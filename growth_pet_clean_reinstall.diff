diff --git a/server/server/home/metin2/Server/share/locale/uk/quest/growth_pet_system.quest b/server/server/home/metin2/Server/share/locale/uk/quest/growth_pet_system.quest
new file mode 100644
index 0000000..d2c807d
--- /dev/null
+++ b/server/server/home/metin2/Server/share/locale/uk/quest/growth_pet_system.quest
@@ -0,0 +1,52 @@
+quest growth_pet_system begin
+	state start begin
+		function get_pet_info(itemVnum)
+			pet_info_map = {
+				[55701] = {34041, " - "..mob_name(34041).." ", 0},
+				[55702] = {34045, " - "..mob_name(34045).." ", 0},
+				[55703] = {34049, " - "..mob_name(34049).." ", 0},
+				[55704] = {34053, " - "..mob_name(34053).." ", 0},
+				[55705] = {34036, " - "..mob_name(34036).." ", 0},
+				[55706] = {34064, " - "..mob_name(34064).." ", 0},
+				[55707] = {34073, " - "..mob_name(34073).." ", 0},
+				[55708] = {34075, " - "..mob_name(34075).." ", 0},
+				[55709] = {34080, " - "..mob_name(34080).." ", 0},
+				[55710] = {34082, " - "..mob_name(34082).." ", 0},
+				[55711] = {34047, " - "..mob_name(34082).." ", 0},
+			}
+
+			itemVnum = tonumber(itemVnum)
+			return pet_info_map[itemVnum]
+		end
+
+		when
+			55701.use or
+			55702.use or
+			55703.use or
+			55704.use or
+			55705.use or
+			55706.use or
+			55707.use or
+			55708.use or
+			55709.use or
+			55710.use or
+			55711.use
+		begin
+			local pet_info = growth_pet_system.get_pet_info(item.get_vnum())
+			if nil != pet_info then
+				local mobVnum = pet_info[1]
+				local petName = pet_info[2]
+
+				if true == growth_pet.is_summon(mobVnum) then
+					growth_pet.unsummon(mobVnum)
+				else
+					if growth_pet.count_summoned() < 1 then
+						growth_pet.summon(mobVnum, petName, false)
+					else
+						syschat(gameforge[LC()][7638])
+					end
+				end
+			end
+		end
+	end
+end
diff --git a/server/server/home/metin2/Server/share/locale/uk/special_item_group.txt b/server/server/home/metin2/Server/share/locale/uk/special_item_group.txt
index e514b6f..4dacf9a 100644
--- a/server/server/home/metin2/Server/share/locale/uk/special_item_group.txt
+++ b/server/server/home/metin2/Server/share/locale/uk/special_item_group.txt
@@ -1,12420 +1,12449 @@
-Group	lv1
-{
-	Vnum	50187 -- Apprentice Chest I
-	Type	Pct
-	1	50188	1	100 -- Apprentice Chest II
-	2	27201	20	100 -- Red Potion (S)
-	3	27204	20	100 -- Blue Potion (S)
-	4	27207	10	100 -- Green Potion (S)
-	5	27210	10	100 -- Purple Potion (S)
-	6	71155	1	100 -- Potion of Wisdom (3h)
-}
-Group	lv10
-{
-	Vnum	50188 -- Apprentice Chest II
-	Type	Pct
-	1	50189	1	100 -- Apprentice Chest III
-	2	76021	1	100 -- Sun Elixir (S)
-	3	76017	5	100 -- Potion of Attack +15
-	4	76012	5	100 -- Potion of Speed
-	5	76008	3	100 -- Medal of the Dragon
-	6	71153	3	100 -- Potion of Wisdom
-	7	56000	1	100 -- Appaloosa
-	8	56001	1	100 -- Village Travel Ticket
-}
-Group	lv20
-{
-	Vnum	50189 -- Apprentice Chest III
-	Type	Pct
-	1	50190	1	100 -- Expert Chest I
-	2	76022	1	100 -- Sun Elixir (M)
-	3	76017	5	100 -- Potion of Attack +15
-	4	76012	5	100 -- Potion of Speed
-	5	76006	1	100 -- Compass for Metin Stones
-	6	76007	1	100 -- Bravery Cape
-	7	38059	1	100 -- Emotion Mask
-	8	71153	3	100 -- Potion of Wisdom
-	9	56001	1	100 -- Village Travel Ticket
-	10	38100	1	100 -- Power Snack (7 days)
-}
-Group	lv30
-{
-	Vnum	50190 -- Expert Chest I
-	Type	Pct
-	1	50191	1	100 -- Expert Chest II
-	2	76012	5	100 -- Potion of Speed
-	3	71034	5	100 -- Potion of Attack +15
-	4	76016	5	100 -- Blessing Scroll
-	5	76011	1	100 -- Book of the Leader
-	6	76007	20	100 -- Bravery Cape
-	7	56001	1	100 -- Village Travel Ticket
-}
-Group	lv40
-{
-	Vnum	50191 -- Expert Chest II
-	Type	Pct
-	1	50192	1	100 -- Expert Chest III
-	2	76003	5	100 -- Potion of Haste
-	3	71034	5	100 -- Potion of Attack +15
-	4	71153	3	100 -- Potion of Wisdom
-	5	76011	1	100 -- Book of the Leader
-	6	76016	5	100 -- Blessing Scroll
-	7	76024	3	100 -- Green Strength
-	8	76023	3	100 -- Green Magic
-	9	76026	3	100 -- Exorcism Scroll
-}
-Group	lv50
-{
-	Vnum	50192 -- Expert Chest III
-	Type	Pct
-	1	50193	1	100 -- Master Chest I
-	2	76007	20	100 -- Bravery Cape
-	3	76003	5	100 -- Potion of Haste
-	4	71034	5	100 -- Potion of Attack +15
-	5	76019	5	100 -- Passage Ticket
-	6	76042	1	100 -- Teleportation Ring
-	7	76026	5	100 -- Exorcism Scroll
-	8	76036	5	100 -- Dragon God Attack
-	9	76035	5	100 -- Dragon God Life
-	10	76037	1	100 -- Thief's Gloves
-	11	76038	1	100 -- Lucky Medal
-}
-Group	lv60
-{
-	Vnum	50193 -- Master Chest I
-	Type	Pct
-	1	50194	1	100 -- Master Chest II
-	2	76009	3	100 -- Dragon Scroll
-	3	71034	5	100 -- Potion of Attack +15
-	4	76000	10	100 -- Peach Flower Wine
-	5	76003	5	100 -- Potion of Haste
-	6	76012	5	100 -- Potion of Speed
-	7	76026	5	100 -- Exorcism Scroll
-	8	76036	5	100 -- Dragon God Attack
-	9	76035	5	100 -- Dragon God Life
-	10	76037	1	100 -- Thief's Gloves
-	11	76038	1	100 -- Lucky Medal
-}
-Group	lv70
-{
-	Vnum	50194 -- Master Chest II
-	Type	Pct
-	1	50195	1	100 -- Master Chest III
-	2	76003	5	100 -- Potion of Haste
-	3	71034	5	100 -- Potion of Attack +15
-	4	76013	5	100 -- Reinforce Item (b)
-	5	76014	5	100 -- Enchant Item (b)
-	6	76001	1	100 -- Status Reset Document
-	7	76012	5	100 -- Potion of Speed
-	8	76026	5	100 -- Exorcism Scroll
-	9	76034	5	100 -- Concentrated Reading
-	10	76036	5	100 -- Dragon God Attack
-	11	76035	5	100 -- Dragon God Life
-	12	76037	1	100 -- Thief's Gloves
-	13	76038	1	100 -- Lucky Medal
-}
-Group	lv80
-{
-	Vnum	50195 -- Master Chest III
-	Type	Pct
-	1	50196	1	100 -- Grand Master Chest
-	2	76003	5	100 -- Potion of Haste
-	3	71034	5	100 -- Potion of Attack +15
-	4	76005	1	100 -- Moon Elixir (M)
-	5	76020	5	100 -- Researcher's Elixir
-	6	76013	5	100 -- Reinforce Item (b)
-	7	76014	5	100 -- Enchant Item (b)
-	8	76012	5	100 -- Potion of Speed
-	9	76026	5	100 -- Exorcism Scroll
-	10	76034	5	100 -- Concentrated Reading
-	11	76036	5	100 -- Dragon God Attack
-	12	76035	5	100 -- Dragon God Life
-	13	76037	1	100 -- Thief's Gloves
-	14	76038	1	100 -- Lucky Medal
-	15	76039	1	100 -- Dragon Chest
-}
-Group	lv90
-{
-	Vnum	50196 -- Grand Master Chest
-	Type	Pct
-	1	76022	1	100 -- Sun Elixir (M)
-	2	76015	2	100 -- Blessing Marble
-	3	76010	3	100 -- Blood Stone
-	4	76002	3	100 -- Shrunken Head
-	5	76013	5	100 -- Reinforce Item (b)
-	6	76014	10	100 -- Enchant Item (b)
-	7	76036	5	100 -- Dragon God Attack
-	8	76035	5	100 -- Dragon God Life
-	9	76019	5	100 -- Passage Ticket
-	10	76039	1	100 -- Dragon Chest
-}
-Group	웅귀족장의상자
-{
-	Vnum	50070 -- Chief Orc's Box
-	1	3140	1	30	30 -- Electromagnetic Blade+0
-	2	3141	1	16	30 -- Electromagnetic Blade+1
-	3	1110	1	30	30 -- Lightning Knife+0
-	4	1111	1	16	30 -- Lightning Knife+1
-	5	2130	1	30	30 -- Divine Apricot Bow+0
-	6	2131	1	16	30 -- Divine Apricot Bow+1
-	7	7140	1	30	30 -- Salvation Fan+0
-	8	7141	1	16	30 -- Salvation Fan+1
-	9	5100	1	30	30 -- Heaven and Earth Bell+0
-	10	5101	1	16	30 -- Heaven and Earth Bell+1
-	11	160	1	30	30 -- Nymph Sword+0
-	12	161	1	16	30 -- Nymph Sword+1
-	13	240	1	30	30 -- Exorcism Sword+0
-	14	241	1	16	30 -- Exorcism Sword+1
-	15	6040	1	33	30 -- Griffon Claw+0
-	16	6041	1	15	30 -- Griffon Claw+1
-	17	11671	1	30	30 -- Ghost Mask Armour+1
-	18	11672	1	5	30 -- Ghost Mask Armour+2
-	19	11271	1	30	30 -- Gold Plate Armour+1
-	20	11272	1	5	30 -- Gold Plate Armour+2
-	21	11471	1	30	30 -- Killer Wind Suit+1
-	22	11472	1	5	30 -- Killer Wind Suit+2
-	23	11871	1	30	30 -- Orange Cat Dress+1
-	24	11872	1	5	30 -- Orange Cat Dress+2
-	25	21051	1	30	30 -- Hobgoblin Plate Armour+1
-	26	21052	1	5	30 -- Hobgoblin Plate Armour+2
-	27	16161	1	30	30 -- Crystal Necklace+1
-	28	16162	1	16	30 -- Crystal Necklace+2
-	29	16163	1	7	30 -- Crystal Necklace+3
-	30	17161	1	30	30 -- Crystal Earrings+1
-	31	17162	1	16	30 -- Crystal Earrings+2
-	32	17163	1	7	30 -- Crystal Earrings+3
-	33	14161	1	30	30 -- Crystal Bracelet+1
-	34	14162	1	16	30 -- Crystal Bracelet+2
-	35	14163	1	7	30 -- Crystal Bracelet+3
-	36	70012	1	25 -- Goddess Tear
-	37	70038	1	25 -- Bravery Cape
-	38	25040	1	30 -- Blessing Scroll
-	39	70048	1	25 -- Cloak of Secrecy
-	40	70037	1	30 -- Book of Forgetfulness
-	41	70014	1	30 -- Blood Pill
-	42	70043	1	25 -- Thief's Gloves
-	43	70005	1	25 -- Experience Ring (1h)
-	44	70006	1	25 -- Language Ring
-	45	돈꾸러미	50000	20 -- Yang
-	46	돈꾸러미	100000	70 -- Yang
-	47	돈꾸러미	200000	9 -- Yang
-	48	27112	10	30 -- Green Potion (L)
-	49	경험치	100000	10 -- Exp.
-	50	60004	1	3	15 -- Looking Glass
-	51	80019	1	3	15 -- Fine Cloth
-	52	38060	1	3	15 -- Bag of Emotions
-}
-Group	밀교교주의상자
-{
-	Vnum	50071 -- Esoteric Leader's Box
-	1	3141	1	33	30 -- Electromagnetic Blade+1
-	2	3142	1	15	30 -- Electromagnetic Blade+2
-	3	1111	1	33	30 -- Lightning Knife+1
-	4	1112	1	15	30 -- Lightning Knife+2
-	5	2131	1	33	30 -- Divine Apricot Bow+1
-	6	2132	1	15	30 -- Divine Apricot Bow+2
-	7	7141	1	33	30 -- Salvation Fan+1
-	8	7142	1	15	30 -- Salvation Fan+2
-	9	5101	1	33	30 -- Heaven and Earth Bell+1
-	10	5102	1	15	30 -- Heaven and Earth Bell+2
-	11	161	1	33	30 -- Nymph Sword+1
-	12	162	1	15	30 -- Nymph Sword+2
-	13	241	1	33	30 -- Exorcism Sword+1
-	14	242	1	15	30 -- Exorcism Sword+2
-	15	6041	1	33	30 -- Griffon Claw+1
-	16	6042	1	15	30 -- Griffon Claw+2
-	17	11672	1	27	30 -- Ghost Mask Armour+2
-	18	11673	1	14	30 -- Ghost Mask Armour+3
-	19	11674	1	5	30 -- Ghost Mask Armour+4
-	20	11272	1	27	30 -- Gold Plate Armour+2
-	21	11273	1	14	30 -- Gold Plate Armour+3
-	22	11274	1	5	30 -- Gold Plate Armour+4
-	23	11472	1	27	30 -- Killer Wind Suit+2
-	24	11473	1	14	30 -- Killer Wind Suit+3
-	25	11474	1	5	30 -- Killer Wind Suit+4
-	26	11872	1	27	30 -- Orange Cat Dress+2
-	27	11873	1	14	30 -- Orange Cat Dress+3
-	28	11874	1	5	30 -- Orange Cat Dress+4
-	29	21052	1	27	30 -- Hobgoblin Plate Armour+2
-	30	21053	1	14	30 -- Hobgoblin Plate Armour+3
-	31	21054	1	5	30 -- Hobgoblin Plate Armour+4
-	32	16181	1	30	30 -- Amethyst Necklace+1
-	33	16182	1	20	30 -- Amethyst Necklace+2
-	34	16183	1	5	30 -- Amethyst Necklace+3
-	35	17181	1	30	30 -- Amethyst Earrings+1
-	36	17182	1	20	30 -- Amethyst Earrings+2
-	37	17183	1	5	30 -- Amethyst Earrings+3
-	38	14181	1	30	30 -- Amethyst Bracelet+1
-	39	14182	1	20	30 -- Amethyst Bracelet+2
-	40	14183	1	5	30 -- Amethyst Bracelet+3
-	41	70012	1	25 -- Goddess Tear
-	42	70038	1	25 -- Bravery Cape
-	43	25040	1	30 -- Blessing Scroll
-	44	70048	1	25 -- Cloak of Secrecy
-	45	70037	1	30 -- Book of Forgetfulness
-	46	70014	1	30 -- Blood Pill
-	47	70043	1	25 -- Thief's Gloves
-	48	70005	1	25 -- Experience Ring (1h)
-	49	돈꾸러미	50000	30 -- Yang
-	50	돈꾸러미	100000	10 -- Yang
-	51	돈꾸러미	200000	20 -- Yang
-	52	경험치	150000	7 -- Exp.
-	53	경험치	200000	8 -- Exp.
-	54	27112	15	25 -- Green Potion (L)
-	55	60004	1	3	15 -- Looking Glass
-	56	80019	1	3	15 -- Fine Cloth
-	57	38060	1	3	15 -- Bag of Emotions
-}
-Group	여왕거미의상자
-{
-	Vnum	50073 -- Queen Spider Box
-	1	3142	1	30	30 -- Electromagnetic Blade+2
-	2	3143	1	16	30 -- Electromagnetic Blade+3
-	3	1112	1	30	30 -- Lightning Knife+2
-	4	1113	1	16	30 -- Lightning Knife+3
-	5	2132	1	30	30 -- Divine Apricot Bow+2
-	6	2133	1	16	30 -- Divine Apricot Bow+3
-	7	7142	1	30	30 -- Salvation Fan+2
-	8	7143	1	16	30 -- Salvation Fan+3
-	9	5102	1	30	30 -- Heaven and Earth Bell+2
-	10	5103	1	16	30 -- Heaven and Earth Bell+3
-	11	162	1	30	30 -- Nymph Sword+2
-	12	163	1	16	30 -- Nymph Sword+3
-	13	242	1	30	30 -- Exorcism Sword+2
-	14	243	1	16	30 -- Exorcism Sword+3
-	15	6042	1	30	30 -- Griffon Claw+2
-	16	6043	1	16	30 -- Griffon Claw+3
-	17	6052	1	30	30 -- Scarab Claw+2
-	18	6053	1	16	30 -- Scarab Claw+3
-	19	11680	1	30	30 -- Spirit Plate Armour+0
-	20	11681	1	6	30 -- Spirit Plate Armour+1
-	21	11880	1	30	30 -- Baroness Dress+0
-	22	11881	1	6	30 -- Baroness Dress+1
-	23	11480	1	30	30 -- Fuchsia Suit+0
-	24	11481	1	6	30 -- Fuchsia Suit+1
-	25	11280	1	30	30 -- Dragon God Armour+0
-	26	11281	1	6	30 -- Dragon God Armour+1
-	27	21060	1	30	30 -- Firellium Plate Armour+0
-	28	21061	1	6	30 -- Firellium Plate Armour+1
-	29	16201	1	30	30 -- Heaven's Tear Necklace+1
-	30	16202	1	16	30 -- Heaven's Tear Necklace+2
-	31	16203	1	7	30 -- Heaven's Tear Necklace+3
-	32	17201	1	30	30 -- Heaven's Tear Earrings+1
-	33	17202	1	16	30 -- Heaven's Tear Earrings+2
-	34	17203	1	7	30 -- Heaven's Tear Earrings+3
-	35	14201	1	30	30 -- Heaven's Tear Bracelet+1
-	36	14202	1	16	30 -- Heaven's Tear Bracelet+2
-	37	14203	1	7	30 -- Heaven's Tear Bracelet+3
-	38	70012	1	25 -- Goddess Tear
-	39	70038	1	25 -- Bravery Cape
-	40	25040	1	30 -- Blessing Scroll
-	41	70048	1	25 -- Cloak of Secrecy
-	42	70037	1	30 -- Book of Forgetfulness
-	43	70014	1	30 -- Blood Pill
-	44	70043	1	25 -- Thief's Gloves
-	45	70005	1	25 -- Experience Ring (1h)
-	46	돈꾸러미	50000	10 -- Yang
-	47	돈꾸러미	100000	30 -- Yang
-	48	돈꾸러미	150000	40 -- Yang
-	49	돈꾸러미	200000	30 -- Yang
-	50	경험치	150000	10 -- Exp.
-	51	경험치	200000	20 -- Exp.
-	52	27112	15	20 -- Green Potion (L)
-	53	60004	1	3	15 -- Looking Glass
-	54	80019	1	3	15 -- Fine Cloth
-	55	38060	1	3	15 -- Bag of Emotions
-}
-Group	대왕거미의상자
-{
-	Vnum	50074 -- Giant Spider Box
-	1	150	1	25	30 -- Ghost Fang Blade+0
-	2	151	1	13	30 -- Ghost Fang Blade+1
-	3	5090	1	25	30 -- Thunder Bird Bell+0
-	4	5091	1	13	30 -- Thunder Bird Bell+1
-	5	140	1	25	30 -- Battle Sword+0
-	6	141	1	13	30 -- Battle Sword+1
-	7	3130	1	25	30 -- Partisan+0
-	8	3131	1	13	30 -- Partisan+1
-	9	1100	1	25	30 -- Dragon Knife+0
-	10	1101	1	13	30 -- Dragon Knife+1
-	11	7130	1	25	30 -- Heavenly Bird Fan+0
-	12	7131	1	13	30 -- Heavenly Bird Fan+1
-	13	2140	1	25	30 -- Yellow Dragon Bow+0
-	14	2141	1	13	30 -- Yellow Dragon Bow+1
-	15	6040	1	25	30 -- Griffon Claw+0
-	16	6041	1	13	30 -- Griffon Claw+1
-	17	6050	1	25	30 -- Scarab Claw+0
-	18	6051	1	13	30 -- Scarab Claw+1
-	19	11681	1	17	30 -- Spirit Plate Armour+1
-	20	11682	1	27	30 -- Spirit Plate Armour+2
-	21	11683	1	11	30 -- Spirit Plate Armour+3
-	22	11881	1	17	30 -- Baroness Dress+1
-	23	11882	1	27	30 -- Baroness Dress+2
-	24	11883	1	11	30 -- Baroness Dress+3
-	25	11481	1	17	30 -- Fuchsia Suit+1
-	26	11482	1	27	30 -- Fuchsia Suit+2
-	27	11483	1	11	30 -- Fuchsia Suit+3
-	28	11281	1	17	30 -- Dragon God Armour+1
-	29	11282	1	27	30 -- Dragon God Armour+2
-	30	11283	1	11	30 -- Dragon God Armour+3
-	31	21061	1	17	30 -- Firellium Plate Armour+1
-	32	21062	1	27	30 -- Firellium Plate Armour+2
-	33	21063	1	11	30 -- Firellium Plate Armour+3
-	34	14163	1	23	30 -- Crystal Bracelet+3
-	35	14164	1	10	30 -- Crystal Bracelet+4
-	36	17163	1	23	30 -- Crystal Earrings+3
-	37	17164	1	10	30 -- Crystal Earrings+4
-	38	16163	1	23	30 -- Crystal Necklace+3
-	39	16164	1	10	30 -- Crystal Necklace+4
-	40	70012	1	25 -- Goddess Tear
-	41	70038	1	25 -- Bravery Cape
-	42	25040	1	30 -- Blessing Scroll
-	43	70048	1	25 -- Cloak of Secrecy
-	44	70037	1	30 -- Book of Forgetfulness
-	45	70014	1	30 -- Blood Pill
-	46	70043	1	25 -- Thief's Gloves
-	47	70005	1	25 -- Experience Ring (1h)
-	48	돈꾸러미	100000	20 -- Yang
-	49	돈꾸러미	150000	30 -- Yang
-	50	돈꾸러미	200000	30 -- Yang
-	51	돈꾸러미	250000	20 -- Yang
-	52	27112	20	20 -- Green Potion (L)
-	53	경험치	150000	30 -- Exp.
-	54	경험치	200000	30 -- Exp.
-	55	경험치	250000	20 -- Exp.
-	56	60004	1	3	15 -- Looking Glass
-	57	80019	1	3	15 -- Fine Cloth
-	58	38060	1	3	15 -- Bag of Emotions
-}
-Group	거대사막거북의상자
-{
-	Vnum	50076 -- Desert Tortoise Chest
-	1	3142	1	24	30 -- Electromagnetic Blade+2
-	2	3143	1	16	30 -- Electromagnetic Blade+3
-	3	1112	1	24	30 -- Lightning Knife+2
-	4	1113	1	16	30 -- Lightning Knife+3
-	5	2132	1	24	30 -- Divine Apricot Bow+2
-	6	2133	1	16	30 -- Divine Apricot Bow+3
-	7	7142	1	24	30 -- Salvation Fan+2
-	8	7143	1	16	30 -- Salvation Fan+3
-	9	5102	1	24	30 -- Heaven and Earth Bell+2
-	10	5103	1	16	30 -- Heaven and Earth Bell+3
-	11	162	1	24	30 -- Nymph Sword+2
-	12	163	1	16	30 -- Nymph Sword+3
-	13	242	1	24	30 -- Exorcism Sword+2
-	14	243	1	16	30 -- Exorcism Sword+3
-	15	6042	1	24	30 -- Griffon Claw+2
-	16	6043	1	16	30 -- Griffon Claw+3
-	17	6052	1	24	30 -- Scarab Claw+2
-	18	6053	1	16	30 -- Scarab Claw+3
-	19	11681	1	24	30 -- Spirit Plate Armour+1
-	20	11682	1	16	30 -- Spirit Plate Armour+2
-	21	11881	1	24	30 -- Baroness Dress+1
-	22	11882	1	16	30 -- Baroness Dress+2
-	23	11481	1	24	30 -- Fuchsia Suit+1
-	24	11482	1	16	30 -- Fuchsia Suit+2
-	25	11281	1	24	30 -- Dragon God Armour+1
-	26	11282	1	16	30 -- Dragon God Armour+2
-	27	21061	1	24	30 -- Firellium Plate Armour+1
-	28	21062	1	16	30 -- Firellium Plate Armour+2
-	29	17184	1	30	30 -- Amethyst Earrings+4
-	30	17185	1	18	30 -- Amethyst Earrings+5
-	31	17186	1	12	30 -- Amethyst Earrings+6
-	32	16184	1	30	30 -- Amethyst Necklace+4
-	33	16185	1	18	30 -- Amethyst Necklace+5
-	34	16186	1	12	30 -- Amethyst Necklace+6
-	35	14184	1	30	30 -- Amethyst Bracelet+4
-	36	14185	1	18	30 -- Amethyst Bracelet+5
-	37	14186	1	12	30 -- Amethyst Bracelet+6
-	38	70012	1	20 -- Goddess Tear
-	39	70038	1	20 -- Bravery Cape
-	40	25040	1	30 -- Blessing Scroll
-	41	70048	1	20 -- Cloak of Secrecy
-	42	70037	1	30 -- Book of Forgetfulness
-	43	70014	1	30 -- Blood Pill
-	44	70043	1	20 -- Thief's Gloves
-	45	70005	1	20 -- Experience Ring (1h)
-	46	경험치	100000	10 -- Exp.
-	47	경험치	150000	20 -- Exp.
-	48	경험치	200000	25 -- Exp.
-	49	경험치	250000	30 -- Exp.
-	50	돈꾸러미	100000	10 -- Yang
-	51	돈꾸러미	150000	20 -- Yang
-	52	돈꾸러미	200000	25 -- Yang
-	53	돈꾸러미	250000	30 -- Yang
-	54	27112	20	20 -- Green Potion (L)
-	55	60004	1	3	15 -- Looking Glass
-	56	80019	1	3	15 -- Fine Cloth
-	57	38060	1	3	15 -- Bag of Emotions
-}
-Group	구미호의상자
-{
-	Vnum	50077 -- Nine Tails' Chest
-	1	151	1	24	30 -- Ghost Fang Blade+1
-	2	152	1	16	30 -- Ghost Fang Blade+2
-	3	5091	1	24	30 -- Thunder Bird Bell+1
-	4	5092	1	16	30 -- Thunder Bird Bell+2
-	5	141	1	24	30 -- Battle Sword+1
-	6	142	1	16	30 -- Battle Sword+2
-	7	3131	1	24	30 -- Partisan+1
-	8	3132	1	16	30 -- Partisan+2
-	9	1101	1	24	30 -- Dragon Knife+1
-	10	1102	1	16	30 -- Dragon Knife+2
-	11	7131	1	24	30 -- Heavenly Bird Fan+1
-	12	7132	1	16	30 -- Heavenly Bird Fan+2
-	13	2141	1	24	30 -- Yellow Dragon Bow+1
-	14	2142	1	16	30 -- Yellow Dragon Bow+2
-	15	6041	1	24	30 -- Griffon Claw+1
-	16	6042	1	16	30 -- Griffon Claw+2
-	17	11682	1	24	30 -- Spirit Plate Armour+2
-	18	11683	1	16	30 -- Spirit Plate Armour+3
-	19	11882	1	24	30 -- Baroness Dress+2
-	20	11883	1	16	30 -- Baroness Dress+3
-	21	11482	1	24	30 -- Fuchsia Suit+2
-	22	11483	1	16	30 -- Fuchsia Suit+3
-	23	11282	1	24	30 -- Dragon God Armour+2
-	24	11283	1	16	30 -- Dragon God Armour+3
-	25	21062	1	16	30 -- Firellium Plate Armour+2
-	26	21063	1	24	30 -- Firellium Plate Armour+3
-	27	17204	1	30	30 -- Heaven's Tear Earrings+4
-	28	17205	1	18	30 -- Heaven's Tear Earrings+5
-	29	17206	1	12	30 -- Heaven's Tear Earrings+6
-	30	16204	1	30	30 -- Heaven's Tear Necklace+4
-	31	16205	1	18	30 -- Heaven's Tear Necklace+5
-	32	16206	1	12	30 -- Heaven's Tear Necklace+6
-	33	14204	1	30	30 -- Heaven's Tear Bracelet+4
-	34	14205	1	18	30 -- Heaven's Tear Bracelet+5
-	35	14206	1	12	30 -- Heaven's Tear Bracelet+6
-	36	70012	1	25 -- Goddess Tear
-	37	70038	1	25 -- Bravery Cape
-	38	25040	1	30 -- Blessing Scroll
-	39	70048	1	25 -- Cloak of Secrecy
-	40	70037	1	30 -- Book of Forgetfulness
-	41	70014	1	30 -- Blood Pill
-	42	70043	1	25 -- Thief's Gloves
-	43	70005	1	25 -- Experience Ring (1h)
-	44	경험치	150000	20 -- Exp.
-	45	경험치	200000	30 -- Exp.
-	46	경험치	250000	20 -- Exp.
-	47	돈꾸러미	150000	20 -- Yang
-	48	돈꾸러미	200000	30 -- Yang
-	49	돈꾸러미	250000	20 -- Yang
-	50	27112	20	25 -- Green Potion (L)
-	51	60004	1	3	15 -- Looking Glass
-	52	80019	1	3	15 -- Fine Cloth
-	53	38060	1	3	15 -- Bag of Emotions
-}
-Group	누렁범귀의상자
-{
-	Vnum	50078 -- Yellow Tiger's Chest
-	1	152	1	22	30 -- Ghost Fang Blade+2
-	2	153	1	16	30 -- Ghost Fang Blade+3
-	3	5092	1	22	30 -- Thunder Bird Bell+2
-	4	5093	1	16	30 -- Thunder Bird Bell+3
-	5	142	1	22	30 -- Battle Sword+2
-	6	143	1	16	30 -- Battle Sword+3
-	7	3132	1	22	30 -- Partisan+2
-	8	3133	1	16	30 -- Partisan+3
-	9	1102	1	22	30 -- Dragon Knife+2
-	10	1103	1	16	30 -- Dragon Knife+3
-	11	7132	1	22	30 -- Heavenly Bird Fan+2
-	12	7133	1	16	30 -- Heavenly Bird Fan+3
-	13	2142	1	22	30 -- Yellow Dragon Bow+2
-	14	2143	1	16	30 -- Yellow Dragon Bow+3
-	15	6052	1	22	30 -- Scarab Claw+2
-	16	6053	1	16	30 -- Scarab Claw+3
-	17	6062	1	22	30 -- Hawk Claw+2
-	18	6063	1	16	30 -- Hawk Claw+3
-	19	11682	1	19	30 -- Spirit Plate Armour+2
-	20	11683	1	28	30 -- Spirit Plate Armour+3
-	21	11684	1	10	30 -- Spirit Plate Armour+4
-	22	11882	1	19	30 -- Baroness Dress+2
-	23	11883	1	28	30 -- Baroness Dress+3
-	24	11884	1	10	30 -- Baroness Dress+4
-	25	11482	1	19	30 -- Fuchsia Suit+2
-	26	11483	1	28	30 -- Fuchsia Suit+3
-	27	11484	1	10	30 -- Fuchsia Suit+4
-	28	11282	1	19	30 -- Dragon God Armour+2
-	29	11283	1	28	30 -- Dragon God Armour+3
-	30	11284	1	10	30 -- Dragon God Armour+4
-	31	21062	1	19	30 -- Firellium Plate Armour+2
-	32	21063	1	28	30 -- Firellium Plate Armour+3
-	33	21064	1	10	30 -- Firellium Plate Armour+4
-	34	17184	1	19	30 -- Amethyst Earrings+4
-	35	17185	1	28	30 -- Amethyst Earrings+5
-	36	17186	1	10	30 -- Amethyst Earrings+6
-	37	16184	1	19	30 -- Amethyst Necklace+4
-	38	16185	1	28	30 -- Amethyst Necklace+5
-	39	16186	1	10	30 -- Amethyst Necklace+6
-	40	14184	1	19	30 -- Amethyst Bracelet+4
-	41	14185	1	28	30 -- Amethyst Bracelet+5
-	42	14186	1	10	30 -- Amethyst Bracelet+6
-	43	70012	1	20 -- Goddess Tear
-	44	70038	1	20 -- Bravery Cape
-	45	25040	1	25 -- Blessing Scroll
-	46	70048	1	20 -- Cloak of Secrecy
-	47	70037	1	25 -- Book of Forgetfulness
-	48	70014	1	25 -- Blood Pill
-	49	70043	1	20 -- Thief's Gloves
-	50	70005	1	20 -- Experience Ring (1h)
-	51	경험치	200000	20 -- Exp.
-	52	경험치	250000	30 -- Exp.
-	53	경험치	300000	20 -- Exp.
-	54	돈꾸러미	200000	20 -- Yang
-	55	돈꾸러미	250000	30 -- Yang
-	56	돈꾸러미	300000	20 -- Yang
-	57	27112	30	20 -- Green Potion (L)
-	58	60004	1	3	15 -- Looking Glass
-	59	80019	1	3	15 -- Fine Cloth
-	60	38060	1	3	15 -- Bag of Emotions
-}
-Group	화염왕의상자
-{
-	Vnum	50079 -- Flame King's Chest
-	1	151	1	10	30 -- Ghost Fang Blade+1
-	2	152	1	25	30 -- Ghost Fang Blade+2
-	3	153	1	15	30 -- Ghost Fang Blade+3
-	4	5091	1	10	30 -- Thunder Bird Bell+1
-	5	5092	1	25	30 -- Thunder Bird Bell+2
-	6	5093	1	15	30 -- Thunder Bird Bell+3
-	7	141	1	10	30 -- Battle Sword+1
-	8	142	1	25	30 -- Battle Sword+2
-	9	143	1	15	30 -- Battle Sword+3
-	10	3131	1	10	30 -- Partisan+1
-	11	3132	1	25	30 -- Partisan+2
-	12	3133	1	15	30 -- Partisan+3
-	13	1101	1	10	30 -- Dragon Knife+1
-	14	1102	1	25	30 -- Dragon Knife+2
-	15	1103	1	15	30 -- Dragon Knife+3
-	16	7131	1	10	30 -- Heavenly Bird Fan+1
-	17	7132	1	25	30 -- Heavenly Bird Fan+2
-	18	7133	1	15	30 -- Heavenly Bird Fan+3
-	19	2141	1	10	30 -- Yellow Dragon Bow+1
-	20	2142	1	25	30 -- Yellow Dragon Bow+2
-	21	2143	1	15	30 -- Yellow Dragon Bow+3
-	22	6051	1	10	30 -- Scarab Claw+1
-	23	6052	1	25	30 -- Scarab Claw+2
-	24	6053	1	10	30 -- Scarab Claw+3
-	25	6061	1	10	30 -- Hawk Claw+1
-	26	6062	1	25	30 -- Hawk Claw+2
-	27	6063	1	15	30 -- Hawk Claw+3
-	28	11681	1	9	30 -- Spirit Plate Armour+1
-	29	11682	1	24	30 -- Spirit Plate Armour+2
-	30	11683	1	14	30 -- Spirit Plate Armour+3
-	31	11881	1	9	30 -- Baroness Dress+1
-	32	11882	1	24	30 -- Baroness Dress+2
-	33	11883	1	14	30 -- Baroness Dress+3
-	34	11481	1	9	30 -- Fuchsia Suit+1
-	35	11482	1	24	30 -- Fuchsia Suit+2
-	36	11483	1	14	30 -- Fuchsia Suit+3
-	37	11281	1	9	30 -- Dragon God Armour+1
-	38	11282	1	24	30 -- Dragon God Armour+2
-	39	11283	1	14	30 -- Dragon God Armour+3
-	40	21061	1	9	30 -- Firellium Plate Armour+1
-	41	21062	1	24	30 -- Firellium Plate Armour+2
-	42	21063	1	14	30 -- Firellium Plate Armour+3
-	43	17164	1	9	30 -- Crystal Earrings+4
-	44	17165	1	24	30 -- Crystal Earrings+5
-	45	17166	1	14	30 -- Crystal Earrings+6
-	46	16164	1	9	30 -- Crystal Necklace+4
-	47	16165	1	24	30 -- Crystal Necklace+5
-	48	16166	1	14	30 -- Crystal Necklace+6
-	49	14164	1	9	30 -- Crystal Bracelet+4
-	50	14165	1	24	30 -- Crystal Bracelet+5
-	51	14166	1	14	30 -- Crystal Bracelet+6
-	52	70012	1	15 -- Goddess Tear
-	53	70038	1	15 -- Bravery Cape
-	54	25040	1	21 -- Blessing Scroll
-	55	70048	1	20 -- Cloak of Secrecy
-	56	70037	1	25 -- Book of Forgetfulness
-	57	70014	1	25 -- Blood Pill
-	58	70043	1	20 -- Thief's Gloves
-	59	70005	1	20 -- Experience Ring (1h)
-	60	경험치	150000	5 -- Exp.
-	61	경험치	200000	10 -- Exp.
-	62	경험치	250000	10 -- Exp.
-	63	경험치	300000	15 -- Exp.
-	64	돈꾸러미	150000	20 -- Yang
-	65	돈꾸러미	200000	25 -- Yang
-	66	돈꾸러미	250000	30 -- Yang
-	67	돈꾸러미	300000	25 -- Yang
-	68	27112	25	20 -- Green Potion (L)
-	69	60004	1	3	15 -- Looking Glass
-	70	80019	1	3	15 -- Fine Cloth
-	71	38060	1	3	15 -- Bag of Emotions
-}
-Group	사귀왕의상자
-{
-	Vnum	50080 -- Red Dragon's Chest
-	1	50513	1	100 -- Soul Stone
-}
-Group	사귀왕의상자
-{
-	Vnum	50081 -- Demon King's Chest
-	1	152	1	22	30 -- Ghost Fang Blade+2
-	2	153	1	16	30 -- Ghost Fang Blade+3
-	3	5092	1	22	30 -- Thunder Bird Bell+2
-	4	5093	1	16	30 -- Thunder Bird Bell+3
-	5	142	1	22	30 -- Battle Sword+2
-	6	143	1	16	30 -- Battle Sword+3
-	7	3132	1	22	30 -- Partisan+2
-	8	3133	1	16	30 -- Partisan+3
-	9	1102	1	22	30 -- Dragon Knife+2
-	10	1103	1	16	30 -- Dragon Knife+3
-	11	7132	1	22	30 -- Heavenly Bird Fan+2
-	12	7133	1	16	30 -- Heavenly Bird Fan+3
-	13	2142	1	22	30 -- Yellow Dragon Bow+2
-	14	2143	1	16	30 -- Yellow Dragon Bow+3
-	15	6052	1	22	30 -- Scarab Claw+2
-	16	6053	1	16	30 -- Scarab Claw+3
-	17	6042	1	22	30 -- Griffon Claw+2
-	18	6043	1	16	30 -- Griffon Claw+3
-	19	11682	1	19	30 -- Spirit Plate Armour+2
-	20	11683	1	28	30 -- Spirit Plate Armour+3
-	21	11684	1	10	30 -- Spirit Plate Armour+4
-	22	11882	1	19	30 -- Baroness Dress+2
-	23	11883	1	28	30 -- Baroness Dress+3
-	24	11884	1	10	30 -- Baroness Dress+4
-	25	11482	1	19	30 -- Fuchsia Suit+2
-	26	11483	1	28	30 -- Fuchsia Suit+3
-	27	11484	1	10	30 -- Fuchsia Suit+4
-	28	11282	1	19	30 -- Dragon God Armour+2
-	29	11283	1	28	30 -- Dragon God Armour+3
-	30	11284	1	10	30 -- Dragon God Armour+4
-	31	21062	1	19	30 -- Firellium Plate Armour+2
-	32	21063	1	28	30 -- Firellium Plate Armour+3
-	33	21064	1	10	30 -- Firellium Plate Armour+4
-	34	17184	1	19	30 -- Amethyst Earrings+4
-	35	17185	1	28	30 -- Amethyst Earrings+5
-	36	17186	1	10	30 -- Amethyst Earrings+6
-	37	16184	1	19	30 -- Amethyst Necklace+4
-	38	16185	1	28	30 -- Amethyst Necklace+5
-	39	16186	1	10	30 -- Amethyst Necklace+6
-	40	14184	1	19	30 -- Amethyst Bracelet+4
-	41	14185	1	28	30 -- Amethyst Bracelet+5
-	42	14186	1	10	30 -- Amethyst Bracelet+6
-	43	70012	1	20 -- Goddess Tear
-	44	70038	1	20 -- Bravery Cape
-	45	25040	1	25 -- Blessing Scroll
-	46	70048	1	20 -- Cloak of Secrecy
-	47	70037	1	25 -- Book of Forgetfulness
-	48	70014	1	25 -- Blood Pill
-	49	70043	1	20 -- Thief's Gloves
-	50	70005	1	20 -- Experience Ring (1h)
-	51	경험치	200000	20 -- Exp.
-	52	경험치	250000	30 -- Exp.
-	53	경험치	300000	20 -- Exp.
-	54	돈꾸러미	200000	20 -- Yang
-	55	돈꾸러미	250000	30 -- Yang
-	56	돈꾸러미	300000	20 -- Yang
-	57	27112	30	20 -- Green Potion (L)
-	58	60004	1	3	15 -- Looking Glass
-	59	80019	1	3	15 -- Fine Cloth
-	60	38060	1	3	15 -- Bag of Emotions
-}
-Group	사신의상자
-{
-	Vnum	50082 -- Grim Reaper's Chest
-	1	170	1	16	30 -- Sting Sword+0
-	2	250	1	16	30 -- Demon Blade+0
-	3	1120	1	16	30 -- Siamese Knife+0
-	4	2180	1	16	30 -- Blue Dragon Bow+0
-	5	3150	1	16	30 -- Soul Stealing Blade+0
-	6	7150	1	16	30 -- Ecstasy Fan+0
-	7	6060	1	16	30 -- Hawk Claw+0
-	8	11290	1	31	30 -- Black Steel Armour+0
-	9	11291	1	15	30 -- Black Steel Armour+1
-	10	11490	1	31	30 -- Black Wind Suit+0
-	11	11491	1	15	30 -- Black Wind Suit+1
-	12	11690	1	31	30 -- Magic Plate Armour+0
-	13	11691	1	15	30 -- Magic Plate Armour+1
-	14	11890	1	31	30 -- Black Clothing+0
-	15	11891	1	15	30 -- Black Clothing+1
-	16	21070	1	31	30 -- Nightshade Armour+0
-	17	21071	1	15	30 -- Nightshade Armour+1
-	18	152	1	22	30 -- Ghost Fang Blade+2
-	19	153	1	16	30 -- Ghost Fang Blade+3
-	20	5092	1	22	30 -- Thunder Bird Bell+2
-	21	5093	1	16	30 -- Thunder Bird Bell+3
-	22	142	1	22	30 -- Battle Sword+2
-	23	143	1	16	30 -- Battle Sword+3
-	24	3132	1	22	30 -- Partisan+2
-	25	3133	1	16	30 -- Partisan+3
-	26	1102	1	22	30 -- Dragon Knife+2
-	27	1103	1	16	30 -- Dragon Knife+3
-	28	7132	1	22	30 -- Heavenly Bird Fan+2
-	29	7133	1	16	30 -- Heavenly Bird Fan+3
-	30	2142	1	22	30 -- Yellow Dragon Bow+2
-	31	2143	1	16	30 -- Yellow Dragon Bow+3
-	32	6041	1	22	30 -- Griffon Claw+1
-	33	6042	1	16	30 -- Griffon Claw+2
-	34	6051	1	22	30 -- Scarab Claw+1
-	35	6052	1	16	30 -- Scarab Claw+2
-	36	11682	1	19	30 -- Spirit Plate Armour+2
-	37	11683	1	28	30 -- Spirit Plate Armour+3
-	38	11684	1	10	30 -- Spirit Plate Armour+4
-	39	11882	1	19	30 -- Baroness Dress+2
-	40	11883	1	28	30 -- Baroness Dress+3
-	41	11884	1	10	30 -- Baroness Dress+4
-	42	11482	1	19	30 -- Fuchsia Suit+2
-	43	11483	1	28	30 -- Fuchsia Suit+3
-	44	11484	1	10	30 -- Fuchsia Suit+4
-	45	11282	1	19	30 -- Dragon God Armour+2
-	46	11283	1	28	30 -- Dragon God Armour+3
-	47	11284	1	10	30 -- Dragon God Armour+4
-	48	21061	1	19	30 -- Firellium Plate Armour+1
-	49	21062	1	28	30 -- Firellium Plate Armour+2
-	50	21063	1	10	30 -- Firellium Plate Armour+3
-	51	180	1	4	30 -- Poison Sword+0
-	52	190	1	4	30 -- Lion Sword+0
-	53	1130	1	10	30 -- Devil Wing Chakram+0
-	54	2170	1	10	30 -- Crow Steel Bow+0
-	55	3160	1	10	30 -- Grudge Sword+0
-	56	5120	1	10	30 -- Bamboo Bell+0
-	57	6070	1	10	30 -- Thorned Claw+0
-	58	60004	1	3	15 -- Looking Glass
-	59	80019	1	3	15 -- Fine Cloth
-	60	38060	1	3	15 -- Bag of Emotions
-}
-Group	진구미호의상자
-{
-	Vnum	50090 -- Box of Fox nine o' Tails
-	1	170	1	16	20 -- Sting Sword+0
-	2	250	1	16	20 -- Demon Blade+0
-	3	1120	1	16	20 -- Siamese Knife+0
-	4	2180	1	16	20 -- Blue Dragon Bow+0
-	5	3150	1	16	20 -- Soul Stealing Blade+0
-	6	7150	1	16	20 -- Ecstasy Fan+0
-	7	6060	1	16	20 -- Hawk Claw+0
-	8	11290	1	31	20 -- Black Steel Armour+0
-	9	11291	1	15	20 -- Black Steel Armour+1
-	10	11490	1	31	20 -- Black Wind Suit+0
-	11	11491	1	15	20 -- Black Wind Suit+1
-	12	11690	1	31	20 -- Magic Plate Armour+0
-	13	11691	1	15	20 -- Magic Plate Armour+1
-	14	11890	1	31	20 -- Black Clothing+0
-	15	11891	1	15	20 -- Black Clothing+1
-	16	21070	1	31	20 -- Nightshade Armour+0
-	17	21071	1	15	20 -- Nightshade Armour+1
-	18	17204	1	60	20 -- Heaven's Tear Earrings+4
-	19	17205	1	40	20 -- Heaven's Tear Earrings+5
-	20	17206	1	20	20 -- Heaven's Tear Earrings+6
-	21	16204	1	60	20 -- Heaven's Tear Necklace+4
-	22	16205	1	40	20 -- Heaven's Tear Necklace+5
-	23	16206	1	20	20 -- Heaven's Tear Necklace+6
-	24	14204	1	60	20 -- Heaven's Tear Bracelet+4
-	25	14205	1	40	20 -- Heaven's Tear Bracelet+5
-	26	14206	1	20	20 -- Heaven's Tear Bracelet+6
-	27	경험치	500000	100 -- Exp.
-	28	경험치	700000	60 -- Exp.
-	29	경험치	1000000	20 -- Exp.
-	30	돈꾸러미	300000	100 -- Yang
-	31	돈꾸러미	500000	60 -- Yang
-	32	돈꾸러미	1000000	20 -- Yang
-	33	38060	1	5 -- Bag of Emotions
-}
-Group	아귀대제의상자
-{
-	Vnum	50186 -- Azrael's Chest
-	1	172	1	25 -- Sting Sword+2
-	2	252	1	25 -- Demon Blade+2
-	3	1122	1	25 -- Siamese Knife+2
-	4	2182	1	25 -- Blue Dragon Bow+2
-	5	3152	1	25 -- Soul Stealing Blade+2
-	6	7152	1	25 -- Ecstasy Fan+2
-	7	6062	1	25 -- Hawk Claw+2
-	8	11291	1	30 -- Black Steel Armour+1
-	9	11292	1	20 -- Black Steel Armour+2
-	10	11491	1	30 -- Black Wind Suit+1
-	11	11492	1	20 -- Black Wind Suit+2
-	12	11691	1	30 -- Magic Plate Armour+1
-	13	11692	1	20 -- Magic Plate Armour+2
-	14	11891	1	30 -- Black Clothing+1
-	15	11892	1	20 -- Black Clothing+2
-	16	21071	1	20 -- Nightshade Armour+1
-	17	21072	1	20 -- Nightshade Armour+2
-	18	17204	1	30 -- Heaven's Tear Earrings+4
-	19	17205	1	20 -- Heaven's Tear Earrings+5
-	20	17206	1	10 -- Heaven's Tear Earrings+6
-	21	16204	1	30 -- Heaven's Tear Necklace+4
-	22	16205	1	20 -- Heaven's Tear Necklace+5
-	23	16206	1	10 -- Heaven's Tear Necklace+6
-	24	14204	1	30 -- Heaven's Tear Bracelet+4
-	25	14205	1	20 -- Heaven's Tear Bracelet+5
-	26	14206	1	10 -- Heaven's Tear Bracelet+6
-	27	12260	1	7 -- Fear Mask +0
-	28	12280	1	5 -- War Master Helmet +0
-	29	12390	1	7 -- Orc Hood +0
-	30	12400	1	5 -- Spider Hood +0
-	31	12530	1	7 -- Horned Helmet +0
-	32	12540	1	5 -- Magic Helmet +0
-	33	12670	1	7 -- Cardinal's Hat +0
-	34	12680	1	5 -- Soul Shard Hat +0
-	35	21530	1	7 -- Godsend Helmet+0
-	36	21540	1	5 -- Viridian Wood Helmet+0
-	37	13140	1	5 -- Titan Shield+0
-	38	14220	1	5 -- Soul Crystal Bracelet+0
-	39	16220	1	5 -- Soul Crystal Necklace+0
-	40	17220	1	5 -- Soul Crystal Earrings+0
-	41	돈꾸러미	500000	40 -- Yang
-	42	27002	200	100 -- Red Potion (M)
-	43	27003	100	100 -- Red Potion (L)
-	44	27005	200	100 -- Blue Potion (M)
-	45	27006	100	100 -- Blue Potion (L)
-	46	80019	1	5 -- Fine Cloth
-	47	60004	1	5 -- Looking Glass
-}
-Group	w20보스상
-{
-	Vnum	50254
-	1	174	1	25 -- Sting Sword+4
-	2	254	1	25 -- Demon Blade+4
-	3	1124	1	25 -- Siamese Knife+4
-	4	2184	1	25 -- Blue Dragon Bow+4
-	5	3154	1	25 -- Soul Stealing Blade+4
-	6	7154	1	25 -- Ecstasy Fan+4
-	7	6064	1	25 -- Hawk Claw+4
-	8	11293	1	30 -- Black Steel Armour+3
-	9	11294	1	20 -- Black Steel Armour+4
-	10	11493	1	30 -- Black Wind Suit+3
-	11	11494	1	20 -- Black Wind Suit+4
-	12	11693	1	30 -- Magic Plate Armour+3
-	13	11694	1	20 -- Magic Plate Armour+4
-	14	11893	1	30 -- Black Clothing+3
-	15	11894	1	20 -- Black Clothing+4
-	16	21073	1	30 -- Nightshade Armour+3
-	17	21074	1	20 -- Nightshade Armour+4
-	18	17205	1	30 -- Heaven's Tear Earrings+5
-	19	17206	1	20 -- Heaven's Tear Earrings+6
-	20	17207	1	10 -- Heaven's Tear Earrings+7
-	21	16205	1	30 -- Heaven's Tear Necklace+5
-	22	16206	1	20 -- Heaven's Tear Necklace+6
-	23	16207	1	10 -- Heaven's Tear Necklace+7
-	24	14205	1	30 -- Heaven's Tear Bracelet+5
-	25	14206	1	20 -- Heaven's Tear Bracelet+6
-	26	14207	1	10 -- Heaven's Tear Bracelet+7
-	27	12260	1	7 -- Fear Mask +0
-	28	12280	1	5 -- War Master Helmet +0
-	29	12390	1	7 -- Orc Hood +0
-	30	12400	1	5 -- Spider Hood +0
-	31	12530	1	7 -- Horned Helmet +0
-	32	12540	1	5 -- Magic Helmet +0
-	33	12670	1	7 -- Cardinal's Hat +0
-	34	12680	1	5 -- Soul Shard Hat +0
-	35	21530	1	7 -- Godsend Helmet+0
-	36	21540	1	5 -- Viridian Wood Helmet+0
-	37	13140	1	5 -- Titan Shield+0
-	38	14220	1	5 -- Soul Crystal Bracelet+0
-	39	16220	1	5 -- Soul Crystal Necklace+0
-	40	17220	1	5 -- Soul Crystal Earrings+0
-	41	155	1	7 -- Ghost Fang Blade+5
-	42	156	1	6 -- Ghost Fang Blade+6
-	43	157	1	5 -- Ghost Fang Blade+7
-	44	1105	1	7 -- Dragon Knife+5
-	45	1106	1	6 -- Dragon Knife+6
-	46	1107	1	5 -- Dragon Knife+7
-	47	2145	1	7 -- Yellow Dragon Bow+5
-	48	2146	1	6 -- Yellow Dragon Bow+6
-	49	2147	1	5 -- Yellow Dragon Bow+7
-	50	3145	1	7 -- Electromagnetic Blade+5
-	51	3146	1	6 -- Electromagnetic Blade+6
-	52	3147	1	5 -- Electromagnetic Blade+7
-	53	5105	1	7 -- Heaven and Earth Bell+5
-	54	5106	1	6 -- Heaven and Earth Bell+6
-	55	5107	1	5 -- Heaven and Earth Bell+7
-	56	7145	1	7 -- Salvation Fan+5
-	57	7146	1	6 -- Salvation Fan+6
-	58	7147	1	5 -- Salvation Fan+7
-	59	6045	1	7 -- Griffon Claw+5
-	60	6046	1	6 -- Griffon Claw+6
-	61	6047	1	5 -- Griffon Claw+7
-	62	11295	1	7 -- Black Steel Armour+5
-	63	11296	1	6 -- Black Steel Armour+6
-	64	11297	1	5 -- Black Steel Armour+7
-	65	11495	1	7 -- Black Wind Suit+5
-	66	11496	1	6 -- Black Wind Suit+6
-	67	11497	1	5 -- Black Wind Suit+7
-	68	11695	1	7 -- Magic Plate Armour+5
-	69	11696	1	6 -- Magic Plate Armour+6
-	70	11697	1	5 -- Magic Plate Armour+7
-	71	11895	1	7 -- Black Clothing+5
-	72	11896	1	6 -- Black Clothing+6
-	73	11897	1	5 -- Black Clothing+7
-	74	21075	1	30 -- Nightshade Armour+5
-	75	21076	1	30 -- Nightshade Armour+6
-	76	21077	1	20 -- Nightshade Armour+7
-	77	460	1	1 -- Rune Sword +0
-	78	470	1	1 -- Dragon Tooth Blade +0
-	79	1340	1	1 -- Five Element Blade +0
-	80	2370	1	1 -- Phoenix Bow +0
-	81	3190	1	1 -- Solar Blade +0
-	82	5340	1	1 -- Dragon Ghost Bell +0
-	83	7370	1	1 -- Lying Dragon Fan+0
-	84	20000	1	1 -- Devil's Horn Armour+0
-	85	20250	1	1 -- Dragon Rider Suit+0
-	86	20500	1	1 -- Bone Plated Armour+0
-	87	20750	1	1 -- Golden Clothing+0
-	88	21090	1	1 -- Warlord Armour+0
-	89	14500	1	3 -- Ruby Bracelet+0
-	90	14520	1	3 -- Garnet Bracelet+0
-	91	14540	1	3 -- Emerald Bracelet+0
-	92	14560	1	3 -- Sapphire Bracelet+0
-	93	14570	1	3 -- Tourmaline Bracelet+0
-	94	16500	1	3 -- Ruby Necklace+0
-	95	16520	1	3 -- Garnet Necklace+0
-	96	16540	1	3 -- Emerald Necklace+0
-	97	16560	1	3 -- Sapphire Necklace+0
-	98	16570	1	3 -- Tourmaline Necklace+0
-	99	17500	1	3 -- Ruby Earrings+0
-	100	17520	1	3 -- Garnet Earrings+0
-	101	17540	1	3 -- Emerald Earrings+0
-	102	17560	1	3 -- Sapphire Earrings+0
-	103	gold	50000	70 -- Yang
-	104	gold	100000	60 -- Yang
-	105	gold	200000	50 -- Yang
-	106	gold	300000	40 -- Yang
-	107	gold	400000	30 -- Yang
-	108	gold	500000	20 -- Yang
-	109	exp	500000	40 -- Exp.
-	110	27002	200	100 -- Red Potion (M)
-	111	27003	100	100 -- Red Potion (L)
-	112	27005	200	100 -- Blue Potion (M)
-	113	27006	100	100 -- Blue Potion (L)
-	114	39004	1	5 -- Blessing Marble
-	115	71130	1	5 -- Passage Ticket
-	116	70024	1	5 -- Blessing Marble
-	117	80019	1	5 -- Fine Cloth
-	118	60004	1	5 -- Looking Glass
-}
-Group	SpiritStoneBundle
-{
-	Vnum	72058 -- Spirit Stone Bundle
-	1	28012	1	100 -- Stone against Lycans+0
-	2	28030	1	100 -- Stone of Penetration+0
-	3	28031	1	100 -- Stone of Deathblow+0
-	4	28032	1	100 -- Stone of Cooldown+0
-	5	28033	1	100 -- Stone against Warriors+0
-	6	28034	1	100 -- Stone against Ninjas+0
-	7	28035	1	100 -- Stone against Suras+0
-	8	28036	1	100 -- Stone against Shamans+0
-	9	28037	1	100 -- Stone of Monsters+0
-	10	28038	1	100 -- Stone of Evasion+0
-	11	28039	1	100 -- Stone of Ducking+0
-	12	28040	1	100 -- Stone of Magic+0
-	13	28041	1	100 -- Stone of Vitality+0
-	14	28042	1	100 -- Stone of Defence+0
-	15	28043	1	100 -- Stone of Haste+0
-	16	28044	1	100 -- Anti-Magic Stone+0
-	17	28112	1	100 -- Stone against Lycans+1
-	18	28130	1	100 -- Stone of Penetration+1
-	19	28131	1	100 -- Stone of Deathblow+1
-	20	28132	1	100 -- Stone of Cooldown+1
-	21	28133	1	100 -- Stone against Warriors+1
-	22	28134	1	100 -- Stone against Ninjas+1
-	23	28135	1	100 -- Stone against Suras+1
-	24	28136	1	100 -- Stone against Shamans+1
-	25	28137	1	100 -- Stone of Monsters+1
-	26	28138	1	100 -- Stone of Evasion+1
-	27	28139	1	100 -- Stone of Ducking+1
-	28	28140	1	100 -- Stone of Magic+1
-	29	28141	1	100 -- Stone of Vitality+1
-	30	28142	1	100 -- Stone of Defence+1
-	31	28143	1	100 -- Stone of Haste+1
-	32	28144	1	100 -- Anti-Magic Stone+1
-	33	28212	1	100 -- Stone against Lycans+2
-	34	28230	1	100 -- Stone of Penetration+2
-	35	28231	1	100 -- Stone of Deathblow+2
-	36	28232	1	100 -- Stone of Cooldown+2
-	37	28233	1	100 -- Stone against Warriors+2
-	38	28234	1	100 -- Stone against Ninjas+2
-	39	28235	1	100 -- Stone against Suras+2
-	40	28236	1	100 -- Stone against Shamans+2
-	41	28237	1	100 -- Stone of Monsters+2
-	42	28238	1	100 -- Stone of Evasion+2
-	43	28239	1	100 -- Stone of Ducking+2
-	44	28240	1	100 -- Stone of Magic+2
-	45	28241	1	100 -- Stone of Vitality+2
-	46	28242	1	100 -- Stone of Defence+2
-	47	28243	1	100 -- Stone of Haste+2
-	48	28244	1	100 -- Anti-Magic Stone+2
-	49	28312	1	100 -- Stone against Lycans+3
-	50	28330	1	100 -- Stone of Penetration+3
-	51	28331	1	100 -- Stone of Deathblow+3
-	52	28332	1	100 -- Stone of Cooldown+3
-	53	28333	1	100 -- Stone against Warriors+3
-	54	28334	1	100 -- Stone against Ninjas+3
-	55	28335	1	100 -- Stone against Suras+3
-	56	28336	1	100 -- Stone against Shamans+3
-	57	28337	1	100 -- Stone of Monsters+3
-	58	28338	1	100 -- Stone of Evasion+3
-	59	28339	1	100 -- Stone of Ducking+3
-	60	28340	1	100 -- Stone of Magic+3
-	61	28341	1	100 -- Stone of Vitality+3
-	62	28342	1	100 -- Stone of Defence+3
-	63	28343	1	100 -- Stone of Haste+3
-	64	28344	1	100 -- Anti-Magic Stone+3
-}
-Group	GoldenKingLoot
-{
-	Vnum	50928 -- Golden King's Loot
-	1	25041	1	100 -- Magic Stone
-	2	76013	1	100 -- Reinforce Item (b)
-	3	76014	1	100 -- Enchant Item (b)
-	4	71189	1	100 -- Enchant Item+
-	5	39015	1	100 -- Stone of the Blacksmith
-	6	71158	1	100 -- Hero's Medal
-	7	71128	1	100 -- Battle Lion
-	8	71127	1	100 -- Storm Tiger
-	9	51505	1	100 -- Cor Draconis (Precious)
-	10	51506	1	100 -- Cor Draconis (Mystical)
-	11	51639	1	100 -- Dragon Chest
-	12	76029	1	100 -- Green Dragon Bean
-	13	30618	1	100 -- Moonstone
-	14	30617	1	100 -- Agate
-	15	30616	1	100 -- Titanium Dioxide
-	16	55403	1	100 -- Razador's Egg
-	17	55404	1	100 -- Nemere's Egg
-	18	71153	1	100 -- Potion of Wisdom
-	19	50513	1	100 -- Soul Stone
-	20	50011	1	100 -- Moonlight Treasure Chest
-	21	50108	20	100 -- Fireworks Top
-	22	50107	20	100 -- Chinese Fire Cracker
-	23	27992	1	100 -- White Pearl
-	24	76016	1	100 -- Blessing Scroll
-	25	71095	3	100 -- Passage Ticket
-	26	72727	1	100 -- Moon Elixir (S)
-	27	72723	1	100 -- Sun Elixir (S)
-	28	70069	5	100 -- Peach Flower Wine XL
-	29	76033	10	100 -- Peach Flower Wine+
-	30	72058	10	100 -- Spirit Stone Bundle
-	31	76012	5	100 -- Potion of Speed
-	32	76017	5	100 -- Potion of Attack +15
-	33	76003	5	100 -- Potion of Haste
-	34	79604	1	100 -- King Deck
-}
-Group	SilverKingLoot
-{
-	Vnum	50929 -- Silver King's Loot
-	1	25041	1	100 -- Magic Stone
-	2	71189	1	100 -- Enchant Item+
-	3	76013	1	100 -- Reinforce Item (b)
-	4	76014	1	100 -- Enchant Item (b)
-	5	85001	1	100 -- Lord Sash (basic)
-	6	51503	1	100 -- Cor Draconis (Normal)
-	7	51504	1	100 -- Cor Draconis (Noble)
-	8	76029	1	100 -- Green Dragon Bean
-	9	71153	1	100 -- Potion of Wisdom
-	10	55401	1	100 -- Monkey Egg
-	11	55402	1	100 -- Spider Egg
-	12	55403	1	100 -- Razador's Egg
-	13	55404	1	100 -- Nemere's Egg
-	14	50324	1	100 -- Boost Book Chest
-	15	50323	1	100 -- Ward Book Chest
-	16	55001	1	100 -- Protein Snack
-	17	79604	1	100 -- King Deck
-	18	27993	1	100 -- Blue Pearl
-	19	27994	1	100 -- Blood-Red Pearl
-	20	71154	1	100 -- Potion of Ascension (3h)
-	21	50108	10	100 -- Fireworks Top
-	22	50107	10	100 -- Chinese Fire Cracker
-	23	76016	1	100 -- Blessing Scroll
-	24	70058	1	100 -- Teleportation Ring
-	25	39036	1	100 -- Wind Shoes
-	26	76033	10	100 -- Peach Flower Wine+
-	27	76012	10	100 -- Potion of Speed
-	28	76017	5	100 -- Potion of Attack +15
-	29	76003	5	100 -- Potion of Haste
-	30	72058	5	100 -- Spirit Stone Bundle
-	31	돈꾸러미	500000	100 -- Yang
-	32	돈꾸러미	300000	100 -- Yang
-	33	돈꾸러미	100000	100 -- Yang
-	34	경험치	100000	100 -- Exp.
-}
-Group	BronzeKingLoot
-{
-	Vnum	50930 -- Bronze King's Loot
-	1	돈꾸러미	50000	100 -- Yang
-	2	돈꾸러미	100000	100 -- Yang
-	3	경험치	100000	100 -- Exp.
-}
-Group	QueenMeleyChest
-{
-	Vnum	50270 -- Queen Meley's Chest
-	Type	pct
-	1	7370	1	18	30 -- Lying Dragon Fan+0
-	2	5340	1	18	30 -- Dragon Ghost Bell +0
-	3	470	1	18	30 -- Dragon Tooth Blade +0
-	4	2370	1	18	30 -- Phoenix Bow +0
-	5	21544	1	10	30 -- Viridian Wood Helmet+4
-	6	21545	1	9	30 -- Viridian Wood Helmet+5
-	7	21546	1	5	30 -- Viridian Wood Helmet+6
-	8	12684	1	10	30 -- Soul Shard Hat +4
-	9	12685	1	9	30 -- Soul Shard Hat +5
-	10	12686	1	5	30 -- Soul Shard Hat +6
-	11	12404	1	10	30 -- Spider Hood +4
-	12	12405	1	9	30 -- Spider Hood +5
-	13	12406	1	5	30 -- Spider Hood +6
-	14	15434	1	10	30 -- Kingfisher Shoes +4
-	15	15435	1	9	30 -- Kingfisher Shoes +5
-	16	15436	1	5	30 -- Kingfisher Shoes +6
-	17	15374	1	10	30 -- Euphoria Shoes +4
-	18	15375	1	9	30 -- Euphoria Shoes +5
-	19	15376	1	5	30 -- Euphoria Shoes +6
-	20	27993	1	20 -- Blue Pearl
-	21	30550	10	20 -- Blue Belt
-	22	27994	1	20 -- Blood-Red Pearl
-	23	30192	5	20 -- Plant Sap
-	24	30621	3	100 -- Red Dragon Scale
-	25	30620	3	100 -- Red Dragon Horn
-	26	30622	1	20 -- Armour Design: Helm
-	27	70031	1	20 -- Fencing Pamphlet
-	28	27992	1	20 -- White Pearl
-	29	55003	1	10 -- Young Pet Book
-	30	55406	1	10 -- Red Dragon Egg
-	31	55005	1	10 -- Valiant Pet Book
-	32	55004	1	10 -- Wild Pet Book
-	33	50299	1	10 -- Crate of Boosts
-	34	50298	1	10 -- Crate of Wards
-	35	50297	1	10 -- Box of Boosts
-	36	50296	1	10 -- Box of Wards
-	37	50513	1	5 -- Soul Stone
-	38	39004	1	5 -- Blessing Marble
-	39	돈꾸러미	10000000	100 -- Yang
-	40	돈꾸러미	20000000	7 -- Yang
-	41	돈꾸러미	30000000	5 -- Yang
-	42	돈꾸러미	60000000	2 -- Yang
-}
-Group	DragonWatcherChest
-{
-	Vnum	50271 -- Dragon Watcher Chest
-	Type	pct
-	1	6090	1	18	30 -- Dragon Lord+0
-	2	1340	1	18	30 -- Five Element Blade +0
-	3	460	1	18	30 -- Rune Sword +0
-	4	3190	1	18	30 -- Solar Blade +0
-	5	12284	1	10	30 -- War Master Helmet +4
-	6	12285	1	9	30 -- War Master Helmet +5
-	7	12286	1	5	30 -- War Master Helmet +6
-	8	12544	1	10	30 -- Magic Helmet +4
-	9	12545	1	9	30 -- Magic Helmet +5
-	10	12546	1	5	30 -- Magic Helmet +6
-	11	15374	1	10	30 -- Euphoria Shoes +4
-	12	15375	1	9	30 -- Euphoria Shoes +5
-	13	15376	1	5	30 -- Euphoria Shoes +6
-	14	27993	1	20 -- Blue Pearl
-	15	27994	1	20 -- Blood-Red Pearl
-	16	30193	5	100 -- Finger Bones
-	17	30080	10	20 -- Curse Book+
-	18	30035	10	20 -- Face Cream
-	19	30011	10	20 -- Ball
-	20	30192	5	20 -- Plant Sap
-	21	30194	2	20 -- Orc Club
-	22	30042	2	20 -- Tiger Fang
-	23	30621	3	100 -- Red Dragon Scale
-	24	30620	3	100 -- Red Dragon Horn
-	25	30622	5	100 -- Armour Design: Helm
-	26	30031	10	20 -- Ornament
-	27	30083	10	20 -- Unknown Medicine+
-	28	27992	1	20 -- White Pearl
-	29	30089	10	20 -- Yeti Fur+
-	30	55003	1	10 -- Young Pet Book
-	31	55004	1	10 -- Wild Pet Book
-	32	55005	1	10 -- Valiant Pet Book
-	33	100700	1	1 -- Flame of the Dragon (B)
-	34	50297	1	10 -- Box of Boosts
-	35	50298	1	10 -- Crate of Wards
-	36	50299	1	10 -- Crate of Boosts
-	37	돈꾸러미	10000000	100 -- Yang
-	38	돈꾸러미	20000000	7 -- Yang
-	39	돈꾸러미	30000000	5 -- Yang
-	40	돈꾸러미	60000000	2 -- Yang
-}
-Group	QueenMeleyChest(P)
-{
-	Vnum	50294 -- Queen Meley's Chest
-	Type	pct
-	1	50926	200	100 -- Glimmerstone
-	2	50926	200	100 -- Glimmerstone
-	3	50926	200	100 -- Glimmerstone
-	4	50926	200	100 -- Glimmerstone
-	5	50926	200	100 -- Glimmerstone
-}
-Group	용혼원석-보상용_기본
-{
-	Vnum	50255 -- Cor Draconis (Rough)
-	1	110000	1	1 -- Rough Dragon Diamond
-	2	120000	1	1 -- Rough Dragon Ruby
-	3	130000	1	1 -- Rough Dragon Jade
-	4	140000	1	1 -- Rough Dragon Sapphire
-	5	150000	1	1 -- Rough Dragon Garnet
-	6	160000	1	1 -- Rough Dragon Onyx
-}
-Group	용혼원석-기본_판매용
-{
-	Vnum	50260 -- Cor Draconis (Rough)
-	1	110000	1	1 -- Rough Dragon Diamond
-	2	120000	1	1 -- Rough Dragon Ruby
-	3	130000	1	1 -- Rough Dragon Jade
-	4	140000	1	1 -- Rough Dragon Sapphire
-	5	150000	1	1 -- Rough Dragon Garnet
-	6	160000	1	1 -- Rough Dragon Onyx
-}
-Group	용혼석박스_일반화려
-{
-	Vnum	51639 -- Dragon Chest
-	Type	Pct
-	1	51503	1	100 -- Cor Draconis (Normal)
-	2	51503	1	100 -- Cor Draconis (Normal)
-	3	51503	1	100 -- Cor Draconis (Normal)
-	4	51503	1	100 -- Cor Draconis (Normal)
-	5	51503	1	100 -- Cor Draconis (Normal)
-	6	51503	1	100 -- Cor Draconis (Normal)
-	7	51503	1	100 -- Cor Draconis (Normal)
-	8	51503	1	100 -- Cor Draconis (Normal)
-	9	51503	1	100 -- Cor Draconis (Normal)
-	10	51503	1	100 -- Cor Draconis (Normal)
-	11	51503	1	100 -- Cor Draconis (Normal)
-}
-Group	강력한용혼석박스_일반화려
-{
-	Vnum	51640 -- Dragon Chest+
-	Type	Pct
-	1	51576	1	100 -- Cor Draconis+ (Normal)
-	2	51576	1	100 -- Cor Draconis+ (Normal)
-	3	51576	1	100 -- Cor Draconis+ (Normal)
-	4	51576	1	100 -- Cor Draconis+ (Normal)
-	5	51576	1	100 -- Cor Draconis+ (Normal)
-	6	51576	1	100 -- Cor Draconis+ (Normal)
-	7	51576	1	100 -- Cor Draconis+ (Normal)
-	8	51576	1	100 -- Cor Draconis+ (Normal)
-	9	51576	1	100 -- Cor Draconis+ (Normal)
-	10	51576	1	100 -- Cor Draconis+ (Normal)
-	11	51576	1	100 -- Cor Draconis+ (Normal)
-	12	100300	1	100 -- Green Dragon Bean
-}
-Group	강력한용혼석박스_일반화려_종류별
-{
-	Vnum	51641 -- Dragon Chest+ (Coloured)
-	Type	Pct
-	1	51577	1	100 -- Cor Diamas+ (Normal)
-	2	51578	1	100 -- Cor Rubinum+ (Normal)
-	3	51579	1	100 -- Cor Jadeit+ (Normal)
-	4	51580	1	100 -- Cor Saphirum+ (Normal)
-	5	51581	1	100 -- Cor Granatum+ (Normal)
-	6	51582	1	100 -- Cor Atrum+ (Normal)
-	7	100300	1	100 -- Green Dragon Bean
-}
-Group	용혼석박스_일반화려_종류별
-{
-	Vnum	51642 -- Dragon Chest (Coloured)
-	Type	Pct
-	1	51517	1	100 -- Cor Diamas (Normal)
-	2	51518	1	100 -- Cor Rubinum (Normal)
-	3	51519	1	100 -- Cor Jadeit (Normal)
-	4	51520	1	100 -- Cor Saphirum (Normal)
-	5	51521	1	100 -- Cor Granatum (Normal)
-	6	51522	1	100 -- Cor Atrum (Normal)
-	7	100300	1	100 -- Green Dragon Bean
-}
-Group	용혼석박스_일반희귀
-{
-	Vnum	51643 -- Noble Dragon Chest
-	Type	Pct
-	1	51504	1	100 -- Cor Draconis (Noble)
-	2	51504	1	100 -- Cor Draconis (Noble)
-	3	51504	1	100 -- Cor Draconis (Noble)
-	4	51504	1	100 -- Cor Draconis (Noble)
-	5	51504	1	100 -- Cor Draconis (Noble)
-	6	51504	1	100 -- Cor Draconis (Noble)
-	7	51504	1	100 -- Cor Draconis (Noble)
-	8	51504	1	100 -- Cor Draconis (Noble)
-	9	51504	1	100 -- Cor Draconis (Noble)
-	10	51504	1	100 -- Cor Draconis (Noble)
-	11	51504	1	100 -- Cor Draconis (Noble)
-}
-Group	강력한용혼석박스_일반희귀
-{
-	Vnum	51644 -- Noble Dragon Chest+
-	Type	Pct
-	1	51583	1	100 -- Cor Draconis+ (Noble)
-	2	51583	1	100 -- Cor Draconis+ (Noble)
-	3	51583	1	100 -- Cor Draconis+ (Noble)
-	4	51583	1	100 -- Cor Draconis+ (Noble)
-	5	51583	1	100 -- Cor Draconis+ (Noble)
-	6	51583	1	100 -- Cor Draconis+ (Noble)
-	7	51583	1	100 -- Cor Draconis+ (Noble)
-	8	51583	1	100 -- Cor Draconis+ (Noble)
-	9	51583	1	100 -- Cor Draconis+ (Noble)
-	10	51583	1	100 -- Cor Draconis+ (Noble)
-	11	51583	1	100 -- Cor Draconis+ (Noble)
-	12	100300	1	100 -- Green Dragon Bean
-}
-Group	강력한용혼석박스_일반희귀_종류별
-{
-	Vnum	51645 -- N. Dragon Cht+(Coloured)
-	Type	Pct
-	1	51584	1	100 -- Cor Diamas+ (Noble)
-	2	51585	1	100 -- Cor Rubinum+ (Noble)
-	3	51586	1	100 -- Cor Jadeit+ (Noble)
-	4	51587	1	100 -- Cor Saphirum+ (Noble)
-	5	51588	1	100 -- Cor Granatum+ (Noble)
-	6	51589	1	100 -- Cor Atrum+ (Noble)
-	7	100300	1	100 -- Green Dragon Bean
-}
-Group	용혼석박스_일반희귀_종류별
-{
-	Vnum	51646 -- N. Dragon Cht (Coloured)
-	Type	Pct
-	1	51523	1	100 -- Cor Diamas (Noble)
-	2	51524	1	100 -- Cor Rubinum (Noble)
-	3	51525	1	100 -- Cor Jadeit (Noble)
-	4	51526	1	100 -- Cor Saphirum (Noble)
-	5	51527	1	100 -- Cor Granatum (Noble)
-	6	51528	1	100 -- Cor Atrum (Noble)
-	7	100300	1	100 -- Green Dragon Bean
-}
-Group	New_용혼원석-보상용_기본
-{
-	Vnum	51501 -- Cor Draconis (Rough)
-	1	110000	1	1 -- Rough Dragon Diamond
-	2	120000	1	1 -- Rough Dragon Ruby
-	3	130000	1	1 -- Rough Dragon Jade
-	4	140000	1	1 -- Rough Dragon Sapphire
-	5	150000	1	1 -- Rough Dragon Garnet
-	6	160000	1	1 -- Rough Dragon Onyx
-}
-Group	New_용혼원석-기본_판매용
-{
-	Vnum	51502 -- Cor Draconis (Rough)
-	1	110000	1	1 -- Rough Dragon Diamond
-	2	120000	1	1 -- Rough Dragon Ruby
-	3	130000	1	1 -- Rough Dragon Jade
-	4	140000	1	1 -- Rough Dragon Sapphire
-	5	150000	1	1 -- Rough Dragon Garnet
-	6	160000	1	1 -- Rough Dragon Onyx
-}
-Group	화려한용혼원석_포괄형
-{
-	Vnum	51503 -- Cor Draconis (Normal)
-	1	110000	1	100 -- Rough Dragon Diamond
-	2	120000	1	100 -- Rough Dragon Ruby
-	3	130000	1	100 -- Rough Dragon Jade
-	4	140000	1	100 -- Rough Dragon Sapphire
-	5	150000	1	100 -- Rough Dragon Garnet
-	6	160000	1	100 -- Rough Dragon Onyx
-	7	111000	1	43 -- Cut Dragon Diamond
-	8	121000	1	43 -- Cut Dragon Ruby
-	9	131000	1	43 -- Cut Dragon Jade
-	10	141000	1	43 -- Cut Dragon Sapphire
-	11	151000	1	43 -- Cut Dragon Garnet
-	12	161000	1	43 -- Cut Dragon Onyx
-}
-Group	희귀한용혼원석_포괄형
-{
-	Vnum	51504 -- Cor Draconis (Noble)
-	1	110000	1	50 -- Rough Dragon Diamond
-	2	120000	1	50 -- Rough Dragon Ruby
-	3	130000	1	50 -- Rough Dragon Jade
-	4	140000	1	50 -- Rough Dragon Sapphire
-	5	150000	1	50 -- Rough Dragon Garnet
-	6	160000	1	50 -- Rough Dragon Onyx
-	7	111000	1	75 -- Cut Dragon Diamond
-	8	121000	1	75 -- Cut Dragon Ruby
-	9	131000	1	75 -- Cut Dragon Jade
-	10	141000	1	75 -- Cut Dragon Sapphire
-	11	151000	1	75 -- Cut Dragon Garnet
-	12	161000	1	75 -- Cut Dragon Onyx
-	13	112000	1	42 -- Rare Dragon Diamond
-	14	122000	1	42 -- Rare Dragon Ruby
-	15	132000	1	42 -- Rare Dragon Jade
-	16	142000	1	42 -- Rare Dragon Sapphire
-	17	152000	1	41 -- Rare Dragon Garnet
-	18	162000	1	41 -- Rare Dragon Onyx
-}
-Group	고대의용혼원석_포괄형
-{
-	Vnum	51505 -- Cor Draconis (Precious)
-	1	110000	1	35 -- Rough Dragon Diamond
-	2	120000	1	35 -- Rough Dragon Ruby
-	3	130000	1	35 -- Rough Dragon Jade
-	4	140000	1	35 -- Rough Dragon Sapphire
-	5	150000	1	35 -- Rough Dragon Garnet
-	6	160000	1	35 -- Rough Dragon Onyx
-	7	111000	1	135 -- Cut Dragon Diamond
-	8	121000	1	135 -- Cut Dragon Ruby
-	9	131000	1	135 -- Cut Dragon Jade
-	10	141000	1	135 -- Cut Dragon Sapphire
-	11	151000	1	135 -- Cut Dragon Garnet
-	12	161000	1	135 -- Cut Dragon Onyx
-	13	112000	1	380 -- Rare Dragon Diamond
-	14	122000	1	380 -- Rare Dragon Ruby
-	15	132000	1	380 -- Rare Dragon Jade
-	16	142000	1	380 -- Rare Dragon Sapphire
-	17	152000	1	380 -- Rare Dragon Garnet
-	18	162000	1	380 -- Rare Dragon Onyx
-	19	113000	1	135 -- Antique Dragon Diamond
-	20	123000	1	135 -- Antique Dragon Ruby
-	21	133000	1	135 -- Antique Dragon Jade
-	22	143000	1	135 -- Antique Dragon Sapphire
-	23	153000	1	135 -- Antique Dragon Garnet
-	24	163000	1	135 -- Antique Dragon Onyx
-}
-Group	고대의용혼원석_포괄형
-{
-	Vnum	51506 -- Cor Draconis (Mystical)
-	1	111000	1	35 -- Cut Dragon Diamond
-	2	121000	1	35 -- Cut Dragon Ruby
-	3	131000	1	35 -- Cut Dragon Jade
-	4	141000	1	35 -- Cut Dragon Sapphire
-	5	151000	1	35 -- Cut Dragon Garnet
-	6	161000	1	35 -- Cut Dragon Onyx
-	7	112000	1	240 -- Rare Dragon Diamond
-	8	122000	1	240 -- Rare Dragon Ruby
-	9	132000	1	240 -- Rare Dragon Jade
-	10	142000	1	240 -- Rare Dragon Sapphire
-	11	152000	1	240 -- Rare Dragon Garnet
-	12	162000	1	240 -- Rare Dragon Onyx
-	13	113000	1	310 -- Antique Dragon Diamond
-	14	123000	1	310 -- Antique Dragon Ruby
-	15	133000	1	310 -- Antique Dragon Jade
-	16	143000	1	310 -- Antique Dragon Sapphire
-	17	153000	1	310 -- Antique Dragon Garnet
-	18	163000	1	310 -- Antique Dragon Onyx
-	19	114000	1	100 -- Legendary Dragon Diamond
-	20	124000	1	100 -- Legendary Dragon Ruby
-	21	134000	1	100 -- Legendary Dragon Jade
-	22	144000	1	100 -- Legendary DragonSapphire
-	23	154000	1	100 -- Legendary Dragon Garnet
-	24	164000	1	100 -- Legendary Dragon Onyx
-}
-Group	화려한용혼석_등급별
-{
-	Vnum	51507 -- Cor Draconis (Cut)
-	1	111000	1	1 -- Cut Dragon Diamond
-	2	121000	1	1 -- Cut Dragon Ruby
-	3	131000	1	1 -- Cut Dragon Jade
-	4	141000	1	1 -- Cut Dragon Sapphire
-	5	151000	1	1 -- Cut Dragon Garnet
-	6	161000	1	1 -- Cut Dragon Onyx
-}
-Group	희귀한용혼석_등급별
-{
-	Vnum	51508 -- Cor Draconis (Rare)
-	1	112000	1	1 -- Rare Dragon Diamond
-	2	122000	1	1 -- Rare Dragon Ruby
-	3	132000	1	1 -- Rare Dragon Jade
-	4	142000	1	1 -- Rare Dragon Sapphire
-	5	152000	1	1 -- Rare Dragon Garnet
-	6	162000	1	1 -- Rare Dragon Onyx
-}
-Group	고대의용혼석_등급별
-{
-	Vnum	51509 -- Cor Draconis (Antique)
-	1	113000	1	1 -- Antique Dragon Diamond
-	2	123000	1	1 -- Antique Dragon Ruby
-	3	133000	1	1 -- Antique Dragon Jade
-	4	143000	1	1 -- Antique Dragon Sapphire
-	5	153000	1	1 -- Antique Dragon Garnet
-	6	163000	1	1 -- Antique Dragon Onyx
-}
-Group	전설의용혼석_등급별
-{
-	Vnum	51510 -- Cor Draconis (Legendary)
-	1	114000	1	1 -- Legendary Dragon Diamond
-	2	124000	1	1 -- Legendary Dragon Ruby
-	3	134000	1	1 -- Legendary Dragon Jade
-	4	144000	1	1 -- Legendary DragonSapphire
-	5	154000	1	1 -- Legendary Dragon Garnet
-	6	164000	1	1 -- Legendary Dragon Onyx
-}
-Group	백룡용혼원석_종류별
-{
-	Vnum	51511 -- Cor Diamas
-	1	110000	1	1 -- Rough Dragon Diamond
-	2	111000	1	1 -- Cut Dragon Diamond
-	3	112000	1	1 -- Rare Dragon Diamond
-	4	113000	1	1 -- Antique Dragon Diamond
-	5	114000	1	1 -- Legendary Dragon Diamond
-}
-Group	화룡용혼원석_종류별
-{
-	Vnum	51512 -- Cor Rubinum
-	1	120000	1	1 -- Rough Dragon Ruby
-	2	121000	1	1 -- Cut Dragon Ruby
-	3	122000	1	1 -- Rare Dragon Ruby
-	4	123000	1	1 -- Antique Dragon Ruby
-	5	124000	1	1 -- Legendary Dragon Ruby
-}
-Group	풍룡용혼원석_종류별
-{
-	Vnum	51513 -- Cor Jadeit
-	1	130000	1	1 -- Rough Dragon Jade
-	2	131000	1	1 -- Cut Dragon Jade
-	3	132000	1	1 -- Rare Dragon Jade
-	4	133000	1	1 -- Antique Dragon Jade
-	5	134000	1	1 -- Legendary Dragon Jade
-}
-Group	철룡용혼원석_종류별
-{
-	Vnum	51514 -- Cor Saphirum
-	1	140000	1	1 -- Rough Dragon Sapphire
-	2	141000	1	1 -- Cut Dragon Sapphire
-	3	142000	1	1 -- Rare Dragon Sapphire
-	4	143000	1	1 -- Antique Dragon Sapphire
-	5	144000	1	1 -- Legendary DragonSapphire
-}
-Group	뇌룡용혼원석_종류별
-{
-	Vnum	51515 -- Cor Granatum
-	1	150000	1	1 -- Rough Dragon Garnet
-	2	151000	1	1 -- Cut Dragon Garnet
-	3	152000	1	1 -- Rare Dragon Garnet
-	4	153000	1	1 -- Antique Dragon Garnet
-	5	154000	1	1 -- Legendary Dragon Garnet
-}
-Group	흑룡용혼원석_종류별
-{
-	Vnum	51516 -- Cor Atrum
-	1	160000	1	1 -- Rough Dragon Onyx
-	2	161000	1	1 -- Cut Dragon Onyx
-	3	162000	1	1 -- Rare Dragon Onyx
-	4	163000	1	1 -- Antique Dragon Onyx
-	5	164000	1	1 -- Legendary Dragon Onyx
-}
-Group	백룡용혼원석_종류별_일반-화려
-{
-	Vnum	51517 -- Cor Diamas (Normal)
-	1	110000	1	7 -- Rough Dragon Diamond
-	2	111000	1	3 -- Cut Dragon Diamond
-}
-Group	화룡용혼원석_종류별_일반-화려
-{
-	Vnum	51518 -- Cor Rubinum (Normal)
-	1	120000	1	7 -- Rough Dragon Ruby
-	2	121000	1	3 -- Cut Dragon Ruby
-}
-Group	풍룡용혼원석_종류별_일반-화려
-{
-	Vnum	51519 -- Cor Jadeit (Normal)
-	1	130000	1	7 -- Rough Dragon Jade
-	2	131000	1	3 -- Cut Dragon Jade
-}
-Group	철룡용혼원석_종류별_일반-화려
-{
-	Vnum	51520 -- Cor Saphirum (Normal)
-	1	140000	1	7 -- Rough Dragon Sapphire
-	2	141000	1	3 -- Cut Dragon Sapphire
-}
-Group	뇌룡용혼원석_종류별_일반-화려
-{
-	Vnum	51521 -- Cor Granatum (Normal)
-	1	150000	1	7 -- Rough Dragon Garnet
-	2	151000	1	3 -- Cut Dragon Garnet
-}
-Group	흑룡용혼원석_종류별_일반-화려
-{
-	Vnum	51522 -- Cor Atrum (Normal)
-	1	160000	1	7 -- Rough Dragon Onyx
-	2	161000	1	3 -- Cut Dragon Onyx
-}
-Group	백룡용혼원석_종류별_일반-희귀
-{
-	Vnum	51523 -- Cor Diamas (Noble)
-	1	110000	1	3 -- Rough Dragon Diamond
-	2	111000	1	6 -- Cut Dragon Diamond
-	3	112000	1	1 -- Rare Dragon Diamond
-}
-Group	화룡용혼원석_종류별_일반-희귀
-{
-	Vnum	51524 -- Cor Rubinum (Noble)
-	1	120000	1	3 -- Rough Dragon Ruby
-	2	121000	1	6 -- Cut Dragon Ruby
-	3	122000	1	1 -- Rare Dragon Ruby
-}
-Group	풍룡용혼원석_종류별_일반-희귀
-{
-	Vnum	51525 -- Cor Jadeit (Noble)
-	1	130000	1	3 -- Rough Dragon Jade
-	2	131000	1	6 -- Cut Dragon Jade
-	3	132000	1	1 -- Rare Dragon Jade
-}
-Group	철룡용혼원석_종류별_일반-희귀
-{
-	Vnum	51526 -- Cor Saphirum (Noble)
-	1	140000	1	3 -- Rough Dragon Sapphire
-	2	141000	1	6 -- Cut Dragon Sapphire
-	3	142000	1	1 -- Rare Dragon Sapphire
-}
-Group	뇌룡용혼원석_종류별_일반-희귀
-{
-	Vnum	51527 -- Cor Granatum (Noble)
-	1	150000	1	3 -- Rough Dragon Garnet
-	2	151000	1	6 -- Cut Dragon Garnet
-	3	152000	1	1 -- Rare Dragon Garnet
-}
-Group	흑룡용혼원석_종류별_일반-희귀
-{
-	Vnum	51528 -- Cor Atrum (Noble)
-	1	160000	1	3 -- Rough Dragon Onyx
-	2	161000	1	6 -- Cut Dragon Onyx
-	3	162000	1	1 -- Rare Dragon Onyx
-}
-Group	백룡용혼원석_종류별_일반-고대
-{
-	Vnum	51529 -- Cor Diamas (Precious)
-	1	110000	1	10 -- Rough Dragon Diamond
-	2	111000	1	25 -- Cut Dragon Diamond
-	3	112000	1	55 -- Rare Dragon Diamond
-	4	113000	1	10 -- Antique Dragon Diamond
-}
-Group	화룡용혼원석_종류별_일반-고대
-{
-	Vnum	51530 -- Cor Rubinum (Precious)
-	1	120000	1	10 -- Rough Dragon Ruby
-	2	121000	1	25 -- Cut Dragon Ruby
-	3	122000	1	55 -- Rare Dragon Ruby
-	4	123000	1	10 -- Antique Dragon Ruby
-}
-Group	풍룡용혼원석_종류별_일반-고대
-{
-	Vnum	51531 -- Cor Jadeit (Precious)
-	1	130000	1	10 -- Rough Dragon Jade
-	2	131000	1	25 -- Cut Dragon Jade
-	3	132000	1	55 -- Rare Dragon Jade
-	4	133000	1	10 -- Antique Dragon Jade
-}
-Group	철룡용혼원석_종류별_일반-고대
-{
-	Vnum	51532 -- Cor Saphirum (Precious)
-	1	140000	1	10 -- Rough Dragon Sapphire
-	2	141000	1	25 -- Cut Dragon Sapphire
-	3	142000	1	55 -- Rare Dragon Sapphire
-	4	143000	1	10 -- Antique Dragon Sapphire
-}
-Group	뇌룡용혼원석_종류별_일반-고대
-{
-	Vnum	51533 -- Cor Granatum (Precious)
-	1	150000	1	10 -- Rough Dragon Garnet
-	2	151000	1	25 -- Cut Dragon Garnet
-	3	152000	1	55 -- Rare Dragon Garnet
-	4	153000	1	10 -- Antique Dragon Garnet
-}
-Group	흑룡용혼원석_종류별_일반-고대
-{
-	Vnum	51534 -- Cor Atrum (Precious)
-	1	160000	1	10 -- Rough Dragon Onyx
-	2	161000	1	25 -- Cut Dragon Onyx
-	3	162000	1	55 -- Rare Dragon Onyx
-	4	163000	1	10 -- Antique Dragon Onyx
-}
-Group	백룡용혼원석_종류별_일반-전설
-{
-	Vnum	51535 -- Cor Diamas (Flawless)
-	1	110000	1	5 -- Rough Dragon Diamond
-	2	111000	1	10 -- Cut Dragon Diamond
-	3	112000	1	15 -- Rare Dragon Diamond
-	4	113000	1	60 -- Antique Dragon Diamond
-	5	114000	1	10 -- Legendary Dragon Diamond
-}
-Group	화룡용혼원석_종류별_일반-전설
-{
-	Vnum	51536 -- Cor Rubinum (Flawless)
-	1	120000	1	5 -- Rough Dragon Ruby
-	2	121000	1	10 -- Cut Dragon Ruby
-	3	122000	1	15 -- Rare Dragon Ruby
-	4	123000	1	60 -- Antique Dragon Ruby
-	5	124000	1	10 -- Legendary Dragon Ruby
-}
-Group	풍룡용혼원석_종류별_일반-전설
-{
-	Vnum	51537 -- Cor Jadeit (Flawless)
-	1	130000	1	5 -- Rough Dragon Jade
-	2	131000	1	10 -- Cut Dragon Jade
-	3	132000	1	15 -- Rare Dragon Jade
-	4	133000	1	60 -- Antique Dragon Jade
-	5	134000	1	10 -- Legendary Dragon Jade
-}
-Group	철룡용혼원석_종류별_일반-전설
-{
-	Vnum	51538 -- Cor Saphirum (Flawless)
-	1	140000	1	5 -- Rough Dragon Sapphire
-	2	141000	1	10 -- Cut Dragon Sapphire
-	3	142000	1	15 -- Rare Dragon Sapphire
-	4	143000	1	60 -- Antique Dragon Sapphire
-	5	144000	1	10 -- Legendary DragonSapphire
-}
-Group	뇌룡용혼원석_종류별_일반-전설
-{
-	Vnum	51539 -- Cor Granatum (Flawless)
-	1	150000	1	5 -- Rough Dragon Garnet
-	2	151000	1	10 -- Cut Dragon Garnet
-	3	152000	1	15 -- Rare Dragon Garnet
-	4	153000	1	60 -- Antique Dragon Garnet
-	5	154000	1	10 -- Legendary Dragon Garnet
-}
-Group	흑룡용혼원석_종류별_일반-전설
-{
-	Vnum	51540 -- Cor Atrum (Flawless)
-	1	160000	1	5 -- Rough Dragon Onyx
-	2	161000	1	10 -- Cut Dragon Onyx
-	3	162000	1	15 -- Rare Dragon Onyx
-	4	163000	1	60 -- Antique Dragon Onyx
-	5	164000	1	10 -- Legendary Dragon Onyx
-}
-Group	용혼원석_종류별_화려-희귀
-{
-	Vnum	51541 -- Cor Draconis (Glowing)
-	1	111000	1	100 -- Cut Dragon Diamond
-	2	121000	1	100 -- Cut Dragon Ruby
-	3	131000	1	100 -- Cut Dragon Jade
-	4	141000	1	100 -- Cut Dragon Sapphire
-	5	151000	1	100 -- Cut Dragon Garnet
-	6	161000	1	100 -- Cut Dragon Onyx
-	7	112000	1	43 -- Rare Dragon Diamond
-	8	122000	1	43 -- Rare Dragon Ruby
-	9	132000	1	43 -- Rare Dragon Jade
-	10	142000	1	43 -- Rare Dragon Sapphire
-	11	152000	1	43 -- Rare Dragon Garnet
-	12	162000	1	43 -- Rare Dragon Onyx
-}
-Group	백룡용혼원석_종류별_화려-희귀
-{
-	Vnum	51542 -- Cor Diamas (Glowing)
-	1	111000	1	7 -- Cut Dragon Diamond
-	2	112000	1	3 -- Rare Dragon Diamond
-}
-Group	화룡용혼원석_종류별_화려-희귀
-{
-	Vnum	51543 -- Cor Rubinum (Glowing)
-	1	121000	1	7 -- Cut Dragon Ruby
-	2	122000	1	3 -- Rare Dragon Ruby
-}
-Group	풍룡용혼원석_종류별_화려-희귀
-{
-	Vnum	51544 -- Cor Jadeit (Glowing)
-	1	131000	1	7 -- Cut Dragon Jade
-	2	132000	1	3 -- Rare Dragon Jade
-}
-Group	철룡용혼원석_종류별_화려-희귀
-{
-	Vnum	51545 -- Cor Saphirum (Glowing)
-	1	141000	1	7 -- Cut Dragon Sapphire
-	2	142000	1	3 -- Rare Dragon Sapphire
-}
-Group	뇌룡용혼원석_종류별_화려-희귀
-{
-	Vnum	51546 -- Cor Granatum (Glowing)
-	1	151000	1	7 -- Cut Dragon Garnet
-	2	152000	1	3 -- Rare Dragon Garnet
-}
-Group	흑룡용혼원석_종류별_화려-희귀
-{
-	Vnum	51547 -- Cor Atrum (Glowing)
-	1	161000	1	7 -- Cut Dragon Onyx
-	2	162000	1	3 -- Rare Dragon Onyx
-}
-Group	용혼원석_전체포괄형
-{
-	Vnum	51548 -- Cor Draconis (Flawless)
-	1	110000	1	35 -- Rough Dragon Diamond
-	2	120000	1	35 -- Rough Dragon Ruby
-	3	130000	1	35 -- Rough Dragon Jade
-	4	140000	1	35 -- Rough Dragon Sapphire
-	5	150000	1	35 -- Rough Dragon Garnet
-	6	160000	1	35 -- Rough Dragon Onyx
-	7	111000	1	70 -- Cut Dragon Diamond
-	8	121000	1	70 -- Cut Dragon Ruby
-	9	131000	1	70 -- Cut Dragon Jade
-	10	141000	1	70 -- Cut Dragon Sapphire
-	11	151000	1	70 -- Cut Dragon Garnet
-	12	161000	1	70 -- Cut Dragon Onyx
-	13	111000	1	105 -- Cut Dragon Diamond
-	14	121000	1	105 -- Cut Dragon Ruby
-	15	131000	1	105 -- Cut Dragon Jade
-	16	141000	1	105 -- Cut Dragon Sapphire
-	17	151000	1	105 -- Cut Dragon Garnet
-	18	161000	1	105 -- Cut Dragon Onyx
-	19	112000	1	420 -- Rare Dragon Diamond
-	20	122000	1	420 -- Rare Dragon Ruby
-	21	132000	1	420 -- Rare Dragon Jade
-	22	142000	1	420 -- Rare Dragon Sapphire
-	23	152000	1	420 -- Rare Dragon Garnet
-	24	162000	1	420 -- Rare Dragon Onyx
-	25	113000	1	70 -- Antique Dragon Diamond
-	26	123000	1	70 -- Antique Dragon Ruby
-	27	133000	1	70 -- Antique Dragon Jade
-	28	143000	1	70 -- Antique Dragon Sapphire
-	29	153000	1	70 -- Antique Dragon Garnet
-	30	163000	1	70 -- Antique Dragon Onyx
-}
-Group	용혼원석_종류별_화려-고대
-{
-	Vnum	51549 -- Cor Draconis (Eternal)
-	1	111000	1	27 -- Cut Dragon Diamond
-	2	121000	1	27 -- Cut Dragon Ruby
-	3	131000	1	27 -- Cut Dragon Jade
-	4	141000	1	27 -- Cut Dragon Sapphire
-	5	151000	1	27 -- Cut Dragon Garnet
-	6	161000	1	27 -- Cut Dragon Onyx
-	7	112000	1	56 -- Rare Dragon Diamond
-	8	122000	1	56 -- Rare Dragon Ruby
-	9	132000	1	56 -- Rare Dragon Jade
-	10	142000	1	56 -- Rare Dragon Sapphire
-	11	152000	1	56 -- Rare Dragon Garnet
-	12	162000	1	56 -- Rare Dragon Onyx
-	13	113000	1	9 -- Antique Dragon Diamond
-	14	123000	1	9 -- Antique Dragon Ruby
-	15	133000	1	9 -- Antique Dragon Jade
-	16	143000	1	9 -- Antique Dragon Sapphire
-	17	153000	1	9 -- Antique Dragon Garnet
-	18	163000	1	9 -- Antique Dragon Onyx
-}
-Group	백룡용혼원석_종류별_화려-고대
-{
-	Vnum	51550 -- Cor Diamas (Eternal)
-	1	111000	1	3 -- Cut Dragon Diamond
-	2	112000	1	6 -- Rare Dragon Diamond
-	3	113000	1	1 -- Antique Dragon Diamond
-}
-Group	화룡용혼원석_종류별_화려-고대
-{
-	Vnum	51551 -- Cor Rubinum (Eternal)
-	1	121000	1	3 -- Cut Dragon Ruby
-	2	122000	1	6 -- Rare Dragon Ruby
-	3	123000	1	1 -- Antique Dragon Ruby
-}
-Group	풍룡용혼원석_종류별_화려-고대
-{
-	Vnum	51552 -- Cor Jadeit (Eternal)
-	1	131000	1	3 -- Cut Dragon Jade
-	2	132000	1	6 -- Rare Dragon Jade
-	3	133000	1	1 -- Antique Dragon Jade
-}
-Group	철룡용혼원석_종류별_화려-고대
-{
-	Vnum	51553 -- Cor Saphirum (Eternal)
-	1	141000	1	3 -- Cut Dragon Sapphire
-	2	142000	1	6 -- Rare Dragon Sapphire
-	3	143000	1	1 -- Antique Dragon Sapphire
-}
-Group	뇌룡용혼원석_종류별_화려-고대
-{
-	Vnum	51554 -- Cor Granatum (Eternal)
-	1	151000	1	3 -- Cut Dragon Garnet
-	2	152000	1	6 -- Rare Dragon Garnet
-	3	153000	1	1 -- Antique Dragon Garnet
-}
-Group	흑룡용혼원석_종류별_화려-고대
-{
-	Vnum	51555 -- Cor Atrum (Eternal)
-	1	161000	1	3 -- Cut Dragon Onyx
-	2	162000	1	6 -- Rare Dragon Onyx
-	3	163000	1	1 -- Antique Dragon Onyx
-}
-Group	백룡용혼원석_종류별_화려-전설
-{
-	Vnum	51556 -- Cor Diamas (Mystical)
-	1	111000	1	10 -- Cut Dragon Diamond
-	2	112000	1	25 -- Rare Dragon Diamond
-	3	113000	1	55 -- Antique Dragon Diamond
-	4	114000	1	10 -- Legendary Dragon Diamond
-}
-Group	화룡용혼원석_종류별_화려-전설
-{
-	Vnum	51557 -- Cor Rubinum (Mystical)
-	1	121000	1	10 -- Cut Dragon Ruby
-	2	122000	1	25 -- Rare Dragon Ruby
-	3	123000	1	55 -- Antique Dragon Ruby
-	4	124000	1	10 -- Legendary Dragon Ruby
-}
-Group	풍룡용혼원석_종류별_화려-전설
-{
-	Vnum	51558 -- Cor Jadeit (Mystical)
-	1	131000	1	10 -- Cut Dragon Jade
-	2	132000	1	25 -- Rare Dragon Jade
-	3	133000	1	55 -- Antique Dragon Jade
-	4	134000	1	10 -- Legendary Dragon Jade
-}
-Group	철룡용혼원석_종류별_화려-전설
-{
-	Vnum	51559 -- Cor Saphirum (Mystical)
-	1	141000	1	10 -- Cut Dragon Sapphire
-	2	142000	1	25 -- Rare Dragon Sapphire
-	3	143000	1	55 -- Antique Dragon Sapphire
-	4	144000	1	10 -- Legendary DragonSapphire
-}
-Group	뇌룡용혼원석_종류별_화려-전설
-{
-	Vnum	51560 -- Cor Granatum (Mystical)
-	1	151000	1	10 -- Cut Dragon Garnet
-	2	152000	1	25 -- Rare Dragon Garnet
-	3	153000	1	55 -- Antique Dragon Garnet
-	4	154000	1	10 -- Legendary Dragon Garnet
-}
-Group	흑룡용혼원석_종류별_화려-전설
-{
-	Vnum	51561 -- Cor Atrum (Mystical)
-	1	161000	1	10 -- Cut Dragon Onyx
-	2	162000	1	25 -- Rare Dragon Onyx
-	3	163000	1	55 -- Antique Dragon Onyx
-	4	164000	1	10 -- Legendary Dragon Onyx
-}
-Group	용혼원석_종류별_희귀-고대
-{
-	Vnum	51562 -- Cor Draconis (Epic)
-	1	112000	1	100 -- Rare Dragon Diamond
-	2	122000	1	100 -- Rare Dragon Ruby
-	3	132000	1	100 -- Rare Dragon Jade
-	4	142000	1	100 -- Rare Dragon Sapphire
-	5	152000	1	100 -- Rare Dragon Garnet
-	6	162000	1	100 -- Rare Dragon Onyx
-	7	113000	1	43 -- Antique Dragon Diamond
-	8	123000	1	43 -- Antique Dragon Ruby
-	9	133000	1	43 -- Antique Dragon Jade
-	10	143000	1	43 -- Antique Dragon Sapphire
-	11	153000	1	43 -- Antique Dragon Garnet
-	12	163000	1	43 -- Antique Dragon Onyx
-}
-Group	백룡용혼원석_종류별_희귀-고대
-{
-	Vnum	51563 -- Cor Diamas (Epic)
-	1	112000	1	7 -- Rare Dragon Diamond
-	2	113000	1	3 -- Antique Dragon Diamond
-}
-Group	화룡용혼원석_종류별_희귀-고대
-{
-	Vnum	51564 -- Cor Rubinum (Epic)
-	1	122000	1	7 -- Rare Dragon Ruby
-	2	123000	1	3 -- Antique Dragon Ruby
-}
-Group	풍룡용혼원석_종류별_희귀-고대
-{
-	Vnum	51565 -- Cor Jadeit (Epic)
-	1	132000	1	7 -- Rare Dragon Jade
-	2	133000	1	3 -- Antique Dragon Jade
-}
-Group	철룡용혼원석_종류별_희귀-고대
-{
-	Vnum	51566 -- Cor Saphirum (Epic)
-	1	142000	1	7 -- Rare Dragon Sapphire
-	2	143000	1	3 -- Antique Dragon Sapphire
-}
-Group	뇌룡용혼원석_종류별_희귀-고대
-{
-	Vnum	51567 -- Cor Granatum (Epic)
-	1	152000	1	7 -- Rare Dragon Garnet
-	2	153000	1	3 -- Antique Dragon Garnet
-}
-Group	흑룡용혼원석_종류별_희귀-고대
-{
-	Vnum	51568 -- Cor Atrum (Epic)
-	1	162000	1	7 -- Rare Dragon Onyx
-	2	163000	1	3 -- Antique Dragon Onyx
-}
-Group	용혼원석_종류별_희귀-전설
-{
-	Vnum	51569 -- Cor Draconis (Divine)
-	1	112000	1	27 -- Rare Dragon Diamond
-	2	122000	1	27 -- Rare Dragon Ruby
-	3	132000	1	27 -- Rare Dragon Jade
-	4	142000	1	27 -- Rare Dragon Sapphire
-	5	152000	1	27 -- Rare Dragon Garnet
-	6	162000	1	27 -- Rare Dragon Onyx
-	7	113000	1	56 -- Antique Dragon Diamond
-	8	123000	1	56 -- Antique Dragon Ruby
-	9	133000	1	56 -- Antique Dragon Jade
-	10	143000	1	56 -- Antique Dragon Sapphire
-	11	153000	1	56 -- Antique Dragon Garnet
-	12	163000	1	56 -- Antique Dragon Onyx
-	13	114000	1	9 -- Legendary Dragon Diamond
-	14	124000	1	9 -- Legendary Dragon Ruby
-	15	134000	1	9 -- Legendary Dragon Jade
-	16	144000	1	9 -- Legendary DragonSapphire
-	17	154000	1	9 -- Legendary Dragon Garnet
-	18	164000	1	9 -- Legendary Dragon Onyx
-}
-Group	백룡용혼원석_종류별_희귀-전설
-{
-	Vnum	51570 -- Cor Diamas (Divine)
-	1	112000	1	3 -- Rare Dragon Diamond
-	2	113000	1	6 -- Antique Dragon Diamond
-	3	114000	1	1 -- Legendary Dragon Diamond
-}
-Group	화룡용혼원석_종류별_희귀-전설
-{
-	Vnum	51571 -- Cor Rubinum (Divine)
-	1	122000	1	3 -- Rare Dragon Ruby
-	2	123000	1	6 -- Antique Dragon Ruby
-	3	124000	1	1 -- Legendary Dragon Ruby
-}
-Group	풍룡용혼원석_종류별_희귀-전설
-{
-	Vnum	51572 -- Cor Jadeit (Divine)
-	1	132000	1	3 -- Rare Dragon Jade
-	2	133000	1	6 -- Antique Dragon Jade
-	3	134000	1	1 -- Legendary Dragon Jade
-}
-Group	철룡용혼원석_종류별_희귀-전설
-{
-	Vnum	51573 -- Cor Saphirum (Divine)
-	1	142000	1	3 -- Rare Dragon Sapphire
-	2	143000	1	6 -- Antique Dragon Sapphire
-	3	144000	1	1 -- Legendary DragonSapphire
-}
-Group	뇌룡용혼원석_종류별_희귀-전설
-{
-	Vnum	51574 -- Cor Granatum (Divine)
-	1	152000	1	3 -- Rare Dragon Garnet
-	2	153000	1	6 -- Antique Dragon Garnet
-	3	154000	1	1 -- Legendary Dragon Garnet
-}
-Group	흑룡용혼원석_종류별_희귀-전설
-{
-	Vnum	51575 -- Cor Atrum (Divine)
-	1	162000	1	3 -- Rare Dragon Onyx
-	2	163000	1	6 -- Antique Dragon Onyx
-	3	164000	1	1 -- Legendary Dragon Onyx
-}
-Group	강력한용혼원석_일반-화려
-{
-	Vnum	51576 -- Cor Draconis+ (Normal)
-	1	110000	1	324 -- Rough Dragon Diamond
-	2	110010	1	1080
-	3	110020	1	360
-	4	110100	1	1080 -- Rough Dragon Diamond
-	5	110110	1	3600
-	6	110120	1	1200
-	7	110200	1	360 -- Rough Dragon Diamond
-	8	110210	1	1200
-	9	110220	1	400
-	10	110230	1	20
-	11	110300	1	18 -- Rough Dragon Diamond
-	12	110310	1	60
-	13	110320	1	20
-	14	110330	1	1
-	15	110400	1	18 -- Rough Dragon Diamond
-	16	110410	1	60
-	17	110420	1	20
-	18	110430	1	1
-	19	110440	1	1
-	20	111000	1	756 -- Cut Dragon Diamond
-	21	111010	1	2520
-	22	111020	1	840
-	23	111030	1	42
-	24	111100	1	2520 -- Cut Dragon Diamond
-	25	111110	1	8400
-	26	111120	1	2800
-	27	111130	1	140
-	28	111200	1	840 -- Cut Dragon Diamond
-	29	111210	1	2800
-	30	111220	1	933
-	31	111230	1	47
-	32	111300	1	42 -- Cut Dragon Diamond
-	33	111310	1	140
-	34	111320	1	47
-	35	111330	1	2
-	36	111340	1	2
-	37	111400	1	42 -- Cut Dragon Diamond
-	38	111410	1	140
-	39	111420	1	47
-	40	111430	1	2
-	41	111440	1	2
-	42	120000	1	324 -- Rough Dragon Ruby
-	43	120010	1	1080
-	44	120020	1	360
-	45	120100	1	1080 -- Rough Dragon Ruby
-	46	120110	1	3600
-	47	120120	1	1200
-	48	120200	1	360 -- Rough Dragon Ruby
-	49	120210	1	1200
-	50	120220	1	400
-	51	120230	1	20
-	52	120300	1	18 -- Rough Dragon Ruby
-	53	120310	1	60
-	54	120320	1	20
-	55	120330	1	1
-	56	120400	1	18 -- Rough Dragon Ruby
-	57	120410	1	60
-	58	120420	1	20
-	59	120430	1	1
-	60	120440	1	1
-	61	121000	1	756 -- Cut Dragon Ruby
-	62	121010	1	2520
-	63	121020	1	840
-	64	121030	1	42
-	65	121100	1	2520 -- Cut Dragon Ruby
-	66	121110	1	8400
-	67	121120	1	2800
-	68	121130	1	140
-	69	121200	1	840 -- Cut Dragon Ruby
-	70	121210	1	2800
-	71	121220	1	933
-	72	121230	1	47
-	73	121300	1	42 -- Cut Dragon Ruby
-	74	121310	1	140
-	75	121320	1	47
-	76	121330	1	2
-	77	121340	1	2
-	78	121400	1	42 -- Cut Dragon Ruby
-	79	121410	1	140
-	80	121420	1	47
-	81	121430	1	2
-	82	121440	1	2
-	83	130000	1	324 -- Rough Dragon Jade
-	84	130010	1	1080
-	85	130020	1	360
-	86	130100	1	1080 -- Rough Dragon Jade
-	87	130110	1	3600
-	88	130120	1	1200
-	89	130200	1	360 -- Rough Dragon Jade
-	90	130210	1	1200
-	91	130220	1	400
-	92	130230	1	20
-	93	130300	1	18 -- Rough Dragon Jade
-	94	130310	1	60
-	95	130320	1	20
-	96	130330	1	1
-	97	130400	1	18 -- Rough Dragon Jade
-	98	130410	1	60
-	99	130420	1	20
-	100	130430	1	1
-	101	130440	1	1
-	102	131000	1	756 -- Cut Dragon Jade
-	103	131010	1	2520
-	104	131020	1	840
-	105	131030	1	42
-	106	131100	1	2520 -- Cut Dragon Jade
-	107	131110	1	8400
-	108	131120	1	2800
-	109	131130	1	140
-	110	131200	1	840 -- Cut Dragon Jade
-	111	131210	1	2800
-	112	131220	1	933
-	113	131230	1	47
-	114	131300	1	42 -- Cut Dragon Jade
-	115	131310	1	140
-	116	131320	1	47
-	117	131330	1	2
-	118	131340	1	2
-	119	131400	1	42 -- Cut Dragon Jade
-	120	131410	1	140
-	121	131420	1	47
-	122	131430	1	2
-	123	131440	1	2
-	124	140000	1	324 -- Rough Dragon Sapphire
-	125	140010	1	1080
-	126	140020	1	360
-	127	140100	1	1080 -- Rough Dragon Sapphire
-	128	140110	1	3600
-	129	140120	1	1200
-	130	140200	1	360 -- Rough Dragon Sapphire
-	131	140210	1	1200
-	132	140220	1	400
-	133	140230	1	20
-	134	140300	1	18 -- Rough Dragon Sapphire
-	135	140310	1	60
-	136	140320	1	20
-	137	140330	1	1
-	138	140400	1	18 -- Rough Dragon Sapphire
-	139	140410	1	60
-	140	140420	1	20
-	141	140430	1	1
-	142	140440	1	1
-	143	141000	1	756 -- Cut Dragon Sapphire
-	144	141010	1	2520
-	145	141020	1	840
-	146	141030	1	42
-	147	141100	1	2520 -- Cut Dragon Sapphire
-	148	141110	1	8400
-	149	141120	1	2800
-	150	141130	1	140
-	151	141200	1	840 -- Cut Dragon Sapphire
-	152	141210	1	2800
-	153	141220	1	933
-	154	141230	1	47
-	155	141300	1	42 -- Cut Dragon Sapphire
-	156	141310	1	140
-	157	141320	1	47
-	158	141330	1	2
-	159	141340	1	2
-	160	141400	1	42 -- Cut Dragon Sapphire
-	161	141410	1	140
-	162	141420	1	47
-	163	141430	1	2
-	164	141440	1	2
-	165	150000	1	324 -- Rough Dragon Garnet
-	166	150010	1	1080
-	167	150020	1	360
-	168	150100	1	1080 -- Rough Dragon Garnet
-	169	150110	1	3600
-	170	150120	1	1200
-	171	150200	1	360 -- Rough Dragon Garnet
-	172	150210	1	1200
-	173	150220	1	400
-	174	150230	1	20
-	175	150300	1	18 -- Rough Dragon Garnet
-	176	150310	1	60
-	177	150320	1	20
-	178	150330	1	1
-	179	150400	1	18 -- Rough Dragon Garnet
-	180	150410	1	60
-	181	150420	1	20
-	182	150430	1	1
-	183	150440	1	1
-	184	151000	1	756 -- Cut Dragon Garnet
-	185	151010	1	2520
-	186	151020	1	840
-	187	151030	1	42
-	188	151100	1	2520 -- Cut Dragon Garnet
-	189	151110	1	8400
-	190	151120	1	2800
-	191	151130	1	140
-	192	151200	1	840 -- Cut Dragon Garnet
-	193	151210	1	2800
-	194	151220	1	933
-	195	151230	1	47
-	196	151300	1	42 -- Cut Dragon Garnet
-	197	151310	1	140
-	198	151320	1	47
-	199	151330	1	2
-	200	151340	1	2
-	201	151400	1	42 -- Cut Dragon Garnet
-	202	151410	1	140
-	203	151420	1	47
-	204	151430	1	2
-	205	151440	1	2
-	206	160000	1	324 -- Rough Dragon Onyx
-	207	160010	1	1080
-	208	160020	1	360
-	209	160100	1	1080 -- Rough Dragon Onyx
-	210	160110	1	3600
-	211	160120	1	1200
-	212	160200	1	360 -- Rough Dragon Onyx
-	213	160210	1	1200
-	214	160220	1	400
-	215	160230	1	20
-	216	160300	1	18 -- Rough Dragon Onyx
-	217	160310	1	60
-	218	160320	1	20
-	219	160330	1	1
-	220	160400	1	18 -- Rough Dragon Onyx
-	221	160410	1	60
-	222	160420	1	20
-	223	160430	1	1
-	224	160440	1	1
-	225	161000	1	756 -- Cut Dragon Onyx
-	226	161010	1	2520
-	227	161020	1	840
-	228	161030	1	42
-	229	161100	1	2520 -- Cut Dragon Onyx
-	230	161110	1	8400
-	231	161120	1	2800
-	232	161130	1	140
-	233	161200	1	840 -- Cut Dragon Onyx
-	234	161210	1	2800
-	235	161220	1	933
-	236	161230	1	47
-	237	161300	1	42 -- Cut Dragon Onyx
-	238	161310	1	140
-	239	161320	1	47
-	240	161330	1	2
-	241	161340	1	2
-	242	161400	1	42 -- Cut Dragon Onyx
-	243	161410	1	140
-	244	161420	1	47
-	245	161430	1	2
-	246	161440	1	2
-}
-Group	백룡강력한용혼원석_일반-화려
-{
-	Vnum	51577 -- Cor Diamas+ (Normal)
-	1	110000	1	324 -- Rough Dragon Diamond
-	2	110010	1	1080
-	3	110020	1	360
-	4	110100	1	1080 -- Rough Dragon Diamond
-	5	110110	1	3600
-	6	110120	1	1200
-	7	110200	1	360 -- Rough Dragon Diamond
-	8	110210	1	1200
-	9	110220	1	400
-	10	110230	1	20
-	11	110300	1	18 -- Rough Dragon Diamond
-	12	110310	1	60
-	13	110320	1	20
-	14	110330	1	1
-	15	110400	1	18 -- Rough Dragon Diamond
-	16	110410	1	60
-	17	110420	1	20
-	18	110430	1	1
-	19	110440	1	1
-	20	111000	1	756 -- Cut Dragon Diamond
-	21	111010	1	2520
-	22	111020	1	840
-	23	111030	1	42
-	24	111100	1	2520 -- Cut Dragon Diamond
-	25	111110	1	8400
-	26	111120	1	2800
-	27	111130	1	140
-	28	111200	1	840 -- Cut Dragon Diamond
-	29	111210	1	2800
-	30	111220	1	933
-	31	111230	1	47
-	32	111300	1	42 -- Cut Dragon Diamond
-	33	111310	1	140
-	34	111320	1	47
-	35	111330	1	2
-	36	111340	1	2
-	37	111400	1	42 -- Cut Dragon Diamond
-	38	111410	1	140
-	39	111420	1	47
-	40	111430	1	2
-	41	111440	1	2
-}
-Group	화룡강력한용혼원석_일반-화려
-{
-	Vnum	51578 -- Cor Rubinum+ (Normal)
-	1	120000	1	324 -- Rough Dragon Ruby
-	2	120010	1	1080
-	3	120020	1	360
-	4	120100	1	1080 -- Rough Dragon Ruby
-	5	120110	1	3600
-	6	120120	1	1200
-	7	120200	1	360 -- Rough Dragon Ruby
-	8	120210	1	1200
-	9	120220	1	400
-	10	120230	1	20
-	11	120300	1	18 -- Rough Dragon Ruby
-	12	120310	1	60
-	13	120320	1	20
-	14	120330	1	1
-	15	120400	1	18 -- Rough Dragon Ruby
-	16	120410	1	60
-	17	120420	1	20
-	18	120430	1	1
-	19	120440	1	1
-	20	121000	1	756 -- Cut Dragon Ruby
-	21	121010	1	2520
-	22	121020	1	840
-	23	121030	1	42
-	24	121100	1	2520 -- Cut Dragon Ruby
-	25	121110	1	8400
-	26	121120	1	2800
-	27	121130	1	140
-	28	121200	1	840 -- Cut Dragon Ruby
-	29	121210	1	2800
-	30	121220	1	933
-	31	121230	1	47
-	32	121300	1	42 -- Cut Dragon Ruby
-	33	121310	1	140
-	34	121320	1	47
-	35	121330	1	2
-	36	121340	1	2
-	37	121400	1	42 -- Cut Dragon Ruby
-	38	121410	1	140
-	39	121420	1	47
-	40	121430	1	2
-	41	121440	1	2
-}
-Group	풍룡강력한용혼원석_일반-화려
-{
-	Vnum	51579 -- Cor Jadeit+ (Normal)
-	1	130000	1	324 -- Rough Dragon Jade
-	2	130010	1	1080
-	3	130020	1	360
-	4	130100	1	1080 -- Rough Dragon Jade
-	5	130110	1	3600
-	6	130120	1	1200
-	7	130200	1	360 -- Rough Dragon Jade
-	8	130210	1	1200
-	9	130220	1	400
-	10	130230	1	20
-	11	130300	1	18 -- Rough Dragon Jade
-	12	130310	1	60
-	13	130320	1	20
-	14	130330	1	1
-	15	130400	1	18 -- Rough Dragon Jade
-	16	130410	1	60
-	17	130420	1	20
-	18	130430	1	1
-	19	130440	1	1
-	20	131000	1	756 -- Cut Dragon Jade
-	21	131010	1	2520
-	22	131020	1	840
-	23	131030	1	42
-	24	131100	1	2520 -- Cut Dragon Jade
-	25	131110	1	8400
-	26	131120	1	2800
-	27	131130	1	140
-	28	131200	1	840 -- Cut Dragon Jade
-	29	131210	1	2800
-	30	131220	1	933
-	31	131230	1	47
-	32	131300	1	42 -- Cut Dragon Jade
-	33	131310	1	140
-	34	131320	1	47
-	35	131330	1	2
-	36	131340	1	2
-	37	131400	1	42 -- Cut Dragon Jade
-	38	131410	1	140
-	39	131420	1	47
-	40	131430	1	2
-	41	131440	1	2
-}
-Group	철룡강력한용혼원석_일반-화려
-{
-	Vnum	51580 -- Cor Saphirum+ (Normal)
-	1	140000	1	324 -- Rough Dragon Sapphire
-	2	140010	1	1080
-	3	140020	1	360
-	4	140100	1	1080 -- Rough Dragon Sapphire
-	5	140110	1	3600
-	6	140120	1	1200
-	7	140200	1	360 -- Rough Dragon Sapphire
-	8	140210	1	1200
-	9	140220	1	400
-	10	140230	1	20
-	11	140300	1	18 -- Rough Dragon Sapphire
-	12	140310	1	60
-	13	140320	1	20
-	14	140330	1	1
-	15	140400	1	18 -- Rough Dragon Sapphire
-	16	140410	1	60
-	17	140420	1	20
-	18	140430	1	1
-	19	140440	1	1
-	20	141000	1	756 -- Cut Dragon Sapphire
-	21	141010	1	2520
-	22	141020	1	840
-	23	141030	1	42
-	24	141100	1	2520 -- Cut Dragon Sapphire
-	25	141110	1	8400
-	26	141120	1	2800
-	27	141130	1	140
-	28	141200	1	840 -- Cut Dragon Sapphire
-	29	141210	1	2800
-	30	141220	1	933
-	31	141230	1	47
-	32	141300	1	42 -- Cut Dragon Sapphire
-	33	141310	1	140
-	34	141320	1	47
-	35	141330	1	2
-	36	141340	1	2
-	37	141400	1	42 -- Cut Dragon Sapphire
-	38	141410	1	140
-	39	141420	1	47
-	40	141430	1	2
-	41	141440	1	2
-}
-Group	뇌룡강력한용혼원석_일반-화려
-{
-	Vnum	51581 -- Cor Granatum+ (Normal)
-	1	150000	1	324 -- Rough Dragon Garnet
-	2	150010	1	1080
-	3	150020	1	360
-	4	150100	1	1080 -- Rough Dragon Garnet
-	5	150110	1	3600
-	6	150120	1	1200
-	7	150200	1	360 -- Rough Dragon Garnet
-	8	150210	1	1200
-	9	150220	1	400
-	10	150230	1	20
-	11	150300	1	18 -- Rough Dragon Garnet
-	12	150310	1	60
-	13	150320	1	20
-	14	150330	1	1
-	15	150400	1	18 -- Rough Dragon Garnet
-	16	150410	1	60
-	17	150420	1	20
-	18	150430	1	1
-	19	150440	1	1
-	20	151000	1	756 -- Cut Dragon Garnet
-	21	151010	1	2520
-	22	151020	1	840
-	23	151030	1	42
-	24	151100	1	2520 -- Cut Dragon Garnet
-	25	151110	1	8400
-	26	151120	1	2800
-	27	151130	1	140
-	28	151200	1	840 -- Cut Dragon Garnet
-	29	151210	1	2800
-	30	151220	1	933
-	31	151230	1	47
-	32	151300	1	42 -- Cut Dragon Garnet
-	33	151310	1	140
-	34	151320	1	47
-	35	151330	1	2
-	36	151340	1	2
-	37	151400	1	42 -- Cut Dragon Garnet
-	38	151410	1	140
-	39	151420	1	47
-	40	151430	1	2
-	41	151440	1	2
-}
-Group	흑룡강력한용혼원석_일반-화려
-{
-	Vnum	51582 -- Cor Atrum+ (Normal)
-	1	160000	1	324 -- Rough Dragon Onyx
-	2	160010	1	1080
-	3	160020	1	360
-	4	160100	1	1080 -- Rough Dragon Onyx
-	5	160110	1	3600
-	6	160120	1	1200
-	7	160200	1	360 -- Rough Dragon Onyx
-	8	160210	1	1200
-	9	160220	1	400
-	10	160230	1	20
-	11	160300	1	18 -- Rough Dragon Onyx
-	12	160310	1	60
-	13	160320	1	20
-	14	160330	1	1
-	15	160400	1	18 -- Rough Dragon Onyx
-	16	160410	1	60
-	17	160420	1	20
-	18	160430	1	1
-	19	160440	1	1
-	20	161000	1	756 -- Cut Dragon Onyx
-	21	161010	1	2520
-	22	161020	1	840
-	23	161030	1	42
-	24	161100	1	2520 -- Cut Dragon Onyx
-	25	161110	1	8400
-	26	161120	1	2800
-	27	161130	1	140
-	28	161200	1	840 -- Cut Dragon Onyx
-	29	161210	1	2800
-	30	161220	1	933
-	31	161230	1	47
-	32	161300	1	42 -- Cut Dragon Onyx
-	33	161310	1	140
-	34	161320	1	47
-	35	161330	1	2
-	36	161340	1	2
-	37	161400	1	42 -- Cut Dragon Onyx
-	38	161410	1	140
-	39	161420	1	47
-	40	161430	1	2
-	41	161440	1	2
-}
-Group	강력한용혼원석_일반-희귀
-{
-	Vnum	51583 -- Cor Draconis+ (Noble)
-	1	110000	1	972 -- Rough Dragon Diamond
-	2	110010	1	3240
-	3	110020	1	1080
-	4	110100	1	3240 -- Rough Dragon Diamond
-	5	110110	1	10800
-	6	110120	1	3600
-	7	110200	1	1080 -- Rough Dragon Diamond
-	8	110210	1	3600
-	9	110220	1	1200
-	10	110230	1	60
-	11	110300	1	54 -- Rough Dragon Diamond
-	12	110310	1	180
-	13	110320	1	60
-	14	110330	1	3
-	15	110400	1	54 -- Rough Dragon Diamond
-	16	110410	1	180
-	17	110420	1	60
-	18	110430	1	3
-	19	110440	1	3
-	20	111000	1	1944 -- Cut Dragon Diamond
-	21	111010	1	6480
-	22	111020	1	2160
-	23	111030	1	108
-	24	111100	1	6480 -- Cut Dragon Diamond
-	25	111110	1	21600
-	26	111120	1	7200
-	27	111130	1	360
-	28	111200	1	2160 -- Cut Dragon Diamond
-	29	111210	1	7200
-	30	111220	1	2400
-	31	111230	1	120
-	32	111300	1	108 -- Cut Dragon Diamond
-	33	111310	1	360
-	34	111320	1	120
-	35	111330	1	6
-	36	111340	1	6
-	37	111400	1	108 -- Cut Dragon Diamond
-	38	111410	1	360
-	39	111420	1	120
-	40	111430	1	6
-	41	111440	1	6
-	42	112000	1	324 -- Rare Dragon Diamond
-	43	112010	1	1080
-	44	112020	1	360
-	45	112030	1	18
-	46	112040	1	18
-	47	112100	1	1080 -- Rare Dragon Diamond
-	48	112110	1	3600
-	49	112120	1	1200
-	50	112130	1	60
-	51	112140	1	60
-	52	112200	1	360 -- Rare Dragon Diamond
-	53	112210	1	1200
-	54	112220	1	400
-	55	112230	1	20
-	56	112240	1	20
-	57	112300	1	18 -- Rare Dragon Diamond
-	58	112310	1	60
-	59	112320	1	20
-	60	112330	1	1
-	61	112340	1	1
-	62	112400	1	18 -- Rare Dragon Diamond
-	63	112410	1	60
-	64	112420	1	20
-	65	112430	1	1
-	66	112440	1	1
-	67	120000	1	972 -- Rough Dragon Ruby
-	68	120010	1	3240
-	69	120020	1	1080
-	70	120100	1	3240 -- Rough Dragon Ruby
-	71	120110	1	10800
-	72	120120	1	3600
-	73	120200	1	1080 -- Rough Dragon Ruby
-	74	120210	1	3600
-	75	120220	1	1200
-	76	120230	1	60
-	77	120300	1	54 -- Rough Dragon Ruby
-	78	120310	1	180
-	79	120320	1	60
-	80	120330	1	3
-	81	120400	1	54 -- Rough Dragon Ruby
-	82	120410	1	180
-	83	120420	1	60
-	84	120430	1	3
-	85	120440	1	3
-	86	121000	1	1944 -- Cut Dragon Ruby
-	87	121010	1	6480
-	88	121020	1	2160
-	89	121030	1	108
-	90	121100	1	6480 -- Cut Dragon Ruby
-	91	121110	1	21600
-	92	121120	1	7200
-	93	121130	1	360
-	94	121200	1	2160 -- Cut Dragon Ruby
-	95	121210	1	7200
-	96	121220	1	2400
-	97	121230	1	120
-	98	121300	1	108 -- Cut Dragon Ruby
-	99	121310	1	360
-	100	121320	1	120
-	101	121330	1	6
-	102	121340	1	6
-	103	121400	1	108 -- Cut Dragon Ruby
-	104	121410	1	360
-	105	121420	1	120
-	106	121430	1	6
-	107	121440	1	6
-	108	122000	1	324 -- Rare Dragon Ruby
-	109	122010	1	1080
-	110	122020	1	360
-	111	122030	1	18
-	112	122040	1	18
-	113	122100	1	1080 -- Rare Dragon Ruby
-	114	122110	1	3600
-	115	122120	1	1200
-	116	122130	1	60
-	117	122140	1	60
-	118	122200	1	360 -- Rare Dragon Ruby
-	119	122210	1	1200
-	120	122220	1	400
-	121	122230	1	20
-	122	122240	1	20
-	123	122300	1	18 -- Rare Dragon Ruby
-	124	122310	1	60
-	125	122320	1	20
-	126	122330	1	1
-	127	122340	1	1
-	128	122400	1	18 -- Rare Dragon Ruby
-	129	122410	1	60
-	130	122420	1	20
-	131	122430	1	1
-	132	122440	1	1
-	133	130000	1	972 -- Rough Dragon Jade
-	134	130010	1	3240
-	135	130020	1	1080
-	136	130100	1	3240 -- Rough Dragon Jade
-	137	130110	1	10800
-	138	130120	1	3600
-	139	130200	1	1080 -- Rough Dragon Jade
-	140	130210	1	3600
-	141	130220	1	1200
-	142	130230	1	60
-	143	130300	1	54 -- Rough Dragon Jade
-	144	130310	1	180
-	145	130320	1	60
-	146	130330	1	3
-	147	130400	1	54 -- Rough Dragon Jade
-	148	130410	1	180
-	149	130420	1	60
-	150	130430	1	3
-	151	130440	1	3
-	152	131000	1	1944 -- Cut Dragon Jade
-	153	131010	1	6480
-	154	131020	1	2160
-	155	131030	1	108
-	156	131100	1	6480 -- Cut Dragon Jade
-	157	131110	1	21600
-	158	131120	1	7200
-	159	131130	1	360
-	160	131200	1	2160 -- Cut Dragon Jade
-	161	131210	1	7200
-	162	131220	1	2400
-	163	131230	1	120
-	164	131300	1	108 -- Cut Dragon Jade
-	165	131310	1	360
-	166	131320	1	120
-	167	131330	1	6
-	168	131340	1	6
-	169	131400	1	108 -- Cut Dragon Jade
-	170	131410	1	360
-	171	131420	1	120
-	172	131430	1	6
-	173	131440	1	6
-	174	132000	1	324 -- Rare Dragon Jade
-	175	132010	1	1080
-	176	132020	1	360
-	177	132030	1	18
-	178	132040	1	18
-	179	132100	1	1080 -- Rare Dragon Jade
-	180	132110	1	3600
-	181	132120	1	1200
-	182	132130	1	60
-	183	132140	1	60
-	184	132200	1	360 -- Rare Dragon Jade
-	185	132210	1	1200
-	186	132220	1	400
-	187	132230	1	20
-	188	132240	1	20
-	189	132300	1	18 -- Rare Dragon Jade
-	190	132310	1	60
-	191	132320	1	20
-	192	132330	1	1
-	193	132340	1	1
-	194	132400	1	18 -- Rare Dragon Jade
-	195	132410	1	60
-	196	132420	1	20
-	197	132430	1	1
-	198	132440	1	1
-	199	140000	1	972 -- Rough Dragon Sapphire
-	200	140010	1	3240
-	201	140020	1	1080
-	202	140100	1	3240 -- Rough Dragon Sapphire
-	203	140110	1	10800
-	204	140120	1	3600
-	205	140200	1	1080 -- Rough Dragon Sapphire
-	206	140210	1	3600
-	207	140220	1	1200
-	208	140230	1	60
-	209	140300	1	54 -- Rough Dragon Sapphire
-	210	140310	1	180
-	211	140320	1	60
-	212	140330	1	3
-	213	140400	1	54 -- Rough Dragon Sapphire
-	214	140410	1	180
-	215	140420	1	60
-	216	140430	1	3
-	217	140440	1	3
-	218	141000	1	1944 -- Cut Dragon Sapphire
-	219	141010	1	6480
-	220	141020	1	2160
-	221	141030	1	108
-	222	141100	1	6480 -- Cut Dragon Sapphire
-	223	141110	1	21600
-	224	141120	1	7200
-	225	141130	1	360
-	226	141200	1	2160 -- Cut Dragon Sapphire
-	227	141210	1	7200
-	228	141220	1	2400
-	229	141230	1	120
-	230	141300	1	108 -- Cut Dragon Sapphire
-	231	141310	1	360
-	232	141320	1	120
-	233	141330	1	6
-	234	141340	1	6
-	235	141400	1	108 -- Cut Dragon Sapphire
-	236	141410	1	360
-	237	141420	1	120
-	238	141430	1	6
-	239	141440	1	6
-	240	142000	1	324 -- Rare Dragon Sapphire
-	241	142010	1	1080
-	242	142020	1	360
-	243	142030	1	18
-	244	142040	1	18
-	245	142100	1	1080 -- Rare Dragon Sapphire
-	246	142110	1	3600
-	247	142120	1	1200
-	248	142130	1	60
-	249	142140	1	60
-	250	142200	1	360 -- Rare Dragon Sapphire
-	251	142210	1	1200
-	252	142220	1	400
-	253	142230	1	20
-	254	142240	1	20
-	255	142300	1	18 -- Rare Dragon Sapphire
-	256	142310	1	60
-	257	142320	1	20
-	258	142330	1	1
-	259	142340	1	1
-	260	142400	1	18 -- Rare Dragon Sapphire
-	261	142410	1	60
-	262	142420	1	20
-	263	142430	1	1
-	264	142440	1	1
-	265	150000	1	972 -- Rough Dragon Garnet
-	266	150010	1	3240
-	267	150020	1	1080
-	268	150100	1	3240 -- Rough Dragon Garnet
-	269	150110	1	10800
-	270	150120	1	3600
-	271	150200	1	1080 -- Rough Dragon Garnet
-	272	150210	1	3600
-	273	150220	1	1200
-	274	150230	1	60
-	275	150300	1	54 -- Rough Dragon Garnet
-	276	150310	1	180
-	277	150320	1	60
-	278	150330	1	3
-	279	150400	1	54 -- Rough Dragon Garnet
-	280	150410	1	180
-	281	150420	1	60
-	282	150430	1	3
-	283	150440	1	3
-	284	151000	1	1944 -- Cut Dragon Garnet
-	285	151010	1	6480
-	286	151020	1	2160
-	287	151030	1	108
-	288	151100	1	6480 -- Cut Dragon Garnet
-	289	151110	1	21600
-	290	151120	1	7200
-	291	151130	1	360
-	292	151200	1	2160 -- Cut Dragon Garnet
-	293	151210	1	7200
-	294	151220	1	2400
-	295	151230	1	120
-	296	151300	1	108 -- Cut Dragon Garnet
-	297	151310	1	360
-	298	151320	1	120
-	299	151330	1	6
-	300	151340	1	6
-	301	151400	1	108 -- Cut Dragon Garnet
-	302	151410	1	360
-	303	151420	1	120
-	304	151430	1	6
-	305	151440	1	6
-	306	152000	1	324 -- Rare Dragon Garnet
-	307	152010	1	1080
-	308	152020	1	360
-	309	152030	1	18
-	310	152040	1	18
-	311	152100	1	1080 -- Rare Dragon Garnet
-	312	152110	1	3600
-	313	152120	1	1200
-	314	152130	1	60
-	315	152140	1	60
-	316	152200	1	360 -- Rare Dragon Garnet
-	317	152210	1	1200
-	318	152220	1	400
-	319	152230	1	20
-	320	152240	1	20
-	321	152300	1	18 -- Rare Dragon Garnet
-	322	152310	1	60
-	323	152320	1	20
-	324	152330	1	1
-	325	152340	1	1
-	326	152400	1	18 -- Rare Dragon Garnet
-	327	152410	1	60
-	328	152420	1	20
-	329	152430	1	1
-	330	152440	1	1
-	331	160000	1	972 -- Rough Dragon Onyx
-	332	160010	1	3240
-	333	160020	1	1080
-	334	160100	1	3240 -- Rough Dragon Onyx
-	335	160110	1	10800
-	336	160120	1	3600
-	337	160200	1	1080 -- Rough Dragon Onyx
-	338	160210	1	3600
-	339	160220	1	1200
-	340	160230	1	60
-	341	160300	1	54 -- Rough Dragon Onyx
-	342	160310	1	180
-	343	160320	1	60
-	344	160330	1	3
-	345	160400	1	54 -- Rough Dragon Onyx
-	346	160410	1	180
-	347	160420	1	60
-	348	160430	1	3
-	349	160440	1	3
-	350	161000	1	1944 -- Cut Dragon Onyx
-	351	161010	1	6480
-	352	161020	1	2160
-	353	161030	1	108
-	354	161100	1	6480 -- Cut Dragon Onyx
-	355	161110	1	21600
-	356	161120	1	7200
-	357	161130	1	360
-	358	161200	1	2160 -- Cut Dragon Onyx
-	359	161210	1	7200
-	360	161220	1	2400
-	361	161230	1	120
-	362	161300	1	108 -- Cut Dragon Onyx
-	363	161310	1	360
-	364	161320	1	120
-	365	161330	1	6
-	366	161340	1	6
-	367	161400	1	108 -- Cut Dragon Onyx
-	368	161410	1	360
-	369	161420	1	120
-	370	161430	1	6
-	371	161440	1	6
-	372	162000	1	324 -- Rare Dragon Onyx
-	373	162010	1	1080
-	374	162020	1	360
-	375	162030	1	18
-	376	162040	1	18
-	377	162100	1	1080 -- Rare Dragon Onyx
-	378	162110	1	3600
-	379	162120	1	1200
-	380	162130	1	60
-	381	162140	1	60
-	382	162200	1	360 -- Rare Dragon Onyx
-	383	162210	1	1200
-	384	162220	1	400
-	385	162230	1	20
-	386	162240	1	20
-	387	162300	1	18 -- Rare Dragon Onyx
-	388	162310	1	60
-	389	162320	1	20
-	390	162330	1	1
-	391	162340	1	1
-	392	162400	1	18 -- Rare Dragon Onyx
-	393	162410	1	60
-	394	162420	1	20
-	395	162430	1	1
-	396	162440	1	1
-}
-Group	백룡강력한용혼원석_일반-희귀
-{
-	Vnum	51584 -- Cor Diamas+ (Noble)
-	1	110000	1	972 -- Rough Dragon Diamond
-	2	110010	1	3240
-	3	110020	1	1080
-	4	110100	1	3240 -- Rough Dragon Diamond
-	5	110110	1	10800
-	6	110120	1	3600
-	7	110200	1	1080 -- Rough Dragon Diamond
-	8	110210	1	3600
-	9	110220	1	1200
-	10	110230	1	60
-	11	110300	1	54 -- Rough Dragon Diamond
-	12	110310	1	180
-	13	110320	1	60
-	14	110330	1	3
-	15	110400	1	54 -- Rough Dragon Diamond
-	16	110410	1	180
-	17	110420	1	60
-	18	110430	1	3
-	19	110440	1	3
-	20	111000	1	1944 -- Cut Dragon Diamond
-	21	111010	1	6480
-	22	111020	1	2160
-	23	111030	1	108
-	24	111100	1	6480 -- Cut Dragon Diamond
-	25	111110	1	21600
-	26	111120	1	7200
-	27	111130	1	360
-	28	111200	1	2160 -- Cut Dragon Diamond
-	29	111210	1	7200
-	30	111220	1	2400
-	31	111230	1	120
-	32	111300	1	108 -- Cut Dragon Diamond
-	33	111310	1	360
-	34	111320	1	120
-	35	111330	1	6
-	36	111340	1	6
-	37	111400	1	108 -- Cut Dragon Diamond
-	38	111410	1	360
-	39	111420	1	120
-	40	111430	1	6
-	41	111440	1	6
-	42	112000	1	324 -- Rare Dragon Diamond
-	43	112010	1	1080
-	44	112020	1	360
-	45	112030	1	18
-	46	112040	1	18
-	47	112100	1	1080 -- Rare Dragon Diamond
-	48	112110	1	3600
-	49	112120	1	1200
-	50	112130	1	60
-	51	112140	1	60
-	52	112200	1	360 -- Rare Dragon Diamond
-	53	112210	1	1200
-	54	112220	1	400
-	55	112230	1	20
-	56	112240	1	20
-	57	112300	1	18 -- Rare Dragon Diamond
-	58	112310	1	60
-	59	112320	1	20
-	60	112330	1	1
-	61	112340	1	1
-	62	112400	1	18 -- Rare Dragon Diamond
-	63	112410	1	60
-	64	112420	1	20
-	65	112430	1	1
-	66	112440	1	1
-}
-Group	화룡강력한용혼원석_일반-희귀
-{
-	Vnum	51585 -- Cor Rubinum+ (Noble)
-	1	120000	1	972 -- Rough Dragon Ruby
-	2	120010	1	3240
-	3	120020	1	1080
-	4	120100	1	3240 -- Rough Dragon Ruby
-	5	120110	1	10800
-	6	120120	1	3600
-	7	120200	1	1080 -- Rough Dragon Ruby
-	8	120210	1	3600
-	9	120220	1	1200
-	10	120230	1	60
-	11	120300	1	54 -- Rough Dragon Ruby
-	12	120310	1	180
-	13	120320	1	60
-	14	120330	1	3
-	15	120400	1	54 -- Rough Dragon Ruby
-	16	120410	1	180
-	17	120420	1	60
-	18	120430	1	3
-	19	120440	1	3
-	20	121000	1	1944 -- Cut Dragon Ruby
-	21	121010	1	6480
-	22	121020	1	2160
-	23	121030	1	108
-	24	121100	1	6480 -- Cut Dragon Ruby
-	25	121110	1	21600
-	26	121120	1	7200
-	27	121130	1	360
-	28	121200	1	2160 -- Cut Dragon Ruby
-	29	121210	1	7200
-	30	121220	1	2400
-	31	121230	1	120
-	32	121300	1	108 -- Cut Dragon Ruby
-	33	121310	1	360
-	34	121320	1	120
-	35	121330	1	6
-	36	121340	1	6
-	37	121400	1	108 -- Cut Dragon Ruby
-	38	121410	1	360
-	39	121420	1	120
-	40	121430	1	6
-	41	121440	1	6
-	42	122000	1	324 -- Rare Dragon Ruby
-	43	122010	1	1080
-	44	122020	1	360
-	45	122030	1	18
-	46	122040	1	18
-	47	122100	1	1080 -- Rare Dragon Ruby
-	48	122110	1	3600
-	49	122120	1	1200
-	50	122130	1	60
-	51	122140	1	60
-	52	122200	1	360 -- Rare Dragon Ruby
-	53	122210	1	1200
-	54	122220	1	400
-	55	122230	1	20
-	56	122240	1	20
-	57	122300	1	18 -- Rare Dragon Ruby
-	58	122310	1	60
-	59	122320	1	20
-	60	122330	1	1
-	61	122340	1	1
-	62	122400	1	18 -- Rare Dragon Ruby
-	63	122410	1	60
-	64	122420	1	20
-	65	122430	1	1
-	66	122440	1	1
-}
-Group	풍룡강력한용혼원석_일반-희귀
-{
-	Vnum	51586 -- Cor Jadeit+ (Noble)
-	1	130000	1	972 -- Rough Dragon Jade
-	2	130010	1	3240
-	3	130020	1	1080
-	4	130100	1	3240 -- Rough Dragon Jade
-	5	130110	1	10800
-	6	130120	1	3600
-	7	130200	1	1080 -- Rough Dragon Jade
-	8	130210	1	3600
-	9	130220	1	1200
-	10	130230	1	60
-	11	130300	1	54 -- Rough Dragon Jade
-	12	130310	1	180
-	13	130320	1	60
-	14	130330	1	3
-	15	130400	1	54 -- Rough Dragon Jade
-	16	130410	1	180
-	17	130420	1	60
-	18	130430	1	3
-	19	130440	1	3
-	20	131000	1	1944 -- Cut Dragon Jade
-	21	131010	1	6480
-	22	131020	1	2160
-	23	131030	1	108
-	24	131100	1	6480 -- Cut Dragon Jade
-	25	131110	1	21600
-	26	131120	1	7200
-	27	131130	1	360
-	28	131200	1	2160 -- Cut Dragon Jade
-	29	131210	1	7200
-	30	131220	1	2400
-	31	131230	1	120
-	32	131300	1	108 -- Cut Dragon Jade
-	33	131310	1	360
-	34	131320	1	120
-	35	131330	1	6
-	36	131340	1	6
-	37	131400	1	108 -- Cut Dragon Jade
-	38	131410	1	360
-	39	131420	1	120
-	40	131430	1	6
-	41	131440	1	6
-	42	132000	1	324 -- Rare Dragon Jade
-	43	132010	1	1080
-	44	132020	1	360
-	45	132030	1	18
-	46	132040	1	18
-	47	132100	1	1080 -- Rare Dragon Jade
-	48	132110	1	3600
-	49	132120	1	1200
-	50	132130	1	60
-	51	132140	1	60
-	52	132200	1	360 -- Rare Dragon Jade
-	53	132210	1	1200
-	54	132220	1	400
-	55	132230	1	20
-	56	132240	1	20
-	57	132300	1	18 -- Rare Dragon Jade
-	58	132310	1	60
-	59	132320	1	20
-	60	132330	1	1
-	61	132340	1	1
-	62	132400	1	18 -- Rare Dragon Jade
-	63	132410	1	60
-	64	132420	1	20
-	65	132430	1	1
-	66	132440	1	1
-}
-Group	철룡강력한용혼원석_일반-희귀
-{
-	Vnum	51587 -- Cor Saphirum+ (Noble)
-	1	140000	1	972 -- Rough Dragon Sapphire
-	2	140010	1	3240
-	3	140020	1	1080
-	4	140100	1	3240 -- Rough Dragon Sapphire
-	5	140110	1	10800
-	6	140120	1	3600
-	7	140200	1	1080 -- Rough Dragon Sapphire
-	8	140210	1	3600
-	9	140220	1	1200
-	10	140230	1	60
-	11	140300	1	54 -- Rough Dragon Sapphire
-	12	140310	1	180
-	13	140320	1	60
-	14	140330	1	3
-	15	140400	1	54 -- Rough Dragon Sapphire
-	16	140410	1	180
-	17	140420	1	60
-	18	140430	1	3
-	19	140440	1	3
-	20	141000	1	1944 -- Cut Dragon Sapphire
-	21	141010	1	6480
-	22	141020	1	2160
-	23	141030	1	108
-	24	141100	1	6480 -- Cut Dragon Sapphire
-	25	141110	1	21600
-	26	141120	1	7200
-	27	141130	1	360
-	28	141200	1	2160 -- Cut Dragon Sapphire
-	29	141210	1	7200
-	30	141220	1	2400
-	31	141230	1	120
-	32	141300	1	108 -- Cut Dragon Sapphire
-	33	141310	1	360
-	34	141320	1	120
-	35	141330	1	6
-	36	141340	1	6
-	37	141400	1	108 -- Cut Dragon Sapphire
-	38	141410	1	360
-	39	141420	1	120
-	40	141430	1	6
-	41	141440	1	6
-	42	142000	1	324 -- Rare Dragon Sapphire
-	43	142010	1	1080
-	44	142020	1	360
-	45	142030	1	18
-	46	142040	1	18
-	47	142100	1	1080 -- Rare Dragon Sapphire
-	48	142110	1	3600
-	49	142120	1	1200
-	50	142130	1	60
-	51	142140	1	60
-	52	142200	1	360 -- Rare Dragon Sapphire
-	53	142210	1	1200
-	54	142220	1	400
-	55	142230	1	20
-	56	142240	1	20
-	57	142300	1	18 -- Rare Dragon Sapphire
-	58	142310	1	60
-	59	142320	1	20
-	60	142330	1	1
-	61	142340	1	1
-	62	142400	1	18 -- Rare Dragon Sapphire
-	63	142410	1	60
-	64	142420	1	20
-	65	142430	1	1
-	66	142440	1	1
-}
-Group	뇌룡강력한용혼원석_일반-희귀
-{
-	Vnum	51588 -- Cor Granatum+ (Noble)
-	1	150000	1	972 -- Rough Dragon Garnet
-	2	150010	1	3240
-	3	150020	1	1080
-	4	150100	1	3240 -- Rough Dragon Garnet
-	5	150110	1	10800
-	6	150120	1	3600
-	7	150200	1	1080 -- Rough Dragon Garnet
-	8	150210	1	3600
-	9	150220	1	1200
-	10	150230	1	60
-	11	150300	1	54 -- Rough Dragon Garnet
-	12	150310	1	180
-	13	150320	1	60
-	14	150330	1	3
-	15	150400	1	54 -- Rough Dragon Garnet
-	16	150410	1	180
-	17	150420	1	60
-	18	150430	1	3
-	19	150440	1	3
-	20	151000	1	1944 -- Cut Dragon Garnet
-	21	151010	1	6480
-	22	151020	1	2160
-	23	151030	1	108
-	24	151100	1	6480 -- Cut Dragon Garnet
-	25	151110	1	21600
-	26	151120	1	7200
-	27	151130	1	360
-	28	151200	1	2160 -- Cut Dragon Garnet
-	29	151210	1	7200
-	30	151220	1	2400
-	31	151230	1	120
-	32	151300	1	108 -- Cut Dragon Garnet
-	33	151310	1	360
-	34	151320	1	120
-	35	151330	1	6
-	36	151340	1	6
-	37	151400	1	108 -- Cut Dragon Garnet
-	38	151410	1	360
-	39	151420	1	120
-	40	151430	1	6
-	41	151440	1	6
-	42	152000	1	324 -- Rare Dragon Garnet
-	43	152010	1	1080
-	44	152020	1	360
-	45	152030	1	18
-	46	152040	1	18
-	47	152100	1	1080 -- Rare Dragon Garnet
-	48	152110	1	3600
-	49	152120	1	1200
-	50	152130	1	60
-	51	152140	1	60
-	52	152200	1	360 -- Rare Dragon Garnet
-	53	152210	1	1200
-	54	152220	1	400
-	55	152230	1	20
-	56	152240	1	20
-	57	152300	1	18 -- Rare Dragon Garnet
-	58	152310	1	60
-	59	152320	1	20
-	60	152330	1	1
-	61	152340	1	1
-	62	152400	1	18 -- Rare Dragon Garnet
-	63	152410	1	60
-	64	152420	1	20
-	65	152430	1	1
-	66	152440	1	1
-}
-Group	흑룡강력한용혼원석_일반-희귀
-{
-	Vnum	51589 -- Cor Atrum+ (Noble)
-	1	160000	1	972 -- Rough Dragon Onyx
-	2	160010	1	3240
-	3	160020	1	1080
-	4	160100	1	3240 -- Rough Dragon Onyx
-	5	160110	1	10800
-	6	160120	1	3600
-	7	160200	1	1080 -- Rough Dragon Onyx
-	8	160210	1	3600
-	9	160220	1	1200
-	10	160230	1	60
-	11	160300	1	54 -- Rough Dragon Onyx
-	12	160310	1	180
-	13	160320	1	60
-	14	160330	1	3
-	15	160400	1	54 -- Rough Dragon Onyx
-	16	160410	1	180
-	17	160420	1	60
-	18	160430	1	3
-	19	160440	1	3
-	20	161000	1	1944 -- Cut Dragon Onyx
-	21	161010	1	6480
-	22	161020	1	2160
-	23	161030	1	108
-	24	161100	1	6480 -- Cut Dragon Onyx
-	25	161110	1	21600
-	26	161120	1	7200
-	27	161130	1	360
-	28	161200	1	2160 -- Cut Dragon Onyx
-	29	161210	1	7200
-	30	161220	1	2400
-	31	161230	1	120
-	32	161300	1	108 -- Cut Dragon Onyx
-	33	161310	1	360
-	34	161320	1	120
-	35	161330	1	6
-	36	161340	1	6
-	37	161400	1	108 -- Cut Dragon Onyx
-	38	161410	1	360
-	39	161420	1	120
-	40	161430	1	6
-	41	161440	1	6
-	42	162000	1	324 -- Rare Dragon Onyx
-	43	162010	1	1080
-	44	162020	1	360
-	45	162030	1	18
-	46	162040	1	18
-	47	162100	1	1080 -- Rare Dragon Onyx
-	48	162110	1	3600
-	49	162120	1	1200
-	50	162130	1	60
-	51	162140	1	60
-	52	162200	1	360 -- Rare Dragon Onyx
-	53	162210	1	1200
-	54	162220	1	400
-	55	162230	1	20
-	56	162240	1	20
-	57	162300	1	18 -- Rare Dragon Onyx
-	58	162310	1	60
-	59	162320	1	20
-	60	162330	1	1
-	61	162340	1	1
-	62	162400	1	18 -- Rare Dragon Onyx
-	63	162410	1	60
-	64	162420	1	20
-	65	162430	1	1
-	66	162440	1	1
-}
-Group	강력한용혼원석_일반-고대
-{
-	Vnum	51590 -- Cor Draconis+ (Precious)
-	1	110000	1	324 -- Rough Dragon Diamond
-	2	110010	1	1080
-	3	110020	1	360
-	4	110100	1	1080 -- Rough Dragon Diamond
-	5	110110	1	3600
-	6	110120	1	1200
-	7	110200	1	360 -- Rough Dragon Diamond
-	8	110210	1	1200
-	9	110220	1	400
-	10	110230	1	20
-	11	110300	1	18 -- Rough Dragon Diamond
-	12	110310	1	60
-	13	110320	1	20
-	14	110330	1	1
-	15	110400	1	18 -- Rough Dragon Diamond
-	16	110410	1	60
-	17	110420	1	20
-	18	110430	1	1
-	19	110440	1	1
-	20	111000	1	810 -- Cut Dragon Diamond
-	21	111010	1	2700
-	22	111020	1	900
-	23	111030	1	45
-	24	111100	1	2700 -- Cut Dragon Diamond
-	25	111110	1	9000
-	26	111120	1	3000
-	27	111130	1	150
-	28	111200	1	900 -- Cut Dragon Diamond
-	29	111210	1	3000
-	30	111220	1	1000
-	31	111230	1	50
-	32	111300	1	45 -- Cut Dragon Diamond
-	33	111310	1	150
-	34	111320	1	50
-	35	111330	1	3
-	36	111340	1	3
-	37	111400	1	45 -- Cut Dragon Diamond
-	38	111410	1	150
-	39	111420	1	50
-	40	111430	1	3
-	41	111440	1	3
-	42	112000	1	1782 -- Rare Dragon Diamond
-	43	112010	1	5940
-	44	112020	1	1980
-	45	112030	1	99
-	46	112040	1	99
-	47	112100	1	5940 -- Rare Dragon Diamond
-	48	112110	1	19800
-	49	112120	1	6600
-	50	112130	1	330
-	51	112140	1	330
-	52	112200	1	1980 -- Rare Dragon Diamond
-	53	112210	1	6600
-	54	112220	1	2200
-	55	112230	1	110
-	56	112240	1	110
-	57	112300	1	99 -- Rare Dragon Diamond
-	58	112310	1	330
-	59	112320	1	110
-	60	112330	1	6
-	61	112340	1	6
-	62	112400	1	99 -- Rare Dragon Diamond
-	63	112410	1	330
-	64	112420	1	110
-	65	112430	1	6
-	66	112440	1	6
-	67	113000	1	324 -- Antique Dragon Diamond
-	68	113010	1	1080
-	69	113020	1	360
-	70	113030	1	18
-	71	113040	1	18
-	72	113100	1	1080 -- Antique Dragon Diamond
-	73	113110	1	3600
-	74	113120	1	1200
-	75	113130	1	60
-	76	113140	1	60
-	77	113200	1	360 -- Antique Dragon Diamond
-	78	113210	1	1200
-	79	113220	1	400
-	80	113230	1	20
-	81	113240	1	20
-	82	113300	1	18 -- Antique Dragon Diamond
-	83	113310	1	60
-	84	113320	1	20
-	85	113330	1	1
-	86	113340	1	1
-	87	113400	1	18 -- Antique Dragon Diamond
-	88	113410	1	60
-	89	113420	1	20
-	90	113430	1	1
-	91	113440	1	1
-	92	120000	1	324 -- Rough Dragon Ruby
-	93	120010	1	1080
-	94	120020	1	360
-	95	120100	1	1080 -- Rough Dragon Ruby
-	96	120110	1	3600
-	97	120120	1	1200
-	98	120200	1	360 -- Rough Dragon Ruby
-	99	120210	1	1200
-	100	120220	1	400
-	101	120230	1	20
-	102	120300	1	18 -- Rough Dragon Ruby
-	103	120310	1	60
-	104	120320	1	20
-	105	120330	1	1
-	106	120400	1	18 -- Rough Dragon Ruby
-	107	120410	1	60
-	108	120420	1	20
-	109	120430	1	1
-	110	120440	1	1
-	111	121000	1	810 -- Cut Dragon Ruby
-	112	121010	1	2700
-	113	121020	1	900
-	114	121030	1	45
-	115	121100	1	2700 -- Cut Dragon Ruby
-	116	121110	1	9000
-	117	121120	1	3000
-	118	121130	1	150
-	119	121200	1	900 -- Cut Dragon Ruby
-	120	121210	1	3000
-	121	121220	1	1000
-	122	121230	1	50
-	123	121300	1	45 -- Cut Dragon Ruby
-	124	121310	1	150
-	125	121320	1	50
-	126	121330	1	2
-	127	121340	1	2
-	128	121400	1	45 -- Cut Dragon Ruby
-	129	121410	1	150
-	130	121420	1	50
-	131	121430	1	2
-	132	121440	1	2
-	133	122000	1	1782 -- Rare Dragon Ruby
-	134	122010	1	5940
-	135	122020	1	1980
-	136	122030	1	99
-	137	122040	1	99
-	138	122100	1	5940 -- Rare Dragon Ruby
-	139	122110	1	19800
-	140	122120	1	6600
-	141	122130	1	330
-	142	122140	1	330
-	143	122200	1	1980 -- Rare Dragon Ruby
-	144	122210	1	6600
-	145	122220	1	2200
-	146	122230	1	110
-	147	122240	1	110
-	148	122300	1	99 -- Rare Dragon Ruby
-	149	122310	1	330
-	150	122320	1	110
-	151	122330	1	5
-	152	122340	1	5
-	153	122400	1	99 -- Rare Dragon Ruby
-	154	122410	1	330
-	155	122420	1	110
-	156	122430	1	5
-	157	122440	1	5
-	158	123000	1	324 -- Antique Dragon Ruby
-	159	123010	1	1080
-	160	123020	1	360
-	161	123030	1	18
-	162	123040	1	18
-	163	123100	1	1080 -- Antique Dragon Ruby
-	164	123110	1	3600
-	165	123120	1	1200
-	166	123130	1	60
-	167	123140	1	60
-	168	123200	1	360 -- Antique Dragon Ruby
-	169	123210	1	1200
-	170	123220	1	400
-	171	123230	1	20
-	172	123240	1	20
-	173	123300	1	18 -- Antique Dragon Ruby
-	174	123310	1	60
-	175	123320	1	20
-	176	123330	1	1
-	177	123340	1	1
-	178	123400	1	18 -- Antique Dragon Ruby
-	179	123410	1	60
-	180	123420	1	20
-	181	123430	1	1
-	182	123440	1	1
-	183	130000	1	324 -- Rough Dragon Jade
-	184	130010	1	1080
-	185	130020	1	360
-	186	130100	1	1080 -- Rough Dragon Jade
-	187	130110	1	3600
-	188	130120	1	1200
-	189	130200	1	360 -- Rough Dragon Jade
-	190	130210	1	1200
-	191	130220	1	400
-	192	130230	1	20
-	193	130300	1	18 -- Rough Dragon Jade
-	194	130310	1	60
-	195	130320	1	20
-	196	130330	1	1
-	197	130400	1	18 -- Rough Dragon Jade
-	198	130410	1	60
-	199	130420	1	20
-	200	130430	1	1
-	201	130440	1	1
-	202	131000	1	810 -- Cut Dragon Jade
-	203	131010	1	2700
-	204	131020	1	900
-	205	131030	1	45
-	206	131100	1	2700 -- Cut Dragon Jade
-	207	131110	1	9000
-	208	131120	1	3000
-	209	131130	1	150
-	210	131200	1	900 -- Cut Dragon Jade
-	211	131210	1	3000
-	212	131220	1	1000
-	213	131230	1	50
-	214	131300	1	45 -- Cut Dragon Jade
-	215	131310	1	150
-	216	131320	1	50
-	217	131330	1	2
-	218	131340	1	2
-	219	131400	1	45 -- Cut Dragon Jade
-	220	131410	1	150
-	221	131420	1	50
-	222	131430	1	2
-	223	131440	1	2
-	224	132000	1	1782 -- Rare Dragon Jade
-	225	132010	1	5940
-	226	132020	1	1980
-	227	132030	1	99
-	228	132040	1	99
-	229	132100	1	5940 -- Rare Dragon Jade
-	230	132110	1	19800
-	231	132120	1	6600
-	232	132130	1	330
-	233	132140	1	330
-	234	132200	1	1980 -- Rare Dragon Jade
-	235	132210	1	6600
-	236	132220	1	2200
-	237	132230	1	110
-	238	132240	1	110
-	239	132300	1	99 -- Rare Dragon Jade
-	240	132310	1	330
-	241	132320	1	110
-	242	132330	1	5
-	243	132340	1	5
-	244	132400	1	99 -- Rare Dragon Jade
-	245	132410	1	330
-	246	132420	1	110
-	247	132430	1	5
-	248	132440	1	5
-	249	133000	1	324 -- Antique Dragon Jade
-	250	133010	1	1080
-	251	133020	1	360
-	252	133030	1	18
-	253	133040	1	18
-	254	133100	1	1080 -- Antique Dragon Jade
-	255	133110	1	3600
-	256	133120	1	1200
-	257	133130	1	60
-	258	133140	1	60
-	259	133200	1	360 -- Antique Dragon Jade
-	260	133210	1	1200
-	261	133220	1	400
-	262	133230	1	20
-	263	133240	1	20
-	264	133300	1	18 -- Antique Dragon Jade
-	265	133310	1	60
-	266	133320	1	20
-	267	133330	1	1
-	268	133340	1	1
-	269	133400	1	18 -- Antique Dragon Jade
-	270	133410	1	60
-	271	133420	1	20
-	272	133430	1	1
-	273	133440	1	1
-	274	140000	1	324 -- Rough Dragon Sapphire
-	275	140010	1	1080
-	276	140020	1	360
-	277	140100	1	1080 -- Rough Dragon Sapphire
-	278	140110	1	3600
-	279	140120	1	1200
-	280	140200	1	360 -- Rough Dragon Sapphire
-	281	140210	1	1200
-	282	140220	1	400
-	283	140230	1	20
-	284	140300	1	18 -- Rough Dragon Sapphire
-	285	140310	1	60
-	286	140320	1	20
-	287	140330	1	1
-	288	140400	1	18 -- Rough Dragon Sapphire
-	289	140410	1	60
-	290	140420	1	20
-	291	140430	1	1
-	292	140440	1	1
-	293	141000	1	810 -- Cut Dragon Sapphire
-	294	141010	1	2700
-	295	141020	1	900
-	296	141030	1	45
-	297	141100	1	2700 -- Cut Dragon Sapphire
-	298	141110	1	9000
-	299	141120	1	3000
-	300	141130	1	150
-	301	141200	1	900 -- Cut Dragon Sapphire
-	302	141210	1	3000
-	303	141220	1	1000
-	304	141230	1	50
-	305	141300	1	45 -- Cut Dragon Sapphire
-	306	141310	1	150
-	307	141320	1	50
-	308	141330	1	2
-	309	141340	1	2
-	310	141400	1	45 -- Cut Dragon Sapphire
-	311	141410	1	150
-	312	141420	1	50
-	313	141430	1	2
-	314	141440	1	2
-	315	142000	1	1782 -- Rare Dragon Sapphire
-	316	142010	1	5940
-	317	142020	1	1980
-	318	142030	1	99
-	319	142040	1	99
-	320	142100	1	5940 -- Rare Dragon Sapphire
-	321	142110	1	19800
-	322	142120	1	6600
-	323	142130	1	330
-	324	142140	1	330
-	325	142200	1	1980 -- Rare Dragon Sapphire
-	326	142210	1	6600
-	327	142220	1	2200
-	328	142230	1	110
-	329	142240	1	110
-	330	142300	1	99 -- Rare Dragon Sapphire
-	331	142310	1	330
-	332	142320	1	110
-	333	142330	1	5
-	334	142340	1	5
-	335	142400	1	99 -- Rare Dragon Sapphire
-	336	142410	1	330
-	337	142420	1	110
-	338	142430	1	5
-	339	142440	1	5
-	340	143000	1	324 -- Antique Dragon Sapphire
-	341	143010	1	1080
-	342	143020	1	360
-	343	143030	1	18
-	344	143040	1	18
-	345	143100	1	1080 -- Antique Dragon Sapphire
-	346	143110	1	3600
-	347	143120	1	1200
-	348	143130	1	60
-	349	143140	1	60
-	350	143200	1	360 -- Antique Dragon Sapphire
-	351	143210	1	1200
-	352	143220	1	400
-	353	143230	1	20
-	354	143240	1	20
-	355	143300	1	18 -- Antique Dragon Sapphire
-	356	143310	1	60
-	357	143320	1	20
-	358	143330	1	1
-	359	143340	1	1
-	360	143400	1	18 -- Antique Dragon Sapphire
-	361	143410	1	60
-	362	143420	1	20
-	363	143430	1	1
-	364	143440	1	1
-	365	150000	1	324 -- Rough Dragon Garnet
-	366	150010	1	1080
-	367	150020	1	360
-	368	150100	1	1080 -- Rough Dragon Garnet
-	369	150110	1	3600
-	370	150120	1	1200
-	371	150200	1	360 -- Rough Dragon Garnet
-	372	150210	1	1200
-	373	150220	1	400
-	374	150230	1	20
-	375	150300	1	18 -- Rough Dragon Garnet
-	376	150310	1	60
-	377	150320	1	20
-	378	150330	1	1
-	379	150400	1	18 -- Rough Dragon Garnet
-	380	150410	1	60
-	381	150420	1	20
-	382	150430	1	1
-	383	150440	1	1
-	384	151000	1	810 -- Cut Dragon Garnet
-	385	151010	1	2700
-	386	151020	1	900
-	387	151030	1	45
-	388	151100	1	2700 -- Cut Dragon Garnet
-	389	151110	1	9000
-	390	151120	1	3000
-	391	151130	1	150
-	392	151200	1	900 -- Cut Dragon Garnet
-	393	151210	1	3000
-	394	151220	1	1000
-	395	151230	1	50
-	396	151300	1	45 -- Cut Dragon Garnet
-	397	151310	1	150
-	398	151320	1	50
-	399	151330	1	2
-	400	151340	1	2
-	401	151400	1	45 -- Cut Dragon Garnet
-	402	151410	1	150
-	403	151420	1	50
-	404	151430	1	2
-	405	151440	1	2
-	406	152000	1	1782 -- Rare Dragon Garnet
-	407	152010	1	5940
-	408	152020	1	1980
-	409	152030	1	99
-	410	152040	1	99
-	411	152100	1	5940 -- Rare Dragon Garnet
-	412	152110	1	19800
-	413	152120	1	6600
-	414	152130	1	330
-	415	152140	1	330
-	416	152200	1	1980 -- Rare Dragon Garnet
-	417	152210	1	6600
-	418	152220	1	2200
-	419	152230	1	110
-	420	152240	1	110
-	421	152300	1	99 -- Rare Dragon Garnet
-	422	152310	1	330
-	423	152320	1	110
-	424	152330	1	5
-	425	152340	1	5
-	426	152400	1	99 -- Rare Dragon Garnet
-	427	152410	1	330
-	428	152420	1	110
-	429	152430	1	5
-	430	152440	1	5
-	431	153000	1	324 -- Antique Dragon Garnet
-	432	153010	1	1080
-	433	153020	1	360
-	434	153030	1	18
-	435	153040	1	18
-	436	153100	1	1080 -- Antique Dragon Garnet
-	437	153110	1	3600
-	438	153120	1	1200
-	439	153130	1	60
-	440	153140	1	60
-	441	153200	1	360 -- Antique Dragon Garnet
-	442	153210	1	1200
-	443	153220	1	400
-	444	153230	1	20
-	445	153240	1	20
-	446	153300	1	18 -- Antique Dragon Garnet
-	447	153310	1	60
-	448	153320	1	20
-	449	153330	1	1
-	450	153340	1	1
-	451	153400	1	18 -- Antique Dragon Garnet
-	452	153410	1	60
-	453	153420	1	20
-	454	153430	1	1
-	455	153440	1	1
-	456	160000	1	324 -- Rough Dragon Onyx
-	457	160010	1	1080
-	458	160020	1	360
-	459	160100	1	1080 -- Rough Dragon Onyx
-	460	160110	1	3600
-	461	160120	1	1200
-	462	160200	1	360 -- Rough Dragon Onyx
-	463	160210	1	1200
-	464	160220	1	400
-	465	160230	1	20
-	466	160300	1	18 -- Rough Dragon Onyx
-	467	160310	1	60
-	468	160320	1	20
-	469	160330	1	1
-	470	160400	1	18 -- Rough Dragon Onyx
-	471	160410	1	60
-	472	160420	1	20
-	473	160430	1	1
-	474	160440	1	1
-	475	161000	1	810 -- Cut Dragon Onyx
-	476	161010	1	2700
-	477	161020	1	900
-	478	161030	1	45
-	479	161100	1	2700 -- Cut Dragon Onyx
-	480	161110	1	9000
-	481	161120	1	3000
-	482	161130	1	150
-	483	161200	1	900 -- Cut Dragon Onyx
-	484	161210	1	3000
-	485	161220	1	1000
-	486	161230	1	50
-	487	161300	1	45 -- Cut Dragon Onyx
-	488	161310	1	150
-	489	161320	1	50
-	490	161330	1	2
-	491	161340	1	2
-	492	161400	1	45 -- Cut Dragon Onyx
-	493	161410	1	150
-	494	161420	1	50
-	495	161430	1	2
-	496	161440	1	2
-	497	162000	1	1782 -- Rare Dragon Onyx
-	498	162010	1	5940
-	499	162020	1	1980
-	500	162030	1	99
-	501	162040	1	99
-	502	162100	1	5940 -- Rare Dragon Onyx
-	503	162110	1	19800
-	504	162120	1	6600
-	505	162130	1	330
-	506	162140	1	330
-	507	162200	1	1980 -- Rare Dragon Onyx
-	508	162210	1	6600
-	509	162220	1	2200
-	510	162230	1	110
-	511	162240	1	110
-	512	162300	1	99 -- Rare Dragon Onyx
-	513	162310	1	330
-	514	162320	1	110
-	515	162330	1	5
-	516	162340	1	5
-	517	162400	1	99 -- Rare Dragon Onyx
-	518	162410	1	330
-	519	162420	1	110
-	520	162430	1	5
-	521	162440	1	5
-	522	163000	1	324 -- Antique Dragon Onyx
-	523	163010	1	1080
-	524	163020	1	360
-	525	163030	1	18
-	526	163040	1	18
-	527	163100	1	1080 -- Antique Dragon Onyx
-	528	163110	1	3600
-	529	163120	1	1200
-	530	163130	1	60
-	531	163140	1	60
-	532	163200	1	360 -- Antique Dragon Onyx
-	533	163210	1	1200
-	534	163220	1	400
-	535	163230	1	20
-	536	163240	1	20
-	537	163300	1	18 -- Antique Dragon Onyx
-	538	163310	1	60
-	539	163320	1	20
-	540	163330	1	1
-	541	163340	1	1
-	542	163400	1	18 -- Antique Dragon Onyx
-	543	163410	1	60
-	544	163420	1	20
-	545	163430	1	1
-	546	163440	1	1
-}
-Group	백룡강력한용혼원석_일반-고대
-{
-	Vnum	51591 -- Cor Diamas+ (Precious)
-	1	110000	1	324 -- Rough Dragon Diamond
-	2	110010	1	1080
-	3	110020	1	360
-	4	110100	1	1080 -- Rough Dragon Diamond
-	5	110110	1	3600
-	6	110120	1	1200
-	7	110200	1	360 -- Rough Dragon Diamond
-	8	110210	1	1200
-	9	110220	1	400
-	10	110230	1	20
-	11	110300	1	18 -- Rough Dragon Diamond
-	12	110310	1	60
-	13	110320	1	20
-	14	110330	1	1
-	15	110400	1	18 -- Rough Dragon Diamond
-	16	110410	1	60
-	17	110420	1	20
-	18	110430	1	1
-	19	110440	1	1
-	20	111000	1	810 -- Cut Dragon Diamond
-	21	111010	1	2700
-	22	111020	1	900
-	23	111030	1	45
-	24	111100	1	2700 -- Cut Dragon Diamond
-	25	111110	1	9000
-	26	111120	1	3000
-	27	111130	1	150
-	28	111200	1	900 -- Cut Dragon Diamond
-	29	111210	1	3000
-	30	111220	1	1000
-	31	111230	1	50
-	32	111300	1	45 -- Cut Dragon Diamond
-	33	111310	1	150
-	34	111320	1	50
-	35	111330	1	3
-	36	111340	1	3
-	37	111400	1	45 -- Cut Dragon Diamond
-	38	111410	1	150
-	39	111420	1	50
-	40	111430	1	3
-	41	111440	1	3
-	42	112000	1	1782 -- Rare Dragon Diamond
-	43	112010	1	5940
-	44	112020	1	1980
-	45	112030	1	99
-	46	112040	1	99
-	47	112100	1	5940 -- Rare Dragon Diamond
-	48	112110	1	19800
-	49	112120	1	6600
-	50	112130	1	330
-	51	112140	1	330
-	52	112200	1	1980 -- Rare Dragon Diamond
-	53	112210	1	6600
-	54	112220	1	2200
-	55	112230	1	110
-	56	112240	1	110
-	57	112300	1	99 -- Rare Dragon Diamond
-	58	112310	1	330
-	59	112320	1	110
-	60	112330	1	6
-	61	112340	1	6
-	62	112400	1	99 -- Rare Dragon Diamond
-	63	112410	1	330
-	64	112420	1	110
-	65	112430	1	6
-	66	112440	1	6
-	67	113000	1	324 -- Antique Dragon Diamond
-	68	113010	1	1080
-	69	113020	1	360
-	70	113030	1	18
-	71	113040	1	18
-	72	113100	1	1080 -- Antique Dragon Diamond
-	73	113110	1	3600
-	74	113120	1	1200
-	75	113130	1	60
-	76	113140	1	60
-	77	113200	1	360 -- Antique Dragon Diamond
-	78	113210	1	1200
-	79	113220	1	400
-	80	113230	1	20
-	81	113240	1	20
-	82	113300	1	18 -- Antique Dragon Diamond
-	83	113310	1	60
-	84	113320	1	20
-	85	113330	1	1
-	86	113340	1	1
-	87	113400	1	18 -- Antique Dragon Diamond
-	88	113410	1	60
-	89	113420	1	20
-	90	113430	1	1
-	91	113440	1	1
-}
-Group	화룡강력한용혼원석_일반-고대
-{
-	Vnum	51592 -- Cor Rubinum+ (Precious)
-	1	120000	1	324 -- Rough Dragon Ruby
-	2	120010	1	1080
-	3	120020	1	360
-	4	120100	1	1080 -- Rough Dragon Ruby
-	5	120110	1	3600
-	6	120120	1	1200
-	7	120200	1	360 -- Rough Dragon Ruby
-	8	120210	1	1200
-	9	120220	1	400
-	10	120230	1	20
-	11	120300	1	18 -- Rough Dragon Ruby
-	12	120310	1	60
-	13	120320	1	20
-	14	120330	1	1
-	15	120400	1	18 -- Rough Dragon Ruby
-	16	120410	1	60
-	17	120420	1	20
-	18	120430	1	1
-	19	120440	1	1
-	20	121000	1	810 -- Cut Dragon Ruby
-	21	121010	1	2700
-	22	121020	1	900
-	23	121030	1	45
-	24	121100	1	2700 -- Cut Dragon Ruby
-	25	121110	1	9000
-	26	121120	1	3000
-	27	121130	1	150
-	28	121200	1	900 -- Cut Dragon Ruby
-	29	121210	1	3000
-	30	121220	1	1000
-	31	121230	1	50
-	32	121300	1	45 -- Cut Dragon Ruby
-	33	121310	1	150
-	34	121320	1	50
-	35	121330	1	3
-	36	121340	1	3
-	37	121400	1	45 -- Cut Dragon Ruby
-	38	121410	1	150
-	39	121420	1	50
-	40	121430	1	3
-	41	121440	1	3
-	42	122000	1	1782 -- Rare Dragon Ruby
-	43	122010	1	5940
-	44	122020	1	1980
-	45	122030	1	99
-	46	122040	1	99
-	47	122100	1	5940 -- Rare Dragon Ruby
-	48	122110	1	19800
-	49	122120	1	6600
-	50	122130	1	330
-	51	122140	1	330
-	52	122200	1	1980 -- Rare Dragon Ruby
-	53	122210	1	6600
-	54	122220	1	2200
-	55	122230	1	110
-	56	122240	1	110
-	57	122300	1	99 -- Rare Dragon Ruby
-	58	122310	1	330
-	59	122320	1	110
-	60	122330	1	6
-	61	122340	1	6
-	62	122400	1	99 -- Rare Dragon Ruby
-	63	122410	1	330
-	64	122420	1	110
-	65	122430	1	6
-	66	122440	1	6
-	67	123000	1	324 -- Antique Dragon Ruby
-	68	123010	1	1080
-	69	123020	1	360
-	70	123030	1	18
-	71	123040	1	18
-	72	123100	1	1080 -- Antique Dragon Ruby
-	73	123110	1	3600
-	74	123120	1	1200
-	75	123130	1	60
-	76	123140	1	60
-	77	123200	1	360 -- Antique Dragon Ruby
-	78	123210	1	1200
-	79	123220	1	400
-	80	123230	1	20
-	81	123240	1	20
-	82	123300	1	18 -- Antique Dragon Ruby
-	83	123310	1	60
-	84	123320	1	20
-	85	123330	1	1
-	86	123340	1	1
-	87	123400	1	18 -- Antique Dragon Ruby
-	88	123410	1	60
-	89	123420	1	20
-	90	123430	1	1
-	91	123440	1	1
-}
-Group	풍룡강력한용혼원석_일반-고대
-{
-	Vnum	51593 -- Cor Jadeit+ (Precious)
-	1	130000	1	324 -- Rough Dragon Jade
-	2	130010	1	1080
-	3	130020	1	360
-	4	130100	1	1080 -- Rough Dragon Jade
-	5	130110	1	3600
-	6	130120	1	1200
-	7	130200	1	360 -- Rough Dragon Jade
-	8	130210	1	1200
-	9	130220	1	400
-	10	130230	1	20
-	11	130300	1	18 -- Rough Dragon Jade
-	12	130310	1	60
-	13	130320	1	20
-	14	130330	1	1
-	15	130400	1	18 -- Rough Dragon Jade
-	16	130410	1	60
-	17	130420	1	20
-	18	130430	1	1
-	19	130440	1	1
-	20	131000	1	810 -- Cut Dragon Jade
-	21	131010	1	2700
-	22	131020	1	900
-	23	131030	1	45
-	24	131100	1	2700 -- Cut Dragon Jade
-	25	131110	1	9000
-	26	131120	1	3000
-	27	131130	1	150
-	28	131200	1	900 -- Cut Dragon Jade
-	29	131210	1	3000
-	30	131220	1	1000
-	31	131230	1	50
-	32	131300	1	45 -- Cut Dragon Jade
-	33	131310	1	150
-	34	131320	1	50
-	35	131330	1	3
-	36	131340	1	3
-	37	131400	1	45 -- Cut Dragon Jade
-	38	131410	1	150
-	39	131420	1	50
-	40	131430	1	3
-	41	131440	1	3
-	42	132000	1	1782 -- Rare Dragon Jade
-	43	132010	1	5940
-	44	132020	1	1980
-	45	132030	1	99
-	46	132040	1	99
-	47	132100	1	5940 -- Rare Dragon Jade
-	48	132110	1	19800
-	49	132120	1	6600
-	50	132130	1	330
-	51	132140	1	330
-	52	132200	1	1980 -- Rare Dragon Jade
-	53	132210	1	6600
-	54	132220	1	2200
-	55	132230	1	110
-	56	132240	1	110
-	57	132300	1	99 -- Rare Dragon Jade
-	58	132310	1	330
-	59	132320	1	110
-	60	132330	1	6
-	61	132340	1	6
-	62	132400	1	99 -- Rare Dragon Jade
-	63	132410	1	330
-	64	132420	1	110
-	65	132430	1	6
-	66	132440	1	6
-	67	133000	1	324 -- Antique Dragon Jade
-	68	133010	1	1080
-	69	133020	1	360
-	70	133030	1	18
-	71	133040	1	18
-	72	133100	1	1080 -- Antique Dragon Jade
-	73	133110	1	3600
-	74	133120	1	1200
-	75	133130	1	60
-	76	133140	1	60
-	77	133200	1	360 -- Antique Dragon Jade
-	78	133210	1	1200
-	79	133220	1	400
-	80	133230	1	20
-	81	133240	1	20
-	82	133300	1	18 -- Antique Dragon Jade
-	83	133310	1	60
-	84	133320	1	20
-	85	133330	1	1
-	86	133340	1	1
-	87	133400	1	18 -- Antique Dragon Jade
-	88	133410	1	60
-	89	133420	1	20
-	90	133430	1	1
-	91	133440	1	1
-}
-Group	철룡강력한용혼원석_일반-고대
-{
-	Vnum	51594 -- Cor Saphirum+ (Precious)
-	1	140000	1	324 -- Rough Dragon Sapphire
-	2	140010	1	1080
-	3	140020	1	360
-	4	140100	1	1080 -- Rough Dragon Sapphire
-	5	140110	1	3600
-	6	140120	1	1200
-	7	140200	1	360 -- Rough Dragon Sapphire
-	8	140210	1	1200
-	9	140220	1	400
-	10	140230	1	20
-	11	140300	1	18 -- Rough Dragon Sapphire
-	12	140310	1	60
-	13	140320	1	20
-	14	140330	1	1
-	15	140400	1	18 -- Rough Dragon Sapphire
-	16	140410	1	60
-	17	140420	1	20
-	18	140430	1	1
-	19	140440	1	1
-	20	141000	1	810 -- Cut Dragon Sapphire
-	21	141010	1	2700
-	22	141020	1	900
-	23	141030	1	45
-	24	141100	1	2700 -- Cut Dragon Sapphire
-	25	141110	1	9000
-	26	141120	1	3000
-	27	141130	1	150
-	28	141200	1	900 -- Cut Dragon Sapphire
-	29	141210	1	3000
-	30	141220	1	1000
-	31	141230	1	50
-	32	141300	1	45 -- Cut Dragon Sapphire
-	33	141310	1	150
-	34	141320	1	50
-	35	141330	1	3
-	36	141340	1	3
-	37	141400	1	45 -- Cut Dragon Sapphire
-	38	141410	1	150
-	39	141420	1	50
-	40	141430	1	3
-	41	141440	1	3
-	42	142000	1	1782 -- Rare Dragon Sapphire
-	43	142010	1	5940
-	44	142020	1	1980
-	45	142030	1	99
-	46	142040	1	99
-	47	142100	1	5940 -- Rare Dragon Sapphire
-	48	142110	1	19800
-	49	142120	1	6600
-	50	142130	1	330
-	51	142140	1	330
-	52	142200	1	1980 -- Rare Dragon Sapphire
-	53	142210	1	6600
-	54	142220	1	2200
-	55	142230	1	110
-	56	142240	1	110
-	57	142300	1	99 -- Rare Dragon Sapphire
-	58	142310	1	330
-	59	142320	1	110
-	60	142330	1	6
-	61	142340	1	6
-	62	142400	1	99 -- Rare Dragon Sapphire
-	63	142410	1	330
-	64	142420	1	110
-	65	142430	1	6
-	66	142440	1	6
-	67	143000	1	324 -- Antique Dragon Sapphire
-	68	143010	1	1080
-	69	143020	1	360
-	70	143030	1	18
-	71	143040	1	18
-	72	143100	1	1080 -- Antique Dragon Sapphire
-	73	143110	1	3600
-	74	143120	1	1200
-	75	143130	1	60
-	76	143140	1	60
-	77	143200	1	360 -- Antique Dragon Sapphire
-	78	143210	1	1200
-	79	143220	1	400
-	80	143230	1	20
-	81	143240	1	20
-	82	143300	1	18 -- Antique Dragon Sapphire
-	83	143310	1	60
-	84	143320	1	20
-	85	143330	1	1
-	86	143340	1	1
-	87	143400	1	18 -- Antique Dragon Sapphire
-	88	143410	1	60
-	89	143420	1	20
-	90	143430	1	1
-	91	143440	1	1
-}
-Group	뇌룡강력한용혼원석_일반-고대
-{
-	Vnum	51595 -- Cor Granatum+ (Precious)
-	1	150000	1	324 -- Rough Dragon Garnet
-	2	150010	1	1080
-	3	150020	1	360
-	4	150100	1	1080 -- Rough Dragon Garnet
-	5	150110	1	3600
-	6	150120	1	1200
-	7	150200	1	360 -- Rough Dragon Garnet
-	8	150210	1	1200
-	9	150220	1	400
-	10	150230	1	20
-	11	150300	1	18 -- Rough Dragon Garnet
-	12	150310	1	60
-	13	150320	1	20
-	14	150330	1	1
-	15	150400	1	18 -- Rough Dragon Garnet
-	16	150410	1	60
-	17	150420	1	20
-	18	150430	1	1
-	19	150440	1	1
-	20	151000	1	810 -- Cut Dragon Garnet
-	21	151010	1	2700
-	22	151020	1	900
-	23	151030	1	45
-	24	151100	1	2700 -- Cut Dragon Garnet
-	25	151110	1	9000
-	26	151120	1	3000
-	27	151130	1	150
-	28	151200	1	900 -- Cut Dragon Garnet
-	29	151210	1	3000
-	30	151220	1	1000
-	31	151230	1	50
-	32	151300	1	45 -- Cut Dragon Garnet
-	33	151310	1	150
-	34	151320	1	50
-	35	151330	1	3
-	36	151340	1	3
-	37	151400	1	45 -- Cut Dragon Garnet
-	38	151410	1	150
-	39	151420	1	50
-	40	151430	1	3
-	41	151440	1	3
-	42	152000	1	1782 -- Rare Dragon Garnet
-	43	152010	1	5940
-	44	152020	1	1980
-	45	152030	1	99
-	46	152040	1	99
-	47	152100	1	5940 -- Rare Dragon Garnet
-	48	152110	1	19800
-	49	152120	1	6600
-	50	152130	1	330
-	51	152140	1	330
-	52	152200	1	1980 -- Rare Dragon Garnet
-	53	152210	1	6600
-	54	152220	1	2200
-	55	152230	1	110
-	56	152240	1	110
-	57	152300	1	99 -- Rare Dragon Garnet
-	58	152310	1	330
-	59	152320	1	110
-	60	152330	1	6
-	61	152340	1	6
-	62	152400	1	99 -- Rare Dragon Garnet
-	63	152410	1	330
-	64	152420	1	110
-	65	152430	1	6
-	66	152440	1	6
-	67	153000	1	324 -- Antique Dragon Garnet
-	68	153010	1	1080
-	69	153020	1	360
-	70	153030	1	18
-	71	153040	1	18
-	72	153100	1	1080 -- Antique Dragon Garnet
-	73	153110	1	3600
-	74	153120	1	1200
-	75	153130	1	60
-	76	153140	1	60
-	77	153200	1	360 -- Antique Dragon Garnet
-	78	153210	1	1200
-	79	153220	1	400
-	80	153230	1	20
-	81	153240	1	20
-	82	153300	1	18 -- Antique Dragon Garnet
-	83	153310	1	60
-	84	153320	1	20
-	85	153330	1	1
-	86	153340	1	1
-	87	153400	1	18 -- Antique Dragon Garnet
-	88	153410	1	60
-	89	153420	1	20
-	90	153430	1	1
-	91	153440	1	1
-}
-Group	흑룡강력한용혼원석_일반-고대
-{
-	Vnum	51596 -- Cor Atrum+ (Precious)
-	1	160000	1	324 -- Rough Dragon Onyx
-	2	160010	1	1080
-	3	160020	1	360
-	4	160100	1	1080 -- Rough Dragon Onyx
-	5	160110	1	3600
-	6	160120	1	1200
-	7	160200	1	360 -- Rough Dragon Onyx
-	8	160210	1	1200
-	9	160220	1	400
-	10	160230	1	20
-	11	160300	1	18 -- Rough Dragon Onyx
-	12	160310	1	60
-	13	160320	1	20
-	14	160330	1	1
-	15	160400	1	18 -- Rough Dragon Onyx
-	16	160410	1	60
-	17	160420	1	20
-	18	160430	1	1
-	19	160440	1	1
-	20	161000	1	810 -- Cut Dragon Onyx
-	21	161010	1	2700
-	22	161020	1	900
-	23	161030	1	45
-	24	161100	1	2700 -- Cut Dragon Onyx
-	25	161110	1	9000
-	26	161120	1	3000
-	27	161130	1	150
-	28	161200	1	900 -- Cut Dragon Onyx
-	29	161210	1	3000
-	30	161220	1	1000
-	31	161230	1	50
-	32	161300	1	45 -- Cut Dragon Onyx
-	33	161310	1	150
-	34	161320	1	50
-	35	161330	1	3
-	36	161340	1	3
-	37	161400	1	45 -- Cut Dragon Onyx
-	38	161410	1	150
-	39	161420	1	50
-	40	161430	1	3
-	41	161440	1	3
-	42	162000	1	1782 -- Rare Dragon Onyx
-	43	162010	1	5940
-	44	162020	1	1980
-	45	162030	1	99
-	46	162040	1	99
-	47	162100	1	5940 -- Rare Dragon Onyx
-	48	162110	1	19800
-	49	162120	1	6600
-	50	162130	1	330
-	51	162140	1	330
-	52	162200	1	1980 -- Rare Dragon Onyx
-	53	162210	1	6600
-	54	162220	1	2200
-	55	162230	1	110
-	56	162240	1	110
-	57	162300	1	99 -- Rare Dragon Onyx
-	58	162310	1	330
-	59	162320	1	110
-	60	162330	1	6
-	61	162340	1	6
-	62	162400	1	99 -- Rare Dragon Onyx
-	63	162410	1	330
-	64	162420	1	110
-	65	162430	1	6
-	66	162440	1	6
-	67	163000	1	324 -- Antique Dragon Onyx
-	68	163010	1	1080
-	69	163020	1	360
-	70	163030	1	18
-	71	163040	1	18
-	72	163100	1	1080 -- Antique Dragon Onyx
-	73	163110	1	3600
-	74	163120	1	1200
-	75	163130	1	60
-	76	163140	1	60
-	77	163200	1	360 -- Antique Dragon Onyx
-	78	163210	1	1200
-	79	163220	1	400
-	80	163230	1	20
-	81	163240	1	20
-	82	163300	1	18 -- Antique Dragon Onyx
-	83	163310	1	60
-	84	163320	1	20
-	85	163330	1	1
-	86	163340	1	1
-	87	163400	1	18 -- Antique Dragon Onyx
-	88	163410	1	60
-	89	163420	1	20
-	90	163430	1	1
-	91	163440	1	1
-}
-Group	강력한용혼원석_일반-전설
-{
-	Vnum	51597 -- Cor Draconis+ (Flawless)
-	1	110000	1	324 -- Rough Dragon Diamond
-	2	110010	1	1080
-	3	110020	1	360
-	4	110100	1	1080 -- Rough Dragon Diamond
-	5	110110	1	3600
-	6	110120	1	1200
-	7	110200	1	360 -- Rough Dragon Diamond
-	8	110210	1	1200
-	9	110220	1	400
-	10	110230	1	20
-	11	110300	1	18 -- Rough Dragon Diamond
-	12	110310	1	60
-	13	110320	1	20
-	14	110330	1	1
-	15	110400	1	18 -- Rough Dragon Diamond
-	16	110410	1	60
-	17	110420	1	20
-	18	110430	1	1
-	19	110440	1	1
-	20	111000	1	648 -- Cut Dragon Diamond
-	21	111010	1	2160
-	22	111020	1	720
-	23	111030	1	36
-	24	111100	1	2160 -- Cut Dragon Diamond
-	25	111110	1	7200
-	26	111120	1	2400
-	27	111130	1	120
-	28	111200	1	720 -- Cut Dragon Diamond
-	29	111210	1	2400
-	30	111220	1	800
-	31	111230	1	40
-	32	111300	1	36 -- Cut Dragon Diamond
-	33	111310	1	120
-	34	111320	1	40
-	35	111330	1	2
-	36	111340	1	2
-	37	111400	1	36 -- Cut Dragon Diamond
-	38	111410	1	120
-	39	111420	1	40
-	40	111430	1	2
-	41	111440	1	2
-	42	112000	1	972 -- Rare Dragon Diamond
-	43	112010	1	3240
-	44	112020	1	1080
-	45	112030	1	54
-	46	112040	1	54
-	47	112100	1	3240 -- Rare Dragon Diamond
-	48	112110	1	10800
-	49	112120	1	3600
-	50	112130	1	180
-	51	112140	1	180
-	52	112200	1	1080 -- Rare Dragon Diamond
-	53	112210	1	3600
-	54	112220	1	1200
-	55	112230	1	60
-	56	112240	1	60
-	57	112300	1	54 -- Rare Dragon Diamond
-	58	112310	1	180
-	59	112320	1	60
-	60	112330	1	3
-	61	112340	1	3
-	62	112400	1	54 -- Rare Dragon Diamond
-	63	112410	1	180
-	64	112420	1	60
-	65	112430	1	3
-	66	112440	1	3
-	67	113000	1	3888 -- Antique Dragon Diamond
-	68	113010	1	12960
-	69	113020	1	4320
-	70	113030	1	216
-	71	113040	1	216
-	72	113100	1	12960 -- Antique Dragon Diamond
-	73	113110	1	43200
-	74	113120	1	14400
-	75	113130	1	720
-	76	113140	1	720
-	77	113200	1	4320 -- Antique Dragon Diamond
-	78	113210	1	14400
-	79	113220	1	4800
-	80	113230	1	240
-	81	113240	1	240
-	82	113300	1	216 -- Antique Dragon Diamond
-	83	113310	1	720
-	84	113320	1	240
-	85	113330	1	12
-	86	113340	1	12
-	87	113400	1	216 -- Antique Dragon Diamond
-	88	113410	1	720
-	89	113420	1	240
-	90	113430	1	12
-	91	113440	1	12
-	92	114000	1	648 -- Legendary Dragon Diamond
-	93	114010	1	2160
-	94	114020	1	720
-	95	114030	1	36
-	96	114040	1	36
-	97	114100	1	2160 -- Legendary Dragon Diamond
-	98	114110	1	7200
-	99	114120	1	2400
-	100	114130	1	120
-	101	114140	1	120
-	102	114200	1	720 -- Legendary Dragon Diamond
-	103	114210	1	2400
-	104	114220	1	800
-	105	114230	1	40
-	106	114240	1	40
-	107	114300	1	36 -- Legendary Dragon Diamond
-	108	114310	1	120
-	109	114320	1	40
-	110	114330	1	2
-	111	114340	1	2
-	112	114400	1	36 -- Legendary Dragon Diamond
-	113	114410	1	120
-	114	114420	1	40
-	115	114430	1	2
-	116	114440	1	2
-	117	120000	1	324 -- Rough Dragon Ruby
-	118	120010	1	1080
-	119	120020	1	360
-	120	120100	1	1080 -- Rough Dragon Ruby
-	121	120110	1	3600
-	122	120120	1	1200
-	123	120200	1	360 -- Rough Dragon Ruby
-	124	120210	1	1200
-	125	120220	1	400
-	126	120230	1	20
-	127	120300	1	18 -- Rough Dragon Ruby
-	128	120310	1	60
-	129	120320	1	20
-	130	120330	1	1
-	131	120400	1	18 -- Rough Dragon Ruby
-	132	120410	1	60
-	133	120420	1	20
-	134	120430	1	1
-	135	120440	1	1
-	136	121000	1	648 -- Cut Dragon Ruby
-	137	121010	1	2160
-	138	121020	1	720
-	139	121030	1	36
-	140	121100	1	2160 -- Cut Dragon Ruby
-	141	121110	1	7200
-	142	121120	1	2400
-	143	121130	1	120
-	144	121200	1	720 -- Cut Dragon Ruby
-	145	121210	1	2400
-	146	121220	1	800
-	147	121230	1	40
-	148	121300	1	36 -- Cut Dragon Ruby
-	149	121310	1	120
-	150	121320	1	40
-	151	121330	1	2
-	152	121340	1	2
-	153	121400	1	36 -- Cut Dragon Ruby
-	154	121410	1	120
-	155	121420	1	40
-	156	121430	1	2
-	157	121440	1	2
-	158	122000	1	972 -- Rare Dragon Ruby
-	159	122010	1	3240
-	160	122020	1	1080
-	161	122030	1	54
-	162	122040	1	54
-	163	122100	1	3240 -- Rare Dragon Ruby
-	164	122110	1	10800
-	165	122120	1	3600
-	166	122130	1	180
-	167	122140	1	180
-	168	122200	1	1080 -- Rare Dragon Ruby
-	169	122210	1	3600
-	170	122220	1	1200
-	171	122230	1	60
-	172	122240	1	60
-	173	122300	1	54 -- Rare Dragon Ruby
-	174	122310	1	180
-	175	122320	1	60
-	176	122330	1	3
-	177	122340	1	3
-	178	122400	1	54 -- Rare Dragon Ruby
-	179	122410	1	180
-	180	122420	1	60
-	181	122430	1	3
-	182	122440	1	3
-	183	123000	1	3888 -- Antique Dragon Ruby
-	184	123010	1	12960
-	185	123020	1	4320
-	186	123030	1	216
-	187	123040	1	216
-	188	123100	1	12960 -- Antique Dragon Ruby
-	189	123110	1	43200
-	190	123120	1	14400
-	191	123130	1	720
-	192	123140	1	720
-	193	123200	1	4320 -- Antique Dragon Ruby
-	194	123210	1	14400
-	195	123220	1	4800
-	196	123230	1	240
-	197	123240	1	240
-	198	123300	1	216 -- Antique Dragon Ruby
-	199	123310	1	720
-	200	123320	1	240
-	201	123330	1	12
-	202	123340	1	12
-	203	123400	1	216 -- Antique Dragon Ruby
-	204	123410	1	720
-	205	123420	1	240
-	206	123430	1	12
-	207	123440	1	12
-	208	124000	1	648 -- Legendary Dragon Ruby
-	209	124010	1	2160
-	210	124020	1	720
-	211	124030	1	36
-	212	124040	1	36
-	213	124100	1	2160 -- Legendary Dragon Ruby
-	214	124110	1	7200
-	215	124120	1	2400
-	216	124130	1	120
-	217	124140	1	120
-	218	124200	1	720 -- Legendary Dragon Ruby
-	219	124210	1	2400
-	220	124220	1	800
-	221	124230	1	40
-	222	124240	1	40
-	223	124300	1	36 -- Legendary Dragon Ruby
-	224	124310	1	120
-	225	124320	1	40
-	226	124330	1	2
-	227	124340	1	2
-	228	124400	1	36 -- Legendary Dragon Ruby
-	229	124410	1	120
-	230	124420	1	40
-	231	124430	1	2
-	232	124440	1	2
-	233	130000	1	324 -- Rough Dragon Jade
-	234	130010	1	1080
-	235	130020	1	360
-	236	130100	1	1080 -- Rough Dragon Jade
-	237	130110	1	3600
-	238	130120	1	1200
-	239	130200	1	360 -- Rough Dragon Jade
-	240	130210	1	1200
-	241	130220	1	400
-	242	130230	1	20
-	243	130300	1	18 -- Rough Dragon Jade
-	244	130310	1	60
-	245	130320	1	20
-	246	130330	1	1
-	247	130400	1	18 -- Rough Dragon Jade
-	248	130410	1	60
-	249	130420	1	20
-	250	130430	1	1
-	251	130440	1	1
-	252	131000	1	648 -- Cut Dragon Jade
-	253	131010	1	2160
-	254	131020	1	720
-	255	131030	1	36
-	256	131100	1	2160 -- Cut Dragon Jade
-	257	131110	1	7200
-	258	131120	1	2400
-	259	131130	1	120
-	260	131200	1	720 -- Cut Dragon Jade
-	261	131210	1	2400
-	262	131220	1	800
-	263	131230	1	40
-	264	131300	1	36 -- Cut Dragon Jade
-	265	131310	1	120
-	266	131320	1	40
-	267	131330	1	2
-	268	131340	1	2
-	269	131400	1	36 -- Cut Dragon Jade
-	270	131410	1	120
-	271	131420	1	40
-	272	131430	1	2
-	273	131440	1	2
-	274	132000	1	972 -- Rare Dragon Jade
-	275	132010	1	3240
-	276	132020	1	1080
-	277	132030	1	54
-	278	132040	1	54
-	279	132100	1	3240 -- Rare Dragon Jade
-	280	132110	1	10800
-	281	132120	1	3600
-	282	132130	1	180
-	283	132140	1	180
-	284	132200	1	1080 -- Rare Dragon Jade
-	285	132210	1	3600
-	286	132220	1	1200
-	287	132230	1	60
-	288	132240	1	60
-	289	132300	1	54 -- Rare Dragon Jade
-	290	132310	1	180
-	291	132320	1	60
-	292	132330	1	3
-	293	132340	1	3
-	294	132400	1	54 -- Rare Dragon Jade
-	295	132410	1	180
-	296	132420	1	60
-	297	132430	1	3
-	298	132440	1	3
-	299	133000	1	3888 -- Antique Dragon Jade
-	300	133010	1	12960
-	301	133020	1	4320
-	302	133030	1	216
-	303	133040	1	216
-	304	133100	1	12960 -- Antique Dragon Jade
-	305	133110	1	43200
-	306	133120	1	14400
-	307	133130	1	720
-	308	133140	1	720
-	309	133200	1	4320 -- Antique Dragon Jade
-	310	133210	1	14400
-	311	133220	1	4800
-	312	133230	1	240
-	313	133240	1	240
-	314	133300	1	216 -- Antique Dragon Jade
-	315	133310	1	720
-	316	133320	1	240
-	317	133330	1	12
-	318	133340	1	12
-	319	133400	1	216 -- Antique Dragon Jade
-	320	133410	1	720
-	321	133420	1	240
-	322	133430	1	12
-	323	133440	1	12
-	324	134000	1	648 -- Legendary Dragon Jade
-	325	134010	1	2160
-	326	134020	1	720
-	327	134030	1	36
-	328	134040	1	36
-	329	134100	1	2160 -- Legendary Dragon Jade
-	330	134110	1	7200
-	331	134120	1	2400
-	332	134130	1	120
-	333	134140	1	120
-	334	134200	1	720 -- Legendary Dragon Jade
-	335	134210	1	2400
-	336	134220	1	800
-	337	134230	1	40
-	338	134240	1	40
-	339	134300	1	36 -- Legendary Dragon Jade
-	340	134310	1	120
-	341	134320	1	40
-	342	134330	1	2
-	343	134340	1	2
-	344	134400	1	36 -- Legendary Dragon Jade
-	345	134410	1	120
-	346	134420	1	40
-	347	134430	1	2
-	348	134440	1	2
-	349	140000	1	324 -- Rough Dragon Sapphire
-	350	140010	1	1080
-	351	140020	1	360
-	352	140100	1	1080 -- Rough Dragon Sapphire
-	353	140110	1	3600
-	354	140120	1	1200
-	355	140200	1	360 -- Rough Dragon Sapphire
-	356	140210	1	1200
-	357	140220	1	400
-	358	140230	1	20
-	359	140300	1	18 -- Rough Dragon Sapphire
-	360	140310	1	60
-	361	140320	1	20
-	362	140330	1	1
-	363	140400	1	18 -- Rough Dragon Sapphire
-	364	140410	1	60
-	365	140420	1	20
-	366	140430	1	1
-	367	140440	1	1
-	368	141000	1	648 -- Cut Dragon Sapphire
-	369	141010	1	2160
-	370	141020	1	720
-	371	141030	1	36
-	372	141100	1	2160 -- Cut Dragon Sapphire
-	373	141110	1	7200
-	374	141120	1	2400
-	375	141130	1	120
-	376	141200	1	720 -- Cut Dragon Sapphire
-	377	141210	1	2400
-	378	141220	1	800
-	379	141230	1	40
-	380	141300	1	36 -- Cut Dragon Sapphire
-	381	141310	1	120
-	382	141320	1	40
-	383	141330	1	2
-	384	141340	1	2
-	385	141400	1	36 -- Cut Dragon Sapphire
-	386	141410	1	120
-	387	141420	1	40
-	388	141430	1	2
-	389	141440	1	2
-	390	142000	1	972 -- Rare Dragon Sapphire
-	391	142010	1	3240
-	392	142020	1	1080
-	393	142030	1	54
-	394	142040	1	54
-	395	142100	1	3240 -- Rare Dragon Sapphire
-	396	142110	1	10800
-	397	142120	1	3600
-	398	142130	1	180
-	399	142140	1	180
-	400	142200	1	1080 -- Rare Dragon Sapphire
-	401	142210	1	3600
-	402	142220	1	1200
-	403	142230	1	60
-	404	142240	1	60
-	405	142300	1	54 -- Rare Dragon Sapphire
-	406	142310	1	180
-	407	142320	1	60
-	408	142330	1	3
-	409	142340	1	3
-	410	142400	1	54 -- Rare Dragon Sapphire
-	411	142410	1	180
-	412	142420	1	60
-	413	142430	1	3
-	414	142440	1	3
-	415	143000	1	3888 -- Antique Dragon Sapphire
-	416	143010	1	12960
-	417	143020	1	4320
-	418	143030	1	216
-	419	143040	1	216
-	420	143100	1	12960 -- Antique Dragon Sapphire
-	421	143110	1	43200
-	422	143120	1	14400
-	423	143130	1	720
-	424	143140	1	720
-	425	143200	1	4320 -- Antique Dragon Sapphire
-	426	143210	1	14400
-	427	143220	1	4800
-	428	143230	1	240
-	429	143240	1	240
-	430	143300	1	216 -- Antique Dragon Sapphire
-	431	143310	1	720
-	432	143320	1	240
-	433	143330	1	12
-	434	143340	1	12
-	435	143400	1	216 -- Antique Dragon Sapphire
-	436	143410	1	720
-	437	143420	1	240
-	438	143430	1	12
-	439	143440	1	12
-	440	144000	1	648 -- Legendary DragonSapphire
-	441	144010	1	2160
-	442	144020	1	720
-	443	144030	1	36
-	444	144040	1	36
-	445	144100	1	2160 -- Legendary DragonSapphire
-	446	144110	1	7200
-	447	144120	1	2400
-	448	144130	1	120
-	449	144140	1	120
-	450	144200	1	720 -- Legendary DragonSapphire
-	451	144210	1	2400
-	452	144220	1	800
-	453	144230	1	40
-	454	144240	1	40
-	455	144300	1	36 -- Legendary DragonSapphire
-	456	144310	1	120
-	457	144320	1	40
-	458	144330	1	2
-	459	144340	1	2
-	460	144400	1	36 -- Legendary DragonSapphire
-	461	144410	1	120
-	462	144420	1	40
-	463	144430	1	2
-	464	144440	1	2
-	465	150000	1	324 -- Rough Dragon Garnet
-	466	150010	1	1080
-	467	150020	1	360
-	468	150100	1	1080 -- Rough Dragon Garnet
-	469	150110	1	3600
-	470	150120	1	1200
-	471	150200	1	360 -- Rough Dragon Garnet
-	472	150210	1	1200
-	473	150220	1	400
-	474	150230	1	20
-	475	150300	1	18 -- Rough Dragon Garnet
-	476	150310	1	60
-	477	150320	1	20
-	478	150330	1	1
-	479	150400	1	18 -- Rough Dragon Garnet
-	480	150410	1	60
-	481	150420	1	20
-	482	150430	1	1
-	483	150440	1	1
-	484	151000	1	648 -- Cut Dragon Garnet
-	485	151010	1	2160
-	486	151020	1	720
-	487	151030	1	36
-	488	151100	1	2160 -- Cut Dragon Garnet
-	489	151110	1	7200
-	490	151120	1	2400
-	491	151130	1	120
-	492	151200	1	720 -- Cut Dragon Garnet
-	493	151210	1	2400
-	494	151220	1	800
-	495	151230	1	40
-	496	151300	1	36 -- Cut Dragon Garnet
-	497	151310	1	120
-	498	151320	1	40
-	499	151330	1	2
-	500	151340	1	2
-	501	151400	1	36 -- Cut Dragon Garnet
-	502	151410	1	120
-	503	151420	1	40
-	504	151430	1	2
-	505	151440	1	2
-	506	152000	1	972 -- Rare Dragon Garnet
-	507	152010	1	3240
-	508	152020	1	1080
-	509	152030	1	54
-	510	152040	1	54
-	511	152100	1	3240 -- Rare Dragon Garnet
-	512	152110	1	10800
-	513	152120	1	3600
-	514	152130	1	180
-	515	152140	1	180
-	516	152200	1	1080 -- Rare Dragon Garnet
-	517	152210	1	3600
-	518	152220	1	1200
-	519	152230	1	60
-	520	152240	1	60
-	521	152300	1	54 -- Rare Dragon Garnet
-	522	152310	1	180
-	523	152320	1	60
-	524	152330	1	3
-	525	152340	1	3
-	526	152400	1	54 -- Rare Dragon Garnet
-	527	152410	1	180
-	528	152420	1	60
-	529	152430	1	3
-	530	152440	1	3
-	531	153000	1	3888 -- Antique Dragon Garnet
-	532	153010	1	12960
-	533	153020	1	4320
-	534	153030	1	216
-	535	153040	1	216
-	536	153100	1	12960 -- Antique Dragon Garnet
-	537	153110	1	43200
-	538	153120	1	14400
-	539	153130	1	720
-	540	153140	1	720
-	541	153200	1	4320 -- Antique Dragon Garnet
-	542	153210	1	14400
-	543	153220	1	4800
-	544	153230	1	240
-	545	153240	1	240
-	546	153300	1	216 -- Antique Dragon Garnet
-	547	153310	1	720
-	548	153320	1	240
-	549	153330	1	12
-	550	153340	1	12
-	551	153400	1	216 -- Antique Dragon Garnet
-	552	153410	1	720
-	553	153420	1	240
-	554	153430	1	12
-	555	153440	1	12
-	556	154000	1	648 -- Legendary Dragon Garnet
-	557	154010	1	2160
-	558	154020	1	720
-	559	154030	1	36
-	560	154040	1	36
-	561	154100	1	2160 -- Legendary Dragon Garnet
-	562	154110	1	7200
-	563	154120	1	2400
-	564	154130	1	120
-	565	154140	1	120
-	566	154200	1	720 -- Legendary Dragon Garnet
-	567	154210	1	2400
-	568	154220	1	800
-	569	154230	1	40
-	570	154240	1	40
-	571	154300	1	36 -- Legendary Dragon Garnet
-	572	154310	1	120
-	573	154320	1	40
-	574	154330	1	2
-	575	154340	1	2
-	576	154400	1	36 -- Legendary Dragon Garnet
-	577	154410	1	120
-	578	154420	1	40
-	579	154430	1	2
-	580	154440	1	2
-	581	160000	1	324 -- Rough Dragon Onyx
-	582	160010	1	1080
-	583	160020	1	360
-	584	160100	1	1080 -- Rough Dragon Onyx
-	585	160110	1	3600
-	586	160120	1	1200
-	587	160200	1	360 -- Rough Dragon Onyx
-	588	160210	1	1200
-	589	160220	1	400
-	590	160230	1	20
-	591	160300	1	18 -- Rough Dragon Onyx
-	592	160310	1	60
-	593	160320	1	20
-	594	160330	1	1
-	595	160400	1	18 -- Rough Dragon Onyx
-	596	160410	1	60
-	597	160420	1	20
-	598	160430	1	1
-	599	160440	1	1
-	600	161000	1	648 -- Cut Dragon Onyx
-	601	161010	1	2160
-	602	161020	1	720
-	603	161030	1	36
-	604	161100	1	2160 -- Cut Dragon Onyx
-	605	161110	1	7200
-	606	161120	1	2400
-	607	161130	1	120
-	608	161200	1	720 -- Cut Dragon Onyx
-	609	161210	1	2400
-	610	161220	1	800
-	611	161230	1	40
-	612	161300	1	36 -- Cut Dragon Onyx
-	613	161310	1	120
-	614	161320	1	40
-	615	161330	1	2
-	616	161340	1	2
-	617	161400	1	36 -- Cut Dragon Onyx
-	618	161410	1	120
-	619	161420	1	40
-	620	161430	1	2
-	621	161440	1	2
-	622	162000	1	972 -- Rare Dragon Onyx
-	623	162010	1	3240
-	624	162020	1	1080
-	625	162030	1	54
-	626	162040	1	54
-	627	162100	1	3240 -- Rare Dragon Onyx
-	628	162110	1	10800
-	629	162120	1	3600
-	630	162130	1	180
-	631	162140	1	180
-	632	162200	1	1080 -- Rare Dragon Onyx
-	633	162210	1	3600
-	634	162220	1	1200
-	635	162230	1	60
-	636	162240	1	60
-	637	162300	1	54 -- Rare Dragon Onyx
-	638	162310	1	180
-	639	162320	1	60
-	640	162330	1	3
-	641	162340	1	3
-	642	162400	1	54 -- Rare Dragon Onyx
-	643	162410	1	180
-	644	162420	1	60
-	645	162430	1	3
-	646	162440	1	3
-	647	163000	1	3888 -- Antique Dragon Onyx
-	648	163010	1	12960
-	649	163020	1	4320
-	650	163030	1	216
-	651	163040	1	216
-	652	163100	1	12960 -- Antique Dragon Onyx
-	653	163110	1	43200
-	654	163120	1	14400
-	655	163130	1	720
-	656	163140	1	720
-	657	163200	1	4320 -- Antique Dragon Onyx
-	658	163210	1	14400
-	659	163220	1	4800
-	660	163230	1	240
-	661	163240	1	240
-	662	163300	1	216 -- Antique Dragon Onyx
-	663	163310	1	720
-	664	163320	1	240
-	665	163330	1	12
-	666	163340	1	12
-	667	163400	1	216 -- Antique Dragon Onyx
-	668	163410	1	720
-	669	163420	1	240
-	670	163430	1	12
-	671	163440	1	12
-	672	164000	1	648 -- Legendary Dragon Onyx
-	673	164010	1	2160
-	674	164020	1	720
-	675	164030	1	36
-	676	164040	1	36
-	677	164100	1	2160 -- Legendary Dragon Onyx
-	678	164110	1	7200
-	679	164120	1	2400
-	680	164130	1	120
-	681	164140	1	120
-	682	164200	1	720 -- Legendary Dragon Onyx
-	683	164210	1	2400
-	684	164220	1	800
-	685	164230	1	40
-	686	164240	1	40
-	687	164300	1	36 -- Legendary Dragon Onyx
-	688	164310	1	120
-	689	164320	1	40
-	690	164330	1	2
-	691	164340	1	2
-	692	164400	1	36 -- Legendary Dragon Onyx
-	693	164410	1	120
-	694	164420	1	40
-	695	164430	1	2
-	696	164440	1	2
-}
-Group	백룡강력한용혼원석_일반-전설
-{
-	Vnum	51598 -- Cor Diamas+ (Flawless)
-	1	110000	1	324 -- Rough Dragon Diamond
-	2	110010	1	1080
-	3	110020	1	360
-	4	110100	1	1080 -- Rough Dragon Diamond
-	5	110110	1	3600
-	6	110120	1	1200
-	7	110200	1	360 -- Rough Dragon Diamond
-	8	110210	1	1200
-	9	110220	1	400
-	10	110230	1	20
-	11	110300	1	18 -- Rough Dragon Diamond
-	12	110310	1	60
-	13	110320	1	20
-	14	110330	1	1
-	15	110400	1	18 -- Rough Dragon Diamond
-	16	110410	1	60
-	17	110420	1	20
-	18	110430	1	1
-	19	110440	1	1
-	20	111000	1	648 -- Cut Dragon Diamond
-	21	111010	1	2160
-	22	111020	1	720
-	23	111030	1	36
-	24	111100	1	2160 -- Cut Dragon Diamond
-	25	111110	1	7200
-	26	111120	1	2400
-	27	111130	1	120
-	28	111200	1	720 -- Cut Dragon Diamond
-	29	111210	1	2400
-	30	111220	1	800
-	31	111230	1	40
-	32	111300	1	36 -- Cut Dragon Diamond
-	33	111310	1	120
-	34	111320	1	40
-	35	111330	1	2
-	36	111340	1	2
-	37	111400	1	36 -- Cut Dragon Diamond
-	38	111410	1	120
-	39	111420	1	40
-	40	111430	1	2
-	41	111440	1	2
-	42	112000	1	972 -- Rare Dragon Diamond
-	43	112010	1	3240
-	44	112020	1	1080
-	45	112030	1	54
-	46	112040	1	54
-	47	112100	1	3240 -- Rare Dragon Diamond
-	48	112110	1	10800
-	49	112120	1	3600
-	50	112130	1	180
-	51	112140	1	180
-	52	112200	1	1080 -- Rare Dragon Diamond
-	53	112210	1	3600
-	54	112220	1	1200
-	55	112230	1	60
-	56	112240	1	60
-	57	112300	1	54 -- Rare Dragon Diamond
-	58	112310	1	180
-	59	112320	1	60
-	60	112330	1	3
-	61	112340	1	3
-	62	112400	1	54 -- Rare Dragon Diamond
-	63	112410	1	180
-	64	112420	1	60
-	65	112430	1	3
-	66	112440	1	3
-	67	113000	1	3888 -- Antique Dragon Diamond
-	68	113010	1	12960
-	69	113020	1	4320
-	70	113030	1	216
-	71	113040	1	216
-	72	113100	1	12960 -- Antique Dragon Diamond
-	73	113110	1	43200
-	74	113120	1	14400
-	75	113130	1	720
-	76	113140	1	720
-	77	113200	1	4320 -- Antique Dragon Diamond
-	78	113210	1	14400
-	79	113220	1	4800
-	80	113230	1	240
-	81	113240	1	240
-	82	113300	1	216 -- Antique Dragon Diamond
-	83	113310	1	720
-	84	113320	1	240
-	85	113330	1	12
-	86	113340	1	12
-	87	113400	1	216 -- Antique Dragon Diamond
-	88	113410	1	720
-	89	113420	1	240
-	90	113430	1	12
-	91	113440	1	12
-	92	114000	1	648 -- Legendary Dragon Diamond
-	93	114010	1	2160
-	94	114020	1	720
-	95	114030	1	36
-	96	114040	1	36
-	97	114100	1	2160 -- Legendary Dragon Diamond
-	98	114110	1	7200
-	99	114120	1	2400
-	100	114130	1	120
-	101	114140	1	120
-	102	114200	1	720 -- Legendary Dragon Diamond
-	103	114210	1	2400
-	104	114220	1	800
-	105	114230	1	40
-	106	114240	1	40
-	107	114300	1	36 -- Legendary Dragon Diamond
-	108	114310	1	120
-	109	114320	1	40
-	110	114330	1	2
-	111	114340	1	2
-	112	114400	1	36 -- Legendary Dragon Diamond
-	113	114410	1	120
-	114	114420	1	40
-	115	114430	1	2
-	116	114440	1	2
-}
-Group	화룡강력한용혼원석_일반-전설
-{
-	Vnum	51599 -- Cor Rubinum+ (Flawless)
-	1	120000	1	324 -- Rough Dragon Ruby
-	2	120010	1	1080
-	3	120020	1	360
-	4	120100	1	1080 -- Rough Dragon Ruby
-	5	120110	1	3600
-	6	120120	1	1200
-	7	120200	1	360 -- Rough Dragon Ruby
-	8	120210	1	1200
-	9	120220	1	400
-	10	120230	1	20
-	11	120300	1	18 -- Rough Dragon Ruby
-	12	120310	1	60
-	13	120320	1	20
-	14	120330	1	1
-	15	120400	1	18 -- Rough Dragon Ruby
-	16	120410	1	60
-	17	120420	1	20
-	18	120430	1	1
-	19	120440	1	1
-	20	121000	1	648 -- Cut Dragon Ruby
-	21	121010	1	2160
-	22	121020	1	720
-	23	121030	1	36
-	24	121100	1	2160 -- Cut Dragon Ruby
-	25	121110	1	7200
-	26	121120	1	2400
-	27	121130	1	120
-	28	121200	1	720 -- Cut Dragon Ruby
-	29	121210	1	2400
-	30	121220	1	800
-	31	121230	1	40
-	32	121300	1	36 -- Cut Dragon Ruby
-	33	121310	1	120
-	34	121320	1	40
-	35	121330	1	2
-	36	121340	1	2
-	37	121400	1	36 -- Cut Dragon Ruby
-	38	121410	1	120
-	39	121420	1	40
-	40	121430	1	2
-	41	121440	1	2
-	42	122000	1	972 -- Rare Dragon Ruby
-	43	122010	1	3240
-	44	122020	1	1080
-	45	122030	1	54
-	46	122040	1	54
-	47	122100	1	3240 -- Rare Dragon Ruby
-	48	122110	1	10800
-	49	122120	1	3600
-	50	122130	1	180
-	51	122140	1	180
-	52	122200	1	1080 -- Rare Dragon Ruby
-	53	122210	1	3600
-	54	122220	1	1200
-	55	122230	1	60
-	56	122240	1	60
-	57	122300	1	54 -- Rare Dragon Ruby
-	58	122310	1	180
-	59	122320	1	60
-	60	122330	1	3
-	61	122340	1	3
-	62	122400	1	54 -- Rare Dragon Ruby
-	63	122410	1	180
-	64	122420	1	60
-	65	122430	1	3
-	66	122440	1	3
-	67	123000	1	3888 -- Antique Dragon Ruby
-	68	123010	1	12960
-	69	123020	1	4320
-	70	123030	1	216
-	71	123040	1	216
-	72	123100	1	12960 -- Antique Dragon Ruby
-	73	123110	1	43200
-	74	123120	1	14400
-	75	123130	1	720
-	76	123140	1	720
-	77	123200	1	4320 -- Antique Dragon Ruby
-	78	123210	1	14400
-	79	123220	1	4800
-	80	123230	1	240
-	81	123240	1	240
-	82	123300	1	216 -- Antique Dragon Ruby
-	83	123310	1	720
-	84	123320	1	240
-	85	123330	1	12
-	86	123340	1	12
-	87	123400	1	216 -- Antique Dragon Ruby
-	88	123410	1	720
-	89	123420	1	240
-	90	123430	1	12
-	91	123440	1	12
-	92	124000	1	648 -- Legendary Dragon Ruby
-	93	124010	1	2160
-	94	124020	1	720
-	95	124030	1	36
-	96	124040	1	36
-	97	124100	1	2160 -- Legendary Dragon Ruby
-	98	124110	1	7200
-	99	124120	1	2400
-	100	124130	1	120
-	101	124140	1	120
-	102	124200	1	720 -- Legendary Dragon Ruby
-	103	124210	1	2400
-	104	124220	1	800
-	105	124230	1	40
-	106	124240	1	40
-	107	124300	1	36 -- Legendary Dragon Ruby
-	108	124310	1	120
-	109	124320	1	40
-	110	124330	1	2
-	111	124340	1	2
-	112	124400	1	36 -- Legendary Dragon Ruby
-	113	124410	1	120
-	114	124420	1	40
-	115	124430	1	2
-	116	124440	1	2
-}
-Group	풍룡강력한용혼원석_일반-전설
-{
-	Vnum	51600 -- Cor Jadeit+ (Flawless)
-	1	130000	1	324 -- Rough Dragon Jade
-	2	130010	1	1080
-	3	130020	1	360
-	4	130100	1	1080 -- Rough Dragon Jade
-	5	130110	1	3600
-	6	130120	1	1200
-	7	130200	1	360 -- Rough Dragon Jade
-	8	130210	1	1200
-	9	130220	1	400
-	10	130230	1	20
-	11	130300	1	18 -- Rough Dragon Jade
-	12	130310	1	60
-	13	130320	1	20
-	14	130330	1	1
-	15	130400	1	18 -- Rough Dragon Jade
-	16	130410	1	60
-	17	130420	1	20
-	18	130430	1	1
-	19	130440	1	1
-	20	131000	1	648 -- Cut Dragon Jade
-	21	131010	1	2160
-	22	131020	1	720
-	23	131030	1	36
-	24	131100	1	2160 -- Cut Dragon Jade
-	25	131110	1	7200
-	26	131120	1	2400
-	27	131130	1	120
-	28	131200	1	720 -- Cut Dragon Jade
-	29	131210	1	2400
-	30	131220	1	800
-	31	131230	1	40
-	32	131300	1	36 -- Cut Dragon Jade
-	33	131310	1	120
-	34	131320	1	40
-	35	131330	1	2
-	36	131340	1	2
-	37	131400	1	36 -- Cut Dragon Jade
-	38	131410	1	120
-	39	131420	1	40
-	40	131430	1	2
-	41	131440	1	2
-	42	132000	1	972 -- Rare Dragon Jade
-	43	132010	1	3240
-	44	132020	1	1080
-	45	132030	1	54
-	46	132040	1	54
-	47	132100	1	3240 -- Rare Dragon Jade
-	48	132110	1	10800
-	49	132120	1	3600
-	50	132130	1	180
-	51	132140	1	180
-	52	132200	1	1080 -- Rare Dragon Jade
-	53	132210	1	3600
-	54	132220	1	1200
-	55	132230	1	60
-	56	132240	1	60
-	57	132300	1	54 -- Rare Dragon Jade
-	58	132310	1	180
-	59	132320	1	60
-	60	132330	1	3
-	61	132340	1	3
-	62	132400	1	54 -- Rare Dragon Jade
-	63	132410	1	180
-	64	132420	1	60
-	65	132430	1	3
-	66	132440	1	3
-	67	133000	1	3888 -- Antique Dragon Jade
-	68	133010	1	12960
-	69	133020	1	4320
-	70	133030	1	216
-	71	133040	1	216
-	72	133100	1	12960 -- Antique Dragon Jade
-	73	133110	1	43200
-	74	133120	1	14400
-	75	133130	1	720
-	76	133140	1	720
-	77	133200	1	4320 -- Antique Dragon Jade
-	78	133210	1	14400
-	79	133220	1	4800
-	80	133230	1	240
-	81	133240	1	240
-	82	133300	1	216 -- Antique Dragon Jade
-	83	133310	1	720
-	84	133320	1	240
-	85	133330	1	12
-	86	133340	1	12
-	87	133400	1	216 -- Antique Dragon Jade
-	88	133410	1	720
-	89	133420	1	240
-	90	133430	1	12
-	91	133440	1	12
-	92	134000	1	648 -- Legendary Dragon Jade
-	93	134010	1	2160
-	94	134020	1	720
-	95	134030	1	36
-	96	134040	1	36
-	97	134100	1	2160 -- Legendary Dragon Jade
-	98	134110	1	7200
-	99	134120	1	2400
-	100	134130	1	120
-	101	134140	1	120
-	102	134200	1	720 -- Legendary Dragon Jade
-	103	134210	1	2400
-	104	134220	1	800
-	105	134230	1	40
-	106	134240	1	40
-	107	134300	1	36 -- Legendary Dragon Jade
-	108	134310	1	120
-	109	134320	1	40
-	110	134330	1	2
-	111	134340	1	2
-	112	134400	1	36 -- Legendary Dragon Jade
-	113	134410	1	120
-	114	134420	1	40
-	115	134430	1	2
-	116	134440	1	2
-}
-Group	철룡강력한용혼원석_일반-전설
-{
-	Vnum	51601 -- Cor Saphirum+ (Flawless)
-	1	140000	1	324 -- Rough Dragon Sapphire
-	2	140010	1	1080
-	3	140020	1	360
-	4	140100	1	1080 -- Rough Dragon Sapphire
-	5	140110	1	3600
-	6	140120	1	1200
-	7	140200	1	360 -- Rough Dragon Sapphire
-	8	140210	1	1200
-	9	140220	1	400
-	10	140230	1	20
-	11	140300	1	18 -- Rough Dragon Sapphire
-	12	140310	1	60
-	13	140320	1	20
-	14	140330	1	1
-	15	140400	1	18 -- Rough Dragon Sapphire
-	16	140410	1	60
-	17	140420	1	20
-	18	140430	1	1
-	19	140440	1	1
-	20	141000	1	648 -- Cut Dragon Sapphire
-	21	141010	1	2160
-	22	141020	1	720
-	23	141030	1	36
-	24	141100	1	2160 -- Cut Dragon Sapphire
-	25	141110	1	7200
-	26	141120	1	2400
-	27	141130	1	120
-	28	141200	1	720 -- Cut Dragon Sapphire
-	29	141210	1	2400
-	30	141220	1	800
-	31	141230	1	40
-	32	141300	1	36 -- Cut Dragon Sapphire
-	33	141310	1	120
-	34	141320	1	40
-	35	141330	1	2
-	36	141340	1	2
-	37	141400	1	36 -- Cut Dragon Sapphire
-	38	141410	1	120
-	39	141420	1	40
-	40	141430	1	2
-	41	141440	1	2
-	42	142000	1	972 -- Rare Dragon Sapphire
-	43	142010	1	3240
-	44	142020	1	1080
-	45	142030	1	54
-	46	142040	1	54
-	47	142100	1	3240 -- Rare Dragon Sapphire
-	48	142110	1	10800
-	49	142120	1	3600
-	50	142130	1	180
-	51	142140	1	180
-	52	142200	1	1080 -- Rare Dragon Sapphire
-	53	142210	1	3600
-	54	142220	1	1200
-	55	142230	1	60
-	56	142240	1	60
-	57	142300	1	54 -- Rare Dragon Sapphire
-	58	142310	1	180
-	59	142320	1	60
-	60	142330	1	3
-	61	142340	1	3
-	62	142400	1	54 -- Rare Dragon Sapphire
-	63	142410	1	180
-	64	142420	1	60
-	65	142430	1	3
-	66	142440	1	3
-	67	143000	1	3888 -- Antique Dragon Sapphire
-	68	143010	1	12960
-	69	143020	1	4320
-	70	143030	1	216
-	71	143040	1	216
-	72	143100	1	12960 -- Antique Dragon Sapphire
-	73	143110	1	43200
-	74	143120	1	14400
-	75	143130	1	720
-	76	143140	1	720
-	77	143200	1	4320 -- Antique Dragon Sapphire
-	78	143210	1	14400
-	79	143220	1	4800
-	80	143230	1	240
-	81	143240	1	240
-	82	143300	1	216 -- Antique Dragon Sapphire
-	83	143310	1	720
-	84	143320	1	240
-	85	143330	1	12
-	86	143340	1	12
-	87	143400	1	216 -- Antique Dragon Sapphire
-	88	143410	1	720
-	89	143420	1	240
-	90	143430	1	12
-	91	143440	1	12
-	92	144000	1	648 -- Legendary DragonSapphire
-	93	144010	1	2160
-	94	144020	1	720
-	95	144030	1	36
-	96	144040	1	36
-	97	144100	1	2160 -- Legendary DragonSapphire
-	98	144110	1	7200
-	99	144120	1	2400
-	100	144130	1	120
-	101	144140	1	120
-	102	144200	1	720 -- Legendary DragonSapphire
-	103	144210	1	2400
-	104	144220	1	800
-	105	144230	1	40
-	106	144240	1	40
-	107	144300	1	36 -- Legendary DragonSapphire
-	108	144310	1	120
-	109	144320	1	40
-	110	144330	1	2
-	111	144340	1	2
-	112	144400	1	36 -- Legendary DragonSapphire
-	113	144410	1	120
-	114	144420	1	40
-	115	144430	1	2
-	116	144440	1	2
-}
-Group	뇌룡강력한용혼원석_일반-전설
-{
-	Vnum	51602 -- Cor Granatum+ (Flawless)
-	1	150000	1	324 -- Rough Dragon Garnet
-	2	150010	1	1080
-	3	150020	1	360
-	4	150100	1	1080 -- Rough Dragon Garnet
-	5	150110	1	3600
-	6	150120	1	1200
-	7	150200	1	360 -- Rough Dragon Garnet
-	8	150210	1	1200
-	9	150220	1	400
-	10	150230	1	20
-	11	150300	1	18 -- Rough Dragon Garnet
-	12	150310	1	60
-	13	150320	1	20
-	14	150330	1	1
-	15	150400	1	18 -- Rough Dragon Garnet
-	16	150410	1	60
-	17	150420	1	20
-	18	150430	1	1
-	19	150440	1	1
-	20	151000	1	648 -- Cut Dragon Garnet
-	21	151010	1	2160
-	22	151020	1	720
-	23	151030	1	36
-	24	151100	1	2160 -- Cut Dragon Garnet
-	25	151110	1	7200
-	26	151120	1	2400
-	27	151130	1	120
-	28	151200	1	720 -- Cut Dragon Garnet
-	29	151210	1	2400
-	30	151220	1	800
-	31	151230	1	40
-	32	151300	1	36 -- Cut Dragon Garnet
-	33	151310	1	120
-	34	151320	1	40
-	35	151330	1	2
-	36	151340	1	2
-	37	151400	1	36 -- Cut Dragon Garnet
-	38	151410	1	120
-	39	151420	1	40
-	40	151430	1	2
-	41	151440	1	2
-	42	152000	1	972 -- Rare Dragon Garnet
-	43	152010	1	3240
-	44	152020	1	1080
-	45	152030	1	54
-	46	152040	1	54
-	47	152100	1	3240 -- Rare Dragon Garnet
-	48	152110	1	10800
-	49	152120	1	3600
-	50	152130	1	180
-	51	152140	1	180
-	52	152200	1	1080 -- Rare Dragon Garnet
-	53	152210	1	3600
-	54	152220	1	1200
-	55	152230	1	60
-	56	152240	1	60
-	57	152300	1	54 -- Rare Dragon Garnet
-	58	152310	1	180
-	59	152320	1	60
-	60	152330	1	3
-	61	152340	1	3
-	62	152400	1	54 -- Rare Dragon Garnet
-	63	152410	1	180
-	64	152420	1	60
-	65	152430	1	3
-	66	152440	1	3
-	67	153000	1	3888 -- Antique Dragon Garnet
-	68	153010	1	12960
-	69	153020	1	4320
-	70	153030	1	216
-	71	153040	1	216
-	72	153100	1	12960 -- Antique Dragon Garnet
-	73	153110	1	43200
-	74	153120	1	14400
-	75	153130	1	720
-	76	153140	1	720
-	77	153200	1	4320 -- Antique Dragon Garnet
-	78	153210	1	14400
-	79	153220	1	4800
-	80	153230	1	240
-	81	153240	1	240
-	82	153300	1	216 -- Antique Dragon Garnet
-	83	153310	1	720
-	84	153320	1	240
-	85	153330	1	12
-	86	153340	1	12
-	87	153400	1	216 -- Antique Dragon Garnet
-	88	153410	1	720
-	89	153420	1	240
-	90	153430	1	12
-	91	153440	1	12
-	92	154000	1	648 -- Legendary Dragon Garnet
-	93	154010	1	2160
-	94	154020	1	720
-	95	154030	1	36
-	96	154040	1	36
-	97	154100	1	2160 -- Legendary Dragon Garnet
-	98	154110	1	7200
-	99	154120	1	2400
-	100	154130	1	120
-	101	154140	1	120
-	102	154200	1	720 -- Legendary Dragon Garnet
-	103	154210	1	2400
-	104	154220	1	800
-	105	154230	1	40
-	106	154240	1	40
-	107	154300	1	36 -- Legendary Dragon Garnet
-	108	154310	1	120
-	109	154320	1	40
-	110	154330	1	2
-	111	154340	1	2
-	112	154400	1	36 -- Legendary Dragon Garnet
-	113	154410	1	120
-	114	154420	1	40
-	115	154430	1	2
-	116	154440	1	2
-}
-Group	흑룡강력한용혼원석_일반-전설
-{
-	Vnum	51603 -- Cor Atrum+ (Flawless)
-	1	160000	1	324 -- Rough Dragon Onyx
-	2	160010	1	1080
-	3	160020	1	360
-	4	160100	1	1080 -- Rough Dragon Onyx
-	5	160110	1	3600
-	6	160120	1	1200
-	7	160200	1	360 -- Rough Dragon Onyx
-	8	160210	1	1200
-	9	160220	1	400
-	10	160230	1	20
-	11	160300	1	18 -- Rough Dragon Onyx
-	12	160310	1	60
-	13	160320	1	20
-	14	160330	1	1
-	15	160400	1	18 -- Rough Dragon Onyx
-	16	160410	1	60
-	17	160420	1	20
-	18	160430	1	1
-	19	160440	1	1
-	20	161000	1	648 -- Cut Dragon Onyx
-	21	161010	1	2160
-	22	161020	1	720
-	23	161030	1	36
-	24	161100	1	2160 -- Cut Dragon Onyx
-	25	161110	1	7200
-	26	161120	1	2400
-	27	161130	1	120
-	28	161200	1	720 -- Cut Dragon Onyx
-	29	161210	1	2400
-	30	161220	1	800
-	31	161230	1	40
-	32	161300	1	36 -- Cut Dragon Onyx
-	33	161310	1	120
-	34	161320	1	40
-	35	161330	1	2
-	36	161340	1	2
-	37	161400	1	36 -- Cut Dragon Onyx
-	38	161410	1	120
-	39	161420	1	40
-	40	161430	1	2
-	41	161440	1	2
-	42	162000	1	972 -- Rare Dragon Onyx
-	43	162010	1	3240
-	44	162020	1	1080
-	45	162030	1	54
-	46	162040	1	54
-	47	162100	1	3240 -- Rare Dragon Onyx
-	48	162110	1	10800
-	49	162120	1	3600
-	50	162130	1	180
-	51	162140	1	180
-	52	162200	1	1080 -- Rare Dragon Onyx
-	53	162210	1	3600
-	54	162220	1	1200
-	55	162230	1	60
-	56	162240	1	60
-	57	162300	1	54 -- Rare Dragon Onyx
-	58	162310	1	180
-	59	162320	1	60
-	60	162330	1	3
-	61	162340	1	3
-	62	162400	1	54 -- Rare Dragon Onyx
-	63	162410	1	180
-	64	162420	1	60
-	65	162430	1	3
-	66	162440	1	3
-	67	163000	1	3888 -- Antique Dragon Onyx
-	68	163010	1	12960
-	69	163020	1	4320
-	70	163030	1	216
-	71	163040	1	216
-	72	163100	1	12960 -- Antique Dragon Onyx
-	73	163110	1	43200
-	74	163120	1	14400
-	75	163130	1	720
-	76	163140	1	720
-	77	163200	1	4320 -- Antique Dragon Onyx
-	78	163210	1	14400
-	79	163220	1	4800
-	80	163230	1	240
-	81	163240	1	240
-	82	163300	1	216 -- Antique Dragon Onyx
-	83	163310	1	720
-	84	163320	1	240
-	85	163330	1	12
-	86	163340	1	12
-	87	163400	1	216 -- Antique Dragon Onyx
-	88	163410	1	720
-	89	163420	1	240
-	90	163430	1	12
-	91	163440	1	12
-	92	164000	1	648 -- Legendary Dragon Onyx
-	93	164010	1	2160
-	94	164020	1	720
-	95	164030	1	36
-	96	164040	1	36
-	97	164100	1	2160 -- Legendary Dragon Onyx
-	98	164110	1	7200
-	99	164120	1	2400
-	100	164130	1	120
-	101	164140	1	120
-	102	164200	1	720 -- Legendary Dragon Onyx
-	103	164210	1	2400
-	104	164220	1	800
-	105	164230	1	40
-	106	164240	1	40
-	107	164300	1	36 -- Legendary Dragon Onyx
-	108	164310	1	120
-	109	164320	1	40
-	110	164330	1	2
-	111	164340	1	2
-	112	164400	1	36 -- Legendary Dragon Onyx
-	113	164410	1	120
-	114	164420	1	40
-	115	164430	1	2
-	116	164440	1	2
-}
-Group	강력한용혼원석_화려-희귀
-{
-	Vnum	51604 -- Cor Draconis+ (Glowing)
-	1	111000	1	756 -- Cut Dragon Diamond
-	2	111010	1	2520
-	3	111020	1	840
-	4	111030	1	42
-	5	111100	1	2520 -- Cut Dragon Diamond
-	6	111110	1	8400
-	7	111120	1	2800
-	8	111130	1	140
-	9	111200	1	840 -- Cut Dragon Diamond
-	10	111210	1	2800
-	11	111220	1	933
-	12	111230	1	47
-	13	111300	1	42 -- Cut Dragon Diamond
-	14	111310	1	140
-	15	111320	1	47
-	16	111330	1	2
-	17	111340	1	2
-	18	111400	1	42 -- Cut Dragon Diamond
-	19	111410	1	140
-	20	111420	1	47
-	21	111430	1	2
-	22	111440	1	2
-	23	112000	1	324 -- Rare Dragon Diamond
-	24	112010	1	1080
-	25	112020	1	360
-	26	112030	1	18
-	27	112040	1	18
-	28	112100	1	1080 -- Rare Dragon Diamond
-	29	112110	1	3600
-	30	112120	1	1200
-	31	112130	1	60
-	32	112140	1	60
-	33	112200	1	360 -- Rare Dragon Diamond
-	34	112210	1	1200
-	35	112220	1	400
-	36	112230	1	20
-	37	112240	1	20
-	38	112300	1	18 -- Rare Dragon Diamond
-	39	112310	1	60
-	40	112320	1	20
-	41	112330	1	1
-	42	112340	1	1
-	43	112400	1	18 -- Rare Dragon Diamond
-	44	112410	1	60
-	45	112420	1	20
-	46	112430	1	1
-	47	112440	1	1
-	48	121000	1	756 -- Cut Dragon Ruby
-	49	121010	1	2520
-	50	121020	1	840
-	51	121030	1	42
-	52	121100	1	2520 -- Cut Dragon Ruby
-	53	121110	1	8400
-	54	121120	1	2800
-	55	121130	1	140
-	56	121200	1	840 -- Cut Dragon Ruby
-	57	121210	1	2800
-	58	121220	1	933
-	59	121230	1	47
-	60	121300	1	42 -- Cut Dragon Ruby
-	61	121310	1	140
-	62	121320	1	47
-	63	121330	1	2
-	64	121340	1	2
-	65	121400	1	42 -- Cut Dragon Ruby
-	66	121410	1	140
-	67	121420	1	47
-	68	121430	1	2
-	69	121440	1	2
-	70	122000	1	324 -- Rare Dragon Ruby
-	71	122010	1	1080
-	72	122020	1	360
-	73	122030	1	18
-	74	122040	1	18
-	75	122100	1	1080 -- Rare Dragon Ruby
-	76	122110	1	3600
-	77	122120	1	1200
-	78	122130	1	60
-	79	122140	1	60
-	80	122200	1	360 -- Rare Dragon Ruby
-	81	122210	1	1200
-	82	122220	1	400
-	83	122230	1	20
-	84	122240	1	20
-	85	122300	1	18 -- Rare Dragon Ruby
-	86	122310	1	60
-	87	122320	1	20
-	88	122330	1	1
-	89	122340	1	1
-	90	122400	1	18 -- Rare Dragon Ruby
-	91	122410	1	60
-	92	122420	1	20
-	93	122430	1	1
-	94	122440	1	1
-	95	131000	1	756 -- Cut Dragon Jade
-	96	131010	1	2520
-	97	131020	1	840
-	98	131030	1	42
-	99	131100	1	2520 -- Cut Dragon Jade
-	100	131110	1	8400
-	101	131120	1	2800
-	102	131130	1	140
-	103	131200	1	840 -- Cut Dragon Jade
-	104	131210	1	2800
-	105	131220	1	933
-	106	131230	1	47
-	107	131300	1	42 -- Cut Dragon Jade
-	108	131310	1	140
-	109	131320	1	47
-	110	131330	1	2
-	111	131340	1	2
-	112	131400	1	42 -- Cut Dragon Jade
-	113	131410	1	140
-	114	131420	1	47
-	115	131430	1	2
-	116	131440	1	2
-	117	132000	1	324 -- Rare Dragon Jade
-	118	132010	1	1080
-	119	132020	1	360
-	120	132030	1	18
-	121	132040	1	18
-	122	132100	1	1080 -- Rare Dragon Jade
-	123	132110	1	3600
-	124	132120	1	1200
-	125	132130	1	60
-	126	132140	1	60
-	127	132200	1	360 -- Rare Dragon Jade
-	128	132210	1	1200
-	129	132220	1	400
-	130	132230	1	20
-	131	132240	1	20
-	132	132300	1	18 -- Rare Dragon Jade
-	133	132310	1	60
-	134	132320	1	20
-	135	132330	1	1
-	136	132340	1	1
-	137	132400	1	18 -- Rare Dragon Jade
-	138	132410	1	60
-	139	132420	1	20
-	140	132430	1	1
-	141	132440	1	1
-	142	141000	1	756 -- Cut Dragon Sapphire
-	143	141010	1	2520
-	144	141020	1	840
-	145	141030	1	42
-	146	141100	1	2520 -- Cut Dragon Sapphire
-	147	141110	1	8400
-	148	141120	1	2800
-	149	141130	1	140
-	150	141200	1	840 -- Cut Dragon Sapphire
-	151	141210	1	2800
-	152	141220	1	933
-	153	141230	1	47
-	154	141300	1	42 -- Cut Dragon Sapphire
-	155	141310	1	140
-	156	141320	1	47
-	157	141330	1	2
-	158	141340	1	2
-	159	141400	1	42 -- Cut Dragon Sapphire
-	160	141410	1	140
-	161	141420	1	47
-	162	141430	1	2
-	163	141440	1	2
-	164	142000	1	324 -- Rare Dragon Sapphire
-	165	142010	1	1080
-	166	142020	1	360
-	167	142030	1	18
-	168	142040	1	18
-	169	142100	1	1080 -- Rare Dragon Sapphire
-	170	142110	1	3600
-	171	142120	1	1200
-	172	142130	1	60
-	173	142140	1	60
-	174	142200	1	360 -- Rare Dragon Sapphire
-	175	142210	1	1200
-	176	142220	1	400
-	177	142230	1	20
-	178	142240	1	20
-	179	142300	1	18 -- Rare Dragon Sapphire
-	180	142310	1	60
-	181	142320	1	20
-	182	142330	1	1
-	183	142340	1	1
-	184	142400	1	18 -- Rare Dragon Sapphire
-	185	142410	1	60
-	186	142420	1	20
-	187	142430	1	1
-	188	142440	1	1
-	189	151000	1	756 -- Cut Dragon Garnet
-	190	151010	1	2520
-	191	151020	1	840
-	192	151030	1	42
-	193	151100	1	2520 -- Cut Dragon Garnet
-	194	151110	1	8400
-	195	151120	1	2800
-	196	151130	1	140
-	197	151200	1	840 -- Cut Dragon Garnet
-	198	151210	1	2800
-	199	151220	1	933
-	200	151230	1	47
-	201	151300	1	42 -- Cut Dragon Garnet
-	202	151310	1	140
-	203	151320	1	47
-	204	151330	1	2
-	205	151340	1	2
-	206	151400	1	42 -- Cut Dragon Garnet
-	207	151410	1	140
-	208	151420	1	47
-	209	151430	1	2
-	210	151440	1	2
-	211	152000	1	324 -- Rare Dragon Garnet
-	212	152010	1	1080
-	213	152020	1	360
-	214	152030	1	18
-	215	152040	1	18
-	216	152100	1	1080 -- Rare Dragon Garnet
-	217	152110	1	3600
-	218	152120	1	1200
-	219	152130	1	60
-	220	152140	1	60
-	221	152200	1	360 -- Rare Dragon Garnet
-	222	152210	1	1200
-	223	152220	1	400
-	224	152230	1	20
-	225	152240	1	20
-	226	152300	1	18 -- Rare Dragon Garnet
-	227	152310	1	60
-	228	152320	1	20
-	229	152330	1	1
-	230	152340	1	1
-	231	152400	1	18 -- Rare Dragon Garnet
-	232	152410	1	60
-	233	152420	1	20
-	234	152430	1	1
-	235	152440	1	1
-	236	161000	1	756 -- Cut Dragon Onyx
-	237	161010	1	2520
-	238	161020	1	840
-	239	161030	1	42
-	240	161100	1	2520 -- Cut Dragon Onyx
-	241	161110	1	8400
-	242	161120	1	2800
-	243	161130	1	140
-	244	161200	1	840 -- Cut Dragon Onyx
-	245	161210	1	2800
-	246	161220	1	933
-	247	161230	1	47
-	248	161300	1	42 -- Cut Dragon Onyx
-	249	161310	1	140
-	250	161320	1	47
-	251	161330	1	2
-	252	161340	1	2
-	253	161400	1	42 -- Cut Dragon Onyx
-	254	161410	1	140
-	255	161420	1	47
-	256	161430	1	2
-	257	161440	1	2
-	258	162000	1	324 -- Rare Dragon Onyx
-	259	162010	1	1080
-	260	162020	1	360
-	261	162030	1	18
-	262	162040	1	18
-	263	162100	1	1080 -- Rare Dragon Onyx
-	264	162110	1	3600
-	265	162120	1	1200
-	266	162130	1	60
-	267	162140	1	60
-	268	162200	1	360 -- Rare Dragon Onyx
-	269	162210	1	1200
-	270	162220	1	400
-	271	162230	1	20
-	272	162240	1	20
-	273	162300	1	18 -- Rare Dragon Onyx
-	274	162310	1	60
-	275	162320	1	20
-	276	162330	1	1
-	277	162340	1	1
-	278	162400	1	18 -- Rare Dragon Onyx
-	279	162410	1	60
-	280	162420	1	20
-	281	162430	1	1
-	282	162440	1	1
-}
-Group	백룡강력한용혼원석_화려-희귀
-{
-	Vnum	51605 -- Cor Diamas+ (Glowing)
-	1	111000	1	756 -- Cut Dragon Diamond
-	2	111010	1	2520
-	3	111020	1	840
-	4	111030	1	42
-	5	111100	1	2520 -- Cut Dragon Diamond
-	6	111110	1	8400
-	7	111120	1	2800
-	8	111130	1	140
-	9	111200	1	840 -- Cut Dragon Diamond
-	10	111210	1	2800
-	11	111220	1	933
-	12	111230	1	47
-	13	111300	1	42 -- Cut Dragon Diamond
-	14	111310	1	140
-	15	111320	1	47
-	16	111330	1	2
-	17	111340	1	2
-	18	111400	1	42 -- Cut Dragon Diamond
-	19	111410	1	140
-	20	111420	1	47
-	21	111430	1	2
-	22	111440	1	2
-	23	112000	1	324 -- Rare Dragon Diamond
-	24	112010	1	1080
-	25	112020	1	360
-	26	112030	1	18
-	27	112040	1	18
-	28	112100	1	1080 -- Rare Dragon Diamond
-	29	112110	1	3600
-	30	112120	1	1200
-	31	112130	1	60
-	32	112140	1	60
-	33	112200	1	360 -- Rare Dragon Diamond
-	34	112210	1	1200
-	35	112220	1	400
-	36	112230	1	20
-	37	112240	1	20
-	38	112300	1	18 -- Rare Dragon Diamond
-	39	112310	1	60
-	40	112320	1	20
-	41	112330	1	1
-	42	112340	1	1
-	43	112400	1	18 -- Rare Dragon Diamond
-	44	112410	1	60
-	45	112420	1	20
-	46	112430	1	1
-	47	112440	1	1
-}
-Group	화룡강력한용혼원석_화려-희귀
-{
-	Vnum	51606 -- Cor Rubinum+ (Glowing)
-	1	121000	1	756 -- Cut Dragon Ruby
-	2	121010	1	2520
-	3	121020	1	840
-	4	121030	1	42
-	5	121100	1	2520 -- Cut Dragon Ruby
-	6	121110	1	8400
-	7	121120	1	2800
-	8	121130	1	140
-	9	121200	1	840 -- Cut Dragon Ruby
-	10	121210	1	2800
-	11	121220	1	933
-	12	121230	1	47
-	13	121300	1	42 -- Cut Dragon Ruby
-	14	121310	1	140
-	15	121320	1	47
-	16	121330	1	2
-	17	121340	1	2
-	18	121400	1	42 -- Cut Dragon Ruby
-	19	121410	1	140
-	20	121420	1	47
-	21	121430	1	2
-	22	121440	1	2
-	23	122000	1	324 -- Rare Dragon Ruby
-	24	122010	1	1080
-	25	122020	1	360
-	26	122030	1	18
-	27	122040	1	18
-	28	122100	1	1080 -- Rare Dragon Ruby
-	29	122110	1	3600
-	30	122120	1	1200
-	31	122130	1	60
-	32	122140	1	60
-	33	122200	1	360 -- Rare Dragon Ruby
-	34	122210	1	1200
-	35	122220	1	400
-	36	122230	1	20
-	37	122240	1	20
-	38	122300	1	18 -- Rare Dragon Ruby
-	39	122310	1	60
-	40	122320	1	20
-	41	122330	1	1
-	42	122340	1	1
-	43	122400	1	18 -- Rare Dragon Ruby
-	44	122410	1	60
-	45	122420	1	20
-	46	122430	1	1
-	47	122440	1	1
-}
-Group	풍룡강력한용혼원석_화려-희귀
-{
-	Vnum	51607 -- Cor Jadeit+ (Glowing)
-	1	131000	1	756 -- Cut Dragon Jade
-	2	131010	1	2520
-	3	131020	1	840
-	4	131030	1	42
-	5	131100	1	2520 -- Cut Dragon Jade
-	6	131110	1	8400
-	7	131120	1	2800
-	8	131130	1	140
-	9	131200	1	840 -- Cut Dragon Jade
-	10	131210	1	2800
-	11	131220	1	933
-	12	131230	1	47
-	13	131300	1	42 -- Cut Dragon Jade
-	14	131310	1	140
-	15	131320	1	47
-	16	131330	1	2
-	17	131340	1	2
-	18	131400	1	42 -- Cut Dragon Jade
-	19	131410	1	140
-	20	131420	1	47
-	21	131430	1	2
-	22	131440	1	2
-	23	132000	1	324 -- Rare Dragon Jade
-	24	132010	1	1080
-	25	132020	1	360
-	26	132030	1	18
-	27	132040	1	18
-	28	132100	1	1080 -- Rare Dragon Jade
-	29	132110	1	3600
-	30	132120	1	1200
-	31	132130	1	60
-	32	132140	1	60
-	33	132200	1	360 -- Rare Dragon Jade
-	34	132210	1	1200
-	35	132220	1	400
-	36	132230	1	20
-	37	132240	1	20
-	38	132300	1	18 -- Rare Dragon Jade
-	39	132310	1	60
-	40	132320	1	20
-	41	132330	1	1
-	42	132340	1	1
-	43	132400	1	18 -- Rare Dragon Jade
-	44	132410	1	60
-	45	132420	1	20
-	46	132430	1	1
-	47	132440	1	1
-}
-Group	철룡강력한용혼원석_화려-희귀
-{
-	Vnum	51608 -- Cor Saphirum+ (Glowing)
-	1	141000	1	756 -- Cut Dragon Sapphire
-	2	141010	1	2520
-	3	141020	1	840
-	4	141030	1	42
-	5	141100	1	2520 -- Cut Dragon Sapphire
-	6	141110	1	8400
-	7	141120	1	2800
-	8	141130	1	140
-	9	141200	1	840 -- Cut Dragon Sapphire
-	10	141210	1	2800
-	11	141220	1	933
-	12	141230	1	47
-	13	141300	1	42 -- Cut Dragon Sapphire
-	14	141310	1	140
-	15	141320	1	47
-	16	141330	1	2
-	17	141340	1	2
-	18	141400	1	42 -- Cut Dragon Sapphire
-	19	141410	1	140
-	20	141420	1	47
-	21	141430	1	2
-	22	141440	1	2
-	23	142000	1	324 -- Rare Dragon Sapphire
-	24	142010	1	1080
-	25	142020	1	360
-	26	142030	1	18
-	27	142040	1	18
-	28	142100	1	1080 -- Rare Dragon Sapphire
-	29	142110	1	3600
-	30	142120	1	1200
-	31	142130	1	60
-	32	142140	1	60
-	33	142200	1	360 -- Rare Dragon Sapphire
-	34	142210	1	1200
-	35	142220	1	400
-	36	142230	1	20
-	37	142240	1	20
-	38	142300	1	18 -- Rare Dragon Sapphire
-	39	142310	1	60
-	40	142320	1	20
-	41	142330	1	1
-	42	142340	1	1
-	43	142400	1	18 -- Rare Dragon Sapphire
-	44	142410	1	60
-	45	142420	1	20
-	46	142430	1	1
-	47	142440	1	1
-}
-Group	뇌룡강력한용혼원석_화려-희귀
-{
-	Vnum	51609 -- Cor Granatum+ (Glowing)
-	1	151000	1	756 -- Cut Dragon Garnet
-	2	151010	1	2520
-	3	151020	1	840
-	4	151030	1	42
-	5	151100	1	2520 -- Cut Dragon Garnet
-	6	151110	1	8400
-	7	151120	1	2800
-	8	151130	1	140
-	9	151200	1	840 -- Cut Dragon Garnet
-	10	151210	1	2800
-	11	151220	1	933
-	12	151230	1	47
-	13	151300	1	42 -- Cut Dragon Garnet
-	14	151310	1	140
-	15	151320	1	47
-	16	151330	1	2
-	17	151340	1	2
-	18	151400	1	42 -- Cut Dragon Garnet
-	19	151410	1	140
-	20	151420	1	47
-	21	151430	1	2
-	22	151440	1	2
-	23	152000	1	324 -- Rare Dragon Garnet
-	24	152010	1	1080
-	25	152020	1	360
-	26	152030	1	18
-	27	152040	1	18
-	28	152100	1	1080 -- Rare Dragon Garnet
-	29	152110	1	3600
-	30	152120	1	1200
-	31	152130	1	60
-	32	152140	1	60
-	33	152200	1	360 -- Rare Dragon Garnet
-	34	152210	1	1200
-	35	152220	1	400
-	36	152230	1	20
-	37	152240	1	20
-	38	152300	1	18 -- Rare Dragon Garnet
-	39	152310	1	60
-	40	152320	1	20
-	41	152330	1	1
-	42	152340	1	1
-	43	152400	1	18 -- Rare Dragon Garnet
-	44	152410	1	60
-	45	152420	1	20
-	46	152430	1	1
-	47	152440	1	1
-}
-Group	흑룡강력한용혼원석_화려-희귀
-{
-	Vnum	51610 -- Cor Atrum+ (Glowing)
-	1	161000	1	756 -- Cut Dragon Onyx
-	2	161010	1	2520
-	3	161020	1	840
-	4	161030	1	42
-	5	161100	1	2520 -- Cut Dragon Onyx
-	6	161110	1	8400
-	7	161120	1	2800
-	8	161130	1	140
-	9	161200	1	840 -- Cut Dragon Onyx
-	10	161210	1	2800
-	11	161220	1	933
-	12	161230	1	47
-	13	161300	1	42 -- Cut Dragon Onyx
-	14	161310	1	140
-	15	161320	1	47
-	16	161330	1	2
-	17	161340	1	2
-	18	161400	1	42 -- Cut Dragon Onyx
-	19	161410	1	140
-	20	161420	1	47
-	21	161430	1	2
-	22	161440	1	2
-	23	162000	1	324 -- Rare Dragon Onyx
-	24	162010	1	1080
-	25	162020	1	360
-	26	162030	1	18
-	27	162040	1	18
-	28	162100	1	1080 -- Rare Dragon Onyx
-	29	162110	1	3600
-	30	162120	1	1200
-	31	162130	1	60
-	32	162140	1	60
-	33	162200	1	360 -- Rare Dragon Onyx
-	34	162210	1	1200
-	35	162220	1	400
-	36	162230	1	20
-	37	162240	1	20
-	38	162300	1	18 -- Rare Dragon Onyx
-	39	162310	1	60
-	40	162320	1	20
-	41	162330	1	1
-	42	162340	1	1
-	43	162400	1	18 -- Rare Dragon Onyx
-	44	162410	1	60
-	45	162420	1	20
-	46	162430	1	1
-	47	162440	1	1
-}
-Group	강력한용혼원석_화려-고대
-{
-	Vnum	51611 -- Cor Draconis+ (Eternal)
-	1	111000	1	972 -- Cut Dragon Diamond
-	2	111010	1	3240
-	3	111020	1	1080
-	4	111030	1	54
-	5	111100	1	3240 -- Cut Dragon Diamond
-	6	111110	1	10800
-	7	111120	1	3600
-	8	111130	1	180
-	9	111200	1	1080 -- Cut Dragon Diamond
-	10	111210	1	3600
-	11	111220	1	1200
-	12	111230	1	60
-	13	111300	1	54 -- Cut Dragon Diamond
-	14	111310	1	180
-	15	111320	1	60
-	16	111330	1	3
-	17	111340	1	3
-	18	111400	1	54 -- Cut Dragon Diamond
-	19	111410	1	180
-	20	111420	1	60
-	21	111430	1	3
-	22	111440	1	3
-	23	112000	1	1944 -- Rare Dragon Diamond
-	24	112010	1	6480
-	25	112020	1	2160
-	26	112030	1	108
-	27	112040	1	108
-	28	112100	1	6480 -- Rare Dragon Diamond
-	29	112110	1	21600
-	30	112120	1	7200
-	31	112130	1	360
-	32	112140	1	360
-	33	112200	1	2160 -- Rare Dragon Diamond
-	34	112210	1	7200
-	35	112220	1	2400
-	36	112230	1	120
-	37	112240	1	120
-	38	112300	1	108 -- Rare Dragon Diamond
-	39	112310	1	360
-	40	112320	1	120
-	41	112330	1	6
-	42	112340	1	6
-	43	112400	1	108 -- Rare Dragon Diamond
-	44	112410	1	360
-	45	112420	1	120
-	46	112430	1	6
-	47	112440	1	6
-	48	113000	1	324 -- Antique Dragon Diamond
-	49	113010	1	1080
-	50	113020	1	360
-	51	113030	1	18
-	52	113040	1	18
-	53	113100	1	1080 -- Antique Dragon Diamond
-	54	113110	1	3600
-	55	113120	1	1200
-	56	113130	1	60
-	57	113140	1	60
-	58	113200	1	360 -- Antique Dragon Diamond
-	59	113210	1	1200
-	60	113220	1	400
-	61	113230	1	20
-	62	113240	1	20
-	63	113300	1	18 -- Antique Dragon Diamond
-	64	113310	1	60
-	65	113320	1	20
-	66	113330	1	1
-	67	113340	1	1
-	68	113400	1	18 -- Antique Dragon Diamond
-	69	113410	1	60
-	70	113420	1	20
-	71	113430	1	1
-	72	113440	1	1
-	73	121000	1	972 -- Cut Dragon Ruby
-	74	121010	1	3240
-	75	121020	1	1080
-	76	121030	1	54
-	77	121100	1	3240 -- Cut Dragon Ruby
-	78	121110	1	10800
-	79	121120	1	3600
-	80	121130	1	180
-	81	121200	1	1080 -- Cut Dragon Ruby
-	82	121210	1	3600
-	83	121220	1	1200
-	84	121230	1	60
-	85	121300	1	54 -- Cut Dragon Ruby
-	86	121310	1	180
-	87	121320	1	60
-	88	121330	1	3
-	89	121340	1	3
-	90	121400	1	54 -- Cut Dragon Ruby
-	91	121410	1	180
-	92	121420	1	60
-	93	121430	1	3
-	94	121440	1	3
-	95	122000	1	1944 -- Rare Dragon Ruby
-	96	122010	1	6480
-	97	122020	1	2160
-	98	122030	1	108
-	99	122040	1	108
-	100	122100	1	6480 -- Rare Dragon Ruby
-	101	122110	1	21600
-	102	122120	1	7200
-	103	122130	1	360
-	104	122140	1	360
-	105	122200	1	2160 -- Rare Dragon Ruby
-	106	122210	1	7200
-	107	122220	1	2400
-	108	122230	1	120
-	109	122240	1	120
-	110	122300	1	108 -- Rare Dragon Ruby
-	111	122310	1	360
-	112	122320	1	120
-	113	122330	1	6
-	114	122340	1	6
-	115	122400	1	108 -- Rare Dragon Ruby
-	116	122410	1	360
-	117	122420	1	120
-	118	122430	1	6
-	119	122440	1	6
-	120	123000	1	324 -- Antique Dragon Ruby
-	121	123010	1	1080
-	122	123020	1	360
-	123	123030	1	18
-	124	123040	1	18
-	125	123100	1	1080 -- Antique Dragon Ruby
-	126	123110	1	3600
-	127	123120	1	1200
-	128	123130	1	60
-	129	123140	1	60
-	130	123200	1	360 -- Antique Dragon Ruby
-	131	123210	1	1200
-	132	123220	1	400
-	133	123230	1	20
-	134	123240	1	20
-	135	123300	1	18 -- Antique Dragon Ruby
-	136	123310	1	60
-	137	123320	1	20
-	138	123330	1	1
-	139	123340	1	1
-	140	123400	1	18 -- Antique Dragon Ruby
-	141	123410	1	60
-	142	123420	1	20
-	143	123430	1	1
-	144	123440	1	1
-	145	131000	1	972 -- Cut Dragon Jade
-	146	131010	1	3240
-	147	131020	1	1080
-	148	131030	1	54
-	149	131100	1	3240 -- Cut Dragon Jade
-	150	131110	1	10800
-	151	131120	1	3600
-	152	131130	1	180
-	153	131200	1	1080 -- Cut Dragon Jade
-	154	131210	1	3600
-	155	131220	1	1200
-	156	131230	1	60
-	157	131300	1	54 -- Cut Dragon Jade
-	158	131310	1	180
-	159	131320	1	60
-	160	131330	1	3
-	161	131340	1	3
-	162	131400	1	54 -- Cut Dragon Jade
-	163	131410	1	180
-	164	131420	1	60
-	165	131430	1	3
-	166	131440	1	3
-	167	132000	1	1944 -- Rare Dragon Jade
-	168	132010	1	6480
-	169	132020	1	2160
-	170	132030	1	108
-	171	132040	1	108
-	172	132100	1	6480 -- Rare Dragon Jade
-	173	132110	1	21600
-	174	132120	1	7200
-	175	132130	1	360
-	176	132140	1	360
-	177	132200	1	2160 -- Rare Dragon Jade
-	178	132210	1	7200
-	179	132220	1	2400
-	180	132230	1	120
-	181	132240	1	120
-	182	132300	1	108 -- Rare Dragon Jade
-	183	132310	1	360
-	184	132320	1	120
-	185	132330	1	6
-	186	132340	1	6
-	187	132400	1	108 -- Rare Dragon Jade
-	188	132410	1	360
-	189	132420	1	120
-	190	132430	1	6
-	191	132440	1	6
-	192	133000	1	324 -- Antique Dragon Jade
-	193	133010	1	1080
-	194	133020	1	360
-	195	133030	1	18
-	196	133040	1	18
-	197	133100	1	1080 -- Antique Dragon Jade
-	198	133110	1	3600
-	199	133120	1	1200
-	200	133130	1	60
-	201	133140	1	60
-	202	133200	1	360 -- Antique Dragon Jade
-	203	133210	1	1200
-	204	133220	1	400
-	205	133230	1	20
-	206	133240	1	20
-	207	133300	1	18 -- Antique Dragon Jade
-	208	133310	1	60
-	209	133320	1	20
-	210	133330	1	1
-	211	133340	1	1
-	212	133400	1	18 -- Antique Dragon Jade
-	213	133410	1	60
-	214	133420	1	20
-	215	133430	1	1
-	216	133440	1	1
-	217	141000	1	972 -- Cut Dragon Sapphire
-	218	141010	1	3240
-	219	141020	1	1080
-	220	141030	1	54
-	221	141100	1	3240 -- Cut Dragon Sapphire
-	222	141110	1	10800
-	223	141120	1	3600
-	224	141130	1	180
-	225	141200	1	1080 -- Cut Dragon Sapphire
-	226	141210	1	3600
-	227	141220	1	1200
-	228	141230	1	60
-	229	141300	1	54 -- Cut Dragon Sapphire
-	230	141310	1	180
-	231	141320	1	60
-	232	141330	1	3
-	233	141340	1	3
-	234	141400	1	54 -- Cut Dragon Sapphire
-	235	141410	1	180
-	236	141420	1	60
-	237	141430	1	3
-	238	141440	1	3
-	239	142000	1	1944 -- Rare Dragon Sapphire
-	240	142010	1	6480
-	241	142020	1	2160
-	242	142030	1	108
-	243	142040	1	108
-	244	142100	1	6480 -- Rare Dragon Sapphire
-	245	142110	1	21600
-	246	142120	1	7200
-	247	142130	1	360
-	248	142140	1	360
-	249	142200	1	2160 -- Rare Dragon Sapphire
-	250	142210	1	7200
-	251	142220	1	2400
-	252	142230	1	120
-	253	142240	1	120
-	254	142300	1	108 -- Rare Dragon Sapphire
-	255	142310	1	360
-	256	142320	1	120
-	257	142330	1	6
-	258	142340	1	6
-	259	142400	1	108 -- Rare Dragon Sapphire
-	260	142410	1	360
-	261	142420	1	120
-	262	142430	1	6
-	263	142440	1	6
-	264	143000	1	324 -- Antique Dragon Sapphire
-	265	143010	1	1080
-	266	143020	1	360
-	267	143030	1	18
-	268	143040	1	18
-	269	143100	1	1080 -- Antique Dragon Sapphire
-	270	143110	1	3600
-	271	143120	1	1200
-	272	143130	1	60
-	273	143140	1	60
-	274	143200	1	360 -- Antique Dragon Sapphire
-	275	143210	1	1200
-	276	143220	1	400
-	277	143230	1	20
-	278	143240	1	20
-	279	143300	1	18 -- Antique Dragon Sapphire
-	280	143310	1	60
-	281	143320	1	20
-	282	143330	1	1
-	283	143340	1	1
-	284	143400	1	18 -- Antique Dragon Sapphire
-	285	143410	1	60
-	286	143420	1	20
-	287	143430	1	1
-	288	143440	1	1
-	289	151000	1	972 -- Cut Dragon Garnet
-	290	151010	1	3240
-	291	151020	1	1080
-	292	151030	1	54
-	293	151100	1	3240 -- Cut Dragon Garnet
-	294	151110	1	10800
-	295	151120	1	3600
-	296	151130	1	180
-	297	151200	1	1080 -- Cut Dragon Garnet
-	298	151210	1	3600
-	299	151220	1	1200
-	300	151230	1	60
-	301	151300	1	54 -- Cut Dragon Garnet
-	302	151310	1	180
-	303	151320	1	60
-	304	151330	1	3
-	305	151340	1	3
-	306	151400	1	54 -- Cut Dragon Garnet
-	307	151410	1	180
-	308	151420	1	60
-	309	151430	1	3
-	310	151440	1	3
-	311	152000	1	1944 -- Rare Dragon Garnet
-	312	152010	1	6480
-	313	152020	1	2160
-	314	152030	1	108
-	315	152040	1	108
-	316	152100	1	6480 -- Rare Dragon Garnet
-	317	152110	1	21600
-	318	152120	1	7200
-	319	152130	1	360
-	320	152140	1	360
-	321	152200	1	2160 -- Rare Dragon Garnet
-	322	152210	1	7200
-	323	152220	1	2400
-	324	152230	1	120
-	325	152240	1	120
-	326	152300	1	108 -- Rare Dragon Garnet
-	327	152310	1	360
-	328	152320	1	120
-	329	152330	1	6
-	330	152340	1	6
-	331	152400	1	108 -- Rare Dragon Garnet
-	332	152410	1	360
-	333	152420	1	120
-	334	152430	1	6
-	335	152440	1	6
-	336	153000	1	324 -- Antique Dragon Garnet
-	337	153010	1	1080
-	338	153020	1	360
-	339	153030	1	18
-	340	153040	1	18
-	341	153100	1	1080 -- Antique Dragon Garnet
-	342	153110	1	3600
-	343	153120	1	1200
-	344	153130	1	60
-	345	153140	1	60
-	346	153200	1	360 -- Antique Dragon Garnet
-	347	153210	1	1200
-	348	153220	1	400
-	349	153230	1	20
-	350	153240	1	20
-	351	153300	1	18 -- Antique Dragon Garnet
-	352	153310	1	60
-	353	153320	1	20
-	354	153330	1	1
-	355	153340	1	1
-	356	153400	1	18 -- Antique Dragon Garnet
-	357	153410	1	60
-	358	153420	1	20
-	359	153430	1	1
-	360	153440	1	1
-	361	161000	1	972 -- Cut Dragon Onyx
-	362	161010	1	3240
-	363	161020	1	1080
-	364	161030	1	54
-	365	161100	1	3240 -- Cut Dragon Onyx
-	366	161110	1	10800
-	367	161120	1	3600
-	368	161130	1	180
-	369	161200	1	1080 -- Cut Dragon Onyx
-	370	161210	1	3600
-	371	161220	1	1200
-	372	161230	1	60
-	373	161300	1	54 -- Cut Dragon Onyx
-	374	161310	1	180
-	375	161320	1	60
-	376	161330	1	3
-	377	161340	1	3
-	378	161400	1	54 -- Cut Dragon Onyx
-	379	161410	1	180
-	380	161420	1	60
-	381	161430	1	3
-	382	161440	1	3
-	383	162000	1	1944 -- Rare Dragon Onyx
-	384	162010	1	6480
-	385	162020	1	2160
-	386	162030	1	108
-	387	162040	1	108
-	388	162100	1	6480 -- Rare Dragon Onyx
-	389	162110	1	21600
-	390	162120	1	7200
-	391	162130	1	360
-	392	162140	1	360
-	393	162200	1	2160 -- Rare Dragon Onyx
-	394	162210	1	7200
-	395	162220	1	2400
-	396	162230	1	120
-	397	162240	1	120
-	398	162300	1	108 -- Rare Dragon Onyx
-	399	162310	1	360
-	400	162320	1	120
-	401	162330	1	6
-	402	162340	1	6
-	403	162400	1	108 -- Rare Dragon Onyx
-	404	162410	1	360
-	405	162420	1	120
-	406	162430	1	6
-	407	162440	1	6
-	408	163000	1	324 -- Antique Dragon Onyx
-	409	163010	1	1080
-	410	163020	1	360
-	411	163030	1	18
-	412	163040	1	18
-	413	163100	1	1080 -- Antique Dragon Onyx
-	414	163110	1	3600
-	415	163120	1	1200
-	416	163130	1	60
-	417	163140	1	60
-	418	163200	1	360 -- Antique Dragon Onyx
-	419	163210	1	1200
-	420	163220	1	400
-	421	163230	1	20
-	422	163240	1	20
-	423	163300	1	18 -- Antique Dragon Onyx
-	424	163310	1	60
-	425	163320	1	20
-	426	163330	1	1
-	427	163340	1	1
-	428	163400	1	18 -- Antique Dragon Onyx
-	429	163410	1	60
-	430	163420	1	20
-	431	163430	1	1
-	432	163440	1	1
-}
-Group	백룡강력한용혼원석_화려-고대
-{
-	Vnum	51612 -- Cor Diamas+ (Eternal)
-	1	111000	1	972 -- Cut Dragon Diamond
-	2	111010	1	3240
-	3	111020	1	1080
-	4	111030	1	54
-	5	111100	1	3240 -- Cut Dragon Diamond
-	6	111110	1	10800
-	7	111120	1	3600
-	8	111130	1	180
-	9	111200	1	1080 -- Cut Dragon Diamond
-	10	111210	1	3600
-	11	111220	1	1200
-	12	111230	1	60
-	13	111300	1	54 -- Cut Dragon Diamond
-	14	111310	1	180
-	15	111320	1	60
-	16	111330	1	3
-	17	111340	1	3
-	18	111400	1	54 -- Cut Dragon Diamond
-	19	111410	1	180
-	20	111420	1	60
-	21	111430	1	3
-	22	111440	1	3
-	23	112000	1	1944 -- Rare Dragon Diamond
-	24	112010	1	6480
-	25	112020	1	2160
-	26	112030	1	108
-	27	112040	1	108
-	28	112100	1	6480 -- Rare Dragon Diamond
-	29	112110	1	21600
-	30	112120	1	7200
-	31	112130	1	360
-	32	112140	1	360
-	33	112200	1	2160 -- Rare Dragon Diamond
-	34	112210	1	7200
-	35	112220	1	2400
-	36	112230	1	120
-	37	112240	1	120
-	38	112300	1	108 -- Rare Dragon Diamond
-	39	112310	1	360
-	40	112320	1	120
-	41	112330	1	6
-	42	112340	1	6
-	43	112400	1	108 -- Rare Dragon Diamond
-	44	112410	1	360
-	45	112420	1	120
-	46	112430	1	6
-	47	112440	1	6
-	48	113000	1	324 -- Antique Dragon Diamond
-	49	113010	1	1080
-	50	113020	1	360
-	51	113030	1	18
-	52	113040	1	18
-	53	113100	1	1080 -- Antique Dragon Diamond
-	54	113110	1	3600
-	55	113120	1	1200
-	56	113130	1	60
-	57	113140	1	60
-	58	113200	1	360 -- Antique Dragon Diamond
-	59	113210	1	1200
-	60	113220	1	400
-	61	113230	1	20
-	62	113240	1	20
-	63	113300	1	18 -- Antique Dragon Diamond
-	64	113310	1	60
-	65	113320	1	20
-	66	113330	1	1
-	67	113340	1	1
-	68	113400	1	18 -- Antique Dragon Diamond
-	69	113410	1	60
-	70	113420	1	20
-	71	113430	1	1
-	72	113440	1	1
-}
-Group	화룡강력한용혼원석_화려-고대
-{
-	Vnum	51613 -- Cor Rubinum+ (Eternal)
-	1	121000	1	972 -- Cut Dragon Ruby
-	2	121010	1	3240
-	3	121020	1	1080
-	4	121030	1	54
-	5	121100	1	3240 -- Cut Dragon Ruby
-	6	121110	1	10800
-	7	121120	1	3600
-	8	121130	1	180
-	9	121200	1	1080 -- Cut Dragon Ruby
-	10	121210	1	3600
-	11	121220	1	1200
-	12	121230	1	60
-	13	121300	1	54 -- Cut Dragon Ruby
-	14	121310	1	180
-	15	121320	1	60
-	16	121330	1	3
-	17	121340	1	3
-	18	121400	1	54 -- Cut Dragon Ruby
-	19	121410	1	180
-	20	121420	1	60
-	21	121430	1	3
-	22	121440	1	3
-	23	122000	1	1944 -- Rare Dragon Ruby
-	24	122010	1	6480
-	25	122020	1	2160
-	26	122030	1	108
-	27	122040	1	108
-	28	122100	1	6480 -- Rare Dragon Ruby
-	29	122110	1	21600
-	30	122120	1	7200
-	31	122130	1	360
-	32	122140	1	360
-	33	122200	1	2160 -- Rare Dragon Ruby
-	34	122210	1	7200
-	35	122220	1	2400
-	36	122230	1	120
-	37	122240	1	120
-	38	122300	1	108 -- Rare Dragon Ruby
-	39	122310	1	360
-	40	122320	1	120
-	41	122330	1	6
-	42	122340	1	6
-	43	122400	1	108 -- Rare Dragon Ruby
-	44	122410	1	360
-	45	122420	1	120
-	46	122430	1	6
-	47	122440	1	6
-	48	123000	1	324 -- Antique Dragon Ruby
-	49	123010	1	1080
-	50	123020	1	360
-	51	123030	1	18
-	52	123040	1	18
-	53	123100	1	1080 -- Antique Dragon Ruby
-	54	123110	1	3600
-	55	123120	1	1200
-	56	123130	1	60
-	57	123140	1	60
-	58	123200	1	360 -- Antique Dragon Ruby
-	59	123210	1	1200
-	60	123220	1	400
-	61	123230	1	20
-	62	123240	1	20
-	63	123300	1	18 -- Antique Dragon Ruby
-	64	123310	1	60
-	65	123320	1	20
-	66	123330	1	1
-	67	123340	1	1
-	68	123400	1	18 -- Antique Dragon Ruby
-	69	123410	1	60
-	70	123420	1	20
-	71	123430	1	1
-	72	123440	1	1
-}
-Group	풍룡강력한용혼원석_화려-고대
-{
-	Vnum	51614 -- Cor Jadeit+ (Eternal)
-	1	131000	1	972 -- Cut Dragon Jade
-	2	131010	1	3240
-	3	131020	1	1080
-	4	131030	1	54
-	5	131100	1	3240 -- Cut Dragon Jade
-	6	131110	1	10800
-	7	131120	1	3600
-	8	131130	1	180
-	9	131200	1	1080 -- Cut Dragon Jade
-	10	131210	1	3600
-	11	131220	1	1200
-	12	131230	1	60
-	13	131300	1	54 -- Cut Dragon Jade
-	14	131310	1	180
-	15	131320	1	60
-	16	131330	1	3
-	17	131340	1	3
-	18	131400	1	54 -- Cut Dragon Jade
-	19	131410	1	180
-	20	131420	1	60
-	21	131430	1	3
-	22	131440	1	3
-	23	132000	1	1944 -- Rare Dragon Jade
-	24	132010	1	6480
-	25	132020	1	2160
-	26	132030	1	108
-	27	132040	1	108
-	28	132100	1	6480 -- Rare Dragon Jade
-	29	132110	1	21600
-	30	132120	1	7200
-	31	132130	1	360
-	32	132140	1	360
-	33	132200	1	2160 -- Rare Dragon Jade
-	34	132210	1	7200
-	35	132220	1	2400
-	36	132230	1	120
-	37	132240	1	120
-	38	132300	1	108 -- Rare Dragon Jade
-	39	132310	1	360
-	40	132320	1	120
-	41	132330	1	6
-	42	132340	1	6
-	43	132400	1	108 -- Rare Dragon Jade
-	44	132410	1	360
-	45	132420	1	120
-	46	132430	1	6
-	47	132440	1	6
-	48	133000	1	324 -- Antique Dragon Jade
-	49	133010	1	1080
-	50	133020	1	360
-	51	133030	1	18
-	52	133040	1	18
-	53	133100	1	1080 -- Antique Dragon Jade
-	54	133110	1	3600
-	55	133120	1	1200
-	56	133130	1	60
-	57	133140	1	60
-	58	133200	1	360 -- Antique Dragon Jade
-	59	133210	1	1200
-	60	133220	1	400
-	61	133230	1	20
-	62	133240	1	20
-	63	133300	1	18 -- Antique Dragon Jade
-	64	133310	1	60
-	65	133320	1	20
-	66	133330	1	1
-	67	133340	1	1
-	68	133400	1	18 -- Antique Dragon Jade
-	69	133410	1	60
-	70	133420	1	20
-	71	133430	1	1
-	72	133440	1	1
-}
-Group	철룡강력한용혼원석_화려-고대
-{
-	Vnum	51615 -- Cor Saphirum+ (Eternal)
-	1	141000	1	972 -- Cut Dragon Sapphire
-	2	141010	1	3240
-	3	141020	1	1080
-	4	141030	1	54
-	5	141100	1	3240 -- Cut Dragon Sapphire
-	6	141110	1	10800
-	7	141120	1	3600
-	8	141130	1	180
-	9	141200	1	1080 -- Cut Dragon Sapphire
-	10	141210	1	3600
-	11	141220	1	1200
-	12	141230	1	60
-	13	141300	1	54 -- Cut Dragon Sapphire
-	14	141310	1	180
-	15	141320	1	60
-	16	141330	1	3
-	17	141340	1	3
-	18	141400	1	54 -- Cut Dragon Sapphire
-	19	141410	1	180
-	20	141420	1	60
-	21	141430	1	3
-	22	141440	1	3
-	23	142000	1	1944 -- Rare Dragon Sapphire
-	24	142010	1	6480
-	25	142020	1	2160
-	26	142030	1	108
-	27	142040	1	108
-	28	142100	1	6480 -- Rare Dragon Sapphire
-	29	142110	1	21600
-	30	142120	1	7200
-	31	142130	1	360
-	32	142140	1	360
-	33	142200	1	2160 -- Rare Dragon Sapphire
-	34	142210	1	7200
-	35	142220	1	2400
-	36	142230	1	120
-	37	142240	1	120
-	38	142300	1	108 -- Rare Dragon Sapphire
-	39	142310	1	360
-	40	142320	1	120
-	41	142330	1	6
-	42	142340	1	6
-	43	142400	1	108 -- Rare Dragon Sapphire
-	44	142410	1	360
-	45	142420	1	120
-	46	142430	1	6
-	47	142440	1	6
-	48	143000	1	324 -- Antique Dragon Sapphire
-	49	143010	1	1080
-	50	143020	1	360
-	51	143030	1	18
-	52	143040	1	18
-	53	143100	1	1080 -- Antique Dragon Sapphire
-	54	143110	1	3600
-	55	143120	1	1200
-	56	143130	1	60
-	57	143140	1	60
-	58	143200	1	360 -- Antique Dragon Sapphire
-	59	143210	1	1200
-	60	143220	1	400
-	61	143230	1	20
-	62	143240	1	20
-	63	143300	1	18 -- Antique Dragon Sapphire
-	64	143310	1	60
-	65	143320	1	20
-	66	143330	1	1
-	67	143340	1	1
-	68	143400	1	18 -- Antique Dragon Sapphire
-	69	143410	1	60
-	70	143420	1	20
-	71	143430	1	1
-	72	143440	1	1
-}
-Group	뇌룡강력한용혼원석_화려-고대
-{
-	Vnum	51616 -- Cor Granatum+ (Eternal)
-	1	151000	1	972 -- Cut Dragon Garnet
-	2	151010	1	3240
-	3	151020	1	1080
-	4	151030	1	54
-	5	151100	1	3240 -- Cut Dragon Garnet
-	6	151110	1	10800
-	7	151120	1	3600
-	8	151130	1	180
-	9	151200	1	1080 -- Cut Dragon Garnet
-	10	151210	1	3600
-	11	151220	1	1200
-	12	151230	1	60
-	13	151300	1	54 -- Cut Dragon Garnet
-	14	151310	1	180
-	15	151320	1	60
-	16	151330	1	3
-	17	151340	1	3
-	18	151400	1	54 -- Cut Dragon Garnet
-	19	151410	1	180
-	20	151420	1	60
-	21	151430	1	3
-	22	151440	1	3
-	23	152000	1	1944 -- Rare Dragon Garnet
-	24	152010	1	6480
-	25	152020	1	2160
-	26	152030	1	108
-	27	152040	1	108
-	28	152100	1	6480 -- Rare Dragon Garnet
-	29	152110	1	21600
-	30	152120	1	7200
-	31	152130	1	360
-	32	152140	1	360
-	33	152200	1	2160 -- Rare Dragon Garnet
-	34	152210	1	7200
-	35	152220	1	2400
-	36	152230	1	120
-	37	152240	1	120
-	38	152300	1	108 -- Rare Dragon Garnet
-	39	152310	1	360
-	40	152320	1	120
-	41	152330	1	6
-	42	152340	1	6
-	43	152400	1	108 -- Rare Dragon Garnet
-	44	152410	1	360
-	45	152420	1	120
-	46	152430	1	6
-	47	152440	1	6
-	48	153000	1	324 -- Antique Dragon Garnet
-	49	153010	1	1080
-	50	153020	1	360
-	51	153030	1	18
-	52	153040	1	18
-	53	153100	1	1080 -- Antique Dragon Garnet
-	54	153110	1	3600
-	55	153120	1	1200
-	56	153130	1	60
-	57	153140	1	60
-	58	153200	1	360 -- Antique Dragon Garnet
-	59	153210	1	1200
-	60	153220	1	400
-	61	153230	1	20
-	62	153240	1	20
-	63	153300	1	18 -- Antique Dragon Garnet
-	64	153310	1	60
-	65	153320	1	20
-	66	153330	1	1
-	67	153340	1	1
-	68	153400	1	18 -- Antique Dragon Garnet
-	69	153410	1	60
-	70	153420	1	20
-	71	153430	1	1
-	72	153440	1	1
-}
-Group	흑룡강력한용혼원석_화려-고대
-{
-	Vnum	51617 -- Cor Atrum+ (Eternal)
-	1	161000	1	972 -- Cut Dragon Onyx
-	2	161010	1	3240
-	3	161020	1	1080
-	4	161030	1	54
-	5	161100	1	3240 -- Cut Dragon Onyx
-	6	161110	1	10800
-	7	161120	1	3600
-	8	161130	1	180
-	9	161200	1	1080 -- Cut Dragon Onyx
-	10	161210	1	3600
-	11	161220	1	1200
-	12	161230	1	60
-	13	161300	1	54 -- Cut Dragon Onyx
-	14	161310	1	180
-	15	161320	1	60
-	16	161330	1	3
-	17	161340	1	3
-	18	161400	1	54 -- Cut Dragon Onyx
-	19	161410	1	180
-	20	161420	1	60
-	21	161430	1	3
-	22	161440	1	3
-	23	162000	1	1944 -- Rare Dragon Onyx
-	24	162010	1	6480
-	25	162020	1	2160
-	26	162030	1	108
-	27	162040	1	108
-	28	162100	1	6480 -- Rare Dragon Onyx
-	29	162110	1	21600
-	30	162120	1	7200
-	31	162130	1	360
-	32	162140	1	360
-	33	162200	1	2160 -- Rare Dragon Onyx
-	34	162210	1	7200
-	35	162220	1	2400
-	36	162230	1	120
-	37	162240	1	120
-	38	162300	1	108 -- Rare Dragon Onyx
-	39	162310	1	360
-	40	162320	1	120
-	41	162330	1	6
-	42	162340	1	6
-	43	162400	1	108 -- Rare Dragon Onyx
-	44	162410	1	360
-	45	162420	1	120
-	46	162430	1	6
-	47	162440	1	6
-	48	163000	1	324 -- Antique Dragon Onyx
-	49	163010	1	1080
-	50	163020	1	360
-	51	163030	1	18
-	52	163040	1	18
-	53	163100	1	1080 -- Antique Dragon Onyx
-	54	163110	1	3600
-	55	163120	1	1200
-	56	163130	1	60
-	57	163140	1	60
-	58	163200	1	360 -- Antique Dragon Onyx
-	59	163210	1	1200
-	60	163220	1	400
-	61	163230	1	20
-	62	163240	1	20
-	63	163300	1	18 -- Antique Dragon Onyx
-	64	163310	1	60
-	65	163320	1	20
-	66	163330	1	1
-	67	163340	1	1
-	68	163400	1	18 -- Antique Dragon Onyx
-	69	163410	1	60
-	70	163420	1	20
-	71	163430	1	1
-	72	163440	1	1
-}
-Group	강력한용혼원석_화려-전설
-{
-	Vnum	51618 -- Cor Draconis+ (Mystical)
-	1	111000	1	324 -- Cut Dragon Diamond
-	2	111010	1	1080
-	3	111020	1	360
-	4	111030	1	18
-	5	111100	1	1080 -- Cut Dragon Diamond
-	6	111110	1	3600
-	7	111120	1	1200
-	8	111130	1	60
-	9	111200	1	360 -- Cut Dragon Diamond
-	10	111210	1	1200
-	11	111220	1	400
-	12	111230	1	20
-	13	111300	1	18 -- Cut Dragon Diamond
-	14	111310	1	60
-	15	111320	1	20
-	16	111330	1	1
-	17	111340	1	1
-	18	111400	1	18 -- Cut Dragon Diamond
-	19	111410	1	60
-	20	111420	1	20
-	21	111430	1	1
-	22	111440	1	1
-	23	112000	1	810 -- Rare Dragon Diamond
-	24	112010	1	2700
-	25	112020	1	900
-	26	112030	1	45
-	27	112040	1	45
-	28	112100	1	2700 -- Rare Dragon Diamond
-	29	112110	1	9000
-	30	112120	1	3000
-	31	112130	1	150
-	32	112140	1	150
-	33	112200	1	900 -- Rare Dragon Diamond
-	34	112210	1	3000
-	35	112220	1	1000
-	36	112230	1	50
-	37	112240	1	50
-	38	112300	1	45 -- Rare Dragon Diamond
-	39	112310	1	150
-	40	112320	1	50
-	41	112330	1	3
-	42	112340	1	3
-	43	112400	1	45 -- Rare Dragon Diamond
-	44	112410	1	150
-	45	112420	1	50
-	46	112430	1	3
-	47	112440	1	3
-	48	113000	1	1782 -- Antique Dragon Diamond
-	49	113010	1	5940
-	50	113020	1	1980
-	51	113030	1	99
-	52	113040	1	99
-	53	113100	1	5940 -- Antique Dragon Diamond
-	54	113110	1	19800
-	55	113120	1	6600
-	56	113130	1	330
-	57	113140	1	330
-	58	113200	1	1980 -- Antique Dragon Diamond
-	59	113210	1	6600
-	60	113220	1	2200
-	61	113230	1	110
-	62	113240	1	110
-	63	113300	1	99 -- Antique Dragon Diamond
-	64	113310	1	330
-	65	113320	1	110
-	66	113330	1	6
-	67	113340	1	6
-	68	113400	1	99 -- Antique Dragon Diamond
-	69	113410	1	330
-	70	113420	1	110
-	71	113430	1	6
-	72	113440	1	6
-	73	114000	1	324 -- Legendary Dragon Diamond
-	74	114010	1	1080
-	75	114020	1	360
-	76	114030	1	18
-	77	114040	1	18
-	78	114100	1	1080 -- Legendary Dragon Diamond
-	79	114110	1	3600
-	80	114120	1	1200
-	81	114130	1	60
-	82	114140	1	60
-	83	114200	1	360 -- Legendary Dragon Diamond
-	84	114210	1	1200
-	85	114220	1	400
-	86	114230	1	20
-	87	114240	1	20
-	88	114300	1	18 -- Legendary Dragon Diamond
-	89	114310	1	60
-	90	114320	1	20
-	91	114330	1	1
-	92	114340	1	1
-	93	114400	1	18 -- Legendary Dragon Diamond
-	94	114410	1	60
-	95	114420	1	20
-	96	114430	1	1
-	97	114440	1	1
-	98	121000	1	324 -- Cut Dragon Ruby
-	99	121010	1	1080
-	100	121020	1	360
-	101	121030	1	18
-	102	121100	1	1080 -- Cut Dragon Ruby
-	103	121110	1	3600
-	104	121120	1	1200
-	105	121130	1	60
-	106	121200	1	360 -- Cut Dragon Ruby
-	107	121210	1	1200
-	108	121220	1	400
-	109	121230	1	20
-	110	121300	1	18 -- Cut Dragon Ruby
-	111	121310	1	60
-	112	121320	1	20
-	113	121330	1	1
-	114	121340	1	1
-	115	121400	1	18 -- Cut Dragon Ruby
-	116	121410	1	60
-	117	121420	1	20
-	118	121430	1	1
-	119	121440	1	1
-	120	122000	1	810 -- Rare Dragon Ruby
-	121	122010	1	2700
-	122	122020	1	900
-	123	122030	1	45
-	124	122040	1	45
-	125	122100	1	2700 -- Rare Dragon Ruby
-	126	122110	1	9000
-	127	122120	1	3000
-	128	122130	1	150
-	129	122140	1	150
-	130	122200	1	900 -- Rare Dragon Ruby
-	131	122210	1	3000
-	132	122220	1	1000
-	133	122230	1	50
-	134	122240	1	50
-	135	122300	1	45 -- Rare Dragon Ruby
-	136	122310	1	150
-	137	122320	1	50
-	138	122330	1	3
-	139	122340	1	3
-	140	122400	1	45 -- Rare Dragon Ruby
-	141	122410	1	150
-	142	122420	1	50
-	143	122430	1	3
-	144	122440	1	3
-	145	123000	1	1782 -- Antique Dragon Ruby
-	146	123010	1	5940
-	147	123020	1	1980
-	148	123030	1	99
-	149	123040	1	99
-	150	123100	1	5940 -- Antique Dragon Ruby
-	151	123110	1	19800
-	152	123120	1	6600
-	153	123130	1	330
-	154	123140	1	330
-	155	123200	1	1980 -- Antique Dragon Ruby
-	156	123210	1	6600
-	157	123220	1	2200
-	158	123230	1	110
-	159	123240	1	110
-	160	123300	1	99 -- Antique Dragon Ruby
-	161	123310	1	330
-	162	123320	1	110
-	163	123330	1	6
-	164	123340	1	6
-	165	123400	1	99 -- Antique Dragon Ruby
-	166	123410	1	330
-	167	123420	1	110
-	168	123430	1	6
-	169	123440	1	6
-	170	124000	1	324 -- Legendary Dragon Ruby
-	171	124010	1	1080
-	172	124020	1	360
-	173	124030	1	18
-	174	124040	1	18
-	175	124100	1	1080 -- Legendary Dragon Ruby
-	176	124110	1	3600
-	177	124120	1	1200
-	178	124130	1	60
-	179	124140	1	60
-	180	124200	1	360 -- Legendary Dragon Ruby
-	181	124210	1	1200
-	182	124220	1	400
-	183	124230	1	20
-	184	124240	1	20
-	185	124300	1	18 -- Legendary Dragon Ruby
-	186	124310	1	60
-	187	124320	1	20
-	188	124330	1	1
-	189	124340	1	1
-	190	124400	1	18 -- Legendary Dragon Ruby
-	191	124410	1	60
-	192	124420	1	20
-	193	124430	1	1
-	194	124440	1	1
-	195	131000	1	324 -- Cut Dragon Jade
-	196	131010	1	1080
-	197	131020	1	360
-	198	131030	1	18
-	199	131100	1	1080 -- Cut Dragon Jade
-	200	131110	1	3600
-	201	131120	1	1200
-	202	131130	1	60
-	203	131200	1	360 -- Cut Dragon Jade
-	204	131210	1	1200
-	205	131220	1	400
-	206	131230	1	20
-	207	131300	1	18 -- Cut Dragon Jade
-	208	131310	1	60
-	209	131320	1	20
-	210	131330	1	1
-	211	131340	1	1
-	212	131400	1	18 -- Cut Dragon Jade
-	213	131410	1	60
-	214	131420	1	20
-	215	131430	1	1
-	216	131440	1	1
-	217	132000	1	810 -- Rare Dragon Jade
-	218	132010	1	2700
-	219	132020	1	900
-	220	132030	1	45
-	221	132040	1	45
-	222	132100	1	2700 -- Rare Dragon Jade
-	223	132110	1	9000
-	224	132120	1	3000
-	225	132130	1	150
-	226	132140	1	150
-	227	132200	1	900 -- Rare Dragon Jade
-	228	132210	1	3000
-	229	132220	1	1000
-	230	132230	1	50
-	231	132240	1	50
-	232	132300	1	45 -- Rare Dragon Jade
-	233	132310	1	150
-	234	132320	1	50
-	235	132330	1	3
-	236	132340	1	3
-	237	132400	1	45 -- Rare Dragon Jade
-	238	132410	1	150
-	239	132420	1	50
-	240	132430	1	3
-	241	132440	1	3
-	242	133000	1	1782 -- Antique Dragon Jade
-	243	133010	1	5940
-	244	133020	1	1980
-	245	133030	1	99
-	246	133040	1	99
-	247	133100	1	5940 -- Antique Dragon Jade
-	248	133110	1	19800
-	249	133120	1	6600
-	250	133130	1	330
-	251	133140	1	330
-	252	133200	1	1980 -- Antique Dragon Jade
-	253	133210	1	6600
-	254	133220	1	2200
-	255	133230	1	110
-	256	133240	1	110
-	257	133300	1	99 -- Antique Dragon Jade
-	258	133310	1	330
-	259	133320	1	110
-	260	133330	1	6
-	261	133340	1	6
-	262	133400	1	99 -- Antique Dragon Jade
-	263	133410	1	330
-	264	133420	1	110
-	265	133430	1	6
-	266	133440	1	6
-	267	134000	1	324 -- Legendary Dragon Jade
-	268	134010	1	1080
-	269	134020	1	360
-	270	134030	1	18
-	271	134040	1	18
-	272	134100	1	1080 -- Legendary Dragon Jade
-	273	134110	1	3600
-	274	134120	1	1200
-	275	134130	1	60
-	276	134140	1	60
-	277	134200	1	360 -- Legendary Dragon Jade
-	278	134210	1	1200
-	279	134220	1	400
-	280	134230	1	20
-	281	134240	1	20
-	282	134300	1	18 -- Legendary Dragon Jade
-	283	134310	1	60
-	284	134320	1	20
-	285	134330	1	1
-	286	134340	1	1
-	287	134400	1	18 -- Legendary Dragon Jade
-	288	134410	1	60
-	289	134420	1	20
-	290	134430	1	1
-	291	134440	1	1
-	292	141000	1	324 -- Cut Dragon Sapphire
-	293	141010	1	1080
-	294	141020	1	360
-	295	141030	1	18
-	296	141100	1	1080 -- Cut Dragon Sapphire
-	297	141110	1	3600
-	298	141120	1	1200
-	299	141130	1	60
-	300	141200	1	360 -- Cut Dragon Sapphire
-	301	141210	1	1200
-	302	141220	1	400
-	303	141230	1	20
-	304	141300	1	18 -- Cut Dragon Sapphire
-	305	141310	1	60
-	306	141320	1	20
-	307	141330	1	1
-	308	141340	1	1
-	309	141400	1	18 -- Cut Dragon Sapphire
-	310	141410	1	60
-	311	141420	1	20
-	312	141430	1	1
-	313	141440	1	1
-	314	142000	1	810 -- Rare Dragon Sapphire
-	315	142010	1	2700
-	316	142020	1	900
-	317	142030	1	45
-	318	142040	1	45
-	319	142100	1	2700 -- Rare Dragon Sapphire
-	320	142110	1	9000
-	321	142120	1	3000
-	322	142130	1	150
-	323	142140	1	150
-	324	142200	1	900 -- Rare Dragon Sapphire
-	325	142210	1	3000
-	326	142220	1	1000
-	327	142230	1	50
-	328	142240	1	50
-	329	142300	1	45 -- Rare Dragon Sapphire
-	330	142310	1	150
-	331	142320	1	50
-	332	142330	1	3
-	333	142340	1	3
-	334	142400	1	45 -- Rare Dragon Sapphire
-	335	142410	1	150
-	336	142420	1	50
-	337	142430	1	3
-	338	142440	1	3
-	339	143000	1	1782 -- Antique Dragon Sapphire
-	340	143010	1	5940
-	341	143020	1	1980
-	342	143030	1	99
-	343	143040	1	99
-	344	143100	1	5940 -- Antique Dragon Sapphire
-	345	143110	1	19800
-	346	143120	1	6600
-	347	143130	1	330
-	348	143140	1	330
-	349	143200	1	1980 -- Antique Dragon Sapphire
-	350	143210	1	6600
-	351	143220	1	2200
-	352	143230	1	110
-	353	143240	1	110
-	354	143300	1	99 -- Antique Dragon Sapphire
-	355	143310	1	330
-	356	143320	1	110
-	357	143330	1	6
-	358	143340	1	6
-	359	143400	1	99 -- Antique Dragon Sapphire
-	360	143410	1	330
-	361	143420	1	110
-	362	143430	1	6
-	363	143440	1	6
-	364	144000	1	324 -- Legendary DragonSapphire
-	365	144010	1	1080
-	366	144020	1	360
-	367	144030	1	18
-	368	144040	1	18
-	369	144100	1	1080 -- Legendary DragonSapphire
-	370	144110	1	3600
-	371	144120	1	1200
-	372	144130	1	60
-	373	144140	1	60
-	374	144200	1	360 -- Legendary DragonSapphire
-	375	144210	1	1200
-	376	144220	1	400
-	377	144230	1	20
-	378	144240	1	20
-	379	144300	1	18 -- Legendary DragonSapphire
-	380	144310	1	60
-	381	144320	1	20
-	382	144330	1	1
-	383	144340	1	1
-	384	144400	1	18 -- Legendary DragonSapphire
-	385	144410	1	60
-	386	144420	1	20
-	387	144430	1	1
-	388	144440	1	1
-	389	151000	1	324 -- Cut Dragon Garnet
-	390	151010	1	1080
-	391	151020	1	360
-	392	151030	1	18
-	393	151100	1	1080 -- Cut Dragon Garnet
-	394	151110	1	3600
-	395	151120	1	1200
-	396	151130	1	60
-	397	151200	1	360 -- Cut Dragon Garnet
-	398	151210	1	1200
-	399	151220	1	400
-	400	151230	1	20
-	401	151300	1	18 -- Cut Dragon Garnet
-	402	151310	1	60
-	403	151320	1	20
-	404	151330	1	1
-	405	151340	1	1
-	406	151400	1	18 -- Cut Dragon Garnet
-	407	151410	1	60
-	408	151420	1	20
-	409	151430	1	1
-	410	151440	1	1
-	411	152000	1	810 -- Rare Dragon Garnet
-	412	152010	1	2700
-	413	152020	1	900
-	414	152030	1	45
-	415	152040	1	45
-	416	152100	1	2700 -- Rare Dragon Garnet
-	417	152110	1	9000
-	418	152120	1	3000
-	419	152130	1	150
-	420	152140	1	150
-	421	152200	1	900 -- Rare Dragon Garnet
-	422	152210	1	3000
-	423	152220	1	1000
-	424	152230	1	50
-	425	152240	1	50
-	426	152300	1	45 -- Rare Dragon Garnet
-	427	152310	1	150
-	428	152320	1	50
-	429	152330	1	3
-	430	152340	1	3
-	431	152400	1	45 -- Rare Dragon Garnet
-	432	152410	1	150
-	433	152420	1	50
-	434	152430	1	3
-	435	152440	1	3
-	436	153000	1	1782 -- Antique Dragon Garnet
-	437	153010	1	5940
-	438	153020	1	1980
-	439	153030	1	99
-	440	153040	1	99
-	441	153100	1	5940 -- Antique Dragon Garnet
-	442	153110	1	19800
-	443	153120	1	6600
-	444	153130	1	330
-	445	153140	1	330
-	446	153200	1	1980 -- Antique Dragon Garnet
-	447	153210	1	6600
-	448	153220	1	2200
-	449	153230	1	110
-	450	153240	1	110
-	451	153300	1	99 -- Antique Dragon Garnet
-	452	153310	1	330
-	453	153320	1	110
-	454	153330	1	6
-	455	153340	1	6
-	456	153400	1	99 -- Antique Dragon Garnet
-	457	153410	1	330
-	458	153420	1	110
-	459	153430	1	6
-	460	153440	1	6
-	461	154000	1	324 -- Legendary Dragon Garnet
-	462	154010	1	1080
-	463	154020	1	360
-	464	154030	1	18
-	465	154040	1	18
-	466	154100	1	1080 -- Legendary Dragon Garnet
-	467	154110	1	3600
-	468	154120	1	1200
-	469	154130	1	60
-	470	154140	1	60
-	471	154200	1	360 -- Legendary Dragon Garnet
-	472	154210	1	1200
-	473	154220	1	400
-	474	154230	1	20
-	475	154240	1	20
-	476	154300	1	18 -- Legendary Dragon Garnet
-	477	154310	1	60
-	478	154320	1	20
-	479	154330	1	1
-	480	154340	1	1
-	481	154400	1	18 -- Legendary Dragon Garnet
-	482	154410	1	60
-	483	154420	1	20
-	484	154430	1	1
-	485	154440	1	1
-	486	161000	1	324 -- Cut Dragon Onyx
-	487	161010	1	1080
-	488	161020	1	360
-	489	161030	1	18
-	490	161100	1	1080 -- Cut Dragon Onyx
-	491	161110	1	3600
-	492	161120	1	1200
-	493	161130	1	60
-	494	161200	1	360 -- Cut Dragon Onyx
-	495	161210	1	1200
-	496	161220	1	400
-	497	161230	1	20
-	498	161300	1	18 -- Cut Dragon Onyx
-	499	161310	1	60
-	500	161320	1	20
-	501	161330	1	1
-	502	161340	1	1
-	503	161400	1	18 -- Cut Dragon Onyx
-	504	161410	1	60
-	505	161420	1	20
-	506	161430	1	1
-	507	161440	1	1
-	508	162000	1	810 -- Rare Dragon Onyx
-	509	162010	1	2700
-	510	162020	1	900
-	511	162030	1	45
-	512	162040	1	45
-	513	162100	1	2700 -- Rare Dragon Onyx
-	514	162110	1	9000
-	515	162120	1	3000
-	516	162130	1	150
-	517	162140	1	150
-	518	162200	1	900 -- Rare Dragon Onyx
-	519	162210	1	3000
-	520	162220	1	1000
-	521	162230	1	50
-	522	162240	1	50
-	523	162300	1	45 -- Rare Dragon Onyx
-	524	162310	1	150
-	525	162320	1	50
-	526	162330	1	3
-	527	162340	1	3
-	528	162400	1	45 -- Rare Dragon Onyx
-	529	162410	1	150
-	530	162420	1	50
-	531	162430	1	3
-	532	162440	1	3
-	533	163000	1	1782 -- Antique Dragon Onyx
-	534	163010	1	5940
-	535	163020	1	1980
-	536	163030	1	99
-	537	163040	1	99
-	538	163100	1	5940 -- Antique Dragon Onyx
-	539	163110	1	19800
-	540	163120	1	6600
-	541	163130	1	330
-	542	163140	1	330
-	543	163200	1	1980 -- Antique Dragon Onyx
-	544	163210	1	6600
-	545	163220	1	2200
-	546	163230	1	110
-	547	163240	1	110
-	548	163300	1	99 -- Antique Dragon Onyx
-	549	163310	1	330
-	550	163320	1	110
-	551	163330	1	6
-	552	163340	1	6
-	553	163400	1	99 -- Antique Dragon Onyx
-	554	163410	1	330
-	555	163420	1	110
-	556	163430	1	6
-	557	163440	1	6
-	558	164000	1	324 -- Legendary Dragon Onyx
-	559	164010	1	1080
-	560	164020	1	360
-	561	164030	1	18
-	562	164040	1	18
-	563	164100	1	1080 -- Legendary Dragon Onyx
-	564	164110	1	3600
-	565	164120	1	1200
-	566	164130	1	60
-	567	164140	1	60
-	568	164200	1	360 -- Legendary Dragon Onyx
-	569	164210	1	1200
-	570	164220	1	400
-	571	164230	1	20
-	572	164240	1	20
-	573	164300	1	18 -- Legendary Dragon Onyx
-	574	164310	1	60
-	575	164320	1	20
-	576	164330	1	1
-	577	164340	1	1
-	578	164400	1	18 -- Legendary Dragon Onyx
-	579	164410	1	60
-	580	164420	1	20
-	581	164430	1	1
-	582	164440	1	1
-}
-Group	백룡강력한용혼원석_화려-전설
-{
-	Vnum	51619 -- Cor Diamas+ (Mystical)
-	1	111000	1	324 -- Cut Dragon Diamond
-	2	111010	1	1080
-	3	111020	1	360
-	4	111030	1	18
-	5	111100	1	1080 -- Cut Dragon Diamond
-	6	111110	1	3600
-	7	111120	1	1200
-	8	111130	1	60
-	9	111200	1	360 -- Cut Dragon Diamond
-	10	111210	1	1200
-	11	111220	1	400
-	12	111230	1	20
-	13	111300	1	18 -- Cut Dragon Diamond
-	14	111310	1	60
-	15	111320	1	20
-	16	111330	1	1
-	17	111340	1	1
-	18	111400	1	18 -- Cut Dragon Diamond
-	19	111410	1	60
-	20	111420	1	20
-	21	111430	1	1
-	22	111440	1	1
-	23	112000	1	810 -- Rare Dragon Diamond
-	24	112010	1	2700
-	25	112020	1	900
-	26	112030	1	45
-	27	112040	1	45
-	28	112100	1	2700 -- Rare Dragon Diamond
-	29	112110	1	9000
-	30	112120	1	3000
-	31	112130	1	150
-	32	112140	1	150
-	33	112200	1	900 -- Rare Dragon Diamond
-	34	112210	1	3000
-	35	112220	1	1000
-	36	112230	1	50
-	37	112240	1	50
-	38	112300	1	45 -- Rare Dragon Diamond
-	39	112310	1	150
-	40	112320	1	50
-	41	112330	1	3
-	42	112340	1	3
-	43	112400	1	45 -- Rare Dragon Diamond
-	44	112410	1	150
-	45	112420	1	50
-	46	112430	1	3
-	47	112440	1	3
-	48	113000	1	1782 -- Antique Dragon Diamond
-	49	113010	1	5940
-	50	113020	1	1980
-	51	113030	1	99
-	52	113040	1	99
-	53	113100	1	5940 -- Antique Dragon Diamond
-	54	113110	1	19800
-	55	113120	1	6600
-	56	113130	1	330
-	57	113140	1	330
-	58	113200	1	1980 -- Antique Dragon Diamond
-	59	113210	1	6600
-	60	113220	1	2200
-	61	113230	1	110
-	62	113240	1	110
-	63	113300	1	99 -- Antique Dragon Diamond
-	64	113310	1	330
-	65	113320	1	110
-	66	113330	1	6
-	67	113340	1	6
-	68	113400	1	99 -- Antique Dragon Diamond
-	69	113410	1	330
-	70	113420	1	110
-	71	113430	1	6
-	72	113440	1	6
-	73	114000	1	324 -- Legendary Dragon Diamond
-	74	114010	1	1080
-	75	114020	1	360
-	76	114030	1	18
-	77	114040	1	18
-	78	114100	1	1080 -- Legendary Dragon Diamond
-	79	114110	1	3600
-	80	114120	1	1200
-	81	114130	1	60
-	82	114140	1	60
-	83	114200	1	360 -- Legendary Dragon Diamond
-	84	114210	1	1200
-	85	114220	1	400
-	86	114230	1	20
-	87	114240	1	20
-	88	114300	1	18 -- Legendary Dragon Diamond
-	89	114310	1	60
-	90	114320	1	20
-	91	114330	1	1
-	92	114340	1	1
-	93	114400	1	18 -- Legendary Dragon Diamond
-	94	114410	1	60
-	95	114420	1	20
-	96	114430	1	1
-	97	114440	1	1
-}
-Group	화룡강력한용혼원석_화려-전설
-{
-	Vnum	51620 -- Cor Rubinum+ (Mystical)
-	1	121000	1	324 -- Cut Dragon Ruby
-	2	121010	1	1080
-	3	121020	1	360
-	4	121030	1	18
-	5	121100	1	1080 -- Cut Dragon Ruby
-	6	121110	1	3600
-	7	121120	1	1200
-	8	121130	1	60
-	9	121200	1	360 -- Cut Dragon Ruby
-	10	121210	1	1200
-	11	121220	1	400
-	12	121230	1	20
-	13	121300	1	18 -- Cut Dragon Ruby
-	14	121310	1	60
-	15	121320	1	20
-	16	121330	1	1
-	17	121340	1	1
-	18	121400	1	18 -- Cut Dragon Ruby
-	19	121410	1	60
-	20	121420	1	20
-	21	121430	1	1
-	22	121440	1	1
-	23	122000	1	810 -- Rare Dragon Ruby
-	24	122010	1	2700
-	25	122020	1	900
-	26	122030	1	45
-	27	122040	1	45
-	28	122100	1	2700 -- Rare Dragon Ruby
-	29	122110	1	9000
-	30	122120	1	3000
-	31	122130	1	150
-	32	122140	1	150
-	33	122200	1	900 -- Rare Dragon Ruby
-	34	122210	1	3000
-	35	122220	1	1000
-	36	122230	1	50
-	37	122240	1	50
-	38	122300	1	45 -- Rare Dragon Ruby
-	39	122310	1	150
-	40	122320	1	50
-	41	122330	1	3
-	42	122340	1	3
-	43	122400	1	45 -- Rare Dragon Ruby
-	44	122410	1	150
-	45	122420	1	50
-	46	122430	1	3
-	47	122440	1	3
-	48	123000	1	1782 -- Antique Dragon Ruby
-	49	123010	1	5940
-	50	123020	1	1980
-	51	123030	1	99
-	52	123040	1	99
-	53	123100	1	5940 -- Antique Dragon Ruby
-	54	123110	1	19800
-	55	123120	1	6600
-	56	123130	1	330
-	57	123140	1	330
-	58	123200	1	1980 -- Antique Dragon Ruby
-	59	123210	1	6600
-	60	123220	1	2200
-	61	123230	1	110
-	62	123240	1	110
-	63	123300	1	99 -- Antique Dragon Ruby
-	64	123310	1	330
-	65	123320	1	110
-	66	123330	1	6
-	67	123340	1	6
-	68	123400	1	99 -- Antique Dragon Ruby
-	69	123410	1	330
-	70	123420	1	110
-	71	123430	1	6
-	72	123440	1	6
-	73	124000	1	324 -- Legendary Dragon Ruby
-	74	124010	1	1080
-	75	124020	1	360
-	76	124030	1	18
-	77	124040	1	18
-	78	124100	1	1080 -- Legendary Dragon Ruby
-	79	124110	1	3600
-	80	124120	1	1200
-	81	124130	1	60
-	82	124140	1	60
-	83	124200	1	360 -- Legendary Dragon Ruby
-	84	124210	1	1200
-	85	124220	1	400
-	86	124230	1	20
-	87	124240	1	20
-	88	124300	1	18 -- Legendary Dragon Ruby
-	89	124310	1	60
-	90	124320	1	20
-	91	124330	1	1
-	92	124340	1	1
-	93	124400	1	18 -- Legendary Dragon Ruby
-	94	124410	1	60
-	95	124420	1	20
-	96	124430	1	1
-	97	124440	1	1
-}
-Group	풍룡강력한용혼원석_화려-전설
-{
-	Vnum	51621 -- Cor Jadeit+ (Mystical)
-	1	131000	1	324 -- Cut Dragon Jade
-	2	131010	1	1080
-	3	131020	1	360
-	4	131030	1	18
-	5	131100	1	1080 -- Cut Dragon Jade
-	6	131110	1	3600
-	7	131120	1	1200
-	8	131130	1	60
-	9	131200	1	360 -- Cut Dragon Jade
-	10	131210	1	1200
-	11	131220	1	400
-	12	131230	1	20
-	13	131300	1	18 -- Cut Dragon Jade
-	14	131310	1	60
-	15	131320	1	20
-	16	131330	1	1
-	17	131340	1	1
-	18	131400	1	18 -- Cut Dragon Jade
-	19	131410	1	60
-	20	131420	1	20
-	21	131430	1	1
-	22	131440	1	1
-	23	132000	1	810 -- Rare Dragon Jade
-	24	132010	1	2700
-	25	132020	1	900
-	26	132030	1	45
-	27	132040	1	45
-	28	132100	1	2700 -- Rare Dragon Jade
-	29	132110	1	9000
-	30	132120	1	3000
-	31	132130	1	150
-	32	132140	1	150
-	33	132200	1	900 -- Rare Dragon Jade
-	34	132210	1	3000
-	35	132220	1	1000
-	36	132230	1	50
-	37	132240	1	50
-	38	132300	1	45 -- Rare Dragon Jade
-	39	132310	1	150
-	40	132320	1	50
-	41	132330	1	3
-	42	132340	1	3
-	43	132400	1	45 -- Rare Dragon Jade
-	44	132410	1	150
-	45	132420	1	50
-	46	132430	1	3
-	47	132440	1	3
-	48	133000	1	1782 -- Antique Dragon Jade
-	49	133010	1	5940
-	50	133020	1	1980
-	51	133030	1	99
-	52	133040	1	99
-	53	133100	1	5940 -- Antique Dragon Jade
-	54	133110	1	19800
-	55	133120	1	6600
-	56	133130	1	330
-	57	133140	1	330
-	58	133200	1	1980 -- Antique Dragon Jade
-	59	133210	1	6600
-	60	133220	1	2200
-	61	133230	1	110
-	62	133240	1	110
-	63	133300	1	99 -- Antique Dragon Jade
-	64	133310	1	330
-	65	133320	1	110
-	66	133330	1	6
-	67	133340	1	6
-	68	133400	1	99 -- Antique Dragon Jade
-	69	133410	1	330
-	70	133420	1	110
-	71	133430	1	6
-	72	133440	1	6
-	73	134000	1	324 -- Legendary Dragon Jade
-	74	134010	1	1080
-	75	134020	1	360
-	76	134030	1	18
-	77	134040	1	18
-	78	134100	1	1080 -- Legendary Dragon Jade
-	79	134110	1	3600
-	80	134120	1	1200
-	81	134130	1	60
-	82	134140	1	60
-	83	134200	1	360 -- Legendary Dragon Jade
-	84	134210	1	1200
-	85	134220	1	400
-	86	134230	1	20
-	87	134240	1	20
-	88	134300	1	18 -- Legendary Dragon Jade
-	89	134310	1	60
-	90	134320	1	20
-	91	134330	1	1
-	92	134340	1	1
-	93	134400	1	18 -- Legendary Dragon Jade
-	94	134410	1	60
-	95	134420	1	20
-	96	134430	1	1
-	97	134440	1	1
-}
-Group	철룡강력한용혼원석_화려-전설
-{
-	Vnum	51622 -- Cor Saphirum+ (Mystical)
-	1	141000	1	324 -- Cut Dragon Sapphire
-	2	141010	1	1080
-	3	141020	1	360
-	4	141030	1	18
-	5	141100	1	1080 -- Cut Dragon Sapphire
-	6	141110	1	3600
-	7	141120	1	1200
-	8	141130	1	60
-	9	141200	1	360 -- Cut Dragon Sapphire
-	10	141210	1	1200
-	11	141220	1	400
-	12	141230	1	20
-	13	141300	1	18 -- Cut Dragon Sapphire
-	14	141310	1	60
-	15	141320	1	20
-	16	141330	1	1
-	17	141340	1	1
-	18	141400	1	18 -- Cut Dragon Sapphire
-	19	141410	1	60
-	20	141420	1	20
-	21	141430	1	1
-	22	141440	1	1
-	23	142000	1	810 -- Rare Dragon Sapphire
-	24	142010	1	2700
-	25	142020	1	900
-	26	142030	1	45
-	27	142040	1	45
-	28	142100	1	2700 -- Rare Dragon Sapphire
-	29	142110	1	9000
-	30	142120	1	3000
-	31	142130	1	150
-	32	142140	1	150
-	33	142200	1	900 -- Rare Dragon Sapphire
-	34	142210	1	3000
-	35	142220	1	1000
-	36	142230	1	50
-	37	142240	1	50
-	38	142300	1	45 -- Rare Dragon Sapphire
-	39	142310	1	150
-	40	142320	1	50
-	41	142330	1	3
-	42	142340	1	3
-	43	142400	1	45 -- Rare Dragon Sapphire
-	44	142410	1	150
-	45	142420	1	50
-	46	142430	1	3
-	47	142440	1	3
-	48	143000	1	1782 -- Antique Dragon Sapphire
-	49	143010	1	5940
-	50	143020	1	1980
-	51	143030	1	99
-	52	143040	1	99
-	53	143100	1	5940 -- Antique Dragon Sapphire
-	54	143110	1	19800
-	55	143120	1	6600
-	56	143130	1	330
-	57	143140	1	330
-	58	143200	1	1980 -- Antique Dragon Sapphire
-	59	143210	1	6600
-	60	143220	1	2200
-	61	143230	1	110
-	62	143240	1	110
-	63	143300	1	99 -- Antique Dragon Sapphire
-	64	143310	1	330
-	65	143320	1	110
-	66	143330	1	6
-	67	143340	1	6
-	68	143400	1	99 -- Antique Dragon Sapphire
-	69	143410	1	330
-	70	143420	1	110
-	71	143430	1	6
-	72	143440	1	6
-	73	144000	1	324 -- Legendary DragonSapphire
-	74	144010	1	1080
-	75	144020	1	360
-	76	144030	1	18
-	77	144040	1	18
-	78	144100	1	1080 -- Legendary DragonSapphire
-	79	144110	1	3600
-	80	144120	1	1200
-	81	144130	1	60
-	82	144140	1	60
-	83	144200	1	360 -- Legendary DragonSapphire
-	84	144210	1	1200
-	85	144220	1	400
-	86	144230	1	20
-	87	144240	1	20
-	88	144300	1	18 -- Legendary DragonSapphire
-	89	144310	1	60
-	90	144320	1	20
-	91	144330	1	1
-	92	144340	1	1
-	93	144400	1	18 -- Legendary DragonSapphire
-	94	144410	1	60
-	95	144420	1	20
-	96	144430	1	1
-	97	144440	1	1
-}
-Group	뇌룡강력한용혼원석_화려-전설
-{
-	Vnum	51623 -- Cor Granatum+ (Mystical)
-	1	151000	1	324 -- Cut Dragon Garnet
-	2	151010	1	1080
-	3	151020	1	360
-	4	151030	1	18
-	5	151100	1	1080 -- Cut Dragon Garnet
-	6	151110	1	3600
-	7	151120	1	1200
-	8	151130	1	60
-	9	151200	1	360 -- Cut Dragon Garnet
-	10	151210	1	1200
-	11	151220	1	400
-	12	151230	1	20
-	13	151300	1	18 -- Cut Dragon Garnet
-	14	151310	1	60
-	15	151320	1	20
-	16	151330	1	1
-	17	151340	1	1
-	18	151400	1	18 -- Cut Dragon Garnet
-	19	151410	1	60
-	20	151420	1	20
-	21	151430	1	1
-	22	151440	1	1
-	23	152000	1	810 -- Rare Dragon Garnet
-	24	152010	1	2700
-	25	152020	1	900
-	26	152030	1	45
-	27	152040	1	45
-	28	152100	1	2700 -- Rare Dragon Garnet
-	29	152110	1	9000
-	30	152120	1	3000
-	31	152130	1	150
-	32	152140	1	150
-	33	152200	1	900 -- Rare Dragon Garnet
-	34	152210	1	3000
-	35	152220	1	1000
-	36	152230	1	50
-	37	152240	1	50
-	38	152300	1	45 -- Rare Dragon Garnet
-	39	152310	1	150
-	40	152320	1	50
-	41	152330	1	3
-	42	152340	1	3
-	43	152400	1	45 -- Rare Dragon Garnet
-	44	152410	1	150
-	45	152420	1	50
-	46	152430	1	3
-	47	152440	1	3
-	48	153000	1	1782 -- Antique Dragon Garnet
-	49	153010	1	5940
-	50	153020	1	1980
-	51	153030	1	99
-	52	153040	1	99
-	53	153100	1	5940 -- Antique Dragon Garnet
-	54	153110	1	19800
-	55	153120	1	6600
-	56	153130	1	330
-	57	153140	1	330
-	58	153200	1	1980 -- Antique Dragon Garnet
-	59	153210	1	6600
-	60	153220	1	2200
-	61	153230	1	110
-	62	153240	1	110
-	63	153300	1	99 -- Antique Dragon Garnet
-	64	153310	1	330
-	65	153320	1	110
-	66	153330	1	6
-	67	153340	1	6
-	68	153400	1	99 -- Antique Dragon Garnet
-	69	153410	1	330
-	70	153420	1	110
-	71	153430	1	6
-	72	153440	1	6
-	73	154000	1	324 -- Legendary Dragon Garnet
-	74	154010	1	1080
-	75	154020	1	360
-	76	154030	1	18
-	77	154040	1	18
-	78	154100	1	1080 -- Legendary Dragon Garnet
-	79	154110	1	3600
-	80	154120	1	1200
-	81	154130	1	60
-	82	154140	1	60
-	83	154200	1	360 -- Legendary Dragon Garnet
-	84	154210	1	1200
-	85	154220	1	400
-	86	154230	1	20
-	87	154240	1	20
-	88	154300	1	18 -- Legendary Dragon Garnet
-	89	154310	1	60
-	90	154320	1	20
-	91	154330	1	1
-	92	154340	1	1
-	93	154400	1	18 -- Legendary Dragon Garnet
-	94	154410	1	60
-	95	154420	1	20
-	96	154430	1	1
-	97	154440	1	1
-}
-Group	흑룡강력한용혼원석_화려-전설
-{
-	Vnum	51624 -- Cor Atrum+ (Mystical)
-	1	161000	1	324 -- Cut Dragon Onyx
-	2	161010	1	1080
-	3	161020	1	360
-	4	161030	1	18
-	5	161100	1	1080 -- Cut Dragon Onyx
-	6	161110	1	3600
-	7	161120	1	1200
-	8	161130	1	60
-	9	161200	1	360 -- Cut Dragon Onyx
-	10	161210	1	1200
-	11	161220	1	400
-	12	161230	1	20
-	13	161300	1	18 -- Cut Dragon Onyx
-	14	161310	1	60
-	15	161320	1	20
-	16	161330	1	1
-	17	161340	1	1
-	18	161400	1	18 -- Cut Dragon Onyx
-	19	161410	1	60
-	20	161420	1	20
-	21	161430	1	1
-	22	161440	1	1
-	23	162000	1	810 -- Rare Dragon Onyx
-	24	162010	1	2700
-	25	162020	1	900
-	26	162030	1	45
-	27	162040	1	45
-	28	162100	1	2700 -- Rare Dragon Onyx
-	29	162110	1	9000
-	30	162120	1	3000
-	31	162130	1	150
-	32	162140	1	150
-	33	162200	1	900 -- Rare Dragon Onyx
-	34	162210	1	3000
-	35	162220	1	1000
-	36	162230	1	50
-	37	162240	1	50
-	38	162300	1	45 -- Rare Dragon Onyx
-	39	162310	1	150
-	40	162320	1	50
-	41	162330	1	3
-	42	162340	1	3
-	43	162400	1	45 -- Rare Dragon Onyx
-	44	162410	1	150
-	45	162420	1	50
-	46	162430	1	3
-	47	162440	1	3
-	48	163000	1	1782 -- Antique Dragon Onyx
-	49	163010	1	5940
-	50	163020	1	1980
-	51	163030	1	99
-	52	163040	1	99
-	53	163100	1	5940 -- Antique Dragon Onyx
-	54	163110	1	19800
-	55	163120	1	6600
-	56	163130	1	330
-	57	163140	1	330
-	58	163200	1	1980 -- Antique Dragon Onyx
-	59	163210	1	6600
-	60	163220	1	2200
-	61	163230	1	110
-	62	163240	1	110
-	63	163300	1	99 -- Antique Dragon Onyx
-	64	163310	1	330
-	65	163320	1	110
-	66	163330	1	6
-	67	163340	1	6
-	68	163400	1	99 -- Antique Dragon Onyx
-	69	163410	1	330
-	70	163420	1	110
-	71	163430	1	6
-	72	163440	1	6
-	73	164000	1	324 -- Legendary Dragon Onyx
-	74	164010	1	1080
-	75	164020	1	360
-	76	164030	1	18
-	77	164040	1	18
-	78	164100	1	1080 -- Legendary Dragon Onyx
-	79	164110	1	3600
-	80	164120	1	1200
-	81	164130	1	60
-	82	164140	1	60
-	83	164200	1	360 -- Legendary Dragon Onyx
-	84	164210	1	1200
-	85	164220	1	400
-	86	164230	1	20
-	87	164240	1	20
-	88	164300	1	18 -- Legendary Dragon Onyx
-	89	164310	1	60
-	90	164320	1	20
-	91	164330	1	1
-	92	164340	1	1
-	93	164400	1	18 -- Legendary Dragon Onyx
-	94	164410	1	60
-	95	164420	1	20
-	96	164430	1	1
-	97	164440	1	1
-}
-Group	강력한용혼원석_희귀-고대
-{
-	Vnum	51625 -- Cor Draconis+ (Epic)
-	1	112000	1	756 -- Rare Dragon Diamond
-	2	112010	1	2520
-	3	112020	1	840
-	4	112030	1	42
-	5	112040	1	42
-	6	112100	1	2520 -- Rare Dragon Diamond
-	7	112110	1	8400
-	8	112120	1	2800
-	9	112130	1	140
-	10	112140	1	140
-	11	112200	1	840 -- Rare Dragon Diamond
-	12	112210	1	2800
-	13	112220	1	933
-	14	112230	1	47
-	15	112240	1	47
-	16	112300	1	42 -- Rare Dragon Diamond
-	17	112310	1	140
-	18	112320	1	47
-	19	112330	1	2
-	20	112340	1	2
-	21	112400	1	42 -- Rare Dragon Diamond
-	22	112410	1	140
-	23	112420	1	47
-	24	112430	1	2
-	25	112440	1	2
-	26	113000	1	324 -- Antique Dragon Diamond
-	27	113010	1	1080
-	28	113020	1	360
-	29	113030	1	18
-	30	113040	1	18
-	31	113100	1	1080 -- Antique Dragon Diamond
-	32	113110	1	3600
-	33	113120	1	1200
-	34	113130	1	60
-	35	113140	1	60
-	36	113200	1	360 -- Antique Dragon Diamond
-	37	113210	1	1200
-	38	113220	1	400
-	39	113230	1	20
-	40	113240	1	20
-	41	113300	1	18 -- Antique Dragon Diamond
-	42	113310	1	60
-	43	113320	1	20
-	44	113330	1	1
-	45	113340	1	1
-	46	113400	1	18 -- Antique Dragon Diamond
-	47	113410	1	60
-	48	113420	1	20
-	49	113430	1	1
-	50	113440	1	1
-	51	122000	1	756 -- Rare Dragon Ruby
-	52	122010	1	2520
-	53	122020	1	840
-	54	122030	1	42
-	55	122040	1	42
-	56	122100	1	2520 -- Rare Dragon Ruby
-	57	122110	1	8400
-	58	122120	1	2800
-	59	122130	1	140
-	60	122140	1	140
-	61	122200	1	840 -- Rare Dragon Ruby
-	62	122210	1	2800
-	63	122220	1	933
-	64	122230	1	47
-	65	122240	1	47
-	66	122300	1	42 -- Rare Dragon Ruby
-	67	122310	1	140
-	68	122320	1	47
-	69	122330	1	2
-	70	122340	1	2
-	71	122400	1	42 -- Rare Dragon Ruby
-	72	122410	1	140
-	73	122420	1	47
-	74	122430	1	2
-	75	122440	1	2
-	76	123000	1	324 -- Antique Dragon Ruby
-	77	123010	1	1080
-	78	123020	1	360
-	79	123030	1	18
-	80	123040	1	18
-	81	123100	1	1080 -- Antique Dragon Ruby
-	82	123110	1	3600
-	83	123120	1	1200
-	84	123130	1	60
-	85	123140	1	60
-	86	123200	1	360 -- Antique Dragon Ruby
-	87	123210	1	1200
-	88	123220	1	400
-	89	123230	1	20
-	90	123240	1	20
-	91	123300	1	18 -- Antique Dragon Ruby
-	92	123310	1	60
-	93	123320	1	20
-	94	123330	1	1
-	95	123340	1	1
-	96	123400	1	18 -- Antique Dragon Ruby
-	97	123410	1	60
-	98	123420	1	20
-	99	123430	1	1
-	100	123440	1	1
-	101	132000	1	756 -- Rare Dragon Jade
-	102	132010	1	2520
-	103	132020	1	840
-	104	132030	1	42
-	105	132040	1	42
-	106	132100	1	2520 -- Rare Dragon Jade
-	107	132110	1	8400
-	108	132120	1	2800
-	109	132130	1	140
-	110	132140	1	140
-	111	132200	1	840 -- Rare Dragon Jade
-	112	132210	1	2800
-	113	132220	1	933
-	114	132230	1	47
-	115	132240	1	47
-	116	132300	1	42 -- Rare Dragon Jade
-	117	132310	1	140
-	118	132320	1	47
-	119	132330	1	2
-	120	132340	1	2
-	121	132400	1	42 -- Rare Dragon Jade
-	122	132410	1	140
-	123	132420	1	47
-	124	132430	1	2
-	125	132440	1	2
-	126	133000	1	324 -- Antique Dragon Jade
-	127	133010	1	1080
-	128	133020	1	360
-	129	133030	1	18
-	130	133040	1	18
-	131	133100	1	1080 -- Antique Dragon Jade
-	132	133110	1	3600
-	133	133120	1	1200
-	134	133130	1	60
-	135	133140	1	60
-	136	133200	1	360 -- Antique Dragon Jade
-	137	133210	1	1200
-	138	133220	1	400
-	139	133230	1	20
-	140	133240	1	20
-	141	133300	1	18 -- Antique Dragon Jade
-	142	133310	1	60
-	143	133320	1	20
-	144	133330	1	1
-	145	133340	1	1
-	146	133400	1	18 -- Antique Dragon Jade
-	147	133410	1	60
-	148	133420	1	20
-	149	133430	1	1
-	150	133440	1	1
-	151	142000	1	756 -- Rare Dragon Sapphire
-	152	142010	1	2520
-	153	142020	1	840
-	154	142030	1	42
-	155	142040	1	42
-	156	142100	1	2520 -- Rare Dragon Sapphire
-	157	142110	1	8400
-	158	142120	1	2800
-	159	142130	1	140
-	160	142140	1	140
-	161	142200	1	840 -- Rare Dragon Sapphire
-	162	142210	1	2800
-	163	142220	1	933
-	164	142230	1	47
-	165	142240	1	47
-	166	142300	1	42 -- Rare Dragon Sapphire
-	167	142310	1	140
-	168	142320	1	47
-	169	142330	1	2
-	170	142340	1	2
-	171	142400	1	42 -- Rare Dragon Sapphire
-	172	142410	1	140
-	173	142420	1	47
-	174	142430	1	2
-	175	142440	1	2
-	176	143000	1	324 -- Antique Dragon Sapphire
-	177	143010	1	1080
-	178	143020	1	360
-	179	143030	1	18
-	180	143040	1	18
-	181	143100	1	1080 -- Antique Dragon Sapphire
-	182	143110	1	3600
-	183	143120	1	1200
-	184	143130	1	60
-	185	143140	1	60
-	186	143200	1	360 -- Antique Dragon Sapphire
-	187	143210	1	1200
-	188	143220	1	400
-	189	143230	1	20
-	190	143240	1	20
-	191	143300	1	18 -- Antique Dragon Sapphire
-	192	143310	1	60
-	193	143320	1	20
-	194	143330	1	1
-	195	143340	1	1
-	196	143400	1	18 -- Antique Dragon Sapphire
-	197	143410	1	60
-	198	143420	1	20
-	199	143430	1	1
-	200	143440	1	1
-	201	152000	1	756 -- Rare Dragon Garnet
-	202	152010	1	2520
-	203	152020	1	840
-	204	152030	1	42
-	205	152040	1	42
-	206	152100	1	2520 -- Rare Dragon Garnet
-	207	152110	1	8400
-	208	152120	1	2800
-	209	152130	1	140
-	210	152140	1	140
-	211	152200	1	840 -- Rare Dragon Garnet
-	212	152210	1	2800
-	213	152220	1	933
-	214	152230	1	47
-	215	152240	1	47
-	216	152300	1	42 -- Rare Dragon Garnet
-	217	152310	1	140
-	218	152320	1	47
-	219	152330	1	2
-	220	152340	1	2
-	221	152400	1	42 -- Rare Dragon Garnet
-	222	152410	1	140
-	223	152420	1	47
-	224	152430	1	2
-	225	152440	1	2
-	226	153000	1	324 -- Antique Dragon Garnet
-	227	153010	1	1080
-	228	153020	1	360
-	229	153030	1	18
-	230	153040	1	18
-	231	153100	1	1080 -- Antique Dragon Garnet
-	232	153110	1	3600
-	233	153120	1	1200
-	234	153130	1	60
-	235	153140	1	60
-	236	153200	1	360 -- Antique Dragon Garnet
-	237	153210	1	1200
-	238	153220	1	400
-	239	153230	1	20
-	240	153240	1	20
-	241	153300	1	18 -- Antique Dragon Garnet
-	242	153310	1	60
-	243	153320	1	20
-	244	153330	1	1
-	245	153340	1	1
-	246	153400	1	18 -- Antique Dragon Garnet
-	247	153410	1	60
-	248	153420	1	20
-	249	153430	1	1
-	250	153440	1	1
-	251	162000	1	756 -- Rare Dragon Onyx
-	252	162010	1	2520
-	253	162020	1	840
-	254	162030	1	42
-	255	162040	1	42
-	256	162100	1	2520 -- Rare Dragon Onyx
-	257	162110	1	8400
-	258	162120	1	2800
-	259	162130	1	140
-	260	162140	1	140
-	261	162200	1	840 -- Rare Dragon Onyx
-	262	162210	1	2800
-	263	162220	1	933
-	264	162230	1	47
-	265	162240	1	47
-	266	162300	1	42 -- Rare Dragon Onyx
-	267	162310	1	140
-	268	162320	1	47
-	269	162330	1	2
-	270	162340	1	2
-	271	162400	1	42 -- Rare Dragon Onyx
-	272	162410	1	140
-	273	162420	1	47
-	274	162430	1	2
-	275	162440	1	2
-	276	163000	1	324 -- Antique Dragon Onyx
-	277	163010	1	1080
-	278	163020	1	360
-	279	163030	1	18
-	280	163040	1	18
-	281	163100	1	1080 -- Antique Dragon Onyx
-	282	163110	1	3600
-	283	163120	1	1200
-	284	163130	1	60
-	285	163140	1	60
-	286	163200	1	360 -- Antique Dragon Onyx
-	287	163210	1	1200
-	288	163220	1	400
-	289	163230	1	20
-	290	163240	1	20
-	291	163300	1	18 -- Antique Dragon Onyx
-	292	163310	1	60
-	293	163320	1	20
-	294	163330	1	1
-	295	163340	1	1
-	296	163400	1	18 -- Antique Dragon Onyx
-	297	163410	1	60
-	298	163420	1	20
-	299	163430	1	1
-	300	163440	1	1
-}
-Group	백룡강력한용혼원석_희귀-고대
-{
-	Vnum	51626 -- Cor Diamas+ (Epic)
-	1	112000	1	756 -- Rare Dragon Diamond
-	2	112010	1	2520
-	3	112020	1	840
-	4	112030	1	42
-	5	112040	1	42
-	6	112100	1	2520 -- Rare Dragon Diamond
-	7	112110	1	8400
-	8	112120	1	2800
-	9	112130	1	140
-	10	112140	1	140
-	11	112200	1	840 -- Rare Dragon Diamond
-	12	112210	1	2800
-	13	112220	1	933
-	14	112230	1	47
-	15	112240	1	47
-	16	112300	1	42 -- Rare Dragon Diamond
-	17	112310	1	140
-	18	112320	1	47
-	19	112330	1	2
-	20	112340	1	2
-	21	112400	1	42 -- Rare Dragon Diamond
-	22	112410	1	140
-	23	112420	1	47
-	24	112430	1	2
-	25	112440	1	2
-	26	113000	1	324 -- Antique Dragon Diamond
-	27	113010	1	1080
-	28	113020	1	360
-	29	113030	1	18
-	30	113040	1	18
-	31	113100	1	1080 -- Antique Dragon Diamond
-	32	113110	1	3600
-	33	113120	1	1200
-	34	113130	1	60
-	35	113140	1	60
-	36	113200	1	360 -- Antique Dragon Diamond
-	37	113210	1	1200
-	38	113220	1	400
-	39	113230	1	20
-	40	113240	1	20
-	41	113300	1	18 -- Antique Dragon Diamond
-	42	113310	1	60
-	43	113320	1	20
-	44	113330	1	1
-	45	113340	1	1
-	46	113400	1	18 -- Antique Dragon Diamond
-	47	113410	1	60
-	48	113420	1	20
-	49	113430	1	1
-	50	113440	1	1
-}
-Group	적룡강력한용혼원석_희귀-고대
-{
-	Vnum	51627 -- Cor Rubinum+ (Epic)
-	1	122000	1	756 -- Rare Dragon Ruby
-	2	122010	1	2520
-	3	122020	1	840
-	4	122030	1	42
-	5	122040	1	42
-	6	122100	1	2520 -- Rare Dragon Ruby
-	7	122110	1	8400
-	8	122120	1	2800
-	9	122130	1	140
-	10	122140	1	140
-	11	122200	1	840 -- Rare Dragon Ruby
-	12	122210	1	2800
-	13	122220	1	933
-	14	122230	1	47
-	15	122240	1	47
-	16	122300	1	42 -- Rare Dragon Ruby
-	17	122310	1	140
-	18	122320	1	47
-	19	122330	1	2
-	20	122340	1	2
-	21	122400	1	42 -- Rare Dragon Ruby
-	22	122410	1	140
-	23	122420	1	47
-	24	122430	1	2
-	25	122440	1	2
-	26	123000	1	324 -- Antique Dragon Ruby
-	27	123010	1	1080
-	28	123020	1	360
-	29	123030	1	18
-	30	123040	1	18
-	31	123100	1	1080 -- Antique Dragon Ruby
-	32	123110	1	3600
-	33	123120	1	1200
-	34	123130	1	60
-	35	123140	1	60
-	36	123200	1	360 -- Antique Dragon Ruby
-	37	123210	1	1200
-	38	123220	1	400
-	39	123230	1	20
-	40	123240	1	20
-	41	123300	1	18 -- Antique Dragon Ruby
-	42	123310	1	60
-	43	123320	1	20
-	44	123330	1	1
-	45	123340	1	1
-	46	123400	1	18 -- Antique Dragon Ruby
-	47	123410	1	60
-	48	123420	1	20
-	49	123430	1	1
-	50	123440	1	1
-}
-Group	풍룡강력한용혼원석_희귀-고대
-{
-	Vnum	51628 -- Cor Jadeit+ (Epic)
-	1	132000	1	756 -- Rare Dragon Jade
-	2	132010	1	2520
-	3	132020	1	840
-	4	132030	1	42
-	5	132040	1	42
-	6	132100	1	2520 -- Rare Dragon Jade
-	7	132110	1	8400
-	8	132120	1	2800
-	9	132130	1	140
-	10	132140	1	140
-	11	132200	1	840 -- Rare Dragon Jade
-	12	132210	1	2800
-	13	132220	1	933
-	14	132230	1	47
-	15	132240	1	47
-	16	132300	1	42 -- Rare Dragon Jade
-	17	132310	1	140
-	18	132320	1	47
-	19	132330	1	2
-	20	132340	1	2
-	21	132400	1	42 -- Rare Dragon Jade
-	22	132410	1	140
-	23	132420	1	47
-	24	132430	1	2
-	25	132440	1	2
-	26	133000	1	324 -- Antique Dragon Jade
-	27	133010	1	1080
-	28	133020	1	360
-	29	133030	1	18
-	30	133040	1	18
-	31	133100	1	1080 -- Antique Dragon Jade
-	32	133110	1	3600
-	33	133120	1	1200
-	34	133130	1	60
-	35	133140	1	60
-	36	133200	1	360 -- Antique Dragon Jade
-	37	133210	1	1200
-	38	133220	1	400
-	39	133230	1	20
-	40	133240	1	20
-	41	133300	1	18 -- Antique Dragon Jade
-	42	133310	1	60
-	43	133320	1	20
-	44	133330	1	1
-	45	133340	1	1
-	46	133400	1	18 -- Antique Dragon Jade
-	47	133410	1	60
-	48	133420	1	20
-	49	133430	1	1
-	50	133440	1	1
-}
-Group	철룡강력한용혼원석_희귀-고대
-{
-	Vnum	51629 -- Cor Saphirum+ (Epic)
-	1	142000	1	756 -- Rare Dragon Sapphire
-	2	142010	1	2520
-	3	142020	1	840
-	4	142030	1	42
-	5	142040	1	42
-	6	142100	1	2520 -- Rare Dragon Sapphire
-	7	142110	1	8400
-	8	142120	1	2800
-	9	142130	1	140
-	10	142140	1	140
-	11	142200	1	840 -- Rare Dragon Sapphire
-	12	142210	1	2800
-	13	142220	1	933
-	14	142230	1	47
-	15	142240	1	47
-	16	142300	1	42 -- Rare Dragon Sapphire
-	17	142310	1	140
-	18	142320	1	47
-	19	142330	1	2
-	20	142340	1	2
-	21	142400	1	42 -- Rare Dragon Sapphire
-	22	142410	1	140
-	23	142420	1	47
-	24	142430	1	2
-	25	142440	1	2
-	26	143000	1	324 -- Antique Dragon Sapphire
-	27	143010	1	1080
-	28	143020	1	360
-	29	143030	1	18
-	30	143040	1	18
-	31	143100	1	1080 -- Antique Dragon Sapphire
-	32	143110	1	3600
-	33	143120	1	1200
-	34	143130	1	60
-	35	143140	1	60
-	36	143200	1	360 -- Antique Dragon Sapphire
-	37	143210	1	1200
-	38	143220	1	400
-	39	143230	1	20
-	40	143240	1	20
-	41	143300	1	18 -- Antique Dragon Sapphire
-	42	143310	1	60
-	43	143320	1	20
-	44	143330	1	1
-	45	143340	1	1
-	46	143400	1	18 -- Antique Dragon Sapphire
-	47	143410	1	60
-	48	143420	1	20
-	49	143430	1	1
-	50	143440	1	1
-}
-Group	뇌룡강력한용혼원석_희귀-고대
-{
-	Vnum	51630 -- Cor Granatum+ (Epic)
-	1	152000	1	756 -- Rare Dragon Garnet
-	2	152010	1	2520
-	3	152020	1	840
-	4	152030	1	42
-	5	152040	1	42
-	6	152100	1	2520 -- Rare Dragon Garnet
-	7	152110	1	8400
-	8	152120	1	2800
-	9	152130	1	140
-	10	152140	1	140
-	11	152200	1	840 -- Rare Dragon Garnet
-	12	152210	1	2800
-	13	152220	1	933
-	14	152230	1	47
-	15	152240	1	47
-	16	152300	1	42 -- Rare Dragon Garnet
-	17	152310	1	140
-	18	152320	1	47
-	19	152330	1	2
-	20	152340	1	2
-	21	152400	1	42 -- Rare Dragon Garnet
-	22	152410	1	140
-	23	152420	1	47
-	24	152430	1	2
-	25	152440	1	2
-	26	153000	1	324 -- Antique Dragon Garnet
-	27	153010	1	1080
-	28	153020	1	360
-	29	153030	1	18
-	30	153040	1	18
-	31	153100	1	1080 -- Antique Dragon Garnet
-	32	153110	1	3600
-	33	153120	1	1200
-	34	153130	1	60
-	35	153140	1	60
-	36	153200	1	360 -- Antique Dragon Garnet
-	37	153210	1	1200
-	38	153220	1	400
-	39	153230	1	20
-	40	153240	1	20
-	41	153300	1	18 -- Antique Dragon Garnet
-	42	153310	1	60
-	43	153320	1	20
-	44	153330	1	1
-	45	153340	1	1
-	46	153400	1	18 -- Antique Dragon Garnet
-	47	153410	1	60
-	48	153420	1	20
-	49	153430	1	1
-	50	153440	1	1
-}
-Group	흑룡강력한용혼원석_희귀-고대
-{
-	Vnum	51631 -- Cor Atrum+ (Epic)
-	1	162000	1	756 -- Rare Dragon Onyx
-	2	162010	1	2520
-	3	162020	1	840
-	4	162030	1	42
-	5	162040	1	42
-	6	162100	1	2520 -- Rare Dragon Onyx
-	7	162110	1	8400
-	8	162120	1	2800
-	9	162130	1	140
-	10	162140	1	140
-	11	162200	1	840 -- Rare Dragon Onyx
-	12	162210	1	2800
-	13	162220	1	933
-	14	162230	1	47
-	15	162240	1	47
-	16	162300	1	42 -- Rare Dragon Onyx
-	17	162310	1	140
-	18	162320	1	47
-	19	162330	1	2
-	20	162340	1	2
-	21	162400	1	42 -- Rare Dragon Onyx
-	22	162410	1	140
-	23	162420	1	47
-	24	162430	1	2
-	25	162440	1	2
-	26	163000	1	324 -- Antique Dragon Onyx
-	27	163010	1	1080
-	28	163020	1	360
-	29	163030	1	18
-	30	163040	1	18
-	31	163100	1	1080 -- Antique Dragon Onyx
-	32	163110	1	3600
-	33	163120	1	1200
-	34	163130	1	60
-	35	163140	1	60
-	36	163200	1	360 -- Antique Dragon Onyx
-	37	163210	1	1200
-	38	163220	1	400
-	39	163230	1	20
-	40	163240	1	20
-	41	163300	1	18 -- Antique Dragon Onyx
-	42	163310	1	60
-	43	163320	1	20
-	44	163330	1	1
-	45	163340	1	1
-	46	163400	1	18 -- Antique Dragon Onyx
-	47	163410	1	60
-	48	163420	1	20
-	49	163430	1	1
-	50	163440	1	1
-}
-Group	강력한용혼원석_희귀-전설
-{
-	Vnum	51632 -- Cor Draconis+ (Divine)
-	1	112000	1	972 -- Rare Dragon Diamond
-	2	112010	1	3240
-	3	112020	1	1080
-	4	112030	1	54
-	5	112040	1	54
-	6	112100	1	3240 -- Rare Dragon Diamond
-	7	112110	1	10800
-	8	112120	1	3600
-	9	112130	1	180
-	10	112140	1	180
-	11	112200	1	1080 -- Rare Dragon Diamond
-	12	112210	1	3600
-	13	112220	1	1200
-	14	112230	1	60
-	15	112240	1	60
-	16	112300	1	54 -- Rare Dragon Diamond
-	17	112310	1	180
-	18	112320	1	60
-	19	112330	1	3
-	20	112340	1	3
-	21	112400	1	54 -- Rare Dragon Diamond
-	22	112410	1	180
-	23	112420	1	60
-	24	112430	1	3
-	25	112440	1	3
-	26	113000	1	1944 -- Antique Dragon Diamond
-	27	113010	1	6480
-	28	113020	1	2160
-	29	113030	1	108
-	30	113040	1	108
-	31	113100	1	6480 -- Antique Dragon Diamond
-	32	113110	1	21600
-	33	113120	1	7200
-	34	113130	1	360
-	35	113140	1	360
-	36	113200	1	2160 -- Antique Dragon Diamond
-	37	113210	1	7200
-	38	113220	1	2400
-	39	113230	1	120
-	40	113240	1	120
-	41	113300	1	108 -- Antique Dragon Diamond
-	42	113310	1	360
-	43	113320	1	120
-	44	113330	1	6
-	45	113340	1	6
-	46	113400	1	108 -- Antique Dragon Diamond
-	47	113410	1	360
-	48	113420	1	120
-	49	113430	1	6
-	50	113440	1	6
-	51	114000	1	324 -- Legendary Dragon Diamond
-	52	114010	1	1080
-	53	114020	1	360
-	54	114030	1	18
-	55	114040	1	18
-	56	114100	1	1080 -- Legendary Dragon Diamond
-	57	114110	1	3600
-	58	114120	1	1200
-	59	114130	1	60
-	60	114140	1	60
-	61	114200	1	360 -- Legendary Dragon Diamond
-	62	114210	1	1200
-	63	114220	1	400
-	64	114230	1	20
-	65	114240	1	20
-	66	114300	1	18 -- Legendary Dragon Diamond
-	67	114310	1	60
-	68	114320	1	20
-	69	114330	1	1
-	70	114340	1	1
-	71	114400	1	18 -- Legendary Dragon Diamond
-	72	114410	1	60
-	73	114420	1	20
-	74	114430	1	1
-	75	114440	1	1
-	76	122000	1	972 -- Rare Dragon Ruby
-	77	122010	1	3240
-	78	122020	1	1080
-	79	122030	1	54
-	80	122040	1	54
-	81	122100	1	3240 -- Rare Dragon Ruby
-	82	122110	1	10800
-	83	122120	1	3600
-	84	122130	1	180
-	85	122140	1	180
-	86	122200	1	1080 -- Rare Dragon Ruby
-	87	122210	1	3600
-	88	122220	1	1200
-	89	122230	1	60
-	90	122240	1	60
-	91	122300	1	54 -- Rare Dragon Ruby
-	92	122310	1	180
-	93	122320	1	60
-	94	122330	1	3
-	95	122340	1	3
-	96	122400	1	54 -- Rare Dragon Ruby
-	97	122410	1	180
-	98	122420	1	60
-	99	122430	1	3
-	100	122440	1	3
-	101	123000	1	1944 -- Antique Dragon Ruby
-	102	123010	1	6480
-	103	123020	1	2160
-	104	123030	1	108
-	105	123040	1	108
-	106	123100	1	6480 -- Antique Dragon Ruby
-	107	123110	1	21600
-	108	123120	1	7200
-	109	123130	1	360
-	110	123140	1	360
-	111	123200	1	2160 -- Antique Dragon Ruby
-	112	123210	1	7200
-	113	123220	1	2400
-	114	123230	1	120
-	115	123240	1	120
-	116	123300	1	108 -- Antique Dragon Ruby
-	117	123310	1	360
-	118	123320	1	120
-	119	123330	1	6
-	120	123340	1	6
-	121	123400	1	108 -- Antique Dragon Ruby
-	122	123410	1	360
-	123	123420	1	120
-	124	123430	1	6
-	125	123440	1	6
-	126	124000	1	324 -- Legendary Dragon Ruby
-	127	124010	1	1080
-	128	124020	1	360
-	129	124030	1	18
-	130	124040	1	18
-	131	124100	1	1080 -- Legendary Dragon Ruby
-	132	124110	1	3600
-	133	124120	1	1200
-	134	124130	1	60
-	135	124140	1	60
-	136	124200	1	360 -- Legendary Dragon Ruby
-	137	124210	1	1200
-	138	124220	1	400
-	139	124230	1	20
-	140	124240	1	20
-	141	124300	1	18 -- Legendary Dragon Ruby
-	142	124310	1	60
-	143	124320	1	20
-	144	124330	1	1
-	145	124340	1	1
-	146	124400	1	18 -- Legendary Dragon Ruby
-	147	124410	1	60
-	148	124420	1	20
-	149	124430	1	1
-	150	124440	1	1
-	151	132000	1	972 -- Rare Dragon Jade
-	152	132010	1	3240
-	153	132020	1	1080
-	154	132030	1	54
-	155	132040	1	54
-	156	132100	1	3240 -- Rare Dragon Jade
-	157	132110	1	10800
-	158	132120	1	3600
-	159	132130	1	180
-	160	132140	1	180
-	161	132200	1	1080 -- Rare Dragon Jade
-	162	132210	1	3600
-	163	132220	1	1200
-	164	132230	1	60
-	165	132240	1	60
-	166	132300	1	54 -- Rare Dragon Jade
-	167	132310	1	180
-	168	132320	1	60
-	169	132330	1	3
-	170	132340	1	3
-	171	132400	1	54 -- Rare Dragon Jade
-	172	132410	1	180
-	173	132420	1	60
-	174	132430	1	3
-	175	132440	1	3
-	176	133000	1	1944 -- Antique Dragon Jade
-	177	133010	1	6480
-	178	133020	1	2160
-	179	133030	1	108
-	180	133040	1	108
-	181	133100	1	6480 -- Antique Dragon Jade
-	182	133110	1	21600
-	183	133120	1	7200
-	184	133130	1	360
-	185	133140	1	360
-	186	133200	1	2160 -- Antique Dragon Jade
-	187	133210	1	7200
-	188	133220	1	2400
-	189	133230	1	120
-	190	133240	1	120
-	191	133300	1	108 -- Antique Dragon Jade
-	192	133310	1	360
-	193	133320	1	120
-	194	133330	1	6
-	195	133340	1	6
-	196	133400	1	108 -- Antique Dragon Jade
-	197	133410	1	360
-	198	133420	1	120
-	199	133430	1	6
-	200	133440	1	6
-	201	134000	1	324 -- Legendary Dragon Jade
-	202	134010	1	1080
-	203	134020	1	360
-	204	134030	1	18
-	205	134040	1	18
-	206	134100	1	1080 -- Legendary Dragon Jade
-	207	134110	1	3600
-	208	134120	1	1200
-	209	134130	1	60
-	210	134140	1	60
-	211	134200	1	360 -- Legendary Dragon Jade
-	212	134210	1	1200
-	213	134220	1	400
-	214	134230	1	20
-	215	134240	1	20
-	216	134300	1	18 -- Legendary Dragon Jade
-	217	134310	1	60
-	218	134320	1	20
-	219	134330	1	1
-	220	134340	1	1
-	221	134400	1	18 -- Legendary Dragon Jade
-	222	134410	1	60
-	223	134420	1	20
-	224	134430	1	1
-	225	134440	1	1
-	226	142000	1	972 -- Rare Dragon Sapphire
-	227	142010	1	3240
-	228	142020	1	1080
-	229	142030	1	54
-	230	142040	1	54
-	231	142100	1	3240 -- Rare Dragon Sapphire
-	232	142110	1	10800
-	233	142120	1	3600
-	234	142130	1	180
-	235	142140	1	180
-	236	142200	1	1080 -- Rare Dragon Sapphire
-	237	142210	1	3600
-	238	142220	1	1200
-	239	142230	1	60
-	240	142240	1	60
-	241	142300	1	54 -- Rare Dragon Sapphire
-	242	142310	1	180
-	243	142320	1	60
-	244	142330	1	3
-	245	142340	1	3
-	246	142400	1	54 -- Rare Dragon Sapphire
-	247	142410	1	180
-	248	142420	1	60
-	249	142430	1	3
-	250	142440	1	3
-	251	143000	1	1944 -- Antique Dragon Sapphire
-	252	143010	1	6480
-	253	143020	1	2160
-	254	143030	1	108
-	255	143040	1	108
-	256	143100	1	6480 -- Antique Dragon Sapphire
-	257	143110	1	21600
-	258	143120	1	7200
-	259	143130	1	360
-	260	143140	1	360
-	261	143200	1	2160 -- Antique Dragon Sapphire
-	262	143210	1	7200
-	263	143220	1	2400
-	264	143230	1	120
-	265	143240	1	120
-	266	143300	1	108 -- Antique Dragon Sapphire
-	267	143310	1	360
-	268	143320	1	120
-	269	143330	1	6
-	270	143340	1	6
-	271	143400	1	108 -- Antique Dragon Sapphire
-	272	143410	1	360
-	273	143420	1	120
-	274	143430	1	6
-	275	143440	1	6
-	276	144000	1	324 -- Legendary DragonSapphire
-	277	144010	1	1080
-	278	144020	1	360
-	279	144030	1	18
-	280	144040	1	18
-	281	144100	1	1080 -- Legendary DragonSapphire
-	282	144110	1	3600
-	283	144120	1	1200
-	284	144130	1	60
-	285	144140	1	60
-	286	144200	1	360 -- Legendary DragonSapphire
-	287	144210	1	1200
-	288	144220	1	400
-	289	144230	1	20
-	290	144240	1	20
-	291	144300	1	18 -- Legendary DragonSapphire
-	292	144310	1	60
-	293	144320	1	20
-	294	144330	1	1
-	295	144340	1	1
-	296	144400	1	18 -- Legendary DragonSapphire
-	297	144410	1	60
-	298	144420	1	20
-	299	144430	1	1
-	300	144440	1	1
-	301	152000	1	972 -- Rare Dragon Garnet
-	302	152010	1	3240
-	303	152020	1	1080
-	304	152030	1	54
-	305	152040	1	54
-	306	152100	1	3240 -- Rare Dragon Garnet
-	307	152110	1	10800
-	308	152120	1	3600
-	309	152130	1	180
-	310	152140	1	180
-	311	152200	1	1080 -- Rare Dragon Garnet
-	312	152210	1	3600
-	313	152220	1	1200
-	314	152230	1	60
-	315	152240	1	60
-	316	152300	1	54 -- Rare Dragon Garnet
-	317	152310	1	180
-	318	152320	1	60
-	319	152330	1	3
-	320	152340	1	3
-	321	152400	1	54 -- Rare Dragon Garnet
-	322	152410	1	180
-	323	152420	1	60
-	324	152430	1	3
-	325	152440	1	3
-	326	153000	1	1944 -- Antique Dragon Garnet
-	327	153010	1	6480
-	328	153020	1	2160
-	329	153030	1	108
-	330	153040	1	108
-	331	153100	1	6480 -- Antique Dragon Garnet
-	332	153110	1	21600
-	333	153120	1	7200
-	334	153130	1	360
-	335	153140	1	360
-	336	153200	1	2160 -- Antique Dragon Garnet
-	337	153210	1	7200
-	338	153220	1	2400
-	339	153230	1	120
-	340	153240	1	120
-	341	153300	1	108 -- Antique Dragon Garnet
-	342	153310	1	360
-	343	153320	1	120
-	344	153330	1	6
-	345	153340	1	6
-	346	153400	1	108 -- Antique Dragon Garnet
-	347	153410	1	360
-	348	153420	1	120
-	349	153430	1	6
-	350	153440	1	6
-	351	154000	1	324 -- Legendary Dragon Garnet
-	352	154010	1	1080
-	353	154020	1	360
-	354	154030	1	18
-	355	154040	1	18
-	356	154100	1	1080 -- Legendary Dragon Garnet
-	357	154110	1	3600
-	358	154120	1	1200
-	359	154130	1	60
-	360	154140	1	60
-	361	154200	1	360 -- Legendary Dragon Garnet
-	362	154210	1	1200
-	363	154220	1	400
-	364	154230	1	20
-	365	154240	1	20
-	366	154300	1	18 -- Legendary Dragon Garnet
-	367	154310	1	60
-	368	154320	1	20
-	369	154330	1	1
-	370	154340	1	1
-	371	154400	1	18 -- Legendary Dragon Garnet
-	372	154410	1	60
-	373	154420	1	20
-	374	154430	1	1
-	375	154440	1	1
-	376	162000	1	972 -- Rare Dragon Onyx
-	377	162010	1	3240
-	378	162020	1	1080
-	379	162030	1	54
-	380	162040	1	54
-	381	162100	1	3240 -- Rare Dragon Onyx
-	382	162110	1	10800
-	383	162120	1	3600
-	384	162130	1	180
-	385	162140	1	180
-	386	162200	1	1080 -- Rare Dragon Onyx
-	387	162210	1	3600
-	388	162220	1	1200
-	389	162230	1	60
-	390	162240	1	60
-	391	162300	1	54 -- Rare Dragon Onyx
-	392	162310	1	180
-	393	162320	1	60
-	394	162330	1	3
-	395	162340	1	3
-	396	162400	1	54 -- Rare Dragon Onyx
-	397	162410	1	180
-	398	162420	1	60
-	399	162430	1	3
-	400	162440	1	3
-	401	163000	1	1944 -- Antique Dragon Onyx
-	402	163010	1	6480
-	403	163020	1	2160
-	404	163030	1	108
-	405	163040	1	108
-	406	163100	1	6480 -- Antique Dragon Onyx
-	407	163110	1	21600
-	408	163120	1	7200
-	409	163130	1	360
-	410	163140	1	360
-	411	163200	1	2160 -- Antique Dragon Onyx
-	412	163210	1	7200
-	413	163220	1	2400
-	414	163230	1	120
-	415	163240	1	120
-	416	163300	1	108 -- Antique Dragon Onyx
-	417	163310	1	360
-	418	163320	1	120
-	419	163330	1	6
-	420	163340	1	6
-	421	163400	1	108 -- Antique Dragon Onyx
-	422	163410	1	360
-	423	163420	1	120
-	424	163430	1	6
-	425	163440	1	6
-	426	164000	1	324 -- Legendary Dragon Onyx
-	427	164010	1	1080
-	428	164020	1	360
-	429	164030	1	18
-	430	164040	1	18
-	431	164100	1	1080 -- Legendary Dragon Onyx
-	432	164110	1	3600
-	433	164120	1	1200
-	434	164130	1	60
-	435	164140	1	60
-	436	164200	1	360 -- Legendary Dragon Onyx
-	437	164210	1	1200
-	438	164220	1	400
-	439	164230	1	20
-	440	164240	1	20
-	441	164300	1	18 -- Legendary Dragon Onyx
-	442	164310	1	60
-	443	164320	1	20
-	444	164330	1	1
-	445	164340	1	1
-	446	164400	1	18 -- Legendary Dragon Onyx
-	447	164410	1	60
-	448	164420	1	20
-	449	164430	1	1
-	450	164440	1	1
-}
-Group	백룡강력한용혼원석_희귀-전설
-{
-	Vnum	51633 -- Cor Diamas+ (Divine)
-	1	112000	1	972 -- Rare Dragon Diamond
-	2	112010	1	3240
-	3	112020	1	1080
-	4	112030	1	54
-	5	112040	1	54
-	6	112100	1	3240 -- Rare Dragon Diamond
-	7	112110	1	10800
-	8	112120	1	3600
-	9	112130	1	180
-	10	112140	1	180
-	11	112200	1	1080 -- Rare Dragon Diamond
-	12	112210	1	3600
-	13	112220	1	1200
-	14	112230	1	60
-	15	112240	1	60
-	16	112300	1	54 -- Rare Dragon Diamond
-	17	112310	1	180
-	18	112320	1	60
-	19	112330	1	3
-	20	112340	1	3
-	21	112400	1	54 -- Rare Dragon Diamond
-	22	112410	1	180
-	23	112420	1	60
-	24	112430	1	3
-	25	112440	1	3
-	26	113000	1	1944 -- Antique Dragon Diamond
-	27	113010	1	6480
-	28	113020	1	2160
-	29	113030	1	108
-	30	113040	1	108
-	31	113100	1	6480 -- Antique Dragon Diamond
-	32	113110	1	21600
-	33	113120	1	7200
-	34	113130	1	360
-	35	113140	1	360
-	36	113200	1	2160 -- Antique Dragon Diamond
-	37	113210	1	7200
-	38	113220	1	2400
-	39	113230	1	120
-	40	113240	1	120
-	41	113300	1	108 -- Antique Dragon Diamond
-	42	113310	1	360
-	43	113320	1	120
-	44	113330	1	6
-	45	113340	1	6
-	46	113400	1	108 -- Antique Dragon Diamond
-	47	113410	1	360
-	48	113420	1	120
-	49	113430	1	6
-	50	113440	1	6
-	51	114000	1	324 -- Legendary Dragon Diamond
-	52	114010	1	1080
-	53	114020	1	360
-	54	114030	1	18
-	55	114040	1	18
-	56	114100	1	1080 -- Legendary Dragon Diamond
-	57	114110	1	3600
-	58	114120	1	1200
-	59	114130	1	60
-	60	114140	1	60
-	61	114200	1	360 -- Legendary Dragon Diamond
-	62	114210	1	1200
-	63	114220	1	400
-	64	114230	1	20
-	65	114240	1	20
-	66	114300	1	18 -- Legendary Dragon Diamond
-	67	114310	1	60
-	68	114320	1	20
-	69	114330	1	1
-	70	114340	1	1
-	71	114400	1	18 -- Legendary Dragon Diamond
-	72	114410	1	60
-	73	114420	1	20
-	74	114430	1	1
-	75	114440	1	1
-}
-Group	화룡강력한용혼원석_희귀-전설
-{
-	Vnum	51634 -- Cor Rubinum+ (Divine)
-	1	122000	1	972 -- Rare Dragon Ruby
-	2	122010	1	3240
-	3	122020	1	1080
-	4	122030	1	54
-	5	122040	1	54
-	6	122100	1	3240 -- Rare Dragon Ruby
-	7	122110	1	10800
-	8	122120	1	3600
-	9	122130	1	180
-	10	122140	1	180
-	11	122200	1	1080 -- Rare Dragon Ruby
-	12	122210	1	3600
-	13	122220	1	1200
-	14	122230	1	60
-	15	122240	1	60
-	16	122300	1	54 -- Rare Dragon Ruby
-	17	122310	1	180
-	18	122320	1	60
-	19	122330	1	3
-	20	122340	1	3
-	21	122400	1	54 -- Rare Dragon Ruby
-	22	122410	1	180
-	23	122420	1	60
-	24	122430	1	3
-	25	122440	1	3
-	26	123000	1	1944 -- Antique Dragon Ruby
-	27	123010	1	6480
-	28	123020	1	2160
-	29	123030	1	108
-	30	123040	1	108
-	31	123100	1	6480 -- Antique Dragon Ruby
-	32	123110	1	21600
-	33	123120	1	7200
-	34	123130	1	360
-	35	123140	1	360
-	36	123200	1	2160 -- Antique Dragon Ruby
-	37	123210	1	7200
-	38	123220	1	2400
-	39	123230	1	120
-	40	123240	1	120
-	41	123300	1	108 -- Antique Dragon Ruby
-	42	123310	1	360
-	43	123320	1	120
-	44	123330	1	6
-	45	123340	1	6
-	46	123400	1	108 -- Antique Dragon Ruby
-	47	123410	1	360
-	48	123420	1	120
-	49	123430	1	6
-	50	123440	1	6
-	51	124000	1	324 -- Legendary Dragon Ruby
-	52	124010	1	1080
-	53	124020	1	360
-	54	124030	1	18
-	55	124040	1	18
-	56	124100	1	1080 -- Legendary Dragon Ruby
-	57	124110	1	3600
-	58	124120	1	1200
-	59	124130	1	60
-	60	124140	1	60
-	61	124200	1	360 -- Legendary Dragon Ruby
-	62	124210	1	1200
-	63	124220	1	400
-	64	124230	1	20
-	65	124240	1	20
-	66	124300	1	18 -- Legendary Dragon Ruby
-	67	124310	1	60
-	68	124320	1	20
-	69	124330	1	1
-	70	124340	1	1
-	71	124400	1	18 -- Legendary Dragon Ruby
-	72	124410	1	60
-	73	124420	1	20
-	74	124430	1	1
-	75	124440	1	1
-}
-Group	풍룡강력한용혼원석_희귀-전설
-{
-	Vnum	51635 -- Cor Jadeit+ (Divine)
-	1	132000	1	972 -- Rare Dragon Jade
-	2	132010	1	3240
-	3	132020	1	1080
-	4	132030	1	54
-	5	132040	1	54
-	6	132100	1	3240 -- Rare Dragon Jade
-	7	132110	1	10800
-	8	132120	1	3600
-	9	132130	1	180
-	10	132140	1	180
-	11	132200	1	1080 -- Rare Dragon Jade
-	12	132210	1	3600
-	13	132220	1	1200
-	14	132230	1	60
-	15	132240	1	60
-	16	132300	1	54 -- Rare Dragon Jade
-	17	132310	1	180
-	18	132320	1	60
-	19	132330	1	3
-	20	132340	1	3
-	21	132400	1	54 -- Rare Dragon Jade
-	22	132410	1	180
-	23	132420	1	60
-	24	132430	1	3
-	25	132440	1	3
-	26	133000	1	1944 -- Antique Dragon Jade
-	27	133010	1	6480
-	28	133020	1	2160
-	29	133030	1	108
-	30	133040	1	108
-	31	133100	1	6480 -- Antique Dragon Jade
-	32	133110	1	21600
-	33	133120	1	7200
-	34	133130	1	360
-	35	133140	1	360
-	36	133200	1	2160 -- Antique Dragon Jade
-	37	133210	1	7200
-	38	133220	1	2400
-	39	133230	1	120
-	40	133240	1	120
-	41	133300	1	108 -- Antique Dragon Jade
-	42	133310	1	360
-	43	133320	1	120
-	44	133330	1	6
-	45	133340	1	6
-	46	133400	1	108 -- Antique Dragon Jade
-	47	133410	1	360
-	48	133420	1	120
-	49	133430	1	6
-	50	133440	1	6
-	51	134000	1	324 -- Legendary Dragon Jade
-	52	134010	1	1080
-	53	134020	1	360
-	54	134030	1	18
-	55	134040	1	18
-	56	134100	1	1080 -- Legendary Dragon Jade
-	57	134110	1	3600
-	58	134120	1	1200
-	59	134130	1	60
-	60	134140	1	60
-	61	134200	1	360 -- Legendary Dragon Jade
-	62	134210	1	1200
-	63	134220	1	400
-	64	134230	1	20
-	65	134240	1	20
-	66	134300	1	18 -- Legendary Dragon Jade
-	67	134310	1	60
-	68	134320	1	20
-	69	134330	1	1
-	70	134340	1	1
-	71	134400	1	18 -- Legendary Dragon Jade
-	72	134410	1	60
-	73	134420	1	20
-	74	134430	1	1
-	75	134440	1	1
-}
-Group	철룡강력한용혼원석_희귀-전설
-{
-	Vnum	51636 -- Cor Saphirum+ (Divine)
-	1	142000	1	972 -- Rare Dragon Sapphire
-	2	142010	1	3240
-	3	142020	1	1080
-	4	142030	1	54
-	5	142040	1	54
-	6	142100	1	3240 -- Rare Dragon Sapphire
-	7	142110	1	10800
-	8	142120	1	3600
-	9	142130	1	180
-	10	142140	1	180
-	11	142200	1	1080 -- Rare Dragon Sapphire
-	12	142210	1	3600
-	13	142220	1	1200
-	14	142230	1	60
-	15	142240	1	60
-	16	142300	1	54 -- Rare Dragon Sapphire
-	17	142310	1	180
-	18	142320	1	60
-	19	142330	1	3
-	20	142340	1	3
-	21	142400	1	54 -- Rare Dragon Sapphire
-	22	142410	1	180
-	23	142420	1	60
-	24	142430	1	3
-	25	142440	1	3
-	26	143000	1	1944 -- Antique Dragon Sapphire
-	27	143010	1	6480
-	28	143020	1	2160
-	29	143030	1	108
-	30	143040	1	108
-	31	143100	1	6480 -- Antique Dragon Sapphire
-	32	143110	1	21600
-	33	143120	1	7200
-	34	143130	1	360
-	35	143140	1	360
-	36	143200	1	2160 -- Antique Dragon Sapphire
-	37	143210	1	7200
-	38	143220	1	2400
-	39	143230	1	120
-	40	143240	1	120
-	41	143300	1	108 -- Antique Dragon Sapphire
-	42	143310	1	360
-	43	143320	1	120
-	44	143330	1	6
-	45	143340	1	6
-	46	143400	1	108 -- Antique Dragon Sapphire
-	47	143410	1	360
-	48	143420	1	120
-	49	143430	1	6
-	50	143440	1	6
-	51	144000	1	324 -- Legendary DragonSapphire
-	52	144010	1	1080
-	53	144020	1	360
-	54	144030	1	18
-	55	144040	1	18
-	56	144100	1	1080 -- Legendary DragonSapphire
-	57	144110	1	3600
-	58	144120	1	1200
-	59	144130	1	60
-	60	144140	1	60
-	61	144200	1	360 -- Legendary DragonSapphire
-	62	144210	1	1200
-	63	144220	1	400
-	64	144230	1	20
-	65	144240	1	20
-	66	144300	1	18 -- Legendary DragonSapphire
-	67	144310	1	60
-	68	144320	1	20
-	69	144330	1	1
-	70	144340	1	1
-	71	144400	1	18 -- Legendary DragonSapphire
-	72	144410	1	60
-	73	144420	1	20
-	74	144430	1	1
-	75	144440	1	1
-}
-Group	뇌룡강력한용혼원석_희귀-전설
-{
-	Vnum	51637 -- Cor Granatum+ (Divine)
-	1	152000	1	972 -- Rare Dragon Garnet
-	2	152010	1	3240
-	3	152020	1	1080
-	4	152030	1	54
-	5	152040	1	54
-	6	152100	1	3240 -- Rare Dragon Garnet
-	7	152110	1	10800
-	8	152120	1	3600
-	9	152130	1	180
-	10	152140	1	180
-	11	152200	1	1080 -- Rare Dragon Garnet
-	12	152210	1	3600
-	13	152220	1	1200
-	14	152230	1	60
-	15	152240	1	60
-	16	152300	1	54 -- Rare Dragon Garnet
-	17	152310	1	180
-	18	152320	1	60
-	19	152330	1	3
-	20	152340	1	3
-	21	152400	1	54 -- Rare Dragon Garnet
-	22	152410	1	180
-	23	152420	1	60
-	24	152430	1	3
-	25	152440	1	3
-	26	153000	1	1944 -- Antique Dragon Garnet
-	27	153010	1	6480
-	28	153020	1	2160
-	29	153030	1	108
-	30	153040	1	108
-	31	153100	1	6480 -- Antique Dragon Garnet
-	32	153110	1	21600
-	33	153120	1	7200
-	34	153130	1	360
-	35	153140	1	360
-	36	153200	1	2160 -- Antique Dragon Garnet
-	37	153210	1	7200
-	38	153220	1	2400
-	39	153230	1	120
-	40	153240	1	120
-	41	153300	1	108 -- Antique Dragon Garnet
-	42	153310	1	360
-	43	153320	1	120
-	44	153330	1	6
-	45	153340	1	6
-	46	153400	1	108 -- Antique Dragon Garnet
-	47	153410	1	360
-	48	153420	1	120
-	49	153430	1	6
-	50	153440	1	6
-	51	154000	1	324 -- Legendary Dragon Garnet
-	52	154010	1	1080
-	53	154020	1	360
-	54	154030	1	18
-	55	154040	1	18
-	56	154100	1	1080 -- Legendary Dragon Garnet
-	57	154110	1	3600
-	58	154120	1	1200
-	59	154130	1	60
-	60	154140	1	60
-	61	154200	1	360 -- Legendary Dragon Garnet
-	62	154210	1	1200
-	63	154220	1	400
-	64	154230	1	20
-	65	154240	1	20
-	66	154300	1	18 -- Legendary Dragon Garnet
-	67	154310	1	60
-	68	154320	1	20
-	69	154330	1	1
-	70	154340	1	1
-	71	154400	1	18 -- Legendary Dragon Garnet
-	72	154410	1	60
-	73	154420	1	20
-	74	154430	1	1
-	75	154440	1	1
-}
-Group	흑룡강력한용혼원석_희귀-전설
-{
-	Vnum	51638 -- Cor Atrum+ (Divine)
-	1	162000	1	972 -- Rare Dragon Onyx
-	2	162010	1	3240
-	3	162020	1	1080
-	4	162030	1	54
-	5	162040	1	54
-	6	162100	1	3240 -- Rare Dragon Onyx
-	7	162110	1	10800
-	8	162120	1	3600
-	9	162130	1	180
-	10	162140	1	180
-	11	162200	1	1080 -- Rare Dragon Onyx
-	12	162210	1	3600
-	13	162220	1	1200
-	14	162230	1	60
-	15	162240	1	60
-	16	162300	1	54 -- Rare Dragon Onyx
-	17	162310	1	180
-	18	162320	1	60
-	19	162330	1	3
-	20	162340	1	3
-	21	162400	1	54 -- Rare Dragon Onyx
-	22	162410	1	180
-	23	162420	1	60
-	24	162430	1	3
-	25	162440	1	3
-	26	163000	1	1944 -- Antique Dragon Onyx
-	27	163010	1	6480
-	28	163020	1	2160
-	29	163030	1	108
-	30	163040	1	108
-	31	163100	1	6480 -- Antique Dragon Onyx
-	32	163110	1	21600
-	33	163120	1	7200
-	34	163130	1	360
-	35	163140	1	360
-	36	163200	1	2160 -- Antique Dragon Onyx
-	37	163210	1	7200
-	38	163220	1	2400
-	39	163230	1	120
-	40	163240	1	120
-	41	163300	1	108 -- Antique Dragon Onyx
-	42	163310	1	360
-	43	163320	1	120
-	44	163330	1	6
-	45	163340	1	6
-	46	163400	1	108 -- Antique Dragon Onyx
-	47	163410	1	360
-	48	163420	1	120
-	49	163430	1	6
-	50	163440	1	6
-	51	164000	1	324 -- Legendary Dragon Onyx
-	52	164010	1	1080
-	53	164020	1	360
-	54	164030	1	18
-	55	164040	1	18
-	56	164100	1	1080 -- Legendary Dragon Onyx
-	57	164110	1	3600
-	58	164120	1	1200
-	59	164130	1	60
-	60	164140	1	60
-	61	164200	1	360 -- Legendary Dragon Onyx
-	62	164210	1	1200
-	63	164220	1	400
-	64	164230	1	20
-	65	164240	1	20
-	66	164300	1	18 -- Legendary Dragon Onyx
-	67	164310	1	60
-	68	164320	1	20
-	69	164330	1	1
-	70	164340	1	1
-	71	164400	1	18 -- Legendary Dragon Onyx
-	72	164410	1	60
-	73	164420	1	20
-	74	164430	1	1
-	75	164440	1	1
-}
-Group	빨간색흑단상자
-{
-	Vnum	50109 -- Red Ebony Box
-	1	50300	1	15 -- Skill Book
-	2	70102	1	10 -- Zen Bean
-	3	25040	1	5 -- Blessing Scroll
-	4	71044	5	35 -- Critical Strike
-	5	71045	5	30 -- Piercing Strike
-	6	72003	1	5 -- Experience Ring (3h)
-	7	72006	1	5 -- Thief's Gloves
-}
-Group	주황색흑단상자
-{
-	Vnum	50110 -- Pomp Ebony Box
-	1	50300	1	25 -- Skill Book
-	2	25040	1	10 -- Blessing Scroll
-	3	71032	1	5 -- Dragon Scroll
-	4	70003	1	20 -- Book of the Leader
-	5	72003	1	20 -- Experience Ring (3h)
-	6	72006	1	20 -- Thief's Gloves
-}
-Group	노랑색흑단상자
-{
-	Vnum	50111 -- Yellow Ebony Box
-	1	70048	1	5 -- Cloak of Secrecy
-	2	70049	1	5 -- Lucy's Ring
-	3	70050	1	5 -- Sage King's Symbol
-	4	70051	1	5 -- Sage King's Glove
-	5	70052	1	5 -- Charm of Karma1
-	6	50513	1	10 -- Soul Stone
-	7	50300	1	10 -- Skill Book
-	8	70102	1	10 -- Zen Bean
-	9	25040	1	5 -- Blessing Scroll
-	10	71032	1	5 -- Dragon Scroll
-	11	72003	1	15 -- Experience Ring (3h)
-	12	72006	1	15 -- Thief's Gloves
-}
-Group	연두색흑단상자
-{
-	Vnum	50112 -- Lightgreen Ebony Box
-	1	71085	1	5 -- Reinforce Item
-	2	71084	1	5 -- Enchant Item
-	3	50513	1	10 -- Soul Stone
-	4	70102	1	10 -- Zen Bean
-	5	25040	1	5 -- Blessing Scroll
-	6	71032	1	5 -- Dragon Scroll
-	7	72003	1	30 -- Experience Ring (3h)
-	8	72006	1	30 -- Thief's Gloves
-}
-Group	녹색흑단상자
-{
-	Vnum	50113 -- Green Ebony Box
-	1	71085	1	5 -- Reinforce Item
-	2	71084	1	5 -- Enchant Item
-	3	50513	1	10 -- Soul Stone
-	4	70102	1	10 -- Zen Bean
-	5	25040	1	5 -- Blessing Scroll
-	6	71032	1	5 -- Dragon Scroll
-	7	71044	5	30 -- Critical Strike
-	8	71045	5	30 -- Piercing Strike
-}
-Group	파란색흑단상자
-{
-	Vnum	50114 -- Blue Ebony Box
-	1	71085	1	5 -- Reinforce Item
-	2	71084	1	5 -- Enchant Item
-	3	50513	1	10 -- Soul Stone
-	4	70102	1	10 -- Zen Bean
-	5	25040	1	5 -- Blessing Scroll
-	6	71032	1	5 -- Dragon Scroll
-	7	71044	5	30 -- Critical Strike
-	8	71045	5	30 -- Piercing Strike
-}
-Group	보라색흑단상자
-{
-	Vnum	50115 -- Crimson Ebony Box
-	1	71085	1	5 -- Reinforce Item
-	2	71084	1	5 -- Enchant Item
-	3	50513	1	10 -- Soul Stone
-	4	70102	1	10 -- Zen Bean
-	5	25040	1	5 -- Blessing Scroll
-	6	71032	1	5 -- Dragon Scroll
-	7	71044	5	30 -- Critical Strike
-	8	71045	5	30 -- Piercing Strike
-}
-Group	크리스마스이벤트(양말)
-{
-	Vnum	50010 -- Stocking
-	1	80003	1	8 -- Silver Bar (50,000 Yang)
-	2	돈꾸러미	5000	1 -- Yang
-	3	돈꾸러미	10000	1 -- Yang
-	4	돈꾸러미	15000	1 -- Yang
-	5	돈꾸러미	20000	1 -- Yang
-	6	돈꾸러미	25000	1 -- Yang
-	7	돈꾸러미	30000	1 -- Yang
-	8	돈꾸러미	35000	1 -- Yang
-	9	돈꾸러미	40000	1 -- Yang
-	10	50300	1	8 -- Skill Book
-	11	70201	1	8 -- Bleach
-	12	70206	1	8 -- Black Hair Dye
-	13	70203	1	8 -- Blonde Hair Dye
-	14	70202	1	8 -- White Hair Dye
-	15	70204	1	8 -- Red Hair Dye
-	16	70205	1	8 -- Brown Hair Dye
-	17	70048	1	8 -- Cloak of Secrecy
-	18	70049	1	8 -- Lucy's Ring
-	19	70050	1	8 -- Sage King's Symbol
-	20	70051	1	8 -- Sage King's Glove
-	21	70102	1	8 -- Zen Bean
-	22	71006	1	8 -- Language Ring
-	23	70008	1	8 -- White Flag
-	24	70012	1	8 -- Goddess Tear
-	25	70038	1	8 -- Bravery Cape
-	26	27006	15	8 -- Blue Potion (L)
-	27	27003	15	8 -- Red Potion (L)
-	28	27005	30	8 -- Blue Potion (M)
-	29	27002	30	8 -- Red Potion (M)
-}
-Group	월광보합
-{
-	Vnum	50011 -- Moonlight Treasure Chest
-	1	50311	1	1 -- Shinsoo Linguistics
-	2	50312	1	1 -- Chunjo Linguistics
-	3	50313	1	1 -- Jinno Linguistics
-	4	70048	1	1 -- Cloak of Secrecy
-	5	70102	1	1 -- Zen Bean
-	6	70051	1	1 -- Sage King's Glove
-	7	70049	1	1 -- Lucy's Ring
-	8	70006	1	1 -- Language Ring
-	9	71045	5	1 -- Piercing Strike
-	10	71018	5	1 -- Blessing of Life
-	11	71020	5	1 -- Blessing of the Dragon
-	12	71044	5	1 -- Critical Strike
-	13	25040	1	1 -- Blessing Scroll
-	14	71032	1	1 -- Dragon Scroll
-	15	71004	10	1 -- Medal of the Dragon
-	16	70035	1	1 -- Magic Copper Ore
-	17	70024	1	1 -- Blessing Marble
-	18	group	426	1
-	19	group	8501	1
-	20	group	2209	1
-}
-Group	세뱃돈주머니
-{
-	Vnum	50023 -- Money Pouch
-	1	돈꾸러미	50000	5 -- Yang
-	2	돈꾸러미	40000	10 -- Yang
-	3	돈꾸러미	30000	15 -- Yang
-	4	돈꾸러미	20000	20 -- Yang
-	5	돈꾸러미	10000	50 -- Yang
-}
-Group	장미
-{
-	Vnum	50024 -- Rose
-	1	50300	1	3 -- Skill Book
-	2	70102	1	1 -- Zen Bean
-	3	25040	1	1 -- Blessing Scroll
-	4	80003	1	5 -- Silver Bar (50,000 Yang)
-	5	27003	5	10 -- Red Potion (L)
-	6	27006	5	15 -- Blue Potion (L)
-	7	27002	5	25 -- Red Potion (M)
-	8	27005	5	40 -- Blue Potion (M)
-}
-Group	초콜릿
-{
-	Vnum	50025 -- Chocolate
-	1	50300	1	3 -- Skill Book
-	2	70102	1	1 -- Zen Bean
-	3	25040	1	1 -- Blessing Scroll
-	4	80003	1	5 -- Silver Bar (50,000 Yang)
-	5	27003	5	10 -- Red Potion (L)
-	6	27006	5	15 -- Blue Potion (L)
-	7	27002	5	25 -- Red Potion (M)
-	8	27005	5	40 -- Blue Potion (M)
-}
-Group	장미
-{
-	Vnum	50031 -- Rose
-	1	50300	1	3 -- Skill Book
-	2	70102	1	1 -- Zen Bean
-	3	25040	1	1 -- Blessing Scroll
-	4	80003	1	5 -- Silver Bar (50,000 Yang)
-	5	27003	5	10 -- Red Potion (L)
-	6	27006	5	15 -- Blue Potion (L)
-	7	27002	5	25 -- Red Potion (M)
-	8	27005	5	40 -- Blue Potion (M)
-}
-Group	사탕
-{
-	Vnum	50032 -- Candy
-	1	50300	1	3 -- Skill Book
-	2	70102	1	1 -- Zen Bean
-	3	25040	1	1 -- Blessing Scroll
-	4	80003	1	5 -- Silver Bar (50,000 Yang)
-	5	27003	5	10 -- Red Potion (L)
-	6	27006	5	15 -- Blue Potion (L)
-	7	27002	5	25 -- Red Potion (M)
-	8	27005	5	40 -- Blue Potion (M)
-}
-Group	알수없는상자
-{
-	Vnum	50033 -- Mysterious Chest
-	1	경험치	10000	80 -- Exp.
-	2	경험치	20000	70 -- Exp.
-	3	경험치	30000	60 -- Exp.
-	4	경험치	40000	50 -- Exp.
-	5	경험치	50000	40 -- Exp.
-	6	돈꾸러미	10000	80 -- Yang
-	7	돈꾸러미	20000	70 -- Yang
-	8	돈꾸러미	30000	65 -- Yang
-	9	돈꾸러미	40000	55 -- Yang
-	10	돈꾸러미	50000	49 -- Yang
-	11	50300	1	10 -- Skill Book
-	12	70102	1	20 -- Zen Bean
-	13	25040	1	1 -- Blessing Scroll
-	14	group	8501	30
-	15	group	8502	30
-	16	group	8503	30
-	17	group	8504	30
-	18	group	8505	30
-	19	group	8506	40
-	20	group	8507	40
-	21	group	8508	30
-	22	group	8509	30
-	23	group	8510	30
-	24	group	8511	30
-}
-Group	어린이날선물상자_3
-{
-	Vnum	50035 -- Gift (yellow)
-	1	경험치	30000	100 -- Exp.
-	2	경험치	50000	120 -- Exp.
-	3	경험치	70000	100 -- Exp.
-	4	경험치	100000	80 -- Exp.
-	5	돈꾸러미	30000	160 -- Yang
-	6	돈꾸러미	50000	140 -- Yang
-	7	80004	1	60 -- Silver Bar(100,000 Yang)
-	8	80005	1	5 -- Gold Bar (500,000 Yang)
-	9	50300	1	15 -- Skill Book
-	10	25040	1	10 -- Blessing Scroll
-	11	71032	1	5 -- Dragon Scroll
-	12	71004	10	30 -- Medal of the Dragon
-	13	70003	1	15 -- Book of the Leader
-	14	71018	10	40 -- Blessing of Life
-	15	71019	10	40 -- Blessing of Magic
-	16	71020	10	20 -- Blessing of the Dragon
-	17	50008	1	20 -- Gold Key
-	18	50108	10	30 -- Fireworks Top
-	19	50100	50	50 -- Fire Crackers
-	20	50101	50	50 -- Fire Crackers
-	21	50102	50	50 -- Fire Crackers
-	22	50103	50	50 -- Fire Crackers
-	23	50104	50	51 -- Fire Crackers
-	24	50105	50	51 -- Fire Crackers
-	25	11280	1	3	30 -- Dragon God Armour+0
-	26	11260	1	4	30 -- Scale Plate Armour+0
-	27	11270	1	5	30 -- Gold Plate Armour+0
-	28	11880	1	3	30 -- Baroness Dress+0
-	29	11870	1	4	30 -- Orange Cat Dress+0
-	30	11860	1	5	30 -- Clothing of Morality+0
-	31	11480	1	3	30 -- Fuchsia Suit+0
-	32	11470	1	4	30 -- Killer Wind Suit+0
-	33	11460	1	5	30 -- Young Dragon Suit+0
-	34	11680	1	3	30 -- Spirit Plate Armour+0
-	35	11670	1	4	30 -- Ghost Mask Armour+0
-	36	11660	1	5	30 -- Fog Plate Armour+0
-	37	21060	1	3	30 -- Firellium Plate Armour+0
-	38	21050	1	4	30 -- Hobgoblin Plate Armour+0
-	39	21040	1	5	30 -- Bronze Plate Armour+0
-	40	90010	2	20 -- Foundation Stone
-	41	90011	2	20 -- Trunk
-	42	90012	2	20 -- Plywood
-}
-Group	어린이날선물상자_5
-{
-	Vnum	50036 -- Gift (violet)
-	1	경험치	30000	30 -- Exp.
-	2	경험치	50000	60 -- Exp.
-	3	경험치	70000	50 -- Exp.
-	4	경험치	100000	60 -- Exp.
-	5	돈꾸러미	30000	50 -- Yang
-	6	돈꾸러미	50000	70 -- Yang
-	7	80004	1	70 -- Silver Bar(100,000 Yang)
-	8	80005	1	10 -- Gold Bar (500,000 Yang)
-	9	80006	1	5 -- Gold Bar (1Million Yang)
-	10	50300	1	20 -- Skill Book
-	11	25040	1	20 -- Blessing Scroll
-	12	71032	1	10 -- Dragon Scroll
-	13	71004	10	30 -- Medal of the Dragon
-	14	70003	1	20 -- Book of the Leader
-	15	71018	10	50 -- Blessing of Life
-	16	71019	10	50 -- Blessing of Magic
-	17	71020	10	30 -- Blessing of the Dragon
-	18	50008	1	20 -- Gold Key
-	19	50108	10	20 -- Fireworks Top
-	20	50100	50	15 -- Fire Crackers
-	21	50101	50	15 -- Fire Crackers
-	22	50102	50	15 -- Fire Crackers
-	23	50103	50	15 -- Fire Crackers
-	24	50104	50	15 -- Fire Crackers
-	25	50105	50	15 -- Fire Crackers
-	26	11280	1	3	30 -- Dragon God Armour+0
-	27	11260	1	5	30 -- Scale Plate Armour+0
-	28	11270	1	7	30 -- Gold Plate Armour+0
-	29	11880	1	3	30 -- Baroness Dress+0
-	30	11870	1	5	30 -- Orange Cat Dress+0
-	31	11860	1	7	30 -- Clothing of Morality+0
-	32	11480	1	3	30 -- Fuchsia Suit+0
-	33	11470	1	5	30 -- Killer Wind Suit+0
-	34	11460	1	7	30 -- Young Dragon Suit+0
-	35	11680	1	3	30 -- Spirit Plate Armour+0
-	36	11670	1	5	30 -- Ghost Mask Armour+0
-	37	11660	1	7	30 -- Fog Plate Armour+0
-	38	21060	1	3	30 -- Firellium Plate Armour+0
-	39	21050	1	5	30 -- Hobgoblin Plate Armour+0
-	40	21040	1	7	30 -- Bronze Plate Armour+0
-	41	90010	2	25 -- Foundation Stone
-	42	90011	2	25 -- Trunk
-	43	90012	2	25 -- Plywood
-}
-Group	육각보합
-{
-	Vnum	50037 -- Hexagonal Treasure Chest
-	1	27001	100	100 -- Red Potion (S)
-	2	27002	50	70 -- Red Potion (M)
-	3	27003	10	50 -- Red Potion (L)
-	4	27004	100	75 -- Blue Potion (S)
-	5	27005	50	55 -- Blue Potion (M)
-	6	27006	10	35 -- Blue Potion (L)
-	7	경험치	30000	70 -- Exp.
-	8	경험치	50000	40 -- Exp.
-	9	경험치	70000	20 -- Exp.
-	10	경험치	100000	10 -- Exp.
-	11	70048	1	20 -- Cloak of Secrecy
-	12	70102	1	9 -- Zen Bean
-	13	70051	1	20 -- Sage King's Glove
-	14	70049	1	35 -- Lucy's Ring
-	15	25040	1	1 -- Blessing Scroll
-	16	30045	1	26 -- Scorpion Needle
-	17	30051	1	26 -- Unknown Talisman
-	18	30038	1	26 -- Tiger Hide
-	19	30070	1	26 -- Wolf Fur+
-	20	30023	1	26 -- White Tiger Hide
-	21	30033	1	26 -- Broken Porcelain
-	22	30011	1	26 -- Ball
-	23	30082	1	26 -- Snake Tail+
-	24	30035	1	26 -- Face Cream
-	25	30010	1	26 -- Bear Gall
-	26	30055	1	26 -- Scorpion Claw
-	27	30006	1	26 -- Orc Tooth
-	28	30003	1	26 -- Pig Nose
-	29	30017	1	26 -- Ornamental Hairpin
-}
-Group	football
-{
-	Vnum	50096 -- Football
-	1	50300	1	1 -- Skill Book
-	2	70102	1	1 -- Zen Bean
-	3	25040	1	2 -- Blessing Scroll
-	4	80003	1	6 -- Silver Bar (50,000 Yang)
-	5	27003	5	10 -- Red Potion (L)
-	6	27006	5	15 -- Blue Potion (L)
-	7	27002	5	25 -- Red Potion (M)
-	8	27005	5	25 -- Blue Potion (M)
-}
-Group	ChrysanthemumBox
-{
-	Vnum	83023 -- Chrysanthemum Box
-	1	55408	1	100 -- Fat Mini Executor Egg
-	2	72059	1	100 -- Book of the Leader+
-	3	50255	1	100 -- Cor Draconis (Rough)
-	4	27209	5	100 -- Green Potion (L)
-	5	27212	5	100 -- Purple Potion (L)
-	6	76007	3	100 -- Bravery Cape
-	7	71080	1	100 -- Metin Stone(L)
-	8	71018	1	100 -- Blessing of Life
-	9	25121	1	100 -- Chrysanthemum
-	10	25122	1	100 -- May Bell
-	11	25123	1	100 -- Daffodil
-	12	25124	1	100 -- Lily
-	13	25125	1	100 -- Sunflower
-	14	55400	1	100 -- Mystery Box
-	15	경험치	300000	100 -- Exp.
-	16	돈꾸러미	250000	100 -- Yang
-}
-Group	MayBellBox
-{
-	Vnum	83024 -- May Bell Box
-	1	55408	1	100 -- Fat Mini Executor Egg
-	2	72059	1	100 -- Book of the Leader+
-	3	50255	1	100 -- Cor Draconis (Rough)
-	4	27209	3	100 -- Green Potion (L)
-	5	27212	3	100 -- Purple Potion (L)
-	6	76007	3	100 -- Bravery Cape
-	7	71080	1	100 -- Metin Stone(L)
-	8	76008	1	100 -- Medal of the Dragon
-	9	25121	1	100 -- Chrysanthemum
-	10	25122	1	100 -- May Bell
-	11	25123	1	100 -- Daffodil
-	12	25124	1	100 -- Lily
-	13	25125	1	100 -- Sunflower
-	14	경험치	200000	100 -- Exp.
-	15	돈꾸러미	200000	100 -- Yang
-}
-Group	DaffodilBox
-{
-	Vnum	83025 -- Daffodil Box
-	1	55402	1	100 -- Spider Egg
-	2	72059	1	100 -- Book of the Leader+
-	3	27206	30	100 -- Blue Potion (L)
-	4	27209	3	100 -- Green Potion (L)
-	5	27212	30	100 -- Purple Potion (L)
-	6	76007	3	100 -- Bravery Cape
-	7	71080	1	100 -- Metin Stone(L)
-	8	76000	1	100 -- Peach Flower Wine
-	9	76008	1	100 -- Medal of the Dragon
-	10	25121	1	100 -- Chrysanthemum
-	11	25122	1	100 -- May Bell
-	12	25123	1	100 -- Daffodil
-	13	25124	1	100 -- Lily
-	14	25125	1	100 -- Sunflower
-	15	경험치	150000	100 -- Exp.
-	16	돈꾸러미	150000	100 -- Yang
-}
-Group	LilyBox
-{
-	Vnum	83026 -- Lily Box
-	1	55401	1	100 -- Monkey Egg
-	2	72059	1	100 -- Book of the Leader+
-	3	27206	30	100 -- Blue Potion (L)
-	4	27209	3	100 -- Green Potion (L)
-	5	27212	30	100 -- Purple Potion (L)
-	6	76007	20	100 -- Bravery Cape
-	7	71080	1	100 -- Metin Stone(L)
-	8	76000	2	100 -- Peach Flower Wine
-	9	76008	1	100 -- Medal of the Dragon
-	10	25121	1	100 -- Chrysanthemum
-	11	25122	1	100 -- May Bell
-	12	25123	1	100 -- Daffodil
-	13	25124	1	100 -- Lily
-	14	25125	1	100 -- Sunflower
-	15	경험치	100000	100 -- Exp.
-	16	돈꾸러미	100000	100 -- Yang
-}
-Group	SunflowerBox
-{
-	Vnum	83027 -- Sunflower Box
-	1	55401	1	100 -- Monkey Egg
-	2	72059	1	100 -- Book of the Leader+
-	3	27206	30	100 -- Blue Potion (L)
-	4	27209	3	100 -- Green Potion (L)
-	5	27212	30	100 -- Purple Potion (L)
-	6	76007	20	100 -- Bravery Cape
-	7	71080	1	100 -- Metin Stone(L)
-	8	76000	1	100 -- Peach Flower Wine
-	9	76008	1	100 -- Medal of the Dragon
-	10	25121	1	100 -- Chrysanthemum
-	11	25122	1	100 -- May Bell
-	12	25123	1	100 -- Daffodil
-	13	25124	1	100 -- Lily
-	14	25125	1	100 -- Sunflower
-	15	경험치	50000	100 -- Exp.
-	16	돈꾸러미	50000	100 -- Yang
-}
-Group	TigerMysteryBox
-{
-	Vnum	38050 -- Power Chest
-	1	38051	1	1 -- Royal Tiger Crystal
-	2	71085	1	2 -- Reinforce Item
-	3	70039	1	2 -- Blacksmith Handbook
-	4	71032	1	3 -- Dragon Scroll
-	5	70024	1	3 -- Blessing Marble
-	6	25040	1	5 -- Blessing Scroll
-	7	71094	1	5 -- Concentrated Reading
-	8	27992	1	7 -- White Pearl
-	9	27993	1	8 -- Blue Pearl
-	10	27994	1	8 -- Blood-Red Pearl
-	11	72724	1	9 -- Sun Elixir (M)
-	12	72728	1	9 -- Moon Elixir (M)
-	13	71027	2	11 -- Dragon God Life
-	14	71113	40	11 -- Glass of Insight
-}
-Group	TigerRewardBox
-{
-	Vnum	38051 -- Royal Tiger Crystal
-	1	71137	1	25 -- Royal Tiger (blue)
-	2	71138	1	20 -- Royal Tiger (red)
-	3	71139	1	10 -- Royal Tiger (gold)
-	4	71140	1	15 -- Royal Tiger (green)
-	5	71141	1	25 -- Royal Tiger (grey)
-	6	71142	1	5 -- Royal Tiger (white)
-}
-Group	WhiteLionBox
-{
-	Vnum	38052 -- The Chest of Kings
-	1	71085	1	3 -- Reinforce Item
-	2	70039	1	3 -- Blacksmith Handbook
-	3	71032	1	5 -- Dragon Scroll
-	4	70024	1	5 -- Blessing Marble
-	5	25040	1	8 -- Blessing Scroll
-	6	71012	1	14 -- Book of the Leader
-	7	71130	3	16 -- Passage Ticket
-	8	71083	1	16 -- Stone Handbook
-	9	71004	10	14 -- Medal of the Dragon
-	10	71018	2	14 -- Blessing of Life
-	11	25041	1	1 -- Magic Stone
-	12	71124	1	1 -- White Lion
-}
-Group	WhitePhoenixBox
-{
-	Vnum	38053 -- Eternal Winter Chest
-	1	53503	1	2 -- Ice Phoenix Cage
-	2	72702	1	1 -- Wind Shoes+ (tradeable)
-	3	71085	1	2 -- Reinforce Item
-	4	70039	1	2 -- Blacksmith Handbook
-	5	71032	1	3 -- Dragon Scroll
-	6	70024	1	3 -- Blessing Marble
-	7	30195	1	4 -- Quartz Sand
-	8	71094	1	5 -- Concentrated Reading
-	9	50513	1	6 -- Soul Stone
-	10	27992	1	6 -- White Pearl
-	11	27993	1	7 -- Blue Pearl
-	12	27994	1	8 -- Blood-Red Pearl
-	13	72725	1	8 -- Sun Elixir (L)
-	14	72729	1	8 -- Moon Elixir (L)
-	15	71027	2	10 -- Dragon God Life
-	16	71044	4	10 -- Critical Strike
-	17	71045	4	10 -- Piercing Strike
-}
-Group	X_Mas_Pet
-{
-	Vnum	38055 -- Whelp Box
-	1	71085	1	1 -- Reinforce Item
-	2	70039	1	2 -- Blacksmith Handbook
-	3	71032	1	5 -- Dragon Scroll
-	4	70024	1	5 -- Blessing Marble
-	5	25040	1	11 -- Blessing Scroll
-	6	71012	1	12 -- Book of the Leader
-	7	71130	3	12 -- Passage Ticket
-	8	71083	1	12 -- Stone Handbook
-	9	71004	10	12 -- Medal of the Dragon
-	10	71018	2	12 -- Blessing of Life
-	11	30319	3	10 -- Shrunken Head
-	12	25041	1	1 -- Magic Stone
-	13	53011	1	3 -- Khan
-	14	53012	1	3 -- Porky
-}
-Group	째징쨘챗쨍짰쩔짚횉횄횪쨘쨔쨩처횣
-{
-	Vnum	50182 -- Blessing Chest
-	1	27992	1	5 -- White Pearl
-	2	27993	1	5 -- Blue Pearl
-	3	27994	1	5 -- Blood-Red Pearl
-	4	70039	1	7 -- Blacksmith Handbook
-	5	71001	5	7 -- Exorcism Scroll
-	6	71094	1	7 -- Concentrated Reading
-	7	70057	1	9 -- Bravery Cape
-	8	70003	1	12 -- Book of the Leader
-	9	70024	1	12 -- Blessing Marble
-	10	71085	1	12 -- Reinforce Item
-	11	71084	1	15 -- Enchant Item
-	12	70056	5	20 -- Pomegranate Juice+
-	13	70064	3	5 -- Enchant Costume
-	14	70063	3	5 -- Transform Costume
-	15	71035	5	5 -- Researcher's Elixir
-}
-Group	할로윈호박
-{
-	Vnum	50095 -- Pumpkin
-	1	50300	1	1 -- Skill Book
-	2	70102	1	1 -- Zen Bean
-	3	25040	1	3 -- Blessing Scroll
-	4	80003	1	5 -- Silver Bar (50,000 Yang)
-	5	27003	5	10 -- Red Potion (L)
-	6	27006	5	15 -- Blue Potion (L)
-	7	27002	5	25 -- Red Potion (M)
-	8	27005	5	40 -- Blue Potion (M)
-	9	27001	5	50 -- Red Potion (S)
-	10	27004	5	50 -- Blue Potion (S)
-}
-Group	할로윈호박선물상자
-{
-	Vnum	50215 -- Halloween Chest
-	1	70035	1	1 -- Magic Copper Ore
-	2	71085	1	6 -- Reinforce Item
-	3	70024	1	6 -- Blessing Marble
-	4	71026	1	1 -- Magic Iron Ore
-	5	71084	1	6 -- Enchant Item
-	6	71108	15	10 -- Pomegranate Juice
-	7	70003	1	5 -- Book of the Leader
-	8	72723	1	5 -- Sun Elixir (S)
-	9	72727	1	5 -- Moon Elixir (S)
-	10	71004	5	5 -- Medal of the Dragon
-	11	71094	1	5 -- Concentrated Reading
-	12	70102	1	10 -- Zen Bean
-	13	27992	1	8 -- White Pearl
-	14	27993	1	7 -- Blue Pearl
-	15	27994	1	5 -- Blood-Red Pearl
-	16	30323	1	15 -- Jack O'Lantern Mask Card
-}
-
-
-Group	BronzeYutNoriBundle
-{
-	Vnum	50922 -- Bronze Yut Nori Bundle
-	1	돈꾸러미	50000	40 -- Yang
-	2	돈꾸러미	100000	50 -- Yang
-	3	경험치	100000	60 -- EXP
-	4	79508	1	40 -- Yut Nori Board
-}
-Group	GoldenYutNoriTrophy
-{
-	Vnum	83030 -- Golden Yut Nori Trophy
-	Type	pct
-	1	50920	1	100 -- Golden Yut Nori Bundle
-	2	30639	1	100 -- Mysterious Shard
-}
-Group	SilverYutNoriTrophy
-{
-	Vnum	83031 -- Silver Yut Nori Trophy
-	Type	pct
-	1	50921	1	100 -- Silver Yut Nori Bundle
-	2	30639	1	30 -- Mysterious Shard
-}
-Group	GoldenYutNoriBundle
-{
-	Vnum	50920 -- Golden Yut Nori Bundle
-	1	79508	1	10 -- Yut Nori Board
-	2	39015	1	19 -- Stone of the Blacksmith
-	3	25040	1	33 -- Blessing Scroll
-	4	39001	1	12 -- Magic Stone
-	5	76042	1	18 -- Teleportation Ring
-	6	39029	1	20 -- Reinforce Item
-	7	39028	1	80 -- Enchant Item
-	8	71189	1	32 -- Enchant Item+
-	9	39036	1	7 -- Wind Shoes
-	10	71136	1	6 -- Mighty Lolly
-	11	71228	1	8 -- Lava Cave Lizard
-	12	55403	1	9 -- Razador's Egg
-	13	55404	1	9 -- Nemere's Egg
-	14	71018	10	20 -- Blessing of Life
-	15	51506	1	19 -- Cor Draconis (Mystical)
-	16	51505	1	26 -- Cor Draconis (Precious)
-	17	30616	1	12 -- Titanium Dioxide
-	18	30617	1	9 -- Agate
-	19	30618	1	6 -- Moonstone
-	20	27992	1	23 -- White Pearl
-	21	50926	200	17 -- Glimmerstone
-	22	72058	10	29 -- Spirit Stone Bundle
-	23	53253	1	9 -- Shiver
-	24	50108	10	20 -- Fireworks Top
-	25	50107	10	20 -- Chinese Fire Cracker
-	26	72709	1	4 -- Tiger Bone Earring
-	27	72710	1	4 -- Dragon Bone Earring
-	28	71181	1	8 -- Potion of Wisdom
-	29	170	1	18	100 -- Sting Sword+0
-	30	250	1	18	100 -- Demon Blade+0
-	31	1120	1	18	100 -- Siamese Knife+0
-	32	2180	1	18	100 -- Blue Dragon Bow+0
-	33	3150	1	18	100 -- Soul Stealing Blade+0
-	34	6060	1	18	100 -- Hawk Claw+0
-	35	7150	1	18	100 -- Ecstasy Fan+0
-}
-Group	SilverYutNoriBundle
-{
-	Vnum	50921 -- Silver Yut Nori Bundle
-	1	경험치	100000	60 -- Exp.
-	2	돈꾸러미	500000	40 -- Yang
-	3	돈꾸러미	300000	50 -- Yang
-	4	돈꾸러미	100000	60 -- Yang
-	5	79508	1	10 -- Yut Nori Board
-	6	55402	1	9 -- Spider Egg
-	7	25040	1	38 -- Blessing Scroll
-	8	39001	1	8 -- Magic Stone
-	9	76042	1	16 -- Teleportation Ring
-	10	39029	1	16 -- Reinforce Item
-	11	39028	1	64 -- Enchant Item
-	12	71189	1	28 -- Enchant Item+
-	13	39036	1	7 -- Wind Shoes
-	14	50324	1	12 -- Boost Book Chest
-	15	50323	1	12 -- Ward Book Chest
-	16	55403	1	6 -- Razador's Egg
-	17	55404	1	6 -- Nemere's Egg
-	18	85001	1	26 -- Lord Sash (basic)
-	19	51503	1	36 -- Cor Draconis (Normal)
-	20	51504	1	30 -- Cor Draconis (Noble)
-	21	55401	1	9 -- Monkey Egg
-	22	71181	1	8 -- Potion of Wisdom
-	23	27993	1	18 -- Blue Pearl
-	24	27994	1	13 -- Blood-Red Pearl
-	25	50108	10	20 -- Fireworks Top
-	26	50107	10	20 -- Chinese Fire Cracker
-	27	71180	1	10 -- Potion of Ascension (3h)
-	28	72058	10	29 -- Spirit Stone Bundle
-}
-
-Group	HalloweenChest(m)
-{
-	Vnum	83004 -- Halloween Chest (m)
-	1	41135	1	1 -- Pumpkin Tuxedo (Bonus)
-	2	41516	1	1 -- Cop. Fanged Costume+ (m)
-	3	41322	1	1 -- Pumpkin Jack Suit+ (m)
-	4	41478	1	1 -- Warlock's Suit+
-	5	41596	1	1 -- Harness of Horror+(Gold)
-	6	41517	1	1 -- Sil. Fanged Costume+ (m)
-	7	41675	1	1 -- Grey Wolf Costume+ (m)
-	8	41564	1	1 -- Blood Vampire+ (Grey)
-	9	41597	1	1 -- Harness of Horror+(Blue)
-	10	41474	1	1 -- Zombie Suit+
-	11	41674	1	1 -- Brown Wolf Costume+ (m)
-	12	41565	1	1 -- Blood Vampire+ (Red)
-}
-Group	HalloweenHatChest(m)
-{
-	Vnum	83005 -- Halloween Hat Chest (m)
-	1	45073	1	1 -- Pumpkin Mask (Bonus)
-	2	45158	1	1 -- Pumpkin Jack Head+ (m)
-	3	45286	1	1 -- Horns of Horror+ (Gold)
-	4	45341	1	1 -- Grey Wolf Hat+ (m)
-	5	45287	1	1 -- Horns of Horror+ (Blue)
-	6	45340	1	1 -- Brown Wolf Hat+ (m)
-	7	45210	1	1 -- Cop. Fanged Helmet+ (m)
-	8	45173	1	1 -- Witch's Hat+
-	9	45211	1	1 -- Sil. Fanged Helmet+ (m)
-	10	45254	1	1 -- Blood Vampire Helm+ (G)
-	11	45172	1	1 -- Zombie Pumpkin Mask+
-	12	45255	1	1 -- Blood Vampire Helm+ (R)
-}
-Group	HalloweenPetChest
-{
-	Vnum	83006 -- Haunted Pet Chest
-	1	53266	1	1 -- Helexna
-	2	53016	1	1 -- Boney
-	3	53265	1	1 -- Astrabell
-	4	53245	1	1 -- Mr Jiangshi+
-	5	53223	1	1 -- Little Broomstick
-	6	53244	1	1 -- Ms Jiangshi+
-	7	53233	1	1 -- Bruce (Loot)
-	8	53017	1	1 -- Jade Phoenix
-	9	53234	1	1 -- Wayne (Loot)
-	10	53254	1	1 -- Snivel
-	11	53222	1	1 -- Pumpkin Head
-	12	53253	1	1 -- Shiver
-}
-Group	HalloweenMountChest
-{
-	Vnum	83007 -- Haunted Mount Chest
-	1	71235	1	1 -- Cerberus (Gold)
-	2	71161	1	1 -- Equus Porphyreus
-	3	71236	1	1 -- Cerberus (Silver)
-	4	71223	1	1 -- Samsara Dragon
-	5	71228	1	1 -- Lava Cave Lizard
-	6	71222	1	1 -- Nirvana Dragon
-	7	71229	1	1 -- Ice Cave Lizard
-}
-Group	HalloweenJewelleryBox
-{
-	Vnum	83008 -- Jewellery Box
-	1	71143	1	1 -- Ring of Joy
-	2	71148	1	1 -- Ring of Will Power
-	3	71158	1	1 -- Hero's Medal
-	4	76047	1	1 -- Power Lolly (3D)
-	5	71202	1	1 -- Nazar Amulet
-	6	71145	1	1 -- Amulet of Eternal Love
-	7	76030	1	1 -- Power Lolly
-	8	71199	1	1 -- Chocolate Amulet
-	9	71149	1	1 -- Ring of Deadly Power
-	10	71188	1	1 -- Magic Lolly
-	11	72054	1	1 -- Amulet of the Guardians
-	12	71180	1	5 -- Potion of Ascension (3h)
-	13	71136	1	1 -- Mighty Lolly
-	14	71135	1	1 -- Crescent Moon Ring
-	15	71181	1	5 -- Potion of Wisdom
-}
-Group	HalloweenGrowthPetChest
-{
-	Vnum	83009 -- Pet Chest
-	1	55401	1	10 -- Monkey Egg
-	2	55406	1	5 -- Red Dragon Egg
-	3	55402	1	8 -- Spider Egg
-	4	55408	1	2 -- Fat Mini Executor Egg
-	5	55403	1	3 -- Razador's Egg
-	6	55407	1	2 -- Mini Azrael's Egg
-	7	55404	1	3 -- Nemere's Egg
-	8	55405	1	1 -- Blue Dragon Egg
-	9	55410	1	1 -- Nessie Egg
-}
-Group	HalloweenSashBox
-{
-	Vnum	83010 -- Sash Box
-	1	85005	1	3 -- Master Sash (basic)
-	2	85006	1	2 -- Master Sash (fine)
-	3	85007	1	1 -- Master Sash (noble)
-	4	85001	1	3 -- Lord Sash (basic)
-	5	85002	1	2 -- Lord Sash (fine)
-	6	85003	1	1 -- Lord Sash (noble)
-	7	85011	1	3 -- Sovereign Sash (basic)
-	8	85012	1	2 -- Sovereign Sash (fine)
-	9	85013	1	1 -- Sovereign Sash (noble)
-	10	85015	1	3 -- Royal Sash (basic)
-	11	85016	1	2 -- Royal Sash (fine)
-	12	85017	1	1 -- Royal Sash (noble)
-	13	86001	1	1 -- Zi Sash (basic)
-	14	86002	1	1 -- Zi Sash (fine)
-	15	86005	1	1 -- Chou Sash (basic)
-	16	86006	1	1 -- Chou Sash (fine)
-	17	86011	1	1 -- Yin Sash (basic)
-	18	86012	1	1 -- Yin Sash (fine)
-	19	86015	1	1 -- Mao Sash (basic)
-	20	86016	1	1 -- Mao Sash (fine)
-	21	86021	1	1 -- Chen Sash (basic)
-	22	86022	1	1 -- Chen Sash (fine)
-	23	86025	1	1 -- Si Sash (basic)
-	24	86026	1	1 -- Si Sash (fine)
-	25	86031	1	1 -- Wu Sash (basic)
-	26	86032	1	1 -- Wu Sash (fine)
-	27	86035	1	1 -- Wei Sash (basic)
-	28	86036	1	1 -- Wei Sash (fine)
-	29	86041	1	1 -- Shen Sash (basic)
-	30	86042	1	1 -- Shen Sash (fine)
-	31	86045	1	1 -- You Sash (basic)
-	32	86046	1	1 -- You Sash (fine)
-	33	86051	1	1 -- Xu Sash (basic)
-	34	86052	1	1 -- Xu Sash (fine)
-	35	86055	1	1 -- Hai Sash (basic)
-	36	86056	1	1 -- Hai Sash (fine)
-}
-Group	HalloweenTalismanChest
-{
-	Vnum	83011 -- Ornament Chest
-	1	10750	1	1 -- Lightning Talisman+0
-	2	10520	1	1 -- Wind Talisman+0
-	3	10060	1	1 -- Earth Talisman+0
-	4	9600	1	1 -- Fire Talisman+0
-	5	9830	1	1 -- Ice Talisman+0
-	6	10290	1	1 -- Dark Talisman+0
-	7	33029	50	1 -- Red Zodiac Case
-	8	33030	50	1 -- Blue Zodiac Case
-	9	72328	1	1 -- Mark of the Guardian
-	10	33031	50	1 -- Elemental Bloom
-	11	72329	50	1 -- Sphere Parchment
-}
-Group	HalloweenPetBookChest
-{
-	Vnum	83012 -- Ultimate Pet Book Chest
-	1	55020	1	1 -- Vampirism Book
-	2	55021	1	1 -- Spiritualism Book
-	3	55036	1	1 -- Eagle Eyes Book
-	4	55025	1	1 -- Range Book
-	5	55015	1	1 -- Berserker Book
-	6	55035	1	1 -- Monster Hunter Book
-	7	55037	1	1 -- Life Drain Book
-	8	55024	1	1 -- Yang Drop Book
-	9	55018	1	1 -- Drill Book
-	10	55023	1	1 -- Reflection Book
-	11	55022	1	1 -- Bulwark Book
-	12	55017	1	1 -- Haste Book
-	13	55016	1	1 -- Anti-Magic Book
-	14	55034	1	1 -- Master Brewer Book
-	15	55010	1	1 -- Resistance (Warrior)
-	16	55011	1	1 -- Resistance (Sura)
-	17	55012	1	1 -- Resistance (Ninja)
-	18	55013	1	1 -- Resistance (Shaman)
-	19	55014	1	1 -- Resistance (Lycan)
-	20	55027	1	1 -- Panacea Book
-	21	55019	1	1 -- Restoration Book
-	22	55026	1	1 -- Immortal Book
-	23	55038	1	1 -- Light as a Feather Book
-	24	55030	1	1 -- Pet Revertus
-}
-#Group	HalloweenWeaponChest+
-#{
-#	Vnum	83013 -- Riptooth Chest+
-#	1	40108	1	1 -- Riptooth Blade+
-#	2	40109	1	1 -- Riptooth Dagger+
-#	3	40110	1	1 -- Riptooth Bow+
-#	4	40111	1	1 -- Riptooth Glaive+
-#	5	40112	1	1 -- Riptooth Bell+
-#	6	40113	1	1 -- Riptooth Fan+
-#	7	40114	1	1 -- Riptooth Claws+
-#
-Group	HalloweenDSChest
-{
-	Vnum	83014 -- Cor Draconis Chest
-	1	51501	1	1 -- Cor Draconis (Rough)
-	2	51503	1	1 -- Cor Draconis (Normal)
-	3	51504	1	1 -- Cor Draconis (Noble)
-	4	51505	1	1 -- Cor Draconis (Precious)
-	5	51506	1	1 -- Cor Draconis (Mystical)
-	6	76029	1	1 -- Green Dragon Bean
-	7	100400	1	1 -- Blue Dragon Bean
-	8	100500	1	1 -- Pink Dragon Bean
-}
-Group	HalloweenGemChest
-{
-	Vnum	83015 -- Gaya Chest
-	1	50926	200	50 -- Glimmerstone
-	2	39063	1	25 -- Refresh Gaya Market
-	3	39064	1	25 -- Gaya Market Expansion
-	4	72058	10	30 -- Spirit Stone Bundle
-}
-Group	HalloweenMysteryChest
-{
-	Vnum	83016 -- Chest of Mysteries
-	1	54702	1	1 -- Razador's Chest
-	2	54703	1	1 -- Nemere's Chest
-	3	54704	1	1 -- Jotun Thrym's Chest
-	4	54701	1	1 -- Bagjanamu's Chest
-	5	54700	1	1 -- Beran-Setaou's Chest
-	6	50271	1	1 -- Dragon Watcher Chest
-	7	50270	1	1 -- Queen Meley's Chest
-	8	54705	1	1 -- Hydra's Chest
-	9	30618	1	3 -- Moonstone
-	10	30617	1	3 -- Agate
-	11	30616	1	3 -- Titanium Dioxide
-	12	27992	1	3 -- White Pearl
-	13	27993	1	3 -- Blue Pearl
-	14	27994	1	3 -- Blood-Red Pearl
-	15	30619	1	3 -- Metallic Gold Dye
-	16	18900	1	3 -- Red Flame Stone
-}
-Group	HalloweenRubyChest
-{
-	Vnum	83017 -- Ruby Chest
-	1	76005	1	1 -- Moon Elixir (M)
-	2	76022	1	1 -- Sun Elixir (M)
-	3	76000	3	1 -- Peach Flower Wine
-	4	76033	3	1 -- Peach Flower Wine+
-	5	76006	1	1 -- Compass for Metin Stones
-	6	76012	3	1 -- Potion of Speed
-	7	76025	1	1 -- Wind Shoes
-	8	76042	1	1 -- Teleportation Ring
-	9	76017	3	1 -- Potion of Attack +15
-	10	76018	3	1 -- Potion of Attack +20
-	11	76003	3	1 -- Potion of Haste
-	12	76036	3	1 -- Dragon God Attack
-	13	76035	3	1 -- Dragon God Life
-	14	76019	1	1 -- Passage Ticket
-	15	76010	1	1 -- Blood Stone
-	16	76002	1	1 -- Shrunken Head
-	17	76014	1	1 -- Enchant Item (b)
-	18	76013	1	1 -- Reinforce Item (b)
-	19	76015	1	1 -- Blessing Marble
-	20	71189	1	1 -- Enchant Item+
-	21	76016	1	1 -- Blessing Scroll
-	22	76009	1	1 -- Dragon Scroll
-	23	76011	1	1 -- Book of the Leader
-	24	76008	3	1 -- Medal of the Dragon
-	25	76007	20	1 -- Bravery Cape
-	26	76051	1	1 -- Ring of Secrets (7d)
-	27	76037	1	1 -- Thief's Gloves
-	28	76038	1	1 -- Lucky Medal
-	29	71107	1	1 -- Fruit of Life
-	30	76001	1	1 -- Status Reset Document
-	31	76045	1	1 -- Pet Name Scroll
-	32	76028	1	1 -- Stone Handbook
-	33	76034	1	1 -- Concentrated Reading
-	34	76026	1	1 -- Exorcism Scroll
-	35	76020	1	1 -- Researcher's Elixir
-	36	72320	1	1 -- Inventory Expansion
-	37	76031	1	1 -- Protein Snack
-}
-Group	HalloweenChest(f)
-{
-	Vnum	83028 -- Halloween Chest (f)
-	1	41136	1	1 -- Pumpkin Dress (Bonus)
-	2	41518	1	1 -- Cop. Fanged Costume+ (f)
-	3	41323	1	1 -- Pumpkin Jack Dress+ (f)
-	4	41479	1	1 -- Witch's Dress+
-	5	41598	1	1 -- Harness of Horror+(Gold)
-	6	41519	1	1 -- Sil. Fanged Costume+ (f)
-	7	41677	1	1 -- Grey Wolf Costume+ (f)
-	8	41566	1	1 -- Blood Lamia+ (Grey)
-	9	41599	1	1 -- Harness of Horror+(Blue)
-	10	41475	1	1 -- Zombie Dress+
-	11	41676	1	1 -- Brown Wolf Costume+ (f)
-	12	41567	1	1 -- Blood Lamia+ (Red)
-}
-Group	HalloweenHatChest(f)
-{
-	Vnum	83029 -- Halloween Hat Chest (f)
-	1	45074	1	1 -- Pumpkin Mask (Bonus)
-	2	45159	1	1 -- Pumpkin Jack Head+ (f)
-	3	45288	1	1 -- Horns of Horror+ (Gold)
-	4	45343	1	1 -- Grey Wolf Hat+ (f)
-	5	45289	1	1 -- Horns of Horror+ (Blue)
-	6	45342	1	1 -- Brown Wolf Hat+ (f)
-	7	45212	1	1 -- Cop. Fanged Helmet+ (f)
-	8	45173	1	1 -- Witch's Hat+
-	9	45213	1	1 -- Sil. Fanged Helmet+ (f)
-	10	45256	1	1 -- Blood Lamia Helm+ (Grey)
-	11	45172	1	1 -- Zombie Pumpkin Mask+
-	12	45257	1	1 -- Blood Lamia Helm+ (Red)
-}
-Group	mystery_box_1
-{
-	Vnum	50125 -- Mysterious Chest
-	1	71085	1	2 -- Reinforce Item
-	2	70039	1	2 -- Blacksmith Handbook
-	3	71032	1	4 -- Dragon Scroll
-	4	70024	1	4 -- Blessing Marble
-	5	25040	1	6 -- Blessing Scroll
-	6	71012	1	14 -- Book of the Leader
-	7	71130	3	14 -- Passage Ticket
-	8	71083	1	14 -- Stone Handbook
-	9	71004	10	14 -- Medal of the Dragon
-	10	71018	2	14 -- Blessing of Life
-	11	25041	1	1 -- Magic Stone
-	12	71125	1	1 -- Wild Battle Boar
-}
-Group	MerryGoldenOkeyChest
-{
-	Vnum	50267 -- Merry Golden Okey Chest
-	1	72355	1	100 -- Personal Premium Shop
-	2	30617	1	100 -- Agate
-	3	76016	1	100 -- Blessing Scroll
-	4	51505	1	100 -- Cor Draconis (Precious)
-	5	51506	1	100 -- Cor Draconis (Mystical)
-	6	71224	1	100 -- Manny
-	7	71225	1	100 -- Ellie
-	8	71189	1	100 -- Enchant Item+
-	9	76014	1	100 -- Enchant Item (b)
-	10	85003	1	100 -- Lord Sash (noble)
-	11	25041	1	100 -- Magic Stone
-	12	30618	1	100 -- Moonstone
-	13	79506	1	100 -- Okey Card Set
-	14	55404	1	100 -- Nemere's Egg
-	15	55403	1	100 -- Razador's Egg
-	16	55405	1	100 -- Blue Dragon Egg
-	17	76013	1	100 -- Reinforce Item (b)
-	18	50525	1	100 -- Soul Stone+
-	19	30616	1	100 -- Titanium Dioxide
-	20	70058	1	100 -- Teleportation Ring
-	21	50324	1	100 -- Boost Book Chest
-	22	50323	1	100 -- Ward Book Chest
-	23	27992	1	100 -- White Pearl
-	24	50926	200	100 -- Glimmerstone
-	25	39036	1	100 -- Wind Shoes
-	26	71153	1	100 -- Potion of Wisdom
-	27	50513	1	100 -- Soul Stone
-	28	경험치	700000	100 -- Exp.
-	29	돈꾸러미	700000	100 -- Yang
-	30	돈꾸러미	500000	100 -- Yang
-	31	71192	1	100 -- Thunder
-	32	71193	1	100 -- Blitzen
-}
-Group	MerrySilverOkeyChest
-{
-	Vnum	50268 -- Merry Silver Okey Chest
-	1	72355	1	100 -- Personal Premium Shop
-	2	79506	1	100 -- Okey Card Set
-	3	76016	1	100 -- Blessing Scroll
-	4	27994	1	100 -- Blood-Red Pearl
-	5	27993	1	100 -- Blue Pearl
-	6	71224	1	100 -- Manny
-	7	71225	1	100 -- Ellie
-	8	50324	1	100 -- Boost Book Chest
-	9	50323	1	100 -- Ward Book Chest
-	10	51503	1	100 -- Cor Draconis (Normal)
-	11	51504	1	100 -- Cor Draconis (Noble)
-	12	71189	1	100 -- Enchant Item+
-	13	76014	1	100 -- Enchant Item (b)
-	14	76013	1	100 -- Reinforce Item (b)
-	15	85001	1	100 -- Lord Sash (basic)
-	16	25041	1	100 -- Magic Stone
-	17	55404	1	100 -- Nemere's Egg
-	18	55403	1	100 -- Razador's Egg
-	19	55402	1	100 -- Spider Egg
-	20	70058	1	100 -- Teleportation Ring
-	21	39036	1	100 -- Wind Shoes
-	22	50926	60	100 -- Glimmerstone
-	23	71153	1	100 -- Potion of Wisdom
-	24	경험치	100000	100 -- Exp.
-	25	돈꾸러미	500000	100 -- Yang
-	26	돈꾸러미	300000	100 -- Yang
-	27	돈꾸러미	100000	100 -- Yang
-	28	71192	1	100 -- Thunder
-	29	71193	1	100 -- Blitzen
-}
-Group	MerryBronzeOkeyChest
-{
-	Vnum	50269 -- Merry Bronze Okey Chest
-	1	79506	1	100 -- Okey Card Set
-	2	경험치	100000	100 -- Exp.
-	3	돈꾸러미	100000	100 -- Yang
-	4	돈꾸러미	50000	100 -- Yang
-}
-
-Group	GoldenOkeyChest
-{
-	Vnum	50275 -- Golden Okey Chest
-	1	71148	1	100 -- Ring of Will Power
-	2	71149	1	100 -- Ring of Deadly Power
-	3	55404	1	100 -- Nemere's Egg
-	4	55403	1	100 -- Razador's Egg
-	5	85017	1	100 -- Royal Sash (noble)
-	6	51506	1	100 -- Cor Draconis (Mystical)
-	7	51505	1	100 -- Cor Draconis (Precious)
-	8	79506	1	100 -- Okey Card Set
-	9	50513	1	100 -- Soul Stone
-	10	76021	1	100 -- Sun Elixir (S)
-	11	76004	1	100 -- Moon Elixir (S)
-	12	70102	1	100 -- Zen Bean
-	13	76012	1	100 -- Potion of Speed
-	14	28443	1	100 -- Stone of Haste+4
-	15	70031	1	100 -- Fencing Pamphlet
-	16	30524	1	100 -- Flame Stone
-	17	71123	1	100 -- Dragon Scales
-	18	30195	1	100 -- Quartz Sand
-	19	27992	1	100 -- White Pearl
-	20	55003	1	100 -- Young Pet Book
-	21	55004	1	100 -- Wild Pet Book
-	22	경험치	700000	100 -- Exp.
-	23	돈꾸러미	1000000	100 -- Yang
-	24	돈꾸러미	700000	100 -- Yang
-	25	돈꾸러미	500000	100 -- Yang
-}
-Group	SilverOkeyChest
-{
-	Vnum	50276 -- Silver Okey Chest
-	1	55401	1	100 -- Monkey Egg
-	2	55402	1	100 -- Spider Egg
-	3	76021	1	100 -- Sun Elixir (S)
-	4	76004	1	100 -- Moon Elixir (S)
-	5	70102	1	100 -- Zen Bean
-	6	27987	1	100 -- Clam
-	7	76012	1	100 -- Potion of Speed
-	8	70031	1	100 -- Fencing Pamphlet
-	9	85001	1	100 -- Lord Sash (basic)
-	10	79506	1	100 -- Okey Card Set
-	11	71148	1	100 -- Ring of Will Power
-	12	71149	1	100 -- Ring of Deadly Power
-	13	55003	1	100 -- Young Pet Book
-	14	55004	1	100 -- Wild Pet Book
-	15	51505	1	100 -- Cor Draconis (Precious)
-	16	51504	1	100 -- Cor Draconis (Noble)
-	17	27994	1	100 -- Blood-Red Pearl
-	18	27993	1	100 -- Blue Pearl
-	19	경험치	500000	100 -- Exp.
-	20	돈꾸러미	500000	100 -- Yang
-	21	돈꾸러미	300000	100 -- Yang
-}
-Group	BronzeOkeyChest
-{
-	Vnum	50277 -- Bronze Okey Chest
-	1	79506	1	100 -- Okey Card Set
-	2	경험치	100000	100 -- Exp.
-	3	돈꾸러미	100000	100 -- Yang
-	4	돈꾸러미	50000	100 -- Yang
-}
-
-Group	GoldenOkeyBox
-{
-	Vnum	71194 -- Golden Okey Box
-	1	79506	5	100 -- Okey Card Set
-}
-Group	SilverOkeyBox
-{
-	Vnum	71195 -- Silver Okey Box
-	1	79506	1	100 -- Okey Card Set
-}
-Group	BronzeOkeyBox
-{
-	Vnum	71196 -- Bronze Okey Box
-	1	79505	6	100 -- Okey Collectable Card
-}
-Group	2012올림픽선물상자_1
-{
-	Vnum	71159 -- Milon's Chest
-	1	70035	1	1 -- Magic Copper Ore
-	2	71085	1	6 -- Reinforce Item
-	3	70024	1	6 -- Blessing Marble
-	4	71026	1	1 -- Magic Iron Ore
-	5	71084	1	6 -- Enchant Item
-	6	71108	15	10 -- Pomegranate Juice
-	7	70003	1	5 -- Book of the Leader
-	8	72723	1	5 -- Sun Elixir (S)
-	9	72727	1	5 -- Moon Elixir (S)
-	10	71004	5	5 -- Medal of the Dragon
-	11	71094	1	5 -- Concentrated Reading
-	12	70102	1	10 -- Zen Bean
-	13	27992	1	5 -- White Pearl
-	14	27993	1	5 -- Blue Pearl
-	15	27994	1	9 -- Blood-Red Pearl
-	16	41005	1	6 -- Fencing Outfit (m)
-	17	41013	1	6 -- Football Outfit (m)
-	18	41021	1	6 -- Boxing Outfit (m)
-}
-Group	2012올림픽선물상자_1_여성용
-{
-	Vnum	71160 -- Athena's Chest
-	1	70035	1	1 -- Magic Copper Ore
-	2	71085	1	6 -- Reinforce Item
-	3	70024	1	6 -- Blessing Marble
-	4	71026	1	1 -- Magic Iron Ore
-	5	71084	1	6 -- Enchant Item
-	6	71108	15	10 -- Pomegranate Juice
-	7	70003	1	5 -- Book of the Leader
-	8	72723	1	5 -- Sun Elixir (S)
-	9	72727	1	5 -- Moon Elixir (S)
-	10	71004	5	5 -- Medal of the Dragon
-	11	71094	1	5 -- Concentrated Reading
-	12	70102	1	10 -- Zen Bean
-	13	27992	1	5 -- White Pearl
-	14	27993	1	5 -- Blue Pearl
-	15	27994	1	9 -- Blood-Red Pearl
-	16	41006	1	6 -- Fencing Outfit (f)
-	17	41014	1	6 -- Football Outfit (f)
-	18	41022	1	6 -- Boxing Outfit (f)
-}
-Group	2012올림픽선물상자_2
-{
-	Vnum	50249
-	1	27001	100	100 -- Red Potion (S)
-	2	27002	50	70 -- Red Potion (M)
-	3	27003	10	50 -- Red Potion (L)
-	4	27004	100	75 -- Blue Potion (S)
-	5	27005	50	55 -- Blue Potion (M)
-	6	27006	10	35 -- Blue Potion (L)
-	7	경험치	30000	70 -- Experience
-	8	경험치	50000	40 -- Experience
-	9	경험치	70000	20 -- Experience
-	10	경험치	100000	10 -- Experience
-	11	70048	1	20 -- Cloak of Secrecy
-	12	70102	1	9 -- Zen Bean
-	13	70051	1	20 -- Sage King's Glove
-	14	70049	1	35 -- Lucy's Ring
-	15	25040	1	1 -- Blessing Scroll
-	16	30045	1	26 -- Scorpion Needle
-	17	30051	1	26 -- Unknown Talisman
-	18	30038	1	26 -- Tiger Hide
-	19	30070	1	26 -- Wolf Fur+
-	20	30023	1	26 -- White Tiger Hide
-	21	30033	1	26 -- Broken Porcelain
-	22	30011	1	26 -- Ball
-	23	30027	1	26 -- Wolf Fur
-	24	30082	1	26 -- Snake Tail+
-	25	30035	1	26 -- Face Cream
-	26	30010	1	26 -- Bear Gall
-	27	30055	1	26 -- Scorpion Claw
-	28	30006	1	26 -- Orc Tooth
-	29	30003	1	26 -- Pig Nose
-	30	30017	1	26 -- Ornamental Hairpin
-}
-Group	녹각보관함_불사조
-{
-	Vnum	53501 -- Fire Phoenix Cage
-	Type	pct
-	1	53001	1	100 -- Fire Phoenix
-}
-Group	녹각보관함_아기순록
-{
-	Vnum	53502 -- Reindeer Calf Chest
-	Type	pct
-	1	53002	1	100 -- Reindeer Calf
-}
-Group	녹각보관함_빙염불사조
-{
-	Vnum	53503 -- Ice Phoenix Cage
-	Type	pct
-	1	53003	1	100 -- Ice Phoenix
-}
-Group	녹각보관함_아기파황
-{
-	Vnum	53505 -- Baby Azrael Chest
-	Type	pct
-	1	53005	1	100 -- Baby Azrael
-}
-Group	녹각보관함_아기파황_special
-{
-	Vnum	53506 -- Baby Azrael Chest (Gold)
-	Type	pct
-	1	53006	1	100 -- Baby Azrael (gold)
-}
-Group	녹각보관함_아기순록_2012
-{
-	Vnum	53507 -- Bambi Chest
-	Type	pct
-	1	53007	1	100 -- Bambi
-}
-Group	녹각보관함_아기백곰
-{
-	Vnum	53508 -- Knuud Chest
-	Type	pct
-	1	53008	1	100 -- Knuud
-}
-Group	녹각보관함_아기펜더
-{
-	Vnum	53509 -- Bao Bao Chest
-	Type	pct
-	1	53009	1	100 -- Bao Bao
-}
-Group	녹각보관함_아기사자
-{
-	Vnum	53510 -- Leonidas Chest
-	Type	pct
-	1	53010	1	100 -- Leonidas
-}
-Group	녹각보관함_아기호랑이
-{
-	Vnum	53511 -- Khan Chest
-	Type	pct
-	1	53011	1	100 -- Khan
-}
-Group	녹각보관함_아기멧돼지
-{
-	Vnum	53512 -- Porky Chest
-	Type	pct
-	1	53012	1	100 -- Porky
-}
-Group	녹각보관함_아기늑대
-{
-	Vnum	53513 -- Rufus Chest
-	Type	pct
-	1	53013	1	100 -- Rufus
-}
-Group	녹각보관함_붉은도적단장수
-{
-	Vnum	53514 -- Mini-Executor Chest
-	Type	pct
-	1	53014	1	100 -- Chubby Mini-Executor
-}
-Group	녹각보관함_붉은도적단장수_특
-{
-	Vnum	53515 -- Mini-ExecutorChest(Gold)
-	Type	pct
-	1	53015	1	100 -- Chubby Mini-Executor (g)
-}
-Group	녹각보관함_할로윈뼈강아지
-{
-	Vnum	53516 -- Bone Chest
-	Type	pct
-	1	53016	1	100 -- Boney
-}
-Group	녹각보관함_녹염불사조
-{
-	Vnum	53517 -- Jade Cage
-	Type	pct
-	1	53017	1	100 -- Jade Phoenix
-}
-Group	이동반지
-{
-	Vnum	10031
-	Type	Quest
-	1	70058	1	1 -- Teleportation Ring
-	2	76042	1	1 -- Teleportation Ring
-}
-Group	탈것교환권
-{
-	Vnum	10032
-	Type	Quest
-	1	52701	1	1 -- Lion Certificate
-	2	52702	1	1 -- Tiger Certificate
-	3	52703	1	1 -- Wild Boar Certificate
-	4	52704	1	1 -- Wolf Certificate
-	5	52705	1	1 -- Reindeer Certificate (m)
-	6	52706	1	1 -- Reindeer Certificate (f)
-	7	52707	1	1 -- Dragor Certificate
-	8	52708	1	1 -- Moa Certificate
-}
-#Group	경험의반지+50
-#{
-#	Vnum	10000
-#	1	39002	1	1 -- Experience Ring (1h)
-#	2	70005	1	1 -- Experience Ring (1h)
-#	3	72001	1	1 -- Experience Ring (10h)
-#	4	72002	1	1 -- Experience Ring (30m)
-#	5	72003	1	1 -- Experience Ring (3h)
-#	6	72303	1	1 -- Experience Ring (1h)
-#	7	72049	1	1 -- Experience Ring (30h)
-#	8	72050	1	1 -- Experience Ring (60h)
-#}
-#Group	도둑의장갑
-#{
-#	Vnum	10002
-#	1	70043	1	1 -- Thief's Gloves (2h)
-#	2	72004	1	1 -- Thief's Gloves (10h)
-#	3	72005	1	1 -- Thief's Gloves (30m)
-#	4	72006	1	1 -- Thief's Gloves (3h)
-#}
-Group	비단보따리
-{
-	Vnum	10003
-	1	71049	1	1 -- Silk Bundle (10d)
-	2	72007	1	1 -- Silk Bundle (10h)
-	3	72008	1	1 -- Silk Bundle (30m)
-	4	72009	1	1 -- Silk Bundle (3h)
-}
-Group	열정의가면
-{
-	Vnum	10004
-	1	38059	1	1 -- Emotion Mask (15d)
-	2	71011	1	1 -- Emotion Mask (30d)
-	3	71033	1	1 -- Emotion Mask (15d)
-	4	76054	1	1 -- Emotion Mask (7d)
-}
-Group	원앙의깃?
-{
-	Vnum	10008
-	1	72010	1	1 -- Lovebird Feather (15m)
-	2	72011	1	1 -- Lovebird Feather (30m)
-	3	72012	1	1 -- Lovebird Feather (3h)
-}
-Group	월간어심
-{
-	Vnum	10009
-	1	72013	1	1 -- Fishing Book (15m)
-	2	72014	1	1 -- Fishing Book (30m)
-	3	72015	1	1 -- Fishing Book (3h)
-}
-Group	육도
-{
-	Vnum	10010
-	1	72043	1	1 -- Book of the Leader (15m)
-	2	72044	1	1 -- Book of the Leader (30m)
-	3	72045	1	1 -- Book of the Leader (3h)
-	4	70003	1	1 -- Book of the Leader (2h)
-	5	71012	1	1 -- Book of the Leader (3h)
-	6	72302	1	1 -- Book of the Leader (2h)
-	7	76011	1	1 -- Book of the Leader (1h)
-}
-Group	제3의손
-{
-	Vnum	10011
-	1	71010	1	1 -- Third Hand (30d)
-	2	72016	1	1 -- Third Hand (15m)
-	3	72017	1	1 -- Third Hand (30m)
-	4	72018	1	1 -- Third Hand (3h)
-	5	76053	1	1 -- Third Hand (3d)
-}
-Group	창고확장권
-{
-	Vnum	10021
-	1	71009	1	1 -- Storage Chest (30d)
-	2	72019	1	1 -- Storage Chest (15m)
-	3	72020	1	1 -- Storage Chest (30m)
-	4	72021	1	1 -- Storage Chest (3h)
-}
-Group	행운의금화
-{
-	Vnum	10024
-	1	72022	1	1 -- Lucky Medal (10h)
-	2	72023	1	1 -- Lucky Medal (30m)
-	3	72024	1	1 -- Lucky Medal (3h)
-}
-Group	언어반지
-{
-	Vnum	10025
-	1	70006	1	1 -- Language Ring (1h)
-	2	70047	1	1 -- Language Ring (5m)
-	3	71005	1	1 -- Language Ring (7d)
-	4	71006	1	1 -- Language Ring (15d)
-	5	71007	1	1 -- Language Ring (30d)
-}
-Group	동물_상자_캐시
-{
-	Vnum	10030
-	1	71115	1	1 -- Wild Boar (blue)
-	2	71117	1	1 -- Wolf (blue)
-	3	71119	1	1 -- Tiger (blue)
-	4	71121	1	1 -- Lion (blue)
-}
-Group	flame_dungeon_ticket_group
-{
-	Vnum	10033
-	1	71174	1	1 -- Passage Ticket
-	2	71175	1	1 -- Passage Ticket
-}
-Group	dungeon_ticket_group
-{
-	Vnum	10034
-	1	71095	1	1 -- Passage Ticket
-	2	71130	1	1 -- Passage Ticket
-	3	76019	1	1 -- Passage Ticket
-}
-Group	grotto_ticket_group
-{
-	Vnum	10035
-	1	30190	1	1 -- Blood Stone
-	2	30191	1	1 -- Blood Stone
-	3	76010	1	1 -- Blood Stone
-}
-Group	mysterious_ticket_group
-{
-	Vnum	10036
-	1	70408	1	1 -- Mysterious Ticket
-	2	70407	1	1 -- Myst. Ticket (Premium)
-}
-Group	red_dragon_lair_ticket_group
-{
-	Vnum	10037
-	1	71201	1	1 -- Passage Ticket (Meley)
-	2	72342	1	1 -- Passage Ticket (Meley)
-}
-#Group	경험의반지+100
-#{
-#	Vnum	10040
-#	1	72057	1	1 -- Double Experience Ring (36h)
-#}
-#Group	경험의반지+200
-#{
-#	Vnum	10041
-#	1	72062	1	1 -- Experience Ring +200 (3h)
-#}
-Group	육도+100
-{
-	Vnum	10042
-	1	72059	1	1 -- Book of the Leader+ (2h)
-	2	72060	1	1 -- Book of the Leader+ (3h)
-}
-Group 스폐셜
-{
-	Vnum	10050
-	Type	special
-	1	71148	100000	1
-	2	71149	100001	1
-	3	71158	100002	1
-	4	71135	100003	1
-	5	71136	100004	1
-	6	71143	100005	1
-	7	71145	100006	1
-	8	71188	100007	1
-	9	71199	100008	1
-	10	71202	100009	1
-	11	72054	100010	1
-	12	76030	100011	1
-	13	76047	100011	1
-	14	72703	100030	1
-	15	72704	100031	1
-	16	72705	100032	1
-	17	72706	100033	1
-	18	72709	100030	1
-	19	72710	100034	1
-	20	72711	100035	1
-	21	72712	100036	1
-}
-Group 스폐셜_Element1
-{
-	Vnum	10051
-	Type	special
-	1	39119	100012	1
-}
-Group 스폐셜_Element2
-{
-	Vnum	10052
-	Type	special
-	1	39120	100013	1
-}
-Group 속성
-{
-	Vnum	100000
-	Type	ATTR
-	1	66	30 -- APPLY_MALL_EXPBONUS
-	2	78	20 -- APPLY_RESIST_WARRIOR
-	3	79	20 -- APPLY_RESIST_ASSASSIN
-	4	95	20 -- APPLY_RESIST_WOLFMAN
-	5	63	30 -- APPLY_ATT_BONUS_TO_MONSTER
-	6	69	10 -- APPLY_MAX_HP_PCT
-	7	70	10 -- APPLY_MAX_SP_PCT
-	effect	"d:/ymir work/effect/etc/buff/buff_item5.mse"
-}
-Group 속성2
-{
-	Vnum	100001
-	Type	ATTR
-	1	66	30 -- APPLY_MALL_EXPBONUS
-	2	80	20 -- APPLY_RESIST_SURA
-	3	81	20 -- APPLY_RESIST_SHAMAN
-	4	95	20 -- APPLY_RESIST_WOLFMAN
-	5	63	30 -- APPLY_ATT_BONUS_TO_MONSTER
-	6	69	10 -- APPLY_MAX_HP_PCT
-	7	70	10 -- APPLY_MAX_SP_PCT
-	effect	"d:\ymir work\effect\etc\buff\buff_item5.mse"
-}
-Group 속성3
-{
-	Vnum	100002
-	Type	ATTR
-	1	66	50 -- APPLY_MALL_EXPBONUS
-	2	64	30 -- APPLY_MALL_ATTBONUS
-	3	7	20 -- APPLY_ATT_SPEED
-	4	9	20 -- APPLY_CAST_SPEED
-	5	69	10 -- APPLY_MAX_HP_PCT
-	6	70	10 -- APPLY_MAX_SP_PCT
-	effect	"d:\ymir work\effect\etc\buff\buff_symbol1.mse"
-}
-Group 속성4
-{
-	Vnum	100003
-	Type	ATTR
-	1	66	50 -- APPLY_MALL_EXPBONUS
-	2	7	20 -- APPLY_ATT_SPEED
-	3	9	20 -- APPLY_CAST_SPEED
-	4	64	30 -- APPLY_MALL_ATTBONUS
-	5	69	10 -- APPLY_MAX_HP_PCT
-	6	70	10 -- APPLY_MAX_SP_PCT
-	7	84	5 -- APPLY_COSTUME_ATTR_BONUS
-}
-Group 속성5
-{
-	Vnum	100004
-	Type	ATTR
-	1	66	50 -- APPLY_MALL_EXPBONUS
-	2	64	30 -- APPLY_MALL_ATTBONUS
-	3	7	20 -- APPLY_ATT_SPEED
-	4	9	20 -- APPLY_CAST_SPEED
-	5	69	10 -- APPLY_MAX_HP_PCT
-	6	70	10 -- APPLY_MAX_SP_PCT
-}
-Group 속성6
-{
-	Vnum	100005
-	Type	ATTR
-	1	66	50 -- APPLY_MALL_EXPBONUS
-	2	7	20 -- APPLY_ATT_SPEED
-	3	9	20 -- APPLY_CAST_SPEED
-	4	63	30 -- APPLY_ATT_BONUS_TO_MONSTER
-	5	69	10 -- APPLY_MAX_HP_PCT
-	6	70	10 -- APPLY_MAX_SP_PCT
-}
-Group 속성7
-{
-	Vnum	100006
-	Type	ATTR
-	1	66	30 -- APPLY_MALL_EXPBONUS
-	2	7	10 -- APPLY_ATT_SPEED
-	3	9	10 -- APPLY_CAST_SPEED
-	4	69	5 -- APPLY_MAX_HP_PCT
-	5	70	5 -- APPLY_MAX_SP_PCT
-	6	63	10 -- APPLY_ATT_BONUS_TO_MONSTER
-}
-Group 속성8
-{
-	Vnum	100007
-	Type	ATTR
-	1	66	50 -- APPLY_MALL_EXPBONUS
-	2	55	30 -- APPLY_MAGIC_ATT_GRADE
-	3	7	20 -- APPLY_ATT_SPEED
-	4	9	20 -- APPLY_CAST_SPEED
-	5	69	10 -- APPLY_MAX_HP_PCT
-	6	70	10 -- APPLY_MAX_SP_PCT
-	effect	"d:/ymir work/effect/etc/buff/buff_item8.mse"
-}
-Group 속성9
-{
-	Vnum	100008
-	Type	ATTR
-	1	66	50 -- APPLY_MALL_EXPBONUS
-	2	7	20 -- APPLY_ATT_SPEED
-	3	9	20 -- APPLY_CAST_SPEED
-	4	63	10 -- APPLY_ATT_BONUS_TO_MONSTER
-	5	69	10 -- APPLY_MAX_HP_PCT
-	6	70	10 -- APPLY_MAX_SP_PCT
-	effect	"d:/ymir work/effect/etc/buff/buff_item10.mse"
-}
-Group 속성10
-{
-	Vnum	100009
-	Type	ATTR
-	1	66	50 -- APPLY_MALL_EXPBONUS
-	2	7	20 -- APPLY_ATT_SPEED
-	3	9	20 -- APPLY_CAST_SPEED
-	4	63	10 -- APPLY_ATT_BONUS_TO_MONSTER
-	5	64	30 -- APPLY_MALL_ATTBONUS
-	6	55	30 -- APPLY_MAGIC_ATT_GRADE
-	effect	"d:/ymir work/effect/etc/buff/buff_item13.mse"
-}
-Group 속성11
-{
-	Vnum	100010
-	Type	ATTR
-	1	64	30 -- APPLY_MALL_ATTBONUS
-	2	55	30 -- APPLY_MAGIC_ATT_GRADE
-	3	7	20 -- APPLY_ATT_SPEED
-	4	9	20 -- APPLY_CAST_SPEED
-	5	115	10 -- APPLY_RESIST_HUMAN
-	6	73	10 -- APPLY_SKILL_DEFEND_BONUS
-	effect	"d:/ymir work/effect/etc/buff/buff_item14.mse"
-}
-Group 속성12-13
-{
-	Vnum	100011
-	Type	ATTR
-	1	66	50 -- APPLY_MALL_EXPBONUS
-	2	7	20 -- APPLY_ATT_SPEED
-	3	9	20 -- APPLY_CAST_SPEED
-	4	63	10 -- APPLY_ATT_BONUS_TO_MONSTER
-	5	69	10 -- APPLY_MAX_HP_PCT
-	6	70	10 -- APPLY_MAX_SP_PCT
-	effect	"d:/ymir work/effect/etc/buff/buff_item16.mse"
-}
-Group 속성14
-{
-	Vnum	100012
-	Type	ATTR
-	1	99	10 -- APPLY_ENCHANT_ELECT
-	2	100	10 -- APPLY_ENCHANT_FIRE
-	3	101	10 -- APPLY_ENCHANT_ICE
-	4	102	10 -- APPLY_ENCHANT_WIND
-	5	103	10 -- APPLY_ENCHANT_EARTH
-	6	104	10 -- APPLY_ENCHANT_DARK
-	effect	"d:\ymir work\effect\etc\buff\buff_item18_element01.mse"
-}
-Group 속성15
-{
-	Vnum	100013
-	Type	ATTR
-	1	35	10 -- APPLY_RESIST_FIRE
-	2	36	10 -- APPLY_RESIST_ELEC
-	3	38	10 -- APPLY_RESIST_WIND
-	4	87	10 -- APPLY_RESIST_ICE
-	5	88	10 -- APPLY_RESIST_EARTH
-	6	89	10 -- APPLY_RESIST_DARK
-	effect	"d:\ymir work\effect\etc\buff\buff_item18_element02.mse"
-}
-Group 속성30
-{
-	Vnum	100030
-	Type	ATTR
-	1	53	200 -- APPLY_ATT_GRADE_BONUS
-}
-Group 속성31
-{
-	Vnum	100031
-	Type	ATTR
-	1	54	200 -- APPLY_DEF_GRADE_BONUS
-}
-Group 속성32
-{
-	Vnum	100032
-	Type	ATTR
-	1	71	15 -- APPLY_SKILL_DAMAGE_BONUS
-}
-Group 속성33
-{
-	Vnum	100033
-	Type	ATTR
-	1	73	15 -- APPLY_SKILL_DEFEND_BONUS
-}
-Group 속성34
-{
-	Vnum	100034
-	Type	ATTR
-	1	54	300 -- APPLY_DEF_GRADE_BONUS
-}
-Group 속성35
-{
-	Vnum	100035
-	Type	ATTR
-	1	73	30 -- APPLY_SKILL_DAMAGE_BONUS
-}
-Group 속성36
-{
-	Vnum	100036
-	Type	ATTR
-	1	73	30 -- APPLY_SKILL_DEFEND_BONUS
-}
-
-Group	경험의반지
-{
-	Vnum	10000
-	Type	special
-	1	39002	110010	1 -- Experience Ring (1h)
-	2	70005	110010	1 -- Experience Ring (1h)
-	3	72001	110010	1 -- Experience Ring (10h)
-	4	72002	110010	1 -- Experience Ring (30m)
-	5	72003	110010	1 -- Experience Ring (3h)
-	6	72303	110010	1 -- Experience Ring (1h)
-	7	72049	110010	1 -- Experience Ring (30h)
-	8	72050	110010	1 -- Experience Ring (60h)
-	9	72057	110011	1 -- Double Experience Ring (36h)
-	10	72062	110012	1 -- Experience Ring +200 (3h)
-}
-Group	경험의반지+50
-{
-	Vnum	110010
-	Type	ATTR
-	1	66	50 -- APPLY_MALL_EXPBONUS
-}
-Group	경험의반지+100
-{
-	Vnum	110011
-	Type	ATTR
-	1	66	100 -- APPLY_MALL_EXPBONUS
-}
-Group	경험의반지+200
-{
-	Vnum	110012
-	Type	ATTR
-	1	66	200 -- APPLY_MALL_EXPBONUS
-}
-Group	도둑의장갑
-{
-	Vnum	10002
-	Type	special
-	1	70043	110020	1 -- Thief's Gloves (2h)
-	2	72004	110020	1 -- Thief's Gloves (10h)
-	3	72005	110020	1 -- Thief's Gloves (30m)
-	4	72006	110020	1 -- Thief's Gloves (3h)
-}
-Group	도둑의장갑+50
-{
-	Vnum	110020
-	Type	ATTR
-	1	67	50 -- APPLY_MALL_ITEMBONUS
-}
-Group	육도
-{
-	Vnum	10010
-	Type	special
-	1	72043	110100	1 -- Book of the Leader (15m)
-	2	72044	110100	1 -- Book of the Leader (30m)
-	3	72045	110100	1 -- Book of the Leader (3h)
-	4	70003	110100	1 -- Book of the Leader (2h)
-	5	71012	110100	1 -- Book of the Leader (3h)
-	6	72302	110100	1 -- Book of the Leader (2h)
-	7	76011	110100	1 -- Book of the Leader (1h)
-	8	72059	110101	1 -- Book of the Leader+ (2h)
-	9	72060	110101	1 -- Book of the Leader+ (3h)
-}
-Group	웅귀족장소환서
-{
-	Vnum	71036
-	1	mob	691	100
-}
-Group	밀교교주소환서
-{
-	Vnum	71037
-	1	mob	791	100
-}
-Group	여왕거미소환서
-{
-	Vnum	71038
-	1	mob	2091	100
-}
-Group	거대사막거북소환서
-{
-	Vnum	71039
-	1	mob	2191	100
-}
-Group	화염왕소환서
-{
-	Vnum	71040
-	1	mob	2206	100
-}
-Group	구미호소환서
-{
-	Vnum	71041
-	1	mob	1901	100
-}
-Group	사귀왕소환서
-{
-	Vnum	71042
-	1	mob	1096	100
-}
-Group	누렁범귀소환서
-{
-	Vnum	71043
-	1	mob	1304	100
-}
-Group	화석목광맥소환서
-{
-	Vnum	71057
-	1	mob	20049	100
-}
-Group	구리광맥소환서
-{
-	Vnum	71058
-	1	mob	20050	100
-}
-Group	은맥소환서
-{
-	Vnum	71059
-	1	mob	20051	100
-}
-Group	금맥소환서
-{
-	Vnum	71060
-	1	mob	20052	100
-}
-Group	옥석맥소환서
-{
-	Vnum	71061
-	1	mob	20053	100
-}
-Group	흑단석맥소환서
-{
-	Vnum	71062
-	1	mob	20054	100
-}
-Group	조개무더기소환서
-{
-	Vnum	71063
-	1	mob	20055	100
-}
-Group	백금맥소환서
-{
-	Vnum	71064
-	1	mob	20056	100
-}
-Group	수정석맥소환서
-{
-	Vnum	71065
-	1	mob	20057	100
-}
-Group	자수정석맥소환서
-{
-	Vnum	71066
-	1	mob	20058	100
-}
-Group	천루광맥소환서
-{
-	Vnum	71067
-	1	mob	20059	100
-}
-Group	초급메틴석소환서
-{
-	Vnum	71080
-	1	mob	8001	10
-	2	mob	8002	10
-	3	mob	8003	10
-	4	mob	8004	10
-	5	mob	8005	10
-}
-Group	중급메틴석소환서
-{
-	Vnum	71081
-	1	mob	8006	10
-	2	mob	8007	10
-	3	mob	8008	10
-	4	mob	8009	10
-	5	mob	8010	10
-}
-Group	고급메틴석소환서
-{
-	Vnum	71082
-	1	mob	8011	10
-	2	mob	8012	10
-	3	mob	8013	10
-	4	mob	8014	10
-	5	mob	8024	10
-	6	mob	8025	10
-	7	mob	8026	10
-	8	mob	8027	10
-}
-Group	금장보물상자
-{
-	Vnum	50006 -- Gold Treasure Chest
-	1	50300	1	100 -- Skill Book
-	2	80008	1	10 -- Lump of Gold
-	3	50002	1	10 -- Gold Ring
-	4	70012	1	10 -- Goddess Tear
-	5	70008	1	10 -- White Flag
-	6	70038	1	10 -- Bravery Cape
-	7	70048	1	10 -- Cloak of Secrecy
-	8	70049	1	10 -- Lucy's Ring
-	9	70050	1	10 -- Sage King's Symbol
-	10	70051	1	10 -- Sage King's Glove
-	11	경험치	10000	30 -- Exp.
-	12	경험치	20000	30 -- Exp.
-	13	경험치	30000	30 -- Exp.
-	14	경험치	40000	30 -- Exp.
-	15	경험치	50000	30 -- Exp.
-	16	돈꾸러미	60000	15 -- Yang
-	17	돈꾸러미	70000	15 -- Yang
-	18	돈꾸러미	80000	15 -- Yang
-	19	돈꾸러미	90000	15 -- Yang
-	20	돈꾸러미	100000	15 -- Yang
-	21	25040	1	30 -- Blessing Scroll
-	22	121	1	8	40 -- Flying Wizard Sword+1
-	23	122	1	5	40 -- Flying Wizard Sword+2
-	24	1081	1	8	40 -- Rib Knife+1
-	25	1082	1	5	40 -- Rib Knife+2
-	26	3111	1	8	40 -- Salvation Blade+1
-	27	3112	1	5	40 -- Salvation Blade+2
-	28	2111	1	8	40 -- Unicorn Bow+1
-	29	2112	1	5	40 -- Unicorn Bow+2
-	30	5071	1	8	40 -- Golden Bug Bell+1
-	31	5072	1	5	40 -- Golden Bug Bell+2
-	32	7111	1	8	40 -- Eyebrow Fan+1
-	33	7112	1	5	40 -- Eyebrow Fan+2
-	34	30023	1	10 -- White Tiger Hide
-	35	30045	1	10 -- Scorpion Needle
-	36	30038	1	10 -- Tiger Hide
-	37	30051	1	10 -- Unknown Talisman
-	38	30011	1	10 -- Ball
-	39	30070	1	10 -- Wolf Fur+
-	40	30017	1	10 -- Ornamental Hairpin
-	41	30033	1	10 -- Broken Porcelain
-	42	30055	1	10 -- Scorpion Claw
-	43	30053	1	10 -- Bear Foot Skin
-	44	30007	1	10 -- Orc Amulet
-	45	30031	1	10 -- Ornament
-	46	30028	1	10 -- Wolf Claw
-	47	30047	1	10 -- Curse Book
-	48	30052	1	10 -- Flag
-	49	30027	1	10 -- Wolf Fur
-	50	30003	1	10 -- Pig Nose
-	51	30081	1	10 -- Scorpion Tail+
-	52	30022	1	10 -- Snake Tail
-	53	30010	1	10 -- Bear Gall
-	54	30025	1	10 -- Spider's Poison Sack
-	55	30004	1	10 -- Wild Boar Tooth
-	56	30050	1	10 -- Ice Marble
-	57	30075	1	40 -- Shiriken+
-}
-Group	은장보물상자
-{
-	Vnum	50007 -- Silver Treasure Chest
-	1	27001	50	43 -- Red Potion (S)
-	2	27002	30	43 -- Red Potion (M)
-	3	27003	20	43 -- Red Potion (L)
-	4	27004	50	43 -- Blue Potion (S)
-	5	27005	30	43 -- Blue Potion (M)
-	6	27006	20	43 -- Blue Potion (L)
-	7	경험치	5000	75 -- Exp.
-	8	경험치	10000	75 -- Exp.
-	9	경험치	15000	75 -- Exp.
-	10	경험치	20000	75 -- Exp.
-	11	돈꾸러미	10000	40 -- Yang
-	12	돈꾸러미	15000	40 -- Yang
-	13	돈꾸러미	20000	40 -- Yang
-	14	돈꾸러미	25000	40 -- Yang
-	15	돈꾸러미	30000	40 -- Yang
-	16	30030	1	12 -- Rusty Blade
-	17	30032	1	12 -- Black Uniform
-	18	30059	1	12 -- Spider Legs
-	19	30056	1	12 -- Spider Web
-	20	30071	1	12 -- Bear Gall+
-	21	30075	1	12 -- Shiriken+
-	22	30014	1	12 -- Yeti Fur
-	23	30061	1	12 -- Frog's Legs
-	24	30083	1	12 -- Unknown Medicine+
-	25	30074	1	12 -- Black Uniform+
-	26	30057	1	12 -- Spider Eyes
-	27	30016	1	12 -- Demon's Gem
-	28	30048	1	12 -- Piece of Ice
-	29	30009	1	12 -- Unknown Medicine
-	30	30037	1	12 -- Tiger Claw
-	31	30039	1	12 -- Piece of Fabric
-}
-Group	금장보물상자+
-{
-	Vnum	50012 -- Gold Treasure Chest+
-	1	50401	1	20 -- Three-Way Cut Manual
-	2	50402	1	20 -- Sword Spin Manual
-	3	50403	1	20 -- Berserk Manual
-	4	50404	1	20 -- Aura of the Sword Manual
-	5	50405	1	20 -- Dash Manual
-	6	50406	1	20 -- Life Force Manual
-	7	50416	1	20 -- Strike Manual
-	8	50417	1	20 -- Bash Manual
-	9	50418	1	20 -- Pounding Manual
-	10	50419	1	20 -- Strong Body Manual
-	11	50420	1	20 -- Sword Strike Manual
-	12	50421	1	20 -- Sword Orb Manual
-	13	50431	1	20 -- Ambush Manual
-	14	50432	1	20 -- Fast Attack Manual
-	15	50433	1	20 -- Rolling Dagger Manual
-	16	50434	1	20 -- Disguise Manual
-	17	50435	1	20 -- Poisonous Cloud Manual
-	18	50436	1	20 -- Insidious Poison Manual
-	19	50446	1	20 -- Repetitive Shot Manual
-	20	50447	1	20 -- Arrow Shower Manual
-	21	50448	1	20 -- Fire Arrow Manual
-	22	50449	1	20 -- Feather Walk Manual
-	23	50450	1	20 -- Poison Arrow Manual
-	24	50451	1	20 -- Spark Manual
-	25	50461	1	20 -- Finger Strike Manual
-	26	50462	1	20 -- Dragon Swirl Manual
-	27	50463	1	20 -- Enchanted Blade Manual
-	28	50464	1	20 -- Fear Manual
-	29	50465	1	20 -- Enchanted Armour Manual
-	30	50466	1	20 -- Dispel Manual
-	31	50476	1	20 -- Dark Strike Manual
-	32	50477	1	20 -- Flame Strike Manual
-	33	50478	1	20 -- Flame Spirit Manual
-	34	50479	1	20 -- Dark Protection Manual
-	35	50480	1	20 -- Spirit Strike Manual
-	36	50481	1	20 -- Dark Orb Manual
-	37	50491	1	20 -- Flying Talisman Manual
-	38	50492	1	20 -- Shooting Dragon Manual
-	39	50493	1	20 -- Dragon's Roar Manual
-	40	50494	1	20 -- Blessing Manual
-	41	50495	1	20 -- Reflect Manual
-	42	50496	1	20 -- Dragon's Aid Manual
-	43	50506	1	20 -- Lightning Throw Manual
-	44	50507	1	20 -- Summon Lightning Manual
-	45	50508	1	20 -- Lightning Claw Manual
-	46	50509	1	20 -- Cure Manual
-	47	50510	1	20 -- Swiftness Manual
-	48	50511	1	20 -- Attack Manual
-	49	50530	1	20 -- Shred Manual
-	50	50531	1	20 -- Wolf's Breath Manual
-	51	50532	1	20 -- Wolf Pounce Manual
-	52	50533	1	20 -- Wolf's Claw Manual
-	53	50534	1	20 -- Crimson Wolf Soul Manual
-	54	50535	1	20 -- Indigo Wolf Soul Manual
-	55	25040	1	75 -- Blessing Scroll
-	56	6032	1	46	40 -- Steel Claw+2
-	57	6033	1	20	40 -- Steel Claw+3
-	58	132	1	46	40 -- Half Moon Sword+2
-	59	133	1	20	40 -- Half Moon Sword+3
-	60	1092	1	46	40 -- Chakram+2
-	61	1093	1	20	40 -- Chakram+3
-	62	3122	1	46	40 -- Lion Slayer+2
-	63	3123	1	20	40 -- Lion Slayer+3
-	64	2122	1	46	40 -- Giant Wing Bow+2
-	65	2123	1	20	40 -- Giant Wing Bow+3
-	66	5082	1	46	40 -- Steel Bug Bell+2
-	67	5083	1	20	40 -- Steel Bug Bell+3
-	68	7122	1	46	40 -- Sun Fan+2
-	69	7123	1	20	40 -- Sun Fan+3
-	70	13202	1	150	40 -- Black Round Shield+2
-	71	13203	1	50	40 -- Black Round Shield+3
-}
-Group	은장보물상자+
-{
-	Vnum	50013 -- Silver Treasure Chest+
-	1	70012	1	57 -- Goddess Tear
-	2	70008	1	57 -- White Flag
-	3	70038	1	57 -- Bravery Cape
-	4	70048	1	57 -- Cloak of Secrecy
-	5	70049	1	57 -- Lucy's Ring
-	6	70050	1	57 -- Sage King's Symbol
-	7	70051	1	57 -- Sage King's Glove
-	8	13192	1	150 -- Pentagon Shield+2
-	9	13193	1	50 -- Pentagon Shield+3
-	10	12222	1	37	40 -- Iron Helmet+2
-	11	12223	1	38	40 -- Iron Helmet+3
-	12	12362	1	37	40 -- Chain Hood+2
-	13	12363	1	38	40 -- Chain Hood+3
-	14	12502	1	37	40 -- Mocking Helmet+2
-	15	12503	1	38	40 -- Mocking Helmet+3
-	16	12642	1	37	40 -- Phoenix Hat+2
-	17	12643	1	38	40 -- Phoenix Hat+3
-	18	21512	1	37	40 -- Ebon Cloth Helmet+2
-	19	21513	1	38	40 -- Ebon Cloth Helmet+3
-	20	30015	1	40 -- Demon's Keepsake
-	21	30035	1	40 -- Face Cream
-	22	30058	1	40 -- Spider Egg Sack
-	23	30006	1	40 -- Orc Tooth
-	24	30082	1	40 -- Snake Tail+
-	25	30076	1	40 -- Orc Amulet+
-	26	30018	1	40 -- Red Hairband
-	27	30046	1	40 -- Scorpion Tail
-	28	30086	1	40 -- Demon's Keepsake+
-	29	30072	1	40 -- Bear Foot Skin+
-	30	30080	1	40 -- Curse Book+
-	31	30077	1	40 -- Orc Tooth+
-	32	30069	1	40 -- Wolf Claw+
-	33	30067	1	40 -- Snakeskin
-	34	30075	1	40 -- Shiriken+
-}
-Group	eva_box
-{
-	Vnum	50124 -- Rotten Wooden Box
-	1	71114	5	40 -- Wild Boar (yellow)
-	2	71116	5	30 -- Wolf (yellow)
-	3	71118	5	20 -- Tiger (yellow)
-	4	71120	5	10 -- Lion (yellow)
-}
-Group	부서진_팔찌_상자
-{
-	Vnum	50120 -- Iron Casket
-	1	14085	1	7 -- Jade Bracelet+5
-	2	14185	1	7 -- Amethyst Bracelet+5
-	3	14125	1	7 -- Pearl Bracelet+5
-	4	14142	1	7 -- White Gold Bracelet+2
-	5	14164	1	7 -- Crystal Bracelet+4
-	6	14184	1	7 -- Amethyst Bracelet+4
-	7	14202	1	7 -- Heaven's Tear Bracelet+2
-	8	30190	1	2 -- Blood Stone
-	9	71018	1	6 -- Blessing of Life
-	10	71019	1	6 -- Blessing of Magic
-	11	71044	1	6 -- Critical Strike
-	12	71004	1	6 -- Medal of the Dragon
-	13	72003	1	3 -- Experience Ring (3h)
-	14	72006	1	3 -- Thief's Gloves
-	15	71017	1	3 -- Lucky Medal
-	16	72015	1	3 -- Fishing Book
-	17	72012	1	3 -- Lovebird Feather
-	18	27987	1	7 -- Clam
-	19	71082	1	3 -- Metin Stone(H)
-}
-Group	부서진_목걸이_상자
-{
-	Vnum	50121 -- Iron Box
-	1	16045	1	7 -- Silver Necklace+5
-	2	16065	1	7 -- Golden Necklace+5
-	3	16084	1	7 -- Jade Necklace+4
-	4	16104	1	7 -- Ebony Necklace+4
-	5	16124	1	7 -- Pearl Necklace+4
-	6	16144	1	7 -- White Gold Necklace+4
-	7	16164	1	7 -- Crystal Necklace+4
-	8	16184	1	7 -- Amethyst Necklace+4
-	9	16202	1	7 -- Heaven's Tear Necklace+2
-	10	25040	1	3 -- Blessing Scroll
-	11	70024	1	3 -- Blessing Marble
-	12	71004	1	6 -- Medal of the Dragon
-	13	72003	1	3 -- Experience Ring (3h)
-	14	71016	1	3 -- Thief's Gloves
-	15	71017	1	3 -- Lucky Medal
-	16	72015	1	3 -- Fishing Book
-	17	72012	1	3 -- Lovebird Feather
-	18	27987	1	7 -- Clam
-	19	71082	1	3 -- Metin Stone(H)
-}
-Group	부서진_귀걸이_상자
-{
-	Vnum	50122 -- Iron Chest
-	1	17084	1	7 -- Jade Earrings+4
-	2	17102	1	7 -- Ebony Earrings+2
-	3	17124	1	7 -- Pearl Earrings+4
-	4	17144	1	7 -- White Gold Earrings+4
-	5	17164	1	7 -- Crystal Earrings+4
-	6	17184	1	7 -- Amethyst Earrings+4
-	7	17202	1	7 -- Heaven's Tear Earrings+2
-	8	71034	1	6 -- Potion of Attack +15
-	9	71101	1	6 -- Potion of Haste
-	10	71020	1	6 -- Blessing of the Dragon
-	11	50124	1	5 -- Rotten Wooden Box
-	12	71004	1	5 -- Medal of the Dragon
-	13	72003	1	3 -- Experience Ring (3h)
-	14	71016	1	3 -- Thief's Gloves
-	15	71017	1	3 -- Lucky Medal
-	16	72015	1	3 -- Fishing Book
-	17	72012	1	3 -- Lovebird Feather
-	18	27987	1	5 -- Clam
-	19	71082	1	3 -- Metin Stone(H)
-}
+Group	lv1
+{
+	Vnum	50187 -- Apprentice Chest I
+	Type	Pct
+	1	50188	1	100 -- Apprentice Chest II
+	2	27201	20	100 -- Red Potion (S)
+	3	27204	20	100 -- Blue Potion (S)
+	4	27207	10	100 -- Green Potion (S)
+	5	27210	10	100 -- Purple Potion (S)
+	6	71155	1	100 -- Potion of Wisdom (3h)
+}
+Group	lv10
+{
+	Vnum	50188 -- Apprentice Chest II
+	Type	Pct
+	1	50189	1	100 -- Apprentice Chest III
+	2	76021	1	100 -- Sun Elixir (S)
+	3	76017	5	100 -- Potion of Attack +15
+	4	76012	5	100 -- Potion of Speed
+	5	76008	3	100 -- Medal of the Dragon
+	6	71153	3	100 -- Potion of Wisdom
+	7	56000	1	100 -- Appaloosa
+	8	56001	1	100 -- Village Travel Ticket
+}
+Group	lv20
+{
+	Vnum	50189 -- Apprentice Chest III
+	Type	Pct
+	1	50190	1	100 -- Expert Chest I
+	2	76022	1	100 -- Sun Elixir (M)
+	3	76017	5	100 -- Potion of Attack +15
+	4	76012	5	100 -- Potion of Speed
+	5	76006	1	100 -- Compass for Metin Stones
+	6	76007	1	100 -- Bravery Cape
+	7	38059	1	100 -- Emotion Mask
+	8	71153	3	100 -- Potion of Wisdom
+	9	56001	1	100 -- Village Travel Ticket
+	10	38100	1	100 -- Power Snack (7 days)
+}
+Group	lv30
+{
+	Vnum	50190 -- Expert Chest I
+	Type	Pct
+	1	50191	1	100 -- Expert Chest II
+	2	76012	5	100 -- Potion of Speed
+	3	71034	5	100 -- Potion of Attack +15
+	4	76016	5	100 -- Blessing Scroll
+	5	76011	1	100 -- Book of the Leader
+	6	76007	20	100 -- Bravery Cape
+	7	56001	1	100 -- Village Travel Ticket
+}
+Group	lv40
+{
+	Vnum	50191 -- Expert Chest II
+	Type	Pct
+	1	50192	1	100 -- Expert Chest III
+	2	76003	5	100 -- Potion of Haste
+	3	71034	5	100 -- Potion of Attack +15
+	4	71153	3	100 -- Potion of Wisdom
+	5	76011	1	100 -- Book of the Leader
+	6	76016	5	100 -- Blessing Scroll
+	7	76024	3	100 -- Green Strength
+	8	76023	3	100 -- Green Magic
+	9	76026	3	100 -- Exorcism Scroll
+}
+Group	lv50
+{
+	Vnum	50192 -- Expert Chest III
+	Type	Pct
+	1	50193	1	100 -- Master Chest I
+	2	76007	20	100 -- Bravery Cape
+	3	76003	5	100 -- Potion of Haste
+	4	71034	5	100 -- Potion of Attack +15
+	5	76019	5	100 -- Passage Ticket
+	6	76042	1	100 -- Teleportation Ring
+	7	76026	5	100 -- Exorcism Scroll
+	8	76036	5	100 -- Dragon God Attack
+	9	76035	5	100 -- Dragon God Life
+	10	76037	1	100 -- Thief's Gloves
+	11	76038	1	100 -- Lucky Medal
+}
+Group	lv60
+{
+	Vnum	50193 -- Master Chest I
+	Type	Pct
+	1	50194	1	100 -- Master Chest II
+	2	76009	3	100 -- Dragon Scroll
+	3	71034	5	100 -- Potion of Attack +15
+	4	76000	10	100 -- Peach Flower Wine
+	5	76003	5	100 -- Potion of Haste
+	6	76012	5	100 -- Potion of Speed
+	7	76026	5	100 -- Exorcism Scroll
+	8	76036	5	100 -- Dragon God Attack
+	9	76035	5	100 -- Dragon God Life
+	10	76037	1	100 -- Thief's Gloves
+	11	76038	1	100 -- Lucky Medal
+}
+Group	lv70
+{
+	Vnum	50194 -- Master Chest II
+	Type	Pct
+	1	50195	1	100 -- Master Chest III
+	2	76003	5	100 -- Potion of Haste
+	3	71034	5	100 -- Potion of Attack +15
+	4	76013	5	100 -- Reinforce Item (b)
+	5	76014	5	100 -- Enchant Item (b)
+	6	76001	1	100 -- Status Reset Document
+	7	76012	5	100 -- Potion of Speed
+	8	76026	5	100 -- Exorcism Scroll
+	9	76034	5	100 -- Concentrated Reading
+	10	76036	5	100 -- Dragon God Attack
+	11	76035	5	100 -- Dragon God Life
+	12	76037	1	100 -- Thief's Gloves
+	13	76038	1	100 -- Lucky Medal
+}
+Group	lv80
+{
+	Vnum	50195 -- Master Chest III
+	Type	Pct
+	1	50196	1	100 -- Grand Master Chest
+	2	76003	5	100 -- Potion of Haste
+	3	71034	5	100 -- Potion of Attack +15
+	4	76005	1	100 -- Moon Elixir (M)
+	5	76020	5	100 -- Researcher's Elixir
+	6	76013	5	100 -- Reinforce Item (b)
+	7	76014	5	100 -- Enchant Item (b)
+	8	76012	5	100 -- Potion of Speed
+	9	76026	5	100 -- Exorcism Scroll
+	10	76034	5	100 -- Concentrated Reading
+	11	76036	5	100 -- Dragon God Attack
+	12	76035	5	100 -- Dragon God Life
+	13	76037	1	100 -- Thief's Gloves
+	14	76038	1	100 -- Lucky Medal
+	15	76039	1	100 -- Dragon Chest
+}
+Group	lv90
+{
+	Vnum	50196 -- Grand Master Chest
+	Type	Pct
+	1	76022	1	100 -- Sun Elixir (M)
+	2	76015	2	100 -- Blessing Marble
+	3	76010	3	100 -- Blood Stone
+	4	76002	3	100 -- Shrunken Head
+	5	76013	5	100 -- Reinforce Item (b)
+	6	76014	10	100 -- Enchant Item (b)
+	7	76036	5	100 -- Dragon God Attack
+	8	76035	5	100 -- Dragon God Life
+	9	76019	5	100 -- Passage Ticket
+	10	76039	1	100 -- Dragon Chest
+}
+Group	퓨
+{
+	Vnum	50070 -- Chief Orc's Box
+	1	3140	1	30	30 -- Electromagnetic Blade+0
+	2	3141	1	16	30 -- Electromagnetic Blade+1
+	3	1110	1	30	30 -- Lightning Knife+0
+	4	1111	1	16	30 -- Lightning Knife+1
+	5	2130	1	30	30 -- Divine Apricot Bow+0
+	6	2131	1	16	30 -- Divine Apricot Bow+1
+	7	7140	1	30	30 -- Salvation Fan+0
+	8	7141	1	16	30 -- Salvation Fan+1
+	9	5100	1	30	30 -- Heaven and Earth Bell+0
+	10	5101	1	16	30 -- Heaven and Earth Bell+1
+	11	160	1	30	30 -- Nymph Sword+0
+	12	161	1	16	30 -- Nymph Sword+1
+	13	240	1	30	30 -- Exorcism Sword+0
+	14	241	1	16	30 -- Exorcism Sword+1
+	15	6040	1	33	30 -- Griffon Claw+0
+	16	6041	1	15	30 -- Griffon Claw+1
+	17	11671	1	30	30 -- Ghost Mask Armour+1
+	18	11672	1	5	30 -- Ghost Mask Armour+2
+	19	11271	1	30	30 -- Gold Plate Armour+1
+	20	11272	1	5	30 -- Gold Plate Armour+2
+	21	11471	1	30	30 -- Killer Wind Suit+1
+	22	11472	1	5	30 -- Killer Wind Suit+2
+	23	11871	1	30	30 -- Orange Cat Dress+1
+	24	11872	1	5	30 -- Orange Cat Dress+2
+	25	21051	1	30	30 -- Hobgoblin Plate Armour+1
+	26	21052	1	5	30 -- Hobgoblin Plate Armour+2
+	27	16161	1	30	30 -- Crystal Necklace+1
+	28	16162	1	16	30 -- Crystal Necklace+2
+	29	16163	1	7	30 -- Crystal Necklace+3
+	30	17161	1	30	30 -- Crystal Earrings+1
+	31	17162	1	16	30 -- Crystal Earrings+2
+	32	17163	1	7	30 -- Crystal Earrings+3
+	33	14161	1	30	30 -- Crystal Bracelet+1
+	34	14162	1	16	30 -- Crystal Bracelet+2
+	35	14163	1	7	30 -- Crystal Bracelet+3
+	36	70012	1	25 -- Goddess Tear
+	37	70038	1	25 -- Bravery Cape
+	38	25040	1	30 -- Blessing Scroll
+	39	70048	1	25 -- Cloak of Secrecy
+	40	70037	1	30 -- Book of Forgetfulness
+	41	70014	1	30 -- Blood Pill
+	42	70043	1	25 -- Thief's Gloves
+	43	70005	1	25 -- Experience Ring (1h)
+	44	70006	1	25 -- Language Ring
+	45	慕	50000	20 -- Yang
+	46	慕	100000	70 -- Yang
+	47	慕	200000	9 -- Yang
+	48	27112	10	30 -- Green Potion (L)
+	49	치	100000	10 -- Exp.
+	50	60004	1	3	15 -- Looking Glass
+	51	80019	1	3	15 -- Fine Cloth
+	52	38060	1	3	15 -- Bag of Emotions
+}
+Group	閨퓨
+{
+	Vnum	50071 -- Esoteric Leader's Box
+	1	3141	1	33	30 -- Electromagnetic Blade+1
+	2	3142	1	15	30 -- Electromagnetic Blade+2
+	3	1111	1	33	30 -- Lightning Knife+1
+	4	1112	1	15	30 -- Lightning Knife+2
+	5	2131	1	33	30 -- Divine Apricot Bow+1
+	6	2132	1	15	30 -- Divine Apricot Bow+2
+	7	7141	1	33	30 -- Salvation Fan+1
+	8	7142	1	15	30 -- Salvation Fan+2
+	9	5101	1	33	30 -- Heaven and Earth Bell+1
+	10	5102	1	15	30 -- Heaven and Earth Bell+2
+	11	161	1	33	30 -- Nymph Sword+1
+	12	162	1	15	30 -- Nymph Sword+2
+	13	241	1	33	30 -- Exorcism Sword+1
+	14	242	1	15	30 -- Exorcism Sword+2
+	15	6041	1	33	30 -- Griffon Claw+1
+	16	6042	1	15	30 -- Griffon Claw+2
+	17	11672	1	27	30 -- Ghost Mask Armour+2
+	18	11673	1	14	30 -- Ghost Mask Armour+3
+	19	11674	1	5	30 -- Ghost Mask Armour+4
+	20	11272	1	27	30 -- Gold Plate Armour+2
+	21	11273	1	14	30 -- Gold Plate Armour+3
+	22	11274	1	5	30 -- Gold Plate Armour+4
+	23	11472	1	27	30 -- Killer Wind Suit+2
+	24	11473	1	14	30 -- Killer Wind Suit+3
+	25	11474	1	5	30 -- Killer Wind Suit+4
+	26	11872	1	27	30 -- Orange Cat Dress+2
+	27	11873	1	14	30 -- Orange Cat Dress+3
+	28	11874	1	5	30 -- Orange Cat Dress+4
+	29	21052	1	27	30 -- Hobgoblin Plate Armour+2
+	30	21053	1	14	30 -- Hobgoblin Plate Armour+3
+	31	21054	1	5	30 -- Hobgoblin Plate Armour+4
+	32	16181	1	30	30 -- Amethyst Necklace+1
+	33	16182	1	20	30 -- Amethyst Necklace+2
+	34	16183	1	5	30 -- Amethyst Necklace+3
+	35	17181	1	30	30 -- Amethyst Earrings+1
+	36	17182	1	20	30 -- Amethyst Earrings+2
+	37	17183	1	5	30 -- Amethyst Earrings+3
+	38	14181	1	30	30 -- Amethyst Bracelet+1
+	39	14182	1	20	30 -- Amethyst Bracelet+2
+	40	14183	1	5	30 -- Amethyst Bracelet+3
+	41	70012	1	25 -- Goddess Tear
+	42	70038	1	25 -- Bravery Cape
+	43	25040	1	30 -- Blessing Scroll
+	44	70048	1	25 -- Cloak of Secrecy
+	45	70037	1	30 -- Book of Forgetfulness
+	46	70014	1	30 -- Blood Pill
+	47	70043	1	25 -- Thief's Gloves
+	48	70005	1	25 -- Experience Ring (1h)
+	49	慕	50000	30 -- Yang
+	50	慕	100000	10 -- Yang
+	51	慕	200000	20 -- Yang
+	52	치	150000	7 -- Exp.
+	53	치	200000	8 -- Exp.
+	54	27112	15	25 -- Green Potion (L)
+	55	60004	1	3	15 -- Looking Glass
+	56	80019	1	3	15 -- Fine Cloth
+	57	38060	1	3	15 -- Bag of Emotions
+}
+Group	卵탁퓨
+{
+	Vnum	50073 -- Queen Spider Box
+	1	3142	1	30	30 -- Electromagnetic Blade+2
+	2	3143	1	16	30 -- Electromagnetic Blade+3
+	3	1112	1	30	30 -- Lightning Knife+2
+	4	1113	1	16	30 -- Lightning Knife+3
+	5	2132	1	30	30 -- Divine Apricot Bow+2
+	6	2133	1	16	30 -- Divine Apricot Bow+3
+	7	7142	1	30	30 -- Salvation Fan+2
+	8	7143	1	16	30 -- Salvation Fan+3
+	9	5102	1	30	30 -- Heaven and Earth Bell+2
+	10	5103	1	16	30 -- Heaven and Earth Bell+3
+	11	162	1	30	30 -- Nymph Sword+2
+	12	163	1	16	30 -- Nymph Sword+3
+	13	242	1	30	30 -- Exorcism Sword+2
+	14	243	1	16	30 -- Exorcism Sword+3
+	15	6042	1	30	30 -- Griffon Claw+2
+	16	6043	1	16	30 -- Griffon Claw+3
+	17	6052	1	30	30 -- Scarab Claw+2
+	18	6053	1	16	30 -- Scarab Claw+3
+	19	11680	1	30	30 -- Spirit Plate Armour+0
+	20	11681	1	6	30 -- Spirit Plate Armour+1
+	21	11880	1	30	30 -- Baroness Dress+0
+	22	11881	1	6	30 -- Baroness Dress+1
+	23	11480	1	30	30 -- Fuchsia Suit+0
+	24	11481	1	6	30 -- Fuchsia Suit+1
+	25	11280	1	30	30 -- Dragon God Armour+0
+	26	11281	1	6	30 -- Dragon God Armour+1
+	27	21060	1	30	30 -- Firellium Plate Armour+0
+	28	21061	1	6	30 -- Firellium Plate Armour+1
+	29	16201	1	30	30 -- Heaven's Tear Necklace+1
+	30	16202	1	16	30 -- Heaven's Tear Necklace+2
+	31	16203	1	7	30 -- Heaven's Tear Necklace+3
+	32	17201	1	30	30 -- Heaven's Tear Earrings+1
+	33	17202	1	16	30 -- Heaven's Tear Earrings+2
+	34	17203	1	7	30 -- Heaven's Tear Earrings+3
+	35	14201	1	30	30 -- Heaven's Tear Bracelet+1
+	36	14202	1	16	30 -- Heaven's Tear Bracelet+2
+	37	14203	1	7	30 -- Heaven's Tear Bracelet+3
+	38	70012	1	25 -- Goddess Tear
+	39	70038	1	25 -- Bravery Cape
+	40	25040	1	30 -- Blessing Scroll
+	41	70048	1	25 -- Cloak of Secrecy
+	42	70037	1	30 -- Book of Forgetfulness
+	43	70014	1	30 -- Blood Pill
+	44	70043	1	25 -- Thief's Gloves
+	45	70005	1	25 -- Experience Ring (1h)
+	46	慕	50000	10 -- Yang
+	47	慕	100000	30 -- Yang
+	48	慕	150000	40 -- Yang
+	49	慕	200000	30 -- Yang
+	50	치	150000	10 -- Exp.
+	51	치	200000	20 -- Exp.
+	52	27112	15	20 -- Green Potion (L)
+	53	60004	1	3	15 -- Looking Glass
+	54	80019	1	3	15 -- Fine Cloth
+	55	38060	1	3	15 -- Bag of Emotions
+}
+Group	卵탁퓨
+{
+	Vnum	50074 -- Giant Spider Box
+	1	150	1	25	30 -- Ghost Fang Blade+0
+	2	151	1	13	30 -- Ghost Fang Blade+1
+	3	5090	1	25	30 -- Thunder Bird Bell+0
+	4	5091	1	13	30 -- Thunder Bird Bell+1
+	5	140	1	25	30 -- Battle Sword+0
+	6	141	1	13	30 -- Battle Sword+1
+	7	3130	1	25	30 -- Partisan+0
+	8	3131	1	13	30 -- Partisan+1
+	9	1100	1	25	30 -- Dragon Knife+0
+	10	1101	1	13	30 -- Dragon Knife+1
+	11	7130	1	25	30 -- Heavenly Bird Fan+0
+	12	7131	1	13	30 -- Heavenly Bird Fan+1
+	13	2140	1	25	30 -- Yellow Dragon Bow+0
+	14	2141	1	13	30 -- Yellow Dragon Bow+1
+	15	6040	1	25	30 -- Griffon Claw+0
+	16	6041	1	13	30 -- Griffon Claw+1
+	17	6050	1	25	30 -- Scarab Claw+0
+	18	6051	1	13	30 -- Scarab Claw+1
+	19	11681	1	17	30 -- Spirit Plate Armour+1
+	20	11682	1	27	30 -- Spirit Plate Armour+2
+	21	11683	1	11	30 -- Spirit Plate Armour+3
+	22	11881	1	17	30 -- Baroness Dress+1
+	23	11882	1	27	30 -- Baroness Dress+2
+	24	11883	1	11	30 -- Baroness Dress+3
+	25	11481	1	17	30 -- Fuchsia Suit+1
+	26	11482	1	27	30 -- Fuchsia Suit+2
+	27	11483	1	11	30 -- Fuchsia Suit+3
+	28	11281	1	17	30 -- Dragon God Armour+1
+	29	11282	1	27	30 -- Dragon God Armour+2
+	30	11283	1	11	30 -- Dragon God Armour+3
+	31	21061	1	17	30 -- Firellium Plate Armour+1
+	32	21062	1	27	30 -- Firellium Plate Armour+2
+	33	21063	1	11	30 -- Firellium Plate Armour+3
+	34	14163	1	23	30 -- Crystal Bracelet+3
+	35	14164	1	10	30 -- Crystal Bracelet+4
+	36	17163	1	23	30 -- Crystal Earrings+3
+	37	17164	1	10	30 -- Crystal Earrings+4
+	38	16163	1	23	30 -- Crystal Necklace+3
+	39	16164	1	10	30 -- Crystal Necklace+4
+	40	70012	1	25 -- Goddess Tear
+	41	70038	1	25 -- Bravery Cape
+	42	25040	1	30 -- Blessing Scroll
+	43	70048	1	25 -- Cloak of Secrecy
+	44	70037	1	30 -- Book of Forgetfulness
+	45	70014	1	30 -- Blood Pill
+	46	70043	1	25 -- Thief's Gloves
+	47	70005	1	25 -- Experience Ring (1h)
+	48	慕	100000	20 -- Yang
+	49	慕	150000	30 -- Yang
+	50	慕	200000	30 -- Yang
+	51	慕	250000	20 -- Yang
+	52	27112	20	20 -- Green Potion (L)
+	53	치	150000	30 -- Exp.
+	54	치	200000	30 -- Exp.
+	55	치	250000	20 -- Exp.
+	56	60004	1	3	15 -- Looking Glass
+	57	80019	1	3	15 -- Fine Cloth
+	58	38060	1	3	15 -- Bag of Emotions
+}
+Group	킴潁렴뵉
+{
+	Vnum	50076 -- Desert Tortoise Chest
+	1	3142	1	24	30 -- Electromagnetic Blade+2
+	2	3143	1	16	30 -- Electromagnetic Blade+3
+	3	1112	1	24	30 -- Lightning Knife+2
+	4	1113	1	16	30 -- Lightning Knife+3
+	5	2132	1	24	30 -- Divine Apricot Bow+2
+	6	2133	1	16	30 -- Divine Apricot Bow+3
+	7	7142	1	24	30 -- Salvation Fan+2
+	8	7143	1	16	30 -- Salvation Fan+3
+	9	5102	1	24	30 -- Heaven and Earth Bell+2
+	10	5103	1	16	30 -- Heaven and Earth Bell+3
+	11	162	1	24	30 -- Nymph Sword+2
+	12	163	1	16	30 -- Nymph Sword+3
+	13	242	1	24	30 -- Exorcism Sword+2
+	14	243	1	16	30 -- Exorcism Sword+3
+	15	6042	1	24	30 -- Griffon Claw+2
+	16	6043	1	16	30 -- Griffon Claw+3
+	17	6052	1	24	30 -- Scarab Claw+2
+	18	6053	1	16	30 -- Scarab Claw+3
+	19	11681	1	24	30 -- Spirit Plate Armour+1
+	20	11682	1	16	30 -- Spirit Plate Armour+2
+	21	11881	1	24	30 -- Baroness Dress+1
+	22	11882	1	16	30 -- Baroness Dress+2
+	23	11481	1	24	30 -- Fuchsia Suit+1
+	24	11482	1	16	30 -- Fuchsia Suit+2
+	25	11281	1	24	30 -- Dragon God Armour+1
+	26	11282	1	16	30 -- Dragon God Armour+2
+	27	21061	1	24	30 -- Firellium Plate Armour+1
+	28	21062	1	16	30 -- Firellium Plate Armour+2
+	29	17184	1	30	30 -- Amethyst Earrings+4
+	30	17185	1	18	30 -- Amethyst Earrings+5
+	31	17186	1	12	30 -- Amethyst Earrings+6
+	32	16184	1	30	30 -- Amethyst Necklace+4
+	33	16185	1	18	30 -- Amethyst Necklace+5
+	34	16186	1	12	30 -- Amethyst Necklace+6
+	35	14184	1	30	30 -- Amethyst Bracelet+4
+	36	14185	1	18	30 -- Amethyst Bracelet+5
+	37	14186	1	12	30 -- Amethyst Bracelet+6
+	38	70012	1	20 -- Goddess Tear
+	39	70038	1	20 -- Bravery Cape
+	40	25040	1	30 -- Blessing Scroll
+	41	70048	1	20 -- Cloak of Secrecy
+	42	70037	1	30 -- Book of Forgetfulness
+	43	70014	1	30 -- Blood Pill
+	44	70043	1	20 -- Thief's Gloves
+	45	70005	1	20 -- Experience Ring (1h)
+	46	치	100000	10 -- Exp.
+	47	치	150000	20 -- Exp.
+	48	치	200000	25 -- Exp.
+	49	치	250000	30 -- Exp.
+	50	慕	100000	10 -- Yang
+	51	慕	150000	20 -- Yang
+	52	慕	200000	25 -- Yang
+	53	慕	250000	30 -- Yang
+	54	27112	20	20 -- Green Potion (L)
+	55	60004	1	3	15 -- Looking Glass
+	56	80019	1	3	15 -- Fine Cloth
+	57	38060	1	3	15 -- Bag of Emotions
+}
+Group	호퓨
+{
+	Vnum	50077 -- Nine Tails' Chest
+	1	151	1	24	30 -- Ghost Fang Blade+1
+	2	152	1	16	30 -- Ghost Fang Blade+2
+	3	5091	1	24	30 -- Thunder Bird Bell+1
+	4	5092	1	16	30 -- Thunder Bird Bell+2
+	5	141	1	24	30 -- Battle Sword+1
+	6	142	1	16	30 -- Battle Sword+2
+	7	3131	1	24	30 -- Partisan+1
+	8	3132	1	16	30 -- Partisan+2
+	9	1101	1	24	30 -- Dragon Knife+1
+	10	1102	1	16	30 -- Dragon Knife+2
+	11	7131	1	24	30 -- Heavenly Bird Fan+1
+	12	7132	1	16	30 -- Heavenly Bird Fan+2
+	13	2141	1	24	30 -- Yellow Dragon Bow+1
+	14	2142	1	16	30 -- Yellow Dragon Bow+2
+	15	6041	1	24	30 -- Griffon Claw+1
+	16	6042	1	16	30 -- Griffon Claw+2
+	17	11682	1	24	30 -- Spirit Plate Armour+2
+	18	11683	1	16	30 -- Spirit Plate Armour+3
+	19	11882	1	24	30 -- Baroness Dress+2
+	20	11883	1	16	30 -- Baroness Dress+3
+	21	11482	1	24	30 -- Fuchsia Suit+2
+	22	11483	1	16	30 -- Fuchsia Suit+3
+	23	11282	1	24	30 -- Dragon God Armour+2
+	24	11283	1	16	30 -- Dragon God Armour+3
+	25	21062	1	16	30 -- Firellium Plate Armour+2
+	26	21063	1	24	30 -- Firellium Plate Armour+3
+	27	17204	1	30	30 -- Heaven's Tear Earrings+4
+	28	17205	1	18	30 -- Heaven's Tear Earrings+5
+	29	17206	1	12	30 -- Heaven's Tear Earrings+6
+	30	16204	1	30	30 -- Heaven's Tear Necklace+4
+	31	16205	1	18	30 -- Heaven's Tear Necklace+5
+	32	16206	1	12	30 -- Heaven's Tear Necklace+6
+	33	14204	1	30	30 -- Heaven's Tear Bracelet+4
+	34	14205	1	18	30 -- Heaven's Tear Bracelet+5
+	35	14206	1	12	30 -- Heaven's Tear Bracelet+6
+	36	70012	1	25 -- Goddess Tear
+	37	70038	1	25 -- Bravery Cape
+	38	25040	1	30 -- Blessing Scroll
+	39	70048	1	25 -- Cloak of Secrecy
+	40	70037	1	30 -- Book of Forgetfulness
+	41	70014	1	30 -- Blood Pill
+	42	70043	1	25 -- Thief's Gloves
+	43	70005	1	25 -- Experience Ring (1h)
+	44	치	150000	20 -- Exp.
+	45	치	200000	30 -- Exp.
+	46	치	250000	20 -- Exp.
+	47	慕	150000	20 -- Yang
+	48	慕	200000	30 -- Yang
+	49	慕	250000	20 -- Yang
+	50	27112	20	25 -- Green Potion (L)
+	51	60004	1	3	15 -- Looking Glass
+	52	80019	1	3	15 -- Fine Cloth
+	53	38060	1	3	15 -- Bag of Emotions
+}
+Group	퓨
+{
+	Vnum	50078 -- Yellow Tiger's Chest
+	1	152	1	22	30 -- Ghost Fang Blade+2
+	2	153	1	16	30 -- Ghost Fang Blade+3
+	3	5092	1	22	30 -- Thunder Bird Bell+2
+	4	5093	1	16	30 -- Thunder Bird Bell+3
+	5	142	1	22	30 -- Battle Sword+2
+	6	143	1	16	30 -- Battle Sword+3
+	7	3132	1	22	30 -- Partisan+2
+	8	3133	1	16	30 -- Partisan+3
+	9	1102	1	22	30 -- Dragon Knife+2
+	10	1103	1	16	30 -- Dragon Knife+3
+	11	7132	1	22	30 -- Heavenly Bird Fan+2
+	12	7133	1	16	30 -- Heavenly Bird Fan+3
+	13	2142	1	22	30 -- Yellow Dragon Bow+2
+	14	2143	1	16	30 -- Yellow Dragon Bow+3
+	15	6052	1	22	30 -- Scarab Claw+2
+	16	6053	1	16	30 -- Scarab Claw+3
+	17	6062	1	22	30 -- Hawk Claw+2
+	18	6063	1	16	30 -- Hawk Claw+3
+	19	11682	1	19	30 -- Spirit Plate Armour+2
+	20	11683	1	28	30 -- Spirit Plate Armour+3
+	21	11684	1	10	30 -- Spirit Plate Armour+4
+	22	11882	1	19	30 -- Baroness Dress+2
+	23	11883	1	28	30 -- Baroness Dress+3
+	24	11884	1	10	30 -- Baroness Dress+4
+	25	11482	1	19	30 -- Fuchsia Suit+2
+	26	11483	1	28	30 -- Fuchsia Suit+3
+	27	11484	1	10	30 -- Fuchsia Suit+4
+	28	11282	1	19	30 -- Dragon God Armour+2
+	29	11283	1	28	30 -- Dragon God Armour+3
+	30	11284	1	10	30 -- Dragon God Armour+4
+	31	21062	1	19	30 -- Firellium Plate Armour+2
+	32	21063	1	28	30 -- Firellium Plate Armour+3
+	33	21064	1	10	30 -- Firellium Plate Armour+4
+	34	17184	1	19	30 -- Amethyst Earrings+4
+	35	17185	1	28	30 -- Amethyst Earrings+5
+	36	17186	1	10	30 -- Amethyst Earrings+6
+	37	16184	1	19	30 -- Amethyst Necklace+4
+	38	16185	1	28	30 -- Amethyst Necklace+5
+	39	16186	1	10	30 -- Amethyst Necklace+6
+	40	14184	1	19	30 -- Amethyst Bracelet+4
+	41	14185	1	28	30 -- Amethyst Bracelet+5
+	42	14186	1	10	30 -- Amethyst Bracelet+6
+	43	70012	1	20 -- Goddess Tear
+	44	70038	1	20 -- Bravery Cape
+	45	25040	1	25 -- Blessing Scroll
+	46	70048	1	20 -- Cloak of Secrecy
+	47	70037	1	25 -- Book of Forgetfulness
+	48	70014	1	25 -- Blood Pill
+	49	70043	1	20 -- Thief's Gloves
+	50	70005	1	20 -- Experience Ring (1h)
+	51	치	200000	20 -- Exp.
+	52	치	250000	30 -- Exp.
+	53	치	300000	20 -- Exp.
+	54	慕	200000	20 -- Yang
+	55	慕	250000	30 -- Yang
+	56	慕	300000	20 -- Yang
+	57	27112	30	20 -- Green Potion (L)
+	58	60004	1	3	15 -- Looking Glass
+	59	80019	1	3	15 -- Fine Cloth
+	60	38060	1	3	15 -- Bag of Emotions
+}
+Group	화퓨
+{
+	Vnum	50079 -- Flame King's Chest
+	1	151	1	10	30 -- Ghost Fang Blade+1
+	2	152	1	25	30 -- Ghost Fang Blade+2
+	3	153	1	15	30 -- Ghost Fang Blade+3
+	4	5091	1	10	30 -- Thunder Bird Bell+1
+	5	5092	1	25	30 -- Thunder Bird Bell+2
+	6	5093	1	15	30 -- Thunder Bird Bell+3
+	7	141	1	10	30 -- Battle Sword+1
+	8	142	1	25	30 -- Battle Sword+2
+	9	143	1	15	30 -- Battle Sword+3
+	10	3131	1	10	30 -- Partisan+1
+	11	3132	1	25	30 -- Partisan+2
+	12	3133	1	15	30 -- Partisan+3
+	13	1101	1	10	30 -- Dragon Knife+1
+	14	1102	1	25	30 -- Dragon Knife+2
+	15	1103	1	15	30 -- Dragon Knife+3
+	16	7131	1	10	30 -- Heavenly Bird Fan+1
+	17	7132	1	25	30 -- Heavenly Bird Fan+2
+	18	7133	1	15	30 -- Heavenly Bird Fan+3
+	19	2141	1	10	30 -- Yellow Dragon Bow+1
+	20	2142	1	25	30 -- Yellow Dragon Bow+2
+	21	2143	1	15	30 -- Yellow Dragon Bow+3
+	22	6051	1	10	30 -- Scarab Claw+1
+	23	6052	1	25	30 -- Scarab Claw+2
+	24	6053	1	10	30 -- Scarab Claw+3
+	25	6061	1	10	30 -- Hawk Claw+1
+	26	6062	1	25	30 -- Hawk Claw+2
+	27	6063	1	15	30 -- Hawk Claw+3
+	28	11681	1	9	30 -- Spirit Plate Armour+1
+	29	11682	1	24	30 -- Spirit Plate Armour+2
+	30	11683	1	14	30 -- Spirit Plate Armour+3
+	31	11881	1	9	30 -- Baroness Dress+1
+	32	11882	1	24	30 -- Baroness Dress+2
+	33	11883	1	14	30 -- Baroness Dress+3
+	34	11481	1	9	30 -- Fuchsia Suit+1
+	35	11482	1	24	30 -- Fuchsia Suit+2
+	36	11483	1	14	30 -- Fuchsia Suit+3
+	37	11281	1	9	30 -- Dragon God Armour+1
+	38	11282	1	24	30 -- Dragon God Armour+2
+	39	11283	1	14	30 -- Dragon God Armour+3
+	40	21061	1	9	30 -- Firellium Plate Armour+1
+	41	21062	1	24	30 -- Firellium Plate Armour+2
+	42	21063	1	14	30 -- Firellium Plate Armour+3
+	43	17164	1	9	30 -- Crystal Earrings+4
+	44	17165	1	24	30 -- Crystal Earrings+5
+	45	17166	1	14	30 -- Crystal Earrings+6
+	46	16164	1	9	30 -- Crystal Necklace+4
+	47	16165	1	24	30 -- Crystal Necklace+5
+	48	16166	1	14	30 -- Crystal Necklace+6
+	49	14164	1	9	30 -- Crystal Bracelet+4
+	50	14165	1	24	30 -- Crystal Bracelet+5
+	51	14166	1	14	30 -- Crystal Bracelet+6
+	52	70012	1	15 -- Goddess Tear
+	53	70038	1	15 -- Bravery Cape
+	54	25040	1	21 -- Blessing Scroll
+	55	70048	1	20 -- Cloak of Secrecy
+	56	70037	1	25 -- Book of Forgetfulness
+	57	70014	1	25 -- Blood Pill
+	58	70043	1	20 -- Thief's Gloves
+	59	70005	1	20 -- Experience Ring (1h)
+	60	치	150000	5 -- Exp.
+	61	치	200000	10 -- Exp.
+	62	치	250000	10 -- Exp.
+	63	치	300000	15 -- Exp.
+	64	慕	150000	20 -- Yang
+	65	慕	200000	25 -- Yang
+	66	慕	250000	30 -- Yang
+	67	慕	300000	25 -- Yang
+	68	27112	25	20 -- Green Potion (L)
+	69	60004	1	3	15 -- Looking Glass
+	70	80019	1	3	15 -- Fine Cloth
+	71	38060	1	3	15 -- Bag of Emotions
+}
+Group	沽퓨
+{
+	Vnum	50080 -- Red Dragon's Chest
+	1	50513	1	100 -- Soul Stone
+}
+Group	沽퓨
+{
+	Vnum	50081 -- Demon King's Chest
+	1	152	1	22	30 -- Ghost Fang Blade+2
+	2	153	1	16	30 -- Ghost Fang Blade+3
+	3	5092	1	22	30 -- Thunder Bird Bell+2
+	4	5093	1	16	30 -- Thunder Bird Bell+3
+	5	142	1	22	30 -- Battle Sword+2
+	6	143	1	16	30 -- Battle Sword+3
+	7	3132	1	22	30 -- Partisan+2
+	8	3133	1	16	30 -- Partisan+3
+	9	1102	1	22	30 -- Dragon Knife+2
+	10	1103	1	16	30 -- Dragon Knife+3
+	11	7132	1	22	30 -- Heavenly Bird Fan+2
+	12	7133	1	16	30 -- Heavenly Bird Fan+3
+	13	2142	1	22	30 -- Yellow Dragon Bow+2
+	14	2143	1	16	30 -- Yellow Dragon Bow+3
+	15	6052	1	22	30 -- Scarab Claw+2
+	16	6053	1	16	30 -- Scarab Claw+3
+	17	6042	1	22	30 -- Griffon Claw+2
+	18	6043	1	16	30 -- Griffon Claw+3
+	19	11682	1	19	30 -- Spirit Plate Armour+2
+	20	11683	1	28	30 -- Spirit Plate Armour+3
+	21	11684	1	10	30 -- Spirit Plate Armour+4
+	22	11882	1	19	30 -- Baroness Dress+2
+	23	11883	1	28	30 -- Baroness Dress+3
+	24	11884	1	10	30 -- Baroness Dress+4
+	25	11482	1	19	30 -- Fuchsia Suit+2
+	26	11483	1	28	30 -- Fuchsia Suit+3
+	27	11484	1	10	30 -- Fuchsia Suit+4
+	28	11282	1	19	30 -- Dragon God Armour+2
+	29	11283	1	28	30 -- Dragon God Armour+3
+	30	11284	1	10	30 -- Dragon God Armour+4
+	31	21062	1	19	30 -- Firellium Plate Armour+2
+	32	21063	1	28	30 -- Firellium Plate Armour+3
+	33	21064	1	10	30 -- Firellium Plate Armour+4
+	34	17184	1	19	30 -- Amethyst Earrings+4
+	35	17185	1	28	30 -- Amethyst Earrings+5
+	36	17186	1	10	30 -- Amethyst Earrings+6
+	37	16184	1	19	30 -- Amethyst Necklace+4
+	38	16185	1	28	30 -- Amethyst Necklace+5
+	39	16186	1	10	30 -- Amethyst Necklace+6
+	40	14184	1	19	30 -- Amethyst Bracelet+4
+	41	14185	1	28	30 -- Amethyst Bracelet+5
+	42	14186	1	10	30 -- Amethyst Bracelet+6
+	43	70012	1	20 -- Goddess Tear
+	44	70038	1	20 -- Bravery Cape
+	45	25040	1	25 -- Blessing Scroll
+	46	70048	1	20 -- Cloak of Secrecy
+	47	70037	1	25 -- Book of Forgetfulness
+	48	70014	1	25 -- Blood Pill
+	49	70043	1	20 -- Thief's Gloves
+	50	70005	1	20 -- Experience Ring (1h)
+	51	치	200000	20 -- Exp.
+	52	치	250000	30 -- Exp.
+	53	치	300000	20 -- Exp.
+	54	慕	200000	20 -- Yang
+	55	慕	250000	30 -- Yang
+	56	慕	300000	20 -- Yang
+	57	27112	30	20 -- Green Potion (L)
+	58	60004	1	3	15 -- Looking Glass
+	59	80019	1	3	15 -- Fine Cloth
+	60	38060	1	3	15 -- Bag of Emotions
+}
+Group	퓨
+{
+	Vnum	50082 -- Grim Reaper's Chest
+	1	170	1	16	30 -- Sting Sword+0
+	2	250	1	16	30 -- Demon Blade+0
+	3	1120	1	16	30 -- Siamese Knife+0
+	4	2180	1	16	30 -- Blue Dragon Bow+0
+	5	3150	1	16	30 -- Soul Stealing Blade+0
+	6	7150	1	16	30 -- Ecstasy Fan+0
+	7	6060	1	16	30 -- Hawk Claw+0
+	8	11290	1	31	30 -- Black Steel Armour+0
+	9	11291	1	15	30 -- Black Steel Armour+1
+	10	11490	1	31	30 -- Black Wind Suit+0
+	11	11491	1	15	30 -- Black Wind Suit+1
+	12	11690	1	31	30 -- Magic Plate Armour+0
+	13	11691	1	15	30 -- Magic Plate Armour+1
+	14	11890	1	31	30 -- Black Clothing+0
+	15	11891	1	15	30 -- Black Clothing+1
+	16	21070	1	31	30 -- Nightshade Armour+0
+	17	21071	1	15	30 -- Nightshade Armour+1
+	18	152	1	22	30 -- Ghost Fang Blade+2
+	19	153	1	16	30 -- Ghost Fang Blade+3
+	20	5092	1	22	30 -- Thunder Bird Bell+2
+	21	5093	1	16	30 -- Thunder Bird Bell+3
+	22	142	1	22	30 -- Battle Sword+2
+	23	143	1	16	30 -- Battle Sword+3
+	24	3132	1	22	30 -- Partisan+2
+	25	3133	1	16	30 -- Partisan+3
+	26	1102	1	22	30 -- Dragon Knife+2
+	27	1103	1	16	30 -- Dragon Knife+3
+	28	7132	1	22	30 -- Heavenly Bird Fan+2
+	29	7133	1	16	30 -- Heavenly Bird Fan+3
+	30	2142	1	22	30 -- Yellow Dragon Bow+2
+	31	2143	1	16	30 -- Yellow Dragon Bow+3
+	32	6041	1	22	30 -- Griffon Claw+1
+	33	6042	1	16	30 -- Griffon Claw+2
+	34	6051	1	22	30 -- Scarab Claw+1
+	35	6052	1	16	30 -- Scarab Claw+2
+	36	11682	1	19	30 -- Spirit Plate Armour+2
+	37	11683	1	28	30 -- Spirit Plate Armour+3
+	38	11684	1	10	30 -- Spirit Plate Armour+4
+	39	11882	1	19	30 -- Baroness Dress+2
+	40	11883	1	28	30 -- Baroness Dress+3
+	41	11884	1	10	30 -- Baroness Dress+4
+	42	11482	1	19	30 -- Fuchsia Suit+2
+	43	11483	1	28	30 -- Fuchsia Suit+3
+	44	11484	1	10	30 -- Fuchsia Suit+4
+	45	11282	1	19	30 -- Dragon God Armour+2
+	46	11283	1	28	30 -- Dragon God Armour+3
+	47	11284	1	10	30 -- Dragon God Armour+4
+	48	21061	1	19	30 -- Firellium Plate Armour+1
+	49	21062	1	28	30 -- Firellium Plate Armour+2
+	50	21063	1	10	30 -- Firellium Plate Armour+3
+	51	180	1	4	30 -- Poison Sword+0
+	52	190	1	4	30 -- Lion Sword+0
+	53	1130	1	10	30 -- Devil Wing Chakram+0
+	54	2170	1	10	30 -- Crow Steel Bow+0
+	55	3160	1	10	30 -- Grudge Sword+0
+	56	5120	1	10	30 -- Bamboo Bell+0
+	57	6070	1	10	30 -- Thorned Claw+0
+	58	60004	1	3	15 -- Looking Glass
+	59	80019	1	3	15 -- Fine Cloth
+	60	38060	1	3	15 -- Bag of Emotions
+}
+Group	호퓨
+{
+	Vnum	50090 -- Box of Fox nine o' Tails
+	1	170	1	16	20 -- Sting Sword+0
+	2	250	1	16	20 -- Demon Blade+0
+	3	1120	1	16	20 -- Siamese Knife+0
+	4	2180	1	16	20 -- Blue Dragon Bow+0
+	5	3150	1	16	20 -- Soul Stealing Blade+0
+	6	7150	1	16	20 -- Ecstasy Fan+0
+	7	6060	1	16	20 -- Hawk Claw+0
+	8	11290	1	31	20 -- Black Steel Armour+0
+	9	11291	1	15	20 -- Black Steel Armour+1
+	10	11490	1	31	20 -- Black Wind Suit+0
+	11	11491	1	15	20 -- Black Wind Suit+1
+	12	11690	1	31	20 -- Magic Plate Armour+0
+	13	11691	1	15	20 -- Magic Plate Armour+1
+	14	11890	1	31	20 -- Black Clothing+0
+	15	11891	1	15	20 -- Black Clothing+1
+	16	21070	1	31	20 -- Nightshade Armour+0
+	17	21071	1	15	20 -- Nightshade Armour+1
+	18	17204	1	60	20 -- Heaven's Tear Earrings+4
+	19	17205	1	40	20 -- Heaven's Tear Earrings+5
+	20	17206	1	20	20 -- Heaven's Tear Earrings+6
+	21	16204	1	60	20 -- Heaven's Tear Necklace+4
+	22	16205	1	40	20 -- Heaven's Tear Necklace+5
+	23	16206	1	20	20 -- Heaven's Tear Necklace+6
+	24	14204	1	60	20 -- Heaven's Tear Bracelet+4
+	25	14205	1	40	20 -- Heaven's Tear Bracelet+5
+	26	14206	1	20	20 -- Heaven's Tear Bracelet+6
+	27	치	500000	100 -- Exp.
+	28	치	700000	60 -- Exp.
+	29	치	1000000	20 -- Exp.
+	30	慕	300000	100 -- Yang
+	31	慕	500000	60 -- Yang
+	32	慕	1000000	20 -- Yang
+	33	38060	1	5 -- Bag of Emotions
+}
+Group	튿姑퓨
+{
+	Vnum	50186 -- Azrael's Chest
+	1	172	1	25 -- Sting Sword+2
+	2	252	1	25 -- Demon Blade+2
+	3	1122	1	25 -- Siamese Knife+2
+	4	2182	1	25 -- Blue Dragon Bow+2
+	5	3152	1	25 -- Soul Stealing Blade+2
+	6	7152	1	25 -- Ecstasy Fan+2
+	7	6062	1	25 -- Hawk Claw+2
+	8	11291	1	30 -- Black Steel Armour+1
+	9	11292	1	20 -- Black Steel Armour+2
+	10	11491	1	30 -- Black Wind Suit+1
+	11	11492	1	20 -- Black Wind Suit+2
+	12	11691	1	30 -- Magic Plate Armour+1
+	13	11692	1	20 -- Magic Plate Armour+2
+	14	11891	1	30 -- Black Clothing+1
+	15	11892	1	20 -- Black Clothing+2
+	16	21071	1	20 -- Nightshade Armour+1
+	17	21072	1	20 -- Nightshade Armour+2
+	18	17204	1	30 -- Heaven's Tear Earrings+4
+	19	17205	1	20 -- Heaven's Tear Earrings+5
+	20	17206	1	10 -- Heaven's Tear Earrings+6
+	21	16204	1	30 -- Heaven's Tear Necklace+4
+	22	16205	1	20 -- Heaven's Tear Necklace+5
+	23	16206	1	10 -- Heaven's Tear Necklace+6
+	24	14204	1	30 -- Heaven's Tear Bracelet+4
+	25	14205	1	20 -- Heaven's Tear Bracelet+5
+	26	14206	1	10 -- Heaven's Tear Bracelet+6
+	27	12260	1	7 -- Fear Mask +0
+	28	12280	1	5 -- War Master Helmet +0
+	29	12390	1	7 -- Orc Hood +0
+	30	12400	1	5 -- Spider Hood +0
+	31	12530	1	7 -- Horned Helmet +0
+	32	12540	1	5 -- Magic Helmet +0
+	33	12670	1	7 -- Cardinal's Hat +0
+	34	12680	1	5 -- Soul Shard Hat +0
+	35	21530	1	7 -- Godsend Helmet+0
+	36	21540	1	5 -- Viridian Wood Helmet+0
+	37	13140	1	5 -- Titan Shield+0
+	38	14220	1	5 -- Soul Crystal Bracelet+0
+	39	16220	1	5 -- Soul Crystal Necklace+0
+	40	17220	1	5 -- Soul Crystal Earrings+0
+	41	慕	500000	40 -- Yang
+	42	27002	200	100 -- Red Potion (M)
+	43	27003	100	100 -- Red Potion (L)
+	44	27005	200	100 -- Blue Potion (M)
+	45	27006	100	100 -- Blue Potion (L)
+	46	80019	1	5 -- Fine Cloth
+	47	60004	1	5 -- Looking Glass
+}
+Group	w20
+{
+	Vnum	50254
+	1	174	1	25 -- Sting Sword+4
+	2	254	1	25 -- Demon Blade+4
+	3	1124	1	25 -- Siamese Knife+4
+	4	2184	1	25 -- Blue Dragon Bow+4
+	5	3154	1	25 -- Soul Stealing Blade+4
+	6	7154	1	25 -- Ecstasy Fan+4
+	7	6064	1	25 -- Hawk Claw+4
+	8	11293	1	30 -- Black Steel Armour+3
+	9	11294	1	20 -- Black Steel Armour+4
+	10	11493	1	30 -- Black Wind Suit+3
+	11	11494	1	20 -- Black Wind Suit+4
+	12	11693	1	30 -- Magic Plate Armour+3
+	13	11694	1	20 -- Magic Plate Armour+4
+	14	11893	1	30 -- Black Clothing+3
+	15	11894	1	20 -- Black Clothing+4
+	16	21073	1	30 -- Nightshade Armour+3
+	17	21074	1	20 -- Nightshade Armour+4
+	18	17205	1	30 -- Heaven's Tear Earrings+5
+	19	17206	1	20 -- Heaven's Tear Earrings+6
+	20	17207	1	10 -- Heaven's Tear Earrings+7
+	21	16205	1	30 -- Heaven's Tear Necklace+5
+	22	16206	1	20 -- Heaven's Tear Necklace+6
+	23	16207	1	10 -- Heaven's Tear Necklace+7
+	24	14205	1	30 -- Heaven's Tear Bracelet+5
+	25	14206	1	20 -- Heaven's Tear Bracelet+6
+	26	14207	1	10 -- Heaven's Tear Bracelet+7
+	27	12260	1	7 -- Fear Mask +0
+	28	12280	1	5 -- War Master Helmet +0
+	29	12390	1	7 -- Orc Hood +0
+	30	12400	1	5 -- Spider Hood +0
+	31	12530	1	7 -- Horned Helmet +0
+	32	12540	1	5 -- Magic Helmet +0
+	33	12670	1	7 -- Cardinal's Hat +0
+	34	12680	1	5 -- Soul Shard Hat +0
+	35	21530	1	7 -- Godsend Helmet+0
+	36	21540	1	5 -- Viridian Wood Helmet+0
+	37	13140	1	5 -- Titan Shield+0
+	38	14220	1	5 -- Soul Crystal Bracelet+0
+	39	16220	1	5 -- Soul Crystal Necklace+0
+	40	17220	1	5 -- Soul Crystal Earrings+0
+	41	155	1	7 -- Ghost Fang Blade+5
+	42	156	1	6 -- Ghost Fang Blade+6
+	43	157	1	5 -- Ghost Fang Blade+7
+	44	1105	1	7 -- Dragon Knife+5
+	45	1106	1	6 -- Dragon Knife+6
+	46	1107	1	5 -- Dragon Knife+7
+	47	2145	1	7 -- Yellow Dragon Bow+5
+	48	2146	1	6 -- Yellow Dragon Bow+6
+	49	2147	1	5 -- Yellow Dragon Bow+7
+	50	3145	1	7 -- Electromagnetic Blade+5
+	51	3146	1	6 -- Electromagnetic Blade+6
+	52	3147	1	5 -- Electromagnetic Blade+7
+	53	5105	1	7 -- Heaven and Earth Bell+5
+	54	5106	1	6 -- Heaven and Earth Bell+6
+	55	5107	1	5 -- Heaven and Earth Bell+7
+	56	7145	1	7 -- Salvation Fan+5
+	57	7146	1	6 -- Salvation Fan+6
+	58	7147	1	5 -- Salvation Fan+7
+	59	6045	1	7 -- Griffon Claw+5
+	60	6046	1	6 -- Griffon Claw+6
+	61	6047	1	5 -- Griffon Claw+7
+	62	11295	1	7 -- Black Steel Armour+5
+	63	11296	1	6 -- Black Steel Armour+6
+	64	11297	1	5 -- Black Steel Armour+7
+	65	11495	1	7 -- Black Wind Suit+5
+	66	11496	1	6 -- Black Wind Suit+6
+	67	11497	1	5 -- Black Wind Suit+7
+	68	11695	1	7 -- Magic Plate Armour+5
+	69	11696	1	6 -- Magic Plate Armour+6
+	70	11697	1	5 -- Magic Plate Armour+7
+	71	11895	1	7 -- Black Clothing+5
+	72	11896	1	6 -- Black Clothing+6
+	73	11897	1	5 -- Black Clothing+7
+	74	21075	1	30 -- Nightshade Armour+5
+	75	21076	1	30 -- Nightshade Armour+6
+	76	21077	1	20 -- Nightshade Armour+7
+	77	460	1	1 -- Rune Sword +0
+	78	470	1	1 -- Dragon Tooth Blade +0
+	79	1340	1	1 -- Five Element Blade +0
+	80	2370	1	1 -- Phoenix Bow +0
+	81	3190	1	1 -- Solar Blade +0
+	82	5340	1	1 -- Dragon Ghost Bell +0
+	83	7370	1	1 -- Lying Dragon Fan+0
+	84	20000	1	1 -- Devil's Horn Armour+0
+	85	20250	1	1 -- Dragon Rider Suit+0
+	86	20500	1	1 -- Bone Plated Armour+0
+	87	20750	1	1 -- Golden Clothing+0
+	88	21090	1	1 -- Warlord Armour+0
+	89	14500	1	3 -- Ruby Bracelet+0
+	90	14520	1	3 -- Garnet Bracelet+0
+	91	14540	1	3 -- Emerald Bracelet+0
+	92	14560	1	3 -- Sapphire Bracelet+0
+	93	14570	1	3 -- Tourmaline Bracelet+0
+	94	16500	1	3 -- Ruby Necklace+0
+	95	16520	1	3 -- Garnet Necklace+0
+	96	16540	1	3 -- Emerald Necklace+0
+	97	16560	1	3 -- Sapphire Necklace+0
+	98	16570	1	3 -- Tourmaline Necklace+0
+	99	17500	1	3 -- Ruby Earrings+0
+	100	17520	1	3 -- Garnet Earrings+0
+	101	17540	1	3 -- Emerald Earrings+0
+	102	17560	1	3 -- Sapphire Earrings+0
+	103	gold	50000	70 -- Yang
+	104	gold	100000	60 -- Yang
+	105	gold	200000	50 -- Yang
+	106	gold	300000	40 -- Yang
+	107	gold	400000	30 -- Yang
+	108	gold	500000	20 -- Yang
+	109	exp	500000	40 -- Exp.
+	110	27002	200	100 -- Red Potion (M)
+	111	27003	100	100 -- Red Potion (L)
+	112	27005	200	100 -- Blue Potion (M)
+	113	27006	100	100 -- Blue Potion (L)
+	114	39004	1	5 -- Blessing Marble
+	115	71130	1	5 -- Passage Ticket
+	116	70024	1	5 -- Blessing Marble
+	117	80019	1	5 -- Fine Cloth
+	118	60004	1	5 -- Looking Glass
+}
+Group	SpiritStoneBundle
+{
+	Vnum	72058 -- Spirit Stone Bundle
+	1	28012	1	100 -- Stone against Lycans+0
+	2	28030	1	100 -- Stone of Penetration+0
+	3	28031	1	100 -- Stone of Deathblow+0
+	4	28032	1	100 -- Stone of Cooldown+0
+	5	28033	1	100 -- Stone against Warriors+0
+	6	28034	1	100 -- Stone against Ninjas+0
+	7	28035	1	100 -- Stone against Suras+0
+	8	28036	1	100 -- Stone against Shamans+0
+	9	28037	1	100 -- Stone of Monsters+0
+	10	28038	1	100 -- Stone of Evasion+0
+	11	28039	1	100 -- Stone of Ducking+0
+	12	28040	1	100 -- Stone of Magic+0
+	13	28041	1	100 -- Stone of Vitality+0
+	14	28042	1	100 -- Stone of Defence+0
+	15	28043	1	100 -- Stone of Haste+0
+	16	28044	1	100 -- Anti-Magic Stone+0
+	17	28112	1	100 -- Stone against Lycans+1
+	18	28130	1	100 -- Stone of Penetration+1
+	19	28131	1	100 -- Stone of Deathblow+1
+	20	28132	1	100 -- Stone of Cooldown+1
+	21	28133	1	100 -- Stone against Warriors+1
+	22	28134	1	100 -- Stone against Ninjas+1
+	23	28135	1	100 -- Stone against Suras+1
+	24	28136	1	100 -- Stone against Shamans+1
+	25	28137	1	100 -- Stone of Monsters+1
+	26	28138	1	100 -- Stone of Evasion+1
+	27	28139	1	100 -- Stone of Ducking+1
+	28	28140	1	100 -- Stone of Magic+1
+	29	28141	1	100 -- Stone of Vitality+1
+	30	28142	1	100 -- Stone of Defence+1
+	31	28143	1	100 -- Stone of Haste+1
+	32	28144	1	100 -- Anti-Magic Stone+1
+	33	28212	1	100 -- Stone against Lycans+2
+	34	28230	1	100 -- Stone of Penetration+2
+	35	28231	1	100 -- Stone of Deathblow+2
+	36	28232	1	100 -- Stone of Cooldown+2
+	37	28233	1	100 -- Stone against Warriors+2
+	38	28234	1	100 -- Stone against Ninjas+2
+	39	28235	1	100 -- Stone against Suras+2
+	40	28236	1	100 -- Stone against Shamans+2
+	41	28237	1	100 -- Stone of Monsters+2
+	42	28238	1	100 -- Stone of Evasion+2
+	43	28239	1	100 -- Stone of Ducking+2
+	44	28240	1	100 -- Stone of Magic+2
+	45	28241	1	100 -- Stone of Vitality+2
+	46	28242	1	100 -- Stone of Defence+2
+	47	28243	1	100 -- Stone of Haste+2
+	48	28244	1	100 -- Anti-Magic Stone+2
+	49	28312	1	100 -- Stone against Lycans+3
+	50	28330	1	100 -- Stone of Penetration+3
+	51	28331	1	100 -- Stone of Deathblow+3
+	52	28332	1	100 -- Stone of Cooldown+3
+	53	28333	1	100 -- Stone against Warriors+3
+	54	28334	1	100 -- Stone against Ninjas+3
+	55	28335	1	100 -- Stone against Suras+3
+	56	28336	1	100 -- Stone against Shamans+3
+	57	28337	1	100 -- Stone of Monsters+3
+	58	28338	1	100 -- Stone of Evasion+3
+	59	28339	1	100 -- Stone of Ducking+3
+	60	28340	1	100 -- Stone of Magic+3
+	61	28341	1	100 -- Stone of Vitality+3
+	62	28342	1	100 -- Stone of Defence+3
+	63	28343	1	100 -- Stone of Haste+3
+	64	28344	1	100 -- Anti-Magic Stone+3
+}
+Group	GoldenKingLoot
+{
+	Vnum	50928 -- Golden King's Loot
+	1	25041	1	100 -- Magic Stone
+	2	76013	1	100 -- Reinforce Item (b)
+	3	76014	1	100 -- Enchant Item (b)
+	4	71189	1	100 -- Enchant Item+
+	5	39015	1	100 -- Stone of the Blacksmith
+	6	71158	1	100 -- Hero's Medal
+	7	71128	1	100 -- Battle Lion
+	8	71127	1	100 -- Storm Tiger
+	9	51505	1	100 -- Cor Draconis (Precious)
+	10	51506	1	100 -- Cor Draconis (Mystical)
+	11	51639	1	100 -- Dragon Chest
+	12	76029	1	100 -- Green Dragon Bean
+	13	30618	1	100 -- Moonstone
+	14	30617	1	100 -- Agate
+	15	30616	1	100 -- Titanium Dioxide
+	16	55403	1	100 -- Razador's Egg
+	17	55404	1	100 -- Nemere's Egg
+	18	71153	1	100 -- Potion of Wisdom
+	19	50513	1	100 -- Soul Stone
+	20	50011	1	100 -- Moonlight Treasure Chest
+	21	50108	20	100 -- Fireworks Top
+	22	50107	20	100 -- Chinese Fire Cracker
+	23	27992	1	100 -- White Pearl
+	24	76016	1	100 -- Blessing Scroll
+	25	71095	3	100 -- Passage Ticket
+	26	72727	1	100 -- Moon Elixir (S)
+	27	72723	1	100 -- Sun Elixir (S)
+	28	70069	5	100 -- Peach Flower Wine XL
+	29	76033	10	100 -- Peach Flower Wine+
+	30	72058	10	100 -- Spirit Stone Bundle
+	31	76012	5	100 -- Potion of Speed
+	32	76017	5	100 -- Potion of Attack +15
+	33	76003	5	100 -- Potion of Haste
+	34	79604	1	100 -- King Deck
+}
+Group	SilverKingLoot
+{
+	Vnum	50929 -- Silver King's Loot
+	1	25041	1	100 -- Magic Stone
+	2	71189	1	100 -- Enchant Item+
+	3	76013	1	100 -- Reinforce Item (b)
+	4	76014	1	100 -- Enchant Item (b)
+	5	85001	1	100 -- Lord Sash (basic)
+	6	51503	1	100 -- Cor Draconis (Normal)
+	7	51504	1	100 -- Cor Draconis (Noble)
+	8	76029	1	100 -- Green Dragon Bean
+	9	71153	1	100 -- Potion of Wisdom
+	10	55401	1	100 -- Monkey Egg
+	11	55402	1	100 -- Spider Egg
+	12	55403	1	100 -- Razador's Egg
+	13	55404	1	100 -- Nemere's Egg
+	14	50324	1	100 -- Boost Book Chest
+	15	50323	1	100 -- Ward Book Chest
+	16	55001	1	100 -- Protein Snack
+	17	79604	1	100 -- King Deck
+	18	27993	1	100 -- Blue Pearl
+	19	27994	1	100 -- Blood-Red Pearl
+	20	71154	1	100 -- Potion of Ascension (3h)
+	21	50108	10	100 -- Fireworks Top
+	22	50107	10	100 -- Chinese Fire Cracker
+	23	76016	1	100 -- Blessing Scroll
+	24	70058	1	100 -- Teleportation Ring
+	25	39036	1	100 -- Wind Shoes
+	26	76033	10	100 -- Peach Flower Wine+
+	27	76012	10	100 -- Potion of Speed
+	28	76017	5	100 -- Potion of Attack +15
+	29	76003	5	100 -- Potion of Haste
+	30	72058	5	100 -- Spirit Stone Bundle
+	31	慕	500000	100 -- Yang
+	32	慕	300000	100 -- Yang
+	33	慕	100000	100 -- Yang
+	34	치	100000	100 -- Exp.
+}
+Group	BronzeKingLoot
+{
+	Vnum	50930 -- Bronze King's Loot
+	1	慕	50000	100 -- Yang
+	2	慕	100000	100 -- Yang
+	3	치	100000	100 -- Exp.
+}
+Group	QueenMeleyChest
+{
+	Vnum	50270 -- Queen Meley's Chest
+	Type	pct
+	1	7370	1	18	30 -- Lying Dragon Fan+0
+	2	5340	1	18	30 -- Dragon Ghost Bell +0
+	3	470	1	18	30 -- Dragon Tooth Blade +0
+	4	2370	1	18	30 -- Phoenix Bow +0
+	5	21544	1	10	30 -- Viridian Wood Helmet+4
+	6	21545	1	9	30 -- Viridian Wood Helmet+5
+	7	21546	1	5	30 -- Viridian Wood Helmet+6
+	8	12684	1	10	30 -- Soul Shard Hat +4
+	9	12685	1	9	30 -- Soul Shard Hat +5
+	10	12686	1	5	30 -- Soul Shard Hat +6
+	11	12404	1	10	30 -- Spider Hood +4
+	12	12405	1	9	30 -- Spider Hood +5
+	13	12406	1	5	30 -- Spider Hood +6
+	14	15434	1	10	30 -- Kingfisher Shoes +4
+	15	15435	1	9	30 -- Kingfisher Shoes +5
+	16	15436	1	5	30 -- Kingfisher Shoes +6
+	17	15374	1	10	30 -- Euphoria Shoes +4
+	18	15375	1	9	30 -- Euphoria Shoes +5
+	19	15376	1	5	30 -- Euphoria Shoes +6
+	20	27993	1	20 -- Blue Pearl
+	21	30550	10	20 -- Blue Belt
+	22	27994	1	20 -- Blood-Red Pearl
+	23	30192	5	20 -- Plant Sap
+	24	30621	3	100 -- Red Dragon Scale
+	25	30620	3	100 -- Red Dragon Horn
+	26	30622	1	20 -- Armour Design: Helm
+	27	70031	1	20 -- Fencing Pamphlet
+	28	27992	1	20 -- White Pearl
+	29	55003	1	10 -- Young Pet Book
+	30	55406	1	10 -- Red Dragon Egg
+	31	55005	1	10 -- Valiant Pet Book
+	32	55004	1	10 -- Wild Pet Book
+	33	50299	1	10 -- Crate of Boosts
+	34	50298	1	10 -- Crate of Wards
+	35	50297	1	10 -- Box of Boosts
+	36	50296	1	10 -- Box of Wards
+	37	50513	1	5 -- Soul Stone
+	38	39004	1	5 -- Blessing Marble
+	39	慕	10000000	100 -- Yang
+	40	慕	20000000	7 -- Yang
+	41	慕	30000000	5 -- Yang
+	42	慕	60000000	2 -- Yang
+}
+Group	DragonWatcherChest
+{
+	Vnum	50271 -- Dragon Watcher Chest
+	Type	pct
+	1	6090	1	18	30 -- Dragon Lord+0
+	2	1340	1	18	30 -- Five Element Blade +0
+	3	460	1	18	30 -- Rune Sword +0
+	4	3190	1	18	30 -- Solar Blade +0
+	5	12284	1	10	30 -- War Master Helmet +4
+	6	12285	1	9	30 -- War Master Helmet +5
+	7	12286	1	5	30 -- War Master Helmet +6
+	8	12544	1	10	30 -- Magic Helmet +4
+	9	12545	1	9	30 -- Magic Helmet +5
+	10	12546	1	5	30 -- Magic Helmet +6
+	11	15374	1	10	30 -- Euphoria Shoes +4
+	12	15375	1	9	30 -- Euphoria Shoes +5
+	13	15376	1	5	30 -- Euphoria Shoes +6
+	14	27993	1	20 -- Blue Pearl
+	15	27994	1	20 -- Blood-Red Pearl
+	16	30193	5	100 -- Finger Bones
+	17	30080	10	20 -- Curse Book+
+	18	30035	10	20 -- Face Cream
+	19	30011	10	20 -- Ball
+	20	30192	5	20 -- Plant Sap
+	21	30194	2	20 -- Orc Club
+	22	30042	2	20 -- Tiger Fang
+	23	30621	3	100 -- Red Dragon Scale
+	24	30620	3	100 -- Red Dragon Horn
+	25	30622	5	100 -- Armour Design: Helm
+	26	30031	10	20 -- Ornament
+	27	30083	10	20 -- Unknown Medicine+
+	28	27992	1	20 -- White Pearl
+	29	30089	10	20 -- Yeti Fur+
+	30	55003	1	10 -- Young Pet Book
+	31	55004	1	10 -- Wild Pet Book
+	32	55005	1	10 -- Valiant Pet Book
+	33	100700	1	1 -- Flame of the Dragon (B)
+	34	50297	1	10 -- Box of Boosts
+	35	50298	1	10 -- Crate of Wards
+	36	50299	1	10 -- Crate of Boosts
+	37	慕	10000000	100 -- Yang
+	38	慕	20000000	7 -- Yang
+	39	慕	30000000	5 -- Yang
+	40	慕	60000000	2 -- Yang
+}
+Group	QueenMeleyChest(P)
+{
+	Vnum	50294 -- Queen Meley's Chest
+	Type	pct
+	1	50926	200	100 -- Glimmerstone
+	2	50926	200	100 -- Glimmerstone
+	3	50926	200	100 -- Glimmerstone
+	4	50926	200	100 -- Glimmerstone
+	5	50926	200	100 -- Glimmerstone
+}
+Group	혼-_羞
+{
+	Vnum	50255 -- Cor Draconis (Rough)
+	1	110000	1	1 -- Rough Dragon Diamond
+	2	120000	1	1 -- Rough Dragon Ruby
+	3	130000	1	1 -- Rough Dragon Jade
+	4	140000	1	1 -- Rough Dragon Sapphire
+	5	150000	1	1 -- Rough Dragon Garnet
+	6	160000	1	1 -- Rough Dragon Onyx
+}
+Group	혼-羞_퓔탓
+{
+	Vnum	50260 -- Cor Draconis (Rough)
+	1	110000	1	1 -- Rough Dragon Diamond
+	2	120000	1	1 -- Rough Dragon Ruby
+	3	130000	1	1 -- Rough Dragon Jade
+	4	140000	1	1 -- Rough Dragon Sapphire
+	5	150000	1	1 -- Rough Dragon Garnet
+	6	160000	1	1 -- Rough Dragon Onyx
+}
+Group	혼黴_球화
+{
+	Vnum	51639 -- Dragon Chest
+	Type	Pct
+	1	51503	1	100 -- Cor Draconis (Normal)
+	2	51503	1	100 -- Cor Draconis (Normal)
+	3	51503	1	100 -- Cor Draconis (Normal)
+	4	51503	1	100 -- Cor Draconis (Normal)
+	5	51503	1	100 -- Cor Draconis (Normal)
+	6	51503	1	100 -- Cor Draconis (Normal)
+	7	51503	1	100 -- Cor Draconis (Normal)
+	8	51503	1	100 -- Cor Draconis (Normal)
+	9	51503	1	100 -- Cor Draconis (Normal)
+	10	51503	1	100 -- Cor Draconis (Normal)
+	11	51503	1	100 -- Cor Draconis (Normal)
+}
+Group	肌혼黴_球화
+{
+	Vnum	51640 -- Dragon Chest+
+	Type	Pct
+	1	51576	1	100 -- Cor Draconis+ (Normal)
+	2	51576	1	100 -- Cor Draconis+ (Normal)
+	3	51576	1	100 -- Cor Draconis+ (Normal)
+	4	51576	1	100 -- Cor Draconis+ (Normal)
+	5	51576	1	100 -- Cor Draconis+ (Normal)
+	6	51576	1	100 -- Cor Draconis+ (Normal)
+	7	51576	1	100 -- Cor Draconis+ (Normal)
+	8	51576	1	100 -- Cor Draconis+ (Normal)
+	9	51576	1	100 -- Cor Draconis+ (Normal)
+	10	51576	1	100 -- Cor Draconis+ (Normal)
+	11	51576	1	100 -- Cor Draconis+ (Normal)
+	12	100300	1	100 -- Green Dragon Bean
+}
+Group	肌혼黴_球화_
+{
+	Vnum	51641 -- Dragon Chest+ (Coloured)
+	Type	Pct
+	1	51577	1	100 -- Cor Diamas+ (Normal)
+	2	51578	1	100 -- Cor Rubinum+ (Normal)
+	3	51579	1	100 -- Cor Jadeit+ (Normal)
+	4	51580	1	100 -- Cor Saphirum+ (Normal)
+	5	51581	1	100 -- Cor Granatum+ (Normal)
+	6	51582	1	100 -- Cor Atrum+ (Normal)
+	7	100300	1	100 -- Green Dragon Bean
+}
+Group	혼黴_球화_
+{
+	Vnum	51642 -- Dragon Chest (Coloured)
+	Type	Pct
+	1	51517	1	100 -- Cor Diamas (Normal)
+	2	51518	1	100 -- Cor Rubinum (Normal)
+	3	51519	1	100 -- Cor Jadeit (Normal)
+	4	51520	1	100 -- Cor Saphirum (Normal)
+	5	51521	1	100 -- Cor Granatum (Normal)
+	6	51522	1	100 -- Cor Atrum (Normal)
+	7	100300	1	100 -- Green Dragon Bean
+}
+Group	혼黴_球
+{
+	Vnum	51643 -- Noble Dragon Chest
+	Type	Pct
+	1	51504	1	100 -- Cor Draconis (Noble)
+	2	51504	1	100 -- Cor Draconis (Noble)
+	3	51504	1	100 -- Cor Draconis (Noble)
+	4	51504	1	100 -- Cor Draconis (Noble)
+	5	51504	1	100 -- Cor Draconis (Noble)
+	6	51504	1	100 -- Cor Draconis (Noble)
+	7	51504	1	100 -- Cor Draconis (Noble)
+	8	51504	1	100 -- Cor Draconis (Noble)
+	9	51504	1	100 -- Cor Draconis (Noble)
+	10	51504	1	100 -- Cor Draconis (Noble)
+	11	51504	1	100 -- Cor Draconis (Noble)
+}
+Group	肌혼黴_球
+{
+	Vnum	51644 -- Noble Dragon Chest+
+	Type	Pct
+	1	51583	1	100 -- Cor Draconis+ (Noble)
+	2	51583	1	100 -- Cor Draconis+ (Noble)
+	3	51583	1	100 -- Cor Draconis+ (Noble)
+	4	51583	1	100 -- Cor Draconis+ (Noble)
+	5	51583	1	100 -- Cor Draconis+ (Noble)
+	6	51583	1	100 -- Cor Draconis+ (Noble)
+	7	51583	1	100 -- Cor Draconis+ (Noble)
+	8	51583	1	100 -- Cor Draconis+ (Noble)
+	9	51583	1	100 -- Cor Draconis+ (Noble)
+	10	51583	1	100 -- Cor Draconis+ (Noble)
+	11	51583	1	100 -- Cor Draconis+ (Noble)
+	12	100300	1	100 -- Green Dragon Bean
+}
+Group	肌혼黴_球_
+{
+	Vnum	51645 -- N. Dragon Cht+(Coloured)
+	Type	Pct
+	1	51584	1	100 -- Cor Diamas+ (Noble)
+	2	51585	1	100 -- Cor Rubinum+ (Noble)
+	3	51586	1	100 -- Cor Jadeit+ (Noble)
+	4	51587	1	100 -- Cor Saphirum+ (Noble)
+	5	51588	1	100 -- Cor Granatum+ (Noble)
+	6	51589	1	100 -- Cor Atrum+ (Noble)
+	7	100300	1	100 -- Green Dragon Bean
+}
+Group	혼黴_球_
+{
+	Vnum	51646 -- N. Dragon Cht (Coloured)
+	Type	Pct
+	1	51523	1	100 -- Cor Diamas (Noble)
+	2	51524	1	100 -- Cor Rubinum (Noble)
+	3	51525	1	100 -- Cor Jadeit (Noble)
+	4	51526	1	100 -- Cor Saphirum (Noble)
+	5	51527	1	100 -- Cor Granatum (Noble)
+	6	51528	1	100 -- Cor Atrum (Noble)
+	7	100300	1	100 -- Green Dragon Bean
+}
+Group	New_혼-_羞
+{
+	Vnum	51501 -- Cor Draconis (Rough)
+	1	110000	1	1 -- Rough Dragon Diamond
+	2	120000	1	1 -- Rough Dragon Ruby
+	3	130000	1	1 -- Rough Dragon Jade
+	4	140000	1	1 -- Rough Dragon Sapphire
+	5	150000	1	1 -- Rough Dragon Garnet
+	6	160000	1	1 -- Rough Dragon Onyx
+}
+Group	New_혼-羞_퓔탓
+{
+	Vnum	51502 -- Cor Draconis (Rough)
+	1	110000	1	1 -- Rough Dragon Diamond
+	2	120000	1	1 -- Rough Dragon Ruby
+	3	130000	1	1 -- Rough Dragon Jade
+	4	140000	1	1 -- Rough Dragon Sapphire
+	5	150000	1	1 -- Rough Dragon Garnet
+	6	160000	1	1 -- Rough Dragon Onyx
+}
+Group	화肌혼_
+{
+	Vnum	51503 -- Cor Draconis (Normal)
+	1	110000	1	100 -- Rough Dragon Diamond
+	2	120000	1	100 -- Rough Dragon Ruby
+	3	130000	1	100 -- Rough Dragon Jade
+	4	140000	1	100 -- Rough Dragon Sapphire
+	5	150000	1	100 -- Rough Dragon Garnet
+	6	160000	1	100 -- Rough Dragon Onyx
+	7	111000	1	43 -- Cut Dragon Diamond
+	8	121000	1	43 -- Cut Dragon Ruby
+	9	131000	1	43 -- Cut Dragon Jade
+	10	141000	1	43 -- Cut Dragon Sapphire
+	11	151000	1	43 -- Cut Dragon Garnet
+	12	161000	1	43 -- Cut Dragon Onyx
+}
+Group	肌혼_
+{
+	Vnum	51504 -- Cor Draconis (Noble)
+	1	110000	1	50 -- Rough Dragon Diamond
+	2	120000	1	50 -- Rough Dragon Ruby
+	3	130000	1	50 -- Rough Dragon Jade
+	4	140000	1	50 -- Rough Dragon Sapphire
+	5	150000	1	50 -- Rough Dragon Garnet
+	6	160000	1	50 -- Rough Dragon Onyx
+	7	111000	1	75 -- Cut Dragon Diamond
+	8	121000	1	75 -- Cut Dragon Ruby
+	9	131000	1	75 -- Cut Dragon Jade
+	10	141000	1	75 -- Cut Dragon Sapphire
+	11	151000	1	75 -- Cut Dragon Garnet
+	12	161000	1	75 -- Cut Dragon Onyx
+	13	112000	1	42 -- Rare Dragon Diamond
+	14	122000	1	42 -- Rare Dragon Ruby
+	15	132000	1	42 -- Rare Dragon Jade
+	16	142000	1	42 -- Rare Dragon Sapphire
+	17	152000	1	41 -- Rare Dragon Garnet
+	18	162000	1	41 -- Rare Dragon Onyx
+}
+Group	퓻혼_
+{
+	Vnum	51505 -- Cor Draconis (Precious)
+	1	110000	1	35 -- Rough Dragon Diamond
+	2	120000	1	35 -- Rough Dragon Ruby
+	3	130000	1	35 -- Rough Dragon Jade
+	4	140000	1	35 -- Rough Dragon Sapphire
+	5	150000	1	35 -- Rough Dragon Garnet
+	6	160000	1	35 -- Rough Dragon Onyx
+	7	111000	1	135 -- Cut Dragon Diamond
+	8	121000	1	135 -- Cut Dragon Ruby
+	9	131000	1	135 -- Cut Dragon Jade
+	10	141000	1	135 -- Cut Dragon Sapphire
+	11	151000	1	135 -- Cut Dragon Garnet
+	12	161000	1	135 -- Cut Dragon Onyx
+	13	112000	1	380 -- Rare Dragon Diamond
+	14	122000	1	380 -- Rare Dragon Ruby
+	15	132000	1	380 -- Rare Dragon Jade
+	16	142000	1	380 -- Rare Dragon Sapphire
+	17	152000	1	380 -- Rare Dragon Garnet
+	18	162000	1	380 -- Rare Dragon Onyx
+	19	113000	1	135 -- Antique Dragon Diamond
+	20	123000	1	135 -- Antique Dragon Ruby
+	21	133000	1	135 -- Antique Dragon Jade
+	22	143000	1	135 -- Antique Dragon Sapphire
+	23	153000	1	135 -- Antique Dragon Garnet
+	24	163000	1	135 -- Antique Dragon Onyx
+}
+Group	퓻혼_
+{
+	Vnum	51506 -- Cor Draconis (Mystical)
+	1	111000	1	35 -- Cut Dragon Diamond
+	2	121000	1	35 -- Cut Dragon Ruby
+	3	131000	1	35 -- Cut Dragon Jade
+	4	141000	1	35 -- Cut Dragon Sapphire
+	5	151000	1	35 -- Cut Dragon Garnet
+	6	161000	1	35 -- Cut Dragon Onyx
+	7	112000	1	240 -- Rare Dragon Diamond
+	8	122000	1	240 -- Rare Dragon Ruby
+	9	132000	1	240 -- Rare Dragon Jade
+	10	142000	1	240 -- Rare Dragon Sapphire
+	11	152000	1	240 -- Rare Dragon Garnet
+	12	162000	1	240 -- Rare Dragon Onyx
+	13	113000	1	310 -- Antique Dragon Diamond
+	14	123000	1	310 -- Antique Dragon Ruby
+	15	133000	1	310 -- Antique Dragon Jade
+	16	143000	1	310 -- Antique Dragon Sapphire
+	17	153000	1	310 -- Antique Dragon Garnet
+	18	163000	1	310 -- Antique Dragon Onyx
+	19	114000	1	100 -- Legendary Dragon Diamond
+	20	124000	1	100 -- Legendary Dragon Ruby
+	21	134000	1	100 -- Legendary Dragon Jade
+	22	144000	1	100 -- Legendary DragonSapphire
+	23	154000	1	100 -- Legendary Dragon Garnet
+	24	164000	1	100 -- Legendary Dragon Onyx
+}
+Group	화肌혼_頻
+{
+	Vnum	51507 -- Cor Draconis (Cut)
+	1	111000	1	1 -- Cut Dragon Diamond
+	2	121000	1	1 -- Cut Dragon Ruby
+	3	131000	1	1 -- Cut Dragon Jade
+	4	141000	1	1 -- Cut Dragon Sapphire
+	5	151000	1	1 -- Cut Dragon Garnet
+	6	161000	1	1 -- Cut Dragon Onyx
+}
+Group	肌혼_頻
+{
+	Vnum	51508 -- Cor Draconis (Rare)
+	1	112000	1	1 -- Rare Dragon Diamond
+	2	122000	1	1 -- Rare Dragon Ruby
+	3	132000	1	1 -- Rare Dragon Jade
+	4	142000	1	1 -- Rare Dragon Sapphire
+	5	152000	1	1 -- Rare Dragon Garnet
+	6	162000	1	1 -- Rare Dragon Onyx
+}
+Group	퓻혼_頻
+{
+	Vnum	51509 -- Cor Draconis (Antique)
+	1	113000	1	1 -- Antique Dragon Diamond
+	2	123000	1	1 -- Antique Dragon Ruby
+	3	133000	1	1 -- Antique Dragon Jade
+	4	143000	1	1 -- Antique Dragon Sapphire
+	5	153000	1	1 -- Antique Dragon Garnet
+	6	163000	1	1 -- Antique Dragon Onyx
+}
+Group	퓻혼_頻
+{
+	Vnum	51510 -- Cor Draconis (Legendary)
+	1	114000	1	1 -- Legendary Dragon Diamond
+	2	124000	1	1 -- Legendary Dragon Ruby
+	3	134000	1	1 -- Legendary Dragon Jade
+	4	144000	1	1 -- Legendary DragonSapphire
+	5	154000	1	1 -- Legendary Dragon Garnet
+	6	164000	1	1 -- Legendary Dragon Onyx
+}
+Group	혼_
+{
+	Vnum	51511 -- Cor Diamas
+	1	110000	1	1 -- Rough Dragon Diamond
+	2	111000	1	1 -- Cut Dragon Diamond
+	3	112000	1	1 -- Rare Dragon Diamond
+	4	113000	1	1 -- Antique Dragon Diamond
+	5	114000	1	1 -- Legendary Dragon Diamond
+}
+Group	화혼_
+{
+	Vnum	51512 -- Cor Rubinum
+	1	120000	1	1 -- Rough Dragon Ruby
+	2	121000	1	1 -- Cut Dragon Ruby
+	3	122000	1	1 -- Rare Dragon Ruby
+	4	123000	1	1 -- Antique Dragon Ruby
+	5	124000	1	1 -- Legendary Dragon Ruby
+}
+Group	풍혼_
+{
+	Vnum	51513 -- Cor Jadeit
+	1	130000	1	1 -- Rough Dragon Jade
+	2	131000	1	1 -- Cut Dragon Jade
+	3	132000	1	1 -- Rare Dragon Jade
+	4	133000	1	1 -- Antique Dragon Jade
+	5	134000	1	1 -- Legendary Dragon Jade
+}
+Group	철혼_
+{
+	Vnum	51514 -- Cor Saphirum
+	1	140000	1	1 -- Rough Dragon Sapphire
+	2	141000	1	1 -- Cut Dragon Sapphire
+	3	142000	1	1 -- Rare Dragon Sapphire
+	4	143000	1	1 -- Antique Dragon Sapphire
+	5	144000	1	1 -- Legendary DragonSapphire
+}
+Group	혼_
+{
+	Vnum	51515 -- Cor Granatum
+	1	150000	1	1 -- Rough Dragon Garnet
+	2	151000	1	1 -- Cut Dragon Garnet
+	3	152000	1	1 -- Rare Dragon Garnet
+	4	153000	1	1 -- Antique Dragon Garnet
+	5	154000	1	1 -- Legendary Dragon Garnet
+}
+Group	혼_
+{
+	Vnum	51516 -- Cor Atrum
+	1	160000	1	1 -- Rough Dragon Onyx
+	2	161000	1	1 -- Cut Dragon Onyx
+	3	162000	1	1 -- Rare Dragon Onyx
+	4	163000	1	1 -- Antique Dragon Onyx
+	5	164000	1	1 -- Legendary Dragon Onyx
+}
+Group	혼__球-화
+{
+	Vnum	51517 -- Cor Diamas (Normal)
+	1	110000	1	7 -- Rough Dragon Diamond
+	2	111000	1	3 -- Cut Dragon Diamond
+}
+Group	화혼__球-화
+{
+	Vnum	51518 -- Cor Rubinum (Normal)
+	1	120000	1	7 -- Rough Dragon Ruby
+	2	121000	1	3 -- Cut Dragon Ruby
+}
+Group	풍혼__球-화
+{
+	Vnum	51519 -- Cor Jadeit (Normal)
+	1	130000	1	7 -- Rough Dragon Jade
+	2	131000	1	3 -- Cut Dragon Jade
+}
+Group	철혼__球-화
+{
+	Vnum	51520 -- Cor Saphirum (Normal)
+	1	140000	1	7 -- Rough Dragon Sapphire
+	2	141000	1	3 -- Cut Dragon Sapphire
+}
+Group	혼__球-화
+{
+	Vnum	51521 -- Cor Granatum (Normal)
+	1	150000	1	7 -- Rough Dragon Garnet
+	2	151000	1	3 -- Cut Dragon Garnet
+}
+Group	혼__球-화
+{
+	Vnum	51522 -- Cor Atrum (Normal)
+	1	160000	1	7 -- Rough Dragon Onyx
+	2	161000	1	3 -- Cut Dragon Onyx
+}
+Group	혼__球-
+{
+	Vnum	51523 -- Cor Diamas (Noble)
+	1	110000	1	3 -- Rough Dragon Diamond
+	2	111000	1	6 -- Cut Dragon Diamond
+	3	112000	1	1 -- Rare Dragon Diamond
+}
+Group	화혼__球-
+{
+	Vnum	51524 -- Cor Rubinum (Noble)
+	1	120000	1	3 -- Rough Dragon Ruby
+	2	121000	1	6 -- Cut Dragon Ruby
+	3	122000	1	1 -- Rare Dragon Ruby
+}
+Group	풍혼__球-
+{
+	Vnum	51525 -- Cor Jadeit (Noble)
+	1	130000	1	3 -- Rough Dragon Jade
+	2	131000	1	6 -- Cut Dragon Jade
+	3	132000	1	1 -- Rare Dragon Jade
+}
+Group	철혼__球-
+{
+	Vnum	51526 -- Cor Saphirum (Noble)
+	1	140000	1	3 -- Rough Dragon Sapphire
+	2	141000	1	6 -- Cut Dragon Sapphire
+	3	142000	1	1 -- Rare Dragon Sapphire
+}
+Group	혼__球-
+{
+	Vnum	51527 -- Cor Granatum (Noble)
+	1	150000	1	3 -- Rough Dragon Garnet
+	2	151000	1	6 -- Cut Dragon Garnet
+	3	152000	1	1 -- Rare Dragon Garnet
+}
+Group	혼__球-
+{
+	Vnum	51528 -- Cor Atrum (Noble)
+	1	160000	1	3 -- Rough Dragon Onyx
+	2	161000	1	6 -- Cut Dragon Onyx
+	3	162000	1	1 -- Rare Dragon Onyx
+}
+Group	혼__球-
+{
+	Vnum	51529 -- Cor Diamas (Precious)
+	1	110000	1	10 -- Rough Dragon Diamond
+	2	111000	1	25 -- Cut Dragon Diamond
+	3	112000	1	55 -- Rare Dragon Diamond
+	4	113000	1	10 -- Antique Dragon Diamond
+}
+Group	화혼__球-
+{
+	Vnum	51530 -- Cor Rubinum (Precious)
+	1	120000	1	10 -- Rough Dragon Ruby
+	2	121000	1	25 -- Cut Dragon Ruby
+	3	122000	1	55 -- Rare Dragon Ruby
+	4	123000	1	10 -- Antique Dragon Ruby
+}
+Group	풍혼__球-
+{
+	Vnum	51531 -- Cor Jadeit (Precious)
+	1	130000	1	10 -- Rough Dragon Jade
+	2	131000	1	25 -- Cut Dragon Jade
+	3	132000	1	55 -- Rare Dragon Jade
+	4	133000	1	10 -- Antique Dragon Jade
+}
+Group	철혼__球-
+{
+	Vnum	51532 -- Cor Saphirum (Precious)
+	1	140000	1	10 -- Rough Dragon Sapphire
+	2	141000	1	25 -- Cut Dragon Sapphire
+	3	142000	1	55 -- Rare Dragon Sapphire
+	4	143000	1	10 -- Antique Dragon Sapphire
+}
+Group	혼__球-
+{
+	Vnum	51533 -- Cor Granatum (Precious)
+	1	150000	1	10 -- Rough Dragon Garnet
+	2	151000	1	25 -- Cut Dragon Garnet
+	3	152000	1	55 -- Rare Dragon Garnet
+	4	153000	1	10 -- Antique Dragon Garnet
+}
+Group	혼__球-
+{
+	Vnum	51534 -- Cor Atrum (Precious)
+	1	160000	1	10 -- Rough Dragon Onyx
+	2	161000	1	25 -- Cut Dragon Onyx
+	3	162000	1	55 -- Rare Dragon Onyx
+	4	163000	1	10 -- Antique Dragon Onyx
+}
+Group	혼__球-
+{
+	Vnum	51535 -- Cor Diamas (Flawless)
+	1	110000	1	5 -- Rough Dragon Diamond
+	2	111000	1	10 -- Cut Dragon Diamond
+	3	112000	1	15 -- Rare Dragon Diamond
+	4	113000	1	60 -- Antique Dragon Diamond
+	5	114000	1	10 -- Legendary Dragon Diamond
+}
+Group	화혼__球-
+{
+	Vnum	51536 -- Cor Rubinum (Flawless)
+	1	120000	1	5 -- Rough Dragon Ruby
+	2	121000	1	10 -- Cut Dragon Ruby
+	3	122000	1	15 -- Rare Dragon Ruby
+	4	123000	1	60 -- Antique Dragon Ruby
+	5	124000	1	10 -- Legendary Dragon Ruby
+}
+Group	풍혼__球-
+{
+	Vnum	51537 -- Cor Jadeit (Flawless)
+	1	130000	1	5 -- Rough Dragon Jade
+	2	131000	1	10 -- Cut Dragon Jade
+	3	132000	1	15 -- Rare Dragon Jade
+	4	133000	1	60 -- Antique Dragon Jade
+	5	134000	1	10 -- Legendary Dragon Jade
+}
+Group	철혼__球-
+{
+	Vnum	51538 -- Cor Saphirum (Flawless)
+	1	140000	1	5 -- Rough Dragon Sapphire
+	2	141000	1	10 -- Cut Dragon Sapphire
+	3	142000	1	15 -- Rare Dragon Sapphire
+	4	143000	1	60 -- Antique Dragon Sapphire
+	5	144000	1	10 -- Legendary DragonSapphire
+}
+Group	혼__球-
+{
+	Vnum	51539 -- Cor Granatum (Flawless)
+	1	150000	1	5 -- Rough Dragon Garnet
+	2	151000	1	10 -- Cut Dragon Garnet
+	3	152000	1	15 -- Rare Dragon Garnet
+	4	153000	1	60 -- Antique Dragon Garnet
+	5	154000	1	10 -- Legendary Dragon Garnet
+}
+Group	혼__球-
+{
+	Vnum	51540 -- Cor Atrum (Flawless)
+	1	160000	1	5 -- Rough Dragon Onyx
+	2	161000	1	10 -- Cut Dragon Onyx
+	3	162000	1	15 -- Rare Dragon Onyx
+	4	163000	1	60 -- Antique Dragon Onyx
+	5	164000	1	10 -- Legendary Dragon Onyx
+}
+Group	혼__화-
+{
+	Vnum	51541 -- Cor Draconis (Glowing)
+	1	111000	1	100 -- Cut Dragon Diamond
+	2	121000	1	100 -- Cut Dragon Ruby
+	3	131000	1	100 -- Cut Dragon Jade
+	4	141000	1	100 -- Cut Dragon Sapphire
+	5	151000	1	100 -- Cut Dragon Garnet
+	6	161000	1	100 -- Cut Dragon Onyx
+	7	112000	1	43 -- Rare Dragon Diamond
+	8	122000	1	43 -- Rare Dragon Ruby
+	9	132000	1	43 -- Rare Dragon Jade
+	10	142000	1	43 -- Rare Dragon Sapphire
+	11	152000	1	43 -- Rare Dragon Garnet
+	12	162000	1	43 -- Rare Dragon Onyx
+}
+Group	혼__화-
+{
+	Vnum	51542 -- Cor Diamas (Glowing)
+	1	111000	1	7 -- Cut Dragon Diamond
+	2	112000	1	3 -- Rare Dragon Diamond
+}
+Group	화혼__화-
+{
+	Vnum	51543 -- Cor Rubinum (Glowing)
+	1	121000	1	7 -- Cut Dragon Ruby
+	2	122000	1	3 -- Rare Dragon Ruby
+}
+Group	풍혼__화-
+{
+	Vnum	51544 -- Cor Jadeit (Glowing)
+	1	131000	1	7 -- Cut Dragon Jade
+	2	132000	1	3 -- Rare Dragon Jade
+}
+Group	철혼__화-
+{
+	Vnum	51545 -- Cor Saphirum (Glowing)
+	1	141000	1	7 -- Cut Dragon Sapphire
+	2	142000	1	3 -- Rare Dragon Sapphire
+}
+Group	혼__화-
+{
+	Vnum	51546 -- Cor Granatum (Glowing)
+	1	151000	1	7 -- Cut Dragon Garnet
+	2	152000	1	3 -- Rare Dragon Garnet
+}
+Group	혼__화-
+{
+	Vnum	51547 -- Cor Atrum (Glowing)
+	1	161000	1	7 -- Cut Dragon Onyx
+	2	162000	1	3 -- Rare Dragon Onyx
+}
+Group	혼_체
+{
+	Vnum	51548 -- Cor Draconis (Flawless)
+	1	110000	1	35 -- Rough Dragon Diamond
+	2	120000	1	35 -- Rough Dragon Ruby
+	3	130000	1	35 -- Rough Dragon Jade
+	4	140000	1	35 -- Rough Dragon Sapphire
+	5	150000	1	35 -- Rough Dragon Garnet
+	6	160000	1	35 -- Rough Dragon Onyx
+	7	111000	1	70 -- Cut Dragon Diamond
+	8	121000	1	70 -- Cut Dragon Ruby
+	9	131000	1	70 -- Cut Dragon Jade
+	10	141000	1	70 -- Cut Dragon Sapphire
+	11	151000	1	70 -- Cut Dragon Garnet
+	12	161000	1	70 -- Cut Dragon Onyx
+	13	111000	1	105 -- Cut Dragon Diamond
+	14	121000	1	105 -- Cut Dragon Ruby
+	15	131000	1	105 -- Cut Dragon Jade
+	16	141000	1	105 -- Cut Dragon Sapphire
+	17	151000	1	105 -- Cut Dragon Garnet
+	18	161000	1	105 -- Cut Dragon Onyx
+	19	112000	1	420 -- Rare Dragon Diamond
+	20	122000	1	420 -- Rare Dragon Ruby
+	21	132000	1	420 -- Rare Dragon Jade
+	22	142000	1	420 -- Rare Dragon Sapphire
+	23	152000	1	420 -- Rare Dragon Garnet
+	24	162000	1	420 -- Rare Dragon Onyx
+	25	113000	1	70 -- Antique Dragon Diamond
+	26	123000	1	70 -- Antique Dragon Ruby
+	27	133000	1	70 -- Antique Dragon Jade
+	28	143000	1	70 -- Antique Dragon Sapphire
+	29	153000	1	70 -- Antique Dragon Garnet
+	30	163000	1	70 -- Antique Dragon Onyx
+}
+Group	혼__화-
+{
+	Vnum	51549 -- Cor Draconis (Eternal)
+	1	111000	1	27 -- Cut Dragon Diamond
+	2	121000	1	27 -- Cut Dragon Ruby
+	3	131000	1	27 -- Cut Dragon Jade
+	4	141000	1	27 -- Cut Dragon Sapphire
+	5	151000	1	27 -- Cut Dragon Garnet
+	6	161000	1	27 -- Cut Dragon Onyx
+	7	112000	1	56 -- Rare Dragon Diamond
+	8	122000	1	56 -- Rare Dragon Ruby
+	9	132000	1	56 -- Rare Dragon Jade
+	10	142000	1	56 -- Rare Dragon Sapphire
+	11	152000	1	56 -- Rare Dragon Garnet
+	12	162000	1	56 -- Rare Dragon Onyx
+	13	113000	1	9 -- Antique Dragon Diamond
+	14	123000	1	9 -- Antique Dragon Ruby
+	15	133000	1	9 -- Antique Dragon Jade
+	16	143000	1	9 -- Antique Dragon Sapphire
+	17	153000	1	9 -- Antique Dragon Garnet
+	18	163000	1	9 -- Antique Dragon Onyx
+}
+Group	혼__화-
+{
+	Vnum	51550 -- Cor Diamas (Eternal)
+	1	111000	1	3 -- Cut Dragon Diamond
+	2	112000	1	6 -- Rare Dragon Diamond
+	3	113000	1	1 -- Antique Dragon Diamond
+}
+Group	화혼__화-
+{
+	Vnum	51551 -- Cor Rubinum (Eternal)
+	1	121000	1	3 -- Cut Dragon Ruby
+	2	122000	1	6 -- Rare Dragon Ruby
+	3	123000	1	1 -- Antique Dragon Ruby
+}
+Group	풍혼__화-
+{
+	Vnum	51552 -- Cor Jadeit (Eternal)
+	1	131000	1	3 -- Cut Dragon Jade
+	2	132000	1	6 -- Rare Dragon Jade
+	3	133000	1	1 -- Antique Dragon Jade
+}
+Group	철혼__화-
+{
+	Vnum	51553 -- Cor Saphirum (Eternal)
+	1	141000	1	3 -- Cut Dragon Sapphire
+	2	142000	1	6 -- Rare Dragon Sapphire
+	3	143000	1	1 -- Antique Dragon Sapphire
+}
+Group	혼__화-
+{
+	Vnum	51554 -- Cor Granatum (Eternal)
+	1	151000	1	3 -- Cut Dragon Garnet
+	2	152000	1	6 -- Rare Dragon Garnet
+	3	153000	1	1 -- Antique Dragon Garnet
+}
+Group	혼__화-
+{
+	Vnum	51555 -- Cor Atrum (Eternal)
+	1	161000	1	3 -- Cut Dragon Onyx
+	2	162000	1	6 -- Rare Dragon Onyx
+	3	163000	1	1 -- Antique Dragon Onyx
+}
+Group	혼__화-
+{
+	Vnum	51556 -- Cor Diamas (Mystical)
+	1	111000	1	10 -- Cut Dragon Diamond
+	2	112000	1	25 -- Rare Dragon Diamond
+	3	113000	1	55 -- Antique Dragon Diamond
+	4	114000	1	10 -- Legendary Dragon Diamond
+}
+Group	화혼__화-
+{
+	Vnum	51557 -- Cor Rubinum (Mystical)
+	1	121000	1	10 -- Cut Dragon Ruby
+	2	122000	1	25 -- Rare Dragon Ruby
+	3	123000	1	55 -- Antique Dragon Ruby
+	4	124000	1	10 -- Legendary Dragon Ruby
+}
+Group	풍혼__화-
+{
+	Vnum	51558 -- Cor Jadeit (Mystical)
+	1	131000	1	10 -- Cut Dragon Jade
+	2	132000	1	25 -- Rare Dragon Jade
+	3	133000	1	55 -- Antique Dragon Jade
+	4	134000	1	10 -- Legendary Dragon Jade
+}
+Group	철혼__화-
+{
+	Vnum	51559 -- Cor Saphirum (Mystical)
+	1	141000	1	10 -- Cut Dragon Sapphire
+	2	142000	1	25 -- Rare Dragon Sapphire
+	3	143000	1	55 -- Antique Dragon Sapphire
+	4	144000	1	10 -- Legendary DragonSapphire
+}
+Group	혼__화-
+{
+	Vnum	51560 -- Cor Granatum (Mystical)
+	1	151000	1	10 -- Cut Dragon Garnet
+	2	152000	1	25 -- Rare Dragon Garnet
+	3	153000	1	55 -- Antique Dragon Garnet
+	4	154000	1	10 -- Legendary Dragon Garnet
+}
+Group	혼__화-
+{
+	Vnum	51561 -- Cor Atrum (Mystical)
+	1	161000	1	10 -- Cut Dragon Onyx
+	2	162000	1	25 -- Rare Dragon Onyx
+	3	163000	1	55 -- Antique Dragon Onyx
+	4	164000	1	10 -- Legendary Dragon Onyx
+}
+Group	혼__-
+{
+	Vnum	51562 -- Cor Draconis (Epic)
+	1	112000	1	100 -- Rare Dragon Diamond
+	2	122000	1	100 -- Rare Dragon Ruby
+	3	132000	1	100 -- Rare Dragon Jade
+	4	142000	1	100 -- Rare Dragon Sapphire
+	5	152000	1	100 -- Rare Dragon Garnet
+	6	162000	1	100 -- Rare Dragon Onyx
+	7	113000	1	43 -- Antique Dragon Diamond
+	8	123000	1	43 -- Antique Dragon Ruby
+	9	133000	1	43 -- Antique Dragon Jade
+	10	143000	1	43 -- Antique Dragon Sapphire
+	11	153000	1	43 -- Antique Dragon Garnet
+	12	163000	1	43 -- Antique Dragon Onyx
+}
+Group	혼__-
+{
+	Vnum	51563 -- Cor Diamas (Epic)
+	1	112000	1	7 -- Rare Dragon Diamond
+	2	113000	1	3 -- Antique Dragon Diamond
+}
+Group	화혼__-
+{
+	Vnum	51564 -- Cor Rubinum (Epic)
+	1	122000	1	7 -- Rare Dragon Ruby
+	2	123000	1	3 -- Antique Dragon Ruby
+}
+Group	풍혼__-
+{
+	Vnum	51565 -- Cor Jadeit (Epic)
+	1	132000	1	7 -- Rare Dragon Jade
+	2	133000	1	3 -- Antique Dragon Jade
+}
+Group	철혼__-
+{
+	Vnum	51566 -- Cor Saphirum (Epic)
+	1	142000	1	7 -- Rare Dragon Sapphire
+	2	143000	1	3 -- Antique Dragon Sapphire
+}
+Group	혼__-
+{
+	Vnum	51567 -- Cor Granatum (Epic)
+	1	152000	1	7 -- Rare Dragon Garnet
+	2	153000	1	3 -- Antique Dragon Garnet
+}
+Group	혼__-
+{
+	Vnum	51568 -- Cor Atrum (Epic)
+	1	162000	1	7 -- Rare Dragon Onyx
+	2	163000	1	3 -- Antique Dragon Onyx
+}
+Group	혼__-
+{
+	Vnum	51569 -- Cor Draconis (Divine)
+	1	112000	1	27 -- Rare Dragon Diamond
+	2	122000	1	27 -- Rare Dragon Ruby
+	3	132000	1	27 -- Rare Dragon Jade
+	4	142000	1	27 -- Rare Dragon Sapphire
+	5	152000	1	27 -- Rare Dragon Garnet
+	6	162000	1	27 -- Rare Dragon Onyx
+	7	113000	1	56 -- Antique Dragon Diamond
+	8	123000	1	56 -- Antique Dragon Ruby
+	9	133000	1	56 -- Antique Dragon Jade
+	10	143000	1	56 -- Antique Dragon Sapphire
+	11	153000	1	56 -- Antique Dragon Garnet
+	12	163000	1	56 -- Antique Dragon Onyx
+	13	114000	1	9 -- Legendary Dragon Diamond
+	14	124000	1	9 -- Legendary Dragon Ruby
+	15	134000	1	9 -- Legendary Dragon Jade
+	16	144000	1	9 -- Legendary DragonSapphire
+	17	154000	1	9 -- Legendary Dragon Garnet
+	18	164000	1	9 -- Legendary Dragon Onyx
+}
+Group	혼__-
+{
+	Vnum	51570 -- Cor Diamas (Divine)
+	1	112000	1	3 -- Rare Dragon Diamond
+	2	113000	1	6 -- Antique Dragon Diamond
+	3	114000	1	1 -- Legendary Dragon Diamond
+}
+Group	화혼__-
+{
+	Vnum	51571 -- Cor Rubinum (Divine)
+	1	122000	1	3 -- Rare Dragon Ruby
+	2	123000	1	6 -- Antique Dragon Ruby
+	3	124000	1	1 -- Legendary Dragon Ruby
+}
+Group	풍혼__-
+{
+	Vnum	51572 -- Cor Jadeit (Divine)
+	1	132000	1	3 -- Rare Dragon Jade
+	2	133000	1	6 -- Antique Dragon Jade
+	3	134000	1	1 -- Legendary Dragon Jade
+}
+Group	철혼__-
+{
+	Vnum	51573 -- Cor Saphirum (Divine)
+	1	142000	1	3 -- Rare Dragon Sapphire
+	2	143000	1	6 -- Antique Dragon Sapphire
+	3	144000	1	1 -- Legendary DragonSapphire
+}
+Group	혼__-
+{
+	Vnum	51574 -- Cor Granatum (Divine)
+	1	152000	1	3 -- Rare Dragon Garnet
+	2	153000	1	6 -- Antique Dragon Garnet
+	3	154000	1	1 -- Legendary Dragon Garnet
+}
+Group	혼__-
+{
+	Vnum	51575 -- Cor Atrum (Divine)
+	1	162000	1	3 -- Rare Dragon Onyx
+	2	163000	1	6 -- Antique Dragon Onyx
+	3	164000	1	1 -- Legendary Dragon Onyx
+}
+Group	肌혼_球-화
+{
+	Vnum	51576 -- Cor Draconis+ (Normal)
+	1	110000	1	324 -- Rough Dragon Diamond
+	2	110010	1	1080
+	3	110020	1	360
+	4	110100	1	1080 -- Rough Dragon Diamond
+	5	110110	1	3600
+	6	110120	1	1200
+	7	110200	1	360 -- Rough Dragon Diamond
+	8	110210	1	1200
+	9	110220	1	400
+	10	110230	1	20
+	11	110300	1	18 -- Rough Dragon Diamond
+	12	110310	1	60
+	13	110320	1	20
+	14	110330	1	1
+	15	110400	1	18 -- Rough Dragon Diamond
+	16	110410	1	60
+	17	110420	1	20
+	18	110430	1	1
+	19	110440	1	1
+	20	111000	1	756 -- Cut Dragon Diamond
+	21	111010	1	2520
+	22	111020	1	840
+	23	111030	1	42
+	24	111100	1	2520 -- Cut Dragon Diamond
+	25	111110	1	8400
+	26	111120	1	2800
+	27	111130	1	140
+	28	111200	1	840 -- Cut Dragon Diamond
+	29	111210	1	2800
+	30	111220	1	933
+	31	111230	1	47
+	32	111300	1	42 -- Cut Dragon Diamond
+	33	111310	1	140
+	34	111320	1	47
+	35	111330	1	2
+	36	111340	1	2
+	37	111400	1	42 -- Cut Dragon Diamond
+	38	111410	1	140
+	39	111420	1	47
+	40	111430	1	2
+	41	111440	1	2
+	42	120000	1	324 -- Rough Dragon Ruby
+	43	120010	1	1080
+	44	120020	1	360
+	45	120100	1	1080 -- Rough Dragon Ruby
+	46	120110	1	3600
+	47	120120	1	1200
+	48	120200	1	360 -- Rough Dragon Ruby
+	49	120210	1	1200
+	50	120220	1	400
+	51	120230	1	20
+	52	120300	1	18 -- Rough Dragon Ruby
+	53	120310	1	60
+	54	120320	1	20
+	55	120330	1	1
+	56	120400	1	18 -- Rough Dragon Ruby
+	57	120410	1	60
+	58	120420	1	20
+	59	120430	1	1
+	60	120440	1	1
+	61	121000	1	756 -- Cut Dragon Ruby
+	62	121010	1	2520
+	63	121020	1	840
+	64	121030	1	42
+	65	121100	1	2520 -- Cut Dragon Ruby
+	66	121110	1	8400
+	67	121120	1	2800
+	68	121130	1	140
+	69	121200	1	840 -- Cut Dragon Ruby
+	70	121210	1	2800
+	71	121220	1	933
+	72	121230	1	47
+	73	121300	1	42 -- Cut Dragon Ruby
+	74	121310	1	140
+	75	121320	1	47
+	76	121330	1	2
+	77	121340	1	2
+	78	121400	1	42 -- Cut Dragon Ruby
+	79	121410	1	140
+	80	121420	1	47
+	81	121430	1	2
+	82	121440	1	2
+	83	130000	1	324 -- Rough Dragon Jade
+	84	130010	1	1080
+	85	130020	1	360
+	86	130100	1	1080 -- Rough Dragon Jade
+	87	130110	1	3600
+	88	130120	1	1200
+	89	130200	1	360 -- Rough Dragon Jade
+	90	130210	1	1200
+	91	130220	1	400
+	92	130230	1	20
+	93	130300	1	18 -- Rough Dragon Jade
+	94	130310	1	60
+	95	130320	1	20
+	96	130330	1	1
+	97	130400	1	18 -- Rough Dragon Jade
+	98	130410	1	60
+	99	130420	1	20
+	100	130430	1	1
+	101	130440	1	1
+	102	131000	1	756 -- Cut Dragon Jade
+	103	131010	1	2520
+	104	131020	1	840
+	105	131030	1	42
+	106	131100	1	2520 -- Cut Dragon Jade
+	107	131110	1	8400
+	108	131120	1	2800
+	109	131130	1	140
+	110	131200	1	840 -- Cut Dragon Jade
+	111	131210	1	2800
+	112	131220	1	933
+	113	131230	1	47
+	114	131300	1	42 -- Cut Dragon Jade
+	115	131310	1	140
+	116	131320	1	47
+	117	131330	1	2
+	118	131340	1	2
+	119	131400	1	42 -- Cut Dragon Jade
+	120	131410	1	140
+	121	131420	1	47
+	122	131430	1	2
+	123	131440	1	2
+	124	140000	1	324 -- Rough Dragon Sapphire
+	125	140010	1	1080
+	126	140020	1	360
+	127	140100	1	1080 -- Rough Dragon Sapphire
+	128	140110	1	3600
+	129	140120	1	1200
+	130	140200	1	360 -- Rough Dragon Sapphire
+	131	140210	1	1200
+	132	140220	1	400
+	133	140230	1	20
+	134	140300	1	18 -- Rough Dragon Sapphire
+	135	140310	1	60
+	136	140320	1	20
+	137	140330	1	1
+	138	140400	1	18 -- Rough Dragon Sapphire
+	139	140410	1	60
+	140	140420	1	20
+	141	140430	1	1
+	142	140440	1	1
+	143	141000	1	756 -- Cut Dragon Sapphire
+	144	141010	1	2520
+	145	141020	1	840
+	146	141030	1	42
+	147	141100	1	2520 -- Cut Dragon Sapphire
+	148	141110	1	8400
+	149	141120	1	2800
+	150	141130	1	140
+	151	141200	1	840 -- Cut Dragon Sapphire
+	152	141210	1	2800
+	153	141220	1	933
+	154	141230	1	47
+	155	141300	1	42 -- Cut Dragon Sapphire
+	156	141310	1	140
+	157	141320	1	47
+	158	141330	1	2
+	159	141340	1	2
+	160	141400	1	42 -- Cut Dragon Sapphire
+	161	141410	1	140
+	162	141420	1	47
+	163	141430	1	2
+	164	141440	1	2
+	165	150000	1	324 -- Rough Dragon Garnet
+	166	150010	1	1080
+	167	150020	1	360
+	168	150100	1	1080 -- Rough Dragon Garnet
+	169	150110	1	3600
+	170	150120	1	1200
+	171	150200	1	360 -- Rough Dragon Garnet
+	172	150210	1	1200
+	173	150220	1	400
+	174	150230	1	20
+	175	150300	1	18 -- Rough Dragon Garnet
+	176	150310	1	60
+	177	150320	1	20
+	178	150330	1	1
+	179	150400	1	18 -- Rough Dragon Garnet
+	180	150410	1	60
+	181	150420	1	20
+	182	150430	1	1
+	183	150440	1	1
+	184	151000	1	756 -- Cut Dragon Garnet
+	185	151010	1	2520
+	186	151020	1	840
+	187	151030	1	42
+	188	151100	1	2520 -- Cut Dragon Garnet
+	189	151110	1	8400
+	190	151120	1	2800
+	191	151130	1	140
+	192	151200	1	840 -- Cut Dragon Garnet
+	193	151210	1	2800
+	194	151220	1	933
+	195	151230	1	47
+	196	151300	1	42 -- Cut Dragon Garnet
+	197	151310	1	140
+	198	151320	1	47
+	199	151330	1	2
+	200	151340	1	2
+	201	151400	1	42 -- Cut Dragon Garnet
+	202	151410	1	140
+	203	151420	1	47
+	204	151430	1	2
+	205	151440	1	2
+	206	160000	1	324 -- Rough Dragon Onyx
+	207	160010	1	1080
+	208	160020	1	360
+	209	160100	1	1080 -- Rough Dragon Onyx
+	210	160110	1	3600
+	211	160120	1	1200
+	212	160200	1	360 -- Rough Dragon Onyx
+	213	160210	1	1200
+	214	160220	1	400
+	215	160230	1	20
+	216	160300	1	18 -- Rough Dragon Onyx
+	217	160310	1	60
+	218	160320	1	20
+	219	160330	1	1
+	220	160400	1	18 -- Rough Dragon Onyx
+	221	160410	1	60
+	222	160420	1	20
+	223	160430	1	1
+	224	160440	1	1
+	225	161000	1	756 -- Cut Dragon Onyx
+	226	161010	1	2520
+	227	161020	1	840
+	228	161030	1	42
+	229	161100	1	2520 -- Cut Dragon Onyx
+	230	161110	1	8400
+	231	161120	1	2800
+	232	161130	1	140
+	233	161200	1	840 -- Cut Dragon Onyx
+	234	161210	1	2800
+	235	161220	1	933
+	236	161230	1	47
+	237	161300	1	42 -- Cut Dragon Onyx
+	238	161310	1	140
+	239	161320	1	47
+	240	161330	1	2
+	241	161340	1	2
+	242	161400	1	42 -- Cut Dragon Onyx
+	243	161410	1	140
+	244	161420	1	47
+	245	161430	1	2
+	246	161440	1	2
+}
+Group	麗肌혼_球-화
+{
+	Vnum	51577 -- Cor Diamas+ (Normal)
+	1	110000	1	324 -- Rough Dragon Diamond
+	2	110010	1	1080
+	3	110020	1	360
+	4	110100	1	1080 -- Rough Dragon Diamond
+	5	110110	1	3600
+	6	110120	1	1200
+	7	110200	1	360 -- Rough Dragon Diamond
+	8	110210	1	1200
+	9	110220	1	400
+	10	110230	1	20
+	11	110300	1	18 -- Rough Dragon Diamond
+	12	110310	1	60
+	13	110320	1	20
+	14	110330	1	1
+	15	110400	1	18 -- Rough Dragon Diamond
+	16	110410	1	60
+	17	110420	1	20
+	18	110430	1	1
+	19	110440	1	1
+	20	111000	1	756 -- Cut Dragon Diamond
+	21	111010	1	2520
+	22	111020	1	840
+	23	111030	1	42
+	24	111100	1	2520 -- Cut Dragon Diamond
+	25	111110	1	8400
+	26	111120	1	2800
+	27	111130	1	140
+	28	111200	1	840 -- Cut Dragon Diamond
+	29	111210	1	2800
+	30	111220	1	933
+	31	111230	1	47
+	32	111300	1	42 -- Cut Dragon Diamond
+	33	111310	1	140
+	34	111320	1	47
+	35	111330	1	2
+	36	111340	1	2
+	37	111400	1	42 -- Cut Dragon Diamond
+	38	111410	1	140
+	39	111420	1	47
+	40	111430	1	2
+	41	111440	1	2
+}
+Group	화麗肌혼_球-화
+{
+	Vnum	51578 -- Cor Rubinum+ (Normal)
+	1	120000	1	324 -- Rough Dragon Ruby
+	2	120010	1	1080
+	3	120020	1	360
+	4	120100	1	1080 -- Rough Dragon Ruby
+	5	120110	1	3600
+	6	120120	1	1200
+	7	120200	1	360 -- Rough Dragon Ruby
+	8	120210	1	1200
+	9	120220	1	400
+	10	120230	1	20
+	11	120300	1	18 -- Rough Dragon Ruby
+	12	120310	1	60
+	13	120320	1	20
+	14	120330	1	1
+	15	120400	1	18 -- Rough Dragon Ruby
+	16	120410	1	60
+	17	120420	1	20
+	18	120430	1	1
+	19	120440	1	1
+	20	121000	1	756 -- Cut Dragon Ruby
+	21	121010	1	2520
+	22	121020	1	840
+	23	121030	1	42
+	24	121100	1	2520 -- Cut Dragon Ruby
+	25	121110	1	8400
+	26	121120	1	2800
+	27	121130	1	140
+	28	121200	1	840 -- Cut Dragon Ruby
+	29	121210	1	2800
+	30	121220	1	933
+	31	121230	1	47
+	32	121300	1	42 -- Cut Dragon Ruby
+	33	121310	1	140
+	34	121320	1	47
+	35	121330	1	2
+	36	121340	1	2
+	37	121400	1	42 -- Cut Dragon Ruby
+	38	121410	1	140
+	39	121420	1	47
+	40	121430	1	2
+	41	121440	1	2
+}
+Group	풍麗肌혼_球-화
+{
+	Vnum	51579 -- Cor Jadeit+ (Normal)
+	1	130000	1	324 -- Rough Dragon Jade
+	2	130010	1	1080
+	3	130020	1	360
+	4	130100	1	1080 -- Rough Dragon Jade
+	5	130110	1	3600
+	6	130120	1	1200
+	7	130200	1	360 -- Rough Dragon Jade
+	8	130210	1	1200
+	9	130220	1	400
+	10	130230	1	20
+	11	130300	1	18 -- Rough Dragon Jade
+	12	130310	1	60
+	13	130320	1	20
+	14	130330	1	1
+	15	130400	1	18 -- Rough Dragon Jade
+	16	130410	1	60
+	17	130420	1	20
+	18	130430	1	1
+	19	130440	1	1
+	20	131000	1	756 -- Cut Dragon Jade
+	21	131010	1	2520
+	22	131020	1	840
+	23	131030	1	42
+	24	131100	1	2520 -- Cut Dragon Jade
+	25	131110	1	8400
+	26	131120	1	2800
+	27	131130	1	140
+	28	131200	1	840 -- Cut Dragon Jade
+	29	131210	1	2800
+	30	131220	1	933
+	31	131230	1	47
+	32	131300	1	42 -- Cut Dragon Jade
+	33	131310	1	140
+	34	131320	1	47
+	35	131330	1	2
+	36	131340	1	2
+	37	131400	1	42 -- Cut Dragon Jade
+	38	131410	1	140
+	39	131420	1	47
+	40	131430	1	2
+	41	131440	1	2
+}
+Group	철麗肌혼_球-화
+{
+	Vnum	51580 -- Cor Saphirum+ (Normal)
+	1	140000	1	324 -- Rough Dragon Sapphire
+	2	140010	1	1080
+	3	140020	1	360
+	4	140100	1	1080 -- Rough Dragon Sapphire
+	5	140110	1	3600
+	6	140120	1	1200
+	7	140200	1	360 -- Rough Dragon Sapphire
+	8	140210	1	1200
+	9	140220	1	400
+	10	140230	1	20
+	11	140300	1	18 -- Rough Dragon Sapphire
+	12	140310	1	60
+	13	140320	1	20
+	14	140330	1	1
+	15	140400	1	18 -- Rough Dragon Sapphire
+	16	140410	1	60
+	17	140420	1	20
+	18	140430	1	1
+	19	140440	1	1
+	20	141000	1	756 -- Cut Dragon Sapphire
+	21	141010	1	2520
+	22	141020	1	840
+	23	141030	1	42
+	24	141100	1	2520 -- Cut Dragon Sapphire
+	25	141110	1	8400
+	26	141120	1	2800
+	27	141130	1	140
+	28	141200	1	840 -- Cut Dragon Sapphire
+	29	141210	1	2800
+	30	141220	1	933
+	31	141230	1	47
+	32	141300	1	42 -- Cut Dragon Sapphire
+	33	141310	1	140
+	34	141320	1	47
+	35	141330	1	2
+	36	141340	1	2
+	37	141400	1	42 -- Cut Dragon Sapphire
+	38	141410	1	140
+	39	141420	1	47
+	40	141430	1	2
+	41	141440	1	2
+}
+Group	麗肌혼_球-화
+{
+	Vnum	51581 -- Cor Granatum+ (Normal)
+	1	150000	1	324 -- Rough Dragon Garnet
+	2	150010	1	1080
+	3	150020	1	360
+	4	150100	1	1080 -- Rough Dragon Garnet
+	5	150110	1	3600
+	6	150120	1	1200
+	7	150200	1	360 -- Rough Dragon Garnet
+	8	150210	1	1200
+	9	150220	1	400
+	10	150230	1	20
+	11	150300	1	18 -- Rough Dragon Garnet
+	12	150310	1	60
+	13	150320	1	20
+	14	150330	1	1
+	15	150400	1	18 -- Rough Dragon Garnet
+	16	150410	1	60
+	17	150420	1	20
+	18	150430	1	1
+	19	150440	1	1
+	20	151000	1	756 -- Cut Dragon Garnet
+	21	151010	1	2520
+	22	151020	1	840
+	23	151030	1	42
+	24	151100	1	2520 -- Cut Dragon Garnet
+	25	151110	1	8400
+	26	151120	1	2800
+	27	151130	1	140
+	28	151200	1	840 -- Cut Dragon Garnet
+	29	151210	1	2800
+	30	151220	1	933
+	31	151230	1	47
+	32	151300	1	42 -- Cut Dragon Garnet
+	33	151310	1	140
+	34	151320	1	47
+	35	151330	1	2
+	36	151340	1	2
+	37	151400	1	42 -- Cut Dragon Garnet
+	38	151410	1	140
+	39	151420	1	47
+	40	151430	1	2
+	41	151440	1	2
+}
+Group	麗肌혼_球-화
+{
+	Vnum	51582 -- Cor Atrum+ (Normal)
+	1	160000	1	324 -- Rough Dragon Onyx
+	2	160010	1	1080
+	3	160020	1	360
+	4	160100	1	1080 -- Rough Dragon Onyx
+	5	160110	1	3600
+	6	160120	1	1200
+	7	160200	1	360 -- Rough Dragon Onyx
+	8	160210	1	1200
+	9	160220	1	400
+	10	160230	1	20
+	11	160300	1	18 -- Rough Dragon Onyx
+	12	160310	1	60
+	13	160320	1	20
+	14	160330	1	1
+	15	160400	1	18 -- Rough Dragon Onyx
+	16	160410	1	60
+	17	160420	1	20
+	18	160430	1	1
+	19	160440	1	1
+	20	161000	1	756 -- Cut Dragon Onyx
+	21	161010	1	2520
+	22	161020	1	840
+	23	161030	1	42
+	24	161100	1	2520 -- Cut Dragon Onyx
+	25	161110	1	8400
+	26	161120	1	2800
+	27	161130	1	140
+	28	161200	1	840 -- Cut Dragon Onyx
+	29	161210	1	2800
+	30	161220	1	933
+	31	161230	1	47
+	32	161300	1	42 -- Cut Dragon Onyx
+	33	161310	1	140
+	34	161320	1	47
+	35	161330	1	2
+	36	161340	1	2
+	37	161400	1	42 -- Cut Dragon Onyx
+	38	161410	1	140
+	39	161420	1	47
+	40	161430	1	2
+	41	161440	1	2
+}
+Group	肌혼_球-
+{
+	Vnum	51583 -- Cor Draconis+ (Noble)
+	1	110000	1	972 -- Rough Dragon Diamond
+	2	110010	1	3240
+	3	110020	1	1080
+	4	110100	1	3240 -- Rough Dragon Diamond
+	5	110110	1	10800
+	6	110120	1	3600
+	7	110200	1	1080 -- Rough Dragon Diamond
+	8	110210	1	3600
+	9	110220	1	1200
+	10	110230	1	60
+	11	110300	1	54 -- Rough Dragon Diamond
+	12	110310	1	180
+	13	110320	1	60
+	14	110330	1	3
+	15	110400	1	54 -- Rough Dragon Diamond
+	16	110410	1	180
+	17	110420	1	60
+	18	110430	1	3
+	19	110440	1	3
+	20	111000	1	1944 -- Cut Dragon Diamond
+	21	111010	1	6480
+	22	111020	1	2160
+	23	111030	1	108
+	24	111100	1	6480 -- Cut Dragon Diamond
+	25	111110	1	21600
+	26	111120	1	7200
+	27	111130	1	360
+	28	111200	1	2160 -- Cut Dragon Diamond
+	29	111210	1	7200
+	30	111220	1	2400
+	31	111230	1	120
+	32	111300	1	108 -- Cut Dragon Diamond
+	33	111310	1	360
+	34	111320	1	120
+	35	111330	1	6
+	36	111340	1	6
+	37	111400	1	108 -- Cut Dragon Diamond
+	38	111410	1	360
+	39	111420	1	120
+	40	111430	1	6
+	41	111440	1	6
+	42	112000	1	324 -- Rare Dragon Diamond
+	43	112010	1	1080
+	44	112020	1	360
+	45	112030	1	18
+	46	112040	1	18
+	47	112100	1	1080 -- Rare Dragon Diamond
+	48	112110	1	3600
+	49	112120	1	1200
+	50	112130	1	60
+	51	112140	1	60
+	52	112200	1	360 -- Rare Dragon Diamond
+	53	112210	1	1200
+	54	112220	1	400
+	55	112230	1	20
+	56	112240	1	20
+	57	112300	1	18 -- Rare Dragon Diamond
+	58	112310	1	60
+	59	112320	1	20
+	60	112330	1	1
+	61	112340	1	1
+	62	112400	1	18 -- Rare Dragon Diamond
+	63	112410	1	60
+	64	112420	1	20
+	65	112430	1	1
+	66	112440	1	1
+	67	120000	1	972 -- Rough Dragon Ruby
+	68	120010	1	3240
+	69	120020	1	1080
+	70	120100	1	3240 -- Rough Dragon Ruby
+	71	120110	1	10800
+	72	120120	1	3600
+	73	120200	1	1080 -- Rough Dragon Ruby
+	74	120210	1	3600
+	75	120220	1	1200
+	76	120230	1	60
+	77	120300	1	54 -- Rough Dragon Ruby
+	78	120310	1	180
+	79	120320	1	60
+	80	120330	1	3
+	81	120400	1	54 -- Rough Dragon Ruby
+	82	120410	1	180
+	83	120420	1	60
+	84	120430	1	3
+	85	120440	1	3
+	86	121000	1	1944 -- Cut Dragon Ruby
+	87	121010	1	6480
+	88	121020	1	2160
+	89	121030	1	108
+	90	121100	1	6480 -- Cut Dragon Ruby
+	91	121110	1	21600
+	92	121120	1	7200
+	93	121130	1	360
+	94	121200	1	2160 -- Cut Dragon Ruby
+	95	121210	1	7200
+	96	121220	1	2400
+	97	121230	1	120
+	98	121300	1	108 -- Cut Dragon Ruby
+	99	121310	1	360
+	100	121320	1	120
+	101	121330	1	6
+	102	121340	1	6
+	103	121400	1	108 -- Cut Dragon Ruby
+	104	121410	1	360
+	105	121420	1	120
+	106	121430	1	6
+	107	121440	1	6
+	108	122000	1	324 -- Rare Dragon Ruby
+	109	122010	1	1080
+	110	122020	1	360
+	111	122030	1	18
+	112	122040	1	18
+	113	122100	1	1080 -- Rare Dragon Ruby
+	114	122110	1	3600
+	115	122120	1	1200
+	116	122130	1	60
+	117	122140	1	60
+	118	122200	1	360 -- Rare Dragon Ruby
+	119	122210	1	1200
+	120	122220	1	400
+	121	122230	1	20
+	122	122240	1	20
+	123	122300	1	18 -- Rare Dragon Ruby
+	124	122310	1	60
+	125	122320	1	20
+	126	122330	1	1
+	127	122340	1	1
+	128	122400	1	18 -- Rare Dragon Ruby
+	129	122410	1	60
+	130	122420	1	20
+	131	122430	1	1
+	132	122440	1	1
+	133	130000	1	972 -- Rough Dragon Jade
+	134	130010	1	3240
+	135	130020	1	1080
+	136	130100	1	3240 -- Rough Dragon Jade
+	137	130110	1	10800
+	138	130120	1	3600
+	139	130200	1	1080 -- Rough Dragon Jade
+	140	130210	1	3600
+	141	130220	1	1200
+	142	130230	1	60
+	143	130300	1	54 -- Rough Dragon Jade
+	144	130310	1	180
+	145	130320	1	60
+	146	130330	1	3
+	147	130400	1	54 -- Rough Dragon Jade
+	148	130410	1	180
+	149	130420	1	60
+	150	130430	1	3
+	151	130440	1	3
+	152	131000	1	1944 -- Cut Dragon Jade
+	153	131010	1	6480
+	154	131020	1	2160
+	155	131030	1	108
+	156	131100	1	6480 -- Cut Dragon Jade
+	157	131110	1	21600
+	158	131120	1	7200
+	159	131130	1	360
+	160	131200	1	2160 -- Cut Dragon Jade
+	161	131210	1	7200
+	162	131220	1	2400
+	163	131230	1	120
+	164	131300	1	108 -- Cut Dragon Jade
+	165	131310	1	360
+	166	131320	1	120
+	167	131330	1	6
+	168	131340	1	6
+	169	131400	1	108 -- Cut Dragon Jade
+	170	131410	1	360
+	171	131420	1	120
+	172	131430	1	6
+	173	131440	1	6
+	174	132000	1	324 -- Rare Dragon Jade
+	175	132010	1	1080
+	176	132020	1	360
+	177	132030	1	18
+	178	132040	1	18
+	179	132100	1	1080 -- Rare Dragon Jade
+	180	132110	1	3600
+	181	132120	1	1200
+	182	132130	1	60
+	183	132140	1	60
+	184	132200	1	360 -- Rare Dragon Jade
+	185	132210	1	1200
+	186	132220	1	400
+	187	132230	1	20
+	188	132240	1	20
+	189	132300	1	18 -- Rare Dragon Jade
+	190	132310	1	60
+	191	132320	1	20
+	192	132330	1	1
+	193	132340	1	1
+	194	132400	1	18 -- Rare Dragon Jade
+	195	132410	1	60
+	196	132420	1	20
+	197	132430	1	1
+	198	132440	1	1
+	199	140000	1	972 -- Rough Dragon Sapphire
+	200	140010	1	3240
+	201	140020	1	1080
+	202	140100	1	3240 -- Rough Dragon Sapphire
+	203	140110	1	10800
+	204	140120	1	3600
+	205	140200	1	1080 -- Rough Dragon Sapphire
+	206	140210	1	3600
+	207	140220	1	1200
+	208	140230	1	60
+	209	140300	1	54 -- Rough Dragon Sapphire
+	210	140310	1	180
+	211	140320	1	60
+	212	140330	1	3
+	213	140400	1	54 -- Rough Dragon Sapphire
+	214	140410	1	180
+	215	140420	1	60
+	216	140430	1	3
+	217	140440	1	3
+	218	141000	1	1944 -- Cut Dragon Sapphire
+	219	141010	1	6480
+	220	141020	1	2160
+	221	141030	1	108
+	222	141100	1	6480 -- Cut Dragon Sapphire
+	223	141110	1	21600
+	224	141120	1	7200
+	225	141130	1	360
+	226	141200	1	2160 -- Cut Dragon Sapphire
+	227	141210	1	7200
+	228	141220	1	2400
+	229	141230	1	120
+	230	141300	1	108 -- Cut Dragon Sapphire
+	231	141310	1	360
+	232	141320	1	120
+	233	141330	1	6
+	234	141340	1	6
+	235	141400	1	108 -- Cut Dragon Sapphire
+	236	141410	1	360
+	237	141420	1	120
+	238	141430	1	6
+	239	141440	1	6
+	240	142000	1	324 -- Rare Dragon Sapphire
+	241	142010	1	1080
+	242	142020	1	360
+	243	142030	1	18
+	244	142040	1	18
+	245	142100	1	1080 -- Rare Dragon Sapphire
+	246	142110	1	3600
+	247	142120	1	1200
+	248	142130	1	60
+	249	142140	1	60
+	250	142200	1	360 -- Rare Dragon Sapphire
+	251	142210	1	1200
+	252	142220	1	400
+	253	142230	1	20
+	254	142240	1	20
+	255	142300	1	18 -- Rare Dragon Sapphire
+	256	142310	1	60
+	257	142320	1	20
+	258	142330	1	1
+	259	142340	1	1
+	260	142400	1	18 -- Rare Dragon Sapphire
+	261	142410	1	60
+	262	142420	1	20
+	263	142430	1	1
+	264	142440	1	1
+	265	150000	1	972 -- Rough Dragon Garnet
+	266	150010	1	3240
+	267	150020	1	1080
+	268	150100	1	3240 -- Rough Dragon Garnet
+	269	150110	1	10800
+	270	150120	1	3600
+	271	150200	1	1080 -- Rough Dragon Garnet
+	272	150210	1	3600
+	273	150220	1	1200
+	274	150230	1	60
+	275	150300	1	54 -- Rough Dragon Garnet
+	276	150310	1	180
+	277	150320	1	60
+	278	150330	1	3
+	279	150400	1	54 -- Rough Dragon Garnet
+	280	150410	1	180
+	281	150420	1	60
+	282	150430	1	3
+	283	150440	1	3
+	284	151000	1	1944 -- Cut Dragon Garnet
+	285	151010	1	6480
+	286	151020	1	2160
+	287	151030	1	108
+	288	151100	1	6480 -- Cut Dragon Garnet
+	289	151110	1	21600
+	290	151120	1	7200
+	291	151130	1	360
+	292	151200	1	2160 -- Cut Dragon Garnet
+	293	151210	1	7200
+	294	151220	1	2400
+	295	151230	1	120
+	296	151300	1	108 -- Cut Dragon Garnet
+	297	151310	1	360
+	298	151320	1	120
+	299	151330	1	6
+	300	151340	1	6
+	301	151400	1	108 -- Cut Dragon Garnet
+	302	151410	1	360
+	303	151420	1	120
+	304	151430	1	6
+	305	151440	1	6
+	306	152000	1	324 -- Rare Dragon Garnet
+	307	152010	1	1080
+	308	152020	1	360
+	309	152030	1	18
+	310	152040	1	18
+	311	152100	1	1080 -- Rare Dragon Garnet
+	312	152110	1	3600
+	313	152120	1	1200
+	314	152130	1	60
+	315	152140	1	60
+	316	152200	1	360 -- Rare Dragon Garnet
+	317	152210	1	1200
+	318	152220	1	400
+	319	152230	1	20
+	320	152240	1	20
+	321	152300	1	18 -- Rare Dragon Garnet
+	322	152310	1	60
+	323	152320	1	20
+	324	152330	1	1
+	325	152340	1	1
+	326	152400	1	18 -- Rare Dragon Garnet
+	327	152410	1	60
+	328	152420	1	20
+	329	152430	1	1
+	330	152440	1	1
+	331	160000	1	972 -- Rough Dragon Onyx
+	332	160010	1	3240
+	333	160020	1	1080
+	334	160100	1	3240 -- Rough Dragon Onyx
+	335	160110	1	10800
+	336	160120	1	3600
+	337	160200	1	1080 -- Rough Dragon Onyx
+	338	160210	1	3600
+	339	160220	1	1200
+	340	160230	1	60
+	341	160300	1	54 -- Rough Dragon Onyx
+	342	160310	1	180
+	343	160320	1	60
+	344	160330	1	3
+	345	160400	1	54 -- Rough Dragon Onyx
+	346	160410	1	180
+	347	160420	1	60
+	348	160430	1	3
+	349	160440	1	3
+	350	161000	1	1944 -- Cut Dragon Onyx
+	351	161010	1	6480
+	352	161020	1	2160
+	353	161030	1	108
+	354	161100	1	6480 -- Cut Dragon Onyx
+	355	161110	1	21600
+	356	161120	1	7200
+	357	161130	1	360
+	358	161200	1	2160 -- Cut Dragon Onyx
+	359	161210	1	7200
+	360	161220	1	2400
+	361	161230	1	120
+	362	161300	1	108 -- Cut Dragon Onyx
+	363	161310	1	360
+	364	161320	1	120
+	365	161330	1	6
+	366	161340	1	6
+	367	161400	1	108 -- Cut Dragon Onyx
+	368	161410	1	360
+	369	161420	1	120
+	370	161430	1	6
+	371	161440	1	6
+	372	162000	1	324 -- Rare Dragon Onyx
+	373	162010	1	1080
+	374	162020	1	360
+	375	162030	1	18
+	376	162040	1	18
+	377	162100	1	1080 -- Rare Dragon Onyx
+	378	162110	1	3600
+	379	162120	1	1200
+	380	162130	1	60
+	381	162140	1	60
+	382	162200	1	360 -- Rare Dragon Onyx
+	383	162210	1	1200
+	384	162220	1	400
+	385	162230	1	20
+	386	162240	1	20
+	387	162300	1	18 -- Rare Dragon Onyx
+	388	162310	1	60
+	389	162320	1	20
+	390	162330	1	1
+	391	162340	1	1
+	392	162400	1	18 -- Rare Dragon Onyx
+	393	162410	1	60
+	394	162420	1	20
+	395	162430	1	1
+	396	162440	1	1
+}
+Group	麗肌혼_球-
+{
+	Vnum	51584 -- Cor Diamas+ (Noble)
+	1	110000	1	972 -- Rough Dragon Diamond
+	2	110010	1	3240
+	3	110020	1	1080
+	4	110100	1	3240 -- Rough Dragon Diamond
+	5	110110	1	10800
+	6	110120	1	3600
+	7	110200	1	1080 -- Rough Dragon Diamond
+	8	110210	1	3600
+	9	110220	1	1200
+	10	110230	1	60
+	11	110300	1	54 -- Rough Dragon Diamond
+	12	110310	1	180
+	13	110320	1	60
+	14	110330	1	3
+	15	110400	1	54 -- Rough Dragon Diamond
+	16	110410	1	180
+	17	110420	1	60
+	18	110430	1	3
+	19	110440	1	3
+	20	111000	1	1944 -- Cut Dragon Diamond
+	21	111010	1	6480
+	22	111020	1	2160
+	23	111030	1	108
+	24	111100	1	6480 -- Cut Dragon Diamond
+	25	111110	1	21600
+	26	111120	1	7200
+	27	111130	1	360
+	28	111200	1	2160 -- Cut Dragon Diamond
+	29	111210	1	7200
+	30	111220	1	2400
+	31	111230	1	120
+	32	111300	1	108 -- Cut Dragon Diamond
+	33	111310	1	360
+	34	111320	1	120
+	35	111330	1	6
+	36	111340	1	6
+	37	111400	1	108 -- Cut Dragon Diamond
+	38	111410	1	360
+	39	111420	1	120
+	40	111430	1	6
+	41	111440	1	6
+	42	112000	1	324 -- Rare Dragon Diamond
+	43	112010	1	1080
+	44	112020	1	360
+	45	112030	1	18
+	46	112040	1	18
+	47	112100	1	1080 -- Rare Dragon Diamond
+	48	112110	1	3600
+	49	112120	1	1200
+	50	112130	1	60
+	51	112140	1	60
+	52	112200	1	360 -- Rare Dragon Diamond
+	53	112210	1	1200
+	54	112220	1	400
+	55	112230	1	20
+	56	112240	1	20
+	57	112300	1	18 -- Rare Dragon Diamond
+	58	112310	1	60
+	59	112320	1	20
+	60	112330	1	1
+	61	112340	1	1
+	62	112400	1	18 -- Rare Dragon Diamond
+	63	112410	1	60
+	64	112420	1	20
+	65	112430	1	1
+	66	112440	1	1
+}
+Group	화麗肌혼_球-
+{
+	Vnum	51585 -- Cor Rubinum+ (Noble)
+	1	120000	1	972 -- Rough Dragon Ruby
+	2	120010	1	3240
+	3	120020	1	1080
+	4	120100	1	3240 -- Rough Dragon Ruby
+	5	120110	1	10800
+	6	120120	1	3600
+	7	120200	1	1080 -- Rough Dragon Ruby
+	8	120210	1	3600
+	9	120220	1	1200
+	10	120230	1	60
+	11	120300	1	54 -- Rough Dragon Ruby
+	12	120310	1	180
+	13	120320	1	60
+	14	120330	1	3
+	15	120400	1	54 -- Rough Dragon Ruby
+	16	120410	1	180
+	17	120420	1	60
+	18	120430	1	3
+	19	120440	1	3
+	20	121000	1	1944 -- Cut Dragon Ruby
+	21	121010	1	6480
+	22	121020	1	2160
+	23	121030	1	108
+	24	121100	1	6480 -- Cut Dragon Ruby
+	25	121110	1	21600
+	26	121120	1	7200
+	27	121130	1	360
+	28	121200	1	2160 -- Cut Dragon Ruby
+	29	121210	1	7200
+	30	121220	1	2400
+	31	121230	1	120
+	32	121300	1	108 -- Cut Dragon Ruby
+	33	121310	1	360
+	34	121320	1	120
+	35	121330	1	6
+	36	121340	1	6
+	37	121400	1	108 -- Cut Dragon Ruby
+	38	121410	1	360
+	39	121420	1	120
+	40	121430	1	6
+	41	121440	1	6
+	42	122000	1	324 -- Rare Dragon Ruby
+	43	122010	1	1080
+	44	122020	1	360
+	45	122030	1	18
+	46	122040	1	18
+	47	122100	1	1080 -- Rare Dragon Ruby
+	48	122110	1	3600
+	49	122120	1	1200
+	50	122130	1	60
+	51	122140	1	60
+	52	122200	1	360 -- Rare Dragon Ruby
+	53	122210	1	1200
+	54	122220	1	400
+	55	122230	1	20
+	56	122240	1	20
+	57	122300	1	18 -- Rare Dragon Ruby
+	58	122310	1	60
+	59	122320	1	20
+	60	122330	1	1
+	61	122340	1	1
+	62	122400	1	18 -- Rare Dragon Ruby
+	63	122410	1	60
+	64	122420	1	20
+	65	122430	1	1
+	66	122440	1	1
+}
+Group	풍麗肌혼_球-
+{
+	Vnum	51586 -- Cor Jadeit+ (Noble)
+	1	130000	1	972 -- Rough Dragon Jade
+	2	130010	1	3240
+	3	130020	1	1080
+	4	130100	1	3240 -- Rough Dragon Jade
+	5	130110	1	10800
+	6	130120	1	3600
+	7	130200	1	1080 -- Rough Dragon Jade
+	8	130210	1	3600
+	9	130220	1	1200
+	10	130230	1	60
+	11	130300	1	54 -- Rough Dragon Jade
+	12	130310	1	180
+	13	130320	1	60
+	14	130330	1	3
+	15	130400	1	54 -- Rough Dragon Jade
+	16	130410	1	180
+	17	130420	1	60
+	18	130430	1	3
+	19	130440	1	3
+	20	131000	1	1944 -- Cut Dragon Jade
+	21	131010	1	6480
+	22	131020	1	2160
+	23	131030	1	108
+	24	131100	1	6480 -- Cut Dragon Jade
+	25	131110	1	21600
+	26	131120	1	7200
+	27	131130	1	360
+	28	131200	1	2160 -- Cut Dragon Jade
+	29	131210	1	7200
+	30	131220	1	2400
+	31	131230	1	120
+	32	131300	1	108 -- Cut Dragon Jade
+	33	131310	1	360
+	34	131320	1	120
+	35	131330	1	6
+	36	131340	1	6
+	37	131400	1	108 -- Cut Dragon Jade
+	38	131410	1	360
+	39	131420	1	120
+	40	131430	1	6
+	41	131440	1	6
+	42	132000	1	324 -- Rare Dragon Jade
+	43	132010	1	1080
+	44	132020	1	360
+	45	132030	1	18
+	46	132040	1	18
+	47	132100	1	1080 -- Rare Dragon Jade
+	48	132110	1	3600
+	49	132120	1	1200
+	50	132130	1	60
+	51	132140	1	60
+	52	132200	1	360 -- Rare Dragon Jade
+	53	132210	1	1200
+	54	132220	1	400
+	55	132230	1	20
+	56	132240	1	20
+	57	132300	1	18 -- Rare Dragon Jade
+	58	132310	1	60
+	59	132320	1	20
+	60	132330	1	1
+	61	132340	1	1
+	62	132400	1	18 -- Rare Dragon Jade
+	63	132410	1	60
+	64	132420	1	20
+	65	132430	1	1
+	66	132440	1	1
+}
+Group	철麗肌혼_球-
+{
+	Vnum	51587 -- Cor Saphirum+ (Noble)
+	1	140000	1	972 -- Rough Dragon Sapphire
+	2	140010	1	3240
+	3	140020	1	1080
+	4	140100	1	3240 -- Rough Dragon Sapphire
+	5	140110	1	10800
+	6	140120	1	3600
+	7	140200	1	1080 -- Rough Dragon Sapphire
+	8	140210	1	3600
+	9	140220	1	1200
+	10	140230	1	60
+	11	140300	1	54 -- Rough Dragon Sapphire
+	12	140310	1	180
+	13	140320	1	60
+	14	140330	1	3
+	15	140400	1	54 -- Rough Dragon Sapphire
+	16	140410	1	180
+	17	140420	1	60
+	18	140430	1	3
+	19	140440	1	3
+	20	141000	1	1944 -- Cut Dragon Sapphire
+	21	141010	1	6480
+	22	141020	1	2160
+	23	141030	1	108
+	24	141100	1	6480 -- Cut Dragon Sapphire
+	25	141110	1	21600
+	26	141120	1	7200
+	27	141130	1	360
+	28	141200	1	2160 -- Cut Dragon Sapphire
+	29	141210	1	7200
+	30	141220	1	2400
+	31	141230	1	120
+	32	141300	1	108 -- Cut Dragon Sapphire
+	33	141310	1	360
+	34	141320	1	120
+	35	141330	1	6
+	36	141340	1	6
+	37	141400	1	108 -- Cut Dragon Sapphire
+	38	141410	1	360
+	39	141420	1	120
+	40	141430	1	6
+	41	141440	1	6
+	42	142000	1	324 -- Rare Dragon Sapphire
+	43	142010	1	1080
+	44	142020	1	360
+	45	142030	1	18
+	46	142040	1	18
+	47	142100	1	1080 -- Rare Dragon Sapphire
+	48	142110	1	3600
+	49	142120	1	1200
+	50	142130	1	60
+	51	142140	1	60
+	52	142200	1	360 -- Rare Dragon Sapphire
+	53	142210	1	1200
+	54	142220	1	400
+	55	142230	1	20
+	56	142240	1	20
+	57	142300	1	18 -- Rare Dragon Sapphire
+	58	142310	1	60
+	59	142320	1	20
+	60	142330	1	1
+	61	142340	1	1
+	62	142400	1	18 -- Rare Dragon Sapphire
+	63	142410	1	60
+	64	142420	1	20
+	65	142430	1	1
+	66	142440	1	1
+}
+Group	麗肌혼_球-
+{
+	Vnum	51588 -- Cor Granatum+ (Noble)
+	1	150000	1	972 -- Rough Dragon Garnet
+	2	150010	1	3240
+	3	150020	1	1080
+	4	150100	1	3240 -- Rough Dragon Garnet
+	5	150110	1	10800
+	6	150120	1	3600
+	7	150200	1	1080 -- Rough Dragon Garnet
+	8	150210	1	3600
+	9	150220	1	1200
+	10	150230	1	60
+	11	150300	1	54 -- Rough Dragon Garnet
+	12	150310	1	180
+	13	150320	1	60
+	14	150330	1	3
+	15	150400	1	54 -- Rough Dragon Garnet
+	16	150410	1	180
+	17	150420	1	60
+	18	150430	1	3
+	19	150440	1	3
+	20	151000	1	1944 -- Cut Dragon Garnet
+	21	151010	1	6480
+	22	151020	1	2160
+	23	151030	1	108
+	24	151100	1	6480 -- Cut Dragon Garnet
+	25	151110	1	21600
+	26	151120	1	7200
+	27	151130	1	360
+	28	151200	1	2160 -- Cut Dragon Garnet
+	29	151210	1	7200
+	30	151220	1	2400
+	31	151230	1	120
+	32	151300	1	108 -- Cut Dragon Garnet
+	33	151310	1	360
+	34	151320	1	120
+	35	151330	1	6
+	36	151340	1	6
+	37	151400	1	108 -- Cut Dragon Garnet
+	38	151410	1	360
+	39	151420	1	120
+	40	151430	1	6
+	41	151440	1	6
+	42	152000	1	324 -- Rare Dragon Garnet
+	43	152010	1	1080
+	44	152020	1	360
+	45	152030	1	18
+	46	152040	1	18
+	47	152100	1	1080 -- Rare Dragon Garnet
+	48	152110	1	3600
+	49	152120	1	1200
+	50	152130	1	60
+	51	152140	1	60
+	52	152200	1	360 -- Rare Dragon Garnet
+	53	152210	1	1200
+	54	152220	1	400
+	55	152230	1	20
+	56	152240	1	20
+	57	152300	1	18 -- Rare Dragon Garnet
+	58	152310	1	60
+	59	152320	1	20
+	60	152330	1	1
+	61	152340	1	1
+	62	152400	1	18 -- Rare Dragon Garnet
+	63	152410	1	60
+	64	152420	1	20
+	65	152430	1	1
+	66	152440	1	1
+}
+Group	麗肌혼_球-
+{
+	Vnum	51589 -- Cor Atrum+ (Noble)
+	1	160000	1	972 -- Rough Dragon Onyx
+	2	160010	1	3240
+	3	160020	1	1080
+	4	160100	1	3240 -- Rough Dragon Onyx
+	5	160110	1	10800
+	6	160120	1	3600
+	7	160200	1	1080 -- Rough Dragon Onyx
+	8	160210	1	3600
+	9	160220	1	1200
+	10	160230	1	60
+	11	160300	1	54 -- Rough Dragon Onyx
+	12	160310	1	180
+	13	160320	1	60
+	14	160330	1	3
+	15	160400	1	54 -- Rough Dragon Onyx
+	16	160410	1	180
+	17	160420	1	60
+	18	160430	1	3
+	19	160440	1	3
+	20	161000	1	1944 -- Cut Dragon Onyx
+	21	161010	1	6480
+	22	161020	1	2160
+	23	161030	1	108
+	24	161100	1	6480 -- Cut Dragon Onyx
+	25	161110	1	21600
+	26	161120	1	7200
+	27	161130	1	360
+	28	161200	1	2160 -- Cut Dragon Onyx
+	29	161210	1	7200
+	30	161220	1	2400
+	31	161230	1	120
+	32	161300	1	108 -- Cut Dragon Onyx
+	33	161310	1	360
+	34	161320	1	120
+	35	161330	1	6
+	36	161340	1	6
+	37	161400	1	108 -- Cut Dragon Onyx
+	38	161410	1	360
+	39	161420	1	120
+	40	161430	1	6
+	41	161440	1	6
+	42	162000	1	324 -- Rare Dragon Onyx
+	43	162010	1	1080
+	44	162020	1	360
+	45	162030	1	18
+	46	162040	1	18
+	47	162100	1	1080 -- Rare Dragon Onyx
+	48	162110	1	3600
+	49	162120	1	1200
+	50	162130	1	60
+	51	162140	1	60
+	52	162200	1	360 -- Rare Dragon Onyx
+	53	162210	1	1200
+	54	162220	1	400
+	55	162230	1	20
+	56	162240	1	20
+	57	162300	1	18 -- Rare Dragon Onyx
+	58	162310	1	60
+	59	162320	1	20
+	60	162330	1	1
+	61	162340	1	1
+	62	162400	1	18 -- Rare Dragon Onyx
+	63	162410	1	60
+	64	162420	1	20
+	65	162430	1	1
+	66	162440	1	1
+}
+Group	肌혼_球-
+{
+	Vnum	51590 -- Cor Draconis+ (Precious)
+	1	110000	1	324 -- Rough Dragon Diamond
+	2	110010	1	1080
+	3	110020	1	360
+	4	110100	1	1080 -- Rough Dragon Diamond
+	5	110110	1	3600
+	6	110120	1	1200
+	7	110200	1	360 -- Rough Dragon Diamond
+	8	110210	1	1200
+	9	110220	1	400
+	10	110230	1	20
+	11	110300	1	18 -- Rough Dragon Diamond
+	12	110310	1	60
+	13	110320	1	20
+	14	110330	1	1
+	15	110400	1	18 -- Rough Dragon Diamond
+	16	110410	1	60
+	17	110420	1	20
+	18	110430	1	1
+	19	110440	1	1
+	20	111000	1	810 -- Cut Dragon Diamond
+	21	111010	1	2700
+	22	111020	1	900
+	23	111030	1	45
+	24	111100	1	2700 -- Cut Dragon Diamond
+	25	111110	1	9000
+	26	111120	1	3000
+	27	111130	1	150
+	28	111200	1	900 -- Cut Dragon Diamond
+	29	111210	1	3000
+	30	111220	1	1000
+	31	111230	1	50
+	32	111300	1	45 -- Cut Dragon Diamond
+	33	111310	1	150
+	34	111320	1	50
+	35	111330	1	3
+	36	111340	1	3
+	37	111400	1	45 -- Cut Dragon Diamond
+	38	111410	1	150
+	39	111420	1	50
+	40	111430	1	3
+	41	111440	1	3
+	42	112000	1	1782 -- Rare Dragon Diamond
+	43	112010	1	5940
+	44	112020	1	1980
+	45	112030	1	99
+	46	112040	1	99
+	47	112100	1	5940 -- Rare Dragon Diamond
+	48	112110	1	19800
+	49	112120	1	6600
+	50	112130	1	330
+	51	112140	1	330
+	52	112200	1	1980 -- Rare Dragon Diamond
+	53	112210	1	6600
+	54	112220	1	2200
+	55	112230	1	110
+	56	112240	1	110
+	57	112300	1	99 -- Rare Dragon Diamond
+	58	112310	1	330
+	59	112320	1	110
+	60	112330	1	6
+	61	112340	1	6
+	62	112400	1	99 -- Rare Dragon Diamond
+	63	112410	1	330
+	64	112420	1	110
+	65	112430	1	6
+	66	112440	1	6
+	67	113000	1	324 -- Antique Dragon Diamond
+	68	113010	1	1080
+	69	113020	1	360
+	70	113030	1	18
+	71	113040	1	18
+	72	113100	1	1080 -- Antique Dragon Diamond
+	73	113110	1	3600
+	74	113120	1	1200
+	75	113130	1	60
+	76	113140	1	60
+	77	113200	1	360 -- Antique Dragon Diamond
+	78	113210	1	1200
+	79	113220	1	400
+	80	113230	1	20
+	81	113240	1	20
+	82	113300	1	18 -- Antique Dragon Diamond
+	83	113310	1	60
+	84	113320	1	20
+	85	113330	1	1
+	86	113340	1	1
+	87	113400	1	18 -- Antique Dragon Diamond
+	88	113410	1	60
+	89	113420	1	20
+	90	113430	1	1
+	91	113440	1	1
+	92	120000	1	324 -- Rough Dragon Ruby
+	93	120010	1	1080
+	94	120020	1	360
+	95	120100	1	1080 -- Rough Dragon Ruby
+	96	120110	1	3600
+	97	120120	1	1200
+	98	120200	1	360 -- Rough Dragon Ruby
+	99	120210	1	1200
+	100	120220	1	400
+	101	120230	1	20
+	102	120300	1	18 -- Rough Dragon Ruby
+	103	120310	1	60
+	104	120320	1	20
+	105	120330	1	1
+	106	120400	1	18 -- Rough Dragon Ruby
+	107	120410	1	60
+	108	120420	1	20
+	109	120430	1	1
+	110	120440	1	1
+	111	121000	1	810 -- Cut Dragon Ruby
+	112	121010	1	2700
+	113	121020	1	900
+	114	121030	1	45
+	115	121100	1	2700 -- Cut Dragon Ruby
+	116	121110	1	9000
+	117	121120	1	3000
+	118	121130	1	150
+	119	121200	1	900 -- Cut Dragon Ruby
+	120	121210	1	3000
+	121	121220	1	1000
+	122	121230	1	50
+	123	121300	1	45 -- Cut Dragon Ruby
+	124	121310	1	150
+	125	121320	1	50
+	126	121330	1	2
+	127	121340	1	2
+	128	121400	1	45 -- Cut Dragon Ruby
+	129	121410	1	150
+	130	121420	1	50
+	131	121430	1	2
+	132	121440	1	2
+	133	122000	1	1782 -- Rare Dragon Ruby
+	134	122010	1	5940
+	135	122020	1	1980
+	136	122030	1	99
+	137	122040	1	99
+	138	122100	1	5940 -- Rare Dragon Ruby
+	139	122110	1	19800
+	140	122120	1	6600
+	141	122130	1	330
+	142	122140	1	330
+	143	122200	1	1980 -- Rare Dragon Ruby
+	144	122210	1	6600
+	145	122220	1	2200
+	146	122230	1	110
+	147	122240	1	110
+	148	122300	1	99 -- Rare Dragon Ruby
+	149	122310	1	330
+	150	122320	1	110
+	151	122330	1	5
+	152	122340	1	5
+	153	122400	1	99 -- Rare Dragon Ruby
+	154	122410	1	330
+	155	122420	1	110
+	156	122430	1	5
+	157	122440	1	5
+	158	123000	1	324 -- Antique Dragon Ruby
+	159	123010	1	1080
+	160	123020	1	360
+	161	123030	1	18
+	162	123040	1	18
+	163	123100	1	1080 -- Antique Dragon Ruby
+	164	123110	1	3600
+	165	123120	1	1200
+	166	123130	1	60
+	167	123140	1	60
+	168	123200	1	360 -- Antique Dragon Ruby
+	169	123210	1	1200
+	170	123220	1	400
+	171	123230	1	20
+	172	123240	1	20
+	173	123300	1	18 -- Antique Dragon Ruby
+	174	123310	1	60
+	175	123320	1	20
+	176	123330	1	1
+	177	123340	1	1
+	178	123400	1	18 -- Antique Dragon Ruby
+	179	123410	1	60
+	180	123420	1	20
+	181	123430	1	1
+	182	123440	1	1
+	183	130000	1	324 -- Rough Dragon Jade
+	184	130010	1	1080
+	185	130020	1	360
+	186	130100	1	1080 -- Rough Dragon Jade
+	187	130110	1	3600
+	188	130120	1	1200
+	189	130200	1	360 -- Rough Dragon Jade
+	190	130210	1	1200
+	191	130220	1	400
+	192	130230	1	20
+	193	130300	1	18 -- Rough Dragon Jade
+	194	130310	1	60
+	195	130320	1	20
+	196	130330	1	1
+	197	130400	1	18 -- Rough Dragon Jade
+	198	130410	1	60
+	199	130420	1	20
+	200	130430	1	1
+	201	130440	1	1
+	202	131000	1	810 -- Cut Dragon Jade
+	203	131010	1	2700
+	204	131020	1	900
+	205	131030	1	45
+	206	131100	1	2700 -- Cut Dragon Jade
+	207	131110	1	9000
+	208	131120	1	3000
+	209	131130	1	150
+	210	131200	1	900 -- Cut Dragon Jade
+	211	131210	1	3000
+	212	131220	1	1000
+	213	131230	1	50
+	214	131300	1	45 -- Cut Dragon Jade
+	215	131310	1	150
+	216	131320	1	50
+	217	131330	1	2
+	218	131340	1	2
+	219	131400	1	45 -- Cut Dragon Jade
+	220	131410	1	150
+	221	131420	1	50
+	222	131430	1	2
+	223	131440	1	2
+	224	132000	1	1782 -- Rare Dragon Jade
+	225	132010	1	5940
+	226	132020	1	1980
+	227	132030	1	99
+	228	132040	1	99
+	229	132100	1	5940 -- Rare Dragon Jade
+	230	132110	1	19800
+	231	132120	1	6600
+	232	132130	1	330
+	233	132140	1	330
+	234	132200	1	1980 -- Rare Dragon Jade
+	235	132210	1	6600
+	236	132220	1	2200
+	237	132230	1	110
+	238	132240	1	110
+	239	132300	1	99 -- Rare Dragon Jade
+	240	132310	1	330
+	241	132320	1	110
+	242	132330	1	5
+	243	132340	1	5
+	244	132400	1	99 -- Rare Dragon Jade
+	245	132410	1	330
+	246	132420	1	110
+	247	132430	1	5
+	248	132440	1	5
+	249	133000	1	324 -- Antique Dragon Jade
+	250	133010	1	1080
+	251	133020	1	360
+	252	133030	1	18
+	253	133040	1	18
+	254	133100	1	1080 -- Antique Dragon Jade
+	255	133110	1	3600
+	256	133120	1	1200
+	257	133130	1	60
+	258	133140	1	60
+	259	133200	1	360 -- Antique Dragon Jade
+	260	133210	1	1200
+	261	133220	1	400
+	262	133230	1	20
+	263	133240	1	20
+	264	133300	1	18 -- Antique Dragon Jade
+	265	133310	1	60
+	266	133320	1	20
+	267	133330	1	1
+	268	133340	1	1
+	269	133400	1	18 -- Antique Dragon Jade
+	270	133410	1	60
+	271	133420	1	20
+	272	133430	1	1
+	273	133440	1	1
+	274	140000	1	324 -- Rough Dragon Sapphire
+	275	140010	1	1080
+	276	140020	1	360
+	277	140100	1	1080 -- Rough Dragon Sapphire
+	278	140110	1	3600
+	279	140120	1	1200
+	280	140200	1	360 -- Rough Dragon Sapphire
+	281	140210	1	1200
+	282	140220	1	400
+	283	140230	1	20
+	284	140300	1	18 -- Rough Dragon Sapphire
+	285	140310	1	60
+	286	140320	1	20
+	287	140330	1	1
+	288	140400	1	18 -- Rough Dragon Sapphire
+	289	140410	1	60
+	290	140420	1	20
+	291	140430	1	1
+	292	140440	1	1
+	293	141000	1	810 -- Cut Dragon Sapphire
+	294	141010	1	2700
+	295	141020	1	900
+	296	141030	1	45
+	297	141100	1	2700 -- Cut Dragon Sapphire
+	298	141110	1	9000
+	299	141120	1	3000
+	300	141130	1	150
+	301	141200	1	900 -- Cut Dragon Sapphire
+	302	141210	1	3000
+	303	141220	1	1000
+	304	141230	1	50
+	305	141300	1	45 -- Cut Dragon Sapphire
+	306	141310	1	150
+	307	141320	1	50
+	308	141330	1	2
+	309	141340	1	2
+	310	141400	1	45 -- Cut Dragon Sapphire
+	311	141410	1	150
+	312	141420	1	50
+	313	141430	1	2
+	314	141440	1	2
+	315	142000	1	1782 -- Rare Dragon Sapphire
+	316	142010	1	5940
+	317	142020	1	1980
+	318	142030	1	99
+	319	142040	1	99
+	320	142100	1	5940 -- Rare Dragon Sapphire
+	321	142110	1	19800
+	322	142120	1	6600
+	323	142130	1	330
+	324	142140	1	330
+	325	142200	1	1980 -- Rare Dragon Sapphire
+	326	142210	1	6600
+	327	142220	1	2200
+	328	142230	1	110
+	329	142240	1	110
+	330	142300	1	99 -- Rare Dragon Sapphire
+	331	142310	1	330
+	332	142320	1	110
+	333	142330	1	5
+	334	142340	1	5
+	335	142400	1	99 -- Rare Dragon Sapphire
+	336	142410	1	330
+	337	142420	1	110
+	338	142430	1	5
+	339	142440	1	5
+	340	143000	1	324 -- Antique Dragon Sapphire
+	341	143010	1	1080
+	342	143020	1	360
+	343	143030	1	18
+	344	143040	1	18
+	345	143100	1	1080 -- Antique Dragon Sapphire
+	346	143110	1	3600
+	347	143120	1	1200
+	348	143130	1	60
+	349	143140	1	60
+	350	143200	1	360 -- Antique Dragon Sapphire
+	351	143210	1	1200
+	352	143220	1	400
+	353	143230	1	20
+	354	143240	1	20
+	355	143300	1	18 -- Antique Dragon Sapphire
+	356	143310	1	60
+	357	143320	1	20
+	358	143330	1	1
+	359	143340	1	1
+	360	143400	1	18 -- Antique Dragon Sapphire
+	361	143410	1	60
+	362	143420	1	20
+	363	143430	1	1
+	364	143440	1	1
+	365	150000	1	324 -- Rough Dragon Garnet
+	366	150010	1	1080
+	367	150020	1	360
+	368	150100	1	1080 -- Rough Dragon Garnet
+	369	150110	1	3600
+	370	150120	1	1200
+	371	150200	1	360 -- Rough Dragon Garnet
+	372	150210	1	1200
+	373	150220	1	400
+	374	150230	1	20
+	375	150300	1	18 -- Rough Dragon Garnet
+	376	150310	1	60
+	377	150320	1	20
+	378	150330	1	1
+	379	150400	1	18 -- Rough Dragon Garnet
+	380	150410	1	60
+	381	150420	1	20
+	382	150430	1	1
+	383	150440	1	1
+	384	151000	1	810 -- Cut Dragon Garnet
+	385	151010	1	2700
+	386	151020	1	900
+	387	151030	1	45
+	388	151100	1	2700 -- Cut Dragon Garnet
+	389	151110	1	9000
+	390	151120	1	3000
+	391	151130	1	150
+	392	151200	1	900 -- Cut Dragon Garnet
+	393	151210	1	3000
+	394	151220	1	1000
+	395	151230	1	50
+	396	151300	1	45 -- Cut Dragon Garnet
+	397	151310	1	150
+	398	151320	1	50
+	399	151330	1	2
+	400	151340	1	2
+	401	151400	1	45 -- Cut Dragon Garnet
+	402	151410	1	150
+	403	151420	1	50
+	404	151430	1	2
+	405	151440	1	2
+	406	152000	1	1782 -- Rare Dragon Garnet
+	407	152010	1	5940
+	408	152020	1	1980
+	409	152030	1	99
+	410	152040	1	99
+	411	152100	1	5940 -- Rare Dragon Garnet
+	412	152110	1	19800
+	413	152120	1	6600
+	414	152130	1	330
+	415	152140	1	330
+	416	152200	1	1980 -- Rare Dragon Garnet
+	417	152210	1	6600
+	418	152220	1	2200
+	419	152230	1	110
+	420	152240	1	110
+	421	152300	1	99 -- Rare Dragon Garnet
+	422	152310	1	330
+	423	152320	1	110
+	424	152330	1	5
+	425	152340	1	5
+	426	152400	1	99 -- Rare Dragon Garnet
+	427	152410	1	330
+	428	152420	1	110
+	429	152430	1	5
+	430	152440	1	5
+	431	153000	1	324 -- Antique Dragon Garnet
+	432	153010	1	1080
+	433	153020	1	360
+	434	153030	1	18
+	435	153040	1	18
+	436	153100	1	1080 -- Antique Dragon Garnet
+	437	153110	1	3600
+	438	153120	1	1200
+	439	153130	1	60
+	440	153140	1	60
+	441	153200	1	360 -- Antique Dragon Garnet
+	442	153210	1	1200
+	443	153220	1	400
+	444	153230	1	20
+	445	153240	1	20
+	446	153300	1	18 -- Antique Dragon Garnet
+	447	153310	1	60
+	448	153320	1	20
+	449	153330	1	1
+	450	153340	1	1
+	451	153400	1	18 -- Antique Dragon Garnet
+	452	153410	1	60
+	453	153420	1	20
+	454	153430	1	1
+	455	153440	1	1
+	456	160000	1	324 -- Rough Dragon Onyx
+	457	160010	1	1080
+	458	160020	1	360
+	459	160100	1	1080 -- Rough Dragon Onyx
+	460	160110	1	3600
+	461	160120	1	1200
+	462	160200	1	360 -- Rough Dragon Onyx
+	463	160210	1	1200
+	464	160220	1	400
+	465	160230	1	20
+	466	160300	1	18 -- Rough Dragon Onyx
+	467	160310	1	60
+	468	160320	1	20
+	469	160330	1	1
+	470	160400	1	18 -- Rough Dragon Onyx
+	471	160410	1	60
+	472	160420	1	20
+	473	160430	1	1
+	474	160440	1	1
+	475	161000	1	810 -- Cut Dragon Onyx
+	476	161010	1	2700
+	477	161020	1	900
+	478	161030	1	45
+	479	161100	1	2700 -- Cut Dragon Onyx
+	480	161110	1	9000
+	481	161120	1	3000
+	482	161130	1	150
+	483	161200	1	900 -- Cut Dragon Onyx
+	484	161210	1	3000
+	485	161220	1	1000
+	486	161230	1	50
+	487	161300	1	45 -- Cut Dragon Onyx
+	488	161310	1	150
+	489	161320	1	50
+	490	161330	1	2
+	491	161340	1	2
+	492	161400	1	45 -- Cut Dragon Onyx
+	493	161410	1	150
+	494	161420	1	50
+	495	161430	1	2
+	496	161440	1	2
+	497	162000	1	1782 -- Rare Dragon Onyx
+	498	162010	1	5940
+	499	162020	1	1980
+	500	162030	1	99
+	501	162040	1	99
+	502	162100	1	5940 -- Rare Dragon Onyx
+	503	162110	1	19800
+	504	162120	1	6600
+	505	162130	1	330
+	506	162140	1	330
+	507	162200	1	1980 -- Rare Dragon Onyx
+	508	162210	1	6600
+	509	162220	1	2200
+	510	162230	1	110
+	511	162240	1	110
+	512	162300	1	99 -- Rare Dragon Onyx
+	513	162310	1	330
+	514	162320	1	110
+	515	162330	1	5
+	516	162340	1	5
+	517	162400	1	99 -- Rare Dragon Onyx
+	518	162410	1	330
+	519	162420	1	110
+	520	162430	1	5
+	521	162440	1	5
+	522	163000	1	324 -- Antique Dragon Onyx
+	523	163010	1	1080
+	524	163020	1	360
+	525	163030	1	18
+	526	163040	1	18
+	527	163100	1	1080 -- Antique Dragon Onyx
+	528	163110	1	3600
+	529	163120	1	1200
+	530	163130	1	60
+	531	163140	1	60
+	532	163200	1	360 -- Antique Dragon Onyx
+	533	163210	1	1200
+	534	163220	1	400
+	535	163230	1	20
+	536	163240	1	20
+	537	163300	1	18 -- Antique Dragon Onyx
+	538	163310	1	60
+	539	163320	1	20
+	540	163330	1	1
+	541	163340	1	1
+	542	163400	1	18 -- Antique Dragon Onyx
+	543	163410	1	60
+	544	163420	1	20
+	545	163430	1	1
+	546	163440	1	1
+}
+Group	麗肌혼_球-
+{
+	Vnum	51591 -- Cor Diamas+ (Precious)
+	1	110000	1	324 -- Rough Dragon Diamond
+	2	110010	1	1080
+	3	110020	1	360
+	4	110100	1	1080 -- Rough Dragon Diamond
+	5	110110	1	3600
+	6	110120	1	1200
+	7	110200	1	360 -- Rough Dragon Diamond
+	8	110210	1	1200
+	9	110220	1	400
+	10	110230	1	20
+	11	110300	1	18 -- Rough Dragon Diamond
+	12	110310	1	60
+	13	110320	1	20
+	14	110330	1	1
+	15	110400	1	18 -- Rough Dragon Diamond
+	16	110410	1	60
+	17	110420	1	20
+	18	110430	1	1
+	19	110440	1	1
+	20	111000	1	810 -- Cut Dragon Diamond
+	21	111010	1	2700
+	22	111020	1	900
+	23	111030	1	45
+	24	111100	1	2700 -- Cut Dragon Diamond
+	25	111110	1	9000
+	26	111120	1	3000
+	27	111130	1	150
+	28	111200	1	900 -- Cut Dragon Diamond
+	29	111210	1	3000
+	30	111220	1	1000
+	31	111230	1	50
+	32	111300	1	45 -- Cut Dragon Diamond
+	33	111310	1	150
+	34	111320	1	50
+	35	111330	1	3
+	36	111340	1	3
+	37	111400	1	45 -- Cut Dragon Diamond
+	38	111410	1	150
+	39	111420	1	50
+	40	111430	1	3
+	41	111440	1	3
+	42	112000	1	1782 -- Rare Dragon Diamond
+	43	112010	1	5940
+	44	112020	1	1980
+	45	112030	1	99
+	46	112040	1	99
+	47	112100	1	5940 -- Rare Dragon Diamond
+	48	112110	1	19800
+	49	112120	1	6600
+	50	112130	1	330
+	51	112140	1	330
+	52	112200	1	1980 -- Rare Dragon Diamond
+	53	112210	1	6600
+	54	112220	1	2200
+	55	112230	1	110
+	56	112240	1	110
+	57	112300	1	99 -- Rare Dragon Diamond
+	58	112310	1	330
+	59	112320	1	110
+	60	112330	1	6
+	61	112340	1	6
+	62	112400	1	99 -- Rare Dragon Diamond
+	63	112410	1	330
+	64	112420	1	110
+	65	112430	1	6
+	66	112440	1	6
+	67	113000	1	324 -- Antique Dragon Diamond
+	68	113010	1	1080
+	69	113020	1	360
+	70	113030	1	18
+	71	113040	1	18
+	72	113100	1	1080 -- Antique Dragon Diamond
+	73	113110	1	3600
+	74	113120	1	1200
+	75	113130	1	60
+	76	113140	1	60
+	77	113200	1	360 -- Antique Dragon Diamond
+	78	113210	1	1200
+	79	113220	1	400
+	80	113230	1	20
+	81	113240	1	20
+	82	113300	1	18 -- Antique Dragon Diamond
+	83	113310	1	60
+	84	113320	1	20
+	85	113330	1	1
+	86	113340	1	1
+	87	113400	1	18 -- Antique Dragon Diamond
+	88	113410	1	60
+	89	113420	1	20
+	90	113430	1	1
+	91	113440	1	1
+}
+Group	화麗肌혼_球-
+{
+	Vnum	51592 -- Cor Rubinum+ (Precious)
+	1	120000	1	324 -- Rough Dragon Ruby
+	2	120010	1	1080
+	3	120020	1	360
+	4	120100	1	1080 -- Rough Dragon Ruby
+	5	120110	1	3600
+	6	120120	1	1200
+	7	120200	1	360 -- Rough Dragon Ruby
+	8	120210	1	1200
+	9	120220	1	400
+	10	120230	1	20
+	11	120300	1	18 -- Rough Dragon Ruby
+	12	120310	1	60
+	13	120320	1	20
+	14	120330	1	1
+	15	120400	1	18 -- Rough Dragon Ruby
+	16	120410	1	60
+	17	120420	1	20
+	18	120430	1	1
+	19	120440	1	1
+	20	121000	1	810 -- Cut Dragon Ruby
+	21	121010	1	2700
+	22	121020	1	900
+	23	121030	1	45
+	24	121100	1	2700 -- Cut Dragon Ruby
+	25	121110	1	9000
+	26	121120	1	3000
+	27	121130	1	150
+	28	121200	1	900 -- Cut Dragon Ruby
+	29	121210	1	3000
+	30	121220	1	1000
+	31	121230	1	50
+	32	121300	1	45 -- Cut Dragon Ruby
+	33	121310	1	150
+	34	121320	1	50
+	35	121330	1	3
+	36	121340	1	3
+	37	121400	1	45 -- Cut Dragon Ruby
+	38	121410	1	150
+	39	121420	1	50
+	40	121430	1	3
+	41	121440	1	3
+	42	122000	1	1782 -- Rare Dragon Ruby
+	43	122010	1	5940
+	44	122020	1	1980
+	45	122030	1	99
+	46	122040	1	99
+	47	122100	1	5940 -- Rare Dragon Ruby
+	48	122110	1	19800
+	49	122120	1	6600
+	50	122130	1	330
+	51	122140	1	330
+	52	122200	1	1980 -- Rare Dragon Ruby
+	53	122210	1	6600
+	54	122220	1	2200
+	55	122230	1	110
+	56	122240	1	110
+	57	122300	1	99 -- Rare Dragon Ruby
+	58	122310	1	330
+	59	122320	1	110
+	60	122330	1	6
+	61	122340	1	6
+	62	122400	1	99 -- Rare Dragon Ruby
+	63	122410	1	330
+	64	122420	1	110
+	65	122430	1	6
+	66	122440	1	6
+	67	123000	1	324 -- Antique Dragon Ruby
+	68	123010	1	1080
+	69	123020	1	360
+	70	123030	1	18
+	71	123040	1	18
+	72	123100	1	1080 -- Antique Dragon Ruby
+	73	123110	1	3600
+	74	123120	1	1200
+	75	123130	1	60
+	76	123140	1	60
+	77	123200	1	360 -- Antique Dragon Ruby
+	78	123210	1	1200
+	79	123220	1	400
+	80	123230	1	20
+	81	123240	1	20
+	82	123300	1	18 -- Antique Dragon Ruby
+	83	123310	1	60
+	84	123320	1	20
+	85	123330	1	1
+	86	123340	1	1
+	87	123400	1	18 -- Antique Dragon Ruby
+	88	123410	1	60
+	89	123420	1	20
+	90	123430	1	1
+	91	123440	1	1
+}
+Group	풍麗肌혼_球-
+{
+	Vnum	51593 -- Cor Jadeit+ (Precious)
+	1	130000	1	324 -- Rough Dragon Jade
+	2	130010	1	1080
+	3	130020	1	360
+	4	130100	1	1080 -- Rough Dragon Jade
+	5	130110	1	3600
+	6	130120	1	1200
+	7	130200	1	360 -- Rough Dragon Jade
+	8	130210	1	1200
+	9	130220	1	400
+	10	130230	1	20
+	11	130300	1	18 -- Rough Dragon Jade
+	12	130310	1	60
+	13	130320	1	20
+	14	130330	1	1
+	15	130400	1	18 -- Rough Dragon Jade
+	16	130410	1	60
+	17	130420	1	20
+	18	130430	1	1
+	19	130440	1	1
+	20	131000	1	810 -- Cut Dragon Jade
+	21	131010	1	2700
+	22	131020	1	900
+	23	131030	1	45
+	24	131100	1	2700 -- Cut Dragon Jade
+	25	131110	1	9000
+	26	131120	1	3000
+	27	131130	1	150
+	28	131200	1	900 -- Cut Dragon Jade
+	29	131210	1	3000
+	30	131220	1	1000
+	31	131230	1	50
+	32	131300	1	45 -- Cut Dragon Jade
+	33	131310	1	150
+	34	131320	1	50
+	35	131330	1	3
+	36	131340	1	3
+	37	131400	1	45 -- Cut Dragon Jade
+	38	131410	1	150
+	39	131420	1	50
+	40	131430	1	3
+	41	131440	1	3
+	42	132000	1	1782 -- Rare Dragon Jade
+	43	132010	1	5940
+	44	132020	1	1980
+	45	132030	1	99
+	46	132040	1	99
+	47	132100	1	5940 -- Rare Dragon Jade
+	48	132110	1	19800
+	49	132120	1	6600
+	50	132130	1	330
+	51	132140	1	330
+	52	132200	1	1980 -- Rare Dragon Jade
+	53	132210	1	6600
+	54	132220	1	2200
+	55	132230	1	110
+	56	132240	1	110
+	57	132300	1	99 -- Rare Dragon Jade
+	58	132310	1	330
+	59	132320	1	110
+	60	132330	1	6
+	61	132340	1	6
+	62	132400	1	99 -- Rare Dragon Jade
+	63	132410	1	330
+	64	132420	1	110
+	65	132430	1	6
+	66	132440	1	6
+	67	133000	1	324 -- Antique Dragon Jade
+	68	133010	1	1080
+	69	133020	1	360
+	70	133030	1	18
+	71	133040	1	18
+	72	133100	1	1080 -- Antique Dragon Jade
+	73	133110	1	3600
+	74	133120	1	1200
+	75	133130	1	60
+	76	133140	1	60
+	77	133200	1	360 -- Antique Dragon Jade
+	78	133210	1	1200
+	79	133220	1	400
+	80	133230	1	20
+	81	133240	1	20
+	82	133300	1	18 -- Antique Dragon Jade
+	83	133310	1	60
+	84	133320	1	20
+	85	133330	1	1
+	86	133340	1	1
+	87	133400	1	18 -- Antique Dragon Jade
+	88	133410	1	60
+	89	133420	1	20
+	90	133430	1	1
+	91	133440	1	1
+}
+Group	철麗肌혼_球-
+{
+	Vnum	51594 -- Cor Saphirum+ (Precious)
+	1	140000	1	324 -- Rough Dragon Sapphire
+	2	140010	1	1080
+	3	140020	1	360
+	4	140100	1	1080 -- Rough Dragon Sapphire
+	5	140110	1	3600
+	6	140120	1	1200
+	7	140200	1	360 -- Rough Dragon Sapphire
+	8	140210	1	1200
+	9	140220	1	400
+	10	140230	1	20
+	11	140300	1	18 -- Rough Dragon Sapphire
+	12	140310	1	60
+	13	140320	1	20
+	14	140330	1	1
+	15	140400	1	18 -- Rough Dragon Sapphire
+	16	140410	1	60
+	17	140420	1	20
+	18	140430	1	1
+	19	140440	1	1
+	20	141000	1	810 -- Cut Dragon Sapphire
+	21	141010	1	2700
+	22	141020	1	900
+	23	141030	1	45
+	24	141100	1	2700 -- Cut Dragon Sapphire
+	25	141110	1	9000
+	26	141120	1	3000
+	27	141130	1	150
+	28	141200	1	900 -- Cut Dragon Sapphire
+	29	141210	1	3000
+	30	141220	1	1000
+	31	141230	1	50
+	32	141300	1	45 -- Cut Dragon Sapphire
+	33	141310	1	150
+	34	141320	1	50
+	35	141330	1	3
+	36	141340	1	3
+	37	141400	1	45 -- Cut Dragon Sapphire
+	38	141410	1	150
+	39	141420	1	50
+	40	141430	1	3
+	41	141440	1	3
+	42	142000	1	1782 -- Rare Dragon Sapphire
+	43	142010	1	5940
+	44	142020	1	1980
+	45	142030	1	99
+	46	142040	1	99
+	47	142100	1	5940 -- Rare Dragon Sapphire
+	48	142110	1	19800
+	49	142120	1	6600
+	50	142130	1	330
+	51	142140	1	330
+	52	142200	1	1980 -- Rare Dragon Sapphire
+	53	142210	1	6600
+	54	142220	1	2200
+	55	142230	1	110
+	56	142240	1	110
+	57	142300	1	99 -- Rare Dragon Sapphire
+	58	142310	1	330
+	59	142320	1	110
+	60	142330	1	6
+	61	142340	1	6
+	62	142400	1	99 -- Rare Dragon Sapphire
+	63	142410	1	330
+	64	142420	1	110
+	65	142430	1	6
+	66	142440	1	6
+	67	143000	1	324 -- Antique Dragon Sapphire
+	68	143010	1	1080
+	69	143020	1	360
+	70	143030	1	18
+	71	143040	1	18
+	72	143100	1	1080 -- Antique Dragon Sapphire
+	73	143110	1	3600
+	74	143120	1	1200
+	75	143130	1	60
+	76	143140	1	60
+	77	143200	1	360 -- Antique Dragon Sapphire
+	78	143210	1	1200
+	79	143220	1	400
+	80	143230	1	20
+	81	143240	1	20
+	82	143300	1	18 -- Antique Dragon Sapphire
+	83	143310	1	60
+	84	143320	1	20
+	85	143330	1	1
+	86	143340	1	1
+	87	143400	1	18 -- Antique Dragon Sapphire
+	88	143410	1	60
+	89	143420	1	20
+	90	143430	1	1
+	91	143440	1	1
+}
+Group	麗肌혼_球-
+{
+	Vnum	51595 -- Cor Granatum+ (Precious)
+	1	150000	1	324 -- Rough Dragon Garnet
+	2	150010	1	1080
+	3	150020	1	360
+	4	150100	1	1080 -- Rough Dragon Garnet
+	5	150110	1	3600
+	6	150120	1	1200
+	7	150200	1	360 -- Rough Dragon Garnet
+	8	150210	1	1200
+	9	150220	1	400
+	10	150230	1	20
+	11	150300	1	18 -- Rough Dragon Garnet
+	12	150310	1	60
+	13	150320	1	20
+	14	150330	1	1
+	15	150400	1	18 -- Rough Dragon Garnet
+	16	150410	1	60
+	17	150420	1	20
+	18	150430	1	1
+	19	150440	1	1
+	20	151000	1	810 -- Cut Dragon Garnet
+	21	151010	1	2700
+	22	151020	1	900
+	23	151030	1	45
+	24	151100	1	2700 -- Cut Dragon Garnet
+	25	151110	1	9000
+	26	151120	1	3000
+	27	151130	1	150
+	28	151200	1	900 -- Cut Dragon Garnet
+	29	151210	1	3000
+	30	151220	1	1000
+	31	151230	1	50
+	32	151300	1	45 -- Cut Dragon Garnet
+	33	151310	1	150
+	34	151320	1	50
+	35	151330	1	3
+	36	151340	1	3
+	37	151400	1	45 -- Cut Dragon Garnet
+	38	151410	1	150
+	39	151420	1	50
+	40	151430	1	3
+	41	151440	1	3
+	42	152000	1	1782 -- Rare Dragon Garnet
+	43	152010	1	5940
+	44	152020	1	1980
+	45	152030	1	99
+	46	152040	1	99
+	47	152100	1	5940 -- Rare Dragon Garnet
+	48	152110	1	19800
+	49	152120	1	6600
+	50	152130	1	330
+	51	152140	1	330
+	52	152200	1	1980 -- Rare Dragon Garnet
+	53	152210	1	6600
+	54	152220	1	2200
+	55	152230	1	110
+	56	152240	1	110
+	57	152300	1	99 -- Rare Dragon Garnet
+	58	152310	1	330
+	59	152320	1	110
+	60	152330	1	6
+	61	152340	1	6
+	62	152400	1	99 -- Rare Dragon Garnet
+	63	152410	1	330
+	64	152420	1	110
+	65	152430	1	6
+	66	152440	1	6
+	67	153000	1	324 -- Antique Dragon Garnet
+	68	153010	1	1080
+	69	153020	1	360
+	70	153030	1	18
+	71	153040	1	18
+	72	153100	1	1080 -- Antique Dragon Garnet
+	73	153110	1	3600
+	74	153120	1	1200
+	75	153130	1	60
+	76	153140	1	60
+	77	153200	1	360 -- Antique Dragon Garnet
+	78	153210	1	1200
+	79	153220	1	400
+	80	153230	1	20
+	81	153240	1	20
+	82	153300	1	18 -- Antique Dragon Garnet
+	83	153310	1	60
+	84	153320	1	20
+	85	153330	1	1
+	86	153340	1	1
+	87	153400	1	18 -- Antique Dragon Garnet
+	88	153410	1	60
+	89	153420	1	20
+	90	153430	1	1
+	91	153440	1	1
+}
+Group	麗肌혼_球-
+{
+	Vnum	51596 -- Cor Atrum+ (Precious)
+	1	160000	1	324 -- Rough Dragon Onyx
+	2	160010	1	1080
+	3	160020	1	360
+	4	160100	1	1080 -- Rough Dragon Onyx
+	5	160110	1	3600
+	6	160120	1	1200
+	7	160200	1	360 -- Rough Dragon Onyx
+	8	160210	1	1200
+	9	160220	1	400
+	10	160230	1	20
+	11	160300	1	18 -- Rough Dragon Onyx
+	12	160310	1	60
+	13	160320	1	20
+	14	160330	1	1
+	15	160400	1	18 -- Rough Dragon Onyx
+	16	160410	1	60
+	17	160420	1	20
+	18	160430	1	1
+	19	160440	1	1
+	20	161000	1	810 -- Cut Dragon Onyx
+	21	161010	1	2700
+	22	161020	1	900
+	23	161030	1	45
+	24	161100	1	2700 -- Cut Dragon Onyx
+	25	161110	1	9000
+	26	161120	1	3000
+	27	161130	1	150
+	28	161200	1	900 -- Cut Dragon Onyx
+	29	161210	1	3000
+	30	161220	1	1000
+	31	161230	1	50
+	32	161300	1	45 -- Cut Dragon Onyx
+	33	161310	1	150
+	34	161320	1	50
+	35	161330	1	3
+	36	161340	1	3
+	37	161400	1	45 -- Cut Dragon Onyx
+	38	161410	1	150
+	39	161420	1	50
+	40	161430	1	3
+	41	161440	1	3
+	42	162000	1	1782 -- Rare Dragon Onyx
+	43	162010	1	5940
+	44	162020	1	1980
+	45	162030	1	99
+	46	162040	1	99
+	47	162100	1	5940 -- Rare Dragon Onyx
+	48	162110	1	19800
+	49	162120	1	6600
+	50	162130	1	330
+	51	162140	1	330
+	52	162200	1	1980 -- Rare Dragon Onyx
+	53	162210	1	6600
+	54	162220	1	2200
+	55	162230	1	110
+	56	162240	1	110
+	57	162300	1	99 -- Rare Dragon Onyx
+	58	162310	1	330
+	59	162320	1	110
+	60	162330	1	6
+	61	162340	1	6
+	62	162400	1	99 -- Rare Dragon Onyx
+	63	162410	1	330
+	64	162420	1	110
+	65	162430	1	6
+	66	162440	1	6
+	67	163000	1	324 -- Antique Dragon Onyx
+	68	163010	1	1080
+	69	163020	1	360
+	70	163030	1	18
+	71	163040	1	18
+	72	163100	1	1080 -- Antique Dragon Onyx
+	73	163110	1	3600
+	74	163120	1	1200
+	75	163130	1	60
+	76	163140	1	60
+	77	163200	1	360 -- Antique Dragon Onyx
+	78	163210	1	1200
+	79	163220	1	400
+	80	163230	1	20
+	81	163240	1	20
+	82	163300	1	18 -- Antique Dragon Onyx
+	83	163310	1	60
+	84	163320	1	20
+	85	163330	1	1
+	86	163340	1	1
+	87	163400	1	18 -- Antique Dragon Onyx
+	88	163410	1	60
+	89	163420	1	20
+	90	163430	1	1
+	91	163440	1	1
+}
+Group	肌혼_球-
+{
+	Vnum	51597 -- Cor Draconis+ (Flawless)
+	1	110000	1	324 -- Rough Dragon Diamond
+	2	110010	1	1080
+	3	110020	1	360
+	4	110100	1	1080 -- Rough Dragon Diamond
+	5	110110	1	3600
+	6	110120	1	1200
+	7	110200	1	360 -- Rough Dragon Diamond
+	8	110210	1	1200
+	9	110220	1	400
+	10	110230	1	20
+	11	110300	1	18 -- Rough Dragon Diamond
+	12	110310	1	60
+	13	110320	1	20
+	14	110330	1	1
+	15	110400	1	18 -- Rough Dragon Diamond
+	16	110410	1	60
+	17	110420	1	20
+	18	110430	1	1
+	19	110440	1	1
+	20	111000	1	648 -- Cut Dragon Diamond
+	21	111010	1	2160
+	22	111020	1	720
+	23	111030	1	36
+	24	111100	1	2160 -- Cut Dragon Diamond
+	25	111110	1	7200
+	26	111120	1	2400
+	27	111130	1	120
+	28	111200	1	720 -- Cut Dragon Diamond
+	29	111210	1	2400
+	30	111220	1	800
+	31	111230	1	40
+	32	111300	1	36 -- Cut Dragon Diamond
+	33	111310	1	120
+	34	111320	1	40
+	35	111330	1	2
+	36	111340	1	2
+	37	111400	1	36 -- Cut Dragon Diamond
+	38	111410	1	120
+	39	111420	1	40
+	40	111430	1	2
+	41	111440	1	2
+	42	112000	1	972 -- Rare Dragon Diamond
+	43	112010	1	3240
+	44	112020	1	1080
+	45	112030	1	54
+	46	112040	1	54
+	47	112100	1	3240 -- Rare Dragon Diamond
+	48	112110	1	10800
+	49	112120	1	3600
+	50	112130	1	180
+	51	112140	1	180
+	52	112200	1	1080 -- Rare Dragon Diamond
+	53	112210	1	3600
+	54	112220	1	1200
+	55	112230	1	60
+	56	112240	1	60
+	57	112300	1	54 -- Rare Dragon Diamond
+	58	112310	1	180
+	59	112320	1	60
+	60	112330	1	3
+	61	112340	1	3
+	62	112400	1	54 -- Rare Dragon Diamond
+	63	112410	1	180
+	64	112420	1	60
+	65	112430	1	3
+	66	112440	1	3
+	67	113000	1	3888 -- Antique Dragon Diamond
+	68	113010	1	12960
+	69	113020	1	4320
+	70	113030	1	216
+	71	113040	1	216
+	72	113100	1	12960 -- Antique Dragon Diamond
+	73	113110	1	43200
+	74	113120	1	14400
+	75	113130	1	720
+	76	113140	1	720
+	77	113200	1	4320 -- Antique Dragon Diamond
+	78	113210	1	14400
+	79	113220	1	4800
+	80	113230	1	240
+	81	113240	1	240
+	82	113300	1	216 -- Antique Dragon Diamond
+	83	113310	1	720
+	84	113320	1	240
+	85	113330	1	12
+	86	113340	1	12
+	87	113400	1	216 -- Antique Dragon Diamond
+	88	113410	1	720
+	89	113420	1	240
+	90	113430	1	12
+	91	113440	1	12
+	92	114000	1	648 -- Legendary Dragon Diamond
+	93	114010	1	2160
+	94	114020	1	720
+	95	114030	1	36
+	96	114040	1	36
+	97	114100	1	2160 -- Legendary Dragon Diamond
+	98	114110	1	7200
+	99	114120	1	2400
+	100	114130	1	120
+	101	114140	1	120
+	102	114200	1	720 -- Legendary Dragon Diamond
+	103	114210	1	2400
+	104	114220	1	800
+	105	114230	1	40
+	106	114240	1	40
+	107	114300	1	36 -- Legendary Dragon Diamond
+	108	114310	1	120
+	109	114320	1	40
+	110	114330	1	2
+	111	114340	1	2
+	112	114400	1	36 -- Legendary Dragon Diamond
+	113	114410	1	120
+	114	114420	1	40
+	115	114430	1	2
+	116	114440	1	2
+	117	120000	1	324 -- Rough Dragon Ruby
+	118	120010	1	1080
+	119	120020	1	360
+	120	120100	1	1080 -- Rough Dragon Ruby
+	121	120110	1	3600
+	122	120120	1	1200
+	123	120200	1	360 -- Rough Dragon Ruby
+	124	120210	1	1200
+	125	120220	1	400
+	126	120230	1	20
+	127	120300	1	18 -- Rough Dragon Ruby
+	128	120310	1	60
+	129	120320	1	20
+	130	120330	1	1
+	131	120400	1	18 -- Rough Dragon Ruby
+	132	120410	1	60
+	133	120420	1	20
+	134	120430	1	1
+	135	120440	1	1
+	136	121000	1	648 -- Cut Dragon Ruby
+	137	121010	1	2160
+	138	121020	1	720
+	139	121030	1	36
+	140	121100	1	2160 -- Cut Dragon Ruby
+	141	121110	1	7200
+	142	121120	1	2400
+	143	121130	1	120
+	144	121200	1	720 -- Cut Dragon Ruby
+	145	121210	1	2400
+	146	121220	1	800
+	147	121230	1	40
+	148	121300	1	36 -- Cut Dragon Ruby
+	149	121310	1	120
+	150	121320	1	40
+	151	121330	1	2
+	152	121340	1	2
+	153	121400	1	36 -- Cut Dragon Ruby
+	154	121410	1	120
+	155	121420	1	40
+	156	121430	1	2
+	157	121440	1	2
+	158	122000	1	972 -- Rare Dragon Ruby
+	159	122010	1	3240
+	160	122020	1	1080
+	161	122030	1	54
+	162	122040	1	54
+	163	122100	1	3240 -- Rare Dragon Ruby
+	164	122110	1	10800
+	165	122120	1	3600
+	166	122130	1	180
+	167	122140	1	180
+	168	122200	1	1080 -- Rare Dragon Ruby
+	169	122210	1	3600
+	170	122220	1	1200
+	171	122230	1	60
+	172	122240	1	60
+	173	122300	1	54 -- Rare Dragon Ruby
+	174	122310	1	180
+	175	122320	1	60
+	176	122330	1	3
+	177	122340	1	3
+	178	122400	1	54 -- Rare Dragon Ruby
+	179	122410	1	180
+	180	122420	1	60
+	181	122430	1	3
+	182	122440	1	3
+	183	123000	1	3888 -- Antique Dragon Ruby
+	184	123010	1	12960
+	185	123020	1	4320
+	186	123030	1	216
+	187	123040	1	216
+	188	123100	1	12960 -- Antique Dragon Ruby
+	189	123110	1	43200
+	190	123120	1	14400
+	191	123130	1	720
+	192	123140	1	720
+	193	123200	1	4320 -- Antique Dragon Ruby
+	194	123210	1	14400
+	195	123220	1	4800
+	196	123230	1	240
+	197	123240	1	240
+	198	123300	1	216 -- Antique Dragon Ruby
+	199	123310	1	720
+	200	123320	1	240
+	201	123330	1	12
+	202	123340	1	12
+	203	123400	1	216 -- Antique Dragon Ruby
+	204	123410	1	720
+	205	123420	1	240
+	206	123430	1	12
+	207	123440	1	12
+	208	124000	1	648 -- Legendary Dragon Ruby
+	209	124010	1	2160
+	210	124020	1	720
+	211	124030	1	36
+	212	124040	1	36
+	213	124100	1	2160 -- Legendary Dragon Ruby
+	214	124110	1	7200
+	215	124120	1	2400
+	216	124130	1	120
+	217	124140	1	120
+	218	124200	1	720 -- Legendary Dragon Ruby
+	219	124210	1	2400
+	220	124220	1	800
+	221	124230	1	40
+	222	124240	1	40
+	223	124300	1	36 -- Legendary Dragon Ruby
+	224	124310	1	120
+	225	124320	1	40
+	226	124330	1	2
+	227	124340	1	2
+	228	124400	1	36 -- Legendary Dragon Ruby
+	229	124410	1	120
+	230	124420	1	40
+	231	124430	1	2
+	232	124440	1	2
+	233	130000	1	324 -- Rough Dragon Jade
+	234	130010	1	1080
+	235	130020	1	360
+	236	130100	1	1080 -- Rough Dragon Jade
+	237	130110	1	3600
+	238	130120	1	1200
+	239	130200	1	360 -- Rough Dragon Jade
+	240	130210	1	1200
+	241	130220	1	400
+	242	130230	1	20
+	243	130300	1	18 -- Rough Dragon Jade
+	244	130310	1	60
+	245	130320	1	20
+	246	130330	1	1
+	247	130400	1	18 -- Rough Dragon Jade
+	248	130410	1	60
+	249	130420	1	20
+	250	130430	1	1
+	251	130440	1	1
+	252	131000	1	648 -- Cut Dragon Jade
+	253	131010	1	2160
+	254	131020	1	720
+	255	131030	1	36
+	256	131100	1	2160 -- Cut Dragon Jade
+	257	131110	1	7200
+	258	131120	1	2400
+	259	131130	1	120
+	260	131200	1	720 -- Cut Dragon Jade
+	261	131210	1	2400
+	262	131220	1	800
+	263	131230	1	40
+	264	131300	1	36 -- Cut Dragon Jade
+	265	131310	1	120
+	266	131320	1	40
+	267	131330	1	2
+	268	131340	1	2
+	269	131400	1	36 -- Cut Dragon Jade
+	270	131410	1	120
+	271	131420	1	40
+	272	131430	1	2
+	273	131440	1	2
+	274	132000	1	972 -- Rare Dragon Jade
+	275	132010	1	3240
+	276	132020	1	1080
+	277	132030	1	54
+	278	132040	1	54
+	279	132100	1	3240 -- Rare Dragon Jade
+	280	132110	1	10800
+	281	132120	1	3600
+	282	132130	1	180
+	283	132140	1	180
+	284	132200	1	1080 -- Rare Dragon Jade
+	285	132210	1	3600
+	286	132220	1	1200
+	287	132230	1	60
+	288	132240	1	60
+	289	132300	1	54 -- Rare Dragon Jade
+	290	132310	1	180
+	291	132320	1	60
+	292	132330	1	3
+	293	132340	1	3
+	294	132400	1	54 -- Rare Dragon Jade
+	295	132410	1	180
+	296	132420	1	60
+	297	132430	1	3
+	298	132440	1	3
+	299	133000	1	3888 -- Antique Dragon Jade
+	300	133010	1	12960
+	301	133020	1	4320
+	302	133030	1	216
+	303	133040	1	216
+	304	133100	1	12960 -- Antique Dragon Jade
+	305	133110	1	43200
+	306	133120	1	14400
+	307	133130	1	720
+	308	133140	1	720
+	309	133200	1	4320 -- Antique Dragon Jade
+	310	133210	1	14400
+	311	133220	1	4800
+	312	133230	1	240
+	313	133240	1	240
+	314	133300	1	216 -- Antique Dragon Jade
+	315	133310	1	720
+	316	133320	1	240
+	317	133330	1	12
+	318	133340	1	12
+	319	133400	1	216 -- Antique Dragon Jade
+	320	133410	1	720
+	321	133420	1	240
+	322	133430	1	12
+	323	133440	1	12
+	324	134000	1	648 -- Legendary Dragon Jade
+	325	134010	1	2160
+	326	134020	1	720
+	327	134030	1	36
+	328	134040	1	36
+	329	134100	1	2160 -- Legendary Dragon Jade
+	330	134110	1	7200
+	331	134120	1	2400
+	332	134130	1	120
+	333	134140	1	120
+	334	134200	1	720 -- Legendary Dragon Jade
+	335	134210	1	2400
+	336	134220	1	800
+	337	134230	1	40
+	338	134240	1	40
+	339	134300	1	36 -- Legendary Dragon Jade
+	340	134310	1	120
+	341	134320	1	40
+	342	134330	1	2
+	343	134340	1	2
+	344	134400	1	36 -- Legendary Dragon Jade
+	345	134410	1	120
+	346	134420	1	40
+	347	134430	1	2
+	348	134440	1	2
+	349	140000	1	324 -- Rough Dragon Sapphire
+	350	140010	1	1080
+	351	140020	1	360
+	352	140100	1	1080 -- Rough Dragon Sapphire
+	353	140110	1	3600
+	354	140120	1	1200
+	355	140200	1	360 -- Rough Dragon Sapphire
+	356	140210	1	1200
+	357	140220	1	400
+	358	140230	1	20
+	359	140300	1	18 -- Rough Dragon Sapphire
+	360	140310	1	60
+	361	140320	1	20
+	362	140330	1	1
+	363	140400	1	18 -- Rough Dragon Sapphire
+	364	140410	1	60
+	365	140420	1	20
+	366	140430	1	1
+	367	140440	1	1
+	368	141000	1	648 -- Cut Dragon Sapphire
+	369	141010	1	2160
+	370	141020	1	720
+	371	141030	1	36
+	372	141100	1	2160 -- Cut Dragon Sapphire
+	373	141110	1	7200
+	374	141120	1	2400
+	375	141130	1	120
+	376	141200	1	720 -- Cut Dragon Sapphire
+	377	141210	1	2400
+	378	141220	1	800
+	379	141230	1	40
+	380	141300	1	36 -- Cut Dragon Sapphire
+	381	141310	1	120
+	382	141320	1	40
+	383	141330	1	2
+	384	141340	1	2
+	385	141400	1	36 -- Cut Dragon Sapphire
+	386	141410	1	120
+	387	141420	1	40
+	388	141430	1	2
+	389	141440	1	2
+	390	142000	1	972 -- Rare Dragon Sapphire
+	391	142010	1	3240
+	392	142020	1	1080
+	393	142030	1	54
+	394	142040	1	54
+	395	142100	1	3240 -- Rare Dragon Sapphire
+	396	142110	1	10800
+	397	142120	1	3600
+	398	142130	1	180
+	399	142140	1	180
+	400	142200	1	1080 -- Rare Dragon Sapphire
+	401	142210	1	3600
+	402	142220	1	1200
+	403	142230	1	60
+	404	142240	1	60
+	405	142300	1	54 -- Rare Dragon Sapphire
+	406	142310	1	180
+	407	142320	1	60
+	408	142330	1	3
+	409	142340	1	3
+	410	142400	1	54 -- Rare Dragon Sapphire
+	411	142410	1	180
+	412	142420	1	60
+	413	142430	1	3
+	414	142440	1	3
+	415	143000	1	3888 -- Antique Dragon Sapphire
+	416	143010	1	12960
+	417	143020	1	4320
+	418	143030	1	216
+	419	143040	1	216
+	420	143100	1	12960 -- Antique Dragon Sapphire
+	421	143110	1	43200
+	422	143120	1	14400
+	423	143130	1	720
+	424	143140	1	720
+	425	143200	1	4320 -- Antique Dragon Sapphire
+	426	143210	1	14400
+	427	143220	1	4800
+	428	143230	1	240
+	429	143240	1	240
+	430	143300	1	216 -- Antique Dragon Sapphire
+	431	143310	1	720
+	432	143320	1	240
+	433	143330	1	12
+	434	143340	1	12
+	435	143400	1	216 -- Antique Dragon Sapphire
+	436	143410	1	720
+	437	143420	1	240
+	438	143430	1	12
+	439	143440	1	12
+	440	144000	1	648 -- Legendary DragonSapphire
+	441	144010	1	2160
+	442	144020	1	720
+	443	144030	1	36
+	444	144040	1	36
+	445	144100	1	2160 -- Legendary DragonSapphire
+	446	144110	1	7200
+	447	144120	1	2400
+	448	144130	1	120
+	449	144140	1	120
+	450	144200	1	720 -- Legendary DragonSapphire
+	451	144210	1	2400
+	452	144220	1	800
+	453	144230	1	40
+	454	144240	1	40
+	455	144300	1	36 -- Legendary DragonSapphire
+	456	144310	1	120
+	457	144320	1	40
+	458	144330	1	2
+	459	144340	1	2
+	460	144400	1	36 -- Legendary DragonSapphire
+	461	144410	1	120
+	462	144420	1	40
+	463	144430	1	2
+	464	144440	1	2
+	465	150000	1	324 -- Rough Dragon Garnet
+	466	150010	1	1080
+	467	150020	1	360
+	468	150100	1	1080 -- Rough Dragon Garnet
+	469	150110	1	3600
+	470	150120	1	1200
+	471	150200	1	360 -- Rough Dragon Garnet
+	472	150210	1	1200
+	473	150220	1	400
+	474	150230	1	20
+	475	150300	1	18 -- Rough Dragon Garnet
+	476	150310	1	60
+	477	150320	1	20
+	478	150330	1	1
+	479	150400	1	18 -- Rough Dragon Garnet
+	480	150410	1	60
+	481	150420	1	20
+	482	150430	1	1
+	483	150440	1	1
+	484	151000	1	648 -- Cut Dragon Garnet
+	485	151010	1	2160
+	486	151020	1	720
+	487	151030	1	36
+	488	151100	1	2160 -- Cut Dragon Garnet
+	489	151110	1	7200
+	490	151120	1	2400
+	491	151130	1	120
+	492	151200	1	720 -- Cut Dragon Garnet
+	493	151210	1	2400
+	494	151220	1	800
+	495	151230	1	40
+	496	151300	1	36 -- Cut Dragon Garnet
+	497	151310	1	120
+	498	151320	1	40
+	499	151330	1	2
+	500	151340	1	2
+	501	151400	1	36 -- Cut Dragon Garnet
+	502	151410	1	120
+	503	151420	1	40
+	504	151430	1	2
+	505	151440	1	2
+	506	152000	1	972 -- Rare Dragon Garnet
+	507	152010	1	3240
+	508	152020	1	1080
+	509	152030	1	54
+	510	152040	1	54
+	511	152100	1	3240 -- Rare Dragon Garnet
+	512	152110	1	10800
+	513	152120	1	3600
+	514	152130	1	180
+	515	152140	1	180
+	516	152200	1	1080 -- Rare Dragon Garnet
+	517	152210	1	3600
+	518	152220	1	1200
+	519	152230	1	60
+	520	152240	1	60
+	521	152300	1	54 -- Rare Dragon Garnet
+	522	152310	1	180
+	523	152320	1	60
+	524	152330	1	3
+	525	152340	1	3
+	526	152400	1	54 -- Rare Dragon Garnet
+	527	152410	1	180
+	528	152420	1	60
+	529	152430	1	3
+	530	152440	1	3
+	531	153000	1	3888 -- Antique Dragon Garnet
+	532	153010	1	12960
+	533	153020	1	4320
+	534	153030	1	216
+	535	153040	1	216
+	536	153100	1	12960 -- Antique Dragon Garnet
+	537	153110	1	43200
+	538	153120	1	14400
+	539	153130	1	720
+	540	153140	1	720
+	541	153200	1	4320 -- Antique Dragon Garnet
+	542	153210	1	14400
+	543	153220	1	4800
+	544	153230	1	240
+	545	153240	1	240
+	546	153300	1	216 -- Antique Dragon Garnet
+	547	153310	1	720
+	548	153320	1	240
+	549	153330	1	12
+	550	153340	1	12
+	551	153400	1	216 -- Antique Dragon Garnet
+	552	153410	1	720
+	553	153420	1	240
+	554	153430	1	12
+	555	153440	1	12
+	556	154000	1	648 -- Legendary Dragon Garnet
+	557	154010	1	2160
+	558	154020	1	720
+	559	154030	1	36
+	560	154040	1	36
+	561	154100	1	2160 -- Legendary Dragon Garnet
+	562	154110	1	7200
+	563	154120	1	2400
+	564	154130	1	120
+	565	154140	1	120
+	566	154200	1	720 -- Legendary Dragon Garnet
+	567	154210	1	2400
+	568	154220	1	800
+	569	154230	1	40
+	570	154240	1	40
+	571	154300	1	36 -- Legendary Dragon Garnet
+	572	154310	1	120
+	573	154320	1	40
+	574	154330	1	2
+	575	154340	1	2
+	576	154400	1	36 -- Legendary Dragon Garnet
+	577	154410	1	120
+	578	154420	1	40
+	579	154430	1	2
+	580	154440	1	2
+	581	160000	1	324 -- Rough Dragon Onyx
+	582	160010	1	1080
+	583	160020	1	360
+	584	160100	1	1080 -- Rough Dragon Onyx
+	585	160110	1	3600
+	586	160120	1	1200
+	587	160200	1	360 -- Rough Dragon Onyx
+	588	160210	1	1200
+	589	160220	1	400
+	590	160230	1	20
+	591	160300	1	18 -- Rough Dragon Onyx
+	592	160310	1	60
+	593	160320	1	20
+	594	160330	1	1
+	595	160400	1	18 -- Rough Dragon Onyx
+	596	160410	1	60
+	597	160420	1	20
+	598	160430	1	1
+	599	160440	1	1
+	600	161000	1	648 -- Cut Dragon Onyx
+	601	161010	1	2160
+	602	161020	1	720
+	603	161030	1	36
+	604	161100	1	2160 -- Cut Dragon Onyx
+	605	161110	1	7200
+	606	161120	1	2400
+	607	161130	1	120
+	608	161200	1	720 -- Cut Dragon Onyx
+	609	161210	1	2400
+	610	161220	1	800
+	611	161230	1	40
+	612	161300	1	36 -- Cut Dragon Onyx
+	613	161310	1	120
+	614	161320	1	40
+	615	161330	1	2
+	616	161340	1	2
+	617	161400	1	36 -- Cut Dragon Onyx
+	618	161410	1	120
+	619	161420	1	40
+	620	161430	1	2
+	621	161440	1	2
+	622	162000	1	972 -- Rare Dragon Onyx
+	623	162010	1	3240
+	624	162020	1	1080
+	625	162030	1	54
+	626	162040	1	54
+	627	162100	1	3240 -- Rare Dragon Onyx
+	628	162110	1	10800
+	629	162120	1	3600
+	630	162130	1	180
+	631	162140	1	180
+	632	162200	1	1080 -- Rare Dragon Onyx
+	633	162210	1	3600
+	634	162220	1	1200
+	635	162230	1	60
+	636	162240	1	60
+	637	162300	1	54 -- Rare Dragon Onyx
+	638	162310	1	180
+	639	162320	1	60
+	640	162330	1	3
+	641	162340	1	3
+	642	162400	1	54 -- Rare Dragon Onyx
+	643	162410	1	180
+	644	162420	1	60
+	645	162430	1	3
+	646	162440	1	3
+	647	163000	1	3888 -- Antique Dragon Onyx
+	648	163010	1	12960
+	649	163020	1	4320
+	650	163030	1	216
+	651	163040	1	216
+	652	163100	1	12960 -- Antique Dragon Onyx
+	653	163110	1	43200
+	654	163120	1	14400
+	655	163130	1	720
+	656	163140	1	720
+	657	163200	1	4320 -- Antique Dragon Onyx
+	658	163210	1	14400
+	659	163220	1	4800
+	660	163230	1	240
+	661	163240	1	240
+	662	163300	1	216 -- Antique Dragon Onyx
+	663	163310	1	720
+	664	163320	1	240
+	665	163330	1	12
+	666	163340	1	12
+	667	163400	1	216 -- Antique Dragon Onyx
+	668	163410	1	720
+	669	163420	1	240
+	670	163430	1	12
+	671	163440	1	12
+	672	164000	1	648 -- Legendary Dragon Onyx
+	673	164010	1	2160
+	674	164020	1	720
+	675	164030	1	36
+	676	164040	1	36
+	677	164100	1	2160 -- Legendary Dragon Onyx
+	678	164110	1	7200
+	679	164120	1	2400
+	680	164130	1	120
+	681	164140	1	120
+	682	164200	1	720 -- Legendary Dragon Onyx
+	683	164210	1	2400
+	684	164220	1	800
+	685	164230	1	40
+	686	164240	1	40
+	687	164300	1	36 -- Legendary Dragon Onyx
+	688	164310	1	120
+	689	164320	1	40
+	690	164330	1	2
+	691	164340	1	2
+	692	164400	1	36 -- Legendary Dragon Onyx
+	693	164410	1	120
+	694	164420	1	40
+	695	164430	1	2
+	696	164440	1	2
+}
+Group	麗肌혼_球-
+{
+	Vnum	51598 -- Cor Diamas+ (Flawless)
+	1	110000	1	324 -- Rough Dragon Diamond
+	2	110010	1	1080
+	3	110020	1	360
+	4	110100	1	1080 -- Rough Dragon Diamond
+	5	110110	1	3600
+	6	110120	1	1200
+	7	110200	1	360 -- Rough Dragon Diamond
+	8	110210	1	1200
+	9	110220	1	400
+	10	110230	1	20
+	11	110300	1	18 -- Rough Dragon Diamond
+	12	110310	1	60
+	13	110320	1	20
+	14	110330	1	1
+	15	110400	1	18 -- Rough Dragon Diamond
+	16	110410	1	60
+	17	110420	1	20
+	18	110430	1	1
+	19	110440	1	1
+	20	111000	1	648 -- Cut Dragon Diamond
+	21	111010	1	2160
+	22	111020	1	720
+	23	111030	1	36
+	24	111100	1	2160 -- Cut Dragon Diamond
+	25	111110	1	7200
+	26	111120	1	2400
+	27	111130	1	120
+	28	111200	1	720 -- Cut Dragon Diamond
+	29	111210	1	2400
+	30	111220	1	800
+	31	111230	1	40
+	32	111300	1	36 -- Cut Dragon Diamond
+	33	111310	1	120
+	34	111320	1	40
+	35	111330	1	2
+	36	111340	1	2
+	37	111400	1	36 -- Cut Dragon Diamond
+	38	111410	1	120
+	39	111420	1	40
+	40	111430	1	2
+	41	111440	1	2
+	42	112000	1	972 -- Rare Dragon Diamond
+	43	112010	1	3240
+	44	112020	1	1080
+	45	112030	1	54
+	46	112040	1	54
+	47	112100	1	3240 -- Rare Dragon Diamond
+	48	112110	1	10800
+	49	112120	1	3600
+	50	112130	1	180
+	51	112140	1	180
+	52	112200	1	1080 -- Rare Dragon Diamond
+	53	112210	1	3600
+	54	112220	1	1200
+	55	112230	1	60
+	56	112240	1	60
+	57	112300	1	54 -- Rare Dragon Diamond
+	58	112310	1	180
+	59	112320	1	60
+	60	112330	1	3
+	61	112340	1	3
+	62	112400	1	54 -- Rare Dragon Diamond
+	63	112410	1	180
+	64	112420	1	60
+	65	112430	1	3
+	66	112440	1	3
+	67	113000	1	3888 -- Antique Dragon Diamond
+	68	113010	1	12960
+	69	113020	1	4320
+	70	113030	1	216
+	71	113040	1	216
+	72	113100	1	12960 -- Antique Dragon Diamond
+	73	113110	1	43200
+	74	113120	1	14400
+	75	113130	1	720
+	76	113140	1	720
+	77	113200	1	4320 -- Antique Dragon Diamond
+	78	113210	1	14400
+	79	113220	1	4800
+	80	113230	1	240
+	81	113240	1	240
+	82	113300	1	216 -- Antique Dragon Diamond
+	83	113310	1	720
+	84	113320	1	240
+	85	113330	1	12
+	86	113340	1	12
+	87	113400	1	216 -- Antique Dragon Diamond
+	88	113410	1	720
+	89	113420	1	240
+	90	113430	1	12
+	91	113440	1	12
+	92	114000	1	648 -- Legendary Dragon Diamond
+	93	114010	1	2160
+	94	114020	1	720
+	95	114030	1	36
+	96	114040	1	36
+	97	114100	1	2160 -- Legendary Dragon Diamond
+	98	114110	1	7200
+	99	114120	1	2400
+	100	114130	1	120
+	101	114140	1	120
+	102	114200	1	720 -- Legendary Dragon Diamond
+	103	114210	1	2400
+	104	114220	1	800
+	105	114230	1	40
+	106	114240	1	40
+	107	114300	1	36 -- Legendary Dragon Diamond
+	108	114310	1	120
+	109	114320	1	40
+	110	114330	1	2
+	111	114340	1	2
+	112	114400	1	36 -- Legendary Dragon Diamond
+	113	114410	1	120
+	114	114420	1	40
+	115	114430	1	2
+	116	114440	1	2
+}
+Group	화麗肌혼_球-
+{
+	Vnum	51599 -- Cor Rubinum+ (Flawless)
+	1	120000	1	324 -- Rough Dragon Ruby
+	2	120010	1	1080
+	3	120020	1	360
+	4	120100	1	1080 -- Rough Dragon Ruby
+	5	120110	1	3600
+	6	120120	1	1200
+	7	120200	1	360 -- Rough Dragon Ruby
+	8	120210	1	1200
+	9	120220	1	400
+	10	120230	1	20
+	11	120300	1	18 -- Rough Dragon Ruby
+	12	120310	1	60
+	13	120320	1	20
+	14	120330	1	1
+	15	120400	1	18 -- Rough Dragon Ruby
+	16	120410	1	60
+	17	120420	1	20
+	18	120430	1	1
+	19	120440	1	1
+	20	121000	1	648 -- Cut Dragon Ruby
+	21	121010	1	2160
+	22	121020	1	720
+	23	121030	1	36
+	24	121100	1	2160 -- Cut Dragon Ruby
+	25	121110	1	7200
+	26	121120	1	2400
+	27	121130	1	120
+	28	121200	1	720 -- Cut Dragon Ruby
+	29	121210	1	2400
+	30	121220	1	800
+	31	121230	1	40
+	32	121300	1	36 -- Cut Dragon Ruby
+	33	121310	1	120
+	34	121320	1	40
+	35	121330	1	2
+	36	121340	1	2
+	37	121400	1	36 -- Cut Dragon Ruby
+	38	121410	1	120
+	39	121420	1	40
+	40	121430	1	2
+	41	121440	1	2
+	42	122000	1	972 -- Rare Dragon Ruby
+	43	122010	1	3240
+	44	122020	1	1080
+	45	122030	1	54
+	46	122040	1	54
+	47	122100	1	3240 -- Rare Dragon Ruby
+	48	122110	1	10800
+	49	122120	1	3600
+	50	122130	1	180
+	51	122140	1	180
+	52	122200	1	1080 -- Rare Dragon Ruby
+	53	122210	1	3600
+	54	122220	1	1200
+	55	122230	1	60
+	56	122240	1	60
+	57	122300	1	54 -- Rare Dragon Ruby
+	58	122310	1	180
+	59	122320	1	60
+	60	122330	1	3
+	61	122340	1	3
+	62	122400	1	54 -- Rare Dragon Ruby
+	63	122410	1	180
+	64	122420	1	60
+	65	122430	1	3
+	66	122440	1	3
+	67	123000	1	3888 -- Antique Dragon Ruby
+	68	123010	1	12960
+	69	123020	1	4320
+	70	123030	1	216
+	71	123040	1	216
+	72	123100	1	12960 -- Antique Dragon Ruby
+	73	123110	1	43200
+	74	123120	1	14400
+	75	123130	1	720
+	76	123140	1	720
+	77	123200	1	4320 -- Antique Dragon Ruby
+	78	123210	1	14400
+	79	123220	1	4800
+	80	123230	1	240
+	81	123240	1	240
+	82	123300	1	216 -- Antique Dragon Ruby
+	83	123310	1	720
+	84	123320	1	240
+	85	123330	1	12
+	86	123340	1	12
+	87	123400	1	216 -- Antique Dragon Ruby
+	88	123410	1	720
+	89	123420	1	240
+	90	123430	1	12
+	91	123440	1	12
+	92	124000	1	648 -- Legendary Dragon Ruby
+	93	124010	1	2160
+	94	124020	1	720
+	95	124030	1	36
+	96	124040	1	36
+	97	124100	1	2160 -- Legendary Dragon Ruby
+	98	124110	1	7200
+	99	124120	1	2400
+	100	124130	1	120
+	101	124140	1	120
+	102	124200	1	720 -- Legendary Dragon Ruby
+	103	124210	1	2400
+	104	124220	1	800
+	105	124230	1	40
+	106	124240	1	40
+	107	124300	1	36 -- Legendary Dragon Ruby
+	108	124310	1	120
+	109	124320	1	40
+	110	124330	1	2
+	111	124340	1	2
+	112	124400	1	36 -- Legendary Dragon Ruby
+	113	124410	1	120
+	114	124420	1	40
+	115	124430	1	2
+	116	124440	1	2
+}
+Group	풍麗肌혼_球-
+{
+	Vnum	51600 -- Cor Jadeit+ (Flawless)
+	1	130000	1	324 -- Rough Dragon Jade
+	2	130010	1	1080
+	3	130020	1	360
+	4	130100	1	1080 -- Rough Dragon Jade
+	5	130110	1	3600
+	6	130120	1	1200
+	7	130200	1	360 -- Rough Dragon Jade
+	8	130210	1	1200
+	9	130220	1	400
+	10	130230	1	20
+	11	130300	1	18 -- Rough Dragon Jade
+	12	130310	1	60
+	13	130320	1	20
+	14	130330	1	1
+	15	130400	1	18 -- Rough Dragon Jade
+	16	130410	1	60
+	17	130420	1	20
+	18	130430	1	1
+	19	130440	1	1
+	20	131000	1	648 -- Cut Dragon Jade
+	21	131010	1	2160
+	22	131020	1	720
+	23	131030	1	36
+	24	131100	1	2160 -- Cut Dragon Jade
+	25	131110	1	7200
+	26	131120	1	2400
+	27	131130	1	120
+	28	131200	1	720 -- Cut Dragon Jade
+	29	131210	1	2400
+	30	131220	1	800
+	31	131230	1	40
+	32	131300	1	36 -- Cut Dragon Jade
+	33	131310	1	120
+	34	131320	1	40
+	35	131330	1	2
+	36	131340	1	2
+	37	131400	1	36 -- Cut Dragon Jade
+	38	131410	1	120
+	39	131420	1	40
+	40	131430	1	2
+	41	131440	1	2
+	42	132000	1	972 -- Rare Dragon Jade
+	43	132010	1	3240
+	44	132020	1	1080
+	45	132030	1	54
+	46	132040	1	54
+	47	132100	1	3240 -- Rare Dragon Jade
+	48	132110	1	10800
+	49	132120	1	3600
+	50	132130	1	180
+	51	132140	1	180
+	52	132200	1	1080 -- Rare Dragon Jade
+	53	132210	1	3600
+	54	132220	1	1200
+	55	132230	1	60
+	56	132240	1	60
+	57	132300	1	54 -- Rare Dragon Jade
+	58	132310	1	180
+	59	132320	1	60
+	60	132330	1	3
+	61	132340	1	3
+	62	132400	1	54 -- Rare Dragon Jade
+	63	132410	1	180
+	64	132420	1	60
+	65	132430	1	3
+	66	132440	1	3
+	67	133000	1	3888 -- Antique Dragon Jade
+	68	133010	1	12960
+	69	133020	1	4320
+	70	133030	1	216
+	71	133040	1	216
+	72	133100	1	12960 -- Antique Dragon Jade
+	73	133110	1	43200
+	74	133120	1	14400
+	75	133130	1	720
+	76	133140	1	720
+	77	133200	1	4320 -- Antique Dragon Jade
+	78	133210	1	14400
+	79	133220	1	4800
+	80	133230	1	240
+	81	133240	1	240
+	82	133300	1	216 -- Antique Dragon Jade
+	83	133310	1	720
+	84	133320	1	240
+	85	133330	1	12
+	86	133340	1	12
+	87	133400	1	216 -- Antique Dragon Jade
+	88	133410	1	720
+	89	133420	1	240
+	90	133430	1	12
+	91	133440	1	12
+	92	134000	1	648 -- Legendary Dragon Jade
+	93	134010	1	2160
+	94	134020	1	720
+	95	134030	1	36
+	96	134040	1	36
+	97	134100	1	2160 -- Legendary Dragon Jade
+	98	134110	1	7200
+	99	134120	1	2400
+	100	134130	1	120
+	101	134140	1	120
+	102	134200	1	720 -- Legendary Dragon Jade
+	103	134210	1	2400
+	104	134220	1	800
+	105	134230	1	40
+	106	134240	1	40
+	107	134300	1	36 -- Legendary Dragon Jade
+	108	134310	1	120
+	109	134320	1	40
+	110	134330	1	2
+	111	134340	1	2
+	112	134400	1	36 -- Legendary Dragon Jade
+	113	134410	1	120
+	114	134420	1	40
+	115	134430	1	2
+	116	134440	1	2
+}
+Group	철麗肌혼_球-
+{
+	Vnum	51601 -- Cor Saphirum+ (Flawless)
+	1	140000	1	324 -- Rough Dragon Sapphire
+	2	140010	1	1080
+	3	140020	1	360
+	4	140100	1	1080 -- Rough Dragon Sapphire
+	5	140110	1	3600
+	6	140120	1	1200
+	7	140200	1	360 -- Rough Dragon Sapphire
+	8	140210	1	1200
+	9	140220	1	400
+	10	140230	1	20
+	11	140300	1	18 -- Rough Dragon Sapphire
+	12	140310	1	60
+	13	140320	1	20
+	14	140330	1	1
+	15	140400	1	18 -- Rough Dragon Sapphire
+	16	140410	1	60
+	17	140420	1	20
+	18	140430	1	1
+	19	140440	1	1
+	20	141000	1	648 -- Cut Dragon Sapphire
+	21	141010	1	2160
+	22	141020	1	720
+	23	141030	1	36
+	24	141100	1	2160 -- Cut Dragon Sapphire
+	25	141110	1	7200
+	26	141120	1	2400
+	27	141130	1	120
+	28	141200	1	720 -- Cut Dragon Sapphire
+	29	141210	1	2400
+	30	141220	1	800
+	31	141230	1	40
+	32	141300	1	36 -- Cut Dragon Sapphire
+	33	141310	1	120
+	34	141320	1	40
+	35	141330	1	2
+	36	141340	1	2
+	37	141400	1	36 -- Cut Dragon Sapphire
+	38	141410	1	120
+	39	141420	1	40
+	40	141430	1	2
+	41	141440	1	2
+	42	142000	1	972 -- Rare Dragon Sapphire
+	43	142010	1	3240
+	44	142020	1	1080
+	45	142030	1	54
+	46	142040	1	54
+	47	142100	1	3240 -- Rare Dragon Sapphire
+	48	142110	1	10800
+	49	142120	1	3600
+	50	142130	1	180
+	51	142140	1	180
+	52	142200	1	1080 -- Rare Dragon Sapphire
+	53	142210	1	3600
+	54	142220	1	1200
+	55	142230	1	60
+	56	142240	1	60
+	57	142300	1	54 -- Rare Dragon Sapphire
+	58	142310	1	180
+	59	142320	1	60
+	60	142330	1	3
+	61	142340	1	3
+	62	142400	1	54 -- Rare Dragon Sapphire
+	63	142410	1	180
+	64	142420	1	60
+	65	142430	1	3
+	66	142440	1	3
+	67	143000	1	3888 -- Antique Dragon Sapphire
+	68	143010	1	12960
+	69	143020	1	4320
+	70	143030	1	216
+	71	143040	1	216
+	72	143100	1	12960 -- Antique Dragon Sapphire
+	73	143110	1	43200
+	74	143120	1	14400
+	75	143130	1	720
+	76	143140	1	720
+	77	143200	1	4320 -- Antique Dragon Sapphire
+	78	143210	1	14400
+	79	143220	1	4800
+	80	143230	1	240
+	81	143240	1	240
+	82	143300	1	216 -- Antique Dragon Sapphire
+	83	143310	1	720
+	84	143320	1	240
+	85	143330	1	12
+	86	143340	1	12
+	87	143400	1	216 -- Antique Dragon Sapphire
+	88	143410	1	720
+	89	143420	1	240
+	90	143430	1	12
+	91	143440	1	12
+	92	144000	1	648 -- Legendary DragonSapphire
+	93	144010	1	2160
+	94	144020	1	720
+	95	144030	1	36
+	96	144040	1	36
+	97	144100	1	2160 -- Legendary DragonSapphire
+	98	144110	1	7200
+	99	144120	1	2400
+	100	144130	1	120
+	101	144140	1	120
+	102	144200	1	720 -- Legendary DragonSapphire
+	103	144210	1	2400
+	104	144220	1	800
+	105	144230	1	40
+	106	144240	1	40
+	107	144300	1	36 -- Legendary DragonSapphire
+	108	144310	1	120
+	109	144320	1	40
+	110	144330	1	2
+	111	144340	1	2
+	112	144400	1	36 -- Legendary DragonSapphire
+	113	144410	1	120
+	114	144420	1	40
+	115	144430	1	2
+	116	144440	1	2
+}
+Group	麗肌혼_球-
+{
+	Vnum	51602 -- Cor Granatum+ (Flawless)
+	1	150000	1	324 -- Rough Dragon Garnet
+	2	150010	1	1080
+	3	150020	1	360
+	4	150100	1	1080 -- Rough Dragon Garnet
+	5	150110	1	3600
+	6	150120	1	1200
+	7	150200	1	360 -- Rough Dragon Garnet
+	8	150210	1	1200
+	9	150220	1	400
+	10	150230	1	20
+	11	150300	1	18 -- Rough Dragon Garnet
+	12	150310	1	60
+	13	150320	1	20
+	14	150330	1	1
+	15	150400	1	18 -- Rough Dragon Garnet
+	16	150410	1	60
+	17	150420	1	20
+	18	150430	1	1
+	19	150440	1	1
+	20	151000	1	648 -- Cut Dragon Garnet
+	21	151010	1	2160
+	22	151020	1	720
+	23	151030	1	36
+	24	151100	1	2160 -- Cut Dragon Garnet
+	25	151110	1	7200
+	26	151120	1	2400
+	27	151130	1	120
+	28	151200	1	720 -- Cut Dragon Garnet
+	29	151210	1	2400
+	30	151220	1	800
+	31	151230	1	40
+	32	151300	1	36 -- Cut Dragon Garnet
+	33	151310	1	120
+	34	151320	1	40
+	35	151330	1	2
+	36	151340	1	2
+	37	151400	1	36 -- Cut Dragon Garnet
+	38	151410	1	120
+	39	151420	1	40
+	40	151430	1	2
+	41	151440	1	2
+	42	152000	1	972 -- Rare Dragon Garnet
+	43	152010	1	3240
+	44	152020	1	1080
+	45	152030	1	54
+	46	152040	1	54
+	47	152100	1	3240 -- Rare Dragon Garnet
+	48	152110	1	10800
+	49	152120	1	3600
+	50	152130	1	180
+	51	152140	1	180
+	52	152200	1	1080 -- Rare Dragon Garnet
+	53	152210	1	3600
+	54	152220	1	1200
+	55	152230	1	60
+	56	152240	1	60
+	57	152300	1	54 -- Rare Dragon Garnet
+	58	152310	1	180
+	59	152320	1	60
+	60	152330	1	3
+	61	152340	1	3
+	62	152400	1	54 -- Rare Dragon Garnet
+	63	152410	1	180
+	64	152420	1	60
+	65	152430	1	3
+	66	152440	1	3
+	67	153000	1	3888 -- Antique Dragon Garnet
+	68	153010	1	12960
+	69	153020	1	4320
+	70	153030	1	216
+	71	153040	1	216
+	72	153100	1	12960 -- Antique Dragon Garnet
+	73	153110	1	43200
+	74	153120	1	14400
+	75	153130	1	720
+	76	153140	1	720
+	77	153200	1	4320 -- Antique Dragon Garnet
+	78	153210	1	14400
+	79	153220	1	4800
+	80	153230	1	240
+	81	153240	1	240
+	82	153300	1	216 -- Antique Dragon Garnet
+	83	153310	1	720
+	84	153320	1	240
+	85	153330	1	12
+	86	153340	1	12
+	87	153400	1	216 -- Antique Dragon Garnet
+	88	153410	1	720
+	89	153420	1	240
+	90	153430	1	12
+	91	153440	1	12
+	92	154000	1	648 -- Legendary Dragon Garnet
+	93	154010	1	2160
+	94	154020	1	720
+	95	154030	1	36
+	96	154040	1	36
+	97	154100	1	2160 -- Legendary Dragon Garnet
+	98	154110	1	7200
+	99	154120	1	2400
+	100	154130	1	120
+	101	154140	1	120
+	102	154200	1	720 -- Legendary Dragon Garnet
+	103	154210	1	2400
+	104	154220	1	800
+	105	154230	1	40
+	106	154240	1	40
+	107	154300	1	36 -- Legendary Dragon Garnet
+	108	154310	1	120
+	109	154320	1	40
+	110	154330	1	2
+	111	154340	1	2
+	112	154400	1	36 -- Legendary Dragon Garnet
+	113	154410	1	120
+	114	154420	1	40
+	115	154430	1	2
+	116	154440	1	2
+}
+Group	麗肌혼_球-
+{
+	Vnum	51603 -- Cor Atrum+ (Flawless)
+	1	160000	1	324 -- Rough Dragon Onyx
+	2	160010	1	1080
+	3	160020	1	360
+	4	160100	1	1080 -- Rough Dragon Onyx
+	5	160110	1	3600
+	6	160120	1	1200
+	7	160200	1	360 -- Rough Dragon Onyx
+	8	160210	1	1200
+	9	160220	1	400
+	10	160230	1	20
+	11	160300	1	18 -- Rough Dragon Onyx
+	12	160310	1	60
+	13	160320	1	20
+	14	160330	1	1
+	15	160400	1	18 -- Rough Dragon Onyx
+	16	160410	1	60
+	17	160420	1	20
+	18	160430	1	1
+	19	160440	1	1
+	20	161000	1	648 -- Cut Dragon Onyx
+	21	161010	1	2160
+	22	161020	1	720
+	23	161030	1	36
+	24	161100	1	2160 -- Cut Dragon Onyx
+	25	161110	1	7200
+	26	161120	1	2400
+	27	161130	1	120
+	28	161200	1	720 -- Cut Dragon Onyx
+	29	161210	1	2400
+	30	161220	1	800
+	31	161230	1	40
+	32	161300	1	36 -- Cut Dragon Onyx
+	33	161310	1	120
+	34	161320	1	40
+	35	161330	1	2
+	36	161340	1	2
+	37	161400	1	36 -- Cut Dragon Onyx
+	38	161410	1	120
+	39	161420	1	40
+	40	161430	1	2
+	41	161440	1	2
+	42	162000	1	972 -- Rare Dragon Onyx
+	43	162010	1	3240
+	44	162020	1	1080
+	45	162030	1	54
+	46	162040	1	54
+	47	162100	1	3240 -- Rare Dragon Onyx
+	48	162110	1	10800
+	49	162120	1	3600
+	50	162130	1	180
+	51	162140	1	180
+	52	162200	1	1080 -- Rare Dragon Onyx
+	53	162210	1	3600
+	54	162220	1	1200
+	55	162230	1	60
+	56	162240	1	60
+	57	162300	1	54 -- Rare Dragon Onyx
+	58	162310	1	180
+	59	162320	1	60
+	60	162330	1	3
+	61	162340	1	3
+	62	162400	1	54 -- Rare Dragon Onyx
+	63	162410	1	180
+	64	162420	1	60
+	65	162430	1	3
+	66	162440	1	3
+	67	163000	1	3888 -- Antique Dragon Onyx
+	68	163010	1	12960
+	69	163020	1	4320
+	70	163030	1	216
+	71	163040	1	216
+	72	163100	1	12960 -- Antique Dragon Onyx
+	73	163110	1	43200
+	74	163120	1	14400
+	75	163130	1	720
+	76	163140	1	720
+	77	163200	1	4320 -- Antique Dragon Onyx
+	78	163210	1	14400
+	79	163220	1	4800
+	80	163230	1	240
+	81	163240	1	240
+	82	163300	1	216 -- Antique Dragon Onyx
+	83	163310	1	720
+	84	163320	1	240
+	85	163330	1	12
+	86	163340	1	12
+	87	163400	1	216 -- Antique Dragon Onyx
+	88	163410	1	720
+	89	163420	1	240
+	90	163430	1	12
+	91	163440	1	12
+	92	164000	1	648 -- Legendary Dragon Onyx
+	93	164010	1	2160
+	94	164020	1	720
+	95	164030	1	36
+	96	164040	1	36
+	97	164100	1	2160 -- Legendary Dragon Onyx
+	98	164110	1	7200
+	99	164120	1	2400
+	100	164130	1	120
+	101	164140	1	120
+	102	164200	1	720 -- Legendary Dragon Onyx
+	103	164210	1	2400
+	104	164220	1	800
+	105	164230	1	40
+	106	164240	1	40
+	107	164300	1	36 -- Legendary Dragon Onyx
+	108	164310	1	120
+	109	164320	1	40
+	110	164330	1	2
+	111	164340	1	2
+	112	164400	1	36 -- Legendary Dragon Onyx
+	113	164410	1	120
+	114	164420	1	40
+	115	164430	1	2
+	116	164440	1	2
+}
+Group	肌혼_화-
+{
+	Vnum	51604 -- Cor Draconis+ (Glowing)
+	1	111000	1	756 -- Cut Dragon Diamond
+	2	111010	1	2520
+	3	111020	1	840
+	4	111030	1	42
+	5	111100	1	2520 -- Cut Dragon Diamond
+	6	111110	1	8400
+	7	111120	1	2800
+	8	111130	1	140
+	9	111200	1	840 -- Cut Dragon Diamond
+	10	111210	1	2800
+	11	111220	1	933
+	12	111230	1	47
+	13	111300	1	42 -- Cut Dragon Diamond
+	14	111310	1	140
+	15	111320	1	47
+	16	111330	1	2
+	17	111340	1	2
+	18	111400	1	42 -- Cut Dragon Diamond
+	19	111410	1	140
+	20	111420	1	47
+	21	111430	1	2
+	22	111440	1	2
+	23	112000	1	324 -- Rare Dragon Diamond
+	24	112010	1	1080
+	25	112020	1	360
+	26	112030	1	18
+	27	112040	1	18
+	28	112100	1	1080 -- Rare Dragon Diamond
+	29	112110	1	3600
+	30	112120	1	1200
+	31	112130	1	60
+	32	112140	1	60
+	33	112200	1	360 -- Rare Dragon Diamond
+	34	112210	1	1200
+	35	112220	1	400
+	36	112230	1	20
+	37	112240	1	20
+	38	112300	1	18 -- Rare Dragon Diamond
+	39	112310	1	60
+	40	112320	1	20
+	41	112330	1	1
+	42	112340	1	1
+	43	112400	1	18 -- Rare Dragon Diamond
+	44	112410	1	60
+	45	112420	1	20
+	46	112430	1	1
+	47	112440	1	1
+	48	121000	1	756 -- Cut Dragon Ruby
+	49	121010	1	2520
+	50	121020	1	840
+	51	121030	1	42
+	52	121100	1	2520 -- Cut Dragon Ruby
+	53	121110	1	8400
+	54	121120	1	2800
+	55	121130	1	140
+	56	121200	1	840 -- Cut Dragon Ruby
+	57	121210	1	2800
+	58	121220	1	933
+	59	121230	1	47
+	60	121300	1	42 -- Cut Dragon Ruby
+	61	121310	1	140
+	62	121320	1	47
+	63	121330	1	2
+	64	121340	1	2
+	65	121400	1	42 -- Cut Dragon Ruby
+	66	121410	1	140
+	67	121420	1	47
+	68	121430	1	2
+	69	121440	1	2
+	70	122000	1	324 -- Rare Dragon Ruby
+	71	122010	1	1080
+	72	122020	1	360
+	73	122030	1	18
+	74	122040	1	18
+	75	122100	1	1080 -- Rare Dragon Ruby
+	76	122110	1	3600
+	77	122120	1	1200
+	78	122130	1	60
+	79	122140	1	60
+	80	122200	1	360 -- Rare Dragon Ruby
+	81	122210	1	1200
+	82	122220	1	400
+	83	122230	1	20
+	84	122240	1	20
+	85	122300	1	18 -- Rare Dragon Ruby
+	86	122310	1	60
+	87	122320	1	20
+	88	122330	1	1
+	89	122340	1	1
+	90	122400	1	18 -- Rare Dragon Ruby
+	91	122410	1	60
+	92	122420	1	20
+	93	122430	1	1
+	94	122440	1	1
+	95	131000	1	756 -- Cut Dragon Jade
+	96	131010	1	2520
+	97	131020	1	840
+	98	131030	1	42
+	99	131100	1	2520 -- Cut Dragon Jade
+	100	131110	1	8400
+	101	131120	1	2800
+	102	131130	1	140
+	103	131200	1	840 -- Cut Dragon Jade
+	104	131210	1	2800
+	105	131220	1	933
+	106	131230	1	47
+	107	131300	1	42 -- Cut Dragon Jade
+	108	131310	1	140
+	109	131320	1	47
+	110	131330	1	2
+	111	131340	1	2
+	112	131400	1	42 -- Cut Dragon Jade
+	113	131410	1	140
+	114	131420	1	47
+	115	131430	1	2
+	116	131440	1	2
+	117	132000	1	324 -- Rare Dragon Jade
+	118	132010	1	1080
+	119	132020	1	360
+	120	132030	1	18
+	121	132040	1	18
+	122	132100	1	1080 -- Rare Dragon Jade
+	123	132110	1	3600
+	124	132120	1	1200
+	125	132130	1	60
+	126	132140	1	60
+	127	132200	1	360 -- Rare Dragon Jade
+	128	132210	1	1200
+	129	132220	1	400
+	130	132230	1	20
+	131	132240	1	20
+	132	132300	1	18 -- Rare Dragon Jade
+	133	132310	1	60
+	134	132320	1	20
+	135	132330	1	1
+	136	132340	1	1
+	137	132400	1	18 -- Rare Dragon Jade
+	138	132410	1	60
+	139	132420	1	20
+	140	132430	1	1
+	141	132440	1	1
+	142	141000	1	756 -- Cut Dragon Sapphire
+	143	141010	1	2520
+	144	141020	1	840
+	145	141030	1	42
+	146	141100	1	2520 -- Cut Dragon Sapphire
+	147	141110	1	8400
+	148	141120	1	2800
+	149	141130	1	140
+	150	141200	1	840 -- Cut Dragon Sapphire
+	151	141210	1	2800
+	152	141220	1	933
+	153	141230	1	47
+	154	141300	1	42 -- Cut Dragon Sapphire
+	155	141310	1	140
+	156	141320	1	47
+	157	141330	1	2
+	158	141340	1	2
+	159	141400	1	42 -- Cut Dragon Sapphire
+	160	141410	1	140
+	161	141420	1	47
+	162	141430	1	2
+	163	141440	1	2
+	164	142000	1	324 -- Rare Dragon Sapphire
+	165	142010	1	1080
+	166	142020	1	360
+	167	142030	1	18
+	168	142040	1	18
+	169	142100	1	1080 -- Rare Dragon Sapphire
+	170	142110	1	3600
+	171	142120	1	1200
+	172	142130	1	60
+	173	142140	1	60
+	174	142200	1	360 -- Rare Dragon Sapphire
+	175	142210	1	1200
+	176	142220	1	400
+	177	142230	1	20
+	178	142240	1	20
+	179	142300	1	18 -- Rare Dragon Sapphire
+	180	142310	1	60
+	181	142320	1	20
+	182	142330	1	1
+	183	142340	1	1
+	184	142400	1	18 -- Rare Dragon Sapphire
+	185	142410	1	60
+	186	142420	1	20
+	187	142430	1	1
+	188	142440	1	1
+	189	151000	1	756 -- Cut Dragon Garnet
+	190	151010	1	2520
+	191	151020	1	840
+	192	151030	1	42
+	193	151100	1	2520 -- Cut Dragon Garnet
+	194	151110	1	8400
+	195	151120	1	2800
+	196	151130	1	140
+	197	151200	1	840 -- Cut Dragon Garnet
+	198	151210	1	2800
+	199	151220	1	933
+	200	151230	1	47
+	201	151300	1	42 -- Cut Dragon Garnet
+	202	151310	1	140
+	203	151320	1	47
+	204	151330	1	2
+	205	151340	1	2
+	206	151400	1	42 -- Cut Dragon Garnet
+	207	151410	1	140
+	208	151420	1	47
+	209	151430	1	2
+	210	151440	1	2
+	211	152000	1	324 -- Rare Dragon Garnet
+	212	152010	1	1080
+	213	152020	1	360
+	214	152030	1	18
+	215	152040	1	18
+	216	152100	1	1080 -- Rare Dragon Garnet
+	217	152110	1	3600
+	218	152120	1	1200
+	219	152130	1	60
+	220	152140	1	60
+	221	152200	1	360 -- Rare Dragon Garnet
+	222	152210	1	1200
+	223	152220	1	400
+	224	152230	1	20
+	225	152240	1	20
+	226	152300	1	18 -- Rare Dragon Garnet
+	227	152310	1	60
+	228	152320	1	20
+	229	152330	1	1
+	230	152340	1	1
+	231	152400	1	18 -- Rare Dragon Garnet
+	232	152410	1	60
+	233	152420	1	20
+	234	152430	1	1
+	235	152440	1	1
+	236	161000	1	756 -- Cut Dragon Onyx
+	237	161010	1	2520
+	238	161020	1	840
+	239	161030	1	42
+	240	161100	1	2520 -- Cut Dragon Onyx
+	241	161110	1	8400
+	242	161120	1	2800
+	243	161130	1	140
+	244	161200	1	840 -- Cut Dragon Onyx
+	245	161210	1	2800
+	246	161220	1	933
+	247	161230	1	47
+	248	161300	1	42 -- Cut Dragon Onyx
+	249	161310	1	140
+	250	161320	1	47
+	251	161330	1	2
+	252	161340	1	2
+	253	161400	1	42 -- Cut Dragon Onyx
+	254	161410	1	140
+	255	161420	1	47
+	256	161430	1	2
+	257	161440	1	2
+	258	162000	1	324 -- Rare Dragon Onyx
+	259	162010	1	1080
+	260	162020	1	360
+	261	162030	1	18
+	262	162040	1	18
+	263	162100	1	1080 -- Rare Dragon Onyx
+	264	162110	1	3600
+	265	162120	1	1200
+	266	162130	1	60
+	267	162140	1	60
+	268	162200	1	360 -- Rare Dragon Onyx
+	269	162210	1	1200
+	270	162220	1	400
+	271	162230	1	20
+	272	162240	1	20
+	273	162300	1	18 -- Rare Dragon Onyx
+	274	162310	1	60
+	275	162320	1	20
+	276	162330	1	1
+	277	162340	1	1
+	278	162400	1	18 -- Rare Dragon Onyx
+	279	162410	1	60
+	280	162420	1	20
+	281	162430	1	1
+	282	162440	1	1
+}
+Group	麗肌혼_화-
+{
+	Vnum	51605 -- Cor Diamas+ (Glowing)
+	1	111000	1	756 -- Cut Dragon Diamond
+	2	111010	1	2520
+	3	111020	1	840
+	4	111030	1	42
+	5	111100	1	2520 -- Cut Dragon Diamond
+	6	111110	1	8400
+	7	111120	1	2800
+	8	111130	1	140
+	9	111200	1	840 -- Cut Dragon Diamond
+	10	111210	1	2800
+	11	111220	1	933
+	12	111230	1	47
+	13	111300	1	42 -- Cut Dragon Diamond
+	14	111310	1	140
+	15	111320	1	47
+	16	111330	1	2
+	17	111340	1	2
+	18	111400	1	42 -- Cut Dragon Diamond
+	19	111410	1	140
+	20	111420	1	47
+	21	111430	1	2
+	22	111440	1	2
+	23	112000	1	324 -- Rare Dragon Diamond
+	24	112010	1	1080
+	25	112020	1	360
+	26	112030	1	18
+	27	112040	1	18
+	28	112100	1	1080 -- Rare Dragon Diamond
+	29	112110	1	3600
+	30	112120	1	1200
+	31	112130	1	60
+	32	112140	1	60
+	33	112200	1	360 -- Rare Dragon Diamond
+	34	112210	1	1200
+	35	112220	1	400
+	36	112230	1	20
+	37	112240	1	20
+	38	112300	1	18 -- Rare Dragon Diamond
+	39	112310	1	60
+	40	112320	1	20
+	41	112330	1	1
+	42	112340	1	1
+	43	112400	1	18 -- Rare Dragon Diamond
+	44	112410	1	60
+	45	112420	1	20
+	46	112430	1	1
+	47	112440	1	1
+}
+Group	화麗肌혼_화-
+{
+	Vnum	51606 -- Cor Rubinum+ (Glowing)
+	1	121000	1	756 -- Cut Dragon Ruby
+	2	121010	1	2520
+	3	121020	1	840
+	4	121030	1	42
+	5	121100	1	2520 -- Cut Dragon Ruby
+	6	121110	1	8400
+	7	121120	1	2800
+	8	121130	1	140
+	9	121200	1	840 -- Cut Dragon Ruby
+	10	121210	1	2800
+	11	121220	1	933
+	12	121230	1	47
+	13	121300	1	42 -- Cut Dragon Ruby
+	14	121310	1	140
+	15	121320	1	47
+	16	121330	1	2
+	17	121340	1	2
+	18	121400	1	42 -- Cut Dragon Ruby
+	19	121410	1	140
+	20	121420	1	47
+	21	121430	1	2
+	22	121440	1	2
+	23	122000	1	324 -- Rare Dragon Ruby
+	24	122010	1	1080
+	25	122020	1	360
+	26	122030	1	18
+	27	122040	1	18
+	28	122100	1	1080 -- Rare Dragon Ruby
+	29	122110	1	3600
+	30	122120	1	1200
+	31	122130	1	60
+	32	122140	1	60
+	33	122200	1	360 -- Rare Dragon Ruby
+	34	122210	1	1200
+	35	122220	1	400
+	36	122230	1	20
+	37	122240	1	20
+	38	122300	1	18 -- Rare Dragon Ruby
+	39	122310	1	60
+	40	122320	1	20
+	41	122330	1	1
+	42	122340	1	1
+	43	122400	1	18 -- Rare Dragon Ruby
+	44	122410	1	60
+	45	122420	1	20
+	46	122430	1	1
+	47	122440	1	1
+}
+Group	풍麗肌혼_화-
+{
+	Vnum	51607 -- Cor Jadeit+ (Glowing)
+	1	131000	1	756 -- Cut Dragon Jade
+	2	131010	1	2520
+	3	131020	1	840
+	4	131030	1	42
+	5	131100	1	2520 -- Cut Dragon Jade
+	6	131110	1	8400
+	7	131120	1	2800
+	8	131130	1	140
+	9	131200	1	840 -- Cut Dragon Jade
+	10	131210	1	2800
+	11	131220	1	933
+	12	131230	1	47
+	13	131300	1	42 -- Cut Dragon Jade
+	14	131310	1	140
+	15	131320	1	47
+	16	131330	1	2
+	17	131340	1	2
+	18	131400	1	42 -- Cut Dragon Jade
+	19	131410	1	140
+	20	131420	1	47
+	21	131430	1	2
+	22	131440	1	2
+	23	132000	1	324 -- Rare Dragon Jade
+	24	132010	1	1080
+	25	132020	1	360
+	26	132030	1	18
+	27	132040	1	18
+	28	132100	1	1080 -- Rare Dragon Jade
+	29	132110	1	3600
+	30	132120	1	1200
+	31	132130	1	60
+	32	132140	1	60
+	33	132200	1	360 -- Rare Dragon Jade
+	34	132210	1	1200
+	35	132220	1	400
+	36	132230	1	20
+	37	132240	1	20
+	38	132300	1	18 -- Rare Dragon Jade
+	39	132310	1	60
+	40	132320	1	20
+	41	132330	1	1
+	42	132340	1	1
+	43	132400	1	18 -- Rare Dragon Jade
+	44	132410	1	60
+	45	132420	1	20
+	46	132430	1	1
+	47	132440	1	1
+}
+Group	철麗肌혼_화-
+{
+	Vnum	51608 -- Cor Saphirum+ (Glowing)
+	1	141000	1	756 -- Cut Dragon Sapphire
+	2	141010	1	2520
+	3	141020	1	840
+	4	141030	1	42
+	5	141100	1	2520 -- Cut Dragon Sapphire
+	6	141110	1	8400
+	7	141120	1	2800
+	8	141130	1	140
+	9	141200	1	840 -- Cut Dragon Sapphire
+	10	141210	1	2800
+	11	141220	1	933
+	12	141230	1	47
+	13	141300	1	42 -- Cut Dragon Sapphire
+	14	141310	1	140
+	15	141320	1	47
+	16	141330	1	2
+	17	141340	1	2
+	18	141400	1	42 -- Cut Dragon Sapphire
+	19	141410	1	140
+	20	141420	1	47
+	21	141430	1	2
+	22	141440	1	2
+	23	142000	1	324 -- Rare Dragon Sapphire
+	24	142010	1	1080
+	25	142020	1	360
+	26	142030	1	18
+	27	142040	1	18
+	28	142100	1	1080 -- Rare Dragon Sapphire
+	29	142110	1	3600
+	30	142120	1	1200
+	31	142130	1	60
+	32	142140	1	60
+	33	142200	1	360 -- Rare Dragon Sapphire
+	34	142210	1	1200
+	35	142220	1	400
+	36	142230	1	20
+	37	142240	1	20
+	38	142300	1	18 -- Rare Dragon Sapphire
+	39	142310	1	60
+	40	142320	1	20
+	41	142330	1	1
+	42	142340	1	1
+	43	142400	1	18 -- Rare Dragon Sapphire
+	44	142410	1	60
+	45	142420	1	20
+	46	142430	1	1
+	47	142440	1	1
+}
+Group	麗肌혼_화-
+{
+	Vnum	51609 -- Cor Granatum+ (Glowing)
+	1	151000	1	756 -- Cut Dragon Garnet
+	2	151010	1	2520
+	3	151020	1	840
+	4	151030	1	42
+	5	151100	1	2520 -- Cut Dragon Garnet
+	6	151110	1	8400
+	7	151120	1	2800
+	8	151130	1	140
+	9	151200	1	840 -- Cut Dragon Garnet
+	10	151210	1	2800
+	11	151220	1	933
+	12	151230	1	47
+	13	151300	1	42 -- Cut Dragon Garnet
+	14	151310	1	140
+	15	151320	1	47
+	16	151330	1	2
+	17	151340	1	2
+	18	151400	1	42 -- Cut Dragon Garnet
+	19	151410	1	140
+	20	151420	1	47
+	21	151430	1	2
+	22	151440	1	2
+	23	152000	1	324 -- Rare Dragon Garnet
+	24	152010	1	1080
+	25	152020	1	360
+	26	152030	1	18
+	27	152040	1	18
+	28	152100	1	1080 -- Rare Dragon Garnet
+	29	152110	1	3600
+	30	152120	1	1200
+	31	152130	1	60
+	32	152140	1	60
+	33	152200	1	360 -- Rare Dragon Garnet
+	34	152210	1	1200
+	35	152220	1	400
+	36	152230	1	20
+	37	152240	1	20
+	38	152300	1	18 -- Rare Dragon Garnet
+	39	152310	1	60
+	40	152320	1	20
+	41	152330	1	1
+	42	152340	1	1
+	43	152400	1	18 -- Rare Dragon Garnet
+	44	152410	1	60
+	45	152420	1	20
+	46	152430	1	1
+	47	152440	1	1
+}
+Group	麗肌혼_화-
+{
+	Vnum	51610 -- Cor Atrum+ (Glowing)
+	1	161000	1	756 -- Cut Dragon Onyx
+	2	161010	1	2520
+	3	161020	1	840
+	4	161030	1	42
+	5	161100	1	2520 -- Cut Dragon Onyx
+	6	161110	1	8400
+	7	161120	1	2800
+	8	161130	1	140
+	9	161200	1	840 -- Cut Dragon Onyx
+	10	161210	1	2800
+	11	161220	1	933
+	12	161230	1	47
+	13	161300	1	42 -- Cut Dragon Onyx
+	14	161310	1	140
+	15	161320	1	47
+	16	161330	1	2
+	17	161340	1	2
+	18	161400	1	42 -- Cut Dragon Onyx
+	19	161410	1	140
+	20	161420	1	47
+	21	161430	1	2
+	22	161440	1	2
+	23	162000	1	324 -- Rare Dragon Onyx
+	24	162010	1	1080
+	25	162020	1	360
+	26	162030	1	18
+	27	162040	1	18
+	28	162100	1	1080 -- Rare Dragon Onyx
+	29	162110	1	3600
+	30	162120	1	1200
+	31	162130	1	60
+	32	162140	1	60
+	33	162200	1	360 -- Rare Dragon Onyx
+	34	162210	1	1200
+	35	162220	1	400
+	36	162230	1	20
+	37	162240	1	20
+	38	162300	1	18 -- Rare Dragon Onyx
+	39	162310	1	60
+	40	162320	1	20
+	41	162330	1	1
+	42	162340	1	1
+	43	162400	1	18 -- Rare Dragon Onyx
+	44	162410	1	60
+	45	162420	1	20
+	46	162430	1	1
+	47	162440	1	1
+}
+Group	肌혼_화-
+{
+	Vnum	51611 -- Cor Draconis+ (Eternal)
+	1	111000	1	972 -- Cut Dragon Diamond
+	2	111010	1	3240
+	3	111020	1	1080
+	4	111030	1	54
+	5	111100	1	3240 -- Cut Dragon Diamond
+	6	111110	1	10800
+	7	111120	1	3600
+	8	111130	1	180
+	9	111200	1	1080 -- Cut Dragon Diamond
+	10	111210	1	3600
+	11	111220	1	1200
+	12	111230	1	60
+	13	111300	1	54 -- Cut Dragon Diamond
+	14	111310	1	180
+	15	111320	1	60
+	16	111330	1	3
+	17	111340	1	3
+	18	111400	1	54 -- Cut Dragon Diamond
+	19	111410	1	180
+	20	111420	1	60
+	21	111430	1	3
+	22	111440	1	3
+	23	112000	1	1944 -- Rare Dragon Diamond
+	24	112010	1	6480
+	25	112020	1	2160
+	26	112030	1	108
+	27	112040	1	108
+	28	112100	1	6480 -- Rare Dragon Diamond
+	29	112110	1	21600
+	30	112120	1	7200
+	31	112130	1	360
+	32	112140	1	360
+	33	112200	1	2160 -- Rare Dragon Diamond
+	34	112210	1	7200
+	35	112220	1	2400
+	36	112230	1	120
+	37	112240	1	120
+	38	112300	1	108 -- Rare Dragon Diamond
+	39	112310	1	360
+	40	112320	1	120
+	41	112330	1	6
+	42	112340	1	6
+	43	112400	1	108 -- Rare Dragon Diamond
+	44	112410	1	360
+	45	112420	1	120
+	46	112430	1	6
+	47	112440	1	6
+	48	113000	1	324 -- Antique Dragon Diamond
+	49	113010	1	1080
+	50	113020	1	360
+	51	113030	1	18
+	52	113040	1	18
+	53	113100	1	1080 -- Antique Dragon Diamond
+	54	113110	1	3600
+	55	113120	1	1200
+	56	113130	1	60
+	57	113140	1	60
+	58	113200	1	360 -- Antique Dragon Diamond
+	59	113210	1	1200
+	60	113220	1	400
+	61	113230	1	20
+	62	113240	1	20
+	63	113300	1	18 -- Antique Dragon Diamond
+	64	113310	1	60
+	65	113320	1	20
+	66	113330	1	1
+	67	113340	1	1
+	68	113400	1	18 -- Antique Dragon Diamond
+	69	113410	1	60
+	70	113420	1	20
+	71	113430	1	1
+	72	113440	1	1
+	73	121000	1	972 -- Cut Dragon Ruby
+	74	121010	1	3240
+	75	121020	1	1080
+	76	121030	1	54
+	77	121100	1	3240 -- Cut Dragon Ruby
+	78	121110	1	10800
+	79	121120	1	3600
+	80	121130	1	180
+	81	121200	1	1080 -- Cut Dragon Ruby
+	82	121210	1	3600
+	83	121220	1	1200
+	84	121230	1	60
+	85	121300	1	54 -- Cut Dragon Ruby
+	86	121310	1	180
+	87	121320	1	60
+	88	121330	1	3
+	89	121340	1	3
+	90	121400	1	54 -- Cut Dragon Ruby
+	91	121410	1	180
+	92	121420	1	60
+	93	121430	1	3
+	94	121440	1	3
+	95	122000	1	1944 -- Rare Dragon Ruby
+	96	122010	1	6480
+	97	122020	1	2160
+	98	122030	1	108
+	99	122040	1	108
+	100	122100	1	6480 -- Rare Dragon Ruby
+	101	122110	1	21600
+	102	122120	1	7200
+	103	122130	1	360
+	104	122140	1	360
+	105	122200	1	2160 -- Rare Dragon Ruby
+	106	122210	1	7200
+	107	122220	1	2400
+	108	122230	1	120
+	109	122240	1	120
+	110	122300	1	108 -- Rare Dragon Ruby
+	111	122310	1	360
+	112	122320	1	120
+	113	122330	1	6
+	114	122340	1	6
+	115	122400	1	108 -- Rare Dragon Ruby
+	116	122410	1	360
+	117	122420	1	120
+	118	122430	1	6
+	119	122440	1	6
+	120	123000	1	324 -- Antique Dragon Ruby
+	121	123010	1	1080
+	122	123020	1	360
+	123	123030	1	18
+	124	123040	1	18
+	125	123100	1	1080 -- Antique Dragon Ruby
+	126	123110	1	3600
+	127	123120	1	1200
+	128	123130	1	60
+	129	123140	1	60
+	130	123200	1	360 -- Antique Dragon Ruby
+	131	123210	1	1200
+	132	123220	1	400
+	133	123230	1	20
+	134	123240	1	20
+	135	123300	1	18 -- Antique Dragon Ruby
+	136	123310	1	60
+	137	123320	1	20
+	138	123330	1	1
+	139	123340	1	1
+	140	123400	1	18 -- Antique Dragon Ruby
+	141	123410	1	60
+	142	123420	1	20
+	143	123430	1	1
+	144	123440	1	1
+	145	131000	1	972 -- Cut Dragon Jade
+	146	131010	1	3240
+	147	131020	1	1080
+	148	131030	1	54
+	149	131100	1	3240 -- Cut Dragon Jade
+	150	131110	1	10800
+	151	131120	1	3600
+	152	131130	1	180
+	153	131200	1	1080 -- Cut Dragon Jade
+	154	131210	1	3600
+	155	131220	1	1200
+	156	131230	1	60
+	157	131300	1	54 -- Cut Dragon Jade
+	158	131310	1	180
+	159	131320	1	60
+	160	131330	1	3
+	161	131340	1	3
+	162	131400	1	54 -- Cut Dragon Jade
+	163	131410	1	180
+	164	131420	1	60
+	165	131430	1	3
+	166	131440	1	3
+	167	132000	1	1944 -- Rare Dragon Jade
+	168	132010	1	6480
+	169	132020	1	2160
+	170	132030	1	108
+	171	132040	1	108
+	172	132100	1	6480 -- Rare Dragon Jade
+	173	132110	1	21600
+	174	132120	1	7200
+	175	132130	1	360
+	176	132140	1	360
+	177	132200	1	2160 -- Rare Dragon Jade
+	178	132210	1	7200
+	179	132220	1	2400
+	180	132230	1	120
+	181	132240	1	120
+	182	132300	1	108 -- Rare Dragon Jade
+	183	132310	1	360
+	184	132320	1	120
+	185	132330	1	6
+	186	132340	1	6
+	187	132400	1	108 -- Rare Dragon Jade
+	188	132410	1	360
+	189	132420	1	120
+	190	132430	1	6
+	191	132440	1	6
+	192	133000	1	324 -- Antique Dragon Jade
+	193	133010	1	1080
+	194	133020	1	360
+	195	133030	1	18
+	196	133040	1	18
+	197	133100	1	1080 -- Antique Dragon Jade
+	198	133110	1	3600
+	199	133120	1	1200
+	200	133130	1	60
+	201	133140	1	60
+	202	133200	1	360 -- Antique Dragon Jade
+	203	133210	1	1200
+	204	133220	1	400
+	205	133230	1	20
+	206	133240	1	20
+	207	133300	1	18 -- Antique Dragon Jade
+	208	133310	1	60
+	209	133320	1	20
+	210	133330	1	1
+	211	133340	1	1
+	212	133400	1	18 -- Antique Dragon Jade
+	213	133410	1	60
+	214	133420	1	20
+	215	133430	1	1
+	216	133440	1	1
+	217	141000	1	972 -- Cut Dragon Sapphire
+	218	141010	1	3240
+	219	141020	1	1080
+	220	141030	1	54
+	221	141100	1	3240 -- Cut Dragon Sapphire
+	222	141110	1	10800
+	223	141120	1	3600
+	224	141130	1	180
+	225	141200	1	1080 -- Cut Dragon Sapphire
+	226	141210	1	3600
+	227	141220	1	1200
+	228	141230	1	60
+	229	141300	1	54 -- Cut Dragon Sapphire
+	230	141310	1	180
+	231	141320	1	60
+	232	141330	1	3
+	233	141340	1	3
+	234	141400	1	54 -- Cut Dragon Sapphire
+	235	141410	1	180
+	236	141420	1	60
+	237	141430	1	3
+	238	141440	1	3
+	239	142000	1	1944 -- Rare Dragon Sapphire
+	240	142010	1	6480
+	241	142020	1	2160
+	242	142030	1	108
+	243	142040	1	108
+	244	142100	1	6480 -- Rare Dragon Sapphire
+	245	142110	1	21600
+	246	142120	1	7200
+	247	142130	1	360
+	248	142140	1	360
+	249	142200	1	2160 -- Rare Dragon Sapphire
+	250	142210	1	7200
+	251	142220	1	2400
+	252	142230	1	120
+	253	142240	1	120
+	254	142300	1	108 -- Rare Dragon Sapphire
+	255	142310	1	360
+	256	142320	1	120
+	257	142330	1	6
+	258	142340	1	6
+	259	142400	1	108 -- Rare Dragon Sapphire
+	260	142410	1	360
+	261	142420	1	120
+	262	142430	1	6
+	263	142440	1	6
+	264	143000	1	324 -- Antique Dragon Sapphire
+	265	143010	1	1080
+	266	143020	1	360
+	267	143030	1	18
+	268	143040	1	18
+	269	143100	1	1080 -- Antique Dragon Sapphire
+	270	143110	1	3600
+	271	143120	1	1200
+	272	143130	1	60
+	273	143140	1	60
+	274	143200	1	360 -- Antique Dragon Sapphire
+	275	143210	1	1200
+	276	143220	1	400
+	277	143230	1	20
+	278	143240	1	20
+	279	143300	1	18 -- Antique Dragon Sapphire
+	280	143310	1	60
+	281	143320	1	20
+	282	143330	1	1
+	283	143340	1	1
+	284	143400	1	18 -- Antique Dragon Sapphire
+	285	143410	1	60
+	286	143420	1	20
+	287	143430	1	1
+	288	143440	1	1
+	289	151000	1	972 -- Cut Dragon Garnet
+	290	151010	1	3240
+	291	151020	1	1080
+	292	151030	1	54
+	293	151100	1	3240 -- Cut Dragon Garnet
+	294	151110	1	10800
+	295	151120	1	3600
+	296	151130	1	180
+	297	151200	1	1080 -- Cut Dragon Garnet
+	298	151210	1	3600
+	299	151220	1	1200
+	300	151230	1	60
+	301	151300	1	54 -- Cut Dragon Garnet
+	302	151310	1	180
+	303	151320	1	60
+	304	151330	1	3
+	305	151340	1	3
+	306	151400	1	54 -- Cut Dragon Garnet
+	307	151410	1	180
+	308	151420	1	60
+	309	151430	1	3
+	310	151440	1	3
+	311	152000	1	1944 -- Rare Dragon Garnet
+	312	152010	1	6480
+	313	152020	1	2160
+	314	152030	1	108
+	315	152040	1	108
+	316	152100	1	6480 -- Rare Dragon Garnet
+	317	152110	1	21600
+	318	152120	1	7200
+	319	152130	1	360
+	320	152140	1	360
+	321	152200	1	2160 -- Rare Dragon Garnet
+	322	152210	1	7200
+	323	152220	1	2400
+	324	152230	1	120
+	325	152240	1	120
+	326	152300	1	108 -- Rare Dragon Garnet
+	327	152310	1	360
+	328	152320	1	120
+	329	152330	1	6
+	330	152340	1	6
+	331	152400	1	108 -- Rare Dragon Garnet
+	332	152410	1	360
+	333	152420	1	120
+	334	152430	1	6
+	335	152440	1	6
+	336	153000	1	324 -- Antique Dragon Garnet
+	337	153010	1	1080
+	338	153020	1	360
+	339	153030	1	18
+	340	153040	1	18
+	341	153100	1	1080 -- Antique Dragon Garnet
+	342	153110	1	3600
+	343	153120	1	1200
+	344	153130	1	60
+	345	153140	1	60
+	346	153200	1	360 -- Antique Dragon Garnet
+	347	153210	1	1200
+	348	153220	1	400
+	349	153230	1	20
+	350	153240	1	20
+	351	153300	1	18 -- Antique Dragon Garnet
+	352	153310	1	60
+	353	153320	1	20
+	354	153330	1	1
+	355	153340	1	1
+	356	153400	1	18 -- Antique Dragon Garnet
+	357	153410	1	60
+	358	153420	1	20
+	359	153430	1	1
+	360	153440	1	1
+	361	161000	1	972 -- Cut Dragon Onyx
+	362	161010	1	3240
+	363	161020	1	1080
+	364	161030	1	54
+	365	161100	1	3240 -- Cut Dragon Onyx
+	366	161110	1	10800
+	367	161120	1	3600
+	368	161130	1	180
+	369	161200	1	1080 -- Cut Dragon Onyx
+	370	161210	1	3600
+	371	161220	1	1200
+	372	161230	1	60
+	373	161300	1	54 -- Cut Dragon Onyx
+	374	161310	1	180
+	375	161320	1	60
+	376	161330	1	3
+	377	161340	1	3
+	378	161400	1	54 -- Cut Dragon Onyx
+	379	161410	1	180
+	380	161420	1	60
+	381	161430	1	3
+	382	161440	1	3
+	383	162000	1	1944 -- Rare Dragon Onyx
+	384	162010	1	6480
+	385	162020	1	2160
+	386	162030	1	108
+	387	162040	1	108
+	388	162100	1	6480 -- Rare Dragon Onyx
+	389	162110	1	21600
+	390	162120	1	7200
+	391	162130	1	360
+	392	162140	1	360
+	393	162200	1	2160 -- Rare Dragon Onyx
+	394	162210	1	7200
+	395	162220	1	2400
+	396	162230	1	120
+	397	162240	1	120
+	398	162300	1	108 -- Rare Dragon Onyx
+	399	162310	1	360
+	400	162320	1	120
+	401	162330	1	6
+	402	162340	1	6
+	403	162400	1	108 -- Rare Dragon Onyx
+	404	162410	1	360
+	405	162420	1	120
+	406	162430	1	6
+	407	162440	1	6
+	408	163000	1	324 -- Antique Dragon Onyx
+	409	163010	1	1080
+	410	163020	1	360
+	411	163030	1	18
+	412	163040	1	18
+	413	163100	1	1080 -- Antique Dragon Onyx
+	414	163110	1	3600
+	415	163120	1	1200
+	416	163130	1	60
+	417	163140	1	60
+	418	163200	1	360 -- Antique Dragon Onyx
+	419	163210	1	1200
+	420	163220	1	400
+	421	163230	1	20
+	422	163240	1	20
+	423	163300	1	18 -- Antique Dragon Onyx
+	424	163310	1	60
+	425	163320	1	20
+	426	163330	1	1
+	427	163340	1	1
+	428	163400	1	18 -- Antique Dragon Onyx
+	429	163410	1	60
+	430	163420	1	20
+	431	163430	1	1
+	432	163440	1	1
+}
+Group	麗肌혼_화-
+{
+	Vnum	51612 -- Cor Diamas+ (Eternal)
+	1	111000	1	972 -- Cut Dragon Diamond
+	2	111010	1	3240
+	3	111020	1	1080
+	4	111030	1	54
+	5	111100	1	3240 -- Cut Dragon Diamond
+	6	111110	1	10800
+	7	111120	1	3600
+	8	111130	1	180
+	9	111200	1	1080 -- Cut Dragon Diamond
+	10	111210	1	3600
+	11	111220	1	1200
+	12	111230	1	60
+	13	111300	1	54 -- Cut Dragon Diamond
+	14	111310	1	180
+	15	111320	1	60
+	16	111330	1	3
+	17	111340	1	3
+	18	111400	1	54 -- Cut Dragon Diamond
+	19	111410	1	180
+	20	111420	1	60
+	21	111430	1	3
+	22	111440	1	3
+	23	112000	1	1944 -- Rare Dragon Diamond
+	24	112010	1	6480
+	25	112020	1	2160
+	26	112030	1	108
+	27	112040	1	108
+	28	112100	1	6480 -- Rare Dragon Diamond
+	29	112110	1	21600
+	30	112120	1	7200
+	31	112130	1	360
+	32	112140	1	360
+	33	112200	1	2160 -- Rare Dragon Diamond
+	34	112210	1	7200
+	35	112220	1	2400
+	36	112230	1	120
+	37	112240	1	120
+	38	112300	1	108 -- Rare Dragon Diamond
+	39	112310	1	360
+	40	112320	1	120
+	41	112330	1	6
+	42	112340	1	6
+	43	112400	1	108 -- Rare Dragon Diamond
+	44	112410	1	360
+	45	112420	1	120
+	46	112430	1	6
+	47	112440	1	6
+	48	113000	1	324 -- Antique Dragon Diamond
+	49	113010	1	1080
+	50	113020	1	360
+	51	113030	1	18
+	52	113040	1	18
+	53	113100	1	1080 -- Antique Dragon Diamond
+	54	113110	1	3600
+	55	113120	1	1200
+	56	113130	1	60
+	57	113140	1	60
+	58	113200	1	360 -- Antique Dragon Diamond
+	59	113210	1	1200
+	60	113220	1	400
+	61	113230	1	20
+	62	113240	1	20
+	63	113300	1	18 -- Antique Dragon Diamond
+	64	113310	1	60
+	65	113320	1	20
+	66	113330	1	1
+	67	113340	1	1
+	68	113400	1	18 -- Antique Dragon Diamond
+	69	113410	1	60
+	70	113420	1	20
+	71	113430	1	1
+	72	113440	1	1
+}
+Group	화麗肌혼_화-
+{
+	Vnum	51613 -- Cor Rubinum+ (Eternal)
+	1	121000	1	972 -- Cut Dragon Ruby
+	2	121010	1	3240
+	3	121020	1	1080
+	4	121030	1	54
+	5	121100	1	3240 -- Cut Dragon Ruby
+	6	121110	1	10800
+	7	121120	1	3600
+	8	121130	1	180
+	9	121200	1	1080 -- Cut Dragon Ruby
+	10	121210	1	3600
+	11	121220	1	1200
+	12	121230	1	60
+	13	121300	1	54 -- Cut Dragon Ruby
+	14	121310	1	180
+	15	121320	1	60
+	16	121330	1	3
+	17	121340	1	3
+	18	121400	1	54 -- Cut Dragon Ruby
+	19	121410	1	180
+	20	121420	1	60
+	21	121430	1	3
+	22	121440	1	3
+	23	122000	1	1944 -- Rare Dragon Ruby
+	24	122010	1	6480
+	25	122020	1	2160
+	26	122030	1	108
+	27	122040	1	108
+	28	122100	1	6480 -- Rare Dragon Ruby
+	29	122110	1	21600
+	30	122120	1	7200
+	31	122130	1	360
+	32	122140	1	360
+	33	122200	1	2160 -- Rare Dragon Ruby
+	34	122210	1	7200
+	35	122220	1	2400
+	36	122230	1	120
+	37	122240	1	120
+	38	122300	1	108 -- Rare Dragon Ruby
+	39	122310	1	360
+	40	122320	1	120
+	41	122330	1	6
+	42	122340	1	6
+	43	122400	1	108 -- Rare Dragon Ruby
+	44	122410	1	360
+	45	122420	1	120
+	46	122430	1	6
+	47	122440	1	6
+	48	123000	1	324 -- Antique Dragon Ruby
+	49	123010	1	1080
+	50	123020	1	360
+	51	123030	1	18
+	52	123040	1	18
+	53	123100	1	1080 -- Antique Dragon Ruby
+	54	123110	1	3600
+	55	123120	1	1200
+	56	123130	1	60
+	57	123140	1	60
+	58	123200	1	360 -- Antique Dragon Ruby
+	59	123210	1	1200
+	60	123220	1	400
+	61	123230	1	20
+	62	123240	1	20
+	63	123300	1	18 -- Antique Dragon Ruby
+	64	123310	1	60
+	65	123320	1	20
+	66	123330	1	1
+	67	123340	1	1
+	68	123400	1	18 -- Antique Dragon Ruby
+	69	123410	1	60
+	70	123420	1	20
+	71	123430	1	1
+	72	123440	1	1
+}
+Group	풍麗肌혼_화-
+{
+	Vnum	51614 -- Cor Jadeit+ (Eternal)
+	1	131000	1	972 -- Cut Dragon Jade
+	2	131010	1	3240
+	3	131020	1	1080
+	4	131030	1	54
+	5	131100	1	3240 -- Cut Dragon Jade
+	6	131110	1	10800
+	7	131120	1	3600
+	8	131130	1	180
+	9	131200	1	1080 -- Cut Dragon Jade
+	10	131210	1	3600
+	11	131220	1	1200
+	12	131230	1	60
+	13	131300	1	54 -- Cut Dragon Jade
+	14	131310	1	180
+	15	131320	1	60
+	16	131330	1	3
+	17	131340	1	3
+	18	131400	1	54 -- Cut Dragon Jade
+	19	131410	1	180
+	20	131420	1	60
+	21	131430	1	3
+	22	131440	1	3
+	23	132000	1	1944 -- Rare Dragon Jade
+	24	132010	1	6480
+	25	132020	1	2160
+	26	132030	1	108
+	27	132040	1	108
+	28	132100	1	6480 -- Rare Dragon Jade
+	29	132110	1	21600
+	30	132120	1	7200
+	31	132130	1	360
+	32	132140	1	360
+	33	132200	1	2160 -- Rare Dragon Jade
+	34	132210	1	7200
+	35	132220	1	2400
+	36	132230	1	120
+	37	132240	1	120
+	38	132300	1	108 -- Rare Dragon Jade
+	39	132310	1	360
+	40	132320	1	120
+	41	132330	1	6
+	42	132340	1	6
+	43	132400	1	108 -- Rare Dragon Jade
+	44	132410	1	360
+	45	132420	1	120
+	46	132430	1	6
+	47	132440	1	6
+	48	133000	1	324 -- Antique Dragon Jade
+	49	133010	1	1080
+	50	133020	1	360
+	51	133030	1	18
+	52	133040	1	18
+	53	133100	1	1080 -- Antique Dragon Jade
+	54	133110	1	3600
+	55	133120	1	1200
+	56	133130	1	60
+	57	133140	1	60
+	58	133200	1	360 -- Antique Dragon Jade
+	59	133210	1	1200
+	60	133220	1	400
+	61	133230	1	20
+	62	133240	1	20
+	63	133300	1	18 -- Antique Dragon Jade
+	64	133310	1	60
+	65	133320	1	20
+	66	133330	1	1
+	67	133340	1	1
+	68	133400	1	18 -- Antique Dragon Jade
+	69	133410	1	60
+	70	133420	1	20
+	71	133430	1	1
+	72	133440	1	1
+}
+Group	철麗肌혼_화-
+{
+	Vnum	51615 -- Cor Saphirum+ (Eternal)
+	1	141000	1	972 -- Cut Dragon Sapphire
+	2	141010	1	3240
+	3	141020	1	1080
+	4	141030	1	54
+	5	141100	1	3240 -- Cut Dragon Sapphire
+	6	141110	1	10800
+	7	141120	1	3600
+	8	141130	1	180
+	9	141200	1	1080 -- Cut Dragon Sapphire
+	10	141210	1	3600
+	11	141220	1	1200
+	12	141230	1	60
+	13	141300	1	54 -- Cut Dragon Sapphire
+	14	141310	1	180
+	15	141320	1	60
+	16	141330	1	3
+	17	141340	1	3
+	18	141400	1	54 -- Cut Dragon Sapphire
+	19	141410	1	180
+	20	141420	1	60
+	21	141430	1	3
+	22	141440	1	3
+	23	142000	1	1944 -- Rare Dragon Sapphire
+	24	142010	1	6480
+	25	142020	1	2160
+	26	142030	1	108
+	27	142040	1	108
+	28	142100	1	6480 -- Rare Dragon Sapphire
+	29	142110	1	21600
+	30	142120	1	7200
+	31	142130	1	360
+	32	142140	1	360
+	33	142200	1	2160 -- Rare Dragon Sapphire
+	34	142210	1	7200
+	35	142220	1	2400
+	36	142230	1	120
+	37	142240	1	120
+	38	142300	1	108 -- Rare Dragon Sapphire
+	39	142310	1	360
+	40	142320	1	120
+	41	142330	1	6
+	42	142340	1	6
+	43	142400	1	108 -- Rare Dragon Sapphire
+	44	142410	1	360
+	45	142420	1	120
+	46	142430	1	6
+	47	142440	1	6
+	48	143000	1	324 -- Antique Dragon Sapphire
+	49	143010	1	1080
+	50	143020	1	360
+	51	143030	1	18
+	52	143040	1	18
+	53	143100	1	1080 -- Antique Dragon Sapphire
+	54	143110	1	3600
+	55	143120	1	1200
+	56	143130	1	60
+	57	143140	1	60
+	58	143200	1	360 -- Antique Dragon Sapphire
+	59	143210	1	1200
+	60	143220	1	400
+	61	143230	1	20
+	62	143240	1	20
+	63	143300	1	18 -- Antique Dragon Sapphire
+	64	143310	1	60
+	65	143320	1	20
+	66	143330	1	1
+	67	143340	1	1
+	68	143400	1	18 -- Antique Dragon Sapphire
+	69	143410	1	60
+	70	143420	1	20
+	71	143430	1	1
+	72	143440	1	1
+}
+Group	麗肌혼_화-
+{
+	Vnum	51616 -- Cor Granatum+ (Eternal)
+	1	151000	1	972 -- Cut Dragon Garnet
+	2	151010	1	3240
+	3	151020	1	1080
+	4	151030	1	54
+	5	151100	1	3240 -- Cut Dragon Garnet
+	6	151110	1	10800
+	7	151120	1	3600
+	8	151130	1	180
+	9	151200	1	1080 -- Cut Dragon Garnet
+	10	151210	1	3600
+	11	151220	1	1200
+	12	151230	1	60
+	13	151300	1	54 -- Cut Dragon Garnet
+	14	151310	1	180
+	15	151320	1	60
+	16	151330	1	3
+	17	151340	1	3
+	18	151400	1	54 -- Cut Dragon Garnet
+	19	151410	1	180
+	20	151420	1	60
+	21	151430	1	3
+	22	151440	1	3
+	23	152000	1	1944 -- Rare Dragon Garnet
+	24	152010	1	6480
+	25	152020	1	2160
+	26	152030	1	108
+	27	152040	1	108
+	28	152100	1	6480 -- Rare Dragon Garnet
+	29	152110	1	21600
+	30	152120	1	7200
+	31	152130	1	360
+	32	152140	1	360
+	33	152200	1	2160 -- Rare Dragon Garnet
+	34	152210	1	7200
+	35	152220	1	2400
+	36	152230	1	120
+	37	152240	1	120
+	38	152300	1	108 -- Rare Dragon Garnet
+	39	152310	1	360
+	40	152320	1	120
+	41	152330	1	6
+	42	152340	1	6
+	43	152400	1	108 -- Rare Dragon Garnet
+	44	152410	1	360
+	45	152420	1	120
+	46	152430	1	6
+	47	152440	1	6
+	48	153000	1	324 -- Antique Dragon Garnet
+	49	153010	1	1080
+	50	153020	1	360
+	51	153030	1	18
+	52	153040	1	18
+	53	153100	1	1080 -- Antique Dragon Garnet
+	54	153110	1	3600
+	55	153120	1	1200
+	56	153130	1	60
+	57	153140	1	60
+	58	153200	1	360 -- Antique Dragon Garnet
+	59	153210	1	1200
+	60	153220	1	400
+	61	153230	1	20
+	62	153240	1	20
+	63	153300	1	18 -- Antique Dragon Garnet
+	64	153310	1	60
+	65	153320	1	20
+	66	153330	1	1
+	67	153340	1	1
+	68	153400	1	18 -- Antique Dragon Garnet
+	69	153410	1	60
+	70	153420	1	20
+	71	153430	1	1
+	72	153440	1	1
+}
+Group	麗肌혼_화-
+{
+	Vnum	51617 -- Cor Atrum+ (Eternal)
+	1	161000	1	972 -- Cut Dragon Onyx
+	2	161010	1	3240
+	3	161020	1	1080
+	4	161030	1	54
+	5	161100	1	3240 -- Cut Dragon Onyx
+	6	161110	1	10800
+	7	161120	1	3600
+	8	161130	1	180
+	9	161200	1	1080 -- Cut Dragon Onyx
+	10	161210	1	3600
+	11	161220	1	1200
+	12	161230	1	60
+	13	161300	1	54 -- Cut Dragon Onyx
+	14	161310	1	180
+	15	161320	1	60
+	16	161330	1	3
+	17	161340	1	3
+	18	161400	1	54 -- Cut Dragon Onyx
+	19	161410	1	180
+	20	161420	1	60
+	21	161430	1	3
+	22	161440	1	3
+	23	162000	1	1944 -- Rare Dragon Onyx
+	24	162010	1	6480
+	25	162020	1	2160
+	26	162030	1	108
+	27	162040	1	108
+	28	162100	1	6480 -- Rare Dragon Onyx
+	29	162110	1	21600
+	30	162120	1	7200
+	31	162130	1	360
+	32	162140	1	360
+	33	162200	1	2160 -- Rare Dragon Onyx
+	34	162210	1	7200
+	35	162220	1	2400
+	36	162230	1	120
+	37	162240	1	120
+	38	162300	1	108 -- Rare Dragon Onyx
+	39	162310	1	360
+	40	162320	1	120
+	41	162330	1	6
+	42	162340	1	6
+	43	162400	1	108 -- Rare Dragon Onyx
+	44	162410	1	360
+	45	162420	1	120
+	46	162430	1	6
+	47	162440	1	6
+	48	163000	1	324 -- Antique Dragon Onyx
+	49	163010	1	1080
+	50	163020	1	360
+	51	163030	1	18
+	52	163040	1	18
+	53	163100	1	1080 -- Antique Dragon Onyx
+	54	163110	1	3600
+	55	163120	1	1200
+	56	163130	1	60
+	57	163140	1	60
+	58	163200	1	360 -- Antique Dragon Onyx
+	59	163210	1	1200
+	60	163220	1	400
+	61	163230	1	20
+	62	163240	1	20
+	63	163300	1	18 -- Antique Dragon Onyx
+	64	163310	1	60
+	65	163320	1	20
+	66	163330	1	1
+	67	163340	1	1
+	68	163400	1	18 -- Antique Dragon Onyx
+	69	163410	1	60
+	70	163420	1	20
+	71	163430	1	1
+	72	163440	1	1
+}
+Group	肌혼_화-
+{
+	Vnum	51618 -- Cor Draconis+ (Mystical)
+	1	111000	1	324 -- Cut Dragon Diamond
+	2	111010	1	1080
+	3	111020	1	360
+	4	111030	1	18
+	5	111100	1	1080 -- Cut Dragon Diamond
+	6	111110	1	3600
+	7	111120	1	1200
+	8	111130	1	60
+	9	111200	1	360 -- Cut Dragon Diamond
+	10	111210	1	1200
+	11	111220	1	400
+	12	111230	1	20
+	13	111300	1	18 -- Cut Dragon Diamond
+	14	111310	1	60
+	15	111320	1	20
+	16	111330	1	1
+	17	111340	1	1
+	18	111400	1	18 -- Cut Dragon Diamond
+	19	111410	1	60
+	20	111420	1	20
+	21	111430	1	1
+	22	111440	1	1
+	23	112000	1	810 -- Rare Dragon Diamond
+	24	112010	1	2700
+	25	112020	1	900
+	26	112030	1	45
+	27	112040	1	45
+	28	112100	1	2700 -- Rare Dragon Diamond
+	29	112110	1	9000
+	30	112120	1	3000
+	31	112130	1	150
+	32	112140	1	150
+	33	112200	1	900 -- Rare Dragon Diamond
+	34	112210	1	3000
+	35	112220	1	1000
+	36	112230	1	50
+	37	112240	1	50
+	38	112300	1	45 -- Rare Dragon Diamond
+	39	112310	1	150
+	40	112320	1	50
+	41	112330	1	3
+	42	112340	1	3
+	43	112400	1	45 -- Rare Dragon Diamond
+	44	112410	1	150
+	45	112420	1	50
+	46	112430	1	3
+	47	112440	1	3
+	48	113000	1	1782 -- Antique Dragon Diamond
+	49	113010	1	5940
+	50	113020	1	1980
+	51	113030	1	99
+	52	113040	1	99
+	53	113100	1	5940 -- Antique Dragon Diamond
+	54	113110	1	19800
+	55	113120	1	6600
+	56	113130	1	330
+	57	113140	1	330
+	58	113200	1	1980 -- Antique Dragon Diamond
+	59	113210	1	6600
+	60	113220	1	2200
+	61	113230	1	110
+	62	113240	1	110
+	63	113300	1	99 -- Antique Dragon Diamond
+	64	113310	1	330
+	65	113320	1	110
+	66	113330	1	6
+	67	113340	1	6
+	68	113400	1	99 -- Antique Dragon Diamond
+	69	113410	1	330
+	70	113420	1	110
+	71	113430	1	6
+	72	113440	1	6
+	73	114000	1	324 -- Legendary Dragon Diamond
+	74	114010	1	1080
+	75	114020	1	360
+	76	114030	1	18
+	77	114040	1	18
+	78	114100	1	1080 -- Legendary Dragon Diamond
+	79	114110	1	3600
+	80	114120	1	1200
+	81	114130	1	60
+	82	114140	1	60
+	83	114200	1	360 -- Legendary Dragon Diamond
+	84	114210	1	1200
+	85	114220	1	400
+	86	114230	1	20
+	87	114240	1	20
+	88	114300	1	18 -- Legendary Dragon Diamond
+	89	114310	1	60
+	90	114320	1	20
+	91	114330	1	1
+	92	114340	1	1
+	93	114400	1	18 -- Legendary Dragon Diamond
+	94	114410	1	60
+	95	114420	1	20
+	96	114430	1	1
+	97	114440	1	1
+	98	121000	1	324 -- Cut Dragon Ruby
+	99	121010	1	1080
+	100	121020	1	360
+	101	121030	1	18
+	102	121100	1	1080 -- Cut Dragon Ruby
+	103	121110	1	3600
+	104	121120	1	1200
+	105	121130	1	60
+	106	121200	1	360 -- Cut Dragon Ruby
+	107	121210	1	1200
+	108	121220	1	400
+	109	121230	1	20
+	110	121300	1	18 -- Cut Dragon Ruby
+	111	121310	1	60
+	112	121320	1	20
+	113	121330	1	1
+	114	121340	1	1
+	115	121400	1	18 -- Cut Dragon Ruby
+	116	121410	1	60
+	117	121420	1	20
+	118	121430	1	1
+	119	121440	1	1
+	120	122000	1	810 -- Rare Dragon Ruby
+	121	122010	1	2700
+	122	122020	1	900
+	123	122030	1	45
+	124	122040	1	45
+	125	122100	1	2700 -- Rare Dragon Ruby
+	126	122110	1	9000
+	127	122120	1	3000
+	128	122130	1	150
+	129	122140	1	150
+	130	122200	1	900 -- Rare Dragon Ruby
+	131	122210	1	3000
+	132	122220	1	1000
+	133	122230	1	50
+	134	122240	1	50
+	135	122300	1	45 -- Rare Dragon Ruby
+	136	122310	1	150
+	137	122320	1	50
+	138	122330	1	3
+	139	122340	1	3
+	140	122400	1	45 -- Rare Dragon Ruby
+	141	122410	1	150
+	142	122420	1	50
+	143	122430	1	3
+	144	122440	1	3
+	145	123000	1	1782 -- Antique Dragon Ruby
+	146	123010	1	5940
+	147	123020	1	1980
+	148	123030	1	99
+	149	123040	1	99
+	150	123100	1	5940 -- Antique Dragon Ruby
+	151	123110	1	19800
+	152	123120	1	6600
+	153	123130	1	330
+	154	123140	1	330
+	155	123200	1	1980 -- Antique Dragon Ruby
+	156	123210	1	6600
+	157	123220	1	2200
+	158	123230	1	110
+	159	123240	1	110
+	160	123300	1	99 -- Antique Dragon Ruby
+	161	123310	1	330
+	162	123320	1	110
+	163	123330	1	6
+	164	123340	1	6
+	165	123400	1	99 -- Antique Dragon Ruby
+	166	123410	1	330
+	167	123420	1	110
+	168	123430	1	6
+	169	123440	1	6
+	170	124000	1	324 -- Legendary Dragon Ruby
+	171	124010	1	1080
+	172	124020	1	360
+	173	124030	1	18
+	174	124040	1	18
+	175	124100	1	1080 -- Legendary Dragon Ruby
+	176	124110	1	3600
+	177	124120	1	1200
+	178	124130	1	60
+	179	124140	1	60
+	180	124200	1	360 -- Legendary Dragon Ruby
+	181	124210	1	1200
+	182	124220	1	400
+	183	124230	1	20
+	184	124240	1	20
+	185	124300	1	18 -- Legendary Dragon Ruby
+	186	124310	1	60
+	187	124320	1	20
+	188	124330	1	1
+	189	124340	1	1
+	190	124400	1	18 -- Legendary Dragon Ruby
+	191	124410	1	60
+	192	124420	1	20
+	193	124430	1	1
+	194	124440	1	1
+	195	131000	1	324 -- Cut Dragon Jade
+	196	131010	1	1080
+	197	131020	1	360
+	198	131030	1	18
+	199	131100	1	1080 -- Cut Dragon Jade
+	200	131110	1	3600
+	201	131120	1	1200
+	202	131130	1	60
+	203	131200	1	360 -- Cut Dragon Jade
+	204	131210	1	1200
+	205	131220	1	400
+	206	131230	1	20
+	207	131300	1	18 -- Cut Dragon Jade
+	208	131310	1	60
+	209	131320	1	20
+	210	131330	1	1
+	211	131340	1	1
+	212	131400	1	18 -- Cut Dragon Jade
+	213	131410	1	60
+	214	131420	1	20
+	215	131430	1	1
+	216	131440	1	1
+	217	132000	1	810 -- Rare Dragon Jade
+	218	132010	1	2700
+	219	132020	1	900
+	220	132030	1	45
+	221	132040	1	45
+	222	132100	1	2700 -- Rare Dragon Jade
+	223	132110	1	9000
+	224	132120	1	3000
+	225	132130	1	150
+	226	132140	1	150
+	227	132200	1	900 -- Rare Dragon Jade
+	228	132210	1	3000
+	229	132220	1	1000
+	230	132230	1	50
+	231	132240	1	50
+	232	132300	1	45 -- Rare Dragon Jade
+	233	132310	1	150
+	234	132320	1	50
+	235	132330	1	3
+	236	132340	1	3
+	237	132400	1	45 -- Rare Dragon Jade
+	238	132410	1	150
+	239	132420	1	50
+	240	132430	1	3
+	241	132440	1	3
+	242	133000	1	1782 -- Antique Dragon Jade
+	243	133010	1	5940
+	244	133020	1	1980
+	245	133030	1	99
+	246	133040	1	99
+	247	133100	1	5940 -- Antique Dragon Jade
+	248	133110	1	19800
+	249	133120	1	6600
+	250	133130	1	330
+	251	133140	1	330
+	252	133200	1	1980 -- Antique Dragon Jade
+	253	133210	1	6600
+	254	133220	1	2200
+	255	133230	1	110
+	256	133240	1	110
+	257	133300	1	99 -- Antique Dragon Jade
+	258	133310	1	330
+	259	133320	1	110
+	260	133330	1	6
+	261	133340	1	6
+	262	133400	1	99 -- Antique Dragon Jade
+	263	133410	1	330
+	264	133420	1	110
+	265	133430	1	6
+	266	133440	1	6
+	267	134000	1	324 -- Legendary Dragon Jade
+	268	134010	1	1080
+	269	134020	1	360
+	270	134030	1	18
+	271	134040	1	18
+	272	134100	1	1080 -- Legendary Dragon Jade
+	273	134110	1	3600
+	274	134120	1	1200
+	275	134130	1	60
+	276	134140	1	60
+	277	134200	1	360 -- Legendary Dragon Jade
+	278	134210	1	1200
+	279	134220	1	400
+	280	134230	1	20
+	281	134240	1	20
+	282	134300	1	18 -- Legendary Dragon Jade
+	283	134310	1	60
+	284	134320	1	20
+	285	134330	1	1
+	286	134340	1	1
+	287	134400	1	18 -- Legendary Dragon Jade
+	288	134410	1	60
+	289	134420	1	20
+	290	134430	1	1
+	291	134440	1	1
+	292	141000	1	324 -- Cut Dragon Sapphire
+	293	141010	1	1080
+	294	141020	1	360
+	295	141030	1	18
+	296	141100	1	1080 -- Cut Dragon Sapphire
+	297	141110	1	3600
+	298	141120	1	1200
+	299	141130	1	60
+	300	141200	1	360 -- Cut Dragon Sapphire
+	301	141210	1	1200
+	302	141220	1	400
+	303	141230	1	20
+	304	141300	1	18 -- Cut Dragon Sapphire
+	305	141310	1	60
+	306	141320	1	20
+	307	141330	1	1
+	308	141340	1	1
+	309	141400	1	18 -- Cut Dragon Sapphire
+	310	141410	1	60
+	311	141420	1	20
+	312	141430	1	1
+	313	141440	1	1
+	314	142000	1	810 -- Rare Dragon Sapphire
+	315	142010	1	2700
+	316	142020	1	900
+	317	142030	1	45
+	318	142040	1	45
+	319	142100	1	2700 -- Rare Dragon Sapphire
+	320	142110	1	9000
+	321	142120	1	3000
+	322	142130	1	150
+	323	142140	1	150
+	324	142200	1	900 -- Rare Dragon Sapphire
+	325	142210	1	3000
+	326	142220	1	1000
+	327	142230	1	50
+	328	142240	1	50
+	329	142300	1	45 -- Rare Dragon Sapphire
+	330	142310	1	150
+	331	142320	1	50
+	332	142330	1	3
+	333	142340	1	3
+	334	142400	1	45 -- Rare Dragon Sapphire
+	335	142410	1	150
+	336	142420	1	50
+	337	142430	1	3
+	338	142440	1	3
+	339	143000	1	1782 -- Antique Dragon Sapphire
+	340	143010	1	5940
+	341	143020	1	1980
+	342	143030	1	99
+	343	143040	1	99
+	344	143100	1	5940 -- Antique Dragon Sapphire
+	345	143110	1	19800
+	346	143120	1	6600
+	347	143130	1	330
+	348	143140	1	330
+	349	143200	1	1980 -- Antique Dragon Sapphire
+	350	143210	1	6600
+	351	143220	1	2200
+	352	143230	1	110
+	353	143240	1	110
+	354	143300	1	99 -- Antique Dragon Sapphire
+	355	143310	1	330
+	356	143320	1	110
+	357	143330	1	6
+	358	143340	1	6
+	359	143400	1	99 -- Antique Dragon Sapphire
+	360	143410	1	330
+	361	143420	1	110
+	362	143430	1	6
+	363	143440	1	6
+	364	144000	1	324 -- Legendary DragonSapphire
+	365	144010	1	1080
+	366	144020	1	360
+	367	144030	1	18
+	368	144040	1	18
+	369	144100	1	1080 -- Legendary DragonSapphire
+	370	144110	1	3600
+	371	144120	1	1200
+	372	144130	1	60
+	373	144140	1	60
+	374	144200	1	360 -- Legendary DragonSapphire
+	375	144210	1	1200
+	376	144220	1	400
+	377	144230	1	20
+	378	144240	1	20
+	379	144300	1	18 -- Legendary DragonSapphire
+	380	144310	1	60
+	381	144320	1	20
+	382	144330	1	1
+	383	144340	1	1
+	384	144400	1	18 -- Legendary DragonSapphire
+	385	144410	1	60
+	386	144420	1	20
+	387	144430	1	1
+	388	144440	1	1
+	389	151000	1	324 -- Cut Dragon Garnet
+	390	151010	1	1080
+	391	151020	1	360
+	392	151030	1	18
+	393	151100	1	1080 -- Cut Dragon Garnet
+	394	151110	1	3600
+	395	151120	1	1200
+	396	151130	1	60
+	397	151200	1	360 -- Cut Dragon Garnet
+	398	151210	1	1200
+	399	151220	1	400
+	400	151230	1	20
+	401	151300	1	18 -- Cut Dragon Garnet
+	402	151310	1	60
+	403	151320	1	20
+	404	151330	1	1
+	405	151340	1	1
+	406	151400	1	18 -- Cut Dragon Garnet
+	407	151410	1	60
+	408	151420	1	20
+	409	151430	1	1
+	410	151440	1	1
+	411	152000	1	810 -- Rare Dragon Garnet
+	412	152010	1	2700
+	413	152020	1	900
+	414	152030	1	45
+	415	152040	1	45
+	416	152100	1	2700 -- Rare Dragon Garnet
+	417	152110	1	9000
+	418	152120	1	3000
+	419	152130	1	150
+	420	152140	1	150
+	421	152200	1	900 -- Rare Dragon Garnet
+	422	152210	1	3000
+	423	152220	1	1000
+	424	152230	1	50
+	425	152240	1	50
+	426	152300	1	45 -- Rare Dragon Garnet
+	427	152310	1	150
+	428	152320	1	50
+	429	152330	1	3
+	430	152340	1	3
+	431	152400	1	45 -- Rare Dragon Garnet
+	432	152410	1	150
+	433	152420	1	50
+	434	152430	1	3
+	435	152440	1	3
+	436	153000	1	1782 -- Antique Dragon Garnet
+	437	153010	1	5940
+	438	153020	1	1980
+	439	153030	1	99
+	440	153040	1	99
+	441	153100	1	5940 -- Antique Dragon Garnet
+	442	153110	1	19800
+	443	153120	1	6600
+	444	153130	1	330
+	445	153140	1	330
+	446	153200	1	1980 -- Antique Dragon Garnet
+	447	153210	1	6600
+	448	153220	1	2200
+	449	153230	1	110
+	450	153240	1	110
+	451	153300	1	99 -- Antique Dragon Garnet
+	452	153310	1	330
+	453	153320	1	110
+	454	153330	1	6
+	455	153340	1	6
+	456	153400	1	99 -- Antique Dragon Garnet
+	457	153410	1	330
+	458	153420	1	110
+	459	153430	1	6
+	460	153440	1	6
+	461	154000	1	324 -- Legendary Dragon Garnet
+	462	154010	1	1080
+	463	154020	1	360
+	464	154030	1	18
+	465	154040	1	18
+	466	154100	1	1080 -- Legendary Dragon Garnet
+	467	154110	1	3600
+	468	154120	1	1200
+	469	154130	1	60
+	470	154140	1	60
+	471	154200	1	360 -- Legendary Dragon Garnet
+	472	154210	1	1200
+	473	154220	1	400
+	474	154230	1	20
+	475	154240	1	20
+	476	154300	1	18 -- Legendary Dragon Garnet
+	477	154310	1	60
+	478	154320	1	20
+	479	154330	1	1
+	480	154340	1	1
+	481	154400	1	18 -- Legendary Dragon Garnet
+	482	154410	1	60
+	483	154420	1	20
+	484	154430	1	1
+	485	154440	1	1
+	486	161000	1	324 -- Cut Dragon Onyx
+	487	161010	1	1080
+	488	161020	1	360
+	489	161030	1	18
+	490	161100	1	1080 -- Cut Dragon Onyx
+	491	161110	1	3600
+	492	161120	1	1200
+	493	161130	1	60
+	494	161200	1	360 -- Cut Dragon Onyx
+	495	161210	1	1200
+	496	161220	1	400
+	497	161230	1	20
+	498	161300	1	18 -- Cut Dragon Onyx
+	499	161310	1	60
+	500	161320	1	20
+	501	161330	1	1
+	502	161340	1	1
+	503	161400	1	18 -- Cut Dragon Onyx
+	504	161410	1	60
+	505	161420	1	20
+	506	161430	1	1
+	507	161440	1	1
+	508	162000	1	810 -- Rare Dragon Onyx
+	509	162010	1	2700
+	510	162020	1	900
+	511	162030	1	45
+	512	162040	1	45
+	513	162100	1	2700 -- Rare Dragon Onyx
+	514	162110	1	9000
+	515	162120	1	3000
+	516	162130	1	150
+	517	162140	1	150
+	518	162200	1	900 -- Rare Dragon Onyx
+	519	162210	1	3000
+	520	162220	1	1000
+	521	162230	1	50
+	522	162240	1	50
+	523	162300	1	45 -- Rare Dragon Onyx
+	524	162310	1	150
+	525	162320	1	50
+	526	162330	1	3
+	527	162340	1	3
+	528	162400	1	45 -- Rare Dragon Onyx
+	529	162410	1	150
+	530	162420	1	50
+	531	162430	1	3
+	532	162440	1	3
+	533	163000	1	1782 -- Antique Dragon Onyx
+	534	163010	1	5940
+	535	163020	1	1980
+	536	163030	1	99
+	537	163040	1	99
+	538	163100	1	5940 -- Antique Dragon Onyx
+	539	163110	1	19800
+	540	163120	1	6600
+	541	163130	1	330
+	542	163140	1	330
+	543	163200	1	1980 -- Antique Dragon Onyx
+	544	163210	1	6600
+	545	163220	1	2200
+	546	163230	1	110
+	547	163240	1	110
+	548	163300	1	99 -- Antique Dragon Onyx
+	549	163310	1	330
+	550	163320	1	110
+	551	163330	1	6
+	552	163340	1	6
+	553	163400	1	99 -- Antique Dragon Onyx
+	554	163410	1	330
+	555	163420	1	110
+	556	163430	1	6
+	557	163440	1	6
+	558	164000	1	324 -- Legendary Dragon Onyx
+	559	164010	1	1080
+	560	164020	1	360
+	561	164030	1	18
+	562	164040	1	18
+	563	164100	1	1080 -- Legendary Dragon Onyx
+	564	164110	1	3600
+	565	164120	1	1200
+	566	164130	1	60
+	567	164140	1	60
+	568	164200	1	360 -- Legendary Dragon Onyx
+	569	164210	1	1200
+	570	164220	1	400
+	571	164230	1	20
+	572	164240	1	20
+	573	164300	1	18 -- Legendary Dragon Onyx
+	574	164310	1	60
+	575	164320	1	20
+	576	164330	1	1
+	577	164340	1	1
+	578	164400	1	18 -- Legendary Dragon Onyx
+	579	164410	1	60
+	580	164420	1	20
+	581	164430	1	1
+	582	164440	1	1
+}
+Group	麗肌혼_화-
+{
+	Vnum	51619 -- Cor Diamas+ (Mystical)
+	1	111000	1	324 -- Cut Dragon Diamond
+	2	111010	1	1080
+	3	111020	1	360
+	4	111030	1	18
+	5	111100	1	1080 -- Cut Dragon Diamond
+	6	111110	1	3600
+	7	111120	1	1200
+	8	111130	1	60
+	9	111200	1	360 -- Cut Dragon Diamond
+	10	111210	1	1200
+	11	111220	1	400
+	12	111230	1	20
+	13	111300	1	18 -- Cut Dragon Diamond
+	14	111310	1	60
+	15	111320	1	20
+	16	111330	1	1
+	17	111340	1	1
+	18	111400	1	18 -- Cut Dragon Diamond
+	19	111410	1	60
+	20	111420	1	20
+	21	111430	1	1
+	22	111440	1	1
+	23	112000	1	810 -- Rare Dragon Diamond
+	24	112010	1	2700
+	25	112020	1	900
+	26	112030	1	45
+	27	112040	1	45
+	28	112100	1	2700 -- Rare Dragon Diamond
+	29	112110	1	9000
+	30	112120	1	3000
+	31	112130	1	150
+	32	112140	1	150
+	33	112200	1	900 -- Rare Dragon Diamond
+	34	112210	1	3000
+	35	112220	1	1000
+	36	112230	1	50
+	37	112240	1	50
+	38	112300	1	45 -- Rare Dragon Diamond
+	39	112310	1	150
+	40	112320	1	50
+	41	112330	1	3
+	42	112340	1	3
+	43	112400	1	45 -- Rare Dragon Diamond
+	44	112410	1	150
+	45	112420	1	50
+	46	112430	1	3
+	47	112440	1	3
+	48	113000	1	1782 -- Antique Dragon Diamond
+	49	113010	1	5940
+	50	113020	1	1980
+	51	113030	1	99
+	52	113040	1	99
+	53	113100	1	5940 -- Antique Dragon Diamond
+	54	113110	1	19800
+	55	113120	1	6600
+	56	113130	1	330
+	57	113140	1	330
+	58	113200	1	1980 -- Antique Dragon Diamond
+	59	113210	1	6600
+	60	113220	1	2200
+	61	113230	1	110
+	62	113240	1	110
+	63	113300	1	99 -- Antique Dragon Diamond
+	64	113310	1	330
+	65	113320	1	110
+	66	113330	1	6
+	67	113340	1	6
+	68	113400	1	99 -- Antique Dragon Diamond
+	69	113410	1	330
+	70	113420	1	110
+	71	113430	1	6
+	72	113440	1	6
+	73	114000	1	324 -- Legendary Dragon Diamond
+	74	114010	1	1080
+	75	114020	1	360
+	76	114030	1	18
+	77	114040	1	18
+	78	114100	1	1080 -- Legendary Dragon Diamond
+	79	114110	1	3600
+	80	114120	1	1200
+	81	114130	1	60
+	82	114140	1	60
+	83	114200	1	360 -- Legendary Dragon Diamond
+	84	114210	1	1200
+	85	114220	1	400
+	86	114230	1	20
+	87	114240	1	20
+	88	114300	1	18 -- Legendary Dragon Diamond
+	89	114310	1	60
+	90	114320	1	20
+	91	114330	1	1
+	92	114340	1	1
+	93	114400	1	18 -- Legendary Dragon Diamond
+	94	114410	1	60
+	95	114420	1	20
+	96	114430	1	1
+	97	114440	1	1
+}
+Group	화麗肌혼_화-
+{
+	Vnum	51620 -- Cor Rubinum+ (Mystical)
+	1	121000	1	324 -- Cut Dragon Ruby
+	2	121010	1	1080
+	3	121020	1	360
+	4	121030	1	18
+	5	121100	1	1080 -- Cut Dragon Ruby
+	6	121110	1	3600
+	7	121120	1	1200
+	8	121130	1	60
+	9	121200	1	360 -- Cut Dragon Ruby
+	10	121210	1	1200
+	11	121220	1	400
+	12	121230	1	20
+	13	121300	1	18 -- Cut Dragon Ruby
+	14	121310	1	60
+	15	121320	1	20
+	16	121330	1	1
+	17	121340	1	1
+	18	121400	1	18 -- Cut Dragon Ruby
+	19	121410	1	60
+	20	121420	1	20
+	21	121430	1	1
+	22	121440	1	1
+	23	122000	1	810 -- Rare Dragon Ruby
+	24	122010	1	2700
+	25	122020	1	900
+	26	122030	1	45
+	27	122040	1	45
+	28	122100	1	2700 -- Rare Dragon Ruby
+	29	122110	1	9000
+	30	122120	1	3000
+	31	122130	1	150
+	32	122140	1	150
+	33	122200	1	900 -- Rare Dragon Ruby
+	34	122210	1	3000
+	35	122220	1	1000
+	36	122230	1	50
+	37	122240	1	50
+	38	122300	1	45 -- Rare Dragon Ruby
+	39	122310	1	150
+	40	122320	1	50
+	41	122330	1	3
+	42	122340	1	3
+	43	122400	1	45 -- Rare Dragon Ruby
+	44	122410	1	150
+	45	122420	1	50
+	46	122430	1	3
+	47	122440	1	3
+	48	123000	1	1782 -- Antique Dragon Ruby
+	49	123010	1	5940
+	50	123020	1	1980
+	51	123030	1	99
+	52	123040	1	99
+	53	123100	1	5940 -- Antique Dragon Ruby
+	54	123110	1	19800
+	55	123120	1	6600
+	56	123130	1	330
+	57	123140	1	330
+	58	123200	1	1980 -- Antique Dragon Ruby
+	59	123210	1	6600
+	60	123220	1	2200
+	61	123230	1	110
+	62	123240	1	110
+	63	123300	1	99 -- Antique Dragon Ruby
+	64	123310	1	330
+	65	123320	1	110
+	66	123330	1	6
+	67	123340	1	6
+	68	123400	1	99 -- Antique Dragon Ruby
+	69	123410	1	330
+	70	123420	1	110
+	71	123430	1	6
+	72	123440	1	6
+	73	124000	1	324 -- Legendary Dragon Ruby
+	74	124010	1	1080
+	75	124020	1	360
+	76	124030	1	18
+	77	124040	1	18
+	78	124100	1	1080 -- Legendary Dragon Ruby
+	79	124110	1	3600
+	80	124120	1	1200
+	81	124130	1	60
+	82	124140	1	60
+	83	124200	1	360 -- Legendary Dragon Ruby
+	84	124210	1	1200
+	85	124220	1	400
+	86	124230	1	20
+	87	124240	1	20
+	88	124300	1	18 -- Legendary Dragon Ruby
+	89	124310	1	60
+	90	124320	1	20
+	91	124330	1	1
+	92	124340	1	1
+	93	124400	1	18 -- Legendary Dragon Ruby
+	94	124410	1	60
+	95	124420	1	20
+	96	124430	1	1
+	97	124440	1	1
+}
+Group	풍麗肌혼_화-
+{
+	Vnum	51621 -- Cor Jadeit+ (Mystical)
+	1	131000	1	324 -- Cut Dragon Jade
+	2	131010	1	1080
+	3	131020	1	360
+	4	131030	1	18
+	5	131100	1	1080 -- Cut Dragon Jade
+	6	131110	1	3600
+	7	131120	1	1200
+	8	131130	1	60
+	9	131200	1	360 -- Cut Dragon Jade
+	10	131210	1	1200
+	11	131220	1	400
+	12	131230	1	20
+	13	131300	1	18 -- Cut Dragon Jade
+	14	131310	1	60
+	15	131320	1	20
+	16	131330	1	1
+	17	131340	1	1
+	18	131400	1	18 -- Cut Dragon Jade
+	19	131410	1	60
+	20	131420	1	20
+	21	131430	1	1
+	22	131440	1	1
+	23	132000	1	810 -- Rare Dragon Jade
+	24	132010	1	2700
+	25	132020	1	900
+	26	132030	1	45
+	27	132040	1	45
+	28	132100	1	2700 -- Rare Dragon Jade
+	29	132110	1	9000
+	30	132120	1	3000
+	31	132130	1	150
+	32	132140	1	150
+	33	132200	1	900 -- Rare Dragon Jade
+	34	132210	1	3000
+	35	132220	1	1000
+	36	132230	1	50
+	37	132240	1	50
+	38	132300	1	45 -- Rare Dragon Jade
+	39	132310	1	150
+	40	132320	1	50
+	41	132330	1	3
+	42	132340	1	3
+	43	132400	1	45 -- Rare Dragon Jade
+	44	132410	1	150
+	45	132420	1	50
+	46	132430	1	3
+	47	132440	1	3
+	48	133000	1	1782 -- Antique Dragon Jade
+	49	133010	1	5940
+	50	133020	1	1980
+	51	133030	1	99
+	52	133040	1	99
+	53	133100	1	5940 -- Antique Dragon Jade
+	54	133110	1	19800
+	55	133120	1	6600
+	56	133130	1	330
+	57	133140	1	330
+	58	133200	1	1980 -- Antique Dragon Jade
+	59	133210	1	6600
+	60	133220	1	2200
+	61	133230	1	110
+	62	133240	1	110
+	63	133300	1	99 -- Antique Dragon Jade
+	64	133310	1	330
+	65	133320	1	110
+	66	133330	1	6
+	67	133340	1	6
+	68	133400	1	99 -- Antique Dragon Jade
+	69	133410	1	330
+	70	133420	1	110
+	71	133430	1	6
+	72	133440	1	6
+	73	134000	1	324 -- Legendary Dragon Jade
+	74	134010	1	1080
+	75	134020	1	360
+	76	134030	1	18
+	77	134040	1	18
+	78	134100	1	1080 -- Legendary Dragon Jade
+	79	134110	1	3600
+	80	134120	1	1200
+	81	134130	1	60
+	82	134140	1	60
+	83	134200	1	360 -- Legendary Dragon Jade
+	84	134210	1	1200
+	85	134220	1	400
+	86	134230	1	20
+	87	134240	1	20
+	88	134300	1	18 -- Legendary Dragon Jade
+	89	134310	1	60
+	90	134320	1	20
+	91	134330	1	1
+	92	134340	1	1
+	93	134400	1	18 -- Legendary Dragon Jade
+	94	134410	1	60
+	95	134420	1	20
+	96	134430	1	1
+	97	134440	1	1
+}
+Group	철麗肌혼_화-
+{
+	Vnum	51622 -- Cor Saphirum+ (Mystical)
+	1	141000	1	324 -- Cut Dragon Sapphire
+	2	141010	1	1080
+	3	141020	1	360
+	4	141030	1	18
+	5	141100	1	1080 -- Cut Dragon Sapphire
+	6	141110	1	3600
+	7	141120	1	1200
+	8	141130	1	60
+	9	141200	1	360 -- Cut Dragon Sapphire
+	10	141210	1	1200
+	11	141220	1	400
+	12	141230	1	20
+	13	141300	1	18 -- Cut Dragon Sapphire
+	14	141310	1	60
+	15	141320	1	20
+	16	141330	1	1
+	17	141340	1	1
+	18	141400	1	18 -- Cut Dragon Sapphire
+	19	141410	1	60
+	20	141420	1	20
+	21	141430	1	1
+	22	141440	1	1
+	23	142000	1	810 -- Rare Dragon Sapphire
+	24	142010	1	2700
+	25	142020	1	900
+	26	142030	1	45
+	27	142040	1	45
+	28	142100	1	2700 -- Rare Dragon Sapphire
+	29	142110	1	9000
+	30	142120	1	3000
+	31	142130	1	150
+	32	142140	1	150
+	33	142200	1	900 -- Rare Dragon Sapphire
+	34	142210	1	3000
+	35	142220	1	1000
+	36	142230	1	50
+	37	142240	1	50
+	38	142300	1	45 -- Rare Dragon Sapphire
+	39	142310	1	150
+	40	142320	1	50
+	41	142330	1	3
+	42	142340	1	3
+	43	142400	1	45 -- Rare Dragon Sapphire
+	44	142410	1	150
+	45	142420	1	50
+	46	142430	1	3
+	47	142440	1	3
+	48	143000	1	1782 -- Antique Dragon Sapphire
+	49	143010	1	5940
+	50	143020	1	1980
+	51	143030	1	99
+	52	143040	1	99
+	53	143100	1	5940 -- Antique Dragon Sapphire
+	54	143110	1	19800
+	55	143120	1	6600
+	56	143130	1	330
+	57	143140	1	330
+	58	143200	1	1980 -- Antique Dragon Sapphire
+	59	143210	1	6600
+	60	143220	1	2200
+	61	143230	1	110
+	62	143240	1	110
+	63	143300	1	99 -- Antique Dragon Sapphire
+	64	143310	1	330
+	65	143320	1	110
+	66	143330	1	6
+	67	143340	1	6
+	68	143400	1	99 -- Antique Dragon Sapphire
+	69	143410	1	330
+	70	143420	1	110
+	71	143430	1	6
+	72	143440	1	6
+	73	144000	1	324 -- Legendary DragonSapphire
+	74	144010	1	1080
+	75	144020	1	360
+	76	144030	1	18
+	77	144040	1	18
+	78	144100	1	1080 -- Legendary DragonSapphire
+	79	144110	1	3600
+	80	144120	1	1200
+	81	144130	1	60
+	82	144140	1	60
+	83	144200	1	360 -- Legendary DragonSapphire
+	84	144210	1	1200
+	85	144220	1	400
+	86	144230	1	20
+	87	144240	1	20
+	88	144300	1	18 -- Legendary DragonSapphire
+	89	144310	1	60
+	90	144320	1	20
+	91	144330	1	1
+	92	144340	1	1
+	93	144400	1	18 -- Legendary DragonSapphire
+	94	144410	1	60
+	95	144420	1	20
+	96	144430	1	1
+	97	144440	1	1
+}
+Group	麗肌혼_화-
+{
+	Vnum	51623 -- Cor Granatum+ (Mystical)
+	1	151000	1	324 -- Cut Dragon Garnet
+	2	151010	1	1080
+	3	151020	1	360
+	4	151030	1	18
+	5	151100	1	1080 -- Cut Dragon Garnet
+	6	151110	1	3600
+	7	151120	1	1200
+	8	151130	1	60
+	9	151200	1	360 -- Cut Dragon Garnet
+	10	151210	1	1200
+	11	151220	1	400
+	12	151230	1	20
+	13	151300	1	18 -- Cut Dragon Garnet
+	14	151310	1	60
+	15	151320	1	20
+	16	151330	1	1
+	17	151340	1	1
+	18	151400	1	18 -- Cut Dragon Garnet
+	19	151410	1	60
+	20	151420	1	20
+	21	151430	1	1
+	22	151440	1	1
+	23	152000	1	810 -- Rare Dragon Garnet
+	24	152010	1	2700
+	25	152020	1	900
+	26	152030	1	45
+	27	152040	1	45
+	28	152100	1	2700 -- Rare Dragon Garnet
+	29	152110	1	9000
+	30	152120	1	3000
+	31	152130	1	150
+	32	152140	1	150
+	33	152200	1	900 -- Rare Dragon Garnet
+	34	152210	1	3000
+	35	152220	1	1000
+	36	152230	1	50
+	37	152240	1	50
+	38	152300	1	45 -- Rare Dragon Garnet
+	39	152310	1	150
+	40	152320	1	50
+	41	152330	1	3
+	42	152340	1	3
+	43	152400	1	45 -- Rare Dragon Garnet
+	44	152410	1	150
+	45	152420	1	50
+	46	152430	1	3
+	47	152440	1	3
+	48	153000	1	1782 -- Antique Dragon Garnet
+	49	153010	1	5940
+	50	153020	1	1980
+	51	153030	1	99
+	52	153040	1	99
+	53	153100	1	5940 -- Antique Dragon Garnet
+	54	153110	1	19800
+	55	153120	1	6600
+	56	153130	1	330
+	57	153140	1	330
+	58	153200	1	1980 -- Antique Dragon Garnet
+	59	153210	1	6600
+	60	153220	1	2200
+	61	153230	1	110
+	62	153240	1	110
+	63	153300	1	99 -- Antique Dragon Garnet
+	64	153310	1	330
+	65	153320	1	110
+	66	153330	1	6
+	67	153340	1	6
+	68	153400	1	99 -- Antique Dragon Garnet
+	69	153410	1	330
+	70	153420	1	110
+	71	153430	1	6
+	72	153440	1	6
+	73	154000	1	324 -- Legendary Dragon Garnet
+	74	154010	1	1080
+	75	154020	1	360
+	76	154030	1	18
+	77	154040	1	18
+	78	154100	1	1080 -- Legendary Dragon Garnet
+	79	154110	1	3600
+	80	154120	1	1200
+	81	154130	1	60
+	82	154140	1	60
+	83	154200	1	360 -- Legendary Dragon Garnet
+	84	154210	1	1200
+	85	154220	1	400
+	86	154230	1	20
+	87	154240	1	20
+	88	154300	1	18 -- Legendary Dragon Garnet
+	89	154310	1	60
+	90	154320	1	20
+	91	154330	1	1
+	92	154340	1	1
+	93	154400	1	18 -- Legendary Dragon Garnet
+	94	154410	1	60
+	95	154420	1	20
+	96	154430	1	1
+	97	154440	1	1
+}
+Group	麗肌혼_화-
+{
+	Vnum	51624 -- Cor Atrum+ (Mystical)
+	1	161000	1	324 -- Cut Dragon Onyx
+	2	161010	1	1080
+	3	161020	1	360
+	4	161030	1	18
+	5	161100	1	1080 -- Cut Dragon Onyx
+	6	161110	1	3600
+	7	161120	1	1200
+	8	161130	1	60
+	9	161200	1	360 -- Cut Dragon Onyx
+	10	161210	1	1200
+	11	161220	1	400
+	12	161230	1	20
+	13	161300	1	18 -- Cut Dragon Onyx
+	14	161310	1	60
+	15	161320	1	20
+	16	161330	1	1
+	17	161340	1	1
+	18	161400	1	18 -- Cut Dragon Onyx
+	19	161410	1	60
+	20	161420	1	20
+	21	161430	1	1
+	22	161440	1	1
+	23	162000	1	810 -- Rare Dragon Onyx
+	24	162010	1	2700
+	25	162020	1	900
+	26	162030	1	45
+	27	162040	1	45
+	28	162100	1	2700 -- Rare Dragon Onyx
+	29	162110	1	9000
+	30	162120	1	3000
+	31	162130	1	150
+	32	162140	1	150
+	33	162200	1	900 -- Rare Dragon Onyx
+	34	162210	1	3000
+	35	162220	1	1000
+	36	162230	1	50
+	37	162240	1	50
+	38	162300	1	45 -- Rare Dragon Onyx
+	39	162310	1	150
+	40	162320	1	50
+	41	162330	1	3
+	42	162340	1	3
+	43	162400	1	45 -- Rare Dragon Onyx
+	44	162410	1	150
+	45	162420	1	50
+	46	162430	1	3
+	47	162440	1	3
+	48	163000	1	1782 -- Antique Dragon Onyx
+	49	163010	1	5940
+	50	163020	1	1980
+	51	163030	1	99
+	52	163040	1	99
+	53	163100	1	5940 -- Antique Dragon Onyx
+	54	163110	1	19800
+	55	163120	1	6600
+	56	163130	1	330
+	57	163140	1	330
+	58	163200	1	1980 -- Antique Dragon Onyx
+	59	163210	1	6600
+	60	163220	1	2200
+	61	163230	1	110
+	62	163240	1	110
+	63	163300	1	99 -- Antique Dragon Onyx
+	64	163310	1	330
+	65	163320	1	110
+	66	163330	1	6
+	67	163340	1	6
+	68	163400	1	99 -- Antique Dragon Onyx
+	69	163410	1	330
+	70	163420	1	110
+	71	163430	1	6
+	72	163440	1	6
+	73	164000	1	324 -- Legendary Dragon Onyx
+	74	164010	1	1080
+	75	164020	1	360
+	76	164030	1	18
+	77	164040	1	18
+	78	164100	1	1080 -- Legendary Dragon Onyx
+	79	164110	1	3600
+	80	164120	1	1200
+	81	164130	1	60
+	82	164140	1	60
+	83	164200	1	360 -- Legendary Dragon Onyx
+	84	164210	1	1200
+	85	164220	1	400
+	86	164230	1	20
+	87	164240	1	20
+	88	164300	1	18 -- Legendary Dragon Onyx
+	89	164310	1	60
+	90	164320	1	20
+	91	164330	1	1
+	92	164340	1	1
+	93	164400	1	18 -- Legendary Dragon Onyx
+	94	164410	1	60
+	95	164420	1	20
+	96	164430	1	1
+	97	164440	1	1
+}
+Group	肌혼_-
+{
+	Vnum	51625 -- Cor Draconis+ (Epic)
+	1	112000	1	756 -- Rare Dragon Diamond
+	2	112010	1	2520
+	3	112020	1	840
+	4	112030	1	42
+	5	112040	1	42
+	6	112100	1	2520 -- Rare Dragon Diamond
+	7	112110	1	8400
+	8	112120	1	2800
+	9	112130	1	140
+	10	112140	1	140
+	11	112200	1	840 -- Rare Dragon Diamond
+	12	112210	1	2800
+	13	112220	1	933
+	14	112230	1	47
+	15	112240	1	47
+	16	112300	1	42 -- Rare Dragon Diamond
+	17	112310	1	140
+	18	112320	1	47
+	19	112330	1	2
+	20	112340	1	2
+	21	112400	1	42 -- Rare Dragon Diamond
+	22	112410	1	140
+	23	112420	1	47
+	24	112430	1	2
+	25	112440	1	2
+	26	113000	1	324 -- Antique Dragon Diamond
+	27	113010	1	1080
+	28	113020	1	360
+	29	113030	1	18
+	30	113040	1	18
+	31	113100	1	1080 -- Antique Dragon Diamond
+	32	113110	1	3600
+	33	113120	1	1200
+	34	113130	1	60
+	35	113140	1	60
+	36	113200	1	360 -- Antique Dragon Diamond
+	37	113210	1	1200
+	38	113220	1	400
+	39	113230	1	20
+	40	113240	1	20
+	41	113300	1	18 -- Antique Dragon Diamond
+	42	113310	1	60
+	43	113320	1	20
+	44	113330	1	1
+	45	113340	1	1
+	46	113400	1	18 -- Antique Dragon Diamond
+	47	113410	1	60
+	48	113420	1	20
+	49	113430	1	1
+	50	113440	1	1
+	51	122000	1	756 -- Rare Dragon Ruby
+	52	122010	1	2520
+	53	122020	1	840
+	54	122030	1	42
+	55	122040	1	42
+	56	122100	1	2520 -- Rare Dragon Ruby
+	57	122110	1	8400
+	58	122120	1	2800
+	59	122130	1	140
+	60	122140	1	140
+	61	122200	1	840 -- Rare Dragon Ruby
+	62	122210	1	2800
+	63	122220	1	933
+	64	122230	1	47
+	65	122240	1	47
+	66	122300	1	42 -- Rare Dragon Ruby
+	67	122310	1	140
+	68	122320	1	47
+	69	122330	1	2
+	70	122340	1	2
+	71	122400	1	42 -- Rare Dragon Ruby
+	72	122410	1	140
+	73	122420	1	47
+	74	122430	1	2
+	75	122440	1	2
+	76	123000	1	324 -- Antique Dragon Ruby
+	77	123010	1	1080
+	78	123020	1	360
+	79	123030	1	18
+	80	123040	1	18
+	81	123100	1	1080 -- Antique Dragon Ruby
+	82	123110	1	3600
+	83	123120	1	1200
+	84	123130	1	60
+	85	123140	1	60
+	86	123200	1	360 -- Antique Dragon Ruby
+	87	123210	1	1200
+	88	123220	1	400
+	89	123230	1	20
+	90	123240	1	20
+	91	123300	1	18 -- Antique Dragon Ruby
+	92	123310	1	60
+	93	123320	1	20
+	94	123330	1	1
+	95	123340	1	1
+	96	123400	1	18 -- Antique Dragon Ruby
+	97	123410	1	60
+	98	123420	1	20
+	99	123430	1	1
+	100	123440	1	1
+	101	132000	1	756 -- Rare Dragon Jade
+	102	132010	1	2520
+	103	132020	1	840
+	104	132030	1	42
+	105	132040	1	42
+	106	132100	1	2520 -- Rare Dragon Jade
+	107	132110	1	8400
+	108	132120	1	2800
+	109	132130	1	140
+	110	132140	1	140
+	111	132200	1	840 -- Rare Dragon Jade
+	112	132210	1	2800
+	113	132220	1	933
+	114	132230	1	47
+	115	132240	1	47
+	116	132300	1	42 -- Rare Dragon Jade
+	117	132310	1	140
+	118	132320	1	47
+	119	132330	1	2
+	120	132340	1	2
+	121	132400	1	42 -- Rare Dragon Jade
+	122	132410	1	140
+	123	132420	1	47
+	124	132430	1	2
+	125	132440	1	2
+	126	133000	1	324 -- Antique Dragon Jade
+	127	133010	1	1080
+	128	133020	1	360
+	129	133030	1	18
+	130	133040	1	18
+	131	133100	1	1080 -- Antique Dragon Jade
+	132	133110	1	3600
+	133	133120	1	1200
+	134	133130	1	60
+	135	133140	1	60
+	136	133200	1	360 -- Antique Dragon Jade
+	137	133210	1	1200
+	138	133220	1	400
+	139	133230	1	20
+	140	133240	1	20
+	141	133300	1	18 -- Antique Dragon Jade
+	142	133310	1	60
+	143	133320	1	20
+	144	133330	1	1
+	145	133340	1	1
+	146	133400	1	18 -- Antique Dragon Jade
+	147	133410	1	60
+	148	133420	1	20
+	149	133430	1	1
+	150	133440	1	1
+	151	142000	1	756 -- Rare Dragon Sapphire
+	152	142010	1	2520
+	153	142020	1	840
+	154	142030	1	42
+	155	142040	1	42
+	156	142100	1	2520 -- Rare Dragon Sapphire
+	157	142110	1	8400
+	158	142120	1	2800
+	159	142130	1	140
+	160	142140	1	140
+	161	142200	1	840 -- Rare Dragon Sapphire
+	162	142210	1	2800
+	163	142220	1	933
+	164	142230	1	47
+	165	142240	1	47
+	166	142300	1	42 -- Rare Dragon Sapphire
+	167	142310	1	140
+	168	142320	1	47
+	169	142330	1	2
+	170	142340	1	2
+	171	142400	1	42 -- Rare Dragon Sapphire
+	172	142410	1	140
+	173	142420	1	47
+	174	142430	1	2
+	175	142440	1	2
+	176	143000	1	324 -- Antique Dragon Sapphire
+	177	143010	1	1080
+	178	143020	1	360
+	179	143030	1	18
+	180	143040	1	18
+	181	143100	1	1080 -- Antique Dragon Sapphire
+	182	143110	1	3600
+	183	143120	1	1200
+	184	143130	1	60
+	185	143140	1	60
+	186	143200	1	360 -- Antique Dragon Sapphire
+	187	143210	1	1200
+	188	143220	1	400
+	189	143230	1	20
+	190	143240	1	20
+	191	143300	1	18 -- Antique Dragon Sapphire
+	192	143310	1	60
+	193	143320	1	20
+	194	143330	1	1
+	195	143340	1	1
+	196	143400	1	18 -- Antique Dragon Sapphire
+	197	143410	1	60
+	198	143420	1	20
+	199	143430	1	1
+	200	143440	1	1
+	201	152000	1	756 -- Rare Dragon Garnet
+	202	152010	1	2520
+	203	152020	1	840
+	204	152030	1	42
+	205	152040	1	42
+	206	152100	1	2520 -- Rare Dragon Garnet
+	207	152110	1	8400
+	208	152120	1	2800
+	209	152130	1	140
+	210	152140	1	140
+	211	152200	1	840 -- Rare Dragon Garnet
+	212	152210	1	2800
+	213	152220	1	933
+	214	152230	1	47
+	215	152240	1	47
+	216	152300	1	42 -- Rare Dragon Garnet
+	217	152310	1	140
+	218	152320	1	47
+	219	152330	1	2
+	220	152340	1	2
+	221	152400	1	42 -- Rare Dragon Garnet
+	222	152410	1	140
+	223	152420	1	47
+	224	152430	1	2
+	225	152440	1	2
+	226	153000	1	324 -- Antique Dragon Garnet
+	227	153010	1	1080
+	228	153020	1	360
+	229	153030	1	18
+	230	153040	1	18
+	231	153100	1	1080 -- Antique Dragon Garnet
+	232	153110	1	3600
+	233	153120	1	1200
+	234	153130	1	60
+	235	153140	1	60
+	236	153200	1	360 -- Antique Dragon Garnet
+	237	153210	1	1200
+	238	153220	1	400
+	239	153230	1	20
+	240	153240	1	20
+	241	153300	1	18 -- Antique Dragon Garnet
+	242	153310	1	60
+	243	153320	1	20
+	244	153330	1	1
+	245	153340	1	1
+	246	153400	1	18 -- Antique Dragon Garnet
+	247	153410	1	60
+	248	153420	1	20
+	249	153430	1	1
+	250	153440	1	1
+	251	162000	1	756 -- Rare Dragon Onyx
+	252	162010	1	2520
+	253	162020	1	840
+	254	162030	1	42
+	255	162040	1	42
+	256	162100	1	2520 -- Rare Dragon Onyx
+	257	162110	1	8400
+	258	162120	1	2800
+	259	162130	1	140
+	260	162140	1	140
+	261	162200	1	840 -- Rare Dragon Onyx
+	262	162210	1	2800
+	263	162220	1	933
+	264	162230	1	47
+	265	162240	1	47
+	266	162300	1	42 -- Rare Dragon Onyx
+	267	162310	1	140
+	268	162320	1	47
+	269	162330	1	2
+	270	162340	1	2
+	271	162400	1	42 -- Rare Dragon Onyx
+	272	162410	1	140
+	273	162420	1	47
+	274	162430	1	2
+	275	162440	1	2
+	276	163000	1	324 -- Antique Dragon Onyx
+	277	163010	1	1080
+	278	163020	1	360
+	279	163030	1	18
+	280	163040	1	18
+	281	163100	1	1080 -- Antique Dragon Onyx
+	282	163110	1	3600
+	283	163120	1	1200
+	284	163130	1	60
+	285	163140	1	60
+	286	163200	1	360 -- Antique Dragon Onyx
+	287	163210	1	1200
+	288	163220	1	400
+	289	163230	1	20
+	290	163240	1	20
+	291	163300	1	18 -- Antique Dragon Onyx
+	292	163310	1	60
+	293	163320	1	20
+	294	163330	1	1
+	295	163340	1	1
+	296	163400	1	18 -- Antique Dragon Onyx
+	297	163410	1	60
+	298	163420	1	20
+	299	163430	1	1
+	300	163440	1	1
+}
+Group	麗肌혼_-
+{
+	Vnum	51626 -- Cor Diamas+ (Epic)
+	1	112000	1	756 -- Rare Dragon Diamond
+	2	112010	1	2520
+	3	112020	1	840
+	4	112030	1	42
+	5	112040	1	42
+	6	112100	1	2520 -- Rare Dragon Diamond
+	7	112110	1	8400
+	8	112120	1	2800
+	9	112130	1	140
+	10	112140	1	140
+	11	112200	1	840 -- Rare Dragon Diamond
+	12	112210	1	2800
+	13	112220	1	933
+	14	112230	1	47
+	15	112240	1	47
+	16	112300	1	42 -- Rare Dragon Diamond
+	17	112310	1	140
+	18	112320	1	47
+	19	112330	1	2
+	20	112340	1	2
+	21	112400	1	42 -- Rare Dragon Diamond
+	22	112410	1	140
+	23	112420	1	47
+	24	112430	1	2
+	25	112440	1	2
+	26	113000	1	324 -- Antique Dragon Diamond
+	27	113010	1	1080
+	28	113020	1	360
+	29	113030	1	18
+	30	113040	1	18
+	31	113100	1	1080 -- Antique Dragon Diamond
+	32	113110	1	3600
+	33	113120	1	1200
+	34	113130	1	60
+	35	113140	1	60
+	36	113200	1	360 -- Antique Dragon Diamond
+	37	113210	1	1200
+	38	113220	1	400
+	39	113230	1	20
+	40	113240	1	20
+	41	113300	1	18 -- Antique Dragon Diamond
+	42	113310	1	60
+	43	113320	1	20
+	44	113330	1	1
+	45	113340	1	1
+	46	113400	1	18 -- Antique Dragon Diamond
+	47	113410	1	60
+	48	113420	1	20
+	49	113430	1	1
+	50	113440	1	1
+}
+Group	麗肌혼_-
+{
+	Vnum	51627 -- Cor Rubinum+ (Epic)
+	1	122000	1	756 -- Rare Dragon Ruby
+	2	122010	1	2520
+	3	122020	1	840
+	4	122030	1	42
+	5	122040	1	42
+	6	122100	1	2520 -- Rare Dragon Ruby
+	7	122110	1	8400
+	8	122120	1	2800
+	9	122130	1	140
+	10	122140	1	140
+	11	122200	1	840 -- Rare Dragon Ruby
+	12	122210	1	2800
+	13	122220	1	933
+	14	122230	1	47
+	15	122240	1	47
+	16	122300	1	42 -- Rare Dragon Ruby
+	17	122310	1	140
+	18	122320	1	47
+	19	122330	1	2
+	20	122340	1	2
+	21	122400	1	42 -- Rare Dragon Ruby
+	22	122410	1	140
+	23	122420	1	47
+	24	122430	1	2
+	25	122440	1	2
+	26	123000	1	324 -- Antique Dragon Ruby
+	27	123010	1	1080
+	28	123020	1	360
+	29	123030	1	18
+	30	123040	1	18
+	31	123100	1	1080 -- Antique Dragon Ruby
+	32	123110	1	3600
+	33	123120	1	1200
+	34	123130	1	60
+	35	123140	1	60
+	36	123200	1	360 -- Antique Dragon Ruby
+	37	123210	1	1200
+	38	123220	1	400
+	39	123230	1	20
+	40	123240	1	20
+	41	123300	1	18 -- Antique Dragon Ruby
+	42	123310	1	60
+	43	123320	1	20
+	44	123330	1	1
+	45	123340	1	1
+	46	123400	1	18 -- Antique Dragon Ruby
+	47	123410	1	60
+	48	123420	1	20
+	49	123430	1	1
+	50	123440	1	1
+}
+Group	풍麗肌혼_-
+{
+	Vnum	51628 -- Cor Jadeit+ (Epic)
+	1	132000	1	756 -- Rare Dragon Jade
+	2	132010	1	2520
+	3	132020	1	840
+	4	132030	1	42
+	5	132040	1	42
+	6	132100	1	2520 -- Rare Dragon Jade
+	7	132110	1	8400
+	8	132120	1	2800
+	9	132130	1	140
+	10	132140	1	140
+	11	132200	1	840 -- Rare Dragon Jade
+	12	132210	1	2800
+	13	132220	1	933
+	14	132230	1	47
+	15	132240	1	47
+	16	132300	1	42 -- Rare Dragon Jade
+	17	132310	1	140
+	18	132320	1	47
+	19	132330	1	2
+	20	132340	1	2
+	21	132400	1	42 -- Rare Dragon Jade
+	22	132410	1	140
+	23	132420	1	47
+	24	132430	1	2
+	25	132440	1	2
+	26	133000	1	324 -- Antique Dragon Jade
+	27	133010	1	1080
+	28	133020	1	360
+	29	133030	1	18
+	30	133040	1	18
+	31	133100	1	1080 -- Antique Dragon Jade
+	32	133110	1	3600
+	33	133120	1	1200
+	34	133130	1	60
+	35	133140	1	60
+	36	133200	1	360 -- Antique Dragon Jade
+	37	133210	1	1200
+	38	133220	1	400
+	39	133230	1	20
+	40	133240	1	20
+	41	133300	1	18 -- Antique Dragon Jade
+	42	133310	1	60
+	43	133320	1	20
+	44	133330	1	1
+	45	133340	1	1
+	46	133400	1	18 -- Antique Dragon Jade
+	47	133410	1	60
+	48	133420	1	20
+	49	133430	1	1
+	50	133440	1	1
+}
+Group	철麗肌혼_-
+{
+	Vnum	51629 -- Cor Saphirum+ (Epic)
+	1	142000	1	756 -- Rare Dragon Sapphire
+	2	142010	1	2520
+	3	142020	1	840
+	4	142030	1	42
+	5	142040	1	42
+	6	142100	1	2520 -- Rare Dragon Sapphire
+	7	142110	1	8400
+	8	142120	1	2800
+	9	142130	1	140
+	10	142140	1	140
+	11	142200	1	840 -- Rare Dragon Sapphire
+	12	142210	1	2800
+	13	142220	1	933
+	14	142230	1	47
+	15	142240	1	47
+	16	142300	1	42 -- Rare Dragon Sapphire
+	17	142310	1	140
+	18	142320	1	47
+	19	142330	1	2
+	20	142340	1	2
+	21	142400	1	42 -- Rare Dragon Sapphire
+	22	142410	1	140
+	23	142420	1	47
+	24	142430	1	2
+	25	142440	1	2
+	26	143000	1	324 -- Antique Dragon Sapphire
+	27	143010	1	1080
+	28	143020	1	360
+	29	143030	1	18
+	30	143040	1	18
+	31	143100	1	1080 -- Antique Dragon Sapphire
+	32	143110	1	3600
+	33	143120	1	1200
+	34	143130	1	60
+	35	143140	1	60
+	36	143200	1	360 -- Antique Dragon Sapphire
+	37	143210	1	1200
+	38	143220	1	400
+	39	143230	1	20
+	40	143240	1	20
+	41	143300	1	18 -- Antique Dragon Sapphire
+	42	143310	1	60
+	43	143320	1	20
+	44	143330	1	1
+	45	143340	1	1
+	46	143400	1	18 -- Antique Dragon Sapphire
+	47	143410	1	60
+	48	143420	1	20
+	49	143430	1	1
+	50	143440	1	1
+}
+Group	麗肌혼_-
+{
+	Vnum	51630 -- Cor Granatum+ (Epic)
+	1	152000	1	756 -- Rare Dragon Garnet
+	2	152010	1	2520
+	3	152020	1	840
+	4	152030	1	42
+	5	152040	1	42
+	6	152100	1	2520 -- Rare Dragon Garnet
+	7	152110	1	8400
+	8	152120	1	2800
+	9	152130	1	140
+	10	152140	1	140
+	11	152200	1	840 -- Rare Dragon Garnet
+	12	152210	1	2800
+	13	152220	1	933
+	14	152230	1	47
+	15	152240	1	47
+	16	152300	1	42 -- Rare Dragon Garnet
+	17	152310	1	140
+	18	152320	1	47
+	19	152330	1	2
+	20	152340	1	2
+	21	152400	1	42 -- Rare Dragon Garnet
+	22	152410	1	140
+	23	152420	1	47
+	24	152430	1	2
+	25	152440	1	2
+	26	153000	1	324 -- Antique Dragon Garnet
+	27	153010	1	1080
+	28	153020	1	360
+	29	153030	1	18
+	30	153040	1	18
+	31	153100	1	1080 -- Antique Dragon Garnet
+	32	153110	1	3600
+	33	153120	1	1200
+	34	153130	1	60
+	35	153140	1	60
+	36	153200	1	360 -- Antique Dragon Garnet
+	37	153210	1	1200
+	38	153220	1	400
+	39	153230	1	20
+	40	153240	1	20
+	41	153300	1	18 -- Antique Dragon Garnet
+	42	153310	1	60
+	43	153320	1	20
+	44	153330	1	1
+	45	153340	1	1
+	46	153400	1	18 -- Antique Dragon Garnet
+	47	153410	1	60
+	48	153420	1	20
+	49	153430	1	1
+	50	153440	1	1
+}
+Group	麗肌혼_-
+{
+	Vnum	51631 -- Cor Atrum+ (Epic)
+	1	162000	1	756 -- Rare Dragon Onyx
+	2	162010	1	2520
+	3	162020	1	840
+	4	162030	1	42
+	5	162040	1	42
+	6	162100	1	2520 -- Rare Dragon Onyx
+	7	162110	1	8400
+	8	162120	1	2800
+	9	162130	1	140
+	10	162140	1	140
+	11	162200	1	840 -- Rare Dragon Onyx
+	12	162210	1	2800
+	13	162220	1	933
+	14	162230	1	47
+	15	162240	1	47
+	16	162300	1	42 -- Rare Dragon Onyx
+	17	162310	1	140
+	18	162320	1	47
+	19	162330	1	2
+	20	162340	1	2
+	21	162400	1	42 -- Rare Dragon Onyx
+	22	162410	1	140
+	23	162420	1	47
+	24	162430	1	2
+	25	162440	1	2
+	26	163000	1	324 -- Antique Dragon Onyx
+	27	163010	1	1080
+	28	163020	1	360
+	29	163030	1	18
+	30	163040	1	18
+	31	163100	1	1080 -- Antique Dragon Onyx
+	32	163110	1	3600
+	33	163120	1	1200
+	34	163130	1	60
+	35	163140	1	60
+	36	163200	1	360 -- Antique Dragon Onyx
+	37	163210	1	1200
+	38	163220	1	400
+	39	163230	1	20
+	40	163240	1	20
+	41	163300	1	18 -- Antique Dragon Onyx
+	42	163310	1	60
+	43	163320	1	20
+	44	163330	1	1
+	45	163340	1	1
+	46	163400	1	18 -- Antique Dragon Onyx
+	47	163410	1	60
+	48	163420	1	20
+	49	163430	1	1
+	50	163440	1	1
+}
+Group	肌혼_-
+{
+	Vnum	51632 -- Cor Draconis+ (Divine)
+	1	112000	1	972 -- Rare Dragon Diamond
+	2	112010	1	3240
+	3	112020	1	1080
+	4	112030	1	54
+	5	112040	1	54
+	6	112100	1	3240 -- Rare Dragon Diamond
+	7	112110	1	10800
+	8	112120	1	3600
+	9	112130	1	180
+	10	112140	1	180
+	11	112200	1	1080 -- Rare Dragon Diamond
+	12	112210	1	3600
+	13	112220	1	1200
+	14	112230	1	60
+	15	112240	1	60
+	16	112300	1	54 -- Rare Dragon Diamond
+	17	112310	1	180
+	18	112320	1	60
+	19	112330	1	3
+	20	112340	1	3
+	21	112400	1	54 -- Rare Dragon Diamond
+	22	112410	1	180
+	23	112420	1	60
+	24	112430	1	3
+	25	112440	1	3
+	26	113000	1	1944 -- Antique Dragon Diamond
+	27	113010	1	6480
+	28	113020	1	2160
+	29	113030	1	108
+	30	113040	1	108
+	31	113100	1	6480 -- Antique Dragon Diamond
+	32	113110	1	21600
+	33	113120	1	7200
+	34	113130	1	360
+	35	113140	1	360
+	36	113200	1	2160 -- Antique Dragon Diamond
+	37	113210	1	7200
+	38	113220	1	2400
+	39	113230	1	120
+	40	113240	1	120
+	41	113300	1	108 -- Antique Dragon Diamond
+	42	113310	1	360
+	43	113320	1	120
+	44	113330	1	6
+	45	113340	1	6
+	46	113400	1	108 -- Antique Dragon Diamond
+	47	113410	1	360
+	48	113420	1	120
+	49	113430	1	6
+	50	113440	1	6
+	51	114000	1	324 -- Legendary Dragon Diamond
+	52	114010	1	1080
+	53	114020	1	360
+	54	114030	1	18
+	55	114040	1	18
+	56	114100	1	1080 -- Legendary Dragon Diamond
+	57	114110	1	3600
+	58	114120	1	1200
+	59	114130	1	60
+	60	114140	1	60
+	61	114200	1	360 -- Legendary Dragon Diamond
+	62	114210	1	1200
+	63	114220	1	400
+	64	114230	1	20
+	65	114240	1	20
+	66	114300	1	18 -- Legendary Dragon Diamond
+	67	114310	1	60
+	68	114320	1	20
+	69	114330	1	1
+	70	114340	1	1
+	71	114400	1	18 -- Legendary Dragon Diamond
+	72	114410	1	60
+	73	114420	1	20
+	74	114430	1	1
+	75	114440	1	1
+	76	122000	1	972 -- Rare Dragon Ruby
+	77	122010	1	3240
+	78	122020	1	1080
+	79	122030	1	54
+	80	122040	1	54
+	81	122100	1	3240 -- Rare Dragon Ruby
+	82	122110	1	10800
+	83	122120	1	3600
+	84	122130	1	180
+	85	122140	1	180
+	86	122200	1	1080 -- Rare Dragon Ruby
+	87	122210	1	3600
+	88	122220	1	1200
+	89	122230	1	60
+	90	122240	1	60
+	91	122300	1	54 -- Rare Dragon Ruby
+	92	122310	1	180
+	93	122320	1	60
+	94	122330	1	3
+	95	122340	1	3
+	96	122400	1	54 -- Rare Dragon Ruby
+	97	122410	1	180
+	98	122420	1	60
+	99	122430	1	3
+	100	122440	1	3
+	101	123000	1	1944 -- Antique Dragon Ruby
+	102	123010	1	6480
+	103	123020	1	2160
+	104	123030	1	108
+	105	123040	1	108
+	106	123100	1	6480 -- Antique Dragon Ruby
+	107	123110	1	21600
+	108	123120	1	7200
+	109	123130	1	360
+	110	123140	1	360
+	111	123200	1	2160 -- Antique Dragon Ruby
+	112	123210	1	7200
+	113	123220	1	2400
+	114	123230	1	120
+	115	123240	1	120
+	116	123300	1	108 -- Antique Dragon Ruby
+	117	123310	1	360
+	118	123320	1	120
+	119	123330	1	6
+	120	123340	1	6
+	121	123400	1	108 -- Antique Dragon Ruby
+	122	123410	1	360
+	123	123420	1	120
+	124	123430	1	6
+	125	123440	1	6
+	126	124000	1	324 -- Legendary Dragon Ruby
+	127	124010	1	1080
+	128	124020	1	360
+	129	124030	1	18
+	130	124040	1	18
+	131	124100	1	1080 -- Legendary Dragon Ruby
+	132	124110	1	3600
+	133	124120	1	1200
+	134	124130	1	60
+	135	124140	1	60
+	136	124200	1	360 -- Legendary Dragon Ruby
+	137	124210	1	1200
+	138	124220	1	400
+	139	124230	1	20
+	140	124240	1	20
+	141	124300	1	18 -- Legendary Dragon Ruby
+	142	124310	1	60
+	143	124320	1	20
+	144	124330	1	1
+	145	124340	1	1
+	146	124400	1	18 -- Legendary Dragon Ruby
+	147	124410	1	60
+	148	124420	1	20
+	149	124430	1	1
+	150	124440	1	1
+	151	132000	1	972 -- Rare Dragon Jade
+	152	132010	1	3240
+	153	132020	1	1080
+	154	132030	1	54
+	155	132040	1	54
+	156	132100	1	3240 -- Rare Dragon Jade
+	157	132110	1	10800
+	158	132120	1	3600
+	159	132130	1	180
+	160	132140	1	180
+	161	132200	1	1080 -- Rare Dragon Jade
+	162	132210	1	3600
+	163	132220	1	1200
+	164	132230	1	60
+	165	132240	1	60
+	166	132300	1	54 -- Rare Dragon Jade
+	167	132310	1	180
+	168	132320	1	60
+	169	132330	1	3
+	170	132340	1	3
+	171	132400	1	54 -- Rare Dragon Jade
+	172	132410	1	180
+	173	132420	1	60
+	174	132430	1	3
+	175	132440	1	3
+	176	133000	1	1944 -- Antique Dragon Jade
+	177	133010	1	6480
+	178	133020	1	2160
+	179	133030	1	108
+	180	133040	1	108
+	181	133100	1	6480 -- Antique Dragon Jade
+	182	133110	1	21600
+	183	133120	1	7200
+	184	133130	1	360
+	185	133140	1	360
+	186	133200	1	2160 -- Antique Dragon Jade
+	187	133210	1	7200
+	188	133220	1	2400
+	189	133230	1	120
+	190	133240	1	120
+	191	133300	1	108 -- Antique Dragon Jade
+	192	133310	1	360
+	193	133320	1	120
+	194	133330	1	6
+	195	133340	1	6
+	196	133400	1	108 -- Antique Dragon Jade
+	197	133410	1	360
+	198	133420	1	120
+	199	133430	1	6
+	200	133440	1	6
+	201	134000	1	324 -- Legendary Dragon Jade
+	202	134010	1	1080
+	203	134020	1	360
+	204	134030	1	18
+	205	134040	1	18
+	206	134100	1	1080 -- Legendary Dragon Jade
+	207	134110	1	3600
+	208	134120	1	1200
+	209	134130	1	60
+	210	134140	1	60
+	211	134200	1	360 -- Legendary Dragon Jade
+	212	134210	1	1200
+	213	134220	1	400
+	214	134230	1	20
+	215	134240	1	20
+	216	134300	1	18 -- Legendary Dragon Jade
+	217	134310	1	60
+	218	134320	1	20
+	219	134330	1	1
+	220	134340	1	1
+	221	134400	1	18 -- Legendary Dragon Jade
+	222	134410	1	60
+	223	134420	1	20
+	224	134430	1	1
+	225	134440	1	1
+	226	142000	1	972 -- Rare Dragon Sapphire
+	227	142010	1	3240
+	228	142020	1	1080
+	229	142030	1	54
+	230	142040	1	54
+	231	142100	1	3240 -- Rare Dragon Sapphire
+	232	142110	1	10800
+	233	142120	1	3600
+	234	142130	1	180
+	235	142140	1	180
+	236	142200	1	1080 -- Rare Dragon Sapphire
+	237	142210	1	3600
+	238	142220	1	1200
+	239	142230	1	60
+	240	142240	1	60
+	241	142300	1	54 -- Rare Dragon Sapphire
+	242	142310	1	180
+	243	142320	1	60
+	244	142330	1	3
+	245	142340	1	3
+	246	142400	1	54 -- Rare Dragon Sapphire
+	247	142410	1	180
+	248	142420	1	60
+	249	142430	1	3
+	250	142440	1	3
+	251	143000	1	1944 -- Antique Dragon Sapphire
+	252	143010	1	6480
+	253	143020	1	2160
+	254	143030	1	108
+	255	143040	1	108
+	256	143100	1	6480 -- Antique Dragon Sapphire
+	257	143110	1	21600
+	258	143120	1	7200
+	259	143130	1	360
+	260	143140	1	360
+	261	143200	1	2160 -- Antique Dragon Sapphire
+	262	143210	1	7200
+	263	143220	1	2400
+	264	143230	1	120
+	265	143240	1	120
+	266	143300	1	108 -- Antique Dragon Sapphire
+	267	143310	1	360
+	268	143320	1	120
+	269	143330	1	6
+	270	143340	1	6
+	271	143400	1	108 -- Antique Dragon Sapphire
+	272	143410	1	360
+	273	143420	1	120
+	274	143430	1	6
+	275	143440	1	6
+	276	144000	1	324 -- Legendary DragonSapphire
+	277	144010	1	1080
+	278	144020	1	360
+	279	144030	1	18
+	280	144040	1	18
+	281	144100	1	1080 -- Legendary DragonSapphire
+	282	144110	1	3600
+	283	144120	1	1200
+	284	144130	1	60
+	285	144140	1	60
+	286	144200	1	360 -- Legendary DragonSapphire
+	287	144210	1	1200
+	288	144220	1	400
+	289	144230	1	20
+	290	144240	1	20
+	291	144300	1	18 -- Legendary DragonSapphire
+	292	144310	1	60
+	293	144320	1	20
+	294	144330	1	1
+	295	144340	1	1
+	296	144400	1	18 -- Legendary DragonSapphire
+	297	144410	1	60
+	298	144420	1	20
+	299	144430	1	1
+	300	144440	1	1
+	301	152000	1	972 -- Rare Dragon Garnet
+	302	152010	1	3240
+	303	152020	1	1080
+	304	152030	1	54
+	305	152040	1	54
+	306	152100	1	3240 -- Rare Dragon Garnet
+	307	152110	1	10800
+	308	152120	1	3600
+	309	152130	1	180
+	310	152140	1	180
+	311	152200	1	1080 -- Rare Dragon Garnet
+	312	152210	1	3600
+	313	152220	1	1200
+	314	152230	1	60
+	315	152240	1	60
+	316	152300	1	54 -- Rare Dragon Garnet
+	317	152310	1	180
+	318	152320	1	60
+	319	152330	1	3
+	320	152340	1	3
+	321	152400	1	54 -- Rare Dragon Garnet
+	322	152410	1	180
+	323	152420	1	60
+	324	152430	1	3
+	325	152440	1	3
+	326	153000	1	1944 -- Antique Dragon Garnet
+	327	153010	1	6480
+	328	153020	1	2160
+	329	153030	1	108
+	330	153040	1	108
+	331	153100	1	6480 -- Antique Dragon Garnet
+	332	153110	1	21600
+	333	153120	1	7200
+	334	153130	1	360
+	335	153140	1	360
+	336	153200	1	2160 -- Antique Dragon Garnet
+	337	153210	1	7200
+	338	153220	1	2400
+	339	153230	1	120
+	340	153240	1	120
+	341	153300	1	108 -- Antique Dragon Garnet
+	342	153310	1	360
+	343	153320	1	120
+	344	153330	1	6
+	345	153340	1	6
+	346	153400	1	108 -- Antique Dragon Garnet
+	347	153410	1	360
+	348	153420	1	120
+	349	153430	1	6
+	350	153440	1	6
+	351	154000	1	324 -- Legendary Dragon Garnet
+	352	154010	1	1080
+	353	154020	1	360
+	354	154030	1	18
+	355	154040	1	18
+	356	154100	1	1080 -- Legendary Dragon Garnet
+	357	154110	1	3600
+	358	154120	1	1200
+	359	154130	1	60
+	360	154140	1	60
+	361	154200	1	360 -- Legendary Dragon Garnet
+	362	154210	1	1200
+	363	154220	1	400
+	364	154230	1	20
+	365	154240	1	20
+	366	154300	1	18 -- Legendary Dragon Garnet
+	367	154310	1	60
+	368	154320	1	20
+	369	154330	1	1
+	370	154340	1	1
+	371	154400	1	18 -- Legendary Dragon Garnet
+	372	154410	1	60
+	373	154420	1	20
+	374	154430	1	1
+	375	154440	1	1
+	376	162000	1	972 -- Rare Dragon Onyx
+	377	162010	1	3240
+	378	162020	1	1080
+	379	162030	1	54
+	380	162040	1	54
+	381	162100	1	3240 -- Rare Dragon Onyx
+	382	162110	1	10800
+	383	162120	1	3600
+	384	162130	1	180
+	385	162140	1	180
+	386	162200	1	1080 -- Rare Dragon Onyx
+	387	162210	1	3600
+	388	162220	1	1200
+	389	162230	1	60
+	390	162240	1	60
+	391	162300	1	54 -- Rare Dragon Onyx
+	392	162310	1	180
+	393	162320	1	60
+	394	162330	1	3
+	395	162340	1	3
+	396	162400	1	54 -- Rare Dragon Onyx
+	397	162410	1	180
+	398	162420	1	60
+	399	162430	1	3
+	400	162440	1	3
+	401	163000	1	1944 -- Antique Dragon Onyx
+	402	163010	1	6480
+	403	163020	1	2160
+	404	163030	1	108
+	405	163040	1	108
+	406	163100	1	6480 -- Antique Dragon Onyx
+	407	163110	1	21600
+	408	163120	1	7200
+	409	163130	1	360
+	410	163140	1	360
+	411	163200	1	2160 -- Antique Dragon Onyx
+	412	163210	1	7200
+	413	163220	1	2400
+	414	163230	1	120
+	415	163240	1	120
+	416	163300	1	108 -- Antique Dragon Onyx
+	417	163310	1	360
+	418	163320	1	120
+	419	163330	1	6
+	420	163340	1	6
+	421	163400	1	108 -- Antique Dragon Onyx
+	422	163410	1	360
+	423	163420	1	120
+	424	163430	1	6
+	425	163440	1	6
+	426	164000	1	324 -- Legendary Dragon Onyx
+	427	164010	1	1080
+	428	164020	1	360
+	429	164030	1	18
+	430	164040	1	18
+	431	164100	1	1080 -- Legendary Dragon Onyx
+	432	164110	1	3600
+	433	164120	1	1200
+	434	164130	1	60
+	435	164140	1	60
+	436	164200	1	360 -- Legendary Dragon Onyx
+	437	164210	1	1200
+	438	164220	1	400
+	439	164230	1	20
+	440	164240	1	20
+	441	164300	1	18 -- Legendary Dragon Onyx
+	442	164310	1	60
+	443	164320	1	20
+	444	164330	1	1
+	445	164340	1	1
+	446	164400	1	18 -- Legendary Dragon Onyx
+	447	164410	1	60
+	448	164420	1	20
+	449	164430	1	1
+	450	164440	1	1
+}
+Group	麗肌혼_-
+{
+	Vnum	51633 -- Cor Diamas+ (Divine)
+	1	112000	1	972 -- Rare Dragon Diamond
+	2	112010	1	3240
+	3	112020	1	1080
+	4	112030	1	54
+	5	112040	1	54
+	6	112100	1	3240 -- Rare Dragon Diamond
+	7	112110	1	10800
+	8	112120	1	3600
+	9	112130	1	180
+	10	112140	1	180
+	11	112200	1	1080 -- Rare Dragon Diamond
+	12	112210	1	3600
+	13	112220	1	1200
+	14	112230	1	60
+	15	112240	1	60
+	16	112300	1	54 -- Rare Dragon Diamond
+	17	112310	1	180
+	18	112320	1	60
+	19	112330	1	3
+	20	112340	1	3
+	21	112400	1	54 -- Rare Dragon Diamond
+	22	112410	1	180
+	23	112420	1	60
+	24	112430	1	3
+	25	112440	1	3
+	26	113000	1	1944 -- Antique Dragon Diamond
+	27	113010	1	6480
+	28	113020	1	2160
+	29	113030	1	108
+	30	113040	1	108
+	31	113100	1	6480 -- Antique Dragon Diamond
+	32	113110	1	21600
+	33	113120	1	7200
+	34	113130	1	360
+	35	113140	1	360
+	36	113200	1	2160 -- Antique Dragon Diamond
+	37	113210	1	7200
+	38	113220	1	2400
+	39	113230	1	120
+	40	113240	1	120
+	41	113300	1	108 -- Antique Dragon Diamond
+	42	113310	1	360
+	43	113320	1	120
+	44	113330	1	6
+	45	113340	1	6
+	46	113400	1	108 -- Antique Dragon Diamond
+	47	113410	1	360
+	48	113420	1	120
+	49	113430	1	6
+	50	113440	1	6
+	51	114000	1	324 -- Legendary Dragon Diamond
+	52	114010	1	1080
+	53	114020	1	360
+	54	114030	1	18
+	55	114040	1	18
+	56	114100	1	1080 -- Legendary Dragon Diamond
+	57	114110	1	3600
+	58	114120	1	1200
+	59	114130	1	60
+	60	114140	1	60
+	61	114200	1	360 -- Legendary Dragon Diamond
+	62	114210	1	1200
+	63	114220	1	400
+	64	114230	1	20
+	65	114240	1	20
+	66	114300	1	18 -- Legendary Dragon Diamond
+	67	114310	1	60
+	68	114320	1	20
+	69	114330	1	1
+	70	114340	1	1
+	71	114400	1	18 -- Legendary Dragon Diamond
+	72	114410	1	60
+	73	114420	1	20
+	74	114430	1	1
+	75	114440	1	1
+}
+Group	화麗肌혼_-
+{
+	Vnum	51634 -- Cor Rubinum+ (Divine)
+	1	122000	1	972 -- Rare Dragon Ruby
+	2	122010	1	3240
+	3	122020	1	1080
+	4	122030	1	54
+	5	122040	1	54
+	6	122100	1	3240 -- Rare Dragon Ruby
+	7	122110	1	10800
+	8	122120	1	3600
+	9	122130	1	180
+	10	122140	1	180
+	11	122200	1	1080 -- Rare Dragon Ruby
+	12	122210	1	3600
+	13	122220	1	1200
+	14	122230	1	60
+	15	122240	1	60
+	16	122300	1	54 -- Rare Dragon Ruby
+	17	122310	1	180
+	18	122320	1	60
+	19	122330	1	3
+	20	122340	1	3
+	21	122400	1	54 -- Rare Dragon Ruby
+	22	122410	1	180
+	23	122420	1	60
+	24	122430	1	3
+	25	122440	1	3
+	26	123000	1	1944 -- Antique Dragon Ruby
+	27	123010	1	6480
+	28	123020	1	2160
+	29	123030	1	108
+	30	123040	1	108
+	31	123100	1	6480 -- Antique Dragon Ruby
+	32	123110	1	21600
+	33	123120	1	7200
+	34	123130	1	360
+	35	123140	1	360
+	36	123200	1	2160 -- Antique Dragon Ruby
+	37	123210	1	7200
+	38	123220	1	2400
+	39	123230	1	120
+	40	123240	1	120
+	41	123300	1	108 -- Antique Dragon Ruby
+	42	123310	1	360
+	43	123320	1	120
+	44	123330	1	6
+	45	123340	1	6
+	46	123400	1	108 -- Antique Dragon Ruby
+	47	123410	1	360
+	48	123420	1	120
+	49	123430	1	6
+	50	123440	1	6
+	51	124000	1	324 -- Legendary Dragon Ruby
+	52	124010	1	1080
+	53	124020	1	360
+	54	124030	1	18
+	55	124040	1	18
+	56	124100	1	1080 -- Legendary Dragon Ruby
+	57	124110	1	3600
+	58	124120	1	1200
+	59	124130	1	60
+	60	124140	1	60
+	61	124200	1	360 -- Legendary Dragon Ruby
+	62	124210	1	1200
+	63	124220	1	400
+	64	124230	1	20
+	65	124240	1	20
+	66	124300	1	18 -- Legendary Dragon Ruby
+	67	124310	1	60
+	68	124320	1	20
+	69	124330	1	1
+	70	124340	1	1
+	71	124400	1	18 -- Legendary Dragon Ruby
+	72	124410	1	60
+	73	124420	1	20
+	74	124430	1	1
+	75	124440	1	1
+}
+Group	풍麗肌혼_-
+{
+	Vnum	51635 -- Cor Jadeit+ (Divine)
+	1	132000	1	972 -- Rare Dragon Jade
+	2	132010	1	3240
+	3	132020	1	1080
+	4	132030	1	54
+	5	132040	1	54
+	6	132100	1	3240 -- Rare Dragon Jade
+	7	132110	1	10800
+	8	132120	1	3600
+	9	132130	1	180
+	10	132140	1	180
+	11	132200	1	1080 -- Rare Dragon Jade
+	12	132210	1	3600
+	13	132220	1	1200
+	14	132230	1	60
+	15	132240	1	60
+	16	132300	1	54 -- Rare Dragon Jade
+	17	132310	1	180
+	18	132320	1	60
+	19	132330	1	3
+	20	132340	1	3
+	21	132400	1	54 -- Rare Dragon Jade
+	22	132410	1	180
+	23	132420	1	60
+	24	132430	1	3
+	25	132440	1	3
+	26	133000	1	1944 -- Antique Dragon Jade
+	27	133010	1	6480
+	28	133020	1	2160
+	29	133030	1	108
+	30	133040	1	108
+	31	133100	1	6480 -- Antique Dragon Jade
+	32	133110	1	21600
+	33	133120	1	7200
+	34	133130	1	360
+	35	133140	1	360
+	36	133200	1	2160 -- Antique Dragon Jade
+	37	133210	1	7200
+	38	133220	1	2400
+	39	133230	1	120
+	40	133240	1	120
+	41	133300	1	108 -- Antique Dragon Jade
+	42	133310	1	360
+	43	133320	1	120
+	44	133330	1	6
+	45	133340	1	6
+	46	133400	1	108 -- Antique Dragon Jade
+	47	133410	1	360
+	48	133420	1	120
+	49	133430	1	6
+	50	133440	1	6
+	51	134000	1	324 -- Legendary Dragon Jade
+	52	134010	1	1080
+	53	134020	1	360
+	54	134030	1	18
+	55	134040	1	18
+	56	134100	1	1080 -- Legendary Dragon Jade
+	57	134110	1	3600
+	58	134120	1	1200
+	59	134130	1	60
+	60	134140	1	60
+	61	134200	1	360 -- Legendary Dragon Jade
+	62	134210	1	1200
+	63	134220	1	400
+	64	134230	1	20
+	65	134240	1	20
+	66	134300	1	18 -- Legendary Dragon Jade
+	67	134310	1	60
+	68	134320	1	20
+	69	134330	1	1
+	70	134340	1	1
+	71	134400	1	18 -- Legendary Dragon Jade
+	72	134410	1	60
+	73	134420	1	20
+	74	134430	1	1
+	75	134440	1	1
+}
+Group	철麗肌혼_-
+{
+	Vnum	51636 -- Cor Saphirum+ (Divine)
+	1	142000	1	972 -- Rare Dragon Sapphire
+	2	142010	1	3240
+	3	142020	1	1080
+	4	142030	1	54
+	5	142040	1	54
+	6	142100	1	3240 -- Rare Dragon Sapphire
+	7	142110	1	10800
+	8	142120	1	3600
+	9	142130	1	180
+	10	142140	1	180
+	11	142200	1	1080 -- Rare Dragon Sapphire
+	12	142210	1	3600
+	13	142220	1	1200
+	14	142230	1	60
+	15	142240	1	60
+	16	142300	1	54 -- Rare Dragon Sapphire
+	17	142310	1	180
+	18	142320	1	60
+	19	142330	1	3
+	20	142340	1	3
+	21	142400	1	54 -- Rare Dragon Sapphire
+	22	142410	1	180
+	23	142420	1	60
+	24	142430	1	3
+	25	142440	1	3
+	26	143000	1	1944 -- Antique Dragon Sapphire
+	27	143010	1	6480
+	28	143020	1	2160
+	29	143030	1	108
+	30	143040	1	108
+	31	143100	1	6480 -- Antique Dragon Sapphire
+	32	143110	1	21600
+	33	143120	1	7200
+	34	143130	1	360
+	35	143140	1	360
+	36	143200	1	2160 -- Antique Dragon Sapphire
+	37	143210	1	7200
+	38	143220	1	2400
+	39	143230	1	120
+	40	143240	1	120
+	41	143300	1	108 -- Antique Dragon Sapphire
+	42	143310	1	360
+	43	143320	1	120
+	44	143330	1	6
+	45	143340	1	6
+	46	143400	1	108 -- Antique Dragon Sapphire
+	47	143410	1	360
+	48	143420	1	120
+	49	143430	1	6
+	50	143440	1	6
+	51	144000	1	324 -- Legendary DragonSapphire
+	52	144010	1	1080
+	53	144020	1	360
+	54	144030	1	18
+	55	144040	1	18
+	56	144100	1	1080 -- Legendary DragonSapphire
+	57	144110	1	3600
+	58	144120	1	1200
+	59	144130	1	60
+	60	144140	1	60
+	61	144200	1	360 -- Legendary DragonSapphire
+	62	144210	1	1200
+	63	144220	1	400
+	64	144230	1	20
+	65	144240	1	20
+	66	144300	1	18 -- Legendary DragonSapphire
+	67	144310	1	60
+	68	144320	1	20
+	69	144330	1	1
+	70	144340	1	1
+	71	144400	1	18 -- Legendary DragonSapphire
+	72	144410	1	60
+	73	144420	1	20
+	74	144430	1	1
+	75	144440	1	1
+}
+Group	麗肌혼_-
+{
+	Vnum	51637 -- Cor Granatum+ (Divine)
+	1	152000	1	972 -- Rare Dragon Garnet
+	2	152010	1	3240
+	3	152020	1	1080
+	4	152030	1	54
+	5	152040	1	54
+	6	152100	1	3240 -- Rare Dragon Garnet
+	7	152110	1	10800
+	8	152120	1	3600
+	9	152130	1	180
+	10	152140	1	180
+	11	152200	1	1080 -- Rare Dragon Garnet
+	12	152210	1	3600
+	13	152220	1	1200
+	14	152230	1	60
+	15	152240	1	60
+	16	152300	1	54 -- Rare Dragon Garnet
+	17	152310	1	180
+	18	152320	1	60
+	19	152330	1	3
+	20	152340	1	3
+	21	152400	1	54 -- Rare Dragon Garnet
+	22	152410	1	180
+	23	152420	1	60
+	24	152430	1	3
+	25	152440	1	3
+	26	153000	1	1944 -- Antique Dragon Garnet
+	27	153010	1	6480
+	28	153020	1	2160
+	29	153030	1	108
+	30	153040	1	108
+	31	153100	1	6480 -- Antique Dragon Garnet
+	32	153110	1	21600
+	33	153120	1	7200
+	34	153130	1	360
+	35	153140	1	360
+	36	153200	1	2160 -- Antique Dragon Garnet
+	37	153210	1	7200
+	38	153220	1	2400
+	39	153230	1	120
+	40	153240	1	120
+	41	153300	1	108 -- Antique Dragon Garnet
+	42	153310	1	360
+	43	153320	1	120
+	44	153330	1	6
+	45	153340	1	6
+	46	153400	1	108 -- Antique Dragon Garnet
+	47	153410	1	360
+	48	153420	1	120
+	49	153430	1	6
+	50	153440	1	6
+	51	154000	1	324 -- Legendary Dragon Garnet
+	52	154010	1	1080
+	53	154020	1	360
+	54	154030	1	18
+	55	154040	1	18
+	56	154100	1	1080 -- Legendary Dragon Garnet
+	57	154110	1	3600
+	58	154120	1	1200
+	59	154130	1	60
+	60	154140	1	60
+	61	154200	1	360 -- Legendary Dragon Garnet
+	62	154210	1	1200
+	63	154220	1	400
+	64	154230	1	20
+	65	154240	1	20
+	66	154300	1	18 -- Legendary Dragon Garnet
+	67	154310	1	60
+	68	154320	1	20
+	69	154330	1	1
+	70	154340	1	1
+	71	154400	1	18 -- Legendary Dragon Garnet
+	72	154410	1	60
+	73	154420	1	20
+	74	154430	1	1
+	75	154440	1	1
+}
+Group	麗肌혼_-
+{
+	Vnum	51638 -- Cor Atrum+ (Divine)
+	1	162000	1	972 -- Rare Dragon Onyx
+	2	162010	1	3240
+	3	162020	1	1080
+	4	162030	1	54
+	5	162040	1	54
+	6	162100	1	3240 -- Rare Dragon Onyx
+	7	162110	1	10800
+	8	162120	1	3600
+	9	162130	1	180
+	10	162140	1	180
+	11	162200	1	1080 -- Rare Dragon Onyx
+	12	162210	1	3600
+	13	162220	1	1200
+	14	162230	1	60
+	15	162240	1	60
+	16	162300	1	54 -- Rare Dragon Onyx
+	17	162310	1	180
+	18	162320	1	60
+	19	162330	1	3
+	20	162340	1	3
+	21	162400	1	54 -- Rare Dragon Onyx
+	22	162410	1	180
+	23	162420	1	60
+	24	162430	1	3
+	25	162440	1	3
+	26	163000	1	1944 -- Antique Dragon Onyx
+	27	163010	1	6480
+	28	163020	1	2160
+	29	163030	1	108
+	30	163040	1	108
+	31	163100	1	6480 -- Antique Dragon Onyx
+	32	163110	1	21600
+	33	163120	1	7200
+	34	163130	1	360
+	35	163140	1	360
+	36	163200	1	2160 -- Antique Dragon Onyx
+	37	163210	1	7200
+	38	163220	1	2400
+	39	163230	1	120
+	40	163240	1	120
+	41	163300	1	108 -- Antique Dragon Onyx
+	42	163310	1	360
+	43	163320	1	120
+	44	163330	1	6
+	45	163340	1	6
+	46	163400	1	108 -- Antique Dragon Onyx
+	47	163410	1	360
+	48	163420	1	120
+	49	163430	1	6
+	50	163440	1	6
+	51	164000	1	324 -- Legendary Dragon Onyx
+	52	164010	1	1080
+	53	164020	1	360
+	54	164030	1	18
+	55	164040	1	18
+	56	164100	1	1080 -- Legendary Dragon Onyx
+	57	164110	1	3600
+	58	164120	1	1200
+	59	164130	1	60
+	60	164140	1	60
+	61	164200	1	360 -- Legendary Dragon Onyx
+	62	164210	1	1200
+	63	164220	1	400
+	64	164230	1	20
+	65	164240	1	20
+	66	164300	1	18 -- Legendary Dragon Onyx
+	67	164310	1	60
+	68	164320	1	20
+	69	164330	1	1
+	70	164340	1	1
+	71	164400	1	18 -- Legendary Dragon Onyx
+	72	164410	1	60
+	73	164420	1	20
+	74	164430	1	1
+	75	164440	1	1
+}
+Group	病
+{
+	Vnum	50109 -- Red Ebony Box
+	1	50300	1	15 -- Skill Book
+	2	70102	1	10 -- Zen Bean
+	3	25040	1	5 -- Blessing Scroll
+	4	71044	5	35 -- Critical Strike
+	5	71045	5	30 -- Piercing Strike
+	6	72003	1	5 -- Experience Ring (3h)
+	7	72006	1	5 -- Thief's Gloves
+}
+Group	황病
+{
+	Vnum	50110 -- Pomp Ebony Box
+	1	50300	1	25 -- Skill Book
+	2	25040	1	10 -- Blessing Scroll
+	3	71032	1	5 -- Dragon Scroll
+	4	70003	1	20 -- Book of the Leader
+	5	72003	1	20 -- Experience Ring (3h)
+	6	72006	1	20 -- Thief's Gloves
+}
+Group	病
+{
+	Vnum	50111 -- Yellow Ebony Box
+	1	70048	1	5 -- Cloak of Secrecy
+	2	70049	1	5 -- Lucy's Ring
+	3	70050	1	5 -- Sage King's Symbol
+	4	70051	1	5 -- Sage King's Glove
+	5	70052	1	5 -- Charm of Karma1
+	6	50513	1	10 -- Soul Stone
+	7	50300	1	10 -- Skill Book
+	8	70102	1	10 -- Zen Bean
+	9	25040	1	5 -- Blessing Scroll
+	10	71032	1	5 -- Dragon Scroll
+	11	72003	1	15 -- Experience Ring (3h)
+	12	72006	1	15 -- Thief's Gloves
+}
+Group	貫病
+{
+	Vnum	50112 -- Lightgreen Ebony Box
+	1	71085	1	5 -- Reinforce Item
+	2	71084	1	5 -- Enchant Item
+	3	50513	1	10 -- Soul Stone
+	4	70102	1	10 -- Zen Bean
+	5	25040	1	5 -- Blessing Scroll
+	6	71032	1	5 -- Dragon Scroll
+	7	72003	1	30 -- Experience Ring (3h)
+	8	72006	1	30 -- Thief's Gloves
+}
+Group	病
+{
+	Vnum	50113 -- Green Ebony Box
+	1	71085	1	5 -- Reinforce Item
+	2	71084	1	5 -- Enchant Item
+	3	50513	1	10 -- Soul Stone
+	4	70102	1	10 -- Zen Bean
+	5	25040	1	5 -- Blessing Scroll
+	6	71032	1	5 -- Dragon Scroll
+	7	71044	5	30 -- Critical Strike
+	8	71045	5	30 -- Piercing Strike
+}
+Group	캘病
+{
+	Vnum	50114 -- Blue Ebony Box
+	1	71085	1	5 -- Reinforce Item
+	2	71084	1	5 -- Enchant Item
+	3	50513	1	10 -- Soul Stone
+	4	70102	1	10 -- Zen Bean
+	5	25040	1	5 -- Blessing Scroll
+	6	71032	1	5 -- Dragon Scroll
+	7	71044	5	30 -- Critical Strike
+	8	71045	5	30 -- Piercing Strike
+}
+Group	病
+{
+	Vnum	50115 -- Crimson Ebony Box
+	1	71085	1	5 -- Reinforce Item
+	2	71084	1	5 -- Enchant Item
+	3	50513	1	10 -- Soul Stone
+	4	70102	1	10 -- Zen Bean
+	5	25040	1	5 -- Blessing Scroll
+	6	71032	1	5 -- Dragon Scroll
+	7	71044	5	30 -- Critical Strike
+	8	71045	5	30 -- Piercing Strike
+}
+Group	크遣트(潁)
+{
+	Vnum	50010 -- Stocking
+	1	80003	1	8 -- Silver Bar (50,000 Yang)
+	2	慕	5000	1 -- Yang
+	3	慕	10000	1 -- Yang
+	4	慕	15000	1 -- Yang
+	5	慕	20000	1 -- Yang
+	6	慕	25000	1 -- Yang
+	7	慕	30000	1 -- Yang
+	8	慕	35000	1 -- Yang
+	9	慕	40000	1 -- Yang
+	10	50300	1	8 -- Skill Book
+	11	70201	1	8 -- Bleach
+	12	70206	1	8 -- Black Hair Dye
+	13	70203	1	8 -- Blonde Hair Dye
+	14	70202	1	8 -- White Hair Dye
+	15	70204	1	8 -- Red Hair Dye
+	16	70205	1	8 -- Brown Hair Dye
+	17	70048	1	8 -- Cloak of Secrecy
+	18	70049	1	8 -- Lucy's Ring
+	19	70050	1	8 -- Sage King's Symbol
+	20	70051	1	8 -- Sage King's Glove
+	21	70102	1	8 -- Zen Bean
+	22	71006	1	8 -- Language Ring
+	23	70008	1	8 -- White Flag
+	24	70012	1	8 -- Goddess Tear
+	25	70038	1	8 -- Bravery Cape
+	26	27006	15	8 -- Blue Potion (L)
+	27	27003	15	8 -- Red Potion (L)
+	28	27005	30	8 -- Blue Potion (M)
+	29	27002	30	8 -- Red Potion (M)
+}
+Group	
+{
+	Vnum	50011 -- Moonlight Treasure Chest
+	1	50311	1	1 -- Shinsoo Linguistics
+	2	50312	1	1 -- Chunjo Linguistics
+	3	50313	1	1 -- Jinno Linguistics
+	4	70048	1	1 -- Cloak of Secrecy
+	5	70102	1	1 -- Zen Bean
+	6	70051	1	1 -- Sage King's Glove
+	7	70049	1	1 -- Lucy's Ring
+	8	70006	1	1 -- Language Ring
+	9	71045	5	1 -- Piercing Strike
+	10	71018	5	1 -- Blessing of Life
+	11	71020	5	1 -- Blessing of the Dragon
+	12	71044	5	1 -- Critical Strike
+	13	25040	1	1 -- Blessing Scroll
+	14	71032	1	1 -- Dragon Scroll
+	15	71004	10	1 -- Medal of the Dragon
+	16	70035	1	1 -- Magic Copper Ore
+	17	70024	1	1 -- Blessing Marble
+	18	group	426	1
+	19	group	8501	1
+	20	group	2209	1
+}
+Group	諍롸머
+{
+	Vnum	50023 -- Money Pouch
+	1	慕	50000	5 -- Yang
+	2	慕	40000	10 -- Yang
+	3	慕	30000	15 -- Yang
+	4	慕	20000	20 -- Yang
+	5	慕	10000	50 -- Yang
+}
+Group	
+{
+	Vnum	50024 -- Rose
+	1	50300	1	3 -- Skill Book
+	2	70102	1	1 -- Zen Bean
+	3	25040	1	1 -- Blessing Scroll
+	4	80003	1	5 -- Silver Bar (50,000 Yang)
+	5	27003	5	10 -- Red Potion (L)
+	6	27006	5	15 -- Blue Potion (L)
+	7	27002	5	25 -- Red Potion (M)
+	8	27005	5	40 -- Blue Potion (M)
+}
+Group	賻
+{
+	Vnum	50025 -- Chocolate
+	1	50300	1	3 -- Skill Book
+	2	70102	1	1 -- Zen Bean
+	3	25040	1	1 -- Blessing Scroll
+	4	80003	1	5 -- Silver Bar (50,000 Yang)
+	5	27003	5	10 -- Red Potion (L)
+	6	27006	5	15 -- Blue Potion (L)
+	7	27002	5	25 -- Red Potion (M)
+	8	27005	5	40 -- Blue Potion (M)
+}
+Group	
+{
+	Vnum	50031 -- Rose
+	1	50300	1	3 -- Skill Book
+	2	70102	1	1 -- Zen Bean
+	3	25040	1	1 -- Blessing Scroll
+	4	80003	1	5 -- Silver Bar (50,000 Yang)
+	5	27003	5	10 -- Red Potion (L)
+	6	27006	5	15 -- Blue Potion (L)
+	7	27002	5	25 -- Red Potion (M)
+	8	27005	5	40 -- Blue Potion (M)
+}
+Group	
+{
+	Vnum	50032 -- Candy
+	1	50300	1	3 -- Skill Book
+	2	70102	1	1 -- Zen Bean
+	3	25040	1	1 -- Blessing Scroll
+	4	80003	1	5 -- Silver Bar (50,000 Yang)
+	5	27003	5	10 -- Red Potion (L)
+	6	27006	5	15 -- Blue Potion (L)
+	7	27002	5	25 -- Red Potion (M)
+	8	27005	5	40 -- Blue Potion (M)
+}
+Group	鋼쨩
+{
+	Vnum	50033 -- Mysterious Chest
+	1	치	10000	80 -- Exp.
+	2	치	20000	70 -- Exp.
+	3	치	30000	60 -- Exp.
+	4	치	40000	50 -- Exp.
+	5	치	50000	40 -- Exp.
+	6	慕	10000	80 -- Yang
+	7	慕	20000	70 -- Yang
+	8	慕	30000	65 -- Yang
+	9	慕	40000	55 -- Yang
+	10	慕	50000	49 -- Yang
+	11	50300	1	10 -- Skill Book
+	12	70102	1	20 -- Zen Bean
+	13	25040	1	1 -- Blessing Scroll
+	14	group	8501	30
+	15	group	8502	30
+	16	group	8503	30
+	17	group	8504	30
+	18	group	8505	30
+	19	group	8506	40
+	20	group	8507	40
+	21	group	8508	30
+	22	group	8509	30
+	23	group	8510	30
+	24	group	8511	30
+}
+Group	低겁_3
+{
+	Vnum	50035 -- Gift (yellow)
+	1	치	30000	100 -- Exp.
+	2	치	50000	120 -- Exp.
+	3	치	70000	100 -- Exp.
+	4	치	100000	80 -- Exp.
+	5	慕	30000	160 -- Yang
+	6	慕	50000	140 -- Yang
+	7	80004	1	60 -- Silver Bar(100,000 Yang)
+	8	80005	1	5 -- Gold Bar (500,000 Yang)
+	9	50300	1	15 -- Skill Book
+	10	25040	1	10 -- Blessing Scroll
+	11	71032	1	5 -- Dragon Scroll
+	12	71004	10	30 -- Medal of the Dragon
+	13	70003	1	15 -- Book of the Leader
+	14	71018	10	40 -- Blessing of Life
+	15	71019	10	40 -- Blessing of Magic
+	16	71020	10	20 -- Blessing of the Dragon
+	17	50008	1	20 -- Gold Key
+	18	50108	10	30 -- Fireworks Top
+	19	50100	50	50 -- Fire Crackers
+	20	50101	50	50 -- Fire Crackers
+	21	50102	50	50 -- Fire Crackers
+	22	50103	50	50 -- Fire Crackers
+	23	50104	50	51 -- Fire Crackers
+	24	50105	50	51 -- Fire Crackers
+	25	11280	1	3	30 -- Dragon God Armour+0
+	26	11260	1	4	30 -- Scale Plate Armour+0
+	27	11270	1	5	30 -- Gold Plate Armour+0
+	28	11880	1	3	30 -- Baroness Dress+0
+	29	11870	1	4	30 -- Orange Cat Dress+0
+	30	11860	1	5	30 -- Clothing of Morality+0
+	31	11480	1	3	30 -- Fuchsia Suit+0
+	32	11470	1	4	30 -- Killer Wind Suit+0
+	33	11460	1	5	30 -- Young Dragon Suit+0
+	34	11680	1	3	30 -- Spirit Plate Armour+0
+	35	11670	1	4	30 -- Ghost Mask Armour+0
+	36	11660	1	5	30 -- Fog Plate Armour+0
+	37	21060	1	3	30 -- Firellium Plate Armour+0
+	38	21050	1	4	30 -- Hobgoblin Plate Armour+0
+	39	21040	1	5	30 -- Bronze Plate Armour+0
+	40	90010	2	20 -- Foundation Stone
+	41	90011	2	20 -- Trunk
+	42	90012	2	20 -- Plywood
+}
+Group	低겁_5
+{
+	Vnum	50036 -- Gift (violet)
+	1	치	30000	30 -- Exp.
+	2	치	50000	60 -- Exp.
+	3	치	70000	50 -- Exp.
+	4	치	100000	60 -- Exp.
+	5	慕	30000	50 -- Yang
+	6	慕	50000	70 -- Yang
+	7	80004	1	70 -- Silver Bar(100,000 Yang)
+	8	80005	1	10 -- Gold Bar (500,000 Yang)
+	9	80006	1	5 -- Gold Bar (1Million Yang)
+	10	50300	1	20 -- Skill Book
+	11	25040	1	20 -- Blessing Scroll
+	12	71032	1	10 -- Dragon Scroll
+	13	71004	10	30 -- Medal of the Dragon
+	14	70003	1	20 -- Book of the Leader
+	15	71018	10	50 -- Blessing of Life
+	16	71019	10	50 -- Blessing of Magic
+	17	71020	10	30 -- Blessing of the Dragon
+	18	50008	1	20 -- Gold Key
+	19	50108	10	20 -- Fireworks Top
+	20	50100	50	15 -- Fire Crackers
+	21	50101	50	15 -- Fire Crackers
+	22	50102	50	15 -- Fire Crackers
+	23	50103	50	15 -- Fire Crackers
+	24	50104	50	15 -- Fire Crackers
+	25	50105	50	15 -- Fire Crackers
+	26	11280	1	3	30 -- Dragon God Armour+0
+	27	11260	1	5	30 -- Scale Plate Armour+0
+	28	11270	1	7	30 -- Gold Plate Armour+0
+	29	11880	1	3	30 -- Baroness Dress+0
+	30	11870	1	5	30 -- Orange Cat Dress+0
+	31	11860	1	7	30 -- Clothing of Morality+0
+	32	11480	1	3	30 -- Fuchsia Suit+0
+	33	11470	1	5	30 -- Killer Wind Suit+0
+	34	11460	1	7	30 -- Young Dragon Suit+0
+	35	11680	1	3	30 -- Spirit Plate Armour+0
+	36	11670	1	5	30 -- Ghost Mask Armour+0
+	37	11660	1	7	30 -- Fog Plate Armour+0
+	38	21060	1	3	30 -- Firellium Plate Armour+0
+	39	21050	1	5	30 -- Hobgoblin Plate Armour+0
+	40	21040	1	7	30 -- Bronze Plate Armour+0
+	41	90010	2	25 -- Foundation Stone
+	42	90011	2	25 -- Trunk
+	43	90012	2	25 -- Plywood
+}
+Group	
+{
+	Vnum	50037 -- Hexagonal Treasure Chest
+	1	27001	100	100 -- Red Potion (S)
+	2	27002	50	70 -- Red Potion (M)
+	3	27003	10	50 -- Red Potion (L)
+	4	27004	100	75 -- Blue Potion (S)
+	5	27005	50	55 -- Blue Potion (M)
+	6	27006	10	35 -- Blue Potion (L)
+	7	치	30000	70 -- Exp.
+	8	치	50000	40 -- Exp.
+	9	치	70000	20 -- Exp.
+	10	치	100000	10 -- Exp.
+	11	70048	1	20 -- Cloak of Secrecy
+	12	70102	1	9 -- Zen Bean
+	13	70051	1	20 -- Sage King's Glove
+	14	70049	1	35 -- Lucy's Ring
+	15	25040	1	1 -- Blessing Scroll
+	16	30045	1	26 -- Scorpion Needle
+	17	30051	1	26 -- Unknown Talisman
+	18	30038	1	26 -- Tiger Hide
+	19	30070	1	26 -- Wolf Fur+
+	20	30023	1	26 -- White Tiger Hide
+	21	30033	1	26 -- Broken Porcelain
+	22	30011	1	26 -- Ball
+	23	30082	1	26 -- Snake Tail+
+	24	30035	1	26 -- Face Cream
+	25	30010	1	26 -- Bear Gall
+	26	30055	1	26 -- Scorpion Claw
+	27	30006	1	26 -- Orc Tooth
+	28	30003	1	26 -- Pig Nose
+	29	30017	1	26 -- Ornamental Hairpin
+}
+Group	football
+{
+	Vnum	50096 -- Football
+	1	50300	1	1 -- Skill Book
+	2	70102	1	1 -- Zen Bean
+	3	25040	1	2 -- Blessing Scroll
+	4	80003	1	6 -- Silver Bar (50,000 Yang)
+	5	27003	5	10 -- Red Potion (L)
+	6	27006	5	15 -- Blue Potion (L)
+	7	27002	5	25 -- Red Potion (M)
+	8	27005	5	25 -- Blue Potion (M)
+}
+Group	ChrysanthemumBox
+{
+	Vnum	83023 -- Chrysanthemum Box
+	1	55408	1	100 -- Fat Mini Executor Egg
+	2	72059	1	100 -- Book of the Leader+
+	3	50255	1	100 -- Cor Draconis (Rough)
+	4	27209	5	100 -- Green Potion (L)
+	5	27212	5	100 -- Purple Potion (L)
+	6	76007	3	100 -- Bravery Cape
+	7	71080	1	100 -- Metin Stone(L)
+	8	71018	1	100 -- Blessing of Life
+	9	25121	1	100 -- Chrysanthemum
+	10	25122	1	100 -- May Bell
+	11	25123	1	100 -- Daffodil
+	12	25124	1	100 -- Lily
+	13	25125	1	100 -- Sunflower
+	14	55400	1	100 -- Mystery Box
+	15	치	300000	100 -- Exp.
+	16	慕	250000	100 -- Yang
+}
+Group	MayBellBox
+{
+	Vnum	83024 -- May Bell Box
+	1	55408	1	100 -- Fat Mini Executor Egg
+	2	72059	1	100 -- Book of the Leader+
+	3	50255	1	100 -- Cor Draconis (Rough)
+	4	27209	3	100 -- Green Potion (L)
+	5	27212	3	100 -- Purple Potion (L)
+	6	76007	3	100 -- Bravery Cape
+	7	71080	1	100 -- Metin Stone(L)
+	8	76008	1	100 -- Medal of the Dragon
+	9	25121	1	100 -- Chrysanthemum
+	10	25122	1	100 -- May Bell
+	11	25123	1	100 -- Daffodil
+	12	25124	1	100 -- Lily
+	13	25125	1	100 -- Sunflower
+	14	치	200000	100 -- Exp.
+	15	慕	200000	100 -- Yang
+}
+Group	DaffodilBox
+{
+	Vnum	83025 -- Daffodil Box
+	1	55402	1	100 -- Spider Egg
+	2	72059	1	100 -- Book of the Leader+
+	3	27206	30	100 -- Blue Potion (L)
+	4	27209	3	100 -- Green Potion (L)
+	5	27212	30	100 -- Purple Potion (L)
+	6	76007	3	100 -- Bravery Cape
+	7	71080	1	100 -- Metin Stone(L)
+	8	76000	1	100 -- Peach Flower Wine
+	9	76008	1	100 -- Medal of the Dragon
+	10	25121	1	100 -- Chrysanthemum
+	11	25122	1	100 -- May Bell
+	12	25123	1	100 -- Daffodil
+	13	25124	1	100 -- Lily
+	14	25125	1	100 -- Sunflower
+	15	치	150000	100 -- Exp.
+	16	慕	150000	100 -- Yang
+}
+Group	LilyBox
+{
+	Vnum	83026 -- Lily Box
+	1	55401	1	100 -- Monkey Egg
+	2	72059	1	100 -- Book of the Leader+
+	3	27206	30	100 -- Blue Potion (L)
+	4	27209	3	100 -- Green Potion (L)
+	5	27212	30	100 -- Purple Potion (L)
+	6	76007	20	100 -- Bravery Cape
+	7	71080	1	100 -- Metin Stone(L)
+	8	76000	2	100 -- Peach Flower Wine
+	9	76008	1	100 -- Medal of the Dragon
+	10	25121	1	100 -- Chrysanthemum
+	11	25122	1	100 -- May Bell
+	12	25123	1	100 -- Daffodil
+	13	25124	1	100 -- Lily
+	14	25125	1	100 -- Sunflower
+	15	치	100000	100 -- Exp.
+	16	慕	100000	100 -- Yang
+}
+Group	SunflowerBox
+{
+	Vnum	83027 -- Sunflower Box
+	1	55401	1	100 -- Monkey Egg
+	2	72059	1	100 -- Book of the Leader+
+	3	27206	30	100 -- Blue Potion (L)
+	4	27209	3	100 -- Green Potion (L)
+	5	27212	30	100 -- Purple Potion (L)
+	6	76007	20	100 -- Bravery Cape
+	7	71080	1	100 -- Metin Stone(L)
+	8	76000	1	100 -- Peach Flower Wine
+	9	76008	1	100 -- Medal of the Dragon
+	10	25121	1	100 -- Chrysanthemum
+	11	25122	1	100 -- May Bell
+	12	25123	1	100 -- Daffodil
+	13	25124	1	100 -- Lily
+	14	25125	1	100 -- Sunflower
+	15	치	50000	100 -- Exp.
+	16	慕	50000	100 -- Yang
+}
+Group	TigerMysteryBox
+{
+	Vnum	38050 -- Power Chest
+	1	38051	1	1 -- Royal Tiger Crystal
+	2	71085	1	2 -- Reinforce Item
+	3	70039	1	2 -- Blacksmith Handbook
+	4	71032	1	3 -- Dragon Scroll
+	5	70024	1	3 -- Blessing Marble
+	6	25040	1	5 -- Blessing Scroll
+	7	71094	1	5 -- Concentrated Reading
+	8	27992	1	7 -- White Pearl
+	9	27993	1	8 -- Blue Pearl
+	10	27994	1	8 -- Blood-Red Pearl
+	11	72724	1	9 -- Sun Elixir (M)
+	12	72728	1	9 -- Moon Elixir (M)
+	13	71027	2	11 -- Dragon God Life
+	14	71113	40	11 -- Glass of Insight
+}
+Group	TigerRewardBox
+{
+	Vnum	38051 -- Royal Tiger Crystal
+	1	71137	1	25 -- Royal Tiger (blue)
+	2	71138	1	20 -- Royal Tiger (red)
+	3	71139	1	10 -- Royal Tiger (gold)
+	4	71140	1	15 -- Royal Tiger (green)
+	5	71141	1	25 -- Royal Tiger (grey)
+	6	71142	1	5 -- Royal Tiger (white)
+}
+Group	WhiteLionBox
+{
+	Vnum	38052 -- The Chest of Kings
+	1	71085	1	3 -- Reinforce Item
+	2	70039	1	3 -- Blacksmith Handbook
+	3	71032	1	5 -- Dragon Scroll
+	4	70024	1	5 -- Blessing Marble
+	5	25040	1	8 -- Blessing Scroll
+	6	71012	1	14 -- Book of the Leader
+	7	71130	3	16 -- Passage Ticket
+	8	71083	1	16 -- Stone Handbook
+	9	71004	10	14 -- Medal of the Dragon
+	10	71018	2	14 -- Blessing of Life
+	11	25041	1	1 -- Magic Stone
+	12	71124	1	1 -- White Lion
+}
+Group	WhitePhoenixBox
+{
+	Vnum	38053 -- Eternal Winter Chest
+	1	53503	1	2 -- Ice Phoenix Cage
+	2	72702	1	1 -- Wind Shoes+ (tradeable)
+	3	71085	1	2 -- Reinforce Item
+	4	70039	1	2 -- Blacksmith Handbook
+	5	71032	1	3 -- Dragon Scroll
+	6	70024	1	3 -- Blessing Marble
+	7	30195	1	4 -- Quartz Sand
+	8	71094	1	5 -- Concentrated Reading
+	9	50513	1	6 -- Soul Stone
+	10	27992	1	6 -- White Pearl
+	11	27993	1	7 -- Blue Pearl
+	12	27994	1	8 -- Blood-Red Pearl
+	13	72725	1	8 -- Sun Elixir (L)
+	14	72729	1	8 -- Moon Elixir (L)
+	15	71027	2	10 -- Dragon God Life
+	16	71044	4	10 -- Critical Strike
+	17	71045	4	10 -- Piercing Strike
+}
+Group	X_Mas_Pet
+{
+	Vnum	38055 -- Whelp Box
+	1	71085	1	1 -- Reinforce Item
+	2	70039	1	2 -- Blacksmith Handbook
+	3	71032	1	5 -- Dragon Scroll
+	4	70024	1	5 -- Blessing Marble
+	5	25040	1	11 -- Blessing Scroll
+	6	71012	1	12 -- Book of the Leader
+	7	71130	3	12 -- Passage Ticket
+	8	71083	1	12 -- Stone Handbook
+	9	71004	10	12 -- Medal of the Dragon
+	10	71018	2	12 -- Blessing of Life
+	11	30319	3	10 -- Shrunken Head
+	12	25041	1	1 -- Magic Stone
+	13	53011	1	3 -- Khan
+	14	53012	1	3 -- Porky
+}
+Group	째징쨘챗쨍짰쩔짚횉횄횪쨘쨔쨩처횣
+{
+	Vnum	50182 -- Blessing Chest
+	1	27992	1	5 -- White Pearl
+	2	27993	1	5 -- Blue Pearl
+	3	27994	1	5 -- Blood-Red Pearl
+	4	70039	1	7 -- Blacksmith Handbook
+	5	71001	5	7 -- Exorcism Scroll
+	6	71094	1	7 -- Concentrated Reading
+	7	70057	1	9 -- Bravery Cape
+	8	70003	1	12 -- Book of the Leader
+	9	70024	1	12 -- Blessing Marble
+	10	71085	1	12 -- Reinforce Item
+	11	71084	1	15 -- Enchant Item
+	12	70056	5	20 -- Pomegranate Juice+
+	13	70064	3	5 -- Enchant Costume
+	14	70063	3	5 -- Transform Costume
+	15	71035	5	5 -- Researcher's Elixir
+}
+Group	念호
+{
+	Vnum	50095 -- Pumpkin
+	1	50300	1	1 -- Skill Book
+	2	70102	1	1 -- Zen Bean
+	3	25040	1	3 -- Blessing Scroll
+	4	80003	1	5 -- Silver Bar (50,000 Yang)
+	5	27003	5	10 -- Red Potion (L)
+	6	27006	5	15 -- Blue Potion (L)
+	7	27002	5	25 -- Red Potion (M)
+	8	27005	5	40 -- Blue Potion (M)
+	9	27001	5	50 -- Red Potion (S)
+	10	27004	5	50 -- Blue Potion (S)
+}
+Group	念호靡
+{
+	Vnum	50215 -- Halloween Chest
+	1	70035	1	1 -- Magic Copper Ore
+	2	71085	1	6 -- Reinforce Item
+	3	70024	1	6 -- Blessing Marble
+	4	71026	1	1 -- Magic Iron Ore
+	5	71084	1	6 -- Enchant Item
+	6	71108	15	10 -- Pomegranate Juice
+	7	70003	1	5 -- Book of the Leader
+	8	72723	1	5 -- Sun Elixir (S)
+	9	72727	1	5 -- Moon Elixir (S)
+	10	71004	5	5 -- Medal of the Dragon
+	11	71094	1	5 -- Concentrated Reading
+	12	70102	1	10 -- Zen Bean
+	13	27992	1	8 -- White Pearl
+	14	27993	1	7 -- Blue Pearl
+	15	27994	1	5 -- Blood-Red Pearl
+	16	30323	1	15 -- Jack O'Lantern Mask Card
+}
+
+
+Group	BronzeYutNoriBundle
+{
+	Vnum	50922 -- Bronze Yut Nori Bundle
+	1	慕	50000	40 -- Yang
+	2	慕	100000	50 -- Yang
+	3	치	100000	60 -- EXP
+	4	79508	1	40 -- Yut Nori Board
+}
+Group	GoldenYutNoriTrophy
+{
+	Vnum	83030 -- Golden Yut Nori Trophy
+	Type	pct
+	1	50920	1	100 -- Golden Yut Nori Bundle
+	2	30639	1	100 -- Mysterious Shard
+}
+Group	SilverYutNoriTrophy
+{
+	Vnum	83031 -- Silver Yut Nori Trophy
+	Type	pct
+	1	50921	1	100 -- Silver Yut Nori Bundle
+	2	30639	1	30 -- Mysterious Shard
+}
+Group	GoldenYutNoriBundle
+{
+	Vnum	50920 -- Golden Yut Nori Bundle
+	1	79508	1	10 -- Yut Nori Board
+	2	39015	1	19 -- Stone of the Blacksmith
+	3	25040	1	33 -- Blessing Scroll
+	4	39001	1	12 -- Magic Stone
+	5	76042	1	18 -- Teleportation Ring
+	6	39029	1	20 -- Reinforce Item
+	7	39028	1	80 -- Enchant Item
+	8	71189	1	32 -- Enchant Item+
+	9	39036	1	7 -- Wind Shoes
+	10	71136	1	6 -- Mighty Lolly
+	11	71228	1	8 -- Lava Cave Lizard
+	12	55403	1	9 -- Razador's Egg
+	13	55404	1	9 -- Nemere's Egg
+	14	71018	10	20 -- Blessing of Life
+	15	51506	1	19 -- Cor Draconis (Mystical)
+	16	51505	1	26 -- Cor Draconis (Precious)
+	17	30616	1	12 -- Titanium Dioxide
+	18	30617	1	9 -- Agate
+	19	30618	1	6 -- Moonstone
+	20	27992	1	23 -- White Pearl
+	21	50926	200	17 -- Glimmerstone
+	22	72058	10	29 -- Spirit Stone Bundle
+	23	53253	1	9 -- Shiver
+	24	50108	10	20 -- Fireworks Top
+	25	50107	10	20 -- Chinese Fire Cracker
+	26	72709	1	4 -- Tiger Bone Earring
+	27	72710	1	4 -- Dragon Bone Earring
+	28	71181	1	8 -- Potion of Wisdom
+	29	170	1	18	100 -- Sting Sword+0
+	30	250	1	18	100 -- Demon Blade+0
+	31	1120	1	18	100 -- Siamese Knife+0
+	32	2180	1	18	100 -- Blue Dragon Bow+0
+	33	3150	1	18	100 -- Soul Stealing Blade+0
+	34	6060	1	18	100 -- Hawk Claw+0
+	35	7150	1	18	100 -- Ecstasy Fan+0
+}
+Group	SilverYutNoriBundle
+{
+	Vnum	50921 -- Silver Yut Nori Bundle
+	1	치	100000	60 -- Exp.
+	2	慕	500000	40 -- Yang
+	3	慕	300000	50 -- Yang
+	4	慕	100000	60 -- Yang
+	5	79508	1	10 -- Yut Nori Board
+	6	55402	1	9 -- Spider Egg
+	7	25040	1	38 -- Blessing Scroll
+	8	39001	1	8 -- Magic Stone
+	9	76042	1	16 -- Teleportation Ring
+	10	39029	1	16 -- Reinforce Item
+	11	39028	1	64 -- Enchant Item
+	12	71189	1	28 -- Enchant Item+
+	13	39036	1	7 -- Wind Shoes
+	14	50324	1	12 -- Boost Book Chest
+	15	50323	1	12 -- Ward Book Chest
+	16	55403	1	6 -- Razador's Egg
+	17	55404	1	6 -- Nemere's Egg
+	18	85001	1	26 -- Lord Sash (basic)
+	19	51503	1	36 -- Cor Draconis (Normal)
+	20	51504	1	30 -- Cor Draconis (Noble)
+	21	55401	1	9 -- Monkey Egg
+	22	71181	1	8 -- Potion of Wisdom
+	23	27993	1	18 -- Blue Pearl
+	24	27994	1	13 -- Blood-Red Pearl
+	25	50108	10	20 -- Fireworks Top
+	26	50107	10	20 -- Chinese Fire Cracker
+	27	71180	1	10 -- Potion of Ascension (3h)
+	28	72058	10	29 -- Spirit Stone Bundle
+}
+
+Group	HalloweenChest(m)
+{
+	Vnum	83004 -- Halloween Chest (m)
+	1	41135	1	1 -- Pumpkin Tuxedo (Bonus)
+	2	41516	1	1 -- Cop. Fanged Costume+ (m)
+	3	41322	1	1 -- Pumpkin Jack Suit+ (m)
+	4	41478	1	1 -- Warlock's Suit+
+	5	41596	1	1 -- Harness of Horror+(Gold)
+	6	41517	1	1 -- Sil. Fanged Costume+ (m)
+	7	41675	1	1 -- Grey Wolf Costume+ (m)
+	8	41564	1	1 -- Blood Vampire+ (Grey)
+	9	41597	1	1 -- Harness of Horror+(Blue)
+	10	41474	1	1 -- Zombie Suit+
+	11	41674	1	1 -- Brown Wolf Costume+ (m)
+	12	41565	1	1 -- Blood Vampire+ (Red)
+}
+Group	HalloweenHatChest(m)
+{
+	Vnum	83005 -- Halloween Hat Chest (m)
+	1	45073	1	1 -- Pumpkin Mask (Bonus)
+	2	45158	1	1 -- Pumpkin Jack Head+ (m)
+	3	45286	1	1 -- Horns of Horror+ (Gold)
+	4	45341	1	1 -- Grey Wolf Hat+ (m)
+	5	45287	1	1 -- Horns of Horror+ (Blue)
+	6	45340	1	1 -- Brown Wolf Hat+ (m)
+	7	45210	1	1 -- Cop. Fanged Helmet+ (m)
+	8	45173	1	1 -- Witch's Hat+
+	9	45211	1	1 -- Sil. Fanged Helmet+ (m)
+	10	45254	1	1 -- Blood Vampire Helm+ (G)
+	11	45172	1	1 -- Zombie Pumpkin Mask+
+	12	45255	1	1 -- Blood Vampire Helm+ (R)
+}
+Group	HalloweenPetChest
+{
+	Vnum	83006 -- Haunted Pet Chest
+	1	53266	1	1 -- Helexna
+	2	53016	1	1 -- Boney
+	3	53265	1	1 -- Astrabell
+	4	53245	1	1 -- Mr Jiangshi+
+	5	53223	1	1 -- Little Broomstick
+	6	53244	1	1 -- Ms Jiangshi+
+	7	53233	1	1 -- Bruce (Loot)
+	8	53017	1	1 -- Jade Phoenix
+	9	53234	1	1 -- Wayne (Loot)
+	10	53254	1	1 -- Snivel
+	11	53222	1	1 -- Pumpkin Head
+	12	53253	1	1 -- Shiver
+}
+Group	HalloweenMountChest
+{
+	Vnum	83007 -- Haunted Mount Chest
+	1	71235	1	1 -- Cerberus (Gold)
+	2	71161	1	1 -- Equus Porphyreus
+	3	71236	1	1 -- Cerberus (Silver)
+	4	71223	1	1 -- Samsara Dragon
+	5	71228	1	1 -- Lava Cave Lizard
+	6	71222	1	1 -- Nirvana Dragon
+	7	71229	1	1 -- Ice Cave Lizard
+}
+Group	HalloweenJewelleryBox
+{
+	Vnum	83008 -- Jewellery Box
+	1	71143	1	1 -- Ring of Joy
+	2	71148	1	1 -- Ring of Will Power
+	3	71158	1	1 -- Hero's Medal
+	4	76047	1	1 -- Power Lolly (3D)
+	5	71202	1	1 -- Nazar Amulet
+	6	71145	1	1 -- Amulet of Eternal Love
+	7	76030	1	1 -- Power Lolly
+	8	71199	1	1 -- Chocolate Amulet
+	9	71149	1	1 -- Ring of Deadly Power
+	10	71188	1	1 -- Magic Lolly
+	11	72054	1	1 -- Amulet of the Guardians
+	12	71180	1	5 -- Potion of Ascension (3h)
+	13	71136	1	1 -- Mighty Lolly
+	14	71135	1	1 -- Crescent Moon Ring
+	15	71181	1	5 -- Potion of Wisdom
+}
+Group	HalloweenGrowthPetChest
+{
+	Vnum	83009 -- Pet Chest
+	1	55401	1	10 -- Monkey Egg
+	2	55406	1	5 -- Red Dragon Egg
+	3	55402	1	8 -- Spider Egg
+	4	55408	1	2 -- Fat Mini Executor Egg
+	5	55403	1	3 -- Razador's Egg
+	6	55407	1	2 -- Mini Azrael's Egg
+	7	55404	1	3 -- Nemere's Egg
+	8	55405	1	1 -- Blue Dragon Egg
+	9	55410	1	1 -- Nessie Egg
+}
+Group	HalloweenSashBox
+{
+	Vnum	83010 -- Sash Box
+	1	85005	1	3 -- Master Sash (basic)
+	2	85006	1	2 -- Master Sash (fine)
+	3	85007	1	1 -- Master Sash (noble)
+	4	85001	1	3 -- Lord Sash (basic)
+	5	85002	1	2 -- Lord Sash (fine)
+	6	85003	1	1 -- Lord Sash (noble)
+	7	85011	1	3 -- Sovereign Sash (basic)
+	8	85012	1	2 -- Sovereign Sash (fine)
+	9	85013	1	1 -- Sovereign Sash (noble)
+	10	85015	1	3 -- Royal Sash (basic)
+	11	85016	1	2 -- Royal Sash (fine)
+	12	85017	1	1 -- Royal Sash (noble)
+	13	86001	1	1 -- Zi Sash (basic)
+	14	86002	1	1 -- Zi Sash (fine)
+	15	86005	1	1 -- Chou Sash (basic)
+	16	86006	1	1 -- Chou Sash (fine)
+	17	86011	1	1 -- Yin Sash (basic)
+	18	86012	1	1 -- Yin Sash (fine)
+	19	86015	1	1 -- Mao Sash (basic)
+	20	86016	1	1 -- Mao Sash (fine)
+	21	86021	1	1 -- Chen Sash (basic)
+	22	86022	1	1 -- Chen Sash (fine)
+	23	86025	1	1 -- Si Sash (basic)
+	24	86026	1	1 -- Si Sash (fine)
+	25	86031	1	1 -- Wu Sash (basic)
+	26	86032	1	1 -- Wu Sash (fine)
+	27	86035	1	1 -- Wei Sash (basic)
+	28	86036	1	1 -- Wei Sash (fine)
+	29	86041	1	1 -- Shen Sash (basic)
+	30	86042	1	1 -- Shen Sash (fine)
+	31	86045	1	1 -- You Sash (basic)
+	32	86046	1	1 -- You Sash (fine)
+	33	86051	1	1 -- Xu Sash (basic)
+	34	86052	1	1 -- Xu Sash (fine)
+	35	86055	1	1 -- Hai Sash (basic)
+	36	86056	1	1 -- Hai Sash (fine)
+}
+Group	HalloweenTalismanChest
+{
+	Vnum	83011 -- Ornament Chest
+	1	10750	1	1 -- Lightning Talisman+0
+	2	10520	1	1 -- Wind Talisman+0
+	3	10060	1	1 -- Earth Talisman+0
+	4	9600	1	1 -- Fire Talisman+0
+	5	9830	1	1 -- Ice Talisman+0
+	6	10290	1	1 -- Dark Talisman+0
+	7	33029	50	1 -- Red Zodiac Case
+	8	33030	50	1 -- Blue Zodiac Case
+	9	72328	1	1 -- Mark of the Guardian
+	10	33031	50	1 -- Elemental Bloom
+	11	72329	50	1 -- Sphere Parchment
+}
+Group	HalloweenPetBookChest
+{
+	Vnum	83012 -- Ultimate Pet Book Chest
+	1	55020	1	1 -- Vampirism Book
+	2	55021	1	1 -- Spiritualism Book
+	3	55036	1	1 -- Eagle Eyes Book
+	4	55025	1	1 -- Range Book
+	5	55015	1	1 -- Berserker Book
+	6	55035	1	1 -- Monster Hunter Book
+	7	55037	1	1 -- Life Drain Book
+	8	55024	1	1 -- Yang Drop Book
+	9	55018	1	1 -- Drill Book
+	10	55023	1	1 -- Reflection Book
+	11	55022	1	1 -- Bulwark Book
+	12	55017	1	1 -- Haste Book
+	13	55016	1	1 -- Anti-Magic Book
+	14	55034	1	1 -- Master Brewer Book
+	15	55010	1	1 -- Resistance (Warrior)
+	16	55011	1	1 -- Resistance (Sura)
+	17	55012	1	1 -- Resistance (Ninja)
+	18	55013	1	1 -- Resistance (Shaman)
+	19	55014	1	1 -- Resistance (Lycan)
+	20	55027	1	1 -- Panacea Book
+	21	55019	1	1 -- Restoration Book
+	22	55026	1	1 -- Immortal Book
+	23	55038	1	1 -- Light as a Feather Book
+	24	55030	1	1 -- Pet Revertus
+}
+#Group	HalloweenWeaponChest+
+#{
+#	Vnum	83013 -- Riptooth Chest+
+#	1	40108	1	1 -- Riptooth Blade+
+#	2	40109	1	1 -- Riptooth Dagger+
+#	3	40110	1	1 -- Riptooth Bow+
+#	4	40111	1	1 -- Riptooth Glaive+
+#	5	40112	1	1 -- Riptooth Bell+
+#	6	40113	1	1 -- Riptooth Fan+
+#	7	40114	1	1 -- Riptooth Claws+
+#
+Group	HalloweenDSChest
+{
+	Vnum	83014 -- Cor Draconis Chest
+	1	51501	1	1 -- Cor Draconis (Rough)
+	2	51503	1	1 -- Cor Draconis (Normal)
+	3	51504	1	1 -- Cor Draconis (Noble)
+	4	51505	1	1 -- Cor Draconis (Precious)
+	5	51506	1	1 -- Cor Draconis (Mystical)
+	6	76029	1	1 -- Green Dragon Bean
+	7	100400	1	1 -- Blue Dragon Bean
+	8	100500	1	1 -- Pink Dragon Bean
+}
+Group	HalloweenGemChest
+{
+	Vnum	83015 -- Gaya Chest
+	1	50926	200	50 -- Glimmerstone
+	2	39063	1	25 -- Refresh Gaya Market
+	3	39064	1	25 -- Gaya Market Expansion
+	4	72058	10	30 -- Spirit Stone Bundle
+}
+Group	HalloweenMysteryChest
+{
+	Vnum	83016 -- Chest of Mysteries
+	1	54702	1	1 -- Razador's Chest
+	2	54703	1	1 -- Nemere's Chest
+	3	54704	1	1 -- Jotun Thrym's Chest
+	4	54701	1	1 -- Bagjanamu's Chest
+	5	54700	1	1 -- Beran-Setaou's Chest
+	6	50271	1	1 -- Dragon Watcher Chest
+	7	50270	1	1 -- Queen Meley's Chest
+	8	54705	1	1 -- Hydra's Chest
+	9	30618	1	3 -- Moonstone
+	10	30617	1	3 -- Agate
+	11	30616	1	3 -- Titanium Dioxide
+	12	27992	1	3 -- White Pearl
+	13	27993	1	3 -- Blue Pearl
+	14	27994	1	3 -- Blood-Red Pearl
+	15	30619	1	3 -- Metallic Gold Dye
+	16	18900	1	3 -- Red Flame Stone
+}
+Group	HalloweenRubyChest
+{
+	Vnum	83017 -- Ruby Chest
+	1	76005	1	1 -- Moon Elixir (M)
+	2	76022	1	1 -- Sun Elixir (M)
+	3	76000	3	1 -- Peach Flower Wine
+	4	76033	3	1 -- Peach Flower Wine+
+	5	76006	1	1 -- Compass for Metin Stones
+	6	76012	3	1 -- Potion of Speed
+	7	76025	1	1 -- Wind Shoes
+	8	76042	1	1 -- Teleportation Ring
+	9	76017	3	1 -- Potion of Attack +15
+	10	76018	3	1 -- Potion of Attack +20
+	11	76003	3	1 -- Potion of Haste
+	12	76036	3	1 -- Dragon God Attack
+	13	76035	3	1 -- Dragon God Life
+	14	76019	1	1 -- Passage Ticket
+	15	76010	1	1 -- Blood Stone
+	16	76002	1	1 -- Shrunken Head
+	17	76014	1	1 -- Enchant Item (b)
+	18	76013	1	1 -- Reinforce Item (b)
+	19	76015	1	1 -- Blessing Marble
+	20	71189	1	1 -- Enchant Item+
+	21	76016	1	1 -- Blessing Scroll
+	22	76009	1	1 -- Dragon Scroll
+	23	76011	1	1 -- Book of the Leader
+	24	76008	3	1 -- Medal of the Dragon
+	25	76007	20	1 -- Bravery Cape
+	26	76051	1	1 -- Ring of Secrets (7d)
+	27	76037	1	1 -- Thief's Gloves
+	28	76038	1	1 -- Lucky Medal
+	29	71107	1	1 -- Fruit of Life
+	30	76001	1	1 -- Status Reset Document
+	31	76045	1	1 -- Pet Name Scroll
+	32	76028	1	1 -- Stone Handbook
+	33	76034	1	1 -- Concentrated Reading
+	34	76026	1	1 -- Exorcism Scroll
+	35	76020	1	1 -- Researcher's Elixir
+	36	72320	1	1 -- Inventory Expansion
+	37	76031	1	1 -- Protein Snack
+}
+Group	HalloweenChest(f)
+{
+	Vnum	83028 -- Halloween Chest (f)
+	1	41136	1	1 -- Pumpkin Dress (Bonus)
+	2	41518	1	1 -- Cop. Fanged Costume+ (f)
+	3	41323	1	1 -- Pumpkin Jack Dress+ (f)
+	4	41479	1	1 -- Witch's Dress+
+	5	41598	1	1 -- Harness of Horror+(Gold)
+	6	41519	1	1 -- Sil. Fanged Costume+ (f)
+	7	41677	1	1 -- Grey Wolf Costume+ (f)
+	8	41566	1	1 -- Blood Lamia+ (Grey)
+	9	41599	1	1 -- Harness of Horror+(Blue)
+	10	41475	1	1 -- Zombie Dress+
+	11	41676	1	1 -- Brown Wolf Costume+ (f)
+	12	41567	1	1 -- Blood Lamia+ (Red)
+}
+Group	HalloweenHatChest(f)
+{
+	Vnum	83029 -- Halloween Hat Chest (f)
+	1	45074	1	1 -- Pumpkin Mask (Bonus)
+	2	45159	1	1 -- Pumpkin Jack Head+ (f)
+	3	45288	1	1 -- Horns of Horror+ (Gold)
+	4	45343	1	1 -- Grey Wolf Hat+ (f)
+	5	45289	1	1 -- Horns of Horror+ (Blue)
+	6	45342	1	1 -- Brown Wolf Hat+ (f)
+	7	45212	1	1 -- Cop. Fanged Helmet+ (f)
+	8	45173	1	1 -- Witch's Hat+
+	9	45213	1	1 -- Sil. Fanged Helmet+ (f)
+	10	45256	1	1 -- Blood Lamia Helm+ (Grey)
+	11	45172	1	1 -- Zombie Pumpkin Mask+
+	12	45257	1	1 -- Blood Lamia Helm+ (Red)
+}
+Group	mystery_box_1
+{
+	Vnum	50125 -- Mysterious Chest
+	1	71085	1	2 -- Reinforce Item
+	2	70039	1	2 -- Blacksmith Handbook
+	3	71032	1	4 -- Dragon Scroll
+	4	70024	1	4 -- Blessing Marble
+	5	25040	1	6 -- Blessing Scroll
+	6	71012	1	14 -- Book of the Leader
+	7	71130	3	14 -- Passage Ticket
+	8	71083	1	14 -- Stone Handbook
+	9	71004	10	14 -- Medal of the Dragon
+	10	71018	2	14 -- Blessing of Life
+	11	25041	1	1 -- Magic Stone
+	12	71125	1	1 -- Wild Battle Boar
+}
+Group	MerryGoldenOkeyChest
+{
+	Vnum	50267 -- Merry Golden Okey Chest
+	1	72355	1	100 -- Personal Premium Shop
+	2	30617	1	100 -- Agate
+	3	76016	1	100 -- Blessing Scroll
+	4	51505	1	100 -- Cor Draconis (Precious)
+	5	51506	1	100 -- Cor Draconis (Mystical)
+	6	71224	1	100 -- Manny
+	7	71225	1	100 -- Ellie
+	8	71189	1	100 -- Enchant Item+
+	9	76014	1	100 -- Enchant Item (b)
+	10	85003	1	100 -- Lord Sash (noble)
+	11	25041	1	100 -- Magic Stone
+	12	30618	1	100 -- Moonstone
+	13	79506	1	100 -- Okey Card Set
+	14	55404	1	100 -- Nemere's Egg
+	15	55403	1	100 -- Razador's Egg
+	16	55405	1	100 -- Blue Dragon Egg
+	17	76013	1	100 -- Reinforce Item (b)
+	18	50525	1	100 -- Soul Stone+
+	19	30616	1	100 -- Titanium Dioxide
+	20	70058	1	100 -- Teleportation Ring
+	21	50324	1	100 -- Boost Book Chest
+	22	50323	1	100 -- Ward Book Chest
+	23	27992	1	100 -- White Pearl
+	24	50926	200	100 -- Glimmerstone
+	25	39036	1	100 -- Wind Shoes
+	26	71153	1	100 -- Potion of Wisdom
+	27	50513	1	100 -- Soul Stone
+	28	치	700000	100 -- Exp.
+	29	慕	700000	100 -- Yang
+	30	慕	500000	100 -- Yang
+	31	71192	1	100 -- Thunder
+	32	71193	1	100 -- Blitzen
+}
+Group	MerrySilverOkeyChest
+{
+	Vnum	50268 -- Merry Silver Okey Chest
+	1	72355	1	100 -- Personal Premium Shop
+	2	79506	1	100 -- Okey Card Set
+	3	76016	1	100 -- Blessing Scroll
+	4	27994	1	100 -- Blood-Red Pearl
+	5	27993	1	100 -- Blue Pearl
+	6	71224	1	100 -- Manny
+	7	71225	1	100 -- Ellie
+	8	50324	1	100 -- Boost Book Chest
+	9	50323	1	100 -- Ward Book Chest
+	10	51503	1	100 -- Cor Draconis (Normal)
+	11	51504	1	100 -- Cor Draconis (Noble)
+	12	71189	1	100 -- Enchant Item+
+	13	76014	1	100 -- Enchant Item (b)
+	14	76013	1	100 -- Reinforce Item (b)
+	15	85001	1	100 -- Lord Sash (basic)
+	16	25041	1	100 -- Magic Stone
+	17	55404	1	100 -- Nemere's Egg
+	18	55403	1	100 -- Razador's Egg
+	19	55402	1	100 -- Spider Egg
+	20	70058	1	100 -- Teleportation Ring
+	21	39036	1	100 -- Wind Shoes
+	22	50926	60	100 -- Glimmerstone
+	23	71153	1	100 -- Potion of Wisdom
+	24	치	100000	100 -- Exp.
+	25	慕	500000	100 -- Yang
+	26	慕	300000	100 -- Yang
+	27	慕	100000	100 -- Yang
+	28	71192	1	100 -- Thunder
+	29	71193	1	100 -- Blitzen
+}
+Group	MerryBronzeOkeyChest
+{
+	Vnum	50269 -- Merry Bronze Okey Chest
+	1	79506	1	100 -- Okey Card Set
+	2	치	100000	100 -- Exp.
+	3	慕	100000	100 -- Yang
+	4	慕	50000	100 -- Yang
+}
+
+Group	GoldenOkeyChest
+{
+	Vnum	50275 -- Golden Okey Chest
+	1	71148	1	100 -- Ring of Will Power
+	2	71149	1	100 -- Ring of Deadly Power
+	3	55404	1	100 -- Nemere's Egg
+	4	55403	1	100 -- Razador's Egg
+	5	85017	1	100 -- Royal Sash (noble)
+	6	51506	1	100 -- Cor Draconis (Mystical)
+	7	51505	1	100 -- Cor Draconis (Precious)
+	8	79506	1	100 -- Okey Card Set
+	9	50513	1	100 -- Soul Stone
+	10	76021	1	100 -- Sun Elixir (S)
+	11	76004	1	100 -- Moon Elixir (S)
+	12	70102	1	100 -- Zen Bean
+	13	76012	1	100 -- Potion of Speed
+	14	28443	1	100 -- Stone of Haste+4
+	15	70031	1	100 -- Fencing Pamphlet
+	16	30524	1	100 -- Flame Stone
+	17	71123	1	100 -- Dragon Scales
+	18	30195	1	100 -- Quartz Sand
+	19	27992	1	100 -- White Pearl
+	20	55003	1	100 -- Young Pet Book
+	21	55004	1	100 -- Wild Pet Book
+	22	치	700000	100 -- Exp.
+	23	慕	1000000	100 -- Yang
+	24	慕	700000	100 -- Yang
+	25	慕	500000	100 -- Yang
+}
+Group	SilverOkeyChest
+{
+	Vnum	50276 -- Silver Okey Chest
+	1	55401	1	100 -- Monkey Egg
+	2	55402	1	100 -- Spider Egg
+	3	76021	1	100 -- Sun Elixir (S)
+	4	76004	1	100 -- Moon Elixir (S)
+	5	70102	1	100 -- Zen Bean
+	6	27987	1	100 -- Clam
+	7	76012	1	100 -- Potion of Speed
+	8	70031	1	100 -- Fencing Pamphlet
+	9	85001	1	100 -- Lord Sash (basic)
+	10	79506	1	100 -- Okey Card Set
+	11	71148	1	100 -- Ring of Will Power
+	12	71149	1	100 -- Ring of Deadly Power
+	13	55003	1	100 -- Young Pet Book
+	14	55004	1	100 -- Wild Pet Book
+	15	51505	1	100 -- Cor Draconis (Precious)
+	16	51504	1	100 -- Cor Draconis (Noble)
+	17	27994	1	100 -- Blood-Red Pearl
+	18	27993	1	100 -- Blue Pearl
+	19	치	500000	100 -- Exp.
+	20	慕	500000	100 -- Yang
+	21	慕	300000	100 -- Yang
+}
+Group	BronzeOkeyChest
+{
+	Vnum	50277 -- Bronze Okey Chest
+	1	79506	1	100 -- Okey Card Set
+	2	치	100000	100 -- Exp.
+	3	慕	100000	100 -- Yang
+	4	慕	50000	100 -- Yang
+}
+
+Group	GoldenOkeyBox
+{
+	Vnum	71194 -- Golden Okey Box
+	1	79506	5	100 -- Okey Card Set
+}
+Group	SilverOkeyBox
+{
+	Vnum	71195 -- Silver Okey Box
+	1	79506	1	100 -- Okey Card Set
+}
+Group	BronzeOkeyBox
+{
+	Vnum	71196 -- Bronze Okey Box
+	1	79505	6	100 -- Okey Collectable Card
+}
+Group	2012첩횝_1
+{
+	Vnum	71159 -- Milon's Chest
+	1	70035	1	1 -- Magic Copper Ore
+	2	71085	1	6 -- Reinforce Item
+	3	70024	1	6 -- Blessing Marble
+	4	71026	1	1 -- Magic Iron Ore
+	5	71084	1	6 -- Enchant Item
+	6	71108	15	10 -- Pomegranate Juice
+	7	70003	1	5 -- Book of the Leader
+	8	72723	1	5 -- Sun Elixir (S)
+	9	72727	1	5 -- Moon Elixir (S)
+	10	71004	5	5 -- Medal of the Dragon
+	11	71094	1	5 -- Concentrated Reading
+	12	70102	1	10 -- Zen Bean
+	13	27992	1	5 -- White Pearl
+	14	27993	1	5 -- Blue Pearl
+	15	27994	1	9 -- Blood-Red Pearl
+	16	41005	1	6 -- Fencing Outfit (m)
+	17	41013	1	6 -- Football Outfit (m)
+	18	41021	1	6 -- Boxing Outfit (m)
+}
+Group	2012첩횝_1_
+{
+	Vnum	71160 -- Athena's Chest
+	1	70035	1	1 -- Magic Copper Ore
+	2	71085	1	6 -- Reinforce Item
+	3	70024	1	6 -- Blessing Marble
+	4	71026	1	1 -- Magic Iron Ore
+	5	71084	1	6 -- Enchant Item
+	6	71108	15	10 -- Pomegranate Juice
+	7	70003	1	5 -- Book of the Leader
+	8	72723	1	5 -- Sun Elixir (S)
+	9	72727	1	5 -- Moon Elixir (S)
+	10	71004	5	5 -- Medal of the Dragon
+	11	71094	1	5 -- Concentrated Reading
+	12	70102	1	10 -- Zen Bean
+	13	27992	1	5 -- White Pearl
+	14	27993	1	5 -- Blue Pearl
+	15	27994	1	9 -- Blood-Red Pearl
+	16	41006	1	6 -- Fencing Outfit (f)
+	17	41014	1	6 -- Football Outfit (f)
+	18	41022	1	6 -- Boxing Outfit (f)
+}
+Group	2012첩횝_2
+{
+	Vnum	50249
+	1	27001	100	100 -- Red Potion (S)
+	2	27002	50	70 -- Red Potion (M)
+	3	27003	10	50 -- Red Potion (L)
+	4	27004	100	75 -- Blue Potion (S)
+	5	27005	50	55 -- Blue Potion (M)
+	6	27006	10	35 -- Blue Potion (L)
+	7	치	30000	70 -- Experience
+	8	치	50000	40 -- Experience
+	9	치	70000	20 -- Experience
+	10	치	100000	10 -- Experience
+	11	70048	1	20 -- Cloak of Secrecy
+	12	70102	1	9 -- Zen Bean
+	13	70051	1	20 -- Sage King's Glove
+	14	70049	1	35 -- Lucy's Ring
+	15	25040	1	1 -- Blessing Scroll
+	16	30045	1	26 -- Scorpion Needle
+	17	30051	1	26 -- Unknown Talisman
+	18	30038	1	26 -- Tiger Hide
+	19	30070	1	26 -- Wolf Fur+
+	20	30023	1	26 -- White Tiger Hide
+	21	30033	1	26 -- Broken Porcelain
+	22	30011	1	26 -- Ball
+	23	30027	1	26 -- Wolf Fur
+	24	30082	1	26 -- Snake Tail+
+	25	30035	1	26 -- Face Cream
+	26	30010	1	26 -- Bear Gall
+	27	30055	1	26 -- Scorpion Claw
+	28	30006	1	26 -- Orc Tooth
+	29	30003	1	26 -- Pig Nose
+	30	30017	1	26 -- Ornamental Hairpin
+}
+Group	李_寧
+{
+	Vnum	53501 -- Fire Phoenix Cage
+	Type	pct
+	1	53001	1	100 -- Fire Phoenix
+}
+Group	李_튿
+{
+	Vnum	53502 -- Reindeer Calf Chest
+	Type	pct
+	1	53002	1	100 -- Reindeer Calf
+}
+Group	李_寧
+{
+	Vnum	53503 -- Ice Phoenix Cage
+	Type	pct
+	1	53003	1	100 -- Ice Phoenix
+}
+Group	李_튿황
+{
+	Vnum	53505 -- Baby Azrael Chest
+	Type	pct
+	1	53005	1	100 -- Baby Azrael
+}
+Group	李_튿황_special
+{
+	Vnum	53506 -- Baby Azrael Chest (Gold)
+	Type	pct
+	1	53006	1	100 -- Baby Azrael (gold)
+}
+Group	李_튿_2012
+{
+	Vnum	53507 -- Bambi Chest
+	Type	pct
+	1	53007	1	100 -- Bambi
+}
+Group	李_튿
+{
+	Vnum	53508 -- Knuud Chest
+	Type	pct
+	1	53008	1	100 -- Knuud
+}
+Group	李_튿
+{
+	Vnum	53509 -- Bao Bao Chest
+	Type	pct
+	1	53009	1	100 -- Bao Bao
+}
+Group	李_튿
+{
+	Vnum	53510 -- Leonidas Chest
+	Type	pct
+	1	53010	1	100 -- Leonidas
+}
+Group	李_튿호
+{
+	Vnum	53511 -- Khan Chest
+	Type	pct
+	1	53011	1	100 -- Khan
+}
+Group	李_튿
+{
+	Vnum	53512 -- Porky Chest
+	Type	pct
+	1	53012	1	100 -- Porky
+}
+Group	李_튿
+{
+	Vnum	53513 -- Rufus Chest
+	Type	pct
+	1	53013	1	100 -- Rufus
+}
+Group	李_
+{
+	Vnum	53514 -- Mini-Executor Chest
+	Type	pct
+	1	53014	1	100 -- Chubby Mini-Executor
+}
+Group	李__특
+{
+	Vnum	53515 -- Mini-ExecutorChest(Gold)
+	Type	pct
+	1	53015	1	100 -- Chubby Mini-Executor (g)
+}
+Group	李_念
+{
+	Vnum	53516 -- Bone Chest
+	Type	pct
+	1	53016	1	100 -- Boney
+}
+Group	李_荑겊
+{
+	Vnum	53517 -- Jade Cage
+	Type	pct
+	1	53017	1	100 -- Jade Phoenix
+}
+Group	絹
+{
+	Vnum	10031
+	Type	Quest
+	1	70058	1	1 -- Teleportation Ring
+	2	76042	1	1 -- Teleportation Ring
+}
+Group	탈告환
+{
+	Vnum	10032
+	Type	Quest
+	1	52701	1	1 -- Lion Certificate
+	2	52702	1	1 -- Tiger Certificate
+	3	52703	1	1 -- Wild Boar Certificate
+	4	52704	1	1 -- Wolf Certificate
+	5	52705	1	1 -- Reindeer Certificate (m)
+	6	52706	1	1 -- Reindeer Certificate (f)
+	7	52707	1	1 -- Dragor Certificate
+	8	52708	1	1 -- Moa Certificate
+}
+#Group	퓜+50
+#{
+#	Vnum	10000
+#	1	39002	1	1 -- Experience Ring (1h)
+#	2	70005	1	1 -- Experience Ring (1h)
+#	3	72001	1	1 -- Experience Ring (10h)
+#	4	72002	1	1 -- Experience Ring (30m)
+#	5	72003	1	1 -- Experience Ring (3h)
+#	6	72303	1	1 -- Experience Ring (1h)
+#	7	72049	1	1 -- Experience Ring (30h)
+#	8	72050	1	1 -- Experience Ring (60h)
+#}
+#Group	弱
+#{
+#	Vnum	10002
+#	1	70043	1	1 -- Thief's Gloves (2h)
+#	2	72004	1	1 -- Thief's Gloves (10h)
+#	3	72005	1	1 -- Thief's Gloves (30m)
+#	4	72006	1	1 -- Thief's Gloves (3h)
+#}
+Group	甁
+{
+	Vnum	10003
+	1	71049	1	1 -- Silk Bundle (10d)
+	2	72007	1	1 -- Silk Bundle (10h)
+	3	72008	1	1 -- Silk Bundle (30m)
+	4	72009	1	1 -- Silk Bundle (3h)
+}
+Group	품
+{
+	Vnum	10004
+	1	38059	1	1 -- Emotion Mask (15d)
+	2	71011	1	1 -- Emotion Mask (30d)
+	3	71033	1	1 -- Emotion Mask (15d)
+	4	76054	1	1 -- Emotion Mask (7d)
+}
+Group	풉?
+{
+	Vnum	10008
+	1	72010	1	1 -- Lovebird Feather (15m)
+	2	72011	1	1 -- Lovebird Feather (30m)
+	3	72012	1	1 -- Lovebird Feather (3h)
+}
+Group	
+{
+	Vnum	10009
+	1	72013	1	1 -- Fishing Book (15m)
+	2	72014	1	1 -- Fishing Book (30m)
+	3	72015	1	1 -- Fishing Book (3h)
+}
+Group	
+{
+	Vnum	10010
+	1	72043	1	1 -- Book of the Leader (15m)
+	2	72044	1	1 -- Book of the Leader (30m)
+	3	72045	1	1 -- Book of the Leader (3h)
+	4	70003	1	1 -- Book of the Leader (2h)
+	5	71012	1	1 -- Book of the Leader (3h)
+	6	72302	1	1 -- Book of the Leader (2h)
+	7	76011	1	1 -- Book of the Leader (1h)
+}
+Group	3퓬
+{
+	Vnum	10011
+	1	71010	1	1 -- Third Hand (30d)
+	2	72016	1	1 -- Third Hand (15m)
+	3	72017	1	1 -- Third Hand (30m)
+	4	72018	1	1 -- Third Hand (3h)
+	5	76053	1	1 -- Third Hand (3d)
+}
+Group	창확
+{
+	Vnum	10021
+	1	71009	1	1 -- Storage Chest (30d)
+	2	72019	1	1 -- Storage Chest (15m)
+	3	72020	1	1 -- Storage Chest (30m)
+	4	72021	1	1 -- Storage Chest (3h)
+}
+Group	풉화
+{
+	Vnum	10024
+	1	72022	1	1 -- Lucky Medal (10h)
+	2	72023	1	1 -- Lucky Medal (30m)
+	3	72024	1	1 -- Lucky Medal (3h)
+}
+Group	
+{
+	Vnum	10025
+	1	70006	1	1 -- Language Ring (1h)
+	2	70047	1	1 -- Language Ring (5m)
+	3	71005	1	1 -- Language Ring (7d)
+	4	71006	1	1 -- Language Ring (15d)
+	5	71007	1	1 -- Language Ring (30d)
+}
+Group	__캐
+{
+	Vnum	10030
+	1	71115	1	1 -- Wild Boar (blue)
+	2	71117	1	1 -- Wolf (blue)
+	3	71119	1	1 -- Tiger (blue)
+	4	71121	1	1 -- Lion (blue)
+}
+Group	flame_dungeon_ticket_group
+{
+	Vnum	10033
+	1	71174	1	1 -- Passage Ticket
+	2	71175	1	1 -- Passage Ticket
+}
+Group	dungeon_ticket_group
+{
+	Vnum	10034
+	1	71095	1	1 -- Passage Ticket
+	2	71130	1	1 -- Passage Ticket
+	3	76019	1	1 -- Passage Ticket
+}
+Group	grotto_ticket_group
+{
+	Vnum	10035
+	1	30190	1	1 -- Blood Stone
+	2	30191	1	1 -- Blood Stone
+	3	76010	1	1 -- Blood Stone
+}
+Group	mysterious_ticket_group
+{
+	Vnum	10036
+	1	70408	1	1 -- Mysterious Ticket
+	2	70407	1	1 -- Myst. Ticket (Premium)
+}
+Group	red_dragon_lair_ticket_group
+{
+	Vnum	10037
+	1	71201	1	1 -- Passage Ticket (Meley)
+	2	72342	1	1 -- Passage Ticket (Meley)
+}
+#Group	퓜+100
+#{
+#	Vnum	10040
+#	1	72057	1	1 -- Double Experience Ring (36h)
+#}
+#Group	퓜+200
+#{
+#	Vnum	10041
+#	1	72062	1	1 -- Experience Ring +200 (3h)
+#}
+Group	+100
+{
+	Vnum	10042
+	1	72059	1	1 -- Book of the Leader+ (2h)
+	2	72060	1	1 -- Book of the Leader+ (3h)
+}
+Group 
+{
+	Vnum	10050
+	Type	special
+	1	71148	100000	1
+	2	71149	100001	1
+	3	71158	100002	1
+	4	71135	100003	1
+	5	71136	100004	1
+	6	71143	100005	1
+	7	71145	100006	1
+	8	71188	100007	1
+	9	71199	100008	1
+	10	71202	100009	1
+	11	72054	100010	1
+	12	76030	100011	1
+	13	76047	100011	1
+	14	72703	100030	1
+	15	72704	100031	1
+	16	72705	100032	1
+	17	72706	100033	1
+	18	72709	100030	1
+	19	72710	100034	1
+	20	72711	100035	1
+	21	72712	100036	1
+}
+Group _Element1
+{
+	Vnum	10051
+	Type	special
+	1	39119	100012	1
+}
+Group _Element2
+{
+	Vnum	10052
+	Type	special
+	1	39120	100013	1
+}
+Group 憺
+{
+	Vnum	100000
+	Type	ATTR
+	1	66	30 -- APPLY_MALL_EXPBONUS
+	2	78	20 -- APPLY_RESIST_WARRIOR
+	3	79	20 -- APPLY_RESIST_ASSASSIN
+	4	95	20 -- APPLY_RESIST_WOLFMAN
+	5	63	30 -- APPLY_ATT_BONUS_TO_MONSTER
+	6	69	10 -- APPLY_MAX_HP_PCT
+	7	70	10 -- APPLY_MAX_SP_PCT
+	effect	"d:/ymir work/effect/etc/buff/buff_item5.mse"
+}
+Group 憺2
+{
+	Vnum	100001
+	Type	ATTR
+	1	66	30 -- APPLY_MALL_EXPBONUS
+	2	80	20 -- APPLY_RESIST_SURA
+	3	81	20 -- APPLY_RESIST_SHAMAN
+	4	95	20 -- APPLY_RESIST_WOLFMAN
+	5	63	30 -- APPLY_ATT_BONUS_TO_MONSTER
+	6	69	10 -- APPLY_MAX_HP_PCT
+	7	70	10 -- APPLY_MAX_SP_PCT
+	effect	"d:\ymir work\effect\etc\buff\buff_item5.mse"
+}
+Group 憺3
+{
+	Vnum	100002
+	Type	ATTR
+	1	66	50 -- APPLY_MALL_EXPBONUS
+	2	64	30 -- APPLY_MALL_ATTBONUS
+	3	7	20 -- APPLY_ATT_SPEED
+	4	9	20 -- APPLY_CAST_SPEED
+	5	69	10 -- APPLY_MAX_HP_PCT
+	6	70	10 -- APPLY_MAX_SP_PCT
+	effect	"d:\ymir work\effect\etc\buff\buff_symbol1.mse"
+}
+Group 憺4
+{
+	Vnum	100003
+	Type	ATTR
+	1	66	50 -- APPLY_MALL_EXPBONUS
+	2	7	20 -- APPLY_ATT_SPEED
+	3	9	20 -- APPLY_CAST_SPEED
+	4	64	30 -- APPLY_MALL_ATTBONUS
+	5	69	10 -- APPLY_MAX_HP_PCT
+	6	70	10 -- APPLY_MAX_SP_PCT
+	7	84	5 -- APPLY_COSTUME_ATTR_BONUS
+}
+Group 憺5
+{
+	Vnum	100004
+	Type	ATTR
+	1	66	50 -- APPLY_MALL_EXPBONUS
+	2	64	30 -- APPLY_MALL_ATTBONUS
+	3	7	20 -- APPLY_ATT_SPEED
+	4	9	20 -- APPLY_CAST_SPEED
+	5	69	10 -- APPLY_MAX_HP_PCT
+	6	70	10 -- APPLY_MAX_SP_PCT
+}
+Group 憺6
+{
+	Vnum	100005
+	Type	ATTR
+	1	66	50 -- APPLY_MALL_EXPBONUS
+	2	7	20 -- APPLY_ATT_SPEED
+	3	9	20 -- APPLY_CAST_SPEED
+	4	63	30 -- APPLY_ATT_BONUS_TO_MONSTER
+	5	69	10 -- APPLY_MAX_HP_PCT
+	6	70	10 -- APPLY_MAX_SP_PCT
+}
+Group 憺7
+{
+	Vnum	100006
+	Type	ATTR
+	1	66	30 -- APPLY_MALL_EXPBONUS
+	2	7	10 -- APPLY_ATT_SPEED
+	3	9	10 -- APPLY_CAST_SPEED
+	4	69	5 -- APPLY_MAX_HP_PCT
+	5	70	5 -- APPLY_MAX_SP_PCT
+	6	63	10 -- APPLY_ATT_BONUS_TO_MONSTER
+}
+Group 憺8
+{
+	Vnum	100007
+	Type	ATTR
+	1	66	50 -- APPLY_MALL_EXPBONUS
+	2	55	30 -- APPLY_MAGIC_ATT_GRADE
+	3	7	20 -- APPLY_ATT_SPEED
+	4	9	20 -- APPLY_CAST_SPEED
+	5	69	10 -- APPLY_MAX_HP_PCT
+	6	70	10 -- APPLY_MAX_SP_PCT
+	effect	"d:/ymir work/effect/etc/buff/buff_item8.mse"
+}
+Group 憺9
+{
+	Vnum	100008
+	Type	ATTR
+	1	66	50 -- APPLY_MALL_EXPBONUS
+	2	7	20 -- APPLY_ATT_SPEED
+	3	9	20 -- APPLY_CAST_SPEED
+	4	63	10 -- APPLY_ATT_BONUS_TO_MONSTER
+	5	69	10 -- APPLY_MAX_HP_PCT
+	6	70	10 -- APPLY_MAX_SP_PCT
+	effect	"d:/ymir work/effect/etc/buff/buff_item10.mse"
+}
+Group 憺10
+{
+	Vnum	100009
+	Type	ATTR
+	1	66	50 -- APPLY_MALL_EXPBONUS
+	2	7	20 -- APPLY_ATT_SPEED
+	3	9	20 -- APPLY_CAST_SPEED
+	4	63	10 -- APPLY_ATT_BONUS_TO_MONSTER
+	5	64	30 -- APPLY_MALL_ATTBONUS
+	6	55	30 -- APPLY_MAGIC_ATT_GRADE
+	effect	"d:/ymir work/effect/etc/buff/buff_item13.mse"
+}
+Group 憺11
+{
+	Vnum	100010
+	Type	ATTR
+	1	64	30 -- APPLY_MALL_ATTBONUS
+	2	55	30 -- APPLY_MAGIC_ATT_GRADE
+	3	7	20 -- APPLY_ATT_SPEED
+	4	9	20 -- APPLY_CAST_SPEED
+	5	115	10 -- APPLY_RESIST_HUMAN
+	6	73	10 -- APPLY_SKILL_DEFEND_BONUS
+	effect	"d:/ymir work/effect/etc/buff/buff_item14.mse"
+}
+Group 憺12-13
+{
+	Vnum	100011
+	Type	ATTR
+	1	66	50 -- APPLY_MALL_EXPBONUS
+	2	7	20 -- APPLY_ATT_SPEED
+	3	9	20 -- APPLY_CAST_SPEED
+	4	63	10 -- APPLY_ATT_BONUS_TO_MONSTER
+	5	69	10 -- APPLY_MAX_HP_PCT
+	6	70	10 -- APPLY_MAX_SP_PCT
+	effect	"d:/ymir work/effect/etc/buff/buff_item16.mse"
+}
+Group 憺14
+{
+	Vnum	100012
+	Type	ATTR
+	1	99	10 -- APPLY_ENCHANT_ELECT
+	2	100	10 -- APPLY_ENCHANT_FIRE
+	3	101	10 -- APPLY_ENCHANT_ICE
+	4	102	10 -- APPLY_ENCHANT_WIND
+	5	103	10 -- APPLY_ENCHANT_EARTH
+	6	104	10 -- APPLY_ENCHANT_DARK
+	effect	"d:\ymir work\effect\etc\buff\buff_item18_element01.mse"
+}
+Group 憺15
+{
+	Vnum	100013
+	Type	ATTR
+	1	35	10 -- APPLY_RESIST_FIRE
+	2	36	10 -- APPLY_RESIST_ELEC
+	3	38	10 -- APPLY_RESIST_WIND
+	4	87	10 -- APPLY_RESIST_ICE
+	5	88	10 -- APPLY_RESIST_EARTH
+	6	89	10 -- APPLY_RESIST_DARK
+	effect	"d:\ymir work\effect\etc\buff\buff_item18_element02.mse"
+}
+Group 憺30
+{
+	Vnum	100030
+	Type	ATTR
+	1	53	200 -- APPLY_ATT_GRADE_BONUS
+}
+Group 憺31
+{
+	Vnum	100031
+	Type	ATTR
+	1	54	200 -- APPLY_DEF_GRADE_BONUS
+}
+Group 憺32
+{
+	Vnum	100032
+	Type	ATTR
+	1	71	15 -- APPLY_SKILL_DAMAGE_BONUS
+}
+Group 憺33
+{
+	Vnum	100033
+	Type	ATTR
+	1	73	15 -- APPLY_SKILL_DEFEND_BONUS
+}
+Group 憺34
+{
+	Vnum	100034
+	Type	ATTR
+	1	54	300 -- APPLY_DEF_GRADE_BONUS
+}
+Group 憺35
+{
+	Vnum	100035
+	Type	ATTR
+	1	73	30 -- APPLY_SKILL_DAMAGE_BONUS
+}
+Group 憺36
+{
+	Vnum	100036
+	Type	ATTR
+	1	73	30 -- APPLY_SKILL_DEFEND_BONUS
+}
+
+Group	퓜
+{
+	Vnum	10000
+	Type	special
+	1	39002	110010	1 -- Experience Ring (1h)
+	2	70005	110010	1 -- Experience Ring (1h)
+	3	72001	110010	1 -- Experience Ring (10h)
+	4	72002	110010	1 -- Experience Ring (30m)
+	5	72003	110010	1 -- Experience Ring (3h)
+	6	72303	110010	1 -- Experience Ring (1h)
+	7	72049	110010	1 -- Experience Ring (30h)
+	8	72050	110010	1 -- Experience Ring (60h)
+	9	72057	110011	1 -- Double Experience Ring (36h)
+	10	72062	110012	1 -- Experience Ring +200 (3h)
+}
+Group	퓜+50
+{
+	Vnum	110010
+	Type	ATTR
+	1	66	50 -- APPLY_MALL_EXPBONUS
+}
+Group	퓜+100
+{
+	Vnum	110011
+	Type	ATTR
+	1	66	100 -- APPLY_MALL_EXPBONUS
+}
+Group	퓜+200
+{
+	Vnum	110012
+	Type	ATTR
+	1	66	200 -- APPLY_MALL_EXPBONUS
+}
+Group	弱
+{
+	Vnum	10002
+	Type	special
+	1	70043	110020	1 -- Thief's Gloves (2h)
+	2	72004	110020	1 -- Thief's Gloves (10h)
+	3	72005	110020	1 -- Thief's Gloves (30m)
+	4	72006	110020	1 -- Thief's Gloves (3h)
+}
+Group	弱+50
+{
+	Vnum	110020
+	Type	ATTR
+	1	67	50 -- APPLY_MALL_ITEMBONUS
+}
+Group	
+{
+	Vnum	10010
+	Type	special
+	1	72043	110100	1 -- Book of the Leader (15m)
+	2	72044	110100	1 -- Book of the Leader (30m)
+	3	72045	110100	1 -- Book of the Leader (3h)
+	4	70003	110100	1 -- Book of the Leader (2h)
+	5	71012	110100	1 -- Book of the Leader (3h)
+	6	72302	110100	1 -- Book of the Leader (2h)
+	7	76011	110100	1 -- Book of the Leader (1h)
+	8	72059	110101	1 -- Book of the Leader+ (2h)
+	9	72060	110101	1 -- Book of the Leader+ (3h)
+}
+Group	환
+{
+	Vnum	71036
+	1	mob	691	100
+}
+Group	閨玲환
+{
+	Vnum	71037
+	1	mob	791	100
+}
+Group	卵탁抉환
+{
+	Vnum	71038
+	1	mob	2091	100
+}
+Group	킴潁렴북셜
+{
+	Vnum	71039
+	1	mob	2191	100
+}
+Group	화欖환
+{
+	Vnum	71040
+	1	mob	2206	100
+}
+Group	호환
+{
+	Vnum	71041
+	1	mob	1901	100
+}
+Group	沽欖환
+{
+	Vnum	71042
+	1	mob	1096	100
+}
+Group	暠환
+{
+	Vnum	71043
+	1	mob	1304	100
+}
+Group	화呪ㅈ티환
+{
+	Vnum	71057
+	1	mob	20049	100
+}
+Group	티환
+{
+	Vnum	71058
+	1	mob	20050	100
+}
+Group	티환
+{
+	Vnum	71059
+	1	mob	20051	100
+}
+Group	賻티환
+{
+	Vnum	71060
+	1	mob	20052	100
+}
+Group	티환
+{
+	Vnum	71061
+	1	mob	20053	100
+}
+Group	秉티환
+{
+	Vnum	71062
+	1	mob	20054	100
+}
+Group	환
+{
+	Vnum	71063
+	1	mob	20055	100
+}
+Group	賻티환
+{
+	Vnum	71064
+	1	mob	20056	100
+}
+Group	티환
+{
+	Vnum	71065
+	1	mob	20057	100
+}
+Group	靡티환
+{
+	Vnum	71066
+	1	mob	20058	100
+}
+Group	천映ㅖ셜
+{
+	Vnum	71067
+	1	mob	20059	100
+}
+Group	珂貧틴환
+{
+	Vnum	71080
+	1	mob	8001	10
+	2	mob	8002	10
+	3	mob	8003	10
+	4	mob	8004	10
+	5	mob	8005	10
+}
+Group	薩貧틴환
+{
+	Vnum	71081
+	1	mob	8006	10
+	2	mob	8007	10
+	3	mob	8008	10
+	4	mob	8009	10
+	5	mob	8010	10
+}
+Group	貧틴환
+{
+	Vnum	71082
+	1	mob	8011	10
+	2	mob	8012	10
+	3	mob	8013	10
+	4	mob	8014	10
+	5	mob	8024	10
+	6	mob	8025	10
+	7	mob	8026	10
+	8	mob	8027	10
+}
+Group	佯
+{
+	Vnum	50006 -- Gold Treasure Chest
+	1	50300	1	100 -- Skill Book
+	2	80008	1	10 -- Lump of Gold
+	3	50002	1	10 -- Gold Ring
+	4	70012	1	10 -- Goddess Tear
+	5	70008	1	10 -- White Flag
+	6	70038	1	10 -- Bravery Cape
+	7	70048	1	10 -- Cloak of Secrecy
+	8	70049	1	10 -- Lucy's Ring
+	9	70050	1	10 -- Sage King's Symbol
+	10	70051	1	10 -- Sage King's Glove
+	11	치	10000	30 -- Exp.
+	12	치	20000	30 -- Exp.
+	13	치	30000	30 -- Exp.
+	14	치	40000	30 -- Exp.
+	15	치	50000	30 -- Exp.
+	16	慕	60000	15 -- Yang
+	17	慕	70000	15 -- Yang
+	18	慕	80000	15 -- Yang
+	19	慕	90000	15 -- Yang
+	20	慕	100000	15 -- Yang
+	21	25040	1	30 -- Blessing Scroll
+	22	121	1	8	40 -- Flying Wizard Sword+1
+	23	122	1	5	40 -- Flying Wizard Sword+2
+	24	1081	1	8	40 -- Rib Knife+1
+	25	1082	1	5	40 -- Rib Knife+2
+	26	3111	1	8	40 -- Salvation Blade+1
+	27	3112	1	5	40 -- Salvation Blade+2
+	28	2111	1	8	40 -- Unicorn Bow+1
+	29	2112	1	5	40 -- Unicorn Bow+2
+	30	5071	1	8	40 -- Golden Bug Bell+1
+	31	5072	1	5	40 -- Golden Bug Bell+2
+	32	7111	1	8	40 -- Eyebrow Fan+1
+	33	7112	1	5	40 -- Eyebrow Fan+2
+	34	30023	1	10 -- White Tiger Hide
+	35	30045	1	10 -- Scorpion Needle
+	36	30038	1	10 -- Tiger Hide
+	37	30051	1	10 -- Unknown Talisman
+	38	30011	1	10 -- Ball
+	39	30070	1	10 -- Wolf Fur+
+	40	30017	1	10 -- Ornamental Hairpin
+	41	30033	1	10 -- Broken Porcelain
+	42	30055	1	10 -- Scorpion Claw
+	43	30053	1	10 -- Bear Foot Skin
+	44	30007	1	10 -- Orc Amulet
+	45	30031	1	10 -- Ornament
+	46	30028	1	10 -- Wolf Claw
+	47	30047	1	10 -- Curse Book
+	48	30052	1	10 -- Flag
+	49	30027	1	10 -- Wolf Fur
+	50	30003	1	10 -- Pig Nose
+	51	30081	1	10 -- Scorpion Tail+
+	52	30022	1	10 -- Snake Tail
+	53	30010	1	10 -- Bear Gall
+	54	30025	1	10 -- Spider's Poison Sack
+	55	30004	1	10 -- Wild Boar Tooth
+	56	30050	1	10 -- Ice Marble
+	57	30075	1	40 -- Shiriken+
+}
+Group	佯
+{
+	Vnum	50007 -- Silver Treasure Chest
+	1	27001	50	43 -- Red Potion (S)
+	2	27002	30	43 -- Red Potion (M)
+	3	27003	20	43 -- Red Potion (L)
+	4	27004	50	43 -- Blue Potion (S)
+	5	27005	30	43 -- Blue Potion (M)
+	6	27006	20	43 -- Blue Potion (L)
+	7	치	5000	75 -- Exp.
+	8	치	10000	75 -- Exp.
+	9	치	15000	75 -- Exp.
+	10	치	20000	75 -- Exp.
+	11	慕	10000	40 -- Yang
+	12	慕	15000	40 -- Yang
+	13	慕	20000	40 -- Yang
+	14	慕	25000	40 -- Yang
+	15	慕	30000	40 -- Yang
+	16	30030	1	12 -- Rusty Blade
+	17	30032	1	12 -- Black Uniform
+	18	30059	1	12 -- Spider Legs
+	19	30056	1	12 -- Spider Web
+	20	30071	1	12 -- Bear Gall+
+	21	30075	1	12 -- Shiriken+
+	22	30014	1	12 -- Yeti Fur
+	23	30061	1	12 -- Frog's Legs
+	24	30083	1	12 -- Unknown Medicine+
+	25	30074	1	12 -- Black Uniform+
+	26	30057	1	12 -- Spider Eyes
+	27	30016	1	12 -- Demon's Gem
+	28	30048	1	12 -- Piece of Ice
+	29	30009	1	12 -- Unknown Medicine
+	30	30037	1	12 -- Tiger Claw
+	31	30039	1	12 -- Piece of Fabric
+}
+Group	佯+
+{
+	Vnum	50012 -- Gold Treasure Chest+
+	1	50401	1	20 -- Three-Way Cut Manual
+	2	50402	1	20 -- Sword Spin Manual
+	3	50403	1	20 -- Berserk Manual
+	4	50404	1	20 -- Aura of the Sword Manual
+	5	50405	1	20 -- Dash Manual
+	6	50406	1	20 -- Life Force Manual
+	7	50416	1	20 -- Strike Manual
+	8	50417	1	20 -- Bash Manual
+	9	50418	1	20 -- Pounding Manual
+	10	50419	1	20 -- Strong Body Manual
+	11	50420	1	20 -- Sword Strike Manual
+	12	50421	1	20 -- Sword Orb Manual
+	13	50431	1	20 -- Ambush Manual
+	14	50432	1	20 -- Fast Attack Manual
+	15	50433	1	20 -- Rolling Dagger Manual
+	16	50434	1	20 -- Disguise Manual
+	17	50435	1	20 -- Poisonous Cloud Manual
+	18	50436	1	20 -- Insidious Poison Manual
+	19	50446	1	20 -- Repetitive Shot Manual
+	20	50447	1	20 -- Arrow Shower Manual
+	21	50448	1	20 -- Fire Arrow Manual
+	22	50449	1	20 -- Feather Walk Manual
+	23	50450	1	20 -- Poison Arrow Manual
+	24	50451	1	20 -- Spark Manual
+	25	50461	1	20 -- Finger Strike Manual
+	26	50462	1	20 -- Dragon Swirl Manual
+	27	50463	1	20 -- Enchanted Blade Manual
+	28	50464	1	20 -- Fear Manual
+	29	50465	1	20 -- Enchanted Armour Manual
+	30	50466	1	20 -- Dispel Manual
+	31	50476	1	20 -- Dark Strike Manual
+	32	50477	1	20 -- Flame Strike Manual
+	33	50478	1	20 -- Flame Spirit Manual
+	34	50479	1	20 -- Dark Protection Manual
+	35	50480	1	20 -- Spirit Strike Manual
+	36	50481	1	20 -- Dark Orb Manual
+	37	50491	1	20 -- Flying Talisman Manual
+	38	50492	1	20 -- Shooting Dragon Manual
+	39	50493	1	20 -- Dragon's Roar Manual
+	40	50494	1	20 -- Blessing Manual
+	41	50495	1	20 -- Reflect Manual
+	42	50496	1	20 -- Dragon's Aid Manual
+	43	50506	1	20 -- Lightning Throw Manual
+	44	50507	1	20 -- Summon Lightning Manual
+	45	50508	1	20 -- Lightning Claw Manual
+	46	50509	1	20 -- Cure Manual
+	47	50510	1	20 -- Swiftness Manual
+	48	50511	1	20 -- Attack Manual
+	49	50530	1	20 -- Shred Manual
+	50	50531	1	20 -- Wolf's Breath Manual
+	51	50532	1	20 -- Wolf Pounce Manual
+	52	50533	1	20 -- Wolf's Claw Manual
+	53	50534	1	20 -- Crimson Wolf Soul Manual
+	54	50535	1	20 -- Indigo Wolf Soul Manual
+	55	25040	1	75 -- Blessing Scroll
+	56	6032	1	46	40 -- Steel Claw+2
+	57	6033	1	20	40 -- Steel Claw+3
+	58	132	1	46	40 -- Half Moon Sword+2
+	59	133	1	20	40 -- Half Moon Sword+3
+	60	1092	1	46	40 -- Chakram+2
+	61	1093	1	20	40 -- Chakram+3
+	62	3122	1	46	40 -- Lion Slayer+2
+	63	3123	1	20	40 -- Lion Slayer+3
+	64	2122	1	46	40 -- Giant Wing Bow+2
+	65	2123	1	20	40 -- Giant Wing Bow+3
+	66	5082	1	46	40 -- Steel Bug Bell+2
+	67	5083	1	20	40 -- Steel Bug Bell+3
+	68	7122	1	46	40 -- Sun Fan+2
+	69	7123	1	20	40 -- Sun Fan+3
+	70	13202	1	150	40 -- Black Round Shield+2
+	71	13203	1	50	40 -- Black Round Shield+3
+}
+Group	佯+
+{
+	Vnum	50013 -- Silver Treasure Chest+
+	1	70012	1	57 -- Goddess Tear
+	2	70008	1	57 -- White Flag
+	3	70038	1	57 -- Bravery Cape
+	4	70048	1	57 -- Cloak of Secrecy
+	5	70049	1	57 -- Lucy's Ring
+	6	70050	1	57 -- Sage King's Symbol
+	7	70051	1	57 -- Sage King's Glove
+	8	13192	1	150 -- Pentagon Shield+2
+	9	13193	1	50 -- Pentagon Shield+3
+	10	12222	1	37	40 -- Iron Helmet+2
+	11	12223	1	38	40 -- Iron Helmet+3
+	12	12362	1	37	40 -- Chain Hood+2
+	13	12363	1	38	40 -- Chain Hood+3
+	14	12502	1	37	40 -- Mocking Helmet+2
+	15	12503	1	38	40 -- Mocking Helmet+3
+	16	12642	1	37	40 -- Phoenix Hat+2
+	17	12643	1	38	40 -- Phoenix Hat+3
+	18	21512	1	37	40 -- Ebon Cloth Helmet+2
+	19	21513	1	38	40 -- Ebon Cloth Helmet+3
+	20	30015	1	40 -- Demon's Keepsake
+	21	30035	1	40 -- Face Cream
+	22	30058	1	40 -- Spider Egg Sack
+	23	30006	1	40 -- Orc Tooth
+	24	30082	1	40 -- Snake Tail+
+	25	30076	1	40 -- Orc Amulet+
+	26	30018	1	40 -- Red Hairband
+	27	30046	1	40 -- Scorpion Tail
+	28	30086	1	40 -- Demon's Keepsake+
+	29	30072	1	40 -- Bear Foot Skin+
+	30	30080	1	40 -- Curse Book+
+	31	30077	1	40 -- Orc Tooth+
+	32	30069	1	40 -- Wolf Claw+
+	33	30067	1	40 -- Snakeskin
+	34	30075	1	40 -- Shiriken+
+}
+Group	eva_box
+{
+	Vnum	50124 -- Rotten Wooden Box
+	1	71114	5	40 -- Wild Boar (yellow)
+	2	71116	5	30 -- Wolf (yellow)
+	3	71118	5	20 -- Tiger (yellow)
+	4	71120	5	10 -- Lion (yellow)
+}
+Group	關__
+{
+	Vnum	50120 -- Iron Casket
+	1	14085	1	7 -- Jade Bracelet+5
+	2	14185	1	7 -- Amethyst Bracelet+5
+	3	14125	1	7 -- Pearl Bracelet+5
+	4	14142	1	7 -- White Gold Bracelet+2
+	5	14164	1	7 -- Crystal Bracelet+4
+	6	14184	1	7 -- Amethyst Bracelet+4
+	7	14202	1	7 -- Heaven's Tear Bracelet+2
+	8	30190	1	2 -- Blood Stone
+	9	71018	1	6 -- Blessing of Life
+	10	71019	1	6 -- Blessing of Magic
+	11	71044	1	6 -- Critical Strike
+	12	71004	1	6 -- Medal of the Dragon
+	13	72003	1	3 -- Experience Ring (3h)
+	14	72006	1	3 -- Thief's Gloves
+	15	71017	1	3 -- Lucky Medal
+	16	72015	1	3 -- Fishing Book
+	17	72012	1	3 -- Lovebird Feather
+	18	27987	1	7 -- Clam
+	19	71082	1	3 -- Metin Stone(H)
+}
+Group	關__
+{
+	Vnum	50121 -- Iron Box
+	1	16045	1	7 -- Silver Necklace+5
+	2	16065	1	7 -- Golden Necklace+5
+	3	16084	1	7 -- Jade Necklace+4
+	4	16104	1	7 -- Ebony Necklace+4
+	5	16124	1	7 -- Pearl Necklace+4
+	6	16144	1	7 -- White Gold Necklace+4
+	7	16164	1	7 -- Crystal Necklace+4
+	8	16184	1	7 -- Amethyst Necklace+4
+	9	16202	1	7 -- Heaven's Tear Necklace+2
+	10	25040	1	3 -- Blessing Scroll
+	11	70024	1	3 -- Blessing Marble
+	12	71004	1	6 -- Medal of the Dragon
+	13	72003	1	3 -- Experience Ring (3h)
+	14	71016	1	3 -- Thief's Gloves
+	15	71017	1	3 -- Lucky Medal
+	16	72015	1	3 -- Fishing Book
+	17	72012	1	3 -- Lovebird Feather
+	18	27987	1	7 -- Clam
+	19	71082	1	3 -- Metin Stone(H)
+}
+Group	關_叩_
+{
+	Vnum	50122 -- Iron Chest
+	1	17084	1	7 -- Jade Earrings+4
+	2	17102	1	7 -- Ebony Earrings+2
+	3	17124	1	7 -- Pearl Earrings+4
+	4	17144	1	7 -- White Gold Earrings+4
+	5	17164	1	7 -- Crystal Earrings+4
+	6	17184	1	7 -- Amethyst Earrings+4
+	7	17202	1	7 -- Heaven's Tear Earrings+2
+	8	71034	1	6 -- Potion of Attack +15
+	9	71101	1	6 -- Potion of Haste
+	10	71020	1	6 -- Blessing of the Dragon
+	11	50124	1	5 -- Rotten Wooden Box
+	12	71004	1	5 -- Medal of the Dragon
+	13	72003	1	3 -- Experience Ring (3h)
+	14	71016	1	3 -- Thief's Gloves
+	15	71017	1	3 -- Lucky Medal
+	16	72015	1	3 -- Fishing Book
+	17	72012	1	3 -- Lovebird Feather
+	18	27987	1	5 -- Clam
+	19	71082	1	3 -- Metin Stone(H)
+}
+
+# --- Growth Pet System ---
+Group PetBookChest
+{
+	Vnum	55009
+	1	55010	1	1 --**Resistance (Warrior) Book
+	2	55011	1	1 --**Resistance (Sura) Book
+	3	55012	1	1 --**Resistance (Assassin) Book
+	4	55013	1	1 --**Resistance (Shaman) Book
+	5	55015	1	1 --**Berserker Book
+	6	55016	1	1 --**Anti-Magic Book
+	7	55017	1	1 --**Haste Book
+	8	55018	1	1 --**Drill Book
+	9	55019	1	1 --**Restoration Book
+	10	55020	1	1 --**Vampirism Book
+	11	55021	1	1 --**Spiritualism Book
+	12	55022	1	1 --**Bulwark Book
+	13	55023	1	1 --**Reflection Book
+	14	55024	1	1 --**Yang Drop Book
+	15	55025	1	1 --**Range Book
+	16	55026	1	1 --**Immortal Book
+	17	55027	1	1 --**Panacea Book
+	18	55034	1	1 --**Master Brewer Book
+	19	55035	1	1 --**Monster Hunter Book
+	20	55036	1	1 --**Eagle Eyes Book
+	21	55037	1	1 --**Life Drain Book
+	22	55038	1	1 --**Light as a Feather Book
+	--23	55014	1	1 --**Resistance (Lycan)
+}
diff --git a/server/server/home/metin2/Source/Server/common/length.h b/server/server/home/metin2/Source/Server/common/length.h
index 7a11f18..a545a9a 100644
--- a/server/server/home/metin2/Source/Server/common/length.h
+++ b/server/server/home/metin2/Source/Server/common/length.h
@@ -1,2047 +1,2001 @@
-#ifndef __INC_COMMON_LENGTH_H__
-#define __INC_COMMON_LENGTH_H__
-
-#include "service.h"
-
-#define WORD_MAX 0xffff
-
-#define POINT_TYPE WORD
-#define POINT_VALUE long
-#define POINT_MIN LONG_MIN
-#define POINT_MAX LONG_MAX
-
-enum EMisc
-{
-	MAX_HOST_LENGTH = 15,
-	IP_ADDRESS_LENGTH = 15,
-	LOGIN_MAX_LEN = 30,
-	PASSWD_MAX_LEN = 16,
-#if defined(__PLAYER_PER_ACCOUNT5__)
-	PLAYER_PER_ACCOUNT = 5,
-#else
-	PLAYER_PER_ACCOUNT = 4,
-#endif
-	ACCOUNT_STATUS_MAX_LEN = 8,
-	CHARACTER_NAME_MAX_LEN = 24,
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	COUNTRY_NAME_MAX_LEN = 2,
-#endif
-	SHOP_SIGN_MAX_LEN = 32,
-
-	ABILITY_MAX_NUM = 50,
-	EMPIRE_MAX_NUM = 4,
-	BANWORD_MAX_LEN = 24,
-	SOCIAL_ID_MAX_LEN = 18,
-
-#if defined(__RANKING_SYSTEM__)
-	PARTY_MAX_MEMBER = 8,
-#endif
-
-	GUILD_NAME_MAX_LEN = 12,
-
-#if defined(__MYSHOP_EXPANSION__)
-	SHOP_HOST_ITEM_MAX = 80, /* The maximum number of items of the pc host. */
-#endif
-	SHOP_HOST_ITEM_MAX_NUM = 40, /* 호스트의 최대 아이템 개수 */
-
-	SHOP_GUEST_ITEM_MAX_NUM = 18, /* 게스트의 최대 아이템 개수 */
-#if defined(__MYSHOP_EXPANSION__)
-	SHOP_PRICELIST_MAX_NUM = SHOP_HOST_ITEM_MAX,
-#else
-	SHOP_PRICELIST_MAX_NUM = 40, ///< 개인상점 가격정보 리스트에서 유지할 가격정보의 최대 갯수
-#endif
-
-#if defined(__MYSHOP_DECO__)
-	MYSHOP_MAX_TABS = 2,
-#endif
-
-	CHAT_MAX_LEN = 512,
-
-	QUICKSLOT_MAX_NUM = 36,
-
-	JOURNAL_MAX_NUM = 2,
-
-	QUERY_MAX_LEN = 16384,
-
-	FILE_MAX_LEN = 128,
-
-	PLAYER_EXP_TABLE_MAX = 120,
-	PLAYER_MAX_LEVEL_CONST = 120,
-
-#if defined(__CONQUEROR_LEVEL__)
-	PLAYER_CONQUEROR_EXP_TABLE_MAX = 30,
-	PLAYER_MAX_CONQUEROR_LEVEL_CONST = 30,
-#endif
-
-	GUILD_MAX_LEVEL = 20,
-	MOB_MAX_LEVEL = 100,
-
-	ATTRIBUTE_MAX_VALUE = 20,
-	CHARACTER_PATH_MAX_NUM = 64,
-	SKILL_MAX_NUM = 255,
-	SKILLBOOK_DELAY_MIN = 64800,
-	SKILLBOOK_DELAY_MAX = 108000,
-	SKILL_MAX_LEVEL = 40,
-
-	APPLY_NAME_MAX_LEN = 32,
-	EVENT_FLAG_NAME_MAX_LEN = 32,
-	CHARACTER_FOLDER_MAX_LEN = 64,
-
-	MOB_SKILL_MAX_NUM = 5,
-
-	POINT_MAX_NUM = 1000,
-
-	MAX_AMOUNT_OF_MALL_BONUS = 20,
-
-	//WEAR_MAX_NUM = 32,
-
-	GOLD_MAX = 2000000000, // 1999999999
-
-#if defined(__CHEQUE_SYSTEM__)
-	CHEQUE_MAX = 3000, // 999
-#endif
-
-#if defined(__GEM_SYSTEM__)
-	GEM_MAX = 1000000, // 999999
-#endif
-
-#if defined(_DEBUG) && defined(_WIN32)
-	MAX_MAP_ALLOW = 128,
-#else
-	MAX_MAP_ALLOW = 64,
-#endif
-
-	SHOP_TAB_NAME_MAX = 32,
-#if defined(__SHOPEX_TAB4__)
-	SHOP_TAB_COUNT_MAX = 4,
-#else
-	SHOP_TAB_COUNT_MAX = 3,
-#endif
-
-#if defined(__GEM_SHOP__)
-	GEM_SHOP_SLOT_COUNT = 9,
-#	if defined(__CONQUEROR_LEVEL__)
-	GEM_SHOP_SPECIAL_SLOT_COUNT = 3,
-#	endif
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	ROULETTE_ITEM_MAX = 20,
-#endif
-
-#ifdef __OFFLINE_SHOP__
-	OFFLINE_SHOP_ITEM_WIDTH = 10,
-	OFFLINE_SHOP_ITEM_HEIGHT = 8,
-	OFFLINE_SHOP_PAGES = 4,
-	OFFLINE_SHOP_ITEM_COUNT = OFFLINE_SHOP_ITEM_WIDTH * OFFLINE_SHOP_ITEM_HEIGHT * OFFLINE_SHOP_PAGES,
-	OFFLINE_SHOP_NAME_CHANGE_TIMELIMIT = 60 * 60,
-#endif
-
-	WINDOW_OPENER_MAX_DISTANCE = 1000,
-};
-
-enum EShopSearchMode
-{
-	MODE_NONE,
-	MODE_LOOKING,
-	MODE_TRADING,
-};
-
-enum EPrivateShopState
-{
-	STATE_UNAVAILABLE,
-	STATE_CLOSED,
-	STATE_OPEN,
-	STATE_MODIFY
-};
-
-enum EPrivateShopSearchState
-{
-	STATE_NON_EXISTENT,
-	STATE_REMOVED,
-	STATE_AVAILABLE,
-	STATE_RESTRICTED,
-};
-
-enum EInventoryPositions
-{
-	INVENTORY_WIDTH = 5,
-	INVENTORY_HEIGHT = 9,
-	INVENTORY_PAGE_SIZE = INVENTORY_WIDTH * INVENTORY_HEIGHT, // 45
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	INVENTORY_PAGE_COUNT = 4, // 180
-#else
-	INVENTORY_PAGE_COUNT = 2, // 90
-#endif
-	INVENTORY_MAX_NUM = INVENTORY_PAGE_SIZE * INVENTORY_PAGE_COUNT,
-
-	DRAGON_SOUL_BOX_SIZE = 32,
-	DRAGON_SOUL_BOX_COLUMN_NUM = 8,
-	DRAGON_SOUL_BOX_ROW_NUM = DRAGON_SOUL_BOX_SIZE / DRAGON_SOUL_BOX_COLUMN_NUM,
-	DRAGON_SOUL_REFINE_GRID_SIZE = 15,
-
-	BELT_INVENTORY_SLOT_WIDTH = 4,
-	BELT_INVENTORY_SLOT_HEIGHT = 4,
-	BELT_INVENTORY_SLOT_COUNT = BELT_INVENTORY_SLOT_WIDTH * BELT_INVENTORY_SLOT_HEIGHT,
-};
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-enum EExtendInven
-{
-	EX_INVENTORY_PAGE_COUNT = 2,
-	EX_INVENTORY_PAGE_START = 3,
-	EX_INVENTORY_STAGE_MAX = INVENTORY_HEIGHT * EX_INVENTORY_PAGE_COUNT,
-};
-
-enum EExtendInvenMsg
-{
-	EX_INVEN_FAIL_FALL_SHORT,
-	EX_INVEN_SUCCESS,
-	EX_INVEN_FAIL_FOURTH_PAGE_STAGE_MAX,
-};
-#endif
-
-#if defined(__REFINE_MSG_ADD__)
-enum ERefineFailType
-{
-	REFINE_FAIL_GRADE_DOWN,
-	REFINE_FAIL_DEL_ITEM,
-	REFINE_FAIL_KEEP_GRADE,
-	REFINE_FAIL_MAX,
-};
-#endif
-
-#if defined(__SKILLBOOK_COMB_SYSTEM__)
-enum ESkillBookCombination
-{
-	SKILLBOOK_COMB_SLOT_MAX = 10,
-	SKILLBOOK_COMB_COST = 1000000,
-};
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-enum EAttr67Add
-{
-	NPC_STORAGE_SLOT_MAX = 1,
-	ATTR67_MATERIAL_MAX_COUNT = 10,
-	ATTR67_SUPPORT_MAX_COUNT = 5,
-	ATTR67_SUCCESS_PER_MATERIAL = 2,
-	ATTR67_ADD_WAIT_TIME = 60 * 60 * 24,
-};
-#endif
-
-enum EDragonSoulDeckType
-{
-	DRAGON_SOUL_DECK_0,
-	DRAGON_SOUL_DECK_1,
-	DRAGON_SOUL_DECK_MAX_NUM = 2,
-
-	DRAGON_SOUL_DECK_RESERVED_MAX_NUM = 3, // NOTE: 중요! 아직 사용중이진 않지만, 3페이지 분량을 예약 해 둠. DS DECK을 늘릴 경우 반드시 그 수만큼 RESERVED에서 차감해야 함!
-};
-
-enum EPrivateShop
-{
-	INVENTORY_PAGE_MAX_NUM = INVENTORY_PAGE_COUNT,
-	INVENTORY_PAGE_WIDTH = INVENTORY_WIDTH,
-	INVENTORY_PAGE_HEIGHT = INVENTORY_HEIGHT,
-	INVENTORY_PAGE_ITEM_MAX_NUM = INVENTORY_PAGE_WIDTH * INVENTORY_PAGE_HEIGHT,
-
-	PRIVATE_SHOP_PAGE_MAX_NUM = 2,
-	PRIVATE_SHOP_WIDTH = 8,
-	PRIVATE_SHOP_HEIGHT = 8,
-	PRIVATE_SHOP_PAGE_ITEM_MAX_NUM = PRIVATE_SHOP_WIDTH * PRIVATE_SHOP_HEIGHT,
-	PRIVATE_SHOP_HOST_ITEM_MAX_NUM = (PRIVATE_SHOP_WIDTH * PRIVATE_SHOP_HEIGHT) * PRIVATE_SHOP_PAGE_MAX_NUM,
-	PRIVATE_SHOP_LOCKED_SLOT_MAX_NUM = PRIVATE_SHOP_HOST_ITEM_MAX_NUM / 2,
-	PRIVATE_SHOP_SLOT_UNLOCK_ITEM = 72357,
-	PRIVATE_SHOP_MAX_PREMIUM_TIME = 3600 * 24 * 7,
-	SELECTED_ITEM_MAX_NUM = 10,
-
-	VALID_SALE_DAY_INTERVAL = 30,
-	VALID_MARKET_PRICE_DAY_INTERVAL = 3,
-	MARKET_ITEM_PRICE_UPDATE_SEC_INTERVAL = 3600,
-
-	TITLE_MAX_LEN = 32,
-	TITLE_MIN_LEN = 3,
-};
-
-enum ESex
-{
-	SEX_MALE,
-	SEX_FEMALE
-};
-
-enum EDirection
-{
-	DIR_NORTH,
-	DIR_NORTHEAST,
-	DIR_EAST,
-	DIR_SOUTHEAST,
-	DIR_SOUTH,
-	DIR_SOUTHWEST,
-	DIR_WEST,
-	DIR_NORTHWEST,
-	DIR_MAX_NUM
-};
-
-#define ABILITY_MAX_LEVEL 10 /* 기술 최대 레벨 */
-
-enum EAbilityDifficulty
-{
-	DIFFICULTY_EASY,
-	DIFFICULTY_NORMAL,
-	DIFFICULTY_HARD,
-	DIFFICULTY_VERY_HARD,
-	DIFFICULTY_NUM_TYPES
-};
-
-enum EAbilityCategory
-{
-	CATEGORY_PHYSICAL, /* 신체적 어빌리티 */
-	CATEGORY_MENTAL, /* 정신적 어빌리티 */
-	CATEGORY_ATTRIBUTE, /* 능력 어빌리티 */
-	CATEGORY_NUM_TYPES
-};
-
-enum EJobs
-{
-	JOB_WARRIOR,
-	JOB_ASSASSIN,
-	JOB_SURA,
-	JOB_SHAMAN,
-	JOB_WOLFMAN,
-	JOB_MAX_NUM
-};
-
-enum ESkillGroups
-{
-	SKILL_GROUP_MAX_NUM = 2,
-};
-
-enum ERaceFlags
-{
-	RACE_FLAG_ANIMAL = (1 << 0),
-	RACE_FLAG_UNDEAD = (1 << 1),
-	RACE_FLAG_DEVIL = (1 << 2),
-	RACE_FLAG_HUMAN = (1 << 3),
-	RACE_FLAG_ORC = (1 << 4),
-	RACE_FLAG_MILGYO = (1 << 5),
-	RACE_FLAG_INSECT = (1 << 6),
-	RACE_FLAG_DESERT = (1 << 7),
-	RACE_FLAG_TREE = (1 << 8),
-	RACE_FLAG_DECO = (1 << 9),
-	RACE_FLAG_HIDE = (1 << 10),
-
-	// 20130117
-	//RACE_FLAG_ATT_ELEC = (1 << 11),
-	//RACE_FLAG_ATT_FIRE = (1 << 12),
-	//RACE_FLAG_ATT_ICE = (1 << 13),
-	//RACE_FLAG_ATT_WIND = (1 << 14),
-	//RACE_FLAG_ATT_EARTH = (1 << 15),
-
-	RACE_FLAG_ATT_CZ = (1 << 11),
-	RACE_FLAG_AWEAKEN = (1 << 12),
-	RACE_FLAG_SUNGMAHEE = (1 << 13),
-	RACE_FLAG_OUTPOST = (1 << 14),
-};
-
-enum ELoads
-{
-	LOAD_NONE,
-	LOAD_LIGHT,
-	LOAD_NORMAL,
-	LOAD_HEAVY,
-	LOAD_MASSIVE
-};
-
-//enum
-//{
-//	QUICKSLOT_TYPE_NONE,
-//	QUICKSLOT_TYPE_INVENTORY,
-//	QUICKSLOT_TYPE_BELT_INVENTORY,
-//	QUICKSLOT_TYPE_SKILL,
-//	QUICKSLOT_TYPE_COMMAND,
-//	QUICKSLOT_TYPE_MAX_NUM,
-//};
-//
-
-#ifdef __GROWTH_PET_SYSTEM__
-enum EGrowthPet
-{
-	PET_MAX_LEVEL = 120,
-
-	PET_ATTR_CHANGE_ITEMVNUM = 55033,
-	PET_NAME_MAX_SIZE = 20,
-	PET_NAME_MIN_SIZE = 4,
-	PET_HATCHING_MONEY = 100000,
-	PET_SKILL_COUNT_MAX = 3,
-	PET_GROWTH_SKILL_LEVEL_MAX = 20,
-	PET_SKILL_UPGRADE_PRICE = 2000000,
-	PET_GROWTH_SKILL_OPEN_EVOL_LEVEL = 4,
-	PET_FEED_SLOT_MAX = 9,
-	PET_REVIVE_MATERIAL_SLOT_MAX = 10,
-
-	EGG_TO_UPBRINGING_DELTA = 300,
-	MELEY_PET_EGG_VNUM = 55406,
-
-	EXP_TYPE_MOB = 1,
-	EXP_TYPE_ITEM = 2,
-
-	PET_EVOL_MAX_ITEM_COUNT = 7,
-	PET_LAST_EVOL_MIN_DAY_COUNT = 30,
-
-	PET_MONKEY = 55701,
-	PET_SPIDER = 55702,
-	PET_RAZADOR = 55703,
-	PET_NEMERE = 55704,
-	PET_BLUE_DRAGON = 55705,
-	PET_RED_DRAGON = 55706,
-	PET_AZRAEL = 55707,
-	PET_MINI_EXECUTOR = 55708,
-	PET_BASHIIDO = 55709,
-	PET_NESSIE = 55710,
-	PET_EXEDYAR = 55711,
-	PET_MAX_NUM = 11,
-
-	PET_MAX_BONUS_NUM = 8,
-};
-
-enum EPetState
-{
-	STATE_NONE,
-	STATE_UPBRINGING,
-	STATE_BAG,
-	STATE_SAFEBOX,
-};
-#endif
-
-enum ESlotType
-{
-	SLOT_TYPE_NONE,
-	SLOT_TYPE_INVENTORY,
-	SLOT_TYPE_SKILL,
-	SLOT_TYPE_EMOTION,
-	SLOT_TYPE_SHOP,
-	SLOT_TYPE_EXCHANGE_OWNER,
-	SLOT_TYPE_EXCHANGE_TARGET,
-	SLOT_TYPE_QUICK_SLOT,
-	SLOT_TYPE_SAFEBOX,
-	SLOT_TYPE_GUILDBANK,
-	SLOT_TYPE_ACCE,
-	SLOT_TYPE_PRIVATE_SHOP,
-	SLOT_TYPE_MALL,
-	SLOT_TYPE_DRAGON_SOUL_INVENTORY,
-	SLOT_TYPE_PET_FEED_WINDOW,
-	SLOT_TYPE_EQUIPMENT,
-	SLOT_TYPE_BELT_INVENTORY,
-	SLOT_TYPE_AUTO,
-	SLOT_TYPE_CHANGE_LOOK,
-	SLOT_TYPE_FISH_EVENT,
-	SLOT_TYPE_AURA,
-	SLOT_TYPE_PREMIUM_PRIVATE_SHOP,
-	SLOT_TYPE_GOLDEN_LAND_FRUIT,
-	SLOT_TYPE_MAX,
-};
-
-enum EParts
-{
-	PART_MAIN,
-	PART_WEAPON,
-	PART_HEAD,
-	PART_HAIR,
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	PART_ACCE,
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	PART_AURA,
-#endif
-
-	PART_MAX_NUM,
-	PART_WEAPON_SUB,
-};
-
-#if defined(__LOCALE_CLIENT__)
-enum ELCType
-{
-	LC_TYPE_STRING,
-	LC_TYPE_QUEST,
-	LC_TYPE_ITEM,
-	LC_TYPE_MOB,
-	LC_TYPE_SKILL,
-	LC_TYPE_PETSKILL,
-	LC_TYPE_OX
-};
-#endif
-
-enum EChatType
-{
-	CHAT_TYPE_TALKING, /* 그냥 채팅 */
-	CHAT_TYPE_INFO, /* 정보 (아이템을 집었다, 경험치를 얻었다. 등) */
-	CHAT_TYPE_NOTICE, /* 공지사항 */
-	CHAT_TYPE_PARTY, /* 파티말 */
-	CHAT_TYPE_GUILD, /* 길드말 */
-	CHAT_TYPE_COMMAND, /* 일반 명령 */
-	CHAT_TYPE_SHOUT, /* 외치기 */
-	CHAT_TYPE_WHISPER,
-	CHAT_TYPE_BIG_NOTICE,
-	CHAT_TYPE_MONARCH_NOTICE,
-#if defined(__OX_RENEWAL__)
-	CHAT_TYPE_BIG_CONTROL_NOTICE,
-#endif
-#if defined(__DICE_SYSTEM__)
-	CHAT_TYPE_DICE_INFO,
-#endif
-	CHAT_TYPE_MISSION,
-	CHAT_TYPE_SUB_MISSION,
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-	CHAT_TYPE_EXP_INFO,
-	CHAT_TYPE_ITEM_INFO,
-	CHAT_TYPE_MONEY_INFO,
-#endif
-	CHAT_TYPE_MAX_NUM
-};
-
-enum EWhisperType
-{
-	WHISPER_TYPE_NORMAL = 0,
-	WHISPER_TYPE_NOT_EXIST = 1,
-	WHISPER_TYPE_TARGET_BLOCKED = 2,
-	WHISPER_TYPE_SENDER_BLOCKED = 3,
-	WHISPER_TYPE_ERROR = 4,
-	WHISPER_TYPE_GM = 5,
-	WHISPER_TYPE_SYSTEM = 0xFF
-};
-
-enum ECharacterPosition
-{
-	POSITION_GENERAL,
-	POSITION_BATTLE,
-	POSITION_DYING,
-	POSITION_SITTING_CHAIR,
-	POSITION_SITTING_GROUND,
-	POSITION_INTRO,
-	POSITION_MAX_NUM
-};
-
-enum EGMLevels
-{
-	GM_PLAYER,
-	GM_LOW_WIZARD,
-	GM_WIZARD,
-	GM_HIGH_WIZARD,
-	GM_GOD,
-	GM_IMPLEMENTOR
-};
-
-enum EMobRank
-{
-	MOB_RANK_PAWN,
-	MOB_RANK_S_PAWN,
-	MOB_RANK_KNIGHT,
-	MOB_RANK_S_KNIGHT,
-	MOB_RANK_BOSS,
-	MOB_RANK_KING,
-	MOB_RANK_MAX_NUM
-};
-
-enum ECharType
-{
-	CHAR_TYPE_MONSTER,
-	CHAR_TYPE_NPC,
-	CHAR_TYPE_STONE,
-	CHAR_TYPE_WARP,
-	CHAR_TYPE_DOOR,
-	CHAR_TYPE_BUILDING,
-	CHAR_TYPE_PC,
-	CHAR_TYPE_POLYMORPH_PC,
-	CHAR_TYPE_HORSE,
-	CHAR_TYPE_GOTO,
-	CHAR_TYPE_PET,
-	CHAR_TYPE_PET_PAY,
-	CHAR_TYPE_SHOP,
-	CHAR_TYPE_OBJECT,
-};
-
-enum EBattleType
-{
-	BATTLE_TYPE_MELEE,
-	BATTLE_TYPE_RANGE,
-	BATTLE_TYPE_MAGIC,
-	BATTLE_TYPE_SPECIAL,
-	BATTLE_TYPE_POWER,
-	BATTLE_TYPE_TANKER,
-	BATTLE_TYPE_SUPER_POWER,
-	BATTLE_TYPE_SUPER_TANKER,
-	BATTLE_TYPE_MAX_NUM
-};
-
-enum EApplyTypes
-{
-	APPLY_NONE,							// 0
-	APPLY_MAX_HP,						// 1
-	APPLY_MAX_SP,						// 2
-	APPLY_CON,							// 3
-	APPLY_INT,							// 4
-	APPLY_STR,							// 5
-	APPLY_DEX,							// 6
-	APPLY_ATT_SPEED,					// 7
-	APPLY_MOV_SPEED,					// 8
-	APPLY_CAST_SPEED,					// 9
-	APPLY_HP_REGEN,						// 10
-	APPLY_SP_REGEN,						// 11
-	APPLY_POISON_PCT,					// 12
-	APPLY_STUN_PCT,						// 13
-	APPLY_SLOW_PCT,						// 14
-	APPLY_CRITICAL_PCT,					// 15
-	APPLY_PENETRATE_PCT,				// 16
-	APPLY_ATTBONUS_HUMAN,				// 17
-	APPLY_ATTBONUS_ANIMAL,				// 18
-	APPLY_ATTBONUS_ORC,					// 19
-	APPLY_ATTBONUS_MILGYO,				// 20
-	APPLY_ATTBONUS_UNDEAD,				// 21
-	APPLY_ATTBONUS_DEVIL,				// 22
-	APPLY_STEAL_HP,						// 23
-	APPLY_STEAL_SP,						// 24
-	APPLY_MANA_BURN_PCT,				// 25
-	APPLY_DAMAGE_SP_RECOVER,			// 26
-	APPLY_BLOCK,						// 27
-	APPLY_DODGE,						// 28
-	APPLY_RESIST_SWORD,					// 29
-	APPLY_RESIST_TWOHAND,				// 30
-	APPLY_RESIST_DAGGER,				// 31
-	APPLY_RESIST_BELL,					// 32
-	APPLY_RESIST_FAN,					// 33
-	APPLY_RESIST_BOW,					// 34
-	APPLY_RESIST_FIRE,					// 35
-	APPLY_RESIST_ELEC,					// 36
-	APPLY_RESIST_MAGIC,					// 37
-	APPLY_RESIST_WIND,					// 38
-	APPLY_REFLECT_MELEE,				// 39
-	APPLY_REFLECT_CURSE,				// 40
-	APPLY_POISON_REDUCE,				// 41
-	APPLY_KILL_SP_RECOVER,				// 42
-	APPLY_EXP_DOUBLE_BONUS,				// 43
-	APPLY_GOLD_DOUBLE_BONUS,			// 44
-	APPLY_ITEM_DROP_BONUS,				// 45
-	APPLY_POTION_BONUS,					// 46
-	APPLY_KILL_HP_RECOVER,				// 47
-	APPLY_IMMUNE_STUN,					// 48
-	APPLY_IMMUNE_SLOW,					// 49
-	APPLY_IMMUNE_FALL,					// 50
-	APPLY_SKILL,						// 51
-	APPLY_BOW_DISTANCE,					// 52
-	APPLY_ATT_GRADE_BONUS,				// 53
-	APPLY_DEF_GRADE_BONUS,				// 54
-	APPLY_MAGIC_ATT_GRADE,				// 55
-	APPLY_MAGIC_DEF_GRADE,				// 56
-	APPLY_CURSE_PCT,					// 57
-	APPLY_MAX_STAMINA,					// 58
-	APPLY_ATTBONUS_WARRIOR,				// 59
-	APPLY_ATTBONUS_ASSASSIN,			// 60
-	APPLY_ATTBONUS_SURA,				// 61
-	APPLY_ATTBONUS_SHAMAN,				// 62
-	APPLY_ATTBONUS_MONSTER,				// 63
-	APPLY_MALL_ATTBONUS,				// 64 공격력 +x%
-	APPLY_MALL_DEFBONUS,				// 65 방어력 +x%
-	APPLY_MALL_EXPBONUS,				// 66 경험치 +x%
-	APPLY_MALL_ITEMBONUS,				// 67 아이템 드롭율 x/10배
-	APPLY_MALL_GOLDBONUS,				// 68 돈 드롭율 x/10배
-	APPLY_MAX_HP_PCT,					// 69 최대 생명력 +x%
-	APPLY_MAX_SP_PCT,					// 70 최대 정신력 +x%
-	APPLY_SKILL_DAMAGE_BONUS,			// 71 스킬 데미지 * (100+x)%
-	APPLY_NORMAL_HIT_DAMAGE_BONUS,		// 72 평타 데미지 * (100+x)%
-	APPLY_SKILL_DEFEND_BONUS,			// 73 스킬 데미지 방어 * (100-x)%
-	APPLY_NORMAL_HIT_DEFEND_BONUS,		// 74 평타 데미지 방어 * (100-x)%
-	APPLY_PC_BANG_EXP_BONUS,			// 75 PC방 아이템 EXP 보너스
-	APPLY_PC_BANG_DROP_BONUS,			// 76 PC방 아이템 드롭율 보너스
-
-	APPLY_EXTRACT_HP_PCT,				// 77 사용시 HP 소모
-
-	APPLY_RESIST_WARRIOR,				// 78 무사에게 저항
-	APPLY_RESIST_ASSASSIN,				// 79 자객에게 저항
-	APPLY_RESIST_SURA,					// 80 수라에게 저항
-	APPLY_RESIST_SHAMAN,				// 81 무당에게 저항
-
-	APPLY_ENERGY,						// 82 기력
-	APPLY_DEF_GRADE,					// 83 방어력. DEF_GRADE_BONUS는 클라에서 두배로 보여지는 의도된 버그(...)가 있다.
-	APPLY_COSTUME_ATTR_BONUS,			// 84 코스튬 아이템에 붙은 속성치 보너스
-	APPLY_MAGIC_ATTBONUS_PER,			// 85 마법 공격력 +x%
-	APPLY_MELEE_MAGIC_ATTBONUS_PER,		// 86 마법 + 밀리 공격력 +x%
-
-	APPLY_RESIST_ICE,					// 87 냉기 저항
-	APPLY_RESIST_EARTH,					// 88 대지 저항
-	APPLY_RESIST_DARK,					// 89 어둠 저항
-
-	APPLY_ANTI_CRITICAL_PCT,			// 90 크리티컬 저항
-	APPLY_ANTI_PENETRATE_PCT,			// 91 관통타격 저항
-
-	APPLY_BLEEDING_REDUCE,			// 92
-	APPLY_BLEEDING_PCT,				// 93
-	APPLY_ATTBONUS_WOLFMAN,			// 94
-	APPLY_RESIST_WOLFMAN,			// 95
-	APPLY_RESIST_CLAW,				// 96
-
-	APPLY_ACCEDRAIN_RATE,
-	APPLY_RESIST_MAGIC_REDUCTION,
-
-	APPLY_ENCHANT_ELECT,
-	APPLY_ENCHANT_FIRE,
-	APPLY_ENCHANT_ICE,
-	APPLY_ENCHANT_WIND,
-	APPLY_ENCHANT_EARTH,
-	APPLY_ENCHANT_DARK,
-
-	APPLY_ATTBONUS_CZ,
-	APPLY_ATTBONUS_INSECT,
-	APPLY_ATTBONUS_DESERT,
-	APPLY_ATTBONUS_SWORD,
-	APPLY_ATTBONUS_TWOHAND,
-	APPLY_ATTBONUS_DAGGER,
-	APPLY_ATTBONUS_BELL,
-	APPLY_ATTBONUS_FAN,
-	APPLY_ATTBONUS_BOW,
-	APPLY_ATTBONUS_CLAW,
-
-	APPLY_RESIST_HUMAN,
-	APPLY_RESIST_MOUNT_FALL,
-	APPLY_RESIST_FIST,
-
-	APPLY_MOUNT,
-
-	APPLY_SKILL_DAMAGE_SAMYEON,
-	APPLY_SKILL_DAMAGE_TANHWAN,
-	APPLY_SKILL_DAMAGE_PALBANG,
-	APPLY_SKILL_DAMAGE_GIGONGCHAM,
-	APPLY_SKILL_DAMAGE_GYOKSAN,
-	APPLY_SKILL_DAMAGE_GEOMPUNG,
-	APPLY_SKILL_DAMAGE_AMSEOP,
-	APPLY_SKILL_DAMAGE_GUNGSIN,
-	APPLY_SKILL_DAMAGE_CHARYUN,
-	APPLY_SKILL_DAMAGE_SANGONG,
-	APPLY_SKILL_DAMAGE_YEONSA,
-	APPLY_SKILL_DAMAGE_KWANKYEOK,
-	APPLY_SKILL_DAMAGE_GIGUNG,
-	APPLY_SKILL_DAMAGE_HWAJO,
-	APPLY_SKILL_DAMAGE_SWAERYUNG,
-	APPLY_SKILL_DAMAGE_YONGKWON,
-	APPLY_SKILL_DAMAGE_PABEOB,
-	APPLY_SKILL_DAMAGE_MARYUNG,
-	APPLY_SKILL_DAMAGE_HWAYEOMPOK,
-	APPLY_SKILL_DAMAGE_MAHWAN,
-	APPLY_SKILL_DAMAGE_BIPABU,
-	APPLY_SKILL_DAMAGE_YONGBI,
-	APPLY_SKILL_DAMAGE_PAERYONG,
-	APPLY_SKILL_DAMAGE_NOEJEON,
-	APPLY_SKILL_DAMAGE_BYEURAK,
-	APPLY_SKILL_DAMAGE_CHAIN,
-	APPLY_SKILL_DAMAGE_CHAYEOL,
-	APPLY_SKILL_DAMAGE_SALPOONG,
-	APPLY_SKILL_DAMAGE_GONGDAB,
-	APPLY_SKILL_DAMAGE_PASWAE,
-
-	APPLY_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE,
-	APPLY_SKILL_DEFEND_BONUS_BOSS_OR_MORE,
-	APPLY_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE,
-	APPLY_SKILL_DAMAGE_BONUS_BOSS_OR_MORE,
-
-	APPLY_HIT_BUFF_ENCHANT_FIRE,
-	APPLY_HIT_BUFF_ENCHANT_ICE,
-	APPLY_HIT_BUFF_ENCHANT_ELEC,
-	APPLY_HIT_BUFF_ENCHANT_WIND,
-	APPLY_HIT_BUFF_ENCHANT_DARK,
-	APPLY_HIT_BUFF_ENCHANT_EARTH,
-	APPLY_HIT_BUFF_RESIST_FIRE,
-	APPLY_HIT_BUFF_RESIST_ICE,
-	APPLY_HIT_BUFF_RESIST_ELEC,
-	APPLY_HIT_BUFF_RESIST_WIND,
-	APPLY_HIT_BUFF_RESIST_DARK,
-	APPLY_HIT_BUFF_RESIST_EARTH,
-
-	APPLY_USE_SKILL_CHEONGRANG_MOV_SPEED,
-	APPLY_USE_SKILL_CHEONGRANG_CASTING_SPEED,
-	APPLY_USE_SKILL_CHAYEOL_CRITICAL_PCT,
-	APPLY_USE_SKILL_SANGONG_ATT_GRADE_BONUS,
-	APPLY_USE_SKILL_GIGUNG_ATT_GRADE_BONUS,
-	APPLY_USE_SKILL_JEOKRANG_DEF_BONUS,
-	APPLY_USE_SKILL_GWIGEOM_DEF_BONUS,
-	APPLY_USE_SKILL_TERROR_ATT_GRADE_BONUS,
-	APPLY_USE_SKILL_MUYEONG_ATT_GRADE_BONUS,
-	APPLY_USE_SKILL_MANASHILED_CASTING_SPEED,
-	APPLY_USE_SKILL_HOSIN_DEF_BONUS,
-	APPLY_USE_SKILL_GICHEON_ATT_GRADE_BONUS,
-	APPLY_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS,
-	APPLY_USE_SKILL_JEUNGRYEOK_DEF_BONUS,
-	APPLY_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS,
-	APPLY_USE_SKILL_CHUNKEON_CASTING_SPEED,
-	APPLY_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS,
-
-	APPLY_SKILL_DURATION_INCREASE_EUNHYUNG,
-	APPLY_SKILL_DURATION_INCREASE_GYEONGGONG,
-	APPLY_SKILL_DURATION_INCREASE_GEOMKYUNG,
-	APPLY_SKILL_DURATION_INCREASE_JEOKRANG,
-
-	APPLY_USE_SKILL_PALBANG_HP_ABSORB,
-	APPLY_USE_SKILL_AMSEOP_HP_ABSORB,
-	APPLY_USE_SKILL_YEONSA_HP_ABSORB,
-	APPLY_USE_SKILL_YONGBI_HP_ABSORB,
-	APPLY_USE_SKILL_CHAIN_HP_ABSORB,
-	APPLY_USE_SKILL_PASWAE_SP_ABSORB,
-	APPLY_USE_SKILL_GIGONGCHAM_STUN,
-	APPLY_USE_SKILL_CHARYUN_STUN,
-	APPLY_USE_SKILL_PABEOB_STUN,
-	APPLY_USE_SKILL_MAHWAN_STUN,
-	APPLY_USE_SKILL_GONGDAB_STUN,
-	APPLY_USE_SKILL_SAMYEON_STUN,
-	APPLY_USE_SKILL_GYOKSAN_KNOCKBACK,
-	APPLY_USE_SKILL_SEOMJEON_KNOCKBACK,
-	APPLY_USE_SKILL_SWAERYUNG_KNOCKBACK,
-	APPLY_USE_SKILL_HWAYEOMPOK_KNOCKBACK,
-	APPLY_USE_SKILL_GONGDAB_KNOCKBACK,
-	APPLY_USE_SKILL_KWANKYEOK_KNOCKBACK,
-	APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER,
-	APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER,
-	APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER,
-	APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER,
-	APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER,
-	APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER,
-	APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER,
-	APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER,
-	APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER,
-	APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER,
-
-	APPLY_ATTBONUS_STONE,
-
-	APPLY_DAMAGE_HP_RECOVERY,
-	APPLY_DAMAGE_SP_RECOVERY,
-
-	APPLY_ALIGNMENT_DAMAGE_BONUS,
-
-	APPLY_NORMAL_DAMAGE_GUARD,
-	APPLY_MORE_THEN_HP90_DAMAGE_REDUCE,
-
-	APPLY_USE_SKILL_TUSOK_HP_ABSORB,
-	APPLY_USE_SKILL_PAERYONG_HP_ABSORB,
-	APPLY_USE_SKILL_BYEURAK_HP_ABSORB,
-
-	APPLY_FIRST_ATTRIBUTE_BONUS,
-	APPLY_SECOND_ATTRIBUTE_BONUS,
-	APPLY_THIRD_ATTRIBUTE_BONUS,
-	APPLY_FOURTH_ATTRIBUTE_BONUS,
-	APPLY_FIFTH_ATTRIBUTE_BONUS,
-
-	APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER,
-	APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER,
-	APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER,
-	APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER,
-	APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER,
-	APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER,
-	APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER,
-	APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER,
-	APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER,
-	APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER,
-	APPLY_USE_SKILL_CHAYEOL_HP_ABSORB,
-
-	APPLY_SUNGMA_STR,
-	APPLY_SUNGMA_HP,
-	APPLY_SUNGMA_MOVE,
-	APPLY_SUNGMA_IMMUNE,
-
-	APPLY_HIT_PCT,
-	APPLY_RANDOM,
-
-	APPLY_ATTBONUS_PER_HUMAN,
-	APPLY_ATTBONUS_PER_ANIMAL,
-	APPLY_ATTBONUS_PER_ORC,
-	APPLY_ATTBONUS_PER_MILGYO,
-	APPLY_ATTBONUS_PER_UNDEAD,
-	APPLY_ATTBONUS_PER_DEVIL,
-
-	APPLY_ENCHANT_PER_ELECT,
-	APPLY_ENCHANT_PER_FIRE,
-	APPLY_ENCHANT_PER_ICE,
-	APPLY_ENCHANT_PER_WIND,
-	APPLY_ENCHANT_PER_EARTH,
-	APPLY_ENCHANT_PER_DARK,
-
-	APPLY_ATTBONUS_PER_CZ,
-	APPLY_ATTBONUS_PER_INSECT,
-	APPLY_ATTBONUS_PER_DESERT,
-	APPLY_ATTBONUS_PER_STONE,
-	APPLY_ATTBONUS_PER_MONSTER,
-
-	APPLY_RESIST_PER_HUMAN,
-	APPLY_RESIST_PER_ICE,
-	APPLY_RESIST_PER_DARK,
-	APPLY_RESIST_PER_EARTH,
-	APPLY_RESIST_PER_FIRE,
-	APPLY_RESIST_PER_ELEC,
-	APPLY_RESIST_PER_MAGIC,
-	APPLY_RESIST_PER_WIND,
-
-	APPLY_HIT_BUFF_SUNGMA_STR,
-	APPLY_HIT_BUFF_SUNGMA_MOVE,
-	APPLY_HIT_BUFF_SUNGMA_HP,
-	APPLY_HIT_BUFF_SUNGMA_IMMUNE,
-
-	APPLY_MOUNT_MELEE_MAGIC_ATTBONUS_PER,
-	APPLY_DISMOUNT_MOVE_SPEED_BONUS_PER,
-
-	APPLY_HIT_AUTO_HP_RECOVERY,
-	APPLY_HIT_AUTO_SP_RECOVERY,
-
-	APPLY_USE_SKILL_COOLTIME_DECREASE_ALL,
-
-	APPLY_HIT_STONE_ATTBONUS_STONE,
-	APPLY_HIT_STONE_DEF_GRADE_BONUS,
-
-	APPLY_KILL_BOSS_ITEM_BONUS,
-	APPLY_MOB_HIT_MOB_AGGRESSIVE,
-	APPLY_NO_DEATH_AND_HP_RECOVERY30,
-
-	APPLY_AUTO_PICKUP,
-	APPLY_MOUNT_NO_KNOCKBACK,
-
-	APPLY_SUNGMA_PER_STR,
-	APPLY_SUNGMA_PER_HP,
-	APPLY_SUNGMA_PER_MOVE,
-	APPLY_SUNGMA_PER_IMMUNE,
-
-	APPLY_IMMUNE_POISON100,
-	APPLY_IMMUNE_BLEEDING100,
-
-	APPLY_MONSTER_DEFEND_BONUS,
-
-	MAX_APPLY_NUM,
-};
-
-enum EOnClickEvents
-{
-	ON_CLICK_NONE,
-	ON_CLICK_TALK,
-	ON_CLICK_SHOP,
-	ON_CLICK_MAX_NUM
-};
-
-enum EOnIdleEvents
-{
-	ON_IDLE_NONE,
-	ON_IDLE_GENERAL,
-	ON_IDLE_MAX_NUM
-};
-
-enum EWindows
-{
-	RESERVED_WINDOW,
-	INVENTORY,
-	EQUIPMENT,
-	SAFEBOX,
-	MALL,
-	DRAGON_SOUL_INVENTORY,
-	BELT_INVENTORY,
-	GUILDBANK, // __GUILDRENEWAL_SYSTEM__
-	MAIL, // __MAILBOX__
-	NPC_STORAGE, // __ATTR_6TH_7TH__
-#if defined(__PREMIUM_PRIVATE_SHOP__)
-	PREMIUM_PRIVATE_SHOP,
-#endif
-	ACCEREFINE, // __ACCE_COSTUME_SYSTEM__
-	GROUND, // NOTE : 2013년 2월5일 현재까지 unused.. 왜 있는거지???
-#if defined(__GROWTH_PET_SYSTEM__)
-	PET_FEED,
-#endif
-	CHANGELOOK, // __CHANGE_LOOK_SYSTEM__
-	AURA_REFINE, // __AURA_COSTUME_SYSTEM__
-	CUBE_WINDOW, // __CUBE_RENEWAL__
-
-	WINDOW_TYPE_MAX,
-};
-
-enum ETradeWnd
-{
-	WND_EXCHANGE = (1 << 0),
-	WND_MYSHOP = (1 << 1),
-	WND_SHOPOWNER = (1 << 2),
-	WND_SAFEBOX = (1 << 3),
-	WND_REFINE = (1 << 4),
-	WND_CUBE = (1 << 5),
-#if defined(__MOVE_COSTUME_ATTR__)
-	WND_ITEM_COMB = (1 << 6),
-#endif
-#if defined(__CHANGED_ATTR__)
-	WND_SELECT_ATTR = (1 << 7),
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	WND_ACCE = (1 << 8),
-#endif
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	WND_CHANGELOOK = (1 << 9),
-#endif
-
-#if defined(__MAILBOX__)
-	WND_MAILBOX = (1 << 11),
-#endif
-#if defined(__ATTR_6TH_7TH__)
-	WND_ATTR67ADD = (1 << 12),
-#endif
-#if defined(__MOVE_COSTUME_ATTR__)
-	WND_LUCKY_BOX = (1 << 13),
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	WND_AURA = (1 << 14),
-#endif
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	WND_MINIGAME_ROULETTE = (1 << 15),
-#endif
-	WND_ALL = (1 << 31), // MAX 31
-};
-
-enum EMobSizes
-{
-	MOBSIZE_RESERVED,
-	MOBSIZE_SMALL,
-	MOBSIZE_MEDIUM,
-	MOBSIZE_BIG
-};
-
-enum EAIFlags
-{
-	AIFLAG_AGGRESSIVE = (1 << 0),
-	AIFLAG_NOMOVE = (1 << 1),
-	AIFLAG_COWARD = (1 << 2),
-	AIFLAG_NOATTACKSHINSU = (1 << 3),
-	AIFLAG_NOATTACKCHUNJO = (1 << 4),
-	AIFLAG_NOATTACKJINNO = (1 << 5),
-	AIFLAG_ATTACKMOB = (1 << 6),
-	AIFLAG_BERSERK = (1 << 7),
-	AIFLAG_STONESKIN = (1 << 8),
-	AIFLAG_GODSPEED = (1 << 9),
-	AIFLAG_DEATHBLOW = (1 << 10),
-	AIFLAG_REVIVE = (1 << 11),
-	AIFLAG_HEALER = (1 << 12),
-	AIFLAG_COUNT = (1 << 13),
-	AIFLAG_NORECOVERY = (1 << 14),
-	AIFLAG_REFLECT = (1 << 15),
-	AIFLAG_FALL = (1 << 16),
-	AIFLAG_VIT = (1 << 17),
-	AIFLAG_RATTSPEED = (1 << 18),
-	AIFLAG_RCASTSPEED = (1 << 19),
-	AIFLAG_RHP_REGEN = (1 << 20),
-	AIFLAG_TIMEVIT = (1 << 21),
-};
-
-enum EMobStatType
-{
-	MOB_STATTYPE_POWER,
-	MOB_STATTYPE_TANKER,
-	MOB_STATTYPE_SUPER_POWER,
-	MOB_STATTYPE_SUPER_TANKER,
-	MOB_STATTYPE_RANGE,
-	MOB_STATTYPE_MAGIC,
-	MOB_STATTYPE_MAX_NUM
-};
-
-enum EImmuneFlags
-{
-	IMMUNE_STUN = (1 << 0),
-	IMMUNE_SLOW = (1 << 1),
-	IMMUNE_FALL = (1 << 2),
-	IMMUNE_CURSE = (1 << 3),
-	IMMUNE_POISON = (1 << 4),
-	IMMUNE_TERROR = (1 << 5),
-	IMMUNE_REFLECT = (1 << 6),
-};
-
-enum EMobEnchants
-{
-	MOB_ENCHANT_CURSE,
-	MOB_ENCHANT_SLOW,
-	MOB_ENCHANT_POISON,
-	MOB_ENCHANT_STUN,
-	MOB_ENCHANT_CRITICAL,
-	MOB_ENCHANT_PENETRATE,
-	MOB_ENCHANTS_MAX_NUM
-};
-
-enum EMobResists
-{
-	MOB_RESIST_FIST,
-
-	MOB_RESIST_SWORD,
-	MOB_RESIST_TWOHAND,
-	MOB_RESIST_DAGGER,
-	MOB_RESIST_BELL,
-	MOB_RESIST_FAN,
-	MOB_RESIST_BOW,
-	MOB_RESIST_CLAW,
-
-	MOB_RESIST_FIRE,
-	MOB_RESIST_ELECT,
-	MOB_RESIST_MAGIC,
-	MOB_RESIST_WIND,
-
-	MOB_RESIST_POISON,
-	MOB_RESIST_BLEEDING,
-
-	MOB_RESISTS_MAX_NUM
-};
-
-//#if defined(__ELEMENT_SYSTEM__)
-enum EMobElements
-{
-	MOB_ELEMENT_ELECT,
-	MOB_ELEMENT_FIRE,
-	MOB_ELEMENT_ICE,
-	MOB_ELEMENT_WIND,
-	MOB_ELEMENT_EARTH,
-	MOB_ELEMENT_DARK,
-	MOB_ELEMENT_MAX_NUM
-};
-//#endif
-
-enum
-{
-	SKILL_ATTR_TYPE_NORMAL = 1,
-	SKILL_ATTR_TYPE_MELEE,
-	SKILL_ATTR_TYPE_RANGE,
-	SKILL_ATTR_TYPE_MAGIC
-	/*
-	SKILL_ATTR_TYPE_FIRE,
-	SKILL_ATTR_TYPE_ICE,
-	SKILL_ATTR_TYPE_ELEC,
-	SKILL_ATTR_TYPE_DARK,
-	*/
-};
-
-enum
-{
-	SKILL_NORMAL,
-	SKILL_MASTER,
-	SKILL_GRAND_MASTER,
-	SKILL_PERFECT_MASTER,
-};
-
-enum EGuildWarType
-{
-	GUILD_WAR_TYPE_FIELD,
-	GUILD_WAR_TYPE_BATTLE,
-	GUILD_WAR_TYPE_FLAG,
-	GUILD_WAR_TYPE_MAX_NUM
-};
-
-enum EGuildWarState
-{
-	GUILD_WAR_NONE,
-	GUILD_WAR_SEND_DECLARE,
-	GUILD_WAR_REFUSE,
-	GUILD_WAR_RECV_DECLARE,
-	GUILD_WAR_WAIT_START,
-	GUILD_WAR_CANCEL,
-	GUILD_WAR_ON_WAR,
-	GUILD_WAR_END,
-	GUILD_WAR_OVER,
-	GUILD_WAR_RESERVE,
-
-	GUILD_WAR_DURATION = 30 * 60, // 1시간
-	GUILD_WAR_WIN_POINT = 1000,
-	GUILD_WAR_LADDER_HALF_PENALTY_TIME = 12 * 60 * 60,
-};
-
-enum EAttributeSet
-{
-	ATTRIBUTE_SET_WEAPON,
-	ATTRIBUTE_SET_BODY,
-	ATTRIBUTE_SET_WRIST,
-	ATTRIBUTE_SET_FOOTS,
-	ATTRIBUTE_SET_NECK,
-	ATTRIBUTE_SET_HEAD,
-	ATTRIBUTE_SET_SHIELD,
-	ATTRIBUTE_SET_EAR,
-#if defined(__PENDANT_SYSTEM__)
-	ATTRIBUTE_SET_PENDANT,
-#endif
-#if defined(__GLOVE_SYSTEM__)
-	ATTRIBUTE_SET_GLOVE,
-#endif
-#if defined(__COSTUME_SYSTEM__)
-	ATTRIBUTE_SET_COSTUME_BODY,
-	ATTRIBUTE_SET_COSTUME_HAIR,
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-	ATTRIBUTE_SET_COSTUME_WEAPON,
-#endif
-#endif
-	ATTRIBUTE_SET_MAX_NUM
-};
-
-enum EPrivType
-{
-	PRIV_NONE,
-	PRIV_ITEM_DROP,
-	PRIV_GOLD_DROP,
-	PRIV_GOLD10_DROP,
-	PRIV_EXP_PCT,
-	MAX_PRIV_NUM,
-};
-
-enum EMoneyLogType
-{
-	MONEY_LOG_RESERVED,
-	MONEY_LOG_MONSTER,
-	MONEY_LOG_SHOP,
-	MONEY_LOG_REFINE,
-	MONEY_LOG_QUEST,
-	MONEY_LOG_GUILD,
-	MONEY_LOG_MISC,
-	MONEY_LOG_MONSTER_KILL,
-	MONEY_LOG_DROP,
-	MONEY_LOG_TYPE_MAX_NUM,
-};
-
-enum EPremiumTypes
-{
-	PREMIUM_EXP, // 경험치가 1.2배
-	PREMIUM_ITEM, // 아이템 드롭율이 2배
-	PREMIUM_SAFEBOX, // 창고가 1칸에서 3칸
-	PREMIUM_AUTOLOOT, // 돈 자동 줍기
-	PREMIUM_FISH_MIND, // 고급 물고기 낚일 확률 상승
-	PREMIUM_MARRIAGE_FAST, // 금실 증가 양을 빠르게합니다.
-	PREMIUM_GOLD, // 돈 드롭율이 1.5배
-	PREMIUM_AUTO_USE,
-#if defined(__CONQUEROR_LEVEL__)
-	PREMIUM_SUNGMA,
-#endif
-	PREMIUM_MAX_NUM = 9
-};
-
-enum SPECIAL_EFFECT
-{
-	SE_NONE,
-
-	SE_HPUP_RED,
-	SE_SPUP_BLUE,
-	SE_SPEEDUP_GREEN,
-	SE_DXUP_PURPLE,
-	SE_CRITICAL,
-	SE_PENETRATE,
-	SE_BLOCK,
-	SE_DODGE,
-	SE_CHINA_FIREWORK,
-	SE_SPIN_TOP,
-	SE_SUCCESS,
-	SE_FAIL,
-	SE_FR_SUCCESS,
-	SE_LEVELUP_ON_14_FOR_GERMANY, //레벨업 14일때 ( 독일전용 )
-	SE_LEVELUP_UNDER_15_FOR_GERMANY, //레벨업 15일때 ( 독일전용 )
-	SE_PERCENT_DAMAGE1,
-	SE_PERCENT_DAMAGE2,
-	SE_PERCENT_DAMAGE3,
-
-	SE_AUTO_HPUP,
-	SE_AUTO_SPUP,
-
-	SE_EQUIP_RAMADAN_RING, // 초승달의 반지를 착용하는 순간에 발동하는 이펙트
-	SE_EQUIP_HALLOWEEN_CANDY, // 할로윈 사탕을 착용(-_-;)한 순간에 발동하는 이펙트
-	SE_EQUIP_HAPPINESS_RING, // 크리스마스 행복의 반지를 착용하는 순간에 발동하는 이펙트
-	SE_EQUIP_LOVE_PENDANT, // 발렌타인 사랑의 팬던트(71145) 착용할 때 이펙트 (발동이펙트임, 지속이펙트 아님)
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	SE_ACCE_SUCESS_ABSORB,
-	SE_ACCE_EQUIP,
-	SE_ACCE_BACK,
-#endif
-
-	SE_EQUIP_EASTER_CANDY,
-
-	SE_THUNDER_AREA,
-	SE_THUNDER,
-	SE_HEAL,
-
-	SE_CAPE_OF_COURAGE,
-	SE_EQUIP_CHOCOLATE_PENDANT,
-#if defined(__PVP_BALANCE_IMPROVING__)
-	SE_FEATHER_WALK,
-#endif
-	SE_PEPSI_EVENT,
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	SE_DRAGONLAIR_STONE_UNBEATABLE_1,
-	SE_DRAGONLAIR_STONE_UNBEATABLE_2,
-	SE_DRAGONLAIR_STONE_UNBEATABLE_3,
-#endif
-
-	SE_BATTLE_POTION, // Battle Field
-	SE_REFLECT, // AI_FLAG_REFLECT
-
-	SE_SKILL_DAMAGE_ZONE,
-	SE_SKILL_SAFE_ZONE,
-	SE_METEOR,
-	SE_BEAD_RAIN,
-	SE_ARROW_RAIN,
-	SE_FALL_ROCK,
-	SE_HORSE_DROP,
-	SE_EGG_DROP,
-	SE_DEAPO_BOOM,
-
-#if defined(__FLOWER_EVENT__)
-	SE_FLOWER_EVENT,
-#endif
-#if defined(__GEM_SYSTEM__)
-	SE_GEM_PENDANT,
-#endif
-#if defined(__DEFENSE_WAVE__)
-	SE_DEFENSE_WAVE_LASER,
-#endif
-	SE_PET_ATTR_CHANGE_NEW_TYPE,
-	SE_PET_PAY_SUMMON1,
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	SE_SPECIAL_ROULETTE,
-#endif
-	SE_MISTS_ISLAND_0,
-	SE_MISTS_ISLAND_1,
-	SE_MISTS_ISLAND_2,
-	SE_MISTS_ISLAND_3,
-	SE_PASSIVE_ATTR_SKILL,
-	SE_SUICIDE_BOMB_SMALL,
-	SE_SUICIDE_BOMB_LARGE,
-	SE_GROUND_THORN,
-	SE_GROUND_SNAKE,
-	SE_WHITE_DRAGON_BERSERK,
-	SE_WHITE_DRAGON_COOLING,
-	SE_USE_METINSTONE_RAIN_SPAWN_TICKET,
-	SE_FAKE_METINSTONE_SPLASH_DAMAGE,
-	SE_MOUNT_UPGRADE_SKILL,
-	SE_SOUTH_REAPER_SKILL_2,
-	SE_YEOMWANG_SKILL_2,
-	SE_BUFF_ITEM_5,
-	SE_BUFF_ITEM_13,
-	SE_BUFF_ITEM_14,
-	SE_BUFF_SYMBOL1,
-	SE_BUFF_ITEM_8_ELEMENT_1,
-	SE_BUFF_ITEM_8_ELEMENT_2,
-	SE_BUFF_FLOWER_OF_GALE,
-	SE_BUFF_FLOWER_OF_DESTRUCTION,
-	SE_SUNGMAHEE_GATE_FLOWER_BLOW_RANGE,
-	SE_SUNGMAHEE_GATE_INVINCIBLE_GATE,
-	SE_SUNGMAHEE_GATE_NORMAL_GATE,
-	SE_MOUNT_UPGRADE_GYEONGGONG,
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-	SE_USE_SNOWFLAKE_STICK,
-#endif
-	SE_SPORTS_MATCH_BUFF_EMBLEM,
-	SE_POINT_AREA_ELECT_ATTACK,
-#ifdef ENABLE_QUEEN_NETHIS
-	SE_EFFECT_SNAKE_REGEN,
-#endif
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	SE_EFFECT_BP_NORMAL_MISSION_COMPLETED,
-	SE_EFFECT_BP_PREMIUM_MISSION_COMPLETED,
-	SE_EFFECT_BP_EVENT_MISSION_COMPLETED,
-	SE_EFFECT_BP_NORMAL_BATTLEPASS_COMPLETED,
-	SE_EFFECT_BP_PREMIUM_BATTLEPASS_COMPLETED,
-	SE_EFFECT_BP_EVENT_BATTLEPASS_COMPLETED,
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-	SE_GYEONGGONG_BOOM,
-#endif
-};
-
-#include "item_length.h"
-
-// inventory의 position을 나타내는 구조체
-// int와의 암시적 형변환이 있는 이유는,SE_THUNDER
-// 인벤 관련된 모든 함수가 window_type은 받지 않고, cell 하나만 받았기 때문에,(기존에는 인벤이 하나 뿐이어서 inventory type이란게 필요없었기 때문에,)
-// 인벤 관련 모든 함수 호출부분을 수정하는 것이 난감하기 떄문이다.
-
-enum EDragonSoulRefineWindowSize
-{
-	DRAGON_SOUL_REFINE_GRID_MAX = 15,
-};
-
-enum EMisc2
-{
-	INVENTORY_SLOT_START = 0,
-	INVENTORY_SLOT_END = INVENTORY_MAX_NUM,
-	
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	DRAGON_SOUL_EQUIP_SLOT_START = WEAR_MAX_NUM,
-	DRAGON_SOUL_EQUIP_SLOT_END = DRAGON_SOUL_EQUIP_SLOT_START + (DS_SLOT_MAX * DRAGON_SOUL_DECK_MAX_NUM),
-#endif
-
-	BELT_INVENTORY_SLOT_START = 0,
-	BELT_INVENTORY_SLOT_END = BELT_INVENTORY_SLOT_COUNT,
-	BELT_INVENTORY_MAX_NUM = BELT_INVENTORY_SLOT_END,
-
-	EQUIPMENT_SLOT_START = 0,
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	EQUIPMENT_SLOT_END = DRAGON_SOUL_EQUIP_SLOT_END,
-#else
-	EQUIPMENT_SLOT_END = WEAR_MAX_NUM,
-#endif
-	EQUIPMENT_MAX_NUM = EQUIPMENT_SLOT_END,
-
-	INVENTORY_AND_EQUIP_SLOT_MAX = INVENTORY_MAX_NUM + EQUIPMENT_MAX_NUM + BELT_INVENTORY_SLOT_COUNT,
-};
-
-#pragma pack(push, 1)
-
-typedef struct SItemPos
-{
-	BYTE window_type;
-	WORD cell;
-	SItemPos()
-	{
-		window_type = INVENTORY;
-		cell = WORD_MAX;
-	}
-
-	SItemPos(BYTE _window_type, WORD _cell)
-	{
-		window_type = _window_type;
-		cell = _cell;
-	}
-
-	bool IsValidItemPosition() const
-	{
-		switch (window_type)
-		{
-			case INVENTORY:
-				return cell < INVENTORY_MAX_NUM;
-
-			case EQUIPMENT:
-				return cell < EQUIPMENT_MAX_NUM;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			case DRAGON_SOUL_INVENTORY:
-				return cell < DRAGON_SOUL_INVENTORY_MAX_NUM;
-#endif
-
-			case BELT_INVENTORY:
-				return cell < BELT_INVENTORY_SLOT_COUNT;
-
-			// 동적으로 크기가 정해지는 window는 valid 체크를 할 수가 없다.
-			case SAFEBOX:
-			case MALL:
-				return false;
-
-			default:
-				return false;
-		}
-
-		return false;
-	}
-
-	bool IsSameItemPosition(const SItemPos& DestCell) const
-	{
-		return (window_type == DestCell.window_type) && (cell == DestCell.cell);
-	}
-
-	bool IsInventoryPosition() const
-	{
-		return (window_type == INVENTORY && cell < INVENTORY_MAX_NUM);
-	}
-
-	bool IsDefaultInventoryPosition() const
-	{
-		return IsInventoryPosition();
-	}
-
-	bool IsEquipPosition() const
-	{
-		return (IsEquipmentPosition()
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			|| IsDragonSoulEquipPosition()
-#endif
-			);
-	}
-
-	bool IsEquipmentPosition() const
-	{
-		return (window_type == EQUIPMENT && cell < EQUIPMENT_MAX_NUM);
-	}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	bool IsDragonSoulEquipPosition() const
-	{
-		return (EQUIPMENT == window_type && (cell >= DRAGON_SOUL_EQUIP_SLOT_START && cell < DRAGON_SOUL_EQUIP_SLOT_END));
-	}
-
-	bool IsDragonSoulInventoryPosition() const
-	{
-		return (window_type == DRAGON_SOUL_INVENTORY && cell < DRAGON_SOUL_INVENTORY_MAX_NUM);
-	}
-#endif
-
-	bool IsBeltInventoryPosition() const
-	{
-		return (window_type == BELT_INVENTORY && cell < BELT_INVENTORY_SLOT_COUNT);
-	}
-
-	bool operator==(const struct SItemPos& rhs) const
-	{
-		return (window_type == rhs.window_type) && (cell == rhs.cell);
-	}
-
-	bool operator!=(const struct SItemPos& rhs) const
-	{
-		return (window_type != rhs.window_type) || (cell != rhs.cell);
-	}
-
-	bool operator<(const struct SItemPos& rhs) const
-	{
-		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));
-	}
-} TItemPos;
-
-const TItemPos NPOS(RESERVED_WINDOW, WORD_MAX);
-
-typedef enum
-{
-	SHOP_COIN_TYPE_GOLD, // DEFAULT VALUE
-	SHOP_COIN_TYPE_SECONDARY_COIN,
-#if defined(__SHOPEX_RENEWAL__)
-	SHOP_COIN_TYPE_ITEM,
-	SHOP_COIN_MAX_TYPE,
-#endif
-} EShopCoinType;
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-enum EAcceMisc
-{
-	ACCE_MAX_DRAINRATE = 25,
-};
-
-enum EAcceSlot
-{
-	ACCE_SLOT_LEFT,
-	ACCE_SLOT_RIGHT,
-	ACCE_SLOT_RESULT,
-	ACCE_SLOT_MAX
-};
-
-enum EAcceSlotType
-{
-	ACCE_SLOT_TYPE_COMBINE,
-	ACCE_SLOT_TYPE_ABSORB,
-	ACCE_SLOT_TYPE_MAX
-};
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-enum EAuraMisc
-{
-	AURA_MAX_LEVEL = 250,
-};
-
-enum EAuraWindowType
-{
-	AURA_WINDOW_TYPE_ABSORB,
-	AURA_WINDOW_TYPE_GROWTH,
-	AURA_WINDOW_TYPE_EVOLVE,
-	AURA_WINDOW_TYPE_MAX,
-};
-
-enum EAuraSlot
-{
-	AURA_SLOT_MAIN,
-	AURA_SLOT_SUB,
-	AURA_SLOT_RESULT,
-	AURA_SLOT_MAX
-};
-
-enum EAuraGradeType
-{
-	AURA_GRADE_NONE,
-	AURA_GRADE_ORDINARY,
-	AURA_GRADE_SIMPLE,
-	AURA_GRADE_NOBLE,
-	AURA_GRADE_SPARKLING,
-	AURA_GRADE_MAGNIFICENT,
-	AURA_GRADE_RADIANT,
-	AURA_GRADE_MAX_NUM,
-};
-
-enum EAuraRefineTokenType
-{
-	AURA_REFINE_INFO_STEP,
-	AURA_REFINE_INFO_LEVEL_MIN,
-	AURA_REFINE_INFO_LEVEL_MAX,
-	AURA_REFINE_INFO_NEED_EXP,
-	AURA_REFINE_INFO_MATERIAL_VNUM,
-	AURA_REFINE_INFO_MATERIAL_COUNT,
-	AURA_REFINE_INFO_NEED_GOLD,
-	AURA_REFINE_INFO_EVOLVE_PCT,
-	AURA_REFINE_INFO_MAX
-};
-
-enum EAuraRefineInfoType
-{
-	AURA_REFINE_INFO_SLOT_CURRENT,
-	AURA_REFINE_INFO_SLOT_NEXT,
-	AURA_REFINE_INFO_SLOT_EVOLVED,
-	AURA_REFINE_INFO_SLOT_MAX
-};
-
-typedef struct SAuraRefineInfo
-{
-	BYTE bLevel;
-	BYTE bExpPercent;
-} TAuraRefineInfo;
-
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-enum ESpecialActionMisc
-{
-	SPECIAL_ACTION_START_INDEX = 101,
-	SPECIAL_ACTION_DURATION = 43200,
-	SPECIAL_ACTION_SLOT_COUNT = 12,
-};
-#endif
-
-enum EEmotion
-{
-	EMOTION_NONE,
-	EMOTION_CLAP,
-	EMOTION_CONGRATULATION,
-	EMOTION_FORGIVE,
-	EMOTION_ANGRY,
-	EMOTION_ATTRACTIVE,
-	EMOTION_SAD,
-	EMOTION_SHY,
-	EMOTION_CHEERUP,
-	EMOTION_BANTER,
-	EMOTION_JOY,
-	EMOTION_CHEERS_1,
-	EMOTION_CHEERS_2,
-	EMOTION_DANCE_1,
-	EMOTION_DANCE_2,
-	EMOTION_DANCE_3,
-	EMOTION_DANCE_4,
-	EMOTION_DANCE_5,
-	EMOTION_DANCE_6,
-
-	EMOTION_KISS = 51,
-	EMOTION_FRENCH_KISS = 52,
-	EMOTION_SLAP = 53,
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	EMOTION_PUSH_UP = SPECIAL_ACTION_START_INDEX,
-	EMOTION_DANCE_7,
-	EMOTION_EXERCISE,
-	EMOTION_DOZE,
-	EMOTION_SELFIE,
-	EMOTION_CHARGING,
-	EMOTION_NOSAY,
-	EMOTION_WEATHER_1,
-	EMOTION_WEATHER_2,
-	EMOTION_WEATHER_3,
-	EMOTION_HUNGRY,
-	EMOTION_SIREN,
-	EMOTION_LETTER,
-	EMOTION_CALL,
-	EMOTION_CELEBRATION,
-	EMOTION_ALCOHOL,
-	EMOTION_BUSY,
-	EMOTION_WHIRL,
-#endif
-	EMOTION_NUM,
-};
-
-enum EEmotionFlag
-{
-	EMOTION_FLAG_SELF = (1 << 0),
-	EMOTION_FLAG_TARGET = (1 << 1),
-	EMOTION_FLAG_MAN = (1 << 2),
-	EMOTION_FLAG_WOMAN = (1 << 3),
-	EMOTION_FLAG_OTHER_SEX = (1 << 3),
-};
-
-#if defined(__SET_ITEM__)
-enum ESetItemType
-{
-	SET_ITEM_COSTUME_BODY,
-	SET_ITEM_COSTUME_HAIR,
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	SET_ITEM_COSTUME_MOUNT,
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	SET_ITEM_COSTUME_ACCE,
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-	SET_ITEM_COSTUME_WEAPON,
-#endif
-	SET_ITEM_UNIQUE,
-	SET_ITEM_PET,
-
-	SET_ITEM_MAX
-};
-
-enum ESetItemValue
-{
-	SET_ITEM_SET_VALUE_NONE,
-	SET_ITEM_SET_VALUE_1,
-	SET_ITEM_SET_VALUE_2,
-	SET_ITEM_SET_VALUE_3,
-	SET_ITEM_SET_VALUE_4,
-	SET_ITEM_SET_VALUE_5,
-	SET_ITEM_SET_VALUE_MAX
-};
-#endif
-
-#if defined(__DELETE_FAILURE_TYPE__)
-enum EDeleteCharacterFailureType
-{
-	DELETE_FAILURE_NORMAL,
-#if defined(__SOUL_BIND_SYSTEM__)
-	DELETE_FAILURE_HAVE_SEALED_ITEM,
-#endif
-	DELETE_FAILURE_PRIVATE_CODE_ERROR,
-	DELETE_FAILURE_LIMITE_LEVEL_HIGHER,
-	DELETE_FAILURE_LIMITE_LEVEL_LOWER,
-	DELETE_FAILURE_REMAIN_TIME,
-	DELETE_FAILURE_GUILD_MEMBER,
-	DELETE_FAILURE_MARRIAGE,
-	DELETE_FAILURE_LAST_CHAR_SAFEBOX,
-	DELETE_FAILURE_ATTR67,
-	DELETE_FAILURE_PREMIUM_PRIVATE_SHOP,
-};
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-enum ERefineElementMisc
-{
-	REFINE_ELEMENT_MIN_REFINE_LEVEL = 7,
-
-	REFINE_ELEMENT_UPGRADE_YANG = 3000000,
-	REFINE_ELEMENT_DOWNGRADE_YANG = 10000000,
-	REFINE_ELEMENT_CHANGE_YANG = 10000000,
-
-	REFINE_ELEMENT_RANDOM_VALUE_MIN = 1,
-	REFINE_ELEMENT_RANDOM_VALUE_MAX = 8,
-
-	REFINE_ELEMENT_RANDOM_BONUS_VALUE_MIN = 2,
-	REFINE_ELEMENT_RANDOM_BONUS_VALUE_MAX = 12,
-};
-
-enum ERefineElementType
-{
-	REFINE_ELEMENT_UPGRADE,
-	REFINE_ELEMENT_DOWNGRADE,
-	REFINE_ELEMENT_CHANGE,
-};
-#endif
-
-enum EPartyLeaderShipRoleValue
-{
-	LEADERSHIP_ATTACKER_BASE_VALUE = 10,
-	LEADERSHIP_ATTACKER_ADJUSTMENT_VALUE = 50,
-	LEADERSHIP_TANKER_BASE_VALUE = 50,
-	LEADERSHIP_TANKER_ADJUSTMENT_VALUE = 1120,
-	LEADERSHIP_BUFFER_BASE_VALUE = 5,
-	LEADERSHIP_BUFFER_ADJUSTMENT_VALUE = 8,
-	LEADERSHIP_SKILL_MASTER_BASE_VALUE = 1,
-	LEADERSHIP_SKILL_MASTER_ADJUSTMENT_VALUE = 2,
-	LEADERSHIP_BERSERKER_BASE_VALUE = 1,
-	LEADERSHIP_BERSERKER_ADJUSTMENT_VALUE = 3,
-	LEADERSHIP_DEFENDER_BASE_VALUE = 1,
-	LEADERSHIP_DEFENDER_ADJUSTMENT_VALUE = 3,
-};
-
-#if defined(__PARTY_INSIGHT__)
-enum EPartyInSightValue
-{
-	INSIGHT_ATTACKER_BASE_VALUE = 2,
-	INSIGHT_ATTACKER_ADJUSTMENT_VALUE = 9,
-	INSIGHT_TANKER_BASE_VALUE = 10,
-	INSIGHT_TANKER_ADJUSTMENT_VALUE = 520,
-	INSIGHT_BUFFER_BASE_VALUE = 1,
-	INSIGHT_BUFFER_ADJUSTMENT_VALUE = 4,
-	INSIGHT_SKILL_MASTER_BASE_VALUE = 1,
-	INSIGHT_SKILL_MASTER_ADJUSTMENT_VALUE = 5,
-	INSIGHT_BERSERKER_BASE_VALUE = 1,
-	INSIGHT_BERSERKER_ADJUSTMENT_VALUE = 1,
-	INSIGHT_DEFENDER_BASE_VALUE = 1,
-	INSIGHT_DEFENDER_ADJUSTMENT_VALUE = 2,
-};
-#endif
-
-enum EMapIndex
-{
-	MAP_A1 = 1,
-	MAP_A3 = 3,
-	MAP_GUILD_01 = 4,
-	MAP_MONKEY_DUNGEON_11 = 5,
-	MAP_GUILD_VILLAGE_01 = 6,
-	MAP_B1 = 21,
-	MAP_B3 = 23,
-	MAP_GUILD_02 = 24,
-	MAP_MONKEY_DUNGEON_12 = 25,
-	MAP_GUILD_VILLAGE_02 = 26,
-	MAP_C1 = 41,
-	MAP_C3 = 43,
-	MAP_GUILD_03 = 44,
-	MAP_MONKEY_DUNGEON_13 = 45,
-	MAP_GUILD_VILLAGE_03 = 46,
-	MAP_N_SNOWM_01 = 61,
-	MAP_N_FLAME_01 = 62,
-	MAP_N_DESERT_01 = 63,
-	MAP_N_THREEWAY = 64,
-	MAP_MILGYO = 65,
-	MAP_DEVILTOWER1 = 66,
-	MAP_TRENT = 67,
-	MAP_TRENT02 = 68,
-	MAP_WL_01 = 69,
-	MAP_NUSLUCK01 = 70,
-	MAP_SPIDERDUNGEON_02 = 71,
-	MAP_SKIPIA_DUNGEON_01 = 72,
-	MAP_SKIPIA_DUNGEON_02 = 73,
-	MAP_WEDDING_01 = 81,
-	MAP_E1_01 = 91,
-	MAP_E1_02 = 92,
-	MAP_E1_03 = 93,
-	MAP_T1 = 103,
-	MAP_SPIDERDUNGEON = 104,
-	MAP_T2 = 105,
-	MAP_MONKEY_DUNGEON = 107,
-	MAP_MONKEY_DUNGEON2 = 108,
-	MAP_MONKEY_DUNGEON3 = 109,
-	MAP_T3 = 110,
-	MAP_T4 = 111,
-	MAP_DUEL = 112,
-	MAP_OXEVENT = 113,
-	MAP_SUNGZI = 114,
-	MAP_SUNGZI_FLAME_HILL_01 = 118,
-	MAP_SUNGZI_FLAME_HILL_02 = 119,
-	MAP_SUNGZI_FLAME_HILL_03 = 120,
-	MAP_SUNGZI_SNOW = 121,
-	MAP_SUNGZI_SNOW_PASS01 = 122,
-	MAP_SUNGZI_SNOW_PASS02 = 123,
-	MAP_SUNGZI_SNOW_PASS03 = 124,
-	MAP_SUNGZI_DESERT_01 = 125,
-	MAP_SUNGZI_DESERT_HILL_01 = 126,
-	MAP_SUNGZI_DESERT_HILL_02 = 127,
-	MAP_SUNGZI_DESERT_HILL_03 = 128,
-	MAP_GUILD_WAR1 = 130,
-	MAP_GUILD_WAR2 = 131,
-	MAP_GUILD_WAR3 = 132,
-	MAP_GUILD_WAR4 = 133,
-	MAP_EMPIREWAR01 = 181,
-	MAP_EMPIREWAR02 = 182,
-	MAP_EMPIREWAR03 = 183,
-	MAP_GM_GUILD_BUILD = 200,
-	MAP_PVP_ARENA = 201,
-	MAP_SKIPIA_DUNGEON_BOSS = 208,
-	MAP_DEVILSCATACOMB = 216,
-	MAP_SPIDERDUNGEON_03 = 217,
-	MAP_CAPEDRAGONHEAD = 301,
-	MAP_DAWNMISTWOOD = 302,
-	MAP_BAYBLACKSAND = 303,
-	MAP_MT_THUNDER = 304,
-	MAP_N_FLAME_DUNGEON_01 = 351,
-	MAP_N_SNOW_DUNGEON_01 = 352,
-	MAP_DAWNMIST_DUNGEON_01 = 353,
-	MAP_MT_TH_DUNGEON_01 = 354,
-	MAP_12ZI_STAGE = 355,
-	MAP_N_FLAME_DRAGON = 356,
-	MAP_BATTLEFIED = 357,
-	MAP_DEFENSEWAVE = 358,
-	MAP_DEFENSEWAVE_PORT = 359,
-	MAP_MISTS_OF_ISLAND = 360,
-	MAP_MINIBOSS_01 = 361,
-	MAP_MINIBOSS_02 = 362,
-	MAP_LABYRINTH = 363,
-	MAP_BOSS_CRACK_SKIPIA = 364,
-	MAP_BOSS_CRACK_FLAME = 365,
-	MAP_BOSS_CRACK_SNOW = 366,
-	MAP_BOSS_CRACK_DAWNMIST = 367,
-	MAP_BOSS_AWAKEN_SKIPIA = 368,
-	MAP_BOSS_AWAKEN_FLAME = 369,
-	MAP_BOSS_AWAKEN_SNOW = 370,
-	MAP_BOSS_AWAKEN_DAWNMIST = 371,
-	MAP_GUILD_PVE = 372,
-	MAP_EASTPLAIN_01 = 373,
-	MAP_EMPIRECASTLE = 374,
-	MAP_BATTLEROYALE = 375,
-	MAP_EASTPLAIN_02 = 376,
-	MAP_EASTPLAIN_03 = 377,
-	MAP_ELEMENTAL_01 = 378,
-	MAP_ELEMENTAL_02 = 379,
-	MAP_ELEMENTAL_03 = 380,
-	MAP_ELEMENTAL_04 = 381,
-	MAP_MAZE_DUNGEON1 = 382,
-	MAP_MAZE_DUNGEON2 = 383,
-	MAP_MAZE_DUNGEON3 = 384,
-	MAP_SNAKEVALLEY = 385,
-	MAP_SMHDUNGEON_01 = 386,
-	MAP_SMHDUNGEON_02 = 387,
-	MAP_ICECRYSTALCAVE = 388,
-	MAP_WHITDRAGONVALLEY = 389,
-	MAP_SNAKE_TEMPLE_01 = 390,
-	MAP_SNAKE_TEMPLE_02 = 391,
-	MAP_PRIVATESHOP = 392,
-	MAP_WHITEDRAGONCAVE_01 = 393,
-	MAP_WHITEDRAGONCAVE_02 = 394,
-	MAP_WHITEDRAGONCAVE_BOSS = 395,
-	MAP_ANGLAR_DUNGEON_01 = 396,
-	MAP_SECRETDUNGEON_01 = 399,
-	MAP_OTHERWORLD_01 = 400,
-	MAP_OTHERWORLD_02 = 401,
-	MAP_OTHERWORLD_03 = 402,
-	MAP_OTHERWORLD_04 = 403,
-};
-
-#if defined(__SOUL_BIND_SYSTEM__)
-enum ESealDate
-{
-	E_SEAL_DATE_DEFAULT_TIMESTAMP = 0, // Empty Seal Data
-	U_SEAL_DATE_DEFAULT_TIMESTAMP = -1, // Unlimited Seal Data
-	SEAL_DATE_MAX = 72, // 72 Days
-};
-#endif
-
-#if defined(__LEFT_SEAT__)
-enum ELeftSeat
-{
-	LEFT_SEAT_PULSE = 15,
-};
-
-enum ELeftSeatTime
-{
-	LEFT_SEAT_TIME_10_MIN,
-	LEFT_SEAT_TIME_30_MIN,
-	LEFT_SEAT_TIME_90_MIN,
-	LEFT_SEAT_TIME_MAX,
-};
-
-enum ELeftSeatLogoutTime
-{
-	LEFT_SEAT_LOGOUT_TIME_30_MIN,
-	LEFT_SEAT_LOGOUT_TIME_60_MIN,
-	LEFT_SEAT_LOGOUT_TIME_120_MIN,
-	LEFT_SEAT_LOGOUT_TIME_180_MIN,
-	LEFT_SEAT_LOGOUT_TIME_OFF,
-	LEFT_SEAT_LOGOUT_TIME_MAX,
-};
-#endif
-
-enum ESetCMD
-{
-	SET_CMD_GOLD,
-	SET_CMD_RACE,
-	SET_CMD_SEX,
-	SET_CMD_EXP,
-	SET_CMD_MAX_HP,
-	SET_CMD_MAX_SP,
-	SET_CMD_SKILL,
-	SET_CMD_ALIGN,
-#if defined(__CHEQUE_SYSTEM__)
-	SET_CMD_CHEQUE,
-#endif
-#if defined(__GEM_SYSTEM__)
-	SET_CMD_GEM,
-#endif
-#if defined(__EXPRESSING_EMOTIONS__)
-	SET_CMD_ACTION,
-#endif
-	SET_CMD_MAX_NUN
-};
-
-enum EDeadDialog
-{
-	DEAD_DIALOG_NONE,
-	DEAD_DIALOG_NORMAL,
-	DEAD_DIALOG_GIVE_UP,
-};
-
-#if defined(__FLOWER_EVENT__)
-enum EFlowerEventShootType
-{
-	SHOOT_ENVELOPE,
-	SHOOT_CHRYSANTHEMUM,
-	SHOOT_MAY_BELL,
-	SHOOT_DAFFODIL,
-	SHOOT_LILY,
-	SHOOT_SUNFLOWER,
-	SHOOT_TYPE_MAX,
-};
-
-enum EFlowerEventMisc
-{
-	FLOWER_EVENT_SHOOT_ENVELOPE_NEED_COUNT = 1,
-	FLOWER_EVENT_SHOOT_NEED_COUNT = 10,
-	FLOWER_EVENT_NEED_INVENTORY_SPACE = 1,
-	FLOWER_EVENT_EXCHANGE_COOLTIME_SEC = 1,
-	MAX_FLOWER_EVENT_ITEM_COUNT = 99999,
-};
-
-enum EFlowerEventChatType
-{
-	FLOWER_EVENT_CHAT_TYPE_NOT_ENOUGH_SHOOT_COUNT,
-	FLOWER_EVENT_CHAT_TYPE_NOT_ENOUGH_EVENTORY_SPACE,
-	FLOWER_EVENT_CHAT_TYPE_NOT_ENOUGH_SHOOT_ENVELOPE,
-	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_ENVELOPE,
-	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_CHRYSANTHEMUM,
-	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_MAY_BELL,
-	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_DAFFODIL,
-	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_LILY,
-	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_SUNFLOWER,
-	FLOWER_EVENT_CHAT_TYPE_ITEM_FULL_AND_NOT_USE,
-	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_CHRYSANTHEMUM_COUNT,
-	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_MAY_BELL_COUNT,
-	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_DAFFODIL_COUNT,
-	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_LILY_COUNT,
-	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_SUNFLOWER_COUNT,
-	FLOWER_EVENT_CHAT_TYPE_ENVELOPE_MAX,
-	FLOWER_EVENT_CHAT_TYPE_MAX,
-};
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-enum EExtBattlePassType
-{
-	BATTLEPASS_NORMAL,
-	BATTLEPASS_PREMIUM,
-	BATTLEPASS_EVENT,
-
-	BATTLEPASS_TYPE_MAX,
-};
-
-enum EExtBattleMissionPassType
-{
-	MISSION_TYPE_NONE,
-
-	KILL_MONSTER,
-	KILL_PLAYER,
-
-	DAMAGE_MONSTER,
-	DAMAGE_PLAYER,
-
-	BP_ITEM_USE,
-	BP_ITEM_SELL,
-	BP_ITEM_CRAFT,
-	BP_ITEM_REFINE,
-	BP_ITEM_DESTROY,
-	BP_ITEM_COLLECT,
-
-	FISH_FISHING,
-	FISH_GRILL,
-	FISH_CATCH,
-	
-	EXP_COLLECT,
-	YANG_COLLECT,
-	
-	GUILD_PLAY_GUILDWAR,
-	GUILD_SPENT_EXP,
-
-	GAYA_CRAFT_GAYA,
-	GAYA_BUY_ITEM_GAYA_COST,
-	
-	PET_ENCHANT,
-
-	COMPLETE_DUNGEON,
-	COMPLETE_MINIGAME,
-
-	MISSION_TYPE_MAX,
-};
-#endif
-
-#pragma pack(pop)
-#endif // __INC_COMMON_LENGTH_H__
+#ifndef __INC_COMMON_LENGTH_H__
+#define __INC_COMMON_LENGTH_H__
+
+#include "service.h"
+
+#define WORD_MAX 0xffff
+
+#define POINT_TYPE WORD
+#define POINT_VALUE long
+#define POINT_MIN LONG_MIN
+#define POINT_MAX LONG_MAX
+
+enum EMisc
+{
+	MAX_HOST_LENGTH = 15,
+	IP_ADDRESS_LENGTH = 15,
+	LOGIN_MAX_LEN = 30,
+	PASSWD_MAX_LEN = 16,
+#if defined(__PLAYER_PER_ACCOUNT5__)
+	PLAYER_PER_ACCOUNT = 5,
+#else
+	PLAYER_PER_ACCOUNT = 4,
+#endif
+	ACCOUNT_STATUS_MAX_LEN = 8,
+	CHARACTER_NAME_MAX_LEN = 24,
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	COUNTRY_NAME_MAX_LEN = 2,
+#endif
+	SHOP_SIGN_MAX_LEN = 32,
+
+	ABILITY_MAX_NUM = 50,
+	EMPIRE_MAX_NUM = 4,
+	BANWORD_MAX_LEN = 24,
+	SOCIAL_ID_MAX_LEN = 18,
+
+#if defined(__RANKING_SYSTEM__)
+	PARTY_MAX_MEMBER = 8,
+#endif
+
+	GUILD_NAME_MAX_LEN = 12,
+
+#if defined(__MYSHOP_EXPANSION__)
+	SHOP_HOST_ITEM_MAX = 80, /* The maximum number of items of the pc host. */
+#endif
+	SHOP_HOST_ITEM_MAX_NUM = 40, /* 호트 獵   */
+
+	SHOP_GUEST_ITEM_MAX_NUM = 18, /* 督트 獵   */
+#if defined(__MYSHOP_EXPANSION__)
+	SHOP_PRICELIST_MAX_NUM = SHOP_HOST_ITEM_MAX,
+#else
+	SHOP_PRICELIST_MAX_NUM = 40, ///< 貫  트   獵 
+#endif
+
+#if defined(__MYSHOP_DECO__)
+	MYSHOP_MAX_TABS = 2,
+#endif
+
+	CHAT_MAX_LEN = 512,
+
+	QUICKSLOT_MAX_NUM = 36,
+
+	JOURNAL_MAX_NUM = 2,
+
+	QUERY_MAX_LEN = 16384,
+
+	FILE_MAX_LEN = 128,
+
+	PLAYER_EXP_TABLE_MAX = 120,
+	PLAYER_MAX_LEVEL_CONST = 120,
+
+#if defined(__CONQUEROR_LEVEL__)
+	PLAYER_CONQUEROR_EXP_TABLE_MAX = 30,
+	PLAYER_MAX_CONQUEROR_LEVEL_CONST = 30,
+#endif
+
+	GUILD_MAX_LEVEL = 20,
+	MOB_MAX_LEVEL = 100,
+
+	ATTRIBUTE_MAX_VALUE = 20,
+	CHARACTER_PATH_MAX_NUM = 64,
+	SKILL_MAX_NUM = 255,
+	SKILLBOOK_DELAY_MIN = 64800,
+	SKILLBOOK_DELAY_MAX = 108000,
+	SKILL_MAX_LEVEL = 40,
+
+	APPLY_NAME_MAX_LEN = 32,
+	EVENT_FLAG_NAME_MAX_LEN = 32,
+	CHARACTER_FOLDER_MAX_LEN = 64,
+
+	MOB_SKILL_MAX_NUM = 5,
+
+	POINT_MAX_NUM = 1000,
+
+	MAX_AMOUNT_OF_MALL_BONUS = 20,
+
+	//WEAR_MAX_NUM = 32,
+
+	GOLD_MAX = 2000000000, // 1999999999
+
+#if defined(__CHEQUE_SYSTEM__)
+	CHEQUE_MAX = 3000, // 999
+#endif
+
+#if defined(__GEM_SYSTEM__)
+	GEM_MAX = 1000000, // 999999
+#endif
+
+#if defined(_DEBUG) && defined(_WIN32)
+	MAX_MAP_ALLOW = 128,
+#else
+	MAX_MAP_ALLOW = 64,
+#endif
+
+	SHOP_TAB_NAME_MAX = 32,
+#if defined(__SHOPEX_TAB4__)
+	SHOP_TAB_COUNT_MAX = 4,
+#else
+	SHOP_TAB_COUNT_MAX = 3,
+#endif
+
+#if defined(__GEM_SHOP__)
+	GEM_SHOP_SLOT_COUNT = 9,
+#	if defined(__CONQUEROR_LEVEL__)
+	GEM_SHOP_SPECIAL_SLOT_COUNT = 3,
+#	endif
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	ROULETTE_ITEM_MAX = 20,
+#endif
+
+#ifdef __OFFLINE_SHOP__
+	OFFLINE_SHOP_ITEM_WIDTH = 10,
+	OFFLINE_SHOP_ITEM_HEIGHT = 8,
+	OFFLINE_SHOP_PAGES = 4,
+	OFFLINE_SHOP_ITEM_COUNT = OFFLINE_SHOP_ITEM_WIDTH * OFFLINE_SHOP_ITEM_HEIGHT * OFFLINE_SHOP_PAGES,
+	OFFLINE_SHOP_NAME_CHANGE_TIMELIMIT = 60 * 60,
+#endif
+
+	WINDOW_OPENER_MAX_DISTANCE = 1000,
+};
+
+enum EShopSearchMode
+{
+	MODE_NONE,
+	MODE_LOOKING,
+	MODE_TRADING,
+};
+
+enum EPrivateShopState
+{
+	STATE_UNAVAILABLE,
+	STATE_CLOSED,
+	STATE_OPEN,
+	STATE_MODIFY
+};
+
+enum EPrivateShopSearchState
+{
+	STATE_NON_EXISTENT,
+	STATE_REMOVED,
+	STATE_AVAILABLE,
+	STATE_RESTRICTED,
+};
+
+enum EInventoryPositions
+{
+	INVENTORY_WIDTH = 5,
+	INVENTORY_HEIGHT = 9,
+	INVENTORY_PAGE_SIZE = INVENTORY_WIDTH * INVENTORY_HEIGHT, // 45
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	INVENTORY_PAGE_COUNT = 4, // 180
+#else
+	INVENTORY_PAGE_COUNT = 2, // 90
+#endif
+	INVENTORY_MAX_NUM = INVENTORY_PAGE_SIZE * INVENTORY_PAGE_COUNT,
+
+	DRAGON_SOUL_BOX_SIZE = 32,
+	DRAGON_SOUL_BOX_COLUMN_NUM = 8,
+	DRAGON_SOUL_BOX_ROW_NUM = DRAGON_SOUL_BOX_SIZE / DRAGON_SOUL_BOX_COLUMN_NUM,
+	DRAGON_SOUL_REFINE_GRID_SIZE = 15,
+
+	BELT_INVENTORY_SLOT_WIDTH = 4,
+	BELT_INVENTORY_SLOT_HEIGHT = 4,
+	BELT_INVENTORY_SLOT_COUNT = BELT_INVENTORY_SLOT_WIDTH * BELT_INVENTORY_SLOT_HEIGHT,
+};
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+enum EExtendInven
+{
+	EX_INVENTORY_PAGE_COUNT = 2,
+	EX_INVENTORY_PAGE_START = 3,
+	EX_INVENTORY_STAGE_MAX = INVENTORY_HEIGHT * EX_INVENTORY_PAGE_COUNT,
+};
+
+enum EExtendInvenMsg
+{
+	EX_INVEN_FAIL_FALL_SHORT,
+	EX_INVEN_SUCCESS,
+	EX_INVEN_FAIL_FOURTH_PAGE_STAGE_MAX,
+};
+#endif
+
+#if defined(__REFINE_MSG_ADD__)
+enum ERefineFailType
+{
+	REFINE_FAIL_GRADE_DOWN,
+	REFINE_FAIL_DEL_ITEM,
+	REFINE_FAIL_KEEP_GRADE,
+	REFINE_FAIL_MAX,
+};
+#endif
+
+#if defined(__SKILLBOOK_COMB_SYSTEM__)
+enum ESkillBookCombination
+{
+	SKILLBOOK_COMB_SLOT_MAX = 10,
+	SKILLBOOK_COMB_COST = 1000000,
+};
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+enum EAttr67Add
+{
+	NPC_STORAGE_SLOT_MAX = 1,
+	ATTR67_MATERIAL_MAX_COUNT = 10,
+	ATTR67_SUPPORT_MAX_COUNT = 5,
+	ATTR67_SUCCESS_PER_MATERIAL = 2,
+	ATTR67_ADD_WAIT_TIME = 60 * 60 * 24,
+};
+#endif
+
+enum EDragonSoulDeckType
+{
+	DRAGON_SOUL_DECK_0,
+	DRAGON_SOUL_DECK_1,
+	DRAGON_SOUL_DECK_MAX_NUM = 2,
+
+	DRAGON_SOUL_DECK_RESERVED_MAX_NUM = 3, // NOTE: 傷!   , 3 鈞   . DS DECK 첩  訃  큼 RESERVED 瞞 !
+};
+
+enum EPrivateShop
+{
+	INVENTORY_PAGE_MAX_NUM = INVENTORY_PAGE_COUNT,
+	INVENTORY_PAGE_WIDTH = INVENTORY_WIDTH,
+	INVENTORY_PAGE_HEIGHT = INVENTORY_HEIGHT,
+	INVENTORY_PAGE_ITEM_MAX_NUM = INVENTORY_PAGE_WIDTH * INVENTORY_PAGE_HEIGHT,
+
+	PRIVATE_SHOP_PAGE_MAX_NUM = 2,
+	PRIVATE_SHOP_WIDTH = 8,
+	PRIVATE_SHOP_HEIGHT = 8,
+	PRIVATE_SHOP_PAGE_ITEM_MAX_NUM = PRIVATE_SHOP_WIDTH * PRIVATE_SHOP_HEIGHT,
+	PRIVATE_SHOP_HOST_ITEM_MAX_NUM = (PRIVATE_SHOP_WIDTH * PRIVATE_SHOP_HEIGHT) * PRIVATE_SHOP_PAGE_MAX_NUM,
+	PRIVATE_SHOP_LOCKED_SLOT_MAX_NUM = PRIVATE_SHOP_HOST_ITEM_MAX_NUM / 2,
+	PRIVATE_SHOP_SLOT_UNLOCK_ITEM = 72357,
+	PRIVATE_SHOP_MAX_PREMIUM_TIME = 3600 * 24 * 7,
+	SELECTED_ITEM_MAX_NUM = 10,
+
+	VALID_SALE_DAY_INTERVAL = 30,
+	VALID_MARKET_PRICE_DAY_INTERVAL = 3,
+	MARKET_ITEM_PRICE_UPDATE_SEC_INTERVAL = 3600,
+
+	TITLE_MAX_LEN = 32,
+	TITLE_MIN_LEN = 3,
+};
+
+enum ESex
+{
+	SEX_MALE,
+	SEX_FEMALE
+};
+
+enum EDirection
+{
+	DIR_NORTH,
+	DIR_NORTHEAST,
+	DIR_EAST,
+	DIR_SOUTHEAST,
+	DIR_SOUTH,
+	DIR_SOUTHWEST,
+	DIR_WEST,
+	DIR_NORTHWEST,
+	DIR_MAX_NUM
+};
+
+#define ABILITY_MAX_LEVEL 10 /*  獵  */
+
+enum EAbilityDifficulty
+{
+	DIFFICULTY_EASY,
+	DIFFICULTY_NORMAL,
+	DIFFICULTY_HARD,
+	DIFFICULTY_VERY_HARD,
+	DIFFICULTY_NUM_TYPES
+};
+
+enum EAbilityCategory
+{
+	CATEGORY_PHYSICAL, /* 체 티 */
+	CATEGORY_MENTAL, /*  티 */
+	CATEGORY_ATTRIBUTE, /*  티 */
+	CATEGORY_NUM_TYPES
+};
+
+enum EJobs
+{
+	JOB_WARRIOR,
+	JOB_ASSASSIN,
+	JOB_SURA,
+	JOB_SHAMAN,
+	JOB_WOLFMAN,
+	JOB_MAX_NUM
+};
+
+enum ESkillGroups
+{
+	SKILL_GROUP_MAX_NUM = 2,
+};
+
+enum ERaceFlags
+{
+	RACE_FLAG_ANIMAL = (1 << 0),
+	RACE_FLAG_UNDEAD = (1 << 1),
+	RACE_FLAG_DEVIL = (1 << 2),
+	RACE_FLAG_HUMAN = (1 << 3),
+	RACE_FLAG_ORC = (1 << 4),
+	RACE_FLAG_MILGYO = (1 << 5),
+	RACE_FLAG_INSECT = (1 << 6),
+	RACE_FLAG_DESERT = (1 << 7),
+	RACE_FLAG_TREE = (1 << 8),
+	RACE_FLAG_DECO = (1 << 9),
+	RACE_FLAG_HIDE = (1 << 10),
+
+	// 20130117
+	//RACE_FLAG_ATT_ELEC = (1 << 11),
+	//RACE_FLAG_ATT_FIRE = (1 << 12),
+	//RACE_FLAG_ATT_ICE = (1 << 13),
+	//RACE_FLAG_ATT_WIND = (1 << 14),
+	//RACE_FLAG_ATT_EARTH = (1 << 15),
+
+	RACE_FLAG_ATT_CZ = (1 << 11),
+	RACE_FLAG_AWEAKEN = (1 << 12),
+	RACE_FLAG_SUNGMAHEE = (1 << 13),
+	RACE_FLAG_OUTPOST = (1 << 14),
+};
+
+enum ELoads
+{
+	LOAD_NONE,
+	LOAD_LIGHT,
+	LOAD_NORMAL,
+	LOAD_HEAVY,
+	LOAD_MASSIVE
+};
+
+//enum
+//{
+//	QUICKSLOT_TYPE_NONE,
+//	QUICKSLOT_TYPE_INVENTORY,
+//	QUICKSLOT_TYPE_BELT_INVENTORY,
+//	QUICKSLOT_TYPE_SKILL,
+//	QUICKSLOT_TYPE_COMMAND,
+//	QUICKSLOT_TYPE_MAX_NUM,
+//};
+//
+
+#ifdef __GROWTH_PET_SYSTEM__
+	SE_GYEONGGONG_BOOM,
+#endif
+
+enum ESlotType
+{
+	SLOT_TYPE_NONE,
+	SLOT_TYPE_INVENTORY,
+	SLOT_TYPE_SKILL,
+	SLOT_TYPE_EMOTION,
+	SLOT_TYPE_SHOP,
+	SLOT_TYPE_EXCHANGE_OWNER,
+	SLOT_TYPE_EXCHANGE_TARGET,
+	SLOT_TYPE_QUICK_SLOT,
+	SLOT_TYPE_SAFEBOX,
+	SLOT_TYPE_GUILDBANK,
+	SLOT_TYPE_ACCE,
+	SLOT_TYPE_PRIVATE_SHOP,
+	SLOT_TYPE_MALL,
+	SLOT_TYPE_DRAGON_SOUL_INVENTORY,
+	SLOT_TYPE_PET_FEED_WINDOW,
+	SLOT_TYPE_EQUIPMENT,
+	SLOT_TYPE_BELT_INVENTORY,
+	SLOT_TYPE_AUTO,
+	SLOT_TYPE_CHANGE_LOOK,
+	SLOT_TYPE_FISH_EVENT,
+	SLOT_TYPE_AURA,
+	SLOT_TYPE_PREMIUM_PRIVATE_SHOP,
+	SLOT_TYPE_GOLDEN_LAND_FRUIT,
+	SLOT_TYPE_MAX,
+};
+
+enum EParts
+{
+	PART_MAIN,
+	PART_WEAPON,
+	PART_HEAD,
+	PART_HAIR,
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	PART_ACCE,
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	PART_AURA,
+#endif
+
+	PART_MAX_NUM,
+	PART_WEAPON_SUB,
+};
+
+#if defined(__LOCALE_CLIENT__)
+enum ELCType
+{
+	LC_TYPE_STRING,
+	LC_TYPE_QUEST,
+	LC_TYPE_ITEM,
+	LC_TYPE_MOB,
+	LC_TYPE_SKILL,
+	LC_TYPE_PETSKILL,
+	LC_TYPE_OX
+};
+#endif
+
+enum EChatType
+{
+	CHAT_TYPE_TALKING, /* 柳 채 */
+	CHAT_TYPE_INFO, /*  ( , 치 . ) */
+	CHAT_TYPE_NOTICE, /*  */
+	CHAT_TYPE_PARTY, /* 티 */
+	CHAT_TYPE_GUILD, /* 躍 */
+	CHAT_TYPE_COMMAND, /* 球  */
+	CHAT_TYPE_SHOUT, /* 치 */
+	CHAT_TYPE_WHISPER,
+	CHAT_TYPE_BIG_NOTICE,
+	CHAT_TYPE_MONARCH_NOTICE,
+#if defined(__OX_RENEWAL__)
+	CHAT_TYPE_BIG_CONTROL_NOTICE,
+#endif
+#if defined(__DICE_SYSTEM__)
+	CHAT_TYPE_DICE_INFO,
+#endif
+	CHAT_TYPE_MISSION,
+	CHAT_TYPE_SUB_MISSION,
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+	CHAT_TYPE_EXP_INFO,
+	CHAT_TYPE_ITEM_INFO,
+	CHAT_TYPE_MONEY_INFO,
+#endif
+	CHAT_TYPE_MAX_NUM
+};
+
+enum EWhisperType
+{
+	WHISPER_TYPE_NORMAL = 0,
+	WHISPER_TYPE_NOT_EXIST = 1,
+	WHISPER_TYPE_TARGET_BLOCKED = 2,
+	WHISPER_TYPE_SENDER_BLOCKED = 3,
+	WHISPER_TYPE_ERROR = 4,
+	WHISPER_TYPE_GM = 5,
+	WHISPER_TYPE_SYSTEM = 0xFF
+};
+
+enum ECharacterPosition
+{
+	POSITION_GENERAL,
+	POSITION_BATTLE,
+	POSITION_DYING,
+	POSITION_SITTING_CHAIR,
+	POSITION_SITTING_GROUND,
+	POSITION_INTRO,
+	POSITION_MAX_NUM
+};
+
+enum EGMLevels
+{
+	GM_PLAYER,
+	GM_LOW_WIZARD,
+	GM_WIZARD,
+	GM_HIGH_WIZARD,
+	GM_GOD,
+	GM_IMPLEMENTOR
+};
+
+enum EMobRank
+{
+	MOB_RANK_PAWN,
+	MOB_RANK_S_PAWN,
+	MOB_RANK_KNIGHT,
+	MOB_RANK_S_KNIGHT,
+	MOB_RANK_BOSS,
+	MOB_RANK_KING,
+	MOB_RANK_MAX_NUM
+};
+
+enum ECharType
+{
+	CHAR_TYPE_MONSTER,
+	CHAR_TYPE_NPC,
+	CHAR_TYPE_STONE,
+	CHAR_TYPE_WARP,
+	CHAR_TYPE_DOOR,
+	CHAR_TYPE_BUILDING,
+	CHAR_TYPE_PC,
+	CHAR_TYPE_POLYMORPH_PC,
+	CHAR_TYPE_HORSE,
+	CHAR_TYPE_GOTO,
+	CHAR_TYPE_PET,
+	CHAR_TYPE_PET_PAY,
+	CHAR_TYPE_SHOP,
+	CHAR_TYPE_OBJECT,
+};
+
+enum EBattleType
+{
+	BATTLE_TYPE_MELEE,
+	BATTLE_TYPE_RANGE,
+	BATTLE_TYPE_MAGIC,
+	BATTLE_TYPE_SPECIAL,
+	BATTLE_TYPE_POWER,
+	BATTLE_TYPE_TANKER,
+	BATTLE_TYPE_SUPER_POWER,
+	BATTLE_TYPE_SUPER_TANKER,
+	BATTLE_TYPE_MAX_NUM
+};
+
+enum EApplyTypes
+{
+	APPLY_NONE,							// 0
+	APPLY_MAX_HP,						// 1
+	APPLY_MAX_SP,						// 2
+	APPLY_CON,							// 3
+	APPLY_INT,							// 4
+	APPLY_STR,							// 5
+	APPLY_DEX,							// 6
+	APPLY_ATT_SPEED,					// 7
+	APPLY_MOV_SPEED,					// 8
+	APPLY_CAST_SPEED,					// 9
+	APPLY_HP_REGEN,						// 10
+	APPLY_SP_REGEN,						// 11
+	APPLY_POISON_PCT,					// 12
+	APPLY_STUN_PCT,						// 13
+	APPLY_SLOW_PCT,						// 14
+	APPLY_CRITICAL_PCT,					// 15
+	APPLY_PENETRATE_PCT,				// 16
+	APPLY_ATTBONUS_HUMAN,				// 17
+	APPLY_ATTBONUS_ANIMAL,				// 18
+	APPLY_ATTBONUS_ORC,					// 19
+	APPLY_ATTBONUS_MILGYO,				// 20
+	APPLY_ATTBONUS_UNDEAD,				// 21
+	APPLY_ATTBONUS_DEVIL,				// 22
+	APPLY_STEAL_HP,						// 23
+	APPLY_STEAL_SP,						// 24
+	APPLY_MANA_BURN_PCT,				// 25
+	APPLY_DAMAGE_SP_RECOVER,			// 26
+	APPLY_BLOCK,						// 27
+	APPLY_DODGE,						// 28
+	APPLY_RESIST_SWORD,					// 29
+	APPLY_RESIST_TWOHAND,				// 30
+	APPLY_RESIST_DAGGER,				// 31
+	APPLY_RESIST_BELL,					// 32
+	APPLY_RESIST_FAN,					// 33
+	APPLY_RESIST_BOW,					// 34
+	APPLY_RESIST_FIRE,					// 35
+	APPLY_RESIST_ELEC,					// 36
+	APPLY_RESIST_MAGIC,					// 37
+	APPLY_RESIST_WIND,					// 38
+	APPLY_REFLECT_MELEE,				// 39
+	APPLY_REFLECT_CURSE,				// 40
+	APPLY_POISON_REDUCE,				// 41
+	APPLY_KILL_SP_RECOVER,				// 42
+	APPLY_EXP_DOUBLE_BONUS,				// 43
+	APPLY_GOLD_DOUBLE_BONUS,			// 44
+	APPLY_ITEM_DROP_BONUS,				// 45
+	APPLY_POTION_BONUS,					// 46
+	APPLY_KILL_HP_RECOVER,				// 47
+	APPLY_IMMUNE_STUN,					// 48
+	APPLY_IMMUNE_SLOW,					// 49
+	APPLY_IMMUNE_FALL,					// 50
+	APPLY_SKILL,						// 51
+	APPLY_BOW_DISTANCE,					// 52
+	APPLY_ATT_GRADE_BONUS,				// 53
+	APPLY_DEF_GRADE_BONUS,				// 54
+	APPLY_MAGIC_ATT_GRADE,				// 55
+	APPLY_MAGIC_DEF_GRADE,				// 56
+	APPLY_CURSE_PCT,					// 57
+	APPLY_MAX_STAMINA,					// 58
+	APPLY_ATTBONUS_WARRIOR,				// 59
+	APPLY_ATTBONUS_ASSASSIN,			// 60
+	APPLY_ATTBONUS_SURA,				// 61
+	APPLY_ATTBONUS_SHAMAN,				// 62
+	APPLY_ATTBONUS_MONSTER,				// 63
+	APPLY_MALL_ATTBONUS,				// 64 賦 +x%
+	APPLY_MALL_DEFBONUS,				// 65  +x%
+	APPLY_MALL_EXPBONUS,				// 66 치 +x%
+	APPLY_MALL_ITEMBONUS,				// 67   x/10
+	APPLY_MALL_GOLDBONUS,				// 68   x/10
+	APPLY_MAX_HP_PCT,					// 69 獵  +x%
+	APPLY_MAX_SP_PCT,					// 70 獵 킹 +x%
+	APPLY_SKILL_DAMAGE_BONUS,			// 71 킬  * (100+x)%
+	APPLY_NORMAL_HIT_DAMAGE_BONUS,		// 72 타  * (100+x)%
+	APPLY_SKILL_DEFEND_BONUS,			// 73 킬   * (100-x)%
+	APPLY_NORMAL_HIT_DEFEND_BONUS,		// 74 타   * (100-x)%
+	APPLY_PC_BANG_EXP_BONUS,			// 75 PC  EXP 駕
+	APPLY_PC_BANG_DROP_BONUS,			// 76 PC   駕
+
+	APPLY_EXTRACT_HP_PCT,				// 77  HP 恬
+
+	APPLY_RESIST_WARRIOR,				// 78 玲 
+	APPLY_RESIST_ASSASSIN,				// 79 微 
+	APPLY_RESIST_SURA,					// 80 璨“ 
+	APPLY_RESIST_SHAMAN,				// 81 玲 
+
+	APPLY_ENERGY,						// 82 
+	APPLY_DEF_GRADE,					// 83 . DEF_GRADE_BONUS 클璨【 菅  풩 (...) 獵.
+	APPLY_COSTUME_ATTR_BONUS,			// 84 黴튬 謗  憺치 駕
+	APPLY_MAGIC_ATTBONUS_PER,			// 85  賦 +x%
+	APPLY_MELEE_MAGIC_ATTBONUS_PER,		// 86  + 龜 賦 +x%
+
+	APPLY_RESIST_ICE,					// 87 챰 
+	APPLY_RESIST_EARTH,					// 88  
+	APPLY_RESIST_DARK,					// 89  
+
+	APPLY_ANTI_CRITICAL_PCT,			// 90 크티 
+	APPLY_ANTI_PENETRATE_PCT,			// 91 타 
+
+	APPLY_BLEEDING_REDUCE,			// 92
+	APPLY_BLEEDING_PCT,				// 93
+	APPLY_ATTBONUS_WOLFMAN,			// 94
+	APPLY_RESIST_WOLFMAN,			// 95
+	APPLY_RESIST_CLAW,				// 96
+
+	APPLY_ACCEDRAIN_RATE,
+	APPLY_RESIST_MAGIC_REDUCTION,
+
+	APPLY_ENCHANT_ELECT,
+	APPLY_ENCHANT_FIRE,
+	APPLY_ENCHANT_ICE,
+	APPLY_ENCHANT_WIND,
+	APPLY_ENCHANT_EARTH,
+	APPLY_ENCHANT_DARK,
+
+	APPLY_ATTBONUS_CZ,
+	APPLY_ATTBONUS_INSECT,
+	APPLY_ATTBONUS_DESERT,
+	APPLY_ATTBONUS_SWORD,
+	APPLY_ATTBONUS_TWOHAND,
+	APPLY_ATTBONUS_DAGGER,
+	APPLY_ATTBONUS_BELL,
+	APPLY_ATTBONUS_FAN,
+	APPLY_ATTBONUS_BOW,
+	APPLY_ATTBONUS_CLAW,
+
+	APPLY_RESIST_HUMAN,
+	APPLY_RESIST_MOUNT_FALL,
+	APPLY_RESIST_FIST,
+
+	APPLY_MOUNT,
+
+	APPLY_SKILL_DAMAGE_SAMYEON,
+	APPLY_SKILL_DAMAGE_TANHWAN,
+	APPLY_SKILL_DAMAGE_PALBANG,
+	APPLY_SKILL_DAMAGE_GIGONGCHAM,
+	APPLY_SKILL_DAMAGE_GYOKSAN,
+	APPLY_SKILL_DAMAGE_GEOMPUNG,
+	APPLY_SKILL_DAMAGE_AMSEOP,
+	APPLY_SKILL_DAMAGE_GUNGSIN,
+	APPLY_SKILL_DAMAGE_CHARYUN,
+	APPLY_SKILL_DAMAGE_SANGONG,
+	APPLY_SKILL_DAMAGE_YEONSA,
+	APPLY_SKILL_DAMAGE_KWANKYEOK,
+	APPLY_SKILL_DAMAGE_GIGUNG,
+	APPLY_SKILL_DAMAGE_HWAJO,
+	APPLY_SKILL_DAMAGE_SWAERYUNG,
+	APPLY_SKILL_DAMAGE_YONGKWON,
+	APPLY_SKILL_DAMAGE_PABEOB,
+	APPLY_SKILL_DAMAGE_MARYUNG,
+	APPLY_SKILL_DAMAGE_HWAYEOMPOK,
+	APPLY_SKILL_DAMAGE_MAHWAN,
+	APPLY_SKILL_DAMAGE_BIPABU,
+	APPLY_SKILL_DAMAGE_YONGBI,
+	APPLY_SKILL_DAMAGE_PAERYONG,
+	APPLY_SKILL_DAMAGE_NOEJEON,
+	APPLY_SKILL_DAMAGE_BYEURAK,
+	APPLY_SKILL_DAMAGE_CHAIN,
+	APPLY_SKILL_DAMAGE_CHAYEOL,
+	APPLY_SKILL_DAMAGE_SALPOONG,
+	APPLY_SKILL_DAMAGE_GONGDAB,
+	APPLY_SKILL_DAMAGE_PASWAE,
+
+	APPLY_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE,
+	APPLY_SKILL_DEFEND_BONUS_BOSS_OR_MORE,
+	APPLY_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE,
+	APPLY_SKILL_DAMAGE_BONUS_BOSS_OR_MORE,
+
+	APPLY_HIT_BUFF_ENCHANT_FIRE,
+	APPLY_HIT_BUFF_ENCHANT_ICE,
+	APPLY_HIT_BUFF_ENCHANT_ELEC,
+	APPLY_HIT_BUFF_ENCHANT_WIND,
+	APPLY_HIT_BUFF_ENCHANT_DARK,
+	APPLY_HIT_BUFF_ENCHANT_EARTH,
+	APPLY_HIT_BUFF_RESIST_FIRE,
+	APPLY_HIT_BUFF_RESIST_ICE,
+	APPLY_HIT_BUFF_RESIST_ELEC,
+	APPLY_HIT_BUFF_RESIST_WIND,
+	APPLY_HIT_BUFF_RESIST_DARK,
+	APPLY_HIT_BUFF_RESIST_EARTH,
+
+	APPLY_USE_SKILL_CHEONGRANG_MOV_SPEED,
+	APPLY_USE_SKILL_CHEONGRANG_CASTING_SPEED,
+	APPLY_USE_SKILL_CHAYEOL_CRITICAL_PCT,
+	APPLY_USE_SKILL_SANGONG_ATT_GRADE_BONUS,
+	APPLY_USE_SKILL_GIGUNG_ATT_GRADE_BONUS,
+	APPLY_USE_SKILL_JEOKRANG_DEF_BONUS,
+	APPLY_USE_SKILL_GWIGEOM_DEF_BONUS,
+	APPLY_USE_SKILL_TERROR_ATT_GRADE_BONUS,
+	APPLY_USE_SKILL_MUYEONG_ATT_GRADE_BONUS,
+	APPLY_USE_SKILL_MANASHILED_CASTING_SPEED,
+	APPLY_USE_SKILL_HOSIN_DEF_BONUS,
+	APPLY_USE_SKILL_GICHEON_ATT_GRADE_BONUS,
+	APPLY_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS,
+	APPLY_USE_SKILL_JEUNGRYEOK_DEF_BONUS,
+	APPLY_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS,
+	APPLY_USE_SKILL_CHUNKEON_CASTING_SPEED,
+	APPLY_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS,
+
+	APPLY_SKILL_DURATION_INCREASE_EUNHYUNG,
+	APPLY_SKILL_DURATION_INCREASE_GYEONGGONG,
+	APPLY_SKILL_DURATION_INCREASE_GEOMKYUNG,
+	APPLY_SKILL_DURATION_INCREASE_JEOKRANG,
+
+	APPLY_USE_SKILL_PALBANG_HP_ABSORB,
+	APPLY_USE_SKILL_AMSEOP_HP_ABSORB,
+	APPLY_USE_SKILL_YEONSA_HP_ABSORB,
+	APPLY_USE_SKILL_YONGBI_HP_ABSORB,
+	APPLY_USE_SKILL_CHAIN_HP_ABSORB,
+	APPLY_USE_SKILL_PASWAE_SP_ABSORB,
+	APPLY_USE_SKILL_GIGONGCHAM_STUN,
+	APPLY_USE_SKILL_CHARYUN_STUN,
+	APPLY_USE_SKILL_PABEOB_STUN,
+	APPLY_USE_SKILL_MAHWAN_STUN,
+	APPLY_USE_SKILL_GONGDAB_STUN,
+	APPLY_USE_SKILL_SAMYEON_STUN,
+	APPLY_USE_SKILL_GYOKSAN_KNOCKBACK,
+	APPLY_USE_SKILL_SEOMJEON_KNOCKBACK,
+	APPLY_USE_SKILL_SWAERYUNG_KNOCKBACK,
+	APPLY_USE_SKILL_HWAYEOMPOK_KNOCKBACK,
+	APPLY_USE_SKILL_GONGDAB_KNOCKBACK,
+	APPLY_USE_SKILL_KWANKYEOK_KNOCKBACK,
+	APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER,
+	APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER,
+	APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER,
+	APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER,
+	APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER,
+	APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER,
+	APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER,
+	APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER,
+	APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER,
+	APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER,
+
+	APPLY_ATTBONUS_STONE,
+
+	APPLY_DAMAGE_HP_RECOVERY,
+	APPLY_DAMAGE_SP_RECOVERY,
+
+	APPLY_ALIGNMENT_DAMAGE_BONUS,
+
+	APPLY_NORMAL_DAMAGE_GUARD,
+	APPLY_MORE_THEN_HP90_DAMAGE_REDUCE,
+
+	APPLY_USE_SKILL_TUSOK_HP_ABSORB,
+	APPLY_USE_SKILL_PAERYONG_HP_ABSORB,
+	APPLY_USE_SKILL_BYEURAK_HP_ABSORB,
+
+	APPLY_FIRST_ATTRIBUTE_BONUS,
+	APPLY_SECOND_ATTRIBUTE_BONUS,
+	APPLY_THIRD_ATTRIBUTE_BONUS,
+	APPLY_FOURTH_ATTRIBUTE_BONUS,
+	APPLY_FIFTH_ATTRIBUTE_BONUS,
+
+	APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER,
+	APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER,
+	APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER,
+	APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER,
+	APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER,
+	APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER,
+	APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER,
+	APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER,
+	APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER,
+	APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER,
+	APPLY_USE_SKILL_CHAYEOL_HP_ABSORB,
+
+	APPLY_SUNGMA_STR,
+	APPLY_SUNGMA_HP,
+	APPLY_SUNGMA_MOVE,
+	APPLY_SUNGMA_IMMUNE,
+
+	APPLY_HIT_PCT,
+	APPLY_RANDOM,
+
+	APPLY_ATTBONUS_PER_HUMAN,
+	APPLY_ATTBONUS_PER_ANIMAL,
+	APPLY_ATTBONUS_PER_ORC,
+	APPLY_ATTBONUS_PER_MILGYO,
+	APPLY_ATTBONUS_PER_UNDEAD,
+	APPLY_ATTBONUS_PER_DEVIL,
+
+	APPLY_ENCHANT_PER_ELECT,
+	APPLY_ENCHANT_PER_FIRE,
+	APPLY_ENCHANT_PER_ICE,
+	APPLY_ENCHANT_PER_WIND,
+	APPLY_ENCHANT_PER_EARTH,
+	APPLY_ENCHANT_PER_DARK,
+
+	APPLY_ATTBONUS_PER_CZ,
+	APPLY_ATTBONUS_PER_INSECT,
+	APPLY_ATTBONUS_PER_DESERT,
+	APPLY_ATTBONUS_PER_STONE,
+	APPLY_ATTBONUS_PER_MONSTER,
+
+	APPLY_RESIST_PER_HUMAN,
+	APPLY_RESIST_PER_ICE,
+	APPLY_RESIST_PER_DARK,
+	APPLY_RESIST_PER_EARTH,
+	APPLY_RESIST_PER_FIRE,
+	APPLY_RESIST_PER_ELEC,
+	APPLY_RESIST_PER_MAGIC,
+	APPLY_RESIST_PER_WIND,
+
+	APPLY_HIT_BUFF_SUNGMA_STR,
+	APPLY_HIT_BUFF_SUNGMA_MOVE,
+	APPLY_HIT_BUFF_SUNGMA_HP,
+	APPLY_HIT_BUFF_SUNGMA_IMMUNE,
+
+	APPLY_MOUNT_MELEE_MAGIC_ATTBONUS_PER,
+	APPLY_DISMOUNT_MOVE_SPEED_BONUS_PER,
+
+	APPLY_HIT_AUTO_HP_RECOVERY,
+	APPLY_HIT_AUTO_SP_RECOVERY,
+
+	APPLY_USE_SKILL_COOLTIME_DECREASE_ALL,
+
+	APPLY_HIT_STONE_ATTBONUS_STONE,
+	APPLY_HIT_STONE_DEF_GRADE_BONUS,
+
+	APPLY_KILL_BOSS_ITEM_BONUS,
+	APPLY_MOB_HIT_MOB_AGGRESSIVE,
+	APPLY_NO_DEATH_AND_HP_RECOVERY30,
+
+	APPLY_AUTO_PICKUP,
+	APPLY_MOUNT_NO_KNOCKBACK,
+
+	APPLY_SUNGMA_PER_STR,
+	APPLY_SUNGMA_PER_HP,
+	APPLY_SUNGMA_PER_MOVE,
+	APPLY_SUNGMA_PER_IMMUNE,
+
+	APPLY_IMMUNE_POISON100,
+	APPLY_IMMUNE_BLEEDING100,
+
+	APPLY_MONSTER_DEFEND_BONUS,
+
+	MAX_APPLY_NUM,
+};
+
+enum EOnClickEvents
+{
+	ON_CLICK_NONE,
+	ON_CLICK_TALK,
+	ON_CLICK_SHOP,
+	ON_CLICK_MAX_NUM
+};
+
+enum EOnIdleEvents
+{
+	ON_IDLE_NONE,
+	ON_IDLE_GENERAL,
+	ON_IDLE_MAX_NUM
+};
+
+enum EWindows
+{
+	RESERVED_WINDOW,
+	INVENTORY,
+	EQUIPMENT,
+	SAFEBOX,
+	MALL,
+	DRAGON_SOUL_INVENTORY,
+	BELT_INVENTORY,
+	GUILDBANK, // __GUILDRENEWAL_SYSTEM__
+	MAIL, // __MAILBOX__
+	NPC_STORAGE, // __ATTR_6TH_7TH__
+#if defined(__PREMIUM_PRIVATE_SHOP__)
+	PREMIUM_PRIVATE_SHOP,
+#endif
+	ACCEREFINE, // __ACCE_COSTUME_SYSTEM__
+	GROUND, // NOTE : 2013 25  unused..  獵째???
+#if defined(__GROWTH_PET_SYSTEM__)
+	PET_FEED,
+#endif
+	CHANGELOOK, // __CHANGE_LOOK_SYSTEM__
+	AURA_REFINE, // __AURA_COSTUME_SYSTEM__
+	CUBE_WINDOW, // __CUBE_RENEWAL__
+
+	WINDOW_TYPE_MAX,
+};
+
+enum ETradeWnd
+{
+	WND_EXCHANGE = (1 << 0),
+	WND_MYSHOP = (1 << 1),
+	WND_SHOPOWNER = (1 << 2),
+	WND_SAFEBOX = (1 << 3),
+	WND_REFINE = (1 << 4),
+	WND_CUBE = (1 << 5),
+#if defined(__MOVE_COSTUME_ATTR__)
+	WND_ITEM_COMB = (1 << 6),
+#endif
+#if defined(__CHANGED_ATTR__)
+	WND_SELECT_ATTR = (1 << 7),
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	WND_ACCE = (1 << 8),
+#endif
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	WND_CHANGELOOK = (1 << 9),
+#endif
+
+#if defined(__MAILBOX__)
+	WND_MAILBOX = (1 << 11),
+#endif
+#if defined(__ATTR_6TH_7TH__)
+	WND_ATTR67ADD = (1 << 12),
+#endif
+#if defined(__MOVE_COSTUME_ATTR__)
+	WND_LUCKY_BOX = (1 << 13),
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	WND_AURA = (1 << 14),
+#endif
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	WND_MINIGAME_ROULETTE = (1 << 15),
+#endif
+	WND_ALL = (1 << 31), // MAX 31
+};
+
+enum EMobSizes
+{
+	MOBSIZE_RESERVED,
+	MOBSIZE_SMALL,
+	MOBSIZE_MEDIUM,
+	MOBSIZE_BIG
+};
+
+enum EAIFlags
+{
+	AIFLAG_AGGRESSIVE = (1 << 0),
+	AIFLAG_NOMOVE = (1 << 1),
+	AIFLAG_COWARD = (1 << 2),
+	AIFLAG_NOATTACKSHINSU = (1 << 3),
+	AIFLAG_NOATTACKCHUNJO = (1 << 4),
+	AIFLAG_NOATTACKJINNO = (1 << 5),
+	AIFLAG_ATTACKMOB = (1 << 6),
+	AIFLAG_BERSERK = (1 << 7),
+	AIFLAG_STONESKIN = (1 << 8),
+	AIFLAG_GODSPEED = (1 << 9),
+	AIFLAG_DEATHBLOW = (1 << 10),
+	AIFLAG_REVIVE = (1 << 11),
+	AIFLAG_HEALER = (1 << 12),
+	AIFLAG_COUNT = (1 << 13),
+	AIFLAG_NORECOVERY = (1 << 14),
+	AIFLAG_REFLECT = (1 << 15),
+	AIFLAG_FALL = (1 << 16),
+	AIFLAG_VIT = (1 << 17),
+	AIFLAG_RATTSPEED = (1 << 18),
+	AIFLAG_RCASTSPEED = (1 << 19),
+	AIFLAG_RHP_REGEN = (1 << 20),
+	AIFLAG_TIMEVIT = (1 << 21),
+};
+
+enum EMobStatType
+{
+	MOB_STATTYPE_POWER,
+	MOB_STATTYPE_TANKER,
+	MOB_STATTYPE_SUPER_POWER,
+	MOB_STATTYPE_SUPER_TANKER,
+	MOB_STATTYPE_RANGE,
+	MOB_STATTYPE_MAGIC,
+	MOB_STATTYPE_MAX_NUM
+};
+
+enum EImmuneFlags
+{
+	IMMUNE_STUN = (1 << 0),
+	IMMUNE_SLOW = (1 << 1),
+	IMMUNE_FALL = (1 << 2),
+	IMMUNE_CURSE = (1 << 3),
+	IMMUNE_POISON = (1 << 4),
+	IMMUNE_TERROR = (1 << 5),
+	IMMUNE_REFLECT = (1 << 6),
+};
+
+enum EMobEnchants
+{
+	MOB_ENCHANT_CURSE,
+	MOB_ENCHANT_SLOW,
+	MOB_ENCHANT_POISON,
+	MOB_ENCHANT_STUN,
+	MOB_ENCHANT_CRITICAL,
+	MOB_ENCHANT_PENETRATE,
+	MOB_ENCHANTS_MAX_NUM
+};
+
+enum EMobResists
+{
+	MOB_RESIST_FIST,
+
+	MOB_RESIST_SWORD,
+	MOB_RESIST_TWOHAND,
+	MOB_RESIST_DAGGER,
+	MOB_RESIST_BELL,
+	MOB_RESIST_FAN,
+	MOB_RESIST_BOW,
+	MOB_RESIST_CLAW,
+
+	MOB_RESIST_FIRE,
+	MOB_RESIST_ELECT,
+	MOB_RESIST_MAGIC,
+	MOB_RESIST_WIND,
+
+	MOB_RESIST_POISON,
+	MOB_RESIST_BLEEDING,
+
+	MOB_RESISTS_MAX_NUM
+};
+
+//#if defined(__ELEMENT_SYSTEM__)
+enum EMobElements
+{
+	MOB_ELEMENT_ELECT,
+	MOB_ELEMENT_FIRE,
+	MOB_ELEMENT_ICE,
+	MOB_ELEMENT_WIND,
+	MOB_ELEMENT_EARTH,
+	MOB_ELEMENT_DARK,
+	MOB_ELEMENT_MAX_NUM
+};
+//#endif
+
+enum
+{
+	SKILL_ATTR_TYPE_NORMAL = 1,
+	SKILL_ATTR_TYPE_MELEE,
+	SKILL_ATTR_TYPE_RANGE,
+	SKILL_ATTR_TYPE_MAGIC
+	/*
+	SKILL_ATTR_TYPE_FIRE,
+	SKILL_ATTR_TYPE_ICE,
+	SKILL_ATTR_TYPE_ELEC,
+	SKILL_ATTR_TYPE_DARK,
+	*/
+};
+
+enum
+{
+	SKILL_NORMAL,
+	SKILL_MASTER,
+	SKILL_GRAND_MASTER,
+	SKILL_PERFECT_MASTER,
+};
+
+enum EGuildWarType
+{
+	GUILD_WAR_TYPE_FIELD,
+	GUILD_WAR_TYPE_BATTLE,
+	GUILD_WAR_TYPE_FLAG,
+	GUILD_WAR_TYPE_MAX_NUM
+};
+
+enum EGuildWarState
+{
+	GUILD_WAR_NONE,
+	GUILD_WAR_SEND_DECLARE,
+	GUILD_WAR_REFUSE,
+	GUILD_WAR_RECV_DECLARE,
+	GUILD_WAR_WAIT_START,
+	GUILD_WAR_CANCEL,
+	GUILD_WAR_ON_WAR,
+	GUILD_WAR_END,
+	GUILD_WAR_OVER,
+	GUILD_WAR_RESERVE,
+
+	GUILD_WAR_DURATION = 30 * 60, // 1챨
+	GUILD_WAR_WIN_POINT = 1000,
+	GUILD_WAR_LADDER_HALF_PENALTY_TIME = 12 * 60 * 60,
+};
+
+enum EAttributeSet
+{
+	ATTRIBUTE_SET_WEAPON,
+	ATTRIBUTE_SET_BODY,
+	ATTRIBUTE_SET_WRIST,
+	ATTRIBUTE_SET_FOOTS,
+	ATTRIBUTE_SET_NECK,
+	ATTRIBUTE_SET_HEAD,
+	ATTRIBUTE_SET_SHIELD,
+	ATTRIBUTE_SET_EAR,
+#if defined(__PENDANT_SYSTEM__)
+	ATTRIBUTE_SET_PENDANT,
+#endif
+#if defined(__GLOVE_SYSTEM__)
+	ATTRIBUTE_SET_GLOVE,
+#endif
+#if defined(__COSTUME_SYSTEM__)
+	ATTRIBUTE_SET_COSTUME_BODY,
+	ATTRIBUTE_SET_COSTUME_HAIR,
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+	ATTRIBUTE_SET_COSTUME_WEAPON,
+#endif
+#endif
+	ATTRIBUTE_SET_MAX_NUM
+};
+
+enum EPrivType
+{
+	PRIV_NONE,
+	PRIV_ITEM_DROP,
+	PRIV_GOLD_DROP,
+	PRIV_GOLD10_DROP,
+	PRIV_EXP_PCT,
+	MAX_PRIV_NUM,
+};
+
+enum EMoneyLogType
+{
+	MONEY_LOG_RESERVED,
+	MONEY_LOG_MONSTER,
+	MONEY_LOG_SHOP,
+	MONEY_LOG_REFINE,
+	MONEY_LOG_QUEST,
+	MONEY_LOG_GUILD,
+	MONEY_LOG_MISC,
+	MONEY_LOG_MONSTER_KILL,
+	MONEY_LOG_DROP,
+	MONEY_LOG_TYPE_MAX_NUM,
+};
+
+enum EPremiumTypes
+{
+	PREMIUM_EXP, // 치 1.2
+	PREMIUM_ITEM, //   2
+	PREMIUM_SAFEBOX, // 창 1칸 3칸
+	PREMIUM_AUTOLOOT, //  湄 膚
+	PREMIUM_FISH_MIND, //    확 
+	PREMIUM_MARRIAGE_FAST, // 阜   爛求.
+	PREMIUM_GOLD, //   1.5
+	PREMIUM_AUTO_USE,
+#if defined(__CONQUEROR_LEVEL__)
+	PREMIUM_SUNGMA,
+#endif
+	PREMIUM_MAX_NUM = 9
+};
+
+enum SPECIAL_EFFECT
+{
+	SE_NONE,
+
+	SE_HPUP_RED,
+	SE_SPUP_BLUE,
+	SE_SPEEDUP_GREEN,
+	SE_DXUP_PURPLE,
+	SE_CRITICAL,
+	SE_PENETRATE,
+	SE_BLOCK,
+	SE_DODGE,
+	SE_CHINA_FIREWORK,
+	SE_SPIN_TOP,
+	SE_SUCCESS,
+	SE_FAIL,
+	SE_FR_SUCCESS,
+	SE_LEVELUP_ON_14_FOR_GERMANY, // 14灸 (  )
+	SE_LEVELUP_UNDER_15_FOR_GERMANY, // 15灸 (  )
+	SE_PERCENT_DAMAGE1,
+	SE_PERCENT_DAMAGE2,
+	SE_PERCENT_DAMAGE3,
+
+	SE_AUTO_HPUP,
+	SE_AUTO_SPUP,
+
+	SE_EQUIP_RAMADAN_RING, // 駕쨈  求  森求 트
+	SE_EQUIP_HALLOWEEN_CANDY, // 念  (-_-;)  森求 트
+	SE_EQUIP_HAPPINESS_RING, // 크 僊  求  森求 트
+	SE_EQUIP_LOVE_PENDANT, // 芟타  年트(71145)   트 (森트, 트 틈)
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	SE_ACCE_SUCESS_ABSORB,
+	SE_ACCE_EQUIP,
+	SE_ACCE_BACK,
+#endif
+
+	SE_EQUIP_EASTER_CANDY,
+
+	SE_THUNDER_AREA,
+	SE_THUNDER,
+	SE_HEAL,
+
+	SE_CAPE_OF_COURAGE,
+	SE_EQUIP_CHOCOLATE_PENDANT,
+#if defined(__PVP_BALANCE_IMPROVING__)
+	SE_FEATHER_WALK,
+#endif
+	SE_PEPSI_EVENT,
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	SE_DRAGONLAIR_STONE_UNBEATABLE_1,
+	SE_DRAGONLAIR_STONE_UNBEATABLE_2,
+	SE_DRAGONLAIR_STONE_UNBEATABLE_3,
+#endif
+
+	SE_BATTLE_POTION, // Battle Field
+	SE_REFLECT, // AI_FLAG_REFLECT
+
+	SE_SKILL_DAMAGE_ZONE,
+	SE_SKILL_SAFE_ZONE,
+	SE_METEOR,
+	SE_BEAD_RAIN,
+	SE_ARROW_RAIN,
+	SE_FALL_ROCK,
+	SE_HORSE_DROP,
+	SE_EGG_DROP,
+	SE_DEAPO_BOOM,
+
+#if defined(__FLOWER_EVENT__)
+	SE_FLOWER_EVENT,
+#endif
+#if defined(__GEM_SYSTEM__)
+	SE_GEM_PENDANT,
+#endif
+#if defined(__DEFENSE_WAVE__)
+	SE_DEFENSE_WAVE_LASER,
+#endif
+	SE_PET_ATTR_CHANGE_NEW_TYPE,
+	SE_PET_PAY_SUMMON1,
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	SE_SPECIAL_ROULETTE,
+#endif
+	SE_MISTS_ISLAND_0,
+	SE_MISTS_ISLAND_1,
+	SE_MISTS_ISLAND_2,
+	SE_MISTS_ISLAND_3,
+	SE_PASSIVE_ATTR_SKILL,
+	SE_SUICIDE_BOMB_SMALL,
+	SE_SUICIDE_BOMB_LARGE,
+	SE_GROUND_THORN,
+	SE_GROUND_SNAKE,
+	SE_WHITE_DRAGON_BERSERK,
+	SE_WHITE_DRAGON_COOLING,
+	SE_USE_METINSTONE_RAIN_SPAWN_TICKET,
+	SE_FAKE_METINSTONE_SPLASH_DAMAGE,
+	SE_MOUNT_UPGRADE_SKILL,
+	SE_SOUTH_REAPER_SKILL_2,
+	SE_YEOMWANG_SKILL_2,
+	SE_BUFF_ITEM_5,
+	SE_BUFF_ITEM_13,
+	SE_BUFF_ITEM_14,
+	SE_BUFF_SYMBOL1,
+	SE_BUFF_ITEM_8_ELEMENT_1,
+	SE_BUFF_ITEM_8_ELEMENT_2,
+	SE_BUFF_FLOWER_OF_GALE,
+	SE_BUFF_FLOWER_OF_DESTRUCTION,
+	SE_SUNGMAHEE_GATE_FLOWER_BLOW_RANGE,
+	SE_SUNGMAHEE_GATE_INVINCIBLE_GATE,
+	SE_SUNGMAHEE_GATE_NORMAL_GATE,
+	SE_MOUNT_UPGRADE_GYEONGGONG,
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+	SE_USE_SNOWFLAKE_STICK,
+#endif
+	SE_SPORTS_MATCH_BUFF_EMBLEM,
+	SE_POINT_AREA_ELECT_ATTACK,
+#ifdef ENABLE_QUEEN_NETHIS
+	SE_EFFECT_SNAKE_REGEN,
+#endif
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	SE_EFFECT_BP_NORMAL_MISSION_COMPLETED,
+	SE_EFFECT_BP_PREMIUM_MISSION_COMPLETED,
+	SE_EFFECT_BP_EVENT_MISSION_COMPLETED,
+	SE_EFFECT_BP_NORMAL_BATTLEPASS_COMPLETED,
+	SE_EFFECT_BP_PREMIUM_BATTLEPASS_COMPLETED,
+	SE_EFFECT_BP_EVENT_BATTLEPASS_COMPLETED,
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+	SE_GYEONGGONG_BOOM,
+#endif
+};
+
+#include "item_length.h"
+
+// inventory position 타 체
+// int 絿 환 獵 ,SE_THUNDER
+// 觀 천  獨 window_type  歌, cell 毬 騁耐 ,( 觀 毬 潔底 inventory type繭 却 ,)
+// 觀   獨 호觀 求  歐 甄.
+
+enum EDragonSoulRefineWindowSize
+{
+	DRAGON_SOUL_REFINE_GRID_MAX = 15,
+};
+
+enum EMisc2
+{
+	INVENTORY_SLOT_START = 0,
+	INVENTORY_SLOT_END = INVENTORY_MAX_NUM,
+	
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	DRAGON_SOUL_EQUIP_SLOT_START = WEAR_MAX_NUM,
+	DRAGON_SOUL_EQUIP_SLOT_END = DRAGON_SOUL_EQUIP_SLOT_START + (DS_SLOT_MAX * DRAGON_SOUL_DECK_MAX_NUM),
+#endif
+
+	BELT_INVENTORY_SLOT_START = 0,
+	BELT_INVENTORY_SLOT_END = BELT_INVENTORY_SLOT_COUNT,
+	BELT_INVENTORY_MAX_NUM = BELT_INVENTORY_SLOT_END,
+
+	EQUIPMENT_SLOT_START = 0,
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	EQUIPMENT_SLOT_END = DRAGON_SOUL_EQUIP_SLOT_END,
+#else
+	EQUIPMENT_SLOT_END = WEAR_MAX_NUM,
+#endif
+	EQUIPMENT_MAX_NUM = EQUIPMENT_SLOT_END,
+
+	INVENTORY_AND_EQUIP_SLOT_MAX = INVENTORY_MAX_NUM + EQUIPMENT_MAX_NUM + BELT_INVENTORY_SLOT_COUNT,
+};
+
+#pragma pack(push, 1)
+
+typedef struct SItemPos
+{
+	BYTE window_type;
+	WORD cell;
+	SItemPos()
+	{
+		window_type = INVENTORY;
+		cell = WORD_MAX;
+	}
+
+	SItemPos(BYTE _window_type, WORD _cell)
+	{
+		window_type = _window_type;
+		cell = _cell;
+	}
+
+	bool IsValidItemPosition() const
+	{
+		switch (window_type)
+		{
+			case INVENTORY:
+				return cell < INVENTORY_MAX_NUM;
+
+			case EQUIPMENT:
+				return cell < EQUIPMENT_MAX_NUM;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			case DRAGON_SOUL_INVENTORY:
+				return cell < DRAGON_SOUL_INVENTORY_MAX_NUM;
+#endif
+
+			case BELT_INVENTORY:
+				return cell < BELT_INVENTORY_SLOT_COUNT;
+
+			//  크璲  window valid 체크   .
+			case SAFEBOX:
+			case MALL:
+				return false;
+
+			default:
+				return false;
+		}
+
+		return false;
+	}
+
+	bool IsSameItemPosition(const SItemPos& DestCell) const
+	{
+		return (window_type == DestCell.window_type) && (cell == DestCell.cell);
+	}
+
+	bool IsInventoryPosition() const
+	{
+		return (window_type == INVENTORY && cell < INVENTORY_MAX_NUM);
+	}
+
+	bool IsDefaultInventoryPosition() const
+	{
+		return IsInventoryPosition();
+	}
+
+	bool IsEquipPosition() const
+	{
+		return (IsEquipmentPosition()
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			|| IsDragonSoulEquipPosition()
+#endif
+			);
+	}
+
+	bool IsEquipmentPosition() const
+	{
+		return (window_type == EQUIPMENT && cell < EQUIPMENT_MAX_NUM);
+	}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	bool IsDragonSoulEquipPosition() const
+	{
+		return (EQUIPMENT == window_type && (cell >= DRAGON_SOUL_EQUIP_SLOT_START && cell < DRAGON_SOUL_EQUIP_SLOT_END));
+	}
+
+	bool IsDragonSoulInventoryPosition() const
+	{
+		return (window_type == DRAGON_SOUL_INVENTORY && cell < DRAGON_SOUL_INVENTORY_MAX_NUM);
+	}
+#endif
+
+	bool IsBeltInventoryPosition() const
+	{
+		return (window_type == BELT_INVENTORY && cell < BELT_INVENTORY_SLOT_COUNT);
+	}
+
+	bool operator==(const struct SItemPos& rhs) const
+	{
+		return (window_type == rhs.window_type) && (cell == rhs.cell);
+	}
+
+	bool operator!=(const struct SItemPos& rhs) const
+	{
+		return (window_type != rhs.window_type) || (cell != rhs.cell);
+	}
+
+	bool operator<(const struct SItemPos& rhs) const
+	{
+		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));
+	}
+} TItemPos;
+
+const TItemPos NPOS(RESERVED_WINDOW, WORD_MAX);
+
+typedef enum
+{
+	SHOP_COIN_TYPE_GOLD, // DEFAULT VALUE
+	SHOP_COIN_TYPE_SECONDARY_COIN,
+#if defined(__SHOPEX_RENEWAL__)
+	SHOP_COIN_TYPE_ITEM,
+	SHOP_COIN_MAX_TYPE,
+#endif
+} EShopCoinType;
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+enum EAcceMisc
+{
+	ACCE_MAX_DRAINRATE = 25,
+};
+
+enum EAcceSlot
+{
+	ACCE_SLOT_LEFT,
+	ACCE_SLOT_RIGHT,
+	ACCE_SLOT_RESULT,
+	ACCE_SLOT_MAX
+};
+
+enum EAcceSlotType
+{
+	ACCE_SLOT_TYPE_COMBINE,
+	ACCE_SLOT_TYPE_ABSORB,
+	ACCE_SLOT_TYPE_MAX
+};
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+enum EAuraMisc
+{
+	AURA_MAX_LEVEL = 250,
+};
+
+enum EAuraWindowType
+{
+	AURA_WINDOW_TYPE_ABSORB,
+	AURA_WINDOW_TYPE_GROWTH,
+	AURA_WINDOW_TYPE_EVOLVE,
+	AURA_WINDOW_TYPE_MAX,
+};
+
+enum EAuraSlot
+{
+	AURA_SLOT_MAIN,
+	AURA_SLOT_SUB,
+	AURA_SLOT_RESULT,
+	AURA_SLOT_MAX
+};
+
+enum EAuraGradeType
+{
+	AURA_GRADE_NONE,
+	AURA_GRADE_ORDINARY,
+	AURA_GRADE_SIMPLE,
+	AURA_GRADE_NOBLE,
+	AURA_GRADE_SPARKLING,
+	AURA_GRADE_MAGNIFICENT,
+	AURA_GRADE_RADIANT,
+	AURA_GRADE_MAX_NUM,
+};
+
+enum EAuraRefineTokenType
+{
+	AURA_REFINE_INFO_STEP,
+	AURA_REFINE_INFO_LEVEL_MIN,
+	AURA_REFINE_INFO_LEVEL_MAX,
+	AURA_REFINE_INFO_NEED_EXP,
+	AURA_REFINE_INFO_MATERIAL_VNUM,
+	AURA_REFINE_INFO_MATERIAL_COUNT,
+	AURA_REFINE_INFO_NEED_GOLD,
+	AURA_REFINE_INFO_EVOLVE_PCT,
+	AURA_REFINE_INFO_MAX
+};
+
+enum EAuraRefineInfoType
+{
+	AURA_REFINE_INFO_SLOT_CURRENT,
+	AURA_REFINE_INFO_SLOT_NEXT,
+	AURA_REFINE_INFO_SLOT_EVOLVED,
+	AURA_REFINE_INFO_SLOT_MAX
+};
+
+typedef struct SAuraRefineInfo
+{
+	BYTE bLevel;
+	BYTE bExpPercent;
+} TAuraRefineInfo;
+
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+enum ESpecialActionMisc
+{
+	SPECIAL_ACTION_START_INDEX = 101,
+	SPECIAL_ACTION_DURATION = 43200,
+	SPECIAL_ACTION_SLOT_COUNT = 12,
+};
+#endif
+
+enum EEmotion
+{
+	EMOTION_NONE,
+	EMOTION_CLAP,
+	EMOTION_CONGRATULATION,
+	EMOTION_FORGIVE,
+	EMOTION_ANGRY,
+	EMOTION_ATTRACTIVE,
+	EMOTION_SAD,
+	EMOTION_SHY,
+	EMOTION_CHEERUP,
+	EMOTION_BANTER,
+	EMOTION_JOY,
+	EMOTION_CHEERS_1,
+	EMOTION_CHEERS_2,
+	EMOTION_DANCE_1,
+	EMOTION_DANCE_2,
+	EMOTION_DANCE_3,
+	EMOTION_DANCE_4,
+	EMOTION_DANCE_5,
+	EMOTION_DANCE_6,
+
+	EMOTION_KISS = 51,
+	EMOTION_FRENCH_KISS = 52,
+	EMOTION_SLAP = 53,
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	EMOTION_PUSH_UP = SPECIAL_ACTION_START_INDEX,
+	EMOTION_DANCE_7,
+	EMOTION_EXERCISE,
+	EMOTION_DOZE,
+	EMOTION_SELFIE,
+	EMOTION_CHARGING,
+	EMOTION_NOSAY,
+	EMOTION_WEATHER_1,
+	EMOTION_WEATHER_2,
+	EMOTION_WEATHER_3,
+	EMOTION_HUNGRY,
+	EMOTION_SIREN,
+	EMOTION_LETTER,
+	EMOTION_CALL,
+	EMOTION_CELEBRATION,
+	EMOTION_ALCOHOL,
+	EMOTION_BUSY,
+	EMOTION_WHIRL,
+#endif
+	EMOTION_NUM,
+};
+
+enum EEmotionFlag
+{
+	EMOTION_FLAG_SELF = (1 << 0),
+	EMOTION_FLAG_TARGET = (1 << 1),
+	EMOTION_FLAG_MAN = (1 << 2),
+	EMOTION_FLAG_WOMAN = (1 << 3),
+	EMOTION_FLAG_OTHER_SEX = (1 << 3),
+};
+
+#if defined(__SET_ITEM__)
+enum ESetItemType
+{
+	SET_ITEM_COSTUME_BODY,
+	SET_ITEM_COSTUME_HAIR,
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	SET_ITEM_COSTUME_MOUNT,
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	SET_ITEM_COSTUME_ACCE,
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+	SET_ITEM_COSTUME_WEAPON,
+#endif
+	SET_ITEM_UNIQUE,
+	SET_ITEM_PET,
+
+	SET_ITEM_MAX
+};
+
+enum ESetItemValue
+{
+	SET_ITEM_SET_VALUE_NONE,
+	SET_ITEM_SET_VALUE_1,
+	SET_ITEM_SET_VALUE_2,
+	SET_ITEM_SET_VALUE_3,
+	SET_ITEM_SET_VALUE_4,
+	SET_ITEM_SET_VALUE_5,
+	SET_ITEM_SET_VALUE_MAX
+};
+#endif
+
+#if defined(__DELETE_FAILURE_TYPE__)
+enum EDeleteCharacterFailureType
+{
+	DELETE_FAILURE_NORMAL,
+#if defined(__SOUL_BIND_SYSTEM__)
+	DELETE_FAILURE_HAVE_SEALED_ITEM,
+#endif
+	DELETE_FAILURE_PRIVATE_CODE_ERROR,
+	DELETE_FAILURE_LIMITE_LEVEL_HIGHER,
+	DELETE_FAILURE_LIMITE_LEVEL_LOWER,
+	DELETE_FAILURE_REMAIN_TIME,
+	DELETE_FAILURE_GUILD_MEMBER,
+	DELETE_FAILURE_MARRIAGE,
+	DELETE_FAILURE_LAST_CHAR_SAFEBOX,
+	DELETE_FAILURE_ATTR67,
+	DELETE_FAILURE_PREMIUM_PRIVATE_SHOP,
+};
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+enum ERefineElementMisc
+{
+	REFINE_ELEMENT_MIN_REFINE_LEVEL = 7,
+
+	REFINE_ELEMENT_UPGRADE_YANG = 3000000,
+	REFINE_ELEMENT_DOWNGRADE_YANG = 10000000,
+	REFINE_ELEMENT_CHANGE_YANG = 10000000,
+
+	REFINE_ELEMENT_RANDOM_VALUE_MIN = 1,
+	REFINE_ELEMENT_RANDOM_VALUE_MAX = 8,
+
+	REFINE_ELEMENT_RANDOM_BONUS_VALUE_MIN = 2,
+	REFINE_ELEMENT_RANDOM_BONUS_VALUE_MAX = 12,
+};
+
+enum ERefineElementType
+{
+	REFINE_ELEMENT_UPGRADE,
+	REFINE_ELEMENT_DOWNGRADE,
+	REFINE_ELEMENT_CHANGE,
+};
+#endif
+
+enum EPartyLeaderShipRoleValue
+{
+	LEADERSHIP_ATTACKER_BASE_VALUE = 10,
+	LEADERSHIP_ATTACKER_ADJUSTMENT_VALUE = 50,
+	LEADERSHIP_TANKER_BASE_VALUE = 50,
+	LEADERSHIP_TANKER_ADJUSTMENT_VALUE = 1120,
+	LEADERSHIP_BUFFER_BASE_VALUE = 5,
+	LEADERSHIP_BUFFER_ADJUSTMENT_VALUE = 8,
+	LEADERSHIP_SKILL_MASTER_BASE_VALUE = 1,
+	LEADERSHIP_SKILL_MASTER_ADJUSTMENT_VALUE = 2,
+	LEADERSHIP_BERSERKER_BASE_VALUE = 1,
+	LEADERSHIP_BERSERKER_ADJUSTMENT_VALUE = 3,
+	LEADERSHIP_DEFENDER_BASE_VALUE = 1,
+	LEADERSHIP_DEFENDER_ADJUSTMENT_VALUE = 3,
+};
+
+#if defined(__PARTY_INSIGHT__)
+enum EPartyInSightValue
+{
+	INSIGHT_ATTACKER_BASE_VALUE = 2,
+	INSIGHT_ATTACKER_ADJUSTMENT_VALUE = 9,
+	INSIGHT_TANKER_BASE_VALUE = 10,
+	INSIGHT_TANKER_ADJUSTMENT_VALUE = 520,
+	INSIGHT_BUFFER_BASE_VALUE = 1,
+	INSIGHT_BUFFER_ADJUSTMENT_VALUE = 4,
+	INSIGHT_SKILL_MASTER_BASE_VALUE = 1,
+	INSIGHT_SKILL_MASTER_ADJUSTMENT_VALUE = 5,
+	INSIGHT_BERSERKER_BASE_VALUE = 1,
+	INSIGHT_BERSERKER_ADJUSTMENT_VALUE = 1,
+	INSIGHT_DEFENDER_BASE_VALUE = 1,
+	INSIGHT_DEFENDER_ADJUSTMENT_VALUE = 2,
+};
+#endif
+
+enum EMapIndex
+{
+	MAP_A1 = 1,
+	MAP_A3 = 3,
+	MAP_GUILD_01 = 4,
+	MAP_MONKEY_DUNGEON_11 = 5,
+	MAP_GUILD_VILLAGE_01 = 6,
+	MAP_B1 = 21,
+	MAP_B3 = 23,
+	MAP_GUILD_02 = 24,
+	MAP_MONKEY_DUNGEON_12 = 25,
+	MAP_GUILD_VILLAGE_02 = 26,
+	MAP_C1 = 41,
+	MAP_C3 = 43,
+	MAP_GUILD_03 = 44,
+	MAP_MONKEY_DUNGEON_13 = 45,
+	MAP_GUILD_VILLAGE_03 = 46,
+	MAP_N_SNOWM_01 = 61,
+	MAP_N_FLAME_01 = 62,
+	MAP_N_DESERT_01 = 63,
+	MAP_N_THREEWAY = 64,
+	MAP_MILGYO = 65,
+	MAP_DEVILTOWER1 = 66,
+	MAP_TRENT = 67,
+	MAP_TRENT02 = 68,
+	MAP_WL_01 = 69,
+	MAP_NUSLUCK01 = 70,
+	MAP_SPIDERDUNGEON_02 = 71,
+	MAP_SKIPIA_DUNGEON_01 = 72,
+	MAP_SKIPIA_DUNGEON_02 = 73,
+	MAP_WEDDING_01 = 81,
+	MAP_E1_01 = 91,
+	MAP_E1_02 = 92,
+	MAP_E1_03 = 93,
+	MAP_T1 = 103,
+	MAP_SPIDERDUNGEON = 104,
+	MAP_T2 = 105,
+	MAP_MONKEY_DUNGEON = 107,
+	MAP_MONKEY_DUNGEON2 = 108,
+	MAP_MONKEY_DUNGEON3 = 109,
+	MAP_T3 = 110,
+	MAP_T4 = 111,
+	MAP_DUEL = 112,
+	MAP_OXEVENT = 113,
+	MAP_SUNGZI = 114,
+	MAP_SUNGZI_FLAME_HILL_01 = 118,
+	MAP_SUNGZI_FLAME_HILL_02 = 119,
+	MAP_SUNGZI_FLAME_HILL_03 = 120,
+	MAP_SUNGZI_SNOW = 121,
+	MAP_SUNGZI_SNOW_PASS01 = 122,
+	MAP_SUNGZI_SNOW_PASS02 = 123,
+	MAP_SUNGZI_SNOW_PASS03 = 124,
+	MAP_SUNGZI_DESERT_01 = 125,
+	MAP_SUNGZI_DESERT_HILL_01 = 126,
+	MAP_SUNGZI_DESERT_HILL_02 = 127,
+	MAP_SUNGZI_DESERT_HILL_03 = 128,
+	MAP_GUILD_WAR1 = 130,
+	MAP_GUILD_WAR2 = 131,
+	MAP_GUILD_WAR3 = 132,
+	MAP_GUILD_WAR4 = 133,
+	MAP_EMPIREWAR01 = 181,
+	MAP_EMPIREWAR02 = 182,
+	MAP_EMPIREWAR03 = 183,
+	MAP_GM_GUILD_BUILD = 200,
+	MAP_PVP_ARENA = 201,
+	MAP_SKIPIA_DUNGEON_BOSS = 208,
+	MAP_DEVILSCATACOMB = 216,
+	MAP_SPIDERDUNGEON_03 = 217,
+	MAP_CAPEDRAGONHEAD = 301,
+	MAP_DAWNMISTWOOD = 302,
+	MAP_BAYBLACKSAND = 303,
+	MAP_MT_THUNDER = 304,
+	MAP_N_FLAME_DUNGEON_01 = 351,
+	MAP_N_SNOW_DUNGEON_01 = 352,
+	MAP_DAWNMIST_DUNGEON_01 = 353,
+	MAP_MT_TH_DUNGEON_01 = 354,
+	MAP_12ZI_STAGE = 355,
+	MAP_N_FLAME_DRAGON = 356,
+	MAP_BATTLEFIED = 357,
+	MAP_DEFENSEWAVE = 358,
+	MAP_DEFENSEWAVE_PORT = 359,
+	MAP_MISTS_OF_ISLAND = 360,
+	MAP_MINIBOSS_01 = 361,
+	MAP_MINIBOSS_02 = 362,
+	MAP_LABYRINTH = 363,
+	MAP_BOSS_CRACK_SKIPIA = 364,
+	MAP_BOSS_CRACK_FLAME = 365,
+	MAP_BOSS_CRACK_SNOW = 366,
+	MAP_BOSS_CRACK_DAWNMIST = 367,
+	MAP_BOSS_AWAKEN_SKIPIA = 368,
+	MAP_BOSS_AWAKEN_FLAME = 369,
+	MAP_BOSS_AWAKEN_SNOW = 370,
+	MAP_BOSS_AWAKEN_DAWNMIST = 371,
+	MAP_GUILD_PVE = 372,
+	MAP_EASTPLAIN_01 = 373,
+	MAP_EMPIRECASTLE = 374,
+	MAP_BATTLEROYALE = 375,
+	MAP_EASTPLAIN_02 = 376,
+	MAP_EASTPLAIN_03 = 377,
+	MAP_ELEMENTAL_01 = 378,
+	MAP_ELEMENTAL_02 = 379,
+	MAP_ELEMENTAL_03 = 380,
+	MAP_ELEMENTAL_04 = 381,
+	MAP_MAZE_DUNGEON1 = 382,
+	MAP_MAZE_DUNGEON2 = 383,
+	MAP_MAZE_DUNGEON3 = 384,
+	MAP_SNAKEVALLEY = 385,
+	MAP_SMHDUNGEON_01 = 386,
+	MAP_SMHDUNGEON_02 = 387,
+	MAP_ICECRYSTALCAVE = 388,
+	MAP_WHITDRAGONVALLEY = 389,
+	MAP_SNAKE_TEMPLE_01 = 390,
+	MAP_SNAKE_TEMPLE_02 = 391,
+	MAP_PRIVATESHOP = 392,
+	MAP_WHITEDRAGONCAVE_01 = 393,
+	MAP_WHITEDRAGONCAVE_02 = 394,
+	MAP_WHITEDRAGONCAVE_BOSS = 395,
+	MAP_ANGLAR_DUNGEON_01 = 396,
+	MAP_SECRETDUNGEON_01 = 399,
+	MAP_OTHERWORLD_01 = 400,
+	MAP_OTHERWORLD_02 = 401,
+	MAP_OTHERWORLD_03 = 402,
+	MAP_OTHERWORLD_04 = 403,
+};
+
+#if defined(__SOUL_BIND_SYSTEM__)
+enum ESealDate
+{
+	E_SEAL_DATE_DEFAULT_TIMESTAMP = 0, // Empty Seal Data
+	U_SEAL_DATE_DEFAULT_TIMESTAMP = -1, // Unlimited Seal Data
+	SEAL_DATE_MAX = 72, // 72 Days
+};
+#endif
+
+#if defined(__LEFT_SEAT__)
+enum ELeftSeat
+{
+	LEFT_SEAT_PULSE = 15,
+};
+
+enum ELeftSeatTime
+{
+	LEFT_SEAT_TIME_10_MIN,
+	LEFT_SEAT_TIME_30_MIN,
+	LEFT_SEAT_TIME_90_MIN,
+	LEFT_SEAT_TIME_MAX,
+};
+
+enum ELeftSeatLogoutTime
+{
+	LEFT_SEAT_LOGOUT_TIME_30_MIN,
+	LEFT_SEAT_LOGOUT_TIME_60_MIN,
+	LEFT_SEAT_LOGOUT_TIME_120_MIN,
+	LEFT_SEAT_LOGOUT_TIME_180_MIN,
+	LEFT_SEAT_LOGOUT_TIME_OFF,
+	LEFT_SEAT_LOGOUT_TIME_MAX,
+};
+#endif
+
+enum ESetCMD
+{
+	SET_CMD_GOLD,
+	SET_CMD_RACE,
+	SET_CMD_SEX,
+	SET_CMD_EXP,
+	SET_CMD_MAX_HP,
+	SET_CMD_MAX_SP,
+	SET_CMD_SKILL,
+	SET_CMD_ALIGN,
+#if defined(__CHEQUE_SYSTEM__)
+	SET_CMD_CHEQUE,
+#endif
+#if defined(__GEM_SYSTEM__)
+	SET_CMD_GEM,
+#endif
+#if defined(__EXPRESSING_EMOTIONS__)
+	SET_CMD_ACTION,
+#endif
+	SET_CMD_MAX_NUN
+};
+
+enum EDeadDialog
+{
+	DEAD_DIALOG_NONE,
+	DEAD_DIALOG_NORMAL,
+	DEAD_DIALOG_GIVE_UP,
+};
+
+#if defined(__FLOWER_EVENT__)
+enum EFlowerEventShootType
+{
+	SHOOT_ENVELOPE,
+	SHOOT_CHRYSANTHEMUM,
+	SHOOT_MAY_BELL,
+	SHOOT_DAFFODIL,
+	SHOOT_LILY,
+	SHOOT_SUNFLOWER,
+	SHOOT_TYPE_MAX,
+};
+
+enum EFlowerEventMisc
+{
+	FLOWER_EVENT_SHOOT_ENVELOPE_NEED_COUNT = 1,
+	FLOWER_EVENT_SHOOT_NEED_COUNT = 10,
+	FLOWER_EVENT_NEED_INVENTORY_SPACE = 1,
+	FLOWER_EVENT_EXCHANGE_COOLTIME_SEC = 1,
+	MAX_FLOWER_EVENT_ITEM_COUNT = 99999,
+};
+
+enum EFlowerEventChatType
+{
+	FLOWER_EVENT_CHAT_TYPE_NOT_ENOUGH_SHOOT_COUNT,
+	FLOWER_EVENT_CHAT_TYPE_NOT_ENOUGH_EVENTORY_SPACE,
+	FLOWER_EVENT_CHAT_TYPE_NOT_ENOUGH_SHOOT_ENVELOPE,
+	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_ENVELOPE,
+	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_CHRYSANTHEMUM,
+	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_MAY_BELL,
+	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_DAFFODIL,
+	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_LILY,
+	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_SUNFLOWER,
+	FLOWER_EVENT_CHAT_TYPE_ITEM_FULL_AND_NOT_USE,
+	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_CHRYSANTHEMUM_COUNT,
+	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_MAY_BELL_COUNT,
+	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_DAFFODIL_COUNT,
+	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_LILY_COUNT,
+	FLOWER_EVENT_CHAT_TYPE_GET_SHOOT_SUNFLOWER_COUNT,
+	FLOWER_EVENT_CHAT_TYPE_ENVELOPE_MAX,
+	FLOWER_EVENT_CHAT_TYPE_MAX,
+};
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+enum EExtBattlePassType
+{
+	BATTLEPASS_NORMAL,
+	BATTLEPASS_PREMIUM,
+	BATTLEPASS_EVENT,
+
+	BATTLEPASS_TYPE_MAX,
+};
+
+enum EExtBattleMissionPassType
+{
+	MISSION_TYPE_NONE,
+
+	KILL_MONSTER,
+	KILL_PLAYER,
+
+	DAMAGE_MONSTER,
+	DAMAGE_PLAYER,
+
+	BP_ITEM_USE,
+	BP_ITEM_SELL,
+	BP_ITEM_CRAFT,
+	BP_ITEM_REFINE,
+	BP_ITEM_DESTROY,
+	BP_ITEM_COLLECT,
+
+	FISH_FISHING,
+	FISH_GRILL,
+	FISH_CATCH,
+	
+	EXP_COLLECT,
+	YANG_COLLECT,
+	
+	GUILD_PLAY_GUILDWAR,
+	GUILD_SPENT_EXP,
+
+	GAYA_CRAFT_GAYA,
+	GAYA_BUY_ITEM_GAYA_COST,
+	
+	PET_ENCHANT,
+
+	COMPLETE_DUNGEON,
+	COMPLETE_MINIGAME,
+
+	MISSION_TYPE_MAX,
+};
+#endif
+
+#pragma pack(pop)
+#endif // __INC_COMMON_LENGTH_H__
diff --git a/server/server/home/metin2/Source/Server/common/tables.h b/server/server/home/metin2/Source/Server/common/tables.h
index 210b2a3..a6e61ad 100644
--- a/server/server/home/metin2/Source/Server/common/tables.h
+++ b/server/server/home/metin2/Source/Server/common/tables.h
@@ -1,2492 +1,2492 @@
-#ifndef __INC_COMMON_TABLES_H__
-#define __INC_COMMON_TABLES_H__
-
-#include "service.h"
-#include "length.h"
-
-#include <array>
-#include <utility>
-
-typedef DWORD IDENT;
-
-/**
-* @version 05/06/10 Bang2ni - Myshop Pricelist 관련 패킷 HEADER_XX_MYSHOP_PRICELIST_XXX 추가
-**/
-enum GD_HEADERS
-{
-	HEADER_GD_LOGIN = 1,
-	HEADER_GD_LOGOUT = 2,
-
-	HEADER_GD_PLAYER_LOAD = 3,
-	HEADER_GD_PLAYER_SAVE = 4,
-	HEADER_GD_PLAYER_CREATE = 5,
-	HEADER_GD_PLAYER_DELETE = 6,
-
-	HEADER_GD_LOGIN_KEY = 7,
-	//HEADER_GD_EMPTY = 8,
-	HEADER_GD_BOOT = 9,
-	HEADER_GD_PLAYER_COUNT = 10,
-	HEADER_GD_QUEST_SAVE = 11,
-	HEADER_GD_SAFEBOX_LOAD = 12,
-	HEADER_GD_SAFEBOX_SAVE = 13,
-	HEADER_GD_SAFEBOX_CHANGE_SIZE = 14,
-	HEADER_GD_EMPIRE_SELECT = 15,
-
-	HEADER_GD_SAFEBOX_CHANGE_PASSWORD = 16,
-	HEADER_GD_SAFEBOX_CHANGE_PASSWORD_SECOND = 17, // Not really a packet, used internal
-	HEADER_GD_DIRECT_ENTER = 18,
-
-	HEADER_GD_GUILD_SKILL_UPDATE = 19,
-	HEADER_GD_GUILD_EXP_UPDATE = 20,
-	HEADER_GD_GUILD_ADD_MEMBER = 21,
-	HEADER_GD_GUILD_REMOVE_MEMBER = 22,
-	HEADER_GD_GUILD_CHANGE_GRADE = 23,
-	HEADER_GD_GUILD_CHANGE_MEMBER_DATA = 24,
-	HEADER_GD_GUILD_DISBAND = 25,
-	HEADER_GD_GUILD_WAR = 26,
-	HEADER_GD_GUILD_WAR_SCORE = 27,
-	HEADER_GD_GUILD_CREATE = 28,
-
-	//HEADER_GD_EMPTY = 29,
-
-	HEADER_GD_ITEM_SAVE = 30,
-	HEADER_GD_ITEM_DESTROY = 31,
-
-	HEADER_GD_ADD_AFFECT = 32,
-	HEADER_GD_REMOVE_AFFECT = 33,
-
-	HEADER_GD_HIGHSCORE_REGISTER = 34,
-	HEADER_GD_ITEM_FLUSH = 35,
-
-	HEADER_GD_PARTY_CREATE = 36,
-	HEADER_GD_PARTY_DELETE = 37,
-	HEADER_GD_PARTY_ADD = 38,
-	HEADER_GD_PARTY_REMOVE = 39,
-	HEADER_GD_PARTY_STATE_CHANGE = 40,
-	HEADER_GD_PARTY_HEAL_USE = 41,
-
-	HEADER_GD_FLUSH_CACHE = 42,
-	HEADER_GD_RELOAD_PROTO = 43,
-
-	HEADER_GD_CHANGE_NAME = 44,
-	//HEADER_GD_EMPTY = 45,
-
-	HEADER_GD_GUILD_CHANGE_LADDER_POINT = 46,
-	HEADER_GD_GUILD_USE_SKILL = 47,
-
-	HEADER_GD_REQUEST_EMPIRE_PRIV = 48,
-	HEADER_GD_REQUEST_GUILD_PRIV = 49,
-
-	HEADER_GD_MONEY_LOG = 50,
-
-	HEADER_GD_GUILD_DEPOSIT_MONEY = 51,
-	HEADER_GD_GUILD_WITHDRAW_MONEY = 52,
-	HEADER_GD_GUILD_WITHDRAW_MONEY_GIVE_REPLY = 53,
-
-	HEADER_GD_REQUEST_CHARACTER_PRIV = 54,
-
-	HEADER_GD_SET_EVENT_FLAG = 55,
-
-	HEADER_GD_PARTY_SET_MEMBER_LEVEL = 56,
-
-	HEADER_GD_GUILD_WAR_BET = 57,
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	HEADER_GD_GUILD_EVENT_FLAG = 58,
-#endif
-	//HEADER_GD_EMPTY = 59,
-
-	HEADER_GD_CREATE_OBJECT = 60,
-	HEADER_GD_DELETE_OBJECT = 61,
-	HEADER_GD_UPDATE_LAND = 62,
-
-	//HEADER_GD_EMPTY = 63,
-	//HEADER_GD_EMPTY = 64,
-	//HEADER_GD_EMPTY = 65,
-	//HEADER_GD_EMPTY = 66,
-	//HEADER_GD_EMPTY = 67,
-	//HEADER_GD_EMPTY = 68,
-	//HEADER_GD_EMPTY = 69,
-
-	HEADER_GD_MARRIAGE_ADD = 70,
-	HEADER_GD_MARRIAGE_UPDATE = 71,
-	HEADER_GD_MARRIAGE_REMOVE = 72,
-
-	HEADER_GD_WEDDING_REQUEST = 73,
-	HEADER_GD_WEDDING_READY = 74,
-	HEADER_GD_WEDDING_END = 75,
-
-	//HEADER_GD_EMPTY = 76,
-	//HEADER_GD_EMPTY = 77,
-	//HEADER_GD_EMPTY = 78,
-	//HEADER_GD_EMPTY = 79,
-	//HEADER_GD_EMPTY = 80,
-	//HEADER_GD_EMPTY = 81,
-	//HEADER_GD_EMPTY = 82,
-	//HEADER_GD_EMPTY = 83,
-	//HEADER_GD_EMPTY = 84,
-	//HEADER_GD_EMPTY = 85,
-	//HEADER_GD_EMPTY = 86,
-	//HEADER_GD_EMPTY = 87,
-	//HEADER_GD_EMPTY = 88,
-	//HEADER_GD_EMPTY = 89,
-	//HEADER_GD_EMPTY = 90,
-	//HEADER_GD_EMPTY = 91,
-	//HEADER_GD_EMPTY = 92,
-	//HEADER_GD_EMPTY = 93,
-	//HEADER_GD_EMPTY = 94,
-	//HEADER_GD_EMPTY = 95,
-	//HEADER_GD_EMPTY = 96,
-	//HEADER_GD_EMPTY = 97,
-	//HEADER_GD_EMPTY = 98,
-	//HEADER_GD_EMPTY = 99,
-
-	HEADER_GD_AUTH_LOGIN = 100,
-	HEADER_GD_LOGIN_BY_KEY = 101,
-	//HEADER_GD_EMPTY = 102,
-	//HEADER_GD_EMPTY = 103,
-	//HEADER_GD_EMPTY = 104,
-	//HEADER_GD_EMPTY = 105,
-	//HEADER_GD_EMPTY = 106,
-	HEADER_GD_MALL_LOAD = 107,
-
-	HEADER_GD_MYSHOP_PRICELIST_UPDATE = 108, /// < 가격정보 갱신 요청
-	HEADER_GD_MYSHOP_PRICELIST_REQ = 109, /// < 가격정보 리스트 요청
-
-	HEADER_GD_BLOCK_CHAT = 110,
-
-	// PCBANG_IP_LIST_BY_AUTH
-	HEADER_GD_PCBANG_REQUEST_IP_LIST = 111,
-	HEADER_GD_PCBANG_CLEAR_IP_LIST = 112,
-	HEADER_GD_PCBANG_INSERT_IP = 113,
-	// END_OF_PCBANG_IP_LIST_BY_AUTH
-
-	HEADER_GD_HAMMER_OF_TOR = 114,
-	HEADER_GD_RELOAD_ADMIN = 115, /// < 운영자 정보 요청
-	HEADER_GD_BREAK_MARRIAGE = 116, /// < 결혼 파기
-	HEADER_GD_ELECT_MONARCH = 117, /// < 군주 투표
-	HEADER_GD_CANDIDACY = 118, /// < 군주 등록
-	HEADER_GD_ADD_MONARCH_MONEY = 119, /// < 군주 돈 증가
-	HEADER_GD_TAKE_MONARCH_MONEY = 120, /// < 군주 돈 감소
-	HEADER_GD_COME_TO_VOTE = 121, /// < 표결
-	HEADER_GD_RMCANDIDACY = 122, /// < 후보 제거 (운영자)
-	HEADER_GD_SETMONARCH = 123, /// <군주설정 (운영자)
-	HEADER_GD_RMMONARCH = 124, /// <군주삭제
-	HEADER_GD_DEC_MONARCH_MONEY = 125,
-
-	HEADER_GD_CHANGE_MONARCH_LORD = 126,
-	HEADER_GD_BLOCK_COUNTRY_IP = 127, // 광대역 IP-Block
-	HEADER_GD_BLOCK_EXCEPTION = 128, // 광대역 IP-Block 예외
-
-	HEADER_GD_REQ_CHANGE_GUILD_MASTER = 129,
-
-	HEADER_GD_REQ_SPARE_ITEM_ID_RANGE = 130,
-
-	HEADER_GD_UPDATE_HORSE_NAME = 131,
-	HEADER_GD_REQ_HORSE_NAME = 132,
-
-	HEADER_GD_DC = 133, // Login Key를 지움
-
-	HEADER_GD_VALID_LOGOUT = 134,
-
-	//HEADER_GD_EMPTY = 135,
-	//HEADER_GD_EMPTY = 136,
-
-	HEADER_GD_REQUEST_CHARGE_CASH = 137,
-
-	HEADER_GD_DELETE_AWARDID = 138, // delete gift notify icon
-
-	HEADER_GD_UPDATE_CHANNELSTATUS = 139,
-	HEADER_GD_REQUEST_CHANNELSTATUS = 140,
-
-	//HEADER_GD_EMPTY = 142,
-	//HEADER_GD_EMPTY = 143,
-
-#if defined(__MOVE_CHANNEL__)
-	HEADER_GD_FIND_CHANNEL = 144,
-#endif
-
-	//HEADER_GD_EMPTY = 145,
-	//HEADER_GD_EMPTY = 146,
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	HEADER_GD_SAVE_EXT_BATTLE_PASS = 147,
-#endif
-
-	//HEADER_GD_EMPTY = 148,
-	//HEADER_GD_EMPTY = 149,
-#if defined(__MAILBOX__)
-	HEADER_GD_MAILBOX_LOAD = 150,
-	HEADER_GD_MAILBOX_CHECK_NAME = 151,
-	HEADER_GD_MAILBOX_WRITE = 152,
-	HEADER_GD_MAILBOX_DELETE = 153,
-	HEADER_GD_MAILBOX_CONFIRM = 154,
-	HEADER_GD_MAILBOX_GET = 155,
-	HEADER_GD_MAILBOX_UNREAD = 156,
-#endif
-	//HEADER_GD_EMPTY = 157,
-	//HEADER_GD_EMPTY = 158,
-	//HEADER_GD_EMPTY = 159,
-#if defined(__GEM_SHOP__)
-	HEADER_GD_GEM_SHOP_LOAD = 160,
-	HEADER_GD_GEM_SHOP_UPDATE = 161,
-#endif
-	//HEADER_GD_EMPTY = 162,
-
-#ifdef __GROWTH_PET_SYSTEM__
-	HEADER_GD_GROWTH_PET_SAVE = 163,
-	HEADER_GD_GROWTH_PET_DELETE = 164,
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	HEADER_GD_EMOTE_LOAD = 165,
-	HEADER_GD_EMOTE_CLEAR = 166,
-	HEADER_GD_EMOTE_ADD = 167,
-#endif
-
-#ifdef __SHOP_SEARCH__
-	HEADER_GD_SHOP_SEARCH_REGISTER_ITEM = 172,
-	HEADER_GD_SHOP_SEARCH_UNREGISTER_ITEM = 173,
-	HEADER_GD_SHOP_SEARCH_SOLD_ITEM = 174,
-	HEADER_GD_SHOP_SEARCH_BY_NAME = 175,
-	HEADER_GD_SHOP_SEARCH_BY_OPTIONS = 176,
-	HEADER_GD_SHOP_SEARCH_REQUEST_BUY = 177,
-	HEADER_GD_SHOP_SEARCH_BUY_FROM_SHOP_ERROR = 178,
-	HEADER_GD_SHOP_SEARCH_BOUGHT_FROM_SHOP = 179,
-	HEADER_GD_SHOP_SEARCH_REQUEST_SOLD_INFO = 180,
-	HEADER_GD_SHOP_SEARCH_RELOAD_AVERAGE = 181,
-#endif
-	//HEADER_GD_EMPTY = 182,
-	//HEADER_GD_EMPTY = 183,
-	//HEADER_GD_EMPTY = 184,
-	//HEADER_GD_EMPTY = 185,
-	//HEADER_GD_EMPTY = 186,
-	//HEADER_GD_EMPTY = 187,
-	//HEADER_GD_EMPTY = 188,
-	//HEADER_GD_EMPTY = 189,
-	//HEADER_GD_EMPTY = 190,
-	//HEADER_GD_EMPTY = 191,
-	//HEADER_GD_EMPTY = 192,
-	//HEADER_GD_EMPTY = 193,
-	//HEADER_GD_EMPTY = 194,
-	//HEADER_GD_EMPTY = 195,
-	//HEADER_GD_EMPTY = 196,
-	//HEADER_GD_EMPTY = 197,
-	//HEADER_GD_EMPTY = 198,
-	//HEADER_GD_EMPTY = 199,
-	//HEADER_GD_EMPTY = 200,
-	//HEADER_GD_EMPTY = 201,
-	//HEADER_GD_EMPTY = 202,
-	//HEADER_GD_EMPTY = 203,
-	//HEADER_GD_EMPTY = 204,
-	//HEADER_GD_EMPTY = 205,
-	//HEADER_GD_EMPTY = 206,
-	//HEADER_GD_EMPTY = 207,
-	//HEADER_GD_EMPTY = 208,
-	//HEADER_GD_EMPTY = 209,
-	//HEADER_GD_EMPTY = 210,
-	//HEADER_GD_EMPTY = 211,
-	//HEADER_GD_EMPTY = 212,
-	//HEADER_GD_EMPTY = 213,
-	//HEADER_GD_EMPTY = 214,
-	//HEADER_GD_EMPTY = 215,
-	//HEADER_GD_EMPTY = 216,
-	//HEADER_GD_EMPTY = 217,
-	//HEADER_GD_EMPTY = 218,
-	//HEADER_GD_EMPTY = 219,
-	//HEADER_GD_EMPTY = 220,
-	//HEADER_GD_EMPTY = 221,
-	//HEADER_GD_EMPTY = 222,
-	//HEADER_GD_EMPTY = 223,
-	//HEADER_GD_EMPTY = 224,
-	//HEADER_GD_EMPTY = 225,
-	//HEADER_GD_EMPTY = 226,
-	//HEADER_GD_EMPTY = 227,
-	//HEADER_GD_EMPTY = 228,
-	//HEADER_GD_EMPTY = 229,
-	//HEADER_GD_EMPTY = 230,
-	//HEADER_GD_EMPTY = 231,
-	//HEADER_GD_EMPTY = 232,
-	//HEADER_GD_EMPTY = 233,
-	//HEADER_GD_EMPTY = 234,
-	//HEADER_GD_EMPTY = 235,
-	//HEADER_GD_EMPTY = 236,
-	//HEADER_GD_EMPTY = 237,
-	//HEADER_GD_EMPTY = 238,
-	//HEADER_GD_EMPTY = 239,
-	//HEADER_GD_EMPTY = 240,
-	//HEADER_GD_EMPTY = 241,
-	//HEADER_GD_EMPTY = 242,
-
-#ifdef __OFFLINE_SHOP__
-	HEADER_GD_REQUEST_OFFLINE_SHOP_ID = 243,
-	HEADER_GD_OFFLINE_SHOP_SAVE = 244,
-	HEADER_GD_OFFLINE_SHOP_SAVE_ITEM = 245,
-	HEADER_GD_OFFLINE_SHOP_DESTROY = 246,
-#endif
-
-	//HEADER_GD_EMPTY = 247,
-	//HEADER_GD_EMPTY = 248,
-	//HEADER_GD_EMPTY = 249,
-	//HEADER_GD_EMPTY = 250,
-	//HEADER_GD_EMPTY = 251,
-	//HEADER_GD_EMPTY = 252,
-	//HEADER_GD_EMPTY = 253,
-	//HEADER_GD_EMPTY = 254,
-	HEADER_GD_SETUP = 0xff, // 255
-};
-
-enum DG_HEADERS
-{
-	HEADER_DG_NOTICE = 1,
-	//HEADER_DG_EMPTY = 2,
-	//HEADER_DG_EMPTY = 3,
-	//HEADER_DG_EMPTY = 4,
-	//HEADER_DG_EMPTY = 5,
-	//HEADER_DG_EMPTY = 6,
-	//HEADER_DG_EMPTY = 7,
-	//HEADER_DG_EMPTY = 8,
-	//HEADER_DG_EMPTY = 9,
-	//HEADER_DG_EMPTY = 10,
-	//HEADER_DG_EMPTY = 11,
-	//HEADER_DG_EMPTY = 12,
-	//HEADER_DG_EMPTY = 13,
-	//HEADER_DG_EMPTY = 14,
-	//HEADER_DG_EMPTY = 15,
-	//HEADER_DG_EMPTY = 16,
-	//HEADER_DG_EMPTY = 17,
-	//HEADER_DG_EMPTY = 18,
-	//HEADER_DG_EMPTY = 19,
-	//HEADER_DG_EMPTY = 20,
-	//HEADER_DG_EMPTY = 21,
-	//HEADER_DG_EMPTY = 22,
-	//HEADER_DG_EMPTY = 23,
-	//HEADER_DG_EMPTY = 24,
-	//HEADER_DG_EMPTY = 25,
-	//HEADER_DG_EMPTY = 26,
-	//HEADER_DG_EMPTY = 27,
-	//HEADER_DG_EMPTY = 28,
-	//HEADER_DG_EMPTY = 29,
-	HEADER_DG_LOGIN_SUCCESS = 30,
-	HEADER_DG_LOGIN_NOT_EXIST = 31,
-	//HEADER_DG_EMPTY = 32,
-	HEADER_DG_LOGIN_WRONG_PASSWD = 33,
-	HEADER_DG_LOGIN_ALREADY = 34,
-
-	HEADER_DG_PLAYER_LOAD_SUCCESS = 35,
-	HEADER_DG_PLAYER_LOAD_FAILED = 36,
-	HEADER_DG_PLAYER_CREATE_SUCCESS = 37,
-	HEADER_DG_PLAYER_CREATE_ALREADY = 38,
-	HEADER_DG_PLAYER_CREATE_FAILED = 39,
-	HEADER_DG_PLAYER_DELETE_SUCCESS = 40,
-	HEADER_DG_PLAYER_DELETE_FAILED = 41,
-
-	HEADER_DG_ITEM_LOAD = 42,
-
-	HEADER_DG_BOOT = 43,
-	HEADER_DG_QUEST_LOAD = 44,
-
-	HEADER_DG_SAFEBOX_LOAD = 45,
-	HEADER_DG_SAFEBOX_CHANGE_SIZE = 46,
-	HEADER_DG_SAFEBOX_WRONG_PASSWORD = 47,
-	HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER = 48,
-
-	HEADER_DG_EMPIRE_SELECT = 49,
-
-	HEADER_DG_AFFECT_LOAD = 50,
-	HEADER_DG_MALL_LOAD = 51,
-
-	//HEADER_DG_EMPTY = 52,
-	//HEADER_DG_EMPTY = 53,
-	//HEADER_DG_EMPTY = 54,
-
-	HEADER_DG_DIRECT_ENTER = 55,
-
-	HEADER_DG_GUILD_SKILL_UPDATE = 56,
-	HEADER_DG_GUILD_SKILL_RECHARGE = 57,
-	HEADER_DG_GUILD_EXP_UPDATE = 58,
-
-	HEADER_DG_PARTY_CREATE = 59,
-	HEADER_DG_PARTY_DELETE = 60,
-	HEADER_DG_PARTY_ADD = 61,
-	HEADER_DG_PARTY_REMOVE = 62,
-	HEADER_DG_PARTY_STATE_CHANGE = 63,
-	HEADER_DG_PARTY_HEAL_USE = 64,
-	HEADER_DG_PARTY_SET_MEMBER_LEVEL = 65,
-
-	//HEADER_DG_EMPTY = 66,
-	//HEADER_DG_EMPTY = 67,
-	//HEADER_DG_EMPTY = 68,
-	//HEADER_DG_EMPTY = 69,
-	//HEADER_DG_EMPTY = 70,
-	//HEADER_DG_EMPTY = 71,
-	//HEADER_DG_EMPTY = 72,
-	//HEADER_DG_EMPTY = 73,
-	//HEADER_DG_EMPTY = 74,
-	//HEADER_DG_EMPTY = 75,
-	//HEADER_DG_EMPTY = 76,
-	//HEADER_DG_EMPTY = 77,
-	//HEADER_DG_EMPTY = 78,
-	//HEADER_DG_EMPTY = 79,
-	//HEADER_DG_EMPTY = 80,
-	//HEADER_DG_EMPTY = 81,
-	//HEADER_DG_EMPTY = 82,
-	//HEADER_DG_EMPTY = 83,
-	//HEADER_DG_EMPTY = 84,
-	//HEADER_DG_EMPTY = 85,
-	//HEADER_DG_EMPTY = 86,
-	//HEADER_DG_EMPTY = 87,
-	//HEADER_DG_EMPTY = 88,
-	//HEADER_DG_EMPTY = 89,
-
-	HEADER_DG_TIME = 90,
-	HEADER_DG_ITEM_ID_RANGE = 91,
-
-	HEADER_DG_GUILD_ADD_MEMBER = 92,
-	HEADER_DG_GUILD_REMOVE_MEMBER = 93,
-	HEADER_DG_GUILD_CHANGE_GRADE = 94,
-	HEADER_DG_GUILD_CHANGE_MEMBER_DATA = 95,
-	HEADER_DG_GUILD_DISBAND = 96,
-	HEADER_DG_GUILD_WAR = 97,
-	HEADER_DG_GUILD_WAR_SCORE = 98,
-	HEADER_DG_GUILD_TIME_UPDATE = 99,
-	HEADER_DG_GUILD_LOAD = 100,
-	HEADER_DG_GUILD_LADDER = 101,
-	HEADER_DG_GUILD_SKILL_USABLE_CHANGE = 102,
-	HEADER_DG_GUILD_MONEY_CHANGE = 103,
-	HEADER_DG_GUILD_WITHDRAW_MONEY_GIVE = 104,
-
-	HEADER_DG_SET_EVENT_FLAG = 105,
-
-	HEADER_DG_GUILD_WAR_RESERVE_ADD = 106,
-	HEADER_DG_GUILD_WAR_RESERVE_DEL = 107,
-	HEADER_DG_GUILD_WAR_BET = 108,
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	HEADER_DG_GUILD_EVENT_FLAG = 109,
-#endif
-	//HEADER_DG_EMPTY = 110,
-	//HEADER_DG_EMPTY = 111,
-	//HEADER_DG_EMPTY = 112,
-	//HEADER_DG_EMPTY = 113,
-	//HEADER_DG_EMPTY = 114,
-	//HEADER_DG_EMPTY = 115,
-	//HEADER_DG_EMPTY = 116,
-	//HEADER_DG_EMPTY = 117,
-	//HEADER_DG_EMPTY = 118,
-	//HEADER_DG_EMPTY = 119,
-	HEADER_DG_RELOAD_PROTO = 120,
-	HEADER_DG_CHANGE_NAME = 121,
-
-	HEADER_DG_AUTH_LOGIN = 122,
-	//HEADER_DG_EMPTY = 123,
-	HEADER_DG_CHANGE_EMPIRE_PRIV = 124,
-	HEADER_DG_CHANGE_GUILD_PRIV = 125,
-
-	HEADER_DG_MONEY_LOG = 126,
-
-	HEADER_DG_CHANGE_CHARACTER_PRIV = 127,
-
-	//HEADER_DG_EMPTY = 128,
-	//HEADER_DG_EMPTY = 129,
-	//HEADER_DG_EMPTY = 130,
-	//HEADER_DG_EMPTY = 131,
-	//HEADER_DG_EMPTY = 132,
-	//HEADER_DG_EMPTY = 133,
-	//HEADER_DG_EMPTY = 134,
-	//HEADER_DG_EMPTY = 135,
-	//HEADER_DG_EMPTY = 136,
-	//HEADER_DG_EMPTY = 137,
-	//HEADER_DG_EMPTY = 138,
-	//HEADER_DG_EMPTY = 139,
-	HEADER_DG_CREATE_OBJECT = 140,
-	HEADER_DG_DELETE_OBJECT = 141,
-	HEADER_DG_UPDATE_LAND = 142,
-	//HEADER_DG_EMPTY = 143,
-	//HEADER_DG_EMPTY = 144,
-	//HEADER_DG_EMPTY = 145,
-	//HEADER_DG_EMPTY = 146,
-	//HEADER_DG_EMPTY = 147,
-	//HEADER_DG_EMPTY = 148,
-	//HEADER_DG_EMPTY = 149,
-	HEADER_DG_MARRIAGE_ADD = 150,
-	HEADER_DG_MARRIAGE_UPDATE = 151,
-	HEADER_DG_MARRIAGE_REMOVE = 152,
-
-	HEADER_DG_WEDDING_REQUEST = 153,
-	HEADER_DG_WEDDING_READY = 154,
-	HEADER_DG_WEDDING_START = 155,
-	HEADER_DG_WEDDING_END = 156,
-
-	HEADER_DG_MYSHOP_PRICELIST_RES = 157, /// < 가격정보 리스트 응답
-	HEADER_DG_RELOAD_ADMIN = 158, /// < 운영자 정보 리로드
-	HEADER_DG_BREAK_MARRIAGE = 159, /// < 결혼 파기
-	HEADER_DG_ELECT_MONARCH = 160, /// < 군주 투표
-	HEADER_DG_CANDIDACY = 161, /// < 군주 등록
-	HEADER_DG_ADD_MONARCH_MONEY = 162, /// < 군주 돈 증가
-	HEADER_DG_TAKE_MONARCH_MONEY = 163, /// < 군주 돈 감소
-	HEADER_DG_COME_TO_VOTE = 164, /// < 표결
-	HEADER_DG_RMCANDIDACY = 165, /// < 후보 제거 (운영자)
-	HEADER_DG_SETMONARCH = 166, /// < 군주설정 (운영자)
-	HEADER_DG_RMMONARCH = 167, /// < 군주삭제
-	HEADER_DG_DEC_MONARCH_MONEY = 168,
-
-	HEADER_DG_CHANGE_MONARCH_LORD_ACK = 169,
-	HEADER_DG_UPDATE_MONARCH_INFO = 170,
-	HEADER_DG_BLOCK_COUNTRY_IP = 171, // 광대역 IP-Block
-	HEADER_DG_BLOCK_EXCEPTION = 172, // 광대역 IP-Block 예외 account
-
-	HEADER_DG_ACK_CHANGE_GUILD_MASTER = 173,
-
-	HEADER_DG_ACK_SPARE_ITEM_ID_RANGE = 174,
-
-	HEADER_DG_UPDATE_HORSE_NAME = 175,
-	HEADER_DG_ACK_HORSE_NAME = 176,
-
-	HEADER_DG_NEED_LOGIN_LOG = 177,
-
-	HEADER_DG_RESULT_CHARGE_CASH = 179,
-	HEADER_DG_ITEMAWARD_INFORMER = 180, // gift notify
-	HEADER_DG_RESPOND_CHANNELSTATUS = 181,
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	HEADER_DG_EMOTE_LOAD = 182,
-	HEADER_DG_EMOTE_GET = 183,
-#endif
-#if defined(__MOVE_CHANNEL__)
-	HEADER_DG_CHANNEL_RESULT = 185,
-#endif
-	//HEADER_DG_EMPTY = 186,
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	HEADER_DG_EXT_BATTLE_PASS_LOAD = 187,
-#endif
-
-	//HEADER_DG_EMPTY = 188,
-	//HEADER_DG_EMPTY = 189,
-#if defined(__MAILBOX__)
-	HEADER_DG_RESPOND_MAILBOX_LOAD = 190,
-	HEADER_DG_RESPOND_MAILBOX_CHECK_NAME = 191,
-	HEADER_DG_RESPOND_MAILBOX_UNREAD = 192,
-#endif
-	//HEADER_DG_EMPTY = 193,
-	//HEADER_DG_EMPTY = 194,
-
-#ifdef __GROWTH_PET_SYSTEM__
-	HEADER_DG_GROWTH_PET_LOAD = 195,
-#endif
-
-#if defined(__GEM_SHOP__)
-	HEADER_DG_GEM_SHOP_LOAD = 196,
-	HEADER_DG_GEM_SHOP_UPDATE = 197,
-#endif
-	//HEADER_DG_EMPTY = 198,
-#ifdef __SHOP_SEARCH__
-	HEADER_DG_SHOP_SEARCH_RESULT = 199,
-	HEADER_DG_SHOP_SEARCH_BUY_RESULT = 200,
-	HEADER_DG_SHOP_SEARCH_BUY_FROM_SHOP = 201,
-	HEADER_DG_SHOP_SEARCH_SOLD_INFO = 202,
-#endif
-
-	//HEADER_DG_EMPTY = 204,
-	//HEADER_DG_EMPTY = 205,
-	//HEADER_DG_EMPTY = 206,
-	//HEADER_DG_EMPTY = 207,
-	//HEADER_DG_EMPTY = 208,
-	//HEADER_DG_EMPTY = 209,
-	//HEADER_DG_EMPTY = 210,
-	//HEADER_DG_EMPTY = 211,
-	//HEADER_DG_EMPTY = 212,
-	//HEADER_DG_EMPTY = 213,
-	//HEADER_DG_EMPTY = 214,
-	//HEADER_DG_EMPTY = 215,
-	//HEADER_DG_EMPTY = 216,
-	//HEADER_DG_EMPTY = 217,
-	//HEADER_DG_EMPTY = 218,
-	//HEADER_DG_EMPTY = 219,
-	//HEADER_DG_EMPTY = 220,
-	//HEADER_DG_EMPTY = 221,
-	//HEADER_DG_EMPTY = 222,
-	//HEADER_DG_EMPTY = 223,
-	//HEADER_DG_EMPTY = 224,
-	//HEADER_DG_EMPTY = 225,
-	//HEADER_DG_EMPTY = 226,
-	//HEADER_DG_EMPTY = 227,
-	//HEADER_DG_EMPTY = 228,
-	//HEADER_DG_EMPTY = 229,
-	//HEADER_DG_EMPTY = 230,
-	//HEADER_DG_EMPTY = 231,
-	//HEADER_DG_EMPTY = 232,
-	//HEADER_DG_EMPTY = 233,
-	//HEADER_DG_EMPTY = 234,
-	//HEADER_DG_EMPTY = 235,
-	//HEADER_DG_EMPTY = 236,
-	//HEADER_DG_EMPTY = 237,
-	//HEADER_DG_EMPTY = 238,
-	//HEADER_DG_EMPTY = 239,
-	//HEADER_DG_EMPTY = 240,
-	//HEADER_DG_EMPTY = 241,
-	//HEADER_DG_EMPTY = 242,
-	//HEADER_DG_EMPTY = 243,
-	//HEADER_DG_EMPTY = 244,
-	//HEADER_DG_EMPTY = 245,
-	//HEADER_DG_EMPTY = 246,
-	//HEADER_DG_EMPTY = 247,
-	//HEADER_DG_EMPTY = 248,
-	//HEADER_DG_EMPTY = 249,
-
-#ifdef __OFFLINE_SHOP__
-	HEADER_DG_RESPOND_OFFLINE_SHOP_ID = 250,
-#endif
-
-	//HEADER_DG_EMPTY = 251,
-	//HEADER_DG_EMPTY = 252,
-	//HEADER_DG_EMPTY = 253,
-	HEADER_DG_MAP_LOCATIONS = 0xfe, // 254
-	HEADER_DG_P2P = 0xff, // 255
-};
-
-/* game Server -> DB Server */
-#pragma pack(1)
-enum ERequestChargeType
-{
-	ERequestCharge_Cash = 0,
-	ERequestCharge_Mileage,
-};
-
-typedef struct SRequestChargeCash
-{
-	DWORD dwAID; // id(primary key) - Account Table
-	DWORD dwAmount;
-	ERequestChargeType eChargeType;
-
-} TRequestChargeCash;
-
-typedef struct SSimplePlayer
-{
-	DWORD dwID;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	BYTE byJob;
-	BYTE byLevel;
-	DWORD dwPlayMinutes;
-	BYTE byST, byHT, byDX, byIQ;
-	DWORD dwMainPart;
-	BYTE bChangeName;
-	DWORD dwHairPart;
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	DWORD dwAccePart;
-#endif
-	BYTE bDummy[4];
-	long x, y;
-	long lAddr;
-	WORD wPort;
-	BYTE skill_group;
-	DWORD last_play;
-#if defined(__CONQUEROR_LEVEL__)
-	BYTE byConquerorLevel;
-	BYTE bySungmaStr, bySungmaHp, bySungmaMove, bySungmaImmune;
-#endif
-} TSimplePlayer;
-
-typedef struct SAccountTable
-{
-	DWORD id;
-	char login[LOGIN_MAX_LEN + 1];
-	char passwd[PASSWD_MAX_LEN + 1];
-	char social_id[SOCIAL_ID_MAX_LEN + 1];
-	char status[ACCOUNT_STATUS_MAX_LEN + 1];
-	BYTE bEmpire;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char country[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-	TSimplePlayer players[PLAYER_PER_ACCOUNT];
-} TAccountTable;
-
-typedef struct SPacketDGCreateSuccess
-{
-	BYTE bAccountCharacterIndex;
-	TSimplePlayer player;
-} TPacketDGCreateSuccess;
-
-typedef struct SPlayerItemAttribute
-{
-	POINT_TYPE wType;
-	POINT_VALUE lValue;
-#if defined(__ITEM_APPLY_RANDOM__)
-	BYTE bPath;
-#endif
-} TPlayerItemAttribute;
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-typedef struct SPlayerItemRefineElement
-{
-	WORD wApplyType;
-	BYTE bGrade;
-	BYTE abValue[REFINE_ELEMENT_MAX];
-	BYTE abBonusValue[REFINE_ELEMENT_MAX];
-	SPlayerItemRefineElement()
-	{
-		wApplyType = 0;
-		bGrade = 0;
-		memset(&abValue, 0, sizeof(abValue));
-		memset(&abBonusValue, 0, sizeof(abBonusValue));
-	}
-} TPlayerItemRefineElement;
-#endif
-
-typedef struct SPlayerItem
-{
-	DWORD dwID;
-	DWORD dwOwner;
-
-	BYTE bWindow;
-	WORD wPos;
-
-	DWORD dwVnum;
-	DWORD dwCount;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	long lSealDate;
-#endif
-
-	long alSockets[ITEM_SOCKET_MAX_NUM]; // 소켓번호
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-} TPlayerItem;
-
-typedef struct packet_item
-{
-	DWORD dwVnum;
-	DWORD dwCount;
-	DWORD dwFlags;
-	DWORD dwAntiFlags;
-#if defined(__SOUL_BIND_SYSTEM__)
-	long lSealDate;
-#endif
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-	packet_item()
-	{
-		memset(&alSockets, 0, sizeof(alSockets));
-		memset(&aAttr, 0, sizeof(aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		dwTransmutationVnum = 0;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		memset(&RefineElement, 0, sizeof(RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-		memset(&aApplyRandom, 0, sizeof(aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-		bSetValue = 0;
-#endif
-	}
-} TItemData;
-
-typedef struct SQuickslot
-{
-	BYTE type;
-	WORD pos;
-} TQuickslot;
-
-typedef struct SPlayerSkill
-{
-	BYTE bMasterType;
-	BYTE bLevel;
-	time_t tNextRead;
-} TPlayerSkill;
-
-typedef struct SHorseInfo
-{
-	BYTE bLevel;
-	BYTE bRiding;
-	short sStamina;
-	short sHealth;
-	DWORD dwHorseHealthDropTime;
-} THorseInfo;
-
-typedef struct SPlayerTable
-{
-	DWORD id;
-
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	char ip[IP_ADDRESS_LENGTH + 1];
-
-	WORD job;
-	BYTE voice;
-
-	BYTE level;
-	BYTE level_step;
-	short st, ht, dx, iq;
-
-	DWORD exp;
-	int gold;
-#if defined(__CHEQUE_SYSTEM__)
-	int cheque;
-#endif
-#if defined(__GEM_SYSTEM__)
-	int gem;
-#endif
-
-	BYTE dir;
-	INT x, y, z;
-	INT lMapIndex;
-
-	long lExitX, lExitY;
-	long lExitMapIndex;
-
-	int hp;
-	int sp;
-
-	short sRandomHP;
-	short sRandomSP;
-
-	int playtime;
-
-	short stat_point;
-	short skill_point;
-	short sub_skill_point;
-	short horse_skill_point;
-
-	TPlayerSkill skills[SKILL_MAX_NUM];
-
-	TQuickslot quickslot[QUICKSLOT_MAX_NUM];
-
-	BYTE part_base;
-	DWORD adwParts[PART_MAX_NUM];
-
-	short stamina;
-
-	BYTE skill_group;
-	long lAlignment;
-
-	short stat_reset_count;
-
-	THorseInfo horse;
-
-	DWORD logoff_interval;
-	DWORD last_play;
-
-	int aiPremiumTimes[PREMIUM_MAX_NUM];
-
-#if defined(__CONQUEROR_LEVEL__)
-	BYTE conqueror_level;
-	BYTE conqueror_level_step;
-	short sungma_str, sungma_hp, sungma_move, sungma_immune;
-	DWORD conqueror_exp;
-	short conqueror_point;
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	BYTE inven_stage;
-#endif
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	int battle_pass_premium_id;
-#endif
-} TPlayerTable;
-
-#ifdef __GROWTH_PET_SYSTEM__
-typedef struct SPetSkill
-{
-	bool	bLocked;
-	BYTE	bSkill;
-	BYTE	bLevel;
-	DWORD	dwCooltime;
-
-	SPetSkill()
-	{
-		bLocked = true;
-		bSkill = 0;
-		bLevel = 0;
-		dwCooltime = 0;
-	}
-} TPetSkill;
-
-typedef struct SGrowthPet
-{
-	DWORD	dwID;
-	DWORD	dwOwner;
-	DWORD	dwVnum;
-	BYTE	bState;
-	char	szName[PET_NAME_MAX_SIZE + 1];
-	BYTE	bSize;
-
-	DWORD	dwLevel;
-	BYTE	bLevelStep;
-	BYTE	bEvolution;
-	BYTE	bType;
-	DWORD	dwHP;
-	DWORD	dwSP;
-	DWORD	dwDef;
-
-	DWORD	dwHPApply;
-	DWORD	dwSPApply;
-	DWORD	dwDefApply;
-	DWORD	dwAgeApply;
-
-	TPetSkill	aSkill[PET_SKILL_COUNT_MAX];
-
-	DWORD	lExp;
-	DWORD	lItemExp;
-
-	time_t	lBirthday;
-	time_t	lEndTime;
-	time_t	lMaxTime;
-} TGrowthPet;
-
-typedef struct SGrowthPetSkillTable
-{
-	DWORD	dwPetVnum;
-	DWORD	dwSkillVnum;
-	char	szName[32 + 1];
-	BYTE	bType;
-	DWORD	dwCooldown;
-	DWORD	dwAffectFlag;
-
-	char	szPointOn[64];
-	char	szPointPoly1[100 + 1];
-	char	szPointPoly2[100 + 1];
-	char	szPointPoly3[100 + 1];
-	char	szPointPoly4[100 + 1];
-	char	szPointPoly5[100 + 1];
-	char	szPointPoly6[100 + 1];
-	char	szPointPoly7[100 + 1];
-	char	szPointPoly8[100 + 1];
-	char	szActivatePctPoly[100 + 1];
-	char	szDurationPoly[100 + 1];
-} TGrowthPetSkillTable;
-#endif
-
-typedef struct SMobSkillLevel
-{
-	DWORD dwVnum;
-	BYTE bLevel;
-} TMobSkillLevel;
-
-typedef struct SEntityTable
-{
-	DWORD dwVnum;
-} TEntityTable;
-
-typedef struct SMobTable : public SEntityTable
-{
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	char szLocaleName[CHARACTER_NAME_MAX_LEN + 1];
-
-	BYTE bType; // Monster, NPC
-	BYTE bRank; // PAWN, KNIGHT, KING
-	BYTE bBattleType; // MELEE, etc..
-	BYTE bLevel;
-	BYTE bScale;
-	BYTE bSize;
-
-	DWORD dwGoldMin;
-	DWORD dwGoldMax;
-	DWORD dwExp;
-	DWORD dwSungMaExp;
-	DWORD dwMaxHP;
-	BYTE bRegenCycle;
-	BYTE bRegenPercent;
-	WORD wDef;
-
-	DWORD dwAIFlag;
-	DWORD dwRaceFlag;
-	DWORD dwImmuneFlag;
-
-	BYTE bStr, bDex, bCon, bInt;
-	BYTE bSungMaStr, bSungMaDex, bSungMaCon, bSungMaInt;
-	DWORD dwDamageRange[2];
-
-	short sAttackSpeed;
-	short sMovingSpeed;
-
-	BYTE bAggressiveHPPct;
-	WORD wAggressiveSight;
-	WORD wAttackRange;
-
-	char cEnchants[MOB_ENCHANTS_MAX_NUM];
-	char cResists[MOB_RESISTS_MAX_NUM];
-	char cElements[MOB_ELEMENT_MAX_NUM];
-	char cResistDark, cResistIce, cResistEarth;
-
-	DWORD dwResurrectionVnum;
-	DWORD dwDropItemVnum;
-
-	BYTE bMountCapacity;
-	BYTE bOnClickType;
-
-	BYTE bEmpire;
-	char szFolder[CHARACTER_FOLDER_MAX_LEN + 1];
-
-	float fDamMultiply;
-
-	DWORD dwSummonVnum;
-	DWORD dwDrainSP;
-	DWORD dwMobColor;
-	DWORD dwPolymorphItemVnum;
-
-	TMobSkillLevel Skills[MOB_SKILL_MAX_NUM];
-
-	BYTE bBerserkPoint;
-	BYTE bStoneSkinPoint;
-	BYTE bGodSpeedPoint;
-	BYTE bDeathBlowPoint;
-	BYTE bRevivePoint;
-
-	BYTE bHealPoint;
-
-	BYTE bRAttSpeedPoint;
-	BYTE bRCastSpeedPoint;
-
-	BYTE bRHPRegenPoint;
-
-	float fHitRange;
-} TMobTable;
-
-typedef struct SSkillTable
-{
-	DWORD dwVnum;
-	char szName[32 + 1];
-	BYTE bType;
-	BYTE bMaxLevel;
-	DWORD dwSplashRange;
-
-	char szPointOn[64];
-	char szPointPoly[100 + 1];
-	char szSPCostPoly[100 + 1];
-	char szDurationPoly[100 + 1];
-	char szDurationSPCostPoly[100 + 1];
-	char szCooldownPoly[100 + 1];
-	char szMasterBonusPoly[100 + 1];
-	//char szAttackGradePoly[100 + 1];
-	char szGrandMasterAddSPCostPoly[100 + 1];
-	DWORD dwFlag;
-	DWORD dwAffectFlag;
-
-	// Data for secondary skill
-	char szPointOn2[64];
-	char szPointPoly2[100 + 1];
-	char szDurationPoly2[100 + 1];
-	DWORD dwAffectFlag2;
-
-	// Data for grand master point
-	char szPointOn3[64];
-	char szPointPoly3[100 + 1];
-	char szDurationPoly3[100 + 1];
-
-	BYTE bLevelStep;
-	BYTE bLevelLimit;
-	DWORD preSkillVnum;
-	BYTE preSkillLevel;
-
-	long lMaxHit;
-	char szSplashAroundDamageAdjustPoly[100 + 1];
-
-	BYTE bSkillAttrType;
-
-	DWORD dwTargetRange;
-} TSkillTable;
-
-typedef struct SShopItemTable
-{
-	DWORD vnum;
-	DWORD count;
-
-	TItemPos pos; // PC 상점에만 이용
-	DWORD price; // PC, shop_table_ex.txt 상점에만 이용
-#if defined(__CHEQUE_SYSTEM__)
-	DWORD cheque;
-#endif
-	BYTE display_pos; // PC, shop_table_ex.txt 상점에만 이용, 보일 위치.
-#if defined(__SHOPEX_RENEWAL__)
-	BYTE bPriceType;
-	DWORD dwPriceVnum;
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	SShopItemTable() : bPriceType(SHOP_COIN_TYPE_GOLD), dwPriceVnum(0)
-	{
-		memset(&alSockets, 0, sizeof(alSockets));
-	}
-#endif
-} TShopItemTable;
-
-typedef struct SShopTable
-{
-	DWORD dwVnum;
-	DWORD dwNPCVnum;
-	BYTE bItemCount;
-#if defined(__MYSHOP_EXPANSION__)
-	TShopItemTable items[SHOP_HOST_ITEM_MAX];
-#else
-	TShopItemTable items[SHOP_HOST_ITEM_MAX_NUM];
-#endif
-} TShopTable;
-
-#define QUEST_NAME_MAX_LEN 50 // 32
-#define QUEST_STATE_MAX_LEN 64
-
-typedef struct SQuestTable
-{
-	DWORD dwPID;
-	char szName[QUEST_NAME_MAX_LEN + 1];
-	char szState[QUEST_STATE_MAX_LEN + 1];
-	long lValue;
-} TQuestTable;
-
-typedef struct SItemLimit
-{
-	BYTE bType;
-	long lValue;
-} TItemLimit;
-
-typedef struct SItemApply
-{
-	POINT_TYPE wType;
-	POINT_VALUE lValue;
-} TItemApply;
-
-typedef struct SItemTable : public SEntityTable
-{
-	DWORD dwVnumRange;
-	char szName[ITEM_NAME_MAX_LEN + 1];
-	char szLocaleName[ITEM_NAME_MAX_LEN + 1];
-	BYTE bType;
-	BYTE bSubType;
-
-	BYTE bWeight;
-	BYTE bSize;
-
-	uint64_t ullAntiFlags;
-	DWORD dwFlags;
-	DWORD dwWearFlags;
-	DWORD dwImmuneFlag;
-
-	DWORD dwShopBuyPrice;
-	DWORD dwShopSellPrice;
-
-	TItemLimit aLimits[ITEM_LIMIT_MAX_NUM];
-	TItemApply aApplies[ITEM_APPLY_MAX_NUM];
-	long alValues[ITEM_VALUES_MAX_NUM];
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	DWORD dwRefinedVnum;
-	WORD wRefineSet;
-	DWORD dw67AttrMaterial;
-	BYTE bAlterToMagicItemPct;
-	BYTE bSpecular;
-	BYTE bGainSocketPct;
-
-	short int sAddonType; // 기본 속성
-
-	// 아래 limit flag들은 realtime에 체크 할 일이 많고, 아이템 VNUM당 고정된 값인데,
-	// 현재 구조대로 매번 아이템마다 필요한 경우에 LIMIT_MAX_NUM까지 루프돌면서 체크하는 부하가 커서 미리 저장 해 둠.
-	char cLimitRealTimeFirstUseIndex; // 아이템 limit 필드값 중에서 LIMIT_REAL_TIME_FIRST_USE 플래그의 위치 (없으면 -1)
-	char cLimitTimerBasedOnWearIndex; // 아이템 limit 필드값 중에서 LIMIT_TIMER_BASED_ON_WEAR 플래그의 위치 (없으면 -1)
-
-	char* GetOriginalName() { return szName; }
-	DWORD GetVNum() { return dwVnum; }
-	char* GetName() { return szLocaleName; }
-
-	BYTE GetType() { return bType; }
-	BYTE GetSubType() { return bSubType; }
-	BYTE GetWeight() { return bWeight; }
-	BYTE GetSize() { return bSize; }
-
-	uint64_t GetAntiFlags() { return ullAntiFlags; }
-	DWORD GetWearFlags() { return dwWearFlags; }
-	DWORD GetImmuneFlags() { return dwImmuneFlag; }
-
-	DWORD GetBuyPrice() { return dwShopBuyPrice; }
-	DWORD GetSellPrice() { return dwShopSellPrice; }
-
-	long GetValue(unsigned int index)
-	{
-		return alValues[index];
-	}
-
-	BYTE GetLimitType(DWORD idx) const { return aLimits[idx].bType; }
-	long GetLimitValue(DWORD idx) const { return aLimits[idx].lValue; }
-
-	// Weapon
-	bool IsWeapon() { return GetType() == ITEM_WEAPON; }
-	bool IsSword() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_SWORD; }
-	bool IsDagger() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_DAGGER; }
-	bool IsBow() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_BOW; }
-	bool IsTwoHandSword() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_TWO_HANDED; }
-	bool IsBell() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_BELL; }
-	bool IsFan() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_FAN; }
-	bool IsArrow() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_ARROW; }
-	bool IsMountSpear() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_MOUNT_SPEAR; }
-	bool IsClaw() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_CLAW; }
-#if defined(__QUIVER_SYSTEM__)
-	bool IsQuiver() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_QUIVER; }
-#endif
-
-	// Armor
-	bool IsArmor() { return GetType() == ITEM_ARMOR; }
-	bool IsArmorBody() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_BODY; }
-	bool IsHelmet() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_HEAD; }
-	bool IsShield() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_SHIELD; }
-	bool IsWrist() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_WRIST; }
-	bool IsShoe() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_FOOTS; }
-	bool IsNecklace() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_NECK; }
-	bool IsEarRing() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_EAR; }
-
-	bool IsBelt() { return GetType() == ITEM_BELT; }
-	bool IsRing() { return GetType() == ITEM_RING; }
-
-	// Costume
-	bool IsCostume() { return GetType() == ITEM_COSTUME; }
-	bool IsCostumeBody() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_BODY; }
-	bool IsCostumeHair() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_HAIR; }
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	bool IsCostumeMount() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_MOUNT; }
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	bool IsCostumeAcce() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_ACCE; }
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-	bool IsCostumeWeapon() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_WEAPON; }
-#endif
-#if defined(__MOVE_COSTUME_ATTR__)
-	bool IsCostumeModifyItem() { return GetType() == ITEM_USE && (GetSubType() == USE_CHANGE_COSTUME_ATTR || GetSubType() == USE_RESET_COSTUME_ATTR); }
-#endif
-
-	bool CanUseByJob(BYTE bJob)
-	{
-		switch (bJob)
-		{
-		case JOB_WARRIOR:
-			if (GetAntiFlags() & ITEM_ANTIFLAG_WARRIOR)
-				return false;
-			break;
-		case JOB_ASSASSIN:
-			if (GetAntiFlags() & ITEM_ANTIFLAG_ASSASSIN)
-				return false;
-			break;
-		case JOB_SHAMAN:
-			if (GetAntiFlags() & ITEM_ANTIFLAG_SHAMAN)
-				return false;
-			break;
-		case JOB_SURA:
-			if (GetAntiFlags() & ITEM_ANTIFLAG_SURA)
-				return false;
-			break;
-		case JOB_WOLFMAN:
-			if (GetAntiFlags() & ITEM_ANTIFLAG_WOLFMAN)
-				return false;
-			break;
-		}
-		return true;
-	}
-
-	POINT_VALUE FindApplyValue(POINT_TYPE dwType)
-	{
-		for (BYTE bIndex = 0; bIndex < ITEM_APPLY_MAX_NUM; ++bIndex)
-		{
-			if (aApplies[bIndex].wType == dwType)
-				return aApplies[bIndex].lValue;
-		}
-		return 0;
-	}
-
-} TItemTable;
-
-struct TItemAttrTable
-{
-	TItemAttrTable() :
-		wApplyIndex(0),
-		dwProb(0)
-	{
-		szApply[0] = 0;
-		memset(&lValues, 0, sizeof(lValues));
-		memset(&bMaxLevelBySet, 0, sizeof(bMaxLevelBySet));
-	}
-
-	char szApply[APPLY_NAME_MAX_LEN + 1];
-	POINT_TYPE wApplyIndex;
-	DWORD dwProb;
-	POINT_VALUE lValues[ITEM_ATTRIBUTE_MAX_LEVEL];
-	BYTE bMaxLevelBySet[ATTRIBUTE_SET_MAX_NUM];
-};
-
-typedef struct SConnectTable
-{
-	char login[LOGIN_MAX_LEN + 1];
-	IDENT ident;
-} TConnectTable;
-
-typedef struct SLoginPacket
-{
-	char login[LOGIN_MAX_LEN + 1];
-	char passwd[PASSWD_MAX_LEN + 1];
-} TLoginPacket;
-
-typedef struct SPlayerLoadPacket
-{
-	DWORD account_id;
-	DWORD player_id;
-	BYTE account_index; /* account 에서의 위치 */
-} TPlayerLoadPacket;
-
-typedef struct SPlayerCreatePacket
-{
-	char login[LOGIN_MAX_LEN + 1];
-	char passwd[PASSWD_MAX_LEN + 1];
-	DWORD account_id;
-	BYTE account_index;
-	TPlayerTable player_table;
-} TPlayerCreatePacket;
-
-typedef struct SPlayerDeletePacket
-{
-	char login[LOGIN_MAX_LEN + 1];
-	DWORD player_id;
-	BYTE account_index;
-	//char name[CHARACTER_NAME_MAX_LEN + 1];
-	char private_code[8];
-} TPlayerDeletePacket;
-
-#if defined(__DELETE_FAILURE_TYPE__)
-typedef struct SPlayerDeleteFailurePacket
-{
-	BYTE bType;
-	INT iTime;
-} TPlayerDeleteFailurePacket;
-#endif
-
-typedef struct SLogoutPacket
-{
-	char login[LOGIN_MAX_LEN + 1];
-	char passwd[PASSWD_MAX_LEN + 1];
-} TLogoutPacket;
-
-typedef struct SPlayerCountPacket
-{
-	DWORD dwCount;
-} TPlayerCountPacket;
-
-#if defined(__EXTEND_MALLBOX__)
-#	define SAFEBOX_MAX_NUM 225 // 45 (Slots) * 5 (Pages)
-#else
-#	define SAFEBOX_MAX_NUM 135 // 45 (Slots) * 3 (Pages)
-#endif
-#define SAFEBOX_PASSWORD_MAX_LEN 6
-
-typedef struct SSafeboxTable
-{
-	DWORD dwID;
-	BYTE bSize;
-	DWORD dwGold;
-	WORD wItemCount;
-} TSafeboxTable;
-
-typedef struct SSafeboxChangeSizePacket
-{
-	DWORD dwID;
-	BYTE bSize;
-} TSafeboxChangeSizePacket;
-
-typedef struct SSafeboxLoadPacket
-{
-	DWORD dwID;
-	char szLogin[LOGIN_MAX_LEN + 1];
-	char szPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
-} TSafeboxLoadPacket;
-
-typedef struct SSafeboxChangePasswordPacket
-{
-	DWORD dwID;
-	char szOldPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
-	char szNewPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
-} TSafeboxChangePasswordPacket;
-
-typedef struct SSafeboxChangePasswordPacketAnswer
-{
-	BYTE flag;
-} TSafeboxChangePasswordPacketAnswer;
-
-typedef struct SEmpireSelectPacket
-{
-	DWORD dwAccountID;
-	BYTE bEmpire;
-} TEmpireSelectPacket;
-
-typedef struct SPacketGDSetup
-{
-	char szPublicIP[16]; // Public IP which listen to users
-	BYTE bChannel; // 채널
-	WORD wListenPort; // 클라이언트가 접속하는 포트 번호
-	WORD wP2PPort; // 서버끼리 연결 시키는 P2P 포트 번호
-	long alMaps[MAX_MAP_ALLOW];
-	DWORD dwLoginCount;
-	BYTE bAuthServer;
-} TPacketGDSetup;
-
-typedef struct SPacketDGMapLocations
-{
-	BYTE bCount;
-} TPacketDGMapLocations;
-
-typedef struct SMapLocation
-{
-	long alMaps[MAX_MAP_ALLOW];
-	char szHost[MAX_HOST_LENGTH + 1];
-	WORD wPort;
-} TMapLocation;
-
-typedef struct SPacketDGP2P
-{
-	char szHost[MAX_HOST_LENGTH + 1];
-	WORD wPort;
-	BYTE bChannel;
-} TPacketDGP2P;
-
-typedef struct SPacketGDDirectEnter
-{
-	char login[LOGIN_MAX_LEN + 1];
-	char passwd[PASSWD_MAX_LEN + 1];
-	BYTE index;
-} TPacketGDDirectEnter;
-
-typedef struct SPacketDGDirectEnter
-{
-	TAccountTable accountTable;
-	TPlayerTable playerTable;
-} TPacketDGDirectEnter;
-
-typedef struct SPacketGuildSkillUpdate
-{
-	DWORD guild_id;
-	int amount;
-	BYTE skill_levels[12];
-	BYTE skill_point;
-	BYTE save;
-} TPacketGuildSkillUpdate;
-
-typedef struct SPacketGuildExpUpdate
-{
-	DWORD guild_id;
-	int amount;
-} TPacketGuildExpUpdate;
-
-typedef struct SPacketGuildChangeMemberData
-{
-	DWORD guild_id;
-	DWORD pid;
-	DWORD offer;
-	BYTE level;
-	BYTE grade;
-} TPacketGuildChangeMemberData;
-
-typedef struct SPacketDGLoginAlready
-{
-	char szLogin[LOGIN_MAX_LEN + 1];
-} TPacketDGLoginAlready;
-
-typedef struct TPacketAffectElement
-{
-	DWORD dwType;
-	POINT_TYPE wApplyOn;
-	POINT_VALUE lApplyValue;
-	DWORD dwFlag;
-	long lDuration;
-	long lSPCost;
-#if defined(__AFFECT_RENEWAL__)
-	bool bRealTime;
-	bool bUpdate;
-#endif
-} TPacketAffectElement;
-
-typedef struct SPacketGDAddAffect
-{
-	DWORD dwPID;
-	TPacketAffectElement elem;
-} TPacketGDAddAffect;
-
-typedef struct SPacketGDRemoveAffect
-{
-	DWORD dwPID;
-	DWORD dwType;
-	POINT_TYPE wApplyOn;
-} TPacketGDRemoveAffect;
-
-typedef struct SPacketGDHighscore
-{
-	DWORD dwPID;
-	long lValue;
-	char cDir;
-	char szBoard[21];
-} TPacketGDHighscore;
-
-typedef struct SPacketPartyCreate
-{
-	DWORD dwLeaderPID;
-} TPacketPartyCreate;
-
-typedef struct SPacketPartyDelete
-{
-	DWORD dwLeaderPID;
-} TPacketPartyDelete;
-
-typedef struct SPacketPartyAdd
-{
-	DWORD dwLeaderPID;
-	DWORD dwPID;
-	BYTE bState;
-} TPacketPartyAdd;
-
-typedef struct SPacketPartyRemove
-{
-	DWORD dwLeaderPID;
-	DWORD dwPID;
-} TPacketPartyRemove;
-
-typedef struct SPacketPartyStateChange
-{
-	DWORD dwLeaderPID;
-	DWORD dwPID;
-	BYTE bRole;
-	BYTE bFlag;
-} TPacketPartyStateChange;
-
-typedef struct SPacketPartySetMemberLevel
-{
-	DWORD dwLeaderPID;
-	DWORD dwPID;
-	BYTE bLevel;
-} TPacketPartySetMemberLevel;
-
-typedef struct SPacketGDBoot
-{
-	DWORD dwItemIDRange[2];
-	char szIP[16];
-} TPacketGDBoot;
-
-typedef struct SPacketGuild
-{
-	DWORD dwGuild;
-	DWORD dwInfo;
-} TPacketGuild;
-
-typedef struct SPacketGDGuildAddMember
-{
-	DWORD dwPID;
-	DWORD dwGuild;
-	BYTE bGrade;
-} TPacketGDGuildAddMember;
-
-typedef struct SPacketDGGuildMember
-{
-	DWORD dwPID;
-	DWORD dwGuild;
-	BYTE bGrade;
-	BYTE isGeneral;
-	BYTE bJob;
-	BYTE bLevel;
-	DWORD dwOffer;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketDGGuildMember;
-
-typedef struct SPacketGuildWar
-{
-	BYTE bType;
-	BYTE bWar;
-	DWORD dwGuildFrom;
-	DWORD dwGuildTo;
-	long lWarPrice;
-	long lInitialScore;
-} TPacketGuildWar;
-
-// Game -> DB : 상대적 변화값
-// DB -> Game : 토탈된 최종값
-typedef struct SPacketGuildWarScore
-{
-	DWORD dwGuildGainPoint;
-	DWORD dwGuildOpponent;
-	long lScore;
-	long lBetScore;
-} TPacketGuildWarScore;
-
-typedef struct SRefineMaterial
-{
-	DWORD vnum;
-	int count;
-} TRefineMaterial;
-
-typedef struct SRefineTable
-{
-	//DWORD src_vnum;
-	//DWORD result_vnum;
-	DWORD id;
-	WORD material_count;
-	int cost; // 소요 비용
-	int prob; // 확률
-	TRefineMaterial materials[REFINE_MATERIAL_MAX_NUM];
-} TRefineTable;
-
-typedef struct SBanwordTable
-{
-	char szWord[BANWORD_MAX_LEN + 1];
-} TBanwordTable;
-
-typedef struct SPacketGDChangeName
-{
-	DWORD pid;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGDChangeName;
-
-typedef struct SPacketDGChangeName
-{
-	DWORD pid;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketDGChangeName;
-
-typedef struct SPacketGuildLadder
-{
-	DWORD dwGuild;
-	long lLadderPoint;
-	long lWin;
-	long lDraw;
-	long lLoss;
-} TPacketGuildLadder;
-
-typedef struct SPacketGuildLadderPoint
-{
-	DWORD dwGuild;
-	long lChange;
-} TPacketGuildLadderPoint;
-
-typedef struct SPacketGuildUseSkill
-{
-	DWORD dwGuild;
-	DWORD dwSkillVnum;
-	DWORD dwCooltime;
-} TPacketGuildUseSkill;
-
-typedef struct SPacketGuildSkillUsableChange
-{
-	DWORD dwGuild;
-	DWORD dwSkillVnum;
-	BYTE bUsable;
-} TPacketGuildSkillUsableChange;
-
-typedef struct SPacketGDLoginKey
-{
-	DWORD dwAccountID;
-	DWORD dwLoginKey;
-} TPacketGDLoginKey;
-
-typedef struct SPacketGDAuthLogin
-{
-	DWORD dwID;
-	DWORD dwLoginKey;
-	char szLogin[LOGIN_MAX_LEN + 1];
-	char szSocialID[SOCIAL_ID_MAX_LEN + 1];
-	DWORD adwClientKey[4];
-	int iPremiumTimes[PREMIUM_MAX_NUM];
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketGDAuthLogin;
-
-typedef struct SPacketGDLoginByKey
-{
-	char szLogin[LOGIN_MAX_LEN + 1];
-	DWORD dwLoginKey;
-	DWORD adwClientKey[4];
-	char szIP[MAX_HOST_LENGTH + 1];
-} TPacketGDLoginByKey;
-
-/**
-* @version 05/06/08 Bang2ni - 지속시간 추가
-**/
-typedef struct SPacketGiveGuildPriv
-{
-	BYTE type;
-	int value;
-	DWORD guild_id;
-	time_t duration_sec; ///< 지속시간
-} TPacketGiveGuildPriv;
-
-typedef struct SPacketGiveEmpirePriv
-{
-	BYTE type;
-	int value;
-	BYTE empire;
-	time_t duration_sec;
-} TPacketGiveEmpirePriv;
-
-typedef struct SPacketGiveCharacterPriv
-{
-	BYTE type;
-	int value;
-	DWORD pid;
-} TPacketGiveCharacterPriv;
-
-typedef struct SPacketRemoveGuildPriv
-{
-	BYTE type;
-	DWORD guild_id;
-} TPacketRemoveGuildPriv;
-
-typedef struct SPacketRemoveEmpirePriv
-{
-	BYTE type;
-	BYTE empire;
-} TPacketRemoveEmpirePriv;
-
-typedef struct SPacketDGChangeCharacterPriv
-{
-	BYTE type;
-	int value;
-	DWORD pid;
-	BYTE bLog;
-} TPacketDGChangeCharacterPriv;
-
-/**
-* @version 05/06/08 Bang2ni - 지속시간 추가
-**/
-typedef struct SPacketDGChangeGuildPriv
-{
-	BYTE type;
-	int value;
-	DWORD guild_id;
-	BYTE bLog;
-	time_t end_time_sec; ///< 지속시간
-} TPacketDGChangeGuildPriv;
-
-typedef struct SPacketDGChangeEmpirePriv
-{
-	BYTE type;
-	int value;
-	BYTE empire;
-	BYTE bLog;
-	time_t end_time_sec;
-} TPacketDGChangeEmpirePriv;
-
-typedef struct SPacketMoneyLog
-{
-	BYTE type;
-	DWORD vnum;
-	int gold;
-#if defined(__CHEQUE_SYSTEM__)
-	int cheque;
-#endif
-} TPacketMoneyLog;
-
-typedef struct SPacketGDGuildMoney
-{
-	DWORD dwGuild;
-	INT iGold;
-} TPacketGDGuildMoney;
-
-typedef struct SPacketDGGuildMoneyChange
-{
-	DWORD dwGuild;
-	INT iTotalGold;
-} TPacketDGGuildMoneyChange;
-
-typedef struct SPacketDGGuildMoneyWithdraw
-{
-	DWORD dwGuild;
-	INT iChangeGold;
-} TPacketDGGuildMoneyWithdraw;
-
-typedef struct SPacketGDGuildMoneyWithdrawGiveReply
-{
-	DWORD dwGuild;
-	INT iChangeGold;
-	BYTE bGiveSuccess;
-} TPacketGDGuildMoneyWithdrawGiveReply;
-
-typedef struct SPacketSetEventFlag
-{
-	char szFlagName[EVENT_FLAG_NAME_MAX_LEN + 1];
-	long lValue;
-} TPacketSetEventFlag;
-
-typedef struct SPacketLoginOnSetup
-{
-	DWORD dwID;
-	char szLogin[LOGIN_MAX_LEN + 1];
-	char szSocialID[SOCIAL_ID_MAX_LEN + 1];
-	char szHost[MAX_HOST_LENGTH + 1];
-	DWORD dwLoginKey;
-	DWORD adwClientKey[4];
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketLoginOnSetup;
-
-typedef struct SPacketGDCreateObject
-{
-	DWORD dwVnum;
-	DWORD dwLandID;
-	INT lMapIndex;
-	INT x, y;
-	float xRot;
-	float yRot;
-	float zRot;
-} TPacketGDCreateObject;
-
-typedef struct SPacketGDHammerOfTor
-{
-	DWORD key;
-	DWORD delay;
-} TPacketGDHammerOfTor;
-
-typedef struct SGuildReserve
-{
-	DWORD dwID;
-	DWORD dwGuildFrom;
-	DWORD dwGuildTo;
-	DWORD dwTime;
-	BYTE bType;
-	long lWarPrice;
-	long lInitialScore;
-	bool bStarted;
-	DWORD dwBetFrom;
-	DWORD dwBetTo;
-	long lPowerFrom;
-	long lPowerTo;
-	long lHandicap;
-} TGuildWarReserve;
-
-typedef struct
-{
-	DWORD dwWarID;
-	char szLogin[LOGIN_MAX_LEN + 1];
-	DWORD dwGold;
-	DWORD dwGuild;
-} TPacketGDGuildWarBet;
-
-// Marriage
-typedef struct
-{
-	DWORD dwPID1;
-	DWORD dwPID2;
-	time_t tMarryTime;
-	char szName1[CHARACTER_NAME_MAX_LEN + 1];
-	char szName2[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketMarriageAdd;
-
-typedef struct
-{
-	DWORD dwPID1;
-	DWORD dwPID2;
-	INT iLovePoint;
-	BYTE byMarried;
-} TPacketMarriageUpdate;
-
-typedef struct
-{
-	DWORD dwPID1;
-	DWORD dwPID2;
-} TPacketMarriageRemove;
-
-typedef struct
-{
-	DWORD dwPID1;
-	DWORD dwPID2;
-} TPacketWeddingRequest;
-
-typedef struct
-{
-	DWORD dwPID1;
-	DWORD dwPID2;
-	DWORD dwMapIndex;
-} TPacketWeddingReady;
-
-typedef struct
-{
-	DWORD dwPID1;
-	DWORD dwPID2;
-} TPacketWeddingStart;
-
-typedef struct
-{
-	DWORD dwPID1;
-	DWORD dwPID2;
-} TPacketWeddingEnd;
-
-/// 개인상점 가격정보의 헤더. 가변 패킷으로 이 뒤에 byCount 만큼의 TItemPriceInfo 가 온다.
-typedef struct SPacketMyshopPricelistHeader
-{
-	DWORD dwOwnerID; ///< 가격정보를 가진 플레이어 ID
-	BYTE byCount; ///< 가격정보 갯수
-} TPacketMyshopPricelistHeader;
-
-/// 개인상점의 단일 아이템에 대한 가격정보
-typedef struct SItemPriceInfo
-{
-	DWORD dwVnum; ///< 아이템 vnum
-	DWORD dwPrice; ///< 가격
-#if defined(__CHEQUE_SYSTEM__)
-	DWORD dwCheque;
-#endif
-} TItemPriceInfo;
-
-/// 개인상점 아이템 가격정보 리스트 테이블
-typedef struct SItemPriceListTable
-{
-	DWORD dwOwnerID; ///< 가격정보를 가진 플레이어 ID
-	BYTE byCount; ///< 가격정보 리스트의 갯수
-
-	TItemPriceInfo aPriceInfo[SHOP_PRICELIST_MAX_NUM]; ///< 가격정보 리스트
-} TItemPriceListTable;
-
-typedef struct
-{
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	long lDuration;
-} TPacketBlockChat;
-
-// PCBANG_IP_LIST
-typedef struct SPacketPCBangIP
-{
-	DWORD id;
-	DWORD ip;
-} TPacketPCBangIP;
-// END_OF_PCBANG_IP_LIST
-
-// ADMIN_MANAGER
-typedef struct TAdminInfo
-{
-	int m_ID; // 고유ID
-	char m_szAccount[32]; // 계정
-	char m_szName[32]; // 캐릭터이름
-	char m_szContactIP[16]; // 접근아이피
-	char m_szServerIP[16]; // 서버아이피
-	int m_Authority; // 권한
-} tAdminInfo;
-// END_ADMIN_MANAGER
-
-// BOOT_LOCALIZATION
-struct tLocale
-{
-	char szValue[32];
-	char szKey[32];
-};
-// BOOT_LOCALIZATION
-
-// RELOAD_ADMIN
-typedef struct SPacketReloadAdmin
-{
-	char szIP[16];
-} TPacketReloadAdmin;
-// END_RELOAD_ADMIN
-
-typedef struct TMonarchInfo
-{
-	DWORD pid[4]; // 군주의 PID
-	int64_t money[4]; // 군주의 별개 돈
-	char name[4][32]; // 군주의 이름
-	char date[4][32]; // 군주 등록 날짜
-} MonarchInfo;
-
-typedef struct TMonarchElectionInfo
-{
-	DWORD pid; // 투표 한사람 PID
-	DWORD selectedpid; // 투표 당한 PID ( 군주 참가자 )
-	char date[32]; // 투표 날짜
-} MonarchElectionInfo;
-
-// 군주 출마자
-typedef struct tMonarchCandidacy
-{
-	DWORD pid;
-	char name[32];
-	char date[32];
-} MonarchCandidacy;
-
-typedef struct tChangeMonarchLord
-{
-	BYTE bEmpire;
-	DWORD dwPID;
-} TPacketChangeMonarchLord;
-
-typedef struct tChangeMonarchLordACK
-{
-	BYTE bEmpire;
-	DWORD dwPID;
-	char szName[32];
-	char szDate[32];
-} TPacketChangeMonarchLordACK;
-
-// Block Country Ip
-typedef struct tBlockCountryIp
-{
-	DWORD ip_from;
-	DWORD ip_to;
-} TPacketBlockCountryIp;
-
-enum EBlockExceptionCommand
-{
-	BLOCK_EXCEPTION_CMD_ADD = 1,
-	BLOCK_EXCEPTION_CMD_DEL = 2,
-};
-
-// Block Exception Account
-typedef struct tBlockException
-{
-	BYTE cmd; // 1 == add, 2 == delete
-	char login[LOGIN_MAX_LEN + 1];
-}TPacketBlockException;
-
-typedef struct tChangeGuildMaster
-{
-	DWORD dwGuildID;
-	DWORD idFrom;
-	DWORD idTo;
-} TPacketChangeGuildMaster;
-
-typedef struct tItemIDRange
-{
-	DWORD dwMin;
-	DWORD dwMax;
-	DWORD dwUsableItemIDMin;
-} TItemIDRangeTable;
-
-typedef struct tUpdateHorseName
-{
-	DWORD dwPlayerID;
-	char szHorseName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketUpdateHorseName;
-
-typedef struct tDC
-{
-	char login[LOGIN_MAX_LEN + 1];
-} TPacketDC;
-
-typedef struct tNeedLoginLogInfo
-{
-	DWORD dwPlayerID;
-} TPacketNeedLoginLogInfo;
-
-// 독일 선물 알림 기능 테스트용 패킷 정보
-typedef struct tItemAwardInformer
-{
-	char login[LOGIN_MAX_LEN + 1];
-	char command[20]; // 명령어
-	unsigned int vnum; // 아이템
-} TPacketItemAwardInfromer;
-
-// 선물 알림 기능 삭제용 패킷 정보
-typedef struct tDeleteAwardID
-{
-	DWORD dwID;
-} TPacketDeleteAwardID;
-
-typedef struct SChannelStatus
-{
-	short nPort;
-	BYTE bStatus;
-} TChannelStatus;
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-enum MessengerBlock
-{
-	MESSENGER_BLOCK,
-	MESSENGER_FRIEND
-};
-#endif
-
-#if defined(__MOVE_CHANNEL__)
-typedef struct
-{
-	long lMapIndex;
-	int iChannel;
-} TPacketChangeChannel;
-
-typedef struct
-{
-	long lAddr;
-	WORD wPort;
-} TPacketReturnChannel;
-#endif
-
-#if defined(__MAILBOX__)
-enum EMAILBOX
-{
-	MAILBOX_TAX = 5,
-	MAILBOX_REMAIN_DAY = 30,
-	MAILBOX_REMAIN_DAY_GM = 7,
-	MAILBOX_LEVEL_LIMIT = 20,
-	MAILBOX_PRICE_YANG = 1000,
-	MAILBOX_PAGE_SIZE = 9,
-	MAILBOX_PAGE_COUNT = 10,
-	MAILBOX_MAX_MAIL = MAILBOX_PAGE_SIZE * MAILBOX_PAGE_COUNT,
-};
-
-typedef struct SMailBoxRespondUnreadData
-{
-	SMailBoxRespondUnreadData() :
-		bHeader(0),
-		bItemMessageCount(0),
-		bCommonMessageCount(0),
-		bGMVisible(false)
-	{}
-	BYTE bHeader;
-	BYTE bItemMessageCount;
-	BYTE bCommonMessageCount;
-	bool bGMVisible;
-} TMailBoxRespondUnreadData;
-
-typedef struct SMailBox
-{
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	BYTE Index;
-} TMailBox;
-
-typedef struct packet_mailbox_add_data
-{
-	BYTE bHeader;
-	BYTE Index;
-	char szFrom[CHARACTER_NAME_MAX_LEN + 1];
-	char szMessage[100 + 1];
-	int iYang;
-	int iWon;
-	DWORD dwItemVnum;
-	DWORD dwItemCount;
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwChangeLookVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-} TPacketGCMailBoxAddData;
-
-typedef struct packet_mailbox_message
-{
-	time_t SendTime;
-	time_t DeleteTime;
-	char szTitle[25 + 1];
-	bool bIsGMPost;
-	bool bIsItemExist;
-	bool bIsConfirm;
-} TPacketGCMailBoxMessage;
-
-typedef struct SMailBoxTable
-{
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	bool bIsDeleted;
-	packet_mailbox_message Message;
-	packet_mailbox_add_data AddData;
-} TMailBoxTable;
-#endif
-
-#if defined(__RANKING_SYSTEM__)
-typedef struct SPartyMemberName
-{
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-} TPartyMember;
-
-typedef struct SRankingData
-{
-	char szGuildName[GUILD_NAME_MAX_LEN + 1];
-	SPartyMemberName Member[PARTY_MAX_MEMBER];
-	DWORD dwRecord0, dwRecord1;
-	DWORD dwStartTime;
-	BYTE bEmpire;
-} TRankingData;
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-typedef struct SAttr67AddData
-{
-	SAttr67AddData() : wRegistItemPos(0), byMaterialCount(0), wSupportItemPos(0), bySupportItemCount(0) {}
-	WORD wRegistItemPos;
-	BYTE byMaterialCount;
-	WORD wSupportItemPos;
-	BYTE bySupportItemCount;
-} TAttr67AddData;
-#endif
-
-#if defined(__GEM_SHOP__)
-typedef struct SGemShopLoad
-{
-	DWORD dwPID;
-#	if defined(__CONQUEROR_LEVEL__)
-	bool bSpecial;
-#	endif
-} TGemShopLoad;
-
-typedef struct SGemShopItem
-{
-	bool bEnable;
-	DWORD dwItemVnum;
-	BYTE bCount;
-	DWORD dwPrice;
-} TGemShopItem;
-
-typedef struct SGemShopTable
-{
-	DWORD dwPID;
-	long lRefreshTime;
-	BYTE bEnabledSlots;
-	TGemShopItem GemShopItem[GEM_SHOP_SLOT_COUNT];
-#	if defined(__CONQUEROR_LEVEL__)
-	bool bSpecial;
-#	endif
-} TGemShopTable;
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-typedef struct SPacketGDEmote
-{
-	DWORD dwPID;
-	DWORD dwVnum;
-	DWORD dwDuration;
-} TPacketGDEmote;
-#endif
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-typedef struct SPacketSetGuildEventFlag
-{
-	DWORD dwGuildID;
-	char szFlagName[EVENT_FLAG_NAME_MAX_LEN + 1];
-	long lValue;
-} TPacketSetGuildEventFlag;
-#endif
-
-#ifdef __OFFLINE_SHOP__
-typedef struct SOfflineShop
-{
-	uint32_t id;
-
-	uint32_t ownerPid;
-	std::array<char, CHARACTER_NAME_MAX_LEN + 1> ownerName;
-
-	std::array<char, SHOP_TAB_NAME_MAX + 1> shopName;
-	int32_t shopNameChangeTime;
-	uint8_t channel;
-	uint32_t mapIndex, x, y;
-	uint32_t decoRace;
-	uint8_t decoBoard;
-
-	uint32_t openingTime;
-	int64_t gold;
-} TOfflineShop;
-
-typedef std::pair<uint32_t, uint16_t> TOfflineItemID;
-namespace std {
-	template <> struct hash <TOfflineItemID> {
-		inline size_t operator()(const TOfflineItemID& v) const {
-			std::hash<int> int_hasher;
-			return int_hasher(v.first) ^ int_hasher(v.second);
-		}
-	};
-}
-
-typedef struct SOfflineShopItem
-{
-	TOfflineItemID id;
-
-	uint32_t vnum;
-	uint32_t count;
-	std::array<int32_t, ITEM_SOCKET_MAX_NUM> sockets;
-	std::array<TPlayerItemAttribute, ITEM_ATTRIBUTE_MAX_NUM> attributes;
-#if defined(__ITEM_APPLY_RANDOM__)
-	std::array<TPlayerItemAttribute, ITEM_APPLY_MAX_NUM> ApplyRandom;
-#endif
-	int64_t price;
-#if defined(__SOUL_BIND_SYSTEM__)
-	long soulbind;
-#endif
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-} TOfflineShopItem;
-
-typedef struct SMySellHistory
-{
-	DWORD		pid;
-	DWORD		dwVnum;
-	DWORD		dwCount;
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD 		dwTransmutationVnum;
-#endif
-	long 		alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-	char		szBuyer[CHARACTER_NAME_MAX_LEN+1];
-	long long 	llPrice;
-	int			iTimeStamp;
-	bool		bIsSaved;
-} TMySellHistory;
-
-typedef std::pair<DWORD, DWORD> TShopSearchItemType;
-
-enum EShopSearchData
-{
-	SHOPSEARCH_SOLD_ITEM_INFO_COUNT = 30,
-};
-
-enum EShopSearchBuyResult {
-	SHOPSEARCH_BUY_SUCCESS,
-	SHOPSEARCH_BUY_NOT_EXIST,
-	SHOPSEARCH_BUY_PRICE_CHANGE,
-	SHOPSEARCH_BUY_TIMEOUT,
-	SHOPSEARCH_BUY_NO_PEER,
-	SHOPSEARCH_BUY_UNKNOWN_ERROR,
-};
-
-enum EShopSearchSortTypes {
-	SHOPSEARCH_SORT_RANDOM,
-	SHOPSEARCH_SORT_ASC,
-	SHOPSEARCH_SORT_DESC,
-	SHOPSEARCH_SORT_MAX_NUM,
-};
-
-enum EShopSearchAveragePriceLevels {
-	SHOPSEARCH_AVG_PRICE_GOOD,
-	SHOPSEARCH_AVG_PRICE_NORMAL,
-	SHOPSEARCH_AVG_PRICE_BAD,
-	SHOPSEARCH_AVG_PRICE_WORST,
-};
-
-typedef struct SShopSearchItem : TPlayerItem
-{
-	TOfflineItemID offlineID;
-
-	int64_t price;
-	DWORD endTime;
-} TShopSearchItem;
-
-typedef struct SShopSearchClientItem : SShopSearchItem
-{
-	BYTE	avgPriceLevel;
-} TShopSearchClientItem;
-
-typedef struct SShopSearchOptions
-{
-	BYTE		typeFlagCount;
-	BYTE		specificVnumCount;
-} TShopSearchOptions;
-
-typedef struct SPacketGDShopSearchByName
-{
-	BYTE	langID;
-	char	itemName[ITEM_NAME_MAX_LEN + 1];
-	WORD	page;
-	BYTE	entryCountIdx;
-	BYTE	sortType;
-} TPacketGDShopSearchByName;
-
-typedef struct SPacketGDShopSearchByOptions
-{
-	TShopSearchOptions	options;
-	WORD				page;
-	BYTE				entryCountIdx;
-	BYTE				sortType;
-} TPacketGDShopSearchByOptions;
-
-typedef struct SPacketGDShopSearchRequestBuy
-{
-	DWORD	ownerID;
-	TOfflineItemID	offlineID;
-	DWORD	itemVnum;
-	int64_t	itemPrice;
-	char	szBuyer[CHARACTER_NAME_MAX_LEN+1];
-} TPacketGDShopSearchRequestBuy;
-
-typedef struct SPacketDGShopSearchBuyFromShop
-{
-	DWORD	buyerDBHandle;
-	DWORD	buyerPCHandle;
-	DWORD	buyerPID;
-	DWORD	ownerPID;
-	TOfflineItemID	offlineID;
-	int64_t	itemPrice;
-	char	szBuyer[CHARACTER_NAME_MAX_LEN+1];
-} TPacketDGShopSearchBuyFromShop;
-
-typedef struct SPacketGDShopSearchBoughtFromShop
-{
-	DWORD	buyerDBHandle;
-	TPlayerItem	item;
-} TPacketGDShopSearchBoughtFromShop;
-
-typedef struct SPacketGDShopSearchSoldItem
-{
-	DWORD	itemVnum;
-	DWORD	itemCount;
-	uint64_t	price;
-} TPacketGDShopSearchSoldItem;
-
-typedef struct SShopSearchSoldItemInfo {
-	SShopSearchSoldItemInfo() : count(0), averagePrice(0) { }
-
-	uint64_t	count;
-	double		averagePrice;
-} TShopSearchSoldItemInfo;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-typedef struct SPlayerExtBattlePassMission
-{
-	DWORD dwPlayerId;
-	DWORD dwBattlePassType;
-	DWORD dwMissionIndex;
-	DWORD dwMissionType;
-	DWORD dwBattlePassId;
-	DWORD dwExtraInfo;
-	BYTE bCompleted;
-	BYTE bIsUpdated;
-} TPlayerExtBattlePassMission;
-
-typedef struct SExtBattlePassRewardItem
-{
-	DWORD dwVnum;
-	BYTE bCount;
-} TExtBattlePassRewardItem;
-
-typedef struct SExtBattlePassMissionInfo
-{
-	BYTE bMissionIndex;
-	BYTE bMissionType;
-	DWORD dwMissionInfo[3];
-	TExtBattlePassRewardItem aRewardList[3];
-} TExtBattlePassMissionInfo;
-
-typedef struct SExtBattlePassTimeTable
-{
-	BYTE	bBattlePassId;
-	DWORD	dwStartTime;
-	DWORD	dwEndTime;
-} TExtBattlePassTimeTable;
-#endif
-
-#pragma pack()
-#endif // __INC_COMMON_TABLES_H__
+#ifndef __INC_COMMON_TABLES_H__
+#define __INC_COMMON_TABLES_H__
+
+#include "service.h"
+#include "length.h"
+
+#include <array>
+#include <utility>
+
+typedef DWORD IDENT;
+
+/**
+* @version 05/06/10 Bang2ni - Myshop Pricelist  킷 HEADER_XX_MYSHOP_PRICELIST_XXX 煞
+**/
+enum GD_HEADERS
+{
+	HEADER_GD_LOGIN = 1,
+	HEADER_GD_LOGOUT = 2,
+
+	HEADER_GD_PLAYER_LOAD = 3,
+	HEADER_GD_PLAYER_SAVE = 4,
+	HEADER_GD_PLAYER_CREATE = 5,
+	HEADER_GD_PLAYER_DELETE = 6,
+
+	HEADER_GD_LOGIN_KEY = 7,
+	//HEADER_GD_EMPTY = 8,
+	HEADER_GD_BOOT = 9,
+	HEADER_GD_PLAYER_COUNT = 10,
+	HEADER_GD_QUEST_SAVE = 11,
+	HEADER_GD_SAFEBOX_LOAD = 12,
+	HEADER_GD_SAFEBOX_SAVE = 13,
+	HEADER_GD_SAFEBOX_CHANGE_SIZE = 14,
+	HEADER_GD_EMPIRE_SELECT = 15,
+
+	HEADER_GD_SAFEBOX_CHANGE_PASSWORD = 16,
+	HEADER_GD_SAFEBOX_CHANGE_PASSWORD_SECOND = 17, // Not really a packet, used internal
+	HEADER_GD_DIRECT_ENTER = 18,
+
+	HEADER_GD_GUILD_SKILL_UPDATE = 19,
+	HEADER_GD_GUILD_EXP_UPDATE = 20,
+	HEADER_GD_GUILD_ADD_MEMBER = 21,
+	HEADER_GD_GUILD_REMOVE_MEMBER = 22,
+	HEADER_GD_GUILD_CHANGE_GRADE = 23,
+	HEADER_GD_GUILD_CHANGE_MEMBER_DATA = 24,
+	HEADER_GD_GUILD_DISBAND = 25,
+	HEADER_GD_GUILD_WAR = 26,
+	HEADER_GD_GUILD_WAR_SCORE = 27,
+	HEADER_GD_GUILD_CREATE = 28,
+
+	//HEADER_GD_EMPTY = 29,
+
+	HEADER_GD_ITEM_SAVE = 30,
+	HEADER_GD_ITEM_DESTROY = 31,
+
+	HEADER_GD_ADD_AFFECT = 32,
+	HEADER_GD_REMOVE_AFFECT = 33,
+
+	HEADER_GD_HIGHSCORE_REGISTER = 34,
+	HEADER_GD_ITEM_FLUSH = 35,
+
+	HEADER_GD_PARTY_CREATE = 36,
+	HEADER_GD_PARTY_DELETE = 37,
+	HEADER_GD_PARTY_ADD = 38,
+	HEADER_GD_PARTY_REMOVE = 39,
+	HEADER_GD_PARTY_STATE_CHANGE = 40,
+	HEADER_GD_PARTY_HEAL_USE = 41,
+
+	HEADER_GD_FLUSH_CACHE = 42,
+	HEADER_GD_RELOAD_PROTO = 43,
+
+	HEADER_GD_CHANGE_NAME = 44,
+	//HEADER_GD_EMPTY = 45,
+
+	HEADER_GD_GUILD_CHANGE_LADDER_POINT = 46,
+	HEADER_GD_GUILD_USE_SKILL = 47,
+
+	HEADER_GD_REQUEST_EMPIRE_PRIV = 48,
+	HEADER_GD_REQUEST_GUILD_PRIV = 49,
+
+	HEADER_GD_MONEY_LOG = 50,
+
+	HEADER_GD_GUILD_DEPOSIT_MONEY = 51,
+	HEADER_GD_GUILD_WITHDRAW_MONEY = 52,
+	HEADER_GD_GUILD_WITHDRAW_MONEY_GIVE_REPLY = 53,
+
+	HEADER_GD_REQUEST_CHARACTER_PRIV = 54,
+
+	HEADER_GD_SET_EVENT_FLAG = 55,
+
+	HEADER_GD_PARTY_SET_MEMBER_LEVEL = 56,
+
+	HEADER_GD_GUILD_WAR_BET = 57,
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	HEADER_GD_GUILD_EVENT_FLAG = 58,
+#endif
+	//HEADER_GD_EMPTY = 59,
+
+	HEADER_GD_CREATE_OBJECT = 60,
+	HEADER_GD_DELETE_OBJECT = 61,
+	HEADER_GD_UPDATE_LAND = 62,
+
+	//HEADER_GD_EMPTY = 63,
+	//HEADER_GD_EMPTY = 64,
+	//HEADER_GD_EMPTY = 65,
+	//HEADER_GD_EMPTY = 66,
+	//HEADER_GD_EMPTY = 67,
+	//HEADER_GD_EMPTY = 68,
+	//HEADER_GD_EMPTY = 69,
+
+	HEADER_GD_MARRIAGE_ADD = 70,
+	HEADER_GD_MARRIAGE_UPDATE = 71,
+	HEADER_GD_MARRIAGE_REMOVE = 72,
+
+	HEADER_GD_WEDDING_REQUEST = 73,
+	HEADER_GD_WEDDING_READY = 74,
+	HEADER_GD_WEDDING_END = 75,
+
+	//HEADER_GD_EMPTY = 76,
+	//HEADER_GD_EMPTY = 77,
+	//HEADER_GD_EMPTY = 78,
+	//HEADER_GD_EMPTY = 79,
+	//HEADER_GD_EMPTY = 80,
+	//HEADER_GD_EMPTY = 81,
+	//HEADER_GD_EMPTY = 82,
+	//HEADER_GD_EMPTY = 83,
+	//HEADER_GD_EMPTY = 84,
+	//HEADER_GD_EMPTY = 85,
+	//HEADER_GD_EMPTY = 86,
+	//HEADER_GD_EMPTY = 87,
+	//HEADER_GD_EMPTY = 88,
+	//HEADER_GD_EMPTY = 89,
+	//HEADER_GD_EMPTY = 90,
+	//HEADER_GD_EMPTY = 91,
+	//HEADER_GD_EMPTY = 92,
+	//HEADER_GD_EMPTY = 93,
+	//HEADER_GD_EMPTY = 94,
+	//HEADER_GD_EMPTY = 95,
+	//HEADER_GD_EMPTY = 96,
+	//HEADER_GD_EMPTY = 97,
+	//HEADER_GD_EMPTY = 98,
+	//HEADER_GD_EMPTY = 99,
+
+	HEADER_GD_AUTH_LOGIN = 100,
+	HEADER_GD_LOGIN_BY_KEY = 101,
+	//HEADER_GD_EMPTY = 102,
+	//HEADER_GD_EMPTY = 103,
+	//HEADER_GD_EMPTY = 104,
+	//HEADER_GD_EMPTY = 105,
+	//HEADER_GD_EMPTY = 106,
+	HEADER_GD_MALL_LOAD = 107,
+
+	HEADER_GD_MYSHOP_PRICELIST_UPDATE = 108, /// <   청
+	HEADER_GD_MYSHOP_PRICELIST_REQ = 109, /// <  트 청
+
+	HEADER_GD_BLOCK_CHAT = 110,
+
+	// PCBANG_IP_LIST_BY_AUTH
+	HEADER_GD_PCBANG_REQUEST_IP_LIST = 111,
+	HEADER_GD_PCBANG_CLEAR_IP_LIST = 112,
+	HEADER_GD_PCBANG_INSERT_IP = 113,
+	// END_OF_PCBANG_IP_LIST_BY_AUTH
+
+	HEADER_GD_HAMMER_OF_TOR = 114,
+	HEADER_GD_RELOAD_ADMIN = 115, /// < 楮  청
+	HEADER_GD_BREAK_MARRIAGE = 116, /// < 혼 캇
+	HEADER_GD_ELECT_MONARCH = 117, /// <  표
+	HEADER_GD_CANDIDACY = 118, /// <  
+	HEADER_GD_ADD_MONARCH_MONEY = 119, /// <   
+	HEADER_GD_TAKE_MONARCH_MONEY = 120, /// <   
+	HEADER_GD_COME_TO_VOTE = 121, /// < 표
+	HEADER_GD_RMCANDIDACY = 122, /// < 캤  (楮)
+	HEADER_GD_SETMONARCH = 123, /// <玲 (楮)
+	HEADER_GD_RMMONARCH = 124, /// <怜
+	HEADER_GD_DEC_MONARCH_MONEY = 125,
+
+	HEADER_GD_CHANGE_MONARCH_LORD = 126,
+	HEADER_GD_BLOCK_COUNTRY_IP = 127, // 肉 IP-Block
+	HEADER_GD_BLOCK_EXCEPTION = 128, // 肉 IP-Block 
+
+	HEADER_GD_REQ_CHANGE_GUILD_MASTER = 129,
+
+	HEADER_GD_REQ_SPARE_ITEM_ID_RANGE = 130,
+
+	HEADER_GD_UPDATE_HORSE_NAME = 131,
+	HEADER_GD_REQ_HORSE_NAME = 132,
+
+	HEADER_GD_DC = 133, // Login Key 
+
+	HEADER_GD_VALID_LOGOUT = 134,
+
+	//HEADER_GD_EMPTY = 135,
+	//HEADER_GD_EMPTY = 136,
+
+	HEADER_GD_REQUEST_CHARGE_CASH = 137,
+
+	HEADER_GD_DELETE_AWARDID = 138, // delete gift notify icon
+
+	HEADER_GD_UPDATE_CHANNELSTATUS = 139,
+	HEADER_GD_REQUEST_CHANNELSTATUS = 140,
+
+	//HEADER_GD_EMPTY = 142,
+	//HEADER_GD_EMPTY = 143,
+
+#if defined(__MOVE_CHANNEL__)
+	HEADER_GD_FIND_CHANNEL = 144,
+#endif
+
+	//HEADER_GD_EMPTY = 145,
+	//HEADER_GD_EMPTY = 146,
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	HEADER_GD_SAVE_EXT_BATTLE_PASS = 147,
+#endif
+
+	//HEADER_GD_EMPTY = 148,
+	//HEADER_GD_EMPTY = 149,
+#if defined(__MAILBOX__)
+	HEADER_GD_MAILBOX_LOAD = 150,
+	HEADER_GD_MAILBOX_CHECK_NAME = 151,
+	HEADER_GD_MAILBOX_WRITE = 152,
+	HEADER_GD_MAILBOX_DELETE = 153,
+	HEADER_GD_MAILBOX_CONFIRM = 154,
+	HEADER_GD_MAILBOX_GET = 155,
+	HEADER_GD_MAILBOX_UNREAD = 156,
+#endif
+	//HEADER_GD_EMPTY = 157,
+	//HEADER_GD_EMPTY = 158,
+	//HEADER_GD_EMPTY = 159,
+#if defined(__GEM_SHOP__)
+	HEADER_GD_GEM_SHOP_LOAD = 160,
+	HEADER_GD_GEM_SHOP_UPDATE = 161,
+#endif
+	//HEADER_GD_EMPTY = 162,
+
+#ifdef __GROWTH_PET_SYSTEM__
+	HEADER_GD_GROWTH_PET_SAVE		= 147,
+	HEADER_GD_GROWTH_PET_DELETE		= 148,
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	HEADER_GD_EMOTE_LOAD = 165,
+	HEADER_GD_EMOTE_CLEAR = 166,
+	HEADER_GD_EMOTE_ADD = 167,
+#endif
+
+#ifdef __SHOP_SEARCH__
+	HEADER_GD_SHOP_SEARCH_REGISTER_ITEM = 172,
+	HEADER_GD_SHOP_SEARCH_UNREGISTER_ITEM = 173,
+	HEADER_GD_SHOP_SEARCH_SOLD_ITEM = 174,
+	HEADER_GD_SHOP_SEARCH_BY_NAME = 175,
+	HEADER_GD_SHOP_SEARCH_BY_OPTIONS = 176,
+	HEADER_GD_SHOP_SEARCH_REQUEST_BUY = 177,
+	HEADER_GD_SHOP_SEARCH_BUY_FROM_SHOP_ERROR = 178,
+	HEADER_GD_SHOP_SEARCH_BOUGHT_FROM_SHOP = 179,
+	HEADER_GD_SHOP_SEARCH_REQUEST_SOLD_INFO = 180,
+	HEADER_GD_SHOP_SEARCH_RELOAD_AVERAGE = 181,
+#endif
+	//HEADER_GD_EMPTY = 182,
+	//HEADER_GD_EMPTY = 183,
+	//HEADER_GD_EMPTY = 184,
+	//HEADER_GD_EMPTY = 185,
+	//HEADER_GD_EMPTY = 186,
+	//HEADER_GD_EMPTY = 187,
+	//HEADER_GD_EMPTY = 188,
+	//HEADER_GD_EMPTY = 189,
+	//HEADER_GD_EMPTY = 190,
+	//HEADER_GD_EMPTY = 191,
+	//HEADER_GD_EMPTY = 192,
+	//HEADER_GD_EMPTY = 193,
+	//HEADER_GD_EMPTY = 194,
+	//HEADER_GD_EMPTY = 195,
+	//HEADER_GD_EMPTY = 196,
+	//HEADER_GD_EMPTY = 197,
+	//HEADER_GD_EMPTY = 198,
+	//HEADER_GD_EMPTY = 199,
+	//HEADER_GD_EMPTY = 200,
+	//HEADER_GD_EMPTY = 201,
+	//HEADER_GD_EMPTY = 202,
+	//HEADER_GD_EMPTY = 203,
+	//HEADER_GD_EMPTY = 204,
+	//HEADER_GD_EMPTY = 205,
+	//HEADER_GD_EMPTY = 206,
+	//HEADER_GD_EMPTY = 207,
+	//HEADER_GD_EMPTY = 208,
+	//HEADER_GD_EMPTY = 209,
+	//HEADER_GD_EMPTY = 210,
+	//HEADER_GD_EMPTY = 211,
+	//HEADER_GD_EMPTY = 212,
+	//HEADER_GD_EMPTY = 213,
+	//HEADER_GD_EMPTY = 214,
+	//HEADER_GD_EMPTY = 215,
+	//HEADER_GD_EMPTY = 216,
+	//HEADER_GD_EMPTY = 217,
+	//HEADER_GD_EMPTY = 218,
+	//HEADER_GD_EMPTY = 219,
+	//HEADER_GD_EMPTY = 220,
+	//HEADER_GD_EMPTY = 221,
+	//HEADER_GD_EMPTY = 222,
+	//HEADER_GD_EMPTY = 223,
+	//HEADER_GD_EMPTY = 224,
+	//HEADER_GD_EMPTY = 225,
+	//HEADER_GD_EMPTY = 226,
+	//HEADER_GD_EMPTY = 227,
+	//HEADER_GD_EMPTY = 228,
+	//HEADER_GD_EMPTY = 229,
+	//HEADER_GD_EMPTY = 230,
+	//HEADER_GD_EMPTY = 231,
+	//HEADER_GD_EMPTY = 232,
+	//HEADER_GD_EMPTY = 233,
+	//HEADER_GD_EMPTY = 234,
+	//HEADER_GD_EMPTY = 235,
+	//HEADER_GD_EMPTY = 236,
+	//HEADER_GD_EMPTY = 237,
+	//HEADER_GD_EMPTY = 238,
+	//HEADER_GD_EMPTY = 239,
+	//HEADER_GD_EMPTY = 240,
+	//HEADER_GD_EMPTY = 241,
+	//HEADER_GD_EMPTY = 242,
+
+#ifdef __OFFLINE_SHOP__
+	HEADER_GD_REQUEST_OFFLINE_SHOP_ID = 243,
+	HEADER_GD_OFFLINE_SHOP_SAVE = 244,
+	HEADER_GD_OFFLINE_SHOP_SAVE_ITEM = 245,
+	HEADER_GD_OFFLINE_SHOP_DESTROY = 246,
+#endif
+
+	//HEADER_GD_EMPTY = 247,
+	//HEADER_GD_EMPTY = 248,
+	//HEADER_GD_EMPTY = 249,
+	//HEADER_GD_EMPTY = 250,
+	//HEADER_GD_EMPTY = 251,
+	//HEADER_GD_EMPTY = 252,
+	//HEADER_GD_EMPTY = 253,
+	//HEADER_GD_EMPTY = 254,
+	HEADER_GD_SETUP = 0xff, // 255
+};
+
+enum DG_HEADERS
+{
+	HEADER_DG_NOTICE = 1,
+	//HEADER_DG_EMPTY = 2,
+	//HEADER_DG_EMPTY = 3,
+	//HEADER_DG_EMPTY = 4,
+	//HEADER_DG_EMPTY = 5,
+	//HEADER_DG_EMPTY = 6,
+	//HEADER_DG_EMPTY = 7,
+	//HEADER_DG_EMPTY = 8,
+	//HEADER_DG_EMPTY = 9,
+	//HEADER_DG_EMPTY = 10,
+	//HEADER_DG_EMPTY = 11,
+	//HEADER_DG_EMPTY = 12,
+	//HEADER_DG_EMPTY = 13,
+	//HEADER_DG_EMPTY = 14,
+	//HEADER_DG_EMPTY = 15,
+	//HEADER_DG_EMPTY = 16,
+	//HEADER_DG_EMPTY = 17,
+	//HEADER_DG_EMPTY = 18,
+	//HEADER_DG_EMPTY = 19,
+	//HEADER_DG_EMPTY = 20,
+	//HEADER_DG_EMPTY = 21,
+	//HEADER_DG_EMPTY = 22,
+	//HEADER_DG_EMPTY = 23,
+	//HEADER_DG_EMPTY = 24,
+	//HEADER_DG_EMPTY = 25,
+	//HEADER_DG_EMPTY = 26,
+	//HEADER_DG_EMPTY = 27,
+	//HEADER_DG_EMPTY = 28,
+	//HEADER_DG_EMPTY = 29,
+	HEADER_DG_LOGIN_SUCCESS = 30,
+	HEADER_DG_LOGIN_NOT_EXIST = 31,
+	//HEADER_DG_EMPTY = 32,
+	HEADER_DG_LOGIN_WRONG_PASSWD = 33,
+	HEADER_DG_LOGIN_ALREADY = 34,
+
+	HEADER_DG_PLAYER_LOAD_SUCCESS = 35,
+	HEADER_DG_PLAYER_LOAD_FAILED = 36,
+	HEADER_DG_PLAYER_CREATE_SUCCESS = 37,
+	HEADER_DG_PLAYER_CREATE_ALREADY = 38,
+	HEADER_DG_PLAYER_CREATE_FAILED = 39,
+	HEADER_DG_PLAYER_DELETE_SUCCESS = 40,
+	HEADER_DG_PLAYER_DELETE_FAILED = 41,
+
+	HEADER_DG_ITEM_LOAD = 42,
+
+	HEADER_DG_BOOT = 43,
+	HEADER_DG_QUEST_LOAD = 44,
+
+	HEADER_DG_SAFEBOX_LOAD = 45,
+	HEADER_DG_SAFEBOX_CHANGE_SIZE = 46,
+	HEADER_DG_SAFEBOX_WRONG_PASSWORD = 47,
+	HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER = 48,
+
+	HEADER_DG_EMPIRE_SELECT = 49,
+
+	HEADER_DG_AFFECT_LOAD = 50,
+	HEADER_DG_MALL_LOAD = 51,
+
+	//HEADER_DG_EMPTY = 52,
+	//HEADER_DG_EMPTY = 53,
+	//HEADER_DG_EMPTY = 54,
+
+	HEADER_DG_DIRECT_ENTER = 55,
+
+	HEADER_DG_GUILD_SKILL_UPDATE = 56,
+	HEADER_DG_GUILD_SKILL_RECHARGE = 57,
+	HEADER_DG_GUILD_EXP_UPDATE = 58,
+
+	HEADER_DG_PARTY_CREATE = 59,
+	HEADER_DG_PARTY_DELETE = 60,
+	HEADER_DG_PARTY_ADD = 61,
+	HEADER_DG_PARTY_REMOVE = 62,
+	HEADER_DG_PARTY_STATE_CHANGE = 63,
+	HEADER_DG_PARTY_HEAL_USE = 64,
+	HEADER_DG_PARTY_SET_MEMBER_LEVEL = 65,
+
+	//HEADER_DG_EMPTY = 66,
+	//HEADER_DG_EMPTY = 67,
+	//HEADER_DG_EMPTY = 68,
+	//HEADER_DG_EMPTY = 69,
+	//HEADER_DG_EMPTY = 70,
+	//HEADER_DG_EMPTY = 71,
+	//HEADER_DG_EMPTY = 72,
+	//HEADER_DG_EMPTY = 73,
+	//HEADER_DG_EMPTY = 74,
+	//HEADER_DG_EMPTY = 75,
+	//HEADER_DG_EMPTY = 76,
+	//HEADER_DG_EMPTY = 77,
+	//HEADER_DG_EMPTY = 78,
+	//HEADER_DG_EMPTY = 79,
+	//HEADER_DG_EMPTY = 80,
+	//HEADER_DG_EMPTY = 81,
+	//HEADER_DG_EMPTY = 82,
+	//HEADER_DG_EMPTY = 83,
+	//HEADER_DG_EMPTY = 84,
+	//HEADER_DG_EMPTY = 85,
+	//HEADER_DG_EMPTY = 86,
+	//HEADER_DG_EMPTY = 87,
+	//HEADER_DG_EMPTY = 88,
+	//HEADER_DG_EMPTY = 89,
+
+	HEADER_DG_TIME = 90,
+	HEADER_DG_ITEM_ID_RANGE = 91,
+
+	HEADER_DG_GUILD_ADD_MEMBER = 92,
+	HEADER_DG_GUILD_REMOVE_MEMBER = 93,
+	HEADER_DG_GUILD_CHANGE_GRADE = 94,
+	HEADER_DG_GUILD_CHANGE_MEMBER_DATA = 95,
+	HEADER_DG_GUILD_DISBAND = 96,
+	HEADER_DG_GUILD_WAR = 97,
+	HEADER_DG_GUILD_WAR_SCORE = 98,
+	HEADER_DG_GUILD_TIME_UPDATE = 99,
+	HEADER_DG_GUILD_LOAD = 100,
+	HEADER_DG_GUILD_LADDER = 101,
+	HEADER_DG_GUILD_SKILL_USABLE_CHANGE = 102,
+	HEADER_DG_GUILD_MONEY_CHANGE = 103,
+	HEADER_DG_GUILD_WITHDRAW_MONEY_GIVE = 104,
+
+	HEADER_DG_SET_EVENT_FLAG = 105,
+
+	HEADER_DG_GUILD_WAR_RESERVE_ADD = 106,
+	HEADER_DG_GUILD_WAR_RESERVE_DEL = 107,
+	HEADER_DG_GUILD_WAR_BET = 108,
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	HEADER_DG_GUILD_EVENT_FLAG = 109,
+#endif
+	//HEADER_DG_EMPTY = 110,
+	//HEADER_DG_EMPTY = 111,
+	//HEADER_DG_EMPTY = 112,
+	//HEADER_DG_EMPTY = 113,
+	//HEADER_DG_EMPTY = 114,
+	//HEADER_DG_EMPTY = 115,
+	//HEADER_DG_EMPTY = 116,
+	//HEADER_DG_EMPTY = 117,
+	//HEADER_DG_EMPTY = 118,
+	//HEADER_DG_EMPTY = 119,
+	HEADER_DG_RELOAD_PROTO = 120,
+	HEADER_DG_CHANGE_NAME = 121,
+
+	HEADER_DG_AUTH_LOGIN = 122,
+	//HEADER_DG_EMPTY = 123,
+	HEADER_DG_CHANGE_EMPIRE_PRIV = 124,
+	HEADER_DG_CHANGE_GUILD_PRIV = 125,
+
+	HEADER_DG_MONEY_LOG = 126,
+
+	HEADER_DG_CHANGE_CHARACTER_PRIV = 127,
+
+	//HEADER_DG_EMPTY = 128,
+	//HEADER_DG_EMPTY = 129,
+	//HEADER_DG_EMPTY = 130,
+	//HEADER_DG_EMPTY = 131,
+	//HEADER_DG_EMPTY = 132,
+	//HEADER_DG_EMPTY = 133,
+	//HEADER_DG_EMPTY = 134,
+	//HEADER_DG_EMPTY = 135,
+	//HEADER_DG_EMPTY = 136,
+	//HEADER_DG_EMPTY = 137,
+	//HEADER_DG_EMPTY = 138,
+	//HEADER_DG_EMPTY = 139,
+	HEADER_DG_CREATE_OBJECT = 140,
+	HEADER_DG_DELETE_OBJECT = 141,
+	HEADER_DG_UPDATE_LAND = 142,
+	//HEADER_DG_EMPTY = 143,
+	//HEADER_DG_EMPTY = 144,
+	//HEADER_DG_EMPTY = 145,
+	//HEADER_DG_EMPTY = 146,
+	//HEADER_DG_EMPTY = 147,
+	//HEADER_DG_EMPTY = 148,
+	//HEADER_DG_EMPTY = 149,
+	HEADER_DG_MARRIAGE_ADD = 150,
+	HEADER_DG_MARRIAGE_UPDATE = 151,
+	HEADER_DG_MARRIAGE_REMOVE = 152,
+
+	HEADER_DG_WEDDING_REQUEST = 153,
+	HEADER_DG_WEDDING_READY = 154,
+	HEADER_DG_WEDDING_START = 155,
+	HEADER_DG_WEDDING_END = 156,
+
+	HEADER_DG_MYSHOP_PRICELIST_RES = 157, /// <  트 
+	HEADER_DG_RELOAD_ADMIN = 158, /// < 楮  琯
+	HEADER_DG_BREAK_MARRIAGE = 159, /// < 혼 캇
+	HEADER_DG_ELECT_MONARCH = 160, /// <  표
+	HEADER_DG_CANDIDACY = 161, /// <  
+	HEADER_DG_ADD_MONARCH_MONEY = 162, /// <   
+	HEADER_DG_TAKE_MONARCH_MONEY = 163, /// <   
+	HEADER_DG_COME_TO_VOTE = 164, /// < 표
+	HEADER_DG_RMCANDIDACY = 165, /// < 캤  (楮)
+	HEADER_DG_SETMONARCH = 166, /// < 玲 (楮)
+	HEADER_DG_RMMONARCH = 167, /// < 怜
+	HEADER_DG_DEC_MONARCH_MONEY = 168,
+
+	HEADER_DG_CHANGE_MONARCH_LORD_ACK = 169,
+	HEADER_DG_UPDATE_MONARCH_INFO = 170,
+	HEADER_DG_BLOCK_COUNTRY_IP = 171, // 肉 IP-Block
+	HEADER_DG_BLOCK_EXCEPTION = 172, // 肉 IP-Block  account
+
+	HEADER_DG_ACK_CHANGE_GUILD_MASTER = 173,
+
+	HEADER_DG_ACK_SPARE_ITEM_ID_RANGE = 174,
+
+	HEADER_DG_UPDATE_HORSE_NAME = 175,
+	HEADER_DG_ACK_HORSE_NAME = 176,
+
+	HEADER_DG_NEED_LOGIN_LOG = 177,
+
+	HEADER_DG_RESULT_CHARGE_CASH = 179,
+	HEADER_DG_ITEMAWARD_INFORMER = 180, // gift notify
+	HEADER_DG_RESPOND_CHANNELSTATUS = 181,
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	HEADER_DG_EMOTE_LOAD = 182,
+	HEADER_DG_EMOTE_GET = 183,
+#endif
+#if defined(__MOVE_CHANNEL__)
+	HEADER_DG_CHANNEL_RESULT = 185,
+#endif
+	//HEADER_DG_EMPTY = 186,
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	HEADER_DG_EXT_BATTLE_PASS_LOAD = 187,
+#endif
+
+	//HEADER_DG_EMPTY = 188,
+	//HEADER_DG_EMPTY = 189,
+#if defined(__MAILBOX__)
+	HEADER_DG_RESPOND_MAILBOX_LOAD = 190,
+	HEADER_DG_RESPOND_MAILBOX_CHECK_NAME = 191,
+	HEADER_DG_RESPOND_MAILBOX_UNREAD = 192,
+#endif
+	//HEADER_DG_EMPTY = 193,
+	//HEADER_DG_EMPTY = 194,
+
+#ifdef __GROWTH_PET_SYSTEM__
+	HEADER_DG_GROWTH_PET_LOAD		= 187,
+#endif
+
+#if defined(__GEM_SHOP__)
+	HEADER_DG_GEM_SHOP_LOAD = 196,
+	HEADER_DG_GEM_SHOP_UPDATE = 197,
+#endif
+	//HEADER_DG_EMPTY = 198,
+#ifdef __SHOP_SEARCH__
+	HEADER_DG_SHOP_SEARCH_RESULT = 199,
+	HEADER_DG_SHOP_SEARCH_BUY_RESULT = 200,
+	HEADER_DG_SHOP_SEARCH_BUY_FROM_SHOP = 201,
+	HEADER_DG_SHOP_SEARCH_SOLD_INFO = 202,
+#endif
+
+	//HEADER_DG_EMPTY = 204,
+	//HEADER_DG_EMPTY = 205,
+	//HEADER_DG_EMPTY = 206,
+	//HEADER_DG_EMPTY = 207,
+	//HEADER_DG_EMPTY = 208,
+	//HEADER_DG_EMPTY = 209,
+	//HEADER_DG_EMPTY = 210,
+	//HEADER_DG_EMPTY = 211,
+	//HEADER_DG_EMPTY = 212,
+	//HEADER_DG_EMPTY = 213,
+	//HEADER_DG_EMPTY = 214,
+	//HEADER_DG_EMPTY = 215,
+	//HEADER_DG_EMPTY = 216,
+	//HEADER_DG_EMPTY = 217,
+	//HEADER_DG_EMPTY = 218,
+	//HEADER_DG_EMPTY = 219,
+	//HEADER_DG_EMPTY = 220,
+	//HEADER_DG_EMPTY = 221,
+	//HEADER_DG_EMPTY = 222,
+	//HEADER_DG_EMPTY = 223,
+	//HEADER_DG_EMPTY = 224,
+	//HEADER_DG_EMPTY = 225,
+	//HEADER_DG_EMPTY = 226,
+	//HEADER_DG_EMPTY = 227,
+	//HEADER_DG_EMPTY = 228,
+	//HEADER_DG_EMPTY = 229,
+	//HEADER_DG_EMPTY = 230,
+	//HEADER_DG_EMPTY = 231,
+	//HEADER_DG_EMPTY = 232,
+	//HEADER_DG_EMPTY = 233,
+	//HEADER_DG_EMPTY = 234,
+	//HEADER_DG_EMPTY = 235,
+	//HEADER_DG_EMPTY = 236,
+	//HEADER_DG_EMPTY = 237,
+	//HEADER_DG_EMPTY = 238,
+	//HEADER_DG_EMPTY = 239,
+	//HEADER_DG_EMPTY = 240,
+	//HEADER_DG_EMPTY = 241,
+	//HEADER_DG_EMPTY = 242,
+	//HEADER_DG_EMPTY = 243,
+	//HEADER_DG_EMPTY = 244,
+	//HEADER_DG_EMPTY = 245,
+	//HEADER_DG_EMPTY = 246,
+	//HEADER_DG_EMPTY = 247,
+	//HEADER_DG_EMPTY = 248,
+	//HEADER_DG_EMPTY = 249,
+
+#ifdef __OFFLINE_SHOP__
+	HEADER_DG_RESPOND_OFFLINE_SHOP_ID = 250,
+#endif
+
+	//HEADER_DG_EMPTY = 251,
+	//HEADER_DG_EMPTY = 252,
+	//HEADER_DG_EMPTY = 253,
+	HEADER_DG_MAP_LOCATIONS = 0xfe, // 254
+	HEADER_DG_P2P = 0xff, // 255
+};
+
+/* game Server -> DB Server */
+#pragma pack(1)
+enum ERequestChargeType
+{
+	ERequestCharge_Cash = 0,
+	ERequestCharge_Mileage,
+};
+
+typedef struct SRequestChargeCash
+{
+	DWORD dwAID; // id(primary key) - Account Table
+	DWORD dwAmount;
+	ERequestChargeType eChargeType;
+
+} TRequestChargeCash;
+
+typedef struct SSimplePlayer
+{
+	DWORD dwID;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	BYTE byJob;
+	BYTE byLevel;
+	DWORD dwPlayMinutes;
+	BYTE byST, byHT, byDX, byIQ;
+	DWORD dwMainPart;
+	BYTE bChangeName;
+	DWORD dwHairPart;
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	DWORD dwAccePart;
+#endif
+	BYTE bDummy[4];
+	long x, y;
+	long lAddr;
+	WORD wPort;
+	BYTE skill_group;
+	DWORD last_play;
+#if defined(__CONQUEROR_LEVEL__)
+	BYTE byConquerorLevel;
+	BYTE bySungmaStr, bySungmaHp, bySungmaMove, bySungmaImmune;
+#endif
+} TSimplePlayer;
+
+typedef struct SAccountTable
+{
+	DWORD id;
+	char login[LOGIN_MAX_LEN + 1];
+	char passwd[PASSWD_MAX_LEN + 1];
+	char social_id[SOCIAL_ID_MAX_LEN + 1];
+	char status[ACCOUNT_STATUS_MAX_LEN + 1];
+	BYTE bEmpire;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char country[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+	TSimplePlayer players[PLAYER_PER_ACCOUNT];
+} TAccountTable;
+
+typedef struct SPacketDGCreateSuccess
+{
+	BYTE bAccountCharacterIndex;
+	TSimplePlayer player;
+} TPacketDGCreateSuccess;
+
+typedef struct SPlayerItemAttribute
+{
+	POINT_TYPE wType;
+	POINT_VALUE lValue;
+#if defined(__ITEM_APPLY_RANDOM__)
+	BYTE bPath;
+#endif
+} TPlayerItemAttribute;
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+typedef struct SPlayerItemRefineElement
+{
+	WORD wApplyType;
+	BYTE bGrade;
+	BYTE abValue[REFINE_ELEMENT_MAX];
+	BYTE abBonusValue[REFINE_ELEMENT_MAX];
+	SPlayerItemRefineElement()
+	{
+		wApplyType = 0;
+		bGrade = 0;
+		memset(&abValue, 0, sizeof(abValue));
+		memset(&abBonusValue, 0, sizeof(abBonusValue));
+	}
+} TPlayerItemRefineElement;
+#endif
+
+typedef struct SPlayerItem
+{
+	DWORD dwID;
+	DWORD dwOwner;
+
+	BYTE bWindow;
+	WORD wPos;
+
+	DWORD dwVnum;
+	DWORD dwCount;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	long lSealDate;
+#endif
+
+	long alSockets[ITEM_SOCKET_MAX_NUM]; // 球호
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+} TPlayerItem;
+
+typedef struct packet_item
+{
+	DWORD dwVnum;
+	DWORD dwCount;
+	DWORD dwFlags;
+	DWORD dwAntiFlags;
+#if defined(__SOUL_BIND_SYSTEM__)
+	long lSealDate;
+#endif
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+	packet_item()
+	{
+		memset(&alSockets, 0, sizeof(alSockets));
+		memset(&aAttr, 0, sizeof(aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		dwTransmutationVnum = 0;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		memset(&RefineElement, 0, sizeof(RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+		memset(&aApplyRandom, 0, sizeof(aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+		bSetValue = 0;
+#endif
+	}
+} TItemData;
+
+typedef struct SQuickslot
+{
+	BYTE type;
+	WORD pos;
+} TQuickslot;
+
+typedef struct SPlayerSkill
+{
+	BYTE bMasterType;
+	BYTE bLevel;
+	time_t tNextRead;
+} TPlayerSkill;
+
+typedef struct SHorseInfo
+{
+	BYTE bLevel;
+	BYTE bRiding;
+	short sStamina;
+	short sHealth;
+	DWORD dwHorseHealthDropTime;
+} THorseInfo;
+
+typedef struct SPlayerTable
+{
+	DWORD id;
+
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	char ip[IP_ADDRESS_LENGTH + 1];
+
+	WORD job;
+	BYTE voice;
+
+	BYTE level;
+	BYTE level_step;
+	short st, ht, dx, iq;
+
+	DWORD exp;
+	int gold;
+#if defined(__CHEQUE_SYSTEM__)
+	int cheque;
+#endif
+#if defined(__GEM_SYSTEM__)
+	int gem;
+#endif
+
+	BYTE dir;
+	INT x, y, z;
+	INT lMapIndex;
+
+	long lExitX, lExitY;
+	long lExitMapIndex;
+
+	int hp;
+	int sp;
+
+	short sRandomHP;
+	short sRandomSP;
+
+	int playtime;
+
+	short stat_point;
+	short skill_point;
+	short sub_skill_point;
+	short horse_skill_point;
+
+	TPlayerSkill skills[SKILL_MAX_NUM];
+
+	TQuickslot quickslot[QUICKSLOT_MAX_NUM];
+
+	BYTE part_base;
+	DWORD adwParts[PART_MAX_NUM];
+
+	short stamina;
+
+	BYTE skill_group;
+	long lAlignment;
+
+	short stat_reset_count;
+
+	THorseInfo horse;
+
+	DWORD logoff_interval;
+	DWORD last_play;
+
+	int aiPremiumTimes[PREMIUM_MAX_NUM];
+
+#if defined(__CONQUEROR_LEVEL__)
+	BYTE conqueror_level;
+	BYTE conqueror_level_step;
+	short sungma_str, sungma_hp, sungma_move, sungma_immune;
+	DWORD conqueror_exp;
+	short conqueror_point;
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	BYTE inven_stage;
+#endif
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	int battle_pass_premium_id;
+#endif
+} TPlayerTable;
+
+#ifdef __GROWTH_PET_SYSTEM__
+typedef struct SPetSkill
+{
+	bool	bLocked;
+	BYTE	bSkill;
+	BYTE	bLevel;
+	DWORD	dwCooltime;
+
+	SPetSkill()
+	{
+		bLocked = true;
+		bSkill = 0;
+		bLevel = 0;
+		dwCooltime = 0;
+	}
+} TPetSkill;
+
+typedef struct SGrowthPet
+{
+	DWORD	dwID;
+	DWORD	dwOwner;
+	DWORD	dwVnum;
+	BYTE	bState;
+	char	szName[PET_NAME_MAX_SIZE + 1];
+	BYTE	bSize;
+
+	DWORD	dwLevel;
+	BYTE	bLevelStep;
+	BYTE	bEvolution;
+	BYTE	bType;
+	DWORD	dwHP;
+	DWORD	dwSP;
+	DWORD	dwDef;
+
+	DWORD	dwHPApply;
+	DWORD	dwSPApply;
+	DWORD	dwDefApply;
+	DWORD	dwAgeApply;
+
+	TPetSkill	aSkill[PET_SKILL_COUNT_MAX];
+
+	DWORD	lExp;
+	DWORD	lItemExp;
+
+	time_t	lBirthday;
+	time_t	lEndTime;
+	time_t	lMaxTime;
+} TGrowthPet;
+
+typedef struct SGrowthPetSkillTable
+{
+	DWORD	dwPetVnum;
+	DWORD	dwSkillVnum;
+	char	szName[32 + 1];
+	BYTE	bType;
+	DWORD	dwCooldown;
+	DWORD	dwAffectFlag;
+
+	char	szPointOn[64];
+	char	szPointPoly1[100 + 1];
+	char	szPointPoly2[100 + 1];
+	char	szPointPoly3[100 + 1];
+	char	szPointPoly4[100 + 1];
+	char	szPointPoly5[100 + 1];
+	char	szPointPoly6[100 + 1];
+	char	szPointPoly7[100 + 1];
+	char	szPointPoly8[100 + 1];
+	char	szActivatePctPoly[100 + 1];
+	char	szDurationPoly[100 + 1];
+} TGrowthPetSkillTable;
+#endif
+
+typedef struct SMobSkillLevel
+{
+	DWORD dwVnum;
+	BYTE bLevel;
+} TMobSkillLevel;
+
+typedef struct SEntityTable
+{
+	DWORD dwVnum;
+} TEntityTable;
+
+typedef struct SMobTable : public SEntityTable
+{
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	char szLocaleName[CHARACTER_NAME_MAX_LEN + 1];
+
+	BYTE bType; // Monster, NPC
+	BYTE bRank; // PAWN, KNIGHT, KING
+	BYTE bBattleType; // MELEE, etc..
+	BYTE bLevel;
+	BYTE bScale;
+	BYTE bSize;
+
+	DWORD dwGoldMin;
+	DWORD dwGoldMax;
+	DWORD dwExp;
+	DWORD dwSungMaExp;
+	DWORD dwMaxHP;
+	BYTE bRegenCycle;
+	BYTE bRegenPercent;
+	WORD wDef;
+
+	DWORD dwAIFlag;
+	DWORD dwRaceFlag;
+	DWORD dwImmuneFlag;
+
+	BYTE bStr, bDex, bCon, bInt;
+	BYTE bSungMaStr, bSungMaDex, bSungMaCon, bSungMaInt;
+	DWORD dwDamageRange[2];
+
+	short sAttackSpeed;
+	short sMovingSpeed;
+
+	BYTE bAggressiveHPPct;
+	WORD wAggressiveSight;
+	WORD wAttackRange;
+
+	char cEnchants[MOB_ENCHANTS_MAX_NUM];
+	char cResists[MOB_RESISTS_MAX_NUM];
+	char cElements[MOB_ELEMENT_MAX_NUM];
+	char cResistDark, cResistIce, cResistEarth;
+
+	DWORD dwResurrectionVnum;
+	DWORD dwDropItemVnum;
+
+	BYTE bMountCapacity;
+	BYTE bOnClickType;
+
+	BYTE bEmpire;
+	char szFolder[CHARACTER_FOLDER_MAX_LEN + 1];
+
+	float fDamMultiply;
+
+	DWORD dwSummonVnum;
+	DWORD dwDrainSP;
+	DWORD dwMobColor;
+	DWORD dwPolymorphItemVnum;
+
+	TMobSkillLevel Skills[MOB_SKILL_MAX_NUM];
+
+	BYTE bBerserkPoint;
+	BYTE bStoneSkinPoint;
+	BYTE bGodSpeedPoint;
+	BYTE bDeathBlowPoint;
+	BYTE bRevivePoint;
+
+	BYTE bHealPoint;
+
+	BYTE bRAttSpeedPoint;
+	BYTE bRCastSpeedPoint;
+
+	BYTE bRHPRegenPoint;
+
+	float fHitRange;
+} TMobTable;
+
+typedef struct SSkillTable
+{
+	DWORD dwVnum;
+	char szName[32 + 1];
+	BYTE bType;
+	BYTE bMaxLevel;
+	DWORD dwSplashRange;
+
+	char szPointOn[64];
+	char szPointPoly[100 + 1];
+	char szSPCostPoly[100 + 1];
+	char szDurationPoly[100 + 1];
+	char szDurationSPCostPoly[100 + 1];
+	char szCooldownPoly[100 + 1];
+	char szMasterBonusPoly[100 + 1];
+	//char szAttackGradePoly[100 + 1];
+	char szGrandMasterAddSPCostPoly[100 + 1];
+	DWORD dwFlag;
+	DWORD dwAffectFlag;
+
+	// Data for secondary skill
+	char szPointOn2[64];
+	char szPointPoly2[100 + 1];
+	char szDurationPoly2[100 + 1];
+	DWORD dwAffectFlag2;
+
+	// Data for grand master point
+	char szPointOn3[64];
+	char szPointPoly3[100 + 1];
+	char szDurationPoly3[100 + 1];
+
+	BYTE bLevelStep;
+	BYTE bLevelLimit;
+	DWORD preSkillVnum;
+	BYTE preSkillLevel;
+
+	long lMaxHit;
+	char szSplashAroundDamageAdjustPoly[100 + 1];
+
+	BYTE bSkillAttrType;
+
+	DWORD dwTargetRange;
+} TSkillTable;
+
+typedef struct SShopItemTable
+{
+	DWORD vnum;
+	DWORD count;
+
+	TItemPos pos; // PC  結
+	DWORD price; // PC, shop_table_ex.txt  結
+#if defined(__CHEQUE_SYSTEM__)
+	DWORD cheque;
+#endif
+	BYTE display_pos; // PC, shop_table_ex.txt  結,  치.
+#if defined(__SHOPEX_RENEWAL__)
+	BYTE bPriceType;
+	DWORD dwPriceVnum;
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	SShopItemTable() : bPriceType(SHOP_COIN_TYPE_GOLD), dwPriceVnum(0)
+	{
+		memset(&alSockets, 0, sizeof(alSockets));
+	}
+#endif
+} TShopItemTable;
+
+typedef struct SShopTable
+{
+	DWORD dwVnum;
+	DWORD dwNPCVnum;
+	BYTE bItemCount;
+#if defined(__MYSHOP_EXPANSION__)
+	TShopItemTable items[SHOP_HOST_ITEM_MAX];
+#else
+	TShopItemTable items[SHOP_HOST_ITEM_MAX_NUM];
+#endif
+} TShopTable;
+
+#define QUEST_NAME_MAX_LEN 50 // 32
+#define QUEST_STATE_MAX_LEN 64
+
+typedef struct SQuestTable
+{
+	DWORD dwPID;
+	char szName[QUEST_NAME_MAX_LEN + 1];
+	char szState[QUEST_STATE_MAX_LEN + 1];
+	long lValue;
+} TQuestTable;
+
+typedef struct SItemLimit
+{
+	BYTE bType;
+	long lValue;
+} TItemLimit;
+
+typedef struct SItemApply
+{
+	POINT_TYPE wType;
+	POINT_VALUE lValue;
+} TItemApply;
+
+typedef struct SItemTable : public SEntityTable
+{
+	DWORD dwVnumRange;
+	char szName[ITEM_NAME_MAX_LEN + 1];
+	char szLocaleName[ITEM_NAME_MAX_LEN + 1];
+	BYTE bType;
+	BYTE bSubType;
+
+	BYTE bWeight;
+	BYTE bSize;
+
+	uint64_t ullAntiFlags;
+	DWORD dwFlags;
+	DWORD dwWearFlags;
+	DWORD dwImmuneFlag;
+
+	DWORD dwShopBuyPrice;
+	DWORD dwShopSellPrice;
+
+	TItemLimit aLimits[ITEM_LIMIT_MAX_NUM];
+	TItemApply aApplies[ITEM_APPLY_MAX_NUM];
+	long alValues[ITEM_VALUES_MAX_NUM];
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	DWORD dwRefinedVnum;
+	WORD wRefineSet;
+	DWORD dw67AttrMaterial;
+	BYTE bAlterToMagicItemPct;
+	BYTE bSpecular;
+	BYTE bGainSocketPct;
+
+	short int sAddonType; // 羞 憺
+
+	// 틔 limit flag realtime 체크   ,  VNUM  琯,
+	//   탁 肪 却 荑 LIMIT_MAX_NUM 庸 체크求 構 커 見   .
+	char cLimitRealTimeFirstUseIndex; //  limit 茄弱 傷 LIMIT_REAL_TIME_FIRST_USE 첨 치 ( -1)
+	char cLimitTimerBasedOnWearIndex; //  limit 茄弱 傷 LIMIT_TIMER_BASED_ON_WEAR 첨 치 ( -1)
+
+	char* GetOriginalName() { return szName; }
+	DWORD GetVNum() { return dwVnum; }
+	char* GetName() { return szLocaleName; }
+
+	BYTE GetType() { return bType; }
+	BYTE GetSubType() { return bSubType; }
+	BYTE GetWeight() { return bWeight; }
+	BYTE GetSize() { return bSize; }
+
+	uint64_t GetAntiFlags() { return ullAntiFlags; }
+	DWORD GetWearFlags() { return dwWearFlags; }
+	DWORD GetImmuneFlags() { return dwImmuneFlag; }
+
+	DWORD GetBuyPrice() { return dwShopBuyPrice; }
+	DWORD GetSellPrice() { return dwShopSellPrice; }
+
+	long GetValue(unsigned int index)
+	{
+		return alValues[index];
+	}
+
+	BYTE GetLimitType(DWORD idx) const { return aLimits[idx].bType; }
+	long GetLimitValue(DWORD idx) const { return aLimits[idx].lValue; }
+
+	// Weapon
+	bool IsWeapon() { return GetType() == ITEM_WEAPON; }
+	bool IsSword() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_SWORD; }
+	bool IsDagger() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_DAGGER; }
+	bool IsBow() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_BOW; }
+	bool IsTwoHandSword() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_TWO_HANDED; }
+	bool IsBell() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_BELL; }
+	bool IsFan() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_FAN; }
+	bool IsArrow() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_ARROW; }
+	bool IsMountSpear() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_MOUNT_SPEAR; }
+	bool IsClaw() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_CLAW; }
+#if defined(__QUIVER_SYSTEM__)
+	bool IsQuiver() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_QUIVER; }
+#endif
+
+	// Armor
+	bool IsArmor() { return GetType() == ITEM_ARMOR; }
+	bool IsArmorBody() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_BODY; }
+	bool IsHelmet() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_HEAD; }
+	bool IsShield() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_SHIELD; }
+	bool IsWrist() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_WRIST; }
+	bool IsShoe() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_FOOTS; }
+	bool IsNecklace() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_NECK; }
+	bool IsEarRing() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_EAR; }
+
+	bool IsBelt() { return GetType() == ITEM_BELT; }
+	bool IsRing() { return GetType() == ITEM_RING; }
+
+	// Costume
+	bool IsCostume() { return GetType() == ITEM_COSTUME; }
+	bool IsCostumeBody() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_BODY; }
+	bool IsCostumeHair() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_HAIR; }
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	bool IsCostumeMount() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_MOUNT; }
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	bool IsCostumeAcce() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_ACCE; }
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+	bool IsCostumeWeapon() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_WEAPON; }
+#endif
+#if defined(__MOVE_COSTUME_ATTR__)
+	bool IsCostumeModifyItem() { return GetType() == ITEM_USE && (GetSubType() == USE_CHANGE_COSTUME_ATTR || GetSubType() == USE_RESET_COSTUME_ATTR); }
+#endif
+
+	bool CanUseByJob(BYTE bJob)
+	{
+		switch (bJob)
+		{
+		case JOB_WARRIOR:
+			if (GetAntiFlags() & ITEM_ANTIFLAG_WARRIOR)
+				return false;
+			break;
+		case JOB_ASSASSIN:
+			if (GetAntiFlags() & ITEM_ANTIFLAG_ASSASSIN)
+				return false;
+			break;
+		case JOB_SHAMAN:
+			if (GetAntiFlags() & ITEM_ANTIFLAG_SHAMAN)
+				return false;
+			break;
+		case JOB_SURA:
+			if (GetAntiFlags() & ITEM_ANTIFLAG_SURA)
+				return false;
+			break;
+		case JOB_WOLFMAN:
+			if (GetAntiFlags() & ITEM_ANTIFLAG_WOLFMAN)
+				return false;
+			break;
+		}
+		return true;
+	}
+
+	POINT_VALUE FindApplyValue(POINT_TYPE dwType)
+	{
+		for (BYTE bIndex = 0; bIndex < ITEM_APPLY_MAX_NUM; ++bIndex)
+		{
+			if (aApplies[bIndex].wType == dwType)
+				return aApplies[bIndex].lValue;
+		}
+		return 0;
+	}
+
+} TItemTable;
+
+struct TItemAttrTable
+{
+	TItemAttrTable() :
+		wApplyIndex(0),
+		dwProb(0)
+	{
+		szApply[0] = 0;
+		memset(&lValues, 0, sizeof(lValues));
+		memset(&bMaxLevelBySet, 0, sizeof(bMaxLevelBySet));
+	}
+
+	char szApply[APPLY_NAME_MAX_LEN + 1];
+	POINT_TYPE wApplyIndex;
+	DWORD dwProb;
+	POINT_VALUE lValues[ITEM_ATTRIBUTE_MAX_LEVEL];
+	BYTE bMaxLevelBySet[ATTRIBUTE_SET_MAX_NUM];
+};
+
+typedef struct SConnectTable
+{
+	char login[LOGIN_MAX_LEN + 1];
+	IDENT ident;
+} TConnectTable;
+
+typedef struct SLoginPacket
+{
+	char login[LOGIN_MAX_LEN + 1];
+	char passwd[PASSWD_MAX_LEN + 1];
+} TLoginPacket;
+
+typedef struct SPlayerLoadPacket
+{
+	DWORD account_id;
+	DWORD player_id;
+	BYTE account_index; /* account  치 */
+} TPlayerLoadPacket;
+
+typedef struct SPlayerCreatePacket
+{
+	char login[LOGIN_MAX_LEN + 1];
+	char passwd[PASSWD_MAX_LEN + 1];
+	DWORD account_id;
+	BYTE account_index;
+	TPlayerTable player_table;
+} TPlayerCreatePacket;
+
+typedef struct SPlayerDeletePacket
+{
+	char login[LOGIN_MAX_LEN + 1];
+	DWORD player_id;
+	BYTE account_index;
+	//char name[CHARACTER_NAME_MAX_LEN + 1];
+	char private_code[8];
+} TPlayerDeletePacket;
+
+#if defined(__DELETE_FAILURE_TYPE__)
+typedef struct SPlayerDeleteFailurePacket
+{
+	BYTE bType;
+	INT iTime;
+} TPlayerDeleteFailurePacket;
+#endif
+
+typedef struct SLogoutPacket
+{
+	char login[LOGIN_MAX_LEN + 1];
+	char passwd[PASSWD_MAX_LEN + 1];
+} TLogoutPacket;
+
+typedef struct SPlayerCountPacket
+{
+	DWORD dwCount;
+} TPlayerCountPacket;
+
+#if defined(__EXTEND_MALLBOX__)
+#	define SAFEBOX_MAX_NUM 225 // 45 (Slots) * 5 (Pages)
+#else
+#	define SAFEBOX_MAX_NUM 135 // 45 (Slots) * 3 (Pages)
+#endif
+#define SAFEBOX_PASSWORD_MAX_LEN 6
+
+typedef struct SSafeboxTable
+{
+	DWORD dwID;
+	BYTE bSize;
+	DWORD dwGold;
+	WORD wItemCount;
+} TSafeboxTable;
+
+typedef struct SSafeboxChangeSizePacket
+{
+	DWORD dwID;
+	BYTE bSize;
+} TSafeboxChangeSizePacket;
+
+typedef struct SSafeboxLoadPacket
+{
+	DWORD dwID;
+	char szLogin[LOGIN_MAX_LEN + 1];
+	char szPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
+} TSafeboxLoadPacket;
+
+typedef struct SSafeboxChangePasswordPacket
+{
+	DWORD dwID;
+	char szOldPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
+	char szNewPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
+} TSafeboxChangePasswordPacket;
+
+typedef struct SSafeboxChangePasswordPacketAnswer
+{
+	BYTE flag;
+} TSafeboxChangePasswordPacketAnswer;
+
+typedef struct SEmpireSelectPacket
+{
+	DWORD dwAccountID;
+	BYTE bEmpire;
+} TEmpireSelectPacket;
+
+typedef struct SPacketGDSetup
+{
+	char szPublicIP[16]; // Public IP which listen to users
+	BYTE bChannel; // 채
+	WORD wListenPort; // 클潔트 求 트 호
+	WORD wP2PPort; //   키 P2P 트 호
+	long alMaps[MAX_MAP_ALLOW];
+	DWORD dwLoginCount;
+	BYTE bAuthServer;
+} TPacketGDSetup;
+
+typedef struct SPacketDGMapLocations
+{
+	BYTE bCount;
+} TPacketDGMapLocations;
+
+typedef struct SMapLocation
+{
+	long alMaps[MAX_MAP_ALLOW];
+	char szHost[MAX_HOST_LENGTH + 1];
+	WORD wPort;
+} TMapLocation;
+
+typedef struct SPacketDGP2P
+{
+	char szHost[MAX_HOST_LENGTH + 1];
+	WORD wPort;
+	BYTE bChannel;
+} TPacketDGP2P;
+
+typedef struct SPacketGDDirectEnter
+{
+	char login[LOGIN_MAX_LEN + 1];
+	char passwd[PASSWD_MAX_LEN + 1];
+	BYTE index;
+} TPacketGDDirectEnter;
+
+typedef struct SPacketDGDirectEnter
+{
+	TAccountTable accountTable;
+	TPlayerTable playerTable;
+} TPacketDGDirectEnter;
+
+typedef struct SPacketGuildSkillUpdate
+{
+	DWORD guild_id;
+	int amount;
+	BYTE skill_levels[12];
+	BYTE skill_point;
+	BYTE save;
+} TPacketGuildSkillUpdate;
+
+typedef struct SPacketGuildExpUpdate
+{
+	DWORD guild_id;
+	int amount;
+} TPacketGuildExpUpdate;
+
+typedef struct SPacketGuildChangeMemberData
+{
+	DWORD guild_id;
+	DWORD pid;
+	DWORD offer;
+	BYTE level;
+	BYTE grade;
+} TPacketGuildChangeMemberData;
+
+typedef struct SPacketDGLoginAlready
+{
+	char szLogin[LOGIN_MAX_LEN + 1];
+} TPacketDGLoginAlready;
+
+typedef struct TPacketAffectElement
+{
+	DWORD dwType;
+	POINT_TYPE wApplyOn;
+	POINT_VALUE lApplyValue;
+	DWORD dwFlag;
+	long lDuration;
+	long lSPCost;
+#if defined(__AFFECT_RENEWAL__)
+	bool bRealTime;
+	bool bUpdate;
+#endif
+} TPacketAffectElement;
+
+typedef struct SPacketGDAddAffect
+{
+	DWORD dwPID;
+	TPacketAffectElement elem;
+} TPacketGDAddAffect;
+
+typedef struct SPacketGDRemoveAffect
+{
+	DWORD dwPID;
+	DWORD dwType;
+	POINT_TYPE wApplyOn;
+} TPacketGDRemoveAffect;
+
+typedef struct SPacketGDHighscore
+{
+	DWORD dwPID;
+	long lValue;
+	char cDir;
+	char szBoard[21];
+} TPacketGDHighscore;
+
+typedef struct SPacketPartyCreate
+{
+	DWORD dwLeaderPID;
+} TPacketPartyCreate;
+
+typedef struct SPacketPartyDelete
+{
+	DWORD dwLeaderPID;
+} TPacketPartyDelete;
+
+typedef struct SPacketPartyAdd
+{
+	DWORD dwLeaderPID;
+	DWORD dwPID;
+	BYTE bState;
+} TPacketPartyAdd;
+
+typedef struct SPacketPartyRemove
+{
+	DWORD dwLeaderPID;
+	DWORD dwPID;
+} TPacketPartyRemove;
+
+typedef struct SPacketPartyStateChange
+{
+	DWORD dwLeaderPID;
+	DWORD dwPID;
+	BYTE bRole;
+	BYTE bFlag;
+} TPacketPartyStateChange;
+
+typedef struct SPacketPartySetMemberLevel
+{
+	DWORD dwLeaderPID;
+	DWORD dwPID;
+	BYTE bLevel;
+} TPacketPartySetMemberLevel;
+
+typedef struct SPacketGDBoot
+{
+	DWORD dwItemIDRange[2];
+	char szIP[16];
+} TPacketGDBoot;
+
+typedef struct SPacketGuild
+{
+	DWORD dwGuild;
+	DWORD dwInfo;
+} TPacketGuild;
+
+typedef struct SPacketGDGuildAddMember
+{
+	DWORD dwPID;
+	DWORD dwGuild;
+	BYTE bGrade;
+} TPacketGDGuildAddMember;
+
+typedef struct SPacketDGGuildMember
+{
+	DWORD dwPID;
+	DWORD dwGuild;
+	BYTE bGrade;
+	BYTE isGeneral;
+	BYTE bJob;
+	BYTE bLevel;
+	DWORD dwOffer;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketDGGuildMember;
+
+typedef struct SPacketGuildWar
+{
+	BYTE bType;
+	BYTE bWar;
+	DWORD dwGuildFrom;
+	DWORD dwGuildTo;
+	long lWarPrice;
+	long lInitialScore;
+} TPacketGuildWar;
+
+// Game -> DB :  화
+// DB -> Game : 탈 
+typedef struct SPacketGuildWarScore
+{
+	DWORD dwGuildGainPoint;
+	DWORD dwGuildOpponent;
+	long lScore;
+	long lBetScore;
+} TPacketGuildWarScore;
+
+typedef struct SRefineMaterial
+{
+	DWORD vnum;
+	int count;
+} TRefineMaterial;
+
+typedef struct SRefineTable
+{
+	//DWORD src_vnum;
+	//DWORD result_vnum;
+	DWORD id;
+	WORD material_count;
+	int cost; // 奴 
+	int prob; // 확
+	TRefineMaterial materials[REFINE_MATERIAL_MAX_NUM];
+} TRefineTable;
+
+typedef struct SBanwordTable
+{
+	char szWord[BANWORD_MAX_LEN + 1];
+} TBanwordTable;
+
+typedef struct SPacketGDChangeName
+{
+	DWORD pid;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGDChangeName;
+
+typedef struct SPacketDGChangeName
+{
+	DWORD pid;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketDGChangeName;
+
+typedef struct SPacketGuildLadder
+{
+	DWORD dwGuild;
+	long lLadderPoint;
+	long lWin;
+	long lDraw;
+	long lLoss;
+} TPacketGuildLadder;
+
+typedef struct SPacketGuildLadderPoint
+{
+	DWORD dwGuild;
+	long lChange;
+} TPacketGuildLadderPoint;
+
+typedef struct SPacketGuildUseSkill
+{
+	DWORD dwGuild;
+	DWORD dwSkillVnum;
+	DWORD dwCooltime;
+} TPacketGuildUseSkill;
+
+typedef struct SPacketGuildSkillUsableChange
+{
+	DWORD dwGuild;
+	DWORD dwSkillVnum;
+	BYTE bUsable;
+} TPacketGuildSkillUsableChange;
+
+typedef struct SPacketGDLoginKey
+{
+	DWORD dwAccountID;
+	DWORD dwLoginKey;
+} TPacketGDLoginKey;
+
+typedef struct SPacketGDAuthLogin
+{
+	DWORD dwID;
+	DWORD dwLoginKey;
+	char szLogin[LOGIN_MAX_LEN + 1];
+	char szSocialID[SOCIAL_ID_MAX_LEN + 1];
+	DWORD adwClientKey[4];
+	int iPremiumTimes[PREMIUM_MAX_NUM];
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketGDAuthLogin;
+
+typedef struct SPacketGDLoginByKey
+{
+	char szLogin[LOGIN_MAX_LEN + 1];
+	DWORD dwLoginKey;
+	DWORD adwClientKey[4];
+	char szIP[MAX_HOST_LENGTH + 1];
+} TPacketGDLoginByKey;
+
+/**
+* @version 05/06/08 Bang2ni - 擔챨 煞
+**/
+typedef struct SPacketGiveGuildPriv
+{
+	BYTE type;
+	int value;
+	DWORD guild_id;
+	time_t duration_sec; ///< 擔챨
+} TPacketGiveGuildPriv;
+
+typedef struct SPacketGiveEmpirePriv
+{
+	BYTE type;
+	int value;
+	BYTE empire;
+	time_t duration_sec;
+} TPacketGiveEmpirePriv;
+
+typedef struct SPacketGiveCharacterPriv
+{
+	BYTE type;
+	int value;
+	DWORD pid;
+} TPacketGiveCharacterPriv;
+
+typedef struct SPacketRemoveGuildPriv
+{
+	BYTE type;
+	DWORD guild_id;
+} TPacketRemoveGuildPriv;
+
+typedef struct SPacketRemoveEmpirePriv
+{
+	BYTE type;
+	BYTE empire;
+} TPacketRemoveEmpirePriv;
+
+typedef struct SPacketDGChangeCharacterPriv
+{
+	BYTE type;
+	int value;
+	DWORD pid;
+	BYTE bLog;
+} TPacketDGChangeCharacterPriv;
+
+/**
+* @version 05/06/08 Bang2ni - 擔챨 煞
+**/
+typedef struct SPacketDGChangeGuildPriv
+{
+	BYTE type;
+	int value;
+	DWORD guild_id;
+	BYTE bLog;
+	time_t end_time_sec; ///< 擔챨
+} TPacketDGChangeGuildPriv;
+
+typedef struct SPacketDGChangeEmpirePriv
+{
+	BYTE type;
+	int value;
+	BYTE empire;
+	BYTE bLog;
+	time_t end_time_sec;
+} TPacketDGChangeEmpirePriv;
+
+typedef struct SPacketMoneyLog
+{
+	BYTE type;
+	DWORD vnum;
+	int gold;
+#if defined(__CHEQUE_SYSTEM__)
+	int cheque;
+#endif
+} TPacketMoneyLog;
+
+typedef struct SPacketGDGuildMoney
+{
+	DWORD dwGuild;
+	INT iGold;
+} TPacketGDGuildMoney;
+
+typedef struct SPacketDGGuildMoneyChange
+{
+	DWORD dwGuild;
+	INT iTotalGold;
+} TPacketDGGuildMoneyChange;
+
+typedef struct SPacketDGGuildMoneyWithdraw
+{
+	DWORD dwGuild;
+	INT iChangeGold;
+} TPacketDGGuildMoneyWithdraw;
+
+typedef struct SPacketGDGuildMoneyWithdrawGiveReply
+{
+	DWORD dwGuild;
+	INT iChangeGold;
+	BYTE bGiveSuccess;
+} TPacketGDGuildMoneyWithdrawGiveReply;
+
+typedef struct SPacketSetEventFlag
+{
+	char szFlagName[EVENT_FLAG_NAME_MAX_LEN + 1];
+	long lValue;
+} TPacketSetEventFlag;
+
+typedef struct SPacketLoginOnSetup
+{
+	DWORD dwID;
+	char szLogin[LOGIN_MAX_LEN + 1];
+	char szSocialID[SOCIAL_ID_MAX_LEN + 1];
+	char szHost[MAX_HOST_LENGTH + 1];
+	DWORD dwLoginKey;
+	DWORD adwClientKey[4];
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketLoginOnSetup;
+
+typedef struct SPacketGDCreateObject
+{
+	DWORD dwVnum;
+	DWORD dwLandID;
+	INT lMapIndex;
+	INT x, y;
+	float xRot;
+	float yRot;
+	float zRot;
+} TPacketGDCreateObject;
+
+typedef struct SPacketGDHammerOfTor
+{
+	DWORD key;
+	DWORD delay;
+} TPacketGDHammerOfTor;
+
+typedef struct SGuildReserve
+{
+	DWORD dwID;
+	DWORD dwGuildFrom;
+	DWORD dwGuildTo;
+	DWORD dwTime;
+	BYTE bType;
+	long lWarPrice;
+	long lInitialScore;
+	bool bStarted;
+	DWORD dwBetFrom;
+	DWORD dwBetTo;
+	long lPowerFrom;
+	long lPowerTo;
+	long lHandicap;
+} TGuildWarReserve;
+
+typedef struct
+{
+	DWORD dwWarID;
+	char szLogin[LOGIN_MAX_LEN + 1];
+	DWORD dwGold;
+	DWORD dwGuild;
+} TPacketGDGuildWarBet;
+
+// Marriage
+typedef struct
+{
+	DWORD dwPID1;
+	DWORD dwPID2;
+	time_t tMarryTime;
+	char szName1[CHARACTER_NAME_MAX_LEN + 1];
+	char szName2[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketMarriageAdd;
+
+typedef struct
+{
+	DWORD dwPID1;
+	DWORD dwPID2;
+	INT iLovePoint;
+	BYTE byMarried;
+} TPacketMarriageUpdate;
+
+typedef struct
+{
+	DWORD dwPID1;
+	DWORD dwPID2;
+} TPacketMarriageRemove;
+
+typedef struct
+{
+	DWORD dwPID1;
+	DWORD dwPID2;
+} TPacketWeddingRequest;
+
+typedef struct
+{
+	DWORD dwPID1;
+	DWORD dwPID2;
+	DWORD dwMapIndex;
+} TPacketWeddingReady;
+
+typedef struct
+{
+	DWORD dwPID1;
+	DWORD dwPID2;
+} TPacketWeddingStart;
+
+typedef struct
+{
+	DWORD dwPID1;
+	DWORD dwPID2;
+} TPacketWeddingEnd;
+
+/// 貫  .  킷  悶 byCount 큼 TItemPriceInfo  쨈.
+typedef struct SPacketMyshopPricelistHeader
+{
+	DWORD dwOwnerID; ///<   첨潔 ID
+	BYTE byCount; ///<  
+} TPacketMyshopPricelistHeader;
+
+/// 貫  謗  
+typedef struct SItemPriceInfo
+{
+	DWORD dwVnum; ///<  vnum
+	DWORD dwPrice; ///< 
+#if defined(__CHEQUE_SYSTEM__)
+	DWORD dwCheque;
+#endif
+} TItemPriceInfo;
+
+/// 貫   트 遣
+typedef struct SItemPriceListTable
+{
+	DWORD dwOwnerID; ///<   첨潔 ID
+	BYTE byCount; ///<  트 
+
+	TItemPriceInfo aPriceInfo[SHOP_PRICELIST_MAX_NUM]; ///<  트
+} TItemPriceListTable;
+
+typedef struct
+{
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	long lDuration;
+} TPacketBlockChat;
+
+// PCBANG_IP_LIST
+typedef struct SPacketPCBangIP
+{
+	DWORD id;
+	DWORD ip;
+} TPacketPCBangIP;
+// END_OF_PCBANG_IP_LIST
+
+// ADMIN_MANAGER
+typedef struct TAdminInfo
+{
+	int m_ID; // ID
+	char m_szAccount[32]; // 
+	char m_szName[32]; // 캐見
+	char m_szContactIP[16]; // 毛
+	char m_szServerIP[16]; // 
+	int m_Authority; // 
+} tAdminInfo;
+// END_ADMIN_MANAGER
+
+// BOOT_LOCALIZATION
+struct tLocale
+{
+	char szValue[32];
+	char szKey[32];
+};
+// BOOT_LOCALIZATION
+
+// RELOAD_ADMIN
+typedef struct SPacketReloadAdmin
+{
+	char szIP[16];
+} TPacketReloadAdmin;
+// END_RELOAD_ADMIN
+
+typedef struct TMonarchInfo
+{
+	DWORD pid[4]; //  PID
+	int64_t money[4]; //   
+	char name[4][32]; //  見
+	char date[4][32]; //   짜
+} MonarchInfo;
+
+typedef struct TMonarchElectionInfo
+{
+	DWORD pid; // 표 綺 PID
+	DWORD selectedpid; // 표  PID (   )
+	char date[32]; // 표 짜
+} MonarchElectionInfo;
+
+//  綬
+typedef struct tMonarchCandidacy
+{
+	DWORD pid;
+	char name[32];
+	char date[32];
+} MonarchCandidacy;
+
+typedef struct tChangeMonarchLord
+{
+	BYTE bEmpire;
+	DWORD dwPID;
+} TPacketChangeMonarchLord;
+
+typedef struct tChangeMonarchLordACK
+{
+	BYTE bEmpire;
+	DWORD dwPID;
+	char szName[32];
+	char szDate[32];
+} TPacketChangeMonarchLordACK;
+
+// Block Country Ip
+typedef struct tBlockCountryIp
+{
+	DWORD ip_from;
+	DWORD ip_to;
+} TPacketBlockCountryIp;
+
+enum EBlockExceptionCommand
+{
+	BLOCK_EXCEPTION_CMD_ADD = 1,
+	BLOCK_EXCEPTION_CMD_DEL = 2,
+};
+
+// Block Exception Account
+typedef struct tBlockException
+{
+	BYTE cmd; // 1 == add, 2 == delete
+	char login[LOGIN_MAX_LEN + 1];
+}TPacketBlockException;
+
+typedef struct tChangeGuildMaster
+{
+	DWORD dwGuildID;
+	DWORD idFrom;
+	DWORD idTo;
+} TPacketChangeGuildMaster;
+
+typedef struct tItemIDRange
+{
+	DWORD dwMin;
+	DWORD dwMax;
+	DWORD dwUsableItemIDMin;
+} TItemIDRangeTable;
+
+typedef struct tUpdateHorseName
+{
+	DWORD dwPlayerID;
+	char szHorseName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketUpdateHorseName;
+
+typedef struct tDC
+{
+	char login[LOGIN_MAX_LEN + 1];
+} TPacketDC;
+
+typedef struct tNeedLoginLogInfo
+{
+	DWORD dwPlayerID;
+} TPacketNeedLoginLogInfo;
+
+//   舡  謬트 킷 
+typedef struct tItemAwardInformer
+{
+	char login[LOGIN_MAX_LEN + 1];
+	char command[20]; // 
+	unsigned int vnum; // 
+} TPacketItemAwardInfromer;
+
+//  舡   킷 
+typedef struct tDeleteAwardID
+{
+	DWORD dwID;
+} TPacketDeleteAwardID;
+
+typedef struct SChannelStatus
+{
+	short nPort;
+	BYTE bStatus;
+} TChannelStatus;
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+enum MessengerBlock
+{
+	MESSENGER_BLOCK,
+	MESSENGER_FRIEND
+};
+#endif
+
+#if defined(__MOVE_CHANNEL__)
+typedef struct
+{
+	long lMapIndex;
+	int iChannel;
+} TPacketChangeChannel;
+
+typedef struct
+{
+	long lAddr;
+	WORD wPort;
+} TPacketReturnChannel;
+#endif
+
+#if defined(__MAILBOX__)
+enum EMAILBOX
+{
+	MAILBOX_TAX = 5,
+	MAILBOX_REMAIN_DAY = 30,
+	MAILBOX_REMAIN_DAY_GM = 7,
+	MAILBOX_LEVEL_LIMIT = 20,
+	MAILBOX_PRICE_YANG = 1000,
+	MAILBOX_PAGE_SIZE = 9,
+	MAILBOX_PAGE_COUNT = 10,
+	MAILBOX_MAX_MAIL = MAILBOX_PAGE_SIZE * MAILBOX_PAGE_COUNT,
+};
+
+typedef struct SMailBoxRespondUnreadData
+{
+	SMailBoxRespondUnreadData() :
+		bHeader(0),
+		bItemMessageCount(0),
+		bCommonMessageCount(0),
+		bGMVisible(false)
+	{}
+	BYTE bHeader;
+	BYTE bItemMessageCount;
+	BYTE bCommonMessageCount;
+	bool bGMVisible;
+} TMailBoxRespondUnreadData;
+
+typedef struct SMailBox
+{
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	BYTE Index;
+} TMailBox;
+
+typedef struct packet_mailbox_add_data
+{
+	BYTE bHeader;
+	BYTE Index;
+	char szFrom[CHARACTER_NAME_MAX_LEN + 1];
+	char szMessage[100 + 1];
+	int iYang;
+	int iWon;
+	DWORD dwItemVnum;
+	DWORD dwItemCount;
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwChangeLookVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+} TPacketGCMailBoxAddData;
+
+typedef struct packet_mailbox_message
+{
+	time_t SendTime;
+	time_t DeleteTime;
+	char szTitle[25 + 1];
+	bool bIsGMPost;
+	bool bIsItemExist;
+	bool bIsConfirm;
+} TPacketGCMailBoxMessage;
+
+typedef struct SMailBoxTable
+{
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	bool bIsDeleted;
+	packet_mailbox_message Message;
+	packet_mailbox_add_data AddData;
+} TMailBoxTable;
+#endif
+
+#if defined(__RANKING_SYSTEM__)
+typedef struct SPartyMemberName
+{
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+} TPartyMember;
+
+typedef struct SRankingData
+{
+	char szGuildName[GUILD_NAME_MAX_LEN + 1];
+	SPartyMemberName Member[PARTY_MAX_MEMBER];
+	DWORD dwRecord0, dwRecord1;
+	DWORD dwStartTime;
+	BYTE bEmpire;
+} TRankingData;
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+typedef struct SAttr67AddData
+{
+	SAttr67AddData() : wRegistItemPos(0), byMaterialCount(0), wSupportItemPos(0), bySupportItemCount(0) {}
+	WORD wRegistItemPos;
+	BYTE byMaterialCount;
+	WORD wSupportItemPos;
+	BYTE bySupportItemCount;
+} TAttr67AddData;
+#endif
+
+#if defined(__GEM_SHOP__)
+typedef struct SGemShopLoad
+{
+	DWORD dwPID;
+#	if defined(__CONQUEROR_LEVEL__)
+	bool bSpecial;
+#	endif
+} TGemShopLoad;
+
+typedef struct SGemShopItem
+{
+	bool bEnable;
+	DWORD dwItemVnum;
+	BYTE bCount;
+	DWORD dwPrice;
+} TGemShopItem;
+
+typedef struct SGemShopTable
+{
+	DWORD dwPID;
+	long lRefreshTime;
+	BYTE bEnabledSlots;
+	TGemShopItem GemShopItem[GEM_SHOP_SLOT_COUNT];
+#	if defined(__CONQUEROR_LEVEL__)
+	bool bSpecial;
+#	endif
+} TGemShopTable;
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+typedef struct SPacketGDEmote
+{
+	DWORD dwPID;
+	DWORD dwVnum;
+	DWORD dwDuration;
+} TPacketGDEmote;
+#endif
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+typedef struct SPacketSetGuildEventFlag
+{
+	DWORD dwGuildID;
+	char szFlagName[EVENT_FLAG_NAME_MAX_LEN + 1];
+	long lValue;
+} TPacketSetGuildEventFlag;
+#endif
+
+#ifdef __OFFLINE_SHOP__
+typedef struct SOfflineShop
+{
+	uint32_t id;
+
+	uint32_t ownerPid;
+	std::array<char, CHARACTER_NAME_MAX_LEN + 1> ownerName;
+
+	std::array<char, SHOP_TAB_NAME_MAX + 1> shopName;
+	int32_t shopNameChangeTime;
+	uint8_t channel;
+	uint32_t mapIndex, x, y;
+	uint32_t decoRace;
+	uint8_t decoBoard;
+
+	uint32_t openingTime;
+	int64_t gold;
+} TOfflineShop;
+
+typedef std::pair<uint32_t, uint16_t> TOfflineItemID;
+namespace std {
+	template <> struct hash <TOfflineItemID> {
+		inline size_t operator()(const TOfflineItemID& v) const {
+			std::hash<int> int_hasher;
+			return int_hasher(v.first) ^ int_hasher(v.second);
+		}
+	};
+}
+
+typedef struct SOfflineShopItem
+{
+	TOfflineItemID id;
+
+	uint32_t vnum;
+	uint32_t count;
+	std::array<int32_t, ITEM_SOCKET_MAX_NUM> sockets;
+	std::array<TPlayerItemAttribute, ITEM_ATTRIBUTE_MAX_NUM> attributes;
+#if defined(__ITEM_APPLY_RANDOM__)
+	std::array<TPlayerItemAttribute, ITEM_APPLY_MAX_NUM> ApplyRandom;
+#endif
+	int64_t price;
+#if defined(__SOUL_BIND_SYSTEM__)
+	long soulbind;
+#endif
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+} TOfflineShopItem;
+
+typedef struct SMySellHistory
+{
+	DWORD		pid;
+	DWORD		dwVnum;
+	DWORD		dwCount;
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD 		dwTransmutationVnum;
+#endif
+	long 		alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+	char		szBuyer[CHARACTER_NAME_MAX_LEN+1];
+	long long 	llPrice;
+	int			iTimeStamp;
+	bool		bIsSaved;
+} TMySellHistory;
+
+typedef std::pair<DWORD, DWORD> TShopSearchItemType;
+
+enum EShopSearchData
+{
+	SHOPSEARCH_SOLD_ITEM_INFO_COUNT = 30,
+};
+
+enum EShopSearchBuyResult {
+	SHOPSEARCH_BUY_SUCCESS,
+	SHOPSEARCH_BUY_NOT_EXIST,
+	SHOPSEARCH_BUY_PRICE_CHANGE,
+	SHOPSEARCH_BUY_TIMEOUT,
+	SHOPSEARCH_BUY_NO_PEER,
+	SHOPSEARCH_BUY_UNKNOWN_ERROR,
+};
+
+enum EShopSearchSortTypes {
+	SHOPSEARCH_SORT_RANDOM,
+	SHOPSEARCH_SORT_ASC,
+	SHOPSEARCH_SORT_DESC,
+	SHOPSEARCH_SORT_MAX_NUM,
+};
+
+enum EShopSearchAveragePriceLevels {
+	SHOPSEARCH_AVG_PRICE_GOOD,
+	SHOPSEARCH_AVG_PRICE_NORMAL,
+	SHOPSEARCH_AVG_PRICE_BAD,
+	SHOPSEARCH_AVG_PRICE_WORST,
+};
+
+typedef struct SShopSearchItem : TPlayerItem
+{
+	TOfflineItemID offlineID;
+
+	int64_t price;
+	DWORD endTime;
+} TShopSearchItem;
+
+typedef struct SShopSearchClientItem : SShopSearchItem
+{
+	BYTE	avgPriceLevel;
+} TShopSearchClientItem;
+
+typedef struct SShopSearchOptions
+{
+	BYTE		typeFlagCount;
+	BYTE		specificVnumCount;
+} TShopSearchOptions;
+
+typedef struct SPacketGDShopSearchByName
+{
+	BYTE	langID;
+	char	itemName[ITEM_NAME_MAX_LEN + 1];
+	WORD	page;
+	BYTE	entryCountIdx;
+	BYTE	sortType;
+} TPacketGDShopSearchByName;
+
+typedef struct SPacketGDShopSearchByOptions
+{
+	TShopSearchOptions	options;
+	WORD				page;
+	BYTE				entryCountIdx;
+	BYTE				sortType;
+} TPacketGDShopSearchByOptions;
+
+typedef struct SPacketGDShopSearchRequestBuy
+{
+	DWORD	ownerID;
+	TOfflineItemID	offlineID;
+	DWORD	itemVnum;
+	int64_t	itemPrice;
+	char	szBuyer[CHARACTER_NAME_MAX_LEN+1];
+} TPacketGDShopSearchRequestBuy;
+
+typedef struct SPacketDGShopSearchBuyFromShop
+{
+	DWORD	buyerDBHandle;
+	DWORD	buyerPCHandle;
+	DWORD	buyerPID;
+	DWORD	ownerPID;
+	TOfflineItemID	offlineID;
+	int64_t	itemPrice;
+	char	szBuyer[CHARACTER_NAME_MAX_LEN+1];
+} TPacketDGShopSearchBuyFromShop;
+
+typedef struct SPacketGDShopSearchBoughtFromShop
+{
+	DWORD	buyerDBHandle;
+	TPlayerItem	item;
+} TPacketGDShopSearchBoughtFromShop;
+
+typedef struct SPacketGDShopSearchSoldItem
+{
+	DWORD	itemVnum;
+	DWORD	itemCount;
+	uint64_t	price;
+} TPacketGDShopSearchSoldItem;
+
+typedef struct SShopSearchSoldItemInfo {
+	SShopSearchSoldItemInfo() : count(0), averagePrice(0) { }
+
+	uint64_t	count;
+	double		averagePrice;
+} TShopSearchSoldItemInfo;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+typedef struct SPlayerExtBattlePassMission
+{
+	DWORD dwPlayerId;
+	DWORD dwBattlePassType;
+	DWORD dwMissionIndex;
+	DWORD dwMissionType;
+	DWORD dwBattlePassId;
+	DWORD dwExtraInfo;
+	BYTE bCompleted;
+	BYTE bIsUpdated;
+} TPlayerExtBattlePassMission;
+
+typedef struct SExtBattlePassRewardItem
+{
+	DWORD dwVnum;
+	BYTE bCount;
+} TExtBattlePassRewardItem;
+
+typedef struct SExtBattlePassMissionInfo
+{
+	BYTE bMissionIndex;
+	BYTE bMissionType;
+	DWORD dwMissionInfo[3];
+	TExtBattlePassRewardItem aRewardList[3];
+} TExtBattlePassMissionInfo;
+
+typedef struct SExtBattlePassTimeTable
+{
+	BYTE	bBattlePassId;
+	DWORD	dwStartTime;
+	DWORD	dwEndTime;
+} TExtBattlePassTimeTable;
+#endif
+
+#pragma pack()
+#endif // __INC_COMMON_TABLES_H__
diff --git a/server/server/home/metin2/Source/Server/db/src/Cache.cpp b/server/server/home/metin2/Source/Server/db/src/Cache.cpp
index c869d43..94159b4 100644
--- a/server/server/home/metin2/Source/Server/db/src/Cache.cpp
+++ b/server/server/home/metin2/Source/Server/db/src/Cache.cpp
@@ -1,636 +1,636 @@
-#include "stdafx.h"
-#include "Cache.h"
-
-#include "QID.h"
-#include "ClientManager.h"
-#include "Main.h"
-
-#include <sstream>
-
-extern CPacketInfo g_item_info;
-extern int g_iPlayerCacheFlushSeconds;
-extern int g_iItemCacheFlushSeconds;
-extern int g_test_server;
-// MYSHOP_PRICE_LIST
-extern int g_iItemPriceListTableCacheFlushSeconds;
-// END_OF_MYSHOP_PRICE_LIST
-
-extern int g_item_count;
-
-#ifdef __OFFLINE_SHOP__
-extern uint32_t g_offlineShopCacheFlushSeconds;
-extern uint32_t g_offlineShopItemCacheFlushSeconds;
-#endif
-
-CItemCache::CItemCache()
-{
-	m_expireTime = MIN(1800, g_iItemCacheFlushSeconds);
-}
-
-CItemCache::~CItemCache()
-{
-}
-
-// 이거 이상한데...
-// Delete를 했으면, Cache도 해제해야 하는것 아닌가???
-// 근데 Cache를 해제하는 부분이 없어.
-// 못 찾은 건가?
-// 이렇게 해놓으면, 계속 시간이 될 때마다 아이템을 계속 지워...
-// 이미 사라진 아이템인데... 확인사살??????
-// fixme
-// by rtsummit
-void CItemCache::Delete()
-{
-	if (m_data.dwVnum == 0)
-		return;
-
-	//char szQuery[QUERY_MAX_LEN];
-	//szQuery[QUERY_MAX_LEN] = '\0';
-	if (g_test_server)
-		sys_log(0, "ItemCache::Delete : DELETE %u", m_data.dwID);
-
-	m_data.dwVnum = 0;
-	m_bNeedQuery = true;
-	m_lastUpdateTime = time(0);
-	OnFlush();
-
-	//m_bNeedQuery = false;
-	//m_lastUpdateTime = time(0) - m_expireTime;
-}
-
-void CItemCache::OnFlush()
-{
-	if (m_data.dwVnum == 0) // vnum 이 0이면 삭제하라고 표시된 것이다.
-	{
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery), "DELETE FROM item%s WHERE `id` = %u", GetTablePostfix(), m_data.dwID);
-		CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_DESTROY, 0, NULL);
-
-		if (g_test_server)
-			sys_log(0, "ItemCache::Flush : DELETE %u %s", m_data.dwID, szQuery);
-	}
-	else
-	{
-		long alSockets[ITEM_SOCKET_MAX_NUM];
-		TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-
-#if defined(__ITEM_APPLY_RANDOM__)
-		TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-		bool isApplyRandom = false;
-#endif
-
-		bool isSocket = false, isAttr = false;
-
-		memset(&alSockets, 0, sizeof(long) * ITEM_SOCKET_MAX_NUM);
-		memset(&aAttr, 0, sizeof(TPlayerItemAttribute) * ITEM_ATTRIBUTE_MAX_NUM);
-#if defined(__ITEM_APPLY_RANDOM__)
-		memset(&aApplyRandom, 0, sizeof(TPlayerItemAttribute) * ITEM_APPLY_MAX_NUM);
-#endif
-
-		TPlayerItem* p = &m_data;
-
-		if (memcmp(alSockets, p->alSockets, sizeof(long) * ITEM_SOCKET_MAX_NUM))
-			isSocket = true;
-
-		if (memcmp(aAttr, p->aAttr, sizeof(TPlayerItemAttribute) * ITEM_ATTRIBUTE_MAX_NUM))
-			isAttr = true;
-
-#if defined(__ITEM_APPLY_RANDOM__)
-		if (memcmp(aApplyRandom, p->aApplyRandom, sizeof(TPlayerItemAttribute) * ITEM_APPLY_MAX_NUM))
-			isApplyRandom = true;
-#endif
-
-		char szColumns[QUERY_MAX_LEN];
-		char szValues[QUERY_MAX_LEN];
-		char szUpdate[QUERY_MAX_LEN];
-
-		int iLen = snprintf(szColumns, sizeof(szColumns), "`id`, `owner_id`, `window`, `pos`, `vnum`, `count`");
-		int iValueLen = snprintf(szValues, sizeof(szValues),
-			"%u, %u, %u, %u, %u, %u"
-			, p->dwID, p->dwOwner, p->bWindow, p->wPos, p->dwVnum, p->dwCount
-		);
-		int iUpdateLen = snprintf(szUpdate, sizeof(szUpdate),
-			"`owner_id` = %u, `window` = %u, `pos` = %u, `vnum` = %u, `count` = %u"
-			, p->dwOwner, p->bWindow, p->wPos, p->dwCount, p->dwVnum
-		);
-
-#if defined(__SOUL_BIND_SYSTEM__)
-		iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `soulbind`");
-		iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %ld", p->lSealDate);
-		iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen, ", `soulbind` = %ld", p->lSealDate);
-#endif
-
-		if (isSocket)
-		{
-			iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen,
-				", `socket0`"
-				", `socket1`"
-				", `socket2`"
-#if defined(__ITEM_SOCKET6__)
-				", `socket3`"
-				", `socket4`"
-				", `socket5`"
-#endif
-			);
-			iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen,
-				", %lu"
-				", %lu"
-				", %lu"
-#if defined(__ITEM_SOCKET6__)
-				", %lu"
-				", %lu"
-				", %lu"
-#endif
-				, p->alSockets[0]
-				, p->alSockets[1]
-				, p->alSockets[2]
-#if defined(__ITEM_SOCKET6__)
-				, p->alSockets[3]
-				, p->alSockets[4]
-				, p->alSockets[5]
-#endif
-			);
-			iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen,
-				", `socket0` = %lu"
-				", `socket1` = %lu"
-				", `socket2` = %lu"
-#if defined(__ITEM_SOCKET6__)
-				", `socket3` = %lu"
-				", `socket4` = %lu"
-				", `socket5` = %lu"
-#endif
-				, p->alSockets[0]
-				, p->alSockets[1]
-				, p->alSockets[2]
-#if defined(__ITEM_SOCKET6__)
-				, p->alSockets[3]
-				, p->alSockets[4]
-				, p->alSockets[5]
-#endif
-			);
-		}
-
-		if (isAttr)
-		{
-			iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen,
-				", `attrtype0`, `attrvalue0`"
-				", `attrtype1`, `attrvalue1`"
-				", `attrtype2`, `attrvalue2`"
-				", `attrtype3`, `attrvalue3`"
-				", `attrtype4`, `attrvalue4`"
-				", `attrtype5`, `attrvalue5`"
-				", `attrtype6`, `attrvalue6`"
-			);
-
-			iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen,
-				", %u, %ld"
-				", %u, %ld"
-				", %u, %ld"
-				", %u, %ld"
-				", %u, %ld"
-				", %u, %ld"
-				", %u, %ld"
-				, p->aAttr[0].wType, p->aAttr[0].lValue
-				, p->aAttr[1].wType, p->aAttr[1].lValue
-				, p->aAttr[2].wType, p->aAttr[2].lValue
-				, p->aAttr[3].wType, p->aAttr[3].lValue
-				, p->aAttr[4].wType, p->aAttr[4].lValue
-				, p->aAttr[5].wType, p->aAttr[5].lValue
-				, p->aAttr[6].wType, p->aAttr[6].lValue
-			);
-
-			iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen,
-				", `attrtype0` = %u, `attrvalue0` = %ld"
-				", `attrtype1` = %u, `attrvalue1` = %ld"
-				", `attrtype2` = %u, `attrvalue2` = %ld"
-				", `attrtype3` = %u, `attrvalue3` = %ld"
-				", `attrtype4` = %u, `attrvalue4` = %ld"
-				", `attrtype5` = %u, `attrvalue5` = %ld"
-				", `attrtype6` = %u, `attrvalue6` = %ld"
-				, p->aAttr[0].wType, p->aAttr[0].lValue
-				, p->aAttr[1].wType, p->aAttr[1].lValue
-				, p->aAttr[2].wType, p->aAttr[2].lValue
-				, p->aAttr[3].wType, p->aAttr[3].lValue
-				, p->aAttr[4].wType, p->aAttr[4].lValue
-				, p->aAttr[5].wType, p->aAttr[5].lValue
-				, p->aAttr[6].wType, p->aAttr[6].lValue
-			);
-		}
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `transmutation`");
-		iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u", p->dwTransmutationVnum);
-		iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen, ", `transmutation` = %u", p->dwTransmutationVnum);
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen,
-			", `refine_element_apply_type`"
-			", `refine_element_grade`"
-			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-		);
-		iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen,
-			", %d"
-			", %d"
-			", %d, %d, %d"
-			", %d, %d, %d"
-			, p->RefineElement.wApplyType
-			, p->RefineElement.bGrade
-			, p->RefineElement.abValue[0], p->RefineElement.abValue[1], p->RefineElement.abValue[2]
-			, p->RefineElement.abBonusValue[0], p->RefineElement.abBonusValue[1], p->RefineElement.abBonusValue[2]
-		);
-		iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen,
-			", `refine_element_apply_type` = %d"
-			", `refine_element_grade` = %d"
-			", `refine_element_value0` = %d, `refine_element_value1` = %d, `refine_element_value2` = %d"
-			", `refine_element_bonus_value0` = %d, `refine_element_bonus_value1` = %d, `refine_element_bonus_value2` = %d"
-			, p->RefineElement.wApplyType
-			, p->RefineElement.bGrade
-			, p->RefineElement.abValue[0], p->RefineElement.abValue[1], p->RefineElement.abValue[2]
-			, p->RefineElement.abBonusValue[0], p->RefineElement.abBonusValue[1], p->RefineElement.abBonusValue[2]
-		);
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-		if (isApplyRandom)
-		{
-			iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen,
-				", `apply_type0`, `apply_value0`, `apply_path0`"
-				", `apply_type1`, `apply_value1`, `apply_path1`"
-				", `apply_type2`, `apply_value2`, `apply_path2`"
-				", `apply_type3`, `apply_value3`, `apply_path3`"
-			);
-
-			iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen,
-				", %u, %ld, %d"
-				", %u, %ld, %d"
-				", %u, %ld, %d"
-				", %u, %ld, %d"
-				, p->aApplyRandom[0].wType, p->aApplyRandom[0].lValue, p->aApplyRandom[0].bPath
-				, p->aApplyRandom[1].wType, p->aApplyRandom[1].lValue, p->aApplyRandom[1].bPath
-				, p->aApplyRandom[2].wType, p->aApplyRandom[2].lValue, p->aApplyRandom[2].bPath
-				, p->aApplyRandom[3].wType, p->aApplyRandom[3].lValue, p->aApplyRandom[3].bPath
-			);
-
-			iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen,
-				", `apply_type0` = %u, `apply_value0` = %ld, `apply_path0` = %d"
-				", `apply_type1` = %u, `apply_value1` = %ld, `apply_path1` = %d"
-				", `apply_type2` = %u, `apply_value2` = %ld, `apply_path2` = %d"
-				", `apply_type3` = %u, `apply_value3` = %ld, `apply_path3` = %d"
-				, p->aApplyRandom[0].wType, p->aApplyRandom[0].lValue, p->aApplyRandom[3].bPath
-				, p->aApplyRandom[1].wType, p->aApplyRandom[1].lValue, p->aApplyRandom[3].bPath
-				, p->aApplyRandom[2].wType, p->aApplyRandom[2].lValue, p->aApplyRandom[3].bPath
-				, p->aApplyRandom[3].wType, p->aApplyRandom[3].lValue, p->aApplyRandom[3].bPath
-			);
-		}
-#endif
-
-#if defined(__SET_ITEM__)
-		iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `set_value`");
-		iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u", p->bSetValue);
-		iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen, ", `set_value` = %u", p->bSetValue);
-#endif
-
-		char szItemQuery[QUERY_MAX_LEN + QUERY_MAX_LEN];
-		snprintf(szItemQuery, sizeof(szItemQuery), "REPLACE INTO item%s (%s) VALUES(%s)", GetTablePostfix(), szColumns, szValues);
-
-		if (g_test_server)
-			sys_log(0, "ItemCache::Flush :REPLACE (%s)", szItemQuery);
-
-		CDBManager::instance().ReturnQuery(szItemQuery, QID_ITEM_SAVE, 0, NULL);
-
-		//g_item_info.Add(p->vnum);
-		++g_item_count;
-	}
-
-	m_bNeedQuery = false;
-}
-
-//
-// CPlayerTableCache
-//
-CPlayerTableCache::CPlayerTableCache()
-{
-	m_expireTime = MIN(1800, g_iPlayerCacheFlushSeconds);
-}
-
-CPlayerTableCache::~CPlayerTableCache()
-{
-}
-
-void CPlayerTableCache::OnFlush()
-{
-	if (g_test_server)
-		sys_log(0, "PlayerTableCache::Flush : %s", m_data.name);
-
-	char szQuery[QUERY_MAX_LEN];
-	CreatePlayerSaveQuery(szQuery, sizeof(szQuery), &m_data);
-	CDBManager::instance().ReturnQuery(szQuery, QID_PLAYER_SAVE, 0, NULL);
-}
-
-// MYSHOP_PRICE_LIST
-//
-// CItemPriceListTableCache class implementation
-//
-
-const int CItemPriceListTableCache::s_nMinFlushSec = 1800;
-
-CItemPriceListTableCache::CItemPriceListTableCache()
-{
-	m_expireTime = MIN(s_nMinFlushSec, g_iItemPriceListTableCacheFlushSeconds);
-}
-
-CItemPriceListTableCache::~CItemPriceListTableCache()
-{
-}
-
-void CItemPriceListTableCache::UpdateList(const TItemPriceListTable* pUpdateList)
-{
-	//
-	// 이미 캐싱된 아이템과 중복된 아이템을 찾고 중복되지 않는 이전 정보는 tmpvec 에 넣는다.
-	//
-
-	std::vector<TItemPriceInfo> tmpvec;
-
-	for (uint idx = 0; idx < m_data.byCount; ++idx)
-	{
-		const TItemPriceInfo* pos = pUpdateList->aPriceInfo;
-		for (; pos != pUpdateList->aPriceInfo + pUpdateList->byCount && m_data.aPriceInfo[idx].dwVnum != pos->dwVnum; ++pos);
-
-		if (pos == pUpdateList->aPriceInfo + pUpdateList->byCount)
-			tmpvec.push_back(m_data.aPriceInfo[idx]);
-	}
-
-	//
-	// pUpdateList 를 m_data 에 복사하고 남은 공간을 tmpvec 의 앞에서 부터 남은 만큼 복사한다.
-	//
-
-	if (pUpdateList->byCount > SHOP_PRICELIST_MAX_NUM)
-	{
-		sys_err("Count overflow!");
-		return;
-	}
-
-	m_data.byCount = pUpdateList->byCount;
-
-	thecore_memcpy(m_data.aPriceInfo, pUpdateList->aPriceInfo, sizeof(TItemPriceInfo) * pUpdateList->byCount);
-
-	int nDeletedNum; // 삭제된 가격정보의 갯수
-
-	if (pUpdateList->byCount < SHOP_PRICELIST_MAX_NUM)
-	{
-		size_t sizeAddOldDataSize = SHOP_PRICELIST_MAX_NUM - pUpdateList->byCount;
-
-		if (tmpvec.size() < sizeAddOldDataSize)
-			sizeAddOldDataSize = tmpvec.size();
-
-		if (!tmpvec.empty())
-			thecore_memcpy(m_data.aPriceInfo + pUpdateList->byCount, &tmpvec[0], sizeof(TItemPriceInfo) * sizeAddOldDataSize);
-
-		m_data.byCount += static_cast<BYTE>(sizeAddOldDataSize);
-
-		nDeletedNum = static_cast<UINT>(tmpvec.size() - sizeAddOldDataSize);
-	}
-	else
-		nDeletedNum = tmpvec.size();
-
-	m_bNeedQuery = true;
-
-	sys_log(0, "ItemPriceListTableCache::UpdateList : OwnerID[%u] Update [%u] Items, Delete [%u] Items, Total [%u] Items",
-		m_data.dwOwnerID, pUpdateList->byCount, nDeletedNum, m_data.byCount);
-}
-
-void CItemPriceListTableCache::OnFlush()
-{
-	char szQuery[QUERY_MAX_LEN];
-
-	//
-	// 이 캐시의 소유자에 대한 기존에 DB 에 저장된 아이템 가격정보를 모두 삭제한다.
-	//
-
-	snprintf(szQuery, sizeof(szQuery), "DELETE FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), m_data.dwOwnerID);
-	CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_DESTROY, 0, NULL);
-
-	//
-	// 캐시의 내용을 모두 DB 에 쓴다.
-	//
-
-	for (int idx = 0; idx < m_data.byCount; ++idx)
-	{
-		snprintf(szQuery, sizeof(szQuery), "REPLACE myshop_pricelist%s (`owner_id`, `item_vnum`, `price`) VALUES(%u, %u, %u)",
-			GetTablePostfix(), m_data.dwOwnerID, m_data.aPriceInfo[idx].dwVnum, m_data.aPriceInfo[idx].dwPrice);
-		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_SAVE, 0, NULL);
-	}
-
-	sys_log(0, "ItemPriceListTableCache::Flush : OwnerID[%u] Update [%u]Items", m_data.dwOwnerID, m_data.byCount);
-
-	m_bNeedQuery = false;
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-#ifdef __OFFLINE_SHOP__
-COfflineShopCache::COfflineShopCache()
-{
-	m_expireTime = g_offlineShopCacheFlushSeconds;
-}
-
-void COfflineShopCache::OnFlush()
-{
-	std::array<char, CHARACTER_NAME_MAX_LEN * 2 + 1> escapedOwnerName;
-	CDBManager::Instance().EscapeString(escapedOwnerName.data(), m_data.ownerName.data(), m_data.ownerName.size());
-
-	std::array<char, SHOP_TAB_NAME_MAX * 2 + 1> escapedShopName;
-	CDBManager::Instance().EscapeString(escapedShopName.data(), m_data.shopName.data(), m_data.shopName.size());
-
-	std::stringstream query;
-	query << "REPLACE INTO offline_shop" << GetTablePostfix() << "("
-		<< "id, owner_pid, owner_name, name, name_change_time, channel, "
-		<< "map_index, x, y, deco_race, deco_board, opening_time, gold"
-		<< ") VALUES("
-		<< m_data.id << ", "
-		<< m_data.ownerPid << ", "
-		<< "'" << escapedOwnerName.data() << "', "
-		<< "'" << escapedShopName.data() << "', "
-		<< "'" << m_data.shopNameChangeTime << "', "
-		<< m2::to_string(m_data.channel) << ", "
-		<< m_data.mapIndex << ", "
-		<< m_data.x << ", "
-		<< m_data.y << ", "
-		<< m_data.decoRace << ", "
-		<< m2::to_string(m_data.decoBoard) << ", "
-		<< m_data.openingTime << ", "
-		<< m_data.gold
-		<< ")";
-
-	sys_log(0, "OFFLINE SHOP: %s", query.str().c_str());
-	CDBManager::Instance().AsyncQuery(query.str().c_str());
-	m_bNeedQuery = false;
-}
-
-COfflineShopItemCache::COfflineShopItemCache()
-{
-	m_expireTime = g_offlineShopItemCacheFlushSeconds;
-}
-
-void COfflineShopItemCache::OnFlush()
-{
-	if (m_data.vnum == 0) {
-		std::stringstream query;
-		query << "DELETE FROM offline_shop_item" << GetTablePostfix() << " WHERE owner_pid = " << m_data.id.first << " AND position = " << m2::to_string(m_data.id.second);
-
-		//sys_err("OFFLINE SHOP ITEM: %s", query.str().c_str());
-		CDBManager::Instance().AsyncQuery(query.str().c_str());
-	}
-	else {
-		std::stringstream fields, values;
-		fields << "owner_pid, position, vnum, count, ";
-		values << m_data.id.first << ", " << m2::to_string(m_data.id.second) << ", "
-			<< m_data.vnum << ", " << m2::to_string(m_data.count) << ", ";
-
-		size_t i = 0;
-		for (const auto& socket : m_data.sockets) {
-			fields << "socket" << i << ", ";
-			values << socket << ", ";
-			++i;
-		}
-
-		i = 0;
-		for (const auto& attribute : m_data.attributes) {
-			fields << "attrtype" << i << ", attrvalue" << i << ", ";
-			values << m2::to_string(attribute.wType) << ", " << attribute.lValue << ", ";
-			++i;
-		}
-
-#if defined(__ITEM_APPLY_RANDOM__)
-		i = 0;
-		for (const auto& apply : m_data.ApplyRandom) {
-			fields << "apply_type" << i << ", apply_value" << i << ", apply_path" << i << ", ";
-			values << m2::to_string(apply.wType) << ", " << apply.lValue << ", " << static_cast<int>(apply.bPath) << ", ";
-			++i;
-		}
-#endif
-
-		fields << "price, ";
-		values << m_data.price << ", ";
-		
-#ifdef __CHANGE_LOOK_SYSTEM__
-		fields << "transmutation, ";
-		values << m_data.dwTransmutationVnum << ", ";
-#endif
-
-#ifdef __SOUL_BIND_SYSTEM__
-		fields << "soulbind";
-		values << m_data.soulbind;
-#endif
-		std::stringstream query;
-		query << "REPLACE INTO offline_shop_item" << GetTablePostfix() << "("
-			<< fields.str() << ") VALUES(" << values.str() << ")";
-
-		//sys_err("OFFLINE SHOP ITEM: %s", query.str().c_str());
-		CDBManager::Instance().AsyncQuery(query.str().c_str());
-	}
-
-	m_bNeedQuery = false;
-}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-CGrowthPetCache::CGrowthPetCache()
-{
-	m_expireTime = MIN(5, g_iItemCacheFlushSeconds);
-}
-
-CGrowthPetCache::~CGrowthPetCache()
-{
-}
-
-void CGrowthPetCache::Delete()
-{
-	if (m_data.dwVnum == 0)
-		return;
-
-	if (g_test_server)
-		sys_log(0, "CGrowthPetCache::Delete : DELETE %u", m_data.dwID);
-
-	m_data.dwVnum = 0;
-	m_bNeedQuery = true;
-	m_lastUpdateTime = time(0);
-	OnFlush();
-}
-
-void CGrowthPetCache::OnFlush()
-{
-	char szQuery[QUERY_MAX_LEN];
-
-	if (m_data.dwVnum == 0)
-	{
-		snprintf(szQuery, sizeof(szQuery), "DELETE FROM growth_pet%s WHERE id=%u", GetTablePostfix(), m_data.dwID);
-		CDBManager::instance().ReturnQuery(szQuery, QID_GROWTH_PET_DELETE, 0, NULL);
-
-		if (g_test_server)
-			sys_log(0, "CGrowthPetCache::Flush : DELETE %u %s", m_data.dwID, szQuery);
-	}
-	else
-	{
-		size_t queryLen;
-		queryLen = snprintf(szQuery, sizeof(szQuery),
-			"REPLACE INTO growth_pet%s SET "
-			"id = %d, "
-			"owner_id = %d, "
-			"vnum = %d, "
-			"state = %d, "
-			"name = '%s', "
-			"size = %d, "
-			"level = %d,"
-			"level_step = %d,"
-			"evolution = %d, "
-			"type = %d, "
-			"hp = %d, "
-			"sp = %d, "
-			"def = %d, "
-			"hp_apply = %d, "
-			"sp_apply = %d, "
-			"def_apply = %d, "
-			"age_apply = %d, "
-			"exp = %d, "
-			"item_exp = %d, "
-			"birthday = FROM_UNIXTIME(%d), "
-			"end_time = %d, "
-			"max_time = %d, ",
-
-			GetTablePostfix(),
-			m_data.dwID,
-			m_data.dwOwner,
-			m_data.dwVnum,
-			m_data.bState,
-			m_data.szName,
-			m_data.bSize,
-			m_data.dwLevel,
-			m_data.bLevelStep,
-			m_data.bEvolution,
-			m_data.bType,
-			m_data.dwHP,
-			m_data.dwSP,
-			m_data.dwDef,
-			m_data.dwHPApply,
-			m_data.dwSPApply,
-			m_data.dwDefApply,
-			m_data.dwAgeApply,
-			m_data.lExp,
-			m_data.lItemExp,
-			m_data.lBirthday,
-			m_data.lEndTime,
-			m_data.lMaxTime
-		);
-
-		static char buf[QUERY_MAX_LEN + 1];
-
-		CDBManager::instance().EscapeString(buf, m_data.aSkill, sizeof(m_data.aSkill));
-		snprintf(szQuery + queryLen, sizeof(szQuery) - queryLen, "skill_level = '%s' ", buf);
-
-		CDBManager::instance().ReturnQuery(szQuery, QID_GROWTH_PET_SAVE, 0, NULL);
-		m_bNeedQuery = false;
-	}
-}
-#endif
+#include "stdafx.h"
+#include "Cache.h"
+
+#include "QID.h"
+#include "ClientManager.h"
+#include "Main.h"
+
+#include <sstream>
+
+extern CPacketInfo g_item_info;
+extern int g_iPlayerCacheFlushSeconds;
+extern int g_iItemCacheFlushSeconds;
+extern int g_test_server;
+// MYSHOP_PRICE_LIST
+extern int g_iItemPriceListTableCacheFlushSeconds;
+// END_OF_MYSHOP_PRICE_LIST
+
+extern int g_item_count;
+
+#ifdef __OFFLINE_SHOP__
+extern uint32_t g_offlineShopCacheFlushSeconds;
+extern uint32_t g_offlineShopItemCacheFlushSeconds;
+#endif
+
+CItemCache::CItemCache()
+{
+	m_expireTime = MIN(1800, g_iItemCacheFlushSeconds);
+}
+
+CItemCache::~CItemCache()
+{
+}
+
+// 隔 鵑祁...
+// Delete , Cache 瞞 求째 틈璣???
+// 姆 Cache 求 觀 .
+//  찾 품?
+// 肩 卍,  챨     ...
+// 譴  琯... 확貫??????
+// fixme
+// by rtsummit
+void CItemCache::Delete()
+{
+	if (m_data.dwVnum == 0)
+		return;
+
+	//char szQuery[QUERY_MAX_LEN];
+	//szQuery[QUERY_MAX_LEN] = '\0';
+	if (g_test_server)
+		sys_log(0, "ItemCache::Delete : DELETE %u", m_data.dwID);
+
+	m_data.dwVnum = 0;
+	m_bNeedQuery = true;
+	m_lastUpdateTime = time(0);
+	OnFlush();
+
+	//m_bNeedQuery = false;
+	//m_lastUpdateTime = time(0) - m_expireTime;
+}
+
+void CItemCache::OnFlush()
+{
+	if (m_data.dwVnum == 0) // vnum  0見 灸 표천 甄.
+	{
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery), "DELETE FROM item%s WHERE `id` = %u", GetTablePostfix(), m_data.dwID);
+		CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_DESTROY, 0, NULL);
+
+		if (g_test_server)
+			sys_log(0, "ItemCache::Flush : DELETE %u %s", m_data.dwID, szQuery);
+	}
+	else
+	{
+		long alSockets[ITEM_SOCKET_MAX_NUM];
+		TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+
+#if defined(__ITEM_APPLY_RANDOM__)
+		TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+		bool isApplyRandom = false;
+#endif
+
+		bool isSocket = false, isAttr = false;
+
+		memset(&alSockets, 0, sizeof(long) * ITEM_SOCKET_MAX_NUM);
+		memset(&aAttr, 0, sizeof(TPlayerItemAttribute) * ITEM_ATTRIBUTE_MAX_NUM);
+#if defined(__ITEM_APPLY_RANDOM__)
+		memset(&aApplyRandom, 0, sizeof(TPlayerItemAttribute) * ITEM_APPLY_MAX_NUM);
+#endif
+
+		TPlayerItem* p = &m_data;
+
+		if (memcmp(alSockets, p->alSockets, sizeof(long) * ITEM_SOCKET_MAX_NUM))
+			isSocket = true;
+
+		if (memcmp(aAttr, p->aAttr, sizeof(TPlayerItemAttribute) * ITEM_ATTRIBUTE_MAX_NUM))
+			isAttr = true;
+
+#if defined(__ITEM_APPLY_RANDOM__)
+		if (memcmp(aApplyRandom, p->aApplyRandom, sizeof(TPlayerItemAttribute) * ITEM_APPLY_MAX_NUM))
+			isApplyRandom = true;
+#endif
+
+		char szColumns[QUERY_MAX_LEN];
+		char szValues[QUERY_MAX_LEN];
+		char szUpdate[QUERY_MAX_LEN];
+
+		int iLen = snprintf(szColumns, sizeof(szColumns), "`id`, `owner_id`, `window`, `pos`, `vnum`, `count`");
+		int iValueLen = snprintf(szValues, sizeof(szValues),
+			"%u, %u, %u, %u, %u, %u"
+			, p->dwID, p->dwOwner, p->bWindow, p->wPos, p->dwVnum, p->dwCount
+		);
+		int iUpdateLen = snprintf(szUpdate, sizeof(szUpdate),
+			"`owner_id` = %u, `window` = %u, `pos` = %u, `vnum` = %u, `count` = %u"
+			, p->dwOwner, p->bWindow, p->wPos, p->dwCount, p->dwVnum
+		);
+
+#if defined(__SOUL_BIND_SYSTEM__)
+		iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `soulbind`");
+		iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %ld", p->lSealDate);
+		iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen, ", `soulbind` = %ld", p->lSealDate);
+#endif
+
+		if (isSocket)
+		{
+			iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen,
+				", `socket0`"
+				", `socket1`"
+				", `socket2`"
+#if defined(__ITEM_SOCKET6__)
+				", `socket3`"
+				", `socket4`"
+				", `socket5`"
+#endif
+			);
+			iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen,
+				", %lu"
+				", %lu"
+				", %lu"
+#if defined(__ITEM_SOCKET6__)
+				", %lu"
+				", %lu"
+				", %lu"
+#endif
+				, p->alSockets[0]
+				, p->alSockets[1]
+				, p->alSockets[2]
+#if defined(__ITEM_SOCKET6__)
+				, p->alSockets[3]
+				, p->alSockets[4]
+				, p->alSockets[5]
+#endif
+			);
+			iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen,
+				", `socket0` = %lu"
+				", `socket1` = %lu"
+				", `socket2` = %lu"
+#if defined(__ITEM_SOCKET6__)
+				", `socket3` = %lu"
+				", `socket4` = %lu"
+				", `socket5` = %lu"
+#endif
+				, p->alSockets[0]
+				, p->alSockets[1]
+				, p->alSockets[2]
+#if defined(__ITEM_SOCKET6__)
+				, p->alSockets[3]
+				, p->alSockets[4]
+				, p->alSockets[5]
+#endif
+			);
+		}
+
+		if (isAttr)
+		{
+			iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen,
+				", `attrtype0`, `attrvalue0`"
+				", `attrtype1`, `attrvalue1`"
+				", `attrtype2`, `attrvalue2`"
+				", `attrtype3`, `attrvalue3`"
+				", `attrtype4`, `attrvalue4`"
+				", `attrtype5`, `attrvalue5`"
+				", `attrtype6`, `attrvalue6`"
+			);
+
+			iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen,
+				", %u, %ld"
+				", %u, %ld"
+				", %u, %ld"
+				", %u, %ld"
+				", %u, %ld"
+				", %u, %ld"
+				", %u, %ld"
+				, p->aAttr[0].wType, p->aAttr[0].lValue
+				, p->aAttr[1].wType, p->aAttr[1].lValue
+				, p->aAttr[2].wType, p->aAttr[2].lValue
+				, p->aAttr[3].wType, p->aAttr[3].lValue
+				, p->aAttr[4].wType, p->aAttr[4].lValue
+				, p->aAttr[5].wType, p->aAttr[5].lValue
+				, p->aAttr[6].wType, p->aAttr[6].lValue
+			);
+
+			iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen,
+				", `attrtype0` = %u, `attrvalue0` = %ld"
+				", `attrtype1` = %u, `attrvalue1` = %ld"
+				", `attrtype2` = %u, `attrvalue2` = %ld"
+				", `attrtype3` = %u, `attrvalue3` = %ld"
+				", `attrtype4` = %u, `attrvalue4` = %ld"
+				", `attrtype5` = %u, `attrvalue5` = %ld"
+				", `attrtype6` = %u, `attrvalue6` = %ld"
+				, p->aAttr[0].wType, p->aAttr[0].lValue
+				, p->aAttr[1].wType, p->aAttr[1].lValue
+				, p->aAttr[2].wType, p->aAttr[2].lValue
+				, p->aAttr[3].wType, p->aAttr[3].lValue
+				, p->aAttr[4].wType, p->aAttr[4].lValue
+				, p->aAttr[5].wType, p->aAttr[5].lValue
+				, p->aAttr[6].wType, p->aAttr[6].lValue
+			);
+		}
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `transmutation`");
+		iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u", p->dwTransmutationVnum);
+		iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen, ", `transmutation` = %u", p->dwTransmutationVnum);
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen,
+			", `refine_element_apply_type`"
+			", `refine_element_grade`"
+			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+		);
+		iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen,
+			", %d"
+			", %d"
+			", %d, %d, %d"
+			", %d, %d, %d"
+			, p->RefineElement.wApplyType
+			, p->RefineElement.bGrade
+			, p->RefineElement.abValue[0], p->RefineElement.abValue[1], p->RefineElement.abValue[2]
+			, p->RefineElement.abBonusValue[0], p->RefineElement.abBonusValue[1], p->RefineElement.abBonusValue[2]
+		);
+		iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen,
+			", `refine_element_apply_type` = %d"
+			", `refine_element_grade` = %d"
+			", `refine_element_value0` = %d, `refine_element_value1` = %d, `refine_element_value2` = %d"
+			", `refine_element_bonus_value0` = %d, `refine_element_bonus_value1` = %d, `refine_element_bonus_value2` = %d"
+			, p->RefineElement.wApplyType
+			, p->RefineElement.bGrade
+			, p->RefineElement.abValue[0], p->RefineElement.abValue[1], p->RefineElement.abValue[2]
+			, p->RefineElement.abBonusValue[0], p->RefineElement.abBonusValue[1], p->RefineElement.abBonusValue[2]
+		);
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+		if (isApplyRandom)
+		{
+			iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen,
+				", `apply_type0`, `apply_value0`, `apply_path0`"
+				", `apply_type1`, `apply_value1`, `apply_path1`"
+				", `apply_type2`, `apply_value2`, `apply_path2`"
+				", `apply_type3`, `apply_value3`, `apply_path3`"
+			);
+
+			iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen,
+				", %u, %ld, %d"
+				", %u, %ld, %d"
+				", %u, %ld, %d"
+				", %u, %ld, %d"
+				, p->aApplyRandom[0].wType, p->aApplyRandom[0].lValue, p->aApplyRandom[0].bPath
+				, p->aApplyRandom[1].wType, p->aApplyRandom[1].lValue, p->aApplyRandom[1].bPath
+				, p->aApplyRandom[2].wType, p->aApplyRandom[2].lValue, p->aApplyRandom[2].bPath
+				, p->aApplyRandom[3].wType, p->aApplyRandom[3].lValue, p->aApplyRandom[3].bPath
+			);
+
+			iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen,
+				", `apply_type0` = %u, `apply_value0` = %ld, `apply_path0` = %d"
+				", `apply_type1` = %u, `apply_value1` = %ld, `apply_path1` = %d"
+				", `apply_type2` = %u, `apply_value2` = %ld, `apply_path2` = %d"
+				", `apply_type3` = %u, `apply_value3` = %ld, `apply_path3` = %d"
+				, p->aApplyRandom[0].wType, p->aApplyRandom[0].lValue, p->aApplyRandom[3].bPath
+				, p->aApplyRandom[1].wType, p->aApplyRandom[1].lValue, p->aApplyRandom[3].bPath
+				, p->aApplyRandom[2].wType, p->aApplyRandom[2].lValue, p->aApplyRandom[3].bPath
+				, p->aApplyRandom[3].wType, p->aApplyRandom[3].lValue, p->aApplyRandom[3].bPath
+			);
+		}
+#endif
+
+#if defined(__SET_ITEM__)
+		iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `set_value`");
+		iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u", p->bSetValue);
+		iUpdateLen += snprintf(szUpdate + iUpdateLen, sizeof(szUpdate) - iUpdateLen, ", `set_value` = %u", p->bSetValue);
+#endif
+
+		char szItemQuery[QUERY_MAX_LEN + QUERY_MAX_LEN];
+		snprintf(szItemQuery, sizeof(szItemQuery), "REPLACE INTO item%s (%s) VALUES(%s)", GetTablePostfix(), szColumns, szValues);
+
+		if (g_test_server)
+			sys_log(0, "ItemCache::Flush :REPLACE (%s)", szItemQuery);
+
+		CDBManager::instance().ReturnQuery(szItemQuery, QID_ITEM_SAVE, 0, NULL);
+
+		//g_item_info.Add(p->vnum);
+		++g_item_count;
+	}
+
+	m_bNeedQuery = false;
+}
+
+//
+// CPlayerTableCache
+//
+CPlayerTableCache::CPlayerTableCache()
+{
+	m_expireTime = MIN(1800, g_iPlayerCacheFlushSeconds);
+}
+
+CPlayerTableCache::~CPlayerTableCache()
+{
+}
+
+void CPlayerTableCache::OnFlush()
+{
+	if (g_test_server)
+		sys_log(0, "PlayerTableCache::Flush : %s", m_data.name);
+
+	char szQuery[QUERY_MAX_LEN];
+	CreatePlayerSaveQuery(szQuery, sizeof(szQuery), &m_data);
+	CDBManager::instance().ReturnQuery(szQuery, QID_PLAYER_SAVE, 0, NULL);
+}
+
+// MYSHOP_PRICE_LIST
+//
+// CItemPriceListTableCache class implementation
+//
+
+const int CItemPriceListTableCache::s_nMinFlushSec = 1800;
+
+CItemPriceListTableCache::CItemPriceListTableCache()
+{
+	m_expireTime = MIN(s_nMinFlushSec, g_iItemPriceListTableCacheFlushSeconds);
+}
+
+CItemPriceListTableCache::~CItemPriceListTableCache()
+{
+}
+
+void CItemPriceListTableCache::UpdateList(const TItemPriceListTable* pUpdateList)
+{
+	//
+	// 譴 캐絹 方 揷  찾 揷 苛   tmpvec  獵쨈.
+	//
+
+	std::vector<TItemPriceInfo> tmpvec;
+
+	for (uint idx = 0; idx < m_data.byCount; ++idx)
+	{
+		const TItemPriceInfo* pos = pUpdateList->aPriceInfo;
+		for (; pos != pUpdateList->aPriceInfo + pUpdateList->byCount && m_data.aPriceInfo[idx].dwVnum != pos->dwVnum; ++pos);
+
+		if (pos == pUpdateList->aPriceInfo + pUpdateList->byCount)
+			tmpvec.push_back(m_data.aPriceInfo[idx]);
+	}
+
+	//
+	// pUpdateList  m_data  構   tmpvec  纜   큼 磯.
+	//
+
+	if (pUpdateList->byCount > SHOP_PRICELIST_MAX_NUM)
+	{
+		sys_err("Count overflow!");
+		return;
+	}
+
+	m_data.byCount = pUpdateList->byCount;
+
+	thecore_memcpy(m_data.aPriceInfo, pUpdateList->aPriceInfo, sizeof(TItemPriceInfo) * pUpdateList->byCount);
+
+	int nDeletedNum; //   
+
+	if (pUpdateList->byCount < SHOP_PRICELIST_MAX_NUM)
+	{
+		size_t sizeAddOldDataSize = SHOP_PRICELIST_MAX_NUM - pUpdateList->byCount;
+
+		if (tmpvec.size() < sizeAddOldDataSize)
+			sizeAddOldDataSize = tmpvec.size();
+
+		if (!tmpvec.empty())
+			thecore_memcpy(m_data.aPriceInfo + pUpdateList->byCount, &tmpvec[0], sizeof(TItemPriceInfo) * sizeAddOldDataSize);
+
+		m_data.byCount += static_cast<BYTE>(sizeAddOldDataSize);
+
+		nDeletedNum = static_cast<UINT>(tmpvec.size() - sizeAddOldDataSize);
+	}
+	else
+		nDeletedNum = tmpvec.size();
+
+	m_bNeedQuery = true;
+
+	sys_log(0, "ItemPriceListTableCache::UpdateList : OwnerID[%u] Update [%u] Items, Delete [%u] Items, Total [%u] Items",
+		m_data.dwOwnerID, pUpdateList->byCount, nDeletedNum, m_data.byCount);
+}
+
+void CItemPriceListTableCache::OnFlush()
+{
+	char szQuery[QUERY_MAX_LEN];
+
+	//
+	//  캐 悶   DB      磯.
+	//
+
+	snprintf(szQuery, sizeof(szQuery), "DELETE FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), m_data.dwOwnerID);
+	CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_DESTROY, 0, NULL);
+
+	//
+	// 캐   DB  .
+	//
+
+	for (int idx = 0; idx < m_data.byCount; ++idx)
+	{
+		snprintf(szQuery, sizeof(szQuery), "REPLACE myshop_pricelist%s (`owner_id`, `item_vnum`, `price`) VALUES(%u, %u, %u)",
+			GetTablePostfix(), m_data.dwOwnerID, m_data.aPriceInfo[idx].dwVnum, m_data.aPriceInfo[idx].dwPrice);
+		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_SAVE, 0, NULL);
+	}
+
+	sys_log(0, "ItemPriceListTableCache::Flush : OwnerID[%u] Update [%u]Items", m_data.dwOwnerID, m_data.byCount);
+
+	m_bNeedQuery = false;
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+#ifdef __OFFLINE_SHOP__
+COfflineShopCache::COfflineShopCache()
+{
+	m_expireTime = g_offlineShopCacheFlushSeconds;
+}
+
+void COfflineShopCache::OnFlush()
+{
+	std::array<char, CHARACTER_NAME_MAX_LEN * 2 + 1> escapedOwnerName;
+	CDBManager::Instance().EscapeString(escapedOwnerName.data(), m_data.ownerName.data(), m_data.ownerName.size());
+
+	std::array<char, SHOP_TAB_NAME_MAX * 2 + 1> escapedShopName;
+	CDBManager::Instance().EscapeString(escapedShopName.data(), m_data.shopName.data(), m_data.shopName.size());
+
+	std::stringstream query;
+	query << "REPLACE INTO offline_shop" << GetTablePostfix() << "("
+		<< "id, owner_pid, owner_name, name, name_change_time, channel, "
+		<< "map_index, x, y, deco_race, deco_board, opening_time, gold"
+		<< ") VALUES("
+		<< m_data.id << ", "
+		<< m_data.ownerPid << ", "
+		<< "'" << escapedOwnerName.data() << "', "
+		<< "'" << escapedShopName.data() << "', "
+		<< "'" << m_data.shopNameChangeTime << "', "
+		<< m2::to_string(m_data.channel) << ", "
+		<< m_data.mapIndex << ", "
+		<< m_data.x << ", "
+		<< m_data.y << ", "
+		<< m_data.decoRace << ", "
+		<< m2::to_string(m_data.decoBoard) << ", "
+		<< m_data.openingTime << ", "
+		<< m_data.gold
+		<< ")";
+
+	sys_log(0, "OFFLINE SHOP: %s", query.str().c_str());
+	CDBManager::Instance().AsyncQuery(query.str().c_str());
+	m_bNeedQuery = false;
+}
+
+COfflineShopItemCache::COfflineShopItemCache()
+{
+	m_expireTime = g_offlineShopItemCacheFlushSeconds;
+}
+
+void COfflineShopItemCache::OnFlush()
+{
+	if (m_data.vnum == 0) {
+		std::stringstream query;
+		query << "DELETE FROM offline_shop_item" << GetTablePostfix() << " WHERE owner_pid = " << m_data.id.first << " AND position = " << m2::to_string(m_data.id.second);
+
+		//sys_err("OFFLINE SHOP ITEM: %s", query.str().c_str());
+		CDBManager::Instance().AsyncQuery(query.str().c_str());
+	}
+	else {
+		std::stringstream fields, values;
+		fields << "owner_pid, position, vnum, count, ";
+		values << m_data.id.first << ", " << m2::to_string(m_data.id.second) << ", "
+			<< m_data.vnum << ", " << m2::to_string(m_data.count) << ", ";
+
+		size_t i = 0;
+		for (const auto& socket : m_data.sockets) {
+			fields << "socket" << i << ", ";
+			values << socket << ", ";
+			++i;
+		}
+
+		i = 0;
+		for (const auto& attribute : m_data.attributes) {
+			fields << "attrtype" << i << ", attrvalue" << i << ", ";
+			values << m2::to_string(attribute.wType) << ", " << attribute.lValue << ", ";
+			++i;
+		}
+
+#if defined(__ITEM_APPLY_RANDOM__)
+		i = 0;
+		for (const auto& apply : m_data.ApplyRandom) {
+			fields << "apply_type" << i << ", apply_value" << i << ", apply_path" << i << ", ";
+			values << m2::to_string(apply.wType) << ", " << apply.lValue << ", " << static_cast<int>(apply.bPath) << ", ";
+			++i;
+		}
+#endif
+
+		fields << "price, ";
+		values << m_data.price << ", ";
+		
+#ifdef __CHANGE_LOOK_SYSTEM__
+		fields << "transmutation, ";
+		values << m_data.dwTransmutationVnum << ", ";
+#endif
+
+#ifdef __SOUL_BIND_SYSTEM__
+		fields << "soulbind";
+		values << m_data.soulbind;
+#endif
+		std::stringstream query;
+		query << "REPLACE INTO offline_shop_item" << GetTablePostfix() << "("
+			<< fields.str() << ") VALUES(" << values.str() << ")";
+
+		//sys_err("OFFLINE SHOP ITEM: %s", query.str().c_str());
+		CDBManager::Instance().AsyncQuery(query.str().c_str());
+	}
+
+	m_bNeedQuery = false;
+}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+CGrowthPetCache::CGrowthPetCache()
+{
+	m_expireTime = MIN(5, g_iItemCacheFlushSeconds);
+}
+
+CGrowthPetCache::~CGrowthPetCache()
+{
+}
+
+void CGrowthPetCache::Delete()
+{
+	if (m_data.dwVnum == 0)
+		return;
+
+	if (g_test_server)
+		sys_log(0, "CGrowthPetCache::Delete : DELETE %u", m_data.dwID);
+
+	m_data.dwVnum = 0;
+	m_bNeedQuery = true;
+	m_lastUpdateTime = time(0);
+	OnFlush();
+}
+
+void CGrowthPetCache::OnFlush()
+{
+	char szQuery[QUERY_MAX_LEN];
+
+	if (m_data.dwVnum == 0)
+	{
+		snprintf(szQuery, sizeof(szQuery), "DELETE FROM growth_pet%s WHERE id=%u", GetTablePostfix(), m_data.dwID);
+		CDBManager::instance().ReturnQuery(szQuery, QID_GROWTH_PET_DELETE, 0, NULL);
+
+		if (g_test_server)
+			sys_log(0, "CGrowthPetCache::Flush : DELETE %u %s", m_data.dwID, szQuery);
+	}
+	else
+	{
+		size_t queryLen;
+		queryLen = snprintf(szQuery, sizeof(szQuery),
+			"REPLACE INTO growth_pet%s SET "
+			"id = %d, "
+			"owner_id = %d, "
+			"vnum = %d, "
+			"state = %d, "
+			"name = '%s', "
+			"size = %d, "
+			"level = %d,"
+			"level_step = %d,"
+			"evolution = %d, "
+			"type = %d, "
+			"hp = %d, "
+			"sp = %d, "
+			"def = %d, "
+			"hp_apply = %d, "
+			"sp_apply = %d, "
+			"def_apply = %d, "
+			"age_apply = %d, "
+			"exp = %d, "
+			"item_exp = %d, "
+			"birthday = FROM_UNIXTIME(%d), "
+			"end_time = %d, "
+			"max_time = %d, ",
+
+			GetTablePostfix(),
+			m_data.dwID,
+			m_data.dwOwner,
+			m_data.dwVnum,
+			m_data.bState,
+			m_data.szName,
+			m_data.bSize,
+			m_data.dwLevel,
+			m_data.bLevelStep,
+			m_data.bEvolution,
+			m_data.bType,
+			m_data.dwHP,
+			m_data.dwSP,
+			m_data.dwDef,
+			m_data.dwHPApply,
+			m_data.dwSPApply,
+			m_data.dwDefApply,
+			m_data.dwAgeApply,
+			m_data.lExp,
+			m_data.lItemExp,
+			m_data.lBirthday,
+			m_data.lEndTime,
+			m_data.lMaxTime
+		);
+
+		static char buf[QUERY_MAX_LEN + 1];
+
+		CDBManager::instance().EscapeString(buf, m_data.aSkill, sizeof(m_data.aSkill));
+		snprintf(szQuery + queryLen, sizeof(szQuery) - queryLen, "skill_level = '%s' ", buf);
+
+		CDBManager::instance().ReturnQuery(szQuery, QID_GROWTH_PET_SAVE, 0, NULL);
+		m_bNeedQuery = false;
+	}
+}
+#endif
\ No newline at end of file
diff --git a/server/server/home/metin2/Source/Server/db/src/ClientManager.cpp b/server/server/home/metin2/Source/Server/db/src/ClientManager.cpp
index c2664b0..8ce27f6 100644
--- a/server/server/home/metin2/Source/Server/db/src/ClientManager.cpp
+++ b/server/server/home/metin2/Source/Server/db/src/ClientManager.cpp
@@ -1,5957 +1,6215 @@
-#include "stdafx.h"
-#include <set>
-#include "../../common/building.h"
-#include "../../common/VnumHelper.h"
-#include "../../libgame/include/grid.h"
-
-#include "ClientManager.h"
-
-#include "Main.h"
-#include "Config.h"
-#include "DBManager.h"
-#include "QID.h"
-#include "GuildManager.h"
-#include "PrivManager.h"
-#include "MoneyLog.h"
-#include "ItemAwardManager.h"
-#include "Marriage.h"
-#include "Monarch.h"
-#include "BlockCountry.h"
-#include "ItemIDRangeManager.h"
-#include "Cache.h"
-
-#include <sstream>
-#if defined(__SHOP_SEARCH__)
-	#include "ShopSearchManager.h"
-#endif
-
-extern int g_iPlayerCacheFlushSeconds;
-extern int g_iItemCacheFlushSeconds;
-extern int g_test_server;
-extern int g_log;
-extern std::string g_stLocale;
-extern std::string g_stLocaleNameColumn;
-bool CreateItemTableFromRes(MYSQL_RES* res, std::vector<TPlayerItem>* pVec, DWORD dwPID);
-
-DWORD g_dwUsageMax = 0;
-DWORD g_dwUsageAvg = 0;
-
-CPacketInfo g_query_info;
-CPacketInfo g_item_info;
-
-int g_item_count = 0;
-int g_query_count[2];
-
-CClientManager::CClientManager() :
-	m_pkAuthPeer(NULL),
-	m_iPlayerIDStart(0),
-	m_iPlayerDeleteLevelLimit(0),
-	m_iPlayerDeleteLevelLimitLower(0),
-	m_bChinaEventServer(false),
-	m_iShopTableSize(0),
-	m_pShopTable(NULL),
-	m_iRefineTableSize(0),
-	m_pRefineTable(NULL),
-	m_bShutdowned(false),
-	m_iCacheFlushCount(0),
-	m_iCacheFlushCountLimit(200)
-#if defined(__EXPRESSING_EMOTIONS__)
-	, m_iEmoteDumpDelay(3600)
-#endif
-#if defined(__MAILBOX__)
-	, m_iMailBoxBackupSec(3600)
-#endif
-#if defined(__GEM_SHOP__)
-	, m_iGemShopFlushDelay(3600)
-#endif
-{
-	m_itemRange.dwMin = 0;
-	m_itemRange.dwMax = 0;
-	m_itemRange.dwUsableItemIDMin = 0;
-
-	memset(g_query_count, 0, sizeof(g_query_count));
-}
-
-CClientManager::~CClientManager()
-{
-	Destroy();
-}
-
-void CClientManager::SetPlayerIDStart(int iIDStart)
-{
-	m_iPlayerIDStart = iIDStart;
-}
-
-void CClientManager::Destroy()
-{
-	m_mChannelStatus.clear();
-	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		(*i)->Destroy();
-
-	m_peerList.clear();
-
-	if (m_fdAccept > 0)
-	{
-		socket_close(m_fdAccept);
-		m_fdAccept = -1;
-	}
-}
-
-bool CClientManager::Initialize()
-{
-	int tmpValue;
-
-	// BOOT_LOCALIZATION
-	if (!InitializeLocalization())
-	{
-		fprintf(stderr, "Failed Localization Infomation so exit\n");
-		return false;
-	}
-	// END_BOOT_LOCALIZATION
-
-	// ITEM_UNIQUE_ID
-	if (!InitializeNowItemID())
-	{
-		fprintf(stderr, " Item range Initialize Failed. Exit DBCache Server\n");
-		return false;
-	}
-	// END_ITEM_UNIQUE_ID
-
-	m_bWolfmanCharacter = true;
-	int iWolfmanCharacter = 0;
-	if (CConfig::instance().GetValue("WOLFMAN_CHARACTER", &iWolfmanCharacter))
-		m_bWolfmanCharacter = (iWolfmanCharacter);
-	sys_log(0, "WOLFMAN_CHARACTER %s", m_bWolfmanCharacter ? "true" : "false");
-
-	m_bDelayedCharacterCreation = true;
-	int iDelayedCharacterCreation = 0;
-	if (CConfig::instance().GetValue("DELAYED_CHARACTER_CREATION", &iDelayedCharacterCreation))
-		m_bDelayedCharacterCreation = (iDelayedCharacterCreation);
-	sys_log(0, "DELAYED_CHARACTER_CREATION %s", m_bDelayedCharacterCreation ? "true" : "false");
-
-	if (!InitializeTables())
-	{
-		sys_err("Table Initialize FAILED");
-		return false;
-	}
-
-	CGuildManager::instance().BootReserveWar();
-
-	if (!CConfig::instance().GetValue("BIND_PORT", &tmpValue))
-		tmpValue = 5300;
-
-	char szBindIP[128];
-
-	if (!CConfig::instance().GetValue("BIND_IP", szBindIP, 128))
-		strlcpy(szBindIP, "0", sizeof(szBindIP));
-
-	m_fdAccept = socket_tcp_bind(szBindIP, tmpValue);
-
-	if (m_fdAccept < 0)
-	{
-		perror("socket");
-		return false;
-	}
-
-	sys_log(0, "ACCEPT_HANDLE: %u", m_fdAccept);
-	fdwatch_add_fd(m_fdWatcher, m_fdAccept, NULL, FDW_READ, false);
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	CConfig::instance().GetValue("EMOTE_DUMP_DELAY", &m_iEmoteDumpDelay);
-#endif
-
-#if defined(__MAILBOX__)
-	CConfig::instance().GetValue("MAILBOX_BACKUP_SEC", &m_iMailBoxBackupSec);
-#endif
-
-#if defined(__GEM_SHOP__)
-	CConfig::instance().GetValue("GEM_SHOP_FLUSH_DELAY", &m_iGemShopFlushDelay);
-#endif
-
-	if (!CConfig::instance().GetValue("BACKUP_LIMIT_SEC", &tmpValue))
-		tmpValue = 600;
-
-	m_looping = true;
-
-	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT", &m_iPlayerDeleteLevelLimit))
-	{
-		sys_err("config.txt: Cannot find PLAYER_DELETE_LEVEL_LIMIT, use default level %d", PLAYER_MAX_LEVEL_CONST + 1);
-		m_iPlayerDeleteLevelLimit = PLAYER_MAX_LEVEL_CONST + 1;
-	}
-
-	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT_LOWER", &m_iPlayerDeleteLevelLimitLower))
-	{
-		m_iPlayerDeleteLevelLimitLower = 0;
-	}
-
-	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT set to %d", m_iPlayerDeleteLevelLimit);
-	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT_LOWER set to %d", m_iPlayerDeleteLevelLimitLower);
-
-	m_bChinaEventServer = false;
-
-	int iChinaEventServer = 0;
-
-	if (CConfig::instance().GetValue("CHINA_EVENT_SERVER", &iChinaEventServer))
-		m_bChinaEventServer = (iChinaEventServer);
-
-	sys_log(0, "CHINA_EVENT_SERVER %s", CClientManager::instance().IsChinaEventServer() ? "true" : "false");
-
-	LoadEventFlag();
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	LoadGuildEventFlag();
-#endif
-
-	// database character-set을 강제로 맞춤
-	if (g_stLocale == "big5" || g_stLocale == "sjis")
-		CDBManager::instance().QueryLocaleSet();
-
-	return true;
-}
-
-void CClientManager::MainLoop()
-{
-	SQLMsg* tmp;
-
-	sys_log(0, "ClientManager pointer is %p", this);
-
-	// 메인루프
-	while (!m_bShutdowned)
-	{
-		while ((tmp = CDBManager::instance().PopResult()))
-		{
-			AnalyzeQueryResult(tmp);
-			delete tmp;
-		}
-
-		if (!Process())
-			break;
-
-		log_rotate();
-	}
-
-	//
-	// 메인루프 종료처리
-	//
-	sys_log(0, "MainLoop exited, Starting cache flushing");
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	CClientManager::instance().QUERY_EMOTE_DUMP();
-#endif
-
-#if defined(__MAILBOX__)
-	CClientManager::instance().MAILBOX_BACKUP();
-#endif
-
-#if defined(__GEM_SHOP__)
-	// Gem Shop Item Data List Flush
-	CClientManager::instance().FlushGemShop();
-#endif
-
-	signal_timer_disable();
-
-	// 플레이어 테이블 캐쉬 플러쉬
-	auto it = m_map_playerCache.begin();
-	while (it != m_map_playerCache.end())
-	{
-		CPlayerTableCache* c = (it++)->second;
-
-		c->Flush();
-		delete c;
-	}
-	m_map_playerCache.clear();
-
-	// 아이템 플러쉬
-	auto it2 = m_map_itemCache.begin();
-	while (it2 != m_map_itemCache.end())
-	{
-		CItemCache* c = (it2++)->second;
-
-		c->Flush();
-		delete c;
-	}
-	m_map_itemCache.clear();
-
-	// MYSHOP_PRICE_LIST
-	//
-	// 개인상점 아이템 가격 리스트 Flush
-	//
-	for (auto itPriceList = m_mapItemPriceListCache.begin(); itPriceList != m_mapItemPriceListCache.end(); ++itPriceList)
-	{
-		CItemPriceListTableCache* pCache = itPriceList->second;
-		pCache->Flush();
-		delete pCache;
-	}
-
-	m_mapItemPriceListCache.clear();
-#ifdef __OFFLINE_SHOP__
-	FlushOfflineShops();
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	auto growthPetCache = m_map_growthPetCache.begin();
-
-	while (growthPetCache != m_map_growthPetCache.end())
-	{
-		CGrowthPetCache* c = (growthPetCache++)->second;
-
-		c->Flush();
-		delete c;
-	}
-	m_map_growthPetCache.clear();
-#endif
-
-	// END_OF_MYSHOP_PRICE_LIST
-}
-
-void CClientManager::Quit()
-{
-	m_bShutdowned = true;
-}
-
-void CClientManager::QUERY_BOOT(CPeer* peer, TPacketGDBoot* p)
-{
-	const BYTE bPacketVersion = 6; // BOOT 패킷이 바뀔때마다 번호를 올리도록 한다.
-
-	std::vector<tAdminInfo> vAdmin;
-	std::vector<std::string> vHost;
-
-	__GetHostInfo(vHost);
-	__GetAdminInfo(p->szIP, vAdmin);
-
-	sys_log(0, "QUERY_BOOT : AdminInfo (Request ServerIp %s) ", p->szIP);
-
-	DWORD dwPacketSize =
-		sizeof(DWORD) +
-		sizeof(BYTE) +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TShopTable) * m_iShopTableSize +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemAttrTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemRareTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(building::TLand) * m_vec_kLandTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObjectProto) * m_vec_kObjectProto.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObject) * m_map_pkObjectTable.size() +
-#ifdef __GROWTH_PET_SYSTEM__
-		sizeof(WORD) + sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size() +
-#endif
-		sizeof(time_t) +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemIDRangeTable) * 2 +
-		// ADMIN_MANAGER
-		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
-		// END_ADMIN_MANAGER
-		sizeof(WORD) + sizeof(WORD) + sizeof(TMonarchInfo) +
-		sizeof(WORD) + sizeof(WORD) + sizeof(MonarchCandidacy) * CMonarch::instance().MonarchCandidacySize() +
-		sizeof(WORD);
-
-	peer->EncodeHeader(HEADER_DG_BOOT, 0, dwPacketSize);
-	peer->Encode(&dwPacketSize, sizeof(DWORD));
-	peer->Encode(&bPacketVersion, sizeof(BYTE));
-
-	sys_log(0, "BOOT: PACKET: %d", dwPacketSize);
-	sys_log(0, "BOOT: VERSION: %d", bPacketVersion);
-
-	sys_log(0, "sizeof(TMobTable) = %d", sizeof(TMobTable));
-	sys_log(0, "sizeof(TItemTable) = %d", sizeof(TItemTable));
-	sys_log(0, "sizeof(TShopTable) = %d", sizeof(TShopTable));
-	sys_log(0, "sizeof(TSkillTable) = %d", sizeof(TSkillTable));
-	sys_log(0, "sizeof(TRefineTable) = %d", sizeof(TRefineTable));
-	sys_log(0, "sizeof(TItemAttrTable) = %d", sizeof(TItemAttrTable));
-	sys_log(0, "sizeof(TItemRareTable) = %d", sizeof(TItemAttrTable));
-	sys_log(0, "sizeof(TBanwordTable) = %d", sizeof(TBanwordTable));
-	sys_log(0, "sizeof(TLand) = %d", sizeof(building::TLand));
-	sys_log(0, "sizeof(TObjectProto) = %d", sizeof(building::TObjectProto));
-	sys_log(0, "sizeof(TObject) = %d", sizeof(building::TObject));
-	// ADMIN_MANAGER
-	sys_log(0, "sizeof(tAdminInfo) = %d * %d ", sizeof(tAdminInfo) * vAdmin.size());
-	// END_ADMIN_MANAGER
-	sys_log(0, "sizeof(TMonarchInfo) = %d * %d", sizeof(TMonarchInfo));
-#ifdef __GROWTH_PET_SYSTEM__
-	sys_log(0, "sizeof(TGrowthPetSkillTable) = %d", sizeof(TGrowthPetSkillTable));
-#endif
-
-	peer->EncodeWORD(sizeof(TMobTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
-	peer->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
-
-	peer->EncodeWORD(sizeof(TItemTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
-	peer->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
-
-	peer->EncodeWORD(sizeof(TShopTable));
-	peer->EncodeWORD(m_iShopTableSize);
-	peer->Encode(m_pShopTable, sizeof(TShopTable) * m_iShopTableSize);
-
-	peer->EncodeWORD(sizeof(TSkillTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
-	peer->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
-
-	peer->EncodeWORD(sizeof(TRefineTable));
-	peer->EncodeWORD(m_iRefineTableSize);
-	peer->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
-
-	peer->EncodeWORD(sizeof(TItemAttrTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_itemAttrTable.size()));
-	peer->Encode(&m_vec_itemAttrTable[0], sizeof(TItemAttrTable) * m_vec_itemAttrTable.size());
-
-	peer->EncodeWORD(sizeof(TItemAttrTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_itemRareTable.size()));
-	peer->Encode(&m_vec_itemRareTable[0], sizeof(TItemAttrTable) * m_vec_itemRareTable.size());
-
-	peer->EncodeWORD(sizeof(TBanwordTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
-	peer->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
-
-	peer->EncodeWORD(sizeof(building::TLand));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_kLandTable.size()));
-	peer->Encode(&m_vec_kLandTable[0], sizeof(building::TLand) * m_vec_kLandTable.size());
-
-	peer->EncodeWORD(sizeof(building::TObjectProto));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_kObjectProto.size()));
-	peer->Encode(&m_vec_kObjectProto[0], sizeof(building::TObjectProto) * m_vec_kObjectProto.size());
-
-	peer->EncodeWORD(sizeof(building::TObject));
-	peer->EncodeWORD(static_cast<WORD>(m_map_pkObjectTable.size()));
-
-	auto it = m_map_pkObjectTable.begin();
-	while (it != m_map_pkObjectTable.end())
-		peer->Encode((it++)->second, sizeof(building::TObject));
-
-#ifdef __GROWTH_PET_SYSTEM__
-	peer->EncodeWORD(sizeof(TGrowthPetSkillTable));
-	peer->EncodeWORD(m_vec_growthPetSkillTable.size());
-	if (m_vec_growthPetSkillTable.size())
-		peer->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
-#endif
-
-	time_t now = time(0);
-	peer->Encode(&now, sizeof(time_t));
-
-	TItemIDRangeTable itemRange = CItemIDRangeManager::instance().GetRange();
-	TItemIDRangeTable itemRangeSpare = CItemIDRangeManager::instance().GetRange();
-
-	peer->EncodeWORD(sizeof(TItemIDRangeTable));
-	peer->EncodeWORD(1);
-	peer->Encode(&itemRange, sizeof(TItemIDRangeTable));
-	peer->Encode(&itemRangeSpare, sizeof(TItemIDRangeTable));
-
-	peer->SetItemIDRange(itemRange);
-	peer->SetSpareItemIDRange(itemRangeSpare);
-
-	// ADMIN_MANAGER
-	peer->EncodeWORD(16);
-	peer->EncodeWORD(static_cast<WORD>(vHost.size()));
-
-	for (size_t n = 0; n < vHost.size(); ++n)
-	{
-		peer->Encode(vHost[n].c_str(), 16);
-		sys_log(0, "GMHosts %s", vHost[n].c_str());
-	}
-
-	peer->EncodeWORD(sizeof(tAdminInfo));
-	peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
-
-	for (size_t n = 0; n < vAdmin.size(); ++n)
-	{
-		peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
-		sys_log(0, "Admin name %s ConntactIP %s", vAdmin[n].m_szName, vAdmin[n].m_szContactIP);
-	}
-	// END_ADMIN_MANAGER
-
-	// MONARCH
-	peer->EncodeWORD(sizeof(TMonarchInfo));
-	peer->EncodeWORD(1);
-	peer->Encode(CMonarch::instance().GetMonarch(), sizeof(TMonarchInfo));
-
-	CMonarch::VEC_MONARCHCANDIDACY& rVecMonarchCandidacy = CMonarch::instance().GetVecMonarchCandidacy();
-
-	size_t num_monarch_candidacy = CMonarch::instance().MonarchCandidacySize();
-	peer->EncodeWORD(sizeof(MonarchCandidacy));
-	peer->EncodeWORD(static_cast<WORD>(num_monarch_candidacy));
-	if (num_monarch_candidacy != 0)
-	{
-		peer->Encode(&rVecMonarchCandidacy[0], sizeof(MonarchCandidacy) * num_monarch_candidacy);
-	}
-	// END_MONARCE
-
-	if (g_test_server)
-		sys_log(0, "MONARCHCandidacy Size %d", CMonarch::instance().MonarchCandidacySize());
-
-#ifdef __OFFLINE_SHOP__
-	peer->EncodeDWORD(sizeof(TOfflineShop));
-	peer->EncodeDWORD(offlineShopCache_.size());
-	for (const auto& entry : offlineShopCache_) {
-		peer->Encode(entry.second->Get(), sizeof(TOfflineShop));
-	}
-
-	peer->EncodeDWORD(sizeof(TOfflineShopItem));
-	peer->EncodeDWORD(offlineShopItemCache_.size());
-	for (const auto& entry : offlineShopItemCache_) {
-		peer->Encode(entry.second->Get(), sizeof(TOfflineShopItem));
-	}
-#endif
-
-	peer->EncodeWORD(0xffff);
-}
-
-void CClientManager::SendPartyOnSetup(CPeer* pkPeer)
-{
-	TPartyMap& pm = m_map_pkChannelParty[pkPeer->GetChannel()];
-	for (auto it_party = pm.begin(); it_party != pm.end(); ++it_party)
-	{
-		sys_log(0, "PARTY SendPartyOnSetup Party [%u]", it_party->first);
-		pkPeer->EncodeHeader(HEADER_DG_PARTY_CREATE, 0, sizeof(TPacketPartyCreate));
-		pkPeer->Encode(&it_party->first, sizeof(DWORD));
-
-		for (auto it_member = it_party->second.begin(); it_member != it_party->second.end(); ++it_member)
-		{
-			sys_log(0, "PARTY SendPartyOnSetup Party [%u] Member [%u]", it_party->first, it_member->first);
-			pkPeer->EncodeHeader(HEADER_DG_PARTY_ADD, 0, sizeof(TPacketPartyAdd));
-			pkPeer->Encode(&it_party->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->second.bRole, sizeof(BYTE));
-
-			pkPeer->EncodeHeader(HEADER_DG_PARTY_SET_MEMBER_LEVEL, 0, sizeof(TPacketPartySetMemberLevel));
-			pkPeer->Encode(&it_party->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->second.bLevel, sizeof(BYTE));
-		}
-	}
-}
-
-void CClientManager::QUERY_PLAYER_COUNT(CPeer* pkPeer, TPlayerCountPacket* pPacket)
-{
-	pkPeer->SetUserCount(pPacket->dwCount);
-}
-
-void CClientManager::QUERY_QUEST_SAVE(CPeer* pkPeer, TQuestTable* pTable, DWORD dwLen)
-{
-	if (0 != (dwLen % sizeof(TQuestTable)))
-	{
-		sys_err("invalid packet size %d, sizeof(TQuestTable) == %d", dwLen, sizeof(TQuestTable));
-		return;
-	}
-
-	int iSize = dwLen / sizeof(TQuestTable);
-
-	char szQuery[1024];
-
-	for (int i = 0; i < iSize; ++i, ++pTable)
-	{
-		if (pTable->lValue == 0)
-		{
-			snprintf(szQuery, sizeof(szQuery), "DELETE FROM quest%s WHERE `dwPID` = %d AND `szName` = '%s' AND `szState` ='%s'",
-				GetTablePostfix(), pTable->dwPID, pTable->szName, pTable->szState);
-		}
-		else
-		{
-			snprintf(szQuery, sizeof(szQuery), "REPLACE INTO quest%s (`dwPID`, `szName`, `szState`, `lValue`) VALUES(%d, '%s', '%s', %ld)",
-				GetTablePostfix(), pTable->dwPID, pTable->szName, pTable->szState, pTable->lValue);
-		}
-
-		CDBManager::instance().ReturnQuery(szQuery, QID_QUEST_SAVE, pkPeer->GetHandle(), NULL);
-	}
-}
-
-void CClientManager::QUERY_SAFEBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TSafeboxLoadPacket* packet, bool bMall)
-{
-	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
-	strlcpy(pi->safebox_password, packet->szPassword, sizeof(pi->safebox_password));
-	pi->account_id = packet->dwID;
-	pi->account_index = 0;
-	pi->ip[0] = bMall ? 1 : 0;
-	strlcpy(pi->login, packet->szLogin, sizeof(pi->login));
-
-	char szQuery[QUERY_MAX_LEN];
-	snprintf(szQuery, sizeof(szQuery),
-		"SELECT `account_id`, `size`, `password` FROM safebox%s WHERE `account_id` = %u",
-		GetTablePostfix(), packet->dwID);
-
-	if (g_log)
-		sys_log(0, "HEADER_GD_SAFEBOX_LOAD (handle: %d account.id %u is_mall %d)", dwHandle, packet->dwID, bMall ? 1 : 0);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
-}
-
-void CClientManager::RESULT_SAFEBOX_LOAD(CPeer* pkPeer, SQLMsg* msg)
-{
-	sys_log(0, "RESULT_SAFEBOX_LOAD");
-
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = pi->dwHandle;
-
-	// 여기에서 사용하는 account_index는 쿼리 순서를 말한다.
-	// 첫번째 패스워드 알아내기 위해 하는 쿼리가 0
-	// 두번째 실제 데이터를 얻어놓는 쿼리가 1
-
-	if (pi->account_index == 0)
-	{
-		sys_log(0, "RESULT_SAFEBOX_LOAD account_index == 0");
-
-		char szSafeboxPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
-		strlcpy(szSafeboxPassword, pi->safebox_password, sizeof(szSafeboxPassword));
-
-		TSafeboxTable* pSafebox = new TSafeboxTable;
-		memset(pSafebox, 0, sizeof(TSafeboxTable));
-
-		SQLResult* res = msg->Get();
-
-		if (res->uiNumRows == 0)
-		{
-			if (strcmp("000000", szSafeboxPassword))
-			{
-				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
-				delete pSafebox;
-				delete pi;
-				return;
-			}
-		}
-		else
-		{
-			sys_log(0, "RESULT_SAFEBOX_LOAD get rows");
-
-			MYSQL_ROW row = mysql_fetch_row(res->pSQLResult);
-
-			// 비밀번호가 틀리면..
-			if (((!row[2] || !*row[2]) && strcmp("000000", szSafeboxPassword)) ||
-				((row[2] && *row[2]) && strcmp(row[2], szSafeboxPassword)))
-			{
-				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
-				delete pSafebox;
-				delete pi;
-				return;
-			}
-
-			if (!row[0])
-				pSafebox->dwID = 0;
-			else
-				str_to_number(pSafebox->dwID, row[0]);
-
-			if (!row[1])
-				pSafebox->bSize = 0;
-			else
-				str_to_number(pSafebox->bSize, row[1]);
-			/*
-			if (!row[3])
-				pSafebox->dwGold = 0;
-			else
-				pSafebox->dwGold = atoi(row[3]);
-			*/
-			if (pi->ip[0] == 1)
-			{
-#if defined(__EXTEND_MALLBOX__)
-				pSafebox->bSize = 5;
-#else
-				pSafebox->bSize = 1;
-#endif
-				sys_log(0, "MALL id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
-			}
-			else
-				sys_log(0, "SAFEBOX id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
-		}
-
-		if (0 == pSafebox->dwID)
-			pSafebox->dwID = pi->account_id;
-
-		pi->pSafebox = pSafebox;
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
-#if defined(__SOUL_BIND_SYSTEM__)
-			", `soulbind`"
-#endif
-			", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-			", `socket3`, `socket4`, `socket5`"
-#endif
-			", `attrtype0`, `attrvalue0`"
-			", `attrtype1`, `attrvalue1`"
-			", `attrtype2`, `attrvalue2`"
-			", `attrtype3`, `attrvalue3`"
-			", `attrtype4`, `attrvalue4`"
-			", `attrtype5`, `attrvalue5`"
-			", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			", `transmutation`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			", `refine_element_apply_type`"
-			", `refine_element_grade`"
-			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			", `apply_type0`, `apply_value0`, `apply_path0`"
-			", `apply_type1`, `apply_value1`, `apply_path1`"
-			", `apply_type2`, `apply_value2`, `apply_path2`"
-			", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-			", `set_value`"
-#endif
-			" FROM `item%s` WHERE `owner_id` = %u AND `window` = '%s'",
-			GetTablePostfix(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL");
-
-		pi->account_index = 1;
-
-		CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
-	}
-	else
-	{
-		sys_log(0, "RESULT_SAFEBOX_LOAD YES!!!!!!!!!!!");
-
-		if (!pi->pSafebox)
-		{
-			sys_err("null safebox pointer!");
-			delete pi;
-			return;
-		}
-
-		// 쿼리에 에러가 있었으므로 응답할 경우 창고가 비어있는 것 처럼
-		// 보이기 때문에 창고가 아얘 안열리는게 나음
-		if (!msg->Get()->pSQLResult)
-		{
-			sys_err("null safebox result");
-			delete pi;
-			return;
-		}
-
-		static std::vector<TPlayerItem> s_items;
-		CreateItemTableFromRes(msg->Get()->pSQLResult, &s_items, pi->account_id);
-
-		ItemAwardSet* pSet = ItemAwardManager::instance().GetByLogin(pi->login);
-
-		// Anti-dupe hardening: prevent duplicate/concurrent processing of item_award for the same login.
-		struct _ItemAwardCheckoutGuard
-		{
-			static std::set<std::string>& Set()
-			{
-				static std::set<std::string> s_inflight;
-				return s_inflight;
-			}
-			std::string login;
-			bool active;
-			_ItemAwardCheckoutGuard(const char* szLogin) : login(szLogin ? szLogin : ""), active(false)
-			{
-				auto& s = Set();
-				if (!login.empty() && s.insert(login).second)
-					active = true;
-			}
-			~_ItemAwardCheckoutGuard()
-			{
-				if (!active) return;
-				auto& s = Set();
-				s.erase(login);
-			}
-			operator bool() const { return active; }
-		};
-		_ItemAwardCheckoutGuard _award_guard(pi->login);
-		if (pSet && !_award_guard)
-		{
-			sys_log(0, "ItemAward checkout skipped (already in progress): %s", pi->login);
-			pSet = NULL;
-		}
-
-		if (pSet && !m_vec_itemTable.empty())
-		{
-#if defined(__EXTEND_MALLBOX__)
-			CGrid grid(5, MAX(1, 5) * 9);
-#else
-			CGrid grid(5, MAX(1, pi->pSafebox->bSize) * 9);
-#endif
-			bool bEscape = false;
-
-			for (DWORD i = 0; i < s_items.size(); ++i)
-			{
-				TPlayerItem& r = s_items[i];
-
-				auto it = m_map_itemTableByVnum.find(r.dwVnum);
-				if (it == m_map_itemTableByVnum.end())
-				{
-					bEscape = true;
-					sys_err("invalid item vnum %u in safebox: login %s", r.dwVnum, pi->login);
-					break;
-				}
-
-				grid.Put(r.wPos, 1, it->second->bSize);
-			}
-
-			if (!bEscape)
-			{
-				std::vector<std::pair<DWORD, DWORD> > vec_dwFinishedAwardID;
-				ItemAwardSet::const_iterator it = pSet->begin();
-				char szQuery[512];
-
-				while (it != pSet->end())
-				{
-					TItemAward* pItemAward = *(it++);
-					const DWORD& dwItemVnum = pItemAward->dwVnum;
-
-					if (pItemAward->bTaken)
-						continue;
-
-					if (pi->ip[0] == 0 && pItemAward->bMall)
-						continue;
-
-					if (pi->ip[0] == 1 && !pItemAward->bMall)
-						continue;
-
-					auto it = m_map_itemTableByVnum.find(pItemAward->dwVnum);
-					if (it == m_map_itemTableByVnum.end())
-					{
-						sys_err("invalid item vnum %u in item_award: login %s", pItemAward->dwVnum, pi->login);
-						continue;
-					}
-
-					TItemTable* pItemTable = it->second;
-
-					int iPos;
-
-					if ((iPos = grid.FindBlank(1, it->second->bSize)) == -1)
-						break;
-
-					TPlayerItem item;
-					memset(&item, 0, sizeof(TPlayerItem));
-
-#if defined(__EXTENDED_ITEM_AWARD__)
-					DWORD dwSocket0 = pItemAward->dwSocket0;
-					DWORD dwSocket2 = pItemAward->dwSocket2;
-					DWORD dwSocket4 = pItemAward->dwSocket4;
-					DWORD dwSocket5 = pItemAward->dwSocket5;
-#else
-					DWORD dwSocket2 = 0;
-#endif
-
-					if (pItemTable->bType == ITEM_UNIQUE)
-					{
-#if defined(__EXTENDED_ITEM_AWARD__)
-						// 12.04.2019 - Correction for unique items based on the real time.
-						const long lValue0 = pItemTable->alValues[ITEM_SOCKET_REMAIN_SEC];
-						const long lValue2 = pItemTable->alValues[ITEM_SOCKET_UNIQUE_REMAIN_TIME];
-						const time_t tNow = CClientManager::instance().GetCurrentTime();
-						dwSocket2 = (lValue2 == 0) ? static_cast<DWORD>(lValue0) : static_cast<DWORD>(tNow + lValue0);
-#else
-						if (pItemAward->dwSocket2 != 0)
-							dwSocket2 = pItemAward->dwSocket2;
-						else
-							dwSocket2 = pItemTable->alValues[0];
-#endif
-					}
-					else if ((dwItemVnum == ITEM_SKILLBOOK_VNUM || dwItemVnum == ITEM_SKILLFORGET_VNUM) && pItemAward->dwSocket0 == 0)
-					{
-						DWORD dwSkillIdx;
-						DWORD dwSkillVnum;
-
-						do
-						{
-							dwSkillIdx = number(0, m_vec_skillTable.size() - 1);
-
-							dwSkillVnum = m_vec_skillTable[dwSkillIdx].dwVnum;
-
-							if (dwSkillVnum > 120)
-								continue;
-
-							break;
-						} while (1);
-
-#if !defined(__EXTENDED_ITEM_AWARD__)
-						pItemAward->dwSocket0 = dwSkillVnum;
-#endif
-					}
-					else
-					{
-						switch (dwItemVnum)
-						{
-							case 72723: case 72724: case 72725: case 72726:
-							case 72727: case 72728: case 72729: case 72730:
-								// 무시무시하지만 이전에 하던 걸 고치기는 무섭고...
-								// 그래서 그냥 하드 코딩. 선물 상자용 자동물약 아이템들.
-							case 76004: case 76005: case 76021: case 76022:
-							case 79012: case 79013:
-								if (pItemAward->dwSocket2 == 0)
-								{
-									dwSocket2 = pItemTable->alValues[0];
-								}
-								else
-								{
-									dwSocket2 = pItemAward->dwSocket2;
-								}
-								break;
-						}
-					}
-
-					if (GetItemID() > m_itemRange.dwMax)
-					{
-						sys_err("UNIQUE ID OVERFLOW!!");
-						break;
-					}
-
-					{
-						auto it = m_map_itemTableByVnum.find(dwItemVnum);
-						if (it == m_map_itemTableByVnum.end())
-						{
-							sys_err("Invalid item(vnum : %d). It is not in m_map_itemTableByVnum.", dwItemVnum);
-							continue;
-						}
-						TItemTable* item_table = it->second;
-						if (item_table == NULL)
-						{
-							sys_err("Invalid item_table (vnum : %d). It's value is NULL in m_map_itemTableByVnum.", dwItemVnum);
-							continue;
-						}
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-						if ((item_table->bType == ITEM_UNIQUE && item_table->bType == COSTUME_MOUNT))
-						{
-							if (pItemAward->dwSocket4 == 0)
-								dwSocket4 = pItemTable->alValues[0];
-							else
-								dwSocket4 = pItemAward->dwSocket4;
-						}
-#endif
-
-						if (0 == pItemAward->dwSocket0)
-						{
-							// Load default values
-							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-							{
-								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
-									break;
-								}
-								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
-									break;
-								}
-							}
-						}
-						else
-						{
-#if defined(__EXTENDED_ITEM_AWARD__)
-							// Load set values
-							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-							{
-								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
-								{
-									dwSocket0 = time(0) + pItemAward->dwSocket0;
-									break;
-								}
-								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
-								{
-									dwSocket0 = pItemAward->dwSocket0;
-									break;
-								}
-							}
-#else
-							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-							{
-								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
-
-									break;
-								}
-								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
-
-									break;
-								}
-							}
-#endif
-						}
-
-#if defined(__EXTENDED_ITEM_AWARD__)
-						ItemAwardManager::instance().CheckItemCount(*pItemAward, *pItemTable);
-						ItemAwardManager::instance().CheckItemBlend(*pItemAward, *pItemTable);
-						ItemAwardManager::instance().CheckItemAddonType(*pItemAward, *pItemTable);
-						ItemAwardManager::instance().CheckItemSkillBook(*pItemAward, m_vec_skillTable);
-						ItemAwardManager::instance().CheckItemAttributes(*pItemAward, *pItemTable, m_vec_itemAttrTable);
-
-						// START_OF_AUTO_QUERY
-						char szColumns[QUERY_MAX_LEN], szValues[QUERY_MAX_LEN];
-
-						int iLen = snprintf(szColumns, sizeof(szColumns), "`id`, `owner_id`, `window`, `pos`, `vnum`, `count`");
-						int iValueLen = snprintf(szValues, sizeof(szValues), "%u, %u, '%s', %d, %u, %u", GainItemID(), pi->account_id, (pi->ip[0] == 0) ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount);
-
-#if defined(__ITEM_SOCKET6__)
-						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`, `socket3`, `socket4`, `socket5`");
-						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u, %u, %u, %u", dwSocket0, pItemAward->dwSocket1, dwSocket2, pItemAward->dwSocket3, pItemAward->dwSocket4, pItemAward->dwSocket5);
-#else
-						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`");
-						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u", pItemAward->dwSocket0, pItemAward->dwSocket1, dwSocket2);
-#endif
-
-						for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
-						{
-							iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `attrtype%d`, `attrvalue%d`", i, i);
-							iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %ld", pItemAward->aAttr[i].wType, pItemAward->aAttr[i].lValue);
-						}
-						// END_OF_AUTO_QUERY
-
-						snprintf(szQuery, sizeof(szQuery), "INSERT INTO item%s (%s) VALUES(%s)", GetTablePostfix(), szColumns, szValues);
-#else
-						snprintf(szQuery, sizeof(szQuery),
-							"INSERT INTO item%s (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
-							", `socket0`"
-							", `socket1`"
-							", `socket2`"
-#if defined(__ITEM_SOCKET6__)
-							", `socket3`"
-							", `socket4`"
-							", `socket5`"
-#endif
-							") VALUES (%u, %u, '%s', %d, %u, %u"
-							", %u"
-							", %u"
-							", %u"
-#if defined(__ITEM_SOCKET6__)
-							", %u"
-							", %u"
-							", %u"
-#endif
-							")",
-							GetTablePostfix(), GainItemID(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount
-							, pItemAward->dwSocket0
-							, pItemAward->dwSocket1
-							, dwSocket2
-#if defined(__ITEM_SOCKET6__)
-							, pItemAward->dwSocket3
-							, pItemAward->dwSocket4
-							, pItemAward->dwSocket5
-#endif
-						);
-#endif
-					}
-
-					std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-					SQLResult* pRes = pmsg->Get();
-					sys_log(0, "SAFEBOX Query : [%s]", szQuery);
-
-					if (pRes->uiAffectedRows == 0 || pRes->uiInsertID == 0 || pRes->uiAffectedRows == (uint32_t)-1)
-						break;
-
-					item.dwID = pmsg->Get()->uiInsertID;
-					if (pi->ip[0] == 0)
-						item.bWindow = SAFEBOX, item.wPos = iPos;
-					else
-						item.bWindow = MALL, item.wPos = iPos;
-					item.dwVnum = pItemAward->dwVnum;
-					item.dwCount = pItemAward->dwCount;
-#if defined(__EXTENDED_ITEM_AWARD__)
-					item.alSockets[0] = dwSocket0;
-#else
-					item.alSockets[0] = pItemAward->dwSocket0;
-#endif
-					item.alSockets[1] = pItemAward->dwSocket1;
-					item.alSockets[2] = dwSocket2;
-#if defined(__ITEM_SOCKET6__)
-					item.alSockets[3] = pItemAward->dwSocket3;
-					item.alSockets[4] = dwSocket4;
-					item.alSockets[5] = dwSocket5;
-#endif
-#if defined(__EXTENDED_ITEM_AWARD__)
-					thecore_memcpy(&item.aAttr, pItemAward->aAttr, sizeof(item.aAttr));
-#endif
-					s_items.push_back(item);
-
-					vec_dwFinishedAwardID.push_back(std::make_pair(pItemAward->dwID, item.dwID));
-					grid.Put(iPos, 1, it->second->bSize);
-				}
-
-				for (DWORD i = 0; i < vec_dwFinishedAwardID.size(); ++i)
-					ItemAwardManager::instance().Taken(vec_dwFinishedAwardID[i].first, vec_dwFinishedAwardID[i].second);
-			}
-		}
-
-		pi->pSafebox->wItemCount = static_cast<WORD>(s_items.size());
-
-#ifdef __GROWTH_PET_SYSTEM__
-		static std::vector<TGrowthPet> s_petVec;
-
-		// Loads pets only when opening safebox with items
-		if (pi->ip[0] == 0 && !s_items.empty())
-		{
-			char szQuery[QUERY_MAX_LEN];
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT id,vnum,state+0,name,size,level,level_step,evolution,type,hp,sp,def,hp_apply,sp_apply,def_apply,"
-				"age_apply,skill_level,exp,item_exp,UNIX_TIMESTAMP(birthday),end_time,max_time "
-				"FROM growth_pet%s WHERE owner_id=%d AND state=%d",
-				GetTablePostfix(), pi->account_id, STATE_SAFEBOX);
-
-			std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(szQuery));
-			MYSQL_RES* pRes = pkMsg->Get()->pSQLResult;
-			CreateGrowthPetTableFromRes(pRes, &s_petVec, pi->account_id);
-		}
-#endif
-
-		if (pi->ip[0] == 0)
-			pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
-#ifdef __GROWTH_PET_SYSTEM__
-			+ sizeof(WORD) + sizeof(TGrowthPet) * s_petVec.size()
-#endif
-		);
-		else
-			pkPeer->EncodeHeader(HEADER_DG_MALL_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
-
-		);
-
-		pkPeer->Encode(pi->pSafebox, sizeof(TSafeboxTable));
-
-		if (!s_items.empty())
-			pkPeer->Encode(&s_items[0], sizeof(TPlayerItem) * s_items.size());
-
-#ifdef __GROWTH_PET_SYSTEM__
-		pkPeer->EncodeWORD((WORD)s_petVec.size());
-
-		if (!s_petVec.empty())
-			pkPeer->Encode(&s_petVec[0], sizeof(TGrowthPet) * s_petVec.size());
-#endif
-
-		delete pi;
-	}
-}
-
-void CClientManager::QUERY_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangeSizePacket* p)
-{
-	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
-	pi->account_index = p->bSize; // account_index를 사이즈로 임시로 사용
-
-	char szQuery[QUERY_MAX_LEN];
-
-	if (p->bSize == 1)
-		snprintf(szQuery, sizeof(szQuery), "INSERT INTO safebox%s (`account_id`, `size`) VALUES(%u, %u)", GetTablePostfix(), p->dwID, p->bSize);
-	else
-		snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `size` = %u WHERE `account_id` = %u", GetTablePostfix(), p->bSize, p->dwID);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_SIZE, pkPeer->GetHandle(), pi);
-}
-
-void CClientManager::RESULT_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = p->dwHandle;
-	BYTE bSize = p->account_index;
-
-	delete p;
-
-	if (msg->Get()->uiNumRows > 0)
-	{
-		pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_SIZE, dwHandle, sizeof(BYTE));
-		pkPeer->EncodeBYTE(bSize);
-	}
-}
-
-void CClientManager::QUERY_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangePasswordPacket* p)
-{
-	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
-	strlcpy(pi->safebox_password, p->szNewPassword, sizeof(pi->safebox_password));
-	strlcpy(pi->login, p->szOldPassword, sizeof(pi->login));
-	pi->account_id = p->dwID;
-
-	char szQuery[QUERY_MAX_LEN];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `password` FROM safebox%s WHERE `account_id` = %u", GetTablePostfix(), p->dwID);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD, pkPeer->GetHandle(), pi);
-}
-
-void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = p->dwHandle;
-
-	if (msg->Get()->uiNumRows > 0)
-	{
-		MYSQL_ROW row = mysql_fetch_row(msg->Get()->pSQLResult);
-
-		if ((row[0] && *row[0] && !strcasecmp(row[0], p->login)) || ((!row[0] || !*row[0]) && !strcmp("000000", p->login)))
-		{
-			char szQuery[QUERY_MAX_LEN];
-			char escape_pwd[64];
-			CDBManager::instance().EscapeString(escape_pwd, p->safebox_password, strlen(p->safebox_password));
-
-			snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `password` = '%s' WHERE `account_id` = %u", GetTablePostfix(), escape_pwd, p->account_id);
-
-			CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD_SECOND, pkPeer->GetHandle(), p);
-			return;
-		}
-	}
-
-	delete p;
-
-	// Wrong old password
-	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
-	pkPeer->EncodeBYTE(0);
-}
-
-void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(CPeer* pkPeer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = p->dwHandle;
-	delete p;
-
-	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
-	pkPeer->EncodeBYTE(1);
-}
-
-// MYSHOP_PRICE_LIST
-void CClientManager::RESULT_PRICELIST_LOAD(CPeer* peer, SQLMsg* pMsg)
-{
-	TItemPricelistReqInfo* pReqInfo = (TItemPricelistReqInfo*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
-
-	//
-	// DB 에서 로드한 정보를 Cache 에 저장
-	//
-
-	TItemPriceListTable table;
-	table.dwOwnerID = pReqInfo->second;
-	table.byCount = 0;
-
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
-		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
-#if defined(__CHEQUE_SYSTEM__)
-		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
-#endif
-		table.byCount++;
-	}
-
-	PutItemPriceListCache(&table);
-
-	//
-	// 로드한 데이터를 Game server 에 전송
-	//
-
-	TPacketMyshopPricelistHeader header;
-
-	header.dwOwnerID = pReqInfo->second;
-	header.byCount = table.byCount;
-
-	size_t sizePriceListSize = sizeof(TItemPriceInfo) * header.byCount;
-
-	peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, pReqInfo->first, sizeof(header) + sizePriceListSize);
-	peer->Encode(&header, sizeof(header));
-	peer->Encode(table.aPriceInfo, sizePriceListSize);
-
-	sys_log(0, "Load MyShopPricelist handle[%d] pid[%d] count[%d]", pReqInfo->first, pReqInfo->second, header.byCount);
-
-	delete pReqInfo;
-}
-
-void CClientManager::RESULT_PRICELIST_LOAD_FOR_UPDATE(SQLMsg* pMsg)
-{
-	TItemPriceListTable* pUpdateTable = (TItemPriceListTable*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
-
-	//
-	// DB 에서 로드한 정보를 Cache 에 저장
-	//
-
-	TItemPriceListTable table{};
-	table.dwOwnerID = pUpdateTable->dwOwnerID;
-	table.byCount = 0;
-
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
-		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
-#if defined(__CHEQUE_SYSTEM__)
-		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
-#endif
-		table.byCount++;
-	}
-
-	PutItemPriceListCache(&table);
-
-	// Update cache
-	GetItemPriceListCache(pUpdateTable->dwOwnerID)->UpdateList(pUpdateTable);
-
-	delete pUpdateTable;
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-void CClientManager::QUERY_SAFEBOX_SAVE(CPeer* pkPeer, TSafeboxTable* pTable)
-{
-	char szQuery[QUERY_MAX_LEN];
-
-	snprintf(szQuery, sizeof(szQuery),
-		"UPDATE safebox%s SET `gold` = '%u' WHERE `account_id` = %u",
-		GetTablePostfix(), pTable->dwGold, pTable->dwID);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_SAVE, pkPeer->GetHandle(), NULL);
-}
-
-void CClientManager::QUERY_EMPIRE_SELECT(CPeer* pkPeer, DWORD dwHandle, TEmpireSelectPacket* p)
-{
-	char szQuery[QUERY_MAX_LEN];
-
-	snprintf(szQuery, sizeof(szQuery), "UPDATE player_index%s SET `empire` = %u WHERE `id` = %u", GetTablePostfix(), p->bEmpire, p->dwAccountID);
-	delete CDBManager::instance().DirectQuery(szQuery);
-
-	sys_log(0, "EmpireSelect: %s", szQuery);
-	{
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `pid1`"
-			", `pid2`"
-			", `pid3`"
-			", `pid4`"
-#if defined(__PLAYER_PER_ACCOUNT5__)
-			", `pid5`"
-#endif
-			" FROM player_index%s WHERE `id` = %u", GetTablePostfix(), p->dwAccountID);
-
-		std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-		SQLResult* pRes = pmsg->Get();
-
-		if (pRes->uiNumRows)
-		{
-			sys_log(0, "EMPIRE %lu", pRes->uiNumRows);
-
-			MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
-			DWORD pids[3];
-
-			UINT g_start_map[4] =
-			{
-				0, // reserved
-				1, // 신수국
-				21, // 천조국
-				41 // 진노국
-			};
-
-			// FIXME share with game
-			DWORD g_start_position[4][2] =
-			{
-				{ 0, 0 },
-				{ 469300, 964200 }, // 신수국
-				{ 55700, 157900 }, // 천조국
-				{ 969600, 278400 } // 진노국
-			};
-
-			for (int i = 0; i < 3; ++i)
-			{
-				str_to_number(pids[i], row[i]);
-				sys_log(0, "EMPIRE PIDS[%d]", pids[i]);
-
-				if (pids[i])
-				{
-					sys_log(0, "EMPIRE move to pid[%d] to villiage of %u, map_index %d",
-						pids[i], p->bEmpire, g_start_map[p->bEmpire]);
-
-					snprintf(szQuery, sizeof(szQuery), "UPDATE player%s SET `map_index` = %u, `x` = %u, `y` = %u WHERE `id` = %u",
-						GetTablePostfix(),
-						g_start_map[p->bEmpire],
-						g_start_position[p->bEmpire][0],
-						g_start_position[p->bEmpire][1],
-						pids[i]);
-
-					std::unique_ptr<SQLMsg> pmsg2(CDBManager::instance().DirectQuery(szQuery));
-				}
-			}
-		}
-	}
-
-	pkPeer->EncodeHeader(HEADER_DG_EMPIRE_SELECT, dwHandle, sizeof(BYTE));
-	pkPeer->EncodeBYTE(p->bEmpire);
-}
-
-void CClientManager::QUERY_SETUP(CPeer* peer, DWORD dwHandle, const char* c_pData)
-{
-	TPacketGDSetup* p = (TPacketGDSetup*)c_pData;
-	c_pData += sizeof(TPacketGDSetup);
-
-	if (p->bAuthServer)
-	{
-		sys_log(0, "AUTH_PEER ptr %p", peer);
-
-		m_pkAuthPeer = peer;
-		return;
-	}
-
-	peer->SetPublicIP(p->szPublicIP);
-	peer->SetChannel(p->bChannel);
-	peer->SetListenPort(p->wListenPort);
-	peer->SetP2PPort(p->wP2PPort);
-	peer->SetMaps(p->alMaps);
-
-	//
-	// 어떤 맵이 어떤 서버에 있는지 보내기
-	//
-	TMapLocation kMapLocations;
-
-	strlcpy(kMapLocations.szHost, peer->GetPublicIP(), sizeof(kMapLocations.szHost));
-	kMapLocations.wPort = peer->GetListenPort();
-	thecore_memcpy(kMapLocations.alMaps, peer->GetMaps(), sizeof(kMapLocations.alMaps));
-
-	BYTE bMapCount;
-
-	std::vector<TMapLocation> vec_kMapLocations;
-
-	if (peer->GetChannel() == 1)
-	{
-		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		{
-			CPeer* tmp = *i;
-
-			if (tmp == peer)
-				continue;
-
-			if (!tmp->GetChannel())
-				continue;
-
-			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
-			{
-				TMapLocation kMapLocation2;
-				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
-				kMapLocation2.wPort = tmp->GetListenPort();
-				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
-				vec_kMapLocations.push_back(kMapLocation2);
-
-				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
-				bMapCount = 1;
-				tmp->EncodeBYTE(bMapCount);
-				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
-			}
-		}
-	}
-	else if (peer->GetChannel() == GUILD_WARP_WAR_CHANNEL)
-	{
-		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		{
-			CPeer* tmp = *i;
-
-			if (tmp == peer)
-				continue;
-
-			if (!tmp->GetChannel())
-				continue;
-
-			if (tmp->GetChannel() == 1 || tmp->GetChannel() == peer->GetChannel())
-			{
-				TMapLocation kMapLocation2;
-				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
-				kMapLocation2.wPort = tmp->GetListenPort();
-				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
-				vec_kMapLocations.push_back(kMapLocation2);
-			}
-
-			tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
-			bMapCount = 1;
-			tmp->EncodeBYTE(bMapCount);
-			tmp->Encode(&kMapLocations, sizeof(TMapLocation));
-		}
-	}
-	else
-	{
-		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		{
-			CPeer* tmp = *i;
-
-			if (tmp == peer)
-				continue;
-
-			if (!tmp->GetChannel())
-				continue;
-
-			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
-			{
-				TMapLocation kMapLocation2;
-
-				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
-				kMapLocation2.wPort = tmp->GetListenPort();
-				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
-
-				vec_kMapLocations.push_back(kMapLocation2);
-			}
-
-			if (tmp->GetChannel() == peer->GetChannel())
-			{
-				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
-				bMapCount = 1;
-				tmp->EncodeBYTE(bMapCount);
-				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
-			}
-		}
-	}
-
-	vec_kMapLocations.push_back(kMapLocations);
-
-	peer->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation) * vec_kMapLocations.size());
-	bMapCount = static_cast<BYTE>(vec_kMapLocations.size());
-	peer->EncodeBYTE(bMapCount);
-	peer->Encode(&vec_kMapLocations[0], sizeof(TMapLocation) * vec_kMapLocations.size());
-
-	//
-	// 셋업 : 접속한 피어에 다른 피어들이 접속하게 만든다. (P2P 컨넥션 생성)
-	//
-	sys_log(0, "SETUP: channel %u listen %u p2p %u count %u", peer->GetChannel(), p->wListenPort, p->wP2PPort, bMapCount);
-
-	TPacketDGP2P p2pSetupPacket;
-	p2pSetupPacket.wPort = peer->GetP2PPort();
-	p2pSetupPacket.bChannel = peer->GetChannel();
-	strlcpy(p2pSetupPacket.szHost, peer->GetPublicIP(), sizeof(p2pSetupPacket.szHost));
-
-	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* tmp = *i;
-
-		if (tmp == peer)
-			continue;
-
-		// 채널이 0이라면 아직 SETUP 패킷이 오지 않은 피어 또는 auth라고 간주할 수 있음
-		if (0 == tmp->GetChannel())
-			continue;
-
-		tmp->EncodeHeader(HEADER_DG_P2P, 0, sizeof(TPacketDGP2P));
-		tmp->Encode(&p2pSetupPacket, sizeof(TPacketDGP2P));
-	}
-
-	//
-	// 로그인 및 빌링정보 보내기
-	//
-	TPacketLoginOnSetup* pck = (TPacketLoginOnSetup*)c_pData;
-
-	for (DWORD c = 0; c < p->dwLoginCount; ++c, ++pck)
-	{
-		CLoginData* pkLD = new CLoginData;
-
-		pkLD->SetKey(pck->dwLoginKey);
-		pkLD->SetClientKey(pck->adwClientKey);
-		pkLD->SetIP(pck->szHost);
-
-		TAccountTable& r = pkLD->GetAccountRef();
-
-		r.id = pck->dwID;
-		trim_and_lower(pck->szLogin, r.login, sizeof(r.login));
-		strlcpy(r.social_id, pck->szSocialID, sizeof(r.social_id));
-		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		strlcpy(r.country, pck->szCountry, sizeof(r.country));
-#endif
-
-		InsertLoginData(pkLD);
-
-		if (InsertLogonAccount(pck->szLogin, peer->GetHandle(), pck->szHost))
-		{
-			sys_log(0, "SETUP: login %u %s login_key %u host %s", pck->dwID, pck->szLogin, pck->dwLoginKey, pck->szHost);
-			pkLD->SetPlay(true);
-		}
-		else
-			sys_log(0, "SETUP: login_fail %u %s login_key %u", pck->dwID, pck->szLogin, pck->dwLoginKey);
-	}
-
-	SendPartyOnSetup(peer);
-
-	CGuildManager::instance().OnSetup(peer);
-	CPrivManager::instance().SendPrivOnSetup(peer);
-
-	SendEventFlagsOnSetup(peer);
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	SendGuildEventFlagsOnSetup(peer);
-#endif
-
-	marriage::CManager::instance().OnSetup(peer);
-}
-
-void CClientManager::QUERY_ITEM_FLUSH(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwID = *(DWORD*)c_pData;
-
-	if (g_log)
-		sys_log(0, "HEADER_GD_ITEM_FLUSH: %u", dwID);
-
-	CItemCache* c = GetItemCache(dwID);
-
-	if (c)
-		c->Flush();
-}
-
-void CClientManager::QUERY_ITEM_SAVE(CPeer* pkPeer, const char* c_pData)
-{
-	TPlayerItem* p = (TPlayerItem*)c_pData;
-
-	// 창고면 캐쉬하지 않고, 캐쉬에 있던 것도 빼버려야 한다.
-
-	if (p->bWindow == SAFEBOX || p->bWindow == MALL
-	)
-	{
-		CItemCache* c = GetItemCache(p->dwID);
-
-		if (c)
-		{
-			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
-
-			if (it != m_map_pkItemCacheSetPtr.end())
-			{
-				if (g_test_server)
-					sys_log(0, "ITEM_CACHE: safebox owner %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-
-				it->second->erase(c);
-			}
-
-			m_map_itemCache.erase(p->dwID);
-
-			delete c;
-		}
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"REPLACE INTO `item%s` (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
-#if defined(__SOUL_BIND_SYSTEM__)
-			", `soulbind`"
-#endif
-			", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-			", `socket3`, `socket4`, `socket5`"
-#endif
-			", `attrtype0`, `attrvalue0`"
-			", `attrtype1`, `attrvalue1`"
-			", `attrtype2`, `attrvalue2`"
-			", `attrtype3`, `attrvalue3`"
-			", `attrtype4`, `attrvalue4`"
-			", `attrtype5`, `attrvalue5`"
-			", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			", `transmutation`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			", `refine_element_apply_type`"
-			", `refine_element_grade`"
-			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			", `apply_type0`, `apply_value0`, `apply_path0`"
-			", `apply_type1`, `apply_value1`, `apply_path1`"
-			", `apply_type2`, `apply_value2`, `apply_path2`"
-			", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-			", `set_value`"
-#endif
-			") VALUES(%u, %u, %u, %u, %u, %u"
-#if defined(__SOUL_BIND_SYSTEM__)
-			", %ld"
-#endif
-			", %ld, %ld, %ld"
-#if defined(__ITEM_SOCKET6__)
-			", %ld, %ld, %ld"
-#endif
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			", %u"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			", %u"
-			", %u"
-			", %u, %u, %u"
-			", %u, %u, %u"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			", %u, %ld, %u"
-			", %u, %ld, %u"
-			", %u, %ld, %u"
-			", %u, %ld, %u"
-#endif
-#if defined(__SET_ITEM__)
-			", %u"
-#endif
-			")", GetTablePostfix()
-			, p->dwID
-			, p->dwOwner
-			, p->bWindow
-			, p->wPos
-			, p->dwVnum
-			, p->dwCount
-#if defined(__SOUL_BIND_SYSTEM__)
-			, p->lSealDate
-#endif
-			, p->alSockets[0], p->alSockets[1], p->alSockets[2]
-#if defined(__ITEM_SOCKET6__)
-			, p->alSockets[3], p->alSockets[4], p->alSockets[5]
-#endif
-			, p->aAttr[0].wType, p->aAttr[0].lValue
-			, p->aAttr[1].wType, p->aAttr[1].lValue
-			, p->aAttr[2].wType, p->aAttr[2].lValue
-			, p->aAttr[3].wType, p->aAttr[3].lValue
-			, p->aAttr[4].wType, p->aAttr[4].lValue
-			, p->aAttr[5].wType, p->aAttr[5].lValue
-			, p->aAttr[6].wType, p->aAttr[6].lValue
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			, p->dwTransmutationVnum
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			, p->RefineElement.wApplyType
-			, p->RefineElement.bGrade
-			, p->RefineElement.abValue[0], p->RefineElement.abValue[1], p->RefineElement.abValue[2]
-			, p->RefineElement.abBonusValue[0], p->RefineElement.abBonusValue[1], p->RefineElement.abBonusValue[2]
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			, p->aApplyRandom[0].wType, p->aApplyRandom[0].lValue, p->aApplyRandom[0].bPath
-			, p->aApplyRandom[1].wType, p->aApplyRandom[1].lValue, p->aApplyRandom[1].bPath
-			, p->aApplyRandom[2].wType, p->aApplyRandom[2].lValue, p->aApplyRandom[2].bPath
-			, p->aApplyRandom[3].wType, p->aApplyRandom[3].lValue, p->aApplyRandom[3].bPath
-#endif
-#if defined(__SET_ITEM__)
-			, p->bSetValue
-#endif
-		);
-
-		CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_SAVE, pkPeer->GetHandle(), NULL);
-	}
-	else
-	{
-		if (g_test_server)
-			sys_log(0, "QUERY_ITEM_SAVE => PutItemCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
-
-		PutItemCache(p);
-	}
-}
-
-CClientManager::TItemCacheSet* CClientManager::GetItemCacheSet(DWORD pid)
-{
-	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
-
-	if (it == m_map_pkItemCacheSetPtr.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::CreateItemCacheSet(DWORD pid)
-{
-	if (m_map_pkItemCacheSetPtr.find(pid) != m_map_pkItemCacheSetPtr.end())
-		return;
-
-	TItemCacheSet* pSet = new TItemCacheSet;
-	m_map_pkItemCacheSetPtr.insert(TItemCacheSetPtrMap::value_type(pid, pSet));
-
-	if (g_log)
-		sys_log(0, "ITEM_CACHE: new cache %u", pid);
-}
-
-void CClientManager::FlushItemCacheSet(DWORD pid)
-{
-	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
-
-	if (it == m_map_pkItemCacheSetPtr.end())
-	{
-		sys_log(0, "FLUSH_ITEMCACHESET : No ItemCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TItemCacheSet* pSet = it->second;
-	TItemCacheSet::iterator it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CItemCache* c = *it_set++;
-		c->Flush();
-
-		m_map_itemCache.erase(c->Get()->dwID);
-		delete c;
-	}
-
-	pSet->clear();
-	delete pSet;
-
-	m_map_pkItemCacheSetPtr.erase(it);
-
-	if (g_log)
-		sys_log(0, "FLUSH_ITEMCACHESET : Deleted pid(%d)", pid);
-}
-
-CItemCache* CClientManager::GetItemCache(DWORD id)
-{
-	TItemCacheMap::iterator it = m_map_itemCache.find(id);
-
-	if (it == m_map_itemCache.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::PutItemCache(TPlayerItem* pNew, bool bSkipQuery)
-{
-	CItemCache* c;
-
-	c = GetItemCache(pNew->dwID);
-
-	// 아이템 새로 생성
-	if (!c)
-	{
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: PutItemCache ==> New CItemCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
-
-		c = new CItemCache;
-		m_map_itemCache.insert(TItemCacheMap::value_type(pNew->dwID, c));
-	}
-	// 있을시
-	else
-	{
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: PutItemCache ==> Have Cache");
-
-		// 소유자가 틀리면
-		if (pNew->dwOwner != c->Get()->dwOwner)
-		{
-			// 이미 이 아이템을 가지고 있었던 유저로 부터 아이템을 삭제한다.
-			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
-
-			if (it != m_map_pkItemCacheSetPtr.end())
-			{
-				if (g_log)
-					sys_log(0, "ITEM_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
-				it->second->erase(c);
-			}
-		}
-	}
-
-	// 새로운 정보 업데이트
-	c->Put(pNew, bSkipQuery);
-
-	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
-
-	if (it != m_map_pkItemCacheSetPtr.end())
-	{
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		it->second->insert(c);
-	}
-	else
-	{
-		// 현재 소유자가 없으므로 바로 저장해야 다음 접속이 올 때 SQL에 쿼리하여
-		// 받을 수 있으므로 바로 저장한다.
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-
-		c->OnFlush();
-	}
-}
-
-bool CClientManager::DeleteItemCache(DWORD dwID)
-{
-	CItemCache* c = GetItemCache(dwID);
-
-	if (!c)
-		return false;
-
-	c->Delete();
-	return true;
-}
-
-// MYSHOP_PRICE_LIST
-CItemPriceListTableCache* CClientManager::GetItemPriceListCache(DWORD dwID)
-{
-	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.find(dwID);
-
-	if (it == m_mapItemPriceListCache.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::PutItemPriceListCache(const TItemPriceListTable* pItemPriceList)
-{
-	CItemPriceListTableCache* pCache = GetItemPriceListCache(pItemPriceList->dwOwnerID);
-
-	if (!pCache)
-	{
-		pCache = new CItemPriceListTableCache;
-		m_mapItemPriceListCache.insert(TItemPriceListCacheMap::value_type(pItemPriceList->dwOwnerID, pCache));
-	}
-
-	pCache->Put(const_cast<TItemPriceListTable*>(pItemPriceList), true);
-}
-
-void CClientManager::UpdatePlayerCache()
-{
-	TPlayerTableCacheMap::iterator it = m_map_playerCache.begin();
-
-	while (it != m_map_playerCache.end())
-	{
-		CPlayerTableCache* c = (it++)->second;
-
-		if (c->CheckTimeout())
-		{
-			if (g_log)
-				sys_log(0, "UPDATE : UpdatePlayerCache() ==> FlushPlayerCache %d %s ", c->Get(false)->id, c->Get(false)->name);
-
-			c->Flush();
-
-			// Item Cache도 업데이트
-			UpdateItemCacheSet(c->Get()->id);
-#ifdef __GROWTH_PET_SYSTEM__
-			UpdateGrowthPetCacheSet(c->Get()->id);
-#endif
-		}
-		else if (c->CheckFlushTimeout())
-			c->Flush();
-	}
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-void CClientManager::SetCacheFlushCountLimit(int iLimit)
-{
-	m_iCacheFlushCountLimit = MAX(10, iLimit);
-	sys_log(0, "CACHE_FLUSH_LIMIT_PER_SECOND: %d", m_iCacheFlushCountLimit);
-}
-
-void CClientManager::UpdateItemCache()
-{
-	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-		return;
-
-	TItemCacheMap::iterator it = m_map_itemCache.begin();
-
-	while (it != m_map_itemCache.end())
-	{
-		CItemCache* c = (it++)->second;
-
-		// 아이템은 Flush만 한다.
-		if (c->CheckFlushTimeout())
-		{
-			if (g_test_server)
-				sys_log(0, "UpdateItemCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
-
-			c->Flush();
-
-			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-				break;
-		}
-	}
-}
-
-void CClientManager::UpdateItemPriceListCache()
-{
-	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.begin();
-
-	while (it != m_mapItemPriceListCache.end())
-	{
-		CItemPriceListTableCache* pCache = it->second;
-
-		if (pCache->CheckFlushTimeout())
-		{
-			pCache->Flush();
-			m_mapItemPriceListCache.erase(it++);
-		}
-		else
-			++it;
-	}
-}
-
-void CClientManager::QUERY_ITEM_DESTROY(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwID = *(DWORD*)c_pData;
-	c_pData += sizeof(DWORD);
-
-	DWORD dwPID = *(DWORD*)c_pData;
-
-	if (!DeleteItemCache(dwID))
-	{
-		char szQuery[64];
-		snprintf(szQuery, sizeof(szQuery), "DELETE FROM item%s WHERE `id` = %u", GetTablePostfix(), dwID);
-
-		if (g_log)
-			sys_log(0, "HEADER_GD_ITEM_DESTROY: PID %u ID %u", dwPID, dwID);
-
-		if (dwPID == 0) // 아무도 가진 사람이 없었다면, 비동기 쿼리
-			CDBManager::instance().AsyncQuery(szQuery);
-		else
-			CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_DESTROY, pkPeer->GetHandle(), NULL);
-	}
-}
-
-void CClientManager::QUERY_FLUSH_CACHE(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwPID = *(DWORD*)c_pData;
-
-	CPlayerTableCache* pkCache = GetPlayerCache(dwPID);
-
-	if (!pkCache)
-		return;
-
-	sys_log(0, "FLUSH_CACHE: %u", dwPID);
-
-	pkCache->Flush();
-	FlushItemCacheSet(dwPID);
-#ifdef __GROWTH_PET_SYSTEM__
-	FlushGrowthPetCacheSet(dwPID);
-#endif
-	m_map_playerCache.erase(dwPID);
-	delete pkCache;
-}
-
-void CClientManager::QUERY_RELOAD_PROTO()
-{
-	if (!InitializeTables())
-	{
-		sys_err("QUERY_RELOAD_PROTO: cannot load tables");
-		return;
-	}
-
-	for (TPeerList::iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* tmp = *i;
-
-		if (!tmp->GetChannel())
-			continue;
-
-		tmp->EncodeHeader(HEADER_DG_RELOAD_PROTO, 0,
-			sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
-			sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
-			sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
-			sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
-			sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize
-#ifdef __GROWTH_PET_SYSTEM__
-			+ sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size()
-#endif
-		);
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
-		tmp->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
-		tmp->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
-		tmp->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
-		tmp->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_iRefineTableSize));
-		tmp->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
-
-#ifdef __GROWTH_PET_SYSTEM__
-		tmp->EncodeWORD(m_vec_growthPetSkillTable.size());
-		if (m_vec_growthPetSkillTable.size())
-			tmp->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
-#endif
-	}
-}
-
-// ADD_GUILD_PRIV_TIME
-/**
-* @version 05/06/08 Bang2ni - 지속시간 추가
-**/
-void CClientManager::AddGuildPriv(TPacketGiveGuildPriv* p)
-{
-	CPrivManager::instance().AddGuildPriv(p->guild_id, p->type, p->value, p->duration_sec);
-}
-
-void CClientManager::AddEmpirePriv(TPacketGiveEmpirePriv* p)
-{
-	CPrivManager::instance().AddEmpirePriv(p->empire, p->type, p->value, p->duration_sec);
-}
-// END_OF_ADD_GUILD_PRIV_TIME
-
-void CClientManager::AddCharacterPriv(TPacketGiveCharacterPriv* p)
-{
-	CPrivManager::instance().AddCharPriv(p->pid, p->type, p->value);
-}
-
-void CClientManager::MoneyLog(TPacketMoneyLog* p)
-{
-	CMoneyLog::instance().AddLog(p->type, p->vnum, p->gold
-#if defined(__CHEQUE_SYSTEM__)
-		, p->cheque
-#endif
-	);
-}
-
-CLoginData* CClientManager::GetLoginData(DWORD dwKey)
-{
-	TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(dwKey);
-
-	if (it == m_map_pkLoginData.end())
-		return NULL;
-
-	return it->second;
-}
-
-CLoginData* CClientManager::GetLoginDataByLogin(const char* c_pszLogin)
-{
-	char szLogin[LOGIN_MAX_LEN + 1];
-	trim_and_lower(c_pszLogin, szLogin, sizeof(szLogin));
-
-	TLoginDataByLogin::iterator it = m_map_pkLoginDataByLogin.find(szLogin);
-
-	if (it == m_map_pkLoginDataByLogin.end())
-		return NULL;
-
-	return it->second;
-}
-
-CLoginData* CClientManager::GetLoginDataByAID(DWORD dwAID)
-{
-	TLoginDataByAID::iterator it = m_map_pkLoginDataByAID.find(dwAID);
-
-	if (it == m_map_pkLoginDataByAID.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::InsertLoginData(CLoginData* pkLD)
-{
-	char szLogin[LOGIN_MAX_LEN + 1];
-	trim_and_lower(pkLD->GetAccountRef().login, szLogin, sizeof(szLogin));
-
-	m_map_pkLoginData.insert(std::make_pair(pkLD->GetKey(), pkLD));
-	m_map_pkLoginDataByLogin.insert(std::make_pair(szLogin, pkLD));
-	m_map_pkLoginDataByAID.insert(std::make_pair(pkLD->GetAccountRef().id, pkLD));
-}
-
-void CClientManager::DeleteLoginData(CLoginData* pkLD)
-{
-	m_map_pkLoginData.erase(pkLD->GetKey());
-	m_map_pkLoginDataByLogin.erase(pkLD->GetAccountRef().login);
-	m_map_pkLoginDataByAID.erase(pkLD->GetAccountRef().id);
-
-	if (m_map_kLogonAccount.find(pkLD->GetAccountRef().login) == m_map_kLogonAccount.end())
-		delete pkLD;
-	else
-		pkLD->SetDeleted(true);
-}
-
-void CClientManager::QUERY_AUTH_LOGIN(CPeer* pkPeer, DWORD dwHandle, TPacketGDAuthLogin* p)
-{
-	if (g_test_server)
-		sys_log(0, "QUERY_AUTH_LOGIN %d %d %s", p->dwID, p->dwLoginKey, p->szLogin);
-
-	CLoginData* pkLD = GetLoginDataByLogin(p->szLogin);
-
-	if (pkLD)
-	{
-		DeleteLoginData(pkLD);
-	}
-
-	BYTE bResult;
-
-	if (GetLoginData(p->dwLoginKey))
-	{
-		sys_err("LoginData already exist key %u login %s", p->dwLoginKey, p->szLogin);
-		bResult = 0;
-
-		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
-		pkPeer->EncodeBYTE(bResult);
-	}
-	else
-	{
-		CLoginData* pkLD = new CLoginData;
-
-		pkLD->SetKey(p->dwLoginKey);
-		pkLD->SetClientKey(p->adwClientKey);
-		pkLD->SetPremium(p->iPremiumTimes);
-
-		TAccountTable& r = pkLD->GetAccountRef();
-
-		r.id = p->dwID;
-		trim_and_lower(p->szLogin, r.login, sizeof(r.login));
-		strlcpy(r.social_id, p->szSocialID, sizeof(r.social_id));
-		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		strlcpy(r.country, p->szCountry, sizeof(r.country));
-#endif
-
-		sys_log(0, "AUTH_LOGIN id(%u) login(%s)"
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			" country(%s)"
-#endif
-			" social_id(%s) login_key(%u), client_key(%u %u %u %u)",
-			p->dwID,
-			p->szLogin,
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			p->szCountry,
-#endif
-			p->szSocialID,
-			p->dwLoginKey,
-			p->adwClientKey[0], p->adwClientKey[1], p->adwClientKey[2], p->adwClientKey[3]
-		);
-
-		bResult = 1;
-
-		InsertLoginData(pkLD);
-
-		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
-		pkPeer->EncodeBYTE(bResult);
-	}
-}
-
-void CClientManager::GuildDepositMoney(TPacketGDGuildMoney* p)
-{
-	CGuildManager::instance().DepositMoney(p->dwGuild, p->iGold);
-}
-
-void CClientManager::GuildWithdrawMoney(CPeer* peer, TPacketGDGuildMoney* p)
-{
-	CGuildManager::instance().WithdrawMoney(peer, p->dwGuild, p->iGold);
-}
-
-void CClientManager::GuildWithdrawMoneyGiveReply(TPacketGDGuildMoneyWithdrawGiveReply* p)
-{
-	CGuildManager::instance().WithdrawMoneyReply(p->dwGuild, p->bGiveSuccess, p->iChangeGold);
-}
-
-void CClientManager::GuildWarBet(TPacketGDGuildWarBet* p)
-{
-	CGuildManager::instance().Bet(p->dwWarID, p->szLogin, p->dwGold, p->dwGuild);
-}
-
-void CClientManager::CreateObject(TPacketGDCreateObject* p)
-{
-	using namespace building;
-
-	char szQuery[512];
-
-	snprintf(szQuery, sizeof(szQuery),
-		"INSERT INTO object%s (`land_id`, `vnum`, `map_index`, `x`, `y`, `x_rot`, `y_rot`, `z_rot`) VALUES(%u, %u, %d, %d, %d, %f, %f, %f)",
-		GetTablePostfix(), p->dwLandID, p->dwVnum, p->lMapIndex, p->x, p->y, p->xRot, p->yRot, p->zRot);
-
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-	if (pmsg->Get()->uiInsertID == 0)
-	{
-		sys_err("cannot insert object");
-		return;
-	}
-
-	TObject* pkObj = new TObject;
-
-	memset(pkObj, 0, sizeof(TObject));
-
-	pkObj->dwID = pmsg->Get()->uiInsertID;
-	pkObj->dwVnum = p->dwVnum;
-	pkObj->dwLandID = p->dwLandID;
-	pkObj->lMapIndex = p->lMapIndex;
-	pkObj->x = p->x;
-	pkObj->y = p->y;
-	pkObj->xRot = p->xRot;
-	pkObj->yRot = p->yRot;
-	pkObj->zRot = p->zRot;
-	pkObj->lLife = 0;
-
-	ForwardPacket(HEADER_DG_CREATE_OBJECT, pkObj, sizeof(TObject));
-
-	m_map_pkObjectTable.insert(std::make_pair(pkObj->dwID, pkObj));
-}
-
-void CClientManager::DeleteObject(DWORD dwID)
-{
-	char szQuery[128];
-
-	snprintf(szQuery, sizeof(szQuery), "DELETE FROM object%s WHERE `id` = %u", GetTablePostfix(), dwID);
-
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
-	{
-		sys_err("no object by id %u", dwID);
-		return;
-	}
-
-	//pkObjectTableMap::const_iterator it = m_map_pkObjectTable.find(dwID);
-	auto it = m_map_pkObjectTable.find(dwID);
-	if (it != m_map_pkObjectTable.end())
-	{
-		delete it->second;
-		m_map_pkObjectTable.erase(it);
-	}
-
-	ForwardPacket(HEADER_DG_DELETE_OBJECT, &dwID, sizeof(DWORD));
-}
-
-void CClientManager::UpdateLand(DWORD* pdw)
-{
-	DWORD dwID = pdw[0];
-	DWORD dwGuild = pdw[1];
-
-	building::TLand* p = &m_vec_kLandTable[0];
-
-	DWORD i;
-
-	for (i = 0; i < m_vec_kLandTable.size(); ++i, ++p)
-	{
-		if (p->dwID == dwID)
-		{
-			char buf[256];
-			snprintf(buf, sizeof(buf), "UPDATE land%s SET `guild_id` = %u WHERE `id` = %u", GetTablePostfix(), dwGuild, dwID);
-			CDBManager::instance().AsyncQuery(buf);
-
-			p->dwGuildID = dwGuild;
-			break;
-		}
-	}
-
-	if (i < m_vec_kLandTable.size())
-		ForwardPacket(HEADER_DG_UPDATE_LAND, p, sizeof(building::TLand));
-}
-
-// BLOCK_CHAT
-void CClientManager::BlockChat(TPacketBlockChat* p)
-{
-	char szQuery[256];
-
-	if (g_stLocale == "sjis")
-		snprintf(szQuery, sizeof(szQuery), "SELECT `id `FROM player%s WHERE `name` = '%s' COLLATE sjis_japanese_ci", GetTablePostfix(), p->szName);
-	else
-		snprintf(szQuery, sizeof(szQuery), "SELECT `id` FROM player%s WHERE `name` = '%s'", GetTablePostfix(), p->szName);
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-	SQLResult* pRes = pmsg->Get();
-
-	if (pRes->uiNumRows)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
-		DWORD pid = strtoul(row[0], NULL, 10);
-
-		TPacketGDAddAffect pa;
-		pa.dwPID = pid;
-		pa.elem.dwType = 223;
-		pa.elem.wApplyOn = 0;
-		pa.elem.lApplyValue = 0;
-		pa.elem.dwFlag = 0;
-		pa.elem.lDuration = p->lDuration;
-		pa.elem.lSPCost = 0;
-		QUERY_ADD_AFFECT(NULL, &pa);
-	}
-	else
-	{
-		// cannot find user with that name
-	}
-}
-// END_OF_BLOCK_CHAT
-
-void CClientManager::MarriageAdd(TPacketMarriageAdd* p)
-{
-	sys_log(0, "MarriageAdd %u %u %s %s", p->dwPID1, p->dwPID2, p->szName1, p->szName2);
-	marriage::CManager::instance().Add(p->dwPID1, p->dwPID2, p->szName1, p->szName2);
-}
-
-void CClientManager::MarriageUpdate(TPacketMarriageUpdate* p)
-{
-	sys_log(0, "MarriageUpdate PID:%u %u LP:%d ST:%d", p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
-	marriage::CManager::instance().Update(p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
-}
-
-void CClientManager::MarriageRemove(TPacketMarriageRemove* p)
-{
-	sys_log(0, "MarriageRemove %u %u", p->dwPID1, p->dwPID2);
-	marriage::CManager::instance().Remove(p->dwPID1, p->dwPID2);
-}
-
-void CClientManager::WeddingRequest(TPacketWeddingRequest* p)
-{
-	sys_log(0, "WeddingRequest %u %u", p->dwPID1, p->dwPID2);
-	ForwardPacket(HEADER_DG_WEDDING_REQUEST, p, sizeof(TPacketWeddingRequest));
-	//marriage::CManager::instance().RegisterWedding(p->dwPID1, p->szName1, p->dwPID2, p->szName2);
-}
-
-void CClientManager::WeddingReady(TPacketWeddingReady* p)
-{
-	sys_log(0, "WeddingReady %u %u", p->dwPID1, p->dwPID2);
-	ForwardPacket(HEADER_DG_WEDDING_READY, p, sizeof(TPacketWeddingReady));
-	marriage::CManager::instance().ReadyWedding(p->dwMapIndex, p->dwPID1, p->dwPID2);
-}
-
-void CClientManager::WeddingEnd(TPacketWeddingEnd* p)
-{
-	sys_log(0, "WeddingEnd %u %u", p->dwPID1, p->dwPID2);
-	marriage::CManager::instance().EndWedding(p->dwPID1, p->dwPID2);
-}
-
-//
-// 캐시에 가격정보가 있으면 캐시를 업데이트 하고 캐시에 가격정보가 없다면
-// 우선 기존의 데이터를 로드한 뒤에 기존의 정보로 캐시를 만들고 새로 받은 가격정보를 업데이트 한다.
-//
-void CClientManager::MyshopPricelistUpdate(const TItemPriceListTable* pPacket)
-{
-	if (pPacket->byCount > SHOP_PRICELIST_MAX_NUM)
-	{
-		sys_err("count overflow!");
-		return;
-	}
-
-	CItemPriceListTableCache* pCache = GetItemPriceListCache(pPacket->dwOwnerID);
-
-	if (pCache)
-	{
-		TItemPriceListTable table;
-
-		table.dwOwnerID = pPacket->dwOwnerID;
-		table.byCount = pPacket->byCount;
-
-		thecore_memcpy(table.aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
-
-		pCache->UpdateList(&table);
-	}
-	else
-	{
-		TItemPriceListTable* pUpdateTable = new TItemPriceListTable;
-
-		pUpdateTable->dwOwnerID = pPacket->dwOwnerID;
-		pUpdateTable->byCount = pPacket->byCount;
-
-		thecore_memcpy(pUpdateTable->aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `item_vnum`, `price`"
-#if defined(__CHEQUE_SYSTEM__)
-			", `cheque`"
-#endif
-			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), pPacket->dwOwnerID);
-		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD_FOR_UPDATE, 0, pUpdateTable);
-	}
-}
-
-// MYSHOP_PRICE_LIST
-// 캐시된 가격정보가 있으면 캐시를 읽어 바로 전송하고 캐시에 정보가 없으면 DB 에 쿼리를 한다.
-//
-void CClientManager::MyshopPricelistRequest(CPeer* peer, DWORD dwHandle, DWORD dwPlayerID)
-{
-	if (CItemPriceListTableCache* pCache = GetItemPriceListCache(dwPlayerID))
-	{
-		sys_log(0, "Cache MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
-
-		TItemPriceListTable* pTable = pCache->Get(false);
-
-		TPacketMyshopPricelistHeader header =
-		{
-			pTable->dwOwnerID,
-			pTable->byCount
-		};
-
-		size_t sizePriceListSize = sizeof(TItemPriceInfo) * pTable->byCount;
-
-		peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, dwHandle, sizeof(header) + sizePriceListSize);
-		peer->Encode(&header, sizeof(header));
-		peer->Encode(pTable->aPriceInfo, sizePriceListSize);
-	}
-	else
-	{
-		sys_log(0, "Query MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `item_vnum`, `price`"
-#if defined(__CHEQUE_SYSTEM__)
-			", `cheque`"
-#endif
-			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), dwPlayerID);
-		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD, peer->GetHandle(), new TItemPricelistReqInfo(dwHandle, dwPlayerID));
-	}
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-void CPacketInfo::Add(int header)
-{
-	auto it = m_map_info.find(header);
-	if (it == m_map_info.end())
-		m_map_info.insert(std::map<int, int>::value_type(header, 1));
-	else
-		++it->second;
-}
-
-void CPacketInfo::Reset()
-{
-	m_map_info.clear();
-}
-
-void CClientManager::ProcessPackets(CPeer* peer)
-{
-	BYTE header;
-	DWORD dwHandle;
-	DWORD dwLength;
-	const char* data = NULL;
-	int i = 0;
-	int iCount = 0;
-
-	while (peer->PeekPacket(i, header, dwHandle, dwLength, &data))
-	{
-		// DISABLE_DB_HEADER_LOG
-		// sys_log(0, "header %d %p size %d", header, this, dwLength);
-		// END_OF_DISABLE_DB_HEADER_LOG
-		m_bLastHeader = header;
-		++iCount;
-
-#if defined(_DEBUG)
-		if (header != 10)
-			sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
-#endif
-
-		if (g_test_server)
-		{
-			if (header != 10)
-				sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
-		}
-
-		// test log by mhh
-		{
-			if (HEADER_GD_BLOCK_COUNTRY_IP == header)
-				sys_log(0, "recved : HEADER_GD_BLOCK_COUNTRY_IP");
-		}
-
-		switch (header)
-		{
-			case HEADER_GD_BOOT:
-				QUERY_BOOT(peer, (TPacketGDBoot*)data);
-				break;
-
-			case HEADER_GD_HAMMER_OF_TOR:
-				break;
-
-			case HEADER_GD_LOGIN_BY_KEY:
-				QUERY_LOGIN_BY_KEY(peer, dwHandle, (TPacketGDLoginByKey*)data);
-				break;
-
-			case HEADER_GD_LOGOUT:
-				//sys_log(0, "HEADER_GD_LOGOUT (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_LOGOUT(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_PLAYER_LOAD:
-				sys_log(1, "HEADER_GD_PLAYER_LOAD (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_PLAYER_LOAD(peer, dwHandle, (TPlayerLoadPacket*)data);
-				break;
-
-			case HEADER_GD_PLAYER_SAVE:
-				sys_log(1, "HEADER_GD_PLAYER_SAVE (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_PLAYER_SAVE(peer, dwHandle, (TPlayerTable*)data);
-				break;
-
-			case HEADER_GD_PLAYER_CREATE:
-				sys_log(0, "HEADER_GD_PLAYER_CREATE (handle: %d length: %d)", dwHandle, dwLength);
-				__QUERY_PLAYER_CREATE(peer, dwHandle, (TPlayerCreatePacket*)data);
-				sys_log(0, "END");
-				break;
-
-			case HEADER_GD_PLAYER_DELETE:
-				sys_log(1, "HEADER_GD_PLAYER_DELETE (handle: %d length: %d)", dwHandle, dwLength);
-				__QUERY_PLAYER_DELETE(peer, dwHandle, (TPlayerDeletePacket*)data);
-				break;
-
-			case HEADER_GD_PLAYER_COUNT:
-				QUERY_PLAYER_COUNT(peer, (TPlayerCountPacket*)data);
-				break;
-
-			case HEADER_GD_QUEST_SAVE:
-				sys_log(1, "HEADER_GD_QUEST_SAVE (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_QUEST_SAVE(peer, (TQuestTable*)data, dwLength);
-				break;
-
-			case HEADER_GD_SAFEBOX_LOAD:
-				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 0);
-				break;
-
-			case HEADER_GD_SAFEBOX_SAVE:
-				sys_log(1, "HEADER_GD_SAFEBOX_SAVE (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_SAFEBOX_SAVE(peer, (TSafeboxTable*)data);
-				break;
-
-			case HEADER_GD_SAFEBOX_CHANGE_SIZE:
-				QUERY_SAFEBOX_CHANGE_SIZE(peer, dwHandle, (TSafeboxChangeSizePacket*)data);
-				break;
-
-			case HEADER_GD_SAFEBOX_CHANGE_PASSWORD:
-				QUERY_SAFEBOX_CHANGE_PASSWORD(peer, dwHandle, (TSafeboxChangePasswordPacket*)data);
-				break;
-
-			case HEADER_GD_MALL_LOAD:
-				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 1);
-				break;
-
-			case HEADER_GD_EMPIRE_SELECT:
-				QUERY_EMPIRE_SELECT(peer, dwHandle, (TEmpireSelectPacket*)data);
-				break;
-
-			case HEADER_GD_SETUP:
-				QUERY_SETUP(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_GUILD_CREATE:
-				GuildCreate(peer, *(DWORD*)data);
-				break;
-
-			case HEADER_GD_GUILD_SKILL_UPDATE:
-				GuildSkillUpdate(peer, (TPacketGuildSkillUpdate*)data);
-				break;
-
-			case HEADER_GD_GUILD_EXP_UPDATE:
-				GuildExpUpdate(peer, (TPacketGuildExpUpdate*)data);
-				break;
-
-			case HEADER_GD_GUILD_ADD_MEMBER:
-				GuildAddMember(peer, (TPacketGDGuildAddMember*)data);
-				break;
-
-			case HEADER_GD_GUILD_REMOVE_MEMBER:
-				GuildRemoveMember(peer, (TPacketGuild*)data);
-				break;
-
-			case HEADER_GD_GUILD_CHANGE_GRADE:
-				GuildChangeGrade(peer, (TPacketGuild*)data);
-				break;
-
-			case HEADER_GD_GUILD_CHANGE_MEMBER_DATA:
-				GuildChangeMemberData(peer, (TPacketGuildChangeMemberData*)data);
-				break;
-
-			case HEADER_GD_GUILD_DISBAND:
-				GuildDisband(peer, (TPacketGuild*)data);
-				break;
-
-			case HEADER_GD_GUILD_WAR:
-				GuildWar(peer, (TPacketGuildWar*)data);
-				break;
-
-			case HEADER_GD_GUILD_WAR_SCORE:
-				GuildWarScore(peer, (TPacketGuildWarScore*)data);
-				break;
-
-			case HEADER_GD_GUILD_CHANGE_LADDER_POINT:
-				GuildChangeLadderPoint((TPacketGuildLadderPoint*)data);
-				break;
-
-			case HEADER_GD_GUILD_USE_SKILL:
-				GuildUseSkill((TPacketGuildUseSkill*)data);
-				break;
-
-			case HEADER_GD_FLUSH_CACHE:
-				QUERY_FLUSH_CACHE(peer, data);
-				break;
-
-			case HEADER_GD_ITEM_SAVE:
-				QUERY_ITEM_SAVE(peer, data);
-				break;
-
-			case HEADER_GD_ITEM_DESTROY:
-				QUERY_ITEM_DESTROY(peer, data);
-				break;
-
-			case HEADER_GD_ITEM_FLUSH:
-				QUERY_ITEM_FLUSH(peer, data);
-				break;
-
-			case HEADER_GD_ADD_AFFECT:
-				sys_log(1, "HEADER_GD_ADD_AFFECT");
-				QUERY_ADD_AFFECT(peer, (TPacketGDAddAffect*)data);
-				break;
-
-			case HEADER_GD_REMOVE_AFFECT:
-				sys_log(1, "HEADER_GD_REMOVE_AFFECT");
-				QUERY_REMOVE_AFFECT(peer, (TPacketGDRemoveAffect*)data);
-				break;
-
-			case HEADER_GD_HIGHSCORE_REGISTER:
-				QUERY_HIGHSCORE_REGISTER(peer, (TPacketGDHighscore*)data);
-				break;
-
-			case HEADER_GD_PARTY_CREATE:
-				QUERY_PARTY_CREATE(peer, (TPacketPartyCreate*)data);
-				break;
-
-			case HEADER_GD_PARTY_DELETE:
-				QUERY_PARTY_DELETE(peer, (TPacketPartyDelete*)data);
-				break;
-
-			case HEADER_GD_PARTY_ADD:
-				QUERY_PARTY_ADD(peer, (TPacketPartyAdd*)data);
-				break;
-
-			case HEADER_GD_PARTY_REMOVE:
-				QUERY_PARTY_REMOVE(peer, (TPacketPartyRemove*)data);
-				break;
-
-			case HEADER_GD_PARTY_STATE_CHANGE:
-				QUERY_PARTY_STATE_CHANGE(peer, (TPacketPartyStateChange*)data);
-				break;
-
-			case HEADER_GD_PARTY_SET_MEMBER_LEVEL:
-				QUERY_PARTY_SET_MEMBER_LEVEL(peer, (TPacketPartySetMemberLevel*)data);
-				break;
-
-			case HEADER_GD_RELOAD_PROTO:
-				QUERY_RELOAD_PROTO();
-				break;
-
-			case HEADER_GD_CHANGE_NAME:
-				QUERY_CHANGE_NAME(peer, dwHandle, (TPacketGDChangeName*)data);
-				break;
-
-			case HEADER_GD_AUTH_LOGIN:
-				QUERY_AUTH_LOGIN(peer, dwHandle, (TPacketGDAuthLogin*)data);
-				break;
-
-			case HEADER_GD_REQUEST_GUILD_PRIV:
-				AddGuildPriv((TPacketGiveGuildPriv*)data);
-				break;
-
-			case HEADER_GD_REQUEST_EMPIRE_PRIV:
-				AddEmpirePriv((TPacketGiveEmpirePriv*)data);
-				break;
-
-			case HEADER_GD_REQUEST_CHARACTER_PRIV:
-				AddCharacterPriv((TPacketGiveCharacterPriv*)data);
-				break;
-
-			case HEADER_GD_MONEY_LOG:
-				MoneyLog((TPacketMoneyLog*)data);
-				break;
-
-			case HEADER_GD_GUILD_DEPOSIT_MONEY:
-				GuildDepositMoney((TPacketGDGuildMoney*)data);
-				break;
-
-			case HEADER_GD_GUILD_WITHDRAW_MONEY:
-				GuildWithdrawMoney(peer, (TPacketGDGuildMoney*)data);
-				break;
-
-			case HEADER_GD_GUILD_WITHDRAW_MONEY_GIVE_REPLY:
-				GuildWithdrawMoneyGiveReply((TPacketGDGuildMoneyWithdrawGiveReply*)data);
-				break;
-
-			case HEADER_GD_GUILD_WAR_BET:
-				GuildWarBet((TPacketGDGuildWarBet*)data);
-				break;
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-			case HEADER_GD_GUILD_EVENT_FLAG:
-				GuildSetEventFlag((TPacketSetGuildEventFlag*)data);
-				break;
-#endif
-
-			case HEADER_GD_SET_EVENT_FLAG:
-				SetEventFlag((TPacketSetEventFlag*)data);
-				break;
-
-			case HEADER_GD_CREATE_OBJECT:
-				CreateObject((TPacketGDCreateObject*)data);
-				break;
-
-			case HEADER_GD_DELETE_OBJECT:
-				DeleteObject(*(DWORD*)data);
-				break;
-
-			case HEADER_GD_UPDATE_LAND:
-				UpdateLand((DWORD*)data);
-				break;
-
-			case HEADER_GD_MARRIAGE_ADD:
-				MarriageAdd((TPacketMarriageAdd*)data);
-				break;
-
-			case HEADER_GD_MARRIAGE_UPDATE:
-				MarriageUpdate((TPacketMarriageUpdate*)data);
-				break;
-
-			case HEADER_GD_MARRIAGE_REMOVE:
-				MarriageRemove((TPacketMarriageRemove*)data);
-				break;
-
-			case HEADER_GD_WEDDING_REQUEST:
-				WeddingRequest((TPacketWeddingRequest*)data);
-				break;
-
-			case HEADER_GD_WEDDING_READY:
-				WeddingReady((TPacketWeddingReady*)data);
-				break;
-
-			case HEADER_GD_WEDDING_END:
-				WeddingEnd((TPacketWeddingEnd*)data);
-				break;
-
-				// BLOCK_CHAT
-			case HEADER_GD_BLOCK_CHAT:
-				BlockChat((TPacketBlockChat*)data);
-				break;
-				// END_OF_BLOCK_CHAT
-
-				// MYSHOP_PRICE_LIST
-			case HEADER_GD_MYSHOP_PRICELIST_UPDATE:
-				MyshopPricelistUpdate((TItemPriceListTable*)data);
-				break;
-
-			case HEADER_GD_MYSHOP_PRICELIST_REQ:
-				MyshopPricelistRequest(peer, dwHandle, *(DWORD*)data);
-				break;
-				// END_OF_MYSHOP_PRICE_LIST
-
-				// RELOAD_ADMIN
-			case HEADER_GD_RELOAD_ADMIN:
-				ReloadAdmin(peer, (TPacketReloadAdmin*)data);
-				break;
-				// END_RELOAD_ADMIN
-
-			case HEADER_GD_BREAK_MARRIAGE:
-				BreakMarriage(peer, data);
-				break;
-
-				// MOANRCH
-			case HEADER_GD_ELECT_MONARCH:
-				Election(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_CANDIDACY:
-				Candidacy(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_ADD_MONARCH_MONEY:
-				AddMonarchMoney(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_DEC_MONARCH_MONEY:
-				DecMonarchMoney(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_TAKE_MONARCH_MONEY:
-				TakeMonarchMoney(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_COME_TO_VOTE:
-				ComeToVote(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_RMCANDIDACY: ///< 후보 제거 (운영자)
-				RMCandidacy(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_SETMONARCH: ///< 군주설정 (운영자)
-				SetMonarch(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_RMMONARCH: ///< 군주삭제
-				RMMonarch(peer, dwHandle, data);
-				break;
-				// END_MONARCH
-
-			case HEADER_GD_CHANGE_MONARCH_LORD:
-				ChangeMonarchLord(peer, dwHandle, (TPacketChangeMonarchLord*)data);
-				break;
-
-			case HEADER_GD_BLOCK_COUNTRY_IP:
-				sys_log(0, "HEADER_GD_BLOCK_COUNTRY_IP received");
-				CBlockCountry::instance().SendBlockedCountryIp(peer);
-				CBlockCountry::instance().SendBlockException(peer);
-				break;
-
-			case HEADER_GD_BLOCK_EXCEPTION:
-				sys_log(0, "HEADER_GD_BLOCK_EXCEPTION received");
-				BlockException((TPacketBlockException*)data);
-				break;
-
-			case HEADER_GD_REQ_SPARE_ITEM_ID_RANGE:
-				SendSpareItemIDRange(peer);
-				break;
-
-			case HEADER_GD_REQ_CHANGE_GUILD_MASTER:
-				GuildChangeMaster((TPacketChangeGuildMaster*)data);
-				break;
-
-			case HEADER_GD_UPDATE_HORSE_NAME:
-				UpdateHorseName((TPacketUpdateHorseName*)data, peer);
-				break;
-
-			case HEADER_GD_REQ_HORSE_NAME:
-				AckHorseName(*(DWORD*)data, peer);
-				break;
-
-			case HEADER_GD_DC:
-				DeleteLoginKey((TPacketDC*)data);
-				break;
-
-			case HEADER_GD_VALID_LOGOUT:
-				ResetLastPlayerID((TPacketNeedLoginLogInfo*)data);
-				break;
-
-			case HEADER_GD_REQUEST_CHARGE_CASH:
-				ChargeCash((TRequestChargeCash*)data);
-				break;
-
-				// delete gift notify icon
-			case HEADER_GD_DELETE_AWARDID:
-				DeleteAwardId((TPacketDeleteAwardID*)data);
-				break;
-
-			case HEADER_GD_UPDATE_CHANNELSTATUS:
-				UpdateChannelStatus((SChannelStatus*)data);
-				break;
-
-			case HEADER_GD_REQUEST_CHANNELSTATUS:
-				RequestChannelStatus(peer, dwHandle);
-				break;
-
-#if defined(__MOVE_CHANNEL__)
-			case HEADER_GD_FIND_CHANNEL:
-				FindChannel(peer, dwHandle, (TPacketChangeChannel*)data);
-				break;
-#endif
-
-#if defined(__GEM_SHOP__)
-			case HEADER_GD_GEM_SHOP_LOAD:
-				LoadGemShop(peer, dwHandle, (TGemShopLoad*)data);
-				break;
-
-			case HEADER_GD_GEM_SHOP_UPDATE:
-				UpdateGemShop(peer, dwHandle, (TGemShopTable*)data);
-				break;
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-			case HEADER_GD_EMOTE_LOAD:
-				QUERY_EMOTE_LOAD(peer, dwHandle, (TPacketGDEmote*)data);
-				break;
-
-			case HEADER_GD_EMOTE_CLEAR:
-				QUERY_EMOTE_CLEAR(peer, dwHandle, (TPacketGDEmote*)data);
-				break;
-
-			case HEADER_GD_EMOTE_ADD:
-				QUERY_EMOTE_ADD(peer, dwHandle, (TPacketGDEmote*)data);
-				break;
-#endif
-
-#if defined(__MAILBOX__)
-			case HEADER_GD_MAILBOX_LOAD:
-				QUERY_MAILBOX_LOAD(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_CHECK_NAME:
-				QUERY_MAILBOX_CHECK_NAME(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_WRITE:
-				QUERY_MAILBOX_WRITE(peer, dwHandle, (TMailBoxTable*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_DELETE:
-				QUERY_MAILBOX_DELETE(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_CONFIRM:
-				QUERY_MAILBOX_CONFIRM(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_GET:
-				QUERY_MAILBOX_GET(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_UNREAD:
-				QUERY_MAILBOX_UNREAD(peer, dwHandle, (TMailBox*)data);
-				break;
-#endif
-
-#ifdef __SHOP_SEARCH__
-			case HEADER_GD_SHOP_SEARCH_REGISTER_ITEM:
-				CShopSearchManager::Instance().RecvRegisterItem(peer, *reinterpret_cast<const TShopSearchItem*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_UNREGISTER_ITEM:
-				CShopSearchManager::Instance().RecvUnregisterItem(*reinterpret_cast<const TShopSearchItem*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_SOLD_ITEM:
-				CShopSearchManager::Instance().RecvSoldItem(*reinterpret_cast<const TPacketGDShopSearchSoldItem*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BY_NAME:
-				CShopSearchManager::Instance().RecvSearchByName(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchByName*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BY_OPTIONS:
-			{
-				const TPacketGDShopSearchByOptions& packet = *reinterpret_cast<const TPacketGDShopSearchByOptions*>(data);
-				data += sizeof(TPacketGDShopSearchByOptions);
-				const TShopSearchItemType* itemTypeFlags = (const TShopSearchItemType*)data;
-				data += sizeof(TShopSearchItemType) * packet.options.typeFlagCount;
-				CShopSearchManager::Instance().RecvSearchByOptions(peer, dwHandle, packet, itemTypeFlags, (const DWORD*)data);
-			}
-			break;
-
-			case HEADER_GD_SHOP_SEARCH_REQUEST_BUY:
-				CShopSearchManager::Instance().RecvBuyItem(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchRequestBuy*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BUY_FROM_SHOP_ERROR:
-				CShopSearchManager::Instance().RecvBuyFromShopError(*reinterpret_cast<const TPacketDGShopSearchBuyFromShop*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BOUGHT_FROM_SHOP:
-				CShopSearchManager::Instance().RecvBoughtFromShop(dwHandle, *reinterpret_cast<const TPacketGDShopSearchBoughtFromShop*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_REQUEST_SOLD_INFO:
-				CShopSearchManager::Instance().RecvRequestSoldInfo(peer, dwHandle, *reinterpret_cast<const DWORD*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_RELOAD_AVERAGE:
-				CShopSearchManager::Instance().Initialize();
-				break;
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-			case HEADER_GD_GROWTH_PET_SAVE:
-				QUERY_GROWTH_PET_SAVE(peer, data);
-				break;
-
-			case HEADER_GD_GROWTH_PET_DELETE:
-				QUERY_GROWTH_PET_DELETE(peer, data);
-				break;
-#endif
-
-#ifdef __OFFLINE_SHOP__
-			case HEADER_GD_REQUEST_OFFLINE_SHOP_ID:
-				RequestOfflineShopId(peer, *reinterpret_cast<const uint32_t*>(data));
-				break;
-
-			case HEADER_GD_OFFLINE_SHOP_SAVE:
-				SaveOfflineShop(*reinterpret_cast<const TOfflineShop*>(data));
-				break;
-
-			case HEADER_GD_OFFLINE_SHOP_SAVE_ITEM:
-				SaveOfflineShopItem(*reinterpret_cast<const TOfflineShopItem*>(data));
-				break;
-
-			case HEADER_GD_OFFLINE_SHOP_DESTROY:
-				DestroyOfflineShop(*reinterpret_cast<const uint32_t*>(data));
-				break;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			case HEADER_GD_SAVE_EXT_BATTLE_PASS:
-				QUERY_SAVE_EXT_BATTLE_PASS(peer, dwHandle, (TPlayerExtBattlePassMission*)data);
-				break;
-#endif
-
-			default:
-				sys_err("Unknown header (header: %d handle: %d length: %d)", header, dwHandle, dwLength);
-				break;
-		}
-	}
-
-	peer->RecvEnd(i);
-}
-
-void CClientManager::AddPeer(socket_t fd)
-{
-	CPeer* pPeer = new CPeer;
-
-	if (pPeer->Accept(fd))
-		m_peerList.push_front(pPeer);
-	else
-		delete pPeer;
-}
-
-void CClientManager::RemovePeer(CPeer* pPeer)
-{
-	if (m_pkAuthPeer == pPeer)
-	{
-		m_pkAuthPeer = NULL;
-	}
-	else
-	{
-		TLogonAccountMap::iterator it = m_map_kLogonAccount.begin();
-
-		while (it != m_map_kLogonAccount.end())
-		{
-			CLoginData* pkLD = it->second;
-
-			if (pkLD->GetConnectedPeerHandle() == pPeer->GetHandle())
-			{
-				if (pkLD->IsPlay())
-					pkLD->SetPlay(false);
-
-				if (pkLD->IsDeleted())
-				{
-					sys_log(0, "DELETING LoginData");
-					delete pkLD;
-				}
-
-				m_map_kLogonAccount.erase(it++);
-			}
-			else
-				++it;
-		}
-	}
-
-	m_peerList.remove(pPeer);
-	delete pPeer;
-}
-
-CPeer* CClientManager::GetPeer(IDENT ident)
-{
-	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* tmp = *i;
-
-		if (tmp->GetHandle() == ident)
-			return tmp;
-	}
-
-	return NULL;
-}
-
-CPeer* CClientManager::GetAnyPeer()
-{
-	if (m_peerList.empty())
-		return NULL;
-
-	return m_peerList.front();
-}
-
-// DB 매니저로 부터 받은 결과를 처리한다.
-//
-// @version	05/06/10 Bang2ni - 가격정보 관련 쿼리(QID_ITEMPRICE_XXX) 추가
-int CClientManager::AnalyzeQueryResult(SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	CPeer* peer = GetPeer(qi->dwIdent);
-
-#if defined(_DEBUG)
-	if (qi->iType != QID_ITEM_AWARD_LOAD)
-		sys_log(0, "AnalyzeQueryResult %d", qi->iType);
-#endif
-
-	switch (qi->iType)
-	{
-		case QID_ITEM_AWARD_LOAD:
-			ItemAwardManager::instance().Load(msg);
-			delete qi;
-			return true;
-
-		case QID_GUILD_RANKING:
-			CGuildManager::instance().ResultRanking(msg->Get()->pSQLResult);
-			break;
-
-			// MYSHOP_PRICE_LIST
-		case QID_ITEMPRICE_LOAD_FOR_UPDATE:
-			RESULT_PRICELIST_LOAD_FOR_UPDATE(msg);
-			break;
-			// END_OF_MYSHOP_PRICE_LIST
-	}
-
-	if (!peer)
-	{
-		//sys_err("CClientManager::AnalyzeQueryResult: peer not exist anymore. (ident: %d)", qi->dwIdent);
-		delete qi;
-		return true;
-	}
-
-	switch (qi->iType)
-	{
-		case QID_PLAYER:
-		case QID_ITEM:
-		case QID_QUEST:
-		case QID_AFFECT:
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		case QID_EXT_BATTLE_PASS:
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-		case QID_GROWTH_PET:
-#endif
-			RESULT_COMPOSITE_PLAYER(peer, msg, qi->iType);
-			break;
-
-		case QID_LOGIN:
-			RESULT_LOGIN(peer, msg);
-			break;
-
-		case QID_SAFEBOX_LOAD:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_LOAD");
-			RESULT_SAFEBOX_LOAD(peer, msg);
-			break;
-
-		case QID_SAFEBOX_CHANGE_SIZE:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_SIZE");
-			RESULT_SAFEBOX_CHANGE_SIZE(peer, msg);
-			break;
-
-		case QID_SAFEBOX_CHANGE_PASSWORD:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
-			RESULT_SAFEBOX_CHANGE_PASSWORD(peer, msg);
-			break;
-
-		case QID_SAFEBOX_CHANGE_PASSWORD_SECOND:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
-			RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(peer, msg);
-			break;
-
-		case QID_HIGHSCORE_REGISTER:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_HIGHSCORE_REGISTER %p", msg);
-			RESULT_HIGHSCORE_REGISTER(peer, msg);
-			break;
-
-		case QID_SAFEBOX_SAVE:
-		case QID_ITEM_SAVE:
-		case QID_ITEM_DESTROY:
-		case QID_QUEST_SAVE:
-		case QID_PLAYER_SAVE:
-		case QID_ITEM_AWARD_TAKEN:
-#ifdef __GROWTH_PET_SYSTEM__
-		case QID_GROWTH_PET_SAVE:
-		case QID_GROWTH_PET_DELETE:
-#endif
-			break;
-
-			// PLAYER_INDEX_CREATE_BUG_FIX
-		case QID_PLAYER_INDEX_CREATE:
-			RESULT_PLAYER_INDEX_CREATE(peer, msg);
-			break;
-			// END_PLAYER_INDEX_CREATE_BUG_FIX
-
-		case QID_PLAYER_DELETE:
-			__RESULT_PLAYER_DELETE(peer, msg);
-			break;
-
-		case QID_LOGIN_BY_KEY:
-			RESULT_LOGIN_BY_KEY(peer, msg);
-			break;
-
-			// MYSHOP_PRICE_LIST
-		case QID_ITEMPRICE_LOAD:
-			RESULT_PRICELIST_LOAD(peer, msg);
-			break;
-			// END_OF_MYSHOP_PRICE_LIST
-
-		default:
-			sys_log(0, "CClientManager::AnalyzeQueryResult unknown query result type: %d, str: %s", qi->iType, msg->stQuery.c_str());
-			break;
-	}
-
-	delete qi;
-	return true;
-}
-
-void UsageLog()
-{
-	FILE* fp = NULL;
-
-	time_t ct;
-	char* time_s;
-	struct tm lt;
-
-	int avg = g_dwUsageAvg / 3600; // 60 초 * 60 분
-
-	fp = fopen("usage.txt", "a+");
-
-	if (!fp)
-		return;
-
-	ct = time(0);
-	lt = *localtime(&ct);
-	time_s = asctime(&lt);
-
-	time_s[strlen(time_s) - 1] = '\0';
-
-	fprintf(fp, "| %4d %-15.15s | %5d | %5u |", lt.tm_year + 1900, time_s + 4, avg, g_dwUsageMax);
-
-	fprintf(fp, "\n");
-	fclose(fp);
-
-	g_dwUsageMax = g_dwUsageAvg = 0;
-}
-
-int CClientManager::Process()
-{
-	int pulses;
-
-	if (!(pulses = thecore_idle()))
-		return 0;
-
-	while (pulses--)
-	{
-		++thecore_heart->pulse;
-
-		/*
-		// 30분마다 변경
-		if (((thecore_pulse() % (60 * 30 * 10)) == 0))
-		{
-			g_iPlayerCacheFlushSeconds = MAX(60, rand() % 180);
-			g_iItemCacheFlushSeconds = MAX(60, rand() % 180);
-			sys_log(0, "[SAVE_TIME]Change saving time item %d player %d", g_iPlayerCacheFlushSeconds, g_iItemCacheFlushSeconds);
-		}
-		*/
-
-		if (!(thecore_heart->pulse % thecore_heart->passes_per_sec))
-		{
-			if (g_test_server)
-			{
-				if (!(thecore_heart->pulse % thecore_heart->passes_per_sec * 10))
-
-				{
-					pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d/%d",
-						thecore_heart->pulse,
-						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-						CDBManager::instance().CountReturnResult(SQL_PLAYER),
-						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-						CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
-						CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
-
-					if ((thecore_heart->pulse % 50) == 0)
-						sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
-							thecore_heart->pulse,
-							CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-							CDBManager::instance().CountReturnResult(SQL_PLAYER),
-							CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-							CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-							CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-							CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
-				}
-			}
-			else
-			{
-				pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d%/%d",
-					thecore_heart->pulse,
-					CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-					CDBManager::instance().CountReturnResult(SQL_PLAYER),
-					CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-					CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
-					CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-					CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-					CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
-					CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
-
-				if ((thecore_heart->pulse % 50) == 0)
-					sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
-						thecore_heart->pulse,
-						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-						CDBManager::instance().CountReturnResult(SQL_PLAYER),
-						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
-			}
-
-			CDBManager::instance().ResetCounter();
-
-			DWORD dwCount = CClientManager::instance().GetUserCount();
-
-			g_dwUsageAvg += dwCount;
-			g_dwUsageMax = MAX(g_dwUsageMax, dwCount);
-
-			memset(&thecore_profiler[0], 0, sizeof(thecore_profiler));
-
-#if defined(__EXPRESSING_EMOTIONS__)
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iEmoteDumpDelay)))
-				CClientManager::instance().QUERY_EMOTE_DUMP();
-#endif
-
-#if defined(__MAILBOX__)
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iMailBoxBackupSec)))
-				CClientManager::instance().MAILBOX_BACKUP();
-#endif
-
-#if defined(__GEM_SHOP__)
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iGemShopFlushDelay)))
-				CClientManager::instance().FlushGemShop();
-#endif
-
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600)))
-				UsageLog();
-
-			m_iCacheFlushCount = 0;
-
-			// 플레이어 플러쉬
-			UpdatePlayerCache();
-			// 아이템 플러쉬
-			UpdateItemCache();
-			//로그아웃시 처리- 캐쉬셋 플러쉬
-			UpdateLogoutPlayer();
-
-			// MYSHOP_PRICE_LIST
-			UpdateItemPriceListCache();
-			// END_OF_MYSHOP_PRICE_LIST
-#ifdef __OFFLINE_SHOP__
-			UpdateOfflineShopCache();
-			UpdateOfflineShopItemCache();
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-			UpdateGrowthPetCache();
-#endif
-			CGuildManager::instance().Update();
-			CPrivManager::instance().Update();
-			marriage::CManager::instance().Update();
-#ifdef __SHOP_SEARCH__
-			CShopSearchManager::Instance().Update();
-#endif
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 5)))
-		{
-			ItemAwardManager::instance().RequestLoad();
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 10)))
-		{
-			/*
-			char buf[4096 + 1];
-			int len
-
-			/////////////////////////////////////////////////////////////////
-			buf[0] = '\0';
-			len = 0;
-
-			auto it = g_query_info.m_map_info.begin();
-
-			int count = 0;
-
-			while (it != g_query_info.m_map_info.end())
-			{
-				len += snprintf(buf + len, sizeof(buf) - len, "%2d %3d\n", it->first, it->second);
-				count += it->second;
-				it++;
-			}
-
-			pt_log("QUERY:\n%s-------------------- MAX : %d\n", buf, count);
-			g_query_info.Reset();
-			*/
-			pt_log("QUERY: MAIN[%d] ASYNC[%d]", g_query_count[0], g_query_count[1]);
-			g_query_count[0] = 0;
-			g_query_count[1] = 0;
-			/////////////////////////////////////////////////////////////////
-
-			/////////////////////////////////////////////////////////////////
-			/*
-			buf[0] = '\0';
-			len = 0;
-
-			it = g_item_info.m_map_info.begin();
-
-			count = 0;
-			while (it != g_item_info.m_map_info.end())
-			{
-				len += snprintf(buf + len, sizeof(buf) - len, "%5d %3d\n", it->first, it->second);
-				count += it->second;
-				it++;
-			}
-
-			pt_log("ITEM:\n%s-------------------- MAX : %d\n", buf, count);
-			g_item_info.Reset();
-			*/
-			pt_log("ITEM:%d\n", g_item_count);
-			g_item_count = 0;
-			/////////////////////////////////////////////////////////////////
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60))) // 60초에 한번
-		{
-			// 유니크 아이템을 위한 시간을 보낸다.
-			CClientManager::instance().SendTime();
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600))) // 한시간에 한번
-		{
-			CMoneyLog::instance().Save();
-		}
-
-#if defined(__ENVIRONMENT_SYSTEM__)
-		static bool OnSetup = true;
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60 * 20)) || OnSetup)
-		{
-			UpdateEnvironment();
-			OnSetup = false;
-		}
-#endif
-	}
-
-	int num_events = fdwatch(m_fdWatcher, 0);
-	int idx;
-	CPeer* peer;
-
-	for (idx = 0; idx < num_events; ++idx) // 인풋
-	{
-		peer = (CPeer*)fdwatch_get_client_data(m_fdWatcher, idx);
-
-		if (!peer)
-		{
-			if (fdwatch_check_event(m_fdWatcher, m_fdAccept, idx) == FDW_READ)
-			{
-				AddPeer(m_fdAccept);
-				fdwatch_clear_event(m_fdWatcher, m_fdAccept, idx);
-			}
-			else
-			{
-				sys_log(0, "FDWATCH: peer null in event: ident %d", fdwatch_get_ident(m_fdWatcher, idx));
-			}
-
-			continue;
-		}
-
-		switch (fdwatch_check_event(m_fdWatcher, peer->GetFd(), idx))
-		{
-			case FDW_READ:
-				if (peer->Recv() < 0)
-				{
-					sys_err("Recv failed");
-					RemovePeer(peer);
-				}
-				else
-				{
-					if (peer == m_pkAuthPeer)
-						if (g_log)
-							sys_log(0, "AUTH_PEER_READ: size %d", peer->GetRecvLength());
-
-					ProcessPackets(peer);
-				}
-				break;
-
-			case FDW_WRITE:
-				if (peer == m_pkAuthPeer)
-					if (g_log)
-						sys_log(0, "AUTH_PEER_WRITE: size %d", peer->GetSendLength());
-
-				if (peer->Send() < 0)
-				{
-					sys_err("Send failed");
-					RemovePeer(peer);
-				}
-
-				break;
-
-			case FDW_EOF:
-				RemovePeer(peer);
-				break;
-
-			default:
-				sys_err("fdwatch_check_fd returned unknown result");
-				RemovePeer(peer);
-				break;
-		}
-	}
-
-#ifdef __WIN32__
-	if (_kbhit())
-	{
-		int c = _getch();
-		switch (c)
-		{
-			case 0x1b: // Esc
-				return 0; // shutdown
-				break;
-			default:
-				break;
-		}
-	}
-#endif
-
-	return 1;
-}
-
-DWORD CClientManager::GetUserCount()
-{
-	// 단순히 로그인 카운트를 센다.. --;
-	return m_map_kLogonAccount.size();
-}
-
-void CClientManager::SendAllGuildSkillRechargePacket()
-{
-	ForwardPacket(HEADER_DG_GUILD_SKILL_RECHARGE, NULL, 0);
-}
-
-void CClientManager::SendTime()
-{
-	time_t now = GetCurrentTime();
-	ForwardPacket(HEADER_DG_TIME, &now, sizeof(time_t));
-}
-
-void CClientManager::ForwardPacket(BYTE header, const void* data, int size, BYTE bChannel, CPeer* except)
-{
-	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* peer = *it;
-
-		if (peer == except)
-			continue;
-
-		if (!peer->GetChannel())
-			continue;
-
-		if (bChannel && peer->GetChannel() != bChannel)
-			continue;
-
-		peer->EncodeHeader(header, 0, size);
-
-		if (size > 0 && data)
-			peer->Encode(data, size);
-	}
-}
-
-void CClientManager::SendNotice(const char* c_pszFormat, ...)
-{
-	char szBuf[255 + 1];
-	va_list args;
-
-	va_start(args, c_pszFormat);
-	int len = vsnprintf(szBuf, sizeof(szBuf), c_pszFormat, args);
-	va_end(args);
-	szBuf[len] = '\0';
-
-	ForwardPacket(HEADER_DG_NOTICE, szBuf, len + 1);
-}
-
-time_t CClientManager::GetCurrentTime()
-{
-	return time(0);
-}
-
-// ITEM_UNIQUE_ID
-bool CClientManager::InitializeNowItemID()
-{
-	DWORD dwMin, dwMax;
-
-	// 아이템 ID를 초기화 한다.
-	if (!CConfig::instance().GetTwoValue("ITEM_ID_RANGE", &dwMin, &dwMax))
-	{
-		sys_err("config.txt: Cannot find ITEM_ID_RANGE [start_item_id] [end_item_id]");
-		return false;
-	}
-
-	sys_log(0, "ItemRange From File %u ~ %u ", dwMin, dwMax);
-
-	if (CItemIDRangeManager::instance().BuildRange(dwMin, dwMax, m_itemRange) == false)
-	{
-		sys_err("Can not build ITEM_ID_RANGE");
-		return false;
-	}
-
-	sys_log(0, " Init Success Start %u End %u Now %u\n", m_itemRange.dwMin, m_itemRange.dwMax, m_itemRange.dwUsableItemIDMin);
-
-	return true;
-}
-
-DWORD CClientManager::GainItemID()
-{
-	return m_itemRange.dwUsableItemIDMin++;
-}
-
-DWORD CClientManager::GetItemID()
-{
-	return m_itemRange.dwUsableItemIDMin;
-}
-// ITEM_UNIQUE_ID_END
-
-// BOOT_LOCALIZATION
-bool CClientManager::InitializeLocalization()
-{
-	char szQuery[512];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `mValue`, `mKey` FROM `locale`");
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
-
-	if (pMsg->Get()->uiNumRows == 0)
-	{
-		sys_err("InitializeLocalization() ==> DirectQuery failed(%s)", szQuery);
-		delete pMsg;
-		return false;
-	}
-
-	sys_log(0, "InitializeLocalization() - LoadLocaleTable(count:%d)", pMsg->Get()->uiNumRows);
-
-	m_vec_Locale.clear();
-
-	MYSQL_ROW row = NULL;
-
-	for (; (row = mysql_fetch_row(pMsg->Get()->pSQLResult)) != NULL;)
-	{
-		int col = 0;
-		tLocale locale;
-
-		strlcpy(locale.szValue, row[col++], sizeof(locale.szValue));
-		strlcpy(locale.szKey, row[col++], sizeof(locale.szKey));
-
-		// DB_NAME_COLUMN Setting
-		if (strcmp(locale.szKey, "LOCALE") == 0)
-		{
-			if (strcmp(locale.szValue, "cibn") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
-
-				g_stLocale = "gb2312";
-				g_stLocaleNameColumn = "gb2312name";
-			}
-			else if (strcmp(locale.szValue, "ymir") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "euckr";
-				g_stLocaleNameColumn = "name";
-			}
-			else if (strcmp(locale.szValue, "japan") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "sjis");
-
-				g_stLocale = "sjis";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "english") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "germany") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "france") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "italy") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "spain") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "uk") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "turkey") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin5";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "poland") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "portugal") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "hongkong") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
-
-				g_stLocale = "big5";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "newcibn") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
-
-				g_stLocale = "gb2312";
-				g_stLocaleNameColumn = "gb2312name";
-			}
-			else if (strcmp(locale.szValue, "korea") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "euckr";
-				g_stLocaleNameColumn = "name";
-			}
-			else if (strcmp(locale.szValue, "canada") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "gb2312name";
-			}
-			else if (strcmp(locale.szValue, "brazil") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "greek") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "greek";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "russia") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "cp1251";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "denmark") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "bulgaria") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "cp1251";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "croatia") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "cp1251";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "mexico") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "arabia") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "cp1256";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "czech") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "hungary") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "romania") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "netherlands") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "singapore") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "vietnam") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "thailand") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "usa") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "we_korea") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "euckr";
-				g_stLocaleNameColumn = "name";
-			}
-			else if (strcmp(locale.szValue, "taiwan") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
-				g_stLocale = "big5";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "europe") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else
-			{
-				sys_err("locale[LOCALE] = UNKNOWN(%s)", locale.szValue);
-				exit(0);
-			}
-
-			CDBManager::instance().SetLocale(g_stLocale.c_str());
-		}
-		else if (strcmp(locale.szKey, "DB_NAME_COLUMN") == 0)
-		{
-			sys_log(0, "locale[DB_NAME_COLUMN] = %s", locale.szValue);
-			g_stLocaleNameColumn = locale.szValue;
-		}
-		else
-		{
-			sys_log(0, "locale[UNKNOWN_KEY(%s)] = %s", locale.szKey, locale.szValue);
-		}
-		m_vec_Locale.push_back(locale);
-	}
-
-	delete pMsg;
-
-	return true;
-}
-// END_BOOT_LOCALIZATION
-
-// ADMIN_MANAGER
-bool CClientManager::__GetAdminInfo(const char* szIP, std::vector<tAdminInfo>& rAdminVec)
-{
-	// szIP == NULL 일경우 모든서버에 운영자 권한을 갖는다.
-	char szQuery[512];
-	snprintf(szQuery, sizeof(szQuery),
-		"SELECT `mID`, `mAccount`, `mName`, `mContactIP`, `mServerIP`, `mAuthority` FROM `gmlist` WHERE `mServerIP` = 'ALL' OR `mServerIP` = '%s'",
-		szIP ? szIP : "ALL");
-
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
-
-	if (pMsg->Get()->uiNumRows == 0)
-	{
-		sys_err("__GetAdminInfo() ==> DirectQuery failed(%s)", szQuery);
-		delete pMsg;
-		return false;
-	}
-
-	MYSQL_ROW row;
-	rAdminVec.reserve(pMsg->Get()->uiNumRows);
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		int idx = 0;
-		tAdminInfo Info;
-
-		str_to_number(Info.m_ID, row[idx++]);
-		trim_and_lower(row[idx++], Info.m_szAccount, sizeof(Info.m_szAccount));
-		strlcpy(Info.m_szName, row[idx++], sizeof(Info.m_szName));
-		strlcpy(Info.m_szContactIP, row[idx++], sizeof(Info.m_szContactIP));
-		strlcpy(Info.m_szServerIP, row[idx++], sizeof(Info.m_szServerIP));
-		std::string stAuth = row[idx++];
-
-		if (!stAuth.compare("IMPLEMENTOR"))
-			Info.m_Authority = GM_IMPLEMENTOR;
-		else if (!stAuth.compare("GOD"))
-			Info.m_Authority = GM_GOD;
-		else if (!stAuth.compare("HIGH_WIZARD"))
-			Info.m_Authority = GM_HIGH_WIZARD;
-		else if (!stAuth.compare("LOW_WIZARD"))
-			Info.m_Authority = GM_LOW_WIZARD;
-		else if (!stAuth.compare("WIZARD"))
-			Info.m_Authority = GM_WIZARD;
-		else
-			continue;
-
-		rAdminVec.push_back(Info);
-
-		sys_log(0, "GM: PID %u Login %s Character %s ContactIP %s ServerIP %s Authority %d[%s]",
-			Info.m_ID, Info.m_szAccount, Info.m_szName, Info.m_szContactIP, Info.m_szServerIP, Info.m_Authority, stAuth.c_str());
-	}
-
-	delete pMsg;
-
-	return true;
-}
-
-bool CClientManager::__GetHostInfo(std::vector<std::string>& rIPVec)
-{
-	char szQuery[512];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `mIP` FROM `gmhost`");
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
-
-	if (pMsg->Get()->uiNumRows == 0)
-	{
-		sys_err("__GetHostInfo() ==> DirectQuery failed(%s)", szQuery);
-		delete pMsg;
-		return false;
-	}
-
-	rIPVec.reserve(pMsg->Get()->uiNumRows);
-
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		if (row[0] && *row[0])
-		{
-			rIPVec.push_back(row[0]);
-			sys_log(0, "GMHOST: %s", row[0]);
-		}
-	}
-
-	delete pMsg;
-	return true;
-}
-// END_ADMIN_MANAGER
-
-void CClientManager::ReloadAdmin(CPeer*, TPacketReloadAdmin* p)
-{
-	std::vector<tAdminInfo> vAdmin;
-	std::vector<std::string> vHost;
-
-	__GetHostInfo(vHost);
-	__GetAdminInfo(p->szIP, vAdmin);
-
-	DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
-		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size();
-
-	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* peer = *it;
-
-		if (!peer->GetChannel())
-			continue;
-
-		peer->EncodeHeader(HEADER_DG_RELOAD_ADMIN, 0, dwPacketSize);
-
-		peer->EncodeWORD(16);
-		peer->EncodeWORD(static_cast<WORD>(vHost.size()));
-
-		for (size_t n = 0; n < vHost.size(); ++n)
-			peer->Encode(vHost[n].c_str(), 16);
-
-		peer->EncodeWORD(sizeof(tAdminInfo));
-		peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
-
-		for (size_t n = 0; n < vAdmin.size(); ++n)
-			peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
-	}
-
-	sys_log(0, "ReloadAdmin End %s", p->szIP);
-}
-
-// BREAK_MARRIAGE
-void CClientManager::BreakMarriage(CPeer* peer, const char* data)
-{
-	DWORD pid1, pid2;
-
-	pid1 = *(int*)data;
-	data += sizeof(int);
-
-	pid2 = *(int*)data;
-	data += sizeof(int);
-
-	sys_log(0, "Breaking off a marriage engagement! pid %d and pid %d", pid1, pid2);
-	marriage::CManager::instance().Remove(pid1, pid2);
-}
-// END_BREAK_MARIIAGE
-
-void CClientManager::UpdateItemCacheSet(DWORD pid)
-{
-	auto it = m_map_pkItemCacheSetPtr.find(pid);
-	if (it == m_map_pkItemCacheSetPtr.end())
-	{
-		if (g_test_server)
-			sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCacheSet ==> No ItemCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TItemCacheSet* pSet = it->second;
-	TItemCacheSet::iterator it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CItemCache* c = *it_set++;
-		c->Flush();
-	}
-
-	if (g_log)
-		sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCachsSet pid(%d)", pid);
-}
-
-void CClientManager::Election(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	DWORD idx;
-	DWORD selectingpid;
-
-	idx = *(DWORD*)data;
-	data += sizeof(DWORD);
-
-	selectingpid = *(DWORD*)data;
-	data += sizeof(DWORD);
-
-	int Success = 0;
-
-	if (!(Success = CMonarch::instance().VoteMonarch(selectingpid, idx)))
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_VOTE] Failed %d %d", idx, selectingpid);
-		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
-		peer->Encode(&Success, sizeof(int));
-		return;
-	}
-	else
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_VOTE] Success %d %d", idx, selectingpid);
-		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
-		peer->Encode(&Success, sizeof(int));
-		return;
-	}
-
-}
-
-void CClientManager::Candidacy(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	DWORD pid;
-
-	pid = *(DWORD*)data;
-	data += sizeof(DWORD);
-
-	if (!CMonarch::instance().AddCandidacy(pid, data))
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_CANDIDACY] Failed %d %s", pid, data);
-
-		peer->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
-		peer->Encode(0, sizeof(int));
-		peer->Encode(data, 32);
-		return;
-	}
-	else
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_CANDIDACY] Success %d %s", pid, data);
-
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (0 && p->GetChannel() != 0)
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
-				p->Encode(&pid, sizeof(int));
-				p->Encode(data, 32);
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_CANDIDACY, 0, sizeof(int) + 32);
-				p->Encode(&pid, sizeof(int));
-				p->Encode(data, 32);
-			}
-		}
-	}
-}
-
-void CClientManager::AddMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH] Add money Empire(%d) Money(%d)", Empire, Money);
-
-	CMonarch::instance().AddMoney(Empire, Money);
-
-	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* p = *it;
-
-		if (!p->GetChannel())
-			continue;
-
-		if (p == peer)
-		{
-			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-		else
-		{
-			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-
-	}
-}
-
-void CClientManager::DecMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH] Dec money Empire(%d) Money(%d)", Empire, Money);
-
-	CMonarch::instance().DecMoney(Empire, Money);
-
-	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* p = *it;
-
-		if (!p->GetChannel())
-			continue;
-
-		if (p == peer)
-		{
-			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-		else
-		{
-			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-	}
-}
-
-void CClientManager::TakeMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	DWORD pid = *(DWORD*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH] Take money Empire(%d) Money(%d)", Empire, Money);
-
-	if (CMonarch::instance().TakeMoney(Empire, pid, Money) == true)
-	{
-		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-		peer->Encode(&Empire, sizeof(int));
-		peer->Encode(&Money, sizeof(int));
-	}
-	else
-	{
-		Money = 0;
-		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-		peer->Encode(&Empire, sizeof(int));
-		peer->Encode(&Money, sizeof(int));
-	}
-}
-
-void CClientManager::ComeToVote(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	CMonarch::instance().ElectMonarch();
-}
-
-void CClientManager::RMCandidacy(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	char szName[32];
-
-	strlcpy(szName, data, sizeof(szName));
-	sys_log(0, "[MONARCH_GM] Remove candidacy name(%s)", szName);
-
-	int iRet = CMonarch::instance().DelCandidacy(szName) ? 1 : 0;
-
-	if (1 == iRet)
-	{
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-		}
-	}
-	else
-	{
-		CPeer* p = peer;
-		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-		p->Encode(&iRet, sizeof(int));
-		p->Encode(szName, sizeof(szName));
-	}
-}
-
-void CClientManager::SetMonarch(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	char szName[32];
-
-	strlcpy(szName, data, sizeof(szName));
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH_GM] Set Monarch name(%s)", szName);
-
-	int iRet = CMonarch::instance().SetMonarch(szName) ? 1 : 0;
-
-	if (1 == iRet)
-	{
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-		}
-	}
-	else
-	{
-		CPeer* p = peer;
-		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-		p->Encode(&iRet, sizeof(int));
-		p->Encode(szName, sizeof(szName));
-	}
-}
-
-void CClientManager::RMMonarch(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	char szName[32];
-
-	strlcpy(szName, data, sizeof(szName));
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH_GM] Remove Monarch name(%s)", szName);
-
-	CMonarch::instance().DelMonarch(szName);
-
-	int iRet = CMonarch::instance().DelMonarch(szName) ? 1 : 0;
-
-	if (1 == iRet)
-	{
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-		}
-	}
-	else
-	{
-		CPeer* p = peer;
-		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-		p->Encode(&iRet, sizeof(int));
-		p->Encode(szName, sizeof(szName));
-	}
-}
-
-void CClientManager::ChangeMonarchLord(CPeer* peer, DWORD dwHandle, TPacketChangeMonarchLord* info)
-{
-	char szQuery[1024];
-	snprintf(szQuery, sizeof(szQuery),
-		"SELECT a.`name`, NOW() FROM player%s AS a, player_index%s AS b WHERE (a.`account_id` = b.`id` AND a.`id` = %u AND b.`empire` = %u) AND "
-		"(b.`pid1` = %u OR "
-		"b.`pid2` = %u OR "
-		"b.`pid3` = %u OR "
-		"b.`pid4` = %u"
-#if defined(__PLAYER_PER_ACCOUNT5__)
-		" OR b.`pid5` = %u"
-#endif
-		")",
-		GetTablePostfix(),
-		GetTablePostfix(),
-		info->dwPID,
-		info->bEmpire,
-		info->dwPID,
-		info->dwPID,
-		info->dwPID,
-		info->dwPID
-#if defined(__PLAYER_PER_ACCOUNT5__)
-		, info->dwPID
-#endif
-	);
-
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
-
-	if (pMsg->Get()->uiNumRows != 0)
-	{
-		TPacketChangeMonarchLordACK ack;
-		ack.bEmpire = info->bEmpire;
-		ack.dwPID = info->dwPID;
-
-		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-		strlcpy(ack.szName, row[0], sizeof(ack.szName));
-		strlcpy(ack.szDate, row[1], sizeof(ack.szDate));
-
-		snprintf(szQuery, sizeof(szQuery), "UPDATE `monarch` SET `pid` = %u, `windate` = NOW() WHERE `empire` = %d", ack.dwPID, ack.bEmpire);
-		SQLMsg* pMsg2 = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
-
-		if (pMsg2->Get()->uiAffectedRows > 0)
-		{
-			CMonarch::instance().LoadMonarch();
-
-			TMonarchInfo* newInfo = CMonarch::instance().GetMonarch();
-
-			for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-			{
-				CPeer* client = *it;
-
-				client->EncodeHeader(HEADER_DG_CHANGE_MONARCH_LORD_ACK, 0, sizeof(TPacketChangeMonarchLordACK));
-				client->Encode(&ack, sizeof(TPacketChangeMonarchLordACK));
-
-				client->EncodeHeader(HEADER_DG_UPDATE_MONARCH_INFO, 0, sizeof(TMonarchInfo));
-				client->Encode(newInfo, sizeof(TMonarchInfo));
-			}
-		}
-
-		delete pMsg2;
-	}
-
-	delete pMsg;
-}
-
-void CClientManager::BlockException(TPacketBlockException* data)
-{
-	sys_log(0, "[BLOCK_EXCEPTION] CMD(%d) login(%s)", data->cmd, data->login);
-
-	// save sql
-	{
-		char buf[1024];
-
-		switch (data->cmd)
-		{
-			case BLOCK_EXCEPTION_CMD_ADD:
-				snprintf(buf, sizeof(buf), "INSERT INTO `block_exception` VALUES('%s')", data->login);
-				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
-				CBlockCountry::instance().AddBlockException(data->login);
-				break;
-			case BLOCK_EXCEPTION_CMD_DEL:
-				snprintf(buf, sizeof(buf), "DELETE FROM `block_exception` WHERE `login` = %s", data->login);
-				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
-				CBlockCountry::instance().DelBlockException(data->login);
-				break;
-			default:
-				return;
-		}
-
-	}
-
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* peer = *it;
-
-		if (!peer->GetChannel())
-			continue;
-
-		CBlockCountry::instance().SendBlockExceptionOne(peer, data->login, data->cmd);
-	}
-}
-
-void CClientManager::SendSpareItemIDRange(CPeer* peer)
-{
-	peer->SendSpareItemIDRange();
-}
-
-//
-// Login Key만 맵에서 지운다.
-//
-void CClientManager::DeleteLoginKey(TPacketDC* data)
-{
-	char login[LOGIN_MAX_LEN + 1] = { 0 };
-	trim_and_lower(data->login, login, sizeof(login));
-
-	CLoginData* pkLD = GetLoginDataByLogin(login);
-
-	if (pkLD)
-	{
-		TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(pkLD->GetKey());
-
-		if (it != m_map_pkLoginData.end())
-			m_map_pkLoginData.erase(it);
-	}
-}
-
-// delete gift notify icon
-void CClientManager::DeleteAwardId(TPacketDeleteAwardID* data)
-{
-	// sys_log(0, "data from game server arrived %d", data->dwID);
-	std::map<DWORD, TItemAward*>::iterator it;
-	it = ItemAwardManager::Instance().GetMapAward().find(data->dwID);
-	if (it != ItemAwardManager::Instance().GetMapAward().end())
-	{
-		std::set<TItemAward*>& kSet = ItemAwardManager::Instance().GetMapkSetAwardByLogin()[it->second->szLogin];
-		if (kSet.erase(it->second))
-			sys_log(0, "erase ItemAward id: %d from cache", data->dwID);
-		ItemAwardManager::Instance().GetMapAward().erase(data->dwID);
-	}
-	else
-	{
-		sys_log(0, "DELETE_AWARDID : could not find the id: %d", data->dwID);
-	}
-}
-
-void CClientManager::UpdateChannelStatus(TChannelStatus* pData)
-{
-	TChannelStatusMap::iterator it = m_mChannelStatus.find(pData->nPort);
-	if (it != m_mChannelStatus.end())
-	{
-		it->second = pData->bStatus;
-	}
-	else
-	{
-		m_mChannelStatus.insert(TChannelStatusMap::value_type(pData->nPort, pData->bStatus));
-	}
-}
-
-void CClientManager::RequestChannelStatus(CPeer* peer, DWORD dwHandle)
-{
-	const int nSize = m_mChannelStatus.size();
-	peer->EncodeHeader(HEADER_DG_RESPOND_CHANNELSTATUS, dwHandle, sizeof(TChannelStatus) * nSize + sizeof(int));
-	peer->Encode(&nSize, sizeof(int));
-	for (TChannelStatusMap::iterator it = m_mChannelStatus.begin(); it != m_mChannelStatus.end(); ++it)
-	{
-		peer->Encode(&it->first, sizeof(short));
-		peer->Encode(&it->second, sizeof(BYTE));
-	}
-}
-
-void CClientManager::ResetLastPlayerID(const TPacketNeedLoginLogInfo* data)
-{
-	CLoginData* pkLD = GetLoginDataByAID(data->dwPlayerID);
-
-	if (NULL != pkLD)
-	{
-		pkLD->SetLastPlayerID(0);
-	}
-}
-
-void CClientManager::ChargeCash(const TRequestChargeCash* packet)
-{
-	char szQuery[512];
-
-	if (ERequestCharge_Cash == packet->eChargeType)
-		sprintf(szQuery, "update account set `cash` = `cash` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
-	else if (ERequestCharge_Mileage == packet->eChargeType)
-		sprintf(szQuery, "update account set `mileage` = `mileage` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
-	else
-	{
-		sys_err("Invalid request charge type (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
-		return;
-	}
-
-	sys_err("Request Charge (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
-
-	CDBManager::Instance().AsyncQuery(szQuery, SQL_ACCOUNT);
-}
-
-#if defined(__MOVE_CHANNEL__)
-void CClientManager::FindChannel(CPeer* requestPeer, DWORD dwHandle, TPacketChangeChannel* p)
-{
-	if (!p->lMapIndex || !p->iChannel)
-		return;
-
-	long lAddr = 0;
-	WORD wPort = 0;
-
-	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* peer = *i;
-		if (peer->GetChannel() != p->iChannel) // not the channel we are looking for!
-			continue;
-
-		TMapLocation kMapLocation;
-		thecore_memcpy(kMapLocation.alMaps, peer->GetMaps(), sizeof(kMapLocation.alMaps));
-		int iLen = sizeof(kMapLocation.alMaps) / sizeof(kMapLocation.alMaps[0]);
-
-		for (int i = 0; i < iLen; ++i)
-		{
-			if (kMapLocation.alMaps[i] == p->lMapIndex)
-			{
-				// Get host, and convert to int
-				char host[16];
-				strlcpy(host, peer->GetPublicIP(), sizeof(kMapLocation.szHost));
-				lAddr = inet_addr(host);
-
-				// Target port
-				wPort = peer->GetListenPort();
-
-				break;
-			}
-		}
-
-		if (lAddr && wPort) // We already obtained them
-			break;
-	}
-
-	TPacketReturnChannel r;
-	r.lAddr = lAddr;
-	r.wPort = wPort;
-
-	requestPeer->EncodeHeader(HEADER_DG_CHANNEL_RESULT, dwHandle, sizeof(r));
-	requestPeer->Encode(&r, sizeof(r));
-}
-#endif
-
-#if defined(__ENVIRONMENT_SYSTEM__)
-enum DayMode : BYTE { DAY, NIGHT };
-
-static BYTE GetDayMode(int Hour)
-{
-	if (Hour >= 6 && Hour <= 20)
-		return DayMode::DAY;
-	return DayMode::NIGHT;
-}
-
-static bool IsWinter(int Month)
-{
-	return (Month >= 11 || Month <= 0);
-}
-
-void CClientManager::UpdateEnvironment()
-{
-	time_t CurrentTime = time(nullptr);
-	tm* tm = localtime(&CurrentTime);
-
-	auto SendFlag = [&](const char* flag, BYTE val)
-		{
-			TEventFlagMap::const_iterator it = m_map_lEventFlag.find(flag);
-			if ((it != m_map_lEventFlag.end() && it->second == val) == false)
-			{
-				TPacketSetEventFlag p;
-				std::strcpy(p.szFlagName, flag);
-				p.lValue = val;
-				SetEventFlag(&p);
-			}
-		};
-
-	SendFlag("eclipse", GetDayMode(tm->tm_hour));
-	BOOL Winter = IsWinter(tm->tm_mon);
-	for (const auto& Flag : { "xmas_snow" })
-		SendFlag(Flag, Winter);
-}
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-void CClientManager::QUERY_EMOTE_LOAD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
-{
-	if (pTable == nullptr)
-		return;
-
-	TEmoteTableVector* pVec = nullptr;
-	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
-	if (it != m_map_kPlayerEmote.end())
-		pVec = &it->second;
-
-	if (pVec && !pVec->empty())
-	{
-		const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
-		pVec->erase(std::remove_if(pVec->begin(), pVec->end(),
-			[dwCurrentTime](const TPacketGDEmote& rkTable)
-			{
-				return dwCurrentTime > rkTable.dwDuration;
-			}
-		), pVec->end());
-	}
-
-	const WORD wSize = pVec ? static_cast<WORD>(pVec->size()) : 0;
-	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(TPacketGDEmote) * wSize;
-
-	pkPeer->EncodeHeader(HEADER_DG_EMOTE_LOAD, dwHandle, dwPacketSize);
-	pkPeer->EncodeWORD(sizeof(TPacketGDEmote));
-	pkPeer->EncodeWORD(wSize);
-	if (pVec && !pVec->empty())
-		pkPeer->Encode(&(*pVec)[0], sizeof(TPacketGDEmote) * wSize);
-}
-
-void CClientManager::QUERY_EMOTE_CLEAR(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
-{
-	if (pTable == nullptr)
-		return;
-
-	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
-	if (it != m_map_kPlayerEmote.end())
-		it->second.clear();
-
-	QUERY_EMOTE_LOAD(pkPeer, dwHandle, pTable);
-}
-
-void CClientManager::QUERY_EMOTE_ADD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
-{
-	if (!pkPeer || !pTable)
-		return;
-
-	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
-
-	TPacketGDEmote GDPacket;
-	GDPacket.dwPID = pTable->dwPID;
-	GDPacket.dwVnum = pTable->dwVnum;
-	GDPacket.dwDuration = dwCurrentTime + pTable->dwDuration;
-
-	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
-	if (it != m_map_kPlayerEmote.end())
-	{
-		TEmoteTableVector& rkVec = it->second;
-		if (rkVec.size() >= SPECIAL_ACTION_SLOT_COUNT)
-		{
-			TPacketGDEmote& rkTable = rkVec[number(0, rkVec.size() - 1)];
-			if (dwCurrentTime >= rkTable.dwDuration)
-				rkTable.dwDuration = dwCurrentTime + pTable->dwDuration;
-			else
-				rkTable.dwDuration += pTable->dwDuration;
-
-			GDPacket.dwVnum = rkTable.dwVnum;
-			GDPacket.dwDuration = rkTable.dwDuration;
-		}
-		else
-		{
-			TEmoteTableVector::iterator itVec = std::find_if(rkVec.begin(), rkVec.end(),
-				[pTable](const TPacketGDEmote& rkTable)
-				{
-					return rkTable.dwVnum == pTable->dwVnum;
-				});
-
-			if (itVec != rkVec.end())
-			{
-				if (dwCurrentTime >= itVec->dwDuration)
-					itVec->dwDuration = dwCurrentTime + pTable->dwDuration;
-				else
-					itVec->dwDuration += pTable->dwDuration;
-
-				GDPacket.dwDuration = itVec->dwDuration;
-			}
-			else
-			{
-				pTable->dwDuration = GDPacket.dwDuration;
-				rkVec.emplace_back(*pTable);
-			}
-		}
-	}
-	else
-	{
-		pTable->dwDuration = GDPacket.dwDuration;
-		m_map_kPlayerEmote[pTable->dwPID].emplace_back(*pTable);
-	}
-
-	pkPeer->EncodeHeader(HEADER_DG_EMOTE_GET, dwHandle, sizeof(GDPacket));
-	pkPeer->Encode(&GDPacket, sizeof(GDPacket));
-}
-
-void CClientManager::QUERY_EMOTE_DUMP()
-{
-	CDBManager::instance().DirectQuery("TRUNCATE TABLE `player`.`emotions`");
-
-	if (m_map_kPlayerEmote.empty())
-		return;
-
-	char szQuery[1024];
-	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
-
-	for (TPlayerEmoteMap::value_type& it : m_map_kPlayerEmote)
-	{
-		TEmoteTableVector& rkVec = it.second;
-		if (rkVec.empty())
-			continue;
-
-		rkVec.erase(std::remove_if(rkVec.begin(), rkVec.end(),
-			[dwCurrentTime](const TPacketGDEmote& rkTable)
-			{
-				return dwCurrentTime > rkTable.dwDuration;
-			}
-		), rkVec.end());
-
-		for (const TPacketGDEmote& rkTable : rkVec)
-		{
-			snprintf(szQuery, sizeof(szQuery),
-				"REPLACE INTO emotions%s (`pid`, `vnum`, `duration`) VALUES(%d, %d, FROM_UNIXTIME(%d))",
-				GetTablePostfix(), rkTable.dwPID, rkTable.dwVnum, rkTable.dwDuration
-			);
-
-			std::unique_ptr<SQLMsg> pkInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-}
-#endif
-
-#if defined(__MAILBOX__)
-void CClientManager::QUERY_MAILBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	if (g_log)
-		sys_log(0, "QUERY_MAILBOX (handle: %d ch: %s)", dwHandle, p->szName);
-
-	std::vector<SMailBoxTable>* vec = nullptr;
-	auto it = m_map_mailbox.find(p->szName);
-	if (it != m_map_mailbox.end())
-		vec = &it->second;
-
-	if (vec)
-	{
-		const time_t now = std::time(nullptr);
-
-		vec->erase(std::remove_if(vec->begin(), vec->end(),
-			[now](const TMailBoxTable& mail)
-			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
-		), vec->end());
-
-		std::sort(vec->begin(), vec->end(),
-			[](const TMailBoxTable& l, const TMailBoxTable& r)
-			{
-				return l.Message.SendTime > r.Message.SendTime;
-			});
-	}
-
-	const WORD size = vec ? static_cast<WORD>(vec->size()) : 0;
-	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(SMailBoxTable) * size;
-
-	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_LOAD, dwHandle, dwPacketSize);
-	pkPeer->EncodeWORD(sizeof(SMailBoxTable));
-	pkPeer->EncodeWORD(size);
-
-	if (vec && vec->empty() == false)
-		pkPeer->Encode(&(*vec)[0], sizeof(SMailBoxTable) * size);
-}
-
-void CClientManager::QUERY_MAILBOX_CHECK_NAME(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	TMailBox t;
-	std::memcpy(t.szName, "", sizeof(t.szName));
-	t.Index = 0; // Index: Mail Count
-
-	static std::unordered_set<std::string> NameSet;
-	bool bFound = NameSet.find(p->szName) != NameSet.end();
-
-	if (bFound == false)
-	{
-		char s_szQuery[128];
-		//snprintf(s_szQuery, sizeof(s_szQuery), "SELECT * FROM player%s WHERE `name` = '%s' LIMIT 1", GetTablePostfix(), p->szName);
-		snprintf(s_szQuery, sizeof(s_szQuery), "SELECT * FROM player%s WHERE `name` = convert('%s' using utf8mb4) collate utf8mb4_bin LIMIT 1", GetTablePostfix(), p->szName);
-		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(s_szQuery));
-		bFound = pMsg->Get()->uiNumRows > 0;
-	}
-
-	if (bFound)
-	{
-		NameSet.emplace(p->szName); // player exists, next time we will use this to avoid using mysql.
-		std::memcpy(t.szName, p->szName, sizeof(t.szName));
-		auto it = m_map_mailbox.find(p->szName);
-		if (it != m_map_mailbox.end())
-		{
-			const time_t now = time(nullptr);
-			for (const SMailBoxTable& mail : it->second)
-			{
-				if (mail.bIsDeleted)
-					continue;
-
-				if (std::difftime(mail.Message.DeleteTime, now) <= 0)
-					continue;
-
-				t.Index++;
-			}
-		}
-	}
-
-	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_CHECK_NAME, dwHandle, sizeof(TMailBox));
-	pkPeer->Encode(&t, sizeof(TMailBox));
-}
-
-void CClientManager::QUERY_MAILBOX_WRITE(CPeer* pkPeer, DWORD dwHandle, TMailBoxTable* p)
-{
-	m_map_mailbox[p->szName].emplace_back(*p);
-}
-
-bool CClientManager::GET_MAIL(const char* name, const BYTE index, SMailBoxTable** mail)
-{
-	auto it = m_map_mailbox.find(name);
-	if (it == m_map_mailbox.end())
-		return false;
-
-	MailVec& mailvec = it->second;
-	if (index >= mailvec.size())
-		return false;
-
-	*mail = &mailvec.at(index);
-	return true;
-}
-
-void CClientManager::QUERY_MAILBOX_DELETE(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	SMailBoxTable* mail = nullptr;
-	if (GET_MAIL(p->szName, p->Index, &mail) == false)
-		return;
-
-	mail->bIsDeleted = true;
-}
-
-void CClientManager::QUERY_MAILBOX_CONFIRM(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	SMailBoxTable* mail = nullptr;
-	if (GET_MAIL(p->szName, p->Index, &mail) == false)
-		return;
-
-	mail->Message.bIsConfirm = true;
-}
-
-void CClientManager::QUERY_MAILBOX_GET(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	SMailBoxTable* mail = nullptr;
-	if (GET_MAIL(p->szName, p->Index, &mail) == false)
-		return;
-
-	mail->AddData.iYang = 0;
-	mail->AddData.iWon = 0;
-	mail->Message.bIsItemExist = false;
-	mail->Message.bIsConfirm = true;
-	mail->AddData.dwItemVnum = 0;
-	mail->AddData.dwItemCount = 0;
-	memset(mail->AddData.alSockets, 0, sizeof(mail->AddData.alSockets));
-	memset(mail->AddData.aAttr, 0, sizeof(mail->AddData.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	mail->AddData.dwChangeLookVnum = 0;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	memset(&mail->AddData.RefineElement, 0, sizeof(mail->AddData.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	memset(mail->AddData.aApplyRandom, 0, sizeof(mail->AddData.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-	mail->AddData.bSetValue = 0;
-#endif
-}
-
-void CClientManager::QUERY_MAILBOX_UNREAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	auto it = m_map_mailbox.find(p->szName);
-	if (it == m_map_mailbox.end())
-		return;
-
-	const MailVec& mailvec = it->second;
-	if (mailvec.empty())
-		return;
-
-	const time_t now = time(nullptr);
-	TMailBoxRespondUnreadData t;
-
-	for (const SMailBoxTable& mail : it->second)
-	{
-		if (mail.bIsDeleted)
-			continue;
-
-		if (mail.Message.bIsConfirm)
-			continue;
-
-		if (std::difftime(mail.Message.DeleteTime, now) <= 0)
-			continue;
-
-		if (mail.Message.bIsGMPost)
-			t.bGMVisible = true;
-
-		if (mail.Message.bIsItemExist)
-			t.bItemMessageCount++;
-		else
-			t.bCommonMessageCount++;
-	}
-
-	if ((t.bItemMessageCount + t.bCommonMessageCount) < 1)
-		return;
-
-	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_UNREAD, dwHandle, sizeof(TMailBoxRespondUnreadData));
-	pkPeer->Encode(&t, sizeof(TMailBoxRespondUnreadData));
-}
-
-void CClientManager::MAILBOX_BACKUP()
-{
-	CDBManager::instance().DirectQuery("TRUNCATE TABLE player.mailbox");
-
-	if (m_map_mailbox.empty())
-		return;
-
-	char szQuery[QUERY_MAX_LEN];
-	const time_t now = std::time(nullptr);
-
-	for (auto& p : m_map_mailbox)
-	{
-		auto& mailvec = p.second;
-		if (mailvec.empty())
-			continue;
-
-		mailvec.erase(std::remove_if(mailvec.begin(), mailvec.end(),
-			[now](const TMailBoxTable& mail)
-			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
-		), mailvec.end());
-
-		std::sort(mailvec.begin(), mailvec.end(),
-			[](const TMailBoxTable& l, const TMailBoxTable& r)
-			{
-				return l.Message.SendTime > r.Message.SendTime;
-			});
-
-		for (const auto& mail : mailvec)
-		{
-			snprintf(szQuery, sizeof(szQuery),
-				"INSERT INTO `mailbox%s` (`name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`"
-				", `gold`, `won`, `vnum`, `count`"
-				", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-				", `socket3`, `socket4`, `socket5`"
-#endif
-				", `attrtype0`, `attrvalue0`"
-				", `attrtype1`, `attrvalue1`"
-				", `attrtype2`, `attrvalue2`"
-				", `attrtype3`, `attrvalue3`"
-				", `attrtype4`, `attrvalue4`"
-				", `attrtype5`, `attrvalue5`"
-				", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				", `changelookvnum`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				", `refine_element_apply_type`"
-				", `refine_element_grade`"
-				", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-				", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-				", `apply_type0`, `apply_value0`, `apply_path0`"
-				", `apply_type1`, `apply_value1`, `apply_path1`"
-				", `apply_type2`, `apply_value2`, `apply_path2`"
-				", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-				", `set_value`"
-#endif
-				") VALUES ('%s', '%s', '%s', '%s', %d, %d, %d, %d" // `name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`
-				", %u, %u, %u, %u" // `gold`, `won`, `vnum`, `count`
-				", %ld, %ld, %ld" // `socket0`, `socket1`, `socket2`
-#if defined(__ITEM_SOCKET6__)
-				", %ld, %ld, %ld" // `socket3`, `socket4`, `socket5`
-#endif
-				", %u, %ld" // `attrtype0`, `attrvalue0`
-				", %u, %ld" // `attrtype1`, `attrvalue1`
-				", %u, %ld" // `attrtype2`, `attrvalue2`
-				", %u, %ld" // `attrtype3`, `attrvalue3`
-				", %u, %ld" // `attrtype4`, `attrvalue4`
-				", %u, %ld" // `attrtype5`, `attrvalue5`
-				", %u, %ld" // `attrtype6`, `attrvalue6`
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				", %u" // `changelookvnum`
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				", %u" // `refine_element_apply_type`
-				", %u" // `refine_element_grade`
-				", %u, %u, %u" // `refine_element_value0`, `refine_element_value1`, `refine_element_value2`
-				", %u, %u, %u" // `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-				", %u, %ld, %d" // `apply_type0`, `apply_value0`, `apply_path0`
-				", %u, %ld, %d" // `apply_type1`, `apply_value1`, `apply_path1`
-				", %u, %ld, %d" // `apply_type2`, `apply_value2`, `apply_path2`
-				", %u, %ld, %d" // `apply_type3`, `apply_value3`, `apply_path3`
-#endif
-#if defined(__SET_ITEM__)
-				", %d" // `set_value`
-#endif
-				")", GetTablePostfix()
-				, mail.szName
-				, mail.AddData.szFrom
-				, mail.Message.szTitle
-				, mail.AddData.szMessage
-				, mail.Message.bIsGMPost
-				, mail.Message.bIsConfirm
-				, mail.Message.SendTime
-				, mail.Message.DeleteTime
-				, mail.AddData.iYang
-				, mail.AddData.iWon
-				, mail.AddData.dwItemVnum
-				, mail.AddData.dwItemCount
-				, mail.AddData.alSockets[0], mail.AddData.alSockets[1], mail.AddData.alSockets[2]
-#if defined(__ITEM_SOCKET6__)
-				, mail.AddData.alSockets[3], mail.AddData.alSockets[4], mail.AddData.alSockets[5]
-#endif
-				, mail.AddData.aAttr[0].wType, mail.AddData.aAttr[0].lValue
-				, mail.AddData.aAttr[1].wType, mail.AddData.aAttr[1].lValue
-				, mail.AddData.aAttr[2].wType, mail.AddData.aAttr[2].lValue
-				, mail.AddData.aAttr[3].wType, mail.AddData.aAttr[3].lValue
-				, mail.AddData.aAttr[4].wType, mail.AddData.aAttr[4].lValue
-				, mail.AddData.aAttr[5].wType, mail.AddData.aAttr[5].lValue
-				, mail.AddData.aAttr[6].wType, mail.AddData.aAttr[6].lValue
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				, mail.AddData.dwChangeLookVnum
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				, mail.AddData.RefineElement.wApplyType
-				, mail.AddData.RefineElement.bGrade
-				, mail.AddData.RefineElement.abValue[0], mail.AddData.RefineElement.abValue[1], mail.AddData.RefineElement.abValue[2]
-				, mail.AddData.RefineElement.abBonusValue[0], mail.AddData.RefineElement.abBonusValue[1], mail.AddData.RefineElement.abBonusValue[2]
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-				, mail.AddData.aApplyRandom[0].wType, mail.AddData.aApplyRandom[0].lValue, mail.AddData.aApplyRandom[0].bPath
-				, mail.AddData.aApplyRandom[1].wType, mail.AddData.aApplyRandom[1].lValue, mail.AddData.aApplyRandom[1].bPath
-				, mail.AddData.aApplyRandom[2].wType, mail.AddData.aApplyRandom[2].lValue, mail.AddData.aApplyRandom[2].bPath
-				, mail.AddData.aApplyRandom[3].wType, mail.AddData.aApplyRandom[3].lValue, mail.AddData.aApplyRandom[3].bPath
-#endif
-#if defined(__SET_ITEM__)
-				, mail.AddData.bSetValue
-#endif
-			);
-
-			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-}
-#endif
-
-#if defined(__GEM_SHOP__)
-void CClientManager::LoadGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopLoad* pTable, bool bUpdate)
-{
-	if (g_log)
-		sys_log(0, "LoadGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
-
-	TGemShopTable GemShopTable = {};
-#	if defined(__CONQUEROR_LEVEL__)
-	GemShopTable.bSpecial = pTable->bSpecial;
-	if (GemShopTable.bSpecial)
-	{
-		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
-		if (it != m_mapGemShopSpecialTable.end())
-			GemShopTable = it->second;
-	}
-	else
-#	endif
-	{
-		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
-		if (it != m_mapGemShopTable.end())
-			GemShopTable = it->second;
-	}
-
-	pPeer->EncodeHeader(bUpdate ? HEADER_DG_GEM_SHOP_UPDATE : HEADER_DG_GEM_SHOP_LOAD, dwHandle, sizeof(GemShopTable));
-	pPeer->Encode(&GemShopTable, sizeof(GemShopTable));
-}
-
-void CClientManager::UpdateGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopTable* pTable)
-{
-	if (g_log)
-		sys_log(0, "UpdateGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
-
-#	if defined(__CONQUEROR_LEVEL__)
-	if (pTable->bSpecial)
-	{
-		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
-		if (it != m_mapGemShopSpecialTable.end())
-			it->second = *pTable;
-		else
-			m_mapGemShopSpecialTable.emplace(std::make_pair(pTable->dwPID, *pTable));
-	}
-	else
-#	endif
-	{
-		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
-		if (it != m_mapGemShopTable.end())
-			it->second = *pTable;
-		else
-			m_mapGemShopTable.emplace(std::make_pair(pTable->dwPID, *pTable));
-	}
-
-	// NOTE : Request Gem Shop Load
-	TGemShopLoad Packet;
-	Packet.dwPID = pTable->dwPID;
-#	if defined(__CONQUEROR_LEVEL__)
-	Packet.bSpecial = pTable->bSpecial;
-#	endif
-	LoadGemShop(pPeer, dwHandle, &Packet, true);
-}
-
-void CClientManager::FlushGemShop()
-{
-	// Flush Default Gem Shop Table
-	{
-		if (m_mapGemShopTable.empty())
-			return;
-
-		char szQuery[1024] = {};
-		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop%s`", GetTablePostfix());
-		CDBManager::instance().DirectQuery(szQuery);
-
-		GemShopTableMap::iterator it = m_mapGemShopTable.begin();
-		for (; it != m_mapGemShopTable.end(); ++it)
-		{
-			TGemShopTable GemShopTable = it->second;
-			if (it->first != GemShopTable.dwPID)
-				continue;
-
-			char szColumns[1024] = {};
-			char szValues[1024] = {};
-
-			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
-			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
-
-			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
-			{
-				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
-					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
-				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
-					GemShopTable.GemShopItem[bSlotIndex].bEnable,
-					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
-					GemShopTable.GemShopItem[bSlotIndex].bCount,
-					GemShopTable.GemShopItem[bSlotIndex].dwPrice
-				);
-			}
-
-			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop%s` (%s) VALUES(%s)",
-				GetTablePostfix(), szColumns, szValues);
-
-			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-
-#	if defined(__CONQUEROR_LEVEL__)
-	// Flush Port (Special) Gem Shop Table
-	{
-		if (m_mapGemShopSpecialTable.empty())
-			return;
-
-		char szQuery[1024] = {};
-		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop_port%s`", GetTablePostfix());
-		CDBManager::instance().DirectQuery(szQuery);
-
-		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.begin();
-		for (; it != m_mapGemShopSpecialTable.end(); ++it)
-		{
-			TGemShopTable GemShopTable = it->second;
-			if (it->first != GemShopTable.dwPID)
-				continue;
-
-			char szColumns[1024] = {};
-			char szValues[1024] = {};
-
-			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
-			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
-
-			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
-			{
-				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
-					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
-				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
-					GemShopTable.GemShopItem[bSlotIndex].bEnable,
-					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
-					GemShopTable.GemShopItem[bSlotIndex].bCount,
-					GemShopTable.GemShopItem[bSlotIndex].dwPrice
-				);
-			}
-
-			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop_port%s` (%s) VALUES(%s)",
-				GetTablePostfix(), szColumns, szValues);
-
-			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-#	endif
-}
-#endif
-
-#ifdef __OFFLINE_SHOP__
-void CClientManager::InitializeNextOfflineShopId()
-{
-	std::stringstream query;
-	query << "SELECT MAX(id) + 1 FROM offline_shop" << GetTablePostfix();
-
-	std::unique_ptr<SQLMsg> msg(CDBManager::Instance().DirectQuery(query.str().c_str()));
-	if (msg && msg->Get()->uiNumRows > 0) {
-		auto row = mysql_fetch_row(msg->Get()->pSQLResult);
-		str_to_number(nextOfflineShopId_, row[0]);
-	}
-	else {
-		nextOfflineShopId_ = 1;
-	}
-
-	sys_log(0, "Next offline shop id: %u", nextOfflineShopId_);
-}
-
-void CClientManager::RequestOfflineShopId(CPeer* peer, uint32_t queueId)
-{
-	peer->EncodeHeader(HEADER_DG_RESPOND_OFFLINE_SHOP_ID, 0, sizeof(uint32_t) + sizeof(uint32_t));
-	peer->Encode(&queueId, sizeof(uint32_t));
-	peer->Encode(&nextOfflineShopId_, sizeof(uint32_t));
-
-	nextOfflineShopId_++;
-}
-
-void CClientManager::SaveOfflineShop(const TOfflineShop& data, bool skipQuery)
-{
-	auto it = offlineShopCache_.find(data.id);
-	if (it != offlineShopCache_.end()) {
-		it->second->Put(&data);
-	}
-	else {
-		auto cache = std::unique_ptr<COfflineShopCache>(new COfflineShopCache());
-		cache->Put(&data, skipQuery);
-
-		offlineShopCache_.insert(std::make_pair(data.id, std::move(cache)));
-	}
-}
-
-void CClientManager::SaveOfflineShopItem(const TOfflineShopItem& data, bool skipQuery)
-{
-	auto it = offlineShopItemCache_.find(data.id);
-	if (it != offlineShopItemCache_.end()) {
-		it->second->Put(&data);
-	}
-	else {
-		auto cache = std::unique_ptr<COfflineShopItemCache>(new COfflineShopItemCache());
-		cache->Put(&data, skipQuery);
-
-		offlineShopItemCache_.insert(std::make_pair(data.id, std::move(cache)));
-	}
-}
-
-void CClientManager::DestroyOfflineShop(uint32_t id)
-{
-	auto it = offlineShopCache_.find(id);
-	if (it != offlineShopCache_.end()) {
-		offlineShopCache_.erase(it);
-	}
-
-	std::pair<uint32_t, uint16_t> key = { id, 0 };
-	for (uint16_t i = 0; i < OFFLINE_SHOP_ITEM_COUNT; ++i) {
-		key.second = i;
-
-		auto it = offlineShopItemCache_.find(key);
-		if (it != offlineShopItemCache_.end()) {
-			offlineShopItemCache_.erase(it);
-		}
-	}
-
-	std::stringstream queryDeleteOfflineShop;
-	queryDeleteOfflineShop << "DELETE FROM offline_shop" << GetTablePostfix() << " WHERE id = " << id;
-	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShop.str().c_str());
-
-	std::stringstream queryDeleteOfflineShopItems;
-	queryDeleteOfflineShopItems << "DELETE FROM offline_shop_item" << GetTablePostfix() << " WHERE owner_pid = " << id;
-	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShopItems.str().c_str());
-}
-
-void CClientManager::UpdateOfflineShopCache()
-{
-	auto it = offlineShopCache_.begin();
-	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopCache_.end()) {
-		if (it->second->CheckFlushTimeout()) {
-			it->second->Flush();
-
-			m_iCacheFlushCount++;
-		}
-
-		it++;
-	}
-}
-
-void CClientManager::UpdateOfflineShopItemCache()
-{
-	auto it = offlineShopItemCache_.begin();
-	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopItemCache_.end()) {
-		if (it->second->CheckFlushTimeout()) {
-			it->second->Flush();
-
-			m_iCacheFlushCount++;
-		}
-
-		it++;
-	}
-}
-
-void CClientManager::FlushOfflineShops()
-{
-	for (auto it = offlineShopCache_.begin(); it != offlineShopCache_.end(); ++it) {
-		it->second->Flush();
-	}
-
-	for (auto it = offlineShopItemCache_.begin(); it != offlineShopItemCache_.end(); ++it) {
-		it->second->Flush();
-	}
-}
-
-const TItemTable* CClientManager::GetItemTable(DWORD vnum) const
-{
-	auto it = m_map_itemTableByVnum.find(vnum);
-	if (it == m_map_itemTableByVnum.end())
-	{
-		return NULL;
-	}
-
-	return it->second;
-}
-
-BYTE CClientManager::GetRealItemType(DWORD vnum)
-{
-	if (vnum >= 110000 && vnum <= 165499)
-		return ITEM_DS;
-	
-	
-	/* SHIT :
-	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
-	{
-		if (it->second->dwVnum == vnum)
-		{
-			return it->second->bType;
-		}
-	}
-	*/
-	
-	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
-	{
-		if (it->dwVnum == vnum)
-		{
-			return it->bType;
-		}
-	}
-	
-	return ITEM_NONE;
-}
-
-BYTE CClientManager::GetRealItemSubType(DWORD vnum)
-{
-	/* SHIT:
-	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
-	{
-		if (it->second->dwVnum == vnum)
-		{
-			return it->second->bSubType;
-		}
-	}
-	*/
-	
-	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
-	{
-		if (it->dwVnum == vnum)
-		{
-			return it->bSubType;
-		}
-	}
-	
-	return 0;
-}
-
-void CClientManager::GetRealItemLimit(DWORD vnum, int & limitType, DWORD & limitValue)
-{
-	/* BUGGED SHIT :
-	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
-	{
-		if (it->second->dwVnum == vnum)
-		{
-			limitType = it->second->aLimits[0].bType;
-			limitValue = it->second->aLimits[0].lValue;
-			return;
-		}
-	}
-	*/
-	
-	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
-	{
-		if (it->dwVnum == vnum)
-		{
-			limitType = it->aLimits[0].bType;
-			limitValue = it->aLimits[0].lValue;
-			return;
-		}
-	}
-}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-CClientManager::TGrowthPetCacheSet* CClientManager::GetGrowthPetCacheSet(DWORD pid)
-{
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
-
-	if (it == m_map_pkGrowthPetCacheSetPtr.end())
-		return nullptr;
-
-	return it->second;
-}
-
-void CClientManager::CreateGrowthPetCacheSet(DWORD pid)
-{
-	if (m_map_pkGrowthPetCacheSetPtr.find(pid) != m_map_pkGrowthPetCacheSetPtr.end())
-		return;
-				 
-	TGrowthPetCacheSet* pSet = new TGrowthPetCacheSet;
-	m_map_pkGrowthPetCacheSetPtr.insert(TGrowthPetCacheSetPtrMap::value_type(pid, pSet));
-
-	if (g_log)
-		sys_log(0, "GROWTH_PET_CACHE: new cache %u", pid);
-}
-
-void CClientManager::FlushGrowthPetCacheSet(DWORD pid)
-{
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
-
-	if (it == m_map_pkGrowthPetCacheSetPtr.end())
-	{
-		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : No GrowthPetCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TGrowthPetCacheSet* pSet = it->second;
-	auto it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CGrowthPetCache* c = *it_set++;
-		c->Flush();
-
-		m_map_growthPetCache.erase(c->Get()->dwID);
-		delete c;
-	}
-
-	pSet->clear();
-	delete pSet;
-
-	m_map_pkGrowthPetCacheSetPtr.erase(it);
-
-	if (g_log)
-		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : Deleted pid(%d)", pid);
-}
-
-CGrowthPetCache* CClientManager::GetGrowthPetCache(DWORD id)
-{
-	auto it = m_map_growthPetCache.find(id);
-
-	if (it == m_map_growthPetCache.end())
-		return nullptr;
-
-	return it->second;
-}
-
-void CClientManager::PutGrowthPetCache(TGrowthPet* pNew, bool bSkipQuery)
-{
-	CGrowthPetCache* c;
-
-	c = GetGrowthPetCache(pNew->dwID);
-	if (!c)
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> New CGrowthPetCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
-
-		c = new CGrowthPetCache;
-		m_map_growthPetCache.insert(TGrowthPetCacheMap::value_type(pNew->dwID, c));
-	}
-	else
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> Have Cache");
-		if (pNew->dwOwner != c->Get()->dwOwner)
-		{
-			auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
-
-			if (it != m_map_pkGrowthPetCacheSetPtr.end())
-			{
-				if (g_log)
-					sys_log(0, "GROWTH_PET_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
-				it->second->erase(c);
-			}
-		}
-	}
-	c->Put(pNew, bSkipQuery);
-
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
-
-	if (it != m_map_pkGrowthPetCacheSetPtr.end())
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		it->second->insert(c);
-	}
-	else
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-
-		c->OnFlush();
-	}
-}
-
-bool CClientManager::DeleteGrowthPetCache(DWORD dwID)
-{
-	CGrowthPetCache* c = GetGrowthPetCache(dwID);
-
-	if (!c)
-		return false;
-
-	c->Delete();
-	return true;
-}
-
-void CClientManager::UpdateGrowthPetCache()
-{
-	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-		return;
-
-	auto it = m_map_growthPetCache.begin();
-
-	while (it != m_map_growthPetCache.end())
-	{
-		CGrowthPetCache* c = (it++)->second;
-
-		if (c->CheckFlushTimeout())
-		{
-			if (g_test_server)
-				sys_log(0, "UpdateGrowthPetCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
-
-			c->Flush();
-
-			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-				break;
-		}
-	}
-}
-
-void CClientManager::UpdateGrowthPetCacheSet(DWORD pid)
-{
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
-
-	if (it == m_map_pkGrowthPetCacheSetPtr.end())
-	{
-		if (g_test_server)
-			sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet ==> No GrowthPetCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TGrowthPetCacheSet* pSet = it->second;
-	auto it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CGrowthPetCache* c = *it_set++;
-		c->Flush();
-	}
-
-	if (g_log)
-		sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet pid(%d)", pid);
-}
-
-void CClientManager::QUERY_GROWTH_PET_SAVE(CPeer* pkPeer, const char* c_pData)
-{
-	TGrowthPet* p = (TGrowthPet*)c_pData;
-	if (g_test_server)
-		sys_log(0, "QUERY_GROWTH_PET_SAVE => PutGrowthPetCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
-
-	PutGrowthPetCache(p);
-}
-
-void CClientManager::QUERY_GROWTH_PET_DELETE(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwID = *(DWORD*)c_pData;
-	c_pData += sizeof(DWORD);
-
-	DWORD dwPID = *(DWORD*)c_pData;
-
-	if (!DeleteGrowthPetCache(dwID))
-	{
-		char szQuery[64];
-		snprintf(szQuery, sizeof(szQuery), "DELETE FROM growth_pet%s WHERE id=%u", GetTablePostfix(), dwID);
-
-		if (dwPID == 0)
-			CDBManager::instance().AsyncQuery(szQuery);
-		else
-			CDBManager::instance().ReturnQuery(szQuery, QID_GROWTH_PET_DELETE, pkPeer->GetHandle(), NULL);
-	}
-}
-
-bool CClientManager::CreateGrowthPetTableFromRes(MYSQL_RES* res, std::vector<TGrowthPet>* pVec, DWORD dwPID)
-{
-	if (!res)
-	{
-		pVec->clear();
-		return true;
-	}
-
-	int rows;
-
-	if ((rows = mysql_num_rows(res)) <= 0)
-	{
-		pVec->clear();
-		return true;
-	}
-
-	pVec->resize(rows);
-
-	for (int i = 0; i < rows; ++i)
-	{
-		MYSQL_ROW row = mysql_fetch_row(res);
-		TGrowthPet& pet = pVec->at(i);
-
-		int cur = 0;
-
-		str_to_number(pet.dwID, row[cur++]);
-		str_to_number(pet.dwVnum, row[cur++]);
-		str_to_number(pet.bState, row[cur++]);
-		strlcpy(pet.szName, row[cur++], sizeof(pet.szName));
-		str_to_number(pet.bSize, row[cur++]);
-		str_to_number(pet.dwLevel, row[cur++]);
-		str_to_number(pet.bLevelStep, row[cur++]);
-		str_to_number(pet.bEvolution, row[cur++]);
-		str_to_number(pet.bType, row[cur++]);
-		str_to_number(pet.dwHP, row[cur++]);
-		str_to_number(pet.dwSP, row[cur++]);
-		str_to_number(pet.dwDef, row[cur++]);
-		str_to_number(pet.dwHPApply, row[cur++]);
-		str_to_number(pet.dwSPApply, row[cur++]);
-		str_to_number(pet.dwDefApply, row[cur++]);
-		str_to_number(pet.dwAgeApply, row[cur++]);
-		thecore_memcpy(pet.aSkill, row[cur++], sizeof(pet.aSkill));
-		str_to_number(pet.lExp, row[cur++]);
-		str_to_number(pet.lItemExp, row[cur++]);
-		str_to_number(pet.lBirthday, row[cur++]);
-		str_to_number(pet.lEndTime, row[cur++]);
-		str_to_number(pet.lMaxTime, row[cur++]);
-
-		pet.dwOwner = dwPID;
-	}
-
-	return true;
-}
-
-void CClientManager::RESULT_GROWTH_PET_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID)
-{
-	static std::vector<TGrowthPet> s_petVec;
-	CreateGrowthPetTableFromRes(pRes, &s_petVec, dwPID);
-	DWORD dwCount = s_petVec.size();
-
-	peer->EncodeHeader(HEADER_DG_GROWTH_PET_LOAD, dwHandle, sizeof(DWORD) + sizeof(TGrowthPet) * dwCount);
-	peer->EncodeDWORD(dwCount);
-
-	CreateGrowthPetCacheSet(dwPID);
-
-	sys_log(0, "GROWTH_PET_LOAD: count %u pid %u", dwCount, dwPID);
-
-	if (dwCount)
-	{
-		peer->Encode(&s_petVec[0], sizeof(TGrowthPet) * dwCount);
-
-		for (DWORD i = 0; i < dwCount; ++i)
-			PutGrowthPetCache(&s_petVec[i], true);
-	}
-}
-#endif
+#include "stdafx.h"
+#include <set>
+#include "../../common/building.h"
+#include "../../common/VnumHelper.h"
+#include "../../libgame/include/grid.h"
+
+#include "ClientManager.h"
+
+#include "Main.h"
+#include "Config.h"
+#include "DBManager.h"
+#include "QID.h"
+#include "GuildManager.h"
+#include "PrivManager.h"
+#include "MoneyLog.h"
+#include "ItemAwardManager.h"
+#include "Marriage.h"
+#include "Monarch.h"
+#include "BlockCountry.h"
+#include "ItemIDRangeManager.h"
+#include "Cache.h"
+
+#include <sstream>
+#if defined(__SHOP_SEARCH__)
+	#include "ShopSearchManager.h"
+#endif
+
+extern int g_iPlayerCacheFlushSeconds;
+extern int g_iItemCacheFlushSeconds;
+extern int g_test_server;
+extern int g_log;
+extern std::string g_stLocale;
+extern std::string g_stLocaleNameColumn;
+bool CreateItemTableFromRes(MYSQL_RES* res, std::vector<TPlayerItem>* pVec, DWORD dwPID);
+
+DWORD g_dwUsageMax = 0;
+DWORD g_dwUsageAvg = 0;
+
+CPacketInfo g_query_info;
+CPacketInfo g_item_info;
+
+int g_item_count = 0;
+int g_query_count[2];
+
+CClientManager::CClientManager() :
+	m_pkAuthPeer(NULL),
+	m_iPlayerIDStart(0),
+	m_iPlayerDeleteLevelLimit(0),
+	m_iPlayerDeleteLevelLimitLower(0),
+	m_bChinaEventServer(false),
+	m_iShopTableSize(0),
+	m_pShopTable(NULL),
+	m_iRefineTableSize(0),
+	m_pRefineTable(NULL),
+	m_bShutdowned(false),
+	m_iCacheFlushCount(0),
+	m_iCacheFlushCountLimit(200)
+#if defined(__EXPRESSING_EMOTIONS__)
+	, m_iEmoteDumpDelay(3600)
+#endif
+#if defined(__MAILBOX__)
+	, m_iMailBoxBackupSec(3600)
+#endif
+#if defined(__GEM_SHOP__)
+	, m_iGemShopFlushDelay(3600)
+#endif
+{
+	m_itemRange.dwMin = 0;
+	m_itemRange.dwMax = 0;
+	m_itemRange.dwUsableItemIDMin = 0;
+
+	memset(g_query_count, 0, sizeof(g_query_count));
+}
+
+CClientManager::~CClientManager()
+{
+	Destroy();
+}
+
+void CClientManager::SetPlayerIDStart(int iIDStart)
+{
+	m_iPlayerIDStart = iIDStart;
+}
+
+void CClientManager::Destroy()
+{
+	m_mChannelStatus.clear();
+	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		(*i)->Destroy();
+
+	m_peerList.clear();
+
+	if (m_fdAccept > 0)
+	{
+		socket_close(m_fdAccept);
+		m_fdAccept = -1;
+	}
+}
+
+bool CClientManager::Initialize()
+{
+	int tmpValue;
+
+	// BOOT_LOCALIZATION
+	if (!InitializeLocalization())
+	{
+		fprintf(stderr, "Failed Localization Infomation so exit\n");
+		return false;
+	}
+	// END_BOOT_LOCALIZATION
+
+	// ITEM_UNIQUE_ID
+	if (!InitializeNowItemID())
+	{
+		fprintf(stderr, " Item range Initialize Failed. Exit DBCache Server\n");
+		return false;
+	}
+	// END_ITEM_UNIQUE_ID
+
+	m_bWolfmanCharacter = true;
+	int iWolfmanCharacter = 0;
+	if (CConfig::instance().GetValue("WOLFMAN_CHARACTER", &iWolfmanCharacter))
+		m_bWolfmanCharacter = (iWolfmanCharacter);
+	sys_log(0, "WOLFMAN_CHARACTER %s", m_bWolfmanCharacter ? "true" : "false");
+
+	m_bDelayedCharacterCreation = true;
+	int iDelayedCharacterCreation = 0;
+	if (CConfig::instance().GetValue("DELAYED_CHARACTER_CREATION", &iDelayedCharacterCreation))
+		m_bDelayedCharacterCreation = (iDelayedCharacterCreation);
+	sys_log(0, "DELAYED_CHARACTER_CREATION %s", m_bDelayedCharacterCreation ? "true" : "false");
+
+	if (!InitializeTables())
+	{
+		sys_err("Table Initialize FAILED");
+		return false;
+	}
+
+	CGuildManager::instance().BootReserveWar();
+
+	if (!CConfig::instance().GetValue("BIND_PORT", &tmpValue))
+		tmpValue = 5300;
+
+	char szBindIP[128];
+
+	if (!CConfig::instance().GetValue("BIND_IP", szBindIP, 128))
+		strlcpy(szBindIP, "0", sizeof(szBindIP));
+
+	m_fdAccept = socket_tcp_bind(szBindIP, tmpValue);
+
+	if (m_fdAccept < 0)
+	{
+		perror("socket");
+		return false;
+	}
+
+	sys_log(0, "ACCEPT_HANDLE: %u", m_fdAccept);
+	fdwatch_add_fd(m_fdWatcher, m_fdAccept, NULL, FDW_READ, false);
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	CConfig::instance().GetValue("EMOTE_DUMP_DELAY", &m_iEmoteDumpDelay);
+#endif
+
+#if defined(__MAILBOX__)
+	CConfig::instance().GetValue("MAILBOX_BACKUP_SEC", &m_iMailBoxBackupSec);
+#endif
+
+#if defined(__GEM_SHOP__)
+	CConfig::instance().GetValue("GEM_SHOP_FLUSH_DELAY", &m_iGemShopFlushDelay);
+#endif
+
+	if (!CConfig::instance().GetValue("BACKUP_LIMIT_SEC", &tmpValue))
+		tmpValue = 600;
+
+	m_looping = true;
+
+	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT", &m_iPlayerDeleteLevelLimit))
+	{
+		sys_err("config.txt: Cannot find PLAYER_DELETE_LEVEL_LIMIT, use default level %d", PLAYER_MAX_LEVEL_CONST + 1);
+		m_iPlayerDeleteLevelLimit = PLAYER_MAX_LEVEL_CONST + 1;
+	}
+
+	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT_LOWER", &m_iPlayerDeleteLevelLimitLower))
+	{
+		m_iPlayerDeleteLevelLimitLower = 0;
+	}
+
+	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT set to %d", m_iPlayerDeleteLevelLimit);
+	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT_LOWER set to %d", m_iPlayerDeleteLevelLimitLower);
+
+	m_bChinaEventServer = false;
+
+	int iChinaEventServer = 0;
+
+	if (CConfig::instance().GetValue("CHINA_EVENT_SERVER", &iChinaEventServer))
+		m_bChinaEventServer = (iChinaEventServer);
+
+	sys_log(0, "CHINA_EVENT_SERVER %s", CClientManager::instance().IsChinaEventServer() ? "true" : "false");
+
+	LoadEventFlag();
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	LoadGuildEventFlag();
+#endif
+
+	// database character-set  
+	if (g_stLocale == "big5" || g_stLocale == "sjis")
+		CDBManager::instance().QueryLocaleSet();
+
+	return true;
+}
+
+void CClientManager::MainLoop()
+{
+	SQLMsg* tmp;
+
+	sys_log(0, "ClientManager pointer is %p", this);
+
+	// 管
+	while (!m_bShutdowned)
+	{
+		while ((tmp = CDBManager::instance().PopResult()))
+		{
+			AnalyzeQueryResult(tmp);
+			delete tmp;
+		}
+
+		if (!Process())
+			break;
+
+		log_rotate();
+	}
+
+	//
+	// 管 처
+	//
+	sys_log(0, "MainLoop exited, Starting cache flushing");
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	CClientManager::instance().QUERY_EMOTE_DUMP();
+#endif
+
+#if defined(__MAILBOX__)
+	CClientManager::instance().MAILBOX_BACKUP();
+#endif
+
+#if defined(__GEM_SHOP__)
+	// Gem Shop Item Data List Flush
+	CClientManager::instance().FlushGemShop();
+#endif
+
+	signal_timer_disable();
+
+	// 첨潔 遣 캐 첨
+	auto it = m_map_playerCache.begin();
+	while (it != m_map_playerCache.end())
+	{
+		CPlayerTableCache* c = (it++)->second;
+
+		c->Flush();
+		delete c;
+	}
+	m_map_playerCache.clear();
+
+	//  첨
+	auto it2 = m_map_itemCache.begin();
+	while (it2 != m_map_itemCache.end())
+	{
+		CItemCache* c = (it2++)->second;
+
+		c->Flush();
+		delete c;
+	}
+	m_map_itemCache.clear();
+
+	// MYSHOP_PRICE_LIST
+	//
+	// 貫   트 Flush
+	//
+	for (auto itPriceList = m_mapItemPriceListCache.begin(); itPriceList != m_mapItemPriceListCache.end(); ++itPriceList)
+	{
+		CItemPriceListTableCache* pCache = itPriceList->second;
+		pCache->Flush();
+		delete pCache;
+	}
+
+	m_mapItemPriceListCache.clear();
+#ifdef __OFFLINE_SHOP__
+	FlushOfflineShops();
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	auto growthPetCache = m_map_growthPetCache.begin();
+
+	while (growthPetCache != m_map_growthPetCache.end())
+	{
+		CGrowthPetCache* c = (growthPetCache++)->second;
+
+		c->Flush();
+		delete c;
+	}
+	m_map_growthPetCache.clear();
+#endif
+
+	// END_OF_MYSHOP_PRICE_LIST
+}
+
+void CClientManager::Quit()
+{
+	m_bShutdowned = true;
+}
+
+void CClientManager::QUERY_BOOT(CPeer* peer, TPacketGDBoot* p)
+{
+	const BYTE bPacketVersion = 6; // BOOT 킷 侮除㎏ 호 첩 磯.
+
+	std::vector<tAdminInfo> vAdmin;
+	std::vector<std::string> vHost;
+
+	__GetHostInfo(vHost);
+	__GetAdminInfo(p->szIP, vAdmin);
+
+	sys_log(0, "QUERY_BOOT : AdminInfo (Request ServerIp %s) ", p->szIP);
+
+	DWORD dwPacketSize =
+		sizeof(DWORD) +
+		sizeof(BYTE) +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TShopTable) * m_iShopTableSize +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemAttrTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemRareTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(building::TLand) * m_vec_kLandTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObjectProto) * m_vec_kObjectProto.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObject) * m_map_pkObjectTable.size() +
+#ifdef __GROWTH_PET_SYSTEM__
+		sizeof(WORD) + sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size() +
+#endif
+		sizeof(time_t) +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemIDRangeTable) * 2 +
+		// ADMIN_MANAGER
+		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
+		// END_ADMIN_MANAGER
+		sizeof(WORD) + sizeof(WORD) + sizeof(TMonarchInfo) +
+		sizeof(WORD) + sizeof(WORD) + sizeof(MonarchCandidacy) * CMonarch::instance().MonarchCandidacySize() +
+		sizeof(WORD);
+
+	peer->EncodeHeader(HEADER_DG_BOOT, 0, dwPacketSize);
+	peer->Encode(&dwPacketSize, sizeof(DWORD));
+	peer->Encode(&bPacketVersion, sizeof(BYTE));
+
+	sys_log(0, "BOOT: PACKET: %d", dwPacketSize);
+	sys_log(0, "BOOT: VERSION: %d", bPacketVersion);
+
+	sys_log(0, "sizeof(TMobTable) = %d", sizeof(TMobTable));
+	sys_log(0, "sizeof(TItemTable) = %d", sizeof(TItemTable));
+	sys_log(0, "sizeof(TShopTable) = %d", sizeof(TShopTable));
+	sys_log(0, "sizeof(TSkillTable) = %d", sizeof(TSkillTable));
+	sys_log(0, "sizeof(TRefineTable) = %d", sizeof(TRefineTable));
+	sys_log(0, "sizeof(TItemAttrTable) = %d", sizeof(TItemAttrTable));
+	sys_log(0, "sizeof(TItemRareTable) = %d", sizeof(TItemAttrTable));
+	sys_log(0, "sizeof(TBanwordTable) = %d", sizeof(TBanwordTable));
+	sys_log(0, "sizeof(TLand) = %d", sizeof(building::TLand));
+	sys_log(0, "sizeof(TObjectProto) = %d", sizeof(building::TObjectProto));
+	sys_log(0, "sizeof(TObject) = %d", sizeof(building::TObject));
+	// ADMIN_MANAGER
+	sys_log(0, "sizeof(tAdminInfo) = %d * %d ", sizeof(tAdminInfo) * vAdmin.size());
+	// END_ADMIN_MANAGER
+	sys_log(0, "sizeof(TMonarchInfo) = %d * %d", sizeof(TMonarchInfo));
+#ifdef __GROWTH_PET_SYSTEM__
+	sys_log(0, "sizeof(TGrowthPetSkillTable) = %d", sizeof(TGrowthPetSkillTable));
+#endif
+
+	peer->EncodeWORD(sizeof(TMobTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
+	peer->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
+
+	peer->EncodeWORD(sizeof(TItemTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
+	peer->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
+
+	peer->EncodeWORD(sizeof(TShopTable));
+	peer->EncodeWORD(m_iShopTableSize);
+	peer->Encode(m_pShopTable, sizeof(TShopTable) * m_iShopTableSize);
+
+	peer->EncodeWORD(sizeof(TSkillTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
+	peer->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
+
+	peer->EncodeWORD(sizeof(TRefineTable));
+	peer->EncodeWORD(m_iRefineTableSize);
+	peer->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
+
+	peer->EncodeWORD(sizeof(TItemAttrTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_itemAttrTable.size()));
+	peer->Encode(&m_vec_itemAttrTable[0], sizeof(TItemAttrTable) * m_vec_itemAttrTable.size());
+
+	peer->EncodeWORD(sizeof(TItemAttrTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_itemRareTable.size()));
+	peer->Encode(&m_vec_itemRareTable[0], sizeof(TItemAttrTable) * m_vec_itemRareTable.size());
+
+	peer->EncodeWORD(sizeof(TBanwordTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
+	peer->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
+
+	peer->EncodeWORD(sizeof(building::TLand));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_kLandTable.size()));
+	peer->Encode(&m_vec_kLandTable[0], sizeof(building::TLand) * m_vec_kLandTable.size());
+
+	peer->EncodeWORD(sizeof(building::TObjectProto));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_kObjectProto.size()));
+	peer->Encode(&m_vec_kObjectProto[0], sizeof(building::TObjectProto) * m_vec_kObjectProto.size());
+
+	peer->EncodeWORD(sizeof(building::TObject));
+	peer->EncodeWORD(static_cast<WORD>(m_map_pkObjectTable.size()));
+
+	auto it = m_map_pkObjectTable.begin();
+	while (it != m_map_pkObjectTable.end())
+		peer->Encode((it++)->second, sizeof(building::TObject));
+
+#ifdef __GROWTH_PET_SYSTEM__
+	peer->EncodeWORD(sizeof(TGrowthPetSkillTable));
+	peer->EncodeWORD(m_vec_growthPetSkillTable.size());
+	if (m_vec_growthPetSkillTable.size())
+		peer->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
+#endif
+
+	time_t now = time(0);
+	peer->Encode(&now, sizeof(time_t));
+
+	TItemIDRangeTable itemRange = CItemIDRangeManager::instance().GetRange();
+	TItemIDRangeTable itemRangeSpare = CItemIDRangeManager::instance().GetRange();
+
+	peer->EncodeWORD(sizeof(TItemIDRangeTable));
+	peer->EncodeWORD(1);
+	peer->Encode(&itemRange, sizeof(TItemIDRangeTable));
+	peer->Encode(&itemRangeSpare, sizeof(TItemIDRangeTable));
+
+	peer->SetItemIDRange(itemRange);
+	peer->SetSpareItemIDRange(itemRangeSpare);
+
+	// ADMIN_MANAGER
+	peer->EncodeWORD(16);
+	peer->EncodeWORD(static_cast<WORD>(vHost.size()));
+
+	for (size_t n = 0; n < vHost.size(); ++n)
+	{
+		peer->Encode(vHost[n].c_str(), 16);
+		sys_log(0, "GMHosts %s", vHost[n].c_str());
+	}
+
+	peer->EncodeWORD(sizeof(tAdminInfo));
+	peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
+
+	for (size_t n = 0; n < vAdmin.size(); ++n)
+	{
+		peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
+		sys_log(0, "Admin name %s ConntactIP %s", vAdmin[n].m_szName, vAdmin[n].m_szContactIP);
+	}
+	// END_ADMIN_MANAGER
+
+	// MONARCH
+	peer->EncodeWORD(sizeof(TMonarchInfo));
+	peer->EncodeWORD(1);
+	peer->Encode(CMonarch::instance().GetMonarch(), sizeof(TMonarchInfo));
+
+	CMonarch::VEC_MONARCHCANDIDACY& rVecMonarchCandidacy = CMonarch::instance().GetVecMonarchCandidacy();
+
+	size_t num_monarch_candidacy = CMonarch::instance().MonarchCandidacySize();
+	peer->EncodeWORD(sizeof(MonarchCandidacy));
+	peer->EncodeWORD(static_cast<WORD>(num_monarch_candidacy));
+	if (num_monarch_candidacy != 0)
+	{
+		peer->Encode(&rVecMonarchCandidacy[0], sizeof(MonarchCandidacy) * num_monarch_candidacy);
+	}
+	// END_MONARCE
+
+	if (g_test_server)
+		sys_log(0, "MONARCHCandidacy Size %d", CMonarch::instance().MonarchCandidacySize());
+
+#ifdef __OFFLINE_SHOP__
+	peer->EncodeDWORD(sizeof(TOfflineShop));
+	peer->EncodeDWORD(offlineShopCache_.size());
+	for (const auto& entry : offlineShopCache_) {
+		peer->Encode(entry.second->Get(), sizeof(TOfflineShop));
+	}
+
+	peer->EncodeDWORD(sizeof(TOfflineShopItem));
+	peer->EncodeDWORD(offlineShopItemCache_.size());
+	for (const auto& entry : offlineShopItemCache_) {
+		peer->Encode(entry.second->Get(), sizeof(TOfflineShopItem));
+	}
+#endif
+
+	peer->EncodeWORD(0xffff);
+}
+
+void CClientManager::SendPartyOnSetup(CPeer* pkPeer)
+{
+	TPartyMap& pm = m_map_pkChannelParty[pkPeer->GetChannel()];
+	for (auto it_party = pm.begin(); it_party != pm.end(); ++it_party)
+	{
+		sys_log(0, "PARTY SendPartyOnSetup Party [%u]", it_party->first);
+		pkPeer->EncodeHeader(HEADER_DG_PARTY_CREATE, 0, sizeof(TPacketPartyCreate));
+		pkPeer->Encode(&it_party->first, sizeof(DWORD));
+
+		for (auto it_member = it_party->second.begin(); it_member != it_party->second.end(); ++it_member)
+		{
+			sys_log(0, "PARTY SendPartyOnSetup Party [%u] Member [%u]", it_party->first, it_member->first);
+			pkPeer->EncodeHeader(HEADER_DG_PARTY_ADD, 0, sizeof(TPacketPartyAdd));
+			pkPeer->Encode(&it_party->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->second.bRole, sizeof(BYTE));
+
+			pkPeer->EncodeHeader(HEADER_DG_PARTY_SET_MEMBER_LEVEL, 0, sizeof(TPacketPartySetMemberLevel));
+			pkPeer->Encode(&it_party->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->second.bLevel, sizeof(BYTE));
+		}
+	}
+}
+
+void CClientManager::QUERY_PLAYER_COUNT(CPeer* pkPeer, TPlayerCountPacket* pPacket)
+{
+	pkPeer->SetUserCount(pPacket->dwCount);
+}
+
+void CClientManager::QUERY_QUEST_SAVE(CPeer* pkPeer, TQuestTable* pTable, DWORD dwLen)
+{
+	if (0 != (dwLen % sizeof(TQuestTable)))
+	{
+		sys_err("invalid packet size %d, sizeof(TQuestTable) == %d", dwLen, sizeof(TQuestTable));
+		return;
+	}
+
+	int iSize = dwLen / sizeof(TQuestTable);
+
+	char szQuery[1024];
+
+	for (int i = 0; i < iSize; ++i, ++pTable)
+	{
+		if (pTable->lValue == 0)
+		{
+			snprintf(szQuery, sizeof(szQuery), "DELETE FROM quest%s WHERE `dwPID` = %d AND `szName` = '%s' AND `szState` ='%s'",
+				GetTablePostfix(), pTable->dwPID, pTable->szName, pTable->szState);
+		}
+		else
+		{
+			snprintf(szQuery, sizeof(szQuery), "REPLACE INTO quest%s (`dwPID`, `szName`, `szState`, `lValue`) VALUES(%d, '%s', '%s', %ld)",
+				GetTablePostfix(), pTable->dwPID, pTable->szName, pTable->szState, pTable->lValue);
+		}
+
+		CDBManager::instance().ReturnQuery(szQuery, QID_QUEST_SAVE, pkPeer->GetHandle(), NULL);
+	}
+}
+
+void CClientManager::QUERY_SAFEBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TSafeboxLoadPacket* packet, bool bMall)
+{
+	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
+	strlcpy(pi->safebox_password, packet->szPassword, sizeof(pi->safebox_password));
+	pi->account_id = packet->dwID;
+	pi->account_index = 0;
+	pi->ip[0] = bMall ? 1 : 0;
+	strlcpy(pi->login, packet->szLogin, sizeof(pi->login));
+
+	char szQuery[QUERY_MAX_LEN];
+	snprintf(szQuery, sizeof(szQuery),
+		"SELECT `account_id`, `size`, `password` FROM safebox%s WHERE `account_id` = %u",
+		GetTablePostfix(), packet->dwID);
+
+	if (g_log)
+		sys_log(0, "HEADER_GD_SAFEBOX_LOAD (handle: %d account.id %u is_mall %d)", dwHandle, packet->dwID, bMall ? 1 : 0);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
+}
+
+void CClientManager::RESULT_SAFEBOX_LOAD(CPeer* pkPeer, SQLMsg* msg)
+{
+	sys_log(0, "RESULT_SAFEBOX_LOAD");
+
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = pi->dwHandle;
+
+	// 藪 求 account_index   磯.
+	// 첫째 戟 鱇틂  求  0
+	// 菅째  拷   1
+
+	if (pi->account_index == 0)
+	{
+		sys_log(0, "RESULT_SAFEBOX_LOAD account_index == 0");
+
+		char szSafeboxPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
+		strlcpy(szSafeboxPassword, pi->safebox_password, sizeof(szSafeboxPassword));
+
+		TSafeboxTable* pSafebox = new TSafeboxTable;
+		memset(pSafebox, 0, sizeof(TSafeboxTable));
+
+		SQLResult* res = msg->Get();
+
+		if (res->uiNumRows == 0)
+		{
+			if (strcmp("000000", szSafeboxPassword))
+			{
+				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
+				delete pSafebox;
+				delete pi;
+				return;
+			}
+		}
+		else
+		{
+			sys_log(0, "RESULT_SAFEBOX_LOAD get rows");
+
+			MYSQL_ROW row = mysql_fetch_row(res->pSQLResult);
+
+			// 橘호 틀..
+			if (((!row[2] || !*row[2]) && strcmp("000000", szSafeboxPassword)) ||
+				((row[2] && *row[2]) && strcmp(row[2], szSafeboxPassword)))
+			{
+				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
+				delete pSafebox;
+				delete pi;
+				return;
+			}
+
+			if (!row[0])
+				pSafebox->dwID = 0;
+			else
+				str_to_number(pSafebox->dwID, row[0]);
+
+			if (!row[1])
+				pSafebox->bSize = 0;
+			else
+				str_to_number(pSafebox->bSize, row[1]);
+			/*
+			if (!row[3])
+				pSafebox->dwGold = 0;
+			else
+				pSafebox->dwGold = atoi(row[3]);
+			*/
+			if (pi->ip[0] == 1)
+			{
+#if defined(__EXTEND_MALLBOX__)
+				pSafebox->bSize = 5;
+#else
+				pSafebox->bSize = 1;
+#endif
+				sys_log(0, "MALL id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
+			}
+			else
+				sys_log(0, "SAFEBOX id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
+		}
+
+		if (0 == pSafebox->dwID)
+			pSafebox->dwID = pi->account_id;
+
+		pi->pSafebox = pSafebox;
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
+#if defined(__SOUL_BIND_SYSTEM__)
+			", `soulbind`"
+#endif
+			", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+			", `socket3`, `socket4`, `socket5`"
+#endif
+			", `attrtype0`, `attrvalue0`"
+			", `attrtype1`, `attrvalue1`"
+			", `attrtype2`, `attrvalue2`"
+			", `attrtype3`, `attrvalue3`"
+			", `attrtype4`, `attrvalue4`"
+			", `attrtype5`, `attrvalue5`"
+			", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			", `transmutation`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			", `refine_element_apply_type`"
+			", `refine_element_grade`"
+			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			", `apply_type0`, `apply_value0`, `apply_path0`"
+			", `apply_type1`, `apply_value1`, `apply_path1`"
+			", `apply_type2`, `apply_value2`, `apply_path2`"
+			", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+			", `set_value`"
+#endif
+			" FROM `item%s` WHERE `owner_id` = %u AND `window` = '%s'",
+			GetTablePostfix(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL");
+
+		pi->account_index = 1;
+
+		CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
+	}
+	else
+	{
+		sys_log(0, "RESULT_SAFEBOX_LOAD YES!!!!!!!!!!!");
+
+		if (!pi->pSafebox)
+		{
+			sys_err("null safebox pointer!");
+			delete pi;
+			return;
+		}
+
+		//   羚퓐   창 獵  처
+		// 堅  창 틴 효째 
+		if (!msg->Get()->pSQLResult)
+		{
+			sys_err("null safebox result");
+			delete pi;
+			return;
+		}
+
+		static std::vector<TPlayerItem> s_items;
+		CreateItemTableFromRes(msg->Get()->pSQLResult, &s_items, pi->account_id);
+
+		ItemAwardSet* pSet = ItemAwardManager::instance().GetByLogin(pi->login);
+
+		// Anti-dupe hardening: prevent duplicate/concurrent processing of item_award for the same login.
+		struct _ItemAwardCheckoutGuard
+		{
+			static std::set<std::string>& Set()
+			{
+				static std::set<std::string> s_inflight;
+				return s_inflight;
+			}
+			std::string login;
+			bool active;
+			_ItemAwardCheckoutGuard(const char* szLogin) : login(szLogin ? szLogin : ""), active(false)
+			{
+				auto& s = Set();
+				if (!login.empty() && s.insert(login).second)
+					active = true;
+			}
+			~_ItemAwardCheckoutGuard()
+			{
+				if (!active) return;
+				auto& s = Set();
+				s.erase(login);
+			}
+			operator bool() const { return active; }
+		};
+		_ItemAwardCheckoutGuard _award_guard(pi->login);
+		if (pSet && !_award_guard)
+		{
+			sys_log(0, "ItemAward checkout skipped (already in progress): %s", pi->login);
+			pSet = NULL;
+		}
+
+		if (pSet && !m_vec_itemTable.empty())
+		{
+#if defined(__EXTEND_MALLBOX__)
+			CGrid grid(5, MAX(1, 5) * 9);
+#else
+			CGrid grid(5, MAX(1, pi->pSafebox->bSize) * 9);
+#endif
+			bool bEscape = false;
+
+			for (DWORD i = 0; i < s_items.size(); ++i)
+			{
+				TPlayerItem& r = s_items[i];
+
+				auto it = m_map_itemTableByVnum.find(r.dwVnum);
+				if (it == m_map_itemTableByVnum.end())
+				{
+					bEscape = true;
+					sys_err("invalid item vnum %u in safebox: login %s", r.dwVnum, pi->login);
+					break;
+				}
+
+				grid.Put(r.wPos, 1, it->second->bSize);
+			}
+
+			if (!bEscape)
+			{
+				std::vector<std::pair<DWORD, DWORD> > vec_dwFinishedAwardID;
+				ItemAwardSet::const_iterator it = pSet->begin();
+				char szQuery[512];
+
+				while (it != pSet->end())
+				{
+					TItemAward* pItemAward = *(it++);
+					const DWORD& dwItemVnum = pItemAward->dwVnum;
+
+					if (pItemAward->bTaken)
+						continue;
+
+					if (pi->ip[0] == 0 && pItemAward->bMall)
+						continue;
+
+					if (pi->ip[0] == 1 && !pItemAward->bMall)
+						continue;
+
+					auto it = m_map_itemTableByVnum.find(pItemAward->dwVnum);
+					if (it == m_map_itemTableByVnum.end())
+					{
+						sys_err("invalid item vnum %u in item_award: login %s", pItemAward->dwVnum, pi->login);
+						continue;
+					}
+
+					TItemTable* pItemTable = it->second;
+
+					int iPos;
+
+					if ((iPos = grid.FindBlank(1, it->second->bSize)) == -1)
+						break;
+
+					TPlayerItem item;
+					memset(&item, 0, sizeof(TPlayerItem));
+
+#if defined(__EXTENDED_ITEM_AWARD__)
+					DWORD dwSocket0 = pItemAward->dwSocket0;
+					DWORD dwSocket2 = pItemAward->dwSocket2;
+					DWORD dwSocket4 = pItemAward->dwSocket4;
+					DWORD dwSocket5 = pItemAward->dwSocket5;
+#else
+					DWORD dwSocket2 = 0;
+#endif
+
+					if (pItemTable->bType == ITEM_UNIQUE)
+					{
+#if defined(__EXTENDED_ITEM_AWARD__)
+						// 12.04.2019 - Correction for unique items based on the real time.
+						const long lValue0 = pItemTable->alValues[ITEM_SOCKET_REMAIN_SEC];
+						const long lValue2 = pItemTable->alValues[ITEM_SOCKET_UNIQUE_REMAIN_TIME];
+						const time_t tNow = CClientManager::instance().GetCurrentTime();
+						dwSocket2 = (lValue2 == 0) ? static_cast<DWORD>(lValue0) : static_cast<DWORD>(tNow + lValue0);
+#else
+						if (pItemAward->dwSocket2 != 0)
+							dwSocket2 = pItemAward->dwSocket2;
+						else
+							dwSocket2 = pItemTable->alValues[0];
+#endif
+					}
+					else if ((dwItemVnum == ITEM_SKILLBOOK_VNUM || dwItemVnum == ITEM_SKILLFORGET_VNUM) && pItemAward->dwSocket0 == 0)
+					{
+						DWORD dwSkillIdx;
+						DWORD dwSkillVnum;
+
+						do
+						{
+							dwSkillIdx = number(0, m_vec_skillTable.size() - 1);
+
+							dwSkillVnum = m_vec_skillTable[dwSkillIdx].dwVnum;
+
+							if (dwSkillVnum > 120)
+								continue;
+
+							break;
+						} while (1);
+
+#if !defined(__EXTENDED_ITEM_AWARD__)
+						pItemAward->dwSocket0 = dwSkillVnum;
+#endif
+					}
+					else
+					{
+						switch (dwItemVnum)
+						{
+							case 72723: case 72724: case 72725: case 72726:
+							case 72727: case 72728: case 72729: case 72730:
+								// 첫  求  치 ...
+								// 瀏 柳 溝 湄.  悶 湄 滂.
+							case 76004: case 76005: case 76021: case 76022:
+							case 79012: case 79013:
+								if (pItemAward->dwSocket2 == 0)
+								{
+									dwSocket2 = pItemTable->alValues[0];
+								}
+								else
+								{
+									dwSocket2 = pItemAward->dwSocket2;
+								}
+								break;
+						}
+					}
+
+					if (GetItemID() > m_itemRange.dwMax)
+					{
+						sys_err("UNIQUE ID OVERFLOW!!");
+						break;
+					}
+
+					{
+						auto it = m_map_itemTableByVnum.find(dwItemVnum);
+						if (it == m_map_itemTableByVnum.end())
+						{
+							sys_err("Invalid item(vnum : %d). It is not in m_map_itemTableByVnum.", dwItemVnum);
+							continue;
+						}
+						TItemTable* item_table = it->second;
+						if (item_table == NULL)
+						{
+							sys_err("Invalid item_table (vnum : %d). It's value is NULL in m_map_itemTableByVnum.", dwItemVnum);
+							continue;
+						}
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+						if ((item_table->bType == ITEM_UNIQUE && item_table->bType == COSTUME_MOUNT))
+						{
+							if (pItemAward->dwSocket4 == 0)
+								dwSocket4 = pItemTable->alValues[0];
+							else
+								dwSocket4 = pItemAward->dwSocket4;
+						}
+#endif
+
+						if (0 == pItemAward->dwSocket0)
+						{
+							// Load default values
+							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+							{
+								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
+									break;
+								}
+								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
+									break;
+								}
+							}
+						}
+						else
+						{
+#if defined(__EXTENDED_ITEM_AWARD__)
+							// Load set values
+							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+							{
+								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
+								{
+									dwSocket0 = time(0) + pItemAward->dwSocket0;
+									break;
+								}
+								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
+								{
+									dwSocket0 = pItemAward->dwSocket0;
+									break;
+								}
+							}
+#else
+							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+							{
+								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
+
+									break;
+								}
+								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
+
+									break;
+								}
+							}
+#endif
+						}
+
+#if defined(__EXTENDED_ITEM_AWARD__)
+						ItemAwardManager::instance().CheckItemCount(*pItemAward, *pItemTable);
+						ItemAwardManager::instance().CheckItemBlend(*pItemAward, *pItemTable);
+						ItemAwardManager::instance().CheckItemAddonType(*pItemAward, *pItemTable);
+						ItemAwardManager::instance().CheckItemSkillBook(*pItemAward, m_vec_skillTable);
+						ItemAwardManager::instance().CheckItemAttributes(*pItemAward, *pItemTable, m_vec_itemAttrTable);
+
+						// START_OF_AUTO_QUERY
+						char szColumns[QUERY_MAX_LEN], szValues[QUERY_MAX_LEN];
+
+						int iLen = snprintf(szColumns, sizeof(szColumns), "`id`, `owner_id`, `window`, `pos`, `vnum`, `count`");
+						int iValueLen = snprintf(szValues, sizeof(szValues), "%u, %u, '%s', %d, %u, %u", GainItemID(), pi->account_id, (pi->ip[0] == 0) ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount);
+
+#if defined(__ITEM_SOCKET6__)
+						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`, `socket3`, `socket4`, `socket5`");
+						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u, %u, %u, %u", dwSocket0, pItemAward->dwSocket1, dwSocket2, pItemAward->dwSocket3, pItemAward->dwSocket4, pItemAward->dwSocket5);
+#else
+						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`");
+						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u", pItemAward->dwSocket0, pItemAward->dwSocket1, dwSocket2);
+#endif
+
+						for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
+						{
+							iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `attrtype%d`, `attrvalue%d`", i, i);
+							iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %ld", pItemAward->aAttr[i].wType, pItemAward->aAttr[i].lValue);
+						}
+						// END_OF_AUTO_QUERY
+
+						snprintf(szQuery, sizeof(szQuery), "INSERT INTO item%s (%s) VALUES(%s)", GetTablePostfix(), szColumns, szValues);
+#else
+						snprintf(szQuery, sizeof(szQuery),
+							"INSERT INTO item%s (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
+							", `socket0`"
+							", `socket1`"
+							", `socket2`"
+#if defined(__ITEM_SOCKET6__)
+							", `socket3`"
+							", `socket4`"
+							", `socket5`"
+#endif
+							") VALUES (%u, %u, '%s', %d, %u, %u"
+							", %u"
+							", %u"
+							", %u"
+#if defined(__ITEM_SOCKET6__)
+							", %u"
+							", %u"
+							", %u"
+#endif
+							")",
+							GetTablePostfix(), GainItemID(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount
+							, pItemAward->dwSocket0
+							, pItemAward->dwSocket1
+							, dwSocket2
+#if defined(__ITEM_SOCKET6__)
+							, pItemAward->dwSocket3
+							, pItemAward->dwSocket4
+							, pItemAward->dwSocket5
+#endif
+						);
+#endif
+					}
+
+					std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+					SQLResult* pRes = pmsg->Get();
+					sys_log(0, "SAFEBOX Query : [%s]", szQuery);
+
+					if (pRes->uiAffectedRows == 0 || pRes->uiInsertID == 0 || pRes->uiAffectedRows == (uint32_t)-1)
+						break;
+
+					item.dwID = pmsg->Get()->uiInsertID;
+					if (pi->ip[0] == 0)
+						item.bWindow = SAFEBOX, item.wPos = iPos;
+					else
+						item.bWindow = MALL, item.wPos = iPos;
+					item.dwVnum = pItemAward->dwVnum;
+					item.dwCount = pItemAward->dwCount;
+#if defined(__EXTENDED_ITEM_AWARD__)
+					item.alSockets[0] = dwSocket0;
+#else
+					item.alSockets[0] = pItemAward->dwSocket0;
+#endif
+					item.alSockets[1] = pItemAward->dwSocket1;
+					item.alSockets[2] = dwSocket2;
+#if defined(__ITEM_SOCKET6__)
+					item.alSockets[3] = pItemAward->dwSocket3;
+					item.alSockets[4] = dwSocket4;
+					item.alSockets[5] = dwSocket5;
+#endif
+#if defined(__EXTENDED_ITEM_AWARD__)
+					thecore_memcpy(&item.aAttr, pItemAward->aAttr, sizeof(item.aAttr));
+#endif
+					s_items.push_back(item);
+
+					vec_dwFinishedAwardID.push_back(std::make_pair(pItemAward->dwID, item.dwID));
+					grid.Put(iPos, 1, it->second->bSize);
+				}
+
+				for (DWORD i = 0; i < vec_dwFinishedAwardID.size(); ++i)
+					ItemAwardManager::instance().Taken(vec_dwFinishedAwardID[i].first, vec_dwFinishedAwardID[i].second);
+			}
+		}
+
+		pi->pSafebox->wItemCount = static_cast<WORD>(s_items.size());
+
+#ifdef __GROWTH_PET_SYSTEM__
+			UpdateGrowthPetCacheSet(c->Get()->id);
+#endif
+
+		if (pi->ip[0] == 0)
+			pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
+#ifdef __GROWTH_PET_SYSTEM__
+	FlushGrowthPetCacheSet(dwPID);
+#endif
+		);
+		else
+			pkPeer->EncodeHeader(HEADER_DG_MALL_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
+
+		);
+
+		pkPeer->Encode(pi->pSafebox, sizeof(TSafeboxTable));
+
+		if (!s_items.empty())
+			pkPeer->Encode(&s_items[0], sizeof(TPlayerItem) * s_items.size());
+
+#ifdef __GROWTH_PET_SYSTEM__
+			+ sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size()
+#endif
+
+		delete pi;
+	}
+}
+
+void CClientManager::QUERY_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangeSizePacket* p)
+{
+	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
+	pi->account_index = p->bSize; // account_index  擔첨 
+
+	char szQuery[QUERY_MAX_LEN];
+
+	if (p->bSize == 1)
+		snprintf(szQuery, sizeof(szQuery), "INSERT INTO safebox%s (`account_id`, `size`) VALUES(%u, %u)", GetTablePostfix(), p->dwID, p->bSize);
+	else
+		snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `size` = %u WHERE `account_id` = %u", GetTablePostfix(), p->bSize, p->dwID);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_SIZE, pkPeer->GetHandle(), pi);
+}
+
+void CClientManager::RESULT_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = p->dwHandle;
+	BYTE bSize = p->account_index;
+
+	delete p;
+
+	if (msg->Get()->uiNumRows > 0)
+	{
+		pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_SIZE, dwHandle, sizeof(BYTE));
+		pkPeer->EncodeBYTE(bSize);
+	}
+}
+
+void CClientManager::QUERY_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangePasswordPacket* p)
+{
+	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
+	strlcpy(pi->safebox_password, p->szNewPassword, sizeof(pi->safebox_password));
+	strlcpy(pi->login, p->szOldPassword, sizeof(pi->login));
+	pi->account_id = p->dwID;
+
+	char szQuery[QUERY_MAX_LEN];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `password` FROM safebox%s WHERE `account_id` = %u", GetTablePostfix(), p->dwID);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD, pkPeer->GetHandle(), pi);
+}
+
+void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = p->dwHandle;
+
+	if (msg->Get()->uiNumRows > 0)
+	{
+		MYSQL_ROW row = mysql_fetch_row(msg->Get()->pSQLResult);
+
+		if ((row[0] && *row[0] && !strcasecmp(row[0], p->login)) || ((!row[0] || !*row[0]) && !strcmp("000000", p->login)))
+		{
+			char szQuery[QUERY_MAX_LEN];
+			char escape_pwd[64];
+			CDBManager::instance().EscapeString(escape_pwd, p->safebox_password, strlen(p->safebox_password));
+
+			snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `password` = '%s' WHERE `account_id` = %u", GetTablePostfix(), escape_pwd, p->account_id);
+
+			CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD_SECOND, pkPeer->GetHandle(), p);
+			return;
+		}
+	}
+
+	delete p;
+
+	// Wrong old password
+	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
+	pkPeer->EncodeBYTE(0);
+}
+
+void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(CPeer* pkPeer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = p->dwHandle;
+	delete p;
+
+	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
+	pkPeer->EncodeBYTE(1);
+}
+
+// MYSHOP_PRICE_LIST
+void CClientManager::RESULT_PRICELIST_LOAD(CPeer* peer, SQLMsg* pMsg)
+{
+	TItemPricelistReqInfo* pReqInfo = (TItemPricelistReqInfo*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
+
+	//
+	// DB  琯  Cache  
+	//
+
+	TItemPriceListTable table;
+	table.dwOwnerID = pReqInfo->second;
+	table.byCount = 0;
+
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
+		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
+#if defined(__CHEQUE_SYSTEM__)
+		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
+#endif
+		table.byCount++;
+	}
+
+	PutItemPriceListCache(&table);
+
+	//
+	// 琯 拷 Game server  
+	//
+
+	TPacketMyshopPricelistHeader header;
+
+	header.dwOwnerID = pReqInfo->second;
+	header.byCount = table.byCount;
+
+	size_t sizePriceListSize = sizeof(TItemPriceInfo) * header.byCount;
+
+	peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, pReqInfo->first, sizeof(header) + sizePriceListSize);
+	peer->Encode(&header, sizeof(header));
+	peer->Encode(table.aPriceInfo, sizePriceListSize);
+
+	sys_log(0, "Load MyShopPricelist handle[%d] pid[%d] count[%d]", pReqInfo->first, pReqInfo->second, header.byCount);
+
+	delete pReqInfo;
+}
+
+void CClientManager::RESULT_PRICELIST_LOAD_FOR_UPDATE(SQLMsg* pMsg)
+{
+	TItemPriceListTable* pUpdateTable = (TItemPriceListTable*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
+
+	//
+	// DB  琯  Cache  
+	//
+
+	TItemPriceListTable table{};
+	table.dwOwnerID = pUpdateTable->dwOwnerID;
+	table.byCount = 0;
+
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
+		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
+#if defined(__CHEQUE_SYSTEM__)
+		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
+#endif
+		table.byCount++;
+	}
+
+	PutItemPriceListCache(&table);
+
+	// Update cache
+	GetItemPriceListCache(pUpdateTable->dwOwnerID)->UpdateList(pUpdateTable);
+
+	delete pUpdateTable;
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+void CClientManager::QUERY_SAFEBOX_SAVE(CPeer* pkPeer, TSafeboxTable* pTable)
+{
+	char szQuery[QUERY_MAX_LEN];
+
+	snprintf(szQuery, sizeof(szQuery),
+		"UPDATE safebox%s SET `gold` = '%u' WHERE `account_id` = %u",
+		GetTablePostfix(), pTable->dwGold, pTable->dwID);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_SAVE, pkPeer->GetHandle(), NULL);
+}
+
+void CClientManager::QUERY_EMPIRE_SELECT(CPeer* pkPeer, DWORD dwHandle, TEmpireSelectPacket* p)
+{
+	char szQuery[QUERY_MAX_LEN];
+
+	snprintf(szQuery, sizeof(szQuery), "UPDATE player_index%s SET `empire` = %u WHERE `id` = %u", GetTablePostfix(), p->bEmpire, p->dwAccountID);
+	delete CDBManager::instance().DirectQuery(szQuery);
+
+	sys_log(0, "EmpireSelect: %s", szQuery);
+	{
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `pid1`"
+			", `pid2`"
+			", `pid3`"
+			", `pid4`"
+#if defined(__PLAYER_PER_ACCOUNT5__)
+			", `pid5`"
+#endif
+			" FROM player_index%s WHERE `id` = %u", GetTablePostfix(), p->dwAccountID);
+
+		std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+		SQLResult* pRes = pmsg->Get();
+
+		if (pRes->uiNumRows)
+		{
+			sys_log(0, "EMPIRE %lu", pRes->uiNumRows);
+
+			MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
+			DWORD pids[3];
+
+			UINT g_start_map[4] =
+			{
+				0, // reserved
+				1, // 탉
+				21, // 천
+				41 // 諭
+			};
+
+			// FIXME share with game
+			DWORD g_start_position[4][2] =
+			{
+				{ 0, 0 },
+				{ 469300, 964200 }, // 탉
+				{ 55700, 157900 }, // 천
+				{ 969600, 278400 } // 諭
+			};
+
+			for (int i = 0; i < 3; ++i)
+			{
+				str_to_number(pids[i], row[i]);
+				sys_log(0, "EMPIRE PIDS[%d]", pids[i]);
+
+				if (pids[i])
+				{
+					sys_log(0, "EMPIRE move to pid[%d] to villiage of %u, map_index %d",
+						pids[i], p->bEmpire, g_start_map[p->bEmpire]);
+
+					snprintf(szQuery, sizeof(szQuery), "UPDATE player%s SET `map_index` = %u, `x` = %u, `y` = %u WHERE `id` = %u",
+						GetTablePostfix(),
+						g_start_map[p->bEmpire],
+						g_start_position[p->bEmpire][0],
+						g_start_position[p->bEmpire][1],
+						pids[i]);
+
+					std::unique_ptr<SQLMsg> pmsg2(CDBManager::instance().DirectQuery(szQuery));
+				}
+			}
+		}
+	}
+
+	pkPeer->EncodeHeader(HEADER_DG_EMPIRE_SELECT, dwHandle, sizeof(BYTE));
+	pkPeer->EncodeBYTE(p->bEmpire);
+}
+
+void CClientManager::QUERY_SETUP(CPeer* peer, DWORD dwHandle, const char* c_pData)
+{
+	TPacketGDSetup* p = (TPacketGDSetup*)c_pData;
+	c_pData += sizeof(TPacketGDSetup);
+
+	if (p->bAuthServer)
+	{
+		sys_log(0, "AUTH_PEER ptr %p", peer);
+
+		m_pkAuthPeer = peer;
+		return;
+	}
+
+	peer->SetPublicIP(p->szPublicIP);
+	peer->SetChannel(p->bChannel);
+	peer->SetListenPort(p->wListenPort);
+	peer->SetP2PPort(p->wP2PPort);
+	peer->SetMaps(p->alMaps);
+
+	//
+	// 錚  錚  獵 
+	//
+	TMapLocation kMapLocations;
+
+	strlcpy(kMapLocations.szHost, peer->GetPublicIP(), sizeof(kMapLocations.szHost));
+	kMapLocations.wPort = peer->GetListenPort();
+	thecore_memcpy(kMapLocations.alMaps, peer->GetMaps(), sizeof(kMapLocations.alMaps));
+
+	BYTE bMapCount;
+
+	std::vector<TMapLocation> vec_kMapLocations;
+
+	if (peer->GetChannel() == 1)
+	{
+		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		{
+			CPeer* tmp = *i;
+
+			if (tmp == peer)
+				continue;
+
+			if (!tmp->GetChannel())
+				continue;
+
+			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
+			{
+				TMapLocation kMapLocation2;
+				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
+				kMapLocation2.wPort = tmp->GetListenPort();
+				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
+				vec_kMapLocations.push_back(kMapLocation2);
+
+				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
+				bMapCount = 1;
+				tmp->EncodeBYTE(bMapCount);
+				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
+			}
+		}
+	}
+	else if (peer->GetChannel() == GUILD_WARP_WAR_CHANNEL)
+	{
+		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		{
+			CPeer* tmp = *i;
+
+			if (tmp == peer)
+				continue;
+
+			if (!tmp->GetChannel())
+				continue;
+
+			if (tmp->GetChannel() == 1 || tmp->GetChannel() == peer->GetChannel())
+			{
+				TMapLocation kMapLocation2;
+				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
+				kMapLocation2.wPort = tmp->GetListenPort();
+				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
+				vec_kMapLocations.push_back(kMapLocation2);
+			}
+
+			tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
+			bMapCount = 1;
+			tmp->EncodeBYTE(bMapCount);
+			tmp->Encode(&kMapLocations, sizeof(TMapLocation));
+		}
+	}
+	else
+	{
+		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		{
+			CPeer* tmp = *i;
+
+			if (tmp == peer)
+				continue;
+
+			if (!tmp->GetChannel())
+				continue;
+
+			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
+			{
+				TMapLocation kMapLocation2;
+
+				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
+				kMapLocation2.wPort = tmp->GetListenPort();
+				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
+
+				vec_kMapLocations.push_back(kMapLocation2);
+			}
+
+			if (tmp->GetChannel() == peer->GetChannel())
+			{
+				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
+				bMapCount = 1;
+				tmp->EncodeBYTE(bMapCount);
+				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
+			}
+		}
+	}
+
+	vec_kMapLocations.push_back(kMapLocations);
+
+	peer->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation) * vec_kMapLocations.size());
+	bMapCount = static_cast<BYTE>(vec_kMapLocations.size());
+	peer->EncodeBYTE(bMapCount);
+	peer->Encode(&vec_kMapLocations[0], sizeof(TMapLocation) * vec_kMapLocations.size());
+
+	//
+	// 쩐 :  퓸楮 摸 퓸 構 . (P2P 漫 )
+	//
+	sys_log(0, "SETUP: channel %u listen %u p2p %u count %u", peer->GetChannel(), p->wListenPort, p->wP2PPort, bMapCount);
+
+	TPacketDGP2P p2pSetupPacket;
+	p2pSetupPacket.wPort = peer->GetP2PPort();
+	p2pSetupPacket.bChannel = peer->GetChannel();
+	strlcpy(p2pSetupPacket.szHost, peer->GetPublicIP(), sizeof(p2pSetupPacket.szHost));
+
+	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* tmp = *i;
+
+		if (tmp == peer)
+			continue;
+
+		// 채 0繭  SETUP 킷   퓸 풔 auth   
+		if (0 == tmp->GetChannel())
+			continue;
+
+		tmp->EncodeHeader(HEADER_DG_P2P, 0, sizeof(TPacketDGP2P));
+		tmp->Encode(&p2pSetupPacket, sizeof(TPacketDGP2P));
+	}
+
+	//
+	// 慣   
+	//
+	TPacketLoginOnSetup* pck = (TPacketLoginOnSetup*)c_pData;
+
+	for (DWORD c = 0; c < p->dwLoginCount; ++c, ++pck)
+	{
+		CLoginData* pkLD = new CLoginData;
+
+		pkLD->SetKey(pck->dwLoginKey);
+		pkLD->SetClientKey(pck->adwClientKey);
+		pkLD->SetIP(pck->szHost);
+
+		TAccountTable& r = pkLD->GetAccountRef();
+
+		r.id = pck->dwID;
+		trim_and_lower(pck->szLogin, r.login, sizeof(r.login));
+		strlcpy(r.social_id, pck->szSocialID, sizeof(r.social_id));
+		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		strlcpy(r.country, pck->szCountry, sizeof(r.country));
+#endif
+
+		InsertLoginData(pkLD);
+
+		if (InsertLogonAccount(pck->szLogin, peer->GetHandle(), pck->szHost))
+		{
+			sys_log(0, "SETUP: login %u %s login_key %u host %s", pck->dwID, pck->szLogin, pck->dwLoginKey, pck->szHost);
+			pkLD->SetPlay(true);
+		}
+		else
+			sys_log(0, "SETUP: login_fail %u %s login_key %u", pck->dwID, pck->szLogin, pck->dwLoginKey);
+	}
+
+	SendPartyOnSetup(peer);
+
+	CGuildManager::instance().OnSetup(peer);
+	CPrivManager::instance().SendPrivOnSetup(peer);
+
+	SendEventFlagsOnSetup(peer);
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	SendGuildEventFlagsOnSetup(peer);
+#endif
+
+	marriage::CManager::instance().OnSetup(peer);
+}
+
+void CClientManager::QUERY_ITEM_FLUSH(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwID = *(DWORD*)c_pData;
+
+	if (g_log)
+		sys_log(0, "HEADER_GD_ITEM_FLUSH: %u", dwID);
+
+	CItemCache* c = GetItemCache(dwID);
+
+	if (c)
+		c->Flush();
+}
+
+void CClientManager::QUERY_ITEM_SAVE(CPeer* pkPeer, const char* c_pData)
+{
+	TPlayerItem* p = (TPlayerItem*)c_pData;
+
+	// 창 캐 歌, 캐 獵 孤  磯.
+
+	if (p->bWindow == SAFEBOX || p->bWindow == MALL
+	)
+	{
+		CItemCache* c = GetItemCache(p->dwID);
+
+		if (c)
+		{
+			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
+
+			if (it != m_map_pkItemCacheSetPtr.end())
+			{
+				if (g_test_server)
+					sys_log(0, "ITEM_CACHE: safebox owner %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+
+				it->second->erase(c);
+			}
+
+			m_map_itemCache.erase(p->dwID);
+
+			delete c;
+		}
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"REPLACE INTO `item%s` (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
+#if defined(__SOUL_BIND_SYSTEM__)
+			", `soulbind`"
+#endif
+			", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+			", `socket3`, `socket4`, `socket5`"
+#endif
+			", `attrtype0`, `attrvalue0`"
+			", `attrtype1`, `attrvalue1`"
+			", `attrtype2`, `attrvalue2`"
+			", `attrtype3`, `attrvalue3`"
+			", `attrtype4`, `attrvalue4`"
+			", `attrtype5`, `attrvalue5`"
+			", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			", `transmutation`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			", `refine_element_apply_type`"
+			", `refine_element_grade`"
+			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			", `apply_type0`, `apply_value0`, `apply_path0`"
+			", `apply_type1`, `apply_value1`, `apply_path1`"
+			", `apply_type2`, `apply_value2`, `apply_path2`"
+			", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+			", `set_value`"
+#endif
+			") VALUES(%u, %u, %u, %u, %u, %u"
+#if defined(__SOUL_BIND_SYSTEM__)
+			", %ld"
+#endif
+			", %ld, %ld, %ld"
+#if defined(__ITEM_SOCKET6__)
+			", %ld, %ld, %ld"
+#endif
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			", %u"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			", %u"
+			", %u"
+			", %u, %u, %u"
+			", %u, %u, %u"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			", %u, %ld, %u"
+			", %u, %ld, %u"
+			", %u, %ld, %u"
+			", %u, %ld, %u"
+#endif
+#if defined(__SET_ITEM__)
+			", %u"
+#endif
+			")", GetTablePostfix()
+			, p->dwID
+			, p->dwOwner
+			, p->bWindow
+			, p->wPos
+			, p->dwVnum
+			, p->dwCount
+#if defined(__SOUL_BIND_SYSTEM__)
+			, p->lSealDate
+#endif
+			, p->alSockets[0], p->alSockets[1], p->alSockets[2]
+#if defined(__ITEM_SOCKET6__)
+			, p->alSockets[3], p->alSockets[4], p->alSockets[5]
+#endif
+			, p->aAttr[0].wType, p->aAttr[0].lValue
+			, p->aAttr[1].wType, p->aAttr[1].lValue
+			, p->aAttr[2].wType, p->aAttr[2].lValue
+			, p->aAttr[3].wType, p->aAttr[3].lValue
+			, p->aAttr[4].wType, p->aAttr[4].lValue
+			, p->aAttr[5].wType, p->aAttr[5].lValue
+			, p->aAttr[6].wType, p->aAttr[6].lValue
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			, p->dwTransmutationVnum
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			, p->RefineElement.wApplyType
+			, p->RefineElement.bGrade
+			, p->RefineElement.abValue[0], p->RefineElement.abValue[1], p->RefineElement.abValue[2]
+			, p->RefineElement.abBonusValue[0], p->RefineElement.abBonusValue[1], p->RefineElement.abBonusValue[2]
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			, p->aApplyRandom[0].wType, p->aApplyRandom[0].lValue, p->aApplyRandom[0].bPath
+			, p->aApplyRandom[1].wType, p->aApplyRandom[1].lValue, p->aApplyRandom[1].bPath
+			, p->aApplyRandom[2].wType, p->aApplyRandom[2].lValue, p->aApplyRandom[2].bPath
+			, p->aApplyRandom[3].wType, p->aApplyRandom[3].lValue, p->aApplyRandom[3].bPath
+#endif
+#if defined(__SET_ITEM__)
+			, p->bSetValue
+#endif
+		);
+
+		CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_SAVE, pkPeer->GetHandle(), NULL);
+	}
+	else
+	{
+		if (g_test_server)
+			sys_log(0, "QUERY_ITEM_SAVE => PutItemCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
+
+		PutItemCache(p);
+	}
+}
+
+CClientManager::TItemCacheSet* CClientManager::GetItemCacheSet(DWORD pid)
+{
+	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
+
+	if (it == m_map_pkItemCacheSetPtr.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::CreateItemCacheSet(DWORD pid)
+{
+	if (m_map_pkItemCacheSetPtr.find(pid) != m_map_pkItemCacheSetPtr.end())
+		return;
+
+	TItemCacheSet* pSet = new TItemCacheSet;
+	m_map_pkItemCacheSetPtr.insert(TItemCacheSetPtrMap::value_type(pid, pSet));
+
+	if (g_log)
+		sys_log(0, "ITEM_CACHE: new cache %u", pid);
+}
+
+void CClientManager::FlushItemCacheSet(DWORD pid)
+{
+	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
+
+	if (it == m_map_pkItemCacheSetPtr.end())
+	{
+		sys_log(0, "FLUSH_ITEMCACHESET : No ItemCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TItemCacheSet* pSet = it->second;
+	TItemCacheSet::iterator it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CItemCache* c = *it_set++;
+		c->Flush();
+
+		m_map_itemCache.erase(c->Get()->dwID);
+		delete c;
+	}
+
+	pSet->clear();
+	delete pSet;
+
+	m_map_pkItemCacheSetPtr.erase(it);
+
+	if (g_log)
+		sys_log(0, "FLUSH_ITEMCACHESET : Deleted pid(%d)", pid);
+}
+
+CItemCache* CClientManager::GetItemCache(DWORD id)
+{
+	TItemCacheMap::iterator it = m_map_itemCache.find(id);
+
+	if (it == m_map_itemCache.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::PutItemCache(TPlayerItem* pNew, bool bSkipQuery)
+{
+	CItemCache* c;
+
+	c = GetItemCache(pNew->dwID);
+
+	//   
+	if (!c)
+	{
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: PutItemCache ==> New CItemCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
+
+		c = new CItemCache;
+		m_map_itemCache.insert(TItemCacheMap::value_type(pNew->dwID, c));
+	}
+	// 
+	else
+	{
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: PutItemCache ==> Have Cache");
+
+		// 微 틀
+		if (pNew->dwOwner != c->Get()->dwOwner)
+		{
+			// 譴    羚    磯.
+			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
+
+			if (it != m_map_pkItemCacheSetPtr.end())
+			{
+				if (g_log)
+					sys_log(0, "ITEM_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
+				it->second->erase(c);
+			}
+		}
+	}
+
+	// 恝  트
+	c->Put(pNew, bSkipQuery);
+
+	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
+
+	if (it != m_map_pkItemCacheSetPtr.end())
+	{
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		it->second->insert(c);
+	}
+	else
+	{
+		//  微 퓐 慕 瞞     SQL 臼
+		//   퓐 慕 磯.
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+
+		c->OnFlush();
+	}
+}
+
+bool CClientManager::DeleteItemCache(DWORD dwID)
+{
+	CItemCache* c = GetItemCache(dwID);
+
+	if (!c)
+		return false;
+
+	c->Delete();
+	return true;
+}
+
+// MYSHOP_PRICE_LIST
+CItemPriceListTableCache* CClientManager::GetItemPriceListCache(DWORD dwID)
+{
+	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.find(dwID);
+
+	if (it == m_mapItemPriceListCache.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::PutItemPriceListCache(const TItemPriceListTable* pItemPriceList)
+{
+	CItemPriceListTableCache* pCache = GetItemPriceListCache(pItemPriceList->dwOwnerID);
+
+	if (!pCache)
+	{
+		pCache = new CItemPriceListTableCache;
+		m_mapItemPriceListCache.insert(TItemPriceListCacheMap::value_type(pItemPriceList->dwOwnerID, pCache));
+	}
+
+	pCache->Put(const_cast<TItemPriceListTable*>(pItemPriceList), true);
+}
+
+void CClientManager::UpdatePlayerCache()
+{
+	TPlayerTableCacheMap::iterator it = m_map_playerCache.begin();
+
+	while (it != m_map_playerCache.end())
+	{
+		CPlayerTableCache* c = (it++)->second;
+
+		if (c->CheckTimeout())
+		{
+			if (g_log)
+				sys_log(0, "UPDATE : UpdatePlayerCache() ==> FlushPlayerCache %d %s ", c->Get(false)->id, c->Get(false)->name);
+
+			c->Flush();
+
+			// Item Cache 트
+			UpdateItemCacheSet(c->Get()->id);
+#ifdef __GROWTH_PET_SYSTEM__
+		tmp->EncodeWORD(m_vec_growthPetSkillTable.size());
+		if (m_vec_growthPetSkillTable.size())
+			tmp->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
+#endif
+		}
+		else if (c->CheckFlushTimeout())
+			c->Flush();
+	}
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+void CClientManager::SetCacheFlushCountLimit(int iLimit)
+{
+	m_iCacheFlushCountLimit = MAX(10, iLimit);
+	sys_log(0, "CACHE_FLUSH_LIMIT_PER_SECOND: %d", m_iCacheFlushCountLimit);
+}
+
+void CClientManager::UpdateItemCache()
+{
+	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+		return;
+
+	TItemCacheMap::iterator it = m_map_itemCache.begin();
+
+	while (it != m_map_itemCache.end())
+	{
+		CItemCache* c = (it++)->second;
+
+		//  Flush 磯.
+		if (c->CheckFlushTimeout())
+		{
+			if (g_test_server)
+				sys_log(0, "UpdateItemCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
+
+			c->Flush();
+
+			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+				break;
+		}
+	}
+}
+
+void CClientManager::UpdateItemPriceListCache()
+{
+	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.begin();
+
+	while (it != m_mapItemPriceListCache.end())
+	{
+		CItemPriceListTableCache* pCache = it->second;
+
+		if (pCache->CheckFlushTimeout())
+		{
+			pCache->Flush();
+			m_mapItemPriceListCache.erase(it++);
+		}
+		else
+			++it;
+	}
+}
+
+void CClientManager::QUERY_ITEM_DESTROY(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwID = *(DWORD*)c_pData;
+	c_pData += sizeof(DWORD);
+
+	DWORD dwPID = *(DWORD*)c_pData;
+
+	if (!DeleteItemCache(dwID))
+	{
+		char szQuery[64];
+		snprintf(szQuery, sizeof(szQuery), "DELETE FROM item%s WHERE `id` = %u", GetTablePostfix(), dwID);
+
+		if (g_log)
+			sys_log(0, "HEADER_GD_ITEM_DESTROY: PID %u ID %u", dwPID, dwID);
+
+		if (dwPID == 0) // 틜   摸, 宙엽 
+			CDBManager::instance().AsyncQuery(szQuery);
+		else
+			CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_DESTROY, pkPeer->GetHandle(), NULL);
+	}
+}
+
+void CClientManager::QUERY_FLUSH_CACHE(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwPID = *(DWORD*)c_pData;
+
+	CPlayerTableCache* pkCache = GetPlayerCache(dwPID);
+
+	if (!pkCache)
+		return;
+
+	sys_log(0, "FLUSH_CACHE: %u", dwPID);
+
+	pkCache->Flush();
+	FlushItemCacheSet(dwPID);
+#ifdef __GROWTH_PET_SYSTEM__
+		case HEADER_GD_GROWTH_PET_SAVE:
+			QUERY_GROWTH_PET_SAVE(peer, data);
+			break;
+
+		case HEADER_GD_GROWTH_PET_DELETE:
+			QUERY_GROWTH_PET_DELETE(peer, data);
+			break;
+#endif
+	m_map_playerCache.erase(dwPID);
+	delete pkCache;
+}
+
+void CClientManager::QUERY_RELOAD_PROTO()
+{
+	if (!InitializeTables())
+	{
+		sys_err("QUERY_RELOAD_PROTO: cannot load tables");
+		return;
+	}
+
+	for (TPeerList::iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* tmp = *i;
+
+		if (!tmp->GetChannel())
+			continue;
+
+		tmp->EncodeHeader(HEADER_DG_RELOAD_PROTO, 0,
+			sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
+			sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
+			sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
+			sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
+			sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize
+#ifdef __GROWTH_PET_SYSTEM__
+	case QID_GROWTH_PET:
+#endif
+		);
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
+		tmp->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
+		tmp->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
+		tmp->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
+		tmp->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_iRefineTableSize));
+		tmp->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
+
+#ifdef __GROWTH_PET_SYSTEM__
+	case QID_GROWTH_PET_SAVE:
+	case QID_GROWTH_PET_DELETE:
+#endif
+	}
+}
+
+// ADD_GUILD_PRIV_TIME
+/**
+* @version 05/06/08 Bang2ni - 擔챨 煞
+**/
+void CClientManager::AddGuildPriv(TPacketGiveGuildPriv* p)
+{
+	CPrivManager::instance().AddGuildPriv(p->guild_id, p->type, p->value, p->duration_sec);
+}
+
+void CClientManager::AddEmpirePriv(TPacketGiveEmpirePriv* p)
+{
+	CPrivManager::instance().AddEmpirePriv(p->empire, p->type, p->value, p->duration_sec);
+}
+// END_OF_ADD_GUILD_PRIV_TIME
+
+void CClientManager::AddCharacterPriv(TPacketGiveCharacterPriv* p)
+{
+	CPrivManager::instance().AddCharPriv(p->pid, p->type, p->value);
+}
+
+void CClientManager::MoneyLog(TPacketMoneyLog* p)
+{
+	CMoneyLog::instance().AddLog(p->type, p->vnum, p->gold
+#if defined(__CHEQUE_SYSTEM__)
+		, p->cheque
+#endif
+	);
+}
+
+CLoginData* CClientManager::GetLoginData(DWORD dwKey)
+{
+	TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(dwKey);
+
+	if (it == m_map_pkLoginData.end())
+		return NULL;
+
+	return it->second;
+}
+
+CLoginData* CClientManager::GetLoginDataByLogin(const char* c_pszLogin)
+{
+	char szLogin[LOGIN_MAX_LEN + 1];
+	trim_and_lower(c_pszLogin, szLogin, sizeof(szLogin));
+
+	TLoginDataByLogin::iterator it = m_map_pkLoginDataByLogin.find(szLogin);
+
+	if (it == m_map_pkLoginDataByLogin.end())
+		return NULL;
+
+	return it->second;
+}
+
+CLoginData* CClientManager::GetLoginDataByAID(DWORD dwAID)
+{
+	TLoginDataByAID::iterator it = m_map_pkLoginDataByAID.find(dwAID);
+
+	if (it == m_map_pkLoginDataByAID.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::InsertLoginData(CLoginData* pkLD)
+{
+	char szLogin[LOGIN_MAX_LEN + 1];
+	trim_and_lower(pkLD->GetAccountRef().login, szLogin, sizeof(szLogin));
+
+	m_map_pkLoginData.insert(std::make_pair(pkLD->GetKey(), pkLD));
+	m_map_pkLoginDataByLogin.insert(std::make_pair(szLogin, pkLD));
+	m_map_pkLoginDataByAID.insert(std::make_pair(pkLD->GetAccountRef().id, pkLD));
+}
+
+void CClientManager::DeleteLoginData(CLoginData* pkLD)
+{
+	m_map_pkLoginData.erase(pkLD->GetKey());
+	m_map_pkLoginDataByLogin.erase(pkLD->GetAccountRef().login);
+	m_map_pkLoginDataByAID.erase(pkLD->GetAccountRef().id);
+
+	if (m_map_kLogonAccount.find(pkLD->GetAccountRef().login) == m_map_kLogonAccount.end())
+		delete pkLD;
+	else
+		pkLD->SetDeleted(true);
+}
+
+void CClientManager::QUERY_AUTH_LOGIN(CPeer* pkPeer, DWORD dwHandle, TPacketGDAuthLogin* p)
+{
+	if (g_test_server)
+		sys_log(0, "QUERY_AUTH_LOGIN %d %d %s", p->dwID, p->dwLoginKey, p->szLogin);
+
+	CLoginData* pkLD = GetLoginDataByLogin(p->szLogin);
+
+	if (pkLD)
+	{
+		DeleteLoginData(pkLD);
+	}
+
+	BYTE bResult;
+
+	if (GetLoginData(p->dwLoginKey))
+	{
+		sys_err("LoginData already exist key %u login %s", p->dwLoginKey, p->szLogin);
+		bResult = 0;
+
+		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
+		pkPeer->EncodeBYTE(bResult);
+	}
+	else
+	{
+		CLoginData* pkLD = new CLoginData;
+
+		pkLD->SetKey(p->dwLoginKey);
+		pkLD->SetClientKey(p->adwClientKey);
+		pkLD->SetPremium(p->iPremiumTimes);
+
+		TAccountTable& r = pkLD->GetAccountRef();
+
+		r.id = p->dwID;
+		trim_and_lower(p->szLogin, r.login, sizeof(r.login));
+		strlcpy(r.social_id, p->szSocialID, sizeof(r.social_id));
+		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		strlcpy(r.country, p->szCountry, sizeof(r.country));
+#endif
+
+		sys_log(0, "AUTH_LOGIN id(%u) login(%s)"
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			" country(%s)"
+#endif
+			" social_id(%s) login_key(%u), client_key(%u %u %u %u)",
+			p->dwID,
+			p->szLogin,
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			p->szCountry,
+#endif
+			p->szSocialID,
+			p->dwLoginKey,
+			p->adwClientKey[0], p->adwClientKey[1], p->adwClientKey[2], p->adwClientKey[3]
+		);
+
+		bResult = 1;
+
+		InsertLoginData(pkLD);
+
+		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
+		pkPeer->EncodeBYTE(bResult);
+	}
+}
+
+void CClientManager::GuildDepositMoney(TPacketGDGuildMoney* p)
+{
+	CGuildManager::instance().DepositMoney(p->dwGuild, p->iGold);
+}
+
+void CClientManager::GuildWithdrawMoney(CPeer* peer, TPacketGDGuildMoney* p)
+{
+	CGuildManager::instance().WithdrawMoney(peer, p->dwGuild, p->iGold);
+}
+
+void CClientManager::GuildWithdrawMoneyGiveReply(TPacketGDGuildMoneyWithdrawGiveReply* p)
+{
+	CGuildManager::instance().WithdrawMoneyReply(p->dwGuild, p->bGiveSuccess, p->iChangeGold);
+}
+
+void CClientManager::GuildWarBet(TPacketGDGuildWarBet* p)
+{
+	CGuildManager::instance().Bet(p->dwWarID, p->szLogin, p->dwGold, p->dwGuild);
+}
+
+void CClientManager::CreateObject(TPacketGDCreateObject* p)
+{
+	using namespace building;
+
+	char szQuery[512];
+
+	snprintf(szQuery, sizeof(szQuery),
+		"INSERT INTO object%s (`land_id`, `vnum`, `map_index`, `x`, `y`, `x_rot`, `y_rot`, `z_rot`) VALUES(%u, %u, %d, %d, %d, %f, %f, %f)",
+		GetTablePostfix(), p->dwLandID, p->dwVnum, p->lMapIndex, p->x, p->y, p->xRot, p->yRot, p->zRot);
+
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+	if (pmsg->Get()->uiInsertID == 0)
+	{
+		sys_err("cannot insert object");
+		return;
+	}
+
+	TObject* pkObj = new TObject;
+
+	memset(pkObj, 0, sizeof(TObject));
+
+	pkObj->dwID = pmsg->Get()->uiInsertID;
+	pkObj->dwVnum = p->dwVnum;
+	pkObj->dwLandID = p->dwLandID;
+	pkObj->lMapIndex = p->lMapIndex;
+	pkObj->x = p->x;
+	pkObj->y = p->y;
+	pkObj->xRot = p->xRot;
+	pkObj->yRot = p->yRot;
+	pkObj->zRot = p->zRot;
+	pkObj->lLife = 0;
+
+	ForwardPacket(HEADER_DG_CREATE_OBJECT, pkObj, sizeof(TObject));
+
+	m_map_pkObjectTable.insert(std::make_pair(pkObj->dwID, pkObj));
+}
+
+void CClientManager::DeleteObject(DWORD dwID)
+{
+	char szQuery[128];
+
+	snprintf(szQuery, sizeof(szQuery), "DELETE FROM object%s WHERE `id` = %u", GetTablePostfix(), dwID);
+
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
+	{
+		sys_err("no object by id %u", dwID);
+		return;
+	}
+
+	//pkObjectTableMap::const_iterator it = m_map_pkObjectTable.find(dwID);
+	auto it = m_map_pkObjectTable.find(dwID);
+	if (it != m_map_pkObjectTable.end())
+	{
+		delete it->second;
+		m_map_pkObjectTable.erase(it);
+	}
+
+	ForwardPacket(HEADER_DG_DELETE_OBJECT, &dwID, sizeof(DWORD));
+}
+
+void CClientManager::UpdateLand(DWORD* pdw)
+{
+	DWORD dwID = pdw[0];
+	DWORD dwGuild = pdw[1];
+
+	building::TLand* p = &m_vec_kLandTable[0];
+
+	DWORD i;
+
+	for (i = 0; i < m_vec_kLandTable.size(); ++i, ++p)
+	{
+		if (p->dwID == dwID)
+		{
+			char buf[256];
+			snprintf(buf, sizeof(buf), "UPDATE land%s SET `guild_id` = %u WHERE `id` = %u", GetTablePostfix(), dwGuild, dwID);
+			CDBManager::instance().AsyncQuery(buf);
+
+			p->dwGuildID = dwGuild;
+			break;
+		}
+	}
+
+	if (i < m_vec_kLandTable.size())
+		ForwardPacket(HEADER_DG_UPDATE_LAND, p, sizeof(building::TLand));
+}
+
+// BLOCK_CHAT
+void CClientManager::BlockChat(TPacketBlockChat* p)
+{
+	char szQuery[256];
+
+	if (g_stLocale == "sjis")
+		snprintf(szQuery, sizeof(szQuery), "SELECT `id `FROM player%s WHERE `name` = '%s' COLLATE sjis_japanese_ci", GetTablePostfix(), p->szName);
+	else
+		snprintf(szQuery, sizeof(szQuery), "SELECT `id` FROM player%s WHERE `name` = '%s'", GetTablePostfix(), p->szName);
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+	SQLResult* pRes = pmsg->Get();
+
+	if (pRes->uiNumRows)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
+		DWORD pid = strtoul(row[0], NULL, 10);
+
+		TPacketGDAddAffect pa;
+		pa.dwPID = pid;
+		pa.elem.dwType = 223;
+		pa.elem.wApplyOn = 0;
+		pa.elem.lApplyValue = 0;
+		pa.elem.dwFlag = 0;
+		pa.elem.lDuration = p->lDuration;
+		pa.elem.lSPCost = 0;
+		QUERY_ADD_AFFECT(NULL, &pa);
+	}
+	else
+	{
+		// cannot find user with that name
+	}
+}
+// END_OF_BLOCK_CHAT
+
+void CClientManager::MarriageAdd(TPacketMarriageAdd* p)
+{
+	sys_log(0, "MarriageAdd %u %u %s %s", p->dwPID1, p->dwPID2, p->szName1, p->szName2);
+	marriage::CManager::instance().Add(p->dwPID1, p->dwPID2, p->szName1, p->szName2);
+}
+
+void CClientManager::MarriageUpdate(TPacketMarriageUpdate* p)
+{
+	sys_log(0, "MarriageUpdate PID:%u %u LP:%d ST:%d", p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
+	marriage::CManager::instance().Update(p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
+}
+
+void CClientManager::MarriageRemove(TPacketMarriageRemove* p)
+{
+	sys_log(0, "MarriageRemove %u %u", p->dwPID1, p->dwPID2);
+	marriage::CManager::instance().Remove(p->dwPID1, p->dwPID2);
+}
+
+void CClientManager::WeddingRequest(TPacketWeddingRequest* p)
+{
+	sys_log(0, "WeddingRequest %u %u", p->dwPID1, p->dwPID2);
+	ForwardPacket(HEADER_DG_WEDDING_REQUEST, p, sizeof(TPacketWeddingRequest));
+	//marriage::CManager::instance().RegisterWedding(p->dwPID1, p->szName1, p->dwPID2, p->szName2);
+}
+
+void CClientManager::WeddingReady(TPacketWeddingReady* p)
+{
+	sys_log(0, "WeddingReady %u %u", p->dwPID1, p->dwPID2);
+	ForwardPacket(HEADER_DG_WEDDING_READY, p, sizeof(TPacketWeddingReady));
+	marriage::CManager::instance().ReadyWedding(p->dwMapIndex, p->dwPID1, p->dwPID2);
+}
+
+void CClientManager::WeddingEnd(TPacketWeddingEnd* p)
+{
+	sys_log(0, "WeddingEnd %u %u", p->dwPID1, p->dwPID2);
+	marriage::CManager::instance().EndWedding(p->dwPID1, p->dwPID2);
+}
+
+//
+// 캐첼   캐첩 트 構 캐첼  摸
+// 耳  拷 琯 悶   캐첩     트 磯.
+//
+void CClientManager::MyshopPricelistUpdate(const TItemPriceListTable* pPacket)
+{
+	if (pPacket->byCount > SHOP_PRICELIST_MAX_NUM)
+	{
+		sys_err("count overflow!");
+		return;
+	}
+
+	CItemPriceListTableCache* pCache = GetItemPriceListCache(pPacket->dwOwnerID);
+
+	if (pCache)
+	{
+		TItemPriceListTable table;
+
+		table.dwOwnerID = pPacket->dwOwnerID;
+		table.byCount = pPacket->byCount;
+
+		thecore_memcpy(table.aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
+
+		pCache->UpdateList(&table);
+	}
+	else
+	{
+		TItemPriceListTable* pUpdateTable = new TItemPriceListTable;
+
+		pUpdateTable->dwOwnerID = pPacket->dwOwnerID;
+		pUpdateTable->byCount = pPacket->byCount;
+
+		thecore_memcpy(pUpdateTable->aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `item_vnum`, `price`"
+#if defined(__CHEQUE_SYSTEM__)
+			", `cheque`"
+#endif
+			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), pPacket->dwOwnerID);
+		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD_FOR_UPDATE, 0, pUpdateTable);
+	}
+}
+
+// MYSHOP_PRICE_LIST
+// 캐천   캐첩 棘 慕 構 캐첼   DB   磯.
+//
+void CClientManager::MyshopPricelistRequest(CPeer* peer, DWORD dwHandle, DWORD dwPlayerID)
+{
+	if (CItemPriceListTableCache* pCache = GetItemPriceListCache(dwPlayerID))
+	{
+		sys_log(0, "Cache MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
+
+		TItemPriceListTable* pTable = pCache->Get(false);
+
+		TPacketMyshopPricelistHeader header =
+		{
+			pTable->dwOwnerID,
+			pTable->byCount
+		};
+
+		size_t sizePriceListSize = sizeof(TItemPriceInfo) * pTable->byCount;
+
+		peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, dwHandle, sizeof(header) + sizePriceListSize);
+		peer->Encode(&header, sizeof(header));
+		peer->Encode(pTable->aPriceInfo, sizePriceListSize);
+	}
+	else
+	{
+		sys_log(0, "Query MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `item_vnum`, `price`"
+#if defined(__CHEQUE_SYSTEM__)
+			", `cheque`"
+#endif
+			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), dwPlayerID);
+		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD, peer->GetHandle(), new TItemPricelistReqInfo(dwHandle, dwPlayerID));
+	}
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+void CPacketInfo::Add(int header)
+{
+	auto it = m_map_info.find(header);
+	if (it == m_map_info.end())
+		m_map_info.insert(std::map<int, int>::value_type(header, 1));
+	else
+		++it->second;
+}
+
+void CPacketInfo::Reset()
+{
+	m_map_info.clear();
+}
+
+void CClientManager::ProcessPackets(CPeer* peer)
+{
+	BYTE header;
+	DWORD dwHandle;
+	DWORD dwLength;
+	const char* data = NULL;
+	int i = 0;
+	int iCount = 0;
+
+	while (peer->PeekPacket(i, header, dwHandle, dwLength, &data))
+	{
+		// DISABLE_DB_HEADER_LOG
+		// sys_log(0, "header %d %p size %d", header, this, dwLength);
+		// END_OF_DISABLE_DB_HEADER_LOG
+		m_bLastHeader = header;
+		++iCount;
+
+#if defined(_DEBUG)
+		if (header != 10)
+			sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
+#endif
+
+		if (g_test_server)
+		{
+			if (header != 10)
+				sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
+		}
+
+		// test log by mhh
+		{
+			if (HEADER_GD_BLOCK_COUNTRY_IP == header)
+				sys_log(0, "recved : HEADER_GD_BLOCK_COUNTRY_IP");
+		}
+
+		switch (header)
+		{
+			case HEADER_GD_BOOT:
+				QUERY_BOOT(peer, (TPacketGDBoot*)data);
+				break;
+
+			case HEADER_GD_HAMMER_OF_TOR:
+				break;
+
+			case HEADER_GD_LOGIN_BY_KEY:
+				QUERY_LOGIN_BY_KEY(peer, dwHandle, (TPacketGDLoginByKey*)data);
+				break;
+
+			case HEADER_GD_LOGOUT:
+				//sys_log(0, "HEADER_GD_LOGOUT (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_LOGOUT(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_PLAYER_LOAD:
+				sys_log(1, "HEADER_GD_PLAYER_LOAD (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_PLAYER_LOAD(peer, dwHandle, (TPlayerLoadPacket*)data);
+				break;
+
+			case HEADER_GD_PLAYER_SAVE:
+				sys_log(1, "HEADER_GD_PLAYER_SAVE (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_PLAYER_SAVE(peer, dwHandle, (TPlayerTable*)data);
+				break;
+
+			case HEADER_GD_PLAYER_CREATE:
+				sys_log(0, "HEADER_GD_PLAYER_CREATE (handle: %d length: %d)", dwHandle, dwLength);
+				__QUERY_PLAYER_CREATE(peer, dwHandle, (TPlayerCreatePacket*)data);
+				sys_log(0, "END");
+				break;
+
+			case HEADER_GD_PLAYER_DELETE:
+				sys_log(1, "HEADER_GD_PLAYER_DELETE (handle: %d length: %d)", dwHandle, dwLength);
+				__QUERY_PLAYER_DELETE(peer, dwHandle, (TPlayerDeletePacket*)data);
+				break;
+
+			case HEADER_GD_PLAYER_COUNT:
+				QUERY_PLAYER_COUNT(peer, (TPlayerCountPacket*)data);
+				break;
+
+			case HEADER_GD_QUEST_SAVE:
+				sys_log(1, "HEADER_GD_QUEST_SAVE (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_QUEST_SAVE(peer, (TQuestTable*)data, dwLength);
+				break;
+
+			case HEADER_GD_SAFEBOX_LOAD:
+				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 0);
+				break;
+
+			case HEADER_GD_SAFEBOX_SAVE:
+				sys_log(1, "HEADER_GD_SAFEBOX_SAVE (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_SAFEBOX_SAVE(peer, (TSafeboxTable*)data);
+				break;
+
+			case HEADER_GD_SAFEBOX_CHANGE_SIZE:
+				QUERY_SAFEBOX_CHANGE_SIZE(peer, dwHandle, (TSafeboxChangeSizePacket*)data);
+				break;
+
+			case HEADER_GD_SAFEBOX_CHANGE_PASSWORD:
+				QUERY_SAFEBOX_CHANGE_PASSWORD(peer, dwHandle, (TSafeboxChangePasswordPacket*)data);
+				break;
+
+			case HEADER_GD_MALL_LOAD:
+				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 1);
+				break;
+
+			case HEADER_GD_EMPIRE_SELECT:
+				QUERY_EMPIRE_SELECT(peer, dwHandle, (TEmpireSelectPacket*)data);
+				break;
+
+			case HEADER_GD_SETUP:
+				QUERY_SETUP(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_GUILD_CREATE:
+				GuildCreate(peer, *(DWORD*)data);
+				break;
+
+			case HEADER_GD_GUILD_SKILL_UPDATE:
+				GuildSkillUpdate(peer, (TPacketGuildSkillUpdate*)data);
+				break;
+
+			case HEADER_GD_GUILD_EXP_UPDATE:
+				GuildExpUpdate(peer, (TPacketGuildExpUpdate*)data);
+				break;
+
+			case HEADER_GD_GUILD_ADD_MEMBER:
+				GuildAddMember(peer, (TPacketGDGuildAddMember*)data);
+				break;
+
+			case HEADER_GD_GUILD_REMOVE_MEMBER:
+				GuildRemoveMember(peer, (TPacketGuild*)data);
+				break;
+
+			case HEADER_GD_GUILD_CHANGE_GRADE:
+				GuildChangeGrade(peer, (TPacketGuild*)data);
+				break;
+
+			case HEADER_GD_GUILD_CHANGE_MEMBER_DATA:
+				GuildChangeMemberData(peer, (TPacketGuildChangeMemberData*)data);
+				break;
+
+			case HEADER_GD_GUILD_DISBAND:
+				GuildDisband(peer, (TPacketGuild*)data);
+				break;
+
+			case HEADER_GD_GUILD_WAR:
+				GuildWar(peer, (TPacketGuildWar*)data);
+				break;
+
+			case HEADER_GD_GUILD_WAR_SCORE:
+				GuildWarScore(peer, (TPacketGuildWarScore*)data);
+				break;
+
+			case HEADER_GD_GUILD_CHANGE_LADDER_POINT:
+				GuildChangeLadderPoint((TPacketGuildLadderPoint*)data);
+				break;
+
+			case HEADER_GD_GUILD_USE_SKILL:
+				GuildUseSkill((TPacketGuildUseSkill*)data);
+				break;
+
+			case HEADER_GD_FLUSH_CACHE:
+				QUERY_FLUSH_CACHE(peer, data);
+				break;
+
+			case HEADER_GD_ITEM_SAVE:
+				QUERY_ITEM_SAVE(peer, data);
+				break;
+
+			case HEADER_GD_ITEM_DESTROY:
+				QUERY_ITEM_DESTROY(peer, data);
+				break;
+
+			case HEADER_GD_ITEM_FLUSH:
+				QUERY_ITEM_FLUSH(peer, data);
+				break;
+
+			case HEADER_GD_ADD_AFFECT:
+				sys_log(1, "HEADER_GD_ADD_AFFECT");
+				QUERY_ADD_AFFECT(peer, (TPacketGDAddAffect*)data);
+				break;
+
+			case HEADER_GD_REMOVE_AFFECT:
+				sys_log(1, "HEADER_GD_REMOVE_AFFECT");
+				QUERY_REMOVE_AFFECT(peer, (TPacketGDRemoveAffect*)data);
+				break;
+
+			case HEADER_GD_HIGHSCORE_REGISTER:
+				QUERY_HIGHSCORE_REGISTER(peer, (TPacketGDHighscore*)data);
+				break;
+
+			case HEADER_GD_PARTY_CREATE:
+				QUERY_PARTY_CREATE(peer, (TPacketPartyCreate*)data);
+				break;
+
+			case HEADER_GD_PARTY_DELETE:
+				QUERY_PARTY_DELETE(peer, (TPacketPartyDelete*)data);
+				break;
+
+			case HEADER_GD_PARTY_ADD:
+				QUERY_PARTY_ADD(peer, (TPacketPartyAdd*)data);
+				break;
+
+			case HEADER_GD_PARTY_REMOVE:
+				QUERY_PARTY_REMOVE(peer, (TPacketPartyRemove*)data);
+				break;
+
+			case HEADER_GD_PARTY_STATE_CHANGE:
+				QUERY_PARTY_STATE_CHANGE(peer, (TPacketPartyStateChange*)data);
+				break;
+
+			case HEADER_GD_PARTY_SET_MEMBER_LEVEL:
+				QUERY_PARTY_SET_MEMBER_LEVEL(peer, (TPacketPartySetMemberLevel*)data);
+				break;
+
+			case HEADER_GD_RELOAD_PROTO:
+				QUERY_RELOAD_PROTO();
+				break;
+
+			case HEADER_GD_CHANGE_NAME:
+				QUERY_CHANGE_NAME(peer, dwHandle, (TPacketGDChangeName*)data);
+				break;
+
+			case HEADER_GD_AUTH_LOGIN:
+				QUERY_AUTH_LOGIN(peer, dwHandle, (TPacketGDAuthLogin*)data);
+				break;
+
+			case HEADER_GD_REQUEST_GUILD_PRIV:
+				AddGuildPriv((TPacketGiveGuildPriv*)data);
+				break;
+
+			case HEADER_GD_REQUEST_EMPIRE_PRIV:
+				AddEmpirePriv((TPacketGiveEmpirePriv*)data);
+				break;
+
+			case HEADER_GD_REQUEST_CHARACTER_PRIV:
+				AddCharacterPriv((TPacketGiveCharacterPriv*)data);
+				break;
+
+			case HEADER_GD_MONEY_LOG:
+				MoneyLog((TPacketMoneyLog*)data);
+				break;
+
+			case HEADER_GD_GUILD_DEPOSIT_MONEY:
+				GuildDepositMoney((TPacketGDGuildMoney*)data);
+				break;
+
+			case HEADER_GD_GUILD_WITHDRAW_MONEY:
+				GuildWithdrawMoney(peer, (TPacketGDGuildMoney*)data);
+				break;
+
+			case HEADER_GD_GUILD_WITHDRAW_MONEY_GIVE_REPLY:
+				GuildWithdrawMoneyGiveReply((TPacketGDGuildMoneyWithdrawGiveReply*)data);
+				break;
+
+			case HEADER_GD_GUILD_WAR_BET:
+				GuildWarBet((TPacketGDGuildWarBet*)data);
+				break;
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+			case HEADER_GD_GUILD_EVENT_FLAG:
+				GuildSetEventFlag((TPacketSetGuildEventFlag*)data);
+				break;
+#endif
+
+			case HEADER_GD_SET_EVENT_FLAG:
+				SetEventFlag((TPacketSetEventFlag*)data);
+				break;
+
+			case HEADER_GD_CREATE_OBJECT:
+				CreateObject((TPacketGDCreateObject*)data);
+				break;
+
+			case HEADER_GD_DELETE_OBJECT:
+				DeleteObject(*(DWORD*)data);
+				break;
+
+			case HEADER_GD_UPDATE_LAND:
+				UpdateLand((DWORD*)data);
+				break;
+
+			case HEADER_GD_MARRIAGE_ADD:
+				MarriageAdd((TPacketMarriageAdd*)data);
+				break;
+
+			case HEADER_GD_MARRIAGE_UPDATE:
+				MarriageUpdate((TPacketMarriageUpdate*)data);
+				break;
+
+			case HEADER_GD_MARRIAGE_REMOVE:
+				MarriageRemove((TPacketMarriageRemove*)data);
+				break;
+
+			case HEADER_GD_WEDDING_REQUEST:
+				WeddingRequest((TPacketWeddingRequest*)data);
+				break;
+
+			case HEADER_GD_WEDDING_READY:
+				WeddingReady((TPacketWeddingReady*)data);
+				break;
+
+			case HEADER_GD_WEDDING_END:
+				WeddingEnd((TPacketWeddingEnd*)data);
+				break;
+
+				// BLOCK_CHAT
+			case HEADER_GD_BLOCK_CHAT:
+				BlockChat((TPacketBlockChat*)data);
+				break;
+				// END_OF_BLOCK_CHAT
+
+				// MYSHOP_PRICE_LIST
+			case HEADER_GD_MYSHOP_PRICELIST_UPDATE:
+				MyshopPricelistUpdate((TItemPriceListTable*)data);
+				break;
+
+			case HEADER_GD_MYSHOP_PRICELIST_REQ:
+				MyshopPricelistRequest(peer, dwHandle, *(DWORD*)data);
+				break;
+				// END_OF_MYSHOP_PRICE_LIST
+
+				// RELOAD_ADMIN
+			case HEADER_GD_RELOAD_ADMIN:
+				ReloadAdmin(peer, (TPacketReloadAdmin*)data);
+				break;
+				// END_RELOAD_ADMIN
+
+			case HEADER_GD_BREAK_MARRIAGE:
+				BreakMarriage(peer, data);
+				break;
+
+				// MOANRCH
+			case HEADER_GD_ELECT_MONARCH:
+				Election(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_CANDIDACY:
+				Candidacy(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_ADD_MONARCH_MONEY:
+				AddMonarchMoney(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_DEC_MONARCH_MONEY:
+				DecMonarchMoney(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_TAKE_MONARCH_MONEY:
+				TakeMonarchMoney(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_COME_TO_VOTE:
+				ComeToVote(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_RMCANDIDACY: ///< 캤  (楮)
+				RMCandidacy(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_SETMONARCH: ///< 玲 (楮)
+				SetMonarch(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_RMMONARCH: ///< 怜
+				RMMonarch(peer, dwHandle, data);
+				break;
+				// END_MONARCH
+
+			case HEADER_GD_CHANGE_MONARCH_LORD:
+				ChangeMonarchLord(peer, dwHandle, (TPacketChangeMonarchLord*)data);
+				break;
+
+			case HEADER_GD_BLOCK_COUNTRY_IP:
+				sys_log(0, "HEADER_GD_BLOCK_COUNTRY_IP received");
+				CBlockCountry::instance().SendBlockedCountryIp(peer);
+				CBlockCountry::instance().SendBlockException(peer);
+				break;
+
+			case HEADER_GD_BLOCK_EXCEPTION:
+				sys_log(0, "HEADER_GD_BLOCK_EXCEPTION received");
+				BlockException((TPacketBlockException*)data);
+				break;
+
+			case HEADER_GD_REQ_SPARE_ITEM_ID_RANGE:
+				SendSpareItemIDRange(peer);
+				break;
+
+			case HEADER_GD_REQ_CHANGE_GUILD_MASTER:
+				GuildChangeMaster((TPacketChangeGuildMaster*)data);
+				break;
+
+			case HEADER_GD_UPDATE_HORSE_NAME:
+				UpdateHorseName((TPacketUpdateHorseName*)data, peer);
+				break;
+
+			case HEADER_GD_REQ_HORSE_NAME:
+				AckHorseName(*(DWORD*)data, peer);
+				break;
+
+			case HEADER_GD_DC:
+				DeleteLoginKey((TPacketDC*)data);
+				break;
+
+			case HEADER_GD_VALID_LOGOUT:
+				ResetLastPlayerID((TPacketNeedLoginLogInfo*)data);
+				break;
+
+			case HEADER_GD_REQUEST_CHARGE_CASH:
+				ChargeCash((TRequestChargeCash*)data);
+				break;
+
+				// delete gift notify icon
+			case HEADER_GD_DELETE_AWARDID:
+				DeleteAwardId((TPacketDeleteAwardID*)data);
+				break;
+
+			case HEADER_GD_UPDATE_CHANNELSTATUS:
+				UpdateChannelStatus((SChannelStatus*)data);
+				break;
+
+			case HEADER_GD_REQUEST_CHANNELSTATUS:
+				RequestChannelStatus(peer, dwHandle);
+				break;
+
+#if defined(__MOVE_CHANNEL__)
+			case HEADER_GD_FIND_CHANNEL:
+				FindChannel(peer, dwHandle, (TPacketChangeChannel*)data);
+				break;
+#endif
+
+#if defined(__GEM_SHOP__)
+			case HEADER_GD_GEM_SHOP_LOAD:
+				LoadGemShop(peer, dwHandle, (TGemShopLoad*)data);
+				break;
+
+			case HEADER_GD_GEM_SHOP_UPDATE:
+				UpdateGemShop(peer, dwHandle, (TGemShopTable*)data);
+				break;
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+			case HEADER_GD_EMOTE_LOAD:
+				QUERY_EMOTE_LOAD(peer, dwHandle, (TPacketGDEmote*)data);
+				break;
+
+			case HEADER_GD_EMOTE_CLEAR:
+				QUERY_EMOTE_CLEAR(peer, dwHandle, (TPacketGDEmote*)data);
+				break;
+
+			case HEADER_GD_EMOTE_ADD:
+				QUERY_EMOTE_ADD(peer, dwHandle, (TPacketGDEmote*)data);
+				break;
+#endif
+
+#if defined(__MAILBOX__)
+			case HEADER_GD_MAILBOX_LOAD:
+				QUERY_MAILBOX_LOAD(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_CHECK_NAME:
+				QUERY_MAILBOX_CHECK_NAME(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_WRITE:
+				QUERY_MAILBOX_WRITE(peer, dwHandle, (TMailBoxTable*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_DELETE:
+				QUERY_MAILBOX_DELETE(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_CONFIRM:
+				QUERY_MAILBOX_CONFIRM(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_GET:
+				QUERY_MAILBOX_GET(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_UNREAD:
+				QUERY_MAILBOX_UNREAD(peer, dwHandle, (TMailBox*)data);
+				break;
+#endif
+
+#ifdef __SHOP_SEARCH__
+			case HEADER_GD_SHOP_SEARCH_REGISTER_ITEM:
+				CShopSearchManager::Instance().RecvRegisterItem(peer, *reinterpret_cast<const TShopSearchItem*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_UNREGISTER_ITEM:
+				CShopSearchManager::Instance().RecvUnregisterItem(*reinterpret_cast<const TShopSearchItem*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_SOLD_ITEM:
+				CShopSearchManager::Instance().RecvSoldItem(*reinterpret_cast<const TPacketGDShopSearchSoldItem*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BY_NAME:
+				CShopSearchManager::Instance().RecvSearchByName(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchByName*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BY_OPTIONS:
+			{
+				const TPacketGDShopSearchByOptions& packet = *reinterpret_cast<const TPacketGDShopSearchByOptions*>(data);
+				data += sizeof(TPacketGDShopSearchByOptions);
+				const TShopSearchItemType* itemTypeFlags = (const TShopSearchItemType*)data;
+				data += sizeof(TShopSearchItemType) * packet.options.typeFlagCount;
+				CShopSearchManager::Instance().RecvSearchByOptions(peer, dwHandle, packet, itemTypeFlags, (const DWORD*)data);
+			}
+			break;
+
+			case HEADER_GD_SHOP_SEARCH_REQUEST_BUY:
+				CShopSearchManager::Instance().RecvBuyItem(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchRequestBuy*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BUY_FROM_SHOP_ERROR:
+				CShopSearchManager::Instance().RecvBuyFromShopError(*reinterpret_cast<const TPacketDGShopSearchBuyFromShop*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BOUGHT_FROM_SHOP:
+				CShopSearchManager::Instance().RecvBoughtFromShop(dwHandle, *reinterpret_cast<const TPacketGDShopSearchBoughtFromShop*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_REQUEST_SOLD_INFO:
+				CShopSearchManager::Instance().RecvRequestSoldInfo(peer, dwHandle, *reinterpret_cast<const DWORD*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_RELOAD_AVERAGE:
+				CShopSearchManager::Instance().Initialize();
+				break;
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+			UpdateGrowthPetCache();
+#endif
+
+#ifdef __OFFLINE_SHOP__
+			case HEADER_GD_REQUEST_OFFLINE_SHOP_ID:
+				RequestOfflineShopId(peer, *reinterpret_cast<const uint32_t*>(data));
+				break;
+
+			case HEADER_GD_OFFLINE_SHOP_SAVE:
+				SaveOfflineShop(*reinterpret_cast<const TOfflineShop*>(data));
+				break;
+
+			case HEADER_GD_OFFLINE_SHOP_SAVE_ITEM:
+				SaveOfflineShopItem(*reinterpret_cast<const TOfflineShopItem*>(data));
+				break;
+
+			case HEADER_GD_OFFLINE_SHOP_DESTROY:
+				DestroyOfflineShop(*reinterpret_cast<const uint32_t*>(data));
+				break;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			case HEADER_GD_SAVE_EXT_BATTLE_PASS:
+				QUERY_SAVE_EXT_BATTLE_PASS(peer, dwHandle, (TPlayerExtBattlePassMission*)data);
+				break;
+#endif
+
+			default:
+				sys_err("Unknown header (header: %d handle: %d length: %d)", header, dwHandle, dwLength);
+				break;
+		}
+	}
+
+	peer->RecvEnd(i);
+}
+
+void CClientManager::AddPeer(socket_t fd)
+{
+	CPeer* pPeer = new CPeer;
+
+	if (pPeer->Accept(fd))
+		m_peerList.push_front(pPeer);
+	else
+		delete pPeer;
+}
+
+void CClientManager::RemovePeer(CPeer* pPeer)
+{
+	if (m_pkAuthPeer == pPeer)
+	{
+		m_pkAuthPeer = NULL;
+	}
+	else
+	{
+		TLogonAccountMap::iterator it = m_map_kLogonAccount.begin();
+
+		while (it != m_map_kLogonAccount.end())
+		{
+			CLoginData* pkLD = it->second;
+
+			if (pkLD->GetConnectedPeerHandle() == pPeer->GetHandle())
+			{
+				if (pkLD->IsPlay())
+					pkLD->SetPlay(false);
+
+				if (pkLD->IsDeleted())
+				{
+					sys_log(0, "DELETING LoginData");
+					delete pkLD;
+				}
+
+				m_map_kLogonAccount.erase(it++);
+			}
+			else
+				++it;
+		}
+	}
+
+	m_peerList.remove(pPeer);
+	delete pPeer;
+}
+
+CPeer* CClientManager::GetPeer(IDENT ident)
+{
+	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* tmp = *i;
+
+		if (tmp->GetHandle() == ident)
+			return tmp;
+	}
+
+	return NULL;
+}
+
+CPeer* CClientManager::GetAnyPeer()
+{
+	if (m_peerList.empty())
+		return NULL;
+
+	return m_peerList.front();
+}
+
+// DB 킴    처磯.
+//
+// @version	05/06/10 Bang2ni -   (QID_ITEMPRICE_XXX) 煞
+int CClientManager::AnalyzeQueryResult(SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	CPeer* peer = GetPeer(qi->dwIdent);
+
+#if defined(_DEBUG)
+	if (qi->iType != QID_ITEM_AWARD_LOAD)
+		sys_log(0, "AnalyzeQueryResult %d", qi->iType);
+#endif
+
+	switch (qi->iType)
+	{
+		case QID_ITEM_AWARD_LOAD:
+			ItemAwardManager::instance().Load(msg);
+			delete qi;
+			return true;
+
+		case QID_GUILD_RANKING:
+			CGuildManager::instance().ResultRanking(msg->Get()->pSQLResult);
+			break;
+
+			// MYSHOP_PRICE_LIST
+		case QID_ITEMPRICE_LOAD_FOR_UPDATE:
+			RESULT_PRICELIST_LOAD_FOR_UPDATE(msg);
+			break;
+			// END_OF_MYSHOP_PRICE_LIST
+	}
+
+	if (!peer)
+	{
+		//sys_err("CClientManager::AnalyzeQueryResult: peer not exist anymore. (ident: %d)", qi->dwIdent);
+		delete qi;
+		return true;
+	}
+
+	switch (qi->iType)
+	{
+		case QID_PLAYER:
+		case QID_ITEM:
+		case QID_QUEST:
+		case QID_AFFECT:
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		case QID_EXT_BATTLE_PASS:
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+CClientManager::TGrowthPetCacheSet* CClientManager::GetGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+		return nullptr;
+
+	return it->second;
+}
+
+void CClientManager::CreateGrowthPetCacheSet(DWORD pid)
+{
+	if (m_map_pkGrowthPetCacheSetPtr.find(pid) != m_map_pkGrowthPetCacheSetPtr.end())
+		return;
+
+	TGrowthPetCacheSet* pSet = new TGrowthPetCacheSet;
+	m_map_pkGrowthPetCacheSetPtr.insert(TGrowthPetCacheSetPtrMap::value_type(pid, pSet));
+
+	if (g_log)
+		sys_log(0, "GROWTH_PET_CACHE: new cache %u", pid);
+}
+
+void CClientManager::FlushGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : No GrowthPetCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TGrowthPetCacheSet* pSet = it->second;
+	auto it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CGrowthPetCache* c = *it_set++;
+		c->Flush();
+
+		m_map_growthPetCache.erase(c->Get()->dwID);
+		delete c;
+	}
+
+	pSet->clear();
+	delete pSet;
+
+	m_map_pkGrowthPetCacheSetPtr.erase(it);
+
+	if (g_log)
+		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : Deleted pid(%d)", pid);
+}
+
+CGrowthPetCache* CClientManager::GetGrowthPetCache(DWORD id)
+{
+	auto it = m_map_growthPetCache.find(id);
+
+	if (it == m_map_growthPetCache.end())
+		return nullptr;
+
+	return it->second;
+}
+
+void CClientManager::PutGrowthPetCache(TGrowthPet* pNew, bool bSkipQuery)
+{
+	CGrowthPetCache* c;
+
+	c = GetGrowthPetCache(pNew->dwID);
+	if (!c)
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> New CGrowthPetCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
+
+		c = new CGrowthPetCache;
+		m_map_growthPetCache.insert(TGrowthPetCacheMap::value_type(pNew->dwID, c));
+	}
+	else
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> Have Cache");
+		if (pNew->dwOwner != c->Get()->dwOwner)
+		{
+			auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
+
+			if (it != m_map_pkGrowthPetCacheSetPtr.end())
+			{
+				if (g_log)
+					sys_log(0, "GROWTH_PET_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
+				it->second->erase(c);
+			}
+		}
+	}
+	c->Put(pNew, bSkipQuery);
+
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
+
+	if (it != m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		it->second->insert(c);
+	}
+	else
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+
+		c->OnFlush();
+	}
+}
+
+bool CClientManager::DeleteGrowthPetCache(DWORD dwID)
+{
+	CGrowthPetCache* c = GetGrowthPetCache(dwID);
+
+	if (!c)
+		return false;
+
+	c->Delete();
+	return true;
+}
+
+void CClientManager::UpdateGrowthPetCache()
+{
+	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+		return;
+
+	auto it = m_map_growthPetCache.begin();
+
+	while (it != m_map_growthPetCache.end())
+	{
+		CGrowthPetCache* c = (it++)->second;
+
+		if (c->CheckFlushTimeout())
+		{
+			if (g_test_server)
+				sys_log(0, "UpdateGrowthPetCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
+
+			c->Flush();
+
+			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+				break;
+		}
+	}
+}
+
+void CClientManager::UpdateGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		if (g_test_server)
+			sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet ==> No GrowthPetCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TGrowthPetCacheSet* pSet = it->second;
+	auto it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CGrowthPetCache* c = *it_set++;
+		c->Flush();
+	}
+
+	if (g_log)
+		sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet pid(%d)", pid);
+}
+
+void CClientManager::QUERY_GROWTH_PET_SAVE(CPeer* pkPeer, const char* c_pData)
+{
+	TGrowthPet* p = (TGrowthPet*)c_pData;
+	if (g_test_server)
+		sys_log(0, "QUERY_GROWTH_PET_SAVE => PutGrowthPetCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
+
+	PutGrowthPetCache(p);
+}
+
+void CClientManager::QUERY_GROWTH_PET_DELETE(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwID = *(DWORD*)c_pData;
+	c_pData += sizeof(DWORD);
+
+	DWORD dwPID = *(DWORD*)c_pData;
+
+	if (!DeleteGrowthPetCache(dwID))
+	{
+		char szQuery[64];
+		snprintf(szQuery, sizeof(szQuery), "DELETE FROM growth_pet%s WHERE id=%u", GetTablePostfix(), dwID);
+
+		if (dwPID == 0)
+			CDBManager::instance().AsyncQuery(szQuery);
+		else
+			CDBManager::instance().ReturnQuery(szQuery, QID_GROWTH_PET_DELETE, pkPeer->GetHandle(), NULL);
+	}
+}
+
+bool CClientManager::CreateGrowthPetTableFromRes(MYSQL_RES* res, std::vector<TGrowthPet>* pVec, DWORD dwPID)
+{
+	if (!res)
+	{
+		pVec->clear();
+		return true;
+	}
+
+	int rows;
+
+	if ((rows = mysql_num_rows(res)) <= 0)
+	{
+		pVec->clear();
+		return true;
+	}
+
+	pVec->resize(rows);
+
+	for (int i = 0; i < rows; ++i)
+	{
+		MYSQL_ROW row = mysql_fetch_row(res);
+		TGrowthPet& pet = pVec->at(i);
+
+		int cur = 0;
+
+		str_to_number(pet.dwID, row[cur++]);
+		str_to_number(pet.dwOwner, row[cur++]);
+		str_to_number(pet.dwVnum, row[cur++]);
+		str_to_number(pet.bState, row[cur++]);
+		strlcpy(pet.szName, row[cur++], sizeof(pet.szName));
+		str_to_number(pet.bSize, row[cur++]);
+		str_to_number(pet.dwLevel, row[cur++]);
+		str_to_number(pet.bLevelStep, row[cur++]);
+		str_to_number(pet.bEvolution, row[cur++]);
+		str_to_number(pet.bType, row[cur++]);
+		str_to_number(pet.dwHP, row[cur++]);
+		str_to_number(pet.dwSP, row[cur++]);
+		str_to_number(pet.dwDef, row[cur++]);
+		str_to_number(pet.dwHPApply, row[cur++]);
+		str_to_number(pet.dwSPApply, row[cur++]);
+		str_to_number(pet.dwDefApply, row[cur++]);
+		str_to_number(pet.dwAgeApply, row[cur++]);
+		thecore_memcpy(pet.aSkill, row[cur++], sizeof(pet.aSkill));
+		str_to_number(pet.lExp, row[cur++]);
+		str_to_number(pet.lItemExp, row[cur++]);
+		str_to_number(pet.lBirthday, row[cur++]);
+		str_to_number(pet.lEndTime, row[cur++]);
+		str_to_number(pet.lMaxTime, row[cur++]);
+	}
+
+	return true;
+}
+
+void CClientManager::RESULT_GROWTH_PET_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID)
+{
+	static std::vector<TGrowthPet> s_petVec;
+	CreateGrowthPetTableFromRes(pRes, &s_petVec, dwPID);
+	DWORD dwCount = s_petVec.size();
+
+	peer->EncodeHeader(HEADER_DG_GROWTH_PET_LOAD, dwHandle, sizeof(DWORD) + sizeof(TGrowthPet) * dwCount);
+	peer->EncodeDWORD(dwCount);
+
+	CreateGrowthPetCacheSet(dwPID);
+
+	sys_log(0, "GROWTH_PET_LOAD: count %u pid %u", dwCount, dwPID);
+
+	if (dwCount)
+	{
+		peer->Encode(&s_petVec[0], sizeof(TGrowthPet) * dwCount);
+
+		for (DWORD i = 0; i < dwCount; ++i)
+			PutGrowthPetCache(&s_petVec[i], true);
+	}
+}
+#endif
+			RESULT_COMPOSITE_PLAYER(peer, msg, qi->iType);
+			break;
+
+		case QID_LOGIN:
+			RESULT_LOGIN(peer, msg);
+			break;
+
+		case QID_SAFEBOX_LOAD:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_LOAD");
+			RESULT_SAFEBOX_LOAD(peer, msg);
+			break;
+
+		case QID_SAFEBOX_CHANGE_SIZE:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_SIZE");
+			RESULT_SAFEBOX_CHANGE_SIZE(peer, msg);
+			break;
+
+		case QID_SAFEBOX_CHANGE_PASSWORD:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
+			RESULT_SAFEBOX_CHANGE_PASSWORD(peer, msg);
+			break;
+
+		case QID_SAFEBOX_CHANGE_PASSWORD_SECOND:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
+			RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(peer, msg);
+			break;
+
+		case QID_HIGHSCORE_REGISTER:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_HIGHSCORE_REGISTER %p", msg);
+			RESULT_HIGHSCORE_REGISTER(peer, msg);
+			break;
+
+		case QID_SAFEBOX_SAVE:
+		case QID_ITEM_SAVE:
+		case QID_ITEM_DESTROY:
+		case QID_QUEST_SAVE:
+		case QID_PLAYER_SAVE:
+		case QID_ITEM_AWARD_TAKEN:
+#ifdef __GROWTH_PET_SYSTEM__
+		case QID_GROWTH_PET_SAVE:
+		case QID_GROWTH_PET_DELETE:
+#endif
+			break;
+
+			// PLAYER_INDEX_CREATE_BUG_FIX
+		case QID_PLAYER_INDEX_CREATE:
+			RESULT_PLAYER_INDEX_CREATE(peer, msg);
+			break;
+			// END_PLAYER_INDEX_CREATE_BUG_FIX
+
+		case QID_PLAYER_DELETE:
+			__RESULT_PLAYER_DELETE(peer, msg);
+			break;
+
+		case QID_LOGIN_BY_KEY:
+			RESULT_LOGIN_BY_KEY(peer, msg);
+			break;
+
+			// MYSHOP_PRICE_LIST
+		case QID_ITEMPRICE_LOAD:
+			RESULT_PRICELIST_LOAD(peer, msg);
+			break;
+			// END_OF_MYSHOP_PRICE_LIST
+
+		default:
+			sys_log(0, "CClientManager::AnalyzeQueryResult unknown query result type: %d, str: %s", qi->iType, msg->stQuery.c_str());
+			break;
+	}
+
+	delete qi;
+	return true;
+}
+
+void UsageLog()
+{
+	FILE* fp = NULL;
+
+	time_t ct;
+	char* time_s;
+	struct tm lt;
+
+	int avg = g_dwUsageAvg / 3600; // 60  * 60 
+
+	fp = fopen("usage.txt", "a+");
+
+	if (!fp)
+		return;
+
+	ct = time(0);
+	lt = *localtime(&ct);
+	time_s = asctime(&lt);
+
+	time_s[strlen(time_s) - 1] = '\0';
+
+	fprintf(fp, "| %4d %-15.15s | %5d | %5u |", lt.tm_year + 1900, time_s + 4, avg, g_dwUsageMax);
+
+	fprintf(fp, "\n");
+	fclose(fp);
+
+	g_dwUsageMax = g_dwUsageAvg = 0;
+}
+
+int CClientManager::Process()
+{
+	int pulses;
+
+	if (!(pulses = thecore_idle()))
+		return 0;
+
+	while (pulses--)
+	{
+		++thecore_heart->pulse;
+
+		/*
+		// 30龜 
+		if (((thecore_pulse() % (60 * 30 * 10)) == 0))
+		{
+			g_iPlayerCacheFlushSeconds = MAX(60, rand() % 180);
+			g_iItemCacheFlushSeconds = MAX(60, rand() % 180);
+			sys_log(0, "[SAVE_TIME]Change saving time item %d player %d", g_iPlayerCacheFlushSeconds, g_iItemCacheFlushSeconds);
+		}
+		*/
+
+		if (!(thecore_heart->pulse % thecore_heart->passes_per_sec))
+		{
+			if (g_test_server)
+			{
+				if (!(thecore_heart->pulse % thecore_heart->passes_per_sec * 10))
+
+				{
+					pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d/%d",
+						thecore_heart->pulse,
+						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+						CDBManager::instance().CountReturnResult(SQL_PLAYER),
+						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+						CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
+						CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
+
+					if ((thecore_heart->pulse % 50) == 0)
+						sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
+							thecore_heart->pulse,
+							CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+							CDBManager::instance().CountReturnResult(SQL_PLAYER),
+							CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+							CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+							CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+							CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
+				}
+			}
+			else
+			{
+				pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d%/%d",
+					thecore_heart->pulse,
+					CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+					CDBManager::instance().CountReturnResult(SQL_PLAYER),
+					CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+					CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
+					CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+					CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+					CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
+					CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
+
+				if ((thecore_heart->pulse % 50) == 0)
+					sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
+						thecore_heart->pulse,
+						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+						CDBManager::instance().CountReturnResult(SQL_PLAYER),
+						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
+			}
+
+			CDBManager::instance().ResetCounter();
+
+			DWORD dwCount = CClientManager::instance().GetUserCount();
+
+			g_dwUsageAvg += dwCount;
+			g_dwUsageMax = MAX(g_dwUsageMax, dwCount);
+
+			memset(&thecore_profiler[0], 0, sizeof(thecore_profiler));
+
+#if defined(__EXPRESSING_EMOTIONS__)
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iEmoteDumpDelay)))
+				CClientManager::instance().QUERY_EMOTE_DUMP();
+#endif
+
+#if defined(__MAILBOX__)
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iMailBoxBackupSec)))
+				CClientManager::instance().MAILBOX_BACKUP();
+#endif
+
+#if defined(__GEM_SHOP__)
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iGemShopFlushDelay)))
+				CClientManager::instance().FlushGemShop();
+#endif
+
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600)))
+				UsageLog();
+
+			m_iCacheFlushCount = 0;
+
+			// 첨潔 첨
+			UpdatePlayerCache();
+			//  첨
+			UpdateItemCache();
+			//慣類틸 처- 캐 첨
+			UpdateLogoutPlayer();
+
+			// MYSHOP_PRICE_LIST
+			UpdateItemPriceListCache();
+			// END_OF_MYSHOP_PRICE_LIST
+#ifdef __OFFLINE_SHOP__
+			UpdateOfflineShopCache();
+			UpdateOfflineShopItemCache();
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+			UpdateGrowthPetCache();
+#endif
+			CGuildManager::instance().Update();
+			CPrivManager::instance().Update();
+			marriage::CManager::instance().Update();
+#ifdef __SHOP_SEARCH__
+			CShopSearchManager::Instance().Update();
+#endif
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 5)))
+		{
+			ItemAwardManager::instance().RequestLoad();
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 10)))
+		{
+			/*
+			char buf[4096 + 1];
+			int len
+
+			/////////////////////////////////////////////////////////////////
+			buf[0] = '\0';
+			len = 0;
+
+			auto it = g_query_info.m_map_info.begin();
+
+			int count = 0;
+
+			while (it != g_query_info.m_map_info.end())
+			{
+				len += snprintf(buf + len, sizeof(buf) - len, "%2d %3d\n", it->first, it->second);
+				count += it->second;
+				it++;
+			}
+
+			pt_log("QUERY:\n%s-------------------- MAX : %d\n", buf, count);
+			g_query_info.Reset();
+			*/
+			pt_log("QUERY: MAIN[%d] ASYNC[%d]", g_query_count[0], g_query_count[1]);
+			g_query_count[0] = 0;
+			g_query_count[1] = 0;
+			/////////////////////////////////////////////////////////////////
+
+			/////////////////////////////////////////////////////////////////
+			/*
+			buf[0] = '\0';
+			len = 0;
+
+			it = g_item_info.m_map_info.begin();
+
+			count = 0;
+			while (it != g_item_info.m_map_info.end())
+			{
+				len += snprintf(buf + len, sizeof(buf) - len, "%5d %3d\n", it->first, it->second);
+				count += it->second;
+				it++;
+			}
+
+			pt_log("ITEM:\n%s-------------------- MAX : %d\n", buf, count);
+			g_item_info.Reset();
+			*/
+			pt_log("ITEM:%d\n", g_item_count);
+			g_item_count = 0;
+			/////////////////////////////////////////////////////////////////
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60))) // 60却 箕
+		{
+			// 크   챨 .
+			CClientManager::instance().SendTime();
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600))) // 耆챨 箕
+		{
+			CMoneyLog::instance().Save();
+		}
+
+#if defined(__ENVIRONMENT_SYSTEM__)
+		static bool OnSetup = true;
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60 * 20)) || OnSetup)
+		{
+			UpdateEnvironment();
+			OnSetup = false;
+		}
+#endif
+	}
+
+	int num_events = fdwatch(m_fdWatcher, 0);
+	int idx;
+	CPeer* peer;
+
+	for (idx = 0; idx < num_events; ++idx) // 풋
+	{
+		peer = (CPeer*)fdwatch_get_client_data(m_fdWatcher, idx);
+
+		if (!peer)
+		{
+			if (fdwatch_check_event(m_fdWatcher, m_fdAccept, idx) == FDW_READ)
+			{
+				AddPeer(m_fdAccept);
+				fdwatch_clear_event(m_fdWatcher, m_fdAccept, idx);
+			}
+			else
+			{
+				sys_log(0, "FDWATCH: peer null in event: ident %d", fdwatch_get_ident(m_fdWatcher, idx));
+			}
+
+			continue;
+		}
+
+		switch (fdwatch_check_event(m_fdWatcher, peer->GetFd(), idx))
+		{
+			case FDW_READ:
+				if (peer->Recv() < 0)
+				{
+					sys_err("Recv failed");
+					RemovePeer(peer);
+				}
+				else
+				{
+					if (peer == m_pkAuthPeer)
+						if (g_log)
+							sys_log(0, "AUTH_PEER_READ: size %d", peer->GetRecvLength());
+
+					ProcessPackets(peer);
+				}
+				break;
+
+			case FDW_WRITE:
+				if (peer == m_pkAuthPeer)
+					if (g_log)
+						sys_log(0, "AUTH_PEER_WRITE: size %d", peer->GetSendLength());
+
+				if (peer->Send() < 0)
+				{
+					sys_err("Send failed");
+					RemovePeer(peer);
+				}
+
+				break;
+
+			case FDW_EOF:
+				RemovePeer(peer);
+				break;
+
+			default:
+				sys_err("fdwatch_check_fd returned unknown result");
+				RemovePeer(peer);
+				break;
+		}
+	}
+
+#ifdef __WIN32__
+	if (_kbhit())
+	{
+		int c = _getch();
+		switch (c)
+		{
+			case 0x1b: // Esc
+				return 0; // shutdown
+				break;
+			default:
+				break;
+		}
+	}
+#endif
+
+	return 1;
+}
+
+DWORD CClientManager::GetUserCount()
+{
+	// 秉 慣 카트 .. --;
+	return m_map_kLogonAccount.size();
+}
+
+void CClientManager::SendAllGuildSkillRechargePacket()
+{
+	ForwardPacket(HEADER_DG_GUILD_SKILL_RECHARGE, NULL, 0);
+}
+
+void CClientManager::SendTime()
+{
+	time_t now = GetCurrentTime();
+	ForwardPacket(HEADER_DG_TIME, &now, sizeof(time_t));
+}
+
+void CClientManager::ForwardPacket(BYTE header, const void* data, int size, BYTE bChannel, CPeer* except)
+{
+	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* peer = *it;
+
+		if (peer == except)
+			continue;
+
+		if (!peer->GetChannel())
+			continue;
+
+		if (bChannel && peer->GetChannel() != bChannel)
+			continue;
+
+		peer->EncodeHeader(header, 0, size);
+
+		if (size > 0 && data)
+			peer->Encode(data, size);
+	}
+}
+
+void CClientManager::SendNotice(const char* c_pszFormat, ...)
+{
+	char szBuf[255 + 1];
+	va_list args;
+
+	va_start(args, c_pszFormat);
+	int len = vsnprintf(szBuf, sizeof(szBuf), c_pszFormat, args);
+	va_end(args);
+	szBuf[len] = '\0';
+
+	ForwardPacket(HEADER_DG_NOTICE, szBuf, len + 1);
+}
+
+time_t CClientManager::GetCurrentTime()
+{
+	return time(0);
+}
+
+// ITEM_UNIQUE_ID
+bool CClientManager::InitializeNowItemID()
+{
+	DWORD dwMin, dwMax;
+
+	//  ID 珂화 磯.
+	if (!CConfig::instance().GetTwoValue("ITEM_ID_RANGE", &dwMin, &dwMax))
+	{
+		sys_err("config.txt: Cannot find ITEM_ID_RANGE [start_item_id] [end_item_id]");
+		return false;
+	}
+
+	sys_log(0, "ItemRange From File %u ~ %u ", dwMin, dwMax);
+
+	if (CItemIDRangeManager::instance().BuildRange(dwMin, dwMax, m_itemRange) == false)
+	{
+		sys_err("Can not build ITEM_ID_RANGE");
+		return false;
+	}
+
+	sys_log(0, " Init Success Start %u End %u Now %u\n", m_itemRange.dwMin, m_itemRange.dwMax, m_itemRange.dwUsableItemIDMin);
+
+	return true;
+}
+
+DWORD CClientManager::GainItemID()
+{
+	return m_itemRange.dwUsableItemIDMin++;
+}
+
+DWORD CClientManager::GetItemID()
+{
+	return m_itemRange.dwUsableItemIDMin;
+}
+// ITEM_UNIQUE_ID_END
+
+// BOOT_LOCALIZATION
+bool CClientManager::InitializeLocalization()
+{
+	char szQuery[512];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `mValue`, `mKey` FROM `locale`");
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
+
+	if (pMsg->Get()->uiNumRows == 0)
+	{
+		sys_err("InitializeLocalization() ==> DirectQuery failed(%s)", szQuery);
+		delete pMsg;
+		return false;
+	}
+
+	sys_log(0, "InitializeLocalization() - LoadLocaleTable(count:%d)", pMsg->Get()->uiNumRows);
+
+	m_vec_Locale.clear();
+
+	MYSQL_ROW row = NULL;
+
+	for (; (row = mysql_fetch_row(pMsg->Get()->pSQLResult)) != NULL;)
+	{
+		int col = 0;
+		tLocale locale;
+
+		strlcpy(locale.szValue, row[col++], sizeof(locale.szValue));
+		strlcpy(locale.szKey, row[col++], sizeof(locale.szKey));
+
+		// DB_NAME_COLUMN Setting
+		if (strcmp(locale.szKey, "LOCALE") == 0)
+		{
+			if (strcmp(locale.szValue, "cibn") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
+
+				g_stLocale = "gb2312";
+				g_stLocaleNameColumn = "gb2312name";
+			}
+			else if (strcmp(locale.szValue, "ymir") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "euckr";
+				g_stLocaleNameColumn = "name";
+			}
+			else if (strcmp(locale.szValue, "japan") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "sjis");
+
+				g_stLocale = "sjis";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "english") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "germany") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "france") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "italy") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "spain") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "uk") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "turkey") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin5";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "poland") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "portugal") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "hongkong") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
+
+				g_stLocale = "big5";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "newcibn") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
+
+				g_stLocale = "gb2312";
+				g_stLocaleNameColumn = "gb2312name";
+			}
+			else if (strcmp(locale.szValue, "korea") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "euckr";
+				g_stLocaleNameColumn = "name";
+			}
+			else if (strcmp(locale.szValue, "canada") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "gb2312name";
+			}
+			else if (strcmp(locale.szValue, "brazil") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "greek") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "greek";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "russia") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "cp1251";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "denmark") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "bulgaria") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "cp1251";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "croatia") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "cp1251";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "mexico") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "arabia") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "cp1256";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "czech") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "hungary") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "romania") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "netherlands") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "singapore") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "vietnam") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "thailand") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "usa") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "we_korea") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "euckr";
+				g_stLocaleNameColumn = "name";
+			}
+			else if (strcmp(locale.szValue, "taiwan") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
+				g_stLocale = "big5";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "europe") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else
+			{
+				sys_err("locale[LOCALE] = UNKNOWN(%s)", locale.szValue);
+				exit(0);
+			}
+
+			CDBManager::instance().SetLocale(g_stLocale.c_str());
+		}
+		else if (strcmp(locale.szKey, "DB_NAME_COLUMN") == 0)
+		{
+			sys_log(0, "locale[DB_NAME_COLUMN] = %s", locale.szValue);
+			g_stLocaleNameColumn = locale.szValue;
+		}
+		else
+		{
+			sys_log(0, "locale[UNKNOWN_KEY(%s)] = %s", locale.szKey, locale.szValue);
+		}
+		m_vec_Locale.push_back(locale);
+	}
+
+	delete pMsg;
+
+	return true;
+}
+// END_BOOT_LOCALIZATION
+
+// ADMIN_MANAGER
+bool CClientManager::__GetAdminInfo(const char* szIP, std::vector<tAdminInfo>& rAdminVec)
+{
+	// szIP == NULL 構 煐 楮  쨈.
+	char szQuery[512];
+	snprintf(szQuery, sizeof(szQuery),
+		"SELECT `mID`, `mAccount`, `mName`, `mContactIP`, `mServerIP`, `mAuthority` FROM `gmlist` WHERE `mServerIP` = 'ALL' OR `mServerIP` = '%s'",
+		szIP ? szIP : "ALL");
+
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
+
+	if (pMsg->Get()->uiNumRows == 0)
+	{
+		sys_err("__GetAdminInfo() ==> DirectQuery failed(%s)", szQuery);
+		delete pMsg;
+		return false;
+	}
+
+	MYSQL_ROW row;
+	rAdminVec.reserve(pMsg->Get()->uiNumRows);
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		int idx = 0;
+		tAdminInfo Info;
+
+		str_to_number(Info.m_ID, row[idx++]);
+		trim_and_lower(row[idx++], Info.m_szAccount, sizeof(Info.m_szAccount));
+		strlcpy(Info.m_szName, row[idx++], sizeof(Info.m_szName));
+		strlcpy(Info.m_szContactIP, row[idx++], sizeof(Info.m_szContactIP));
+		strlcpy(Info.m_szServerIP, row[idx++], sizeof(Info.m_szServerIP));
+		std::string stAuth = row[idx++];
+
+		if (!stAuth.compare("IMPLEMENTOR"))
+			Info.m_Authority = GM_IMPLEMENTOR;
+		else if (!stAuth.compare("GOD"))
+			Info.m_Authority = GM_GOD;
+		else if (!stAuth.compare("HIGH_WIZARD"))
+			Info.m_Authority = GM_HIGH_WIZARD;
+		else if (!stAuth.compare("LOW_WIZARD"))
+			Info.m_Authority = GM_LOW_WIZARD;
+		else if (!stAuth.compare("WIZARD"))
+			Info.m_Authority = GM_WIZARD;
+		else
+			continue;
+
+		rAdminVec.push_back(Info);
+
+		sys_log(0, "GM: PID %u Login %s Character %s ContactIP %s ServerIP %s Authority %d[%s]",
+			Info.m_ID, Info.m_szAccount, Info.m_szName, Info.m_szContactIP, Info.m_szServerIP, Info.m_Authority, stAuth.c_str());
+	}
+
+	delete pMsg;
+
+	return true;
+}
+
+bool CClientManager::__GetHostInfo(std::vector<std::string>& rIPVec)
+{
+	char szQuery[512];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `mIP` FROM `gmhost`");
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
+
+	if (pMsg->Get()->uiNumRows == 0)
+	{
+		sys_err("__GetHostInfo() ==> DirectQuery failed(%s)", szQuery);
+		delete pMsg;
+		return false;
+	}
+
+	rIPVec.reserve(pMsg->Get()->uiNumRows);
+
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		if (row[0] && *row[0])
+		{
+			rIPVec.push_back(row[0]);
+			sys_log(0, "GMHOST: %s", row[0]);
+		}
+	}
+
+	delete pMsg;
+	return true;
+}
+// END_ADMIN_MANAGER
+
+void CClientManager::ReloadAdmin(CPeer*, TPacketReloadAdmin* p)
+{
+	std::vector<tAdminInfo> vAdmin;
+	std::vector<std::string> vHost;
+
+	__GetHostInfo(vHost);
+	__GetAdminInfo(p->szIP, vAdmin);
+
+	DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
+		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size();
+
+	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* peer = *it;
+
+		if (!peer->GetChannel())
+			continue;
+
+		peer->EncodeHeader(HEADER_DG_RELOAD_ADMIN, 0, dwPacketSize);
+
+		peer->EncodeWORD(16);
+		peer->EncodeWORD(static_cast<WORD>(vHost.size()));
+
+		for (size_t n = 0; n < vHost.size(); ++n)
+			peer->Encode(vHost[n].c_str(), 16);
+
+		peer->EncodeWORD(sizeof(tAdminInfo));
+		peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
+
+		for (size_t n = 0; n < vAdmin.size(); ++n)
+			peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
+	}
+
+	sys_log(0, "ReloadAdmin End %s", p->szIP);
+}
+
+// BREAK_MARRIAGE
+void CClientManager::BreakMarriage(CPeer* peer, const char* data)
+{
+	DWORD pid1, pid2;
+
+	pid1 = *(int*)data;
+	data += sizeof(int);
+
+	pid2 = *(int*)data;
+	data += sizeof(int);
+
+	sys_log(0, "Breaking off a marriage engagement! pid %d and pid %d", pid1, pid2);
+	marriage::CManager::instance().Remove(pid1, pid2);
+}
+// END_BREAK_MARIIAGE
+
+void CClientManager::UpdateItemCacheSet(DWORD pid)
+{
+	auto it = m_map_pkItemCacheSetPtr.find(pid);
+	if (it == m_map_pkItemCacheSetPtr.end())
+	{
+		if (g_test_server)
+			sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCacheSet ==> No ItemCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TItemCacheSet* pSet = it->second;
+	TItemCacheSet::iterator it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CItemCache* c = *it_set++;
+		c->Flush();
+	}
+
+	if (g_log)
+		sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCachsSet pid(%d)", pid);
+}
+
+void CClientManager::Election(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	DWORD idx;
+	DWORD selectingpid;
+
+	idx = *(DWORD*)data;
+	data += sizeof(DWORD);
+
+	selectingpid = *(DWORD*)data;
+	data += sizeof(DWORD);
+
+	int Success = 0;
+
+	if (!(Success = CMonarch::instance().VoteMonarch(selectingpid, idx)))
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_VOTE] Failed %d %d", idx, selectingpid);
+		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
+		peer->Encode(&Success, sizeof(int));
+		return;
+	}
+	else
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_VOTE] Success %d %d", idx, selectingpid);
+		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
+		peer->Encode(&Success, sizeof(int));
+		return;
+	}
+
+}
+
+void CClientManager::Candidacy(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	DWORD pid;
+
+	pid = *(DWORD*)data;
+	data += sizeof(DWORD);
+
+	if (!CMonarch::instance().AddCandidacy(pid, data))
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_CANDIDACY] Failed %d %s", pid, data);
+
+		peer->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
+		peer->Encode(0, sizeof(int));
+		peer->Encode(data, 32);
+		return;
+	}
+	else
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_CANDIDACY] Success %d %s", pid, data);
+
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (0 && p->GetChannel() != 0)
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
+				p->Encode(&pid, sizeof(int));
+				p->Encode(data, 32);
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_CANDIDACY, 0, sizeof(int) + 32);
+				p->Encode(&pid, sizeof(int));
+				p->Encode(data, 32);
+			}
+		}
+	}
+}
+
+void CClientManager::AddMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH] Add money Empire(%d) Money(%d)", Empire, Money);
+
+	CMonarch::instance().AddMoney(Empire, Money);
+
+	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* p = *it;
+
+		if (!p->GetChannel())
+			continue;
+
+		if (p == peer)
+		{
+			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+		else
+		{
+			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+
+	}
+}
+
+void CClientManager::DecMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH] Dec money Empire(%d) Money(%d)", Empire, Money);
+
+	CMonarch::instance().DecMoney(Empire, Money);
+
+	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* p = *it;
+
+		if (!p->GetChannel())
+			continue;
+
+		if (p == peer)
+		{
+			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+		else
+		{
+			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+	}
+}
+
+void CClientManager::TakeMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	DWORD pid = *(DWORD*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH] Take money Empire(%d) Money(%d)", Empire, Money);
+
+	if (CMonarch::instance().TakeMoney(Empire, pid, Money) == true)
+	{
+		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+		peer->Encode(&Empire, sizeof(int));
+		peer->Encode(&Money, sizeof(int));
+	}
+	else
+	{
+		Money = 0;
+		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+		peer->Encode(&Empire, sizeof(int));
+		peer->Encode(&Money, sizeof(int));
+	}
+}
+
+void CClientManager::ComeToVote(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	CMonarch::instance().ElectMonarch();
+}
+
+void CClientManager::RMCandidacy(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	char szName[32];
+
+	strlcpy(szName, data, sizeof(szName));
+	sys_log(0, "[MONARCH_GM] Remove candidacy name(%s)", szName);
+
+	int iRet = CMonarch::instance().DelCandidacy(szName) ? 1 : 0;
+
+	if (1 == iRet)
+	{
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+		}
+	}
+	else
+	{
+		CPeer* p = peer;
+		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+		p->Encode(&iRet, sizeof(int));
+		p->Encode(szName, sizeof(szName));
+	}
+}
+
+void CClientManager::SetMonarch(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	char szName[32];
+
+	strlcpy(szName, data, sizeof(szName));
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH_GM] Set Monarch name(%s)", szName);
+
+	int iRet = CMonarch::instance().SetMonarch(szName) ? 1 : 0;
+
+	if (1 == iRet)
+	{
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+		}
+	}
+	else
+	{
+		CPeer* p = peer;
+		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+		p->Encode(&iRet, sizeof(int));
+		p->Encode(szName, sizeof(szName));
+	}
+}
+
+void CClientManager::RMMonarch(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	char szName[32];
+
+	strlcpy(szName, data, sizeof(szName));
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH_GM] Remove Monarch name(%s)", szName);
+
+	CMonarch::instance().DelMonarch(szName);
+
+	int iRet = CMonarch::instance().DelMonarch(szName) ? 1 : 0;
+
+	if (1 == iRet)
+	{
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+		}
+	}
+	else
+	{
+		CPeer* p = peer;
+		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+		p->Encode(&iRet, sizeof(int));
+		p->Encode(szName, sizeof(szName));
+	}
+}
+
+void CClientManager::ChangeMonarchLord(CPeer* peer, DWORD dwHandle, TPacketChangeMonarchLord* info)
+{
+	char szQuery[1024];
+	snprintf(szQuery, sizeof(szQuery),
+		"SELECT a.`name`, NOW() FROM player%s AS a, player_index%s AS b WHERE (a.`account_id` = b.`id` AND a.`id` = %u AND b.`empire` = %u) AND "
+		"(b.`pid1` = %u OR "
+		"b.`pid2` = %u OR "
+		"b.`pid3` = %u OR "
+		"b.`pid4` = %u"
+#if defined(__PLAYER_PER_ACCOUNT5__)
+		" OR b.`pid5` = %u"
+#endif
+		")",
+		GetTablePostfix(),
+		GetTablePostfix(),
+		info->dwPID,
+		info->bEmpire,
+		info->dwPID,
+		info->dwPID,
+		info->dwPID,
+		info->dwPID
+#if defined(__PLAYER_PER_ACCOUNT5__)
+		, info->dwPID
+#endif
+	);
+
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
+
+	if (pMsg->Get()->uiNumRows != 0)
+	{
+		TPacketChangeMonarchLordACK ack;
+		ack.bEmpire = info->bEmpire;
+		ack.dwPID = info->dwPID;
+
+		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+		strlcpy(ack.szName, row[0], sizeof(ack.szName));
+		strlcpy(ack.szDate, row[1], sizeof(ack.szDate));
+
+		snprintf(szQuery, sizeof(szQuery), "UPDATE `monarch` SET `pid` = %u, `windate` = NOW() WHERE `empire` = %d", ack.dwPID, ack.bEmpire);
+		SQLMsg* pMsg2 = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
+
+		if (pMsg2->Get()->uiAffectedRows > 0)
+		{
+			CMonarch::instance().LoadMonarch();
+
+			TMonarchInfo* newInfo = CMonarch::instance().GetMonarch();
+
+			for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+			{
+				CPeer* client = *it;
+
+				client->EncodeHeader(HEADER_DG_CHANGE_MONARCH_LORD_ACK, 0, sizeof(TPacketChangeMonarchLordACK));
+				client->Encode(&ack, sizeof(TPacketChangeMonarchLordACK));
+
+				client->EncodeHeader(HEADER_DG_UPDATE_MONARCH_INFO, 0, sizeof(TMonarchInfo));
+				client->Encode(newInfo, sizeof(TMonarchInfo));
+			}
+		}
+
+		delete pMsg2;
+	}
+
+	delete pMsg;
+}
+
+void CClientManager::BlockException(TPacketBlockException* data)
+{
+	sys_log(0, "[BLOCK_EXCEPTION] CMD(%d) login(%s)", data->cmd, data->login);
+
+	// save sql
+	{
+		char buf[1024];
+
+		switch (data->cmd)
+		{
+			case BLOCK_EXCEPTION_CMD_ADD:
+				snprintf(buf, sizeof(buf), "INSERT INTO `block_exception` VALUES('%s')", data->login);
+				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
+				CBlockCountry::instance().AddBlockException(data->login);
+				break;
+			case BLOCK_EXCEPTION_CMD_DEL:
+				snprintf(buf, sizeof(buf), "DELETE FROM `block_exception` WHERE `login` = %s", data->login);
+				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
+				CBlockCountry::instance().DelBlockException(data->login);
+				break;
+			default:
+				return;
+		}
+
+	}
+
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* peer = *it;
+
+		if (!peer->GetChannel())
+			continue;
+
+		CBlockCountry::instance().SendBlockExceptionOne(peer, data->login, data->cmd);
+	}
+}
+
+void CClientManager::SendSpareItemIDRange(CPeer* peer)
+{
+	peer->SendSpareItemIDRange();
+}
+
+//
+// Login Key 却 .
+//
+void CClientManager::DeleteLoginKey(TPacketDC* data)
+{
+	char login[LOGIN_MAX_LEN + 1] = { 0 };
+	trim_and_lower(data->login, login, sizeof(login));
+
+	CLoginData* pkLD = GetLoginDataByLogin(login);
+
+	if (pkLD)
+	{
+		TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(pkLD->GetKey());
+
+		if (it != m_map_pkLoginData.end())
+			m_map_pkLoginData.erase(it);
+	}
+}
+
+// delete gift notify icon
+void CClientManager::DeleteAwardId(TPacketDeleteAwardID* data)
+{
+	// sys_log(0, "data from game server arrived %d", data->dwID);
+	std::map<DWORD, TItemAward*>::iterator it;
+	it = ItemAwardManager::Instance().GetMapAward().find(data->dwID);
+	if (it != ItemAwardManager::Instance().GetMapAward().end())
+	{
+		std::set<TItemAward*>& kSet = ItemAwardManager::Instance().GetMapkSetAwardByLogin()[it->second->szLogin];
+		if (kSet.erase(it->second))
+			sys_log(0, "erase ItemAward id: %d from cache", data->dwID);
+		ItemAwardManager::Instance().GetMapAward().erase(data->dwID);
+	}
+	else
+	{
+		sys_log(0, "DELETE_AWARDID : could not find the id: %d", data->dwID);
+	}
+}
+
+void CClientManager::UpdateChannelStatus(TChannelStatus* pData)
+{
+	TChannelStatusMap::iterator it = m_mChannelStatus.find(pData->nPort);
+	if (it != m_mChannelStatus.end())
+	{
+		it->second = pData->bStatus;
+	}
+	else
+	{
+		m_mChannelStatus.insert(TChannelStatusMap::value_type(pData->nPort, pData->bStatus));
+	}
+}
+
+void CClientManager::RequestChannelStatus(CPeer* peer, DWORD dwHandle)
+{
+	const int nSize = m_mChannelStatus.size();
+	peer->EncodeHeader(HEADER_DG_RESPOND_CHANNELSTATUS, dwHandle, sizeof(TChannelStatus) * nSize + sizeof(int));
+	peer->Encode(&nSize, sizeof(int));
+	for (TChannelStatusMap::iterator it = m_mChannelStatus.begin(); it != m_mChannelStatus.end(); ++it)
+	{
+		peer->Encode(&it->first, sizeof(short));
+		peer->Encode(&it->second, sizeof(BYTE));
+	}
+}
+
+void CClientManager::ResetLastPlayerID(const TPacketNeedLoginLogInfo* data)
+{
+	CLoginData* pkLD = GetLoginDataByAID(data->dwPlayerID);
+
+	if (NULL != pkLD)
+	{
+		pkLD->SetLastPlayerID(0);
+	}
+}
+
+void CClientManager::ChargeCash(const TRequestChargeCash* packet)
+{
+	char szQuery[512];
+
+	if (ERequestCharge_Cash == packet->eChargeType)
+		sprintf(szQuery, "update account set `cash` = `cash` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
+	else if (ERequestCharge_Mileage == packet->eChargeType)
+		sprintf(szQuery, "update account set `mileage` = `mileage` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
+	else
+	{
+		sys_err("Invalid request charge type (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
+		return;
+	}
+
+	sys_err("Request Charge (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
+
+	CDBManager::Instance().AsyncQuery(szQuery, SQL_ACCOUNT);
+}
+
+#if defined(__MOVE_CHANNEL__)
+void CClientManager::FindChannel(CPeer* requestPeer, DWORD dwHandle, TPacketChangeChannel* p)
+{
+	if (!p->lMapIndex || !p->iChannel)
+		return;
+
+	long lAddr = 0;
+	WORD wPort = 0;
+
+	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* peer = *i;
+		if (peer->GetChannel() != p->iChannel) // not the channel we are looking for!
+			continue;
+
+		TMapLocation kMapLocation;
+		thecore_memcpy(kMapLocation.alMaps, peer->GetMaps(), sizeof(kMapLocation.alMaps));
+		int iLen = sizeof(kMapLocation.alMaps) / sizeof(kMapLocation.alMaps[0]);
+
+		for (int i = 0; i < iLen; ++i)
+		{
+			if (kMapLocation.alMaps[i] == p->lMapIndex)
+			{
+				// Get host, and convert to int
+				char host[16];
+				strlcpy(host, peer->GetPublicIP(), sizeof(kMapLocation.szHost));
+				lAddr = inet_addr(host);
+
+				// Target port
+				wPort = peer->GetListenPort();
+
+				break;
+			}
+		}
+
+		if (lAddr && wPort) // We already obtained them
+			break;
+	}
+
+	TPacketReturnChannel r;
+	r.lAddr = lAddr;
+	r.wPort = wPort;
+
+	requestPeer->EncodeHeader(HEADER_DG_CHANNEL_RESULT, dwHandle, sizeof(r));
+	requestPeer->Encode(&r, sizeof(r));
+}
+#endif
+
+#if defined(__ENVIRONMENT_SYSTEM__)
+enum DayMode : BYTE { DAY, NIGHT };
+
+static BYTE GetDayMode(int Hour)
+{
+	if (Hour >= 6 && Hour <= 20)
+		return DayMode::DAY;
+	return DayMode::NIGHT;
+}
+
+static bool IsWinter(int Month)
+{
+	return (Month >= 11 || Month <= 0);
+}
+
+void CClientManager::UpdateEnvironment()
+{
+	time_t CurrentTime = time(nullptr);
+	tm* tm = localtime(&CurrentTime);
+
+	auto SendFlag = [&](const char* flag, BYTE val)
+		{
+			TEventFlagMap::const_iterator it = m_map_lEventFlag.find(flag);
+			if ((it != m_map_lEventFlag.end() && it->second == val) == false)
+			{
+				TPacketSetEventFlag p;
+				std::strcpy(p.szFlagName, flag);
+				p.lValue = val;
+				SetEventFlag(&p);
+			}
+		};
+
+	SendFlag("eclipse", GetDayMode(tm->tm_hour));
+	BOOL Winter = IsWinter(tm->tm_mon);
+	for (const auto& Flag : { "xmas_snow" })
+		SendFlag(Flag, Winter);
+}
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+void CClientManager::QUERY_EMOTE_LOAD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
+{
+	if (pTable == nullptr)
+		return;
+
+	TEmoteTableVector* pVec = nullptr;
+	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
+	if (it != m_map_kPlayerEmote.end())
+		pVec = &it->second;
+
+	if (pVec && !pVec->empty())
+	{
+		const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
+		pVec->erase(std::remove_if(pVec->begin(), pVec->end(),
+			[dwCurrentTime](const TPacketGDEmote& rkTable)
+			{
+				return dwCurrentTime > rkTable.dwDuration;
+			}
+		), pVec->end());
+	}
+
+	const WORD wSize = pVec ? static_cast<WORD>(pVec->size()) : 0;
+	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(TPacketGDEmote) * wSize;
+
+	pkPeer->EncodeHeader(HEADER_DG_EMOTE_LOAD, dwHandle, dwPacketSize);
+	pkPeer->EncodeWORD(sizeof(TPacketGDEmote));
+	pkPeer->EncodeWORD(wSize);
+	if (pVec && !pVec->empty())
+		pkPeer->Encode(&(*pVec)[0], sizeof(TPacketGDEmote) * wSize);
+}
+
+void CClientManager::QUERY_EMOTE_CLEAR(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
+{
+	if (pTable == nullptr)
+		return;
+
+	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
+	if (it != m_map_kPlayerEmote.end())
+		it->second.clear();
+
+	QUERY_EMOTE_LOAD(pkPeer, dwHandle, pTable);
+}
+
+void CClientManager::QUERY_EMOTE_ADD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
+{
+	if (!pkPeer || !pTable)
+		return;
+
+	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
+
+	TPacketGDEmote GDPacket;
+	GDPacket.dwPID = pTable->dwPID;
+	GDPacket.dwVnum = pTable->dwVnum;
+	GDPacket.dwDuration = dwCurrentTime + pTable->dwDuration;
+
+	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
+	if (it != m_map_kPlayerEmote.end())
+	{
+		TEmoteTableVector& rkVec = it->second;
+		if (rkVec.size() >= SPECIAL_ACTION_SLOT_COUNT)
+		{
+			TPacketGDEmote& rkTable = rkVec[number(0, rkVec.size() - 1)];
+			if (dwCurrentTime >= rkTable.dwDuration)
+				rkTable.dwDuration = dwCurrentTime + pTable->dwDuration;
+			else
+				rkTable.dwDuration += pTable->dwDuration;
+
+			GDPacket.dwVnum = rkTable.dwVnum;
+			GDPacket.dwDuration = rkTable.dwDuration;
+		}
+		else
+		{
+			TEmoteTableVector::iterator itVec = std::find_if(rkVec.begin(), rkVec.end(),
+				[pTable](const TPacketGDEmote& rkTable)
+				{
+					return rkTable.dwVnum == pTable->dwVnum;
+				});
+
+			if (itVec != rkVec.end())
+			{
+				if (dwCurrentTime >= itVec->dwDuration)
+					itVec->dwDuration = dwCurrentTime + pTable->dwDuration;
+				else
+					itVec->dwDuration += pTable->dwDuration;
+
+				GDPacket.dwDuration = itVec->dwDuration;
+			}
+			else
+			{
+				pTable->dwDuration = GDPacket.dwDuration;
+				rkVec.emplace_back(*pTable);
+			}
+		}
+	}
+	else
+	{
+		pTable->dwDuration = GDPacket.dwDuration;
+		m_map_kPlayerEmote[pTable->dwPID].emplace_back(*pTable);
+	}
+
+	pkPeer->EncodeHeader(HEADER_DG_EMOTE_GET, dwHandle, sizeof(GDPacket));
+	pkPeer->Encode(&GDPacket, sizeof(GDPacket));
+}
+
+void CClientManager::QUERY_EMOTE_DUMP()
+{
+	CDBManager::instance().DirectQuery("TRUNCATE TABLE `player`.`emotions`");
+
+	if (m_map_kPlayerEmote.empty())
+		return;
+
+	char szQuery[1024];
+	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
+
+	for (TPlayerEmoteMap::value_type& it : m_map_kPlayerEmote)
+	{
+		TEmoteTableVector& rkVec = it.second;
+		if (rkVec.empty())
+			continue;
+
+		rkVec.erase(std::remove_if(rkVec.begin(), rkVec.end(),
+			[dwCurrentTime](const TPacketGDEmote& rkTable)
+			{
+				return dwCurrentTime > rkTable.dwDuration;
+			}
+		), rkVec.end());
+
+		for (const TPacketGDEmote& rkTable : rkVec)
+		{
+			snprintf(szQuery, sizeof(szQuery),
+				"REPLACE INTO emotions%s (`pid`, `vnum`, `duration`) VALUES(%d, %d, FROM_UNIXTIME(%d))",
+				GetTablePostfix(), rkTable.dwPID, rkTable.dwVnum, rkTable.dwDuration
+			);
+
+			std::unique_ptr<SQLMsg> pkInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+}
+#endif
+
+#if defined(__MAILBOX__)
+void CClientManager::QUERY_MAILBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	if (g_log)
+		sys_log(0, "QUERY_MAILBOX (handle: %d ch: %s)", dwHandle, p->szName);
+
+	std::vector<SMailBoxTable>* vec = nullptr;
+	auto it = m_map_mailbox.find(p->szName);
+	if (it != m_map_mailbox.end())
+		vec = &it->second;
+
+	if (vec)
+	{
+		const time_t now = std::time(nullptr);
+
+		vec->erase(std::remove_if(vec->begin(), vec->end(),
+			[now](const TMailBoxTable& mail)
+			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
+		), vec->end());
+
+		std::sort(vec->begin(), vec->end(),
+			[](const TMailBoxTable& l, const TMailBoxTable& r)
+			{
+				return l.Message.SendTime > r.Message.SendTime;
+			});
+	}
+
+	const WORD size = vec ? static_cast<WORD>(vec->size()) : 0;
+	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(SMailBoxTable) * size;
+
+	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_LOAD, dwHandle, dwPacketSize);
+	pkPeer->EncodeWORD(sizeof(SMailBoxTable));
+	pkPeer->EncodeWORD(size);
+
+	if (vec && vec->empty() == false)
+		pkPeer->Encode(&(*vec)[0], sizeof(SMailBoxTable) * size);
+}
+
+void CClientManager::QUERY_MAILBOX_CHECK_NAME(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	TMailBox t;
+	std::memcpy(t.szName, "", sizeof(t.szName));
+	t.Index = 0; // Index: Mail Count
+
+	static std::unordered_set<std::string> NameSet;
+	bool bFound = NameSet.find(p->szName) != NameSet.end();
+
+	if (bFound == false)
+	{
+		char s_szQuery[128];
+		//snprintf(s_szQuery, sizeof(s_szQuery), "SELECT * FROM player%s WHERE `name` = '%s' LIMIT 1", GetTablePostfix(), p->szName);
+		snprintf(s_szQuery, sizeof(s_szQuery), "SELECT * FROM player%s WHERE `name` = convert('%s' using utf8mb4) collate utf8mb4_bin LIMIT 1", GetTablePostfix(), p->szName);
+		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(s_szQuery));
+		bFound = pMsg->Get()->uiNumRows > 0;
+	}
+
+	if (bFound)
+	{
+		NameSet.emplace(p->szName); // player exists, next time we will use this to avoid using mysql.
+		std::memcpy(t.szName, p->szName, sizeof(t.szName));
+		auto it = m_map_mailbox.find(p->szName);
+		if (it != m_map_mailbox.end())
+		{
+			const time_t now = time(nullptr);
+			for (const SMailBoxTable& mail : it->second)
+			{
+				if (mail.bIsDeleted)
+					continue;
+
+				if (std::difftime(mail.Message.DeleteTime, now) <= 0)
+					continue;
+
+				t.Index++;
+			}
+		}
+	}
+
+	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_CHECK_NAME, dwHandle, sizeof(TMailBox));
+	pkPeer->Encode(&t, sizeof(TMailBox));
+}
+
+void CClientManager::QUERY_MAILBOX_WRITE(CPeer* pkPeer, DWORD dwHandle, TMailBoxTable* p)
+{
+	m_map_mailbox[p->szName].emplace_back(*p);
+}
+
+bool CClientManager::GET_MAIL(const char* name, const BYTE index, SMailBoxTable** mail)
+{
+	auto it = m_map_mailbox.find(name);
+	if (it == m_map_mailbox.end())
+		return false;
+
+	MailVec& mailvec = it->second;
+	if (index >= mailvec.size())
+		return false;
+
+	*mail = &mailvec.at(index);
+	return true;
+}
+
+void CClientManager::QUERY_MAILBOX_DELETE(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	SMailBoxTable* mail = nullptr;
+	if (GET_MAIL(p->szName, p->Index, &mail) == false)
+		return;
+
+	mail->bIsDeleted = true;
+}
+
+void CClientManager::QUERY_MAILBOX_CONFIRM(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	SMailBoxTable* mail = nullptr;
+	if (GET_MAIL(p->szName, p->Index, &mail) == false)
+		return;
+
+	mail->Message.bIsConfirm = true;
+}
+
+void CClientManager::QUERY_MAILBOX_GET(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	SMailBoxTable* mail = nullptr;
+	if (GET_MAIL(p->szName, p->Index, &mail) == false)
+		return;
+
+	mail->AddData.iYang = 0;
+	mail->AddData.iWon = 0;
+	mail->Message.bIsItemExist = false;
+	mail->Message.bIsConfirm = true;
+	mail->AddData.dwItemVnum = 0;
+	mail->AddData.dwItemCount = 0;
+	memset(mail->AddData.alSockets, 0, sizeof(mail->AddData.alSockets));
+	memset(mail->AddData.aAttr, 0, sizeof(mail->AddData.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	mail->AddData.dwChangeLookVnum = 0;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	memset(&mail->AddData.RefineElement, 0, sizeof(mail->AddData.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	memset(mail->AddData.aApplyRandom, 0, sizeof(mail->AddData.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+	mail->AddData.bSetValue = 0;
+#endif
+}
+
+void CClientManager::QUERY_MAILBOX_UNREAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	auto it = m_map_mailbox.find(p->szName);
+	if (it == m_map_mailbox.end())
+		return;
+
+	const MailVec& mailvec = it->second;
+	if (mailvec.empty())
+		return;
+
+	const time_t now = time(nullptr);
+	TMailBoxRespondUnreadData t;
+
+	for (const SMailBoxTable& mail : it->second)
+	{
+		if (mail.bIsDeleted)
+			continue;
+
+		if (mail.Message.bIsConfirm)
+			continue;
+
+		if (std::difftime(mail.Message.DeleteTime, now) <= 0)
+			continue;
+
+		if (mail.Message.bIsGMPost)
+			t.bGMVisible = true;
+
+		if (mail.Message.bIsItemExist)
+			t.bItemMessageCount++;
+		else
+			t.bCommonMessageCount++;
+	}
+
+	if ((t.bItemMessageCount + t.bCommonMessageCount) < 1)
+		return;
+
+	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_UNREAD, dwHandle, sizeof(TMailBoxRespondUnreadData));
+	pkPeer->Encode(&t, sizeof(TMailBoxRespondUnreadData));
+}
+
+void CClientManager::MAILBOX_BACKUP()
+{
+	CDBManager::instance().DirectQuery("TRUNCATE TABLE player.mailbox");
+
+	if (m_map_mailbox.empty())
+		return;
+
+	char szQuery[QUERY_MAX_LEN];
+	const time_t now = std::time(nullptr);
+
+	for (auto& p : m_map_mailbox)
+	{
+		auto& mailvec = p.second;
+		if (mailvec.empty())
+			continue;
+
+		mailvec.erase(std::remove_if(mailvec.begin(), mailvec.end(),
+			[now](const TMailBoxTable& mail)
+			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
+		), mailvec.end());
+
+		std::sort(mailvec.begin(), mailvec.end(),
+			[](const TMailBoxTable& l, const TMailBoxTable& r)
+			{
+				return l.Message.SendTime > r.Message.SendTime;
+			});
+
+		for (const auto& mail : mailvec)
+		{
+			snprintf(szQuery, sizeof(szQuery),
+				"INSERT INTO `mailbox%s` (`name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`"
+				", `gold`, `won`, `vnum`, `count`"
+				", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+				", `socket3`, `socket4`, `socket5`"
+#endif
+				", `attrtype0`, `attrvalue0`"
+				", `attrtype1`, `attrvalue1`"
+				", `attrtype2`, `attrvalue2`"
+				", `attrtype3`, `attrvalue3`"
+				", `attrtype4`, `attrvalue4`"
+				", `attrtype5`, `attrvalue5`"
+				", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				", `changelookvnum`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				", `refine_element_apply_type`"
+				", `refine_element_grade`"
+				", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+				", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+				", `apply_type0`, `apply_value0`, `apply_path0`"
+				", `apply_type1`, `apply_value1`, `apply_path1`"
+				", `apply_type2`, `apply_value2`, `apply_path2`"
+				", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+				", `set_value`"
+#endif
+				") VALUES ('%s', '%s', '%s', '%s', %d, %d, %d, %d" // `name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`
+				", %u, %u, %u, %u" // `gold`, `won`, `vnum`, `count`
+				", %ld, %ld, %ld" // `socket0`, `socket1`, `socket2`
+#if defined(__ITEM_SOCKET6__)
+				", %ld, %ld, %ld" // `socket3`, `socket4`, `socket5`
+#endif
+				", %u, %ld" // `attrtype0`, `attrvalue0`
+				", %u, %ld" // `attrtype1`, `attrvalue1`
+				", %u, %ld" // `attrtype2`, `attrvalue2`
+				", %u, %ld" // `attrtype3`, `attrvalue3`
+				", %u, %ld" // `attrtype4`, `attrvalue4`
+				", %u, %ld" // `attrtype5`, `attrvalue5`
+				", %u, %ld" // `attrtype6`, `attrvalue6`
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				", %u" // `changelookvnum`
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				", %u" // `refine_element_apply_type`
+				", %u" // `refine_element_grade`
+				", %u, %u, %u" // `refine_element_value0`, `refine_element_value1`, `refine_element_value2`
+				", %u, %u, %u" // `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+				", %u, %ld, %d" // `apply_type0`, `apply_value0`, `apply_path0`
+				", %u, %ld, %d" // `apply_type1`, `apply_value1`, `apply_path1`
+				", %u, %ld, %d" // `apply_type2`, `apply_value2`, `apply_path2`
+				", %u, %ld, %d" // `apply_type3`, `apply_value3`, `apply_path3`
+#endif
+#if defined(__SET_ITEM__)
+				", %d" // `set_value`
+#endif
+				")", GetTablePostfix()
+				, mail.szName
+				, mail.AddData.szFrom
+				, mail.Message.szTitle
+				, mail.AddData.szMessage
+				, mail.Message.bIsGMPost
+				, mail.Message.bIsConfirm
+				, mail.Message.SendTime
+				, mail.Message.DeleteTime
+				, mail.AddData.iYang
+				, mail.AddData.iWon
+				, mail.AddData.dwItemVnum
+				, mail.AddData.dwItemCount
+				, mail.AddData.alSockets[0], mail.AddData.alSockets[1], mail.AddData.alSockets[2]
+#if defined(__ITEM_SOCKET6__)
+				, mail.AddData.alSockets[3], mail.AddData.alSockets[4], mail.AddData.alSockets[5]
+#endif
+				, mail.AddData.aAttr[0].wType, mail.AddData.aAttr[0].lValue
+				, mail.AddData.aAttr[1].wType, mail.AddData.aAttr[1].lValue
+				, mail.AddData.aAttr[2].wType, mail.AddData.aAttr[2].lValue
+				, mail.AddData.aAttr[3].wType, mail.AddData.aAttr[3].lValue
+				, mail.AddData.aAttr[4].wType, mail.AddData.aAttr[4].lValue
+				, mail.AddData.aAttr[5].wType, mail.AddData.aAttr[5].lValue
+				, mail.AddData.aAttr[6].wType, mail.AddData.aAttr[6].lValue
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				, mail.AddData.dwChangeLookVnum
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				, mail.AddData.RefineElement.wApplyType
+				, mail.AddData.RefineElement.bGrade
+				, mail.AddData.RefineElement.abValue[0], mail.AddData.RefineElement.abValue[1], mail.AddData.RefineElement.abValue[2]
+				, mail.AddData.RefineElement.abBonusValue[0], mail.AddData.RefineElement.abBonusValue[1], mail.AddData.RefineElement.abBonusValue[2]
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+				, mail.AddData.aApplyRandom[0].wType, mail.AddData.aApplyRandom[0].lValue, mail.AddData.aApplyRandom[0].bPath
+				, mail.AddData.aApplyRandom[1].wType, mail.AddData.aApplyRandom[1].lValue, mail.AddData.aApplyRandom[1].bPath
+				, mail.AddData.aApplyRandom[2].wType, mail.AddData.aApplyRandom[2].lValue, mail.AddData.aApplyRandom[2].bPath
+				, mail.AddData.aApplyRandom[3].wType, mail.AddData.aApplyRandom[3].lValue, mail.AddData.aApplyRandom[3].bPath
+#endif
+#if defined(__SET_ITEM__)
+				, mail.AddData.bSetValue
+#endif
+			);
+
+			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+}
+#endif
+
+#if defined(__GEM_SHOP__)
+void CClientManager::LoadGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopLoad* pTable, bool bUpdate)
+{
+	if (g_log)
+		sys_log(0, "LoadGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
+
+	TGemShopTable GemShopTable = {};
+#	if defined(__CONQUEROR_LEVEL__)
+	GemShopTable.bSpecial = pTable->bSpecial;
+	if (GemShopTable.bSpecial)
+	{
+		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
+		if (it != m_mapGemShopSpecialTable.end())
+			GemShopTable = it->second;
+	}
+	else
+#	endif
+	{
+		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
+		if (it != m_mapGemShopTable.end())
+			GemShopTable = it->second;
+	}
+
+	pPeer->EncodeHeader(bUpdate ? HEADER_DG_GEM_SHOP_UPDATE : HEADER_DG_GEM_SHOP_LOAD, dwHandle, sizeof(GemShopTable));
+	pPeer->Encode(&GemShopTable, sizeof(GemShopTable));
+}
+
+void CClientManager::UpdateGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopTable* pTable)
+{
+	if (g_log)
+		sys_log(0, "UpdateGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
+
+#	if defined(__CONQUEROR_LEVEL__)
+	if (pTable->bSpecial)
+	{
+		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
+		if (it != m_mapGemShopSpecialTable.end())
+			it->second = *pTable;
+		else
+			m_mapGemShopSpecialTable.emplace(std::make_pair(pTable->dwPID, *pTable));
+	}
+	else
+#	endif
+	{
+		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
+		if (it != m_mapGemShopTable.end())
+			it->second = *pTable;
+		else
+			m_mapGemShopTable.emplace(std::make_pair(pTable->dwPID, *pTable));
+	}
+
+	// NOTE : Request Gem Shop Load
+	TGemShopLoad Packet;
+	Packet.dwPID = pTable->dwPID;
+#	if defined(__CONQUEROR_LEVEL__)
+	Packet.bSpecial = pTable->bSpecial;
+#	endif
+	LoadGemShop(pPeer, dwHandle, &Packet, true);
+}
+
+void CClientManager::FlushGemShop()
+{
+	// Flush Default Gem Shop Table
+	{
+		if (m_mapGemShopTable.empty())
+			return;
+
+		char szQuery[1024] = {};
+		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop%s`", GetTablePostfix());
+		CDBManager::instance().DirectQuery(szQuery);
+
+		GemShopTableMap::iterator it = m_mapGemShopTable.begin();
+		for (; it != m_mapGemShopTable.end(); ++it)
+		{
+			TGemShopTable GemShopTable = it->second;
+			if (it->first != GemShopTable.dwPID)
+				continue;
+
+			char szColumns[1024] = {};
+			char szValues[1024] = {};
+
+			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
+			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
+
+			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
+			{
+				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
+					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
+				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
+					GemShopTable.GemShopItem[bSlotIndex].bEnable,
+					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
+					GemShopTable.GemShopItem[bSlotIndex].bCount,
+					GemShopTable.GemShopItem[bSlotIndex].dwPrice
+				);
+			}
+
+			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop%s` (%s) VALUES(%s)",
+				GetTablePostfix(), szColumns, szValues);
+
+			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+
+#	if defined(__CONQUEROR_LEVEL__)
+	// Flush Port (Special) Gem Shop Table
+	{
+		if (m_mapGemShopSpecialTable.empty())
+			return;
+
+		char szQuery[1024] = {};
+		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop_port%s`", GetTablePostfix());
+		CDBManager::instance().DirectQuery(szQuery);
+
+		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.begin();
+		for (; it != m_mapGemShopSpecialTable.end(); ++it)
+		{
+			TGemShopTable GemShopTable = it->second;
+			if (it->first != GemShopTable.dwPID)
+				continue;
+
+			char szColumns[1024] = {};
+			char szValues[1024] = {};
+
+			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
+			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
+
+			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
+			{
+				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
+					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
+				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
+					GemShopTable.GemShopItem[bSlotIndex].bEnable,
+					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
+					GemShopTable.GemShopItem[bSlotIndex].bCount,
+					GemShopTable.GemShopItem[bSlotIndex].dwPrice
+				);
+			}
+
+			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop_port%s` (%s) VALUES(%s)",
+				GetTablePostfix(), szColumns, szValues);
+
+			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+#	endif
+}
+#endif
+
+#ifdef __OFFLINE_SHOP__
+void CClientManager::InitializeNextOfflineShopId()
+{
+	std::stringstream query;
+	query << "SELECT MAX(id) + 1 FROM offline_shop" << GetTablePostfix();
+
+	std::unique_ptr<SQLMsg> msg(CDBManager::Instance().DirectQuery(query.str().c_str()));
+	if (msg && msg->Get()->uiNumRows > 0) {
+		auto row = mysql_fetch_row(msg->Get()->pSQLResult);
+		str_to_number(nextOfflineShopId_, row[0]);
+	}
+	else {
+		nextOfflineShopId_ = 1;
+	}
+
+	sys_log(0, "Next offline shop id: %u", nextOfflineShopId_);
+}
+
+void CClientManager::RequestOfflineShopId(CPeer* peer, uint32_t queueId)
+{
+	peer->EncodeHeader(HEADER_DG_RESPOND_OFFLINE_SHOP_ID, 0, sizeof(uint32_t) + sizeof(uint32_t));
+	peer->Encode(&queueId, sizeof(uint32_t));
+	peer->Encode(&nextOfflineShopId_, sizeof(uint32_t));
+
+	nextOfflineShopId_++;
+}
+
+void CClientManager::SaveOfflineShop(const TOfflineShop& data, bool skipQuery)
+{
+	auto it = offlineShopCache_.find(data.id);
+	if (it != offlineShopCache_.end()) {
+		it->second->Put(&data);
+	}
+	else {
+		auto cache = std::unique_ptr<COfflineShopCache>(new COfflineShopCache());
+		cache->Put(&data, skipQuery);
+
+		offlineShopCache_.insert(std::make_pair(data.id, std::move(cache)));
+	}
+}
+
+void CClientManager::SaveOfflineShopItem(const TOfflineShopItem& data, bool skipQuery)
+{
+	auto it = offlineShopItemCache_.find(data.id);
+	if (it != offlineShopItemCache_.end()) {
+		it->second->Put(&data);
+	}
+	else {
+		auto cache = std::unique_ptr<COfflineShopItemCache>(new COfflineShopItemCache());
+		cache->Put(&data, skipQuery);
+
+		offlineShopItemCache_.insert(std::make_pair(data.id, std::move(cache)));
+	}
+}
+
+void CClientManager::DestroyOfflineShop(uint32_t id)
+{
+	auto it = offlineShopCache_.find(id);
+	if (it != offlineShopCache_.end()) {
+		offlineShopCache_.erase(it);
+	}
+
+	std::pair<uint32_t, uint16_t> key = { id, 0 };
+	for (uint16_t i = 0; i < OFFLINE_SHOP_ITEM_COUNT; ++i) {
+		key.second = i;
+
+		auto it = offlineShopItemCache_.find(key);
+		if (it != offlineShopItemCache_.end()) {
+			offlineShopItemCache_.erase(it);
+		}
+	}
+
+	std::stringstream queryDeleteOfflineShop;
+	queryDeleteOfflineShop << "DELETE FROM offline_shop" << GetTablePostfix() << " WHERE id = " << id;
+	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShop.str().c_str());
+
+	std::stringstream queryDeleteOfflineShopItems;
+	queryDeleteOfflineShopItems << "DELETE FROM offline_shop_item" << GetTablePostfix() << " WHERE owner_pid = " << id;
+	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShopItems.str().c_str());
+}
+
+void CClientManager::UpdateOfflineShopCache()
+{
+	auto it = offlineShopCache_.begin();
+	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopCache_.end()) {
+		if (it->second->CheckFlushTimeout()) {
+			it->second->Flush();
+
+			m_iCacheFlushCount++;
+		}
+
+		it++;
+	}
+}
+
+void CClientManager::UpdateOfflineShopItemCache()
+{
+	auto it = offlineShopItemCache_.begin();
+	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopItemCache_.end()) {
+		if (it->second->CheckFlushTimeout()) {
+			it->second->Flush();
+
+			m_iCacheFlushCount++;
+		}
+
+		it++;
+	}
+}
+
+void CClientManager::FlushOfflineShops()
+{
+	for (auto it = offlineShopCache_.begin(); it != offlineShopCache_.end(); ++it) {
+		it->second->Flush();
+	}
+
+	for (auto it = offlineShopItemCache_.begin(); it != offlineShopItemCache_.end(); ++it) {
+		it->second->Flush();
+	}
+}
+
+const TItemTable* CClientManager::GetItemTable(DWORD vnum) const
+{
+	auto it = m_map_itemTableByVnum.find(vnum);
+	if (it == m_map_itemTableByVnum.end())
+	{
+		return NULL;
+	}
+
+	return it->second;
+}
+
+BYTE CClientManager::GetRealItemType(DWORD vnum)
+{
+	if (vnum >= 110000 && vnum <= 165499)
+		return ITEM_DS;
+	
+	
+	/* SHIT :
+	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
+	{
+		if (it->second->dwVnum == vnum)
+		{
+			return it->second->bType;
+		}
+	}
+	*/
+	
+	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
+	{
+		if (it->dwVnum == vnum)
+		{
+			return it->bType;
+		}
+	}
+	
+	return ITEM_NONE;
+}
+
+BYTE CClientManager::GetRealItemSubType(DWORD vnum)
+{
+	/* SHIT:
+	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
+	{
+		if (it->second->dwVnum == vnum)
+		{
+			return it->second->bSubType;
+		}
+	}
+	*/
+	
+	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
+	{
+		if (it->dwVnum == vnum)
+		{
+			return it->bSubType;
+		}
+	}
+	
+	return 0;
+}
+
+void CClientManager::GetRealItemLimit(DWORD vnum, int & limitType, DWORD & limitValue)
+{
+	/* BUGGED SHIT :
+	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
+	{
+		if (it->second->dwVnum == vnum)
+		{
+			limitType = it->second->aLimits[0].bType;
+			limitValue = it->second->aLimits[0].lValue;
+			return;
+		}
+	}
+	*/
+	
+	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
+	{
+		if (it->dwVnum == vnum)
+		{
+			limitType = it->aLimits[0].bType;
+			limitValue = it->aLimits[0].lValue;
+			return;
+		}
+	}
+}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+CClientManager::TGrowthPetCacheSet* CClientManager::GetGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+		return nullptr;
+
+	return it->second;
+}
+
+void CClientManager::CreateGrowthPetCacheSet(DWORD pid)
+{
+	if (m_map_pkGrowthPetCacheSetPtr.find(pid) != m_map_pkGrowthPetCacheSetPtr.end())
+		return;
+				 
+	TGrowthPetCacheSet* pSet = new TGrowthPetCacheSet;
+	m_map_pkGrowthPetCacheSetPtr.insert(TGrowthPetCacheSetPtrMap::value_type(pid, pSet));
+
+	if (g_log)
+		sys_log(0, "GROWTH_PET_CACHE: new cache %u", pid);
+}
+
+void CClientManager::FlushGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : No GrowthPetCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TGrowthPetCacheSet* pSet = it->second;
+	auto it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CGrowthPetCache* c = *it_set++;
+		c->Flush();
+
+		m_map_growthPetCache.erase(c->Get()->dwID);
+		delete c;
+	}
+
+	pSet->clear();
+	delete pSet;
+
+	m_map_pkGrowthPetCacheSetPtr.erase(it);
+
+	if (g_log)
+		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : Deleted pid(%d)", pid);
+}
+
+CGrowthPetCache* CClientManager::GetGrowthPetCache(DWORD id)
+{
+	auto it = m_map_growthPetCache.find(id);
+
+	if (it == m_map_growthPetCache.end())
+		return nullptr;
+
+	return it->second;
+}
+
+void CClientManager::PutGrowthPetCache(TGrowthPet* pNew, bool bSkipQuery)
+{
+	CGrowthPetCache* c;
+
+	c = GetGrowthPetCache(pNew->dwID);
+	if (!c)
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> New CGrowthPetCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
+
+		c = new CGrowthPetCache;
+		m_map_growthPetCache.insert(TGrowthPetCacheMap::value_type(pNew->dwID, c));
+	}
+	else
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> Have Cache");
+		if (pNew->dwOwner != c->Get()->dwOwner)
+		{
+			auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
+
+			if (it != m_map_pkGrowthPetCacheSetPtr.end())
+			{
+				if (g_log)
+					sys_log(0, "GROWTH_PET_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
+				it->second->erase(c);
+			}
+		}
+	}
+	c->Put(pNew, bSkipQuery);
+
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
+
+	if (it != m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		it->second->insert(c);
+	}
+	else
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+
+		c->OnFlush();
+	}
+}
+
+bool CClientManager::DeleteGrowthPetCache(DWORD dwID)
+{
+	CGrowthPetCache* c = GetGrowthPetCache(dwID);
+
+	if (!c)
+		return false;
+
+	c->Delete();
+	return true;
+}
+
+void CClientManager::UpdateGrowthPetCache()
+{
+	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+		return;
+
+	auto it = m_map_growthPetCache.begin();
+
+	while (it != m_map_growthPetCache.end())
+	{
+		CGrowthPetCache* c = (it++)->second;
+
+		if (c->CheckFlushTimeout())
+		{
+			if (g_test_server)
+				sys_log(0, "UpdateGrowthPetCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
+
+			c->Flush();
+
+			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+				break;
+		}
+	}
+}
+
+void CClientManager::UpdateGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		if (g_test_server)
+			sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet ==> No GrowthPetCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TGrowthPetCacheSet* pSet = it->second;
+	auto it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CGrowthPetCache* c = *it_set++;
+		c->Flush();
+	}
+
+	if (g_log)
+		sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet pid(%d)", pid);
+}
+
+void CClientManager::QUERY_GROWTH_PET_SAVE(CPeer* pkPeer, const char* c_pData)
+{
+	TGrowthPet* p = (TGrowthPet*)c_pData;
+	if (g_test_server)
+		sys_log(0, "QUERY_GROWTH_PET_SAVE => PutGrowthPetCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
+
+	PutGrowthPetCache(p);
+}
+
+void CClientManager::QUERY_GROWTH_PET_DELETE(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwID = *(DWORD*)c_pData;
+	c_pData += sizeof(DWORD);
+
+	DWORD dwPID = *(DWORD*)c_pData;
+
+	if (!DeleteGrowthPetCache(dwID))
+	{
+		char szQuery[64];
+		snprintf(szQuery, sizeof(szQuery), "DELETE FROM growth_pet%s WHERE id=%u", GetTablePostfix(), dwID);
+
+		if (dwPID == 0)
+			CDBManager::instance().AsyncQuery(szQuery);
+		else
+			CDBManager::instance().ReturnQuery(szQuery, QID_GROWTH_PET_DELETE, pkPeer->GetHandle(), NULL);
+	}
+}
+
+bool CClientManager::CreateGrowthPetTableFromRes(MYSQL_RES* res, std::vector<TGrowthPet>* pVec, DWORD dwPID)
+{
+	if (!res)
+	{
+		pVec->clear();
+		return true;
+	}
+
+	int rows;
+
+	if ((rows = mysql_num_rows(res)) <= 0)
+	{
+		pVec->clear();
+		return true;
+	}
+
+	pVec->resize(rows);
+
+	for (int i = 0; i < rows; ++i)
+	{
+		MYSQL_ROW row = mysql_fetch_row(res);
+		TGrowthPet& pet = pVec->at(i);
+
+		int cur = 0;
+
+		str_to_number(pet.dwID, row[cur++]);
+		str_to_number(pet.dwVnum, row[cur++]);
+		str_to_number(pet.bState, row[cur++]);
+		strlcpy(pet.szName, row[cur++], sizeof(pet.szName));
+		str_to_number(pet.bSize, row[cur++]);
+		str_to_number(pet.dwLevel, row[cur++]);
+		str_to_number(pet.bLevelStep, row[cur++]);
+		str_to_number(pet.bEvolution, row[cur++]);
+		str_to_number(pet.bType, row[cur++]);
+		str_to_number(pet.dwHP, row[cur++]);
+		str_to_number(pet.dwSP, row[cur++]);
+		str_to_number(pet.dwDef, row[cur++]);
+		str_to_number(pet.dwHPApply, row[cur++]);
+		str_to_number(pet.dwSPApply, row[cur++]);
+		str_to_number(pet.dwDefApply, row[cur++]);
+		str_to_number(pet.dwAgeApply, row[cur++]);
+		thecore_memcpy(pet.aSkill, row[cur++], sizeof(pet.aSkill));
+		str_to_number(pet.lExp, row[cur++]);
+		str_to_number(pet.lItemExp, row[cur++]);
+		str_to_number(pet.lBirthday, row[cur++]);
+		str_to_number(pet.lEndTime, row[cur++]);
+		str_to_number(pet.lMaxTime, row[cur++]);
+
+		pet.dwOwner = dwPID;
+	}
+
+	return true;
+}
+
+void CClientManager::RESULT_GROWTH_PET_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID)
+{
+	static std::vector<TGrowthPet> s_petVec;
+	CreateGrowthPetTableFromRes(pRes, &s_petVec, dwPID);
+	DWORD dwCount = s_petVec.size();
+
+	peer->EncodeHeader(HEADER_DG_GROWTH_PET_LOAD, dwHandle, sizeof(DWORD) + sizeof(TGrowthPet) * dwCount);
+	peer->EncodeDWORD(dwCount);
+
+	CreateGrowthPetCacheSet(dwPID);
+
+	sys_log(0, "GROWTH_PET_LOAD: count %u pid %u", dwCount, dwPID);
+
+	if (dwCount)
+	{
+		peer->Encode(&s_petVec[0], sizeof(TGrowthPet) * dwCount);
+
+		for (DWORD i = 0; i < dwCount; ++i)
+			PutGrowthPetCache(&s_petVec[i], true);
+	}
+}
+#endif
diff --git a/server/server/home/metin2/Source/Server/db/src/ClientManager.h b/server/server/home/metin2/Source/Server/db/src/ClientManager.h
index 3a69ab3..991c725 100644
--- a/server/server/home/metin2/Source/Server/db/src/ClientManager.h
+++ b/server/server/home/metin2/Source/Server/db/src/ClientManager.h
@@ -1,707 +1,704 @@
-#ifndef __INC_CLIENTMANAGER_H__
-#define __INC_CLIENTMANAGER_H__
-
-#include <boost/unordered_map.hpp>
-#include <boost/unordered_set.hpp>
-#include <memory>
-
-#include <unordered_map>
-#include <unordered_set>
-#include "Cache.h"
-
-#include "../../common/stl.h"
-#include "../../common/building.h"
-
-#include "Peer.h"
-#include "DBManager.h"
-#include "LoginData.h"
-
-class CPlayerTableCache;
-class CItemCache;
-class CItemPriceListTableCache;
-#ifdef __GROWTH_PET_SYSTEM__
-class CGrowthPetCache;
-#endif
-// typedef std::map<int, int> PacketInfoMap;
-
-class CPacketInfo
-{
-public:
-	void Add(int header);
-	void Reset();
-
-	// PacketInfoMap m_map_info;
-	std::map<int, int> m_map_info;
-};
-
-size_t CreatePlayerSaveQuery(char* pszQuery, size_t querySize, TPlayerTable* pkTab);
-
-// typedef std::vector<TItemTable> ItemTableVector;
-// typedef std::vector<TMobTable> MobTableVector;
-// typedef std::map<DWORD, building::TObject*> pkObjectTableMap;
-// typedef std::map<DWORD, TItemTable*> ItemTableVNumMap;
-
-class CClientManager : public CNetBase, public singleton<CClientManager>
-{
-public:
-	typedef std::list<CPeer*> TPeerList;
-	typedef std::unordered_map<DWORD, CPlayerTableCache*> TPlayerTableCacheMap;
-	typedef std::unordered_map<DWORD, CItemCache*> TItemCacheMap;
-	typedef std::unordered_set<CItemCache*, std::hash<CItemCache*> > TItemCacheSet;
-	typedef std::unordered_map<DWORD, TItemCacheSet*> TItemCacheSetPtrMap;
-	typedef std::unordered_map<DWORD, CItemPriceListTableCache*> TItemPriceListCacheMap;
-	typedef std::unordered_map<short, BYTE> TChannelStatusMap;
-
-#ifdef __GROWTH_PET_SYSTEM__
-	typedef boost::unordered_map<DWORD, CGrowthPetCache*> TGrowthPetCacheMap;
-	typedef boost::unordered_set<CGrowthPetCache*, boost::hash<CGrowthPetCache*> > TGrowthPetCacheSet;
-	typedef boost::unordered_map<DWORD, TGrowthPetCacheSet*> TGrowthPetCacheSetPtrMap;
-#endif
-
-	// MYSHOP_PRICE_LIST
-	/// 아이템 가격정보 리스트 요청 정보
-	/**
-	* first: Peer handle
-	* second: 요청한 플레이어의 ID
-	**/
-	typedef std::pair< DWORD, DWORD > TItemPricelistReqInfo;
-	// END_OF_MYSHOP_PRICE_LIST
-
-	class ClientHandleInfo
-	{
-	public:
-		DWORD dwHandle;
-		DWORD account_id;
-		DWORD player_id;
-		BYTE account_index;
-		char login[LOGIN_MAX_LEN + 1];
-		char safebox_password[SAFEBOX_PASSWORD_MAX_LEN + 1];
-		char ip[MAX_HOST_LENGTH + 1];
-
-		TAccountTable* pAccountTable;
-		TSafeboxTable* pSafebox;
-
-		ClientHandleInfo(DWORD argHandle, DWORD dwPID = 0)
-		{
-			dwHandle = argHandle;
-			pSafebox = NULL;
-			pAccountTable = NULL;
-			player_id = dwPID;
-		};
-
-		// 독일선물기능용 생성자
-		ClientHandleInfo(DWORD argHandle, DWORD dwPID, DWORD accountId)
-		{
-			dwHandle = argHandle;
-			pSafebox = NULL;
-			pAccountTable = NULL;
-			player_id = dwPID;
-			account_id = accountId;
-		};
-
-		~ClientHandleInfo()
-		{
-			if (pSafebox)
-			{
-				delete pSafebox;
-				pSafebox = NULL;
-			}
-		}
-	};
-
-public:
-	CClientManager();
-	~CClientManager();
-
-	bool Initialize();
-	time_t GetCurrentTime();
-
-	void MainLoop();
-	void Quit();
-
-	void SetTablePostfix(const char* c_pszTablePostfix);
-	void SetPlayerIDStart(int iIDStart);
-	int GetPlayerIDStart() { return m_iPlayerIDStart; }
-
-	int GetPlayerDeleteLevelLimit() { return m_iPlayerDeleteLevelLimit; }
-
-	void SetChinaEventServer(bool flag) { m_bChinaEventServer = flag; }
-	bool IsChinaEventServer() { return m_bChinaEventServer; }
-
-	DWORD GetUserCount(); // 접속된 사용자 수를 리턴 한다.
-
-	void SendAllGuildSkillRechargePacket();
-	void SendTime();
-
-	CPlayerTableCache* GetPlayerCache(DWORD id);
-	void PutPlayerCache(TPlayerTable* pNew);
-
-	void CreateItemCacheSet(DWORD dwID);
-	TItemCacheSet* GetItemCacheSet(DWORD dwID);
-	void FlushItemCacheSet(DWORD dwID);
-
-	CItemCache* GetItemCache(DWORD id);
-	void PutItemCache(TPlayerItem* pNew, bool bSkipQuery = false);
-	bool DeleteItemCache(DWORD id);
-
-	CPeer* GetPeer(IDENT ident);
-
-	void UpdatePlayerCache();
-	void UpdateItemCache();
-
-#ifdef __GROWTH_PET_SYSTEM__
-	void			CreateGrowthPetCacheSet(DWORD dwID);
-	TGrowthPetCacheSet* GetGrowthPetCacheSet(DWORD dwID);
-	void			FlushGrowthPetCacheSet(DWORD dwID);
-
-	CGrowthPetCache* GetGrowthPetCache(DWORD id);
-	void			PutGrowthPetCache(TGrowthPet* pNew, bool bSkipQuery = false);
-	bool			DeleteGrowthPetCache(DWORD dwID);
-
-	void			UpdateGrowthPetCache();
-	void			UpdateGrowthPetCacheSet(DWORD pid);
-
-	void		QUERY_GROWTH_PET_SAVE(CPeer* pkPeer, const char* c_pData);
-	void		QUERY_GROWTH_PET_DELETE(CPeer* pkPeer, const char* c_pData);
-	bool		CreateGrowthPetTableFromRes(MYSQL_RES* res, std::vector<TGrowthPet>* pVec, DWORD dwPID);
-	void		RESULT_GROWTH_PET_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
-#endif
-
-	// MYSHOP_PRICE_LIST
-	/// 가격정보 리스트 캐시를 가져온다.
-	/**
-	* @param [in] dwID 가격정보 리스트의 소유자.(플레이어 ID)
-	* @return 가격정보 리스트 캐시의 포인터
-	**/
-	CItemPriceListTableCache* GetItemPriceListCache(DWORD dwID);
-
-	/// 가격정보 리스트 캐시를 넣는다.
-	/**
-	* @param [in] pItemPriceList 캐시에 넣을 아이템 가격정보 리스트
-	*
-	* 캐시가 이미 있으면 Update 가 아닌 replace 한다.
-	**/
-	void PutItemPriceListCache(const TItemPriceListTable* pItemPriceList);
-
-	/// Flush 시간이 만료된 아이템 가격정보 리스트 캐시를 Flush 해주고 캐시에서 삭제한다.
-	void UpdateItemPriceListCache(void);
-	// END_OF_MYSHOP_PRICE_LIST
-
-	void SendGuildSkillUsable(DWORD guild_id, DWORD dwSkillVnum, bool bUsable);
-
-	void SetCacheFlushCountLimit(int iLimit);
-
-	template <class Func>
-	Func for_each_peer(Func f);
-
-	CPeer* GetAnyPeer();
-
-	void ForwardPacket(BYTE header, const void* data, int size, BYTE bChannel = 0, CPeer* except = NULL);
-
-	void SendNotice(const char* c_pszFormat, ...);
-
-	char* GetCommand(char* str, char* command); // 독일선물기능에서 명령어 얻는 함수
-	void ItemAward(CPeer* peer, char* login); // 독일 선물 기능
-
-protected:
-	void Destroy();
-
-private:
-	bool InitializeTables();
-	bool InitializeShopTable();
-
-	bool InitializeMobTable();
-	bool InitializeItemTable();
-
-	// BEGIN NPC TABLE
-	bool InitializeNpcTable();
-	// END NPC TABLE
-
-	bool InitializeQuestItemTable();
-	bool InitializeSkillTable();
-	bool InitializeRefineTable();
-	bool InitializeBanwordTable();
-	bool InitializeItemAttrTable();
-	bool InitializeItemRareTable();
-	bool InitializeLandTable();
-	bool InitializeObjectProto();
-	bool InitializeObjectTable();
-	bool InitializeMonarch();
-
-	void AddPeer(socket_t fd);
-	void RemovePeer(CPeer* pPeer);
-
-	int AnalyzeQueryResult(SQLMsg* msg);
-	int AnalyzeErrorMsg(CPeer* peer, SQLMsg* msg);
-
-	int Process();
-
-	void ProcessPackets(CPeer* peer);
-
-	CLoginData* GetLoginData(DWORD dwKey);
-	CLoginData* GetLoginDataByLogin(const char* c_pszLogin);
-	CLoginData* GetLoginDataByAID(DWORD dwAID);
-
-	void InsertLoginData(CLoginData* pkLD);
-	void DeleteLoginData(CLoginData* pkLD);
-
-	bool InsertLogonAccount(const char* c_pszLogin, DWORD dwHandle, const char* c_pszIP);
-	bool DeleteLogonAccount(const char* c_pszLogin, DWORD dwHandle);
-	bool FindLogonAccount(const char* c_pszLogin);
-
-	void GuildCreate(CPeer* peer, DWORD dwGuildID);
-	void GuildSkillUpdate(CPeer* peer, TPacketGuildSkillUpdate* p);
-	void GuildExpUpdate(CPeer* peer, TPacketGuildExpUpdate* p);
-	void GuildAddMember(CPeer* peer, TPacketGDGuildAddMember* p);
-	void GuildChangeGrade(CPeer* peer, TPacketGuild* p);
-	void GuildRemoveMember(CPeer* peer, TPacketGuild* p);
-	void GuildChangeMemberData(CPeer* peer, TPacketGuildChangeMemberData* p);
-	void GuildDisband(CPeer* peer, TPacketGuild* p);
-	void GuildWar(CPeer* peer, TPacketGuildWar* p);
-	void GuildWarScore(CPeer* peer, TPacketGuildWarScore* p);
-	void GuildChangeLadderPoint(TPacketGuildLadderPoint* p);
-	void GuildUseSkill(TPacketGuildUseSkill* p);
-	void GuildDepositMoney(TPacketGDGuildMoney* p);
-	void GuildWithdrawMoney(CPeer* peer, TPacketGDGuildMoney* p);
-	void GuildWithdrawMoneyGiveReply(TPacketGDGuildMoneyWithdrawGiveReply* p);
-	void GuildWarBet(TPacketGDGuildWarBet* p);
-	void GuildChangeMaster(TPacketChangeGuildMaster* p);
-
-	void SetGuildWarEndTime(DWORD guild_id1, DWORD guild_id2, time_t tEndTime);
-
-	void QUERY_BOOT(CPeer* peer, TPacketGDBoot* p);
-
-	void QUERY_LOGIN(CPeer* peer, DWORD dwHandle, SLoginPacket* data);
-	void QUERY_LOGOUT(CPeer* peer, DWORD dwHandle, const char*);
-
-	void RESULT_LOGIN(CPeer* peer, SQLMsg* msg);
-
-	void QUERY_PLAYER_LOAD(CPeer* peer, DWORD dwHandle, TPlayerLoadPacket*);
-	void RESULT_COMPOSITE_PLAYER(CPeer* peer, SQLMsg* pMsg, DWORD dwQID);
-	void RESULT_PLAYER_LOAD(CPeer* peer, MYSQL_RES* pRes, ClientHandleInfo* pkInfo);
-	void RESULT_ITEM_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
-	void RESULT_QUEST_LOAD(CPeer* pkPeer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
-	void RESULT_AFFECT_LOAD(CPeer* pkPeer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	void RESULT_EXT_BATTLE_PASS_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID);
-	void QUERY_SAVE_EXT_BATTLE_PASS(CPeer* peer, DWORD dwHandle, TPlayerExtBattlePassMission* battlePass);
-#endif
-
-	// PLAYER_INDEX_CREATE_BUG_FIX
-	void RESULT_PLAYER_INDEX_CREATE(CPeer* pkPeer, SQLMsg* msg);
-	// END_PLAYER_INDEX_CREATE_BUG_FIX
-
-	// MYSHOP_PRICE_LIST
-	/// 가격정보 로드 쿼리에 대한 Result 처리
-	/**
-	* @param peer 가격정보를 요청한 Game server 의 peer 객체 포인터
-	* @param pMsg 쿼리의 Result 로 받은 객체의 포인터
-	*
-	* 로드된 가격정보 리스트를 캐시에 저장하고 peer 에게 리스트를 보내준다.
-	**/
-	void RESULT_PRICELIST_LOAD(CPeer* peer, SQLMsg* pMsg);
-
-	/// 가격정보 업데이트를 위한 로드 쿼리에 대한 Result 처리
-	/**
-	* @param pMsg 쿼리의 Result 로 받은 객체의 포인터
-	*
-	* 로드된 정보로 가격정보 리스트 캐시를 만들고 업데이트 받은 가격정보로 업데이트 한다.
-	**/
-	void RESULT_PRICELIST_LOAD_FOR_UPDATE(SQLMsg* pMsg);
-	// END_OF_MYSHOP_PRICE_LIST
-
-	void QUERY_PLAYER_SAVE(CPeer* peer, DWORD dwHandle, TPlayerTable*);
-
-	void __QUERY_PLAYER_CREATE(CPeer* peer, DWORD dwHandle, TPlayerCreatePacket*);
-	void __QUERY_PLAYER_DELETE(CPeer* peer, DWORD dwHandle, TPlayerDeletePacket*);
-	void __RESULT_PLAYER_DELETE(CPeer* peer, SQLMsg* msg);
-
-	void QUERY_PLAYER_COUNT(CPeer* pkPeer, TPlayerCountPacket*);
-
-	void QUERY_ITEM_SAVE(CPeer* pkPeer, const char* c_pData);
-	void QUERY_ITEM_DESTROY(CPeer* pkPeer, const char* c_pData);
-	void QUERY_ITEM_FLUSH(CPeer* pkPeer, const char* c_pData);
-
-	void QUERY_QUEST_SAVE(CPeer* pkPeer, TQuestTable*, DWORD dwLen);
-	void QUERY_ADD_AFFECT(CPeer* pkPeer, TPacketGDAddAffect* p);
-	void QUERY_REMOVE_AFFECT(CPeer* pkPeer, TPacketGDRemoveAffect* p);
-
-	void QUERY_SAFEBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TSafeboxLoadPacket*, bool bMall);
-	void QUERY_SAFEBOX_SAVE(CPeer* pkPeer, TSafeboxTable* pTable);
-	void QUERY_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangeSizePacket* p);
-	void QUERY_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangePasswordPacket* p);
-
-	void RESULT_SAFEBOX_LOAD(CPeer* pkPeer, SQLMsg* msg);
-	void RESULT_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, SQLMsg* msg);
-	void RESULT_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, SQLMsg* msg);
-	void RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(CPeer* pkPeer, SQLMsg* msg);
-
-	void QUERY_EMPIRE_SELECT(CPeer* pkPeer, DWORD dwHandle, TEmpireSelectPacket* p);
-	void QUERY_SETUP(CPeer* pkPeer, DWORD dwHandle, const char* c_pData);
-
-	void SendPartyOnSetup(CPeer* peer);
-
-	void QUERY_HIGHSCORE_REGISTER(CPeer* peer, TPacketGDHighscore* data);
-	void RESULT_HIGHSCORE_REGISTER(CPeer* pkPeer, SQLMsg* msg);
-
-	void QUERY_FLUSH_CACHE(CPeer* pkPeer, const char* c_pData);
-
-	void QUERY_PARTY_CREATE(CPeer* peer, TPacketPartyCreate* p);
-	void QUERY_PARTY_DELETE(CPeer* peer, TPacketPartyDelete* p);
-	void QUERY_PARTY_ADD(CPeer* peer, TPacketPartyAdd* p);
-	void QUERY_PARTY_REMOVE(CPeer* peer, TPacketPartyRemove* p);
-	void QUERY_PARTY_STATE_CHANGE(CPeer* peer, TPacketPartyStateChange* p);
-	void QUERY_PARTY_SET_MEMBER_LEVEL(CPeer* peer, TPacketPartySetMemberLevel* p);
-
-	void QUERY_RELOAD_PROTO();
-
-	void QUERY_CHANGE_NAME(CPeer* peer, DWORD dwHandle, TPacketGDChangeName* p);
-	void GetPlayerFromRes(TPlayerTable* player_table, MYSQL_RES* res);
-
-	void QUERY_LOGIN_KEY(CPeer* pkPeer, TPacketGDLoginKey* p);
-
-	void AddGuildPriv(TPacketGiveGuildPriv* p);
-	void AddEmpirePriv(TPacketGiveEmpirePriv* p);
-	void AddCharacterPriv(TPacketGiveCharacterPriv* p);
-
-	void MoneyLog(TPacketMoneyLog* p);
-
-	void QUERY_AUTH_LOGIN(CPeer* pkPeer, DWORD dwHandle, TPacketGDAuthLogin* p);
-
-	void QUERY_LOGIN_BY_KEY(CPeer* pkPeer, DWORD dwHandle, TPacketGDLoginByKey* p);
-	void RESULT_LOGIN_BY_KEY(CPeer* peer, SQLMsg* msg);
-
-	void ChargeCash(const TRequestChargeCash* p);
-
-	void LoadEventFlag();
-	void SetEventFlag(TPacketSetEventFlag* p);
-	void SendEventFlagsOnSetup(CPeer* peer);
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	void LoadGuildEventFlag();
-	void GuildSetEventFlag(TPacketSetGuildEventFlag* pTable);
-	void SendGuildEventFlagsOnSetup(CPeer* pPeer);
-#endif
-
-	// 결혼
-	void MarriageAdd(TPacketMarriageAdd* p);
-	void MarriageUpdate(TPacketMarriageUpdate* p);
-	void MarriageRemove(TPacketMarriageRemove* p);
-
-	void WeddingRequest(TPacketWeddingRequest* p);
-	void WeddingReady(TPacketWeddingReady* p);
-	void WeddingEnd(TPacketWeddingEnd* p);
-
-#if defined(__MOVE_CHANNEL__)
-	void FindChannel(CPeer* pkPeer, DWORD dwHandle, TPacketChangeChannel* p);
-#endif
-
-	// MYSHOP_PRICE_LIST
-	// 개인상점 가격정보
-
-	/// 아이템 가격정보 리스트 업데이트 패킷(HEADER_GD_MYSHOP_PRICELIST_UPDATE) 처리함수
-	/**
-	* @param [in] pPacket 패킷 데이터의 포인터
-	**/
-	void MyshopPricelistUpdate(const TItemPriceListTable* pPacket);
-
-	/// 아이템 가격정보 리스트 요청 패킷(HEADER_GD_MYSHOP_PRICELIST_REQ) 처리함수
-	/**
-	* @param peer 패킷을 보낸 Game server 의 peer 객체의 포인터
-	* @param [in] dwHandle 가격정보를 요청한 peer 의 핸들
-	* @param [in] dwPlayerID 가격정보 리스트를 요청한 플레이어의 ID
-	**/
-	void MyshopPricelistRequest(CPeer* peer, DWORD dwHandle, DWORD dwPlayerID);
-	// END_OF_MYSHOP_PRICE_LIST
-
-	// Building
-	void CreateObject(TPacketGDCreateObject* p);
-	void DeleteObject(DWORD dwID);
-	void UpdateLand(DWORD* pdw);
-
-	// BLOCK_CHAT
-	void BlockChat(TPacketBlockChat* p);
-	// END_OF_BLOCK_CHAT
-
-#if defined(__ENVIRONMENT_SYSTEM__)
-	void UpdateEnvironment();
-#endif
-
-#ifdef __OFFLINE_SHOP__
-public:
-	const TItemTable* GetItemTable(DWORD vnum) const;
-	BYTE GetRealItemType(DWORD vnum);
-	BYTE GetRealItemSubType(DWORD vnum);
-	void GetRealItemLimit(DWORD vnum, int & limitType, DWORD & limitValue);
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-protected:
-	bool InitializeGrowthPetSkillTable();
-#endif
-
-private:
-	int m_looping;
-	socket_t m_fdAccept; // 접속 받는 소켓
-	TPeerList m_peerList;
-
-	CPeer* m_pkAuthPeer;
-
-	// LoginKey, LoginData pair
-	typedef std::unordered_map<DWORD, CLoginData*> TLoginDataByLoginKey;
-	TLoginDataByLoginKey m_map_pkLoginData;
-
-	// Login LoginData pair
-	typedef std::unordered_map<std::string, CLoginData*> TLoginDataByLogin;
-	TLoginDataByLogin m_map_pkLoginDataByLogin;
-
-	// AccountID LoginData pair
-	typedef std::unordered_map<DWORD, CLoginData*> TLoginDataByAID;
-	TLoginDataByAID m_map_pkLoginDataByAID;
-
-	// Login LoginData pair (실제 로그인 되어있는 계정)
-	typedef std::unordered_map<std::string, CLoginData*> TLogonAccountMap;
-	TLogonAccountMap m_map_kLogonAccount;
-
-	int m_iPlayerIDStart;
-	int m_iPlayerDeleteLevelLimit;
-	int m_iPlayerDeleteLevelLimitLower;
-	bool m_bChinaEventServer;
-	bool m_bWolfmanCharacter;
-	bool m_bDelayedCharacterCreation;
-
-	//MobTableVector m_vec_mobTable;
-	//ItemTableVector m_vec_itemTable;
-	//ItemTableVNumMap m_map_itemTableByVnum;
-	std::vector<TMobTable> m_vec_mobTable;
-	std::vector<TItemTable> m_vec_itemTable;
-	std::map<DWORD, TItemTable *> m_map_itemTableByVnum;
-
-	int m_iShopTableSize;
-	TShopTable* m_pShopTable;
-
-	int m_iRefineTableSize;
-	TRefineTable* m_pRefineTable;
-
-	std::vector<TSkillTable> m_vec_skillTable;
-	std::vector<TBanwordTable> m_vec_banwordTable;
-	std::vector<TItemAttrTable> m_vec_itemAttrTable;
-	std::vector<TItemAttrTable> m_vec_itemRareTable;
-
-	std::vector<building::TLand> m_vec_kLandTable;
-	std::vector<building::TObjectProto> m_vec_kObjectProto;
-	//pkObjectTableMap m_map_pkObjectTable;
-	std::map<DWORD, building::TObject *> m_map_pkObjectTable;
-#ifdef __GROWTH_PET_SYSTEM__
-	std::vector<TGrowthPetSkillTable>		m_vec_growthPetSkillTable;
-	TGrowthPetCacheMap				m_map_growthPetCache;
-	TGrowthPetCacheSetPtrMap		m_map_pkGrowthPetCacheSetPtr;
-#endif
-	bool m_bShutdowned;
-
-	TPlayerTableCacheMap m_map_playerCache; // 플레이어 id가 key
-
-	TItemCacheMap m_map_itemCache; // 아이템 id가 key
-	TItemCacheSetPtrMap m_map_pkItemCacheSetPtr; // 플레이어 id가 key, 이 플레이어가 어떤 아이템 캐쉬를 가지고 있나?
-
-	// MYSHOP_PRICE_LIST
-	/// 플레이어별 아이템 가격정보 리스트 map. key: 플레이어 ID, value: 가격정보 리스트 캐시
-	TItemPriceListCacheMap m_mapItemPriceListCache; ///< 플레이어별 아이템 가격정보 리스트
-	// END_OF_MYSHOP_PRICE_LIST
-
-	TChannelStatusMap m_mChannelStatus;
-
-	struct TPartyInfo
-	{
-		BYTE bRole;
-		BYTE bLevel;
-
-		TPartyInfo() :bRole(0), bLevel(0)
-		{
-		}
-	};
-
-	typedef std::map<DWORD, TPartyInfo> TPartyMember;
-	typedef std::map<DWORD, TPartyMember> TPartyMap;
-	typedef std::map<BYTE, TPartyMap> TPartyChannelMap;
-	TPartyChannelMap m_map_pkChannelParty;
-
-	typedef std::map<std::string, long> TEventFlagMap;
-	TEventFlagMap m_map_lEventFlag;
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	typedef std::map<DWORD, std::map<std::string, long>> TGuildEventFlagMap;
-	TGuildEventFlagMap m_map_lGuildEventFlag;
-#endif
-
-	BYTE m_bLastHeader;
-	int m_iCacheFlushCount;
-	int m_iCacheFlushCountLimit;
-
-private:
-	TItemIDRangeTable m_itemRange;
-
-public:
-	bool InitializeNowItemID();
-	DWORD GetItemID();
-	DWORD GainItemID();
-	TItemIDRangeTable GetItemRange() { return m_itemRange; }
-
-	// BOOT_LOCALIZATION
-public:
-	/* 로컬 정보 초기화 */
-	bool InitializeLocalization();
-
-private:
-	std::vector<tLocale> m_vec_Locale;
-	// END_BOOT_LOCALIZATION
-
-	// ADMIN_MANAGER
-	bool __GetAdminInfo(const char* szIP, std::vector<tAdminInfo>& rAdminVec);
-	bool __GetHostInfo(std::vector<std::string>& rIPVec);
-	// END_ADMIN_MANAGER
-
-	// RELOAD_ADMIN
-	void ReloadAdmin(CPeer* peer, TPacketReloadAdmin* p);
-	// END_RELOAD_ADMIN
-	void BreakMarriage(CPeer* peer, const char* data);
-
-	struct TLogoutPlayer
-	{
-		DWORD pid;
-		time_t time;
-
-		bool operator < (const TLogoutPlayer& r)
-		{
-			return (pid < r.pid);
-		}
-	};
-
-	typedef std::unordered_map<DWORD, TLogoutPlayer*> TLogoutPlayerMap;
-	TLogoutPlayerMap m_map_logout;
-
-	void InsertLogoutPlayer(DWORD pid);
-	void DeleteLogoutPlayer(DWORD pid);
-	void UpdateLogoutPlayer();
-	void UpdateItemCacheSet(DWORD pid);
-
-	void FlushPlayerCacheSet(DWORD pid);
-
-	// MONARCH
-	void Election(CPeer* peer, DWORD dwHandle, const char* p);
-	void Candidacy(CPeer* peer, DWORD dwHandle, const char* p);
-	void AddMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
-	void TakeMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
-	void ComeToVote(CPeer* peer, DWORD dwHandle, const char* p);
-	void RMCandidacy(CPeer* peer, DWORD dwHandle, const char* p);
-	void SetMonarch(CPeer* peer, DWORD dwHandle, const char* p);
-	void RMMonarch(CPeer* peer, DWORD dwHandle, const char* p);
-
-	void DecMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
-	// END_MONARCH
-
-	void ChangeMonarchLord(CPeer* peer, DWORD dwHandle, TPacketChangeMonarchLord* info);
-	void BlockException(TPacketBlockException* data);
-
-	void SendSpareItemIDRange(CPeer* peer);
-
-	void UpdateHorseName(TPacketUpdateHorseName* data, CPeer* peer);
-	void AckHorseName(DWORD dwPID, CPeer* peer);
-	void DeleteLoginKey(TPacketDC* data);
-	void ResetLastPlayerID(const TPacketNeedLoginLogInfo* data);
-
-	void DeleteAwardId(TPacketDeleteAwardID* data); // delete gift notify icon
-
-	void UpdateChannelStatus(TChannelStatus* pData);
-	void RequestChannelStatus(CPeer* peer, DWORD dwHandle);
-
-#if defined(__EXPRESSING_EMOTIONS__)
-public:
-	typedef std::vector<TPacketGDEmote> TEmoteTableVector;
-	typedef std::unordered_map<DWORD, TEmoteTableVector> TPlayerEmoteMap;
-
-private:
-	bool InitializeEmoteTable();
-
-	void QUERY_EMOTE_LOAD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
-	void QUERY_EMOTE_CLEAR(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
-	void QUERY_EMOTE_ADD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
-	void QUERY_EMOTE_DUMP();
-
-	TPlayerEmoteMap m_map_kPlayerEmote;
-	int m_iEmoteDumpDelay;
-#endif
-
-#if defined(__MAILBOX__)
-public:
-	typedef std::vector<SMailBoxTable> MailVec;
-	typedef std::map<std::string, MailVec> MailBoxMap;
-
-private:
-	bool InitializeMailBoxTable();
-
-	bool GET_MAIL(const char* name, const BYTE index, SMailBoxTable** mail);
-	void QUERY_MAILBOX_LOAD(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
-	void QUERY_MAILBOX_CHECK_NAME(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
-	void QUERY_MAILBOX_WRITE(CPeer * pkPeer, DWORD dwHandle, TMailBoxTable*);
-	void QUERY_MAILBOX_DELETE(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
-	void QUERY_MAILBOX_CONFIRM(CPeer* pkPeer, DWORD dwHandle, TMailBox*);
-	void QUERY_MAILBOX_GET(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
-	void QUERY_MAILBOX_UNREAD(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
-	void MAILBOX_BACKUP();
-
-	int m_iMailBoxBackupSec;
-	std::map<std::string, MailVec> m_map_mailbox;
-#endif
-
-#if defined(__GEM_SHOP__)
-public:
-	using GemShopTableMap = std::map<DWORD, TGemShopTable>;
-
-	bool InitializeGemShopTable();
-
-	void LoadGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopLoad* pTable, bool bUpdate = false);
-	void UpdateGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopTable* pTable);
-	void FlushGemShop();
-
-	GemShopTableMap m_mapGemShopTable;
-#if defined(__CONQUEROR_LEVEL__)
-	GemShopTableMap m_mapGemShopSpecialTable;
-#endif
-	int m_iGemShopFlushDelay;
-#endif
-
-#ifdef __OFFLINE_SHOP__
-private:
-	uint32_t nextOfflineShopId_;
-	std::map<uint32_t, std::unique_ptr<COfflineShopCache>> offlineShopCache_;
-	std::map<TOfflineItemID, std::unique_ptr<COfflineShopItemCache>> offlineShopItemCache_;
-
-private:
-	void InitializeOfflineShops();
-	void RequestOfflineShopId(CPeer* peer, uint32_t queueId);
-	void SaveOfflineShop(const TOfflineShop& data, bool skipQuery = false);
-	void SaveOfflineShopItem(const TOfflineShopItem& data, bool skipQuery = false);
-	void DestroyOfflineShop(uint32_t id);
-	void UpdateOfflineShopCache();
-	void UpdateOfflineShopItemCache();
-
-	void FlushOfflineShops();
-
-public:
-	void InitializeNextOfflineShopId();
-#endif
-};
-
-template<class Func>
-Func CClientManager::for_each_peer(Func f)
-{
-	TPeerList::iterator it;
-	for (it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		f(*it);
-	}
-	return f;
-}
-#endif
+#ifndef __INC_CLIENTMANAGER_H__
+#define __INC_CLIENTMANAGER_H__
+
+#include <boost/unordered_map.hpp>
+#include <boost/unordered_set.hpp>
+#include <memory>
+
+#include <unordered_map>
+#include <unordered_set>
+#include "Cache.h"
+
+#include "../../common/stl.h"
+#include "../../common/building.h"
+
+#include "Peer.h"
+#include "DBManager.h"
+#include "LoginData.h"
+
+class CPlayerTableCache;
+class CItemCache;
+class CItemPriceListTableCache;
+#ifdef __GROWTH_PET_SYSTEM__
+class CGrowthPetCache;
+#endif
+// typedef std::map<int, int> PacketInfoMap;
+
+class CPacketInfo
+{
+public:
+	void Add(int header);
+	void Reset();
+
+	// PacketInfoMap m_map_info;
+	std::map<int, int> m_map_info;
+};
+
+size_t CreatePlayerSaveQuery(char* pszQuery, size_t querySize, TPlayerTable* pkTab);
+
+// typedef std::vector<TItemTable> ItemTableVector;
+// typedef std::vector<TMobTable> MobTableVector;
+// typedef std::map<DWORD, building::TObject*> pkObjectTableMap;
+// typedef std::map<DWORD, TItemTable*> ItemTableVNumMap;
+
+class CClientManager : public CNetBase, public singleton<CClientManager>
+{
+public:
+	typedef std::list<CPeer*> TPeerList;
+	typedef std::unordered_map<DWORD, CPlayerTableCache*> TPlayerTableCacheMap;
+	typedef std::unordered_map<DWORD, CItemCache*> TItemCacheMap;
+	typedef std::unordered_set<CItemCache*, std::hash<CItemCache*> > TItemCacheSet;
+	typedef std::unordered_map<DWORD, TItemCacheSet*> TItemCacheSetPtrMap;
+	typedef std::unordered_map<DWORD, CItemPriceListTableCache*> TItemPriceListCacheMap;
+	typedef std::unordered_map<short, BYTE> TChannelStatusMap;
+
+#ifdef __GROWTH_PET_SYSTEM__
+	typedef std::unordered_map<DWORD, CGrowthPetCache*> TGrowthPetCacheMap;
+	typedef std::unordered_set<CGrowthPetCache*, std::hash<CGrowthPetCache*> > TGrowthPetCacheSet;
+	typedef std::unordered_map<DWORD, TGrowthPetCacheSet*> TGrowthPetCacheSetPtrMap;
+#endif
+
+	// MYSHOP_PRICE_LIST
+	///   트 청 
+	/**
+	* first: Peer handle
+	* second: 청 첨潔 ID
+	**/
+	typedef std::pair< DWORD, DWORD > TItemPricelistReqInfo;
+	// END_OF_MYSHOP_PRICE_LIST
+
+	class ClientHandleInfo
+	{
+	public:
+		DWORD dwHandle;
+		DWORD account_id;
+		DWORD player_id;
+		BYTE account_index;
+		char login[LOGIN_MAX_LEN + 1];
+		char safebox_password[SAFEBOX_PASSWORD_MAX_LEN + 1];
+		char ip[MAX_HOST_LENGTH + 1];
+
+		TAccountTable* pAccountTable;
+		TSafeboxTable* pSafebox;
+
+		ClientHandleInfo(DWORD argHandle, DWORD dwPID = 0)
+		{
+			dwHandle = argHandle;
+			pSafebox = NULL;
+			pAccountTable = NULL;
+			player_id = dwPID;
+		};
+
+		// 究 
+		ClientHandleInfo(DWORD argHandle, DWORD dwPID, DWORD accountId)
+		{
+			dwHandle = argHandle;
+			pSafebox = NULL;
+			pAccountTable = NULL;
+			player_id = dwPID;
+			account_id = accountId;
+		};
+
+		~ClientHandleInfo()
+		{
+			if (pSafebox)
+			{
+				delete pSafebox;
+				pSafebox = NULL;
+			}
+		}
+	};
+
+public:
+	CClientManager();
+	~CClientManager();
+
+	bool Initialize();
+	time_t GetCurrentTime();
+
+	void MainLoop();
+	void Quit();
+
+	void SetTablePostfix(const char* c_pszTablePostfix);
+	void SetPlayerIDStart(int iIDStart);
+	int GetPlayerIDStart() { return m_iPlayerIDStart; }
+
+	int GetPlayerDeleteLevelLimit() { return m_iPlayerDeleteLevelLimit; }
+
+	void SetChinaEventServer(bool flag) { m_bChinaEventServer = flag; }
+	bool IsChinaEventServer() { return m_bChinaEventServer; }
+
+	DWORD GetUserCount(); // 撻    磯.
+
+	void SendAllGuildSkillRechargePacket();
+	void SendTime();
+
+	CPlayerTableCache* GetPlayerCache(DWORD id);
+	void PutPlayerCache(TPlayerTable* pNew);
+
+	void CreateItemCacheSet(DWORD dwID);
+	TItemCacheSet* GetItemCacheSet(DWORD dwID);
+	void FlushItemCacheSet(DWORD dwID);
+
+	CItemCache* GetItemCache(DWORD id);
+	void PutItemCache(TPlayerItem* pNew, bool bSkipQuery = false);
+	bool DeleteItemCache(DWORD id);
+
+	CPeer* GetPeer(IDENT ident);
+
+	void UpdatePlayerCache();
+	void UpdateItemCache();
+
+#ifdef __GROWTH_PET_SYSTEM__
+	void			CreateGrowthPetCacheSet(DWORD dwID);
+	TGrowthPetCacheSet* GetGrowthPetCacheSet(DWORD dwID);
+	void			FlushGrowthPetCacheSet(DWORD dwID);
+
+	CGrowthPetCache* GetGrowthPetCache(DWORD id);
+	void			PutGrowthPetCache(TGrowthPet* pNew, bool bSkipQuery = false);
+	bool			DeleteGrowthPetCache(DWORD dwID);
+
+	void			UpdateGrowthPetCache();
+	void			UpdateGrowthPetCacheSet(DWORD pid);
+
+	void		QUERY_GROWTH_PET_SAVE(CPeer* pkPeer, const char* c_pData);
+	void		QUERY_GROWTH_PET_DELETE(CPeer* pkPeer, const char* c_pData);
+	bool		CreateGrowthPetTableFromRes(MYSQL_RES* res, std::vector<TGrowthPet>* pVec, DWORD dwPID);
+	void		RESULT_GROWTH_PET_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
+#endif
+
+	// MYSHOP_PRICE_LIST
+	///  트 캐첩 쨈.
+	/**
+	* @param [in] dwID  트 .(첨潔 ID)
+	* @return  트 캐 
+	**/
+	CItemPriceListTableCache* GetItemPriceListCache(DWORD dwID);
+
+	///  트 캐첩 獵쨈.
+	/**
+	* @param [in] pItemPriceList 캐첼    트
+	*
+	* 캐챨 譴  Update  틈 replace 磯.
+	**/
+	void PutItemPriceListCache(const TItemPriceListTable* pItemPriceList);
+
+	/// Flush 챨    트 캐첩 Flush 斂 캐첼 磯.
+	void UpdateItemPriceListCache(void);
+	// END_OF_MYSHOP_PRICE_LIST
+
+	void SendGuildSkillUsable(DWORD guild_id, DWORD dwSkillVnum, bool bUsable);
+
+	void SetCacheFlushCountLimit(int iLimit);
+
+	template <class Func>
+	Func for_each_peer(Func f);
+
+	CPeer* GetAnyPeer();
+
+	void ForwardPacket(BYTE header, const void* data, int size, BYTE bChannel = 0, CPeer* except = NULL);
+
+	void SendNotice(const char* c_pszFormat, ...);
+
+	char* GetCommand(char* str, char* command); // 究   獨
+	void ItemAward(CPeer* peer, char* login); //   
+
+protected:
+	void Destroy();
+
+private:
+	bool InitializeTables();
+	bool InitializeShopTable();
+
+	bool InitializeMobTable();
+	bool InitializeItemTable();
+
+	// BEGIN NPC TABLE
+	bool InitializeNpcTable();
+	// END NPC TABLE
+
+	bool InitializeQuestItemTable();
+	bool InitializeSkillTable();
+	bool InitializeRefineTable();
+	bool InitializeBanwordTable();
+	bool InitializeItemAttrTable();
+	bool InitializeItemRareTable();
+	bool InitializeLandTable();
+	bool InitializeObjectProto();
+	bool InitializeObjectTable();
+	bool InitializeMonarch();
+
+	void AddPeer(socket_t fd);
+	void RemovePeer(CPeer* pPeer);
+
+	int AnalyzeQueryResult(SQLMsg* msg);
+	int AnalyzeErrorMsg(CPeer* peer, SQLMsg* msg);
+
+	int Process();
+
+	void ProcessPackets(CPeer* peer);
+
+	CLoginData* GetLoginData(DWORD dwKey);
+	CLoginData* GetLoginDataByLogin(const char* c_pszLogin);
+	CLoginData* GetLoginDataByAID(DWORD dwAID);
+
+	void InsertLoginData(CLoginData* pkLD);
+	void DeleteLoginData(CLoginData* pkLD);
+
+	bool InsertLogonAccount(const char* c_pszLogin, DWORD dwHandle, const char* c_pszIP);
+	bool DeleteLogonAccount(const char* c_pszLogin, DWORD dwHandle);
+	bool FindLogonAccount(const char* c_pszLogin);
+
+	void GuildCreate(CPeer* peer, DWORD dwGuildID);
+	void GuildSkillUpdate(CPeer* peer, TPacketGuildSkillUpdate* p);
+	void GuildExpUpdate(CPeer* peer, TPacketGuildExpUpdate* p);
+	void GuildAddMember(CPeer* peer, TPacketGDGuildAddMember* p);
+	void GuildChangeGrade(CPeer* peer, TPacketGuild* p);
+	void GuildRemoveMember(CPeer* peer, TPacketGuild* p);
+	void GuildChangeMemberData(CPeer* peer, TPacketGuildChangeMemberData* p);
+	void GuildDisband(CPeer* peer, TPacketGuild* p);
+	void GuildWar(CPeer* peer, TPacketGuildWar* p);
+	void GuildWarScore(CPeer* peer, TPacketGuildWarScore* p);
+	void GuildChangeLadderPoint(TPacketGuildLadderPoint* p);
+	void GuildUseSkill(TPacketGuildUseSkill* p);
+	void GuildDepositMoney(TPacketGDGuildMoney* p);
+	void GuildWithdrawMoney(CPeer* peer, TPacketGDGuildMoney* p);
+	void GuildWithdrawMoneyGiveReply(TPacketGDGuildMoneyWithdrawGiveReply* p);
+	void GuildWarBet(TPacketGDGuildWarBet* p);
+	void GuildChangeMaster(TPacketChangeGuildMaster* p);
+
+	void SetGuildWarEndTime(DWORD guild_id1, DWORD guild_id2, time_t tEndTime);
+
+	void QUERY_BOOT(CPeer* peer, TPacketGDBoot* p);
+
+	void QUERY_LOGIN(CPeer* peer, DWORD dwHandle, SLoginPacket* data);
+	void QUERY_LOGOUT(CPeer* peer, DWORD dwHandle, const char*);
+
+	void RESULT_LOGIN(CPeer* peer, SQLMsg* msg);
+
+	void QUERY_PLAYER_LOAD(CPeer* peer, DWORD dwHandle, TPlayerLoadPacket*);
+	void RESULT_COMPOSITE_PLAYER(CPeer* peer, SQLMsg* pMsg, DWORD dwQID);
+	void RESULT_PLAYER_LOAD(CPeer* peer, MYSQL_RES* pRes, ClientHandleInfo* pkInfo);
+	void RESULT_ITEM_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
+	void RESULT_QUEST_LOAD(CPeer* pkPeer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
+	void RESULT_AFFECT_LOAD(CPeer* pkPeer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	void RESULT_EXT_BATTLE_PASS_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID);
+	void QUERY_SAVE_EXT_BATTLE_PASS(CPeer* peer, DWORD dwHandle, TPlayerExtBattlePassMission* battlePass);
+#endif
+
+	// PLAYER_INDEX_CREATE_BUG_FIX
+	void RESULT_PLAYER_INDEX_CREATE(CPeer* pkPeer, SQLMsg* msg);
+	// END_PLAYER_INDEX_CREATE_BUG_FIX
+
+	// MYSHOP_PRICE_LIST
+	///  琯   Result 처
+	/**
+	* @param peer  청 Game server  peer 체 
+	* @param pMsg  Result   체 
+	*
+	* 琯  트 캐첼 構 peer  트 娩.
+	**/
+	void RESULT_PRICELIST_LOAD(CPeer* peer, SQLMsg* pMsg);
+
+	///  트  琯   Result 처
+	/**
+	* @param pMsg  Result   체 
+	*
+	* 琯   트 캐첩  트   트 磯.
+	**/
+	void RESULT_PRICELIST_LOAD_FOR_UPDATE(SQLMsg* pMsg);
+	// END_OF_MYSHOP_PRICE_LIST
+
+	void QUERY_PLAYER_SAVE(CPeer* peer, DWORD dwHandle, TPlayerTable*);
+
+	void __QUERY_PLAYER_CREATE(CPeer* peer, DWORD dwHandle, TPlayerCreatePacket*);
+	void __QUERY_PLAYER_DELETE(CPeer* peer, DWORD dwHandle, TPlayerDeletePacket*);
+	void __RESULT_PLAYER_DELETE(CPeer* peer, SQLMsg* msg);
+
+	void QUERY_PLAYER_COUNT(CPeer* pkPeer, TPlayerCountPacket*);
+
+	void QUERY_ITEM_SAVE(CPeer* pkPeer, const char* c_pData);
+	void QUERY_ITEM_DESTROY(CPeer* pkPeer, const char* c_pData);
+	void QUERY_ITEM_FLUSH(CPeer* pkPeer, const char* c_pData);
+
+	void QUERY_QUEST_SAVE(CPeer* pkPeer, TQuestTable*, DWORD dwLen);
+	void QUERY_ADD_AFFECT(CPeer* pkPeer, TPacketGDAddAffect* p);
+	void QUERY_REMOVE_AFFECT(CPeer* pkPeer, TPacketGDRemoveAffect* p);
+
+	void QUERY_SAFEBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TSafeboxLoadPacket*, bool bMall);
+	void QUERY_SAFEBOX_SAVE(CPeer* pkPeer, TSafeboxTable* pTable);
+	void QUERY_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangeSizePacket* p);
+	void QUERY_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangePasswordPacket* p);
+
+	void RESULT_SAFEBOX_LOAD(CPeer* pkPeer, SQLMsg* msg);
+	void RESULT_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, SQLMsg* msg);
+	void RESULT_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, SQLMsg* msg);
+	void RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(CPeer* pkPeer, SQLMsg* msg);
+
+	void QUERY_EMPIRE_SELECT(CPeer* pkPeer, DWORD dwHandle, TEmpireSelectPacket* p);
+	void QUERY_SETUP(CPeer* pkPeer, DWORD dwHandle, const char* c_pData);
+
+	void SendPartyOnSetup(CPeer* peer);
+
+	void QUERY_HIGHSCORE_REGISTER(CPeer* peer, TPacketGDHighscore* data);
+	void RESULT_HIGHSCORE_REGISTER(CPeer* pkPeer, SQLMsg* msg);
+
+	void QUERY_FLUSH_CACHE(CPeer* pkPeer, const char* c_pData);
+
+	void QUERY_PARTY_CREATE(CPeer* peer, TPacketPartyCreate* p);
+	void QUERY_PARTY_DELETE(CPeer* peer, TPacketPartyDelete* p);
+	void QUERY_PARTY_ADD(CPeer* peer, TPacketPartyAdd* p);
+	void QUERY_PARTY_REMOVE(CPeer* peer, TPacketPartyRemove* p);
+	void QUERY_PARTY_STATE_CHANGE(CPeer* peer, TPacketPartyStateChange* p);
+	void QUERY_PARTY_SET_MEMBER_LEVEL(CPeer* peer, TPacketPartySetMemberLevel* p);
+
+	void QUERY_RELOAD_PROTO();
+
+	void QUERY_CHANGE_NAME(CPeer* peer, DWORD dwHandle, TPacketGDChangeName* p);
+	void GetPlayerFromRes(TPlayerTable* player_table, MYSQL_RES* res);
+
+	void QUERY_LOGIN_KEY(CPeer* pkPeer, TPacketGDLoginKey* p);
+
+	void AddGuildPriv(TPacketGiveGuildPriv* p);
+	void AddEmpirePriv(TPacketGiveEmpirePriv* p);
+	void AddCharacterPriv(TPacketGiveCharacterPriv* p);
+
+	void MoneyLog(TPacketMoneyLog* p);
+
+	void QUERY_AUTH_LOGIN(CPeer* pkPeer, DWORD dwHandle, TPacketGDAuthLogin* p);
+
+	void QUERY_LOGIN_BY_KEY(CPeer* pkPeer, DWORD dwHandle, TPacketGDLoginByKey* p);
+	void RESULT_LOGIN_BY_KEY(CPeer* peer, SQLMsg* msg);
+
+	void ChargeCash(const TRequestChargeCash* p);
+
+	void LoadEventFlag();
+	void SetEventFlag(TPacketSetEventFlag* p);
+	void SendEventFlagsOnSetup(CPeer* peer);
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	void LoadGuildEventFlag();
+	void GuildSetEventFlag(TPacketSetGuildEventFlag* pTable);
+	void SendGuildEventFlagsOnSetup(CPeer* pPeer);
+#endif
+
+	// 혼
+	void MarriageAdd(TPacketMarriageAdd* p);
+	void MarriageUpdate(TPacketMarriageUpdate* p);
+	void MarriageRemove(TPacketMarriageRemove* p);
+
+	void WeddingRequest(TPacketWeddingRequest* p);
+	void WeddingReady(TPacketWeddingReady* p);
+	void WeddingEnd(TPacketWeddingEnd* p);
+
+#if defined(__MOVE_CHANNEL__)
+	void FindChannel(CPeer* pkPeer, DWORD dwHandle, TPacketChangeChannel* p);
+#endif
+
+	// MYSHOP_PRICE_LIST
+	// 貫 
+
+	///   트 트 킷(HEADER_GD_MYSHOP_PRICELIST_UPDATE) 처獨
+	/**
+	* @param [in] pPacket 킷  
+	**/
+	void MyshopPricelistUpdate(const TItemPriceListTable* pPacket);
+
+	///   트 청 킷(HEADER_GD_MYSHOP_PRICELIST_REQ) 처獨
+	/**
+	* @param peer 킷  Game server  peer 체 
+	* @param [in] dwHandle  청 peer  湄
+	* @param [in] dwPlayerID  트 청 첨潔 ID
+	**/
+	void MyshopPricelistRequest(CPeer* peer, DWORD dwHandle, DWORD dwPlayerID);
+	// END_OF_MYSHOP_PRICE_LIST
+
+	// Building
+	void CreateObject(TPacketGDCreateObject* p);
+	void DeleteObject(DWORD dwID);
+	void UpdateLand(DWORD* pdw);
+
+	// BLOCK_CHAT
+	void BlockChat(TPacketBlockChat* p);
+	// END_OF_BLOCK_CHAT
+
+#if defined(__ENVIRONMENT_SYSTEM__)
+	void UpdateEnvironment();
+#endif
+
+#ifdef __OFFLINE_SHOP__
+public:
+	const TItemTable* GetItemTable(DWORD vnum) const;
+	BYTE GetRealItemType(DWORD vnum);
+	BYTE GetRealItemSubType(DWORD vnum);
+	void GetRealItemLimit(DWORD vnum, int & limitType, DWORD & limitValue);
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	bool		InitializeGrowthPetSkillTable();
+#endif
+
+private:
+	int m_looping;
+	socket_t m_fdAccept; //  濱 
+	TPeerList m_peerList;
+
+	CPeer* m_pkAuthPeer;
+
+	// LoginKey, LoginData pair
+	typedef std::unordered_map<DWORD, CLoginData*> TLoginDataByLoginKey;
+	TLoginDataByLoginKey m_map_pkLoginData;
+
+	// Login LoginData pair
+	typedef std::unordered_map<std::string, CLoginData*> TLoginDataByLogin;
+	TLoginDataByLogin m_map_pkLoginDataByLogin;
+
+	// AccountID LoginData pair
+	typedef std::unordered_map<DWORD, CLoginData*> TLoginDataByAID;
+	TLoginDataByAID m_map_pkLoginDataByAID;
+
+	// Login LoginData pair ( 慣 퓸獵 )
+	typedef std::unordered_map<std::string, CLoginData*> TLogonAccountMap;
+	TLogonAccountMap m_map_kLogonAccount;
+
+	int m_iPlayerIDStart;
+	int m_iPlayerDeleteLevelLimit;
+	int m_iPlayerDeleteLevelLimitLower;
+	bool m_bChinaEventServer;
+	bool m_bWolfmanCharacter;
+	bool m_bDelayedCharacterCreation;
+
+	//MobTableVector m_vec_mobTable;
+	//ItemTableVector m_vec_itemTable;
+	//ItemTableVNumMap m_map_itemTableByVnum;
+	std::vector<TMobTable> m_vec_mobTable;
+	std::vector<TItemTable> m_vec_itemTable;
+	std::map<DWORD, TItemTable *> m_map_itemTableByVnum;
+
+	int m_iShopTableSize;
+	TShopTable* m_pShopTable;
+
+	int m_iRefineTableSize;
+	TRefineTable* m_pRefineTable;
+
+	std::vector<TSkillTable> m_vec_skillTable;
+	std::vector<TBanwordTable> m_vec_banwordTable;
+	std::vector<TItemAttrTable> m_vec_itemAttrTable;
+	std::vector<TItemAttrTable> m_vec_itemRareTable;
+
+	std::vector<building::TLand> m_vec_kLandTable;
+	std::vector<building::TObjectProto> m_vec_kObjectProto;
+	//pkObjectTableMap m_map_pkObjectTable;
+	std::map<DWORD, building::TObject *> m_map_pkObjectTable;
+#ifdef __GROWTH_PET_SYSTEM__
+	std::vector<TGrowthPetSkillTable>		m_vec_growthPetSkillTable;
+#endif
+	bool m_bShutdowned;
+
+	TPlayerTableCacheMap m_map_playerCache; // 첨潔 id key
+
+	TItemCacheMap m_map_itemCache; //  id key
+	TItemCacheSetPtrMap m_map_pkItemCacheSetPtr; // 첨潔 id key,  첨潔載 錚  캐  簾?
+
+	// MYSHOP_PRICE_LIST
+	/// 첨潔咀   트 map. key: 첨潔 ID, value:  트 캐
+	TItemPriceListCacheMap m_mapItemPriceListCache; ///< 첨潔咀   트
+	// END_OF_MYSHOP_PRICE_LIST
+
+	TChannelStatusMap m_mChannelStatus;
+
+	struct TPartyInfo
+	{
+		BYTE bRole;
+		BYTE bLevel;
+
+		TPartyInfo() :bRole(0), bLevel(0)
+		{
+		}
+	};
+
+	typedef std::map<DWORD, TPartyInfo> TPartyMember;
+	typedef std::map<DWORD, TPartyMember> TPartyMap;
+	typedef std::map<BYTE, TPartyMap> TPartyChannelMap;
+	TPartyChannelMap m_map_pkChannelParty;
+
+	typedef std::map<std::string, long> TEventFlagMap;
+	TEventFlagMap m_map_lEventFlag;
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	typedef std::map<DWORD, std::map<std::string, long>> TGuildEventFlagMap;
+	TGuildEventFlagMap m_map_lGuildEventFlag;
+#endif
+
+	BYTE m_bLastHeader;
+	int m_iCacheFlushCount;
+	int m_iCacheFlushCountLimit;
+
+private:
+	TItemIDRangeTable m_itemRange;
+
+public:
+	bool InitializeNowItemID();
+	DWORD GetItemID();
+	DWORD GainItemID();
+	TItemIDRangeTable GetItemRange() { return m_itemRange; }
+
+	// BOOT_LOCALIZATION
+public:
+	/*   珂화 */
+	bool InitializeLocalization();
+
+private:
+	std::vector<tLocale> m_vec_Locale;
+	// END_BOOT_LOCALIZATION
+
+	// ADMIN_MANAGER
+	bool __GetAdminInfo(const char* szIP, std::vector<tAdminInfo>& rAdminVec);
+	bool __GetHostInfo(std::vector<std::string>& rIPVec);
+	// END_ADMIN_MANAGER
+
+	// RELOAD_ADMIN
+	void ReloadAdmin(CPeer* peer, TPacketReloadAdmin* p);
+	// END_RELOAD_ADMIN
+	void BreakMarriage(CPeer* peer, const char* data);
+
+	struct TLogoutPlayer
+	{
+		DWORD pid;
+		time_t time;
+
+		bool operator < (const TLogoutPlayer& r)
+		{
+			return (pid < r.pid);
+		}
+	};
+
+	typedef std::unordered_map<DWORD, TLogoutPlayer*> TLogoutPlayerMap;
+	TLogoutPlayerMap m_map_logout;
+
+	void InsertLogoutPlayer(DWORD pid);
+	void DeleteLogoutPlayer(DWORD pid);
+	void UpdateLogoutPlayer();
+	void UpdateItemCacheSet(DWORD pid);
+
+	void FlushPlayerCacheSet(DWORD pid);
+
+	// MONARCH
+	void Election(CPeer* peer, DWORD dwHandle, const char* p);
+	void Candidacy(CPeer* peer, DWORD dwHandle, const char* p);
+	void AddMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
+	void TakeMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
+	void ComeToVote(CPeer* peer, DWORD dwHandle, const char* p);
+	void RMCandidacy(CPeer* peer, DWORD dwHandle, const char* p);
+	void SetMonarch(CPeer* peer, DWORD dwHandle, const char* p);
+	void RMMonarch(CPeer* peer, DWORD dwHandle, const char* p);
+
+	void DecMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
+	// END_MONARCH
+
+	void ChangeMonarchLord(CPeer* peer, DWORD dwHandle, TPacketChangeMonarchLord* info);
+	void BlockException(TPacketBlockException* data);
+
+	void SendSpareItemIDRange(CPeer* peer);
+
+	void UpdateHorseName(TPacketUpdateHorseName* data, CPeer* peer);
+	void AckHorseName(DWORD dwPID, CPeer* peer);
+	void DeleteLoginKey(TPacketDC* data);
+	void ResetLastPlayerID(const TPacketNeedLoginLogInfo* data);
+
+	void DeleteAwardId(TPacketDeleteAwardID* data); // delete gift notify icon
+
+	void UpdateChannelStatus(TChannelStatus* pData);
+	void RequestChannelStatus(CPeer* peer, DWORD dwHandle);
+
+#if defined(__EXPRESSING_EMOTIONS__)
+public:
+	typedef std::vector<TPacketGDEmote> TEmoteTableVector;
+	typedef std::unordered_map<DWORD, TEmoteTableVector> TPlayerEmoteMap;
+
+private:
+	bool InitializeEmoteTable();
+
+	void QUERY_EMOTE_LOAD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
+	void QUERY_EMOTE_CLEAR(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
+	void QUERY_EMOTE_ADD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
+	void QUERY_EMOTE_DUMP();
+
+	TPlayerEmoteMap m_map_kPlayerEmote;
+	int m_iEmoteDumpDelay;
+#endif
+
+#if defined(__MAILBOX__)
+public:
+	typedef std::vector<SMailBoxTable> MailVec;
+	typedef std::map<std::string, MailVec> MailBoxMap;
+
+private:
+	bool InitializeMailBoxTable();
+
+	bool GET_MAIL(const char* name, const BYTE index, SMailBoxTable** mail);
+	void QUERY_MAILBOX_LOAD(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
+	void QUERY_MAILBOX_CHECK_NAME(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
+	void QUERY_MAILBOX_WRITE(CPeer * pkPeer, DWORD dwHandle, TMailBoxTable*);
+	void QUERY_MAILBOX_DELETE(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
+	void QUERY_MAILBOX_CONFIRM(CPeer* pkPeer, DWORD dwHandle, TMailBox*);
+	void QUERY_MAILBOX_GET(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
+	void QUERY_MAILBOX_UNREAD(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
+	void MAILBOX_BACKUP();
+
+	int m_iMailBoxBackupSec;
+	std::map<std::string, MailVec> m_map_mailbox;
+#endif
+
+#if defined(__GEM_SHOP__)
+public:
+	using GemShopTableMap = std::map<DWORD, TGemShopTable>;
+
+	bool InitializeGemShopTable();
+
+	void LoadGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopLoad* pTable, bool bUpdate = false);
+	void UpdateGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopTable* pTable);
+	void FlushGemShop();
+
+	GemShopTableMap m_mapGemShopTable;
+#if defined(__CONQUEROR_LEVEL__)
+	GemShopTableMap m_mapGemShopSpecialTable;
+#endif
+	int m_iGemShopFlushDelay;
+#endif
+
+#ifdef __OFFLINE_SHOP__
+private:
+	uint32_t nextOfflineShopId_;
+	std::map<uint32_t, std::unique_ptr<COfflineShopCache>> offlineShopCache_;
+	std::map<TOfflineItemID, std::unique_ptr<COfflineShopItemCache>> offlineShopItemCache_;
+
+private:
+	void InitializeOfflineShops();
+	void RequestOfflineShopId(CPeer* peer, uint32_t queueId);
+	void SaveOfflineShop(const TOfflineShop& data, bool skipQuery = false);
+	void SaveOfflineShopItem(const TOfflineShopItem& data, bool skipQuery = false);
+	void DestroyOfflineShop(uint32_t id);
+	void UpdateOfflineShopCache();
+	void UpdateOfflineShopItemCache();
+
+	void FlushOfflineShops();
+
+public:
+	void InitializeNextOfflineShopId();
+#endif
+};
+
+template<class Func>
+Func CClientManager::for_each_peer(Func f)
+{
+	TPeerList::iterator it;
+	for (it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		f(*it);
+	}
+	return f;
+}
+#endif
diff --git a/server/server/home/metin2/Source/Server/db/src/ClientManagerPlayer.cpp b/server/server/home/metin2/Source/Server/db/src/ClientManagerPlayer.cpp
index 196adc6..88c44b0 100644
--- a/server/server/home/metin2/Source/Server/db/src/ClientManagerPlayer.cpp
+++ b/server/server/home/metin2/Source/Server/db/src/ClientManagerPlayer.cpp
@@ -1,1973 +1,1973 @@
-#include "stdafx.h"
-
-#include "ClientManager.h"
-
-#include "Main.h"
-#include "QID.h"
-#include "ItemAwardManager.h"
-#include "HB.h"
-#include "Cache.h"
-
-extern bool g_bHotBackup;
-
-extern std::string g_stLocale;
-extern int g_test_server;
-extern int g_log;
-
-//
-// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-// !!!!!!!!!!! IMPORTANT !!!!!!!!!!!!
-// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-//
-// Check all SELECT syntax on item table before change this function!!!
-//
-bool CreateItemTableFromRes(MYSQL_RES* res, std::vector<TPlayerItem>* pVec, DWORD dwPID)
-{
-	if (!res)
-	{
-		pVec->clear();
-		return true;
-	}
-
-	int rows;
-
-	if ((rows = static_cast<int>(mysql_num_rows(res))) <= 0) // 데이터 없음
-	{
-		pVec->clear();
-		return true;
-	}
-
-	pVec->resize(rows);
-
-	for (int i = 0; i < rows; ++i)
-	{
-		MYSQL_ROW row = mysql_fetch_row(res);
-		TPlayerItem& item = pVec->at(i);
-
-		int cur = 0;
-
-		// Check all SELECT syntax on item table before change this function!!!
-		// Check all SELECT syntax on item table before change this function!!!
-		// Check all SELECT syntax on item table before change this function!!!
-		str_to_number(item.dwID, row[cur++]);
-		str_to_number(item.bWindow, row[cur++]);
-		str_to_number(item.wPos, row[cur++]);
-		str_to_number(item.dwVnum, row[cur++]);
-		str_to_number(item.dwCount, row[cur++]);
-
-#if defined(__SOUL_BIND_SYSTEM__)
-		str_to_number(item.lSealDate, row[cur++]);
-#endif
-
-		for (BYTE i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
-			str_to_number(item.alSockets[i], row[cur++]);
-
-		for (int j = 0; j < ITEM_ATTRIBUTE_MAX_NUM; j++)
-		{
-			str_to_number(item.aAttr[j].wType, row[cur++]);
-			str_to_number(item.aAttr[j].lValue, row[cur++]);
-		}
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		str_to_number(item.dwTransmutationVnum, row[cur++]);
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		str_to_number(item.RefineElement.wApplyType, row[cur++]);
-		str_to_number(item.RefineElement.bGrade, row[cur++]);
-		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
-			str_to_number(item.RefineElement.abValue[i], row[cur++]);
-		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
-			str_to_number(item.RefineElement.abBonusValue[i], row[cur++]);
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-		for (int j = 0; j < ITEM_APPLY_MAX_NUM; j++)
-		{
-			str_to_number(item.aApplyRandom[j].wType, row[cur++]);
-			str_to_number(item.aApplyRandom[j].lValue, row[cur++]);
-			str_to_number(item.aApplyRandom[j].bPath, row[cur++]);
-		}
-#endif
-
-#if defined(__SET_ITEM__)
-		str_to_number(item.bSetValue, row[cur++]);
-#endif
-
-		item.dwOwner = dwPID;
-	}
-
-	return true;
-}
-
-size_t CreatePlayerSaveQuery(char* pszQuery, size_t querySize, TPlayerTable* pkTab)
-{
-	size_t queryLen;
-
-	queryLen = snprintf(pszQuery, querySize,
-		"UPDATE player%s SET "
-		"`job` = %d, "
-		"`voice` = %d, "
-		"`dir` = %d, "
-		"`x` = %d, "
-		"`y` = %d, "
-		"`z` = %d, "
-		"`map_index` = %d, "
-		"`exit_x` = %ld, "
-		"`exit_y` = %ld, "
-		"`exit_map_index` = %ld, "
-		"`hp` = %d, "
-		"`mp` = %d, "
-		"`stamina` = %d, "
-		"`random_hp` = %d, "
-		"`random_sp` = %d, "
-		"`playtime` = %d, "
-		"`level` = %d, "
-		"`level_step` = %d, "
-		"`st` = %d, "
-		"`ht` = %d, "
-		"`dx` = %d, "
-		"`iq` = %d, "
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		"`inven_stage` = %d, "
-#endif
-		"`gold` = %d, "
-#if defined(__CHEQUE_SYSTEM__)
-		"`cheque` = %d, "
-#endif
-#if defined(__GEM_SYSTEM__)
-		"`gem` = %d, "
-#endif
-		"`exp` = %u, "
-		"`stat_point` = %d, "
-		"`skill_point` = %d, "
-		"`sub_skill_point` = %d, "
-		"`stat_reset_count` = %d, "
-		"`ip` = '%s', "
-		"`part_main` = %d, "
-		"`part_hair` = %d, "
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		"`part_acce` = %d, "
-#endif
-		"`last_play` = NOW(), "
-		"`skill_group` = %d, "
-		"`alignment` = %ld, "
-#if defined(__CONQUEROR_LEVEL__)
-		"`conqueror_level` = %d, "
-		"`conqueror_level_step` = %d, "
-		"`sungma_str` = %d, "
-		"`sungma_hp` = %d, "
-		"`sungma_move` = %d, "
-		"`sungma_immune` = %d, "
-		"`conqueror_exp` = %u, "
-		"`conqueror_point` = %d, "
-#endif
-		"`horse_level` = %d, "
-		"`horse_riding` = %d, "
-		"`horse_hp` = %d, "
-		"`horse_hp_droptime` = %u, "
-		"`horse_stamina` = %d, "
-		"`horse_skill_point` = %d, "
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		"`battle_pass_premium_id` = %d, "
-#endif
-		,
-		GetTablePostfix(),
-		pkTab->job,
-		pkTab->voice,
-		pkTab->dir,
-		pkTab->x,
-		pkTab->y,
-		pkTab->z,
-		pkTab->lMapIndex,
-		pkTab->lExitX,
-		pkTab->lExitY,
-		pkTab->lExitMapIndex,
-		pkTab->hp,
-		pkTab->sp,
-		pkTab->stamina,
-		pkTab->sRandomHP,
-		pkTab->sRandomSP,
-		pkTab->playtime,
-		pkTab->level,
-		pkTab->level_step,
-		pkTab->st,
-		pkTab->ht,
-		pkTab->dx,
-		pkTab->iq,
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		pkTab->inven_stage,
-#endif
-		pkTab->gold,
-#if defined(__CHEQUE_SYSTEM__)
-		pkTab->cheque,
-#endif
-#if defined(__GEM_SYSTEM__)
-		pkTab->gem,
-#endif
-		pkTab->exp,
-		pkTab->stat_point,
-		pkTab->skill_point,
-		pkTab->sub_skill_point,
-		pkTab->stat_reset_count,
-		pkTab->ip,
-		pkTab->adwParts[PART_MAIN],
-		pkTab->adwParts[PART_HAIR],
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		pkTab->adwParts[PART_ACCE],
-#endif
-		pkTab->skill_group,
-		pkTab->lAlignment,
-#if defined(__CONQUEROR_LEVEL__)
-		pkTab->conqueror_level,
-		pkTab->conqueror_level_step,
-		pkTab->sungma_str,
-		pkTab->sungma_hp,
-		pkTab->sungma_move,
-		pkTab->sungma_immune,
-		pkTab->conqueror_exp,
-		pkTab->conqueror_point,
-#endif
-		pkTab->horse.bLevel,
-		pkTab->horse.bRiding,
-		pkTab->horse.sHealth,
-		pkTab->horse.dwHorseHealthDropTime,
-		pkTab->horse.sStamina,
-		pkTab->horse_skill_point,
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		pkTab->battle_pass_premium_id
-#endif
-	);
-
-	// Binary 로 바꾸기 위한 임시 공간
-	static char text[QUERY_MAX_LEN];
-
-	CDBManager::instance().EscapeString(text, pkTab->skills, sizeof(pkTab->skills));
-	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, "`skill_level` = '%s', ", text);
-
-	CDBManager::instance().EscapeString(text, pkTab->quickslot, sizeof(pkTab->quickslot));
-	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, "`quickslot` = '%s' ", text);
-
-	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, " WHERE `id` = %d", pkTab->id);
-	return queryLen;
-}
-
-CPlayerTableCache* CClientManager::GetPlayerCache(DWORD id)
-{
-	TPlayerTableCacheMap::iterator it = m_map_playerCache.find(id);
-
-	if (it == m_map_playerCache.end())
-		return NULL;
-
-	TPlayerTable* pTable = it->second->Get(false);
-	pTable->logoff_interval = static_cast<DWORD>(GetCurrentTime()) - it->second->GetLastUpdateTime();
-	return it->second;
-}
-
-void CClientManager::PutPlayerCache(TPlayerTable* pNew)
-{
-	CPlayerTableCache* c;
-
-	c = GetPlayerCache(pNew->id);
-
-	if (!c)
-	{
-		c = new CPlayerTableCache;
-		m_map_playerCache.insert(TPlayerTableCacheMap::value_type(pNew->id, c));
-	}
-
-	if (g_bHotBackup)
-		PlayerHB::instance().Put(pNew->id);
-
-	c->Put(pNew);
-}
-
-/*
-* PLAYER LOAD
-*/
-void CClientManager::QUERY_PLAYER_LOAD(CPeer* peer, DWORD dwHandle, TPlayerLoadPacket* packet)
-{
-	CPlayerTableCache* c;
-	TPlayerTable* pTab;
-
-	//
-	// 한 계정에 속한 모든 캐릭터들 캐쉬처리
-	//
-	CLoginData* pLoginData = GetLoginDataByAID(packet->account_id);
-
-	if (pLoginData)
-	{
-		for (int n = 0; n < PLAYER_PER_ACCOUNT; ++n)
-			if (pLoginData->GetAccountRef().players[n].dwID != 0)
-				DeleteLogoutPlayer(pLoginData->GetAccountRef().players[n].dwID);
-	}
-
-	// ---------------------------------------------------------------
-	// 1. 유저정보가 DBCache 에 존재 : DBCache에서
-	// 2. 유저정보가 DBCache 에 없음 : DB에서
-	// ---------------------------------------------------------------
-
-	// ---------------------------------------------------------------
-	// 1. 유저정보가 DBCache 에 존재 : DBCache에서
-	// ---------------------------------------------------------------
-	if ((c = GetPlayerCache(packet->player_id)))
-	{
-		CLoginData* pkLD = GetLoginDataByAID(packet->account_id);
-
-		if (!pkLD || pkLD->IsPlay())
-		{
-			sys_log(0, "PLAYER_LOAD_ERROR: LoginData %p IsPlay %d", pkLD, pkLD ? pkLD->IsPlay() : 0);
-			peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, dwHandle, 0);
-			return;
-		}
-
-		pTab = c->Get();
-
-		pkLD->SetPlay(true);
-		thecore_memcpy(pTab->aiPremiumTimes, pkLD->GetPremiumPtr(), sizeof(pTab->aiPremiumTimes));
-
-		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_SUCCESS, dwHandle, sizeof(TPlayerTable));
-		peer->Encode(pTab, sizeof(TPlayerTable));
-
-		if (packet->player_id != pkLD->GetLastPlayerID())
-		{
-			TPacketNeedLoginLogInfo logInfo;
-			logInfo.dwPlayerID = packet->player_id;
-
-			pkLD->SetLastPlayerID(packet->player_id);
-
-			peer->EncodeHeader(HEADER_DG_NEED_LOGIN_LOG, dwHandle, sizeof(TPacketNeedLoginLogInfo));
-			peer->Encode(&logInfo, sizeof(TPacketNeedLoginLogInfo));
-		}
-
-		char szQuery[1024] = { 0, };
-
-		TItemCacheSet* pSet = GetItemCacheSet(pTab->id);
-
-		sys_log(0, "[PLAYER_LOAD] ID %s pid %d gold %d "
-#if defined(__CHEQUE_SYSTEM__)
-			"cheque %d "
-#endif
-#if defined(__GEM_SYSTEM__)
-			"gem %d "
-#endif
-			, pTab->name
-			, pTab->id
-			, pTab->gold
-#if defined(__CHEQUE_SYSTEM__)
-			, pTab->cheque
-#endif
-#if defined(__GEM_SYSTEM__)
-			, pTab->gem
-#endif
-		);
-
-		// ---------------------------------------------------------------
-		// 아이템 & AFFECT & QUEST 로딩 :
-		// ---------------------------------------------------------------
-		// 1) 아이템이 DBCache 에 존재 : DBCache 에서 가져옴
-		// 2) 아이템이 DBCache 에 없음 : DB 에서 가져옴
-
-		///////////////////////////////////////////////////////////////
-		// 1) 아이템이 DBCache 에 존재 : DBCache 에서 가져옴
-		///////////////////////////////////////////////////////////////
-		if (pSet)
-		{
-			static std::vector<TPlayerItem> s_items;
-			s_items.resize(pSet->size());
-
-			DWORD dwCount = 0;
-			TItemCacheSet::iterator it = pSet->begin();
-
-			while (it != pSet->end())
-			{
-				CItemCache* c = *it++;
-				TPlayerItem* p = c->Get();
-
-				if (p->dwVnum) // vnum이 없으면 삭제된 아이템이다.
-					thecore_memcpy(&s_items[dwCount++], p, sizeof(TPlayerItem));
-			}
-
-			if (g_test_server)
-				sys_log(0, "ITEM_CACHE: HIT! %s count: %u", pTab->name, dwCount);
-
-			peer->EncodeHeader(HEADER_DG_ITEM_LOAD, dwHandle, sizeof(DWORD) + sizeof(TPlayerItem) * dwCount);
-			peer->EncodeDWORD(dwCount);
-
-			if (dwCount)
-				peer->Encode(&s_items[0], sizeof(TPlayerItem) * dwCount);
-
-			// Quest
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d AND `lValue` <> 0",
-				GetTablePostfix(), pTab->id);
-
-			CDBManager::instance().ReturnQuery(szQuery, QID_QUEST, peer->GetHandle(), new ClientHandleInfo(dwHandle, 0, packet->account_id));
-
-			// Affect
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
-#if defined(__AFFECT_RENEWAL__)
-				", `bRealTime`"
-#endif
-				" FROM `affect%s` WHERE `dwPID` = %d",
-				GetTablePostfix(), pTab->id);
-			CDBManager::instance().ReturnQuery(szQuery, QID_AFFECT, peer->GetHandle(), new ClientHandleInfo(dwHandle, pTab->id));
-		}
-		///////////////////////////////////////////////////////////////
-		// 2) 아이템이 DBCache 에 없음 : DB 에서 가져옴
-		///////////////////////////////////////////////////////////////
-		else
-		{
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
-#if defined(__SOUL_BIND_SYSTEM__)
-				", `soulbind`"
-#endif
-				", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-				", `socket3`, `socket4`, `socket5`"
-#endif
-				", `attrtype0`, `attrvalue0`"
-				", `attrtype1`, `attrvalue1`"
-				", `attrtype2`, `attrvalue2`"
-				", `attrtype3`, `attrvalue3`"
-				", `attrtype4`, `attrvalue4`"
-				", `attrtype5`, `attrvalue5`"
-				", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				", `transmutation`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				", `refine_element_apply_type`"
-				", `refine_element_grade`"
-				", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-				", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-				", `apply_type0`, `apply_value0`, `apply_path0`"
-				", `apply_type1`, `apply_value1`, `apply_path1`"
-				", `apply_type2`, `apply_value2`, `apply_path2`"
-				", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-				", `set_value`"
-#endif
-				" FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
-				"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
-#if defined(__ATTR_6TH_7TH__)
-				", 'NPC_STORAGE'"
-#endif
-				"))",
-				GetTablePostfix(), pTab->id);
-
-			CDBManager::instance().ReturnQuery(szQuery,
-				QID_ITEM,
-				peer->GetHandle(),
-				new ClientHandleInfo(dwHandle, pTab->id));
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d",
-				GetTablePostfix(), pTab->id);
-
-			CDBManager::instance().ReturnQuery(szQuery,
-				QID_QUEST,
-				peer->GetHandle(),
-				new ClientHandleInfo(dwHandle, pTab->id));
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
-#if defined(__AFFECT_RENEWAL__)
-				", `bRealTime`"
-#endif
-				" FROM `affect%s` WHERE `dwPID` = %d",
-				GetTablePostfix(), pTab->id);
-
-			CDBManager::instance().ReturnQuery(szQuery,
-				QID_AFFECT,
-				peer->GetHandle(),
-				new ClientHandleInfo(dwHandle, pTab->id));
-		}
-		// ljw
-		//return;
-	}
-	// ---------------------------------------------------------------
-	// 2. 유저정보가 DBCache 에 없음 : DB에서
-	// ---------------------------------------------------------------
-	else
-	{
-		sys_log(0, "[PLAYER_LOAD] Load from PlayerDB pid[%d]", packet->player_id);
-
-		char queryStr[QUERY_MAX_LEN];
-
-		// ---------------------------------------------------------------
-		// 캐릭터 정보 얻어오기 : 무조건 DB에서
-		// ---------------------------------------------------------------
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT "
-			"`id`, `name`, `job`, `voice`, `dir`, `x`, `y`, `z`, `map_index`, "
-			"`exit_x`, `exit_y`, `exit_map_index`, `hp`, `mp`, `stamina`, `random_hp`, `random_sp`, `playtime`, "
-#if defined(__EXTEND_INVEN_SYSTEM__)
-			"`inven_stage`, "
-#endif
-			"`gold`, "
-#if defined(__CHEQUE_SYSTEM__)
-			"`cheque`, "
-#endif
-#if defined(__GEM_SYSTEM__)
-			"`gem`, "
-#endif
-			"`level`, "
-			"`level_step`, "
-			"`st`, `ht`, `dx`, `iq`, `exp`, "
-			"`stat_point`, "
-			"`skill_point`, "
-			"`sub_skill_point`, "
-			"`stat_reset_count`, "
-			"`part_base`, `part_hair`, "
-#if defined(__ACCE_COSTUME_SYSTEM__)
-			"`part_acce`, "
-#endif
-			"`skill_level`, "
-			"`quickslot`, "
-			"`skill_group`, "
-			"`alignment`, "
-#if defined(__CONQUEROR_LEVEL__)
-			"`conqueror_level`, "
-			"`conqueror_level_step`, "
-			"`sungma_str`, "
-			"`sungma_hp`, "
-			"`sungma_move`, "
-			"`sungma_immune`, "
-			"`conqueror_exp`, "
-			"`conqueror_point`, "
-#endif
-			"`horse_level`, "
-			"`horse_riding`, "
-			"`horse_hp`, "
-			"`horse_hp_droptime`, "
-			"`horse_stamina`, "
-			"UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(`last_play`), "
-			"`horse_skill_point`, "
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			"`battle_pass_premium_id` "
-#endif
-			" FROM player%s WHERE `id` = %d",
-			GetTablePostfix(), packet->player_id);
-
-		ClientHandleInfo* pkInfo = new ClientHandleInfo(dwHandle, packet->player_id);
-		pkInfo->account_id = packet->account_id;
-		CDBManager::instance().ReturnQuery(queryStr, QID_PLAYER, peer->GetHandle(), pkInfo);
-
-		// ---------------------------------------------------------------
-		// 아이템 가져오기
-		// ---------------------------------------------------------------
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
-#if defined(__SOUL_BIND_SYSTEM__)
-			", `soulbind`"
-#endif
-			", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-			", `socket3`, `socket4`, `socket5`"
-#endif
-			", `attrtype0`, `attrvalue0`"
-			", `attrtype1`, `attrvalue1`"
-			", `attrtype2`, `attrvalue2`"
-			", `attrtype3`, `attrvalue3`"
-			", `attrtype4`, `attrvalue4`"
-			", `attrtype5`, `attrvalue5`"
-			", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			", `transmutation`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			", `refine_element_apply_type`"
-			", `refine_element_grade`"
-			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			", `apply_type0`, `apply_value0`, `apply_path0`"
-			", `apply_type1`, `apply_value1`, `apply_path1`"
-			", `apply_type2`, `apply_value2`, `apply_path2`"
-			", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-			", `set_value`"
-#endif
-			" FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
-			"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
-#if defined(__ATTR_6TH_7TH__)
-			", 'NPC_STORAGE'"
-#endif
-			"))",
-			GetTablePostfix(), packet->player_id);
-
-		CDBManager::instance().ReturnQuery(queryStr, QID_ITEM, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
-
-		// ---------------------------------------------------------------
-		// QUEST 가져오기
-		// ---------------------------------------------------------------
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d",
-			GetTablePostfix(), packet->player_id);
-		CDBManager::instance().ReturnQuery(queryStr, QID_QUEST, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id, packet->account_id));
-		// 독일 선물 기능에서 item_award테이블에서 login 정보를 얻기위해 account id도 넘겨준다
-		// ---------------------------------------------------------------
-		// AFFECT 가져오기 
-		// ---------------------------------------------------------------
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
-#if defined(__AFFECT_RENEWAL__)
-			", `bRealTime`"
-#endif
-			" FROM `affect%s` WHERE `dwPID` = %d",
-			GetTablePostfix(), packet->player_id);
-		CDBManager::instance().ReturnQuery(queryStr, QID_AFFECT, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
-	}
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	// Load all missions from table
-	char queryStrBP[QUERY_MAX_LEN];
-	snprintf(queryStrBP, sizeof(queryStrBP),
-		"SELECT player_id, battlepass_type+0, mission_index, mission_type+0, battle_pass_id, extra_info, completed FROM battlepass_missions WHERE player_id = %d", packet->player_id);
-	CDBManager::instance().ReturnQuery(queryStrBP, QID_EXT_BATTLE_PASS, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	TGrowthPetCacheSet* pSet = GetGrowthPetCacheSet(packet->player_id);
-	if (pSet)
-	{
-		static std::vector<TGrowthPet> s_petVec;
-		s_petVec.resize(pSet->size());
-
-		DWORD dwCount = 0;
-		auto it = pSet->begin();
-
-		while (it != pSet->end())
-		{
-			CGrowthPetCache* c = *it++;
-			TGrowthPet* p = c->Get();
-
-			if (p->dwOwner)
-				thecore_memcpy(&s_petVec[dwCount++], p, sizeof(TGrowthPet));
-		}
-
-		peer->EncodeHeader(HEADER_DG_GROWTH_PET_LOAD, dwHandle, sizeof(DWORD) + sizeof(TGrowthPet) * dwCount);
-		peer->EncodeDWORD(dwCount);
-
-		if (dwCount)
-			peer->Encode(&s_petVec[0], sizeof(TGrowthPet) * dwCount);
-
-	}
-	else
-	{
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT id,vnum,state+0,name,size,level,level_step,evolution,type,hp,sp,def,hp_apply,sp_apply,def_apply,"
-			"age_apply,skill_level,exp,item_exp,UNIX_TIMESTAMP(birthday),end_time,max_time "
-			"FROM growth_pet%s WHERE owner_id=%d AND state < %d",
-			GetTablePostfix(), packet->player_id, STATE_SAFEBOX);
-
-		CDBManager::instance().ReturnQuery(szQuery,
-			QID_GROWTH_PET,
-			peer->GetHandle(),
-			new ClientHandleInfo(dwHandle, packet->player_id));
-	}
-#endif
-}
-
-void CClientManager::ItemAward(CPeer* peer, char* login)
-{
-	char login_t[LOGIN_MAX_LEN + 1] = "";
-	strlcpy(login_t, login, LOGIN_MAX_LEN + 1);
-	std::set<TItemAward*>* pSet = ItemAwardManager::instance().GetByLogin(login_t);
-	if (pSet == NULL)
-		return;
-
-	ItemAwardSet::iterator it = pSet->begin(); // taken_time 이 NULL 인것들 읽어옴
-	while (it != pSet->end())
-	{
-		TItemAward* pItemAward = *(it++);
-		char* whyStr = pItemAward->szWhy; // why 콜룸 읽기
-		char cmdStr[100] = ""; // why콜룸에서 읽은 값을 임시 문자열에 복사해둠
-		strcpy(cmdStr, whyStr); // 명령어 얻는 과정에서 토큰쓰면 원본도 토큰화 되기 때문
-		char command[20] = "";
-		GetCommand(cmdStr, command); // command 얻기
-		if (!(strcmp(cmdStr, "GIFT"))) // command 가 GIFT 이면
-		{
-			TPacketItemAwardInfromer giftData;
-			strcpy(giftData.login, pItemAward->szLogin); //로그인 아이디 복사
-			strcpy(giftData.command, command); // 명령어 복사
-			giftData.vnum = pItemAward->dwVnum; // 아이템 vnum 도 복사
-			ForwardPacket(HEADER_DG_ITEMAWARD_INFORMER, &giftData, sizeof(TPacketItemAwardInfromer));
-		}
-	}
-}
-
-char* CClientManager::GetCommand(char* str, char* command)
-{
-	// char* command = new char[20];
-	char* tok;
-
-	if (str[0] == '[')
-	{
-		tok = strtok(str, "]");
-		strcat(command, &tok[1]);
-	}
-
-	return command;
-	// free(command);
-}
-
-bool CreatePlayerTableFromRes(MYSQL_RES* res, TPlayerTable* pkTab)
-{
-	if (mysql_num_rows(res) == 0) // 데이터 없음
-		return false;
-
-	memset(pkTab, 0, sizeof(TPlayerTable));
-
-	MYSQL_ROW row = mysql_fetch_row(res);
-
-	int col = 0;
-
-	str_to_number(pkTab->id, row[col++]);
-	strlcpy(pkTab->name, row[col++], sizeof(pkTab->name));
-	str_to_number(pkTab->job, row[col++]);
-	str_to_number(pkTab->voice, row[col++]);
-	str_to_number(pkTab->dir, row[col++]);
-	str_to_number(pkTab->x, row[col++]);
-	str_to_number(pkTab->y, row[col++]);
-	str_to_number(pkTab->z, row[col++]);
-	str_to_number(pkTab->lMapIndex, row[col++]);
-	str_to_number(pkTab->lExitX, row[col++]);
-	str_to_number(pkTab->lExitY, row[col++]);
-	str_to_number(pkTab->lExitMapIndex, row[col++]);
-	str_to_number(pkTab->hp, row[col++]);
-	str_to_number(pkTab->sp, row[col++]);
-	str_to_number(pkTab->stamina, row[col++]);
-	str_to_number(pkTab->sRandomHP, row[col++]);
-	str_to_number(pkTab->sRandomSP, row[col++]);
-	str_to_number(pkTab->playtime, row[col++]);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	str_to_number(pkTab->inven_stage, row[col++]);
-#endif
-	str_to_number(pkTab->gold, row[col++]);
-#if defined(__CHEQUE_SYSTEM__)
-	str_to_number(pkTab->cheque, row[col++]);
-#endif
-#if defined(__GEM_SYSTEM__)
-	str_to_number(pkTab->gem, row[col++]);
-#endif
-	str_to_number(pkTab->level, row[col++]);
-	str_to_number(pkTab->level_step, row[col++]);
-	str_to_number(pkTab->st, row[col++]);
-	str_to_number(pkTab->ht, row[col++]);
-	str_to_number(pkTab->dx, row[col++]);
-	str_to_number(pkTab->iq, row[col++]);
-	str_to_number(pkTab->exp, row[col++]);
-	str_to_number(pkTab->stat_point, row[col++]);
-	str_to_number(pkTab->skill_point, row[col++]);
-	str_to_number(pkTab->sub_skill_point, row[col++]);
-	str_to_number(pkTab->stat_reset_count, row[col++]);
-	str_to_number(pkTab->part_base, row[col++]);
-	str_to_number(pkTab->adwParts[PART_HAIR], row[col++]);
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	str_to_number(pkTab->adwParts[PART_ACCE], row[col++]);
-#endif
-
-	if (row[col])
-		thecore_memcpy(pkTab->skills, row[col], sizeof(pkTab->skills));
-	else
-		memset(&pkTab->skills, 0, sizeof(pkTab->skills));
-
-	col++;
-
-	if (row[col])
-		thecore_memcpy(pkTab->quickslot, row[col], sizeof(pkTab->quickslot));
-	else
-		memset(pkTab->quickslot, 0, sizeof(pkTab->quickslot));
-
-	col++;
-
-	str_to_number(pkTab->skill_group, row[col++]);
-	str_to_number(pkTab->lAlignment, row[col++]);
-#if defined(__CONQUEROR_LEVEL__)
-	str_to_number(pkTab->conqueror_level, row[col++]);
-	str_to_number(pkTab->conqueror_level_step, row[col++]);
-	str_to_number(pkTab->sungma_str, row[col++]);
-	str_to_number(pkTab->sungma_hp, row[col++]);
-	str_to_number(pkTab->sungma_move, row[col++]);
-	str_to_number(pkTab->sungma_immune, row[col++]);
-	str_to_number(pkTab->conqueror_exp, row[col++]);
-	str_to_number(pkTab->conqueror_point, row[col++]);
-#endif
-	str_to_number(pkTab->horse.bLevel, row[col++]);
-	str_to_number(pkTab->horse.bRiding, row[col++]);
-	str_to_number(pkTab->horse.sHealth, row[col++]);
-	str_to_number(pkTab->horse.dwHorseHealthDropTime, row[col++]);
-	str_to_number(pkTab->horse.sStamina, row[col++]);
-	str_to_number(pkTab->logoff_interval, row[col++]);
-	str_to_number(pkTab->horse_skill_point, row[col++]);
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	str_to_number(pkTab->battle_pass_premium_id, row[col++]);
-#endif
-	// reset sub_skill_point
-	{
-		pkTab->skills[123].bLevel = 0; // SKILL_CREATE
-		if (pkTab->skills[130].bMasterType != 0) // SKILL_HORSE
-			pkTab->skills[130].bMasterType = SKILL_NORMAL;
-
-		if (pkTab->level > 9)
-		{
-			int max_point = pkTab->level - 9;
-
-			int skill_point =
-				MIN(20, pkTab->skills[121].bLevel) + // SKILL_LEADERSHIP 통솔력
-				MIN(20, pkTab->skills[124].bLevel) + // SKILL_MINING 채광
-				MIN(10, pkTab->skills[131].bLevel) + // SKILL_HORSE_SUMMON 말소환
-				MIN(20, pkTab->skills[141].bLevel) + // SKILL_ADD_HP HP보강
-				MIN(20, pkTab->skills[142].bLevel) + // SKILL_RESIST_PENETRATE 관통저항
-#if defined(__PARTY_PROFICY__)
-				MIN(20, pkTab->skills[133].bLevel) + // SKILL_ROLE_PROFICIENCY
-#endif
-#if defined(__PARTY_INSIGHT__)
-				MIN(20, pkTab->skills[134].bLevel) + // SKILL_INSIGHT
-#endif
-				MIN(20, pkTab->skills[246].bLevel); // SKILL_HIT
-
-			pkTab->sub_skill_point = max_point - skill_point;
-		}
-		else
-			pkTab->sub_skill_point = 0;
-	}
-
-	return true;
-}
-
-void CClientManager::RESULT_COMPOSITE_PLAYER(CPeer* peer, SQLMsg* pMsg, DWORD dwQID)
-{
-	CQueryInfo* qi = (CQueryInfo*)pMsg->pvUserData;
-	std::unique_ptr<ClientHandleInfo> info((ClientHandleInfo*)qi->pvData);
-
-	MYSQL_RES* pSQLResult = pMsg->Get()->pSQLResult;
-	if (!pSQLResult)
-	{
-		sys_err("null MYSQL_RES QID %u", dwQID);
-		return;
-	}
-
-	switch (dwQID)
-	{
-	case QID_PLAYER:
-		sys_log(0, "QID_PLAYER %u %u", info->dwHandle, info->player_id);
-		RESULT_PLAYER_LOAD(peer, pSQLResult, info.get());
-		break;
-
-	case QID_ITEM:
-		sys_log(0, "QID_ITEM %u", info->dwHandle);
-		RESULT_ITEM_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
-		break;
-
-	case QID_QUEST:
-	{
-		sys_log(0, "QID_QUEST %u", info->dwHandle);
-		RESULT_QUEST_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
-
-		// aid얻기
-		ClientHandleInfo* temp1 = info.get();
-		if (temp1 == NULL)
-			break;
-
-		CLoginData* pLoginData1 = GetLoginDataByAID(temp1->account_id);
-		// 독일 선물 기능
-		//if (pLoginData1->GetAccountRef().login == NULL)
-		//	break;
-
-		if (pLoginData1 == NULL)
-			break;
-
-		sys_log(0, "info of pLoginData1 before call ItemAwardfunction %d", pLoginData1);
-		ItemAward(peer, pLoginData1->GetAccountRef().login);
-	}
-	break;
-
-	case QID_AFFECT:
-		sys_log(0, "QID_AFFECT %u", info->dwHandle);
-		RESULT_AFFECT_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
-		break;
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	case QID_EXT_BATTLE_PASS:
-		sys_log(0, "QID_EXT_BATTLE_PASS %u", info->dwHandle);
-		RESULT_EXT_BATTLE_PASS_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
-		break;
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-	case QID_GROWTH_PET:
-		sys_log(0, "QID_GROWTH_PET %u", info->dwHandle);
-		RESULT_GROWTH_PET_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
-		break;
-#endif
-	}
-}
-
-void CClientManager::RESULT_PLAYER_LOAD(CPeer* peer, MYSQL_RES* pRes, ClientHandleInfo* pkInfo)
-{
-	TPlayerTable tab;
-
-	if (!CreatePlayerTableFromRes(pRes, &tab))
-	{
-		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, pkInfo->dwHandle, 0);
-		return;
-	}
-
-	CLoginData* pkLD = GetLoginDataByAID(pkInfo->account_id);
-
-	if (!pkLD || pkLD->IsPlay())
-	{
-		sys_log(0, "PLAYER_LOAD_ERROR: LoginData %p IsPlay %d", pkLD, pkLD ? pkLD->IsPlay() : 0);
-		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, pkInfo->dwHandle, 0);
-		return;
-	}
-
-	pkLD->SetPlay(true);
-	thecore_memcpy(tab.aiPremiumTimes, pkLD->GetPremiumPtr(), sizeof(tab.aiPremiumTimes));
-
-	peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_SUCCESS, pkInfo->dwHandle, sizeof(TPlayerTable));
-	peer->Encode(&tab, sizeof(TPlayerTable));
-
-	if (tab.id != pkLD->GetLastPlayerID())
-	{
-		TPacketNeedLoginLogInfo logInfo;
-		logInfo.dwPlayerID = tab.id;
-
-		pkLD->SetLastPlayerID(tab.id);
-
-		peer->EncodeHeader(HEADER_DG_NEED_LOGIN_LOG, pkInfo->dwHandle, sizeof(TPacketNeedLoginLogInfo));
-		peer->Encode(&logInfo, sizeof(TPacketNeedLoginLogInfo));
-	}
-}
-
-void CClientManager::RESULT_ITEM_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID)
-{
-	static std::vector<TPlayerItem> s_items;
-	// DB에서 아이템 정보를 읽어온다.
-	CreateItemTableFromRes(pRes, &s_items, dwPID);
-	DWORD dwCount = s_items.size();
-
-	peer->EncodeHeader(HEADER_DG_ITEM_LOAD, dwHandle, sizeof(DWORD) + sizeof(TPlayerItem) * dwCount);
-	peer->EncodeDWORD(dwCount);
-
-	// CacheSet을 만든다
-	CreateItemCacheSet(dwPID);
-
-	// ITEM_LOAD_LOG_ATTACH_PID
-	sys_log(0, "ITEM_LOAD: count %u pid %u", dwCount, dwPID);
-	// END_OF_ITEM_LOAD_LOG_ATTACH_PID
-
-	if (dwCount)
-	{
-		peer->Encode(&s_items[0], sizeof(TPlayerItem) * dwCount);
-
-		for (DWORD i = 0; i < dwCount; ++i)
-			PutItemCache(&s_items[i], true); // 로드한 것은 따로 저장할 필요 없으므로, 인자 bSkipQuery에 true를 넣는다.
-	}
-}
-
-void CClientManager::RESULT_AFFECT_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID)
-{
-	int iNumRows;
-
-	if ((iNumRows = static_cast<int>(mysql_num_rows(pRes))) == 0) // 데이터 없음
-	{
-		static DWORD dwPID;
-		static DWORD dwCount = 0; //1;
-		static TPacketAffectElement paeTable = { 0 };
-
-		dwPID = dwRealPID;
-		sys_log(0, "AFFECT_LOAD: count %u PID %u RealPID %u", dwCount, dwPID, dwRealPID);
-
-		peer->EncodeHeader(HEADER_DG_AFFECT_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPacketAffectElement) * dwCount);
-		peer->Encode(&dwPID, sizeof(DWORD));
-		peer->Encode(&dwCount, sizeof(DWORD));
-		peer->Encode(&paeTable, sizeof(TPacketAffectElement) * dwCount);
-		return;
-	}
-
-	static std::vector<TPacketAffectElement> s_elements;
-	s_elements.resize(iNumRows);
-
-	DWORD dwPID = 0;
-
-	MYSQL_ROW row;
-
-	for (int i = 0; i < iNumRows; ++i)
-	{
-		TPacketAffectElement& r = s_elements[i];
-		row = mysql_fetch_row(pRes);
-
-		if (dwPID == 0)
-			str_to_number(dwPID, row[0]);
-
-		str_to_number(r.dwType, row[1]);
-		str_to_number(r.wApplyOn, row[2]);
-		str_to_number(r.lApplyValue, row[3]);
-		str_to_number(r.dwFlag, row[4]);
-		str_to_number(r.lDuration, row[5]);
-		str_to_number(r.lSPCost, row[6]);
-#if defined(__AFFECT_RENEWAL__)
-		str_to_number(r.bRealTime, row[7]);
-		r.bUpdate = false;
-#endif
-	}
-
-	sys_log(0, "AFFECT_LOAD: count %d PID %u", s_elements.size(), dwPID);
-
-	DWORD dwCount = s_elements.size();
-
-	peer->EncodeHeader(HEADER_DG_AFFECT_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPacketAffectElement) * dwCount);
-	peer->Encode(&dwPID, sizeof(DWORD));
-	peer->Encode(&dwCount, sizeof(DWORD));
-	peer->Encode(&s_elements[0], sizeof(TPacketAffectElement) * dwCount);
-}
-
-void CClientManager::RESULT_QUEST_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD pid)
-{
-	int iNumRows;
-
-	if ((iNumRows = static_cast<int>(mysql_num_rows(pRes))) == 0)
-	{
-		DWORD dwCount = 0;
-		peer->EncodeHeader(HEADER_DG_QUEST_LOAD, dwHandle, sizeof(DWORD));
-		peer->Encode(&dwCount, sizeof(DWORD));
-		return;
-	}
-
-	static std::vector<TQuestTable> s_table;
-	s_table.resize(iNumRows);
-
-	MYSQL_ROW row;
-
-	for (int i = 0; i < iNumRows; ++i)
-	{
-		TQuestTable& r = s_table[i];
-
-		row = mysql_fetch_row(pRes);
-
-		str_to_number(r.dwPID, row[0]);
-		strlcpy(r.szName, row[1], sizeof(r.szName));
-		strlcpy(r.szState, row[2], sizeof(r.szState));
-		str_to_number(r.lValue, row[3]);
-	}
-
-	sys_log(0, "QUEST_LOAD: count %d PID %u", s_table.size(), s_table[0].dwPID);
-
-	DWORD dwCount = s_table.size();
-
-	peer->EncodeHeader(HEADER_DG_QUEST_LOAD, dwHandle, sizeof(DWORD) + sizeof(TQuestTable) * dwCount);
-	peer->Encode(&dwCount, sizeof(DWORD));
-	peer->Encode(&s_table[0], sizeof(TQuestTable) * dwCount);
-}
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-void CClientManager::RESULT_EXT_BATTLE_PASS_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID)
-{
-	int iNumRows;
-
-	if ((iNumRows = mysql_num_rows(pRes)) == 0)
-	{
-		DWORD dwCount = 0;
-		TPlayerExtBattlePassMission pbpTable = { 0 };
-
-		sys_log(0, "EXT_BATTLE_PASS_LOAD: count %u PID %u", dwCount, dwRealPID);
-
-		peer->EncodeHeader(HEADER_DG_EXT_BATTLE_PASS_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPlayerExtBattlePassMission) * dwCount);
-		peer->Encode(&dwRealPID, sizeof(DWORD));
-		peer->Encode(&dwCount, sizeof(DWORD));
-		peer->Encode(&pbpTable, sizeof(TPlayerExtBattlePassMission) * dwCount);
-		return;
-	}
-
-	static std::vector<TPlayerExtBattlePassMission> s_mission;
-	s_mission.resize(iNumRows);
-
-	MYSQL_ROW row;
-
-	for (int i = 0; i < iNumRows; ++i)
-	{
-		int col = 0;
-		TPlayerExtBattlePassMission& r = s_mission[i];
-		row = mysql_fetch_row(pRes);
-
-		str_to_number(r.dwPlayerId, row[col++]);
-		str_to_number(r.dwBattlePassType, row[col++]);
-		str_to_number(r.dwMissionIndex, row[col++]);
-		str_to_number(r.dwMissionType, row[col++]);
-		str_to_number(r.dwBattlePassId, row[col++]);
-		str_to_number(r.dwExtraInfo, row[col++]);
-		str_to_number(r.bCompleted, row[col++]);
-
-		r.bIsUpdated = 0;
-	}
-
-	sys_log(0, "EXT_BATTLE_PASS_LOAD: count %d PID %u", s_mission.size(), dwRealPID);
-
-	DWORD dwCount = s_mission.size();
-
-	peer->EncodeHeader(HEADER_DG_EXT_BATTLE_PASS_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPlayerExtBattlePassMission) * dwCount);
-	peer->Encode(&dwRealPID, sizeof(DWORD));
-	peer->Encode(&dwCount, sizeof(DWORD));
-	peer->Encode(&s_mission[0], sizeof(TPlayerExtBattlePassMission) * dwCount);
-}
-
-void CClientManager::QUERY_SAVE_EXT_BATTLE_PASS(CPeer* peer, DWORD dwHandle, TPlayerExtBattlePassMission* battlePass)
-{
-	if (g_test_server)
-		sys_log(0, "QUERY_SAVE_EXT_BATTLE_PASS: %lu", battlePass->dwPlayerId);
-
-	char szQuery[QUERY_MAX_LEN];
-	snprintf(szQuery, sizeof(szQuery),
-		"REPLACE INTO battlepass_missions (player_id, battlepass_type, mission_index, mission_type, battle_pass_id, extra_info, completed) VALUES (%lu, %d, %d, %d, %d, %d, %d)",
-		battlePass->dwPlayerId,
-		battlePass->dwBattlePassType,
-		battlePass->dwMissionIndex,
-		battlePass->dwMissionType,
-		battlePass->dwBattlePassId,
-		battlePass->dwExtraInfo,
-		battlePass->bCompleted ? 1 : 0);
-	CDBManager::instance().AsyncQuery(szQuery);
-}
-#endif
-
-/*
-* PLAYER SAVE
-*/
-void CClientManager::QUERY_PLAYER_SAVE(CPeer* peer, DWORD dwHandle, TPlayerTable* pkTab)
-{
-	if (g_test_server)
-		sys_log(0, "PLAYER_SAVE: %s", pkTab->name);
-
-	PutPlayerCache(pkTab);
-}
-
-typedef std::map<DWORD, time_t> time_by_id_map_t;
-static time_by_id_map_t s_createTimeByAccountID;
-
-/*
-* PLAYER CREATE
-*/
-void CClientManager::__QUERY_PLAYER_CREATE(CPeer* peer, DWORD dwHandle, TPlayerCreatePacket* packet)
-{
-	char queryStr[QUERY_MAX_LEN];
-	int queryLen;
-	int player_id;
-
-	// 한 계정에 X초 내로 캐릭터 생성을 할 수 없다.
-	time_by_id_map_t::iterator it = s_createTimeByAccountID.find(packet->account_id);
-
-	if (m_bDelayedCharacterCreation)
-	{
-		if (it != s_createTimeByAccountID.end())
-		{
-			time_t curtime = time(0);
-
-			if (curtime - it->second < 30)
-			{
-				peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-				return;
-			}
-		}
-	}
-
-	queryLen = snprintf(queryStr, sizeof(queryStr),
-		"SELECT `pid%d` FROM player_index%s WHERE `id` = %d", packet->account_index + 1, GetTablePostfix(), packet->account_id);
-
-	std::unique_ptr<SQLMsg> pMsg0(CDBManager::instance().DirectQuery(queryStr));
-
-	if (pMsg0->Get()->uiNumRows != 0)
-	{
-		if (!pMsg0->Get()->pSQLResult)
-		{
-			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-			return;
-		}
-
-		MYSQL_ROW row = mysql_fetch_row(pMsg0->Get()->pSQLResult);
-
-		DWORD dwPID = 0; str_to_number(dwPID, row[0]);
-		if (row[0] && dwPID > 0)
-		{
-			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
-			sys_log(0, "ALREADY EXIST AccountChrIdx %d ID %d", packet->account_index, dwPID);
-			return;
-		}
-	}
-	else
-	{
-		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-		return;
-	}
-
-	if (g_stLocale == "sjis")
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT COUNT(*) AS count FROM player%s WHERE `name` = '%s' COLLATE sjis_japanese_ci",
-			GetTablePostfix(), packet->player_table.name);
-	else
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT COUNT(*) AS count FROM player%s WHERE `name` = '%s'", GetTablePostfix(), packet->player_table.name);
-
-	std::unique_ptr<SQLMsg> pMsg1(CDBManager::instance().DirectQuery(queryStr));
-
-	if (pMsg1->Get()->uiNumRows)
-	{
-		if (!pMsg1->Get()->pSQLResult)
-		{
-			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-			return;
-		}
-
-		MYSQL_ROW row = mysql_fetch_row(pMsg1->Get()->pSQLResult);
-
-		if (*row[0] != '0')
-		{
-			sys_log(0, "ALREADY EXIST name %s, row[0] %s query %s", packet->player_table.name, row[0], queryStr);
-			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
-			return;
-		}
-	}
-	else
-	{
-		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-		return;
-	}
-
-	queryLen = snprintf(queryStr, sizeof(queryStr),
-		"INSERT INTO player%s "
-		"(`id`, `account_id`, `name`, `level`, `st`, `ht`, `dx`, `iq`, "
-		"`job`, `voice`, `dir`, `x`, `y`, `z`, "
-		"`hp`, `mp`, `random_hp`, `random_sp`, `stat_point`, `stamina`, "
-		"`part_base`, `part_main`, `part_hair`, "
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		"`part_acce`, "
-#endif
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		"`inven_stage`, "
-#endif
-		"`gold`, "
-#if defined(__CHEQUE_SYSTEM__)
-		"`cheque`, "
-#endif
-#if defined(__GEM_SYSTEM__)
-		"`gem`, "
-#endif
-		"`playtime`, `skill_level`, `quickslot`) "
-		"VALUES (0, "
-		"%u, "
-		"'%s', " // name
-		"%d, " // level
-		"%d, " // st
-		"%d, " // ht
-		"%d, " // dx
-		"%d, " // iq
-		"%d, " // job
-		"%d, " // voice
-		"%d, " // dir
-		"%d, " // x
-		"%d, " // y
-		"%d, " // z
-		"%d, " // hp
-		"%d, " // sp
-		"%d, " // sRandomHP
-		"%d, " // sRandomSP
-		"%d, " // stat_point
-		"%d, " // stamina
-		"%d, " // part_base
-		"%d, " // part_base
-		"%d, " // part_base(hair)
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		"%d, " // part_base(acce)
-#endif
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		"%d, " // inven_stage
-#endif
-		"%d, " // gold
-#if defined(__CHEQUE_SYSTEM__)
-		"%d, " // cheque
-#endif
-#if defined(__GEM_SYSTEM__)
-		"%d, " // gem
-#endif
-		"0, "
-		, GetTablePostfix()
-		, packet->account_id
-		, packet->player_table.name
-		, packet->player_table.level
-		, packet->player_table.st
-		, packet->player_table.ht
-		, packet->player_table.dx
-		, packet->player_table.iq
-		, packet->player_table.job
-		, packet->player_table.voice
-		, packet->player_table.dir
-		, packet->player_table.x
-		, packet->player_table.y
-		, packet->player_table.z
-		, packet->player_table.hp
-		, packet->player_table.sp
-		, packet->player_table.sRandomHP
-		, packet->player_table.sRandomSP
-		, packet->player_table.stat_point
-		, packet->player_table.stamina
-		, packet->player_table.part_base
-		, packet->player_table.part_base
-		, packet->player_table.adwParts[PART_HAIR]
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		, packet->player_table.adwParts[PART_ACCE]
-#endif
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		, packet->player_table.inven_stage
-#endif
-		, packet->player_table.gold
-#if defined(__CHEQUE_SYSTEM__)
-		, packet->player_table.cheque
-#endif
-#if defined(__GEM_SYSTEM__)
-		, packet->player_table.gem
-#endif
-	);
-
-	sys_log(0, "PlayerCreate accountid %d name %s level %d gold %d"
-#if defined(__CHEQUE_SYSTEM__)
-		" cheque %d"
-#endif
-#if defined(__GEM_SYSTEM__)
-		" gem %d"
-#endif
-		", st %d ht %d job %d"
-		, packet->account_id
-		, packet->player_table.name
-		, packet->player_table.level
-		, packet->player_table.gold
-#if defined(__CHEQUE_SYSTEM__)
-		, packet->player_table.cheque
-#endif
-#if defined(__GEM_SYSTEM__)
-		, packet->player_table.gem
-#endif
-		, packet->player_table.st
-		, packet->player_table.ht
-		, packet->player_table.job
-	);
-
-	static char text[QUERY_MAX_LEN];
-
-	CDBManager::instance().EscapeString(text, packet->player_table.skills, sizeof(packet->player_table.skills));
-	queryLen += snprintf(queryStr + queryLen, sizeof(queryStr) - queryLen, "'%s', ", text);
-	if (g_test_server)
-		sys_log(0, "Create_Player queryLen[%d] TEXT[%s]", queryLen, text);
-
-	CDBManager::instance().EscapeString(text, packet->player_table.quickslot, sizeof(packet->player_table.quickslot));
-	queryLen += snprintf(queryStr + queryLen, sizeof(queryStr) - queryLen, "'%s')", text);
-
-	std::unique_ptr<SQLMsg> pMsg2(CDBManager::instance().DirectQuery(queryStr));
-	if (g_test_server)
-		sys_log(0, "Create_Player queryLen[%d] TEXT[%s]", queryLen, text);
-
-	if (pMsg2->Get()->uiAffectedRows <= 0)
-	{
-		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
-		sys_log(0, "ALREADY EXIST3 query: %s AffectedRows %lu", queryStr, pMsg2->Get()->uiAffectedRows);
-		return;
-	}
-
-	player_id = pMsg2->Get()->uiInsertID;
-
-	snprintf(queryStr, sizeof(queryStr), "UPDATE player_index%s SET `pid%d` = %d WHERE `id` = %d",
-		GetTablePostfix(), packet->account_index + 1, player_id, packet->account_id);
-	std::unique_ptr<SQLMsg> pMsg3(CDBManager::instance().DirectQuery(queryStr));
-
-	if (pMsg3->Get()->uiAffectedRows <= 0)
-	{
-		sys_err("QUERY_ERROR: %s", queryStr);
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM player%s WHERE `id` = %d", GetTablePostfix(), player_id);
-		CDBManager::instance().DirectQuery(queryStr);
-
-		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-		return;
-	}
-
-	TPacketDGCreateSuccess pack;
-	memset(&pack, 0, sizeof(pack));
-
-	pack.bAccountCharacterIndex = packet->account_index;
-
-	pack.player.dwID = player_id;
-	strlcpy(pack.player.szName, packet->player_table.name, sizeof(pack.player.szName));
-	pack.player.byJob = packet->player_table.job;
-	pack.player.byLevel = 1;
-	pack.player.dwPlayMinutes = 0;
-	pack.player.byST = packet->player_table.st;
-	pack.player.byHT = packet->player_table.ht;
-	pack.player.byDX = packet->player_table.dx;
-	pack.player.byIQ = packet->player_table.iq;
-#if defined(__CONQUEROR_LEVEL__)
-	pack.player.byConquerorLevel = packet->player_table.conqueror_level;
-	pack.player.bySungmaStr = packet->player_table.sungma_str;
-	pack.player.bySungmaHp = packet->player_table.sungma_hp;
-	pack.player.bySungmaMove = packet->player_table.sungma_move;
-	pack.player.bySungmaImmune = packet->player_table.sungma_immune;
-#endif
-	pack.player.dwMainPart = packet->player_table.part_base;
-	pack.player.x = packet->player_table.x;
-	pack.player.y = packet->player_table.y;
-	pack.player.last_play = packet->player_table.last_play;
-
-	peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_SUCCESS, dwHandle, sizeof(TPacketDGCreateSuccess));
-	peer->Encode(&pack, sizeof(TPacketDGCreateSuccess));
-
-	sys_log(0, "7 name %s job %d", pack.player.szName, pack.player.byJob);
-
-	s_createTimeByAccountID[packet->account_id] = time(0);
-}
-
-/*
-* PLAYER DELETE
-*/
-#if defined(__DELETE_FAILURE_TYPE__)
-static char QUERY_CHECK_PLAYER_DELETE(DWORD dwPID, DWORD dwAID, INT* piWaitTime)
-{
-	*piWaitTime = 0;
-
-	SQLMsg* pMsg = NULL;
-	char szQuery[QUERY_MAX_LEN] = {};
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	// Check if the player has any sealed items.
-	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `soulbind` != 0", GetTablePostfix(), dwPID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get()->uiNumRows)
-		return DELETE_FAILURE_HAVE_SEALED_ITEM;
-#endif
-
-	// Check if the player is a member of a guild.
-	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM guild_member%s WHERE `pid` = %d", GetTablePostfix(), dwPID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get()->uiNumRows)
-		return DELETE_FAILURE_GUILD_MEMBER;
-
-	// Check if the player is married.
-	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM marriage%s WHERE `pid1` = %d OR `pid2` = %d", GetTablePostfix(), dwPID, dwPID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get()->uiNumRows)
-		return DELETE_FAILURE_MARRIAGE;
-
-	// Check if the player is the last character on the account and if there are any items in the safebox.
-	snprintf(szQuery, sizeof(szQuery), "SELECT COUNT(*) FROM `player%s` WHERE `account_id` = %u;", GetTablePostfix(), dwAID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get() && pMsg->Get()->uiNumRows)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-
-		BYTE bPlayerCount = 0;
-		str_to_number(bPlayerCount, row[0]);
-
-		if (bPlayerCount == 1)
-		{
-			snprintf(szQuery, sizeof(szQuery), "SELECT * FROM `item%s` WHERE `owner_id` = %u AND `window` = 'SAFEBOX' > 0;", GetTablePostfix(), dwAID);
-			pMsg = CDBManager::Instance().DirectQuery(szQuery);
-			if (pMsg->Get()->uiNumRows)
-				return DELETE_FAILURE_LAST_CHAR_SAFEBOX;
-		}
-	}
-
-#if defined(__ATTR_6TH_7TH__)
-	// Check if the player has any items in the NPC storage.
-	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `window` = 'NPC_STORAGE'", GetTablePostfix(), dwPID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get()->uiNumRows)
-		return DELETE_FAILURE_ATTR67;
-#endif
-
-	// Check if the player has any items in the premium private shop.
-	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `window` = 'PREMIUM_PRIVATE_SHOP'", GetTablePostfix(), dwPID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get()->uiNumRows)
-		return DELETE_FAILURE_PREMIUM_PRIVATE_SHOP;
-
-	// Check if the player has at least 10 minutes of playtime.
-	/*
-	CPlayerTableCache* pPlayerTableCache = CClientManager::Instance().GetPlayerCache(dwPID);
-	INT iPlayTime = pPlayerTableCache ? pPlayerTableCache->Get(false)->playtime : 0;
-	if (iPlayTime < 10)
-	{
-		*piWaitTime = 10 - iPlayTime;
-		return DELETE_FAILURE_REMAIN_TIME;
-	}
-	*/
-
-	return -1;
-}
-#endif
-
-void CClientManager::__QUERY_PLAYER_DELETE(CPeer* peer, DWORD dwHandle, TPlayerDeletePacket* packet)
-{
-	if (!packet->login[0] || !packet->player_id || packet->account_index >= PLAYER_PER_ACCOUNT)
-		return;
-
-	CLoginData* ld = GetLoginDataByLogin(packet->login);
-
-	if (!ld)
-	{
-#if defined(__DELETE_FAILURE_TYPE__)
-		TPlayerDeleteFailurePacket DelFailurePacket = {};
-		DelFailurePacket.bType = DELETE_FAILURE_NORMAL;
-		DelFailurePacket.iTime = 0;
-		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
-		peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
-#else
-		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
-		peer->EncodeBYTE(packet->account_index);
-#endif
-		return;
-	}
-
-	TAccountTable& r = ld->GetAccountRef();
-
-	// block for japan
-	if (g_stLocale != "sjis")
-	{
-		if (!IsChinaEventServer())
-		{
-			if (strlen(r.social_id) < 7 || strncmp(packet->private_code, r.social_id + strlen(r.social_id) - 7, 7))
-			{
-				sys_log(0, "PLAYER_DELETE FAILED len(%d)", strlen(r.social_id));
-#if defined(__DELETE_FAILURE_TYPE__)
-				TPlayerDeleteFailurePacket DelFailurePacket;
-				DelFailurePacket.bType = DELETE_FAILURE_PRIVATE_CODE_ERROR;
-				DelFailurePacket.iTime = 0;
-				peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
-				peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
-#else
-				peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
-				peer->EncodeBYTE(packet->account_index);
-#endif
-				return;
-			}
-
-			CPlayerTableCache* pkPlayerCache = GetPlayerCache(packet->player_id);
-			if (pkPlayerCache)
-			{
-				TPlayerTable* pTab = pkPlayerCache->Get();
-
-				if (pTab->level >= m_iPlayerDeleteLevelLimit)
-				{
-					sys_log(0, "PLAYER_DELETE FAILED LEVEL %u >= DELETE LIMIT %d", pTab->level, m_iPlayerDeleteLevelLimit);
-#if defined(__DELETE_FAILURE_TYPE__)
-					TPlayerDeleteFailurePacket DelFailurePacket;
-					DelFailurePacket.bType = DELETE_FAILURE_LIMITE_LEVEL_HIGHER;
-					DelFailurePacket.iTime = 0;
-					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
-					peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
-#else
-					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
-					peer->EncodeBYTE(packet->account_index);
-#endif
-					return;
-				}
-
-				if (pTab->level < m_iPlayerDeleteLevelLimitLower)
-				{
-					sys_log(0, "PLAYER_DELETE FAILED LEVEL %u < DELETE LIMIT %d", pTab->level, m_iPlayerDeleteLevelLimitLower);
-#if defined(__DELETE_FAILURE_TYPE__)
-					TPlayerDeleteFailurePacket DelFailurePacket;
-					DelFailurePacket.bType = DELETE_FAILURE_LIMITE_LEVEL_LOWER;
-					DelFailurePacket.iTime = 0;
-					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
-					peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
-#else
-					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
-					peer->EncodeBYTE(packet->account_index);
-#endif
-					return;
-				}
-			}
-		}
-	}
-
-#if defined(__DELETE_FAILURE_TYPE__)
-	INT iWaitTime;
-	const char bFailureType = QUERY_CHECK_PLAYER_DELETE(packet->player_id, r.id, &iWaitTime);
-	if (bFailureType != -1)
-	{
-		TPlayerDeleteFailurePacket DelFailurePacket;
-		DelFailurePacket.bType = bFailureType;
-		DelFailurePacket.iTime = iWaitTime;
-		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
-		peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
-		return;
-}
-#endif
-
-	char szQuery[128];
-	snprintf(szQuery, sizeof(szQuery), "SELECT p.`id`, p.`level`, p.`name` FROM player_index%s AS i, player%s AS p WHERE `pid%d` = %u AND `pid%d` = p.`id`",
-		GetTablePostfix(), GetTablePostfix(), packet->account_index + 1, packet->player_id, packet->account_index + 1);
-
-	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle, packet->player_id);
-	pi->account_index = packet->account_index;
-
-	sys_log(0, "PLAYER_DELETE TRY: %s %d pid%d", packet->login, packet->player_id, packet->account_index + 1);
-	CDBManager::instance().ReturnQuery(szQuery, QID_PLAYER_DELETE, peer->GetHandle(), pi);
-}
-
-//
-// @version	05/06/10 Bang2ni - 플레이어 삭제시 가격정보 리스트 삭제 추가.
-//
-void CClientManager::__RESULT_PLAYER_DELETE(CPeer* peer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
-
-	if (msg->Get() && msg->Get()->uiNumRows)
-	{
-		MYSQL_ROW row = mysql_fetch_row(msg->Get()->pSQLResult);
-
-		DWORD dwPID = 0;
-		str_to_number(dwPID, row[0]);
-
-		int deletedLevelLimit = 0;
-		str_to_number(deletedLevelLimit, row[1]);
-
-		char szName[64];
-		strlcpy(szName, row[2], sizeof(szName));
-
-		if (deletedLevelLimit >= m_iPlayerDeleteLevelLimit && !IsChinaEventServer())
-		{
-			sys_log(0, "PLAYER_DELETE FAILED LEVEL %u >= DELETE LIMIT %d", deletedLevelLimit, m_iPlayerDeleteLevelLimit);
-			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
-			peer->EncodeBYTE(pi->account_index);
-			return;
-		}
-
-		if (deletedLevelLimit < m_iPlayerDeleteLevelLimitLower)
-		{
-			sys_log(0, "PLAYER_DELETE FAILED LEVEL %u < DELETE LIMIT %d", deletedLevelLimit, m_iPlayerDeleteLevelLimitLower);
-			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
-			peer->EncodeBYTE(pi->account_index);
-			return;
-		}
-
-		char queryStr[QUERY_MAX_LEN];
-
-		snprintf(queryStr, sizeof(queryStr), "INSERT INTO player_deleted%s SELECT * FROM player%s WHERE `id` = %d",
-			GetTablePostfix(), GetTablePostfix(), pi->player_id);
-		std::unique_ptr<SQLMsg> pIns(CDBManager::instance().DirectQuery(queryStr));
-
-		if (pIns->Get()->uiAffectedRows == 0 || pIns->Get()->uiAffectedRows == (uint32_t)-1)
-		{
-			sys_log(0, "PLAYER_DELETE FAILED %u CANNOT INSERT TO player_deleted%s", dwPID, GetTablePostfix());
-
-			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
-			peer->EncodeBYTE(pi->account_index);
-			return;
-		}
-
-		// 삭제 성공
-		sys_log(0, "PLAYER_DELETE SUCCESS %u", dwPID);
-
-		// char account_index_string[16];
-
-		// snprintf(account_index_string, sizeof(account_index_string), "player_id%d", m_iPlayerIDStart + pi->account_index);
-
-		// 플레이어 테이블을 캐쉬에서 삭제한다.
-		CPlayerTableCache* pkPlayerCache = GetPlayerCache(pi->player_id);
-
-		if (pkPlayerCache)
-		{
-			m_map_playerCache.erase(pi->player_id);
-			delete pkPlayerCache;
-		}
-
-		// 아이템들을 캐쉬에서 삭제한다.
-		TItemCacheSet* pSet = GetItemCacheSet(pi->player_id);
-
-		if (pSet)
-		{
-			TItemCacheSet::iterator it = pSet->begin();
-
-			while (it != pSet->end())
-			{
-				CItemCache* pkItemCache = *it++;
-				DeleteItemCache(pkItemCache->Get()->dwID);
-			}
-
-			pSet->clear();
-			delete pSet;
-
-			m_map_pkItemCacheSetPtr.erase(pi->player_id);
-		}
-
-		snprintf(queryStr, sizeof(queryStr), "UPDATE player_index%s SET `pid%d` = 0 WHERE `pid%d` = %d",
-			GetTablePostfix(),
-			pi->account_index + 1,
-			pi->account_index + 1,
-			pi->player_id);
-
-		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(queryStr));
-
-		if (pMsg->Get()->uiAffectedRows == 0 || pMsg->Get()->uiAffectedRows == (uint32_t)-1)
-		{
-			sys_log(0, "PLAYER_DELETE FAIL WHEN UPDATE account table");
-			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
-			peer->EncodeBYTE(pi->account_index);
-			return;
-		}
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `player%s` WHERE `id` = %u", GetTablePostfix(), pi->player_id);
-		delete CDBManager::instance().DirectQuery(queryStr);
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
-			"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
-#if defined(__ATTR_6TH_7TH__)
-			", 'NPC_STORAGE'"
-#endif
-			"))", GetTablePostfix(), pi->player_id);
-		delete CDBManager::instance().DirectQuery(queryStr);
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `quest%s` WHERE `dwPID` = %d", GetTablePostfix(), pi->player_id);
-		CDBManager::instance().AsyncQuery(queryStr);
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `affect%s` WHERE `dwPID` = %d", GetTablePostfix(), pi->player_id);
-		CDBManager::instance().AsyncQuery(queryStr);
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `guild_member%s` WHERE `pid` = %u", GetTablePostfix(), pi->player_id);
-		CDBManager::instance().AsyncQuery(queryStr);
-
-		// MYSHOP_PRICE_LIST
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `myshop_pricelist%s` WHERE `owner_id` = %u", GetTablePostfix(), pi->player_id);
-		CDBManager::instance().AsyncQuery(queryStr);
-		// END_OF_MYSHOP_PRICE_LIST
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `messenger_list%s` WHERE `account` = '%s' OR `companion` = '%s'", GetTablePostfix(), szName, szName);
-		CDBManager::instance().AsyncQuery(queryStr);
-
-		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_SUCCESS, pi->dwHandle, 1);
-		peer->EncodeBYTE(pi->account_index);
-	}
-	else
-	{
-		// 삭제 실패
-		sys_log(0, "PLAYER_DELETE FAIL NO ROW");
-		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
-		peer->EncodeBYTE(pi->account_index);
-	}
-}
-
-void CClientManager::QUERY_ADD_AFFECT(CPeer* peer, TPacketGDAddAffect* p)
-{
-	char query[QUERY_MAX_LEN];
-#if defined(__AFFECT_RENEWAL__)
-	if (p->elem.bUpdate)
-	{
-		snprintf(query, sizeof(query),
-			"UPDATE `affect%s` SET `lApplyValue` = %ld, `dwFlag` = %u, `lDuration` = %ld, `lSPCost` = %ld, `bRealTime` = %d "
-			"WHERE `dwPID` = %u AND `dwType` = %u AND `wApplyOn` = %u",
-			GetTablePostfix(),
-			p->elem.lApplyValue,
-			p->elem.dwFlag,
-			p->elem.lDuration,
-			p->elem.lSPCost,
-			p->elem.bRealTime ? 1 : 0,
-			p->dwPID,
-			p->elem.dwType,
-			p->elem.wApplyOn);
-	}
-	else
-	{
-		snprintf(query, sizeof(query),
-			"REPLACE INTO `affect%s` (`dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`, `bRealTime`) "
-			"VALUES(%u, %u, %u, %ld, %u, %ld, %ld, %d)",
-			GetTablePostfix(),
-			p->dwPID,
-			p->elem.dwType,
-			p->elem.wApplyOn,
-			p->elem.lApplyValue,
-			p->elem.dwFlag,
-			p->elem.lDuration,
-			p->elem.lSPCost,
-			p->elem.bRealTime ? 1 : 0);
-	}
-#else
-	snprintf(query, sizeof(query),
-		"REPLACE INTO `affect%s` (`dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`) "
-		"VALUES(%u, %u, %u, %ld, %u, %ld, %ld)",
-		GetTablePostfix(),
-		p->dwPID,
-		p->elem.dwType,
-		p->elem.wApplyOn,
-		p->elem.lApplyValue,
-		p->elem.dwFlag,
-		p->elem.lDuration,
-		p->elem.lSPCost
-	);
-#endif
-	CDBManager::instance().AsyncQuery(query);
-}
-
-void CClientManager::QUERY_REMOVE_AFFECT(CPeer* peer, TPacketGDRemoveAffect* p)
-{
-	char query[QUERY_MAX_LEN];
-	snprintf(query, sizeof(query),
-		"DELETE FROM `affect%s` WHERE `dwPID` = %u AND `dwType` = %u AND `wApplyOn` = %u",
-		GetTablePostfix(), p->dwPID, p->dwType, p->wApplyOn);
-	CDBManager::instance().AsyncQuery(query);
-}
-
-void CClientManager::QUERY_HIGHSCORE_REGISTER(CPeer* peer, TPacketGDHighscore* data)
-{
-	char escBoard[sizeof(data->szBoard) * 2 + 1];
-	const size_t boardLen = strnlen(data->szBoard, sizeof(data->szBoard));
-	CDBManager::instance().EscapeString(escBoard, data->szBoard, boardLen);
-
-	char szQuery[256];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `value` FROM highscore%s WHERE `board` = '%s' AND `pid` = %u", GetTablePostfix(), escBoard, data->dwPID);
-
-	sys_log(0, "HEADER_GD_HIGHSCORE_REGISTER: PID %u", data->dwPID);
-
-	ClientHandleInfo* pi = new ClientHandleInfo(0);
-	strlcpy(pi->login, data->szBoard, sizeof(pi->login));
-	pi->account_id = (DWORD)data->lValue;
-	pi->player_id = data->dwPID;
-	pi->account_index = (data->cDir > 0);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_HIGHSCORE_REGISTER, peer->GetHandle(), pi);
-}
-
-void CClientManager::RESULT_HIGHSCORE_REGISTER(CPeer* pkPeer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
-	//DWORD dwHandle = pi->dwHandle;
-
-	char szBoard[21];
-	strlcpy(szBoard, pi->login, sizeof(szBoard));
-	int value = (int)pi->account_id;
-
-	SQLResult* res = msg->Get();
-
-	if (res->uiNumRows == 0)
-	{
-		// 새로운 하이스코어를 삽입
-		char buf[256];
-		snprintf(buf, sizeof(buf), "INSERT INTO highscore%s VALUES('%s', %u, %d)", GetTablePostfix(), szBoard, pi->player_id, value);
-		CDBManager::instance().AsyncQuery(buf);
-	}
-	else
-	{
-		if (!res->pSQLResult)
-		{
-			delete pi;
-			return;
-		}
-
-		MYSQL_ROW row = mysql_fetch_row(res->pSQLResult);
-		if (row && row[0])
-		{
-			int current_value = 0; str_to_number(current_value, row[0]);
-			if ((pi->account_index && current_value >= value) || (!pi->account_index && current_value <= value))
-			{
-				value = current_value;
-			}
-			else
-			{
-				char buf[256];
-				snprintf(buf, sizeof(buf), "REPLACE INTO highscore%s VALUES('%s', %u, %d)", GetTablePostfix(), szBoard, pi->player_id, value);
-				CDBManager::instance().AsyncQuery(buf);
-			}
-		}
-		else
-		{
-			char buf[256];
-			snprintf(buf, sizeof(buf), "INSERT INTO highscore%s VALUES('%s', %u, %d)", GetTablePostfix(), szBoard, pi->player_id, value);
-			CDBManager::instance().AsyncQuery(buf);
-		}
-	}
-	// TODO: 이곳에서 하이스코어가 업데이트 되었는지 체크하여 공지를 뿌려야한다.
-	delete pi;
-}
-
-void CClientManager::InsertLogoutPlayer(DWORD pid)
-{
-	TLogoutPlayerMap::iterator it = m_map_logout.find(pid);
-
-	// 존재하지 않을경우 추가
-	if (it != m_map_logout.end())
-	{
-		// 존재할경우 시간만 갱신
-		if (g_log)
-			sys_log(0, "LOGOUT: Update player time pid(%d)", pid);
-
-		it->second->time = time(0);
-		return;
-	}
-
-	TLogoutPlayer* pLogout = new TLogoutPlayer;
-	pLogout->pid = pid;
-	pLogout->time = time(0);
-	m_map_logout.insert(std::make_pair(pid, pLogout));
-
-	if (g_log)
-		sys_log(0, "LOGOUT: Insert player pid(%d)", pid);
-}
-
-void CClientManager::DeleteLogoutPlayer(DWORD pid)
-{
-	TLogoutPlayerMap::iterator it = m_map_logout.find(pid);
-
-	if (it != m_map_logout.end())
-	{
-		delete it->second;
-		m_map_logout.erase(it);
-	}
-}
-
-extern int g_iLogoutSeconds;
-
-void CClientManager::UpdateLogoutPlayer()
-{
-	time_t now = time(0);
-
-	TLogoutPlayerMap::iterator it = m_map_logout.begin();
-
-	while (it != m_map_logout.end())
-	{
-		TLogoutPlayer* pLogout = it->second;
-
-		if (now - g_iLogoutSeconds > pLogout->time)
-		{
-			FlushItemCacheSet(pLogout->pid);
-			FlushPlayerCacheSet(pLogout->pid);
-#ifdef __GROWTH_PET_SYSTEM__
-			FlushGrowthPetCacheSet(pLogout->pid);
-#endif
-			delete pLogout;
-			m_map_logout.erase(it++);
-		}
-		else
-			++it;
-	}
-}
-
-void CClientManager::FlushPlayerCacheSet(DWORD pid)
-{
-	TPlayerTableCacheMap::iterator it = m_map_playerCache.find(pid);
-
-	if (it != m_map_playerCache.end())
-	{
-		CPlayerTableCache* c = it->second;
-		m_map_playerCache.erase(it);
-
-		c->Flush();
-		delete c;
-	}
-}
+#include "stdafx.h"
+
+#include "ClientManager.h"
+
+#include "Main.h"
+#include "QID.h"
+#include "ItemAwardManager.h"
+#include "HB.h"
+#include "Cache.h"
+
+extern bool g_bHotBackup;
+
+extern std::string g_stLocale;
+extern int g_test_server;
+extern int g_log;
+
+//
+// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+// !!!!!!!!!!! IMPORTANT !!!!!!!!!!!!
+// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+//
+// Check all SELECT syntax on item table before change this function!!!
+//
+bool CreateItemTableFromRes(MYSQL_RES* res, std::vector<TPlayerItem>* pVec, DWORD dwPID)
+{
+	if (!res)
+	{
+		pVec->clear();
+		return true;
+	}
+
+	int rows;
+
+	if ((rows = static_cast<int>(mysql_num_rows(res))) <= 0) //  
+	{
+		pVec->clear();
+		return true;
+	}
+
+	pVec->resize(rows);
+
+	for (int i = 0; i < rows; ++i)
+	{
+		MYSQL_ROW row = mysql_fetch_row(res);
+		TPlayerItem& item = pVec->at(i);
+
+		int cur = 0;
+
+		// Check all SELECT syntax on item table before change this function!!!
+		// Check all SELECT syntax on item table before change this function!!!
+		// Check all SELECT syntax on item table before change this function!!!
+		str_to_number(item.dwID, row[cur++]);
+		str_to_number(item.bWindow, row[cur++]);
+		str_to_number(item.wPos, row[cur++]);
+		str_to_number(item.dwVnum, row[cur++]);
+		str_to_number(item.dwCount, row[cur++]);
+
+#if defined(__SOUL_BIND_SYSTEM__)
+		str_to_number(item.lSealDate, row[cur++]);
+#endif
+
+		for (BYTE i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
+			str_to_number(item.alSockets[i], row[cur++]);
+
+		for (int j = 0; j < ITEM_ATTRIBUTE_MAX_NUM; j++)
+		{
+			str_to_number(item.aAttr[j].wType, row[cur++]);
+			str_to_number(item.aAttr[j].lValue, row[cur++]);
+		}
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		str_to_number(item.dwTransmutationVnum, row[cur++]);
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		str_to_number(item.RefineElement.wApplyType, row[cur++]);
+		str_to_number(item.RefineElement.bGrade, row[cur++]);
+		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
+			str_to_number(item.RefineElement.abValue[i], row[cur++]);
+		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
+			str_to_number(item.RefineElement.abBonusValue[i], row[cur++]);
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+		for (int j = 0; j < ITEM_APPLY_MAX_NUM; j++)
+		{
+			str_to_number(item.aApplyRandom[j].wType, row[cur++]);
+			str_to_number(item.aApplyRandom[j].lValue, row[cur++]);
+			str_to_number(item.aApplyRandom[j].bPath, row[cur++]);
+		}
+#endif
+
+#if defined(__SET_ITEM__)
+		str_to_number(item.bSetValue, row[cur++]);
+#endif
+
+		item.dwOwner = dwPID;
+	}
+
+	return true;
+}
+
+size_t CreatePlayerSaveQuery(char* pszQuery, size_t querySize, TPlayerTable* pkTab)
+{
+	size_t queryLen;
+
+	queryLen = snprintf(pszQuery, querySize,
+		"UPDATE player%s SET "
+		"`job` = %d, "
+		"`voice` = %d, "
+		"`dir` = %d, "
+		"`x` = %d, "
+		"`y` = %d, "
+		"`z` = %d, "
+		"`map_index` = %d, "
+		"`exit_x` = %ld, "
+		"`exit_y` = %ld, "
+		"`exit_map_index` = %ld, "
+		"`hp` = %d, "
+		"`mp` = %d, "
+		"`stamina` = %d, "
+		"`random_hp` = %d, "
+		"`random_sp` = %d, "
+		"`playtime` = %d, "
+		"`level` = %d, "
+		"`level_step` = %d, "
+		"`st` = %d, "
+		"`ht` = %d, "
+		"`dx` = %d, "
+		"`iq` = %d, "
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		"`inven_stage` = %d, "
+#endif
+		"`gold` = %d, "
+#if defined(__CHEQUE_SYSTEM__)
+		"`cheque` = %d, "
+#endif
+#if defined(__GEM_SYSTEM__)
+		"`gem` = %d, "
+#endif
+		"`exp` = %u, "
+		"`stat_point` = %d, "
+		"`skill_point` = %d, "
+		"`sub_skill_point` = %d, "
+		"`stat_reset_count` = %d, "
+		"`ip` = '%s', "
+		"`part_main` = %d, "
+		"`part_hair` = %d, "
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		"`part_acce` = %d, "
+#endif
+		"`last_play` = NOW(), "
+		"`skill_group` = %d, "
+		"`alignment` = %ld, "
+#if defined(__CONQUEROR_LEVEL__)
+		"`conqueror_level` = %d, "
+		"`conqueror_level_step` = %d, "
+		"`sungma_str` = %d, "
+		"`sungma_hp` = %d, "
+		"`sungma_move` = %d, "
+		"`sungma_immune` = %d, "
+		"`conqueror_exp` = %u, "
+		"`conqueror_point` = %d, "
+#endif
+		"`horse_level` = %d, "
+		"`horse_riding` = %d, "
+		"`horse_hp` = %d, "
+		"`horse_hp_droptime` = %u, "
+		"`horse_stamina` = %d, "
+		"`horse_skill_point` = %d, "
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		"`battle_pass_premium_id` = %d, "
+#endif
+		,
+		GetTablePostfix(),
+		pkTab->job,
+		pkTab->voice,
+		pkTab->dir,
+		pkTab->x,
+		pkTab->y,
+		pkTab->z,
+		pkTab->lMapIndex,
+		pkTab->lExitX,
+		pkTab->lExitY,
+		pkTab->lExitMapIndex,
+		pkTab->hp,
+		pkTab->sp,
+		pkTab->stamina,
+		pkTab->sRandomHP,
+		pkTab->sRandomSP,
+		pkTab->playtime,
+		pkTab->level,
+		pkTab->level_step,
+		pkTab->st,
+		pkTab->ht,
+		pkTab->dx,
+		pkTab->iq,
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		pkTab->inven_stage,
+#endif
+		pkTab->gold,
+#if defined(__CHEQUE_SYSTEM__)
+		pkTab->cheque,
+#endif
+#if defined(__GEM_SYSTEM__)
+		pkTab->gem,
+#endif
+		pkTab->exp,
+		pkTab->stat_point,
+		pkTab->skill_point,
+		pkTab->sub_skill_point,
+		pkTab->stat_reset_count,
+		pkTab->ip,
+		pkTab->adwParts[PART_MAIN],
+		pkTab->adwParts[PART_HAIR],
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		pkTab->adwParts[PART_ACCE],
+#endif
+		pkTab->skill_group,
+		pkTab->lAlignment,
+#if defined(__CONQUEROR_LEVEL__)
+		pkTab->conqueror_level,
+		pkTab->conqueror_level_step,
+		pkTab->sungma_str,
+		pkTab->sungma_hp,
+		pkTab->sungma_move,
+		pkTab->sungma_immune,
+		pkTab->conqueror_exp,
+		pkTab->conqueror_point,
+#endif
+		pkTab->horse.bLevel,
+		pkTab->horse.bRiding,
+		pkTab->horse.sHealth,
+		pkTab->horse.dwHorseHealthDropTime,
+		pkTab->horse.sStamina,
+		pkTab->horse_skill_point,
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		pkTab->battle_pass_premium_id
+#endif
+	);
+
+	// Binary  侮袂  擔 
+	static char text[QUERY_MAX_LEN];
+
+	CDBManager::instance().EscapeString(text, pkTab->skills, sizeof(pkTab->skills));
+	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, "`skill_level` = '%s', ", text);
+
+	CDBManager::instance().EscapeString(text, pkTab->quickslot, sizeof(pkTab->quickslot));
+	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, "`quickslot` = '%s' ", text);
+
+	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, " WHERE `id` = %d", pkTab->id);
+	return queryLen;
+}
+
+CPlayerTableCache* CClientManager::GetPlayerCache(DWORD id)
+{
+	TPlayerTableCacheMap::iterator it = m_map_playerCache.find(id);
+
+	if (it == m_map_playerCache.end())
+		return NULL;
+
+	TPlayerTable* pTable = it->second->Get(false);
+	pTable->logoff_interval = static_cast<DWORD>(GetCurrentTime()) - it->second->GetLastUpdateTime();
+	return it->second;
+}
+
+void CClientManager::PutPlayerCache(TPlayerTable* pNew)
+{
+	CPlayerTableCache* c;
+
+	c = GetPlayerCache(pNew->id);
+
+	if (!c)
+	{
+		c = new CPlayerTableCache;
+		m_map_playerCache.insert(TPlayerTableCacheMap::value_type(pNew->id, c));
+	}
+
+	if (g_bHotBackup)
+		PlayerHB::instance().Put(pNew->id);
+
+	c->Put(pNew);
+}
+
+/*
+* PLAYER LOAD
+*/
+void CClientManager::QUERY_PLAYER_LOAD(CPeer* peer, DWORD dwHandle, TPlayerLoadPacket* packet)
+{
+	CPlayerTableCache* c;
+	TPlayerTable* pTab;
+
+	//
+	//     캐孤 캐처
+	//
+	CLoginData* pLoginData = GetLoginDataByAID(packet->account_id);
+
+	if (pLoginData)
+	{
+		for (int n = 0; n < PLAYER_PER_ACCOUNT; ++n)
+			if (pLoginData->GetAccountRef().players[n].dwID != 0)
+				DeleteLogoutPlayer(pLoginData->GetAccountRef().players[n].dwID);
+	}
+
+	// ---------------------------------------------------------------
+	// 1.  DBCache   : DBCache
+	// 2.  DBCache   : DB
+	// ---------------------------------------------------------------
+
+	// ---------------------------------------------------------------
+	// 1.  DBCache   : DBCache
+	// ---------------------------------------------------------------
+	if ((c = GetPlayerCache(packet->player_id)))
+	{
+		CLoginData* pkLD = GetLoginDataByAID(packet->account_id);
+
+		if (!pkLD || pkLD->IsPlay())
+		{
+			sys_log(0, "PLAYER_LOAD_ERROR: LoginData %p IsPlay %d", pkLD, pkLD ? pkLD->IsPlay() : 0);
+			peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, dwHandle, 0);
+			return;
+		}
+
+		pTab = c->Get();
+
+		pkLD->SetPlay(true);
+		thecore_memcpy(pTab->aiPremiumTimes, pkLD->GetPremiumPtr(), sizeof(pTab->aiPremiumTimes));
+
+		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_SUCCESS, dwHandle, sizeof(TPlayerTable));
+		peer->Encode(pTab, sizeof(TPlayerTable));
+
+		if (packet->player_id != pkLD->GetLastPlayerID())
+		{
+			TPacketNeedLoginLogInfo logInfo;
+			logInfo.dwPlayerID = packet->player_id;
+
+			pkLD->SetLastPlayerID(packet->player_id);
+
+			peer->EncodeHeader(HEADER_DG_NEED_LOGIN_LOG, dwHandle, sizeof(TPacketNeedLoginLogInfo));
+			peer->Encode(&logInfo, sizeof(TPacketNeedLoginLogInfo));
+		}
+
+		char szQuery[1024] = { 0, };
+
+		TItemCacheSet* pSet = GetItemCacheSet(pTab->id);
+
+		sys_log(0, "[PLAYER_LOAD] ID %s pid %d gold %d "
+#if defined(__CHEQUE_SYSTEM__)
+			"cheque %d "
+#endif
+#if defined(__GEM_SYSTEM__)
+			"gem %d "
+#endif
+			, pTab->name
+			, pTab->id
+			, pTab->gold
+#if defined(__CHEQUE_SYSTEM__)
+			, pTab->cheque
+#endif
+#if defined(__GEM_SYSTEM__)
+			, pTab->gem
+#endif
+		);
+
+		// ---------------------------------------------------------------
+		//  & AFFECT & QUEST 琯 :
+		// ---------------------------------------------------------------
+		// 1)  DBCache   : DBCache  
+		// 2)  DBCache   : DB  
+
+		///////////////////////////////////////////////////////////////
+		// 1)  DBCache   : DBCache  
+		///////////////////////////////////////////////////////////////
+		if (pSet)
+		{
+			static std::vector<TPlayerItem> s_items;
+			s_items.resize(pSet->size());
+
+			DWORD dwCount = 0;
+			TItemCacheSet::iterator it = pSet->begin();
+
+			while (it != pSet->end())
+			{
+				CItemCache* c = *it++;
+				TPlayerItem* p = c->Get();
+
+				if (p->dwVnum) // vnum   甄.
+					thecore_memcpy(&s_items[dwCount++], p, sizeof(TPlayerItem));
+			}
+
+			if (g_test_server)
+				sys_log(0, "ITEM_CACHE: HIT! %s count: %u", pTab->name, dwCount);
+
+			peer->EncodeHeader(HEADER_DG_ITEM_LOAD, dwHandle, sizeof(DWORD) + sizeof(TPlayerItem) * dwCount);
+			peer->EncodeDWORD(dwCount);
+
+			if (dwCount)
+				peer->Encode(&s_items[0], sizeof(TPlayerItem) * dwCount);
+
+			// Quest
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d AND `lValue` <> 0",
+				GetTablePostfix(), pTab->id);
+
+			CDBManager::instance().ReturnQuery(szQuery, QID_QUEST, peer->GetHandle(), new ClientHandleInfo(dwHandle, 0, packet->account_id));
+
+			// Affect
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
+#if defined(__AFFECT_RENEWAL__)
+				", `bRealTime`"
+#endif
+				" FROM `affect%s` WHERE `dwPID` = %d",
+				GetTablePostfix(), pTab->id);
+			CDBManager::instance().ReturnQuery(szQuery, QID_AFFECT, peer->GetHandle(), new ClientHandleInfo(dwHandle, pTab->id));
+		}
+		///////////////////////////////////////////////////////////////
+		// 2)  DBCache   : DB  
+		///////////////////////////////////////////////////////////////
+		else
+		{
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
+#if defined(__SOUL_BIND_SYSTEM__)
+				", `soulbind`"
+#endif
+				", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+				", `socket3`, `socket4`, `socket5`"
+#endif
+				", `attrtype0`, `attrvalue0`"
+				", `attrtype1`, `attrvalue1`"
+				", `attrtype2`, `attrvalue2`"
+				", `attrtype3`, `attrvalue3`"
+				", `attrtype4`, `attrvalue4`"
+				", `attrtype5`, `attrvalue5`"
+				", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				", `transmutation`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				", `refine_element_apply_type`"
+				", `refine_element_grade`"
+				", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+				", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+				", `apply_type0`, `apply_value0`, `apply_path0`"
+				", `apply_type1`, `apply_value1`, `apply_path1`"
+				", `apply_type2`, `apply_value2`, `apply_path2`"
+				", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+				", `set_value`"
+#endif
+				" FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
+				"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
+#if defined(__ATTR_6TH_7TH__)
+				", 'NPC_STORAGE'"
+#endif
+				"))",
+				GetTablePostfix(), pTab->id);
+
+			CDBManager::instance().ReturnQuery(szQuery,
+				QID_ITEM,
+				peer->GetHandle(),
+				new ClientHandleInfo(dwHandle, pTab->id));
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d",
+				GetTablePostfix(), pTab->id);
+
+			CDBManager::instance().ReturnQuery(szQuery,
+				QID_QUEST,
+				peer->GetHandle(),
+				new ClientHandleInfo(dwHandle, pTab->id));
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
+#if defined(__AFFECT_RENEWAL__)
+				", `bRealTime`"
+#endif
+				" FROM `affect%s` WHERE `dwPID` = %d",
+				GetTablePostfix(), pTab->id);
+
+			CDBManager::instance().ReturnQuery(szQuery,
+				QID_AFFECT,
+				peer->GetHandle(),
+				new ClientHandleInfo(dwHandle, pTab->id));
+		}
+		// ljw
+		//return;
+	}
+	// ---------------------------------------------------------------
+	// 2.  DBCache   : DB
+	// ---------------------------------------------------------------
+	else
+	{
+		sys_log(0, "[PLAYER_LOAD] Load from PlayerDB pid[%d]", packet->player_id);
+
+		char queryStr[QUERY_MAX_LEN];
+
+		// ---------------------------------------------------------------
+		// 캐   :  DB
+		// ---------------------------------------------------------------
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT "
+			"`id`, `name`, `job`, `voice`, `dir`, `x`, `y`, `z`, `map_index`, "
+			"`exit_x`, `exit_y`, `exit_map_index`, `hp`, `mp`, `stamina`, `random_hp`, `random_sp`, `playtime`, "
+#if defined(__EXTEND_INVEN_SYSTEM__)
+			"`inven_stage`, "
+#endif
+			"`gold`, "
+#if defined(__CHEQUE_SYSTEM__)
+			"`cheque`, "
+#endif
+#if defined(__GEM_SYSTEM__)
+			"`gem`, "
+#endif
+			"`level`, "
+			"`level_step`, "
+			"`st`, `ht`, `dx`, `iq`, `exp`, "
+			"`stat_point`, "
+			"`skill_point`, "
+			"`sub_skill_point`, "
+			"`stat_reset_count`, "
+			"`part_base`, `part_hair`, "
+#if defined(__ACCE_COSTUME_SYSTEM__)
+			"`part_acce`, "
+#endif
+			"`skill_level`, "
+			"`quickslot`, "
+			"`skill_group`, "
+			"`alignment`, "
+#if defined(__CONQUEROR_LEVEL__)
+			"`conqueror_level`, "
+			"`conqueror_level_step`, "
+			"`sungma_str`, "
+			"`sungma_hp`, "
+			"`sungma_move`, "
+			"`sungma_immune`, "
+			"`conqueror_exp`, "
+			"`conqueror_point`, "
+#endif
+			"`horse_level`, "
+			"`horse_riding`, "
+			"`horse_hp`, "
+			"`horse_hp_droptime`, "
+			"`horse_stamina`, "
+			"UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(`last_play`), "
+			"`horse_skill_point`, "
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			"`battle_pass_premium_id` "
+#endif
+			" FROM player%s WHERE `id` = %d",
+			GetTablePostfix(), packet->player_id);
+
+		ClientHandleInfo* pkInfo = new ClientHandleInfo(dwHandle, packet->player_id);
+		pkInfo->account_id = packet->account_id;
+		CDBManager::instance().ReturnQuery(queryStr, QID_PLAYER, peer->GetHandle(), pkInfo);
+
+		// ---------------------------------------------------------------
+		//  
+		// ---------------------------------------------------------------
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
+#if defined(__SOUL_BIND_SYSTEM__)
+			", `soulbind`"
+#endif
+			", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+			", `socket3`, `socket4`, `socket5`"
+#endif
+			", `attrtype0`, `attrvalue0`"
+			", `attrtype1`, `attrvalue1`"
+			", `attrtype2`, `attrvalue2`"
+			", `attrtype3`, `attrvalue3`"
+			", `attrtype4`, `attrvalue4`"
+			", `attrtype5`, `attrvalue5`"
+			", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			", `transmutation`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			", `refine_element_apply_type`"
+			", `refine_element_grade`"
+			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			", `apply_type0`, `apply_value0`, `apply_path0`"
+			", `apply_type1`, `apply_value1`, `apply_path1`"
+			", `apply_type2`, `apply_value2`, `apply_path2`"
+			", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+			", `set_value`"
+#endif
+			" FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
+			"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
+#if defined(__ATTR_6TH_7TH__)
+			", 'NPC_STORAGE'"
+#endif
+			"))",
+			GetTablePostfix(), packet->player_id);
+
+		CDBManager::instance().ReturnQuery(queryStr, QID_ITEM, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
+
+		// ---------------------------------------------------------------
+		// QUEST 
+		// ---------------------------------------------------------------
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d",
+			GetTablePostfix(), packet->player_id);
+		CDBManager::instance().ReturnQuery(queryStr, QID_QUEST, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id, packet->account_id));
+		//    item_award遣 login   account id 璣娩
+		// ---------------------------------------------------------------
+		// AFFECT  
+		// ---------------------------------------------------------------
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
+#if defined(__AFFECT_RENEWAL__)
+			", `bRealTime`"
+#endif
+			" FROM `affect%s` WHERE `dwPID` = %d",
+			GetTablePostfix(), packet->player_id);
+		CDBManager::instance().ReturnQuery(queryStr, QID_AFFECT, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
+	}
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	// Load all missions from table
+	char queryStrBP[QUERY_MAX_LEN];
+	snprintf(queryStrBP, sizeof(queryStrBP),
+		"SELECT player_id, battlepass_type+0, mission_index, mission_type+0, battle_pass_id, extra_info, completed FROM battlepass_missions WHERE player_id = %d", packet->player_id);
+	CDBManager::instance().ReturnQuery(queryStrBP, QID_EXT_BATTLE_PASS, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	TGrowthPetCacheSet* pSet = GetGrowthPetCacheSet(packet->player_id);
+	if (pSet)
+	{
+		static std::vector<TGrowthPet> s_petVec;
+		s_petVec.resize(pSet->size());
+
+		DWORD dwCount = 0;
+		auto it = pSet->begin();
+
+		while (it != pSet->end())
+		{
+			CGrowthPetCache* c = *it++;
+			TGrowthPet* p = c->Get();
+
+			if (p->dwOwner)
+				thecore_memcpy(&s_petVec[dwCount++], p, sizeof(TGrowthPet));
+		}
+
+		peer->EncodeHeader(HEADER_DG_GROWTH_PET_LOAD, dwHandle, sizeof(DWORD) + sizeof(TGrowthPet) * dwCount);
+		peer->EncodeDWORD(dwCount);
+
+		if (dwCount)
+			peer->Encode(&s_petVec[0], sizeof(TGrowthPet) * dwCount);
+
+	}
+	else
+	{
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT id,owner_id,vnum,state+0,name,size,level,level_step,evolution,type,hp,sp,def,hp_apply,sp_apply,def_apply,"
+			"age_apply,skill_level,exp,item_exp,UNIX_TIMESTAMP(birthday),end_time,max_time "
+			"FROM growth_pet%s WHERE owner_id=%d",
+			GetTablePostfix(), packet->player_id);
+
+		CDBManager::instance().ReturnQuery(szQuery,
+			QID_GROWTH_PET,
+			peer->GetHandle(),
+			new ClientHandleInfo(dwHandle, packet->player_id));
+	}
+#endif
+}
+
+void CClientManager::ItemAward(CPeer* peer, char* login)
+{
+	char login_t[LOGIN_MAX_LEN + 1] = "";
+	strlcpy(login_t, login, LOGIN_MAX_LEN + 1);
+	std::set<TItemAward*>* pSet = ItemAwardManager::instance().GetByLogin(login_t);
+	if (pSet == NULL)
+		return;
+
+	ItemAwardSet::iterator it = pSet->begin(); // taken_time  NULL 寬孤 棘
+	while (it != pSet->end())
+	{
+		TItemAward* pItemAward = *(it++);
+		char* whyStr = pItemAward->szWhy; // why 賦 閨
+		char cmdStr[100] = ""; // why賦肉   擔 悶 巒
+		strcpy(cmdStr, whyStr); //    큰  큰화 풉 
+		char command[20] = "";
+		GetCommand(cmdStr, command); // command 
+		if (!(strcmp(cmdStr, "GIFT"))) // command  GIFT 見
+		{
+			TPacketItemAwardInfromer giftData;
+			strcpy(giftData.login, pItemAward->szLogin); //慣 絹 
+			strcpy(giftData.command, command); //  
+			giftData.vnum = pItemAward->dwVnum; //  vnum  
+			ForwardPacket(HEADER_DG_ITEMAWARD_INFORMER, &giftData, sizeof(TPacketItemAwardInfromer));
+		}
+	}
+}
+
+char* CClientManager::GetCommand(char* str, char* command)
+{
+	// char* command = new char[20];
+	char* tok;
+
+	if (str[0] == '[')
+	{
+		tok = strtok(str, "]");
+		strcat(command, &tok[1]);
+	}
+
+	return command;
+	// free(command);
+}
+
+bool CreatePlayerTableFromRes(MYSQL_RES* res, TPlayerTable* pkTab)
+{
+	if (mysql_num_rows(res) == 0) //  
+		return false;
+
+	memset(pkTab, 0, sizeof(TPlayerTable));
+
+	MYSQL_ROW row = mysql_fetch_row(res);
+
+	int col = 0;
+
+	str_to_number(pkTab->id, row[col++]);
+	strlcpy(pkTab->name, row[col++], sizeof(pkTab->name));
+	str_to_number(pkTab->job, row[col++]);
+	str_to_number(pkTab->voice, row[col++]);
+	str_to_number(pkTab->dir, row[col++]);
+	str_to_number(pkTab->x, row[col++]);
+	str_to_number(pkTab->y, row[col++]);
+	str_to_number(pkTab->z, row[col++]);
+	str_to_number(pkTab->lMapIndex, row[col++]);
+	str_to_number(pkTab->lExitX, row[col++]);
+	str_to_number(pkTab->lExitY, row[col++]);
+	str_to_number(pkTab->lExitMapIndex, row[col++]);
+	str_to_number(pkTab->hp, row[col++]);
+	str_to_number(pkTab->sp, row[col++]);
+	str_to_number(pkTab->stamina, row[col++]);
+	str_to_number(pkTab->sRandomHP, row[col++]);
+	str_to_number(pkTab->sRandomSP, row[col++]);
+	str_to_number(pkTab->playtime, row[col++]);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	str_to_number(pkTab->inven_stage, row[col++]);
+#endif
+	str_to_number(pkTab->gold, row[col++]);
+#if defined(__CHEQUE_SYSTEM__)
+	str_to_number(pkTab->cheque, row[col++]);
+#endif
+#if defined(__GEM_SYSTEM__)
+	str_to_number(pkTab->gem, row[col++]);
+#endif
+	str_to_number(pkTab->level, row[col++]);
+	str_to_number(pkTab->level_step, row[col++]);
+	str_to_number(pkTab->st, row[col++]);
+	str_to_number(pkTab->ht, row[col++]);
+	str_to_number(pkTab->dx, row[col++]);
+	str_to_number(pkTab->iq, row[col++]);
+	str_to_number(pkTab->exp, row[col++]);
+	str_to_number(pkTab->stat_point, row[col++]);
+	str_to_number(pkTab->skill_point, row[col++]);
+	str_to_number(pkTab->sub_skill_point, row[col++]);
+	str_to_number(pkTab->stat_reset_count, row[col++]);
+	str_to_number(pkTab->part_base, row[col++]);
+	str_to_number(pkTab->adwParts[PART_HAIR], row[col++]);
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	str_to_number(pkTab->adwParts[PART_ACCE], row[col++]);
+#endif
+
+	if (row[col])
+		thecore_memcpy(pkTab->skills, row[col], sizeof(pkTab->skills));
+	else
+		memset(&pkTab->skills, 0, sizeof(pkTab->skills));
+
+	col++;
+
+	if (row[col])
+		thecore_memcpy(pkTab->quickslot, row[col], sizeof(pkTab->quickslot));
+	else
+		memset(pkTab->quickslot, 0, sizeof(pkTab->quickslot));
+
+	col++;
+
+	str_to_number(pkTab->skill_group, row[col++]);
+	str_to_number(pkTab->lAlignment, row[col++]);
+#if defined(__CONQUEROR_LEVEL__)
+	str_to_number(pkTab->conqueror_level, row[col++]);
+	str_to_number(pkTab->conqueror_level_step, row[col++]);
+	str_to_number(pkTab->sungma_str, row[col++]);
+	str_to_number(pkTab->sungma_hp, row[col++]);
+	str_to_number(pkTab->sungma_move, row[col++]);
+	str_to_number(pkTab->sungma_immune, row[col++]);
+	str_to_number(pkTab->conqueror_exp, row[col++]);
+	str_to_number(pkTab->conqueror_point, row[col++]);
+#endif
+	str_to_number(pkTab->horse.bLevel, row[col++]);
+	str_to_number(pkTab->horse.bRiding, row[col++]);
+	str_to_number(pkTab->horse.sHealth, row[col++]);
+	str_to_number(pkTab->horse.dwHorseHealthDropTime, row[col++]);
+	str_to_number(pkTab->horse.sStamina, row[col++]);
+	str_to_number(pkTab->logoff_interval, row[col++]);
+	str_to_number(pkTab->horse_skill_point, row[col++]);
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	str_to_number(pkTab->battle_pass_premium_id, row[col++]);
+#endif
+	// reset sub_skill_point
+	{
+		pkTab->skills[123].bLevel = 0; // SKILL_CREATE
+		if (pkTab->skills[130].bMasterType != 0) // SKILL_HORSE
+			pkTab->skills[130].bMasterType = SKILL_NORMAL;
+
+		if (pkTab->level > 9)
+		{
+			int max_point = pkTab->level - 9;
+
+			int skill_point =
+				MIN(20, pkTab->skills[121].bLevel) + // SKILL_LEADERSHIP 囹
+				MIN(20, pkTab->skills[124].bLevel) + // SKILL_MINING 채
+				MIN(10, pkTab->skills[131].bLevel) + // SKILL_HORSE_SUMMON 환
+				MIN(20, pkTab->skills[141].bLevel) + // SKILL_ADD_HP HP
+				MIN(20, pkTab->skills[142].bLevel) + // SKILL_RESIST_PENETRATE 
+#if defined(__PARTY_PROFICY__)
+				MIN(20, pkTab->skills[133].bLevel) + // SKILL_ROLE_PROFICIENCY
+#endif
+#if defined(__PARTY_INSIGHT__)
+				MIN(20, pkTab->skills[134].bLevel) + // SKILL_INSIGHT
+#endif
+				MIN(20, pkTab->skills[246].bLevel); // SKILL_HIT
+
+			pkTab->sub_skill_point = max_point - skill_point;
+		}
+		else
+			pkTab->sub_skill_point = 0;
+	}
+
+	return true;
+}
+
+void CClientManager::RESULT_COMPOSITE_PLAYER(CPeer* peer, SQLMsg* pMsg, DWORD dwQID)
+{
+	CQueryInfo* qi = (CQueryInfo*)pMsg->pvUserData;
+	std::unique_ptr<ClientHandleInfo> info((ClientHandleInfo*)qi->pvData);
+
+	MYSQL_RES* pSQLResult = pMsg->Get()->pSQLResult;
+	if (!pSQLResult)
+	{
+		sys_err("null MYSQL_RES QID %u", dwQID);
+		return;
+	}
+
+	switch (dwQID)
+	{
+	case QID_PLAYER:
+		sys_log(0, "QID_PLAYER %u %u", info->dwHandle, info->player_id);
+		RESULT_PLAYER_LOAD(peer, pSQLResult, info.get());
+		break;
+
+	case QID_ITEM:
+		sys_log(0, "QID_ITEM %u", info->dwHandle);
+		RESULT_ITEM_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
+		break;
+
+	case QID_QUEST:
+	{
+		sys_log(0, "QID_QUEST %u", info->dwHandle);
+		RESULT_QUEST_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
+
+		// aid
+		ClientHandleInfo* temp1 = info.get();
+		if (temp1 == NULL)
+			break;
+
+		CLoginData* pLoginData1 = GetLoginDataByAID(temp1->account_id);
+		//   
+		//if (pLoginData1->GetAccountRef().login == NULL)
+		//	break;
+
+		if (pLoginData1 == NULL)
+			break;
+
+		sys_log(0, "info of pLoginData1 before call ItemAwardfunction %d", pLoginData1);
+		ItemAward(peer, pLoginData1->GetAccountRef().login);
+	}
+	break;
+
+	case QID_AFFECT:
+		sys_log(0, "QID_AFFECT %u", info->dwHandle);
+		RESULT_AFFECT_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
+		break;
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	case QID_EXT_BATTLE_PASS:
+		sys_log(0, "QID_EXT_BATTLE_PASS %u", info->dwHandle);
+		RESULT_EXT_BATTLE_PASS_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
+		break;
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+	case QID_GROWTH_PET:
+		sys_log(0, "QID_GROWTH_PET %u", info->dwHandle);
+		RESULT_GROWTH_PET_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
+		break;
+#endif
+	}
+}
+
+void CClientManager::RESULT_PLAYER_LOAD(CPeer* peer, MYSQL_RES* pRes, ClientHandleInfo* pkInfo)
+{
+	TPlayerTable tab;
+
+	if (!CreatePlayerTableFromRes(pRes, &tab))
+	{
+		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, pkInfo->dwHandle, 0);
+		return;
+	}
+
+	CLoginData* pkLD = GetLoginDataByAID(pkInfo->account_id);
+
+	if (!pkLD || pkLD->IsPlay())
+	{
+		sys_log(0, "PLAYER_LOAD_ERROR: LoginData %p IsPlay %d", pkLD, pkLD ? pkLD->IsPlay() : 0);
+		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, pkInfo->dwHandle, 0);
+		return;
+	}
+
+	pkLD->SetPlay(true);
+	thecore_memcpy(tab.aiPremiumTimes, pkLD->GetPremiumPtr(), sizeof(tab.aiPremiumTimes));
+
+	peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_SUCCESS, pkInfo->dwHandle, sizeof(TPlayerTable));
+	peer->Encode(&tab, sizeof(TPlayerTable));
+
+	if (tab.id != pkLD->GetLastPlayerID())
+	{
+		TPacketNeedLoginLogInfo logInfo;
+		logInfo.dwPlayerID = tab.id;
+
+		pkLD->SetLastPlayerID(tab.id);
+
+		peer->EncodeHeader(HEADER_DG_NEED_LOGIN_LOG, pkInfo->dwHandle, sizeof(TPacketNeedLoginLogInfo));
+		peer->Encode(&logInfo, sizeof(TPacketNeedLoginLogInfo));
+	}
+}
+
+void CClientManager::RESULT_ITEM_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID)
+{
+	static std::vector<TPlayerItem> s_items;
+	// DB   棘쨈.
+	CreateItemTableFromRes(pRes, &s_items, dwPID);
+	DWORD dwCount = s_items.size();
+
+	peer->EncodeHeader(HEADER_DG_ITEM_LOAD, dwHandle, sizeof(DWORD) + sizeof(TPlayerItem) * dwCount);
+	peer->EncodeDWORD(dwCount);
+
+	// CacheSet 
+	CreateItemCacheSet(dwPID);
+
+	// ITEM_LOAD_LOG_ATTACH_PID
+	sys_log(0, "ITEM_LOAD: count %u pid %u", dwCount, dwPID);
+	// END_OF_ITEM_LOAD_LOG_ATTACH_PID
+
+	if (dwCount)
+	{
+		peer->Encode(&s_items[0], sizeof(TPlayerItem) * dwCount);
+
+		for (DWORD i = 0; i < dwCount; ++i)
+			PutItemCache(&s_items[i], true); // 琯    却 퓐,  bSkipQuery true 獵쨈.
+	}
+}
+
+void CClientManager::RESULT_AFFECT_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID)
+{
+	int iNumRows;
+
+	if ((iNumRows = static_cast<int>(mysql_num_rows(pRes))) == 0) //  
+	{
+		static DWORD dwPID;
+		static DWORD dwCount = 0; //1;
+		static TPacketAffectElement paeTable = { 0 };
+
+		dwPID = dwRealPID;
+		sys_log(0, "AFFECT_LOAD: count %u PID %u RealPID %u", dwCount, dwPID, dwRealPID);
+
+		peer->EncodeHeader(HEADER_DG_AFFECT_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPacketAffectElement) * dwCount);
+		peer->Encode(&dwPID, sizeof(DWORD));
+		peer->Encode(&dwCount, sizeof(DWORD));
+		peer->Encode(&paeTable, sizeof(TPacketAffectElement) * dwCount);
+		return;
+	}
+
+	static std::vector<TPacketAffectElement> s_elements;
+	s_elements.resize(iNumRows);
+
+	DWORD dwPID = 0;
+
+	MYSQL_ROW row;
+
+	for (int i = 0; i < iNumRows; ++i)
+	{
+		TPacketAffectElement& r = s_elements[i];
+		row = mysql_fetch_row(pRes);
+
+		if (dwPID == 0)
+			str_to_number(dwPID, row[0]);
+
+		str_to_number(r.dwType, row[1]);
+		str_to_number(r.wApplyOn, row[2]);
+		str_to_number(r.lApplyValue, row[3]);
+		str_to_number(r.dwFlag, row[4]);
+		str_to_number(r.lDuration, row[5]);
+		str_to_number(r.lSPCost, row[6]);
+#if defined(__AFFECT_RENEWAL__)
+		str_to_number(r.bRealTime, row[7]);
+		r.bUpdate = false;
+#endif
+	}
+
+	sys_log(0, "AFFECT_LOAD: count %d PID %u", s_elements.size(), dwPID);
+
+	DWORD dwCount = s_elements.size();
+
+	peer->EncodeHeader(HEADER_DG_AFFECT_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPacketAffectElement) * dwCount);
+	peer->Encode(&dwPID, sizeof(DWORD));
+	peer->Encode(&dwCount, sizeof(DWORD));
+	peer->Encode(&s_elements[0], sizeof(TPacketAffectElement) * dwCount);
+}
+
+void CClientManager::RESULT_QUEST_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD pid)
+{
+	int iNumRows;
+
+	if ((iNumRows = static_cast<int>(mysql_num_rows(pRes))) == 0)
+	{
+		DWORD dwCount = 0;
+		peer->EncodeHeader(HEADER_DG_QUEST_LOAD, dwHandle, sizeof(DWORD));
+		peer->Encode(&dwCount, sizeof(DWORD));
+		return;
+	}
+
+	static std::vector<TQuestTable> s_table;
+	s_table.resize(iNumRows);
+
+	MYSQL_ROW row;
+
+	for (int i = 0; i < iNumRows; ++i)
+	{
+		TQuestTable& r = s_table[i];
+
+		row = mysql_fetch_row(pRes);
+
+		str_to_number(r.dwPID, row[0]);
+		strlcpy(r.szName, row[1], sizeof(r.szName));
+		strlcpy(r.szState, row[2], sizeof(r.szState));
+		str_to_number(r.lValue, row[3]);
+	}
+
+	sys_log(0, "QUEST_LOAD: count %d PID %u", s_table.size(), s_table[0].dwPID);
+
+	DWORD dwCount = s_table.size();
+
+	peer->EncodeHeader(HEADER_DG_QUEST_LOAD, dwHandle, sizeof(DWORD) + sizeof(TQuestTable) * dwCount);
+	peer->Encode(&dwCount, sizeof(DWORD));
+	peer->Encode(&s_table[0], sizeof(TQuestTable) * dwCount);
+}
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+void CClientManager::RESULT_EXT_BATTLE_PASS_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID)
+{
+	int iNumRows;
+
+	if ((iNumRows = mysql_num_rows(pRes)) == 0)
+	{
+		DWORD dwCount = 0;
+		TPlayerExtBattlePassMission pbpTable = { 0 };
+
+		sys_log(0, "EXT_BATTLE_PASS_LOAD: count %u PID %u", dwCount, dwRealPID);
+
+		peer->EncodeHeader(HEADER_DG_EXT_BATTLE_PASS_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPlayerExtBattlePassMission) * dwCount);
+		peer->Encode(&dwRealPID, sizeof(DWORD));
+		peer->Encode(&dwCount, sizeof(DWORD));
+		peer->Encode(&pbpTable, sizeof(TPlayerExtBattlePassMission) * dwCount);
+		return;
+	}
+
+	static std::vector<TPlayerExtBattlePassMission> s_mission;
+	s_mission.resize(iNumRows);
+
+	MYSQL_ROW row;
+
+	for (int i = 0; i < iNumRows; ++i)
+	{
+		int col = 0;
+		TPlayerExtBattlePassMission& r = s_mission[i];
+		row = mysql_fetch_row(pRes);
+
+		str_to_number(r.dwPlayerId, row[col++]);
+		str_to_number(r.dwBattlePassType, row[col++]);
+		str_to_number(r.dwMissionIndex, row[col++]);
+		str_to_number(r.dwMissionType, row[col++]);
+		str_to_number(r.dwBattlePassId, row[col++]);
+		str_to_number(r.dwExtraInfo, row[col++]);
+		str_to_number(r.bCompleted, row[col++]);
+
+		r.bIsUpdated = 0;
+	}
+
+	sys_log(0, "EXT_BATTLE_PASS_LOAD: count %d PID %u", s_mission.size(), dwRealPID);
+
+	DWORD dwCount = s_mission.size();
+
+	peer->EncodeHeader(HEADER_DG_EXT_BATTLE_PASS_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPlayerExtBattlePassMission) * dwCount);
+	peer->Encode(&dwRealPID, sizeof(DWORD));
+	peer->Encode(&dwCount, sizeof(DWORD));
+	peer->Encode(&s_mission[0], sizeof(TPlayerExtBattlePassMission) * dwCount);
+}
+
+void CClientManager::QUERY_SAVE_EXT_BATTLE_PASS(CPeer* peer, DWORD dwHandle, TPlayerExtBattlePassMission* battlePass)
+{
+	if (g_test_server)
+		sys_log(0, "QUERY_SAVE_EXT_BATTLE_PASS: %lu", battlePass->dwPlayerId);
+
+	char szQuery[QUERY_MAX_LEN];
+	snprintf(szQuery, sizeof(szQuery),
+		"REPLACE INTO battlepass_missions (player_id, battlepass_type, mission_index, mission_type, battle_pass_id, extra_info, completed) VALUES (%lu, %d, %d, %d, %d, %d, %d)",
+		battlePass->dwPlayerId,
+		battlePass->dwBattlePassType,
+		battlePass->dwMissionIndex,
+		battlePass->dwMissionType,
+		battlePass->dwBattlePassId,
+		battlePass->dwExtraInfo,
+		battlePass->bCompleted ? 1 : 0);
+	CDBManager::instance().AsyncQuery(szQuery);
+}
+#endif
+
+/*
+* PLAYER SAVE
+*/
+void CClientManager::QUERY_PLAYER_SAVE(CPeer* peer, DWORD dwHandle, TPlayerTable* pkTab)
+{
+	if (g_test_server)
+		sys_log(0, "PLAYER_SAVE: %s", pkTab->name);
+
+	PutPlayerCache(pkTab);
+}
+
+typedef std::map<DWORD, time_t> time_by_id_map_t;
+static time_by_id_map_t s_createTimeByAccountID;
+
+/*
+* PLAYER CREATE
+*/
+void CClientManager::__QUERY_PLAYER_CREATE(CPeer* peer, DWORD dwHandle, TPlayerCreatePacket* packet)
+{
+	char queryStr[QUERY_MAX_LEN];
+	int queryLen;
+	int player_id;
+
+	//   X  캐    .
+	time_by_id_map_t::iterator it = s_createTimeByAccountID.find(packet->account_id);
+
+	if (m_bDelayedCharacterCreation)
+	{
+		if (it != s_createTimeByAccountID.end())
+		{
+			time_t curtime = time(0);
+
+			if (curtime - it->second < 30)
+			{
+				peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+				return;
+			}
+		}
+	}
+
+	queryLen = snprintf(queryStr, sizeof(queryStr),
+		"SELECT `pid%d` FROM player_index%s WHERE `id` = %d", packet->account_index + 1, GetTablePostfix(), packet->account_id);
+
+	std::unique_ptr<SQLMsg> pMsg0(CDBManager::instance().DirectQuery(queryStr));
+
+	if (pMsg0->Get()->uiNumRows != 0)
+	{
+		if (!pMsg0->Get()->pSQLResult)
+		{
+			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+			return;
+		}
+
+		MYSQL_ROW row = mysql_fetch_row(pMsg0->Get()->pSQLResult);
+
+		DWORD dwPID = 0; str_to_number(dwPID, row[0]);
+		if (row[0] && dwPID > 0)
+		{
+			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
+			sys_log(0, "ALREADY EXIST AccountChrIdx %d ID %d", packet->account_index, dwPID);
+			return;
+		}
+	}
+	else
+	{
+		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+		return;
+	}
+
+	if (g_stLocale == "sjis")
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT COUNT(*) AS count FROM player%s WHERE `name` = '%s' COLLATE sjis_japanese_ci",
+			GetTablePostfix(), packet->player_table.name);
+	else
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT COUNT(*) AS count FROM player%s WHERE `name` = '%s'", GetTablePostfix(), packet->player_table.name);
+
+	std::unique_ptr<SQLMsg> pMsg1(CDBManager::instance().DirectQuery(queryStr));
+
+	if (pMsg1->Get()->uiNumRows)
+	{
+		if (!pMsg1->Get()->pSQLResult)
+		{
+			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+			return;
+		}
+
+		MYSQL_ROW row = mysql_fetch_row(pMsg1->Get()->pSQLResult);
+
+		if (*row[0] != '0')
+		{
+			sys_log(0, "ALREADY EXIST name %s, row[0] %s query %s", packet->player_table.name, row[0], queryStr);
+			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
+			return;
+		}
+	}
+	else
+	{
+		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+		return;
+	}
+
+	queryLen = snprintf(queryStr, sizeof(queryStr),
+		"INSERT INTO player%s "
+		"(`id`, `account_id`, `name`, `level`, `st`, `ht`, `dx`, `iq`, "
+		"`job`, `voice`, `dir`, `x`, `y`, `z`, "
+		"`hp`, `mp`, `random_hp`, `random_sp`, `stat_point`, `stamina`, "
+		"`part_base`, `part_main`, `part_hair`, "
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		"`part_acce`, "
+#endif
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		"`inven_stage`, "
+#endif
+		"`gold`, "
+#if defined(__CHEQUE_SYSTEM__)
+		"`cheque`, "
+#endif
+#if defined(__GEM_SYSTEM__)
+		"`gem`, "
+#endif
+		"`playtime`, `skill_level`, `quickslot`) "
+		"VALUES (0, "
+		"%u, "
+		"'%s', " // name
+		"%d, " // level
+		"%d, " // st
+		"%d, " // ht
+		"%d, " // dx
+		"%d, " // iq
+		"%d, " // job
+		"%d, " // voice
+		"%d, " // dir
+		"%d, " // x
+		"%d, " // y
+		"%d, " // z
+		"%d, " // hp
+		"%d, " // sp
+		"%d, " // sRandomHP
+		"%d, " // sRandomSP
+		"%d, " // stat_point
+		"%d, " // stamina
+		"%d, " // part_base
+		"%d, " // part_base
+		"%d, " // part_base(hair)
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		"%d, " // part_base(acce)
+#endif
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		"%d, " // inven_stage
+#endif
+		"%d, " // gold
+#if defined(__CHEQUE_SYSTEM__)
+		"%d, " // cheque
+#endif
+#if defined(__GEM_SYSTEM__)
+		"%d, " // gem
+#endif
+		"0, "
+		, GetTablePostfix()
+		, packet->account_id
+		, packet->player_table.name
+		, packet->player_table.level
+		, packet->player_table.st
+		, packet->player_table.ht
+		, packet->player_table.dx
+		, packet->player_table.iq
+		, packet->player_table.job
+		, packet->player_table.voice
+		, packet->player_table.dir
+		, packet->player_table.x
+		, packet->player_table.y
+		, packet->player_table.z
+		, packet->player_table.hp
+		, packet->player_table.sp
+		, packet->player_table.sRandomHP
+		, packet->player_table.sRandomSP
+		, packet->player_table.stat_point
+		, packet->player_table.stamina
+		, packet->player_table.part_base
+		, packet->player_table.part_base
+		, packet->player_table.adwParts[PART_HAIR]
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		, packet->player_table.adwParts[PART_ACCE]
+#endif
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		, packet->player_table.inven_stage
+#endif
+		, packet->player_table.gold
+#if defined(__CHEQUE_SYSTEM__)
+		, packet->player_table.cheque
+#endif
+#if defined(__GEM_SYSTEM__)
+		, packet->player_table.gem
+#endif
+	);
+
+	sys_log(0, "PlayerCreate accountid %d name %s level %d gold %d"
+#if defined(__CHEQUE_SYSTEM__)
+		" cheque %d"
+#endif
+#if defined(__GEM_SYSTEM__)
+		" gem %d"
+#endif
+		", st %d ht %d job %d"
+		, packet->account_id
+		, packet->player_table.name
+		, packet->player_table.level
+		, packet->player_table.gold
+#if defined(__CHEQUE_SYSTEM__)
+		, packet->player_table.cheque
+#endif
+#if defined(__GEM_SYSTEM__)
+		, packet->player_table.gem
+#endif
+		, packet->player_table.st
+		, packet->player_table.ht
+		, packet->player_table.job
+	);
+
+	static char text[QUERY_MAX_LEN];
+
+	CDBManager::instance().EscapeString(text, packet->player_table.skills, sizeof(packet->player_table.skills));
+	queryLen += snprintf(queryStr + queryLen, sizeof(queryStr) - queryLen, "'%s', ", text);
+	if (g_test_server)
+		sys_log(0, "Create_Player queryLen[%d] TEXT[%s]", queryLen, text);
+
+	CDBManager::instance().EscapeString(text, packet->player_table.quickslot, sizeof(packet->player_table.quickslot));
+	queryLen += snprintf(queryStr + queryLen, sizeof(queryStr) - queryLen, "'%s')", text);
+
+	std::unique_ptr<SQLMsg> pMsg2(CDBManager::instance().DirectQuery(queryStr));
+	if (g_test_server)
+		sys_log(0, "Create_Player queryLen[%d] TEXT[%s]", queryLen, text);
+
+	if (pMsg2->Get()->uiAffectedRows <= 0)
+	{
+		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
+		sys_log(0, "ALREADY EXIST3 query: %s AffectedRows %lu", queryStr, pMsg2->Get()->uiAffectedRows);
+		return;
+	}
+
+	player_id = pMsg2->Get()->uiInsertID;
+
+	snprintf(queryStr, sizeof(queryStr), "UPDATE player_index%s SET `pid%d` = %d WHERE `id` = %d",
+		GetTablePostfix(), packet->account_index + 1, player_id, packet->account_id);
+	std::unique_ptr<SQLMsg> pMsg3(CDBManager::instance().DirectQuery(queryStr));
+
+	if (pMsg3->Get()->uiAffectedRows <= 0)
+	{
+		sys_err("QUERY_ERROR: %s", queryStr);
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM player%s WHERE `id` = %d", GetTablePostfix(), player_id);
+		CDBManager::instance().DirectQuery(queryStr);
+
+		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+		return;
+	}
+
+	TPacketDGCreateSuccess pack;
+	memset(&pack, 0, sizeof(pack));
+
+	pack.bAccountCharacterIndex = packet->account_index;
+
+	pack.player.dwID = player_id;
+	strlcpy(pack.player.szName, packet->player_table.name, sizeof(pack.player.szName));
+	pack.player.byJob = packet->player_table.job;
+	pack.player.byLevel = 1;
+	pack.player.dwPlayMinutes = 0;
+	pack.player.byST = packet->player_table.st;
+	pack.player.byHT = packet->player_table.ht;
+	pack.player.byDX = packet->player_table.dx;
+	pack.player.byIQ = packet->player_table.iq;
+#if defined(__CONQUEROR_LEVEL__)
+	pack.player.byConquerorLevel = packet->player_table.conqueror_level;
+	pack.player.bySungmaStr = packet->player_table.sungma_str;
+	pack.player.bySungmaHp = packet->player_table.sungma_hp;
+	pack.player.bySungmaMove = packet->player_table.sungma_move;
+	pack.player.bySungmaImmune = packet->player_table.sungma_immune;
+#endif
+	pack.player.dwMainPart = packet->player_table.part_base;
+	pack.player.x = packet->player_table.x;
+	pack.player.y = packet->player_table.y;
+	pack.player.last_play = packet->player_table.last_play;
+
+	peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_SUCCESS, dwHandle, sizeof(TPacketDGCreateSuccess));
+	peer->Encode(&pack, sizeof(TPacketDGCreateSuccess));
+
+	sys_log(0, "7 name %s job %d", pack.player.szName, pack.player.byJob);
+
+	s_createTimeByAccountID[packet->account_id] = time(0);
+}
+
+/*
+* PLAYER DELETE
+*/
+#if defined(__DELETE_FAILURE_TYPE__)
+static char QUERY_CHECK_PLAYER_DELETE(DWORD dwPID, DWORD dwAID, INT* piWaitTime)
+{
+	*piWaitTime = 0;
+
+	SQLMsg* pMsg = NULL;
+	char szQuery[QUERY_MAX_LEN] = {};
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	// Check if the player has any sealed items.
+	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `soulbind` != 0", GetTablePostfix(), dwPID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get()->uiNumRows)
+		return DELETE_FAILURE_HAVE_SEALED_ITEM;
+#endif
+
+	// Check if the player is a member of a guild.
+	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM guild_member%s WHERE `pid` = %d", GetTablePostfix(), dwPID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get()->uiNumRows)
+		return DELETE_FAILURE_GUILD_MEMBER;
+
+	// Check if the player is married.
+	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM marriage%s WHERE `pid1` = %d OR `pid2` = %d", GetTablePostfix(), dwPID, dwPID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get()->uiNumRows)
+		return DELETE_FAILURE_MARRIAGE;
+
+	// Check if the player is the last character on the account and if there are any items in the safebox.
+	snprintf(szQuery, sizeof(szQuery), "SELECT COUNT(*) FROM `player%s` WHERE `account_id` = %u;", GetTablePostfix(), dwAID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get() && pMsg->Get()->uiNumRows)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+
+		BYTE bPlayerCount = 0;
+		str_to_number(bPlayerCount, row[0]);
+
+		if (bPlayerCount == 1)
+		{
+			snprintf(szQuery, sizeof(szQuery), "SELECT * FROM `item%s` WHERE `owner_id` = %u AND `window` = 'SAFEBOX' > 0;", GetTablePostfix(), dwAID);
+			pMsg = CDBManager::Instance().DirectQuery(szQuery);
+			if (pMsg->Get()->uiNumRows)
+				return DELETE_FAILURE_LAST_CHAR_SAFEBOX;
+		}
+	}
+
+#if defined(__ATTR_6TH_7TH__)
+	// Check if the player has any items in the NPC storage.
+	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `window` = 'NPC_STORAGE'", GetTablePostfix(), dwPID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get()->uiNumRows)
+		return DELETE_FAILURE_ATTR67;
+#endif
+
+	// Check if the player has any items in the premium private shop.
+	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `window` = 'PREMIUM_PRIVATE_SHOP'", GetTablePostfix(), dwPID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get()->uiNumRows)
+		return DELETE_FAILURE_PREMIUM_PRIVATE_SHOP;
+
+	// Check if the player has at least 10 minutes of playtime.
+	/*
+	CPlayerTableCache* pPlayerTableCache = CClientManager::Instance().GetPlayerCache(dwPID);
+	INT iPlayTime = pPlayerTableCache ? pPlayerTableCache->Get(false)->playtime : 0;
+	if (iPlayTime < 10)
+	{
+		*piWaitTime = 10 - iPlayTime;
+		return DELETE_FAILURE_REMAIN_TIME;
+	}
+	*/
+
+	return -1;
+}
+#endif
+
+void CClientManager::__QUERY_PLAYER_DELETE(CPeer* peer, DWORD dwHandle, TPlayerDeletePacket* packet)
+{
+	if (!packet->login[0] || !packet->player_id || packet->account_index >= PLAYER_PER_ACCOUNT)
+		return;
+
+	CLoginData* ld = GetLoginDataByLogin(packet->login);
+
+	if (!ld)
+	{
+#if defined(__DELETE_FAILURE_TYPE__)
+		TPlayerDeleteFailurePacket DelFailurePacket = {};
+		DelFailurePacket.bType = DELETE_FAILURE_NORMAL;
+		DelFailurePacket.iTime = 0;
+		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
+		peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
+#else
+		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
+		peer->EncodeBYTE(packet->account_index);
+#endif
+		return;
+	}
+
+	TAccountTable& r = ld->GetAccountRef();
+
+	// block for japan
+	if (g_stLocale != "sjis")
+	{
+		if (!IsChinaEventServer())
+		{
+			if (strlen(r.social_id) < 7 || strncmp(packet->private_code, r.social_id + strlen(r.social_id) - 7, 7))
+			{
+				sys_log(0, "PLAYER_DELETE FAILED len(%d)", strlen(r.social_id));
+#if defined(__DELETE_FAILURE_TYPE__)
+				TPlayerDeleteFailurePacket DelFailurePacket;
+				DelFailurePacket.bType = DELETE_FAILURE_PRIVATE_CODE_ERROR;
+				DelFailurePacket.iTime = 0;
+				peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
+				peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
+#else
+				peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
+				peer->EncodeBYTE(packet->account_index);
+#endif
+				return;
+			}
+
+			CPlayerTableCache* pkPlayerCache = GetPlayerCache(packet->player_id);
+			if (pkPlayerCache)
+			{
+				TPlayerTable* pTab = pkPlayerCache->Get();
+
+				if (pTab->level >= m_iPlayerDeleteLevelLimit)
+				{
+					sys_log(0, "PLAYER_DELETE FAILED LEVEL %u >= DELETE LIMIT %d", pTab->level, m_iPlayerDeleteLevelLimit);
+#if defined(__DELETE_FAILURE_TYPE__)
+					TPlayerDeleteFailurePacket DelFailurePacket;
+					DelFailurePacket.bType = DELETE_FAILURE_LIMITE_LEVEL_HIGHER;
+					DelFailurePacket.iTime = 0;
+					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
+					peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
+#else
+					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
+					peer->EncodeBYTE(packet->account_index);
+#endif
+					return;
+				}
+
+				if (pTab->level < m_iPlayerDeleteLevelLimitLower)
+				{
+					sys_log(0, "PLAYER_DELETE FAILED LEVEL %u < DELETE LIMIT %d", pTab->level, m_iPlayerDeleteLevelLimitLower);
+#if defined(__DELETE_FAILURE_TYPE__)
+					TPlayerDeleteFailurePacket DelFailurePacket;
+					DelFailurePacket.bType = DELETE_FAILURE_LIMITE_LEVEL_LOWER;
+					DelFailurePacket.iTime = 0;
+					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
+					peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
+#else
+					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
+					peer->EncodeBYTE(packet->account_index);
+#endif
+					return;
+				}
+			}
+		}
+	}
+
+#if defined(__DELETE_FAILURE_TYPE__)
+	INT iWaitTime;
+	const char bFailureType = QUERY_CHECK_PLAYER_DELETE(packet->player_id, r.id, &iWaitTime);
+	if (bFailureType != -1)
+	{
+		TPlayerDeleteFailurePacket DelFailurePacket;
+		DelFailurePacket.bType = bFailureType;
+		DelFailurePacket.iTime = iWaitTime;
+		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
+		peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
+		return;
+}
+#endif
+
+	char szQuery[128];
+	snprintf(szQuery, sizeof(szQuery), "SELECT p.`id`, p.`level`, p.`name` FROM player_index%s AS i, player%s AS p WHERE `pid%d` = %u AND `pid%d` = p.`id`",
+		GetTablePostfix(), GetTablePostfix(), packet->account_index + 1, packet->player_id, packet->account_index + 1);
+
+	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle, packet->player_id);
+	pi->account_index = packet->account_index;
+
+	sys_log(0, "PLAYER_DELETE TRY: %s %d pid%d", packet->login, packet->player_id, packet->account_index + 1);
+	CDBManager::instance().ReturnQuery(szQuery, QID_PLAYER_DELETE, peer->GetHandle(), pi);
+}
+
+//
+// @version	05/06/10 Bang2ni - 첨潔   트  煞.
+//
+void CClientManager::__RESULT_PLAYER_DELETE(CPeer* peer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
+
+	if (msg->Get() && msg->Get()->uiNumRows)
+	{
+		MYSQL_ROW row = mysql_fetch_row(msg->Get()->pSQLResult);
+
+		DWORD dwPID = 0;
+		str_to_number(dwPID, row[0]);
+
+		int deletedLevelLimit = 0;
+		str_to_number(deletedLevelLimit, row[1]);
+
+		char szName[64];
+		strlcpy(szName, row[2], sizeof(szName));
+
+		if (deletedLevelLimit >= m_iPlayerDeleteLevelLimit && !IsChinaEventServer())
+		{
+			sys_log(0, "PLAYER_DELETE FAILED LEVEL %u >= DELETE LIMIT %d", deletedLevelLimit, m_iPlayerDeleteLevelLimit);
+			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
+			peer->EncodeBYTE(pi->account_index);
+			return;
+		}
+
+		if (deletedLevelLimit < m_iPlayerDeleteLevelLimitLower)
+		{
+			sys_log(0, "PLAYER_DELETE FAILED LEVEL %u < DELETE LIMIT %d", deletedLevelLimit, m_iPlayerDeleteLevelLimitLower);
+			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
+			peer->EncodeBYTE(pi->account_index);
+			return;
+		}
+
+		char queryStr[QUERY_MAX_LEN];
+
+		snprintf(queryStr, sizeof(queryStr), "INSERT INTO player_deleted%s SELECT * FROM player%s WHERE `id` = %d",
+			GetTablePostfix(), GetTablePostfix(), pi->player_id);
+		std::unique_ptr<SQLMsg> pIns(CDBManager::instance().DirectQuery(queryStr));
+
+		if (pIns->Get()->uiAffectedRows == 0 || pIns->Get()->uiAffectedRows == (uint32_t)-1)
+		{
+			sys_log(0, "PLAYER_DELETE FAILED %u CANNOT INSERT TO player_deleted%s", dwPID, GetTablePostfix());
+
+			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
+			peer->EncodeBYTE(pi->account_index);
+			return;
+		}
+
+		//  
+		sys_log(0, "PLAYER_DELETE SUCCESS %u", dwPID);
+
+		// char account_index_string[16];
+
+		// snprintf(account_index_string, sizeof(account_index_string), "player_id%d", m_iPlayerIDStart + pi->account_index);
+
+		// 첨潔 遣 캐 磯.
+		CPlayerTableCache* pkPlayerCache = GetPlayerCache(pi->player_id);
+
+		if (pkPlayerCache)
+		{
+			m_map_playerCache.erase(pi->player_id);
+			delete pkPlayerCache;
+		}
+
+		// 滂 캐 磯.
+		TItemCacheSet* pSet = GetItemCacheSet(pi->player_id);
+
+		if (pSet)
+		{
+			TItemCacheSet::iterator it = pSet->begin();
+
+			while (it != pSet->end())
+			{
+				CItemCache* pkItemCache = *it++;
+				DeleteItemCache(pkItemCache->Get()->dwID);
+			}
+
+			pSet->clear();
+			delete pSet;
+
+			m_map_pkItemCacheSetPtr.erase(pi->player_id);
+		}
+
+		snprintf(queryStr, sizeof(queryStr), "UPDATE player_index%s SET `pid%d` = 0 WHERE `pid%d` = %d",
+			GetTablePostfix(),
+			pi->account_index + 1,
+			pi->account_index + 1,
+			pi->player_id);
+
+		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(queryStr));
+
+		if (pMsg->Get()->uiAffectedRows == 0 || pMsg->Get()->uiAffectedRows == (uint32_t)-1)
+		{
+			sys_log(0, "PLAYER_DELETE FAIL WHEN UPDATE account table");
+			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
+			peer->EncodeBYTE(pi->account_index);
+			return;
+		}
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `player%s` WHERE `id` = %u", GetTablePostfix(), pi->player_id);
+		delete CDBManager::instance().DirectQuery(queryStr);
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
+			"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
+#if defined(__ATTR_6TH_7TH__)
+			", 'NPC_STORAGE'"
+#endif
+			"))", GetTablePostfix(), pi->player_id);
+		delete CDBManager::instance().DirectQuery(queryStr);
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `quest%s` WHERE `dwPID` = %d", GetTablePostfix(), pi->player_id);
+		CDBManager::instance().AsyncQuery(queryStr);
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `affect%s` WHERE `dwPID` = %d", GetTablePostfix(), pi->player_id);
+		CDBManager::instance().AsyncQuery(queryStr);
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `guild_member%s` WHERE `pid` = %u", GetTablePostfix(), pi->player_id);
+		CDBManager::instance().AsyncQuery(queryStr);
+
+		// MYSHOP_PRICE_LIST
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `myshop_pricelist%s` WHERE `owner_id` = %u", GetTablePostfix(), pi->player_id);
+		CDBManager::instance().AsyncQuery(queryStr);
+		// END_OF_MYSHOP_PRICE_LIST
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `messenger_list%s` WHERE `account` = '%s' OR `companion` = '%s'", GetTablePostfix(), szName, szName);
+		CDBManager::instance().AsyncQuery(queryStr);
+
+		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_SUCCESS, pi->dwHandle, 1);
+		peer->EncodeBYTE(pi->account_index);
+	}
+	else
+	{
+		//  
+		sys_log(0, "PLAYER_DELETE FAIL NO ROW");
+		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
+		peer->EncodeBYTE(pi->account_index);
+	}
+}
+
+void CClientManager::QUERY_ADD_AFFECT(CPeer* peer, TPacketGDAddAffect* p)
+{
+	char query[QUERY_MAX_LEN];
+#if defined(__AFFECT_RENEWAL__)
+	if (p->elem.bUpdate)
+	{
+		snprintf(query, sizeof(query),
+			"UPDATE `affect%s` SET `lApplyValue` = %ld, `dwFlag` = %u, `lDuration` = %ld, `lSPCost` = %ld, `bRealTime` = %d "
+			"WHERE `dwPID` = %u AND `dwType` = %u AND `wApplyOn` = %u",
+			GetTablePostfix(),
+			p->elem.lApplyValue,
+			p->elem.dwFlag,
+			p->elem.lDuration,
+			p->elem.lSPCost,
+			p->elem.bRealTime ? 1 : 0,
+			p->dwPID,
+			p->elem.dwType,
+			p->elem.wApplyOn);
+	}
+	else
+	{
+		snprintf(query, sizeof(query),
+			"REPLACE INTO `affect%s` (`dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`, `bRealTime`) "
+			"VALUES(%u, %u, %u, %ld, %u, %ld, %ld, %d)",
+			GetTablePostfix(),
+			p->dwPID,
+			p->elem.dwType,
+			p->elem.wApplyOn,
+			p->elem.lApplyValue,
+			p->elem.dwFlag,
+			p->elem.lDuration,
+			p->elem.lSPCost,
+			p->elem.bRealTime ? 1 : 0);
+	}
+#else
+	snprintf(query, sizeof(query),
+		"REPLACE INTO `affect%s` (`dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`) "
+		"VALUES(%u, %u, %u, %ld, %u, %ld, %ld)",
+		GetTablePostfix(),
+		p->dwPID,
+		p->elem.dwType,
+		p->elem.wApplyOn,
+		p->elem.lApplyValue,
+		p->elem.dwFlag,
+		p->elem.lDuration,
+		p->elem.lSPCost
+	);
+#endif
+	CDBManager::instance().AsyncQuery(query);
+}
+
+void CClientManager::QUERY_REMOVE_AFFECT(CPeer* peer, TPacketGDRemoveAffect* p)
+{
+	char query[QUERY_MAX_LEN];
+	snprintf(query, sizeof(query),
+		"DELETE FROM `affect%s` WHERE `dwPID` = %u AND `dwType` = %u AND `wApplyOn` = %u",
+		GetTablePostfix(), p->dwPID, p->dwType, p->wApplyOn);
+	CDBManager::instance().AsyncQuery(query);
+}
+
+void CClientManager::QUERY_HIGHSCORE_REGISTER(CPeer* peer, TPacketGDHighscore* data)
+{
+	char escBoard[sizeof(data->szBoard) * 2 + 1];
+	const size_t boardLen = strnlen(data->szBoard, sizeof(data->szBoard));
+	CDBManager::instance().EscapeString(escBoard, data->szBoard, boardLen);
+
+	char szQuery[256];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `value` FROM highscore%s WHERE `board` = '%s' AND `pid` = %u", GetTablePostfix(), escBoard, data->dwPID);
+
+	sys_log(0, "HEADER_GD_HIGHSCORE_REGISTER: PID %u", data->dwPID);
+
+	ClientHandleInfo* pi = new ClientHandleInfo(0);
+	strlcpy(pi->login, data->szBoard, sizeof(pi->login));
+	pi->account_id = (DWORD)data->lValue;
+	pi->player_id = data->dwPID;
+	pi->account_index = (data->cDir > 0);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_HIGHSCORE_REGISTER, peer->GetHandle(), pi);
+}
+
+void CClientManager::RESULT_HIGHSCORE_REGISTER(CPeer* pkPeer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
+	//DWORD dwHandle = pi->dwHandle;
+
+	char szBoard[21];
+	strlcpy(szBoard, pi->login, sizeof(szBoard));
+	int value = (int)pi->account_id;
+
+	SQLResult* res = msg->Get();
+
+	if (res->uiNumRows == 0)
+	{
+		// 恝 決岷低 
+		char buf[256];
+		snprintf(buf, sizeof(buf), "INSERT INTO highscore%s VALUES('%s', %u, %d)", GetTablePostfix(), szBoard, pi->player_id, value);
+		CDBManager::instance().AsyncQuery(buf);
+	}
+	else
+	{
+		if (!res->pSQLResult)
+		{
+			delete pi;
+			return;
+		}
+
+		MYSQL_ROW row = mysql_fetch_row(res->pSQLResult);
+		if (row && row[0])
+		{
+			int current_value = 0; str_to_number(current_value, row[0]);
+			if ((pi->account_index && current_value >= value) || (!pi->account_index && current_value <= value))
+			{
+				value = current_value;
+			}
+			else
+			{
+				char buf[256];
+				snprintf(buf, sizeof(buf), "REPLACE INTO highscore%s VALUES('%s', %u, %d)", GetTablePostfix(), szBoard, pi->player_id, value);
+				CDBManager::instance().AsyncQuery(buf);
+			}
+		}
+		else
+		{
+			char buf[256];
+			snprintf(buf, sizeof(buf), "INSERT INTO highscore%s VALUES('%s', %u, %d)", GetTablePostfix(), szBoard, pi->player_id, value);
+			CDBManager::instance().AsyncQuery(buf);
+		}
+	}
+	// TODO: 隔 決岷載 트 퓸 체크臼  祈磯.
+	delete pi;
+}
+
+void CClientManager::InsertLogoutPlayer(DWORD pid)
+{
+	TLogoutPlayerMap::iterator it = m_map_logout.find(pid);
+
+	//   煞
+	if (it != m_map_logout.end())
+	{
+		// 柰 챨 
+		if (g_log)
+			sys_log(0, "LOGOUT: Update player time pid(%d)", pid);
+
+		it->second->time = time(0);
+		return;
+	}
+
+	TLogoutPlayer* pLogout = new TLogoutPlayer;
+	pLogout->pid = pid;
+	pLogout->time = time(0);
+	m_map_logout.insert(std::make_pair(pid, pLogout));
+
+	if (g_log)
+		sys_log(0, "LOGOUT: Insert player pid(%d)", pid);
+}
+
+void CClientManager::DeleteLogoutPlayer(DWORD pid)
+{
+	TLogoutPlayerMap::iterator it = m_map_logout.find(pid);
+
+	if (it != m_map_logout.end())
+	{
+		delete it->second;
+		m_map_logout.erase(it);
+	}
+}
+
+extern int g_iLogoutSeconds;
+
+void CClientManager::UpdateLogoutPlayer()
+{
+	time_t now = time(0);
+
+	TLogoutPlayerMap::iterator it = m_map_logout.begin();
+
+	while (it != m_map_logout.end())
+	{
+		TLogoutPlayer* pLogout = it->second;
+
+		if (now - g_iLogoutSeconds > pLogout->time)
+		{
+			FlushItemCacheSet(pLogout->pid);
+			FlushPlayerCacheSet(pLogout->pid);
+#ifdef __GROWTH_PET_SYSTEM__
+			FlushGrowthPetCacheSet(pLogout->pid);
+#endif
+			delete pLogout;
+			m_map_logout.erase(it++);
+		}
+		else
+			++it;
+	}
+}
+
+void CClientManager::FlushPlayerCacheSet(DWORD pid)
+{
+	TPlayerTableCacheMap::iterator it = m_map_playerCache.find(pid);
+
+	if (it != m_map_playerCache.end())
+	{
+		CPlayerTableCache* c = it->second;
+		m_map_playerCache.erase(it);
+
+		c->Flush();
+		delete c;
+	}
+}
diff --git a/server/server/home/metin2/Source/Server/db/src/QID.h b/server/server/home/metin2/Source/Server/db/src/QID.h
index 87139fe..04cd9b9 100644
--- a/server/server/home/metin2/Source/Server/db/src/QID.h
+++ b/server/server/home/metin2/Source/Server/db/src/QID.h
@@ -1,47 +1,47 @@
-#ifndef __INC_METIN_II_DB_QID_H__
-#define __INC_METIN_II_DB_QID_H__
-
-/**
-* @version 05/06/10 Bang2ni - 아이템 가격정보 쿼리 추가(QID_ITEMPRICE_XXX)
-*/
-enum QID
-{
-	QID_PLAYER, // 0
-	QID_ITEM, // 1
-	QID_QUEST, // 2
-	QID_AFFECT, // 3
-	QID_LOGIN, // 4
-	QID_SAFEBOX_LOAD, // 5
-	QID_SAFEBOX_CHANGE_SIZE, // 6
-	QID_SAFEBOX_CHANGE_PASSWORD, // 7
-	QID_SAFEBOX_CHANGE_PASSWORD_SECOND, // 8
-	QID_SAFEBOX_SAVE, // 9
-	QID_ITEM_SAVE, // 10
-	QID_ITEM_DESTROY, // 11
-	QID_QUEST_SAVE, // 12
-	QID_PLAYER_SAVE, // 13
-	QID_HIGHSCORE_REGISTER, // 14
-	QID_PLAYER_DELETE, // 15
-	QID_LOGIN_BY_KEY, // 16
-	QID_PLAYER_INDEX_CREATE, // 17
-	QID_ITEM_AWARD_LOAD, // 18
-	QID_ITEM_AWARD_TAKEN, // 19
-	QID_GUILD_RANKING, // 20
-
-	// MYSHOP_PRICE_LIST
-	QID_ITEMPRICE_SAVE, ///< 21, 아이템 가격정보 저장 쿼리
-	QID_ITEMPRICE_DESTROY, ///< 22, 아이템 가격정보 삭제 쿼리
-	QID_ITEMPRICE_LOAD_FOR_UPDATE, ///< 23, 가격정보 업데이트를 위한 아이템 가격정보 로드 쿼리
-	QID_ITEMPRICE_LOAD, ///< 24, 아이템 가격정보 로드 쿼리
-	// END_OF_MYSHOP_PRICE_LIST
-#ifdef __GROWTH_PET_SYSTEM__
-	QID_GROWTH_PET,
-	QID_GROWTH_PET_SAVE,
-	QID_GROWTH_PET_DELETE,
-#endif
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	QID_EXT_BATTLE_PASS,
-#endif
-};
-
-#endif
+#ifndef __INC_METIN_II_DB_QID_H__
+#define __INC_METIN_II_DB_QID_H__
+
+/**
+* @version 05/06/10 Bang2ni -    煞(QID_ITEMPRICE_XXX)
+*/
+enum QID
+{
+	QID_PLAYER, // 0
+	QID_ITEM, // 1
+	QID_QUEST, // 2
+	QID_AFFECT, // 3
+	QID_LOGIN, // 4
+	QID_SAFEBOX_LOAD, // 5
+	QID_SAFEBOX_CHANGE_SIZE, // 6
+	QID_SAFEBOX_CHANGE_PASSWORD, // 7
+	QID_SAFEBOX_CHANGE_PASSWORD_SECOND, // 8
+	QID_SAFEBOX_SAVE, // 9
+	QID_ITEM_SAVE, // 10
+	QID_ITEM_DESTROY, // 11
+	QID_QUEST_SAVE, // 12
+	QID_PLAYER_SAVE, // 13
+	QID_HIGHSCORE_REGISTER, // 14
+	QID_PLAYER_DELETE, // 15
+	QID_LOGIN_BY_KEY, // 16
+	QID_PLAYER_INDEX_CREATE, // 17
+	QID_ITEM_AWARD_LOAD, // 18
+	QID_ITEM_AWARD_TAKEN, // 19
+	QID_GUILD_RANKING, // 20
+
+	// MYSHOP_PRICE_LIST
+	QID_ITEMPRICE_SAVE, ///< 21,    
+	QID_ITEMPRICE_DESTROY, ///< 22,    
+	QID_ITEMPRICE_LOAD_FOR_UPDATE, ///< 23,  트    琯 
+	QID_ITEMPRICE_LOAD, ///< 24,   琯 
+	// END_OF_MYSHOP_PRICE_LIST
+#ifdef __GROWTH_PET_SYSTEM__
+    QID_GROWTH_PET,
+    QID_GROWTH_PET_SAVE,
+    QID_GROWTH_PET_DELETE,
+#endif
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	QID_EXT_BATTLE_PASS,
+#endif
+};
+
+#endif
diff --git a/server/server/home/metin2/Source/Server/game/src/affect.h b/server/server/home/metin2/Source/Server/game/src/affect.h
index 280906d..26ec471 100644
--- a/server/server/home/metin2/Source/Server/game/src/affect.h
+++ b/server/server/home/metin2/Source/Server/game/src/affect.h
@@ -1,464 +1,464 @@
-#ifndef __INC_AFFECT_H__
-#define __INC_AFFECT_H__
-
-class CAffect
-{
-public:
-	DWORD dwType;
-	POINT_TYPE wApplyOn;
-	POINT_VALUE lApplyValue;
-	DWORD dwFlag;
-	long lDuration;
-	long lSPCost;
-#if defined(__AFFECT_RENEWAL__)
-	bool bRealTime;
-	bool bUpdate;
-#endif
-#if defined(__9TH_SKILL__)
-	long lValue;
-#endif
-
-	static CAffect* Acquire();
-	static void Release(CAffect* p);
-};
-
-enum EAffectTypes
-{
-	AFFECT_NONE,
-
-	//AFFECT_GUILD_SKILL_BLOOD = 152,
-	//AFFECT_GUILD_SKILL_BLESS = 153,
-	//AFFECT_GUILD_SKILL_SEONGHWI = 154,
-	//AFFECT_GUILD_SKILL_ACCEL = 155,
-	//AFFECT_GUILD_SKILL_BUNNO = 156,
-	//AFFECT_GUILD_SKILL_JUMUN = 157,
-
-	//AFFECT_SKILL_9_FINISH = 176,
-	//AFFECT_SKILL_9_ILGWANGPYO = 177,
-	//AFFECT_SKILL_9_PUNGLOEPO = 178,
-	//AFFECT_SKILL_9_GEOMAGGWI = 179,
-	//AFFECT_SKILL_9_MABEOBAGGWI = 180,
-	//AFFECT_SKILL_9_METEO = 181,
-#if defined(__9TH_SKILL__)
-	AFFECT_SKILL_9_CHEONUN = 182,
-#endif
-	//AFFECT_SKILL_9_ILIPUNGU = 183,
-
-	AFFECT_MOV_SPEED = 200,
-	AFFECT_ATT_SPEED,
-	AFFECT_ATT_GRADE,
-	AFFECT_INVISIBILITY,
-	AFFECT_STR,
-	AFFECT_DEX,
-	AFFECT_CON,
-	AFFECT_INT,
-	AFFECT_FISH_MIND_PILL,
-
-	AFFECT_POISON,
-	AFFECT_STUN,
-	AFFECT_SLOW,
-	AFFECT_DUNGEON_READY,
-	AFFECT_DUNGEON_UNIQUE,
-
-	AFFECT_BUILDING,
-	AFFECT_REVIVE_INVISIBLE,
-	AFFECT_FIRE,
-	AFFECT_CAST_SPEED,
-	AFFECT_HP_RECOVER_CONTINUE,
-	AFFECT_SP_RECOVER_CONTINUE,
-
-	AFFECT_POLYMORPH,
-	AFFECT_MOUNT,
-
-	AFFECT_WAR_FLAG,
-
-	AFFECT_BLOCK_CHAT,
-	AFFECT_CHINA_FIREWORK,
-
-	AFFECT_BOW_DISTANCE,
-	AFFECT_DEF_GRADE,
-
-	AFFECT_BLEEDING,
-
-	//AFFECT_SKILL_MONSTER_WIDE_AREA_DAMAGE_SUNGMA_STR = 274,
-	//AFFECT_SKILL_MONSTER_ATT_GRADE_DOWN = 279,
-	//AFFECT_SKILL_POSION_DAMAGE_SUNGMA_MOVE = 280,
-	//AFFECT_SKILL_CRUSH_DAMAGE_SUNGMA_STR = 281,
-
-	AFFECT_RAMADAN_ABILITY = 300,
-	AFFECT_RAMADAN_RING = 301, // 라마단 이벤트용 특수아이템 초승달의 반지 착용 유무
-
-	AFFECT_NOG_ABILITY = 302,
-	AFFECT_HOLLY_STONE_POWER = 303,
-
-	AFFECT_PREMIUM_START = 500,
-	AFFECT_EXP_BONUS = 500, // 경험의 반지
-	AFFECT_ITEM_BONUS = 501, // 도둑의 장갑
-	AFFECT_SAFEBOX = 502, // PREMIUM_SAFEBOX,
-	AFFECT_AUTOLOOT = 503, // PREMIUM_AUTOLOOT,
-	AFFECT_FISH_MIND = 504, // PREMIUM_FISH_MIND,
-	AFFECT_MARRIAGE_FAST = 505, // 원앙의 깃털
-	AFFECT_GOLD_BONUS = 506, // 돈 드롭확률 50%증가
-	AFFECT_AUTO_USE = 507, // 자동 사냥
-#if defined(__CONQUEROR_LEVEL__)
-	AFFECT_SUNGMA_BONUS = 508,
-#endif
-	AFFECT_PREMIUM_END = 509,
-
-	AFFECT_MALL = 510, // 몰 아이템 에펙트
-	AFFECT_NO_DEATH_PENALTY = 511, // 용신의 가호 (경험치가 패널티를 한번 막아준다)
-	AFFECT_SKILL_BOOK_BONUS = 512, // 선인의 교훈 (책 수련 성공 확률이 50% 증가)
-	AFFECT_SKILL_NO_BOOK_DELAY = 513, // 주안술서
-
-	AFFECT_HAIR = 514, // 헤어 효과
-	AFFECT_COLLECT = 515, // 수집퀘스트 
-
-	AFFECT_EXP_BONUS_EURO_FREE = 516, // 경험의 반지 (유럽 버전 14 레벨 이하 기본 효과)
-	AFFECT_EXP_BONUS_EURO_FREE_UNDER_15 = 517,
-	AFFECT_UNIQUE_ABILITY = 518,
-
-	AFFECT_BLEND,
-
-	AFFECT_HORSE_NAME,
-	AFFECT_MOUNT_BONUS,
-
-	AFFECT_AUTO_HP_RECOVERY = 534,
-	AFFECT_AUTO_SP_RECOVERY = 535,
-
-#if defined(__LOOT_FILTER_SYSTEM__) && defined(__PREMIUM_LOOT_FILTER__)
-	AFFECT_LOOTING_SYSTEM = 537,
-#endif
-
-	//AFFECT_UNKNOWN_538,
-	//AFFECT_UNKNOWN_539,
-
-	AFFECT_DRAGON_SOUL_QUALIFIED = 540,
-	AFFECT_DRAGON_SOUL_DECK_0 = 541,
-	AFFECT_DRAGON_SOUL_DECK_1 = 542,
-
-	//AFFECT_PVP_EXPBONUS = 543,
-	//AFFECT_IMPOSSIBLE_ATTACK = 544,
-	//AFFECT_PVP_ENTER = 545,
-
-#ifdef __GROWTH_PET_SYSTEM__
-	AFFECT_GROWTH_PET = 545,
-#endif
-
-#if defined(__SOUL_SYSTEM__)
-	AFFECT_SOUL = 546,
-#endif
-#ifdef __OFFLINE_SHOP__
-	AFFECT_OFFLINE_SHOP_DECORATION = 547,
-#endif
-
-	//AFFECT_UNKNOWN_549,
-
-#if defined(__SET_ITEM__)
-	AFFECT_SET_ITEM = 550,
-#endif
-	//AFFECT_EXP_BONUS_EVENT = 551,
-	//AFFECT_ATT_SPEED_SLOW = 552,
-	//AFFECT_PEPSI_EVENT = 553,
-	//AFFECT_SUMMER_EVENT = 554,
-
-	//AFFECT_BATTLE_FIELD = 555,
-	//AFFECT_BATTLE_POTION = 556,
-	//AFFECT_BATTLE_RANK = 557,
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	AFFECT_RED_DRAGONLAIR_STONE = 558,
-#endif
-	//AFFECT_UNKNOWN_559,
-
-	//AFFECT_LUCKEY_EVENT_BUFF = 560,
-	AFFECT_MOUNT_FALL = 561,
-	//AFFECT_NO_RECOVERY = 562,
-	//AFFECT_REDUCE_CAST_SPEED = 563,
-	//AFFECT_UNKNOWN_564,
-
-	//AFFECT_ATT_GRADE_DOWN = 565,
-	//AFFECT_DEF_GRADE_DOWN = 566,
-
-	//AFFECT_CRITICAL_PCT_DOWN = 567,
-	//AFFECT_CZ_UNLIMIT_ENTER = 568,
-	//AFFECT_UNKNOWN_569,
-#if defined(__FLOWER_EVENT__)
-	AFFECT_FLOWER_EVENT = 570,
-#endif
-#if defined(__DS_SET__)
-	AFFECT_DS_SET = 571,
-#endif
-	AFFECT_RESEARCHER_ELIXIR = 572,
-#if defined(__DEFENSE_WAVE__)
-	AFFECT_DEFENSEWAVE_LASER = 573,
-#endif
-
-	//AFFECT_NO_DEATH_PENALTY_PLUS = 574,
-#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-	AFFECT_HALLOWEEN_EVENT = 575,
-#endif
-	//AFFECT_UNKNOWN_576,
-#if defined(__FISHING_GAME__)
-	AFFECT_FISHING_GOLD_TUNA = 577,
-	AFFECT_FISHING_MOVE_SPEED_DOWN = 578,
-#endif
-	//AFFECT_UNKNOWN_579,
-	AFFECT_SAFE_BOX_BUFF = 580,
-	//AFFECT_UNKNOWN_581,
-	//AFFECT_MALL_EXP_BONUS = 582,
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	AFFECT_LATE_SUMMER_EVENT_BUFF = 583,
-	AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF = 584,
-#endif
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	AFFECT_RED_DRAGONLAIR_BUFF = 585,
-#endif
-	//AFFECT_MISTS_ISLAND_BUFF = 586,
-
-	//AFFECT_SEASON_RANKING_BUFF = 587,
-	//AFFECT_SEASON_PVE_BUFF = 588,
-	//AFFECT_UNKNOWN_589,
-
-	//AFFECT_BATTLE_ROYALE_SLOW = 590,
-	//AFFECT_BATTLE_ROYALE_MOVE_SPEED = 591,
-	//AFFECT_UNKNOWN_592,
-
-	//AFFECT_PASSIVE_JOB_DECK = 593,
-#if defined(__ELEMENTAL_DUNGEON__)
-	AFFECT_CURSE_OF_ELEMENTAL = 594,
-	AFFECT_PROTECTION_OF_ELEMENTAL = 595,
-	AFFECT_POTION_OF_ELEMENTAL = 596,
-#endif
-	//AFFECT_UNKNOWN_597,
-	//AFFECT_UNKNOWN_598,
-	//AFFECT_UNKNOWN_599,
-	//AFFECT_BATTLE_ROYALE_INFINITE_STAMINA = 600,
-
-#if defined(__SET_ITEM__)
-	AFFECT_SET_ITEM_SET_VALUE_1 = 601,
-	AFFECT_SET_ITEM_SET_VALUE_2 = 602,
-	AFFECT_SET_ITEM_SET_VALUE_3 = 603,
-	AFFECT_SET_ITEM_SET_VALUE_4 = 604,
-	AFFECT_SET_ITEM_SET_VALUE_5 = 605,
-#endif
-	//AFFECT_UNKNOWN_606,
-	//AFFECT_UNKNOWN_607,
-
-#if defined(__9TH_SKILL__)
-	AFFECT_CHEONUN_INVINCIBILITY = 608,
-#endif
-
-	//AFFECT_WORLD_BOSS_REWARD = 609,
-	//AFFECT_WORLD_BOSS_DAILY_REWARD = 610,
-
-	//AFFECT_SUNGMAHEE_TOWER_BUFF = 611,
-	//AFFECT_SUNGMAHEE_TOWER_DEBUFF = 612,
-	//AFFECT_SUNGMAHEE_TOWER_CURSE = 613,
-	//AFFECT_UNKNOWN_614,
-	//AFFECT_GARRISON_DEBUFF = 615,
-	//AFFECT_GARRISON_BUFF = 616,
-
-	//AFFECT_UNKNOWN_617,
-	//AFFECT_UNKNOWN_618,
-	//AFFECT_UNKNOWN_619,
-	//AFFECT_UNKNOWN_620,
-	//AFFECT_UNKNOWN_621,
-	//AFFECT_UNKNOWN_622,
-
-#if defined(__CONQUEROR_LEVEL__)
-	AFFECT_SUNGMA_STR = 623,
-	AFFECT_SUNGMA_HP = 624,
-	AFFECT_SUNGMA_MOVE = 625,
-	AFFECT_SUNGMA_IMMUNE = 626,
-#endif
-
-	//AFFECT_UNKNOWN_627,
-	//AFFECT_UNKNOWN_628,
-	//AFFECT_SUBQUEST_NEWWORLD_5 = 629,
-	//AFFECT_WHITE_DRAGON_CAVE_CURSE = 630,
-
-	//AFFECT_SECRET_DUNGEON_BUFF_POINT_C = 631,
-	//AFFECT_SECRET_DUNGEON_BUFF_C = 632,
-	//AFFECT_SECRET_DUNGEON_BUFF_B = 633,
-	//AFFECT_SECRET_DUNGEON_BUFF_A = 634,
-
-	//AFFECT_OTHER_WORLD_DEAD_SOUL = 635,
-	//AFFECT_OTHER_WORLD_GOBLIN_PROTECTION = 636,
-	//AFFECT_OTHER_WORLD_YEOMWANG_CURSE = 637,
-	//AFFECT_OTHER_WORLD_NORTH_REAPER_ROOM_DEBUFF = 638,
-
-	//AFFECT_SKILL_MOUNT_UPGRADE_NIMBLE = 639,
-	//AFFECT_SKILL_MOUNT_UPGRADE_EXP = 640,
-	//AFFECT_SKILL_MOUNT_UPGRADE_SPEED = 641,
-	//AFFECT_SKILL_MOUNT_UPGRADE_GYENONGGONG = 642,
-	//AFFECT_SKILL_MOUNT_UPGRADE_INVINCIBLITIY = 643,
-	//AFFECT_SKILL_MOUNT_UPGRADE_KNOCKBACK = 644,
-	//AFFECT_SKILL_MOUNT_UPGRADE_TO_STRONG = 645,
-	//AFFECT_SKILL_MOUNT_UPGRADE_EFFECT_UP = 646,
-	//AFFECT_SKILL_MOUNT_UPGRADE_SUNGMA_STR = 647,
-	//AFFECT_SKILL_MOUNT_UPGRADE_SUNGMA_HP = 648,
-	//AFFECT_SKILL_MOUNT_UPGRADE_SUNGMA_MOVE = 649,
-	//AFFECT_SKILL_MOUNT_UPGRADE_SUNGMA_IMMUNE = 650,
-	//AFFECT_SKILL_MOUNT_UPGRADE_HIT_PCT = 651,
-
-	//AFFECT_MERCENARY_MISSION_MAX_ACTIVE_INCREASE = 652,
-	//AFFECT_SECRET_DUNGEON_BUFF_POINT_B = 653,
-	//AFFECT_SECRET_DUNGEON_BUFF_POINT_A = 654,
-	AFFECT_ELEMENT_BUFF_CRACK = 655,
-	//AFFECT_FLOWER_OF_GALE = 656,
-	//AFFECT_FLOWER_OF_DESTRUCTION = 657,
-	//AFFECT_UNKNOWN_658,
-	//AFFECT_UNKNOWN_659,
-	//AFFECT_UNKNOWN_660,
-	//AFFECT_UNKNOWN_661,
-	//AFFECT_IMMUNE_MINE_TOWER_SKILL = 662,
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-	AFFECT_SNOWFLAKE_STICK_EVENT_RANK_BUFF = 663,
-	AFFECT_SNOWFLAKE_STICK_EVENT_SNOWFLAKE_BUFF = 664,
-#endif
-
-	AFFECT_QUEST_START_IDX = 1000,
-
-	AFFECT_MAX
-};
-
-enum EAffectBits
-{
-	AFF_NONE,
-
-	AFF_YMIR,
-	AFF_INVISIBILITY,
-	AFF_SPAWN,
-
-	AFF_POISON,
-	AFF_SLOW,
-	AFF_STUN,
-
-	AFF_DUNGEON_READY, // 던전에서 준비 상태
-	AFF_DUNGEON_UNIQUE, // 던전 유니크 (클라이언트에서 컬링되지않음)
-
-	AFF_BUILDING_CONSTRUCTION_SMALL, // AFF_SHACKLE
-	AFF_BUILDING_CONSTRUCTION_LARGE,
-	AFF_BUILDING_UPGRADE,
-
-	AFF_MOV_SPEED_POTION,
-	AFF_ATT_SPEED_POTION,
-
-	AFF_FISH_MIND,
-
-	AFF_JEONGWIHON, // 전귀혼
-	AFF_GEOMGYEONG, // 검경
-	AFF_CHEONGEUN, // 천근추
-	AFF_GYEONGGONG, // 경공술
-	AFF_EUNHYUNG, // 은형법
-	AFF_GWIGUM, // 귀검
-	AFF_TERROR, // 공포
-	AFF_JUMAGAP, // 주마갑
-	AFF_HOSIN, // 호신
-	AFF_BOHO, // 보호
-	AFF_KWAESOK, // 쾌속
-	AFF_MANASHIELD, // 마나쉴드
-	AFF_MUYEONG, // 무영진 affect
-	AFF_REVIVE_INVISIBLE, // 부활시 잠시동안 무적
-	AFF_FIRE, // 지속 불 데미지
-	AFF_GICHEON, // 기천대공
-	AFF_JEUNGRYEOK, // 증력술
-	AFF_TANHWAN_DASH, // 탄환격용 달리기어펙트
-	AFF_PABEOP, // 파법술
-	AFF_CHEONGEUN_WITH_FALL, // 천근추
-
-	AFF_POLYMORPH, // 폴리모프
-
-	AFF_WAR_FLAG1,
-	AFF_WAR_FLAG2,
-	AFF_WAR_FLAG3,
-
-	AFF_CHINA_FIREWORK,
-	AFF_CANNOT_ATTACK,
-	AFF_CANNOT_USE_SKILL,
-	AFF_DS,
-
-	AFF_BLEEDING,
-	AFF_RED_POSSESSION,
-	AFF_BLUE_POSSESSION,
-
-	AFF_UNK46,
-	AFF_UNK47,
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	AFF_UNBEATABLE,
-#endif
-
-	AFF_BATTLE_FIELD_RANK1,
-	AFF_BATTLE_FIELD_RANK2,
-	AFF_BATTLE_FIELD_RANK3,
-	AFF_TARGET_VICTIM,
-
-	AFF_UNK53,
-
-	AFF_ELECTRIC_SHOCK,
-	AFF_CONFUSION,
-
-#if defined(__SOUL_SYSTEM__)
-	AFF_SOUL_RED,
-	AFF_SOUL_BLUE,
-	AFF_SOUL_MIX,
-#endif
-
-	AFF_UNK59,
-	AFF_BATTLE_ROYALE_SLOW_1,
-	AFF_BATTLE_ROYALE_SLOW_2,
-	AFF_BATTLE_ROYALE_SLOW_3,
-
-	AFF_UNK63,
-	AFF_PASWAE,
-	AFF_UNK65,
-
-	AFF_ELEMENT_BUFF_CRACK_NONE,
-	AFF_ELEMENT_BUFF_CRACK_FIRE,
-	AFF_ELEMENT_BUFF_CRACK_ICE,
-	AFF_ELEMENT_BUFF_CRACK_ELECT,
-	AFF_ELEMENT_BUFF_CRACK_WIND,
-	AFF_ELEMENT_BUFF_CRACK_EARTH,
-	AFF_ELEMENT_BUFF_CRACK_DARK,
-
-	AFF_FLAG_UNK73, // guild_battle (blue)
-	AFF_FLAG_UNK74, // guild_battle (yellow)
-	AFF_FLAG_UNK75, // guild_battle (green)
-	AFF_FLAG_UNK76, // guild_battle (red)
-
-	AFF_FLAG_UNK77,
-	AFF_FLAG_UNK78,
-	AFF_FLAG_UNK79,
-	AFF_FLAG_UNK80,
-
-#if defined(__9TH_SKILL__)
-	AFF_CHEONUN_INVINCIBILITY,
-	AFF_CHEONUN_NORMAL,
-	AFF_CHEONUN_MASTER,
-	AFF_CHEONUN_GRAND_MASTER,
-	AFF_CHEONUN_PERFECT_MASTER,
-#endif
-
-	AFF_BITS_MAX,
-
-	AFF_HWAYEOM = AFF_GEOMGYEONG,
-};
-
-extern void SendAffectAddPacket(LPDESC d, CAffect* pkAff);
-
-// AFFECT_DURATION_BUG_FIX
-enum AffectVariable
-{
-	// Used when Affect should be set to infinity.
-	// Since time continues to decrease, infinity is emulated by using a very large value.
-	//// 24 bits are not enough, so 25 bits are used.
-	// ...Despite saying to use 25 bits, this is an enormous comment using 29 bits...
-	// In the collect quest, an infinite time of 60 years is used, so let's use 60 years here too.
-
-	INFINITE_AFFECT_DURATION = 60 * 365 * 24 * 60 * 60
-};
-// END_AFFECT_DURATION_BUG_FIX
-
-#endif // __INC_AFFECT_H__
+#ifndef __INC_AFFECT_H__
+#define __INC_AFFECT_H__
+
+class CAffect
+{
+public:
+	DWORD dwType;
+	POINT_TYPE wApplyOn;
+	POINT_VALUE lApplyValue;
+	DWORD dwFlag;
+	long lDuration;
+	long lSPCost;
+#if defined(__AFFECT_RENEWAL__)
+	bool bRealTime;
+	bool bUpdate;
+#endif
+#if defined(__9TH_SKILL__)
+	long lValue;
+#endif
+
+	static CAffect* Acquire();
+	static void Release(CAffect* p);
+};
+
+enum EAffectTypes
+{
+	AFFECT_NONE,
+
+	//AFFECT_GUILD_SKILL_BLOOD = 152,
+	//AFFECT_GUILD_SKILL_BLESS = 153,
+	//AFFECT_GUILD_SKILL_SEONGHWI = 154,
+	//AFFECT_GUILD_SKILL_ACCEL = 155,
+	//AFFECT_GUILD_SKILL_BUNNO = 156,
+	//AFFECT_GUILD_SKILL_JUMUN = 157,
+
+	//AFFECT_SKILL_9_FINISH = 176,
+	//AFFECT_SKILL_9_ILGWANGPYO = 177,
+	//AFFECT_SKILL_9_PUNGLOEPO = 178,
+	//AFFECT_SKILL_9_GEOMAGGWI = 179,
+	//AFFECT_SKILL_9_MABEOBAGGWI = 180,
+	//AFFECT_SKILL_9_METEO = 181,
+#if defined(__9TH_SKILL__)
+	AFFECT_SKILL_9_CHEONUN = 182,
+#endif
+	//AFFECT_SKILL_9_ILIPUNGU = 183,
+
+	AFFECT_MOV_SPEED = 200,
+	AFFECT_ATT_SPEED,
+	AFFECT_ATT_GRADE,
+	AFFECT_INVISIBILITY,
+	AFFECT_STR,
+	AFFECT_DEX,
+	AFFECT_CON,
+	AFFECT_INT,
+	AFFECT_FISH_MIND_PILL,
+
+	AFFECT_POISON,
+	AFFECT_STUN,
+	AFFECT_SLOW,
+	AFFECT_DUNGEON_READY,
+	AFFECT_DUNGEON_UNIQUE,
+
+	AFFECT_BUILDING,
+	AFFECT_REVIVE_INVISIBLE,
+	AFFECT_FIRE,
+	AFFECT_CAST_SPEED,
+	AFFECT_HP_RECOVER_CONTINUE,
+	AFFECT_SP_RECOVER_CONTINUE,
+
+	AFFECT_POLYMORPH,
+	AFFECT_MOUNT,
+
+	AFFECT_WAR_FLAG,
+
+	AFFECT_BLOCK_CHAT,
+	AFFECT_CHINA_FIREWORK,
+
+	AFFECT_BOW_DISTANCE,
+	AFFECT_DEF_GRADE,
+
+	AFFECT_BLEEDING,
+
+	//AFFECT_SKILL_MONSTER_WIDE_AREA_DAMAGE_SUNGMA_STR = 274,
+	//AFFECT_SKILL_MONSTER_ATT_GRADE_DOWN = 279,
+	//AFFECT_SKILL_POSION_DAMAGE_SUNGMA_MOVE = 280,
+	//AFFECT_SKILL_CRUSH_DAMAGE_SUNGMA_STR = 281,
+
+	AFFECT_RAMADAN_ABILITY = 300,
+	AFFECT_RAMADAN_RING = 301, // 窄떪 遣트 특 駕쨈   
+
+	AFFECT_NOG_ABILITY = 302,
+	AFFECT_HOLLY_STONE_POWER = 303,
+
+	AFFECT_PREMIUM_START = 500,
+	AFFECT_EXP_BONUS = 500, //  
+	AFFECT_ITEM_BONUS = 501, //  弱
+	AFFECT_SAFEBOX = 502, // PREMIUM_SAFEBOX,
+	AFFECT_AUTOLOOT = 503, // PREMIUM_AUTOLOOT,
+	AFFECT_FISH_MIND = 504, // PREMIUM_FISH_MIND,
+	AFFECT_MARRIAGE_FAST = 505, //  
+	AFFECT_GOLD_BONUS = 506, //  확 50%
+	AFFECT_AUTO_USE = 507, // 湄 
+#if defined(__CONQUEROR_LEVEL__)
+	AFFECT_SUNGMA_BONUS = 508,
+#endif
+	AFFECT_PREMIUM_END = 509,
+
+	AFFECT_MALL = 510, //   트
+	AFFECT_NO_DEATH_PENALTY = 511, //  호 (치 均티 箕 娩)
+	AFFECT_SKILL_BOOK_BONUS = 512, //   (책   확 50% )
+	AFFECT_SKILL_NO_BOOK_DELAY = 513, // 羚횝
+
+	AFFECT_HAIR = 514, //  효
+	AFFECT_COLLECT = 515, // 트 
+
+	AFFECT_EXP_BONUS_EURO_FREE = 516, //   (  14   羞 효)
+	AFFECT_EXP_BONUS_EURO_FREE_UNDER_15 = 517,
+	AFFECT_UNIQUE_ABILITY = 518,
+
+	AFFECT_BLEND,
+
+	AFFECT_HORSE_NAME,
+	AFFECT_MOUNT_BONUS,
+
+	AFFECT_AUTO_HP_RECOVERY = 534,
+	AFFECT_AUTO_SP_RECOVERY = 535,
+
+#if defined(__LOOT_FILTER_SYSTEM__) && defined(__PREMIUM_LOOT_FILTER__)
+	AFFECT_LOOTING_SYSTEM = 537,
+#endif
+
+	//AFFECT_UNKNOWN_538,
+	//AFFECT_UNKNOWN_539,
+
+	AFFECT_DRAGON_SOUL_QUALIFIED = 540,
+	AFFECT_DRAGON_SOUL_DECK_0 = 541,
+	AFFECT_DRAGON_SOUL_DECK_1 = 542,
+
+	//AFFECT_PVP_EXPBONUS = 543,
+	//AFFECT_IMPOSSIBLE_ATTACK = 544,
+	//AFFECT_PVP_ENTER = 545,
+
+#ifdef __GROWTH_PET_SYSTEM__
+	AFFECT_GROWTH_PET,
+#endif
+
+#if defined(__SOUL_SYSTEM__)
+	AFFECT_SOUL = 546,
+#endif
+#ifdef __OFFLINE_SHOP__
+	AFFECT_OFFLINE_SHOP_DECORATION = 547,
+#endif
+
+	//AFFECT_UNKNOWN_549,
+
+#if defined(__SET_ITEM__)
+	AFFECT_SET_ITEM = 550,
+#endif
+	//AFFECT_EXP_BONUS_EVENT = 551,
+	//AFFECT_ATT_SPEED_SLOW = 552,
+	//AFFECT_PEPSI_EVENT = 553,
+	//AFFECT_SUMMER_EVENT = 554,
+
+	//AFFECT_BATTLE_FIELD = 555,
+	//AFFECT_BATTLE_POTION = 556,
+	//AFFECT_BATTLE_RANK = 557,
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	AFFECT_RED_DRAGONLAIR_STONE = 558,
+#endif
+	//AFFECT_UNKNOWN_559,
+
+	//AFFECT_LUCKEY_EVENT_BUFF = 560,
+	AFFECT_MOUNT_FALL = 561,
+	//AFFECT_NO_RECOVERY = 562,
+	//AFFECT_REDUCE_CAST_SPEED = 563,
+	//AFFECT_UNKNOWN_564,
+
+	//AFFECT_ATT_GRADE_DOWN = 565,
+	//AFFECT_DEF_GRADE_DOWN = 566,
+
+	//AFFECT_CRITICAL_PCT_DOWN = 567,
+	//AFFECT_CZ_UNLIMIT_ENTER = 568,
+	//AFFECT_UNKNOWN_569,
+#if defined(__FLOWER_EVENT__)
+	AFFECT_FLOWER_EVENT = 570,
+#endif
+#if defined(__DS_SET__)
+	AFFECT_DS_SET = 571,
+#endif
+	AFFECT_RESEARCHER_ELIXIR = 572,
+#if defined(__DEFENSE_WAVE__)
+	AFFECT_DEFENSEWAVE_LASER = 573,
+#endif
+
+	//AFFECT_NO_DEATH_PENALTY_PLUS = 574,
+#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+	AFFECT_HALLOWEEN_EVENT = 575,
+#endif
+	//AFFECT_UNKNOWN_576,
+#if defined(__FISHING_GAME__)
+	AFFECT_FISHING_GOLD_TUNA = 577,
+	AFFECT_FISHING_MOVE_SPEED_DOWN = 578,
+#endif
+	//AFFECT_UNKNOWN_579,
+	AFFECT_SAFE_BOX_BUFF = 580,
+	//AFFECT_UNKNOWN_581,
+	//AFFECT_MALL_EXP_BONUS = 582,
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	AFFECT_LATE_SUMMER_EVENT_BUFF = 583,
+	AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF = 584,
+#endif
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	AFFECT_RED_DRAGONLAIR_BUFF = 585,
+#endif
+	//AFFECT_MISTS_ISLAND_BUFF = 586,
+
+	//AFFECT_SEASON_RANKING_BUFF = 587,
+	//AFFECT_SEASON_PVE_BUFF = 588,
+	//AFFECT_UNKNOWN_589,
+
+	//AFFECT_BATTLE_ROYALE_SLOW = 590,
+	//AFFECT_BATTLE_ROYALE_MOVE_SPEED = 591,
+	//AFFECT_UNKNOWN_592,
+
+	//AFFECT_PASSIVE_JOB_DECK = 593,
+#if defined(__ELEMENTAL_DUNGEON__)
+	AFFECT_CURSE_OF_ELEMENTAL = 594,
+	AFFECT_PROTECTION_OF_ELEMENTAL = 595,
+	AFFECT_POTION_OF_ELEMENTAL = 596,
+#endif
+	//AFFECT_UNKNOWN_597,
+	//AFFECT_UNKNOWN_598,
+	//AFFECT_UNKNOWN_599,
+	//AFFECT_BATTLE_ROYALE_INFINITE_STAMINA = 600,
+
+#if defined(__SET_ITEM__)
+	AFFECT_SET_ITEM_SET_VALUE_1 = 601,
+	AFFECT_SET_ITEM_SET_VALUE_2 = 602,
+	AFFECT_SET_ITEM_SET_VALUE_3 = 603,
+	AFFECT_SET_ITEM_SET_VALUE_4 = 604,
+	AFFECT_SET_ITEM_SET_VALUE_5 = 605,
+#endif
+	//AFFECT_UNKNOWN_606,
+	//AFFECT_UNKNOWN_607,
+
+#if defined(__9TH_SKILL__)
+	AFFECT_CHEONUN_INVINCIBILITY = 608,
+#endif
+
+	//AFFECT_WORLD_BOSS_REWARD = 609,
+	//AFFECT_WORLD_BOSS_DAILY_REWARD = 610,
+
+	//AFFECT_SUNGMAHEE_TOWER_BUFF = 611,
+	//AFFECT_SUNGMAHEE_TOWER_DEBUFF = 612,
+	//AFFECT_SUNGMAHEE_TOWER_CURSE = 613,
+	//AFFECT_UNKNOWN_614,
+	//AFFECT_GARRISON_DEBUFF = 615,
+	//AFFECT_GARRISON_BUFF = 616,
+
+	//AFFECT_UNKNOWN_617,
+	//AFFECT_UNKNOWN_618,
+	//AFFECT_UNKNOWN_619,
+	//AFFECT_UNKNOWN_620,
+	//AFFECT_UNKNOWN_621,
+	//AFFECT_UNKNOWN_622,
+
+#if defined(__CONQUEROR_LEVEL__)
+	AFFECT_SUNGMA_STR = 623,
+	AFFECT_SUNGMA_HP = 624,
+	AFFECT_SUNGMA_MOVE = 625,
+	AFFECT_SUNGMA_IMMUNE = 626,
+#endif
+
+	//AFFECT_UNKNOWN_627,
+	//AFFECT_UNKNOWN_628,
+	//AFFECT_SUBQUEST_NEWWORLD_5 = 629,
+	//AFFECT_WHITE_DRAGON_CAVE_CURSE = 630,
+
+	//AFFECT_SECRET_DUNGEON_BUFF_POINT_C = 631,
+	//AFFECT_SECRET_DUNGEON_BUFF_C = 632,
+	//AFFECT_SECRET_DUNGEON_BUFF_B = 633,
+	//AFFECT_SECRET_DUNGEON_BUFF_A = 634,
+
+	//AFFECT_OTHER_WORLD_DEAD_SOUL = 635,
+	//AFFECT_OTHER_WORLD_GOBLIN_PROTECTION = 636,
+	//AFFECT_OTHER_WORLD_YEOMWANG_CURSE = 637,
+	//AFFECT_OTHER_WORLD_NORTH_REAPER_ROOM_DEBUFF = 638,
+
+	//AFFECT_SKILL_MOUNT_UPGRADE_NIMBLE = 639,
+	//AFFECT_SKILL_MOUNT_UPGRADE_EXP = 640,
+	//AFFECT_SKILL_MOUNT_UPGRADE_SPEED = 641,
+	//AFFECT_SKILL_MOUNT_UPGRADE_GYENONGGONG = 642,
+	//AFFECT_SKILL_MOUNT_UPGRADE_INVINCIBLITIY = 643,
+	//AFFECT_SKILL_MOUNT_UPGRADE_KNOCKBACK = 644,
+	//AFFECT_SKILL_MOUNT_UPGRADE_TO_STRONG = 645,
+	//AFFECT_SKILL_MOUNT_UPGRADE_EFFECT_UP = 646,
+	//AFFECT_SKILL_MOUNT_UPGRADE_SUNGMA_STR = 647,
+	//AFFECT_SKILL_MOUNT_UPGRADE_SUNGMA_HP = 648,
+	//AFFECT_SKILL_MOUNT_UPGRADE_SUNGMA_MOVE = 649,
+	//AFFECT_SKILL_MOUNT_UPGRADE_SUNGMA_IMMUNE = 650,
+	//AFFECT_SKILL_MOUNT_UPGRADE_HIT_PCT = 651,
+
+	//AFFECT_MERCENARY_MISSION_MAX_ACTIVE_INCREASE = 652,
+	//AFFECT_SECRET_DUNGEON_BUFF_POINT_B = 653,
+	//AFFECT_SECRET_DUNGEON_BUFF_POINT_A = 654,
+	AFFECT_ELEMENT_BUFF_CRACK = 655,
+	//AFFECT_FLOWER_OF_GALE = 656,
+	//AFFECT_FLOWER_OF_DESTRUCTION = 657,
+	//AFFECT_UNKNOWN_658,
+	//AFFECT_UNKNOWN_659,
+	//AFFECT_UNKNOWN_660,
+	//AFFECT_UNKNOWN_661,
+	//AFFECT_IMMUNE_MINE_TOWER_SKILL = 662,
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+	AFFECT_SNOWFLAKE_STICK_EVENT_RANK_BUFF = 663,
+	AFFECT_SNOWFLAKE_STICK_EVENT_SNOWFLAKE_BUFF = 664,
+#endif
+
+	AFFECT_QUEST_START_IDX = 1000,
+
+	AFFECT_MAX
+};
+
+enum EAffectBits
+{
+	AFF_NONE,
+
+	AFF_YMIR,
+	AFF_INVISIBILITY,
+	AFF_SPAWN,
+
+	AFF_POISON,
+	AFF_SLOW,
+	AFF_STUN,
+
+	AFF_DUNGEON_READY, //  曼 
+	AFF_DUNGEON_UNIQUE, //  크 (클潔트 첩)
+
+	AFF_BUILDING_CONSTRUCTION_SMALL, // AFF_SHACKLE
+	AFF_BUILDING_CONSTRUCTION_LARGE,
+	AFF_BUILDING_UPGRADE,
+
+	AFF_MOV_SPEED_POTION,
+	AFF_ATT_SPEED_POTION,
+
+	AFF_FISH_MIND,
+
+	AFF_JEONGWIHON, // 혼
+	AFF_GEOMGYEONG, // 江
+	AFF_CHEONGEUN, // 천
+	AFF_GYEONGGONG, // 
+	AFF_EUNHYUNG, // 
+	AFF_GWIGUM, // 叩
+	AFF_TERROR, // 
+	AFF_JUMAGAP, // 寧
+	AFF_HOSIN, // 호
+	AFF_BOHO, // 호
+	AFF_KWAESOK, // 
+	AFF_MANASHIELD, // 
+	AFF_MUYEONG, //  affect
+	AFF_REVIVE_INVISIBLE, // 활 천 
+	AFF_FIRE, //   
+	AFF_GICHEON, // 천
+	AFF_JEUNGRYEOK, // 쩌
+	AFF_TANHWAN_DASH, // 탄환駙 貧트
+	AFF_PABEOP, // 캣
+	AFF_CHEONGEUN_WITH_FALL, // 천
+
+	AFF_POLYMORPH, // 
+
+	AFF_WAR_FLAG1,
+	AFF_WAR_FLAG2,
+	AFF_WAR_FLAG3,
+
+	AFF_CHINA_FIREWORK,
+	AFF_CANNOT_ATTACK,
+	AFF_CANNOT_USE_SKILL,
+	AFF_DS,
+
+	AFF_BLEEDING,
+	AFF_RED_POSSESSION,
+	AFF_BLUE_POSSESSION,
+
+	AFF_UNK46,
+	AFF_UNK47,
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	AFF_UNBEATABLE,
+#endif
+
+	AFF_BATTLE_FIELD_RANK1,
+	AFF_BATTLE_FIELD_RANK2,
+	AFF_BATTLE_FIELD_RANK3,
+	AFF_TARGET_VICTIM,
+
+	AFF_UNK53,
+
+	AFF_ELECTRIC_SHOCK,
+	AFF_CONFUSION,
+
+#if defined(__SOUL_SYSTEM__)
+	AFF_SOUL_RED,
+	AFF_SOUL_BLUE,
+	AFF_SOUL_MIX,
+#endif
+
+	AFF_UNK59,
+	AFF_BATTLE_ROYALE_SLOW_1,
+	AFF_BATTLE_ROYALE_SLOW_2,
+	AFF_BATTLE_ROYALE_SLOW_3,
+
+	AFF_UNK63,
+	AFF_PASWAE,
+	AFF_UNK65,
+
+	AFF_ELEMENT_BUFF_CRACK_NONE,
+	AFF_ELEMENT_BUFF_CRACK_FIRE,
+	AFF_ELEMENT_BUFF_CRACK_ICE,
+	AFF_ELEMENT_BUFF_CRACK_ELECT,
+	AFF_ELEMENT_BUFF_CRACK_WIND,
+	AFF_ELEMENT_BUFF_CRACK_EARTH,
+	AFF_ELEMENT_BUFF_CRACK_DARK,
+
+	AFF_FLAG_UNK73, // guild_battle (blue)
+	AFF_FLAG_UNK74, // guild_battle (yellow)
+	AFF_FLAG_UNK75, // guild_battle (green)
+	AFF_FLAG_UNK76, // guild_battle (red)
+
+	AFF_FLAG_UNK77,
+	AFF_FLAG_UNK78,
+	AFF_FLAG_UNK79,
+	AFF_FLAG_UNK80,
+
+#if defined(__9TH_SKILL__)
+	AFF_CHEONUN_INVINCIBILITY,
+	AFF_CHEONUN_NORMAL,
+	AFF_CHEONUN_MASTER,
+	AFF_CHEONUN_GRAND_MASTER,
+	AFF_CHEONUN_PERFECT_MASTER,
+#endif
+
+	AFF_BITS_MAX,
+
+	AFF_HWAYEOM = AFF_GEOMGYEONG,
+};
+
+extern void SendAffectAddPacket(LPDESC d, CAffect* pkAff);
+
+// AFFECT_DURATION_BUG_FIX
+enum AffectVariable
+{
+	// Used when Affect should be set to infinity.
+	// Since time continues to decrease, infinity is emulated by using a very large value.
+	//// 24 bits are not enough, so 25 bits are used.
+	// ...Despite saying to use 25 bits, this is an enormous comment using 29 bits...
+	// In the collect quest, an infinite time of 60 years is used, so let's use 60 years here too.
+
+	INFINITE_AFFECT_DURATION = 60 * 365 * 24 * 60 * 60
+};
+// END_AFFECT_DURATION_BUG_FIX
+
+#endif // __INC_AFFECT_H__
diff --git a/server/server/home/metin2/Source/Server/game/src/char.cpp b/server/server/home/metin2/Source/Server/game/src/char.cpp
index 2d0c257..cdeb675 100644
--- a/server/server/home/metin2/Source/Server/game/src/char.cpp
+++ b/server/server/home/metin2/Source/Server/game/src/char.cpp
@@ -776,7 +776,7 @@ void CHARACTER::Destroy()
 				party->Quit(GetVID());
 		}
 
-		SetParty(NULL); // 안해도 되지만 안전하게.
+		SetParty(NULL); // 巒  構.
 	}
 
 	if (m_pkMobInst)
@@ -891,40 +891,40 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 {
 	if (!CanHandleItem())
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 거래중(창고,교환,상점)에는 개인상점을 사용할 수 없습니다."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 킹(창,환,) 貫   求."));
 		return;
 	}
 
 #ifdef __GROWTH_PET_SYSTEM__
 	if (GetActiveGrowthPet())
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("PET_YANINDAYKEN_PAZAR_ACAMAZSIN"));
+		ChatPacket(CHAT_TYPE_INFO, "You cannot open a private shop whilst summoning your pet.");
 		return;
 	}
 
 	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("PET_STATLARINI_DEGISTIRME_UYARI"));
+		ChatPacket(CHAT_TYPE_INFO, "While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc.");
 		return;
 	}
 #endif
 
 	if (GetPart(PART_MAIN) > 2)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("갑옷을 벗어야 개인 상점을 열 수 있습니다."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("      笭求."));
 		return;
 	}
 
-	if (GetMyShop()) // 이미 샵이 열려 있으면 닫는다.
+	if (GetMyShop()) // 譴    莩쨈.
 	{
 		CloseMyShop();
 		return;
 	}
 
-	// 진행중인 퀘스트가 있으면 상점을 열 수 없다.
+	//  트     .
 	quest::PC* pPC = quest::CQuestManager::instance().GetPCForce(GetPlayerID());
 
-	// GetPCForce는 NULL일 수 없으므로 따로 확인하지 않음
+	// GetPCForce NULL  퓐  확 
 	if (pPC->IsRunning())
 		return;
 
@@ -952,7 +952,7 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 	if (GOLD_MAX <= nTotalMoney)
 	{
 		sys_err("[OVERFLOW_GOLD] Overflow (GOLD_MAX) id %u name %s", GetPlayerID(), GetName());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("20억 냥을 초과하여 상점을 열수가 없습니다"));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("20  歌臼   求"));
 		return;
 	}
 
@@ -975,7 +975,7 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 
 	if (CBanwordManager::instance().CheckString(m_stShopSign.c_str(), m_stShopSign.length()))
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("비속어나 은어가 포함된 상점 이름으로 상점을 열 수 없습니다."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("曇爭 載 鍍  見    求."));
 		return;
 	}
 
@@ -983,7 +983,7 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 #if defined(__CHEQUE_SYSTEM__)
 	std::map<DWORD, TItemPriceInfo> itemkind;
 #else
-	std::map<DWORD, DWORD> itemkind; // 아이템 종류별 가격, first: vnum, second: 단일 수량 가격
+	std::map<DWORD, DWORD> itemkind; //   , first: vnum, second:   
 #endif
 	// END_OF_MYSHOP_PRICE_LIST
 
@@ -1005,19 +1005,19 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 
 			if (item_table && (IS_SET(item_table->ullAntiFlags, ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_MYSHOP)))
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("유료화 아이템은 개인상점에서 판매할 수 없습니다."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("화  貫 퓔  求."));
 				return;
 			}
 
 			if (pkItem->IsEquipped() == true)
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("장비중인 아이템은 개인상점에서 판매할 수 없습니다."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  貫 퓔  求."));
 				return;
 			}
 
 			if (true == pkItem->isLocked())
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("사용중인 아이템은 개인상점에서 판매할 수 없습니다."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  貫 퓔  求."));
 				return;
 			}
 
@@ -1046,11 +1046,11 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 	}
 
 	// MYSHOP_PRICE_LIST
-	// 보따리 개수를 감소시킨다.
-	if (CountSpecifyItem(71049)) // 비단 보따리는 없애지 않고 가격정보를 저장한다.
+	//   努킨.
+	if (CountSpecifyItem(71049)) //    歌  磯.
 	{
 		//
-		// 아이템 가격정보를 저장하기 위해 아이템 가격정보 패킷을 만들어 DB 캐시에 보낸다.
+		//   歐    킷  DB 캐첼 .
 		//
 		TItemPriceListTable header;
 		memset(&header, 0, sizeof(TItemPriceListTable));
@@ -1079,7 +1079,7 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 	else if (CountSpecifyItem(50200))
 		RemoveSpecifyItem(50200, 1);
 	else
-		return; // 보따리가 없으면 중단.
+		return; //   杉.
 
 	if (m_pkExchange)
 		m_pkExchange->Cancel();
@@ -1106,8 +1106,8 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 	{
 		HorseSummon(false, true);
 	}
-	// new mount 이용 중에, 개인 상점 열면 자동 unmount
-	// StopRiding으로 뉴마운트까지 처리하면 좋은데 왜 그렇게 안해놨는지 알 수 없다.
+	// new mount 結 傷,    湄 unmount
+	// StopRiding 트 처玖   瀏 卍   .
 	else if (GetMountVnum())
 	{
 		RemoveAffect(AFFECT_MOUNT);
@@ -1179,41 +1179,41 @@ void CHARACTER::Restart(BYTE bSubCMD)
 		{
 			if (IsHack())
 			{
-				// 성지 맵일경우에는 체크 하지 않는다.
+				//  構荑 체크  苛쨈.
 				if (false == CThreeWayWar::instance().IsSungZiMapIndex(GetMapIndex()))
 				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("아직 재시작 할 수 없습니다. (%d초 남음)", iTimeToDead - (180 - g_nPortalLimitTime)));
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求. (%d )", iTimeToDead - (180 - g_nPortalLimitTime)));
 					return;
 				}
 			}
 
 			if (iTimeToDead > 170)
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("아직 재시작 할 수 없습니다. (%d초 남음)", iTimeToDead - 170));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求. (%d )", iTimeToDead - 170));
 				return;
 			}
 		}
 	}
 
 	// PREVENT_HACK
-	// DESC : 창고, 교환 창 후 포탈을 사용하는 버그에 이용될수 있어서
-	// 쿨타임을 추가
+	// DESC : 창, 환 창  탈 求 六 結 羚底
+	// 타 煞
 	if (bSubCMD == SCMD_RESTART_TOWN)
 	{
 		if (IsHack())
 		{
-			// 길드맵, 성지맵에서는 체크 하지 않는다.
+			// , 却 체크  苛쨈.
 			if ((!GetWarMap() || GetWarMap()->GetType() == GUILD_WAR_TYPE_FLAG) ||
 				false == CThreeWayWar::instance().IsSungZiMapIndex(GetMapIndex()))
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("아직 재시작 할 수 없습니다. (%d초 남음)", iTimeToDead - (180 - g_nPortalLimitTime)));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求. (%d )", iTimeToDead - (180 - g_nPortalLimitTime)));
 				return;
 			}
 		}
 
 		if (iTimeToDead > 173)
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("아직 마을에서 재시작 할 수 없습니다. (%d 초 남음)", iTimeToDead - 173));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("     求. (%d  )", iTimeToDead - 173));
 			return;
 		}
 	}
@@ -1226,7 +1226,7 @@ void CHARACTER::Restart(BYTE bSubCMD)
 	StartRecoveryEvent();
 
 	// FORKED_LOAD
-	// DESC: 삼거리 전투시 부활을 할경우 맵의 입구가 아닌 삼거리 전투의 시작지점으로 이동하게 된다.
+	// DESC: 타  활 柰  逃 틈 타   絹構 홱.
 	if (1 == quest::CQuestManager::instance().GetEventFlag("threeway_war"))
 	{
 		if (bSubCMD == SCMD_RESTART_TOWN || bSubCMD == SCMD_RESTART_HERE)
@@ -1245,12 +1245,12 @@ void CHARACTER::Restart(BYTE bSubCMD)
 				return;
 			}
 
-			// 성지
+			// 
 			if (true == CThreeWayWar::instance().IsSungZiMapIndex(GetMapIndex()))
 			{
 				if (CThreeWayWar::instance().GetReviveTokenForPlayer(GetPlayerID()) <= 0)
 				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("성지에서 부활 기회를 모두 잃었습니다! 마을로 이동합니다!"));
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 활 회  勞求!  絹爛求!"));
 					WarpSet(EMPIRE_START_X(GetEmpire()), EMPIRE_START_Y(GetEmpire()));
 				}
 				else
@@ -1338,22 +1338,22 @@ void CHARACTER::Restart(BYTE bSubCMD)
 			sys_log(0, "do_restart: restart town");
 
 #if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-			if (GetGuildDragonLair())
-			{
-				const LPSECTREE_MAP pSectree = SECTREE_MANAGER::instance().GetMap(MAP_N_FLAME_DRAGON);
-				if (pSectree != NULL)
-				{
-					Show(GetMapIndex(),
-						pSectree->m_setting.iBaseX + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "x") * 100,
-						pSectree->m_setting.iBaseY + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "y") * 100, 0);
-					Stop();
-				}
-				else
-					CGuildDragonLairManager::Instance().Exit(this);
-
+			if (GetGuildDragonLair())
+			{
+				const LPSECTREE_MAP pSectree = SECTREE_MANAGER::instance().GetMap(MAP_N_FLAME_DRAGON);
+				if (pSectree != NULL)
+				{
+					Show(GetMapIndex(),
+						pSectree->m_setting.iBaseX + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "x") * 100,
+						pSectree->m_setting.iBaseY + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "y") * 100, 0);
+					Stop();
+				}
+				else
+					CGuildDragonLairManager::Instance().Exit(this);
+
 				PointChange(POINT_HP, 50 - GetHP());
-				DeathPenalty(1);
-				return;
+				DeathPenalty(1);
+				return;
 			}
 #endif
 
@@ -1457,7 +1457,7 @@ void CHARACTER::RestartAtSamePos()
 	}
 }
 
-// Entity에 내가 나타났다고 패킷을 보낸다.
+// Entity  타鳴 킷 .
 void CHARACTER::EncodeInsertPacket(LPENTITY entity)
 {
 	LPDESC d;
@@ -1465,7 +1465,7 @@ void CHARACTER::EncodeInsertPacket(LPENTITY entity)
 	if (!(d = entity->GetDesc()))
 		return;
 
-	// 길드이름 버그 수정 코드
+	// 見   湄
 	LPCHARACTER ch = (LPCHARACTER)entity;
 #ifdef __OFFLINE_SHOP__
 	if (IsNPC() && GetRaceNum() == COfflineShop::CLOSED_RACE) {
@@ -1480,7 +1480,7 @@ void CHARACTER::EncodeInsertPacket(LPENTITY entity)
 	}
 #endif
 	ch->SendGuildName(GetGuild());
-	// 길드이름 버그 수정 코드
+	// 見   湄
 
 	TPacketGCCharacterAdd pack;
 
@@ -1782,8 +1782,8 @@ void CHARACTER::UpdatePacket()
 #endif
 	pack.bPKMode = m_bPKMode;
 	pack.dwMountVnum = GetMountVnum();
-#if defined(__LEFT_SEAT__)
-	pack.bLeftSeat = IsPC() ? LeftSeat() : false;
+#if defined(__LEFT_SEAT__)
+	pack.bLeftSeat = IsPC() ? LeftSeat() : false;
 #endif
 
 #if defined(__GUILD_LEADER_GRADE_NAME__)
@@ -1895,14 +1895,14 @@ void CHARACTER::SetPosition(int pos)
 		{
 			case POS_FIGHTING:
 				if (!IsState(m_stateBattle))
-					MonsterLog("[BATTLE] 싸우는 상태");
+					MonsterLog("[BATTLE] 恝 ");
 
 				GotoState(m_stateBattle);
 				break;
 
 			default:
 				if (!IsState(m_stateIdle))
-					MonsterLog("[IDLE] 쉬는 상태");
+					MonsterLog("[IDLE]  ");
 
 				GotoState(m_stateIdle);
 				break;
@@ -2089,7 +2089,7 @@ void CHARACTER::FlushDelayedSaveItem()
 {
 	int i = 0;
 
-	// 저장 안된 소지품을 전부 저장시킨다.
+	//  홴 품  킨.
 	LPITEM item = nullptr;
 
 	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
@@ -2204,7 +2204,7 @@ void CHARACTER::Disconnect(const char* c_pszReason)
 	if (GetParty())
 		GetParty()->Unlink(this);
 
-	// 죽었을 때 접속끊으면 경험치 줄게 하기
+	// 類  袒 치 鳴 歐
 	if (IsStun() || IsDead())
 	{
 		DeathPenalty(0);
@@ -2221,7 +2221,7 @@ void CHARACTER::Disconnect(const char* c_pszReason)
 	SaveAffect();
 	m_bIsLoadedAffect = false;
 
-	m_bSkipSave = true; // 이 이후에는 더이상 저장하면 안된다.
+	m_bSkipSave = true; //  커 鵑 玖 홴홱.
 
 	quest::CQuestManager::instance().DisconnectPC(this);
 
@@ -2765,7 +2765,7 @@ void CHARACTER::SetPlayerProto(const TPlayerTable* t)
 	SetSP(t->sp);
 	SetStamina(t->stamina);
 
-	// GM일때 보호모드
+	// GM灸 호
 	if (GetGMLevel() > GM_LOW_WIZARD)
 		m_afAffectFlag.Set(AFF_YMIR);
 
@@ -2791,7 +2791,7 @@ void CHARACTER::SetPlayerProto(const TPlayerTable* t)
 	}
 
 #if defined(__PET_SYSTEM__)
-	// NOTE: 일단 캐릭터가 PC인 경우에만 PetSystem을 갖도록 함. 유럽 머신당 메모리 사용률때문에 NPC까지 하긴 좀..
+	// NOTE: 求 캐叩 PC 荑 PetSystem  .  擔킴 貧  NPC 歐 ..
 	if (m_petSystem)
 	{
 		m_petSystem->Destroy();
@@ -2887,9 +2887,9 @@ void CHARACTER::SetProto(const CMob* pkMob)
 		else
 			SetPoint(POINT_DEF_GRADE_BONUS, 15);
 
-		// 산타용
+		// 타
 		//m_dwPlayStartTime = get_dword_time() + 10 * 60 * 1000;
-		// 신선자 노해
+		// 탉 
 		m_dwPlayStartTime = get_dword_time() + 30 * 1000;
 		if (test_server)
 			m_dwPlayStartTime = get_dword_time() + 30 * 1000;
@@ -2948,7 +2948,7 @@ const TMobTable& CHARACTER::GetMobTable() const
 BYTE CHARACTER::GetMobRank() const
 {
 	if (!m_pkMobData)
-		return MOB_RANK_KNIGHT; // PC일 경우 KNIGHT급
+		return MOB_RANK_KNIGHT; // PC  KNIGHT
 
 	return m_pkMobData->m_table.bRank;
 }
@@ -3024,7 +3024,7 @@ float CHARACTER::GetMobDamageMultiply() const
 	float fDamMultiply = GetMobTable().fDamMultiply;
 
 	if (IsBerserk())
-		fDamMultiply = fDamMultiply * 2.0f; // BALANCE: 광폭화 시 두배
+		fDamMultiply = fDamMultiply * 2.0f; // BALANCE: 화  菅
 
 	return fDamMultiply;
 }
@@ -3118,7 +3118,7 @@ void CHARACTER::ComputeBattlePoints()
 		SetPoint(POINT_MAGIC_DEF_GRADE, GetPoint(POINT_DEF_GRADE));
 
 		//
-		// 기본 ATK = 2lev + 2str, 직업에 마다 2str은 바뀔 수 있음
+		// 羞 ATK = 2lev + 2str,   2str 侮  
 		//
 		int iAtk = GetLevel() * 2;
 		int iStatAtk = 0;
@@ -3148,14 +3148,14 @@ void CHARACTER::ComputeBattlePoints()
 				break;
 		}
 
-		// 말을 타고 있고, 스탯으로 인한 공격력이 ST*2 보다 낮으면 ST*2로 한다.
-		// 스탯을 잘못 찍은 사람 공격력이 더 낮지 않게 하기 위해서다.
+		//  타 斂,   賦 ST*2   ST*2 磯.
+		//  蔘   賦   歌 歐 漫.
 		if (GetMountVnum() && iStatAtk < 2 * GetPoint(POINT_ST))
 			iStatAtk = (2 * GetPoint(POINT_ST));
 
 		iAtk += iStatAtk;
 
-		// 승마(말) : 검수라 데미지 감소
+		// 쨍() : 鋼  
 		if (GetMountVnum())
 		{
 			if (GetJob() == JOB_SURA && GetSkillGroup() == 1)
@@ -3176,7 +3176,7 @@ void CHARACTER::ComputeBattlePoints()
 		PointChange(POINT_ATT_GRADE, iAtk);
 
 		// DEF = LEV + CON + ARMOR
-		int iShowDef = GetLevel() + GetPoint(POINT_HT); // For Ymir(천마)
+		int iShowDef = GetLevel() + GetPoint(POINT_HT); // For Ymir(천)
 		int iDef = GetLevel() + static_cast<int>((GetPoint(POINT_HT) / 1.25)); // For Other
 		int iArmor = 0;
 
@@ -3256,7 +3256,7 @@ void CHARACTER::ComputeBattlePoints()
 #endif
 		}
 
-		// 말 타고 있을 때 방어력이 말의 기준 방어력보다 낮으면 기준 방어력으로 설정
+		//  타      쨘    
 		if (IsHorseRiding())
 		{
 			if (iArmor < GetHorseArmor())
@@ -3377,7 +3377,7 @@ void CHARACTER::ComputePoints()
 
 	if (IsPC())
 	{
-		// 최대 생명력/정신력
+		// 獵 /킹
 		iMaxHP = JobInitialPoints[GetJob()].max_hp + m_points.iRandomHP + GetPoint(POINT_HT) * JobInitialPoints[GetJob()].hp_per_ht;
 		iMaxSP = JobInitialPoints[GetJob()].max_sp + m_points.iRandomSP + GetPoint(POINT_IQ) * JobInitialPoints[GetJob()].sp_per_iq;
 		iMaxStamina = JobInitialPoints[GetJob()].max_stamina + GetPoint(POINT_HT) * JobInitialPoints[GetJob()].stamina_per_con;
@@ -3389,7 +3389,7 @@ void CHARACTER::ComputePoints()
 			iMaxHP += static_cast<int>(pkSk->kPointPoly.Eval());
 		}
 
-		// 기본 값들
+		// 羞 
 		SetPoint(POINT_MOV_SPEED, 100);
 		SetPoint(POINT_ATT_SPEED, 100);
 		PointChange(POINT_ATT_SPEED, GetPoint(POINT_PARTY_HASTE_BONUS));
@@ -3408,9 +3408,9 @@ void CHARACTER::ComputePoints()
 
 	if (IsPC())
 	{
-		// 말 타고 있을 때는 기본 스탯이 말의 기준 스탯보다 낮으면 높게 만든다.
-		// 따라서 말의 기준 스탯이 무사 기준이므로, 수라/무당은 전체 스탯 합이
-		// 대채적으로 더 올라가게 될 것이다.
+		//  타   羞    횐   .
+		//      譴퓐, / 체  
+		// 채  철箚“  甄.
 		if (GetMountVnum())
 		{
 			if (GetHorseST() > GetPoint(POINT_ST))
@@ -3429,13 +3429,13 @@ void CHARACTER::ComputePoints()
 
 	ComputeBattlePoints();
 
-	// 기본 HP/SP 설정
+	// 羞 HP/SP 
 	if (iMaxHP != GetMaxHP())
-		SetRealPoint(POINT_MAX_HP, iMaxHP); // 기본HP를 RealPoint에 저장해 놓는다.
+		SetRealPoint(POINT_MAX_HP, iMaxHP); // 羞팆P RealPoint  쨈.
 	PointChange(POINT_MAX_HP, 0);
 
 	if (iMaxSP != GetMaxSP())
-		SetRealPoint(POINT_MAX_SP, iMaxSP); // 기본SP를 RealPoint에 저장해 놓는다.
+		SetRealPoint(POINT_MAX_SP, iMaxSP); // 羞팗P RealPoint  쨈.
 	PointChange(POINT_MAX_SP, 0);
 
 	SetMaxStamina(iMaxStamina);
@@ -3452,10 +3452,10 @@ void CHARACTER::ComputePoints()
 		}
 	}
 
-	// 용혼석 시스템
-	// ComputePoints에서는 케릭터의 모든 속성값을 초기화하고,
-	// 아이템, 버프 등에 관련된 모든 속성값을 재계산하기 때문에,
-	// 용혼석 시스템도 ActiveDeck에 있는 모든 용혼석의 속성값을 다시 적용시켜야 한다.
+	// 혼 첵
+	// ComputePoints   憺 珂화構,
+	// ,  楮 천  憺 歐 ,
+	// 혼 첵滂 ActiveDeck 獵  혼 憺 母 耭 磯.
 #if defined(__DRAGON_SOUL_SYSTEM__)
 	if (DragonSoul_IsDeckActivated())
 	{
@@ -3511,9 +3511,9 @@ void CHARACTER::ComputePoints()
 	UpdatePacket();
 }
 
-// m_dwPlayStartTime의 단위는 milisecond다. 데이터베이스에는 분단위로 기록하기
-// 때문에 플레이시간을 계산할 때 / 60000 으로 나눠서 하는데, 그 나머지 값이 남았
-// 을 때 여기에 dwTimeRemain으로 넣어서 제대로 계산되도록 해주어야 한다.
+// m_dwPlayStartTime  milisecond. 故決 畇 歐
+//  첨決챨   / 60000   求쨉,    
+//   藪 dwTimeRemain 羚底  풩 羚 磯.
 void CHARACTER::ResetPlayTime(DWORD dwTimeRemain)
 {
 	m_dwPlayStartTime = get_dword_time() - dwTimeRemain;
@@ -3538,7 +3538,7 @@ EVENTFUNC(recovery_event)
 	if (!ch->IsPC())
 	{
 		//
-		// 몬스터 회복
+		//  회
 		//
 		if (ch->IsAffectFlag(AFF_POISON))
 			return PASSES_PER_SEC(MAX(1, ch->GetMobTable().bRegenCycle));
@@ -3619,16 +3619,16 @@ EVENTFUNC(recovery_event)
 	else
 	{
 		//
-		// PC 회복
+		// PC 회
 		//
 		ch->CheckTarget();
-		//ch->UpdateSectree(); // 여기서 이걸 왜하지?
+		//ch->UpdateSectree(); // 茱 隔 ?
 		ch->UpdateKillerMode();
 
 		if (ch->IsAffectFlag(AFF_POISON) == true)
 		{
-			// 중독인 경우 자동회복 금지
-			// 파법술인 경우 자동회복 금지
+			// 森  湄회 
+			// 캣  湄회 
 			return 3;
 		}
 
@@ -3637,8 +3637,8 @@ EVENTFUNC(recovery_event)
 
 		int iSec = (get_dword_time() - ch->GetLastMoveTime()) / 3000;
 
-		// SP 회복 루틴.
-		// 왜 이걸로 해서 함수로 빼놨는가 ?!
+		// SP 회 틴.
+		//  隔 漫 獨 째 ?!
 		ch->DistributeSP(ch);
 
 		if (ch->GetMaxHP() <= ch->GetHP())
@@ -3669,7 +3669,7 @@ void CHARACTER::StartRecoveryEvent()
 	if (IsDead() || IsStun())
 		return;
 
-	if (IsNPC() && GetHP() >= GetMaxHP()) // 몬스터는 체력이 다 차있으면 시작 안한다.
+	if (IsNPC() && GetHP() >= GetMaxHP()) // 姑 체    磯.
 		return;
 
 	if (IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_NORECOVERY))
@@ -3721,7 +3721,7 @@ void CHARACTER::SetRotation(float fRot)
 	m_pointsInstant.fRot = fRot;
 }
 
-// x, y 방향으로 보고 선다.
+// x, y   .
 void CHARACTER::SetRotationToXY(long x, long y)
 {
 	SetRotation(GetDegreeFromPositionXY(GetX(), GetY(), x, y));
@@ -3737,17 +3737,17 @@ bool CHARACTER::CanMove() const
 	if (CannotMoveByAffect())
 		return false;
 
-	if (GetMyShop()) // 상점 연 상태에서는 움직일 수 없음
+	if (GetMyShop()) //   쩔   
 		return false;
 
-	// 0.2초 전이라면 움직일 수 없다.
+	// 0.2 繭   .
 	//if (get_float_time() - m_fSyncTime < 0.2f)
 	//	return false;
 
 	return true;
 }
 
-// 무조건 x, y 위치로 이동 시킨다.
+//  x, y 치 絹 킨.
 bool CHARACTER::Sync(long x, long y)
 {
 	if (!GetSectree())
@@ -3781,7 +3781,7 @@ bool CHARACTER::Sync(long x, long y)
 
 	if (GetDungeon())
 	{
-		// 던젼용 이벤트 속성 변화
+		//  遣트 憺 화
 		int iLastEventAttr = m_iEventAttr;
 		m_iEventAttr = new_tree->GetEventAttribute(x, y);
 
@@ -3832,7 +3832,7 @@ bool CHARACTER::Sync(long x, long y)
 void CHARACTER::Stop()
 {
 	if (!IsState(m_stateIdle))
-		MonsterLog("[IDLE] 정지");
+		MonsterLog("[IDLE] ");
 
 	GotoState(m_stateIdle);
 
@@ -3842,8 +3842,8 @@ void CHARACTER::Stop()
 
 bool CHARACTER::Goto(long x, long y)
 {
-	// TODO 거리체크 필요
-	// 같은 위치면 이동할 필요 없음 (자동 성공)
+	// TODO 타체크 却
+	//  치 絹 却  (湄 )
 	if (GetX() == x && GetY() == y)
 		return false;
 
@@ -3976,17 +3976,17 @@ void CHARACTER::CalculateMoveDuration()
 	m_dwMoveStartTime = get_dword_time();
 }
 
-// x y 위치로 이동 한다. (이동할 수 있는 가 없는 가를 확인 하고 Sync 메소드로 실제 이동 한다)
-// 서버는 char의 x, y 값을 바로 바꾸지만,
-// 클라에서는 이전 위치에서 바꾼 x, y까지 interpolation한다.
-// 걷거나 뛰는 것은 char의 m_bNowWalking에 달려있다.
-// Warp를 의도한 것이라면 Show를 사용할 것.
+// x y 치 絹 磯. (絹  獵    확 構 Sync 氷撚  絹 磯)
+//  char x, y  慕 侮,
+// 클璨【  치 侮 x, y interpolation磯.
+// 활킬 募  char m_bNowWalking 玭獵.
+// Warp 풩 繭 Show  .
 bool CHARACTER::Move(long x, long y)
 {
 	if (IsPC() && IsDead())
 		return false;
 
-	// 같은 위치면 이동할 필요 없음 (자동 성공)
+	//  치 絹 却  (湄 )
 	if (GetX() == x && GetY() == y)
 		return true;
 
@@ -4180,7 +4180,7 @@ void CHARACTER::SetPoint(POINT_TYPE wPointType, POINT_VALUE lPointValue)
 
 	m_pointsInstant.points[wPointType] = lPointValue;
 
-	// 아직 이동이 다 안끝났다면 이동 시간 계산을 다시 해야 한다.
+	//  絹  홰摸 絹 챨  母 瞞 磯.
 	if (wPointType == POINT_MOV_SPEED && get_dword_time() < m_dwMoveStartTime + m_dwMoveDuration)
 	{
 		CalculateMoveDuration();
@@ -4227,7 +4227,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 
 			sys_log(0, "LEVELUP: %s %d NEXT EXP %d", GetName(), GetLevel(), GetNextExp());
 
-			// WOLFMAN 수인족 특수처리 (수인족은 직군이 하나이므로, 5레벨이 되면 무조건 1번 직군으로 설정함. 하드코딩 ㅈㅅ)
+			// WOLFMAN  특처 (  毬譴퓐, 5 퓔  1  . 溝湄 )
 			if (GetJob() == JOB_WOLFMAN)
 			{
 				if ((5 <= val) && (GetSkillGroup() != 1))
@@ -4266,7 +4266,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 		case POINT_NEXT_EXP:
 		{
 			val = GetNextExp();
-			bAmount = false; // 무조건 bAmount는 false 여야 한다.
+			bAmount = false; //  bAmount false  磯.
 		} break;
 
 		case POINT_EXP:
@@ -4274,7 +4274,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 			DWORD exp = GetExp();
 			DWORD next_exp = GetNextExp();
 
-			// exp가 0 이하로 가지 않도록 한다
+			// exp 0 狗  茄 磯
 			if (amount < 0 && exp <= -amount)
 			{
 				sys_log(0, "%s - Reduce EXP by %d, CUR EXP: %d (setting to zero)", GetName(), -amount, exp);
@@ -4295,14 +4295,14 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 #endif
 
 #if defined(__CHATTING_WINDOW_RENEWAL__)
-				ChatPacket(CHAT_TYPE_EXP_INFO, LC_STRING("%d의 경험치를 획득했습니다.", amount));
+				ChatPacket(CHAT_TYPE_EXP_INFO, LC_STRING("%d 치 획颯求.", amount));
 #else
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d의 경험치를 획득했습니다.", amount));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d 치 획颯求.", amount));
 #endif
 
 				DWORD iExpBalance = 0;
 
-				// 레벨 업!
+				//  !
 				if (exp + amount >= next_exp)
 				{
 					iExpBalance = (exp + amount) - next_exp;
@@ -4335,7 +4335,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 				DWORD q = DWORD(next_exp / 4.0f);
 				int iLevStep = GetRealPoint(POINT_LEVEL_STEP);
 
-				// iLevStep이 4 이상이면 레벨이 올랐어야 하므로 여기에 올 수 없는 값이다.
+				// iLevStep 4 鵑見  철 球퓐 藪    甄.
 				if (iLevStep >= 4)
 				{
 					sys_err("%s LEVEL_STEP bigger than 4! (%d)", GetName(), iLevStep);
@@ -4477,16 +4477,16 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 
 			if (val == 0)
 			{
-				// Stamina가 없으니 걷자!
+				// Stamina  !
 				SetNowWalking(true);
 			}
 			else if (prev_val == 0)
 			{
-				// 없던 스테미나가 생겼으니 이전 모드 복귀
+				//  瑠犬    
 				ResetWalking();
 			}
 
-			if (amount < 0 && val != 0) // 감소는 보내지않는다.
+			if (amount < 0 && val != 0) // 年 苛쨈.
 				return;
 		}
 		break;
@@ -4496,7 +4496,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 			SetPoint(type, GetPoint(type) + amount);
 
 			//SetMaxHP(GetMaxHP() + amount);
-			// 최대 생명력 = (기본 최대 생명력 + 추가) * 최대생명력%
+			// 獵  = (羞 獵  + 煞) * 獵%
 			int curMaxHP = GetMaxHP();
 			int hp = GetRealPoint(POINT_MAX_HP);
 			int add_hp = MIN(3500, hp * GetPoint(POINT_MAX_HP_PCT) / 100);
@@ -4526,7 +4526,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 			SetPoint(type, GetPoint(type) + amount);
 
 			//SetMaxSP(GetMaxSP() + amount);
-			// 최대 정신력 = (기본 최대 정신력 + 추가) * 최대정신력%
+			// 獵 킹 = (羞 獵 킹 + 煞) * 獵킹%
 			int curMaxSP = GetMaxSP();
 			int sp = GetRealPoint(POINT_MAX_SP);
 			int add_sp = MIN(800, sp * GetPoint(POINT_MAX_SP_PCT) / 100);
@@ -4629,12 +4629,12 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 		case POINT_HP_RECOVERY:
 		case POINT_SP_RECOVERY:
 
-		case POINT_ATTBONUS_HUMAN: // 42 인간에게 강함
-		case POINT_ATTBONUS_ANIMAL: // 43 동물에게 데미지 % 증가
-		case POINT_ATTBONUS_ORC: // 44 웅귀에게 데미지 % 증가
-		case POINT_ATTBONUS_MILGYO: // 45 밀교에게 데미지 % 증가
-		case POINT_ATTBONUS_UNDEAD: // 46 시체에게 데미지 % 증가
-		case POINT_ATTBONUS_DEVIL: // 47 마귀(악마)에게 데미지 % 증가
+		case POINT_ATTBONUS_HUMAN: // 42 寬 
+		case POINT_ATTBONUS_ANIMAL: // 43   % 
+		case POINT_ATTBONUS_ORC: // 44 沽  % 
+		case POINT_ATTBONUS_MILGYO: // 45 閨  % 
+		case POINT_ATTBONUS_UNDEAD: // 46 체  % 
+		case POINT_ATTBONUS_DEVIL: // 47 (퓔)  % 
 		case POINT_ATTBONUS_INSECT:
 		case POINT_ATTBONUS_DESERT:
 
@@ -4660,11 +4660,11 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 		case POINT_RESIST_PENETRATE:
 		case POINT_CURSE_PCT:
 
-		case POINT_STEAL_HP: // 48 생명력 흡수
-		case POINT_STEAL_SP: // 49 정신력 흡수
+		case POINT_STEAL_HP: // 48  
+		case POINT_STEAL_SP: // 49 킹 
 
-		case POINT_MANA_BURN_PCT: // 50 마나 번
-		case POINT_DAMAGE_SP_RECOVER: // 51 공격당할 시 정신력 회복 확률
+		case POINT_MANA_BURN_PCT: // 50  
+		case POINT_DAMAGE_SP_RECOVER: // 51 莩  킹 회 확
 		case POINT_RESIST_NORMAL_DAMAGE:
 		case POINT_RESIST_SWORD:
 		case POINT_RESIST_TWOHAND:
@@ -4684,12 +4684,12 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 		case POINT_RESIST_ICE:
 		case POINT_RESIST_EARTH:
 		case POINT_RESIST_DARK:
-		case POINT_REFLECT_MELEE: // 67 공격 반사
-		case POINT_REFLECT_CURSE: // 68 저주 반사
-		case POINT_POISON_REDUCE: // 69 독데미지 감소
+		case POINT_REFLECT_MELEE: // 67  部
+		case POINT_REFLECT_CURSE: // 68  部
+		case POINT_POISON_REDUCE: // 69  
 		case POINT_BLEEDING_REDUCE:
 
-		case POINT_KILL_SP_RECOVER: // 70 적 소멸시 MP 회복
+		case POINT_KILL_SP_RECOVER: // 70  恬 MP 회
 		case POINT_KILL_HP_RECOVERY: // 75
 		case POINT_HIT_HP_RECOVERY:
 		case POINT_HIT_SP_RECOVERY:
@@ -5190,7 +5190,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 
 				DWORD iExpBalance = 0;
 
-				// 레벨 업!
+				//  !
 				if (exp + amount >= next_exp)
 				{
 					iExpBalance = (exp + amount) - next_exp;
@@ -5353,11 +5353,11 @@ void CHARACTER::ApplyPoint(POINT_TYPE wApplyType, POINT_VALUE lApplyValue)
 		case APPLY_NONE:						// 0
 			break;
 
-			// NOTE: 아이템에 의한 최대HP 보너스나 퀘스트 보상 보너스가 똑같은 방식을 사용하므로
-			// 그냥 MAX_HP만 계산하면 퀘스트 보상의 경우 문제가 생김. 사실 원래 이쪽이 합리적이기도 하고..
-			// 바꾼 공식은 현재 최대 hp와 보유 hp의 비율을 구한 뒤 바뀔 최대 hp를 기준으로 hp를 보정한다.
-			// 원래 PointChange에서 하는게 좋을것 같은데 설계 문제로 어려워서 skip..
-			// SP도 똑같이 계산한다.
+			// NOTE: 謗  獵HP 駕 트  駕 활  球퓐
+			// 柳 MAX_HP 玖 트    .    辣堅竪 構..
+			// 侮   獵 hp  hp    侮 獵 hp  hp 磯.
+			//  PointChange 求째      skip..
+			// SP 활 磯.
 			// Mantis : 101460 ~ ity ~
 		case APPLY_MAX_HP:						// 1
 		{
@@ -5440,7 +5440,7 @@ void CHARACTER::ApplyPoint(POINT_TYPE wApplyType, POINT_VALUE lApplyValue)
 		case APPLY_SKILL:						// 51
 			// SKILL_DAMAGE_BONUS
 		{
-			// 최상위 비트 기준으로 8비트 vnum, 9비트 add, 15비트 change
+			// 怜 트  8트 vnum, 9트 add, 15트 change
 			// 00000000 00000000 00000000 00000000
 			// ^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^
 			// vnum		^ add		change
@@ -5508,25 +5508,25 @@ void CHARACTER::ApplyPoint(POINT_TYPE wApplyType, POINT_VALUE lApplyValue)
 		case APPLY_PC_BANG_EXP_BONUS:			// 75
 		case APPLY_PC_BANG_DROP_BONUS:			// 76
 
-			//case APPLY_EXTRACT_HP_PCT:			// 77 사용시 HP 소모
+			//case APPLY_EXTRACT_HP_PCT:			// 77  HP 恬
 
 		case APPLY_RESIST_WARRIOR:				// 78
 		case APPLY_RESIST_ASSASSIN:				// 79
 		case APPLY_RESIST_SURA:					// 80
 		case APPLY_RESIST_SHAMAN:				// 81
 
-		case APPLY_ENERGY:						// 82 기력
-		case APPLY_DEF_GRADE:					// 83 방어력. DEF_GRADE_BONUS는 클라에서 두배로 보여지는 의도된 버그(...)가 있다.
-		case APPLY_COSTUME_ATTR_BONUS:			// 84 코스튬 아이템에 붙은 속성치 보너스
-		case APPLY_MAGIC_ATTBONUS_PER:			// 85 마법 공격력 +x%
-		case APPLY_MELEE_MAGIC_ATTBONUS_PER:	// 86 마법 + 밀리 공격력 +x%
+		case APPLY_ENERGY:						// 82 
+		case APPLY_DEF_GRADE:					// 83 . DEF_GRADE_BONUS 클璨【 菅  풩 (...) 獵.
+		case APPLY_COSTUME_ATTR_BONUS:			// 84 黴튬 謗  憺치 駕
+		case APPLY_MAGIC_ATTBONUS_PER:			// 85  賦 +x%
+		case APPLY_MELEE_MAGIC_ATTBONUS_PER:	// 86  + 龜 賦 +x%
 
-		case APPLY_RESIST_ICE:					// 87 냉기 저항
-		case APPLY_RESIST_EARTH:				// 88 대지 저항
-		case APPLY_RESIST_DARK:					// 89 어둠 저항
+		case APPLY_RESIST_ICE:					// 87 챰 
+		case APPLY_RESIST_EARTH:				// 88  
+		case APPLY_RESIST_DARK:					// 89  
 
-		case APPLY_ANTI_CRITICAL_PCT:			// 90 크리티컬 저항
-		case APPLY_ANTI_PENETRATE_PCT:			// 91 관통타격 저항
+		case APPLY_ANTI_CRITICAL_PCT:			// 90 크티 
+		case APPLY_ANTI_PENETRATE_PCT:			// 91 타 
 
 		case APPLY_BLEEDING_REDUCE:				// 92
 		case APPLY_BLEEDING_PCT:				// 93
@@ -5853,7 +5853,7 @@ void CHARACTER::MonsterLog(const char* format, ...)
 	else
 		len += len2;
 
-	// \0 문자 포함
+	// \0  
 	++len;
 
 	va_end(args);
@@ -5945,7 +5945,7 @@ void CHARACTER::mining_cancel()
 	{
 		sys_log(0, "XXX MINING CANCEL");
 		event_cancel(&m_pkMiningEvent);
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("채광을 중단하였습니다."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("채 杉臼求."));
 	}
 }
 
@@ -5973,13 +5973,13 @@ void CHARACTER::mining(LPCHARACTER chLoad)
 
 	if (!pick || pick->GetType() != ITEM_PICK)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("곡괭이를 장착하세요."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("齋ぬ 究."));
 		return;
 	}
 
-	int count = number(5, 15); // 동작 횟수, 한 동작당 2초
+	int count = number(5, 15); //  횟,  榜 2
 
-	// 채광 동작을 보여줌
+	// 채  
 	TPacketGCDigMotion p;
 	p.header = HEADER_GC_DIG_MOTION;
 	p.vid = GetVID();
@@ -6006,7 +6006,7 @@ void CHARACTER::fishing()
 		return;
 	}
 
-	// 못감 속성에서 낚시를 시도한다?
+	//  憺 첩 천磯?
 	{
 		LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(GetMapIndex());
 
@@ -6018,45 +6018,43 @@ void CHARACTER::fishing()
 
 		if (IS_SET(dwAttr, ATTR_BLOCK))
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("낚시를 할 수 있는 곳이 아닙니다"));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("첩   獵  틈爛求"));
 			return;
 		}
 	}
 
 #ifdef __GROWTH_PET_SYSTEM__
-/*
 	if (GetActiveGrowthPet())
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot fish while your pet is summoned."));
+		ChatPacket(CHAT_TYPE_INFO, "You cannot fish while your pet is summoned.");
 		return;
 	}
-*/
 
 	if (IsPetHatchWindowOpen())
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("PET_VARKEN_BALIK_TUTAMAZSIN"));
+		ChatPacket(CHAT_TYPE_INFO, "You cannot fish when your pet is hatched.");
 		return;
 	}
 
 	if (IsPetChangeNameWindowOpen())
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("PET_BONUS_PENCERESI_ACIKKEN_BALIK_TUTAMAZSIN"));
+		ChatPacket(CHAT_TYPE_INFO, "You cannot fish while the pet bonus change window is open.");
 		return;
 	}
 #endif
 
 	LPITEM rod = GetWear(WEAR_WEAPON);
 
-	// 낚시대 장착
+	// 척 
 	if (!rod || rod->GetType() != ITEM_ROD)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("낚시대를 장착 하세요."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("척釉  究."));
 		return;
 	}
 
 	if (0 == rod->GetSocket(2))
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("미끼를 끼고 던져 주세요."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("犬   玲."));
 		return;
 	}
 
@@ -6092,7 +6090,7 @@ void CHARACTER::fishing_take()
 	}
 	else
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("낚시대가 아닌 물건으로 낚시를 할 수 없습니다!"));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("척諛 틈  첩   求!"));
 	}
 
 	event_cancel(&m_pkFishingEvent);
@@ -6132,10 +6130,10 @@ void CHARACTER::SetNextStatePulse(int iNextPulse)
 	m_dwNextStatePulse = iNextPulse;
 
 	if (iNextPulse < 10)
-		MonsterLog("다음상태로어서가자");
+		MonsterLog("쨌刮底");
 }
 
-// 캐릭터 인스턴스 업데이트 함수.
+// 캐 館絿 트 獨.
 void CHARACTER::UpdateCharacter(DWORD dwPulse)
 {
 	CFSM::Update();
@@ -6165,35 +6163,35 @@ void CHARACTER::SetPart(BYTE bPartPos, DWORD dwVal)
 
 DWORD CHARACTER::GetPart(BYTE bPartPos) const
 {
-	assert(bPartPos < PART_MAX_NUM);
-#if defined(__HIDE_COSTUME_SYSTEM__)
-	if (bPartPos == PART_MAIN && GetHiddenCostumeByPart(PART_MAIN))
-	{
-		if (const LPITEM pArmor = GetWear(WEAR_BODY))
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			return pArmor->GetTransmutationVnum() != 0 ? pArmor->GetTransmutationVnum() : pArmor->GetVnum();
-#else
-			return pArmor->GetVnum();
-#endif
-		else
-			return 0;
-	}
-	else if (bPartPos == PART_WEAPON && GetHiddenCostumeByPart(PART_WEAPON))
-	{
-		if (const LPITEM pWeapon = GetWear(WEAR_WEAPON))
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			return pWeapon->GetTransmutationVnum() != 0 ? pWeapon->GetTransmutationVnum() : pWeapon->GetVnum();
-#else
-			return pWeapon->GetVnum();
-#endif
-		else
-			return 0;
-	}
-	else
-	{
-		if (GetHiddenCostumeByPart(bPartPos))
-			return 0;
-	}
+	assert(bPartPos < PART_MAX_NUM);
+#if defined(__HIDE_COSTUME_SYSTEM__)
+	if (bPartPos == PART_MAIN && GetHiddenCostumeByPart(PART_MAIN))
+	{
+		if (const LPITEM pArmor = GetWear(WEAR_BODY))
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			return pArmor->GetTransmutationVnum() != 0 ? pArmor->GetTransmutationVnum() : pArmor->GetVnum();
+#else
+			return pArmor->GetVnum();
+#endif
+		else
+			return 0;
+	}
+	else if (bPartPos == PART_WEAPON && GetHiddenCostumeByPart(PART_WEAPON))
+	{
+		if (const LPITEM pWeapon = GetWear(WEAR_WEAPON))
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			return pWeapon->GetTransmutationVnum() != 0 ? pWeapon->GetTransmutationVnum() : pWeapon->GetVnum();
+#else
+			return pWeapon->GetVnum();
+#endif
+		else
+			return 0;
+	}
+	else
+	{
+		if (GetHiddenCostumeByPart(bPartPos))
+			return 0;
+	}
 #endif
 	return m_pointsInstant.adwParts[bPartPos];
 }
@@ -6203,7 +6201,7 @@ DWORD CHARACTER::GetOriginalPart(BYTE bPartPos) const
 	switch (bPartPos)
 	{
 		case PART_MAIN:
-			if (!IsPC()) // PC가 아닌 경우 현재 파트를 그대로 리턴
+			if (!IsPC()) // PC 틈   트 榴 
 				return GetPart(PART_MAIN);
 			else
 				return m_pointsInstant.bBasePart;
@@ -6266,7 +6264,7 @@ bool CHARACTER::SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList)
 		if (m_pkChrSyncOwner)
 			sys_log(1, "SyncRelease %s %p from %s", GetName(), this, m_pkChrSyncOwner->GetName());
 
-		// 리스트에서 제거하지 않더라도 포인터는 NULL로 셋팅되어야 한다.
+		// 트  苛 姑 NULL 천퓸 磯.
 		m_pkChrSyncOwner = NULL;
 	}
 	else
@@ -6274,12 +6272,12 @@ bool CHARACTER::SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList)
 		if (!IsSyncOwner(ch))
 			return false;
 
-		// 거리가 200 이상이면 SyncOwner가 될 수 없다.
+		// 타 200 鵑見 SyncOwner   .
 		if (DISTANCE_APPROX(GetX() - ch->GetX(), GetY() - ch->GetY()) > 250)
 		{
 			sys_log(1, "SetSyncOwner distance over than 250 %s %s", GetName(), ch->GetName());
 
-			// SyncOwner일 경우 Owner로 표시한다.
+			// SyncOwner  Owner 표磯.
 			if (m_pkChrSyncOwner == ch)
 				return true;
 
@@ -6297,7 +6295,7 @@ bool CHARACTER::SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList)
 			m_pkChrSyncOwner = ch;
 			m_pkChrSyncOwner->m_kLst_pkChrSyncOwned.push_back(this);
 
-			// SyncOwner가 바뀌면 LastSyncTime을 초기화한다.
+			// SyncOwner 侮 LastSyncTime 珂화磯.
 			static const timeval zero_tv = { 0, 0 };
 			SetLastSyncTime(zero_tv);
 
@@ -6307,9 +6305,9 @@ bool CHARACTER::SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList)
 		m_fSyncTime = get_float_time();
 	}
 
-	// TODO: Sync Owner가 같더라도 계속 패킷을 보내고 있으므로,
-	// 동기화 된 시간이 3초 이상 지났을 때 풀어주는 패킷을
-	// 보내는 방식으로 하면 패킷을 줄일 수 있다.
+	// TODO: Sync Owner   킷  퓐,
+	// 화  챨 3 鵑   풀獵 킷
+	//   玖 킷   獵.
 	TPacketGCOwnership pack;
 
 	pack.bHeader = HEADER_GC_OWNERSHIP;
@@ -6325,7 +6323,7 @@ struct FuncClearSync
 	void operator () (LPCHARACTER ch)
 	{
 		assert(ch != NULL);
-		ch->SetSyncOwner(NULL, false); // false 플래그로 해야 for_each 가 제대로 돈다.
+		ch->SetSyncOwner(NULL, false); // false 첨瀏 瞞 for_each   .
 	}
 };
 
@@ -6333,7 +6331,7 @@ void CHARACTER::ClearSync()
 {
 	SetSyncOwner(NULL);
 
-	// 아래 for_each에서 나를 m_pkChrSyncOwner로 가진 자들의 포인터를 NULL로 한다.
+	// 틔 for_each  m_pkChrSyncOwner  湄 拷 NULL 磯.
 	std::for_each(m_kLst_pkChrSyncOwned.begin(), m_kLst_pkChrSyncOwned.end(), FuncClearSync());
 	m_kLst_pkChrSyncOwned.clear();
 }
@@ -6343,8 +6341,8 @@ bool CHARACTER::IsSyncOwner(LPCHARACTER ch) const
 	if (m_pkChrSyncOwner == ch)
 		return true;
 
-	// 마지막으로 동기화 된 시간이 3초 이상 지났다면 소유권이 아무에게도
-	// 없다. 따라서 아무나 SyncOwner이므로 true 리턴
+	//  화  챨 3 鵑 摸  틜鍍
+	// .  틜 SyncOwner譴퓐 true 
 	if (get_float_time() - m_fSyncTime >= 3.0f)
 		return true;
 
@@ -6378,11 +6376,11 @@ void CHARACTER::SetParty(LPPARTY pkParty)
 }
 
 // PARTY_JOIN_BUG_FIX
-/// 파티 가입 event 정보
+/// 티  event 
 EVENTINFO(TPartyJoinEventInfo)
 {
-	DWORD dwGuestPID; ///< 파티에 참여할 캐릭터의 PID
-	DWORD dwLeaderPID; ///< 파티 리더의 PID
+	DWORD dwGuestPID; ///< 티  캐 PID
+	DWORD dwLeaderPID; ///< 티  PID
 
 	TPartyJoinEventInfo()
 		: dwGuestPID(0)
@@ -6420,7 +6418,7 @@ bool CHARACTER::RequestToParty(LPCHARACTER leader)
 
 	if (!leader)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("파티장이 접속 상태가 아니라서 요청을 할 수 없습니다."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("티  째 틈灸 청   求."));
 		return false;
 	}
 
@@ -6441,38 +6439,38 @@ bool CHARACTER::RequestToParty(LPCHARACTER leader)
 			break;
 
 		case PERR_SERVER:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 서버 문제로 파티 관련 처리를 할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>   티  처   求."));
 			return false;
 
 		case PERR_DIFFEMPIRE:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 다른 제국과 파티를 이룰 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 摸  티 肩  求."));
 			return false;
 
 		case PERR_DUNGEON:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 던전 안에서는 파티 초대를 할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  효 티 苛釉   求."));
 			return false;
 
 		case PERR_OBSERVER:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 관전 모드에선 파티 초대를 할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  恙 티 苛釉   求."));
 			return false;
 
 		case PERR_LVBOUNDARY:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> -30 ~ +30 레벨 이내의 상대방만 초대할 수 있습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> -30 ~ +30  犬 歷 苛  笭求."));
 			return false;
 
 		case PERR_LOWLEVEL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티내 최고 레벨 보다 30레벨이 낮아 초대할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 斂   30  苛  求."));
 			return false;
 
 		case PERR_HILEVEL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티내 최저 레벨 보다 30레벨이 높아 초대할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티    30  苛  求."));
 			return false;
 
 		case PERR_ALREADYJOIN:
 			return false;
 
 		case PERR_PARTYISFULL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 더 이상 파티원을 초대할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  鵑 티 苛  求."));
 			return false;
 
 		default:
@@ -6492,7 +6490,7 @@ bool CHARACTER::RequestToParty(LPCHARACTER leader)
 #else
 	leader->ChatPacket(CHAT_TYPE_COMMAND, "PartyRequest %u", (DWORD)GetVID());
 #endif
-	ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 님에게 파티가입 신청을 했습니다.", leader->GetName()));
+	ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 篤 티 청 颯求.", leader->GetName()));
 	return true;
 }
 
@@ -6546,7 +6544,7 @@ void CHARACTER::AcceptToParty(LPCHARACTER member)
 	event_cancel(&member->m_pkPartyRequestEvent);
 
 	if (!GetParty())
-		member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 파티에 속해있지 않습니다."));
+		member->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 티  駕求."));
 	else
 	{
 		if (GetPlayerID() != GetParty()->GetLeaderPID())
@@ -6556,16 +6554,16 @@ void CHARACTER::AcceptToParty(LPCHARACTER member)
 		switch (errcode)
 		{
 			case PERR_NONE: member->PartyJoin(this); return;
-			case PERR_SERVER: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 서버 문제로 파티 관련 처리를 할 수 없습니다.")); break;
-			case PERR_DUNGEON: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 던전 안에서는 파티 초대를 할 수 없습니다.")); break;
-			case PERR_OBSERVER: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 관전 모드에선 파티 초대를 할 수 없습니다.")); break;
-			case PERR_LVBOUNDARY: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> -30 ~ +30 레벨 이내의 상대방만 초대할 수 있습니다.")); break;
-			case PERR_LOWLEVEL: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티내 최고 레벨 보다 30레벨이 낮아 초대할 수 없습니다.")); break;
-			case PERR_HILEVEL: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티내 최저 레벨 보다 30레벨이 높아 초대할 수 없습니다.")); break;
+			case PERR_SERVER: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>   티  처   求.")); break;
+			case PERR_DUNGEON: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  효 티 苛釉   求.")); break;
+			case PERR_OBSERVER: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  恙 티 苛釉   求.")); break;
+			case PERR_LVBOUNDARY: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> -30 ~ +30  犬 歷 苛  笭求.")); break;
+			case PERR_LOWLEVEL: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 斂   30  苛  求.")); break;
+			case PERR_HILEVEL: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티    30  苛  求.")); break;
 			case PERR_ALREADYJOIN: break;
 			case PERR_PARTYISFULL: {
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 더 이상 파티원을 초대할 수 없습니다."));
-				member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티의 인원제한이 초과하여 파티에 참가할 수 없습니다."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  鵑 티 苛  求."));
+				member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 恝 歌臼 티   求."));
 				break;
 			}
 			default: sys_err("Do not process party join error(%d)", errcode);
@@ -6576,8 +6574,8 @@ void CHARACTER::AcceptToParty(LPCHARACTER member)
 }
 
 /**
-* 파티 초대 event callback 함수.
-* event 가 발동하면 초대 거절로 처리한다.
+* 티 苛 event callback 獨.
+* event  森玖 苛  처磯.
 **/
 EVENTFUNC(party_invite_event)
 {
@@ -6604,12 +6602,12 @@ void CHARACTER::PartyInvite(LPCHARACTER pchInvitee)
 {
 	if (GetParty() && GetParty()->GetLeaderPID() != GetPlayerID())
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티원을 초대할 수 있는 권한이 없습니다."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 苛  獵  求."));
 		return;
 	}
 	else if (pchInvitee->IsBlockMode(BLOCK_PARTY_INVITE))
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> %s 님이 파티 거부 상태입니다.", pchInvitee->GetName()));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> %s  티 탄 都求.", pchInvitee->GetName()));
 		return;
 	}
 
@@ -6621,39 +6619,39 @@ void CHARACTER::PartyInvite(LPCHARACTER pchInvitee)
 			break;
 
 		case PERR_SERVER:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 서버 문제로 파티 관련 처리를 할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>   티  처   求."));
 			return;
 
 		case PERR_DIFFEMPIRE:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 다른 제국과 파티를 이룰 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 摸  티 肩  求."));
 			return;
 
 		case PERR_DUNGEON:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 던전 안에서는 파티 초대를 할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  효 티 苛釉   求."));
 			return;
 
 		case PERR_OBSERVER:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 관전 모드에선 파티 초대를 할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  恙 티 苛釉   求."));
 			return;
 
 		case PERR_LVBOUNDARY:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> -30 ~ +30 레벨 이내의 상대방만 초대할 수 있습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> -30 ~ +30  犬 歷 苛  笭求."));
 			return;
 
 		case PERR_LOWLEVEL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티내 최고 레벨 보다 30레벨이 낮아 초대할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 斂   30  苛  求."));
 			return;
 
 		case PERR_HILEVEL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티내 최저 레벨 보다 30레벨이 높아 초대할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티    30  苛  求."));
 			return;
 
 		case PERR_ALREADYJOIN:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 이미 %s님은 파티에 속해 있습니다.", pchInvitee->GetName()));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 譴 %s 티  笭求.", pchInvitee->GetName()));
 			return;
 
 		case PERR_PARTYISFULL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 더 이상 파티원을 초대할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  鵑 티 苛  求."));
 			return;
 
 		default:
@@ -6665,7 +6663,7 @@ void CHARACTER::PartyInvite(LPCHARACTER pchInvitee)
 		return;
 
 	//
-	// EventMap 에 이벤트 추가
+	// EventMap  遣트 煞
 	//
 	TPartyJoinEventInfo* info = AllocEventInfo<TPartyJoinEventInfo>();
 
@@ -6675,7 +6673,7 @@ void CHARACTER::PartyInvite(LPCHARACTER pchInvitee)
 	m_PartyInviteEventMap.insert(EventMap::value_type(pchInvitee->GetPlayerID(), event_create(party_invite_event, info, PASSES_PER_SEC(10))));
 
 	//
-	// 초대 받는 character 에게 초대 패킷 전송
+	// 苛 濱 character  苛 킷 
 	//
 
 	TPacketGCPartyInvite p;
@@ -6699,7 +6697,7 @@ void CHARACTER::PartyInviteAccept(LPCHARACTER pchInvitee)
 
 	if (GetParty() && GetParty()->GetLeaderPID() != GetPlayerID())
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티원을 초대할 수 있는 권한이 없습니다."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 苛  獵  求."));
 		return;
 	}
 
@@ -6711,36 +6709,36 @@ void CHARACTER::PartyInviteAccept(LPCHARACTER pchInvitee)
 			break;
 
 		case PERR_SERVER:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 서버 문제로 파티 관련 처리를 할 수 없습니다."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>   티  처   求."));
 			return;
 
 		case PERR_DUNGEON:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 던전 안에서는 파티 초대에 응할 수 없습니다."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  효 티 苛肉   求."));
 			return;
 
 		case PERR_OBSERVER:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 관전 모드에선 파티 초대를 할 수 없습니다."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  恙 티 苛釉   求."));
 			return;
 
 		case PERR_LVBOUNDARY:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> -30 ~ +30 레벨 이내의 상대방만 초대할 수 있습니다."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> -30 ~ +30  犬 歷 苛  笭求."));
 			return;
 
 		case PERR_LOWLEVEL:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티내 최고 레벨 보다 30레벨이 낮아 초대할 수 없습니다."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 斂   30  苛  求."));
 			return;
 
 		case PERR_HILEVEL:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티내 최저 레벨 보다 30레벨이 높아 초대할 수 없습니다."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티    30  苛  求."));
 			return;
 
 		case PERR_ALREADYJOIN:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티 초대에 응할 수 없습니다."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 苛肉   求."));
 			return;
 
 		case PERR_PARTYISFULL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 더 이상 파티원을 초대할 수 없습니다."));
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티의 인원제한이 초과하여 파티에 참가할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  鵑 티 苛  求."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 恝 歌臼 티   求."));
 			return;
 
 		default:
@@ -6749,7 +6747,7 @@ void CHARACTER::PartyInviteAccept(LPCHARACTER pchInvitee)
 	}
 
 	//
-	// 파티 가입 처리
+	// 티  처
 	//
 
 	if (GetParty())
@@ -6779,13 +6777,13 @@ void CHARACTER::PartyInviteDeny(DWORD dwPID)
 
 	LPCHARACTER pchInvitee = CHARACTER_MANAGER::instance().FindByPID(dwPID);
 	if (pchInvitee)
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> %s님이 파티 초대를 거절하셨습니다.", pchInvitee->GetName()));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> %s 티 苛釉 究決求.", pchInvitee->GetName()));
 }
 
 void CHARACTER::PartyJoin(LPCHARACTER pLeader)
 {
-	pLeader->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> %s님이 파티에 참가하셨습니다.", GetName()));
-	ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> %s님의 파티에 참가하셨습니다.", pLeader->GetName()));
+	pLeader->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> %s 티 究決求.", GetName()));
+	ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> %s 티 究決求.", pLeader->GetName()));
 
 	pLeader->GetParty()->Join(GetPlayerID());
 	pLeader->GetParty()->Link(this);
@@ -6998,7 +6996,7 @@ void CHARACTER::OnClick(LPCHARACTER pkChrCauser)
 		return;
 	}
 
-	// 교환중일때 퀘스트를 진행할 수 없다.
+	// 환灸 트   .
 	{
 		if (pkChrCauser->GetExchange())
 		{
@@ -7008,9 +7006,9 @@ void CHARACTER::OnClick(LPCHARACTER pkChrCauser)
 		}
 	}
 
-	// 상점을 연상태로 퀘스트를 진행할 수 없다.
+	//  쨌 트   .
 	{
-		// 단, 자신은 자신의 상점을 클릭할 수 있다.
+		// , 黴 黴  클  獵.
 		if (pkChrCauser->GetMyShop() && pkChrCauser != this)
 		{
 			if (test_server)
@@ -7021,45 +7019,45 @@ void CHARACTER::OnClick(LPCHARACTER pkChrCauser)
 
 	if (IsPC())
 	{
-		// 타겟으로 설정된 경우는 PC에 의한 클릭도 퀘스트로 처리하도록 합니다.
+		// 타   PC  클 트 처溝 爛求.
 		if (!CTargetManager::instance().GetTargetInfo(pkChrCauser->GetPlayerID(), TARGET_TYPE_VID, GetVID()))
 		{
-			// 20050317.myevan.타겟이 아닌 경우는 개인 상점 처리 기능을 작동시킨다.
+			// 20050317.myevan.타 틈    처  滂킨.
 			if (GetMyShop())
 			{
 				if (pkChrCauser->IsDead() == true) return;
 
 #ifdef __GROWTH_PET_SYSTEM__
-				if (pkChrCauser->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || pkChrCauser->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+				if (pkChrCauser->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
 				{
-					pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("PET_STATLARINI_DEGISTIRME_UYARI"));
+					pkChrCauser->ChatPacket(CHAT_TYPE_INFO, "While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc.");
 					return;
 				}
 #endif
 
 				// PREVENT_TRADE_WINDOW
-				if (pkChrCauser == this) // 자기는 가능
+				if (pkChrCauser == this) // 未 
 				{
 					if (PreventTradeWindow(WND_MYSHOP, true/*except*/))
 					{
-						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 거래중(창고,교환,상점)에는 개인상점을 사용할 수 없습니다."));
+						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 킹(창,환,) 貫   求."));
 						return;
 					}
 				}
-				else // 다른 사람이 클릭했을때
+				else // 摸  클
 				{
-					// 클릭한 사람이 교환/창고/개인상점/상점이용중이라면 불가
+					// 클  환/창/貫/結繭 柰
 					if (pkChrCauser->PreventTradeWindow(WND_ALL))
 					{
-						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 거래중(창고,교환,상점)에는 개인상점을 사용할 수 없습니다."));
+						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 킹(창,환,) 貫   求."));
 						return;
 					}
 
-					// 클릭한 대상이 교환/창고/상점이용중이라면 불가
+					// 클  환/창/結繭 柰
 					//if ((GetExchange() || IsOpenSafebox() || GetShopOwner()))
 					if (PreventTradeWindow(WND_MYSHOP | WND_SHOPOWNER, true/*except*/))
 					{
-						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 다른 거래를 하고 있는 중입니다."));
+						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 摸 킹 構 獵 都求."));
 						return;
 					}
 				}
@@ -7095,9 +7093,9 @@ void CHARACTER::OnClick(LPCHARACTER pkChrCauser)
 #endif
 
 #ifdef __GROWTH_PET_SYSTEM__
-	if (pkChrCauser->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || pkChrCauser->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	if (pkChrCauser->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
 	{
-		pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("PET_STATLARINI_DEGISTIRIRKEN_NPC_ACAMAZSIN"));
+		pkChrCauser->ChatPacket(CHAT_TYPE_INFO, "You cannot speak with an NPC while modifying your pet's stats.");
 		return;
 	}
 #endif
@@ -7110,12 +7108,12 @@ void CHARACTER::OnClick(LPCHARACTER pkChrCauser)
 			return;
 	}
 
-	// NPC 전용 기능 수행 : 상점 열기 등
+	// NPC    :   
 	if (!IsPC())
 	{
 		if (!m_triggerOnClick.pFunc)
 		{
-			// NPC 트리거 시스템 로그 보기
+			// NPC 트 첵 慣 
 			/*
 			sys_err("%s.OnClickFailure(%s) : triggerOnClick.pFunc is EMPTY(pid=%d)",
 				pkChrCauser->GetName(),
@@ -7184,7 +7182,7 @@ void CHARACTER::ClearStone()
 {
 	if (!m_set_pkChrSpawnedBy.empty())
 	{
-		// 내가 스폰시킨 몬스터들을 모두 죽인다.
+		//  킨 孤  灌.
 		FuncDeadSpawnedByStone f;
 		std::for_each(m_set_pkChrSpawnedBy.begin(), m_set_pkChrSpawnedBy.end(), f);
 		m_set_pkChrSpawnedBy.clear();
@@ -7548,9 +7546,9 @@ void CHARACTER::ExitToSavedLocation()
 }
 
 // fixme
-// 지금까진 privateMapIndex 가 현재 맵 인덱스와 같은지 체크 하는 것을 외부에서 하고,
-// 다르면 warpset을 불렀는데
-// 이를 warpset 안으로 넣자.
+// 膚 privateMapIndex    琯  체크 求  甁恝 構,
+// 摸 warpset 念쨉
+// 見 warpset  .
 bool CHARACTER::WarpSet(long x, long y, long lPrivateMapIndex)
 {
 	if (!IsPC())
@@ -7648,7 +7646,7 @@ void CHARACTER::WarpEnd()
 
 	if (!map_allow_find(index))
 	{
-		// 이 곳으로 워프할 수 없으므로 워프하기 전 좌표로 되돌리자.
+		//     퓐 歐  표 풩.
 		sys_err("location %d %d not allowed to login this server", m_posWarp.x, m_posWarp.y);
 		if (g_bIgnoreDisallowedMap) // 20200807.Owsap : Go home if map index isn't allowed.
 			GoHome();
@@ -7707,7 +7705,7 @@ bool CHARACTER::Return()
 	SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
 
 	if (test_server)
-		sys_log(0, "%s %p 포기하고 돌아가자! %d %d", GetName(), this, x, y);
+		sys_log(0, "%s %p 構 튼! %d %d", GetName(), this, x, y);
 
 	if (GetParty())
 		GetParty()->SendMessage(this, PM_RETURN, x, y);
@@ -7726,14 +7724,14 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 	// TRENT_MONSTER
 	if (IsNoMove())
 	{
-		if (pkChr->IsPC()) // 쫓아가는 상대가 PC일 때
+		if (pkChr->IsPC()) // 耭튼 諛 PC 
 		{
 			// If i'm in a party. I must obey party leader's AI.
 			if (!GetParty() || !GetParty()->GetLeader() || GetParty()->GetLeader() == this)
 			{
-				if (get_dword_time() - m_pkMobInst->m_dwLastAttackedTime >= 15000) // 마지막으로 공격받은지 15초가 지났고
+				if (get_dword_time() - m_pkMobInst->m_dwLastAttackedTime >= 15000) //  赴 15歌 
 				{
-					// 마지막 맞은 곳으로 부터 50미터 이상 차이나면 포기하고 돌아간다.
+					//     50 鵑 犬 構 튼.
 					if (m_pkMobData->m_table.wAttackRange < DISTANCE_APPROX(pkChr->GetX() - GetX(), pkChr->GetY() - GetY()))
 						if (Return())
 							return true;
@@ -7747,14 +7745,14 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 	long x = pkChr->GetX();
 	long y = pkChr->GetY();
 
-	if (pkChr->IsPC()) // 쫓아가는 상대가 PC일 때
+	if (pkChr->IsPC()) // 耭튼 諛 PC 
 	{
 		// If i'm in a party. I must obey party leader's AI.
 		if (!GetParty() || !GetParty()->GetLeader() || GetParty()->GetLeader() == this)
 		{
-			if (get_dword_time() - m_pkMobInst->m_dwLastAttackedTime >= 15000) // 마지막으로 공격받은지 15초가 지났고
+			if (get_dword_time() - m_pkMobInst->m_dwLastAttackedTime >= 15000) //  赴 15歌 
 			{
-				// 마지막 맞은 곳으로 부터 50미터 이상 차이나면 포기하고 돌아간다.
+				//     50 鵑 犬 構 튼.
 				if (5000 < DISTANCE_APPROX(m_pkMobInst->m_posLastAttacked.x - GetX(), m_pkMobInst->m_posLastAttacked.y - GetY()))
 					if (Return())
 						return true;
@@ -7782,9 +7780,9 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 #endif
 		)
 	{
-		// 대상이 이동중이면 예측 이동을 한다
-		// 나와 상대방의 속도차와 거리로부터 만날 시간을 예상한 후
-		// 상대방이 그 시간까지 직선으로 이동한다고 가정하여 거기로 이동한다.
+		//  絹見  絹 磯
+		//   撻 타觀  챨  
+		//   챨  絹磯鳴 臼 킥 絹磯.
 		float rot = pkChr->GetRotation();
 		float rot_delta = GetDegreeDelta(rot, GetDegreeFromPositionXY(GetX(), GetY(), pkChr->GetX(), pkChr->GetY()));
 
@@ -7816,7 +7814,7 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 		}
 	}
 
-	// 가려는 위치를 바라봐야 한다.
+	//  치 帽 磯.
 	SetRotationToXY(x, y);
 
 	float fDist = DISTANCE_SQRT(x - GetX(), y - GetY());
@@ -7828,7 +7826,7 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 
 	if (IsChangeAttackPosition(pkChr) && GetMobRank() < MOB_RANK_BOSS)
 	{
-		// 상대방 주변 랜덤한 곳으로 이동
+		//  嶺   絹
 		SetChangeAttackPositionTime();
 
 		int retry = 16;
@@ -7853,23 +7851,23 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 				break;
 		}
 
-		//sys_log(0, "근처 어딘가로 이동 %s retry %d", GetName(), retry);
+		//sys_log(0, "처 漬》 絹 %s retry %d", GetName(), retry);
 		if (!Goto(dx, dy))
 			return false;
 	}
 	else
 	{
-		// 직선 따라가기
+		//  箚”
 		float fDistToGo = fDist - fMinDistance;
 		GetDeltaByDegree(GetRotation(), fDistToGo, &fx, &fy);
 
-		//sys_log(0, "직선으로 이동 %s", GetName());
+		//sys_log(0, " 絹 %s", GetName());
 		if (!Goto(GetX() + (int)fx, GetY() + (int)fy))
 			return false;
 	}
 
 	SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
-	//MonsterLog("쫓아가기; %s", pkChr->GetName());
+	//MonsterLog("耭튼; %s", pkChr->GetName());
 	return true;
 }
 
@@ -7893,30 +7891,30 @@ void CHARACTER::ReqSafeboxLoad(const char* pszPassword)
 #ifdef __GROWTH_PET_SYSTEM__
 	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("PET_STATLARINI_DEGISTIRME_UYARI"));
+		ChatPacket(CHAT_TYPE_INFO, "While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc.");
 		return;
 	}
 #endif
 	if (!*pszPassword || strlen(pszPassword) > SAFEBOX_PASSWORD_MAX_LEN)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 잘못된 암호를 입력하셨습니다."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창> 蔘 호 韜究決求."));
 		return;
 	}
 	else if (m_pkSafebox)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 창고가 이미 열려있습니다."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창> 창 譴 笭求."));
 		return;
 	}
 
 	int iPulse = thecore_pulse();
 	if (iPulse - GetSafeboxLoadTime() < PASSES_PER_SEC(10))
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 창고를 닫은지 10초 안에는 열 수 없습니다."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창> 창  10 효   求."));
 		return;
 	}
 	else if (GetDistanceFromSafeboxOpen() > 1000)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 거리가 멀어서 창고를 열 수 없습니다."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창> 타 羚底 창   求."));
 		return;
 	}
 	else if (m_bOpeningSafebox)
@@ -8320,9 +8318,9 @@ void CHARACTER::SetNowWalking(bool bWalkFlag)
 		if (IsNPC())
 		{
 			if (m_bNowWalking)
-				MonsterLog("걷는다");
+				MonsterLog("홱쨈");
 			else
-				MonsterLog("뛴다");
+				MonsterLog("渼");
 		}
 
 		//sys_log(0, "%s is now %s", GetName(), m_bNowWalking ? "walking." : "running.");
@@ -8398,7 +8396,7 @@ void CHARACTER::ResetPoint(int iLv)
 
 	ComputePoints();
 
-	// 회복
+	// 회
 	PointChange(POINT_HP, GetMaxHP() - GetHP());
 	PointChange(POINT_SP, GetMaxSP() - GetSP());
 
@@ -8421,31 +8419,31 @@ void CHARACTER::ResetExp()
 #if defined(__CONQUEROR_LEVEL__)
 void CHARACTER::ResetConquerorPoint(int iLv)
 {
-	PointChange(POINT_CONQUEROR_LEVEL, MINMAX(0, iLv, gPlayerMaxConquerorLevel) - GetConquerorLevel());
-
-	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
-	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
-
-	SetRealPoint(POINT_CONQUEROR_POINT, MINMAX(0, (iLv * 4) - 4, (4 * (gPlayerMaxConquerorLevel - 1))));
-	SetPoint(POINT_CONQUEROR_POINT, GetRealPoint(POINT_CONQUEROR_POINT));
-
-	SetRealPoint(POINT_SUNGMA_STR, 0);
-	SetPoint(POINT_SUNGMA_STR, GetRealPoint(POINT_SUNGMA_STR));
-
-	SetRealPoint(POINT_SUNGMA_HP, 0);
-	SetPoint(POINT_SUNGMA_HP, GetRealPoint(POINT_SUNGMA_HP));
-
-	SetRealPoint(POINT_SUNGMA_MOVE, 0);
-	SetPoint(POINT_SUNGMA_MOVE, GetRealPoint(POINT_SUNGMA_MOVE));
-
-	SetRealPoint(POINT_SUNGMA_IMMUNE, 0);
-	SetPoint(POINT_SUNGMA_IMMUNE, GetRealPoint(POINT_SUNGMA_IMMUNE));
-
-	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
-	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
-
-	ComputePoints();
-	PointsPacket();
+	PointChange(POINT_CONQUEROR_LEVEL, MINMAX(0, iLv, gPlayerMaxConquerorLevel) - GetConquerorLevel());
+
+	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
+	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
+
+	SetRealPoint(POINT_CONQUEROR_POINT, MINMAX(0, (iLv * 4) - 4, (4 * (gPlayerMaxConquerorLevel - 1))));
+	SetPoint(POINT_CONQUEROR_POINT, GetRealPoint(POINT_CONQUEROR_POINT));
+
+	SetRealPoint(POINT_SUNGMA_STR, 0);
+	SetPoint(POINT_SUNGMA_STR, GetRealPoint(POINT_SUNGMA_STR));
+
+	SetRealPoint(POINT_SUNGMA_HP, 0);
+	SetPoint(POINT_SUNGMA_HP, GetRealPoint(POINT_SUNGMA_HP));
+
+	SetRealPoint(POINT_SUNGMA_MOVE, 0);
+	SetPoint(POINT_SUNGMA_MOVE, GetRealPoint(POINT_SUNGMA_MOVE));
+
+	SetRealPoint(POINT_SUNGMA_IMMUNE, 0);
+	SetPoint(POINT_SUNGMA_IMMUNE, GetRealPoint(POINT_SUNGMA_IMMUNE));
+
+	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
+	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
+
+	ComputePoints();
+	PointsPacket();
 
 	LogManager::instance().CharLog(this, 0, "RESET_CONQUEROR_POINT", "");
 }
@@ -8617,7 +8615,7 @@ void CHARACTER::MonsterChat(BYTE bMonsterChatType)
 
 	std::string text = quest::ScriptToString(sbuf);
 	if (text.empty())
-		return;
+		return;
 
 	TPacketGCChat pack_chat;
 	pack_chat.header = HEADER_GC_CHAT;
@@ -8781,11 +8779,11 @@ void CHARACTER::SetPolymorph(DWORD dwRaceNum, bool bMaintainStat)
 		PointChange(POINT_HT, 0);
 	}
 
-	// 폴리모프 상태에서 죽는 경우, 폴리모프가 풀리게 되는데
-	// 폴리 모프 전후로 valid combo interval이 다르기 때문에
-	// Combo 핵 또는 Hacker로 인식하는 경우가 있다.
-	// 따라서 폴리모프를 풀거나 폴리모프 하게 되면,
-	// valid combo interval을 reset한다.
+	//  쩔 榴 ,  풀 풔쨉
+	//   캠 valid combo interval 摸 
+	// Combo  풔 Hacker 館求 李 獵.
+	//   풀킬  構 퓔,
+	// valid combo interval reset磯.
 	SetValidComboInterval(0);
 	SetComboSequence(0);
 
@@ -8886,7 +8884,7 @@ void CHARACTER::DetermineDropMetinStone()
 				else
 				{
 					iGradePct -= iLevelGradePortion;
-					m_dwDropMetinStone += 100; // 돌 +a -> +(a+1)이 될때마다 100씩 증가
+					m_dwDropMetinStone += 100; //  +a -> +(a+1)  100 
 				}
 			}
 		}
@@ -8910,11 +8908,11 @@ void CHARACTER::SendEquipment(LPCHARACTER pChar)
 #if defined(__CHANGE_LOOK_SYSTEM__)
 			Packet.Equips[bSlotIdx].dwTransmutationVnum = pItem->GetTransmutationVnum();
 #endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			thecore_memcpy(&Packet.Equips[bSlotIdx].RefineElement, pItem->GetRefineElement(), sizeof(Packet.Equips[bSlotIdx].RefineElement));
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			thecore_memcpy(&Packet.Equips[bSlotIdx].RefineElement, pItem->GetRefineElement(), sizeof(Packet.Equips[bSlotIdx].RefineElement));
 #endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			thecore_memcpy(Packet.Equips[bSlotIdx].aApplyRandom, pItem->GetRandomApplies(), sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
+#if defined(__ITEM_APPLY_RANDOM__)
+			thecore_memcpy(Packet.Equips[bSlotIdx].aApplyRandom, pItem->GetRandomApplies(), sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
 #endif
 #if defined(__SET_ITEM__)
 			Packet.Equips[bSlotIdx].bSetValue = pItem->GetItemSetValue();
@@ -8924,16 +8922,16 @@ void CHARACTER::SendEquipment(LPCHARACTER pChar)
 		{
 			Packet.Equips[bSlotIdx].dwVnum = 0;
 			Packet.Equips[bSlotIdx].bCount = 0;
-			memset(&Packet.Equips[bSlotIdx].alSockets, 0, sizeof(Packet.Equips[bSlotIdx].alSockets));
+			memset(&Packet.Equips[bSlotIdx].alSockets, 0, sizeof(Packet.Equips[bSlotIdx].alSockets));
 			memset(&Packet.Equips[bSlotIdx].aAttr, 0, sizeof(Packet.Equips[bSlotIdx].aAttr));
 #if defined(__CHANGE_LOOK_SYSTEM__)
 			Packet.Equips[bSlotIdx].dwTransmutationVnum = 0;
 #endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			memset(&Packet.Equips[bSlotIdx].RefineElement, 0, sizeof(Packet.Equips[bSlotIdx].RefineElement));
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			memset(&Packet.Equips[bSlotIdx].RefineElement, 0, sizeof(Packet.Equips[bSlotIdx].RefineElement));
 #endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			memset(&Packet.Equips[bSlotIdx].aApplyRandom, 0, sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
+#if defined(__ITEM_APPLY_RANDOM__)
+			memset(&Packet.Equips[bSlotIdx].aApplyRandom, 0, sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
 #endif
 #if defined(__SET_ITEM__)
 			Packet.Equips[bSlotIdx].bSetValue = 0;
@@ -8986,9 +8984,9 @@ void CHARACTER::MountVnum(DWORD vnum)
 	m_posDest.x = m_posStart.x = GetX();
 	m_posDest.y = m_posStart.y = GetY();
 
-	// NOTE : Mount한다고 해서 Client Side의 객체를 삭제하진 않는다.
-	// 그리고 서버Side에서 탔을때 위치 이동은 하지 않는다. 왜냐하면 Client Side에서 Coliision Adjust를 할수 있는데
-	// 객체를 소멸시켰다가 서버위치로 이동시키면 이때 collision check를 하지는 않으므로 배경에 끼거나 뚫고 나가는 문제가 존재한다.
+	// NOTE : Mount磯鳴 漫 Client Side 체  苛쨈.
+	// 琉 Side  치 絹  苛쨈. 簾玖 Client Side Coliision Adjust 寗 獵쨉
+	// 체 恬榴鳴 치 絹키 繭 collision check  퓐 嚥 킬 卵   磯.
 	m_posDest.x = m_posStart.x = GetX();
 	m_posDest.y = m_posStart.y = GetY();
 #if defined(__MOUNT_ENTITY_REFRESH__)
@@ -9002,7 +9000,7 @@ void CHARACTER::MountVnum(DWORD vnum)
 	{
 		LPENTITY entity = (it++)->first;
 
-		// Mount한다고 해서 Client Side의 객체를 삭제하진 않는다.
+		// Mount磯鳴 漫 Client Side 체  苛쨈.
 #if defined(__MOUNT_ENTITY_REFRESH__)
 		EncodeRemovePacket(entity);
 		if (!m_bIsObserver)
@@ -9246,45 +9244,45 @@ bool CHARACTER::WarpToPID(DWORD dwPID, bool bWarpForce)
 			}
 			else
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 있는 곳으로 워프할 수 없습니다."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 獵    求."));
 				return false;
 			}
 		}
 		else
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 있는 곳으로 워프할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 獵    求."));
 			return false;
 		}
 	}
 	else
 	{
-		// 다른 서버에 로그인된 사람이 있음 -> 메시지 보내 좌표를 받아오자
-		// 1. A.pid, B.pid 를 뿌림
-		// 2. B.pid를 가진 서버가 뿌린서버에게 A.pid, 좌표 를 보냄
-		// 3. 워프
+		// 摸  慣琯   -> 聘  표 騁틸
+		// 1. A.pid, B.pid  祺
+		// 2. B.pid   祺 A.pid, 표  
+		// 3. 
 		CCI* pcci = P2P_MANAGER::instance().FindByPID(dwPID);
 
 		if (!pcci)
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 온라인 상태가 아닙니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 쨋 째 틈爛求."));
 			return false;
 		}
 
 		if ((pcci->bChannel != g_bChannel) && !bWarpForce)
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 %d 채널에 있습니다. (현재 채널 %d)", pcci->bChannel, g_bChannel));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" %d 채恝 笭求. ( 채 %d)", pcci->bChannel, g_bChannel));
 			return false;
 		}
 		else if (false == IS_SUMMONABLE_ZONE(pcci->lMapIndex))
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 있는 곳으로 워프할 수 없습니다."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 獵    求."));
 			return false;
 		}
 		else
 		{
 			if (!CAN_ENTER_ZONE(this, pcci->lMapIndex))
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 있는 곳으로 워프할 수 없습니다."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 獵    求."));
 				return false;
 			}
 
@@ -9322,7 +9320,7 @@ int CHARACTER::ComputeRefineFee(int iCost, int iMultiply) const
 		if (pGuild == GetGuild())
 			return iCost * iMultiply * 9 / 10;
 
-		// 다른 제국 사람이 시도하는 경우 추가로 3배 더
+		// 摸   천求  煞 3 
 		LPCHARACTER chRefineNPC = CHARACTER_MANAGER::instance().Find(m_dwRefineNPCVID);
 		if (chRefineNPC && chRefineNPC->GetEmpire() != GetEmpire())
 			return iCost * iMultiply * 3;
@@ -9342,7 +9340,7 @@ void CHARACTER::PayRefineFee(int iTotalMoney)
 
 	if (pGuild)
 	{
-		// 자기 길드이면 iTotalMoney에 이미 10%가 제외되어있다
+		// 未 見 iTotalMoney 譴 10% 昞퓸獵
 		if (pGuild != GetGuild())
 		{
 			pGuild->RequestDepositMoney(this, iFee);
@@ -9446,20 +9444,116 @@ bool CHARACTER::PreventTradeWindow(int flags, bool except) const
 #endif
 
 #ifdef __GROWTH_PET_SYSTEM__
-	if (except && !(PET_WINDOW_ATTR_CHANGE & flags) || !except && (PET_WINDOW_ATTR_CHANGE & flags))
-		if (GetPetWindowType())
-			return true;
+bool CHARACTER::SetGrowthPet(LPGROWTH_PET pkPet)
+{
+	auto it = m_growthPetMap.find(pkPet->GetPetID());
 
-	if (except && !(PET_WINDOW_PRIMIUM_FEEDSTUFF & flags) || !except && (PET_WINDOW_PRIMIUM_FEEDSTUFF & flags))
-		if (GetPetWindowType())
-			return true;
+	if (it != m_growthPetMap.end())
+		m_growthPetMap.erase(it);
+
+	if (pkPet->GetOwner() != this)
+		pkPet->SetOwner(this);
+
+	m_growthPetMap.emplace(pkPet->GetPetID(), pkPet);
+
+	TPacketGCPetSet packet;
+	packet.header = HEADER_GC_PET_SET;
+	packet.dwID = pkPet->GetPetID();
+	packet.dwSummonItemVnum = pkPet->GetSummonItemVnum();
+
+	strlcpy(packet.szName, pkPet->GetPetName().c_str(), sizeof(packet.szName));
+	thecore_memcpy(packet.aSkill, pkPet->GetPetSkill(), sizeof(packet.aSkill));
+
+	for (int i = 0; i < POINT_UPBRINGING_MAX_NUM; i++)
+		packet.dwPoints[i] = pkPet->GetPetPoint(i);
+
+	if(GetDesc())
+		GetDesc()->Packet(&packet, sizeof(packet));
+
+	return true;
+}
+
+bool CHARACTER::DeleteGrowthPet(DWORD dwID)
+{
+	auto it = m_growthPetMap.find(dwID);
+
+	if (it == m_growthPetMap.end())
+		return false;
+
+	m_growthPetMap.erase(it);
+
+	TPacketGCPetDelete packet;
+	packet.header = HEADER_GC_PET_DEL;
+	packet.dwID = dwID;
+
+	if (GetDesc())
+		GetDesc()->Packet(&packet, sizeof(packet));
+
+	return true;
+}
+
+LPGROWTH_PET CHARACTER::GetGrowthPet(DWORD dwID)
+{
+	auto it = m_growthPetMap.find(dwID);
+
+	if (it != m_growthPetMap.end())
+		return it->second;
+
+	return nullptr;
+}
+
+void CHARACTER::ClearGrowthPet()
+{
+	if (m_activeGrowthPet)
+		m_activeGrowthPet->Unsummon();
+
+	if (m_growthPetMap.size())
+	{
+		auto it = m_growthPetMap.begin();
+
+		while (it != m_growthPetMap.end())
+		{
+			LPGROWTH_PET pPet = it->second;
+
+			pPet->Save();
+
+			// Increase the iterator before deleting pet pointer
+			++it;
+
+			CGrowthPetManager::Instance().DeleteGrowthPet(pPet->GetPetID());
+		}
+
+		m_growthPetMap.clear();
+	}
+}
+
+void CHARACTER::SendDeadPetMessage()
+{
+	for (auto kv : m_growthPetMap)
+	{
+		LPGROWTH_PET pPet = kv.second;
+
+
+		if (pPet->GetState() != STATE_UPBRINGING)
+			continue;
+
+		if (pPet->GetPetPoint(POINT_UPBRINGING_DURATION) < get_global_time())
+		{
+			TItemTable* pProto = ITEM_MANAGER::instance().GetTable(pPet->GetSummonItemVnum());
+			if (!pProto)
+				continue;
+
+			//ChatPacket(CHAT_TYPE_INFO, "%s is currently fast asleep.", pProto->szLocaleName);
+		}
+	}
+}
 #endif
 
 	return false;
 }
 // END_PREVENT_TRADE_WINDOW
 
-// Hack 방지를 위한 체크.
+// Hack   체크.
 bool CHARACTER::IsHack(bool bSendMsg, bool bCheckShopOwner, int limittime)
 {
 	const int iPulse = thecore_pulse();
@@ -9467,24 +9561,24 @@ bool CHARACTER::IsHack(bool bSendMsg, bool bCheckShopOwner, int limittime)
 	if (test_server)
 		bSendMsg = true;
 
-	// 창고 연후 체크
+	// 창  체크
 	if (iPulse - GetSafeboxLoadTime() < PASSES_PER_SEC(limittime))
 	{
 		if (bSendMsg)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("창고를 연후 %d초 이내에는 다른곳으로 이동할수 없습니다.", limittime));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("창  %d 犬 摸 絹寗 求.", limittime));
 
 		if (test_server)
 			ChatPacket(CHAT_TYPE_INFO, "[TestOnly]Pulse %d LoadTime %d PASS %d", iPulse, GetSafeboxLoadTime(), PASSES_PER_SEC(limittime));
 		return true;
 	}
 
-	// 거래관련 창 체크
+	// 킹 창 체크
 	if (bCheckShopOwner)
 	{
 		if (PreventTradeWindow(WND_ALL))
 		{
 			if (bSendMsg)
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("거래창,창고 등을 연 상태에서는 다른곳으로 이동,종료 할수 없습니다"));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("킹창,창   쩔 摸 絹, 寗 求"));
 
 			return true;
 		}
@@ -9494,18 +9588,18 @@ bool CHARACTER::IsHack(bool bSendMsg, bool bCheckShopOwner, int limittime)
 		if (PreventTradeWindow(WND_SHOPOWNER, true/*except*/))
 		{
 			if (bSendMsg)
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("거래창,창고 등을 연 상태에서는 다른곳으로 이동,종료 할수 없습니다"));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("킹창,창   쩔 摸 絹, 寗 求"));
 
 			return true;
 		}
 	}
 
 	// PREVENT_PORTAL_AFTER_EXCHANGE
-	// 교환 후 시간체크
+	// 환  챨체크
 	if (iPulse - GetExchangeTime() < PASSES_PER_SEC(limittime))
 	{
 		if (bSendMsg)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("거래 후 %d초 이내에는 다른지역으로 이동 할 수 없습니다.", limittime));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("킹  %d 犬 摸 絹   求.", limittime));
 		return true;
 	}
 	// END_PREVENT_PORTAL_AFTER_EXCHANGE
@@ -9514,14 +9608,14 @@ bool CHARACTER::IsHack(bool bSendMsg, bool bCheckShopOwner, int limittime)
 	if (iPulse - GetMyShopTime() < PASSES_PER_SEC(limittime))
 	{
 		if (bSendMsg)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("거래 후 %d초 이내에는 다른지역으로 이동 할 수 없습니다.", limittime));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("킹  %d 犬 摸 絹   求.", limittime));
 		return true;
 	}
 
 	if (iPulse - GetRefineTime() < PASSES_PER_SEC(limittime))
 	{
 		if (bSendMsg)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 개량후 %d초 이내에는 귀환부,귀환기억부를 사용할 수 없습니다.", limittime));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d 犬 환,환罐   求.", limittime));
 		return true;
 	}
 
@@ -9643,7 +9737,7 @@ bool CHARACTER::IsSiegeNPC() const
 //------------------------------------------------
 void CHARACTER::UpdateDepositPulse()
 {
-	m_deposit_pulse = thecore_pulse() + PASSES_PER_SEC(60 * 5); // 5분
+	m_deposit_pulse = thecore_pulse() + PASSES_PER_SEC(60 * 5); // 5
 }
 
 bool CHARACTER::CanDeposit() const
@@ -9849,7 +9943,7 @@ void CHARACTER::StartCheckSpeedHackEvent()
 
 	info->ch = this;
 
-	m_pkCheckSpeedHackEvent = event_create(check_speedhack_event, info, PASSES_PER_SEC(60)); // 1분
+	m_pkCheckSpeedHackEvent = event_create(check_speedhack_event, info, PASSES_PER_SEC(60)); // 1
 }
 
 void CHARACTER::GoHome()
@@ -10018,7 +10112,7 @@ DWORD CHARACTER::GetSkipComboAttackByTime() const
 	return m_dwSkipComboAttackByTime;
 }
 
-// 말이나 다른것을 타고 있나?
+// 犬 摸 타 簾?
 bool CHARACTER::IsRiding() const
 {
 	return IsHorseRiding() || GetMountVnum();
@@ -10672,17 +10766,17 @@ EVENTFUNC(hit_buff_event)
 	const long buff_value = 30;
 	std::unordered_map<WORD, WORD> map_buff_point
 	{
-		{ POINT_HIT_BUFF_ENCHANT_FIRE, POINT_ENCHANT_FIRE },
-		{ POINT_HIT_BUFF_ENCHANT_ICE, POINT_ENCHANT_ICE },
-		{ POINT_HIT_BUFF_ENCHANT_ELEC, POINT_ENCHANT_ELECT },
-		{ POINT_HIT_BUFF_ENCHANT_WIND, POINT_ENCHANT_WIND },
-		{ POINT_HIT_BUFF_ENCHANT_DARK, POINT_ENCHANT_DARK },
-		{ POINT_HIT_BUFF_ENCHANT_EARTH, POINT_ENCHANT_EARTH },
-		{ POINT_HIT_BUFF_RESIST_FIRE, POINT_ENCHANT_FIRE },
-		{ POINT_HIT_BUFF_RESIST_ICE, POINT_RESIST_ICE },
-		{ POINT_HIT_BUFF_RESIST_ELEC, POINT_RESIST_ELEC },
-		{ POINT_HIT_BUFF_RESIST_WIND, POINT_RESIST_WIND },
-		{ POINT_HIT_BUFF_RESIST_DARK, POINT_RESIST_DARK },
+		{ POINT_HIT_BUFF_ENCHANT_FIRE, POINT_ENCHANT_FIRE },
+		{ POINT_HIT_BUFF_ENCHANT_ICE, POINT_ENCHANT_ICE },
+		{ POINT_HIT_BUFF_ENCHANT_ELEC, POINT_ENCHANT_ELECT },
+		{ POINT_HIT_BUFF_ENCHANT_WIND, POINT_ENCHANT_WIND },
+		{ POINT_HIT_BUFF_ENCHANT_DARK, POINT_ENCHANT_DARK },
+		{ POINT_HIT_BUFF_ENCHANT_EARTH, POINT_ENCHANT_EARTH },
+		{ POINT_HIT_BUFF_RESIST_FIRE, POINT_ENCHANT_FIRE },
+		{ POINT_HIT_BUFF_RESIST_ICE, POINT_RESIST_ICE },
+		{ POINT_HIT_BUFF_RESIST_ELEC, POINT_RESIST_ELEC },
+		{ POINT_HIT_BUFF_RESIST_WIND, POINT_RESIST_WIND },
+		{ POINT_HIT_BUFF_RESIST_DARK, POINT_RESIST_DARK },
 		{ POINT_HIT_BUFF_RESIST_EARTH, POINT_RESIST_EARTH },
 
 		{ POINT_HIT_BUFF_SUNGMA_STR, POINT_SUNGMA_STR },
@@ -10781,7 +10875,7 @@ void CHARACTER::SetEventRaceNum(DWORD dwRaceNum)
 
 	sys_log(0, "EVENT_RACE: %s race %u ", GetName(), dwRaceNum);
 
-	SET_BIT(m_bAddChrState, ADD_CHARACTER_STATE_SPAWN);
+	SET_BIT(m_bAddChrState, ADD_CHARACTER_STATE_SPAWN);
 	m_afAffectFlag.Set(AFF_SPAWN);
 
 	ViewReencode();
@@ -10792,35 +10886,35 @@ void CHARACTER::SetEventRaceNum(DWORD dwRaceNum)
 }
 #endif
 
-#if defined(__HIDE_COSTUME_SYSTEM__)
-void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bSave)
-{
-	switch (bCostumeSubType)
-	{
-		case COSTUME_BODY:
-		case COSTUME_HAIR:
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case COSTUME_ACCE:
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case COSTUME_WEAPON:
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case COSTUME_AURA:
-#endif
-			break;
-
-		default:
-		{
-			sys_err("CHARACTER::SetHiddenCostumePart: %s cannot hide unknown costume sub type %u",
-				GetName(), bCostumeSubType);
-			return;
-		}
-	}
-
+#if defined(__HIDE_COSTUME_SYSTEM__)
+void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bSave)
+{
+	switch (bCostumeSubType)
+	{
+		case COSTUME_BODY:
+		case COSTUME_HAIR:
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case COSTUME_ACCE:
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case COSTUME_WEAPON:
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case COSTUME_AURA:
+#endif
+			break;
+
+		default:
+		{
+			sys_err("CHARACTER::SetHiddenCostumePart: %s cannot hide unknown costume sub type %u",
+				GetName(), bCostumeSubType);
+			return;
+		}
+	}
+
 	if (IsDead() || IsWarping())
-		return;
-
+		return;
+
 	bool bAttacking = (get_dword_time() - GetLastAttackTime()) < 1500;
 	bool bMoving = (get_dword_time() - GetLastMoveTime()) < 1500;
 	bool bDelayedCMD = false;
@@ -10829,8 +10923,8 @@ void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bS
 	{
 		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have to stand still to hide your costume."));
 		return;
-	}
-
+	}
+
 	int iPulse = thecore_pulse();
 	if (iPulse - m_dwHideCostumePulse < passes_per_sec * 3)
 	{
@@ -10838,16 +10932,16 @@ void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bS
 		return;
 	}
 
-	m_dwHideCostumePulse = thecore_pulse();
+	m_dwHideCostumePulse = thecore_pulse();
 	m_bHiddenCostumePart[bCostumeSubType] = bHidden;
 
 	if (bSave)
 		SetQuestFlag(HiddenCostumePartMap[bCostumeSubType], bHidden ? 1 : 0);
 
-	UpdatePacket();
-
-	ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", bCostumeSubType, bHidden ? 1 : 0);
-}
+	UpdatePacket();
+
+	ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", bCostumeSubType, bHidden ? 1 : 0);
+}
 
 bool CHARACTER::CheckComboFlood(DWORD dwTime)
 {
@@ -10873,63 +10967,63 @@ bool CHARACTER::CheckComboFlood(DWORD dwTime)
 
 	return false;
 }
-
-bool CHARACTER::GetHiddenCostumeByPart(BYTE bPartPos) const
-{
-	switch (bPartPos)
-	{
-		case PART_MAIN:
-			if (m_bHiddenCostumePart[COSTUME_BODY] && GetWear(WEAR_COSTUME_BODY))
-				return true;
-			break;
-
-		case PART_HAIR:
-			if (m_bHiddenCostumePart[COSTUME_HAIR] && GetWear(WEAR_COSTUME_HAIR))
-				return true;
-			break;
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case PART_ACCE:
-			if (m_bHiddenCostumePart[COSTUME_ACCE] && GetWear(WEAR_COSTUME_ACCE))
-				return true;
-			break;
-#endif
-
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-		case PART_WEAPON:
-			if (m_bHiddenCostumePart[COSTUME_WEAPON] && GetWear(WEAR_COSTUME_WEAPON))
-				return true;
-			break;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-		case PART_AURA:
-			if (m_bHiddenCostumePart[COSTUME_AURA] && GetWear(WEAR_COSTUME_AURA))
-				return true;
-			break;
-#endif
-
-		default:
-			return false;
-	}
-
-	return false;
-}
-
-void CHARACTER::SetHiddenCostumeParts()
-{
-	bool bHidden = false;
-	for (const THiddenCostumePartMap::value_type& it : HiddenCostumePartMap)
-	{
-		bHidden = (GetQuestFlag(it.second) != 0 ? 1 : 0);
-		m_bHiddenCostumePart[it.first] = bHidden;
-
-		ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", it.first, static_cast<BYTE>(bHidden));
-	}
-}
-#endif
-
-#if defined(__MYSHOP_DECO__)
+
+bool CHARACTER::GetHiddenCostumeByPart(BYTE bPartPos) const
+{
+	switch (bPartPos)
+	{
+		case PART_MAIN:
+			if (m_bHiddenCostumePart[COSTUME_BODY] && GetWear(WEAR_COSTUME_BODY))
+				return true;
+			break;
+
+		case PART_HAIR:
+			if (m_bHiddenCostumePart[COSTUME_HAIR] && GetWear(WEAR_COSTUME_HAIR))
+				return true;
+			break;
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case PART_ACCE:
+			if (m_bHiddenCostumePart[COSTUME_ACCE] && GetWear(WEAR_COSTUME_ACCE))
+				return true;
+			break;
+#endif
+
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+		case PART_WEAPON:
+			if (m_bHiddenCostumePart[COSTUME_WEAPON] && GetWear(WEAR_COSTUME_WEAPON))
+				return true;
+			break;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+		case PART_AURA:
+			if (m_bHiddenCostumePart[COSTUME_AURA] && GetWear(WEAR_COSTUME_AURA))
+				return true;
+			break;
+#endif
+
+		default:
+			return false;
+	}
+
+	return false;
+}
+
+void CHARACTER::SetHiddenCostumeParts()
+{
+	bool bHidden = false;
+	for (const THiddenCostumePartMap::value_type& it : HiddenCostumePartMap)
+	{
+		bHidden = (GetQuestFlag(it.second) != 0 ? 1 : 0);
+		m_bHiddenCostumePart[it.first] = bHidden;
+
+		ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", it.first, static_cast<BYTE>(bHidden));
+	}
+}
+#endif
+
+#if defined(__MYSHOP_DECO__)
 void CHARACTER::OpenPrivateShop(BYTE bTabCount, bool bIsCashItem)
 {
 	if (bTabCount > MYSHOP_MAX_TABS)
@@ -10959,172 +11053,172 @@ void CHARACTER::OpenPrivateShop(BYTE bTabCount, bool bIsCashItem)
 		GetDesc()->BufferedPacket(&Packet, sizeof(TPacketGCShop));
 		GetDesc()->Packet(&Packet2, sizeof(TPacketGCMyPrivShopOpen));
 	}
-}
-#endif
-
-#if defined(__LEFT_SEAT__)
-EVENTFUNC(left_seat_wait_timer_event)
-{
-	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-	if (info == NULL)
-	{
-		sys_err("left_seat_wait_timer_event> <Factor> Null pointer");
-		return 0;
-	}
-
+}
+#endif
+
+#if defined(__LEFT_SEAT__)
+EVENTFUNC(left_seat_wait_timer_event)
+{
+	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+	if (info == NULL)
+	{
+		sys_err("left_seat_wait_timer_event> <Factor> Null pointer");
+		return 0;
+	}
+
 	LPCHARACTER ch = info->ch;
 	if (ch == NULL) // <Factor>
-		return 0;
-
-	if (ch->GetMyShop())
-		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
-
-	if (ch->IsRunningQuest())
-		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
-
-	if (get_dword_time() - ch->GetLastRequestTime() > 1000 * ch->GetLeftSeatWaitTime())
-	{
-		if (ch->LeftSeat() == false)
-		{
-			ch->SetLeftSeat(true);
-
-			if (ch->GetLeftSeatLogoutTime())
-				ch->RestartLeftSeatLogoutTimer();
-		}
-	}
-
-	return PASSES_PER_SEC(LEFT_SEAT_PULSE);
-}
-
-void CHARACTER::RestartLeftSeatWaitTimer()
-{
-	if (m_pLeftSeatWaitTimerEvent)
-		event_cancel(&m_pLeftSeatWaitTimerEvent);
-
-	char_event_info* info = AllocEventInfo<char_event_info>();
-	info->ch = this;
-	m_pLeftSeatWaitTimerEvent = event_create(left_seat_wait_timer_event, info, PASSES_PER_SEC(LEFT_SEAT_PULSE));
-}
-
-void CHARACTER::SetLeftSeatWaitTime(BYTE bIndex)
-{
-	DWORD dwTime = 0;
-	switch (bIndex)
-	{
-		case LEFT_SEAT_TIME_10_MIN:
-			dwTime = 60 * 10;
-			break;
-		case LEFT_SEAT_TIME_30_MIN:
-			dwTime = 60 * 30;
-			break;
-		case LEFT_SEAT_TIME_90_MIN:
-			dwTime = 60 * 90;
-			break;
-		default:
-			dwTime = 60 * 10;
-			break;
-	}
-
-	//if (test_server)
-	//	dwTime = 10;
-
-	m_dwLeftSeatWaitTime = dwTime;
-	RestartLeftSeatWaitTimer();
-}
-
-EVENTFUNC(left_seat_logout_timer_event)
-{
-	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-	if (info == NULL)
-	{
-		sys_err("left_seat_logout_timer_event> <Factor> Null pointer");
-		return 0;
-	}
-
+		return 0;
+
+	if (ch->GetMyShop())
+		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
+
+	if (ch->IsRunningQuest())
+		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
+
+	if (get_dword_time() - ch->GetLastRequestTime() > 1000 * ch->GetLeftSeatWaitTime())
+	{
+		if (ch->LeftSeat() == false)
+		{
+			ch->SetLeftSeat(true);
+
+			if (ch->GetLeftSeatLogoutTime())
+				ch->RestartLeftSeatLogoutTimer();
+		}
+	}
+
+	return PASSES_PER_SEC(LEFT_SEAT_PULSE);
+}
+
+void CHARACTER::RestartLeftSeatWaitTimer()
+{
+	if (m_pLeftSeatWaitTimerEvent)
+		event_cancel(&m_pLeftSeatWaitTimerEvent);
+
+	char_event_info* info = AllocEventInfo<char_event_info>();
+	info->ch = this;
+	m_pLeftSeatWaitTimerEvent = event_create(left_seat_wait_timer_event, info, PASSES_PER_SEC(LEFT_SEAT_PULSE));
+}
+
+void CHARACTER::SetLeftSeatWaitTime(BYTE bIndex)
+{
+	DWORD dwTime = 0;
+	switch (bIndex)
+	{
+		case LEFT_SEAT_TIME_10_MIN:
+			dwTime = 60 * 10;
+			break;
+		case LEFT_SEAT_TIME_30_MIN:
+			dwTime = 60 * 30;
+			break;
+		case LEFT_SEAT_TIME_90_MIN:
+			dwTime = 60 * 90;
+			break;
+		default:
+			dwTime = 60 * 10;
+			break;
+	}
+
+	//if (test_server)
+	//	dwTime = 10;
+
+	m_dwLeftSeatWaitTime = dwTime;
+	RestartLeftSeatWaitTimer();
+}
+
+EVENTFUNC(left_seat_logout_timer_event)
+{
+	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+	if (info == NULL)
+	{
+		sys_err("left_seat_logout_timer_event> <Factor> Null pointer");
+		return 0;
+	}
+
 	LPCHARACTER ch = info->ch;
 	if (ch == NULL) // <Factor>
-		return 0;
-
-	LPDESC d = ch->GetDesc();
-	if (ch->LeftSeat())
+		return 0;
+
+	LPDESC d = ch->GetDesc();
+	if (ch->LeftSeat())
 	{
 		ch->Disconnect("LEFT_SEAT");
 		if (d)
-			d->SetPhase(PHASE_CLOSE);
-	}
-
-	return 0;
-}
-
-void CHARACTER::RestartLeftSeatLogoutTimer()
-{
-	if (m_pLeftSeatLogoutTimerEvent)
-		event_cancel(&m_pLeftSeatLogoutTimerEvent);
-
-	const DWORD dwTime = GetLeftSeatLogoutTime();
-	if (dwTime == 0)
-		return;
-
-	char_event_info* info = AllocEventInfo<char_event_info>();
-	info->ch = this;
-	m_pLeftSeatLogoutTimerEvent = event_create(left_seat_logout_timer_event, info, PASSES_PER_SEC(dwTime));
-}
-
-void CHARACTER::SetLeftSeatLogoutTime(BYTE bIndex)
-{
-	DWORD dwTime = 0;
-	switch (bIndex)
-	{
-		case LEFT_SEAT_LOGOUT_TIME_30_MIN:
-			dwTime = 60 * 30;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_60_MIN:
-			dwTime = 60 * 60;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_120_MIN:
-			dwTime = 60 * 120;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_180_MIN:
-			dwTime = 60 * 180;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_OFF:
-			dwTime = 0;
-			break;
-		default:
-			dwTime = 60 * 30;
-			break;
-	}
-
-	//if (test_server)
-	//	dwTime = 10;
-
-	m_dwLeftSeatLogoutTime = dwTime;
-}
-
-void CHARACTER::DisableLeftSeatLogOutState(bool bClosePopup)
-{
-	if (bClosePopup)
-		ChatPacket(CHAT_TYPE_COMMAND, "CloseLeftSeatDialog");
-
-	if (m_pLeftSeatLogoutTimerEvent)
-		event_cancel(&m_pLeftSeatLogoutTimerEvent);
-
-	m_dwLastRequestTime = get_dword_time();
-
-	SetLeftSeat(false);
-	RestartLeftSeatWaitTimer();
-}
-
-void CHARACTER::SetLeftSeat(bool bLeftSeat)
-{
-	if (bLeftSeat)
-		ChatPacket(CHAT_TYPE_COMMAND, "OpenLeftSeatDialog");
-
-	m_bLeftSeat = bLeftSeat;
-	UpdatePacket();
-}
-#endif
-
+			d->SetPhase(PHASE_CLOSE);
+	}
+
+	return 0;
+}
+
+void CHARACTER::RestartLeftSeatLogoutTimer()
+{
+	if (m_pLeftSeatLogoutTimerEvent)
+		event_cancel(&m_pLeftSeatLogoutTimerEvent);
+
+	const DWORD dwTime = GetLeftSeatLogoutTime();
+	if (dwTime == 0)
+		return;
+
+	char_event_info* info = AllocEventInfo<char_event_info>();
+	info->ch = this;
+	m_pLeftSeatLogoutTimerEvent = event_create(left_seat_logout_timer_event, info, PASSES_PER_SEC(dwTime));
+}
+
+void CHARACTER::SetLeftSeatLogoutTime(BYTE bIndex)
+{
+	DWORD dwTime = 0;
+	switch (bIndex)
+	{
+		case LEFT_SEAT_LOGOUT_TIME_30_MIN:
+			dwTime = 60 * 30;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_60_MIN:
+			dwTime = 60 * 60;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_120_MIN:
+			dwTime = 60 * 120;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_180_MIN:
+			dwTime = 60 * 180;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_OFF:
+			dwTime = 0;
+			break;
+		default:
+			dwTime = 60 * 30;
+			break;
+	}
+
+	//if (test_server)
+	//	dwTime = 10;
+
+	m_dwLeftSeatLogoutTime = dwTime;
+}
+
+void CHARACTER::DisableLeftSeatLogOutState(bool bClosePopup)
+{
+	if (bClosePopup)
+		ChatPacket(CHAT_TYPE_COMMAND, "CloseLeftSeatDialog");
+
+	if (m_pLeftSeatLogoutTimerEvent)
+		event_cancel(&m_pLeftSeatLogoutTimerEvent);
+
+	m_dwLastRequestTime = get_dword_time();
+
+	SetLeftSeat(false);
+	RestartLeftSeatWaitTimer();
+}
+
+void CHARACTER::SetLeftSeat(bool bLeftSeat)
+{
+	if (bLeftSeat)
+		ChatPacket(CHAT_TYPE_COMMAND, "OpenLeftSeatDialog");
+
+	m_bLeftSeat = bLeftSeat;
+	UpdatePacket();
+}
+#endif
+
 #if defined(__ELEMENTAL_DUNGEON__)
 EVENTFUNC(elemental_curse_event)
 {
@@ -11144,7 +11238,7 @@ EVENTFUNC(elemental_curse_event)
 
 	// NOTE : Increase the hp reduction level every 200.000 damage.
 	int iReductionLevel = MINMAX(1, dwAccumulatedDamage / 200000, 10);
-	int iDropHP = static_cast<int>(ch->GetMaxHP() * (fReductionPct[iReductionLevel - 1] / 100.0f));
+	int iDropHP = static_cast<int>(ch->GetMaxHP() * (fReductionPct[iReductionLevel - 1] / 100.0f));
 
 	CAffect* pAffect = ch->FindAffect(AFFECT_CURSE_OF_ELEMENTAL);
 	if (pAffect == NULL || iReductionLevel > pAffect->lApplyValue)
diff --git a/server/server/home/metin2/Source/Server/game/src/char.h b/server/server/home/metin2/Source/Server/game/src/char.h
index fc6097a..5b90aa0 100644
--- a/server/server/home/metin2/Source/Server/game/src/char.h
+++ b/server/server/home/metin2/Source/Server/game/src/char.h
@@ -1,3309 +1,3308 @@
-#ifndef __INC_CHAR_H__
-#define __INC_CHAR_H__
-
-#include "../../common/stl.h"
-#include "entity.h"
-#include "FSM.h"
-#include "horse_rider.h"
-#include "vid.h"
-#include "constants.h"
-#include "affect.h"
-#include "affect_flag.h"
-#include "cube.h"
-#include "mining.h"
-#include "packet.h"
-
-#if defined(__LUCKY_BOX__)
-#	include "item_manager.h"
-#endif
-#if defined(__CHANGE_LOOK_SYSTEM__)
-#	include "changelook.h"
-#endif
-#if defined(__MAILBOX__)
-#	include "MailBox.h"
-#endif
-#if defined(__GEM_SHOP__)
-#	include "GemShop.h"
-#endif
-#if defined(__RANKING_SYSTEM__)
-#	include "Ranking.h"
-#endif
-#if defined(__MINI_GAME_RUMI__)
-#	include "minigame_rumi.h"
-#endif
-#if defined(__MINI_GAME_YUTNORI__)
-#	include "minigame_yutnori.h"
-#endif
-#if defined(__MINI_GAME_CATCH_KING__)
-#	include "minigame_catchking.h"
-#endif
-#if defined(__FLOWER_EVENT__)
-#	include "flower_event.h"
-#endif
-#if defined(__SUMMER_EVENT_ROULETTE__)
-#	include "minigame_roulette.h"
-#endif
-#if defined(__INGAME_EVENT_MANAGER__)
-#	include "ingame_event_manager.h"
-#endif
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-#	include "guild_dragonlair.h"
-#endif
-
-class CBuffOnAttributes;
-class CPetSystem;
-#if defined(__LOOT_FILTER_SYSTEM__)
-class CLootFilter;
-#endif
-#ifdef __OFFLINE_SHOP__
-class COfflineShop;
-#endif
-
-#define INSTANT_FLAG_DEATH_PENALTY (1 << 0)
-#define INSTANT_FLAG_SHOP (1 << 1)
-#define INSTANT_FLAG_EXCHANGE (1 << 2)
-#define INSTANT_FLAG_STUN (1 << 3)
-#define INSTANT_FLAG_NO_REWARD (1 << 4)
-
-#define AI_FLAG_NPC (1 << 0)
-#define AI_FLAG_AGGRESSIVE (1 << 1)
-#define AI_FLAG_HELPER (1 << 2)
-#define AI_FLAG_STAYZONE (1 << 3)
-
-#define SET_OVER_TIME(ch, time) (ch)->SetOverTime(time)
-
-#ifdef __GROWTH_PET_SYSTEM__
-#include "growth_pet.h"
-#endif
-extern int g_nPortalLimitTime;
-
-extern bool IS_SUMMON_ITEM(LPITEM item, int map_index = 0);
-extern bool IS_SUMMONABLE_ZONE(int map_index);
-
-extern bool IS_MONKEY_DUNGEON(int map_index);
-extern bool IS_MAZE_DUNGEON(int map_index);
-
-#if defined(__SNOW_DUNGEON__)
-extern bool IS_SNOW_DUNGEON(int map_index);
-#endif
-
-#if defined(__ELEMENTAL_DUNGEON__)
-extern bool IS_ELEMENTAL_DUNGEON(int map_index);
-#endif
-
-extern bool CAN_ENTER_ZONE(const LPCHARACTER& ch, int map_index);
-extern bool IS_BLOCKED_PET(int map_index); // char.cpp
-extern bool IS_BLOCKED_PET_DUNGEON_MAP(int map_index);
-
-enum
-{
-	MAIN_RACE_WARRIOR_M,
-	MAIN_RACE_ASSASSIN_W,
-	MAIN_RACE_SURA_M,
-	MAIN_RACE_SHAMAN_W,
-	MAIN_RACE_WARRIOR_W,
-	MAIN_RACE_ASSASSIN_M,
-	MAIN_RACE_SURA_W,
-	MAIN_RACE_SHAMAN_M,
-	MAIN_RACE_WOLFMAN_M,
-	MAIN_RACE_MAX_NUM,
-};
-
-enum
-{
-	POISON_LENGTH = 30,
-	BLEEDING_LENGTH = 30,
-	STAMINA_PER_STEP = 1,
-	SAFEBOX_PAGE_SIZE = 9,
-	AI_CHANGE_ATTACK_POISITION_TIME_NEAR = 10000,
-	AI_CHANGE_ATTACK_POISITION_TIME_FAR = 1000,
-	AI_CHANGE_ATTACK_POISITION_DISTANCE = 100,
-	SUMMON_MONSTER_COUNT = 3,
-};
-
-enum
-{
-	FLY_NONE,
-	FLY_EXP,
-	FLY_HP_MEDIUM,
-	FLY_HP_BIG,
-	FLY_SP_SMALL,
-	FLY_SP_MEDIUM,
-	FLY_SP_BIG,
-	FLY_FIREWORK1,
-	FLY_FIREWORK2,
-	FLY_FIREWORK3,
-	FLY_FIREWORK4,
-	FLY_FIREWORK5,
-	FLY_FIREWORK6,
-	FLY_FIREWORK_CHRISTMAS,
-	FLY_CHAIN_LIGHTNING,
-	FLY_HP_SMALL,
-	FLY_SKILL_MUYEONG,
-#if defined(__QUIVER_SYSTEM__)
-	FLY_QUIVER_ATTACK_NORMAL,
-#endif
-#if defined(__CONQUEROR_LEVEL__)
-	FLY_ILGWANGPYO_NORMAL,
-	FLY_ILGWANGPYO_MASTER,
-	FLY_ILGWANGPYO_GRAND_MASTER,
-	FLY_ILGWANGPYO_PERFECT_MASTER,
-	FLY_CONQUEROR_EXP,
-#endif
-};
-
-enum EDamageType
-{
-	DAMAGE_TYPE_NONE,
-	DAMAGE_TYPE_NORMAL,
-	DAMAGE_TYPE_NORMAL_RANGE,
-	// 스킬
-	DAMAGE_TYPE_MELEE,
-	DAMAGE_TYPE_RANGE,
-	DAMAGE_TYPE_FIRE,
-	DAMAGE_TYPE_ICE,
-	DAMAGE_TYPE_ELEC,
-	DAMAGE_TYPE_MAGIC,
-	DAMAGE_TYPE_POISON,
-	DAMAGE_TYPE_SPECIAL,
-	DAMAGE_TYPE_BLEEDING,
-};
-
-enum DamageFlag
-{
-	DAMAGE_NORMAL = (1 << 0),
-	DAMAGE_POISON = (1 << 1),
-	DAMAGE_DODGE = (1 << 2),
-	DAMAGE_BLOCK = (1 << 3),
-	DAMAGE_PENETRATE = (1 << 4),
-	DAMAGE_CRITICAL = (1 << 5),
-	DAMAGE_BLEEDING = (1 << 6),
-};
-
-enum EPKModes
-{
-	PK_MODE_PEACE,
-	PK_MODE_REVENGE,
-	PK_MODE_FREE,
-	PK_MODE_PROTECT,
-	PK_MODE_GUILD,
-	PK_MODE_MAX_NUM
-};
-
-enum EPositions
-{
-	POS_DEAD,
-	POS_SLEEPING,
-	POS_RESTING,
-	POS_SITTING,
-	POS_FISHING,
-	POS_FIGHTING,
-	POS_MOUNTING,
-	POS_STANDING
-};
-
-enum EBlockAction
-{
-	BLOCK_EXCHANGE = (1 << 0),
-	BLOCK_PARTY_INVITE = (1 << 1),
-	BLOCK_GUILD_INVITE = (1 << 2),
-	BLOCK_WHISPER = (1 << 3),
-	BLOCK_MESSENGER_INVITE = (1 << 4),
-	BLOCK_PARTY_REQUEST = (1 << 5),
-};
-
-#ifdef __OFFLINE_SHOP__
-enum EUnlockShopSkin
-{
-	UNLOCK_SHOP_SKIN_1 = (1 << 0),
-	UNLOCK_SHOP_SKIN_2 = (1 << 1),
-	UNLOCK_SHOP_SKIN_3 = (1 << 2),
-	UNLOCK_SHOP_SKIN_4 = (1 << 3),
-	UNLOCK_SHOP_SKIN_5 = (1 << 4),
-	UNLOCK_SHOP_SKIN_6 = (1 << 5),
-	UNLOCK_SHOP_SKIN_7 = (1 << 6),
-	UNLOCK_SHOP_SKIN_8 = (1 << 7),
-};
-
-enum EUnlockShopBanner
-{
-	UNLOCK_SHOP_BANNER_1 = (1 << 0),
-	UNLOCK_SHOP_BANNER_2 = (1 << 1),
-	UNLOCK_SHOP_BANNER_3 = (1 << 2),
-	UNLOCK_SHOP_BANNER_4 = (1 << 3),
-	UNLOCK_SHOP_BANNER_5 = (1 << 4),
-};
-#endif
-
-enum EAlignmentGrade
-{
-	ALIGN_GRADE_GOOD_4,
-	ALIGN_GRADE_GOOD_3,
-	ALIGN_GRADE_GOOD_2,
-	ALIGN_GRADE_GOOD_1,
-	ALIGN_GRADE_NORMAL,
-	ALIGN_GRADE_EVIL_1,
-	ALIGN_GRADE_EVIL_2,
-	ALIGN_GRADE_EVIL_3,
-	ALIGN_GRADE_EVIL_4,
-};
-
-enum EPointTypes
-{
-	POINT_NONE,								// 0
-	POINT_LEVEL,							// 1
-	POINT_VOICE,							// 2
-	POINT_EXP,								// 3
-	POINT_NEXT_EXP,							// 4
-	POINT_HP,								// 5
-	POINT_MAX_HP,							// 6
-	POINT_SP,								// 7
-	POINT_MAX_SP,							// 8
-	POINT_STAMINA,							// 9 스테미너
-	POINT_MAX_STAMINA,						// 10 최대 스테미너
-
-	POINT_GOLD,								// 11
-	POINT_ST,								// 12 근력
-	POINT_HT,								// 13 체력
-	POINT_DX,								// 14 민첩성
-	POINT_IQ,								// 15 정신력
-	POINT_DEF_GRADE,						// 16 ...
-	POINT_ATT_SPEED,						// 17 공격속도
-	POINT_ATT_GRADE,						// 18 공격력 MAX
-	POINT_MOV_SPEED,						// 19 이동속도
-	POINT_CLIENT_DEF_GRADE,					// 20 방어등급
-	POINT_CASTING_SPEED,					// 21 주문속도 (쿨다운타임*100) / (100 + 이값) = 최종 쿨다운 타임
-	POINT_MAGIC_ATT_GRADE,					// 22 마법공격력
-	POINT_MAGIC_DEF_GRADE,					// 23 마법방어력
-	POINT_EMPIRE_POINT,						// 24 제국점수
-	POINT_LEVEL_STEP,						// 25 한 레벨에서의 단계.. (1 2 3 될 때 보상, 4 되면 레벨 업)
-	POINT_STAT,								// 26 능력치 올릴 수 있는 개수
-	POINT_SUB_SKILL,						// 27 보조 스킬 포인트
-	POINT_SKILL,							// 28 액티브 스킬 포인트
-	POINT_WEAPON_MIN,						// 29 무기 최소 데미지
-	POINT_WEAPON_MAX,						// 30 무기 최대 데미지
-	POINT_PLAYTIME,							// 31 플레이시간
-	POINT_HP_REGEN,							// 32 HP 회복률
-	POINT_SP_REGEN,							// 33 SP 회복률
-
-	POINT_BOW_DISTANCE,						// 34 활 사정거리 증가치 (meter)
-
-	POINT_HP_RECOVERY,						// 35 체력 회복 증가량
-	POINT_SP_RECOVERY,						// 36 정신력 회복 증가량
-
-	POINT_POISON_PCT,						// 37 독 확률
-	POINT_STUN_PCT,							// 38 기절 확률
-	POINT_SLOW_PCT,							// 39 슬로우 확률
-	POINT_CRITICAL_PCT,						// 40 크리티컬 확률
-	POINT_PENETRATE_PCT,					// 41 관통타격 확률
-	POINT_CURSE_PCT,						// 42 저주 확률
-
-	POINT_ATTBONUS_HUMAN,					// 43 인간에게 강함
-	POINT_ATTBONUS_ANIMAL,					// 44 동물에게 데미지 % 증가
-	POINT_ATTBONUS_ORC,						// 45 웅귀에게 데미지 % 증가
-	POINT_ATTBONUS_MILGYO,					// 46 밀교에게 데미지 % 증가
-	POINT_ATTBONUS_UNDEAD,					// 47 시체에게 데미지 % 증가
-	POINT_ATTBONUS_DEVIL,					// 48 마귀(악마)에게 데미지 % 증가
-	POINT_ATTBONUS_INSECT,					// 49 벌레족
-	POINT_ATTBONUS_FIRE,					// 50 화염족
-	POINT_ATTBONUS_ICE,						// 51 빙설족
-	POINT_ATTBONUS_DESERT,					// 52 사막족
-	POINT_ATTBONUS_MONSTER,					// 53 모든 몬스터에게 강함
-	POINT_ATTBONUS_WARRIOR,					// 54 무사에게 강함
-	POINT_ATTBONUS_ASSASSIN,				// 55 자객에게 강함
-	POINT_ATTBONUS_SURA,					// 56 수라에게 강함
-	POINT_ATTBONUS_SHAMAN,					// 57 무당에게 강함
-	POINT_ATTBONUS_TREE,					// 58 나무에게 강함 20050729.myevan UNUSED5
-
-	POINT_RESIST_WARRIOR,					// 59 무사에게 저항
-	POINT_RESIST_ASSASSIN,					// 60 자객에게 저항
-	POINT_RESIST_SURA,						// 61 수라에게 저항
-	POINT_RESIST_SHAMAN,					// 62 무당에게 저항
-
-	POINT_STEAL_HP,							// 63 생명력 흡수
-	POINT_STEAL_SP,							// 64 정신력 흡수
-
-	POINT_MANA_BURN_PCT,					// 65 마나 번
-
-	/// 피해시 보너스 ///
-
-	POINT_DAMAGE_SP_RECOVER,				// 66 공격당할 시 정신력 회복 확률
-
-	POINT_BLOCK,							// 67 블럭율
-	POINT_DODGE,							// 68 회피율
-
-	POINT_RESIST_SWORD,						// 69
-	POINT_RESIST_TWOHAND,					// 70
-	POINT_RESIST_DAGGER,					// 71
-	POINT_RESIST_BELL,						// 72
-	POINT_RESIST_FAN,						// 73
-	POINT_RESIST_BOW,						// 74 화살 저항 : 대미지 감소
-	POINT_RESIST_FIRE,						// 75 화염 저항 : 화염공격에 대한 대미지 감소
-	POINT_RESIST_ELEC,						// 76 전기 저항 : 전기공격에 대한 대미지 감소
-	POINT_RESIST_MAGIC,						// 77 술법 저항 : 모든술법에 대한 대미지 감소
-	POINT_RESIST_WIND,						// 78 바람 저항 : 바람공격에 대한 대미지 감소
-
-	POINT_REFLECT_MELEE,					// 79 공격 반사
-
-	/// 특수 피해시 ///
-	POINT_REFLECT_CURSE,					// 80 저주 반사
-	POINT_POISON_REDUCE,					// 81 독데미지 감소
-
-	/// 적 소멸시 ///
-	POINT_KILL_SP_RECOVER,					// 82 적 소멸시 MP 회복
-	POINT_EXP_DOUBLE_BONUS,					// 83
-	POINT_GOLD_DOUBLE_BONUS,				// 84
-	POINT_ITEM_DROP_BONUS,					// 85
-
-	/// 회복 관련 ///
-	POINT_POTION_BONUS,						// 86
-	POINT_KILL_HP_RECOVERY,					// 87
-
-	POINT_IMMUNE_STUN,						// 88
-	POINT_IMMUNE_SLOW,						// 89
-	POINT_IMMUNE_FALL,						// 90
-	//////////////////
-
-	POINT_PARTY_ATTACKER_BONUS,				// 91
-	POINT_PARTY_TANKER_BONUS,				// 92
-
-	POINT_ATT_BONUS,						// 93
-	POINT_DEF_BONUS,						// 94
-
-	POINT_ATT_GRADE_BONUS,					// 95
-	POINT_DEF_GRADE_BONUS,					// 96
-	POINT_MAGIC_ATT_GRADE_BONUS,			// 97
-	POINT_MAGIC_DEF_GRADE_BONUS,			// 98
-
-	POINT_RESIST_NORMAL_DAMAGE,				// 99
-
-	POINT_HIT_HP_RECOVERY,					// 100
-	POINT_HIT_SP_RECOVERY,					// 101
-	POINT_MANASHIELD,						// 102 흑신수호 스킬에 의한 마나쉴드 효과 정도
-
-	POINT_PARTY_BUFFER_BONUS,				// 103
-	POINT_PARTY_SKILL_MASTER_BONUS,			// 104
-
-	POINT_HP_RECOVER_CONTINUE,				// 105
-	POINT_SP_RECOVER_CONTINUE,				// 106
-
-	POINT_STEAL_GOLD,						// 107
-	POINT_POLYMORPH,						// 108 변신한 몬스터 번호
-	POINT_MOUNT,							// 109 타고있는 몬스터 번호
-
-	POINT_PARTY_HASTE_BONUS,				// 110
-	POINT_PARTY_DEFENDER_BONUS,				// 111
-	POINT_STAT_RESET_COUNT,					// 112 피의 단약 사용을 통한 스텟 리셋 포인트 (1당 1포인트 리셋가능)
-
-	POINT_HORSE_SKILL,						// 113
-
-	POINT_MALL_ATTBONUS,					// 114 공격력 +x%
-	POINT_MALL_DEFBONUS,					// 115 방어력 +x%
-	POINT_MALL_EXPBONUS,					// 116 경험치 +x%
-	POINT_MALL_ITEMBONUS,					// 117 아이템 드롭율 x/10배
-	POINT_MALL_GOLDBONUS,					// 118 돈 드롭율 x/10배
-
-	POINT_MAX_HP_PCT,						// 119 최대생명력 +x%
-	POINT_MAX_SP_PCT,						// 120 최대정신력 +x%
-
-	POINT_SKILL_DAMAGE_BONUS,				// 121 스킬 데미지 *(100+x)%
-	POINT_NORMAL_HIT_DAMAGE_BONUS,			// 122 평타 데미지 *(100+x)%
-
-	// DEFEND_BONUS_ATTRIBUTES
-	POINT_SKILL_DEFEND_BONUS,				// 123 스킬 방어 데미지
-	POINT_NORMAL_HIT_DEFEND_BONUS,			// 124 평타 방어 데미지
-	// END_OF_DEFEND_BONUS_ATTRIBUTES
-
-	// PC_BANG_ITEM_ADD 
-	POINT_PC_BANG_EXP_BONUS,				// 125 PC방 전용 경험치 보너스
-	POINT_PC_BANG_DROP_BONUS,				// 126 PC방 전용 드롭률 보너스
-	// END_PC_BANG_ITEM_ADD
-	POINT_RAMADAN_CANDY_BONUS_EXP,			// 127 라마단 사탕 경험치 증가용
-
-	POINT_ENERGY = 128,						// 128 기력
-
-	// 기력 ui 용.
-	// 서버에서 쓰지 않기만, 클라이언트에서 기력의 끝 시간을 POINT로 관리하기 때문에 이렇게 한다.
-	// 아 부끄럽다
-	POINT_ENERGY_END_TIME = 129,			// 129 기력 종료 시간
-
-	POINT_COSTUME_ATTR_BONUS = 130,			// 130
-	POINT_MAGIC_ATT_BONUS_PER = 131,		// 131
-	POINT_MELEE_MAGIC_ATT_BONUS_PER = 132,	// 132
-
-	// 추가 속성 저항
-	POINT_RESIST_ICE = 133,					// 133 냉기 저항 : 얼음공격에 대한 대미지 감소
-	POINT_RESIST_EARTH = 134,				// 134 대지 저항 : 얼음공격에 대한 대미지 감소
-	POINT_RESIST_DARK = 135,				// 135 어둠 저항 : 얼음공격에 대한 대미지 감소
-
-	POINT_RESIST_CRITICAL = 136,			// 136 크리티컬 저항 : 상대의 크리티컬 확률을 감소
-	POINT_RESIST_PENETRATE = 137,			// 137 관통타격 저항 : 상대의 관통타격 확률을 감소
-
-	POINT_BLEEDING_REDUCE = 138,			// 138
-	POINT_BLEEDING_PCT = 139,				// 139
-	POINT_ATTBONUS_WOLFMAN = 140,			// 140
-	POINT_RESIST_WOLFMAN = 141,				// 141
-	POINT_RESIST_CLAW = 142,				// 142
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	POINT_ACCEDRAIN_RATE,
-#endif
-#if defined(__MAGIC_REDUCTION__)
-	POINT_RESIST_MAGIC_REDUCTION,
-#endif
-#if defined(__CHEQUE_SYSTEM__)
-	POINT_CHEQUE,
-#endif
-	POINT_BATTLE_POINT,
-	POINT_RESIST_HUMAN,
-	POINT_ENCHANT_ELECT,
-	POINT_ENCHANT_FIRE,
-	POINT_ENCHANT_ICE,
-	POINT_ENCHANT_WIND,
-	POINT_ENCHANT_EARTH,
-	POINT_ENCHANT_DARK,
-	POINT_ATTBONUS_CZ,
-	POINT_BEAD,
-#if defined(__GEM_SYSTEM__)
-	POINT_GEM,
-#endif
-	POINT_ATTBONUS_SWORD,
-	POINT_ATTBONUS_TWOHAND,
-	POINT_ATTBONUS_DAGGER,
-	POINT_ATTBONUS_BELL,
-	POINT_ATTBONUS_FAN,
-	POINT_ATTBONUS_BOW,
-	POINT_ATTBONUS_CLAW,
-	POINT_RESIST_MOUNT_FALL,
-	POINT_RESIST_FIST,
-	POINT_PREMIUM_EXPBONUS,
-	POINT_PRIVILEGE_EXPBONUS,
-	POINT_MARRIAGE_EXPBONUS,
-	POINT_DEVILTOWER_EXPBONUS,
-	POINT_PREMIUM_ITEMBONUS,
-	POINT_PRIVILEGE_ITEMBONUS,
-	POINT_PREMIUM_GOLDBONUS,
-	POINT_PRIVILEGE_GOLDBONUS,
-	POINT_SKILL_DAMAGE_SAMYEON,
-	POINT_SKILL_DAMAGE_TANHWAN,
-	POINT_SKILL_DAMAGE_PALBANG,
-	POINT_SKILL_DAMAGE_GIGONGCHAM,
-	POINT_SKILL_DAMAGE_GYOKSAN,
-	POINT_SKILL_DAMAGE_GEOMPUNG,
-	POINT_SKILL_DAMAGE_AMSEOP,
-	POINT_SKILL_DAMAGE_GUNGSIN,
-	POINT_SKILL_DAMAGE_CHARYUN,
-	POINT_SKILL_DAMAGE_SANGONG,
-	POINT_SKILL_DAMAGE_YEONSA,
-	POINT_SKILL_DAMAGE_KWANKYEOK,
-	POINT_SKILL_DAMAGE_GIGUNG,
-	POINT_SKILL_DAMAGE_HWAJO,
-	POINT_SKILL_DAMAGE_SWAERYUNG,
-	POINT_SKILL_DAMAGE_YONGKWON,
-	POINT_SKILL_DAMAGE_PABEOB,
-	POINT_SKILL_DAMAGE_MARYUNG,
-	POINT_SKILL_DAMAGE_HWAYEOMPOK,
-	POINT_SKILL_DAMAGE_MAHWAN,
-	POINT_SKILL_DAMAGE_BIPABU,
-	POINT_SKILL_DAMAGE_YONGBI,
-	POINT_SKILL_DAMAGE_PAERYONG,
-	POINT_SKILL_DAMAGE_NOEJEON,
-	POINT_SKILL_DAMAGE_BYEURAK,
-	POINT_SKILL_DAMAGE_CHAIN,
-	POINT_SKILL_DAMAGE_CHAYEOL,
-	POINT_SKILL_DAMAGE_SALPOONG,
-	POINT_SKILL_DAMAGE_GONGDAB,
-	POINT_SKILL_DAMAGE_PASWAE,
-	POINT_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE,
-	POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE,
-	POINT_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE,
-	POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE,
-	POINT_HIT_BUFF_ENCHANT_FIRE,
-	POINT_HIT_BUFF_ENCHANT_ICE,
-	POINT_HIT_BUFF_ENCHANT_ELEC,
-	POINT_HIT_BUFF_ENCHANT_WIND,
-	POINT_HIT_BUFF_ENCHANT_DARK,
-	POINT_HIT_BUFF_ENCHANT_EARTH,
-	POINT_HIT_BUFF_RESIST_FIRE,
-	POINT_HIT_BUFF_RESIST_ICE,
-	POINT_HIT_BUFF_RESIST_ELEC,
-	POINT_HIT_BUFF_RESIST_WIND,
-	POINT_HIT_BUFF_RESIST_DARK,
-	POINT_HIT_BUFF_RESIST_EARTH,
-	POINT_USE_SKILL_CHEONGRANG_MOV_SPEED,
-	POINT_USE_SKILL_CHEONGRANG_CASTING_SPEED,
-	POINT_USE_SKILL_CHAYEOL_CRITICAL_PCT,
-	POINT_USE_SKILL_SANGONG_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_GIGUNG_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_JEOKRANG_DEF_BONUS,
-	POINT_USE_SKILL_GWIGEOM_DEF_BONUS,
-	POINT_USE_SKILL_TERROR_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_MUYEONG_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_MANASHILED_CASTING_SPEED,
-	POINT_USE_SKILL_HOSIN_DEF_BONUS,
-	POINT_USE_SKILL_GICHEON_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_JEUNGRYEOK_DEF_BONUS,
-	POINT_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_CHUNKEON_CASTING_SPEED,
-	POINT_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS,
-	POINT_SKILL_DURATION_INCREASE_EUNHYUNG,
-	POINT_SKILL_DURATION_INCREASE_GYEONGGONG,
-	POINT_SKILL_DURATION_INCREASE_GEOMKYUNG,
-	POINT_SKILL_DURATION_INCREASE_JEOKRANG,
-	POINT_USE_SKILL_PALBANG_HP_ABSORB,
-	POINT_USE_SKILL_AMSEOP_HP_ABSORB,
-	POINT_USE_SKILL_YEONSA_HP_ABSORB,
-	POINT_USE_SKILL_YONGBI_HP_ABSORB,
-	POINT_USE_SKILL_CHAIN_HP_ABSORB,
-	POINT_USE_SKILL_PASWAE_SP_ABSORB,
-	POINT_USE_SKILL_GIGONGCHAM_STUN,
-	POINT_USE_SKILL_CHARYUN_STUN,
-	POINT_USE_SKILL_PABEOB_STUN,
-	POINT_USE_SKILL_MAHWAN_STUN,
-	POINT_USE_SKILL_GONGDAB_STUN,
-	POINT_USE_SKILL_SAMYEON_STUN,
-	POINT_USE_SKILL_GYOKSAN_KNOCKBACK,
-	POINT_USE_SKILL_SEOMJEON_KNOCKBACK,
-	POINT_USE_SKILL_SWAERYUNG_KNOCKBACK,
-	POINT_USE_SKILL_HWAYEOMPOK_KNOCKBACK,
-	POINT_USE_SKILL_GONGDAB_KNOCKBACK,
-	POINT_USE_SKILL_KWANKYEOK_KNOCKBACK,
-	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_ATTBONUS_STONE,
-	POINT_DAMAGE_HP_RECOVERY,
-	POINT_DAMAGE_SP_RECOVERY,
-	POINT_ALIGNMENT_DAMAGE_BONUS,
-	POINT_NORMAL_DAMAGE_GUARD,
-	POINT_MORE_THEN_HP90_DAMAGE_REDUCE,
-	POINT_USE_SKILL_TUSOK_HP_ABSORB,
-	POINT_USE_SKILL_PAERYONG_HP_ABSORB,
-	POINT_USE_SKILL_BYEURAK_HP_ABSORB,
-	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_CHAYEOL_HP_ABSORB,
-	POINT_MEDAL_OF_HONOR,
-	POINT_ALL_STAT_BONUS,
-	POINT_SUNGMA_STR,
-	POINT_SUNGMA_HP,
-	POINT_SUNGMA_MOVE,
-	POINT_SUNGMA_IMMUNE,
-	POINT_CONQUEROR_LEVEL,
-	POINT_CONQUEROR_LEVEL_STEP,
-	POINT_CONQUEROR_EXP,
-	POINT_CONQUEROR_NEXT_EXP,
-	POINT_CONQUEROR_POINT,
-	POINT_HIT_PCT,
-	POINT_ATTBONUS_PER_HUMAN,
-	POINT_ATTBONUS_PER_ANIMAL,
-	POINT_ATTBONUS_PER_ORC,
-	POINT_ATTBONUS_PER_MILGYO,
-	POINT_ATTBONUS_PER_UNDEAD,
-	POINT_ATTBONUS_PER_DEVIL,
-	POINT_ENCHANT_PER_ELECT,
-	POINT_ENCHANT_PER_FIRE,
-	POINT_ENCHANT_PER_ICE,
-	POINT_ENCHANT_PER_WIND,
-	POINT_ENCHANT_PER_EARTH,
-	POINT_ENCHANT_PER_DARK,
-	POINT_ATTBONUS_PER_CZ,
-	POINT_ATTBONUS_PER_INSECT,
-	POINT_ATTBONUS_PER_DESERT,
-	POINT_ATTBONUS_PER_STONE,
-	POINT_ATTBONUS_PER_MONSTER,
-	POINT_RESIST_PER_HUMAN,
-	POINT_RESIST_PER_ICE,
-	POINT_RESIST_PER_DARK,
-	POINT_RESIST_PER_EARTH,
-	POINT_RESIST_PER_FIRE,
-	POINT_RESIST_PER_ELEC,
-	POINT_RESIST_PER_MAGIC,
-	POINT_RESIST_PER_WIND,
-	POINT_HIT_BUFF_SUNGMA_STR,
-	POINT_HIT_BUFF_SUNGMA_MOVE,
-	POINT_HIT_BUFF_SUNGMA_HP,
-	POINT_HIT_BUFF_SUNGMA_IMMUNE,
-	POINT_MOUNT_MELEE_MAGIC_ATTBONUS_PER,
-	POINT_DISMOUNT_MOVE_SPEED_BONUS_PER,
-	POINT_HIT_AUTO_HP_RECOVERY,
-	POINT_HIT_AUTO_SP_RECOVERY,
-	POINT_USE_SKILL_COOLTIME_DECREASE_ALL,
-	POINT_HIT_STONE_ATTBONUS_STONE,
-	POINT_HIT_STONE_DEF_GRADE_BONUS,
-	POINT_KILL_BOSS_ITEM_BONUS,
-	POINT_MOB_HIT_MOB_AGGRESSIVE,
-	POINT_NO_DEATH_AND_HP_RECOVERY30,
-	POINT_AUTO_PICKUP,
-	POINT_MOUNT_NO_KNOCKBACK,
-	POINT_SUNGMA_PER_STR,
-	POINT_SUNGMA_PER_HP,
-	POINT_SUNGMA_PER_MOVE,
-	POINT_SUNGMA_PER_IMMUNE,
-	POINT_IMMUNE_POISON100,
-	POINT_IMMUNE_BLEEDING100,
-	POINT_MONSTER_DEFEND_BONUS,
-
-	// 클라이언트 포인트
-	POINT_MIN_WEP,
-	POINT_MAX_WEP,
-	POINT_MIN_MAGIC_WEP,
-	POINT_MAX_MAGIC_WEP,
-	POINT_HIT_RATE,
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	POINT_BATTLE_PASS_PREMIUM_ID
-#endif
-};
-
-// <Factor> Dynamically evaluated CHARACTER* equivalent.
-// Referring to SCharDeadEventInfo.
-struct DynamicCharacterPtr
-{
-	DynamicCharacterPtr() : is_pc(false), id(0) {}
-	DynamicCharacterPtr(const DynamicCharacterPtr& o)
-		: is_pc(o.is_pc), id(o.id) {}
-
-	// Returns the LPCHARACTER found in CHARACTER_MANAGER.
-	LPCHARACTER Get() const;
-	// Clears the current settings.
-	void Reset()
-	{
-		is_pc = false;
-		id = 0;
-	}
-
-	// Basic assignment operator.
-	DynamicCharacterPtr& operator=(const DynamicCharacterPtr& rhs)
-	{
-		is_pc = rhs.is_pc;
-		id = rhs.id;
-		return *this;
-	}
-	// Supports assignment with LPCHARACTER type.
-	DynamicCharacterPtr& operator=(LPCHARACTER character);
-	// Supports type casting to LPCHARACTER.
-	operator LPCHARACTER() const
-	{
-		return Get();
-	}
-
-	bool is_pc;
-	uint32_t id;
-};
-
-/* 저장하는 데이터 */
-typedef struct character_point
-{
-	POINT_VALUE lPoints[POINT_MAX_NUM];
-
-	BYTE bJob;
-	BYTE bVoice;
-
-	BYTE bLevel;
-	DWORD dwExp;
-
-#if defined(__CONQUEROR_LEVEL__)
-	BYTE bConquerorLevel;
-	DWORD dwConquerorExp;
-#endif
-
-	int iGold;
-#if defined(__CHEQUE_SYSTEM__)
-	int iCheque;
-#endif
-#if defined(__GEM_SYSTEM__)
-	int iGem;
-#endif
-
-	int iHP, iSP;
-	int iRandomHP, iRandomSP;
-	int iStamina;
-
-	BYTE bSkillGroup;
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	int battle_pass_premium_id;
-#endif
-} CHARACTER_POINT;
-
-/* 저장되지 않는 캐릭터 데이터 */
-typedef struct character_point_instant
-{
-	POINT_VALUE points[POINT_MAX_NUM];
-
-	float fRot;
-
-	int iMaxHP;
-	int iMaxSP;
-
-	long position;
-
-	long instant_flag;
-	DWORD dwAIFlag;
-	DWORD dwImmuneFlag;
-	DWORD dwLastShoutPulse;
-
-	DWORD adwParts[PART_MAX_NUM];
-
-	LPITEM pInventoryItems[INVENTORY_MAX_NUM];
-	WORD wInventoryItemGrid[INVENTORY_MAX_NUM];
-
-	LPITEM pEquipmentItems[EQUIPMENT_MAX_NUM];
-	BYTE bEquipmentItemGrid[EQUIPMENT_MAX_NUM];
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	// 용혼석 인벤토리.
-	LPITEM pDragonSoulInventoryItems[DRAGON_SOUL_INVENTORY_MAX_NUM];
-	WORD wDragonSoulInventoryItemGrid[DRAGON_SOUL_INVENTORY_MAX_NUM];
-#endif
-
-	LPITEM pBeltInventoryItems[BELT_INVENTORY_MAX_NUM];
-	BYTE bBeltInventoryItemGrid[BELT_INVENTORY_MAX_NUM];
-
-#if !defined(__CUBE_RENEWAL__)
-	// by mhh
-	LPITEM pCubeItems[CUBE_MAX_NUM];
-#endif
-	LPCHARACTER pCubeNpc;
-#if defined(__MOVE_COSTUME_ATTR__)
-	LPCHARACTER pItemCombNpc;
-#endif
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	LPCHARACTER pRouletteNPC;
-#endif
-#if defined(__ATTR_6TH_7TH__)
-	LPITEM pNPCStorageItems;
-#endif
-
-	BYTE gm_level;
-
-	BYTE bBasePart; // 평상복 번호
-
-	int iMaxStamina;
-
-	BYTE bBlockMode;
-#ifdef __OFFLINE_SHOP__
-	BYTE bUnlockedShopSkin;
-	BYTE bUnlockedShopBanner;
-#endif
-	int iDragonSoulActiveDeck;
-	int iDragonSoulRefineDeckSnapshot;
-	LPENTITY m_pDragonSoulRefineWindowOpener;
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	LPENTITY m_pAcceRefineWindowOpener;
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	LPENTITY m_pAuraRefineWindowOpener;
-#endif
-} CHARACTER_POINT_INSTANT;
-
-#define TRIGGERPARAM LPCHARACTER ch, LPCHARACTER causer
-
-typedef struct trigger
-{
-	BYTE type;
-	int (*func) (TRIGGERPARAM);
-	long value;
-} TRIGGER;
-
-class CTrigger
-{
-public:
-	CTrigger() : bType(0), pFunc(NULL)
-	{
-	}
-
-	BYTE bType;
-	int (*pFunc) (TRIGGERPARAM);
-};
-
-EVENTINFO(char_event_info)
-{
-	DynamicCharacterPtr ch;
-};
-
-struct TSkillUseInfo
-{
-	int iHitCount;
-	int iMaxHitCount;
-	int iSplashCount;
-	DWORD dwNextSkillUsableTime;
-	int iRange;
-	bool bUsed;
-	DWORD dwVID;
-	bool isGrandMaster;
-
-	std::unordered_map<DWORD, std::size_t> TargetVIDMap;
-
-	TSkillUseInfo()
-		: iHitCount(0), iMaxHitCount(0), iSplashCount(0), dwNextSkillUsableTime(0), iRange(0), bUsed(false),
-		dwVID(0), isGrandMaster(false)
-	{}
-
-	bool HitOnce(DWORD dwVnum = 0);
-
-	bool UseSkill(bool isGrandMaster, DWORD vid, DWORD dwCooltime, int splashcount = 1, int hitcount = -1, int range = -1);
-	DWORD GetMainTargetVID() const { return dwVID; }
-	void SetMainTargetVID(DWORD vid) { dwVID = vid; }
-	void ResetHitCount() { if (iSplashCount) { iHitCount = iMaxHitCount; iSplashCount--; } }
-};
-
-typedef struct packet_party_update TPacketGCPartyUpdate;
-class CExchange;
-class CSkillProto;
-class CParty;
-class CDungeon;
-#if defined(__DEFENSE_WAVE__)
-class CDefenseWave;
-#endif
-class CWarMap;
-class CAffect;
-class CGuild;
-class CSafebox;
-class CArena;
-
-class CShop;
-typedef class CShop* LPSHOP;
-
-class CMob;
-class CMobInstance;
-typedef struct SMobSkillInfo TMobSkillInfo;
-
-// SKILL_POWER_BY_LEVEL
-extern int GetSkillPowerByLevelFromType(int job, int skillgroup, int skilllevel);
-// END_SKILL_POWER_BY_LEVEL
-
-namespace marriage
-{
-	class WeddingMap;
-}
-enum e_overtime
-{
-	OT_NONE,
-	OT_3HOUR,
-	OT_5HOUR,
-};
-
-typedef std::list<CAffect*> AffectContainerList;
-typedef std::unordered_map<DWORD, BYTE> AffectStackMap;
-typedef std::map<int, LPEVENT> MobSkillEventMap;
-
-class CHARACTER : public CEntity, public CFSM, public CHorseRider
-{
-protected:
-	//////////////////////////////////////////////////////////////////////////////////
-	// Entity 관련
-	virtual void EncodeInsertPacket(LPENTITY entity);
-	virtual void EncodeRemovePacket(LPENTITY entity);
-	//////////////////////////////////////////////////////////////////////////////////
-
-public:
-	LPCHARACTER FindCharacterInView(const char* name, bool bFindPCOnly);
-	void UpdatePacket();
-
-	//////////////////////////////////////////////////////////////////////////////////
-	// FSM (Finite State Machine) 관련
-protected:
-	CStateTemplate<CHARACTER> m_stateMove;
-	CStateTemplate<CHARACTER> m_stateBattle;
-	CStateTemplate<CHARACTER> m_stateIdle;
-
-public:
-	virtual void StateMove();
-	virtual void StateBattle();
-	virtual void StateIdle();
-	virtual void StateFlag();
-	virtual void StateFlagBase();
-	void StateHorse();
-
-protected:
-	// STATE_IDLE_REFACTORING
-	void __StateIdle_Monster();
-	void __StateIdle_Stone();
-	void __StateIdle_NPC();
-	// END_OF_STATE_IDLE_REFACTORING
-
-public:
-	DWORD GetAIFlag() const { return m_pointsInstant.dwAIFlag; }
-
-	void SetAggressive(bool bSet = true);
-	bool IsAggressive() const;
-
-	void SetCoward();
-	bool IsCoward() const;
-	void CowardEscape();
-
-	void SetNoAttackShinsu();
-	bool IsNoAttackShinsu() const;
-
-	void SetNoAttackChunjo();
-	bool IsNoAttackChunjo() const;
-
-	void SetNoAttackJinno();
-	bool IsNoAttackJinno() const;
-
-	void SetAttackMob();
-	bool IsAttackMob() const;
-
-	void SetNoMove();
-	bool IsNoMove() const;
-
-	virtual void BeginStateEmpty();
-	virtual void EndStateEmpty() {}
-
-	void Restart(BYTE bSubCMD);
-	void RestartAtSamePos();
-
-protected:
-	DWORD m_dwStateDuration;
-	//////////////////////////////////////////////////////////////////////////////////
-
-public:
-	CHARACTER();
-	virtual ~CHARACTER();
-
-	void Create(const char* c_pszName, DWORD vid, bool isPC);
-	void Destroy();
-
-	void Disconnect(const char* c_pszReason);
-
-protected:
-	void Initialize();
-
-	//////////////////////////////////////////////////////////////////////////////////
-	// Basic Points
-
-public:
-	DWORD GetPlayerID() const { return m_dwPlayerID; }
-
-	void SetPlayerProto(const TPlayerTable* table);
-	void CreatePlayerProto(TPlayerTable& tab); // 저장 시 사용
-
-	void SetProto(const CMob* c_pkMob);
-	WORD GetRaceNum() const;
-
-	void Save(); // DelayedSave
-	void SaveReal(); // 실제 저장
-	void FlushDelayedSaveItem();
-
-	const char* GetName() const;
-	const VID& GetVID() const { return m_vid; }
-
-	void SetName(const std::string& name) { m_stName = name; }
-
-	void SetRace(BYTE race);
-	bool ChangeSex();
-
-	bool IsFemale() const;
-	bool IsMale() const;
-
-	DWORD GetAID() const;
-	int GetChangeEmpireCount() const;
-	void SetChangeEmpireCount();
-	int ChangeEmpire(BYTE empire);
-
-	BYTE GetJob() const;
-	BYTE GetCharType() const;
-
-	bool IsPC() const { return GetDesc() ? true : false; }
-	bool IsNPC() const { return m_bCharType != CHAR_TYPE_PC; }
-	bool IsMonster() const { return m_bCharType == CHAR_TYPE_MONSTER; }
-	bool IsStone() const { return m_bCharType == CHAR_TYPE_STONE; }
-	bool IsDoor() const { return m_bCharType == CHAR_TYPE_DOOR; }
-	bool IsBuilding() const { return m_bCharType == CHAR_TYPE_BUILDING; }
-	bool IsWarp() const { return m_bCharType == CHAR_TYPE_WARP; }
-	bool IsGoto() const { return m_bCharType == CHAR_TYPE_GOTO; }
-	bool IsHorse() const { return m_bCharType == CHAR_TYPE_HORSE; }
-	bool IsPetPay() const { return m_bCharType == CHAR_TYPE_PET_PAY; }
-	//bool IsPet() const { return m_bCharType == CHAR_TYPE_PET; }
-
-	DWORD GetLastShoutPulse() const { return m_pointsInstant.dwLastShoutPulse; }
-	void SetLastShoutPulse(DWORD pulse) { m_pointsInstant.dwLastShoutPulse = pulse; }
-
-	BYTE GetGMLevel() const;
-	BOOL IsGM() const;
-	void SetGMLevel();
-
-	void SetLevel(BYTE bValue);
-	BYTE GetLevel() const { return m_points.bLevel; }
-
-	void SetExp(DWORD dwValue) { m_points.dwExp = dwValue; }
-	DWORD GetExp() const { return m_points.dwExp; }
-	DWORD GetNextExp() const;
-
-#if defined(__CONQUEROR_LEVEL__)
-	void SetConqueror(bool bSet = true);
-
-	void SetConquerorLevel(BYTE bValue) { m_points.bConquerorLevel = bValue; }
-	BYTE GetConquerorLevel() const { return m_points.bConquerorLevel; }
-
-	void SetConquerorExp(DWORD dwValue) { m_points.dwConquerorExp = dwValue; }
-	DWORD GetConquerorExp() const { return m_points.dwConquerorExp; }
-	DWORD GetNextConquerorExp() const;
-#endif
-
-	LPCHARACTER DistributeExp(); // 제일 많이 때린 사람을 리턴한다.
-
-	void DistributeHP(LPCHARACTER pkKiller);
-	void DistributeSP(LPCHARACTER pkKiller, int iMethod = 0);
-
-	void SetPosition(int pos);
-	bool IsPosition(int pos) const { return m_pointsInstant.position == pos ? true : false; }
-	int GetPosition() const { return m_pointsInstant.position; }
-
-	void SetPart(BYTE bPartPos, DWORD dwVal);
-	DWORD GetPart(BYTE bPartPos) const;
-	DWORD GetOriginalPart(BYTE bPartPos) const;
-
-	void SetHP(int val) { m_points.iHP = val; }
-	int GetHP() const { return m_points.iHP; }
-
-	void SetSP(int val) { m_points.iSP = val; }
-	int GetSP() const { return m_points.iSP; }
-
-	void SetMaxHP(int val) { m_pointsInstant.iMaxHP = val; }
-	int GetMaxHP() const { return m_pointsInstant.iMaxHP; }
-
-	void SetMaxSP(int val) { m_pointsInstant.iMaxSP = val; }
-	int GetMaxSP() const { return m_pointsInstant.iMaxSP; }
-
-	void SetStamina(int iValue) { m_points.iStamina = iValue; }
-	int GetStamina() const { return m_points.iStamina; }
-
-	void SetMaxStamina(int iValue) { m_pointsInstant.iMaxStamina = iValue; }
-	int GetMaxStamina() const { return m_pointsInstant.iMaxStamina; }
-
-	void SetRandomHP(int iValue) { m_points.iRandomHP = iValue; }
-	int GetRandomHP() const { return m_points.iRandomHP; }
-
-	void SetRandomSP(int iValue) { m_points.iRandomSP = iValue; }
-	int GetRandomSP() const { return m_points.iRandomSP; }
-
-	int GetHPPct() const;
-
-	void SetRealPoint(POINT_TYPE wPointType, POINT_VALUE lPointValue);
-	POINT_VALUE GetRealPoint(POINT_TYPE wPointType) const;
-
-	void SetPoint(POINT_TYPE wPointType, POINT_VALUE lPointValue);
-	POINT_VALUE GetPoint(POINT_TYPE wPointType) const;
-
-	POINT_VALUE GetLimitPoint(POINT_TYPE wPointType) const;
-	POINT_VALUE GetPolymorphPoint(POINT_TYPE wPointType) const;
-
-	const TMobTable& GetMobTable() const;
-	BYTE GetMobRank() const;
-	BYTE GetMobType() const;
-	BYTE GetMobBattleType() const;
-	BYTE GetMobSize() const;
-	DWORD GetMobDamageMin() const;
-	DWORD GetMobDamageMax() const;
-	WORD GetMobAttackRange() const;
-	DWORD GetMobDropItemVnum() const;
-	float GetMobDamageMultiply() const;
-#if defined(__ELEMENT_SYSTEM__)
-	int GetMobElement(BYTE bElement) const;
-#endif
-	float GetMonsterHitRange() const;
-
-	// NEWAI
-	bool IsBerserker() const;
-	bool IsBerserk() const;
-	void SetBerserk(bool mode);
-
-	bool IsStoneSkinner() const;
-
-	bool IsGodSpeeder() const;
-	bool IsGodSpeed() const;
-	void SetGodSpeed(bool mode);
-
-	bool IsDeathBlower() const;
-	bool IsDeathBlow() const;
-
-	bool IsHealer() const;
-	bool IsFaller() const;
-
-	bool IsReviver() const;
-	bool HasReviverInParty() const;
-	bool IsRevive() const;
-	void SetRevive(bool mode);
-	// NEWAI END
-
-	bool IsRaceFlag(DWORD dwBit) const;
-	bool IsSummonMonster() const;
-	DWORD GetSummonVnum() const;
-
-	int m_newSummonInterval;
-	int m_lastSummonTime;
-
-	bool CanSummonMonster() const;
-	void MarkSummonedMonster();
-
-	DWORD GetPolymorphItemVnum() const;
-	DWORD GetMonsterDrainSPPoint() const;
-
-	void MainCharacterPacket(); // 내가 메인캐릭터라고 보내준다.
-
-	void ComputePoints();
-	void ComputeBattlePoints();
-
-	void PointChange(POINT_TYPE wPointType, POINT_VALUE lPointAmount, bool bAmount = false, bool bBroadcast = false);
-	void PointsPacket();
-	void UpdatePointsPacket(POINT_TYPE wPointType, POINT_VALUE lPointValue, POINT_VALUE lPointAmount = 0, bool bAmount = false, bool bBroadcast = false);
-
-	void ApplyPoint(POINT_TYPE wApplyType, POINT_VALUE lApplyValue);
-	void CheckMaximumPoints(); // HP, SP 등의 현재 값이 최대값 보다 높은지 검사하고 높다면 낮춘다.
-
-
-	bool Show(long lMapIndex, long x, long y, long z = LONG_MAX, bool bShowSpawnMotion = false
-#if defined(__WJ_SHOW_MOB_INFO__)
-		, bool bAggressive = false
-#endif
-	);
-
-	void Sitdown(int is_ground);
-	void Standup();
-
-	void SetRotation(float fRot);
-	void SetRotationToXY(long x, long y);
-	float GetRotation() const { return m_pointsInstant.fRot; }
-
-	void MotionPacketEncode(BYTE motion, LPCHARACTER victim, struct packet_motion* packet);
-	void Motion(BYTE motion, LPCHARACTER victim = NULL);
-
-	void ChatPacket(BYTE type, const char* format, ...);
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	void ChatPacket(packet_chat pack_chat, const char* format, ...);
-#endif
-	void MonsterChat(BYTE bMonsterChatType);
-	void SendGreetMessage();
-
-	void ResetPoint(int iLv);
-	void ResetExp();
-
-#if defined(__CONQUEROR_LEVEL__)
-	void ResetConquerorPoint(int iLv);
-	void ResetConquerorExp();
-#endif
-
-	void SetBlockMode(BYTE bFlag);
-	void SetBlockModeForce(BYTE bFlag);
-	bool IsBlockMode(BYTE bFlag) const { return (m_pointsInstant.bBlockMode & bFlag) ? true : false; }
-#ifdef __OFFLINE_SHOP__
-	void SendUnlockedShopDeco();
-	void SetUnlockShopSkin(BYTE bFlag);
-	void SetUnlockShopBanner(BYTE bFlag);
-	bool IsUnlockedShopSkin(BYTE bFlag) const { return (m_pointsInstant.bUnlockedShopSkin & bFlag) ? true : false; }
-	bool IsUnlockedShopBanner(BYTE bFlag) const { return (m_pointsInstant.bUnlockedShopBanner & bFlag) ? true : false; }
-#endif
-	bool IsPolymorphed() const { return m_dwPolymorphRace > 0; }
-	bool IsPolyMaintainStat() const { return m_bPolyMaintainStat; } // 이전 스텟을 유지하는 폴리모프.
-	void SetPolymorph(DWORD dwRaceNum, bool bMaintainStat = false);
-	DWORD GetPolymorphVnum() const { return m_dwPolymorphRace; }
-	int GetPolymorphPower() const;
-
-	// FISING
-	void fishing();
-	void fishing_take();
-	bool IsFishing() const { return m_pkFishingEvent ? true : false; }
-	// END_OF_FISHING
-
-	// MINING
-	void mining(LPCHARACTER chLoad);
-	void mining_cancel();
-	void mining_take();
-	bool IsMining() const { return m_pkMiningEvent ? true : false; }
-	// END_OF_MINING
-
-	void ResetPlayTime(DWORD dwTimeRemain = 0);
-
-	void CreateFly(BYTE bType, LPCHARACTER pkVictim);
-
-	void ResetChatCounter() { m_bChatCounter = 0; }
-	void IncreaseChatCounter() { ++m_bChatCounter; }
-	BYTE GetChatCounter() const { return m_bChatCounter; }
-
-	void ResetWhisperCounter() { m_bWhisperCounter = 0; }
-	bool IncreaseWhisperCounter() { ++m_bWhisperCounter; return m_bWhisperCounter; }
-	BYTE GetWhisperCounter() const { return m_bWhisperCounter; }
-
-protected:
-	DWORD m_dwPolymorphRace;
-	bool m_bPolyMaintainStat;
-	DWORD m_dwLoginPlayTime;
-	DWORD m_dwPlayerID;
-	DWORD m_dwTargetVID;
-	VID m_vid;
-	std::string m_stName;
-	BYTE m_bCharType;
-
-	CHARACTER_POINT m_points;
-	CHARACTER_POINT_INSTANT m_pointsInstant;
-
-	int m_iMoveCount;
-	DWORD m_dwPlayStartTime;
-	BYTE m_bAddChrState;
-	bool m_bSkipSave;
-	BYTE m_bChatCounter;
-	BYTE m_bWhisperCounter;
-
-	// End of Basic Points
-
-	//////////////////////////////////////////////////////////////////////////////////
-	// Move & Synchronize Positions
-	//////////////////////////////////////////////////////////////////////////////////
-public:
-	bool IsStateMove() const { return IsState((CState&)m_stateMove); }
-	bool IsStateIdle() const { return IsState((CState&)m_stateIdle); }
-	bool IsWalking() const { return m_bNowWalking || GetStamina() <= 0; }
-	void SetWalking(bool bWalkFlag) { m_bWalking = bWalkFlag; }
-	void SetNowWalking(bool bWalkFlag);
-	void ResetWalking() { SetNowWalking(m_bWalking); }
-
-	bool Goto(long x, long y); // 바로 이동 시키지 않고 목표 위치로 BLENDING 시킨다.
-	void Stop();
-
-	bool CanMove() const; // 이동할 수 있는가?
-
-	void SyncPacket();
-	bool Sync(long x, long y); // 실제 이 메소드로 이동 한다 (각 종 조건에 의한 이동 불가가 없음)
-	bool Move(long x, long y); // 조건을 검사하고 Sync 메소드를 통해 이동 한다.
-	void OnMove(bool bIsAttack = false); // 움직일때 불린다. Move() 메소드 이외에서도 불릴 수 있다.
-	DWORD GetMotionMode() const;
-	float GetMoveMotionSpeed() const;
-	float GetMoveSpeed() const;
-	void CalculateMoveDuration();
-	void SendMovePacket(BYTE bFunc, BYTE bArg, DWORD x, DWORD y, DWORD dwDuration, DWORD dwTime = 0, int iRot = -1);
-
-	DWORD GetCurrentMoveDuration() const { return m_dwMoveDuration; }
-	DWORD GetWalkStartTime() const { return m_dwWalkStartTime; }
-	DWORD GetLastMoveTime() const { return m_dwLastMoveTime; }
-	DWORD GetLastAttackTime() const { return m_dwLastAttackTime; }
-
-	void SetLastAttacked(DWORD time); // 마지막으로 공격받은 시간 및 위치를 저장함
-
-	bool SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList = true);
-	bool IsSyncOwner(LPCHARACTER ch) const;
-
-	bool WarpSet(long x, long y, long lRealMapIndex = 0);
-	void SetWarpLocation(long lMapIndex, long x, long y);
-	void WarpEnd();
-	const PIXEL_POSITION& GetWarpPosition() const { return m_posWarp; }
-	bool WarpToPID(DWORD dwPID, bool bWarpForce = false);
-
-	void SaveExitLocation();
-	void ExitToSavedLocation();
-
-	void StartStaminaConsume();
-	void StopStaminaConsume();
-	bool IsStaminaConsume() const;
-	bool IsStaminaHalfConsume() const;
-
-	void ResetStopTime();
-	DWORD GetStopTime() const;
-
-#if defined(__MOVE_CHANNEL__)
-	bool MoveChannel(long lNewAddr, WORD wNewPort);
-	bool StartMoveChannel(long lNewAddr, WORD wNewPort);
-#endif
-
-protected:
-	void ClearSync();
-
-	float m_fSyncTime;
-	LPCHARACTER m_pkChrSyncOwner;
-	CHARACTER_LIST m_kLst_pkChrSyncOwned; // 내가 SyncOwner인 자들
-
-	PIXEL_POSITION m_posDest;
-	PIXEL_POSITION m_posStart;
-	PIXEL_POSITION m_posWarp;
-	long m_lWarpMapIndex;
-
-	PIXEL_POSITION m_posExit;
-	long m_lExitMapIndex;
-
-	DWORD m_dwMoveStartTime;
-	DWORD m_dwMoveDuration;
-
-	DWORD m_dwLastMoveTime;
-	DWORD m_dwLastAttackTime;
-	DWORD m_dwWalkStartTime;
-	DWORD m_dwStopTime;
-
-	bool m_bWalking;
-	bool m_bNowWalking;
-	bool m_bStaminaConsume;
-
-	// End
-
-	// Quickslot 관련
-public:
-	void SyncQuickslot(BYTE bType, WORD wOldPos, WORD wNewPos);
-	bool GetQuickslot(BYTE pos, TQuickslot** ppSlot);
-	bool SetQuickslot(BYTE pos, TQuickslot& rSlot);
-	bool DelQuickslot(BYTE pos);
-	bool SwapQuickslot(BYTE a, BYTE b);
-	void ChainQuickslotItem(LPITEM pItem, BYTE bType, WORD wOldPos);
-	void MoveQuickSlotItem(BYTE bOldType, WORD wOldPos, BYTE bNewType, WORD wNewPos);
-
-	void CheckQuickSlotItems();
-	bool CanAddToQuickSlot(LPITEM pItem);
-
-protected:
-	TQuickslot m_quickslot[QUICKSLOT_MAX_NUM];
-
-#if defined(__LUCKY_BOX__)
-public:
-	void SetLuckyBoxSrcItem(LPITEM lpItem);
-	void SendLuckyBoxInfo();
-	void LuckyBoxRetry();
-	void LuckyBoxReceive();
-	int GetLuckyBoxPrice() const;
-	bool IsLuckyBoxOpen() const;
-	void ResetLuckyBoxData();
-
-private:
-	struct
-	{
-		DWORD dwSrcItemVNum;
-		DWORD dwSrcItemID;
-		WORD wSrcSlotIndex;
-		BYTE bTryCount;
-		DWORD dwItemVNum;
-		BYTE bItemCount;
-	} m_sLuckyBox;
-#endif
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Affect
-public:
-	void StartAffectEvent();
-	void ClearAffect(bool bSave = false);
-	void ComputeAffect(const CAffect* pkAff, bool bAdd);
-	bool AddAffect(DWORD dwType, POINT_TYPE wApplyOn, POINT_VALUE lApplyValue, DWORD dwFlag, long lDuration, long lSPCost, bool bOverride, bool IsCube = false
-#if defined(__AFFECT_RENEWAL__)
-		, bool bRealTime = false
-#endif
-#if defined(__9TH_SKILL__)
-		, long lValue = 0 /* Skill iAmount2 */
-#endif
-	);
-#if defined(__AFFECT_RENEWAL__)
-	bool AddRealTimeAffect(DWORD dwType, POINT_TYPE wApplyOn, POINT_VALUE lApplyValue, DWORD dwFlag, long lDuration, long lSPCost, bool bOverride, bool IsCube = false, bool bRealTime = true);
-#endif
-	void RefreshAffect();
-	bool RemoveAffect(DWORD dwType);
-#if defined(__SOUL_SYSTEM__)
-	void RemoveAffect(DWORD dwType, POINT_TYPE wApplyType);
-#endif
-	bool IsAffectFlag(DWORD dwAff) const;
-
-	bool UpdateAffect(); // called from EVENT
-	int ProcessAffect();
-
-	void LoadAffect(DWORD dwCount, TPacketAffectElement* pElements);
-	void SaveAffect();
-
-public:
-	// Affect loading이 끝난 상태인가?
-	bool IsLoadedAffect() const { return m_bIsLoadedAffect; }
-
-	bool IsGoodAffect(BYTE bAffectType) const;
-
-	void RemoveGoodAffect();
-	void RemoveBadAffect();
-
-	CAffect* FindAffect(DWORD dwType, POINT_TYPE wApplyType = APPLY_NONE) const;
-	const AffectContainerList& GetAffectContainer() const { return m_list_pkAffect; }
-	bool RemoveAffect(CAffect* pkAff);
-
-	//void SetAffectStack(CAffect* pkAff, BYTE value);
-	//BYTE GetAffectStack(CAffect* pkAff);
-	//void ClearAffectStack(CAffect* pkAff);
-	//
-	//AffectStackMap m_map_affectStack;
-
-protected:
-	bool m_bIsLoadedAffect;
-	TAffectFlag m_afAffectFlag;
-	AffectContainerList m_list_pkAffect;
-
-public:
-	// PARTY_JOIN_BUG_FIX
-	void SetParty(LPPARTY pkParty);
-	LPPARTY GetParty() const { return m_pkParty; }
-
-	bool RequestToParty(LPCHARACTER leader);
-	void DenyToParty(LPCHARACTER member);
-	void AcceptToParty(LPCHARACTER member);
-
-	/// 자신의 파티에 다른 character 를 초대한다.
-	/**
-	* @param pchInvitee 초대할 대상 character. 파티에 참여 가능한 상태이어야 한다.
-	*
-	* 양측 character 의 상태가 파티에 초대하고 초대받을 수 있는 상태가 아니라면 초대하는 캐릭터에게 해당하는 채팅 메세지를 전송한다.
-	**/
-	void PartyInvite(LPCHARACTER pchInvitee);
-
-	/// 초대했던 character 의 수락을 처리한다.
-	/**
-	* @param pchInvitee 파티에 참여할 character. 파티에 참여가능한 상태이어야 한다.
-	*
-	* pchInvitee 가 파티에 가입할 수 있는 상황이 아니라면 해당하는 채팅 메세지를 전송한다.
-	**/
-	void PartyInviteAccept(LPCHARACTER pchInvitee);
-
-	/// 초대했던 character 의 초대 거부를 처리한다.
-	/**
-	* @param [in] dwPID 초대 했던 character 의 PID
-	**/
-	void PartyInviteDeny(DWORD dwPID);
-
-	bool BuildUpdatePartyPacket(TPacketGCPartyUpdate& out);
-	int GetLeadershipSkillLevel() const;
-#if defined(__PARTY_PROFICY__)
-	int GetRoleProficiencySkillLevel() const;
-#endif
-#if defined(__PARTY_INSIGHT__)
-	int GetInSightSkillLevel() const;
-#endif
-
-	bool CanSummon(int iLeaderShip);
-
-	void SetPartyRequestEvent(LPEVENT pkEvent) { m_pkPartyRequestEvent = pkEvent; }
-
-protected:
-
-	/// 파티에 가입한다.
-	/**
-	* @param pkLeader 가입할 파티의 리더
-	**/
-	void PartyJoin(LPCHARACTER pkLeader);
-
-	/**
-	* 파티 가입을 할 수 없을 경우의 에러코드.
-	* Error code 는 시간에 의존적인가에 따라 변경가능한(mutable) type 과 정적(static) type 으로 나뉜다.
-	* Error code 의 값이 PERR_SEPARATOR 보다 낮으면 변경가능한 type 이고 높으면 정적 type 이다.
-	**/
-	enum PartyJoinErrCode
-	{
-		PERR_NONE = 0, ///< 처리성공
-		PERR_SERVER, ///< 서버문제로 파티관련 처리 불가
-		PERR_DUNGEON, ///< 캐릭터가 던전에 있음
-		PERR_OBSERVER, ///< 관전모드임
-		PERR_LVBOUNDARY, ///< 상대 캐릭터와 레벨차이가 남
-		PERR_LOWLEVEL, ///< 상대파티의 최고레벨보다 30레벨 낮음
-		PERR_HILEVEL, ///< 상대파티의 최저레벨보다 30레벨 높음
-		PERR_ALREADYJOIN, ///< 파티가입 대상 캐릭터가 이미 파티중
-		PERR_PARTYISFULL, ///< 파티인원 제한 초과
-		PERR_SEPARATOR, ///< Error type separator.
-		PERR_DIFFEMPIRE, ///< 상대 캐릭터와 다른 제국임
-		PERR_MAX ///< Error code 최고치. 이 앞에 Error code 를 추가한다.
-	};
-
-	/// 파티 가입이나 결성 가능한 조건을 검사한다.
-	/**
-	* @param pchLeader 파티의 leader 이거나 초대한 character
-	* @param pchGuest 초대받는 character
-	* @return 모든 PartyJoinErrCode 가 반환될 수 있다.
-	**/
-	static PartyJoinErrCode IsPartyJoinableCondition(const LPCHARACTER pchLeader, const LPCHARACTER pchGuest);
-
-	/// 파티 가입이나 결성 가능한 동적인 조건을 검사한다.
-	/**
-	* @param pchLeader 파티의 leader 이거나 초대한 character
-	* @param pchGuest 초대받는 character
-	* @return mutable type 의 code 만 반환한다.
-	**/
-	static PartyJoinErrCode IsPartyJoinableMutableCondition(const LPCHARACTER pchLeader, const LPCHARACTER pchGuest);
-
-	LPPARTY m_pkParty;
-	DWORD m_dwLastDeadTime;
-	LPEVENT m_pkPartyRequestEvent;
-
-	/**
-	* 파티초청 Event map.
-	* key: 초대받은 캐릭터의 PID
-	* value: event의 pointer
-	*
-	* 초대한 캐릭터들에 대한 event map.
-	**/
-	typedef std::map<DWORD, LPEVENT> EventMap;
-	EventMap m_PartyInviteEventMap;
-
-	// END_OF_PARTY_JOIN_BUG_FIX
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Dungeon
-public:
-	void SetDungeon(LPDUNGEON pkDungeon);
-	LPDUNGEON GetDungeon() const { return m_pkDungeon; }
-	LPDUNGEON GetDungeonForce() const;
-protected:
-	LPDUNGEON m_pkDungeon;
-	int m_iEventAttr;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Guild
-public:
-	void SetGuild(CGuild* pGuild);
-	CGuild* GetGuild() const { return m_pGuild; }
-
-	void SetWarMap(CWarMap* pWarMap);
-	CWarMap* GetWarMap() const { return m_pWarMap; }
-
-protected:
-	CGuild* m_pGuild;
-	DWORD m_dwUnderGuildWarInfoMessageTime;
-	CWarMap* m_pWarMap;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Item related
-public:
-	bool CanHandleItem(bool bSkipRefineCheck = false, bool bSkipObserver = false); // 아이템 관련 행위를 할 수 있는가?
-
-	bool IsItemLoaded() const { return m_bItemLoaded; }
-	void SetItemLoaded() { m_bItemLoaded = true; }
-
-	void ClearItem();
-
-	LPITEM GetInventoryItem(WORD wCell) const;
-	LPITEM GetEquipmentItem(WORD wCell) const;
-	LPITEM GetDragonSoulInventoryItem(WORD wCell) const;
-	LPITEM GetBeltInventoryItem(WORD wCell) const;
-
-	void SetItem(TItemPos Cell, LPITEM item
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		, bool isHighLight = false
-#endif
-	);
-
-	LPITEM GetItem(TItemPos Cell) const;
-
-	bool IsEmptyItemGrid(TItemPos Cell, BYTE size, int iExceptionCell = -1) const;
-
-	void SetWear(WORD wCell, LPITEM item);
-	LPITEM GetWear(WORD wCell) const;
-
-	// MYSHOP_PRICE_LIST
-	void UseSilkBotary(void); /// 비단 보따리 아이템의 사용
-
-	/// DB 캐시로 부터 받아온 가격정보 리스트를 유저에게 전송하고 보따리 아이템 사용을 처리한다.
-	/**
-	* @param [in] p 가격정보 리스트 패킷
-	*
-	* 접속한 후 처음 비단 보따리 아이템 사용 시 UseSilkBotary 에서 DB 캐시로 가격정보 리스트를 요청하고
-	* 응답받은 시점에 이 함수에서 실제 비단보따리 사용을 처리한다.
-	**/
-	void UseSilkBotaryReal(const TPacketMyshopPricelistHeader* p);
-	// END_OF_MYSHOP_PRICE_LIST
-
-	bool UseItemEx(LPITEM item, TItemPos DestCell);
-	bool UseItem(TItemPos Cell, TItemPos DestCell = NPOS);
-
-	// ADD_REFINE_BUILDING
-	bool IsRefineThroughGuild() const;
-	CGuild* GetRefineGuild() const;
-	int ComputeRefineFee(int iCost, int iMultiply = 5) const;
-	void PayRefineFee(int iTotalMoney);
-	void SetRefineNPC(LPCHARACTER ch);
-	// END_OF_ADD_REFINE_BUILDING
-
-	bool RefineItem(LPITEM pkItem, LPITEM pkTarget);
-	bool DropItem(TItemPos Cell, WORD wCount = 0);
-#if defined(__NEW_DROP_DIALOG__)
-	bool DestroyItem(TItemPos Cell);
-#endif
-	bool GiveRecallItem(LPITEM item);
-	void ProcessRecallItem(LPITEM item);
-
-	// void PotionPacket(int iPotionType);
-	void EffectPacket(BYTE bEffectNum, BYTE bEffectType = SE_TYPE_NORMAL, const PIXEL_POSITION& rEffectPos = { 0, 0, 0 });
-	void SpecificEffectPacket(const char filename[128]);
-
-	// ADD_MONSTER_REFINE
-	bool DoRefine(LPITEM item, bool bMoneyOnly = false);
-	// END_OF_ADD_MONSTER_REFINE
-
-	bool DoRefineWithScroll(LPITEM item);
-	bool RefineInformation(WORD wCell, BYTE bType, int iAdditionalCell = -1);
-
-	struct SRefineScrollData
-	{
-		BYTE bSuccessProb;
-		bool bKeepGrade;
-	};
-	SRefineScrollData GetScrollRefinePct(BYTE bProb, BYTE bRefineLevel, BYTE bScrollType);
-
-	void SetRefineMode(int iAdditionalCell = -1);
-	void ClearRefineMode();
-
-	bool GiveItem(LPCHARACTER victim, TItemPos Cell);
-	bool CanReceiveItem(LPCHARACTER from, LPITEM item) const;
-	void ReceiveItem(LPCHARACTER from, LPITEM item);
-	//bool GiveItemFromSpecialItemGroup(DWORD dwGroupNum, std::vector<DWORD>& dwItemVnums,
-	//	std::vector<DWORD>& dwItemCounts, std::vector<LPITEM>& item_gets, int& count);
-	bool GiveItemFromSpecialItemGroup(DWORD dwGroupNum);
-
-	bool MoveItem(TItemPos pos, TItemPos change_pos, WORD num);
-	bool PickupItem(DWORD vid
-#if defined(__PET_LOOT_AI__)
-		, bool PetLoot = false
-#endif
-	);
-	bool EquipItem(LPITEM item, int iCandidateCell = -1);
-	bool UnequipItem(LPITEM item);
-
-	// 현재 item을 착용할 수 있는 지 확인하고, 불가능 하다면 캐릭터에게 이유를 알려주는 함수
-	bool CanEquipNow(const LPITEM item, const TItemPos& srcCell = NPOS, const TItemPos& destCell = NPOS);
-	// 착용중인 item을 벗을 수 있는 지 확인하고, 불가능 하다면 캐릭터에게 이유를 알려주는 함수
-	bool CanUnequipNow(const LPITEM item, const TItemPos& srcCell = NPOS, const TItemPos& destCell = NPOS);
-
-	bool SwapItem(WORD wCell, WORD wDestCell);
-
-	LPITEM AutoGiveItem(DWORD dwItemVnum, WORD wCount = 1, int iRarePct = -1, bool bMsg = true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		, bool isHighLight = false
-#endif
-#if defined(__NEW_USER_CARE__)
-		, bool bSystemDrop = true
-#endif
-	);
-
-	void AutoGiveItem(LPITEM item, bool longOwnerShip = false, bool bMsg = true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		, bool isHighLight = false
-#endif
-	);
-
-	int GetEmptyInventory(BYTE size) const;
-	int GetEmptyInventoryCount(BYTE size) const;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	int GetEmptyDragonSoulInventory(LPITEM pItem) const;
-	void CopyDragonSoulItemGrid(std::vector<WORD>& vDragonSoulItemGrid) const;
-#endif
-
-	int CountEmptyInventory() const;
-	bool HasEnoughInventorySpace(std::vector<TItemData>& vItems) const;
-
-	int CountSpecifyItem(DWORD vnum, int iExceptionCell = -1
-#if defined(__SOUL_BIND_SYSTEM__)
-		, bool bIgnoreSealedItem = false
-#endif
-#if defined(__SET_ITEM__)
-		, bool bIgnoreSetValue = false
-#endif
-	) const;
-	void RemoveSpecifyItem(DWORD vnum, DWORD count = 1, int iExceptionCell = -1
-#if defined(__SOUL_BIND_SYSTEM__)
-		, bool bIgnoreSealedItem = false
-#endif
-#if defined(__SET_ITEM__)
-		, bool bIgnoreSetValue = false
-#endif
-	);
-	LPITEM FindSpecifyItem(DWORD dwVnum
-#if defined(__SOUL_BIND_SYSTEM__)
-		, bool bIgnoreSealedItem = false
-#endif
-#if defined(__SET_ITEM__)
-		, bool bIgnoreSetValue = false
-#endif
-	) const;
-	LPITEM FindItemByID(DWORD id) const;
-
-	int CountSpecifyTypeItem(BYTE type) const;
-	void RemoveSpecifyTypeItem(BYTE type, DWORD count = 1);
-
-	bool IsEquipUniqueItem(DWORD dwItemVnum) const;
-
-	// CHECK_UNIQUE_GROUP
-	bool IsEquipUniqueGroup(DWORD dwGroupVnum) const;
-	// END_OF_CHECK_UNIQUE_GROUP
-
-	void SendEquipment(LPCHARACTER pChar);
-	// End of Item
-
-protected:
-	/// 한 아이템에 대한 가격정보를 전송한다.
-	/**
-	* @param [in] dwItemVnum 아이템 vnum
-	* @param [in] dwItemPrice 아이템 가격
-	**/
-	void SendMyShopPriceListCmd(DWORD dwItemVnum, DWORD dwItemPrice
-#if defined(__CHEQUE_SYSTEM__)
-		, DWORD dwItemCheque
-#endif
-	);
-
-	bool m_bNoOpenedShop; ///< 이번 접속 후 개인상점을 연 적이 있는지의 여부(열었던 적이 없다면 true)
-
-	bool m_bItemLoaded;
-	int m_iRefineAdditionalCell;
-
-public:
-	bool IsUnderRefine() const { return m_bUnderRefine; }
-	void SetUnderRefine(bool bState) { m_bUnderRefine = bState; }
-protected:
-	bool m_bUnderRefine;
-	DWORD m_dwRefineNPCVID;
-
-public:
-	int GetGold() const { return m_points.iGold; }
-	void SetGold(int iValue) { m_points.iGold = iValue; }
-
-	bool DropGold(int iAmount);
-	void GiveGold(int iAmount); // 파티가 있으면 파티 분배, 로그 등의 처리
-
-	int GetAllowedGold() const;
-
-#if defined(__CHEQUE_SYSTEM__)
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Cheque related
-	int GetCheque() const { return m_points.iCheque; }
-	void SetCheque(int iValue) { m_points.iCheque = iValue; }
-	bool DropCheque(int iAmount);
-	void GiveCheque(int iAmount);
-	// End of Cheque
-#endif
-
-#if defined(__GEM_SYSTEM__)
-	////////////////////////////////////////////////////////////////////////////////////////
-	int GetGem() const { return m_points.iGem; }
-	void SetGem(int iValue) { m_points.iGem = iValue; }
-	void GiveGem(int iAmount);
-#endif
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Shop related
-public:
-	void SetShop(LPSHOP pkShop);
-	LPSHOP GetShop() const { return m_pkShop; }
-	void ShopPacket(BYTE bSubHeader);
-
-	void SetShopOwner(LPCHARACTER ch) { m_pkChrShopOwner = ch; }
-	LPCHARACTER GetShopOwner() const { return m_pkChrShopOwner; }
-
-#ifdef __OFFLINE_SHOP__
-	void SetShowOfflineShop(DWORD option) { dwIsShowShops = option; UpdateSectree();}
-	DWORD GetShowOfflineShop()  const { return dwIsShowShops;}
-#endif
-
-	void OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE bItemCount);
-	LPSHOP GetMyShop() const { return m_pkMyShop; }
-	void CloseMyShop();
-
-protected:
-	LPSHOP m_pkShop;
-	LPSHOP m_pkMyShop;
-	std::string m_stShopSign;
-	LPCHARACTER m_pkChrShopOwner;
-	// End of shop
-
-#ifdef __OFFLINE_SHOP__
-	DWORD dwIsShowShops;
-#endif
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Exchange related
-public:
-	bool ExchangeStart(LPCHARACTER victim);
-	void SetExchange(CExchange* pkExchange);
-	CExchange* GetExchange() const { return m_pkExchange; }
-
-protected:
-	CExchange* m_pkExchange;
-	// End of Exchange
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Battle
-public:
-	struct TBattleInfo
-	{
-		int iTotalDamage;
-		int iAggro;
-
-		TBattleInfo(int iTot, int iAggr)
-			: iTotalDamage(iTot), iAggro(iAggr)
-		{}
-	};
-	typedef std::map<VID, TBattleInfo> TDamageMap;
-
-	typedef struct SAttackLog
-	{
-		DWORD dwVID;
-		DWORD dwTime;
-	} AttackLog;
-
-	bool Damage(LPCHARACTER pAttacker, int dam, EDamageType type = DAMAGE_TYPE_NORMAL);
-	bool __Profile__Damage(LPCHARACTER pAttacker, int dam, EDamageType type = DAMAGE_TYPE_NORMAL);
-	void DeathPenalty(BYTE bExpLossPercent);
-	void ReviveInvisible(int iDur);
-
-	bool Attack(LPCHARACTER pkVictim, BYTE bType = 0);
-	bool IsAlive() const { return m_pointsInstant.position == POS_DEAD ? false : true; }
-	bool CanFight() const;
-
-	bool CanBeginFight() const;
-	void BeginFight(LPCHARACTER pkVictim); // pkVictimr과 싸우기 시작한다. (강제적임, 시작할 수 있나 체크하려면 CanBeginFight을 사용)
-
-	bool CounterAttack(LPCHARACTER pkChr); // 반격하기 (몬스터만 사용)
-
-	bool IsStun() const;
-	void Stun(bool bImmediate = false);
-	bool IsDead() const;
-	void Dead(LPCHARACTER pkKiller = NULL, bool bImmediateDead = false);
-
-	void Reward(bool bItemDrop);
-	void RewardGold(LPCHARACTER pkAttacker);
-
-	bool Shoot(BYTE bType);
-	void FlyTarget(DWORD dwTargetVID, long x, long y, BYTE bHeader);
-
-	void ForgetMyAttacker(bool bRevive = true);
-	void AggregateMonster();
-	void AttractRanger();
-	void PullMonster();
-
-	int GetArrowAndBow(LPITEM* ppkBow, LPITEM* ppkArrow, int iArrowCount = 1);
-	void UseArrow(LPITEM pkArrow, DWORD dwArrowCount);
-
-	void AttackedByPoison(LPCHARACTER pkAttacker);
-	void RemovePoison();
-
-	void AttackedByBleeding(LPCHARACTER pkAttacker);
-	void RemoveBleeding();
-
-	void AttackedByFire(LPCHARACTER pkAttacker, int amount, int count);
-	void RemoveFire();
-
-	void UpdateAlignment(int iAmount);
-	int GetAlignment() const;
-
-	// 선악치 얻기 
-	int GetRealAlignment() const;
-	void ShowAlignment(bool bShow);
-
-	UINT GetAlignmentGrade() const;
-
-	void SetKillerMode(bool bOn);
-	bool IsKillerMode() const;
-	void UpdateKillerMode();
-
-	BYTE GetPKMode() const;
-	void SetPKMode(BYTE bPKMode);
-
-	void ItemDropPenalty(LPCHARACTER pkKiller);
-
-	void UpdateAggrPoint(LPCHARACTER ch, EDamageType type, int dam);
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// HACK
-public:
-	void SetComboSequence(BYTE seq);
-	BYTE GetComboSequence() const;
-
-	void SetLastComboTime(DWORD time);
-	DWORD GetLastComboTime() const;
-
-	int GetValidComboInterval() const;
-	void SetValidComboInterval(int interval);
-
-	BYTE GetComboIndex() const;
-
-	void IncreaseComboHackCount(int k = 1);
-	void ResetComboHackCount();
-	void SkipComboAttackByTime(int interval);
-	DWORD GetSkipComboAttackByTime() const;
-
-		// Flood guard: rate-limit FUNC_COMBO packets (DoS mitigation)
-		bool CheckComboFlood(DWORD dwTime);
-
-protected:
-	BYTE m_bComboSequence;
-	DWORD m_dwLastComboTime;
-	int m_iValidComboInterval;
-	BYTE m_bComboIndex;
-	int m_iComboHackCount;
-	DWORD m_dwSkipComboAttackByTime;
-	DWORD m_dwComboFloodWindow;
-	BYTE m_bComboFloodCount;
-
-protected:
-	void UpdateAggrPointEx(LPCHARACTER ch, EDamageType type, int dam, TBattleInfo& info);
-	void ChangeVictimByAggro(int iNewAggro, LPCHARACTER pNewVictim);
-
-	DWORD m_dwFlyTargetID;
-	std::vector<DWORD> m_vec_dwFlyTargets;
-	TDamageMap m_map_kDamage; // 어떤 캐릭터가 나에게 얼마만큼의 데미지를 주었는가?
-	//AttackLog m_kAttackLog;
-	DWORD m_dwKillerPID;
-
-	int m_iAlignment; // Lawful / Chaotic value -200000 ~ 200000
-	int m_iRealAlignment;
-	int m_iKillerModePulse;
-	BYTE m_bPKMode;
-
-	// Aggro
-	DWORD m_dwLastVictimSetTime;
-	int m_iMaxAggro;
-	// End of Battle
-
-	// Stone
-public:
-	void SetStone(LPCHARACTER pkChrStone);
-	void ClearStone();
-	void DetermineDropMetinStone();
-	DWORD GetDropMetinStoneVnum() const { return m_dwDropMetinStone; }
-	BYTE GetDropMetinStonePct() const { return m_bDropMetinStonePct; }
-
-protected:
-	LPCHARACTER m_pkChrStone; // 나를 스폰한 돌
-	CHARACTER_SET m_set_pkChrSpawnedBy; // 내가 스폰한 놈들
-	DWORD m_dwDropMetinStone;
-	BYTE m_bDropMetinStonePct;
-	// End of Stone
-
-public:
-	enum
-	{
-		SKILL_UP_BY_POINT,
-		SKILL_UP_BY_BOOK,
-		SKILL_UP_BY_TRAIN,
-
-		// ADD_GRANDMASTER_SKILL
-		SKILL_UP_BY_QUEST,
-		// END_OF_ADD_GRANDMASTER_SKILL
-	};
-
-	void SkillLevelPacket();
-	void SkillLevelUp(DWORD dwVnum, BYTE bMethod = SKILL_UP_BY_POINT);
-	bool SkillLevelDown(DWORD dwVnum);
-	// ADD_GRANDMASTER_SKILL
-	bool UseSkill(DWORD dwVnum, LPCHARACTER pkVictim, bool bUseGrandMaster = true);
-	void ResetSkill();
-#if defined(__SKILL_COOLTIME_UPDATE__)
-	void ResetSkillCoolTimes();
-#endif
-	void SetSkillLevel(DWORD dwVnum, BYTE bLev);
-	int GetUsedSkillMasterType(DWORD dwVnum);
-
-	bool IsLearnableSkill(DWORD dwSkillVnum) const;
-	// END_OF_ADD_GRANDMASTER_SKILL
-
-	bool CheckSkillHitCount(const BYTE SkillID, const VID dwTargetVID);
-	bool CanUseSkill(DWORD dwSkillVnum) const;
-	bool IsUsableSkillMotion(DWORD dwMotionIndex) const;
-	int GetSkillLevel(DWORD dwVnum) const;
-	int GetSkillMasterType(DWORD dwVnum) const;
-	int GetSkillPower(DWORD dwVnum, BYTE bLevel = 0) const;
-
-	time_t GetSkillNextReadTime(DWORD dwVnum) const;
-	void SetSkillNextReadTime(DWORD dwVnum, time_t time);
-	void SkillLearnWaitMoreTimeMessage(DWORD dwVnum);
-
-	void ComputePassiveSkill(DWORD dwVnum);
-#ifdef ENABLE_QUEEN_NETHIS
-	int ComputeSnakeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel);
-#endif
-	int ComputeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
-	int ComputeSkillParty(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
-	int ComputeSkillAtPosition(DWORD dwVnum, const PIXEL_POSITION& posTarget, BYTE bSkillLevel = 0);
-#if defined(__PVP_BALANCE_IMPROVING__)
-	int ComputeGyeongGongSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
-#endif
-	void ComputeSkillPoints();
-
-	void SetSkillGroup(BYTE bSkillGroup);
-	BYTE GetSkillGroup() const { return m_points.bSkillGroup; }
-
-	int ComputeCooltime(int time);
-
-	void GiveRandomSkillBook();
-	void GiveSkillBook(DWORD dwSkillVnum, WORD wCount);
-
-	void DisableCooltime();
-	bool LearnSkillByBook(DWORD dwSkillVnum, BYTE bProb = 0);
-	bool LearnGrandMasterSkill(DWORD dwSkillVnum);
-
-#if defined(__CONQUEROR_LEVEL__)
-	bool IsConquerorSkill(DWORD dwVnum) const;
-#endif
-
-private:
-	bool m_bDisableCooltime;
-	DWORD m_dwLastSkillTime; ///< 마지막으로 skill 을 쓴 시간(millisecond).
-	// End of Skill
-
-	// MOB_SKILL
-public:
-	bool HasMobSkill() const;
-	size_t CountMobSkill() const;
-	const TMobSkillInfo* GetMobSkill(unsigned int idx) const;
-	bool CanUseMobSkill(unsigned int idx) const;
-	bool UseMobSkill(unsigned int idx);
-	void ResetMobSkillCooltime();
-protected:
-	DWORD m_adwMobSkillCooltime[MOB_SKILL_MAX_NUM];
-	// END_OF_MOB_SKILL
-
-	// for SKILL_MUYEONG
-public:
-	void StartMuyeongEvent();
-	void StopMuyeongEvent();
-
-#if defined(__PVP_BALANCE_IMPROVING__)
-	void StartGyeongGongEvent();
-	void StopGyeongGongEvent();
-#endif
-
-#if defined(__9TH_SKILL__)
-	void StartCheonunEvent(BYTE bChance, BYTE bDuration);
-	void StopCheonunEvent();
-#endif
-
-private:
-	LPEVENT m_pkMuyeongEvent;
-#ifdef ENABLE_QUEEN_NETHIS
-	LPEVENT m_pkSnakeSkillEvent;
-#endif
-#if defined(__PVP_BALANCE_IMPROVING__)
-	LPEVENT m_pkGyeongGongEvent;
-#endif
-#if defined(__9TH_SKILL__)
-	LPEVENT m_pkCheonunEvent;
-#endif
-
-	// for SKILL_CHAIN lighting
-public:
-	int GetChainLightningIndex() const { return m_iChainLightingIndex; }
-	void IncChainLightningIndex() { ++m_iChainLightingIndex; }
-	void AddChainLightningExcept(LPCHARACTER ch) { m_setExceptChainLighting.insert(ch); }
-	void ResetChainLightningIndex() { m_iChainLightingIndex = 0; m_setExceptChainLighting.clear(); }
-	int GetChainLightningMaxCount() const;
-	const CHARACTER_SET& GetChainLightingExcept() const { return m_setExceptChainLighting; }
-
-private:
-	int m_iChainLightingIndex;
-	CHARACTER_SET m_setExceptChainLighting;
-
-	// for SKILL_EUNHYUNG
-public:
-	void SetAffectedEunhyung();
-	void ClearAffectedEunhyung() { m_dwAffectedEunhyungLevel = 0; }
-	bool GetAffectedEunhyung() const { return m_dwAffectedEunhyungLevel; }
-
-private:
-	DWORD m_dwAffectedEunhyungLevel;
-
-	//
-	// Skill levels
-	//
-protected:
-	TPlayerSkill* m_pSkillLevels;
-	std::unordered_map<BYTE, int> m_SkillDamageBonus;
-	std::map<int, TSkillUseInfo> m_SkillUseInfo;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// AI related
-public:
-	void AssignTriggers(const TMobTable* table);
-	LPCHARACTER GetVictim() const; // 공격할 대상 리턴
-	void SetVictim(LPCHARACTER pkVictim);
-	LPCHARACTER GetNearestVictim(LPCHARACTER pkChr);
-	LPCHARACTER GetProtege() const; // 보호해야 할 대상 리턴
-
-	bool Follow(LPCHARACTER pkChr, float fMinimumDistance = 150.0f);
-	bool Return();
-	bool IsGuardNPC() const;
-	bool IsChangeAttackPosition(LPCHARACTER target) const;
-	void ResetChangeAttackPositionTime() { m_dwLastChangeAttackPositionTime = get_dword_time() - AI_CHANGE_ATTACK_POISITION_TIME_NEAR; }
-	void SetChangeAttackPositionTime() { m_dwLastChangeAttackPositionTime = get_dword_time(); }
-
-	bool OnIdle();
-
-	void OnAttack(LPCHARACTER pkChrAttacker);
-	void OnClick(LPCHARACTER pkChrCauser);
-
-	VID m_kVIDVictim;
-
-protected:
-	DWORD m_dwLastChangeAttackPositionTime;
-	CTrigger m_triggerOnClick;
-	// End of AI
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Target
-protected:
-	LPCHARACTER m_pkChrTarget; // 내 타겟
-	CHARACTER_SET m_set_pkChrTargetedBy; // 나를 타겟으로 가지고 있는 사람들
-
-public:
-	void SetTarget(LPCHARACTER pkChrTarget);
-	void BroadcastTargetPacket();
-	void ClearTarget();
-	void CheckTarget();
-	LPCHARACTER GetTarget() const { return m_pkChrTarget; }
-	LPCHARACTER GetTargetSafe();
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Safebox
-public:
-	int GetSafeboxSize() const;
-	void QuerySafeboxSize();
-	void SetSafeboxSize(int size);
-
-	CSafebox* GetSafebox() const;
-	void LoadSafebox(int iSize, DWORD dwGold, int iItemCount, TPlayerItem* pItems);
-	void ChangeSafeboxSize(BYTE bSize);
-	void CloseSafebox();
-
-	/// 창고 열기 요청
-	/**
-	* @param [in] pszPassword 1자 이상 6자 이하의 창고 비밀번호
-	*
-	* DB 에 창고열기를 요청한다.
-	* 창고는 중복으로 열지 못하며, 최근 창고를 닫은 시간으로 부터 10초 이내에는 열 지 못한다.
-	**/
-	void ReqSafeboxLoad(const char* pszPassword);
-
-	/// 창고 열기 요청의 취소
-	/**
-	* ReqSafeboxLoad 를 호출하고 CloseSafebox 하지 않았을 때 이 함수를 호출하면 창고를 열 수 있다.
-	* 창고열기의 요청이 DB 서버에서 실패응답을 받았을 경우 이 함수를 사용해서 요청을 할 수 있게 해준다.
-	**/
-	void CancelSafeboxLoad(void) { m_bOpeningSafebox = false; }
-
-	void SetMallLoadTime(int t) { m_iMallLoadTime = t; }
-	int GetMallLoadTime() const { return m_iMallLoadTime; }
-
-	CSafebox* GetMall() const;
-	void LoadMall(int iItemCount, TPlayerItem* pItems);
-	void CloseMall();
-
-	void SetSafeboxOpenPosition();
-	float GetDistanceFromSafeboxOpen() const;
-
-	void LoadSafeboxBuff();
-	void SetSafeboxBuff();
-
-protected:
-	CSafebox* m_pkSafebox;
-	int m_iSafeboxSize;
-	int m_iSafeboxLoadTime;
-	bool m_bOpeningSafebox; ///< 창고가 열기 요청 중이거나 열려있는가 여부, true 일 경우 열기요청이거나 열려있음.
-
-	CSafebox* m_pkMall;
-	int m_iMallLoadTime;
-
-	PIXEL_POSITION m_posSafeboxOpen;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Mounting
-public:
-	void UnMount(bool bUnequipItem = false);
-	void MountVnum(DWORD vnum);
-	DWORD GetMountVnum() const { return m_dwMountVnum; }
-	DWORD GetLastMountTime() const { return m_dwMountTime; }
-
-	bool CanUseHorseSkill();
-
-	// Horse
-	virtual void SetHorseLevel(int iLevel);
-
-	virtual bool StartRiding();
-	virtual bool StopRiding();
-
-	virtual DWORD GetMyHorseVnum() const;
-
-	virtual void HorseDie();
-	virtual bool ReviveHorse();
-
-	virtual void SendHorseInfo();
-	virtual void ClearHorseInfo();
-
-	void HorseSummon(bool bSummon, bool bFromFar = false, DWORD dwVnum = 0, const char* pHorseName = 0);
-
-	LPCHARACTER GetHorse() const { return m_chHorse; } // 현재 소환중인 말
-	LPCHARACTER GetRider() const; // rider on horse
-	void SetRider(LPCHARACTER ch);
-
-	bool IsRiding() const;
-
-#if defined(__PET_SYSTEM__)
-public:
-	CPetSystem* GetPetSystem() { return m_petSystem; }
-
-protected:
-	CPetSystem* m_petSystem;
-
-public:
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-public:
-	bool	IsPet() const { return m_bCharType == CHAR_TYPE_PET_PAY; }
-	bool	IsGrowthPet() { return m_bCharType == CHAR_TYPE_PET; };
-	void	SetInvincible(bool bInvincible) { m_bInvincible = bInvincible; }
-	bool	IsInvincible() { return m_bInvincible; }
-
-	void	SetPetHatchWindow(bool bState) { m_bIsPetHatchOpen = bState; }
-	bool	IsPetHatchWindowOpen() { return m_bIsPetHatchOpen; }
-	void	SetPetChangeNameWindow(bool bState) { m_bIsPetChangeNameOpen = bState; }
-	bool	IsPetChangeNameWindowOpen() { return m_bIsPetChangeNameOpen; }
-
-	void	SetPetWindowType(BYTE bType) { m_bPetWindowType = bType; }
-	BYTE	GetPetWindowType() const { return m_bPetWindowType; }
-
-	void	SetGrowthPetLoaded(bool bState) { m_bIsGrowthPetLoaded = bState; }
-	bool	IsGrowthPetLoaded() { return m_bIsGrowthPetLoaded; }
-
-	void	SetCharacterSize(BYTE bSize) { m_bCharacterSize = bSize; }
-	BYTE	GetCharacterSize() { return m_bCharacterSize; }
-
-	bool			SetGrowthPet(LPGROWTH_PET pkPet);
-	bool			DeleteGrowthPet(DWORD dwID);
-	LPGROWTH_PET	GetGrowthPet(DWORD dwID);
-	void			ClearGrowthPet();
-
-	void			SetActiveGrowthPet(LPGROWTH_PET pkPet) { m_activeGrowthPet = pkPet;  }
-	LPGROWTH_PET	GetActiveGrowthPet() { return m_activeGrowthPet; }
-
-private:
-	DWORD	m_bInvincible;
-	bool	m_bIsPetHatchOpen;
-	bool	m_bIsPetChangeNameOpen;
-	BYTE	m_bPetWindowType;
-
-	bool	m_bIsGrowthPetLoaded;
-
-	CGrowthPetManager::TGrowthPetMap m_growthPetMap;
-	LPGROWTH_PET m_activeGrowthPet;
-
-	BYTE m_bCharacterSize;
-#endif
-
-protected:
-	LPCHARACTER m_chHorse;
-	LPCHARACTER m_chRider;
-
-	DWORD m_dwMountVnum;
-	DWORD m_dwMountTime;
-
-	BYTE m_bSendHorseLevel;
-	BYTE m_bSendHorseHealthGrade;
-	BYTE m_bSendHorseStaminaGrade;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Detailed Log
-public:
-	void DetailLog() { m_bDetailLog = !m_bDetailLog; }
-	void ToggleMonsterLog();
-	void MonsterLog(const char* format, ...);
-
-private:
-	bool m_bDetailLog;
-	bool m_bMonsterLog;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Empire
-public:
-	void SetEmpire(BYTE bEmpire);
-	BYTE GetEmpire() const { return m_bEmpire; }
-
-protected:
-	BYTE m_bEmpire;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Regen
-public:
-	void SetRegen(LPREGEN pkRegen);
-
-protected:
-	PIXEL_POSITION m_posRegen;
-	float m_fRegenAngle;
-	LPREGEN m_pkRegen;
-	size_t regen_id_; // to help dungeon regen identification
-	// End of Regen
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Resists & Proofs
-public:
-	bool CannotMoveByAffect() const; // 특정 효과에 의해 움직일 수 없는 상태인가?
-	bool IsImmune(DWORD dwImmuneFlag);
-	void SetImmuneFlag(DWORD dw) { m_pointsInstant.dwImmuneFlag = dw; }
-
-protected:
-	void ApplyMobAttribute(const TMobTable* table);
-	// End of Resists & Proofs
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// QUEST
-public:
-	void SetQuestNPCID(DWORD vid);
-	DWORD GetQuestNPCID() const { return m_dwQuestNPCVID; }
-	LPCHARACTER GetQuestNPC() const;
-
-	void SetQuestItemPtr(LPITEM item);
-	void ClearQuestItemPtr();
-	LPITEM GetQuestItemPtr() const;
-
-	void SetQuestBy(DWORD dwQuestVnum) { m_dwQuestByVnum = dwQuestVnum; }
-	DWORD GetQuestBy() const { return m_dwQuestByVnum; }
-
-	int GetQuestFlag(const std::string& flag) const;
-	void SetQuestFlag(const std::string& flag, int value);
-
-	void ConfirmWithMsg(const char* szMsg, int iTimeout, DWORD dwRequestPID);
-	bool IsRunningQuest() const;
-
-private:
-	DWORD m_dwQuestNPCVID;
-	DWORD m_dwQuestByVnum;
-	LPITEM m_pQuestItem;
-
-	// Events
-public:
-	bool StartStateMachine(int iPulse = 1);
-	void StopStateMachine();
-	void UpdateStateMachine(DWORD dwPulse);
-	void SetNextStatePulse(int iPulseNext);
-
-	// 캐릭터 인스턴스 업데이트 함수. 기존엔 이상한 상속구조로 CFSM::Update 함수를 호출하거나 UpdateStateMachine 함수를 사용했는데, 별개의 업데이트 함수 추가함.
-	void UpdateCharacter(DWORD dwPulse);
-
-protected:
-	DWORD m_dwNextStatePulse;
-
-	// Marriage
-public:
-	LPCHARACTER GetMarryPartner() const;
-	void SetMarryPartner(LPCHARACTER ch);
-	int GetMarriageBonus(DWORD dwItemVnum, bool bSum = true);
-
-	bool IsWearingDress() const;
-
-	void SetWeddingMap(marriage::WeddingMap* pMap);
-	marriage::WeddingMap* GetWeddingMap() const { return m_pWeddingMap; }
-
-private:
-	marriage::WeddingMap* m_pWeddingMap;
-	LPCHARACTER m_pkChrMarried;
-
-	// Warp Character
-public:
-	void StartWarpNPCEvent();
-
-public:
-	void StartSaveEvent();
-	void StartRecoveryEvent();
-	void StartCheckSpeedHackEvent();
-	void StartDestroyWhenIdleEvent();
-
-	LPEVENT m_pkDeadEvent;
-	LPEVENT m_pkStunEvent;
-	LPEVENT m_pkSaveEvent;
-	LPEVENT m_pkRecoveryEvent;
-	LPEVENT m_pkTimedEvent;
-	LPEVENT m_pkFishingEvent;
-	LPEVENT m_pkAffectEvent;
-	LPEVENT m_pkPoisonEvent;
-	LPEVENT m_pkBleedingEvent;
-	LPEVENT m_pkFireEvent;
-#if defined(__DAWNMIST_DUNGEON__)
-	LPEVENT m_pkHealEvent;
-#endif
-	LPEVENT m_pkWarpNPCEvent;
-	// DELAYED_WARP
-	// END_DELAYED_WARP
-
-	// MINING
-	LPEVENT m_pkMiningEvent;
-	// END_OF_MINING
-	LPEVENT m_pkWarpEvent;
-	LPEVENT m_pkCheckSpeedHackEvent;
-	LPEVENT m_pkDestroyWhenIdleEvent;
-	LPEVENT m_pkPetSystemUpdateEvent;
-
-	bool IsWarping() const { return m_pkWarpEvent ? true : false; }
-
-	bool m_bHasPoisoned;
-	bool m_bHasBled;
-
-	const CMob* m_pkMobData;
-	CMobInstance* m_pkMobInst;
-
-	MobSkillEventMap m_mapMobSkillEvent;
-
-	friend struct FuncSplashDamage;
-	friend struct FuncSplashAffect;
-	friend class CFuncShoot;
-
-public:
-	int GetPremiumRemainSeconds(BYTE bType) const;
-
-private:
-	int m_aiPremiumTimes[PREMIUM_MAX_NUM];
-
-	// CHANGE_ITEM_ATTRIBUTES
-	static const DWORD msc_dwDefaultChangeItemAttrCycle; ///< 디폴트 아이템 속성변경 가능 주기
-	static const char msc_szLastChangeItemAttrFlag[]; ///< 최근 아이템 속성을 변경한 시간의 Quest Flag 이름
-	static const char msc_szChangeItemAttrCycleFlag[]; ///< 아이템 속성병경 가능 주기의 Quest Flag 이름
-	// END_OF_CHANGE_ITEM_ATTRIBUTES
-
-	// PC_BANG_ITEM_ADD
-private:
-	bool m_isinPCBang;
-
-public:
-	bool SetPCBang(bool flag) { m_isinPCBang = flag; return m_isinPCBang; }
-	bool IsPCBang() const { return m_isinPCBang; }
-	// END_PC_BANG_ITEM_ADD
-
-	// NEW_HAIR_STYLE_ADD
-public:
-	bool ItemProcess_Hair(LPITEM item, int iDestCell);
-	// END_NEW_HAIR_STYLE_ADD
-
-public:
-	void ClearSkill();
-	void ClearSubSkill();
-
-	// RESET_ONE_SKILL
-	bool ResetOneSkill(DWORD dwVnum);
-	// END_RESET_ONE_SKILL
-
-private:
-	void SendDamagePacket(LPCHARACTER pAttacker, int Damage, BYTE DamageFlag);
-
-	// ARENA
-private:
-	CArena* m_pArena;
-	bool m_ArenaObserver;
-	int m_nPotionLimit;
-
-public:
-	void SetArena(CArena* pArena) { m_pArena = pArena; }
-	void SetArenaObserverMode(bool flag) { m_ArenaObserver = flag; }
-
-	CArena* GetArena() const { return m_pArena; }
-	bool GetArenaObserverMode() const { return m_ArenaObserver; }
-
-	void SetPotionLimit(int count) { m_nPotionLimit = count; }
-	int GetPotionLimit() const { return m_nPotionLimit; }
-	// END_ARENA
-
-	// PREVENT_TRADE_WINDOW
-public:
-	bool IsOpenSafebox() const { return m_isOpenSafebox ? true : false; }
-	void SetOpenSafebox(bool b) { m_isOpenSafebox = b; }
-
-	int GetSafeboxLoadTime() const { return m_iSafeboxLoadTime; }
-	void SetSafeboxLoadTime() { m_iSafeboxLoadTime = thecore_pulse(); }
-
-private:
-	bool m_isOpenSafebox;
-	// END_PREVENT_TRADE_WINDOW
-
-public:
-	int GetSkillPowerByLevel(int iLevel, bool bMob = false) const;
-
-	// PREVENT_REFINE_HACK
-	int GetRefineTime() const { return m_iRefineTime; }
-	void SetRefineTime() { m_iRefineTime = thecore_pulse(); }
-	int m_iRefineTime;
-	// END_PREVENT_REFINE_HACK
-
-	// RESTRICT_USE_SEED_OR_MOONBOTTLE
-	int GetUseSeedOrMoonBottleTime() const { return m_iSeedTime; }
-	void SetUseSeedOrMoonBottleTime() { m_iSeedTime = thecore_pulse(); }
-	int m_iSeedTime;
-	// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
-
-	// PREVENT_PORTAL_AFTER_EXCHANGE
-	int GetExchangeTime() const { return m_iExchangeTime; }
-	void SetExchangeTime() { m_iExchangeTime = thecore_pulse(); }
-	int m_iExchangeTime;
-	// END_PREVENT_PORTAL_AFTER_EXCHANGE
-
-	int m_iMyShopTime;
-	int GetMyShopTime() const { return m_iMyShopTime; }
-	void SetMyShopTime() { m_iMyShopTime = thecore_pulse(); }
-
-	// PREVENT_TRADE_WINDOW
-	bool PreventTradeWindow(int flags, bool except = false) const;
-	// END_PREVENT_TRADE_WINDOW
-
-	// Hack 방지를 위한 체크.
-	bool IsHack(bool bSendMsg = true, bool bCheckShopOwner = true, int limittime = g_nPortalLimitTime);
-
-	// MONARCH
-	BOOL IsMonarch() const;
-	// END_MONARCH
-	void Say(const std::string& s);
-
-	enum MONARCH_COOLTIME
-	{
-		MC_HEAL = 10,
-		MC_WARP = 60,
-		MC_TRANSFER = 60,
-		MC_TAX = (60 * 60 * 24 * 7),
-		MC_SUMMON = (60 * 60),
-	};
-
-	enum MONARCH_INDEX
-	{
-		MI_HEAL = 0,
-		MI_WARP,
-		MI_TRANSFER,
-		MI_TAX,
-		MI_SUMMON,
-		MI_MAX
-	};
-
-	DWORD m_dwMonarchCooltime[MI_MAX];
-	DWORD m_dwMonarchCooltimelimit[MI_MAX];
-
-	void InitMC();
-	DWORD GetMC(enum MONARCH_INDEX e) const;
-	void SetMC(enum MONARCH_INDEX e);
-	bool IsMCOK(enum MONARCH_INDEX e) const;
-	DWORD GetMCL(enum MONARCH_INDEX e) const;
-	DWORD GetMCLTime(enum MONARCH_INDEX e) const;
-
-public:
-	bool ItemProcess_Polymorph(LPITEM item);
-
-#if !defined(__CUBE_RENEWAL__)
-	// by mhh
-	LPITEM* GetCubeItem() { return m_pointsInstant.pCubeItems; }
-#endif
-	bool IsCubeOpen() const { return (m_pointsInstant.pCubeNpc ? true : false); }
-	LPCHARACTER GetCubeNpc() const { return m_pointsInstant.pCubeNpc; }
-	void SetCubeNpc(LPCHARACTER npc) { m_pointsInstant.pCubeNpc = npc; }
-	bool CanDoCube() const;
-
-public:
-	bool IsSiegeNPC() const;
-
-private:
-	// 중국 전용
-	// 18세 미만 전용
-	// 3시간 : 50 % 5 시간 0%
-	e_overtime m_eOverTime;
-
-public:
-	bool IsOverTime(e_overtime e) const { return (e == m_eOverTime); }
-	void SetOverTime(e_overtime e) { m_eOverTime = e; }
-
-private:
-	int m_deposit_pulse;
-
-public:
-	void UpdateDepositPulse();
-	bool CanDeposit() const;
-
-private:
-	void __OpenPrivateShop();
-
-public:
-	struct AttackedLog
-	{
-		DWORD dwPID;
-		DWORD dwAttackedTime;
-
-		AttackedLog() : dwPID(0), dwAttackedTime(0)
-		{
-		}
-	};
-
-	AttackLog m_kAttackLog;
-	AttackedLog m_AttackedLog;
-	int m_speed_hack_count;
-
-private:
-	std::string m_strNewName;
-
-public:
-	const std::string GetNewName() const { return this->m_strNewName; }
-	void SetNewName(const std::string name) { this->m_strNewName = name; }
-
-public:
-	void GoHome();
-
-private:
-	std::set<DWORD> m_known_guild;
-
-public:
-	void SendGuildName(CGuild* pGuild);
-	void SendGuildName(DWORD dwGuildID);
-
-private:
-	DWORD m_dwLogOffInterval;
-	DWORD m_dwLastPlay;
-
-public:
-	DWORD GetLogOffInterval() const { return m_dwLogOffInterval; }
-	DWORD GetLastPlay() const { return m_dwLastPlay; }
-
-public:
-	bool UnEquipSpecialRideUniqueItem();
-
-	bool CanWarp() const;
-	bool IsInSafezone() const;
-	bool IsInBlockedArea(long x = 0, long y = 0) const;
-
-private:
-	DWORD m_dwLastGoldDropTime;
-#if defined(__CHEQUE_SYSTEM__)
-	DWORD m_dwLastChequeDropTime;
-#endif
-
-public:
-	void AutoRecoveryItemProcess(const EAffectTypes);
-
-public:
-	void BuffOnAttr_AddBuffsFromItem(LPITEM pItem);
-	void BuffOnAttr_RemoveBuffsFromItem(LPITEM pItem);
-
-private:
-	void BuffOnAttr_ValueChange(POINT_TYPE wPointType, POINT_VALUE lOldValue, POINT_VALUE lNewValue);
-	void BuffOnAttr_ClearAll();
-
-	typedef std::map<DWORD, CBuffOnAttributes*> TMapBuffOnAttrs;
-	TMapBuffOnAttrs m_map_buff_on_attrs;
-	// 무적 : 원활한 테스트를 위하여.
-
-public:
-	void SetArmada() { cannot_dead = true; }
-	void ResetArmada() { cannot_dead = false; }
-
-private:
-	bool cannot_dead;
-
-#if defined(__PET_SYSTEM__)
-private:
-	bool m_bIsPet;
-
-public:
-	void SetPet() { m_bIsPet = true; }
-	bool IsPet() { return m_bIsPet; }
-#endif
-
-	// 최종 데미지 보정.
-private:
-	float m_fAttMul;
-	float m_fDamMul;
-
-public:
-	float GetAttMul() { return this->m_fAttMul; }
-	void SetAttMul(float newAttMul) { this->m_fAttMul = newAttMul; }
-	float GetDamMul() { return this->m_fDamMul; }
-	void SetDamMul(float newDamMul) { this->m_fDamMul = newDamMul; }
-
-private:
-	bool IsValidItemPosition(TItemPos Pos) const;
-
-	// 독일 선물 기능 패킷 임시 저장
-private:
-	unsigned int itemAward_vnum;
-	char itemAward_cmd[20];
-	//bool itemAward_flag;
-public:
-	unsigned int GetItemAward_vnum() { return itemAward_vnum; }
-	char* GetItemAward_cmd() { return itemAward_cmd; }
-	//bool GetItemAward_flag() { return itemAward_flag; }
-	void SetItemAward_vnum(unsigned int vnum) { itemAward_vnum = vnum; }
-	void SetItemAward_cmd(char* cmd) { strcpy(itemAward_cmd, cmd); }
-	//void SetItemAward_flag(bool flag) { itemAward_flag = flag; }
-
-#if defined(__MOVE_COSTUME_ATTR__)
-public:
-	void ItemCombination(const short MediumIndex, const short BaseIndex, const short MaterialIndex);
-	void OpenItemComb();
-
-	bool IsItemComb() const { return m_pointsInstant.pItemCombNpc != NULL; }
-	void SetItemCombNpc(const LPCHARACTER npc) { m_pointsInstant.pItemCombNpc = npc; }
-#endif
-
-#if defined(__CHANGED_ATTR__)
-public:
-	void SelectAttr(LPITEM material, LPITEM item);
-	void SelectAttrResult(const bool bNew, const TItemPos& pos);
-	bool IsSelectAttr() const;
-private:
-	struct SItemSelectAttr
-	{
-		DWORD dwItemID;
-		TPlayerItemAttribute Attr[ITEM_ATTRIBUTE_MAX_NUM];
-	} m_ItemSelectAttr;
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__)
-public:
-	void MiniGameCatchKingSetFieldCards(std::vector<TCatchKingCard> vec) { m_vecCatchKingFieldCards = vec; }
-
-	DWORD MiniGameCatchKingGetScore() const { return dwCatchKingTotalScore; }
-	void MiniGameCatchKingSetScore(DWORD dwScore) { dwCatchKingTotalScore = dwScore; }
-
-	DWORD MiniGameCatchKingGetBetNumber() const { return bCatchKingBetSetNumber; }
-	void MiniGameCatchKingSetBetNumber(BYTE bSetNr) { bCatchKingBetSetNumber = bSetNr; }
-
-	BYTE MiniGameCatchKingGetHandCard() const { return bCatchKingHandCard; }
-	void MiniGameCatchKingSetHandCard(BYTE bKingCard) { bCatchKingHandCard = bKingCard; }
-
-	BYTE MiniGameCatchKingGetHandCardLeft() const { return bCatchKingHandCardLeft; }
-	void MiniGameCatchKingSetHandCardLeft(BYTE bHandCard) { bCatchKingHandCardLeft = bHandCard; }
-
-	bool MiniGameCatchKingGetGameStatus() const { return dwCatchKingGameStatus; }
-	void MiniGameCatchKingSetGameStatus(bool bStatus) { dwCatchKingGameStatus = bStatus; }
-
-	std::vector<TCatchKingCard> m_vecCatchKingFieldCards;
-
-protected:
-	BYTE bCatchKingHandCard;
-	BYTE bCatchKingHandCardLeft;
-	bool dwCatchKingGameStatus;
-
-	BYTE bCatchKingBetSetNumber;
-	DWORD dwCatchKingTotalScore;
-#endif
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-public:
-	// 용혼석
-
-	// 캐릭터의 affect, quest가 load 되기 전에 DragonSoul_Initialize를 호출하면 안된다.
-	// affect가 가장 마지막에 로드되어 LoadAffect에서 호출함.
-	void DragonSoul_Initialize();
-
-	bool DragonSoul_IsQualified() const;
-	void DragonSoul_GiveQualification();
-
-	int DragonSoul_GetActiveDeck() const;
-	bool DragonSoul_IsDeckActivated() const;
-	bool DragonSoul_ActivateDeck(int iDeckIdx);
-
-	void DragonSoul_DeactivateAll();
-	// 반드시 ClearItem 전에 불러야 한다.
-	// 왜냐하면....
-	// 용혼석 하나 하나를 deactivate할 때마다 덱에 active인 용혼석이 있는지 확인하고,
-	// active인 용혼석이 하나도 없다면, 캐릭터의 용혼석 affect와, 활성 상태를 제거한다.
-	// 
-	// 하지만 ClearItem 시, 캐릭터가 착용하고 있는 모든 아이템을 unequip하는 바람에,
-	// 용혼석 Affect가 제거되고, 결국 로그인 시, 용혼석이 활성화되지 않는다.
-	// (Unequip할 때에는 로그아웃 상태인지, 아닌지 알 수 없다.)
-	// 용혼석만 deactivate시키고 캐릭터의 용혼석 덱 활성 상태는 건드리지 않는다.
-	void DragonSoul_CleanUp();
-
-#if defined(__DS_SET__)
-	// Dragon Soul Set Bonus
-public:
-	void DragonSoul_SetBonus();
-	void DragonSoul_ActivateAll();
-#endif
-
-	// 용혼석 강화창
-public:
-	bool DragonSoul_RefineWindow_Open(LPENTITY pEntity);
-#if defined(__DS_CHANGE_ATTR__)
-	bool DragonSoul_RefineWindow_ChangeAttr_Open(LPENTITY pEntity);
-#endif
-	bool DragonSoul_RefineWindow_Close();
-	LPENTITY DragonSoul_RefineWindow_GetOpener() { return m_pointsInstant.m_pDragonSoulRefineWindowOpener; }
-	int DragonSoul_RefineWindow_GetDeckSnapshot() const { return m_pointsInstant.iDragonSoulRefineDeckSnapshot; }
-	void DragonSoul_RefineWindow_SetDeckSnapshot(int iDeck) { m_pointsInstant.iDragonSoulRefineDeckSnapshot = iDeck; }
-	bool DragonSoul_RefineWindow_CanRefine();
-#endif
-
-private:
-	// SyncPosition을 악용하여 타유저를 이상한 곳으로 보내는 핵 방어하기 위하여,
-	// SyncPosition이 일어날 때를 기록.
-	timeval m_tvLastSyncTime;
-	int m_iSyncHackCount;
-public:
-	void SetLastSyncTime(const timeval& tv) { memcpy(&m_tvLastSyncTime, &tv, sizeof(timeval)); }
-	const timeval& GetLastSyncTime() { return m_tvLastSyncTime; }
-	void SetSyncHackCount(int iCount) { m_iSyncHackCount = iCount; }
-	int GetSyncHackCount() { return m_iSyncHackCount; }
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-public:
-	void SetChangeLook(CChangeLook* c);
-	CChangeLook* GetChangeLook() const;
-protected:
-	CChangeLook* m_pkChangeLook;
-#endif
-
-#if defined(__MAILBOX__)
-public:
-	int GetMyMailBoxTime() const { return m_iMyMailBoxTime; }
-	void SetMyMailBoxTime() { m_iMyMailBoxTime = thecore_pulse(); }
-
-	void SetMailBox(CMailBox* m);
-
-	void SetMailBoxLoading(const bool b) { bMailBoxLoading = b; }
-	bool IsMailBoxLoading() const { return bMailBoxLoading; }
-
-	CMailBox* GetMailBox() const { return m_pkMailBox; }
-
-private:
-	CMailBox* m_pkMailBox;
-	bool bMailBoxLoading;
-	int m_iMyMailBoxTime;
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-public:
-	void SetMiniGameRumi(CMiniGameRumi* pClass);
-	CMiniGameRumi* GetMiniGameRumi() const { return m_pkMiniGameRumi; }
-private:
-	CMiniGameRumi* m_pkMiniGameRumi;
-#endif
-
-#if defined(__CONQUEROR_LEVEL__)
-public:
-	bool IsNewWorldMapIndex() const;
-	long GetNewWorldSungMa(POINT_TYPE wPointType, bool bPremium = true) const;
-	bool IsSungMaCursed(POINT_TYPE wPointType) const;
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-public:
-	CLootFilter* GetLootFilter();
-	void SetLootFilter();
-	void ClearLootFilter();
-private:
-	CLootFilter* m_pLootFilter;
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-public:
-	bool IsOpenAttr67Add() const { return m_bIsOpenAttr67Add ? true : false; }
-	void SetOpenAttr67Add(bool bOpen) { m_bIsOpenAttr67Add = bOpen; }
-
-	LPITEM GetNPCStorageItem(BYTE bCell = 0) const;
-	bool Attr67Add(const TAttr67AddData kAttr67AddData);
-
-private:
-	bool m_bIsOpenAttr67Add;
-#endif
-
-#if defined(__FISHING_GAME__)
-public:
-	void SetFishingGameGoals(BYTE bCount) { m_bFishingGameGoals = bCount; }
-	BYTE GetFishingGameGoals() { return m_bFishingGameGoals; }
-private:
-	BYTE m_bFishingGameGoals;
-#endif
-
-#if defined(__GEM_SYSTEM__)
-public:
-	void SelectItemEx(DWORD dwInventoryPos, BYTE bType);
-	bool GemRefine(LPITEM lpMetinStoneItem);
-
-#	if defined(__GEM_SHOP__)
-public:
-	void SetGemShop(CGemShop* pGemShop);
-	CGemShop* GetGemShop() const { return m_pGemShop; }
-
-	void SetGemShopLoading(const bool c_bLoading) { m_bGemShopLoading = c_bLoading; }
-	bool IsGemShopLoading() const { return m_bGemShopLoading; }
-
-private:
-	CGemShop* m_pGemShop;
-	bool m_bGemShopLoading;
-#	endif
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	//////////////////////////////////////////////////////////////////////////////////
-	// Acce Costume System
-public:
-	void AcceRefineWindowOpen(const LPENTITY pEntity, BYTE bType);
-	void AcceRefineWindowClose(bool bServerClose = false);
-	bool IsAcceRefineWindowOpen() const { return m_bAcceRefineWindowOpen; }
-	bool GetAcceRefineWindowType() const { return m_bAcceRefineWindowType; }
-
-	bool IsAcceRefineWindowCanRefine();
-	LPENTITY GetAcceRefineWindowOpener() const { return m_pointsInstant.m_pAcceRefineWindowOpener; }
-
-	void AcceRefineWindowCheckIn(BYTE bType, TItemPos SelectedPos, TItemPos AttachedPos);
-	void AcceRefineWindowCheckOut(BYTE bType, TItemPos SelectedPos);
-	void AcceRefineWindowAccept(BYTE bType);
-
-	int GetAcceWeaponAttack() const;
-	int GetAcceWeaponMagicAttack() const;
-
-	void ModifyAccePoints(const LPITEM& rAcceItem, bool bAdd);
-
-protected:
-	int __CalculateAcceDrainValues(BYTE bWeaponAttackType) const;
-	int __CheckAcceRefineItem(const LPITEM& rLeftItem, const LPITEM& rRightItem) const;
-	BYTE __GetNextDrainRate(const LPITEM& rAcceItem, BYTE bMinDrainRate) const;
-
-private:
-	bool m_bAcceRefineWindowOpen;
-	BYTE m_bAcceRefineWindowType;
-	TItemPos m_pAcceRefineWindowItemSlot[ACCE_SLOT_MAX];
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-	//////////////////////////////////////////////////////////////////////////////////
-	// Aura Costume System
-public:
-	void OpenAuraRefineWindow(const LPENTITY pEntity, BYTE bType);
-	void AuraRefineWindowClose(bool bServerClose = false);
-	bool IsAuraRefineWindowOpen() const { return m_bAuraRefineWindowOpen; }
-	BYTE GetAuraRefineWindowType() const { return m_bAuraRefineWindowType; }
-
-	bool IsAuraRefineWindowCanRefine();
-	LPENTITY GetAuraRefineWindowOpener() const { return m_pointsInstant.m_pAuraRefineWindowOpener; }
-
-	void AuraRefineWindowCheckIn(BYTE bType, TItemPos SelectedPos, TItemPos AttachedPos);
-	void AuraRefineWindowCheckOut(BYTE bType, TItemPos SelectedPos);
-	void AuraRefineWindowAccept(BYTE bType);
-
-	void ModifyAuraPoints(const LPITEM& rAuraItem, bool bAdd);
-
-private:
-	BYTE m_bAuraRefineWindowType;
-	bool m_bAuraRefineWindowOpen;
-	TItemPos m_pAuraRefineWindowItemSlot[AURA_SLOT_MAX];
-	TAuraRefineInfo m_bAuraRefineInfo[AURA_REFINE_INFO_SLOT_MAX];
-
-protected:
-	TAuraRefineInfo __GetAuraRefineInfo(TItemPos Cell);
-	TAuraRefineInfo __CalcAuraRefineInfo(TItemPos Cell, TItemPos MaterialCell);
-	TAuraRefineInfo __GetAuraEvolvedRefineInfo(TItemPos Cell);
-#endif
-
-#if defined(__SOUL_SYSTEM__)
-public:
-	void SoulItemProcess(ESoulSubTypes eSubType);
-
-	int GetSoulDamage(ESoulSubTypes eSubType) const;
-	bool DoRefineSoul(LPITEM item);
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-public:
-	void SetExtendInvenStage(BYTE bStage) { m_bExtendInvenStage = bStage; }
-	BYTE GetExtendInvenStage() const { return m_bExtendInvenStage; }
-
-	WORD GetExtendInvenMax() const;
-
-	void ExtendInvenRequest();
-	void ExtendInvenUpgrade();
-
-	void SendExtendInvenPacket();
-
-private:
-	BYTE m_bExtendInvenStage;
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-public:
-	void StartHitBuffEvent();
-	void StopHitBuffEvent();
-private:
-	LPEVENT m_pHitBuffEvent;
-#endif
-
-#if defined(__CLIENT_TIMER__)
-public:
-	void SendClientTimer(BYTE bSubHeader, DWORD dwEndTime = 0, DWORD dwAlarmSec = 0);
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-public:
-	void AddEmote(const INT iEmoteIndex = -1);
-	void SetEmotes(const TPacketGDEmote* pTable, const WORD c_wSize);
-#endif
-
-#if defined(__SET_ITEM__)
-public:
-	using SetItemCountMap = std::map<BYTE, BYTE>;
-	SetItemCountMap GetItemSetCountMap() const;
-
-	void RefreshItemSetBonus();
-	void RefreshItemSetBonusByValue();
-#endif
-
-#if defined(__RACE_SWAP__)
-public:
-	void SetEventRaceNum(DWORD dwRaceNum);
-	DWORD GetEventRaceNum() const { return m_dwEventRaceNum; }
-private:
-	DWORD m_dwEventRaceNum;
-#endif
-
-#if defined(__GAME_OPTION_ESCAPE__)
-public:
-	void SetEscapeCooltime(const DWORD dwTime) { m_dwEscapeCooltime = dwTime; }
-	DWORD GetEscapeCooltime() const { return m_dwEscapeCooltime; }
-private:
-	DWORD m_dwEscapeCooltime;
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-public:
-	void RefineElementInformation(const LPITEM& rSrcItem, const TItemPos& kItemDestCell);
-	void RefineElement(WORD wElementType);
-
-	bool IsUnderRefineElement() const { return m_bUnderRefineElement; }
-	void SetUnderRefineElement(bool bState, BYTE bRefineType = 0, const TItemPos& rkSrcPos = NPOS, const TItemPos& rkDestPos = NPOS);
-
-	WORD GetRefineElementEffect() const;
-
-private:
-	struct SRefineElementItemPos
-	{
-		SRefineElementItemPos() : RefineType(0), SrcPos(NPOS), DestPos(NPOS) {}
-		BYTE RefineType;
-		TItemPos SrcPos, DestPos;
-	} m_kRefineElementItemPos;
-	bool m_bUnderRefineElement;
-#endif
-
-#if defined(__HIDE_COSTUME_SYSTEM__)
-public:
-	void SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bSave = true);
-	bool GetHiddenCostumeByPart(BYTE bPartPos) const;
-
-	void SetHiddenCostumeParts();
-private:
-	DWORD m_dwHideCostumePulse;
-	bool m_bHiddenCostumePart[COSTUME_NUM_TYPES];
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__)
-public:
-	void SetMiniGameYutnori(CMiniGameYutnori* pClass);
-	CMiniGameYutnori* GetMiniGameYutnori() const { return m_pkMiniGameYutnori; }
-private:
-	CMiniGameYutnori* m_pkMiniGameYutnori;
-#endif
-
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-public:
-	void SetCountry(const std::string& country) { m_stCountry = country; }
-	const char* GetCountry() const { return m_stCountry.c_str(); }
-
-protected:
-	std::string m_stCountry;
-#endif
-
-#if defined(__MYSHOP_DECO__)
-public:
-	void SetMyShopDecoState(BYTE bState) { m_bMyShopDecoState = bState; };
-	BYTE GetMyShopDecoState() const { return m_bMyShopDecoState; };
-
-	void SetMyShopDecoType(BYTE bShopType) { m_bMyShopDecoType = bShopType; };
-	BYTE GetMyShopDecoType() const { return m_bMyShopDecoType; };
-
-	void SetMyShopDecoPolyVnum(DWORD dwPolyVnum) { m_bMyShopDecoPolyVnum = dwPolyVnum; };
-	DWORD GetMyShopDecoPolyVnum() const { return m_bMyShopDecoPolyVnum; };
-
-	void SetMyPrivShopTabCount(BYTE bTabCount) { m_bMyPrivShopTabCount = bTabCount; };
-	BYTE GetMyPrivShopTabCount() const { return m_bMyPrivShopTabCount; };
-
-	void SetMyPrivShopIsCashItem(bool bIsCashItem) { m_bMyPrivShopIsCashItem = bIsCashItem; };
-	bool GetMyPrivShopIsCashItem() const { return m_bMyPrivShopIsCashItem; };
-
-	void OpenPrivateShop(BYTE bTabCount = 1, bool bIsCashItem = false);
-
-private:
-	BYTE m_bMyShopDecoState;
-	BYTE m_bMyShopDecoType;
-	DWORD m_bMyShopDecoPolyVnum;
-
-	BYTE m_bMyPrivShopTabCount;
-	bool m_bMyPrivShopIsCashItem;
-#endif
-
-#if defined(__LEFT_SEAT__)
-public:
-	void SetLeftSeat(bool bLeftSeat);
-	bool LeftSeat() const { return m_bLeftSeat; }
-
-	void SetLeftSeatWaitTime(BYTE bIndex);
-	DWORD GetLeftSeatWaitTime() const { return m_dwLeftSeatWaitTime; }
-
-	void SetLeftSeatLogoutTime(BYTE bIndex);
-	DWORD GetLeftSeatLogoutTime() const { return m_dwLeftSeatLogoutTime; }
-
-	void DisableLeftSeatLogOutState(bool bClosePopup = false);
-
-	void RestartLeftSeatWaitTimer();
-	void RestartLeftSeatLogoutTimer();
-
-	void SetLastRequestTime(DWORD dwRequestTime) { m_dwLastRequestTime = dwRequestTime; }
-	DWORD GetLastRequestTime() const { return m_dwLastRequestTime; }
-
-#ifdef __SHOP_SEARCH__
-	bool CheckShopSearchFlood();
-#endif
-
-public:
-	LPEVENT m_pLeftSeatWaitTimerEvent;
-	LPEVENT m_pLeftSeatLogoutTimerEvent;
-
-private:
-	BOOL m_bLeftSeat;
-	DWORD m_dwLeftSeatWaitTime;
-	DWORD m_dwLeftSeatLogoutTime;
-	DWORD m_dwLastRequestTime;
-#ifdef __SHOP_SEARCH__
-	DWORD m_dwLastShopSearchRequestTime;
-	BYTE m_bShopSearchFloodCount;
-#endif
-#endif
-
-#if defined(__ELEMENTAL_DUNGEON__)
-public:
-	void StartElementalCurseEvent();
-	void StopElementalCurseEvent();
-
-	void SetAccumulatedDamage(DWORD dwDamage);
-	DWORD GetAccumulatedDamage() const { return m_dwAccumulatedDamage; }
-
-private:
-	LPEVENT m_pElementalCurseEvent;
-	DWORD m_dwAccumulatedDamage;
-#endif
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-public:
-	void SetGuildDragonLair(CGuildDragonLair* pGuildDragonLair);
-	CGuildDragonLair* GetGuildDragonLair() const { return m_pGuildDragonLair; }
-private:
-	CGuildDragonLair* m_pGuildDragonLair;
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-public:
-	void SetMiniGameRoulette(CMiniGameRoulette* pMiniGameRoulette);
-	CMiniGameRoulette* GetMiniGameRoulette() const { return m_pMiniGameRoulette; }
-
-	void SetMiniGameRoulette_RewardMapperNum(BYTE bMapNum) { m_bMiniGameRoulette_RewardMapperNum = bMapNum; }
-	BYTE GetMiniGameRoulette_RewardMapperNum() const { return m_bMiniGameRoulette_RewardMapperNum; }
-
-private:
-	CMiniGameRoulette* m_pMiniGameRoulette;
-	BYTE m_bMiniGameRoulette_RewardMapperNum;
-#endif
-
-#if defined(__FLOWER_EVENT__)
-public:
-	void SetLastFlowerEventExchangePulse(DWORD dwPulse) { m_dwLastFlowerEventExchangePulse = dwPulse; }
-	DWORD GetLastFlowerEventExchangePulse() const { return m_dwLastFlowerEventExchangePulse; }
-private:
-	DWORD m_dwLastFlowerEventExchangePulse;
-#endif
-
-#if defined(__DEFENSE_WAVE__)
-public:
-	void SetDefenseWave(LPDEFENSE_WAVE pDefenseWave);
-	LPDEFENSE_WAVE GetDefenseWave() const;
-private:
-	LPDEFENSE_WAVE m_pDefenseWave;
-#endif
-
-#ifdef ENABLE_QUEEN_NETHIS
-public:
-	bool IsSnakeMap();
-#endif
-#ifdef __OFFLINE_SHOP__
-private:
-	uint32_t keepingOfflineShop_;
-
-	std::set<uint32_t> viewingOfflineShops_;
-
-	bool isOpeningOfflineShop_;
-	CItem* offlineShopOpeningItem_;
-
-public:
-	void SetKeepingOfflineShop(uint32_t keepingOfflineShop);
-	uint32_t GetKeepingOfflineShop() const;
-
-	void AddViewingOfflineShop(uint32_t id);
-	bool IsViewingOfflineShop();
-	void RemoveViewingOfflineShop(uint32_t id);
-	void RemoveFromViewingOfflineShops();
-
-	bool UseItemOpenOfflineShop(CItem* item);
-	void SetOpeningOfflineShopState(bool isOpeningOfflineShop);
-	bool IsOpeningOfflineShop() const;
-	void SetOfflineShopOpeningItem(CItem* item);
-	CItem* GetOfflineShopOpeningItem() const;
-	bool IsAffectOfflineShopDecoration();
-	void WarpToShop(long x, long y, long mapIndex, BYTE channel);
-
-private:
-	std::map<std::string, int> m_protection_Time;
-
-public:
-	int GetProtectTime(const std::string& flagname) const;
-	void SetProtectTime(const std::string& flagname, int time);
-
-public:
-	void	AddToSellHistory(TMySellHistory newItem);
-	void	SaveSellHistory();
-	void	RequestSellHistory(BYTE bPage);
-	void	SetSellHistoryLoaded(BYTE bStatus) {  m_bSellHistoryLoaded = bStatus; }
-	BYTE	GetSellHistoryLoaded() { return m_bSellHistoryLoaded; }
-protected:
-	BYTE	m_bSellHistoryLoaded;
-	std::vector<TMySellHistory> m_vecSellHistory;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-typedef std::list<TPlayerExtBattlePassMission*> ListExtBattlePassMap;
-public:
-	void LoadExtBattlePass(DWORD dwCount, TPlayerExtBattlePassMission* data);
-	DWORD GetExtBattlePassMissionProgress(DWORD dwBattlePassType, BYTE bMissionIndex, BYTE bMissionType);
-	bool IsExtBattlePassCompletedMission(DWORD dwBattlePassType, BYTE bMissionIndex, BYTE bMissionType);
-	bool IsExtBattlePassRegistered(BYTE bBattlePassType, DWORD dwBattlePassID);
-	void UpdateExtBattlePassMissionProgress(DWORD dwMissionID, DWORD dwUpdateValue, DWORD dwCondition, bool isOverride = false);
-	void SetExtBattlePassMissionProgress(BYTE bBattlePassType, DWORD dwMissionIndex, DWORD dwMissionType, DWORD dwUpdateValue);
-	
-	bool		IsLoadedExtBattlePass()		const	{ return m_bIsLoadedExtBattlePass; }
-	int			GetExtBattlePassPremiumID()	const	{ return m_points.battle_pass_premium_id;	}
-	void		SetExtBattlePassPremiumID(int battle_pass_premium_id)	{ m_points.battle_pass_premium_id = battle_pass_premium_id;}
-
-	void				SetLastReciveExtBattlePassInfoTime(DWORD time);
-	DWORD			GetLastReciveExtBattlePassInfoTime() const	{ return m_dwLastReciveExtBattlePassInfoTime; }
-	void				SetLastReciveExtBattlePassOpenRanking(DWORD time);
-	DWORD			GetLastReciveExtBattlePassOpenRanking() const	{ return m_dwLastExtBattlePassOpenRankingTime; }
-protected:
-	DWORD	m_dwLastReciveExtBattlePassInfoTime;
-	DWORD	m_dwLastExtBattlePassOpenRankingTime;
-	
-private:
-	bool m_bIsLoadedExtBattlePass;
-	ListExtBattlePassMap m_listExtBattlePass;
-#endif
-};
-
-ESex GET_SEX(LPCHARACTER ch);
-
-#endif // __INC_CHAR_H__
+#ifndef __INC_CHAR_H__
+#define __INC_CHAR_H__
+
+#include "../../common/stl.h"
+#include "entity.h"
+#include "FSM.h"
+#include "horse_rider.h"
+#include "vid.h"
+#include "constants.h"
+#include "affect.h"
+#include "affect_flag.h"
+#include "cube.h"
+#include "mining.h"
+#include "packet.h"
+
+#if defined(__LUCKY_BOX__)
+#	include "item_manager.h"
+#endif
+#if defined(__CHANGE_LOOK_SYSTEM__)
+#	include "changelook.h"
+#endif
+#if defined(__MAILBOX__)
+#	include "MailBox.h"
+#endif
+#if defined(__GEM_SHOP__)
+#	include "GemShop.h"
+#endif
+#if defined(__RANKING_SYSTEM__)
+#	include "Ranking.h"
+#endif
+#if defined(__MINI_GAME_RUMI__)
+#	include "minigame_rumi.h"
+#endif
+#if defined(__MINI_GAME_YUTNORI__)
+#	include "minigame_yutnori.h"
+#endif
+#if defined(__MINI_GAME_CATCH_KING__)
+#	include "minigame_catchking.h"
+#endif
+#if defined(__FLOWER_EVENT__)
+#	include "flower_event.h"
+#endif
+#if defined(__SUMMER_EVENT_ROULETTE__)
+#	include "minigame_roulette.h"
+#endif
+#if defined(__INGAME_EVENT_MANAGER__)
+#	include "ingame_event_manager.h"
+#endif
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+#	include "guild_dragonlair.h"
+#endif
+
+class CBuffOnAttributes;
+class CPetSystem;
+#if defined(__LOOT_FILTER_SYSTEM__)
+class CLootFilter;
+#endif
+#ifdef __OFFLINE_SHOP__
+class COfflineShop;
+#endif
+
+#define INSTANT_FLAG_DEATH_PENALTY (1 << 0)
+#define INSTANT_FLAG_SHOP (1 << 1)
+#define INSTANT_FLAG_EXCHANGE (1 << 2)
+#define INSTANT_FLAG_STUN (1 << 3)
+#define INSTANT_FLAG_NO_REWARD (1 << 4)
+
+#define AI_FLAG_NPC (1 << 0)
+#define AI_FLAG_AGGRESSIVE (1 << 1)
+#define AI_FLAG_HELPER (1 << 2)
+#define AI_FLAG_STAYZONE (1 << 3)
+
+#define SET_OVER_TIME(ch, time) (ch)->SetOverTime(time)
+
+#ifdef __GROWTH_PET_SYSTEM__
+#include "growth_pet.h"
+#endif
+extern int g_nPortalLimitTime;
+
+extern bool IS_SUMMON_ITEM(LPITEM item, int map_index = 0);
+extern bool IS_SUMMONABLE_ZONE(int map_index);
+
+extern bool IS_MONKEY_DUNGEON(int map_index);
+extern bool IS_MAZE_DUNGEON(int map_index);
+
+#if defined(__SNOW_DUNGEON__)
+extern bool IS_SNOW_DUNGEON(int map_index);
+#endif
+
+#if defined(__ELEMENTAL_DUNGEON__)
+extern bool IS_ELEMENTAL_DUNGEON(int map_index);
+#endif
+
+extern bool CAN_ENTER_ZONE(const LPCHARACTER& ch, int map_index);
+extern bool IS_BLOCKED_PET(int map_index); // char.cpp
+extern bool IS_BLOCKED_PET_DUNGEON_MAP(int map_index);
+
+enum
+{
+	MAIN_RACE_WARRIOR_M,
+	MAIN_RACE_ASSASSIN_W,
+	MAIN_RACE_SURA_M,
+	MAIN_RACE_SHAMAN_W,
+	MAIN_RACE_WARRIOR_W,
+	MAIN_RACE_ASSASSIN_M,
+	MAIN_RACE_SURA_W,
+	MAIN_RACE_SHAMAN_M,
+	MAIN_RACE_WOLFMAN_M,
+	MAIN_RACE_MAX_NUM,
+};
+
+enum
+{
+	POISON_LENGTH = 30,
+	BLEEDING_LENGTH = 30,
+	STAMINA_PER_STEP = 1,
+	SAFEBOX_PAGE_SIZE = 9,
+	AI_CHANGE_ATTACK_POISITION_TIME_NEAR = 10000,
+	AI_CHANGE_ATTACK_POISITION_TIME_FAR = 1000,
+	AI_CHANGE_ATTACK_POISITION_DISTANCE = 100,
+	SUMMON_MONSTER_COUNT = 3,
+};
+
+enum
+{
+	FLY_NONE,
+	FLY_EXP,
+	FLY_HP_MEDIUM,
+	FLY_HP_BIG,
+	FLY_SP_SMALL,
+	FLY_SP_MEDIUM,
+	FLY_SP_BIG,
+	FLY_FIREWORK1,
+	FLY_FIREWORK2,
+	FLY_FIREWORK3,
+	FLY_FIREWORK4,
+	FLY_FIREWORK5,
+	FLY_FIREWORK6,
+	FLY_FIREWORK_CHRISTMAS,
+	FLY_CHAIN_LIGHTNING,
+	FLY_HP_SMALL,
+	FLY_SKILL_MUYEONG,
+#if defined(__QUIVER_SYSTEM__)
+	FLY_QUIVER_ATTACK_NORMAL,
+#endif
+#if defined(__CONQUEROR_LEVEL__)
+	FLY_ILGWANGPYO_NORMAL,
+	FLY_ILGWANGPYO_MASTER,
+	FLY_ILGWANGPYO_GRAND_MASTER,
+	FLY_ILGWANGPYO_PERFECT_MASTER,
+	FLY_CONQUEROR_EXP,
+#endif
+};
+
+enum EDamageType
+{
+	DAMAGE_TYPE_NONE,
+	DAMAGE_TYPE_NORMAL,
+	DAMAGE_TYPE_NORMAL_RANGE,
+	// 킬
+	DAMAGE_TYPE_MELEE,
+	DAMAGE_TYPE_RANGE,
+	DAMAGE_TYPE_FIRE,
+	DAMAGE_TYPE_ICE,
+	DAMAGE_TYPE_ELEC,
+	DAMAGE_TYPE_MAGIC,
+	DAMAGE_TYPE_POISON,
+	DAMAGE_TYPE_SPECIAL,
+	DAMAGE_TYPE_BLEEDING,
+};
+
+enum DamageFlag
+{
+	DAMAGE_NORMAL = (1 << 0),
+	DAMAGE_POISON = (1 << 1),
+	DAMAGE_DODGE = (1 << 2),
+	DAMAGE_BLOCK = (1 << 3),
+	DAMAGE_PENETRATE = (1 << 4),
+	DAMAGE_CRITICAL = (1 << 5),
+	DAMAGE_BLEEDING = (1 << 6),
+};
+
+enum EPKModes
+{
+	PK_MODE_PEACE,
+	PK_MODE_REVENGE,
+	PK_MODE_FREE,
+	PK_MODE_PROTECT,
+	PK_MODE_GUILD,
+	PK_MODE_MAX_NUM
+};
+
+enum EPositions
+{
+	POS_DEAD,
+	POS_SLEEPING,
+	POS_RESTING,
+	POS_SITTING,
+	POS_FISHING,
+	POS_FIGHTING,
+	POS_MOUNTING,
+	POS_STANDING
+};
+
+enum EBlockAction
+{
+	BLOCK_EXCHANGE = (1 << 0),
+	BLOCK_PARTY_INVITE = (1 << 1),
+	BLOCK_GUILD_INVITE = (1 << 2),
+	BLOCK_WHISPER = (1 << 3),
+	BLOCK_MESSENGER_INVITE = (1 << 4),
+	BLOCK_PARTY_REQUEST = (1 << 5),
+};
+
+#ifdef __OFFLINE_SHOP__
+enum EUnlockShopSkin
+{
+	UNLOCK_SHOP_SKIN_1 = (1 << 0),
+	UNLOCK_SHOP_SKIN_2 = (1 << 1),
+	UNLOCK_SHOP_SKIN_3 = (1 << 2),
+	UNLOCK_SHOP_SKIN_4 = (1 << 3),
+	UNLOCK_SHOP_SKIN_5 = (1 << 4),
+	UNLOCK_SHOP_SKIN_6 = (1 << 5),
+	UNLOCK_SHOP_SKIN_7 = (1 << 6),
+	UNLOCK_SHOP_SKIN_8 = (1 << 7),
+};
+
+enum EUnlockShopBanner
+{
+	UNLOCK_SHOP_BANNER_1 = (1 << 0),
+	UNLOCK_SHOP_BANNER_2 = (1 << 1),
+	UNLOCK_SHOP_BANNER_3 = (1 << 2),
+	UNLOCK_SHOP_BANNER_4 = (1 << 3),
+	UNLOCK_SHOP_BANNER_5 = (1 << 4),
+};
+#endif
+
+enum EAlignmentGrade
+{
+	ALIGN_GRADE_GOOD_4,
+	ALIGN_GRADE_GOOD_3,
+	ALIGN_GRADE_GOOD_2,
+	ALIGN_GRADE_GOOD_1,
+	ALIGN_GRADE_NORMAL,
+	ALIGN_GRADE_EVIL_1,
+	ALIGN_GRADE_EVIL_2,
+	ALIGN_GRADE_EVIL_3,
+	ALIGN_GRADE_EVIL_4,
+};
+
+enum EPointTypes
+{
+	POINT_NONE,								// 0
+	POINT_LEVEL,							// 1
+	POINT_VOICE,							// 2
+	POINT_EXP,								// 3
+	POINT_NEXT_EXP,							// 4
+	POINT_HP,								// 5
+	POINT_MAX_HP,							// 6
+	POINT_SP,								// 7
+	POINT_MAX_SP,							// 8
+	POINT_STAMINA,							// 9 瑠犬
+	POINT_MAX_STAMINA,						// 10 獵 瑠犬
+
+	POINT_GOLD,								// 11
+	POINT_ST,								// 12 慕
+	POINT_HT,								// 13 체
+	POINT_DX,								// 14 첩
+	POINT_IQ,								// 15 킹
+	POINT_DEF_GRADE,						// 16 ...
+	POINT_ATT_SPEED,						// 17 釜撻
+	POINT_ATT_GRADE,						// 18 賦 MAX
+	POINT_MOV_SPEED,						// 19 絹撻
+	POINT_CLIENT_DEF_GRADE,					// 20 
+	POINT_CASTING_SPEED,					// 21 岺撻 (牟타*100) / (100 + 隔) =  牟 타
+	POINT_MAGIC_ATT_GRADE,					// 22 賦
+	POINT_MAGIC_DEF_GRADE,					// 23 
+	POINT_EMPIRE_POINT,						// 24 
+	POINT_LEVEL_STEP,						// 25   丙.. (1 2 3   , 4 퓔  )
+	POINT_STAT,								// 26 렬 첩  獵 
+	POINT_SUB_SKILL,						// 27  킬 트
+	POINT_SKILL,							// 28 티 킬 트
+	POINT_WEAPON_MIN,						// 29  玲 
+	POINT_WEAPON_MAX,						// 30  獵 
+	POINT_PLAYTIME,							// 31 첨決챨
+	POINT_HP_REGEN,							// 32 HP 회
+	POINT_SP_REGEN,							// 33 SP 회
+
+	POINT_BOW_DISTANCE,						// 34 활 타 치 (meter)
+
+	POINT_HP_RECOVERY,						// 35 체 회 
+	POINT_SP_RECOVERY,						// 36 킹 회 
+
+	POINT_POISON_PCT,						// 37  확
+	POINT_STUN_PCT,							// 38  확
+	POINT_SLOW_PCT,							// 39 恝 확
+	POINT_CRITICAL_PCT,						// 40 크티 확
+	POINT_PENETRATE_PCT,					// 41 타 확
+	POINT_CURSE_PCT,						// 42  확
+
+	POINT_ATTBONUS_HUMAN,					// 43 寬 
+	POINT_ATTBONUS_ANIMAL,					// 44   % 
+	POINT_ATTBONUS_ORC,						// 45 沽  % 
+	POINT_ATTBONUS_MILGYO,					// 46 閨  % 
+	POINT_ATTBONUS_UNDEAD,					// 47 체  % 
+	POINT_ATTBONUS_DEVIL,					// 48 (퓔)  % 
+	POINT_ATTBONUS_INSECT,					// 49 
+	POINT_ATTBONUS_FIRE,					// 50 화
+	POINT_ATTBONUS_ICE,						// 51 
+	POINT_ATTBONUS_DESERT,					// 52 潁
+	POINT_ATTBONUS_MONSTER,					// 53  沽 
+	POINT_ATTBONUS_WARRIOR,					// 54 玲 
+	POINT_ATTBONUS_ASSASSIN,				// 55 微 
+	POINT_ATTBONUS_SURA,					// 56 璨“ 
+	POINT_ATTBONUS_SHAMAN,					// 57 玲 
+	POINT_ATTBONUS_TREE,					// 58   20050729.myevan UNUSED5
+
+	POINT_RESIST_WARRIOR,					// 59 玲 
+	POINT_RESIST_ASSASSIN,					// 60 微 
+	POINT_RESIST_SURA,						// 61 璨“ 
+	POINT_RESIST_SHAMAN,					// 62 玲 
+
+	POINT_STEAL_HP,							// 63  
+	POINT_STEAL_SP,							// 64 킹 
+
+	POINT_MANA_BURN_PCT,					// 65  
+
+	/// 灣 駕 ///
+
+	POINT_DAMAGE_SP_RECOVER,				// 66 莩  킹 회 확
+
+	POINT_BLOCK,							// 67 
+	POINT_DODGE,							// 68 회
+
+	POINT_RESIST_SWORD,						// 69
+	POINT_RESIST_TWOHAND,					// 70
+	POINT_RESIST_DAGGER,					// 71
+	POINT_RESIST_BELL,						// 72
+	POINT_RESIST_FAN,						// 73
+	POINT_RESIST_BOW,						// 74 화  :  
+	POINT_RESIST_FIRE,						// 75 화  : 화駙   
+	POINT_RESIST_ELEC,						// 76   : 駙   
+	POINT_RESIST_MAGIC,						// 77   :    
+	POINT_RESIST_WIND,						// 78 帽  : 帽駙   
+
+	POINT_REFLECT_MELEE,					// 79  部
+
+	/// 특 灣 ///
+	POINT_REFLECT_CURSE,					// 80  部
+	POINT_POISON_REDUCE,					// 81  
+
+	///  恬 ///
+	POINT_KILL_SP_RECOVER,					// 82  恬 MP 회
+	POINT_EXP_DOUBLE_BONUS,					// 83
+	POINT_GOLD_DOUBLE_BONUS,				// 84
+	POINT_ITEM_DROP_BONUS,					// 85
+
+	/// 회  ///
+	POINT_POTION_BONUS,						// 86
+	POINT_KILL_HP_RECOVERY,					// 87
+
+	POINT_IMMUNE_STUN,						// 88
+	POINT_IMMUNE_SLOW,						// 89
+	POINT_IMMUNE_FALL,						// 90
+	//////////////////
+
+	POINT_PARTY_ATTACKER_BONUS,				// 91
+	POINT_PARTY_TANKER_BONUS,				// 92
+
+	POINT_ATT_BONUS,						// 93
+	POINT_DEF_BONUS,						// 94
+
+	POINT_ATT_GRADE_BONUS,					// 95
+	POINT_DEF_GRADE_BONUS,					// 96
+	POINT_MAGIC_ATT_GRADE_BONUS,			// 97
+	POINT_MAGIC_DEF_GRADE_BONUS,			// 98
+
+	POINT_RESIST_NORMAL_DAMAGE,				// 99
+
+	POINT_HIT_HP_RECOVERY,					// 100
+	POINT_HIT_SP_RECOVERY,					// 101
+	POINT_MANASHIELD,						// 102 탉호 킬   효 
+
+	POINT_PARTY_BUFFER_BONUS,				// 103
+	POINT_PARTY_SKILL_MASTER_BONUS,			// 104
+
+	POINT_HP_RECOVER_CONTINUE,				// 105
+	POINT_SP_RECOVER_CONTINUE,				// 106
+
+	POINT_STEAL_GOLD,						// 107
+	POINT_POLYMORPH,						// 108   호
+	POINT_MOUNT,							// 109 타獵  호
+
+	POINT_PARTY_HASTE_BONUS,				// 110
+	POINT_PARTY_DEFENDER_BONUS,				// 111
+	POINT_STAT_RESET_COUNT,					// 112  輧     트 (1 1트 째)
+
+	POINT_HORSE_SKILL,						// 113
+
+	POINT_MALL_ATTBONUS,					// 114 賦 +x%
+	POINT_MALL_DEFBONUS,					// 115  +x%
+	POINT_MALL_EXPBONUS,					// 116 치 +x%
+	POINT_MALL_ITEMBONUS,					// 117   x/10
+	POINT_MALL_GOLDBONUS,					// 118   x/10
+
+	POINT_MAX_HP_PCT,						// 119 獵 +x%
+	POINT_MAX_SP_PCT,						// 120 獵킹 +x%
+
+	POINT_SKILL_DAMAGE_BONUS,				// 121 킬  *(100+x)%
+	POINT_NORMAL_HIT_DAMAGE_BONUS,			// 122 타  *(100+x)%
+
+	// DEFEND_BONUS_ATTRIBUTES
+	POINT_SKILL_DEFEND_BONUS,				// 123 킬  
+	POINT_NORMAL_HIT_DEFEND_BONUS,			// 124 타  
+	// END_OF_DEFEND_BONUS_ATTRIBUTES
+
+	// PC_BANG_ITEM_ADD 
+	POINT_PC_BANG_EXP_BONUS,				// 125 PC  치 駕
+	POINT_PC_BANG_DROP_BONUS,				// 126 PC  獺 駕
+	// END_PC_BANG_ITEM_ADD
+	POINT_RAMADAN_CANDY_BONUS_EXP,			// 127 窄떪  치 
+
+	POINT_ENERGY = 128,						// 128 
+
+	//  ui .
+	//   珂綬, 클潔트   챨 POINT 歐  肩 磯.
+	//  棺
+	POINT_ENERGY_END_TIME = 129,			// 129   챨
+
+	POINT_COSTUME_ATTR_BONUS = 130,			// 130
+	POINT_MAGIC_ATT_BONUS_PER = 131,		// 131
+	POINT_MELEE_MAGIC_ATT_BONUS_PER = 132,	// 132
+
+	// 煞 憺 
+	POINT_RESIST_ICE = 133,					// 133 챰  : 駙   
+	POINT_RESIST_EARTH = 134,				// 134   : 駙   
+	POINT_RESIST_DARK = 135,				// 135   : 駙   
+
+	POINT_RESIST_CRITICAL = 136,			// 136 크티  :  크티 확 
+	POINT_RESIST_PENETRATE = 137,			// 137 타  :  타 확 
+
+	POINT_BLEEDING_REDUCE = 138,			// 138
+	POINT_BLEEDING_PCT = 139,				// 139
+	POINT_ATTBONUS_WOLFMAN = 140,			// 140
+	POINT_RESIST_WOLFMAN = 141,				// 141
+	POINT_RESIST_CLAW = 142,				// 142
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	POINT_ACCEDRAIN_RATE,
+#endif
+#if defined(__MAGIC_REDUCTION__)
+	POINT_RESIST_MAGIC_REDUCTION,
+#endif
+#if defined(__CHEQUE_SYSTEM__)
+	POINT_CHEQUE,
+#endif
+	POINT_BATTLE_POINT,
+	POINT_RESIST_HUMAN,
+	POINT_ENCHANT_ELECT,
+	POINT_ENCHANT_FIRE,
+	POINT_ENCHANT_ICE,
+	POINT_ENCHANT_WIND,
+	POINT_ENCHANT_EARTH,
+	POINT_ENCHANT_DARK,
+	POINT_ATTBONUS_CZ,
+	POINT_BEAD,
+#if defined(__GEM_SYSTEM__)
+	POINT_GEM,
+#endif
+	POINT_ATTBONUS_SWORD,
+	POINT_ATTBONUS_TWOHAND,
+	POINT_ATTBONUS_DAGGER,
+	POINT_ATTBONUS_BELL,
+	POINT_ATTBONUS_FAN,
+	POINT_ATTBONUS_BOW,
+	POINT_ATTBONUS_CLAW,
+	POINT_RESIST_MOUNT_FALL,
+	POINT_RESIST_FIST,
+	POINT_PREMIUM_EXPBONUS,
+	POINT_PRIVILEGE_EXPBONUS,
+	POINT_MARRIAGE_EXPBONUS,
+	POINT_DEVILTOWER_EXPBONUS,
+	POINT_PREMIUM_ITEMBONUS,
+	POINT_PRIVILEGE_ITEMBONUS,
+	POINT_PREMIUM_GOLDBONUS,
+	POINT_PRIVILEGE_GOLDBONUS,
+	POINT_SKILL_DAMAGE_SAMYEON,
+	POINT_SKILL_DAMAGE_TANHWAN,
+	POINT_SKILL_DAMAGE_PALBANG,
+	POINT_SKILL_DAMAGE_GIGONGCHAM,
+	POINT_SKILL_DAMAGE_GYOKSAN,
+	POINT_SKILL_DAMAGE_GEOMPUNG,
+	POINT_SKILL_DAMAGE_AMSEOP,
+	POINT_SKILL_DAMAGE_GUNGSIN,
+	POINT_SKILL_DAMAGE_CHARYUN,
+	POINT_SKILL_DAMAGE_SANGONG,
+	POINT_SKILL_DAMAGE_YEONSA,
+	POINT_SKILL_DAMAGE_KWANKYEOK,
+	POINT_SKILL_DAMAGE_GIGUNG,
+	POINT_SKILL_DAMAGE_HWAJO,
+	POINT_SKILL_DAMAGE_SWAERYUNG,
+	POINT_SKILL_DAMAGE_YONGKWON,
+	POINT_SKILL_DAMAGE_PABEOB,
+	POINT_SKILL_DAMAGE_MARYUNG,
+	POINT_SKILL_DAMAGE_HWAYEOMPOK,
+	POINT_SKILL_DAMAGE_MAHWAN,
+	POINT_SKILL_DAMAGE_BIPABU,
+	POINT_SKILL_DAMAGE_YONGBI,
+	POINT_SKILL_DAMAGE_PAERYONG,
+	POINT_SKILL_DAMAGE_NOEJEON,
+	POINT_SKILL_DAMAGE_BYEURAK,
+	POINT_SKILL_DAMAGE_CHAIN,
+	POINT_SKILL_DAMAGE_CHAYEOL,
+	POINT_SKILL_DAMAGE_SALPOONG,
+	POINT_SKILL_DAMAGE_GONGDAB,
+	POINT_SKILL_DAMAGE_PASWAE,
+	POINT_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE,
+	POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE,
+	POINT_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE,
+	POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE,
+	POINT_HIT_BUFF_ENCHANT_FIRE,
+	POINT_HIT_BUFF_ENCHANT_ICE,
+	POINT_HIT_BUFF_ENCHANT_ELEC,
+	POINT_HIT_BUFF_ENCHANT_WIND,
+	POINT_HIT_BUFF_ENCHANT_DARK,
+	POINT_HIT_BUFF_ENCHANT_EARTH,
+	POINT_HIT_BUFF_RESIST_FIRE,
+	POINT_HIT_BUFF_RESIST_ICE,
+	POINT_HIT_BUFF_RESIST_ELEC,
+	POINT_HIT_BUFF_RESIST_WIND,
+	POINT_HIT_BUFF_RESIST_DARK,
+	POINT_HIT_BUFF_RESIST_EARTH,
+	POINT_USE_SKILL_CHEONGRANG_MOV_SPEED,
+	POINT_USE_SKILL_CHEONGRANG_CASTING_SPEED,
+	POINT_USE_SKILL_CHAYEOL_CRITICAL_PCT,
+	POINT_USE_SKILL_SANGONG_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_GIGUNG_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_JEOKRANG_DEF_BONUS,
+	POINT_USE_SKILL_GWIGEOM_DEF_BONUS,
+	POINT_USE_SKILL_TERROR_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_MUYEONG_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_MANASHILED_CASTING_SPEED,
+	POINT_USE_SKILL_HOSIN_DEF_BONUS,
+	POINT_USE_SKILL_GICHEON_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_JEUNGRYEOK_DEF_BONUS,
+	POINT_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_CHUNKEON_CASTING_SPEED,
+	POINT_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS,
+	POINT_SKILL_DURATION_INCREASE_EUNHYUNG,
+	POINT_SKILL_DURATION_INCREASE_GYEONGGONG,
+	POINT_SKILL_DURATION_INCREASE_GEOMKYUNG,
+	POINT_SKILL_DURATION_INCREASE_JEOKRANG,
+	POINT_USE_SKILL_PALBANG_HP_ABSORB,
+	POINT_USE_SKILL_AMSEOP_HP_ABSORB,
+	POINT_USE_SKILL_YEONSA_HP_ABSORB,
+	POINT_USE_SKILL_YONGBI_HP_ABSORB,
+	POINT_USE_SKILL_CHAIN_HP_ABSORB,
+	POINT_USE_SKILL_PASWAE_SP_ABSORB,
+	POINT_USE_SKILL_GIGONGCHAM_STUN,
+	POINT_USE_SKILL_CHARYUN_STUN,
+	POINT_USE_SKILL_PABEOB_STUN,
+	POINT_USE_SKILL_MAHWAN_STUN,
+	POINT_USE_SKILL_GONGDAB_STUN,
+	POINT_USE_SKILL_SAMYEON_STUN,
+	POINT_USE_SKILL_GYOKSAN_KNOCKBACK,
+	POINT_USE_SKILL_SEOMJEON_KNOCKBACK,
+	POINT_USE_SKILL_SWAERYUNG_KNOCKBACK,
+	POINT_USE_SKILL_HWAYEOMPOK_KNOCKBACK,
+	POINT_USE_SKILL_GONGDAB_KNOCKBACK,
+	POINT_USE_SKILL_KWANKYEOK_KNOCKBACK,
+	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_ATTBONUS_STONE,
+	POINT_DAMAGE_HP_RECOVERY,
+	POINT_DAMAGE_SP_RECOVERY,
+	POINT_ALIGNMENT_DAMAGE_BONUS,
+	POINT_NORMAL_DAMAGE_GUARD,
+	POINT_MORE_THEN_HP90_DAMAGE_REDUCE,
+	POINT_USE_SKILL_TUSOK_HP_ABSORB,
+	POINT_USE_SKILL_PAERYONG_HP_ABSORB,
+	POINT_USE_SKILL_BYEURAK_HP_ABSORB,
+	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_CHAYEOL_HP_ABSORB,
+	POINT_MEDAL_OF_HONOR,
+	POINT_ALL_STAT_BONUS,
+	POINT_SUNGMA_STR,
+	POINT_SUNGMA_HP,
+	POINT_SUNGMA_MOVE,
+	POINT_SUNGMA_IMMUNE,
+	POINT_CONQUEROR_LEVEL,
+	POINT_CONQUEROR_LEVEL_STEP,
+	POINT_CONQUEROR_EXP,
+	POINT_CONQUEROR_NEXT_EXP,
+	POINT_CONQUEROR_POINT,
+	POINT_HIT_PCT,
+	POINT_ATTBONUS_PER_HUMAN,
+	POINT_ATTBONUS_PER_ANIMAL,
+	POINT_ATTBONUS_PER_ORC,
+	POINT_ATTBONUS_PER_MILGYO,
+	POINT_ATTBONUS_PER_UNDEAD,
+	POINT_ATTBONUS_PER_DEVIL,
+	POINT_ENCHANT_PER_ELECT,
+	POINT_ENCHANT_PER_FIRE,
+	POINT_ENCHANT_PER_ICE,
+	POINT_ENCHANT_PER_WIND,
+	POINT_ENCHANT_PER_EARTH,
+	POINT_ENCHANT_PER_DARK,
+	POINT_ATTBONUS_PER_CZ,
+	POINT_ATTBONUS_PER_INSECT,
+	POINT_ATTBONUS_PER_DESERT,
+	POINT_ATTBONUS_PER_STONE,
+	POINT_ATTBONUS_PER_MONSTER,
+	POINT_RESIST_PER_HUMAN,
+	POINT_RESIST_PER_ICE,
+	POINT_RESIST_PER_DARK,
+	POINT_RESIST_PER_EARTH,
+	POINT_RESIST_PER_FIRE,
+	POINT_RESIST_PER_ELEC,
+	POINT_RESIST_PER_MAGIC,
+	POINT_RESIST_PER_WIND,
+	POINT_HIT_BUFF_SUNGMA_STR,
+	POINT_HIT_BUFF_SUNGMA_MOVE,
+	POINT_HIT_BUFF_SUNGMA_HP,
+	POINT_HIT_BUFF_SUNGMA_IMMUNE,
+	POINT_MOUNT_MELEE_MAGIC_ATTBONUS_PER,
+	POINT_DISMOUNT_MOVE_SPEED_BONUS_PER,
+	POINT_HIT_AUTO_HP_RECOVERY,
+	POINT_HIT_AUTO_SP_RECOVERY,
+	POINT_USE_SKILL_COOLTIME_DECREASE_ALL,
+	POINT_HIT_STONE_ATTBONUS_STONE,
+	POINT_HIT_STONE_DEF_GRADE_BONUS,
+	POINT_KILL_BOSS_ITEM_BONUS,
+	POINT_MOB_HIT_MOB_AGGRESSIVE,
+	POINT_NO_DEATH_AND_HP_RECOVERY30,
+	POINT_AUTO_PICKUP,
+	POINT_MOUNT_NO_KNOCKBACK,
+	POINT_SUNGMA_PER_STR,
+	POINT_SUNGMA_PER_HP,
+	POINT_SUNGMA_PER_MOVE,
+	POINT_SUNGMA_PER_IMMUNE,
+	POINT_IMMUNE_POISON100,
+	POINT_IMMUNE_BLEEDING100,
+	POINT_MONSTER_DEFEND_BONUS,
+
+	// 클潔트 트
+	POINT_MIN_WEP,
+	POINT_MAX_WEP,
+	POINT_MIN_MAGIC_WEP,
+	POINT_MAX_MAGIC_WEP,
+	POINT_HIT_RATE,
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	POINT_BATTLE_PASS_PREMIUM_ID
+#endif
+};
+
+// <Factor> Dynamically evaluated CHARACTER* equivalent.
+// Referring to SCharDeadEventInfo.
+struct DynamicCharacterPtr
+{
+	DynamicCharacterPtr() : is_pc(false), id(0) {}
+	DynamicCharacterPtr(const DynamicCharacterPtr& o)
+		: is_pc(o.is_pc), id(o.id) {}
+
+	// Returns the LPCHARACTER found in CHARACTER_MANAGER.
+	LPCHARACTER Get() const;
+	// Clears the current settings.
+	void Reset()
+	{
+		is_pc = false;
+		id = 0;
+	}
+
+	// Basic assignment operator.
+	DynamicCharacterPtr& operator=(const DynamicCharacterPtr& rhs)
+	{
+		is_pc = rhs.is_pc;
+		id = rhs.id;
+		return *this;
+	}
+	// Supports assignment with LPCHARACTER type.
+	DynamicCharacterPtr& operator=(LPCHARACTER character);
+	// Supports type casting to LPCHARACTER.
+	operator LPCHARACTER() const
+	{
+		return Get();
+	}
+
+	bool is_pc;
+	uint32_t id;
+};
+
+/* 求  */
+typedef struct character_point
+{
+	POINT_VALUE lPoints[POINT_MAX_NUM];
+
+	BYTE bJob;
+	BYTE bVoice;
+
+	BYTE bLevel;
+	DWORD dwExp;
+
+#if defined(__CONQUEROR_LEVEL__)
+	BYTE bConquerorLevel;
+	DWORD dwConquerorExp;
+#endif
+
+	int iGold;
+#if defined(__CHEQUE_SYSTEM__)
+	int iCheque;
+#endif
+#if defined(__GEM_SYSTEM__)
+	int iGem;
+#endif
+
+	int iHP, iSP;
+	int iRandomHP, iRandomSP;
+	int iStamina;
+
+	BYTE bSkillGroup;
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	int battle_pass_premium_id;
+#endif
+} CHARACTER_POINT;
+
+/*  苛 캐  */
+typedef struct character_point_instant
+{
+	POINT_VALUE points[POINT_MAX_NUM];
+
+	float fRot;
+
+	int iMaxHP;
+	int iMaxSP;
+
+	long position;
+
+	long instant_flag;
+	DWORD dwAIFlag;
+	DWORD dwImmuneFlag;
+	DWORD dwLastShoutPulse;
+
+	DWORD adwParts[PART_MAX_NUM];
+
+	LPITEM pInventoryItems[INVENTORY_MAX_NUM];
+	WORD wInventoryItemGrid[INVENTORY_MAX_NUM];
+
+	LPITEM pEquipmentItems[EQUIPMENT_MAX_NUM];
+	BYTE bEquipmentItemGrid[EQUIPMENT_MAX_NUM];
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	// 혼 觀訝.
+	LPITEM pDragonSoulInventoryItems[DRAGON_SOUL_INVENTORY_MAX_NUM];
+	WORD wDragonSoulInventoryItemGrid[DRAGON_SOUL_INVENTORY_MAX_NUM];
+#endif
+
+	LPITEM pBeltInventoryItems[BELT_INVENTORY_MAX_NUM];
+	BYTE bBeltInventoryItemGrid[BELT_INVENTORY_MAX_NUM];
+
+#if !defined(__CUBE_RENEWAL__)
+	// by mhh
+	LPITEM pCubeItems[CUBE_MAX_NUM];
+#endif
+	LPCHARACTER pCubeNpc;
+#if defined(__MOVE_COSTUME_ATTR__)
+	LPCHARACTER pItemCombNpc;
+#endif
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	LPCHARACTER pRouletteNPC;
+#endif
+#if defined(__ATTR_6TH_7TH__)
+	LPITEM pNPCStorageItems;
+#endif
+
+	BYTE gm_level;
+
+	BYTE bBasePart; //  호
+
+	int iMaxStamina;
+
+	BYTE bBlockMode;
+#ifdef __OFFLINE_SHOP__
+	BYTE bUnlockedShopSkin;
+	BYTE bUnlockedShopBanner;
+#endif
+	int iDragonSoulActiveDeck;
+	int iDragonSoulRefineDeckSnapshot;
+	LPENTITY m_pDragonSoulRefineWindowOpener;
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	LPENTITY m_pAcceRefineWindowOpener;
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	LPENTITY m_pAuraRefineWindowOpener;
+#endif
+} CHARACTER_POINT_INSTANT;
+
+#define TRIGGERPARAM LPCHARACTER ch, LPCHARACTER causer
+
+typedef struct trigger
+{
+	BYTE type;
+	int (*func) (TRIGGERPARAM);
+	long value;
+} TRIGGER;
+
+class CTrigger
+{
+public:
+	CTrigger() : bType(0), pFunc(NULL)
+	{
+	}
+
+	BYTE bType;
+	int (*pFunc) (TRIGGERPARAM);
+};
+
+EVENTINFO(char_event_info)
+{
+	DynamicCharacterPtr ch;
+};
+
+struct TSkillUseInfo
+{
+	int iHitCount;
+	int iMaxHitCount;
+	int iSplashCount;
+	DWORD dwNextSkillUsableTime;
+	int iRange;
+	bool bUsed;
+	DWORD dwVID;
+	bool isGrandMaster;
+
+	std::unordered_map<DWORD, std::size_t> TargetVIDMap;
+
+	TSkillUseInfo()
+		: iHitCount(0), iMaxHitCount(0), iSplashCount(0), dwNextSkillUsableTime(0), iRange(0), bUsed(false),
+		dwVID(0), isGrandMaster(false)
+	{}
+
+	bool HitOnce(DWORD dwVnum = 0);
+
+	bool UseSkill(bool isGrandMaster, DWORD vid, DWORD dwCooltime, int splashcount = 1, int hitcount = -1, int range = -1);
+	DWORD GetMainTargetVID() const { return dwVID; }
+	void SetMainTargetVID(DWORD vid) { dwVID = vid; }
+	void ResetHitCount() { if (iSplashCount) { iHitCount = iMaxHitCount; iSplashCount--; } }
+};
+
+typedef struct packet_party_update TPacketGCPartyUpdate;
+class CExchange;
+class CSkillProto;
+class CParty;
+class CDungeon;
+#if defined(__DEFENSE_WAVE__)
+class CDefenseWave;
+#endif
+class CWarMap;
+class CAffect;
+class CGuild;
+class CSafebox;
+class CArena;
+
+class CShop;
+typedef class CShop* LPSHOP;
+
+class CMob;
+class CMobInstance;
+typedef struct SMobSkillInfo TMobSkillInfo;
+
+// SKILL_POWER_BY_LEVEL
+extern int GetSkillPowerByLevelFromType(int job, int skillgroup, int skilllevel);
+// END_SKILL_POWER_BY_LEVEL
+
+namespace marriage
+{
+	class WeddingMap;
+}
+enum e_overtime
+{
+	OT_NONE,
+	OT_3HOUR,
+	OT_5HOUR,
+};
+
+typedef std::list<CAffect*> AffectContainerList;
+typedef std::unordered_map<DWORD, BYTE> AffectStackMap;
+typedef std::map<int, LPEVENT> MobSkillEventMap;
+
+class CHARACTER : public CEntity, public CFSM, public CHorseRider
+{
+protected:
+	//////////////////////////////////////////////////////////////////////////////////
+	// Entity 
+	virtual void EncodeInsertPacket(LPENTITY entity);
+	virtual void EncodeRemovePacket(LPENTITY entity);
+	//////////////////////////////////////////////////////////////////////////////////
+
+public:
+	LPCHARACTER FindCharacterInView(const char* name, bool bFindPCOnly);
+	void UpdatePacket();
+
+	//////////////////////////////////////////////////////////////////////////////////
+	// FSM (Finite State Machine) 
+protected:
+	CStateTemplate<CHARACTER> m_stateMove;
+	CStateTemplate<CHARACTER> m_stateBattle;
+	CStateTemplate<CHARACTER> m_stateIdle;
+
+public:
+	virtual void StateMove();
+	virtual void StateBattle();
+	virtual void StateIdle();
+	virtual void StateFlag();
+	virtual void StateFlagBase();
+	void StateHorse();
+
+protected:
+	// STATE_IDLE_REFACTORING
+	void __StateIdle_Monster();
+	void __StateIdle_Stone();
+	void __StateIdle_NPC();
+	// END_OF_STATE_IDLE_REFACTORING
+
+public:
+	DWORD GetAIFlag() const { return m_pointsInstant.dwAIFlag; }
+
+	void SetAggressive(bool bSet = true);
+	bool IsAggressive() const;
+
+	void SetCoward();
+	bool IsCoward() const;
+	void CowardEscape();
+
+	void SetNoAttackShinsu();
+	bool IsNoAttackShinsu() const;
+
+	void SetNoAttackChunjo();
+	bool IsNoAttackChunjo() const;
+
+	void SetNoAttackJinno();
+	bool IsNoAttackJinno() const;
+
+	void SetAttackMob();
+	bool IsAttackMob() const;
+
+	void SetNoMove();
+	bool IsNoMove() const;
+
+	virtual void BeginStateEmpty();
+	virtual void EndStateEmpty() {}
+
+	void Restart(BYTE bSubCMD);
+	void RestartAtSamePos();
+
+protected:
+	DWORD m_dwStateDuration;
+	//////////////////////////////////////////////////////////////////////////////////
+
+public:
+	CHARACTER();
+	virtual ~CHARACTER();
+
+	void Create(const char* c_pszName, DWORD vid, bool isPC);
+	void Destroy();
+
+	void Disconnect(const char* c_pszReason);
+
+protected:
+	void Initialize();
+
+	//////////////////////////////////////////////////////////////////////////////////
+	// Basic Points
+
+public:
+	DWORD GetPlayerID() const { return m_dwPlayerID; }
+
+	void SetPlayerProto(const TPlayerTable* table);
+	void CreatePlayerProto(TPlayerTable& tab); //   
+
+	void SetProto(const CMob* c_pkMob);
+	WORD GetRaceNum() const;
+
+	void Save(); // DelayedSave
+	void SaveReal(); //  
+	void FlushDelayedSaveItem();
+
+	const char* GetName() const;
+	const VID& GetVID() const { return m_vid; }
+
+	void SetName(const std::string& name) { m_stName = name; }
+
+	void SetRace(BYTE race);
+	bool ChangeSex();
+
+	bool IsFemale() const;
+	bool IsMale() const;
+
+	DWORD GetAID() const;
+	int GetChangeEmpireCount() const;
+	void SetChangeEmpireCount();
+	int ChangeEmpire(BYTE empire);
+
+	BYTE GetJob() const;
+	BYTE GetCharType() const;
+
+	bool IsPC() const { return GetDesc() ? true : false; }
+	bool IsNPC() const { return m_bCharType != CHAR_TYPE_PC; }
+	bool IsMonster() const { return m_bCharType == CHAR_TYPE_MONSTER; }
+	bool IsStone() const { return m_bCharType == CHAR_TYPE_STONE; }
+	bool IsDoor() const { return m_bCharType == CHAR_TYPE_DOOR; }
+	bool IsBuilding() const { return m_bCharType == CHAR_TYPE_BUILDING; }
+	bool IsWarp() const { return m_bCharType == CHAR_TYPE_WARP; }
+	bool IsGoto() const { return m_bCharType == CHAR_TYPE_GOTO; }
+	bool IsHorse() const { return m_bCharType == CHAR_TYPE_HORSE; }
+	bool IsPetPay() const { return m_bCharType == CHAR_TYPE_PET_PAY; }
+	//bool IsPet() const { return m_bCharType == CHAR_TYPE_PET; }
+
+	DWORD GetLastShoutPulse() const { return m_pointsInstant.dwLastShoutPulse; }
+	void SetLastShoutPulse(DWORD pulse) { m_pointsInstant.dwLastShoutPulse = pulse; }
+
+	BYTE GetGMLevel() const;
+	BOOL IsGM() const;
+	void SetGMLevel();
+
+	void SetLevel(BYTE bValue);
+	BYTE GetLevel() const { return m_points.bLevel; }
+
+	void SetExp(DWORD dwValue) { m_points.dwExp = dwValue; }
+	DWORD GetExp() const { return m_points.dwExp; }
+	DWORD GetNextExp() const;
+
+#if defined(__CONQUEROR_LEVEL__)
+	void SetConqueror(bool bSet = true);
+
+	void SetConquerorLevel(BYTE bValue) { m_points.bConquerorLevel = bValue; }
+	BYTE GetConquerorLevel() const { return m_points.bConquerorLevel; }
+
+	void SetConquerorExp(DWORD dwValue) { m_points.dwConquerorExp = dwValue; }
+	DWORD GetConquerorExp() const { return m_points.dwConquerorExp; }
+	DWORD GetNextConquerorExp() const;
+#endif
+
+	LPCHARACTER DistributeExp(); //     磯.
+
+	void DistributeHP(LPCHARACTER pkKiller);
+	void DistributeSP(LPCHARACTER pkKiller, int iMethod = 0);
+
+	void SetPosition(int pos);
+	bool IsPosition(int pos) const { return m_pointsInstant.position == pos ? true : false; }
+	int GetPosition() const { return m_pointsInstant.position; }
+
+	void SetPart(BYTE bPartPos, DWORD dwVal);
+	DWORD GetPart(BYTE bPartPos) const;
+	DWORD GetOriginalPart(BYTE bPartPos) const;
+
+	void SetHP(int val) { m_points.iHP = val; }
+	int GetHP() const { return m_points.iHP; }
+
+	void SetSP(int val) { m_points.iSP = val; }
+	int GetSP() const { return m_points.iSP; }
+
+	void SetMaxHP(int val) { m_pointsInstant.iMaxHP = val; }
+	int GetMaxHP() const { return m_pointsInstant.iMaxHP; }
+
+	void SetMaxSP(int val) { m_pointsInstant.iMaxSP = val; }
+	int GetMaxSP() const { return m_pointsInstant.iMaxSP; }
+
+	void SetStamina(int iValue) { m_points.iStamina = iValue; }
+	int GetStamina() const { return m_points.iStamina; }
+
+	void SetMaxStamina(int iValue) { m_pointsInstant.iMaxStamina = iValue; }
+	int GetMaxStamina() const { return m_pointsInstant.iMaxStamina; }
+
+	void SetRandomHP(int iValue) { m_points.iRandomHP = iValue; }
+	int GetRandomHP() const { return m_points.iRandomHP; }
+
+	void SetRandomSP(int iValue) { m_points.iRandomSP = iValue; }
+	int GetRandomSP() const { return m_points.iRandomSP; }
+
+	int GetHPPct() const;
+
+	void SetRealPoint(POINT_TYPE wPointType, POINT_VALUE lPointValue);
+	POINT_VALUE GetRealPoint(POINT_TYPE wPointType) const;
+
+	void SetPoint(POINT_TYPE wPointType, POINT_VALUE lPointValue);
+	POINT_VALUE GetPoint(POINT_TYPE wPointType) const;
+
+	POINT_VALUE GetLimitPoint(POINT_TYPE wPointType) const;
+	POINT_VALUE GetPolymorphPoint(POINT_TYPE wPointType) const;
+
+	const TMobTable& GetMobTable() const;
+	BYTE GetMobRank() const;
+	BYTE GetMobType() const;
+	BYTE GetMobBattleType() const;
+	BYTE GetMobSize() const;
+	DWORD GetMobDamageMin() const;
+	DWORD GetMobDamageMax() const;
+	WORD GetMobAttackRange() const;
+	DWORD GetMobDropItemVnum() const;
+	float GetMobDamageMultiply() const;
+#if defined(__ELEMENT_SYSTEM__)
+	int GetMobElement(BYTE bElement) const;
+#endif
+	float GetMonsterHitRange() const;
+
+	// NEWAI
+	bool IsBerserker() const;
+	bool IsBerserk() const;
+	void SetBerserk(bool mode);
+
+	bool IsStoneSkinner() const;
+
+	bool IsGodSpeeder() const;
+	bool IsGodSpeed() const;
+	void SetGodSpeed(bool mode);
+
+	bool IsDeathBlower() const;
+	bool IsDeathBlow() const;
+
+	bool IsHealer() const;
+	bool IsFaller() const;
+
+	bool IsReviver() const;
+	bool HasReviverInParty() const;
+	bool IsRevive() const;
+	void SetRevive(bool mode);
+	// NEWAI END
+
+	bool IsRaceFlag(DWORD dwBit) const;
+	bool IsSummonMonster() const;
+	DWORD GetSummonVnum() const;
+
+	int m_newSummonInterval;
+	int m_lastSummonTime;
+
+	bool CanSummonMonster() const;
+	void MarkSummonedMonster();
+
+	DWORD GetPolymorphItemVnum() const;
+	DWORD GetMonsterDrainSPPoint() const;
+
+	void MainCharacterPacket(); //  캐尻 娩.
+
+	void ComputePoints();
+	void ComputeBattlePoints();
+
+	void PointChange(POINT_TYPE wPointType, POINT_VALUE lPointAmount, bool bAmount = false, bool bBroadcast = false);
+	void PointsPacket();
+	void UpdatePointsPacket(POINT_TYPE wPointType, POINT_VALUE lPointValue, POINT_VALUE lPointAmount = 0, bool bAmount = false, bool bBroadcast = false);
+
+	void ApplyPoint(POINT_TYPE wApplyType, POINT_VALUE lApplyValue);
+	void CheckMaximumPoints(); // HP, SP    獵諛   講構 摸 .
+
+
+	bool Show(long lMapIndex, long x, long y, long z = LONG_MAX, bool bShowSpawnMotion = false
+#if defined(__WJ_SHOW_MOB_INFO__)
+		, bool bAggressive = false
+#endif
+	);
+
+	void Sitdown(int is_ground);
+	void Standup();
+
+	void SetRotation(float fRot);
+	void SetRotationToXY(long x, long y);
+	float GetRotation() const { return m_pointsInstant.fRot; }
+
+	void MotionPacketEncode(BYTE motion, LPCHARACTER victim, struct packet_motion* packet);
+	void Motion(BYTE motion, LPCHARACTER victim = NULL);
+
+	void ChatPacket(BYTE type, const char* format, ...);
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	void ChatPacket(packet_chat pack_chat, const char* format, ...);
+#endif
+	void MonsterChat(BYTE bMonsterChatType);
+	void SendGreetMessage();
+
+	void ResetPoint(int iLv);
+	void ResetExp();
+
+#if defined(__CONQUEROR_LEVEL__)
+	void ResetConquerorPoint(int iLv);
+	void ResetConquerorExp();
+#endif
+
+	void SetBlockMode(BYTE bFlag);
+	void SetBlockModeForce(BYTE bFlag);
+	bool IsBlockMode(BYTE bFlag) const { return (m_pointsInstant.bBlockMode & bFlag) ? true : false; }
+#ifdef __OFFLINE_SHOP__
+	void SendUnlockedShopDeco();
+	void SetUnlockShopSkin(BYTE bFlag);
+	void SetUnlockShopBanner(BYTE bFlag);
+	bool IsUnlockedShopSkin(BYTE bFlag) const { return (m_pointsInstant.bUnlockedShopSkin & bFlag) ? true : false; }
+	bool IsUnlockedShopBanner(BYTE bFlag) const { return (m_pointsInstant.bUnlockedShopBanner & bFlag) ? true : false; }
+#endif
+	bool IsPolymorphed() const { return m_dwPolymorphRace > 0; }
+	bool IsPolyMaintainStat() const { return m_bPolyMaintainStat; } //   求 .
+	void SetPolymorph(DWORD dwRaceNum, bool bMaintainStat = false);
+	DWORD GetPolymorphVnum() const { return m_dwPolymorphRace; }
+	int GetPolymorphPower() const;
+
+	// FISING
+	void fishing();
+	void fishing_take();
+	bool IsFishing() const { return m_pkFishingEvent ? true : false; }
+	// END_OF_FISHING
+
+	// MINING
+	void mining(LPCHARACTER chLoad);
+	void mining_cancel();
+	void mining_take();
+	bool IsMining() const { return m_pkMiningEvent ? true : false; }
+	// END_OF_MINING
+
+	void ResetPlayTime(DWORD dwTimeRemain = 0);
+
+	void CreateFly(BYTE bType, LPCHARACTER pkVictim);
+
+	void ResetChatCounter() { m_bChatCounter = 0; }
+	void IncreaseChatCounter() { ++m_bChatCounter; }
+	BYTE GetChatCounter() const { return m_bChatCounter; }
+
+	void ResetWhisperCounter() { m_bWhisperCounter = 0; }
+	bool IncreaseWhisperCounter() { ++m_bWhisperCounter; return m_bWhisperCounter; }
+	BYTE GetWhisperCounter() const { return m_bWhisperCounter; }
+
+protected:
+	DWORD m_dwPolymorphRace;
+	bool m_bPolyMaintainStat;
+	DWORD m_dwLoginPlayTime;
+	DWORD m_dwPlayerID;
+	DWORD m_dwTargetVID;
+	VID m_vid;
+	std::string m_stName;
+	BYTE m_bCharType;
+
+	CHARACTER_POINT m_points;
+	CHARACTER_POINT_INSTANT m_pointsInstant;
+
+	int m_iMoveCount;
+	DWORD m_dwPlayStartTime;
+	BYTE m_bAddChrState;
+	bool m_bSkipSave;
+	BYTE m_bChatCounter;
+	BYTE m_bWhisperCounter;
+
+	// End of Basic Points
+
+	//////////////////////////////////////////////////////////////////////////////////
+	// Move & Synchronize Positions
+	//////////////////////////////////////////////////////////////////////////////////
+public:
+	bool IsStateMove() const { return IsState((CState&)m_stateMove); }
+	bool IsStateIdle() const { return IsState((CState&)m_stateIdle); }
+	bool IsWalking() const { return m_bNowWalking || GetStamina() <= 0; }
+	void SetWalking(bool bWalkFlag) { m_bWalking = bWalkFlag; }
+	void SetNowWalking(bool bWalkFlag);
+	void ResetWalking() { SetNowWalking(m_bWalking); }
+
+	bool Goto(long x, long y); // 慕 絹 키 歌 표 치 BLENDING 킨.
+	void Stop();
+
+	bool CanMove() const; // 絹  獵째?
+
+	void SyncPacket();
+	bool Sync(long x, long y); //   氷撚 絹 磯 (  퓻  絹 柰 )
+	bool Move(long x, long y); //  講構 Sync 氷撚躍  絹 磯.
+	void OnMove(bool bIsAttack = false); // 灸 恬. Move() 氷撚 結餠 恬  獵.
+	DWORD GetMotionMode() const;
+	float GetMoveMotionSpeed() const;
+	float GetMoveSpeed() const;
+	void CalculateMoveDuration();
+	void SendMovePacket(BYTE bFunc, BYTE bArg, DWORD x, DWORD y, DWORD dwDuration, DWORD dwTime = 0, int iRot = -1);
+
+	DWORD GetCurrentMoveDuration() const { return m_dwMoveDuration; }
+	DWORD GetWalkStartTime() const { return m_dwWalkStartTime; }
+	DWORD GetLastMoveTime() const { return m_dwLastMoveTime; }
+	DWORD GetLastAttackTime() const { return m_dwLastAttackTime; }
+
+	void SetLastAttacked(DWORD time); //  赴 챨  치 
+
+	bool SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList = true);
+	bool IsSyncOwner(LPCHARACTER ch) const;
+
+	bool WarpSet(long x, long y, long lRealMapIndex = 0);
+	void SetWarpLocation(long lMapIndex, long x, long y);
+	void WarpEnd();
+	const PIXEL_POSITION& GetWarpPosition() const { return m_posWarp; }
+	bool WarpToPID(DWORD dwPID, bool bWarpForce = false);
+
+	void SaveExitLocation();
+	void ExitToSavedLocation();
+
+	void StartStaminaConsume();
+	void StopStaminaConsume();
+	bool IsStaminaConsume() const;
+	bool IsStaminaHalfConsume() const;
+
+	void ResetStopTime();
+	DWORD GetStopTime() const;
+
+#if defined(__MOVE_CHANNEL__)
+	bool MoveChannel(long lNewAddr, WORD wNewPort);
+	bool StartMoveChannel(long lNewAddr, WORD wNewPort);
+#endif
+
+protected:
+	void ClearSync();
+
+	float m_fSyncTime;
+	LPCHARACTER m_pkChrSyncOwner;
+	CHARACTER_LIST m_kLst_pkChrSyncOwned; //  SyncOwner 湄
+
+	PIXEL_POSITION m_posDest;
+	PIXEL_POSITION m_posStart;
+	PIXEL_POSITION m_posWarp;
+	long m_lWarpMapIndex;
+
+	PIXEL_POSITION m_posExit;
+	long m_lExitMapIndex;
+
+	DWORD m_dwMoveStartTime;
+	DWORD m_dwMoveDuration;
+
+	DWORD m_dwLastMoveTime;
+	DWORD m_dwLastAttackTime;
+	DWORD m_dwWalkStartTime;
+	DWORD m_dwStopTime;
+
+	bool m_bWalking;
+	bool m_bNowWalking;
+	bool m_bStaminaConsume;
+
+	// End
+
+	// Quickslot 
+public:
+	void SyncQuickslot(BYTE bType, WORD wOldPos, WORD wNewPos);
+	bool GetQuickslot(BYTE pos, TQuickslot** ppSlot);
+	bool SetQuickslot(BYTE pos, TQuickslot& rSlot);
+	bool DelQuickslot(BYTE pos);
+	bool SwapQuickslot(BYTE a, BYTE b);
+	void ChainQuickslotItem(LPITEM pItem, BYTE bType, WORD wOldPos);
+	void MoveQuickSlotItem(BYTE bOldType, WORD wOldPos, BYTE bNewType, WORD wNewPos);
+
+	void CheckQuickSlotItems();
+	bool CanAddToQuickSlot(LPITEM pItem);
+
+protected:
+	TQuickslot m_quickslot[QUICKSLOT_MAX_NUM];
+
+#if defined(__LUCKY_BOX__)
+public:
+	void SetLuckyBoxSrcItem(LPITEM lpItem);
+	void SendLuckyBoxInfo();
+	void LuckyBoxRetry();
+	void LuckyBoxReceive();
+	int GetLuckyBoxPrice() const;
+	bool IsLuckyBoxOpen() const;
+	void ResetLuckyBoxData();
+
+private:
+	struct
+	{
+		DWORD dwSrcItemVNum;
+		DWORD dwSrcItemID;
+		WORD wSrcSlotIndex;
+		BYTE bTryCount;
+		DWORD dwItemVNum;
+		BYTE bItemCount;
+	} m_sLuckyBox;
+#endif
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Affect
+public:
+	void StartAffectEvent();
+	void ClearAffect(bool bSave = false);
+	void ComputeAffect(const CAffect* pkAff, bool bAdd);
+	bool AddAffect(DWORD dwType, POINT_TYPE wApplyOn, POINT_VALUE lApplyValue, DWORD dwFlag, long lDuration, long lSPCost, bool bOverride, bool IsCube = false
+#if defined(__AFFECT_RENEWAL__)
+		, bool bRealTime = false
+#endif
+#if defined(__9TH_SKILL__)
+		, long lValue = 0 /* Skill iAmount2 */
+#endif
+	);
+#if defined(__AFFECT_RENEWAL__)
+	bool AddRealTimeAffect(DWORD dwType, POINT_TYPE wApplyOn, POINT_VALUE lApplyValue, DWORD dwFlag, long lDuration, long lSPCost, bool bOverride, bool IsCube = false, bool bRealTime = true);
+#endif
+	void RefreshAffect();
+	bool RemoveAffect(DWORD dwType);
+#if defined(__SOUL_SYSTEM__)
+	void RemoveAffect(DWORD dwType, POINT_TYPE wApplyType);
+#endif
+	bool IsAffectFlag(DWORD dwAff) const;
+
+	bool UpdateAffect(); // called from EVENT
+	int ProcessAffect();
+
+	void LoadAffect(DWORD dwCount, TPacketAffectElement* pElements);
+	void SaveAffect();
+
+public:
+	// Affect loading  寬?
+	bool IsLoadedAffect() const { return m_bIsLoadedAffect; }
+
+	bool IsGoodAffect(BYTE bAffectType) const;
+
+	void RemoveGoodAffect();
+	void RemoveBadAffect();
+
+	CAffect* FindAffect(DWORD dwType, POINT_TYPE wApplyType = APPLY_NONE) const;
+	const AffectContainerList& GetAffectContainer() const { return m_list_pkAffect; }
+	bool RemoveAffect(CAffect* pkAff);
+
+	//void SetAffectStack(CAffect* pkAff, BYTE value);
+	//BYTE GetAffectStack(CAffect* pkAff);
+	//void ClearAffectStack(CAffect* pkAff);
+	//
+	//AffectStackMap m_map_affectStack;
+
+protected:
+	bool m_bIsLoadedAffect;
+	TAffectFlag m_afAffectFlag;
+	AffectContainerList m_list_pkAffect;
+
+public:
+	// PARTY_JOIN_BUG_FIX
+	void SetParty(LPPARTY pkParty);
+	LPPARTY GetParty() const { return m_pkParty; }
+
+	bool RequestToParty(LPCHARACTER leader);
+	void DenyToParty(LPCHARACTER member);
+	void AcceptToParty(LPCHARACTER member);
+
+	/// 黴 티 摸 character  苛磯.
+	/**
+	* @param pchInvitee 苛  character. 티   潔 磯.
+	*
+	*  character  째 티 苛構 苛  獵 째 틈灸 苛求 캐沽 娩求 채 氷 磯.
+	**/
+	void PartyInvite(LPCHARACTER pchInvitee);
+
+	/// 苛杉 character   처磯.
+	/**
+	* @param pchInvitee 티  character. 티  潔 磯.
+	*
+	* pchInvitee  티   獵 황 틈灸 娩求 채 氷 磯.
+	**/
+	void PartyInviteAccept(LPCHARACTER pchInvitee);
+
+	/// 苛杉 character  苛 탄罐 처磯.
+	/**
+	* @param [in] dwPID 苛 杉 character  PID
+	**/
+	void PartyInviteDeny(DWORD dwPID);
+
+	bool BuildUpdatePartyPacket(TPacketGCPartyUpdate& out);
+	int GetLeadershipSkillLevel() const;
+#if defined(__PARTY_PROFICY__)
+	int GetRoleProficiencySkillLevel() const;
+#endif
+#if defined(__PARTY_INSIGHT__)
+	int GetInSightSkillLevel() const;
+#endif
+
+	bool CanSummon(int iLeaderShip);
+
+	void SetPartyRequestEvent(LPEVENT pkEvent) { m_pkPartyRequestEvent = pkEvent; }
+
+protected:
+
+	/// 티 磯.
+	/**
+	* @param pkLeader  티 
+	**/
+	void PartyJoin(LPCHARACTER pkLeader);
+
+	/**
+	* 티      湄.
+	* Error code  챨 寬  麗(mutable) type  (static) type  .
+	* Error code   PERR_SEPARATOR   麗 type 隔   type 甄.
+	**/
+	enum PartyJoinErrCode
+	{
+		PERR_NONE = 0, ///< 처
+		PERR_SERVER, ///<  티 처 柰
+		PERR_DUNGEON, ///< 캐叩  
+		PERR_OBSERVER, ///< 
+		PERR_LVBOUNDARY, ///<  캐沽 隔 
+		PERR_LOWLEVEL, ///< 티 斂 30 
+		PERR_HILEVEL, ///< 티  30 
+		PERR_ALREADYJOIN, ///< 티  캐叩 譴 티
+		PERR_PARTYISFULL, ///< 티恝  歌
+		PERR_SEPARATOR, ///< Error type separator.
+		PERR_DIFFEMPIRE, ///<  캐沽 摸 
+		PERR_MAX ///< Error code 斂치.  纜 Error code  煞磯.
+	};
+
+	/// 티 犬 消   講磯.
+	/**
+	* @param pchLeader 티 leader 隔킬 苛 character
+	* @param pchGuest 苛濱 character
+	* @return  PartyJoinErrCode  환  獵.
+	**/
+	static PartyJoinErrCode IsPartyJoinableCondition(const LPCHARACTER pchLeader, const LPCHARACTER pchGuest);
+
+	/// 티 犬 消    講磯.
+	/**
+	* @param pchLeader 티 leader 隔킬 苛 character
+	* @param pchGuest 苛濱 character
+	* @return mutable type  code  환磯.
+	**/
+	static PartyJoinErrCode IsPartyJoinableMutableCondition(const LPCHARACTER pchLeader, const LPCHARACTER pchGuest);
+
+	LPPARTY m_pkParty;
+	DWORD m_dwLastDeadTime;
+	LPEVENT m_pkPartyRequestEvent;
+
+	/**
+	* 티청 Event map.
+	* key: 苛 캐 PID
+	* value: event pointer
+	*
+	* 苛 캐孤涌  event map.
+	**/
+	typedef std::map<DWORD, LPEVENT> EventMap;
+	EventMap m_PartyInviteEventMap;
+
+	// END_OF_PARTY_JOIN_BUG_FIX
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Dungeon
+public:
+	void SetDungeon(LPDUNGEON pkDungeon);
+	LPDUNGEON GetDungeon() const { return m_pkDungeon; }
+	LPDUNGEON GetDungeonForce() const;
+protected:
+	LPDUNGEON m_pkDungeon;
+	int m_iEventAttr;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Guild
+public:
+	void SetGuild(CGuild* pGuild);
+	CGuild* GetGuild() const { return m_pGuild; }
+
+	void SetWarMap(CWarMap* pWarMap);
+	CWarMap* GetWarMap() const { return m_pWarMap; }
+
+protected:
+	CGuild* m_pGuild;
+	DWORD m_dwUnderGuildWarInfoMessageTime;
+	CWarMap* m_pWarMap;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Item related
+public:
+	bool CanHandleItem(bool bSkipRefineCheck = false, bool bSkipObserver = false); //      獵째?
+
+	bool IsItemLoaded() const { return m_bItemLoaded; }
+	void SetItemLoaded() { m_bItemLoaded = true; }
+
+	void ClearItem();
+
+	LPITEM GetInventoryItem(WORD wCell) const;
+	LPITEM GetEquipmentItem(WORD wCell) const;
+	LPITEM GetDragonSoulInventoryItem(WORD wCell) const;
+	LPITEM GetBeltInventoryItem(WORD wCell) const;
+
+	void SetItem(TItemPos Cell, LPITEM item
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		, bool isHighLight = false
+#endif
+	);
+
+	LPITEM GetItem(TItemPos Cell) const;
+
+	bool IsEmptyItemGrid(TItemPos Cell, BYTE size, int iExceptionCell = -1) const;
+
+	void SetWear(WORD wCell, LPITEM item);
+	LPITEM GetWear(WORD wCell) const;
+
+	// MYSHOP_PRICE_LIST
+	void UseSilkBotary(void); ///    
+
+	/// DB 캐첨  騁틸  트  構    처磯.
+	/**
+	* @param [in] p  트 킷
+	*
+	*   처      UseSilkBotary  DB 캐첨  트 청構
+	*    獨  甁  처磯.
+	**/
+	void UseSilkBotaryReal(const TPacketMyshopPricelistHeader* p);
+	// END_OF_MYSHOP_PRICE_LIST
+
+	bool UseItemEx(LPITEM item, TItemPos DestCell);
+	bool UseItem(TItemPos Cell, TItemPos DestCell = NPOS);
+
+	// ADD_REFINE_BUILDING
+	bool IsRefineThroughGuild() const;
+	CGuild* GetRefineGuild() const;
+	int ComputeRefineFee(int iCost, int iMultiply = 5) const;
+	void PayRefineFee(int iTotalMoney);
+	void SetRefineNPC(LPCHARACTER ch);
+	// END_OF_ADD_REFINE_BUILDING
+
+	bool RefineItem(LPITEM pkItem, LPITEM pkTarget);
+	bool DropItem(TItemPos Cell, WORD wCount = 0);
+#if defined(__NEW_DROP_DIALOG__)
+	bool DestroyItem(TItemPos Cell);
+#endif
+	bool GiveRecallItem(LPITEM item);
+	void ProcessRecallItem(LPITEM item);
+
+	// void PotionPacket(int iPotionType);
+	void EffectPacket(BYTE bEffectNum, BYTE bEffectType = SE_TYPE_NORMAL, const PIXEL_POSITION& rEffectPos = { 0, 0, 0 });
+	void SpecificEffectPacket(const char filename[128]);
+
+	// ADD_MONSTER_REFINE
+	bool DoRefine(LPITEM item, bool bMoneyOnly = false);
+	// END_OF_ADD_MONSTER_REFINE
+
+	bool DoRefineWithScroll(LPITEM item);
+	bool RefineInformation(WORD wCell, BYTE bType, int iAdditionalCell = -1);
+
+	struct SRefineScrollData
+	{
+		BYTE bSuccessProb;
+		bool bKeepGrade;
+	};
+	SRefineScrollData GetScrollRefinePct(BYTE bProb, BYTE bRefineLevel, BYTE bScrollType);
+
+	void SetRefineMode(int iAdditionalCell = -1);
+	void ClearRefineMode();
+
+	bool GiveItem(LPCHARACTER victim, TItemPos Cell);
+	bool CanReceiveItem(LPCHARACTER from, LPITEM item) const;
+	void ReceiveItem(LPCHARACTER from, LPITEM item);
+	//bool GiveItemFromSpecialItemGroup(DWORD dwGroupNum, std::vector<DWORD>& dwItemVnums,
+	//	std::vector<DWORD>& dwItemCounts, std::vector<LPITEM>& item_gets, int& count);
+	bool GiveItemFromSpecialItemGroup(DWORD dwGroupNum);
+
+	bool MoveItem(TItemPos pos, TItemPos change_pos, WORD num);
+	bool PickupItem(DWORD vid
+#if defined(__PET_LOOT_AI__)
+		, bool PetLoot = false
+#endif
+	);
+	bool EquipItem(LPITEM item, int iCandidateCell = -1);
+	bool UnequipItem(LPITEM item);
+
+	//  item   獵  확構, 柰 求摸 캐沽  腔獵 獨
+	bool CanEquipNow(const LPITEM item, const TItemPos& srcCell = NPOS, const TItemPos& destCell = NPOS);
+	//  item   獵  확構, 柰 求摸 캐沽  腔獵 獨
+	bool CanUnequipNow(const LPITEM item, const TItemPos& srcCell = NPOS, const TItemPos& destCell = NPOS);
+
+	bool SwapItem(WORD wCell, WORD wDestCell);
+
+	LPITEM AutoGiveItem(DWORD dwItemVnum, WORD wCount = 1, int iRarePct = -1, bool bMsg = true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		, bool isHighLight = false
+#endif
+#if defined(__NEW_USER_CARE__)
+		, bool bSystemDrop = true
+#endif
+	);
+
+	void AutoGiveItem(LPITEM item, bool longOwnerShip = false, bool bMsg = true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		, bool isHighLight = false
+#endif
+	);
+
+	int GetEmptyInventory(BYTE size) const;
+	int GetEmptyInventoryCount(BYTE size) const;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	int GetEmptyDragonSoulInventory(LPITEM pItem) const;
+	void CopyDragonSoulItemGrid(std::vector<WORD>& vDragonSoulItemGrid) const;
+#endif
+
+	int CountEmptyInventory() const;
+	bool HasEnoughInventorySpace(std::vector<TItemData>& vItems) const;
+
+	int CountSpecifyItem(DWORD vnum, int iExceptionCell = -1
+#if defined(__SOUL_BIND_SYSTEM__)
+		, bool bIgnoreSealedItem = false
+#endif
+#if defined(__SET_ITEM__)
+		, bool bIgnoreSetValue = false
+#endif
+	) const;
+	void RemoveSpecifyItem(DWORD vnum, DWORD count = 1, int iExceptionCell = -1
+#if defined(__SOUL_BIND_SYSTEM__)
+		, bool bIgnoreSealedItem = false
+#endif
+#if defined(__SET_ITEM__)
+		, bool bIgnoreSetValue = false
+#endif
+	);
+	LPITEM FindSpecifyItem(DWORD dwVnum
+#if defined(__SOUL_BIND_SYSTEM__)
+		, bool bIgnoreSealedItem = false
+#endif
+#if defined(__SET_ITEM__)
+		, bool bIgnoreSetValue = false
+#endif
+	) const;
+	LPITEM FindItemByID(DWORD id) const;
+
+	int CountSpecifyTypeItem(BYTE type) const;
+	void RemoveSpecifyTypeItem(BYTE type, DWORD count = 1);
+
+	bool IsEquipUniqueItem(DWORD dwItemVnum) const;
+
+	// CHECK_UNIQUE_GROUP
+	bool IsEquipUniqueGroup(DWORD dwGroupVnum) const;
+	// END_OF_CHECK_UNIQUE_GROUP
+
+	void SendEquipment(LPCHARACTER pChar);
+	// End of Item
+
+protected:
+	///  謗   磯.
+	/**
+	* @param [in] dwItemVnum  vnum
+	* @param [in] dwItemPrice  
+	**/
+	void SendMyShopPriceListCmd(DWORD dwItemVnum, DWORD dwItemPrice
+#if defined(__CHEQUE_SYSTEM__)
+		, DWORD dwItemCheque
+#endif
+	);
+
+	bool m_bNoOpenedShop; ///< 譴   貫   獵 (  摸 true)
+
+	bool m_bItemLoaded;
+	int m_iRefineAdditionalCell;
+
+public:
+	bool IsUnderRefine() const { return m_bUnderRefine; }
+	void SetUnderRefine(bool bState) { m_bUnderRefine = bState; }
+protected:
+	bool m_bUnderRefine;
+	DWORD m_dwRefineNPCVID;
+
+public:
+	int GetGold() const { return m_points.iGold; }
+	void SetGold(int iValue) { m_points.iGold = iValue; }
+
+	bool DropGold(int iAmount);
+	void GiveGold(int iAmount); // 티  티 橘, 慣  처
+
+	int GetAllowedGold() const;
+
+#if defined(__CHEQUE_SYSTEM__)
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Cheque related
+	int GetCheque() const { return m_points.iCheque; }
+	void SetCheque(int iValue) { m_points.iCheque = iValue; }
+	bool DropCheque(int iAmount);
+	void GiveCheque(int iAmount);
+	// End of Cheque
+#endif
+
+#if defined(__GEM_SYSTEM__)
+	////////////////////////////////////////////////////////////////////////////////////////
+	int GetGem() const { return m_points.iGem; }
+	void SetGem(int iValue) { m_points.iGem = iValue; }
+	void GiveGem(int iAmount);
+#endif
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Shop related
+public:
+	void SetShop(LPSHOP pkShop);
+	LPSHOP GetShop() const { return m_pkShop; }
+	void ShopPacket(BYTE bSubHeader);
+
+	void SetShopOwner(LPCHARACTER ch) { m_pkChrShopOwner = ch; }
+	LPCHARACTER GetShopOwner() const { return m_pkChrShopOwner; }
+
+#ifdef __OFFLINE_SHOP__
+	void SetShowOfflineShop(DWORD option) { dwIsShowShops = option; UpdateSectree();}
+	DWORD GetShowOfflineShop()  const { return dwIsShowShops;}
+#endif
+
+	void OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE bItemCount);
+	LPSHOP GetMyShop() const { return m_pkMyShop; }
+	void CloseMyShop();
+
+protected:
+	LPSHOP m_pkShop;
+	LPSHOP m_pkMyShop;
+	std::string m_stShopSign;
+	LPCHARACTER m_pkChrShopOwner;
+	// End of shop
+
+#ifdef __OFFLINE_SHOP__
+	DWORD dwIsShowShops;
+#endif
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Exchange related
+public:
+	bool ExchangeStart(LPCHARACTER victim);
+	void SetExchange(CExchange* pkExchange);
+	CExchange* GetExchange() const { return m_pkExchange; }
+
+protected:
+	CExchange* m_pkExchange;
+	// End of Exchange
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Battle
+public:
+	struct TBattleInfo
+	{
+		int iTotalDamage;
+		int iAggro;
+
+		TBattleInfo(int iTot, int iAggr)
+			: iTotalDamage(iTot), iAggro(iAggr)
+		{}
+	};
+	typedef std::map<VID, TBattleInfo> TDamageMap;
+
+	typedef struct SAttackLog
+	{
+		DWORD dwVID;
+		DWORD dwTime;
+	} AttackLog;
+
+	bool Damage(LPCHARACTER pAttacker, int dam, EDamageType type = DAMAGE_TYPE_NORMAL);
+	bool __Profile__Damage(LPCHARACTER pAttacker, int dam, EDamageType type = DAMAGE_TYPE_NORMAL);
+	void DeathPenalty(BYTE bExpLossPercent);
+	void ReviveInvisible(int iDur);
+
+	bool Attack(LPCHARACTER pkVictim, BYTE bType = 0);
+	bool IsAlive() const { return m_pointsInstant.position == POS_DEAD ? false : true; }
+	bool CanFight() const;
+
+	bool CanBeginFight() const;
+	void BeginFight(LPCHARACTER pkVictim); // pkVictimr 恝 磯. (,   簾 체크狗 CanBeginFight )
+
+	bool CounterAttack(LPCHARACTER pkChr); // 腑歐 (拷 )
+
+	bool IsStun() const;
+	void Stun(bool bImmediate = false);
+	bool IsDead() const;
+	void Dead(LPCHARACTER pkKiller = NULL, bool bImmediateDead = false);
+
+	void Reward(bool bItemDrop);
+	void RewardGold(LPCHARACTER pkAttacker);
+
+	bool Shoot(BYTE bType);
+	void FlyTarget(DWORD dwTargetVID, long x, long y, BYTE bHeader);
+
+	void ForgetMyAttacker(bool bRevive = true);
+	void AggregateMonster();
+	void AttractRanger();
+	void PullMonster();
+
+	int GetArrowAndBow(LPITEM* ppkBow, LPITEM* ppkArrow, int iArrowCount = 1);
+	void UseArrow(LPITEM pkArrow, DWORD dwArrowCount);
+
+	void AttackedByPoison(LPCHARACTER pkAttacker);
+	void RemovePoison();
+
+	void AttackedByBleeding(LPCHARACTER pkAttacker);
+	void RemoveBleeding();
+
+	void AttackedByFire(LPCHARACTER pkAttacker, int amount, int count);
+	void RemoveFire();
+
+	void UpdateAlignment(int iAmount);
+	int GetAlignment() const;
+
+	// 치  
+	int GetRealAlignment() const;
+	void ShowAlignment(bool bShow);
+
+	UINT GetAlignmentGrade() const;
+
+	void SetKillerMode(bool bOn);
+	bool IsKillerMode() const;
+	void UpdateKillerMode();
+
+	BYTE GetPKMode() const;
+	void SetPKMode(BYTE bPKMode);
+
+	void ItemDropPenalty(LPCHARACTER pkKiller);
+
+	void UpdateAggrPoint(LPCHARACTER ch, EDamageType type, int dam);
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// HACK
+public:
+	void SetComboSequence(BYTE seq);
+	BYTE GetComboSequence() const;
+
+	void SetLastComboTime(DWORD time);
+	DWORD GetLastComboTime() const;
+
+	int GetValidComboInterval() const;
+	void SetValidComboInterval(int interval);
+
+	BYTE GetComboIndex() const;
+
+	void IncreaseComboHackCount(int k = 1);
+	void ResetComboHackCount();
+	void SkipComboAttackByTime(int interval);
+	DWORD GetSkipComboAttackByTime() const;
+
+		// Flood guard: rate-limit FUNC_COMBO packets (DoS mitigation)
+		bool CheckComboFlood(DWORD dwTime);
+
+protected:
+	BYTE m_bComboSequence;
+	DWORD m_dwLastComboTime;
+	int m_iValidComboInterval;
+	BYTE m_bComboIndex;
+	int m_iComboHackCount;
+	DWORD m_dwSkipComboAttackByTime;
+	DWORD m_dwComboFloodWindow;
+	BYTE m_bComboFloodCount;
+
+protected:
+	void UpdateAggrPointEx(LPCHARACTER ch, EDamageType type, int dam, TBattleInfo& info);
+	void ChangeVictimByAggro(int iNewAggro, LPCHARACTER pNewVictim);
+
+	DWORD m_dwFlyTargetID;
+	std::vector<DWORD> m_vec_dwFlyTargets;
+	TDamageMap m_map_kDamage; // 錚 캐叩  窄떳큼  羚째?
+	//AttackLog m_kAttackLog;
+	DWORD m_dwKillerPID;
+
+	int m_iAlignment; // Lawful / Chaotic value -200000 ~ 200000
+	int m_iRealAlignment;
+	int m_iKillerModePulse;
+	BYTE m_bPKMode;
+
+	// Aggro
+	DWORD m_dwLastVictimSetTime;
+	int m_iMaxAggro;
+	// End of Battle
+
+	// Stone
+public:
+	void SetStone(LPCHARACTER pkChrStone);
+	void ClearStone();
+	void DetermineDropMetinStone();
+	DWORD GetDropMetinStoneVnum() const { return m_dwDropMetinStone; }
+	BYTE GetDropMetinStonePct() const { return m_bDropMetinStonePct; }
+
+protected:
+	LPCHARACTER m_pkChrStone; //   
+	CHARACTER_SET m_set_pkChrSpawnedBy; //   
+	DWORD m_dwDropMetinStone;
+	BYTE m_bDropMetinStonePct;
+	// End of Stone
+
+public:
+	enum
+	{
+		SKILL_UP_BY_POINT,
+		SKILL_UP_BY_BOOK,
+		SKILL_UP_BY_TRAIN,
+
+		// ADD_GRANDMASTER_SKILL
+		SKILL_UP_BY_QUEST,
+		// END_OF_ADD_GRANDMASTER_SKILL
+	};
+
+	void SkillLevelPacket();
+	void SkillLevelUp(DWORD dwVnum, BYTE bMethod = SKILL_UP_BY_POINT);
+	bool SkillLevelDown(DWORD dwVnum);
+	// ADD_GRANDMASTER_SKILL
+	bool UseSkill(DWORD dwVnum, LPCHARACTER pkVictim, bool bUseGrandMaster = true);
+	void ResetSkill();
+#if defined(__SKILL_COOLTIME_UPDATE__)
+	void ResetSkillCoolTimes();
+#endif
+	void SetSkillLevel(DWORD dwVnum, BYTE bLev);
+	int GetUsedSkillMasterType(DWORD dwVnum);
+
+	bool IsLearnableSkill(DWORD dwSkillVnum) const;
+	// END_OF_ADD_GRANDMASTER_SKILL
+
+	bool CheckSkillHitCount(const BYTE SkillID, const VID dwTargetVID);
+	bool CanUseSkill(DWORD dwSkillVnum) const;
+	bool IsUsableSkillMotion(DWORD dwMotionIndex) const;
+	int GetSkillLevel(DWORD dwVnum) const;
+	int GetSkillMasterType(DWORD dwVnum) const;
+	int GetSkillPower(DWORD dwVnum, BYTE bLevel = 0) const;
+
+	time_t GetSkillNextReadTime(DWORD dwVnum) const;
+	void SetSkillNextReadTime(DWORD dwVnum, time_t time);
+	void SkillLearnWaitMoreTimeMessage(DWORD dwVnum);
+
+	void ComputePassiveSkill(DWORD dwVnum);
+#ifdef ENABLE_QUEEN_NETHIS
+	int ComputeSnakeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel);
+#endif
+	int ComputeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
+	int ComputeSkillParty(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
+	int ComputeSkillAtPosition(DWORD dwVnum, const PIXEL_POSITION& posTarget, BYTE bSkillLevel = 0);
+#if defined(__PVP_BALANCE_IMPROVING__)
+	int ComputeGyeongGongSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
+#endif
+	void ComputeSkillPoints();
+
+	void SetSkillGroup(BYTE bSkillGroup);
+	BYTE GetSkillGroup() const { return m_points.bSkillGroup; }
+
+	int ComputeCooltime(int time);
+
+	void GiveRandomSkillBook();
+	void GiveSkillBook(DWORD dwSkillVnum, WORD wCount);
+
+	void DisableCooltime();
+	bool LearnSkillByBook(DWORD dwSkillVnum, BYTE bProb = 0);
+	bool LearnGrandMasterSkill(DWORD dwSkillVnum);
+
+#if defined(__CONQUEROR_LEVEL__)
+	bool IsConquerorSkill(DWORD dwVnum) const;
+#endif
+
+private:
+	bool m_bDisableCooltime;
+	DWORD m_dwLastSkillTime; ///<  skill   챨(millisecond).
+	// End of Skill
+
+	// MOB_SKILL
+public:
+	bool HasMobSkill() const;
+	size_t CountMobSkill() const;
+	const TMobSkillInfo* GetMobSkill(unsigned int idx) const;
+	bool CanUseMobSkill(unsigned int idx) const;
+	bool UseMobSkill(unsigned int idx);
+	void ResetMobSkillCooltime();
+protected:
+	DWORD m_adwMobSkillCooltime[MOB_SKILL_MAX_NUM];
+	// END_OF_MOB_SKILL
+
+	// for SKILL_MUYEONG
+public:
+	void StartMuyeongEvent();
+	void StopMuyeongEvent();
+
+#if defined(__PVP_BALANCE_IMPROVING__)
+	void StartGyeongGongEvent();
+	void StopGyeongGongEvent();
+#endif
+
+#if defined(__9TH_SKILL__)
+	void StartCheonunEvent(BYTE bChance, BYTE bDuration);
+	void StopCheonunEvent();
+#endif
+
+private:
+	LPEVENT m_pkMuyeongEvent;
+#ifdef ENABLE_QUEEN_NETHIS
+	LPEVENT m_pkSnakeSkillEvent;
+#endif
+#if defined(__PVP_BALANCE_IMPROVING__)
+	LPEVENT m_pkGyeongGongEvent;
+#endif
+#if defined(__9TH_SKILL__)
+	LPEVENT m_pkCheonunEvent;
+#endif
+
+	// for SKILL_CHAIN lighting
+public:
+	int GetChainLightningIndex() const { return m_iChainLightingIndex; }
+	void IncChainLightningIndex() { ++m_iChainLightingIndex; }
+	void AddChainLightningExcept(LPCHARACTER ch) { m_setExceptChainLighting.insert(ch); }
+	void ResetChainLightningIndex() { m_iChainLightingIndex = 0; m_setExceptChainLighting.clear(); }
+	int GetChainLightningMaxCount() const;
+	const CHARACTER_SET& GetChainLightingExcept() const { return m_setExceptChainLighting; }
+
+private:
+	int m_iChainLightingIndex;
+	CHARACTER_SET m_setExceptChainLighting;
+
+	// for SKILL_EUNHYUNG
+public:
+	void SetAffectedEunhyung();
+	void ClearAffectedEunhyung() { m_dwAffectedEunhyungLevel = 0; }
+	bool GetAffectedEunhyung() const { return m_dwAffectedEunhyungLevel; }
+
+private:
+	DWORD m_dwAffectedEunhyungLevel;
+
+	//
+	// Skill levels
+	//
+protected:
+	TPlayerSkill* m_pSkillLevels;
+	std::unordered_map<BYTE, int> m_SkillDamageBonus;
+	std::map<int, TSkillUseInfo> m_SkillUseInfo;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// AI related
+public:
+	void AssignTriggers(const TMobTable* table);
+	LPCHARACTER GetVictim() const; //   
+	void SetVictim(LPCHARACTER pkVictim);
+	LPCHARACTER GetNearestVictim(LPCHARACTER pkChr);
+	LPCHARACTER GetProtege() const; // 호瞞   
+
+	bool Follow(LPCHARACTER pkChr, float fMinimumDistance = 150.0f);
+	bool Return();
+	bool IsGuardNPC() const;
+	bool IsChangeAttackPosition(LPCHARACTER target) const;
+	void ResetChangeAttackPositionTime() { m_dwLastChangeAttackPositionTime = get_dword_time() - AI_CHANGE_ATTACK_POISITION_TIME_NEAR; }
+	void SetChangeAttackPositionTime() { m_dwLastChangeAttackPositionTime = get_dword_time(); }
+
+	bool OnIdle();
+
+	void OnAttack(LPCHARACTER pkChrAttacker);
+	void OnClick(LPCHARACTER pkChrCauser);
+
+	VID m_kVIDVictim;
+
+protected:
+	DWORD m_dwLastChangeAttackPositionTime;
+	CTrigger m_triggerOnClick;
+	// End of AI
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Target
+protected:
+	LPCHARACTER m_pkChrTarget; //  타
+	CHARACTER_SET m_set_pkChrTargetedBy; //  타  獵 
+
+public:
+	void SetTarget(LPCHARACTER pkChrTarget);
+	void BroadcastTargetPacket();
+	void ClearTarget();
+	void CheckTarget();
+	LPCHARACTER GetTarget() const { return m_pkChrTarget; }
+	LPCHARACTER GetTargetSafe();
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Safebox
+public:
+	int GetSafeboxSize() const;
+	void QuerySafeboxSize();
+	void SetSafeboxSize(int size);
+
+	CSafebox* GetSafebox() const;
+	void LoadSafebox(int iSize, DWORD dwGold, int iItemCount, TPlayerItem* pItems);
+	void ChangeSafeboxSize(BYTE bSize);
+	void CloseSafebox();
+
+	/// 창  청
+	/**
+	* @param [in] pszPassword 1 鵑 6  창 橘호
+	*
+	* DB  창綬 청磯.
+	* 창 揷  玖, 殮 창  챨  10 犬   磯.
+	**/
+	void ReqSafeboxLoad(const char* pszPassword);
+
+	/// 창  청 
+	/**
+	* ReqSafeboxLoad  호構 CloseSafebox  刻   獨 호玖 창   獵.
+	* 창 청 DB   騁   獨 漫 청   斂 娩.
+	**/
+	void CancelSafeboxLoad(void) { m_bOpeningSafebox = false; }
+
+	void SetMallLoadTime(int t) { m_iMallLoadTime = t; }
+	int GetMallLoadTime() const { return m_iMallLoadTime; }
+
+	CSafebox* GetMall() const;
+	void LoadMall(int iItemCount, TPlayerItem* pItems);
+	void CloseMall();
+
+	void SetSafeboxOpenPosition();
+	float GetDistanceFromSafeboxOpen() const;
+
+	void LoadSafeboxBuff();
+	void SetSafeboxBuff();
+
+protected:
+	CSafebox* m_pkSafebox;
+	int m_iSafeboxSize;
+	int m_iSafeboxLoadTime;
+	bool m_bOpeningSafebox; ///< 창  청 隔킬 獵째 , true   청隔킬 .
+
+	CSafebox* m_pkMall;
+	int m_iMallLoadTime;
+
+	PIXEL_POSITION m_posSafeboxOpen;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Mounting
+public:
+	void UnMount(bool bUnequipItem = false);
+	void MountVnum(DWORD vnum);
+	DWORD GetMountVnum() const { return m_dwMountVnum; }
+	DWORD GetLastMountTime() const { return m_dwMountTime; }
+
+	bool CanUseHorseSkill();
+
+	// Horse
+	virtual void SetHorseLevel(int iLevel);
+
+	virtual bool StartRiding();
+	virtual bool StopRiding();
+
+	virtual DWORD GetMyHorseVnum() const;
+
+	virtual void HorseDie();
+	virtual bool ReviveHorse();
+
+	virtual void SendHorseInfo();
+	virtual void ClearHorseInfo();
+
+	void HorseSummon(bool bSummon, bool bFromFar = false, DWORD dwVnum = 0, const char* pHorseName = 0);
+
+	LPCHARACTER GetHorse() const { return m_chHorse; } //  환 
+	LPCHARACTER GetRider() const; // rider on horse
+	void SetRider(LPCHARACTER ch);
+
+	bool IsRiding() const;
+
+#if defined(__PET_SYSTEM__)
+public:
+	CPetSystem* GetPetSystem() { return m_petSystem; }
+
+protected:
+	CPetSystem* m_petSystem;
+
+public:
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+		void	SetInvincible(bool bInvincible) { m_bInvincible = bInvincible; }
+		bool	IsInvincible() { return m_bInvincible; }
+
+		void	SetPetHatchWindow(bool bState) { m_bIsPetHatchOpen = bState; }
+		bool	IsPetHatchWindowOpen() { return m_bIsPetHatchOpen; }
+		void	SetPetChangeNameWindow(bool bState) { m_bIsPetChangeNameOpen = bState; }
+		bool	IsPetChangeNameWindowOpen() { return m_bIsPetChangeNameOpen; }
+
+		void	SetPetWindowType(BYTE bType) { m_bPetWindowType = bType; }
+		BYTE	GetPetWindowType() { return m_bPetWindowType; }
+
+		void	SetGrowthPetLoaded(bool bState) { m_bIsGrowthPetLoaded = bState; }
+		bool	IsGrowthPetLoaded() { return m_bIsGrowthPetLoaded; }
+
+		void	SetCharacterSize(BYTE bSize) { m_bCharacterSize = bSize; }
+		BYTE	GetCharacterSize() { return m_bCharacterSize; }
+
+		bool			SetGrowthPet(LPGROWTH_PET pkPet);
+		bool			DeleteGrowthPet(DWORD dwID);
+		LPGROWTH_PET	GetGrowthPet(DWORD dwID);
+		void			ClearGrowthPet();
+
+		void			SetActiveGrowthPet(LPGROWTH_PET pkPet) { m_activeGrowthPet = pkPet;  }
+		LPGROWTH_PET	GetActiveGrowthPet() { return m_activeGrowthPet; }
+
+		void			SendDeadPetMessage();
+
+	private:
+		DWORD	m_bInvincible;
+		bool	m_bIsPetHatchOpen;
+		bool	m_bIsPetChangeNameOpen;
+		BYTE	m_bPetWindowType;
+
+		bool	m_bIsGrowthPetLoaded;
+
+		CGrowthPetManager::TGrowthPetMap	m_growthPetMap;
+		LPGROWTH_PET	m_activeGrowthPet;
+
+		BYTE			m_bCharacterSize;
+#endif 
+
+protected:
+	LPCHARACTER m_chHorse;
+	LPCHARACTER m_chRider;
+
+	DWORD m_dwMountVnum;
+	DWORD m_dwMountTime;
+
+	BYTE m_bSendHorseLevel;
+	BYTE m_bSendHorseHealthGrade;
+	BYTE m_bSendHorseStaminaGrade;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Detailed Log
+public:
+	void DetailLog() { m_bDetailLog = !m_bDetailLog; }
+	void ToggleMonsterLog();
+	void MonsterLog(const char* format, ...);
+
+private:
+	bool m_bDetailLog;
+	bool m_bMonsterLog;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Empire
+public:
+	void SetEmpire(BYTE bEmpire);
+	BYTE GetEmpire() const { return m_bEmpire; }
+
+protected:
+	BYTE m_bEmpire;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Regen
+public:
+	void SetRegen(LPREGEN pkRegen);
+
+protected:
+	PIXEL_POSITION m_posRegen;
+	float m_fRegenAngle;
+	LPREGEN m_pkRegen;
+	size_t regen_id_; // to help dungeon regen identification
+	// End of Regen
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Resists & Proofs
+public:
+	bool CannotMoveByAffect() const; // 특 효     寬?
+	bool IsImmune(DWORD dwImmuneFlag);
+	void SetImmuneFlag(DWORD dw) { m_pointsInstant.dwImmuneFlag = dw; }
+
+protected:
+	void ApplyMobAttribute(const TMobTable* table);
+	// End of Resists & Proofs
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// QUEST
+public:
+	void SetQuestNPCID(DWORD vid);
+	DWORD GetQuestNPCID() const { return m_dwQuestNPCVID; }
+	LPCHARACTER GetQuestNPC() const;
+
+	void SetQuestItemPtr(LPITEM item);
+	void ClearQuestItemPtr();
+	LPITEM GetQuestItemPtr() const;
+
+	void SetQuestBy(DWORD dwQuestVnum) { m_dwQuestByVnum = dwQuestVnum; }
+	DWORD GetQuestBy() const { return m_dwQuestByVnum; }
+
+	int GetQuestFlag(const std::string& flag) const;
+	void SetQuestFlag(const std::string& flag, int value);
+
+	void ConfirmWithMsg(const char* szMsg, int iTimeout, DWORD dwRequestPID);
+	bool IsRunningQuest() const;
+
+private:
+	DWORD m_dwQuestNPCVID;
+	DWORD m_dwQuestByVnum;
+	LPITEM m_pQuestItem;
+
+	// Events
+public:
+	bool StartStateMachine(int iPulse = 1);
+	void StopStateMachine();
+	void UpdateStateMachine(DWORD dwPulse);
+	void SetNextStatePulse(int iPulseNext);
+
+	// 캐 館絿 트 獨.  鵑 蛋 CFSM::Update 獨 호構킬 UpdateStateMachine 獨 杉쨉,  트 獨 煞.
+	void UpdateCharacter(DWORD dwPulse);
+
+protected:
+	DWORD m_dwNextStatePulse;
+
+	// Marriage
+public:
+	LPCHARACTER GetMarryPartner() const;
+	void SetMarryPartner(LPCHARACTER ch);
+	int GetMarriageBonus(DWORD dwItemVnum, bool bSum = true);
+
+	bool IsWearingDress() const;
+
+	void SetWeddingMap(marriage::WeddingMap* pMap);
+	marriage::WeddingMap* GetWeddingMap() const { return m_pWeddingMap; }
+
+private:
+	marriage::WeddingMap* m_pWeddingMap;
+	LPCHARACTER m_pkChrMarried;
+
+	// Warp Character
+public:
+	void StartWarpNPCEvent();
+
+public:
+	void StartSaveEvent();
+	void StartRecoveryEvent();
+	void StartCheckSpeedHackEvent();
+	void StartDestroyWhenIdleEvent();
+
+	LPEVENT m_pkDeadEvent;
+	LPEVENT m_pkStunEvent;
+	LPEVENT m_pkSaveEvent;
+	LPEVENT m_pkRecoveryEvent;
+	LPEVENT m_pkTimedEvent;
+	LPEVENT m_pkFishingEvent;
+	LPEVENT m_pkAffectEvent;
+	LPEVENT m_pkPoisonEvent;
+	LPEVENT m_pkBleedingEvent;
+	LPEVENT m_pkFireEvent;
+#if defined(__DAWNMIST_DUNGEON__)
+	LPEVENT m_pkHealEvent;
+#endif
+	LPEVENT m_pkWarpNPCEvent;
+	// DELAYED_WARP
+	// END_DELAYED_WARP
+
+	// MINING
+	LPEVENT m_pkMiningEvent;
+	// END_OF_MINING
+	LPEVENT m_pkWarpEvent;
+	LPEVENT m_pkCheckSpeedHackEvent;
+	LPEVENT m_pkDestroyWhenIdleEvent;
+	LPEVENT m_pkPetSystemUpdateEvent;
+
+	bool IsWarping() const { return m_pkWarpEvent ? true : false; }
+
+	bool m_bHasPoisoned;
+	bool m_bHasBled;
+
+	const CMob* m_pkMobData;
+	CMobInstance* m_pkMobInst;
+
+	MobSkillEventMap m_mapMobSkillEvent;
+
+	friend struct FuncSplashDamage;
+	friend struct FuncSplashAffect;
+	friend class CFuncShoot;
+
+public:
+	int GetPremiumRemainSeconds(BYTE bType) const;
+
+private:
+	int m_aiPremiumTimes[PREMIUM_MAX_NUM];
+
+	// CHANGE_ITEM_ATTRIBUTES
+	static const DWORD msc_dwDefaultChangeItemAttrCycle; ///< 트  憺  殮
+	static const char msc_szLastChangeItemAttrFlag[]; ///< 殮  憺  챨 Quest Flag 見
+	static const char msc_szChangeItemAttrCycleFlag[]; ///<  憺  殮 Quest Flag 見
+	// END_OF_CHANGE_ITEM_ATTRIBUTES
+
+	// PC_BANG_ITEM_ADD
+private:
+	bool m_isinPCBang;
+
+public:
+	bool SetPCBang(bool flag) { m_isinPCBang = flag; return m_isinPCBang; }
+	bool IsPCBang() const { return m_isinPCBang; }
+	// END_PC_BANG_ITEM_ADD
+
+	// NEW_HAIR_STYLE_ADD
+public:
+	bool ItemProcess_Hair(LPITEM item, int iDestCell);
+	// END_NEW_HAIR_STYLE_ADD
+
+public:
+	void ClearSkill();
+	void ClearSubSkill();
+
+	// RESET_ONE_SKILL
+	bool ResetOneSkill(DWORD dwVnum);
+	// END_RESET_ONE_SKILL
+
+private:
+	void SendDamagePacket(LPCHARACTER pAttacker, int Damage, BYTE DamageFlag);
+
+	// ARENA
+private:
+	CArena* m_pArena;
+	bool m_ArenaObserver;
+	int m_nPotionLimit;
+
+public:
+	void SetArena(CArena* pArena) { m_pArena = pArena; }
+	void SetArenaObserverMode(bool flag) { m_ArenaObserver = flag; }
+
+	CArena* GetArena() const { return m_pArena; }
+	bool GetArenaObserverMode() const { return m_ArenaObserver; }
+
+	void SetPotionLimit(int count) { m_nPotionLimit = count; }
+	int GetPotionLimit() const { return m_nPotionLimit; }
+	// END_ARENA
+
+	// PREVENT_TRADE_WINDOW
+public:
+	bool IsOpenSafebox() const { return m_isOpenSafebox ? true : false; }
+	void SetOpenSafebox(bool b) { m_isOpenSafebox = b; }
+
+	int GetSafeboxLoadTime() const { return m_iSafeboxLoadTime; }
+	void SetSafeboxLoadTime() { m_iSafeboxLoadTime = thecore_pulse(); }
+
+private:
+	bool m_isOpenSafebox;
+	// END_PREVENT_TRADE_WINDOW
+
+public:
+	int GetSkillPowerByLevel(int iLevel, bool bMob = false) const;
+
+	// PREVENT_REFINE_HACK
+	int GetRefineTime() const { return m_iRefineTime; }
+	void SetRefineTime() { m_iRefineTime = thecore_pulse(); }
+	int m_iRefineTime;
+	// END_PREVENT_REFINE_HACK
+
+	// RESTRICT_USE_SEED_OR_MOONBOTTLE
+	int GetUseSeedOrMoonBottleTime() const { return m_iSeedTime; }
+	void SetUseSeedOrMoonBottleTime() { m_iSeedTime = thecore_pulse(); }
+	int m_iSeedTime;
+	// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
+
+	// PREVENT_PORTAL_AFTER_EXCHANGE
+	int GetExchangeTime() const { return m_iExchangeTime; }
+	void SetExchangeTime() { m_iExchangeTime = thecore_pulse(); }
+	int m_iExchangeTime;
+	// END_PREVENT_PORTAL_AFTER_EXCHANGE
+
+	int m_iMyShopTime;
+	int GetMyShopTime() const { return m_iMyShopTime; }
+	void SetMyShopTime() { m_iMyShopTime = thecore_pulse(); }
+
+	// PREVENT_TRADE_WINDOW
+	bool PreventTradeWindow(int flags, bool except = false) const;
+	// END_PREVENT_TRADE_WINDOW
+
+	// Hack   체크.
+	bool IsHack(bool bSendMsg = true, bool bCheckShopOwner = true, int limittime = g_nPortalLimitTime);
+
+	// MONARCH
+	BOOL IsMonarch() const;
+	// END_MONARCH
+	void Say(const std::string& s);
+
+	enum MONARCH_COOLTIME
+	{
+		MC_HEAL = 10,
+		MC_WARP = 60,
+		MC_TRANSFER = 60,
+		MC_TAX = (60 * 60 * 24 * 7),
+		MC_SUMMON = (60 * 60),
+	};
+
+	enum MONARCH_INDEX
+	{
+		MI_HEAL = 0,
+		MI_WARP,
+		MI_TRANSFER,
+		MI_TAX,
+		MI_SUMMON,
+		MI_MAX
+	};
+
+	DWORD m_dwMonarchCooltime[MI_MAX];
+	DWORD m_dwMonarchCooltimelimit[MI_MAX];
+
+	void InitMC();
+	DWORD GetMC(enum MONARCH_INDEX e) const;
+	void SetMC(enum MONARCH_INDEX e);
+	bool IsMCOK(enum MONARCH_INDEX e) const;
+	DWORD GetMCL(enum MONARCH_INDEX e) const;
+	DWORD GetMCLTime(enum MONARCH_INDEX e) const;
+
+public:
+	bool ItemProcess_Polymorph(LPITEM item);
+
+#if !defined(__CUBE_RENEWAL__)
+	// by mhh
+	LPITEM* GetCubeItem() { return m_pointsInstant.pCubeItems; }
+#endif
+	bool IsCubeOpen() const { return (m_pointsInstant.pCubeNpc ? true : false); }
+	LPCHARACTER GetCubeNpc() const { return m_pointsInstant.pCubeNpc; }
+	void SetCubeNpc(LPCHARACTER npc) { m_pointsInstant.pCubeNpc = npc; }
+	bool CanDoCube() const;
+
+public:
+	bool IsSiegeNPC() const;
+
+private:
+	// 薩 
+	// 18 見 
+	// 3챨 : 50 % 5 챨 0%
+	e_overtime m_eOverTime;
+
+public:
+	bool IsOverTime(e_overtime e) const { return (e == m_eOverTime); }
+	void SetOverTime(e_overtime e) { m_eOverTime = e; }
+
+private:
+	int m_deposit_pulse;
+
+public:
+	void UpdateDepositPulse();
+	bool CanDeposit() const;
+
+private:
+	void __OpenPrivateShop();
+
+public:
+	struct AttackedLog
+	{
+		DWORD dwPID;
+		DWORD dwAttackedTime;
+
+		AttackedLog() : dwPID(0), dwAttackedTime(0)
+		{
+		}
+	};
+
+	AttackLog m_kAttackLog;
+	AttackedLog m_AttackedLog;
+	int m_speed_hack_count;
+
+private:
+	std::string m_strNewName;
+
+public:
+	const std::string GetNewName() const { return this->m_strNewName; }
+	void SetNewName(const std::string name) { this->m_strNewName = name; }
+
+public:
+	void GoHome();
+
+private:
+	std::set<DWORD> m_known_guild;
+
+public:
+	void SendGuildName(CGuild* pGuild);
+	void SendGuildName(DWORD dwGuildID);
+
+private:
+	DWORD m_dwLogOffInterval;
+	DWORD m_dwLastPlay;
+
+public:
+	DWORD GetLogOffInterval() const { return m_dwLogOffInterval; }
+	DWORD GetLastPlay() const { return m_dwLastPlay; }
+
+public:
+	bool UnEquipSpecialRideUniqueItem();
+
+	bool CanWarp() const;
+	bool IsInSafezone() const;
+	bool IsInBlockedArea(long x = 0, long y = 0) const;
+
+private:
+	DWORD m_dwLastGoldDropTime;
+#if defined(__CHEQUE_SYSTEM__)
+	DWORD m_dwLastChequeDropTime;
+#endif
+
+public:
+	void AutoRecoveryItemProcess(const EAffectTypes);
+
+public:
+	void BuffOnAttr_AddBuffsFromItem(LPITEM pItem);
+	void BuffOnAttr_RemoveBuffsFromItem(LPITEM pItem);
+
+private:
+	void BuffOnAttr_ValueChange(POINT_TYPE wPointType, POINT_VALUE lOldValue, POINT_VALUE lNewValue);
+	void BuffOnAttr_ClearAll();
+
+	typedef std::map<DWORD, CBuffOnAttributes*> TMapBuffOnAttrs;
+	TMapBuffOnAttrs m_map_buff_on_attrs;
+	//  : 활 謬트 臼.
+
+public:
+	void SetArmada() { cannot_dead = true; }
+	void ResetArmada() { cannot_dead = false; }
+
+private:
+	bool cannot_dead;
+
+#if defined(__PET_SYSTEM__)
+private:
+	bool m_bIsPet;
+
+public:
+	void SetPet() { m_bIsPet = true; }
+	bool IsPet() { return m_bIsPet; }
+#endif
+
+	//   .
+private:
+	float m_fAttMul;
+	float m_fDamMul;
+
+public:
+	float GetAttMul() { return this->m_fAttMul; }
+	void SetAttMul(float newAttMul) { this->m_fAttMul = newAttMul; }
+	float GetDamMul() { return this->m_fDamMul; }
+	void SetDamMul(float newDamMul) { this->m_fDamMul = newDamMul; }
+
+private:
+	bool IsValidItemPosition(TItemPos Pos) const;
+
+	//    킷 擔 
+private:
+	unsigned int itemAward_vnum;
+	char itemAward_cmd[20];
+	//bool itemAward_flag;
+public:
+	unsigned int GetItemAward_vnum() { return itemAward_vnum; }
+	char* GetItemAward_cmd() { return itemAward_cmd; }
+	//bool GetItemAward_flag() { return itemAward_flag; }
+	void SetItemAward_vnum(unsigned int vnum) { itemAward_vnum = vnum; }
+	void SetItemAward_cmd(char* cmd) { strcpy(itemAward_cmd, cmd); }
+	//void SetItemAward_flag(bool flag) { itemAward_flag = flag; }
+
+#if defined(__MOVE_COSTUME_ATTR__)
+public:
+	void ItemCombination(const short MediumIndex, const short BaseIndex, const short MaterialIndex);
+	void OpenItemComb();
+
+	bool IsItemComb() const { return m_pointsInstant.pItemCombNpc != NULL; }
+	void SetItemCombNpc(const LPCHARACTER npc) { m_pointsInstant.pItemCombNpc = npc; }
+#endif
+
+#if defined(__CHANGED_ATTR__)
+public:
+	void SelectAttr(LPITEM material, LPITEM item);
+	void SelectAttrResult(const bool bNew, const TItemPos& pos);
+	bool IsSelectAttr() const;
+private:
+	struct SItemSelectAttr
+	{
+		DWORD dwItemID;
+		TPlayerItemAttribute Attr[ITEM_ATTRIBUTE_MAX_NUM];
+	} m_ItemSelectAttr;
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__)
+public:
+	void MiniGameCatchKingSetFieldCards(std::vector<TCatchKingCard> vec) { m_vecCatchKingFieldCards = vec; }
+
+	DWORD MiniGameCatchKingGetScore() const { return dwCatchKingTotalScore; }
+	void MiniGameCatchKingSetScore(DWORD dwScore) { dwCatchKingTotalScore = dwScore; }
+
+	DWORD MiniGameCatchKingGetBetNumber() const { return bCatchKingBetSetNumber; }
+	void MiniGameCatchKingSetBetNumber(BYTE bSetNr) { bCatchKingBetSetNumber = bSetNr; }
+
+	BYTE MiniGameCatchKingGetHandCard() const { return bCatchKingHandCard; }
+	void MiniGameCatchKingSetHandCard(BYTE bKingCard) { bCatchKingHandCard = bKingCard; }
+
+	BYTE MiniGameCatchKingGetHandCardLeft() const { return bCatchKingHandCardLeft; }
+	void MiniGameCatchKingSetHandCardLeft(BYTE bHandCard) { bCatchKingHandCardLeft = bHandCard; }
+
+	bool MiniGameCatchKingGetGameStatus() const { return dwCatchKingGameStatus; }
+	void MiniGameCatchKingSetGameStatus(bool bStatus) { dwCatchKingGameStatus = bStatus; }
+
+	std::vector<TCatchKingCard> m_vecCatchKingFieldCards;
+
+protected:
+	BYTE bCatchKingHandCard;
+	BYTE bCatchKingHandCardLeft;
+	bool dwCatchKingGameStatus;
+
+	BYTE bCatchKingBetSetNumber;
+	DWORD dwCatchKingTotalScore;
+#endif
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+public:
+	// 혼
+
+	// 캐 affect, quest load 풉  DragonSoul_Initialize 호玖 홴홱.
+	// affect   琯퓸 LoadAffect 호.
+	void DragonSoul_Initialize();
+
+	bool DragonSoul_IsQualified() const;
+	void DragonSoul_GiveQualification();
+
+	int DragonSoul_GetActiveDeck() const;
+	bool DragonSoul_IsDeckActivated() const;
+	bool DragonSoul_ActivateDeck(int iDeckIdx);
+
+	void DragonSoul_DeactivateAll();
+	// 訃 ClearItem  念 磯.
+	// 簾玖....
+	// 혼 毬 毬 deactivate   active 혼 獵 확構,
+	// active 혼 毬 摸, 캐 혼 affect, 활 쨍 磯.
+	// 
+	//  ClearItem , 캐叩 構 獵   unequip求 帽,
+	// 혼 Affect 킵품, 塑 慣 , 혼 활화 苛쨈.
+	// (Unequip  慣類틸 , 틈   .)
+	// 혼 deactivate키 캐 혼  활 쨈 풩躍 苛쨈.
+	void DragonSoul_CleanUp();
+
+#if defined(__DS_SET__)
+	// Dragon Soul Set Bonus
+public:
+	void DragonSoul_SetBonus();
+	void DragonSoul_ActivateAll();
+#endif
+
+	// 혼 화창
+public:
+	bool DragonSoul_RefineWindow_Open(LPENTITY pEntity);
+#if defined(__DS_CHANGE_ATTR__)
+	bool DragonSoul_RefineWindow_ChangeAttr_Open(LPENTITY pEntity);
+#endif
+	bool DragonSoul_RefineWindow_Close();
+	LPENTITY DragonSoul_RefineWindow_GetOpener() { return m_pointsInstant.m_pDragonSoulRefineWindowOpener; }
+	int DragonSoul_RefineWindow_GetDeckSnapshot() const { return m_pointsInstant.iDragonSoulRefineDeckSnapshot; }
+	void DragonSoul_RefineWindow_SetDeckSnapshot(int iDeck) { m_pointsInstant.iDragonSoulRefineDeckSnapshot = iDeck; }
+	bool DragonSoul_RefineWindow_CanRefine();
+#endif
+
+private:
+	// SyncPosition 퓻臼 타 鵑    歐 臼,
+	// SyncPosition 耉爭  .
+	timeval m_tvLastSyncTime;
+	int m_iSyncHackCount;
+public:
+	void SetLastSyncTime(const timeval& tv) { memcpy(&m_tvLastSyncTime, &tv, sizeof(timeval)); }
+	const timeval& GetLastSyncTime() { return m_tvLastSyncTime; }
+	void SetSyncHackCount(int iCount) { m_iSyncHackCount = iCount; }
+	int GetSyncHackCount() { return m_iSyncHackCount; }
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+public:
+	void SetChangeLook(CChangeLook* c);
+	CChangeLook* GetChangeLook() const;
+protected:
+	CChangeLook* m_pkChangeLook;
+#endif
+
+#if defined(__MAILBOX__)
+public:
+	int GetMyMailBoxTime() const { return m_iMyMailBoxTime; }
+	void SetMyMailBoxTime() { m_iMyMailBoxTime = thecore_pulse(); }
+
+	void SetMailBox(CMailBox* m);
+
+	void SetMailBoxLoading(const bool b) { bMailBoxLoading = b; }
+	bool IsMailBoxLoading() const { return bMailBoxLoading; }
+
+	CMailBox* GetMailBox() const { return m_pkMailBox; }
+
+private:
+	CMailBox* m_pkMailBox;
+	bool bMailBoxLoading;
+	int m_iMyMailBoxTime;
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+public:
+	void SetMiniGameRumi(CMiniGameRumi* pClass);
+	CMiniGameRumi* GetMiniGameRumi() const { return m_pkMiniGameRumi; }
+private:
+	CMiniGameRumi* m_pkMiniGameRumi;
+#endif
+
+#if defined(__CONQUEROR_LEVEL__)
+public:
+	bool IsNewWorldMapIndex() const;
+	long GetNewWorldSungMa(POINT_TYPE wPointType, bool bPremium = true) const;
+	bool IsSungMaCursed(POINT_TYPE wPointType) const;
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+public:
+	CLootFilter* GetLootFilter();
+	void SetLootFilter();
+	void ClearLootFilter();
+private:
+	CLootFilter* m_pLootFilter;
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+public:
+	bool IsOpenAttr67Add() const { return m_bIsOpenAttr67Add ? true : false; }
+	void SetOpenAttr67Add(bool bOpen) { m_bIsOpenAttr67Add = bOpen; }
+
+	LPITEM GetNPCStorageItem(BYTE bCell = 0) const;
+	bool Attr67Add(const TAttr67AddData kAttr67AddData);
+
+private:
+	bool m_bIsOpenAttr67Add;
+#endif
+
+#if defined(__FISHING_GAME__)
+public:
+	void SetFishingGameGoals(BYTE bCount) { m_bFishingGameGoals = bCount; }
+	BYTE GetFishingGameGoals() { return m_bFishingGameGoals; }
+private:
+	BYTE m_bFishingGameGoals;
+#endif
+
+#if defined(__GEM_SYSTEM__)
+public:
+	void SelectItemEx(DWORD dwInventoryPos, BYTE bType);
+	bool GemRefine(LPITEM lpMetinStoneItem);
+
+#	if defined(__GEM_SHOP__)
+public:
+	void SetGemShop(CGemShop* pGemShop);
+	CGemShop* GetGemShop() const { return m_pGemShop; }
+
+	void SetGemShopLoading(const bool c_bLoading) { m_bGemShopLoading = c_bLoading; }
+	bool IsGemShopLoading() const { return m_bGemShopLoading; }
+
+private:
+	CGemShop* m_pGemShop;
+	bool m_bGemShopLoading;
+#	endif
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	//////////////////////////////////////////////////////////////////////////////////
+	// Acce Costume System
+public:
+	void AcceRefineWindowOpen(const LPENTITY pEntity, BYTE bType);
+	void AcceRefineWindowClose(bool bServerClose = false);
+	bool IsAcceRefineWindowOpen() const { return m_bAcceRefineWindowOpen; }
+	bool GetAcceRefineWindowType() const { return m_bAcceRefineWindowType; }
+
+	bool IsAcceRefineWindowCanRefine();
+	LPENTITY GetAcceRefineWindowOpener() const { return m_pointsInstant.m_pAcceRefineWindowOpener; }
+
+	void AcceRefineWindowCheckIn(BYTE bType, TItemPos SelectedPos, TItemPos AttachedPos);
+	void AcceRefineWindowCheckOut(BYTE bType, TItemPos SelectedPos);
+	void AcceRefineWindowAccept(BYTE bType);
+
+	int GetAcceWeaponAttack() const;
+	int GetAcceWeaponMagicAttack() const;
+
+	void ModifyAccePoints(const LPITEM& rAcceItem, bool bAdd);
+
+protected:
+	int __CalculateAcceDrainValues(BYTE bWeaponAttackType) const;
+	int __CheckAcceRefineItem(const LPITEM& rLeftItem, const LPITEM& rRightItem) const;
+	BYTE __GetNextDrainRate(const LPITEM& rAcceItem, BYTE bMinDrainRate) const;
+
+private:
+	bool m_bAcceRefineWindowOpen;
+	BYTE m_bAcceRefineWindowType;
+	TItemPos m_pAcceRefineWindowItemSlot[ACCE_SLOT_MAX];
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+	//////////////////////////////////////////////////////////////////////////////////
+	// Aura Costume System
+public:
+	void OpenAuraRefineWindow(const LPENTITY pEntity, BYTE bType);
+	void AuraRefineWindowClose(bool bServerClose = false);
+	bool IsAuraRefineWindowOpen() const { return m_bAuraRefineWindowOpen; }
+	BYTE GetAuraRefineWindowType() const { return m_bAuraRefineWindowType; }
+
+	bool IsAuraRefineWindowCanRefine();
+	LPENTITY GetAuraRefineWindowOpener() const { return m_pointsInstant.m_pAuraRefineWindowOpener; }
+
+	void AuraRefineWindowCheckIn(BYTE bType, TItemPos SelectedPos, TItemPos AttachedPos);
+	void AuraRefineWindowCheckOut(BYTE bType, TItemPos SelectedPos);
+	void AuraRefineWindowAccept(BYTE bType);
+
+	void ModifyAuraPoints(const LPITEM& rAuraItem, bool bAdd);
+
+private:
+	BYTE m_bAuraRefineWindowType;
+	bool m_bAuraRefineWindowOpen;
+	TItemPos m_pAuraRefineWindowItemSlot[AURA_SLOT_MAX];
+	TAuraRefineInfo m_bAuraRefineInfo[AURA_REFINE_INFO_SLOT_MAX];
+
+protected:
+	TAuraRefineInfo __GetAuraRefineInfo(TItemPos Cell);
+	TAuraRefineInfo __CalcAuraRefineInfo(TItemPos Cell, TItemPos MaterialCell);
+	TAuraRefineInfo __GetAuraEvolvedRefineInfo(TItemPos Cell);
+#endif
+
+#if defined(__SOUL_SYSTEM__)
+public:
+	void SoulItemProcess(ESoulSubTypes eSubType);
+
+	int GetSoulDamage(ESoulSubTypes eSubType) const;
+	bool DoRefineSoul(LPITEM item);
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+public:
+	void SetExtendInvenStage(BYTE bStage) { m_bExtendInvenStage = bStage; }
+	BYTE GetExtendInvenStage() const { return m_bExtendInvenStage; }
+
+	WORD GetExtendInvenMax() const;
+
+	void ExtendInvenRequest();
+	void ExtendInvenUpgrade();
+
+	void SendExtendInvenPacket();
+
+private:
+	BYTE m_bExtendInvenStage;
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+public:
+	void StartHitBuffEvent();
+	void StopHitBuffEvent();
+private:
+	LPEVENT m_pHitBuffEvent;
+#endif
+
+#if defined(__CLIENT_TIMER__)
+public:
+	void SendClientTimer(BYTE bSubHeader, DWORD dwEndTime = 0, DWORD dwAlarmSec = 0);
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+public:
+	void AddEmote(const INT iEmoteIndex = -1);
+	void SetEmotes(const TPacketGDEmote* pTable, const WORD c_wSize);
+#endif
+
+#if defined(__SET_ITEM__)
+public:
+	using SetItemCountMap = std::map<BYTE, BYTE>;
+	SetItemCountMap GetItemSetCountMap() const;
+
+	void RefreshItemSetBonus();
+	void RefreshItemSetBonusByValue();
+#endif
+
+#if defined(__RACE_SWAP__)
+public:
+	void SetEventRaceNum(DWORD dwRaceNum);
+	DWORD GetEventRaceNum() const { return m_dwEventRaceNum; }
+private:
+	DWORD m_dwEventRaceNum;
+#endif
+
+#if defined(__GAME_OPTION_ESCAPE__)
+public:
+	void SetEscapeCooltime(const DWORD dwTime) { m_dwEscapeCooltime = dwTime; }
+	DWORD GetEscapeCooltime() const { return m_dwEscapeCooltime; }
+private:
+	DWORD m_dwEscapeCooltime;
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+public:
+	void RefineElementInformation(const LPITEM& rSrcItem, const TItemPos& kItemDestCell);
+	void RefineElement(WORD wElementType);
+
+	bool IsUnderRefineElement() const { return m_bUnderRefineElement; }
+	void SetUnderRefineElement(bool bState, BYTE bRefineType = 0, const TItemPos& rkSrcPos = NPOS, const TItemPos& rkDestPos = NPOS);
+
+	WORD GetRefineElementEffect() const;
+
+private:
+	struct SRefineElementItemPos
+	{
+		SRefineElementItemPos() : RefineType(0), SrcPos(NPOS), DestPos(NPOS) {}
+		BYTE RefineType;
+		TItemPos SrcPos, DestPos;
+	} m_kRefineElementItemPos;
+	bool m_bUnderRefineElement;
+#endif
+
+#if defined(__HIDE_COSTUME_SYSTEM__)
+public:
+	void SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bSave = true);
+	bool GetHiddenCostumeByPart(BYTE bPartPos) const;
+
+	void SetHiddenCostumeParts();
+private:
+	DWORD m_dwHideCostumePulse;
+	bool m_bHiddenCostumePart[COSTUME_NUM_TYPES];
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__)
+public:
+	void SetMiniGameYutnori(CMiniGameYutnori* pClass);
+	CMiniGameYutnori* GetMiniGameYutnori() const { return m_pkMiniGameYutnori; }
+private:
+	CMiniGameYutnori* m_pkMiniGameYutnori;
+#endif
+
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+public:
+	void SetCountry(const std::string& country) { m_stCountry = country; }
+	const char* GetCountry() const { return m_stCountry.c_str(); }
+
+protected:
+	std::string m_stCountry;
+#endif
+
+#if defined(__MYSHOP_DECO__)
+public:
+	void SetMyShopDecoState(BYTE bState) { m_bMyShopDecoState = bState; };
+	BYTE GetMyShopDecoState() const { return m_bMyShopDecoState; };
+
+	void SetMyShopDecoType(BYTE bShopType) { m_bMyShopDecoType = bShopType; };
+	BYTE GetMyShopDecoType() const { return m_bMyShopDecoType; };
+
+	void SetMyShopDecoPolyVnum(DWORD dwPolyVnum) { m_bMyShopDecoPolyVnum = dwPolyVnum; };
+	DWORD GetMyShopDecoPolyVnum() const { return m_bMyShopDecoPolyVnum; };
+
+	void SetMyPrivShopTabCount(BYTE bTabCount) { m_bMyPrivShopTabCount = bTabCount; };
+	BYTE GetMyPrivShopTabCount() const { return m_bMyPrivShopTabCount; };
+
+	void SetMyPrivShopIsCashItem(bool bIsCashItem) { m_bMyPrivShopIsCashItem = bIsCashItem; };
+	bool GetMyPrivShopIsCashItem() const { return m_bMyPrivShopIsCashItem; };
+
+	void OpenPrivateShop(BYTE bTabCount = 1, bool bIsCashItem = false);
+
+private:
+	BYTE m_bMyShopDecoState;
+	BYTE m_bMyShopDecoType;
+	DWORD m_bMyShopDecoPolyVnum;
+
+	BYTE m_bMyPrivShopTabCount;
+	bool m_bMyPrivShopIsCashItem;
+#endif
+
+#if defined(__LEFT_SEAT__)
+public:
+	void SetLeftSeat(bool bLeftSeat);
+	bool LeftSeat() const { return m_bLeftSeat; }
+
+	void SetLeftSeatWaitTime(BYTE bIndex);
+	DWORD GetLeftSeatWaitTime() const { return m_dwLeftSeatWaitTime; }
+
+	void SetLeftSeatLogoutTime(BYTE bIndex);
+	DWORD GetLeftSeatLogoutTime() const { return m_dwLeftSeatLogoutTime; }
+
+	void DisableLeftSeatLogOutState(bool bClosePopup = false);
+
+	void RestartLeftSeatWaitTimer();
+	void RestartLeftSeatLogoutTimer();
+
+	void SetLastRequestTime(DWORD dwRequestTime) { m_dwLastRequestTime = dwRequestTime; }
+	DWORD GetLastRequestTime() const { return m_dwLastRequestTime; }
+
+#ifdef __SHOP_SEARCH__
+	bool CheckShopSearchFlood();
+#endif
+
+public:
+	LPEVENT m_pLeftSeatWaitTimerEvent;
+	LPEVENT m_pLeftSeatLogoutTimerEvent;
+
+private:
+	BOOL m_bLeftSeat;
+	DWORD m_dwLeftSeatWaitTime;
+	DWORD m_dwLeftSeatLogoutTime;
+	DWORD m_dwLastRequestTime;
+#ifdef __SHOP_SEARCH__
+	DWORD m_dwLastShopSearchRequestTime;
+	BYTE m_bShopSearchFloodCount;
+#endif
+#endif
+
+#if defined(__ELEMENTAL_DUNGEON__)
+public:
+	void StartElementalCurseEvent();
+	void StopElementalCurseEvent();
+
+	void SetAccumulatedDamage(DWORD dwDamage);
+	DWORD GetAccumulatedDamage() const { return m_dwAccumulatedDamage; }
+
+private:
+	LPEVENT m_pElementalCurseEvent;
+	DWORD m_dwAccumulatedDamage;
+#endif
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+public:
+	void SetGuildDragonLair(CGuildDragonLair* pGuildDragonLair);
+	CGuildDragonLair* GetGuildDragonLair() const { return m_pGuildDragonLair; }
+private:
+	CGuildDragonLair* m_pGuildDragonLair;
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+public:
+	void SetMiniGameRoulette(CMiniGameRoulette* pMiniGameRoulette);
+	CMiniGameRoulette* GetMiniGameRoulette() const { return m_pMiniGameRoulette; }
+
+	void SetMiniGameRoulette_RewardMapperNum(BYTE bMapNum) { m_bMiniGameRoulette_RewardMapperNum = bMapNum; }
+	BYTE GetMiniGameRoulette_RewardMapperNum() const { return m_bMiniGameRoulette_RewardMapperNum; }
+
+private:
+	CMiniGameRoulette* m_pMiniGameRoulette;
+	BYTE m_bMiniGameRoulette_RewardMapperNum;
+#endif
+
+#if defined(__FLOWER_EVENT__)
+public:
+	void SetLastFlowerEventExchangePulse(DWORD dwPulse) { m_dwLastFlowerEventExchangePulse = dwPulse; }
+	DWORD GetLastFlowerEventExchangePulse() const { return m_dwLastFlowerEventExchangePulse; }
+private:
+	DWORD m_dwLastFlowerEventExchangePulse;
+#endif
+
+#if defined(__DEFENSE_WAVE__)
+public:
+	void SetDefenseWave(LPDEFENSE_WAVE pDefenseWave);
+	LPDEFENSE_WAVE GetDefenseWave() const;
+private:
+	LPDEFENSE_WAVE m_pDefenseWave;
+#endif
+
+#ifdef ENABLE_QUEEN_NETHIS
+public:
+	bool IsSnakeMap();
+#endif
+#ifdef __OFFLINE_SHOP__
+private:
+	uint32_t keepingOfflineShop_;
+
+	std::set<uint32_t> viewingOfflineShops_;
+
+	bool isOpeningOfflineShop_;
+	CItem* offlineShopOpeningItem_;
+
+public:
+	void SetKeepingOfflineShop(uint32_t keepingOfflineShop);
+	uint32_t GetKeepingOfflineShop() const;
+
+	void AddViewingOfflineShop(uint32_t id);
+	bool IsViewingOfflineShop();
+	void RemoveViewingOfflineShop(uint32_t id);
+	void RemoveFromViewingOfflineShops();
+
+	bool UseItemOpenOfflineShop(CItem* item);
+	void SetOpeningOfflineShopState(bool isOpeningOfflineShop);
+	bool IsOpeningOfflineShop() const;
+	void SetOfflineShopOpeningItem(CItem* item);
+	CItem* GetOfflineShopOpeningItem() const;
+	bool IsAffectOfflineShopDecoration();
+	void WarpToShop(long x, long y, long mapIndex, BYTE channel);
+
+private:
+	std::map<std::string, int> m_protection_Time;
+
+public:
+	int GetProtectTime(const std::string& flagname) const;
+	void SetProtectTime(const std::string& flagname, int time);
+
+public:
+	void	AddToSellHistory(TMySellHistory newItem);
+	void	SaveSellHistory();
+	void	RequestSellHistory(BYTE bPage);
+	void	SetSellHistoryLoaded(BYTE bStatus) {  m_bSellHistoryLoaded = bStatus; }
+	BYTE	GetSellHistoryLoaded() { return m_bSellHistoryLoaded; }
+protected:
+	BYTE	m_bSellHistoryLoaded;
+	std::vector<TMySellHistory> m_vecSellHistory;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+typedef std::list<TPlayerExtBattlePassMission*> ListExtBattlePassMap;
+public:
+	void LoadExtBattlePass(DWORD dwCount, TPlayerExtBattlePassMission* data);
+	DWORD GetExtBattlePassMissionProgress(DWORD dwBattlePassType, BYTE bMissionIndex, BYTE bMissionType);
+	bool IsExtBattlePassCompletedMission(DWORD dwBattlePassType, BYTE bMissionIndex, BYTE bMissionType);
+	bool IsExtBattlePassRegistered(BYTE bBattlePassType, DWORD dwBattlePassID);
+	void UpdateExtBattlePassMissionProgress(DWORD dwMissionID, DWORD dwUpdateValue, DWORD dwCondition, bool isOverride = false);
+	void SetExtBattlePassMissionProgress(BYTE bBattlePassType, DWORD dwMissionIndex, DWORD dwMissionType, DWORD dwUpdateValue);
+	
+	bool		IsLoadedExtBattlePass()		const	{ return m_bIsLoadedExtBattlePass; }
+	int			GetExtBattlePassPremiumID()	const	{ return m_points.battle_pass_premium_id;	}
+	void		SetExtBattlePassPremiumID(int battle_pass_premium_id)	{ m_points.battle_pass_premium_id = battle_pass_premium_id;}
+
+	void				SetLastReciveExtBattlePassInfoTime(DWORD time);
+	DWORD			GetLastReciveExtBattlePassInfoTime() const	{ return m_dwLastReciveExtBattlePassInfoTime; }
+	void				SetLastReciveExtBattlePassOpenRanking(DWORD time);
+	DWORD			GetLastReciveExtBattlePassOpenRanking() const	{ return m_dwLastExtBattlePassOpenRankingTime; }
+protected:
+	DWORD	m_dwLastReciveExtBattlePassInfoTime;
+	DWORD	m_dwLastExtBattlePassOpenRankingTime;
+	
+private:
+	bool m_bIsLoadedExtBattlePass;
+	ListExtBattlePassMap m_listExtBattlePass;
+#endif
+};
+
+ESex GET_SEX(LPCHARACTER ch);
+
+#endif // __INC_CHAR_H__
diff --git a/server/server/home/metin2/Source/Server/game/src/char_item.cpp b/server/server/home/metin2/Source/Server/game/src/char_item.cpp
index 28f3d59..9a138d2 100644
--- a/server/server/home/metin2/Source/Server/game/src/char_item.cpp
+++ b/server/server/home/metin2/Source/Server/game/src/char_item.cpp
@@ -1,12312 +1,12287 @@
-#include "stdafx.h"
-
-#include <stack>
-
-#include "utils.h"
-#include "config.h"
-#include "char.h"
-#include "char_manager.h"
-#include "item_manager.h"
-#include "desc.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "packet.h"
-#include "affect.h"
-#include "skill.h"
-#include "start_position.h"
-#include "mob_manager.h"
-#include "db.h"
-#include "log.h"
-#include "vector.h"
-#include "buffer_manager.h"
-#include "questmanager.h"
-#include "fishing.h"
-#include "party.h"
-#include "dungeon.h"
-#include "refine.h"
-#include "unique_item.h"
-#include "war_map.h"
-#include "xmas_event.h"
-#include "marriage.h"
-#include "monarch.h"
-#include "polymorph.h"
-#include "blend_item.h"
-#include "castle.h"
-#include "BattleArena.h"
-#include "arena.h"
-#include "dev_log.h"
-#include "pcbang.h"
-#include "threeway_war.h"
-
-#include "safebox.h"
-#include "shop.h"
-#include "pvp.h"
-
-#include "../../common/VnumHelper.h"
-#include "DragonSoul.h"
-#ifdef ENABLE_QUEEN_NETHIS
-#include "SnakeLair.h"
-#endif
-#include "buff_on_attributes.h"
-#include "belt_inventory_helper.h"
-#if defined(__LOOT_FILTER_SYSTEM__)
-#	include "LootFilter.h"
-#endif
-
-#if defined(__MT_THUNDER_DUNGEON__)
-#	include "mt_thunder_dungeon.h"
-#endif
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-#	include "guild_dragonlair.h"
-#endif
-
-#ifdef __OFFLINE_SHOP__
-#include "OfflineShop.h"
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-#include "growth_pet.h"
-#endif
-
-#include "../../libgame/include/grid.h"
-
-#include <optional>
-
-const int ITEM_BROKEN_METIN_VNUM = 28960;
-
-// CHANGE_ITEM_ATTRIBUTES
-const DWORD CHARACTER::msc_dwDefaultChangeItemAttrCycle = 10;
-const char CHARACTER::msc_szLastChangeItemAttrFlag[] = "Item.LastChangeItemAttr";
-const char CHARACTER::msc_szChangeItemAttrCycleFlag[] = "change_itemattr_cycle";
-// END_OF_CHANGE_ITEM_ATTRIBUTES
-const POINT_TYPE g_aBuffOnAttrPoints[] = { POINT_ENERGY, POINT_COSTUME_ATTR_BONUS };
-
-struct FFindStone
-{
-	std::map<DWORD, LPCHARACTER> m_mapStone;
-
-	void operator()(LPENTITY pEnt)
-	{
-		if (pEnt->IsType(ENTITY_CHARACTER) == true)
-		{
-			LPCHARACTER pChar = (LPCHARACTER)pEnt;
-
-			if (pChar->IsStone() == true)
-			{
-				m_mapStone[(DWORD)pChar->GetVID()] = pChar;
-			}
-		}
-	}
-};
-
-#if defined(__MT_THUNDER_DUNGEON__)
-struct FFindMobVnum
-{
-	DWORD dwMobVnum;
-	FFindMobVnum(DWORD dwMobVnum) : dwMobVnum(dwMobVnum) {}
-
-	std::map<DWORD, LPCHARACTER> m_mapVID;
-	void operator()(LPENTITY pEnt)
-	{
-		if (pEnt && pEnt->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER pChar = dynamic_cast<LPCHARACTER>(pEnt);
-
-			if (pChar && pChar->GetRaceNum() == dwMobVnum)
-			{
-				m_mapVID[(DWORD)pChar->GetVID()] = pChar;
-			}
-		}
-	}
-};
-#endif
-
-// 귀환부, 귀환기억부, 결혼반지
-bool IS_SUMMON_ITEM(LPITEM item, int map_index)
-{
-	if (item->GetVnum() == ITEM_MARRIAGE_RING)
-		return true;
-
-	switch (item->GetType())
-	{
-		case ITEM_QUEST:
-		{
-			if (item->GetSubType() == QUEST_WARP)
-			{
-				// NOTE : Force allow warp ring in certain maps indexes.
-				if (item->GetSpecialGroup() == UNIQUE_GROUP_WARP_RING)
-				{
-					switch (map_index)
-					{
-						case MAP_SKIPIA_DUNGEON_01:
-							return false;
-						default:
-							return true;
-					}
-				}
-				return true;
-			}
-		}
-		break;
-		case ITEM_USE:
-		{
-			if (item->GetSubType() == USE_TALISMAN)
-				return true;
-		}
-		break;
-	}
-
-	return false;
-}
-
-bool IS_MONKEY_DUNGEON(int map_index)
-{
-	switch (map_index)
-	{
-		case MAP_MONKEY_DUNGEON_11:
-		case MAP_MONKEY_DUNGEON_12:
-		case MAP_MONKEY_DUNGEON_13:
-		case MAP_MONKEY_DUNGEON:
-		case MAP_MONKEY_DUNGEON2:
-		case MAP_MONKEY_DUNGEON3:
-			return true;
-	}
-
-	return false;
-}
-
-bool IS_MAZE_DUNGEON(int map_index)
-{
-	switch (map_index)
-	{
-		case MAP_MAZE_DUNGEON1:
-		case MAP_MAZE_DUNGEON2:
-		case MAP_MAZE_DUNGEON3:
-			return true;
-	}
-
-	return false;
-}
-
-#if defined(__SNOW_DUNGEON__)
-bool IS_SNOW_DUNGEON(int map_index)
-{
-	if (map_index >= MAP_N_SNOW_DUNGEON_01 * 10000 && map_index < (MAP_N_SNOW_DUNGEON_01 + 1) * 10000)
-		return true;
-#if defined(__LABYRINTH_DUNGEON__)
-	else if (map_index >= MAP_BOSS_CRACK_SNOW * 10000 && map_index < (MAP_BOSS_CRACK_SNOW + 1) * 10000)
-		return true;
-	else if (map_index >= MAP_BOSS_AWAKEN_SNOW * 10000 && map_index < (MAP_BOSS_AWAKEN_SNOW + 1) * 10000)
-		return true;
-#endif
-
-	return false;
-}
-#endif
-
-#if defined(__ELEMENTAL_DUNGEON__)
-bool IS_ELEMENTAL_DUNGEON(int map_index)
-{
-	switch (map_index)
-	{
-		case MAP_ELEMENTAL_01:
-		case MAP_ELEMENTAL_02:
-		case MAP_ELEMENTAL_03:
-		case MAP_ELEMENTAL_04:
-			return true;
-	}
-
-	return false;
-}
-#endif
-
-bool IS_SUMMONABLE_ZONE(int map_index)
-{
-	// 몽키던전
-	if (IS_MONKEY_DUNGEON(map_index))
-		return false;
-
-	if (IS_MAZE_DUNGEON(map_index))
-		return false;
-
-	// 성
-	if (IS_CASTLE_MAP(map_index))
-		return false;
-
-	switch (map_index)
-	{
-		case MAP_DEVILTOWER1: // 사귀타워
-		case MAP_SPIDERDUNGEON_02: // 거미 던전 2층
-		case MAP_SKIPIA_DUNGEON_01: // 천의 동굴
-		case MAP_SKIPIA_DUNGEON_02: // 천의 동굴 2층
-#if 0
-		case 193: // 거미 던전 2-1층
-		case 184: // 천의 동굴(신수)
-		case 185: // 천의 동굴 2층(신수)
-		case 186: // 천의 동굴(천조)
-		case 187: // 천의 동굴 2층(천조)
-		case 188: // 천의 동굴(진노)
-		case 189: // 천의 동굴 2층(진노)
-#endif
-			//case 206: // 아귀동굴
-		case MAP_DEVILSCATACOMB: // 아귀동굴
-		case MAP_SPIDERDUNGEON_03: // 거미 던전 3층
-		case MAP_SKIPIA_DUNGEON_BOSS: // 천의 동굴 (용방)
-		case MAP_OXEVENT: // OX Event 맵
-		case MAP_12ZI_STAGE: // 12ZI
-		case MAP_BATTLEFIED: // Battlefield
-			return false;
-	}
-
-	if (CBattleArena::IsBattleArenaMap(map_index))
-		return false;
-
-	// 모든 private 맵으론 워프 불가능
-	if (map_index > 10000)
-		return false;
-
-	return true;
-}
-
-bool IS_BOTARYABLE_ZONE(int nMapIndex)
-{
-	if (LC_IsYMIR() == false && LC_IsKorea() == false) return true;
-
-	switch (nMapIndex)
-	{
-		case MAP_A1:
-		case MAP_A3:
-		case MAP_B1:
-		case MAP_B3:
-		case MAP_C1:
-		case MAP_C3:
-		case MAP_PRIVATESHOP:
-			return true;
-	}
-
-	return false;
-}
-
-// item socket 이 프로토타입과 같은지 체크 -- by mhh
-static bool FN_check_item_socket(LPITEM item)
-{
-	switch (item->GetVnum())
-	{
-		case ITEM_AUTO_HP_RECOVERY_S:
-		case ITEM_AUTO_HP_RECOVERY_M:
-		case ITEM_AUTO_HP_RECOVERY_L:
-		case ITEM_AUTO_HP_RECOVERY_X:
-		case ITEM_AUTO_SP_RECOVERY_S:
-		case ITEM_AUTO_SP_RECOVERY_M:
-		case ITEM_AUTO_SP_RECOVERY_L:
-		case ITEM_AUTO_SP_RECOVERY_X:
-		case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
-		case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
-		case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
-		case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
-		{
-			if (item->GetSocket(0) == 0 && item->GetSocket(1) == 0 && item->GetSocket(2) == item->GetProto()->alValues[0])
-				return true;
-		}
-		break;
-	}
-
-	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-	{
-		if (item->GetSocket(i) != item->GetProto()->alSockets[i])
-			return false;
-	}
-
-	return true;
-}
-
-// item socket 복사 -- by mhh
-static void FN_copy_item_socket(LPITEM dest, LPITEM src)
-{
-	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-	{
-		dest->SetSocket(i, src->GetSocket(i));
-	}
-}
-
-static bool FN_check_item_sex(LPCHARACTER ch, LPITEM item)
-{
-	// 남자 금지
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_MALE))
-	{
-		if (SEX_MALE == GET_SEX(ch))
-			return false;
-	}
-
-	// 여자금지
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_FEMALE))
-	{
-		if (SEX_FEMALE == GET_SEX(ch))
-			return false;
-	}
-
-	return true;
-}
-
-#define VERIFY_POTION(affect, afftype) \
-	if (FindAffect(affect, afftype)) \
-	{ \
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다.")); \
-		return false; \
-	}
-
-/////////////////////////////////////////////////////////////////////////////
-// ITEM HANDLING
-/////////////////////////////////////////////////////////////////////////////
-bool CHARACTER::CanHandleItem(bool bSkipCheckRefine, bool bSkipObserver)
-{
-	if (!bSkipObserver)
-		if (m_bIsObserver)
-			return false;
-
-	if (GetMyShop())
-		return false;
-
-	if (!bSkipCheckRefine)
-	{
-		if (IsUnderRefine())
-			return false;
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		if (IsUnderRefineElement())
-			return false;
-#endif
-	}
-
-	if (IsWarping())
-		return false;
-
-	if (IsCubeOpen())
-		return false;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (NULL != DragonSoul_RefineWindow_GetOpener())
-		return false;
-#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-	if (IsItemComb())
-		return false;
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	if (GetChangeLook())
-		return false;
-#endif
-
-#if defined(__MAILBOX__)
-	if (GetMailBox())
-		return false;
-#endif
-
-#if defined(__GEM_SHOP__)
-	if (GetGemShop())
-		return false;
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	if (IsAcceRefineWindowOpen())
-		return false;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-	if (IsAuraRefineWindowOpen() || NULL != GetAuraRefineWindowOpener())
-		return false;
-#endif
-
-#if defined(__CHANGED_ATTR__)
-	if (IsSelectAttr())
-		return false;
-#endif
-
-#if defined(__LUCKY_BOX__)
-	if (IsLuckyBoxOpen())
-		return false;
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	if (GetMiniGameRoulette())
-		return false;
-#endif
-
-	return true;
-}
-
-LPITEM CHARACTER::GetInventoryItem(WORD wCell) const
-{
-	return GetItem(TItemPos(INVENTORY, wCell));
-}
-
-LPITEM CHARACTER::GetEquipmentItem(WORD wCell) const
-{
-	return GetItem(TItemPos(EQUIPMENT, wCell));
-}
-
-LPITEM CHARACTER::GetDragonSoulInventoryItem(WORD wCell) const
-{
-	return GetItem(TItemPos(DRAGON_SOUL_INVENTORY, wCell));
-}
-
-LPITEM CHARACTER::GetBeltInventoryItem(WORD wCell) const
-{
-	return GetItem(TItemPos(BELT_INVENTORY, wCell));
-}
-
-LPITEM CHARACTER::GetItem(TItemPos Cell) const
-{
-	if (!IsValidItemPosition(Cell))
-		return nullptr;
-
-	WORD wCell = Cell.cell;
-	BYTE window_type = Cell.window_type;
-
-	switch (window_type)
-	{
-		case INVENTORY:
-		{
-			if (wCell >= INVENTORY_MAX_NUM)
-			{
-				sys_err("CHARACTER::GetItem: Invalid Inventory item! Window %d Cell %d", window_type, wCell);
-				return nullptr;
-			}
-			return m_pointsInstant.pInventoryItems[wCell];
-		}
-		break;
-
-		case EQUIPMENT:
-		{
-			if (wCell >= EQUIPMENT_MAX_NUM)
-			{
-				sys_err("CHARACTER::GetItem: Invalid Equipment item! Window %d Cell %d", window_type, wCell);
-				return nullptr;
-			}
-			return m_pointsInstant.pEquipmentItems[wCell];
-		}
-		break;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case DRAGON_SOUL_INVENTORY:
-		{
-			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-			{
-				sys_err("CHARACTER::GetItem: Invalid Dragon Soul item! window %d cell %d", window_type, wCell);
-				return nullptr;
-			}
-			return m_pointsInstant.pDragonSoulInventoryItems[wCell];
-		}
-		break;
-#endif
-
-		case BELT_INVENTORY:
-		{
-			if (wCell >= BELT_INVENTORY_SLOT_COUNT)
-			{
-				sys_err("CHARACTER::GetItem: Invalid Belt item! window %d cell %d", window_type, wCell);
-				return nullptr;
-			}
-			return m_pointsInstant.pBeltInventoryItems[wCell];
-		}
-		break;
-
-#if defined(__ATTR_6TH_7TH__)
-		case NPC_STORAGE:
-		{
-			if (wCell >= NPC_STORAGE_SLOT_MAX)
-			{
-				sys_err("CHARACTER::GetItem: invalid NPC_STORAGE item cell %d", wCell);
-				return nullptr;
-			}
-			return m_pointsInstant.pNPCStorageItems;
-		}
-#endif
-
-		default:
-			return nullptr;
-	}
-
-	return nullptr;
-}
-
-void CHARACTER::SetItem(TItemPos Cell, LPITEM pItem
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-	, bool isHighLight
-#endif
-)
-{
-	BYTE bWindowType = Cell.window_type;
-	WORD wCell = Cell.cell;
-
-	if ((unsigned long)((CItem*)pItem) == 0xff || (unsigned long)((CItem*)pItem) == 0xffffffff)
-	{
-		sys_err("!!! FATAL ERROR !!! item == 0xff (char: %s cell: %u)", GetName(), wCell);
-		core_dump();
-		return;
-	}
-
-	if (pItem && pItem->GetOwner())
-	{
-		assert(!"GetOwner exist");
-		return;
-	}
-
-	// 기본 인벤토리
-	switch (bWindowType)
-	{
-		case INVENTORY:
-		{
-			if (wCell >= INVENTORY_MAX_NUM)
-			{
-				sys_err("CHARACTER::SetItem: Invalid Inventory item! Window %d Cell %d", bWindowType, wCell);
-				return;
-			}
-
-			LPITEM pOldItem = m_pointsInstant.pInventoryItems[wCell];
-			if (pOldItem)
-			{
-				if (wCell < INVENTORY_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * INVENTORY_WIDTH);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-						if (wSlot >= GetExtendInvenMax())
-							continue;
-#else
-						if (wSlot >= INVENTORY_MAX_NUM)
-							continue;
-#endif
-
-						if (m_pointsInstant.pInventoryItems[wSlot] && m_pointsInstant.pInventoryItems[wSlot] != pOldItem)
-							continue;
-
-						m_pointsInstant.wInventoryItemGrid[wSlot] = 0;
-					}
-				}
-				else
-					m_pointsInstant.wInventoryItemGrid[wCell] = 0;
-			}
-
-			if (pItem)
-			{
-				if (wCell < INVENTORY_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * INVENTORY_WIDTH);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-						if (wSlot >= GetExtendInvenMax())
-							continue;
-#else
-						if (wSlot >= INVENTORY_MAX_NUM)
-							continue;
-#endif
-
-						// wCell + 1 로 하는 것은 빈곳을 체크할 때 같은
-						// 아이템은 예외처리하기 위함
-						m_pointsInstant.wInventoryItemGrid[wSlot] = wCell + 1;
-					}
-				}
-				else
-					m_pointsInstant.wInventoryItemGrid[wCell] = wCell + 1;
-			}
-
-			m_pointsInstant.pInventoryItems[wCell] = pItem;
-		}
-		break;
-
-		case EQUIPMENT:
-		{
-			if (wCell >= EQUIPMENT_MAX_NUM)
-			{
-				sys_err("CHARACTER::SetItem: Invalid Equipment item! Window %d Cell %d", bWindowType, wCell);
-				return;
-			}
-
-			LPITEM pOldItem = m_pointsInstant.pEquipmentItems[wCell];
-			if (pOldItem)
-			{
-				if (wCell < EQUIPMENT_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
-					{
-						BYTE bSlot = wCell + bSize;
-						if (bSlot >= EQUIPMENT_MAX_NUM)
-							continue;
-
-						if (m_pointsInstant.pEquipmentItems[bSlot] && m_pointsInstant.pEquipmentItems[bSlot] != pOldItem)
-							continue;
-
-						m_pointsInstant.bEquipmentItemGrid[bSlot] = 0;
-					}
-				}
-				else
-					m_pointsInstant.bEquipmentItemGrid[wCell] = 0;
-			}
-
-			if (pItem)
-			{
-				if (wCell < EQUIPMENT_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
-					{
-						BYTE bSlot = wCell + bSize;
-						if (bSlot >= EQUIPMENT_MAX_NUM)
-							continue;
-
-						m_pointsInstant.bEquipmentItemGrid[bSlot] = wCell + 1;
-					}
-				}
-				else
-					m_pointsInstant.bEquipmentItemGrid[wCell] = wCell + 1;
-			}
-
-			m_pointsInstant.pEquipmentItems[wCell] = pItem;
-		}
-		break;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case DRAGON_SOUL_INVENTORY:
-		{
-			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-			{
-				sys_err("CHARACTER::SetItem: Invalid Dragon Soul item! Window %d Cell %d", bWindowType, wCell);
-				return;
-			}
-
-			LPITEM pOldItem = m_pointsInstant.pDragonSoulInventoryItems[wCell];
-			if (pOldItem)
-			{
-				if (wCell < DRAGON_SOUL_INVENTORY_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * DRAGON_SOUL_BOX_COLUMN_NUM);
-						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-							continue;
-
-						if (m_pointsInstant.pDragonSoulInventoryItems[wSlot] && m_pointsInstant.pDragonSoulInventoryItems[wSlot] != pOldItem)
-							continue;
-
-						m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] = 0;
-					}
-				}
-				else
-					m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] = 0;
-			}
-
-			if (pItem)
-			{
-				if (wCell < DRAGON_SOUL_INVENTORY_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * DRAGON_SOUL_BOX_COLUMN_NUM);
-						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-							continue;
-
-						m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] = wCell + 1;
-					}
-				}
-				else
-					m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] = wCell + 1;
-			}
-
-			m_pointsInstant.pDragonSoulInventoryItems[wCell] = pItem;
-		}
-		break;
-#endif
-
-		case BELT_INVENTORY:
-		{
-			if (wCell >= BELT_INVENTORY_SLOT_COUNT)
-			{
-				sys_err("CHARACTER::SetItem: Invalid Belt item! Window %d Cell %d", bWindowType, wCell);
-				return;
-			}
-
-			LPITEM pOldItem = m_pointsInstant.pBeltInventoryItems[wCell];
-			if (pOldItem)
-			{
-				if (wCell < BELT_INVENTORY_SLOT_COUNT)
-				{
-					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * BELT_INVENTORY_SLOT_WIDTH);
-						if (wSlot >= BELT_INVENTORY_SLOT_COUNT)
-							continue;
-
-						if (m_pointsInstant.pBeltInventoryItems[wSlot] && m_pointsInstant.pBeltInventoryItems[wSlot] != pOldItem)
-							continue;
-
-						m_pointsInstant.bBeltInventoryItemGrid[wSlot] = 0;
-					}
-				}
-				else
-					m_pointsInstant.bBeltInventoryItemGrid[wCell] = 0;
-			}
-
-			if (pItem)
-			{
-				if (wCell < BELT_INVENTORY_SLOT_COUNT)
-				{
-					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * BELT_INVENTORY_SLOT_WIDTH);
-						if (wSlot >= BELT_INVENTORY_SLOT_COUNT)
-							continue;
-
-						m_pointsInstant.bBeltInventoryItemGrid[wSlot] = wCell + 1;
-					}
-				}
-				else
-					m_pointsInstant.bBeltInventoryItemGrid[wCell] = wCell + 1;
-			}
-
-			m_pointsInstant.pBeltInventoryItems[wCell] = pItem;
-		}
-		break;
-
-#if defined(__ATTR_6TH_7TH__)
-		case NPC_STORAGE:
-		{
-			if (wCell >= NPC_STORAGE_SLOT_MAX)
-			{
-				sys_err("CHARACTER::SetItem: invalid ATTR67_ADD item cell %d", wCell);
-				return;
-			}
-			m_pointsInstant.pNPCStorageItems = pItem;
-		}
-		break;
-#endif
-
-		default:
-			sys_err("Invalid Inventory type %d", bWindowType);
-			return;
-	}
-
-	if (GetDesc())
-	{
-		// 확장 아이템: 서버에서 아이템 플래그 정보를 보낸다
-		if (pItem)
-		{
-			TPacketGCItemSet pack;
-			pack.bHeader = HEADER_GC_ITEM_SET;
-			pack.Cell = Cell;
-			pack.dwVnum = pItem->GetVnum();
-			pack.dwCount = pItem->GetCount();
-			pack.dwFlags = pItem->GetFlag();
-			pack.dwAntiFlags = pItem->GetAntiFlag();
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			if (isHighLight)
-				pack.bHighLight = true;
-			else
-				pack.bHighLight = (Cell.window_type == DRAGON_SOUL_INVENTORY);
-#else
-			pack.bHighLight = (Cell.window_type == DRAGON_SOUL_INVENTORY);
-#endif
-#if defined(__SOUL_BIND_SYSTEM__)
-			pack.lSealDate = pItem->GetSealDate();
-#endif
-			thecore_memcpy(pack.alSockets, pItem->GetSockets(), sizeof(pack.alSockets));
-			thecore_memcpy(pack.aAttr, pItem->GetAttributes(), sizeof(pack.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			pack.dwTransmutationVnum = pItem->GetTransmutationVnum();
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			thecore_memcpy(&pack.RefineElement, pItem->GetRefineElement(), sizeof(pack.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			thecore_memcpy(pack.aApplyRandom, pItem->GetRandomApplies(), sizeof(pack.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-			pack.bSetValue = pItem->GetItemSetValue();
-#endif
-
-			GetDesc()->Packet(&pack, sizeof(TPacketGCItemSet));
-		}
-		else
-		{
-			TPacketGCItemSetEmpty pack;
-			pack.bHeader = HEADER_GC_ITEM_DEL;
-			pack.Cell = Cell;
-			pack.dwVnum = 0;
-			pack.dwCount = 0;
-			memset(pack.alSockets, 0, sizeof(pack.alSockets));
-			memset(pack.aAttr, 0, sizeof(pack.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			pack.dwTransmutationVnum = 0;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			memset(&pack.RefineElement, 0, sizeof(pack.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			memset(pack.aApplyRandom, 0, sizeof(pack.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-			pack.bSetValue = 0;
-#endif
-
-			GetDesc()->Packet(&pack, sizeof(TPacketGCItemSetEmpty));
-		}
-	}
-
-	if (pItem)
-	{
-		pItem->SetCell(this, wCell);
-		switch (bWindowType)
-		{
-			case INVENTORY:
-				pItem->SetWindow(INVENTORY);
-				break;
-
-			case EQUIPMENT:
-				pItem->SetWindow(EQUIPMENT);
-				break;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			case DRAGON_SOUL_INVENTORY:
-				pItem->SetWindow(DRAGON_SOUL_INVENTORY);
-				break;
-#endif
-
-			case BELT_INVENTORY:
-				pItem->SetWindow(BELT_INVENTORY);
-				break;
-
-#if defined(__ATTR_6TH_7TH__)
-			case NPC_STORAGE:
-				pItem->SetWindow(NPC_STORAGE);
-				break;
-#endif
-
-			default:
-				sys_err("Trying to set window %d, non determined behaviour!", bWindowType);
-		}
-	}
-}
-
-LPITEM CHARACTER::GetWear(WORD wCell) const
-{
-	if (wCell >= EQUIPMENT_MAX_NUM)
-	{
-		sys_err("CHARACTER::GetWear: invalid wear cell %d", wCell);
-		return nullptr;
-	}
-
-	return m_pointsInstant.pEquipmentItems[wCell];
-}
-
-void CHARACTER::SetWear(WORD wCell, LPITEM item)
-{
-	if (wCell >= EQUIPMENT_MAX_NUM)
-	{
-		sys_err("CHARACTER::SetItem: invalid item cell %d", wCell);
-		return;
-	}
-
-	SetItem(TItemPos(EQUIPMENT, wCell), item);
-
-	if (!item && wCell == WEAR_WEAPON)
-	{
-		// 귀검 사용 시 벗는 것이라면 효과를 없애야 한다.
-		if (IsAffectFlag(AFF_GWIGUM))
-			RemoveAffect(SKILL_GWIGEOM);
-
-		if (IsAffectFlag(AFF_GEOMGYEONG))
-			RemoveAffect(SKILL_GEOMKYUNG);
-	}
-}
-
-void CHARACTER::ClearItem()
-{
-	int i;
-	LPITEM item;
-
-	for (i = 0; i < INVENTORY_MAX_NUM; ++i)
-	{
-		if ((item = GetInventoryItem(i)))
-		{
-			item->SetSkipSave(true);
-			ITEM_MANAGER::Instance().FlushDelayedSave(item);
-
-			item->RemoveFromCharacter();
-			M2_DESTROY_ITEM(item);
-
-			SyncQuickslot(SLOT_TYPE_INVENTORY, i, WORD_MAX);
-		}
-	}
-
-	for (i = 0; i < EQUIPMENT_MAX_NUM; ++i)
-	{
-		if ((item = GetEquipmentItem(i)))
-		{
-			item->SetSkipSave(true);
-			ITEM_MANAGER::Instance().FlushDelayedSave(item);
-
-			item->RemoveFromCharacter();
-			M2_DESTROY_ITEM(item);
-		}
-	}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	for (i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
-	{
-		if ((item = GetDragonSoulInventoryItem(i)))
-		{
-			item->SetSkipSave(true);
-			ITEM_MANAGER::Instance().FlushDelayedSave(item);
-
-			item->RemoveFromCharacter();
-			M2_DESTROY_ITEM(item);
-		}
-	}
-#endif
-
-	for (i = 0; i < BELT_INVENTORY_SLOT_COUNT; ++i)
-	{
-		if ((item = GetBeltInventoryItem(i)))
-		{
-			item->SetSkipSave(true);
-			ITEM_MANAGER::Instance().FlushDelayedSave(item);
-
-			item->RemoveFromCharacter();
-			M2_DESTROY_ITEM(item);
-
-			SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, i, WORD_MAX);
-		}
-	}
-
-#if defined(__ATTR_6TH_7TH__)
-	if ((item = GetNPCStorageItem()))
-	{
-		item->SetSkipSave(true);
-		ITEM_MANAGER::Instance().FlushDelayedSave(item);
-
-		item->RemoveFromCharacter();
-		M2_DESTROY_ITEM(item);
-	}
-#endif
-}
-
-bool CHARACTER::IsEmptyItemGrid(TItemPos Cell, BYTE bSize, int iExceptionCell) const
-{
-	switch (Cell.window_type)
-	{
-		case INVENTORY:
-		{
-			const WORD wCell = Cell.cell;
-#if defined(__EXTEND_INVEN_SYSTEM__)
-			if (wCell >= GetExtendInvenMax())
-#else
-			if (wCell >= INVENTORY_MAX_NUM)
-#endif
-				return false;
-
-			// bItemCell은 0이 false임을 나타내기 위해 + 1 해서 처리한다.
-			// 따라서 iExceptionCell에 1을 더해 비교한다.
-			++iExceptionCell;
-
-			if (m_pointsInstant.wInventoryItemGrid[wCell])
-			{
-				if (m_pointsInstant.wInventoryItemGrid[wCell] == iExceptionCell)
-				{
-					if (bSize == 1)
-						return true;
-
-					int iOffset = 1;
-#if defined(__EXTEND_INVEN_SYSTEM__)
-					const WORD wPage = wCell / INVENTORY_PAGE_SIZE;
-#else
-					const WORD wPage = wCell / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT);
-#endif
-					do
-					{
-						const WORD wSlot = wCell + (INVENTORY_WIDTH * iOffset);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-						if (wSlot >= GetExtendInvenMax())
-							return false;
-
-						if (wSlot / INVENTORY_PAGE_SIZE != wPage)
-							return false;
-#else
-						if (wSlot >= INVENTORY_MAX_NUM)
-							return false;
-
-						if (wSlot / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT) != wPage)
-							return false;
-#endif
-
-						if (m_pointsInstant.wInventoryItemGrid[wSlot])
-						{
-							if (m_pointsInstant.wInventoryItemGrid[wSlot] != iExceptionCell)
-								return false;
-						}
-					} while (++iOffset < bSize);
-
-					return true;
-				}
-				else
-					return false;
-			}
-
-			// 크기가 1이면 한칸을 차지하는 것이므로 그냥 리턴
-			if (1 == bSize)
-				return true;
-			else
-			{
-				int iOffset = 1;
-#if defined(__EXTEND_INVEN_SYSTEM__)
-				const WORD wPage = wCell / INVENTORY_PAGE_SIZE;
-#else
-				const WORD wPage = wCell / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT);
-#endif
-
-				do
-				{
-					const WORD wSlot = wCell + (INVENTORY_WIDTH * iOffset);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-					if (wSlot >= GetExtendInvenMax())
-						return false;
-
-					if (wSlot / INVENTORY_PAGE_SIZE != wPage)
-						return false;
-#else
-					if (wSlot >= INVENTORY_MAX_NUM)
-						return false;
-
-					if (wSlot / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT) != wPage)
-						return false;
-#endif
-
-					if (m_pointsInstant.wInventoryItemGrid[wSlot])
-					{
-						if (m_pointsInstant.wInventoryItemGrid[wSlot] != iExceptionCell)
-							return false;
-					}
-				} while (++iOffset < bSize);
-
-				return true;
-			}
-		}
-		break;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case DRAGON_SOUL_INVENTORY:
-		{
-			const WORD wCell = Cell.cell;
-			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-				return false;
-
-			++iExceptionCell;
-
-			if (m_pointsInstant.wDragonSoulInventoryItemGrid[wCell])
-			{
-				if (m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] == iExceptionCell)
-				{
-					if (bSize == 1)
-						return true;
-
-					int iOffset = 1;
-
-					do
-					{
-						const WORD wSlot = wCell + (DRAGON_SOUL_BOX_COLUMN_NUM * iOffset);
-						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-							return false;
-
-						if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot])
-						{
-							if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] != iExceptionCell)
-								return false;
-						}
-					} while (++iOffset < bSize);
-
-					return true;
-				}
-				else
-					return false;
-			}
-
-			if (1 == bSize)
-				return true;
-			else
-			{
-				int iOffset = 1;
-
-				do
-				{
-					const WORD wSlot = wCell + (DRAGON_SOUL_BOX_COLUMN_NUM * iOffset);
-					if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-						return false;
-
-					if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot])
-					{
-						if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] != iExceptionCell)
-							return false;
-					}
-				} while (++iOffset < bSize);
-
-				return true;
-			}
-		}
-		break;
-#endif
-
-		case BELT_INVENTORY:
-		{
-			const WORD wCell = Cell.cell;
-			if (wCell >= BELT_INVENTORY_MAX_NUM)
-				return false;
-
-			++iExceptionCell;
-
-			const LPITEM pBeltItem = GetWear(WEAR_BELT);
-			if (pBeltItem == nullptr)
-				return false;
-
-			if (!CBeltInventoryHelper::IsAvailableCell(wCell - BELT_INVENTORY_SLOT_START, pBeltItem->GetValue(0)))
-				return false;
-
-			if (m_pointsInstant.bBeltInventoryItemGrid[wCell])
-			{
-				if (m_pointsInstant.bBeltInventoryItemGrid[wCell] == iExceptionCell)
-				{
-					if (bSize == 1)
-						return true;
-
-					int iOffset = 1;
-
-					do
-					{
-						const WORD wSlot = wCell + (BELT_INVENTORY_SLOT_WIDTH * iOffset);
-						if (wSlot >= BELT_INVENTORY_MAX_NUM)
-							return false;
-
-						if (m_pointsInstant.bBeltInventoryItemGrid[wSlot])
-						{
-							if (m_pointsInstant.bBeltInventoryItemGrid[wSlot] != iExceptionCell)
-								return false;
-						}
-					} while (++iOffset < bSize);
-
-					return true;
-				}
-				else
-					return false;
-			}
-
-			if (1 == bSize)
-				return true;
-			else
-			{
-				int iOffset = 1;
-
-				do
-				{
-					const WORD wSlot = wCell + (BELT_INVENTORY_SLOT_WIDTH * iOffset);
-					if (wSlot >= BELT_INVENTORY_MAX_NUM)
-						return false;
-
-					if (m_pointsInstant.bBeltInventoryItemGrid[wSlot])
-					{
-						if (m_pointsInstant.bBeltInventoryItemGrid[wSlot] != iExceptionCell)
-							return false;
-					}
-				} while (++iOffset < bSize);
-
-				return true;
-			}
-		}
-		break;
-	}
-
-	return false;
-}
-
-int CHARACTER::GetEmptyInventory(BYTE size) const
-{
-	// NOTE : 현재 이 함수는 아이템 지급, 획득 등의 행위를 할 때 인벤토리의 빈 칸을 찾기 위해 사용되고 있는데,
-	// 벨트 인벤토리는 특수 인벤토리이므로 검사하지 않도록 한다. (기본 인벤토리: INVENTORY_MAX_NUM 까지만 검사)
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (int i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-		if (IsEmptyItemGrid(TItemPos(INVENTORY, i), size))
-			return i;
-	return -1;
-}
-
-int CHARACTER::GetEmptyInventoryCount(BYTE size) const
-{
-	// NOTE : 현재 이 함수는 아이템 지급, 획득 등의 행위를 할 때 인벤토리의 빈 칸을 찾기 위해 사용되고 있는데,
-	// 벨트 인벤토리는 특수 인벤토리이므로 검사하지 않도록 한다. (기본 인벤토리: INVENTORY_MAX_NUM 까지만 검사)
-	int emptyCount = 0;
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (int i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-	{
-		if (IsEmptyItemGrid(TItemPos(INVENTORY, i), size))
-			++emptyCount;
-	}
-
-	return emptyCount;
-}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-int CHARACTER::GetEmptyDragonSoulInventory(LPITEM pItem) const
-{
-	if (NULL == pItem || !pItem->IsDragonSoul())
-		return -1;
-
-	if (!DragonSoul_IsQualified())
-		return -1;
-
-	BYTE bSize = pItem->GetSize();
-	WORD wBaseCell = DSManager::instance().GetBasePosition(pItem);
-
-	if (WORD_MAX == wBaseCell)
-		return -1;
-
-	for (int i = 0; i < DRAGON_SOUL_BOX_SIZE; ++i)
-		if (IsEmptyItemGrid(TItemPos(DRAGON_SOUL_INVENTORY, i + wBaseCell), bSize))
-			return i + wBaseCell;
-
-	return -1;
-}
-
-void CHARACTER::CopyDragonSoulItemGrid(std::vector<WORD>& vDragonSoulItemGrid) const
-{
-	vDragonSoulItemGrid.resize(DRAGON_SOUL_INVENTORY_MAX_NUM);
-	std::copy(m_pointsInstant.wDragonSoulInventoryItemGrid, m_pointsInstant.wDragonSoulInventoryItemGrid + DRAGON_SOUL_INVENTORY_MAX_NUM, vDragonSoulItemGrid.begin());
-}
-#endif
-
-int CHARACTER::CountEmptyInventory() const
-{
-	int count = 0;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (int i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-		if (GetInventoryItem(i))
-			count += GetInventoryItem(i)->GetSize();
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	return (GetExtendInvenMax() - count);
-#else
-	return (INVENTORY_MAX_NUM - count);
-#endif
-}
-
-bool CHARACTER::HasEnoughInventorySpace(std::vector<TItemData>& vItems) const
-{
-	if (vItems.empty())
-		return true;
-
-	static std::array<CGrid, 4> aGrids = {
-		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
-		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
-		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
-		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT)
-	};
-	for (auto& kGrid : aGrids)
-		kGrid.Clear();
-
-	LPITEM pItem = nullptr;
-	for (int i = 0; i < INVENTORY_PAGE_SIZE * 4; ++i)
-	{
-		if ((pItem = GetInventoryItem(i)))
-		{
-			aGrids[i / INVENTORY_PAGE_SIZE].Put(i % INVENTORY_PAGE_SIZE, 1, pItem->GetSize());
-		}
-	}
-
-	for (const TItemData& kItem : vItems)
-	{
-		const TItemTable* pItemTable = ITEM_MANAGER::Instance().GetTable(kItem.dwVnum);
-		if (!pItemTable)
-			return true;
-
-		int iPos = -1;
-		for (int j = 0; j < aGrids.size(); ++j)
-		{
-			iPos = aGrids[j].FindBlank(1, pItemTable->bSize);
-			if (iPos >= 0)
-			{
-#if defined(__EXTEND_INVEN_SYSTEM__)
-				if (j >= 2)
-				{
-					int iExtendMaxPos = (INVENTORY_WIDTH * (GetExtendInvenStage() - (j - 1))) - 1;
-					if (iPos > iExtendMaxPos)
-						return false;
-
-					if (pItemTable->bSize > 1)
-					{
-						iExtendMaxPos -= (INVENTORY_WIDTH * (pItemTable->bSize - 1));
-						if (iPos > iExtendMaxPos)
-							return false;
-					}
-				}
-#endif
-				aGrids[j].Put(iPos, 1, pItemTable->bSize);
-				break;
-			}
-		}
-
-		if (iPos == -1)
-			return false;
-	}
-
-	return true;
-}
-
-void TransformRefineItem(LPITEM pkOldItem, LPITEM pkNewItem)
-{
-	// ACCESSORY_REFINE
-	if (pkOldItem->IsAccessoryForSocket())
-	{
-		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-		{
-			pkNewItem->SetSocket(i, pkOldItem->GetSocket(i));
-		}
-		//pkNewItem->StartAccessorySocketExpireEvent();
-	}
-	// END_OF_ACCESSORY_REFINE
-	else
-	{
-		// 여기서 깨진석이 자동적으로 청소 됨
-		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-		{
-			if (!pkOldItem->GetSocket(i))
-				break;
-			else
-				pkNewItem->SetSocket(i, 1);
-		}
-
-		// 소켓 설정
-		int slot = 0;
-
-		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-		{
-			long socket = pkOldItem->GetSocket(i);
-
-			if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
-				pkNewItem->SetSocket(slot++, socket);
-		}
-
-	}
-
-#if defined(__ITEM_SOCKET6__)
-	for (int i = METIN_SOCKET_MAX_NUM; i < ITEM_SOCKET_MAX_NUM; ++i)
-		pkNewItem->SetSocket(i, pkOldItem->GetSocket(i));
-#endif
-
-	// 매직 아이템 설정
-	pkOldItem->CopyAttributeTo(pkNewItem);
-}
-
-void NotifyRefineSuccess(LPCHARACTER ch, LPITEM item, const char* way)
-{
-	if (NULL != ch && item != NULL)
-	{
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineSuceeded");
-
-		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), 1, way);
-	}
-}
-
-void NotifyRefineFail(LPCHARACTER ch, LPITEM item, const char* way, int success = 0)
-{
-	if (NULL != ch && NULL != item)
-	{
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineFailed");
-
-		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), success, way);
-	}
-}
-
-#if defined(__REFINE_MSG_ADD__)
-void NotifyRefineFailType(const LPCHARACTER ch, const LPITEM item, const BYTE type, const char* way, const BYTE success = 0)
-{
-	if (ch && item)
-	{
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineFailedType %d", type);
-		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), success, way);
-	}
-}
-#endif
-
-void CHARACTER::SetRefineNPC(LPCHARACTER ch)
-{
-	if (ch != NULL)
-	{
-		m_dwRefineNPCVID = ch->GetVID();
-	}
-	else
-	{
-		m_dwRefineNPCVID = 0;
-	}
-}
-
-bool CHARACTER::DoRefine(LPITEM item, bool bMoneyOnly)
-{
-	if (!CanHandleItem(true))
-	{
-		ClearRefineMode();
-		return false;
-	}
-
-	// HARDENING: block spoofed refine packets on fishing rods (rods use dedicated upgrade logic)
-	if (item && item->GetType() == ITEM_ROD)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("\xc0\xcc \xbe\xc6\xc0\xcc\xc5\xdb\xc0\xba \xb0\xb3\xb7\xae\xc7\xd2 \xbc\xf6 \xbe\xf8\xbd\xc0\xb4\xcf\xb4\xd9."));
-		ClearRefineMode();
-		return false;
-	}
-
-	//개량 시간제한 : upgrade_refine_scroll.quest 에서 개량후 5분이내에 일반 개량을
-	//진행할수 없음
-	if (quest::CQuestManager::instance().GetEventFlag("update_refine_time") != 0)
-	{
-		if (get_global_time() < quest::CQuestManager::instance().GetEventFlag("update_refine_time") + (60 * 5))
-		{
-			sys_log(0, "can't refine %d %s", GetPlayerID(), GetName());
-			return false;
-		}
-	}
-
-	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
-	if (!prt)
-		return false;
-
-	DWORD result_vnum = item->GetRefinedVnum();
-
-	// REFINE_COST
-	int cost = ComputeRefineFee(prt->cost);
-
-	int RefineChance = GetQuestFlag("main_quest_lv7.refine_chance");
-
-	if (RefineChance > 0)
-	{
-		if (!item->CheckItemUseLevel(20) || item->GetType() != ITEM_WEAPON)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("무료 개량 기회는 20 이하의 무기만 가능합니다"));
-			return false;
-		}
-		cost = 0;
-		SetQuestFlag("main_quest_lv7.refine_chance", RefineChance - 1);
-	}
-	// END_OF_REFINE_COST
-
-	if (result_vnum == 0)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("더 이상 개량할 수 없습니다."));
-		return false;
-	}
-
-	if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TUNING)
-		return false;
-
-	TItemTable* pProto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
-
-	if (!pProto)
-	{
-		sys_err("DoRefine NOT GET ITEM PROTO %d", item->GetRefinedVnum());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템은 개량할 수 없습니다."));
-		return false;
-	}
-
-	// Check level limit in korea only
-	if (!g_iUseLocale)
-	{
-		for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-		{
-			long limit = pProto->aLimits[i].lValue;
-
-			switch (pProto->aLimits[i].bType)
-			{
-				case LIMIT_LEVEL:
-				{
-					if (GetLevel() < limit)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("개량된 후 아이템의 레벨 제한보다 레벨이 낮습니다."));
-						return false;
-					}
-				}
-				break;
-
-#if defined(__CONQUEROR_LEVEL__)
-				case LIMIT_NEWWORLD_LEVEL:
-				{
-					if (GetConquerorLevel() < limit)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("개량된 후 아이템의 레벨 제한보다 레벨이 낮습니다."));
-						return false;
-					}
-				}
-				break;
-#endif
-			}
-		}
-	}
-
-	// REFINE_COST
-	if (GetGold() < (long long)cost)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("개량을 하기 위한 돈이 부족합니다."));
-		return false;
-	}
-
-#if defined(__REFINE_STACK_FIX__)
-	int iEmptyPos = GetEmptyInventory(item->GetSize());
-	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-	{
-		if (-1 == iEmptyPos)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지품에 빈 공간이 없습니다."));
-			return false;
-		}
-	}
-#endif
-
-	if (!bMoneyOnly && !RefineChance)
-	{
-		for (int i = 0; i < prt->material_count; ++i)
-		{
-			if (CountSpecifyItem(prt->materials[i].vnum, item->GetCell()) < prt->materials[i].count)
-			{
-				if (test_server)
-				{
-					ChatPacket(CHAT_TYPE_INFO, "Find %d, count %d, require %d", prt->materials[i].vnum, CountSpecifyItem(prt->materials[i].vnum), prt->materials[i].count);
-				}
-
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("개량을 하기 위한 재료가 부족합니다."));
-				return false;
-			}
-		}
-
-		for (int i = 0; i < prt->material_count; ++i)
-			RemoveSpecifyItem(prt->materials[i].vnum, prt->materials[i].count, item->GetCell());
-	}
-
-	int prob = number(1, 100);
-
-	if (IsRefineThroughGuild() || bMoneyOnly)
-		prob -= 10;
-
-	// END_OF_REFINE_COST
-
-	if (prob <= prt->prob)
-	{
-		// 성공! 모든 아이템이 사라지고, 같은 속성의 다른 아이템 획득
-		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
-
-		if (pkNewItem)
-		{
-			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
-			if (aApplyRandom)
-				pkNewItem->SetRandomApplies(aApplyRandom);
-#endif
-
-			LogManager::instance().ItemLog(this, pkNewItem, "REFINE SUCCESS", pkNewItem->GetName());
-
-			UINT bCell = item->GetCell();
-
-			// DETAIL_REFINE_LOG
-			NotifyRefineSuccess(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
-			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -cost);
-			// END_OF_DETAIL_REFINE_LOG
-
-#if defined(__REFINE_STACK_FIX__)
-			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-			{
-				item->SetCount(item->GetCount() - 1);
-				AutoGiveItem(pkNewItem, true, true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-					, true
-#endif
-				);
-			}
-			else
-			{
-				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
-				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-			}
-#else
-			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
-			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-#endif
-
-			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
-			pkNewItem->AttrLog();
-
-			sys_log(0, "Refine Success %d", cost);
-			//PointChange(POINT_GOLD, -cost);
-			sys_log(0, "PayPee %d", cost);
-			PayRefineFee(cost);
-			sys_log(0, "PayPee End %d", cost);
-		}
-		else
-		{
-			// DETAIL_REFINE_LOG
-			// 아이템 생성에 실패 -> 개량 실패로 간주
-			sys_err("cannot create item %u", result_vnum);
-#if defined(__REFINE_MSG_ADD__)
-			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, IsRefineThroughGuild() ? "GUILD" : "POWER");
-#else
-			NotifyRefineFail(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
-#endif
-			// END_OF_DETAIL_REFINE_LOG
-		}
-	}
-	else
-	{
-		// 실패! 모든 아이템이 사라짐.
-		DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -cost);
-#if defined(__REFINE_MSG_ADD__)
-		NotifyRefineFailType(this, item, REFINE_FAIL_DEL_ITEM, IsRefineThroughGuild() ? "GUILD" : "POWER");
-#else
-		NotifyRefineFail(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
-#endif
-		item->AttrLog();
-
-#if defined(__REFINE_STACK_FIX__)
-		if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-		{
-			item->SetCount(item->GetCount() - 1);
-		}
-		else
-		{
-			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
-		}
-#else
-		ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
-#endif
-
-		//PointChange(POINT_GOLD, -cost);
-		PayRefineFee(cost);
-	}
-
-	return true;
-}
-
-enum ERefineScroll
-{
-	CHUKBOK_SCROLL = 0,
-	HYUNIRON_STONE = 1,
-	YONGSIN_SCROLL = 2,
-	MUSIN_SCROLL = 3,
-	YAGONG_SCROLL = 4,
-	MEMO_SCROLL = 5,
-	BDRAGON_SCROLL = 6,
-#if defined(__STONE_OF_BLESS__)
-	BLESSING_STONE = 7,
-#endif
-#if defined(__SOUL_SYSTEM__)
-	SOUL_AWAKE_SCROLL = 8,
-	SOUL_EVOLVE_SCROLL = 9,
-#endif
-#if defined(__STONE_OF_BLESS__)
-	MALL_BLESSING_STONE = 10,
-#endif
-};
-
-#if defined(__SOUL_SYSTEM__)
-bool CHARACTER::DoRefineSoul(LPITEM item)
-{
-	if (!CanHandleItem(true))
-	{
-		ClearRefineMode();
-		return false;
-	}
-
-	ClearRefineMode();
-
-	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
-	if (!prt)
-		return false;
-
-	if (m_iRefineAdditionalCell < 0)
-		return false;
-
-	LPITEM item_scroll = GetInventoryItem(m_iRefineAdditionalCell);
-	if (item_scroll == nullptr)
-		return false;
-
-	if (!(item_scroll->GetType() == ITEM_USE && item_scroll->GetSubType() == USE_TUNING))
-		return false;
-
-	if (item_scroll->GetVnum() == item->GetVnum())
-		return false;
-
-	DWORD result_vnum = item->GetRefinedVnum();
-	if (result_vnum == 0)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("더 이상 개량할 수 없습니다."));
-		return false;
-	}
-
-	TItemTable* proto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
-	if (!proto)
-	{
-		sys_err("DoRefineSoul NOT GET ITEM PROTO %d", item->GetRefinedVnum());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템은 개량할 수 없습니다."));
-		return false;
-	}
-
-	int prob = number(1, 100);
-	int success_prob = prt->prob;
-
-	switch (item_scroll->GetValue(0))
-	{
-		case SOUL_AWAKE_SCROLL:
-			success_prob = 100;
-			break;
-
-		case SOUL_EVOLVE_SCROLL:
-			success_prob = soul_refine_prob[MINMAX(0, item->GetValue(1), SOUL_GRADE_MAX)];
-			break;
-	}
-
-	item_scroll->SetCount(item_scroll->GetCount() - 1);
-
-	if (prob <= success_prob)
-	{
-		LPITEM new_item = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
-		if (new_item)
-		{
-			WORD wCell = item->GetCell();
-
-			LogManager::instance().ItemLog(this, new_item, "SOUL REFINE FAIL", new_item->GetName());
-			ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulSuceeded");
-
-			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (SOUL REFINE FAIL)");
-
-			new_item->AddToCharacter(this, TItemPos(INVENTORY, wCell));
-			ITEM_MANAGER::instance().FlushDelayedSave(new_item);
-		}
-		else
-		{
-			sys_err("cannot create item %u", result_vnum);
-			ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulFailed");
-		}
-	}
-	else
-	{
-		ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulFailed");
-	}
-
-	return true;
-}
-#endif
-
-bool CHARACTER::DoRefineWithScroll(LPITEM item)
-{
-	if (!CanHandleItem(true))
-	{
-		ClearRefineMode();
-		return false;
-	}
-
-	ClearRefineMode();
-
-	// 개량 시간제한 : upgrade_refine_scroll.quest 에서 개량후 5분이내에 일반 개량을
-	// 진행할수 없음
-	if (quest::CQuestManager::instance().GetEventFlag("update_refine_time") != 0)
-	{
-		if (get_global_time() < quest::CQuestManager::instance().GetEventFlag("update_refine_time") + (60 * 5))
-		{
-			sys_log(0, "can't refine %d %s", GetPlayerID(), GetName());
-			return false;
-		}
-	}
-
-	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
-	if (!prt)
-		return false;
-
-	LPITEM pkItemScroll;
-
-	// 개량서 체크
-	if (m_iRefineAdditionalCell < 0)
-		return false;
-
-	pkItemScroll = GetInventoryItem(m_iRefineAdditionalCell);
-
-	if (!pkItemScroll)
-		return false;
-
-	if (!(pkItemScroll->GetType() == ITEM_USE && pkItemScroll->GetSubType() == USE_TUNING))
-		return false;
-
-	if (pkItemScroll->GetVnum() == item->GetVnum())
-		return false;
-
-	DWORD result_vnum = item->GetRefinedVnum();
-	DWORD result_fail_vnum = item->GetRefineFromVnum();
-
-	if (result_vnum == 0)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("더 이상 개량할 수 없습니다."));
-		return false;
-	}
-
-	TItemTable* pProto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
-	if (!pProto)
-	{
-		sys_err("DoRefineWithScroll NOT GET ITEM PROTO %d", item->GetRefinedVnum());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템은 개량할 수 없습니다."));
-		return false;
-	}
-
-	if (GetGold() < prt->cost)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("개량을 하기 위한 돈이 부족합니다."));
-		return false;
-	}
-
-#if defined(__REFINE_STACK_FIX__)
-	int iEmptyPos = GetEmptyInventory(item->GetSize());
-	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-	{
-		if (-1 == iEmptyPos)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지품에 빈 공간이 없습니다."));
-			return false;
-		}
-	}
-#endif
-
-	for (int i = 0; i < prt->material_count; ++i)
-	{
-		if (CountSpecifyItem(prt->materials[i].vnum, item->GetCell()) < prt->materials[i].count)
-		{
-			if (test_server)
-			{
-				ChatPacket(CHAT_TYPE_INFO, "Find %d, count %d, require %d", prt->materials[i].vnum, CountSpecifyItem(prt->materials[i].vnum), prt->materials[i].count);
-			}
-
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("개량을 하기 위한 재료가 부족합니다."));
-			return false;
-		}
-	}
-
-	for (int i = 0; i < prt->material_count; ++i)
-		RemoveSpecifyItem(prt->materials[i].vnum, prt->materials[i].count, item->GetCell());
-
-	int prob = number(1, 100);
-	const SRefineScrollData& kScroll = GetScrollRefinePct(prt->prob, item->GetRefinedVnum(), pkItemScroll->GetValue(0));
-	const char* szRefineType = "SCROLL";
-
-	switch (pkItemScroll->GetValue(0))
-	{
-		case HYUNIRON_STONE:
-			szRefineType = "HYUNIRON_STONE";
-			break;
-
-		case YONGSIN_SCROLL:
-			szRefineType = "GOD_SCROLL";
-			break;
-
-		case MUSIN_SCROLL:
-			szRefineType = "MUSIN_SCROLL";
-			break;
-
-		case YAGONG_SCROLL:
-			szRefineType = "YAGONG_SCROLL";
-			break;
-
-		case MEMO_SCROLL:
-			szRefineType = "MEMO_SCROLL";
-			break;
-
-		case BDRAGON_SCROLL:
-			szRefineType = "BDRAGON_SCROLL";
-			break;
-
-#if defined(__STONE_OF_BLESS__)
-		case BLESSING_STONE:
-			szRefineType = "BLESSING_STONE";
-			break;
-
-		case MALL_BLESSING_STONE:
-			szRefineType = "MALL_BLESSING_STONE";
-			break;
-#endif
-
-		default:
-			sys_err("REFINE : Unknown refine scroll item. Value0: %d", pkItemScroll->GetValue(0));
-			break;
-	}
-
-	if (test_server)
-		ChatPacket(CHAT_TYPE_INFO, "[Only Test] SuccessProb %d, RefineLevel %d ", kScroll.bSuccessProb, item->GetRefineLevel());
-
-	pkItemScroll->SetCount(pkItemScroll->GetCount() - 1);
-
-	if (prob <= kScroll.bSuccessProb)
-	{
-		// 성공! 모든 아이템이 사라지고, 같은 속성의 다른 아이템 획득
-		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
-
-		if (pkNewItem)
-		{
-			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
-			if (aApplyRandom)
-				pkNewItem->SetRandomApplies(aApplyRandom);
-#endif
-
-			LogManager::instance().ItemLog(this, pkNewItem, "REFINE SUCCESS", pkNewItem->GetName());
-
-			UINT bCell = item->GetCell();
-
-			NotifyRefineSuccess(this, item, szRefineType);
-			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -prt->cost);
-
-#if defined(__REFINE_STACK_FIX__)
-			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-			{
-				item->SetCount(item->GetCount() - 1);
-				AutoGiveItem(pkNewItem, true, true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-					, true
-#endif
-				);
-			}
-			else
-			{
-				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
-				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-			}
-#else
-			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
-			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-#endif
-
-			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
-			pkNewItem->AttrLog();
-
-			//PointChange(POINT_GOLD, -prt->cost);
-			PayRefineFee(prt->cost);
-		}
-		else
-		{
-			// 아이템 생성에 실패 -> 개량 실패로 간주
-			sys_err("cannot create item %u", result_vnum);
-#if defined(__REFINE_MSG_ADD__)
-			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
-#else
-			NotifyRefineFail(this, item, szRefineType);
-#endif
-		}
-	}
-	else if (!kScroll.bKeepGrade && result_fail_vnum)
-	{
-		// 실패! 모든 아이템이 사라지고, 같은 속성의 낮은 등급의 아이템 획득
-		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_fail_vnum, 1, 0, false);
-
-		if (pkNewItem)
-		{
-			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_PREVIOUS);
-			if (aApplyRandom)
-				pkNewItem->SetRandomApplies(aApplyRandom);
-#endif
-
-			LogManager::instance().ItemLog(this, pkNewItem, "REFINE FAIL", pkNewItem->GetName());
-
-			UINT bCell = item->GetCell();
-
-			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -prt->cost);
-#if defined(__REFINE_MSG_ADD__)
-			NotifyRefineFailType(this, item, REFINE_FAIL_GRADE_DOWN, szRefineType, -1);
-#else
-			NotifyRefineFail(this, item, szRefineType, -1);
-
-#endif
-
-#if defined(__REFINE_STACK_FIX__)
-			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-			{
-				item->SetCount(item->GetCount() - 1);
-				AutoGiveItem(pkNewItem, true, true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-					, true
-#endif
-				);
-			}
-			else
-			{
-				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
-				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-			}
-#else
-			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
-			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-#endif
-
-			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
-			pkNewItem->AttrLog();
-
-			//PointChange(POINT_GOLD, -prt->cost);
-			PayRefineFee(prt->cost);
-		}
-		else
-		{
-			// 아이템 생성에 실패 -> 개량 실패로 간주
-			sys_err("cannot create item %u", result_fail_vnum);
-#if defined(__REFINE_MSG_ADD__)
-			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
-#else
-			NotifyRefineFail(this, item, szRefineType);
-#endif
-		}
-	}
-	else
-	{
-#if defined(__REFINE_MSG_ADD__)
-		NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
-#else
-		NotifyRefineFail(this, item, szRefineType); // 개량시 아이템 사라지지 않음
-#endif
-		PayRefineFee(prt->cost);
-	}
-
-	return true;
-}
-
-CHARACTER::SRefineScrollData CHARACTER::GetScrollRefinePct(BYTE bProb, BYTE bRefineLevel, BYTE bScrollType)
-{
-	SRefineScrollData Scroll{};
-	Scroll.bSuccessProb = bProb;
-	Scroll.bKeepGrade = false;
-
-	// 현철, 용신의 축복서, 야공의 비전서 처리
-	switch (bScrollType)
-	{
-		case CHUKBOK_SCROLL:
-			break;
-
-		case HYUNIRON_STONE:
-			Scroll.bSuccessProb = MINMAX(1, bProb + 10, 100);
-			Scroll.bKeepGrade = true;
-			break;
-
-		case YONGSIN_SCROLL:
-			Scroll.bSuccessProb = MINMAX(1, bProb + 10, 100);
-			break;
-
-		case MUSIN_SCROLL: // 무신의 축복서는 100% 성공 (+4까지만)
-			Scroll.bSuccessProb = 100;
-			break;
-
-		case YAGONG_SCROLL:
-			Scroll.bSuccessProb = MINMAX(1, bProb + 15, 100);
-			break;
-
-		case MEMO_SCROLL:
-			Scroll.bSuccessProb = 100;
-			break;
-
-		case BDRAGON_SCROLL:
-			Scroll.bSuccessProb = 80;
-			break;
-
-#if defined(__STONE_OF_BLESS__)
-		case BLESSING_STONE:
-			Scroll.bSuccessProb = MINMAX(1, bProb + 15, 100);
-			Scroll.bKeepGrade = true;
-			break;
-
-		case MALL_BLESSING_STONE:
-			Scroll.bSuccessProb = MINMAX(1, bProb + 20, 100);
-			Scroll.bKeepGrade = true;
-			break;
-#endif
-	}
-
-	return Scroll;
-}
-
-bool CHARACTER::RefineInformation(WORD wCell, BYTE bType, int iAdditionalCell)
-{
-	if (wCell > INVENTORY_MAX_NUM)
-		return false;
-
-	const LPITEM item = GetInventoryItem(wCell);
-	if (!item)
-		return false;
-
-	// HARDENING: fishing rods do not use refine_proto (avoid spoofed REFINE packets)
-	if (item->GetType() == ITEM_ROD)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("\xc0\xcc \xbe\xc6\xc0\xcc\xc5\xdb\xc0\xba \xb0\xb3\xb7\xae\xc7\xd2 \xbc\xf6 \xbe\xf8\xbd\xc0\xb4\xcf\xb4\xd9."));
-		ClearRefineMode();
-		return false;
-	}
-
-	// REFINE_COST
-	if (bType == REFINE_TYPE_MONEY_ONLY && !GetQuestFlag("deviltower_zone.can_refine"))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("사귀 타워 완료 보상은 한번까지 사용가능합니다."));
-		return false;
-	}
-	// END_OF_REFINE_COST
-
-	TPacketGCRefineInformation p;
-	p.header = HEADER_GC_REFINE_INFORMATION;
-	p.pos = wCell;
-	p.src_vnum = item->GetVnum();
-	p.result_vnum = item->GetRefinedVnum();
-	p.type = bType;
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	thecore_memcpy(&p.RefineElement, item->GetRefineElement(), sizeof(p.RefineElement));
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-	item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
-	thecore_memcpy(&p.aApplyRandom, aApplyRandom, sizeof(p.aApplyRandom));
-#endif
-
-	if (p.result_vnum == 0)
-	{
-		sys_err("RefineInformation p.result_vnum == 0");
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템은 개량할 수 없습니다."));
-		return false;
-	}
-
-	if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TUNING)
-	{
-		if (bType == 0)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템은 이 방식으로는 개량할 수 없습니다."));
-			return false;
-		}
-		else
-		{
-			const LPITEM& item_scroll = GetInventoryItem(iAdditionalCell);
-			if (!item_scroll || item->GetVnum() == item_scroll->GetVnum())
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("같은 개량서를 합칠 수는 없습니다."));
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("축복의 서와 현철을 합칠 수 있습니다."));
-				return false;
-			}
-		}
-	}
-
-#if defined(__SOUL_SYSTEM__)
-	if (item->GetType() == ITEM_SOUL)
-	{
-		if (bType == REFINE_TYPE_SOUL_AWAKE || bType == REFINE_TYPE_SOUL_EVOLVE)
-		{
-			p.cost = 0;
-			p.prob = bType == REFINE_TYPE_SOUL_AWAKE ? 100 : soul_refine_prob[MINMAX(0, item->GetValue(1), SOUL_GRADE_MAX)];
-			p.material_count = 0;
-			std::memset(p.materials, 0, sizeof(p.materials));
-
-			GetDesc()->Packet(&p, sizeof(TPacketGCRefineInformation));
-
-			SetRefineMode(iAdditionalCell);
-			return true;
-		}
-	}
-#endif
-
-	CRefineManager& rm = CRefineManager::instance();
-	const TRefineTable* prt = rm.GetRefineRecipe(item->GetRefineSet());
-	if (!prt)
-	{
-		sys_err("RefineInformation NOT GET REFINE SET %d", item->GetRefineSet());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템은 개량할 수 없습니다."));
-		return false;
-	}
-
-	// REFINE_COST
-
-	// MAIN_QUEST_LV7
-	if (GetQuestFlag("main_quest_lv7.refine_chance") > 0)
-	{
-		// 일본은 제외
-		if (!item->CheckItemUseLevel(20) || item->GetType() != ITEM_WEAPON)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("무료 개량 기회는 20 이하의 무기만 가능합니다"));
-			return false;
-		}
-		p.cost = 0;
-	}
-	else
-		p.cost = ComputeRefineFee(prt->cost);
-	// END_MAIN_QUEST_LV7
-
-	const LPITEM& item_scroll = GetInventoryItem(iAdditionalCell);
-	if (item_scroll)
-	{
-		const SRefineScrollData& kScroll = GetScrollRefinePct(prt->prob, item->GetRefinedVnum(), item_scroll->GetValue(0));
-		p.prob = kScroll.bSuccessProb;
-	}
-	else
-	{
-		p.prob = prt->prob;
-
-		if (IsRefineThroughGuild())
-			p.prob += 10;
-	}
-
-	if (p.prob > 100)
-		p.prob = 100;
-
-	if (bType == REFINE_TYPE_MONEY_ONLY)
-	{
-		p.material_count = 0;
-		memset(p.materials, 0, sizeof(p.materials));
-	}
-	else
-	{
-		p.material_count = prt->material_count;
-		thecore_memcpy(&p.materials, prt->materials, sizeof(prt->materials));
-	}
-	// END_OF_REFINE_COST
-
-	GetDesc()->Packet(&p, sizeof(TPacketGCRefineInformation));
-
-	SetRefineMode(iAdditionalCell);
-	return true;
-}
-
-bool CHARACTER::RefineItem(LPITEM pkItem, LPITEM pkTarget)
-{
-	if (!CanHandleItem())
-		return false;
-
-	// HARDENING: prevent applying refine/scroll logic to fishing rods
-	if (pkTarget && pkTarget->GetType() == ITEM_ROD)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("\xc0\xcc \xbe\xc6\xc0\xcc\xc5\xdb\xc0\xba \xb0\xb3\xb7\xae\xc7\xd2 \xbc\xf6 \xbe\xf8\xbd\xc0\xb4\xcf\xb4\xd9."));
-		return false;
-	}
-
-	if (pkItem->GetSubType() == USE_TUNING)
-	{
-		// XXX 성능, 소켓 개량서는 사라졌습니다...
-		// XXX 성능개량서는 축복의 서가 되었다!
-
-		BYTE bRefineType = REFINE_TYPE_NORMAL;
-		switch (pkItem->GetValue(0))
-		{
-			case HYUNIRON_STONE:
-				bRefineType = REFINE_TYPE_HYUNIRON;
-				break;
-
-			case MUSIN_SCROLL:
-			{
-				if (pkTarget->GetRefineLevel() >= 4)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 개량서로 더 이상 개량할 수 없습니다."));
-					return false;
-				}
-
-				bRefineType = REFINE_TYPE_MUSIN;
-			}
-			break;
-
-			case MEMO_SCROLL:
-			{
-				if (pkTarget->GetRefineLevel() != pkItem->GetValue(1))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 개량서로 개량할 수 없습니다."));
-					return false;
-				}
-
-				bRefineType = REFINE_TYPE_NOT_USED1;
-			}
-			break;
-
-			case BDRAGON_SCROLL:
-			{
-				if (pkTarget->GetType() != ITEM_METIN || pkTarget->GetRefineLevel() != 4)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템으로 개량할 수 없습니다."));
-					return false;
-				}
-
-				if (pkTarget->GetRefineSet() != 702)
-					return false;
-			}
-			break;
-
-#if defined(__STONE_OF_BLESS__)
-			case BLESSING_STONE:
-			{
-				if (pkTarget->GetLevelLimit() <= 80)
-					return false;
-
-				bRefineType = REFINE_TYPE_BLESSING_STONE;
-			}
-			break;
-
-			case MALL_BLESSING_STONE:
-				bRefineType = REFINE_TYPE_BLESSING_STONE;
-				break;
-#endif
-
-#if defined(__SOUL_SYSTEM__)
-			case SOUL_AWAKE_SCROLL:
-			case SOUL_EVOLVE_SCROLL:
-			{
-				if (pkTarget->GetType() != ITEM_SOUL)
-					return false;
-
-				if (pkTarget->GetValue(0) >= SOUL_GRADE_ILUMINED)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Soul System] %s is already at the highest level.", LC_ITEM(pkTarget->GetVnum())));
-					return false;
-				}
-
-				if (pkItem->GetValue(0) == SOUL_AWAKE_SCROLL)
-					bRefineType = REFINE_TYPE_SOUL_AWAKE;
-				else if (pkItem->GetValue(0) == SOUL_EVOLVE_SCROLL)
-					bRefineType = REFINE_TYPE_SOUL_EVOLVE;
-			}
-			break;
-#endif
-
-			default:
-			{
-				if (pkTarget->GetRefineSet() == 501)
-					return false;
-
-				if (pkTarget->GetVnum() >= 28330 && pkTarget->GetVnum() <= 28343) // 영석+3
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("+3 영석은 이 아이템으로 개량할 수 없습니다"));
-					return false;
-				}
-
-				if (pkTarget->GetVnum() >= 28430 && pkTarget->GetVnum() <= 28443) // 영석+4
-				{
-					if (pkItem->GetVnum() != 71056) // 청룡의숨결
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("영석은 이 아이템으로 개량할 수 없습니다"));
-						return false;
-					}
-				}
-
-				bRefineType = REFINE_TYPE_SCROLL;
-			}
-			break;
-		}
-
-		RefineInformation(pkTarget->GetCell(), bRefineType, pkItem->GetCell());
-	}
-	else if (pkItem->GetSubType() == USE_DETACHMENT && IS_SET(pkTarget->GetFlag(), ITEM_FLAG_REFINEABLE) && pkTarget->IsRemovableSocket())
-	{
-		LogManager::instance().ItemLog(this, pkTarget, "USE_DETACHMENT", pkTarget->GetName());
-
-		bool bHasMetinStone = false;
-
-		for (int i = 0; i < METIN_SOCKET_MAX_NUM; i++)
-		{
-			long socket = pkTarget->GetSocket(i);
-			if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
-			{
-				bHasMetinStone = true;
-				break;
-			}
-		}
-
-		if (bHasMetinStone)
-		{
-			for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-			{
-				long socket = pkTarget->GetSocket(i);
-				if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
-				{
-#if defined(__GLOVE_SYSTEM__)
-					if (pkTarget->IsGlove() && socket >= 1000000)
-					{
-						DWORD dwBaseIndex = 28046;
-						dwBaseIndex += (((socket / 1000) % 10) * 100);
-						dwBaseIndex += ((socket / 100) % 10) - 1;
-
-						const TItemTable* pItemData = ITEM_MANAGER::instance().GetTable(dwBaseIndex);
-						if (pItemData == nullptr)
-							continue;
-
-						socket = dwBaseIndex;
-					}
-#endif
-					AutoGiveItem(socket);
-					//TItemTable* pTable = ITEM_MANAGER::instance().GetTable(pkTarget->GetSocket(i));
-					//pkTarget->SetSocket(i, pTable->alValues[2]);
-					// 깨진돌로 대체해준다
-					pkTarget->SetSocket(i, ITEM_BROKEN_METIN_VNUM);
-				}
-			}
-			pkItem->SetCount(pkItem->GetCount() - 1);
-			return true;
-		}
-		else
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("빼낼 수 있는 메틴석이 없습니다."));
-			return false;
-		}
-	}
-
-	return false;
-}
-
-EVENTFUNC(kill_campfire_event)
-{
-	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("kill_campfire_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPCHARACTER ch = info->ch;
-
-	if (ch == NULL) // <Factor>
-		return 0;
-
-	ch->m_pkMiningEvent = NULL;
-	M2_DESTROY_CHARACTER(ch);
-	return 0;
-}
-
-bool CHARACTER::GiveRecallItem(LPITEM item)
-{
-	int idx = GetMapIndex();
-	int iEmpireByMapIndex = -1;
-
-	if (idx < 20)
-		iEmpireByMapIndex = 1;
-	else if (idx < 40)
-		iEmpireByMapIndex = 2;
-	else if (idx < 60)
-		iEmpireByMapIndex = 3;
-	else if (idx < 10000)
-		iEmpireByMapIndex = 0;
-
-	switch (idx)
-	{
-		case 66:
-		case 216:
-		case 301:
-		case 302:
-		case 303:
-		case 304:
-			iEmpireByMapIndex = -1;
-			break;
-	}
-
-	if (iEmpireByMapIndex && GetEmpire() != iEmpireByMapIndex)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("기억해 둘 수 없는 위치 입니다."));
-		return false;
-	}
-
-	int pos;
-
-	if (item->GetCount() == 1) // 아이템이 하나라면 그냥 셋팅.
-	{
-		item->SetSocket(0, GetX());
-		item->SetSocket(1, GetY());
-	}
-	else if ((pos = GetEmptyInventory(item->GetSize())) != -1) // 그렇지 않다면 다른 인벤토리 슬롯을 찾는다.
-	{
-		LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), 1);
-		if (item2 != nullptr)
-		{
-			item2->SetSocket(0, GetX());
-			item2->SetSocket(1, GetY());
-			item2->AddToCharacter(this, TItemPos(INVENTORY, pos));
-
-			item->SetCount(item->GetCount() - 1);
-		}
-	}
-	else
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지품에 빈 공간이 없습니다."));
-		return false;
-	}
-
-	return true;
-}
-
-void CHARACTER::ProcessRecallItem(LPITEM item)
-{
-	int idx;
-
-	if ((idx = SECTREE_MANAGER::instance().GetMapIndex(item->GetSocket(0), item->GetSocket(1))) == 0)
-		return;
-
-	int iEmpireByMapIndex = -1;
-
-	if (idx < 20)
-		iEmpireByMapIndex = 1;
-	else if (idx < 40)
-		iEmpireByMapIndex = 2;
-	else if (idx < 60)
-		iEmpireByMapIndex = 3;
-	else if (idx < 10000)
-		iEmpireByMapIndex = 0;
-
-	switch (idx)
-	{
-		case 66:
-		case 216:
-			iEmpireByMapIndex = -1;
-			break;
-			// 악룡군도 일때
-		case 301:
-		case 302:
-		case 303:
-		case 304:
-			if (GetLevel() < 90)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템의 레벨 제한보다 레벨이 낮습니다."));
-				return;
-			}
-			else
-				break;
-	}
-
-	if (iEmpireByMapIndex && GetEmpire() != iEmpireByMapIndex)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("기억된 위치가 타제국에 속해 있어서 귀환할 수 없습니다."));
-		item->SetSocket(0, 0);
-		item->SetSocket(1, 0);
-	}
-	else
-	{
-		sys_log(1, "Recall: %s %d %d -> %d %d", GetName(), GetX(), GetY(), item->GetSocket(0), item->GetSocket(1));
-		WarpSet(item->GetSocket(0), item->GetSocket(1));
-		item->SetCount(item->GetCount() - 1);
-	}
-}
-
-void CHARACTER::__OpenPrivateShop()
-{
-	unsigned bodyPart = GetPart(PART_MAIN);
-	switch (bodyPart)
-	{
-	case 0:
-	case 1:
-	case 2:
-		ChatPacket(CHAT_TYPE_COMMAND, "OpenPrivateShop");
-		break;
-	default:
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("갑옷을 벗어야 개인 상점을 열 수 있습니다."));
-		break;
-	}
-}
-
-// MYSHOP_PRICE_LIST
-
-void CHARACTER::SendMyShopPriceListCmd(DWORD dwItemVnum, DWORD dwItemPrice
-#if defined(__CHEQUE_SYSTEM__)
-	, DWORD dwItemCheque
-#endif
-)
-{
-	char szLine[256];
-#if defined(__CHEQUE_SYSTEM__)
-	snprintf(szLine, sizeof(szLine), "MyShopPriceList %u %u %u", dwItemVnum, dwItemPrice, dwItemCheque);
-#else
-	snprintf(szLine, sizeof(szLine), "MyShopPriceList %u %u", dwItemVnum, dwItemPrice);
-#endif
-	ChatPacket(CHAT_TYPE_COMMAND, szLine);
-	sys_log(0, szLine);
-}
-
-//
-// DB 캐시로 부터 받은 리스트를 User 에게 전송하고 상점을 열라는 커맨드를 보낸다.
-//
-void CHARACTER::UseSilkBotaryReal(const TPacketMyshopPricelistHeader* p)
-{
-	const TItemPriceInfo* pInfo = (const TItemPriceInfo*)(p + 1);
-
-#if defined(__CHEQUE_SYSTEM__)
-	if (!p->byCount)
-		SendMyShopPriceListCmd(1, 0, 0);
-	else
-	{
-		for (int idx = 0; idx < p->byCount; idx++)
-			SendMyShopPriceListCmd(pInfo[idx].dwVnum, pInfo[idx].dwPrice, pInfo[idx].dwCheque);
-	}
-#else
-	if (!p->byCount)
-		// 가격 리스트가 없다. dummy 데이터를 넣은 커맨드를 보내준다.
-		SendMyShopPriceListCmd(1, 0);
-	else {
-		for (int idx = 0; idx < p->byCount; idx++)
-			SendMyShopPriceListCmd(pInfo[idx].dwVnum, pInfo[idx].dwPrice);
-	}
-#endif
-
-	__OpenPrivateShop();
-}
-
-//
-// 이번 접속 후 처음 상점을 Open 하는 경우 리스트를 Load 하기 위해 DB 캐시에 가격정보 리스트 요청 패킷을 보낸다.
-// 이후부터는 바로 상점을 열라는 응답을 보낸다.
-//
-void CHARACTER::UseSilkBotary(void)
-{
-	if (m_bNoOpenedShop)
-	{
-		DWORD dwPlayerID = GetPlayerID();
-		db_clientdesc->DBPacket(HEADER_GD_MYSHOP_PRICELIST_REQ, GetDesc()->GetHandle(), &dwPlayerID, sizeof(DWORD));
-		m_bNoOpenedShop = false;
-	}
-	else
-	{
-		__OpenPrivateShop();
-	}
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-int CalculateConsume(LPCHARACTER ch)
-{
-	static const int WARP_NEED_LIFE_PERCENT = 30;
-	static const int WARP_MIN_LIFE_PERCENT = 10;
-	// CONSUME_LIFE_WHEN_USE_WARP_ITEM
-	int consumeLife = 0;
-	{
-		// CheckNeedLifeForWarp
-		const int curLife = ch->GetHP();
-		const int needPercent = WARP_NEED_LIFE_PERCENT;
-		const int needLife = ch->GetMaxHP() * needPercent / 100;
-		if (curLife < needLife)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("남은 생명력 양이 모자라 사용할 수 없습니다."));
-			return -1;
-		}
-
-		consumeLife = needLife;
-
-		// CheckMinLifeForWarp: 독에 의해서 죽으면 안되므로 생명력 최소량는 남겨준다
-		const int minPercent = WARP_MIN_LIFE_PERCENT;
-		const int minLife = ch->GetMaxHP() * minPercent / 100;
-		if (curLife - needLife < minLife)
-			consumeLife = curLife - minLife;
-
-		if (consumeLife < 0)
-			consumeLife = 0;
-	}
-	// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
-	return consumeLife;
-}
-
-int CalculateConsumeSP(LPCHARACTER lpChar)
-{
-	static const int NEED_WARP_SP_PERCENT = 30;
-
-	const int curSP = lpChar->GetSP();
-	const int needSP = lpChar->GetMaxSP() * NEED_WARP_SP_PERCENT / 100;
-
-	if (curSP < needSP)
-	{
-		lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("남은 정신력 양이 모자라 사용할 수 없습니다."));
-		return -1;
-	}
-
-	return needSP;
-}
-
-bool CHARACTER::UseItemEx(LPITEM item, TItemPos DestCell)
-{
-	int iLimitRealtimeStartFirstUseFlagIndex = -1;
-	int iLimitTimerBasedOnWearFlagIndex = -1;
-
-	WORD wDestCell = DestCell.cell;
-	BYTE bDestInven = DestCell.window_type;
-
-	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-	{
-		long limitValue = item->GetProto()->aLimits[i].lValue;
-
-		switch (item->GetProto()->aLimits[i].bType)
-		{
-			case LIMIT_LEVEL:
-			{
-				if (GetLevel() < limitValue)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템의 레벨 제한보다 레벨이 낮습니다."));
-					return false;
-				}
-			}
-			break;
-
-#if defined(__CONQUEROR_LEVEL__)
-			case LIMIT_NEWWORLD_LEVEL:
-			{
-				if (GetConquerorLevel() < limitValue)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템의 레벨 제한보다 레벨이 낮습니다."));
-					return false;
-				}
-			}
-			break;
-#endif
-
-			case LIMIT_REAL_TIME_START_FIRST_USE:
-				iLimitRealtimeStartFirstUseFlagIndex = i;
-				break;
-
-			case LIMIT_TIMER_BASED_ON_WEAR:
-				iLimitTimerBasedOnWearFlagIndex = i;
-				break;
-		}
-	}
-
-	if (test_server)
-	{
-		sys_log(0, "USE_ITEM %s, Inven %d, Cell %d, ItemType %d, SubType %d", item->GetName(), bDestInven, wDestCell, item->GetType(), item->GetSubType());
-	}
-
-	if (CArenaManager::instance().IsLimitedItem(GetMapIndex(), item->GetVnum()))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 중에는 이용할 수 없는 물품입니다."));
-		return false;
-	}
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
-		iLimitRealtimeStartFirstUseFlagIndex = -1;
-#endif
-
-	// 아이템 최초 사용 이후부터는 사용하지 않아도 시간이 차감되는 방식 처리.
-	if (-1 != iLimitRealtimeStartFirstUseFlagIndex)
-	{
-		// 한 번이라도 사용한 아이템인지 여부는 Socket1을 보고 판단한다. (Socket1에 사용횟수 기록)
-		if (0 == item->GetSocket(1))
-		{
-			// 사용가능시간은 Default 값으로 Limit Value 값을 사용하되, Socket0에 값이 있으면 그 값을 사용하도록 한다. (단위는 초)
-			long duration = (0 != item->GetSocket(0)) ? item->GetSocket(0) : item->GetProto()->aLimits[iLimitRealtimeStartFirstUseFlagIndex].lValue;
-
-			if (0 == duration)
-				duration = 60 * 60 * 24 * 7;
-
-			item->SetSocket(0, time(0) + duration);
-			item->StartRealTimeExpireEvent();
-		}
-
-		if (false == item->IsEquipped())
-			item->SetSocket(1, item->GetSocket(1) + 1);
-	}
-
-#if defined(__MAILBOX__)
-	if (item->GetVnum() == ITEM_MOBILE_MAILBOX)
-	{
-		CMailBox::Open(this);
-		return true;
-	}
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	if (item->GetVnum() == ITEM_EXTEND_INVEN_TICKET ||
-		item->GetVnum() == ITEM_EXTEND_INVEN_TICKET_MALL)
-	{
-		ExtendInvenRequest();
-		return true;
-	}
-#endif
-
-	switch (item->GetType())
-	{
-#ifdef __GROWTH_PET_SYSTEM__
-		case ITEM_PET:
-			{
-				switch (item->GetSubType())
-				{
-					case PET_PAY:
-					{
-						if (GetArena() != NULL || IsObserverMode() == true)
-						{
-							if (item->GetVnum() == 50051 || item->GetVnum() == 50052 || item->GetVnum() == 50053)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 중에는 이용할 수 없는 물품입니다."));
-								return false;
-							}
-						}
-
-						if (!IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE) || item->GetSubType() == PET_PAY)
-						{
-							if (item->GetSIGVnum() == 0)
-							{
-								quest::CQuestManager::instance().UseItem(GetPlayerID(), item, false);
-							}
-							else
-							{
-								quest::CQuestManager::instance().SIGUse(GetPlayerID(), item->GetSIGVnum(), item, false);
-							}
-						}
-						break;
-					}
-					
-					case PET_UPBRINGING:
-					{
-						LPGROWTH_PET pPet = GetGrowthPet(item->GetSocket(2));
-						if (pPet)
-						{
-							if (m_activeGrowthPet && m_activeGrowthPet->GetPetID() == pPet->GetPetID())
-							{
-								m_activeGrowthPet->Unsummon();
-								m_activeGrowthPet = nullptr;
-								return true;
-							}
-							else if (m_activeGrowthPet)
-								m_activeGrowthPet->Unsummon();
-
-							m_activeGrowthPet = pPet->Summon(item);
-						}
-					} break;
-
-					case PET_FEEDSTUFF:
-					{
-						LPITEM item2;
-
-						if (!GetItem(DestCell) || !(item2 = GetItem(DestCell)))
-							return false;
-
-						if (item2->GetType() != ITEM_PET && item2->GetSubType() != PET_UPBRINGING)
-							return false;
-
-						LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
-						if (!pPet)
-							return false;
-
-						if (item2->GetSocket(0) < get_global_time())
-						{
-							pPet->Revive(item2, PET_REVIVE_TYPE_NORMAL);
-							ITEM_MANAGER::instance().RemoveItem(item);
-						}
-						else
-						{
-							pPet->RewardFood(item, PET_FEED_TYPE_FULL);
-						}
-
-					} break;
-
-					case PET_BAG:
-					{
-						LPITEM item2 = GetItem(DestCell);
-						
-						if (item2)
-						{
-							if (item2->GetType() != ITEM_PET)
-								return false;
-
-							if (item2->GetSubType() != PET_UPBRINGING && item2->GetSubType() != PET_BAG)
-								return false;
-
-							switch (item2->GetSubType())
-							{
-								case PET_UPBRINGING:
-								{
-									LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
-									if (!pPet)
-										return false;
-
-									pPet->SetState(STATE_BAG);
-									pPet->SetSummonItem(nullptr);
-									pPet->Save();
-
-									time_t currentTime = time(0);
-									item->SetSocket(0, currentTime + item->GetLimitValue(0));
-									item->SetSocket(1, time(0));
-									item->SetSocket(2, pPet->GetPetID());
-									item->SetSocket(3, pPet->GetPetType());
-									item->StartRealTimeExpireEvent();
-
-									ITEM_MANAGER::instance().RemoveItem(item2, "REMOVE (UPBRINGING-BAG TRANSFER)");
-								} break;
-
-								case PET_BAG:
-								{
-									LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
-									if (!pPet)
-										return false;
-
-									/* Pet age equals to difference between birthday and current time minus time spent in bag */
-
-									// Time spent in bag: current time - the time pet was put into the bag
-									time_t currentTime = time(0);
-									DWORD dwBagTime = currentTime - (item2->GetSocket(0) - item2->GetLimitValue(0));
-									DWORD dwPetAge = currentTime - pPet->GetPetPoint(POINT_UPBRINGING_BIRTHDAY) - dwBagTime;
-
-									// Shift back pet's birthday from current time & update real time event
-									pPet->ChangePetPoint(POINT_UPBRINGING_BIRTHDAY, currentTime - dwPetAge, true);
-									pPet->Save();
-
-									item2->SetSocket(0, currentTime + item2->GetLimitValue(0));
-									item2->StartRealTimeExpireEvent();
-									item->SetSocket(3, pPet->GetPetType());
-
-									ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (BAG-BAG TRANSFER)");
-								} break;
-							}
-						}
-						else
-						{
-							if (!item->GetSocket(2))
-								return false;
-
-							LPGROWTH_PET pPet = GetGrowthPet(item->GetSocket(2));
-							if (!pPet)
-								return false;
-
-							time_t currentTime = time(0);
-							DWORD dwBagTime = item->GetSocket(0) - item->GetLimitValue(0);
-							DWORD dwPetAge = currentTime - pPet->GetPetPoint(POINT_UPBRINGING_BIRTHDAY) - (currentTime - dwBagTime);
-							DWORD dwPetDuration = currentTime + pPet->GetPetPoint(POINT_UPBRINGING_MAX_DURATION);
-							LPITEM pUpBringingItem = AutoGiveItem(pPet->GetSummonItemVnum());
-
-							// Copy stats from old pet to a new table
-							TGrowthPet petTable;
-							pPet->CreateGrowthPetProto(&petTable);
-							petTable.dwID = pUpBringingItem->GetID();
-							petTable.lBirthday = currentTime - dwPetAge;
-							petTable.lEndTime = dwPetDuration;
-							petTable.bState = STATE_UPBRINGING;
-
-							// Create a new pet and copy stats from table to it
-							LPGROWTH_PET pNewPet = CGrowthPetManager::Instance().CreateGrowthPet(this, pUpBringingItem->GetID());
-							pNewPet->SetGrowthPetProto(&petTable);
-
-							// Sync upbringing sockets with the new pet
-							pUpBringingItem->SetSocket(0, dwPetDuration);
-							pUpBringingItem->SetSocket(1, petTable.lMaxTime);
-							pUpBringingItem->SetSocket(2, pUpBringingItem->GetID());
-							pUpBringingItem->SetSocket(3, item->GetSocket(3));
-
-							pPet->SetSummonItem(pUpBringingItem);
-							pPet->Save();
-
-							SetGrowthPet(pNewPet);
-
-							CGrowthPetManager::Instance().DeleteGrowthPet(item->GetSocket(2), true);
-							ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (BAG-UPBRINGING TRANSFER)");
-						}
-					} break;
-				}
-
-			} break;
-#endif
-		case ITEM_HAIR:
-			return ItemProcess_Hair(item, wDestCell);
-
-		case ITEM_POLYMORPH:
-			return ItemProcess_Polymorph(item);
-
-		case ITEM_QUEST:
-		{
-			if (GetArena() != NULL || IsObserverMode() == true)
-			{
-				if (item->GetVnum() == ITEM_VNUM_HORSE_PICTURE || item->GetVnum() == ITEM_VNUM_ARMED_HORSE_BOOK || item->GetVnum() == ITEM_VNUM_MILITARY_HORSE_BOOK)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 중에는 이용할 수 없는 물품입니다."));
-					return false;
-				}
-			}
-
-			if (!IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE))
-			{
-				if (item->GetSIGVnum() == 0)
-				{
-					quest::CQuestManager::instance().UseItem(GetPlayerID(), item, false);
-				}
-				else
-				{
-					quest::CQuestManager::instance().SIGUse(GetPlayerID(), item->GetSIGVnum(), item, false);
-				}
-			}
-		}
-		break;
-
-		case ITEM_CAMPFIRE:
-		{
-			float fx, fy;
-			GetDeltaByDegree(GetRotation(), 100.0f, &fx, &fy);
-
-			LPSECTREE tree = SECTREE_MANAGER::instance().Get(GetMapIndex(), (long)(GetX() + fx), (long)(GetY() + fy));
-
-			if (!tree)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("모닥불을 피울 수 없는 지점입니다."));
-				return false;
-			}
-
-			if (tree->IsAttr((long)(GetX() + fx), (long)(GetY() + fy), ATTR_WATER))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("물 속에 모닥불을 피울 수 없습니다."));
-				return false;
-			}
-
-			LPCHARACTER campfire = CHARACTER_MANAGER::instance().SpawnMob(fishing::CAMPFIRE_MOB, GetMapIndex(), (long)(GetX() + fx), (long)(GetY() + fy), 0, false, number(0, 359));
-
-			char_event_info* info = AllocEventInfo<char_event_info>();
-
-			info->ch = campfire;
-
-			campfire->m_pkMiningEvent = event_create(kill_campfire_event, info, PASSES_PER_SEC(40));
-
-			item->SetCount(item->GetCount() - 1);
-		}
-		break;
-
-		case ITEM_UNIQUE:
-		{
-			switch (item->GetSubType())
-			{
-				case USE_ABILITY_UP:
-				{
-					if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-						return false;
-					}
-
-					switch (item->GetValue(0))
-					{
-						case APPLY_MOV_SPEED:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MOV_SPEED,
-								item->GetValue(2), AFF_MOV_SPEED_POTION, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_ATT_SPEED:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATT_SPEED,
-								item->GetValue(2), AFF_ATT_SPEED_POTION, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_STR:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ST,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_DEX:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_DX,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_CON:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_HT,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_INT:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_IQ,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_CAST_SPEED:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_CASTING_SPEED,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_RESIST_MAGIC:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_MAGIC,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_ATT_GRADE_BONUS:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATT_GRADE_BONUS,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_DEF_GRADE_BONUS:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_DEF_GRADE_BONUS,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-					}
-
-					if (GetDungeon())
-						GetDungeon()->UsePotion(this);
-
-					if (GetWarMap())
-						GetWarMap()->UsePotion(this, item);
-
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case UNIQUE_BUNDLE:
-				{
-					if (IsRiding())
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this bundle whilst riding."));
-						return false;
-					}
-
-					if (GetWear(ARMOR_BODY))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("갑옷을 벗어야 개인 상점을 열 수 있습니다."));
-						return false;
-					}
-
-					switch (item->GetVnum())
-					{
-						case 71049: // 비단보따리
-						{
-							if (LC_IsYMIR() == true || LC_IsKorea() == true)
-							{
-								if (IS_BOTARYABLE_ZONE(GetMapIndex()) == true)
-								{
-									UseSilkBotary();
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("개인 상점을 열 수 없는 지역입니다"));
-								}
-							}
-							else
-							{
-								UseSilkBotary();
-							}
-						}
-						break;
-
-#if defined(__MYSHOP_DECO__)
-						case ITEM_KASHMIR_BUNDLE:
-							ChatPacket(CHAT_TYPE_COMMAND, "OpenMyShopDecoWnd");
-							break;
-#endif
-					}
-				}
-				break;
-
-				default:
-				{
-					if (!item->IsEquipped())
-						EquipItem(item);
-					else
-						UnequipItem(item);
-				}
-				break;
-			}
-		}
-		break;
-
-		case ITEM_COSTUME:
-		case ITEM_WEAPON:
-		case ITEM_ARMOR:
-		case ITEM_ROD:
-		case ITEM_RING: // 신규 반지 아이템
-		case ITEM_BELT: // 신규 벨트 아이템
-		case ITEM_PICK: // MINING
-		{
-			if (!item->IsEquipped())
-				EquipItem(item);
-			else
-				UnequipItem(item);
-		}
-		break;
-
-		// 착용하지 않은 용혼석은 사용할 수 없다.
-		// 정상적인 클라라면, 용혼석에 관하여 item use 패킷을 보낼 수 없다.
-		// 용혼석 착용은 item move 패킷으로 한다.
-		// 착용한 용혼석은 추출한다.
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case ITEM_DS:
-		{
-			if (!item->IsEquipped())
-				return false;
-
-			return DSManager::instance().PullOut(this, NPOS, item);
-		}
-
-		case ITEM_SPECIAL_DS:
-		{
-			if (!item->IsEquipped())
-				EquipItem(item);
-			else
-				UnequipItem(item);
-		}
-		break;
-#endif
-
-		case ITEM_FISH:
-		{
-			if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 중에는 이용할 수 없는 물품입니다."));
-				return false;
-			}
-
-			if (item->GetSubType() == FISH_ALIVE)
-				fishing::UseFish(this, item);
-		}
-		break;
-
-		case ITEM_TREASURE_BOX:
-		{
-			return false;
-			//ChatPacket(CHAT_TYPE_TALKING, LC_STRING("열쇠로 잠겨 있어서 열리지 않는것 같다. 열쇠를 구해보자."));
-		}
-		break;
-
-		case ITEM_TREASURE_KEY:
-		{
-			LPITEM item2;
-
-			if (!GetItem(DestCell) || !(item2 = GetItem(DestCell)))
-				return false;
-
-			if (item2->IsExchanging())
-				return false;
-
-			if (item2->GetType() != ITEM_TREASURE_BOX)
-			{
-				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("열쇠로 여는 물건이 아닌것 같다."));
-				return false;
-			}
-
-			if (item->GetValue(0) == item2->GetValue(0))
-			{
-				//ChatPacket(CHAT_TYPE_TALKING, LC_STRING("열쇠는 맞으나 아이템 주는 부분 구현이 안되었습니다."));
-
-				if (GiveItemFromSpecialItemGroup(item2->GetVnum()))
-				{
-					item->SetCount(item->GetCount() - 1);
-					item2->SetCount(item2->GetCount() - 1);
-				}
-				else
-				{
-					ChatPacket(CHAT_TYPE_TALKING, LC_STRING("열쇠가 맞지 않는 것 같다."));
-					return false;
-				}
-			}
-			else
-			{
-				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("열쇠가 맞지 않는 것 같다."));
-				return false;
-			}
-		}
-		break;
-
-		case ITEM_GIFTBOX:
-		{
-			DWORD dwBoxVnum = item->GetVnum();
-
-			if (dwBoxVnum == 50033 && LC_IsYMIR()) // 알수없는 상자
-			{
-				if (GetLevel() < 15)
-				{
-					ChatPacket(CHAT_TYPE_INFO, "15레벨 이하에서는 사용할 수 없습니다.");
-					return false;
-				}
-			}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			if ((dwBoxVnum > 51500 && dwBoxVnum < 52000) || (dwBoxVnum >= 50255 && dwBoxVnum <= 50260)) // 용혼원석들
-			{
-				if (!(this->DragonSoul_IsQualified()))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("먼저 용혼석 퀘스트를 완료하셔야 합니다."));
-					return false;
-				}
-			}
-#endif
-
-			if (!GiveItemFromSpecialItemGroup(dwBoxVnum))
-			{
-				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("아무것도 얻을 수 없었습니다."));
-				return false;
-			}
-
-			item->SetCount(item->GetCount() - 1);
-		}
-		break;
-
-		case ITEM_SKILLFORGET:
-		{
-			if (!item->GetSocket(0))
-			{
-				ITEM_MANAGER::instance().RemoveItem(item);
-				return false;
-			}
-
-			DWORD dwVnum = item->GetSocket(0);
-
-			if (SkillLevelDown(dwVnum))
-			{
-				ITEM_MANAGER::instance().RemoveItem(item);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("스킬 레벨을 내리는데 성공하였습니다."));
-			}
-			else
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("스킬 레벨을 내릴 수 없습니다."));
-		}
-		break;
-
-		case ITEM_SKILLBOOK:
-		{
-			if (IsPolymorphed())
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("변신중에는 책을 읽을수 없습니다."));
-				return false;
-			}
-
-			DWORD dwVnum = 0;
-
-			if (item->GetVnum() == ITEM_SKILLBOOK_VNUM)
-			{
-				dwVnum = item->GetSocket(0);
-			}
-			else
-			{
-				// 새로운 수련서는 value 0 에 스킬 번호가 있으므로 그것을 사용.
-				dwVnum = item->GetValue(0);
-			}
-
-			if (0 == dwVnum)
-			{
-				ITEM_MANAGER::instance().RemoveItem(item);
-				return false;
-			}
-
-			if (true == LearnSkillByBook(dwVnum))
-			{
-				item->SetCount(item->GetCount() - 1);
-
-				int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-
-				if (distribution_test_server)
-					iReadDelay /= 3;
-
-				// 한국 본섭의 경우에는 시간을 24시간 고정
-				if (LC_IsKorea())
-					iReadDelay = 86400;
-
-				SetSkillNextReadTime(dwVnum, get_global_time() + iReadDelay);
-			}
-		}
-		break;
-
-		case ITEM_USE:
-		{
-			if (item->GetVnum() > 50800 && item->GetVnum() <= 50820)
-			{
-				if (test_server)
-					sys_log(0, "ADD addtional effect : vnum(%d) subtype(%d)", item->GetOriginalVnum(), item->GetSubType());
-
-				int affect_type = AFFECT_EXP_BONUS_EURO_FREE;
-				int apply_type = aApplyInfo[item->GetValue(0)].wPointType;
-				int apply_value = item->GetValue(2);
-				int apply_duration = item->GetValue(1);
-
-				switch (item->GetSubType())
-				{
-					case USE_ABILITY_UP:
-					{
-						if (FindAffect(affect_type, apply_type))
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-							return false;
-						}
-
-						if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-							return false;
-						}
-
-						switch (item->GetValue(0))
-						{
-							case APPLY_MOV_SPEED:
-							{
-								AddAffect(affect_type, apply_type, apply_value, AFF_MOV_SPEED_POTION, apply_duration, 0, true, true);
-								break;
-							}
-
-							case APPLY_ATT_SPEED:
-							{
-								AddAffect(affect_type, apply_type, apply_value, AFF_ATT_SPEED_POTION, apply_duration, 0, true, true);
-								break;
-							}
-
-							case APPLY_STR:
-							case APPLY_DEX:
-							case APPLY_CON:
-							case APPLY_INT:
-							case APPLY_CAST_SPEED:
-							case APPLY_CRITICAL_PCT:
-							case APPLY_PENETRATE_PCT:
-							case APPLY_RESIST_MAGIC:
-							case APPLY_ATT_GRADE_BONUS:
-							case APPLY_DEF_GRADE_BONUS:
-#if defined(__CONQUEROR_LEVEL__)
-							case APPLY_SUNGMA_STR:
-							case APPLY_SUNGMA_HP:
-							case APPLY_SUNGMA_MOVE:
-							case APPLY_SUNGMA_IMMUNE:
-#endif
-							{
-								AddAffect(affect_type, apply_type, apply_value, 0, apply_duration, 0, true, true);
-								break;
-							}
-
-						}
-
-						if (GetDungeon())
-							GetDungeon()->UsePotion(this);
-
-						if (GetWarMap())
-							GetWarMap()->UsePotion(this, item);
-
-						item->SetCount(item->GetCount() - 1);
-					}
-					break;
-
-					case USE_AFFECT:
-					{
-						if (FindAffect(AFFECT_EXP_BONUS_EURO_FREE, aApplyInfo[item->GetValue(1)].wPointType))
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-						}
-						else
-						{
-							AddAffect(AFFECT_EXP_BONUS_EURO_FREE, aApplyInfo[item->GetValue(1)].wPointType, item->GetValue(2), 0, item->GetValue(3), 0, false, true);
-							item->SetCount(item->GetCount() - 1);
-						}
-					}
-					break;
-
-					case USE_POTION_NODELAY:
-					{
-						if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-						{
-							if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련장에서 사용하실 수 없습니다."));
-								return false;
-							}
-
-							switch (item->GetVnum())
-							{
-								case 70020: // Peach Flower Wine
-								case 71018: // Blessing of Life
-								case 71019: // Blessing of Magic
-								case 71020: // Blessing of the Dragon
-								{
-									if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
-									{
-										if (m_nPotionLimit <= 0)
-										{
-											ChatPacket(CHAT_TYPE_INFO, LC_STRING("사용 제한량을 초과하였습니다."));
-											return false;
-										}
-									}
-								}
-								break;
-
-								default:
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련장에서 사용하실 수 없습니다."));
-									return false;
-								}
-							}
-						}
-
-						bool bUsed = false;
-
-						if (item->GetValue(0) != 0) // HP 절대값 회복
-						{
-							if (GetHP() < GetMaxHP())
-							{
-								PointChange(POINT_HP, item->GetValue(0) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
-								EffectPacket(SE_HPUP_RED);
-								bUsed = true;
-							}
-						}
-
-						if (item->GetValue(1) != 0) // SP 절대값 회복
-						{
-							if (GetSP() < GetMaxSP())
-							{
-								PointChange(POINT_SP, item->GetValue(1) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
-								EffectPacket(SE_SPUP_BLUE);
-								bUsed = true;
-							}
-						}
-
-						if (item->GetValue(3) != 0) // HP % 회복
-						{
-							if (GetHP() < GetMaxHP())
-							{
-								PointChange(POINT_HP, item->GetValue(3) * GetMaxHP() / 100);
-								EffectPacket(SE_HPUP_RED);
-								bUsed = true;
-							}
-						}
-
-						if (item->GetValue(4) != 0) // SP % 회복
-						{
-							if (GetSP() < GetMaxSP())
-							{
-								PointChange(POINT_SP, item->GetValue(4) * GetMaxSP() / 100);
-								EffectPacket(SE_SPUP_BLUE);
-								bUsed = true;
-							}
-						}
-
-						if (bUsed)
-						{
-							if (item->GetVnum() == 50085 || item->GetVnum() == 50086)
-							{
-								if (test_server)
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("월병 또는 종자 를 사용하였습니다"));
-
-								SetUseSeedOrMoonBottleTime();
-							}
-
-							if (GetDungeon())
-								GetDungeon()->UsePotion(this);
-
-							if (GetWarMap())
-								GetWarMap()->UsePotion(this, item);
-
-							m_nPotionLimit--;
-
-							// RESTRICT_USE_SEED_OR_MOONBOTTLE
-							item->SetCount(item->GetCount() - 1);
-							// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
-						}
-					}
-					break;
-				}
-
-				return true;
-			}
-
-			if (item->GetVnum() >= 27863 && item->GetVnum() <= 27883)
-			{
-				if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 중에는 이용할 수 없는 물품입니다."));
-					return false;
-				}
-			}
-
-			if (test_server)
-			{
-				sys_log(0, "USE_ITEM %s Type %d SubType %d vnum %d", item->GetName(), item->GetType(), item->GetSubType(), item->GetOriginalVnum());
-			}
-
-			switch (item->GetSubType())
-			{
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				case USE_ELEMENT_UPGRADE:
-				case USE_ELEMENT_DOWNGRADE:
-				case USE_ELEMENT_CHANGE:
-					RefineElementInformation(item, DestCell);
-					break;
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-				case USE_EMOTION_PACK:
-				{
-					AddEmote();
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-#endif
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-				case USE_TIME_CHARGE_PER:
-				{
-					LPITEM pDestItem = GetItem(DestCell);
-					if (NULL == pDestItem)
-						return false;
-
-					// 우선 용혼석에 관해서만 하도록 한다.
-					if (pDestItem->IsDragonSoul())
-					{
-						int ret;
-						char buf[128];
-						if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
-						{
-							ret = pDestItem->GiveMoreTime_Per((float)item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
-						}
-						else
-						{
-							ret = pDestItem->GiveMoreTime_Per((float)item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-						}
-
-						if (ret > 0)
-						{
-#if defined(__DS_SET__)
-							DragonSoul_SetBonus();
-#endif
-
-							if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
-							{
-								sprintf(buf, "Inc %ds by item{VN:%d SOC%d:%d}", ret, item->GetVnum(), ITEM_SOCKET_CHARGING_AMOUNT_IDX, item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
-							}
-							else
-							{
-								sprintf(buf, "Inc %ds by item{VN:%d VAL%d:%d}", ret, item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-							}
-
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d초 만큼 충전되었습니다.", ret));
-							item->SetCount(item->GetCount() - 1);
-							LogManager::instance().ItemLog(this, item, "DS_CHARGING_SUCCESS", buf);
-
-							return true;
-						}
-						else
-						{
-							if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
-							{
-								sprintf(buf, "No change by item{VN:%d SOC%d:%d}", item->GetVnum(), ITEM_SOCKET_CHARGING_AMOUNT_IDX, item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
-							}
-							else
-							{
-								sprintf(buf, "No change by item{VN:%d VAL%d:%d}", item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-							}
-
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("충전할 수 없습니다."));
-							LogManager::instance().ItemLog(this, item, "DS_CHARGING_FAILED", buf);
-							return false;
-						}
-					}
-					else
-						return false;
-				}
-				break;
-
-				case USE_TIME_CHARGE_FIX:
-				{
-					LPITEM pDestItem = GetItem(DestCell);
-					if (NULL == pDestItem)
-						return false;
-
-					// 우선 용혼석에 관해서만 하도록 한다.
-					if (pDestItem->IsDragonSoul())
-					{
-						int ret = pDestItem->GiveMoreTime_Fix(item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-						char buf[128];
-						if (ret)
-						{
-#if defined(__DS_SET__)
-							DragonSoul_SetBonus();
-#endif
-
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d초 만큼 충전되었습니다.", ret));
-
-							sprintf(buf, "Increase %ds by item{VN:%d VAL%d:%d}", ret, item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-							LogManager::instance().ItemLog(this, item, "DS_CHARGING_SUCCESS", buf);
-							item->SetCount(item->GetCount() - 1);
-
-							return true;
-						}
-						else
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("충전할 수 없습니다."));
-							sprintf(buf, "No change by item{VN:%d VAL%d:%d}", item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-							LogManager::instance().ItemLog(this, item, "DS_CHARGING_FAILED", buf);
-							return false;
-						}
-					}
-					else
-						return false;
-				}
-				break;
-#endif
-
-				case USE_SPECIAL:
-				{
-					switch (item->GetVnum())
-					{
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-						case ITEM_GUILD_DRAGONLAIR_POTION:
-						{
-							if (GetGuildDragonLair() == NULL)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
-								return false;
-							}
-
-							if (FindAffect(AFFECT_RED_DRAGONLAIR_BUFF))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-								return false;
-							}
-							else
-							{
-								const long duration = item->GetValue(1);
-
-								AddAffect(AFFECT_RED_DRAGONLAIR_BUFF, POINT_SKILL_DEFEND_BONUS, 15, AFF_NONE, duration, 0, true, true);
-								AddAffect(AFFECT_RED_DRAGONLAIR_BUFF, POINT_NORMAL_HIT_DEFEND_BONUS, 15, AFF_NONE, duration, 0, true, true);
-
-								item->SetCount(item->GetCount() - 1);
-							}
-						}
-						break;
-#endif
-
-#if defined(__ELEMENTAL_DUNGEON__)
-						case ITEM_PRIMAL_FORCE_MEDAL:
-						{
-							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
-								return false;
-							}
-
-							CAffect* pAffect = FindAffect(AFFECT_PROTECTION_OF_ELEMENTAL);
-							if (pAffect)
-							{
-								// NOTE : Check if adding another 600 seconds (10 minutes) would exceed 3600 seconds (60 minutes).
-								const long lDuration = pAffect->lDuration;
-								if (lDuration + 600 > 3600)
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that any more."));
-									return false;
-								}
-
-								AddAffect(AFFECT_PROTECTION_OF_ELEMENTAL, APPLY_NONE, 0, AFF_NONE, lDuration + 600, 0, true);
-							}
-							else
-								AddAffect(AFFECT_PROTECTION_OF_ELEMENTAL, APPLY_NONE, 0, AFF_NONE, 600, 0, true);
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_ELEMENTAL_DEFENSE_POTION:
-						{
-							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
-								return false;
-							}
-
-							const long duration = item->GetValue(1);
-							static const std::unordered_map<POINT_TYPE, POINT_VALUE> map_affect = {
-								{ APPLY_MELEE_MAGIC_ATTBONUS_PER, 5 },
-								{ APPLY_RESIST_FIRE, 10 },
-								{ APPLY_RESIST_ELEC, 10 },
-								{ APPLY_RESIST_ICE, 10 },
-								{ APPLY_RESIST_EARTH, 10 },
-								{ APPLY_RESIST_DARK, 10 },
-							};
-							for (const auto& it : map_affect)
-								AddAffect(AFFECT_POTION_OF_ELEMENTAL, it.first, it.second, AFF_NONE, duration, 0, true, true);
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_PRIMAL_FORCE_RING:
-						case ITEM_PRIMAL_FORCE_RING_MALL:
-						{
-							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
-								return false;
-							}
-
-							if (number(0, 100) < item->GetValue(0))
-							{
-								PIXEL_POSITION WarpPos;
-								if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(MAP_ELEMENTAL_04, GetEmpire(), WarpPos))
-									WarpSet(WarpPos.x, WarpPos.y);
-								else
-									sys_err("CHARACTER::UseItem : cannot find spawn position (name %s, %d x %d)", GetName(), GetX(), GetY());
-							}
-							else
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Teleportation to the Plateau of Primal Forces has failed."));
-							
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-#if defined(__MINI_GAME_RUMI__) && defined(__OKEY_EVENT_FLAG_RENEWAL__)
-						case ITEM_VNUM_RUMI_CARD_PIECE:
-						{
-							if (CMiniGameRumi::UpdateQuestFlag(this))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_VNUM_RUMI_CARD_PACK:
-						{
-							const WORD wCardCount = GetQuestFlag("minigame_rumi.card_count");
-							if (wCardCount < CMiniGameRumi::RUMI_CARD_COUNT_MAX)
-							{
-								SetQuestFlag("minigame_rumi.card_count", wCardCount + 1);
-								CMiniGameRumi::RequestQuestFlag(this, RUMI_GC_SUBHEADER_SET_CARD_FLAG);
-
-								item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								CMiniGameRumi::RequestQuestFlag(this, RUMI_GC_SUBHEADER_NO_MORE_GAIN);
-							}
-						}
-						break;
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__) && defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-						case ITEM_VNUM_YUT_PIECE:
-						{
-							if (CMiniGameYutnori::UpdateQuestFlag(this))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_VNUM_YUT_BOARD:
-						{
-							const WORD wYutBoardCount = GetQuestFlag("minigame_yutnori.board_count");
-							if (wYutBoardCount < CMiniGameYutnori::YUTNORI_BOARD_COUNT_MAX)
-							{
-								SetQuestFlag("minigame_yutnori.board_count", wYutBoardCount + 1);
-								CMiniGameYutnori::RequestQuestFlag(this, YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG);
-
-								item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								CMiniGameYutnori::RequestQuestFlag(this, YUTNORI_GC_SUBHEADER_NO_MORE_GAIN);
-							}
-						}
-						break;
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__) && defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
-						case ITEM_VNUM_CATCH_KING_PIECE:
-						{
-							if (CMiniGameCatchKing::UpdateQuestFlag(this))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_VNUM_CATCH_KING_PACK:
-						{
-							const WORD wPackCount = GetQuestFlag("minigame_catchking.pack_count");
-							if (wPackCount < CMiniGameCatchKing::CATCH_KING_PACK_COUNT_MAX)
-							{
-								SetQuestFlag("minigame_catchking.pack_count", wPackCount + 1);
-								CMiniGameCatchKing::RequestQuestFlag(this, CATCHKING_GC_SET_CARD_FLAG);
-
-								item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								CMiniGameCatchKing::RequestQuestFlag(this, CATCHKING_GC_NO_MORE_GAIN);
-							}
-						}
-						break;
-#endif
-
-#if defined(__EASTER_EVENT__)
-						case ITEM_MAGIC_EASTER_EGG:
-						{
-							int nMaxUse = 3;
-							int nNextUseTime = 1800;
-
-							int nUseTime = get_global_time() - item->GetSocket(1);
-							int nUseCount = item->GetSocket(0);
-
-							if (nUseTime >= nNextUseTime)
-							{
-								if (GiveItemFromSpecialItemGroup(ITEM_MAGIC_EASTER_EGG))
-								{
-									item->SetSocket(1, get_global_time());
-									if (nUseCount >= (nMaxUse - 1))
-										item->SetCount(item->GetCount() - 1);
-									else
-										item->SetSocket(0, nUseCount + 1);
-
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Total %d: You can still unpack %d.", nMaxUse, (nMaxUse - 1) - nUseCount));
-								}
-								else
-									ChatPacket(CHAT_TYPE_TALKING, LC_STRING("아무것도 얻을 수 없었습니다."));
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unpack the next gift in %d minutes.", 31 - nUseTime / 60));
-							}
-						}
-						break;
-#endif
-
-#if defined(__GEM_CONVERTER__)
-						case ITEM_VNUM_GEM_CONVERTER:
-						{
-							LPITEM pTargetItem;
-							if (!IsValidItemPosition(DestCell) || !(pTargetItem = GetItem(DestCell)))
-								return false;
-
-							if (pTargetItem->GetVnum() != ITEM_VNUM_GEM_STONE)
-								return false;
-
-							if (item->IsExchanging() || pTargetItem->IsExchanging())
-								return false;
-
-							if (item->isLocked() || pTargetItem->isLocked())
-								return false;
-
-							int iNeedGemStoneCount = item->GetCount() * item->GetValue(0);
-							int iConvertToGem = iNeedGemStoneCount / item->GetValue(0);
-							int iConvertCost = item->GetCount() * item->GetValue(1);
-
-							if (pTargetItem->GetCount() < iNeedGemStoneCount)
-								return false;
-
-							if (GetGold() < iConvertCost)
-								return false;
-
-							if (GetGem() + iConvertToGem >= GEM_MAX)
-								return false;
-
-							item->SetCount(item->GetCount() - 1);
-							pTargetItem->SetCount(pTargetItem->GetCount() - iNeedGemStoneCount);
-
-							PointChange(POINT_GOLD, -iConvertCost);
-							PointChange(POINT_GEM, iConvertToGem);
-						}
-						break;
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-						case ITEM_VNUM_SNOWFLAKE_STICK:
-						{
-							if (CSnowflakeStickEvent::UseStick(this))
-							{
-								EffectPacket(SE_USE_SNOWFLAKE_STICK);
-								item->SetCount(item->GetCount() - 1);
-							}
-						}
-						break;
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-						case ITEM_ACCE_REVERSAL:
-						case ITEM_ACCE_REVERSAL_MALL:
-						{
-							LPITEM lpTargetItem;
-							if (!IsValidItemPosition(DestCell) || !(lpTargetItem = GetItem(DestCell)))
-								return false;
-
-							if (lpTargetItem->IsExchanging())
-								return false;
-
-							if (lpTargetItem->isLocked())
-								return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (lpTargetItem->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
-								return false;
-							}
-#endif
-
-							if (IsAcceRefineWindowOpen())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item while the windows for absorption and combination are open."));
-								return false;
-							}
-
-							lpTargetItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_ITEM_VNUM, 0);
-							lpTargetItem->ClearAllAttribute();
-							lpTargetItem->UpdatePacket();
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-						case ITEM_CHANGE_LOOK_REVERSAL:
-						case ITEM_CHANGE_LOOK_MOUNT_REVERSAL:
-						{
-							LPITEM item2;
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item2->IsExchanging())
-								return false;
-
-							if (item2->isLocked())
-								return false;
-
-							if (item2->GetTransmutationVnum() == 0)
-								return false;
-
-							if (item->GetVnum() == ITEM_CHANGE_LOOK_MOUNT_REVERSAL && !item2->IsCostumeMount())
-								return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
-								return false;
-							}
-#endif
-
-							item2->SetTransmutationVnum(0);
-							item2->UpdatePacket();
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-						case ITEM_VNUM_AURA_CLEAR:
-						{
-							LPITEM lpTargetItem;
-							if (!IsValidItemPosition(DestCell) || !(lpTargetItem = GetItem(DestCell)))
-								return false;
-
-							if (lpTargetItem->IsExchanging())
-								return false;
-
-							if (lpTargetItem->isLocked())
-								return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (lpTargetItem->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
-								return false;
-							}
-#endif
-
-							if (IsAuraRefineWindowOpen())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item while the windows for absorption and combination are open."));
-								return false;
-							}
-
-							lpTargetItem->SetSocket(ITEM_SOCKET_AURA_DRAIN_ITEM_VNUM, 0);
-							lpTargetItem->ClearAllAttribute();
-							lpTargetItem->UpdatePacket();
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-#if defined(__SET_ITEM__)
-						case ITEM_SET_CLEAR_SCROLL:
-						{
-							LPITEM item2;
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item->IsExchanging() || item2->IsExchanging() || item2->IsEquipped())
-								return false;
-
-							if (item->isLocked() || item2->isLocked())
-								return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
-								return false;
-							}
-#endif
-
-							item2->SetItemSetValue(0);
-							item2->UpdatePacket();
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-						// RESEARCHER_ELIXIR
-						case ITEM_RESEARCHERS_ELIXIR:
-						case ITEM_RESEARCHERS_ELIXIR_GIFT:
-						case ITEM_RESEARCHERS_ELIXIR_MALL:
-						{
-							if (FindAffect(AFFECT_RESEARCHER_ELIXIR))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-							}
-							else
-							{
-								AddAffect(AFFECT_RESEARCHER_ELIXIR, APPLY_NONE, 1, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
-								item->SetCount(item->GetCount() - 1);
-							}
-						}
-						break;
-						// END_RESEARCHER_ELIXIR
-
-#if defined(__SOUL_BIND_SYSTEM__)
-						case ITEM_SCROLL_BINDING:
-						{
-							if (!g_bSoulBind)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot soulbind items on this server."));
-								return false;
-							}
-
-							LPITEM item2;
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item2->IsExchanging())
-								return false;
-
-							if (!item2->CanSealItem())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot bind this item to your soul."));
-								return false;
-							}
-
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("This item is already soulbound."));
-								return false;
-							}
-
-							item2->SealItem();
-
-							char buf[256 + 1];
-							snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
-								item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
-							LogManager::instance().ItemLog(this, item, "SEAL_SCROLL_USE_SUCCESS", buf);
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_SCROLL_UNBINDING:
-#if defined(__UN_SEAL_SCROLL_PLUS__)
-						case ITEM_SCROLL_UNBINDING_MALL:
-#endif
-						{
-							LPITEM item2;
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item2->isLocked() || item2->IsExchanging())
-								return false;
-
-							if (!item2->IsSealed())
-								return false;
-
-							if (item2->GetSealDate() > E_SEAL_DATE_DEFAULT_TIMESTAMP)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("The soulbind on this item is already in the process of being removed."));
-								return false;
-							}
-
-#if defined(__UN_SEAL_SCROLL_PLUS__)
-							if (item->GetVnum() == ITEM_SCROLL_UNBINDING_MALL)
-							{
-								item2->SealItem(E_SEAL_DATE_DEFAULT_TIMESTAMP);
-
-								char buf[256 + 1];
-								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
-									item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
-								LogManager::instance().ItemLog(this, item, "UN_SEAL_SCROLL_PLUS_USE_SUCCESS", buf);
-							}
-							else
-#endif
-							{
-								long lSealDate = time(0);
-
-								if (test_server)
-									lSealDate += 60;
-								else
-									lSealDate += (60 * 60 * SEAL_DATE_MAX);
-
-								item2->SealItem(lSealDate);
-								item2->StartSealDateExpireTimerEvent();
-
-								char buf[256 + 1];
-								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
-									item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
-								LogManager::instance().ItemLog(this, item, "UN_SEAL_SCROLL_USE_SUCCESS", buf);
-							}
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-						// 크리스마스 란주
-						case ITEM_NOG_POCKET:
-						{
-							/*
-							란주능력치 : item_proto value 의미
-								이동속도 value 1
-								공격력 value 2
-								경험치 value 3
-								지속시간 value 0 (단위 초)
-							*/
-							if (FindAffect(AFFECT_NOG_ABILITY))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-								return false;
-							}
-							long time = item->GetValue(0);
-							long moveSpeedPer = item->GetValue(1);
-							long attPer = item->GetValue(2);
-							long expPer = item->GetValue(3);
-							AddAffect(AFFECT_NOG_ABILITY, POINT_MOV_SPEED, moveSpeedPer, AFF_MOV_SPEED_POTION, time, 0, true, true);
-							AddAffect(AFFECT_NOG_ABILITY, POINT_MALL_ATTBONUS, attPer, AFF_NONE, time, 0, true, true);
-							AddAffect(AFFECT_NOG_ABILITY, POINT_MALL_EXPBONUS, expPer, AFF_NONE, time, 0, true, true);
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						// 라마단용 사탕
-						case ITEM_RAMADAN_CANDY:
-						{
-							/*
-							사탕능력치 : item_proto value 의미
-								이동속도 value 1
-								공격력 value 2
-								경험치 value 3
-								지속시간 value 0 (단위 초)
-							*/
-							if (FindAffect(AFFECT_RAMADAN_ABILITY))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-								return false;
-							}
-
-							long time = item->GetValue(0);
-							long moveSpeedPer = item->GetValue(1);
-							long attPer = item->GetValue(2);
-							long expPer = item->GetValue(3);
-							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MOV_SPEED, moveSpeedPer, AFF_MOV_SPEED_POTION, time, 0, true, true);
-							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MALL_ATTBONUS, attPer, AFF_NONE, time, 0, true, true);
-							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MALL_EXPBONUS, expPer, AFF_NONE, time, 0, true, true);
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_MARRIAGE_RING:
-						{
-							marriage::TMarriage* pMarriage = marriage::CManager::instance().Get(GetPlayerID());
-							if (pMarriage)
-							{
-								if (pMarriage->ch1 != NULL)
-								{
-									if (CArenaManager::instance().IsArenaMap(pMarriage->ch1->GetMapIndex()))
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 중에는 이용할 수 없는 물품입니다."));
-										break;
-									}
-								}
-
-								if (pMarriage->ch2 != NULL)
-								{
-									if (CArenaManager::instance().IsArenaMap(pMarriage->ch2->GetMapIndex()))
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 중에는 이용할 수 없는 물품입니다."));
-										break;
-									}
-								}
-
-								int consumeSP = CalculateConsumeSP(this);
-
-								if (consumeSP < 0)
-									return false;
-
-								PointChange(POINT_SP, -consumeSP, false);
-
-								WarpToPID(pMarriage->GetOther(GetPlayerID()));
-							}
-							else
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("결혼 상태가 아니면 결혼반지를 사용할 수 없습니다."));
-						}
-						break;
-
-						case ITEM_WHITE_FLAG:
-							ForgetMyAttacker();
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case 30093:
-						case 30094:
-						case 30095:
-						case 30096:
-							// 복주머니
-						{
-							const int MAX_BAG_INFO = 26;
-							static struct LuckyBagInfo
-							{
-								DWORD count;
-								int prob;
-								DWORD vnum;
-							} b1[MAX_BAG_INFO] =
-							{
-								{ 1000, 302, 1 },
-								{ 10, 150, 27002 },
-								{ 10, 75, 27003 },
-								{ 10, 100, 27005 },
-								{ 10, 50, 27006 },
-								{ 10, 80, 27001 },
-								{ 10, 50, 27002 },
-								{ 10, 80, 27004 },
-								{ 10, 50, 27005 },
-								{ 1, 10, ITEM_SKILLBOOK_VNUM },
-								{ 1, 6, 92 },
-								{ 1, 2, 132 },
-								{ 1, 6, 1052 },
-								{ 1, 2, 1092 },
-								{ 1, 6, 2082 },
-								{ 1, 2, 2122 },
-								{ 1, 6, 3082 },
-								{ 1, 2, 3122 },
-								{ 1, 6, 5052 },
-								{ 1, 2, 5082 },
-								{ 1, 6, 7082 },
-								{ 1, 2, 7122 },
-								{ 1, 1, 11282 },
-								{ 1, 1, 11482 },
-								{ 1, 1, 11682 },
-								{ 1, 1, 11882 },
-							};
-
-							struct LuckyBagInfo b2[MAX_BAG_INFO] =
-							{
-								{ 1000, 302, 1 },
-								{ 10, 150, 27002 },
-								{ 10, 75, 27002 },
-								{ 10, 100, 27005 },
-								{ 10, 50, 27005 },
-								{ 10, 80, 27001 },
-								{ 10, 50, 27002 },
-								{ 10, 80, 27004 },
-								{ 10, 50, 27005 },
-								{ 1, 10, ITEM_SKILLBOOK_VNUM },
-								{ 1, 6, 92 },
-								{ 1, 2, 132 },
-								{ 1, 6, 1052 },
-								{ 1, 2, 1092 },
-								{ 1, 6, 2082 },
-								{ 1, 2, 2122 },
-								{ 1, 6, 3082 },
-								{ 1, 2, 3122 },
-								{ 1, 6, 5052 },
-								{ 1, 2, 5082 },
-								{ 1, 6, 7082 },
-								{ 1, 2, 7122 },
-								{ 1, 1, 11282 },
-								{ 1, 1, 11482 },
-								{ 1, 1, 11682 },
-								{ 1, 1, 11882 },
-							};
-
-							LuckyBagInfo* bi = NULL;
-							if (LC_IsHongKong())
-								bi = b2;
-							else
-								bi = b1;
-
-							int pct = number(1, 1000);
-
-							int i;
-							for (i = 0; i < MAX_BAG_INFO; i++)
-							{
-								if (pct <= bi[i].prob)
-									break;
-								pct -= bi[i].prob;
-							}
-							if (i >= MAX_BAG_INFO)
-								return false;
-
-							if (bi[i].vnum == ITEM_SKILLBOOK_VNUM)
-							{
-								// 스킬수련서는 특수하게 준다.
-								GiveRandomSkillBook();
-							}
-							else if (bi[i].vnum == 1)
-							{
-								PointChange(POINT_GOLD, 1000, true);
-							}
-							else
-							{
-								AutoGiveItem(bi[i].vnum, bi[i].count);
-							}
-							ITEM_MANAGER::instance().RemoveItem(item);
-						}
-						break;
-
-						case 50004: // 이벤트용 감지기
-						{
-							if (item->GetSocket(0))
-							{
-								item->SetSocket(0, item->GetSocket(0) + 1);
-							}
-							else
-							{
-								// 처음 사용시
-								int iMapIndex = GetMapIndex();
-
-								PIXEL_POSITION pos;
-
-								if (SECTREE_MANAGER::instance().GetRandomLocation(iMapIndex, pos, 700))
-								{
-									item->SetSocket(0, 1);
-									item->SetSocket(1, pos.x);
-									item->SetSocket(2, pos.y);
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 곳에선 이벤트용 감지기가 동작하지 않는것 같습니다."));
-									return false;
-								}
-							}
-
-							int dist = 0;
-							float distance = (DISTANCE_SQRT(GetX() - item->GetSocket(1), GetY() - item->GetSocket(2)));
-
-							if (distance < 1000.0f)
-							{
-								// 발견!
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이벤트용 감지기가 신비로운 빛을 내며 사라집니다."));
-
-								// 사용횟수에 따라 주는 아이템을 다르게 한다.
-								struct TEventStoneInfo
-								{
-									DWORD dwVnum;
-									int count;
-									int prob;
-								};
-								const int EVENT_STONE_MAX_INFO = 15;
-								TEventStoneInfo info_10[EVENT_STONE_MAX_INFO] =
-								{
-									{ 27001, 10, 8 },
-									{ 27004, 10, 6 },
-									{ 27002, 10, 12 },
-									{ 27005, 10, 12 },
-									{ 27100, 1, 9 },
-									{ 27103, 1, 9 },
-									{ 27101, 1, 10 },
-									{ 27104, 1, 10 },
-									{ 27999, 1, 12 },
-
-									{ 25040, 1, 4 },
-
-									{ 27410, 1, 0 },
-									{ 27600, 1, 0 },
-									{ 25100, 1, 0 },
-
-									{ 50001, 1, 0 },
-									{ 50003, 1, 1 },
-								};
-								TEventStoneInfo info_7[EVENT_STONE_MAX_INFO] =
-								{
-									{ 27001, 10, 1 },
-									{ 27004, 10, 1 },
-									{ 27004, 10, 9 },
-									{ 27005, 10, 9 },
-									{ 27100, 1, 5 },
-									{ 27103, 1, 5 },
-									{ 27101, 1, 10 },
-									{ 27104, 1, 10 },
-									{ 27999, 1, 14 },
-
-									{ 25040, 1, 5 },
-
-									{ 27410, 1, 5 },
-									{ 27600, 1, 5 },
-									{ 25100, 1, 5 },
-
-									{ 50001, 1, 0 },
-									{ 50003, 1, 5 },
-
-								};
-								TEventStoneInfo info_4[EVENT_STONE_MAX_INFO] =
-								{
-									{ 27001, 10, 0 },
-									{ 27004, 10, 0 },
-									{ 27002, 10, 0 },
-									{ 27005, 10, 0 },
-									{ 27100, 1, 0 },
-									{ 27103, 1, 0 },
-									{ 27101, 1, 0 },
-									{ 27104, 1, 0 },
-									{ 27999, 1, 25 },
-
-									{ 25040, 1, 0 },
-
-									{ 27410, 1, 0 },
-									{ 27600, 1, 0 },
-									{ 25100, 1, 15 },
-
-									{ 50001, 1, 10 },
-									{ 50003, 1, 50 },
-
-								};
-
-								{
-									TEventStoneInfo* info;
-									if (item->GetSocket(0) <= 4)
-										info = info_4;
-									else if (item->GetSocket(0) <= 7)
-										info = info_7;
-									else
-										info = info_10;
-
-									int prob = number(1, 100);
-
-									for (int i = 0; i < EVENT_STONE_MAX_INFO; ++i)
-									{
-										if (!info[i].prob)
-											continue;
-
-										if (prob <= info[i].prob)
-										{
-											if (info[i].dwVnum == 50001)
-											{
-												DWORD* pdw = M2_NEW DWORD[2];
-
-												pdw[0] = info[i].dwVnum;
-												pdw[1] = info[i].count;
-
-												// 추첨서는 소켓을 설정한다
-												DBManager::instance().ReturnQuery(QID_LOTTO, GetPlayerID(), pdw,
-													"INSERT INTO lotto_list VALUES(0, 'server%s', %u, NOW())",
-													get_table_postfix(), GetPlayerID());
-											}
-											else
-												AutoGiveItem(info[i].dwVnum, info[i].count);
-
-											break;
-										}
-										prob -= info[i].prob;
-									}
-								}
-
-								char chatbuf[CHAT_MAX_LEN + 1];
-								int len = snprintf(chatbuf, sizeof(chatbuf), "StoneDetect %u 0 0", (DWORD)GetVID());
-
-								if (len < 0 || len >= (int)sizeof(chatbuf))
-									len = sizeof(chatbuf) - 1;
-
-								++len; // \0 문자까지 보내기
-
-								TPacketGCChat pack_chat;
-								pack_chat.header = HEADER_GC_CHAT;
-								pack_chat.size = sizeof(TPacketGCChat) + len;
-								pack_chat.type = CHAT_TYPE_COMMAND;
-								pack_chat.id = 0;
-								pack_chat.bEmpire = GetDesc()->GetEmpire();
-								//pack_chat.id = vid;
-
-								TEMP_BUFFER buf;
-								buf.write(&pack_chat, sizeof(TPacketGCChat));
-								buf.write(chatbuf, len);
-
-								PacketAround(buf.read_peek(), buf.size());
-
-								ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (DETECT_EVENT_STONE) 1");
-								return true;
-							}
-							else if (distance < 20000)
-								dist = 1;
-							else if (distance < 70000)
-								dist = 2;
-							else
-								dist = 3;
-
-							// 많이 사용했으면 사라진다.
-							const int STONE_DETECT_MAX_TRY = 10;
-							if (item->GetSocket(0) >= STONE_DETECT_MAX_TRY)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이벤트용 감지기가 흔적도 없이 사라집니다."));
-								ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (DETECT_EVENT_STONE) 0");
-								AutoGiveItem(27002);
-								return true;
-							}
-
-							if (dist)
-							{
-								char chatbuf[CHAT_MAX_LEN + 1];
-								int len = snprintf(chatbuf, sizeof(chatbuf),
-									"StoneDetect %u %d %d",
-									(DWORD)GetVID(), dist, (int)GetDegreeFromPositionXY(GetX(), item->GetSocket(2), item->GetSocket(1), GetY()));
-
-								if (len < 0 || len >= (int)sizeof(chatbuf))
-									len = sizeof(chatbuf) - 1;
-
-								++len; // \0 문자까지 보내기
-
-								TPacketGCChat pack_chat;
-								pack_chat.header = HEADER_GC_CHAT;
-								pack_chat.size = sizeof(TPacketGCChat) + len;
-								pack_chat.type = CHAT_TYPE_COMMAND;
-								pack_chat.id = 0;
-								pack_chat.bEmpire = GetDesc()->GetEmpire();
-								//pack_chat.id = vid;
-
-								TEMP_BUFFER buf;
-								buf.write(&pack_chat, sizeof(TPacketGCChat));
-								buf.write(chatbuf, len);
-
-								PacketAround(buf.read_peek(), buf.size());
-							}
-						}
-						break;
-
-						case 27989: // 영석감지기
-						case 76006: // 선물용 영석감지기
-						{
-							LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(GetMapIndex());
-
-							if (pMap != NULL)
-							{
-								item->SetSocket(0, item->GetSocket(0) + 1);
-
-								FFindStone f;
-
-								// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
-								pMap->for_each(f);
-
-								if (f.m_mapStone.size() > 0)
-								{
-									std::map<DWORD, LPCHARACTER>::iterator stone = f.m_mapStone.begin();
-
-									DWORD max = UINT_MAX;
-									LPCHARACTER pTarget = stone->second;
-
-									while (stone != f.m_mapStone.end())
-									{
-										DWORD dist = (DWORD)DISTANCE_SQRT(GetX() - stone->second->GetX(), GetY() - stone->second->GetY());
-
-										if (dist != 0 && max > dist)
-										{
-											max = dist;
-											pTarget = stone->second;
-										}
-										stone++;
-									}
-
-									if (pTarget != NULL)
-									{
-										int val = 3;
-
-										if (max < 10000) val = 2;
-										else if (max < 70000) val = 1;
-
-										ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u %d %d", (DWORD)GetVID(), val,
-											(int)GetDegreeFromPositionXY(GetX(), pTarget->GetY(), pTarget->GetX(), GetY()));
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("감지기를 작용하였으나 감지되는 영석이 없습니다."));
-									}
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("감지기를 작용하였으나 감지되는 영석이 없습니다."));
-								}
-
-								if (item->GetSocket(0) >= 6)
-								{
-									ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u 0 0", (DWORD)GetVID());
-									ITEM_MANAGER::instance().RemoveItem(item);
-								}
-							}
-							break;
-						}
-						break;
-
-#if defined(__MT_THUNDER_DUNGEON__)
-						case 79602:
-						{
-							if (GetMapIndex() != CMTThunderDungeon::MAP_INDEX)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("This action is not possible on this map."));
-								return false;
-							}
-
-							LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(GetMapIndex());
-
-							if (pMap != NULL)
-							{
-								item->SetSocket(0, item->GetSocket(0) + 1);
-
-								FFindMobVnum f(6405);
-
-								// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
-								pMap->for_each(f);
-
-								if (f.m_mapVID.size() > 0)
-								{
-									std::map<DWORD, LPCHARACTER>::iterator it = f.m_mapVID.begin();
-
-									DWORD max = UINT_MAX;
-									LPCHARACTER pTarget = it->second;
-
-									while (it != f.m_mapVID.end())
-									{
-										DWORD dist = (DWORD)DISTANCE_SQRT(GetX() - it->second->GetX(), GetY() - it->second->GetY());
-
-										if (dist != 0 && max > dist)
-										{
-											max = dist;
-											pTarget = it->second;
-										}
-										it++;
-									}
-
-									if (pTarget != NULL)
-									{
-										int val = 3;
-
-										if (max < 10000) val = 2;
-										else if (max < 70000) val = 1;
-
-										ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u %d %d", (DWORD)GetVID(), val,
-											(int)GetDegreeFromPositionXY(GetX(), pTarget->GetY(), pTarget->GetX(), GetY()));
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Compass was used, but the Guard wasn뭪 found."));
-									}
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Compass was used, but the Guard wasn뭪 found."));
-								}
-
-								if (item->GetSocket(0) >= 6)
-								{
-									ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u 0 0", (DWORD)GetVID());
-									ITEM_MANAGER::instance().RemoveItem(item);
-								}
-							}
-						}
-						break;
-#endif
-
-						case 27996: // 독병
-							item->SetCount(item->GetCount() - 1);
-							/*
-							if (GetSkillLevel(SKILL_CREATE_POISON))
-								AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE, 3, AFF_DRINK_POISON, 15 * 60, 0, true);
-							else
-							{
-								// 독다루기가 없으면 50% 즉사 50% 공격력 +2
-								if (number(0, 1))
-								{
-									if (GetHP() > 100)
-										PointChange(POINT_HP, -(GetHP() - 1));
-									else
-										Dead();
-								}
-								else
-									AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE, 2, AFF_DRINK_POISON, 15 * 60, 0, true);
-							}
-							*/
-							break;
-
-						case fishing::SHELLFISH_VNUM: // 조개
-							// 50 돌조각 47990
-							// 30 꽝
-							// 10 백진주 47992
-							// 7 청진주 47993
-							// 3 피진주 47994
-						{
-							item->SetCount(item->GetCount() - 1);
-
-							int r = number(1, 100);
-
-							if (r <= 50)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("조개에서 돌조각이 나왔습니다."));
-								AutoGiveItem(fishing::STONEPIECE_VNUM);
-							}
-							else
-							{
-								const int prob_table_euckr[] =
-								{
-									80, 90, 97
-								};
-
-								const int prob_table_gb2312[] =
-								{
-									95, 97, 99
-								};
-
-								const int* prob_table = !g_iUseLocale ? prob_table_euckr : prob_table_gb2312;
-
-								if (r <= prob_table[0])
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("조개가 흔적도 없이 사라집니다."));
-								}
-								else if (r <= prob_table[1])
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("조개에서 백진주가 나왔습니다."));
-									AutoGiveItem(fishing::WHITE_PEARL_VNUM);
-								}
-								else if (r <= prob_table[2])
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("조개에서 청진주가 나왔습니다."));
-									AutoGiveItem(fishing::BLUE_PEARL_VNUM);
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("조개에서 피진주가 나왔습니다."));
-									AutoGiveItem(fishing::RED_PEARL_VNUM);
-								}
-							}
-						}
-						break;
-
-						case 71013: // 축제용폭죽
-							CreateFly(number(FLY_FIREWORK1, FLY_FIREWORK6), this);
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case 50100: // 폭죽
-						case 50101:
-						case 50102:
-						case 50103:
-						case 50104:
-						case 50105:
-						case 50106:
-							CreateFly(item->GetVnum() - 50100 + FLY_FIREWORK1, this);
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case 50200: // 보따리
-						{
-							if (LC_IsYMIR() == true || LC_IsKorea() == true)
-							{
-								if (IS_BOTARYABLE_ZONE(GetMapIndex()) == true)
-								{
-									__OpenPrivateShop();
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("개인 상점을 열 수 없는 지역입니다"));
-								}
-							}
-							else
-							{
-								__OpenPrivateShop();
-							}
-						}
-						break;
-
-						case fishing::FISH_MIND_PILL_VNUM:
-							AddAffect(AFFECT_FISH_MIND_PILL, POINT_NONE, 0, AFF_FISH_MIND, 20 * 60, 0, true);
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case 50301: // 통솔력 수련서
-						case 50302:
-						case 50303:
-						{
-							if (IsPolymorphed() == true)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("둔갑 중에는 능력을 올릴 수 없습니다."));
-								return false;
-							}
-
-							int lv = GetSkillLevel(SKILL_LEADERSHIP);
-
-							if (lv < item->GetValue(0))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 책은 너무 어려워 이해하기가 힘듭니다."));
-								return false;
-							}
-
-							if (lv >= item->GetValue(1))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 책은 아무리 봐도 도움이 될 것 같지 않습니다."));
-								return false;
-							}
-
-							if (LearnSkillByBook(SKILL_LEADERSHIP))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(SKILL_LEADERSHIP, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-
-						case 50304: // 연계기 수련서
-						case 50305:
-						case 50306:
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("변신중에는 책을 읽을수 없습니다."));
-								return false;
-							}
-
-							if (GetSkillLevel(SKILL_COMBO) == 0 && GetLevel() < 30)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("레벨 30이 되기 전에는 습득할 수 있을 것 같지 않습니다."));
-								return false;
-							}
-
-							if (GetSkillLevel(SKILL_COMBO) == 1 && GetLevel() < 50)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("레벨 50이 되기 전에는 습득할 수 있을 것 같지 않습니다."));
-								return false;
-							}
-
-							if (GetSkillLevel(SKILL_COMBO) >= 2)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("연계기는 더이상 수련할 수 없습니다."));
-								return false;
-							}
-
-							int iPct = item->GetValue(0);
-
-							if (LearnSkillByBook(SKILL_COMBO, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(SKILL_COMBO, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-
-						case 50311: // 언어 수련서
-						case 50312:
-						case 50313:
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("변신중에는 책을 읽을수 없습니다."));
-								return false;
-							}
-
-							DWORD dwSkillVnum = item->GetValue(0);
-							int iPct = MINMAX(0, item->GetValue(1), 100);
-							if (GetSkillLevel(dwSkillVnum) >= 20 || dwSkillVnum - SKILL_LANGUAGE1 + 1 == GetEmpire())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 완벽하게 알아들을 수 있는 언어이다."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-
-						case 50061: // 일본 말 소환 스킬 수련서
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("변신중에는 책을 읽을수 없습니다."));
-								return false;
-							}
-
-							DWORD dwSkillVnum = item->GetValue(0);
-							int iPct = MINMAX(0, item->GetValue(1), 100);
-
-							if (GetSkillLevel(dwSkillVnum) >= 10)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("더 이상 수련할 수 없습니다."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-
-						// LEARNABLE_SKILL_BOOKS_BY_LEVEL
-						case 50314: case 50315: case 50316: // 변신 수련서
-						case 50325: // Book of Precision
-						{
-							if (IsPolymorphed() == true)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("둔갑 중에는 능력을 올릴 수 없습니다."));
-								return false;
-							}
-
-							int iSkillLevelLowLimit = item->GetValue(0);
-							int iSkillLevelHighLimit = item->GetValue(1);
-							int iPct = MINMAX(0, item->GetValue(2), 100);
-							int iLevelLimit = item->GetValue(3);
-							DWORD dwSkillVnum = 0;
-
-							switch (item->GetVnum())
-							{
-								case 50314: case 50315: case 50316:
-									dwSkillVnum = SKILL_POLYMORPH;
-									break;
-
-#if defined(__CONQUEROR_LEVEL__)
-								case 50325: // Book of Precision
-									dwSkillVnum = SKILL_HIT;
-									break;
-#endif
-
-								default:
-									return false;
-							}
-
-							if (0 == dwSkillVnum)
-								return false;
-
-#if defined(__CONQUEROR_LEVEL__)
-							if (dwSkillVnum == SKILL_HIT && GetConquerorLevel() < iSkillLevelLowLimit)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 책을 읽으려면 레벨을 더 올려야 합니다."));
-								return false;
-							}
-							else
-#endif
-							{
-								if (GetLevel() < iLevelLimit)
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 책을 읽으려면 레벨을 더 올려야 합니다."));
-									return false;
-								}
-							}
-
-							if (GetSkillLevel(dwSkillVnum) >= 40)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("더 이상 수련할 수 없습니다."));
-								return false;
-							}
-
-							if (GetSkillLevel(dwSkillVnum) < iSkillLevelLowLimit
-#if defined(__CONQUEROR_LEVEL__)
-								&& dwSkillVnum != SKILL_HIT
-#endif
-								)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 책은 너무 어려워 이해하기가 힘듭니다."));
-								return false;
-							}
-
-							if (GetSkillLevel(dwSkillVnum) >= iSkillLevelHighLimit)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 책으로는 더 이상 수련할 수 없습니다."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-						// END_LEARNABLE_SKILL_BOOKS_BY_LEVEL
-
-						// LEARNABLE_SKILL_BOOKS_BY_EXP
-#if defined(__PARTY_PROFICY__)
-						case 50338:	// Charisma of a Rookie
-						case 50339:	// Charisma of an Adept
-						case 50340:	// Charisma of an Expert
-#endif
-#if defined(__PARTY_INSIGHT__)
-						case 50341:	// Inspiration of a Rookie
-						case 50342:	// Inspiration of an Adept
-						case 50343:	// Inspiration of an Expert
-#endif
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("둔갑 중에는 능력을 올릴 수 없습니다."));
-								return false;
-							}
-
-							int iSkillLevelLowLimit = item->GetValue(0);
-							int iSkillLevelHighLimit = item->GetValue(1);
-							int iPct = MINMAX(0, item->GetValue(2), 100);
-							int iNeedExp = item->GetValue(3);
-							DWORD dwSkillVnum = 0;
-
-							switch (item->GetVnum())
-							{
-#if defined(__PARTY_PROFICY__)
-								case 50338:	// Charisma of a Rookie
-								case 50339:	// Charisma of an Adept
-								case 50340:	// Charisma of an Expert
-									dwSkillVnum = SKILL_ROLE_PROFICIENCY;
-									break;
-#endif
-
-#if defined(__PARTY_INSIGHT__)
-								case 50341:	// Inspiration of a Rookie
-								case 50342:	// Inspiration of an Adept
-								case 50343:	// Inspiration of an Expert
-									dwSkillVnum = SKILL_INSIGHT;
-									break;
-#endif
-
-								default:
-									return false;
-							}
-
-							if (0 == dwSkillVnum)
-								return false;
-
-							if (GetExp() < static_cast<DWORD>(iNeedExp))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("경험치가 부족하여 책을 읽을 수 없습니다."));
-								return false;
-							}
-
-							if (GetSkillLevel(dwSkillVnum) >= 40)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("수련할 수 없는 스킬입니다."));
-								return false;
-							}
-
-							if (GetSkillLevel(dwSkillVnum) < iSkillLevelLowLimit)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 책은 너무 어려워 이해하기가 힘듭니다."));
-								return false;
-							}
-
-							if (GetSkillLevel(dwSkillVnum) >= iSkillLevelHighLimit)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 책으로는 더 이상 수련할 수 없습니다."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								if (dwSkillVnum != SKILL_HIT)
-									PointChange(POINT_EXP, -iNeedExp);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server)
-									iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-						// END_LEARNABLE_SKILL_BOOKS_BY_EXP
-
-						case 50902:
-						case 50903:
-						case 50904:
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("변신중에는 책을 읽을수 없습니다."));
-								return false;
-							}
-
-							DWORD dwSkillVnum = SKILL_CREATE;
-							int iPct = MINMAX(0, item->GetValue(1), 100);
-
-							if (GetSkillLevel(dwSkillVnum) >= 40)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("더 이상 수련할 수 없습니다."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-
-								if (test_server)
-								{
-									ChatPacket(CHAT_TYPE_INFO, "[TEST_SERVER] Success to learn skill ");
-								}
-							}
-							else
-							{
-								if (test_server)
-								{
-									ChatPacket(CHAT_TYPE_INFO, "[TEST_SERVER] Failed to learn skill ");
-								}
-							}
-						}
-						break;
-
-						// MINING
-						case ITEM_MINING_SKILL_TRAIN_BOOK:
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("변신중에는 책을 읽을수 없습니다."));
-								return false;
-							}
-
-							DWORD dwSkillVnum = SKILL_MINING;
-							int iPct = MINMAX(0, item->GetValue(1), 100);
-
-							if (GetSkillLevel(dwSkillVnum) >= 40)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("더 이상 수련할 수 없습니다."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-						// END_OF_MINING
-
-						case ITEM_HORSE_SKILL_TRAIN_BOOK:
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("변신중에는 책을 읽을수 없습니다."));
-								return false;
-							}
-
-							DWORD dwSkillVnum = SKILL_HORSE;
-							int iPct = MINMAX(0, item->GetValue(1), 100);
-
-							if (GetLevel() < 50)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("아직 승마 스킬을 수련할 수 있는 레벨이 아닙니다."));
-								return false;
-							}
-
-							if (!test_server && get_global_time() < GetSkillNextReadTime(dwSkillVnum))
-							{
-								if (FindAffect(AFFECT_SKILL_NO_BOOK_DELAY))
-								{
-									// 주안술서 사용중에는 시간 제한 무시
-									RemoveAffect(AFFECT_SKILL_NO_BOOK_DELAY);
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("주안술서를 통해 주화입마에서 빠져나왔습니다."));
-								}
-								else
-								{
-									SkillLearnWaitMoreTimeMessage(GetSkillNextReadTime(dwSkillVnum) - get_global_time());
-									return false;
-								}
-							}
-
-							if (GetPoint(POINT_HORSE_SKILL) >= 20 ||
-								GetSkillLevel(SKILL_HORSE_WILDATTACK) + GetSkillLevel(SKILL_HORSE_CHARGE) + GetSkillLevel(SKILL_HORSE_ESCAPE) >= 60 ||
-								GetSkillLevel(SKILL_HORSE_WILDATTACK_RANGE) + GetSkillLevel(SKILL_HORSE_CHARGE) + GetSkillLevel(SKILL_HORSE_ESCAPE) >= 60)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("더 이상 승마 수련서를 읽을 수 없습니다."));
-								return false;
-							}
-
-							if (number(1, 100) <= iPct)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("승마 수련서를 읽어 승마 스킬 포인트를 얻었습니다."));
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("얻은 포인트로는 승마 스킬의 레벨을 올릴 수 있습니다."));
-								PointChange(POINT_HORSE_SKILL, 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								if (!test_server)
-									SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("승마 수련서 이해에 실패하였습니다."));
-							}
-
-							ITEM_MANAGER::instance().RemoveItem(item);
-						}
-						break;
-
-						case 70102: // 선두
-						case 70103: // 선두
-						{
-							if (GetAlignment() >= 0)
-								return false;
-
-							int delta = MIN(-GetAlignment(), item->GetValue(0));
-
-							sys_log(0, "%s ALIGNMENT ITEM %d", GetName(), delta);
-
-							UpdateAlignment(delta);
-							item->SetCount(item->GetCount() - 1);
-
-							if (delta / 10 > 0)
-							{
-								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("마음이 맑아지는군. 가슴을 짓누르던 무언가가 좀 가벼워진 느낌이야."));
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("선악치가 %d 증가하였습니다.", delta / 10));
-							}
-						}
-						break;
-
-						case 71107: // 천도복숭아
-						case 39032:
-						{
-							quest::CQuestManager& q = quest::CQuestManager::Instance();
-							quest::PC* pPC = q.GetPC(GetPlayerID());
-							if (pPC)
-							{
-								int val = item->GetValue(0);
-								int interval = item->GetValue(1);
-								int last_use_time = pPC->GetFlag("mythical_peach.last_use_time");
-								if (get_global_time() - last_use_time < interval * 60 * 60)
-								{
-									if (test_server == false)
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("아직 사용할 수 없습니다."));
-										return false;
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("테스트 서버 시간제한 통과"));
-									}
-								}
-
-								if (GetAlignment() == 200000)
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("선악치를 더 이상 올릴 수 없습니다."));
-									return false;
-								}
-
-								if (200000 - GetAlignment() < val * 10)
-								{
-									val = (200000 - GetAlignment()) / 10;
-								}
-
-								int old_alignment = GetAlignment() / 10;
-
-								UpdateAlignment(val * 10);
-
-								item->SetCount(item->GetCount() - 1);
-								pPC->SetFlag("mythical_peach.last_use_time", get_global_time());
-
-								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("마음이 맑아지는군. 가슴을 짓누르던 무언가가 좀 가벼워진 느낌이야."));
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("선악치가 %d 증가하였습니다.", val));
-
-								char buf[256 + 1];
-								snprintf(buf, sizeof(buf), "%d %d", old_alignment, GetAlignment() / 10);
-								LogManager::instance().CharLog(this, val, "MYTHICAL_PEACH", buf);
-							}
-						}
-						break;
-
-						case 71109: // 탈석서
-						case 39033:
-						{
-							LPITEM item2;
-
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item2->IsExchanging() || item2->IsEquipped())
-								return false;
-
-							if (item2->GetSocketCount() == 0)
-								return false;
-
-							switch (item2->GetType())
-							{
-								case ITEM_WEAPON:
-									break;
-
-								case ITEM_ARMOR:
-									switch (item2->GetSubType())
-									{
-										case ARMOR_EAR:
-										case ARMOR_WRIST:
-										case ARMOR_NECK:
-											ChatPacket(CHAT_TYPE_INFO, LC_STRING("빼낼 영석이 없습니다"));
-											return false;
-									}
-									break;
-
-								default:
-									return false;
-							}
-
-							std::stack<long> socket;
-
-							for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-							{
-#if defined(__GLOVE_SYSTEM__)
-								DWORD dwSocketData = item2->GetSocket(i);
-								if (item2->IsGlove() && dwSocketData >= 1000000 && dwSocketData != ITEM_BROKEN_METIN_VNUM)
-								{
-									DWORD dwBaseIndex = 28046;
-									dwBaseIndex += (((dwSocketData / 1000) % 10) * 100);
-									dwBaseIndex += ((dwSocketData / 100) % 10) - 1;
-
-									const TItemTable* pItemData = ITEM_MANAGER::instance().GetTable(dwBaseIndex);
-									if (pItemData == nullptr)
-										continue;
-
-									dwSocketData = dwBaseIndex;
-								}
-								socket.push(dwSocketData);
-#else
-								socket.push(item2->GetSocket(i));
-#endif
-							}
-
-							int idx = METIN_SOCKET_MAX_NUM - 1;
-
-							while (socket.size() > 0)
-							{
-								if (socket.top() > 2 && socket.top() != ITEM_BROKEN_METIN_VNUM)
-									break;
-
-								idx--;
-								socket.pop();
-							}
-
-							if (socket.size() == 0)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("빼낼 영석이 없습니다"));
-								return false;
-							}
-
-							LPITEM pItemReward = AutoGiveItem(socket.top());
-							if (pItemReward != NULL)
-							{
-								item2->SetSocket(idx, 1);
-
-								char buf[256 + 1];
-								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
-									item2->GetName(), item2->GetID(), pItemReward->GetName(), pItemReward->GetID());
-								LogManager::instance().ItemLog(this, item, "USE_DETACHMENT_ONE", buf);
-
-								item->SetCount(item->GetCount() - 1);
-							}
-						}
-						break;
-
-						case 70201: // 탈색제
-						case 70202: // 염색약(흰색)
-						case 70203: // 염색약(금색)
-						case 70204: // 염색약(빨간색)
-						case 70205: // 염색약(갈색)
-						case 70206: // 염색약(검은색)
-						{
-							// NEW_HAIR_STYLE_ADD
-							if (GetPart(PART_HAIR) >= 1001)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("현재 헤어스타일에서는 염색과 탈색이 불가능합니다."));
-							}
-							// END_NEW_HAIR_STYLE_ADD
-							else
-							{
-								quest::CQuestManager& q = quest::CQuestManager::instance();
-								quest::PC* pPC = q.GetPC(GetPlayerID());
-								if (pPC)
-								{
-									int last_dye_level = pPC->GetFlag("dyeing_hair.last_dye_level");
-
-									if (last_dye_level == 0 ||
-										last_dye_level + 3 <= GetLevel() ||
-										item->GetVnum() == 70201)
-									{
-										SetPart(PART_HAIR, item->GetVnum() - 70201);
-
-										if (item->GetVnum() == 70201)
-											pPC->SetFlag("dyeing_hair.last_dye_level", 0);
-										else
-											pPC->SetFlag("dyeing_hair.last_dye_level", GetLevel());
-
-										item->SetCount(item->GetCount() - 1);
-										UpdatePacket();
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d 레벨이 되어야 다시 염색하실 수 있습니다.", last_dye_level + 3));
-									}
-								}
-							}
-						}
-						break;
-
-						case ITEM_NEW_YEAR_GREETING_VNUM:
-						{
-							if (GiveItemFromSpecialItemGroup(ITEM_NEW_YEAR_GREETING_VNUM))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_VALENTINE_ROSE:
-						case ITEM_VALENTINE_CHOCOLATE:
-						{
-							if (item->GetVnum() == ITEM_VALENTINE_ROSE && SEX_MALE == GET_SEX(this) ||
-								item->GetVnum() == ITEM_VALENTINE_CHOCOLATE && SEX_FEMALE == GET_SEX(this))
-							{
-								// 성별이 맞지않아 쓸 수 없다.
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("성별이 맞지않아 이 아이템을 열 수 없습니다."));
-								return false;
-							}
-
-							if (GiveItemFromSpecialItemGroup(item->GetVnum()))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_WHITEDAY_CANDY:
-						case ITEM_WHITEDAY_ROSE:
-						{
-							if (item->GetVnum() == ITEM_WHITEDAY_CANDY && SEX_MALE == GET_SEX(this) ||
-								item->GetVnum() == ITEM_WHITEDAY_ROSE && SEX_FEMALE == GET_SEX(this))
-							{
-								// 성별이 맞지않아 쓸 수 없다.
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("성별이 맞지않아 이 아이템을 열 수 없습니다."));
-								return false;
-							}
-
-							if (GiveItemFromSpecialItemGroup(item->GetVnum()))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case 50011: // 월광보합
-						{
-							if (!GiveItemFromSpecialItemGroup(50011))
-							{
-								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("아무것도 얻을 수 없었습니다."));
-								return false;
-							}
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_GIVE_STAT_RESET_COUNT_VNUM:
-						{
-							//PointChange(POINT_GOLD, -iCost);
-							PointChange(POINT_STAT_RESET_COUNT, 1);
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case 50107:
-						{
-							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 중에는 이용할 수 없는 물품입니다."));
-								return false;
-							}
-
-							EffectPacket(SE_CHINA_FIREWORK);
-							// 스턴 공격을 올려준다
-							AddAffect(AFFECT_CHINA_FIREWORK, POINT_STUN_PCT, 30, AFF_CHINA_FIREWORK, 5 * 60, 0, true);
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case 50108:
-						{
-							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 중에는 이용할 수 없는 물품입니다."));
-								return false;
-							}
-
-							EffectPacket(SE_SPIN_TOP);
-							// 스턴 공격을 올려준다
-							AddAffect(AFFECT_CHINA_FIREWORK, POINT_STUN_PCT, 30, AFF_CHINA_FIREWORK, 5 * 60, 0, true);
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_WONSO_BEAN_VNUM:
-							PointChange(POINT_HP, GetMaxHP() - GetHP());
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case ITEM_WONSO_SUGAR_VNUM:
-							PointChange(POINT_SP, GetMaxSP() - GetSP());
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case ITEM_WONSO_FRUIT_VNUM:
-							PointChange(POINT_STAMINA, GetMaxStamina() - GetStamina());
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case ITEM_ELK_VNUM: // 돈꾸러미
-						{
-							int iGold = item->GetSocket(0);
-							ITEM_MANAGER::instance().RemoveItem(item);
-							PointChange(POINT_GOLD, iGold);
-						}
-						break;
-
-						// 군주의 증표
-						case 70021:
-						{
-							int HealPrice = quest::CQuestManager::instance().GetEventFlag("MonarchHealGold");
-							if (HealPrice == 0)
-								HealPrice = 2000000;
-
-							if (CMonarch::instance().HealMyEmpire(this, HealPrice))
-							{
-								char szNotice[256];
-								snprintf(szNotice, sizeof(szNotice), LC_STRING("군주의 축복으로 이지역 %s 유저는 HP,SP가 모두 채워집니다.", EMPIRE_NAME(GetEmpire())));
-								SendNoticeMap(szNotice, GetMapIndex(), false);
-
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("군주의 축복을 사용하였습니다."));
-							}
-						}
-						break;
-
-						case 27995:
-						{
-						}
-						break;
-
-						case 71092: // 변신 해체부 임시
-						{
-							if (m_pkChrTarget != NULL)
-							{
-								if (m_pkChrTarget->IsPolymorphed())
-								{
-									m_pkChrTarget->SetPolymorph(0);
-									m_pkChrTarget->RemoveAffect(AFFECT_POLYMORPH);
-								}
-							}
-							else
-							{
-								if (IsPolymorphed())
-								{
-									SetPolymorph(0);
-									RemoveAffect(AFFECT_POLYMORPH);
-								}
-							}
-						}
-						break;
-
-						case 71051: // 진재가
-						{
-							LPITEM item2;
-
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetInventoryItem(wDestCell)))
-								return false;
-
-							if (item2->IsExchanging())
-								return false;
-
-							if (item2->IsEquipped())
-								return false;
-
-							if (item2->GetType() == ITEM_COSTUME)
-								return false;
-
-							//if (item2->GetAttributeCount() < 5)
-							//	return false;
-
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경할 수 없는 아이템입니다."));
-								return false;
-							}
-
-							if (item2->AddRareAttribute() == true)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성 추가에 성공하였습니다."));
-
-								int iAddedIdx = item2->GetRareAttrCount() + 4;
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-
-								LogManager::instance().ItemLog(
-									GetPlayerID(),
-									item2->GetAttributeType(iAddedIdx),
-									item2->GetAttributeValue(iAddedIdx),
-									item->GetID(),
-									"ADD_RARE_ATTR",
-									buf,
-									GetDesc()->GetHostName(),
-									item->GetOriginalVnum());
-
-								if (!g_bUnlimitedAddRareAttributes)
-									item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성 추가에 실패하였습니다."));
-							}
-						}
-						break;
-
-						case 71052: // 진재경
-						{
-							LPITEM item2;
-
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item2->IsEquipped())
-								return false;
-
-							if (item2->GetType() == ITEM_COSTUME)
-								return false;
-
-							if (item2->IsExchanging() == true)
-								return false;
-
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경할 수 없는 아이템입니다."));
-								return false;
-							}
-
-							if (item2->ChangeRareAttribute() == true)
-							{
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-								LogManager::instance().ItemLog(this, item, "CHANGE_RARE_ATTR", buf);
-
-								if (!g_bUnlimitedChangeRareAttributes)
-									item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경하였습니다."));
-							}
-						}
-						break;
-
-						case ITEM_AUTO_HP_RECOVERY_S:
-						case ITEM_AUTO_HP_RECOVERY_M:
-						case ITEM_AUTO_HP_RECOVERY_L:
-						case ITEM_AUTO_HP_RECOVERY_X:
-						case ITEM_AUTO_SP_RECOVERY_S:
-						case ITEM_AUTO_SP_RECOVERY_M:
-						case ITEM_AUTO_SP_RECOVERY_L:
-						case ITEM_AUTO_SP_RECOVERY_X:
-							// 무시무시하지만 이전에 하던 걸 고치기는 무섭고...
-							// 그래서 그냥 하드 코딩. 선물 상자용 자동물약 아이템들.
-						case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
-						case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
-						case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
-						case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
-						{
-							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련장에서 사용하실 수 없습니다."));
-								return false;
-							}
-
-							EAffectTypes type = AFFECT_NONE;
-							bool isSpecialPotion = false;
-
-							switch (item->GetVnum())
-							{
-								case ITEM_AUTO_HP_RECOVERY_X:
-									isSpecialPotion = true;
-
-								case ITEM_AUTO_HP_RECOVERY_S:
-								case ITEM_AUTO_HP_RECOVERY_M:
-								case ITEM_AUTO_HP_RECOVERY_L:
-								case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
-								case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
-									type = AFFECT_AUTO_HP_RECOVERY;
-									break;
-
-								case ITEM_AUTO_SP_RECOVERY_X:
-									isSpecialPotion = true;
-
-								case ITEM_AUTO_SP_RECOVERY_S:
-								case ITEM_AUTO_SP_RECOVERY_M:
-								case ITEM_AUTO_SP_RECOVERY_L:
-								case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
-								case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
-									type = AFFECT_AUTO_SP_RECOVERY;
-									break;
-							}
-
-							if (AFFECT_NONE == type)
-								break;
-
-							if (item->GetCount() > 1)
-							{
-								int pos = GetEmptyInventory(item->GetSize());
-
-								if (-1 == pos)
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지품에 빈 공간이 없습니다."));
-									break;
-								}
-
-								item->SetCount(item->GetCount() - 1);
-
-								LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), 1);
-								item2->AddToCharacter(this, TItemPos(INVENTORY, pos));
-
-								if (item->GetSocket(1) != 0)
-								{
-									item2->SetSocket(1, item->GetSocket(1));
-								}
-
-								item = item2;
-							}
-
-							CAffect* pAffect = FindAffect(type);
-
-							if (NULL == pAffect)
-							{
-								EPointTypes bonus = POINT_NONE;
-
-								if (true == isSpecialPotion)
-								{
-									if (type == AFFECT_AUTO_HP_RECOVERY)
-									{
-										bonus = POINT_MAX_HP_PCT;
-									}
-									else if (type == AFFECT_AUTO_SP_RECOVERY)
-									{
-										bonus = POINT_MAX_SP_PCT;
-									}
-								}
-
-								AddAffect(type, bonus, 4, item->GetID(), INFINITE_AFFECT_DURATION, 0, true, false);
-
-								item->Lock(true);
-								item->SetSocket(0, true);
-
-								AutoRecoveryItemProcess(type);
-							}
-							else
-							{
-								if (item->GetID() == pAffect->dwFlag)
-								{
-									RemoveAffect(pAffect);
-
-									item->Lock(false);
-									item->SetSocket(0, false);
-								}
-								else
-								{
-									LPITEM old = FindItemByID(pAffect->dwFlag);
-
-									if (NULL != old)
-									{
-										old->Lock(false);
-										old->SetSocket(0, false);
-									}
-
-									RemoveAffect(pAffect);
-
-									EPointTypes bonus = POINT_NONE;
-
-									if (true == isSpecialPotion)
-									{
-										if (type == AFFECT_AUTO_HP_RECOVERY)
-										{
-											bonus = POINT_MAX_HP_PCT;
-										}
-										else if (type == AFFECT_AUTO_SP_RECOVERY)
-										{
-											bonus = POINT_MAX_SP_PCT;
-										}
-									}
-
-									AddAffect(type, bonus, 4, item->GetID(), INFINITE_AFFECT_DURATION, 0, true, false);
-
-									item->Lock(true);
-									item->SetSocket(0, true);
-
-									AutoRecoveryItemProcess(type);
-								}
-							}
-						}
-						break;
-					}
-				}
-				break;
-
-				case USE_CLEAR:
-				{
-					switch (item->GetVnum())
-					{
-						case 27124: // Bandage
-							RemoveBleeding();
-							break;
-
-						case 27874: // Grilled Perch
-							RemoveBadAffect();
-							break;
-					}
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case USE_INVISIBILITY:
-				{
-					if (item->GetVnum() == 70026)
-					{
-						quest::CQuestManager& q = quest::CQuestManager::instance();
-						quest::PC* pPC = q.GetPC(GetPlayerID());
-
-						if (pPC != NULL)
-						{
-							int last_use_time = pPC->GetFlag("mirror_of_disapper.last_use_time");
-
-							if (get_global_time() - last_use_time < 10 * 60)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("아직 사용할 수 없습니다."));
-								return false;
-							}
-
-							pPC->SetFlag("mirror_of_disapper.last_use_time", get_global_time());
-						}
-					}
-
-					AddAffect(AFFECT_INVISIBILITY, POINT_NONE, 0, AFF_INVISIBILITY, 300, 0, true);
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case USE_POTION_NODELAY:
-				{
-					if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-					{
-						if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련장에서 사용하실 수 없습니다."));
-							return false;
-						}
-
-						switch (item->GetVnum())
-						{
-							case 70020:
-							case 71018:
-							case 71019:
-							case 71020:
-							{
-								if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
-								{
-									if (m_nPotionLimit <= 0)
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("사용 제한량을 초과하였습니다."));
-										return false;
-									}
-								}
-							}
-							break;
-
-							default:
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련장에서 사용하실 수 없습니다."));
-								return false;
-						}
-					}
-
-					bool bUsed = false;
-
-					if (item->GetValue(0) != 0) // HP 절대값 회복
-					{
-						if (GetHP() < GetMaxHP())
-						{
-							PointChange(POINT_HP, item->GetValue(0) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
-							EffectPacket(SE_HPUP_RED);
-							bUsed = true;
-						}
-					}
-
-					if (item->GetValue(1) != 0) // SP 절대값 회복
-					{
-						if (GetSP() < GetMaxSP())
-						{
-							PointChange(POINT_SP, item->GetValue(1) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
-							EffectPacket(SE_SPUP_BLUE);
-							bUsed = true;
-						}
-					}
-
-					if (item->GetValue(3) != 0) // HP % 회복
-					{
-						if (GetHP() < GetMaxHP())
-						{
-							PointChange(POINT_HP, item->GetValue(3) * GetMaxHP() / 100);
-							EffectPacket(SE_HPUP_RED);
-							bUsed = true;
-						}
-					}
-
-					if (item->GetValue(4) != 0) // SP % 회복
-					{
-						if (GetSP() < GetMaxSP())
-						{
-							PointChange(POINT_SP, item->GetValue(4) * GetMaxSP() / 100);
-							EffectPacket(SE_SPUP_BLUE);
-							bUsed = true;
-						}
-					}
-
-					if (bUsed)
-					{
-						if (item->GetVnum() == 50085 || item->GetVnum() == 50086)
-						{
-							if (test_server)
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("월병 또는 종자 를 사용하였습니다"));
-
-							SetUseSeedOrMoonBottleTime();
-						}
-
-						if (GetDungeon())
-							GetDungeon()->UsePotion(this);
-
-						if (GetWarMap())
-							GetWarMap()->UsePotion(this, item);
-
-						m_nPotionLimit--;
-
-						// RESTRICT_USE_SEED_OR_MOONBOTTLE
-						item->SetCount(item->GetCount() - 1);
-						// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
-					}
-				}
-				break;
-
-				case USE_POTION:
-				{
-					if (CArenaManager::instance().IsArenaMap(GetMapIndex()) == true)
-					{
-						if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련장에서 사용하실 수 없습니다."));
-							return false;
-						}
-
-						switch (item->GetVnum())
-						{
-							case 27001: // Red Potion (S)
-							case 27002: // Red Potion (M)
-							case 27003: // Red Potion (L)
-							case 27007: // Red Potion (XXL)
-							case 27004: // Blue Potion (S)
-							case 27005: // Blue Potion (M)
-							case 27006: // Blue Potion (L)
-							case 27008: // Red Potion (XXL)
-							{
-								if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
-								{
-									if (m_nPotionLimit <= 0)
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("사용 제한량을 초과하였습니다."));
-										return false;
-									}
-								}
-							}
-							break;
-
-							default:
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련장에서 사용하실 수 없습니다."));
-								return false;
-						}
-					}
-
-					if (item->GetValue(1) != 0)
-					{
-						if (GetPoint(POINT_SP_RECOVERY) + GetSP() >= GetMaxSP())
-							return false;
-
-						PointChange(POINT_SP_RECOVERY, item->GetValue(1) * MIN(200, (100 + GetPoint(POINT_POTION_BONUS))) / 100);
-						StartAffectEvent();
-						EffectPacket(SE_SPUP_BLUE);
-					}
-
-					if (item->GetValue(0) != 0)
-					{
-						if (GetPoint(POINT_HP_RECOVERY) + GetHP() >= GetMaxHP())
-							return false;
-
-						PointChange(POINT_HP_RECOVERY, item->GetValue(0) * MIN(200, (100 + GetPoint(POINT_POTION_BONUS))) / 100);
-						StartAffectEvent();
-						EffectPacket(SE_HPUP_RED);
-					}
-
-					if (GetDungeon())
-						GetDungeon()->UsePotion(this);
-
-					if (GetWarMap())
-						GetWarMap()->UsePotion(this, item);
-
-					item->SetCount(item->GetCount() - 1);
-					m_nPotionLimit--;
-				}
-				break;
-
-				case USE_POTION_CONTINUE:
-				{
-					if (item->GetValue(0) != 0)
-						AddAffect(AFFECT_HP_RECOVER_CONTINUE, POINT_HP_RECOVER_CONTINUE, item->GetValue(0), 0, item->GetValue(2), 0, true);
-					else if (item->GetValue(1) != 0)
-						AddAffect(AFFECT_SP_RECOVER_CONTINUE, POINT_SP_RECOVER_CONTINUE, item->GetValue(1), 0, item->GetValue(2), 0, true);
-					else
-						return false;
-
-					if (GetDungeon())
-						GetDungeon()->UsePotion(this);
-
-					if (GetWarMap())
-						GetWarMap()->UsePotion(this, item);
-
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case USE_ABILITY_UP:
-				{
-					if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-						return false;
-					}
-
-					switch (item->GetValue(0))
-					{
-						case APPLY_MOV_SPEED:
-						{
-							VERIFY_POTION(AFFECT_MOV_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_MOV_SPEED, POINT_MOV_SPEED, item->GetValue(2), AFF_MOV_SPEED_POTION, item->GetValue(1), 0, true);
-							EffectPacket(SE_DXUP_PURPLE);
-						}
-						break;
-
-						case APPLY_ATT_SPEED:
-						{
-							VERIFY_POTION(AFFECT_ATT_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_ATT_SPEED, POINT_ATT_SPEED, item->GetValue(2), AFF_ATT_SPEED_POTION, item->GetValue(1), 0, true);
-							EffectPacket(SE_SPEEDUP_GREEN);
-						}
-						break;
-
-						case APPLY_STR:
-						{
-							VERIFY_POTION(AFFECT_STR, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_STR, POINT_ST, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_DEX:
-						{
-							VERIFY_POTION(AFFECT_DEX, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_DEX, POINT_DX, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_CON:
-						{
-							VERIFY_POTION(AFFECT_CON, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_CON, POINT_HT, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_INT:
-						{
-							VERIFY_POTION(AFFECT_INT, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_INT, POINT_IQ, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_CAST_SPEED:
-						{
-							VERIFY_POTION(AFFECT_CAST_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_CAST_SPEED, POINT_CASTING_SPEED, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_ATT_GRADE_BONUS:
-						{
-							VERIFY_POTION(AFFECT_ATT_GRADE, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE_BONUS, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_DEF_GRADE_BONUS:
-						{
-							VERIFY_POTION(AFFECT_DEF_GRADE, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_DEF_GRADE, POINT_DEF_GRADE_BONUS, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_RESIST_MAGIC:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_MAGIC, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-#if defined(__CONQUEROR_LEVEL__)
-						case APPLY_SUNGMA_STR:
-						{
-							VERIFY_POTION(AFFECT_SUNGMA_STR, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_SUNGMA_STR, POINT_SUNGMA_STR, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_SUNGMA_HP:
-						{
-							VERIFY_POTION(AFFECT_SUNGMA_HP, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_SUNGMA_HP, POINT_SUNGMA_HP, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_SUNGMA_MOVE:
-						{
-							VERIFY_POTION(AFFECT_SUNGMA_MOVE, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_SUNGMA_MOVE, POINT_SUNGMA_MOVE, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_SUNGMA_IMMUNE:
-						{
-							VERIFY_POTION(AFFECT_SUNGMA_IMMUNE, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_SUNGMA_IMMUNE, POINT_SUNGMA_IMMUNE, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-#endif
-
-						case APPLY_ATTBONUS_MONSTER:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATTBONUS_MONSTER, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-						case APPLY_MALL_EXPBONUS:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MALL_EXPBONUS, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-						case APPLY_MELEE_MAGIC_ATTBONUS_PER:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MELEE_MAGIC_ATT_BONUS_PER, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-						case APPLY_RESIST_ICE:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_ICE, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-						case APPLY_RESIST_EARTH:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_EARTH, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-						case APPLY_RESIST_DARK:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_DARK, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-					}
-
-					if (GetDungeon())
-						GetDungeon()->UsePotion(this);
-
-					if (GetWarMap())
-						GetWarMap()->UsePotion(this, item);
-
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case USE_TALISMAN:
-				{
-					const int TOWN_PORTAL = 1;
-					const int MEMORY_PORTAL = 2;
-
-					// gm_guild_build, oxevent 맵에서 귀환부 귀환기억부 를 사용못하게 막음
-					if (GetMapIndex() == 200 || GetMapIndex() == 113)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("현재 위치에서 사용할 수 없습니다."));
-						return false;
-					}
-
-					if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 중에는 이용할 수 없는 물품입니다."));
-						return false;
-					}
-
-					if (m_pkWarpEvent)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("이동할 준비가 되어있음으로 귀환부를 사용할수 없습니다"));
-						return false;
-					}
-
-					// CONSUME_LIFE_WHEN_USE_WARP_ITEM
-					int consumeLife = CalculateConsume(this);
-
-					if (consumeLife < 0)
-						return false;
-					// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
-
-					if (item->GetValue(0) == TOWN_PORTAL) // 귀환부
-					{
-						if (item->GetSocket(0) == 0)
-						{
-							if (!GetDungeon())
-								if (!GiveRecallItem(item))
-									return false;
-
-							PIXEL_POSITION posWarp;
-
-							if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(GetMapIndex(), GetEmpire(), posWarp))
-							{
-								// CONSUME_LIFE_WHEN_USE_WARP_ITEM
-								PointChange(POINT_HP, -consumeLife, false);
-								// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
-
-								WarpSet(posWarp.x, posWarp.y);
-							}
-							else
-							{
-								sys_err("CHARACTER::UseItem : cannot find spawn position (name %s, %d x %d)", GetName(), GetX(), GetY());
-							}
-						}
-						else
-						{
-							if (test_server)
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("원래 위치로 복귀"));
-
-							ProcessRecallItem(item);
-						}
-					}
-					else if (item->GetValue(0) == MEMORY_PORTAL) // 귀환기억부
-					{
-						if (item->GetSocket(0) == 0)
-						{
-							if (GetDungeon())
-							{
-								const char* c_szConv = (g_iUseLocale ? "" : (under_han(item->GetName()) ? LC_STRING("을") : LC_STRING("를")));
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("던전 안에서는 %s%s 사용할 수 없습니다.", LC_ITEM(item->GetVnum()), c_szConv));
-								return false;
-							}
-
-							if (!GiveRecallItem(item))
-								return false;
-						}
-						else
-						{
-							// CONSUME_LIFE_WHEN_USE_WARP_ITEM
-							PointChange(POINT_HP, -consumeLife, false);
-							// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
-
-							ProcessRecallItem(item);
-						}
-					}
-				}
-				break;
-
-				case USE_TUNING:
-				case USE_DETACHMENT:
-				{
-					LPITEM item2;
-
-					if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-						return false;
-
-					if (item2->IsEquipped())
-						return false;
-
-					if (item2->IsExchanging())
-						return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-					if (item2->IsSealed())
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot improve a soulbound item."));
-						return false;
-					}
-#endif
-
-					if (PreventTradeWindow(WND_ALL))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("창고,거래창등이 열린 상태에서는 개량을 할수가 없습니다"));
-						return false;
-					}
-
-					RefineItem(item, item2);
-				}
-				break;
-
-				// ACCESSORY_REFINE & ADD/CHANGE_ATTRIBUTES
-				case USE_PUT_INTO_BELT_SOCKET:
-				case USE_PUT_INTO_RING_SOCKET:
-				case USE_PUT_INTO_ACCESSORY_SOCKET:
-				case USE_ADD_ACCESSORY_SOCKET:
-				case USE_CLEAN_SOCKET:
-				case USE_CHANGE_ATTRIBUTE:
-#if defined(__ATTR_6TH_7TH__)
-				case USE_CHANGE_ATTRIBUTE2:
-#endif
-				case USE_ADD_ATTRIBUTE:
-				case USE_ADD_ATTRIBUTE2:
-#if defined(__MOVE_COSTUME_ATTR__)
-				case USE_RESET_COSTUME_ATTR:
-				case USE_CHANGE_COSTUME_ATTR:
-#endif
-#if defined(__CHANGED_ATTR__)
-				case USE_SELECT_ATTRIBUTE:
-#endif
-				{
-					LPITEM item2;
-					if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-						return false;
-
-					if (item2->IsEquipped())
-					{
-						BuffOnAttr_RemoveBuffsFromItem(item2);
-					}
-
-					// [NOTE] 코스튬 아이템에는 아이템 최초 생성시 랜덤 속성을 부여하되, 재경재가 등등은 막아달라는 요청이 있었음.
-					// 원래 ANTI_CHANGE_ATTRIBUTE 같은 아이템 Flag를 추가하여 기획 레벨에서 유연하게 컨트롤 할 수 있도록 할 예정이었으나
-					// 그딴거 필요없으니 닥치고 빨리 해달래서 그냥 여기서 막음... -_-
-					/*
-					if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_CHANGE_ATTRIBUTE) && !item->IsSocketModifyingItem())
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the upgrade of this item."));
-						return false;
-					}
-					*/
-
-					if (ITEM_COSTUME == item2->GetType()
-#if defined(__MOVE_COSTUME_ATTR__)	
-						&& item->GetSubType() != USE_RESET_COSTUME_ATTR && item->GetSubType() != USE_CHANGE_COSTUME_ATTR
-#endif
-#if defined(__CHANGED_ATTR__)
-						&& item->GetSubType() != USE_SELECT_ATTRIBUTE
-#endif
-						)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경할 수 없는 아이템입니다."));
-						return false;
-					}
-
-					if (item2->IsExchanging() || item2->IsEquipped())
-						return false;
-
-					switch (item->GetSubType())
-					{
-						case USE_CLEAN_SOCKET:
-						{
-							int i;
-							for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-							{
-								if (item2->GetSocket(i) == ITEM_BROKEN_METIN_VNUM)
-									break;
-							}
-
-							if (i == METIN_SOCKET_MAX_NUM)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("청소할 석이 박혀있지 않습니다."));
-								return false;
-							}
-
-							int j = 0;
-
-							for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-							{
-								if (item2->GetSocket(i) != ITEM_BROKEN_METIN_VNUM && item2->GetSocket(i) != 0)
-									item2->SetSocket(j++, item2->GetSocket(i));
-							}
-
-							for (; j < METIN_SOCKET_MAX_NUM; ++j)
-							{
-								if (item2->GetSocket(j) > 0)
-									item2->SetSocket(j, 1);
-							}
-
-							{
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-								LogManager::instance().ItemLog(this, item, "CLEAN_SOCKET", buf);
-							}
-
-							if (!g_bUnlimitedCleanSocket)
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case USE_CHANGE_ATTRIBUTE:
-						{
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
-								return false;
-							}
-#endif
-
-							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_ENCHANT))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Enchant Item cannot be used on this item."));
-								return false;
-							}
-
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경할 수 없는 아이템입니다."));
-								return false;
-							}
-
-							if (item2->GetAttributeCount() == 0)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("변경할 속성이 없습니다."));
-								return false;
-							}
-
-							if (g_bChangeItemAttrCycle)
-							{
-								if (GM_PLAYER == GetGMLevel() && false == test_server)
-								{
-									//
-									// Event Flag 를 통해 이전에 아이템 속성 변경을 한 시간으로 부터 충분한 시간이 흘렀는지 검사하고
-									// 시간이 충분히 흘렀다면 현재 속성변경에 대한 시간을 설정해 준다.
-									//
-
-									DWORD dwChangeItemAttrCycle = quest::CQuestManager::instance().GetEventFlag(msc_szChangeItemAttrCycleFlag);
-									if (dwChangeItemAttrCycle < msc_dwDefaultChangeItemAttrCycle)
-										dwChangeItemAttrCycle = msc_dwDefaultChangeItemAttrCycle;
-
-									quest::PC* pPC = quest::CQuestManager::instance().GetPC(GetPlayerID());
-
-									if (pPC)
-									{
-										DWORD dwNowMin = get_global_time() / 60;
-
-										DWORD dwLastChangeItemAttrMin = pPC->GetFlag(msc_szLastChangeItemAttrFlag);
-
-										if (dwLastChangeItemAttrMin + dwChangeItemAttrCycle > dwNowMin)
-										{
-											ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 바꾼지 %d분 이내에는 다시 변경할 수 없습니다.(%d 분 남음)",
-												dwChangeItemAttrCycle, dwChangeItemAttrCycle - (dwNowMin - dwLastChangeItemAttrMin)));
-											return false;
-										}
-
-										pPC->SetFlag(msc_szLastChangeItemAttrFlag, dwNowMin);
-									}
-								}
-							}
-
-							if (item->GetVnum() == 76014)
-							{
-								int aiChangeProb[ITEM_ATTRIBUTE_MAX_LEVEL] =
-								{
-									0, 10, 50, 39, 1
-								};
-
-								item2->ChangeAttribute(aiChangeProb);
-							}
-							else
-							{
-								// 연재경 특수처리
-								// 절대로 연재가 추가 안될거라 하여 하드 코딩함.
-								if (item->GetVnum() == 71151 || item->GetVnum() == 76023)
-								{
-									if ((item2->GetType() == ITEM_WEAPON) || (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY))
-									{
-										bool bCanUse = true;
-										for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-										{
-											if (item2->GetLimitType(i) == LIMIT_LEVEL && item2->GetLimitValue(i) > 40)
-											{
-												bCanUse = false;
-												break;
-											}
-										}
-										if (false == bCanUse)
-										{
-											ChatPacket(CHAT_TYPE_INFO, LC_STRING("적용 레벨보다 높아 사용이 불가능합니다."));
-											break;
-										}
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("무기와 갑옷에만 사용 가능합니다."));
-										break;
-									}
-								}
-								item2->ChangeAttribute();
-							}
-
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경하였습니다."));
-							{
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-								LogManager::instance().ItemLog(this, item, "CHANGE_ATTRIBUTE", buf);
-							}
-
-							if (!g_bUnlimitedChangeAttributes)
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case USE_ADD_ATTRIBUTE:
-						{
-							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_REINFORCE))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Reinforce Item cannot be used on this item."));
-								return false;
-							}
-
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경할 수 없는 아이템입니다."));
-								return false;
-							}
-
-							if (item2->GetAttributeCount() < 4)
-							{
-								// 연재가 특수처리
-								// 절대로 연재가 추가 안될거라 하여 하드 코딩함.
-								if (item->GetVnum() == 71152 || item->GetVnum() == 76024)
-								{
-									if ((item2->GetType() == ITEM_WEAPON) || (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY))
-									{
-										bool bCanUse = true;
-										for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-										{
-											if (item2->GetLimitType(i) == LIMIT_LEVEL && item2->GetLimitValue(i) > 40)
-											{
-												bCanUse = false;
-												break;
-											}
-										}
-										if (false == bCanUse)
-										{
-											ChatPacket(CHAT_TYPE_INFO, LC_STRING("적용 레벨보다 높아 사용이 불가능합니다."));
-											break;
-										}
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("무기와 갑옷에만 사용 가능합니다."));
-										break;
-									}
-								}
-
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-
-								if (number(1, 100) <= aiItemAttributeAddPercent[item2->GetAttributeCount()] || g_bNeverFailAddAttributes == true)
-								{
-									item2->AddAttribute();
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성 추가에 성공하였습니다."));
-
-									int iAddedIdx = item2->GetAttributeCount() - 1;
-									LogManager::instance().ItemLog(
-										GetPlayerID(),
-										item2->GetAttributeType(iAddedIdx),
-										item2->GetAttributeValue(iAddedIdx),
-										item->GetID(),
-										"ADD_ATTRIBUTE_SUCCESS",
-										buf,
-										GetDesc()->GetHostName(),
-										item->GetOriginalVnum()
-									);
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성 추가에 실패하였습니다."));
-									LogManager::instance().ItemLog(this, item, "ADD_ATTRIBUTE_FAIL", buf);
-								}
-
-								if (!g_bUnlimitedAddAttributes)
-									item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("더이상 이 아이템을 이용하여 속성을 추가할 수 없습니다."));
-							}
-						}
-						break;
-
-						case USE_ADD_ATTRIBUTE2:
-						{
-							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_REINFORCE))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Reinforce Item cannot be used on this item."));
-								return false;
-							}
-
-							// 축복의 구슬
-							// 재가비서를 통해 속성을 4개 추가 시킨 아이템에 대해서 하나의 속성을 더 붙여준다.
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경할 수 없는 아이템입니다."));
-								return false;
-							}
-
-							// 속성이 이미 4개 추가 되었을 때만 속성을 추가 가능하다.
-							if (item2->GetAttributeCount() == 4)
-							{
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-
-								if (number(1, 100) <= aiItemAttributeAddPercent[item2->GetAttributeCount()] || g_bNeverFailAddAttributes == true)
-								{
-									item2->AddAttribute();
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성 추가에 성공하였습니다."));
-
-									int iAddedIdx = item2->GetAttributeCount() - 1;
-									LogManager::instance().ItemLog(
-										GetPlayerID(),
-										item2->GetAttributeType(iAddedIdx),
-										item2->GetAttributeValue(iAddedIdx),
-										item->GetID(),
-										"ADD_ATTRIBUTE2_SUCCESS",
-										buf,
-										GetDesc()->GetHostName(),
-										item->GetOriginalVnum()
-									);
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성 추가에 실패하였습니다."));
-									LogManager::instance().ItemLog(this, item, "ADD_ATTRIBUTE2_FAIL", buf);
-								}
-
-								if (!g_bUnlimitedAddAttributes)
-									item->SetCount(item->GetCount() - 1);
-							}
-							else if (item2->GetAttributeCount() == 5)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("더 이상 이 아이템을 이용하여 속성을 추가할 수 없습니다."));
-							}
-							else if (item2->GetAttributeCount() < 4)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("먼저 재가비서를 이용하여 속성을 추가시켜 주세요."));
-							}
-							else
-							{
-								// wtf ?!
-								sys_err("ADD_ATTRIBUTE2 : Item has wrong AttributeCount(%d)", item2->GetAttributeCount());
-							}
-						}
-						break;
-
-#if defined(__ATTR_6TH_7TH__)
-						case USE_CHANGE_ATTRIBUTE2:
-						{
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
-								return false;
-							}
-#endif
-
-							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_ENCHANT))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Enchant Item cannot be used on this item."));
-								return false;
-							}
-
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경할 수 없는 아이템입니다."));
-								return false;
-							}
-
-							if (item2->GetRareAttrCount() == 0)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("변경할 속성이 없습니다."));
-								return false;
-							}
-
-							if (number(1, 100) <= item->GetValue(0))
-							{
-								if (item2->ChangeRareAttribute())
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경하였습니다."));
-									{
-										char szBuff[21];
-										snprintf(szBuff, sizeof(szBuff), "%u", item2->GetID());
-										LogManager::instance().ItemLog(this, item, "CHANGE_ATTRIBUTE2", szBuff);
-									}
-								}
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Upgrade change failed."));
-							}
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-						case USE_ADD_ACCESSORY_SOCKET:
-						{
-							char buf[21];
-							snprintf(buf, sizeof(buf), "%u", item2->GetID());
-
-							if (item2->IsAccessoryForSocket())
-							{
-								if (item2->GetAccessorySocketMaxGrade() < ITEM_ACCESSORY_SOCKET_MAX_NUM)
-								{
-									if (number(1, 100) <= 50 || g_bNeverFailAccessorySocket == true)
-									{
-										item2->SetAccessorySocketMaxGrade(item2->GetAccessorySocketMaxGrade() + 1);
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("소켓이 성공적으로 추가되었습니다."));
-										LogManager::instance().ItemLog(this, item, "ADD_SOCKET_SUCCESS", buf);
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("소켓 추가에 실패하였습니다."));
-										LogManager::instance().ItemLog(this, item, "ADD_SOCKET_FAIL", buf);
-									}
-
-									if (!g_bUnlimitedAddAccessorySocket)
-										item->SetCount(item->GetCount() - 1);
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 액세서리에는 더이상 소켓을 추가할 공간이 없습니다."));
-								}
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템으로 소켓을 추가할 수 없는 아이템입니다."));
-							}
-						}
-						break;
-
-						case USE_PUT_INTO_BELT_SOCKET:
-						case USE_PUT_INTO_ACCESSORY_SOCKET:
-						{
-							if (item2->IsAccessoryForSocket() && item->CanPutInto(item2))
-							{
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-
-								if (item2->GetAccessorySocketGrade() < item2->GetAccessorySocketMaxGrade())
-								{
-									if (number(1, 100) <= aiAccessorySocketPutPct[item2->GetAccessorySocketGrade()] || g_bNeverFailAccessory == true)
-									{
-										item2->SetAccessorySocketGrade(item2->GetAccessorySocketGrade() + 1);
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("장착에 성공하였습니다."));
-										LogManager::instance().ItemLog(this, item, "PUT_SOCKET_SUCCESS", buf);
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("장착에 실패하였습니다."));
-										LogManager::instance().ItemLog(this, item, "PUT_SOCKET_FAIL", buf);
-									}
-
-									if (!g_bUnlimitedAddAccessory)
-										item->SetCount(item->GetCount() - 1);
-								}
-								else
-								{
-									if (item2->GetAccessorySocketMaxGrade() == 0)
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("먼저 다이아몬드로 악세서리에 소켓을 추가해야합니다."));
-									else if (item2->GetAccessorySocketMaxGrade() < ITEM_ACCESSORY_SOCKET_MAX_NUM)
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 액세서리에는 더이상 장착할 소켓이 없습니다."));
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("다이아몬드로 소켓을 추가해야합니다."));
-									}
-									else
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 액세서리에는 더이상 보석을 장착할 수 없습니다."));
-								}
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템을 장착할 수 없습니다."));
-							}
-						}
-						break;
-
-#if defined(__MOVE_COSTUME_ATTR__)
-						case USE_RESET_COSTUME_ATTR:
-						case USE_CHANGE_COSTUME_ATTR:
-						{
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
-								return false;
-							}
-#endif
-
-							if (!item2->CanChangeCostumeAttr())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경할 수 없는 아이템입니다."));
-								return false;
-							}
-
-							// NOTE: Prevent changing costumes without bonus.
-							if (item2->GetAttributeCount() == 0)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경할 수 없는 아이템입니다."));
-								return false;
-							}
-
-							switch (item->GetSubType())
-							{
-								case USE_RESET_COSTUME_ATTR:
-								{
-									item2->ClearAttribute();
-									item2->AlterToMagicItem();
-
-									char buf[21];
-									snprintf(buf, sizeof(buf), "%u", item2->GetID());
-									LogManager::instance().ItemLog(this, item, "RESET_COSTUME_ATTR", buf);
-
-									if (!g_bUnlimitedResetCostumeAttributes)
-										item->SetCount(item->GetCount() - 1);
-
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경하였습니다."));
-								}
-								break;
-
-								case USE_CHANGE_COSTUME_ATTR:
-								{
-									item2->ChangeAttribute();
-
-									char buf[21];
-									snprintf(buf, sizeof(buf), "%u", item2->GetID());
-									LogManager::instance().ItemLog(this, item, "CHANGE_COSTUME_ATTR", buf);
-
-									if (!g_bUnlimitedChangeCostumeAttributes)
-										item->SetCount(item->GetCount() - 1);
-
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경하였습니다."));
-								}
-								break;
-							}
-						}
-						break;
-#endif
-
-#if defined(__CHANGED_ATTR__)
-						case USE_SELECT_ATTRIBUTE:
-						{
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
-								return false;
-							}
-#endif
-							SelectAttr(item, item2);
-						}
-						break;
-#endif
-					}
-
-					if (item2->IsEquipped())
-					{
-						BuffOnAttr_AddBuffsFromItem(item2);
-					}
-				}
-				break;
-				// END_OF_ACCESSORY_REFINE & END_OF_ADD_ATTRIBUTES & END_OF_CHANGE_ATTRIBUTES
-
-				case USE_CALL:
-					AggregateMonster();
-					if (!g_bUnlimitedCapeOfCourage)
-						item->SetCount(item->GetCount() - 1);
-					break;
-
-				case USE_BAIT:
-				{
-					if (m_pkFishingEvent)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("낚시 중에 미끼를 갈아끼울 수 없습니다."));
-						return false;
-					}
-
-					LPITEM weapon = GetWear(WEAR_WEAPON);
-
-					if (!weapon || weapon->GetType() != ITEM_ROD)
-						return false;
-
-					if (weapon->GetSocket(2))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 꽂혀있던 미끼를 빼고 %s를 끼웁니다.", LC_ITEM(item->GetVnum())));
-					}
-					else
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("낚시대에 %s를 미끼로 끼웁니다.", LC_ITEM(item->GetVnum())));
-					}
-
-					weapon->SetSocket(2, item->GetValue(0));
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case USE_MOVE:
-				case USE_TREASURE_BOX:
-				case USE_MONEYBAG:
-					break;
-
-				case USE_AFFECT:
-				{
-#if defined(__FLOWER_EVENT__)
-					if (item->GetValue(0) == AFFECT_FLOWER_EVENT)
-						return CFlowerEvent::UseFlower(this, item);
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-					if (item->GetValue(0) == AFFECT_LATE_SUMMER_EVENT_BUFF)
-					{
-						if (FindAffect(item->GetValue(0)) || FindAffect(AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF))
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("This effect is already activated."));
-							return false;
-						}
-
-						AddAffect(item->GetValue(0), POINT_NONE, 0, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
-						item->SetCount(item->GetCount() - 1);
-						return true;
-					}
-					else if (item->GetValue(0) == AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF)
-					{
-						if (FindAffect(item->GetValue(0)) || FindAffect(AFFECT_LATE_SUMMER_EVENT_BUFF))
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("This effect is already activated."));
-							return false;
-						}
-
-						AddAffect(item->GetValue(0), POINT_NONE, 0, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
-						item->SetCount(item->GetCount() - 1);
-						return true;
-					}
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__) && defined(__PREMIUM_LOOT_FILTER__)
-					if (item->GetValue(0) == AFFECT_LOOTING_SYSTEM)
-					{
-						CAffect* pAffect = FindAffect(AFFECT_LOOTING_SYSTEM);
-						long lDuration = item->GetValue(3);
-
-						if (pAffect)
-						{
-							if (lDuration > 0)
-							{
-								if (pAffect->lDuration > LONG_MAX - lDuration)
-								{
-									sys_err("LOOT_FILTER_SYSTEM: Duration overflow, affect duration (%ld), item value3 (%ld)",
-										pAffect->lDuration, lDuration);
-									return false;
-								}
-							}
-							else
-							{
-								sys_err("LOOT_FILTER_SYSTEM: Item duration value3 (%ld) is not positive.", lDuration);
-								return false;
-							}
-
-							pAffect->bUpdate = true;
-							pAffect->lApplyValue += lDuration;
-
-							ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("Loot filter duration extended."));
-						}
-						else
-						{
-#if defined(__AFFECT_RENEWAL__)
-							AddRealTimeAffect(AFFECT_LOOTING_SYSTEM, POINT_NONE, 0, AFF_NONE, lDuration, 0, false, false);
-#else
-							AddAffect(AFFECT_LOOTING_SYSTEM, POINT_NONE, 0, AFF_NONE, lDuration, 0, false, false);
-#endif
-							ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("Loot filter activated."));
-						}
-
-						item->SetCount(item->GetCount() - 1);
-						return true;
-					}
-#endif
-
-					if (FindAffect(item->GetValue(0), aApplyInfo[item->GetValue(1)].wPointType))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-					}
-					else
-					{
-						AddAffect(item->GetValue(0), aApplyInfo[item->GetValue(1)].wPointType, item->GetValue(2), 0, item->GetValue(3), 0, false);
-						item->SetCount(item->GetCount() - 1);
-					}
-				}
-				break;
-
-				case USE_CREATE_STONE:
-				{
-					AutoGiveItem(number(28000, 28012));
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				// 물약 제조 스킬용 레시피 처리
-				case USE_RECIPE:
-				{
-					LPITEM pSource1 = FindSpecifyItem(item->GetValue(1));
-					DWORD dwSourceCount1 = item->GetValue(2);
-
-					LPITEM pSource2 = FindSpecifyItem(item->GetValue(3));
-					DWORD dwSourceCount2 = item->GetValue(4);
-
-					if (dwSourceCount1 != 0)
-					{
-						if (pSource1 == NULL)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("물약 조합을 위한 재료가 부족합니다."));
-							return false;
-						}
-					}
-
-					if (dwSourceCount2 != 0)
-					{
-						if (pSource2 == NULL)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("물약 조합을 위한 재료가 부족합니다."));
-							return false;
-						}
-					}
-
-					if (pSource1 != NULL)
-					{
-						if (pSource1->GetCount() < dwSourceCount1)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("재료(%s)가 부족합니다.", LC_ITEM(pSource1->GetVnum())));
-							return false;
-						}
-
-						pSource1->SetCount(pSource1->GetCount() - dwSourceCount1);
-					}
-
-					if (pSource2 != NULL)
-					{
-						if (pSource2->GetCount() < dwSourceCount2)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("재료(%s)가 부족합니다.", LC_ITEM(pSource2->GetVnum())));
-							return false;
-						}
-
-						pSource2->SetCount(pSource2->GetCount() - dwSourceCount2);
-					}
-
-					LPITEM pBottle = FindSpecifyItem(50901);
-
-					if (!pBottle || pBottle->GetCount() < 1)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("빈 병이 모자릅니다."));
-						return false;
-					}
-
-					pBottle->SetCount(pBottle->GetCount() - 1);
-
-					if (number(1, 100) > item->GetValue(5))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("물약 제조에 실패했습니다."));
-						return false;
-					}
-
-					AutoGiveItem(item->GetValue(0));
-				}
-				break;
-			}
-		}
-		break;
-
-		case ITEM_METIN:
-		{
-			LPITEM item2;
-
-			if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-				return false;
-
-			if (item2->IsExchanging())
-				return false;
-
-			if (item2->IsEquipped())
-				return false;
-
-			if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_APPLY))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("This Spirit Stone cannot be attached to this type of item."));
-				return false;
-			}
-
-			if (item2->GetType() == ITEM_PICK)
-				return false;
-
-			if (item2->GetType() == ITEM_ROD)
-				return false;
-
-			int i;
-
-			for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-			{
-				DWORD dwVnum;
-
-				if ((dwVnum = item2->GetSocket(i)) <= 2)
-					continue;
-
-				const TItemTable* p = ITEM_MANAGER::instance().GetTable(dwVnum);
-
-				if (!p)
-					continue;
-
-				if (item->GetValue(5) == p->alValues[5]
-#if defined(__GLOVE_SYSTEM__)
-					&& item->GetSubType() != METIN_SUNGMA
-#endif
-					)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("같은 종류의 메틴석은 여러개 부착할 수 없습니다."));
-					return false;
-				}
-			}
-
-			if (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY)
-			{
-				if (!IS_SET(item->GetWearFlag(), WEARABLE_BODY) || !IS_SET(item2->GetWearFlag(), WEARABLE_BODY))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 메틴석은 장비에 부착할 수 없습니다."));
-					return false;
-				}
-			}
-#if defined(__GLOVE_SYSTEM__)
-			else if (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_GLOVE)
-			{
-				if (!IS_SET(item->GetWearFlag(), WEARABLE_GLOVE) || !IS_SET(item2->GetWearFlag(), WEARABLE_GLOVE))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 메틴석은 장비에 부착할 수 없습니다."));
-					return false;
-				}
-			}
-#endif
-			else if (item2->GetType() == ITEM_WEAPON)
-			{
-				if (!IS_SET(item->GetWearFlag(), WEARABLE_WEAPON))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 메틴석은 무기에 부착할 수 없습니다."));
-					return false;
-				}
-			}
-			else
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("부착할 수 있는 슬롯이 없습니다."));
-				return false;
-			}
-
-			for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-			{
-				if (item2->GetSocket(i) >= 1 && item2->GetSocket(i) <= 2 && item2->GetSocket(i) >= item->GetValue(2))
-				{
-					// 석 확률
-					if (number(1, 100) <= 30 || g_bNeverFailMetin == true)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("메틴석 부착에 성공하였습니다."));
-
-#if defined(__GLOVE_SYSTEM__)
-						DWORD dwValue = item->GetVnum();
-						if (item->GetSubType() == METIN_SUNGMA)
-						{
-							bool bMultiplier = false;
-							if (item->GetValue(5) == 2 && number(1, 100) <= 30)
-							{
-								bMultiplier = true;
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Perfect! You have attached the Spirit Stone successfully and you even receive a double stat bonus."));
-							}
-							dwValue = item2->GetRandomSungMaSocketValue(item->GetValue(5), item->GetRefineLevel(), bMultiplier);
-						}
-						item2->SetSocket(i, dwValue);
-#else
-						item2->SetSocket(i, item->GetVnum());
-#endif
-					}
-					else
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("메틴석 부착에 실패하였습니다."));
-						item2->SetSocket(i, ITEM_BROKEN_METIN_VNUM);
-					}
-
-					LogManager::instance().ItemLog(this, item2, "SOCKET", item->GetName());
-					item->SetCount(item->GetCount() - 1);
-					break;
-				}
-			}
-
-			if (i == METIN_SOCKET_MAX_NUM)
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("부착할 수 있는 슬롯이 없습니다."));
-		}
-		break;
-
-		case ITEM_AUTOUSE:
-		case ITEM_MATERIAL:
-		case ITEM_SPECIAL:
-		case ITEM_TOOL:
-		case ITEM_LOTTERY:
-			break;
-
-		case ITEM_TOTEM:
-		{
-			if (!item->IsEquipped())
-				EquipItem(item);
-		}
-		break;
-
-		case ITEM_BLEND:
-		{
-			// 새로운 약초들
-			sys_log(0, "ITEM_BLEND!!");
-
-			if (Blend_Item_find(item->GetVnum()))
-			{
-				int affect_type = AFFECT_BLEND;
-				int apply_type = aApplyInfo[item->GetSocket(0)].wPointType;
-				int apply_value = item->GetSocket(1);
-				int apply_duration = item->GetSocket(2);
-
-				if (FindAffect(affect_type, apply_type))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-				}
-				else
-				{
-					if (FindAffect(AFFECT_EXP_BONUS_EURO_FREE, POINT_RESIST_MAGIC))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 효과가 걸려 있습니다."));
-					}
-					else
-					{
-						AddAffect(affect_type, apply_type, apply_value, 0, apply_duration, 0, false);
-						item->SetCount(item->GetCount() - 1);
-					}
-				}
-			}
-		}
-		break;
-
-		case ITEM_EXTRACT:
-		{
-			LPITEM pDestItem = GetItem(DestCell);
-			if (NULL == pDestItem)
-				return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-			if (item->IsSealed())
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
-				return false;
-			}
-#endif
-
-			switch (item->GetSubType())
-			{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-				case EXTRACT_DRAGON_SOUL:
-				{
-					if (pDestItem->IsDragonSoul())
-						return DSManager::instance().PullOut(this, NPOS, pDestItem, item);
-					return false;
-				}
-				case EXTRACT_DRAGON_HEART:
-				{
-					if (pDestItem->IsDragonSoul())
-						return DSManager::instance().ExtractDragonHeart(this, pDestItem, item);
-					return false;
-				}
-#endif
-				default:
-					return false;
-			}
-		}
-		break;
-
-#if defined(__GACHA_SYSTEM__)
-		case ITEM_GACHA:
-		{
-			switch (item->GetSubType())
-			{
-				case USE_GACHA:
-				{
-					if (GiveItemFromSpecialItemGroup(item->GetVnum()))
-					{
-						if (item->GetSocket(0) > 1)
-							item->SetSocket(0, item->GetSocket(0) - 1);
-						else
-							ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (ITEM_GACHA)");
-					}
-				}
-				break;
-
-#if defined(__LUCKY_BOX__)
-				case GEM_LUCKY_BOX_GACHA:
-				case SPECIAL_LUCKY_BOX_GACHA:
-					SetLuckyBoxSrcItem(item);
-					break;
-#endif
-			}
-		}
-		break;
-#endif
-
-#if defined(__SOUL_SYSTEM__)
-		case ITEM_SOUL:
-		{
-			struct SoulData
-			{
-				WORD point_type;
-				DWORD affect_flag;
-			};
-			std::unordered_map<BYTE, SoulData> soul_map
-			{
-				{ RED_SOUL, { AFF_SOUL_RED, AFF_SOUL_RED }, },
-				{ BLUE_SOUL, { AFF_SOUL_BLUE, AFF_SOUL_BLUE }, },
-			};
-
-			const auto& it = soul_map.find(item->GetSubType());
-			if (it == soul_map.end())
-			{
-				sys_err("ITEM_SOUL: Unknown SubType");
-				return false;
-			}
-
-			const auto& soul = it->second;
-
-			CAffect* affect = nullptr;
-			for (auto const& it : GetAffectContainer())
-			{
-				if (it != nullptr && it->dwType == AFFECT_SOUL)
-				{
-					if (it->wApplyOn == soul.point_type)
-					{
-						if (item->GetSocket(1) != TRUE)
-						{
-							ChatPacket(CHAT_TYPE_INFO, "The soul color is already beeing used.");
-							return false;
-						}
-					}
-
-					affect = it;
-					continue;
-				}
-			}
-
-			if (item->GetSocket(1) != TRUE)
-			{
-				AddAffect(AFFECT_SOUL, soul.point_type, item->GetID(), affect ? AFF_NONE : soul.affect_flag, item->GetSocket(0), 0, false/*override*/);
-
-				if (affect)
-				{
-					std::vector<CAffect> tmp_affects;
-					std::vector<CAffect*> to_remove;
-					for (const auto& [k, v] : soul_map)
-					{
-						CAffect* affect = FindAffect(AFFECT_SOUL, v.point_type);
-						if (affect)
-						{
-							tmp_affects.emplace_back(*affect);
-							to_remove.emplace_back(affect);
-						}
-					}
-
-					if (!to_remove.empty())
-					{
-						for (const auto& it : to_remove)
-							RemoveAffect(it);
-					}
-
-					if (!tmp_affects.empty())
-					{
-						for (const auto& it : tmp_affects)
-							AddAffect(it.dwType, it.wApplyOn, it.lApplyValue, AFF_NONE, it.lDuration, 0, false/*override*/);
-					}
-
-					AddAffect(AFFECT_SOUL, AFF_SOUL_MIX, 0, AFF_SOUL_MIX, item->GetSocket(0), 0, false/*override*/);
-				}
-
-				item->SetSocket(1, TRUE);
-				item->Lock(true);
-			}
-			else
-			{
-				RemoveAffect(AFFECT_SOUL, soul.point_type);
-				RemoveAffect(AFFECT_SOUL, AFF_SOUL_MIX); // AFF_SOUL_MIX
-
-				std::vector<CAffect> tmp_affects;
-				std::vector<CAffect*> to_remove;
-				for (const auto& affect : GetAffectContainer())
-				{
-					if (affect != nullptr && affect->dwType == AFFECT_SOUL)
-					{
-						tmp_affects.emplace_back(*affect);
-						to_remove.emplace_back(affect);
-					}
-				}
-
-				for (const auto& affect : to_remove)
-					RemoveAffect(affect);
-
-				if (!tmp_affects.empty())
-				{
-					for (const auto& affect : tmp_affects)
-					{
-						auto it = std::find_if(soul_map.begin(), soul_map.end(), [&](const auto& kv_pair) {
-							return kv_pair.second.point_type == affect.wApplyOn;
-							});
-
-						if (it != soul_map.end())
-							AddAffect(affect.dwType, affect.wApplyOn, affect.lApplyValue, it->second.affect_flag, affect.lDuration, 0, false/*override*/);
-					}
-				}
-
-				item->SetSocket(1, FALSE);
-				item->Lock(false);
-			}
-		}
-		break;
-#endif
-
-		case ITEM_NONE:
-			sys_err("Item type NONE %s", item->GetName());
-			break;
-
-		default:
-			sys_log(0, "UseItemEx: Unknown type %s %d", item->GetName(), item->GetType());
-			return false;
-	}
-
-	return true;
-}
-
-int g_nPortalLimitTime = 10;
-
-bool CHARACTER::UseItem(TItemPos Cell, TItemPos DestCell)
-{
-	WORD wCell = Cell.cell;
-	BYTE window_type = Cell.window_type;
-
-	//WORD wDestCell = DestCell.cell;
-	//BYTE bDestInven = DestCell.window_type;
-
-	LPITEM item;
-
-	if (!CanHandleItem())
-		return false;
-
-	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
-		return false;
-
-	// We don't want to use it if we are dragging it over another item of the same type...
-	LPITEM destItem = GetItem(DestCell);
-	if (destItem && item != destItem && destItem->IsStackable() && !IS_SET(destItem->GetAntiFlag(), ITEM_ANTIFLAG_STACK) && destItem->GetVnum() == item->GetVnum())
-	{
-		if (MoveItem(Cell, DestCell, 0))
-			return false;
-	}
-
-	sys_log(0, "%s: USE_ITEM %s (inven %d, cell: %d)", GetName(), item->GetName(), window_type, wCell);
-
-	if (item->IsExchanging())
-		return false;
-
-	if (!item->CanUsedBy(this))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("군직이 맞지않아 이 아이템을 사용할 수 없습니다."));
-		return false;
-	}
-
-	if (IsStun())
-		return false;
-
-	if (false == FN_check_item_sex(this, item))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("성별이 맞지않아 이 아이템을 사용할 수 없습니다."));
-		return false;
-	}
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use items while modifying your pet's stats."));
-		return false;
-	}
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum = item->GetTransmutationVnum();
-	if (dwTransmutationVnum != 0)
-	{
-		TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwTransmutationVnum);
-
-		if (!pItemTable->CanUseByJob(GetJob()))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your class."));
-			return false;
-		}
-
-#	if defined(__COSTUME_SYSTEM__)
-		if (pItemTable && pItemTable->IsCostume())
-		{
-			if ((IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_MALE) && SEX_MALE == GET_SEX(this)) ||
-				(IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_FEMALE) && SEX_FEMALE == GET_SEX(this)))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your gender."));
-				return false;
-			}
-		}
-	}
-#	endif
-#endif
-
-	// PREVENT_TRADE_WINDOW
-	if (IS_SUMMON_ITEM(item, GetMapIndex()))
-	{
-		if (false == IS_SUMMONABLE_ZONE(GetMapIndex()))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item here."));
-			return false;
-		}
-
-		// 경혼반지 사용지 상대방이 SUMMONABLE_ZONE에 있는가는 WarpToPC()에서 체크
-
-		// 삼거리 관려 맵에서는 귀환부를 막아버린다.
-		if (CThreeWayWar::instance().IsThreeWayWarMapIndex(GetMapIndex()))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("삼거리 전투 참가중에는 귀환부,귀환기억부를 사용할수 없습니다."));
-			return false;
-		}
-
-		int iPulse = thecore_pulse();
-
-		// 창고 연후 체크
-		if (iPulse - GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("창고를 연후 %d초 이내에는 귀환부,귀환기억부를 사용할 수 없습니다.", g_nPortalLimitTime));
-
-			if (test_server)
-				ChatPacket(CHAT_TYPE_INFO, "[TestOnly]Pulse %d LoadTime %d PASS %d", iPulse, GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
-			return false;
-		}
-
-		// 거래관련 창 체크
-		if (PreventTradeWindow(WND_ALL))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("거래창,창고 등을 연 상태에서는 귀환부,귀환기억부 를 사용할수 없습니다."));
-			return false;
-		}
-
-		// PREVENT_REFINE_HACK
-		// 개량후 시간체크
-		{
-			if (iPulse - GetRefineTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 개량후 %d초 이내에는 귀환부,귀환기억부를 사용할 수 없습니다.", g_nPortalLimitTime));
-				return false;
-			}
-		}
-		// END_PREVENT_REFINE_HACK
-
-		// PREVENT_ITEM_COPY
-		{
-			if (iPulse - GetMyShopTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("개인상점 사용후 %d초 이내에는 귀환부,귀환기억부를 사용할 수 없습니다.", g_nPortalLimitTime));
-				return false;
-			}
-
-#if defined(__MAILBOX__)
-			if (iPulse - GetMyMailBoxTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-			{
-				ChatPacket(CHAT_TYPE_INFO, "You cannot use a Return Scroll %d seconds after opening a mailbox.", g_nPortalLimitTime);
-				return false;
-			}
-#endif
-		}
-		// END_PREVENT_ITEM_COPY
-
-		// 귀환부 거리체크
-		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TALISMAN)
-		{
-			PIXEL_POSITION posWarp;
-
-			int x = 0;
-			int y = 0;
-
-			double nDist = 0;
-			const double nDistant = 5000.0;
-
-			// 귀환기억부
-			if (item->GetVnum() == 22010)
-			{
-				x = item->GetSocket(0) - GetX();
-				y = item->GetSocket(1) - GetY();
-			}
-			// 귀환부
-			else if (item->GetVnum() == 22000)
-			{
-				SECTREE_MANAGER::instance().GetRecallPositionByEmpire(GetMapIndex(), GetEmpire(), posWarp);
-
-				if (item->GetSocket(0) == 0)
-				{
-					x = posWarp.x - GetX();
-					y = posWarp.y - GetY();
-				}
-				else
-				{
-					x = item->GetSocket(0) - GetX();
-					y = item->GetSocket(1) - GetY();
-				}
-			}
-
-			nDist = sqrt(pow((float)x, 2) + pow((float)y, 2));
-
-			if (nDistant > nDist)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("이동 되어질 위치와 너무 가까워 귀환부를 사용할수 없습니다."));
-				if (test_server)
-					ChatPacket(CHAT_TYPE_INFO, "PossibleDistant %f nNowDist %f", nDistant, nDist);
-				return false;
-			}
-		}
-
-		// PREVENT_PORTAL_AFTER_EXCHANGE
-		// 교환 후 시간체크
-		if (iPulse - GetExchangeTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("거래 후 %d초 이내에는 귀환부,귀환기억부등을 사용할 수 없습니다.", g_nPortalLimitTime));
-			return false;
-		}
-		// END_PREVENT_PORTAL_AFTER_EXCHANGE
-	}
-
-	// 보따리 비단 사용시 거래창 제한 체크
-	if ((item->GetVnum() == 50200) || (item->GetVnum() == 71049))
-	{
-		if (PreventTradeWindow(WND_ALL))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("거래창,창고 등을 연 상태에서는 보따리,비단보따리를 사용할수 없습니다."));
-			return false;
-		}
-	}
-	// END_PREVENT_TRADE_WINDOW
-
-	if (IsRunningQuest())
-		return false;
-
-	if (IS_SET(item->GetFlag(), ITEM_FLAG_LOG)) // 사용 로그를 남기는 아이템 처리
-	{
-		DWORD vid = item->GetVID();
-		DWORD oldCount = item->GetCount();
-		DWORD vnum = item->GetVnum();
-
-		char hint[ITEM_NAME_MAX_LEN + 32 + 1];
-		int len = snprintf(hint, sizeof(hint) - 32, "%s", item->GetName());
-
-		if (len < 0 || len >= (int)sizeof(hint) - 32)
-			len = (sizeof(hint) - 32) - 1;
-
-		bool ret = UseItemEx(item, DestCell);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		if (ret and item->GetType() == ITEM_USE or ret and item->GetType() == ITEM_SKILLBOOK or ret and item->GetType() == ITEM_GIFTBOX)
-			UpdateExtBattlePassMissionProgress(BP_ITEM_USE, 1, item->GetVnum());
-#endif
-
-		if (NULL == ITEM_MANAGER::instance().FindByVID(vid)) // UseItemEx에서 아이템이 삭제 되었다. 삭제 로그를 남김
-		{
-			LogManager::instance().ItemLog(this, vid, vnum, "REMOVE", hint);
-		}
-		else if (oldCount != item->GetCount())
-		{
-			snprintf(hint + len, sizeof(hint) - len, " %u", oldCount - 1);
-			LogManager::instance().ItemLog(this, vid, vnum, "USE_ITEM", hint);
-		}
-		return (ret);
-	}
-	else
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	{
-		bool ret = UseItemEx(item, DestCell);
-
-		if (ret and item->GetType() == ITEM_USE or ret and item->GetType() == ITEM_SKILLBOOK or ret and item->GetType() == ITEM_GIFTBOX)
-			UpdateExtBattlePassMissionProgress(BP_ITEM_USE, 1, item->GetVnum());
-		
-		return (ret);
-	}
-#else
-		return UseItemEx(item, DestCell);
-#endif
-}
-
-bool CHARACTER::DropItem(TItemPos Cell, WORD wCount)
-{
-	LPITEM item = NULL;
-
-	if (!CanHandleItem())
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (NULL != DragonSoul_RefineWindow_GetOpener())
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("강화창을 연 상태에서는 아이템을 옮길 수 없습니다."));
-#endif
-		return false;
-	}
-
-	if (IsDead())
-		return false;
-
-	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
-		return false;
-
-	if (item->IsExchanging())
-		return false;
-
-	if (true == item->isLocked())
-		return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (item->IsSealed())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot drop a soulbound item."));
-		return false;
-	}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot drop items while modifying your pet's stats."));
-		return false;
-	}
-#endif
-
-	if (IsRunningQuest())
-		return false;
-
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DROP | ITEM_ANTIFLAG_GIVE))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("버릴 수 없는 아이템입니다."));
-		return false;
-	}
-
-	if (wCount == 0 || wCount > item->GetCount())
-		wCount = item->GetCount();
-
-	// Quickslot 에서 지움
-	if (INVENTORY == Cell.window_type)
-		SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, WORD_MAX);
-	else if (BELT_INVENTORY == Cell.window_type)
-		SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, WORD_MAX);
-
-	LPITEM pkItemToDrop;
-
-	if (wCount == item->GetCount())
-	{
-		item->RemoveFromCharacter();
-		pkItemToDrop = item;
-	}
-	else
-	{
-		if (wCount == 0)
-		{
-			if (test_server)
-				sys_log(0, "[DROP_ITEM] drop item count == 0");
-			return false;
-		}
-
-		item->SetCount(item->GetCount() - wCount);
-		ITEM_MANAGER::instance().FlushDelayedSave(item);
-
-		pkItemToDrop = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), wCount);
-
-		// Copy item socket -- by mhh
-		FN_copy_item_socket(pkItemToDrop, item);
-
-		char szBuf[51 + 1];
-		snprintf(szBuf, sizeof(szBuf), "%u %u", pkItemToDrop->GetID(), pkItemToDrop->GetCount());
-		LogManager::instance().ItemLog(this, item, "ITEM_SPLIT", szBuf);
-	}
-
-	PIXEL_POSITION pxPos = GetXYZ();
-
-	if (pkItemToDrop->AddToGround(GetMapIndex(), pxPos))
-	{
-		// 한국에는 아이템을 버리고 복구해달라는 진상유저들이 많아서
-		// 아이템을 바닥에 버릴 시 속성로그를 남긴다.
-		if (LC_IsYMIR())
-			item->AttrLog();
-
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("떨어진 아이템은 3분 후 사라집니다."));
-		pkItemToDrop->StartDestroyEvent();
-
-		ITEM_MANAGER::instance().FlushDelayedSave(pkItemToDrop);
-
-		char szHint[32 + 1];
-		snprintf(szHint, sizeof(szHint), "%s %u %u", pkItemToDrop->GetName(), pkItemToDrop->GetCount(), pkItemToDrop->GetOriginalVnum());
-		LogManager::instance().ItemLog(this, pkItemToDrop, "DROP", szHint);
-		//Motion(MOTION_PICKUP);
-	}
-
-	return true;
-}
-
-#if defined(__NEW_DROP_DIALOG__)
-bool CHARACTER::DestroyItem(TItemPos Cell)
-{
-	LPITEM item = NULL;
-
-	if (!CanHandleItem())
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (NULL != DragonSoul_RefineWindow_GetOpener())
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("강화창을 연 상태에서는 아이템을 옮길 수 없습니다."));
-#endif
-		return false;
-	}
-
-	if (IsDead())
-		return false;
-
-	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
-		return false;
-
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DESTROY))
-		return false;
-
-	if (item->IsExchanging())
-		return false;
-
-	if (true == item->isLocked())
-		return false;
-
-	if (IsRunningQuest())
-		return false;
-
-	if (item->GetCount() <= 0)
-		return false;
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	UpdateExtBattlePassMissionProgress(BP_ITEM_DESTROY, 1, item->GetVnum());
-#endif
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (item->IsSealed())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot destroy a soulbound item."));
-		return false;
-	}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (item->IsPet())
-		return false;
-#endif
-
-	if (INVENTORY == Cell.window_type)
-		SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, WORD_MAX);
-	else if (BELT_INVENTORY == Cell.window_type)
-		SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, WORD_MAX);
-
-	ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have deleted %s.", LC_ITEM(item->GetVnum())));
-	ITEM_MANAGER::instance().RemoveItem(item, "DESTROYED BY PLAYER");
-
-	return true;
-}
-#endif
-
-bool CHARACTER::DropGold(int iAmount)
-{
-	if (iAmount <= 0 || iAmount > GetGold())
-		return false;
-
-	if (!CanHandleItem())
-		return false;
-
-	if (0 != g_GoldDropTimeLimitValue)
-	{
-		if (get_dword_time() < m_dwLastGoldDropTime + g_GoldDropTimeLimitValue)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("아직 골드를 버릴 수 없습니다."));
-			return false;
-		}
-	}
-
-	m_dwLastGoldDropTime = get_dword_time();
-
-	LPITEM item = ITEM_MANAGER::instance().CreateItem(1, iAmount);
-
-	if (item)
-	{
-		PIXEL_POSITION pos = GetXYZ();
-
-		if (item->AddToGround(GetMapIndex(), pos))
-		{
-			//Motion(MOTION_PICKUP);
-			PointChange(POINT_GOLD, -iAmount, true);
-
-			// 브라질에 돈이 없어진다는 버그가 있는데,
-			// 가능한 시나리오 중에 하나는,
-			// 메크로나, 핵을 써서 1000원 이하의 돈을 계속 버려 골드를 0으로 만들고,
-			// 돈이 없어졌다고 복구 신청하는 것일 수도 있다.
-			// 따라서 그런 경우를 잡기 위해 낮은 수치의 골드에 대해서도 로그를 남김.
-			if (LC_IsBrazil() == true)
-			{
-				if (iAmount >= 213)
-					LogManager::instance().CharLog(this, iAmount, "DROP_GOLD", "");
-			}
-			else
-			{
-				if (iAmount > 1000) // 천원 이상만 기록한다.
-					LogManager::instance().CharLog(this, iAmount, "DROP_GOLD", "");
-			}
-
-			if (false == LC_IsBrazil())
-			{
-				item->StartDestroyEvent(150);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("떨어진 아이템은 %d분 후 사라집니다.", 150 / 60));
-			}
-			else
-			{
-				item->StartDestroyEvent(60);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("떨어진 아이템은 %d분 후 사라집니다.", 1));
-			}
-		}
-
-		Save();
-		return true;
-	}
-
-	return false;
-}
-
-#if defined(__CHEQUE_SYSTEM__)
-bool CHARACTER::DropCheque(int cheque)
-{
-	if (cheque <= 0 || (long long)cheque > GetCheque())
-		return false;
-
-	if (!CanHandleItem())
-		return false;
-
-	if (0 != g_ChequeDropTimeLimitValue)
-	{
-		if (get_dword_time() < m_dwLastChequeDropTime + g_ChequeDropTimeLimitValue)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("아직 골드를 버릴 수 없습니다."));
-			return false;
-		}
-	}
-
-	m_dwLastChequeDropTime = get_dword_time();
-
-	LPITEM item = ITEM_MANAGER::instance().CreateItem(80020, cheque);
-
-	if (item)
-	{
-		PIXEL_POSITION pos = GetXYZ();
-
-		if (item->AddToGround(GetMapIndex(), pos))
-		{
-			PointChange(POINT_CHEQUE, -cheque, true);
-
-			if (cheque > 1000)
-				LogManager::instance().CharLog(this, cheque, "DROP_CHEQUE", "");
-
-			if (false == LC_IsBrazil())
-			{
-				item->StartDestroyEvent(150);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("떨어진 아이템은 %d분 후 사라집니다.", 150 / 60));
-			}
-			else
-			{
-				item->StartDestroyEvent(60);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("떨어진 아이템은 %d분 후 사라집니다.", 1));
-			}
-		}
-
-		Save();
-		return true;
-	}
-
-	return false;
-}
-#endif
-
-bool CHARACTER::MoveItem(TItemPos Cell, TItemPos DestCell, WORD count)
-{
-	LPITEM item = nullptr;
-
-	if (Cell.IsSameItemPosition(DestCell))
-		return false;
-
-	if (!IsValidItemPosition(Cell))
-		return false;
-
-	if (!(item = GetItem(Cell)))
-		return false;
-
-	if (item->IsExchanging())
-		return false;
-
-	if (item->GetCount() < count)
-		return false;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	if (INVENTORY == Cell.window_type && Cell.cell >= GetExtendInvenMax() && IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-		return false;
-#else
-	if (INVENTORY == Cell.window_type && Cell.cell >= INVENTORY_MAX_NUM && IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-		return false;
-#endif
-
-	if (true == item->isLocked())
-		return false;
-
-	if (!IsValidItemPosition(DestCell))
-		return false;
-
-	if (!CanHandleItem())
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (DragonSoul_RefineWindow_GetOpener())
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("강화창을 연 상태에서는 아이템을 옮길 수 없습니다."));
-#endif
-		return false;
-	}
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot move items while modifying your pet's stats."));
-		return false;
-	}
-#endif
-
-	if (DestCell.IsBeltInventoryPosition())
-	{
-		// At the request of the planner, only certain types of items can be placed in the belt inventory.
-		if (!CBeltInventoryHelper::CanMoveIntoBeltInventory(item))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템은 벨트 인벤토리로 옮길 수 없습니다."));
-			return false;
-		}
-	}
-
-	// 이미 착용중인 아이템을 다른 곳으로 옮기는 경우, '장책 해제' 가능한 지 확인하고 옮김
-	if (Cell.IsEquipPosition())
-	{
-		if (!CanUnequipNow(item))
-			return false;
-
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-		const int iWearCell = item->FindEquipCell(this);
-		if (iWearCell == WEAR_WEAPON)
-		{
-			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
-			if (pkCostumeWeapon)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
-				return false;
-			}
-		}
-#endif
-	}
-
-	if (DestCell.IsEquipPosition())
-	{
-		if (GetItem(DestCell)
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			&& DestCell.IsDragonSoulEquipPosition()
-#endif
-			) // 장비일 경우 한 곳만 검사해도 된다.
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 장비를 착용하고 있습니다."));
-			return false;
-		}
-
-		EquipItem(item, DestCell.cell);
-	}
-	else
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-		{
-			if (item->IsEquipped())
-			{
-				return DSManager::instance().PullOut(this, DestCell, item);
-			}
-			else
-			{
-				if (DestCell.window_type != DRAGON_SOUL_INVENTORY)
-				{
-					return false;
-				}
-
-				if (!DSManager::instance().IsValidCellForThisItem(item, DestCell))
-					return false;
-			}
-		}
-		// 용혼석이 아닌 아이템은 용혼석 인벤에 들어갈 수 없다.
-		else if (DRAGON_SOUL_INVENTORY == DestCell.window_type)
-			return false;
-#endif
-
-		LPITEM item2;
-
-		if ((item2 = GetItem(DestCell)) && item != item2 && item2->IsStackable() &&
-			!IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_STACK) &&
-			item2->GetVnum() == item->GetVnum() && !item2->IsExchanging()) // 합칠 수 있는 아이템의 경우
-		{
-			for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-				if (item2->GetSocket(i) != item->GetSocket(i))
-					return false;
-
-			if (count == 0)
-				count = item->GetCount();
-
-			sys_log(0, "%s: ITEM_STACK %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell,
-				DestCell.window_type, DestCell.cell, count);
-
-			count = MIN(ITEM_MAX_COUNT - item2->GetCount(), count);
-
-			item->SetCount(item->GetCount() - count);
-			item2->SetCount(item2->GetCount() + count);
-
-			return true;
-		}
-
-		if (!IsEmptyItemGrid(DestCell, item->GetSize(), Cell.cell))
-		{
-			return false;
-		}
-
-		if (count == 0 || count >= item->GetCount() || !item->IsStackable() || IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-		{
-			sys_log(0, "%s: ITEM_MOVE %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell,
-				DestCell.window_type, DestCell.cell, count);
-
-			item->RemoveFromCharacter();
-			SetItem(DestCell, item);
-
-			if (INVENTORY == Cell.window_type && INVENTORY == DestCell.window_type)
-				SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, DestCell.cell);
-			else if (BELT_INVENTORY == Cell.window_type && BELT_INVENTORY == DestCell.window_type)
-				SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, DestCell.cell);
-
-			else if (INVENTORY == Cell.window_type && BELT_INVENTORY == DestCell.window_type)
-				MoveQuickSlotItem(SLOT_TYPE_INVENTORY, Cell.cell, SLOT_TYPE_BELT_INVENTORY, DestCell.cell);
-			else if (BELT_INVENTORY == Cell.window_type && INVENTORY == DestCell.window_type)
-				MoveQuickSlotItem(SLOT_TYPE_BELT_INVENTORY, Cell.cell, SLOT_TYPE_INVENTORY, DestCell.cell);
-		}
-		else if (count < item->GetCount())
-		{
-			sys_log(0, "%s: ITEM_SPLIT %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell, DestCell.window_type, DestCell.cell, count);
-
-			item->SetCount(item->GetCount() - count);
-			LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), count);
-
-			// Copy socket -- by mhh
-			FN_copy_item_socket(item2, item);
-
-			item2->AddToCharacter(this, DestCell);
-
-			char szBuf[51 + 1];
-			snprintf(szBuf, sizeof(szBuf), "%u %u %u %u ", item2->GetID(), item2->GetCount(), item->GetCount(), item->GetCount() + item2->GetCount());
-			LogManager::instance().ItemLog(this, item, "ITEM_SPLIT", szBuf);
-		}
-	}
-
-	return true;
-}
-
-namespace NPartyPickupDistribute
-{
-	struct FFindOwnership
-	{
-		LPITEM item;
-		LPCHARACTER owner;
-
-		FFindOwnership(LPITEM item)
-			: item(item), owner(NULL)
-		{
-		}
-
-		void operator () (LPCHARACTER ch)
-		{
-			if (item->IsOwnership(ch))
-				owner = ch;
-		}
-	};
-
-	struct FCountNearMember
-	{
-		int total;
-		int x, y;
-
-		FCountNearMember(LPCHARACTER center)
-			: total(0), x(center->GetX()), y(center->GetY())
-		{
-		}
-
-		void operator () (LPCHARACTER ch)
-		{
-			if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
-				total += 1;
-		}
-	};
-
-	struct FMoneyDistributor
-	{
-		int total;
-		LPCHARACTER c;
-		int x, y;
-		int iMoney;
-
-		FMoneyDistributor(LPCHARACTER center, int iMoney)
-			: total(0), c(center), x(center->GetX()), y(center->GetY()), iMoney(iMoney)
-		{
-		}
-
-		void operator ()(LPCHARACTER ch)
-		{
-			if (ch != c)
-				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
-				{
-					ch->PointChange(POINT_GOLD, iMoney, true);
-
-					if (iMoney > 1000) // 천원 이상만 기록한다.
-						LogManager::instance().CharLog(ch, iMoney, "GET_GOLD", "");
-				}
-		}
-	};
-
-#if defined(__CHEQUE_SYSTEM__)
-	struct FChequeDistributor
-	{
-		int total;
-		LPCHARACTER c;
-		int x, y;
-		int iCheque;
-
-		FChequeDistributor(LPCHARACTER center, int iCheque)
-			: total(0), c(center), x(center->GetX()), y(center->GetY()), iCheque(iCheque)
-		{
-		}
-
-		void operator ()(LPCHARACTER ch)
-		{
-			if (ch != c)
-				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
-				{
-					ch->PointChange(POINT_CHEQUE, iCheque, true);
-
-					if (iCheque > 1000)
-						LogManager::instance().CharLog(ch, iCheque, "GET_CHEQUE", "");
-				}
-		}
-	};
-#endif
-
-#if defined(__GEM_SYSTEM__)
-	struct FGemDistributor
-	{
-		int total;
-		LPCHARACTER c;
-		int x, y;
-		int iGem;
-
-		FGemDistributor(LPCHARACTER center, int iGem)
-			: total(0), c(center), x(center->GetX()), y(center->GetY()), iGem(iGem)
-		{
-		}
-
-		void operator ()(LPCHARACTER ch)
-		{
-			if (ch != c)
-				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
-				{
-					ch->PointChange(POINT_GEM, iGem, true);
-
-					if (iGem > 1000)
-						LogManager::instance().CharLog(ch, iGem, "GET_GEM", "");
-				}
-		}
-	};
-#endif
-}
-
-void CHARACTER::GiveGold(int iAmount)
-{
-	if (iAmount <= 0)
-		return;
-
-	sys_log(0, "GIVE_GOLD: %s %d", GetName(), iAmount);
-
-	if (GetParty())
-	{
-		LPPARTY pParty = GetParty();
-
-		// 파티가 있는 경우 나누어 가진다.
-		DWORD dwTotal = iAmount;
-		DWORD dwMyAmount = dwTotal;
-
-		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
-		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
-
-		if (funcCountNearMember.total > 1)
-		{
-			DWORD dwShare = dwTotal / funcCountNearMember.total;
-			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
-
-			NPartyPickupDistribute::FMoneyDistributor funcMoneyDist(this, dwShare);
-			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
-		}
-
-		PointChange(POINT_GOLD, dwMyAmount, true);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		UpdateExtBattlePassMissionProgress(YANG_COLLECT, dwMyAmount, GetMapIndex());
-#endif
-
-		if (dwMyAmount > 1000) // 천원 이상만 기록한다.
-			LogManager::instance().CharLog(this, dwMyAmount, "GET_GOLD", "");
-	}
-	else
-	{
-		PointChange(POINT_GOLD, iAmount, true);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		UpdateExtBattlePassMissionProgress(YANG_COLLECT, iAmount, GetMapIndex());
-#endif
-
-		// 브라질에 돈이 없어진다는 버그가 있는데,
-		// 가능한 시나리오 중에 하나는,
-		// 메크로나, 핵을 써서 1000원 이하의 돈을 계속 버려 골드를 0으로 만들고,
-		// 돈이 없어졌다고 복구 신청하는 것일 수도 있다.
-		// 따라서 그런 경우를 잡기 위해 낮은 수치의 골드에 대해서도 로그를 남김.
-		if (LC_IsBrazil() == true)
-		{
-			if (iAmount >= 213)
-				LogManager::instance().CharLog(this, iAmount, "GET_GOLD", "");
-		}
-		else
-		{
-			if (iAmount > 1000) // 천원 이상만 기록한다.
-				LogManager::instance().CharLog(this, iAmount, "GET_GOLD", "");
-		}
-	}
-}
-
-#if defined(__CHEQUE_SYSTEM__)
-void CHARACTER::GiveCheque(int iAmount)
-{
-	if (iAmount <= 0)
-		return;
-
-	sys_log(0, "GIVE_CHEQUE: %s %lld", GetName(), iAmount);
-
-	if (GetParty())
-	{
-		LPPARTY pParty = GetParty();
-
-		DWORD dwTotal = iAmount;
-		DWORD dwMyAmount = dwTotal;
-
-		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
-		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
-
-		if (funcCountNearMember.total > 1)
-		{
-			DWORD dwShare = dwTotal / funcCountNearMember.total;
-			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
-
-			NPartyPickupDistribute::FChequeDistributor funcMoneyDist(this, dwShare);
-			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
-		}
-
-		PointChange(POINT_CHEQUE, dwMyAmount, true);
-
-		if (dwMyAmount > 1000)
-			LogManager::instance().CharLog(this, dwMyAmount, "GET_CHEQUE", "");
-	}
-	else
-	{
-		PointChange(POINT_CHEQUE, iAmount, true);
-
-		if (LC_IsBrazil() == true)
-		{
-			if (iAmount >= 213)
-				LogManager::instance().CharLog(this, iAmount, "GET_CHEQUE", "");
-		}
-		else
-		{
-			if (iAmount > 1000)
-				LogManager::instance().CharLog(this, iAmount, "GET_CHEQUE", "");
-		}
-	}
-}
-#endif
-
-#if defined(__GEM_SYSTEM__)
-void CHARACTER::GiveGem(int iAmount)
-{
-	if (iAmount <= 0)
-		return;
-
-	sys_log(0, "GIVE_GEM: %s %lld", GetName(), iAmount);
-
-	if (GetParty())
-	{
-		LPPARTY pParty = GetParty();
-
-		DWORD dwTotal = iAmount;
-		DWORD dwMyAmount = dwTotal;
-
-		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
-		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
-
-		if (funcCountNearMember.total > 1)
-		{
-			DWORD dwShare = dwTotal / funcCountNearMember.total;
-			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
-
-			NPartyPickupDistribute::FGemDistributor funcMoneyDist(this, dwShare);
-			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
-		}
-
-		PointChange(POINT_GEM, dwMyAmount, true);
-
-		if (dwMyAmount > 1000)
-			LogManager::instance().CharLog(this, dwMyAmount, "GET_GEM", "");
-	}
-	else
-	{
-		PointChange(POINT_GEM, iAmount, true);
-
-		if (LC_IsBrazil() == true)
-		{
-			if (iAmount >= 213)
-				LogManager::instance().CharLog(this, iAmount, "GET_GEM", "");
-		}
-		else
-		{
-			if (iAmount > 1000)
-				LogManager::instance().CharLog(this, iAmount, "GET_GEM", "");
-		}
-	}
-}
-#endif
-
-bool CHARACTER::PickupItem(DWORD dwVID
-#if defined(__PET_LOOT_AI__)
-	, bool bPetLoot
-#endif
-)
-{
-	if (IsDead())
-		return false;
-
-	LPITEM item = ITEM_MANAGER::instance().FindByVID(dwVID);
-
-	if (IsObserverMode())
-		return false;
-
-	if (!item || !item->GetSectree())
-		return false;
-
-	if (item->DistanceValid(this)
-#if defined(__PET_LOOT_AI__)
-		|| bPetLoot
-#endif
-		)
-	{
-		if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
-			|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
-		{
-			if (IsRunningQuest())
-				return false;
-		}
-
-		if (item->IsOwnership(this))
-		{
-#if defined(__LOOT_FILTER_SYSTEM__)
-			if (GetLootFilter() && !GetLootFilter()->CanPickUpItem(item))
-			{
-				if (!GetLootFilter()->IsLootFilteredItem(dwVID))
-				{
-					GetLootFilter()->InsertLootFilteredItem(dwVID);
-
-					if (GetDesc())
-					{
-						TPacketGCLootFilter p;
-						p.header = HEADER_GC_LOOT_FILTER;
-						p.enable = false;
-						p.vid = dwVID;
-						GetDesc()->Packet(&p, sizeof(p));
-					}
-				}
-
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as the loot filter is deactivated."));
-				return false;
-			}
-#endif
-
-			// 만약 주으려 하는 아이템이 엘크라면
-			if (item->GetType() == ITEM_ELK)
-			{
-				GiveGold(item->GetCount());
-				item->RemoveFromGround();
-
-				M2_DESTROY_ITEM(item);
-
-				Save();
-			}
-			// 평범한 아이템이라면
-			else
-			{
-				if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-				{
-					WORD wCount = item->GetCount();
-
-					for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-					{
-						LPITEM item2 = GetInventoryItem(i);
-
-						if (!item2)
-							continue;
-
-						if (item2->GetVnum() == item->GetVnum())
-						{
-							int j;
-
-							for (j = 0; j < ITEM_SOCKET_MAX_NUM; ++j)
-							{
-								if (item2->GetSocket(j) != item->GetSocket(j))
-									break;
-							}
-
-							if (j != ITEM_SOCKET_MAX_NUM)
-								continue;
-
-							WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
-
-							wCount -= wCount2;
-
-							item2->SetCount(item2->GetCount() + wCount2);
-
-							if (wCount == 0)
-							{
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-								ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
-#else
-								ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item2->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
-#else
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item2->GetVnum())));
-#endif
-#endif
-								M2_DESTROY_ITEM(item);
-
-								if (item2->GetType() == ITEM_QUEST)
-									quest::CQuestManager::instance().PickupItem(GetPlayerID(), item2);
-
-								return true;
-							}
-						}
-					}
-
-					item->SetCount(wCount);
-				}
-
-				int iEmptyCell;
-#if defined(__DRAGON_SOUL_SYSTEM__)
-				if (item->IsDragonSoul())
-				{
-					if ((iEmptyCell = GetEmptyDragonSoulInventory(item)) == -1)
-					{
-						sys_log(0, "No empty ds inventory pid %u size %ud itemid %u", GetPlayerID(), item->GetSize(), item->GetID());
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지하고 있는 아이템이 너무 많습니다."));
-						return false;
-					}
-				}
-				else
-#endif
-				{
-					if ((iEmptyCell = GetEmptyInventory(item->GetSize())) == -1)
-					{
-						sys_log(0, "No empty inventory pid %u size %ud itemid %u", GetPlayerID(), item->GetSize(), item->GetID());
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지하고 있는 아이템이 너무 많습니다."));
-						return false;
-					}
-				}
-
-				item->RemoveFromGround();
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-				if (item->IsDragonSoul())
-					item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
-				else
-#endif
-					item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell));
-
-				char szHint[32 + 1];
-				snprintf(szHint, sizeof(szHint), "%s %u %u", item->GetName(), item->GetCount(), item->GetOriginalVnum());
-				LogManager::instance().ItemLog(this, item, "GET", szHint);
-
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#endif
-#endif
-
-				if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
-					|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
-				{
-					quest::CQuestManager::instance().PickupItem(GetPlayerID(), item);
-				}
-			}
-
-			//Motion(MOTION_PICKUP);
-			return true;
-		}
-		else if (!IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_DROP) && GetParty())
-		{
-			// 다른 파티원 소유권 아이템을 주으려고 한다면
-			NPartyPickupDistribute::FFindOwnership funcFindOwnership(item);
-			GetParty()->ForEachOnMapMember(funcFindOwnership, GetMapIndex());
-
-			LPCHARACTER owner = funcFindOwnership.owner;
-			if (!owner)
-				return false;
-
-			int iEmptyCell;
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			if (item->IsDragonSoul())
-			{
-				if (!(owner && (iEmptyCell = owner->GetEmptyDragonSoulInventory(item)) != -1))
-				{
-					owner = this;
-
-					if ((iEmptyCell = GetEmptyDragonSoulInventory(item)) == -1)
-					{
-						owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지하고 있는 아이템이 너무 많습니다."));
-						return false;
-					}
-				}
-			}
-			else
-#endif
-			{
-				if (!(owner && (iEmptyCell = owner->GetEmptyInventory(item->GetSize())) != -1))
-				{
-					owner = this;
-
-					if ((iEmptyCell = GetEmptyInventory(item->GetSize())) == -1)
-					{
-						owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지하고 있는 아이템이 너무 많습니다."));
-						return false;
-					}
-				}
-			}
-
-			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-			{
-				WORD wCount = item->GetCount();
-
-				for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-				{
-					LPITEM item2 = owner->GetInventoryItem(i);
-
-					if (!item2)
-						continue;
-
-					if (item2->GetVnum() == item->GetVnum())
-					{
-						int j;
-
-						for (j = 0; j < ITEM_SOCKET_MAX_NUM; ++j)
-						{
-							if (item2->GetSocket(j) != item->GetSocket(j))
-								break;
-						}
-
-						if (j != ITEM_SOCKET_MAX_NUM)
-							continue;
-
-						WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
-
-						wCount -= wCount2;
-
-						item2->SetCount(item2->GetCount() + wCount2);
-
-						if (wCount == 0)
-						{
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-							owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
-#else
-							owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item2->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-							owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
-#else
-							owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item2->GetVnum())));
-#endif
-#endif
-							M2_DESTROY_ITEM(item);
-
-							if (item2->GetType() == ITEM_QUEST)
-								quest::CQuestManager::instance().PickupItem(owner->GetPlayerID(), item2);
-
-							return true;
-						}
-					}
-				}
-
-				item->SetCount(wCount);
-			}
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-			if (owner->GetLootFilter() && !owner->GetLootFilter()->CanPickUpItem(item))
-			{
-				if (owner == this)
-				{
-					if (!owner->GetLootFilter()->IsLootFilteredItem(dwVID))
-					{
-						owner->GetLootFilter()->InsertLootFilteredItem(dwVID);
-
-						if (owner->GetDesc())
-						{
-							TPacketGCLootFilter p;
-							p.header = HEADER_GC_LOOT_FILTER;
-							p.enable = false;
-							p.vid = dwVID;
-							owner->GetDesc()->Packet(&p, sizeof(p));
-						}
-					}
-
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as the loot filter is deactivated."));
-				}
-				else
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as a party member's loot filter is deactivated."));
-				}
-
-				return false;
-			}
-#endif
-
-			item->RemoveFromGround();
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			if (item->IsDragonSoul())
-				item->AddToCharacter(owner, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
-			else
-#endif
-				item->AddToCharacter(owner, TItemPos(INVENTORY, iEmptyCell));
-
-			char szHint[32 + 1];
-			snprintf(szHint, sizeof(szHint), "%s %u %u", item->GetName(), item->GetCount(), item->GetOriginalVnum());
-			LogManager::instance().ItemLog(owner, item, "GET", szHint);
-
-			if (owner == this)
-			{
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#endif
-#endif
-			}
-			else
-			{
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-				owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s 님으로부터 %s", GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 전달: %s 님에게 %s", owner->GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s 님으로부터 %s", GetName(), LC_ITEM(item->GetVnum())));
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 전달: %s 님에게 %s", owner->GetName(), LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-				owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s 님으로부터 %s", GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 전달: %s 님에게 %s", owner->GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s 님으로부터 %s", GetName(), LC_ITEM(item->GetVnum())));
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 전달: %s 님에게 %s", owner->GetName(), LC_ITEM(item->GetVnum())));
-#endif
-#endif
-			}
-
-			if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
-				|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
-			{
-				quest::CQuestManager::instance().PickupItem(owner->GetPlayerID(), item);
-			}
-
-			return true;
-		}
-	}
-
-	return false;
-}
-
-// 귀찮아서 만든 매크로.. exp가 true면 msg를 출력하고 return false 하는 매크로 (일반적인 verify 용도랑은 return 때문에 약간 반대라 이름때문에 헷갈릴 수도 있겠다..)
-#define VERIFY_MSG(exp, msg) \
-	if (true == (exp)) \
-	{ \
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING(msg)); \
-		return false; \
-	}
-
-bool CHARACTER::SwapItem(WORD wCell, WORD wDestCell)
-{
-	if (!CanHandleItem())
-		return false;
-
-	const TItemPos srcCell(INVENTORY, wCell), destCell(EQUIPMENT, wDestCell);
-
-	// 올바른 Cell 인지 검사
-	// 용혼석은 Swap할 수 없으므로, 여기서 걸림.
-	//if (bCell >= INVENTORY_MAX_NUM + WEAR_MAX_NUM || bDestCell >= INVENTORY_MAX_NUM + WEAR_MAX_NUM)
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (srcCell.IsDragonSoulEquipPosition() || destCell.IsDragonSoulEquipPosition())
-		return false;
-#endif
-
-	// 둘 다 장비창 위치면 Swap 할 수 없다.
-	if (srcCell.IsEquipPosition() && destCell.IsEquipPosition())
-		return false;
-
-	LPITEM item1 = nullptr, item2 = nullptr;
-
-	// item2가 장비창에 있는 것이 되도록.
-	if (srcCell.IsEquipPosition())
-	{
-		item1 = GetEquipmentItem(wDestCell);
-		item2 = GetInventoryItem(wCell);
-	}
-	else
-	{
-		item1 = GetInventoryItem(wCell);
-		item2 = GetEquipmentItem(wDestCell);
-	}
-
-	if (!item1 || !item2)
-		return false;
-
-	if (item1 == item2)
-	{
-		sys_log(0, "[WARNING][WARNING][HACK USER!] : %s %d %d", m_stName.c_str(), wCell, wDestCell);
-		return false;
-	}
-
-	// item2가 bCell위치에 들어갈 수 있는지 확인한다.
-	if (!IsEmptyItemGrid(TItemPos(INVENTORY, item1->GetCell()), item2->GetSize(), item1->GetCell()))
-		return false;
-
-	// 바꿀 아이템이 장비창에 있으면
-	if (TItemPos(EQUIPMENT, item2->GetCell()).IsEquipPosition())
-	{
-		const WORD wEquipCell = item2->GetCell();
-		const WORD wInvenCell = item1->GetCell();
-
-		// The item currently being worn can be removed, and the item planned to be worn
-		// must be in a wearable state in order to proceed.
-		if (!CanUnequipNow(item2, TItemPos(INVENTORY, wEquipCell)) || !CanEquipNow(item1))
-			return false;
-
-		if (wEquipCell != item1->FindEquipCell(this)) // When in the same location, it is only allowed
-			return false;
-
-		item2->RemoveFromCharacter();
-
-		if (item1->EquipTo(this, wEquipCell))
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			item2->AddToCharacter(this, TItemPos(INVENTORY, wInvenCell), false);
-#else
-			item2->AddToCharacter(this, TItemPos(INVENTORY, wInvenCell));
-#endif
-		else
-			sys_err("SwapItem cannot equip %s! item1 %s", item2->GetName(), item1->GetName());
-	}
-	else
-	{
-		const WORD wCell1 = item1->GetCell();
-		const WORD wCell2 = item2->GetCell();
-
-		item1->RemoveFromCharacter();
-		item2->RemoveFromCharacter();
-
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		item1->AddToCharacter(this, TItemPos(EQUIPMENT, wCell2), false);
-		item2->AddToCharacter(this, TItemPos(INVENTORY, wCell1), false);
-#else
-		item1->AddToCharacter(this, TItemPos(INVENTORY, wCell2));
-		item2->AddToCharacter(this, TItemPos(INVENTORY, wCell1));
-#endif
-	}
-
-	return true;
-}
-
-bool CHARACTER::UnequipItem(LPITEM item)
-{
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-	if (item->FindEquipCell(this) == WEAR_WEAPON)
-	{
-		LPITEM pCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
-		if (pCostumeWeapon)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
-			return false;
-		}
-	}
-#endif
-
-	if (false == CanUnequipNow(item))
-		return false;
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	if (item->IsCostumeMount() && item->IsEquipped())
-		UnMount();
-#endif
-
-	int pos;
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (item->IsDragonSoul())
-		pos = GetEmptyDragonSoulInventory(item);
-	else
-#endif
-		pos = GetEmptyInventory(item->GetSize());
-
-	// HARD CODING
-	if (item->GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
-		ShowAlignment(true);
-
-	item->RemoveFromCharacter();
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (item->IsDragonSoul())
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, pos), false);
-#else
-		item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, pos));
-#endif
-	else
-#endif
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		item->AddToCharacter(this, TItemPos(INVENTORY, pos), false);
-#else
-		item->AddToCharacter(this, TItemPos(INVENTORY, pos));
-#endif
-
-	CheckMaximumPoints();
-
-	return true;
-}
-
-//
-// @version 05/07/05 Bang2ni - Skill 사용후 1.5 초 이내에 장비 착용 금지
-//
-bool CHARACTER::EquipItem(LPITEM item, int iCandidateCell)
-{
-	if (item->IsExchanging())
-		return false;
-
-	if (false == item->IsEquipable())
-		return false;
-
-	if (false == CanEquipNow(item))
-		return false;
-
-	int iWearCell = item->FindEquipCell(this, iCandidateCell);
-
-	if (iWearCell < 0)
-		return false;
-
-	// 무언가를 탄 상태에서 턱시도 입기 금지
-	if (iWearCell == WEAR_BODY && IsRiding() && (item->GetVnum() >= 11901 && item->GetVnum() <= 11904))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("말을 탄 상태에서 예복을 입을 수 없습니다."));
-		return false;
-	}
-
-	if (iWearCell != WEAR_ARROW && IsPolymorphed())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("둔갑 중에는 착용중인 장비를 변경할 수 없습니다."));
-		return false;
-	}
-
-	if (FN_check_item_sex(this, item) == false)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("성별이 맞지않아 이 아이템을 사용할 수 없습니다."));
-		return false;
-	}
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum = item->GetTransmutationVnum();
-	if (dwTransmutationVnum != 0)
-	{
-		TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwTransmutationVnum);
-
-		if (!pItemTable->CanUseByJob(GetJob()))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your class."));
-			return false;
-		}
-
-#	if defined(__COSTUME_SYSTEM__)
-		if (pItemTable && pItemTable->IsCostume())
-		{
-			if ((IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_MALE) && SEX_MALE == GET_SEX(this)) ||
-				(IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_FEMALE) && SEX_FEMALE == GET_SEX(this)))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your gender."));
-				return false;
-			}
-		}
-	}
-#	endif
-#endif
-
-	// 신규 탈것 사용시 기존 말 사용여부 체크
-	if (item->IsRideItem())
-	{
-		if (IsRiding())
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 탈것을 이용중입니다."));
-			return false;
-		}
-
-		if (IsPolymorphed())
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("변신 상태에서는 말에 탈 수 없습니다."));
-			return false;
-		}
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-		if (item->IsRideItem())
-		{
-			DWORD dwMountVnum = item->GetMountVnum();
-			if (dwMountVnum > 0 && FindAffect(AFFECT_MOUNT_FALL) == NULL)
-				MountVnum(dwMountVnum);
-		}
-#endif
-	}
-
-	// 화살 이외에는 마지막 공격 시간 또는 스킬 사용 1.5 후에 장비 교체가 가능
-	DWORD dwCurTime = get_dword_time();
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	if (iWearCell != WEAR_ARROW && iWearCell != WEAR_COSTUME_MOUNT
-		&& (dwCurTime - GetLastAttackTime() <= 1500 || dwCurTime - m_dwLastSkillTime <= 1500))
-#else
-	if (iWearCell != WEAR_ARROW
-		&& (dwCurTime - GetLastAttackTime() <= 1500 || dwCurTime - m_dwLastSkillTime <= 1500))
-#endif
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("가만히 있을 때만 착용할 수 있습니다."));
-		return false;
-	}
-
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-	if (iWearCell == WEAR_WEAPON)
-	{
-		if (item->GetType() == ITEM_WEAPON)
-		{
-			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
-			if (pkCostumeWeapon && pkCostumeWeapon->GetValue(3) != item->GetSubType())
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
-				return false;
-			}
-		}
-		else
-		{
-			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
-			if (pkCostumeWeapon)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
-				return false;
-			}
-		}
-	}
-	else if (iWearCell == WEAR_COSTUME_WEAPON)
-	{
-		if (item->GetType() == ITEM_COSTUME && item->GetSubType() == COSTUME_WEAPON)
-		{
-			LPITEM pkWeapon = GetWear(WEAR_WEAPON);
-			if (!pkWeapon)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You need to equip a weapon first."));
-				return false;
-			}
-			else if (pkWeapon->GetType() != ITEM_WEAPON || item->GetValue(3) != pkWeapon->GetSubType())
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this costume for this weapon."));
-				return false;
-			}
-		}
-	}
-#endif
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	// 용혼석 특수 처리
-	if (item->IsDragonSoul())
-	{
-		// 같은 타입의 용혼석이 이미 들어가 있다면 착용할 수 없다.
-		// 용혼석은 swap을 지원하면 안됨.
-		if (GetEquipmentItem(iWearCell))
-		{
-			ChatPacket(CHAT_TYPE_INFO, "이미 같은 종류의 용혼석을 착용하고 있습니다.");
-			return false;
-		}
-
-		if (!item->EquipTo(this, iWearCell))
-		{
-			return false;
-		}
-	}
-	// 용혼석이 아님.
-	else
-#endif
-	{
-		// 착용할 곳에 아이템이 있다면,
-		if (GetWear(iWearCell) && !IS_SET(GetWear(iWearCell)->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-		{
-			// 이 아이템은 한번 박히면 변경 불가. swap 역시 완전 불가
-			//if (item->GetWearFlag() == WEARABLE_ABILITY)
-			//	return false;
-
-			if (!SwapItem(item->GetCell(), iWearCell))
-				return false;
-		}
-		else
-		{
-			BYTE bOldCell = item->GetCell();
-
-			if (item->EquipTo(this, iWearCell))
-				SyncQuickslot(SLOT_TYPE_INVENTORY, bOldCell, iWearCell);
-		}
-	}
-
-	if (true == item->IsEquipped())
-	{
-		// 아이템 최초 사용 이후부터는 사용하지 않아도 시간이 차감되는 방식 처리.
-		if (-1 != item->GetProto()->cLimitRealTimeFirstUseIndex)
-		{
-			// 한 번이라도 사용한 아이템인지 여부는 Socket1을 보고 판단한다. (Socket1에 사용횟수 기록)
-			if (0 == item->GetSocket(1))
-			{
-				// 사용가능시간은 Default 값으로 Limit Value 값을 사용하되, Socket0에 값이 있으면 그 값을 사용하도록 한다. (단위는 초)
-				long duration = (0 != item->GetSocket(0)) ? item->GetSocket(0) : item->GetProto()->aLimits[(BYTE)item->GetProto()->cLimitRealTimeFirstUseIndex].lValue;
-
-				if (0 == duration)
-					duration = 60 * 60 * 24 * 7;
-
-				item->SetSocket(0, time(0) + duration);
-				item->StartRealTimeExpireEvent();
-			}
-
-			item->SetSocket(1, item->GetSocket(1) + 1);
-		}
-
-		if (item->GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
-			ShowAlignment(false);
-
-		if (item->IsRing() || item->IsCostume()
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-			&& !item->IsCostumeMount()
-#endif
-			)
-			ChatPacket(CHAT_TYPE_COMMAND, "OpenCostumeWindow");
-
-		const DWORD& dwVnum = item->GetVnum();
-
-		// 라마단 이벤트 초승달의 반지(71135) 착용시 이펙트 발동
-		if (true == CItemVnumHelper::IsRamadanMoonRing(dwVnum))
-		{
-			this->EffectPacket(SE_EQUIP_RAMADAN_RING);
-		}
-		// 할로윈 사탕(71136) 착용시 이펙트 발동
-		else if (true == CItemVnumHelper::IsHalloweenCandy(dwVnum))
-		{
-			this->EffectPacket(SE_EQUIP_HALLOWEEN_CANDY);
-		}
-		// 행복의 반지(71143) 착용시 이펙트 발동
-		else if (true == CItemVnumHelper::IsHappinessRing(dwVnum))
-		{
-			this->EffectPacket(SE_EQUIP_HAPPINESS_RING);
-		}
-		// 사랑의 팬던트(71145) 착용시 이펙트 발동
-		else if (true == CItemVnumHelper::IsLovePendant(dwVnum))
-		{
-			this->EffectPacket(SE_EQUIP_LOVE_PENDANT);
-		}
-		// ITEM_UNIQUE의 경우, SpecialItemGroup에 정의되어 있고, (item->GetSIGVnum() != NULL)
-		//
-		else if ((ITEM_UNIQUE == item->GetType() || ITEM_RING == item->GetType()) && 0 != item->GetSIGVnum())
-		{
-			const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(item->GetSIGVnum());
-			if (NULL != pGroup)
-			{
-				const CSpecialAttrGroup* pAttrGroup = ITEM_MANAGER::instance().GetSpecialAttrGroup(pGroup->GetAttrVnum(item->GetVnum()));
-				if (NULL != pAttrGroup)
-				{
-					const std::string& std = pAttrGroup->m_stEffectFileName;
-					SpecificEffectPacket(std.c_str());
-				}
-			}
-		}
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		if ((item->GetType() == ITEM_COSTUME) && (item->GetSubType() == COSTUME_ACCE
-#if defined(__AURA_COSTUME_SYSTEM__)
-			|| item->GetSubType() == COSTUME_AURA
-#endif
-			))
-		{
-			if (item->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) > 18)
-				this->EffectPacket(SE_ACCE_BACK);
-			this->EffectPacket(SE_ACCE_EQUIP);
-		}
-#endif
-
-		if ((ITEM_UNIQUE == item->GetType() && UNIQUE_SPECIAL_RIDE == item->GetSubType() && IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE))
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-			|| (ITEM_COSTUME == item->GetType() && COSTUME_MOUNT == item->GetSubType())
-#endif
-			)
-		{
-			quest::CQuestManager::instance().UseItem(GetPlayerID(), item, false);
-		}
-	}
-
-	return true;
-}
-
-void CHARACTER::BuffOnAttr_AddBuffsFromItem(LPITEM pItem)
-{
-	for (int i = 0; i < sizeof(g_aBuffOnAttrPoints) / sizeof(g_aBuffOnAttrPoints[0]); i++)
-	{
-		TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(g_aBuffOnAttrPoints[i]);
-		if (it != m_map_buff_on_attrs.end())
-		{
-			it->second->AddBuffFromItem(pItem);
-		}
-	}
-}
-
-void CHARACTER::BuffOnAttr_RemoveBuffsFromItem(LPITEM pItem)
-{
-	for (int i = 0; i < sizeof(g_aBuffOnAttrPoints) / sizeof(g_aBuffOnAttrPoints[0]); i++)
-	{
-		TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(g_aBuffOnAttrPoints[i]);
-		if (it != m_map_buff_on_attrs.end())
-		{
-			it->second->RemoveBuffFromItem(pItem);
-		}
-	}
-}
-
-void CHARACTER::BuffOnAttr_ClearAll()
-{
-	for (TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.begin(); it != m_map_buff_on_attrs.end(); ++it)
-	{
-		CBuffOnAttributes* pBuff = it->second;
-		if (pBuff)
-		{
-			pBuff->Initialize();
-		}
-	}
-}
-
-void CHARACTER::BuffOnAttr_ValueChange(POINT_TYPE wPointType, POINT_VALUE llOldValue, POINT_VALUE lNewValue)
-{
-	TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(wPointType);
-
-	if (0 == lNewValue)
-	{
-		if (m_map_buff_on_attrs.end() == it)
-			return;
-		else
-			it->second->Off();
-	}
-	else if (0 == llOldValue)
-	{
-		CBuffOnAttributes* pBuff;
-		if (m_map_buff_on_attrs.end() == it)
-		{
-			switch (wPointType)
-			{
-				case POINT_ENERGY:
-				{
-					static BYTE s_abSlot[] = {
-						WEAR_BODY,
-						WEAR_HEAD,
-						WEAR_FOOTS,
-						WEAR_WRIST,
-						WEAR_WEAPON,
-						WEAR_NECK,
-						WEAR_EAR,
-						WEAR_SHIELD,
-#if defined(__PENDANT_SYSTEM__)
-						WEAR_PENDANT,
-#endif
-#if defined(__GLOVE_SYSTEM__)
-						WEAR_GLOVE,
-#endif
-					};
-					static std::vector<POINT_TYPE> s_vSlots(s_abSlot, s_abSlot + _countof(s_abSlot));
-					pBuff = M2_NEW CBuffOnAttributes(this, wPointType, &s_vSlots);
-				}
-				break;
-
-				case POINT_COSTUME_ATTR_BONUS:
-				{
-					static BYTE s_abSlot[] = {
-						WEAR_COSTUME_BODY,
-						WEAR_COSTUME_HAIR,
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-						WEAR_COSTUME_WEAPON,
-#endif
-					};
-					static std::vector<POINT_TYPE> s_vSlots(s_abSlot, s_abSlot + _countof(s_abSlot));
-					pBuff = M2_NEW CBuffOnAttributes(this, wPointType, &s_vSlots);
-				}
-				break;
-
-				default:
-					break;
-
-			}
-			m_map_buff_on_attrs.insert(TMapBuffOnAttrs::value_type(wPointType, pBuff));
-
-		}
-		else
-			pBuff = it->second;
-
-		pBuff->On(lNewValue);
-	}
-	else
-	{
-		if (m_map_buff_on_attrs.end() == it)
-			return;
-		else
-			it->second->ChangeBuffValue(lNewValue);
-	}
-}
-
-LPITEM CHARACTER::FindSpecifyItem(DWORD dwVnum
-#if defined(__SOUL_BIND_SYSTEM__)
-	, bool bIgnoreSoulBound
-#endif
-#if defined(__SET_ITEM__)
-	, bool bIgnoreSetValue
-#endif
-) const
-{
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-	{
-		if (GetInventoryItem(i) && GetInventoryItem(i)->GetVnum() == dwVnum)
-		{
-#if defined(__SOUL_BIND_SYSTEM__)
-			if (bIgnoreSoulBound && GetInventoryItem(i)->IsSealed())
-				continue;
-#endif
-
-#if defined(__SET_ITEM__)
-			if (bIgnoreSetValue && GetInventoryItem(i)->GetItemSetValue())
-				continue;
-#endif
-			return GetInventoryItem(i);
-		}
-	}
-	return NULL;
-}
-
-LPITEM CHARACTER::FindItemByID(DWORD id) const
-{
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (WORD wCell = 0; wCell < GetExtendInvenMax(); ++wCell)
-#else
-	for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
-#endif
-		if (GetInventoryItem(wCell) && GetInventoryItem(wCell)->GetID() == id)
-			return GetInventoryItem(wCell);
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	for (WORD wCell = 0; wCell < DRAGON_SOUL_INVENTORY_MAX_NUM; ++wCell)
-		if (GetDragonSoulInventoryItem(wCell) && GetDragonSoulInventoryItem(wCell)->GetID() == id)
-			return GetDragonSoulInventoryItem(wCell);
-#endif
-
-	for (WORD wCell = 0; wCell < BELT_INVENTORY_MAX_NUM; ++wCell)
-		if (GetBeltInventoryItem(wCell) && GetBeltInventoryItem(wCell)->GetID() == id)
-			return GetBeltInventoryItem(wCell);
-
-	return NULL;
-}
-
-int CHARACTER::CountSpecifyItem(DWORD vnum, int iExceptionCell
-#if defined(__SOUL_BIND_SYSTEM__)
-	, bool bIgnoreSealedItem
-#endif
-#if defined(__SET_ITEM__)
-	, bool bIgnoreSetValue
-#endif
-) const
-{
-	int iCount = 0;
-	LPITEM pItem = nullptr;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (WORD wCell = 0; wCell < GetExtendInvenMax(); ++wCell)
-#else
-	for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
-#endif
-	{
-		if (wCell == iExceptionCell)
-			continue;
-
-		pItem = GetInventoryItem(wCell);
-		if (pItem && pItem->GetVnum() == vnum)
-		{
-			// 개인 상점에 등록된 물건이면 넘어간다.
-			if (m_pkMyShop && m_pkMyShop->IsSellingItem(pItem->GetID()))
-				continue;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-			if (bIgnoreSealedItem && pItem->IsSealed())
-				continue;
-#endif
-
-#if defined(__SET_ITEM__)
-			if (bIgnoreSetValue && pItem->GetItemSetValue())
-				continue;
-#endif
-
-			iCount += pItem->GetCount();
-		}
-	}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	for (WORD wCell = 0; wCell < DRAGON_SOUL_INVENTORY_MAX_NUM; ++wCell)
-	{
-		pItem = GetDragonSoulInventoryItem(wCell);
-		if (pItem && pItem->GetVnum() == vnum)
-		{
-#if defined(__SOUL_BIND_SYSTEM__)
-			if (bIgnoreSealedItem && pItem->IsSealed())
-				continue;
-#endif
-
-			iCount += pItem->GetCount();
-		}
-	}
-#endif
-
-	return iCount;
-}
-
-void CHARACTER::RemoveSpecifyItem(DWORD vnum, DWORD count, int iExceptionCell
-#if defined(__SOUL_BIND_SYSTEM__)
-	, bool bIgnoreSealedItem
-#endif
-#if defined(__SET_ITEM__)
-	, bool bIgnoreSetValue
-#endif
-)
-{
-	if (0 == count)
-		return;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (UINT i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (UINT i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-	{
-		if (i == iExceptionCell)
-			continue;
-
-		if (NULL == GetInventoryItem(i))
-			continue;
-
-		if (GetInventoryItem(i)->GetVnum() != vnum)
-			continue;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-		if (bIgnoreSealedItem && GetInventoryItem(i)->IsSealed())
-			continue;
-#endif
-
-#if defined(__SET_ITEM__)
-		if (bIgnoreSetValue && GetInventoryItem(i)->GetItemSetValue())
-			continue;
-#endif
-
-		//개인 상점에 등록된 물건이면 넘어간다. (개인 상점에서 판매될때 이 부분으로 들어올 경우 문제!)
-		if (m_pkMyShop)
-		{
-			bool isItemSelling = m_pkMyShop->IsSellingItem(GetInventoryItem(i)->GetID());
-			if (isItemSelling)
-				continue;
-		}
-
-		if (vnum >= 80003 && vnum <= 80007)
-			LogManager::instance().GoldBarLog(GetPlayerID(), GetInventoryItem(i)->GetID(), QUEST, "RemoveSpecifyItem");
-
-		if (count >= GetInventoryItem(i)->GetCount())
-		{
-			count -= GetInventoryItem(i)->GetCount();
-			GetInventoryItem(i)->SetCount(0);
-
-			if (0 == count)
-				return;
-		}
-		else
-		{
-			GetInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
-			return;
-		}
-	}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	for (UINT i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
-	{
-		if (NULL == GetDragonSoulInventoryItem(i))
-			continue;
-
-		if (GetDragonSoulInventoryItem(i)->GetVnum() != vnum)
-			continue;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-		if (bIgnoreSealedItem && GetDragonSoulInventoryItem(i)->IsSealed())
-			continue;
-#endif
-
-#if defined(__SET_ITEM__)
-		if (bIgnoreSetValue && GetDragonSoulInventoryItem(i)->GetItemSetValue())
-			continue;
-#endif
-
-		if (count >= GetDragonSoulInventoryItem(i)->GetCount())
-		{
-			count -= GetDragonSoulInventoryItem(i)->GetCount();
-			GetDragonSoulInventoryItem(i)->SetCount(0);
-
-			if (0 == count)
-				return;
-		}
-		else
-		{
-			GetDragonSoulInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
-			return;
-		}
-	}
-#endif
-
-	// 예외처리가 약하다.
-	if (count)
-		sys_log(0, "CHARACTER::RemoveSpecifyItem cannot remove enough item vnum %u, still remain %d", vnum, count);
-}
-
-int CHARACTER::CountSpecifyTypeItem(BYTE type) const
-{
-	int count = 0;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (int i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-	{
-		LPITEM pItem = GetInventoryItem(i);
-		if (pItem != NULL && pItem->GetType() == type)
-		{
-			count += pItem->GetCount();
-		}
-	}
-
-	return count;
-}
-
-void CHARACTER::RemoveSpecifyTypeItem(BYTE type, DWORD count)
-{
-	if (0 == count)
-		return;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (UINT i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (UINT i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-	{
-		if (NULL == GetInventoryItem(i))
-			continue;
-
-		if (GetInventoryItem(i)->GetType() != type)
-			continue;
-
-		//개인 상점에 등록된 물건이면 넘어간다. (개인 상점에서 판매될때 이 부분으로 들어올 경우 문제!)
-		if (m_pkMyShop)
-		{
-			bool isItemSelling = m_pkMyShop->IsSellingItem(GetInventoryItem(i)->GetID());
-			if (isItemSelling)
-				continue;
-		}
-
-		if (count >= GetInventoryItem(i)->GetCount())
-		{
-			count -= GetInventoryItem(i)->GetCount();
-			GetInventoryItem(i)->SetCount(0);
-
-			if (0 == count)
-				return;
-		}
-		else
-		{
-			GetInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
-			return;
-		}
-	}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	for (UINT i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
-	{
-		if (NULL == GetDragonSoulInventoryItem(i))
-			continue;
-
-		if (GetDragonSoulInventoryItem(i)->GetType() != type)
-			continue;
-
-		if (count >= GetDragonSoulInventoryItem(i)->GetCount())
-		{
-			count -= GetDragonSoulInventoryItem(i)->GetCount();
-			GetDragonSoulInventoryItem(i)->SetCount(0);
-
-			if (0 == count)
-				return;
-		}
-		else
-		{
-			GetDragonSoulInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
-			return;
-		}
-	}
-#endif
-}
-
-// 20200808.Owsap : Fix book stacking while sorting.
-void CHARACTER::GiveSkillBook(DWORD dwSkillVnum, WORD wCount)
-{
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-	{
-		LPITEM pkItem = GetInventoryItem(i);
-
-		if (!pkItem)
-			continue;
-
-		if ((pkItem->GetType() == ITEM_SKILLBOOK || pkItem->GetType() == ITEM_SKILLFORGET) && pkItem->GetSocket(0) == dwSkillVnum)
-		{
-			WORD wCount2 = MIN(ITEM_MAX_COUNT - pkItem->GetCount(), wCount);
-			wCount -= wCount2;
-
-			pkItem->SetCount(pkItem->GetCount() + wCount2);
-			if (wCount == 0)
-				return;
-		}
-	}
-
-	LPITEM pkBookItem = AutoGiveItem(ITEM_SKILLBOOK_VNUM, wCount, false, false);
-	if (NULL != pkBookItem)
-		pkBookItem->SetSocket(0, dwSkillVnum);
-}
-//>
-
-LPITEM CHARACTER::AutoGiveItem(DWORD dwItemVnum, WORD wCount, int iRarePct, bool bMsg
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-	, bool isHighLight
-#endif
-#if defined(__NEW_USER_CARE__)
-	, bool bSystemDrop
-#endif
-)
-{
-	TItemTable* p = ITEM_MANAGER::instance().GetTable(dwItemVnum);
-	if (!p)
-		return NULL;
-
-	DBManager::instance().SendMoneyLog(MONEY_LOG_DROP, dwItemVnum, wCount);
-
-	if (p->dwFlags & ITEM_FLAG_STACKABLE/* && p->bType != ITEM_BLEND*/)
-	{
-		for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-		{
-			LPITEM item = GetInventoryItem(i);
-
-			if (!item)
-				continue;
-
-			if (item->GetVnum() == dwItemVnum && FN_check_item_socket(item))
-			{
-				if (IS_SET(p->dwFlags, ITEM_FLAG_MAKECOUNT))
-				{
-					if (wCount < p->alValues[1])
-						wCount = p->alValues[1];
-				}
-
-				WORD wCount2 = MIN(ITEM_MAX_COUNT - item->GetCount(), wCount);
-				wCount -= wCount2;
-
-				item->SetCount(item->GetCount() + wCount2);
-
-				if (wCount == 0)
-				{
-					if (bMsg)
-					{
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#	if defined(__SET_ITEM__)
-						ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#	else
-						ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#	endif
-#else
-#	if defined(__SET_ITEM__)
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#	else
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#	endif
-#endif
-					}
-
-					return item;
-				}
-			}
-		}
-	}
-
-	LPITEM item = ITEM_MANAGER::instance().CreateItem(dwItemVnum, wCount, 0, true);
-
-	if (!item)
-	{
-		sys_err("cannot create item by vnum %u (name: %s)", dwItemVnum, GetName());
-		return NULL;
-	}
-
-	if (item->GetType() == ITEM_BLEND)
-	{
-		for (int i = 0; i < INVENTORY_MAX_NUM; i++)
-		{
-			LPITEM inv_item = GetInventoryItem(i);
-
-			if (inv_item == NULL)
-				continue;
-
-			if (inv_item->GetType() == ITEM_BLEND)
-			{
-				if (inv_item->GetVnum() == item->GetVnum())
-				{
-					if (inv_item->GetSocket(0) == item->GetSocket(0) &&
-						inv_item->GetSocket(1) == item->GetSocket(1) &&
-						inv_item->GetSocket(2) == item->GetSocket(2) &&
-						inv_item->GetCount() + item->GetCount() <= ITEM_MAX_COUNT)
-					{
-						inv_item->SetCount(inv_item->GetCount() + item->GetCount());
-						M2_DESTROY_ITEM(item);
-						return inv_item;
-					}
-				}
-			}
-		}
-	}
-
-	int iEmptyCell;
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (item->IsDragonSoul())
-		iEmptyCell = GetEmptyDragonSoulInventory(item);
-	else
-#endif
-		iEmptyCell = GetEmptyInventory(item->GetSize());
-
-	if (iEmptyCell != -1)
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-			item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
-		else
-#endif
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell), isHighLight);
-#else
-			item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell));
-#endif
-
-		if (bMsg)
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#endif
-#endif
-
-		LogManager::instance().ItemLog(this, item, "SYSTEM", item->GetName());
-
-		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_POTION)
-		{
-			TQuickslot* pSlot;
-
-			if (GetQuickslot(0, &pSlot) && pSlot->type == SLOT_TYPE_NONE)
-			{
-				TQuickslot slot;
-				slot.type = SLOT_TYPE_INVENTORY;
-				slot.pos = iEmptyCell;
-				SetQuickslot(0, slot);
-			}
-		}
-	}
-	else
-	{
-#if defined(__NEW_USER_CARE__)
-		if (!bSystemDrop)
-		{
-			sys_log(0, "AutoGiveItem: No inventory space, SystemDrop disabled!");
-
-			M2_DESTROY_ITEM(item);
-			return NULL;
-		}
-#endif
-
-		item->AddToGround(GetMapIndex(), GetXYZ());
-		item->StartDestroyEvent();
-		// 안티 드랍 flag가 걸려있는 아이템의 경우,
-		// 인벤에 빈 공간이 없어서 어쩔 수 없이 떨어트리게 되면,
-		// ownership을 아이템이 사라질 때까지(300초) 유지한다.
-		if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DROP))
-			item->SetOwnership(this, 300);
-		else
-			item->SetOwnership(this, 60);
-
-		LogManager::instance().ItemLog(this, item, "SYSTEM_DROP", item->GetName());
-	}
-
-	sys_log(0, "7: %d %d", dwItemVnum, wCount);
-	return item;
-}
-
-#define __AUTO_GIVE_ITEM_STACK__
-void CHARACTER::AutoGiveItem(LPITEM item, bool longOwnerShip, bool bMsg
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-	, bool isHighLight
-#endif
-)
-{
-	if (NULL == item)
-	{
-		sys_err("NULL point.");
-		return;
-	}
-
-	if (item->GetOwner())
-	{
-		sys_err("item %d 's owner exists!", item->GetID());
-		return;
-	}
-
-#if defined(__AUTO_GIVE_ITEM_STACK__)
-	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-	{
-		for (WORD i = 0; i < INVENTORY_MAX_NUM; ++i)
-		{
-			LPITEM item2 = GetInventoryItem(i);
-			if (!item2)
-				continue;
-
-			if (item2->GetVnum() != item->GetVnum())
-				continue;
-
-			BYTE j = 0;
-			for (; j < ITEM_SOCKET_MAX_NUM; ++j)
-				if (item2->GetSocket(j) != item->GetSocket(j))
-					break;
-
-			if (j != ITEM_SOCKET_MAX_NUM)
-				continue;
-
-			if (item2->GetCount() >= ITEM_MAX_COUNT)
-				continue;
-
-			WORD wCount = item->GetCount();
-			if (IS_SET(item->GetFlag(), ITEM_FLAG_MAKECOUNT))
-			{
-				if (wCount < item->GetValue(1))
-					wCount = item->GetValue(1);
-			}
-
-			WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
-			wCount -= wCount2;
-			item2->SetCount(item2->GetCount() + wCount2);
-
-			if (wCount == 0)
-			{
-				if (bMsg)
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-					ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-					ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#endif
-#endif
-
-				M2_DESTROY_ITEM(item);
-
-				return;
-			}
-
-			item->SetCount(wCount);
-		}
-	}
-#endif
-
-	int cell;
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (item->IsDragonSoul())
-	{
-		cell = GetEmptyDragonSoulInventory(item);
-	}
-	else
-#endif
-	{
-		cell = GetEmptyInventory(item->GetSize());
-	}
-
-	if (cell != -1)
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-			item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, cell));
-		else
-#endif
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			item->AddToCharacter(this, TItemPos(INVENTORY, cell), isHighLight);
-#else
-			item->AddToCharacter(this, TItemPos(INVENTORY, cell));
-#endif
-
-		if (bMsg)
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(item->GetVnum())));
-#endif
-#endif
-
-		LogManager::instance().ItemLog(this, item, "SYSTEM", item->GetName());
-
-		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_POTION)
-		{
-			TQuickslot* pSlot;
-
-			if (GetQuickslot(0, &pSlot) && pSlot->type == SLOT_TYPE_NONE)
-			{
-				TQuickslot slot;
-				slot.type = SLOT_TYPE_INVENTORY;
-				slot.pos = cell;
-				SetQuickslot(0, slot);
-			}
-		}
-	}
-	else
-	{
-		item->AddToGround(GetMapIndex(), GetXYZ());
-		item->StartDestroyEvent();
-
-		if (longOwnerShip)
-			item->SetOwnership(this, 300);
-		else
-			item->SetOwnership(this, 60);
-
-		LogManager::instance().ItemLog(this, item, "SYSTEM_DROP", item->GetName());
-	}
-}
-
-bool CHARACTER::GiveItem(LPCHARACTER victim, TItemPos Cell)
-{
-	if (!CanHandleItem())
-		return false;
-
-	if (IsRunningQuest())
-		return false;
-
-	LPITEM item = GetItem(Cell);
-	if (item && !item->IsExchanging())
-	{
-		if (victim->CanReceiveItem(this, item))
-		{
-			victim->ReceiveItem(this, item);
-			return true;
-		}
-	}
-
-	return false;
-}
-
-bool CHARACTER::CanReceiveItem(LPCHARACTER from, LPITEM item) const
-{
-	if (IsPC())
-		return false;
-
-	// TOO_LONG_DISTANCE_EXCHANGE_BUG_FIX
-	if (DISTANCE_APPROX(GetX() - from->GetX(), GetY() - from->GetY()) > 2000)
-		return false;
-	// END_OF_TOO_LONG_DISTANCE_EXCHANGE_BUG_FIX
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (item->IsSealed())
-	{
-		from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot improve a soulbound item."));
-		return false;
-	}
-#endif
-
-	switch (GetRaceNum())
-	{
-		case fishing::CAMPFIRE_MOB:
-		{
-			if (item->GetType() == ITEM_FISH &&
-				(item->GetSubType() == FISH_ALIVE || item->GetSubType() == FISH_DEAD))
-				return true;
-		}
-		break;
-
-		case fishing::FISHER_MOB:
-		{
-			if (item->GetType() == ITEM_ROD)
-				return true;
-		}
-		break;
-
-		// BUILDING_NPC
-		case BLACKSMITH_WEAPON_MOB:
-		case DEVILTOWER_BLACKSMITH_WEAPON_MOB:
-		{
-			if (item->GetType() == ITEM_WEAPON &&
-				item->GetRefinedVnum())
-				return true;
-			else
-				return false;
-		}
-		break;
-
-		case BLACKSMITH_ARMOR_MOB:
-		case DEVILTOWER_BLACKSMITH_ARMOR_MOB:
-		{
-			if (item->GetType() == ITEM_ARMOR &&
-				(item->GetSubType() == ARMOR_BODY || item->GetSubType() == ARMOR_SHIELD || item->GetSubType() == ARMOR_HEAD) &&
-				item->GetRefinedVnum())
-				return true;
-			else
-				return false;
-		}
-		break;
-
-		case BLACKSMITH_ACCESSORY_MOB:
-		case DEVILTOWER_BLACKSMITH_ACCESSORY_MOB:
-		{
-			if (item->GetType() == ITEM_ARMOR &&
-				!(item->GetSubType() == ARMOR_BODY || item->GetSubType() == ARMOR_SHIELD || item->GetSubType() == ARMOR_HEAD) &&
-				item->GetRefinedVnum())
-				return true;
-			else
-				return false;
-		}
-		break;
-		// END_OF_BUILDING_NPC
-
-		case BLACKSMITH_MOB:
-		{
-			if (item->GetRefinedVnum() && item->GetRefineSet() < 500)
-				return true;
-			else
-				return false;
-		}
-		break;
-
-		case BLACKSMITH2_MOB:
-		{
-			if (item->GetRefineSet() >= 500)
-				return true;
-			else
-				return false;
-		}
-		break;
-
-		case ALCHEMIST_MOB:
-		{
-			if (item->GetRefinedVnum())
-				return true;
-		}
-		break;
-
-		case 20101:
-		case 20102:
-		case 20103:
-		{
-			// 초급 말
-			if (item->GetVnum() == ITEM_REVIVE_HORSE_1)
-			{
-				if (!IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("죽지 않은 말에게 선초를 먹일 수 없습니다."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_1)
-			{
-				if (IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("죽은 말에게 사료를 먹일 수 없습니다."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_2 || item->GetVnum() == ITEM_HORSE_FOOD_3)
-			{
-				return false;
-			}
-		}
-		break;
-
-		case 20104:
-		case 20105:
-		case 20106:
-		{
-			// 중급 말
-			if (item->GetVnum() == ITEM_REVIVE_HORSE_2)
-			{
-				if (!IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("죽지 않은 말에게 선초를 먹일 수 없습니다."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_2)
-			{
-				if (IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("죽은 말에게 사료를 먹일 수 없습니다."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 || item->GetVnum() == ITEM_HORSE_FOOD_3)
-			{
-				return false;
-			}
-		}
-		break;
-
-		case 20107:
-		case 20108:
-		case 20109:
-		{
-			// 고급 말
-			if (item->GetVnum() == ITEM_REVIVE_HORSE_3)
-			{
-				if (!IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("죽지 않은 말에게 선초를 먹일 수 없습니다."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_3)
-			{
-				if (IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("죽은 말에게 사료를 먹일 수 없습니다."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 || item->GetVnum() == ITEM_HORSE_FOOD_2)
-			{
-				return false;
-			}
-		}
-		break;
-
-		default:
-			break;
-	}
-
-	//if (IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_GIVE))
-	{
-		return true;
-	}
-
-	return false;
-}
-
-void CHARACTER::ReceiveItem(LPCHARACTER from, LPITEM item)
-{
-	if (IsPC())
-		return;
-
-	switch (GetRaceNum())
-	{
-		case fishing::CAMPFIRE_MOB:
-		{
-			if (item->GetType() == ITEM_FISH && (item->GetSubType() == FISH_ALIVE || item->GetSubType() == FISH_DEAD))
-				fishing::Grill(from, item);
-			else
-			{
-				// TAKE_ITEM_BUG_FIX
-				from->SetQuestNPCID(GetVID());
-				// END_OF_TAKE_ITEM_BUG_FIX
-				quest::CQuestManager::instance().TakeItem(from->GetPlayerID(), GetRaceNum(), item);
-			}
-		}
-		break;
-
-#ifdef ENABLE_QUEEN_NETHIS
-		case SnakeLair::PILAR_STEP_4:
-			{
-				if(from->IsPC())
-				{
-					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
-						SnakeLair::CSnk::instance().OnKillPilar(item, from, this);
-				}
-			}
-			break;
-		case SnakeLair::BLACKSMITH_5:
-			{
-				if(from->IsPC())
-				{
-					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
-						SnakeLair::CSnk::instance().OnKillBlackSmith(item, from, this);
-				}
-			}
-			break;
-
-		case SnakeLair::SNAKE_STATUE1:
-		case SnakeLair::SNAKE_STATUE2:
-		case SnakeLair::SNAKE_STATUE3:
-		case SnakeLair::SNAKE_STATUE4:
-			{
-				if(from->IsPC())
-				{
-					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
-						SnakeLair::CSnk::instance().OnStatueSetRotation(item, from, this);
-				}
-			}
-			break;
-#endif
-
-		// DEVILTOWER_NPC
-		case DEVILTOWER_BLACKSMITH_WEAPON_MOB:
-		case DEVILTOWER_BLACKSMITH_ARMOR_MOB:
-		case DEVILTOWER_BLACKSMITH_ACCESSORY_MOB:
-		{
-			if (item->GetRefinedVnum() != 0 && item->GetRefineSet() != 0 && item->GetRefineSet() < 500)
-			{
-				from->SetRefineNPC(this);
-				from->RefineInformation(item->GetCell(), REFINE_TYPE_MONEY_ONLY);
-			}
-			else
-			{
-				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템은 개량할 수 없습니다."));
-			}
-		}
-		break;
-		// END_OF_DEVILTOWER_NPC
-
-		case BLACKSMITH_MOB:
-		case BLACKSMITH2_MOB:
-		case BLACKSMITH_WEAPON_MOB:
-		case BLACKSMITH_ARMOR_MOB:
-		case BLACKSMITH_ACCESSORY_MOB:
-		{
-			if (item->GetRefinedVnum())
-			{
-				from->SetRefineNPC(this);
-				from->RefineInformation(item->GetCell(), REFINE_TYPE_NORMAL);
-			}
-			else
-			{
-				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("이 아이템은 개량할 수 없습니다."));
-			}
-		}
-		break;
-
-		case 20101:
-		case 20102:
-		case 20103:
-		case 20104:
-		case 20105:
-		case 20106:
-		case 20107:
-		case 20108:
-		case 20109:
-		{
-			if (item->GetVnum() == ITEM_REVIVE_HORSE_1 ||
-				item->GetVnum() == ITEM_REVIVE_HORSE_2 ||
-				item->GetVnum() == ITEM_REVIVE_HORSE_3)
-			{
-				from->ReviveHorse();
-				item->SetCount(item->GetCount() - 1);
-				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("말에게 선초를 주었습니다."));
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 ||
-				item->GetVnum() == ITEM_HORSE_FOOD_2 ||
-				item->GetVnum() == ITEM_HORSE_FOOD_3)
-			{
-				from->FeedHorse();
-				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("말에게 사료를 주었습니다."));
-				item->SetCount(item->GetCount() - 1);
-				EffectPacket(SE_HPUP_RED);
-			}
-		}
-		break;
-
-		default:
-		{
-			sys_log(0, "TakeItem %s %d %s", from->GetName(), GetRaceNum(), item->GetName());
-			from->SetQuestNPCID(GetVID());
-			quest::CQuestManager::instance().TakeItem(from->GetPlayerID(), GetRaceNum(), item);
-		}
-		break;
-	}
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	if (CGuildDragonLairManager::Instance().IsRedDragonLair(from->GetMapIndex())
-		&& CGuildDragonLairManager::Instance().IsStone(GetRaceNum()))
-	{
-		if (item->GetVnum() == ITEM_GUILD_DRAGONLAIR_RING)
-		{
-			sys_log(0, "GuildDragonLair TakeItem %s %d %s", from->GetName(), GetRaceNum(), item->GetName());
-
-			if (from->GetGuildDragonLair())
-				from->GetGuildDragonLair()->TakeItem(from, this, item);
-		}
-	}
-#endif
-}
-
-bool CHARACTER::IsEquipUniqueItem(DWORD dwItemVnum) const
-{
-	{
-		LPITEM u = GetWear(WEAR_UNIQUE1);
-
-		if (u && u->GetVnum() == dwItemVnum)
-			return true;
-	}
-
-	{
-		LPITEM u = GetWear(WEAR_UNIQUE2);
-
-		if (u && u->GetVnum() == dwItemVnum)
-			return true;
-	}
-
-	return false;
-}
-
-// CHECK_UNIQUE_GROUP
-bool CHARACTER::IsEquipUniqueGroup(DWORD dwGroupVnum) const
-{
-	{
-		LPITEM u = GetWear(WEAR_UNIQUE1);
-
-		if (u && u->GetSpecialGroup() == (int)dwGroupVnum)
-			return true;
-	}
-
-	{
-		LPITEM u = GetWear(WEAR_UNIQUE2);
-
-		if (u && u->GetSpecialGroup() == (int)dwGroupVnum)
-			return true;
-	}
-
-	return false;
-}
-// END_OF_CHECK_UNIQUE_GROUP
-
-void CHARACTER::SetRefineMode(int iAdditionalCell)
-{
-	m_iRefineAdditionalCell = iAdditionalCell;
-	SetUnderRefine(true);
-}
-
-void CHARACTER::ClearRefineMode()
-{
-	SetUnderRefine(false);
-	SetRefineNPC(NULL);
-}
-
-//bool CHARACTER::GiveItemFromSpecialItemGroup(DWORD dwGroupNum, std::vector<DWORD>& dwItemVnums,
-//	std::vector<DWORD>& dwItemCounts, std::vector <LPITEM>& item_gets, int& count)
-bool CHARACTER::GiveItemFromSpecialItemGroup(DWORD dwGroupNum)
-{
-	const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(dwGroupNum);
-
-	if (!pGroup)
-	{
-		sys_err("cannot find special item group %d", dwGroupNum);
-		return false;
-	}
-
-	std::vector<int> idxes;
-	int n = pGroup->GetMultiIndex(idxes);
-
-	bool bSuccess = false;
-
-	for (int i = 0; i < n; i++)
-	{
-		bSuccess = false;
-		int idx = idxes[i];
-		DWORD dwVnum = pGroup->GetVnum(idx);
-		DWORD dwCount = pGroup->GetCount(idx);
-		int iRarePct = pGroup->GetRarePct(idx);
-		LPITEM item_get = NULL;
-		switch (dwVnum)
-		{
-			case CSpecialItemGroup::GOLD:
-			{
-				PointChange(POINT_GOLD, dwCount, true);
-				LogManager::instance().CharLog(this, dwCount, "TREASURE_GOLD", "");
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::EXP:
-			{
-				PointChange(POINT_EXP, dwCount);
-				LogManager::instance().CharLog(this, dwCount, "TREASURE_EXP", "");
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::MOB:
-			{
-				sys_log(0, "CSpecialItemGroup::MOB %d", dwCount);
-				int x = GetX() + number(-500, 500);
-				int y = GetY() + number(-500, 500);
-
-				LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(dwCount, GetMapIndex(), x, y, 0, true, -1);
-				if (ch)
-					ch->SetAggressive();
-				else
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("This doesn't seem to work here."));
-					return false;
-				}
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("상자에서 몬스터가 나타났습니다!"));
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::SLOW:
-			{
-				sys_log(0, "CSpecialItemGroup::SLOW %d", -(int)dwCount);
-				AddAffect(AFFECT_SLOW, POINT_MOV_SPEED, -(int)dwCount, AFF_SLOW, 300, 0, true);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("상자에서 나온 빨간 연기를 들이마시자 움직이는 속도가 느려졌습니다!"));
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::DRAIN_HP:
-			{
-				int iDropHP = GetMaxHP() * dwCount / 100;
-				sys_log(0, "CSpecialItemGroup::DRAIN_HP %d", -iDropHP);
-				iDropHP = MIN(iDropHP, GetHP() - 1);
-				sys_log(0, "CSpecialItemGroup::DRAIN_HP %d", -iDropHP);
-				PointChange(POINT_HP, -iDropHP);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("상자가 갑자기 폭발하였습니다! 생명력이 감소했습니다."));
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::POISON:
-			{
-				AttackedByPoison(NULL);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("상자에서 나온 녹색 연기를 들이마시자 독이 온몸으로 퍼집니다!"));
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::BLEEDING:
-			{
-				AttackedByBleeding(NULL);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("상자에서 나온 빨간 연기를 들이마시자 움직이는 속도가 느려졌습니다!"));
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::MOB_GROUP:
-			{
-				int sx = GetX() - number(300, 500);
-				int sy = GetY() - number(300, 500);
-				int ex = GetX() + number(300, 500);
-				int ey = GetY() + number(300, 500);
-				LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnGroup(dwCount, GetMapIndex(), sx, sy, ex, ey, NULL, true);
-				if (!ch)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("This doesn't seem to work here."));
-					return false;
-				}
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("상자에서 몬스터가 나타났습니다!"));
-				bSuccess = true;
-			}
-			break;
-
-			default:
-			{
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-				item_get = AutoGiveItem(dwVnum, dwCount, iRarePct, true, true);
-#else
-				item_get = AutoGiveItem(dwVnum, dwCount, iRarePct);
-#endif
-				if (item_get)
-					bSuccess = true;
-			}
-			break;
-		}
-
-		if (!bSuccess)
-		{
-			ChatPacket(CHAT_TYPE_TALKING, LC_STRING("아무것도 얻을 수 없었습니다."));
-			return false;
-		}
-	}
-	return bSuccess;
-}
-
-// NEW_HAIR_STYLE_ADD
-bool CHARACTER::ItemProcess_Hair(LPITEM item, int iDestCell)
-{
-	if (item->CheckItemUseLevel(GetLevel()) == false)
-	{
-		// 레벨 제한에 걸림
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("아직 이 머리를 사용할 수 없는 레벨입니다."));
-		return false;
-	}
-
-	DWORD hair = item->GetVnum();
-
-	switch (GetJob())
-	{
-		case JOB_WARRIOR:
-			hair -= 72000; // 73001 - 72000 = 1001 부터 헤어 번호 시작
-			break;
-
-		case JOB_ASSASSIN:
-			hair -= 71250;
-			break;
-
-		case JOB_SURA:
-			hair -= 70500;
-			break;
-
-		case JOB_SHAMAN:
-			hair -= 69750;
-			break;
-
-		case JOB_WOLFMAN:
-			break;
-
-		default:
-			return false;
-			break;
-	}
-
-	if (hair == GetPart(PART_HAIR))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("동일한 머리 스타일로는 교체할 수 없습니다."));
-		return true;
-	}
-
-	item->SetCount(item->GetCount() - 1);
-
-	SetPart(PART_HAIR, hair);
-	UpdatePacket();
-
-	return true;
-}
-// END_NEW_HAIR_STYLE_ADD
-
-bool CHARACTER::ItemProcess_Polymorph(LPITEM item)
-{
-	if (IsPolymorphed())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("이미 둔갑중인 상태입니다."));
-		return false;
-	}
-
-	if (true == IsRiding())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("둔갑할 수 없는 상태입니다."));
-		return false;
-	}
-
-	DWORD dwVnum = item->GetSocket(0);
-
-	if (dwVnum == 0)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("잘못된 둔갑 아이템입니다."));
-		item->SetCount(item->GetCount() - 1);
-		return false;
-	}
-
-	const CMob* pMob = CMobManager::instance().Get(dwVnum);
-
-	if (pMob == NULL)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("잘못된 둔갑 아이템입니다."));
-		item->SetCount(item->GetCount() - 1);
-		return false;
-	}
-
-	switch (item->GetVnum())
-	{
-		case 70104: // Polymorph Marble
-		case 70105: // Polymorph Marble
-		case 70106: // Polymorph Marble
-		case 70107: // Polymorph Marble
-		case 71093: // Polymorph Marble
-		{
-			// 둔갑구 처리
-			sys_log(0, "USE_POLYMORPH_BALL PID(%d) vnum(%d)", GetPlayerID(), dwVnum);
-
-			// 레벨 제한 체크
-			int iPolymorphLevelLimit = MAX(0, 20 - GetLevel() * 3 / 10);
-			if (pMob->m_table.bLevel >= GetLevel() + iPolymorphLevelLimit)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("나보다 너무 높은 레벨의 몬스터로는 변신 할 수 없습니다."));
-				return false;
-			}
-
-			int iDuration = GetSkillLevel(POLYMORPH_SKILL_ID) == 0 ? 5 : (5 + (5 + GetSkillLevel(POLYMORPH_SKILL_ID) / 40 * 25));
-			iDuration *= 60;
-
-			DWORD dwBonus = 0;
-
-			if (true == LC_IsYMIR() || true == LC_IsKorea())
-			{
-				dwBonus = GetSkillLevel(POLYMORPH_SKILL_ID) + 60;
-			}
-			else
-			{
-				dwBonus = (2 + GetSkillLevel(POLYMORPH_SKILL_ID) / 40) * 100;
-			}
-
-			AddAffect(AFFECT_POLYMORPH, POINT_POLYMORPH, dwVnum, AFF_POLYMORPH, iDuration, 0, true);
-			AddAffect(AFFECT_POLYMORPH, POINT_ATT_BONUS, dwBonus, AFF_POLYMORPH, iDuration, 0, false);
-
-			item->SetCount(item->GetCount() - 1);
-		}
-		break;
-
-		case 50322: // Transformation Role
-		{
-			// 보류
-
-			// 둔갑서 처리
-			// 소켓0 소켓1 소켓2
-			// 둔갑할 몬스터 번호 수련정도 둔갑서 레벨
-			sys_log(0, "USE_POLYMORPH_BOOK: %s(%u) vnum(%u)", GetName(), GetPlayerID(), dwVnum);
-
-			if (CPolymorphUtils::instance().PolymorphCharacter(this, item, pMob) == true)
-			{
-				CPolymorphUtils::instance().UpdateBookPracticeGrade(this, item);
-			}
-			else
-			{
-			}
-		}
-		break;
-
-		default:
-			sys_err("POLYMORPH invalid item passed PID(%d) vnum(%d)", GetPlayerID(), item->GetOriginalVnum());
-			return false;
-	}
-
-	return true;
-}
-
-bool CHARACTER::CanDoCube() const
-{
-	if (m_bIsObserver) return false;
-	if (GetShop()) return false;
-	if (GetMyShop()) return false;
-	if (IsUnderRefine()) return false;
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	if (IsUnderRefineElement()) return false;
-#endif
-	if (IsWarping()) return false;
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	if (IsAcceRefineWindowOpen()) return false;
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	if (IsAuraRefineWindowOpen()) return false;
-#endif
-
-	return true;
-}
-
-bool CHARACTER::UnEquipSpecialRideUniqueItem()
-{
-	LPITEM Unique1 = GetWear(WEAR_UNIQUE1);
-	LPITEM Unique2 = GetWear(WEAR_UNIQUE2);
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	LPITEM MountCostume = GetWear(WEAR_COSTUME_MOUNT);
-#endif
-
-	if (NULL != Unique1)
-	{
-		if (UNIQUE_GROUP_SPECIAL_RIDE == Unique1->GetSpecialGroup())
-		{
-			return UnequipItem(Unique1);
-		}
-	}
-
-	if (NULL != Unique2)
-	{
-		if (UNIQUE_GROUP_SPECIAL_RIDE == Unique2->GetSpecialGroup())
-		{
-			return UnequipItem(Unique2);
-		}
-	}
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	if (MountCostume)
-		return UnequipItem(MountCostume);
-#endif
-
-	return true;
-}
-
-void CHARACTER::AutoRecoveryItemProcess(const EAffectTypes type)
-{
-	if (true == IsDead() || true == IsStun())
-		return;
-
-	if (false == IsPC())
-		return;
-
-	if (AFFECT_AUTO_HP_RECOVERY != type && AFFECT_AUTO_SP_RECOVERY != type)
-		return;
-
-	if (NULL != FindAffect(AFFECT_STUN))
-		return;
-
-	{
-		const DWORD stunSkills[] = { SKILL_TANHWAN, SKILL_GEOMPUNG, SKILL_BYEURAK, SKILL_GIGUNG };
-
-		for (size_t i = 0; i < sizeof(stunSkills) / sizeof(DWORD); ++i)
-		{
-			const CAffect* p = FindAffect(stunSkills[i]);
-
-			if (NULL != p && AFF_STUN == p->dwFlag)
-				return;
-		}
-	}
-
-	const CAffect* pAffect = FindAffect(type);
-	const size_t idx_of_amount_of_used = 1;
-	const size_t idx_of_amount_of_full = 2;
-
-	if (NULL != pAffect)
-	{
-		LPITEM pItem = FindItemByID(pAffect->dwFlag);
-
-		if ((NULL != pItem) && (pItem->GetSocket(0) > 0))
-		{
-			if (false == CArenaManager::instance().IsArenaMap(GetMapIndex()))
-			{
-				const long amount_of_used = pItem->GetSocket(idx_of_amount_of_used);
-				const long amount_of_full = pItem->GetSocket(idx_of_amount_of_full);
-
-				const int32_t avail = amount_of_full - amount_of_used;
-
-				int32_t amount = 0;
-
-				if (AFFECT_AUTO_HP_RECOVERY == type)
-				{
-					amount = GetMaxHP() - (GetHP() + GetPoint(POINT_HP_RECOVERY));
-				}
-				else if (AFFECT_AUTO_SP_RECOVERY == type)
-				{
-					amount = GetMaxSP() - (GetSP() + GetPoint(POINT_SP_RECOVERY));
-				}
-
-				if (amount > 0)
-				{
-					if (avail > amount)
-					{
-						const int pct_of_used = amount_of_used * 100 / amount_of_full;
-						const int pct_of_will_used = (amount_of_used + amount) * 100 / amount_of_full;
-
-						bool bLog = false;
-						// 사용량의 10% 단위로 로그를 남김
-						// (사용량의 %에서, 십의 자리가 바뀔 때마다 로그를 남김.)
-						if ((pct_of_will_used / 10) - (pct_of_used / 10) >= 1)
-							bLog = true;
-						pItem->SetSocket(idx_of_amount_of_used, amount_of_used + amount, bLog);
-					}
-					else
-					{
-						amount = avail;
-
-#if defined(__USE_NEXT_AUTO_POTION__)
-						for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
-						{
-							LPITEM pkNextItem = GetInventoryItem(wCell);
-							if (NULL == pkNextItem)
-								continue;
-
-							if (pItem->GetWindow() == pkNextItem->GetWindow() && pItem->GetCell() != pkNextItem->GetCell())
-							{
-								UseItemEx(pkNextItem, TItemPos(INVENTORY, wCell));
-								break;
-							}
-						}
-#endif
-
-						ITEM_MANAGER::instance().RemoveItem(pItem);
-					}
-
-					if (AFFECT_AUTO_HP_RECOVERY == type)
-					{
-						PointChange(POINT_HP_RECOVERY, amount);
-						EffectPacket(SE_AUTO_HPUP);
-					}
-					else if (AFFECT_AUTO_SP_RECOVERY == type)
-					{
-						PointChange(POINT_SP_RECOVERY, amount);
-						EffectPacket(SE_AUTO_SPUP);
-					}
-				}
-			}
-			else
-			{
-				pItem->Lock(false);
-				pItem->SetSocket(0, false);
-				RemoveAffect(const_cast<CAffect*>(pAffect));
-			}
-		}
-		else
-		{
-			RemoveAffect(const_cast<CAffect*>(pAffect));
-		}
-	}
-}
-
-bool CHARACTER::IsValidItemPosition(TItemPos Pos) const
-{
-	BYTE window_type = Pos.window_type;
-	WORD cell = Pos.cell;
-
-	switch (window_type)
-	{
-		case INVENTORY:
-			return cell < INVENTORY_MAX_NUM;
-
-		case EQUIPMENT:
-			return cell < EQUIPMENT_MAX_NUM;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case DRAGON_SOUL_INVENTORY:
-			return cell < DRAGON_SOUL_INVENTORY_MAX_NUM;
-#endif
-
-		case BELT_INVENTORY:
-			return cell < BELT_INVENTORY_MAX_NUM;
-
-		case SAFEBOX:
-			if (NULL != m_pkSafebox)
-				return m_pkSafebox->IsValidPosition(cell);
-			else
-				return false;
-
-		case MALL:
-			if (NULL != m_pkMall)
-				return m_pkMall->IsValidPosition(cell);
-			else
-				return false;
-
-#if defined(__ATTR_6TH_7TH__)
-		case NPC_STORAGE:
-			return cell < NPC_STORAGE_SLOT_MAX;
-#endif
-
-		default:
-			return false;
-	}
-}
-
-/// 현재 캐릭터의 상태를 바탕으로 주어진 item을 착용할 수 있는 지 확인하고, 불가능 하다면 캐릭터에게 이유를 알려주는 함수
-bool CHARACTER::CanEquipNow(const LPITEM item, const TItemPos& srcCell, const TItemPos& destCell) /*const*/
-{
-	if (IsFishing())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
-		return false;
-	}
-
-	const TItemTable* itemTable = item->GetProto();
-	//BYTE itemType = item->GetType();
-	//BYTE itemSubType = item->GetSubType();
-
-	switch (GetJob())
-	{
-		case JOB_WARRIOR:
-			if (item->GetAntiFlag() & ITEM_ANTIFLAG_WARRIOR)
-				return false;
-			break;
-
-		case JOB_ASSASSIN:
-			if (item->GetAntiFlag() & ITEM_ANTIFLAG_ASSASSIN)
-				return false;
-			break;
-
-		case JOB_SHAMAN:
-			if (item->GetAntiFlag() & ITEM_ANTIFLAG_SHAMAN)
-				return false;
-			break;
-
-		case JOB_SURA:
-			if (item->GetAntiFlag() & ITEM_ANTIFLAG_SURA)
-				return false;
-			break;
-
-		case JOB_WOLFMAN:
-			if (item->GetAntiFlag() & ITEM_ANTIFLAG_WOLFMAN)
-				return false;
-			break;
-
-	}
-
-	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-	{
-		long limit = itemTable->aLimits[i].lValue;
-		switch (itemTable->aLimits[i].bType)
-		{
-			case LIMIT_LEVEL:
-			{
-				if (GetLevel() < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("레벨이 낮아 착용할 수 없습니다."));
-					return false;
-				}
-			}
-			break;
-
-#if defined(__CONQUEROR_LEVEL__)
-			case LIMIT_NEWWORLD_LEVEL:
-			{
-				if (GetConquerorLevel() < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("레벨이 낮아 착용할 수 없습니다."));
-					return false;
-				}
-			}
-			break;
-#endif
-
-			case LIMIT_STR:
-			{
-				if (GetPoint(POINT_ST) < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("근력이 낮아 착용할 수 없습니다."));
-					return false;
-				}
-			}
-			break;
-
-			case LIMIT_INT:
-			{
-				if (GetPoint(POINT_IQ) < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("지능이 낮아 착용할 수 없습니다."));
-					return false;
-				}
-			}
-			break;
-
-			case LIMIT_DEX:
-			{
-				if (GetPoint(POINT_DX) < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("민첩이 낮아 착용할 수 없습니다."));
-					return false;
-				}
-			}
-			break;
-
-			case LIMIT_CON:
-			{
-				if (GetPoint(POINT_HT) < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("체력이 낮아 착용할 수 없습니다."));
-					return false;
-				}
-			}
-			break;
-		}
-	}
-
-	if (item->GetWearFlag() & WEARABLE_UNIQUE)
-	{
-		if ((GetWear(WEAR_UNIQUE1) && GetWear(WEAR_UNIQUE1)->IsSameSpecialGroup(item)) ||
-			(GetWear(WEAR_UNIQUE2) && GetWear(WEAR_UNIQUE2)->IsSameSpecialGroup(item)))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("같은 종류의 유니크 아이템 두 개를 동시에 장착할 수 없습니다."));
-			return false;
-		}
-
-		if (marriage::CManager::instance().IsMarriageUniqueItem(item->GetVnum()) &&
-			!marriage::CManager::instance().IsMarried(GetPlayerID()))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("결혼하지 않은 상태에서 예물을 착용할 수 없습니다."));
-			return false;
-		}
-	}
-
-#if defined(__PET_SYSTEM__)
-	if (item->IsPet() && SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::PET_BLOCK_MAP_INDEX, GetMapIndex()))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
-		return false;
-	}
-#endif
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	if (item->IsCostumeMount() && SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX, GetMapIndex()))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
-		return false;
-	}
-#endif
-
-	return true;
-}
-
-/// 현재 캐릭터의 상태를 바탕으로 착용 중인 item을 벗을 수 있는 지 확인하고, 불가능 하다면 캐릭터에게 이유를 알려주는 함수
-bool CHARACTER::CanUnequipNow(const LPITEM item, const TItemPos& srcCell, const TItemPos& destCell) /*const*/
-//bool CHARACTER::CanUnequipNow(const LPITEM item, const TItemPos& swapCell) /*const*/
-{
-	if (item->IsBelt())
-	{
-		if (CBeltInventoryHelper::IsExistItemInBeltInventory(this))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can only discard the belt when there are no longer any items in its inventory."));
-			return false;
-		}
-	}
-
-	// 영원히 해제할 수 없는 아이템
-	if (IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-		return false;
-
-	if (IsFishing())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
-		return false;
-	}
-
-	// 아이템 unequip시 인벤토리로 옮길 때 빈 자리가 있는 지 확인
-	{
-		int pos = -1;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-			pos = GetEmptyDragonSoulInventory(item);
-		else
-#endif
-			pos = GetEmptyInventory(item->GetSize());
-
-		if (-1 == pos)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지품에 빈 공간이 없습니다."));
-			return false;
-		}
-	}
-
-	return true;
-}
-
-#ifdef __OFFLINE_SHOP__
-bool CHARACTER::UseItemOpenOfflineShop(CItem* item)
-{
-	if (!item) {
-		return false;
-	}
-
-	if (IsOpeningOfflineShop()) {
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ZATEN_PAZAR_ACIYORSUN"));
-		return false;
-	}
-
-	item->Lock(true);
-	SetOpeningOfflineShopState(true);
-	SetOfflineShopOpeningItem(item);
-
-	ChatPacket(CHAT_TYPE_COMMAND, "StartOpeningOfflineShop %d %lld",
-		item->GetValue(COfflineShop::ITEM_TIME_IDX), item->GetValue(COfflineShop::ITEM_GOLD_IDX));
-
-	return true;
-}
-#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-void CHARACTER::OpenItemComb()
-{
-	if (PreventTradeWindow(WND_ALL))
-	{
-		ChatPacket(CHAT_TYPE_INFO, "You have to close other windows.");
-		return;
-	}
-
-	const LPCHARACTER npc = GetQuestNPC();
-	if (npc == NULL)
-	{
-		sys_err("Item Combination NPC is NULL (ch: %s)", GetName());
-		return;
-	}
-
-	SetItemCombNpc(npc);
-	ChatPacket(CHAT_TYPE_COMMAND, "ShowItemCombinationDialog");
-}
-
-void CHARACTER::ItemCombination(const short MediumIndex, const short BaseIndex, const short MaterialIndex)
-{
-	if (IsItemComb() == false)
-		return;
-
-	const LPITEM MediumItem = GetItem(TItemPos(INVENTORY, MediumIndex));
-	const LPITEM BaseItem = GetItem(TItemPos(INVENTORY, BaseIndex));
-	const LPITEM MaterialItem = GetItem(TItemPos(INVENTORY, MaterialIndex));
-
-	if (MediumItem == NULL || BaseItem == NULL || MaterialItem == NULL)
-		return;
-
-	if (BaseItem->GetCount() > 1 || MaterialItem->GetCount() > 1)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Split the items first. You cannot use stacked items here."));
-		return;
-	}
-
-	if (MediumItem->GetType() != ITEM_MEDIUM)
-		return;
-
-	if (BaseItem->GetType() != MaterialItem->GetType())
-		return;
-
-	if (BaseItem->GetSubType() != MaterialItem->GetSubType())
-		return;
-
-	if (BaseItem->GetType() != EItemTypes::ITEM_COSTUME || MaterialItem->GetType() != EItemTypes::ITEM_COSTUME)
-		return;
-
-	if (BaseItem->IsEquipped() || MaterialItem->IsEquipped())
-		return;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (BaseItem->IsSealed() || MaterialItem->IsSealed())
-		return;
-#endif
-
-	if (MediumItem->GetSubType() == MEDIUM_MOVE_COSTUME_ATTR)
-	{
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-		if (BaseItem->GetSubType() == COSTUME_MOUNT || MaterialItem->GetSubType() == COSTUME_MOUNT)
-			return;
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		if (BaseItem->GetSubType() == COSTUME_ACCE || MaterialItem->GetSubType() == COSTUME_ACCE)
-			return;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-		if (BaseItem->GetSubType() == COSTUME_AURA || MaterialItem->GetSubType() == COSTUME_AURA)
-			return;
-#endif
-
-		BaseItem->SetAttributes(MaterialItem->GetAttributes());
-		BaseItem->UpdatePacket();
-
-		ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
-		MediumItem->SetCount(MediumItem->GetCount() - 1);
-	}
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	else if (MediumItem->GetSubType() == MEDIUM_MOVE_ACCE_ATTR)
-	{
-		if (MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_ITEM_VNUM) == 0)
-		{
-			if (MaterialItem->GetAttributeCount() == 0)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use a sash without a bonus as the source."));
-				return;
-			}
-		}
-
-		if (BaseItem->GetAttributeCount() > 0)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use a sash with a bonus for the target."));
-			return;
-		}
-
-		if (BaseItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) != MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot transfer the bonus as the sashes have different absorption rates."));
-			return;
-		}
-
-		if (BaseItem->FindApplyValue(APPLY_ACCEDRAIN_RATE) != MaterialItem->FindApplyValue(APPLY_ACCEDRAIN_RATE))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot transfer the bonus as the sashes have different grades."));
-			return;
-		}
-
-		int iRandom = number(0, EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_MAX - 1);
-		switch (iRandom)
-		{
-			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_FAIL:
-			{
-				MaterialItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE, MAX(MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) - 1, 11));
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Failure! The absorption rate was reduced by 1%."));
-			}
-			break;
-
-			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_PARTIAL:
-			{
-				BaseItem->SetSockets(MaterialItem->GetSockets());
-				BaseItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE, MAX(MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) - 1, 11));
-				BaseItem->SetAttributes(MaterialItem->GetAttributes());
-#if defined(__ITEM_APPLY_RANDOM__)
-				MaterialItem->CopyRandomAppliesTo(BaseItem);
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				MaterialItem->CopyElementTo(BaseItem);
-#endif
-				BaseItem->UpdatePacket();
-
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Partial success! The absorption rate was reduced by 1%."));
-				ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
-			}
-			break;
-
-			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_SUCCESS:
-			{
-				BaseItem->SetSockets(MaterialItem->GetSockets());
-				BaseItem->SetAttributes(MaterialItem->GetAttributes());
-#if defined(__ITEM_APPLY_RANDOM__)
-				MaterialItem->CopyRandomAppliesTo(BaseItem);
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				MaterialItem->CopyElementTo(BaseItem);
-#endif
-				BaseItem->UpdatePacket();
-
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Success! The bonus was transferred successfully."));
-				ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
-			}
-			break;
-		}
-
-		MediumItem->SetCount(MediumItem->GetCount() - 1);
-	}
-#endif
-}
-#endif
-
-#if defined(__CHANGED_ATTR__)
-void CHARACTER::SelectAttr(LPITEM material, LPITEM item)
-{
-	const LPDESC d = GetDesc();
-	if (d == nullptr)
-		return;
-
-	if (PreventTradeWindow(WND_ALL))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot upgrade anything while another window is open."));
-		return;
-	}
-
-	if (item->GetAttributeSetIndex() == -1)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("속성을 변경할 수 없는 아이템입니다."));
-		return;
-	}
-
-	if (item->GetAttributeCount() < 1)
-		return;
-
-	const TItemPos pos(item->GetWindow(), item->GetCell());
-	if (pos.IsInventoryPosition() == false)
-		return;
-
-	m_ItemSelectAttr.dwItemID = item->GetID();
-	item->GetSelectAttr(m_ItemSelectAttr.Attr);
-
-	TPacketGCItemSelectAttr p;
-	p.bHeader = HEADER_GC_ITEM_SELECT_ATTR;
-	p.pItemPos = pos;
-	std::copy(std::begin(m_ItemSelectAttr.Attr), std::end(m_ItemSelectAttr.Attr), std::begin(p.aAttr));
-	d->Packet(&p, sizeof p);
-
-	material->SetCount(material->GetCount() - 1);
-}
-
-void CHARACTER::SelectAttrResult(const bool bNew, const TItemPos& pos)
-{
-	if (IsSelectAttr() == false)
-		return;
-
-	if (bNew)
-	{
-		const LPITEM item = GetItem(pos);
-		if (item && item->GetID() == m_ItemSelectAttr.dwItemID)
-		{
-			item->SetAttributes(m_ItemSelectAttr.Attr);
-			item->UpdatePacket();
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have changed the upgrade."));
-		}
-	}
-
-	memset(&m_ItemSelectAttr, 0, sizeof m_ItemSelectAttr);
-}
-
-bool CHARACTER::IsSelectAttr() const
-{
-	return m_ItemSelectAttr.dwItemID != 0;
-}
-#endif
-
-#if defined(__LUCKY_BOX__)
-void CHARACTER::SetLuckyBoxSrcItem(const LPITEM c_lpItem)
-{
-	if (c_lpItem == nullptr)
-		return;
-
-	if (PreventTradeWindow(WND_ALL))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have to close other windows."));
-		return;
-	}
-
-	ResetLuckyBoxData();
-
-	m_sLuckyBox.dwSrcItemVNum = c_lpItem->GetVnum();
-	m_sLuckyBox.dwSrcItemID = c_lpItem->GetID();
-	m_sLuckyBox.wSrcSlotIndex = c_lpItem->GetCell();
-
-	SendLuckyBoxInfo();
-}
-
-void CHARACTER::SendLuckyBoxInfo()
-{
-	if (!IsLuckyBoxOpen())
-		return;
-
-	if (!GetDesc())
-		return;
-
-	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
-	if (!pLuckyBox)
-		return;
-
-	if (!pLuckyBox->ContainsItems(m_sLuckyBox.dwSrcItemVNum))
-	{
-		ResetLuckyBoxData();
-		return;
-	}
-
-	m_sLuckyBox.bTryCount++;
-
-	while (true)
-	{
-		const CLuckyBoxGroup::SLuckyBoxItemInfo& item = pLuckyBox->GetRandomItem(m_sLuckyBox.dwSrcItemVNum);
-		if (pLuckyBox->GetItemCount(m_sLuckyBox.dwSrcItemVNum) > 1 && item.dwVNum == m_sLuckyBox.dwItemVNum)
-			continue;
-
-		m_sLuckyBox.dwItemVNum = item.dwVNum;
-		m_sLuckyBox.bItemCount = item.bCount;
-		break;
-	}
-
-	TPacketGCLuckyBox Packet;
-	Packet.bHeader = HEADER_GC_LUCKY_BOX;
-	Packet.dwVNum = m_sLuckyBox.dwItemVNum;
-	Packet.bCount = m_sLuckyBox.bItemCount;
-	Packet.iNeedMoney = GetLuckyBoxPrice();
-	Packet.wSlotIndex = m_sLuckyBox.wSrcSlotIndex;
-	GetDesc()->Packet(&Packet, sizeof(Packet));
-}
-
-void CHARACTER::LuckyBoxRetry()
-{
-	if (!IsLuckyBoxOpen())
-		return;
-
-	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
-	if (!pLuckyBox)
-		return;
-
-	if (m_sLuckyBox.bTryCount >= pLuckyBox->GetMaxTryCount())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can't do this anymore."));
-		return;
-	}
-
-	const int c_iPrice = GetLuckyBoxPrice();
-	if (c_iPrice > GetGold())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough money."));
-		return;
-	}
-
-	PointChange(POINT_GOLD, -c_iPrice);
-	ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d Yang has been deducted.", c_iPrice));
-	SendLuckyBoxInfo();
-}
-
-void CHARACTER::LuckyBoxReceive()
-{
-	if (!IsLuckyBoxOpen())
-		return;
-
-	const LPITEM c_lpSrcItem = ITEM_MANAGER::Instance().Find(m_sLuckyBox.dwSrcItemID);
-	if (c_lpSrcItem)
-	{
-		ITEM_MANAGER::Instance().RemoveItem(c_lpSrcItem);
-		AutoGiveItem(m_sLuckyBox.dwItemVNum, m_sLuckyBox.bItemCount);
-	}
-
-	ResetLuckyBoxData();
-}
-
-int CHARACTER::GetLuckyBoxPrice() const
-{
-	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
-	if (!pLuckyBox)
-		return 0;
-
-	int iRet = pLuckyBox->GetPrice();
-	for (int i = 1; i < m_sLuckyBox.bTryCount; i++)
-		iRet *= 2;
-
-	return iRet;
-}
-
-bool CHARACTER::IsLuckyBoxOpen() const
-{
-	return m_sLuckyBox.dwSrcItemID != 0;
-}
-
-void CHARACTER::ResetLuckyBoxData()
-{
-	memset(&m_sLuckyBox, 0, sizeof(m_sLuckyBox));
-}
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-LPITEM CHARACTER::GetNPCStorageItem(BYTE bCell) const
-{
-	return GetItem(TItemPos(NPC_STORAGE, bCell));
-}
-
-bool CHARACTER::Attr67Add(const TAttr67AddData kAttr67AddData)
-{
-	if (!IsPC())
-		return false;
-
-	if (PreventTradeWindow(WND_ATTR67ADD, true/*except*/))
-		return false;
-
-	if (GetNPCStorageItem())
-		return false;
-
-	const LPITEM pkRegistItem = GetInventoryItem(kAttr67AddData.wRegistItemPos);
-	if (pkRegistItem == nullptr)
-		return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (pkRegistItem->IsSealed())
-		return false;
-#endif
-
-	if (pkRegistItem->isLocked())
-		return false;
-
-	if (pkRegistItem->IsEquipped())
-		return false;
-
-	if (pkRegistItem->GetType() != ITEM_ARMOR && pkRegistItem->GetType() != ITEM_WEAPON)
-		return false;
-
-	pkRegistItem->Lock(true);
-
-	if (pkRegistItem->GetAttributeCount() < ITEM_MANAGER::MAX_NORM_ATTR_NUM)
-	{
-		pkRegistItem->Lock(false);
-		return false;
-	}
-
-	DWORD dwItemMaterialVnum = pkRegistItem->Get67AttrMaterial();
-	if (CountSpecifyItem(dwItemMaterialVnum) < kAttr67AddData.byMaterialCount)
-		return false;
-
-	RemoveSpecifyItem(dwItemMaterialVnum, kAttr67AddData.byMaterialCount);
-
-	long lSupportIncreasePct = 0;
-	LPITEM pSupportItem = nullptr;
-	{
-		pSupportItem = GetInventoryItem(kAttr67AddData.wSupportItemPos);
-		if (pSupportItem)
-			lSupportIncreasePct = pSupportItem->GetValue(1);
-	}
-
-	// Total success percent.
-	float fMaterialPct = kAttr67AddData.byMaterialCount * ATTR67_SUCCESS_PER_MATERIAL;
-	float fSupportPct = 0.0f;
-	if (kAttr67AddData.bySupportItemCount != 0)
-	{
-		fSupportPct = static_cast<float>(lSupportIncreasePct) / (ATTR67_MATERIAL_MAX_COUNT * ATTR67_SUPPORT_MAX_COUNT);
-		fSupportPct *= kAttr67AddData.bySupportItemCount * kAttr67AddData.byMaterialCount;
-
-	}
-	float fTotalSuccessPct = fMaterialPct + fSupportPct;
-
-	if (test_server)
-	{
-		ChatPacket(CHAT_TYPE_INFO, "<Add67> Success Percentage: %.2f", fTotalSuccessPct);
-	}
-
-	if (pSupportItem)
-	{
-		if (CountSpecifyItem(pSupportItem->GetVnum()) < kAttr67AddData.bySupportItemCount)
-		{
-			pkRegistItem->Lock(false);
-			return false;
-		}
-
-		RemoveSpecifyItem(pSupportItem->GetVnum(), kAttr67AddData.bySupportItemCount);
-	}
-
-	pkRegistItem->RemoveFromCharacter();
-	SetItem(TItemPos(NPC_STORAGE, 0), pkRegistItem);
-	{
-		const LPITEM pkAttr67Add = GetNPCStorageItem();
-		if (!pkAttr67Add)
-		{
-			// TODO: Make a backup of the item in case something goes bad.
-			pkRegistItem->Lock(false);
-			sys_err("CHARACTER::Attr67Add: failed to get regist item from ATTR67_ADD (window).");
-			return false;
-		}
-
-		SetQuestFlag("add_attr67.success", (number(1, 100) <= fTotalSuccessPct ? 1 : 0));
-		SetQuestFlag("add_attr67.wait_time", get_global_time() + ATTR67_ADD_WAIT_TIME);
-		SetQuestFlag("add_attr67.add", 0);
-		// @ attr67add_collect (handling)
-	}
-
-	return true;
-}
-#endif
-
-#if defined(__SOUL_SYSTEM__)
-void CHARACTER::SoulItemProcess(ESoulSubTypes eSubType)
-{
-	LPITEM item = nullptr;
-	for (const auto& it : GetAffectContainer())
-	{
-		if (it == nullptr || it->dwType != AFFECT_SOUL)
-			continue;
-
-		switch (eSubType)
-		{
-			case ESoulSubTypes::RED_SOUL:
-			{
-				if (it->wApplyOn == AFF_SOUL_RED)
-					item = FindItemByID(it->lApplyValue);
-			}
-			break;
-
-			case ESoulSubTypes::BLUE_SOUL:
-			{
-				if (it->wApplyOn == AFF_SOUL_BLUE)
-					item = FindItemByID(it->lApplyValue);
-			}
-			break;
-		}
-	}
-
-	if (item == nullptr)
-		return;
-
-	if (!item->isLocked() || item->GetSocket(1) != TRUE)
-		return;
-
-	long data = item->GetSocket(2);
-	long keep_time = data / 10000;
-	//auto max_time = item->GetLimitValue(1);
-	long min_time = 60;
-
-	// Minimum use time.
-	if (keep_time < min_time)
-		return;
-
-	/*
-	* Since the `remain_count` is added after the `keep_time`
-	* we can decrease `data` directly because the count
-	* stays at the end of `data`.
-	*/
-	//if (test_server)
-	//	data -= 5;
-	//else
-	--data; /* remain_count */;
-
-	/*
-	* If the remaining count is equal or below to zero
-	* then set decrease the socket data.
-	*/
-	long new_data = ((keep_time - min_time) * 10000) + item->GetValue(2);
-	long remain_count = data % 10000;
-	if (remain_count <= 0)
-	{
-		item->SetSocket(2, new_data);
-		item->ResetSoulTimerUseEvent();
-		return;
-	}
-
-	// Update the item with the new data (decreased count)
-	item->SetSocket(2, data, false /* log */);
-}
-
-int CHARACTER::GetSoulDamage(ESoulSubTypes eSubType) const
-{
-	LPITEM item = nullptr;
-	for (const auto& it : GetAffectContainer())
-	{
-		if (it == nullptr || it->dwType != AFFECT_SOUL)
-			continue;
-
-		switch (eSubType)
-		{
-			case ESoulSubTypes::RED_SOUL:
-			{
-				if (it->wApplyOn == AFF_SOUL_RED)
-					item = FindItemByID(it->lApplyValue);
-			}
-			break;
-
-			case ESoulSubTypes::BLUE_SOUL:
-			{
-				if (it->wApplyOn == AFF_SOUL_BLUE)
-					item = FindItemByID(it->lApplyValue);
-			}
-			break;
-		}
-	}
-
-	if (item == nullptr)
-		return 0;
-
-	if (item->GetSocket(1) != TRUE)
-		return 0;
-
-	int value = 0;
-	long data = item->GetSocket(2);
-	long keep_time = data / 10000;
-
-	long max_time = item->GetLimitValue(1);
-	long min_time = 60;
-
-	// Minimum use time.
-	if (keep_time < min_time)
-		return 0;
-
-	if (keep_time >= max_time)
-		return item->GetValue(5);
-
-	// Damage values in value field (3, 4, 5)
-	int value_field = 3 + std::floor(keep_time / (max_time - min_time));
-	if (value_field < ITEM_VALUES_MAX_NUM)
-		value = item->GetValue(value_field);
-
-	return value;
-}
-#endif
-
-#if defined(__SET_ITEM__)
-void CHARACTER::RefreshItemSetBonus()
-{
-	RemoveAffect(AFFECT_SET_ITEM);
-
-	bool bSetBonus = false;
-	for (const auto& [bSetValue, vItems] : ITEM_MANAGER::Instance().GetItemSetItemMap())
-	{
-		BYTE bWearCount = 0;
-
-		const auto& rkItemSetValueMap = ITEM_MANAGER::Instance().GetItemSetValueMap();
-		if (rkItemSetValueMap.empty())
-			break;
-
-		const auto& ItemSetValueMap = rkItemSetValueMap.find(bSetValue);
-		if (ItemSetValueMap == rkItemSetValueMap.end())
-			continue;
-
-		for (const auto& [bSetType, kItemTuple] : vItems)
-		{
-			LPITEM pItem = nullptr;
-			LPITEM pUnique1 = nullptr;
-			LPITEM pUnique2 = nullptr;
-			CPetSystem* pPetSystem = nullptr;
-
-			switch (bSetType)
-			{
-				case SET_ITEM_COSTUME_BODY:
-					pItem = GetWear(WEAR_COSTUME_BODY);
-					break;
-
-				case SET_ITEM_COSTUME_HAIR:
-					pItem = GetWear(WEAR_COSTUME_HAIR);
-					break;
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-				case SET_ITEM_COSTUME_MOUNT:
-					pItem = GetWear(WEAR_COSTUME_MOUNT);
-					break;
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-				case SET_ITEM_COSTUME_ACCE:
-					pItem = GetWear(WEAR_COSTUME_ACCE);
-					break;
-#endif
-
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-				case SET_ITEM_COSTUME_WEAPON:
-					pItem = GetWear(WEAR_COSTUME_WEAPON);
-					break;
-#endif
-
-				case SET_ITEM_UNIQUE:
-					pUnique1 = GetWear(WEAR_UNIQUE1);
-					pUnique2 = GetWear(WEAR_UNIQUE2);
-					break;
-
-#if defined(__PET_SYSTEM__)
-				case SET_ITEM_PET:
-					pPetSystem = GetPetSystem();
-					break;
-#endif
-			}
-
-			const auto& [dwMinVnum, dwMaxVnum, bRange] = kItemTuple;
-
-#if defined(__PET_SYSTEM__)
-			if (pPetSystem && CHECK_VNUM_RANGE(pPetSystem->GetSummonItemVnum(), dwMinVnum, dwMaxVnum, bRange))
-				++bWearCount;
-#endif
-
-			if (pUnique1 && CHECK_VNUM_RANGE(pUnique1->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
-				++bWearCount;
-
-			if (pUnique2 && CHECK_VNUM_RANGE(pUnique2->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
-				++bWearCount;
-
-			if (pItem && CHECK_VNUM_RANGE(pItem->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
-				++bWearCount;
-
-			for (const auto& [bCount, vSetBonus] : ItemSetValueMap->second)
-			{
-				if (bWearCount != bCount)
-				{
-					bSetBonus = false;
-					continue;
-				}
-
-				for (const auto& [wApplyType, lApplyValue] : vSetBonus)
-				{
-					AddAffect(AFFECT_SET_ITEM, aApplyInfo[wApplyType].wPointType, lApplyValue, 0, INFINITE_AFFECT_DURATION, 0, true, true);
-					bSetBonus = true;
-				}
-			}
-		}
-
-		if (bSetBonus)
-			break;
-	}
-}
-
-CHARACTER::SetItemCountMap CHARACTER::GetItemSetCountMap() const
-{
-	std::vector<LPITEM> vItems = { GetWear(WEAR_BODY), GetWear(WEAR_HEAD), GetWear(WEAR_WEAPON) };
-	std::map<BYTE, BYTE> mSetCount = {
-		{ SET_ITEM_SET_VALUE_1, 0 },
-		{ SET_ITEM_SET_VALUE_2, 0 },
-		{ SET_ITEM_SET_VALUE_3, 0 },
-		{ SET_ITEM_SET_VALUE_4, 0 },
-		{ SET_ITEM_SET_VALUE_5, 0 },
-	};
-
-	for (const LPITEM& pkItem : vItems)
-	{
-		if (pkItem == nullptr)
-			continue;
-
-		const BYTE bSetValue = pkItem->GetItemSetValue();
-		if (bSetValue != SET_ITEM_SET_VALUE_NONE)
-			++mSetCount[bSetValue];
-	}
-
-	return mSetCount;
-}
-
-void CHARACTER::RefreshItemSetBonusByValue()
-{
-	for (DWORD dwType = AFFECT_SET_ITEM_SET_VALUE_1; dwType <= AFFECT_SET_ITEM_SET_VALUE_5; ++dwType)
-		RemoveAffect(dwType);
-
-	const auto& rkItemSetValueMap = ITEM_MANAGER::Instance().GetItemSetValueMap();
-	if (rkItemSetValueMap.empty())
-		return;
-
-	for (const auto& rkItemSetPair : GetItemSetCountMap())
-	{
-		BYTE bSetValue = rkItemSetPair.first;
-		BYTE bWearCount = rkItemSetPair.second;
-
-		const auto& rkSetItemMap = rkItemSetValueMap.find(bSetValue);
-		if (rkSetItemMap == rkItemSetValueMap.end())
-			continue;
-
-		for (const auto& kSetItem : rkSetItemMap->second)
-		{
-			const auto& vSetBonus = kSetItem.second;
-			if (bWearCount != kSetItem.first)
-				continue;
-
-			for (const auto& kSetBonus : vSetBonus)
-				AddAffect((AFFECT_SET_ITEM_SET_VALUE_1 - 1) + bSetValue, aApplyInfo[kSetBonus.first].wPointType, kSetBonus.second, 0, INFINITE_AFFECT_DURATION, 0, true, true);
-		}
-	}
-}
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-void CHARACTER::RefineElementInformation(const LPITEM& rSrcItem, const TItemPos& kItemDestCell)
-{
-	if (!CanHandleItem())
-		return;
-
-	LPITEM pDestItem;
-	if (!IsValidItemPosition(kItemDestCell) || !(pDestItem = GetItem(kItemDestCell)))
-		return;
-
-	if (rSrcItem->IsEquipped() || pDestItem->IsEquipped())
-		return;
-
-	if (rSrcItem->IsExchanging() || pDestItem->IsExchanging())
-		return;
-
-	if (rSrcItem->isLocked() || pDestItem->isLocked())
-		return;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (pDestItem->IsSealed())
-		return;
-#endif
-
-	if (pDestItem->GetType() != ITEM_WEAPON)
-		return;
-
-	if (pDestItem->GetRefineLevel() < REFINE_ELEMENT_MIN_REFINE_LEVEL)
-		return;
-
-	TPacketGCRefineElement kPacket;
-	kPacket.bHeader = HEADER_GC_REFINE_ELEMENT;
-	kPacket.bSubHeader = REFINE_ELEMENT_GC_OPEN;
-	switch (rSrcItem->GetSubType())
-	{
-		case USE_ELEMENT_UPGRADE:
-			kPacket.bRefineType = REFINE_ELEMENT_UPGRADE;
-			break;
-		case USE_ELEMENT_DOWNGRADE:
-			kPacket.bRefineType = REFINE_ELEMENT_DOWNGRADE;
-			break;
-		case USE_ELEMENT_CHANGE:
-			kPacket.bRefineType = REFINE_ELEMENT_CHANGE;
-			break;
-		default:
-		{
-			sys_err("CHARACTER::RefineElementInformation: %s cannot receive information with unsupported material sub type.", GetName());
-			return;
-		}
-	}
-	kPacket.bResult = false;
-	kPacket.SrcPos = TItemPos(rSrcItem->GetWindow(), rSrcItem->GetCell());
-	kPacket.DestPos = kItemDestCell;
-	GetDesc()->Packet(&kPacket, sizeof(kPacket));
-
-	SetUnderRefineElement(true, kPacket.bRefineType, kPacket.SrcPos, kPacket.DestPos);
-}
-
-void CHARACTER::SetUnderRefineElement(bool bState, BYTE bRefineType, const TItemPos& rkSrcPos, const TItemPos& rkDestPos)
-{
-	m_kRefineElementItemPos.RefineType = bRefineType;
-	m_kRefineElementItemPos.SrcPos = rkSrcPos;
-	m_kRefineElementItemPos.DestPos = rkDestPos;
-	m_bUnderRefineElement = bState;
-}
-
-void CHARACTER::RefineElement(WORD wChangeElement)
-{
-	if (!IsUnderRefineElement())
-		return;
-
-	LPITEM pSrcItem;
-	if (!IsValidItemPosition(m_kRefineElementItemPos.SrcPos) || !(pSrcItem = GetItem(m_kRefineElementItemPos.SrcPos)))
-		return;
-
-	LPITEM pDestItem;
-	if (!IsValidItemPosition(m_kRefineElementItemPos.DestPos) || !(pDestItem = GetItem(m_kRefineElementItemPos.DestPos)))
-		return;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (pDestItem->IsSealed())
-		return;
-#endif
-
-	if (pDestItem->GetType() != ITEM_WEAPON)
-		return;
-
-	if (pDestItem->GetRefineLevel() < REFINE_ELEMENT_MIN_REFINE_LEVEL)
-		return;
-
-	TPacketGCRefineElement kPacket;
-	kPacket.bHeader = HEADER_GC_REFINE_ELEMENT;
-	kPacket.bSubHeader = REFINE_ELEMENT_GC_RESULT;
-	kPacket.bRefineType = m_kRefineElementItemPos.RefineType;
-	switch (kPacket.bRefineType)
-	{
-		case REFINE_ELEMENT_UPGRADE:
-		{
-			if (GetGold() < REFINE_ELEMENT_UPGRADE_YANG)
-				return;
-
-			//const TRefineTable* pRefineTable = CRefineManager::instance().GetRefineRecipe(11);
-			//if (number(1, 100) <= (pRefineTable ? pRefineTable->prob : 30))
-			if (number(1, 100) <= (test_server ? 80 : 30))
-			{
-				const WORD wMaterialApplyType = static_cast<WORD>(pSrcItem->GetValue(0));
-				const WORD wRefineElementApplyType = pDestItem->GetRefineElementApplyType();
-				if ((wRefineElementApplyType != 0) && (wRefineElementApplyType != wMaterialApplyType))
-				{
-					sys_err("CHARACTER::RefineElement: %s cannot upgrade with wrong material.", GetName());
-					return;
-				}
-
-				const BYTE bRandomValue = number_even(REFINE_ELEMENT_RANDOM_VALUE_MIN, REFINE_ELEMENT_RANDOM_VALUE_MAX);
-				const BYTE bRandomBonusValue = number_even(REFINE_ELEMENT_RANDOM_BONUS_VALUE_MIN, REFINE_ELEMENT_RANDOM_BONUS_VALUE_MAX);
-
-				pDestItem->UpgradeRefineElement(wMaterialApplyType, bRandomValue, bRandomBonusValue);
-
-				kPacket.bResult = true;
-			}
-			else
-			{
-				kPacket.bResult = false;
-			}
-
-			PointChange(POINT_GOLD, -REFINE_ELEMENT_UPGRADE_YANG);
-		}
-		break;
-
-		case REFINE_ELEMENT_DOWNGRADE:
-		{
-			if (GetGold() < REFINE_ELEMENT_DOWNGRADE_YANG)
-				return;
-
-			pDestItem->DowngradeRefineElement();
-			kPacket.bResult = true;
-
-			PointChange(POINT_GOLD, -REFINE_ELEMENT_DOWNGRADE_YANG);
-		}
-		break;
-
-		case REFINE_ELEMENT_CHANGE:
-		{
-			if (GetGold() < REFINE_ELEMENT_CHANGE_YANG)
-				return;
-
-			switch (wChangeElement)
-			{
-				case APPLY_ENCHANT_ELECT:
-				case APPLY_ENCHANT_FIRE:
-				case APPLY_ENCHANT_ICE:
-				case APPLY_ENCHANT_WIND:
-				case APPLY_ENCHANT_EARTH:
-				case APPLY_ENCHANT_DARK:
-					break;
-
-				default:
-				{
-					sys_err("CHARACTER::RefineElement: %s cannot change element with unsupported apply type.", GetName());
-					return;
-				}
-			}
-
-			const WORD wRefineElementApplyType = pDestItem->GetRefineElementApplyType();
-			if (wRefineElementApplyType == wChangeElement)
-			{
-				sys_err("CHARACTER::RefineElement: %s cannot change element with the current apply type.", GetName());
-				return;
-			}
-
-			pDestItem->ChangeRefineElement(wChangeElement);
-			kPacket.bResult = true;
-
-			PointChange(POINT_GOLD, -REFINE_ELEMENT_CHANGE_YANG);
-		}
-		break;
-
-		default:
-		{
-			sys_err("CHARACTER::RefineElement: %s cannot refine with unknown type.", GetName());
-			return;
-		}
-	}
-	kPacket.SrcPos = NPOS;
-	kPacket.DestPos = NPOS;
-	GetDesc()->Packet(&kPacket, sizeof(kPacket));
-
-	pSrcItem->SetCount(pSrcItem->GetCount() - 1);
-
-	SetUnderRefineElement(false);
-}
-
-WORD CHARACTER::GetRefineElementEffect() const
-{
-	const LPITEM pItemWeapon = GetWear(WEAR_WEAPON);
-	if ((pItemWeapon) && (pItemWeapon->GetRefineElementGrade() >= REFINE_ELEMENT_MAX))
-		return pItemWeapon->GetRefineElementApplyType();
-	return 0;
-}
-#endif
+#include "stdafx.h"
+
+#include <stack>
+
+#include "utils.h"
+#include "config.h"
+#include "char.h"
+#include "char_manager.h"
+#include "item_manager.h"
+#include "desc.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "packet.h"
+#include "affect.h"
+#include "skill.h"
+#include "start_position.h"
+#include "mob_manager.h"
+#include "db.h"
+#include "log.h"
+#include "vector.h"
+#include "buffer_manager.h"
+#include "questmanager.h"
+#include "fishing.h"
+#include "party.h"
+#include "dungeon.h"
+#include "refine.h"
+#include "unique_item.h"
+#include "war_map.h"
+#include "xmas_event.h"
+#include "marriage.h"
+#include "monarch.h"
+#include "polymorph.h"
+#include "blend_item.h"
+#include "castle.h"
+#include "BattleArena.h"
+#include "arena.h"
+#include "dev_log.h"
+#include "pcbang.h"
+#include "threeway_war.h"
+
+#include "safebox.h"
+#include "shop.h"
+#include "pvp.h"
+
+#include "../../common/VnumHelper.h"
+#include "DragonSoul.h"
+#ifdef ENABLE_QUEEN_NETHIS
+#include "SnakeLair.h"
+#endif
+#include "buff_on_attributes.h"
+#include "belt_inventory_helper.h"
+#if defined(__LOOT_FILTER_SYSTEM__)
+#	include "LootFilter.h"
+#endif
+
+#if defined(__MT_THUNDER_DUNGEON__)
+#	include "mt_thunder_dungeon.h"
+#endif
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+#	include "guild_dragonlair.h"
+#endif
+
+#ifdef __OFFLINE_SHOP__
+#include "OfflineShop.h"
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+#include "growth_pet.h"
+#endif
+
+#include "../../libgame/include/grid.h"
+
+#include <optional>
+
+const int ITEM_BROKEN_METIN_VNUM = 28960;
+
+// CHANGE_ITEM_ATTRIBUTES
+const DWORD CHARACTER::msc_dwDefaultChangeItemAttrCycle = 10;
+const char CHARACTER::msc_szLastChangeItemAttrFlag[] = "Item.LastChangeItemAttr";
+const char CHARACTER::msc_szChangeItemAttrCycleFlag[] = "change_itemattr_cycle";
+// END_OF_CHANGE_ITEM_ATTRIBUTES
+const POINT_TYPE g_aBuffOnAttrPoints[] = { POINT_ENERGY, POINT_COSTUME_ATTR_BONUS };
+
+struct FFindStone
+{
+	std::map<DWORD, LPCHARACTER> m_mapStone;
+
+	void operator()(LPENTITY pEnt)
+	{
+		if (pEnt->IsType(ENTITY_CHARACTER) == true)
+		{
+			LPCHARACTER pChar = (LPCHARACTER)pEnt;
+
+			if (pChar->IsStone() == true)
+			{
+				m_mapStone[(DWORD)pChar->GetVID()] = pChar;
+			}
+		}
+	}
+};
+
+#if defined(__MT_THUNDER_DUNGEON__)
+struct FFindMobVnum
+{
+	DWORD dwMobVnum;
+	FFindMobVnum(DWORD dwMobVnum) : dwMobVnum(dwMobVnum) {}
+
+	std::map<DWORD, LPCHARACTER> m_mapVID;
+	void operator()(LPENTITY pEnt)
+	{
+		if (pEnt && pEnt->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER pChar = dynamic_cast<LPCHARACTER>(pEnt);
+
+			if (pChar && pChar->GetRaceNum() == dwMobVnum)
+			{
+				m_mapVID[(DWORD)pChar->GetVID()] = pChar;
+			}
+		}
+	}
+};
+#endif
+
+// 환, 환, 혼
+bool IS_SUMMON_ITEM(LPITEM item, int map_index)
+{
+	if (item->GetVnum() == ITEM_MARRIAGE_RING)
+		return true;
+
+	switch (item->GetType())
+	{
+		case ITEM_QUEST:
+		{
+			if (item->GetSubType() == QUEST_WARP)
+			{
+				// NOTE : Force allow warp ring in certain maps indexes.
+				if (item->GetSpecialGroup() == UNIQUE_GROUP_WARP_RING)
+				{
+					switch (map_index)
+					{
+						case MAP_SKIPIA_DUNGEON_01:
+							return false;
+						default:
+							return true;
+					}
+				}
+				return true;
+			}
+		}
+		break;
+		case ITEM_USE:
+		{
+			if (item->GetSubType() == USE_TALISMAN)
+				return true;
+		}
+		break;
+	}
+
+	return false;
+}
+
+bool IS_MONKEY_DUNGEON(int map_index)
+{
+	switch (map_index)
+	{
+		case MAP_MONKEY_DUNGEON_11:
+		case MAP_MONKEY_DUNGEON_12:
+		case MAP_MONKEY_DUNGEON_13:
+		case MAP_MONKEY_DUNGEON:
+		case MAP_MONKEY_DUNGEON2:
+		case MAP_MONKEY_DUNGEON3:
+			return true;
+	}
+
+	return false;
+}
+
+bool IS_MAZE_DUNGEON(int map_index)
+{
+	switch (map_index)
+	{
+		case MAP_MAZE_DUNGEON1:
+		case MAP_MAZE_DUNGEON2:
+		case MAP_MAZE_DUNGEON3:
+			return true;
+	}
+
+	return false;
+}
+
+#if defined(__SNOW_DUNGEON__)
+bool IS_SNOW_DUNGEON(int map_index)
+{
+	if (map_index >= MAP_N_SNOW_DUNGEON_01 * 10000 && map_index < (MAP_N_SNOW_DUNGEON_01 + 1) * 10000)
+		return true;
+#if defined(__LABYRINTH_DUNGEON__)
+	else if (map_index >= MAP_BOSS_CRACK_SNOW * 10000 && map_index < (MAP_BOSS_CRACK_SNOW + 1) * 10000)
+		return true;
+	else if (map_index >= MAP_BOSS_AWAKEN_SNOW * 10000 && map_index < (MAP_BOSS_AWAKEN_SNOW + 1) * 10000)
+		return true;
+#endif
+
+	return false;
+}
+#endif
+
+#if defined(__ELEMENTAL_DUNGEON__)
+bool IS_ELEMENTAL_DUNGEON(int map_index)
+{
+	switch (map_index)
+	{
+		case MAP_ELEMENTAL_01:
+		case MAP_ELEMENTAL_02:
+		case MAP_ELEMENTAL_03:
+		case MAP_ELEMENTAL_04:
+			return true;
+	}
+
+	return false;
+}
+#endif
+
+bool IS_SUMMONABLE_ZONE(int map_index)
+{
+	// 키
+	if (IS_MONKEY_DUNGEON(map_index))
+		return false;
+
+	if (IS_MAZE_DUNGEON(map_index))
+		return false;
+
+	// 
+	if (IS_CASTLE_MAP(map_index))
+		return false;
+
+	switch (map_index)
+	{
+		case MAP_DEVILTOWER1: // 타
+		case MAP_SPIDERDUNGEON_02: // 탁  2
+		case MAP_SKIPIA_DUNGEON_01: // 천 
+		case MAP_SKIPIA_DUNGEON_02: // 천  2
+#if 0
+		case 193: // 탁  2-1
+		case 184: // 천 (탉)
+		case 185: // 천  2(탉)
+		case 186: // 천 (천)
+		case 187: // 천  2(천)
+		case 188: // 천 ()
+		case 189: // 천  2()
+#endif
+			//case 206: // 튿孤
+		case MAP_DEVILSCATACOMB: // 튿孤
+		case MAP_SPIDERDUNGEON_03: // 탁  3
+		case MAP_SKIPIA_DUNGEON_BOSS: // 천  ()
+		case MAP_OXEVENT: // OX Event 
+		case MAP_12ZI_STAGE: // 12ZI
+		case MAP_BATTLEFIED: // Battlefield
+			return false;
+	}
+
+	if (CBattleArena::IsBattleArenaMap(map_index))
+		return false;
+
+	//  private   柰
+	if (map_index > 10000)
+		return false;
+
+	return true;
+}
+
+bool IS_BOTARYABLE_ZONE(int nMapIndex)
+{
+	if (LC_IsYMIR() == false && LC_IsKorea() == false) return true;
+
+	switch (nMapIndex)
+	{
+		case MAP_A1:
+		case MAP_A3:
+		case MAP_B1:
+		case MAP_B3:
+		case MAP_C1:
+		case MAP_C3:
+		case MAP_PRIVATESHOP:
+			return true;
+	}
+
+	return false;
+}
+
+// item socket  타蹈  체크 -- by mhh
+static bool FN_check_item_socket(LPITEM item)
+{
+	switch (item->GetVnum())
+	{
+		case ITEM_AUTO_HP_RECOVERY_S:
+		case ITEM_AUTO_HP_RECOVERY_M:
+		case ITEM_AUTO_HP_RECOVERY_L:
+		case ITEM_AUTO_HP_RECOVERY_X:
+		case ITEM_AUTO_SP_RECOVERY_S:
+		case ITEM_AUTO_SP_RECOVERY_M:
+		case ITEM_AUTO_SP_RECOVERY_L:
+		case ITEM_AUTO_SP_RECOVERY_X:
+		case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
+		case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
+		case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
+		case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
+		{
+			if (item->GetSocket(0) == 0 && item->GetSocket(1) == 0 && item->GetSocket(2) == item->GetProto()->alValues[0])
+				return true;
+		}
+		break;
+	}
+
+	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+	{
+		if (item->GetSocket(i) != item->GetProto()->alSockets[i])
+			return false;
+	}
+
+	return true;
+}
+
+// item socket  -- by mhh
+static void FN_copy_item_socket(LPITEM dest, LPITEM src)
+{
+	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+	{
+		dest->SetSocket(i, src->GetSocket(i));
+	}
+}
+
+static bool FN_check_item_sex(LPCHARACTER ch, LPITEM item)
+{
+	//  
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_MALE))
+	{
+		if (SEX_MALE == GET_SEX(ch))
+			return false;
+	}
+
+	// 未
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_FEMALE))
+	{
+		if (SEX_FEMALE == GET_SEX(ch))
+			return false;
+	}
+
+	return true;
+}
+
+#define VERIFY_POTION(affect, afftype) \
+	if (FindAffect(affect, afftype)) \
+	{ \
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求.")); \
+		return false; \
+	}
+
+/////////////////////////////////////////////////////////////////////////////
+// ITEM HANDLING
+/////////////////////////////////////////////////////////////////////////////
+bool CHARACTER::CanHandleItem(bool bSkipCheckRefine, bool bSkipObserver)
+{
+	if (!bSkipObserver)
+		if (m_bIsObserver)
+			return false;
+
+	if (GetMyShop())
+		return false;
+
+	if (!bSkipCheckRefine)
+	{
+		if (IsUnderRefine())
+			return false;
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		if (IsUnderRefineElement())
+			return false;
+#endif
+	}
+
+	if (IsWarping())
+		return false;
+
+	if (IsCubeOpen())
+		return false;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (NULL != DragonSoul_RefineWindow_GetOpener())
+		return false;
+#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+	if (IsItemComb())
+		return false;
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	if (GetChangeLook())
+		return false;
+#endif
+
+#if defined(__MAILBOX__)
+	if (GetMailBox())
+		return false;
+#endif
+
+#if defined(__GEM_SHOP__)
+	if (GetGemShop())
+		return false;
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	if (IsAcceRefineWindowOpen())
+		return false;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+	if (IsAuraRefineWindowOpen() || NULL != GetAuraRefineWindowOpener())
+		return false;
+#endif
+
+#if defined(__CHANGED_ATTR__)
+	if (IsSelectAttr())
+		return false;
+#endif
+
+#if defined(__LUCKY_BOX__)
+	if (IsLuckyBoxOpen())
+		return false;
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	if (GetMiniGameRoulette())
+		return false;
+#endif
+
+	return true;
+}
+
+LPITEM CHARACTER::GetInventoryItem(WORD wCell) const
+{
+	return GetItem(TItemPos(INVENTORY, wCell));
+}
+
+LPITEM CHARACTER::GetEquipmentItem(WORD wCell) const
+{
+	return GetItem(TItemPos(EQUIPMENT, wCell));
+}
+
+LPITEM CHARACTER::GetDragonSoulInventoryItem(WORD wCell) const
+{
+	return GetItem(TItemPos(DRAGON_SOUL_INVENTORY, wCell));
+}
+
+LPITEM CHARACTER::GetBeltInventoryItem(WORD wCell) const
+{
+	return GetItem(TItemPos(BELT_INVENTORY, wCell));
+}
+
+LPITEM CHARACTER::GetItem(TItemPos Cell) const
+{
+	if (!IsValidItemPosition(Cell))
+		return nullptr;
+
+	WORD wCell = Cell.cell;
+	BYTE window_type = Cell.window_type;
+
+	switch (window_type)
+	{
+		case INVENTORY:
+		{
+			if (wCell >= INVENTORY_MAX_NUM)
+			{
+				sys_err("CHARACTER::GetItem: Invalid Inventory item! Window %d Cell %d", window_type, wCell);
+				return nullptr;
+			}
+			return m_pointsInstant.pInventoryItems[wCell];
+		}
+		break;
+
+		case EQUIPMENT:
+		{
+			if (wCell >= EQUIPMENT_MAX_NUM)
+			{
+				sys_err("CHARACTER::GetItem: Invalid Equipment item! Window %d Cell %d", window_type, wCell);
+				return nullptr;
+			}
+			return m_pointsInstant.pEquipmentItems[wCell];
+		}
+		break;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case DRAGON_SOUL_INVENTORY:
+		{
+			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+			{
+				sys_err("CHARACTER::GetItem: Invalid Dragon Soul item! window %d cell %d", window_type, wCell);
+				return nullptr;
+			}
+			return m_pointsInstant.pDragonSoulInventoryItems[wCell];
+		}
+		break;
+#endif
+
+		case BELT_INVENTORY:
+		{
+			if (wCell >= BELT_INVENTORY_SLOT_COUNT)
+			{
+				sys_err("CHARACTER::GetItem: Invalid Belt item! window %d cell %d", window_type, wCell);
+				return nullptr;
+			}
+			return m_pointsInstant.pBeltInventoryItems[wCell];
+		}
+		break;
+
+#if defined(__ATTR_6TH_7TH__)
+		case NPC_STORAGE:
+		{
+			if (wCell >= NPC_STORAGE_SLOT_MAX)
+			{
+				sys_err("CHARACTER::GetItem: invalid NPC_STORAGE item cell %d", wCell);
+				return nullptr;
+			}
+			return m_pointsInstant.pNPCStorageItems;
+		}
+#endif
+
+		default:
+			return nullptr;
+	}
+
+	return nullptr;
+}
+
+void CHARACTER::SetItem(TItemPos Cell, LPITEM pItem
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+	, bool isHighLight
+#endif
+)
+{
+	BYTE bWindowType = Cell.window_type;
+	WORD wCell = Cell.cell;
+
+	if ((unsigned long)((CItem*)pItem) == 0xff || (unsigned long)((CItem*)pItem) == 0xffffffff)
+	{
+		sys_err("!!! FATAL ERROR !!! item == 0xff (char: %s cell: %u)", GetName(), wCell);
+		core_dump();
+		return;
+	}
+
+	if (pItem && pItem->GetOwner())
+	{
+		assert(!"GetOwner exist");
+		return;
+	}
+
+	// 羞 觀訝
+	switch (bWindowType)
+	{
+		case INVENTORY:
+		{
+			if (wCell >= INVENTORY_MAX_NUM)
+			{
+				sys_err("CHARACTER::SetItem: Invalid Inventory item! Window %d Cell %d", bWindowType, wCell);
+				return;
+			}
+
+			LPITEM pOldItem = m_pointsInstant.pInventoryItems[wCell];
+			if (pOldItem)
+			{
+				if (wCell < INVENTORY_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * INVENTORY_WIDTH);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+						if (wSlot >= GetExtendInvenMax())
+							continue;
+#else
+						if (wSlot >= INVENTORY_MAX_NUM)
+							continue;
+#endif
+
+						if (m_pointsInstant.pInventoryItems[wSlot] && m_pointsInstant.pInventoryItems[wSlot] != pOldItem)
+							continue;
+
+						m_pointsInstant.wInventoryItemGrid[wSlot] = 0;
+					}
+				}
+				else
+					m_pointsInstant.wInventoryItemGrid[wCell] = 0;
+			}
+
+			if (pItem)
+			{
+				if (wCell < INVENTORY_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * INVENTORY_WIDTH);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+						if (wSlot >= GetExtendInvenMax())
+							continue;
+#else
+						if (wSlot >= INVENTORY_MAX_NUM)
+							continue;
+#endif
+
+						// wCell + 1  求   체크  
+						//  처歐 
+						m_pointsInstant.wInventoryItemGrid[wSlot] = wCell + 1;
+					}
+				}
+				else
+					m_pointsInstant.wInventoryItemGrid[wCell] = wCell + 1;
+			}
+
+			m_pointsInstant.pInventoryItems[wCell] = pItem;
+		}
+		break;
+
+		case EQUIPMENT:
+		{
+			if (wCell >= EQUIPMENT_MAX_NUM)
+			{
+				sys_err("CHARACTER::SetItem: Invalid Equipment item! Window %d Cell %d", bWindowType, wCell);
+				return;
+			}
+
+			LPITEM pOldItem = m_pointsInstant.pEquipmentItems[wCell];
+			if (pOldItem)
+			{
+				if (wCell < EQUIPMENT_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
+					{
+						BYTE bSlot = wCell + bSize;
+						if (bSlot >= EQUIPMENT_MAX_NUM)
+							continue;
+
+						if (m_pointsInstant.pEquipmentItems[bSlot] && m_pointsInstant.pEquipmentItems[bSlot] != pOldItem)
+							continue;
+
+						m_pointsInstant.bEquipmentItemGrid[bSlot] = 0;
+					}
+				}
+				else
+					m_pointsInstant.bEquipmentItemGrid[wCell] = 0;
+			}
+
+			if (pItem)
+			{
+				if (wCell < EQUIPMENT_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
+					{
+						BYTE bSlot = wCell + bSize;
+						if (bSlot >= EQUIPMENT_MAX_NUM)
+							continue;
+
+						m_pointsInstant.bEquipmentItemGrid[bSlot] = wCell + 1;
+					}
+				}
+				else
+					m_pointsInstant.bEquipmentItemGrid[wCell] = wCell + 1;
+			}
+
+			m_pointsInstant.pEquipmentItems[wCell] = pItem;
+		}
+		break;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case DRAGON_SOUL_INVENTORY:
+		{
+			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+			{
+				sys_err("CHARACTER::SetItem: Invalid Dragon Soul item! Window %d Cell %d", bWindowType, wCell);
+				return;
+			}
+
+			LPITEM pOldItem = m_pointsInstant.pDragonSoulInventoryItems[wCell];
+			if (pOldItem)
+			{
+				if (wCell < DRAGON_SOUL_INVENTORY_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * DRAGON_SOUL_BOX_COLUMN_NUM);
+						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+							continue;
+
+						if (m_pointsInstant.pDragonSoulInventoryItems[wSlot] && m_pointsInstant.pDragonSoulInventoryItems[wSlot] != pOldItem)
+							continue;
+
+						m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] = 0;
+					}
+				}
+				else
+					m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] = 0;
+			}
+
+			if (pItem)
+			{
+				if (wCell < DRAGON_SOUL_INVENTORY_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * DRAGON_SOUL_BOX_COLUMN_NUM);
+						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+							continue;
+
+						m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] = wCell + 1;
+					}
+				}
+				else
+					m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] = wCell + 1;
+			}
+
+			m_pointsInstant.pDragonSoulInventoryItems[wCell] = pItem;
+		}
+		break;
+#endif
+
+		case BELT_INVENTORY:
+		{
+			if (wCell >= BELT_INVENTORY_SLOT_COUNT)
+			{
+				sys_err("CHARACTER::SetItem: Invalid Belt item! Window %d Cell %d", bWindowType, wCell);
+				return;
+			}
+
+			LPITEM pOldItem = m_pointsInstant.pBeltInventoryItems[wCell];
+			if (pOldItem)
+			{
+				if (wCell < BELT_INVENTORY_SLOT_COUNT)
+				{
+					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * BELT_INVENTORY_SLOT_WIDTH);
+						if (wSlot >= BELT_INVENTORY_SLOT_COUNT)
+							continue;
+
+						if (m_pointsInstant.pBeltInventoryItems[wSlot] && m_pointsInstant.pBeltInventoryItems[wSlot] != pOldItem)
+							continue;
+
+						m_pointsInstant.bBeltInventoryItemGrid[wSlot] = 0;
+					}
+				}
+				else
+					m_pointsInstant.bBeltInventoryItemGrid[wCell] = 0;
+			}
+
+			if (pItem)
+			{
+				if (wCell < BELT_INVENTORY_SLOT_COUNT)
+				{
+					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * BELT_INVENTORY_SLOT_WIDTH);
+						if (wSlot >= BELT_INVENTORY_SLOT_COUNT)
+							continue;
+
+						m_pointsInstant.bBeltInventoryItemGrid[wSlot] = wCell + 1;
+					}
+				}
+				else
+					m_pointsInstant.bBeltInventoryItemGrid[wCell] = wCell + 1;
+			}
+
+			m_pointsInstant.pBeltInventoryItems[wCell] = pItem;
+		}
+		break;
+
+#if defined(__ATTR_6TH_7TH__)
+		case NPC_STORAGE:
+		{
+			if (wCell >= NPC_STORAGE_SLOT_MAX)
+			{
+				sys_err("CHARACTER::SetItem: invalid ATTR67_ADD item cell %d", wCell);
+				return;
+			}
+			m_pointsInstant.pNPCStorageItems = pItem;
+		}
+		break;
+#endif
+
+		default:
+			sys_err("Invalid Inventory type %d", bWindowType);
+			return;
+	}
+
+	if (GetDesc())
+	{
+		// 확 :   첨  
+		if (pItem)
+		{
+			TPacketGCItemSet pack;
+			pack.bHeader = HEADER_GC_ITEM_SET;
+			pack.Cell = Cell;
+			pack.dwVnum = pItem->GetVnum();
+			pack.dwCount = pItem->GetCount();
+			pack.dwFlags = pItem->GetFlag();
+			pack.dwAntiFlags = pItem->GetAntiFlag();
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			if (isHighLight)
+				pack.bHighLight = true;
+			else
+				pack.bHighLight = (Cell.window_type == DRAGON_SOUL_INVENTORY);
+#else
+			pack.bHighLight = (Cell.window_type == DRAGON_SOUL_INVENTORY);
+#endif
+#if defined(__SOUL_BIND_SYSTEM__)
+			pack.lSealDate = pItem->GetSealDate();
+#endif
+			thecore_memcpy(pack.alSockets, pItem->GetSockets(), sizeof(pack.alSockets));
+			thecore_memcpy(pack.aAttr, pItem->GetAttributes(), sizeof(pack.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			pack.dwTransmutationVnum = pItem->GetTransmutationVnum();
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			thecore_memcpy(&pack.RefineElement, pItem->GetRefineElement(), sizeof(pack.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			thecore_memcpy(pack.aApplyRandom, pItem->GetRandomApplies(), sizeof(pack.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+			pack.bSetValue = pItem->GetItemSetValue();
+#endif
+
+			GetDesc()->Packet(&pack, sizeof(TPacketGCItemSet));
+		}
+		else
+		{
+			TPacketGCItemSetEmpty pack;
+			pack.bHeader = HEADER_GC_ITEM_DEL;
+			pack.Cell = Cell;
+			pack.dwVnum = 0;
+			pack.dwCount = 0;
+			memset(pack.alSockets, 0, sizeof(pack.alSockets));
+			memset(pack.aAttr, 0, sizeof(pack.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			pack.dwTransmutationVnum = 0;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			memset(&pack.RefineElement, 0, sizeof(pack.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			memset(pack.aApplyRandom, 0, sizeof(pack.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+			pack.bSetValue = 0;
+#endif
+
+			GetDesc()->Packet(&pack, sizeof(TPacketGCItemSetEmpty));
+		}
+	}
+
+	if (pItem)
+	{
+		pItem->SetCell(this, wCell);
+		switch (bWindowType)
+		{
+			case INVENTORY:
+				pItem->SetWindow(INVENTORY);
+				break;
+
+			case EQUIPMENT:
+				pItem->SetWindow(EQUIPMENT);
+				break;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			case DRAGON_SOUL_INVENTORY:
+				pItem->SetWindow(DRAGON_SOUL_INVENTORY);
+				break;
+#endif
+
+			case BELT_INVENTORY:
+				pItem->SetWindow(BELT_INVENTORY);
+				break;
+
+#if defined(__ATTR_6TH_7TH__)
+			case NPC_STORAGE:
+				pItem->SetWindow(NPC_STORAGE);
+				break;
+#endif
+
+			default:
+				sys_err("Trying to set window %d, non determined behaviour!", bWindowType);
+		}
+	}
+}
+
+LPITEM CHARACTER::GetWear(WORD wCell) const
+{
+	if (wCell >= EQUIPMENT_MAX_NUM)
+	{
+		sys_err("CHARACTER::GetWear: invalid wear cell %d", wCell);
+		return nullptr;
+	}
+
+	return m_pointsInstant.pEquipmentItems[wCell];
+}
+
+void CHARACTER::SetWear(WORD wCell, LPITEM item)
+{
+	if (wCell >= EQUIPMENT_MAX_NUM)
+	{
+		sys_err("CHARACTER::SetItem: invalid item cell %d", wCell);
+		return;
+	}
+
+	SetItem(TItemPos(EQUIPMENT, wCell), item);
+
+	if (!item && wCell == WEAR_WEAPON)
+	{
+		// 叩    繭 효 羚 磯.
+		if (IsAffectFlag(AFF_GWIGUM))
+			RemoveAffect(SKILL_GWIGEOM);
+
+		if (IsAffectFlag(AFF_GEOMGYEONG))
+			RemoveAffect(SKILL_GEOMKYUNG);
+	}
+}
+
+void CHARACTER::ClearItem()
+{
+	int i;
+	LPITEM item;
+
+	for (i = 0; i < INVENTORY_MAX_NUM; ++i)
+	{
+		if ((item = GetInventoryItem(i)))
+		{
+			item->SetSkipSave(true);
+			ITEM_MANAGER::Instance().FlushDelayedSave(item);
+
+			item->RemoveFromCharacter();
+			M2_DESTROY_ITEM(item);
+
+			SyncQuickslot(SLOT_TYPE_INVENTORY, i, WORD_MAX);
+		}
+	}
+
+	for (i = 0; i < EQUIPMENT_MAX_NUM; ++i)
+	{
+		if ((item = GetEquipmentItem(i)))
+		{
+			item->SetSkipSave(true);
+			ITEM_MANAGER::Instance().FlushDelayedSave(item);
+
+			item->RemoveFromCharacter();
+			M2_DESTROY_ITEM(item);
+		}
+	}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	for (i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
+	{
+		if ((item = GetDragonSoulInventoryItem(i)))
+		{
+			item->SetSkipSave(true);
+			ITEM_MANAGER::Instance().FlushDelayedSave(item);
+
+			item->RemoveFromCharacter();
+			M2_DESTROY_ITEM(item);
+		}
+	}
+#endif
+
+	for (i = 0; i < BELT_INVENTORY_SLOT_COUNT; ++i)
+	{
+		if ((item = GetBeltInventoryItem(i)))
+		{
+			item->SetSkipSave(true);
+			ITEM_MANAGER::Instance().FlushDelayedSave(item);
+
+			item->RemoveFromCharacter();
+			M2_DESTROY_ITEM(item);
+
+			SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, i, WORD_MAX);
+		}
+	}
+
+#if defined(__ATTR_6TH_7TH__)
+	if ((item = GetNPCStorageItem()))
+	{
+		item->SetSkipSave(true);
+		ITEM_MANAGER::Instance().FlushDelayedSave(item);
+
+		item->RemoveFromCharacter();
+		M2_DESTROY_ITEM(item);
+	}
+#endif
+}
+
+bool CHARACTER::IsEmptyItemGrid(TItemPos Cell, BYTE bSize, int iExceptionCell) const
+{
+	switch (Cell.window_type)
+	{
+		case INVENTORY:
+		{
+			const WORD wCell = Cell.cell;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+			if (wCell >= GetExtendInvenMax())
+#else
+			if (wCell >= INVENTORY_MAX_NUM)
+#endif
+				return false;
+
+			// bItemCell 0 false 타  + 1 漫 처磯.
+			//  iExceptionCell 1  磯.
+			++iExceptionCell;
+
+			if (m_pointsInstant.wInventoryItemGrid[wCell])
+			{
+				if (m_pointsInstant.wInventoryItemGrid[wCell] == iExceptionCell)
+				{
+					if (bSize == 1)
+						return true;
+
+					int iOffset = 1;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+					const WORD wPage = wCell / INVENTORY_PAGE_SIZE;
+#else
+					const WORD wPage = wCell / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT);
+#endif
+					do
+					{
+						const WORD wSlot = wCell + (INVENTORY_WIDTH * iOffset);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+						if (wSlot >= GetExtendInvenMax())
+							return false;
+
+						if (wSlot / INVENTORY_PAGE_SIZE != wPage)
+							return false;
+#else
+						if (wSlot >= INVENTORY_MAX_NUM)
+							return false;
+
+						if (wSlot / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT) != wPage)
+							return false;
+#endif
+
+						if (m_pointsInstant.wInventoryItemGrid[wSlot])
+						{
+							if (m_pointsInstant.wInventoryItemGrid[wSlot] != iExceptionCell)
+								return false;
+						}
+					} while (++iOffset < bSize);
+
+					return true;
+				}
+				else
+					return false;
+			}
+
+			// 크璲 1見 칸 求 譴퓐 柳 
+			if (1 == bSize)
+				return true;
+			else
+			{
+				int iOffset = 1;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+				const WORD wPage = wCell / INVENTORY_PAGE_SIZE;
+#else
+				const WORD wPage = wCell / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT);
+#endif
+
+				do
+				{
+					const WORD wSlot = wCell + (INVENTORY_WIDTH * iOffset);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+					if (wSlot >= GetExtendInvenMax())
+						return false;
+
+					if (wSlot / INVENTORY_PAGE_SIZE != wPage)
+						return false;
+#else
+					if (wSlot >= INVENTORY_MAX_NUM)
+						return false;
+
+					if (wSlot / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT) != wPage)
+						return false;
+#endif
+
+					if (m_pointsInstant.wInventoryItemGrid[wSlot])
+					{
+						if (m_pointsInstant.wInventoryItemGrid[wSlot] != iExceptionCell)
+							return false;
+					}
+				} while (++iOffset < bSize);
+
+				return true;
+			}
+		}
+		break;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case DRAGON_SOUL_INVENTORY:
+		{
+			const WORD wCell = Cell.cell;
+			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+				return false;
+
+			++iExceptionCell;
+
+			if (m_pointsInstant.wDragonSoulInventoryItemGrid[wCell])
+			{
+				if (m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] == iExceptionCell)
+				{
+					if (bSize == 1)
+						return true;
+
+					int iOffset = 1;
+
+					do
+					{
+						const WORD wSlot = wCell + (DRAGON_SOUL_BOX_COLUMN_NUM * iOffset);
+						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+							return false;
+
+						if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot])
+						{
+							if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] != iExceptionCell)
+								return false;
+						}
+					} while (++iOffset < bSize);
+
+					return true;
+				}
+				else
+					return false;
+			}
+
+			if (1 == bSize)
+				return true;
+			else
+			{
+				int iOffset = 1;
+
+				do
+				{
+					const WORD wSlot = wCell + (DRAGON_SOUL_BOX_COLUMN_NUM * iOffset);
+					if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+						return false;
+
+					if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot])
+					{
+						if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] != iExceptionCell)
+							return false;
+					}
+				} while (++iOffset < bSize);
+
+				return true;
+			}
+		}
+		break;
+#endif
+
+		case BELT_INVENTORY:
+		{
+			const WORD wCell = Cell.cell;
+			if (wCell >= BELT_INVENTORY_MAX_NUM)
+				return false;
+
+			++iExceptionCell;
+
+			const LPITEM pBeltItem = GetWear(WEAR_BELT);
+			if (pBeltItem == nullptr)
+				return false;
+
+			if (!CBeltInventoryHelper::IsAvailableCell(wCell - BELT_INVENTORY_SLOT_START, pBeltItem->GetValue(0)))
+				return false;
+
+			if (m_pointsInstant.bBeltInventoryItemGrid[wCell])
+			{
+				if (m_pointsInstant.bBeltInventoryItemGrid[wCell] == iExceptionCell)
+				{
+					if (bSize == 1)
+						return true;
+
+					int iOffset = 1;
+
+					do
+					{
+						const WORD wSlot = wCell + (BELT_INVENTORY_SLOT_WIDTH * iOffset);
+						if (wSlot >= BELT_INVENTORY_MAX_NUM)
+							return false;
+
+						if (m_pointsInstant.bBeltInventoryItemGrid[wSlot])
+						{
+							if (m_pointsInstant.bBeltInventoryItemGrid[wSlot] != iExceptionCell)
+								return false;
+						}
+					} while (++iOffset < bSize);
+
+					return true;
+				}
+				else
+					return false;
+			}
+
+			if (1 == bSize)
+				return true;
+			else
+			{
+				int iOffset = 1;
+
+				do
+				{
+					const WORD wSlot = wCell + (BELT_INVENTORY_SLOT_WIDTH * iOffset);
+					if (wSlot >= BELT_INVENTORY_MAX_NUM)
+						return false;
+
+					if (m_pointsInstant.bBeltInventoryItemGrid[wSlot])
+					{
+						if (m_pointsInstant.bBeltInventoryItemGrid[wSlot] != iExceptionCell)
+							return false;
+					}
+				} while (++iOffset < bSize);
+
+				return true;
+			}
+		}
+		break;
+	}
+
+	return false;
+}
+
+int CHARACTER::GetEmptyInventory(BYTE size) const
+{
+	// NOTE :   獨  , 획     觀訝  칸 찾  품 獵쨉,
+	// 트 觀訝 특 觀訝譴퓐 講 茄 磯. (羞 觀訝: INVENTORY_MAX_NUM  講)
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (int i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+		if (IsEmptyItemGrid(TItemPos(INVENTORY, i), size))
+			return i;
+	return -1;
+}
+
+int CHARACTER::GetEmptyInventoryCount(BYTE size) const
+{
+	// NOTE :   獨  , 획     觀訝  칸 찾  품 獵쨉,
+	// 트 觀訝 특 觀訝譴퓐 講 茄 磯. (羞 觀訝: INVENTORY_MAX_NUM  講)
+	int emptyCount = 0;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (int i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+	{
+		if (IsEmptyItemGrid(TItemPos(INVENTORY, i), size))
+			++emptyCount;
+	}
+
+	return emptyCount;
+}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+int CHARACTER::GetEmptyDragonSoulInventory(LPITEM pItem) const
+{
+	if (NULL == pItem || !pItem->IsDragonSoul())
+		return -1;
+
+	if (!DragonSoul_IsQualified())
+		return -1;
+
+	BYTE bSize = pItem->GetSize();
+	WORD wBaseCell = DSManager::instance().GetBasePosition(pItem);
+
+	if (WORD_MAX == wBaseCell)
+		return -1;
+
+	for (int i = 0; i < DRAGON_SOUL_BOX_SIZE; ++i)
+		if (IsEmptyItemGrid(TItemPos(DRAGON_SOUL_INVENTORY, i + wBaseCell), bSize))
+			return i + wBaseCell;
+
+	return -1;
+}
+
+void CHARACTER::CopyDragonSoulItemGrid(std::vector<WORD>& vDragonSoulItemGrid) const
+{
+	vDragonSoulItemGrid.resize(DRAGON_SOUL_INVENTORY_MAX_NUM);
+	std::copy(m_pointsInstant.wDragonSoulInventoryItemGrid, m_pointsInstant.wDragonSoulInventoryItemGrid + DRAGON_SOUL_INVENTORY_MAX_NUM, vDragonSoulItemGrid.begin());
+}
+#endif
+
+int CHARACTER::CountEmptyInventory() const
+{
+	int count = 0;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (int i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+		if (GetInventoryItem(i))
+			count += GetInventoryItem(i)->GetSize();
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	return (GetExtendInvenMax() - count);
+#else
+	return (INVENTORY_MAX_NUM - count);
+#endif
+}
+
+bool CHARACTER::HasEnoughInventorySpace(std::vector<TItemData>& vItems) const
+{
+	if (vItems.empty())
+		return true;
+
+	static std::array<CGrid, 4> aGrids = {
+		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
+		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
+		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
+		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT)
+	};
+	for (auto& kGrid : aGrids)
+		kGrid.Clear();
+
+	LPITEM pItem = nullptr;
+	for (int i = 0; i < INVENTORY_PAGE_SIZE * 4; ++i)
+	{
+		if ((pItem = GetInventoryItem(i)))
+		{
+			aGrids[i / INVENTORY_PAGE_SIZE].Put(i % INVENTORY_PAGE_SIZE, 1, pItem->GetSize());
+		}
+	}
+
+	for (const TItemData& kItem : vItems)
+	{
+		const TItemTable* pItemTable = ITEM_MANAGER::Instance().GetTable(kItem.dwVnum);
+		if (!pItemTable)
+			return true;
+
+		int iPos = -1;
+		for (int j = 0; j < aGrids.size(); ++j)
+		{
+			iPos = aGrids[j].FindBlank(1, pItemTable->bSize);
+			if (iPos >= 0)
+			{
+#if defined(__EXTEND_INVEN_SYSTEM__)
+				if (j >= 2)
+				{
+					int iExtendMaxPos = (INVENTORY_WIDTH * (GetExtendInvenStage() - (j - 1))) - 1;
+					if (iPos > iExtendMaxPos)
+						return false;
+
+					if (pItemTable->bSize > 1)
+					{
+						iExtendMaxPos -= (INVENTORY_WIDTH * (pItemTable->bSize - 1));
+						if (iPos > iExtendMaxPos)
+							return false;
+					}
+				}
+#endif
+				aGrids[j].Put(iPos, 1, pItemTable->bSize);
+				break;
+			}
+		}
+
+		if (iPos == -1)
+			return false;
+	}
+
+	return true;
+}
+
+void TransformRefineItem(LPITEM pkOldItem, LPITEM pkNewItem)
+{
+	// ACCESSORY_REFINE
+	if (pkOldItem->IsAccessoryForSocket())
+	{
+		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+		{
+			pkNewItem->SetSocket(i, pkOldItem->GetSocket(i));
+		}
+		//pkNewItem->StartAccessorySocketExpireEvent();
+	}
+	// END_OF_ACCESSORY_REFINE
+	else
+	{
+		// 茱  湄 청 
+		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+		{
+			if (!pkOldItem->GetSocket(i))
+				break;
+			else
+				pkNewItem->SetSocket(i, 1);
+		}
+
+		//  
+		int slot = 0;
+
+		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+		{
+			long socket = pkOldItem->GetSocket(i);
+
+			if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
+				pkNewItem->SetSocket(slot++, socket);
+		}
+
+	}
+
+#if defined(__ITEM_SOCKET6__)
+	for (int i = METIN_SOCKET_MAX_NUM; i < ITEM_SOCKET_MAX_NUM; ++i)
+		pkNewItem->SetSocket(i, pkOldItem->GetSocket(i));
+#endif
+
+	//   
+	pkOldItem->CopyAttributeTo(pkNewItem);
+}
+
+void NotifyRefineSuccess(LPCHARACTER ch, LPITEM item, const char* way)
+{
+	if (NULL != ch && item != NULL)
+	{
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineSuceeded");
+
+		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), 1, way);
+	}
+}
+
+void NotifyRefineFail(LPCHARACTER ch, LPITEM item, const char* way, int success = 0)
+{
+	if (NULL != ch && NULL != item)
+	{
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineFailed");
+
+		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), success, way);
+	}
+}
+
+#if defined(__REFINE_MSG_ADD__)
+void NotifyRefineFailType(const LPCHARACTER ch, const LPITEM item, const BYTE type, const char* way, const BYTE success = 0)
+{
+	if (ch && item)
+	{
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineFailedType %d", type);
+		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), success, way);
+	}
+}
+#endif
+
+void CHARACTER::SetRefineNPC(LPCHARACTER ch)
+{
+	if (ch != NULL)
+	{
+		m_dwRefineNPCVID = ch->GetVID();
+	}
+	else
+	{
+		m_dwRefineNPCVID = 0;
+	}
+}
+
+bool CHARACTER::DoRefine(LPITEM item, bool bMoneyOnly)
+{
+	if (!CanHandleItem(true))
+	{
+		ClearRefineMode();
+		return false;
+	}
+
+	// HARDENING: block spoofed refine packets on fishing rods (rods use dedicated upgrade logic)
+	if (item && item->GetType() == ITEM_ROD)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("\xc0\xcc \xbe\xc6\xc0\xcc\xc5\xdb\xc0\xba \xb0\xb3\xb7\xae\xc7\xd2 \xbc\xf6 \xbe\xf8\xbd\xc0\xb4\xcf\xb4\xd9."));
+		ClearRefineMode();
+		return false;
+	}
+
+	// 챨 : upgrade_refine_scroll.quest   5犬 球 
+	//寗 
+	if (quest::CQuestManager::instance().GetEventFlag("update_refine_time") != 0)
+	{
+		if (get_global_time() < quest::CQuestManager::instance().GetEventFlag("update_refine_time") + (60 * 5))
+		{
+			sys_log(0, "can't refine %d %s", GetPlayerID(), GetName());
+			return false;
+		}
+	}
+
+	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
+	if (!prt)
+		return false;
+
+	DWORD result_vnum = item->GetRefinedVnum();
+
+	// REFINE_COST
+	int cost = ComputeRefineFee(prt->cost);
+
+	int RefineChance = GetQuestFlag("main_quest_lv7.refine_chance");
+
+	if (RefineChance > 0)
+	{
+		if (!item->CheckItemUseLevel(20) || item->GetType() != ITEM_WEAPON)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  회 20  綬 爛求"));
+			return false;
+		}
+		cost = 0;
+		SetQuestFlag("main_quest_lv7.refine_chance", RefineChance - 1);
+	}
+	// END_OF_REFINE_COST
+
+	if (result_vnum == 0)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鵑   求."));
+		return false;
+	}
+
+	if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TUNING)
+		return false;
+
+	TItemTable* pProto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
+
+	if (!pProto)
+	{
+		sys_err("DoRefine NOT GET ITEM PROTO %d", item->GetRefinedVnum());
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+		return false;
+	}
+
+	// Check level limit in korea only
+	if (!g_iUseLocale)
+	{
+		for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+		{
+			long limit = pProto->aLimits[i].lValue;
+
+			switch (pProto->aLimits[i].bType)
+			{
+				case LIMIT_LEVEL:
+				{
+					if (GetLevel() < limit)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("    紀  求."));
+						return false;
+					}
+				}
+				break;
+
+#if defined(__CONQUEROR_LEVEL__)
+				case LIMIT_NEWWORLD_LEVEL:
+				{
+					if (GetConquerorLevel() < limit)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("    紀  求."));
+						return false;
+					}
+				}
+				break;
+#endif
+			}
+		}
+	}
+
+	// REFINE_COST
+	if (GetGold() < (long long)cost)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 歐   爛求."));
+		return false;
+	}
+
+#if defined(__REFINE_STACK_FIX__)
+	int iEmptyPos = GetEmptyInventory(item->GetSize());
+	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+	{
+		if (-1 == iEmptyPos)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("품   求."));
+			return false;
+		}
+	}
+#endif
+
+	if (!bMoneyOnly && !RefineChance)
+	{
+		for (int i = 0; i < prt->material_count; ++i)
+		{
+			if (CountSpecifyItem(prt->materials[i].vnum, item->GetCell()) < prt->materials[i].count)
+			{
+				if (test_server)
+				{
+					ChatPacket(CHAT_TYPE_INFO, "Find %d, count %d, require %d", prt->materials[i].vnum, CountSpecifyItem(prt->materials[i].vnum), prt->materials[i].count);
+				}
+
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 歐  嘯 爛求."));
+				return false;
+			}
+		}
+
+		for (int i = 0; i < prt->material_count; ++i)
+			RemoveSpecifyItem(prt->materials[i].vnum, prt->materials[i].count, item->GetCell());
+	}
+
+	int prob = number(1, 100);
+
+	if (IsRefineThroughGuild() || bMoneyOnly)
+		prob -= 10;
+
+	// END_OF_REFINE_COST
+
+	if (prob <= prt->prob)
+	{
+		// !   ,  憺 摸  획
+		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
+
+		if (pkNewItem)
+		{
+			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
+			if (aApplyRandom)
+				pkNewItem->SetRandomApplies(aApplyRandom);
+#endif
+
+			LogManager::instance().ItemLog(this, pkNewItem, "REFINE SUCCESS", pkNewItem->GetName());
+
+			UINT bCell = item->GetCell();
+
+			// DETAIL_REFINE_LOG
+			NotifyRefineSuccess(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
+			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -cost);
+			// END_OF_DETAIL_REFINE_LOG
+
+#if defined(__REFINE_STACK_FIX__)
+			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+			{
+				item->SetCount(item->GetCount() - 1);
+				AutoGiveItem(pkNewItem, true, true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+					, true
+#endif
+				);
+			}
+			else
+			{
+				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
+				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+			}
+#else
+			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
+			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+#endif
+
+			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
+			pkNewItem->AttrLog();
+
+			sys_log(0, "Refine Success %d", cost);
+			//PointChange(POINT_GOLD, -cost);
+			sys_log(0, "PayPee %d", cost);
+			PayRefineFee(cost);
+			sys_log(0, "PayPee End %d", cost);
+		}
+		else
+		{
+			// DETAIL_REFINE_LOG
+			//    ->  鈞 
+			sys_err("cannot create item %u", result_vnum);
+#if defined(__REFINE_MSG_ADD__)
+			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, IsRefineThroughGuild() ? "GUILD" : "POWER");
+#else
+			NotifyRefineFail(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
+#endif
+			// END_OF_DETAIL_REFINE_LOG
+		}
+	}
+	else
+	{
+		// !   .
+		DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -cost);
+#if defined(__REFINE_MSG_ADD__)
+		NotifyRefineFailType(this, item, REFINE_FAIL_DEL_ITEM, IsRefineThroughGuild() ? "GUILD" : "POWER");
+#else
+		NotifyRefineFail(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
+#endif
+		item->AttrLog();
+
+#if defined(__REFINE_STACK_FIX__)
+		if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+		{
+			item->SetCount(item->GetCount() - 1);
+		}
+		else
+		{
+			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
+		}
+#else
+		ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
+#endif
+
+		//PointChange(POINT_GOLD, -cost);
+		PayRefineFee(cost);
+	}
+
+	return true;
+}
+
+enum ERefineScroll
+{
+	CHUKBOK_SCROLL = 0,
+	HYUNIRON_STONE = 1,
+	YONGSIN_SCROLL = 2,
+	MUSIN_SCROLL = 3,
+	YAGONG_SCROLL = 4,
+	MEMO_SCROLL = 5,
+	BDRAGON_SCROLL = 6,
+#if defined(__STONE_OF_BLESS__)
+	BLESSING_STONE = 7,
+#endif
+#if defined(__SOUL_SYSTEM__)
+	SOUL_AWAKE_SCROLL = 8,
+	SOUL_EVOLVE_SCROLL = 9,
+#endif
+#if defined(__STONE_OF_BLESS__)
+	MALL_BLESSING_STONE = 10,
+#endif
+};
+
+#if defined(__SOUL_SYSTEM__)
+bool CHARACTER::DoRefineSoul(LPITEM item)
+{
+	if (!CanHandleItem(true))
+	{
+		ClearRefineMode();
+		return false;
+	}
+
+	ClearRefineMode();
+
+	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
+	if (!prt)
+		return false;
+
+	if (m_iRefineAdditionalCell < 0)
+		return false;
+
+	LPITEM item_scroll = GetInventoryItem(m_iRefineAdditionalCell);
+	if (item_scroll == nullptr)
+		return false;
+
+	if (!(item_scroll->GetType() == ITEM_USE && item_scroll->GetSubType() == USE_TUNING))
+		return false;
+
+	if (item_scroll->GetVnum() == item->GetVnum())
+		return false;
+
+	DWORD result_vnum = item->GetRefinedVnum();
+	if (result_vnum == 0)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鵑   求."));
+		return false;
+	}
+
+	TItemTable* proto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
+	if (!proto)
+	{
+		sys_err("DoRefineSoul NOT GET ITEM PROTO %d", item->GetRefinedVnum());
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+		return false;
+	}
+
+	int prob = number(1, 100);
+	int success_prob = prt->prob;
+
+	switch (item_scroll->GetValue(0))
+	{
+		case SOUL_AWAKE_SCROLL:
+			success_prob = 100;
+			break;
+
+		case SOUL_EVOLVE_SCROLL:
+			success_prob = soul_refine_prob[MINMAX(0, item->GetValue(1), SOUL_GRADE_MAX)];
+			break;
+	}
+
+	item_scroll->SetCount(item_scroll->GetCount() - 1);
+
+	if (prob <= success_prob)
+	{
+		LPITEM new_item = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
+		if (new_item)
+		{
+			WORD wCell = item->GetCell();
+
+			LogManager::instance().ItemLog(this, new_item, "SOUL REFINE FAIL", new_item->GetName());
+			ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulSuceeded");
+
+			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (SOUL REFINE FAIL)");
+
+			new_item->AddToCharacter(this, TItemPos(INVENTORY, wCell));
+			ITEM_MANAGER::instance().FlushDelayedSave(new_item);
+		}
+		else
+		{
+			sys_err("cannot create item %u", result_vnum);
+			ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulFailed");
+		}
+	}
+	else
+	{
+		ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulFailed");
+	}
+
+	return true;
+}
+#endif
+
+bool CHARACTER::DoRefineWithScroll(LPITEM item)
+{
+	if (!CanHandleItem(true))
+	{
+		ClearRefineMode();
+		return false;
+	}
+
+	ClearRefineMode();
+
+	//  챨 : upgrade_refine_scroll.quest   5犬 球 
+	// 寗 
+	if (quest::CQuestManager::instance().GetEventFlag("update_refine_time") != 0)
+	{
+		if (get_global_time() < quest::CQuestManager::instance().GetEventFlag("update_refine_time") + (60 * 5))
+		{
+			sys_log(0, "can't refine %d %s", GetPlayerID(), GetName());
+			return false;
+		}
+	}
+
+	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
+	if (!prt)
+		return false;
+
+	LPITEM pkItemScroll;
+
+	//  체크
+	if (m_iRefineAdditionalCell < 0)
+		return false;
+
+	pkItemScroll = GetInventoryItem(m_iRefineAdditionalCell);
+
+	if (!pkItemScroll)
+		return false;
+
+	if (!(pkItemScroll->GetType() == ITEM_USE && pkItemScroll->GetSubType() == USE_TUNING))
+		return false;
+
+	if (pkItemScroll->GetVnum() == item->GetVnum())
+		return false;
+
+	DWORD result_vnum = item->GetRefinedVnum();
+	DWORD result_fail_vnum = item->GetRefineFromVnum();
+
+	if (result_vnum == 0)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鵑   求."));
+		return false;
+	}
+
+	TItemTable* pProto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
+	if (!pProto)
+	{
+		sys_err("DoRefineWithScroll NOT GET ITEM PROTO %d", item->GetRefinedVnum());
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+		return false;
+	}
+
+	if (GetGold() < prt->cost)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 歐   爛求."));
+		return false;
+	}
+
+#if defined(__REFINE_STACK_FIX__)
+	int iEmptyPos = GetEmptyInventory(item->GetSize());
+	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+	{
+		if (-1 == iEmptyPos)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("품   求."));
+			return false;
+		}
+	}
+#endif
+
+	for (int i = 0; i < prt->material_count; ++i)
+	{
+		if (CountSpecifyItem(prt->materials[i].vnum, item->GetCell()) < prt->materials[i].count)
+		{
+			if (test_server)
+			{
+				ChatPacket(CHAT_TYPE_INFO, "Find %d, count %d, require %d", prt->materials[i].vnum, CountSpecifyItem(prt->materials[i].vnum), prt->materials[i].count);
+			}
+
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 歐  嘯 爛求."));
+			return false;
+		}
+	}
+
+	for (int i = 0; i < prt->material_count; ++i)
+		RemoveSpecifyItem(prt->materials[i].vnum, prt->materials[i].count, item->GetCell());
+
+	int prob = number(1, 100);
+	const SRefineScrollData& kScroll = GetScrollRefinePct(prt->prob, item->GetRefinedVnum(), pkItemScroll->GetValue(0));
+	const char* szRefineType = "SCROLL";
+
+	switch (pkItemScroll->GetValue(0))
+	{
+		case HYUNIRON_STONE:
+			szRefineType = "HYUNIRON_STONE";
+			break;
+
+		case YONGSIN_SCROLL:
+			szRefineType = "GOD_SCROLL";
+			break;
+
+		case MUSIN_SCROLL:
+			szRefineType = "MUSIN_SCROLL";
+			break;
+
+		case YAGONG_SCROLL:
+			szRefineType = "YAGONG_SCROLL";
+			break;
+
+		case MEMO_SCROLL:
+			szRefineType = "MEMO_SCROLL";
+			break;
+
+		case BDRAGON_SCROLL:
+			szRefineType = "BDRAGON_SCROLL";
+			break;
+
+#if defined(__STONE_OF_BLESS__)
+		case BLESSING_STONE:
+			szRefineType = "BLESSING_STONE";
+			break;
+
+		case MALL_BLESSING_STONE:
+			szRefineType = "MALL_BLESSING_STONE";
+			break;
+#endif
+
+		default:
+			sys_err("REFINE : Unknown refine scroll item. Value0: %d", pkItemScroll->GetValue(0));
+			break;
+	}
+
+	if (test_server)
+		ChatPacket(CHAT_TYPE_INFO, "[Only Test] SuccessProb %d, RefineLevel %d ", kScroll.bSuccessProb, item->GetRefineLevel());
+
+	pkItemScroll->SetCount(pkItemScroll->GetCount() - 1);
+
+	if (prob <= kScroll.bSuccessProb)
+	{
+		// !   ,  憺 摸  획
+		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
+
+		if (pkNewItem)
+		{
+			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
+			if (aApplyRandom)
+				pkNewItem->SetRandomApplies(aApplyRandom);
+#endif
+
+			LogManager::instance().ItemLog(this, pkNewItem, "REFINE SUCCESS", pkNewItem->GetName());
+
+			UINT bCell = item->GetCell();
+
+			NotifyRefineSuccess(this, item, szRefineType);
+			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -prt->cost);
+
+#if defined(__REFINE_STACK_FIX__)
+			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+			{
+				item->SetCount(item->GetCount() - 1);
+				AutoGiveItem(pkNewItem, true, true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+					, true
+#endif
+				);
+			}
+			else
+			{
+				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
+				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+			}
+#else
+			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
+			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+#endif
+
+			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
+			pkNewItem->AttrLog();
+
+			//PointChange(POINT_GOLD, -prt->cost);
+			PayRefineFee(prt->cost);
+		}
+		else
+		{
+			//    ->  鈞 
+			sys_err("cannot create item %u", result_vnum);
+#if defined(__REFINE_MSG_ADD__)
+			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
+#else
+			NotifyRefineFail(this, item, szRefineType);
+#endif
+		}
+	}
+	else if (!kScroll.bKeepGrade && result_fail_vnum)
+	{
+		// !   ,  憺    획
+		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_fail_vnum, 1, 0, false);
+
+		if (pkNewItem)
+		{
+			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_PREVIOUS);
+			if (aApplyRandom)
+				pkNewItem->SetRandomApplies(aApplyRandom);
+#endif
+
+			LogManager::instance().ItemLog(this, pkNewItem, "REFINE FAIL", pkNewItem->GetName());
+
+			UINT bCell = item->GetCell();
+
+			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -prt->cost);
+#if defined(__REFINE_MSG_ADD__)
+			NotifyRefineFailType(this, item, REFINE_FAIL_GRADE_DOWN, szRefineType, -1);
+#else
+			NotifyRefineFail(this, item, szRefineType, -1);
+
+#endif
+
+#if defined(__REFINE_STACK_FIX__)
+			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+			{
+				item->SetCount(item->GetCount() - 1);
+				AutoGiveItem(pkNewItem, true, true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+					, true
+#endif
+				);
+			}
+			else
+			{
+				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
+				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+			}
+#else
+			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
+			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+#endif
+
+			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
+			pkNewItem->AttrLog();
+
+			//PointChange(POINT_GOLD, -prt->cost);
+			PayRefineFee(prt->cost);
+		}
+		else
+		{
+			//    ->  鈞 
+			sys_err("cannot create item %u", result_fail_vnum);
+#if defined(__REFINE_MSG_ADD__)
+			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
+#else
+			NotifyRefineFail(this, item, szRefineType);
+#endif
+		}
+	}
+	else
+	{
+#if defined(__REFINE_MSG_ADD__)
+		NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
+#else
+		NotifyRefineFail(this, item, szRefineType); //    
+#endif
+		PayRefineFee(prt->cost);
+	}
+
+	return true;
+}
+
+CHARACTER::SRefineScrollData CHARACTER::GetScrollRefinePct(BYTE bProb, BYTE bRefineLevel, BYTE bScrollType)
+{
+	SRefineScrollData Scroll{};
+	Scroll.bSuccessProb = bProb;
+	Scroll.bKeepGrade = false;
+
+	// 철,  僊, 煞  처
+	switch (bScrollType)
+	{
+		case CHUKBOK_SCROLL:
+			break;
+
+		case HYUNIRON_STONE:
+			Scroll.bSuccessProb = MINMAX(1, bProb + 10, 100);
+			Scroll.bKeepGrade = true;
+			break;
+
+		case YONGSIN_SCROLL:
+			Scroll.bSuccessProb = MINMAX(1, bProb + 10, 100);
+			break;
+
+		case MUSIN_SCROLL: //  僊 100%  (+4)
+			Scroll.bSuccessProb = 100;
+			break;
+
+		case YAGONG_SCROLL:
+			Scroll.bSuccessProb = MINMAX(1, bProb + 15, 100);
+			break;
+
+		case MEMO_SCROLL:
+			Scroll.bSuccessProb = 100;
+			break;
+
+		case BDRAGON_SCROLL:
+			Scroll.bSuccessProb = 80;
+			break;
+
+#if defined(__STONE_OF_BLESS__)
+		case BLESSING_STONE:
+			Scroll.bSuccessProb = MINMAX(1, bProb + 15, 100);
+			Scroll.bKeepGrade = true;
+			break;
+
+		case MALL_BLESSING_STONE:
+			Scroll.bSuccessProb = MINMAX(1, bProb + 20, 100);
+			Scroll.bKeepGrade = true;
+			break;
+#endif
+	}
+
+	return Scroll;
+}
+
+bool CHARACTER::RefineInformation(WORD wCell, BYTE bType, int iAdditionalCell)
+{
+	if (wCell > INVENTORY_MAX_NUM)
+		return false;
+
+	const LPITEM item = GetInventoryItem(wCell);
+	if (!item)
+		return false;
+
+	// HARDENING: fishing rods do not use refine_proto (avoid spoofed REFINE packets)
+	if (item->GetType() == ITEM_ROD)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("\xc0\xcc \xbe\xc6\xc0\xcc\xc5\xdb\xc0\xba \xb0\xb3\xb7\xae\xc7\xd2 \xbc\xf6 \xbe\xf8\xbd\xc0\xb4\xcf\xb4\xd9."));
+		ClearRefineMode();
+		return false;
+	}
+
+	// REFINE_COST
+	if (bType == REFINE_TYPE_MONEY_ONLY && !GetQuestFlag("deviltower_zone.can_refine"))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 타 狗  箕 諛≡니."));
+		return false;
+	}
+	// END_OF_REFINE_COST
+
+	TPacketGCRefineInformation p;
+	p.header = HEADER_GC_REFINE_INFORMATION;
+	p.pos = wCell;
+	p.src_vnum = item->GetVnum();
+	p.result_vnum = item->GetRefinedVnum();
+	p.type = bType;
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	thecore_memcpy(&p.RefineElement, item->GetRefineElement(), sizeof(p.RefineElement));
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+	item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
+	thecore_memcpy(&p.aApplyRandom, aApplyRandom, sizeof(p.aApplyRandom));
+#endif
+
+	if (p.result_vnum == 0)
+	{
+		sys_err("RefineInformation p.result_vnum == 0");
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+		return false;
+	}
+
+	if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TUNING)
+	{
+		if (bType == 0)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("   灌   求."));
+			return false;
+		}
+		else
+		{
+			const LPITEM& item_scroll = GetInventoryItem(iAdditionalCell);
+			if (!item_scroll || item->GetVnum() == item_scroll->GetVnum())
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  칠  求."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("僊  철 칠  笭求."));
+				return false;
+			}
+		}
+	}
+
+#if defined(__SOUL_SYSTEM__)
+	if (item->GetType() == ITEM_SOUL)
+	{
+		if (bType == REFINE_TYPE_SOUL_AWAKE || bType == REFINE_TYPE_SOUL_EVOLVE)
+		{
+			p.cost = 0;
+			p.prob = bType == REFINE_TYPE_SOUL_AWAKE ? 100 : soul_refine_prob[MINMAX(0, item->GetValue(1), SOUL_GRADE_MAX)];
+			p.material_count = 0;
+			std::memset(p.materials, 0, sizeof(p.materials));
+
+			GetDesc()->Packet(&p, sizeof(TPacketGCRefineInformation));
+
+			SetRefineMode(iAdditionalCell);
+			return true;
+		}
+	}
+#endif
+
+	CRefineManager& rm = CRefineManager::instance();
+	const TRefineTable* prt = rm.GetRefineRecipe(item->GetRefineSet());
+	if (!prt)
+	{
+		sys_err("RefineInformation NOT GET REFINE SET %d", item->GetRefineSet());
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+		return false;
+	}
+
+	// REFINE_COST
+
+	// MAIN_QUEST_LV7
+	if (GetQuestFlag("main_quest_lv7.refine_chance") > 0)
+	{
+		// 瞿 
+		if (!item->CheckItemUseLevel(20) || item->GetType() != ITEM_WEAPON)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  회 20  綬 爛求"));
+			return false;
+		}
+		p.cost = 0;
+	}
+	else
+		p.cost = ComputeRefineFee(prt->cost);
+	// END_MAIN_QUEST_LV7
+
+	const LPITEM& item_scroll = GetInventoryItem(iAdditionalCell);
+	if (item_scroll)
+	{
+		const SRefineScrollData& kScroll = GetScrollRefinePct(prt->prob, item->GetRefinedVnum(), item_scroll->GetValue(0));
+		p.prob = kScroll.bSuccessProb;
+	}
+	else
+	{
+		p.prob = prt->prob;
+
+		if (IsRefineThroughGuild())
+			p.prob += 10;
+	}
+
+	if (p.prob > 100)
+		p.prob = 100;
+
+	if (bType == REFINE_TYPE_MONEY_ONLY)
+	{
+		p.material_count = 0;
+		memset(p.materials, 0, sizeof(p.materials));
+	}
+	else
+	{
+		p.material_count = prt->material_count;
+		thecore_memcpy(&p.materials, prt->materials, sizeof(prt->materials));
+	}
+	// END_OF_REFINE_COST
+
+	GetDesc()->Packet(&p, sizeof(TPacketGCRefineInformation));
+
+	SetRefineMode(iAdditionalCell);
+	return true;
+}
+
+bool CHARACTER::RefineItem(LPITEM pkItem, LPITEM pkTarget)
+{
+	if (!CanHandleItem())
+		return false;
+
+	// HARDENING: prevent applying refine/scroll logic to fishing rods
+	if (pkTarget && pkTarget->GetType() == ITEM_ROD)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("\xc0\xcc \xbe\xc6\xc0\xcc\xc5\xdb\xc0\xba \xb0\xb3\xb7\xae\xc7\xd2 \xbc\xf6 \xbe\xf8\xbd\xc0\xb4\xcf\xb4\xd9."));
+		return false;
+	}
+
+	if (pkItem->GetSubType() == USE_TUNING)
+	{
+		// XXX ,   求...
+		// XXX  僊  퓸!
+
+		BYTE bRefineType = REFINE_TYPE_NORMAL;
+		switch (pkItem->GetValue(0))
+		{
+			case HYUNIRON_STONE:
+				bRefineType = REFINE_TYPE_HYUNIRON;
+				break;
+
+			case MUSIN_SCROLL:
+			{
+				if (pkTarget->GetRefineLevel() >= 4)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("   鵑   求."));
+					return false;
+				}
+
+				bRefineType = REFINE_TYPE_MUSIN;
+			}
+			break;
+
+			case MEMO_SCROLL:
+			{
+				if (pkTarget->GetRefineLevel() != pkItem->GetValue(1))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+					return false;
+				}
+
+				bRefineType = REFINE_TYPE_NOT_USED1;
+			}
+			break;
+
+			case BDRAGON_SCROLL:
+			{
+				if (pkTarget->GetType() != ITEM_METIN || pkTarget->GetRefineLevel() != 4)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+					return false;
+				}
+
+				if (pkTarget->GetRefineSet() != 702)
+					return false;
+			}
+			break;
+
+#if defined(__STONE_OF_BLESS__)
+			case BLESSING_STONE:
+			{
+				if (pkTarget->GetLevelLimit() <= 80)
+					return false;
+
+				bRefineType = REFINE_TYPE_BLESSING_STONE;
+			}
+			break;
+
+			case MALL_BLESSING_STONE:
+				bRefineType = REFINE_TYPE_BLESSING_STONE;
+				break;
+#endif
+
+#if defined(__SOUL_SYSTEM__)
+			case SOUL_AWAKE_SCROLL:
+			case SOUL_EVOLVE_SCROLL:
+			{
+				if (pkTarget->GetType() != ITEM_SOUL)
+					return false;
+
+				if (pkTarget->GetValue(0) >= SOUL_GRADE_ILUMINED)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Soul System] %s is already at the highest level.", LC_ITEM(pkTarget->GetVnum())));
+					return false;
+				}
+
+				if (pkItem->GetValue(0) == SOUL_AWAKE_SCROLL)
+					bRefineType = REFINE_TYPE_SOUL_AWAKE;
+				else if (pkItem->GetValue(0) == SOUL_EVOLVE_SCROLL)
+					bRefineType = REFINE_TYPE_SOUL_EVOLVE;
+			}
+			break;
+#endif
+
+			default:
+			{
+				if (pkTarget->GetRefineSet() == 501)
+					return false;
+
+				if (pkTarget->GetVnum() >= 28330 && pkTarget->GetVnum() <= 28343) // +3
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("+3      求"));
+					return false;
+				}
+
+				if (pkTarget->GetVnum() >= 28430 && pkTarget->GetVnum() <= 28443) // +4
+				{
+					if (pkItem->GetVnum() != 71056) // 청퓬
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("     求"));
+						return false;
+					}
+				}
+
+				bRefineType = REFINE_TYPE_SCROLL;
+			}
+			break;
+		}
+
+		RefineInformation(pkTarget->GetCell(), bRefineType, pkItem->GetCell());
+	}
+	else if (pkItem->GetSubType() == USE_DETACHMENT && IS_SET(pkTarget->GetFlag(), ITEM_FLAG_REFINEABLE) && pkTarget->IsRemovableSocket())
+	{
+		LogManager::instance().ItemLog(this, pkTarget, "USE_DETACHMENT", pkTarget->GetName());
+
+		bool bHasMetinStone = false;
+
+		for (int i = 0; i < METIN_SOCKET_MAX_NUM; i++)
+		{
+			long socket = pkTarget->GetSocket(i);
+			if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
+			{
+				bHasMetinStone = true;
+				break;
+			}
+		}
+
+		if (bHasMetinStone)
+		{
+			for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+			{
+				long socket = pkTarget->GetSocket(i);
+				if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
+				{
+#if defined(__GLOVE_SYSTEM__)
+					if (pkTarget->IsGlove() && socket >= 1000000)
+					{
+						DWORD dwBaseIndex = 28046;
+						dwBaseIndex += (((socket / 1000) % 10) * 100);
+						dwBaseIndex += ((socket / 100) % 10) - 1;
+
+						const TItemTable* pItemData = ITEM_MANAGER::instance().GetTable(dwBaseIndex);
+						if (pItemData == nullptr)
+							continue;
+
+						socket = dwBaseIndex;
+					}
+#endif
+					AutoGiveItem(socket);
+					//TItemTable* pTable = ITEM_MANAGER::instance().GetTable(pkTarget->GetSocket(i));
+					//pkTarget->SetSocket(i, pTable->alValues[2]);
+					//  체娩
+					pkTarget->SetSocket(i, ITEM_BROKEN_METIN_VNUM);
+				}
+			}
+			pkItem->SetCount(pkItem->GetCount() - 1);
+			return true;
+		}
+		else
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  獵 틴 求."));
+			return false;
+		}
+	}
+
+	return false;
+}
+
+EVENTFUNC(kill_campfire_event)
+{
+	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("kill_campfire_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPCHARACTER ch = info->ch;
+
+	if (ch == NULL) // <Factor>
+		return 0;
+
+	ch->m_pkMiningEvent = NULL;
+	M2_DESTROY_CHARACTER(ch);
+	return 0;
+}
+
+bool CHARACTER::GiveRecallItem(LPITEM item)
+{
+	int idx = GetMapIndex();
+	int iEmpireByMapIndex = -1;
+
+	if (idx < 20)
+		iEmpireByMapIndex = 1;
+	else if (idx < 40)
+		iEmpireByMapIndex = 2;
+	else if (idx < 60)
+		iEmpireByMapIndex = 3;
+	else if (idx < 10000)
+		iEmpireByMapIndex = 0;
+
+	switch (idx)
+	{
+		case 66:
+		case 216:
+		case 301:
+		case 302:
+		case 303:
+		case 304:
+			iEmpireByMapIndex = -1;
+			break;
+	}
+
+	if (iEmpireByMapIndex && GetEmpire() != iEmpireByMapIndex)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    치 都求."));
+		return false;
+	}
+
+	int pos;
+
+	if (item->GetCount() == 1) //  毬 柳 .
+	{
+		item->SetSocket(0, GetX());
+		item->SetSocket(1, GetY());
+	}
+	else if ((pos = GetEmptyInventory(item->GetSize())) != -1) // 瀏 苛摸 摸 觀訝  찾쨈.
+	{
+		LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), 1);
+		if (item2 != nullptr)
+		{
+			item2->SetSocket(0, GetX());
+			item2->SetSocket(1, GetY());
+			item2->AddToCharacter(this, TItemPos(INVENTORY, pos));
+
+			item->SetCount(item->GetCount() - 1);
+		}
+	}
+	else
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("품   求."));
+		return false;
+	}
+
+	return true;
+}
+
+void CHARACTER::ProcessRecallItem(LPITEM item)
+{
+	int idx;
+
+	if ((idx = SECTREE_MANAGER::instance().GetMapIndex(item->GetSocket(0), item->GetSocket(1))) == 0)
+		return;
+
+	int iEmpireByMapIndex = -1;
+
+	if (idx < 20)
+		iEmpireByMapIndex = 1;
+	else if (idx < 40)
+		iEmpireByMapIndex = 2;
+	else if (idx < 60)
+		iEmpireByMapIndex = 3;
+	else if (idx < 10000)
+		iEmpireByMapIndex = 0;
+
+	switch (idx)
+	{
+		case 66:
+		case 216:
+			iEmpireByMapIndex = -1;
+			break;
+			// 퓐黎 灸
+		case 301:
+		case 302:
+		case 303:
+		case 304:
+			if (GetLevel() < 90)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  紀  求."));
+				return;
+			}
+			else
+				break;
+	}
+
+	if (iEmpireByMapIndex && GetEmpire() != iEmpireByMapIndex)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 치 타  羚底 환  求."));
+		item->SetSocket(0, 0);
+		item->SetSocket(1, 0);
+	}
+	else
+	{
+		sys_log(1, "Recall: %s %d %d -> %d %d", GetName(), GetX(), GetY(), item->GetSocket(0), item->GetSocket(1));
+		WarpSet(item->GetSocket(0), item->GetSocket(1));
+		item->SetCount(item->GetCount() - 1);
+	}
+}
+
+void CHARACTER::__OpenPrivateShop()
+{
+	unsigned bodyPart = GetPart(PART_MAIN);
+	switch (bodyPart)
+	{
+	case 0:
+	case 1:
+	case 2:
+		ChatPacket(CHAT_TYPE_COMMAND, "OpenPrivateShop");
+		break;
+	default:
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("      笭求."));
+		break;
+	}
+}
+
+// MYSHOP_PRICE_LIST
+
+void CHARACTER::SendMyShopPriceListCmd(DWORD dwItemVnum, DWORD dwItemPrice
+#if defined(__CHEQUE_SYSTEM__)
+	, DWORD dwItemCheque
+#endif
+)
+{
+	char szLine[256];
+#if defined(__CHEQUE_SYSTEM__)
+	snprintf(szLine, sizeof(szLine), "MyShopPriceList %u %u %u", dwItemVnum, dwItemPrice, dwItemCheque);
+#else
+	snprintf(szLine, sizeof(szLine), "MyShopPriceList %u %u", dwItemVnum, dwItemPrice);
+#endif
+	ChatPacket(CHAT_TYPE_COMMAND, szLine);
+	sys_log(0, szLine);
+}
+
+//
+// DB 캐첨   트 User  構   커풩躍 .
+//
+void CHARACTER::UseSilkBotaryReal(const TPacketMyshopPricelistHeader* p)
+{
+	const TItemPriceInfo* pInfo = (const TItemPriceInfo*)(p + 1);
+
+#if defined(__CHEQUE_SYSTEM__)
+	if (!p->byCount)
+		SendMyShopPriceListCmd(1, 0, 0);
+	else
+	{
+		for (int idx = 0; idx < p->byCount; idx++)
+			SendMyShopPriceListCmd(pInfo[idx].dwVnum, pInfo[idx].dwPrice, pInfo[idx].dwCheque);
+	}
+#else
+	if (!p->byCount)
+		//  트 . dummy 拷  커풩躍 娩.
+		SendMyShopPriceListCmd(1, 0);
+	else {
+		for (int idx = 0; idx < p->byCount; idx++)
+			SendMyShopPriceListCmd(pInfo[idx].dwVnum, pInfo[idx].dwPrice);
+	}
+#endif
+
+	__OpenPrivateShop();
+}
+
+//
+// 譴   처  Open 求  트 Load 歐  DB 캐첼  트 청 킷 .
+// 캤姑 慕    .
+//
+void CHARACTER::UseSilkBotary(void)
+{
+	if (m_bNoOpenedShop)
+	{
+		DWORD dwPlayerID = GetPlayerID();
+		db_clientdesc->DBPacket(HEADER_GD_MYSHOP_PRICELIST_REQ, GetDesc()->GetHandle(), &dwPlayerID, sizeof(DWORD));
+		m_bNoOpenedShop = false;
+	}
+	else
+	{
+		__OpenPrivateShop();
+	}
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+int CalculateConsume(LPCHARACTER ch)
+{
+	static const int WARP_NEED_LIFE_PERCENT = 30;
+	static const int WARP_MIN_LIFE_PERCENT = 10;
+	// CONSUME_LIFE_WHEN_USE_WARP_ITEM
+	int consumeLife = 0;
+	{
+		// CheckNeedLifeForWarp
+		const int curLife = ch->GetHP();
+		const int needPercent = WARP_NEED_LIFE_PERCENT;
+		const int needLife = ch->GetMaxHP() * needPercent / 100;
+		if (curLife < needLife)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   眉   求."));
+			return -1;
+		}
+
+		consumeLife = needLife;
+
+		// CheckMinLifeForWarp:  漫  홴퓜퓐  玲念 娩
+		const int minPercent = WARP_MIN_LIFE_PERCENT;
+		const int minLife = ch->GetMaxHP() * minPercent / 100;
+		if (curLife - needLife < minLife)
+			consumeLife = curLife - minLife;
+
+		if (consumeLife < 0)
+			consumeLife = 0;
+	}
+	// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
+	return consumeLife;
+}
+
+int CalculateConsumeSP(LPCHARACTER lpChar)
+{
+	static const int NEED_WARP_SP_PERCENT = 30;
+
+	const int curSP = lpChar->GetSP();
+	const int needSP = lpChar->GetMaxSP() * NEED_WARP_SP_PERCENT / 100;
+
+	if (curSP < needSP)
+	{
+		lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 킹  眉   求."));
+		return -1;
+	}
+
+	return needSP;
+}
+
+bool CHARACTER::UseItemEx(LPITEM item, TItemPos DestCell)
+{
+	int iLimitRealtimeStartFirstUseFlagIndex = -1;
+	int iLimitTimerBasedOnWearFlagIndex = -1;
+
+	WORD wDestCell = DestCell.cell;
+	BYTE bDestInven = DestCell.window_type;
+
+	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+	{
+		long limitValue = item->GetProto()->aLimits[i].lValue;
+
+		switch (item->GetProto()->aLimits[i].bType)
+		{
+			case LIMIT_LEVEL:
+			{
+				if (GetLevel() < limitValue)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("  紀  求."));
+					return false;
+				}
+			}
+			break;
+
+#if defined(__CONQUEROR_LEVEL__)
+			case LIMIT_NEWWORLD_LEVEL:
+			{
+				if (GetConquerorLevel() < limitValue)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("  紀  求."));
+					return false;
+				}
+			}
+			break;
+#endif
+
+			case LIMIT_REAL_TIME_START_FIRST_USE:
+				iLimitRealtimeStartFirstUseFlagIndex = i;
+				break;
+
+			case LIMIT_TIMER_BASED_ON_WEAR:
+				iLimitTimerBasedOnWearFlagIndex = i;
+				break;
+		}
+	}
+
+	if (test_server)
+	{
+		sys_log(0, "USE_ITEM %s, Inven %d, Cell %d, ItemType %d, SubType %d", item->GetName(), bDestInven, wDestCell, item->GetType(), item->GetSubType());
+	}
+
+	if (CArenaManager::instance().IsLimitedItem(GetMapIndex(), item->GetVnum()))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 傷 結   품都求."));
+		return false;
+	}
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (GetActiveGrowthPet())
+	{
+		ChatPacket(CHAT_TYPE_INFO, "You cannot improve that while an evolvable pet has been summoned.");
+		return false;
+	}
+#endif
+
+	//    캤姑  刻틉 챨 풔  처.
+	if (-1 != iLimitRealtimeStartFirstUseFlagIndex)
+	{
+		//  繭   灌 Socket1  풔磯. (Socket1 횟 )
+		if (0 == item->GetSocket(1))
+		{
+			// 諛℃시 Default  Limit Value  溝, Socket0     溝 磯. ( )
+			long duration = (0 != item->GetSocket(0)) ? item->GetSocket(0) : item->GetProto()->aLimits[iLimitRealtimeStartFirstUseFlagIndex].lValue;
+
+			if (0 == duration)
+				duration = 60 * 60 * 24 * 7;
+
+			item->SetSocket(0, time(0) + duration);
+			item->StartRealTimeExpireEvent();
+		}
+
+		if (false == item->IsEquipped())
+			item->SetSocket(1, item->GetSocket(1) + 1);
+	}
+
+#if defined(__MAILBOX__)
+	if (item->GetVnum() == ITEM_MOBILE_MAILBOX)
+	{
+		CMailBox::Open(this);
+		return true;
+	}
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	if (item->GetVnum() == ITEM_EXTEND_INVEN_TICKET ||
+		item->GetVnum() == ITEM_EXTEND_INVEN_TICKET_MALL)
+	{
+		ExtendInvenRequest();
+		return true;
+	}
+#endif
+
+	switch (item->GetType())
+	{
+#ifdef __GROWTH_PET_SYSTEM__
+	if (GetActiveGrowthPet())
+	{
+		ChatPacket(CHAT_TYPE_INFO, "You cannot improve that while an evolvable pet has been summoned.");
+		return false;
+	}
+#endif
+		case ITEM_HAIR:
+			return ItemProcess_Hair(item, wDestCell);
+
+		case ITEM_POLYMORPH:
+			return ItemProcess_Polymorph(item);
+
+		case ITEM_QUEST:
+		{
+			if (GetArena() != NULL || IsObserverMode() == true)
+			{
+				if (item->GetVnum() == ITEM_VNUM_HORSE_PICTURE || item->GetVnum() == ITEM_VNUM_ARMED_HORSE_BOOK || item->GetVnum() == ITEM_VNUM_MILITARY_HORSE_BOOK)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 傷 結   품都求."));
+					return false;
+				}
+			}
+
+			if (!IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE))
+			{
+				if (item->GetSIGVnum() == 0)
+				{
+					quest::CQuestManager::instance().UseItem(GetPlayerID(), item, false);
+				}
+				else
+				{
+					quest::CQuestManager::instance().SIGUse(GetPlayerID(), item->GetSIGVnum(), item, false);
+				}
+			}
+		}
+		break;
+
+		case ITEM_CAMPFIRE:
+		{
+			float fx, fy;
+			GetDeltaByDegree(GetRotation(), 100.0f, &fx, &fy);
+
+			LPSECTREE tree = SECTREE_MANAGER::instance().Get(GetMapIndex(), (long)(GetX() + fx), (long)(GetY() + fy));
+
+			if (!tree)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("謎 퓻   都求."));
+				return false;
+			}
+
+			if (tree->IsAttr((long)(GetX() + fx), (long)(GetY() + fy), ATTR_WATER))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 淡 謎 퓻  求."));
+				return false;
+			}
+
+			LPCHARACTER campfire = CHARACTER_MANAGER::instance().SpawnMob(fishing::CAMPFIRE_MOB, GetMapIndex(), (long)(GetX() + fx), (long)(GetY() + fy), 0, false, number(0, 359));
+
+			char_event_info* info = AllocEventInfo<char_event_info>();
+
+			info->ch = campfire;
+
+			campfire->m_pkMiningEvent = event_create(kill_campfire_event, info, PASSES_PER_SEC(40));
+
+			item->SetCount(item->GetCount() - 1);
+		}
+		break;
+
+		case ITEM_UNIQUE:
+		{
+			switch (item->GetSubType())
+			{
+				case USE_ABILITY_UP:
+				{
+					if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+						return false;
+					}
+
+					switch (item->GetValue(0))
+					{
+						case APPLY_MOV_SPEED:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MOV_SPEED,
+								item->GetValue(2), AFF_MOV_SPEED_POTION, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_ATT_SPEED:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATT_SPEED,
+								item->GetValue(2), AFF_ATT_SPEED_POTION, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_STR:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ST,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_DEX:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_DX,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_CON:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_HT,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_INT:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_IQ,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_CAST_SPEED:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_CASTING_SPEED,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_RESIST_MAGIC:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_MAGIC,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_ATT_GRADE_BONUS:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATT_GRADE_BONUS,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_DEF_GRADE_BONUS:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_DEF_GRADE_BONUS,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+					}
+
+					if (GetDungeon())
+						GetDungeon()->UsePotion(this);
+
+					if (GetWarMap())
+						GetWarMap()->UsePotion(this, item);
+
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case UNIQUE_BUNDLE:
+				{
+					if (IsRiding())
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this bundle whilst riding."));
+						return false;
+					}
+
+					if (GetWear(ARMOR_BODY))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("      笭求."));
+						return false;
+					}
+
+					switch (item->GetVnum())
+					{
+						case 71049: // 甁
+						{
+							if (LC_IsYMIR() == true || LC_IsKorea() == true)
+							{
+								if (IS_BOTARYABLE_ZONE(GetMapIndex()) == true)
+								{
+									UseSilkBotary();
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("     都求"));
+								}
+							}
+							else
+							{
+								UseSilkBotary();
+							}
+						}
+						break;
+
+#if defined(__MYSHOP_DECO__)
+						case ITEM_KASHMIR_BUNDLE:
+							ChatPacket(CHAT_TYPE_COMMAND, "OpenMyShopDecoWnd");
+							break;
+#endif
+					}
+				}
+				break;
+
+				default:
+				{
+					if (!item->IsEquipped())
+						EquipItem(item);
+					else
+						UnequipItem(item);
+				}
+				break;
+			}
+		}
+		break;
+
+		case ITEM_COSTUME:
+		case ITEM_WEAPON:
+		case ITEM_ARMOR:
+		case ITEM_ROD:
+		case ITEM_RING: // 킥  
+		case ITEM_BELT: // 킥 트 
+		case ITEM_PICK: // MINING
+		{
+			if (!item->IsEquipped())
+				EquipItem(item);
+			else
+				UnequipItem(item);
+		}
+		break;
+
+		//   혼   .
+		//  클, 혼 臼 item use 킷   .
+		// 혼  item move 킷 磯.
+		//  혼 磯.
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case ITEM_DS:
+		{
+			if (!item->IsEquipped())
+				return false;
+
+			return DSManager::instance().PullOut(this, NPOS, item);
+		}
+
+		case ITEM_SPECIAL_DS:
+		{
+			if (!item->IsEquipped())
+				EquipItem(item);
+			else
+				UnequipItem(item);
+		}
+		break;
+#endif
+
+		case ITEM_FISH:
+		{
+			if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 傷 結   품都求."));
+				return false;
+			}
+
+			if (item->GetSubType() == FISH_ALIVE)
+				fishing::UseFish(this, item);
+		}
+		break;
+
+		case ITEM_TREASURE_BOX:
+		{
+			return false;
+			//ChatPacket(CHAT_TYPE_TALKING, LC_STRING("  羚底  苛째 . 甕 曼."));
+		}
+		break;
+
+		case ITEM_TREASURE_KEY:
+		{
+			LPITEM item2;
+
+			if (!GetItem(DestCell) || !(item2 = GetItem(DestCell)))
+				return false;
+
+			if (item2->IsExchanging())
+				return false;
+
+			if (item2->GetType() != ITEM_TREASURE_BOX)
+			{
+				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("   틈璣 ."));
+				return false;
+			}
+
+			if (item->GetValue(0) == item2->GetValue(0))
+			{
+				//ChatPacket(CHAT_TYPE_TALKING, LC_STRING("   獵 觀  홴퓸求."));
+
+				if (GiveItemFromSpecialItemGroup(item2->GetVnum()))
+				{
+					item->SetCount(item->GetCount() - 1);
+					item2->SetCount(item2->GetCount() - 1);
+				}
+				else
+				{
+					ChatPacket(CHAT_TYPE_TALKING, LC_STRING("瘟  苛  ."));
+					return false;
+				}
+			}
+			else
+			{
+				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("瘟  苛  ."));
+				return false;
+			}
+		}
+		break;
+
+		case ITEM_GIFTBOX:
+		{
+			DWORD dwBoxVnum = item->GetVnum();
+
+			if (dwBoxVnum == 50033 && LC_IsYMIR()) // 鋼 
+			{
+				if (GetLevel() < 15)
+				{
+					ChatPacket(CHAT_TYPE_INFO, "15 臼   求.");
+					return false;
+				}
+			}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			if ((dwBoxVnum > 51500 && dwBoxVnum < 52000) || (dwBoxVnum >= 50255 && dwBoxVnum <= 50260)) // 혼
+			{
+				if (!(this->DragonSoul_IsQualified()))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 혼 트 狗究탑 爛求."));
+					return false;
+				}
+			}
+#endif
+
+			if (!GiveItemFromSpecialItemGroup(dwBoxVnum))
+			{
+				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("틜孤   求."));
+				return false;
+			}
+
+			item->SetCount(item->GetCount() - 1);
+		}
+		break;
+
+		case ITEM_SKILLFORGET:
+		{
+			if (!item->GetSocket(0))
+			{
+				ITEM_MANAGER::instance().RemoveItem(item);
+				return false;
+			}
+
+			DWORD dwVnum = item->GetSocket(0);
+
+			if (SkillLevelDown(dwVnum))
+			{
+				ITEM_MANAGER::instance().RemoveItem(item);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("킬  쨉 臼求."));
+			}
+			else
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("킬    求."));
+		}
+		break;
+
+		case ITEM_SKILLBOOK:
+		{
+			if (IsPolymorphed())
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("傷 책  求."));
+				return false;
+			}
+
+			DWORD dwVnum = 0;
+
+			if (item->GetVnum() == ITEM_SKILLBOOK_VNUM)
+			{
+				dwVnum = item->GetSocket(0);
+			}
+			else
+			{
+				// 恝 체 value 0  킬 호 퓐 陋 .
+				dwVnum = item->GetValue(0);
+			}
+
+			if (0 == dwVnum)
+			{
+				ITEM_MANAGER::instance().RemoveItem(item);
+				return false;
+			}
+
+			if (true == LearnSkillByBook(dwVnum))
+			{
+				item->SetCount(item->GetCount() - 1);
+
+				int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+
+				if (distribution_test_server)
+					iReadDelay /= 3;
+
+				// 畸  荑 챨 24챨 
+				if (LC_IsKorea())
+					iReadDelay = 86400;
+
+				SetSkillNextReadTime(dwVnum, get_global_time() + iReadDelay);
+			}
+		}
+		break;
+
+		case ITEM_USE:
+		{
+			if (item->GetVnum() > 50800 && item->GetVnum() <= 50820)
+			{
+				if (test_server)
+					sys_log(0, "ADD addtional effect : vnum(%d) subtype(%d)", item->GetOriginalVnum(), item->GetSubType());
+
+				int affect_type = AFFECT_EXP_BONUS_EURO_FREE;
+				int apply_type = aApplyInfo[item->GetValue(0)].wPointType;
+				int apply_value = item->GetValue(2);
+				int apply_duration = item->GetValue(1);
+
+				switch (item->GetSubType())
+				{
+					case USE_ABILITY_UP:
+					{
+						if (FindAffect(affect_type, apply_type))
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+							return false;
+						}
+
+						if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+							return false;
+						}
+
+						switch (item->GetValue(0))
+						{
+							case APPLY_MOV_SPEED:
+							{
+								AddAffect(affect_type, apply_type, apply_value, AFF_MOV_SPEED_POTION, apply_duration, 0, true, true);
+								break;
+							}
+
+							case APPLY_ATT_SPEED:
+							{
+								AddAffect(affect_type, apply_type, apply_value, AFF_ATT_SPEED_POTION, apply_duration, 0, true, true);
+								break;
+							}
+
+							case APPLY_STR:
+							case APPLY_DEX:
+							case APPLY_CON:
+							case APPLY_INT:
+							case APPLY_CAST_SPEED:
+							case APPLY_CRITICAL_PCT:
+							case APPLY_PENETRATE_PCT:
+							case APPLY_RESIST_MAGIC:
+							case APPLY_ATT_GRADE_BONUS:
+							case APPLY_DEF_GRADE_BONUS:
+#if defined(__CONQUEROR_LEVEL__)
+							case APPLY_SUNGMA_STR:
+							case APPLY_SUNGMA_HP:
+							case APPLY_SUNGMA_MOVE:
+							case APPLY_SUNGMA_IMMUNE:
+#endif
+							{
+								AddAffect(affect_type, apply_type, apply_value, 0, apply_duration, 0, true, true);
+								break;
+							}
+
+						}
+
+						if (GetDungeon())
+							GetDungeon()->UsePotion(this);
+
+						if (GetWarMap())
+							GetWarMap()->UsePotion(this, item);
+
+						item->SetCount(item->GetCount() - 1);
+					}
+					break;
+
+					case USE_AFFECT:
+					{
+						if (FindAffect(AFFECT_EXP_BONUS_EURO_FREE, aApplyInfo[item->GetValue(1)].wPointType))
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+						}
+						else
+						{
+							AddAffect(AFFECT_EXP_BONUS_EURO_FREE, aApplyInfo[item->GetValue(1)].wPointType, item->GetValue(2), 0, item->GetValue(3), 0, false, true);
+							item->SetCount(item->GetCount() - 1);
+						}
+					}
+					break;
+
+					case USE_POTION_NODELAY:
+					{
+						if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+						{
+							if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("恙 絿  求."));
+								return false;
+							}
+
+							switch (item->GetVnum())
+							{
+								case 70020: // Peach Flower Wine
+								case 71018: // Blessing of Life
+								case 71019: // Blessing of Magic
+								case 71020: // Blessing of the Dragon
+								{
+									if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
+									{
+										if (m_nPotionLimit <= 0)
+										{
+											ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 祈 歌臼求."));
+											return false;
+										}
+									}
+								}
+								break;
+
+								default:
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("恙 絿  求."));
+									return false;
+								}
+							}
+						}
+
+						bool bUsed = false;
+
+						if (item->GetValue(0) != 0) // HP 諛 회
+						{
+							if (GetHP() < GetMaxHP())
+							{
+								PointChange(POINT_HP, item->GetValue(0) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
+								EffectPacket(SE_HPUP_RED);
+								bUsed = true;
+							}
+						}
+
+						if (item->GetValue(1) != 0) // SP 諛 회
+						{
+							if (GetSP() < GetMaxSP())
+							{
+								PointChange(POINT_SP, item->GetValue(1) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
+								EffectPacket(SE_SPUP_BLUE);
+								bUsed = true;
+							}
+						}
+
+						if (item->GetValue(3) != 0) // HP % 회
+						{
+							if (GetHP() < GetMaxHP())
+							{
+								PointChange(POINT_HP, item->GetValue(3) * GetMaxHP() / 100);
+								EffectPacket(SE_HPUP_RED);
+								bUsed = true;
+							}
+						}
+
+						if (item->GetValue(4) != 0) // SP % 회
+						{
+							if (GetSP() < GetMaxSP())
+							{
+								PointChange(POINT_SP, item->GetValue(4) * GetMaxSP() / 100);
+								EffectPacket(SE_SPUP_BLUE);
+								bUsed = true;
+							}
+						}
+
+						if (bUsed)
+						{
+							if (item->GetVnum() == 50085 || item->GetVnum() == 50086)
+							{
+								if (test_server)
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 풔   臼求"));
+
+								SetUseSeedOrMoonBottleTime();
+							}
+
+							if (GetDungeon())
+								GetDungeon()->UsePotion(this);
+
+							if (GetWarMap())
+								GetWarMap()->UsePotion(this, item);
+
+							m_nPotionLimit--;
+
+							// RESTRICT_USE_SEED_OR_MOONBOTTLE
+							item->SetCount(item->GetCount() - 1);
+							// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
+						}
+					}
+					break;
+				}
+
+				return true;
+			}
+
+			if (item->GetVnum() >= 27863 && item->GetVnum() <= 27883)
+			{
+				if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 傷 結   품都求."));
+					return false;
+				}
+			}
+
+			if (test_server)
+			{
+				sys_log(0, "USE_ITEM %s Type %d SubType %d vnum %d", item->GetName(), item->GetType(), item->GetSubType(), item->GetOriginalVnum());
+			}
+
+			switch (item->GetSubType())
+			{
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				case USE_ELEMENT_UPGRADE:
+				case USE_ELEMENT_DOWNGRADE:
+				case USE_ELEMENT_CHANGE:
+					RefineElementInformation(item, DestCell);
+					break;
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+				case USE_EMOTION_PACK:
+				{
+					AddEmote();
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+#endif
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+				case USE_TIME_CHARGE_PER:
+				{
+					LPITEM pDestItem = GetItem(DestCell);
+					if (NULL == pDestItem)
+						return false;
+
+					// 耳 혼 漫 溝 磯.
+					if (pDestItem->IsDragonSoul())
+					{
+						int ret;
+						char buf[128];
+						if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
+						{
+							ret = pDestItem->GiveMoreTime_Per((float)item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
+						}
+						else
+						{
+							ret = pDestItem->GiveMoreTime_Per((float)item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+						}
+
+						if (ret > 0)
+						{
+#if defined(__DS_SET__)
+							DragonSoul_SetBonus();
+#endif
+
+							if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
+							{
+								sprintf(buf, "Inc %ds by item{VN:%d SOC%d:%d}", ret, item->GetVnum(), ITEM_SOCKET_CHARGING_AMOUNT_IDX, item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
+							}
+							else
+							{
+								sprintf(buf, "Inc %ds by item{VN:%d VAL%d:%d}", ret, item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+							}
+
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d 큼 퓸求.", ret));
+							item->SetCount(item->GetCount() - 1);
+							LogManager::instance().ItemLog(this, item, "DS_CHARGING_SUCCESS", buf);
+
+							return true;
+						}
+						else
+						{
+							if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
+							{
+								sprintf(buf, "No change by item{VN:%d SOC%d:%d}", item->GetVnum(), ITEM_SOCKET_CHARGING_AMOUNT_IDX, item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
+							}
+							else
+							{
+								sprintf(buf, "No change by item{VN:%d VAL%d:%d}", item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+							}
+
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("  求."));
+							LogManager::instance().ItemLog(this, item, "DS_CHARGING_FAILED", buf);
+							return false;
+						}
+					}
+					else
+						return false;
+				}
+				break;
+
+				case USE_TIME_CHARGE_FIX:
+				{
+					LPITEM pDestItem = GetItem(DestCell);
+					if (NULL == pDestItem)
+						return false;
+
+					// 耳 혼 漫 溝 磯.
+					if (pDestItem->IsDragonSoul())
+					{
+						int ret = pDestItem->GiveMoreTime_Fix(item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+						char buf[128];
+						if (ret)
+						{
+#if defined(__DS_SET__)
+							DragonSoul_SetBonus();
+#endif
+
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d 큼 퓸求.", ret));
+
+							sprintf(buf, "Increase %ds by item{VN:%d VAL%d:%d}", ret, item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+							LogManager::instance().ItemLog(this, item, "DS_CHARGING_SUCCESS", buf);
+							item->SetCount(item->GetCount() - 1);
+
+							return true;
+						}
+						else
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("  求."));
+							sprintf(buf, "No change by item{VN:%d VAL%d:%d}", item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+							LogManager::instance().ItemLog(this, item, "DS_CHARGING_FAILED", buf);
+							return false;
+						}
+					}
+					else
+						return false;
+				}
+				break;
+#endif
+
+				case USE_SPECIAL:
+				{
+					switch (item->GetVnum())
+					{
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+						case ITEM_GUILD_DRAGONLAIR_POTION:
+						{
+							if (GetGuildDragonLair() == NULL)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
+								return false;
+							}
+
+							if (FindAffect(AFFECT_RED_DRAGONLAIR_BUFF))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+								return false;
+							}
+							else
+							{
+								const long duration = item->GetValue(1);
+
+								AddAffect(AFFECT_RED_DRAGONLAIR_BUFF, POINT_SKILL_DEFEND_BONUS, 15, AFF_NONE, duration, 0, true, true);
+								AddAffect(AFFECT_RED_DRAGONLAIR_BUFF, POINT_NORMAL_HIT_DEFEND_BONUS, 15, AFF_NONE, duration, 0, true, true);
+
+								item->SetCount(item->GetCount() - 1);
+							}
+						}
+						break;
+#endif
+
+#if defined(__ELEMENTAL_DUNGEON__)
+						case ITEM_PRIMAL_FORCE_MEDAL:
+						{
+							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
+								return false;
+							}
+
+							CAffect* pAffect = FindAffect(AFFECT_PROTECTION_OF_ELEMENTAL);
+							if (pAffect)
+							{
+								// NOTE : Check if adding another 600 seconds (10 minutes) would exceed 3600 seconds (60 minutes).
+								const long lDuration = pAffect->lDuration;
+								if (lDuration + 600 > 3600)
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that any more."));
+									return false;
+								}
+
+								AddAffect(AFFECT_PROTECTION_OF_ELEMENTAL, APPLY_NONE, 0, AFF_NONE, lDuration + 600, 0, true);
+							}
+							else
+								AddAffect(AFFECT_PROTECTION_OF_ELEMENTAL, APPLY_NONE, 0, AFF_NONE, 600, 0, true);
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_ELEMENTAL_DEFENSE_POTION:
+						{
+							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
+								return false;
+							}
+
+							const long duration = item->GetValue(1);
+							static const std::unordered_map<POINT_TYPE, POINT_VALUE> map_affect = {
+								{ APPLY_MELEE_MAGIC_ATTBONUS_PER, 5 },
+								{ APPLY_RESIST_FIRE, 10 },
+								{ APPLY_RESIST_ELEC, 10 },
+								{ APPLY_RESIST_ICE, 10 },
+								{ APPLY_RESIST_EARTH, 10 },
+								{ APPLY_RESIST_DARK, 10 },
+							};
+							for (const auto& it : map_affect)
+								AddAffect(AFFECT_POTION_OF_ELEMENTAL, it.first, it.second, AFF_NONE, duration, 0, true, true);
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_PRIMAL_FORCE_RING:
+						case ITEM_PRIMAL_FORCE_RING_MALL:
+						{
+							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
+								return false;
+							}
+
+							if (number(0, 100) < item->GetValue(0))
+							{
+								PIXEL_POSITION WarpPos;
+								if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(MAP_ELEMENTAL_04, GetEmpire(), WarpPos))
+									WarpSet(WarpPos.x, WarpPos.y);
+								else
+									sys_err("CHARACTER::UseItem : cannot find spawn position (name %s, %d x %d)", GetName(), GetX(), GetY());
+							}
+							else
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Teleportation to the Plateau of Primal Forces has failed."));
+							
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+#if defined(__MINI_GAME_RUMI__) && defined(__OKEY_EVENT_FLAG_RENEWAL__)
+						case ITEM_VNUM_RUMI_CARD_PIECE:
+						{
+							if (CMiniGameRumi::UpdateQuestFlag(this))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_VNUM_RUMI_CARD_PACK:
+						{
+							const WORD wCardCount = GetQuestFlag("minigame_rumi.card_count");
+							if (wCardCount < CMiniGameRumi::RUMI_CARD_COUNT_MAX)
+							{
+								SetQuestFlag("minigame_rumi.card_count", wCardCount + 1);
+								CMiniGameRumi::RequestQuestFlag(this, RUMI_GC_SUBHEADER_SET_CARD_FLAG);
+
+								item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								CMiniGameRumi::RequestQuestFlag(this, RUMI_GC_SUBHEADER_NO_MORE_GAIN);
+							}
+						}
+						break;
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__) && defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+						case ITEM_VNUM_YUT_PIECE:
+						{
+							if (CMiniGameYutnori::UpdateQuestFlag(this))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_VNUM_YUT_BOARD:
+						{
+							const WORD wYutBoardCount = GetQuestFlag("minigame_yutnori.board_count");
+							if (wYutBoardCount < CMiniGameYutnori::YUTNORI_BOARD_COUNT_MAX)
+							{
+								SetQuestFlag("minigame_yutnori.board_count", wYutBoardCount + 1);
+								CMiniGameYutnori::RequestQuestFlag(this, YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG);
+
+								item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								CMiniGameYutnori::RequestQuestFlag(this, YUTNORI_GC_SUBHEADER_NO_MORE_GAIN);
+							}
+						}
+						break;
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__) && defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
+						case ITEM_VNUM_CATCH_KING_PIECE:
+						{
+							if (CMiniGameCatchKing::UpdateQuestFlag(this))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_VNUM_CATCH_KING_PACK:
+						{
+							const WORD wPackCount = GetQuestFlag("minigame_catchking.pack_count");
+							if (wPackCount < CMiniGameCatchKing::CATCH_KING_PACK_COUNT_MAX)
+							{
+								SetQuestFlag("minigame_catchking.pack_count", wPackCount + 1);
+								CMiniGameCatchKing::RequestQuestFlag(this, CATCHKING_GC_SET_CARD_FLAG);
+
+								item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								CMiniGameCatchKing::RequestQuestFlag(this, CATCHKING_GC_NO_MORE_GAIN);
+							}
+						}
+						break;
+#endif
+
+#if defined(__EASTER_EVENT__)
+						case ITEM_MAGIC_EASTER_EGG:
+						{
+							int nMaxUse = 3;
+							int nNextUseTime = 1800;
+
+							int nUseTime = get_global_time() - item->GetSocket(1);
+							int nUseCount = item->GetSocket(0);
+
+							if (nUseTime >= nNextUseTime)
+							{
+								if (GiveItemFromSpecialItemGroup(ITEM_MAGIC_EASTER_EGG))
+								{
+									item->SetSocket(1, get_global_time());
+									if (nUseCount >= (nMaxUse - 1))
+										item->SetCount(item->GetCount() - 1);
+									else
+										item->SetSocket(0, nUseCount + 1);
+
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Total %d: You can still unpack %d.", nMaxUse, (nMaxUse - 1) - nUseCount));
+								}
+								else
+									ChatPacket(CHAT_TYPE_TALKING, LC_STRING("틜孤   求."));
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unpack the next gift in %d minutes.", 31 - nUseTime / 60));
+							}
+						}
+						break;
+#endif
+
+#if defined(__GEM_CONVERTER__)
+						case ITEM_VNUM_GEM_CONVERTER:
+						{
+							LPITEM pTargetItem;
+							if (!IsValidItemPosition(DestCell) || !(pTargetItem = GetItem(DestCell)))
+								return false;
+
+							if (pTargetItem->GetVnum() != ITEM_VNUM_GEM_STONE)
+								return false;
+
+							if (item->IsExchanging() || pTargetItem->IsExchanging())
+								return false;
+
+							if (item->isLocked() || pTargetItem->isLocked())
+								return false;
+
+							int iNeedGemStoneCount = item->GetCount() * item->GetValue(0);
+							int iConvertToGem = iNeedGemStoneCount / item->GetValue(0);
+							int iConvertCost = item->GetCount() * item->GetValue(1);
+
+							if (pTargetItem->GetCount() < iNeedGemStoneCount)
+								return false;
+
+							if (GetGold() < iConvertCost)
+								return false;
+
+							if (GetGem() + iConvertToGem >= GEM_MAX)
+								return false;
+
+							item->SetCount(item->GetCount() - 1);
+							pTargetItem->SetCount(pTargetItem->GetCount() - iNeedGemStoneCount);
+
+							PointChange(POINT_GOLD, -iConvertCost);
+							PointChange(POINT_GEM, iConvertToGem);
+						}
+						break;
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+						case ITEM_VNUM_SNOWFLAKE_STICK:
+						{
+							if (CSnowflakeStickEvent::UseStick(this))
+							{
+								EffectPacket(SE_USE_SNOWFLAKE_STICK);
+								item->SetCount(item->GetCount() - 1);
+							}
+						}
+						break;
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+						case ITEM_ACCE_REVERSAL:
+						case ITEM_ACCE_REVERSAL_MALL:
+						{
+							LPITEM lpTargetItem;
+							if (!IsValidItemPosition(DestCell) || !(lpTargetItem = GetItem(DestCell)))
+								return false;
+
+							if (lpTargetItem->IsExchanging())
+								return false;
+
+							if (lpTargetItem->isLocked())
+								return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (lpTargetItem->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
+								return false;
+							}
+#endif
+
+							if (IsAcceRefineWindowOpen())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item while the windows for absorption and combination are open."));
+								return false;
+							}
+
+							lpTargetItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_ITEM_VNUM, 0);
+							lpTargetItem->ClearAllAttribute();
+							lpTargetItem->UpdatePacket();
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+						case ITEM_CHANGE_LOOK_REVERSAL:
+						case ITEM_CHANGE_LOOK_MOUNT_REVERSAL:
+						{
+							LPITEM item2;
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item2->IsExchanging())
+								return false;
+
+							if (item2->isLocked())
+								return false;
+
+							if (item2->GetTransmutationVnum() == 0)
+								return false;
+
+							if (item->GetVnum() == ITEM_CHANGE_LOOK_MOUNT_REVERSAL && !item2->IsCostumeMount())
+								return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
+								return false;
+							}
+#endif
+
+							item2->SetTransmutationVnum(0);
+							item2->UpdatePacket();
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+						case ITEM_VNUM_AURA_CLEAR:
+						{
+							LPITEM lpTargetItem;
+							if (!IsValidItemPosition(DestCell) || !(lpTargetItem = GetItem(DestCell)))
+								return false;
+
+							if (lpTargetItem->IsExchanging())
+								return false;
+
+							if (lpTargetItem->isLocked())
+								return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (lpTargetItem->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
+								return false;
+							}
+#endif
+
+							if (IsAuraRefineWindowOpen())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item while the windows for absorption and combination are open."));
+								return false;
+							}
+
+							lpTargetItem->SetSocket(ITEM_SOCKET_AURA_DRAIN_ITEM_VNUM, 0);
+							lpTargetItem->ClearAllAttribute();
+							lpTargetItem->UpdatePacket();
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+#if defined(__SET_ITEM__)
+						case ITEM_SET_CLEAR_SCROLL:
+						{
+							LPITEM item2;
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item->IsExchanging() || item2->IsExchanging() || item2->IsEquipped())
+								return false;
+
+							if (item->isLocked() || item2->isLocked())
+								return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
+								return false;
+							}
+#endif
+
+							item2->SetItemSetValue(0);
+							item2->UpdatePacket();
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+						// RESEARCHER_ELIXIR
+						case ITEM_RESEARCHERS_ELIXIR:
+						case ITEM_RESEARCHERS_ELIXIR_GIFT:
+						case ITEM_RESEARCHERS_ELIXIR_MALL:
+						{
+							if (FindAffect(AFFECT_RESEARCHER_ELIXIR))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+							}
+							else
+							{
+								AddAffect(AFFECT_RESEARCHER_ELIXIR, APPLY_NONE, 1, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
+								item->SetCount(item->GetCount() - 1);
+							}
+						}
+						break;
+						// END_RESEARCHER_ELIXIR
+
+#if defined(__SOUL_BIND_SYSTEM__)
+						case ITEM_SCROLL_BINDING:
+						{
+							if (!g_bSoulBind)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot soulbind items on this server."));
+								return false;
+							}
+
+							LPITEM item2;
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item2->IsExchanging())
+								return false;
+
+							if (!item2->CanSealItem())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot bind this item to your soul."));
+								return false;
+							}
+
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("This item is already soulbound."));
+								return false;
+							}
+
+							item2->SealItem();
+
+							char buf[256 + 1];
+							snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
+								item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
+							LogManager::instance().ItemLog(this, item, "SEAL_SCROLL_USE_SUCCESS", buf);
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_SCROLL_UNBINDING:
+#if defined(__UN_SEAL_SCROLL_PLUS__)
+						case ITEM_SCROLL_UNBINDING_MALL:
+#endif
+						{
+							LPITEM item2;
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item2->isLocked() || item2->IsExchanging())
+								return false;
+
+							if (!item2->IsSealed())
+								return false;
+
+							if (item2->GetSealDate() > E_SEAL_DATE_DEFAULT_TIMESTAMP)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("The soulbind on this item is already in the process of being removed."));
+								return false;
+							}
+
+#if defined(__UN_SEAL_SCROLL_PLUS__)
+							if (item->GetVnum() == ITEM_SCROLL_UNBINDING_MALL)
+							{
+								item2->SealItem(E_SEAL_DATE_DEFAULT_TIMESTAMP);
+
+								char buf[256 + 1];
+								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
+									item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
+								LogManager::instance().ItemLog(this, item, "UN_SEAL_SCROLL_PLUS_USE_SUCCESS", buf);
+							}
+							else
+#endif
+							{
+								long lSealDate = time(0);
+
+								if (test_server)
+									lSealDate += 60;
+								else
+									lSealDate += (60 * 60 * SEAL_DATE_MAX);
+
+								item2->SealItem(lSealDate);
+								item2->StartSealDateExpireTimerEvent();
+
+								char buf[256 + 1];
+								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
+									item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
+								LogManager::instance().ItemLog(this, item, "UN_SEAL_SCROLL_USE_SUCCESS", buf);
+							}
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+						// 크 
+						case ITEM_NOG_POCKET:
+						{
+							/*
+							獵렬 : item_proto value 퓜
+								絹撻 value 1
+								賦 value 2
+								치 value 3
+								擔챨 value 0 ( )
+							*/
+							if (FindAffect(AFFECT_NOG_ABILITY))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+								return false;
+							}
+							long time = item->GetValue(0);
+							long moveSpeedPer = item->GetValue(1);
+							long attPer = item->GetValue(2);
+							long expPer = item->GetValue(3);
+							AddAffect(AFFECT_NOG_ABILITY, POINT_MOV_SPEED, moveSpeedPer, AFF_MOV_SPEED_POTION, time, 0, true, true);
+							AddAffect(AFFECT_NOG_ABILITY, POINT_MALL_ATTBONUS, attPer, AFF_NONE, time, 0, true, true);
+							AddAffect(AFFECT_NOG_ABILITY, POINT_MALL_EXPBONUS, expPer, AFF_NONE, time, 0, true, true);
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						// 窄떪餠 
+						case ITEM_RAMADAN_CANDY:
+						{
+							/*
+							렬 : item_proto value 퓜
+								絹撻 value 1
+								賦 value 2
+								치 value 3
+								擔챨 value 0 ( )
+							*/
+							if (FindAffect(AFFECT_RAMADAN_ABILITY))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+								return false;
+							}
+
+							long time = item->GetValue(0);
+							long moveSpeedPer = item->GetValue(1);
+							long attPer = item->GetValue(2);
+							long expPer = item->GetValue(3);
+							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MOV_SPEED, moveSpeedPer, AFF_MOV_SPEED_POTION, time, 0, true, true);
+							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MALL_ATTBONUS, attPer, AFF_NONE, time, 0, true, true);
+							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MALL_EXPBONUS, expPer, AFF_NONE, time, 0, true, true);
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_MARRIAGE_RING:
+						{
+							marriage::TMarriage* pMarriage = marriage::CManager::instance().Get(GetPlayerID());
+							if (pMarriage)
+							{
+								if (pMarriage->ch1 != NULL)
+								{
+									if (CArenaManager::instance().IsArenaMap(pMarriage->ch1->GetMapIndex()))
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 傷 結   품都求."));
+										break;
+									}
+								}
+
+								if (pMarriage->ch2 != NULL)
+								{
+									if (CArenaManager::instance().IsArenaMap(pMarriage->ch2->GetMapIndex()))
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 傷 結   품都求."));
+										break;
+									}
+								}
+
+								int consumeSP = CalculateConsumeSP(this);
+
+								if (consumeSP < 0)
+									return false;
+
+								PointChange(POINT_SP, -consumeSP, false);
+
+								WarpToPID(pMarriage->GetOther(GetPlayerID()));
+							}
+							else
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("혼 째 틈玖 혼   求."));
+						}
+						break;
+
+						case ITEM_WHITE_FLAG:
+							ForgetMyAttacker();
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case 30093:
+						case 30094:
+						case 30095:
+						case 30096:
+							// 寧鍛
+						{
+							const int MAX_BAG_INFO = 26;
+							static struct LuckyBagInfo
+							{
+								DWORD count;
+								int prob;
+								DWORD vnum;
+							} b1[MAX_BAG_INFO] =
+							{
+								{ 1000, 302, 1 },
+								{ 10, 150, 27002 },
+								{ 10, 75, 27003 },
+								{ 10, 100, 27005 },
+								{ 10, 50, 27006 },
+								{ 10, 80, 27001 },
+								{ 10, 50, 27002 },
+								{ 10, 80, 27004 },
+								{ 10, 50, 27005 },
+								{ 1, 10, ITEM_SKILLBOOK_VNUM },
+								{ 1, 6, 92 },
+								{ 1, 2, 132 },
+								{ 1, 6, 1052 },
+								{ 1, 2, 1092 },
+								{ 1, 6, 2082 },
+								{ 1, 2, 2122 },
+								{ 1, 6, 3082 },
+								{ 1, 2, 3122 },
+								{ 1, 6, 5052 },
+								{ 1, 2, 5082 },
+								{ 1, 6, 7082 },
+								{ 1, 2, 7122 },
+								{ 1, 1, 11282 },
+								{ 1, 1, 11482 },
+								{ 1, 1, 11682 },
+								{ 1, 1, 11882 },
+							};
+
+							struct LuckyBagInfo b2[MAX_BAG_INFO] =
+							{
+								{ 1000, 302, 1 },
+								{ 10, 150, 27002 },
+								{ 10, 75, 27002 },
+								{ 10, 100, 27005 },
+								{ 10, 50, 27005 },
+								{ 10, 80, 27001 },
+								{ 10, 50, 27002 },
+								{ 10, 80, 27004 },
+								{ 10, 50, 27005 },
+								{ 1, 10, ITEM_SKILLBOOK_VNUM },
+								{ 1, 6, 92 },
+								{ 1, 2, 132 },
+								{ 1, 6, 1052 },
+								{ 1, 2, 1092 },
+								{ 1, 6, 2082 },
+								{ 1, 2, 2122 },
+								{ 1, 6, 3082 },
+								{ 1, 2, 3122 },
+								{ 1, 6, 5052 },
+								{ 1, 2, 5082 },
+								{ 1, 6, 7082 },
+								{ 1, 2, 7122 },
+								{ 1, 1, 11282 },
+								{ 1, 1, 11482 },
+								{ 1, 1, 11682 },
+								{ 1, 1, 11882 },
+							};
+
+							LuckyBagInfo* bi = NULL;
+							if (LC_IsHongKong())
+								bi = b2;
+							else
+								bi = b1;
+
+							int pct = number(1, 1000);
+
+							int i;
+							for (i = 0; i < MAX_BAG_INFO; i++)
+							{
+								if (pct <= bi[i].prob)
+									break;
+								pct -= bi[i].prob;
+							}
+							if (i >= MAX_BAG_INFO)
+								return false;
+
+							if (bi[i].vnum == ITEM_SKILLBOOK_VNUM)
+							{
+								// 킬체 특構 娩.
+								GiveRandomSkillBook();
+							}
+							else if (bi[i].vnum == 1)
+							{
+								PointChange(POINT_GOLD, 1000, true);
+							}
+							else
+							{
+								AutoGiveItem(bi[i].vnum, bi[i].count);
+							}
+							ITEM_MANAGER::instance().RemoveItem(item);
+						}
+						break;
+
+						case 50004: // 遣트 
+						{
+							if (item->GetSocket(0))
+							{
+								item->SetSocket(0, item->GetSocket(0) + 1);
+							}
+							else
+							{
+								// 처 
+								int iMapIndex = GetMapIndex();
+
+								PIXEL_POSITION pos;
+
+								if (SECTREE_MANAGER::instance().GetRandomLocation(iMapIndex, pos, 700))
+								{
+									item->SetSocket(0, 1);
+									item->SetSocket(1, pos.x);
+									item->SetSocket(2, pos.y);
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("  遣트 璲  苛째 求."));
+									return false;
+								}
+							}
+
+							int dist = 0;
+							float distance = (DISTANCE_SQRT(GetX() - item->GetSocket(1), GetY() - item->GetSocket(2)));
+
+							if (distance < 1000.0f)
+							{
+								// 煞!
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("遣트 璲 탄恝   求."));
+
+								// 횟  獵  摸 磯.
+								struct TEventStoneInfo
+								{
+									DWORD dwVnum;
+									int count;
+									int prob;
+								};
+								const int EVENT_STONE_MAX_INFO = 15;
+								TEventStoneInfo info_10[EVENT_STONE_MAX_INFO] =
+								{
+									{ 27001, 10, 8 },
+									{ 27004, 10, 6 },
+									{ 27002, 10, 12 },
+									{ 27005, 10, 12 },
+									{ 27100, 1, 9 },
+									{ 27103, 1, 9 },
+									{ 27101, 1, 10 },
+									{ 27104, 1, 10 },
+									{ 27999, 1, 12 },
+
+									{ 25040, 1, 4 },
+
+									{ 27410, 1, 0 },
+									{ 27600, 1, 0 },
+									{ 25100, 1, 0 },
+
+									{ 50001, 1, 0 },
+									{ 50003, 1, 1 },
+								};
+								TEventStoneInfo info_7[EVENT_STONE_MAX_INFO] =
+								{
+									{ 27001, 10, 1 },
+									{ 27004, 10, 1 },
+									{ 27004, 10, 9 },
+									{ 27005, 10, 9 },
+									{ 27100, 1, 5 },
+									{ 27103, 1, 5 },
+									{ 27101, 1, 10 },
+									{ 27104, 1, 10 },
+									{ 27999, 1, 14 },
+
+									{ 25040, 1, 5 },
+
+									{ 27410, 1, 5 },
+									{ 27600, 1, 5 },
+									{ 25100, 1, 5 },
+
+									{ 50001, 1, 0 },
+									{ 50003, 1, 5 },
+
+								};
+								TEventStoneInfo info_4[EVENT_STONE_MAX_INFO] =
+								{
+									{ 27001, 10, 0 },
+									{ 27004, 10, 0 },
+									{ 27002, 10, 0 },
+									{ 27005, 10, 0 },
+									{ 27100, 1, 0 },
+									{ 27103, 1, 0 },
+									{ 27101, 1, 0 },
+									{ 27104, 1, 0 },
+									{ 27999, 1, 25 },
+
+									{ 25040, 1, 0 },
+
+									{ 27410, 1, 0 },
+									{ 27600, 1, 0 },
+									{ 25100, 1, 15 },
+
+									{ 50001, 1, 10 },
+									{ 50003, 1, 50 },
+
+								};
+
+								{
+									TEventStoneInfo* info;
+									if (item->GetSocket(0) <= 4)
+										info = info_4;
+									else if (item->GetSocket(0) <= 7)
+										info = info_7;
+									else
+										info = info_10;
+
+									int prob = number(1, 100);
+
+									for (int i = 0; i < EVENT_STONE_MAX_INFO; ++i)
+									{
+										if (!info[i].prob)
+											continue;
+
+										if (prob <= info[i].prob)
+										{
+											if (info[i].dwVnum == 50001)
+											{
+												DWORD* pdw = M2_NEW DWORD[2];
+
+												pdw[0] = info[i].dwVnum;
+												pdw[1] = info[i].count;
+
+												// 첨  磯
+												DBManager::instance().ReturnQuery(QID_LOTTO, GetPlayerID(), pdw,
+													"INSERT INTO lotto_list VALUES(0, 'server%s', %u, NOW())",
+													get_table_postfix(), GetPlayerID());
+											}
+											else
+												AutoGiveItem(info[i].dwVnum, info[i].count);
+
+											break;
+										}
+										prob -= info[i].prob;
+									}
+								}
+
+								char chatbuf[CHAT_MAX_LEN + 1];
+								int len = snprintf(chatbuf, sizeof(chatbuf), "StoneDetect %u 0 0", (DWORD)GetVID());
+
+								if (len < 0 || len >= (int)sizeof(chatbuf))
+									len = sizeof(chatbuf) - 1;
+
+								++len; // \0 未 
+
+								TPacketGCChat pack_chat;
+								pack_chat.header = HEADER_GC_CHAT;
+								pack_chat.size = sizeof(TPacketGCChat) + len;
+								pack_chat.type = CHAT_TYPE_COMMAND;
+								pack_chat.id = 0;
+								pack_chat.bEmpire = GetDesc()->GetEmpire();
+								//pack_chat.id = vid;
+
+								TEMP_BUFFER buf;
+								buf.write(&pack_chat, sizeof(TPacketGCChat));
+								buf.write(chatbuf, len);
+
+								PacketAround(buf.read_peek(), buf.size());
+
+								ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (DETECT_EVENT_STONE) 1");
+								return true;
+							}
+							else if (distance < 20000)
+								dist = 1;
+							else if (distance < 70000)
+								dist = 2;
+							else
+								dist = 3;
+
+							//   .
+							const int STONE_DETECT_MAX_TRY = 10;
+							if (item->GetSocket(0) >= STONE_DETECT_MAX_TRY)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("遣트 璲   求."));
+								ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (DETECT_EVENT_STONE) 0");
+								AutoGiveItem(27002);
+								return true;
+							}
+
+							if (dist)
+							{
+								char chatbuf[CHAT_MAX_LEN + 1];
+								int len = snprintf(chatbuf, sizeof(chatbuf),
+									"StoneDetect %u %d %d",
+									(DWORD)GetVID(), dist, (int)GetDegreeFromPositionXY(GetX(), item->GetSocket(2), item->GetSocket(1), GetY()));
+
+								if (len < 0 || len >= (int)sizeof(chatbuf))
+									len = sizeof(chatbuf) - 1;
+
+								++len; // \0 未 
+
+								TPacketGCChat pack_chat;
+								pack_chat.header = HEADER_GC_CHAT;
+								pack_chat.size = sizeof(TPacketGCChat) + len;
+								pack_chat.type = CHAT_TYPE_COMMAND;
+								pack_chat.id = 0;
+								pack_chat.bEmpire = GetDesc()->GetEmpire();
+								//pack_chat.id = vid;
+
+								TEMP_BUFFER buf;
+								buf.write(&pack_chat, sizeof(TPacketGCChat));
+								buf.write(chatbuf, len);
+
+								PacketAround(buf.read_peek(), buf.size());
+							}
+						}
+						break;
+
+						case 27989: // 
+						case 76006: //  
+						{
+							LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(GetMapIndex());
+
+							if (pMap != NULL)
+							{
+								item->SetSocket(0, item->GetSocket(0) + 1);
+
+								FFindStone f;
+
+								// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
+								pMap->for_each(f);
+
+								if (f.m_mapStone.size() > 0)
+								{
+									std::map<DWORD, LPCHARACTER>::iterator stone = f.m_mapStone.begin();
+
+									DWORD max = UINT_MAX;
+									LPCHARACTER pTarget = stone->second;
+
+									while (stone != f.m_mapStone.end())
+									{
+										DWORD dist = (DWORD)DISTANCE_SQRT(GetX() - stone->second->GetX(), GetY() - stone->second->GetY());
+
+										if (dist != 0 && max > dist)
+										{
+											max = dist;
+											pTarget = stone->second;
+										}
+										stone++;
+									}
+
+									if (pTarget != NULL)
+									{
+										int val = 3;
+
+										if (max < 10000) val = 2;
+										else if (max < 70000) val = 1;
+
+										ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u %d %d", (DWORD)GetVID(), val,
+											(int)GetDegreeFromPositionXY(GetX(), pTarget->GetY(), pTarget->GetX(), GetY()));
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("綬 謗臼 풔  求."));
+									}
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("綬 謗臼 풔  求."));
+								}
+
+								if (item->GetSocket(0) >= 6)
+								{
+									ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u 0 0", (DWORD)GetVID());
+									ITEM_MANAGER::instance().RemoveItem(item);
+								}
+							}
+							break;
+						}
+						break;
+
+#if defined(__MT_THUNDER_DUNGEON__)
+						case 79602:
+						{
+							if (GetMapIndex() != CMTThunderDungeon::MAP_INDEX)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("This action is not possible on this map."));
+								return false;
+							}
+
+							LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(GetMapIndex());
+
+							if (pMap != NULL)
+							{
+								item->SetSocket(0, item->GetSocket(0) + 1);
+
+								FFindMobVnum f(6405);
+
+								// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
+								pMap->for_each(f);
+
+								if (f.m_mapVID.size() > 0)
+								{
+									std::map<DWORD, LPCHARACTER>::iterator it = f.m_mapVID.begin();
+
+									DWORD max = UINT_MAX;
+									LPCHARACTER pTarget = it->second;
+
+									while (it != f.m_mapVID.end())
+									{
+										DWORD dist = (DWORD)DISTANCE_SQRT(GetX() - it->second->GetX(), GetY() - it->second->GetY());
+
+										if (dist != 0 && max > dist)
+										{
+											max = dist;
+											pTarget = it->second;
+										}
+										it++;
+									}
+
+									if (pTarget != NULL)
+									{
+										int val = 3;
+
+										if (max < 10000) val = 2;
+										else if (max < 70000) val = 1;
+
+										ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u %d %d", (DWORD)GetVID(), val,
+											(int)GetDegreeFromPositionXY(GetX(), pTarget->GetY(), pTarget->GetX(), GetY()));
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Compass was used, but the Guard wasnt found."));
+									}
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Compass was used, but the Guard wasnt found."));
+								}
+
+								if (item->GetSocket(0) >= 6)
+								{
+									ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u 0 0", (DWORD)GetVID());
+									ITEM_MANAGER::instance().RemoveItem(item);
+								}
+							}
+						}
+						break;
+#endif
+
+						case 27996: // 
+							item->SetCount(item->GetCount() - 1);
+							/*
+							if (GetSkillLevel(SKILL_CREATE_POISON))
+								AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE, 3, AFF_DRINK_POISON, 15 * 60, 0, true);
+							else
+							{
+								// 慕璲  50%  50% 賦 +2
+								if (number(0, 1))
+								{
+									if (GetHP() > 100)
+										PointChange(POINT_HP, -(GetHP() - 1));
+									else
+										Dead();
+								}
+								else
+									AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE, 2, AFF_DRINK_POISON, 15 * 60, 0, true);
+							}
+							*/
+							break;
+
+						case fishing::SHELLFISH_VNUM: // 
+							// 50  47990
+							// 30 
+							// 10  47992
+							// 7 청 47993
+							// 3  47994
+						{
+							item->SetCount(item->GetCount() - 1);
+
+							int r = number(1, 100);
+
+							if (r <= 50)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("  督求."));
+								AutoGiveItem(fishing::STONEPIECE_VNUM);
+							}
+							else
+							{
+								const int prob_table_euckr[] =
+								{
+									80, 90, 97
+								};
+
+								const int prob_table_gb2312[] =
+								{
+									95, 97, 99
+								};
+
+								const int* prob_table = !g_iUseLocale ? prob_table_euckr : prob_table_gb2312;
+
+								if (r <= prob_table[0])
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("   求."));
+								}
+								else if (r <= prob_table[1])
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 斂 督求."));
+									AutoGiveItem(fishing::WHITE_PEARL_VNUM);
+								}
+								else if (r <= prob_table[2])
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 청斂 督求."));
+									AutoGiveItem(fishing::BLUE_PEARL_VNUM);
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 斂 督求."));
+									AutoGiveItem(fishing::RED_PEARL_VNUM);
+								}
+							}
+						}
+						break;
+
+						case 71013: // 
+							CreateFly(number(FLY_FIREWORK1, FLY_FIREWORK6), this);
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case 50100: // 
+						case 50101:
+						case 50102:
+						case 50103:
+						case 50104:
+						case 50105:
+						case 50106:
+							CreateFly(item->GetVnum() - 50100 + FLY_FIREWORK1, this);
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case 50200: // 
+						{
+							if (LC_IsYMIR() == true || LC_IsKorea() == true)
+							{
+								if (IS_BOTARYABLE_ZONE(GetMapIndex()) == true)
+								{
+									__OpenPrivateShop();
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("     都求"));
+								}
+							}
+							else
+							{
+								__OpenPrivateShop();
+							}
+						}
+						break;
+
+						case fishing::FISH_MIND_PILL_VNUM:
+							AddAffect(AFFECT_FISH_MIND_PILL, POINT_NONE, 0, AFF_FISH_MIND, 20 * 60, 0, true);
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case 50301: // 囹 체
+						case 50302:
+						case 50303:
+						{
+							if (IsPolymorphed() == true)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("逵 傷  첩  求."));
+								return false;
+							}
+
+							int lv = GetSkillLevel(SKILL_LEADERSHIP);
+
+							if (lv < item->GetValue(0))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 책 賈  歐璲 求."));
+								return false;
+							}
+
+							if (lv >= item->GetValue(1))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 책 틜      駕求."));
+								return false;
+							}
+
+							if (LearnSkillByBook(SKILL_LEADERSHIP))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(SKILL_LEADERSHIP, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+
+						case 50304: //  체
+						case 50305:
+						case 50306:
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("傷 책  求."));
+								return false;
+							}
+
+							if (GetSkillLevel(SKILL_COMBO) == 0 && GetLevel() < 30)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 30 풉       駕求."));
+								return false;
+							}
+
+							if (GetSkillLevel(SKILL_COMBO) == 1 && GetLevel() < 50)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 50 풉       駕求."));
+								return false;
+							}
+
+							if (GetSkillLevel(SKILL_COMBO) >= 2)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鵑   求."));
+								return false;
+							}
+
+							int iPct = item->GetValue(0);
+
+							if (LearnSkillByBook(SKILL_COMBO, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(SKILL_COMBO, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+
+						case 50311: //  체
+						case 50312:
+						case 50313:
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("傷 책  求."));
+								return false;
+							}
+
+							DWORD dwSkillVnum = item->GetValue(0);
+							int iPct = MINMAX(0, item->GetValue(1), 100);
+							if (GetSkillLevel(dwSkillVnum) >= 20 || dwSkillVnum - SKILL_LANGUAGE1 + 1 == GetEmpire())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 瞿構 鱇틉  獵 甄."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+
+						case 50061: // 瞿  환 킬 체
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("傷 책  求."));
+								return false;
+							}
+
+							DWORD dwSkillVnum = item->GetValue(0);
+							int iPct = MINMAX(0, item->GetValue(1), 100);
+
+							if (GetSkillLevel(dwSkillVnum) >= 10)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鵑   求."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+
+						// LEARNABLE_SKILL_BOOKS_BY_LEVEL
+						case 50314: case 50315: case 50316: //  체
+						case 50325: // Book of Precision
+						{
+							if (IsPolymorphed() == true)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("逵 傷  첩  求."));
+								return false;
+							}
+
+							int iSkillLevelLowLimit = item->GetValue(0);
+							int iSkillLevelHighLimit = item->GetValue(1);
+							int iPct = MINMAX(0, item->GetValue(2), 100);
+							int iLevelLimit = item->GetValue(3);
+							DWORD dwSkillVnum = 0;
+
+							switch (item->GetVnum())
+							{
+								case 50314: case 50315: case 50316:
+									dwSkillVnum = SKILL_POLYMORPH;
+									break;
+
+#if defined(__CONQUEROR_LEVEL__)
+								case 50325: // Book of Precision
+									dwSkillVnum = SKILL_HIT;
+									break;
+#endif
+
+								default:
+									return false;
+							}
+
+							if (0 == dwSkillVnum)
+								return false;
+
+#if defined(__CONQUEROR_LEVEL__)
+							if (dwSkillVnum == SKILL_HIT && GetConquerorLevel() < iSkillLevelLowLimit)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 책    첨 爛求."));
+								return false;
+							}
+							else
+#endif
+							{
+								if (GetLevel() < iLevelLimit)
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 책    첨 爛求."));
+									return false;
+								}
+							}
+
+							if (GetSkillLevel(dwSkillVnum) >= 40)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鵑   求."));
+								return false;
+							}
+
+							if (GetSkillLevel(dwSkillVnum) < iSkillLevelLowLimit
+#if defined(__CONQUEROR_LEVEL__)
+								&& dwSkillVnum != SKILL_HIT
+#endif
+								)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 책 賈  歐璲 求."));
+								return false;
+							}
+
+							if (GetSkillLevel(dwSkillVnum) >= iSkillLevelHighLimit)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 책灌  鵑   求."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+						// END_LEARNABLE_SKILL_BOOKS_BY_LEVEL
+
+						// LEARNABLE_SKILL_BOOKS_BY_EXP
+#if defined(__PARTY_PROFICY__)
+						case 50338:	// Charisma of a Rookie
+						case 50339:	// Charisma of an Adept
+						case 50340:	// Charisma of an Expert
+#endif
+#if defined(__PARTY_INSIGHT__)
+						case 50341:	// Inspiration of a Rookie
+						case 50342:	// Inspiration of an Adept
+						case 50343:	// Inspiration of an Expert
+#endif
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("逵 傷  첩  求."));
+								return false;
+							}
+
+							int iSkillLevelLowLimit = item->GetValue(0);
+							int iSkillLevelHighLimit = item->GetValue(1);
+							int iPct = MINMAX(0, item->GetValue(2), 100);
+							int iNeedExp = item->GetValue(3);
+							DWORD dwSkillVnum = 0;
+
+							switch (item->GetVnum())
+							{
+#if defined(__PARTY_PROFICY__)
+								case 50338:	// Charisma of a Rookie
+								case 50339:	// Charisma of an Adept
+								case 50340:	// Charisma of an Expert
+									dwSkillVnum = SKILL_ROLE_PROFICIENCY;
+									break;
+#endif
+
+#if defined(__PARTY_INSIGHT__)
+								case 50341:	// Inspiration of a Rookie
+								case 50342:	// Inspiration of an Adept
+								case 50343:	// Inspiration of an Expert
+									dwSkillVnum = SKILL_INSIGHT;
+									break;
+#endif
+
+								default:
+									return false;
+							}
+
+							if (0 == dwSkillVnum)
+								return false;
+
+							if (GetExp() < static_cast<DWORD>(iNeedExp))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("치 臼 책   求."));
+								return false;
+							}
+
+							if (GetSkillLevel(dwSkillVnum) >= 40)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("   킬都求."));
+								return false;
+							}
+
+							if (GetSkillLevel(dwSkillVnum) < iSkillLevelLowLimit)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 책 賈  歐璲 求."));
+								return false;
+							}
+
+							if (GetSkillLevel(dwSkillVnum) >= iSkillLevelHighLimit)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 책灌  鵑   求."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								if (dwSkillVnum != SKILL_HIT)
+									PointChange(POINT_EXP, -iNeedExp);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server)
+									iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+						// END_LEARNABLE_SKILL_BOOKS_BY_EXP
+
+						case 50902:
+						case 50903:
+						case 50904:
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("傷 책  求."));
+								return false;
+							}
+
+							DWORD dwSkillVnum = SKILL_CREATE;
+							int iPct = MINMAX(0, item->GetValue(1), 100);
+
+							if (GetSkillLevel(dwSkillVnum) >= 40)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鵑   求."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+
+								if (test_server)
+								{
+									ChatPacket(CHAT_TYPE_INFO, "[TEST_SERVER] Success to learn skill ");
+								}
+							}
+							else
+							{
+								if (test_server)
+								{
+									ChatPacket(CHAT_TYPE_INFO, "[TEST_SERVER] Failed to learn skill ");
+								}
+							}
+						}
+						break;
+
+						// MINING
+						case ITEM_MINING_SKILL_TRAIN_BOOK:
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("傷 책  求."));
+								return false;
+							}
+
+							DWORD dwSkillVnum = SKILL_MINING;
+							int iPct = MINMAX(0, item->GetValue(1), 100);
+
+							if (GetSkillLevel(dwSkillVnum) >= 40)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鵑   求."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+						// END_OF_MINING
+
+						case ITEM_HORSE_SKILL_TRAIN_BOOK:
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("傷 책  求."));
+								return false;
+							}
+
+							DWORD dwSkillVnum = SKILL_HORSE;
+							int iPct = MINMAX(0, item->GetValue(1), 100);
+
+							if (GetLevel() < 50)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 쨍 킬   獵  틈爛求."));
+								return false;
+							}
+
+							if (!test_server && get_global_time() < GetSkillNextReadTime(dwSkillVnum))
+							{
+								if (FindAffect(AFFECT_SKILL_NO_BOOK_DELAY))
+								{
+									// 羚횝 傷 챨  
+									RemoveAffect(AFFECT_SKILL_NO_BOOK_DELAY);
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("羚횝  화毒 督求."));
+								}
+								else
+								{
+									SkillLearnWaitMoreTimeMessage(GetSkillNextReadTime(dwSkillVnum) - get_global_time());
+									return false;
+								}
+							}
+
+							if (GetPoint(POINT_HORSE_SKILL) >= 20 ||
+								GetSkillLevel(SKILL_HORSE_WILDATTACK) + GetSkillLevel(SKILL_HORSE_CHARGE) + GetSkillLevel(SKILL_HORSE_ESCAPE) >= 60 ||
+								GetSkillLevel(SKILL_HORSE_WILDATTACK_RANGE) + GetSkillLevel(SKILL_HORSE_CHARGE) + GetSkillLevel(SKILL_HORSE_ESCAPE) >= 60)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鵑 쨍 체   求."));
+								return false;
+							}
+
+							if (number(1, 100) <= iPct)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("쨍 체 棘 쨍 킬 트 求."));
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 트灌 쨍 킬  첩  笭求."));
+								PointChange(POINT_HORSE_SKILL, 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								if (!test_server)
+									SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("쨍 체 萬 臼求."));
+							}
+
+							ITEM_MANAGER::instance().RemoveItem(item);
+						}
+						break;
+
+						case 70102: // 
+						case 70103: // 
+						{
+							if (GetAlignment() >= 0)
+								return false;
+
+							int delta = MIN(-GetAlignment(), item->GetValue(0));
+
+							sys_log(0, "%s ALIGNMENT ITEM %d", GetName(), delta);
+
+							UpdateAlignment(delta);
+							item->SetCount(item->GetCount() - 1);
+
+							if (delta / 10 > 0)
+							{
+								ChatPacket(CHAT_TYPE_TALKING, LC_STRING(" 짹.   臍“   潔."));
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("치 %d 臼求.", delta / 10));
+							}
+						}
+						break;
+
+						case 71107: // 천
+						case 39032:
+						{
+							quest::CQuestManager& q = quest::CQuestManager::Instance();
+							quest::PC* pPC = q.GetPC(GetPlayerID());
+							if (pPC)
+							{
+								int val = item->GetValue(0);
+								int interval = item->GetValue(1);
+								int last_use_time = pPC->GetFlag("mythical_peach.last_use_time");
+								if (get_global_time() - last_use_time < interval * 60 * 60)
+								{
+									if (test_server == false)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("   求."));
+										return false;
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("謬트  챨 "));
+									}
+								}
+
+								if (GetAlignment() == 200000)
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("치  鵑 첩  求."));
+									return false;
+								}
+
+								if (200000 - GetAlignment() < val * 10)
+								{
+									val = (200000 - GetAlignment()) / 10;
+								}
+
+								int old_alignment = GetAlignment() / 10;
+
+								UpdateAlignment(val * 10);
+
+								item->SetCount(item->GetCount() - 1);
+								pPC->SetFlag("mythical_peach.last_use_time", get_global_time());
+
+								ChatPacket(CHAT_TYPE_TALKING, LC_STRING(" 짹.   臍“   潔."));
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("치 %d 臼求.", val));
+
+								char buf[256 + 1];
+								snprintf(buf, sizeof(buf), "%d %d", old_alignment, GetAlignment() / 10);
+								LogManager::instance().CharLog(this, val, "MYTHICAL_PEACH", buf);
+							}
+						}
+						break;
+
+						case 71109: // 탈
+						case 39033:
+						{
+							LPITEM item2;
+
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item2->IsExchanging() || item2->IsEquipped())
+								return false;
+
+							if (item2->GetSocketCount() == 0)
+								return false;
+
+							switch (item2->GetType())
+							{
+								case ITEM_WEAPON:
+									break;
+
+								case ITEM_ARMOR:
+									switch (item2->GetSubType())
+									{
+										case ARMOR_EAR:
+										case ARMOR_WRIST:
+										case ARMOR_NECK:
+											ChatPacket(CHAT_TYPE_INFO, LC_STRING("  求"));
+											return false;
+									}
+									break;
+
+								default:
+									return false;
+							}
+
+							std::stack<long> socket;
+
+							for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+							{
+#if defined(__GLOVE_SYSTEM__)
+								DWORD dwSocketData = item2->GetSocket(i);
+								if (item2->IsGlove() && dwSocketData >= 1000000 && dwSocketData != ITEM_BROKEN_METIN_VNUM)
+								{
+									DWORD dwBaseIndex = 28046;
+									dwBaseIndex += (((dwSocketData / 1000) % 10) * 100);
+									dwBaseIndex += ((dwSocketData / 100) % 10) - 1;
+
+									const TItemTable* pItemData = ITEM_MANAGER::instance().GetTable(dwBaseIndex);
+									if (pItemData == nullptr)
+										continue;
+
+									dwSocketData = dwBaseIndex;
+								}
+								socket.push(dwSocketData);
+#else
+								socket.push(item2->GetSocket(i));
+#endif
+							}
+
+							int idx = METIN_SOCKET_MAX_NUM - 1;
+
+							while (socket.size() > 0)
+							{
+								if (socket.top() > 2 && socket.top() != ITEM_BROKEN_METIN_VNUM)
+									break;
+
+								idx--;
+								socket.pop();
+							}
+
+							if (socket.size() == 0)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("  求"));
+								return false;
+							}
+
+							LPITEM pItemReward = AutoGiveItem(socket.top());
+							if (pItemReward != NULL)
+							{
+								item2->SetSocket(idx, 1);
+
+								char buf[256 + 1];
+								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
+									item2->GetName(), item2->GetID(), pItemReward->GetName(), pItemReward->GetID());
+								LogManager::instance().ItemLog(this, item, "USE_DETACHMENT_ONE", buf);
+
+								item->SetCount(item->GetCount() - 1);
+							}
+						}
+						break;
+
+						case 70201: // 탈
+						case 70202: // ()
+						case 70203: // (部)
+						case 70204: // ()
+						case 70205: // ()
+						case 70206: // ()
+						{
+							// NEW_HAIR_STYLE_ADD
+							if (GetPart(PART_HAIR) >= 1001)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 抵뵀먀  탈 柰爛求."));
+							}
+							// END_NEW_HAIR_STYLE_ADD
+							else
+							{
+								quest::CQuestManager& q = quest::CQuestManager::instance();
+								quest::PC* pPC = q.GetPC(GetPlayerID());
+								if (pPC)
+								{
+									int last_dye_level = pPC->GetFlag("dyeing_hair.last_dye_level");
+
+									if (last_dye_level == 0 ||
+										last_dye_level + 3 <= GetLevel() ||
+										item->GetVnum() == 70201)
+									{
+										SetPart(PART_HAIR, item->GetVnum() - 70201);
+
+										if (item->GetVnum() == 70201)
+											pPC->SetFlag("dyeing_hair.last_dye_level", 0);
+										else
+											pPC->SetFlag("dyeing_hair.last_dye_level", GetLevel());
+
+										item->SetCount(item->GetCount() - 1);
+										UpdatePacket();
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d  퓸 母 絿  笭求.", last_dye_level + 3));
+									}
+								}
+							}
+						}
+						break;
+
+						case ITEM_NEW_YEAR_GREETING_VNUM:
+						{
+							if (GiveItemFromSpecialItemGroup(ITEM_NEW_YEAR_GREETING_VNUM))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_VALENTINE_ROSE:
+						case ITEM_VALENTINE_CHOCOLATE:
+						{
+							if (item->GetVnum() == ITEM_VALENTINE_ROSE && SEX_MALE == GET_SEX(this) ||
+								item->GetVnum() == ITEM_VALENTINE_CHOCOLATE && SEX_FEMALE == GET_SEX(this))
+							{
+								//  刻   .
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 刻     求."));
+								return false;
+							}
+
+							if (GiveItemFromSpecialItemGroup(item->GetVnum()))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_WHITEDAY_CANDY:
+						case ITEM_WHITEDAY_ROSE:
+						{
+							if (item->GetVnum() == ITEM_WHITEDAY_CANDY && SEX_MALE == GET_SEX(this) ||
+								item->GetVnum() == ITEM_WHITEDAY_ROSE && SEX_FEMALE == GET_SEX(this))
+							{
+								//  刻   .
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 刻     求."));
+								return false;
+							}
+
+							if (GiveItemFromSpecialItemGroup(item->GetVnum()))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case 50011: // 
+						{
+							if (!GiveItemFromSpecialItemGroup(50011))
+							{
+								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("틜孤   求."));
+								return false;
+							}
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_GIVE_STAT_RESET_COUNT_VNUM:
+						{
+							//PointChange(POINT_GOLD, -iCost);
+							PointChange(POINT_STAT_RESET_COUNT, 1);
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case 50107:
+						{
+							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 傷 結   품都求."));
+								return false;
+							}
+
+							EffectPacket(SE_CHINA_FIREWORK);
+							//   첨娩
+							AddAffect(AFFECT_CHINA_FIREWORK, POINT_STUN_PCT, 30, AFF_CHINA_FIREWORK, 5 * 60, 0, true);
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case 50108:
+						{
+							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 傷 結   품都求."));
+								return false;
+							}
+
+							EffectPacket(SE_SPIN_TOP);
+							//   첨娩
+							AddAffect(AFFECT_CHINA_FIREWORK, POINT_STUN_PCT, 30, AFF_CHINA_FIREWORK, 5 * 60, 0, true);
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_WONSO_BEAN_VNUM:
+							PointChange(POINT_HP, GetMaxHP() - GetHP());
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case ITEM_WONSO_SUGAR_VNUM:
+							PointChange(POINT_SP, GetMaxSP() - GetSP());
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case ITEM_WONSO_FRUIT_VNUM:
+							PointChange(POINT_STAMINA, GetMaxStamina() - GetStamina());
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case ITEM_ELK_VNUM: // 慕
+						{
+							int iGold = item->GetSocket(0);
+							ITEM_MANAGER::instance().RemoveItem(item);
+							PointChange(POINT_GOLD, iGold);
+						}
+						break;
+
+						//  표
+						case 70021:
+						{
+							int HealPrice = quest::CQuestManager::instance().GetEventFlag("MonarchHealGold");
+							if (HealPrice == 0)
+								HealPrice = 2000000;
+
+							if (CMonarch::instance().HealMyEmpire(this, HealPrice))
+							{
+								char szNotice[256];
+								snprintf(szNotice, sizeof(szNotice), LC_STRING(" 僊  %s  HP,SP  채求.", EMPIRE_NAME(GetEmpire())));
+								SendNoticeMap(szNotice, GetMapIndex(), false);
+
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 僊 臼求."));
+							}
+						}
+						break;
+
+						case 27995:
+						{
+						}
+						break;
+
+						case 71092: //  체 擔
+						{
+							if (m_pkChrTarget != NULL)
+							{
+								if (m_pkChrTarget->IsPolymorphed())
+								{
+									m_pkChrTarget->SetPolymorph(0);
+									m_pkChrTarget->RemoveAffect(AFFECT_POLYMORPH);
+								}
+							}
+							else
+							{
+								if (IsPolymorphed())
+								{
+									SetPolymorph(0);
+									RemoveAffect(AFFECT_POLYMORPH);
+								}
+							}
+						}
+						break;
+
+						case 71051: // 怜
+						{
+							LPITEM item2;
+
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetInventoryItem(wDestCell)))
+								return false;
+
+							if (item2->IsExchanging())
+								return false;
+
+							if (item2->IsEquipped())
+								return false;
+
+							if (item2->GetType() == ITEM_COSTUME)
+								return false;
+
+							//if (item2->GetAttributeCount() < 5)
+							//	return false;
+
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺    都求."));
+								return false;
+							}
+
+							if (item2->AddRareAttribute() == true)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 煞 臼求."));
+
+								int iAddedIdx = item2->GetRareAttrCount() + 4;
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+
+								LogManager::instance().ItemLog(
+									GetPlayerID(),
+									item2->GetAttributeType(iAddedIdx),
+									item2->GetAttributeValue(iAddedIdx),
+									item->GetID(),
+									"ADD_RARE_ATTR",
+									buf,
+									GetDesc()->GetHostName(),
+									item->GetOriginalVnum());
+
+								if (!g_bUnlimitedAddRareAttributes)
+									item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 煞 臼求."));
+							}
+						}
+						break;
+
+						case 71052: // 
+						{
+							LPITEM item2;
+
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item2->IsEquipped())
+								return false;
+
+							if (item2->GetType() == ITEM_COSTUME)
+								return false;
+
+							if (item2->IsExchanging() == true)
+								return false;
+
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺    都求."));
+								return false;
+							}
+
+							if (item2->ChangeRareAttribute() == true)
+							{
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+								LogManager::instance().ItemLog(this, item, "CHANGE_RARE_ATTR", buf);
+
+								if (!g_bUnlimitedChangeRareAttributes)
+									item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 臼求."));
+							}
+						}
+						break;
+
+						case ITEM_AUTO_HP_RECOVERY_S:
+						case ITEM_AUTO_HP_RECOVERY_M:
+						case ITEM_AUTO_HP_RECOVERY_L:
+						case ITEM_AUTO_HP_RECOVERY_X:
+						case ITEM_AUTO_SP_RECOVERY_S:
+						case ITEM_AUTO_SP_RECOVERY_M:
+						case ITEM_AUTO_SP_RECOVERY_L:
+						case ITEM_AUTO_SP_RECOVERY_X:
+							// 첫  求  치 ...
+							// 瀏 柳 溝 湄.  悶 湄 滂.
+						case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
+						case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
+						case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
+						case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
+						{
+							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("恙 絿  求."));
+								return false;
+							}
+
+							EAffectTypes type = AFFECT_NONE;
+							bool isSpecialPotion = false;
+
+							switch (item->GetVnum())
+							{
+								case ITEM_AUTO_HP_RECOVERY_X:
+									isSpecialPotion = true;
+
+								case ITEM_AUTO_HP_RECOVERY_S:
+								case ITEM_AUTO_HP_RECOVERY_M:
+								case ITEM_AUTO_HP_RECOVERY_L:
+								case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
+								case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
+									type = AFFECT_AUTO_HP_RECOVERY;
+									break;
+
+								case ITEM_AUTO_SP_RECOVERY_X:
+									isSpecialPotion = true;
+
+								case ITEM_AUTO_SP_RECOVERY_S:
+								case ITEM_AUTO_SP_RECOVERY_M:
+								case ITEM_AUTO_SP_RECOVERY_L:
+								case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
+								case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
+									type = AFFECT_AUTO_SP_RECOVERY;
+									break;
+							}
+
+							if (AFFECT_NONE == type)
+								break;
+
+							if (item->GetCount() > 1)
+							{
+								int pos = GetEmptyInventory(item->GetSize());
+
+								if (-1 == pos)
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("품   求."));
+									break;
+								}
+
+								item->SetCount(item->GetCount() - 1);
+
+								LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), 1);
+								item2->AddToCharacter(this, TItemPos(INVENTORY, pos));
+
+								if (item->GetSocket(1) != 0)
+								{
+									item2->SetSocket(1, item->GetSocket(1));
+								}
+
+								item = item2;
+							}
+
+							CAffect* pAffect = FindAffect(type);
+
+							if (NULL == pAffect)
+							{
+								EPointTypes bonus = POINT_NONE;
+
+								if (true == isSpecialPotion)
+								{
+									if (type == AFFECT_AUTO_HP_RECOVERY)
+									{
+										bonus = POINT_MAX_HP_PCT;
+									}
+									else if (type == AFFECT_AUTO_SP_RECOVERY)
+									{
+										bonus = POINT_MAX_SP_PCT;
+									}
+								}
+
+								AddAffect(type, bonus, 4, item->GetID(), INFINITE_AFFECT_DURATION, 0, true, false);
+
+								item->Lock(true);
+								item->SetSocket(0, true);
+
+								AutoRecoveryItemProcess(type);
+							}
+							else
+							{
+								if (item->GetID() == pAffect->dwFlag)
+								{
+									RemoveAffect(pAffect);
+
+									item->Lock(false);
+									item->SetSocket(0, false);
+								}
+								else
+								{
+									LPITEM old = FindItemByID(pAffect->dwFlag);
+
+									if (NULL != old)
+									{
+										old->Lock(false);
+										old->SetSocket(0, false);
+									}
+
+									RemoveAffect(pAffect);
+
+									EPointTypes bonus = POINT_NONE;
+
+									if (true == isSpecialPotion)
+									{
+										if (type == AFFECT_AUTO_HP_RECOVERY)
+										{
+											bonus = POINT_MAX_HP_PCT;
+										}
+										else if (type == AFFECT_AUTO_SP_RECOVERY)
+										{
+											bonus = POINT_MAX_SP_PCT;
+										}
+									}
+
+									AddAffect(type, bonus, 4, item->GetID(), INFINITE_AFFECT_DURATION, 0, true, false);
+
+									item->Lock(true);
+									item->SetSocket(0, true);
+
+									AutoRecoveryItemProcess(type);
+								}
+							}
+						}
+						break;
+					}
+				}
+				break;
+
+				case USE_CLEAR:
+				{
+					switch (item->GetVnum())
+					{
+						case 27124: // Bandage
+							RemoveBleeding();
+							break;
+
+						case 27874: // Grilled Perch
+							RemoveBadAffect();
+							break;
+					}
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case USE_INVISIBILITY:
+				{
+					if (item->GetVnum() == 70026)
+					{
+						quest::CQuestManager& q = quest::CQuestManager::instance();
+						quest::PC* pPC = q.GetPC(GetPlayerID());
+
+						if (pPC != NULL)
+						{
+							int last_use_time = pPC->GetFlag("mirror_of_disapper.last_use_time");
+
+							if (get_global_time() - last_use_time < 10 * 60)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("   求."));
+								return false;
+							}
+
+							pPC->SetFlag("mirror_of_disapper.last_use_time", get_global_time());
+						}
+					}
+
+					AddAffect(AFFECT_INVISIBILITY, POINT_NONE, 0, AFF_INVISIBILITY, 300, 0, true);
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case USE_POTION_NODELAY:
+				{
+					if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+					{
+						if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("恙 絿  求."));
+							return false;
+						}
+
+						switch (item->GetVnum())
+						{
+							case 70020:
+							case 71018:
+							case 71019:
+							case 71020:
+							{
+								if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
+								{
+									if (m_nPotionLimit <= 0)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 祈 歌臼求."));
+										return false;
+									}
+								}
+							}
+							break;
+
+							default:
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("恙 絿  求."));
+								return false;
+						}
+					}
+
+					bool bUsed = false;
+
+					if (item->GetValue(0) != 0) // HP 諛 회
+					{
+						if (GetHP() < GetMaxHP())
+						{
+							PointChange(POINT_HP, item->GetValue(0) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
+							EffectPacket(SE_HPUP_RED);
+							bUsed = true;
+						}
+					}
+
+					if (item->GetValue(1) != 0) // SP 諛 회
+					{
+						if (GetSP() < GetMaxSP())
+						{
+							PointChange(POINT_SP, item->GetValue(1) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
+							EffectPacket(SE_SPUP_BLUE);
+							bUsed = true;
+						}
+					}
+
+					if (item->GetValue(3) != 0) // HP % 회
+					{
+						if (GetHP() < GetMaxHP())
+						{
+							PointChange(POINT_HP, item->GetValue(3) * GetMaxHP() / 100);
+							EffectPacket(SE_HPUP_RED);
+							bUsed = true;
+						}
+					}
+
+					if (item->GetValue(4) != 0) // SP % 회
+					{
+						if (GetSP() < GetMaxSP())
+						{
+							PointChange(POINT_SP, item->GetValue(4) * GetMaxSP() / 100);
+							EffectPacket(SE_SPUP_BLUE);
+							bUsed = true;
+						}
+					}
+
+					if (bUsed)
+					{
+						if (item->GetVnum() == 50085 || item->GetVnum() == 50086)
+						{
+							if (test_server)
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 풔   臼求"));
+
+							SetUseSeedOrMoonBottleTime();
+						}
+
+						if (GetDungeon())
+							GetDungeon()->UsePotion(this);
+
+						if (GetWarMap())
+							GetWarMap()->UsePotion(this, item);
+
+						m_nPotionLimit--;
+
+						// RESTRICT_USE_SEED_OR_MOONBOTTLE
+						item->SetCount(item->GetCount() - 1);
+						// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
+					}
+				}
+				break;
+
+				case USE_POTION:
+				{
+					if (CArenaManager::instance().IsArenaMap(GetMapIndex()) == true)
+					{
+						if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("恙 絿  求."));
+							return false;
+						}
+
+						switch (item->GetVnum())
+						{
+							case 27001: // Red Potion (S)
+							case 27002: // Red Potion (M)
+							case 27003: // Red Potion (L)
+							case 27007: // Red Potion (XXL)
+							case 27004: // Blue Potion (S)
+							case 27005: // Blue Potion (M)
+							case 27006: // Blue Potion (L)
+							case 27008: // Red Potion (XXL)
+							{
+								if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
+								{
+									if (m_nPotionLimit <= 0)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 祈 歌臼求."));
+										return false;
+									}
+								}
+							}
+							break;
+
+							default:
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("恙 絿  求."));
+								return false;
+						}
+					}
+
+					if (item->GetValue(1) != 0)
+					{
+						if (GetPoint(POINT_SP_RECOVERY) + GetSP() >= GetMaxSP())
+							return false;
+
+						PointChange(POINT_SP_RECOVERY, item->GetValue(1) * MIN(200, (100 + GetPoint(POINT_POTION_BONUS))) / 100);
+						StartAffectEvent();
+						EffectPacket(SE_SPUP_BLUE);
+					}
+
+					if (item->GetValue(0) != 0)
+					{
+						if (GetPoint(POINT_HP_RECOVERY) + GetHP() >= GetMaxHP())
+							return false;
+
+						PointChange(POINT_HP_RECOVERY, item->GetValue(0) * MIN(200, (100 + GetPoint(POINT_POTION_BONUS))) / 100);
+						StartAffectEvent();
+						EffectPacket(SE_HPUP_RED);
+					}
+
+					if (GetDungeon())
+						GetDungeon()->UsePotion(this);
+
+					if (GetWarMap())
+						GetWarMap()->UsePotion(this, item);
+
+					item->SetCount(item->GetCount() - 1);
+					m_nPotionLimit--;
+				}
+				break;
+
+				case USE_POTION_CONTINUE:
+				{
+					if (item->GetValue(0) != 0)
+						AddAffect(AFFECT_HP_RECOVER_CONTINUE, POINT_HP_RECOVER_CONTINUE, item->GetValue(0), 0, item->GetValue(2), 0, true);
+					else if (item->GetValue(1) != 0)
+						AddAffect(AFFECT_SP_RECOVER_CONTINUE, POINT_SP_RECOVER_CONTINUE, item->GetValue(1), 0, item->GetValue(2), 0, true);
+					else
+						return false;
+
+					if (GetDungeon())
+						GetDungeon()->UsePotion(this);
+
+					if (GetWarMap())
+						GetWarMap()->UsePotion(this, item);
+
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case USE_ABILITY_UP:
+				{
+					if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+						return false;
+					}
+
+					switch (item->GetValue(0))
+					{
+						case APPLY_MOV_SPEED:
+						{
+							VERIFY_POTION(AFFECT_MOV_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_MOV_SPEED, POINT_MOV_SPEED, item->GetValue(2), AFF_MOV_SPEED_POTION, item->GetValue(1), 0, true);
+							EffectPacket(SE_DXUP_PURPLE);
+						}
+						break;
+
+						case APPLY_ATT_SPEED:
+						{
+							VERIFY_POTION(AFFECT_ATT_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_ATT_SPEED, POINT_ATT_SPEED, item->GetValue(2), AFF_ATT_SPEED_POTION, item->GetValue(1), 0, true);
+							EffectPacket(SE_SPEEDUP_GREEN);
+						}
+						break;
+
+						case APPLY_STR:
+						{
+							VERIFY_POTION(AFFECT_STR, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_STR, POINT_ST, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_DEX:
+						{
+							VERIFY_POTION(AFFECT_DEX, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_DEX, POINT_DX, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_CON:
+						{
+							VERIFY_POTION(AFFECT_CON, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_CON, POINT_HT, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_INT:
+						{
+							VERIFY_POTION(AFFECT_INT, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_INT, POINT_IQ, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_CAST_SPEED:
+						{
+							VERIFY_POTION(AFFECT_CAST_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_CAST_SPEED, POINT_CASTING_SPEED, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_ATT_GRADE_BONUS:
+						{
+							VERIFY_POTION(AFFECT_ATT_GRADE, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE_BONUS, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_DEF_GRADE_BONUS:
+						{
+							VERIFY_POTION(AFFECT_DEF_GRADE, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_DEF_GRADE, POINT_DEF_GRADE_BONUS, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_RESIST_MAGIC:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_MAGIC, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+#if defined(__CONQUEROR_LEVEL__)
+						case APPLY_SUNGMA_STR:
+						{
+							VERIFY_POTION(AFFECT_SUNGMA_STR, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_SUNGMA_STR, POINT_SUNGMA_STR, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_SUNGMA_HP:
+						{
+							VERIFY_POTION(AFFECT_SUNGMA_HP, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_SUNGMA_HP, POINT_SUNGMA_HP, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_SUNGMA_MOVE:
+						{
+							VERIFY_POTION(AFFECT_SUNGMA_MOVE, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_SUNGMA_MOVE, POINT_SUNGMA_MOVE, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_SUNGMA_IMMUNE:
+						{
+							VERIFY_POTION(AFFECT_SUNGMA_IMMUNE, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_SUNGMA_IMMUNE, POINT_SUNGMA_IMMUNE, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+#endif
+
+						case APPLY_ATTBONUS_MONSTER:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATTBONUS_MONSTER, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+						case APPLY_MALL_EXPBONUS:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MALL_EXPBONUS, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+						case APPLY_MELEE_MAGIC_ATTBONUS_PER:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MELEE_MAGIC_ATT_BONUS_PER, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+						case APPLY_RESIST_ICE:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_ICE, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+						case APPLY_RESIST_EARTH:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_EARTH, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+						case APPLY_RESIST_DARK:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_DARK, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+					}
+
+					if (GetDungeon())
+						GetDungeon()->UsePotion(this);
+
+					if (GetWarMap())
+						GetWarMap()->UsePotion(this, item);
+
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case USE_TALISMAN:
+				{
+					const int TOWN_PORTAL = 1;
+					const int MEMORY_PORTAL = 2;
+
+					// gm_guild_build, oxevent 却 환 환  構 
+					if (GetMapIndex() == 200 || GetMapIndex() == 113)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 치   求."));
+						return false;
+					}
+
+					if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 傷 結   품都求."));
+						return false;
+					}
+
+					if (m_pkWarpEvent)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("絹 曼 퓸 환罐 寗 求"));
+						return false;
+					}
+
+					// CONSUME_LIFE_WHEN_USE_WARP_ITEM
+					int consumeLife = CalculateConsume(this);
+
+					if (consumeLife < 0)
+						return false;
+					// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
+
+					if (item->GetValue(0) == TOWN_PORTAL) // 환
+					{
+						if (item->GetSocket(0) == 0)
+						{
+							if (!GetDungeon())
+								if (!GiveRecallItem(item))
+									return false;
+
+							PIXEL_POSITION posWarp;
+
+							if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(GetMapIndex(), GetEmpire(), posWarp))
+							{
+								// CONSUME_LIFE_WHEN_USE_WARP_ITEM
+								PointChange(POINT_HP, -consumeLife, false);
+								// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
+
+								WarpSet(posWarp.x, posWarp.y);
+							}
+							else
+							{
+								sys_err("CHARACTER::UseItem : cannot find spawn position (name %s, %d x %d)", GetName(), GetX(), GetY());
+							}
+						}
+						else
+						{
+							if (test_server)
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 치 "));
+
+							ProcessRecallItem(item);
+						}
+					}
+					else if (item->GetValue(0) == MEMORY_PORTAL) // 환
+					{
+						if (item->GetSocket(0) == 0)
+						{
+							if (GetDungeon())
+							{
+								const char* c_szConv = (g_iUseLocale ? "" : (under_han(item->GetName()) ? LC_STRING("") : LC_STRING("")));
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 효 %s%s   求.", LC_ITEM(item->GetVnum()), c_szConv));
+								return false;
+							}
+
+							if (!GiveRecallItem(item))
+								return false;
+						}
+						else
+						{
+							// CONSUME_LIFE_WHEN_USE_WARP_ITEM
+							PointChange(POINT_HP, -consumeLife, false);
+							// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
+
+							ProcessRecallItem(item);
+						}
+					}
+				}
+				break;
+
+				case USE_TUNING:
+				case USE_DETACHMENT:
+				{
+					LPITEM item2;
+
+					if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+						return false;
+
+					if (item2->IsEquipped())
+						return false;
+
+					if (item2->IsExchanging())
+						return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+					if (item2->IsSealed())
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot improve a soulbound item."));
+						return false;
+					}
+#endif
+
+					if (PreventTradeWindow(WND_ALL))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("창,킹창  쩔  寗 求"));
+						return false;
+					}
+
+					RefineItem(item, item2);
+				}
+				break;
+
+				// ACCESSORY_REFINE & ADD/CHANGE_ATTRIBUTES
+				case USE_PUT_INTO_BELT_SOCKET:
+				case USE_PUT_INTO_RING_SOCKET:
+				case USE_PUT_INTO_ACCESSORY_SOCKET:
+				case USE_ADD_ACCESSORY_SOCKET:
+				case USE_CLEAN_SOCKET:
+				case USE_CHANGE_ATTRIBUTE:
+#if defined(__ATTR_6TH_7TH__)
+				case USE_CHANGE_ATTRIBUTE2:
+#endif
+				case USE_ADD_ATTRIBUTE:
+				case USE_ADD_ATTRIBUTE2:
+#if defined(__MOVE_COSTUME_ATTR__)
+				case USE_RESET_COSTUME_ATTR:
+				case USE_CHANGE_COSTUME_ATTR:
+#endif
+#if defined(__CHANGED_ATTR__)
+				case USE_SELECT_ATTRIBUTE:
+#endif
+				{
+					LPITEM item2;
+					if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+						return false;
+
+					if (item2->IsEquipped())
+					{
+						BuffOnAttr_RemoveBuffsFromItem(item2);
+					}
+
+					// [NOTE] 黴튬 謗     憺 恝溝, 怜  틈牝 청 羚.
+					//  ANTI_CHANGE_ATTRIBUTE   Flag 煞臼 획  構 트   令  潔
+					// 流 却 치  娩玭 柳 茱 ... -_-
+					/*
+					if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_CHANGE_ATTRIBUTE) && !item->IsSocketModifyingItem())
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the upgrade of this item."));
+						return false;
+					}
+					*/
+
+					if (ITEM_COSTUME == item2->GetType()
+#if defined(__MOVE_COSTUME_ATTR__)	
+						&& item->GetSubType() != USE_RESET_COSTUME_ATTR && item->GetSubType() != USE_CHANGE_COSTUME_ATTR
+#endif
+#if defined(__CHANGED_ATTR__)
+						&& item->GetSubType() != USE_SELECT_ATTRIBUTE
+#endif
+						)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺    都求."));
+						return false;
+					}
+
+					if (item2->IsExchanging() || item2->IsEquipped())
+						return false;
+
+					switch (item->GetSubType())
+					{
+						case USE_CLEAN_SOCKET:
+						{
+							int i;
+							for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+							{
+								if (item2->GetSocket(i) == ITEM_BROKEN_METIN_VNUM)
+									break;
+							}
+
+							if (i == METIN_SOCKET_MAX_NUM)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("청   駕求."));
+								return false;
+							}
+
+							int j = 0;
+
+							for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+							{
+								if (item2->GetSocket(i) != ITEM_BROKEN_METIN_VNUM && item2->GetSocket(i) != 0)
+									item2->SetSocket(j++, item2->GetSocket(i));
+							}
+
+							for (; j < METIN_SOCKET_MAX_NUM; ++j)
+							{
+								if (item2->GetSocket(j) > 0)
+									item2->SetSocket(j, 1);
+							}
+
+							{
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+								LogManager::instance().ItemLog(this, item, "CLEAN_SOCKET", buf);
+							}
+
+							if (!g_bUnlimitedCleanSocket)
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case USE_CHANGE_ATTRIBUTE:
+						{
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
+								return false;
+							}
+#endif
+
+							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_ENCHANT))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Enchant Item cannot be used on this item."));
+								return false;
+							}
+
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺    都求."));
+								return false;
+							}
+
+							if (item2->GetAttributeCount() == 0)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 憺 求."));
+								return false;
+							}
+
+							if (g_bChangeItemAttrCycle)
+							{
+								if (GM_PLAYER == GetGMLevel() && false == test_server)
+								{
+									//
+									// Event Flag     憺   챨   챨 洹 講構
+									// 챨  洹뛰  憺嚥  챨  娩.
+									//
+
+									DWORD dwChangeItemAttrCycle = quest::CQuestManager::instance().GetEventFlag(msc_szChangeItemAttrCycleFlag);
+									if (dwChangeItemAttrCycle < msc_dwDefaultChangeItemAttrCycle)
+										dwChangeItemAttrCycle = msc_dwDefaultChangeItemAttrCycle;
+
+									quest::PC* pPC = quest::CQuestManager::instance().GetPC(GetPlayerID());
+
+									if (pPC)
+									{
+										DWORD dwNowMin = get_global_time() / 60;
+
+										DWORD dwLastChangeItemAttrMin = pPC->GetFlag(msc_szLastChangeItemAttrFlag);
+
+										if (dwLastChangeItemAttrMin + dwChangeItemAttrCycle > dwNowMin)
+										{
+											ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 侮 %d 犬 母   求.(%d  )",
+												dwChangeItemAttrCycle, dwChangeItemAttrCycle - (dwNowMin - dwLastChangeItemAttrMin)));
+											return false;
+										}
+
+										pPC->SetFlag(msc_szLastChangeItemAttrFlag, dwNowMin);
+									}
+								}
+							}
+
+							if (item->GetVnum() == 76014)
+							{
+								int aiChangeProb[ITEM_ATTRIBUTE_MAX_LEVEL] =
+								{
+									0, 10, 50, 39, 1
+								};
+
+								item2->ChangeAttribute(aiChangeProb);
+							}
+							else
+							{
+								//  특처
+								//  怜 煞 홴거 臼 溝 湄.
+								if (item->GetVnum() == 71151 || item->GetVnum() == 76023)
+								{
+									if ((item2->GetType() == ITEM_WEAPON) || (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY))
+									{
+										bool bCanUse = true;
+										for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+										{
+											if (item2->GetLimitType(i) == LIMIT_LEVEL && item2->GetLimitValue(i) > 40)
+											{
+												bCanUse = false;
+												break;
+											}
+										}
+										if (false == bCanUse)
+										{
+											ChatPacket(CHAT_TYPE_INFO, LC_STRING("    柰爛求."));
+											break;
+										}
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 却  爛求."));
+										break;
+									}
+								}
+								item2->ChangeAttribute();
+							}
+
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 臼求."));
+							{
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+								LogManager::instance().ItemLog(this, item, "CHANGE_ATTRIBUTE", buf);
+							}
+
+							if (!g_bUnlimitedChangeAttributes)
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case USE_ADD_ATTRIBUTE:
+						{
+							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_REINFORCE))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Reinforce Item cannot be used on this item."));
+								return false;
+							}
+
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺    都求."));
+								return false;
+							}
+
+							if (item2->GetAttributeCount() < 4)
+							{
+								// 怜 특처
+								//  怜 煞 홴거 臼 溝 湄.
+								if (item->GetVnum() == 71152 || item->GetVnum() == 76024)
+								{
+									if ((item2->GetType() == ITEM_WEAPON) || (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY))
+									{
+										bool bCanUse = true;
+										for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+										{
+											if (item2->GetLimitType(i) == LIMIT_LEVEL && item2->GetLimitValue(i) > 40)
+											{
+												bCanUse = false;
+												break;
+											}
+										}
+										if (false == bCanUse)
+										{
+											ChatPacket(CHAT_TYPE_INFO, LC_STRING("    柰爛求."));
+											break;
+										}
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 却  爛求."));
+										break;
+									}
+								}
+
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+
+								if (number(1, 100) <= aiItemAttributeAddPercent[item2->GetAttributeCount()] || g_bNeverFailAddAttributes == true)
+								{
+									item2->AddAttribute();
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 煞 臼求."));
+
+									int iAddedIdx = item2->GetAttributeCount() - 1;
+									LogManager::instance().ItemLog(
+										GetPlayerID(),
+										item2->GetAttributeType(iAddedIdx),
+										item2->GetAttributeValue(iAddedIdx),
+										item->GetID(),
+										"ADD_ATTRIBUTE_SUCCESS",
+										buf,
+										GetDesc()->GetHostName(),
+										item->GetOriginalVnum()
+									);
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 煞 臼求."));
+									LogManager::instance().ItemLog(this, item, "ADD_ATTRIBUTE_FAIL", buf);
+								}
+
+								if (!g_bUnlimitedAddAttributes)
+									item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("鵑   結臼 憺 煞  求."));
+							}
+						}
+						break;
+
+						case USE_ADD_ATTRIBUTE2:
+						{
+							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_REINFORCE))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Reinforce Item cannot be used on this item."));
+								return false;
+							}
+
+							// 僊 
+							// 怜∵서  憺 4 煞 킨 謗 漫 毬 憺  牟娩.
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺    都求."));
+								return false;
+							}
+
+							// 憺 譴 4 煞 퓸  憺 煞 求.
+							if (item2->GetAttributeCount() == 4)
+							{
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+
+								if (number(1, 100) <= aiItemAttributeAddPercent[item2->GetAttributeCount()] || g_bNeverFailAddAttributes == true)
+								{
+									item2->AddAttribute();
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 煞 臼求."));
+
+									int iAddedIdx = item2->GetAttributeCount() - 1;
+									LogManager::instance().ItemLog(
+										GetPlayerID(),
+										item2->GetAttributeType(iAddedIdx),
+										item2->GetAttributeValue(iAddedIdx),
+										item->GetID(),
+										"ADD_ATTRIBUTE2_SUCCESS",
+										buf,
+										GetDesc()->GetHostName(),
+										item->GetOriginalVnum()
+									);
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 煞 臼求."));
+									LogManager::instance().ItemLog(this, item, "ADD_ATTRIBUTE2_FAIL", buf);
+								}
+
+								if (!g_bUnlimitedAddAttributes)
+									item->SetCount(item->GetCount() - 1);
+							}
+							else if (item2->GetAttributeCount() == 5)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 鵑   結臼 憺 煞  求."));
+							}
+							else if (item2->GetAttributeCount() < 4)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 怜∵서 結臼 憺 煞 玲."));
+							}
+							else
+							{
+								// wtf ?!
+								sys_err("ADD_ATTRIBUTE2 : Item has wrong AttributeCount(%d)", item2->GetAttributeCount());
+							}
+						}
+						break;
+
+#if defined(__ATTR_6TH_7TH__)
+						case USE_CHANGE_ATTRIBUTE2:
+						{
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
+								return false;
+							}
+#endif
+
+							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_ENCHANT))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Enchant Item cannot be used on this item."));
+								return false;
+							}
+
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺    都求."));
+								return false;
+							}
+
+							if (item2->GetRareAttrCount() == 0)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 憺 求."));
+								return false;
+							}
+
+							if (number(1, 100) <= item->GetValue(0))
+							{
+								if (item2->ChangeRareAttribute())
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 臼求."));
+									{
+										char szBuff[21];
+										snprintf(szBuff, sizeof(szBuff), "%u", item2->GetID());
+										LogManager::instance().ItemLog(this, item, "CHANGE_ATTRIBUTE2", szBuff);
+									}
+								}
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Upgrade change failed."));
+							}
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+						case USE_ADD_ACCESSORY_SOCKET:
+						{
+							char buf[21];
+							snprintf(buf, sizeof(buf), "%u", item2->GetID());
+
+							if (item2->IsAccessoryForSocket())
+							{
+								if (item2->GetAccessorySocketMaxGrade() < ITEM_ACCESSORY_SOCKET_MAX_NUM)
+								{
+									if (number(1, 100) <= 50 || g_bNeverFailAccessorySocket == true)
+									{
+										item2->SetAccessorySocketMaxGrade(item2->GetAccessorySocketMaxGrade() + 1);
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("  煞퓸求."));
+										LogManager::instance().ItemLog(this, item, "ADD_SOCKET_SUCCESS", buf);
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 煞 臼求."));
+										LogManager::instance().ItemLog(this, item, "ADD_SOCKET_FAIL", buf);
+									}
+
+									if (!g_bUnlimitedAddAccessorySocket)
+										item->SetCount(item->GetCount() - 1);
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 硫 鵑  煞  求."));
+								}
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("   煞   都求."));
+							}
+						}
+						break;
+
+						case USE_PUT_INTO_BELT_SOCKET:
+						case USE_PUT_INTO_ACCESSORY_SOCKET:
+						{
+							if (item2->IsAccessoryForSocket() && item->CanPutInto(item2))
+							{
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+
+								if (item2->GetAccessorySocketGrade() < item2->GetAccessorySocketMaxGrade())
+								{
+									if (number(1, 100) <= aiAccessorySocketPutPct[item2->GetAccessorySocketGrade()] || g_bNeverFailAccessory == true)
+									{
+										item2->SetAccessorySocketGrade(item2->GetAccessorySocketGrade() + 1);
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 臼求."));
+										LogManager::instance().ItemLog(this, item, "PUT_SOCKET_SUCCESS", buf);
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 臼求."));
+										LogManager::instance().ItemLog(this, item, "PUT_SOCKET_FAIL", buf);
+									}
+
+									if (!g_bUnlimitedAddAccessory)
+										item->SetCount(item->GetCount() - 1);
+								}
+								else
+								{
+									if (item2->GetAccessorySocketMaxGrade() == 0)
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 潔틘 퓬  煞瞞爛求."));
+									else if (item2->GetAccessorySocketMaxGrade() < ITEM_ACCESSORY_SOCKET_MAX_NUM)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 硫 鵑   求."));
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("潔틘  煞瞞爛求."));
+									}
+									else
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 硫 鵑    求."));
+								}
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+							}
+						}
+						break;
+
+#if defined(__MOVE_COSTUME_ATTR__)
+						case USE_RESET_COSTUME_ATTR:
+						case USE_CHANGE_COSTUME_ATTR:
+						{
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
+								return false;
+							}
+#endif
+
+							if (!item2->CanChangeCostumeAttr())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺    都求."));
+								return false;
+							}
+
+							// NOTE: Prevent changing costumes without bonus.
+							if (item2->GetAttributeCount() == 0)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺    都求."));
+								return false;
+							}
+
+							switch (item->GetSubType())
+							{
+								case USE_RESET_COSTUME_ATTR:
+								{
+									item2->ClearAttribute();
+									item2->AlterToMagicItem();
+
+									char buf[21];
+									snprintf(buf, sizeof(buf), "%u", item2->GetID());
+									LogManager::instance().ItemLog(this, item, "RESET_COSTUME_ATTR", buf);
+
+									if (!g_bUnlimitedResetCostumeAttributes)
+										item->SetCount(item->GetCount() - 1);
+
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 臼求."));
+								}
+								break;
+
+								case USE_CHANGE_COSTUME_ATTR:
+								{
+									item2->ChangeAttribute();
+
+									char buf[21];
+									snprintf(buf, sizeof(buf), "%u", item2->GetID());
+									LogManager::instance().ItemLog(this, item, "CHANGE_COSTUME_ATTR", buf);
+
+									if (!g_bUnlimitedChangeCostumeAttributes)
+										item->SetCount(item->GetCount() - 1);
+
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺 臼求."));
+								}
+								break;
+							}
+						}
+						break;
+#endif
+
+#if defined(__CHANGED_ATTR__)
+						case USE_SELECT_ATTRIBUTE:
+						{
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
+								return false;
+							}
+#endif
+							SelectAttr(item, item2);
+						}
+						break;
+#endif
+					}
+
+					if (item2->IsEquipped())
+					{
+						BuffOnAttr_AddBuffsFromItem(item2);
+					}
+				}
+				break;
+				// END_OF_ACCESSORY_REFINE & END_OF_ADD_ATTRIBUTES & END_OF_CHANGE_ATTRIBUTES
+
+				case USE_CALL:
+					AggregateMonster();
+					if (!g_bUnlimitedCapeOfCourage)
+						item->SetCount(item->GetCount() - 1);
+					break;
+
+				case USE_BAIT:
+				{
+					if (m_pkFishingEvent)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 傷 犬 틂  求."));
+						return false;
+					}
+
+					LPITEM weapon = GetWear(WEAR_WEAPON);
+
+					if (!weapon || weapon->GetType() != ITEM_ROD)
+						return false;
+
+					if (weapon->GetSocket(2))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 獵 犬  %s 求.", LC_ITEM(item->GetVnum())));
+					}
+					else
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("척肉 %s 犬 求.", LC_ITEM(item->GetVnum())));
+					}
+
+					weapon->SetSocket(2, item->GetValue(0));
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case USE_MOVE:
+				case USE_TREASURE_BOX:
+				case USE_MONEYBAG:
+					break;
+
+				case USE_AFFECT:
+				{
+#if defined(__FLOWER_EVENT__)
+					if (item->GetValue(0) == AFFECT_FLOWER_EVENT)
+						return CFlowerEvent::UseFlower(this, item);
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+					if (item->GetValue(0) == AFFECT_LATE_SUMMER_EVENT_BUFF)
+					{
+						if (FindAffect(item->GetValue(0)) || FindAffect(AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF))
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("This effect is already activated."));
+							return false;
+						}
+
+						AddAffect(item->GetValue(0), POINT_NONE, 0, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
+						item->SetCount(item->GetCount() - 1);
+						return true;
+					}
+					else if (item->GetValue(0) == AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF)
+					{
+						if (FindAffect(item->GetValue(0)) || FindAffect(AFFECT_LATE_SUMMER_EVENT_BUFF))
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("This effect is already activated."));
+							return false;
+						}
+
+						AddAffect(item->GetValue(0), POINT_NONE, 0, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
+						item->SetCount(item->GetCount() - 1);
+						return true;
+					}
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__) && defined(__PREMIUM_LOOT_FILTER__)
+					if (item->GetValue(0) == AFFECT_LOOTING_SYSTEM)
+					{
+						CAffect* pAffect = FindAffect(AFFECT_LOOTING_SYSTEM);
+						long lDuration = item->GetValue(3);
+
+						if (pAffect)
+						{
+							if (lDuration > 0)
+							{
+								if (pAffect->lDuration > LONG_MAX - lDuration)
+								{
+									sys_err("LOOT_FILTER_SYSTEM: Duration overflow, affect duration (%ld), item value3 (%ld)",
+										pAffect->lDuration, lDuration);
+									return false;
+								}
+							}
+							else
+							{
+								sys_err("LOOT_FILTER_SYSTEM: Item duration value3 (%ld) is not positive.", lDuration);
+								return false;
+							}
+
+							pAffect->bUpdate = true;
+							pAffect->lApplyValue += lDuration;
+
+							ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("Loot filter duration extended."));
+						}
+						else
+						{
+#if defined(__AFFECT_RENEWAL__)
+							AddRealTimeAffect(AFFECT_LOOTING_SYSTEM, POINT_NONE, 0, AFF_NONE, lDuration, 0, false, false);
+#else
+							AddAffect(AFFECT_LOOTING_SYSTEM, POINT_NONE, 0, AFF_NONE, lDuration, 0, false, false);
+#endif
+							ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("Loot filter activated."));
+						}
+
+						item->SetCount(item->GetCount() - 1);
+						return true;
+					}
+#endif
+
+					if (FindAffect(item->GetValue(0), aApplyInfo[item->GetValue(1)].wPointType))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+					}
+					else
+					{
+						AddAffect(item->GetValue(0), aApplyInfo[item->GetValue(1)].wPointType, item->GetValue(2), 0, item->GetValue(3), 0, false);
+						item->SetCount(item->GetCount() - 1);
+					}
+				}
+				break;
+
+				case USE_CREATE_STONE:
+				{
+					AutoGiveItem(number(28000, 28012));
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				//   킬  처
+				case USE_RECIPE:
+				{
+					LPITEM pSource1 = FindSpecifyItem(item->GetValue(1));
+					DWORD dwSourceCount1 = item->GetValue(2);
+
+					LPITEM pSource2 = FindSpecifyItem(item->GetValue(3));
+					DWORD dwSourceCount2 = item->GetValue(4);
+
+					if (dwSourceCount1 != 0)
+					{
+						if (pSource1 == NULL)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("   嘯 爛求."));
+							return false;
+						}
+					}
+
+					if (dwSourceCount2 != 0)
+					{
+						if (pSource2 == NULL)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("   嘯 爛求."));
+							return false;
+						}
+					}
+
+					if (pSource1 != NULL)
+					{
+						if (pSource1->GetCount() < dwSourceCount1)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("(%s) 爛求.", LC_ITEM(pSource1->GetVnum())));
+							return false;
+						}
+
+						pSource1->SetCount(pSource1->GetCount() - dwSourceCount1);
+					}
+
+					if (pSource2 != NULL)
+					{
+						if (pSource2->GetCount() < dwSourceCount2)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("(%s) 爛求.", LC_ITEM(pSource2->GetVnum())));
+							return false;
+						}
+
+						pSource2->SetCount(pSource2->GetCount() - dwSourceCount2);
+					}
+
+					LPITEM pBottle = FindSpecifyItem(50901);
+
+					if (!pBottle || pBottle->GetCount() < 1)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("  美求."));
+						return false;
+					}
+
+					pBottle->SetCount(pBottle->GetCount() - 1);
+
+					if (number(1, 100) > item->GetValue(5))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("  颯求."));
+						return false;
+					}
+
+					AutoGiveItem(item->GetValue(0));
+				}
+				break;
+			}
+		}
+		break;
+
+		case ITEM_METIN:
+		{
+			LPITEM item2;
+
+			if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+				return false;
+
+			if (item2->IsExchanging())
+				return false;
+
+			if (item2->IsEquipped())
+				return false;
+
+			if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_APPLY))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("This Spirit Stone cannot be attached to this type of item."));
+				return false;
+			}
+
+			if (item2->GetType() == ITEM_PICK)
+				return false;
+
+			if (item2->GetType() == ITEM_ROD)
+				return false;
+
+			int i;
+
+			for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+			{
+				DWORD dwVnum;
+
+				if ((dwVnum = item2->GetSocket(i)) <= 2)
+					continue;
+
+				const TItemTable* p = ITEM_MANAGER::instance().GetTable(dwVnum);
+
+				if (!p)
+					continue;
+
+				if (item->GetValue(5) == p->alValues[5]
+#if defined(__GLOVE_SYSTEM__)
+					&& item->GetSubType() != METIN_SUNGMA
+#endif
+					)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("  틴    求."));
+					return false;
+				}
+			}
+
+			if (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY)
+			{
+				if (!IS_SET(item->GetWearFlag(), WEARABLE_BODY) || !IS_SET(item2->GetWearFlag(), WEARABLE_BODY))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 틴    求."));
+					return false;
+				}
+			}
+#if defined(__GLOVE_SYSTEM__)
+			else if (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_GLOVE)
+			{
+				if (!IS_SET(item->GetWearFlag(), WEARABLE_GLOVE) || !IS_SET(item2->GetWearFlag(), WEARABLE_GLOVE))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 틴    求."));
+					return false;
+				}
+			}
+#endif
+			else if (item2->GetType() == ITEM_WEAPON)
+			{
+				if (!IS_SET(item->GetWearFlag(), WEARABLE_WEAPON))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 틴 藪   求."));
+					return false;
+				}
+			}
+			else
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  獵  求."));
+				return false;
+			}
+
+			for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+			{
+				if (item2->GetSocket(i) >= 1 && item2->GetSocket(i) <= 2 && item2->GetSocket(i) >= item->GetValue(2))
+				{
+					//  확
+					if (number(1, 100) <= 30 || g_bNeverFailMetin == true)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("틴  臼求."));
+
+#if defined(__GLOVE_SYSTEM__)
+						DWORD dwValue = item->GetVnum();
+						if (item->GetSubType() == METIN_SUNGMA)
+						{
+							bool bMultiplier = false;
+							if (item->GetValue(5) == 2 && number(1, 100) <= 30)
+							{
+								bMultiplier = true;
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Perfect! You have attached the Spirit Stone successfully and you even receive a double stat bonus."));
+							}
+							dwValue = item2->GetRandomSungMaSocketValue(item->GetValue(5), item->GetRefineLevel(), bMultiplier);
+						}
+						item2->SetSocket(i, dwValue);
+#else
+						item2->SetSocket(i, item->GetVnum());
+#endif
+					}
+					else
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("틴  臼求."));
+						item2->SetSocket(i, ITEM_BROKEN_METIN_VNUM);
+					}
+
+					LogManager::instance().ItemLog(this, item2, "SOCKET", item->GetName());
+					item->SetCount(item->GetCount() - 1);
+					break;
+				}
+			}
+
+			if (i == METIN_SOCKET_MAX_NUM)
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  獵  求."));
+		}
+		break;
+
+		case ITEM_AUTOUSE:
+		case ITEM_MATERIAL:
+		case ITEM_SPECIAL:
+		case ITEM_TOOL:
+		case ITEM_LOTTERY:
+			break;
+
+		case ITEM_TOTEM:
+		{
+			if (!item->IsEquipped())
+				EquipItem(item);
+		}
+		break;
+
+		case ITEM_BLEND:
+		{
+			// 恝 茄
+			sys_log(0, "ITEM_BLEND!!");
+
+			if (Blend_Item_find(item->GetVnum()))
+			{
+				int affect_type = AFFECT_BLEND;
+				int apply_type = aApplyInfo[item->GetSocket(0)].wPointType;
+				int apply_value = item->GetSocket(1);
+				int apply_duration = item->GetSocket(2);
+
+				if (FindAffect(affect_type, apply_type))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+				}
+				else
+				{
+					if (FindAffect(AFFECT_EXP_BONUS_EURO_FREE, POINT_RESIST_MAGIC))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 효  笭求."));
+					}
+					else
+					{
+						AddAffect(affect_type, apply_type, apply_value, 0, apply_duration, 0, false);
+						item->SetCount(item->GetCount() - 1);
+					}
+				}
+			}
+		}
+		break;
+
+		case ITEM_EXTRACT:
+		{
+			LPITEM pDestItem = GetItem(DestCell);
+			if (NULL == pDestItem)
+				return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+			if (item->IsSealed())
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
+				return false;
+			}
+#endif
+
+			switch (item->GetSubType())
+			{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+				case EXTRACT_DRAGON_SOUL:
+				{
+					if (pDestItem->IsDragonSoul())
+						return DSManager::instance().PullOut(this, NPOS, pDestItem, item);
+					return false;
+				}
+				case EXTRACT_DRAGON_HEART:
+				{
+					if (pDestItem->IsDragonSoul())
+						return DSManager::instance().ExtractDragonHeart(this, pDestItem, item);
+					return false;
+				}
+#endif
+				default:
+					return false;
+			}
+		}
+		break;
+
+#if defined(__GACHA_SYSTEM__)
+		case ITEM_GACHA:
+		{
+			switch (item->GetSubType())
+			{
+				case USE_GACHA:
+				{
+					if (GiveItemFromSpecialItemGroup(item->GetVnum()))
+					{
+						if (item->GetSocket(0) > 1)
+							item->SetSocket(0, item->GetSocket(0) - 1);
+						else
+							ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (ITEM_GACHA)");
+					}
+				}
+				break;
+
+#if defined(__LUCKY_BOX__)
+				case GEM_LUCKY_BOX_GACHA:
+				case SPECIAL_LUCKY_BOX_GACHA:
+					SetLuckyBoxSrcItem(item);
+					break;
+#endif
+			}
+		}
+		break;
+#endif
+
+#if defined(__SOUL_SYSTEM__)
+		case ITEM_SOUL:
+		{
+			struct SoulData
+			{
+				WORD point_type;
+				DWORD affect_flag;
+			};
+			std::unordered_map<BYTE, SoulData> soul_map
+			{
+				{ RED_SOUL, { AFF_SOUL_RED, AFF_SOUL_RED }, },
+				{ BLUE_SOUL, { AFF_SOUL_BLUE, AFF_SOUL_BLUE }, },
+			};
+
+			const auto& it = soul_map.find(item->GetSubType());
+			if (it == soul_map.end())
+			{
+				sys_err("ITEM_SOUL: Unknown SubType");
+				return false;
+			}
+
+			const auto& soul = it->second;
+
+			CAffect* affect = nullptr;
+			for (auto const& it : GetAffectContainer())
+			{
+				if (it != nullptr && it->dwType == AFFECT_SOUL)
+				{
+					if (it->wApplyOn == soul.point_type)
+					{
+						if (item->GetSocket(1) != TRUE)
+						{
+							ChatPacket(CHAT_TYPE_INFO, "The soul color is already beeing used.");
+							return false;
+						}
+					}
+
+					affect = it;
+					continue;
+				}
+			}
+
+			if (item->GetSocket(1) != TRUE)
+			{
+				AddAffect(AFFECT_SOUL, soul.point_type, item->GetID(), affect ? AFF_NONE : soul.affect_flag, item->GetSocket(0), 0, false/*override*/);
+
+				if (affect)
+				{
+					std::vector<CAffect> tmp_affects;
+					std::vector<CAffect*> to_remove;
+					for (const auto& [k, v] : soul_map)
+					{
+						CAffect* affect = FindAffect(AFFECT_SOUL, v.point_type);
+						if (affect)
+						{
+							tmp_affects.emplace_back(*affect);
+							to_remove.emplace_back(affect);
+						}
+					}
+
+					if (!to_remove.empty())
+					{
+						for (const auto& it : to_remove)
+							RemoveAffect(it);
+					}
+
+					if (!tmp_affects.empty())
+					{
+						for (const auto& it : tmp_affects)
+							AddAffect(it.dwType, it.wApplyOn, it.lApplyValue, AFF_NONE, it.lDuration, 0, false/*override*/);
+					}
+
+					AddAffect(AFFECT_SOUL, AFF_SOUL_MIX, 0, AFF_SOUL_MIX, item->GetSocket(0), 0, false/*override*/);
+				}
+
+				item->SetSocket(1, TRUE);
+				item->Lock(true);
+			}
+			else
+			{
+				RemoveAffect(AFFECT_SOUL, soul.point_type);
+				RemoveAffect(AFFECT_SOUL, AFF_SOUL_MIX); // AFF_SOUL_MIX
+
+				std::vector<CAffect> tmp_affects;
+				std::vector<CAffect*> to_remove;
+				for (const auto& affect : GetAffectContainer())
+				{
+					if (affect != nullptr && affect->dwType == AFFECT_SOUL)
+					{
+						tmp_affects.emplace_back(*affect);
+						to_remove.emplace_back(affect);
+					}
+				}
+
+				for (const auto& affect : to_remove)
+					RemoveAffect(affect);
+
+				if (!tmp_affects.empty())
+				{
+					for (const auto& affect : tmp_affects)
+					{
+						auto it = std::find_if(soul_map.begin(), soul_map.end(), [&](const auto& kv_pair) {
+							return kv_pair.second.point_type == affect.wApplyOn;
+							});
+
+						if (it != soul_map.end())
+							AddAffect(affect.dwType, affect.wApplyOn, affect.lApplyValue, it->second.affect_flag, affect.lDuration, 0, false/*override*/);
+					}
+				}
+
+				item->SetSocket(1, FALSE);
+				item->Lock(false);
+			}
+		}
+		break;
+#endif
+
+		case ITEM_NONE:
+			sys_err("Item type NONE %s", item->GetName());
+			break;
+
+		default:
+			sys_log(0, "UseItemEx: Unknown type %s %d", item->GetName(), item->GetType());
+			return false;
+	}
+
+	return true;
+}
+
+int g_nPortalLimitTime = 10;
+
+bool CHARACTER::UseItem(TItemPos Cell, TItemPos DestCell)
+{
+	WORD wCell = Cell.cell;
+	BYTE window_type = Cell.window_type;
+
+	//WORD wDestCell = DestCell.cell;
+	//BYTE bDestInven = DestCell.window_type;
+
+	LPITEM item;
+
+	if (!CanHandleItem())
+		return false;
+
+	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
+		return false;
+
+	// We don't want to use it if we are dragging it over another item of the same type...
+	LPITEM destItem = GetItem(DestCell);
+	if (destItem && item != destItem && destItem->IsStackable() && !IS_SET(destItem->GetAntiFlag(), ITEM_ANTIFLAG_STACK) && destItem->GetVnum() == item->GetVnum())
+	{
+		if (MoveItem(Cell, DestCell, 0))
+			return false;
+	}
+
+	sys_log(0, "%s: USE_ITEM %s (inven %d, cell: %d)", GetName(), item->GetName(), window_type, wCell);
+
+	if (item->IsExchanging())
+		return false;
+
+	if (!item->CanUsedBy(this))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 刻     求."));
+		return false;
+	}
+
+	if (IsStun())
+		return false;
+
+	if (false == FN_check_item_sex(this, item))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 刻     求."));
+		return false;
+	}
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
+		iLimitRealtimeStartFirstUseFlagIndex = -1;
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum = item->GetTransmutationVnum();
+	if (dwTransmutationVnum != 0)
+	{
+		TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwTransmutationVnum);
+
+		if (!pItemTable->CanUseByJob(GetJob()))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your class."));
+			return false;
+		}
+
+#	if defined(__COSTUME_SYSTEM__)
+		if (pItemTable && pItemTable->IsCostume())
+		{
+			if ((IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_MALE) && SEX_MALE == GET_SEX(this)) ||
+				(IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_FEMALE) && SEX_FEMALE == GET_SEX(this)))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your gender."));
+				return false;
+			}
+		}
+	}
+#	endif
+#endif
+
+	// PREVENT_TRADE_WINDOW
+	if (IS_SUMMON_ITEM(item, GetMapIndex()))
+	{
+		if (false == IS_SUMMONABLE_ZONE(GetMapIndex()))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item here."));
+			return false;
+		}
+
+		// 혼   SUMMONABLE_ZONE 獵째 WarpToPC() 체크
+
+		// 타  却 환罐 틜.
+		if (CThreeWayWar::instance().IsThreeWayWarMapIndex(GetMapIndex()))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("타  傷 환,환罐 寗 求."));
+			return false;
+		}
+
+		int iPulse = thecore_pulse();
+
+		// 창  체크
+		if (iPulse - GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("창  %d 犬 환,환罐   求.", g_nPortalLimitTime));
+
+			if (test_server)
+				ChatPacket(CHAT_TYPE_INFO, "[TestOnly]Pulse %d LoadTime %d PASS %d", iPulse, GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
+			return false;
+		}
+
+		// 킹 창 체크
+		if (PreventTradeWindow(WND_ALL))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("킹창,창   쩔 환,환  寗 求."));
+			return false;
+		}
+
+		// PREVENT_REFINE_HACK
+		//  챨체크
+		{
+			if (iPulse - GetRefineTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d 犬 환,환罐   求.", g_nPortalLimitTime));
+				return false;
+			}
+		}
+		// END_PREVENT_REFINE_HACK
+
+		// PREVENT_ITEM_COPY
+		{
+			if (iPulse - GetMyShopTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("貫  %d 犬 환,환罐   求.", g_nPortalLimitTime));
+				return false;
+			}
+
+#if defined(__MAILBOX__)
+			if (iPulse - GetMyMailBoxTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+			{
+				ChatPacket(CHAT_TYPE_INFO, "You cannot use a Return Scroll %d seconds after opening a mailbox.", g_nPortalLimitTime);
+				return false;
+			}
+#endif
+		}
+		// END_PREVENT_ITEM_COPY
+
+		// 환 타체크
+		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TALISMAN)
+		{
+			PIXEL_POSITION posWarp;
+
+			int x = 0;
+			int y = 0;
+
+			double nDist = 0;
+			const double nDistant = 5000.0;
+
+			// 환
+			if (item->GetVnum() == 22010)
+			{
+				x = item->GetSocket(0) - GetX();
+				y = item->GetSocket(1) - GetY();
+			}
+			// 환
+			else if (item->GetVnum() == 22000)
+			{
+				SECTREE_MANAGER::instance().GetRecallPositionByEmpire(GetMapIndex(), GetEmpire(), posWarp);
+
+				if (item->GetSocket(0) == 0)
+				{
+					x = posWarp.x - GetX();
+					y = posWarp.y - GetY();
+				}
+				else
+				{
+					x = item->GetSocket(0) - GetX();
+					y = item->GetSocket(1) - GetY();
+				}
+			}
+
+			nDist = sqrt(pow((float)x, 2) + pow((float)y, 2));
+
+			if (nDistant > nDist)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("絹 퓸 치 賈  환罐 寗 求."));
+				if (test_server)
+					ChatPacket(CHAT_TYPE_INFO, "PossibleDistant %f nNowDist %f", nDistant, nDist);
+				return false;
+			}
+		}
+
+		// PREVENT_PORTAL_AFTER_EXCHANGE
+		// 환  챨체크
+		if (iPulse - GetExchangeTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("킹  %d 犬 환,환琯   求.", g_nPortalLimitTime));
+			return false;
+		}
+		// END_PREVENT_PORTAL_AFTER_EXCHANGE
+	}
+
+	//    킹창  체크
+	if ((item->GetVnum() == 50200) || (item->GetVnum() == 71049))
+	{
+		if (PreventTradeWindow(WND_ALL))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("킹창,창   쩔 ,甁 寗 求."));
+			return false;
+		}
+	}
+	// END_PREVENT_TRADE_WINDOW
+
+	if (IsRunningQuest())
+		return false;
+
+	if (IS_SET(item->GetFlag(), ITEM_FLAG_LOG)) //  慣琉   처
+	{
+		DWORD vid = item->GetVID();
+		DWORD oldCount = item->GetCount();
+		DWORD vnum = item->GetVnum();
+
+		char hint[ITEM_NAME_MAX_LEN + 32 + 1];
+		int len = snprintf(hint, sizeof(hint) - 32, "%s", item->GetName());
+
+		if (len < 0 || len >= (int)sizeof(hint) - 32)
+			len = (sizeof(hint) - 32) - 1;
+
+		bool ret = UseItemEx(item, DestCell);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		if (ret and item->GetType() == ITEM_USE or ret and item->GetType() == ITEM_SKILLBOOK or ret and item->GetType() == ITEM_GIFTBOX)
+			UpdateExtBattlePassMissionProgress(BP_ITEM_USE, 1, item->GetVnum());
+#endif
+
+		if (NULL == ITEM_MANAGER::instance().FindByVID(vid)) // UseItemEx   퓸.  慣琉 
+		{
+			LogManager::instance().ItemLog(this, vid, vnum, "REMOVE", hint);
+		}
+		else if (oldCount != item->GetCount())
+		{
+			snprintf(hint + len, sizeof(hint) - len, " %u", oldCount - 1);
+			LogManager::instance().ItemLog(this, vid, vnum, "USE_ITEM", hint);
+		}
+		return (ret);
+	}
+	else
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	{
+		bool ret = UseItemEx(item, DestCell);
+
+		if (ret and item->GetType() == ITEM_USE or ret and item->GetType() == ITEM_SKILLBOOK or ret and item->GetType() == ITEM_GIFTBOX)
+			UpdateExtBattlePassMissionProgress(BP_ITEM_USE, 1, item->GetVnum());
+		
+		return (ret);
+	}
+#else
+		return UseItemEx(item, DestCell);
+#endif
+}
+
+bool CHARACTER::DropItem(TItemPos Cell, WORD wCount)
+{
+	LPITEM item = NULL;
+
+	if (!CanHandleItem())
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (NULL != DragonSoul_RefineWindow_GetOpener())
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("화창  쩔  킥  求."));
+#endif
+		return false;
+	}
+
+	if (IsDead())
+		return false;
+
+	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
+		return false;
+
+	if (item->IsExchanging())
+		return false;
+
+	if (true == item->isLocked())
+		return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (item->IsSealed())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot drop a soulbound item."));
+		return false;
+	}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+		case ITEM_PET:
+			{
+				switch (item->GetSubType())
+				{
+					case PET_UPBRINGING:
+					{
+						LPGROWTH_PET pPet = GetGrowthPet(item->GetSocket(2));
+						if (pPet)
+						{
+							if (m_activeGrowthPet && m_activeGrowthPet->GetPetID() == pPet->GetPetID())
+							{
+								m_activeGrowthPet->Unsummon();
+								m_activeGrowthPet = nullptr;
+								return true;
+							}
+							else if (m_activeGrowthPet)
+								m_activeGrowthPet->Unsummon();
+
+							m_activeGrowthPet = pPet->Summon(item);
+						}
+					} break;
+
+					case PET_FEEDSTUFF:
+					{
+						LPITEM item2;
+
+						if (!GetItem(DestCell) || !(item2 = GetItem(DestCell)))
+							return false;
+
+						if (item2->GetType() != ITEM_PET && item2->GetSubType() != PET_UPBRINGING)
+							return false;
+
+						LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
+						if (!pPet)
+							return false;
+
+						if (item2->GetSocket(0) < get_global_time())
+						{
+							pPet->Revive(item2, PET_REVIVE_TYPE_NORMAL);
+							ITEM_MANAGER::instance().RemoveItem(item);
+						}
+						else
+						{
+							pPet->RewardFood(item, PET_FEED_TYPE_FULL);
+						}
+
+					} break;
+
+					case PET_BAG:
+					{
+						LPITEM item2 = GetItem(DestCell);
+						
+						if (item2)
+						{
+							if (item2->GetType() != ITEM_PET)
+								return false;
+
+							if (item2->GetSubType() != PET_UPBRINGING && item2->GetSubType() != PET_BAG)
+								return false;
+
+							switch (item2->GetSubType())
+							{
+								case PET_UPBRINGING:
+								{
+									LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
+									if (!pPet)
+										return false;
+
+									pPet->SetState(STATE_BAG);
+									pPet->SetSummonItem(nullptr);
+									pPet->Save();
+
+									time_t currentTime = time(0);
+									item->SetSocket(0, currentTime + item->GetLimitValue(0));
+									item->SetSocket(1, time(0));
+									item->SetSocket(2, pPet->GetPetID());
+									item->StartRealTimeExpireEvent();
+
+									ITEM_MANAGER::instance().RemoveItem(item2, "REMOVE (UPBRINGING-BAG TRANSFER)");
+								} break;
+
+								case PET_BAG:
+								{
+									LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
+									if (!pPet)
+										return false;
+
+									/* Pet age equals to difference between birthday and current time minus time spent in bag */
+
+									// Time spent in bag: current time - the time pet was put into the bag
+									time_t currentTime = time(0);
+									DWORD dwBagTime = currentTime - (item2->GetSocket(0) - item2->GetLimitValue(0));
+									DWORD dwPetAge = currentTime - pPet->GetPetPoint(POINT_UPBRINGING_BIRTHDAY) - dwBagTime;
+
+									// Shift back pet's birthday from current time & update real time event
+									pPet->ChangePetPoint(POINT_UPBRINGING_BIRTHDAY, currentTime - dwPetAge, true);
+									pPet->Save();
+
+									item2->SetSocket(0, currentTime + item2->GetLimitValue(0));
+									item2->StartRealTimeExpireEvent();
+
+									ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (BAG-BAG TRANSFER)");
+								} break;
+							}
+						}
+						else
+						{
+							if (!item->GetSocket(2))
+								return false;
+
+							LPGROWTH_PET pPet = GetGrowthPet(item->GetSocket(2));
+							if (!pPet)
+								return false;
+
+							time_t currentTime = time(0);
+							DWORD dwBagTime = item->GetSocket(0) - item->GetLimitValue(0);
+							DWORD dwPetAge = currentTime - pPet->GetPetPoint(POINT_UPBRINGING_BIRTHDAY) - (currentTime - dwBagTime);
+							DWORD dwPetDuration = currentTime + pPet->GetPetPoint(POINT_UPBRINGING_MAX_DURATION);
+							LPITEM pUpBringingItem = AutoGiveItem(pPet->GetSummonItemVnum());
+
+							// Copy stats from old pet to a new table
+							TGrowthPet petTable;
+							pPet->CreateGrowthPetProto(&petTable);
+							petTable.dwID = pUpBringingItem->GetID();
+							petTable.lBirthday = currentTime - dwPetAge;
+							petTable.lEndTime = dwPetDuration;
+							petTable.bState = STATE_UPBRINGING;
+
+							// Create a new pet and copy stats from table to it
+							LPGROWTH_PET pNewPet = CGrowthPetManager::Instance().CreateGrowthPet(this, pUpBringingItem->GetID());
+							pNewPet->SetGrowthPetProto(&petTable);
+
+							// Sync upbringing sockets with the new pet
+							pUpBringingItem->SetSocket(0, dwPetDuration);
+							pUpBringingItem->SetSocket(1, petTable.lMaxTime);
+							pUpBringingItem->SetSocket(2, pUpBringingItem->GetID());
+
+							pPet->SetSummonItem(pUpBringingItem);
+							pPet->Save();
+
+							SetGrowthPet(pNewPet);
+
+							CGrowthPetManager::Instance().DeleteGrowthPet(item->GetSocket(2), true);
+							ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (BAG-UPBRINGING TRANSFER)");
+						}
+					} break;
+				}
+
+			} break;
+#endif
+
+	if (IsRunningQuest())
+		return false;
+
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DROP | ITEM_ANTIFLAG_GIVE))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("   都求."));
+		return false;
+	}
+
+	if (wCount == 0 || wCount > item->GetCount())
+		wCount = item->GetCount();
+
+	// Quickslot  
+	if (INVENTORY == Cell.window_type)
+		SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, WORD_MAX);
+	else if (BELT_INVENTORY == Cell.window_type)
+		SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, WORD_MAX);
+
+	LPITEM pkItemToDrop;
+
+	if (wCount == item->GetCount())
+	{
+		item->RemoveFromCharacter();
+		pkItemToDrop = item;
+	}
+	else
+	{
+		if (wCount == 0)
+		{
+			if (test_server)
+				sys_log(0, "[DROP_ITEM] drop item count == 0");
+			return false;
+		}
+
+		item->SetCount(item->GetCount() - wCount);
+		ITEM_MANAGER::instance().FlushDelayedSave(item);
+
+		pkItemToDrop = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), wCount);
+
+		// Copy item socket -- by mhh
+		FN_copy_item_socket(pkItemToDrop, item);
+
+		char szBuf[51 + 1];
+		snprintf(szBuf, sizeof(szBuf), "%u %u", pkItemToDrop->GetID(), pkItemToDrop->GetCount());
+		LogManager::instance().ItemLog(this, item, "ITEM_SPLIT", szBuf);
+	}
+
+	PIXEL_POSITION pxPos = GetXYZ();
+
+	if (pkItemToDrop->AddToGround(GetMapIndex(), pxPos))
+	{
+		// 畸   娩牝  티
+		//  募悶   憺慣琉 .
+		if (LC_IsYMIR())
+			item->AttrLog();
+
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("  3  求."));
+		pkItemToDrop->StartDestroyEvent();
+
+		ITEM_MANAGER::instance().FlushDelayedSave(pkItemToDrop);
+
+		char szHint[32 + 1];
+		snprintf(szHint, sizeof(szHint), "%s %u %u", pkItemToDrop->GetName(), pkItemToDrop->GetCount(), pkItemToDrop->GetOriginalVnum());
+		LogManager::instance().ItemLog(this, pkItemToDrop, "DROP", szHint);
+		//Motion(MOTION_PICKUP);
+	}
+
+	return true;
+}
+
+#if defined(__NEW_DROP_DIALOG__)
+bool CHARACTER::DestroyItem(TItemPos Cell)
+{
+	LPITEM item = NULL;
+
+	if (!CanHandleItem())
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (NULL != DragonSoul_RefineWindow_GetOpener())
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("화창  쩔  킥  求."));
+#endif
+		return false;
+	}
+
+	if (IsDead())
+		return false;
+
+	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
+		return false;
+
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DESTROY))
+		return false;
+
+	if (item->IsExchanging())
+		return false;
+
+	if (true == item->isLocked())
+		return false;
+
+	if (IsRunningQuest())
+		return false;
+
+	if (item->GetCount() <= 0)
+		return false;
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	UpdateExtBattlePassMissionProgress(BP_ITEM_DESTROY, 1, item->GetVnum());
+#endif
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (item->IsSealed())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot destroy a soulbound item."));
+		return false;
+	}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		ChatPacket(CHAT_TYPE_INFO, "You cannot use items while modifying your pet's stats.");
+		return false;
+	}
+#endif
+
+	if (INVENTORY == Cell.window_type)
+		SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, WORD_MAX);
+	else if (BELT_INVENTORY == Cell.window_type)
+		SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, WORD_MAX);
+
+	ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have deleted %s.", LC_ITEM(item->GetVnum())));
+	ITEM_MANAGER::instance().RemoveItem(item, "DESTROYED BY PLAYER");
+
+	return true;
+}
+#endif
+
+bool CHARACTER::DropGold(int iAmount)
+{
+	if (iAmount <= 0 || iAmount > GetGold())
+		return false;
+
+	if (!CanHandleItem())
+		return false;
+
+	if (0 != g_GoldDropTimeLimitValue)
+	{
+		if (get_dword_time() < m_dwLastGoldDropTime + g_GoldDropTimeLimitValue)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 躍   求."));
+			return false;
+		}
+	}
+
+	m_dwLastGoldDropTime = get_dword_time();
+
+	LPITEM item = ITEM_MANAGER::instance().CreateItem(1, iAmount);
+
+	if (item)
+	{
+		PIXEL_POSITION pos = GetXYZ();
+
+		if (item->AddToGround(GetMapIndex(), pos))
+		{
+			//Motion(MOTION_PICKUP);
+			PointChange(POINT_GOLD, -iAmount, true);
+
+			//   募 陋 獵쨉,
+			//  처 傷 毬,
+			// 크款,  消 1000     躍 0 ,
+			//  鳴  청求   獵.
+			//  瀏 痢    치 恙 漫 慣琉 .
+			if (LC_IsBrazil() == true)
+			{
+				if (iAmount >= 213)
+					LogManager::instance().CharLog(this, iAmount, "DROP_GOLD", "");
+			}
+			else
+			{
+				if (iAmount > 1000) // 천 鵑 磯.
+					LogManager::instance().CharLog(this, iAmount, "DROP_GOLD", "");
+			}
+
+			if (false == LC_IsBrazil())
+			{
+				item->StartDestroyEvent(150);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d  求.", 150 / 60));
+			}
+			else
+			{
+				item->StartDestroyEvent(60);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d  求.", 1));
+			}
+		}
+
+		Save();
+		return true;
+	}
+
+	return false;
+}
+
+#if defined(__CHEQUE_SYSTEM__)
+bool CHARACTER::DropCheque(int cheque)
+{
+	if (cheque <= 0 || (long long)cheque > GetCheque())
+		return false;
+
+	if (!CanHandleItem())
+		return false;
+
+	if (0 != g_ChequeDropTimeLimitValue)
+	{
+		if (get_dword_time() < m_dwLastChequeDropTime + g_ChequeDropTimeLimitValue)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 躍   求."));
+			return false;
+		}
+	}
+
+	m_dwLastChequeDropTime = get_dword_time();
+
+	LPITEM item = ITEM_MANAGER::instance().CreateItem(80020, cheque);
+
+	if (item)
+	{
+		PIXEL_POSITION pos = GetXYZ();
+
+		if (item->AddToGround(GetMapIndex(), pos))
+		{
+			PointChange(POINT_CHEQUE, -cheque, true);
+
+			if (cheque > 1000)
+				LogManager::instance().CharLog(this, cheque, "DROP_CHEQUE", "");
+
+			if (false == LC_IsBrazil())
+			{
+				item->StartDestroyEvent(150);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d  求.", 150 / 60));
+			}
+			else
+			{
+				item->StartDestroyEvent(60);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d  求.", 1));
+			}
+		}
+
+		Save();
+		return true;
+	}
+
+	return false;
+}
+#endif
+
+bool CHARACTER::MoveItem(TItemPos Cell, TItemPos DestCell, WORD count)
+{
+	LPITEM item = nullptr;
+
+	if (Cell.IsSameItemPosition(DestCell))
+		return false;
+
+	if (!IsValidItemPosition(Cell))
+		return false;
+
+	if (!(item = GetItem(Cell)))
+		return false;
+
+	if (item->IsExchanging())
+		return false;
+
+	if (item->GetCount() < count)
+		return false;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	if (INVENTORY == Cell.window_type && Cell.cell >= GetExtendInvenMax() && IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+		return false;
+#else
+	if (INVENTORY == Cell.window_type && Cell.cell >= INVENTORY_MAX_NUM && IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+		return false;
+#endif
+
+	if (true == item->isLocked())
+		return false;
+
+	if (!IsValidItemPosition(DestCell))
+		return false;
+
+	if (!CanHandleItem())
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (DragonSoul_RefineWindow_GetOpener())
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("화창  쩔  킥  求."));
+#endif
+		return false;
+	}
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		ChatPacket(CHAT_TYPE_INFO, "You cannot drop items while modifying your pet's stats.");
+		return false;
+	}
+#endif
+
+	if (DestCell.IsBeltInventoryPosition())
+	{
+		// At the request of the planner, only certain types of items can be placed in the belt inventory.
+		if (!CBeltInventoryHelper::CanMoveIntoBeltInventory(item))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  트 觀訝 킥  求."));
+			return false;
+		}
+	}
+
+	// 譴   摸  킥 , '책 '   확構 킥
+	if (Cell.IsEquipPosition())
+	{
+		if (!CanUnequipNow(item))
+			return false;
+
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+		const int iWearCell = item->FindEquipCell(this);
+		if (iWearCell == WEAR_WEAPON)
+		{
+			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
+			if (pkCostumeWeapon)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
+				return false;
+			}
+		}
+#endif
+	}
+
+	if (DestCell.IsEquipPosition())
+	{
+		if (GetItem(DestCell)
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			&& DestCell.IsDragonSoulEquipPosition()
+#endif
+			) //     講巒 홱.
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴  構 笭求."));
+			return false;
+		}
+
+		EquipItem(item, DestCell.cell);
+	}
+	else
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+		{
+			if (item->IsEquipped())
+			{
+				return DSManager::instance().PullOut(this, DestCell, item);
+			}
+			else
+			{
+				if (DestCell.window_type != DRAGON_SOUL_INVENTORY)
+				{
+					return false;
+				}
+
+				if (!DSManager::instance().IsValidCellForThisItem(item, DestCell))
+					return false;
+			}
+		}
+		// 혼 틈  혼 觀 載  .
+		else if (DRAGON_SOUL_INVENTORY == DestCell.window_type)
+			return false;
+#endif
+
+		LPITEM item2;
+
+		if ((item2 = GetItem(DestCell)) && item != item2 && item2->IsStackable() &&
+			!IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_STACK) &&
+			item2->GetVnum() == item->GetVnum() && !item2->IsExchanging()) // 칠  獵  
+		{
+			for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+				if (item2->GetSocket(i) != item->GetSocket(i))
+					return false;
+
+			if (count == 0)
+				count = item->GetCount();
+
+			sys_log(0, "%s: ITEM_STACK %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell,
+				DestCell.window_type, DestCell.cell, count);
+
+			count = MIN(ITEM_MAX_COUNT - item2->GetCount(), count);
+
+			item->SetCount(item->GetCount() - count);
+			item2->SetCount(item2->GetCount() + count);
+
+			return true;
+		}
+
+		if (!IsEmptyItemGrid(DestCell, item->GetSize(), Cell.cell))
+		{
+			return false;
+		}
+
+		if (count == 0 || count >= item->GetCount() || !item->IsStackable() || IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+		{
+			sys_log(0, "%s: ITEM_MOVE %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell,
+				DestCell.window_type, DestCell.cell, count);
+
+			item->RemoveFromCharacter();
+			SetItem(DestCell, item);
+
+			if (INVENTORY == Cell.window_type && INVENTORY == DestCell.window_type)
+				SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, DestCell.cell);
+			else if (BELT_INVENTORY == Cell.window_type && BELT_INVENTORY == DestCell.window_type)
+				SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, DestCell.cell);
+
+			else if (INVENTORY == Cell.window_type && BELT_INVENTORY == DestCell.window_type)
+				MoveQuickSlotItem(SLOT_TYPE_INVENTORY, Cell.cell, SLOT_TYPE_BELT_INVENTORY, DestCell.cell);
+			else if (BELT_INVENTORY == Cell.window_type && INVENTORY == DestCell.window_type)
+				MoveQuickSlotItem(SLOT_TYPE_BELT_INVENTORY, Cell.cell, SLOT_TYPE_INVENTORY, DestCell.cell);
+		}
+		else if (count < item->GetCount())
+		{
+			sys_log(0, "%s: ITEM_SPLIT %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell, DestCell.window_type, DestCell.cell, count);
+
+			item->SetCount(item->GetCount() - count);
+			LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), count);
+
+			// Copy socket -- by mhh
+			FN_copy_item_socket(item2, item);
+
+			item2->AddToCharacter(this, DestCell);
+
+			char szBuf[51 + 1];
+			snprintf(szBuf, sizeof(szBuf), "%u %u %u %u ", item2->GetID(), item2->GetCount(), item->GetCount(), item->GetCount() + item2->GetCount());
+			LogManager::instance().ItemLog(this, item, "ITEM_SPLIT", szBuf);
+		}
+	}
+
+	return true;
+}
+
+namespace NPartyPickupDistribute
+{
+	struct FFindOwnership
+	{
+		LPITEM item;
+		LPCHARACTER owner;
+
+		FFindOwnership(LPITEM item)
+			: item(item), owner(NULL)
+		{
+		}
+
+		void operator () (LPCHARACTER ch)
+		{
+			if (item->IsOwnership(ch))
+				owner = ch;
+		}
+	};
+
+	struct FCountNearMember
+	{
+		int total;
+		int x, y;
+
+		FCountNearMember(LPCHARACTER center)
+			: total(0), x(center->GetX()), y(center->GetY())
+		{
+		}
+
+		void operator () (LPCHARACTER ch)
+		{
+			if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
+				total += 1;
+		}
+	};
+
+	struct FMoneyDistributor
+	{
+		int total;
+		LPCHARACTER c;
+		int x, y;
+		int iMoney;
+
+		FMoneyDistributor(LPCHARACTER center, int iMoney)
+			: total(0), c(center), x(center->GetX()), y(center->GetY()), iMoney(iMoney)
+		{
+		}
+
+		void operator ()(LPCHARACTER ch)
+		{
+			if (ch != c)
+				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
+				{
+					ch->PointChange(POINT_GOLD, iMoney, true);
+
+					if (iMoney > 1000) // 천 鵑 磯.
+						LogManager::instance().CharLog(ch, iMoney, "GET_GOLD", "");
+				}
+		}
+	};
+
+#if defined(__CHEQUE_SYSTEM__)
+	struct FChequeDistributor
+	{
+		int total;
+		LPCHARACTER c;
+		int x, y;
+		int iCheque;
+
+		FChequeDistributor(LPCHARACTER center, int iCheque)
+			: total(0), c(center), x(center->GetX()), y(center->GetY()), iCheque(iCheque)
+		{
+		}
+
+		void operator ()(LPCHARACTER ch)
+		{
+			if (ch != c)
+				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
+				{
+					ch->PointChange(POINT_CHEQUE, iCheque, true);
+
+					if (iCheque > 1000)
+						LogManager::instance().CharLog(ch, iCheque, "GET_CHEQUE", "");
+				}
+		}
+	};
+#endif
+
+#if defined(__GEM_SYSTEM__)
+	struct FGemDistributor
+	{
+		int total;
+		LPCHARACTER c;
+		int x, y;
+		int iGem;
+
+		FGemDistributor(LPCHARACTER center, int iGem)
+			: total(0), c(center), x(center->GetX()), y(center->GetY()), iGem(iGem)
+		{
+		}
+
+		void operator ()(LPCHARACTER ch)
+		{
+			if (ch != c)
+				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
+				{
+					ch->PointChange(POINT_GEM, iGem, true);
+
+					if (iGem > 1000)
+						LogManager::instance().CharLog(ch, iGem, "GET_GEM", "");
+				}
+		}
+	};
+#endif
+}
+
+void CHARACTER::GiveGold(int iAmount)
+{
+	if (iAmount <= 0)
+		return;
+
+	sys_log(0, "GIVE_GOLD: %s %d", GetName(), iAmount);
+
+	if (GetParty())
+	{
+		LPPARTY pParty = GetParty();
+
+		// 티 獵   .
+		DWORD dwTotal = iAmount;
+		DWORD dwMyAmount = dwTotal;
+
+		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
+		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
+
+		if (funcCountNearMember.total > 1)
+		{
+			DWORD dwShare = dwTotal / funcCountNearMember.total;
+			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
+
+			NPartyPickupDistribute::FMoneyDistributor funcMoneyDist(this, dwShare);
+			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
+		}
+
+		PointChange(POINT_GOLD, dwMyAmount, true);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		UpdateExtBattlePassMissionProgress(YANG_COLLECT, dwMyAmount, GetMapIndex());
+#endif
+
+		if (dwMyAmount > 1000) // 천 鵑 磯.
+			LogManager::instance().CharLog(this, dwMyAmount, "GET_GOLD", "");
+	}
+	else
+	{
+		PointChange(POINT_GOLD, iAmount, true);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		UpdateExtBattlePassMissionProgress(YANG_COLLECT, iAmount, GetMapIndex());
+#endif
+
+		//   募 陋 獵쨉,
+		//  처 傷 毬,
+		// 크款,  消 1000     躍 0 ,
+		//  鳴  청求   獵.
+		//  瀏 痢    치 恙 漫 慣琉 .
+		if (LC_IsBrazil() == true)
+		{
+			if (iAmount >= 213)
+				LogManager::instance().CharLog(this, iAmount, "GET_GOLD", "");
+		}
+		else
+		{
+			if (iAmount > 1000) // 천 鵑 磯.
+				LogManager::instance().CharLog(this, iAmount, "GET_GOLD", "");
+		}
+	}
+}
+
+#if defined(__CHEQUE_SYSTEM__)
+void CHARACTER::GiveCheque(int iAmount)
+{
+	if (iAmount <= 0)
+		return;
+
+	sys_log(0, "GIVE_CHEQUE: %s %lld", GetName(), iAmount);
+
+	if (GetParty())
+	{
+		LPPARTY pParty = GetParty();
+
+		DWORD dwTotal = iAmount;
+		DWORD dwMyAmount = dwTotal;
+
+		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
+		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
+
+		if (funcCountNearMember.total > 1)
+		{
+			DWORD dwShare = dwTotal / funcCountNearMember.total;
+			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
+
+			NPartyPickupDistribute::FChequeDistributor funcMoneyDist(this, dwShare);
+			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
+		}
+
+		PointChange(POINT_CHEQUE, dwMyAmount, true);
+
+		if (dwMyAmount > 1000)
+			LogManager::instance().CharLog(this, dwMyAmount, "GET_CHEQUE", "");
+	}
+	else
+	{
+		PointChange(POINT_CHEQUE, iAmount, true);
+
+		if (LC_IsBrazil() == true)
+		{
+			if (iAmount >= 213)
+				LogManager::instance().CharLog(this, iAmount, "GET_CHEQUE", "");
+		}
+		else
+		{
+			if (iAmount > 1000)
+				LogManager::instance().CharLog(this, iAmount, "GET_CHEQUE", "");
+		}
+	}
+}
+#endif
+
+#if defined(__GEM_SYSTEM__)
+void CHARACTER::GiveGem(int iAmount)
+{
+	if (iAmount <= 0)
+		return;
+
+	sys_log(0, "GIVE_GEM: %s %lld", GetName(), iAmount);
+
+	if (GetParty())
+	{
+		LPPARTY pParty = GetParty();
+
+		DWORD dwTotal = iAmount;
+		DWORD dwMyAmount = dwTotal;
+
+		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
+		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
+
+		if (funcCountNearMember.total > 1)
+		{
+			DWORD dwShare = dwTotal / funcCountNearMember.total;
+			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
+
+			NPartyPickupDistribute::FGemDistributor funcMoneyDist(this, dwShare);
+			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
+		}
+
+		PointChange(POINT_GEM, dwMyAmount, true);
+
+		if (dwMyAmount > 1000)
+			LogManager::instance().CharLog(this, dwMyAmount, "GET_GEM", "");
+	}
+	else
+	{
+		PointChange(POINT_GEM, iAmount, true);
+
+		if (LC_IsBrazil() == true)
+		{
+			if (iAmount >= 213)
+				LogManager::instance().CharLog(this, iAmount, "GET_GEM", "");
+		}
+		else
+		{
+			if (iAmount > 1000)
+				LogManager::instance().CharLog(this, iAmount, "GET_GEM", "");
+		}
+	}
+}
+#endif
+
+bool CHARACTER::PickupItem(DWORD dwVID
+#if defined(__PET_LOOT_AI__)
+	, bool bPetLoot
+#endif
+)
+{
+	if (IsDead())
+		return false;
+
+	LPITEM item = ITEM_MANAGER::instance().FindByVID(dwVID);
+
+	if (IsObserverMode())
+		return false;
+
+	if (!item || !item->GetSectree())
+		return false;
+
+	if (item->DistanceValid(this)
+#if defined(__PET_LOOT_AI__)
+		|| bPetLoot
+#endif
+		)
+	{
+		if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
+			|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
+		{
+			if (IsRunningQuest())
+				return false;
+		}
+
+		if (item->IsOwnership(this))
+		{
+#if defined(__LOOT_FILTER_SYSTEM__)
+			if (GetLootFilter() && !GetLootFilter()->CanPickUpItem(item))
+			{
+				if (!GetLootFilter()->IsLootFilteredItem(dwVID))
+				{
+					GetLootFilter()->InsertLootFilteredItem(dwVID);
+
+					if (GetDesc())
+					{
+						TPacketGCLootFilter p;
+						p.header = HEADER_GC_LOOT_FILTER;
+						p.enable = false;
+						p.vid = dwVID;
+						GetDesc()->Packet(&p, sizeof(p));
+					}
+				}
+
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as the loot filter is deactivated."));
+				return false;
+			}
+#endif
+
+			//   求  크
+			if (item->GetType() == ITEM_ELK)
+			{
+				GiveGold(item->GetCount());
+				item->RemoveFromGround();
+
+				M2_DESTROY_ITEM(item);
+
+				Save();
+			}
+			//  繭
+			else
+			{
+				if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+				{
+					WORD wCount = item->GetCount();
+
+					for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+					{
+						LPITEM item2 = GetInventoryItem(i);
+
+						if (!item2)
+							continue;
+
+						if (item2->GetVnum() == item->GetVnum())
+						{
+							int j;
+
+							for (j = 0; j < ITEM_SOCKET_MAX_NUM; ++j)
+							{
+								if (item2->GetSocket(j) != item->GetSocket(j))
+									break;
+							}
+
+							if (j != ITEM_SOCKET_MAX_NUM)
+								continue;
+
+							WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
+
+							wCount -= wCount2;
+
+							item2->SetCount(item2->GetCount() + wCount2);
+
+							if (wCount == 0)
+							{
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+								ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
+#else
+								ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_ITEM(item2->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
+#else
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_ITEM(item2->GetVnum())));
+#endif
+#endif
+								M2_DESTROY_ITEM(item);
+
+								if (item2->GetType() == ITEM_QUEST)
+									quest::CQuestManager::instance().PickupItem(GetPlayerID(), item2);
+
+								return true;
+							}
+						}
+					}
+
+					item->SetCount(wCount);
+				}
+
+				int iEmptyCell;
+#if defined(__DRAGON_SOUL_SYSTEM__)
+				if (item->IsDragonSoul())
+				{
+					if ((iEmptyCell = GetEmptyDragonSoulInventory(item)) == -1)
+					{
+						sys_log(0, "No empty ds inventory pid %u size %ud itemid %u", GetPlayerID(), item->GetSize(), item->GetID());
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("構 獵  賈 求."));
+						return false;
+					}
+				}
+				else
+#endif
+				{
+					if ((iEmptyCell = GetEmptyInventory(item->GetSize())) == -1)
+					{
+						sys_log(0, "No empty inventory pid %u size %ud itemid %u", GetPlayerID(), item->GetSize(), item->GetID());
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("構 獵  賈 求."));
+						return false;
+					}
+				}
+
+				item->RemoveFromGround();
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+				if (item->IsDragonSoul())
+					item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
+				else
+#endif
+					item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell));
+
+				char szHint[32 + 1];
+				snprintf(szHint, sizeof(szHint), "%s %u %u", item->GetName(), item->GetCount(), item->GetOriginalVnum());
+				LogManager::instance().ItemLog(this, item, "GET", szHint);
+
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#endif
+#endif
+
+				if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
+					|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
+				{
+					quest::CQuestManager::instance().PickupItem(GetPlayerID(), item);
+				}
+			}
+
+			//Motion(MOTION_PICKUP);
+			return true;
+		}
+		else if (!IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_DROP) && GetParty())
+		{
+			// 摸 티    磯摸
+			NPartyPickupDistribute::FFindOwnership funcFindOwnership(item);
+			GetParty()->ForEachOnMapMember(funcFindOwnership, GetMapIndex());
+
+			LPCHARACTER owner = funcFindOwnership.owner;
+			if (!owner)
+				return false;
+
+			int iEmptyCell;
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			if (item->IsDragonSoul())
+			{
+				if (!(owner && (iEmptyCell = owner->GetEmptyDragonSoulInventory(item)) != -1))
+				{
+					owner = this;
+
+					if ((iEmptyCell = GetEmptyDragonSoulInventory(item)) == -1)
+					{
+						owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("構 獵  賈 求."));
+						return false;
+					}
+				}
+			}
+			else
+#endif
+			{
+				if (!(owner && (iEmptyCell = owner->GetEmptyInventory(item->GetSize())) != -1))
+				{
+					owner = this;
+
+					if ((iEmptyCell = GetEmptyInventory(item->GetSize())) == -1)
+					{
+						owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("構 獵  賈 求."));
+						return false;
+					}
+				}
+			}
+
+			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+			{
+				WORD wCount = item->GetCount();
+
+				for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+				{
+					LPITEM item2 = owner->GetInventoryItem(i);
+
+					if (!item2)
+						continue;
+
+					if (item2->GetVnum() == item->GetVnum())
+					{
+						int j;
+
+						for (j = 0; j < ITEM_SOCKET_MAX_NUM; ++j)
+						{
+							if (item2->GetSocket(j) != item->GetSocket(j))
+								break;
+						}
+
+						if (j != ITEM_SOCKET_MAX_NUM)
+							continue;
+
+						WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
+
+						wCount -= wCount2;
+
+						item2->SetCount(item2->GetCount() + wCount2);
+
+						if (wCount == 0)
+						{
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+							owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
+#else
+							owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_ITEM(item2->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+							owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
+#else
+							owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_ITEM(item2->GetVnum())));
+#endif
+#endif
+							M2_DESTROY_ITEM(item);
+
+							if (item2->GetType() == ITEM_QUEST)
+								quest::CQuestManager::instance().PickupItem(owner->GetPlayerID(), item2);
+
+							return true;
+						}
+					}
+				}
+
+				item->SetCount(wCount);
+			}
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+			if (owner->GetLootFilter() && !owner->GetLootFilter()->CanPickUpItem(item))
+			{
+				if (owner == this)
+				{
+					if (!owner->GetLootFilter()->IsLootFilteredItem(dwVID))
+					{
+						owner->GetLootFilter()->InsertLootFilteredItem(dwVID);
+
+						if (owner->GetDesc())
+						{
+							TPacketGCLootFilter p;
+							p.header = HEADER_GC_LOOT_FILTER;
+							p.enable = false;
+							p.vid = dwVID;
+							owner->GetDesc()->Packet(&p, sizeof(p));
+						}
+					}
+
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as the loot filter is deactivated."));
+				}
+				else
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as a party member's loot filter is deactivated."));
+				}
+
+				return false;
+			}
+#endif
+
+			item->RemoveFromGround();
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			if (item->IsDragonSoul())
+				item->AddToCharacter(owner, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
+			else
+#endif
+				item->AddToCharacter(owner, TItemPos(INVENTORY, iEmptyCell));
+
+			char szHint[32 + 1];
+			snprintf(szHint, sizeof(szHint), "%s %u %u", item->GetName(), item->GetCount(), item->GetOriginalVnum());
+			LogManager::instance().ItemLog(owner, item, "GET", szHint);
+
+			if (owner == this)
+			{
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#endif
+#endif
+			}
+			else
+			{
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+				owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s 觀 %s", GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" : %s 篤 %s", owner->GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s 觀 %s", GetName(), LC_ITEM(item->GetVnum())));
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" : %s 篤 %s", owner->GetName(), LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+				owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s 觀 %s", GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" : %s 篤 %s", owner->GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s 觀 %s", GetName(), LC_ITEM(item->GetVnum())));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" : %s 篤 %s", owner->GetName(), LC_ITEM(item->GetVnum())));
+#endif
+#endif
+			}
+
+			if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
+				|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
+			{
+				quest::CQuestManager::instance().PickupItem(owner->GetPlayerID(), item);
+			}
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
+// 티  크.. exp true msg 構 return false 求 크 (球 verify 逾 return  析 莩 見 漬Ⅸ  斂渼..)
+#define VERIFY_MSG(exp, msg) \
+	if (true == (exp)) \
+	{ \
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(msg)); \
+		return false; \
+	}
+
+bool CHARACTER::SwapItem(WORD wCell, WORD wDestCell)
+{
+	if (!CanHandleItem())
+		return false;
+
+	const TItemPos srcCell(INVENTORY, wCell), destCell(EQUIPMENT, wDestCell);
+
+	// 첫摸 Cell  講
+	// 혼 Swap  퓐, 茱 .
+	//if (bCell >= INVENTORY_MAX_NUM + WEAR_MAX_NUM || bDestCell >= INVENTORY_MAX_NUM + WEAR_MAX_NUM)
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (srcCell.IsDragonSoulEquipPosition() || destCell.IsDragonSoulEquipPosition())
+		return false;
+#endif
+
+	//   창 치 Swap   .
+	if (srcCell.IsEquipPosition() && destCell.IsEquipPosition())
+		return false;
+
+	LPITEM item1 = nullptr, item2 = nullptr;
+
+	// item2 창 獵  풩.
+	if (srcCell.IsEquipPosition())
+	{
+		item1 = GetEquipmentItem(wDestCell);
+		item2 = GetInventoryItem(wCell);
+	}
+	else
+	{
+		item1 = GetInventoryItem(wCell);
+		item2 = GetEquipmentItem(wDestCell);
+	}
+
+	if (!item1 || !item2)
+		return false;
+
+	if (item1 == item2)
+	{
+		sys_log(0, "[WARNING][WARNING][HACK USER!] : %s %d %d", m_stName.c_str(), wCell, wDestCell);
+		return false;
+	}
+
+	// item2 bCell치 載  獵 확磯.
+	if (!IsEmptyItemGrid(TItemPos(INVENTORY, item1->GetCell()), item2->GetSize(), item1->GetCell()))
+		return false;
+
+	// 侮  창 
+	if (TItemPos(EQUIPMENT, item2->GetCell()).IsEquipPosition())
+	{
+		const WORD wEquipCell = item2->GetCell();
+		const WORD wInvenCell = item1->GetCell();
+
+		// The item currently being worn can be removed, and the item planned to be worn
+		// must be in a wearable state in order to proceed.
+		if (!CanUnequipNow(item2, TItemPos(INVENTORY, wEquipCell)) || !CanEquipNow(item1))
+			return false;
+
+		if (wEquipCell != item1->FindEquipCell(this)) // When in the same location, it is only allowed
+			return false;
+
+		item2->RemoveFromCharacter();
+
+		if (item1->EquipTo(this, wEquipCell))
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			item2->AddToCharacter(this, TItemPos(INVENTORY, wInvenCell), false);
+#else
+			item2->AddToCharacter(this, TItemPos(INVENTORY, wInvenCell));
+#endif
+		else
+			sys_err("SwapItem cannot equip %s! item1 %s", item2->GetName(), item1->GetName());
+	}
+	else
+	{
+		const WORD wCell1 = item1->GetCell();
+		const WORD wCell2 = item2->GetCell();
+
+		item1->RemoveFromCharacter();
+		item2->RemoveFromCharacter();
+
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		item1->AddToCharacter(this, TItemPos(EQUIPMENT, wCell2), false);
+		item2->AddToCharacter(this, TItemPos(INVENTORY, wCell1), false);
+#else
+		item1->AddToCharacter(this, TItemPos(INVENTORY, wCell2));
+		item2->AddToCharacter(this, TItemPos(INVENTORY, wCell1));
+#endif
+	}
+
+	return true;
+}
+
+bool CHARACTER::UnequipItem(LPITEM item)
+{
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+	if (item->FindEquipCell(this) == WEAR_WEAPON)
+	{
+		LPITEM pCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
+		if (pCostumeWeapon)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
+			return false;
+		}
+	}
+#endif
+
+	if (false == CanUnequipNow(item))
+		return false;
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	if (item->IsCostumeMount() && item->IsEquipped())
+		UnMount();
+#endif
+
+	int pos;
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (item->IsDragonSoul())
+		pos = GetEmptyDragonSoulInventory(item);
+	else
+#endif
+		pos = GetEmptyInventory(item->GetSize());
+
+	// HARD CODING
+	if (item->GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
+		ShowAlignment(true);
+
+	item->RemoveFromCharacter();
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (item->IsDragonSoul())
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, pos), false);
+#else
+		item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, pos));
+#endif
+	else
+#endif
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		item->AddToCharacter(this, TItemPos(INVENTORY, pos), false);
+#else
+		item->AddToCharacter(this, TItemPos(INVENTORY, pos));
+#endif
+
+	CheckMaximumPoints();
+
+	return true;
+}
+
+//
+// @version 05/07/05 Bang2ni - Skill  1.5  犬   
+//
+bool CHARACTER::EquipItem(LPITEM item, int iCandidateCell)
+{
+	if (item->IsExchanging())
+		return false;
+
+	if (false == item->IsEquipable())
+		return false;
+
+	if (false == CanEquipNow(item))
+		return false;
+
+	int iWearCell = item->FindEquipCell(this, iCandidateCell);
+
+	if (iWearCell < 0)
+		return false;
+
+	// 臍「 탄 쩔 館천 逃 
+	if (iWearCell == WEAR_BODY && IsRiding() && (item->GetVnum() >= 11901 && item->GetVnum() <= 11904))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 탄 쩔    求."));
+		return false;
+	}
+
+	if (iWearCell != WEAR_ARROW && IsPolymorphed())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("逵 傷     求."));
+		return false;
+	}
+
+	if (FN_check_item_sex(this, item) == false)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 刻     求."));
+		return false;
+	}
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum = item->GetTransmutationVnum();
+	if (dwTransmutationVnum != 0)
+	{
+		TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwTransmutationVnum);
+
+		if (!pItemTable->CanUseByJob(GetJob()))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your class."));
+			return false;
+		}
+
+#	if defined(__COSTUME_SYSTEM__)
+		if (pItemTable && pItemTable->IsCostume())
+		{
+			if ((IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_MALE) && SEX_MALE == GET_SEX(this)) ||
+				(IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_FEMALE) && SEX_FEMALE == GET_SEX(this)))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your gender."));
+				return false;
+			}
+		}
+	}
+#	endif
+#endif
+
+	// 킥 탈    肉 체크
+	if (item->IsRideItem())
+	{
+		if (IsRiding())
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 탈 結都求."));
+			return false;
+		}
+
+		if (IsPolymorphed())
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 쩔  탈  求."));
+			return false;
+		}
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+		if (item->IsRideItem())
+		{
+			DWORD dwMountVnum = item->GetMountVnum();
+			if (dwMountVnum > 0 && FindAffect(AFFECT_MOUNT_FALL) == NULL)
+				MountVnum(dwMountVnum);
+		}
+#endif
+	}
+
+	// 화 結餠   챨 풔 킬  1.5 커  체 
+	DWORD dwCurTime = get_dword_time();
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	if (iWearCell != WEAR_ARROW && iWearCell != WEAR_COSTUME_MOUNT
+		&& (dwCurTime - GetLastAttackTime() <= 1500 || dwCurTime - m_dwLastSkillTime <= 1500))
+#else
+	if (iWearCell != WEAR_ARROW
+		&& (dwCurTime - GetLastAttackTime() <= 1500 || dwCurTime - m_dwLastSkillTime <= 1500))
+#endif
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("     笭求."));
+		return false;
+	}
+
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+	if (iWearCell == WEAR_WEAPON)
+	{
+		if (item->GetType() == ITEM_WEAPON)
+		{
+			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
+			if (pkCostumeWeapon && pkCostumeWeapon->GetValue(3) != item->GetSubType())
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
+				return false;
+			}
+		}
+		else
+		{
+			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
+			if (pkCostumeWeapon)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
+				return false;
+			}
+		}
+	}
+	else if (iWearCell == WEAR_COSTUME_WEAPON)
+	{
+		if (item->GetType() == ITEM_COSTUME && item->GetSubType() == COSTUME_WEAPON)
+		{
+			LPITEM pkWeapon = GetWear(WEAR_WEAPON);
+			if (!pkWeapon)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You need to equip a weapon first."));
+				return false;
+			}
+			else if (pkWeapon->GetType() != ITEM_WEAPON || item->GetValue(3) != pkWeapon->GetSubType())
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this costume for this weapon."));
+				return false;
+			}
+		}
+	}
+#endif
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	// 혼 특 처
+	if (item->IsDragonSoul())
+	{
+		//  타 혼 譴 載 獵摸   .
+		// 혼 swap 玖 홴.
+		if (GetEquipmentItem(iWearCell))
+		{
+			ChatPacket(CHAT_TYPE_INFO, "譴   혼 構 笭求.");
+			return false;
+		}
+
+		if (!item->EquipTo(this, iWearCell))
+		{
+			return false;
+		}
+	}
+	// 혼 틈.
+	else
+#endif
+	{
+		//    獵摸,
+		if (GetWear(iWearCell) && !IS_SET(GetWear(iWearCell)->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+		{
+			//   箕   柰. swap   柰
+			//if (item->GetWearFlag() == WEARABLE_ABILITY)
+			//	return false;
+
+			if (!SwapItem(item->GetCell(), iWearCell))
+				return false;
+		}
+		else
+		{
+			BYTE bOldCell = item->GetCell();
+
+			if (item->EquipTo(this, iWearCell))
+				SyncQuickslot(SLOT_TYPE_INVENTORY, bOldCell, iWearCell);
+		}
+	}
+
+	if (true == item->IsEquipped())
+	{
+		//    캤姑  刻틉 챨 풔  처.
+		if (-1 != item->GetProto()->cLimitRealTimeFirstUseIndex)
+		{
+			//  繭   灌 Socket1  풔磯. (Socket1 횟 )
+			if (0 == item->GetSocket(1))
+			{
+				// 諛℃시 Default  Limit Value  溝, Socket0     溝 磯. ( )
+				long duration = (0 != item->GetSocket(0)) ? item->GetSocket(0) : item->GetProto()->aLimits[(BYTE)item->GetProto()->cLimitRealTimeFirstUseIndex].lValue;
+
+				if (0 == duration)
+					duration = 60 * 60 * 24 * 7;
+
+				item->SetSocket(0, time(0) + duration);
+				item->StartRealTimeExpireEvent();
+			}
+
+			item->SetSocket(1, item->GetSocket(1) + 1);
+		}
+
+		if (item->GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
+			ShowAlignment(false);
+
+		if (item->IsRing() || item->IsCostume()
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+			&& !item->IsCostumeMount()
+#endif
+			)
+			ChatPacket(CHAT_TYPE_COMMAND, "OpenCostumeWindow");
+
+		const DWORD& dwVnum = item->GetVnum();
+
+		// 窄떪 遣트 駕쨈 (71135)  트 森
+		if (true == CItemVnumHelper::IsRamadanMoonRing(dwVnum))
+		{
+			this->EffectPacket(SE_EQUIP_RAMADAN_RING);
+		}
+		// 念 (71136)  트 森
+		else if (true == CItemVnumHelper::IsHalloweenCandy(dwVnum))
+		{
+			this->EffectPacket(SE_EQUIP_HALLOWEEN_CANDY);
+		}
+		// 僊 (71143)  트 森
+		else if (true == CItemVnumHelper::IsHappinessRing(dwVnum))
+		{
+			this->EffectPacket(SE_EQUIP_HAPPINESS_RING);
+		}
+		//  年트(71145)  트 森
+		else if (true == CItemVnumHelper::IsLovePendant(dwVnum))
+		{
+			this->EffectPacket(SE_EQUIP_LOVE_PENDANT);
+		}
+		// ITEM_UNIQUE , SpecialItemGroup 풩퓸 斂, (item->GetSIGVnum() != NULL)
+		//
+		else if ((ITEM_UNIQUE == item->GetType() || ITEM_RING == item->GetType()) && 0 != item->GetSIGVnum())
+		{
+			const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(item->GetSIGVnum());
+			if (NULL != pGroup)
+			{
+				const CSpecialAttrGroup* pAttrGroup = ITEM_MANAGER::instance().GetSpecialAttrGroup(pGroup->GetAttrVnum(item->GetVnum()));
+				if (NULL != pAttrGroup)
+				{
+					const std::string& std = pAttrGroup->m_stEffectFileName;
+					SpecificEffectPacket(std.c_str());
+				}
+			}
+		}
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		if ((item->GetType() == ITEM_COSTUME) && (item->GetSubType() == COSTUME_ACCE
+#if defined(__AURA_COSTUME_SYSTEM__)
+			|| item->GetSubType() == COSTUME_AURA
+#endif
+			))
+		{
+			if (item->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) > 18)
+				this->EffectPacket(SE_ACCE_BACK);
+			this->EffectPacket(SE_ACCE_EQUIP);
+		}
+#endif
+
+		if ((ITEM_UNIQUE == item->GetType() && UNIQUE_SPECIAL_RIDE == item->GetSubType() && IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE))
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+			|| (ITEM_COSTUME == item->GetType() && COSTUME_MOUNT == item->GetSubType())
+#endif
+			)
+		{
+			quest::CQuestManager::instance().UseItem(GetPlayerID(), item, false);
+		}
+	}
+
+	return true;
+}
+
+void CHARACTER::BuffOnAttr_AddBuffsFromItem(LPITEM pItem)
+{
+	for (int i = 0; i < sizeof(g_aBuffOnAttrPoints) / sizeof(g_aBuffOnAttrPoints[0]); i++)
+	{
+		TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(g_aBuffOnAttrPoints[i]);
+		if (it != m_map_buff_on_attrs.end())
+		{
+			it->second->AddBuffFromItem(pItem);
+		}
+	}
+}
+
+void CHARACTER::BuffOnAttr_RemoveBuffsFromItem(LPITEM pItem)
+{
+	for (int i = 0; i < sizeof(g_aBuffOnAttrPoints) / sizeof(g_aBuffOnAttrPoints[0]); i++)
+	{
+		TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(g_aBuffOnAttrPoints[i]);
+		if (it != m_map_buff_on_attrs.end())
+		{
+			it->second->RemoveBuffFromItem(pItem);
+		}
+	}
+}
+
+void CHARACTER::BuffOnAttr_ClearAll()
+{
+	for (TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.begin(); it != m_map_buff_on_attrs.end(); ++it)
+	{
+		CBuffOnAttributes* pBuff = it->second;
+		if (pBuff)
+		{
+			pBuff->Initialize();
+		}
+	}
+}
+
+void CHARACTER::BuffOnAttr_ValueChange(POINT_TYPE wPointType, POINT_VALUE llOldValue, POINT_VALUE lNewValue)
+{
+	TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(wPointType);
+
+	if (0 == lNewValue)
+	{
+		if (m_map_buff_on_attrs.end() == it)
+			return;
+		else
+			it->second->Off();
+	}
+	else if (0 == llOldValue)
+	{
+		CBuffOnAttributes* pBuff;
+		if (m_map_buff_on_attrs.end() == it)
+		{
+			switch (wPointType)
+			{
+				case POINT_ENERGY:
+				{
+					static BYTE s_abSlot[] = {
+						WEAR_BODY,
+						WEAR_HEAD,
+						WEAR_FOOTS,
+						WEAR_WRIST,
+						WEAR_WEAPON,
+						WEAR_NECK,
+						WEAR_EAR,
+						WEAR_SHIELD,
+#if defined(__PENDANT_SYSTEM__)
+						WEAR_PENDANT,
+#endif
+#if defined(__GLOVE_SYSTEM__)
+						WEAR_GLOVE,
+#endif
+					};
+					static std::vector<POINT_TYPE> s_vSlots(s_abSlot, s_abSlot + _countof(s_abSlot));
+					pBuff = M2_NEW CBuffOnAttributes(this, wPointType, &s_vSlots);
+				}
+				break;
+
+				case POINT_COSTUME_ATTR_BONUS:
+				{
+					static BYTE s_abSlot[] = {
+						WEAR_COSTUME_BODY,
+						WEAR_COSTUME_HAIR,
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+						WEAR_COSTUME_WEAPON,
+#endif
+					};
+					static std::vector<POINT_TYPE> s_vSlots(s_abSlot, s_abSlot + _countof(s_abSlot));
+					pBuff = M2_NEW CBuffOnAttributes(this, wPointType, &s_vSlots);
+				}
+				break;
+
+				default:
+					break;
+
+			}
+			m_map_buff_on_attrs.insert(TMapBuffOnAttrs::value_type(wPointType, pBuff));
+
+		}
+		else
+			pBuff = it->second;
+
+		pBuff->On(lNewValue);
+	}
+	else
+	{
+		if (m_map_buff_on_attrs.end() == it)
+			return;
+		else
+			it->second->ChangeBuffValue(lNewValue);
+	}
+}
+
+LPITEM CHARACTER::FindSpecifyItem(DWORD dwVnum
+#if defined(__SOUL_BIND_SYSTEM__)
+	, bool bIgnoreSoulBound
+#endif
+#if defined(__SET_ITEM__)
+	, bool bIgnoreSetValue
+#endif
+) const
+{
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+	{
+		if (GetInventoryItem(i) && GetInventoryItem(i)->GetVnum() == dwVnum)
+		{
+#if defined(__SOUL_BIND_SYSTEM__)
+			if (bIgnoreSoulBound && GetInventoryItem(i)->IsSealed())
+				continue;
+#endif
+
+#if defined(__SET_ITEM__)
+			if (bIgnoreSetValue && GetInventoryItem(i)->GetItemSetValue())
+				continue;
+#endif
+			return GetInventoryItem(i);
+		}
+	}
+	return NULL;
+}
+
+LPITEM CHARACTER::FindItemByID(DWORD id) const
+{
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (WORD wCell = 0; wCell < GetExtendInvenMax(); ++wCell)
+#else
+	for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
+#endif
+		if (GetInventoryItem(wCell) && GetInventoryItem(wCell)->GetID() == id)
+			return GetInventoryItem(wCell);
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	for (WORD wCell = 0; wCell < DRAGON_SOUL_INVENTORY_MAX_NUM; ++wCell)
+		if (GetDragonSoulInventoryItem(wCell) && GetDragonSoulInventoryItem(wCell)->GetID() == id)
+			return GetDragonSoulInventoryItem(wCell);
+#endif
+
+	for (WORD wCell = 0; wCell < BELT_INVENTORY_MAX_NUM; ++wCell)
+		if (GetBeltInventoryItem(wCell) && GetBeltInventoryItem(wCell)->GetID() == id)
+			return GetBeltInventoryItem(wCell);
+
+	return NULL;
+}
+
+int CHARACTER::CountSpecifyItem(DWORD vnum, int iExceptionCell
+#if defined(__SOUL_BIND_SYSTEM__)
+	, bool bIgnoreSealedItem
+#endif
+#if defined(__SET_ITEM__)
+	, bool bIgnoreSetValue
+#endif
+) const
+{
+	int iCount = 0;
+	LPITEM pItem = nullptr;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (WORD wCell = 0; wCell < GetExtendInvenMax(); ++wCell)
+#else
+	for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
+#endif
+	{
+		if (wCell == iExceptionCell)
+			continue;
+
+		pItem = GetInventoryItem(wCell);
+		if (pItem && pItem->GetVnum() == vnum)
+		{
+			//   溝 見 耭載.
+			if (m_pkMyShop && m_pkMyShop->IsSellingItem(pItem->GetID()))
+				continue;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+			if (bIgnoreSealedItem && pItem->IsSealed())
+				continue;
+#endif
+
+#if defined(__SET_ITEM__)
+			if (bIgnoreSetValue && pItem->GetItemSetValue())
+				continue;
+#endif
+
+			iCount += pItem->GetCount();
+		}
+	}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	for (WORD wCell = 0; wCell < DRAGON_SOUL_INVENTORY_MAX_NUM; ++wCell)
+	{
+		pItem = GetDragonSoulInventoryItem(wCell);
+		if (pItem && pItem->GetVnum() == vnum)
+		{
+#if defined(__SOUL_BIND_SYSTEM__)
+			if (bIgnoreSealedItem && pItem->IsSealed())
+				continue;
+#endif
+
+			iCount += pItem->GetCount();
+		}
+	}
+#endif
+
+	return iCount;
+}
+
+void CHARACTER::RemoveSpecifyItem(DWORD vnum, DWORD count, int iExceptionCell
+#if defined(__SOUL_BIND_SYSTEM__)
+	, bool bIgnoreSealedItem
+#endif
+#if defined(__SET_ITEM__)
+	, bool bIgnoreSetValue
+#endif
+)
+{
+	if (0 == count)
+		return;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (UINT i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (UINT i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+	{
+		if (i == iExceptionCell)
+			continue;
+
+		if (NULL == GetInventoryItem(i))
+			continue;
+
+		if (GetInventoryItem(i)->GetVnum() != vnum)
+			continue;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+		if (bIgnoreSealedItem && GetInventoryItem(i)->IsSealed())
+			continue;
+#endif
+
+#if defined(__SET_ITEM__)
+		if (bIgnoreSetValue && GetInventoryItem(i)->GetItemSetValue())
+			continue;
+#endif
+
+		//  溝 見 耭載. (  퓔킵  觀   !)
+		if (m_pkMyShop)
+		{
+			bool isItemSelling = m_pkMyShop->IsSellingItem(GetInventoryItem(i)->GetID());
+			if (isItemSelling)
+				continue;
+		}
+
+		if (vnum >= 80003 && vnum <= 80007)
+			LogManager::instance().GoldBarLog(GetPlayerID(), GetInventoryItem(i)->GetID(), QUEST, "RemoveSpecifyItem");
+
+		if (count >= GetInventoryItem(i)->GetCount())
+		{
+			count -= GetInventoryItem(i)->GetCount();
+			GetInventoryItem(i)->SetCount(0);
+
+			if (0 == count)
+				return;
+		}
+		else
+		{
+			GetInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
+			return;
+		}
+	}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	for (UINT i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
+	{
+		if (NULL == GetDragonSoulInventoryItem(i))
+			continue;
+
+		if (GetDragonSoulInventoryItem(i)->GetVnum() != vnum)
+			continue;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+		if (bIgnoreSealedItem && GetDragonSoulInventoryItem(i)->IsSealed())
+			continue;
+#endif
+
+#if defined(__SET_ITEM__)
+		if (bIgnoreSetValue && GetDragonSoulInventoryItem(i)->GetItemSetValue())
+			continue;
+#endif
+
+		if (count >= GetDragonSoulInventoryItem(i)->GetCount())
+		{
+			count -= GetDragonSoulInventoryItem(i)->GetCount();
+			GetDragonSoulInventoryItem(i)->SetCount(0);
+
+			if (0 == count)
+				return;
+		}
+		else
+		{
+			GetDragonSoulInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
+			return;
+		}
+	}
+#endif
+
+	// 처 求.
+	if (count)
+		sys_log(0, "CHARACTER::RemoveSpecifyItem cannot remove enough item vnum %u, still remain %d", vnum, count);
+}
+
+int CHARACTER::CountSpecifyTypeItem(BYTE type) const
+{
+	int count = 0;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (int i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+	{
+		LPITEM pItem = GetInventoryItem(i);
+		if (pItem != NULL && pItem->GetType() == type)
+		{
+			count += pItem->GetCount();
+		}
+	}
+
+	return count;
+}
+
+void CHARACTER::RemoveSpecifyTypeItem(BYTE type, DWORD count)
+{
+	if (0 == count)
+		return;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (UINT i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (UINT i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+	{
+		if (NULL == GetInventoryItem(i))
+			continue;
+
+		if (GetInventoryItem(i)->GetType() != type)
+			continue;
+
+		//  溝 見 耭載. (  퓔킵  觀   !)
+		if (m_pkMyShop)
+		{
+			bool isItemSelling = m_pkMyShop->IsSellingItem(GetInventoryItem(i)->GetID());
+			if (isItemSelling)
+				continue;
+		}
+
+		if (count >= GetInventoryItem(i)->GetCount())
+		{
+			count -= GetInventoryItem(i)->GetCount();
+			GetInventoryItem(i)->SetCount(0);
+
+			if (0 == count)
+				return;
+		}
+		else
+		{
+			GetInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
+			return;
+		}
+	}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	for (UINT i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
+	{
+		if (NULL == GetDragonSoulInventoryItem(i))
+			continue;
+
+		if (GetDragonSoulInventoryItem(i)->GetType() != type)
+			continue;
+
+		if (count >= GetDragonSoulInventoryItem(i)->GetCount())
+		{
+			count -= GetDragonSoulInventoryItem(i)->GetCount();
+			GetDragonSoulInventoryItem(i)->SetCount(0);
+
+			if (0 == count)
+				return;
+		}
+		else
+		{
+			GetDragonSoulInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
+			return;
+		}
+	}
+#endif
+}
+
+// 20200808.Owsap : Fix book stacking while sorting.
+void CHARACTER::GiveSkillBook(DWORD dwSkillVnum, WORD wCount)
+{
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+	{
+		LPITEM pkItem = GetInventoryItem(i);
+
+		if (!pkItem)
+			continue;
+
+		if ((pkItem->GetType() == ITEM_SKILLBOOK || pkItem->GetType() == ITEM_SKILLFORGET) && pkItem->GetSocket(0) == dwSkillVnum)
+		{
+			WORD wCount2 = MIN(ITEM_MAX_COUNT - pkItem->GetCount(), wCount);
+			wCount -= wCount2;
+
+			pkItem->SetCount(pkItem->GetCount() + wCount2);
+			if (wCount == 0)
+				return;
+		}
+	}
+
+	LPITEM pkBookItem = AutoGiveItem(ITEM_SKILLBOOK_VNUM, wCount, false, false);
+	if (NULL != pkBookItem)
+		pkBookItem->SetSocket(0, dwSkillVnum);
+}
+//>
+
+LPITEM CHARACTER::AutoGiveItem(DWORD dwItemVnum, WORD wCount, int iRarePct, bool bMsg
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+	, bool isHighLight
+#endif
+#if defined(__NEW_USER_CARE__)
+	, bool bSystemDrop
+#endif
+)
+{
+	TItemTable* p = ITEM_MANAGER::instance().GetTable(dwItemVnum);
+	if (!p)
+		return NULL;
+
+	DBManager::instance().SendMoneyLog(MONEY_LOG_DROP, dwItemVnum, wCount);
+
+	if (p->dwFlags & ITEM_FLAG_STACKABLE/* && p->bType != ITEM_BLEND*/)
+	{
+		for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+		{
+			LPITEM item = GetInventoryItem(i);
+
+			if (!item)
+				continue;
+
+			if (item->GetVnum() == dwItemVnum && FN_check_item_socket(item))
+			{
+				if (IS_SET(p->dwFlags, ITEM_FLAG_MAKECOUNT))
+				{
+					if (wCount < p->alValues[1])
+						wCount = p->alValues[1];
+				}
+
+				WORD wCount2 = MIN(ITEM_MAX_COUNT - item->GetCount(), wCount);
+				wCount -= wCount2;
+
+				item->SetCount(item->GetCount() + wCount2);
+
+				if (wCount == 0)
+				{
+					if (bMsg)
+					{
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#	if defined(__SET_ITEM__)
+						ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#	else
+						ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#	endif
+#else
+#	if defined(__SET_ITEM__)
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#	else
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#	endif
+#endif
+					}
+
+					return item;
+				}
+			}
+		}
+	}
+
+	LPITEM item = ITEM_MANAGER::instance().CreateItem(dwItemVnum, wCount, 0, true);
+
+	if (!item)
+	{
+		sys_err("cannot create item by vnum %u (name: %s)", dwItemVnum, GetName());
+		return NULL;
+	}
+
+	if (item->GetType() == ITEM_BLEND)
+	{
+		for (int i = 0; i < INVENTORY_MAX_NUM; i++)
+		{
+			LPITEM inv_item = GetInventoryItem(i);
+
+			if (inv_item == NULL)
+				continue;
+
+			if (inv_item->GetType() == ITEM_BLEND)
+			{
+				if (inv_item->GetVnum() == item->GetVnum())
+				{
+					if (inv_item->GetSocket(0) == item->GetSocket(0) &&
+						inv_item->GetSocket(1) == item->GetSocket(1) &&
+						inv_item->GetSocket(2) == item->GetSocket(2) &&
+						inv_item->GetCount() + item->GetCount() <= ITEM_MAX_COUNT)
+					{
+						inv_item->SetCount(inv_item->GetCount() + item->GetCount());
+						M2_DESTROY_ITEM(item);
+						return inv_item;
+					}
+				}
+			}
+		}
+	}
+
+	int iEmptyCell;
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (item->IsDragonSoul())
+		iEmptyCell = GetEmptyDragonSoulInventory(item);
+	else
+#endif
+		iEmptyCell = GetEmptyInventory(item->GetSize());
+
+	if (iEmptyCell != -1)
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+			item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
+		else
+#endif
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell), isHighLight);
+#else
+			item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell));
+#endif
+
+		if (bMsg)
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#endif
+#endif
+
+		LogManager::instance().ItemLog(this, item, "SYSTEM", item->GetName());
+
+		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_POTION)
+		{
+			TQuickslot* pSlot;
+
+			if (GetQuickslot(0, &pSlot) && pSlot->type == SLOT_TYPE_NONE)
+			{
+				TQuickslot slot;
+				slot.type = SLOT_TYPE_INVENTORY;
+				slot.pos = iEmptyCell;
+				SetQuickslot(0, slot);
+			}
+		}
+	}
+	else
+	{
+#if defined(__NEW_USER_CARE__)
+		if (!bSystemDrop)
+		{
+			sys_log(0, "AutoGiveItem: No inventory space, SystemDrop disabled!");
+
+			M2_DESTROY_ITEM(item);
+			return NULL;
+		}
+#endif
+
+		item->AddToGround(GetMapIndex(), GetXYZ());
+		item->StartDestroyEvent();
+		// 티  flag 롸  ,
+		// 觀   底 쩔   트 퓔,
+		// ownership   (300) 磯.
+		if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DROP))
+			item->SetOwnership(this, 300);
+		else
+			item->SetOwnership(this, 60);
+
+		LogManager::instance().ItemLog(this, item, "SYSTEM_DROP", item->GetName());
+	}
+
+	sys_log(0, "7: %d %d", dwItemVnum, wCount);
+	return item;
+}
+
+#define __AUTO_GIVE_ITEM_STACK__
+void CHARACTER::AutoGiveItem(LPITEM item, bool longOwnerShip, bool bMsg
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+	, bool isHighLight
+#endif
+)
+{
+	if (NULL == item)
+	{
+		sys_err("NULL point.");
+		return;
+	}
+
+	if (item->GetOwner())
+	{
+		sys_err("item %d 's owner exists!", item->GetID());
+		return;
+	}
+
+#if defined(__AUTO_GIVE_ITEM_STACK__)
+	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+	{
+		for (WORD i = 0; i < INVENTORY_MAX_NUM; ++i)
+		{
+			LPITEM item2 = GetInventoryItem(i);
+			if (!item2)
+				continue;
+
+			if (item2->GetVnum() != item->GetVnum())
+				continue;
+
+			BYTE j = 0;
+			for (; j < ITEM_SOCKET_MAX_NUM; ++j)
+				if (item2->GetSocket(j) != item->GetSocket(j))
+					break;
+
+			if (j != ITEM_SOCKET_MAX_NUM)
+				continue;
+
+			if (item2->GetCount() >= ITEM_MAX_COUNT)
+				continue;
+
+			WORD wCount = item->GetCount();
+			if (IS_SET(item->GetFlag(), ITEM_FLAG_MAKECOUNT))
+			{
+				if (wCount < item->GetValue(1))
+					wCount = item->GetValue(1);
+			}
+
+			WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
+			wCount -= wCount2;
+			item2->SetCount(item2->GetCount() + wCount2);
+
+			if (wCount == 0)
+			{
+				if (bMsg)
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+					ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+					ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#endif
+#endif
+
+				M2_DESTROY_ITEM(item);
+
+				return;
+			}
+
+			item->SetCount(wCount);
+		}
+	}
+#endif
+
+	int cell;
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (item->IsDragonSoul())
+	{
+		cell = GetEmptyDragonSoulInventory(item);
+	}
+	else
+#endif
+	{
+		cell = GetEmptyInventory(item->GetSize());
+	}
+
+	if (cell != -1)
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+			item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, cell));
+		else
+#endif
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			item->AddToCharacter(this, TItemPos(INVENTORY, cell), isHighLight);
+#else
+			item->AddToCharacter(this, TItemPos(INVENTORY, cell));
+#endif
+
+		if (bMsg)
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_ITEM(item->GetVnum())));
+#endif
+#endif
+
+		LogManager::instance().ItemLog(this, item, "SYSTEM", item->GetName());
+
+		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_POTION)
+		{
+			TQuickslot* pSlot;
+
+			if (GetQuickslot(0, &pSlot) && pSlot->type == SLOT_TYPE_NONE)
+			{
+				TQuickslot slot;
+				slot.type = SLOT_TYPE_INVENTORY;
+				slot.pos = cell;
+				SetQuickslot(0, slot);
+			}
+		}
+	}
+	else
+	{
+		item->AddToGround(GetMapIndex(), GetXYZ());
+		item->StartDestroyEvent();
+
+		if (longOwnerShip)
+			item->SetOwnership(this, 300);
+		else
+			item->SetOwnership(this, 60);
+
+		LogManager::instance().ItemLog(this, item, "SYSTEM_DROP", item->GetName());
+	}
+}
+
+bool CHARACTER::GiveItem(LPCHARACTER victim, TItemPos Cell)
+{
+	if (!CanHandleItem())
+		return false;
+
+	if (IsRunningQuest())
+		return false;
+
+	LPITEM item = GetItem(Cell);
+	if (item && !item->IsExchanging())
+	{
+		if (victim->CanReceiveItem(this, item))
+		{
+			victim->ReceiveItem(this, item);
+			return true;
+		}
+	}
+
+	return false;
+}
+
+bool CHARACTER::CanReceiveItem(LPCHARACTER from, LPITEM item) const
+{
+	if (IsPC())
+		return false;
+
+	// TOO_LONG_DISTANCE_EXCHANGE_BUG_FIX
+	if (DISTANCE_APPROX(GetX() - from->GetX(), GetY() - from->GetY()) > 2000)
+		return false;
+	// END_OF_TOO_LONG_DISTANCE_EXCHANGE_BUG_FIX
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (item->IsSealed())
+	{
+		from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot improve a soulbound item."));
+		return false;
+	}
+#endif
+
+	switch (GetRaceNum())
+	{
+		case fishing::CAMPFIRE_MOB:
+		{
+			if (item->GetType() == ITEM_FISH &&
+				(item->GetSubType() == FISH_ALIVE || item->GetSubType() == FISH_DEAD))
+				return true;
+		}
+		break;
+
+		case fishing::FISHER_MOB:
+		{
+			if (item->GetType() == ITEM_ROD)
+				return true;
+		}
+		break;
+
+		// BUILDING_NPC
+		case BLACKSMITH_WEAPON_MOB:
+		case DEVILTOWER_BLACKSMITH_WEAPON_MOB:
+		{
+			if (item->GetType() == ITEM_WEAPON &&
+				item->GetRefinedVnum())
+				return true;
+			else
+				return false;
+		}
+		break;
+
+		case BLACKSMITH_ARMOR_MOB:
+		case DEVILTOWER_BLACKSMITH_ARMOR_MOB:
+		{
+			if (item->GetType() == ITEM_ARMOR &&
+				(item->GetSubType() == ARMOR_BODY || item->GetSubType() == ARMOR_SHIELD || item->GetSubType() == ARMOR_HEAD) &&
+				item->GetRefinedVnum())
+				return true;
+			else
+				return false;
+		}
+		break;
+
+		case BLACKSMITH_ACCESSORY_MOB:
+		case DEVILTOWER_BLACKSMITH_ACCESSORY_MOB:
+		{
+			if (item->GetType() == ITEM_ARMOR &&
+				!(item->GetSubType() == ARMOR_BODY || item->GetSubType() == ARMOR_SHIELD || item->GetSubType() == ARMOR_HEAD) &&
+				item->GetRefinedVnum())
+				return true;
+			else
+				return false;
+		}
+		break;
+		// END_OF_BUILDING_NPC
+
+		case BLACKSMITH_MOB:
+		{
+			if (item->GetRefinedVnum() && item->GetRefineSet() < 500)
+				return true;
+			else
+				return false;
+		}
+		break;
+
+		case BLACKSMITH2_MOB:
+		{
+			if (item->GetRefineSet() >= 500)
+				return true;
+			else
+				return false;
+		}
+		break;
+
+		case ALCHEMIST_MOB:
+		{
+			if (item->GetRefinedVnum())
+				return true;
+		}
+		break;
+
+		case 20101:
+		case 20102:
+		case 20103:
+		{
+			// 珂 
+			if (item->GetVnum() == ITEM_REVIVE_HORSE_1)
+			{
+				if (!IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   訶   求."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_1)
+			{
+				if (IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  搔   求."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_2 || item->GetVnum() == ITEM_HORSE_FOOD_3)
+			{
+				return false;
+			}
+		}
+		break;
+
+		case 20104:
+		case 20105:
+		case 20106:
+		{
+			// 薩 
+			if (item->GetVnum() == ITEM_REVIVE_HORSE_2)
+			{
+				if (!IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   訶   求."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_2)
+			{
+				if (IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  搔   求."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 || item->GetVnum() == ITEM_HORSE_FOOD_3)
+			{
+				return false;
+			}
+		}
+		break;
+
+		case 20107:
+		case 20108:
+		case 20109:
+		{
+			//  
+			if (item->GetVnum() == ITEM_REVIVE_HORSE_3)
+			{
+				if (!IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   訶   求."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_3)
+			{
+				if (IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  搔   求."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 || item->GetVnum() == ITEM_HORSE_FOOD_2)
+			{
+				return false;
+			}
+		}
+		break;
+
+		default:
+			break;
+	}
+
+	//if (IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_GIVE))
+	{
+		return true;
+	}
+
+	return false;
+}
+
+void CHARACTER::ReceiveItem(LPCHARACTER from, LPITEM item)
+{
+	if (IsPC())
+		return;
+
+	switch (GetRaceNum())
+	{
+		case fishing::CAMPFIRE_MOB:
+		{
+			if (item->GetType() == ITEM_FISH && (item->GetSubType() == FISH_ALIVE || item->GetSubType() == FISH_DEAD))
+				fishing::Grill(from, item);
+			else
+			{
+				// TAKE_ITEM_BUG_FIX
+				from->SetQuestNPCID(GetVID());
+				// END_OF_TAKE_ITEM_BUG_FIX
+				quest::CQuestManager::instance().TakeItem(from->GetPlayerID(), GetRaceNum(), item);
+			}
+		}
+		break;
+
+#ifdef ENABLE_QUEEN_NETHIS
+		case SnakeLair::PILAR_STEP_4:
+			{
+				if(from->IsPC())
+				{
+					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
+						SnakeLair::CSnk::instance().OnKillPilar(item, from, this);
+				}
+			}
+			break;
+		case SnakeLair::BLACKSMITH_5:
+			{
+				if(from->IsPC())
+				{
+					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
+						SnakeLair::CSnk::instance().OnKillBlackSmith(item, from, this);
+				}
+			}
+			break;
+
+		case SnakeLair::SNAKE_STATUE1:
+		case SnakeLair::SNAKE_STATUE2:
+		case SnakeLair::SNAKE_STATUE3:
+		case SnakeLair::SNAKE_STATUE4:
+			{
+				if(from->IsPC())
+				{
+					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
+						SnakeLair::CSnk::instance().OnStatueSetRotation(item, from, this);
+				}
+			}
+			break;
+#endif
+
+		// DEVILTOWER_NPC
+		case DEVILTOWER_BLACKSMITH_WEAPON_MOB:
+		case DEVILTOWER_BLACKSMITH_ARMOR_MOB:
+		case DEVILTOWER_BLACKSMITH_ACCESSORY_MOB:
+		{
+			if (item->GetRefinedVnum() != 0 && item->GetRefineSet() != 0 && item->GetRefineSet() < 500)
+			{
+				from->SetRefineNPC(this);
+				from->RefineInformation(item->GetCell(), REFINE_TYPE_MONEY_ONLY);
+			}
+			else
+			{
+				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+			}
+		}
+		break;
+		// END_OF_DEVILTOWER_NPC
+
+		case BLACKSMITH_MOB:
+		case BLACKSMITH2_MOB:
+		case BLACKSMITH_WEAPON_MOB:
+		case BLACKSMITH_ARMOR_MOB:
+		case BLACKSMITH_ACCESSORY_MOB:
+		{
+			if (item->GetRefinedVnum())
+			{
+				from->SetRefineNPC(this);
+				from->RefineInformation(item->GetCell(), REFINE_TYPE_NORMAL);
+			}
+			else
+			{
+				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+			}
+		}
+		break;
+
+		case 20101:
+		case 20102:
+		case 20103:
+		case 20104:
+		case 20105:
+		case 20106:
+		case 20107:
+		case 20108:
+		case 20109:
+		{
+			if (item->GetVnum() == ITEM_REVIVE_HORSE_1 ||
+				item->GetVnum() == ITEM_REVIVE_HORSE_2 ||
+				item->GetVnum() == ITEM_REVIVE_HORSE_3)
+			{
+				from->ReviveHorse();
+				item->SetCount(item->GetCount() - 1);
+				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 訶 羚求."));
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 ||
+				item->GetVnum() == ITEM_HORSE_FOOD_2 ||
+				item->GetVnum() == ITEM_HORSE_FOOD_3)
+			{
+				from->FeedHorse();
+				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 搔 羚求."));
+				item->SetCount(item->GetCount() - 1);
+				EffectPacket(SE_HPUP_RED);
+			}
+		}
+		break;
+
+		default:
+		{
+			sys_log(0, "TakeItem %s %d %s", from->GetName(), GetRaceNum(), item->GetName());
+			from->SetQuestNPCID(GetVID());
+			quest::CQuestManager::instance().TakeItem(from->GetPlayerID(), GetRaceNum(), item);
+		}
+		break;
+	}
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	if (CGuildDragonLairManager::Instance().IsRedDragonLair(from->GetMapIndex())
+		&& CGuildDragonLairManager::Instance().IsStone(GetRaceNum()))
+	{
+		if (item->GetVnum() == ITEM_GUILD_DRAGONLAIR_RING)
+		{
+			sys_log(0, "GuildDragonLair TakeItem %s %d %s", from->GetName(), GetRaceNum(), item->GetName());
+
+			if (from->GetGuildDragonLair())
+				from->GetGuildDragonLair()->TakeItem(from, this, item);
+		}
+	}
+#endif
+}
+
+bool CHARACTER::IsEquipUniqueItem(DWORD dwItemVnum) const
+{
+	{
+		LPITEM u = GetWear(WEAR_UNIQUE1);
+
+		if (u && u->GetVnum() == dwItemVnum)
+			return true;
+	}
+
+	{
+		LPITEM u = GetWear(WEAR_UNIQUE2);
+
+		if (u && u->GetVnum() == dwItemVnum)
+			return true;
+	}
+
+	return false;
+}
+
+// CHECK_UNIQUE_GROUP
+bool CHARACTER::IsEquipUniqueGroup(DWORD dwGroupVnum) const
+{
+	{
+		LPITEM u = GetWear(WEAR_UNIQUE1);
+
+		if (u && u->GetSpecialGroup() == (int)dwGroupVnum)
+			return true;
+	}
+
+	{
+		LPITEM u = GetWear(WEAR_UNIQUE2);
+
+		if (u && u->GetSpecialGroup() == (int)dwGroupVnum)
+			return true;
+	}
+
+	return false;
+}
+// END_OF_CHECK_UNIQUE_GROUP
+
+void CHARACTER::SetRefineMode(int iAdditionalCell)
+{
+	m_iRefineAdditionalCell = iAdditionalCell;
+	SetUnderRefine(true);
+}
+
+void CHARACTER::ClearRefineMode()
+{
+	SetUnderRefine(false);
+	SetRefineNPC(NULL);
+}
+
+//bool CHARACTER::GiveItemFromSpecialItemGroup(DWORD dwGroupNum, std::vector<DWORD>& dwItemVnums,
+//	std::vector<DWORD>& dwItemCounts, std::vector <LPITEM>& item_gets, int& count)
+bool CHARACTER::GiveItemFromSpecialItemGroup(DWORD dwGroupNum)
+{
+	const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(dwGroupNum);
+
+	if (!pGroup)
+	{
+		sys_err("cannot find special item group %d", dwGroupNum);
+		return false;
+	}
+
+	std::vector<int> idxes;
+	int n = pGroup->GetMultiIndex(idxes);
+
+	bool bSuccess = false;
+
+	for (int i = 0; i < n; i++)
+	{
+		bSuccess = false;
+		int idx = idxes[i];
+		DWORD dwVnum = pGroup->GetVnum(idx);
+		DWORD dwCount = pGroup->GetCount(idx);
+		int iRarePct = pGroup->GetRarePct(idx);
+		LPITEM item_get = NULL;
+		switch (dwVnum)
+		{
+			case CSpecialItemGroup::GOLD:
+			{
+				PointChange(POINT_GOLD, dwCount, true);
+				LogManager::instance().CharLog(this, dwCount, "TREASURE_GOLD", "");
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::EXP:
+			{
+				PointChange(POINT_EXP, dwCount);
+				LogManager::instance().CharLog(this, dwCount, "TREASURE_EXP", "");
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::MOB:
+			{
+				sys_log(0, "CSpecialItemGroup::MOB %d", dwCount);
+				int x = GetX() + number(-500, 500);
+				int y = GetY() + number(-500, 500);
+
+				LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(dwCount, GetMapIndex(), x, y, 0, true, -1);
+				if (ch)
+					ch->SetAggressive();
+				else
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("This doesn't seem to work here."));
+					return false;
+				}
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("悶 叩 타求!"));
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::SLOW:
+			{
+				sys_log(0, "CSpecialItemGroup::SLOW %d", -(int)dwCount);
+				AddAffect(AFFECT_SLOW, POINT_MOV_SPEED, -(int)dwCount, AFF_SLOW, 300, 0, true);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("悶   綬 見 甄 撻 求!"));
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::DRAIN_HP:
+			{
+				int iDropHP = GetMaxHP() * dwCount / 100;
+				sys_log(0, "CSpecialItemGroup::DRAIN_HP %d", -iDropHP);
+				iDropHP = MIN(iDropHP, GetHP() - 1);
+				sys_log(0, "CSpecialItemGroup::DRAIN_HP %d", -iDropHP);
+				PointChange(POINT_HP, -iDropHP);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("微 未 臼求!  颯求."));
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::POISON:
+			{
+				AttackedByPoison(NULL);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("悶   綬 見  쨍 求!"));
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::BLEEDING:
+			{
+				AttackedByBleeding(NULL);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("悶   綬 見 甄 撻 求!"));
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::MOB_GROUP:
+			{
+				int sx = GetX() - number(300, 500);
+				int sy = GetY() - number(300, 500);
+				int ex = GetX() + number(300, 500);
+				int ey = GetY() + number(300, 500);
+				LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnGroup(dwCount, GetMapIndex(), sx, sy, ex, ey, NULL, true);
+				if (!ch)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("This doesn't seem to work here."));
+					return false;
+				}
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("悶 叩 타求!"));
+				bSuccess = true;
+			}
+			break;
+
+			default:
+			{
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+				item_get = AutoGiveItem(dwVnum, dwCount, iRarePct, true, true);
+#else
+				item_get = AutoGiveItem(dwVnum, dwCount, iRarePct);
+#endif
+				if (item_get)
+					bSuccess = true;
+			}
+			break;
+		}
+
+		if (!bSuccess)
+		{
+			ChatPacket(CHAT_TYPE_TALKING, LC_STRING("틜孤   求."));
+			return false;
+		}
+	}
+	return bSuccess;
+}
+
+// NEW_HAIR_STYLE_ADD
+bool CHARACTER::ItemProcess_Hair(LPITEM item, int iDestCell)
+{
+	if (item->CheckItemUseLevel(GetLevel()) == false)
+	{
+		//  肌 
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("  疸    都求."));
+		return false;
+	}
+
+	DWORD hair = item->GetVnum();
+
+	switch (GetJob())
+	{
+		case JOB_WARRIOR:
+			hair -= 72000; // 73001 - 72000 = 1001   호 
+			break;
+
+		case JOB_ASSASSIN:
+			hair -= 71250;
+			break;
+
+		case JOB_SURA:
+			hair -= 70500;
+			break;
+
+		case JOB_SHAMAN:
+			hair -= 69750;
+			break;
+
+		case JOB_WOLFMAN:
+			break;
+
+		default:
+			return false;
+			break;
+	}
+
+	if (hair == GetPart(PART_HAIR))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 疸 타狗灌 체  求."));
+		return true;
+	}
+
+	item->SetCount(item->GetCount() - 1);
+
+	SetPart(PART_HAIR, hair);
+	UpdatePacket();
+
+	return true;
+}
+// END_NEW_HAIR_STYLE_ADD
+
+bool CHARACTER::ItemProcess_Polymorph(LPITEM item)
+{
+	if (IsPolymorphed())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("譴 逵 都求."));
+		return false;
+	}
+
+	if (true == IsRiding())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("逵   都求."));
+		return false;
+	}
+
+	DWORD dwVnum = item->GetSocket(0);
+
+	if (dwVnum == 0)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("蔘 逵 都求."));
+		item->SetCount(item->GetCount() - 1);
+		return false;
+	}
+
+	const CMob* pMob = CMobManager::instance().Get(dwVnum);
+
+	if (pMob == NULL)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("蔘 逵 都求."));
+		item->SetCount(item->GetCount() - 1);
+		return false;
+	}
+
+	switch (item->GetVnum())
+	{
+		case 70104: // Polymorph Marble
+		case 70105: // Polymorph Marble
+		case 70106: // Polymorph Marble
+		case 70107: // Polymorph Marble
+		case 71093: // Polymorph Marble
+		{
+			// 逵 처
+			sys_log(0, "USE_POLYMORPH_BALL PID(%d) vnum(%d)", GetPlayerID(), dwVnum);
+
+			//   체크
+			int iPolymorphLevelLimit = MAX(0, 20 - GetLevel() * 3 / 10);
+			if (pMob->m_table.bLevel >= GetLevel() + iPolymorphLevelLimit)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 賈   庫灌    求."));
+				return false;
+			}
+
+			int iDuration = GetSkillLevel(POLYMORPH_SKILL_ID) == 0 ? 5 : (5 + (5 + GetSkillLevel(POLYMORPH_SKILL_ID) / 40 * 25));
+			iDuration *= 60;
+
+			DWORD dwBonus = 0;
+
+			if (true == LC_IsYMIR() || true == LC_IsKorea())
+			{
+				dwBonus = GetSkillLevel(POLYMORPH_SKILL_ID) + 60;
+			}
+			else
+			{
+				dwBonus = (2 + GetSkillLevel(POLYMORPH_SKILL_ID) / 40) * 100;
+			}
+
+			AddAffect(AFFECT_POLYMORPH, POINT_POLYMORPH, dwVnum, AFF_POLYMORPH, iDuration, 0, true);
+			AddAffect(AFFECT_POLYMORPH, POINT_ATT_BONUS, dwBonus, AFF_POLYMORPH, iDuration, 0, false);
+
+			item->SetCount(item->GetCount() - 1);
+		}
+		break;
+
+		case 50322: // Transformation Role
+		{
+			// 
+
+			// 逵 처
+			// 0 1 2
+			// 逵  호  逵 
+			sys_log(0, "USE_POLYMORPH_BOOK: %s(%u) vnum(%u)", GetName(), GetPlayerID(), dwVnum);
+
+			if (CPolymorphUtils::instance().PolymorphCharacter(this, item, pMob) == true)
+			{
+				CPolymorphUtils::instance().UpdateBookPracticeGrade(this, item);
+			}
+			else
+			{
+			}
+		}
+		break;
+
+		default:
+			sys_err("POLYMORPH invalid item passed PID(%d) vnum(%d)", GetPlayerID(), item->GetOriginalVnum());
+			return false;
+	}
+
+	return true;
+}
+
+bool CHARACTER::CanDoCube() const
+{
+	if (m_bIsObserver) return false;
+	if (GetShop()) return false;
+	if (GetMyShop()) return false;
+	if (IsUnderRefine()) return false;
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	if (IsUnderRefineElement()) return false;
+#endif
+	if (IsWarping()) return false;
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	if (IsAcceRefineWindowOpen()) return false;
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	if (IsAuraRefineWindowOpen()) return false;
+#endif
+
+	return true;
+}
+
+bool CHARACTER::UnEquipSpecialRideUniqueItem()
+{
+	LPITEM Unique1 = GetWear(WEAR_UNIQUE1);
+	LPITEM Unique2 = GetWear(WEAR_UNIQUE2);
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	LPITEM MountCostume = GetWear(WEAR_COSTUME_MOUNT);
+#endif
+
+	if (NULL != Unique1)
+	{
+		if (UNIQUE_GROUP_SPECIAL_RIDE == Unique1->GetSpecialGroup())
+		{
+			return UnequipItem(Unique1);
+		}
+	}
+
+	if (NULL != Unique2)
+	{
+		if (UNIQUE_GROUP_SPECIAL_RIDE == Unique2->GetSpecialGroup())
+		{
+			return UnequipItem(Unique2);
+		}
+	}
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	if (MountCostume)
+		return UnequipItem(MountCostume);
+#endif
+
+	return true;
+}
+
+void CHARACTER::AutoRecoveryItemProcess(const EAffectTypes type)
+{
+	if (true == IsDead() || true == IsStun())
+		return;
+
+	if (false == IsPC())
+		return;
+
+	if (AFFECT_AUTO_HP_RECOVERY != type && AFFECT_AUTO_SP_RECOVERY != type)
+		return;
+
+	if (NULL != FindAffect(AFFECT_STUN))
+		return;
+
+	{
+		const DWORD stunSkills[] = { SKILL_TANHWAN, SKILL_GEOMPUNG, SKILL_BYEURAK, SKILL_GIGUNG };
+
+		for (size_t i = 0; i < sizeof(stunSkills) / sizeof(DWORD); ++i)
+		{
+			const CAffect* p = FindAffect(stunSkills[i]);
+
+			if (NULL != p && AFF_STUN == p->dwFlag)
+				return;
+		}
+	}
+
+	const CAffect* pAffect = FindAffect(type);
+	const size_t idx_of_amount_of_used = 1;
+	const size_t idx_of_amount_of_full = 2;
+
+	if (NULL != pAffect)
+	{
+		LPITEM pItem = FindItemByID(pAffect->dwFlag);
+
+		if ((NULL != pItem) && (pItem->GetSocket(0) > 0))
+		{
+			if (false == CArenaManager::instance().IsArenaMap(GetMapIndex()))
+			{
+				const long amount_of_used = pItem->GetSocket(idx_of_amount_of_used);
+				const long amount_of_full = pItem->GetSocket(idx_of_amount_of_full);
+
+				const int32_t avail = amount_of_full - amount_of_used;
+
+				int32_t amount = 0;
+
+				if (AFFECT_AUTO_HP_RECOVERY == type)
+				{
+					amount = GetMaxHP() - (GetHP() + GetPoint(POINT_HP_RECOVERY));
+				}
+				else if (AFFECT_AUTO_SP_RECOVERY == type)
+				{
+					amount = GetMaxSP() - (GetSP() + GetPoint(POINT_SP_RECOVERY));
+				}
+
+				if (amount > 0)
+				{
+					if (avail > amount)
+					{
+						const int pct_of_used = amount_of_used * 100 / amount_of_full;
+						const int pct_of_will_used = (amount_of_used + amount) * 100 / amount_of_full;
+
+						bool bLog = false;
+						// 酉 10%  慣琉 
+						// (酉 %,  美 侮  慣琉 .)
+						if ((pct_of_will_used / 10) - (pct_of_used / 10) >= 1)
+							bLog = true;
+						pItem->SetSocket(idx_of_amount_of_used, amount_of_used + amount, bLog);
+					}
+					else
+					{
+						amount = avail;
+
+#if defined(__USE_NEXT_AUTO_POTION__)
+						for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
+						{
+							LPITEM pkNextItem = GetInventoryItem(wCell);
+							if (NULL == pkNextItem)
+								continue;
+
+							if (pItem->GetWindow() == pkNextItem->GetWindow() && pItem->GetCell() != pkNextItem->GetCell())
+							{
+								UseItemEx(pkNextItem, TItemPos(INVENTORY, wCell));
+								break;
+							}
+						}
+#endif
+
+						ITEM_MANAGER::instance().RemoveItem(pItem);
+					}
+
+					if (AFFECT_AUTO_HP_RECOVERY == type)
+					{
+						PointChange(POINT_HP_RECOVERY, amount);
+						EffectPacket(SE_AUTO_HPUP);
+					}
+					else if (AFFECT_AUTO_SP_RECOVERY == type)
+					{
+						PointChange(POINT_SP_RECOVERY, amount);
+						EffectPacket(SE_AUTO_SPUP);
+					}
+				}
+			}
+			else
+			{
+				pItem->Lock(false);
+				pItem->SetSocket(0, false);
+				RemoveAffect(const_cast<CAffect*>(pAffect));
+			}
+		}
+		else
+		{
+			RemoveAffect(const_cast<CAffect*>(pAffect));
+		}
+	}
+}
+
+bool CHARACTER::IsValidItemPosition(TItemPos Pos) const
+{
+	BYTE window_type = Pos.window_type;
+	WORD cell = Pos.cell;
+
+	switch (window_type)
+	{
+		case INVENTORY:
+			return cell < INVENTORY_MAX_NUM;
+
+		case EQUIPMENT:
+			return cell < EQUIPMENT_MAX_NUM;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case DRAGON_SOUL_INVENTORY:
+			return cell < DRAGON_SOUL_INVENTORY_MAX_NUM;
+#endif
+
+		case BELT_INVENTORY:
+			return cell < BELT_INVENTORY_MAX_NUM;
+
+		case SAFEBOX:
+			if (NULL != m_pkSafebox)
+				return m_pkSafebox->IsValidPosition(cell);
+			else
+				return false;
+
+		case MALL:
+			if (NULL != m_pkMall)
+				return m_pkMall->IsValidPosition(cell);
+			else
+				return false;
+
+#if defined(__ATTR_6TH_7TH__)
+		case NPC_STORAGE:
+			return cell < NPC_STORAGE_SLOT_MAX;
+#endif
+
+		default:
+			return false;
+	}
+}
+
+///  캐 쨍  羚 item   獵  확構, 柰 求摸 캐沽  腔獵 獨
+bool CHARACTER::CanEquipNow(const LPITEM item, const TItemPos& srcCell, const TItemPos& destCell) /*const*/
+{
+	if (IsFishing())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
+		return false;
+	}
+
+	const TItemTable* itemTable = item->GetProto();
+	//BYTE itemType = item->GetType();
+	//BYTE itemSubType = item->GetSubType();
+
+	switch (GetJob())
+	{
+		case JOB_WARRIOR:
+			if (item->GetAntiFlag() & ITEM_ANTIFLAG_WARRIOR)
+				return false;
+			break;
+
+		case JOB_ASSASSIN:
+			if (item->GetAntiFlag() & ITEM_ANTIFLAG_ASSASSIN)
+				return false;
+			break;
+
+		case JOB_SHAMAN:
+			if (item->GetAntiFlag() & ITEM_ANTIFLAG_SHAMAN)
+				return false;
+			break;
+
+		case JOB_SURA:
+			if (item->GetAntiFlag() & ITEM_ANTIFLAG_SURA)
+				return false;
+			break;
+
+		case JOB_WOLFMAN:
+			if (item->GetAntiFlag() & ITEM_ANTIFLAG_WOLFMAN)
+				return false;
+			break;
+
+	}
+
+	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+	{
+		long limit = itemTable->aLimits[i].lValue;
+		switch (itemTable->aLimits[i].bType)
+		{
+			case LIMIT_LEVEL:
+			{
+				if (GetLevel() < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+					return false;
+				}
+			}
+			break;
+
+#if defined(__CONQUEROR_LEVEL__)
+			case LIMIT_NEWWORLD_LEVEL:
+			{
+				if (GetConquerorLevel() < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+					return false;
+				}
+			}
+			break;
+#endif
+
+			case LIMIT_STR:
+			{
+				if (GetPoint(POINT_ST) < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("慕    求."));
+					return false;
+				}
+			}
+			break;
+
+			case LIMIT_INT:
+			{
+				if (GetPoint(POINT_IQ) < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    求."));
+					return false;
+				}
+			}
+			break;
+
+			case LIMIT_DEX:
+			{
+				if (GetPoint(POINT_DX) < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("첩    求."));
+					return false;
+				}
+			}
+			break;
+
+			case LIMIT_CON:
+			{
+				if (GetPoint(POINT_HT) < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("체    求."));
+					return false;
+				}
+			}
+			break;
+		}
+	}
+
+	if (item->GetWearFlag() & WEARABLE_UNIQUE)
+	{
+		if ((GetWear(WEAR_UNIQUE1) && GetWear(WEAR_UNIQUE1)->IsSameSpecialGroup(item)) ||
+			(GetWear(WEAR_UNIQUE2) && GetWear(WEAR_UNIQUE2)->IsSameSpecialGroup(item)))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  크    첼   求."));
+			return false;
+		}
+
+		if (marriage::CManager::instance().IsMarriageUniqueItem(item->GetVnum()) &&
+			!marriage::CManager::instance().IsMarried(GetPlayerID()))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("혼  쩔    求."));
+			return false;
+		}
+	}
+
+#if defined(__PET_SYSTEM__)
+	if (item->IsPet() && SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::PET_BLOCK_MAP_INDEX, GetMapIndex()))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
+		return false;
+	}
+#endif
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	if (item->IsCostumeMount() && SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX, GetMapIndex()))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
+		return false;
+	}
+#endif
+
+	return true;
+}
+
+///  캐 쨍    item   獵  확構, 柰 求摸 캐沽  腔獵 獨
+bool CHARACTER::CanUnequipNow(const LPITEM item, const TItemPos& srcCell, const TItemPos& destCell) /*const*/
+//bool CHARACTER::CanUnequipNow(const LPITEM item, const TItemPos& swapCell) /*const*/
+{
+	if (item->IsBelt())
+	{
+		if (CBeltInventoryHelper::IsExistItemInBeltInventory(this))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can only discard the belt when there are no longer any items in its inventory."));
+			return false;
+		}
+	}
+
+	//     
+	if (IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+		return false;
+
+	if (IsFishing())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
+		return false;
+	}
+
+	//  unequip 觀訝 킥   美 獵  확
+	{
+		int pos = -1;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+			pos = GetEmptyDragonSoulInventory(item);
+		else
+#endif
+			pos = GetEmptyInventory(item->GetSize());
+
+		if (-1 == pos)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("품   求."));
+			return false;
+		}
+	}
+
+	return true;
+}
+
+#ifdef __OFFLINE_SHOP__
+bool CHARACTER::UseItemOpenOfflineShop(CItem* item)
+{
+	if (!item) {
+		return false;
+	}
+
+	if (IsOpeningOfflineShop()) {
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ZATEN_PAZAR_ACIYORSUN"));
+		return false;
+	}
+
+	item->Lock(true);
+	SetOpeningOfflineShopState(true);
+	SetOfflineShopOpeningItem(item);
+
+	ChatPacket(CHAT_TYPE_COMMAND, "StartOpeningOfflineShop %d %lld",
+		item->GetValue(COfflineShop::ITEM_TIME_IDX), item->GetValue(COfflineShop::ITEM_GOLD_IDX));
+
+	return true;
+}
+#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+void CHARACTER::OpenItemComb()
+{
+	if (PreventTradeWindow(WND_ALL))
+	{
+		ChatPacket(CHAT_TYPE_INFO, "You have to close other windows.");
+		return;
+	}
+
+	const LPCHARACTER npc = GetQuestNPC();
+	if (npc == NULL)
+	{
+		sys_err("Item Combination NPC is NULL (ch: %s)", GetName());
+		return;
+	}
+
+	SetItemCombNpc(npc);
+	ChatPacket(CHAT_TYPE_COMMAND, "ShowItemCombinationDialog");
+}
+
+void CHARACTER::ItemCombination(const short MediumIndex, const short BaseIndex, const short MaterialIndex)
+{
+	if (IsItemComb() == false)
+		return;
+
+	const LPITEM MediumItem = GetItem(TItemPos(INVENTORY, MediumIndex));
+	const LPITEM BaseItem = GetItem(TItemPos(INVENTORY, BaseIndex));
+	const LPITEM MaterialItem = GetItem(TItemPos(INVENTORY, MaterialIndex));
+
+	if (MediumItem == NULL || BaseItem == NULL || MaterialItem == NULL)
+		return;
+
+	if (BaseItem->GetCount() > 1 || MaterialItem->GetCount() > 1)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Split the items first. You cannot use stacked items here."));
+		return;
+	}
+
+	if (MediumItem->GetType() != ITEM_MEDIUM)
+		return;
+
+	if (BaseItem->GetType() != MaterialItem->GetType())
+		return;
+
+	if (BaseItem->GetSubType() != MaterialItem->GetSubType())
+		return;
+
+	if (BaseItem->GetType() != EItemTypes::ITEM_COSTUME || MaterialItem->GetType() != EItemTypes::ITEM_COSTUME)
+		return;
+
+	if (BaseItem->IsEquipped() || MaterialItem->IsEquipped())
+		return;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (BaseItem->IsSealed() || MaterialItem->IsSealed())
+		return;
+#endif
+
+	if (MediumItem->GetSubType() == MEDIUM_MOVE_COSTUME_ATTR)
+	{
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+		if (BaseItem->GetSubType() == COSTUME_MOUNT || MaterialItem->GetSubType() == COSTUME_MOUNT)
+			return;
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		if (BaseItem->GetSubType() == COSTUME_ACCE || MaterialItem->GetSubType() == COSTUME_ACCE)
+			return;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+		if (BaseItem->GetSubType() == COSTUME_AURA || MaterialItem->GetSubType() == COSTUME_AURA)
+			return;
+#endif
+
+		BaseItem->SetAttributes(MaterialItem->GetAttributes());
+		BaseItem->UpdatePacket();
+
+		ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
+		MediumItem->SetCount(MediumItem->GetCount() - 1);
+	}
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	else if (MediumItem->GetSubType() == MEDIUM_MOVE_ACCE_ATTR)
+	{
+		if (MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_ITEM_VNUM) == 0)
+		{
+			if (MaterialItem->GetAttributeCount() == 0)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use a sash without a bonus as the source."));
+				return;
+			}
+		}
+
+		if (BaseItem->GetAttributeCount() > 0)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use a sash with a bonus for the target."));
+			return;
+		}
+
+		if (BaseItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) != MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot transfer the bonus as the sashes have different absorption rates."));
+			return;
+		}
+
+		if (BaseItem->FindApplyValue(APPLY_ACCEDRAIN_RATE) != MaterialItem->FindApplyValue(APPLY_ACCEDRAIN_RATE))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot transfer the bonus as the sashes have different grades."));
+			return;
+		}
+
+		int iRandom = number(0, EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_MAX - 1);
+		switch (iRandom)
+		{
+			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_FAIL:
+			{
+				MaterialItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE, MAX(MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) - 1, 11));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Failure! The absorption rate was reduced by 1%."));
+			}
+			break;
+
+			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_PARTIAL:
+			{
+				BaseItem->SetSockets(MaterialItem->GetSockets());
+				BaseItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE, MAX(MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) - 1, 11));
+				BaseItem->SetAttributes(MaterialItem->GetAttributes());
+#if defined(__ITEM_APPLY_RANDOM__)
+				MaterialItem->CopyRandomAppliesTo(BaseItem);
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				MaterialItem->CopyElementTo(BaseItem);
+#endif
+				BaseItem->UpdatePacket();
+
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Partial success! The absorption rate was reduced by 1%."));
+				ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
+			}
+			break;
+
+			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_SUCCESS:
+			{
+				BaseItem->SetSockets(MaterialItem->GetSockets());
+				BaseItem->SetAttributes(MaterialItem->GetAttributes());
+#if defined(__ITEM_APPLY_RANDOM__)
+				MaterialItem->CopyRandomAppliesTo(BaseItem);
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				MaterialItem->CopyElementTo(BaseItem);
+#endif
+				BaseItem->UpdatePacket();
+
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Success! The bonus was transferred successfully."));
+				ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
+			}
+			break;
+		}
+
+		MediumItem->SetCount(MediumItem->GetCount() - 1);
+	}
+#endif
+}
+#endif
+
+#if defined(__CHANGED_ATTR__)
+void CHARACTER::SelectAttr(LPITEM material, LPITEM item)
+{
+	const LPDESC d = GetDesc();
+	if (d == nullptr)
+		return;
+
+	if (PreventTradeWindow(WND_ALL))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot upgrade anything while another window is open."));
+		return;
+	}
+
+	if (item->GetAttributeSetIndex() == -1)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("憺    都求."));
+		return;
+	}
+
+	if (item->GetAttributeCount() < 1)
+		return;
+
+	const TItemPos pos(item->GetWindow(), item->GetCell());
+	if (pos.IsInventoryPosition() == false)
+		return;
+
+	m_ItemSelectAttr.dwItemID = item->GetID();
+	item->GetSelectAttr(m_ItemSelectAttr.Attr);
+
+	TPacketGCItemSelectAttr p;
+	p.bHeader = HEADER_GC_ITEM_SELECT_ATTR;
+	p.pItemPos = pos;
+	std::copy(std::begin(m_ItemSelectAttr.Attr), std::end(m_ItemSelectAttr.Attr), std::begin(p.aAttr));
+	d->Packet(&p, sizeof p);
+
+	material->SetCount(material->GetCount() - 1);
+}
+
+void CHARACTER::SelectAttrResult(const bool bNew, const TItemPos& pos)
+{
+	if (IsSelectAttr() == false)
+		return;
+
+	if (bNew)
+	{
+		const LPITEM item = GetItem(pos);
+		if (item && item->GetID() == m_ItemSelectAttr.dwItemID)
+		{
+			item->SetAttributes(m_ItemSelectAttr.Attr);
+			item->UpdatePacket();
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have changed the upgrade."));
+		}
+	}
+
+	memset(&m_ItemSelectAttr, 0, sizeof m_ItemSelectAttr);
+}
+
+bool CHARACTER::IsSelectAttr() const
+{
+	return m_ItemSelectAttr.dwItemID != 0;
+}
+#endif
+
+#if defined(__LUCKY_BOX__)
+void CHARACTER::SetLuckyBoxSrcItem(const LPITEM c_lpItem)
+{
+	if (c_lpItem == nullptr)
+		return;
+
+	if (PreventTradeWindow(WND_ALL))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have to close other windows."));
+		return;
+	}
+
+	ResetLuckyBoxData();
+
+	m_sLuckyBox.dwSrcItemVNum = c_lpItem->GetVnum();
+	m_sLuckyBox.dwSrcItemID = c_lpItem->GetID();
+	m_sLuckyBox.wSrcSlotIndex = c_lpItem->GetCell();
+
+	SendLuckyBoxInfo();
+}
+
+void CHARACTER::SendLuckyBoxInfo()
+{
+	if (!IsLuckyBoxOpen())
+		return;
+
+	if (!GetDesc())
+		return;
+
+	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
+	if (!pLuckyBox)
+		return;
+
+	if (!pLuckyBox->ContainsItems(m_sLuckyBox.dwSrcItemVNum))
+	{
+		ResetLuckyBoxData();
+		return;
+	}
+
+	m_sLuckyBox.bTryCount++;
+
+	while (true)
+	{
+		const CLuckyBoxGroup::SLuckyBoxItemInfo& item = pLuckyBox->GetRandomItem(m_sLuckyBox.dwSrcItemVNum);
+		if (pLuckyBox->GetItemCount(m_sLuckyBox.dwSrcItemVNum) > 1 && item.dwVNum == m_sLuckyBox.dwItemVNum)
+			continue;
+
+		m_sLuckyBox.dwItemVNum = item.dwVNum;
+		m_sLuckyBox.bItemCount = item.bCount;
+		break;
+	}
+
+	TPacketGCLuckyBox Packet;
+	Packet.bHeader = HEADER_GC_LUCKY_BOX;
+	Packet.dwVNum = m_sLuckyBox.dwItemVNum;
+	Packet.bCount = m_sLuckyBox.bItemCount;
+	Packet.iNeedMoney = GetLuckyBoxPrice();
+	Packet.wSlotIndex = m_sLuckyBox.wSrcSlotIndex;
+	GetDesc()->Packet(&Packet, sizeof(Packet));
+}
+
+void CHARACTER::LuckyBoxRetry()
+{
+	if (!IsLuckyBoxOpen())
+		return;
+
+	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
+	if (!pLuckyBox)
+		return;
+
+	if (m_sLuckyBox.bTryCount >= pLuckyBox->GetMaxTryCount())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can't do this anymore."));
+		return;
+	}
+
+	const int c_iPrice = GetLuckyBoxPrice();
+	if (c_iPrice > GetGold())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough money."));
+		return;
+	}
+
+	PointChange(POINT_GOLD, -c_iPrice);
+	ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d Yang has been deducted.", c_iPrice));
+	SendLuckyBoxInfo();
+}
+
+void CHARACTER::LuckyBoxReceive()
+{
+	if (!IsLuckyBoxOpen())
+		return;
+
+	const LPITEM c_lpSrcItem = ITEM_MANAGER::Instance().Find(m_sLuckyBox.dwSrcItemID);
+	if (c_lpSrcItem)
+	{
+		ITEM_MANAGER::Instance().RemoveItem(c_lpSrcItem);
+		AutoGiveItem(m_sLuckyBox.dwItemVNum, m_sLuckyBox.bItemCount);
+	}
+
+	ResetLuckyBoxData();
+}
+
+int CHARACTER::GetLuckyBoxPrice() const
+{
+	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
+	if (!pLuckyBox)
+		return 0;
+
+	int iRet = pLuckyBox->GetPrice();
+	for (int i = 1; i < m_sLuckyBox.bTryCount; i++)
+		iRet *= 2;
+
+	return iRet;
+}
+
+bool CHARACTER::IsLuckyBoxOpen() const
+{
+	return m_sLuckyBox.dwSrcItemID != 0;
+}
+
+void CHARACTER::ResetLuckyBoxData()
+{
+	memset(&m_sLuckyBox, 0, sizeof(m_sLuckyBox));
+}
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+LPITEM CHARACTER::GetNPCStorageItem(BYTE bCell) const
+{
+	return GetItem(TItemPos(NPC_STORAGE, bCell));
+}
+
+bool CHARACTER::Attr67Add(const TAttr67AddData kAttr67AddData)
+{
+	if (!IsPC())
+		return false;
+
+	if (PreventTradeWindow(WND_ATTR67ADD, true/*except*/))
+		return false;
+
+	if (GetNPCStorageItem())
+		return false;
+
+	const LPITEM pkRegistItem = GetInventoryItem(kAttr67AddData.wRegistItemPos);
+	if (pkRegistItem == nullptr)
+		return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (pkRegistItem->IsSealed())
+		return false;
+#endif
+
+	if (pkRegistItem->isLocked())
+		return false;
+
+	if (pkRegistItem->IsEquipped())
+		return false;
+
+	if (pkRegistItem->GetType() != ITEM_ARMOR && pkRegistItem->GetType() != ITEM_WEAPON)
+		return false;
+
+	pkRegistItem->Lock(true);
+
+	if (pkRegistItem->GetAttributeCount() < ITEM_MANAGER::MAX_NORM_ATTR_NUM)
+	{
+		pkRegistItem->Lock(false);
+		return false;
+	}
+
+	DWORD dwItemMaterialVnum = pkRegistItem->Get67AttrMaterial();
+	if (CountSpecifyItem(dwItemMaterialVnum) < kAttr67AddData.byMaterialCount)
+		return false;
+
+	RemoveSpecifyItem(dwItemMaterialVnum, kAttr67AddData.byMaterialCount);
+
+	long lSupportIncreasePct = 0;
+	LPITEM pSupportItem = nullptr;
+	{
+		pSupportItem = GetInventoryItem(kAttr67AddData.wSupportItemPos);
+		if (pSupportItem)
+			lSupportIncreasePct = pSupportItem->GetValue(1);
+	}
+
+	// Total success percent.
+	float fMaterialPct = kAttr67AddData.byMaterialCount * ATTR67_SUCCESS_PER_MATERIAL;
+	float fSupportPct = 0.0f;
+	if (kAttr67AddData.bySupportItemCount != 0)
+	{
+		fSupportPct = static_cast<float>(lSupportIncreasePct) / (ATTR67_MATERIAL_MAX_COUNT * ATTR67_SUPPORT_MAX_COUNT);
+		fSupportPct *= kAttr67AddData.bySupportItemCount * kAttr67AddData.byMaterialCount;
+
+	}
+	float fTotalSuccessPct = fMaterialPct + fSupportPct;
+
+	if (test_server)
+	{
+		ChatPacket(CHAT_TYPE_INFO, "<Add67> Success Percentage: %.2f", fTotalSuccessPct);
+	}
+
+	if (pSupportItem)
+	{
+		if (CountSpecifyItem(pSupportItem->GetVnum()) < kAttr67AddData.bySupportItemCount)
+		{
+			pkRegistItem->Lock(false);
+			return false;
+		}
+
+		RemoveSpecifyItem(pSupportItem->GetVnum(), kAttr67AddData.bySupportItemCount);
+	}
+
+	pkRegistItem->RemoveFromCharacter();
+	SetItem(TItemPos(NPC_STORAGE, 0), pkRegistItem);
+	{
+		const LPITEM pkAttr67Add = GetNPCStorageItem();
+		if (!pkAttr67Add)
+		{
+			// TODO: Make a backup of the item in case something goes bad.
+			pkRegistItem->Lock(false);
+			sys_err("CHARACTER::Attr67Add: failed to get regist item from ATTR67_ADD (window).");
+			return false;
+		}
+
+		SetQuestFlag("add_attr67.success", (number(1, 100) <= fTotalSuccessPct ? 1 : 0));
+		SetQuestFlag("add_attr67.wait_time", get_global_time() + ATTR67_ADD_WAIT_TIME);
+		SetQuestFlag("add_attr67.add", 0);
+		// @ attr67add_collect (handling)
+	}
+
+	return true;
+}
+#endif
+
+#if defined(__SOUL_SYSTEM__)
+void CHARACTER::SoulItemProcess(ESoulSubTypes eSubType)
+{
+	LPITEM item = nullptr;
+	for (const auto& it : GetAffectContainer())
+	{
+		if (it == nullptr || it->dwType != AFFECT_SOUL)
+			continue;
+
+		switch (eSubType)
+		{
+			case ESoulSubTypes::RED_SOUL:
+			{
+				if (it->wApplyOn == AFF_SOUL_RED)
+					item = FindItemByID(it->lApplyValue);
+			}
+			break;
+
+			case ESoulSubTypes::BLUE_SOUL:
+			{
+				if (it->wApplyOn == AFF_SOUL_BLUE)
+					item = FindItemByID(it->lApplyValue);
+			}
+			break;
+		}
+	}
+
+	if (item == nullptr)
+		return;
+
+	if (!item->isLocked() || item->GetSocket(1) != TRUE)
+		return;
+
+	long data = item->GetSocket(2);
+	long keep_time = data / 10000;
+	//auto max_time = item->GetLimitValue(1);
+	long min_time = 60;
+
+	// Minimum use time.
+	if (keep_time < min_time)
+		return;
+
+	/*
+	* Since the `remain_count` is added after the `keep_time`
+	* we can decrease `data` directly because the count
+	* stays at the end of `data`.
+	*/
+	//if (test_server)
+	//	data -= 5;
+	//else
+	--data; /* remain_count */;
+
+	/*
+	* If the remaining count is equal or below to zero
+	* then set decrease the socket data.
+	*/
+	long new_data = ((keep_time - min_time) * 10000) + item->GetValue(2);
+	long remain_count = data % 10000;
+	if (remain_count <= 0)
+	{
+		item->SetSocket(2, new_data);
+		item->ResetSoulTimerUseEvent();
+		return;
+	}
+
+	// Update the item with the new data (decreased count)
+	item->SetSocket(2, data, false /* log */);
+}
+
+int CHARACTER::GetSoulDamage(ESoulSubTypes eSubType) const
+{
+	LPITEM item = nullptr;
+	for (const auto& it : GetAffectContainer())
+	{
+		if (it == nullptr || it->dwType != AFFECT_SOUL)
+			continue;
+
+		switch (eSubType)
+		{
+			case ESoulSubTypes::RED_SOUL:
+			{
+				if (it->wApplyOn == AFF_SOUL_RED)
+					item = FindItemByID(it->lApplyValue);
+			}
+			break;
+
+			case ESoulSubTypes::BLUE_SOUL:
+			{
+				if (it->wApplyOn == AFF_SOUL_BLUE)
+					item = FindItemByID(it->lApplyValue);
+			}
+			break;
+		}
+	}
+
+	if (item == nullptr)
+		return 0;
+
+	if (item->GetSocket(1) != TRUE)
+		return 0;
+
+	int value = 0;
+	long data = item->GetSocket(2);
+	long keep_time = data / 10000;
+
+	long max_time = item->GetLimitValue(1);
+	long min_time = 60;
+
+	// Minimum use time.
+	if (keep_time < min_time)
+		return 0;
+
+	if (keep_time >= max_time)
+		return item->GetValue(5);
+
+	// Damage values in value field (3, 4, 5)
+	int value_field = 3 + std::floor(keep_time / (max_time - min_time));
+	if (value_field < ITEM_VALUES_MAX_NUM)
+		value = item->GetValue(value_field);
+
+	return value;
+}
+#endif
+
+#if defined(__SET_ITEM__)
+void CHARACTER::RefreshItemSetBonus()
+{
+	RemoveAffect(AFFECT_SET_ITEM);
+
+	bool bSetBonus = false;
+	for (const auto& [bSetValue, vItems] : ITEM_MANAGER::Instance().GetItemSetItemMap())
+	{
+		BYTE bWearCount = 0;
+
+		const auto& rkItemSetValueMap = ITEM_MANAGER::Instance().GetItemSetValueMap();
+		if (rkItemSetValueMap.empty())
+			break;
+
+		const auto& ItemSetValueMap = rkItemSetValueMap.find(bSetValue);
+		if (ItemSetValueMap == rkItemSetValueMap.end())
+			continue;
+
+		for (const auto& [bSetType, kItemTuple] : vItems)
+		{
+			LPITEM pItem = nullptr;
+			LPITEM pUnique1 = nullptr;
+			LPITEM pUnique2 = nullptr;
+			CPetSystem* pPetSystem = nullptr;
+
+			switch (bSetType)
+			{
+				case SET_ITEM_COSTUME_BODY:
+					pItem = GetWear(WEAR_COSTUME_BODY);
+					break;
+
+				case SET_ITEM_COSTUME_HAIR:
+					pItem = GetWear(WEAR_COSTUME_HAIR);
+					break;
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+				case SET_ITEM_COSTUME_MOUNT:
+					pItem = GetWear(WEAR_COSTUME_MOUNT);
+					break;
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+				case SET_ITEM_COSTUME_ACCE:
+					pItem = GetWear(WEAR_COSTUME_ACCE);
+					break;
+#endif
+
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+				case SET_ITEM_COSTUME_WEAPON:
+					pItem = GetWear(WEAR_COSTUME_WEAPON);
+					break;
+#endif
+
+				case SET_ITEM_UNIQUE:
+					pUnique1 = GetWear(WEAR_UNIQUE1);
+					pUnique2 = GetWear(WEAR_UNIQUE2);
+					break;
+
+#if defined(__PET_SYSTEM__)
+				case SET_ITEM_PET:
+					pPetSystem = GetPetSystem();
+					break;
+#endif
+			}
+
+			const auto& [dwMinVnum, dwMaxVnum, bRange] = kItemTuple;
+
+#if defined(__PET_SYSTEM__)
+			if (pPetSystem && CHECK_VNUM_RANGE(pPetSystem->GetSummonItemVnum(), dwMinVnum, dwMaxVnum, bRange))
+				++bWearCount;
+#endif
+
+			if (pUnique1 && CHECK_VNUM_RANGE(pUnique1->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
+				++bWearCount;
+
+			if (pUnique2 && CHECK_VNUM_RANGE(pUnique2->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
+				++bWearCount;
+
+			if (pItem && CHECK_VNUM_RANGE(pItem->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
+				++bWearCount;
+
+			for (const auto& [bCount, vSetBonus] : ItemSetValueMap->second)
+			{
+				if (bWearCount != bCount)
+				{
+					bSetBonus = false;
+					continue;
+				}
+
+				for (const auto& [wApplyType, lApplyValue] : vSetBonus)
+				{
+					AddAffect(AFFECT_SET_ITEM, aApplyInfo[wApplyType].wPointType, lApplyValue, 0, INFINITE_AFFECT_DURATION, 0, true, true);
+					bSetBonus = true;
+				}
+			}
+		}
+
+		if (bSetBonus)
+			break;
+	}
+}
+
+CHARACTER::SetItemCountMap CHARACTER::GetItemSetCountMap() const
+{
+	std::vector<LPITEM> vItems = { GetWear(WEAR_BODY), GetWear(WEAR_HEAD), GetWear(WEAR_WEAPON) };
+	std::map<BYTE, BYTE> mSetCount = {
+		{ SET_ITEM_SET_VALUE_1, 0 },
+		{ SET_ITEM_SET_VALUE_2, 0 },
+		{ SET_ITEM_SET_VALUE_3, 0 },
+		{ SET_ITEM_SET_VALUE_4, 0 },
+		{ SET_ITEM_SET_VALUE_5, 0 },
+	};
+
+	for (const LPITEM& pkItem : vItems)
+	{
+		if (pkItem == nullptr)
+			continue;
+
+		const BYTE bSetValue = pkItem->GetItemSetValue();
+		if (bSetValue != SET_ITEM_SET_VALUE_NONE)
+			++mSetCount[bSetValue];
+	}
+
+	return mSetCount;
+}
+
+void CHARACTER::RefreshItemSetBonusByValue()
+{
+	for (DWORD dwType = AFFECT_SET_ITEM_SET_VALUE_1; dwType <= AFFECT_SET_ITEM_SET_VALUE_5; ++dwType)
+		RemoveAffect(dwType);
+
+	const auto& rkItemSetValueMap = ITEM_MANAGER::Instance().GetItemSetValueMap();
+	if (rkItemSetValueMap.empty())
+		return;
+
+	for (const auto& rkItemSetPair : GetItemSetCountMap())
+	{
+		BYTE bSetValue = rkItemSetPair.first;
+		BYTE bWearCount = rkItemSetPair.second;
+
+		const auto& rkSetItemMap = rkItemSetValueMap.find(bSetValue);
+		if (rkSetItemMap == rkItemSetValueMap.end())
+			continue;
+
+		for (const auto& kSetItem : rkSetItemMap->second)
+		{
+			const auto& vSetBonus = kSetItem.second;
+			if (bWearCount != kSetItem.first)
+				continue;
+
+			for (const auto& kSetBonus : vSetBonus)
+				AddAffect((AFFECT_SET_ITEM_SET_VALUE_1 - 1) + bSetValue, aApplyInfo[kSetBonus.first].wPointType, kSetBonus.second, 0, INFINITE_AFFECT_DURATION, 0, true, true);
+		}
+	}
+}
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+void CHARACTER::RefineElementInformation(const LPITEM& rSrcItem, const TItemPos& kItemDestCell)
+{
+	if (!CanHandleItem())
+		return;
+
+	LPITEM pDestItem;
+	if (!IsValidItemPosition(kItemDestCell) || !(pDestItem = GetItem(kItemDestCell)))
+		return;
+
+	if (rSrcItem->IsEquipped() || pDestItem->IsEquipped())
+		return;
+
+	if (rSrcItem->IsExchanging() || pDestItem->IsExchanging())
+		return;
+
+	if (rSrcItem->isLocked() || pDestItem->isLocked())
+		return;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (pDestItem->IsSealed())
+		return;
+#endif
+
+	if (pDestItem->GetType() != ITEM_WEAPON)
+		return;
+
+	if (pDestItem->GetRefineLevel() < REFINE_ELEMENT_MIN_REFINE_LEVEL)
+		return;
+
+	TPacketGCRefineElement kPacket;
+	kPacket.bHeader = HEADER_GC_REFINE_ELEMENT;
+	kPacket.bSubHeader = REFINE_ELEMENT_GC_OPEN;
+	switch (rSrcItem->GetSubType())
+	{
+		case USE_ELEMENT_UPGRADE:
+			kPacket.bRefineType = REFINE_ELEMENT_UPGRADE;
+			break;
+		case USE_ELEMENT_DOWNGRADE:
+			kPacket.bRefineType = REFINE_ELEMENT_DOWNGRADE;
+			break;
+		case USE_ELEMENT_CHANGE:
+			kPacket.bRefineType = REFINE_ELEMENT_CHANGE;
+			break;
+		default:
+		{
+			sys_err("CHARACTER::RefineElementInformation: %s cannot receive information with unsupported material sub type.", GetName());
+			return;
+		}
+	}
+	kPacket.bResult = false;
+	kPacket.SrcPos = TItemPos(rSrcItem->GetWindow(), rSrcItem->GetCell());
+	kPacket.DestPos = kItemDestCell;
+	GetDesc()->Packet(&kPacket, sizeof(kPacket));
+
+	SetUnderRefineElement(true, kPacket.bRefineType, kPacket.SrcPos, kPacket.DestPos);
+}
+
+void CHARACTER::SetUnderRefineElement(bool bState, BYTE bRefineType, const TItemPos& rkSrcPos, const TItemPos& rkDestPos)
+{
+	m_kRefineElementItemPos.RefineType = bRefineType;
+	m_kRefineElementItemPos.SrcPos = rkSrcPos;
+	m_kRefineElementItemPos.DestPos = rkDestPos;
+	m_bUnderRefineElement = bState;
+}
+
+void CHARACTER::RefineElement(WORD wChangeElement)
+{
+	if (!IsUnderRefineElement())
+		return;
+
+	LPITEM pSrcItem;
+	if (!IsValidItemPosition(m_kRefineElementItemPos.SrcPos) || !(pSrcItem = GetItem(m_kRefineElementItemPos.SrcPos)))
+		return;
+
+	LPITEM pDestItem;
+	if (!IsValidItemPosition(m_kRefineElementItemPos.DestPos) || !(pDestItem = GetItem(m_kRefineElementItemPos.DestPos)))
+		return;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (pDestItem->IsSealed())
+		return;
+#endif
+
+	if (pDestItem->GetType() != ITEM_WEAPON)
+		return;
+
+	if (pDestItem->GetRefineLevel() < REFINE_ELEMENT_MIN_REFINE_LEVEL)
+		return;
+
+	TPacketGCRefineElement kPacket;
+	kPacket.bHeader = HEADER_GC_REFINE_ELEMENT;
+	kPacket.bSubHeader = REFINE_ELEMENT_GC_RESULT;
+	kPacket.bRefineType = m_kRefineElementItemPos.RefineType;
+	switch (kPacket.bRefineType)
+	{
+		case REFINE_ELEMENT_UPGRADE:
+		{
+			if (GetGold() < REFINE_ELEMENT_UPGRADE_YANG)
+				return;
+
+			//const TRefineTable* pRefineTable = CRefineManager::instance().GetRefineRecipe(11);
+			//if (number(1, 100) <= (pRefineTable ? pRefineTable->prob : 30))
+			if (number(1, 100) <= (test_server ? 80 : 30))
+			{
+				const WORD wMaterialApplyType = static_cast<WORD>(pSrcItem->GetValue(0));
+				const WORD wRefineElementApplyType = pDestItem->GetRefineElementApplyType();
+				if ((wRefineElementApplyType != 0) && (wRefineElementApplyType != wMaterialApplyType))
+				{
+					sys_err("CHARACTER::RefineElement: %s cannot upgrade with wrong material.", GetName());
+					return;
+				}
+
+				const BYTE bRandomValue = number_even(REFINE_ELEMENT_RANDOM_VALUE_MIN, REFINE_ELEMENT_RANDOM_VALUE_MAX);
+				const BYTE bRandomBonusValue = number_even(REFINE_ELEMENT_RANDOM_BONUS_VALUE_MIN, REFINE_ELEMENT_RANDOM_BONUS_VALUE_MAX);
+
+				pDestItem->UpgradeRefineElement(wMaterialApplyType, bRandomValue, bRandomBonusValue);
+
+				kPacket.bResult = true;
+			}
+			else
+			{
+				kPacket.bResult = false;
+			}
+
+			PointChange(POINT_GOLD, -REFINE_ELEMENT_UPGRADE_YANG);
+		}
+		break;
+
+		case REFINE_ELEMENT_DOWNGRADE:
+		{
+			if (GetGold() < REFINE_ELEMENT_DOWNGRADE_YANG)
+				return;
+
+			pDestItem->DowngradeRefineElement();
+			kPacket.bResult = true;
+
+			PointChange(POINT_GOLD, -REFINE_ELEMENT_DOWNGRADE_YANG);
+		}
+		break;
+
+		case REFINE_ELEMENT_CHANGE:
+		{
+			if (GetGold() < REFINE_ELEMENT_CHANGE_YANG)
+				return;
+
+			switch (wChangeElement)
+			{
+				case APPLY_ENCHANT_ELECT:
+				case APPLY_ENCHANT_FIRE:
+				case APPLY_ENCHANT_ICE:
+				case APPLY_ENCHANT_WIND:
+				case APPLY_ENCHANT_EARTH:
+				case APPLY_ENCHANT_DARK:
+					break;
+
+				default:
+				{
+					sys_err("CHARACTER::RefineElement: %s cannot change element with unsupported apply type.", GetName());
+					return;
+				}
+			}
+
+			const WORD wRefineElementApplyType = pDestItem->GetRefineElementApplyType();
+			if (wRefineElementApplyType == wChangeElement)
+			{
+				sys_err("CHARACTER::RefineElement: %s cannot change element with the current apply type.", GetName());
+				return;
+			}
+
+			pDestItem->ChangeRefineElement(wChangeElement);
+			kPacket.bResult = true;
+
+			PointChange(POINT_GOLD, -REFINE_ELEMENT_CHANGE_YANG);
+		}
+		break;
+
+		default:
+		{
+			sys_err("CHARACTER::RefineElement: %s cannot refine with unknown type.", GetName());
+			return;
+		}
+	}
+	kPacket.SrcPos = NPOS;
+	kPacket.DestPos = NPOS;
+	GetDesc()->Packet(&kPacket, sizeof(kPacket));
+
+	pSrcItem->SetCount(pSrcItem->GetCount() - 1);
+
+	SetUnderRefineElement(false);
+}
+
+WORD CHARACTER::GetRefineElementEffect() const
+{
+	const LPITEM pItemWeapon = GetWear(WEAR_WEAPON);
+	if ((pItemWeapon) && (pItemWeapon->GetRefineElementGrade() >= REFINE_ELEMENT_MAX))
+		return pItemWeapon->GetRefineElementApplyType();
+	return 0;
+}
+#endif
diff --git a/server/server/home/metin2/Source/Server/game/src/cmd.cpp b/server/server/home/metin2/Source/Server/game/src/cmd.cpp
index 3daa262..12149d0 100644
--- a/server/server/home/metin2/Source/Server/game/src/cmd.cpp
+++ b/server/server/home/metin2/Source/Server/game/src/cmd.cpp
@@ -1,882 +1,882 @@
-#include "stdafx.h"
-#include "utils.h"
-#include "config.h"
-#include "char.h"
-#include "locale_service.h"
-#include "log.h"
-#include "desc.h"
-
-ACMD(do_user_horse_ride);
-ACMD(do_user_horse_back);
-ACMD(do_user_horse_feed);
-
-ACMD(do_pcbang_update);
-ACMD(do_pcbang_check);
-
-// ADD_COMMAND_SLOW_STUN
-ACMD(do_slow);
-ACMD(do_stun);
-// END_OF_ADD_COMMAND_SLOW_STUN
-
-ACMD(do_poison);
-ACMD(do_bleeding);
-ACMD(do_fire);
-
-ACMD(do_warp);
-ACMD(do_goto);
-ACMD(do_item);
-ACMD(do_mob);
-ACMD(do_mob_ld);
-ACMD(do_mob_aggresive);
-ACMD(do_mob_coward);
-ACMD(do_mob_map);
-ACMD(do_purge);
-ACMD(do_weaken);
-ACMD(do_item_purge);
-ACMD(do_state);
-ACMD(do_notice);
-ACMD(do_map_notice);
-ACMD(do_big_notice);
-ACMD(do_who);
-ACMD(do_user);
-ACMD(do_disconnect);
-ACMD(do_kill);
-ACMD(do_emotion_allow);
-ACMD(do_emotion_play);
-ACMD(do_emoticon);
-//ACMD(do_emotion);
-ACMD(do_transfer);
-ACMD(do_set);
-ACMD(do_cmd);
-ACMD(do_reset);
-ACMD(do_greset);
-ACMD(do_mount);
-ACMD(do_fishing);
-ACMD(do_refine_rod);
-
-// REFINE_PICK
-ACMD(do_max_pick);
-ACMD(do_refine_pick);
-// END_OF_REFINE_PICK
-
-ACMD(do_fishing_simul);
-ACMD(do_console);
-ACMD(do_restart);
-ACMD(do_advance);
-ACMD(do_stat);
-#if defined(__CONQUEROR_LEVEL__)
-ACMD(do_conqueror_point);
-ACMD(do_conqueror_level);
-#endif
-ACMD(do_respawn);
-ACMD(do_skillup);
-ACMD(do_guildskillup);
-ACMD(do_pvp);
-ACMD(do_point_reset);
-ACMD(do_safebox_size);
-ACMD(do_safebox_close);
-ACMD(do_safebox_password);
-ACMD(do_safebox_change_password);
-ACMD(do_mall_password);
-ACMD(do_mall_close);
-ACMD(do_ungroup);
-ACMD(do_makeguild);
-ACMD(do_deleteguild);
-ACMD(do_shutdown);
-ACMD(do_group);
-ACMD(do_group_random);
-ACMD(do_invisibility);
-ACMD(do_event_flag);
-ACMD(do_get_event_flag);
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-ACMD(do_guild_event_flag);
-ACMD(do_get_guild_event_flag);
-#endif
-ACMD(do_private);
-ACMD(do_qf);
-ACMD(do_clear_quest);
-ACMD(do_book);
-ACMD(do_reload);
-ACMD(do_war);
-ACMD(do_nowar);
-ACMD(do_setskill);
-ACMD(do_setskillother);
-ACMD(do_level);
-ACMD(do_polymorph);
-ACMD(do_polymorph_item);
-/*
-ACMD(do_b1);
-ACMD(do_b2);
-ACMD(do_b3);
-ACMD(do_b4);
-ACMD(do_b5);
-ACMD(do_b6);
-ACMD(do_b7);
-*/
-ACMD(do_close_shop);
-ACMD(do_set_walk_mode);
-ACMD(do_set_run_mode);
-ACMD(do_set_skill_group);
-ACMD(do_set_skill_point);
-ACMD(do_cooltime);
-ACMD(do_detaillog);
-ACMD(do_monsterlog);
-
-ACMD(do_gwlist);
-ACMD(do_stop_guild_war);
-ACMD(do_cancel_guild_war);
-ACMD(do_guild_state);
-
-ACMD(do_pkmode);
-ACMD(do_messenger_auth);
-
-ACMD(do_getqf);
-ACMD(do_setqf);
-ACMD(do_delqf);
-ACMD(do_set_state);
-
-ACMD(do_forgetme);
-ACMD(do_aggregate);
-ACMD(do_attract_ranger);
-ACMD(do_pull_monster);
-ACMD(do_setblockmode);
-ACMD(do_priv_empire);
-ACMD(do_priv_guild);
-ACMD(do_mount_test);
-ACMD(do_unmount);
-ACMD(do_observer);
-ACMD(do_observer_exit);
-ACMD(do_socket_item);
-ACMD(do_xmas);
-ACMD(do_stat_minus);
-ACMD(do_stat_reset);
-ACMD(do_view_equip);
-ACMD(do_block_chat);
-ACMD(do_vote_block_chat);
-
-// BLOCK_CHAT
-ACMD(do_block_chat_list);
-// END_OF_BLOCK_CHAT
-
-ACMD(do_party_request);
-ACMD(do_party_request_deny);
-ACMD(do_party_request_accept);
-ACMD(do_build);
-ACMD(do_clear_land);
-
-ACMD(do_horse_state);
-ACMD(do_horse_level);
-ACMD(do_horse_ride);
-ACMD(do_horse_summon);
-ACMD(do_horse_unsummon);
-ACMD(do_horse_set_stat);
-
-ACMD(do_save_attribute_to_image);
-ACMD(do_affect_remove);
-ACMD(do_affect_add);
-
-ACMD(do_change_attr);
-ACMD(do_add_attr);
-ACMD(do_add_socket);
-
-ACMD(do_inputall)
-{
-	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("명령어를 모두 입력하세요."));
-}
-
-ACMD(do_show_arena_list);
-ACMD(do_end_all_duel);
-ACMD(do_end_duel);
-ACMD(do_duel);
-
-ACMD(do_stat_plus_amount);
-
-ACMD(do_break_marriage);
-
-ACMD(do_oxevent_show_quiz);
-ACMD(do_oxevent_log);
-ACMD(do_oxevent_get_attender);
-
-ACMD(do_effect);
-ACMD(do_threeway_war_info);
-ACMD(do_threeway_war_myinfo);
-//
-// 군주 전용기능
-ACMD(do_monarch_warpto);
-ACMD(do_monarch_transfer);
-ACMD(do_monarch_info);
-ACMD(do_elect);
-ACMD(do_monarch_tax);
-ACMD(do_monarch_mob);
-ACMD(do_monarch_notice);
-
-// 군주 관리 기능
-ACMD(do_rmcandidacy);
-ACMD(do_setmonarch);
-ACMD(do_rmmonarch);
-
-ACMD(do_hair);
-// gift notify quest command
-ACMD(do_gift);
-// 큐브관련
-ACMD(do_inventory);
-#if !defined(__CUBE_RENEWAL__)
-ACMD(do_cube);
-#endif
-// 공성전
-ACMD(do_siege);
-ACMD(do_temp);
-ACMD(do_frog);
-
-ACMD(do_check_monarch_money);
-
-ACMD(do_reset_subskill);
-ACMD(do_flush);
-
-ACMD(do_eclipse);
-ACMD(do_weeklyevent);
-
-#if defined(__XMAS_EVENT_2008__)
-ACMD(do_event_helper);
-#endif
-
-ACMD(do_in_game_mall);
-
-ACMD(do_get_mob_count);
-
-ACMD(do_dice);
-ACMD(do_special_item);
-
-ACMD(do_click_mall);
-
-ACMD(do_ride);
-ACMD(do_get_item_id_list);
-ACMD(do_set_socket);
-ACMD(do_get_socket);
-
-// 코스츔 상태보기 및 벗기
-ACMD(do_costume);
-ACMD(do_set_stat);
-
-// 무적
-ACMD(do_can_dead);
-
-ACMD(do_full_set);
-// 직군과 레벨에 따른 최고 아이템
-ACMD(do_item_full_set);
-// 직군에 따른 최고 옵션의 속성 셋팅
-ACMD(do_attr_full_set);
-// 모든 스킬 마스터
-ACMD(do_all_skill_master);
-// 아이템 착용. icon이 없어 클라에서 확인 할 수 없는 아이템 착용을 위해 만듦.
-ACMD(do_use_item);
-#if defined(__DRAGON_SOUL_SYSTEM__)
-ACMD(do_dragon_soul);
-ACMD(do_ds_list);
-ACMD(do_ds_qualify);
-#endif
-ACMD(do_clear_affect);
-
-ACMD(do_kill_all);
-ACMD(do_drop_item);
-
-#if defined(__MOVE_CHANNEL__)
-ACMD(do_move_channel);
-#endif
-
-ACMD(do_transfer_force);
-ACMD(do_warp_force);
-ACMD(do_online);
-
-#if defined(__INGAME_EVENT_MANAGER__) && defined(__EVENT_BANNER_FLAG__)
-ACMD(do_banner);
-#endif
-
-#if defined(__POPUP_NOTICE__)
-ACMD(do_popup_notice_check);
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-ACMD(do_mini_game_okey);
-#endif
-#if defined(__MINI_GAME_YUTNORI__)
-ACMD(do_mini_game_yutnori);
-#endif
-#if defined(__FLOWER_EVENT__)
-ACMD(do_flower_event);
-#endif
-#if defined(__MINI_GAME_CATCH_KING__)
-ACMD(do_mini_game_catchking);
-#endif
-#if defined(__SUMMER_EVENT_ROULETTE__)
-ACMD(do_mini_game_roulette);
-#endif
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-ACMD(do_snowflake_stick_event);
-#endif
-
-#if defined(__GAME_OPTION_ESCAPE__)
-ACMD(do_escape);
-#endif
-
-#if defined(__CHECK_PORT_STATUS__)
-ACMD(do_portstatus);
-#endif
-
-#if defined(__HIDE_COSTUME_SYSTEM__)
-ACMD(do_hide_costume_part);
-#endif
-
-ACMD(do_loglevel);
-ACMD(do_clear_ground);
-ACMD(do_whisper_notice);
-
-#if defined(__DEFENSE_WAVE__)
-ACMD(do_dw_create);
-#endif
-
-#if defined(__OFFLINE_SHOP__)
-ACMD(do_create_offline_shop);
-ACMD(do_cancel_opening_offline_shop);
-ACMD(do_open_offline_shop);
-ACMD(do_close_offline_shop);
-// ACMD(do_close_offline_shop_force);
-ACMD(do_sell_history);
-ACMD(do_deleteshop);
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-ACMD(do_battlepass_get_info);
-ACMD(do_battlepass_set_mission);
-ACMD(do_battlepass_premium_activate);
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-ACMD(do_pet_set);
-#endif
-
-struct command_info cmd_info[] =
-{
-	{ "!RESERVED!", NULL, 0, POS_DEAD, GM_IMPLEMENTOR }, /* 반드시 이 것이 처음이어야 한다. */
-
-	{ "who", do_who, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "war", do_war, 0, POS_DEAD, GM_PLAYER },
-	{ "warp", do_warp, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "user", do_user, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "notice", do_notice, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "notice_map", do_map_notice, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "big_notice", do_big_notice, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "nowar", do_nowar, 0, POS_DEAD, GM_PLAYER },
-	{ "purge", do_purge, 0, POS_DEAD, GM_WIZARD },
-	{ "weaken", do_weaken, 0, POS_DEAD, GM_GOD },
-	{ "dc", do_disconnect, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "transfer", do_transfer, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "goto", do_goto, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "level", do_level, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "eventflag", do_event_flag, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "geteventflag", do_get_event_flag, 0, POS_DEAD, GM_LOW_WIZARD },
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	{ "guild_event_flag", do_guild_event_flag, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "get_guild_event_flag", do_get_guild_event_flag, 0, POS_DEAD, GM_LOW_WIZARD },
-#endif
-
-	{ "item", do_item, 0, POS_DEAD, GM_GOD },
-
-	{ "mob", do_mob, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "mob_ld", do_mob_ld, 0, POS_DEAD, GM_HIGH_WIZARD }, /* 몹의 위치와 방향을 설정해 소환 /mob_ld vnum x y dir */
-	{ "ma", do_mob_aggresive, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "mc", do_mob_coward, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "mm", do_mob_map, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "kill", do_kill, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "ipurge", do_item_purge, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "group", do_group, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "grrandom", do_group_random, 0, POS_DEAD, GM_HIGH_WIZARD },
-
-	{ "set", do_set, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "reset", do_reset, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "greset", do_greset, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "advance", do_advance, 0, POS_DEAD, GM_GOD },
-	{ "book", do_book, 0, POS_DEAD, GM_IMPLEMENTOR },
-
-	{ "console", do_console, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "shutdow", do_inputall, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "shutdown", do_shutdown, 0, POS_DEAD, GM_IMPLEMENTOR },
-
-	{ "stat", do_stat, 0, POS_DEAD, GM_PLAYER },
-	{ "stat-", do_stat_minus, 0, POS_DEAD, GM_PLAYER },
-	{ "stat_reset", do_stat_reset, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "state", do_state, 0, POS_DEAD, GM_LOW_WIZARD },
-
-#if defined(__CONQUEROR_LEVEL__)
-	{ "conqueror_point", do_conqueror_point, 0, POS_DEAD, GM_PLAYER },
-	{ "conqueror_level", do_conqueror_level, 0, POS_DEAD, GM_LOW_WIZARD },
-#endif
-
-	// ADD_COMMAND_SLOW_STUN
-	{ "stun", do_stun, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "slow", do_slow, 0, POS_DEAD, GM_LOW_WIZARD },
-	// END_OF_ADD_COMMAND_SLOW_STUN
-
-	{ "respawn", do_respawn, 0, POS_DEAD, GM_WIZARD },
-
-	{ "makeguild", do_makeguild, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "deleteguild", do_deleteguild, 0, POS_DEAD, GM_HIGH_WIZARD },
-
-	{ "mount", do_mount, 0, POS_MOUNTING, GM_PLAYER },
-	{ "restart_here", do_restart, SCMD_RESTART_HERE, POS_DEAD, GM_PLAYER },
-	{ "restart_town", do_restart, SCMD_RESTART_TOWN, POS_DEAD, GM_PLAYER },
-	{ "restart_immediately", do_restart, SCMD_RESTART_IMMEDIATE, POS_DEAD, GM_PLAYER },
-	{ "restart_giveup", do_restart, SCMD_RESTART_GIVEUP, POS_DEAD, GM_PLAYER },
-	{ "phase_selec", do_inputall, 0, POS_DEAD, GM_PLAYER },
-	{ "phase_select", do_cmd, SCMD_PHASE_SELECT, POS_DEAD, GM_PLAYER },
-	{ "qui", do_inputall, 0, POS_DEAD, GM_PLAYER },
-	{ "quit", do_cmd, SCMD_QUIT, POS_DEAD, GM_PLAYER },
-	{ "logou", do_inputall, 0, POS_DEAD, GM_PLAYER },
-	{ "logout", do_cmd, SCMD_LOGOUT, POS_DEAD, GM_PLAYER },
-#if defined(__LOCALE_CLIENT__)
-	{ "language_change", do_cmd, SCMD_LANGUAGE_CHANGE, POS_DEAD, GM_PLAYER },
-#endif
-	{ "skillup", do_skillup, 0, POS_DEAD, GM_PLAYER },
-	{ "gskillup", do_guildskillup, 0, POS_DEAD, GM_PLAYER },
-	{ "pvp", do_pvp, 0, POS_DEAD, GM_PLAYER },
-	{ "safebox", do_safebox_size, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "safebox_close", do_safebox_close, 0, POS_DEAD, GM_PLAYER },
-	{ "safebox_passwor",do_inputall, 0, POS_DEAD, GM_PLAYER },
-	{ "safebox_password",do_safebox_password, 0, POS_DEAD, GM_PLAYER },
-	{ "safebox_change_passwor", do_inputall, 0, POS_DEAD, GM_PLAYER },
-	{ "safebox_change_password", do_safebox_change_password, 0, POS_DEAD, GM_PLAYER },
-	{ "mall_passwor", do_inputall, 0, POS_DEAD, GM_PLAYER },
-	{ "mall_password", do_mall_password, 0, POS_DEAD, GM_PLAYER },
-	{ "mall_close", do_mall_close, 0, POS_DEAD, GM_PLAYER },
-
-	// Group Command
-	{ "ungroup", do_ungroup, 0, POS_DEAD, GM_PLAYER },
-
-	// REFINE_ROD_HACK_BUG_FIX
-	{ "refine_rod", do_refine_rod, 0, POS_DEAD, GM_IMPLEMENTOR },
-	// END_OF_REFINE_ROD_HACK_BUG_FIX
-
-	// REFINE_PICK 
-	{ "refine_pick", do_refine_pick, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "max_pick", do_max_pick, 0, POS_DEAD, GM_IMPLEMENTOR },
-	// END_OF_REFINE_PICK
-
-	{ "fish_simul", do_fishing_simul, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "invisible", do_invisibility, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "qf", do_qf, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "clear_quest", do_clear_quest, 0, POS_DEAD, GM_HIGH_WIZARD },
-
-	{ "close_shop", do_close_shop, 0, POS_DEAD, GM_PLAYER },
-
-	{ "set_walk_mode", do_set_walk_mode, 0, POS_DEAD, GM_PLAYER },
-	{ "set_run_mode", do_set_run_mode, 0, POS_DEAD, GM_PLAYER },
-	{ "setjob",do_set_skill_group, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "setskill", do_setskill, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "setskillother", do_setskillother, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "setskillpoint", do_set_skill_point, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "reload", do_reload, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "cooltime", do_cooltime, 0, POS_DEAD, GM_HIGH_WIZARD },
-
-	{ "gwlist", do_gwlist, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "gwstop", do_stop_guild_war, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "gwcancel", do_cancel_guild_war, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "gstate", do_guild_state, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "pkmode", do_pkmode, 0, POS_DEAD, GM_PLAYER },
-	{ "messenger_auth", do_messenger_auth, 0, POS_DEAD, GM_PLAYER },
-
-	{ "getqf", do_getqf, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "setqf", do_setqf, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "delqf", do_delqf, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "set_state", do_set_state, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	//{ "로그를보여줘", do_detaillog, 0, POS_DEAD, GM_LOW_WIZARD },
-	//{ "몬스터보여줘", do_monsterlog, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "detaillog", do_detaillog, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "monsterlog", do_monsterlog, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "forgetme", do_forgetme, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "aggregate", do_aggregate, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "attract_ranger", do_attract_ranger, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "pull_monster", do_pull_monster, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "setblockmode", do_setblockmode, 0, POS_DEAD, GM_PLAYER },
-	{ "polymorph", do_polymorph, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "polyitem", do_polymorph_item, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "priv_empire", do_priv_empire, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "priv_guild", do_priv_guild, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "mount_test", do_mount_test, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "unmount", do_unmount, 0, POS_DEAD, GM_PLAYER },
-	{ "private", do_private, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "party_request", do_party_request, 0, POS_DEAD, GM_PLAYER },
-	{ "party_request_accept", do_party_request_accept,0, POS_DEAD, GM_PLAYER },
-	{ "party_request_deny", do_party_request_deny,0, POS_DEAD, GM_PLAYER },
-	{ "observer", do_observer, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "observer_exit", do_observer_exit, 0, POS_DEAD, GM_PLAYER },
-	{ "socketitem", do_socket_item, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "saveati", do_save_attribute_to_image, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "xmas_boom", do_xmas, SCMD_XMAS_BOOM, POS_DEAD, GM_HIGH_WIZARD },
-	{ "xmas_snow", do_xmas, SCMD_XMAS_SNOW, POS_DEAD, GM_HIGH_WIZARD },
-	{ "xmas_santa", do_xmas, SCMD_XMAS_SANTA, POS_DEAD, GM_HIGH_WIZARD },
-	{ "view_equip", do_view_equip, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "jy", do_block_chat, 0, POS_DEAD, GM_HIGH_WIZARD },
-
-	// BLOCK_CHAT
-	{ "vote_block_chat", do_vote_block_chat, 0, POS_DEAD, GM_PLAYER },
-	{ "block_chat", do_block_chat, 0, POS_DEAD, GM_PLAYER },
-	{ "block_chat_list",do_block_chat_list, 0, POS_DEAD, GM_PLAYER },
-	// END_OF_BLOCK_CHAT
-
-	{ "build", do_build, 0, POS_DEAD, GM_PLAYER },
-	{ "clear_land", do_clear_land, 0, POS_DEAD, GM_HIGH_WIZARD },
-
-	{ "affect_remove", do_affect_remove, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "affect_add", do_affect_add, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "horse_state", do_horse_state, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "horse_level", do_horse_level, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "horse_ride", do_horse_ride, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "horse_summon", do_horse_summon, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "horse_unsummon", do_horse_unsummon, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "horse_set_stat", do_horse_set_stat, 0, POS_DEAD, GM_HIGH_WIZARD },
-
-	{ "pcbang_update", do_pcbang_update, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "pcbang_check", do_pcbang_check, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "emotion_allow", do_emotion_allow, 0, POS_FIGHTING, GM_PLAYER },
-	{ "emotion_play", do_emotion_play, 0, POS_FIGHTING, GM_PLAYER },
-	{ "emoticon", do_emoticon, 0, POS_FIGHTING, GM_PLAYER },
-
-	{ "change_attr", do_change_attr, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "add_attr", do_add_attr, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "add_socket", do_add_socket, 0, POS_DEAD, GM_IMPLEMENTOR },
-
-	{ "user_horse_ride", do_user_horse_ride, 0, POS_FISHING, GM_PLAYER },
-	{ "user_horse_back", do_user_horse_back, 0, POS_FISHING, GM_PLAYER },
-	{ "user_horse_feed", do_user_horse_feed, 0, POS_FISHING, GM_PLAYER },
-
-	{ "show_arena_list", do_show_arena_list, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "end_all_duel", do_end_all_duel, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "end_duel", do_end_duel, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "duel", do_duel, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "con+", do_stat_plus_amount, POINT_HT, POS_DEAD, GM_LOW_WIZARD },
-	{ "int+", do_stat_plus_amount, POINT_IQ, POS_DEAD, GM_LOW_WIZARD },
-	{ "str+", do_stat_plus_amount, POINT_ST, POS_DEAD, GM_LOW_WIZARD },
-	{ "dex+", do_stat_plus_amount, POINT_DX, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "break_marriage", do_break_marriage, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "show_quiz", do_oxevent_show_quiz, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "log_oxevent", do_oxevent_log, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "get_oxevent_att", do_oxevent_get_attender,0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "effect", do_effect, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "threeway_info", do_threeway_war_info, 0, POS_DEAD, GM_LOW_WIZARD},
-	{ "threeway_myinfo", do_threeway_war_myinfo, 0, POS_DEAD, GM_LOW_WIZARD},
-	{ "mto", do_monarch_warpto, 0, POS_DEAD, GM_PLAYER},
-	{ "mtr", do_monarch_transfer, 0, POS_DEAD, GM_PLAYER},
-	{ "minfo", do_monarch_info, 0, POS_DEAD, GM_PLAYER},
-	{ "mtax", do_monarch_tax, 0, POS_DEAD, GM_PLAYER},
-	{ "mmob", do_monarch_mob, 0, POS_DEAD, GM_PLAYER},
-	{ "elect", do_elect, 0, POS_DEAD, GM_HIGH_WIZARD},
-	{ "rmcandidacy", do_rmcandidacy, 0, POS_DEAD, GM_LOW_WIZARD},
-	{ "setmonarch", do_setmonarch, 0, POS_DEAD, GM_LOW_WIZARD},
-	{ "rmmonarch", do_rmmonarch, 0, POS_DEAD, GM_LOW_WIZARD},
-	{ "hair", do_hair, 0, POS_DEAD, GM_PLAYER },
-	{ "inventory", do_inventory, 0, POS_DEAD, GM_LOW_WIZARD },
-#if !defined(__CUBE_RENEWAL__)
-	{ "cube", do_cube, 0, POS_DEAD, GM_PLAYER },
-#endif
-	{ "siege", do_siege, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "temp", do_temp, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "frog", do_frog, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "check_mmoney", do_check_monarch_money, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "reset_subskill", do_reset_subskill, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "flush", do_flush, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "gift", do_gift, 0, POS_DEAD, GM_PLAYER }, // gift
-
-	{ "mnotice", do_monarch_notice, 0, POS_DEAD, GM_PLAYER },
-
-	{ "eclipse", do_eclipse, 0, POS_DEAD, GM_HIGH_WIZARD },
-
-	{ "weeklyevent", do_weeklyevent, 0, POS_DEAD, GM_LOW_WIZARD },
-
-#if defined(__XMAS_EVENT_2008__)
-	{ "eventhelper", do_event_helper, 0, POS_DEAD, GM_HIGH_WIZARD },
-#endif
-
-	{ "in_game_mall", do_in_game_mall, 0, POS_DEAD, GM_PLAYER },
-
-	{ "get_mob_count", do_get_mob_count, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "dice", do_dice, 0, POS_DEAD, GM_PLAYER },
-	//{ "주사위", do_dice, 0, POS_DEAD, GM_PLAYER },
-	{ "special_item", do_special_item, 0, POS_DEAD, GM_IMPLEMENTOR },
-
-	{ "click_mall", do_click_mall, 0, POS_DEAD, GM_PLAYER },
-
-	{ "ride", do_ride, 0, POS_DEAD, GM_PLAYER },
-
-	{ "item_id_list", do_get_item_id_list, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "set_socket", do_set_socket, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "get_socket", do_get_socket, 0, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "costume", do_costume, 0, POS_DEAD, GM_PLAYER },
-
-	{ "tcon", do_set_stat, POINT_HT, POS_DEAD, GM_LOW_WIZARD },
-	{ "tint", do_set_stat, POINT_IQ, POS_DEAD, GM_LOW_WIZARD },
-	{ "tstr", do_set_stat, POINT_ST, POS_DEAD, GM_LOW_WIZARD },
-	{ "tdex", do_set_stat, POINT_DX, POS_DEAD, GM_LOW_WIZARD },
-
-	{ "cannot_dead", do_can_dead, 1, POS_DEAD, GM_LOW_WIZARD},
-	{ "can_dead", do_can_dead, 0, POS_DEAD, GM_LOW_WIZARD},
-
-	{ "full_set", do_full_set, 0, POS_DEAD, GM_LOW_WIZARD},
-	{ "item_full_set", do_item_full_set, 0, POS_DEAD, GM_LOW_WIZARD},
-	{ "attr_full_set", do_attr_full_set, 0, POS_DEAD, GM_LOW_WIZARD},
-	{ "all_skill_master", do_all_skill_master, 0, POS_DEAD, GM_LOW_WIZARD},
-	{ "use_item", do_use_item, 0, POS_DEAD, GM_LOW_WIZARD},
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	{ "dragon_soul", do_dragon_soul, 0, POS_DEAD, GM_PLAYER },
-	{ "ds_list", do_ds_list, 0, POS_DEAD, GM_PLAYER },
-	{ "ds_qualify", do_ds_qualify, 0, POS_DEAD, GM_HIGH_WIZARD },
-#endif
-	{ "do_clear_affect", do_clear_affect, 0, POS_DEAD, GM_LOW_WIZARD},
-
-	{ "kill_all", do_kill_all, 0, POS_DEAD, GM_HIGH_WIZARD },
-	{ "drop_item", do_drop_item, 0, POS_DEAD, GM_HIGH_WIZARD },
-
-	{ "poison", do_poison, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "bleeding", do_bleeding, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "fire", do_fire, 0, POS_DEAD, GM_IMPLEMENTOR },
-
-#if defined(__MOVE_CHANNEL__)
-	{ "move_channel", do_move_channel, 0, POS_DEAD, GM_PLAYER },
-#endif
-
-	{ "warp_force", do_warp_force, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "transfer_force", do_transfer_force, 0, POS_DEAD, GM_LOW_WIZARD },
-	{ "online", do_online, 0, POS_DEAD, GM_LOW_WIZARD },
-
-#if defined(__INGAME_EVENT_MANAGER__) && defined(__EVENT_BANNER_FLAG__)
-	{ "banner", do_banner, 0, POS_DEAD, GM_IMPLEMENTOR },
-#endif
-
-#if defined(__POPUP_NOTICE__)
-	{ "popup_notice_check", do_popup_notice_check, 0, POS_DEAD, GM_PLAYER },
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-	{ "mini_game_okey", do_mini_game_okey, 0, POS_DEAD, GM_IMPLEMENTOR },
-#endif
-	
-#if defined(__MINI_GAME_YUTNORI__)
-	{ "mini_game_yutnori", do_mini_game_yutnori, 0, POS_DEAD, GM_IMPLEMENTOR },
-#endif
-
-#if defined(__FLOWER_EVENT__)
-	{ "flower_event", do_flower_event, 0, POS_DEAD, GM_IMPLEMENTOR },
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__)
-	{ "mini_game_catchking", do_mini_game_catchking, 0, POS_DEAD, GM_IMPLEMENTOR },
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	{ "mini_game_roulette", do_mini_game_roulette, 0, POS_DEAD, GM_IMPLEMENTOR },
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-	{ "snowflake_stick_event", do_snowflake_stick_event, 0, POS_DEAD, GM_IMPLEMENTOR },
-#endif
-
-#if defined(__GAME_OPTION_ESCAPE__)
-	{ "escape", do_escape, 0, POS_DEAD, GM_PLAYER },
-#endif
-
-#if defined(__CHECK_PORT_STATUS__)
-	{ "portstatus", do_portstatus, 0, POS_DEAD, GM_IMPLEMENTOR },
-#endif
-
-#if defined(__HIDE_COSTUME_SYSTEM__)
-	{ "hide_costume_part", do_hide_costume_part, 0, POS_DEAD, GM_PLAYER },
-#endif
-
-	{ "loglevel", do_loglevel, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "clear_ground", do_clear_ground, 0, POS_DEAD, GM_IMPLEMENTOR },
-	{ "whisper_notice", do_whisper_notice, 0, POS_DEAD, GM_IMPLEMENTOR },
-
-#if defined(__DEFENSE_WAVE__)
-	{ "dw_create", do_dw_create, 0, POS_DEAD, GM_IMPLEMENTOR },
-#endif
-
-#if defined(__OFFLINE_SHOP__)
-	{ "create_offline_shop", do_create_offline_shop, 0, POS_DEAD, GM_PLAYER },
-	{ "cancel_opening_offline_shop", do_cancel_opening_offline_shop, 0, POS_DEAD, GM_PLAYER },
-	{ "open_offline_shop", do_open_offline_shop, 0, POS_DEAD, GM_PLAYER },
-	{ "close_offline_shop", do_close_offline_shop, 0, POS_DEAD, GM_PLAYER },
-	{ "sell_history",		do_sell_history,	0,	POS_DEAD,	GM_PLAYER	},
-	{ "delete_shop",			do_deleteshop,		0,		POS_DEAD,	GM_LOW_WIZARD },
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	{ "battlepass_get_info",	do_battlepass_get_info,	0,	POS_DEAD,	RESTRICT_COMMAND_GET_INFO },
-	{ "battlepass_set_mission",	do_battlepass_set_mission,	0,	POS_DEAD,	RESTRICT_COMMAND_SET_MISSION },
-	{ "battlepass_premium_activate",	do_battlepass_premium_activate,	0,	POS_DEAD,	RESTRICT_COMMAND_PREMIUM_ACTIVATE },
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	{ "pet_set",			do_pet_set, 		0, POS_DEAD,		GM_IMPLEMENTOR },
-#endif
-
-	{ "\n", NULL, 0, POS_DEAD, GM_IMPLEMENTOR } /* 반드시 이 것이 마지막이어야 한다. */
-};
-
-void interpreter_set_privilege(const char* cmd, int lvl)
-{
-	int i;
-
-	for (i = 0; *cmd_info[i].command != '\n'; ++i)
-	{
-		if (!str_cmp(cmd, cmd_info[i].command))
-		{
-			cmd_info[i].gm_level = lvl;
-			sys_log(0, "Setting command privilege: %s -> %d", cmd, lvl);
-			break;
-		}
-	}
-}
-
-void double_dollar(const char* src, size_t src_len, char* dest, size_t dest_len)
-{
-	const char* tmp = src;
-	size_t cur_len = 0;
-
-	// \0 넣을 자리 확보
-	dest_len -= 1;
-
-	while (src_len-- && *tmp)
-	{
-		if (*tmp == '$')
-		{
-			if (cur_len + 1 >= dest_len)
-				break;
-
-			*(dest++) = '$';
-			*(dest++) = *(tmp++);
-			cur_len += 2;
-		}
-		else
-		{
-			if (cur_len >= dest_len)
-				break;
-
-			*(dest++) = *(tmp++);
-			cur_len += 1;
-		}
-	}
-
-	*dest = '\0';
-}
-
-void interpret_command(LPCHARACTER ch, const char* argument, size_t len)
-{
-	if (NULL == ch)
-	{
-		sys_err("NULL CHARACTER");
-		return;
-	}
-
-	char cmd[128 + 1]; // buffer overflow 문제가 생기지 않도록 일부러 길이를 짧게 잡음
-	char new_line[256 + 1];
-	const char* line;
-	int icmd;
-
-	if (len == 0 || !*argument)
-		return;
-
-	double_dollar(argument, len, new_line, sizeof(new_line));
-
-	size_t cmdlen;
-	line = first_cmd(new_line, cmd, sizeof(cmd), &cmdlen);
-
-	for (icmd = 1; *cmd_info[icmd].command != '\n'; ++icmd)
-	{
-		if (cmd_info[icmd].command_pointer == do_cmd)
-		{
-			if (!strcmp(cmd_info[icmd].command, cmd)) // do_cmd는 모든 명령어를 쳐야 할 수 있다.
-				break;
-		}
-		else if (!strncmp(cmd_info[icmd].command, cmd, cmdlen))
-			break;
-	}
-
-	if (ch->GetPosition() < cmd_info[icmd].minimum_position)
-	{
-		switch (ch->GetPosition())
-		{
-		case POS_MOUNTING:
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("탄 상태에서는 할 수 없습니다."));
-			break;
-
-		case POS_DEAD:
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("쓰러진 상태에서는 할 수 없습니다."));
-			break;
-
-		case POS_SLEEPING:
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("꿈속에서 어떻게요?"));
-			break;
-
-		case POS_RESTING:
-		case POS_SITTING:
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("먼저 일어 나세요."));
-			break;
-			/*
-			case POS_FIGHTING:
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("목숨을 걸고 전투 중 입니다. 집중 하세요."));
-				break;
-			*/
-		default:
-			sys_err("unknown position %d", ch->GetPosition());
-			break;
-		}
-
-		return;
-	}
-
-	if (*cmd_info[icmd].command == '\n')
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("그런 명령어는 없습니다"));
-		return;
-	}
-
-	if (cmd_info[icmd].gm_level && cmd_info[icmd].gm_level > ch->GetGMLevel())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("그런 명령어는 없습니다"));
-		return;
-	}
-
-	if (strncmp("phase", cmd_info[icmd].command, 5) != 0) // 히든 명령어 처리 
-		sys_log(0, "COMMAND: %s: %s", ch->GetName(), cmd_info[icmd].command);
-
-	((*cmd_info[icmd].command_pointer) (ch, line, icmd, cmd_info[icmd].subcmd));
-
-	if (ch->GetGMLevel() >= GM_LOW_WIZARD)
-	{
-		if (cmd_info[icmd].gm_level >= GM_LOW_WIZARD)
-		{
-			if (LC_IsEurope() == true || /* LC_IsNewCIBN() == true || */LC_IsCanada() == true || LC_IsBrazil() == true)
-			{
-				char buf[1024];
-				snprintf(buf, sizeof(buf), "%s", argument);
-
-				LogManager::instance().GMCommandLog(ch->GetPlayerID(), ch->GetName(), ch->GetDesc()->GetHostName(), g_bChannel, buf);
-			}
-		}
-	}
-}
+#include "stdafx.h"
+#include "utils.h"
+#include "config.h"
+#include "char.h"
+#include "locale_service.h"
+#include "log.h"
+#include "desc.h"
+
+ACMD(do_user_horse_ride);
+ACMD(do_user_horse_back);
+ACMD(do_user_horse_feed);
+
+ACMD(do_pcbang_update);
+ACMD(do_pcbang_check);
+
+// ADD_COMMAND_SLOW_STUN
+ACMD(do_slow);
+ACMD(do_stun);
+// END_OF_ADD_COMMAND_SLOW_STUN
+
+ACMD(do_poison);
+ACMD(do_bleeding);
+ACMD(do_fire);
+
+ACMD(do_warp);
+ACMD(do_goto);
+ACMD(do_item);
+ACMD(do_mob);
+ACMD(do_mob_ld);
+ACMD(do_mob_aggresive);
+ACMD(do_mob_coward);
+ACMD(do_mob_map);
+ACMD(do_purge);
+ACMD(do_weaken);
+ACMD(do_item_purge);
+ACMD(do_state);
+ACMD(do_notice);
+ACMD(do_map_notice);
+ACMD(do_big_notice);
+ACMD(do_who);
+ACMD(do_user);
+ACMD(do_disconnect);
+ACMD(do_kill);
+ACMD(do_emotion_allow);
+ACMD(do_emotion_play);
+ACMD(do_emoticon);
+//ACMD(do_emotion);
+ACMD(do_transfer);
+ACMD(do_set);
+ACMD(do_cmd);
+ACMD(do_reset);
+ACMD(do_greset);
+ACMD(do_mount);
+ACMD(do_fishing);
+ACMD(do_refine_rod);
+
+// REFINE_PICK
+ACMD(do_max_pick);
+ACMD(do_refine_pick);
+// END_OF_REFINE_PICK
+
+ACMD(do_fishing_simul);
+ACMD(do_console);
+ACMD(do_restart);
+ACMD(do_advance);
+ACMD(do_stat);
+#if defined(__CONQUEROR_LEVEL__)
+ACMD(do_conqueror_point);
+ACMD(do_conqueror_level);
+#endif
+ACMD(do_respawn);
+ACMD(do_skillup);
+ACMD(do_guildskillup);
+ACMD(do_pvp);
+ACMD(do_point_reset);
+ACMD(do_safebox_size);
+ACMD(do_safebox_close);
+ACMD(do_safebox_password);
+ACMD(do_safebox_change_password);
+ACMD(do_mall_password);
+ACMD(do_mall_close);
+ACMD(do_ungroup);
+ACMD(do_makeguild);
+ACMD(do_deleteguild);
+ACMD(do_shutdown);
+ACMD(do_group);
+ACMD(do_group_random);
+ACMD(do_invisibility);
+ACMD(do_event_flag);
+ACMD(do_get_event_flag);
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+ACMD(do_guild_event_flag);
+ACMD(do_get_guild_event_flag);
+#endif
+ACMD(do_private);
+ACMD(do_qf);
+ACMD(do_clear_quest);
+ACMD(do_book);
+ACMD(do_reload);
+ACMD(do_war);
+ACMD(do_nowar);
+ACMD(do_setskill);
+ACMD(do_setskillother);
+ACMD(do_level);
+ACMD(do_polymorph);
+ACMD(do_polymorph_item);
+/*
+ACMD(do_b1);
+ACMD(do_b2);
+ACMD(do_b3);
+ACMD(do_b4);
+ACMD(do_b5);
+ACMD(do_b6);
+ACMD(do_b7);
+*/
+ACMD(do_close_shop);
+ACMD(do_set_walk_mode);
+ACMD(do_set_run_mode);
+ACMD(do_set_skill_group);
+ACMD(do_set_skill_point);
+ACMD(do_cooltime);
+ACMD(do_detaillog);
+ACMD(do_monsterlog);
+
+ACMD(do_gwlist);
+ACMD(do_stop_guild_war);
+ACMD(do_cancel_guild_war);
+ACMD(do_guild_state);
+
+ACMD(do_pkmode);
+ACMD(do_messenger_auth);
+
+ACMD(do_getqf);
+ACMD(do_setqf);
+ACMD(do_delqf);
+ACMD(do_set_state);
+
+ACMD(do_forgetme);
+ACMD(do_aggregate);
+ACMD(do_attract_ranger);
+ACMD(do_pull_monster);
+ACMD(do_setblockmode);
+ACMD(do_priv_empire);
+ACMD(do_priv_guild);
+ACMD(do_mount_test);
+ACMD(do_unmount);
+ACMD(do_observer);
+ACMD(do_observer_exit);
+ACMD(do_socket_item);
+ACMD(do_xmas);
+ACMD(do_stat_minus);
+ACMD(do_stat_reset);
+ACMD(do_view_equip);
+ACMD(do_block_chat);
+ACMD(do_vote_block_chat);
+
+// BLOCK_CHAT
+ACMD(do_block_chat_list);
+// END_OF_BLOCK_CHAT
+
+ACMD(do_party_request);
+ACMD(do_party_request_deny);
+ACMD(do_party_request_accept);
+ACMD(do_build);
+ACMD(do_clear_land);
+
+ACMD(do_horse_state);
+ACMD(do_horse_level);
+ACMD(do_horse_ride);
+ACMD(do_horse_summon);
+ACMD(do_horse_unsummon);
+ACMD(do_horse_set_stat);
+
+ACMD(do_save_attribute_to_image);
+ACMD(do_affect_remove);
+ACMD(do_affect_add);
+
+ACMD(do_change_attr);
+ACMD(do_add_attr);
+ACMD(do_add_socket);
+
+ACMD(do_inputall)
+{
+	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("어를  韜究."));
+}
+
+ACMD(do_show_arena_list);
+ACMD(do_end_all_duel);
+ACMD(do_end_duel);
+ACMD(do_duel);
+
+ACMD(do_stat_plus_amount);
+
+ACMD(do_break_marriage);
+
+ACMD(do_oxevent_show_quiz);
+ACMD(do_oxevent_log);
+ACMD(do_oxevent_get_attender);
+
+ACMD(do_effect);
+ACMD(do_threeway_war_info);
+ACMD(do_threeway_war_myinfo);
+//
+//  
+ACMD(do_monarch_warpto);
+ACMD(do_monarch_transfer);
+ACMD(do_monarch_info);
+ACMD(do_elect);
+ACMD(do_monarch_tax);
+ACMD(do_monarch_mob);
+ACMD(do_monarch_notice);
+
+//   
+ACMD(do_rmcandidacy);
+ACMD(do_setmonarch);
+ACMD(do_rmmonarch);
+
+ACMD(do_hair);
+// gift notify quest command
+ACMD(do_gift);
+// 큐
+ACMD(do_inventory);
+#if !defined(__CUBE_RENEWAL__)
+ACMD(do_cube);
+#endif
+// 
+ACMD(do_siege);
+ACMD(do_temp);
+ACMD(do_frog);
+
+ACMD(do_check_monarch_money);
+
+ACMD(do_reset_subskill);
+ACMD(do_flush);
+
+ACMD(do_eclipse);
+ACMD(do_weeklyevent);
+
+#if defined(__XMAS_EVENT_2008__)
+ACMD(do_event_helper);
+#endif
+
+ACMD(do_in_game_mall);
+
+ACMD(do_get_mob_count);
+
+ACMD(do_dice);
+ACMD(do_special_item);
+
+ACMD(do_click_mall);
+
+ACMD(do_ride);
+ACMD(do_get_item_id_list);
+ACMD(do_set_socket);
+ACMD(do_get_socket);
+
+// 黴 쨘  
+ACMD(do_costume);
+ACMD(do_set_stat);
+
+// 
+ACMD(do_can_dead);
+
+ACMD(do_full_set);
+//    斂 
+ACMD(do_item_full_set);
+//   斂  憺 
+ACMD(do_attr_full_set);
+//  킬 
+ACMD(do_all_skill_master);
+//  . icon  클璨【 확       .
+ACMD(do_use_item);
+#if defined(__DRAGON_SOUL_SYSTEM__)
+ACMD(do_dragon_soul);
+ACMD(do_ds_list);
+ACMD(do_ds_qualify);
+#endif
+ACMD(do_clear_affect);
+
+ACMD(do_kill_all);
+ACMD(do_drop_item);
+
+#if defined(__MOVE_CHANNEL__)
+ACMD(do_move_channel);
+#endif
+
+ACMD(do_transfer_force);
+ACMD(do_warp_force);
+ACMD(do_online);
+
+#if defined(__INGAME_EVENT_MANAGER__) && defined(__EVENT_BANNER_FLAG__)
+ACMD(do_banner);
+#endif
+
+#if defined(__POPUP_NOTICE__)
+ACMD(do_popup_notice_check);
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+ACMD(do_mini_game_okey);
+#endif
+#if defined(__MINI_GAME_YUTNORI__)
+ACMD(do_mini_game_yutnori);
+#endif
+#if defined(__FLOWER_EVENT__)
+ACMD(do_flower_event);
+#endif
+#if defined(__MINI_GAME_CATCH_KING__)
+ACMD(do_mini_game_catchking);
+#endif
+#if defined(__SUMMER_EVENT_ROULETTE__)
+ACMD(do_mini_game_roulette);
+#endif
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+ACMD(do_snowflake_stick_event);
+#endif
+
+#if defined(__GAME_OPTION_ESCAPE__)
+ACMD(do_escape);
+#endif
+
+#if defined(__CHECK_PORT_STATUS__)
+ACMD(do_portstatus);
+#endif
+
+#if defined(__HIDE_COSTUME_SYSTEM__)
+ACMD(do_hide_costume_part);
+#endif
+
+ACMD(do_loglevel);
+ACMD(do_clear_ground);
+ACMD(do_whisper_notice);
+
+#if defined(__DEFENSE_WAVE__)
+ACMD(do_dw_create);
+#endif
+
+#if defined(__OFFLINE_SHOP__)
+ACMD(do_create_offline_shop);
+ACMD(do_cancel_opening_offline_shop);
+ACMD(do_open_offline_shop);
+ACMD(do_close_offline_shop);
+// ACMD(do_close_offline_shop_force);
+ACMD(do_sell_history);
+ACMD(do_deleteshop);
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+ACMD(do_battlepass_get_info);
+ACMD(do_battlepass_set_mission);
+ACMD(do_battlepass_premium_activate);
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+ACMD (do_pet_set);
+#endif
+
+struct command_info cmd_info[] =
+{
+	{ "!RESERVED!", NULL, 0, POS_DEAD, GM_IMPLEMENTOR }, /* 訃   처潔 磯. */
+
+	{ "who", do_who, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "war", do_war, 0, POS_DEAD, GM_PLAYER },
+	{ "warp", do_warp, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "user", do_user, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "notice", do_notice, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "notice_map", do_map_notice, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "big_notice", do_big_notice, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "nowar", do_nowar, 0, POS_DEAD, GM_PLAYER },
+	{ "purge", do_purge, 0, POS_DEAD, GM_WIZARD },
+	{ "weaken", do_weaken, 0, POS_DEAD, GM_GOD },
+	{ "dc", do_disconnect, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "transfer", do_transfer, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "goto", do_goto, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "level", do_level, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "eventflag", do_event_flag, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "geteventflag", do_get_event_flag, 0, POS_DEAD, GM_LOW_WIZARD },
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	{ "guild_event_flag", do_guild_event_flag, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "get_guild_event_flag", do_get_guild_event_flag, 0, POS_DEAD, GM_LOW_WIZARD },
+#endif
+
+	{ "item", do_item, 0, POS_DEAD, GM_GOD },
+
+	{ "mob", do_mob, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "mob_ld", do_mob_ld, 0, POS_DEAD, GM_HIGH_WIZARD }, /*  치   환 /mob_ld vnum x y dir */
+	{ "ma", do_mob_aggresive, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "mc", do_mob_coward, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "mm", do_mob_map, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "kill", do_kill, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "ipurge", do_item_purge, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "group", do_group, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "grrandom", do_group_random, 0, POS_DEAD, GM_HIGH_WIZARD },
+
+	{ "set", do_set, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "reset", do_reset, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "greset", do_greset, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "advance", do_advance, 0, POS_DEAD, GM_GOD },
+	{ "book", do_book, 0, POS_DEAD, GM_IMPLEMENTOR },
+
+	{ "console", do_console, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "shutdow", do_inputall, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "shutdown", do_shutdown, 0, POS_DEAD, GM_IMPLEMENTOR },
+
+	{ "stat", do_stat, 0, POS_DEAD, GM_PLAYER },
+	{ "stat-", do_stat_minus, 0, POS_DEAD, GM_PLAYER },
+	{ "stat_reset", do_stat_reset, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "state", do_state, 0, POS_DEAD, GM_LOW_WIZARD },
+
+#if defined(__CONQUEROR_LEVEL__)
+	{ "conqueror_point", do_conqueror_point, 0, POS_DEAD, GM_PLAYER },
+	{ "conqueror_level", do_conqueror_level, 0, POS_DEAD, GM_LOW_WIZARD },
+#endif
+
+	// ADD_COMMAND_SLOW_STUN
+	{ "stun", do_stun, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "slow", do_slow, 0, POS_DEAD, GM_LOW_WIZARD },
+	// END_OF_ADD_COMMAND_SLOW_STUN
+
+	{ "respawn", do_respawn, 0, POS_DEAD, GM_WIZARD },
+
+	{ "makeguild", do_makeguild, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "deleteguild", do_deleteguild, 0, POS_DEAD, GM_HIGH_WIZARD },
+
+	{ "mount", do_mount, 0, POS_MOUNTING, GM_PLAYER },
+	{ "restart_here", do_restart, SCMD_RESTART_HERE, POS_DEAD, GM_PLAYER },
+	{ "restart_town", do_restart, SCMD_RESTART_TOWN, POS_DEAD, GM_PLAYER },
+	{ "restart_immediately", do_restart, SCMD_RESTART_IMMEDIATE, POS_DEAD, GM_PLAYER },
+	{ "restart_giveup", do_restart, SCMD_RESTART_GIVEUP, POS_DEAD, GM_PLAYER },
+	{ "phase_selec", do_inputall, 0, POS_DEAD, GM_PLAYER },
+	{ "phase_select", do_cmd, SCMD_PHASE_SELECT, POS_DEAD, GM_PLAYER },
+	{ "qui", do_inputall, 0, POS_DEAD, GM_PLAYER },
+	{ "quit", do_cmd, SCMD_QUIT, POS_DEAD, GM_PLAYER },
+	{ "logou", do_inputall, 0, POS_DEAD, GM_PLAYER },
+	{ "logout", do_cmd, SCMD_LOGOUT, POS_DEAD, GM_PLAYER },
+#if defined(__LOCALE_CLIENT__)
+	{ "language_change", do_cmd, SCMD_LANGUAGE_CHANGE, POS_DEAD, GM_PLAYER },
+#endif
+	{ "skillup", do_skillup, 0, POS_DEAD, GM_PLAYER },
+	{ "gskillup", do_guildskillup, 0, POS_DEAD, GM_PLAYER },
+	{ "pvp", do_pvp, 0, POS_DEAD, GM_PLAYER },
+	{ "safebox", do_safebox_size, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "safebox_close", do_safebox_close, 0, POS_DEAD, GM_PLAYER },
+	{ "safebox_passwor",do_inputall, 0, POS_DEAD, GM_PLAYER },
+	{ "safebox_password",do_safebox_password, 0, POS_DEAD, GM_PLAYER },
+	{ "safebox_change_passwor", do_inputall, 0, POS_DEAD, GM_PLAYER },
+	{ "safebox_change_password", do_safebox_change_password, 0, POS_DEAD, GM_PLAYER },
+	{ "mall_passwor", do_inputall, 0, POS_DEAD, GM_PLAYER },
+	{ "mall_password", do_mall_password, 0, POS_DEAD, GM_PLAYER },
+	{ "mall_close", do_mall_close, 0, POS_DEAD, GM_PLAYER },
+
+	// Group Command
+	{ "ungroup", do_ungroup, 0, POS_DEAD, GM_PLAYER },
+
+	// REFINE_ROD_HACK_BUG_FIX
+	{ "refine_rod", do_refine_rod, 0, POS_DEAD, GM_IMPLEMENTOR },
+	// END_OF_REFINE_ROD_HACK_BUG_FIX
+
+	// REFINE_PICK 
+	{ "refine_pick", do_refine_pick, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "max_pick", do_max_pick, 0, POS_DEAD, GM_IMPLEMENTOR },
+	// END_OF_REFINE_PICK
+
+	{ "fish_simul", do_fishing_simul, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "invisible", do_invisibility, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "qf", do_qf, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "clear_quest", do_clear_quest, 0, POS_DEAD, GM_HIGH_WIZARD },
+
+	{ "close_shop", do_close_shop, 0, POS_DEAD, GM_PLAYER },
+
+	{ "set_walk_mode", do_set_walk_mode, 0, POS_DEAD, GM_PLAYER },
+	{ "set_run_mode", do_set_run_mode, 0, POS_DEAD, GM_PLAYER },
+	{ "setjob",do_set_skill_group, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "setskill", do_setskill, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "setskillother", do_setskillother, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "setskillpoint", do_set_skill_point, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "reload", do_reload, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "cooltime", do_cooltime, 0, POS_DEAD, GM_HIGH_WIZARD },
+
+	{ "gwlist", do_gwlist, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "gwstop", do_stop_guild_war, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "gwcancel", do_cancel_guild_war, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "gstate", do_guild_state, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "pkmode", do_pkmode, 0, POS_DEAD, GM_PLAYER },
+	{ "messenger_auth", do_messenger_auth, 0, POS_DEAD, GM_PLAYER },
+
+	{ "getqf", do_getqf, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "setqf", do_setqf, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "delqf", do_delqf, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "set_state", do_set_state, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	//{ "慣琉", do_detaillog, 0, POS_DEAD, GM_LOW_WIZARD },
+	//{ "故", do_monsterlog, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "detaillog", do_detaillog, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "monsterlog", do_monsterlog, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "forgetme", do_forgetme, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "aggregate", do_aggregate, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "attract_ranger", do_attract_ranger, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "pull_monster", do_pull_monster, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "setblockmode", do_setblockmode, 0, POS_DEAD, GM_PLAYER },
+	{ "polymorph", do_polymorph, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "polyitem", do_polymorph_item, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "priv_empire", do_priv_empire, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "priv_guild", do_priv_guild, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "mount_test", do_mount_test, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "unmount", do_unmount, 0, POS_DEAD, GM_PLAYER },
+	{ "private", do_private, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "party_request", do_party_request, 0, POS_DEAD, GM_PLAYER },
+	{ "party_request_accept", do_party_request_accept,0, POS_DEAD, GM_PLAYER },
+	{ "party_request_deny", do_party_request_deny,0, POS_DEAD, GM_PLAYER },
+	{ "observer", do_observer, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "observer_exit", do_observer_exit, 0, POS_DEAD, GM_PLAYER },
+	{ "socketitem", do_socket_item, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "saveati", do_save_attribute_to_image, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "xmas_boom", do_xmas, SCMD_XMAS_BOOM, POS_DEAD, GM_HIGH_WIZARD },
+	{ "xmas_snow", do_xmas, SCMD_XMAS_SNOW, POS_DEAD, GM_HIGH_WIZARD },
+	{ "xmas_santa", do_xmas, SCMD_XMAS_SANTA, POS_DEAD, GM_HIGH_WIZARD },
+	{ "view_equip", do_view_equip, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "jy", do_block_chat, 0, POS_DEAD, GM_HIGH_WIZARD },
+
+	// BLOCK_CHAT
+	{ "vote_block_chat", do_vote_block_chat, 0, POS_DEAD, GM_PLAYER },
+	{ "block_chat", do_block_chat, 0, POS_DEAD, GM_PLAYER },
+	{ "block_chat_list",do_block_chat_list, 0, POS_DEAD, GM_PLAYER },
+	// END_OF_BLOCK_CHAT
+
+	{ "build", do_build, 0, POS_DEAD, GM_PLAYER },
+	{ "clear_land", do_clear_land, 0, POS_DEAD, GM_HIGH_WIZARD },
+
+	{ "affect_remove", do_affect_remove, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "affect_add", do_affect_add, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "horse_state", do_horse_state, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "horse_level", do_horse_level, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "horse_ride", do_horse_ride, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "horse_summon", do_horse_summon, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "horse_unsummon", do_horse_unsummon, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "horse_set_stat", do_horse_set_stat, 0, POS_DEAD, GM_HIGH_WIZARD },
+
+	{ "pcbang_update", do_pcbang_update, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "pcbang_check", do_pcbang_check, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "emotion_allow", do_emotion_allow, 0, POS_FIGHTING, GM_PLAYER },
+	{ "emotion_play", do_emotion_play, 0, POS_FIGHTING, GM_PLAYER },
+	{ "emoticon", do_emoticon, 0, POS_FIGHTING, GM_PLAYER },
+
+	{ "change_attr", do_change_attr, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "add_attr", do_add_attr, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "add_socket", do_add_socket, 0, POS_DEAD, GM_IMPLEMENTOR },
+
+	{ "user_horse_ride", do_user_horse_ride, 0, POS_FISHING, GM_PLAYER },
+	{ "user_horse_back", do_user_horse_back, 0, POS_FISHING, GM_PLAYER },
+	{ "user_horse_feed", do_user_horse_feed, 0, POS_FISHING, GM_PLAYER },
+
+	{ "show_arena_list", do_show_arena_list, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "end_all_duel", do_end_all_duel, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "end_duel", do_end_duel, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "duel", do_duel, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "con+", do_stat_plus_amount, POINT_HT, POS_DEAD, GM_LOW_WIZARD },
+	{ "int+", do_stat_plus_amount, POINT_IQ, POS_DEAD, GM_LOW_WIZARD },
+	{ "str+", do_stat_plus_amount, POINT_ST, POS_DEAD, GM_LOW_WIZARD },
+	{ "dex+", do_stat_plus_amount, POINT_DX, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "break_marriage", do_break_marriage, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "show_quiz", do_oxevent_show_quiz, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "log_oxevent", do_oxevent_log, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "get_oxevent_att", do_oxevent_get_attender,0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "effect", do_effect, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "threeway_info", do_threeway_war_info, 0, POS_DEAD, GM_LOW_WIZARD},
+	{ "threeway_myinfo", do_threeway_war_myinfo, 0, POS_DEAD, GM_LOW_WIZARD},
+	{ "mto", do_monarch_warpto, 0, POS_DEAD, GM_PLAYER},
+	{ "mtr", do_monarch_transfer, 0, POS_DEAD, GM_PLAYER},
+	{ "minfo", do_monarch_info, 0, POS_DEAD, GM_PLAYER},
+	{ "mtax", do_monarch_tax, 0, POS_DEAD, GM_PLAYER},
+	{ "mmob", do_monarch_mob, 0, POS_DEAD, GM_PLAYER},
+	{ "elect", do_elect, 0, POS_DEAD, GM_HIGH_WIZARD},
+	{ "rmcandidacy", do_rmcandidacy, 0, POS_DEAD, GM_LOW_WIZARD},
+	{ "setmonarch", do_setmonarch, 0, POS_DEAD, GM_LOW_WIZARD},
+	{ "rmmonarch", do_rmmonarch, 0, POS_DEAD, GM_LOW_WIZARD},
+	{ "hair", do_hair, 0, POS_DEAD, GM_PLAYER },
+	{ "inventory", do_inventory, 0, POS_DEAD, GM_LOW_WIZARD },
+#if !defined(__CUBE_RENEWAL__)
+	{ "cube", do_cube, 0, POS_DEAD, GM_PLAYER },
+#endif
+	{ "siege", do_siege, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "temp", do_temp, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "frog", do_frog, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "check_mmoney", do_check_monarch_money, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "reset_subskill", do_reset_subskill, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "flush", do_flush, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "gift", do_gift, 0, POS_DEAD, GM_PLAYER }, // gift
+
+	{ "mnotice", do_monarch_notice, 0, POS_DEAD, GM_PLAYER },
+
+	{ "eclipse", do_eclipse, 0, POS_DEAD, GM_HIGH_WIZARD },
+
+	{ "weeklyevent", do_weeklyevent, 0, POS_DEAD, GM_LOW_WIZARD },
+
+#if defined(__XMAS_EVENT_2008__)
+	{ "eventhelper", do_event_helper, 0, POS_DEAD, GM_HIGH_WIZARD },
+#endif
+
+	{ "in_game_mall", do_in_game_mall, 0, POS_DEAD, GM_PLAYER },
+
+	{ "get_mob_count", do_get_mob_count, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "dice", do_dice, 0, POS_DEAD, GM_PLAYER },
+	//{ "怜", do_dice, 0, POS_DEAD, GM_PLAYER },
+	{ "special_item", do_special_item, 0, POS_DEAD, GM_IMPLEMENTOR },
+
+	{ "click_mall", do_click_mall, 0, POS_DEAD, GM_PLAYER },
+
+	{ "ride", do_ride, 0, POS_DEAD, GM_PLAYER },
+
+	{ "item_id_list", do_get_item_id_list, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "set_socket", do_set_socket, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "get_socket", do_get_socket, 0, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "costume", do_costume, 0, POS_DEAD, GM_PLAYER },
+
+	{ "tcon", do_set_stat, POINT_HT, POS_DEAD, GM_LOW_WIZARD },
+	{ "tint", do_set_stat, POINT_IQ, POS_DEAD, GM_LOW_WIZARD },
+	{ "tstr", do_set_stat, POINT_ST, POS_DEAD, GM_LOW_WIZARD },
+	{ "tdex", do_set_stat, POINT_DX, POS_DEAD, GM_LOW_WIZARD },
+
+	{ "cannot_dead", do_can_dead, 1, POS_DEAD, GM_LOW_WIZARD},
+	{ "can_dead", do_can_dead, 0, POS_DEAD, GM_LOW_WIZARD},
+
+	{ "full_set", do_full_set, 0, POS_DEAD, GM_LOW_WIZARD},
+	{ "item_full_set", do_item_full_set, 0, POS_DEAD, GM_LOW_WIZARD},
+	{ "attr_full_set", do_attr_full_set, 0, POS_DEAD, GM_LOW_WIZARD},
+	{ "all_skill_master", do_all_skill_master, 0, POS_DEAD, GM_LOW_WIZARD},
+	{ "use_item", do_use_item, 0, POS_DEAD, GM_LOW_WIZARD},
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	{ "dragon_soul", do_dragon_soul, 0, POS_DEAD, GM_PLAYER },
+	{ "ds_list", do_ds_list, 0, POS_DEAD, GM_PLAYER },
+	{ "ds_qualify", do_ds_qualify, 0, POS_DEAD, GM_HIGH_WIZARD },
+#endif
+	{ "do_clear_affect", do_clear_affect, 0, POS_DEAD, GM_LOW_WIZARD},
+
+	{ "kill_all", do_kill_all, 0, POS_DEAD, GM_HIGH_WIZARD },
+	{ "drop_item", do_drop_item, 0, POS_DEAD, GM_HIGH_WIZARD },
+
+	{ "poison", do_poison, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "bleeding", do_bleeding, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "fire", do_fire, 0, POS_DEAD, GM_IMPLEMENTOR },
+
+#if defined(__MOVE_CHANNEL__)
+	{ "move_channel", do_move_channel, 0, POS_DEAD, GM_PLAYER },
+#endif
+
+	{ "warp_force", do_warp_force, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "transfer_force", do_transfer_force, 0, POS_DEAD, GM_LOW_WIZARD },
+	{ "online", do_online, 0, POS_DEAD, GM_LOW_WIZARD },
+
+#if defined(__INGAME_EVENT_MANAGER__) && defined(__EVENT_BANNER_FLAG__)
+	{ "banner", do_banner, 0, POS_DEAD, GM_IMPLEMENTOR },
+#endif
+
+#if defined(__POPUP_NOTICE__)
+	{ "popup_notice_check", do_popup_notice_check, 0, POS_DEAD, GM_PLAYER },
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+	{ "mini_game_okey", do_mini_game_okey, 0, POS_DEAD, GM_IMPLEMENTOR },
+#endif
+	
+#if defined(__MINI_GAME_YUTNORI__)
+	{ "mini_game_yutnori", do_mini_game_yutnori, 0, POS_DEAD, GM_IMPLEMENTOR },
+#endif
+
+#if defined(__FLOWER_EVENT__)
+	{ "flower_event", do_flower_event, 0, POS_DEAD, GM_IMPLEMENTOR },
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__)
+	{ "mini_game_catchking", do_mini_game_catchking, 0, POS_DEAD, GM_IMPLEMENTOR },
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	{ "mini_game_roulette", do_mini_game_roulette, 0, POS_DEAD, GM_IMPLEMENTOR },
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+	{ "snowflake_stick_event", do_snowflake_stick_event, 0, POS_DEAD, GM_IMPLEMENTOR },
+#endif
+
+#if defined(__GAME_OPTION_ESCAPE__)
+	{ "escape", do_escape, 0, POS_DEAD, GM_PLAYER },
+#endif
+
+#if defined(__CHECK_PORT_STATUS__)
+	{ "portstatus", do_portstatus, 0, POS_DEAD, GM_IMPLEMENTOR },
+#endif
+
+#if defined(__HIDE_COSTUME_SYSTEM__)
+	{ "hide_costume_part", do_hide_costume_part, 0, POS_DEAD, GM_PLAYER },
+#endif
+
+	{ "loglevel", do_loglevel, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "clear_ground", do_clear_ground, 0, POS_DEAD, GM_IMPLEMENTOR },
+	{ "whisper_notice", do_whisper_notice, 0, POS_DEAD, GM_IMPLEMENTOR },
+
+#if defined(__DEFENSE_WAVE__)
+	{ "dw_create", do_dw_create, 0, POS_DEAD, GM_IMPLEMENTOR },
+#endif
+
+#if defined(__OFFLINE_SHOP__)
+	{ "create_offline_shop", do_create_offline_shop, 0, POS_DEAD, GM_PLAYER },
+	{ "cancel_opening_offline_shop", do_cancel_opening_offline_shop, 0, POS_DEAD, GM_PLAYER },
+	{ "open_offline_shop", do_open_offline_shop, 0, POS_DEAD, GM_PLAYER },
+	{ "close_offline_shop", do_close_offline_shop, 0, POS_DEAD, GM_PLAYER },
+	{ "sell_history",		do_sell_history,	0,	POS_DEAD,	GM_PLAYER	},
+	{ "delete_shop",			do_deleteshop,		0,		POS_DEAD,	GM_LOW_WIZARD },
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	{ "battlepass_get_info",	do_battlepass_get_info,	0,	POS_DEAD,	RESTRICT_COMMAND_GET_INFO },
+	{ "battlepass_set_mission",	do_battlepass_set_mission,	0,	POS_DEAD,	RESTRICT_COMMAND_SET_MISSION },
+	{ "battlepass_premium_activate",	do_battlepass_premium_activate,	0,	POS_DEAD,	RESTRICT_COMMAND_PREMIUM_ACTIVATE },
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	{ "pet_set", do_pet_set, 0, POS_DEAD, GM_IMPLEMENTOR },
+#endif
+
+	{ "\n", NULL, 0, POS_DEAD, GM_IMPLEMENTOR } /* 訃   潔 磯. */
+};
+
+void interpreter_set_privilege(const char* cmd, int lvl)
+{
+	int i;
+
+	for (i = 0; *cmd_info[i].command != '\n'; ++i)
+	{
+		if (!str_cmp(cmd, cmd_info[i].command))
+		{
+			cmd_info[i].gm_level = lvl;
+			sys_log(0, "Setting command privilege: %s -> %d", cmd, lvl);
+			break;
+		}
+	}
+}
+
+void double_dollar(const char* src, size_t src_len, char* dest, size_t dest_len)
+{
+	const char* tmp = src;
+	size_t cur_len = 0;
+
+	// \0  美 확
+	dest_len -= 1;
+
+	while (src_len-- && *tmp)
+	{
+		if (*tmp == '$')
+		{
+			if (cur_len + 1 >= dest_len)
+				break;
+
+			*(dest++) = '$';
+			*(dest++) = *(tmp++);
+			cur_len += 2;
+		}
+		else
+		{
+			if (cur_len >= dest_len)
+				break;
+
+			*(dest++) = *(tmp++);
+			cur_len += 1;
+		}
+	}
+
+	*dest = '\0';
+}
+
+void interpret_command(LPCHARACTER ch, const char* argument, size_t len)
+{
+	if (NULL == ch)
+	{
+		sys_err("NULL CHARACTER");
+		return;
+	}
+
+	char cmd[128 + 1]; // buffer overflow   茄 瞿管 見 짧 
+	char new_line[256 + 1];
+	const char* line;
+	int icmd;
+
+	if (len == 0 || !*argument)
+		return;
+
+	double_dollar(argument, len, new_line, sizeof(new_line));
+
+	size_t cmdlen;
+	line = first_cmd(new_line, cmd, sizeof(cmd), &cmdlen);
+
+	for (icmd = 1; *cmd_info[icmd].command != '\n'; ++icmd)
+	{
+		if (cmd_info[icmd].command_pointer == do_cmd)
+		{
+			if (!strcmp(cmd_info[icmd].command, cmd)) // do_cmd  어를 컁   獵.
+				break;
+		}
+		else if (!strncmp(cmd_info[icmd].command, cmd, cmdlen))
+			break;
+	}
+
+	if (ch->GetPosition() < cmd_info[icmd].minimum_position)
+	{
+		switch (ch->GetPosition())
+		{
+		case POS_MOUNTING:
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("탄 쩔   求."));
+			break;
+
+		case POS_DEAD:
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 쩔   求."));
+			break;
+
+		case POS_SLEEPING:
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("氷淡 錚뿔?"));
+			break;
+
+		case POS_RESTING:
+		case POS_SITTING:
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 耉 ."));
+			break;
+			/*
+			case POS_FIGHTING:
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("    都求.  究."));
+				break;
+			*/
+		default:
+			sys_err("unknown position %d", ch->GetPosition());
+			break;
+		}
+
+		return;
+	}
+
+	if (*cmd_info[icmd].command == '\n')
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("瀏  求"));
+		return;
+	}
+
+	if (cmd_info[icmd].gm_level && cmd_info[icmd].gm_level > ch->GetGMLevel())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("瀏  求"));
+		return;
+	}
+
+	if (strncmp("phase", cmd_info[icmd].command, 5) != 0) //   처 
+		sys_log(0, "COMMAND: %s: %s", ch->GetName(), cmd_info[icmd].command);
+
+	((*cmd_info[icmd].command_pointer) (ch, line, icmd, cmd_info[icmd].subcmd));
+
+	if (ch->GetGMLevel() >= GM_LOW_WIZARD)
+	{
+		if (cmd_info[icmd].gm_level >= GM_LOW_WIZARD)
+		{
+			if (LC_IsEurope() == true || /* LC_IsNewCIBN() == true || */LC_IsCanada() == true || LC_IsBrazil() == true)
+			{
+				char buf[1024];
+				snprintf(buf, sizeof(buf), "%s", argument);
+
+				LogManager::instance().GMCommandLog(ch->GetPlayerID(), ch->GetName(), ch->GetDesc()->GetHostName(), g_bChannel, buf);
+			}
+		}
+	}
+}
diff --git a/server/server/home/metin2/Source/Server/game/src/cmd_gm.cpp b/server/server/home/metin2/Source/Server/game/src/cmd_gm.cpp
index 84bdfe8..34dacbc 100644
--- a/server/server/home/metin2/Source/Server/game/src/cmd_gm.cpp
+++ b/server/server/home/metin2/Source/Server/game/src/cmd_gm.cpp
@@ -1,6379 +1,6382 @@
-#include "stdafx.h"
-#include "utils.h"
-#include "config.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "item_manager.h"
-#include "sectree_manager.h"
-#include "mob_manager.h"
-#include "packet.h"
-#include "cmd.h"
-#include "regen.h"
-#include "guild.h"
-#include "guild_manager.h"
-#include "p2p.h"
-#include "buffer_manager.h"
-#include "fishing.h"
-#include "mining.h"
-#include "questmanager.h"
-#include "vector.h"
-#include "affect.h"
-#include "db.h"
-#include "priv_manager.h"
-#include "building.h"
-#include "battle.h"
-#include "arena.h"
-#include "start_position.h"
-#include "party.h"
-#include "monarch.h"
-#include "castle.h"
-#include "BattleArena.h"
-#include "xmas_event.h"
-#include "log.h"
-#include "pcbang.h"
-#include "threeway_war.h"
-#include "unique_item.h"
-#include "DragonSoul.h"
-#include "shop_manager.h"
-#include "OXEvent.h"
-#if defined(__DEFENSE_WAVE__)
-#	include "defense_wave.h"
-#endif
-#if defined(__EXTENDED_RELOAD__)
-#	include "mob_manager.h"
-#endif
-#if defined(__OFFLINE_SHOP__)
-#include "OfflineShop.h"
-#endif
-
-extern bool DropEvent_RefineBox_SetValue(const std::string& name, int value);
-
-// ADD_COMMAND_SLOW_STUN
-enum
-{
-	COMMANDAFFECT_STUN,
-	COMMANDAFFECT_SLOW,
-};
-
-void Command_ApplyAffect(LPCHARACTER ch, const char* argument, const char* affectName, int cmdAffect)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	sys_log(0, arg1);
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: %s <name>", affectName);
-		return;
-	}
-
-	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-	if (!tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s is not in same map", arg1);
-		return;
-	}
-
-	switch (cmdAffect)
-	{
-		case COMMANDAFFECT_STUN:
-			SkillAttackAffect(tch, 1000, IMMUNE_STUN, AFFECT_STUN, POINT_NONE, 0, AFF_STUN, 30, "GM_STUN");
-			break;
-		case COMMANDAFFECT_SLOW:
-			SkillAttackAffect(tch, 1000, IMMUNE_SLOW, AFFECT_SLOW, POINT_MOV_SPEED, -30, AFF_SLOW, 30, "GM_SLOW");
-			break;
-	}
-
-	sys_log(0, "%s %s", arg1, affectName);
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "%s %s", arg1, affectName);
-}
-// END_OF_ADD_COMMAND_SLOW_STUN
-
-ACMD(do_pcbang_update)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	unsigned long PCBangID = 0;
-
-	if (*arg1 == '\0')
-		PCBangID = 0;
-	else
-		str_to_number(PCBangID, arg1);
-
-	if (PCBangID == 0)
-	{
-		CPCBangManager::instance().RequestUpdateIPList(0);
-		ch->ChatPacket(CHAT_TYPE_INFO, "PCBang Info Update For All");
-	}
-	else
-	{
-		CPCBangManager::instance().RequestUpdateIPList(PCBangID);
-		ch->ChatPacket(CHAT_TYPE_INFO, "PCBang Info Update For %u", PCBangID);
-	}
-
-	TPacketPCBangUpdate packet;
-	packet.bHeader = HEADER_GG_PCBANG_UPDATE;
-	packet.ulPCBangID = PCBangID;
-
-	P2P_MANAGER::instance().Send(&packet, sizeof(TPacketPCBangUpdate));
-
-}
-
-ACMD(do_pcbang_check)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (CPCBangManager::instance().IsPCBangIP(arg1) == true)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s is a PCBang IP", arg1);
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s is not a PCBang IP", arg1);
-	}
-}
-
-ACMD(do_stun)
-{
-	Command_ApplyAffect(ch, argument, "stun", COMMANDAFFECT_STUN);
-}
-
-ACMD(do_slow)
-{
-	Command_ApplyAffect(ch, argument, "slow", COMMANDAFFECT_SLOW);
-}
-
-ACMD(do_transfer)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: transfer <name>");
-		return;
-	}
-
-	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-	if (!tch)
-	{
-		CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
-
-		if (pkCCI)
-		{
-			if (pkCCI->bChannel != g_bChannel)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, "Target is in %d channel (my channel %d)", pkCCI->bChannel, g_bChannel);
-				return;
-			}
-
-			TPacketGGTransfer pgg;
-
-			pgg.bHeader = HEADER_GG_TRANSFER;
-			strlcpy(pgg.szName, arg1, sizeof(pgg.szName));
-			pgg.lX = ch->GetX();
-			pgg.lY = ch->GetY();
-
-			P2P_MANAGER::instance().Send(&pgg, sizeof(TPacketGGTransfer));
-			ch->ChatPacket(CHAT_TYPE_INFO, "Transfer requested.");
-		}
-		else
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "There is no character(%s) by that name", arg1);
-			sys_log(0, "There is no character(%s) by that name", arg1);
-		}
-
-		return;
-	}
-
-	if (ch == tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Transfer me?!?");
-		return;
-	}
-
-	//tch->Show(ch->GetMapIndex(), ch->GetX(), ch->GetY(), ch->GetZ());
-	tch->WarpSet(ch->GetX(), ch->GetY(), ch->GetMapIndex());
-}
-
-ACMD(do_transfer_force)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: transfer_force <name>");
-		return;
-	}
-
-	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-	if (!tch)
-	{
-		CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
-
-		if (pkCCI)
-		{
-			TPacketGGTransfer pgg;
-
-			pgg.bHeader = HEADER_GG_TRANSFER;
-			strlcpy(pgg.szName, arg1, sizeof(pgg.szName));
-			pgg.lX = ch->GetX();
-			pgg.lY = ch->GetY();
-
-			P2P_MANAGER::instance().Send(&pgg, sizeof(TPacketGGTransfer));
-			ch->ChatPacket(CHAT_TYPE_INFO, "Transfer requested.");
-		}
-		else
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "There is no character(%s) by that name", arg1);
-			sys_log(0, "There is no character(%s) by that name", arg1);
-		}
-
-		return;
-	}
-
-	if (ch == tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Transfer me?!?");
-		return;
-	}
-
-	//tch->Show(ch->GetMapIndex(), ch->GetX(), ch->GetY(), ch->GetZ());
-	tch->WarpSet(ch->GetX(), ch->GetY(), ch->GetMapIndex());
-}
-
-// LUA_ADD_GOTO_INFO
-struct GotoInfo
-{
-	std::string st_name;
-
-	BYTE empire;
-	int mapIndex;
-	DWORD x, y;
-
-	GotoInfo()
-	{
-		st_name = "";
-		empire = 0;
-		mapIndex = 0;
-
-		x = 0;
-		y = 0;
-	}
-	GotoInfo(const GotoInfo& c_src)
-	{
-		__copy__(c_src);
-	}
-	void operator = (const GotoInfo& c_src)
-	{
-		__copy__(c_src);
-	}
-	void __copy__(const GotoInfo& c_src)
-	{
-		st_name = c_src.st_name;
-		empire = c_src.empire;
-		mapIndex = c_src.mapIndex;
-
-		x = c_src.x;
-		y = c_src.y;
-	}
-};
-
-static std::vector<GotoInfo> gs_vec_gotoInfo;
-
-void CHARACTER_AddGotoInfo(const std::string& c_st_name, BYTE empire, int mapIndex, DWORD x, DWORD y)
-{
-	GotoInfo newGotoInfo;
-	newGotoInfo.st_name = c_st_name;
-	newGotoInfo.empire = empire;
-	newGotoInfo.mapIndex = mapIndex;
-	newGotoInfo.x = x;
-	newGotoInfo.y = y;
-	gs_vec_gotoInfo.push_back(newGotoInfo);
-
-	sys_log(0, "AddGotoInfo(name=%s, empire=%d, mapIndex=%d, pos=(%d, %d))", c_st_name.c_str(), empire, mapIndex, x, y);
-}
-
-bool FindInString(const char* c_pszFind, const char* c_pszIn)
-{
-	const char* c = c_pszIn;
-	const char* p;
-
-	p = strchr(c, '|');
-
-	if (!p)
-		return (0 == strncasecmp(c_pszFind, c_pszIn, strlen(c_pszFind)));
-	else
-	{
-		char sz[64 + 1];
-
-		do
-		{
-			strlcpy(sz, c, MIN(sizeof(sz), (p - c) + 1));
-
-			if (!strncasecmp(c_pszFind, sz, strlen(c_pszFind)))
-				return true;
-
-			c = p + 1;
-		} while ((p = strchr(c, '|')));
-
-		strlcpy(sz, c, sizeof(sz));
-
-		if (!strncasecmp(c_pszFind, sz, strlen(c_pszFind)))
-			return true;
-	}
-
-	return false;
-}
-
-bool CHARACTER_GoToName(LPCHARACTER ch, BYTE empire, int mapIndex, const char* gotoName)
-{
-	std::vector<GotoInfo>::iterator i;
-	for (i = gs_vec_gotoInfo.begin(); i != gs_vec_gotoInfo.end(); ++i)
-	{
-		const GotoInfo& c_eachGotoInfo = *i;
-
-		if (mapIndex != 0)
-		{
-			if (mapIndex != c_eachGotoInfo.mapIndex)
-				continue;
-		}
-		else if (!FindInString(gotoName, c_eachGotoInfo.st_name.c_str()))
-			continue;
-
-		if (c_eachGotoInfo.empire == 0 || c_eachGotoInfo.empire == empire)
-		{
-			int x = c_eachGotoInfo.x * 100;
-			int y = c_eachGotoInfo.y * 100;
-
-			ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", x, y);
-			ch->WarpSet(x, y);
-			ch->Stop();
-			return true;
-		}
-	}
-	return false;
-}
-
-// END_OF_LUA_ADD_GOTO_INFO
-
-/*
-{
-	{ "A1|영안읍성", 0, 1, 4693, 9642 },
-	{ "A3|자양현", 0, 3, 3608, 8776 },
-
-	{ "B1|조안읍성", 0, 21, 557, 1579 },
-	{ "B3|복정현", 0, 23, 1385, 2349 },
-
-	{ "C1|평무읍성", 0, 41, 9696, 2784 },
-	{ "C3|박라현", 0, 43, 8731, 2426 },
-
-	// Snow
-	{ "Snow|서한산", 1, 61, 4342, 2906 },
-	{ "Snow|서한산", 2, 61, 3752, 1749 },
-	{ "Snow|서한산", 3, 61, 4918, 1736 },
-
-	// Flame
-	{ "Flame|도염화지|화염", 1, 62, 5994, 7563 },
-	{ "Flame|도염화지|화염", 2, 62, 5978, 6222 },
-	{ "Flame|도염화지|화염", 3, 62, 7307, 6898 },
-
-	// Desert
-	{ "Desert|영비사막|사막", 1, 63, 2178, 6272 },
-	{ "Desert|영비사막|사막", 2, 63, 2219, 5027 },
-	{ "Desert|영비사막|사막", 3, 63, 3440, 5025 },
-
-	// Threeway
-	{ "Three|승룡곡", 1, 64, 4021, 6739 },
-	{ "Three|승룡곡", 2, 64, 2704, 7399 },
-	{ "Three|승룡곡", 3, 64, 3213, 8080 },
-
-	// 밀교사원
-	{ "Milgyo|밀교사원", 1, 65, 5536, 1436 },
-	{ "Milgyo|밀교사원", 2, 65, 5536, 1436 },
-	{ "Milgyo|밀교사원", 3, 65, 5536, 1436 },
-
-	// 사귀타워입구
-	{ "사귀타워입구", 1, 65, 5905, 1108 },
-	{ "사귀타워입구", 2, 65, 5905, 1108 },
-	{ "사귀타워입구", 3, 65, 5905, 1108 },
-
-	{ NULL, 0, 0, 0, 0 },
-};
-*/
-
-ACMD(do_goto)
-{
-	char arg1[256], arg2[256];
-	int x = 0, y = 0, z = 0;
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1 && !*arg2)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: goto <x meter> <y meter>");
-		return;
-	}
-
-	if (isnhdigit(*arg1) && isnhdigit(*arg2))
-	{
-		str_to_number(x, arg1);
-		str_to_number(y, arg2);
-
-		PIXEL_POSITION p;
-
-		if (SECTREE_MANAGER::instance().GetMapBasePosition(ch->GetX(), ch->GetY(), p))
-		{
-			x += p.x / 100;
-			y += p.y / 100;
-		}
-
-		ch->ChatPacket(CHAT_TYPE_INFO, "You goto ( %d, %d )", x, y);
-	}
-	else
-	{
-		int mapIndex = 0;
-		BYTE empire = 0;
-
-		if (*arg1 == '#')
-			str_to_number(mapIndex, (arg1 + 1));
-
-		if (*arg2 && isnhdigit(*arg2))
-		{
-			str_to_number(empire, arg2);
-			empire = MINMAX(1, empire, 3);
-		}
-		else
-			empire = ch->GetEmpire();
-
-		if (CHARACTER_GoToName(ch, empire, mapIndex, arg1))
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "Cannot find map command syntax: /goto <mapname> [empire]");
-			return;
-		}
-
-		return;
-
-		/*
-		int iMapIndex = 0;
-		for (int i = 0; aWarpInfo[i].c_pszName != NULL; ++i)
-		{
-			if (iMapIndex != 0)
-			{
-				if (iMapIndex != aWarpInfo[i].iMapIndex)
-					continue;
-			}
-			else if (!FindInString(arg1, aWarpInfo[i].c_pszName))
-				continue;
-
-			if (aWarpInfo[i].bEmpire == 0 || aWarpInfo[i].bEmpire == bEmpire)
-			{
-				x = aWarpInfo[i].x * 100;
-				y = aWarpInfo[i].y * 100;
-
-				ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", x, y);
-				ch->WarpSet(x, y);
-				ch->Stop();
-				return;
-			}
-		}
-		*/
-	}
-
-	x *= 100;
-	y *= 100;
-
-	ch->Show(ch->GetMapIndex(), x, y, z);
-	ch->Stop();
-}
-
-ACMD(do_warp)
-{
-	char arg1[256], arg2[256];
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: warp <character name> | <x meter> <y meter>");
-		return;
-	}
-
-	int x = 0, y = 0;
-
-	if (isnhdigit(*arg1) && isnhdigit(*arg2))
-	{
-		str_to_number(x, arg1);
-		str_to_number(y, arg2);
-	}
-	else
-	{
-		LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-
-		if (NULL == tch)
-		{
-			const CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
-
-			if (NULL != pkCCI)
-			{
-				if (pkCCI->bChannel != g_bChannel)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, "Target is in %d channel (my channel %d)", pkCCI->bChannel, g_bChannel);
-					return;
-				}
-
-				ch->WarpToPID(pkCCI->dwPID);
-			}
-			else
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, "There is no one by that name");
-			}
-
-			return;
-		}
-		else
-		{
-			x = tch->GetX() / 100;
-			y = tch->GetY() / 100;
-		}
-	}
-
-	x *= 100;
-	y *= 100;
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", x, y);
-	ch->WarpSet(x, y);
-	ch->Stop();
-}
-
-ACMD(do_warp_force)
-{
-	char arg1[256], arg2[256];
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: warp <character name> | <x meter> <y meter>");
-		return;
-	}
-
-	int x = 0, y = 0;
-
-	if (isnhdigit(*arg1) && isnhdigit(*arg2))
-	{
-		str_to_number(x, arg1);
-		str_to_number(y, arg2);
-	}
-	else
-	{
-		LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-
-		if (NULL == tch)
-		{
-			const CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
-
-			if (NULL != pkCCI)
-				ch->WarpToPID(pkCCI->dwPID, true /* bWarpForce */);
-			else
-				ch->ChatPacket(CHAT_TYPE_INFO, "There is no one by that name");
-
-			return;
-		}
-		else
-		{
-			x = tch->GetX() / 100;
-			y = tch->GetY() / 100;
-		}
-	}
-
-	x *= 100;
-	y *= 100;
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", x, y);
-	ch->WarpSet(x, y);
-	ch->Stop();
-}
-
-ACMD(do_item)
-{
-	char arg1[256], arg2[256];
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: item <item vnum>");
-		return;
-	}
-
-	int iCount = 1;
-
-	if (*arg2)
-	{
-		str_to_number(iCount, arg2);
-		iCount = MINMAX(1, iCount, ITEM_MAX_COUNT);
-	}
-
-	DWORD dwVnum;
-
-	if (isnhdigit(*arg1))
-		str_to_number(dwVnum, arg1);
-	else
-	{
-		if (!ITEM_MANAGER::instance().GetVnum(arg1, dwVnum))
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "#%u item not exist by that vnum.", dwVnum);
-			return;
-		}
-	}
-
-	LPITEM item = ITEM_MANAGER::instance().CreateItem(dwVnum, iCount, 0, true);
-
-	if (item)
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-		{
-			int iEmptyPos = ch->GetEmptyDragonSoulInventory(item);
-
-			if (iEmptyPos != -1)
-			{
-				item->AddToCharacter(ch, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyPos));
-				LogManager::instance().ItemLog(ch, item, "GM", item->GetName());
-			}
-			else
-			{
-				M2_DESTROY_ITEM(item);
-				if (!ch->DragonSoul_IsQualified())
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Before you open the Cor Draconis, you have to complete the Dragon Stone quest and activate the Dragon Stone Alchemy."));
-				}
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough space in your inventory."));
-			}
-		}
-		else
-#endif
-		{
-			int iEmptyPos = ch->GetEmptyInventory(item->GetSize());
-
-			if (iEmptyPos != -1)
-			{
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-				item->AddToCharacter(ch, TItemPos(INVENTORY, iEmptyPos), true);
-#else
-				item->AddToCharacter(ch, TItemPos(INVENTORY, iEmptyPos));
-
-#endif
-				LogManager::instance().ItemLog(ch, item, "GM", item->GetName());
-			}
-			else
-			{
-				M2_DESTROY_ITEM(item);
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough space in your inventory."));
-			}
-		}
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "#%u item not exist by that vnum.", dwVnum);
-	}
-}
-
-ACMD(do_group_random)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: grrandom <group vnum>");
-		return;
-	}
-
-	DWORD dwVnum = 0;
-	str_to_number(dwVnum, arg1);
-	CHARACTER_MANAGER::instance().SpawnGroupGroup(dwVnum, ch->GetMapIndex(), ch->GetX() - 500, ch->GetY() - 500, ch->GetX() + 500, ch->GetY() + 500);
-}
-
-ACMD(do_group)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: group <group vnum>");
-		return;
-	}
-
-	DWORD dwVnum = 0;
-	str_to_number(dwVnum, arg1);
-
-	if (test_server)
-		sys_log(0, "COMMAND GROUP SPAWN %u at %u %u %u", dwVnum, ch->GetMapIndex(), ch->GetX(), ch->GetY());
-
-	CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, ch->GetMapIndex(), ch->GetX() - 500, ch->GetY() - 500, ch->GetX() + 500, ch->GetY() + 500);
-}
-
-ACMD(do_mob_coward)
-{
-	char arg1[256], arg2[256];
-	DWORD vnum = 0;
-	LPCHARACTER tch;
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mc <vnum>");
-		return;
-	}
-
-	const CMob* pkMob;
-
-	if (isdigit(*arg1))
-	{
-		str_to_number(vnum, arg1);
-
-		if ((pkMob = CMobManager::instance().Get(vnum)) == NULL)
-			vnum = 0;
-	}
-	else
-	{
-		pkMob = CMobManager::Instance().Get(arg1, true);
-
-		if (pkMob)
-			vnum = pkMob->m_table.dwVnum;
-	}
-
-	if (vnum == 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "No such mob by that vnum");
-		return;
-	}
-
-	int iCount = 0;
-
-	if (*arg2)
-		str_to_number(iCount, arg2);
-	else
-		iCount = 1;
-
-	iCount = MIN(20, iCount);
-
-	while (iCount--)
-	{
-		tch = CHARACTER_MANAGER::instance().SpawnMobRange(vnum,
-			ch->GetMapIndex(),
-			ch->GetX() - number(200, 750),
-			ch->GetY() - number(200, 750),
-			ch->GetX() + number(200, 750),
-			ch->GetY() + number(200, 750),
-			true,
-			pkMob->m_table.bType == CHAR_TYPE_STONE);
-		if (tch)
-			tch->SetCoward();
-	}
-}
-
-ACMD(do_mob_map)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: mm <vnum>");
-		return;
-	}
-
-	DWORD vnum = 0;
-	str_to_number(vnum, arg1);
-	LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRandomPosition(vnum, ch->GetMapIndex());
-
-	if (tch)
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s spawned in %dx%d", tch->GetName(), tch->GetX(), tch->GetY());
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, "Spawn failed.");
-}
-
-ACMD(do_mob_aggresive)
-{
-	char arg1[256], arg2[256];
-	DWORD vnum = 0;
-	LPCHARACTER tch;
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mob <mob vnum>");
-		return;
-	}
-
-	const CMob* pkMob;
-
-	if (isdigit(*arg1))
-	{
-		str_to_number(vnum, arg1);
-
-		if ((pkMob = CMobManager::instance().Get(vnum)) == NULL)
-			vnum = 0;
-	}
-	else
-	{
-		pkMob = CMobManager::Instance().Get(arg1, true);
-
-		if (pkMob)
-			vnum = pkMob->m_table.dwVnum;
-	}
-
-	if (vnum == 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "No such mob by that vnum");
-		return;
-	}
-
-	int iCount = 0;
-
-	if (*arg2)
-		str_to_number(iCount, arg2);
-	else
-		iCount = 1;
-
-	iCount = MIN(20, iCount);
-
-	while (iCount--)
-	{
-		tch = CHARACTER_MANAGER::instance().SpawnMobRange(vnum,
-			ch->GetMapIndex(),
-			ch->GetX() - number(200, 750),
-			ch->GetY() - number(200, 750),
-			ch->GetX() + number(200, 750),
-			ch->GetY() + number(200, 750),
-			true,
-			pkMob->m_table.bType == CHAR_TYPE_STONE);
-		if (tch)
-			tch->SetAggressive();
-	}
-}
-
-ACMD(do_mob)
-{
-	char arg1[256], arg2[256];
-	DWORD vnum = 0;
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mob <mob vnum>");
-		return;
-	}
-
-	const CMob* pkMob = NULL;
-
-	if (isnhdigit(*arg1))
-	{
-		str_to_number(vnum, arg1);
-
-		if ((pkMob = CMobManager::instance().Get(vnum)) == NULL)
-			vnum = 0;
-	}
-	else
-	{
-		pkMob = CMobManager::Instance().Get(arg1, true);
-
-		if (pkMob)
-			vnum = pkMob->m_table.dwVnum;
-	}
-
-	if (vnum == 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "No such mob by that vnum");
-		return;
-	}
-
-	int iCount = 0;
-
-	if (*arg2)
-		str_to_number(iCount, arg2);
-	else
-		iCount = 1;
-
-	if (test_server)
-		iCount = MIN(40, iCount);
-	else
-		iCount = MIN(20, iCount);
-
-	while (iCount--)
-	{
-		CHARACTER_MANAGER::instance().SpawnMobRange(vnum,
-			ch->GetMapIndex(),
-			ch->GetX() - number(200, 750),
-			ch->GetY() - number(200, 750),
-			ch->GetX() + number(200, 750),
-			ch->GetY() + number(200, 750),
-			true,
-			pkMob->m_table.bType == CHAR_TYPE_STONE);
-	}
-}
-
-ACMD(do_mob_ld)
-{
-	char arg1[256], arg2[256], arg3[256], arg4[256];
-	DWORD vnum = 0;
-
-	two_arguments(two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2)), arg3, sizeof(arg3), arg4, sizeof(arg4));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mob <mob vnum>");
-		return;
-	}
-
-	const CMob* pkMob = NULL;
-
-	if (isnhdigit(*arg1))
-	{
-		str_to_number(vnum, arg1);
-
-		if ((pkMob = CMobManager::instance().Get(vnum)) == NULL)
-			vnum = 0;
-	}
-	else
-	{
-		pkMob = CMobManager::Instance().Get(arg1, true);
-
-		if (pkMob)
-			vnum = pkMob->m_table.dwVnum;
-	}
-
-	if (vnum == 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "No such mob by that vnum");
-		return;
-	}
-
-	int dir = 1;
-	long x, y;
-
-	if (*arg2)
-		str_to_number(x, arg2);
-	if (*arg3)
-		str_to_number(y, arg3);
-	if (*arg4)
-		str_to_number(dir, arg4);
-
-	CHARACTER_MANAGER::instance().SpawnMob(vnum,
-		ch->GetMapIndex(),
-		x * 100,
-		y * 100,
-		ch->GetZ(),
-		pkMob->m_table.bType == CHAR_TYPE_STONE,
-		dir);
-}
-
-struct FuncPurge
-{
-	LPCHARACTER m_pkGM;
-	bool m_bAll;
-
-	FuncPurge(LPCHARACTER ch) : m_pkGM(ch), m_bAll(false)
-	{
-	}
-
-	void operator () (LPENTITY ent)
-	{
-		if (!ent->IsType(ENTITY_CHARACTER))
-			return;
-
-		LPCHARACTER pkChr = (LPCHARACTER)ent;
-
-		int iDist = DISTANCE_APPROX(pkChr->GetX() - m_pkGM->GetX(), pkChr->GetY() - m_pkGM->GetY());
-
-		if (!m_bAll && iDist >= 1000) // 10미터 이상에 있는 것들은 purge 하지 않는다.
-			return;
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-		if (CGuildDragonLairManager::Instance().IsUnique(pkChr))
-			return;
-#endif
-
-#if defined(__DEFENSE_WAVE__)
-		if (pkChr->GetDefenseWave() && pkChr->GetDefenseWave()->IsUnique(pkChr))
-			return;
-#endif
-
-		sys_log(0, "PURGE: %s %d", pkChr->GetName(), iDist);
-
-		// todo : check instances
-		if (pkChr->IsNPC() && pkChr->GetRider() == NULL
-#if defined(__PET_SYSTEM__)
-			&& !pkChr->IsPet()
-#endif
-#if defined(__GROWTH_PET_SYSTEM__)
-			&& !pkChr->IsGrowthPet()
-#endif
-			)
-		{
-			M2_DESTROY_CHARACTER(pkChr);
-		}
-	}
-};
-
-ACMD(do_purge)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	FuncPurge func(ch);
-
-	if (*arg1 && !strcmp(arg1, "all"))
-		func.m_bAll = true;
-
-	LPSECTREE sectree = ch->GetSectree();
-	if (sectree) // #431
-		sectree->ForEachAround(func);
-	else
-		sys_err("PURGE_ERROR.NULL_SECTREE(mapIndex=%d, pos=(%d, %d)", ch->GetMapIndex(), ch->GetX(), ch->GetY());
-}
-
-static void ipurge_window(const LPCHARACTER& ch, BYTE window_type)
-{
-	if (NULL == ch)
-		return;
-
-	WORD cell = 0;
-	LPITEM item = nullptr;
-
-	if (INVENTORY == window_type)
-	{
-		for (cell = 0; cell < INVENTORY_MAX_NUM; ++cell)
-		{
-			if ((item = ch->GetInventoryItem(cell)))
-			{
-				if (item->isLocked())
-					continue;
-
-#ifdef __GROWTH_PET_SYSTEM__
-				if (item->GetType() == ITEM_PET)
-				{
-					if (item->GetSubType() == PET_UPBRINGING || item->GetSubType() == PET_BAG)
-						CGrowthPetManager::Instance().DeleteGrowthPet(item->GetSocket(2), true);
-				}
-#endif
-
-				ITEM_MANAGER::instance().RemoveItem(item, "PURGE");
-				ch->SyncQuickslot(SLOT_TYPE_INVENTORY, cell, WORD_MAX);
-			}
-		}
-	}
-	else if (EQUIPMENT == window_type)
-	{
-		for (cell = 0; cell < EQUIPMENT_MAX_NUM; ++cell)
-			if ((item = ch->GetEquipmentItem(cell)))
-				ITEM_MANAGER::instance().RemoveItem(item, "PURGE");
-	}
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	else if (DRAGON_SOUL_INVENTORY == window_type)
-	{
-		for (cell = 0; cell < DRAGON_SOUL_INVENTORY_MAX_NUM; ++cell)
-			if ((item = ch->GetItem(TItemPos(DRAGON_SOUL_INVENTORY, cell))))
-				ITEM_MANAGER::instance().RemoveItem(item, "PURGE");
-	}
-#endif
-	else if (BELT_INVENTORY == window_type)
-	{
-		for (cell = 0; cell < BELT_INVENTORY_SLOT_COUNT; ++cell)
-		{
-			if ((item = ch->GetBeltInventoryItem(cell)))
-			{
-				if (item->isLocked())
-					continue;
-
-				ITEM_MANAGER::instance().RemoveItem(item, "PURGE");
-			}
-		}
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Unknown window.");
-	}
-}
-
-ACMD(do_item_purge)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-	if (!*arg1)
-		goto USAGE;
-
-	if (!strcmp(arg1, "all"))
-	{
-		ipurge_window(ch, INVENTORY);
-		ipurge_window(ch, EQUIPMENT);
-		ipurge_window(ch, DRAGON_SOUL_INVENTORY);
-		ipurge_window(ch, BELT_INVENTORY);
-		ch->ChatPacket(CHAT_TYPE_INFO, "all items cleared");
-	}
-	else if (!strcmp(arg1, "inven"))
-	{
-		ipurge_window(ch, INVENTORY);
-		ch->ChatPacket(CHAT_TYPE_INFO, "inventory items cleared");
-	}
-	else if (!strcmp(arg1, "equip"))
-	{
-		ipurge_window(ch, EQUIPMENT);
-		ch->ChatPacket(CHAT_TYPE_INFO, "equipment items cleared!");
-	}
-	else if (!strcmp(arg1, "ds"))
-	{
-		ipurge_window(ch, DRAGON_SOUL_INVENTORY);
-		ch->ChatPacket(CHAT_TYPE_INFO, "dragon soul items cleared!");
-	}
-	else if (!strcmp(arg1, "belt"))
-	{
-		ipurge_window(ch, BELT_INVENTORY);
-		ch->ChatPacket(CHAT_TYPE_INFO, "belt items cleared!");
-	}
-	else
-		goto USAGE;
-
-	return;
-
-USAGE:
-	ch->ChatPacket(CHAT_TYPE_INFO, "usage : ipurge <window>");
-	ch->ChatPacket(CHAT_TYPE_INFO, "		<window> inven, equip, ds, belt");
-}
-
-ACMD(do_state)
-{
-	char arg1[256];
-	LPCHARACTER tch;
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (*arg1)
-	{
-		if (arg1[0] == '#')
-		{
-			tch = CHARACTER_MANAGER::instance().Find(strtoul(arg1 + 1, NULL, 10));
-		}
-		else
-		{
-			LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
-
-			if (!d)
-				tch = NULL;
-			else
-				tch = d->GetCharacter();
-		}
-	}
-	else
-		tch = ch;
-
-	if (!tch)
-		return;
-
-	char buf[256];
-
-	snprintf(buf, sizeof(buf), "%s's State: ", tch->GetName());
-
-	if (tch->IsPosition(POS_FIGHTING))
-		strlcat(buf, "Battle", sizeof(buf));
-	else if (tch->IsPosition(POS_DEAD))
-		strlcat(buf, "Dead", sizeof(buf));
-	else
-		strlcat(buf, "Standing", sizeof(buf));
-
-	if (ch->GetShop())
-		strlcat(buf, ", Shop", sizeof(buf));
-
-	if (ch->GetExchange())
-		strlcat(buf, ", Exchange", sizeof(buf));
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "%s", buf);
-
-	int len;
-	len = snprintf(buf, sizeof(buf), "Coordinate %ldx%ld (%ldx%ld)",
-		tch->GetX(), tch->GetY(), tch->GetX() / 100, tch->GetY() / 100);
-
-	if (len < 0 || len >= (int)sizeof(buf))
-		len = sizeof(buf) - 1;
-
-	LPSECTREE pSec = SECTREE_MANAGER::instance().Get(tch->GetMapIndex(), tch->GetX(), tch->GetY());
-
-	if (pSec)
-	{
-		TMapSetting& map_setting = SECTREE_MANAGER::instance().GetMap(tch->GetMapIndex())->m_setting;
-		snprintf(buf + len, sizeof(buf) - len, " MapIndex %ld Attribute %08X Local Position (%ld x %ld)",
-			tch->GetMapIndex(), pSec->GetAttribute(tch->GetX(), tch->GetY()), (tch->GetX() - map_setting.iBaseX) / 100, (tch->GetY() - map_setting.iBaseY) / 100);
-	}
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "%s", buf);
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "LEV %d", tch->GetLevel());
-	ch->ChatPacket(CHAT_TYPE_INFO, "HP %d/%d", tch->GetHP(), tch->GetMaxHP());
-	ch->ChatPacket(CHAT_TYPE_INFO, "SP %d/%d", tch->GetSP(), tch->GetMaxSP());
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "SUNGMA_STR %d SUNGMA_HP %d SUNGMA_MOVE %d SUNGMA_IMMUNE %d",
-		tch->GetPoint(POINT_SUNGMA_STR),
-		tch->GetPoint(POINT_SUNGMA_HP),
-		tch->GetPoint(POINT_SUNGMA_MOVE),
-		tch->GetPoint(POINT_SUNGMA_IMMUNE)
-	);
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "ATT_SPD %d/%d (LIMIT) MOVE_SPD %d/%d (LIMIT) CAST_SPD %d",
-		tch->GetPoint(POINT_ATT_SPEED), tch->GetLimitPoint(POINT_ATT_SPEED),
-		tch->GetPoint(POINT_MOV_SPEED), tch->GetLimitPoint(POINT_MOV_SPEED),
-		tch->GetPoint(POINT_CASTING_SPEED));
-	ch->ChatPacket(CHAT_TYPE_INFO, "ATT %d MAGIC_ATT %d CRIT %d%% PENE %d%% ATT_BONUS %d%%",
-		tch->GetPoint(POINT_ATT_GRADE),
-		tch->GetPoint(POINT_MAGIC_ATT_GRADE),
-		tch->GetPoint(POINT_CRITICAL_PCT),
-		tch->GetPoint(POINT_PENETRATE_PCT),
-		tch->GetPoint(POINT_ATT_BONUS));
-	ch->ChatPacket(CHAT_TYPE_INFO, "DEF %d MAGIC_DEF %d BLOCK %d%% DODGE %d%% DEF_BONUS %d%%",
-		tch->GetPoint(POINT_DEF_GRADE),
-		tch->GetPoint(POINT_MAGIC_DEF_GRADE),
-		tch->GetPoint(POINT_BLOCK),
-		tch->GetPoint(POINT_DODGE),
-		tch->GetPoint(POINT_DEF_BONUS));
-	ch->ChatPacket(CHAT_TYPE_INFO, "RESISTANCES:");
-	ch->ChatPacket(CHAT_TYPE_INFO, "   WARR:%3d%% ASAS:%3d%% SURA:%3d%% SHAM:%3d%% WOLF:%3d%%"
-		, tch->GetPoint(POINT_RESIST_WARRIOR)
-		, tch->GetPoint(POINT_RESIST_ASSASSIN)
-		, tch->GetPoint(POINT_RESIST_SURA)
-		, tch->GetPoint(POINT_RESIST_SHAMAN)
-		, tch->GetPoint(POINT_RESIST_WOLFMAN)
-	);
-	ch->ChatPacket(CHAT_TYPE_INFO, "   SWORD:%3d%% THSWORD:%3d%% DAGGER:%3d%% BELL:%3d%% FAN:%3d%% BOW:%3d%% CLAW:%3d%%"
-		, tch->GetPoint(POINT_RESIST_SWORD)
-		, tch->GetPoint(POINT_RESIST_TWOHAND)
-		, tch->GetPoint(POINT_RESIST_DAGGER)
-		, tch->GetPoint(POINT_RESIST_BELL)
-		, tch->GetPoint(POINT_RESIST_FAN)
-		, tch->GetPoint(POINT_RESIST_BOW)
-		, tch->GetPoint(POINT_RESIST_CLAW)
-	);
-	ch->ChatPacket(CHAT_TYPE_INFO, "   FIRE:%3d%% ELEC:%3d%% MAGIC:%3d%% WIND:%3d%% CRIT:%3d%% PENE:%3d%%",
-		tch->GetPoint(POINT_RESIST_FIRE),
-		tch->GetPoint(POINT_RESIST_ELEC),
-		tch->GetPoint(POINT_RESIST_MAGIC),
-		tch->GetPoint(POINT_RESIST_WIND),
-		tch->GetPoint(POINT_RESIST_CRITICAL),
-		tch->GetPoint(POINT_RESIST_PENETRATE));
-	ch->ChatPacket(CHAT_TYPE_INFO, "   ICE:%3d%% EARTH:%3d%% DARK:%3d%%",
-		tch->GetPoint(POINT_RESIST_ICE),
-		tch->GetPoint(POINT_RESIST_EARTH),
-		tch->GetPoint(POINT_RESIST_DARK));
-
-#if defined(__MAGIC_REDUCTION__)
-	ch->ChatPacket(CHAT_TYPE_INFO, "   MAGIC_REDUCT:%3d%%", tch->GetPoint(POINT_RESIST_MAGIC_REDUCTION));
-#endif
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "MALL:");
-	ch->ChatPacket(CHAT_TYPE_INFO, "   ATT:%3d%% DEF:%3d%% EXP:%3d%% ITEMx%d GOLDx%d",
-		tch->GetPoint(POINT_MALL_ATTBONUS),
-		tch->GetPoint(POINT_MALL_DEFBONUS),
-		tch->GetPoint(POINT_MALL_EXPBONUS),
-		tch->GetPoint(POINT_MALL_ITEMBONUS) / 10,
-		tch->GetPoint(POINT_MALL_GOLDBONUS) / 10);
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "BONUS:");
-	ch->ChatPacket(CHAT_TYPE_INFO, "   SKILL:%3d%% NORMAL:%3d%% SKILL_DEF:%3d%% NORMAL_DEF:%3d%%",
-		tch->GetPoint(POINT_SKILL_DAMAGE_BONUS),
-		tch->GetPoint(POINT_NORMAL_HIT_DAMAGE_BONUS),
-		tch->GetPoint(POINT_SKILL_DEFEND_BONUS),
-		tch->GetPoint(POINT_NORMAL_HIT_DEFEND_BONUS));
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "   HUMAN:%3d%% ANIMAL:%3d%% ORC:%3d%% MILGYO:%3d%% UNDEAD:%3d%%",
-		tch->GetPoint(POINT_ATTBONUS_HUMAN),
-		tch->GetPoint(POINT_ATTBONUS_ANIMAL),
-		tch->GetPoint(POINT_ATTBONUS_ORC),
-		tch->GetPoint(POINT_ATTBONUS_MILGYO),
-		tch->GetPoint(POINT_ATTBONUS_UNDEAD));
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "   DEVIL:%3d%% INSECT:%3d%% FIRE:%3d%% ICE:%3d%% DESERT:%3d%%",
-		tch->GetPoint(POINT_ATTBONUS_DEVIL),
-		tch->GetPoint(POINT_ATTBONUS_INSECT),
-		tch->GetPoint(POINT_ATTBONUS_FIRE),
-		tch->GetPoint(POINT_ATTBONUS_ICE),
-		tch->GetPoint(POINT_ATTBONUS_DESERT));
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "   TREE:%3d%% MONSTER:%3d%% STONE:%3d%%",
-		tch->GetPoint(POINT_ATTBONUS_TREE),
-		tch->GetPoint(POINT_ATTBONUS_MONSTER),
-		tch->GetPoint(POINT_ATTBONUS_STONE));
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "   WARR:%3d%% ASAS:%3d%% SURA:%3d%% SHAM:%3d%%"
-		" WOLF:%3d%%"
-		, tch->GetPoint(POINT_ATTBONUS_WARRIOR)
-		, tch->GetPoint(POINT_ATTBONUS_ASSASSIN)
-		, tch->GetPoint(POINT_ATTBONUS_SURA)
-		, tch->GetPoint(POINT_ATTBONUS_SHAMAN)
-		, tch->GetPoint(POINT_ATTBONUS_WOLFMAN)
-	);
-
-#if defined(__ELEMENT_SYSTEM__)
-	ch->ChatPacket(CHAT_TYPE_INFO, "   HUMAN:%3d%%", tch->GetPoint(POINT_RESIST_HUMAN));
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "ENCHANTS:");
-	ch->ChatPacket(CHAT_TYPE_INFO, "   ELECT:%3d%% FIRE:%3d%% ICE:%3d%% WIND:%3d%% EARTH:%3d%% DARK:%3d%%",
-		tch->GetPoint(POINT_ENCHANT_ELECT),
-		tch->GetPoint(POINT_ENCHANT_FIRE),
-		tch->GetPoint(POINT_ENCHANT_ICE),
-		tch->GetPoint(POINT_ENCHANT_WIND),
-		tch->GetPoint(POINT_ENCHANT_EARTH),
-		tch->GetPoint(POINT_ENCHANT_DARK));
-	ch->ChatPacket(CHAT_TYPE_INFO, "   ZODIAC:%3d%%", tch->GetPoint(POINT_ATTBONUS_CZ));
-#endif
-
-	for (int i = 0; i < MAX_PRIV_NUM; ++i)
-		if (CPrivManager::instance().GetPriv(tch, i))
-		{
-			int iByEmpire = CPrivManager::instance().GetPrivByEmpire(tch->GetEmpire(), i);
-			int iByGuild = 0;
-
-			if (tch->GetGuild())
-				iByGuild = CPrivManager::instance().GetPrivByGuild(tch->GetGuild()->GetID(), i);
-
-			int iByPlayer = CPrivManager::instance().GetPrivByCharacter(tch->GetPlayerID(), i);
-
-			if (iByEmpire)
-				ch->ChatPacket(CHAT_TYPE_INFO, "%s for empire : %d", c_apszPrivNames[i], iByEmpire);
-
-			if (iByGuild)
-				ch->ChatPacket(CHAT_TYPE_INFO, "%s for guild : %d", c_apszPrivNames[i], iByGuild);
-
-			if (iByPlayer)
-				ch->ChatPacket(CHAT_TYPE_INFO, "%s for player : %d", c_apszPrivNames[i], iByPlayer);
-		}
-}
-
-struct notice_packet_func
-{
-	const char* m_str;
-	const bool m_big;
-
-	notice_packet_func(const char* str, const bool big) : m_str(str), m_big(big)
-	{
-	}
-
-	void operator () (LPDESC d)
-	{
-		if (!d->GetCharacter())
-			return;
-
-		d->GetCharacter()->ChatPacket(m_big ? CHAT_TYPE_BIG_NOTICE : CHAT_TYPE_NOTICE, "%s", m_str);
-	}
-};
-
-#if defined(__DUNGEON_RENEWAL__)
-struct party_notice_packet_func
-{
-	const LPPARTY m_pParty;
-	const char* m_szBuf;
-	party_notice_packet_func(const LPPARTY c_pParty, const char* c_szBuf) : m_pParty(c_pParty), m_szBuf(c_szBuf) {}
-	void operator () (LPDESC d)
-	{
-		const LPCHARACTER& pChar = d->GetCharacter();
-		if (pChar == nullptr)
-			return;
-
-		if (pChar->GetParty() != m_pParty)
-			return;
-
-		pChar->ChatPacket(CHAT_TYPE_PARTY, "%s", m_szBuf);
-	}
-};
-#endif
-
-struct monarch_notice_packet_func
-{
-	const char* m_str;
-	BYTE m_bEmpire;
-
-	monarch_notice_packet_func(BYTE bEmpire, const char* str) : m_str(str), m_bEmpire(bEmpire)
-	{
-	}
-
-	void operator () (LPDESC d)
-	{
-		if (!d->GetCharacter())
-			return;
-
-		if (m_bEmpire == d->GetCharacter()->GetEmpire())
-		{
-			d->GetCharacter()->ChatPacket(CHAT_TYPE_NOTICE, "%s", m_str);
-		}
-	}
-};
-
-void SendNotice(const char* c_pszBuf, const bool c_bBigFont)
-{
-	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
-	std::for_each(c_ref_set.begin(), c_ref_set.end(), notice_packet_func(c_pszBuf, c_bBigFont));
-}
-
-void SendMonarchNotice(BYTE bEmpire, const char* c_pszBuf)
-{
-	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
-	std::for_each(c_ref_set.begin(), c_ref_set.end(), monarch_notice_packet_func(bEmpire, c_pszBuf));
-}
-
-#if defined(__DUNGEON_RENEWAL__)
-void SendPartyNotice(const LPPARTY c_pParty, const char* c_pszBuf)
-{
-	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
-	std::for_each(c_ref_set.begin(), c_ref_set.end(), party_notice_packet_func(c_pParty, c_pszBuf));
-}
-#endif
-
-struct notice_map_packet_func
-{
-	const char* m_str;
-	int m_mapIndex;
-	bool m_bBigFont;
-
-	notice_map_packet_func(const char* str, int idx, bool bBigFont) : m_str(str), m_mapIndex(idx), m_bBigFont(bBigFont)
-	{
-	}
-
-	void operator() (LPDESC d)
-	{
-		if (d->GetCharacter() == NULL) return;
-		if (d->GetCharacter()->GetMapIndex() != m_mapIndex) return;
-
-		d->GetCharacter()->ChatPacket(m_bBigFont == true ? CHAT_TYPE_BIG_NOTICE : CHAT_TYPE_NOTICE, "%s", m_str);
-	}
-};
-
-void SendNoticeMap(const char* c_pszBuf, int nMapIndex, bool bBigFont)
-{
-	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
-	std::for_each(c_ref_set.begin(), c_ref_set.end(), notice_map_packet_func(c_pszBuf, nMapIndex, bBigFont));
-}
-
-#if defined(__OX_RENEWAL__)
-struct control_notice_packet_func
-{
-	const char* m_str;
-	int m_mapIndex;
-	control_notice_packet_func(const char* str, int idx) : m_str(str), m_mapIndex(idx) {}
-
-	void operator() (LPDESC d)
-	{
-		if (d->GetCharacter() == NULL) return;
-		if (d->GetCharacter()->GetMapIndex() != m_mapIndex) return;
-		d->GetCharacter()->ChatPacket(CHAT_TYPE_BIG_CONTROL_NOTICE, "%s", m_str);
-	}
-};
-
-void SendControlNoticeMap(const char* c_pszBuf, int nMapIndex)
-{
-	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
-	std::for_each(c_ref_set.begin(), c_ref_set.end(), control_notice_packet_func(c_pszBuf, nMapIndex));
-}
-#endif
-
-struct log_packet_func
-{
-	const char* m_str;
-
-	log_packet_func(const char* str) : m_str(str)
-	{
-	}
-
-	void operator () (LPDESC d)
-	{
-		if (!d->GetCharacter())
-			return;
-
-		if (d->GetCharacter()->GetGMLevel() > GM_PLAYER)
-			d->GetCharacter()->ChatPacket(CHAT_TYPE_NOTICE, "%s", m_str);
-	}
-};
-
-void SendLog(const char* c_pszBuf)
-{
-	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
-	std::for_each(c_ref_set.begin(), c_ref_set.end(), log_packet_func(c_pszBuf));
-}
-
-void BroadcastNotice(const char* c_pszBuf, const bool c_bBigFont)
-{
-	TPacketGGNotice p;
-	p.bHeader = HEADER_GG_NOTICE;
-	p.lSize = strlen(c_pszBuf) + 1;
-	p.bBigFont = c_bBigFont;
-
-	TEMP_BUFFER buf;
-	buf.write(&p, sizeof(p));
-	buf.write(c_pszBuf, p.lSize);
-
-	P2P_MANAGER::instance().Send(buf.read_peek(), buf.size()); // HEADER_GG_NOTICE
-
-	SendNotice(c_pszBuf, c_bBigFont);
-}
-
-void BroadcastMonarchNotice(BYTE bEmpire, const char* c_pszBuf)
-{
-	TPacketGGMonarchNotice p;
-	p.bHeader = HEADER_GG_MONARCH_NOTICE;
-	p.bEmpire = bEmpire;
-	p.lSize = strlen(c_pszBuf) + 1;
-
-	TEMP_BUFFER buf;
-	buf.write(&p, sizeof(p));
-	buf.write(c_pszBuf, p.lSize);
-
-	P2P_MANAGER::instance().Send(buf.read_peek(), buf.size());
-
-	SendMonarchNotice(bEmpire, c_pszBuf);
-}
-
-ACMD(do_notice)
-{
-	char buf[CHAT_MAX_LEN + 1];
-	snprintf(buf, sizeof(buf), "%s : %s", ch->GetName(), argument);
-	BroadcastNotice(buf);
-}
-
-ACMD(do_map_notice)
-{
-	char buf[CHAT_MAX_LEN + 1];
-	snprintf(buf, sizeof(buf), "%s : %s", ch->GetName(), argument);
-	SendNoticeMap(buf, ch->GetMapIndex(), false);
-}
-
-ACMD(do_big_notice)
-{
-	BroadcastNotice(argument, true);
-}
-
-ACMD(do_monarch_notice)
-{
-	if (ch->IsMonarch() == TRUE)
-	{
-		BroadcastMonarchNotice(ch->GetEmpire(), argument);
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("군주만이 사용 가능한 기능입니다"));
-	}
-}
-
-ACMD(do_who)
-{
-	int iTotal;
-	int* paiEmpireUserCount;
-	int iLocal;
-
-	DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "Total [%d] %d / %d / %d (this server %d)",
-		iTotal, paiEmpireUserCount[1], paiEmpireUserCount[2], paiEmpireUserCount[3], iLocal);
-}
-
-ACMD(do_online)
-{
-	/// Phase 1 - Count Local Core
-	const DESC_MANAGER::DESC_SET& c_set_desc = DESC_MANAGER::instance().GetClientSet();
-	DESC_MANAGER::DESC_SET::const_iterator it = c_set_desc.begin();
-
-	DWORD dwLoginCount = 0;
-	while (it != c_set_desc.end())
-	{
-		LPDESC d = *(it++);
-		if (d->GetCharacter())
-			++dwLoginCount; // count login count in core
-	}
-	/// Phase 2 - Count Peer PID Connections
-	dwLoginCount = dwLoginCount + (int)P2P_MANAGER::instance().GetPIDCount();
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "Total Online %d ", dwLoginCount);
-}
-
-class user_func
-{
-public:
-	LPCHARACTER m_ch;
-	static int count;
-	static char str[128];
-	static int str_len;
-
-	user_func()
-		: m_ch(NULL)
-	{}
-
-	void initialize(LPCHARACTER ch)
-	{
-		m_ch = ch;
-		str_len = 0;
-		count = 0;
-		str[0] = '\0';
-	}
-
-	void operator () (LPDESC d)
-	{
-		if (!d->GetCharacter())
-			return;
-
-		int len = snprintf(str + str_len, sizeof(str) - str_len, "%-16s ", d->GetCharacter()->GetName());
-
-		if (len < 0 || len >= (int)sizeof(str) - str_len)
-			len = (sizeof(str) - str_len) - 1;
-
-		str_len += len;
-		++count;
-
-		if (!(count % 4))
-		{
-			m_ch->ChatPacket(CHAT_TYPE_INFO, str);
-
-			str[0] = '\0';
-			str_len = 0;
-		}
-	}
-};
-
-int user_func::count = 0;
-char user_func::str[128] = { 0, };
-int user_func::str_len = 0;
-
-ACMD(do_user)
-{
-	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
-	user_func func;
-
-	func.initialize(ch);
-	std::for_each(c_ref_set.begin(), c_ref_set.end(), func);
-
-	if (func.count % 4)
-		ch->ChatPacket(CHAT_TYPE_INFO, func.str);
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "Total %d", func.count);
-}
-
-ACMD(do_disconnect)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "ex) /dc <player name>");
-		return;
-	}
-
-	LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
-	LPCHARACTER tch = d ? d->GetCharacter() : NULL;
-
-	if (!tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s: no such a player.", arg1);
-		return;
-	}
-
-	if (tch == ch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "cannot disconnect myself");
-		return;
-	}
-
-	DESC_MANAGER::instance().DestroyDesc(d);
-}
-
-ACMD(do_kill)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "ex) /kill <player name>");
-		return;
-	}
-
-	LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
-	LPCHARACTER tch = d ? d->GetCharacter() : NULL;
-
-	if (!tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s: no such a player", arg1);
-		return;
-	}
-
-	tch->Dead();
-}
-
-ACMD(do_poison)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "ex) /poison <player name>");
-		return;
-	}
-
-	LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
-	LPCHARACTER tch = d ? d->GetCharacter() : NULL;
-
-	if (!tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s: no such a player", arg1);
-		return;
-	}
-
-	tch->AttackedByPoison(NULL);
-}
-
-ACMD(do_bleeding)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "ex) /bleeding <player name>");
-		return;
-	}
-
-	LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
-	LPCHARACTER tch = d ? d->GetCharacter() : NULL;
-
-	if (!tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s: no such a player", arg1);
-		return;
-	}
-
-	tch->AttackedByBleeding(NULL);
-}
-
-ACMD(do_fire)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "ex) /fire <player name>");
-		return;
-	}
-
-	LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
-	LPCHARACTER tch = d ? d->GetCharacter() : NULL;
-
-	if (!tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s: no such a player", arg1);
-		return;
-	}
-
-	tch->AttackedByFire(NULL, number(1, 5), 5);
-}
-
-#define MISC 0
-#define BINARY 1
-#define NUMBER 2
-
-const struct set_struct
-{
-	const char key;
-	const char* cmd;
-	const char type;
-} set_fields[] = {
-	{ SET_CMD_GOLD, "gold", NUMBER },
-	{ SET_CMD_RACE, "race", BINARY },
-	{ SET_CMD_SEX, "sex", BINARY },
-	{ SET_CMD_EXP, "exp", NUMBER },
-	{ SET_CMD_MAX_HP, "max_hp", NUMBER },
-	{ SET_CMD_MAX_SP, "max_sp", NUMBER },
-	{ SET_CMD_SKILL, "skill", NUMBER },
-	{ SET_CMD_ALIGN, "align", NUMBER },
-#if defined(__CHEQUE_SYSTEM__)
-	{ SET_CMD_CHEQUE, "cheque", NUMBER },
-#endif
-#if defined(__GEM_SYSTEM__)
-	{ SET_CMD_GEM, "gem", NUMBER },
-#endif
-#if defined(__EXPRESSING_EMOTIONS__)
-	{ SET_CMD_ACTION, "action", NUMBER },
-#endif
-	{ SET_CMD_MAX_NUN, "\n", MISC }
-};
-
-ACMD(do_set)
-{
-	char arg1[256], arg2[256], arg3[256];
-
-	LPCHARACTER tch = NULL;
-
-	int i, len;
-	const char* line;
-
-	line = two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-	one_argument(line, arg3, sizeof(arg3));
-
-	if (!*arg1 || !*arg2 || !*arg3)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: set <name> <field> <value>");
-		return;
-	}
-
-	tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-	if (!tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s not exist", arg1);
-		return;
-	}
-
-	len = strlen(arg2);
-
-	for (i = 0; *(set_fields[i].cmd) != '\n'; i++)
-		if (!strncmp(arg2, set_fields[i].cmd, len))
-			break;
-
-	switch (i)
-	{
-		case SET_CMD_GOLD:
-		{
-			POINT_VALUE gold = 0;
-			safe_str_to_number(gold, arg3);
-
-			int before_gold = tch->GetGold();
-			gold = MINMAXLL(0, (long long)before_gold + gold, GOLD_MAX - 1);
-
-			tch->SetPoint(POINT_GOLD, gold);
-			tch->SetGold(gold);
-			tch->UpdatePointsPacket(POINT_GOLD, gold);
-
-			int after_gold = tch->GetGold();
-
-			if (0 == after_gold && 0 != before_gold)
-				LogManager::instance().CharLog(tch, gold, "ZERO_GOLD", "GM");
-
-			if (before_gold != after_gold)
-			{
-				int gold_diff = after_gold - before_gold;
-				if (gold_diff < 0)
-					DBManager::instance().SendMoneyLog(MONEY_LOG_MISC, 3, -gold_diff);
-				else
-					DBManager::instance().SendMoneyLog(MONEY_LOG_MISC, 3, gold_diff);
-			}
-		}
-		break;
-
-		case SET_CMD_RACE:
-		{
-			BYTE race;
-			str_to_number(race, arg3);
-
-			if (race < 0 || race >= MAIN_RACE_MAX_NUM)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_WARRIOR_M = 0");
-				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_ASSASSIN_W = 1");
-				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_SURA_M = 2");
-				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_SHAMAN_W = 3");
-				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_WARRIOR_W = 4");
-				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_ASSASSIN_M = 5");
-				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_SURA_W = 6");
-				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_SHAMAN_M = 7");
-#if defined(__WOLFMAN_CHARACTER__) && !defined(__DISABLE_WOLFMAN_CREATION__)
-				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_WOLFMAN_M = 8");
-#endif
-				return;
-			}
-
-			tch->SetRace(race);
-
-			tch->ClearSkill();
-			tch->ClearSubSkill();
-			tch->SetSkillGroup(0);
-
-			tch->SetPolymorph(101);
-			tch->SetPolymorph(0);
-		}
-		break;
-
-		case SET_CMD_SEX:
-		{
-			BYTE sex = 0;
-			str_to_number(sex, arg3);
-
-			if (sex < SEX_MALE || sex > SEX_FEMALE)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, "SEX_MALE = 0");
-				ch->ChatPacket(CHAT_TYPE_INFO, "SEX_FEMALE = 1");
-				return;
-			}
-
-			BYTE race = 0;
-			switch (tch->GetJob())
-			{
-				case JOB_WARRIOR:
-					race = (sex == SEX_MALE) ? MAIN_RACE_WARRIOR_M : MAIN_RACE_WARRIOR_W;
-					break;
-				case JOB_ASSASSIN:
-					race = (sex == SEX_MALE) ? MAIN_RACE_ASSASSIN_M : MAIN_RACE_ASSASSIN_W;
-					break;
-				case JOB_SURA:
-					race = (sex == SEX_MALE) ? MAIN_RACE_SURA_M : MAIN_RACE_SURA_W;
-					break;
-				case JOB_SHAMAN:
-					race = (sex == SEX_MALE) ? MAIN_RACE_SHAMAN_M : MAIN_RACE_SHAMAN_W;
-					break;
-#if defined(__WOLFMAN_CHARACTER__)
-				case JOB_WOLFMAN:
-					race = (sex == SEX_MALE) ? MAIN_RACE_WOLFMAN_M : MAIN_RACE_WOLFMAN_M;
-					break;
-#endif
-			}
-
-			tch->SetRace(race);
-
-			tch->SetPolymorph(101);
-			tch->SetPolymorph(0);
-		}
-		break;
-
-		case SET_CMD_EXP:
-		{
-			POINT_VALUE amount = 0;
-			safe_str_to_number(amount, arg3);
-
-			amount = MINMAXLL(POINT_MIN, amount, POINT_MAX);
-
-#if defined(__CONQUEROR_LEVEL__)
-			if (tch->GetConquerorLevel() > 0)
-				tch->PointChange(POINT_CONQUEROR_EXP, amount, true);
-			else
-				tch->PointChange(POINT_EXP, amount, true);
-#else
-			tch->PointChange(POINT_EXP, amount, true);
-#endif
-		}
-		break;
-
-		case SET_CMD_MAX_HP:
-		{
-			POINT_VALUE amount = 0;
-			safe_str_to_number(amount, arg3);
-
-			amount = MINMAXLL(POINT_MIN, amount, POINT_MAX);
-
-			tch->PointChange(POINT_MAX_HP, amount, true);
-		}
-		break;
-
-		case SET_CMD_MAX_SP:
-		{
-			POINT_VALUE amount = 0;
-			safe_str_to_number(amount, arg3);
-
-			amount = MINMAXLL(POINT_MIN, amount, POINT_MAX);
-
-			tch->PointChange(POINT_MAX_SP, amount, true);
-		}
-		break;
-
-		case SET_CMD_SKILL: // active skill point
-		{
-			POINT_VALUE amount = 0;
-			safe_str_to_number(amount, arg3);
-
-			amount = MINMAXLL(POINT_MIN, amount, POINT_MAX);
-
-			tch->PointChange(POINT_SKILL, amount, true);
-		}
-		break;
-
-		case SET_CMD_ALIGN:
-		{
-			int amount = 0;
-			safe_str_to_number(amount, arg3);
-
-			amount = MINMAXLL(INT_MIN, amount, INT_MAX);
-
-			tch->UpdateAlignment(amount - tch->GetRealAlignment());
-		}
-		break;
-
-#if defined(__CHEQUE_SYSTEM__)
-		case SET_CMD_CHEQUE:
-		{
-			POINT_VALUE cheque = 0;
-			safe_str_to_number(cheque, arg3);
-
-			int before_cheque = tch->GetCheque();
-			cheque = MINMAXLL(0, (long long)before_cheque + cheque, CHEQUE_MAX);
-
-			tch->SetPoint(POINT_CHEQUE, cheque);
-			tch->SetCheque(cheque);
-			tch->UpdatePointsPacket(POINT_CHEQUE, cheque);
-
-			int after_cheque = tch->GetCheque();
-			if (0 == after_cheque && 0 != before_cheque)
-				LogManager::instance().CharLog(tch, cheque, "ZERO_CHEQUE", "GM");
-
-			if (before_cheque != after_cheque)
-			{
-				int cheque_diff = after_cheque - before_cheque;
-				if (cheque_diff < 0)
-					DBManager::instance().SendMoneyLog(MONEY_LOG_MISC, 3, 0, -cheque_diff);
-				else
-					DBManager::instance().SendMoneyLog(MONEY_LOG_MISC, 3, 0, cheque_diff);
-			}
-		}
-		break;
-#endif
-
-#if defined(__GEM_SYSTEM__)
-		case SET_CMD_GEM:
-		{
-			POINT_VALUE gem = 0;
-			safe_str_to_number(gem, arg3);
-
-			int before_gem = tch->GetGem();
-			gem = MINMAXLL(0, (long long)before_gem + gem, GEM_MAX);
-
-			tch->SetPoint(POINT_GEM, gem);
-			tch->SetGem(gem);
-			tch->UpdatePointsPacket(POINT_GEM, gem);
-
-			int after_gem = tch->GetGem();
-			if (0 == after_gem && 0 != before_gem)
-				LogManager::instance().CharLog(tch, gem, "ZERO_GEM", "GM");
-		}
-		break;
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-		case SET_CMD_ACTION:
-		{
-			int emote_idx = 0;
-			safe_str_to_number(emote_idx, arg3);
-
-			emote_idx = MINMAXLL(0, emote_idx, INT_MAX);
-
-			tch->AddEmote(emote_idx);
-		}
-		break;
-#endif
-	}
-
-	if (set_fields[i].type == NUMBER)
-	{
-		long long amount = 0;
-		safe_str_to_number(amount, arg3);
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s's %s set to [%lld]", tch->GetName(), set_fields[i].cmd, amount);
-	}
-}
-
-ACMD(do_reset)
-{
-	ch->PointChange(POINT_HP, ch->GetMaxHP() - ch->GetHP());
-	ch->PointChange(POINT_SP, ch->GetMaxSP() - ch->GetSP());
-	ch->Save();
-}
-
-ACMD(do_advance)
-{
-	char arg1[256], arg2[256];
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1 || !*arg2)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: advance <name> <level>");
-		return;
-	}
-
-	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-
-	if (!tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s not exist", arg1);
-		return;
-	}
-
-	int level = 0;
-	str_to_number(level, arg2);
-
-	tch->ResetPoint(MINMAX(1, level, PLAYER_MAX_LEVEL_CONST));
-	tch->ResetExp();
-}
-
-ACMD(do_respawn)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (*arg1 && !strcasecmp(arg1, "all"))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Respaw everywhere");
-		regen_reset(0, 0);
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Respaw around");
-		regen_reset(ch->GetX(), ch->GetY());
-	}
-}
-
-ACMD(do_safebox_size)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	int size = 0;
-
-	if (*arg1)
-		str_to_number(size, arg1);
-
-	if (size > 3 || size < 0)
-		size = 0;
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "Safebox size set to %d", size);
-	ch->ChangeSafeboxSize(size);
-}
-
-ACMD(do_makeguild)
-{
-	if (ch->GetGuild())
-		return;
-
-	CGuildManager& gm = CGuildManager::instance();
-
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	TGuildCreateParameter cp;
-	memset(&cp, 0, sizeof(cp));
-
-	cp.master = ch;
-	strlcpy(cp.name, arg1, sizeof(cp.name));
-
-	if (!check_name(cp.name))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("적합하지 않은 길드 이름 입니다."));
-		return;
-	}
-
-	gm.CreateGuild(cp);
-	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("(%s) 길드가 생성되었습니다. [임시]", cp.name));
-}
-
-ACMD(do_deleteguild)
-{
-	if (ch->GetGuild())
-		ch->GetGuild()->RequestDisband(ch->GetPlayerID());
-}
-
-ACMD(do_greset)
-{
-	if (ch->GetGuild())
-		ch->GetGuild()->Reset();
-}
-
-// REFINE_ROD_HACK_BUG_FIX
-ACMD(do_refine_rod)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	BYTE cell = 0;
-	str_to_number(cell, arg1);
-	LPITEM item = ch->GetInventoryItem(cell);
-	if (item)
-		fishing::RealRefineRod(ch, item);
-}
-// END_OF_REFINE_ROD_HACK_BUG_FIX
-
-// REFINE_PICK
-ACMD(do_refine_pick)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	BYTE cell = 0;
-	str_to_number(cell, arg1);
-	LPITEM item = ch->GetInventoryItem(cell);
-	if (item)
-	{
-		mining::CHEAT_MAX_PICK(ch, item);
-		mining::RealRefinePick(ch, item);
-	}
-}
-
-ACMD(do_max_pick)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	BYTE cell = 0;
-	str_to_number(cell, arg1);
-	LPITEM item = ch->GetInventoryItem(cell);
-	if (item)
-	{
-		mining::CHEAT_MAX_PICK(ch, item);
-	}
-}
-// END_OF_REFINE_PICK
-
-ACMD(do_fishing_simul)
-{
-	char arg1[256];
-	char arg2[256];
-	char arg3[256];
-	argument = one_argument(argument, arg1, sizeof(arg1));
-	two_arguments(argument, arg2, sizeof(arg2), arg3, sizeof(arg3));
-
-	int count = 1000;
-	int prob_idx = 0;
-	int level = 100;
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "Usage: fishing_simul <level> <prob index> <count>");
-
-	if (*arg1)
-		str_to_number(level, arg1);
-
-	if (*arg2)
-		str_to_number(prob_idx, arg2);
-
-	if (*arg3)
-		str_to_number(count, arg3);
-
-	fishing::Simulation(level, count, prob_idx, ch);
-}
-
-ACMD(do_invisibility)
-{
-	if (ch->IsAffectFlag(AFF_INVISIBILITY))
-	{
-		ch->RemoveAffect(AFFECT_INVISIBILITY);
-		ch->EffectPacket(30);
-	}
-	else
-	{
-		ch->AddAffect(AFFECT_INVISIBILITY, POINT_NONE, 0, AFF_INVISIBILITY, INFINITE_AFFECT_DURATION, 0, true);
-	}
-}
-
-ACMD(do_event_flag)
-{
-	char arg1[256];
-	char arg2[256];
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!(*arg1) || !(*arg2))
-		return;
-
-	int value = 0;
-	str_to_number(value, arg2);
-
-	if (!strcmp(arg1, "mob_item") ||
-		!strcmp(arg1, "mob_exp") ||
-		!strcmp(arg1, "mob_gold") ||
-		!strcmp(arg1, "mob_dam") ||
-		!strcmp(arg1, "mob_gold_pct") ||
-		!strcmp(arg1, "mob_item_buyer") ||
-		!strcmp(arg1, "mob_exp_buyer") ||
-		!strcmp(arg1, "mob_gold_buyer") ||
-		!strcmp(arg1, "mob_gold_pct_buyer")
-		)
-		value = MINMAX(0, value, 1000);
-
-	//quest::CQuestManager::instance().SetEventFlag(arg1, atoi(arg2));
-	quest::CQuestManager::instance().RequestSetEventFlag(arg1, value);
-	ch->ChatPacket(CHAT_TYPE_INFO, "RequestSetEventFlag %s %d", arg1, value);
-	sys_log(0, "RequestSetEventFlag %s %d", arg1, value);
-}
-
-ACMD(do_get_event_flag)
-{
-	quest::CQuestManager::instance().SendEventFlagList(ch);
-}
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-ACMD(do_guild_event_flag)
-{
-	char arg1[256];
-	char arg2[256];
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!(*arg1) || !(*arg2))
-		return;
-
-	int value = 0;
-	str_to_number(value, arg2);
-
-	LPGUILD g = ch->GetGuild();
-	if (g == nullptr)
-		return;
-
-	CGuildManager::Instance().RequestSetEventFlag(g->GetID(), arg1, value);
-}
-
-ACMD(do_get_guild_event_flag)
-{
-	CGuildManager::Instance().SendGuildEventFlagList(ch);
-}
-#endif
-
-ACMD(do_private)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: private <map index>");
-		return;
-	}
-
-	long lMapIndex;
-	long map_index = 0;
-	str_to_number(map_index, arg1);
-	if ((lMapIndex = SECTREE_MANAGER::instance().CreatePrivateMap(map_index)))
-	{
-		ch->SaveExitLocation();
-
-		LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(lMapIndex);
-		ch->WarpSet(pkSectreeMap->m_setting.posSpawn.x, pkSectreeMap->m_setting.posSpawn.y, lMapIndex);
-	}
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, "Can't find map by index %d", map_index);
-}
-
-ACMD(do_qf)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-		return;
-
-	quest::PC* pPC = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
-	std::string questname = pPC->GetCurrentQuestName();
-
-	if (!questname.empty())
-	{
-		int value = quest::CQuestManager::Instance().GetQuestStateIndex(questname, arg1);
-
-		pPC->SetFlag(questname + ".__status", value);
-		pPC->ClearTimer();
-
-		quest::PC::QuestInfoIterator it = pPC->quest_begin();
-		unsigned int questindex = quest::CQuestManager::instance().GetQuestIndexByName(questname);
-
-		while (it != pPC->quest_end())
-		{
-			if (it->first == questindex)
-			{
-				it->second.st = value;
-				break;
-			}
-
-			++it;
-		}
-
-		ch->ChatPacket(CHAT_TYPE_INFO, "setting quest state flag %s %s %d", questname.c_str(), arg1, value);
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "setting quest state flag failed");
-	}
-}
-
-LPCHARACTER chHori, chForge, chLib, chTemple, chTraining, chTree, chPortal, chBall;
-
-ACMD(do_b1)
-{
-	// 호리병 478 579
-	chHori = CHARACTER_MANAGER::instance().SpawnMobRange(14017, ch->GetMapIndex(), 304222, 742858, 304222, 742858, true, false);
-	chHori->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_BUILDING_CONSTRUCTION_SMALL, 65535, 0, true);
-	chHori->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-
-	for (int i = 0; i < 30; ++i)
-	{
-		int rot = number(0, 359);
-		float fx, fy;
-		GetDeltaByDegree(rot, 800, &fx, &fy);
-
-		LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRange(number(701, 706),
-			ch->GetMapIndex(),
-			304222 + (int)fx,
-			742858 + (int)fy,
-			304222 + (int)fx,
-			742858 + (int)fy,
-			true,
-			false);
-		tch->SetAggressive();
-	}
-
-	for (int i = 0; i < 5; ++i)
-	{
-		int rot = number(0, 359);
-		float fx, fy;
-		GetDeltaByDegree(rot, 800, &fx, &fy);
-
-		LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRange(8009,
-			ch->GetMapIndex(),
-			304222 + (int)fx,
-			742858 + (int)fy,
-			304222 + (int)fx,
-			742858 + (int)fy,
-			true,
-			false);
-		tch->SetAggressive();
-	}
-}
-
-ACMD(do_b2)
-{
-	chHori->RemoveAffect(AFFECT_DUNGEON_UNIQUE);
-}
-
-ACMD(do_b3)
-{
-	// 포지 492 547
-	chForge = CHARACTER_MANAGER::instance().SpawnMobRange(14003, ch->GetMapIndex(), 307500, 746300, 307500, 746300, true, false);
-	chForge->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-	// 높은탑 509 589 -> 도서관
-	chLib = CHARACTER_MANAGER::instance().SpawnMobRange(14007, ch->GetMapIndex(), 307900, 744500, 307900, 744500, true, false);
-	chLib->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-	// 욕조 513 606 -> 힘의신전
-	chTemple = CHARACTER_MANAGER::instance().SpawnMobRange(14004, ch->GetMapIndex(), 307700, 741600, 307700, 741600, true, false);
-	chTemple->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-	// 권투장 490 625
-	chTraining = CHARACTER_MANAGER::instance().SpawnMobRange(14010, ch->GetMapIndex(), 307100, 739500, 307100, 739500, true, false);
-	chTraining->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-	// 나무 466 614
-	chTree = CHARACTER_MANAGER::instance().SpawnMobRange(14013, ch->GetMapIndex(), 300800, 741600, 300800, 741600, true, false);
-	chTree->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-	// 포탈 439 615
-	chPortal = CHARACTER_MANAGER::instance().SpawnMobRange(14001, ch->GetMapIndex(), 300900, 744500, 300900, 744500, true, false);
-	chPortal->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-	// 구슬 436 600
-	chBall = CHARACTER_MANAGER::instance().SpawnMobRange(14012, ch->GetMapIndex(), 302500, 746600, 302500, 746600, true, false);
-	chBall->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-}
-
-ACMD(do_b4)
-{
-	chLib->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_BUILDING_UPGRADE, 65535, 0, true);
-
-	for (int i = 0; i < 30; ++i)
-	{
-		int rot = number(0, 359);
-		float fx, fy;
-		GetDeltaByDegree(rot, 1200, &fx, &fy);
-
-		LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRange(number(701, 706),
-			ch->GetMapIndex(),
-			307900 + (int)fx,
-			744500 + (int)fy,
-			307900 + (int)fx,
-			744500 + (int)fy,
-			true,
-			false);
-		tch->SetAggressive();
-	}
-
-	for (int i = 0; i < 5; ++i)
-	{
-		int rot = number(0, 359);
-		float fx, fy;
-		GetDeltaByDegree(rot, 1200, &fx, &fy);
-
-		LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRange(8009,
-			ch->GetMapIndex(),
-			307900 + (int)fx,
-			744500 + (int)fy,
-			307900 + (int)fx,
-			744500 + (int)fy,
-			true,
-			false);
-		tch->SetAggressive();
-	}
-
-}
-
-ACMD(do_b5)
-{
-	M2_DESTROY_CHARACTER(chLib);
-	//chHori->RemoveAffect(AFFECT_DUNGEON_UNIQUE);
-	chLib = CHARACTER_MANAGER::instance().SpawnMobRange(14008, ch->GetMapIndex(), 307900, 744500, 307900, 744500, true, false);
-	chLib->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-}
-
-ACMD(do_b6)
-{
-	chLib->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_BUILDING_UPGRADE, 65535, 0, true);
-}
-ACMD(do_b7)
-{
-	M2_DESTROY_CHARACTER(chLib);
-	//chHori->RemoveAffect(AFFECT_DUNGEON_UNIQUE);
-	chLib = CHARACTER_MANAGER::instance().SpawnMobRange(14009, ch->GetMapIndex(), 307900, 744500, 307900, 744500, true, false);
-	chLib->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-}
-
-ACMD(do_book)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	CSkillProto* pkProto;
-
-	if (isnhdigit(*arg1))
-	{
-		DWORD vnum = 0;
-		str_to_number(vnum, arg1);
-		pkProto = CSkillManager::instance().Get(vnum);
-	}
-	else
-		pkProto = CSkillManager::instance().Get(arg1);
-
-	if (!pkProto)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "There is no such a skill.");
-		return;
-	}
-
-	LPITEM item = ch->AutoGiveItem(ITEM_SKILLBOOK_VNUM, 1, false, false);
-	item->SetSocket(0, pkProto->dwVnum);
-}
-
-ACMD(do_setskillother)
-{
-	char arg1[256], arg2[256], arg3[256];
-	argument = two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-	one_argument(argument, arg3, sizeof(arg3));
-
-	if (!*arg1 || !*arg2 || !*arg3 || !isdigit(*arg3))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: setskillother <target> <skillname> <lev>");
-		return;
-	}
-
-	LPCHARACTER tch;
-
-	tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-
-	if (!tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "There is no such character.");
-		return;
-	}
-
-	CSkillProto* pk;
-
-	if (isdigit(*arg2))
-	{
-		DWORD vnum = 0;
-		str_to_number(vnum, arg2);
-		pk = CSkillManager::instance().Get(vnum);
-	}
-	else
-		pk = CSkillManager::instance().Get(arg2);
-
-	if (!pk)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "No such a skill by that name.");
-		return;
-	}
-
-	BYTE level = 0;
-	str_to_number(level, arg3);
-	tch->SetSkillLevel(pk->dwVnum, level);
-	tch->ComputePoints();
-	tch->SkillLevelPacket();
-}
-
-ACMD(do_setskill)
-{
-	char arg1[256], arg2[256];
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1 || !*arg2 || !isdigit(*arg2))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: setskill <name> <lev>");
-		return;
-	}
-
-	CSkillProto* pk;
-
-	if (isdigit(*arg1))
-	{
-		DWORD vnum = 0;
-		str_to_number(vnum, arg1);
-		pk = CSkillManager::instance().Get(vnum);
-	}
-
-	else
-		pk = CSkillManager::instance().Get(arg1);
-
-	if (!pk)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "No such a skill by that name.");
-		return;
-	}
-
-	BYTE level = 0;
-	str_to_number(level, arg2);
-	ch->SetSkillLevel(pk->dwVnum, level);
-	ch->ComputePoints();
-	ch->SkillLevelPacket();
-}
-
-ACMD(do_set_skill_point)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	int skill_point = 0;
-	if (*arg1)
-		str_to_number(skill_point, arg1);
-
-	ch->SetRealPoint(POINT_SKILL, skill_point);
-	ch->SetPoint(POINT_SKILL, ch->GetRealPoint(POINT_SKILL));
-	ch->PointChange(POINT_SKILL, 0);
-}
-
-ACMD(do_set_skill_group)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	int skill_group = 0;
-	if (*arg1)
-		str_to_number(skill_group, arg1);
-
-	ch->SetSkillGroup(skill_group);
-
-	ch->ClearSkill();
-	ch->ChatPacket(CHAT_TYPE_INFO, "skill group to %d.", skill_group);
-}
-
-ACMD(do_reload)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-	const int FILE_NAME_LEN = 256;
-
-	if (*arg1)
-	{
-#if defined(__EXTENDED_RELOAD__)
-		struct s_cmd_data { std::string file_name, base_path; };
-		std::unordered_map<std::string, s_cmd_data> cmd_map = {
-			{ "mob_drop_item", { "mob_drop_item.txt", LocaleService_GetBasePath() } },
-			{ "special_item_group", { "special_item_group.txt", LocaleService_GetBasePath() } },
-			{ "group", { "group.txt", LocaleService_GetBasePath() } },
-			{ "group_group", { "group_group.txt", LocaleService_GetBasePath() } },
-#if defined(__SHOPEX_RENEWAL__)
-			{ "shop_table_ex", { "shop_table_ex.txt", LocaleService_GetBasePath() } },
-#endif
-#if defined(__SET_ITEM__)
-			{ "set_item_table", { "set_item_table.txt", LocaleService_GetBasePath() } },
-#endif
-#if defined(__GEM_SHOP__)
-			{ "new_world", { "new_world.txt", LocaleService_GetMapPath() } },
-#endif
-			{ "pet_block_index", { "pet_block_index.txt", LocaleService_GetMapPath() } },
-			{ "mount_block_index", { "mount_block_index.txt", LocaleService_GetMapPath() } },
-#if defined(__SUMMER_EVENT_ROULETTE__)
-			{ "roulette_table", { "roulette_table.txt", LocaleService_GetMapPath() } },
-#endif
-		};
-
-		if (cmd_map.find(arg1) != cmd_map.end())
-		{
-			char szFileName[FILE_NAME_LEN];
-			snprintf(szFileName, sizeof(szFileName), "%s/%s",
-				cmd_map[arg1].base_path.c_str(), cmd_map[arg1].file_name.c_str());
-
-			if (strcasecmp(arg1, "mob_drop_item") == 0)
-			{
-				if (ITEM_MANAGER::instance().ReloadMobDropItemGroup(szFileName))
-					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
-				return;
-			}
-
-			if (strcasecmp(arg1, "special_item_group") == 0)
-			{
-				if (ITEM_MANAGER::instance().ReloadSpecialItemGroup(szFileName))
-					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
-				return;
-			}
-
-			if (strcasecmp(arg1, "group") == 0)
-			{
-				if (CMobManager::Instance().LoadGroup(szFileName, true))
-					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
-				return;
-			}
-
-			if (strcasecmp(arg1, "group_group") == 0)
-			{
-				if (CMobManager::Instance().LoadGroupGroup(szFileName))
-					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
-				return;
-			}
-
-#if defined(__SHOPEX_RENEWAL__)
-			if (strcasecmp(arg1, "shop_table_ex") == 0)
-			{
-				if (CShopManager::instance().ReadShopTableEx(szFileName))
-					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
-				return;
-			}
-#endif
-
-#if defined(__SET_ITEM__)
-			if (strcasecmp(arg1, "set_item_table") == 0)
-			{
-				if (ITEM_MANAGER::instance().LoadSetItemTable(szFileName))
-					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
-				return;
-			}
-#endif
-
-#if defined(__GEM_SHOP__)
-			if (strcasecmp(arg1, "gem_shop_table") == 0)
-			{
-				if (ITEM_MANAGER::instance().ReadGemShopItemGroup(szFileName))
-					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
-				return;
-			}
-#endif
-
-#if defined(__CONQUEROR_LEVEL__)
-			if (strcasecmp(arg1, "new_world") == 0)
-			{
-				if (SECTREE_MANAGER::Instance().LoadNewWorldMapIndexFile(szFileName))
-					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
-				return;
-			}
-#endif
-
-			if (strcasecmp(arg1, "pet_block_index") == 0)
-			{
-				if (SECTREE_MANAGER::instance().LoadBlockFilterMapIndexFile(SECTREE_MANAGER::PET_BLOCK_MAP_INDEX))
-					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
-				return;
-			}
-
-			if (strcasecmp(arg1, "mount_block_index") == 0)
-			{
-				if (SECTREE_MANAGER::instance().LoadBlockFilterMapIndexFile(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX))
-					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
-				return;
-			}
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-			if (strcasecmp(arg1, "roulette_table") == 0)
-			{
-				if (CRouletteManager::Instance().ReadRouletteTableFile(szFileName))
-					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
-				return;
-			}
-#endif
-		}
-#endif
-
-		switch (LOWER(*arg1))
-		{
-			case 'u':
-				ch->ChatPacket(CHAT_TYPE_INFO, "Reloading state_user_count.");
-				LoadStateUserCount();
-				break;
-
-			case 'p':
-				ch->ChatPacket(CHAT_TYPE_INFO, "Reloading prototype tables,");
-				db_clientdesc->DBPacket(HEADER_GD_RELOAD_PROTO, 0, NULL, 0);
-				break;
-
-			case 's':
-				ch->ChatPacket(CHAT_TYPE_INFO, "Reloading notice string.");
-				DBManager::instance().LoadDBString();
-				break;
-
-			case 'q':
-				ch->ChatPacket(CHAT_TYPE_INFO, "Reloading quest.");
-				quest::CQuestManager::instance().Reload();
-				break;
-
-			case 'f':
-				fishing::Initialize();
-				break;
-
-				// RELOAD_ADMIN
-			case 'a':
-				ch->ChatPacket(CHAT_TYPE_INFO, "Reloading Admin infomation.");
-				db_clientdesc->DBPacket(HEADER_GD_RELOAD_ADMIN, 0, NULL, 0);
-				sys_log(0, "Reloading admin infomation.");
-				break;
-				// END_RELOAD_ADMIN
-
-			case 'c': // Cube
-			{
-				// 로컬 프로세스만 갱산한다.
-#if defined(__CUBE_RENEWAL__)
-				CCubeManager::Instance().Initialize();
-#else
-				Cube_init();
-#endif
-			}
-			break;
-		}
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Reloading state_user_count.");
-		LoadStateUserCount();
-
-		ch->ChatPacket(CHAT_TYPE_INFO, "Reloading prototype tables,");
-		db_clientdesc->DBPacket(HEADER_GD_RELOAD_PROTO, 0, NULL, 0);
-
-		ch->ChatPacket(CHAT_TYPE_INFO, "Reloading notice string.");
-		DBManager::instance().LoadDBString();
-	}
-}
-
-ACMD(do_cooltime)
-{
-	ch->DisableCooltime();
-}
-
-ACMD(do_level)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: level <level>");
-		return;
-	}
-
-	int level = 0;
-	str_to_number(level, arg1);
-
-	ch->ResetPoint(MINMAX(1, level, PLAYER_MAX_LEVEL_CONST));
-	ch->ResetExp();
-
-	ch->ClearSkill();
-	ch->ClearSubSkill();
-}
-
-ACMD(do_gwlist)
-{
-	ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("현재 전쟁중인 길드 입니다"));
-	CGuildManager::instance().ShowGuildWarList(ch);
-}
-
-ACMD(do_stop_guild_war)
-{
-	char arg1[256], arg2[256];
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1 || !*arg2)
-		return;
-
-	int id1 = 0, id2 = 0;
-
-	str_to_number(id1, arg1);
-	str_to_number(id2, arg2);
-
-	if (!id1 || !id2)
-		return;
-
-	if (id1 > id2)
-	{
-		std::swap(id1, id2);
-	}
-
-	ch->ChatPacket(CHAT_TYPE_TALKING, "%d %d", id1, id2);
-	CGuildManager::instance().RequestEndWar(id1, id2);
-}
-
-ACMD(do_cancel_guild_war)
-{
-	char arg1[256], arg2[256];
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	int id1 = 0, id2 = 0;
-	str_to_number(id1, arg1);
-	str_to_number(id2, arg2);
-
-	if (id1 > id2)
-		std::swap(id1, id2);
-
-	CGuildManager::instance().RequestCancelWar(id1, id2);
-}
-
-ACMD(do_guild_state)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	CGuild* pGuild = CGuildManager::instance().FindGuildByName(arg1);
-	if (pGuild != NULL)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "GuildID: %d", pGuild->GetID());
-		ch->ChatPacket(CHAT_TYPE_INFO, "GuildMasterPID: %d", pGuild->GetMasterPID());
-		ch->ChatPacket(CHAT_TYPE_INFO, "IsInWar: %d", pGuild->UnderAnyWar());
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s: 존재하지 않는 길드 입니다.", arg1));
-	}
-}
-
-struct FuncWeaken
-{
-	LPCHARACTER m_pkGM;
-	bool m_bAll;
-
-	FuncWeaken(LPCHARACTER ch) : m_pkGM(ch), m_bAll(false)
-	{
-	}
-
-	void operator () (LPENTITY ent)
-	{
-		if (!ent->IsType(ENTITY_CHARACTER))
-			return;
-
-		LPCHARACTER pkChr = (LPCHARACTER)ent;
-
-		int iDist = DISTANCE_APPROX(pkChr->GetX() - m_pkGM->GetX(), pkChr->GetY() - m_pkGM->GetY());
-
-		if (!m_bAll && iDist >= 1000) // 10미터 이상에 있는 것들은 purge 하지 않는다.
-			return;
-
-#if defined(__DEFENSE_WAVE__)
-		if (pkChr->GetDefenseWave() && (pkChr->GetDefenseWave()->IsUnique(pkChr) && pkChr->IsMonster() == false))
-			return;
-#endif
-
-		if (pkChr->IsNPC())
-			pkChr->PointChange(POINT_HP, (10 - pkChr->GetHP()));
-	}
-};
-
-ACMD(do_weaken)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	FuncWeaken func(ch);
-
-	if (*arg1 && !strcmp(arg1, "all"))
-		func.m_bAll = true;
-
-	if (ch->GetSectree())
-		ch->GetSectree()->ForEachAround(func);
-}
-
-ACMD(do_getqf)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	LPCHARACTER tch;
-
-	if (!*arg1)
-		tch = ch;
-	else
-	{
-		tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-
-		if (!tch)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "There is no such character.");
-			return;
-		}
-	}
-
-	quest::PC* pPC = quest::CQuestManager::instance().GetPC(tch->GetPlayerID());
-
-	if (pPC)
-		pPC->SendFlagList(ch);
-}
-
-ACMD(do_set_state)
-{
-	char arg1[256];
-	char arg2[256];
-
-	//argument = one_argument(argument, arg1, sizeof(arg1));
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1 || !*arg2)
-		return;
-
-	quest::PC* pPC = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
-	std::string questname = arg1;
-	std::string statename = arg2;
-
-	if (!questname.empty())
-	{
-		int value = quest::CQuestManager::Instance().GetQuestStateIndex(questname, statename);
-
-		pPC->SetFlag(questname + ".__status", value);
-		pPC->ClearTimer();
-
-		quest::PC::QuestInfoIterator it = pPC->quest_begin();
-		unsigned int questindex = quest::CQuestManager::instance().GetQuestIndexByName(questname);
-
-		while (it != pPC->quest_end())
-		{
-			if (it->first == questindex)
-			{
-				it->second.st = value;
-				break;
-			}
-
-			++it;
-		}
-
-		ch->ChatPacket(CHAT_TYPE_INFO, "setting quest state flag %s %s %d", questname.c_str(), arg1, value);
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "setting quest state flag failed");
-	}
-}
-
-ACMD(do_setqf)
-{
-	char arg1[256];
-	char arg2[256];
-	char arg3[256];
-
-	one_argument(two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2)), arg3, sizeof(arg3));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: setqf <flagname> <value> [<character name>]");
-		return;
-	}
-
-	LPCHARACTER tch = ch;
-
-	if (*arg3)
-		tch = CHARACTER_MANAGER::instance().FindPC(arg3);
-
-	if (!tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "There is no such character.");
-		return;
-	}
-
-	quest::PC* pPC = quest::CQuestManager::instance().GetPC(tch->GetPlayerID());
-
-	if (pPC)
-	{
-		int value = 0;
-		str_to_number(value, arg2);
-		pPC->SetFlag(arg1, value);
-		ch->ChatPacket(CHAT_TYPE_INFO, "Quest flag set: %s %d", arg1, value);
-	}
-}
-
-ACMD(do_delqf)
-{
-	char arg1[256];
-	char arg2[256];
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: delqf <flagname> [<character name>]");
-		return;
-	}
-
-	LPCHARACTER tch = ch;
-
-	if (*arg2)
-		tch = CHARACTER_MANAGER::instance().FindPC(arg2);
-
-	if (!tch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "There is no such character.");
-		return;
-	}
-
-	quest::PC* pPC = quest::CQuestManager::instance().GetPC(tch->GetPlayerID());
-
-	if (pPC)
-	{
-		if (pPC->DeleteFlag(arg1))
-			ch->ChatPacket(CHAT_TYPE_INFO, "Delete success.");
-		else
-			ch->ChatPacket(CHAT_TYPE_INFO, "Delete failed. Quest flag does not exist.");
-	}
-}
-
-ACMD(do_forgetme)
-{
-	ch->ForgetMyAttacker();
-}
-
-ACMD(do_aggregate)
-{
-	ch->AggregateMonster();
-}
-
-ACMD(do_attract_ranger)
-{
-	ch->AttractRanger();
-}
-
-ACMD(do_pull_monster)
-{
-	ch->PullMonster();
-}
-
-ACMD(do_polymorph)
-{
-	char arg1[256], arg2[256];
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-	if (*arg1)
-	{
-		DWORD dwVnum = 0;
-		str_to_number(dwVnum, arg1);
-		bool bMaintainStat = false;
-		if (*arg2)
-		{
-			int value = 0;
-			str_to_number(value, arg2);
-			bMaintainStat = (value > 0);
-		}
-
-		ch->SetPolymorph(dwVnum, bMaintainStat);
-	}
-}
-
-ACMD(do_polymorph_item)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (*arg1)
-	{
-		DWORD dwVnum = 0;
-		str_to_number(dwVnum, arg1);
-
-		LPITEM item = ITEM_MANAGER::instance().CreateItem(70104, 1, 0, true);
-		if (item)
-		{
-			item->SetSocket(0, dwVnum);
-			int iEmptyPos = ch->GetEmptyInventory(item->GetSize());
-
-			if (iEmptyPos != -1)
-			{
-				item->AddToCharacter(ch, TItemPos(INVENTORY, iEmptyPos));
-				LogManager::instance().ItemLog(ch, item, "GM", item->GetName());
-			}
-			else
-			{
-				M2_DESTROY_ITEM(item);
-				ch->ChatPacket(CHAT_TYPE_INFO, "Not enough inventory space.");
-			}
-		}
-		else
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "#%d item not exist by that vnum.", 70103);
-		}
-		//ch->SetPolymorph(dwVnum, bMaintainStat);
-	}
-}
-
-ACMD(do_priv_empire)
-{
-	char arg1[256] = { 0 };
-	char arg2[256] = { 0 };
-	char arg3[256] = { 0 };
-	char arg4[256] = { 0 };
-	int empire = 0;
-	int type = 0;
-	int value = 0;
-	int duration = 0;
-
-	const char* line = two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1 || !*arg2)
-		goto USAGE;
-
-	if (!line)
-		goto USAGE;
-
-	two_arguments(line, arg3, sizeof(arg3), arg4, sizeof(arg4));
-
-	if (!*arg3 || !*arg4)
-		goto USAGE;
-
-	str_to_number(empire, arg1);
-	str_to_number(type, arg2);
-	str_to_number(value, arg3);
-	value = MINMAX(0, value, 1000);
-	str_to_number(duration, arg4);
-
-	if (empire < 0 || 3 < empire)
-		goto USAGE;
-
-	if (type < 1 || 4 < type)
-		goto USAGE;
-
-	if (value < 0)
-		goto USAGE;
-
-	if (duration < 0)
-		goto USAGE;
-
-	// 시간 단위로 변경
-	duration = duration * (60 * 60);
-
-	sys_log(0, "_give_empire_privileage(empire=%d, type=%d, value=%d, duration=%d) by command",
-		empire, type, value, duration);
-	CPrivManager::instance().RequestGiveEmpirePriv(empire, type, value, duration);
-	return;
-
-USAGE:
-	ch->ChatPacket(CHAT_TYPE_INFO, "usage : priv_empire <empire> <type> <value> <duration>");
-	ch->ChatPacket(CHAT_TYPE_INFO, "  <empire>    0 - 3 (0==all)");
-	ch->ChatPacket(CHAT_TYPE_INFO, "  <type>      1:item_drop, 2:gold_drop, 3:gold10_drop, 4:exp");
-	ch->ChatPacket(CHAT_TYPE_INFO, "  <value>     percent");
-	ch->ChatPacket(CHAT_TYPE_INFO, "  <duration>  hour");
-}
-
-/**
-* @version 05/06/08 Bang2ni - 길드 보너스 퀘스트 진행 안되는 문제 수정.(스크립트가 작성안됨.)
-* quest/priv_guild.quest 로 부터 스크립트 읽어오게 수정됨
-**/
-ACMD(do_priv_guild)
-{
-	static const char msg[] = { '\0' };
-
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (*arg1)
-	{
-		CGuild* g = CGuildManager::instance().FindGuildByName(arg1);
-
-		if (!g)
-		{
-			DWORD guild_id = 0;
-			str_to_number(guild_id, arg1);
-			g = CGuildManager::instance().FindGuild(guild_id);
-		}
-
-		if (!g)
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("그런 이름 또는 번호의 길드가 없습니다."));
-		else
-		{
-			char buf[1024 + 1];
-			snprintf(buf, sizeof(buf), msg, g->GetID());
-
-			using namespace quest;
-			PC* pc = CQuestManager::instance().GetPC(ch->GetPlayerID());
-			QuestState qs = CQuestManager::instance().OpenState("ADMIN_QUEST", QUEST_FISH_REFINE_STATE_INDEX);
-			luaL_loadbuffer(qs.co, buf, strlen(buf), "ADMIN_QUEST");
-			pc->SetQuest("ADMIN_QUEST", qs);
-
-			QuestState& rqs = *pc->GetRunningQuestState();
-
-			if (!CQuestManager::instance().RunState(rqs))
-			{
-				CQuestManager::instance().CloseState(rqs);
-				pc->EndRunning();
-				return;
-			}
-		}
-	}
-}
-
-ACMD(do_mount_test)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (*arg1)
-	{
-		DWORD vnum = 0;
-		str_to_number(vnum, arg1);
-		ch->MountVnum(vnum);
-	}
-}
-
-ACMD(do_observer)
-{
-	ch->SetObserverMode(!ch->IsObserverMode());
-}
-
-ACMD(do_socket_item)
-{
-	char arg1[256], arg2[256], arg3[256];
-	three_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2), arg3, sizeof(arg3));
-
-	if (*arg1)
-	{
-		DWORD dwVnum = 0;
-		str_to_number(dwVnum, arg1);
-
-		int iSocketIndex = 0;
-		str_to_number(iSocketIndex, arg2);
-
-		int iSocketValue = 0;
-		str_to_number(iSocketValue, arg3);
-
-		if (iSocketIndex >= ITEM_SOCKET_MAX_NUM)
-			iSocketIndex = ITEM_SOCKET_MAX_NUM - 1;
-
-		if (!dwVnum)
-		{
-			if (!ITEM_MANAGER::instance().GetVnum(arg1, dwVnum))
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, "#%d item not exist by that vnum.", dwVnum);
-				return;
-			}
-		}
-
-		if (LPITEM item = ch->AutoGiveItem(dwVnum))
-		{
-			item->SetSocket(iSocketIndex, iSocketValue);
-		}
-		else
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "#%d cannot create item.", dwVnum);
-		}
-	}
-}
-
-ACMD(do_xmas)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	int flag = 0;
-
-	if (*arg1)
-		str_to_number(flag, arg1);
-
-	switch (subcmd)
-	{
-		case SCMD_XMAS_BOOM:
-			quest::CQuestManager::instance().RequestSetEventFlag("xmas_boom", flag);
-			break;
-
-		case SCMD_XMAS_SNOW:
-			quest::CQuestManager::instance().RequestSetEventFlag("xmas_snow", flag);
-			break;
-
-		case SCMD_XMAS_SANTA:
-			quest::CQuestManager::instance().RequestSetEventFlag("xmas_santa", flag);
-			break;
-	}
-}
-
-// BLOCK_CHAT
-ACMD(do_block_chat_list)
-{
-	// GM이 아니거나 block_chat_privilege가 없는 사람은 명령어 사용 불가
-	if (!ch || (ch->GetGMLevel() < GM_HIGH_WIZARD && ch->GetQuestFlag("chat_privilege.block") <= 0))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("그런 명령어는 없습니다"));
-		return;
-	}
-
-	DBManager::instance().ReturnQuery(QID_BLOCK_CHAT_LIST, ch->GetPlayerID(), NULL,
-		"SELECT p.name, a.lDuration FROM affect%s as a, player%s as p WHERE a.bType = %d AND a.dwPID = p.id",
-		get_table_postfix(), get_table_postfix(), AFFECT_BLOCK_CHAT);
-}
-
-ACMD(do_vote_block_chat)
-{
-	return;
-
-	char arg1[256];
-	argument = one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: vote_block_chat <name>");
-		return;
-	}
-
-	const char* name = arg1;
-	long lBlockDuration = 10;
-	sys_log(0, "vote_block_chat %s %d", name, lBlockDuration);
-
-	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(name);
-
-	if (!tch)
-	{
-		CCI* pkCCI = P2P_MANAGER::instance().Find(name);
-
-		if (pkCCI)
-		{
-			TPacketGGBlockChat p;
-
-			p.bHeader = HEADER_GG_BLOCK_CHAT;
-			strlcpy(p.szName, name, sizeof(p.szName));
-			p.lBlockDuration = lBlockDuration;
-			P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGBlockChat));
-		}
-		else
-		{
-			TPacketBlockChat p;
-
-			strlcpy(p.szName, name, sizeof(p.szName));
-			p.lDuration = lBlockDuration;
-			db_clientdesc->DBPacket(HEADER_GD_BLOCK_CHAT, ch ? ch->GetDesc()->GetHandle() : 0, &p, sizeof(p));
-
-		}
-
-		if (ch)
-			ch->ChatPacket(CHAT_TYPE_INFO, "Chat block requested.");
-
-		return;
-	}
-
-	if (tch && ch != tch)
-		tch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, lBlockDuration, 0, true);
-}
-
-ACMD(do_block_chat)
-{
-	// GM이 아니거나 block_chat_privilege가 없는 사람은 명령어 사용 불가
-	if (ch && (ch->GetGMLevel() < GM_HIGH_WIZARD && ch->GetQuestFlag("chat_privilege.block") <= 0))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("그런 명령어는 없습니다"));
-		return;
-	}
-
-	char arg1[256];
-	argument = one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		if (ch)
-			ch->ChatPacket(CHAT_TYPE_INFO, "Usage: block_chat <name> <time> (0 to off)");
-
-		return;
-	}
-
-	const char* name = arg1;
-	long lBlockDuration = parse_time_str(argument);
-
-	if (lBlockDuration < 0)
-	{
-		if (ch)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "This is a malformed time. Please specify h, m, and s.");
-			ch->ChatPacket(CHAT_TYPE_INFO, "Example: 1h30m10s (01:30:10");
-		}
-		return;
-	}
-
-	if (ch)
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is now blocked.", name));
-
-	sys_log(0, "BLOCK CHAT %s %d", name, lBlockDuration);
-
-	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(name);
-
-	if (!tch)
-	{
-		CCI* pkCCI = P2P_MANAGER::instance().Find(name);
-
-		if (pkCCI)
-		{
-			TPacketGGBlockChat p;
-
-			p.bHeader = HEADER_GG_BLOCK_CHAT;
-			strlcpy(p.szName, name, sizeof(p.szName));
-			p.lBlockDuration = lBlockDuration;
-			P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGBlockChat));
-		}
-		else
-		{
-			TPacketBlockChat p;
-
-			strlcpy(p.szName, name, sizeof(p.szName));
-			p.lDuration = lBlockDuration;
-			db_clientdesc->DBPacket(HEADER_GD_BLOCK_CHAT, ch ? ch->GetDesc()->GetHandle() : 0, &p, sizeof(p));
-		}
-
-		if (ch)
-			ch->ChatPacket(CHAT_TYPE_INFO, "Chat block requested.");
-
-		return;
-	}
-
-	if (tch && ch != tch)
-		tch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, lBlockDuration, 0, true);
-}
-// END_OF_BLOCK_CHAT
-
-// BUILD_BUILDING
-ACMD(do_build)
-{
-	using namespace building;
-
-	char arg1[256], arg2[256], arg3[256], arg4[256];
-	const char* line = one_argument(argument, arg1, sizeof(arg1));
-	BYTE GMLevel = ch->GetGMLevel();
-
-	CLand* pkLand = CManager::instance().FindLand(ch->GetMapIndex(), ch->GetX(), ch->GetY());
-
-	// NOTE: 조건 체크들은 클라이언트와 서버가 함께 하기 때문에 문제가 있을 때는
-	// 메세지를 전송하지 않고 에러를 출력한다.
-	if (!pkLand)
-	{
-		sys_err("%s trying to build on not buildable area.", ch->GetName());
-		return;
-	}
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Invalid syntax: no command");
-		return;
-	}
-
-	// 건설 권한 체크
-	if (GMLevel == GM_PLAYER)
-	{
-		// 플레이어가 집을 지을 때는 땅이 내껀지 확인해야 한다.
-		if ((!ch->GetGuild() || ch->GetGuild()->GetID() != pkLand->GetOwner()))
-		{
-			sys_err("%s trying to build on not owned land.", ch->GetName());
-			return;
-		}
-
-		// 내가 길마인가?
-		if (ch->GetGuild()->GetMasterPID() != ch->GetPlayerID())
-		{
-			sys_err("%s trying to build while not the guild master.", ch->GetName());
-			return;
-		}
-	}
-
-	switch (LOWER(*arg1))
-	{
-		case 'c':
-		{
-			// /build c vnum x y x_rot y_rot z_rot
-			char arg5[256], arg6[256];
-			line = one_argument(two_arguments(line, arg1, sizeof(arg1), arg2, sizeof(arg2)), arg3, sizeof(arg3)); // vnum x y
-			one_argument(two_arguments(line, arg4, sizeof(arg4), arg5, sizeof(arg5)), arg6, sizeof(arg6)); // x_rot y_rot z_rot
-
-			if (!*arg1 || !*arg2 || !*arg3 || !*arg4 || !*arg5 || !*arg6)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, "Invalid syntax");
-				return;
-			}
-
-			DWORD dwVnum = 0;
-			str_to_number(dwVnum, arg1);
-
-			using namespace building;
-
-			const TObjectProto* t = CManager::instance().GetObjectProto(dwVnum);
-			if (!t)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("존재하지 않는 건물입니다."));
-				return;
-			}
-
-			const DWORD BUILDING_MAX_PRICE = 100000000;
-
-			if (t->dwGroupVnum)
-			{
-				if (pkLand->FindObjectByGroup(t->dwGroupVnum))
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("같이 지을 수 없는 종류의 건물이 지어져 있습니다."));
-					return;
-				}
-			}
-
-			// 건물 종속성 체크 (이 건물이 지어져 있어야함)
-			if (t->dwDependOnGroupVnum)
-			{
-				//const TObjectProto* dependent = CManager::instance().GetObjectProto(dwVnum);
-				//if (dependent)
-				{
-					// 지어져있는가?
-					if (!pkLand->FindObjectByGroup(t->dwDependOnGroupVnum))
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("건설에 필요한 건물이 지어져 있지 않습니다."));
-						return;
-					}
-				}
-			}
-
-			int32_t iPrice = t->dwPrice;
-			if (test_server || GMLevel == GM_PLAYER)
-			{
-				// GM이 아닐경우만 (테섭에서는 GM도 소모)
-				// 건설 비용 체크
-				if (iPrice > BUILDING_MAX_PRICE)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("건물 비용 정보 이상으로 건설 작업에 실패했습니다."));
-					return;
-				}
-
-				if (ch->GetGold() < iPrice)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("건설 비용이 부족합니다."));
-					return;
-				}
-
-				// 아이템 자재 개수 체크
-
-				int i;
-				for (i = 0; i < OBJECT_MATERIAL_MAX_NUM; ++i)
-				{
-					DWORD dwItemVnum = t->kMaterials[i].dwItemVnum;
-					DWORD dwItemCount = t->kMaterials[i].dwCount;
-
-					if (dwItemVnum == 0)
-						break;
-
-					if ((int)dwItemCount > ch->CountSpecifyItem(dwItemVnum))
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("자재가 부족하여 건설할 수 없습니다."));
-						return;
-					}
-				}
-			}
-
-			float x_rot = atof(arg4);
-			float y_rot = atof(arg5);
-			float z_rot = atof(arg6);
-			// 20050811.myevan.건물 회전 기능 봉인 해제
-			/*
-			if (x_rot != 0.0f || y_rot != 0.0f || z_rot != 0.0f)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, "건물 회전 기능은 아직 제공되지 않습니다");
-				return;
-			}
-			*/
-
-			long map_x = 0;
-			str_to_number(map_x, arg2);
-			long map_y = 0;
-			str_to_number(map_y, arg3);
-
-			bool isSuccess = pkLand->RequestCreateObject(dwVnum,
-				ch->GetMapIndex(),
-				map_x,
-				map_y,
-				x_rot,
-				y_rot,
-				z_rot, true
-			);
-
-			if (!isSuccess)
-			{
-				if (test_server)
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("건물을 지을 수 없는 위치입니다."));
-				return;
-			}
-
-			if (test_server || GMLevel == GM_PLAYER)
-				// 건설 재료 소모하기 (테섭에서는 GM도 소모)
-			{
-				// 건설 비용 소모
-				ch->PointChange(POINT_GOLD, -iPrice);
-
-				// 아이템 자재 사용하기 
-				{
-					int i;
-					for (i = 0; i < OBJECT_MATERIAL_MAX_NUM; ++i)
-					{
-						DWORD dwItemVnum = t->kMaterials[i].dwItemVnum;
-						DWORD dwItemCount = t->kMaterials[i].dwCount;
-
-						if (dwItemVnum == 0)
-							break;
-
-						sys_log(0, "BUILD: material %d %u %u", i, dwItemVnum, dwItemCount);
-						ch->RemoveSpecifyItem(dwItemVnum, dwItemCount);
-					}
-				}
-			}
-		}
-		break;
-
-		case 'd':
-			// build (d)elete ObjectID
-		{
-			one_argument(line, arg1, sizeof(arg1));
-
-			if (!*arg1)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, "Invalid syntax");
-				return;
-			}
-
-			DWORD vid = 0;
-			str_to_number(vid, arg1);
-			pkLand->RequestDeleteObjectByVID(vid);
-		}
-		break;
-
-		// BUILD_WALL
-
-		// build w n/e/w/s
-		case 'w':
-			if (GMLevel > GM_PLAYER)
-			{
-				int mapIndex = ch->GetMapIndex();
-
-				one_argument(line, arg1, sizeof(arg1));
-
-				sys_log(0, "guild.wall.build map[%d] direction[%s]", mapIndex, arg1);
-
-				switch (arg1[0])
-				{
-					case 's':
-						pkLand->RequestCreateWall(mapIndex, 0.0f);
-						break;
-					case 'n':
-						pkLand->RequestCreateWall(mapIndex, 180.0f);
-						break;
-					case 'e':
-						pkLand->RequestCreateWall(mapIndex, 90.0f);
-						break;
-					case 'w':
-						pkLand->RequestCreateWall(mapIndex, 270.0f);
-						break;
-					default:
-						ch->ChatPacket(CHAT_TYPE_INFO, "guild.wall.build unknown_direction[%s]", arg1);
-						sys_err("guild.wall.build unknown_direction[%s]", arg1);
-						break;
-				}
-
-			}
-			break;
-
-		case 'e':
-			if (GMLevel > GM_PLAYER)
-			{
-				pkLand->RequestDeleteWall();
-			}
-			break;
-
-		case 'W':
-			// 담장 세우기
-			// build (w)all 담장번호 담장크기 대문동 대문서 대문남 대문북
-
-			if (GMLevel > GM_PLAYER)
-			{
-				int setID = 0, wallSize = 0;
-				char arg5[256], arg6[256];
-				line = two_arguments(line, arg1, sizeof(arg1), arg2, sizeof(arg2));
-				line = two_arguments(line, arg3, sizeof(arg3), arg4, sizeof(arg4));
-				two_arguments(line, arg5, sizeof(arg5), arg6, sizeof(arg6));
-
-				str_to_number(setID, arg1);
-				str_to_number(wallSize, arg2);
-
-				if (setID != 14105 && setID != 14115 && setID != 14125)
-				{
-					sys_log(0, "BUILD_WALL: wrong wall set id %d", setID);
-					break;
-				}
-				else
-				{
-					bool door_east = false;
-					str_to_number(door_east, arg3);
-					bool door_west = false;
-					str_to_number(door_west, arg4);
-					bool door_south = false;
-					str_to_number(door_south, arg5);
-					bool door_north = false;
-					str_to_number(door_north, arg6);
-					pkLand->RequestCreateWallBlocks(setID, ch->GetMapIndex(), wallSize, door_east, door_west, door_south, door_north);
-				}
-			}
-			break;
-
-		case 'E':
-			// 담장 지우기
-			// build (e)rase 담장셋ID
-			if (GMLevel > GM_PLAYER)
-			{
-				one_argument(line, arg1, sizeof(arg1));
-				DWORD id = 0;
-				str_to_number(id, arg1);
-				pkLand->RequestDeleteWallBlocks(id);
-			}
-			break;
-
-		default:
-			ch->ChatPacket(CHAT_TYPE_INFO, "Invalid command %s", arg1);
-			break;
-	}
-}
-// END_OF_BUILD_BUILDING
-
-ACMD(do_clear_quest)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-		return;
-
-	quest::PC* pPC = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
-	pPC->ClearQuest(arg1);
-}
-
-ACMD(do_horse_state)
-{
-	ch->ChatPacket(CHAT_TYPE_INFO, "Horse Information:");
-	ch->ChatPacket(CHAT_TYPE_INFO, "    Level  %d", ch->GetHorseLevel());
-	ch->ChatPacket(CHAT_TYPE_INFO, "    Health %d/%d (%d%%)", ch->GetHorseHealth(), ch->GetHorseMaxHealth(), ch->GetHorseHealth() * 100 / ch->GetHorseMaxHealth());
-	ch->ChatPacket(CHAT_TYPE_INFO, "    Stam   %d/%d (%d%%)", ch->GetHorseStamina(), ch->GetHorseMaxStamina(), ch->GetHorseStamina() * 100 / ch->GetHorseMaxStamina());
-}
-
-ACMD(do_horse_level)
-{
-	char arg1[256] = { 0 };
-	char arg2[256] = { 0 };
-	LPCHARACTER victim;
-	int level = 0;
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1 || !*arg2)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "usage : /horse_level <name> <level>");
-		return;
-	}
-
-	victim = CHARACTER_MANAGER::instance().FindPC(arg1);
-
-	if (NULL == victim)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("존재하지 않는 캐릭터 입니다."));
-		return;
-	}
-
-	str_to_number(level, arg2);
-	level = MINMAX(0, level, HORSE_MAX_LEVEL);
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "horse level set (%s: %d)", victim->GetName(), level);
-
-	victim->SetHorseLevel(level);
-	victim->ComputePoints();
-	victim->SkillLevelPacket();
-	return;
-
-	/*-----
-		char arg1[256];
-		one_argument(argument, arg1, sizeof(arg1));
-
-		int level = MINMAX(0, atoi(arg1), HORSE_MAX_LEVEL);
-
-		ch->ChatPacket(CHAT_TYPE_INFO, "horse level set to %d.", level);
-		ch->SetHorseLevel(level);
-		ch->ComputePoints();
-		ch->SkillLevelPacket();
-		return;
-	-----*/
-}
-
-ACMD(do_horse_ride)
-{
-	if (ch->IsHorseRiding())
-		ch->StopRiding();
-	else
-		ch->StartRiding();
-}
-
-ACMD(do_horse_summon)
-{
-	ch->HorseSummon(true, true);
-}
-
-ACMD(do_horse_unsummon)
-{
-	ch->HorseSummon(false, true);
-}
-
-ACMD(do_horse_set_stat)
-{
-	char arg1[256], arg2[256];
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (*arg1 && *arg2)
-	{
-		int hp = 0;
-		str_to_number(hp, arg1);
-		int stam = 0;
-		str_to_number(stam, arg2);
-		ch->UpdateHorseHealth(hp - ch->GetHorseHealth());
-		ch->UpdateHorseStamina(stam - ch->GetHorseStamina());
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage : /horse_set_stat <hp> <stamina>");
-	}
-}
-
-ACMD(do_save_attribute_to_image) // command "/saveati" for alias
-{
-	char szFileName[256];
-	char szMapIndex[256];
-
-	two_arguments(argument, szMapIndex, sizeof(szMapIndex), szFileName, sizeof(szFileName));
-
-	if (!*szMapIndex || !*szFileName)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: /saveati <map_index> <filename>");
-		return;
-	}
-
-	long lMapIndex = 0;
-	str_to_number(lMapIndex, szMapIndex);
-
-	if (SECTREE_MANAGER::instance().SaveAttributeToImage(lMapIndex, szFileName))
-		ch->ChatPacket(CHAT_TYPE_INFO, "Save done.");
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, "Save failed.");
-}
-
-ACMD(do_affect_remove)
-{
-	char arg1[256];
-	char arg2[256];
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1 || !*arg2)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: /affect_remove <player name>");
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: /affect_remove <type> <point>");
-
-		LPCHARACTER tch = ch;
-
-		if (*arg1)
-			if (!(tch = CHARACTER_MANAGER::instance().FindPC(arg1)))
-				tch = ch;
-
-		ch->ChatPacket(CHAT_TYPE_INFO, "-- Affect List of %s -------------------------------", tch->GetName());
-		ch->ChatPacket(CHAT_TYPE_INFO, "Type Point Modif Duration Flag");
-
-		const AffectContainerList& cont = tch->GetAffectContainer();
-		auto it = cont.begin();
-		while (it != cont.end())
-		{
-			CAffect* pkAff = *it++;
-
-			ch->ChatPacket(CHAT_TYPE_INFO, "%4d %5d %5d %8d %u",
-				pkAff->dwType, pkAff->wApplyOn, pkAff->lApplyValue, pkAff->lDuration, pkAff->dwFlag);
-		}
-		return;
-	}
-
-	bool removed = false;
-
-	CAffect* af;
-
-	DWORD type = 0;
-	str_to_number(type, arg1);
-	POINT_TYPE point = 0;
-	str_to_number(point, arg2);
-	while ((af = ch->FindAffect(type, point)))
-	{
-		ch->RemoveAffect(af);
-		removed = true;
-	}
-
-	if (removed)
-		ch->ChatPacket(CHAT_TYPE_INFO, "Affect successfully removed.");
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, "Not affected by that type and point.");
-}
-
-ACMD(do_affect_add)
-{
-	char arg1[256], arg2[256], arg3[256], arg4[256], arg5[256], arg6[256];
-	one_argument(
-		one_argument(
-			one_argument(
-				one_argument(
-					one_argument(
-						one_argument(argument,
-							arg1, sizeof(arg1)),
-						arg2, sizeof(arg2)),
-					arg3, sizeof(arg3)),
-				arg4, sizeof(arg4)),
-			arg5, sizeof(arg5)),
-		arg6, sizeof(arg6)
-	);
-	if (!*arg1 || !*arg2 || !*arg3 || !*arg4 || !*arg5 || !*arg6)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: /affect_add <type> <apply> <value> <flag> <duration> <override>");
-		return; // invalid syntax
-	}
-
-	DWORD dwType;
-	WORD wApplyOn;
-	long lApplyValue;
-	DWORD dwFlag;
-	long lDuration;
-	bool bOverride;
-
-	str_to_number(dwType, arg1);
-	str_to_number(wApplyOn, arg2);
-	str_to_number(lApplyValue, arg3);
-	str_to_number(dwFlag, arg4);
-	str_to_number(lDuration, arg5);
-	str_to_number(bOverride, arg6);
-
-	ch->AddAffect(dwType, wApplyOn, lApplyValue, dwFlag, lDuration, 0, bOverride);
-	ch->ChatPacket(CHAT_TYPE_INFO, "Affect successfully added.");
-}
-
-ACMD(do_change_attr)
-{
-	LPITEM weapon = ch->GetWear(WEAR_WEAPON);
-	if (weapon)
-		weapon->ChangeAttribute();
-}
-
-ACMD(do_add_attr)
-{
-	LPITEM weapon = ch->GetWear(WEAR_WEAPON);
-	if (weapon)
-		weapon->AddAttribute();
-}
-
-ACMD(do_add_socket)
-{
-	LPITEM weapon = ch->GetWear(WEAR_WEAPON);
-	if (weapon)
-		weapon->AddSocket();
-}
-
-ACMD(do_show_arena_list)
-{
-	CArenaManager::instance().SendArenaMapListTo(ch);
-}
-
-ACMD(do_end_all_duel)
-{
-	CArenaManager::instance().EndAllDuel();
-}
-
-ACMD(do_end_duel)
-{
-	char szName[256];
-
-	one_argument(argument, szName, sizeof(szName));
-
-	LPCHARACTER pChar = CHARACTER_MANAGER::instance().FindPC(szName);
-	if (pChar == NULL)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("존재하지 않는 캐릭터 입니다."));
-		return;
-	}
-
-	if (CArenaManager::instance().EndDuel(pChar->GetPlayerID()) == false)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 강제 종료 실패"));
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 강제 종료 성공"));
-	}
-}
-
-ACMD(do_duel)
-{
-	char szName1[256];
-	char szName2[256];
-	char szSet[256];
-	char szMinute[256];
-	int set = 0;
-	int minute = 0;
-
-	argument = two_arguments(argument, szName1, sizeof(szName1), szName2, sizeof(szName2));
-	two_arguments(argument, szSet, sizeof(szSet), szMinute, sizeof(szMinute));
-
-	str_to_number(set, szSet);
-
-	if (set < 0) set = 1;
-	if (set > 5) set = 5;
-
-	if (!str_to_number(minute, szMinute))
-	{
-		// 캐나다는 기본 10분.
-		if (LC_IsCanada() == true)
-		{
-			minute = 10;
-		}
-		else
-		{
-			minute = 5;
-		}
-	}
-	if (minute < 5)
-		minute = 5;
-
-	LPCHARACTER pChar1 = CHARACTER_MANAGER::instance().FindPC(szName1);
-	LPCHARACTER pChar2 = CHARACTER_MANAGER::instance().FindPC(szName2);
-
-	if (pChar1 != NULL && pChar2 != NULL)
-	{
-		pChar1->RemoveGoodAffect();
-		pChar2->RemoveGoodAffect();
-
-		pChar1->RemoveBadAffect();
-		pChar2->RemoveBadAffect();
-
-		LPPARTY pParty = pChar1->GetParty();
-		if (pParty != NULL)
-		{
-			if (pParty->GetMemberCount() == 2)
-			{
-				CPartyManager::instance().DeleteParty(pParty);
-			}
-			else
-			{
-				pChar1->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티에서 나가셨습니다."));
-				pParty->Quit(pChar1->GetPlayerID());
-			}
-		}
-
-		pParty = pChar2->GetParty();
-		if (pParty != NULL)
-		{
-			if (pParty->GetMemberCount() == 2)
-			{
-				CPartyManager::instance().DeleteParty(pParty);
-			}
-			else
-			{
-				pChar2->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티에서 나가셨습니다."));
-				pParty->Quit(pChar2->GetPlayerID());
-			}
-		}
-
-		if (CArenaManager::instance().StartDuel(pChar1, pChar2, set, minute) == true)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련이 성공적으로 시작 되었습니다."));
-		}
-		else
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련 시작에 문제가 있습니다."));
-		}
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련자가 없습니다."));
-	}
-}
-
-ACMD(do_stat_plus_amount)
-{
-	char szPoint[256];
-
-	one_argument(argument, szPoint, sizeof(szPoint));
-
-	if (*szPoint == '\0')
-		return;
-
-	if (ch->IsPolymorphed())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("둔갑 중에는 능력을 올릴 수 없습니다."));
-		return;
-	}
-
-	int nRemainPoint = ch->GetPoint(POINT_STAT);
-
-	if (nRemainPoint <= 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("남은 스탯 포인트가 없습니다."));
-		return;
-	}
-
-	int nPoint = 0;
-	str_to_number(nPoint, szPoint);
-
-	if (nRemainPoint < nPoint)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("남은 스탯 포인트가 적습니다."));
-		return;
-	}
-
-	if (nPoint < 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("값을 잘못 입력하였습니다."));
-		return;
-	}
-
-	switch (subcmd)
-	{
-		case POINT_HT: // 체력
-			if (nPoint + ch->GetPoint(POINT_HT) > 90)
-			{
-				nPoint = 90 - ch->GetPoint(POINT_HT);
-			}
-			break;
-
-		case POINT_IQ: // 지능
-			if (nPoint + ch->GetPoint(POINT_IQ) > 90)
-			{
-				nPoint = 90 - ch->GetPoint(POINT_IQ);
-			}
-			break;
-
-		case POINT_ST: // 근력
-			if (nPoint + ch->GetPoint(POINT_ST) > 90)
-			{
-				nPoint = 90 - ch->GetPoint(POINT_ST);
-			}
-			break;
-
-		case POINT_DX: // 민첩
-			if (nPoint + ch->GetPoint(POINT_DX) > 90)
-			{
-				nPoint = 90 - ch->GetPoint(POINT_DX);
-			}
-			break;
-
-		default:
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("명령어의 서브 커맨드가 잘못 되었습니다."));
-			return;
-			break;
-	}
-
-	if (nPoint != 0)
-	{
-		ch->SetRealPoint(subcmd, ch->GetRealPoint(subcmd) + nPoint);
-		ch->SetPoint(subcmd, ch->GetPoint(subcmd) + nPoint);
-		ch->ComputePoints();
-		ch->PointChange(subcmd, 0);
-
-		ch->PointChange(POINT_STAT, -nPoint);
-		ch->ComputePoints();
-	}
-}
-
-struct tTwoPID
-{
-	int pid1;
-	int pid2;
-};
-
-ACMD(do_break_marriage)
-{
-	char arg1[256], arg2[256];
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	tTwoPID pids = { 0, 0 };
-
-	str_to_number(pids.pid1, arg1);
-	str_to_number(pids.pid2, arg2);
-
-	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("플레이어 %d 와 플레이어  %d를 파혼시킵니다..", pids.pid1, pids.pid2));
-	db_clientdesc->DBPacket(HEADER_GD_BREAK_MARRIAGE, 0, &pids, sizeof(pids));
-}
-
-ACMD(do_effect)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	int effect_type = 0;
-	str_to_number(effect_type, arg1);
-	ch->EffectPacket(effect_type);
-}
-
-struct FCountInMap
-{
-	int m_Count[4];
-	FCountInMap() { memset(m_Count, 0, sizeof(int) * 4); }
-	void operator()(LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-			if (ch && ch->IsPC())
-				++m_Count[ch->GetEmpire()];
-		}
-	}
-	int GetCount(BYTE bEmpire) { return m_Count[bEmpire]; }
-};
-
-ACMD(do_threeway_war_info)
-{
-	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("각제국 진행 정보"));
-	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("선택 맵 정보 성지 %d 통로 %d %d %d", GetSungziMapIndex(), GetPassMapIndex(1), GetPassMapIndex(2), GetPassMapIndex(3)));
-	ch->ChatPacket(CHAT_TYPE_INFO, "ThreewayPhase %d", CThreeWayWar::instance().GetRegenFlag());
-
-	for (int n = 1; n < 4; ++n)
-	{
-		LPSECTREE_MAP pSecMap = SECTREE_MANAGER::instance().GetMap(GetSungziMapIndex());
-
-		FCountInMap c;
-
-		if (pSecMap)
-		{
-			pSecMap->for_each(c);
-		}
-
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s killscore %d usercount %d",
-			EMPIRE_NAME(n),
-			CThreeWayWar::instance().GetKillScore(n),
-			c.GetCount(n));
-	}
-}
-
-ACMD(do_threeway_war_myinfo)
-{
-	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("나의 삼거리 진행정보"));
-	ch->ChatPacket(CHAT_TYPE_INFO, "Deadcount %d",
-		CThreeWayWar::instance().GetReviveTokenForPlayer(ch->GetPlayerID()));
-}
-
-ACMD(do_rmcandidacy)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: rmcandidacy <name>");
-		return;
-	}
-
-	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-
-	if (!tch)
-	{
-		CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
-
-		if (pkCCI)
-		{
-			if (pkCCI->bChannel != g_bChannel)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, "Target is in %d channel (my channel %d)", pkCCI->bChannel, g_bChannel);
-				return;
-			}
-		}
-	}
-
-	db_clientdesc->DBPacket(HEADER_GD_RMCANDIDACY, 0, NULL, 32);
-	db_clientdesc->Packet(arg1, 32);
-}
-
-ACMD(do_setmonarch)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: setmonarch <name>");
-		return;
-	}
-
-	db_clientdesc->DBPacket(HEADER_GD_SETMONARCH, 0, NULL, 32);
-	db_clientdesc->Packet(arg1, 32);
-}
-
-ACMD(do_rmmonarch)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: rmmonarch <name>");
-		return;
-	}
-
-	db_clientdesc->DBPacket(HEADER_GD_RMMONARCH, 0, NULL, 32);
-	db_clientdesc->Packet(arg1, 32);
-}
-
-ACMD(do_check_monarch_money)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-		return;
-
-	int empire = 0;
-	str_to_number(empire, arg1);
-	int NationMoney = CMonarch::instance().GetMoney(empire);
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "국고: %d 원", NationMoney);
-}
-
-ACMD(do_reset_subskill)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: reset_subskill <name>");
-		return;
-	}
-
-	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-
-	if (tch == NULL)
-		return;
-
-	tch->ClearSubSkill();
-	ch->ChatPacket(CHAT_TYPE_INFO, "Subskill of [%s] was reset", tch->GetName());
-}
-
-ACMD(do_siege)
-{
-	char arg1[256], arg2[256];
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	int empire = strtol(arg1, NULL, 10);
-	int tower_count = strtol(arg2, NULL, 10);
-
-	if (empire == 0) empire = number(1, 3);
-	if (tower_count < 5 || tower_count > 10) tower_count = number(5, 10);
-
-	TPacketGGSiege packet;
-	packet.bHeader = HEADER_GG_SIEGE;
-	packet.bEmpire = empire;
-	packet.bTowerCount = tower_count;
-
-	P2P_MANAGER::instance().Send(&packet, sizeof(TPacketGGSiege));
-
-	switch (castle_siege(empire, tower_count))
-	{
-		case 0:
-			ch->ChatPacket(CHAT_TYPE_INFO, "SIEGE FAILED");
-			break;
-		case 1:
-			ch->ChatPacket(CHAT_TYPE_INFO, "SIEGE START Empire(%d) Tower(%d)", empire, tower_count);
-			break;
-		case 2:
-			ch->ChatPacket(CHAT_TYPE_INFO, "SIEGE END");
-			break;
-	}
-}
-
-ACMD(do_temp)
-{
-	if (false == test_server)
-		return;
-
-	char arg1[256], arg2[256];
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (0 == arg1[0] || 0 == arg2[0])
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: empire money");
-		return;
-	}
-
-	int empire = 0;
-	str_to_number(empire, arg1);
-	int money = 0;
-	str_to_number(money, arg2);
-
-	CMonarch::instance().SendtoDBAddMoney(money, empire, ch);
-}
-
-ACMD(do_frog)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (0 == arg1[0])
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: empire(1, 2, 3)");
-		return;
-	}
-
-	int empire = 0;
-	str_to_number(empire, arg1);
-
-	switch (empire)
-	{
-		case 1:
-		case 2:
-		case 3:
-			if (IS_CASTLE_MAP(ch->GetMapIndex()))
-			{
-				castle_spawn_frog(empire);
-				castle_save();
-			}
-			else
-				ch->ChatPacket(CHAT_TYPE_INFO, "You must spawn frog in castle");
-			break;
-
-		default:
-			ch->ChatPacket(CHAT_TYPE_INFO, "Usage: empire(1, 2, 3)");
-			break;
-	}
-
-}
-
-ACMD(do_flush)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (0 == arg1[0])
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "usage : /flush player_id");
-		return;
-	}
-
-	DWORD pid = (DWORD)strtoul(arg1, NULL, 10);
-
-	db_clientdesc->DBPacketHeader(HEADER_GD_FLUSH_CACHE, 0, sizeof(DWORD));
-	db_clientdesc->Packet(&pid, sizeof(DWORD));
-}
-
-ACMD(do_eclipse)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (strtol(arg1, NULL, 10) == 1)
-	{
-		quest::CQuestManager::instance().RequestSetEventFlag("eclipse", 1);
-	}
-	else
-	{
-		quest::CQuestManager::instance().RequestSetEventFlag("eclipse", 0);
-	}
-}
-
-ACMD(do_weeklyevent)
-{
-	char arg1[256];
-	int empire = 0;
-
-	if (CBattleArena::instance().IsRunning() == false)
-	{
-		one_argument(argument, arg1, sizeof(arg1));
-
-		empire = strtol(arg1, NULL, 10);
-
-		if (empire == 1 || empire == 2 || empire == 3)
-		{
-			CBattleArena::instance().Start(empire);
-		}
-		else
-		{
-			CBattleArena::instance().Start(rand() % 3 + 1);
-		}
-		ch->ChatPacket(CHAT_TYPE_INFO, "Weekly Event Start");
-	}
-	else
-	{
-		CBattleArena::instance().ForceEnd();
-		ch->ChatPacket(CHAT_TYPE_INFO, "Weekly Event End");
-	}
-}
-
-#if defined(__XMAS_EVENT_2008__)
-ACMD(do_event_helper)
-{
-	char arg1[256];
-	int mode = 0;
-
-	one_argument(argument, arg1, sizeof(arg1));
-	str_to_number(mode, arg1);
-
-	if (mode == 1)
-	{
-		xmas::SpawnEventHelper(true);
-		ch->ChatPacket(CHAT_TYPE_INFO, "Event Helper Spawn");
-	}
-	else
-	{
-		xmas::SpawnEventHelper(false);
-		ch->ChatPacket(CHAT_TYPE_INFO, "Event Helper Delete");
-	}
-}
-#endif
-
-struct FMobCounter
-{
-	int nCount;
-
-	void operator () (LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER pChar = static_cast<LPCHARACTER>(ent);
-
-			if (pChar->IsMonster() == true || pChar->IsStone())
-			{
-				nCount++;
-			}
-		}
-	}
-};
-
-ACMD(do_get_mob_count)
-{
-	LPSECTREE_MAP pSectree = SECTREE_MANAGER::instance().GetMap(ch->GetMapIndex());
-
-	if (pSectree == NULL)
-		return;
-
-	FMobCounter f;
-	f.nCount = 0;
-
-	pSectree->for_each(f);
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "MapIndex: %d MobCount %d", ch->GetMapIndex(), f.nCount);
-}
-
-ACMD(do_clear_land)
-{
-	const building::CLand* pLand = building::CManager::instance().FindLand(ch->GetMapIndex(), ch->GetX(), ch->GetY());
-
-	if (NULL == pLand)
-	{
-		return;
-	}
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "Guild Land(%d) Cleared", pLand->GetID());
-
-	building::CManager::instance().ClearLand(pLand->GetID());
-}
-
-ACMD(do_special_item)
-{
-	ITEM_MANAGER::instance().ConvSpecialDropItemFile();
-}
-
-ACMD(do_set_stat)
-{
-	char szName[256];
-	char szChangeAmount[256];
-
-	two_arguments(argument, szName, sizeof(szName), szChangeAmount, sizeof(szChangeAmount));
-
-	if (*szName == 0 || *szChangeAmount == '\0')
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Invalid argument.");
-		return;
-	}
-
-	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(szName);
-
-	if (!tch)
-	{
-		CCI* pkCCI = P2P_MANAGER::instance().Find(szName);
-
-		if (pkCCI)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "Cannot find player(%s). %s is not in your game server.", szName, szName);
-			return;
-		}
-		else
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "Cannot find player(%s). Perhaps %s doesn't login or exist.", szName, szName);
-			return;
-		}
-	}
-	else
-	{
-		if (tch->IsPolymorphed())
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("둔갑 중에는 능력을 올릴 수 없습니다."));
-			return;
-		}
-
-		if (subcmd != POINT_HT && subcmd != POINT_IQ && subcmd != POINT_ST && subcmd != POINT_DX)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("명령어의 서브 커맨드가 잘못 되었습니다."));
-			return;
-		}
-		int nRemainPoint = tch->GetPoint(POINT_STAT);
-		int nCurPoint = tch->GetRealPoint(subcmd);
-		int nChangeAmount = 0;
-		str_to_number(nChangeAmount, szChangeAmount);
-		int nPoint = nCurPoint + nChangeAmount;
-
-		int n;
-		switch (subcmd)
-		{
-			case POINT_HT:
-				if (nPoint < JobInitialPoints[tch->GetJob()].ht)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, "Cannot set stat under initial stat.");
-					return;
-				}
-				n = 0;
-				break;
-			case POINT_IQ:
-				if (nPoint < JobInitialPoints[tch->GetJob()].iq)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, "Cannot set stat under initial stat.");
-					return;
-				}
-				n = 1;
-				break;
-			case POINT_ST:
-				if (nPoint < JobInitialPoints[tch->GetJob()].st)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, "Cannot set stat under initial stat.");
-					return;
-				}
-				n = 2;
-				break;
-			case POINT_DX:
-				if (nPoint < JobInitialPoints[tch->GetJob()].dx)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, "Cannot set stat under initial stat.");
-					return;
-				}
-				n = 3;
-				break;
-		}
-
-		if (nPoint > 90)
-		{
-			nChangeAmount -= nPoint - 90;
-			nPoint = 90;
-		}
-
-		if (nRemainPoint < nChangeAmount)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("남은 스탯 포인트가 적습니다."));
-			return;
-		}
-
-		tch->SetRealPoint(subcmd, nPoint);
-		tch->SetPoint(subcmd, tch->GetPoint(subcmd) + nChangeAmount);
-		tch->ComputePoints();
-		tch->PointChange(subcmd, 0);
-
-		tch->PointChange(POINT_STAT, -nChangeAmount);
-		tch->ComputePoints();
-
-		const char* stat_name[4] = { "con", "int", "str", "dex" };
-
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s's %s change %d to %d", szName, stat_name[n], nCurPoint, nPoint);
-	}
-}
-
-ACMD(do_get_item_id_list)
-{
-	for (int i = 0; i < INVENTORY_MAX_NUM; i++)
-	{
-		LPITEM item = ch->GetInventoryItem(i);
-		if (item != NULL)
-			ch->ChatPacket(CHAT_TYPE_INFO, "cell : %d, name : %s, id : %d", item->GetCell(), item->GetName(), item->GetID());
-	}
-}
-
-ACMD(do_set_socket)
-{
-	char arg1[256];
-	char arg2[256];
-	char arg3[256];
-
-	one_argument(two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2)), arg3, sizeof(arg3));
-
-	int item_id, socket_num, value;
-	if (!str_to_number(item_id, arg1) || !str_to_number(socket_num, arg2) || !str_to_number(value, arg3))
-		return;
-
-	LPITEM item = ITEM_MANAGER::instance().Find(item_id);
-	if (item)
-		item->SetSocket(socket_num, value);
-}
-
-ACMD(do_get_socket)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	int cell;
-	str_to_number(cell, arg1);
-
-	LPITEM item = ch->GetInventoryItem(cell);
-	if (item)
-	{
-		for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "cell(%d), socket(%d) : %ld", cell, i, item->GetSocket(i));
-		}
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "아이템이 없어서 착용할 수 없어.");
-	}
-}
-
-ACMD(do_can_dead)
-{
-	if (subcmd)
-		ch->SetArmada();
-	else
-		ch->ResetArmada();
-}
-
-ACMD(do_full_set)
-{
-	extern void do_all_skill_master(LPCHARACTER ch, const char* argument, int cmd, int subcmd);
-	do_all_skill_master(ch, NULL, 0, 0);
-	extern void do_item_full_set(LPCHARACTER ch, const char* argument, int cmd, int subcmd);
-	do_item_full_set(ch, NULL, 0, 0);
-	extern void do_attr_full_set(LPCHARACTER ch, const char* argument, int cmd, int subcmd);
-	do_attr_full_set(ch, NULL, 0, 0);
-}
-
-ACMD(do_all_skill_master)
-{
-	ch->SetHorseLevel(SKILL_MAX_LEVEL - 10);
-	for (int i = 0; i < SKILL_MAX_NUM; i++)
-	{
-		if (true == ch->CanUseSkill(i))
-		{
-			ch->SetSkillLevel(i, SKILL_MAX_LEVEL);
-		}
-		else
-		{
-			switch (i)
-			{
-				case SKILL_HORSE_WILDATTACK:
-				case SKILL_HORSE_CHARGE:
-				case SKILL_HORSE_ESCAPE:
-				case SKILL_HORSE_WILDATTACK_RANGE:
-					ch->SetSkillLevel(i, SKILL_MAX_LEVEL);
-					break;
-			}
-		}
-	}
-	ch->ComputePoints();
-	ch->SkillLevelPacket();
-}
-
-ACMD(do_item_full_set)
-{
-	BYTE bJob = ch->GetJob();
-	LPITEM pItem = nullptr;
-
-	std::vector<BYTE> vWearIndex
-	{
-		WEAR_BODY,
-		WEAR_HEAD,
-		WEAR_FOOTS,
-		WEAR_WRIST,
-		WEAR_WEAPON,
-		WEAR_NECK,
-		WEAR_EAR,
-		WEAR_UNIQUE1,
-		WEAR_UNIQUE2,
-		WEAR_ARROW,
-		WEAR_SHIELD,
-		WEAR_BELT,
-#if defined(__PENDANT_SYSTEM__)
-		WEAR_PENDANT,
-#endif
-#if defined(__GLOVE_SYSTEM__)
-		WEAR_GLOVE,
-#endif
-
-		WEAR_COSTUME_BODY,
-		WEAR_COSTUME_HAIR,
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-		WEAR_COSTUME_MOUNT,
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		WEAR_COSTUME_ACCE,
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-		WEAR_COSTUME_WEAPON,
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-		WEAR_COSTUME_AURA,
-#endif
-	};
-
-	for (const BYTE bWearIndex : vWearIndex)
-	{
-		pItem = ch->GetWear(bWearIndex);
-		if (pItem)
-			ch->UnequipItem(pItem);
-	}
-
-	using WearItemMap = std::unordered_map<BYTE, std::vector<DWORD>>;
-	WearItemMap mWearItem =
-	{
-		{ JOB_WARRIOR,
-			{
-				{ 20869 }, // WEAR_BODY
-				{ 12739 }, // WEAR_HEAD
-				{ 15449 }, // WEAR_FOOTS
-				{ 14209 }, // WEAR_WRIST
-				{ 319 }, // WEAR_WEAPON
-				{ 16209 }, // WEAR_NECK
-				{ 17549 }, // WEAR_EAR
-				{ 71202 }, // WEAR_UNIQUE1
-				{ 0 }, // WEAR_UNIQUE2
-				{ 13149 }, // WEAR_SHIELD
-				{ 18089 }, // WEAR_BELT
-#if defined(__PENDANT_SYSTEM__)
-				{ 9800 }, // WEAR_PENDANT
-#endif
-#if defined(__GLOVE_SYSTEM__)
-				{ 23009 }, // WEAR_GLOVE
-#endif
-				{ 0 }, // WEAR_COSTUME_BODY
-				{ 0 }, // WEAR_COSTUME_HAIR
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-				{ 0 }, // WEAR_COSTUME_MOUNT
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-				{ 85004 }, // WEAR_COSTUME_ACCE
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-				{ 0 }, // WEAR_COSTUME_WEAPON
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-				{ 49006 }, // WEAR_COSTUME_AURA
-#endif
-			},
-		},
-		{ JOB_ASSASSIN,
-			{
-				{ 20879 }, // WEAR_BODY
-				{ 12749 }, // WEAR_HEAD
-				{ 15449 }, // WEAR_FOOTS
-				{ 14209 }, // WEAR_WRIST
-				{ 1189 }, // WEAR_WEAPON
-				{ 16209 }, // WEAR_NECK
-				{ 17549 }, // WEAR_EAR
-				{ 71202 }, // WEAR_UNIQUE1
-				{ 0 }, // WEAR_UNIQUE2
-				{ 79504 }, // WEAR_ARROW
-				{ 13149 }, // WEAR_SHIELD
-				{ 18089 }, // WEAR_BELT
-#if defined(__PENDANT_SYSTEM__)
-				{ 9800 }, // WEAR_PENDANT
-#endif
-#if defined(__GLOVE_SYSTEM__)
-				{ 23009 }, // WEAR_GLOVE
-#endif
-				{ 0 }, // WEAR_COSTUME_BODY
-				{ 0 }, // WEAR_COSTUME_HAIR
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-				{ 0 }, // WEAR_COSTUME_MOUNT
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-				{ 85004 }, // WEAR_COSTUME_ACCE
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-				{ 0 }, // WEAR_COSTUME_WEAPON
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-				{ 49006 }, // WEAR_COSTUME_AURA
-#endif
-			},
-		},
-		{ JOB_SURA,
-			{
-				{ 20889 }, // WEAR_BODY
-				{ 12489 }, // WEAR_HEAD
-				{ 15449 }, // WEAR_FOOTS
-				{ 14209 }, // WEAR_WRIST
-				{ 309 }, // WEAR_WEAPON
-				{ 16209 }, // WEAR_NECK
-				{ 17549 }, // WEAR_EAR
-				{ 71202 }, // WEAR_UNIQUE1
-				{ 0 }, // WEAR_UNIQUE2
-				{ 13149 }, // WEAR_SHIELD
-				{ 18089 }, // WEAR_BELT
-#if defined(__PENDANT_SYSTEM__)
-				{ 9800 }, // WEAR_PENDANT
-#endif
-#if defined(__GLOVE_SYSTEM__)
-				{ 23009 }, // WEAR_GLOVE
-#endif
-				{ 0 }, // WEAR_COSTUME_BODY
-				{ 0 }, // WEAR_COSTUME_HAIR
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-				{ 0 }, // WEAR_COSTUME_MOUNT
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-				{ 85004 }, // WEAR_COSTUME_ACCE
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-				{ 0 }, // WEAR_COSTUME_WEAPON
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-				{ 49006 }, // WEAR_COSTUME_AURA
-#endif
-			},
-		},
-		{ JOB_SHAMAN,
-			{
-				{ 20899 }, // WEAR_BODY
-				{ 12629 }, // WEAR_HEAD
-				{ 15449 }, // WEAR_FOOTS
-				{ 14209 }, // WEAR_WRIST
-				{ 5169 }, // WEAR_WEAPON
-				{ 16209 }, // WEAR_NECK
-				{ 17549 }, // WEAR_EAR
-				{ 71202 }, // WEAR_UNIQUE1
-				{ 0 }, // WEAR_UNIQUE2
-				{ 13149 }, // WEAR_SHIELD
-				{ 18089 }, // WEAR_BELT
-#if defined(__PENDANT_SYSTEM__)
-				{ 9800 }, // WEAR_PENDANT
-#endif
-#if defined(__GLOVE_SYSTEM__)
-				{ 23009 }, // WEAR_GLOVE
-#endif
-				{ 0 }, // WEAR_COSTUME_BODY
-				{ 0 }, // WEAR_COSTUME_HAIR
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-				{ 0 }, // WEAR_COSTUME_MOUNT
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-				{ 85004 }, // WEAR_COSTUME_ACCE
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-				{ 0 }, // WEAR_COSTUME_WEAPON
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-				{ 49006 }, // WEAR_COSTUME_AURA
-#endif
-			},
-		},
-		{ JOB_WOLFMAN,
-			{
-				{ 20909 }, // WEAR_BODY
-				{ 21509 }, // WEAR_HEAD
-				{ 15449 }, // WEAR_FOOTS
-				{ 14209 }, // WEAR_WRIST
-				{ 6129 }, // WEAR_WEAPON
-				{ 16209 }, // WEAR_NECK
-				{ 17549 }, // WEAR_EAR
-				{ 71202 }, // WEAR_UNIQUE1
-				{ 0 }, // WEAR_UNIQUE2
-				{ 13149 }, // WEAR_SHIELD
-				{ 18089 }, // WEAR_BELT
-#if defined(__PENDANT_SYSTEM__)
-				{ 9800 }, // WEAR_PENDANT
-#endif
-#if defined(__GLOVE_SYSTEM__)
-				{ 23009 }, // WEAR_GLOVE
-#endif
-				{ 0 }, // WEAR_COSTUME_BODY
-				{ 0 }, // WEAR_COSTUME_HAIR
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-				{ 0 }, // WEAR_COSTUME_MOUNT
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-				{ 85004 }, // WEAR_COSTUME_ACCE
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-				{ 0 }, // WEAR_COSTUME_WEAPON
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-				{ 49006 }, // WEAR_COSTUME_AURA
-#endif
-			},
-		},
-	};
-
-	const WearItemMap::iterator& it = mWearItem.find(bJob);
-	if (it != mWearItem.end())
-	{
-		for (const DWORD dwVnum : it->second)
-		{
-			pItem = ITEM_MANAGER::instance().CreateItem(dwVnum, 1, 0, false, -1, false, true);
-			if (!pItem || !pItem->EquipTo(ch, pItem->FindEquipCell(ch)))
-				M2_DESTROY_ITEM(pItem);
-		}
-	}
-
-	ch->ComputePoints();
-}
-
-ACMD(do_attr_full_set)
-{
-	BYTE job = ch->GetJob();
-	LPITEM item;
-
-	switch (job)
-	{
-		case JOB_WARRIOR:
-		case JOB_ASSASSIN:
-		case JOB_SURA:
-		case JOB_SHAMAN:
-		case JOB_WOLFMAN:
-		{
-			// 무사 몸빵 셋팅.
-			// 이것만 나와 있어서 임시로 모든 직군 다 이런 속성 따름.
-			// WEAR_BODY
-			item = ch->GetWear(WEAR_BODY);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
-				item->SetForceAttribute(1, APPLY_CAST_SPEED, 20);
-				item->SetForceAttribute(2, APPLY_STEAL_HP, 10);
-				item->SetForceAttribute(3, APPLY_REFLECT_MELEE, 10);
-				item->SetForceAttribute(4, APPLY_ATT_GRADE_BONUS, 50);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
-#endif
-				item->SetSocket(0, 28438);
-				item->SetSocket(1, 28441);
-				item->SetSocket(2, 28442);
-			}
-			// WEAR_HEAD
-			item = ch->GetWear(WEAR_HEAD);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetForceAttribute(0, APPLY_ATT_SPEED, 8);
-				item->SetForceAttribute(1, APPLY_HP_REGEN, 30);
-				item->SetForceAttribute(2, APPLY_SP_REGEN, 30);
-				item->SetForceAttribute(3, APPLY_DODGE, 15);
-				item->SetForceAttribute(4, APPLY_STEAL_SP, 10);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
-#endif
-			}
-			// WEAR_FOOTS
-			item = ch->GetWear(WEAR_FOOTS);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
-				item->SetForceAttribute(1, APPLY_MAX_SP, 80);
-				item->SetForceAttribute(2, APPLY_MOV_SPEED, 8);
-				item->SetForceAttribute(3, APPLY_ATT_SPEED, 8);
-				item->SetForceAttribute(4, APPLY_CRITICAL_PCT, 10);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
-#endif
-			}
-			// WEAR_WRIST
-			item = ch->GetWear(WEAR_WRIST);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
-				item->SetForceAttribute(1, APPLY_MAX_SP, 80);
-				item->SetForceAttribute(2, APPLY_PENETRATE_PCT, 10);
-				item->SetForceAttribute(3, APPLY_STEAL_HP, 10);
-				item->SetForceAttribute(4, APPLY_MANA_BURN_PCT, 10);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
-#endif
-				item->SetSocket(0, 3);
-				item->SetSocket(1, 3);
-				item->SetSocket(2, 21600);
-			}
-			// WEAR_WEAPON
-			item = ch->GetWear(WEAR_WEAPON);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetForceAttribute(0, APPLY_NORMAL_HIT_DAMAGE_BONUS, 60);
-				item->SetForceAttribute(1, APPLY_CRITICAL_PCT, 10);
-				item->SetForceAttribute(2, APPLY_PENETRATE_PCT, 10);
-				item->SetForceAttribute(3, APPLY_CAST_SPEED, 20);
-				item->SetForceAttribute(4, APPLY_STR, 12);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_ATTBONUS_PER_MONSTER, 10);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
-#endif
-				item->SetSocket(0, 28437);
-				item->SetSocket(1, 28431);
-				item->SetSocket(2, 28430);
-			}
-			// WEAR_NECK
-			item = ch->GetWear(WEAR_NECK);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
-				item->SetForceAttribute(1, APPLY_MAX_SP, 80);
-				item->SetForceAttribute(2, APPLY_CRITICAL_PCT, 10);
-				item->SetForceAttribute(3, APPLY_PENETRATE_PCT, 10);
-				item->SetForceAttribute(4, APPLY_STEAL_SP, 10);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
-#endif
-				item->SetSocket(0, 3);
-				item->SetSocket(1, 3);
-				item->SetSocket(2, 21600);
-			}
-			// WEAR_EAR
-			item = ch->GetWear(WEAR_EAR);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetForceAttribute(0, APPLY_MOV_SPEED, 20);
-				item->SetForceAttribute(1, APPLY_MANA_BURN_PCT, 10);
-				item->SetForceAttribute(2, APPLY_POISON_REDUCE, 5);
-				item->SetForceAttribute(3, APPLY_ATTBONUS_DEVIL, 20);
-				item->SetForceAttribute(4, APPLY_ATTBONUS_UNDEAD, 20);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
-#endif
-				item->SetSocket(0, 3);
-				item->SetSocket(1, 3);
-				item->SetSocket(2, 21600);
-			}
-			// WEAR_SHIELD
-			item = ch->GetWear(WEAR_SHIELD);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetForceAttribute(0, APPLY_CON, 12);
-				item->SetForceAttribute(1, APPLY_BLOCK, 15);
-				item->SetForceAttribute(2, APPLY_REFLECT_MELEE, 10);
-				item->SetForceAttribute(3, APPLY_IMMUNE_STUN, 1);
-				item->SetForceAttribute(4, APPLY_IMMUNE_SLOW, 1);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
-#endif
-			}
-			// WEAR_BELT
-			item = ch->GetWear(WEAR_BELT);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetSocket(0, 3);
-				item->SetSocket(1, 3);
-				item->SetSocket(2, 21600);
-			}
-			// WEAR_PENDANT
-#if defined(__PENDANT_SYSTEM__)
-			item = ch->GetWear(WEAR_PENDANT);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetForceAttribute(0, APPLY_MALL_DEFBONUS, 5);
-				item->SetForceAttribute(1, APPLY_RESIST_ICE, 25);
-				item->SetForceAttribute(2, APPLY_RESIST_EARTH, 25);
-				item->SetForceAttribute(3, APPLY_RESIST_DARK, 25);
-				item->SetForceAttribute(4, APPLY_ATTBONUS_HUMAN, 10);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
-#endif
-			}
-#endif
-			// WEAR_GLOVE
-#if defined(__GLOVE_SYSTEM__)
-			item = ch->GetWear(WEAR_GLOVE);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetForceAttribute(0, APPLY_HIT_PCT, 12);
-				item->SetForceAttribute(1, APPLY_RESIST_HUMAN, 10);
-				item->SetForceAttribute(2, APPLY_RESIST_MOUNT_FALL, 20);
-				item->SetForceAttribute(3, APPLY_REFLECT_MELEE, 10);
-				item->SetForceAttribute(4, APPLY_STR, 12);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
-#endif
-			}
-#endif
-			// WEAR_COSTUME_ACCE
-#if defined(__ACCE_COSTUME_SYSTEM__)
-			item = ch->GetWear(WEAR_COSTUME_ACCE);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetSocket(ITEM_SOCKET_ACCE_DRAIN_ITEM_VNUM, 2209);
-				item->SetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE, ACCE_MAX_DRAINRATE);
-				item->SetForceAttribute(0, APPLY_NORMAL_HIT_DAMAGE_BONUS, 12);
-				item->SetForceAttribute(1, APPLY_CRITICAL_PCT, 2);
-				item->SetForceAttribute(2, APPLY_PENETRATE_PCT, 2);
-				item->SetForceAttribute(3, APPLY_DEX, 3);
-				item->SetForceAttribute(4, APPLY_STR, 3);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_ATTBONUS_STONE, 2);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 12);
-#endif
-			}
-#endif
-			// WEAR_COSTUME_AURA
-#if defined(__AURA_COSTUME_SYSTEM__)
-			item = ch->GetWear(WEAR_COSTUME_AURA);
-			if (item != NULL)
-			{
-				item->ClearAllAttribute();
-				item->SetSocket(ITEM_SOCKET_AURA_DRAIN_ITEM_VNUM, 16209);
-
-				item->SetForceAttribute(0, APPLY_MAX_HP, 500);
-				item->SetForceAttribute(1, APPLY_MAX_SP, 20);
-				item->SetForceAttribute(2, APPLY_CRITICAL_PCT, 2);
-				item->SetForceAttribute(3, APPLY_PENETRATE_PCT, 2);
-				item->SetForceAttribute(4, APPLY_DAMAGE_SP_RECOVER, 2);
-#if defined(__ATTR_6TH_7TH__)
-				item->SetForceAttribute(5, APPLY_MAX_HP, 125);
-				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 12);
-#endif
-			}
-#endif
-		}
-		break;
-	}
-
-	ch->ComputePoints();
-}
-
-ACMD(do_use_item)
-{
-	char arg1[256];
-
-	one_argument(argument, arg1, sizeof(arg1));
-
-	int cell;
-	str_to_number(cell, arg1);
-
-	LPITEM item = ch->GetInventoryItem(cell);
-	if (item)
-	{
-		ch->UseItem(TItemPos(INVENTORY, cell));
-	}
-	else
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "아이템이 없어서 착용할 수 없어.");
-	}
-}
-
-ACMD(do_clear_affect)
-{
-	ch->ClearAffect(true);
-}
-
-struct FuncKillAll
-{
-	LPCHARACTER m_ch;
-
-	FuncKillAll(LPCHARACTER ch) :
-		m_ch(ch)
-	{}
-
-	void operator()(LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-
-			if (m_ch == ch || ch->IsNPC() || ch->IsGM() || ch->IsDead() || ch->GetHP() <= 0)
-				return;
-
-			float fDist = DISTANCE_APPROX(m_ch->GetX() - ch->GetX(), m_ch->GetY() - ch->GetY());
-			if (fDist > 7000.f)
-				return;
-
-			int damage = ch->GetHP() + number(1, 4250);
-			ch->EffectPacket(SE_CRITICAL);
-			ch->PointChange(POINT_HP, -damage, false);
-			ch->Dead();
-		}
-	}
-};
-
-ACMD(do_kill_all)
-{
-	LPSECTREE pSec = ch->GetSectree();
-	if (pSec)
-	{
-		FuncKillAll f(ch);
-		pSec->ForEachAround(f);
-	}
-}
-
-ACMD(do_drop_item)
-{
-	// #Pass 1. With one arg: args[0] = Cell
-	// #Pass 2. With two args: args[0] = BeginCell args[1] = EndCell
-	char args[2][256];
-
-	argument = two_arguments(argument, args[0], 256, args[1], 256);
-	if (!*args[0])
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage:");
-		ch->ChatPacket(CHAT_TYPE_INFO, "/drop_item <SlotPos> or /drop_item <BeginPos> <EndPos>");
-		return;
-	}
-
-	if (!*args[1])
-	{
-		int Cell;
-		str_to_number(Cell, args[0]);
-		if (Cell >= 0 && Cell < INVENTORY_MAX_NUM)
-			ch->DropItem(TItemPos(INVENTORY, Cell));
-		else
-			ch->ChatPacket(CHAT_TYPE_INFO, "Invalid argument! (Cell:%d)", Cell);
-	}
-	else
-	{
-		int beginPos;
-		str_to_number(beginPos, args[0]);
-		int endPos;
-		str_to_number(endPos, args[1]);
-		sys_log(0, "do_drop_item: beginPos: %d, endPos: %d", beginPos, endPos);
-		if (beginPos >= 0 && endPos < INVENTORY_MAX_NUM && beginPos < endPos)
-		{
-			for (int Cell = beginPos; Cell <= endPos; Cell++)
-				ch->DropItem(TItemPos(INVENTORY, Cell));
-		}
-		else
-			ch->ChatPacket(CHAT_TYPE_INFO, "Invalid arguments! (beginPos:%d; endPos:%d)", beginPos, endPos);
-	}
-}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-ACMD(do_dragon_soul)
-{
-	char arg1[512];
-	const char* rest = one_argument(argument, arg1, sizeof(arg1));
-	switch (arg1[0])
-	{
-		case 'a':
-		{
-			one_argument(rest, arg1, sizeof(arg1));
-			int deck_idx = 0;
-			if (str_to_number(deck_idx, arg1) == false)
-			{
-				return;
-			}
-			ch->DragonSoul_ActivateDeck(deck_idx);
-		}
-		break;
-		case 'd':
-		{
-			ch->DragonSoul_DeactivateAll();
-		}
-		break;
-	}
-}
-
-ACMD(do_ds_list)
-{
-	for (int i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; i++)
-	{
-		TItemPos cell(DRAGON_SOUL_INVENTORY, i);
-
-		LPITEM item = ch->GetItem(cell);
-		if (item != NULL)
-			ch->ChatPacket(CHAT_TYPE_INFO, "cell : %d, name : %s, id : %d", item->GetCell(), item->GetName(), item->GetID());
-	}
-}
-
-ACMD(do_ds_qualify)
-{
-	ch->DragonSoul_GiveQualification();
-}
-#endif
-
-#if defined(__INGAME_EVENT_MANAGER__) && defined(__EVENT_BANNER_FLAG__)
-ACMD(do_banner)
-{
-	char arg1[256], arg2[256];
-	int iEnable = 0;
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1 || !*arg2 || !isnhdigit(*arg1))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: /banner <1:0> <banner_name>");
-		ch->ChatPacket(CHAT_TYPE_INFO, "Example: /banner 1 halloween");
-		return;
-	}
-
-	str_to_number(iEnable, arg1);
-
-	CInGameEventManager::instance().SpawnBanners(iEnable, arg2);
-
-	return;
-}
-#endif
-
-#if defined(__CONQUEROR_LEVEL__)
-ACMD(do_conqueror_level)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: conqueror_level <level>");
-		return;
-	}
-
-	int level = 0;
-	str_to_number(level, arg1);
-
-	ch->ResetConquerorPoint(MINMAX(0, level, gPlayerMaxConquerorLevel));
-	ch->ResetConquerorExp();
-}
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-ACMD(do_mini_game_okey)
-{
-	char szArg1[256], szArg2[256], szArg3[256];
-	three_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2), szArg3, sizeof(szArg3));
-	int iEnable = 0, iDropPerKillPct = 100, iNormal = 0;
-
-	if (strlen(szArg1) == 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mini_game_okey <enable_days> <drop_value>");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <enable_days> days / 0 (disable); -1 (disable + disable reward cooldown)");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> default 100");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <normal> default 0");
-		return;
-	}
-
-	if (*szArg1 && !strcmp(szArg1, "-1"))
-		iEnable -= 1;
-	else if (isnhdigit(*szArg1))
-		str_to_number(iEnable, szArg1);
-
-	if (isnhdigit(*szArg2))
-		str_to_number(iDropPerKillPct, szArg2);
-
-	if (isnhdigit(*szArg3))
-		str_to_number(iNormal, szArg3);
-
-	if (iEnable > 0)
-	{
-		DWORD dwEndTime = std::time(nullptr) + (60 * 60 * 24 * iEnable);
-
-		if (iNormal == 0)
-		{
-			quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey", dwEndTime);
-			quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_normal", 0);
-		}
-		else
-		{
-			quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey", 0);
-			quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_normal", dwEndTime);
-		}
-
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_drop", iDropPerKillPct);
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_reward", 0);
-
-		BroadcastNotice(LC_STRING("[Okey Event] The Okey Event has started!"));
-		BroadcastNotice(LC_STRING("[Okey Event] Defeat monsters, collect cards and play a game of okey."));
-		BroadcastNotice(LC_STRING("[Okey Event] Amazing prizes await!"));
-	}
-	else if (iEnable == 0)
-	{
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey", 0);
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_normal", 0);
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_reward",
-			std::time(nullptr) + CMiniGameRumi::RUMI_REWARD_COOLDOWN);
-
-		BroadcastNotice(LC_STRING("[Okey Event] The Okey Event is over!"));
-		BroadcastNotice(LC_STRING("[Okey Event] If you make it into the top rankings, you have 7 days to collect your prize."));
-	}
-	else
-	{
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey", 0);
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_normal", 0);
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_reward", -1); // -1 to remove the event npc.
-
-		BroadcastNotice(LC_STRING("[Okey Event] The Okey Event is over!"));
-	}
-}
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__)
-ACMD(do_mini_game_yutnori)
-{
-	char szArg1[256], szArg2[256];
-	two_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2));
-	int iEnable = 0, iDropPerKillPct = 100;
-
-	if (strlen(szArg1) == 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mini_game_yutnori <enable_days> <drop_value>");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <enable_days> days / 0 (disable); -1 (disable + disable reward cooldown)");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> default 100");
-		return;
-	}
-
-	if (*szArg1 && !strcmp(szArg1, "-1"))
-		iEnable -= 1;
-	else if (isnhdigit(*szArg1))
-		str_to_number(iEnable, szArg1);
-
-	if (isnhdigit(*szArg2))
-		str_to_number(iDropPerKillPct, szArg2);
-
-	if (iEnable > 0)
-	{
-		DWORD dwEndTime = std::time(nullptr) + (60 * 60 * 24 * iEnable);
-
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori", dwEndTime);
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori_drop", iDropPerKillPct);
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori_reward", 0);
-
-		BroadcastNotice(LC_STRING("Yut Nori has started!"));
-		BroadcastNotice(LC_STRING("Collect Birch Branches, craft Yut Nori Boards from them and play the exciting minigame."));
-		BroadcastNotice(LC_STRING("Fantastic prizes await!"));
-	}
-	else if (iEnable == 0)
-	{
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori", 0);
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori_reward",
-			std::time(nullptr) + CMiniGameYutnori::YUTNORI_REWARD_COOLDOWN);
-
-		BroadcastNotice(LC_STRING("Yut Nori has finished."));
-		BroadcastNotice(LC_STRING("Go to the Yut Nori Table to collect your reward."));
-	}
-	else
-	{
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori", 0);
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori_reward", -1); // -1 to remove the event npc.
-
-		BroadcastNotice(LC_STRING("Yut Nori has finished."));
-	}
-}
-#endif
-
-#if defined(__FLOWER_EVENT__)
-ACMD(do_flower_event)
-{
-	char szArg1[256], szArg2[256];
-	two_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2));
-	int iDropPerKillPct = 100;
-
-	if (strlen(szArg1) == 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: flower_event <drop_value>");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> value / 0 (disable)");
-		return;
-	}
-
-	if (isnhdigit(*szArg1))
-		str_to_number(iDropPerKillPct, szArg1);
-
-	if (iDropPerKillPct != 0)
-	{
-		quest::CQuestManager::instance().RequestSetEventFlag("e_flower_drop", iDropPerKillPct);
-		BroadcastNotice(LC_STRING("The Flower Power Event has started."));
-	}
-	else
-	{
-		quest::CQuestManager::instance().RequestSetEventFlag("e_flower_drop", 0);
-		BroadcastNotice(LC_STRING("The Flower Power Event has ended."));
-	}
-}
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__)
-ACMD(do_mini_game_catchking)
-{
-	char szArg1[256], szArg2[256];
-	two_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2));
-	int iEnable = 0, iDropPerKillPct = 100;
-
-	if (strlen(szArg1) == 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mini_game_catchking <enable_days> <drop_value>");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <enable_days> days / 0 (disable)");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> default 100");
-		return;
-	}
-
-	if (isnhdigit(*szArg1))
-		str_to_number(iEnable, szArg1);
-
-	if (isnhdigit(*szArg2))
-		str_to_number(iDropPerKillPct, szArg2);
-
-	if (iEnable != 0)
-	{
-		DWORD dwEndTime = std::time(nullptr) + (60 * 60 * 24 * iEnable);
-
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_catchking", dwEndTime);
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_catchking_drop", iDropPerKillPct);
-
-		BroadcastNotice(LC_STRING("[Catch the King] Play a game of Catch the King now!"));
-		BroadcastNotice(LC_STRING("[Catch the King] Defeat monsters to collect King Cards. You need 25 cards for a King Deck."));
-		BroadcastNotice(LC_STRING("[Catch the King] Loads of great prizes await!"));
-		BroadcastNotice(LC_STRING("[Catch the King] If you make it into the top rankings, you'll receive your prize from the game table."));
-	}
-	else
-	{
-		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_catchking", 0);
-
-		BroadcastNotice(LC_STRING("[Catch the King] Catch the King has ended."));
-	}
-}
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-ACMD(do_snowflake_stick_event)
-{
-	char szArg1[256], szArg2[256];
-	two_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2));
-	int iEnable = 0, iDropPerKillPct = 100;
-
-	if (strlen(szArg1) == 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: snowflake_stick_event <enable_days> <drop_value>");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <enable_days> days / 0 (disable)");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> default 100");
-		return;
-	}
-
-	if (isnhdigit(*szArg1))
-		str_to_number(iEnable, szArg1);
-
-	if (isnhdigit(*szArg2))
-		str_to_number(iDropPerKillPct, szArg2);
-
-	if (iEnable != 0)
-	{
-		DWORD dwEndTime = std::time(nullptr) + (60 * 60 * 24 * iEnable);
-		quest::CQuestManager::instance().RequestSetEventFlag("snowflake_stick_event", dwEndTime);
-		quest::CQuestManager::instance().RequestSetEventFlag("snowflake_stick_drop", iDropPerKillPct);
-	}
-	else
-	{
-		quest::CQuestManager::instance().RequestSetEventFlag("snowflake_stick_event", 0);
-	}
-}
-#endif
-
-#if defined(__CHECK_PORT_STATUS__)
-ACMD(do_portstatus)
-{
-	char szArg1[256];
-	one_argument(argument, szArg1, sizeof(szArg1));
-	int iListenPort = 0;
-
-	if (strlen(szArg1) == 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: portstatus <port>");
-		return;
-	}
-
-	if (isnhdigit(*szArg1))
-	{
-		str_to_number(iListenPort, szArg1);
-
-		socket_t socket = socket_connect(g_szPublicIP, static_cast<WORD>(iListenPort));
-		if (socket != INVALID_SOCKET)
-		{
-			socket_close(socket);
-
-			ch->ChatPacket(CHAT_TYPE_INFO, "Port %d is available.", iListenPort);
-		}
-		else
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "Port %d is not available.", iListenPort);
-		}
-	}
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: portstatus <channel> <port>");
-}
-#endif
-
-ACMD(do_view_equip)
-{
-	char szArg1[256];
-	one_argument(argument, szArg1, sizeof(szArg1));
-
-	if (!*szArg1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: view_equip <character name>");
-		return;
-	}
-
-	LPCHARACTER pTargetChar = CHARACTER_MANAGER::instance().FindPC(szArg1);
-	if (NULL == pTargetChar)
-	{
-		const CCI* pkCCI = P2P_MANAGER::instance().Find(szArg1);
-		if (pkCCI && pkCCI->pkDesc)
-			pTargetChar = pkCCI->pkDesc->GetCharacter();
-		else
-			pTargetChar = NULL;
-	}
-
-	if (pTargetChar && pTargetChar->IsPC())
-		pTargetChar->SendEquipment(ch);
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, "%s is not online or doesn't exist.", szArg1);
-}
-
-ACMD(do_loglevel)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	unsigned int level = 0;
-	str_to_number(level, arg1);
-
-	char buf[255 + 1];
-	snprintf(buf, sizeof(buf), "LOG LEVEL : %d", level);
-	sys_log(0, buf);
-
-	log_set_level(level);
-}
-
-struct ClearGroundItems
-{
-	void operator () (LPENTITY ent)
-	{
-		if (!ent->IsType(ENTITY_ITEM))
-			return;
-
-		LPITEM item = (LPITEM)ent;
-		if (item) M2_DESTROY_ITEM(item);
-	}
-};
-
-ACMD(do_clear_ground)
-{
-	ClearGroundItems func;
-	LPSECTREE sectree = ch->GetSectree();
-	if (sectree)
-		sectree->ForEachAround(func);
-}
-
-struct whisper_notice_packet_func
-{
-	const char* m_str;
-	whisper_notice_packet_func(const char* str) : m_str(str) {}
-
-	void operator() (LPDESC d)
-	{
-		if (d->GetCharacter() == NULL)
-			return;
-
-		TPacketGCWhisper pack;
-
-		int len = MIN(CHAT_MAX_LEN, strlen(m_str) + 1);
-
-		pack.bHeader = HEADER_GC_WHISPER;
-		pack.wSize = sizeof(TPacketGCWhisper) + len;
-		pack.bType = WHISPER_TYPE_SYSTEM;
-		strlcpy(pack.szNameFrom, "[LC;5452]", sizeof(pack.szNameFrom));
-
-		TEMP_BUFFER buf;
-
-		buf.write(&pack, sizeof(TPacketGCWhisper));
-		buf.write(m_str, len);
-		d->Packet(buf.read_peek(), buf.size());
-	}
-};
-
-void SendWhisperNotice(const char* c_pszBuf)
-{
-	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
-	std::for_each(c_ref_set.begin(), c_ref_set.end(), whisper_notice_packet_func(c_pszBuf));
-}
-
-ACMD(do_whisper_notice)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	SendWhisperNotice(arg1);
-}
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-ACMD(do_mini_game_roulette)
-{
-	char szArg1[256], szArg2[256];
-	two_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2));
-	int iEnable = 0, iDropPerKillPct = 100;
-
-	if (strlen(szArg1) == 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mini_game_roulette <enable_days> <drop_value>");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <enable_days> days / 0 (disable);");
-		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> default 100");
-		return;
-	}
-
-	if (isnhdigit(*szArg1))
-		str_to_number(iEnable, szArg1);
-
-	if (isnhdigit(*szArg2))
-		str_to_number(iDropPerKillPct, szArg2);
-
-	if (iEnable > 0)
-	{
-		DWORD dwEndTime = std::time(nullptr) + (60 * 60 * 24 * iEnable);
-
-		quest::CQuestManager::instance().RequestSetEventFlag("e_late_summer", dwEndTime);
-		quest::CQuestManager::instance().RequestSetEventFlag("e_late_summer_drop", iDropPerKillPct);
-
-		BroadcastNotice(LC_STRING("The Altar of Blood has appeared."));
-	}
-	else if (iEnable == 0)
-	{
-		quest::CQuestManager::instance().RequestSetEventFlag("e_late_summer", 0);
-		quest::CQuestManager::instance().RequestSetEventFlag("e_late_summer_drop", 0);
-	}
-}
-#endif
-
-#if defined(__DEFENSE_WAVE__)
-ACMD(do_dw_create)
-{
-	LPDEFENSE_WAVE pDefenseWave = CDefenseWaveManager::Instance().Create(MAP_DEFENSEWAVE);
-	if (pDefenseWave == NULL)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Cannot create CDefenseWave on OriginalMapIndex %ld", MAP_DEFENSEWAVE);
-		return;
-	}
-
-	ch->ChatPacket(CHAT_TYPE_INFO, "CDefenseWave Created %u", pDefenseWave->GetId());
-	pDefenseWave->Initialize();
-	pDefenseWave->Enter(ch);
-	pDefenseWave->Start();
-}
-#endif
-
-#ifdef __OFFLINE_SHOP__
-ACMD(do_deleteshop)
-{
-	char arg1[256];
-	one_argument(argument, arg1, sizeof(arg1));
-
-	if (!*arg1)
-		return;
-
-	DWORD vid = 0;
-	str_to_number(vid, arg1);
-
-	COfflineShop::GM_CloseShop(ch, vid);
-}
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-#include "battlepass_manager.h"
-ACMD(do_battlepass_get_info)
-{
-	if (CBattlePassManager::instance().GetNormalBattlePassID() == 0) 
-		ch->ChatPacket(CHAT_TYPE_INFO, "No normal Battlepass is currently active");
-	else
-	{
-		std::unique_ptr<SQLMsg> pMsgRegistred(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 1 and battlepass_id = %d", CBattlePassManager::instance().GetNormalBattlePassID()));
-		std::unique_ptr<SQLMsg> pMsgCompledet(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 1 and battlepass_id = %d and battlepass_completed = 1", CBattlePassManager::instance().GetNormalBattlePassID()));
-		if (!pMsgRegistred->uiSQLErrno and !pMsgCompledet->uiSQLErrno)
-		{
-			MYSQL_ROW row_registred = mysql_fetch_row(pMsgRegistred->Get()->pSQLResult);
-			MYSQL_ROW row_compledet = mysql_fetch_row(pMsgCompledet->Get()->pSQLResult);
-			
-			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
-			ch->ChatPacket(CHAT_TYPE_INFO, "Actual Normal Battlepass ID = %d", CBattlePassManager::instance().GetNormalBattlePassID());
-			ch->ChatPacket(CHAT_TYPE_INFO, "Registred Player for Normal Battlepass = %d", std::atoi(row_registred[0]));
-			ch->ChatPacket(CHAT_TYPE_INFO, "Finish Player for Normal Battlepass = %d / %d", std::atoi(row_compledet[0]), std::atoi(row_registred[0]));
-			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
-		}
-	}
-		
-	if (CBattlePassManager::instance().GetPremiumBattlePassID() == 0) 
-		ch->ChatPacket(CHAT_TYPE_INFO, "No premium Battlepass is currently active");
-	else
-	{
-		std::unique_ptr<SQLMsg> pMsgRegistred(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 2 and battlepass_id = %d", CBattlePassManager::instance().GetPremiumBattlePassID()));
-		std::unique_ptr<SQLMsg> pMsgCompledet(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 2 and battlepass_id = %d and battlepass_completed = 1", CBattlePassManager::instance().GetPremiumBattlePassID()));
-		if (!pMsgRegistred->uiSQLErrno and !pMsgCompledet->uiSQLErrno)
-		{
-			MYSQL_ROW row_registred = mysql_fetch_row(pMsgRegistred->Get()->pSQLResult);
-			MYSQL_ROW row_compledet = mysql_fetch_row(pMsgCompledet->Get()->pSQLResult);
-			
-			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
-			ch->ChatPacket(CHAT_TYPE_INFO, "Actual Premium Battlepass ID = %d", CBattlePassManager::instance().GetPremiumBattlePassID());
-			ch->ChatPacket(CHAT_TYPE_INFO, "Registred Player for Premium Battlepass = %d",  std::atoi(row_registred[0]));
-			ch->ChatPacket(CHAT_TYPE_INFO, "Finish Player for Premium Battlepass = %d / %d", std::atoi(row_compledet[0]), std::atoi(row_registred[0]));
-			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
-		}
-	}
-		
-	if (CBattlePassManager::instance().GetEventBattlePassID() == 0) 
-		ch->ChatPacket(CHAT_TYPE_INFO, "No event Battlepass is currently active");
-	else
-	{
-		std::unique_ptr<SQLMsg> pMsgRegistred(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 3 and battlepass_id = %d", CBattlePassManager::instance().GetEventBattlePassID()));
-		std::unique_ptr<SQLMsg> pMsgCompledet(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 3 and battlepass_id = %d and battlepass_completed = 1", CBattlePassManager::instance().GetEventBattlePassID()));
-		if (!pMsgRegistred->uiSQLErrno and !pMsgCompledet->uiSQLErrno)
-		{
-			MYSQL_ROW row_registred = mysql_fetch_row(pMsgRegistred->Get()->pSQLResult);
-			MYSQL_ROW row_compledet = mysql_fetch_row(pMsgCompledet->Get()->pSQLResult);
-			
-			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
-			ch->ChatPacket(CHAT_TYPE_INFO, "Actual Event Battlepass ID = %d", CBattlePassManager::instance().GetEventBattlePassID());
-			ch->ChatPacket(CHAT_TYPE_INFO, "Registred Player for Event Battlepass = %d", std::atoi(row_registred[0]));
-			ch->ChatPacket(CHAT_TYPE_INFO, "Finish Player for Event Battlepass = %d / %d", std::atoi(row_compledet[0]), std::atoi(row_registred[0]));
-			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
-		}
-	}
-}
-
-ACMD(do_battlepass_set_mission)
-{
-	char arg1[256], arg2[256], arg3[256], arg4[256];
-	four_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2), arg3, sizeof(arg3), arg4, sizeof(arg4));
-	
-	if (!*arg1 || !*arg2 || !*arg3)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: battlepass_set_mission <battlepass_type> <mission_index> <value> (<playername>)");
-		ch->ChatPacket(CHAT_TYPE_INFO, "battlepass_type: 1 = NORMAL | 2 = PREMIUM | 3 = EVENT");
-		ch->ChatPacket(CHAT_TYPE_INFO, "mission_index: mission index means the number of the mission counted from the top starting with 1");
-		ch->ChatPacket(CHAT_TYPE_INFO, "value: input the value what you will override");
-		return;
-	}
-	
-	int battlepass_type, mission_index, value;
-	str_to_number(battlepass_type, arg1);
-	str_to_number(mission_index, arg2);
-	str_to_number(value, arg3);
-	
-	value = MAX(0, value);
-	
-	if (battlepass_type == 1 and CBattlePassManager::instance().GetNormalBattlePassID() == 0) {
-		ch->ChatPacket(CHAT_TYPE_INFO, "No normal Battlepass is currently active");
-		return;
-	}
-	if (battlepass_type == 2 and CBattlePassManager::instance().GetPremiumBattlePassID() == 0) {
-		ch->ChatPacket(CHAT_TYPE_INFO, "No premium Battlepass is currently active");
-		return;
-	}
-	if (battlepass_type == 3 and CBattlePassManager::instance().GetEventBattlePassID() == 0) {
-		ch->ChatPacket(CHAT_TYPE_INFO, "No event Battlepass is currently active");
-		return;
-	}
-	
-	LPCHARACTER tch;
-	
-	if (*arg4 && ch->GetName() != arg4)
-		tch = CHARACTER_MANAGER::instance().FindPC(arg4);
-	else
-		tch = CHARACTER_MANAGER::instance().FindPC(ch->GetName());
-
-	if (!tch) {
-		ch->ChatPacket(CHAT_TYPE_INFO, "This player is not online or does not exist.");
-		return;
-	}
-	if (battlepass_type == 2 and CBattlePassManager::instance().GetPremiumBattlePassID() != tch->GetExtBattlePassPremiumID()) {
-		ch->ChatPacket(CHAT_TYPE_INFO, "This player does not have access to the current Premium Battle Pass.");
-		return;
-	}
-	DWORD mission_type = CBattlePassManager::instance().GetMissionTypeByIndex(battlepass_type, mission_index);
-	if (mission_type == 0){
-		ch->ChatPacket(CHAT_TYPE_INFO, "There is no mission index %d in battlepass-typ %d", mission_index, battlepass_type);
-		return;
-	}
-	
-	tch->SetExtBattlePassMissionProgress(battlepass_type, mission_index, mission_type, value);
-}
-
-ACMD(do_battlepass_premium_activate)
-{
-	char arg1[256], arg2[256];
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	int value;
-	str_to_number(value, arg2);
-	
-	if (!*arg1 || !*arg2 || value > 1)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: battlepass_premium_activate <playername> <activate = 1 / deactivate = 0>");
-		return;
-	}
-	
-	if (CBattlePassManager::instance().GetPremiumBattlePassID() == 0) {
-		ch->ChatPacket(CHAT_TYPE_INFO, "No premium Battlepass is currently active");
-		return;
-	}
-		
-	if (ch->GetName() != arg1) {
-		LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
-		if (!tch)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, "This player is not online or does not exist.");
-			return;
-		}	
-			
-		if (value == 1)
-		{
-			tch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, CBattlePassManager::instance().GetPremiumBattlePassID());
-			CBattlePassManager::instance().BattlePassRequestOpen(tch, false);
-			tch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NOW_IS_ACTIVATED_PREMIUM_BATTLEPASS"));
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_CMDGM_ACTIVATE_PREMIUM_TO_PLAYER"), tch->GetName());
-		}
-		if (value == 0)
-		{
-			tch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, 0);
-			tch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_CMDGM_DEACTIVATE_PREMIUM_PLAYER"));
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_CMDGM_DEACTIVATE_PREMIUM_TO_PLAYER"), tch->GetName());
-		}
-	}
-	else
-	{
-		if (value == 1)
-		{
-			ch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, CBattlePassManager::instance().GetPremiumBattlePassID());
-			CBattlePassManager::instance().BattlePassRequestOpen(ch, false);
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NOW_IS_ACTIVATED_PREMIUM_BATTLEPASS_OWN"));
-		}
-		if (value == 0)
-		{
-			ch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, 0);
-			CBattlePassManager::instance().BattlePassRequestOpen(ch, false);
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_CMDGM_DEACTIVATE_PREMIUM_OWN"));
-		}
-	}
-}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-#include "growth_pet.h"
-
-const char* pet_set_fields[] = {
-	"level",
-	"evo",
-	"type",
-	"exp",
-	"iexp",
-	"hp",
-	"sp",
-	"def",
-	"itemevo",
-	"time",
-	"age",
-	"maxtime",
-	"\n",
-};
-
-ACMD(do_pet_set)
-{
-	char arg1[256], arg2[256];
-
-	int i, len;
-
-	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
-
-	if (!*arg1 || !*arg2)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: pet_set <field> <value>");
-		return;
-	}
-
-	if(!ch->GetActiveGrowthPet())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ONCE_PETI_CAGIR"));
-		return;
-	}
-
-	len = strlen(arg1);
-
-	for (i = 0; *(pet_set_fields[i]) != '\n'; i++)
-		if (!strncmp(arg1, pet_set_fields[i], len))
-			break;
-
-	switch (i)
-	{
-		case 0: // Level
-		{
-			int level = 0;
-			str_to_number(level, arg2);
-
-			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_PET_LEVEL, level, true);
-		}
-		break;
-
-		case 1: // Evolution
-		{
-			int evolution = 0;
-			str_to_number(evolution, arg2);
-
-			ch->GetActiveGrowthPet()->Evolve(evolution);
-		}
-		break;
-
-		case 2: // Type
-		{
-			int type = 0;
-			str_to_number(type, arg2);
-		}
-		break;
-
-		case 3: // EXP
-		{
-			int exp = 0;
-			str_to_number(exp, arg2);
-
-			ch->GetActiveGrowthPet()->RewardEXP(EXP_TYPE_MOB, exp);
-		}
-		break;
-
-		case 4: // Item EXP
-		{
-			int item_exp = 0;
-			str_to_number(item_exp, arg2);
-
-			ch->GetActiveGrowthPet()->RewardEXP(EXP_TYPE_ITEM, item_exp);
-		}
-		break;
-
-		case 5: // HP
-		{
-			int hp = 0;
-			str_to_number(hp, arg2);
-
-			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_PET_HP, hp, true);
-		}
-		break;
-
-		case 6: // SP
-		{
-			int sp = 0;
-			str_to_number(sp, arg2);
-
-			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_PET_SP, sp, true);
-		}
-		break;
-
-		case 7: // Def
-		{
-			int def = 0;
-			str_to_number(def, arg2);
-
-			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_PET_DEF_GRADE, def, true);
-		}
-		break;
-
-		case 8: // Evolution Items
-		{
-			int evolution = 0;
-			str_to_number(evolution, arg2);
-
-			if (!arPetEvolutionTable[evolution - 2].szEvolutionName)
-				return;
-
-			for (int i = 0; i < PET_EVOL_MAX_ITEM_COUNT; ++i)
-			{
-				std::pair<DWORD, WORD> itemPair = arPetEvolutionTable[evolution - 2].dwItems[i];
-				ch->AutoGiveItem(itemPair.first, itemPair.second);
-			}
-		}
-		break;
-		
-		case 9: // Time
-		{
-			int endtime = 0;
-			str_to_number(endtime, arg2);
-
-			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_DURATION, time(0) + endtime, true);
-			ch->GetActiveGrowthPet()->GetSummonItem()->SetSocket(0, time(0) + endtime);
-		}
-		break;
-
-		case 10: // Age
-		{
-			int age = 0;
-			str_to_number(age, arg2); // (Day count)
-			DWORD dwAge = time(0) - (age * 3600 * 24);
-			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_BIRTHDAY, dwAge, true);
-		}
-		break;
-		
-		case 11: // Max Time life
-		{
-			int max_time = 0;
-			str_to_number(max_time, arg2);
-			// DWORD maxTime = time(0) - (age * 3600 * 24);
-			// ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_BIRTHDAY, dwAge, true);
-			ch->ChatPacket(CHAT_TYPE_INFO, "OLD_Cur pet max life = %d", ch->GetActiveGrowthPet()->GetPetPoint(POINT_UPBRINGING_MAX_DURATION));
-			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_MAX_DURATION, max_time, true);
-			ch->ChatPacket(CHAT_TYPE_INFO, "NEW_Cur pet max life = %d", ch->GetActiveGrowthPet()->GetPetPoint(POINT_UPBRINGING_MAX_DURATION));
-		}
-		break;
-	}
-}
-#endif
+#include "stdafx.h"
+#include "utils.h"
+#include "config.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "item_manager.h"
+#include "sectree_manager.h"
+#include "mob_manager.h"
+#include "packet.h"
+#include "cmd.h"
+#include "regen.h"
+#include "guild.h"
+#include "guild_manager.h"
+#include "p2p.h"
+#include "buffer_manager.h"
+#include "fishing.h"
+#include "mining.h"
+#include "questmanager.h"
+#include "vector.h"
+#include "affect.h"
+#include "db.h"
+#include "priv_manager.h"
+#include "building.h"
+#include "battle.h"
+#include "arena.h"
+#include "start_position.h"
+#include "party.h"
+#include "monarch.h"
+#include "castle.h"
+#include "BattleArena.h"
+#include "xmas_event.h"
+#include "log.h"
+#include "pcbang.h"
+#include "threeway_war.h"
+#include "unique_item.h"
+#include "DragonSoul.h"
+#include "shop_manager.h"
+#include "OXEvent.h"
+#if defined(__DEFENSE_WAVE__)
+#	include "defense_wave.h"
+#endif
+#if defined(__EXTENDED_RELOAD__)
+#	include "mob_manager.h"
+#endif
+#if defined(__OFFLINE_SHOP__)
+#include "OfflineShop.h"
+#endif
+
+extern bool DropEvent_RefineBox_SetValue(const std::string& name, int value);
+
+// ADD_COMMAND_SLOW_STUN
+enum
+{
+	COMMANDAFFECT_STUN,
+	COMMANDAFFECT_SLOW,
+};
+
+void Command_ApplyAffect(LPCHARACTER ch, const char* argument, const char* affectName, int cmdAffect)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	sys_log(0, arg1);
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: %s <name>", affectName);
+		return;
+	}
+
+	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+	if (!tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s is not in same map", arg1);
+		return;
+	}
+
+	switch (cmdAffect)
+	{
+		case COMMANDAFFECT_STUN:
+			SkillAttackAffect(tch, 1000, IMMUNE_STUN, AFFECT_STUN, POINT_NONE, 0, AFF_STUN, 30, "GM_STUN");
+			break;
+		case COMMANDAFFECT_SLOW:
+			SkillAttackAffect(tch, 1000, IMMUNE_SLOW, AFFECT_SLOW, POINT_MOV_SPEED, -30, AFF_SLOW, 30, "GM_SLOW");
+			break;
+	}
+
+	sys_log(0, "%s %s", arg1, affectName);
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "%s %s", arg1, affectName);
+}
+// END_OF_ADD_COMMAND_SLOW_STUN
+
+ACMD(do_pcbang_update)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	unsigned long PCBangID = 0;
+
+	if (*arg1 == '\0')
+		PCBangID = 0;
+	else
+		str_to_number(PCBangID, arg1);
+
+	if (PCBangID == 0)
+	{
+		CPCBangManager::instance().RequestUpdateIPList(0);
+		ch->ChatPacket(CHAT_TYPE_INFO, "PCBang Info Update For All");
+	}
+	else
+	{
+		CPCBangManager::instance().RequestUpdateIPList(PCBangID);
+		ch->ChatPacket(CHAT_TYPE_INFO, "PCBang Info Update For %u", PCBangID);
+	}
+
+	TPacketPCBangUpdate packet;
+	packet.bHeader = HEADER_GG_PCBANG_UPDATE;
+	packet.ulPCBangID = PCBangID;
+
+	P2P_MANAGER::instance().Send(&packet, sizeof(TPacketPCBangUpdate));
+
+}
+
+ACMD(do_pcbang_check)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (CPCBangManager::instance().IsPCBangIP(arg1) == true)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s is a PCBang IP", arg1);
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s is not a PCBang IP", arg1);
+	}
+}
+
+ACMD(do_stun)
+{
+	Command_ApplyAffect(ch, argument, "stun", COMMANDAFFECT_STUN);
+}
+
+ACMD(do_slow)
+{
+	Command_ApplyAffect(ch, argument, "slow", COMMANDAFFECT_SLOW);
+}
+
+ACMD(do_transfer)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: transfer <name>");
+		return;
+	}
+
+	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+	if (!tch)
+	{
+		CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
+
+		if (pkCCI)
+		{
+			if (pkCCI->bChannel != g_bChannel)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, "Target is in %d channel (my channel %d)", pkCCI->bChannel, g_bChannel);
+				return;
+			}
+
+			TPacketGGTransfer pgg;
+
+			pgg.bHeader = HEADER_GG_TRANSFER;
+			strlcpy(pgg.szName, arg1, sizeof(pgg.szName));
+			pgg.lX = ch->GetX();
+			pgg.lY = ch->GetY();
+
+			P2P_MANAGER::instance().Send(&pgg, sizeof(TPacketGGTransfer));
+			ch->ChatPacket(CHAT_TYPE_INFO, "Transfer requested.");
+		}
+		else
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "There is no character(%s) by that name", arg1);
+			sys_log(0, "There is no character(%s) by that name", arg1);
+		}
+
+		return;
+	}
+
+	if (ch == tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Transfer me?!?");
+		return;
+	}
+
+	//tch->Show(ch->GetMapIndex(), ch->GetX(), ch->GetY(), ch->GetZ());
+	tch->WarpSet(ch->GetX(), ch->GetY(), ch->GetMapIndex());
+}
+
+ACMD(do_transfer_force)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: transfer_force <name>");
+		return;
+	}
+
+	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+	if (!tch)
+	{
+		CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
+
+		if (pkCCI)
+		{
+			TPacketGGTransfer pgg;
+
+			pgg.bHeader = HEADER_GG_TRANSFER;
+			strlcpy(pgg.szName, arg1, sizeof(pgg.szName));
+			pgg.lX = ch->GetX();
+			pgg.lY = ch->GetY();
+
+			P2P_MANAGER::instance().Send(&pgg, sizeof(TPacketGGTransfer));
+			ch->ChatPacket(CHAT_TYPE_INFO, "Transfer requested.");
+		}
+		else
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "There is no character(%s) by that name", arg1);
+			sys_log(0, "There is no character(%s) by that name", arg1);
+		}
+
+		return;
+	}
+
+	if (ch == tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Transfer me?!?");
+		return;
+	}
+
+	//tch->Show(ch->GetMapIndex(), ch->GetX(), ch->GetY(), ch->GetZ());
+	tch->WarpSet(ch->GetX(), ch->GetY(), ch->GetMapIndex());
+}
+
+// LUA_ADD_GOTO_INFO
+struct GotoInfo
+{
+	std::string st_name;
+
+	BYTE empire;
+	int mapIndex;
+	DWORD x, y;
+
+	GotoInfo()
+	{
+		st_name = "";
+		empire = 0;
+		mapIndex = 0;
+
+		x = 0;
+		y = 0;
+	}
+	GotoInfo(const GotoInfo& c_src)
+	{
+		__copy__(c_src);
+	}
+	void operator = (const GotoInfo& c_src)
+	{
+		__copy__(c_src);
+	}
+	void __copy__(const GotoInfo& c_src)
+	{
+		st_name = c_src.st_name;
+		empire = c_src.empire;
+		mapIndex = c_src.mapIndex;
+
+		x = c_src.x;
+		y = c_src.y;
+	}
+};
+
+static std::vector<GotoInfo> gs_vec_gotoInfo;
+
+void CHARACTER_AddGotoInfo(const std::string& c_st_name, BYTE empire, int mapIndex, DWORD x, DWORD y)
+{
+	GotoInfo newGotoInfo;
+	newGotoInfo.st_name = c_st_name;
+	newGotoInfo.empire = empire;
+	newGotoInfo.mapIndex = mapIndex;
+	newGotoInfo.x = x;
+	newGotoInfo.y = y;
+	gs_vec_gotoInfo.push_back(newGotoInfo);
+
+	sys_log(0, "AddGotoInfo(name=%s, empire=%d, mapIndex=%d, pos=(%d, %d))", c_st_name.c_str(), empire, mapIndex, x, y);
+}
+
+bool FindInString(const char* c_pszFind, const char* c_pszIn)
+{
+	const char* c = c_pszIn;
+	const char* p;
+
+	p = strchr(c, '|');
+
+	if (!p)
+		return (0 == strncasecmp(c_pszFind, c_pszIn, strlen(c_pszFind)));
+	else
+	{
+		char sz[64 + 1];
+
+		do
+		{
+			strlcpy(sz, c, MIN(sizeof(sz), (p - c) + 1));
+
+			if (!strncasecmp(c_pszFind, sz, strlen(c_pszFind)))
+				return true;
+
+			c = p + 1;
+		} while ((p = strchr(c, '|')));
+
+		strlcpy(sz, c, sizeof(sz));
+
+		if (!strncasecmp(c_pszFind, sz, strlen(c_pszFind)))
+			return true;
+	}
+
+	return false;
+}
+
+bool CHARACTER_GoToName(LPCHARACTER ch, BYTE empire, int mapIndex, const char* gotoName)
+{
+	std::vector<GotoInfo>::iterator i;
+	for (i = gs_vec_gotoInfo.begin(); i != gs_vec_gotoInfo.end(); ++i)
+	{
+		const GotoInfo& c_eachGotoInfo = *i;
+
+		if (mapIndex != 0)
+		{
+			if (mapIndex != c_eachGotoInfo.mapIndex)
+				continue;
+		}
+		else if (!FindInString(gotoName, c_eachGotoInfo.st_name.c_str()))
+			continue;
+
+		if (c_eachGotoInfo.empire == 0 || c_eachGotoInfo.empire == empire)
+		{
+			int x = c_eachGotoInfo.x * 100;
+			int y = c_eachGotoInfo.y * 100;
+
+			ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", x, y);
+			ch->WarpSet(x, y);
+			ch->Stop();
+			return true;
+		}
+	}
+	return false;
+}
+
+// END_OF_LUA_ADD_GOTO_INFO
+
+/*
+{
+	{ "A1|", 0, 1, 4693, 9642 },
+	{ "A3|岷", 0, 3, 3608, 8776 },
+
+	{ "B1|", 0, 21, 557, 1579 },
+	{ "B3|", 0, 23, 1385, 2349 },
+
+	{ "C1|", 0, 41, 9696, 2784 },
+	{ "C3|眉", 0, 43, 8731, 2426 },
+
+	// Snow
+	{ "Snow|綺", 1, 61, 4342, 2906 },
+	{ "Snow|綺", 2, 61, 3752, 1749 },
+	{ "Snow|綺", 3, 61, 4918, 1736 },
+
+	// Flame
+	{ "Flame|화|화", 1, 62, 5994, 7563 },
+	{ "Flame|화|화", 2, 62, 5978, 6222 },
+	{ "Flame|화|화", 3, 62, 7307, 6898 },
+
+	// Desert
+	{ "Desert|潁|潁", 1, 63, 2178, 6272 },
+	{ "Desert|潁|潁", 2, 63, 2219, 5027 },
+	{ "Desert|潁|潁", 3, 63, 3440, 5025 },
+
+	// Threeway
+	{ "Three|쨌", 1, 64, 4021, 6739 },
+	{ "Three|쨌", 2, 64, 2704, 7399 },
+	{ "Three|쨌", 3, 64, 3213, 8080 },
+
+	// 閨
+	{ "Milgyo|閨", 1, 65, 5536, 1436 },
+	{ "Milgyo|閨", 2, 65, 5536, 1436 },
+	{ "Milgyo|閨", 3, 65, 5536, 1436 },
+
+	// 타逃
+	{ "타逃", 1, 65, 5905, 1108 },
+	{ "타逃", 2, 65, 5905, 1108 },
+	{ "타逃", 3, 65, 5905, 1108 },
+
+	{ NULL, 0, 0, 0, 0 },
+};
+*/
+
+ACMD(do_goto)
+{
+	char arg1[256], arg2[256];
+	int x = 0, y = 0, z = 0;
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1 && !*arg2)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: goto <x meter> <y meter>");
+		return;
+	}
+
+	if (isnhdigit(*arg1) && isnhdigit(*arg2))
+	{
+		str_to_number(x, arg1);
+		str_to_number(y, arg2);
+
+		PIXEL_POSITION p;
+
+		if (SECTREE_MANAGER::instance().GetMapBasePosition(ch->GetX(), ch->GetY(), p))
+		{
+			x += p.x / 100;
+			y += p.y / 100;
+		}
+
+		ch->ChatPacket(CHAT_TYPE_INFO, "You goto ( %d, %d )", x, y);
+	}
+	else
+	{
+		int mapIndex = 0;
+		BYTE empire = 0;
+
+		if (*arg1 == '#')
+			str_to_number(mapIndex, (arg1 + 1));
+
+		if (*arg2 && isnhdigit(*arg2))
+		{
+			str_to_number(empire, arg2);
+			empire = MINMAX(1, empire, 3);
+		}
+		else
+			empire = ch->GetEmpire();
+
+		if (CHARACTER_GoToName(ch, empire, mapIndex, arg1))
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "Cannot find map command syntax: /goto <mapname> [empire]");
+			return;
+		}
+
+		return;
+
+		/*
+		int iMapIndex = 0;
+		for (int i = 0; aWarpInfo[i].c_pszName != NULL; ++i)
+		{
+			if (iMapIndex != 0)
+			{
+				if (iMapIndex != aWarpInfo[i].iMapIndex)
+					continue;
+			}
+			else if (!FindInString(arg1, aWarpInfo[i].c_pszName))
+				continue;
+
+			if (aWarpInfo[i].bEmpire == 0 || aWarpInfo[i].bEmpire == bEmpire)
+			{
+				x = aWarpInfo[i].x * 100;
+				y = aWarpInfo[i].y * 100;
+
+				ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", x, y);
+				ch->WarpSet(x, y);
+				ch->Stop();
+				return;
+			}
+		}
+		*/
+	}
+
+	x *= 100;
+	y *= 100;
+
+	ch->Show(ch->GetMapIndex(), x, y, z);
+	ch->Stop();
+}
+
+ACMD(do_warp)
+{
+	char arg1[256], arg2[256];
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: warp <character name> | <x meter> <y meter>");
+		return;
+	}
+
+	int x = 0, y = 0;
+
+	if (isnhdigit(*arg1) && isnhdigit(*arg2))
+	{
+		str_to_number(x, arg1);
+		str_to_number(y, arg2);
+	}
+	else
+	{
+		LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+
+		if (NULL == tch)
+		{
+			const CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
+
+			if (NULL != pkCCI)
+			{
+				if (pkCCI->bChannel != g_bChannel)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, "Target is in %d channel (my channel %d)", pkCCI->bChannel, g_bChannel);
+					return;
+				}
+
+				ch->WarpToPID(pkCCI->dwPID);
+			}
+			else
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, "There is no one by that name");
+			}
+
+			return;
+		}
+		else
+		{
+			x = tch->GetX() / 100;
+			y = tch->GetY() / 100;
+		}
+	}
+
+	x *= 100;
+	y *= 100;
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", x, y);
+	ch->WarpSet(x, y);
+	ch->Stop();
+}
+
+ACMD(do_warp_force)
+{
+	char arg1[256], arg2[256];
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: warp <character name> | <x meter> <y meter>");
+		return;
+	}
+
+	int x = 0, y = 0;
+
+	if (isnhdigit(*arg1) && isnhdigit(*arg2))
+	{
+		str_to_number(x, arg1);
+		str_to_number(y, arg2);
+	}
+	else
+	{
+		LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+
+		if (NULL == tch)
+		{
+			const CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
+
+			if (NULL != pkCCI)
+				ch->WarpToPID(pkCCI->dwPID, true /* bWarpForce */);
+			else
+				ch->ChatPacket(CHAT_TYPE_INFO, "There is no one by that name");
+
+			return;
+		}
+		else
+		{
+			x = tch->GetX() / 100;
+			y = tch->GetY() / 100;
+		}
+	}
+
+	x *= 100;
+	y *= 100;
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "You warp to ( %d, %d )", x, y);
+	ch->WarpSet(x, y);
+	ch->Stop();
+}
+
+ACMD(do_item)
+{
+	char arg1[256], arg2[256];
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: item <item vnum>");
+		return;
+	}
+
+	int iCount = 1;
+
+	if (*arg2)
+	{
+		str_to_number(iCount, arg2);
+		iCount = MINMAX(1, iCount, ITEM_MAX_COUNT);
+	}
+
+	DWORD dwVnum;
+
+	if (isnhdigit(*arg1))
+		str_to_number(dwVnum, arg1);
+	else
+	{
+		if (!ITEM_MANAGER::instance().GetVnum(arg1, dwVnum))
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "#%u item not exist by that vnum.", dwVnum);
+			return;
+		}
+	}
+
+	LPITEM item = ITEM_MANAGER::instance().CreateItem(dwVnum, iCount, 0, true);
+
+	if (item)
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+		{
+			int iEmptyPos = ch->GetEmptyDragonSoulInventory(item);
+
+			if (iEmptyPos != -1)
+			{
+				item->AddToCharacter(ch, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyPos));
+				LogManager::instance().ItemLog(ch, item, "GM", item->GetName());
+			}
+			else
+			{
+				M2_DESTROY_ITEM(item);
+				if (!ch->DragonSoul_IsQualified())
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Before you open the Cor Draconis, you have to complete the Dragon Stone quest and activate the Dragon Stone Alchemy."));
+				}
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough space in your inventory."));
+			}
+		}
+		else
+#endif
+		{
+			int iEmptyPos = ch->GetEmptyInventory(item->GetSize());
+
+			if (iEmptyPos != -1)
+			{
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+				item->AddToCharacter(ch, TItemPos(INVENTORY, iEmptyPos), true);
+#else
+				item->AddToCharacter(ch, TItemPos(INVENTORY, iEmptyPos));
+
+#endif
+				LogManager::instance().ItemLog(ch, item, "GM", item->GetName());
+			}
+			else
+			{
+				M2_DESTROY_ITEM(item);
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough space in your inventory."));
+			}
+		}
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "#%u item not exist by that vnum.", dwVnum);
+	}
+}
+
+ACMD(do_group_random)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: grrandom <group vnum>");
+		return;
+	}
+
+	DWORD dwVnum = 0;
+	str_to_number(dwVnum, arg1);
+	CHARACTER_MANAGER::instance().SpawnGroupGroup(dwVnum, ch->GetMapIndex(), ch->GetX() - 500, ch->GetY() - 500, ch->GetX() + 500, ch->GetY() + 500);
+}
+
+ACMD(do_group)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: group <group vnum>");
+		return;
+	}
+
+	DWORD dwVnum = 0;
+	str_to_number(dwVnum, arg1);
+
+	if (test_server)
+		sys_log(0, "COMMAND GROUP SPAWN %u at %u %u %u", dwVnum, ch->GetMapIndex(), ch->GetX(), ch->GetY());
+
+	CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, ch->GetMapIndex(), ch->GetX() - 500, ch->GetY() - 500, ch->GetX() + 500, ch->GetY() + 500);
+}
+
+ACMD(do_mob_coward)
+{
+	char arg1[256], arg2[256];
+	DWORD vnum = 0;
+	LPCHARACTER tch;
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mc <vnum>");
+		return;
+	}
+
+	const CMob* pkMob;
+
+	if (isdigit(*arg1))
+	{
+		str_to_number(vnum, arg1);
+
+		if ((pkMob = CMobManager::instance().Get(vnum)) == NULL)
+			vnum = 0;
+	}
+	else
+	{
+		pkMob = CMobManager::Instance().Get(arg1, true);
+
+		if (pkMob)
+			vnum = pkMob->m_table.dwVnum;
+	}
+
+	if (vnum == 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "No such mob by that vnum");
+		return;
+	}
+
+	int iCount = 0;
+
+	if (*arg2)
+		str_to_number(iCount, arg2);
+	else
+		iCount = 1;
+
+	iCount = MIN(20, iCount);
+
+	while (iCount--)
+	{
+		tch = CHARACTER_MANAGER::instance().SpawnMobRange(vnum,
+			ch->GetMapIndex(),
+			ch->GetX() - number(200, 750),
+			ch->GetY() - number(200, 750),
+			ch->GetX() + number(200, 750),
+			ch->GetY() + number(200, 750),
+			true,
+			pkMob->m_table.bType == CHAR_TYPE_STONE);
+		if (tch)
+			tch->SetCoward();
+	}
+}
+
+ACMD(do_mob_map)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: mm <vnum>");
+		return;
+	}
+
+	DWORD vnum = 0;
+	str_to_number(vnum, arg1);
+	LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRandomPosition(vnum, ch->GetMapIndex());
+
+	if (tch)
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s spawned in %dx%d", tch->GetName(), tch->GetX(), tch->GetY());
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, "Spawn failed.");
+}
+
+ACMD(do_mob_aggresive)
+{
+	char arg1[256], arg2[256];
+	DWORD vnum = 0;
+	LPCHARACTER tch;
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mob <mob vnum>");
+		return;
+	}
+
+	const CMob* pkMob;
+
+	if (isdigit(*arg1))
+	{
+		str_to_number(vnum, arg1);
+
+		if ((pkMob = CMobManager::instance().Get(vnum)) == NULL)
+			vnum = 0;
+	}
+	else
+	{
+		pkMob = CMobManager::Instance().Get(arg1, true);
+
+		if (pkMob)
+			vnum = pkMob->m_table.dwVnum;
+	}
+
+	if (vnum == 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "No such mob by that vnum");
+		return;
+	}
+
+	int iCount = 0;
+
+	if (*arg2)
+		str_to_number(iCount, arg2);
+	else
+		iCount = 1;
+
+	iCount = MIN(20, iCount);
+
+	while (iCount--)
+	{
+		tch = CHARACTER_MANAGER::instance().SpawnMobRange(vnum,
+			ch->GetMapIndex(),
+			ch->GetX() - number(200, 750),
+			ch->GetY() - number(200, 750),
+			ch->GetX() + number(200, 750),
+			ch->GetY() + number(200, 750),
+			true,
+			pkMob->m_table.bType == CHAR_TYPE_STONE);
+		if (tch)
+			tch->SetAggressive();
+	}
+}
+
+ACMD(do_mob)
+{
+	char arg1[256], arg2[256];
+	DWORD vnum = 0;
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mob <mob vnum>");
+		return;
+	}
+
+	const CMob* pkMob = NULL;
+
+	if (isnhdigit(*arg1))
+	{
+		str_to_number(vnum, arg1);
+
+		if ((pkMob = CMobManager::instance().Get(vnum)) == NULL)
+			vnum = 0;
+	}
+	else
+	{
+		pkMob = CMobManager::Instance().Get(arg1, true);
+
+		if (pkMob)
+			vnum = pkMob->m_table.dwVnum;
+	}
+
+	if (vnum == 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "No such mob by that vnum");
+		return;
+	}
+
+	int iCount = 0;
+
+	if (*arg2)
+		str_to_number(iCount, arg2);
+	else
+		iCount = 1;
+
+	if (test_server)
+		iCount = MIN(40, iCount);
+	else
+		iCount = MIN(20, iCount);
+
+	while (iCount--)
+	{
+		CHARACTER_MANAGER::instance().SpawnMobRange(vnum,
+			ch->GetMapIndex(),
+			ch->GetX() - number(200, 750),
+			ch->GetY() - number(200, 750),
+			ch->GetX() + number(200, 750),
+			ch->GetY() + number(200, 750),
+			true,
+			pkMob->m_table.bType == CHAR_TYPE_STONE);
+	}
+}
+
+ACMD(do_mob_ld)
+{
+	char arg1[256], arg2[256], arg3[256], arg4[256];
+	DWORD vnum = 0;
+
+	two_arguments(two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2)), arg3, sizeof(arg3), arg4, sizeof(arg4));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mob <mob vnum>");
+		return;
+	}
+
+	const CMob* pkMob = NULL;
+
+	if (isnhdigit(*arg1))
+	{
+		str_to_number(vnum, arg1);
+
+		if ((pkMob = CMobManager::instance().Get(vnum)) == NULL)
+			vnum = 0;
+	}
+	else
+	{
+		pkMob = CMobManager::Instance().Get(arg1, true);
+
+		if (pkMob)
+			vnum = pkMob->m_table.dwVnum;
+	}
+
+	if (vnum == 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "No such mob by that vnum");
+		return;
+	}
+
+	int dir = 1;
+	long x, y;
+
+	if (*arg2)
+		str_to_number(x, arg2);
+	if (*arg3)
+		str_to_number(y, arg3);
+	if (*arg4)
+		str_to_number(dir, arg4);
+
+	CHARACTER_MANAGER::instance().SpawnMob(vnum,
+		ch->GetMapIndex(),
+		x * 100,
+		y * 100,
+		ch->GetZ(),
+		pkMob->m_table.bType == CHAR_TYPE_STONE,
+		dir);
+}
+
+struct FuncPurge
+{
+	LPCHARACTER m_pkGM;
+	bool m_bAll;
+
+	FuncPurge(LPCHARACTER ch) : m_pkGM(ch), m_bAll(false)
+	{
+	}
+
+	void operator () (LPENTITY ent)
+	{
+		if (!ent->IsType(ENTITY_CHARACTER))
+			return;
+
+		LPCHARACTER pkChr = (LPCHARACTER)ent;
+
+		int iDist = DISTANCE_APPROX(pkChr->GetX() - m_pkGM->GetX(), pkChr->GetY() - m_pkGM->GetY());
+
+		if (!m_bAll && iDist >= 1000) // 10 鵑 獵 孤 purge  苛쨈.
+			return;
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+		if (CGuildDragonLairManager::Instance().IsUnique(pkChr))
+			return;
+#endif
+
+#if defined(__DEFENSE_WAVE__)
+		if (pkChr->GetDefenseWave() && pkChr->GetDefenseWave()->IsUnique(pkChr))
+			return;
+#endif
+
+		sys_log(0, "PURGE: %s %d", pkChr->GetName(), iDist);
+
+		// todo : check instances
+		if (pkChr->IsNPC() && pkChr->GetRider() == NULL
+#if defined(__PET_SYSTEM__)
+			&& !pkChr->IsPet()
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+				/*
+					UPBRINGING/BAG item should not be deleted in any way by default.
+					If you have other functions that allow you to delete items,
+					either block destroying UPBRINGING/BAG items or add the following
+					code.
+				*/
+				if (item->GetType() == ITEM_PET)
+				{
+					if (item->GetSubType() == PET_UPBRINGING || item->GetSubType() == PET_BAG)
+						CGrowthPetManager::Instance().DeleteGrowthPet(item->GetSocket(0), true);
+				}
+#endif
+			)
+		{
+			M2_DESTROY_CHARACTER(pkChr);
+		}
+	}
+};
+
+ACMD(do_purge)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	FuncPurge func(ch);
+
+	if (*arg1 && !strcmp(arg1, "all"))
+		func.m_bAll = true;
+
+	LPSECTREE sectree = ch->GetSectree();
+	if (sectree) // #431
+		sectree->ForEachAround(func);
+	else
+		sys_err("PURGE_ERROR.NULL_SECTREE(mapIndex=%d, pos=(%d, %d)", ch->GetMapIndex(), ch->GetX(), ch->GetY());
+}
+
+static void ipurge_window(const LPCHARACTER& ch, BYTE window_type)
+{
+	if (NULL == ch)
+		return;
+
+	WORD cell = 0;
+	LPITEM item = nullptr;
+
+	if (INVENTORY == window_type)
+	{
+		for (cell = 0; cell < INVENTORY_MAX_NUM; ++cell)
+		{
+			if ((item = ch->GetInventoryItem(cell)))
+			{
+				if (item->isLocked())
+					continue;
+
+#ifdef __GROWTH_PET_SYSTEM__
+					/*
+						UPBRINGING/BAG item should not be deleted in any way by default.
+						If you have other functions that allow you to delete items,
+						either block destroying UPBRINGING/BAG items or add the following
+						code.
+					*/
+					if (item->GetType() == ITEM_PET)
+					{
+						if (item->GetSubType() == PET_UPBRINGING || item->GetSubType() == PET_BAG)
+							CGrowthPetManager::Instance().DeleteGrowthPet(item->GetSocket(0), true);
+					}
+#endif
+
+				ITEM_MANAGER::instance().RemoveItem(item, "PURGE");
+				ch->SyncQuickslot(SLOT_TYPE_INVENTORY, cell, WORD_MAX);
+			}
+		}
+	}
+	else if (EQUIPMENT == window_type)
+	{
+		for (cell = 0; cell < EQUIPMENT_MAX_NUM; ++cell)
+			if ((item = ch->GetEquipmentItem(cell)))
+				ITEM_MANAGER::instance().RemoveItem(item, "PURGE");
+	}
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	else if (DRAGON_SOUL_INVENTORY == window_type)
+	{
+		for (cell = 0; cell < DRAGON_SOUL_INVENTORY_MAX_NUM; ++cell)
+			if ((item = ch->GetItem(TItemPos(DRAGON_SOUL_INVENTORY, cell))))
+				ITEM_MANAGER::instance().RemoveItem(item, "PURGE");
+	}
+#endif
+	else if (BELT_INVENTORY == window_type)
+	{
+		for (cell = 0; cell < BELT_INVENTORY_SLOT_COUNT; ++cell)
+		{
+			if ((item = ch->GetBeltInventoryItem(cell)))
+			{
+				if (item->isLocked())
+					continue;
+
+				ITEM_MANAGER::instance().RemoveItem(item, "PURGE");
+			}
+		}
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Unknown window.");
+	}
+}
+
+ACMD(do_item_purge)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+	if (!*arg1)
+		goto USAGE;
+
+	if (!strcmp(arg1, "all"))
+	{
+		ipurge_window(ch, INVENTORY);
+		ipurge_window(ch, EQUIPMENT);
+		ipurge_window(ch, DRAGON_SOUL_INVENTORY);
+		ipurge_window(ch, BELT_INVENTORY);
+		ch->ChatPacket(CHAT_TYPE_INFO, "all items cleared");
+	}
+	else if (!strcmp(arg1, "inven"))
+	{
+		ipurge_window(ch, INVENTORY);
+		ch->ChatPacket(CHAT_TYPE_INFO, "inventory items cleared");
+	}
+	else if (!strcmp(arg1, "equip"))
+	{
+		ipurge_window(ch, EQUIPMENT);
+		ch->ChatPacket(CHAT_TYPE_INFO, "equipment items cleared!");
+	}
+	else if (!strcmp(arg1, "ds"))
+	{
+		ipurge_window(ch, DRAGON_SOUL_INVENTORY);
+		ch->ChatPacket(CHAT_TYPE_INFO, "dragon soul items cleared!");
+	}
+	else if (!strcmp(arg1, "belt"))
+	{
+		ipurge_window(ch, BELT_INVENTORY);
+		ch->ChatPacket(CHAT_TYPE_INFO, "belt items cleared!");
+	}
+	else
+		goto USAGE;
+
+	return;
+
+USAGE:
+	ch->ChatPacket(CHAT_TYPE_INFO, "usage : ipurge <window>");
+	ch->ChatPacket(CHAT_TYPE_INFO, "		<window> inven, equip, ds, belt");
+}
+
+ACMD(do_state)
+{
+	char arg1[256];
+	LPCHARACTER tch;
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (*arg1)
+	{
+		if (arg1[0] == '#')
+		{
+			tch = CHARACTER_MANAGER::instance().Find(strtoul(arg1 + 1, NULL, 10));
+		}
+		else
+		{
+			LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
+
+			if (!d)
+				tch = NULL;
+			else
+				tch = d->GetCharacter();
+		}
+	}
+	else
+		tch = ch;
+
+	if (!tch)
+		return;
+
+	char buf[256];
+
+	snprintf(buf, sizeof(buf), "%s's State: ", tch->GetName());
+
+	if (tch->IsPosition(POS_FIGHTING))
+		strlcat(buf, "Battle", sizeof(buf));
+	else if (tch->IsPosition(POS_DEAD))
+		strlcat(buf, "Dead", sizeof(buf));
+	else
+		strlcat(buf, "Standing", sizeof(buf));
+
+	if (ch->GetShop())
+		strlcat(buf, ", Shop", sizeof(buf));
+
+	if (ch->GetExchange())
+		strlcat(buf, ", Exchange", sizeof(buf));
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "%s", buf);
+
+	int len;
+	len = snprintf(buf, sizeof(buf), "Coordinate %ldx%ld (%ldx%ld)",
+		tch->GetX(), tch->GetY(), tch->GetX() / 100, tch->GetY() / 100);
+
+	if (len < 0 || len >= (int)sizeof(buf))
+		len = sizeof(buf) - 1;
+
+	LPSECTREE pSec = SECTREE_MANAGER::instance().Get(tch->GetMapIndex(), tch->GetX(), tch->GetY());
+
+	if (pSec)
+	{
+		TMapSetting& map_setting = SECTREE_MANAGER::instance().GetMap(tch->GetMapIndex())->m_setting;
+		snprintf(buf + len, sizeof(buf) - len, " MapIndex %ld Attribute %08X Local Position (%ld x %ld)",
+			tch->GetMapIndex(), pSec->GetAttribute(tch->GetX(), tch->GetY()), (tch->GetX() - map_setting.iBaseX) / 100, (tch->GetY() - map_setting.iBaseY) / 100);
+	}
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "%s", buf);
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "LEV %d", tch->GetLevel());
+	ch->ChatPacket(CHAT_TYPE_INFO, "HP %d/%d", tch->GetHP(), tch->GetMaxHP());
+	ch->ChatPacket(CHAT_TYPE_INFO, "SP %d/%d", tch->GetSP(), tch->GetMaxSP());
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "SUNGMA_STR %d SUNGMA_HP %d SUNGMA_MOVE %d SUNGMA_IMMUNE %d",
+		tch->GetPoint(POINT_SUNGMA_STR),
+		tch->GetPoint(POINT_SUNGMA_HP),
+		tch->GetPoint(POINT_SUNGMA_MOVE),
+		tch->GetPoint(POINT_SUNGMA_IMMUNE)
+	);
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "ATT_SPD %d/%d (LIMIT) MOVE_SPD %d/%d (LIMIT) CAST_SPD %d",
+		tch->GetPoint(POINT_ATT_SPEED), tch->GetLimitPoint(POINT_ATT_SPEED),
+		tch->GetPoint(POINT_MOV_SPEED), tch->GetLimitPoint(POINT_MOV_SPEED),
+		tch->GetPoint(POINT_CASTING_SPEED));
+	ch->ChatPacket(CHAT_TYPE_INFO, "ATT %d MAGIC_ATT %d CRIT %d%% PENE %d%% ATT_BONUS %d%%",
+		tch->GetPoint(POINT_ATT_GRADE),
+		tch->GetPoint(POINT_MAGIC_ATT_GRADE),
+		tch->GetPoint(POINT_CRITICAL_PCT),
+		tch->GetPoint(POINT_PENETRATE_PCT),
+		tch->GetPoint(POINT_ATT_BONUS));
+	ch->ChatPacket(CHAT_TYPE_INFO, "DEF %d MAGIC_DEF %d BLOCK %d%% DODGE %d%% DEF_BONUS %d%%",
+		tch->GetPoint(POINT_DEF_GRADE),
+		tch->GetPoint(POINT_MAGIC_DEF_GRADE),
+		tch->GetPoint(POINT_BLOCK),
+		tch->GetPoint(POINT_DODGE),
+		tch->GetPoint(POINT_DEF_BONUS));
+	ch->ChatPacket(CHAT_TYPE_INFO, "RESISTANCES:");
+	ch->ChatPacket(CHAT_TYPE_INFO, "   WARR:%3d%% ASAS:%3d%% SURA:%3d%% SHAM:%3d%% WOLF:%3d%%"
+		, tch->GetPoint(POINT_RESIST_WARRIOR)
+		, tch->GetPoint(POINT_RESIST_ASSASSIN)
+		, tch->GetPoint(POINT_RESIST_SURA)
+		, tch->GetPoint(POINT_RESIST_SHAMAN)
+		, tch->GetPoint(POINT_RESIST_WOLFMAN)
+	);
+	ch->ChatPacket(CHAT_TYPE_INFO, "   SWORD:%3d%% THSWORD:%3d%% DAGGER:%3d%% BELL:%3d%% FAN:%3d%% BOW:%3d%% CLAW:%3d%%"
+		, tch->GetPoint(POINT_RESIST_SWORD)
+		, tch->GetPoint(POINT_RESIST_TWOHAND)
+		, tch->GetPoint(POINT_RESIST_DAGGER)
+		, tch->GetPoint(POINT_RESIST_BELL)
+		, tch->GetPoint(POINT_RESIST_FAN)
+		, tch->GetPoint(POINT_RESIST_BOW)
+		, tch->GetPoint(POINT_RESIST_CLAW)
+	);
+	ch->ChatPacket(CHAT_TYPE_INFO, "   FIRE:%3d%% ELEC:%3d%% MAGIC:%3d%% WIND:%3d%% CRIT:%3d%% PENE:%3d%%",
+		tch->GetPoint(POINT_RESIST_FIRE),
+		tch->GetPoint(POINT_RESIST_ELEC),
+		tch->GetPoint(POINT_RESIST_MAGIC),
+		tch->GetPoint(POINT_RESIST_WIND),
+		tch->GetPoint(POINT_RESIST_CRITICAL),
+		tch->GetPoint(POINT_RESIST_PENETRATE));
+	ch->ChatPacket(CHAT_TYPE_INFO, "   ICE:%3d%% EARTH:%3d%% DARK:%3d%%",
+		tch->GetPoint(POINT_RESIST_ICE),
+		tch->GetPoint(POINT_RESIST_EARTH),
+		tch->GetPoint(POINT_RESIST_DARK));
+
+#if defined(__MAGIC_REDUCTION__)
+	ch->ChatPacket(CHAT_TYPE_INFO, "   MAGIC_REDUCT:%3d%%", tch->GetPoint(POINT_RESIST_MAGIC_REDUCTION));
+#endif
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "MALL:");
+	ch->ChatPacket(CHAT_TYPE_INFO, "   ATT:%3d%% DEF:%3d%% EXP:%3d%% ITEMx%d GOLDx%d",
+		tch->GetPoint(POINT_MALL_ATTBONUS),
+		tch->GetPoint(POINT_MALL_DEFBONUS),
+		tch->GetPoint(POINT_MALL_EXPBONUS),
+		tch->GetPoint(POINT_MALL_ITEMBONUS) / 10,
+		tch->GetPoint(POINT_MALL_GOLDBONUS) / 10);
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "BONUS:");
+	ch->ChatPacket(CHAT_TYPE_INFO, "   SKILL:%3d%% NORMAL:%3d%% SKILL_DEF:%3d%% NORMAL_DEF:%3d%%",
+		tch->GetPoint(POINT_SKILL_DAMAGE_BONUS),
+		tch->GetPoint(POINT_NORMAL_HIT_DAMAGE_BONUS),
+		tch->GetPoint(POINT_SKILL_DEFEND_BONUS),
+		tch->GetPoint(POINT_NORMAL_HIT_DEFEND_BONUS));
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "   HUMAN:%3d%% ANIMAL:%3d%% ORC:%3d%% MILGYO:%3d%% UNDEAD:%3d%%",
+		tch->GetPoint(POINT_ATTBONUS_HUMAN),
+		tch->GetPoint(POINT_ATTBONUS_ANIMAL),
+		tch->GetPoint(POINT_ATTBONUS_ORC),
+		tch->GetPoint(POINT_ATTBONUS_MILGYO),
+		tch->GetPoint(POINT_ATTBONUS_UNDEAD));
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "   DEVIL:%3d%% INSECT:%3d%% FIRE:%3d%% ICE:%3d%% DESERT:%3d%%",
+		tch->GetPoint(POINT_ATTBONUS_DEVIL),
+		tch->GetPoint(POINT_ATTBONUS_INSECT),
+		tch->GetPoint(POINT_ATTBONUS_FIRE),
+		tch->GetPoint(POINT_ATTBONUS_ICE),
+		tch->GetPoint(POINT_ATTBONUS_DESERT));
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "   TREE:%3d%% MONSTER:%3d%% STONE:%3d%%",
+		tch->GetPoint(POINT_ATTBONUS_TREE),
+		tch->GetPoint(POINT_ATTBONUS_MONSTER),
+		tch->GetPoint(POINT_ATTBONUS_STONE));
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "   WARR:%3d%% ASAS:%3d%% SURA:%3d%% SHAM:%3d%%"
+		" WOLF:%3d%%"
+		, tch->GetPoint(POINT_ATTBONUS_WARRIOR)
+		, tch->GetPoint(POINT_ATTBONUS_ASSASSIN)
+		, tch->GetPoint(POINT_ATTBONUS_SURA)
+		, tch->GetPoint(POINT_ATTBONUS_SHAMAN)
+		, tch->GetPoint(POINT_ATTBONUS_WOLFMAN)
+	);
+
+#if defined(__ELEMENT_SYSTEM__)
+	ch->ChatPacket(CHAT_TYPE_INFO, "   HUMAN:%3d%%", tch->GetPoint(POINT_RESIST_HUMAN));
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "ENCHANTS:");
+	ch->ChatPacket(CHAT_TYPE_INFO, "   ELECT:%3d%% FIRE:%3d%% ICE:%3d%% WIND:%3d%% EARTH:%3d%% DARK:%3d%%",
+		tch->GetPoint(POINT_ENCHANT_ELECT),
+		tch->GetPoint(POINT_ENCHANT_FIRE),
+		tch->GetPoint(POINT_ENCHANT_ICE),
+		tch->GetPoint(POINT_ENCHANT_WIND),
+		tch->GetPoint(POINT_ENCHANT_EARTH),
+		tch->GetPoint(POINT_ENCHANT_DARK));
+	ch->ChatPacket(CHAT_TYPE_INFO, "   ZODIAC:%3d%%", tch->GetPoint(POINT_ATTBONUS_CZ));
+#endif
+
+	for (int i = 0; i < MAX_PRIV_NUM; ++i)
+		if (CPrivManager::instance().GetPriv(tch, i))
+		{
+			int iByEmpire = CPrivManager::instance().GetPrivByEmpire(tch->GetEmpire(), i);
+			int iByGuild = 0;
+
+			if (tch->GetGuild())
+				iByGuild = CPrivManager::instance().GetPrivByGuild(tch->GetGuild()->GetID(), i);
+
+			int iByPlayer = CPrivManager::instance().GetPrivByCharacter(tch->GetPlayerID(), i);
+
+			if (iByEmpire)
+				ch->ChatPacket(CHAT_TYPE_INFO, "%s for empire : %d", c_apszPrivNames[i], iByEmpire);
+
+			if (iByGuild)
+				ch->ChatPacket(CHAT_TYPE_INFO, "%s for guild : %d", c_apszPrivNames[i], iByGuild);
+
+			if (iByPlayer)
+				ch->ChatPacket(CHAT_TYPE_INFO, "%s for player : %d", c_apszPrivNames[i], iByPlayer);
+		}
+}
+
+struct notice_packet_func
+{
+	const char* m_str;
+	const bool m_big;
+
+	notice_packet_func(const char* str, const bool big) : m_str(str), m_big(big)
+	{
+	}
+
+	void operator () (LPDESC d)
+	{
+		if (!d->GetCharacter())
+			return;
+
+		d->GetCharacter()->ChatPacket(m_big ? CHAT_TYPE_BIG_NOTICE : CHAT_TYPE_NOTICE, "%s", m_str);
+	}
+};
+
+#if defined(__DUNGEON_RENEWAL__)
+struct party_notice_packet_func
+{
+	const LPPARTY m_pParty;
+	const char* m_szBuf;
+	party_notice_packet_func(const LPPARTY c_pParty, const char* c_szBuf) : m_pParty(c_pParty), m_szBuf(c_szBuf) {}
+	void operator () (LPDESC d)
+	{
+		const LPCHARACTER& pChar = d->GetCharacter();
+		if (pChar == nullptr)
+			return;
+
+		if (pChar->GetParty() != m_pParty)
+			return;
+
+		pChar->ChatPacket(CHAT_TYPE_PARTY, "%s", m_szBuf);
+	}
+};
+#endif
+
+struct monarch_notice_packet_func
+{
+	const char* m_str;
+	BYTE m_bEmpire;
+
+	monarch_notice_packet_func(BYTE bEmpire, const char* str) : m_str(str), m_bEmpire(bEmpire)
+	{
+	}
+
+	void operator () (LPDESC d)
+	{
+		if (!d->GetCharacter())
+			return;
+
+		if (m_bEmpire == d->GetCharacter()->GetEmpire())
+		{
+			d->GetCharacter()->ChatPacket(CHAT_TYPE_NOTICE, "%s", m_str);
+		}
+	}
+};
+
+void SendNotice(const char* c_pszBuf, const bool c_bBigFont)
+{
+	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
+	std::for_each(c_ref_set.begin(), c_ref_set.end(), notice_packet_func(c_pszBuf, c_bBigFont));
+}
+
+void SendMonarchNotice(BYTE bEmpire, const char* c_pszBuf)
+{
+	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
+	std::for_each(c_ref_set.begin(), c_ref_set.end(), monarch_notice_packet_func(bEmpire, c_pszBuf));
+}
+
+#if defined(__DUNGEON_RENEWAL__)
+void SendPartyNotice(const LPPARTY c_pParty, const char* c_pszBuf)
+{
+	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
+	std::for_each(c_ref_set.begin(), c_ref_set.end(), party_notice_packet_func(c_pParty, c_pszBuf));
+}
+#endif
+
+struct notice_map_packet_func
+{
+	const char* m_str;
+	int m_mapIndex;
+	bool m_bBigFont;
+
+	notice_map_packet_func(const char* str, int idx, bool bBigFont) : m_str(str), m_mapIndex(idx), m_bBigFont(bBigFont)
+	{
+	}
+
+	void operator() (LPDESC d)
+	{
+		if (d->GetCharacter() == NULL) return;
+		if (d->GetCharacter()->GetMapIndex() != m_mapIndex) return;
+
+		d->GetCharacter()->ChatPacket(m_bBigFont == true ? CHAT_TYPE_BIG_NOTICE : CHAT_TYPE_NOTICE, "%s", m_str);
+	}
+};
+
+void SendNoticeMap(const char* c_pszBuf, int nMapIndex, bool bBigFont)
+{
+	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
+	std::for_each(c_ref_set.begin(), c_ref_set.end(), notice_map_packet_func(c_pszBuf, nMapIndex, bBigFont));
+}
+
+#if defined(__OX_RENEWAL__)
+struct control_notice_packet_func
+{
+	const char* m_str;
+	int m_mapIndex;
+	control_notice_packet_func(const char* str, int idx) : m_str(str), m_mapIndex(idx) {}
+
+	void operator() (LPDESC d)
+	{
+		if (d->GetCharacter() == NULL) return;
+		if (d->GetCharacter()->GetMapIndex() != m_mapIndex) return;
+		d->GetCharacter()->ChatPacket(CHAT_TYPE_BIG_CONTROL_NOTICE, "%s", m_str);
+	}
+};
+
+void SendControlNoticeMap(const char* c_pszBuf, int nMapIndex)
+{
+	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
+	std::for_each(c_ref_set.begin(), c_ref_set.end(), control_notice_packet_func(c_pszBuf, nMapIndex));
+}
+#endif
+
+struct log_packet_func
+{
+	const char* m_str;
+
+	log_packet_func(const char* str) : m_str(str)
+	{
+	}
+
+	void operator () (LPDESC d)
+	{
+		if (!d->GetCharacter())
+			return;
+
+		if (d->GetCharacter()->GetGMLevel() > GM_PLAYER)
+			d->GetCharacter()->ChatPacket(CHAT_TYPE_NOTICE, "%s", m_str);
+	}
+};
+
+void SendLog(const char* c_pszBuf)
+{
+	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
+	std::for_each(c_ref_set.begin(), c_ref_set.end(), log_packet_func(c_pszBuf));
+}
+
+void BroadcastNotice(const char* c_pszBuf, const bool c_bBigFont)
+{
+	TPacketGGNotice p;
+	p.bHeader = HEADER_GG_NOTICE;
+	p.lSize = strlen(c_pszBuf) + 1;
+	p.bBigFont = c_bBigFont;
+
+	TEMP_BUFFER buf;
+	buf.write(&p, sizeof(p));
+	buf.write(c_pszBuf, p.lSize);
+
+	P2P_MANAGER::instance().Send(buf.read_peek(), buf.size()); // HEADER_GG_NOTICE
+
+	SendNotice(c_pszBuf, c_bBigFont);
+}
+
+void BroadcastMonarchNotice(BYTE bEmpire, const char* c_pszBuf)
+{
+	TPacketGGMonarchNotice p;
+	p.bHeader = HEADER_GG_MONARCH_NOTICE;
+	p.bEmpire = bEmpire;
+	p.lSize = strlen(c_pszBuf) + 1;
+
+	TEMP_BUFFER buf;
+	buf.write(&p, sizeof(p));
+	buf.write(c_pszBuf, p.lSize);
+
+	P2P_MANAGER::instance().Send(buf.read_peek(), buf.size());
+
+	SendMonarchNotice(bEmpire, c_pszBuf);
+}
+
+ACMD(do_notice)
+{
+	char buf[CHAT_MAX_LEN + 1];
+	snprintf(buf, sizeof(buf), "%s : %s", ch->GetName(), argument);
+	BroadcastNotice(buf);
+}
+
+ACMD(do_map_notice)
+{
+	char buf[CHAT_MAX_LEN + 1];
+	snprintf(buf, sizeof(buf), "%s : %s", ch->GetName(), argument);
+	SendNoticeMap(buf, ch->GetMapIndex(), false);
+}
+
+ACMD(do_big_notice)
+{
+	BroadcastNotice(argument, true);
+}
+
+ACMD(do_monarch_notice)
+{
+	if (ch->IsMonarch() == TRUE)
+	{
+		BroadcastMonarchNotice(ch->GetEmpire(), argument);
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("寧   都求"));
+	}
+}
+
+ACMD(do_who)
+{
+	int iTotal;
+	int* paiEmpireUserCount;
+	int iLocal;
+
+	DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "Total [%d] %d / %d / %d (this server %d)",
+		iTotal, paiEmpireUserCount[1], paiEmpireUserCount[2], paiEmpireUserCount[3], iLocal);
+}
+
+ACMD(do_online)
+{
+	/// Phase 1 - Count Local Core
+	const DESC_MANAGER::DESC_SET& c_set_desc = DESC_MANAGER::instance().GetClientSet();
+	DESC_MANAGER::DESC_SET::const_iterator it = c_set_desc.begin();
+
+	DWORD dwLoginCount = 0;
+	while (it != c_set_desc.end())
+	{
+		LPDESC d = *(it++);
+		if (d->GetCharacter())
+			++dwLoginCount; // count login count in core
+	}
+	/// Phase 2 - Count Peer PID Connections
+	dwLoginCount = dwLoginCount + (int)P2P_MANAGER::instance().GetPIDCount();
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "Total Online %d ", dwLoginCount);
+}
+
+class user_func
+{
+public:
+	LPCHARACTER m_ch;
+	static int count;
+	static char str[128];
+	static int str_len;
+
+	user_func()
+		: m_ch(NULL)
+	{}
+
+	void initialize(LPCHARACTER ch)
+	{
+		m_ch = ch;
+		str_len = 0;
+		count = 0;
+		str[0] = '\0';
+	}
+
+	void operator () (LPDESC d)
+	{
+		if (!d->GetCharacter())
+			return;
+
+		int len = snprintf(str + str_len, sizeof(str) - str_len, "%-16s ", d->GetCharacter()->GetName());
+
+		if (len < 0 || len >= (int)sizeof(str) - str_len)
+			len = (sizeof(str) - str_len) - 1;
+
+		str_len += len;
+		++count;
+
+		if (!(count % 4))
+		{
+			m_ch->ChatPacket(CHAT_TYPE_INFO, str);
+
+			str[0] = '\0';
+			str_len = 0;
+		}
+	}
+};
+
+int user_func::count = 0;
+char user_func::str[128] = { 0, };
+int user_func::str_len = 0;
+
+ACMD(do_user)
+{
+	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
+	user_func func;
+
+	func.initialize(ch);
+	std::for_each(c_ref_set.begin(), c_ref_set.end(), func);
+
+	if (func.count % 4)
+		ch->ChatPacket(CHAT_TYPE_INFO, func.str);
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "Total %d", func.count);
+}
+
+ACMD(do_disconnect)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "ex) /dc <player name>");
+		return;
+	}
+
+	LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
+	LPCHARACTER tch = d ? d->GetCharacter() : NULL;
+
+	if (!tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s: no such a player.", arg1);
+		return;
+	}
+
+	if (tch == ch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "cannot disconnect myself");
+		return;
+	}
+
+	DESC_MANAGER::instance().DestroyDesc(d);
+}
+
+ACMD(do_kill)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "ex) /kill <player name>");
+		return;
+	}
+
+	LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
+	LPCHARACTER tch = d ? d->GetCharacter() : NULL;
+
+	if (!tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s: no such a player", arg1);
+		return;
+	}
+
+	tch->Dead();
+}
+
+ACMD(do_poison)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "ex) /poison <player name>");
+		return;
+	}
+
+	LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
+	LPCHARACTER tch = d ? d->GetCharacter() : NULL;
+
+	if (!tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s: no such a player", arg1);
+		return;
+	}
+
+	tch->AttackedByPoison(NULL);
+}
+
+ACMD(do_bleeding)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "ex) /bleeding <player name>");
+		return;
+	}
+
+	LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
+	LPCHARACTER tch = d ? d->GetCharacter() : NULL;
+
+	if (!tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s: no such a player", arg1);
+		return;
+	}
+
+	tch->AttackedByBleeding(NULL);
+}
+
+ACMD(do_fire)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "ex) /fire <player name>");
+		return;
+	}
+
+	LPDESC d = DESC_MANAGER::instance().FindByCharacterName(arg1);
+	LPCHARACTER tch = d ? d->GetCharacter() : NULL;
+
+	if (!tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s: no such a player", arg1);
+		return;
+	}
+
+	tch->AttackedByFire(NULL, number(1, 5), 5);
+}
+
+#define MISC 0
+#define BINARY 1
+#define NUMBER 2
+
+const struct set_struct
+{
+	const char key;
+	const char* cmd;
+	const char type;
+} set_fields[] = {
+	{ SET_CMD_GOLD, "gold", NUMBER },
+	{ SET_CMD_RACE, "race", BINARY },
+	{ SET_CMD_SEX, "sex", BINARY },
+	{ SET_CMD_EXP, "exp", NUMBER },
+	{ SET_CMD_MAX_HP, "max_hp", NUMBER },
+	{ SET_CMD_MAX_SP, "max_sp", NUMBER },
+	{ SET_CMD_SKILL, "skill", NUMBER },
+	{ SET_CMD_ALIGN, "align", NUMBER },
+#if defined(__CHEQUE_SYSTEM__)
+	{ SET_CMD_CHEQUE, "cheque", NUMBER },
+#endif
+#if defined(__GEM_SYSTEM__)
+	{ SET_CMD_GEM, "gem", NUMBER },
+#endif
+#if defined(__EXPRESSING_EMOTIONS__)
+	{ SET_CMD_ACTION, "action", NUMBER },
+#endif
+	{ SET_CMD_MAX_NUN, "\n", MISC }
+};
+
+ACMD(do_set)
+{
+	char arg1[256], arg2[256], arg3[256];
+
+	LPCHARACTER tch = NULL;
+
+	int i, len;
+	const char* line;
+
+	line = two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+	one_argument(line, arg3, sizeof(arg3));
+
+	if (!*arg1 || !*arg2 || !*arg3)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: set <name> <field> <value>");
+		return;
+	}
+
+	tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+	if (!tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s not exist", arg1);
+		return;
+	}
+
+	len = strlen(arg2);
+
+	for (i = 0; *(set_fields[i].cmd) != '\n'; i++)
+		if (!strncmp(arg2, set_fields[i].cmd, len))
+			break;
+
+	switch (i)
+	{
+		case SET_CMD_GOLD:
+		{
+			POINT_VALUE gold = 0;
+			safe_str_to_number(gold, arg3);
+
+			int before_gold = tch->GetGold();
+			gold = MINMAXLL(0, (long long)before_gold + gold, GOLD_MAX - 1);
+
+			tch->SetPoint(POINT_GOLD, gold);
+			tch->SetGold(gold);
+			tch->UpdatePointsPacket(POINT_GOLD, gold);
+
+			int after_gold = tch->GetGold();
+
+			if (0 == after_gold && 0 != before_gold)
+				LogManager::instance().CharLog(tch, gold, "ZERO_GOLD", "GM");
+
+			if (before_gold != after_gold)
+			{
+				int gold_diff = after_gold - before_gold;
+				if (gold_diff < 0)
+					DBManager::instance().SendMoneyLog(MONEY_LOG_MISC, 3, -gold_diff);
+				else
+					DBManager::instance().SendMoneyLog(MONEY_LOG_MISC, 3, gold_diff);
+			}
+		}
+		break;
+
+		case SET_CMD_RACE:
+		{
+			BYTE race;
+			str_to_number(race, arg3);
+
+			if (race < 0 || race >= MAIN_RACE_MAX_NUM)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_WARRIOR_M = 0");
+				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_ASSASSIN_W = 1");
+				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_SURA_M = 2");
+				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_SHAMAN_W = 3");
+				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_WARRIOR_W = 4");
+				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_ASSASSIN_M = 5");
+				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_SURA_W = 6");
+				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_SHAMAN_M = 7");
+#if defined(__WOLFMAN_CHARACTER__) && !defined(__DISABLE_WOLFMAN_CREATION__)
+				ch->ChatPacket(CHAT_TYPE_INFO, "RACE_WOLFMAN_M = 8");
+#endif
+				return;
+			}
+
+			tch->SetRace(race);
+
+			tch->ClearSkill();
+			tch->ClearSubSkill();
+			tch->SetSkillGroup(0);
+
+			tch->SetPolymorph(101);
+			tch->SetPolymorph(0);
+		}
+		break;
+
+		case SET_CMD_SEX:
+		{
+			BYTE sex = 0;
+			str_to_number(sex, arg3);
+
+			if (sex < SEX_MALE || sex > SEX_FEMALE)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, "SEX_MALE = 0");
+				ch->ChatPacket(CHAT_TYPE_INFO, "SEX_FEMALE = 1");
+				return;
+			}
+
+			BYTE race = 0;
+			switch (tch->GetJob())
+			{
+				case JOB_WARRIOR:
+					race = (sex == SEX_MALE) ? MAIN_RACE_WARRIOR_M : MAIN_RACE_WARRIOR_W;
+					break;
+				case JOB_ASSASSIN:
+					race = (sex == SEX_MALE) ? MAIN_RACE_ASSASSIN_M : MAIN_RACE_ASSASSIN_W;
+					break;
+				case JOB_SURA:
+					race = (sex == SEX_MALE) ? MAIN_RACE_SURA_M : MAIN_RACE_SURA_W;
+					break;
+				case JOB_SHAMAN:
+					race = (sex == SEX_MALE) ? MAIN_RACE_SHAMAN_M : MAIN_RACE_SHAMAN_W;
+					break;
+#if defined(__WOLFMAN_CHARACTER__)
+				case JOB_WOLFMAN:
+					race = (sex == SEX_MALE) ? MAIN_RACE_WOLFMAN_M : MAIN_RACE_WOLFMAN_M;
+					break;
+#endif
+			}
+
+			tch->SetRace(race);
+
+			tch->SetPolymorph(101);
+			tch->SetPolymorph(0);
+		}
+		break;
+
+		case SET_CMD_EXP:
+		{
+			POINT_VALUE amount = 0;
+			safe_str_to_number(amount, arg3);
+
+			amount = MINMAXLL(POINT_MIN, amount, POINT_MAX);
+
+#if defined(__CONQUEROR_LEVEL__)
+			if (tch->GetConquerorLevel() > 0)
+				tch->PointChange(POINT_CONQUEROR_EXP, amount, true);
+			else
+				tch->PointChange(POINT_EXP, amount, true);
+#else
+			tch->PointChange(POINT_EXP, amount, true);
+#endif
+		}
+		break;
+
+		case SET_CMD_MAX_HP:
+		{
+			POINT_VALUE amount = 0;
+			safe_str_to_number(amount, arg3);
+
+			amount = MINMAXLL(POINT_MIN, amount, POINT_MAX);
+
+			tch->PointChange(POINT_MAX_HP, amount, true);
+		}
+		break;
+
+		case SET_CMD_MAX_SP:
+		{
+			POINT_VALUE amount = 0;
+			safe_str_to_number(amount, arg3);
+
+			amount = MINMAXLL(POINT_MIN, amount, POINT_MAX);
+
+			tch->PointChange(POINT_MAX_SP, amount, true);
+		}
+		break;
+
+		case SET_CMD_SKILL: // active skill point
+		{
+			POINT_VALUE amount = 0;
+			safe_str_to_number(amount, arg3);
+
+			amount = MINMAXLL(POINT_MIN, amount, POINT_MAX);
+
+			tch->PointChange(POINT_SKILL, amount, true);
+		}
+		break;
+
+		case SET_CMD_ALIGN:
+		{
+			int amount = 0;
+			safe_str_to_number(amount, arg3);
+
+			amount = MINMAXLL(INT_MIN, amount, INT_MAX);
+
+			tch->UpdateAlignment(amount - tch->GetRealAlignment());
+		}
+		break;
+
+#if defined(__CHEQUE_SYSTEM__)
+		case SET_CMD_CHEQUE:
+		{
+			POINT_VALUE cheque = 0;
+			safe_str_to_number(cheque, arg3);
+
+			int before_cheque = tch->GetCheque();
+			cheque = MINMAXLL(0, (long long)before_cheque + cheque, CHEQUE_MAX);
+
+			tch->SetPoint(POINT_CHEQUE, cheque);
+			tch->SetCheque(cheque);
+			tch->UpdatePointsPacket(POINT_CHEQUE, cheque);
+
+			int after_cheque = tch->GetCheque();
+			if (0 == after_cheque && 0 != before_cheque)
+				LogManager::instance().CharLog(tch, cheque, "ZERO_CHEQUE", "GM");
+
+			if (before_cheque != after_cheque)
+			{
+				int cheque_diff = after_cheque - before_cheque;
+				if (cheque_diff < 0)
+					DBManager::instance().SendMoneyLog(MONEY_LOG_MISC, 3, 0, -cheque_diff);
+				else
+					DBManager::instance().SendMoneyLog(MONEY_LOG_MISC, 3, 0, cheque_diff);
+			}
+		}
+		break;
+#endif
+
+#if defined(__GEM_SYSTEM__)
+		case SET_CMD_GEM:
+		{
+			POINT_VALUE gem = 0;
+			safe_str_to_number(gem, arg3);
+
+			int before_gem = tch->GetGem();
+			gem = MINMAXLL(0, (long long)before_gem + gem, GEM_MAX);
+
+			tch->SetPoint(POINT_GEM, gem);
+			tch->SetGem(gem);
+			tch->UpdatePointsPacket(POINT_GEM, gem);
+
+			int after_gem = tch->GetGem();
+			if (0 == after_gem && 0 != before_gem)
+				LogManager::instance().CharLog(tch, gem, "ZERO_GEM", "GM");
+		}
+		break;
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+		case SET_CMD_ACTION:
+		{
+			int emote_idx = 0;
+			safe_str_to_number(emote_idx, arg3);
+
+			emote_idx = MINMAXLL(0, emote_idx, INT_MAX);
+
+			tch->AddEmote(emote_idx);
+		}
+		break;
+#endif
+	}
+
+	if (set_fields[i].type == NUMBER)
+	{
+		long long amount = 0;
+		safe_str_to_number(amount, arg3);
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s's %s set to [%lld]", tch->GetName(), set_fields[i].cmd, amount);
+	}
+}
+
+ACMD(do_reset)
+{
+	ch->PointChange(POINT_HP, ch->GetMaxHP() - ch->GetHP());
+	ch->PointChange(POINT_SP, ch->GetMaxSP() - ch->GetSP());
+	ch->Save();
+}
+
+ACMD(do_advance)
+{
+	char arg1[256], arg2[256];
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1 || !*arg2)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: advance <name> <level>");
+		return;
+	}
+
+	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+
+	if (!tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s not exist", arg1);
+		return;
+	}
+
+	int level = 0;
+	str_to_number(level, arg2);
+
+	tch->ResetPoint(MINMAX(1, level, PLAYER_MAX_LEVEL_CONST));
+	tch->ResetExp();
+}
+
+ACMD(do_respawn)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (*arg1 && !strcasecmp(arg1, "all"))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Respaw everywhere");
+		regen_reset(0, 0);
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Respaw around");
+		regen_reset(ch->GetX(), ch->GetY());
+	}
+}
+
+ACMD(do_safebox_size)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	int size = 0;
+
+	if (*arg1)
+		str_to_number(size, arg1);
+
+	if (size > 3 || size < 0)
+		size = 0;
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "Safebox size set to %d", size);
+	ch->ChangeSafeboxSize(size);
+}
+
+ACMD(do_makeguild)
+{
+	if (ch->GetGuild())
+		return;
+
+	CGuildManager& gm = CGuildManager::instance();
+
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	TGuildCreateParameter cp;
+	memset(&cp, 0, sizeof(cp));
+
+	cp.master = ch;
+	strlcpy(cp.name, arg1, sizeof(cp.name));
+
+	if (!check_name(cp.name))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   見 都求."));
+		return;
+	}
+
+	gm.CreateGuild(cp);
+	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("(%s) 弱 퓸求. [擔]", cp.name));
+}
+
+ACMD(do_deleteguild)
+{
+	if (ch->GetGuild())
+		ch->GetGuild()->RequestDisband(ch->GetPlayerID());
+}
+
+ACMD(do_greset)
+{
+	if (ch->GetGuild())
+		ch->GetGuild()->Reset();
+}
+
+// REFINE_ROD_HACK_BUG_FIX
+ACMD(do_refine_rod)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	BYTE cell = 0;
+	str_to_number(cell, arg1);
+	LPITEM item = ch->GetInventoryItem(cell);
+	if (item)
+		fishing::RealRefineRod(ch, item);
+}
+// END_OF_REFINE_ROD_HACK_BUG_FIX
+
+// REFINE_PICK
+ACMD(do_refine_pick)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	BYTE cell = 0;
+	str_to_number(cell, arg1);
+	LPITEM item = ch->GetInventoryItem(cell);
+	if (item)
+	{
+		mining::CHEAT_MAX_PICK(ch, item);
+		mining::RealRefinePick(ch, item);
+	}
+}
+
+ACMD(do_max_pick)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	BYTE cell = 0;
+	str_to_number(cell, arg1);
+	LPITEM item = ch->GetInventoryItem(cell);
+	if (item)
+	{
+		mining::CHEAT_MAX_PICK(ch, item);
+	}
+}
+// END_OF_REFINE_PICK
+
+ACMD(do_fishing_simul)
+{
+	char arg1[256];
+	char arg2[256];
+	char arg3[256];
+	argument = one_argument(argument, arg1, sizeof(arg1));
+	two_arguments(argument, arg2, sizeof(arg2), arg3, sizeof(arg3));
+
+	int count = 1000;
+	int prob_idx = 0;
+	int level = 100;
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "Usage: fishing_simul <level> <prob index> <count>");
+
+	if (*arg1)
+		str_to_number(level, arg1);
+
+	if (*arg2)
+		str_to_number(prob_idx, arg2);
+
+	if (*arg3)
+		str_to_number(count, arg3);
+
+	fishing::Simulation(level, count, prob_idx, ch);
+}
+
+ACMD(do_invisibility)
+{
+	if (ch->IsAffectFlag(AFF_INVISIBILITY))
+	{
+		ch->RemoveAffect(AFFECT_INVISIBILITY);
+		ch->EffectPacket(30);
+	}
+	else
+	{
+		ch->AddAffect(AFFECT_INVISIBILITY, POINT_NONE, 0, AFF_INVISIBILITY, INFINITE_AFFECT_DURATION, 0, true);
+	}
+}
+
+ACMD(do_event_flag)
+{
+	char arg1[256];
+	char arg2[256];
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!(*arg1) || !(*arg2))
+		return;
+
+	int value = 0;
+	str_to_number(value, arg2);
+
+	if (!strcmp(arg1, "mob_item") ||
+		!strcmp(arg1, "mob_exp") ||
+		!strcmp(arg1, "mob_gold") ||
+		!strcmp(arg1, "mob_dam") ||
+		!strcmp(arg1, "mob_gold_pct") ||
+		!strcmp(arg1, "mob_item_buyer") ||
+		!strcmp(arg1, "mob_exp_buyer") ||
+		!strcmp(arg1, "mob_gold_buyer") ||
+		!strcmp(arg1, "mob_gold_pct_buyer")
+		)
+		value = MINMAX(0, value, 1000);
+
+	//quest::CQuestManager::instance().SetEventFlag(arg1, atoi(arg2));
+	quest::CQuestManager::instance().RequestSetEventFlag(arg1, value);
+	ch->ChatPacket(CHAT_TYPE_INFO, "RequestSetEventFlag %s %d", arg1, value);
+	sys_log(0, "RequestSetEventFlag %s %d", arg1, value);
+}
+
+ACMD(do_get_event_flag)
+{
+	quest::CQuestManager::instance().SendEventFlagList(ch);
+}
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+ACMD(do_guild_event_flag)
+{
+	char arg1[256];
+	char arg2[256];
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!(*arg1) || !(*arg2))
+		return;
+
+	int value = 0;
+	str_to_number(value, arg2);
+
+	LPGUILD g = ch->GetGuild();
+	if (g == nullptr)
+		return;
+
+	CGuildManager::Instance().RequestSetEventFlag(g->GetID(), arg1, value);
+}
+
+ACMD(do_get_guild_event_flag)
+{
+	CGuildManager::Instance().SendGuildEventFlagList(ch);
+}
+#endif
+
+ACMD(do_private)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: private <map index>");
+		return;
+	}
+
+	long lMapIndex;
+	long map_index = 0;
+	str_to_number(map_index, arg1);
+	if ((lMapIndex = SECTREE_MANAGER::instance().CreatePrivateMap(map_index)))
+	{
+		ch->SaveExitLocation();
+
+		LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(lMapIndex);
+		ch->WarpSet(pkSectreeMap->m_setting.posSpawn.x, pkSectreeMap->m_setting.posSpawn.y, lMapIndex);
+	}
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, "Can't find map by index %d", map_index);
+}
+
+ACMD(do_qf)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+		return;
+
+	quest::PC* pPC = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
+	std::string questname = pPC->GetCurrentQuestName();
+
+	if (!questname.empty())
+	{
+		int value = quest::CQuestManager::Instance().GetQuestStateIndex(questname, arg1);
+
+		pPC->SetFlag(questname + ".__status", value);
+		pPC->ClearTimer();
+
+		quest::PC::QuestInfoIterator it = pPC->quest_begin();
+		unsigned int questindex = quest::CQuestManager::instance().GetQuestIndexByName(questname);
+
+		while (it != pPC->quest_end())
+		{
+			if (it->first == questindex)
+			{
+				it->second.st = value;
+				break;
+			}
+
+			++it;
+		}
+
+		ch->ChatPacket(CHAT_TYPE_INFO, "setting quest state flag %s %s %d", questname.c_str(), arg1, value);
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "setting quest state flag failed");
+	}
+}
+
+LPCHARACTER chHori, chForge, chLib, chTemple, chTraining, chTree, chPortal, chBall;
+
+ACMD(do_b1)
+{
+	// 호 478 579
+	chHori = CHARACTER_MANAGER::instance().SpawnMobRange(14017, ch->GetMapIndex(), 304222, 742858, 304222, 742858, true, false);
+	chHori->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_BUILDING_CONSTRUCTION_SMALL, 65535, 0, true);
+	chHori->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+
+	for (int i = 0; i < 30; ++i)
+	{
+		int rot = number(0, 359);
+		float fx, fy;
+		GetDeltaByDegree(rot, 800, &fx, &fy);
+
+		LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRange(number(701, 706),
+			ch->GetMapIndex(),
+			304222 + (int)fx,
+			742858 + (int)fy,
+			304222 + (int)fx,
+			742858 + (int)fy,
+			true,
+			false);
+		tch->SetAggressive();
+	}
+
+	for (int i = 0; i < 5; ++i)
+	{
+		int rot = number(0, 359);
+		float fx, fy;
+		GetDeltaByDegree(rot, 800, &fx, &fy);
+
+		LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRange(8009,
+			ch->GetMapIndex(),
+			304222 + (int)fx,
+			742858 + (int)fy,
+			304222 + (int)fx,
+			742858 + (int)fy,
+			true,
+			false);
+		tch->SetAggressive();
+	}
+}
+
+ACMD(do_b2)
+{
+	chHori->RemoveAffect(AFFECT_DUNGEON_UNIQUE);
+}
+
+ACMD(do_b3)
+{
+	//  492 547
+	chForge = CHARACTER_MANAGER::instance().SpawnMobRange(14003, ch->GetMapIndex(), 307500, 746300, 307500, 746300, true, false);
+	chForge->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+	// 탑 509 589 -> 
+	chLib = CHARACTER_MANAGER::instance().SpawnMobRange(14007, ch->GetMapIndex(), 307900, 744500, 307900, 744500, true, false);
+	chLib->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+	//  513 606 -> 퓰
+	chTemple = CHARACTER_MANAGER::instance().SpawnMobRange(14004, ch->GetMapIndex(), 307700, 741600, 307700, 741600, true, false);
+	chTemple->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+	//  490 625
+	chTraining = CHARACTER_MANAGER::instance().SpawnMobRange(14010, ch->GetMapIndex(), 307100, 739500, 307100, 739500, true, false);
+	chTraining->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+	//  466 614
+	chTree = CHARACTER_MANAGER::instance().SpawnMobRange(14013, ch->GetMapIndex(), 300800, 741600, 300800, 741600, true, false);
+	chTree->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+	// 탈 439 615
+	chPortal = CHARACTER_MANAGER::instance().SpawnMobRange(14001, ch->GetMapIndex(), 300900, 744500, 300900, 744500, true, false);
+	chPortal->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+	//  436 600
+	chBall = CHARACTER_MANAGER::instance().SpawnMobRange(14012, ch->GetMapIndex(), 302500, 746600, 302500, 746600, true, false);
+	chBall->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+}
+
+ACMD(do_b4)
+{
+	chLib->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_BUILDING_UPGRADE, 65535, 0, true);
+
+	for (int i = 0; i < 30; ++i)
+	{
+		int rot = number(0, 359);
+		float fx, fy;
+		GetDeltaByDegree(rot, 1200, &fx, &fy);
+
+		LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRange(number(701, 706),
+			ch->GetMapIndex(),
+			307900 + (int)fx,
+			744500 + (int)fy,
+			307900 + (int)fx,
+			744500 + (int)fy,
+			true,
+			false);
+		tch->SetAggressive();
+	}
+
+	for (int i = 0; i < 5; ++i)
+	{
+		int rot = number(0, 359);
+		float fx, fy;
+		GetDeltaByDegree(rot, 1200, &fx, &fy);
+
+		LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRange(8009,
+			ch->GetMapIndex(),
+			307900 + (int)fx,
+			744500 + (int)fy,
+			307900 + (int)fx,
+			744500 + (int)fy,
+			true,
+			false);
+		tch->SetAggressive();
+	}
+
+}
+
+ACMD(do_b5)
+{
+	M2_DESTROY_CHARACTER(chLib);
+	//chHori->RemoveAffect(AFFECT_DUNGEON_UNIQUE);
+	chLib = CHARACTER_MANAGER::instance().SpawnMobRange(14008, ch->GetMapIndex(), 307900, 744500, 307900, 744500, true, false);
+	chLib->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+}
+
+ACMD(do_b6)
+{
+	chLib->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_BUILDING_UPGRADE, 65535, 0, true);
+}
+ACMD(do_b7)
+{
+	M2_DESTROY_CHARACTER(chLib);
+	//chHori->RemoveAffect(AFFECT_DUNGEON_UNIQUE);
+	chLib = CHARACTER_MANAGER::instance().SpawnMobRange(14009, ch->GetMapIndex(), 307900, 744500, 307900, 744500, true, false);
+	chLib->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+}
+
+ACMD(do_book)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	CSkillProto* pkProto;
+
+	if (isnhdigit(*arg1))
+	{
+		DWORD vnum = 0;
+		str_to_number(vnum, arg1);
+		pkProto = CSkillManager::instance().Get(vnum);
+	}
+	else
+		pkProto = CSkillManager::instance().Get(arg1);
+
+	if (!pkProto)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "There is no such a skill.");
+		return;
+	}
+
+	LPITEM item = ch->AutoGiveItem(ITEM_SKILLBOOK_VNUM, 1, false, false);
+	item->SetSocket(0, pkProto->dwVnum);
+}
+
+ACMD(do_setskillother)
+{
+	char arg1[256], arg2[256], arg3[256];
+	argument = two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+	one_argument(argument, arg3, sizeof(arg3));
+
+	if (!*arg1 || !*arg2 || !*arg3 || !isdigit(*arg3))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: setskillother <target> <skillname> <lev>");
+		return;
+	}
+
+	LPCHARACTER tch;
+
+	tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+
+	if (!tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "There is no such character.");
+		return;
+	}
+
+	CSkillProto* pk;
+
+	if (isdigit(*arg2))
+	{
+		DWORD vnum = 0;
+		str_to_number(vnum, arg2);
+		pk = CSkillManager::instance().Get(vnum);
+	}
+	else
+		pk = CSkillManager::instance().Get(arg2);
+
+	if (!pk)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "No such a skill by that name.");
+		return;
+	}
+
+	BYTE level = 0;
+	str_to_number(level, arg3);
+	tch->SetSkillLevel(pk->dwVnum, level);
+	tch->ComputePoints();
+	tch->SkillLevelPacket();
+}
+
+ACMD(do_setskill)
+{
+	char arg1[256], arg2[256];
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1 || !*arg2 || !isdigit(*arg2))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: setskill <name> <lev>");
+		return;
+	}
+
+	CSkillProto* pk;
+
+	if (isdigit(*arg1))
+	{
+		DWORD vnum = 0;
+		str_to_number(vnum, arg1);
+		pk = CSkillManager::instance().Get(vnum);
+	}
+
+	else
+		pk = CSkillManager::instance().Get(arg1);
+
+	if (!pk)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "No such a skill by that name.");
+		return;
+	}
+
+	BYTE level = 0;
+	str_to_number(level, arg2);
+	ch->SetSkillLevel(pk->dwVnum, level);
+	ch->ComputePoints();
+	ch->SkillLevelPacket();
+}
+
+ACMD(do_set_skill_point)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	int skill_point = 0;
+	if (*arg1)
+		str_to_number(skill_point, arg1);
+
+	ch->SetRealPoint(POINT_SKILL, skill_point);
+	ch->SetPoint(POINT_SKILL, ch->GetRealPoint(POINT_SKILL));
+	ch->PointChange(POINT_SKILL, 0);
+}
+
+ACMD(do_set_skill_group)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	int skill_group = 0;
+	if (*arg1)
+		str_to_number(skill_group, arg1);
+
+	ch->SetSkillGroup(skill_group);
+
+	ch->ClearSkill();
+	ch->ChatPacket(CHAT_TYPE_INFO, "skill group to %d.", skill_group);
+}
+
+ACMD(do_reload)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+	const int FILE_NAME_LEN = 256;
+
+	if (*arg1)
+	{
+#if defined(__EXTENDED_RELOAD__)
+		struct s_cmd_data { std::string file_name, base_path; };
+		std::unordered_map<std::string, s_cmd_data> cmd_map = {
+			{ "mob_drop_item", { "mob_drop_item.txt", LocaleService_GetBasePath() } },
+			{ "special_item_group", { "special_item_group.txt", LocaleService_GetBasePath() } },
+			{ "group", { "group.txt", LocaleService_GetBasePath() } },
+			{ "group_group", { "group_group.txt", LocaleService_GetBasePath() } },
+#if defined(__SHOPEX_RENEWAL__)
+			{ "shop_table_ex", { "shop_table_ex.txt", LocaleService_GetBasePath() } },
+#endif
+#if defined(__SET_ITEM__)
+			{ "set_item_table", { "set_item_table.txt", LocaleService_GetBasePath() } },
+#endif
+#if defined(__GEM_SHOP__)
+			{ "new_world", { "new_world.txt", LocaleService_GetMapPath() } },
+#endif
+			{ "pet_block_index", { "pet_block_index.txt", LocaleService_GetMapPath() } },
+			{ "mount_block_index", { "mount_block_index.txt", LocaleService_GetMapPath() } },
+#if defined(__SUMMER_EVENT_ROULETTE__)
+			{ "roulette_table", { "roulette_table.txt", LocaleService_GetMapPath() } },
+#endif
+		};
+
+		if (cmd_map.find(arg1) != cmd_map.end())
+		{
+			char szFileName[FILE_NAME_LEN];
+			snprintf(szFileName, sizeof(szFileName), "%s/%s",
+				cmd_map[arg1].base_path.c_str(), cmd_map[arg1].file_name.c_str());
+
+			if (strcasecmp(arg1, "mob_drop_item") == 0)
+			{
+				if (ITEM_MANAGER::instance().ReloadMobDropItemGroup(szFileName))
+					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
+				return;
+			}
+
+			if (strcasecmp(arg1, "special_item_group") == 0)
+			{
+				if (ITEM_MANAGER::instance().ReloadSpecialItemGroup(szFileName))
+					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
+				return;
+			}
+
+			if (strcasecmp(arg1, "group") == 0)
+			{
+				if (CMobManager::Instance().LoadGroup(szFileName, true))
+					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
+				return;
+			}
+
+			if (strcasecmp(arg1, "group_group") == 0)
+			{
+				if (CMobManager::Instance().LoadGroupGroup(szFileName))
+					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
+				return;
+			}
+
+#if defined(__SHOPEX_RENEWAL__)
+			if (strcasecmp(arg1, "shop_table_ex") == 0)
+			{
+				if (CShopManager::instance().ReadShopTableEx(szFileName))
+					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
+				return;
+			}
+#endif
+
+#if defined(__SET_ITEM__)
+			if (strcasecmp(arg1, "set_item_table") == 0)
+			{
+				if (ITEM_MANAGER::instance().LoadSetItemTable(szFileName))
+					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
+				return;
+			}
+#endif
+
+#if defined(__GEM_SHOP__)
+			if (strcasecmp(arg1, "gem_shop_table") == 0)
+			{
+				if (ITEM_MANAGER::instance().ReadGemShopItemGroup(szFileName))
+					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
+				return;
+			}
+#endif
+
+#if defined(__CONQUEROR_LEVEL__)
+			if (strcasecmp(arg1, "new_world") == 0)
+			{
+				if (SECTREE_MANAGER::Instance().LoadNewWorldMapIndexFile(szFileName))
+					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
+				return;
+			}
+#endif
+
+			if (strcasecmp(arg1, "pet_block_index") == 0)
+			{
+				if (SECTREE_MANAGER::instance().LoadBlockFilterMapIndexFile(SECTREE_MANAGER::PET_BLOCK_MAP_INDEX))
+					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
+				return;
+			}
+
+			if (strcasecmp(arg1, "mount_block_index") == 0)
+			{
+				if (SECTREE_MANAGER::instance().LoadBlockFilterMapIndexFile(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX))
+					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
+				return;
+			}
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+			if (strcasecmp(arg1, "roulette_table") == 0)
+			{
+				if (CRouletteManager::Instance().ReadRouletteTableFile(szFileName))
+					ch->ChatPacket(CHAT_TYPE_INFO, "Reloading %s", cmd_map[arg1].file_name.c_str());
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, "Failed to reload %s", cmd_map[arg1].file_name.c_str());
+				return;
+			}
+#endif
+		}
+#endif
+
+		switch (LOWER(*arg1))
+		{
+			case 'u':
+				ch->ChatPacket(CHAT_TYPE_INFO, "Reloading state_user_count.");
+				LoadStateUserCount();
+				break;
+
+			case 'p':
+				ch->ChatPacket(CHAT_TYPE_INFO, "Reloading prototype tables,");
+				db_clientdesc->DBPacket(HEADER_GD_RELOAD_PROTO, 0, NULL, 0);
+				break;
+
+			case 's':
+				ch->ChatPacket(CHAT_TYPE_INFO, "Reloading notice string.");
+				DBManager::instance().LoadDBString();
+				break;
+
+			case 'q':
+				ch->ChatPacket(CHAT_TYPE_INFO, "Reloading quest.");
+				quest::CQuestManager::instance().Reload();
+				break;
+
+			case 'f':
+				fishing::Initialize();
+				break;
+
+				// RELOAD_ADMIN
+			case 'a':
+				ch->ChatPacket(CHAT_TYPE_INFO, "Reloading Admin infomation.");
+				db_clientdesc->DBPacket(HEADER_GD_RELOAD_ADMIN, 0, NULL, 0);
+				sys_log(0, "Reloading admin infomation.");
+				break;
+				// END_RELOAD_ADMIN
+
+			case 'c': // Cube
+			{
+				//  關 磯.
+#if defined(__CUBE_RENEWAL__)
+				CCubeManager::Instance().Initialize();
+#else
+				Cube_init();
+#endif
+			}
+			break;
+		}
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Reloading state_user_count.");
+		LoadStateUserCount();
+
+		ch->ChatPacket(CHAT_TYPE_INFO, "Reloading prototype tables,");
+		db_clientdesc->DBPacket(HEADER_GD_RELOAD_PROTO, 0, NULL, 0);
+
+		ch->ChatPacket(CHAT_TYPE_INFO, "Reloading notice string.");
+		DBManager::instance().LoadDBString();
+	}
+}
+
+ACMD(do_cooltime)
+{
+	ch->DisableCooltime();
+}
+
+ACMD(do_level)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: level <level>");
+		return;
+	}
+
+	int level = 0;
+	str_to_number(level, arg1);
+
+	ch->ResetPoint(MINMAX(1, level, PLAYER_MAX_LEVEL_CONST));
+	ch->ResetExp();
+
+	ch->ClearSkill();
+	ch->ClearSubSkill();
+}
+
+ACMD(do_gwlist)
+{
+	ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("   都求"));
+	CGuildManager::instance().ShowGuildWarList(ch);
+}
+
+ACMD(do_stop_guild_war)
+{
+	char arg1[256], arg2[256];
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1 || !*arg2)
+		return;
+
+	int id1 = 0, id2 = 0;
+
+	str_to_number(id1, arg1);
+	str_to_number(id2, arg2);
+
+	if (!id1 || !id2)
+		return;
+
+	if (id1 > id2)
+	{
+		std::swap(id1, id2);
+	}
+
+	ch->ChatPacket(CHAT_TYPE_TALKING, "%d %d", id1, id2);
+	CGuildManager::instance().RequestEndWar(id1, id2);
+}
+
+ACMD(do_cancel_guild_war)
+{
+	char arg1[256], arg2[256];
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	int id1 = 0, id2 = 0;
+	str_to_number(id1, arg1);
+	str_to_number(id2, arg2);
+
+	if (id1 > id2)
+		std::swap(id1, id2);
+
+	CGuildManager::instance().RequestCancelWar(id1, id2);
+}
+
+ACMD(do_guild_state)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	CGuild* pGuild = CGuildManager::instance().FindGuildByName(arg1);
+	if (pGuild != NULL)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "GuildID: %d", pGuild->GetID());
+		ch->ChatPacket(CHAT_TYPE_INFO, "GuildMasterPID: %d", pGuild->GetMasterPID());
+		ch->ChatPacket(CHAT_TYPE_INFO, "IsInWar: %d", pGuild->UnderAnyWar());
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s:  苛  都求.", arg1));
+	}
+}
+
+struct FuncWeaken
+{
+	LPCHARACTER m_pkGM;
+	bool m_bAll;
+
+	FuncWeaken(LPCHARACTER ch) : m_pkGM(ch), m_bAll(false)
+	{
+	}
+
+	void operator () (LPENTITY ent)
+	{
+		if (!ent->IsType(ENTITY_CHARACTER))
+			return;
+
+		LPCHARACTER pkChr = (LPCHARACTER)ent;
+
+		int iDist = DISTANCE_APPROX(pkChr->GetX() - m_pkGM->GetX(), pkChr->GetY() - m_pkGM->GetY());
+
+		if (!m_bAll && iDist >= 1000) // 10 鵑 獵 孤 purge  苛쨈.
+			return;
+
+#if defined(__DEFENSE_WAVE__)
+		if (pkChr->GetDefenseWave() && (pkChr->GetDefenseWave()->IsUnique(pkChr) && pkChr->IsMonster() == false))
+			return;
+#endif
+
+		if (pkChr->IsNPC())
+			pkChr->PointChange(POINT_HP, (10 - pkChr->GetHP()));
+	}
+};
+
+ACMD(do_weaken)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	FuncWeaken func(ch);
+
+	if (*arg1 && !strcmp(arg1, "all"))
+		func.m_bAll = true;
+
+	if (ch->GetSectree())
+		ch->GetSectree()->ForEachAround(func);
+}
+
+ACMD(do_getqf)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	LPCHARACTER tch;
+
+	if (!*arg1)
+		tch = ch;
+	else
+	{
+		tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+
+		if (!tch)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "There is no such character.");
+			return;
+		}
+	}
+
+	quest::PC* pPC = quest::CQuestManager::instance().GetPC(tch->GetPlayerID());
+
+	if (pPC)
+		pPC->SendFlagList(ch);
+}
+
+ACMD(do_set_state)
+{
+	char arg1[256];
+	char arg2[256];
+
+	//argument = one_argument(argument, arg1, sizeof(arg1));
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1 || !*arg2)
+		return;
+
+	quest::PC* pPC = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
+	std::string questname = arg1;
+	std::string statename = arg2;
+
+	if (!questname.empty())
+	{
+		int value = quest::CQuestManager::Instance().GetQuestStateIndex(questname, statename);
+
+		pPC->SetFlag(questname + ".__status", value);
+		pPC->ClearTimer();
+
+		quest::PC::QuestInfoIterator it = pPC->quest_begin();
+		unsigned int questindex = quest::CQuestManager::instance().GetQuestIndexByName(questname);
+
+		while (it != pPC->quest_end())
+		{
+			if (it->first == questindex)
+			{
+				it->second.st = value;
+				break;
+			}
+
+			++it;
+		}
+
+		ch->ChatPacket(CHAT_TYPE_INFO, "setting quest state flag %s %s %d", questname.c_str(), arg1, value);
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "setting quest state flag failed");
+	}
+}
+
+ACMD(do_setqf)
+{
+	char arg1[256];
+	char arg2[256];
+	char arg3[256];
+
+	one_argument(two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2)), arg3, sizeof(arg3));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: setqf <flagname> <value> [<character name>]");
+		return;
+	}
+
+	LPCHARACTER tch = ch;
+
+	if (*arg3)
+		tch = CHARACTER_MANAGER::instance().FindPC(arg3);
+
+	if (!tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "There is no such character.");
+		return;
+	}
+
+	quest::PC* pPC = quest::CQuestManager::instance().GetPC(tch->GetPlayerID());
+
+	if (pPC)
+	{
+		int value = 0;
+		str_to_number(value, arg2);
+		pPC->SetFlag(arg1, value);
+		ch->ChatPacket(CHAT_TYPE_INFO, "Quest flag set: %s %d", arg1, value);
+	}
+}
+
+ACMD(do_delqf)
+{
+	char arg1[256];
+	char arg2[256];
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: delqf <flagname> [<character name>]");
+		return;
+	}
+
+	LPCHARACTER tch = ch;
+
+	if (*arg2)
+		tch = CHARACTER_MANAGER::instance().FindPC(arg2);
+
+	if (!tch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "There is no such character.");
+		return;
+	}
+
+	quest::PC* pPC = quest::CQuestManager::instance().GetPC(tch->GetPlayerID());
+
+	if (pPC)
+	{
+		if (pPC->DeleteFlag(arg1))
+			ch->ChatPacket(CHAT_TYPE_INFO, "Delete success.");
+		else
+			ch->ChatPacket(CHAT_TYPE_INFO, "Delete failed. Quest flag does not exist.");
+	}
+}
+
+ACMD(do_forgetme)
+{
+	ch->ForgetMyAttacker();
+}
+
+ACMD(do_aggregate)
+{
+	ch->AggregateMonster();
+}
+
+ACMD(do_attract_ranger)
+{
+	ch->AttractRanger();
+}
+
+ACMD(do_pull_monster)
+{
+	ch->PullMonster();
+}
+
+ACMD(do_polymorph)
+{
+	char arg1[256], arg2[256];
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+	if (*arg1)
+	{
+		DWORD dwVnum = 0;
+		str_to_number(dwVnum, arg1);
+		bool bMaintainStat = false;
+		if (*arg2)
+		{
+			int value = 0;
+			str_to_number(value, arg2);
+			bMaintainStat = (value > 0);
+		}
+
+		ch->SetPolymorph(dwVnum, bMaintainStat);
+	}
+}
+
+ACMD(do_polymorph_item)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (*arg1)
+	{
+		DWORD dwVnum = 0;
+		str_to_number(dwVnum, arg1);
+
+		LPITEM item = ITEM_MANAGER::instance().CreateItem(70104, 1, 0, true);
+		if (item)
+		{
+			item->SetSocket(0, dwVnum);
+			int iEmptyPos = ch->GetEmptyInventory(item->GetSize());
+
+			if (iEmptyPos != -1)
+			{
+				item->AddToCharacter(ch, TItemPos(INVENTORY, iEmptyPos));
+				LogManager::instance().ItemLog(ch, item, "GM", item->GetName());
+			}
+			else
+			{
+				M2_DESTROY_ITEM(item);
+				ch->ChatPacket(CHAT_TYPE_INFO, "Not enough inventory space.");
+			}
+		}
+		else
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "#%d item not exist by that vnum.", 70103);
+		}
+		//ch->SetPolymorph(dwVnum, bMaintainStat);
+	}
+}
+
+ACMD(do_priv_empire)
+{
+	char arg1[256] = { 0 };
+	char arg2[256] = { 0 };
+	char arg3[256] = { 0 };
+	char arg4[256] = { 0 };
+	int empire = 0;
+	int type = 0;
+	int value = 0;
+	int duration = 0;
+
+	const char* line = two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1 || !*arg2)
+		goto USAGE;
+
+	if (!line)
+		goto USAGE;
+
+	two_arguments(line, arg3, sizeof(arg3), arg4, sizeof(arg4));
+
+	if (!*arg3 || !*arg4)
+		goto USAGE;
+
+	str_to_number(empire, arg1);
+	str_to_number(type, arg2);
+	str_to_number(value, arg3);
+	value = MINMAX(0, value, 1000);
+	str_to_number(duration, arg4);
+
+	if (empire < 0 || 3 < empire)
+		goto USAGE;
+
+	if (type < 1 || 4 < type)
+		goto USAGE;
+
+	if (value < 0)
+		goto USAGE;
+
+	if (duration < 0)
+		goto USAGE;
+
+	// 챨  
+	duration = duration * (60 * 60);
+
+	sys_log(0, "_give_empire_privileage(empire=%d, type=%d, value=%d, duration=%d) by command",
+		empire, type, value, duration);
+	CPrivManager::instance().RequestGiveEmpirePriv(empire, type, value, duration);
+	return;
+
+USAGE:
+	ch->ChatPacket(CHAT_TYPE_INFO, "usage : priv_empire <empire> <type> <value> <duration>");
+	ch->ChatPacket(CHAT_TYPE_INFO, "  <empire>    0 - 3 (0==all)");
+	ch->ChatPacket(CHAT_TYPE_INFO, "  <type>      1:item_drop, 2:gold_drop, 3:gold10_drop, 4:exp");
+	ch->ChatPacket(CHAT_TYPE_INFO, "  <value>     percent");
+	ch->ChatPacket(CHAT_TYPE_INFO, "  <duration>  hour");
+}
+
+/**
+* @version 05/06/08 Bang2ni -  駕 트  홴풔  .(크트 蒡홴.)
+* quest/priv_guild.quest   크트 棘 
+**/
+ACMD(do_priv_guild)
+{
+	static const char msg[] = { '\0' };
+
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (*arg1)
+	{
+		CGuild* g = CGuildManager::instance().FindGuildByName(arg1);
+
+		if (!g)
+		{
+			DWORD guild_id = 0;
+			str_to_number(guild_id, arg1);
+			g = CGuildManager::instance().FindGuild(guild_id);
+		}
+
+		if (!g)
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("瀏 見 풔 호 弱 求."));
+		else
+		{
+			char buf[1024 + 1];
+			snprintf(buf, sizeof(buf), msg, g->GetID());
+
+			using namespace quest;
+			PC* pc = CQuestManager::instance().GetPC(ch->GetPlayerID());
+			QuestState qs = CQuestManager::instance().OpenState("ADMIN_QUEST", QUEST_FISH_REFINE_STATE_INDEX);
+			luaL_loadbuffer(qs.co, buf, strlen(buf), "ADMIN_QUEST");
+			pc->SetQuest("ADMIN_QUEST", qs);
+
+			QuestState& rqs = *pc->GetRunningQuestState();
+
+			if (!CQuestManager::instance().RunState(rqs))
+			{
+				CQuestManager::instance().CloseState(rqs);
+				pc->EndRunning();
+				return;
+			}
+		}
+	}
+}
+
+ACMD(do_mount_test)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (*arg1)
+	{
+		DWORD vnum = 0;
+		str_to_number(vnum, arg1);
+		ch->MountVnum(vnum);
+	}
+}
+
+ACMD(do_observer)
+{
+	ch->SetObserverMode(!ch->IsObserverMode());
+}
+
+ACMD(do_socket_item)
+{
+	char arg1[256], arg2[256], arg3[256];
+	three_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2), arg3, sizeof(arg3));
+
+	if (*arg1)
+	{
+		DWORD dwVnum = 0;
+		str_to_number(dwVnum, arg1);
+
+		int iSocketIndex = 0;
+		str_to_number(iSocketIndex, arg2);
+
+		int iSocketValue = 0;
+		str_to_number(iSocketValue, arg3);
+
+		if (iSocketIndex >= ITEM_SOCKET_MAX_NUM)
+			iSocketIndex = ITEM_SOCKET_MAX_NUM - 1;
+
+		if (!dwVnum)
+		{
+			if (!ITEM_MANAGER::instance().GetVnum(arg1, dwVnum))
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, "#%d item not exist by that vnum.", dwVnum);
+				return;
+			}
+		}
+
+		if (LPITEM item = ch->AutoGiveItem(dwVnum))
+		{
+			item->SetSocket(iSocketIndex, iSocketValue);
+		}
+		else
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "#%d cannot create item.", dwVnum);
+		}
+	}
+}
+
+ACMD(do_xmas)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	int flag = 0;
+
+	if (*arg1)
+		str_to_number(flag, arg1);
+
+	switch (subcmd)
+	{
+		case SCMD_XMAS_BOOM:
+			quest::CQuestManager::instance().RequestSetEventFlag("xmas_boom", flag);
+			break;
+
+		case SCMD_XMAS_SNOW:
+			quest::CQuestManager::instance().RequestSetEventFlag("xmas_snow", flag);
+			break;
+
+		case SCMD_XMAS_SANTA:
+			quest::CQuestManager::instance().RequestSetEventFlag("xmas_santa", flag);
+			break;
+	}
+}
+
+// BLOCK_CHAT
+ACMD(do_block_chat_list)
+{
+	// GM 틈構킬 block_chat_privilege     柰
+	if (!ch || (ch->GetGMLevel() < GM_HIGH_WIZARD && ch->GetQuestFlag("chat_privilege.block") <= 0))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("瀏  求"));
+		return;
+	}
+
+	DBManager::instance().ReturnQuery(QID_BLOCK_CHAT_LIST, ch->GetPlayerID(), NULL,
+		"SELECT p.name, a.lDuration FROM affect%s as a, player%s as p WHERE a.bType = %d AND a.dwPID = p.id",
+		get_table_postfix(), get_table_postfix(), AFFECT_BLOCK_CHAT);
+}
+
+ACMD(do_vote_block_chat)
+{
+	return;
+
+	char arg1[256];
+	argument = one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: vote_block_chat <name>");
+		return;
+	}
+
+	const char* name = arg1;
+	long lBlockDuration = 10;
+	sys_log(0, "vote_block_chat %s %d", name, lBlockDuration);
+
+	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(name);
+
+	if (!tch)
+	{
+		CCI* pkCCI = P2P_MANAGER::instance().Find(name);
+
+		if (pkCCI)
+		{
+			TPacketGGBlockChat p;
+
+			p.bHeader = HEADER_GG_BLOCK_CHAT;
+			strlcpy(p.szName, name, sizeof(p.szName));
+			p.lBlockDuration = lBlockDuration;
+			P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGBlockChat));
+		}
+		else
+		{
+			TPacketBlockChat p;
+
+			strlcpy(p.szName, name, sizeof(p.szName));
+			p.lDuration = lBlockDuration;
+			db_clientdesc->DBPacket(HEADER_GD_BLOCK_CHAT, ch ? ch->GetDesc()->GetHandle() : 0, &p, sizeof(p));
+
+		}
+
+		if (ch)
+			ch->ChatPacket(CHAT_TYPE_INFO, "Chat block requested.");
+
+		return;
+	}
+
+	if (tch && ch != tch)
+		tch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, lBlockDuration, 0, true);
+}
+
+ACMD(do_block_chat)
+{
+	// GM 틈構킬 block_chat_privilege     柰
+	if (ch && (ch->GetGMLevel() < GM_HIGH_WIZARD && ch->GetQuestFlag("chat_privilege.block") <= 0))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("瀏  求"));
+		return;
+	}
+
+	char arg1[256];
+	argument = one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		if (ch)
+			ch->ChatPacket(CHAT_TYPE_INFO, "Usage: block_chat <name> <time> (0 to off)");
+
+		return;
+	}
+
+	const char* name = arg1;
+	long lBlockDuration = parse_time_str(argument);
+
+	if (lBlockDuration < 0)
+	{
+		if (ch)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "This is a malformed time. Please specify h, m, and s.");
+			ch->ChatPacket(CHAT_TYPE_INFO, "Example: 1h30m10s (01:30:10");
+		}
+		return;
+	}
+
+	if (ch)
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is now blocked.", name));
+
+	sys_log(0, "BLOCK CHAT %s %d", name, lBlockDuration);
+
+	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(name);
+
+	if (!tch)
+	{
+		CCI* pkCCI = P2P_MANAGER::instance().Find(name);
+
+		if (pkCCI)
+		{
+			TPacketGGBlockChat p;
+
+			p.bHeader = HEADER_GG_BLOCK_CHAT;
+			strlcpy(p.szName, name, sizeof(p.szName));
+			p.lBlockDuration = lBlockDuration;
+			P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGBlockChat));
+		}
+		else
+		{
+			TPacketBlockChat p;
+
+			strlcpy(p.szName, name, sizeof(p.szName));
+			p.lDuration = lBlockDuration;
+			db_clientdesc->DBPacket(HEADER_GD_BLOCK_CHAT, ch ? ch->GetDesc()->GetHandle() : 0, &p, sizeof(p));
+		}
+
+		if (ch)
+			ch->ChatPacket(CHAT_TYPE_INFO, "Chat block requested.");
+
+		return;
+	}
+
+	if (tch && ch != tch)
+		tch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, lBlockDuration, 0, true);
+}
+// END_OF_BLOCK_CHAT
+
+// BUILD_BUILDING
+ACMD(do_build)
+{
+	using namespace building;
+
+	char arg1[256], arg2[256], arg3[256], arg4[256];
+	const char* line = one_argument(argument, arg1, sizeof(arg1));
+	BYTE GMLevel = ch->GetGMLevel();
+
+	CLand* pkLand = CManager::instance().FindLand(ch->GetMapIndex(), ch->GetX(), ch->GetY());
+
+	// NOTE:  체크 클潔트  途 歐    
+	// 氷  歌  磯.
+	if (!pkLand)
+	{
+		sys_err("%s trying to build on not buildable area.", ch->GetName());
+		return;
+	}
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Invalid syntax: no command");
+		return;
+	}
+
+	// 퓬  체크
+	if (GMLevel == GM_PLAYER)
+	{
+		// 첨潔載      확瞞 磯.
+		if ((!ch->GetGuild() || ch->GetGuild()->GetID() != pkLand->GetOwner()))
+		{
+			sys_err("%s trying to build on not owned land.", ch->GetName());
+			return;
+		}
+
+		//  歷뙈?
+		if (ch->GetGuild()->GetMasterPID() != ch->GetPlayerID())
+		{
+			sys_err("%s trying to build while not the guild master.", ch->GetName());
+			return;
+		}
+	}
+
+	switch (LOWER(*arg1))
+	{
+		case 'c':
+		{
+			// /build c vnum x y x_rot y_rot z_rot
+			char arg5[256], arg6[256];
+			line = one_argument(two_arguments(line, arg1, sizeof(arg1), arg2, sizeof(arg2)), arg3, sizeof(arg3)); // vnum x y
+			one_argument(two_arguments(line, arg4, sizeof(arg4), arg5, sizeof(arg5)), arg6, sizeof(arg6)); // x_rot y_rot z_rot
+
+			if (!*arg1 || !*arg2 || !*arg3 || !*arg4 || !*arg5 || !*arg6)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, "Invalid syntax");
+				return;
+			}
+
+			DWORD dwVnum = 0;
+			str_to_number(dwVnum, arg1);
+
+			using namespace building;
+
+			const TObjectProto* t = CManager::instance().GetObjectProto(dwVnum);
+			if (!t)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 苛 퓜都求."));
+				return;
+			}
+
+			const DWORD BUILDING_MAX_PRICE = 100000000;
+
+			if (t->dwGroupVnum)
+			{
+				if (pkLand->FindObjectByGroup(t->dwGroupVnum))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("     퓜  笭求."));
+					return;
+				}
+			}
+
+			// 퓜 憺 체크 ( 퓜  羚)
+			if (t->dwDependOnGroupVnum)
+			{
+				//const TObjectProto* dependent = CManager::instance().GetObjectProto(dwVnum);
+				//if (dependent)
+				{
+					// 獵째?
+					if (!pkLand->FindObjectByGroup(t->dwDependOnGroupVnum))
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("퓬 却 퓜   駕求."));
+						return;
+					}
+				}
+			}
+
+			int32_t iPrice = t->dwPrice;
+			if (test_server || GMLevel == GM_PLAYER)
+			{
+				// GM 틈柰痢 (硫 GM 恬)
+				// 퓬  체크
+				if (iPrice > BUILDING_MAX_PRICE)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("퓜   鵑 퓬 訪 颯求."));
+					return;
+				}
+
+				if (ch->GetGold() < iPrice)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("퓬  爛求."));
+					return;
+				}
+
+				//    체크
+
+				int i;
+				for (i = 0; i < OBJECT_MATERIAL_MAX_NUM; ++i)
+				{
+					DWORD dwItemVnum = t->kMaterials[i].dwItemVnum;
+					DWORD dwItemCount = t->kMaterials[i].dwCount;
+
+					if (dwItemVnum == 0)
+						break;
+
+					if ((int)dwItemCount > ch->CountSpecifyItem(dwItemVnum))
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("怜 臼 퓬  求."));
+						return;
+					}
+				}
+			}
+
+			float x_rot = atof(arg4);
+			float y_rot = atof(arg5);
+			float z_rot = atof(arg6);
+			// 20050811.myevan.퓜 회   
+			/*
+			if (x_rot != 0.0f || y_rot != 0.0f || z_rot != 0.0f)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, "퓜 회    駕求");
+				return;
+			}
+			*/
+
+			long map_x = 0;
+			str_to_number(map_x, arg2);
+			long map_y = 0;
+			str_to_number(map_y, arg3);
+
+			bool isSuccess = pkLand->RequestCreateObject(dwVnum,
+				ch->GetMapIndex(),
+				map_x,
+				map_y,
+				x_rot,
+				y_rot,
+				z_rot, true
+			);
+
+			if (!isSuccess)
+			{
+				if (test_server)
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("퓜    치都求."));
+				return;
+			}
+
+			if (test_server || GMLevel == GM_PLAYER)
+				// 퓬  恬歐 (硫 GM 恬)
+			{
+				// 퓬  恬
+				ch->PointChange(POINT_GOLD, -iPrice);
+
+				//   歐 
+				{
+					int i;
+					for (i = 0; i < OBJECT_MATERIAL_MAX_NUM; ++i)
+					{
+						DWORD dwItemVnum = t->kMaterials[i].dwItemVnum;
+						DWORD dwItemCount = t->kMaterials[i].dwCount;
+
+						if (dwItemVnum == 0)
+							break;
+
+						sys_log(0, "BUILD: material %d %u %u", i, dwItemVnum, dwItemCount);
+						ch->RemoveSpecifyItem(dwItemVnum, dwItemCount);
+					}
+				}
+			}
+		}
+		break;
+
+		case 'd':
+			// build (d)elete ObjectID
+		{
+			one_argument(line, arg1, sizeof(arg1));
+
+			if (!*arg1)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, "Invalid syntax");
+				return;
+			}
+
+			DWORD vid = 0;
+			str_to_number(vid, arg1);
+			pkLand->RequestDeleteObjectByVID(vid);
+		}
+		break;
+
+		// BUILD_WALL
+
+		// build w n/e/w/s
+		case 'w':
+			if (GMLevel > GM_PLAYER)
+			{
+				int mapIndex = ch->GetMapIndex();
+
+				one_argument(line, arg1, sizeof(arg1));
+
+				sys_log(0, "guild.wall.build map[%d] direction[%s]", mapIndex, arg1);
+
+				switch (arg1[0])
+				{
+					case 's':
+						pkLand->RequestCreateWall(mapIndex, 0.0f);
+						break;
+					case 'n':
+						pkLand->RequestCreateWall(mapIndex, 180.0f);
+						break;
+					case 'e':
+						pkLand->RequestCreateWall(mapIndex, 90.0f);
+						break;
+					case 'w':
+						pkLand->RequestCreateWall(mapIndex, 270.0f);
+						break;
+					default:
+						ch->ChatPacket(CHAT_TYPE_INFO, "guild.wall.build unknown_direction[%s]", arg1);
+						sys_err("guild.wall.build unknown_direction[%s]", arg1);
+						break;
+				}
+
+			}
+			break;
+
+		case 'e':
+			if (GMLevel > GM_PLAYER)
+			{
+				pkLand->RequestDeleteWall();
+			}
+			break;
+
+		case 'W':
+			//  
+			// build (w)all 호 크 鍮 鍮 鍮 鍮
+
+			if (GMLevel > GM_PLAYER)
+			{
+				int setID = 0, wallSize = 0;
+				char arg5[256], arg6[256];
+				line = two_arguments(line, arg1, sizeof(arg1), arg2, sizeof(arg2));
+				line = two_arguments(line, arg3, sizeof(arg3), arg4, sizeof(arg4));
+				two_arguments(line, arg5, sizeof(arg5), arg6, sizeof(arg6));
+
+				str_to_number(setID, arg1);
+				str_to_number(wallSize, arg2);
+
+				if (setID != 14105 && setID != 14115 && setID != 14125)
+				{
+					sys_log(0, "BUILD_WALL: wrong wall set id %d", setID);
+					break;
+				}
+				else
+				{
+					bool door_east = false;
+					str_to_number(door_east, arg3);
+					bool door_west = false;
+					str_to_number(door_west, arg4);
+					bool door_south = false;
+					str_to_number(door_south, arg5);
+					bool door_north = false;
+					str_to_number(door_north, arg6);
+					pkLand->RequestCreateWallBlocks(setID, ch->GetMapIndex(), wallSize, door_east, door_west, door_south, door_north);
+				}
+			}
+			break;
+
+		case 'E':
+			//  
+			// build (e)rase ID
+			if (GMLevel > GM_PLAYER)
+			{
+				one_argument(line, arg1, sizeof(arg1));
+				DWORD id = 0;
+				str_to_number(id, arg1);
+				pkLand->RequestDeleteWallBlocks(id);
+			}
+			break;
+
+		default:
+			ch->ChatPacket(CHAT_TYPE_INFO, "Invalid command %s", arg1);
+			break;
+	}
+}
+// END_OF_BUILD_BUILDING
+
+ACMD(do_clear_quest)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+		return;
+
+	quest::PC* pPC = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
+	pPC->ClearQuest(arg1);
+}
+
+ACMD(do_horse_state)
+{
+	ch->ChatPacket(CHAT_TYPE_INFO, "Horse Information:");
+	ch->ChatPacket(CHAT_TYPE_INFO, "    Level  %d", ch->GetHorseLevel());
+	ch->ChatPacket(CHAT_TYPE_INFO, "    Health %d/%d (%d%%)", ch->GetHorseHealth(), ch->GetHorseMaxHealth(), ch->GetHorseHealth() * 100 / ch->GetHorseMaxHealth());
+	ch->ChatPacket(CHAT_TYPE_INFO, "    Stam   %d/%d (%d%%)", ch->GetHorseStamina(), ch->GetHorseMaxStamina(), ch->GetHorseStamina() * 100 / ch->GetHorseMaxStamina());
+}
+
+ACMD(do_horse_level)
+{
+	char arg1[256] = { 0 };
+	char arg2[256] = { 0 };
+	LPCHARACTER victim;
+	int level = 0;
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1 || !*arg2)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "usage : /horse_level <name> <level>");
+		return;
+	}
+
+	victim = CHARACTER_MANAGER::instance().FindPC(arg1);
+
+	if (NULL == victim)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 苛 캐 都求."));
+		return;
+	}
+
+	str_to_number(level, arg2);
+	level = MINMAX(0, level, HORSE_MAX_LEVEL);
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "horse level set (%s: %d)", victim->GetName(), level);
+
+	victim->SetHorseLevel(level);
+	victim->ComputePoints();
+	victim->SkillLevelPacket();
+	return;
+
+	/*-----
+		char arg1[256];
+		one_argument(argument, arg1, sizeof(arg1));
+
+		int level = MINMAX(0, atoi(arg1), HORSE_MAX_LEVEL);
+
+		ch->ChatPacket(CHAT_TYPE_INFO, "horse level set to %d.", level);
+		ch->SetHorseLevel(level);
+		ch->ComputePoints();
+		ch->SkillLevelPacket();
+		return;
+	-----*/
+}
+
+ACMD(do_horse_ride)
+{
+	if (ch->IsHorseRiding())
+		ch->StopRiding();
+	else
+		ch->StartRiding();
+}
+
+ACMD(do_horse_summon)
+{
+	ch->HorseSummon(true, true);
+}
+
+ACMD(do_horse_unsummon)
+{
+	ch->HorseSummon(false, true);
+}
+
+ACMD(do_horse_set_stat)
+{
+	char arg1[256], arg2[256];
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (*arg1 && *arg2)
+	{
+		int hp = 0;
+		str_to_number(hp, arg1);
+		int stam = 0;
+		str_to_number(stam, arg2);
+		ch->UpdateHorseHealth(hp - ch->GetHorseHealth());
+		ch->UpdateHorseStamina(stam - ch->GetHorseStamina());
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage : /horse_set_stat <hp> <stamina>");
+	}
+}
+
+ACMD(do_save_attribute_to_image) // command "/saveati" for alias
+{
+	char szFileName[256];
+	char szMapIndex[256];
+
+	two_arguments(argument, szMapIndex, sizeof(szMapIndex), szFileName, sizeof(szFileName));
+
+	if (!*szMapIndex || !*szFileName)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: /saveati <map_index> <filename>");
+		return;
+	}
+
+	long lMapIndex = 0;
+	str_to_number(lMapIndex, szMapIndex);
+
+	if (SECTREE_MANAGER::instance().SaveAttributeToImage(lMapIndex, szFileName))
+		ch->ChatPacket(CHAT_TYPE_INFO, "Save done.");
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, "Save failed.");
+}
+
+ACMD(do_affect_remove)
+{
+	char arg1[256];
+	char arg2[256];
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1 || !*arg2)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: /affect_remove <player name>");
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: /affect_remove <type> <point>");
+
+		LPCHARACTER tch = ch;
+
+		if (*arg1)
+			if (!(tch = CHARACTER_MANAGER::instance().FindPC(arg1)))
+				tch = ch;
+
+		ch->ChatPacket(CHAT_TYPE_INFO, "-- Affect List of %s -------------------------------", tch->GetName());
+		ch->ChatPacket(CHAT_TYPE_INFO, "Type Point Modif Duration Flag");
+
+		const AffectContainerList& cont = tch->GetAffectContainer();
+		auto it = cont.begin();
+		while (it != cont.end())
+		{
+			CAffect* pkAff = *it++;
+
+			ch->ChatPacket(CHAT_TYPE_INFO, "%4d %5d %5d %8d %u",
+				pkAff->dwType, pkAff->wApplyOn, pkAff->lApplyValue, pkAff->lDuration, pkAff->dwFlag);
+		}
+		return;
+	}
+
+	bool removed = false;
+
+	CAffect* af;
+
+	DWORD type = 0;
+	str_to_number(type, arg1);
+	POINT_TYPE point = 0;
+	str_to_number(point, arg2);
+	while ((af = ch->FindAffect(type, point)))
+	{
+		ch->RemoveAffect(af);
+		removed = true;
+	}
+
+	if (removed)
+		ch->ChatPacket(CHAT_TYPE_INFO, "Affect successfully removed.");
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, "Not affected by that type and point.");
+}
+
+ACMD(do_affect_add)
+{
+	char arg1[256], arg2[256], arg3[256], arg4[256], arg5[256], arg6[256];
+	one_argument(
+		one_argument(
+			one_argument(
+				one_argument(
+					one_argument(
+						one_argument(argument,
+							arg1, sizeof(arg1)),
+						arg2, sizeof(arg2)),
+					arg3, sizeof(arg3)),
+				arg4, sizeof(arg4)),
+			arg5, sizeof(arg5)),
+		arg6, sizeof(arg6)
+	);
+	if (!*arg1 || !*arg2 || !*arg3 || !*arg4 || !*arg5 || !*arg6)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: /affect_add <type> <apply> <value> <flag> <duration> <override>");
+		return; // invalid syntax
+	}
+
+	DWORD dwType;
+	WORD wApplyOn;
+	long lApplyValue;
+	DWORD dwFlag;
+	long lDuration;
+	bool bOverride;
+
+	str_to_number(dwType, arg1);
+	str_to_number(wApplyOn, arg2);
+	str_to_number(lApplyValue, arg3);
+	str_to_number(dwFlag, arg4);
+	str_to_number(lDuration, arg5);
+	str_to_number(bOverride, arg6);
+
+	ch->AddAffect(dwType, wApplyOn, lApplyValue, dwFlag, lDuration, 0, bOverride);
+	ch->ChatPacket(CHAT_TYPE_INFO, "Affect successfully added.");
+}
+
+ACMD(do_change_attr)
+{
+	LPITEM weapon = ch->GetWear(WEAR_WEAPON);
+	if (weapon)
+		weapon->ChangeAttribute();
+}
+
+ACMD(do_add_attr)
+{
+	LPITEM weapon = ch->GetWear(WEAR_WEAPON);
+	if (weapon)
+		weapon->AddAttribute();
+}
+
+ACMD(do_add_socket)
+{
+	LPITEM weapon = ch->GetWear(WEAR_WEAPON);
+	if (weapon)
+		weapon->AddSocket();
+}
+
+ACMD(do_show_arena_list)
+{
+	CArenaManager::instance().SendArenaMapListTo(ch);
+}
+
+ACMD(do_end_all_duel)
+{
+	CArenaManager::instance().EndAllDuel();
+}
+
+ACMD(do_end_duel)
+{
+	char szName[256];
+
+	one_argument(argument, szName, sizeof(szName));
+
+	LPCHARACTER pChar = CHARACTER_MANAGER::instance().FindPC(szName);
+	if (pChar == NULL)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 苛 캐 都求."));
+		return;
+	}
+
+	if (CArenaManager::instance().EndDuel(pChar->GetPlayerID()) == false)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   "));
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   "));
+	}
+}
+
+ACMD(do_duel)
+{
+	char szName1[256];
+	char szName2[256];
+	char szSet[256];
+	char szMinute[256];
+	int set = 0;
+	int minute = 0;
+
+	argument = two_arguments(argument, szName1, sizeof(szName1), szName2, sizeof(szName2));
+	two_arguments(argument, szSet, sizeof(szSet), szMinute, sizeof(szMinute));
+
+	str_to_number(set, szSet);
+
+	if (set < 0) set = 1;
+	if (set > 5) set = 5;
+
+	if (!str_to_number(minute, szMinute))
+	{
+		// 캐募 羞 10.
+		if (LC_IsCanada() == true)
+		{
+			minute = 10;
+		}
+		else
+		{
+			minute = 5;
+		}
+	}
+	if (minute < 5)
+		minute = 5;
+
+	LPCHARACTER pChar1 = CHARACTER_MANAGER::instance().FindPC(szName1);
+	LPCHARACTER pChar2 = CHARACTER_MANAGER::instance().FindPC(szName2);
+
+	if (pChar1 != NULL && pChar2 != NULL)
+	{
+		pChar1->RemoveGoodAffect();
+		pChar2->RemoveGoodAffect();
+
+		pChar1->RemoveBadAffect();
+		pChar2->RemoveBadAffect();
+
+		LPPARTY pParty = pChar1->GetParty();
+		if (pParty != NULL)
+		{
+			if (pParty->GetMemberCount() == 2)
+			{
+				CPartyManager::instance().DeleteParty(pParty);
+			}
+			else
+			{
+				pChar1->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 決求."));
+				pParty->Quit(pChar1->GetPlayerID());
+			}
+		}
+
+		pParty = pChar2->GetParty();
+		if (pParty != NULL)
+		{
+			if (pParty->GetMemberCount() == 2)
+			{
+				CPartyManager::instance().DeleteParty(pParty);
+			}
+			else
+			{
+				pChar2->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 決求."));
+				pParty->Quit(pChar2->GetPlayerID());
+			}
+		}
+
+		if (CArenaManager::instance().StartDuel(pChar1, pChar2, set, minute) == true)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   퓸求."));
+		}
+		else
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 謗  笭求."));
+		}
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("微 求."));
+	}
+}
+
+ACMD(do_stat_plus_amount)
+{
+	char szPoint[256];
+
+	one_argument(argument, szPoint, sizeof(szPoint));
+
+	if (*szPoint == '\0')
+		return;
+
+	if (ch->IsPolymorphed())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("逵 傷  첩  求."));
+		return;
+	}
+
+	int nRemainPoint = ch->GetPoint(POINT_STAT);
+
+	if (nRemainPoint <= 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  트 求."));
+		return;
+	}
+
+	int nPoint = 0;
+	str_to_number(nPoint, szPoint);
+
+	if (nRemainPoint < nPoint)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  트 求."));
+		return;
+	}
+
+	if (nPoint < 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 蔘 韜臼求."));
+		return;
+	}
+
+	switch (subcmd)
+	{
+		case POINT_HT: // 체
+			if (nPoint + ch->GetPoint(POINT_HT) > 90)
+			{
+				nPoint = 90 - ch->GetPoint(POINT_HT);
+			}
+			break;
+
+		case POINT_IQ: // 
+			if (nPoint + ch->GetPoint(POINT_IQ) > 90)
+			{
+				nPoint = 90 - ch->GetPoint(POINT_IQ);
+			}
+			break;
+
+		case POINT_ST: // 慕
+			if (nPoint + ch->GetPoint(POINT_ST) > 90)
+			{
+				nPoint = 90 - ch->GetPoint(POINT_ST);
+			}
+			break;
+
+		case POINT_DX: // 첩
+			if (nPoint + ch->GetPoint(POINT_DX) > 90)
+			{
+				nPoint = 90 - ch->GetPoint(POINT_DX);
+			}
+			break;
+
+		default:
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  커풩弱 蔘 퓸求."));
+			return;
+			break;
+	}
+
+	if (nPoint != 0)
+	{
+		ch->SetRealPoint(subcmd, ch->GetRealPoint(subcmd) + nPoint);
+		ch->SetPoint(subcmd, ch->GetPoint(subcmd) + nPoint);
+		ch->ComputePoints();
+		ch->PointChange(subcmd, 0);
+
+		ch->PointChange(POINT_STAT, -nPoint);
+		ch->ComputePoints();
+	}
+}
+
+struct tTwoPID
+{
+	int pid1;
+	int pid2;
+};
+
+ACMD(do_break_marriage)
+{
+	char arg1[256], arg2[256];
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	tTwoPID pids = { 0, 0 };
+
+	str_to_number(pids.pid1, arg1);
+	str_to_number(pids.pid2, arg2);
+
+	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("첨潔 %d  첨潔  %d 혼킵求..", pids.pid1, pids.pid2));
+	db_clientdesc->DBPacket(HEADER_GD_BREAK_MARRIAGE, 0, &pids, sizeof(pids));
+}
+
+ACMD(do_effect)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	int effect_type = 0;
+	str_to_number(effect_type, arg1);
+	ch->EffectPacket(effect_type);
+}
+
+struct FCountInMap
+{
+	int m_Count[4];
+	FCountInMap() { memset(m_Count, 0, sizeof(int) * 4); }
+	void operator()(LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+			if (ch && ch->IsPC())
+				++m_Count[ch->GetEmpire()];
+		}
+	}
+	int GetCount(BYTE bEmpire) { return m_Count[bEmpire]; }
+};
+
+ACMD(do_threeway_war_info)
+{
+	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  "));
+	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("    %d  %d %d %d", GetSungziMapIndex(), GetPassMapIndex(1), GetPassMapIndex(2), GetPassMapIndex(3)));
+	ch->ChatPacket(CHAT_TYPE_INFO, "ThreewayPhase %d", CThreeWayWar::instance().GetRegenFlag());
+
+	for (int n = 1; n < 4; ++n)
+	{
+		LPSECTREE_MAP pSecMap = SECTREE_MANAGER::instance().GetMap(GetSungziMapIndex());
+
+		FCountInMap c;
+
+		if (pSecMap)
+		{
+			pSecMap->for_each(c);
+		}
+
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s killscore %d usercount %d",
+			EMPIRE_NAME(n),
+			CThreeWayWar::instance().GetKillScore(n),
+			c.GetCount(n));
+	}
+}
+
+ACMD(do_threeway_war_myinfo)
+{
+	ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 타 "));
+	ch->ChatPacket(CHAT_TYPE_INFO, "Deadcount %d",
+		CThreeWayWar::instance().GetReviveTokenForPlayer(ch->GetPlayerID()));
+}
+
+ACMD(do_rmcandidacy)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: rmcandidacy <name>");
+		return;
+	}
+
+	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+
+	if (!tch)
+	{
+		CCI* pkCCI = P2P_MANAGER::instance().Find(arg1);
+
+		if (pkCCI)
+		{
+			if (pkCCI->bChannel != g_bChannel)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, "Target is in %d channel (my channel %d)", pkCCI->bChannel, g_bChannel);
+				return;
+			}
+		}
+	}
+
+	db_clientdesc->DBPacket(HEADER_GD_RMCANDIDACY, 0, NULL, 32);
+	db_clientdesc->Packet(arg1, 32);
+}
+
+ACMD(do_setmonarch)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: setmonarch <name>");
+		return;
+	}
+
+	db_clientdesc->DBPacket(HEADER_GD_SETMONARCH, 0, NULL, 32);
+	db_clientdesc->Packet(arg1, 32);
+}
+
+ACMD(do_rmmonarch)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: rmmonarch <name>");
+		return;
+	}
+
+	db_clientdesc->DBPacket(HEADER_GD_RMMONARCH, 0, NULL, 32);
+	db_clientdesc->Packet(arg1, 32);
+}
+
+ACMD(do_check_monarch_money)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+		return;
+
+	int empire = 0;
+	str_to_number(empire, arg1);
+	int NationMoney = CMonarch::instance().GetMoney(empire);
+
+	ch->ChatPacket(CHAT_TYPE_INFO, ": %d ", NationMoney);
+}
+
+ACMD(do_reset_subskill)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: reset_subskill <name>");
+		return;
+	}
+
+	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+
+	if (tch == NULL)
+		return;
+
+	tch->ClearSubSkill();
+	ch->ChatPacket(CHAT_TYPE_INFO, "Subskill of [%s] was reset", tch->GetName());
+}
+
+ACMD(do_siege)
+{
+	char arg1[256], arg2[256];
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	int empire = strtol(arg1, NULL, 10);
+	int tower_count = strtol(arg2, NULL, 10);
+
+	if (empire == 0) empire = number(1, 3);
+	if (tower_count < 5 || tower_count > 10) tower_count = number(5, 10);
+
+	TPacketGGSiege packet;
+	packet.bHeader = HEADER_GG_SIEGE;
+	packet.bEmpire = empire;
+	packet.bTowerCount = tower_count;
+
+	P2P_MANAGER::instance().Send(&packet, sizeof(TPacketGGSiege));
+
+	switch (castle_siege(empire, tower_count))
+	{
+		case 0:
+			ch->ChatPacket(CHAT_TYPE_INFO, "SIEGE FAILED");
+			break;
+		case 1:
+			ch->ChatPacket(CHAT_TYPE_INFO, "SIEGE START Empire(%d) Tower(%d)", empire, tower_count);
+			break;
+		case 2:
+			ch->ChatPacket(CHAT_TYPE_INFO, "SIEGE END");
+			break;
+	}
+}
+
+ACMD(do_temp)
+{
+	if (false == test_server)
+		return;
+
+	char arg1[256], arg2[256];
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (0 == arg1[0] || 0 == arg2[0])
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: empire money");
+		return;
+	}
+
+	int empire = 0;
+	str_to_number(empire, arg1);
+	int money = 0;
+	str_to_number(money, arg2);
+
+	CMonarch::instance().SendtoDBAddMoney(money, empire, ch);
+}
+
+ACMD(do_frog)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (0 == arg1[0])
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: empire(1, 2, 3)");
+		return;
+	}
+
+	int empire = 0;
+	str_to_number(empire, arg1);
+
+	switch (empire)
+	{
+		case 1:
+		case 2:
+		case 3:
+			if (IS_CASTLE_MAP(ch->GetMapIndex()))
+			{
+				castle_spawn_frog(empire);
+				castle_save();
+			}
+			else
+				ch->ChatPacket(CHAT_TYPE_INFO, "You must spawn frog in castle");
+			break;
+
+		default:
+			ch->ChatPacket(CHAT_TYPE_INFO, "Usage: empire(1, 2, 3)");
+			break;
+	}
+
+}
+
+ACMD(do_flush)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (0 == arg1[0])
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "usage : /flush player_id");
+		return;
+	}
+
+	DWORD pid = (DWORD)strtoul(arg1, NULL, 10);
+
+	db_clientdesc->DBPacketHeader(HEADER_GD_FLUSH_CACHE, 0, sizeof(DWORD));
+	db_clientdesc->Packet(&pid, sizeof(DWORD));
+}
+
+ACMD(do_eclipse)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (strtol(arg1, NULL, 10) == 1)
+	{
+		quest::CQuestManager::instance().RequestSetEventFlag("eclipse", 1);
+	}
+	else
+	{
+		quest::CQuestManager::instance().RequestSetEventFlag("eclipse", 0);
+	}
+}
+
+ACMD(do_weeklyevent)
+{
+	char arg1[256];
+	int empire = 0;
+
+	if (CBattleArena::instance().IsRunning() == false)
+	{
+		one_argument(argument, arg1, sizeof(arg1));
+
+		empire = strtol(arg1, NULL, 10);
+
+		if (empire == 1 || empire == 2 || empire == 3)
+		{
+			CBattleArena::instance().Start(empire);
+		}
+		else
+		{
+			CBattleArena::instance().Start(rand() % 3 + 1);
+		}
+		ch->ChatPacket(CHAT_TYPE_INFO, "Weekly Event Start");
+	}
+	else
+	{
+		CBattleArena::instance().ForceEnd();
+		ch->ChatPacket(CHAT_TYPE_INFO, "Weekly Event End");
+	}
+}
+
+#if defined(__XMAS_EVENT_2008__)
+ACMD(do_event_helper)
+{
+	char arg1[256];
+	int mode = 0;
+
+	one_argument(argument, arg1, sizeof(arg1));
+	str_to_number(mode, arg1);
+
+	if (mode == 1)
+	{
+		xmas::SpawnEventHelper(true);
+		ch->ChatPacket(CHAT_TYPE_INFO, "Event Helper Spawn");
+	}
+	else
+	{
+		xmas::SpawnEventHelper(false);
+		ch->ChatPacket(CHAT_TYPE_INFO, "Event Helper Delete");
+	}
+}
+#endif
+
+struct FMobCounter
+{
+	int nCount;
+
+	void operator () (LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER pChar = static_cast<LPCHARACTER>(ent);
+
+			if (pChar->IsMonster() == true || pChar->IsStone())
+			{
+				nCount++;
+			}
+		}
+	}
+};
+
+ACMD(do_get_mob_count)
+{
+	LPSECTREE_MAP pSectree = SECTREE_MANAGER::instance().GetMap(ch->GetMapIndex());
+
+	if (pSectree == NULL)
+		return;
+
+	FMobCounter f;
+	f.nCount = 0;
+
+	pSectree->for_each(f);
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "MapIndex: %d MobCount %d", ch->GetMapIndex(), f.nCount);
+}
+
+ACMD(do_clear_land)
+{
+	const building::CLand* pLand = building::CManager::instance().FindLand(ch->GetMapIndex(), ch->GetX(), ch->GetY());
+
+	if (NULL == pLand)
+	{
+		return;
+	}
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "Guild Land(%d) Cleared", pLand->GetID());
+
+	building::CManager::instance().ClearLand(pLand->GetID());
+}
+
+ACMD(do_special_item)
+{
+	ITEM_MANAGER::instance().ConvSpecialDropItemFile();
+}
+
+ACMD(do_set_stat)
+{
+	char szName[256];
+	char szChangeAmount[256];
+
+	two_arguments(argument, szName, sizeof(szName), szChangeAmount, sizeof(szChangeAmount));
+
+	if (*szName == 0 || *szChangeAmount == '\0')
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Invalid argument.");
+		return;
+	}
+
+	LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(szName);
+
+	if (!tch)
+	{
+		CCI* pkCCI = P2P_MANAGER::instance().Find(szName);
+
+		if (pkCCI)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "Cannot find player(%s). %s is not in your game server.", szName, szName);
+			return;
+		}
+		else
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "Cannot find player(%s). Perhaps %s doesn't login or exist.", szName, szName);
+			return;
+		}
+	}
+	else
+	{
+		if (tch->IsPolymorphed())
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("逵 傷  첩  求."));
+			return;
+		}
+
+		if (subcmd != POINT_HT && subcmd != POINT_IQ && subcmd != POINT_ST && subcmd != POINT_DX)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  커풩弱 蔘 퓸求."));
+			return;
+		}
+		int nRemainPoint = tch->GetPoint(POINT_STAT);
+		int nCurPoint = tch->GetRealPoint(subcmd);
+		int nChangeAmount = 0;
+		str_to_number(nChangeAmount, szChangeAmount);
+		int nPoint = nCurPoint + nChangeAmount;
+
+		int n;
+		switch (subcmd)
+		{
+			case POINT_HT:
+				if (nPoint < JobInitialPoints[tch->GetJob()].ht)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, "Cannot set stat under initial stat.");
+					return;
+				}
+				n = 0;
+				break;
+			case POINT_IQ:
+				if (nPoint < JobInitialPoints[tch->GetJob()].iq)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, "Cannot set stat under initial stat.");
+					return;
+				}
+				n = 1;
+				break;
+			case POINT_ST:
+				if (nPoint < JobInitialPoints[tch->GetJob()].st)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, "Cannot set stat under initial stat.");
+					return;
+				}
+				n = 2;
+				break;
+			case POINT_DX:
+				if (nPoint < JobInitialPoints[tch->GetJob()].dx)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, "Cannot set stat under initial stat.");
+					return;
+				}
+				n = 3;
+				break;
+		}
+
+		if (nPoint > 90)
+		{
+			nChangeAmount -= nPoint - 90;
+			nPoint = 90;
+		}
+
+		if (nRemainPoint < nChangeAmount)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  트 求."));
+			return;
+		}
+
+		tch->SetRealPoint(subcmd, nPoint);
+		tch->SetPoint(subcmd, tch->GetPoint(subcmd) + nChangeAmount);
+		tch->ComputePoints();
+		tch->PointChange(subcmd, 0);
+
+		tch->PointChange(POINT_STAT, -nChangeAmount);
+		tch->ComputePoints();
+
+		const char* stat_name[4] = { "con", "int", "str", "dex" };
+
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s's %s change %d to %d", szName, stat_name[n], nCurPoint, nPoint);
+	}
+}
+
+ACMD(do_get_item_id_list)
+{
+	for (int i = 0; i < INVENTORY_MAX_NUM; i++)
+	{
+		LPITEM item = ch->GetInventoryItem(i);
+		if (item != NULL)
+			ch->ChatPacket(CHAT_TYPE_INFO, "cell : %d, name : %s, id : %d", item->GetCell(), item->GetName(), item->GetID());
+	}
+}
+
+ACMD(do_set_socket)
+{
+	char arg1[256];
+	char arg2[256];
+	char arg3[256];
+
+	one_argument(two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2)), arg3, sizeof(arg3));
+
+	int item_id, socket_num, value;
+	if (!str_to_number(item_id, arg1) || !str_to_number(socket_num, arg2) || !str_to_number(value, arg3))
+		return;
+
+	LPITEM item = ITEM_MANAGER::instance().Find(item_id);
+	if (item)
+		item->SetSocket(socket_num, value);
+}
+
+ACMD(do_get_socket)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	int cell;
+	str_to_number(cell, arg1);
+
+	LPITEM item = ch->GetInventoryItem(cell);
+	if (item)
+	{
+		for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "cell(%d), socket(%d) : %ld", cell, i, item->GetSocket(i));
+		}
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, " 底   .");
+	}
+}
+
+ACMD(do_can_dead)
+{
+	if (subcmd)
+		ch->SetArmada();
+	else
+		ch->ResetArmada();
+}
+
+ACMD(do_full_set)
+{
+	extern void do_all_skill_master(LPCHARACTER ch, const char* argument, int cmd, int subcmd);
+	do_all_skill_master(ch, NULL, 0, 0);
+	extern void do_item_full_set(LPCHARACTER ch, const char* argument, int cmd, int subcmd);
+	do_item_full_set(ch, NULL, 0, 0);
+	extern void do_attr_full_set(LPCHARACTER ch, const char* argument, int cmd, int subcmd);
+	do_attr_full_set(ch, NULL, 0, 0);
+}
+
+ACMD(do_all_skill_master)
+{
+	ch->SetHorseLevel(SKILL_MAX_LEVEL - 10);
+	for (int i = 0; i < SKILL_MAX_NUM; i++)
+	{
+		if (true == ch->CanUseSkill(i))
+		{
+			ch->SetSkillLevel(i, SKILL_MAX_LEVEL);
+		}
+		else
+		{
+			switch (i)
+			{
+				case SKILL_HORSE_WILDATTACK:
+				case SKILL_HORSE_CHARGE:
+				case SKILL_HORSE_ESCAPE:
+				case SKILL_HORSE_WILDATTACK_RANGE:
+					ch->SetSkillLevel(i, SKILL_MAX_LEVEL);
+					break;
+			}
+		}
+	}
+	ch->ComputePoints();
+	ch->SkillLevelPacket();
+}
+
+ACMD(do_item_full_set)
+{
+	BYTE bJob = ch->GetJob();
+	LPITEM pItem = nullptr;
+
+	std::vector<BYTE> vWearIndex
+	{
+		WEAR_BODY,
+		WEAR_HEAD,
+		WEAR_FOOTS,
+		WEAR_WRIST,
+		WEAR_WEAPON,
+		WEAR_NECK,
+		WEAR_EAR,
+		WEAR_UNIQUE1,
+		WEAR_UNIQUE2,
+		WEAR_ARROW,
+		WEAR_SHIELD,
+		WEAR_BELT,
+#if defined(__PENDANT_SYSTEM__)
+		WEAR_PENDANT,
+#endif
+#if defined(__GLOVE_SYSTEM__)
+		WEAR_GLOVE,
+#endif
+
+		WEAR_COSTUME_BODY,
+		WEAR_COSTUME_HAIR,
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+		WEAR_COSTUME_MOUNT,
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		WEAR_COSTUME_ACCE,
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+		WEAR_COSTUME_WEAPON,
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+		WEAR_COSTUME_AURA,
+#endif
+	};
+
+	for (const BYTE bWearIndex : vWearIndex)
+	{
+		pItem = ch->GetWear(bWearIndex);
+		if (pItem)
+			ch->UnequipItem(pItem);
+	}
+
+	using WearItemMap = std::unordered_map<BYTE, std::vector<DWORD>>;
+	WearItemMap mWearItem =
+	{
+		{ JOB_WARRIOR,
+			{
+				{ 20869 }, // WEAR_BODY
+				{ 12739 }, // WEAR_HEAD
+				{ 15449 }, // WEAR_FOOTS
+				{ 14209 }, // WEAR_WRIST
+				{ 319 }, // WEAR_WEAPON
+				{ 16209 }, // WEAR_NECK
+				{ 17549 }, // WEAR_EAR
+				{ 71202 }, // WEAR_UNIQUE1
+				{ 0 }, // WEAR_UNIQUE2
+				{ 13149 }, // WEAR_SHIELD
+				{ 18089 }, // WEAR_BELT
+#if defined(__PENDANT_SYSTEM__)
+				{ 9800 }, // WEAR_PENDANT
+#endif
+#if defined(__GLOVE_SYSTEM__)
+				{ 23009 }, // WEAR_GLOVE
+#endif
+				{ 0 }, // WEAR_COSTUME_BODY
+				{ 0 }, // WEAR_COSTUME_HAIR
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+				{ 0 }, // WEAR_COSTUME_MOUNT
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+				{ 85004 }, // WEAR_COSTUME_ACCE
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+				{ 0 }, // WEAR_COSTUME_WEAPON
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+				{ 49006 }, // WEAR_COSTUME_AURA
+#endif
+			},
+		},
+		{ JOB_ASSASSIN,
+			{
+				{ 20879 }, // WEAR_BODY
+				{ 12749 }, // WEAR_HEAD
+				{ 15449 }, // WEAR_FOOTS
+				{ 14209 }, // WEAR_WRIST
+				{ 1189 }, // WEAR_WEAPON
+				{ 16209 }, // WEAR_NECK
+				{ 17549 }, // WEAR_EAR
+				{ 71202 }, // WEAR_UNIQUE1
+				{ 0 }, // WEAR_UNIQUE2
+				{ 79504 }, // WEAR_ARROW
+				{ 13149 }, // WEAR_SHIELD
+				{ 18089 }, // WEAR_BELT
+#if defined(__PENDANT_SYSTEM__)
+				{ 9800 }, // WEAR_PENDANT
+#endif
+#if defined(__GLOVE_SYSTEM__)
+				{ 23009 }, // WEAR_GLOVE
+#endif
+				{ 0 }, // WEAR_COSTUME_BODY
+				{ 0 }, // WEAR_COSTUME_HAIR
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+				{ 0 }, // WEAR_COSTUME_MOUNT
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+				{ 85004 }, // WEAR_COSTUME_ACCE
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+				{ 0 }, // WEAR_COSTUME_WEAPON
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+				{ 49006 }, // WEAR_COSTUME_AURA
+#endif
+			},
+		},
+		{ JOB_SURA,
+			{
+				{ 20889 }, // WEAR_BODY
+				{ 12489 }, // WEAR_HEAD
+				{ 15449 }, // WEAR_FOOTS
+				{ 14209 }, // WEAR_WRIST
+				{ 309 }, // WEAR_WEAPON
+				{ 16209 }, // WEAR_NECK
+				{ 17549 }, // WEAR_EAR
+				{ 71202 }, // WEAR_UNIQUE1
+				{ 0 }, // WEAR_UNIQUE2
+				{ 13149 }, // WEAR_SHIELD
+				{ 18089 }, // WEAR_BELT
+#if defined(__PENDANT_SYSTEM__)
+				{ 9800 }, // WEAR_PENDANT
+#endif
+#if defined(__GLOVE_SYSTEM__)
+				{ 23009 }, // WEAR_GLOVE
+#endif
+				{ 0 }, // WEAR_COSTUME_BODY
+				{ 0 }, // WEAR_COSTUME_HAIR
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+				{ 0 }, // WEAR_COSTUME_MOUNT
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+				{ 85004 }, // WEAR_COSTUME_ACCE
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+				{ 0 }, // WEAR_COSTUME_WEAPON
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+				{ 49006 }, // WEAR_COSTUME_AURA
+#endif
+			},
+		},
+		{ JOB_SHAMAN,
+			{
+				{ 20899 }, // WEAR_BODY
+				{ 12629 }, // WEAR_HEAD
+				{ 15449 }, // WEAR_FOOTS
+				{ 14209 }, // WEAR_WRIST
+				{ 5169 }, // WEAR_WEAPON
+				{ 16209 }, // WEAR_NECK
+				{ 17549 }, // WEAR_EAR
+				{ 71202 }, // WEAR_UNIQUE1
+				{ 0 }, // WEAR_UNIQUE2
+				{ 13149 }, // WEAR_SHIELD
+				{ 18089 }, // WEAR_BELT
+#if defined(__PENDANT_SYSTEM__)
+				{ 9800 }, // WEAR_PENDANT
+#endif
+#if defined(__GLOVE_SYSTEM__)
+				{ 23009 }, // WEAR_GLOVE
+#endif
+				{ 0 }, // WEAR_COSTUME_BODY
+				{ 0 }, // WEAR_COSTUME_HAIR
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+				{ 0 }, // WEAR_COSTUME_MOUNT
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+				{ 85004 }, // WEAR_COSTUME_ACCE
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+				{ 0 }, // WEAR_COSTUME_WEAPON
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+				{ 49006 }, // WEAR_COSTUME_AURA
+#endif
+			},
+		},
+		{ JOB_WOLFMAN,
+			{
+				{ 20909 }, // WEAR_BODY
+				{ 21509 }, // WEAR_HEAD
+				{ 15449 }, // WEAR_FOOTS
+				{ 14209 }, // WEAR_WRIST
+				{ 6129 }, // WEAR_WEAPON
+				{ 16209 }, // WEAR_NECK
+				{ 17549 }, // WEAR_EAR
+				{ 71202 }, // WEAR_UNIQUE1
+				{ 0 }, // WEAR_UNIQUE2
+				{ 13149 }, // WEAR_SHIELD
+				{ 18089 }, // WEAR_BELT
+#if defined(__PENDANT_SYSTEM__)
+				{ 9800 }, // WEAR_PENDANT
+#endif
+#if defined(__GLOVE_SYSTEM__)
+				{ 23009 }, // WEAR_GLOVE
+#endif
+				{ 0 }, // WEAR_COSTUME_BODY
+				{ 0 }, // WEAR_COSTUME_HAIR
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+				{ 0 }, // WEAR_COSTUME_MOUNT
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+				{ 85004 }, // WEAR_COSTUME_ACCE
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+				{ 0 }, // WEAR_COSTUME_WEAPON
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+				{ 49006 }, // WEAR_COSTUME_AURA
+#endif
+			},
+		},
+	};
+
+	const WearItemMap::iterator& it = mWearItem.find(bJob);
+	if (it != mWearItem.end())
+	{
+		for (const DWORD dwVnum : it->second)
+		{
+			pItem = ITEM_MANAGER::instance().CreateItem(dwVnum, 1, 0, false, -1, false, true);
+			if (!pItem || !pItem->EquipTo(ch, pItem->FindEquipCell(ch)))
+				M2_DESTROY_ITEM(pItem);
+		}
+	}
+
+	ch->ComputePoints();
+}
+
+ACMD(do_attr_full_set)
+{
+	BYTE job = ch->GetJob();
+	LPITEM item;
+
+	switch (job)
+	{
+		case JOB_WARRIOR:
+		case JOB_ASSASSIN:
+		case JOB_SURA:
+		case JOB_SHAMAN:
+		case JOB_WOLFMAN:
+		{
+			//   .
+			// 隔拷  羚底 擔첨    肩 憺 .
+			// WEAR_BODY
+			item = ch->GetWear(WEAR_BODY);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
+				item->SetForceAttribute(1, APPLY_CAST_SPEED, 20);
+				item->SetForceAttribute(2, APPLY_STEAL_HP, 10);
+				item->SetForceAttribute(3, APPLY_REFLECT_MELEE, 10);
+				item->SetForceAttribute(4, APPLY_ATT_GRADE_BONUS, 50);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
+#endif
+				item->SetSocket(0, 28438);
+				item->SetSocket(1, 28441);
+				item->SetSocket(2, 28442);
+			}
+			// WEAR_HEAD
+			item = ch->GetWear(WEAR_HEAD);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetForceAttribute(0, APPLY_ATT_SPEED, 8);
+				item->SetForceAttribute(1, APPLY_HP_REGEN, 30);
+				item->SetForceAttribute(2, APPLY_SP_REGEN, 30);
+				item->SetForceAttribute(3, APPLY_DODGE, 15);
+				item->SetForceAttribute(4, APPLY_STEAL_SP, 10);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
+#endif
+			}
+			// WEAR_FOOTS
+			item = ch->GetWear(WEAR_FOOTS);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
+				item->SetForceAttribute(1, APPLY_MAX_SP, 80);
+				item->SetForceAttribute(2, APPLY_MOV_SPEED, 8);
+				item->SetForceAttribute(3, APPLY_ATT_SPEED, 8);
+				item->SetForceAttribute(4, APPLY_CRITICAL_PCT, 10);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
+#endif
+			}
+			// WEAR_WRIST
+			item = ch->GetWear(WEAR_WRIST);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
+				item->SetForceAttribute(1, APPLY_MAX_SP, 80);
+				item->SetForceAttribute(2, APPLY_PENETRATE_PCT, 10);
+				item->SetForceAttribute(3, APPLY_STEAL_HP, 10);
+				item->SetForceAttribute(4, APPLY_MANA_BURN_PCT, 10);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
+#endif
+				item->SetSocket(0, 3);
+				item->SetSocket(1, 3);
+				item->SetSocket(2, 21600);
+			}
+			// WEAR_WEAPON
+			item = ch->GetWear(WEAR_WEAPON);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetForceAttribute(0, APPLY_NORMAL_HIT_DAMAGE_BONUS, 60);
+				item->SetForceAttribute(1, APPLY_CRITICAL_PCT, 10);
+				item->SetForceAttribute(2, APPLY_PENETRATE_PCT, 10);
+				item->SetForceAttribute(3, APPLY_CAST_SPEED, 20);
+				item->SetForceAttribute(4, APPLY_STR, 12);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_ATTBONUS_PER_MONSTER, 10);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
+#endif
+				item->SetSocket(0, 28437);
+				item->SetSocket(1, 28431);
+				item->SetSocket(2, 28430);
+			}
+			// WEAR_NECK
+			item = ch->GetWear(WEAR_NECK);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetForceAttribute(0, APPLY_MAX_HP, 2000);
+				item->SetForceAttribute(1, APPLY_MAX_SP, 80);
+				item->SetForceAttribute(2, APPLY_CRITICAL_PCT, 10);
+				item->SetForceAttribute(3, APPLY_PENETRATE_PCT, 10);
+				item->SetForceAttribute(4, APPLY_STEAL_SP, 10);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
+#endif
+				item->SetSocket(0, 3);
+				item->SetSocket(1, 3);
+				item->SetSocket(2, 21600);
+			}
+			// WEAR_EAR
+			item = ch->GetWear(WEAR_EAR);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetForceAttribute(0, APPLY_MOV_SPEED, 20);
+				item->SetForceAttribute(1, APPLY_MANA_BURN_PCT, 10);
+				item->SetForceAttribute(2, APPLY_POISON_REDUCE, 5);
+				item->SetForceAttribute(3, APPLY_ATTBONUS_DEVIL, 20);
+				item->SetForceAttribute(4, APPLY_ATTBONUS_UNDEAD, 20);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
+#endif
+				item->SetSocket(0, 3);
+				item->SetSocket(1, 3);
+				item->SetSocket(2, 21600);
+			}
+			// WEAR_SHIELD
+			item = ch->GetWear(WEAR_SHIELD);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetForceAttribute(0, APPLY_CON, 12);
+				item->SetForceAttribute(1, APPLY_BLOCK, 15);
+				item->SetForceAttribute(2, APPLY_REFLECT_MELEE, 10);
+				item->SetForceAttribute(3, APPLY_IMMUNE_STUN, 1);
+				item->SetForceAttribute(4, APPLY_IMMUNE_SLOW, 1);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
+#endif
+			}
+			// WEAR_BELT
+			item = ch->GetWear(WEAR_BELT);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetSocket(0, 3);
+				item->SetSocket(1, 3);
+				item->SetSocket(2, 21600);
+			}
+			// WEAR_PENDANT
+#if defined(__PENDANT_SYSTEM__)
+			item = ch->GetWear(WEAR_PENDANT);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetForceAttribute(0, APPLY_MALL_DEFBONUS, 5);
+				item->SetForceAttribute(1, APPLY_RESIST_ICE, 25);
+				item->SetForceAttribute(2, APPLY_RESIST_EARTH, 25);
+				item->SetForceAttribute(3, APPLY_RESIST_DARK, 25);
+				item->SetForceAttribute(4, APPLY_ATTBONUS_HUMAN, 10);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
+#endif
+			}
+#endif
+			// WEAR_GLOVE
+#if defined(__GLOVE_SYSTEM__)
+			item = ch->GetWear(WEAR_GLOVE);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetForceAttribute(0, APPLY_HIT_PCT, 12);
+				item->SetForceAttribute(1, APPLY_RESIST_HUMAN, 10);
+				item->SetForceAttribute(2, APPLY_RESIST_MOUNT_FALL, 20);
+				item->SetForceAttribute(3, APPLY_REFLECT_MELEE, 10);
+				item->SetForceAttribute(4, APPLY_STR, 12);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_MAX_HP, 500);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 50);
+#endif
+			}
+#endif
+			// WEAR_COSTUME_ACCE
+#if defined(__ACCE_COSTUME_SYSTEM__)
+			item = ch->GetWear(WEAR_COSTUME_ACCE);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetSocket(ITEM_SOCKET_ACCE_DRAIN_ITEM_VNUM, 2209);
+				item->SetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE, ACCE_MAX_DRAINRATE);
+				item->SetForceAttribute(0, APPLY_NORMAL_HIT_DAMAGE_BONUS, 12);
+				item->SetForceAttribute(1, APPLY_CRITICAL_PCT, 2);
+				item->SetForceAttribute(2, APPLY_PENETRATE_PCT, 2);
+				item->SetForceAttribute(3, APPLY_DEX, 3);
+				item->SetForceAttribute(4, APPLY_STR, 3);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_ATTBONUS_STONE, 2);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 12);
+#endif
+			}
+#endif
+			// WEAR_COSTUME_AURA
+#if defined(__AURA_COSTUME_SYSTEM__)
+			item = ch->GetWear(WEAR_COSTUME_AURA);
+			if (item != NULL)
+			{
+				item->ClearAllAttribute();
+				item->SetSocket(ITEM_SOCKET_AURA_DRAIN_ITEM_VNUM, 16209);
+
+				item->SetForceAttribute(0, APPLY_MAX_HP, 500);
+				item->SetForceAttribute(1, APPLY_MAX_SP, 20);
+				item->SetForceAttribute(2, APPLY_CRITICAL_PCT, 2);
+				item->SetForceAttribute(3, APPLY_PENETRATE_PCT, 2);
+				item->SetForceAttribute(4, APPLY_DAMAGE_SP_RECOVER, 2);
+#if defined(__ATTR_6TH_7TH__)
+				item->SetForceAttribute(5, APPLY_MAX_HP, 125);
+				item->SetForceAttribute(6, APPLY_ATT_GRADE_BONUS, 12);
+#endif
+			}
+#endif
+		}
+		break;
+	}
+
+	ch->ComputePoints();
+}
+
+ACMD(do_use_item)
+{
+	char arg1[256];
+
+	one_argument(argument, arg1, sizeof(arg1));
+
+	int cell;
+	str_to_number(cell, arg1);
+
+	LPITEM item = ch->GetInventoryItem(cell);
+	if (item)
+	{
+		ch->UseItem(TItemPos(INVENTORY, cell));
+	}
+	else
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, " 底   .");
+	}
+}
+
+ACMD(do_clear_affect)
+{
+	ch->ClearAffect(true);
+}
+
+struct FuncKillAll
+{
+	LPCHARACTER m_ch;
+
+	FuncKillAll(LPCHARACTER ch) :
+		m_ch(ch)
+	{}
+
+	void operator()(LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+
+			if (m_ch == ch || ch->IsNPC() || ch->IsGM() || ch->IsDead() || ch->GetHP() <= 0)
+				return;
+
+			float fDist = DISTANCE_APPROX(m_ch->GetX() - ch->GetX(), m_ch->GetY() - ch->GetY());
+			if (fDist > 7000.f)
+				return;
+
+			int damage = ch->GetHP() + number(1, 4250);
+			ch->EffectPacket(SE_CRITICAL);
+			ch->PointChange(POINT_HP, -damage, false);
+			ch->Dead();
+		}
+	}
+};
+
+ACMD(do_kill_all)
+{
+	LPSECTREE pSec = ch->GetSectree();
+	if (pSec)
+	{
+		FuncKillAll f(ch);
+		pSec->ForEachAround(f);
+	}
+}
+
+ACMD(do_drop_item)
+{
+	// #Pass 1. With one arg: args[0] = Cell
+	// #Pass 2. With two args: args[0] = BeginCell args[1] = EndCell
+	char args[2][256];
+
+	argument = two_arguments(argument, args[0], 256, args[1], 256);
+	if (!*args[0])
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage:");
+		ch->ChatPacket(CHAT_TYPE_INFO, "/drop_item <SlotPos> or /drop_item <BeginPos> <EndPos>");
+		return;
+	}
+
+	if (!*args[1])
+	{
+		int Cell;
+		str_to_number(Cell, args[0]);
+		if (Cell >= 0 && Cell < INVENTORY_MAX_NUM)
+			ch->DropItem(TItemPos(INVENTORY, Cell));
+		else
+			ch->ChatPacket(CHAT_TYPE_INFO, "Invalid argument! (Cell:%d)", Cell);
+	}
+	else
+	{
+		int beginPos;
+		str_to_number(beginPos, args[0]);
+		int endPos;
+		str_to_number(endPos, args[1]);
+		sys_log(0, "do_drop_item: beginPos: %d, endPos: %d", beginPos, endPos);
+		if (beginPos >= 0 && endPos < INVENTORY_MAX_NUM && beginPos < endPos)
+		{
+			for (int Cell = beginPos; Cell <= endPos; Cell++)
+				ch->DropItem(TItemPos(INVENTORY, Cell));
+		}
+		else
+			ch->ChatPacket(CHAT_TYPE_INFO, "Invalid arguments! (beginPos:%d; endPos:%d)", beginPos, endPos);
+	}
+}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+ACMD(do_dragon_soul)
+{
+	char arg1[512];
+	const char* rest = one_argument(argument, arg1, sizeof(arg1));
+	switch (arg1[0])
+	{
+		case 'a':
+		{
+			one_argument(rest, arg1, sizeof(arg1));
+			int deck_idx = 0;
+			if (str_to_number(deck_idx, arg1) == false)
+			{
+				return;
+			}
+			ch->DragonSoul_ActivateDeck(deck_idx);
+		}
+		break;
+		case 'd':
+		{
+			ch->DragonSoul_DeactivateAll();
+		}
+		break;
+	}
+}
+
+ACMD(do_ds_list)
+{
+	for (int i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; i++)
+	{
+		TItemPos cell(DRAGON_SOUL_INVENTORY, i);
+
+		LPITEM item = ch->GetItem(cell);
+		if (item != NULL)
+			ch->ChatPacket(CHAT_TYPE_INFO, "cell : %d, name : %s, id : %d", item->GetCell(), item->GetName(), item->GetID());
+	}
+}
+
+ACMD(do_ds_qualify)
+{
+	ch->DragonSoul_GiveQualification();
+}
+#endif
+
+#if defined(__INGAME_EVENT_MANAGER__) && defined(__EVENT_BANNER_FLAG__)
+ACMD(do_banner)
+{
+	char arg1[256], arg2[256];
+	int iEnable = 0;
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1 || !*arg2 || !isnhdigit(*arg1))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: /banner <1:0> <banner_name>");
+		ch->ChatPacket(CHAT_TYPE_INFO, "Example: /banner 1 halloween");
+		return;
+	}
+
+	str_to_number(iEnable, arg1);
+
+	CInGameEventManager::instance().SpawnBanners(iEnable, arg2);
+
+	return;
+}
+#endif
+
+#if defined(__CONQUEROR_LEVEL__)
+ACMD(do_conqueror_level)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: conqueror_level <level>");
+		return;
+	}
+
+	int level = 0;
+	str_to_number(level, arg1);
+
+	ch->ResetConquerorPoint(MINMAX(0, level, gPlayerMaxConquerorLevel));
+	ch->ResetConquerorExp();
+}
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+ACMD(do_mini_game_okey)
+{
+	char szArg1[256], szArg2[256], szArg3[256];
+	three_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2), szArg3, sizeof(szArg3));
+	int iEnable = 0, iDropPerKillPct = 100, iNormal = 0;
+
+	if (strlen(szArg1) == 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mini_game_okey <enable_days> <drop_value>");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <enable_days> days / 0 (disable); -1 (disable + disable reward cooldown)");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> default 100");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <normal> default 0");
+		return;
+	}
+
+	if (*szArg1 && !strcmp(szArg1, "-1"))
+		iEnable -= 1;
+	else if (isnhdigit(*szArg1))
+		str_to_number(iEnable, szArg1);
+
+	if (isnhdigit(*szArg2))
+		str_to_number(iDropPerKillPct, szArg2);
+
+	if (isnhdigit(*szArg3))
+		str_to_number(iNormal, szArg3);
+
+	if (iEnable > 0)
+	{
+		DWORD dwEndTime = std::time(nullptr) + (60 * 60 * 24 * iEnable);
+
+		if (iNormal == 0)
+		{
+			quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey", dwEndTime);
+			quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_normal", 0);
+		}
+		else
+		{
+			quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey", 0);
+			quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_normal", dwEndTime);
+		}
+
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_drop", iDropPerKillPct);
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_reward", 0);
+
+		BroadcastNotice(LC_STRING("[Okey Event] The Okey Event has started!"));
+		BroadcastNotice(LC_STRING("[Okey Event] Defeat monsters, collect cards and play a game of okey."));
+		BroadcastNotice(LC_STRING("[Okey Event] Amazing prizes await!"));
+	}
+	else if (iEnable == 0)
+	{
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey", 0);
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_normal", 0);
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_reward",
+			std::time(nullptr) + CMiniGameRumi::RUMI_REWARD_COOLDOWN);
+
+		BroadcastNotice(LC_STRING("[Okey Event] The Okey Event is over!"));
+		BroadcastNotice(LC_STRING("[Okey Event] If you make it into the top rankings, you have 7 days to collect your prize."));
+	}
+	else
+	{
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey", 0);
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_normal", 0);
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_okey_reward", -1); // -1 to remove the event npc.
+
+		BroadcastNotice(LC_STRING("[Okey Event] The Okey Event is over!"));
+	}
+}
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__)
+ACMD(do_mini_game_yutnori)
+{
+	char szArg1[256], szArg2[256];
+	two_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2));
+	int iEnable = 0, iDropPerKillPct = 100;
+
+	if (strlen(szArg1) == 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mini_game_yutnori <enable_days> <drop_value>");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <enable_days> days / 0 (disable); -1 (disable + disable reward cooldown)");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> default 100");
+		return;
+	}
+
+	if (*szArg1 && !strcmp(szArg1, "-1"))
+		iEnable -= 1;
+	else if (isnhdigit(*szArg1))
+		str_to_number(iEnable, szArg1);
+
+	if (isnhdigit(*szArg2))
+		str_to_number(iDropPerKillPct, szArg2);
+
+	if (iEnable > 0)
+	{
+		DWORD dwEndTime = std::time(nullptr) + (60 * 60 * 24 * iEnable);
+
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori", dwEndTime);
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori_drop", iDropPerKillPct);
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori_reward", 0);
+
+		BroadcastNotice(LC_STRING("Yut Nori has started!"));
+		BroadcastNotice(LC_STRING("Collect Birch Branches, craft Yut Nori Boards from them and play the exciting minigame."));
+		BroadcastNotice(LC_STRING("Fantastic prizes await!"));
+	}
+	else if (iEnable == 0)
+	{
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori", 0);
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori_reward",
+			std::time(nullptr) + CMiniGameYutnori::YUTNORI_REWARD_COOLDOWN);
+
+		BroadcastNotice(LC_STRING("Yut Nori has finished."));
+		BroadcastNotice(LC_STRING("Go to the Yut Nori Table to collect your reward."));
+	}
+	else
+	{
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori", 0);
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_yutnori_reward", -1); // -1 to remove the event npc.
+
+		BroadcastNotice(LC_STRING("Yut Nori has finished."));
+	}
+}
+#endif
+
+#if defined(__FLOWER_EVENT__)
+ACMD(do_flower_event)
+{
+	char szArg1[256], szArg2[256];
+	two_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2));
+	int iDropPerKillPct = 100;
+
+	if (strlen(szArg1) == 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: flower_event <drop_value>");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> value / 0 (disable)");
+		return;
+	}
+
+	if (isnhdigit(*szArg1))
+		str_to_number(iDropPerKillPct, szArg1);
+
+	if (iDropPerKillPct != 0)
+	{
+		quest::CQuestManager::instance().RequestSetEventFlag("e_flower_drop", iDropPerKillPct);
+		BroadcastNotice(LC_STRING("The Flower Power Event has started."));
+	}
+	else
+	{
+		quest::CQuestManager::instance().RequestSetEventFlag("e_flower_drop", 0);
+		BroadcastNotice(LC_STRING("The Flower Power Event has ended."));
+	}
+}
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__)
+ACMD(do_mini_game_catchking)
+{
+	char szArg1[256], szArg2[256];
+	two_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2));
+	int iEnable = 0, iDropPerKillPct = 100;
+
+	if (strlen(szArg1) == 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mini_game_catchking <enable_days> <drop_value>");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <enable_days> days / 0 (disable)");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> default 100");
+		return;
+	}
+
+	if (isnhdigit(*szArg1))
+		str_to_number(iEnable, szArg1);
+
+	if (isnhdigit(*szArg2))
+		str_to_number(iDropPerKillPct, szArg2);
+
+	if (iEnable != 0)
+	{
+		DWORD dwEndTime = std::time(nullptr) + (60 * 60 * 24 * iEnable);
+
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_catchking", dwEndTime);
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_catchking_drop", iDropPerKillPct);
+
+		BroadcastNotice(LC_STRING("[Catch the King] Play a game of Catch the King now!"));
+		BroadcastNotice(LC_STRING("[Catch the King] Defeat monsters to collect King Cards. You need 25 cards for a King Deck."));
+		BroadcastNotice(LC_STRING("[Catch the King] Loads of great prizes await!"));
+		BroadcastNotice(LC_STRING("[Catch the King] If you make it into the top rankings, you'll receive your prize from the game table."));
+	}
+	else
+	{
+		quest::CQuestManager::instance().RequestSetEventFlag("mini_game_catchking", 0);
+
+		BroadcastNotice(LC_STRING("[Catch the King] Catch the King has ended."));
+	}
+}
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+ACMD(do_snowflake_stick_event)
+{
+	char szArg1[256], szArg2[256];
+	two_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2));
+	int iEnable = 0, iDropPerKillPct = 100;
+
+	if (strlen(szArg1) == 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: snowflake_stick_event <enable_days> <drop_value>");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <enable_days> days / 0 (disable)");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> default 100");
+		return;
+	}
+
+	if (isnhdigit(*szArg1))
+		str_to_number(iEnable, szArg1);
+
+	if (isnhdigit(*szArg2))
+		str_to_number(iDropPerKillPct, szArg2);
+
+	if (iEnable != 0)
+	{
+		DWORD dwEndTime = std::time(nullptr) + (60 * 60 * 24 * iEnable);
+		quest::CQuestManager::instance().RequestSetEventFlag("snowflake_stick_event", dwEndTime);
+		quest::CQuestManager::instance().RequestSetEventFlag("snowflake_stick_drop", iDropPerKillPct);
+	}
+	else
+	{
+		quest::CQuestManager::instance().RequestSetEventFlag("snowflake_stick_event", 0);
+	}
+}
+#endif
+
+#if defined(__CHECK_PORT_STATUS__)
+ACMD(do_portstatus)
+{
+	char szArg1[256];
+	one_argument(argument, szArg1, sizeof(szArg1));
+	int iListenPort = 0;
+
+	if (strlen(szArg1) == 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: portstatus <port>");
+		return;
+	}
+
+	if (isnhdigit(*szArg1))
+	{
+		str_to_number(iListenPort, szArg1);
+
+		socket_t socket = socket_connect(g_szPublicIP, static_cast<WORD>(iListenPort));
+		if (socket != INVALID_SOCKET)
+		{
+			socket_close(socket);
+
+			ch->ChatPacket(CHAT_TYPE_INFO, "Port %d is available.", iListenPort);
+		}
+		else
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "Port %d is not available.", iListenPort);
+		}
+	}
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: portstatus <channel> <port>");
+}
+#endif
+
+ACMD(do_view_equip)
+{
+	char szArg1[256];
+	one_argument(argument, szArg1, sizeof(szArg1));
+
+	if (!*szArg1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: view_equip <character name>");
+		return;
+	}
+
+	LPCHARACTER pTargetChar = CHARACTER_MANAGER::instance().FindPC(szArg1);
+	if (NULL == pTargetChar)
+	{
+		const CCI* pkCCI = P2P_MANAGER::instance().Find(szArg1);
+		if (pkCCI && pkCCI->pkDesc)
+			pTargetChar = pkCCI->pkDesc->GetCharacter();
+		else
+			pTargetChar = NULL;
+	}
+
+	if (pTargetChar && pTargetChar->IsPC())
+		pTargetChar->SendEquipment(ch);
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, "%s is not online or doesn't exist.", szArg1);
+}
+
+ACMD(do_loglevel)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	unsigned int level = 0;
+	str_to_number(level, arg1);
+
+	char buf[255 + 1];
+	snprintf(buf, sizeof(buf), "LOG LEVEL : %d", level);
+	sys_log(0, buf);
+
+	log_set_level(level);
+}
+
+struct ClearGroundItems
+{
+	void operator () (LPENTITY ent)
+	{
+		if (!ent->IsType(ENTITY_ITEM))
+			return;
+
+		LPITEM item = (LPITEM)ent;
+		if (item) M2_DESTROY_ITEM(item);
+	}
+};
+
+ACMD(do_clear_ground)
+{
+	ClearGroundItems func;
+	LPSECTREE sectree = ch->GetSectree();
+	if (sectree)
+		sectree->ForEachAround(func);
+}
+
+struct whisper_notice_packet_func
+{
+	const char* m_str;
+	whisper_notice_packet_func(const char* str) : m_str(str) {}
+
+	void operator() (LPDESC d)
+	{
+		if (d->GetCharacter() == NULL)
+			return;
+
+		TPacketGCWhisper pack;
+
+		int len = MIN(CHAT_MAX_LEN, strlen(m_str) + 1);
+
+		pack.bHeader = HEADER_GC_WHISPER;
+		pack.wSize = sizeof(TPacketGCWhisper) + len;
+		pack.bType = WHISPER_TYPE_SYSTEM;
+		strlcpy(pack.szNameFrom, "[LC;5452]", sizeof(pack.szNameFrom));
+
+		TEMP_BUFFER buf;
+
+		buf.write(&pack, sizeof(TPacketGCWhisper));
+		buf.write(m_str, len);
+		d->Packet(buf.read_peek(), buf.size());
+	}
+};
+
+void SendWhisperNotice(const char* c_pszBuf)
+{
+	const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
+	std::for_each(c_ref_set.begin(), c_ref_set.end(), whisper_notice_packet_func(c_pszBuf));
+}
+
+ACMD(do_whisper_notice)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	SendWhisperNotice(arg1);
+}
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+ACMD(do_mini_game_roulette)
+{
+	char szArg1[256], szArg2[256];
+	two_arguments(argument, szArg1, sizeof(szArg1), szArg2, sizeof(szArg2));
+	int iEnable = 0, iDropPerKillPct = 100;
+
+	if (strlen(szArg1) == 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: mini_game_roulette <enable_days> <drop_value>");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <enable_days> days / 0 (disable);");
+		ch->ChatPacket(CHAT_TYPE_INFO, "       <drop_value> default 100");
+		return;
+	}
+
+	if (isnhdigit(*szArg1))
+		str_to_number(iEnable, szArg1);
+
+	if (isnhdigit(*szArg2))
+		str_to_number(iDropPerKillPct, szArg2);
+
+	if (iEnable > 0)
+	{
+		DWORD dwEndTime = std::time(nullptr) + (60 * 60 * 24 * iEnable);
+
+		quest::CQuestManager::instance().RequestSetEventFlag("e_late_summer", dwEndTime);
+		quest::CQuestManager::instance().RequestSetEventFlag("e_late_summer_drop", iDropPerKillPct);
+
+		BroadcastNotice(LC_STRING("The Altar of Blood has appeared."));
+	}
+	else if (iEnable == 0)
+	{
+		quest::CQuestManager::instance().RequestSetEventFlag("e_late_summer", 0);
+		quest::CQuestManager::instance().RequestSetEventFlag("e_late_summer_drop", 0);
+	}
+}
+#endif
+
+#if defined(__DEFENSE_WAVE__)
+ACMD(do_dw_create)
+{
+	LPDEFENSE_WAVE pDefenseWave = CDefenseWaveManager::Instance().Create(MAP_DEFENSEWAVE);
+	if (pDefenseWave == NULL)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Cannot create CDefenseWave on OriginalMapIndex %ld", MAP_DEFENSEWAVE);
+		return;
+	}
+
+	ch->ChatPacket(CHAT_TYPE_INFO, "CDefenseWave Created %u", pDefenseWave->GetId());
+	pDefenseWave->Initialize();
+	pDefenseWave->Enter(ch);
+	pDefenseWave->Start();
+}
+#endif
+
+#ifdef __OFFLINE_SHOP__
+ACMD(do_deleteshop)
+{
+	char arg1[256];
+	one_argument(argument, arg1, sizeof(arg1));
+
+	if (!*arg1)
+		return;
+
+	DWORD vid = 0;
+	str_to_number(vid, arg1);
+
+	COfflineShop::GM_CloseShop(ch, vid);
+}
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+#include "battlepass_manager.h"
+ACMD(do_battlepass_get_info)
+{
+	if (CBattlePassManager::instance().GetNormalBattlePassID() == 0) 
+		ch->ChatPacket(CHAT_TYPE_INFO, "No normal Battlepass is currently active");
+	else
+	{
+		std::unique_ptr<SQLMsg> pMsgRegistred(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 1 and battlepass_id = %d", CBattlePassManager::instance().GetNormalBattlePassID()));
+		std::unique_ptr<SQLMsg> pMsgCompledet(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 1 and battlepass_id = %d and battlepass_completed = 1", CBattlePassManager::instance().GetNormalBattlePassID()));
+		if (!pMsgRegistred->uiSQLErrno and !pMsgCompledet->uiSQLErrno)
+		{
+			MYSQL_ROW row_registred = mysql_fetch_row(pMsgRegistred->Get()->pSQLResult);
+			MYSQL_ROW row_compledet = mysql_fetch_row(pMsgCompledet->Get()->pSQLResult);
+			
+			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
+			ch->ChatPacket(CHAT_TYPE_INFO, "Actual Normal Battlepass ID = %d", CBattlePassManager::instance().GetNormalBattlePassID());
+			ch->ChatPacket(CHAT_TYPE_INFO, "Registred Player for Normal Battlepass = %d", std::atoi(row_registred[0]));
+			ch->ChatPacket(CHAT_TYPE_INFO, "Finish Player for Normal Battlepass = %d / %d", std::atoi(row_compledet[0]), std::atoi(row_registred[0]));
+			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
+		}
+	}
+		
+	if (CBattlePassManager::instance().GetPremiumBattlePassID() == 0) 
+		ch->ChatPacket(CHAT_TYPE_INFO, "No premium Battlepass is currently active");
+	else
+	{
+		std::unique_ptr<SQLMsg> pMsgRegistred(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 2 and battlepass_id = %d", CBattlePassManager::instance().GetPremiumBattlePassID()));
+		std::unique_ptr<SQLMsg> pMsgCompledet(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 2 and battlepass_id = %d and battlepass_completed = 1", CBattlePassManager::instance().GetPremiumBattlePassID()));
+		if (!pMsgRegistred->uiSQLErrno and !pMsgCompledet->uiSQLErrno)
+		{
+			MYSQL_ROW row_registred = mysql_fetch_row(pMsgRegistred->Get()->pSQLResult);
+			MYSQL_ROW row_compledet = mysql_fetch_row(pMsgCompledet->Get()->pSQLResult);
+			
+			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
+			ch->ChatPacket(CHAT_TYPE_INFO, "Actual Premium Battlepass ID = %d", CBattlePassManager::instance().GetPremiumBattlePassID());
+			ch->ChatPacket(CHAT_TYPE_INFO, "Registred Player for Premium Battlepass = %d",  std::atoi(row_registred[0]));
+			ch->ChatPacket(CHAT_TYPE_INFO, "Finish Player for Premium Battlepass = %d / %d", std::atoi(row_compledet[0]), std::atoi(row_registred[0]));
+			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
+		}
+	}
+		
+	if (CBattlePassManager::instance().GetEventBattlePassID() == 0) 
+		ch->ChatPacket(CHAT_TYPE_INFO, "No event Battlepass is currently active");
+	else
+	{
+		std::unique_ptr<SQLMsg> pMsgRegistred(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 3 and battlepass_id = %d", CBattlePassManager::instance().GetEventBattlePassID()));
+		std::unique_ptr<SQLMsg> pMsgCompledet(DBManager::instance().DirectQuery("SELECT COUNT(*) FROM `battlepass_playerindex` WHERE battlepass_type = 3 and battlepass_id = %d and battlepass_completed = 1", CBattlePassManager::instance().GetEventBattlePassID()));
+		if (!pMsgRegistred->uiSQLErrno and !pMsgCompledet->uiSQLErrno)
+		{
+			MYSQL_ROW row_registred = mysql_fetch_row(pMsgRegistred->Get()->pSQLResult);
+			MYSQL_ROW row_compledet = mysql_fetch_row(pMsgCompledet->Get()->pSQLResult);
+			
+			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
+			ch->ChatPacket(CHAT_TYPE_INFO, "Actual Event Battlepass ID = %d", CBattlePassManager::instance().GetEventBattlePassID());
+			ch->ChatPacket(CHAT_TYPE_INFO, "Registred Player for Event Battlepass = %d", std::atoi(row_registred[0]));
+			ch->ChatPacket(CHAT_TYPE_INFO, "Finish Player for Event Battlepass = %d / %d", std::atoi(row_compledet[0]), std::atoi(row_registred[0]));
+			ch->ChatPacket(CHAT_TYPE_INFO, "---------------------------------------------------------------");
+		}
+	}
+}
+
+ACMD(do_battlepass_set_mission)
+{
+	char arg1[256], arg2[256], arg3[256], arg4[256];
+	four_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2), arg3, sizeof(arg3), arg4, sizeof(arg4));
+	
+	if (!*arg1 || !*arg2 || !*arg3)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: battlepass_set_mission <battlepass_type> <mission_index> <value> (<playername>)");
+		ch->ChatPacket(CHAT_TYPE_INFO, "battlepass_type: 1 = NORMAL | 2 = PREMIUM | 3 = EVENT");
+		ch->ChatPacket(CHAT_TYPE_INFO, "mission_index: mission index means the number of the mission counted from the top starting with 1");
+		ch->ChatPacket(CHAT_TYPE_INFO, "value: input the value what you will override");
+		return;
+	}
+	
+	int battlepass_type, mission_index, value;
+	str_to_number(battlepass_type, arg1);
+	str_to_number(mission_index, arg2);
+	str_to_number(value, arg3);
+	
+	value = MAX(0, value);
+	
+	if (battlepass_type == 1 and CBattlePassManager::instance().GetNormalBattlePassID() == 0) {
+		ch->ChatPacket(CHAT_TYPE_INFO, "No normal Battlepass is currently active");
+		return;
+	}
+	if (battlepass_type == 2 and CBattlePassManager::instance().GetPremiumBattlePassID() == 0) {
+		ch->ChatPacket(CHAT_TYPE_INFO, "No premium Battlepass is currently active");
+		return;
+	}
+	if (battlepass_type == 3 and CBattlePassManager::instance().GetEventBattlePassID() == 0) {
+		ch->ChatPacket(CHAT_TYPE_INFO, "No event Battlepass is currently active");
+		return;
+	}
+	
+	LPCHARACTER tch;
+	
+	if (*arg4 && ch->GetName() != arg4)
+		tch = CHARACTER_MANAGER::instance().FindPC(arg4);
+	else
+		tch = CHARACTER_MANAGER::instance().FindPC(ch->GetName());
+
+	if (!tch) {
+		ch->ChatPacket(CHAT_TYPE_INFO, "This player is not online or does not exist.");
+		return;
+	}
+	if (battlepass_type == 2 and CBattlePassManager::instance().GetPremiumBattlePassID() != tch->GetExtBattlePassPremiumID()) {
+		ch->ChatPacket(CHAT_TYPE_INFO, "This player does not have access to the current Premium Battle Pass.");
+		return;
+	}
+	DWORD mission_type = CBattlePassManager::instance().GetMissionTypeByIndex(battlepass_type, mission_index);
+	if (mission_type == 0){
+		ch->ChatPacket(CHAT_TYPE_INFO, "There is no mission index %d in battlepass-typ %d", mission_index, battlepass_type);
+		return;
+	}
+	
+	tch->SetExtBattlePassMissionProgress(battlepass_type, mission_index, mission_type, value);
+}
+
+ACMD(do_battlepass_premium_activate)
+{
+	char arg1[256], arg2[256];
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	int value;
+	str_to_number(value, arg2);
+	
+	if (!*arg1 || !*arg2 || value > 1)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Syntax: battlepass_premium_activate <playername> <activate = 1 / deactivate = 0>");
+		return;
+	}
+	
+	if (CBattlePassManager::instance().GetPremiumBattlePassID() == 0) {
+		ch->ChatPacket(CHAT_TYPE_INFO, "No premium Battlepass is currently active");
+		return;
+	}
+		
+	if (ch->GetName() != arg1) {
+		LPCHARACTER tch = CHARACTER_MANAGER::instance().FindPC(arg1);
+		if (!tch)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, "This player is not online or does not exist.");
+			return;
+		}	
+			
+		if (value == 1)
+		{
+			tch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, CBattlePassManager::instance().GetPremiumBattlePassID());
+			CBattlePassManager::instance().BattlePassRequestOpen(tch, false);
+			tch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NOW_IS_ACTIVATED_PREMIUM_BATTLEPASS"));
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_CMDGM_ACTIVATE_PREMIUM_TO_PLAYER"), tch->GetName());
+		}
+		if (value == 0)
+		{
+			tch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, 0);
+			tch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_CMDGM_DEACTIVATE_PREMIUM_PLAYER"));
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_CMDGM_DEACTIVATE_PREMIUM_TO_PLAYER"), tch->GetName());
+		}
+	}
+	else
+	{
+		if (value == 1)
+		{
+			ch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, CBattlePassManager::instance().GetPremiumBattlePassID());
+			CBattlePassManager::instance().BattlePassRequestOpen(ch, false);
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NOW_IS_ACTIVATED_PREMIUM_BATTLEPASS_OWN"));
+		}
+		if (value == 0)
+		{
+			ch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, 0);
+			CBattlePassManager::instance().BattlePassRequestOpen(ch, false);
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_CMDGM_DEACTIVATE_PREMIUM_OWN"));
+		}
+	}
+}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+#include "growth_pet.h"
+
+const char* pet_set_fields[] = {
+	"level",
+	"evo",
+	"type",
+	"exp",
+	"iexp",
+	"hp",
+	"sp",
+	"def",
+	"itemevo",
+	"time",
+	"age",
+	"\n",
+};
+
+ACMD(do_pet_set)
+{
+	char arg1[256], arg2[256];
+
+	int i, len;
+
+	two_arguments(argument, arg1, sizeof(arg1), arg2, sizeof(arg2));
+
+	if (!*arg1 || !*arg2)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Usage: pet_set <field> <value>");
+		return;
+	}
+
+	if(!ch->GetActiveGrowthPet())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "You need to summon your pet first.");
+		return;
+	}
+
+	len = strlen(arg1);
+
+	for (i = 0; *(pet_set_fields[i]) != '\n'; i++)
+		if (!strncmp(arg1, pet_set_fields[i], len))
+			break;
+
+	switch (i)
+	{
+		case 0: // Level
+		{
+			int level = 0;
+			str_to_number(level, arg2);
+
+			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_PET_LEVEL, level, true);
+		}
+		break;
+
+		case 1: // Evolution
+		{
+			int evolution = 0;
+			str_to_number(evolution, arg2);
+
+			ch->GetActiveGrowthPet()->Evolve(evolution);
+		}
+		break;
+
+		case 2: // Type
+		{
+			int type = 0;
+			str_to_number(type, arg2);
+		}
+		break;
+
+		case 3: // EXP
+		{
+			int exp = 0;
+			str_to_number(exp, arg2);
+
+			ch->GetActiveGrowthPet()->RewardEXP(EXP_TYPE_MOB, exp);
+		}
+		break;
+
+		case 4: // Item EXP
+		{
+			int item_exp = 0;
+			str_to_number(item_exp, arg2);
+
+			ch->GetActiveGrowthPet()->RewardEXP(EXP_TYPE_ITEM, item_exp);
+		}
+		break;
+
+		case 5: // HP
+		{
+			int hp = 0;
+			str_to_number(hp, arg2);
+
+			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_PET_HP, hp, true);
+		}
+		break;
+
+		case 6: // SP
+		{
+			int sp = 0;
+			str_to_number(sp, arg2);
+
+			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_PET_SP, sp, true);
+		}
+		break;
+
+		case 7: // Def
+		{
+			int def = 0;
+			str_to_number(def, arg2);
+
+			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_PET_DEF_GRADE, def, true);
+		}
+		break;
+
+		case 8: // Evolution Items
+		{
+			int evolution = 0;
+			str_to_number(evolution, arg2);
+
+			if (!arPetEvolutionTable[evolution - 2].szEvolutionName)
+				return;
+
+			for (int i = 0; i < PET_EVOL_MAX_ITEM_COUNT; ++i)
+			{
+				std::pair<DWORD, WORD> itemPair = arPetEvolutionTable[evolution - 2].dwItems[i];
+				ch->AutoGiveItem(itemPair.first, itemPair.second);
+			}
+		}
+		break;
+		
+		case 9: // Time
+		{
+			int endtime = 0;
+			str_to_number(endtime, arg2);
+
+			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_DURATION, time(0) + endtime, true);
+			ch->GetActiveGrowthPet()->GetSummonItem()->SetSocket(0, time(0) + endtime);
+		}
+		break;
+
+		case 10: // Age
+		{
+			int age = 0;
+			str_to_number(age, arg2); // (Day count)
+			DWORD dwAge = time(0) - (age * 3600 * 24);
+			ch->GetActiveGrowthPet()->ChangePetPoint(POINT_UPBRINGING_BIRTHDAY, dwAge, true);
+		}
+		break;
+	}
+}
+#endif
diff --git a/server/server/home/metin2/Source/Server/game/src/constants.cpp b/server/server/home/metin2/Source/Server/game/src/constants.cpp
index 8af88bb..7c43363 100644
--- a/server/server/home/metin2/Source/Server/game/src/constants.cpp
+++ b/server/server/home/metin2/Source/Server/game/src/constants.cpp
@@ -1,1946 +1,1946 @@
-#include "stdafx.h"
-#include "char.h"
-
-#ifdef __GROWTH_PET_SYSTEM__
-const TPetEvolution arPetEvolutionTable[3] =
-{
-	// Young ? Wild
-	{
-		40, // Required Level
-		"the level Wild",
-		{
-			{55003,	10}, // Young Pet Book
-			{30058, 10}, // Spider Egg Sack
-			{30073, 10}, // White Hairband+
-			{30041, 10}, // Shiriken
-			{30017, 10}, // Ornamental Hairpin
-			{30074, 5},	 // Black Uniform+
-			{30088, 5},	 // Piece of Ice+
-		}
-	},
-
-	// Wild ? Valiant
-	{
-		80, // Required Level
-		"the level Valiant",
-		{
-			{55004, 10}, // Wild Pet Book
-			{27994, 2},  // Blood-Red Pearl
-			{30035, 10}, // Face Cream
-			{30089, 10}, // Yeti Fur+
-			{30031, 10}, // Ornament
-			{30011, 10}, // Ball
-			{30080, 5},  // Curse Book+
-		}
-	},
-
-	// Valiant ? Heroic
-	{
-		81, // Required Level
-		"the level Heroic",
-		{
-			{55005, 10}, // Valiant Pet Book
-			{30083, 10}, // Unknown Medicine+
-			{27992, 2},  // White Pearl
-			{27993, 2},  // Blue Pearl
-			{30086, 10}, // Demon?s Keepsake+
-			{30077, 10}, // Orc Tooth+
-			{30550, 5},  // Blue Belt
-		}
-	},
-};
-
-const TPetHatch arPetHatchTable[PET_MAX_NUM] =
-{
-	{ PET_MONKEY,			2, 1, 14 },
-	{ PET_SPIDER,			2, 1, 14 },
-	{ PET_RAZADOR,			3, 1, 14 },
-	{ PET_NEMERE,			3, 1, 14 },
-	{ PET_BLUE_DRAGON,		3, 1, 14 },
-	{ PET_RED_DRAGON,		3, 15, 45 },
-	{ PET_AZRAEL,			2, 1, 14 },
-	{ PET_MINI_EXECUTOR,	3, 1, 14 },
-	{ PET_BASHIIDO,			3, 7, 28 },
-	{ PET_NESSIE,			3, 15, 45 },
-	{ PET_EXEDYAR,			3, 15, 45 },
-};
-
-const TPetBonus arPetHPBonusTable[PET_MAX_BONUS_NUM] =
-{
-	{1,	5},
-	{2,	3},
-	{1, 7},
-	{3, 4},
-	{1, 9},
-	{5, 6},
-	{1, 10},
-	{5, 7},
-};
-
-const TPetBonus arPetSPBonusTable[PET_MAX_BONUS_NUM] =
-{
-	{1, 2},
-	{2, 3},
-	{1, 3},
-	{3, 4},
-	{1, 4},
-	{4, 5},
-	{1, 6},
-	{5, 6},
-};
-
-const TPetBonus arPetDefBonusTable[PET_MAX_BONUS_NUM] =
-{
-	{1, 5},
-	{2, 3},
-	{1, 7},
-	{3, 4},
-	{1, 9},
-	{4, 5},
-	{1, 11},
-	{5, 6},
-};
-#endif
-
-TJobInitialPoints JobInitialPoints[JOB_MAX_NUM] =
-/*
-{
-	int st, ht, dx, iq;
-	int max_hp, max_sp;
-	int hp_per_ht, sp_per_iq;
-	int hp_per_lv_begin, hp_per_lv_end;
-	int sp_per_lv_begin, sp_per_lv_end;
-	int max_stamina;
-	int stamina_per_con;
-	int stamina_per_lv_begin, stamina_per_lv_end;
-}
-*/
-{
-	//	str	con	dex	int	초기HP	초기SP	CON/HP	INT/SP	HP랜덤/lv	MP랜덤/lv	초기stam	stam/con	stam/lv
-	{	 6,	4,	3,	3,	600,	200,	40,		20,		36,	44,		18,	22,		800,		5,			1,	3 }, // JOB_WARRIOR 16
-	{	 4,	3,	6,	3,	650,	200,	40,		20,		36,	44,		18,	22,		800,		5,			1,	3 }, // JOB_ASSASSIN 16
-	{	 5,	3,	3,	5,	650,	200,	40,		20,		36,	44,		18,	22,		800,		5,			1,	3 }, // JOB_SURA 16
-	{	 3,	4,	3,	6,	700,	200,	40,		20,		36,	44,		18,	22,		800,		5,			1,	3 }, // JOB_SHAMAN 16
-	{	 2,	6,	6,	2,	600,	200,	40,		20,		36,	44,		18,	22,		800,		5,			1,	3 }, // JOB_WOLFMAN 16
-};
-
-const TMobRankStat MobRankStats[MOB_RANK_MAX_NUM] =
-/*
-{
-	int iGoldPercent;
-}
-*/
-{
-	{ 20, }, // MOB_RANK_PAWN,
-	{ 20, }, // MOB_RANK_S_PAWN,
-	{ 25, }, // MOB_RANK_KNIGHT,
-	{ 30, }, // MOB_RANK_S_KNIGHT,
-	{ 50, }, // MOB_RANK_BOSS,
-	{ 100, } // MOB_RANK_KING,
-};
-
-TBattleTypeStat BattleTypeStats[BATTLE_TYPE_MAX_NUM] =
-/*
-{
-	int AttGradeBias;
-	int DefGradeBias;
-	int MagicAttGradeBias;
-	int MagicDefGradeBias;
-}
-*/
-{
-	{ 0, 0, 0, -10 }, // BATTLE_TYPE_MELEE,
-	{ 10, -20, -10, -15 }, // BATTLE_TYPE_RANGE,
-	{ -5, -5, 10, 10 }, // BATTLE_TYPE_MAGIC,
-	{ 0, 0, 0, 0 }, // BATTLE_TYPE_SPECIAL,
-	{ 10, -10, 0, -15 }, // BATTLE_TYPE_POWER,
-	{ -10, 10, -10, 0 }, // BATTLE_TYPE_TANKER,
-	{ 20, -20, 0, -10 }, // BATTLE_TYPE_SUPER_POWER,
-	{ -20, 20, -10, 0 }, // BATTLE_TYPE_SUPER_TANKER,
-};
-
-const DWORD* exp_table = NULL;
-const DWORD exp_table_common[PLAYER_EXP_TABLE_MAX + 1] =
-{
-	0, // 0
-	300,
-	800,
-	1500,
-	2500,
-	4300,
-	7200,
-	11000,
-	17000,
-	24000,
-	33000, // 10
-	43000,
-	58000,
-	76000,
-	100000,
-	130000,
-	169000,
-	219000,
-	283000,
-	365000,
-	472000, // 20
-	610000,
-	705000,
-	813000,
-	937000,
-	1077000,
-	1237000,
-	1418000,
-	1624000,
-	1857000,
-	2122000, // 30
-	2421000,
-	2761000,
-	3145000,
-	3580000,
-	4073000,
-	4632000,
-	5194000,
-	5717000,
-	6264000,
-	6837000, // 40
-	7600000,
-	8274000,
-	8990000,
-	9753000,
-	10560000,
-	11410000,
-	12320000,
-	13270000,
-	14280000,
-	15340000, // 50
-	16870000,
-	18960000,
-	19980000,
-	21420000,
-	22930000,
-	24530000,
-	26200000,
-	27960000,
-	29800000,
-	32780000, // 60
-	36060000,
-	39670000,
-	43640000,
-	48000000,
-	52800000,
-	58080000,
-	63890000,
-	70280000,
-	77310000,
-	85040000, // 70
-	93540000,
-	102900000,
-	113500000,
-	121000000,
-	137000000,
-	150700000,
-	165700000,
-	236990000,
-	260650000,
-	286780000, // 80
-	315000000,
-	346970000,
-	381680000,
-	419770000,
-	461760000,
-	508040000,
-	558740000,
-	614640000,
-	676130000,
-	743730000, // 90
-	1041222000,
-	1145344200,
-	1259878620,
-	1385866482,
-	1524453130,
-	1676898443,
-	1844588288,
-	2029047116,
-	2050000000, // 99레벨 일 때 필요경험치 (100레벨이 되기 위한)
-	2150000000, // 100
-	2210000000,
-	2250000000,
-	2280000000,
-	2310000000,
-	2340000000,
-	2370000000,
-	2400000000,
-	2430000000,
-	2460000000,
-	2490000000, // 110
-	2520000000,
-	2550000000,
-	2580000000,
-	2610000000,
-	2640000000,
-	2670000000,
-	2700000000,
-	2730000000,
-	2760000000,
-	2790000000, // 120
-};
-
-#if defined(__CONQUEROR_LEVEL__)
-const DWORD* conqueror_exp_table = NULL;
-const DWORD conqueror_exp_table_common[PLAYER_CONQUEROR_EXP_TABLE_MAX + 1] =
-{
-	0, // 0
-	433400,
-	1300204,
-	2600413,
-	4334029,
-	6501054,
-	9101490,
-	12135339,
-	15602603,
-	19503284,
-	23837384, // 10
-	28604905,
-	33805849,
-	39440218,
-	45508014,
-	52009239,
-	58943895,
-	66311984,
-	74113508,
-	82348469,
-	91016869, // 20
-	100118710,
-	109653994,
-	119622723,
-	130024899,
-	140860524,
-	152129600,
-	163832129,
-	175968113,
-	188537554,
-	188537554, // 30
-};
-#endif
-
-const int* aiPercentByDeltaLev = NULL;
-const int* aiPercentByDeltaLevForBoss = NULL;
-
-// 적과 나와의 레벨차이에 의한 계산에 사용되는 테이블
-// MIN(MAX_EXP_DELTA_OF_LEV - 1, (적렙 + 15) - 내렙))
-const int aiPercentByDeltaLevForBoss_euckr[MAX_EXP_DELTA_OF_LEV] =
-{
-	1,		// -15	0
-	3,		// -14	1
-	5,		// -13	2
-	7,		// -12	3
-	15,		// -11	4
-	30,		// -10	5
-	60,		// -9	6
-	90,		// -8	7
-	91,		// -7	8
-	92,		// -6	9
-	93,		// -5	10
-	94,		// -4	11
-	95,		// -3	12
-	97,		// -2	13
-	99,		// -1	14
-	100,	// 0	15
-	105,	// 1	16
-	110,	// 2	17
-	115,	// 3	18
-	120,	// 4	19
-	125,	// 5	20
-	130,	// 6	21
-	135,	// 7	22
-	140,	// 8	23
-	145,	// 9	24
-	150,	// 10	25
-	155,	// 11	26
-	160,	// 12	27
-	165,	// 13	28
-	170,	// 14	29
-	180,	// 15	30
-};
-
-const int aiPercentByDeltaLev_euckr[MAX_EXP_DELTA_OF_LEV] =
-{
-	1,		// -15	0
-	5,		// -14	1
-	10,		// -13	2
-	20,		// -12	3
-	30,		// -11	4
-	50,		// -10	5
-	70,		// -9	6
-	80,		// -8	7
-	85,		// -7	8
-	90,		// -6	9
-	92,		// -5	10
-	94,		// -4	11
-	96,		// -3	12
-	98,		// -2	13
-	100,	// -1	14
-	100,	// 0	15
-	105,	// 1	16
-	110,	// 2	17
-	115,	// 3	18
-	120,	// 4	19
-	125,	// 5	20
-	130,	// 6	21
-	135,	// 7	22
-	140,	// 8	23
-	145,	// 9	24
-	150,	// 10	25
-	155,	// 11	26
-	160,	// 12	27
-	165,	// 13	28
-	170,	// 14	29
-	180,	// 15	30
-};
-
-const DWORD party_exp_distribute_table[PLAYER_MAX_LEVEL_CONST + 1] =
-{
-	0,
-	10,		10,		10,		10,		15,		15,		20,		25,		30,		40,		// 1 - 10
-	50,		60,		80,		100,	120,	140,	160,	184,	210,	240,	// 11 - 20
-	270,	300,	330,	360,	390,	420,	450,	480,	510,	550,	// 21 - 30
-	600,	640,	700,	760,	820,	880,	940,	1000,	1100,	1180,	// 31 - 40
-	1260,	1320,	1380,	1440,	1500,	1560,	1620,	1680,	1740,	1800,	// 41 - 50
-	1860,	1920,	2000,	2100,	2200,	2300,	2450,	2600,	2750,	2900,	// 51 - 60
-	3050,	3200,	3350,	3500,	3650,	3800,	3950,	4100,	4250,	4400,	// 61 - 70
-	4600,	4800,	5000,	5200,	5400,	5600,	5800,	6000,	6200,	6400,	// 71 - 80
-	6600,	6900,	7100,	7300,	7600,	7800,	8000,	8300,	8500,	8800,	// 81 - 90
-	9000,	9000,	9000,	9000,	9000,	9000,	9000,	9000,	9000,	9000,	// 91 - 100
-	10000,	10000,	10000,	10000,	10000,	10000,	10000,	10000,	10000,	10000,	// 101 - 110
-	12000,	12000,	12000,	12000,	12000,	12000,	12000,	12000,	12000,	12000,	// 111 - 120
-};
-
-Coord aArroundCoords[ARROUND_COORD_MAX_NUM] =
-{
-	{ 0, 0 },
-	{ 0, 50 },
-	{ 35, 35 },
-	{ 50, -0 },
-	{ 35, -35 },
-	{ 0, -50 },
-	{ -35, -35 },
-	{ -50, 0 },
-	{ -35, 35 },
-	{ 0, 100 },
-	{ 71, 71 },
-	{ 100, -0 },
-	{ 71, -71 },
-	{ 0, -100 },
-	{ -71, -71 },
-	{ -100, 0 },
-	{ -71, 71 },
-	{ 0, 150 },
-	{ 106, 106 },
-	{ 150, -0 },
-	{ 106, -106 },
-	{ 0, -150 },
-	{ -106, -106 },
-	{ -150, 0 },
-	{ -106, 106 },
-	{ 0, 200 },
-	{ 141, 141 },
-	{ 200, -0 },
-	{ 141, -141 },
-	{ 0, -200 },
-	{ -141, -141 },
-	{ -200, 0 },
-	{ -141, 141 },
-	{ 0, 250 },
-	{ 177, 177 },
-	{ 250, -0 },
-	{ 177, -177 },
-	{ 0, -250 },
-	{ -177, -177 },
-	{ -250, 0 },
-	{ -177, 177 },
-	{ 0, 300 },
-	{ 212, 212 },
-	{ 300, -0 },
-	{ 212, -212 },
-	{ 0, -300 },
-	{ -212, -212 },
-	{ -300, 0 },
-	{ -212, 212 },
-	{ 0, 350 },
-	{ 247, 247 },
-	{ 350, -0 },
-	{ 247, -247 },
-	{ 0, -350 },
-	{ -247, -247 },
-	{ -350, 0 },
-	{ -247, 247 },
-	{ 0, 400 },
-	{ 283, 283 },
-	{ 400, -0 },
-	{ 283, -283 },
-	{ 0, -400 },
-	{ -283, -283 },
-	{ -400, 0 },
-	{ -283, 283 },
-	{ 0, 450 },
-	{ 318, 318 },
-	{ 450, -0 },
-	{ 318, -318 },
-	{ 0, -450 },
-	{ -318, -318 },
-	{ -450, 0 },
-	{ -318, 318 },
-	{ 0, 500 },
-	{ 354, 354 },
-	{ 500, -0 },
-	{ 354, -354 },
-	{ 0, -500 },
-	{ -354, -354 },
-	{ -500, 0 },
-	{ -354, 354 },
-	{ 0, 550 },
-	{ 389, 389 },
-	{ 550, -0 },
-	{ 389, -389 },
-	{ 0, -550 },
-	{ -389, -389 },
-	{ -550, 0 },
-	{ -389, 389 },
-	{ 0, 600 },
-	{ 424, 424 },
-	{ 600, -0 },
-	{ 424, -424 },
-	{ 0, -600 },
-	{ -424, -424 },
-	{ -600, 0 },
-	{ -424, 424 },
-	{ 0, 650 },
-	{ 460, 460 },
-	{ 650, -0 },
-	{ 460, -460 },
-	{ 0, -650 },
-	{ -460, -460 },
-	{ -650, 0 },
-	{ -460, 460 },
-	{ 0, 700 },
-	{ 495, 495 },
-	{ 700, -0 },
-	{ 495, -495 },
-	{ 0, -700 },
-	{ -495, -495 },
-	{ -700, 0 },
-	{ -495, 495 },
-	{ 0, 750 },
-	{ 530, 530 },
-	{ 750, -0 },
-	{ 530, -530 },
-	{ 0, -750 },
-	{ -530, -530 },
-	{ -750, 0 },
-	{ -530, 530 },
-	{ 0, 800 },
-	{ 566, 566 },
-	{ 800, -0 },
-	{ 566, -566 },
-	{ 0, -800 },
-	{ -566, -566 },
-	{ -800, 0 },
-	{ -566, 566 },
-	{ 0, 850 },
-	{ 601, 601 },
-	{ 850, -0 },
-	{ 601, -601 },
-	{ 0, -850 },
-	{ -601, -601 },
-	{ -850, 0 },
-	{ -601, 601 },
-	{ 0, 900 },
-	{ 636, 636 },
-	{ 900, -0 },
-	{ 636, -636 },
-	{ 0, -900 },
-	{ -636, -636 },
-	{ -900, 0 },
-	{ -636, 636 },
-	{ 0, 950 },
-	{ 672, 672 },
-	{ 950, -0 },
-	{ 672, -672 },
-	{ 0, -950 },
-	{ -672, -672 },
-	{ -950, 0 },
-	{ -672, 672 },
-	{ 0, 1000 },
-	{ 707, 707 },
-	{ 1000, -0 },
-	{ 707, -707 },
-	{ 0, -1000 },
-	{ -707, -707 },
-	{ -1000, 0 },
-	{ -707, 707 },
-};
-
-const DWORD guild_exp_table[GUILD_MAX_LEVEL + 1] =
-{
-	0,
-	15000UL,
-	45000UL,
-	90000UL,
-	160000UL,
-	235000UL,
-	325000UL,
-	430000UL,
-	550000UL,
-	685000UL,
-	835000UL,
-	1000000UL,
-	1500000UL,
-	2100000UL,
-	2800000UL,
-	3600000UL,
-	4500000UL,
-	6500000UL,
-	8000000UL,
-	10000000UL,
-	42000000UL
-};
-
-// INTERNATIONAL_VERSION 길드경험치
-const DWORD guild_exp_table2[GUILD_MAX_LEVEL + 1] =
-{
-	0,
-	6000UL,
-	18000UL,
-	36000UL,
-	64000UL,
-	94000UL,
-	130000UL,
-	172000UL,
-	220000UL,
-	274000UL,
-	334000UL,
-	400000UL,
-	600000UL,
-	840000UL,
-	1120000UL,
-	1440000UL,
-	1800000UL,
-	2600000UL,
-	3200000UL,
-	4000000UL,
-	16800000UL
-};
-// END_OF_INTERNATIONAL_VERSION 길드경험치
-
-const int aiMobEnchantApplyIdx[MOB_ENCHANTS_MAX_NUM] =
-{
-	APPLY_CURSE_PCT,
-	APPLY_SLOW_PCT,
-	APPLY_POISON_PCT,
-	APPLY_STUN_PCT,
-	APPLY_CRITICAL_PCT,
-	APPLY_PENETRATE_PCT,
-};
-
-const int aiMobResistsApplyIdx[MOB_RESISTS_MAX_NUM] =
-{
-	APPLY_RESIST_FIST,
-
-	APPLY_RESIST_SWORD,
-	APPLY_RESIST_TWOHAND,
-	APPLY_RESIST_DAGGER,
-	APPLY_RESIST_BELL,
-	APPLY_RESIST_FAN,
-	APPLY_RESIST_BOW,
-	APPLY_RESIST_CLAW,
-
-	APPLY_RESIST_FIRE,
-	APPLY_RESIST_ELEC,
-	APPLY_RESIST_MAGIC,
-	APPLY_RESIST_WIND,
-
-	APPLY_POISON_REDUCE,
-	APPLY_BLEEDING_REDUCE,
-};
-
-#if defined(__ELEMENT_SYSTEM__)
-const int aiMobElementsApplyIdx[MOB_ELEMENT_MAX_NUM] =
-{
-	APPLY_ENCHANT_ELECT,
-	APPLY_ENCHANT_FIRE,
-	APPLY_ENCHANT_ICE,
-	APPLY_ENCHANT_WIND,
-	APPLY_ENCHANT_EARTH,
-	APPLY_ENCHANT_DARK
-};
-#endif
-
-const int aiSocketPercentByQty[5][4] =
-{
-	{ 0, 0, 0, 0 },
-	{ 3, 0, 0, 0 },
-	{ 10, 1, 0, 0 },
-	{ 15, 10, 1, 0 },
-	{ 20, 15, 10, 1 }
-};
-
-const int aiWeaponSocketQty[WEAPON_NUM_TYPES] =
-{
-	3, // WEAPON_SWORD,
-	3, // WEAPON_DAGGER,
-	3, // WEAPON_BOW,
-	3, // WEAPON_TWO_HANDED,
-	3, // WEAPON_BELL,
-	3, // WEAPON_FAN,
-	0, // WEAPON_ARROW,
-	0, // WEAPON_MOUNT_SPEAR
-#if defined(__WOLFMAN_CHARACTER__)
-	3, // WEAPON_CLAW
-#endif
-#if defined(__QUIVER_SYSTEM__)
-	0, // WEAPON_QUIVER,
-#endif
-};
-
-const int aiArmorSocketQty[ARMOR_NUM_TYPES] =
-{
-	3, // ARMOR_BODY,
-	1, // ARMOR_HEAD,
-	1, // ARMOR_SHIELD,
-	0, // ARMOR_WRIST,
-	0, // ARMOR_FOOTS,
-	0 // ARMOR_ACCESSORY
-};
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-const int s_aiAuraRefineTable[AURA_GRADE_MAX_NUM][AURA_REFINE_INFO_MAX] = {
-	// Grade					MinLevel	MaxLevel		Exp		MaterialVnum	MaterialCount	Cost		Pct
-	{ AURA_GRADE_ORDINARY,		1,			49,				1000,	30617,			10,				5000000,	100 },
-	{ AURA_GRADE_SIMPLE,		50,			99,				2000,	31136,			10,				5000000,	100 },
-	{ AURA_GRADE_NOBLE,			100,		149,			4000,	31137,			10,				5000000,	100 },
-	{ AURA_GRADE_SPARKLING,		150,		199,			8000,	31138,			10,				8000000,	100 },
-	{ AURA_GRADE_MAGNIFICENT,	200,		249,			16000,	31138,			20,				10000000,	100 },
-	{ AURA_GRADE_RADIANT,		250,		250,			0,		0,				0,				0,			0 },
-	{ AURA_GRADE_NONE,			0,			0,				0,		0,				0,				0,			0 }
-};
-
-const int* GetAuraRefineInfo(BYTE bLevel)
-{
-	if (bLevel > AURA_MAX_LEVEL)
-		return NULL;
-
-	for (int i = 0; i < AURA_GRADE_MAX_NUM; ++i)
-	{
-		if (bLevel >= s_aiAuraRefineTable[i][AURA_REFINE_INFO_LEVEL_MIN] && bLevel <= s_aiAuraRefineTable[i][AURA_REFINE_INFO_LEVEL_MAX])
-			return s_aiAuraRefineTable[i];
-	}
-
-	return NULL;
-}
-
-const int GetAuraRefineInfo(BYTE bGrade, BYTE bInfo)
-{
-	if (bGrade >= AURA_GRADE_MAX_NUM || bInfo >= AURA_REFINE_INFO_MAX)
-		return 0;
-
-	return s_aiAuraRefineTable[bGrade - 1][bInfo];
-}
-#endif
-
-TItemAttrMap g_map_itemAttr;
-TItemAttrMap g_map_itemRare;
-
-const TApplyInfo aApplyInfo[MAX_APPLY_NUM] =
-/*
-{
-	POINT_TYPE wApplyType;
-	POINT_TYPE wPointType;
-}
-*/
-{
-	{ APPLY_NONE, POINT_NONE, },
-	{ APPLY_MAX_HP, POINT_MAX_HP, },
-	{ APPLY_MAX_SP, POINT_MAX_SP, },
-	{ APPLY_CON, POINT_HT, },
-	{ APPLY_INT, POINT_IQ, },
-	{ APPLY_STR, POINT_ST, },
-	{ APPLY_DEX, POINT_DX, },
-	{ APPLY_ATT_SPEED, POINT_ATT_SPEED, },
-	{ APPLY_MOV_SPEED, POINT_MOV_SPEED, },
-	{ APPLY_CAST_SPEED, POINT_CASTING_SPEED, },
-	{ APPLY_HP_REGEN, POINT_HP_REGEN, },
-	{ APPLY_SP_REGEN, POINT_SP_REGEN, },
-	{ APPLY_POISON_PCT, POINT_POISON_PCT, },
-	{ APPLY_STUN_PCT, POINT_STUN_PCT, },
-	{ APPLY_SLOW_PCT, POINT_SLOW_PCT, },
-	{ APPLY_CRITICAL_PCT, POINT_CRITICAL_PCT, },
-	{ APPLY_PENETRATE_PCT, POINT_PENETRATE_PCT, },
-	{ APPLY_ATTBONUS_HUMAN, POINT_ATTBONUS_HUMAN, },
-	{ APPLY_ATTBONUS_ANIMAL, POINT_ATTBONUS_ANIMAL, },
-	{ APPLY_ATTBONUS_ORC, POINT_ATTBONUS_ORC, },
-	{ APPLY_ATTBONUS_MILGYO, POINT_ATTBONUS_MILGYO, },
-	{ APPLY_ATTBONUS_UNDEAD, POINT_ATTBONUS_UNDEAD, },
-	{ APPLY_ATTBONUS_DEVIL, POINT_ATTBONUS_DEVIL, },
-	{ APPLY_STEAL_HP, POINT_STEAL_HP, },
-	{ APPLY_STEAL_SP, POINT_STEAL_SP, },
-	{ APPLY_MANA_BURN_PCT, POINT_MANA_BURN_PCT, },
-	{ APPLY_DAMAGE_SP_RECOVER, POINT_DAMAGE_SP_RECOVER, },
-	{ APPLY_BLOCK, POINT_BLOCK, },
-	{ APPLY_DODGE, POINT_DODGE, },
-	{ APPLY_RESIST_SWORD, POINT_RESIST_SWORD, },
-	{ APPLY_RESIST_TWOHAND, POINT_RESIST_TWOHAND, },
-	{ APPLY_RESIST_DAGGER, POINT_RESIST_DAGGER, },
-	{ APPLY_RESIST_BELL, POINT_RESIST_BELL, },
-	{ APPLY_RESIST_FAN, POINT_RESIST_FAN, },
-	{ APPLY_RESIST_BOW, POINT_RESIST_BOW, },
-	{ APPLY_RESIST_FIRE, POINT_RESIST_FIRE, },
-	{ APPLY_RESIST_ELEC, POINT_RESIST_ELEC, },
-	{ APPLY_RESIST_MAGIC, POINT_RESIST_MAGIC, },
-	{ APPLY_RESIST_WIND, POINT_RESIST_WIND, },
-	{ APPLY_REFLECT_MELEE, POINT_REFLECT_MELEE, },
-	{ APPLY_REFLECT_CURSE, POINT_REFLECT_CURSE, },
-	{ APPLY_POISON_REDUCE, POINT_POISON_REDUCE, },
-	{ APPLY_KILL_SP_RECOVER, POINT_KILL_SP_RECOVER, },
-	{ APPLY_EXP_DOUBLE_BONUS, POINT_EXP_DOUBLE_BONUS, },
-	{ APPLY_GOLD_DOUBLE_BONUS, POINT_GOLD_DOUBLE_BONUS, },
-	{ APPLY_ITEM_DROP_BONUS, POINT_ITEM_DROP_BONUS, },
-	{ APPLY_POTION_BONUS, POINT_POTION_BONUS, },
-	{ APPLY_KILL_HP_RECOVER, POINT_KILL_HP_RECOVERY, },
-	{ APPLY_IMMUNE_STUN, POINT_IMMUNE_STUN, },
-	{ APPLY_IMMUNE_SLOW, POINT_IMMUNE_SLOW, },
-	{ APPLY_IMMUNE_FALL, POINT_IMMUNE_FALL, },
-	{ APPLY_SKILL, POINT_NONE, },
-	{ APPLY_BOW_DISTANCE, POINT_BOW_DISTANCE, },
-	{ APPLY_ATT_GRADE_BONUS, POINT_ATT_GRADE_BONUS, },
-	{ APPLY_DEF_GRADE_BONUS, POINT_DEF_GRADE_BONUS, },
-	{ APPLY_MAGIC_ATT_GRADE, POINT_MAGIC_ATT_GRADE_BONUS, },
-	{ APPLY_MAGIC_DEF_GRADE, POINT_MAGIC_DEF_GRADE_BONUS, },
-	{ APPLY_CURSE_PCT, POINT_CURSE_PCT, },
-	{ APPLY_MAX_STAMINA, POINT_MAX_STAMINA, },
-	{ APPLY_ATTBONUS_WARRIOR, POINT_ATTBONUS_WARRIOR, },
-	{ APPLY_ATTBONUS_ASSASSIN, POINT_ATTBONUS_ASSASSIN, },
-	{ APPLY_ATTBONUS_SURA, POINT_ATTBONUS_SURA, },
-	{ APPLY_ATTBONUS_SHAMAN, POINT_ATTBONUS_SHAMAN, },
-	{ APPLY_ATTBONUS_MONSTER, POINT_ATTBONUS_MONSTER, },
-	{ APPLY_MALL_ATTBONUS, POINT_ATT_BONUS, },
-	{ APPLY_MALL_DEFBONUS, POINT_MALL_DEFBONUS, },
-	{ APPLY_MALL_EXPBONUS, POINT_MALL_EXPBONUS, },
-	{ APPLY_MALL_ITEMBONUS, POINT_MALL_ITEMBONUS, },
-	{ APPLY_MALL_GOLDBONUS, POINT_MALL_GOLDBONUS, },
-	{ APPLY_MAX_HP_PCT, POINT_MAX_HP_PCT, },
-	{ APPLY_MAX_SP_PCT, POINT_MAX_SP_PCT, },
-	{ APPLY_SKILL_DAMAGE_BONUS, POINT_SKILL_DAMAGE_BONUS, },
-	{ APPLY_NORMAL_HIT_DAMAGE_BONUS, POINT_NORMAL_HIT_DAMAGE_BONUS, },
-
-	{ APPLY_SKILL_DEFEND_BONUS, POINT_SKILL_DEFEND_BONUS, },
-	{ APPLY_NORMAL_HIT_DEFEND_BONUS, POINT_NORMAL_HIT_DEFEND_BONUS, },
-
-	{ APPLY_PC_BANG_EXP_BONUS, POINT_PC_BANG_EXP_BONUS, },
-	{ APPLY_PC_BANG_DROP_BONUS, POINT_PC_BANG_DROP_BONUS, },
-
-	{ APPLY_EXTRACT_HP_PCT, POINT_NONE, },
-
-	{ APPLY_RESIST_WARRIOR, POINT_RESIST_WARRIOR, },
-	{ APPLY_RESIST_ASSASSIN, POINT_RESIST_ASSASSIN, },
-	{ APPLY_RESIST_SURA, POINT_RESIST_SURA, },
-	{ APPLY_RESIST_SHAMAN, POINT_RESIST_SHAMAN, },
-	{ APPLY_ENERGY, POINT_ENERGY, },
-	{ APPLY_DEF_GRADE, POINT_DEF_GRADE, },
-	{ APPLY_COSTUME_ATTR_BONUS, POINT_COSTUME_ATTR_BONUS, },
-	{ APPLY_MAGIC_ATTBONUS_PER, POINT_MAGIC_ATT_BONUS_PER, },
-	{ APPLY_MELEE_MAGIC_ATTBONUS_PER, POINT_MELEE_MAGIC_ATT_BONUS_PER, },
-
-	{ APPLY_RESIST_ICE, POINT_RESIST_ICE, },
-	{ APPLY_RESIST_EARTH, POINT_RESIST_EARTH, },
-	{ APPLY_RESIST_DARK, POINT_RESIST_DARK, },
-
-	{ APPLY_ANTI_CRITICAL_PCT, POINT_RESIST_CRITICAL, },
-	{ APPLY_ANTI_PENETRATE_PCT, POINT_RESIST_PENETRATE, },
-
-	{ APPLY_BLEEDING_REDUCE, POINT_BLEEDING_REDUCE, },
-	{ APPLY_BLEEDING_PCT, POINT_BLEEDING_PCT, },
-	{ APPLY_ATTBONUS_WOLFMAN, POINT_ATTBONUS_WOLFMAN, },
-	{ APPLY_RESIST_WOLFMAN, POINT_RESIST_WOLFMAN, },
-	{ APPLY_RESIST_CLAW, POINT_RESIST_CLAW, },
-
-	{ APPLY_ACCEDRAIN_RATE, POINT_NONE, },
-#if defined(__MAGIC_REDUCTION__)
-	{ APPLY_RESIST_MAGIC_REDUCTION, POINT_RESIST_MAGIC_REDUCTION, },
-#endif
-
-	{ APPLY_ENCHANT_ELECT, POINT_ENCHANT_ELECT, },
-	{ APPLY_ENCHANT_FIRE, POINT_ENCHANT_FIRE, },
-	{ APPLY_ENCHANT_ICE, POINT_ENCHANT_ICE, },
-	{ APPLY_ENCHANT_WIND, POINT_ENCHANT_WIND, },
-	{ APPLY_ENCHANT_EARTH, POINT_ENCHANT_EARTH, },
-	{ APPLY_ENCHANT_DARK, POINT_ENCHANT_DARK, },
-
-	{ APPLY_ATTBONUS_CZ, POINT_ATTBONUS_CZ, },
-	{ APPLY_ATTBONUS_INSECT, POINT_ATTBONUS_INSECT, },
-	{ APPLY_ATTBONUS_DESERT, POINT_ATTBONUS_DESERT, },
-	{ APPLY_ATTBONUS_SWORD, POINT_ATTBONUS_SWORD, },
-	{ APPLY_ATTBONUS_TWOHAND, POINT_ATTBONUS_TWOHAND, },
-	{ APPLY_ATTBONUS_DAGGER, POINT_ATTBONUS_DAGGER, },
-	{ APPLY_ATTBONUS_BELL, POINT_ATTBONUS_BELL, },
-	{ APPLY_ATTBONUS_FAN, POINT_ATTBONUS_FAN, },
-	{ APPLY_ATTBONUS_BOW, POINT_ATTBONUS_BOW, },
-	{ APPLY_ATTBONUS_CLAW, POINT_ATTBONUS_CLAW, },
-
-	{ APPLY_RESIST_HUMAN, POINT_RESIST_HUMAN, },
-	{ APPLY_RESIST_MOUNT_FALL, POINT_RESIST_MOUNT_FALL, },
-	{ APPLY_RESIST_FIST, POINT_RESIST_FIST, },
-
-	{ APPLY_MOUNT, POINT_MOUNT, },
-
-	{ APPLY_SKILL_DAMAGE_SAMYEON, POINT_SKILL_DAMAGE_SAMYEON, },
-	{ APPLY_SKILL_DAMAGE_TANHWAN, POINT_SKILL_DAMAGE_TANHWAN, },
-	{ APPLY_SKILL_DAMAGE_PALBANG, POINT_SKILL_DAMAGE_PALBANG, },
-	{ APPLY_SKILL_DAMAGE_GIGONGCHAM, POINT_SKILL_DAMAGE_GIGONGCHAM, },
-	{ APPLY_SKILL_DAMAGE_GYOKSAN, POINT_SKILL_DAMAGE_GYOKSAN, },
-	{ APPLY_SKILL_DAMAGE_GEOMPUNG, POINT_SKILL_DAMAGE_GEOMPUNG, },
-	{ APPLY_SKILL_DAMAGE_AMSEOP, POINT_SKILL_DAMAGE_AMSEOP, },
-	{ APPLY_SKILL_DAMAGE_GUNGSIN, POINT_SKILL_DAMAGE_GUNGSIN, },
-	{ APPLY_SKILL_DAMAGE_CHARYUN, POINT_SKILL_DAMAGE_CHARYUN, },
-	{ APPLY_SKILL_DAMAGE_SANGONG, POINT_SKILL_DAMAGE_SANGONG, },
-	{ APPLY_SKILL_DAMAGE_YEONSA, POINT_SKILL_DAMAGE_YEONSA, },
-	{ APPLY_SKILL_DAMAGE_KWANKYEOK, POINT_SKILL_DAMAGE_KWANKYEOK, },
-	{ APPLY_SKILL_DAMAGE_GIGUNG, POINT_SKILL_DAMAGE_GIGUNG, },
-	{ APPLY_SKILL_DAMAGE_HWAJO, POINT_SKILL_DAMAGE_HWAJO, },
-	{ APPLY_SKILL_DAMAGE_SWAERYUNG, POINT_SKILL_DAMAGE_SWAERYUNG, },
-	{ APPLY_SKILL_DAMAGE_YONGKWON, POINT_SKILL_DAMAGE_YONGKWON, },
-	{ APPLY_SKILL_DAMAGE_PABEOB, POINT_SKILL_DAMAGE_PABEOB, },
-	{ APPLY_SKILL_DAMAGE_MARYUNG, POINT_SKILL_DAMAGE_MARYUNG, },
-	{ APPLY_SKILL_DAMAGE_HWAYEOMPOK, POINT_SKILL_DAMAGE_HWAYEOMPOK, },
-	{ APPLY_SKILL_DAMAGE_MAHWAN, POINT_SKILL_DAMAGE_MAHWAN, },
-	{ APPLY_SKILL_DAMAGE_BIPABU, POINT_SKILL_DAMAGE_BIPABU, },
-	{ APPLY_SKILL_DAMAGE_YONGBI, POINT_SKILL_DAMAGE_YONGBI, },
-	{ APPLY_SKILL_DAMAGE_PAERYONG, POINT_SKILL_DAMAGE_PAERYONG, },
-	{ APPLY_SKILL_DAMAGE_NOEJEON, POINT_SKILL_DAMAGE_NOEJEON, },
-	{ APPLY_SKILL_DAMAGE_BYEURAK, POINT_SKILL_DAMAGE_BYEURAK, },
-	{ APPLY_SKILL_DAMAGE_CHAIN, POINT_SKILL_DAMAGE_CHAIN, },
-	{ APPLY_SKILL_DAMAGE_CHAYEOL, POINT_SKILL_DAMAGE_CHAYEOL, },
-	{ APPLY_SKILL_DAMAGE_SALPOONG, POINT_SKILL_DAMAGE_SALPOONG, },
-	{ APPLY_SKILL_DAMAGE_GONGDAB, POINT_SKILL_DAMAGE_GONGDAB, },
-	{ APPLY_SKILL_DAMAGE_PASWAE, POINT_SKILL_DAMAGE_PASWAE, },
-
-	{ APPLY_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE, POINT_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE, },
-	{ APPLY_SKILL_DEFEND_BONUS_BOSS_OR_MORE, POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE, },
-	{ APPLY_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE, POINT_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE, },
-	{ APPLY_SKILL_DAMAGE_BONUS_BOSS_OR_MORE, POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE, },
-
-	{ APPLY_HIT_BUFF_ENCHANT_FIRE, POINT_HIT_BUFF_ENCHANT_FIRE, },
-	{ APPLY_HIT_BUFF_ENCHANT_ICE, POINT_HIT_BUFF_ENCHANT_ICE, },
-	{ APPLY_HIT_BUFF_ENCHANT_ELEC, POINT_HIT_BUFF_ENCHANT_ELEC, },
-	{ APPLY_HIT_BUFF_ENCHANT_WIND, POINT_HIT_BUFF_ENCHANT_WIND, },
-	{ APPLY_HIT_BUFF_ENCHANT_DARK, POINT_HIT_BUFF_ENCHANT_DARK, },
-	{ APPLY_HIT_BUFF_ENCHANT_EARTH, POINT_HIT_BUFF_ENCHANT_EARTH, },
-	{ APPLY_HIT_BUFF_RESIST_FIRE, POINT_HIT_BUFF_RESIST_FIRE, },
-	{ APPLY_HIT_BUFF_RESIST_ICE, POINT_HIT_BUFF_RESIST_ICE, },
-	{ APPLY_HIT_BUFF_RESIST_ELEC, POINT_HIT_BUFF_RESIST_ELEC, },
-	{ APPLY_HIT_BUFF_RESIST_WIND, POINT_HIT_BUFF_RESIST_WIND, },
-	{ APPLY_HIT_BUFF_RESIST_DARK, POINT_HIT_BUFF_RESIST_DARK, },
-	{ APPLY_HIT_BUFF_RESIST_EARTH, POINT_HIT_BUFF_RESIST_EARTH, },
-
-	{ APPLY_USE_SKILL_CHEONGRANG_MOV_SPEED, POINT_USE_SKILL_CHEONGRANG_MOV_SPEED, },
-	{ APPLY_USE_SKILL_CHEONGRANG_CASTING_SPEED, POINT_USE_SKILL_CHEONGRANG_CASTING_SPEED, },
-	{ APPLY_USE_SKILL_CHAYEOL_CRITICAL_PCT, POINT_USE_SKILL_CHAYEOL_CRITICAL_PCT, },
-	{ APPLY_USE_SKILL_SANGONG_ATT_GRADE_BONUS, POINT_USE_SKILL_SANGONG_ATT_GRADE_BONUS, },
-	{ APPLY_USE_SKILL_GIGUNG_ATT_GRADE_BONUS, POINT_USE_SKILL_GIGUNG_ATT_GRADE_BONUS, },
-	{ APPLY_USE_SKILL_JEOKRANG_DEF_BONUS, POINT_USE_SKILL_JEOKRANG_DEF_BONUS, },
-	{ APPLY_USE_SKILL_GWIGEOM_DEF_BONUS, POINT_USE_SKILL_GWIGEOM_DEF_BONUS, },
-	{ APPLY_USE_SKILL_TERROR_ATT_GRADE_BONUS, POINT_USE_SKILL_TERROR_ATT_GRADE_BONUS, },
-	{ APPLY_USE_SKILL_MUYEONG_ATT_GRADE_BONUS, POINT_USE_SKILL_MUYEONG_ATT_GRADE_BONUS, },
-	{ APPLY_USE_SKILL_MANASHILED_CASTING_SPEED, POINT_USE_SKILL_MANASHILED_CASTING_SPEED, },
-	{ APPLY_USE_SKILL_HOSIN_DEF_BONUS, POINT_USE_SKILL_HOSIN_DEF_BONUS, },
-	{ APPLY_USE_SKILL_GICHEON_ATT_GRADE_BONUS, POINT_USE_SKILL_GICHEON_ATT_GRADE_BONUS, },
-	{ APPLY_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS, POINT_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS, },
-	{ APPLY_USE_SKILL_JEUNGRYEOK_DEF_BONUS, POINT_USE_SKILL_JEUNGRYEOK_DEF_BONUS, },
-	{ APPLY_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS, POINT_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS, },
-	{ APPLY_USE_SKILL_CHUNKEON_CASTING_SPEED, POINT_USE_SKILL_CHUNKEON_CASTING_SPEED, },
-	{ APPLY_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS, POINT_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS, },
-
-	{ APPLY_SKILL_DURATION_INCREASE_EUNHYUNG, POINT_SKILL_DURATION_INCREASE_EUNHYUNG, },
-	{ APPLY_SKILL_DURATION_INCREASE_GYEONGGONG, POINT_SKILL_DURATION_INCREASE_GYEONGGONG, },
-	{ APPLY_SKILL_DURATION_INCREASE_GEOMKYUNG, POINT_SKILL_DURATION_INCREASE_GEOMKYUNG, },
-	{ APPLY_SKILL_DURATION_INCREASE_JEOKRANG, POINT_SKILL_DURATION_INCREASE_JEOKRANG, },
-
-	{ APPLY_USE_SKILL_PALBANG_HP_ABSORB, POINT_USE_SKILL_PALBANG_HP_ABSORB, },
-	{ APPLY_USE_SKILL_AMSEOP_HP_ABSORB, POINT_USE_SKILL_AMSEOP_HP_ABSORB, },
-	{ APPLY_USE_SKILL_YEONSA_HP_ABSORB, POINT_USE_SKILL_YEONSA_HP_ABSORB, },
-	{ APPLY_USE_SKILL_YONGBI_HP_ABSORB, POINT_USE_SKILL_YONGBI_HP_ABSORB, },
-	{ APPLY_USE_SKILL_CHAIN_HP_ABSORB, POINT_USE_SKILL_CHAIN_HP_ABSORB, },
-	{ APPLY_USE_SKILL_PASWAE_SP_ABSORB, POINT_USE_SKILL_PASWAE_SP_ABSORB, },
-	{ APPLY_USE_SKILL_GIGONGCHAM_STUN, POINT_USE_SKILL_GIGONGCHAM_STUN, },
-	{ APPLY_USE_SKILL_CHARYUN_STUN, POINT_USE_SKILL_CHARYUN_STUN, },
-	{ APPLY_USE_SKILL_PABEOB_STUN, POINT_USE_SKILL_PABEOB_STUN, },
-	{ APPLY_USE_SKILL_MAHWAN_STUN, POINT_USE_SKILL_MAHWAN_STUN, },
-	{ APPLY_USE_SKILL_GONGDAB_STUN, POINT_USE_SKILL_GONGDAB_STUN, },
-	{ APPLY_USE_SKILL_SAMYEON_STUN, POINT_USE_SKILL_SAMYEON_STUN, },
-	{ APPLY_USE_SKILL_GYOKSAN_KNOCKBACK, POINT_USE_SKILL_GYOKSAN_KNOCKBACK, },
-	{ APPLY_USE_SKILL_SEOMJEON_KNOCKBACK, POINT_USE_SKILL_SEOMJEON_KNOCKBACK, },
-	{ APPLY_USE_SKILL_SWAERYUNG_KNOCKBACK, POINT_USE_SKILL_SWAERYUNG_KNOCKBACK, },
-	{ APPLY_USE_SKILL_HWAYEOMPOK_KNOCKBACK, POINT_USE_SKILL_HWAYEOMPOK_KNOCKBACK, },
-	{ APPLY_USE_SKILL_GONGDAB_KNOCKBACK, POINT_USE_SKILL_GONGDAB_KNOCKBACK, },
-	{ APPLY_USE_SKILL_KWANKYEOK_KNOCKBACK, POINT_USE_SKILL_KWANKYEOK_KNOCKBACK, },
-	{ APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER, },
-	{ APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER, },
-	{ APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER, },
-	{ APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER, },
-	{ APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER, },
-	{ APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER, },
-	{ APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER, },
-	{ APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER, },
-	{ APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER, },
-	{ APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER, },
-
-	{ APPLY_ATTBONUS_STONE, POINT_ATTBONUS_STONE, },
-
-	{ APPLY_DAMAGE_HP_RECOVERY, POINT_DAMAGE_HP_RECOVERY, },
-	{ APPLY_DAMAGE_SP_RECOVERY, POINT_DAMAGE_SP_RECOVERY, },
-
-	{ APPLY_ALIGNMENT_DAMAGE_BONUS, POINT_ALIGNMENT_DAMAGE_BONUS, },
-
-	{ APPLY_NORMAL_DAMAGE_GUARD, POINT_NORMAL_DAMAGE_GUARD },
-	{ APPLY_MORE_THEN_HP90_DAMAGE_REDUCE, POINT_MORE_THEN_HP90_DAMAGE_REDUCE, },
-
-	{ APPLY_USE_SKILL_TUSOK_HP_ABSORB, POINT_USE_SKILL_TUSOK_HP_ABSORB, },
-	{ APPLY_USE_SKILL_PAERYONG_HP_ABSORB, POINT_USE_SKILL_PAERYONG_HP_ABSORB, },
-	{ APPLY_USE_SKILL_BYEURAK_HP_ABSORB, POINT_USE_SKILL_BYEURAK_HP_ABSORB, },
-
-	{ APPLY_FIRST_ATTRIBUTE_BONUS, POINT_NONE, },
-	{ APPLY_SECOND_ATTRIBUTE_BONUS, POINT_NONE, },
-	{ APPLY_THIRD_ATTRIBUTE_BONUS, POINT_NONE, },
-	{ APPLY_FOURTH_ATTRIBUTE_BONUS, POINT_NONE, },
-	{ APPLY_FIFTH_ATTRIBUTE_BONUS, POINT_NONE, },
-
-	{ APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER, },
-	{ APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER, },
-	{ APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER, },
-	{ APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER, },
-	{ APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER, },
-	{ APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER, },
-	{ APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER, },
-	{ APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER, },
-	{ APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER, },
-	{ APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER, },
-	{ APPLY_USE_SKILL_CHAYEOL_HP_ABSORB, POINT_USE_SKILL_CHAYEOL_HP_ABSORB, },
-
-	{ APPLY_SUNGMA_STR, POINT_SUNGMA_STR, },
-	{ APPLY_SUNGMA_HP, POINT_SUNGMA_HP, },
-	{ APPLY_SUNGMA_MOVE, POINT_SUNGMA_MOVE, },
-	{ APPLY_SUNGMA_IMMUNE, POINT_SUNGMA_IMMUNE, },
-
-	{ APPLY_HIT_PCT, POINT_HIT_PCT, },
-	{ APPLY_RANDOM, POINT_NONE, },
-
-	{ APPLY_ATTBONUS_PER_HUMAN, POINT_ATTBONUS_PER_HUMAN, },
-	{ APPLY_ATTBONUS_PER_ANIMAL, POINT_ATTBONUS_PER_ANIMAL, },
-	{ APPLY_ATTBONUS_PER_ORC, POINT_ATTBONUS_PER_ORC, },
-	{ APPLY_ATTBONUS_PER_MILGYO, POINT_ATTBONUS_PER_MILGYO, },
-	{ APPLY_ATTBONUS_PER_UNDEAD, POINT_ATTBONUS_PER_UNDEAD, },
-	{ APPLY_ATTBONUS_PER_DEVIL, POINT_ATTBONUS_PER_DEVIL, },
-
-	{ APPLY_ENCHANT_PER_ELECT, POINT_ENCHANT_PER_ELECT, },
-	{ APPLY_ENCHANT_PER_FIRE, POINT_ENCHANT_PER_FIRE, },
-	{ APPLY_ENCHANT_PER_ICE, POINT_ENCHANT_PER_ICE, },
-	{ APPLY_ENCHANT_PER_WIND, POINT_ENCHANT_PER_WIND, },
-	{ APPLY_ENCHANT_PER_EARTH, POINT_ENCHANT_PER_EARTH, },
-	{ APPLY_ENCHANT_PER_DARK, POINT_ENCHANT_PER_DARK, },
-
-	{ APPLY_ATTBONUS_PER_CZ, POINT_ATTBONUS_PER_CZ, },
-	{ APPLY_ATTBONUS_PER_INSECT, POINT_ATTBONUS_PER_INSECT, },
-	{ APPLY_ATTBONUS_PER_DESERT, POINT_ATTBONUS_PER_DESERT, },
-	{ APPLY_ATTBONUS_PER_STONE, POINT_ATTBONUS_PER_STONE, },
-	{ APPLY_ATTBONUS_PER_MONSTER, POINT_ATTBONUS_PER_MONSTER, },
-
-	{ APPLY_RESIST_PER_HUMAN, POINT_RESIST_PER_HUMAN, },
-	{ APPLY_RESIST_PER_ICE, POINT_RESIST_PER_ICE, },
-	{ APPLY_RESIST_PER_DARK, POINT_RESIST_PER_DARK, },
-	{ APPLY_RESIST_PER_EARTH, POINT_RESIST_PER_EARTH, },
-	{ APPLY_RESIST_PER_FIRE, POINT_RESIST_PER_FIRE, },
-	{ APPLY_RESIST_PER_ELEC, POINT_RESIST_PER_ELEC, },
-	{ APPLY_RESIST_PER_MAGIC, POINT_RESIST_PER_MAGIC, },
-	{ APPLY_RESIST_PER_WIND, POINT_RESIST_PER_WIND, },
-
-	{ APPLY_HIT_BUFF_SUNGMA_STR, POINT_HIT_BUFF_SUNGMA_STR, },
-	{ APPLY_HIT_BUFF_SUNGMA_MOVE, POINT_HIT_BUFF_SUNGMA_MOVE, },
-	{ APPLY_HIT_BUFF_SUNGMA_HP, POINT_HIT_BUFF_SUNGMA_HP, },
-	{ APPLY_HIT_BUFF_SUNGMA_IMMUNE, POINT_HIT_BUFF_SUNGMA_IMMUNE, },
-
-	{ APPLY_MOUNT_MELEE_MAGIC_ATTBONUS_PER, POINT_MOUNT_MELEE_MAGIC_ATTBONUS_PER, },
-	{ APPLY_DISMOUNT_MOVE_SPEED_BONUS_PER, POINT_DISMOUNT_MOVE_SPEED_BONUS_PER, },
-
-	{ APPLY_HIT_AUTO_HP_RECOVERY, POINT_HIT_AUTO_HP_RECOVERY, },
-	{ APPLY_HIT_AUTO_SP_RECOVERY, POINT_HIT_AUTO_SP_RECOVERY, },
-
-	{ APPLY_USE_SKILL_COOLTIME_DECREASE_ALL, POINT_USE_SKILL_COOLTIME_DECREASE_ALL, },
-
-	{ APPLY_HIT_STONE_ATTBONUS_STONE, POINT_HIT_STONE_ATTBONUS_STONE, },
-	{ APPLY_HIT_STONE_DEF_GRADE_BONUS, POINT_HIT_STONE_DEF_GRADE_BONUS, },
-
-	{ APPLY_KILL_BOSS_ITEM_BONUS, POINT_KILL_BOSS_ITEM_BONUS, },
-	{ APPLY_MOB_HIT_MOB_AGGRESSIVE, POINT_MOB_HIT_MOB_AGGRESSIVE, },
-	{ APPLY_NO_DEATH_AND_HP_RECOVERY30, POINT_NO_DEATH_AND_HP_RECOVERY30, },
-
-	{ APPLY_AUTO_PICKUP, POINT_AUTO_PICKUP, },
-	{ APPLY_MOUNT_NO_KNOCKBACK, POINT_MOUNT_NO_KNOCKBACK, },
-
-	{ APPLY_SUNGMA_PER_STR, POINT_SUNGMA_PER_STR, },
-	{ APPLY_SUNGMA_PER_HP, POINT_SUNGMA_PER_HP, },
-	{ APPLY_SUNGMA_PER_MOVE, POINT_SUNGMA_PER_MOVE, },
-	{ APPLY_SUNGMA_PER_IMMUNE, POINT_SUNGMA_PER_IMMUNE, },
-
-	{ APPLY_IMMUNE_POISON100, POINT_IMMUNE_POISON100, },
-	{ APPLY_IMMUNE_BLEEDING100, POINT_IMMUNE_BLEEDING100, },
-
-	{ APPLY_MONSTER_DEFEND_BONUS, POINT_MONSTER_DEFEND_BONUS, },
-};
-
-const int aiItemMagicAttributePercentHigh[ITEM_ATTRIBUTE_MAX_LEVEL] =
-{
-	//25, 25, 40, 8, 2,
-	30, 40, 20, 8, 2
-};
-
-const int aiItemMagicAttributePercentLow[ITEM_ATTRIBUTE_MAX_LEVEL] =
-{
-	//45, 25, 20, 10, 0,
-	50, 40, 10, 0, 0
-};
-
-// ADD_ITEM_ATTRIBUTE
-const int aiItemAttributeAddPercent[ITEM_ATTRIBUTE_MAX_NUM] =
-{
-	100, 80, 60, 50, 30, 0, 0,
-};
-// END_OF_ADD_ITEM_ATTRIBUTE
-
-const int aiExpLossPercents[PLAYER_EXP_TABLE_MAX + 1] =
-{
-	0,
-	5, 5, 5, 5, 5, 5, 5, 5, 5, 4, // 1 - 10
-	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, // 11 - 20
-	4, 4, 4, 4, 4, 4, 4, 3, 3, 3, // 21 - 30
-	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, // 31 - 40
-	3, 3, 3, 3, 2, 2, 2, 2, 2, 2, // 41 - 50
-	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 51 - 60
-	2, 2, 1, 1, 1, 1, 1, 1, 1, 1, // 61 - 70
-	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 71 - 80
-	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 81 - 90
-	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 91 - 100
-	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 101 - 110
-	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 111 - 120
-};
-
-const int aiSkillBookCountForLevelUp[10] =
-{
-	3, 3, 3, 3, 3, 4, 4, 5, 5, 6
-};
-
-// ADD_GRANDMASTER_SKILL
-const int aiGrandMasterSkillBookCountForLevelUp[10] =
-{
-	3, 3, 5, 5, 7, 7, 10, 10, 10, 20,
-};
-
-const int aiGrandMasterSkillBookMinCount[10] =
-{
-	// 1, 1, 3, 5, 10, 15, 20, 30, 40, 50,
-	// 3, 3, 5, 5, 10, 10, 15, 15, 20, 30
-	1, 1, 1, 2, 2, 3, 3, 4, 5, 6
-};
-
-const int aiGrandMasterSkillBookMaxCount[10] =
-{
-	// 6, 15, 30, 45, 60, 80, 100, 120, 160, 200,
-	// 6, 10, 15, 20, 30, 40, 50, 60, 70, 80
-	5, 7, 9, 11, 13, 15, 20, 25, 30, 35
-};
-// END_OF_ADD_GRANDMASTER_SKILL
-
-const int CHN_aiPartyBonusExpPercentByMemberCount[9] =
-{
-	0, 0, 12, 18, 26, 40, 53, 70, 100
-};
-
-// UPGRADE_PARTY_BONUS
-const int KOR_aiPartyBonusExpPercentByMemberCount[9] =
-{
-	0,
-	0,
-	30, // 66% * 2 - 100
-	60, // 53% * 3 - 100
-	75, // 44% * 4 - 100
-	90, // 38% * 5 - 100
-	105, // 34% * 6 - 100
-	110, // 30% * 7 - 100
-	140, // 30% * 8 - 100
-};
-
-const int KOR_aiUniqueItemPartyBonusExpPercentByMemberCount[9] =
-{
-	0,
-	0,
-	15 * 2,
-	14 * 3,
-	13 * 4,
-	12 * 5,
-	11 * 6,
-	10 * 7,
-	10 * 8,
-};
-// END_OF_UPGRADE_PARTY_BONUS
-
-const int* aiChainLightningCountBySkillLevel = NULL;
-
-const int aiChainLightningCountBySkillLevel_euckr[SKILL_MAX_LEVEL + 1] =
-{
-	0, // 0
-	2, // 1
-	2, // 2
-	2, // 3
-	2, // 4
-	2, // 5
-	2, // 6
-	2, // 7
-	2, // 8
-	3, // 9
-	3, // 10
-	3, // 11
-	3, // 12
-	3, // 13
-	3, // 14
-	3, // 15
-	3, // 16
-	3, // 17
-	3, // 18
-	4, // 19
-	4, // 20
-	4, // 21
-	4, // 22
-	4, // 23
-	5, // 24
-	5, // 25
-	5, // 26
-	5, // 27
-	5, // 28
-	5, // 29
-	5, // 30
-	5, // 31
-	5, // 32
-	5, // 33
-	5, // 34
-	5, // 35
-	5, // 36
-	5, // 37
-	5, // 38
-	5, // 39
-	5, // 40
-};
-
-const SStoneDropInfo aStoneDrop[STONE_INFO_MAX_NUM] =
-{
-	// mob pct { +0 +1 +2 +3 +4 }
-	{ 8005, 60, { 30, 30, 30, 9, 1 } },
-	{ 8006, 60, { 28, 29, 31, 11, 1 } },
-	{ 8007, 60, { 24, 29, 32, 13, 2 } },
-	{ 8008, 60, { 22, 28, 33, 15, 2 } },
-	{ 8009, 60, { 21, 27, 33, 17, 2 } },
-	{ 8010, 60, { 18, 26, 34, 20, 2 } },
-	{ 8011, 60, { 14, 26, 35, 22, 3 } },
-	{ 8012, 60, { 10, 26, 37, 24, 3 } },
-	{ 8013, 60, { 2, 26, 40, 29, 3 } },
-	{ 8014, 60, { 0, 26, 41, 30, 3 } },
-	{ 8018, 60, { 0, 25, 42, 30, 3 } },
-	{ 8019, 60, { 0, 23, 42, 32, 3 } },
-	{ 8024, 60, { 0, 22, 43, 32, 3 } },
-	{ 8025, 60, { 0, 21, 43, 32, 4 } },
-	{ 8026, 60, { 0, 19, 44, 33, 4 } },
-	{ 8027, 60, { 0, 17, 45, 34, 4 } },
-	{ 8051, 60, { 0, 15, 46, 34, 5 } },
-	{ 8052, 60, { 0, 15, 46, 34, 5 } },
-	{ 8053, 60, { 0, 12, 47, 36, 5 } },
-	{ 8054, 60, { 0, 12, 47, 36, 5 } },
-	{ 8055, 60, { 0, 9, 48, 37, 6 } },
-	{ 8056, 60, { 0, 9, 48, 37, 6 } },
-};
-
-const char* c_apszEmpireNames[EMPIRE_MAX_NUM] =
-{
-#if defined(__LOCALE_CLIENT__)
-	"[LS;1037]",
-	"[LS;793]",
-	"[LS;794]",
-	"[LS;795]"
-#else
-	"전제국",
-	"신수국",
-	"천조국",
-	"진노국"
-#endif
-};
-
-const char* c_apszPrivNames[MAX_PRIV_NUM] =
-{
-#if defined(__LOCALE_CLIENT__)
-	"",
-	"[LS;1038]",
-	"[LS;1039]",
-	"[LS;1031]",
-	"[LS;1040]"
-#else
-	"",
-	"아이템이 나올 확률",
-	"돈이 나올 확률",
-	"돈 대박이 나올 확률",
-	"경험치 배율"
-#endif
-};
-
-const int aiPolymorphPowerByLevel[SKILL_MAX_LEVEL + 1] =
-{
-	0, // 0
-	10, // 1
-	11, // 2
-	11, // 3
-	12, // 4
-	13, // 5
-	13, // 6
-	14, // 7
-	15, // 8
-	16, // 9
-	17, // 10
-	18, // 11
-	19, // 12
-	20, // 13
-	22, // 14
-	23, // 15
-	24, // 16
-	26, // 17
-	27, // 18
-	29, // 19
-	31, // 20 M1
-	33, // 21
-	35, // 22
-	37, // 23
-	39, // 24
-	41, // 25
-	44, // 26
-	46, // 27
-	49, // 28
-	52, // 29
-	55, // 30 G1
-	59, // 31
-	62, // 32
-	66, // 33
-	70, // 34
-	74, // 35
-	79, // 36
-	84, // 37
-	89, // 38
-	94,	// 39
-	100, // 40 P
-};
-
-#if defined(__PARTY_PROFICY__)
-const int aiProficiencyPowerByLevel[SKILL_MAX_LEVEL + 1] = {
-	0, 1, 2, 3, 4, 5, 6, 7,8, 9,
-	10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
-	20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
-	30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
-	50,
-};
-#endif
-
-const int aiPrecisionPowerByLevel[SKILL_MAX_LEVEL + 1] =
-{
-	0,	// 0
-	0,	// 1
-	0,	// 2
-	1,	// 3
-	1,	// 4
-	1,	// 5
-	2,	// 6
-	2,	// 7
-	2,	// 8
-	3,	// 9
-	3,	// 10
-	3,	// 11
-	4,	// 12
-	4,	// 13
-	4,	// 14
-	5,	// 15
-	5,	// 16
-	5,	// 17
-	6,	// 18
-	6,	// 19
-	8,	// 20
-	8,	// 21
-	8,	// 22
-	9,	// 23
-	9,	// 24
-	9,	// 25
-	10,	// 26
-	10,	// 27
-	11,	// 28
-	11,	// 29
-	13,	// 30
-	13,	// 31
-	14,	// 32
-	14,	// 33
-	15,	// 34
-	16,	// 35
-	16,	// 36
-	17,	// 37
-	18,	// 38
-	18,	// 39
-	20,	// 40
-};
-
-TGuildWarInfo KOR_aGuildWarInfo[GUILD_WAR_TYPE_MAX_NUM] =
-/*
-{
-	long lMapIndex;
-	int iWarPrice;
-	int iWinnerPotionRewardPctToWinner;
-	int iLoserPotionRewardPctToWinner;
-	int iInitialScore;
-	int iEndScore;
-};
-*/
-{
-	{ 0, 0, 0, 0, 0, 0 },
-	{ 110, 0, 100, 50, 0, 100 },
-	{ 111, 0, 100, 50, 0, 10 },
-};
-
-//
-// 악세서리 소켓용 수치들
-//
-
-// 다이아몬드로 소켓을 추가할 때 확률
-const int aiAccessorySocketAddPct[ITEM_ACCESSORY_SOCKET_MAX_NUM] =
-{
-	50, 50, 50
-};
-
-// 악세서리 수치 값의 몇%만큼의 성능을 추가하는지
-const int aiAccessorySocketEffectivePct[ITEM_ACCESSORY_SOCKET_MAX_NUM + 1] =
-{
-	0, 10, 20, 40
-};
-
-// 소켓 지속시간 24, 12, 6
-const int aiAccessorySocketDegradeTime[ITEM_ACCESSORY_SOCKET_MAX_NUM + 1] =
-{
-	0, 3600 * 24, 3600 * 12, 3600 * 6
-};
-
-// 소켓 장착 성공률
-const int aiAccessorySocketPutPct[ITEM_ACCESSORY_SOCKET_MAX_NUM + 1] =
-{
-	90, 80, 70, 0
-};
-// END_OF_ACCESSORY_REFINE
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-const int aiAcceDrainRateAdvancePct[ACCE_MAX_DRAINRATE + 1] =
-{
-	100, // 0
-	100, // 1
-	100, // 2
-	100, // 3
-	100, // 4
-	100, // 5
-	100, // 6
-	100, // 7
-	100, // 8
-	100, // 9
-	100, // 10
-	100, // 11
-	100, // 12
-	100, // 13
-	100, // 14
-	100, // 15
-	100, // 16
-	90, // 17
-	80, // 18
-	50, // 19
-	40, // 20
-	35, // 21
-	30, // 22
-	25, // 23
-	20, // 24
-	0 // 25
-};
-#endif
-
-#include "../../common/length.h"
-// from import_item_proto.c
-typedef struct SValueName
-{
-	const char* c_pszName;
-	long lValue;
-} TValueName;
-
-TValueName c_aApplyTypeNames[] =
-{
-	// APPLY_NONE
-	{ "MAX_HP", APPLY_MAX_HP },
-	{ "MAX_SP", APPLY_MAX_SP },
-	{ "CON", APPLY_CON },
-	{ "INT", APPLY_INT },
-	{ "STR", APPLY_STR },
-	{ "DEX", APPLY_DEX },
-	{ "ATT_SPEED", APPLY_ATT_SPEED },
-	{ "MOV_SPEED", APPLY_MOV_SPEED },
-	{ "CAST_SPEED", APPLY_CAST_SPEED },
-	{ "HP_REGEN", APPLY_HP_REGEN },
-	{ "SP_REGEN", APPLY_SP_REGEN },
-	{ "POISON_PCT", APPLY_POISON_PCT },
-	{ "STUN_PCT", APPLY_STUN_PCT },
-	{ "SLOW_PCT", APPLY_SLOW_PCT },
-	{ "CRITICAL_PCT", APPLY_CRITICAL_PCT },
-	{ "PENETRATE_PCT", APPLY_PENETRATE_PCT },
-	{ "ATTBONUS_HUMAN", APPLY_ATTBONUS_HUMAN },
-	{ "ATTBONUS_ANIMAL", APPLY_ATTBONUS_ANIMAL },
-	{ "ATTBONUS_ORC", APPLY_ATTBONUS_ORC },
-	{ "ATTBONUS_MILGYO", APPLY_ATTBONUS_MILGYO },
-	{ "ATTBONUS_UNDEAD", APPLY_ATTBONUS_UNDEAD },
-	{ "ATTBONUS_DEVIL", APPLY_ATTBONUS_DEVIL },
-	{ "STEAL_HP", APPLY_STEAL_HP },
-	{ "STEAL_SP", APPLY_STEAL_SP },
-	{ "MANA_BURN_PCT", APPLY_MANA_BURN_PCT },
-	{ "DAMAGE_SP_RECOVER", APPLY_DAMAGE_SP_RECOVER },
-	{ "BLOCK", APPLY_BLOCK },
-	{ "DODGE", APPLY_DODGE },
-	{ "RESIST_SWORD", APPLY_RESIST_SWORD },
-	{ "RESIST_TWOHAND", APPLY_RESIST_TWOHAND },
-	{ "RESIST_DAGGER", APPLY_RESIST_DAGGER },
-	{ "RESIST_BELL", APPLY_RESIST_BELL },
-	{ "RESIST_FAN", APPLY_RESIST_FAN },
-	{ "RESIST_BOW", APPLY_RESIST_BOW },
-	{ "RESIST_FIRE", APPLY_RESIST_FIRE },
-	{ "RESIST_ELEC", APPLY_RESIST_ELEC },
-	{ "RESIST_MAGIC", APPLY_RESIST_MAGIC },
-	{ "RESIST_WIND", APPLY_RESIST_WIND },
-	{ "REFLECT_MELEE", APPLY_REFLECT_MELEE },
-	{ "REFLECT_CURSE", APPLY_REFLECT_CURSE },
-	{ "POISON_REDUCE", APPLY_POISON_REDUCE },
-	{ "KILL_SP_RECOVER", APPLY_KILL_SP_RECOVER },
-	{ "EXP_DOUBLE_BONUS", APPLY_EXP_DOUBLE_BONUS },
-	{ "GOLD_DOUBLE_BONUS", APPLY_GOLD_DOUBLE_BONUS },
-	{ "ITEM_DROP_BONUS", APPLY_ITEM_DROP_BONUS },
-	{ "POTION_BONUS", APPLY_POTION_BONUS },
-	{ "KILL_HP_RECOVER", APPLY_KILL_HP_RECOVER },
-	{ "IMMUNE_STUN", APPLY_IMMUNE_STUN },
-	{ "IMMUNE_SLOW", APPLY_IMMUNE_SLOW },
-	{ "IMMUNE_FALL", APPLY_IMMUNE_FALL },
-	{ "SKILL", APPLY_SKILL },
-	{ "BOW_DISTANCE", APPLY_BOW_DISTANCE },
-	{ "ATT_GRADE_BONUS", APPLY_ATT_GRADE_BONUS },
-	{ "DEF_GRADE_BONUS", APPLY_DEF_GRADE_BONUS },
-	{ "MAGIC_ATT_GRADE", APPLY_MAGIC_ATT_GRADE },
-	{ "MAGIC_DEF_GRADE", APPLY_MAGIC_DEF_GRADE },
-	{ "CURSE_PCT", APPLY_CURSE_PCT },
-	{ "MAX_STAMINA", APPLY_MAX_STAMINA },
-
-	{ "ATTBONUS_WARRIOR", APPLY_ATTBONUS_WARRIOR },
-	{ "ATTBONUS_ASSASSIN", APPLY_ATTBONUS_ASSASSIN },
-	{ "ATTBONUS_SURA", APPLY_ATTBONUS_SURA },
-	{ "ATTBONUS_SHAMAN", APPLY_ATTBONUS_SHAMAN },
-	{ "ATTBONUS_MONSTER", APPLY_ATTBONUS_MONSTER },
-
-	{ "MALL_ATTBONUS", APPLY_MALL_ATTBONUS },
-	{ "MALL_DEFBONUS", APPLY_MALL_DEFBONUS },
-	{ "MALL_EXPBONUS", APPLY_MALL_EXPBONUS },
-	{ "MALL_ITEMBONUS", APPLY_MALL_ITEMBONUS },
-	{ "MALL_GOLDBONUS", APPLY_MALL_GOLDBONUS },
-
-	{ "MAX_HP_PCT", APPLY_MAX_HP_PCT },
-	{ "MAX_SP_PCT", APPLY_MAX_SP_PCT },
-
-	{ "SKILL_DAMAGE_BONUS", APPLY_SKILL_DAMAGE_BONUS },
-	{ "NORMAL_HIT_DAMAGE_BONUS", APPLY_NORMAL_HIT_DAMAGE_BONUS },
-
-	{ "SKILL_DEFEND_BONUS", APPLY_SKILL_DEFEND_BONUS },
-
-	{ "NORMAL_HIT_DEFEND_BONUS", APPLY_NORMAL_HIT_DEFEND_BONUS },
-	{ "PC_BANG_EXP_BONUS", APPLY_PC_BANG_EXP_BONUS },
-	{ "PC_BANG_DROP_BONUS", APPLY_PC_BANG_DROP_BONUS },
-
-	{ "EXTRACT_HP_PCT", APPLY_EXTRACT_HP_PCT },
-
-	{ "RESIST_WARRIOR", APPLY_RESIST_WARRIOR },
-	{ "RESIST_ASSASSIN", APPLY_RESIST_ASSASSIN },
-	{ "RESIST_SURA", APPLY_RESIST_SURA },
-	{ "RESIST_SHAMAN", APPLY_RESIST_SHAMAN },
-
-	{ "ENERGY", APPLY_ENERGY },
-	{ "DEF_GRADE", APPLY_DEF_GRADE },
-	{ "COSTUME_ATTR_BONUS", APPLY_COSTUME_ATTR_BONUS },
-	{ "MAGIC_ATTBONUS_PER", APPLY_MAGIC_ATTBONUS_PER },
-	{ "MELEE_MAGIC_ATTBONUS_PER", APPLY_MELEE_MAGIC_ATTBONUS_PER },
-
-	{ "RESIST_ICE", APPLY_RESIST_ICE },
-	{ "RESIST_EARTH", APPLY_RESIST_EARTH },
-	{ "RESIST_DARK", APPLY_RESIST_DARK },
-
-	{ "RESIST_CRITICAL", APPLY_ANTI_CRITICAL_PCT /* APPLY_RESIST_CRITICAL */ },
-	{ "RESIST_PENETRATE", APPLY_ANTI_PENETRATE_PCT /* APPLY_RESIST_PENETRATE */ },
-
-	{ "BLEEDING_REDUCE", APPLY_BLEEDING_REDUCE },
-	{ "BLEEDING_PCT", APPLY_BLEEDING_PCT },
-	{ "ATTBONUS_WOLFMAN", APPLY_ATTBONUS_WOLFMAN },
-	{ "RESIST_WOLFMAN", APPLY_RESIST_WOLFMAN },
-	{ "RESIST_CLAW", APPLY_RESIST_CLAW },
-
-	{ "ACCEDRAIN_RATE", APPLY_ACCEDRAIN_RATE },
-	{ "RESIST_MAGIC_REDUCTION", APPLY_RESIST_MAGIC_REDUCTION },
-
-	{ "ENCHANT_ELECT", APPLY_ENCHANT_ELECT },
-	{ "ENCHANT_FIRE", APPLY_ENCHANT_FIRE },
-	{ "ENCHANT_ICE", APPLY_ENCHANT_ICE },
-	{ "ENCHANT_WIND", APPLY_ENCHANT_WIND },
-	{ "ENCHANT_EARTH", APPLY_ENCHANT_EARTH },
-	{ "ENCHANT_DARK", APPLY_ENCHANT_DARK },
-
-	{ "ATTBONUS_CZ", APPLY_ATTBONUS_CZ },
-	{ "ATTBONUS_INSECT", APPLY_ATTBONUS_INSECT },
-	{ "ATTBONUS_DESERT", APPLY_ATTBONUS_DESERT },
-	{ "ATTBONUS_SWORD", APPLY_ATTBONUS_SWORD },
-	{ "ATTBONUS_TWOHAND", APPLY_ATTBONUS_TWOHAND },
-	{ "ATTBONUS_DAGGER", APPLY_ATTBONUS_DAGGER },
-	{ "ATTBONUS_BELL", APPLY_ATTBONUS_BELL },
-	{ "ATTBONUS_FAN", APPLY_ATTBONUS_FAN },
-	{ "ATTBONUS_BOW", APPLY_ATTBONUS_BOW },
-	{ "ATTBONUS_CLAW", APPLY_ATTBONUS_CLAW },
-
-	{ "RESIST_HUMAN", APPLY_RESIST_HUMAN },
-	{ "RESIST_MOUNT_FALL", APPLY_RESIST_MOUNT_FALL },
-	{ "RESIST_FIST", APPLY_RESIST_FIST },
-
-	{ "MOUNT", APPLY_MOUNT },
-
-	{ "SKILL_DAMAGE_SAMYEON", APPLY_SKILL_DAMAGE_SAMYEON },
-	{ "SKILL_DAMAGE_TANHWAN", APPLY_SKILL_DAMAGE_TANHWAN },
-	{ "SKILL_DAMAGE_PALBANG", APPLY_SKILL_DAMAGE_PALBANG },
-	{ "SKILL_DAMAGE_GIGONGCHAM", APPLY_SKILL_DAMAGE_GIGONGCHAM },
-	{ "SKILL_DAMAGE_GYOKSAN", APPLY_SKILL_DAMAGE_GYOKSAN },
-	{ "SKILL_DAMAGE_GEOMPUNG", APPLY_SKILL_DAMAGE_GEOMPUNG },
-	{ "SKILL_DAMAGE_AMSEOP", APPLY_SKILL_DAMAGE_AMSEOP },
-	{ "SKILL_DAMAGE_GUNGSIN", APPLY_SKILL_DAMAGE_GUNGSIN },
-	{ "SKILL_DAMAGE_CHARYUN", APPLY_SKILL_DAMAGE_CHARYUN },
-	{ "SKILL_DAMAGE_SANGONG", APPLY_SKILL_DAMAGE_SANGONG },
-	{ "SKILL_DAMAGE_YEONSA", APPLY_SKILL_DAMAGE_YEONSA },
-	{ "SKILL_DAMAGE_KWANKYEOK", APPLY_SKILL_DAMAGE_KWANKYEOK },
-	{ "SKILL_DAMAGE_GIGUNG", APPLY_SKILL_DAMAGE_GIGUNG },
-	{ "SKILL_DAMAGE_HWAJO", APPLY_SKILL_DAMAGE_HWAJO },
-	{ "SKILL_DAMAGE_SWAERYUNG", APPLY_SKILL_DAMAGE_SWAERYUNG },
-	{ "SKILL_DAMAGE_YONGKWON", APPLY_SKILL_DAMAGE_YONGKWON },
-	{ "SKILL_DAMAGE_PABEOB", APPLY_SKILL_DAMAGE_PABEOB },
-	{ "SKILL_DAMAGE_MARYUNG", APPLY_SKILL_DAMAGE_MARYUNG },
-	{ "SKILL_DAMAGE_HWAYEOMPOK", APPLY_SKILL_DAMAGE_HWAYEOMPOK },
-	{ "SKILL_DAMAGE_MAHWAN", APPLY_SKILL_DAMAGE_MAHWAN },
-	{ "SKILL_DAMAGE_BIPABU", APPLY_SKILL_DAMAGE_BIPABU },
-	{ "SKILL_DAMAGE_YONGBI", APPLY_SKILL_DAMAGE_YONGBI },
-	{ "SKILL_DAMAGE_PAERYONG", APPLY_SKILL_DAMAGE_PAERYONG },
-	{ "SKILL_DAMAGE_NOEJEON", APPLY_SKILL_DAMAGE_NOEJEON },
-	{ "SKILL_DAMAGE_BYEURAK", APPLY_SKILL_DAMAGE_BYEURAK },
-	{ "SKILL_DAMAGE_CHAIN", APPLY_SKILL_DAMAGE_CHAIN },
-	{ "SKILL_DAMAGE_CHAYEOL", APPLY_SKILL_DAMAGE_CHAYEOL },
-	{ "SKILL_DAMAGE_SALPOONG", APPLY_SKILL_DAMAGE_SALPOONG },
-	{ "SKILL_DAMAGE_GONGDAB", APPLY_SKILL_DAMAGE_GONGDAB },
-	{ "SKILL_DAMAGE_PASWAE", APPLY_SKILL_DAMAGE_PASWAE },
-
-	{ "NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE", APPLY_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE },
-	{ "SKILL_DEFEND_BONUS_BOSS_OR_MORE", APPLY_SKILL_DEFEND_BONUS_BOSS_OR_MORE },
-	{ "NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE", APPLY_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE },
-	{ "SKILL_DAMAGE_BONUS_BOSS_OR_MORE", APPLY_SKILL_DAMAGE_BONUS_BOSS_OR_MORE },
-
-	{ "HIT_BUFF_ENCHANT_FIRE", APPLY_HIT_BUFF_ENCHANT_FIRE },
-	{ "HIT_BUFF_ENCHANT_ICE", APPLY_HIT_BUFF_ENCHANT_ICE },
-	{ "HIT_BUFF_ENCHANT_ELEC", APPLY_HIT_BUFF_ENCHANT_ELEC },
-	{ "HIT_BUFF_ENCHANT_WIND", APPLY_HIT_BUFF_ENCHANT_WIND },
-	{ "HIT_BUFF_ENCHANT_DARK", APPLY_HIT_BUFF_ENCHANT_DARK },
-	{ "HIT_BUFF_ENCHANT_EARTH", APPLY_HIT_BUFF_ENCHANT_EARTH },
-	{ "HIT_BUFF_RESIST_FIRE", APPLY_HIT_BUFF_RESIST_FIRE },
-	{ "HIT_BUFF_RESIST_ICE", APPLY_HIT_BUFF_RESIST_ICE },
-	{ "HIT_BUFF_RESIST_ELEC", APPLY_HIT_BUFF_RESIST_ELEC },
-	{ "HIT_BUFF_RESIST_WIND", APPLY_HIT_BUFF_RESIST_WIND },
-	{ "HIT_BUFF_RESIST_DARK", APPLY_HIT_BUFF_RESIST_DARK },
-	{ "HIT_BUFF_RESIST_EARTH", APPLY_HIT_BUFF_RESIST_EARTH },
-
-	{ "USE_SKILL_CHEONGRANG_MOV_SPEED", APPLY_USE_SKILL_CHEONGRANG_MOV_SPEED },
-	{ "USE_SKILL_CHEONGRANG_CASTING_SPEED", APPLY_USE_SKILL_CHEONGRANG_CASTING_SPEED },
-	{ "USE_SKILL_CHAYEOL_CRITICAL_PCT", APPLY_USE_SKILL_CHAYEOL_CRITICAL_PCT },
-	{ "USE_SKILL_SANGONG_ATT_GRADE_BONUS", APPLY_USE_SKILL_SANGONG_ATT_GRADE_BONUS },
-	{ "USE_SKILL_GIGUNG_ATT_GRADE_BONUS", APPLY_USE_SKILL_GIGUNG_ATT_GRADE_BONUS },
-	{ "USE_SKILL_JEOKRANG_DEF_BONUS", APPLY_USE_SKILL_JEOKRANG_DEF_BONUS },
-	{ "USE_SKILL_GWIGEOM_DEF_BONUS", APPLY_USE_SKILL_GWIGEOM_DEF_BONUS },
-	{ "USE_SKILL_TERROR_ATT_GRADE_BONUS", APPLY_USE_SKILL_TERROR_ATT_GRADE_BONUS },
-	{ "USE_SKILL_MUYEONG_ATT_GRADE_BONUS", APPLY_USE_SKILL_MUYEONG_ATT_GRADE_BONUS },
-	{ "USE_SKILL_MANASHILED_CASTING_SPEED", APPLY_USE_SKILL_MANASHILED_CASTING_SPEED },
-	{ "USE_SKILL_HOSIN_DEF_BONUS", APPLY_USE_SKILL_HOSIN_DEF_BONUS },
-	{ "USE_SKILL_GICHEON_ATT_GRADE_BONUS", APPLY_USE_SKILL_GICHEON_ATT_GRADE_BONUS },
-	{ "USE_SKILL_JEONGEOP_ATT_GRADE_BONUS", APPLY_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS },
-	{ "USE_SKILL_JEUNGRYEOK_DEF_BONUS", APPLY_USE_SKILL_JEUNGRYEOK_DEF_BONUS },
-	{ "USE_SKILL_GIHYEOL_ATT_GRADE_BONUS", APPLY_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS },
-	{ "USE_SKILL_CHUNKEON_CASTING_SPEED", APPLY_USE_SKILL_CHUNKEON_CASTING_SPEED },
-	{ "USE_SKILL_NOEGEOM_ATT_GRADE_BONUS", APPLY_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS },
-
-	{ "SKILL_DURATION_INCREASE_EUNHYUNG", APPLY_SKILL_DURATION_INCREASE_EUNHYUNG },
-	{ "SKILL_DURATION_INCREASE_GYEONGGONG", APPLY_SKILL_DURATION_INCREASE_GYEONGGONG },
-	{ "SKILL_DURATION_INCREASE_GEOMKYUNG", APPLY_SKILL_DURATION_INCREASE_GEOMKYUNG },
-	{ "SKILL_DURATION_INCREASE_JEOKRANG", APPLY_SKILL_DURATION_INCREASE_JEOKRANG },
-
-	{ "USE_SKILL_PALBANG_HP_ABSORB", APPLY_USE_SKILL_PALBANG_HP_ABSORB },
-	{ "USE_SKILL_AMSEOP_HP_ABSORB", APPLY_USE_SKILL_AMSEOP_HP_ABSORB },
-	{ "USE_SKILL_YEONSA_HP_ABSORB", APPLY_USE_SKILL_YEONSA_HP_ABSORB },
-	{ "USE_SKILL_YONGBI_HP_ABSORB", APPLY_USE_SKILL_YONGBI_HP_ABSORB },
-	{ "USE_SKILL_CHAIN_HP_ABSORB", APPLY_USE_SKILL_CHAIN_HP_ABSORB },
-	{ "USE_SKILL_PASWAE_SP_ABSORB", APPLY_USE_SKILL_PASWAE_SP_ABSORB },
-
-	{ "USE_SKILL_GIGONGCHAM_STUN", APPLY_USE_SKILL_GIGONGCHAM_STUN },
-	{ "USE_SKILL_CHARYUN_STUN", APPLY_USE_SKILL_CHARYUN_STUN },
-	{ "USE_SKILL_PABEOB_STUN", APPLY_USE_SKILL_PABEOB_STUN },
-	{ "USE_SKILL_MAHWAN_STUN", APPLY_USE_SKILL_MAHWAN_STUN },
-	{ "USE_SKILL_GONGDAB_STUN", APPLY_USE_SKILL_GONGDAB_STUN },
-	{ "USE_SKILL_SAMYEON_STUN", APPLY_USE_SKILL_SAMYEON_STUN },
-
-	{ "USE_SKILL_GYOKSAN_KNOCKBACK", APPLY_USE_SKILL_GYOKSAN_KNOCKBACK },
-	{ "USE_SKILL_SEOMJEON_KNOCKBACK", APPLY_USE_SKILL_SEOMJEON_KNOCKBACK },
-	{ "USE_SKILL_SWAERYUNG_KNOCKBACK", APPLY_USE_SKILL_SWAERYUNG_KNOCKBACK },
-	{ "USE_SKILL_HWAYEOMPOK_KNOCKBACK", APPLY_USE_SKILL_HWAYEOMPOK_KNOCKBACK },
-	{ "USE_SKILL_GONGDAB_KNOCKBACK", APPLY_USE_SKILL_GONGDAB_KNOCKBACK },
-	{ "USE_SKILL_KWANKYEOK_KNOCKBACK", APPLY_USE_SKILL_KWANKYEOK_KNOCKBACK },
-
-	{ "USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER },
-	{ "USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER },
-	{ "USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER },
-	{ "USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER },
-	{ "USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER },
-	{ "USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER },
-	{ "USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER },
-	{ "USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER },
-	{ "USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER },
-	{ "USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER },
-
-	{ "ATTBONUS_STONE", APPLY_ATTBONUS_STONE },
-
-	{ "DAMAGE_HP_RECOVERY", APPLY_DAMAGE_HP_RECOVERY },
-	{ "DAMAGE_SP_RECOVERY", APPLY_DAMAGE_SP_RECOVERY },
-
-	{ "ALIGNMENT_DAMAGE_BONUS", APPLY_ALIGNMENT_DAMAGE_BONUS },
-
-	{ "NORMAL_DAMAGE_GUARD", APPLY_NORMAL_DAMAGE_GUARD },
-	{ "MORE_THEN_HP90_DAMAGE_REDUCE", APPLY_MORE_THEN_HP90_DAMAGE_REDUCE },
-
-	{ "USE_SKILL_TUSOK_HP_ABSORB", APPLY_USE_SKILL_TUSOK_HP_ABSORB },
-	{ "USE_SKILL_PAERYONG_HP_ABSORB", APPLY_USE_SKILL_PAERYONG_HP_ABSORB },
-	{ "USE_SKILL_BYEURAK_HP_ABSORB", APPLY_USE_SKILL_BYEURAK_HP_ABSORB },
-
-	{ "FIRST_ATTRIBUTE_BONUS", APPLY_FIRST_ATTRIBUTE_BONUS },
-	{ "SECOND_ATTRIBUTE_BONUS", APPLY_SECOND_ATTRIBUTE_BONUS },
-	{ "THIRD_ATTRIBUTE_BONUS", APPLY_THIRD_ATTRIBUTE_BONUS },
-	{ "FOURTH_ATTRIBUTE_BONUS", APPLY_FOURTH_ATTRIBUTE_BONUS },
-	{ "FIFTH_ATTRIBUTE_BONUS", APPLY_FIFTH_ATTRIBUTE_BONUS },
-
-	{ "USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER },
-	{ "USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER },
-	{ "USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER },
-	{ "USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER },
-	{ "USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER },
-	{ "USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER },
-	{ "USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER },
-	{ "USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER },
-	{ "USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER },
-	{ "USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER },
-	{ "USE_SKILL_CHAYEOL_HP_ABSORB", APPLY_USE_SKILL_CHAYEOL_HP_ABSORB },
-
-	{ "SUNGMA_STR", APPLY_SUNGMA_STR },
-	{ "SUNGMA_HP", APPLY_SUNGMA_HP },
-	{ "SUNGMA_MOVE", APPLY_SUNGMA_MOVE },
-	{ "SUNGMA_IMMUNE", APPLY_SUNGMA_IMMUNE },
-
-	{ "HIT_PCT", APPLY_HIT_PCT },
-#if defined(__ITEM_APPLY_RANDOM__)
-	{ "RANDOM", APPLY_NONE },
-#endif
-
-	{ "ATTBONUS_PER_HUMAN", APPLY_ATTBONUS_PER_HUMAN },
-	{ "ATTBONUS_PER_ANIMAL", APPLY_ATTBONUS_PER_ANIMAL },
-	{ "ATTBONUS_PER_ORC", APPLY_ATTBONUS_PER_ORC },
-	{ "ATTBONUS_PER_MILGYO", APPLY_ATTBONUS_PER_MILGYO },
-	{ "ATTBONUS_PER_UNDEAD", APPLY_ATTBONUS_PER_UNDEAD },
-	{ "ATTBONUS_PER_DEVIL", APPLY_ATTBONUS_PER_DEVIL },
-
-	{ "ENCHANT_PER_ELECT", APPLY_ENCHANT_PER_ELECT },
-	{ "ENCHANT_PER_FIRE", APPLY_ENCHANT_PER_FIRE },
-	{ "ENCHANT_PER_ICE", APPLY_ENCHANT_PER_ICE },
-	{ "ENCHANT_PER_WIND", APPLY_ENCHANT_PER_WIND },
-	{ "ENCHANT_PER_EARTH", APPLY_ENCHANT_PER_EARTH },
-	{ "ENCHANT_PER_DARK", APPLY_ENCHANT_PER_DARK },
-
-	{ "ATTBONUS_PER_CZ", APPLY_ATTBONUS_PER_CZ },
-	{ "ATTBONUS_PER_INSECT", APPLY_ATTBONUS_PER_INSECT },
-	{ "ATTBONUS_PER_DESERT", APPLY_ATTBONUS_PER_DESERT },
-	{ "ATTBONUS_PER_STONE", APPLY_ATTBONUS_PER_STONE },
-	{ "ATTBONUS_PER_MONSTER", APPLY_ATTBONUS_PER_MONSTER },
-
-	{ "RESIST_PER_HUMAN", APPLY_RESIST_PER_HUMAN },
-	{ "RESIST_PER_ICE", APPLY_RESIST_PER_ICE },
-	{ "RESIST_PER_DARK", APPLY_RESIST_PER_DARK },
-	{ "RESIST_PER_EARTH", APPLY_RESIST_PER_EARTH },
-	{ "RESIST_PER_FIRE", APPLY_RESIST_PER_FIRE },
-	{ "RESIST_PER_ELEC", APPLY_RESIST_PER_ELEC },
-	{ "RESIST_PER_MAGIC", APPLY_RESIST_PER_MAGIC },
-	{ "RESIST_PER_WIND", APPLY_RESIST_PER_WIND },
-
-	{ "HIT_BUFF_SUNGMA_STR", APPLY_HIT_BUFF_SUNGMA_STR },
-	{ "HIT_BUFF_SUNGMA_MOVE", APPLY_HIT_BUFF_SUNGMA_MOVE },
-	{ "HIT_BUFF_SUNGMA_HP", APPLY_HIT_BUFF_SUNGMA_HP },
-	{ "HIT_BUFF_SUNGMA_IMMUNE", APPLY_HIT_BUFF_SUNGMA_IMMUNE },
-
-	{ "MOUNT_MELEE_MAGIC_ATTBONUS_PER", APPLY_MOUNT_MELEE_MAGIC_ATTBONUS_PER },
-	{ "DISMOUNT_MOVE_SPEED_BONUS_PER", APPLY_DISMOUNT_MOVE_SPEED_BONUS_PER },
-
-	{ "HIT_AUTO_HP_RECOVERY", APPLY_HIT_AUTO_HP_RECOVERY },
-	{ "HIT_AUTO_SP_RECOVERY", APPLY_HIT_AUTO_SP_RECOVERY },
-
-	{ "USE_SKILL_COOLTIME_DECREASE_ALL", APPLY_USE_SKILL_COOLTIME_DECREASE_ALL },
-
-	{ "HIT_STONE_ATTBONUS_STONE", APPLY_HIT_STONE_ATTBONUS_STONE },
-	{ "HIT_STONE_DEF_GRADE_BONUS", APPLY_HIT_STONE_DEF_GRADE_BONUS },
-
-	{ "KILL_BOSS_ITEM_BONUS", APPLY_KILL_BOSS_ITEM_BONUS },
-	{ "MOB_HIT_MOB_AGGRESSIVE", APPLY_MOB_HIT_MOB_AGGRESSIVE },
-	{ "NO_DEATH_AND_HP_RECOVERY30", APPLY_NO_DEATH_AND_HP_RECOVERY30 },
-
-	{ "AUTO_PICKUP", APPLY_AUTO_PICKUP },
-	{ "MOUNT_NO_KNOCKBACK", APPLY_MOUNT_NO_KNOCKBACK },
-
-	{ "SUNGMA_PER_STR", APPLY_SUNGMA_PER_STR },
-	{ "SUNGMA_PER_HP", APPLY_SUNGMA_PER_HP },
-	{ "SUNGMA_PER_MOVE", APPLY_SUNGMA_PER_MOVE },
-	{ "SUNGMA_PER_IMMUNE", APPLY_SUNGMA_PER_IMMUNE },
-
-	{ "IMMUNE_POISON100", APPLY_IMMUNE_POISON100 },
-	{ "IMMUNE_BLEEDING100", APPLY_IMMUNE_BLEEDING100 },
-
-	{ "MONSTER_DEFEND_BONUS", APPLY_MONSTER_DEFEND_BONUS },
-
-	// by mhh game/affect.h 정의되어있음. INFINITE_AFFECT_DURATION = 0x1FFFFFFF
-	{ "INFINITE_AFFECT_DURATION", 0x1FFFFFFF },
-
-	// 20200806.Owsap : Old apply values support.
-	{ "ATTACK_SPEED", APPLY_ATT_SPEED },
-	{ "MOVE_SPEED", APPLY_MOV_SPEED },
-	{ "ATT_BONUS", APPLY_ATT_GRADE_BONUS },
-	{ "DEF_BONUS", APPLY_DEF_GRADE_BONUS },
-	{ "ATT_BONUS_TO_WARRIOR", APPLY_ATTBONUS_WARRIOR },
-	{ "ATT_BONUS_TO_ASSASSIN", APPLY_ATTBONUS_ASSASSIN },
-	{ "ATT_BONUS_TO_SURA", APPLY_ATTBONUS_SURA },
-	{ "ATT_BONUS_TO_SHAMAN", APPLY_ATTBONUS_SHAMAN },
-	{ "ATT_BONUS_TO_WOLFMAN", APPLY_ATTBONUS_WOLFMAN },
-
-	{ NULL, 0 }
-};
-// from import_item_proto.c
-
-long FN_get_apply_type(const char* apply_type_string)
-{
-	TValueName* value_name;
-	for (value_name = c_aApplyTypeNames; value_name->c_pszName; ++value_name)
-	{
-		if (0 == strcasecmp(value_name->c_pszName, apply_type_string))
-			return value_name->lValue;
-	}
-	return 0;
-}
-
-#if defined(__SOUL_SYSTEM__)
-const int soul_refine_prob[SOUL_GRADE_MAX + 1] = { 0, 60, 40, 20, 30, 15 };
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-/*
-* By hard coding the required keys, the code becomes more readable
-* and maintainable, as anyone reading the code can immediately can
-* immediately see the requiremented keys for each stage.
-*/
-const BYTE abInvenStageKeys[EX_INVENTORY_STAGE_MAX] =
-{
-	// 90 - 135
-	2, 2, 2,
-	3, 3, 3,
-	4, 4, 4,
-	// 135 - 180
-	5, 5, 5,
-	6, 6, 6,
-	7, 7, 7
-};
-#endif
-
-TEmotionInfoMap EmotionInfoMap
-{
-	{ EMOTION_NONE, { 0, 0.0f } },
-	{ EMOTION_CLAP, { EMOTION_FLAG_SELF, 2.66667f } },
-	{ EMOTION_CONGRATULATION, { EMOTION_FLAG_SELF, 6.33333f } },
-	{ EMOTION_FORGIVE, { EMOTION_FLAG_SELF, 8.33333f } },
-	{ EMOTION_ANGRY, { EMOTION_FLAG_SELF, 4.33333f } },
-	{ EMOTION_ATTRACTIVE, { EMOTION_FLAG_SELF, 4.83333f } },
-	{ EMOTION_SAD, { EMOTION_FLAG_SELF, 7.33333f } },
-	{ EMOTION_SHY, { EMOTION_FLAG_SELF, 4.66667f } },
-	{ EMOTION_CHEERUP, { EMOTION_FLAG_SELF, 5.0f } },
-	{ EMOTION_BANTER, { EMOTION_FLAG_SELF, 7.0f } },
-	{ EMOTION_JOY, { EMOTION_FLAG_SELF, 5.33333f } },
-	{ EMOTION_CHEERS_1, { EMOTION_FLAG_SELF, 2.33333f } },
-	{ EMOTION_CHEERS_2, { EMOTION_FLAG_SELF, 2.33333f } },
-	{ EMOTION_DANCE_1, { EMOTION_FLAG_SELF, 28.3333f } },
-	{ EMOTION_DANCE_2, { EMOTION_FLAG_SELF, 4.76667f } },
-	{ EMOTION_DANCE_3, { EMOTION_FLAG_SELF, 27.3333f } },
-	{ EMOTION_DANCE_4, { EMOTION_FLAG_SELF, 30.3333f } },
-	{ EMOTION_DANCE_5, { EMOTION_FLAG_SELF, 21.1f } },
-	{ EMOTION_DANCE_6, { EMOTION_FLAG_SELF, 30.433332f } },
-	{ EMOTION_KISS, { EMOTION_FLAG_TARGET | EMOTION_FLAG_OTHER_SEX, 1.5f } },
-	{ EMOTION_FRENCH_KISS, { EMOTION_FLAG_TARGET | EMOTION_FLAG_OTHER_SEX, 4.0f } },
-	{ EMOTION_SLAP, { EMOTION_FLAG_TARGET, 2.0f } },
-#if defined(__EXPRESSING_EMOTIONS__)
-	{ EMOTION_PUSH_UP, { EMOTION_FLAG_SELF, 6.666667f } },
-	{ EMOTION_DANCE_7, { EMOTION_FLAG_SELF, 12.0f } },
-	{ EMOTION_EXERCISE, { EMOTION_FLAG_SELF, 6.333333f } },
-	{ EMOTION_DOZE, { EMOTION_FLAG_SELF, 4.666667f } },
-	{ EMOTION_SELFIE, { EMOTION_FLAG_SELF, 3.000000f } },
-	{ EMOTION_CHARGING, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_NOSAY, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_WEATHER_1, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_WEATHER_2, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_WEATHER_3, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_HUNGRY, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_SIREN, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_LETTER, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_CALL, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_CELEBRATION, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_ALCOHOL, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_BUSY, { EMOTION_FLAG_SELF, 0.0f } },
-	{ EMOTION_WHIRL, { EMOTION_FLAG_SELF, 0.0f } },
-#endif
-};
-
-#if defined(__HIDE_COSTUME_SYSTEM__)
-THiddenCostumePartMap HiddenCostumePartMap
-{
-	{ COSTUME_BODY, "costume_option.hide_body" },
-	{ COSTUME_HAIR, "costume_option.hide_hair" },
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	{ COSTUME_ACCE, "costume_option.hide_acce" },
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-	{ COSTUME_WEAPON, "costume_option.hide_weapon" },
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	{ COSTUME_AURA, "costume_option.hide_aura" },
-#endif
-};
-#endif
+#include "stdafx.h"
+#include "char.h"
+
+#ifdef __GROWTH_PET_SYSTEM__
+const TPetEvolution arPetEvolutionTable[3] =
+{
+	// Young ? Wild
+	{
+		40, // Required Level
+		"the level Wild",
+		{
+			{55003,	10}, // Young Pet Book
+			{30058, 10}, // Spider Egg Sack
+			{30073, 10}, // White Hairband+
+			{30041, 10}, // Shiriken
+			{30017, 10}, // Ornamental Hairpin
+			{30074, 5},	 // Black Uniform+
+			{30088, 5},	 // Piece of Ice+
+		}
+	},
+
+	// Wild ? Valiant
+	{
+		80, // Required Level
+		"the level Valiant",
+		{
+			{55004, 10}, // Wild Pet Book
+			{27994, 2},  // Blood-Red Pearl
+			{30035, 10}, // Face Cream
+			{30089, 10}, // Yeti Fur+
+			{30031, 10}, // Ornament
+			{30011, 10}, // Ball
+			{30080, 5},  // Curse Book+
+		}
+	},
+
+	// Valiant ? Heroic
+	{
+		81, // Required Level
+		"the level Heroic",
+		{
+			{55005, 10}, // Valiant Pet Book
+			{30083, 10}, // Unknown Medicine+
+			{27992, 2},  // White Pearl
+			{27993, 2},  // Blue Pearl
+			{30086, 10}, // Demons Keepsake+
+			{30077, 10}, // Orc Tooth+
+			{30550, 5},  // Blue Belt
+		}
+	},
+};
+
+const TPetHatch arPetHatchTable[PET_MAX_NUM] =
+{
+	{ PET_MONKEY,			2, 1, 14 },
+	{ PET_SPIDER,			2, 1, 14 },
+	{ PET_RAZADOR,			3, 1, 14 },
+	{ PET_NEMERE,			3, 1, 14 },
+	{ PET_BLUE_DRAGON,		3, 1, 14 },
+	{ PET_RED_DRAGON,		3, 15, 45 },
+	{ PET_AZRAEL,			2, 1, 14 },
+	{ PET_MINI_EXECUTOR,	3, 1, 14 },
+	{ PET_BASHIIDO,			3, 7, 28 },
+	{ PET_NESSIE,			3, 15, 45 },
+	{ PET_EXEDYAR,			3, 15, 45 },
+};
+
+const TPetBonus arPetHPBonusTable[PET_MAX_BONUS_NUM] =
+{
+	{1,	5},
+	{2,	3},
+	{1, 7},
+	{3, 4},
+	{1, 9},
+	{5, 6},
+	{1, 10},
+	{5, 7},
+};
+
+const TPetBonus arPetSPBonusTable[PET_MAX_BONUS_NUM] =
+{
+	{1, 2},
+	{2, 3},
+	{1, 3},
+	{3, 4},
+	{1, 4},
+	{4, 5},
+	{1, 6},
+	{5, 6},
+};
+
+const TPetBonus arPetDefBonusTable[PET_MAX_BONUS_NUM] =
+{
+	{1, 5},
+	{2, 3},
+	{1, 7},
+	{3, 4},
+	{1, 9},
+	{4, 5},
+	{1, 11},
+	{5, 6},
+};
+#endif
+
+TJobInitialPoints JobInitialPoints[JOB_MAX_NUM] =
+/*
+{
+	int st, ht, dx, iq;
+	int max_hp, max_sp;
+	int hp_per_ht, sp_per_iq;
+	int hp_per_lv_begin, hp_per_lv_end;
+	int sp_per_lv_begin, sp_per_lv_end;
+	int max_stamina;
+	int stamina_per_con;
+	int stamina_per_lv_begin, stamina_per_lv_end;
+}
+*/
+{
+	//	str	con	dex	int	珂HP	珂SP	CON/HP	INT/SP	HP/lv	MP/lv	珂stam	stam/con	stam/lv
+	{	 6,	4,	3,	3,	600,	200,	40,		20,		36,	44,		18,	22,		800,		5,			1,	3 }, // JOB_WARRIOR 16
+	{	 4,	3,	6,	3,	650,	200,	40,		20,		36,	44,		18,	22,		800,		5,			1,	3 }, // JOB_ASSASSIN 16
+	{	 5,	3,	3,	5,	650,	200,	40,		20,		36,	44,		18,	22,		800,		5,			1,	3 }, // JOB_SURA 16
+	{	 3,	4,	3,	6,	700,	200,	40,		20,		36,	44,		18,	22,		800,		5,			1,	3 }, // JOB_SHAMAN 16
+	{	 2,	6,	6,	2,	600,	200,	40,		20,		36,	44,		18,	22,		800,		5,			1,	3 }, // JOB_WOLFMAN 16
+};
+
+const TMobRankStat MobRankStats[MOB_RANK_MAX_NUM] =
+/*
+{
+	int iGoldPercent;
+}
+*/
+{
+	{ 20, }, // MOB_RANK_PAWN,
+	{ 20, }, // MOB_RANK_S_PAWN,
+	{ 25, }, // MOB_RANK_KNIGHT,
+	{ 30, }, // MOB_RANK_S_KNIGHT,
+	{ 50, }, // MOB_RANK_BOSS,
+	{ 100, } // MOB_RANK_KING,
+};
+
+TBattleTypeStat BattleTypeStats[BATTLE_TYPE_MAX_NUM] =
+/*
+{
+	int AttGradeBias;
+	int DefGradeBias;
+	int MagicAttGradeBias;
+	int MagicDefGradeBias;
+}
+*/
+{
+	{ 0, 0, 0, -10 }, // BATTLE_TYPE_MELEE,
+	{ 10, -20, -10, -15 }, // BATTLE_TYPE_RANGE,
+	{ -5, -5, 10, 10 }, // BATTLE_TYPE_MAGIC,
+	{ 0, 0, 0, 0 }, // BATTLE_TYPE_SPECIAL,
+	{ 10, -10, 0, -15 }, // BATTLE_TYPE_POWER,
+	{ -10, 10, -10, 0 }, // BATTLE_TYPE_TANKER,
+	{ 20, -20, 0, -10 }, // BATTLE_TYPE_SUPER_POWER,
+	{ -20, 20, -10, 0 }, // BATTLE_TYPE_SUPER_TANKER,
+};
+
+const DWORD* exp_table = NULL;
+const DWORD exp_table_common[PLAYER_EXP_TABLE_MAX + 1] =
+{
+	0, // 0
+	300,
+	800,
+	1500,
+	2500,
+	4300,
+	7200,
+	11000,
+	17000,
+	24000,
+	33000, // 10
+	43000,
+	58000,
+	76000,
+	100000,
+	130000,
+	169000,
+	219000,
+	283000,
+	365000,
+	472000, // 20
+	610000,
+	705000,
+	813000,
+	937000,
+	1077000,
+	1237000,
+	1418000,
+	1624000,
+	1857000,
+	2122000, // 30
+	2421000,
+	2761000,
+	3145000,
+	3580000,
+	4073000,
+	4632000,
+	5194000,
+	5717000,
+	6264000,
+	6837000, // 40
+	7600000,
+	8274000,
+	8990000,
+	9753000,
+	10560000,
+	11410000,
+	12320000,
+	13270000,
+	14280000,
+	15340000, // 50
+	16870000,
+	18960000,
+	19980000,
+	21420000,
+	22930000,
+	24530000,
+	26200000,
+	27960000,
+	29800000,
+	32780000, // 60
+	36060000,
+	39670000,
+	43640000,
+	48000000,
+	52800000,
+	58080000,
+	63890000,
+	70280000,
+	77310000,
+	85040000, // 70
+	93540000,
+	102900000,
+	113500000,
+	121000000,
+	137000000,
+	150700000,
+	165700000,
+	236990000,
+	260650000,
+	286780000, // 80
+	315000000,
+	346970000,
+	381680000,
+	419770000,
+	461760000,
+	508040000,
+	558740000,
+	614640000,
+	676130000,
+	743730000, // 90
+	1041222000,
+	1145344200,
+	1259878620,
+	1385866482,
+	1524453130,
+	1676898443,
+	1844588288,
+	2029047116,
+	2050000000, // 99   却치 (100 풉 )
+	2150000000, // 100
+	2210000000,
+	2250000000,
+	2280000000,
+	2310000000,
+	2340000000,
+	2370000000,
+	2400000000,
+	2430000000,
+	2460000000,
+	2490000000, // 110
+	2520000000,
+	2550000000,
+	2580000000,
+	2610000000,
+	2640000000,
+	2670000000,
+	2700000000,
+	2730000000,
+	2760000000,
+	2790000000, // 120
+};
+
+#if defined(__CONQUEROR_LEVEL__)
+const DWORD* conqueror_exp_table = NULL;
+const DWORD conqueror_exp_table_common[PLAYER_CONQUEROR_EXP_TABLE_MAX + 1] =
+{
+	0, // 0
+	433400,
+	1300204,
+	2600413,
+	4334029,
+	6501054,
+	9101490,
+	12135339,
+	15602603,
+	19503284,
+	23837384, // 10
+	28604905,
+	33805849,
+	39440218,
+	45508014,
+	52009239,
+	58943895,
+	66311984,
+	74113508,
+	82348469,
+	91016869, // 20
+	100118710,
+	109653994,
+	119622723,
+	130024899,
+	140860524,
+	152129600,
+	163832129,
+	175968113,
+	188537554,
+	188537554, // 30
+};
+#endif
+
+const int* aiPercentByDeltaLev = NULL;
+const int* aiPercentByDeltaLevForBoss = NULL;
+
+//   結  轅 풔 遣
+// MIN(MAX_EXP_DELTA_OF_LEV - 1, ( + 15) - ))
+const int aiPercentByDeltaLevForBoss_euckr[MAX_EXP_DELTA_OF_LEV] =
+{
+	1,		// -15	0
+	3,		// -14	1
+	5,		// -13	2
+	7,		// -12	3
+	15,		// -11	4
+	30,		// -10	5
+	60,		// -9	6
+	90,		// -8	7
+	91,		// -7	8
+	92,		// -6	9
+	93,		// -5	10
+	94,		// -4	11
+	95,		// -3	12
+	97,		// -2	13
+	99,		// -1	14
+	100,	// 0	15
+	105,	// 1	16
+	110,	// 2	17
+	115,	// 3	18
+	120,	// 4	19
+	125,	// 5	20
+	130,	// 6	21
+	135,	// 7	22
+	140,	// 8	23
+	145,	// 9	24
+	150,	// 10	25
+	155,	// 11	26
+	160,	// 12	27
+	165,	// 13	28
+	170,	// 14	29
+	180,	// 15	30
+};
+
+const int aiPercentByDeltaLev_euckr[MAX_EXP_DELTA_OF_LEV] =
+{
+	1,		// -15	0
+	5,		// -14	1
+	10,		// -13	2
+	20,		// -12	3
+	30,		// -11	4
+	50,		// -10	5
+	70,		// -9	6
+	80,		// -8	7
+	85,		// -7	8
+	90,		// -6	9
+	92,		// -5	10
+	94,		// -4	11
+	96,		// -3	12
+	98,		// -2	13
+	100,	// -1	14
+	100,	// 0	15
+	105,	// 1	16
+	110,	// 2	17
+	115,	// 3	18
+	120,	// 4	19
+	125,	// 5	20
+	130,	// 6	21
+	135,	// 7	22
+	140,	// 8	23
+	145,	// 9	24
+	150,	// 10	25
+	155,	// 11	26
+	160,	// 12	27
+	165,	// 13	28
+	170,	// 14	29
+	180,	// 15	30
+};
+
+const DWORD party_exp_distribute_table[PLAYER_MAX_LEVEL_CONST + 1] =
+{
+	0,
+	10,		10,		10,		10,		15,		15,		20,		25,		30,		40,		// 1 - 10
+	50,		60,		80,		100,	120,	140,	160,	184,	210,	240,	// 11 - 20
+	270,	300,	330,	360,	390,	420,	450,	480,	510,	550,	// 21 - 30
+	600,	640,	700,	760,	820,	880,	940,	1000,	1100,	1180,	// 31 - 40
+	1260,	1320,	1380,	1440,	1500,	1560,	1620,	1680,	1740,	1800,	// 41 - 50
+	1860,	1920,	2000,	2100,	2200,	2300,	2450,	2600,	2750,	2900,	// 51 - 60
+	3050,	3200,	3350,	3500,	3650,	3800,	3950,	4100,	4250,	4400,	// 61 - 70
+	4600,	4800,	5000,	5200,	5400,	5600,	5800,	6000,	6200,	6400,	// 71 - 80
+	6600,	6900,	7100,	7300,	7600,	7800,	8000,	8300,	8500,	8800,	// 81 - 90
+	9000,	9000,	9000,	9000,	9000,	9000,	9000,	9000,	9000,	9000,	// 91 - 100
+	10000,	10000,	10000,	10000,	10000,	10000,	10000,	10000,	10000,	10000,	// 101 - 110
+	12000,	12000,	12000,	12000,	12000,	12000,	12000,	12000,	12000,	12000,	// 111 - 120
+};
+
+Coord aArroundCoords[ARROUND_COORD_MAX_NUM] =
+{
+	{ 0, 0 },
+	{ 0, 50 },
+	{ 35, 35 },
+	{ 50, -0 },
+	{ 35, -35 },
+	{ 0, -50 },
+	{ -35, -35 },
+	{ -50, 0 },
+	{ -35, 35 },
+	{ 0, 100 },
+	{ 71, 71 },
+	{ 100, -0 },
+	{ 71, -71 },
+	{ 0, -100 },
+	{ -71, -71 },
+	{ -100, 0 },
+	{ -71, 71 },
+	{ 0, 150 },
+	{ 106, 106 },
+	{ 150, -0 },
+	{ 106, -106 },
+	{ 0, -150 },
+	{ -106, -106 },
+	{ -150, 0 },
+	{ -106, 106 },
+	{ 0, 200 },
+	{ 141, 141 },
+	{ 200, -0 },
+	{ 141, -141 },
+	{ 0, -200 },
+	{ -141, -141 },
+	{ -200, 0 },
+	{ -141, 141 },
+	{ 0, 250 },
+	{ 177, 177 },
+	{ 250, -0 },
+	{ 177, -177 },
+	{ 0, -250 },
+	{ -177, -177 },
+	{ -250, 0 },
+	{ -177, 177 },
+	{ 0, 300 },
+	{ 212, 212 },
+	{ 300, -0 },
+	{ 212, -212 },
+	{ 0, -300 },
+	{ -212, -212 },
+	{ -300, 0 },
+	{ -212, 212 },
+	{ 0, 350 },
+	{ 247, 247 },
+	{ 350, -0 },
+	{ 247, -247 },
+	{ 0, -350 },
+	{ -247, -247 },
+	{ -350, 0 },
+	{ -247, 247 },
+	{ 0, 400 },
+	{ 283, 283 },
+	{ 400, -0 },
+	{ 283, -283 },
+	{ 0, -400 },
+	{ -283, -283 },
+	{ -400, 0 },
+	{ -283, 283 },
+	{ 0, 450 },
+	{ 318, 318 },
+	{ 450, -0 },
+	{ 318, -318 },
+	{ 0, -450 },
+	{ -318, -318 },
+	{ -450, 0 },
+	{ -318, 318 },
+	{ 0, 500 },
+	{ 354, 354 },
+	{ 500, -0 },
+	{ 354, -354 },
+	{ 0, -500 },
+	{ -354, -354 },
+	{ -500, 0 },
+	{ -354, 354 },
+	{ 0, 550 },
+	{ 389, 389 },
+	{ 550, -0 },
+	{ 389, -389 },
+	{ 0, -550 },
+	{ -389, -389 },
+	{ -550, 0 },
+	{ -389, 389 },
+	{ 0, 600 },
+	{ 424, 424 },
+	{ 600, -0 },
+	{ 424, -424 },
+	{ 0, -600 },
+	{ -424, -424 },
+	{ -600, 0 },
+	{ -424, 424 },
+	{ 0, 650 },
+	{ 460, 460 },
+	{ 650, -0 },
+	{ 460, -460 },
+	{ 0, -650 },
+	{ -460, -460 },
+	{ -650, 0 },
+	{ -460, 460 },
+	{ 0, 700 },
+	{ 495, 495 },
+	{ 700, -0 },
+	{ 495, -495 },
+	{ 0, -700 },
+	{ -495, -495 },
+	{ -700, 0 },
+	{ -495, 495 },
+	{ 0, 750 },
+	{ 530, 530 },
+	{ 750, -0 },
+	{ 530, -530 },
+	{ 0, -750 },
+	{ -530, -530 },
+	{ -750, 0 },
+	{ -530, 530 },
+	{ 0, 800 },
+	{ 566, 566 },
+	{ 800, -0 },
+	{ 566, -566 },
+	{ 0, -800 },
+	{ -566, -566 },
+	{ -800, 0 },
+	{ -566, 566 },
+	{ 0, 850 },
+	{ 601, 601 },
+	{ 850, -0 },
+	{ 601, -601 },
+	{ 0, -850 },
+	{ -601, -601 },
+	{ -850, 0 },
+	{ -601, 601 },
+	{ 0, 900 },
+	{ 636, 636 },
+	{ 900, -0 },
+	{ 636, -636 },
+	{ 0, -900 },
+	{ -636, -636 },
+	{ -900, 0 },
+	{ -636, 636 },
+	{ 0, 950 },
+	{ 672, 672 },
+	{ 950, -0 },
+	{ 672, -672 },
+	{ 0, -950 },
+	{ -672, -672 },
+	{ -950, 0 },
+	{ -672, 672 },
+	{ 0, 1000 },
+	{ 707, 707 },
+	{ 1000, -0 },
+	{ 707, -707 },
+	{ 0, -1000 },
+	{ -707, -707 },
+	{ -1000, 0 },
+	{ -707, 707 },
+};
+
+const DWORD guild_exp_table[GUILD_MAX_LEVEL + 1] =
+{
+	0,
+	15000UL,
+	45000UL,
+	90000UL,
+	160000UL,
+	235000UL,
+	325000UL,
+	430000UL,
+	550000UL,
+	685000UL,
+	835000UL,
+	1000000UL,
+	1500000UL,
+	2100000UL,
+	2800000UL,
+	3600000UL,
+	4500000UL,
+	6500000UL,
+	8000000UL,
+	10000000UL,
+	42000000UL
+};
+
+// INTERNATIONAL_VERSION 치
+const DWORD guild_exp_table2[GUILD_MAX_LEVEL + 1] =
+{
+	0,
+	6000UL,
+	18000UL,
+	36000UL,
+	64000UL,
+	94000UL,
+	130000UL,
+	172000UL,
+	220000UL,
+	274000UL,
+	334000UL,
+	400000UL,
+	600000UL,
+	840000UL,
+	1120000UL,
+	1440000UL,
+	1800000UL,
+	2600000UL,
+	3200000UL,
+	4000000UL,
+	16800000UL
+};
+// END_OF_INTERNATIONAL_VERSION 치
+
+const int aiMobEnchantApplyIdx[MOB_ENCHANTS_MAX_NUM] =
+{
+	APPLY_CURSE_PCT,
+	APPLY_SLOW_PCT,
+	APPLY_POISON_PCT,
+	APPLY_STUN_PCT,
+	APPLY_CRITICAL_PCT,
+	APPLY_PENETRATE_PCT,
+};
+
+const int aiMobResistsApplyIdx[MOB_RESISTS_MAX_NUM] =
+{
+	APPLY_RESIST_FIST,
+
+	APPLY_RESIST_SWORD,
+	APPLY_RESIST_TWOHAND,
+	APPLY_RESIST_DAGGER,
+	APPLY_RESIST_BELL,
+	APPLY_RESIST_FAN,
+	APPLY_RESIST_BOW,
+	APPLY_RESIST_CLAW,
+
+	APPLY_RESIST_FIRE,
+	APPLY_RESIST_ELEC,
+	APPLY_RESIST_MAGIC,
+	APPLY_RESIST_WIND,
+
+	APPLY_POISON_REDUCE,
+	APPLY_BLEEDING_REDUCE,
+};
+
+#if defined(__ELEMENT_SYSTEM__)
+const int aiMobElementsApplyIdx[MOB_ELEMENT_MAX_NUM] =
+{
+	APPLY_ENCHANT_ELECT,
+	APPLY_ENCHANT_FIRE,
+	APPLY_ENCHANT_ICE,
+	APPLY_ENCHANT_WIND,
+	APPLY_ENCHANT_EARTH,
+	APPLY_ENCHANT_DARK
+};
+#endif
+
+const int aiSocketPercentByQty[5][4] =
+{
+	{ 0, 0, 0, 0 },
+	{ 3, 0, 0, 0 },
+	{ 10, 1, 0, 0 },
+	{ 15, 10, 1, 0 },
+	{ 20, 15, 10, 1 }
+};
+
+const int aiWeaponSocketQty[WEAPON_NUM_TYPES] =
+{
+	3, // WEAPON_SWORD,
+	3, // WEAPON_DAGGER,
+	3, // WEAPON_BOW,
+	3, // WEAPON_TWO_HANDED,
+	3, // WEAPON_BELL,
+	3, // WEAPON_FAN,
+	0, // WEAPON_ARROW,
+	0, // WEAPON_MOUNT_SPEAR
+#if defined(__WOLFMAN_CHARACTER__)
+	3, // WEAPON_CLAW
+#endif
+#if defined(__QUIVER_SYSTEM__)
+	0, // WEAPON_QUIVER,
+#endif
+};
+
+const int aiArmorSocketQty[ARMOR_NUM_TYPES] =
+{
+	3, // ARMOR_BODY,
+	1, // ARMOR_HEAD,
+	1, // ARMOR_SHIELD,
+	0, // ARMOR_WRIST,
+	0, // ARMOR_FOOTS,
+	0 // ARMOR_ACCESSORY
+};
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+const int s_aiAuraRefineTable[AURA_GRADE_MAX_NUM][AURA_REFINE_INFO_MAX] = {
+	// Grade					MinLevel	MaxLevel		Exp		MaterialVnum	MaterialCount	Cost		Pct
+	{ AURA_GRADE_ORDINARY,		1,			49,				1000,	30617,			10,				5000000,	100 },
+	{ AURA_GRADE_SIMPLE,		50,			99,				2000,	31136,			10,				5000000,	100 },
+	{ AURA_GRADE_NOBLE,			100,		149,			4000,	31137,			10,				5000000,	100 },
+	{ AURA_GRADE_SPARKLING,		150,		199,			8000,	31138,			10,				8000000,	100 },
+	{ AURA_GRADE_MAGNIFICENT,	200,		249,			16000,	31138,			20,				10000000,	100 },
+	{ AURA_GRADE_RADIANT,		250,		250,			0,		0,				0,				0,			0 },
+	{ AURA_GRADE_NONE,			0,			0,				0,		0,				0,				0,			0 }
+};
+
+const int* GetAuraRefineInfo(BYTE bLevel)
+{
+	if (bLevel > AURA_MAX_LEVEL)
+		return NULL;
+
+	for (int i = 0; i < AURA_GRADE_MAX_NUM; ++i)
+	{
+		if (bLevel >= s_aiAuraRefineTable[i][AURA_REFINE_INFO_LEVEL_MIN] && bLevel <= s_aiAuraRefineTable[i][AURA_REFINE_INFO_LEVEL_MAX])
+			return s_aiAuraRefineTable[i];
+	}
+
+	return NULL;
+}
+
+const int GetAuraRefineInfo(BYTE bGrade, BYTE bInfo)
+{
+	if (bGrade >= AURA_GRADE_MAX_NUM || bInfo >= AURA_REFINE_INFO_MAX)
+		return 0;
+
+	return s_aiAuraRefineTable[bGrade - 1][bInfo];
+}
+#endif
+
+TItemAttrMap g_map_itemAttr;
+TItemAttrMap g_map_itemRare;
+
+const TApplyInfo aApplyInfo[MAX_APPLY_NUM] =
+/*
+{
+	POINT_TYPE wApplyType;
+	POINT_TYPE wPointType;
+}
+*/
+{
+	{ APPLY_NONE, POINT_NONE, },
+	{ APPLY_MAX_HP, POINT_MAX_HP, },
+	{ APPLY_MAX_SP, POINT_MAX_SP, },
+	{ APPLY_CON, POINT_HT, },
+	{ APPLY_INT, POINT_IQ, },
+	{ APPLY_STR, POINT_ST, },
+	{ APPLY_DEX, POINT_DX, },
+	{ APPLY_ATT_SPEED, POINT_ATT_SPEED, },
+	{ APPLY_MOV_SPEED, POINT_MOV_SPEED, },
+	{ APPLY_CAST_SPEED, POINT_CASTING_SPEED, },
+	{ APPLY_HP_REGEN, POINT_HP_REGEN, },
+	{ APPLY_SP_REGEN, POINT_SP_REGEN, },
+	{ APPLY_POISON_PCT, POINT_POISON_PCT, },
+	{ APPLY_STUN_PCT, POINT_STUN_PCT, },
+	{ APPLY_SLOW_PCT, POINT_SLOW_PCT, },
+	{ APPLY_CRITICAL_PCT, POINT_CRITICAL_PCT, },
+	{ APPLY_PENETRATE_PCT, POINT_PENETRATE_PCT, },
+	{ APPLY_ATTBONUS_HUMAN, POINT_ATTBONUS_HUMAN, },
+	{ APPLY_ATTBONUS_ANIMAL, POINT_ATTBONUS_ANIMAL, },
+	{ APPLY_ATTBONUS_ORC, POINT_ATTBONUS_ORC, },
+	{ APPLY_ATTBONUS_MILGYO, POINT_ATTBONUS_MILGYO, },
+	{ APPLY_ATTBONUS_UNDEAD, POINT_ATTBONUS_UNDEAD, },
+	{ APPLY_ATTBONUS_DEVIL, POINT_ATTBONUS_DEVIL, },
+	{ APPLY_STEAL_HP, POINT_STEAL_HP, },
+	{ APPLY_STEAL_SP, POINT_STEAL_SP, },
+	{ APPLY_MANA_BURN_PCT, POINT_MANA_BURN_PCT, },
+	{ APPLY_DAMAGE_SP_RECOVER, POINT_DAMAGE_SP_RECOVER, },
+	{ APPLY_BLOCK, POINT_BLOCK, },
+	{ APPLY_DODGE, POINT_DODGE, },
+	{ APPLY_RESIST_SWORD, POINT_RESIST_SWORD, },
+	{ APPLY_RESIST_TWOHAND, POINT_RESIST_TWOHAND, },
+	{ APPLY_RESIST_DAGGER, POINT_RESIST_DAGGER, },
+	{ APPLY_RESIST_BELL, POINT_RESIST_BELL, },
+	{ APPLY_RESIST_FAN, POINT_RESIST_FAN, },
+	{ APPLY_RESIST_BOW, POINT_RESIST_BOW, },
+	{ APPLY_RESIST_FIRE, POINT_RESIST_FIRE, },
+	{ APPLY_RESIST_ELEC, POINT_RESIST_ELEC, },
+	{ APPLY_RESIST_MAGIC, POINT_RESIST_MAGIC, },
+	{ APPLY_RESIST_WIND, POINT_RESIST_WIND, },
+	{ APPLY_REFLECT_MELEE, POINT_REFLECT_MELEE, },
+	{ APPLY_REFLECT_CURSE, POINT_REFLECT_CURSE, },
+	{ APPLY_POISON_REDUCE, POINT_POISON_REDUCE, },
+	{ APPLY_KILL_SP_RECOVER, POINT_KILL_SP_RECOVER, },
+	{ APPLY_EXP_DOUBLE_BONUS, POINT_EXP_DOUBLE_BONUS, },
+	{ APPLY_GOLD_DOUBLE_BONUS, POINT_GOLD_DOUBLE_BONUS, },
+	{ APPLY_ITEM_DROP_BONUS, POINT_ITEM_DROP_BONUS, },
+	{ APPLY_POTION_BONUS, POINT_POTION_BONUS, },
+	{ APPLY_KILL_HP_RECOVER, POINT_KILL_HP_RECOVERY, },
+	{ APPLY_IMMUNE_STUN, POINT_IMMUNE_STUN, },
+	{ APPLY_IMMUNE_SLOW, POINT_IMMUNE_SLOW, },
+	{ APPLY_IMMUNE_FALL, POINT_IMMUNE_FALL, },
+	{ APPLY_SKILL, POINT_NONE, },
+	{ APPLY_BOW_DISTANCE, POINT_BOW_DISTANCE, },
+	{ APPLY_ATT_GRADE_BONUS, POINT_ATT_GRADE_BONUS, },
+	{ APPLY_DEF_GRADE_BONUS, POINT_DEF_GRADE_BONUS, },
+	{ APPLY_MAGIC_ATT_GRADE, POINT_MAGIC_ATT_GRADE_BONUS, },
+	{ APPLY_MAGIC_DEF_GRADE, POINT_MAGIC_DEF_GRADE_BONUS, },
+	{ APPLY_CURSE_PCT, POINT_CURSE_PCT, },
+	{ APPLY_MAX_STAMINA, POINT_MAX_STAMINA, },
+	{ APPLY_ATTBONUS_WARRIOR, POINT_ATTBONUS_WARRIOR, },
+	{ APPLY_ATTBONUS_ASSASSIN, POINT_ATTBONUS_ASSASSIN, },
+	{ APPLY_ATTBONUS_SURA, POINT_ATTBONUS_SURA, },
+	{ APPLY_ATTBONUS_SHAMAN, POINT_ATTBONUS_SHAMAN, },
+	{ APPLY_ATTBONUS_MONSTER, POINT_ATTBONUS_MONSTER, },
+	{ APPLY_MALL_ATTBONUS, POINT_ATT_BONUS, },
+	{ APPLY_MALL_DEFBONUS, POINT_MALL_DEFBONUS, },
+	{ APPLY_MALL_EXPBONUS, POINT_MALL_EXPBONUS, },
+	{ APPLY_MALL_ITEMBONUS, POINT_MALL_ITEMBONUS, },
+	{ APPLY_MALL_GOLDBONUS, POINT_MALL_GOLDBONUS, },
+	{ APPLY_MAX_HP_PCT, POINT_MAX_HP_PCT, },
+	{ APPLY_MAX_SP_PCT, POINT_MAX_SP_PCT, },
+	{ APPLY_SKILL_DAMAGE_BONUS, POINT_SKILL_DAMAGE_BONUS, },
+	{ APPLY_NORMAL_HIT_DAMAGE_BONUS, POINT_NORMAL_HIT_DAMAGE_BONUS, },
+
+	{ APPLY_SKILL_DEFEND_BONUS, POINT_SKILL_DEFEND_BONUS, },
+	{ APPLY_NORMAL_HIT_DEFEND_BONUS, POINT_NORMAL_HIT_DEFEND_BONUS, },
+
+	{ APPLY_PC_BANG_EXP_BONUS, POINT_PC_BANG_EXP_BONUS, },
+	{ APPLY_PC_BANG_DROP_BONUS, POINT_PC_BANG_DROP_BONUS, },
+
+	{ APPLY_EXTRACT_HP_PCT, POINT_NONE, },
+
+	{ APPLY_RESIST_WARRIOR, POINT_RESIST_WARRIOR, },
+	{ APPLY_RESIST_ASSASSIN, POINT_RESIST_ASSASSIN, },
+	{ APPLY_RESIST_SURA, POINT_RESIST_SURA, },
+	{ APPLY_RESIST_SHAMAN, POINT_RESIST_SHAMAN, },
+	{ APPLY_ENERGY, POINT_ENERGY, },
+	{ APPLY_DEF_GRADE, POINT_DEF_GRADE, },
+	{ APPLY_COSTUME_ATTR_BONUS, POINT_COSTUME_ATTR_BONUS, },
+	{ APPLY_MAGIC_ATTBONUS_PER, POINT_MAGIC_ATT_BONUS_PER, },
+	{ APPLY_MELEE_MAGIC_ATTBONUS_PER, POINT_MELEE_MAGIC_ATT_BONUS_PER, },
+
+	{ APPLY_RESIST_ICE, POINT_RESIST_ICE, },
+	{ APPLY_RESIST_EARTH, POINT_RESIST_EARTH, },
+	{ APPLY_RESIST_DARK, POINT_RESIST_DARK, },
+
+	{ APPLY_ANTI_CRITICAL_PCT, POINT_RESIST_CRITICAL, },
+	{ APPLY_ANTI_PENETRATE_PCT, POINT_RESIST_PENETRATE, },
+
+	{ APPLY_BLEEDING_REDUCE, POINT_BLEEDING_REDUCE, },
+	{ APPLY_BLEEDING_PCT, POINT_BLEEDING_PCT, },
+	{ APPLY_ATTBONUS_WOLFMAN, POINT_ATTBONUS_WOLFMAN, },
+	{ APPLY_RESIST_WOLFMAN, POINT_RESIST_WOLFMAN, },
+	{ APPLY_RESIST_CLAW, POINT_RESIST_CLAW, },
+
+	{ APPLY_ACCEDRAIN_RATE, POINT_NONE, },
+#if defined(__MAGIC_REDUCTION__)
+	{ APPLY_RESIST_MAGIC_REDUCTION, POINT_RESIST_MAGIC_REDUCTION, },
+#endif
+
+	{ APPLY_ENCHANT_ELECT, POINT_ENCHANT_ELECT, },
+	{ APPLY_ENCHANT_FIRE, POINT_ENCHANT_FIRE, },
+	{ APPLY_ENCHANT_ICE, POINT_ENCHANT_ICE, },
+	{ APPLY_ENCHANT_WIND, POINT_ENCHANT_WIND, },
+	{ APPLY_ENCHANT_EARTH, POINT_ENCHANT_EARTH, },
+	{ APPLY_ENCHANT_DARK, POINT_ENCHANT_DARK, },
+
+	{ APPLY_ATTBONUS_CZ, POINT_ATTBONUS_CZ, },
+	{ APPLY_ATTBONUS_INSECT, POINT_ATTBONUS_INSECT, },
+	{ APPLY_ATTBONUS_DESERT, POINT_ATTBONUS_DESERT, },
+	{ APPLY_ATTBONUS_SWORD, POINT_ATTBONUS_SWORD, },
+	{ APPLY_ATTBONUS_TWOHAND, POINT_ATTBONUS_TWOHAND, },
+	{ APPLY_ATTBONUS_DAGGER, POINT_ATTBONUS_DAGGER, },
+	{ APPLY_ATTBONUS_BELL, POINT_ATTBONUS_BELL, },
+	{ APPLY_ATTBONUS_FAN, POINT_ATTBONUS_FAN, },
+	{ APPLY_ATTBONUS_BOW, POINT_ATTBONUS_BOW, },
+	{ APPLY_ATTBONUS_CLAW, POINT_ATTBONUS_CLAW, },
+
+	{ APPLY_RESIST_HUMAN, POINT_RESIST_HUMAN, },
+	{ APPLY_RESIST_MOUNT_FALL, POINT_RESIST_MOUNT_FALL, },
+	{ APPLY_RESIST_FIST, POINT_RESIST_FIST, },
+
+	{ APPLY_MOUNT, POINT_MOUNT, },
+
+	{ APPLY_SKILL_DAMAGE_SAMYEON, POINT_SKILL_DAMAGE_SAMYEON, },
+	{ APPLY_SKILL_DAMAGE_TANHWAN, POINT_SKILL_DAMAGE_TANHWAN, },
+	{ APPLY_SKILL_DAMAGE_PALBANG, POINT_SKILL_DAMAGE_PALBANG, },
+	{ APPLY_SKILL_DAMAGE_GIGONGCHAM, POINT_SKILL_DAMAGE_GIGONGCHAM, },
+	{ APPLY_SKILL_DAMAGE_GYOKSAN, POINT_SKILL_DAMAGE_GYOKSAN, },
+	{ APPLY_SKILL_DAMAGE_GEOMPUNG, POINT_SKILL_DAMAGE_GEOMPUNG, },
+	{ APPLY_SKILL_DAMAGE_AMSEOP, POINT_SKILL_DAMAGE_AMSEOP, },
+	{ APPLY_SKILL_DAMAGE_GUNGSIN, POINT_SKILL_DAMAGE_GUNGSIN, },
+	{ APPLY_SKILL_DAMAGE_CHARYUN, POINT_SKILL_DAMAGE_CHARYUN, },
+	{ APPLY_SKILL_DAMAGE_SANGONG, POINT_SKILL_DAMAGE_SANGONG, },
+	{ APPLY_SKILL_DAMAGE_YEONSA, POINT_SKILL_DAMAGE_YEONSA, },
+	{ APPLY_SKILL_DAMAGE_KWANKYEOK, POINT_SKILL_DAMAGE_KWANKYEOK, },
+	{ APPLY_SKILL_DAMAGE_GIGUNG, POINT_SKILL_DAMAGE_GIGUNG, },
+	{ APPLY_SKILL_DAMAGE_HWAJO, POINT_SKILL_DAMAGE_HWAJO, },
+	{ APPLY_SKILL_DAMAGE_SWAERYUNG, POINT_SKILL_DAMAGE_SWAERYUNG, },
+	{ APPLY_SKILL_DAMAGE_YONGKWON, POINT_SKILL_DAMAGE_YONGKWON, },
+	{ APPLY_SKILL_DAMAGE_PABEOB, POINT_SKILL_DAMAGE_PABEOB, },
+	{ APPLY_SKILL_DAMAGE_MARYUNG, POINT_SKILL_DAMAGE_MARYUNG, },
+	{ APPLY_SKILL_DAMAGE_HWAYEOMPOK, POINT_SKILL_DAMAGE_HWAYEOMPOK, },
+	{ APPLY_SKILL_DAMAGE_MAHWAN, POINT_SKILL_DAMAGE_MAHWAN, },
+	{ APPLY_SKILL_DAMAGE_BIPABU, POINT_SKILL_DAMAGE_BIPABU, },
+	{ APPLY_SKILL_DAMAGE_YONGBI, POINT_SKILL_DAMAGE_YONGBI, },
+	{ APPLY_SKILL_DAMAGE_PAERYONG, POINT_SKILL_DAMAGE_PAERYONG, },
+	{ APPLY_SKILL_DAMAGE_NOEJEON, POINT_SKILL_DAMAGE_NOEJEON, },
+	{ APPLY_SKILL_DAMAGE_BYEURAK, POINT_SKILL_DAMAGE_BYEURAK, },
+	{ APPLY_SKILL_DAMAGE_CHAIN, POINT_SKILL_DAMAGE_CHAIN, },
+	{ APPLY_SKILL_DAMAGE_CHAYEOL, POINT_SKILL_DAMAGE_CHAYEOL, },
+	{ APPLY_SKILL_DAMAGE_SALPOONG, POINT_SKILL_DAMAGE_SALPOONG, },
+	{ APPLY_SKILL_DAMAGE_GONGDAB, POINT_SKILL_DAMAGE_GONGDAB, },
+	{ APPLY_SKILL_DAMAGE_PASWAE, POINT_SKILL_DAMAGE_PASWAE, },
+
+	{ APPLY_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE, POINT_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE, },
+	{ APPLY_SKILL_DEFEND_BONUS_BOSS_OR_MORE, POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE, },
+	{ APPLY_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE, POINT_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE, },
+	{ APPLY_SKILL_DAMAGE_BONUS_BOSS_OR_MORE, POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE, },
+
+	{ APPLY_HIT_BUFF_ENCHANT_FIRE, POINT_HIT_BUFF_ENCHANT_FIRE, },
+	{ APPLY_HIT_BUFF_ENCHANT_ICE, POINT_HIT_BUFF_ENCHANT_ICE, },
+	{ APPLY_HIT_BUFF_ENCHANT_ELEC, POINT_HIT_BUFF_ENCHANT_ELEC, },
+	{ APPLY_HIT_BUFF_ENCHANT_WIND, POINT_HIT_BUFF_ENCHANT_WIND, },
+	{ APPLY_HIT_BUFF_ENCHANT_DARK, POINT_HIT_BUFF_ENCHANT_DARK, },
+	{ APPLY_HIT_BUFF_ENCHANT_EARTH, POINT_HIT_BUFF_ENCHANT_EARTH, },
+	{ APPLY_HIT_BUFF_RESIST_FIRE, POINT_HIT_BUFF_RESIST_FIRE, },
+	{ APPLY_HIT_BUFF_RESIST_ICE, POINT_HIT_BUFF_RESIST_ICE, },
+	{ APPLY_HIT_BUFF_RESIST_ELEC, POINT_HIT_BUFF_RESIST_ELEC, },
+	{ APPLY_HIT_BUFF_RESIST_WIND, POINT_HIT_BUFF_RESIST_WIND, },
+	{ APPLY_HIT_BUFF_RESIST_DARK, POINT_HIT_BUFF_RESIST_DARK, },
+	{ APPLY_HIT_BUFF_RESIST_EARTH, POINT_HIT_BUFF_RESIST_EARTH, },
+
+	{ APPLY_USE_SKILL_CHEONGRANG_MOV_SPEED, POINT_USE_SKILL_CHEONGRANG_MOV_SPEED, },
+	{ APPLY_USE_SKILL_CHEONGRANG_CASTING_SPEED, POINT_USE_SKILL_CHEONGRANG_CASTING_SPEED, },
+	{ APPLY_USE_SKILL_CHAYEOL_CRITICAL_PCT, POINT_USE_SKILL_CHAYEOL_CRITICAL_PCT, },
+	{ APPLY_USE_SKILL_SANGONG_ATT_GRADE_BONUS, POINT_USE_SKILL_SANGONG_ATT_GRADE_BONUS, },
+	{ APPLY_USE_SKILL_GIGUNG_ATT_GRADE_BONUS, POINT_USE_SKILL_GIGUNG_ATT_GRADE_BONUS, },
+	{ APPLY_USE_SKILL_JEOKRANG_DEF_BONUS, POINT_USE_SKILL_JEOKRANG_DEF_BONUS, },
+	{ APPLY_USE_SKILL_GWIGEOM_DEF_BONUS, POINT_USE_SKILL_GWIGEOM_DEF_BONUS, },
+	{ APPLY_USE_SKILL_TERROR_ATT_GRADE_BONUS, POINT_USE_SKILL_TERROR_ATT_GRADE_BONUS, },
+	{ APPLY_USE_SKILL_MUYEONG_ATT_GRADE_BONUS, POINT_USE_SKILL_MUYEONG_ATT_GRADE_BONUS, },
+	{ APPLY_USE_SKILL_MANASHILED_CASTING_SPEED, POINT_USE_SKILL_MANASHILED_CASTING_SPEED, },
+	{ APPLY_USE_SKILL_HOSIN_DEF_BONUS, POINT_USE_SKILL_HOSIN_DEF_BONUS, },
+	{ APPLY_USE_SKILL_GICHEON_ATT_GRADE_BONUS, POINT_USE_SKILL_GICHEON_ATT_GRADE_BONUS, },
+	{ APPLY_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS, POINT_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS, },
+	{ APPLY_USE_SKILL_JEUNGRYEOK_DEF_BONUS, POINT_USE_SKILL_JEUNGRYEOK_DEF_BONUS, },
+	{ APPLY_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS, POINT_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS, },
+	{ APPLY_USE_SKILL_CHUNKEON_CASTING_SPEED, POINT_USE_SKILL_CHUNKEON_CASTING_SPEED, },
+	{ APPLY_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS, POINT_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS, },
+
+	{ APPLY_SKILL_DURATION_INCREASE_EUNHYUNG, POINT_SKILL_DURATION_INCREASE_EUNHYUNG, },
+	{ APPLY_SKILL_DURATION_INCREASE_GYEONGGONG, POINT_SKILL_DURATION_INCREASE_GYEONGGONG, },
+	{ APPLY_SKILL_DURATION_INCREASE_GEOMKYUNG, POINT_SKILL_DURATION_INCREASE_GEOMKYUNG, },
+	{ APPLY_SKILL_DURATION_INCREASE_JEOKRANG, POINT_SKILL_DURATION_INCREASE_JEOKRANG, },
+
+	{ APPLY_USE_SKILL_PALBANG_HP_ABSORB, POINT_USE_SKILL_PALBANG_HP_ABSORB, },
+	{ APPLY_USE_SKILL_AMSEOP_HP_ABSORB, POINT_USE_SKILL_AMSEOP_HP_ABSORB, },
+	{ APPLY_USE_SKILL_YEONSA_HP_ABSORB, POINT_USE_SKILL_YEONSA_HP_ABSORB, },
+	{ APPLY_USE_SKILL_YONGBI_HP_ABSORB, POINT_USE_SKILL_YONGBI_HP_ABSORB, },
+	{ APPLY_USE_SKILL_CHAIN_HP_ABSORB, POINT_USE_SKILL_CHAIN_HP_ABSORB, },
+	{ APPLY_USE_SKILL_PASWAE_SP_ABSORB, POINT_USE_SKILL_PASWAE_SP_ABSORB, },
+	{ APPLY_USE_SKILL_GIGONGCHAM_STUN, POINT_USE_SKILL_GIGONGCHAM_STUN, },
+	{ APPLY_USE_SKILL_CHARYUN_STUN, POINT_USE_SKILL_CHARYUN_STUN, },
+	{ APPLY_USE_SKILL_PABEOB_STUN, POINT_USE_SKILL_PABEOB_STUN, },
+	{ APPLY_USE_SKILL_MAHWAN_STUN, POINT_USE_SKILL_MAHWAN_STUN, },
+	{ APPLY_USE_SKILL_GONGDAB_STUN, POINT_USE_SKILL_GONGDAB_STUN, },
+	{ APPLY_USE_SKILL_SAMYEON_STUN, POINT_USE_SKILL_SAMYEON_STUN, },
+	{ APPLY_USE_SKILL_GYOKSAN_KNOCKBACK, POINT_USE_SKILL_GYOKSAN_KNOCKBACK, },
+	{ APPLY_USE_SKILL_SEOMJEON_KNOCKBACK, POINT_USE_SKILL_SEOMJEON_KNOCKBACK, },
+	{ APPLY_USE_SKILL_SWAERYUNG_KNOCKBACK, POINT_USE_SKILL_SWAERYUNG_KNOCKBACK, },
+	{ APPLY_USE_SKILL_HWAYEOMPOK_KNOCKBACK, POINT_USE_SKILL_HWAYEOMPOK_KNOCKBACK, },
+	{ APPLY_USE_SKILL_GONGDAB_KNOCKBACK, POINT_USE_SKILL_GONGDAB_KNOCKBACK, },
+	{ APPLY_USE_SKILL_KWANKYEOK_KNOCKBACK, POINT_USE_SKILL_KWANKYEOK_KNOCKBACK, },
+	{ APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER, },
+	{ APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER, },
+	{ APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER, },
+	{ APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER, },
+	{ APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER, },
+	{ APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER, },
+	{ APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER, },
+	{ APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER, },
+	{ APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER, },
+	{ APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER, POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER, },
+
+	{ APPLY_ATTBONUS_STONE, POINT_ATTBONUS_STONE, },
+
+	{ APPLY_DAMAGE_HP_RECOVERY, POINT_DAMAGE_HP_RECOVERY, },
+	{ APPLY_DAMAGE_SP_RECOVERY, POINT_DAMAGE_SP_RECOVERY, },
+
+	{ APPLY_ALIGNMENT_DAMAGE_BONUS, POINT_ALIGNMENT_DAMAGE_BONUS, },
+
+	{ APPLY_NORMAL_DAMAGE_GUARD, POINT_NORMAL_DAMAGE_GUARD },
+	{ APPLY_MORE_THEN_HP90_DAMAGE_REDUCE, POINT_MORE_THEN_HP90_DAMAGE_REDUCE, },
+
+	{ APPLY_USE_SKILL_TUSOK_HP_ABSORB, POINT_USE_SKILL_TUSOK_HP_ABSORB, },
+	{ APPLY_USE_SKILL_PAERYONG_HP_ABSORB, POINT_USE_SKILL_PAERYONG_HP_ABSORB, },
+	{ APPLY_USE_SKILL_BYEURAK_HP_ABSORB, POINT_USE_SKILL_BYEURAK_HP_ABSORB, },
+
+	{ APPLY_FIRST_ATTRIBUTE_BONUS, POINT_NONE, },
+	{ APPLY_SECOND_ATTRIBUTE_BONUS, POINT_NONE, },
+	{ APPLY_THIRD_ATTRIBUTE_BONUS, POINT_NONE, },
+	{ APPLY_FOURTH_ATTRIBUTE_BONUS, POINT_NONE, },
+	{ APPLY_FIFTH_ATTRIBUTE_BONUS, POINT_NONE, },
+
+	{ APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER, },
+	{ APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER, },
+	{ APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER, },
+	{ APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER, },
+	{ APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER, },
+	{ APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER, },
+	{ APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER, },
+	{ APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER, },
+	{ APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER, },
+	{ APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER, POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER, },
+	{ APPLY_USE_SKILL_CHAYEOL_HP_ABSORB, POINT_USE_SKILL_CHAYEOL_HP_ABSORB, },
+
+	{ APPLY_SUNGMA_STR, POINT_SUNGMA_STR, },
+	{ APPLY_SUNGMA_HP, POINT_SUNGMA_HP, },
+	{ APPLY_SUNGMA_MOVE, POINT_SUNGMA_MOVE, },
+	{ APPLY_SUNGMA_IMMUNE, POINT_SUNGMA_IMMUNE, },
+
+	{ APPLY_HIT_PCT, POINT_HIT_PCT, },
+	{ APPLY_RANDOM, POINT_NONE, },
+
+	{ APPLY_ATTBONUS_PER_HUMAN, POINT_ATTBONUS_PER_HUMAN, },
+	{ APPLY_ATTBONUS_PER_ANIMAL, POINT_ATTBONUS_PER_ANIMAL, },
+	{ APPLY_ATTBONUS_PER_ORC, POINT_ATTBONUS_PER_ORC, },
+	{ APPLY_ATTBONUS_PER_MILGYO, POINT_ATTBONUS_PER_MILGYO, },
+	{ APPLY_ATTBONUS_PER_UNDEAD, POINT_ATTBONUS_PER_UNDEAD, },
+	{ APPLY_ATTBONUS_PER_DEVIL, POINT_ATTBONUS_PER_DEVIL, },
+
+	{ APPLY_ENCHANT_PER_ELECT, POINT_ENCHANT_PER_ELECT, },
+	{ APPLY_ENCHANT_PER_FIRE, POINT_ENCHANT_PER_FIRE, },
+	{ APPLY_ENCHANT_PER_ICE, POINT_ENCHANT_PER_ICE, },
+	{ APPLY_ENCHANT_PER_WIND, POINT_ENCHANT_PER_WIND, },
+	{ APPLY_ENCHANT_PER_EARTH, POINT_ENCHANT_PER_EARTH, },
+	{ APPLY_ENCHANT_PER_DARK, POINT_ENCHANT_PER_DARK, },
+
+	{ APPLY_ATTBONUS_PER_CZ, POINT_ATTBONUS_PER_CZ, },
+	{ APPLY_ATTBONUS_PER_INSECT, POINT_ATTBONUS_PER_INSECT, },
+	{ APPLY_ATTBONUS_PER_DESERT, POINT_ATTBONUS_PER_DESERT, },
+	{ APPLY_ATTBONUS_PER_STONE, POINT_ATTBONUS_PER_STONE, },
+	{ APPLY_ATTBONUS_PER_MONSTER, POINT_ATTBONUS_PER_MONSTER, },
+
+	{ APPLY_RESIST_PER_HUMAN, POINT_RESIST_PER_HUMAN, },
+	{ APPLY_RESIST_PER_ICE, POINT_RESIST_PER_ICE, },
+	{ APPLY_RESIST_PER_DARK, POINT_RESIST_PER_DARK, },
+	{ APPLY_RESIST_PER_EARTH, POINT_RESIST_PER_EARTH, },
+	{ APPLY_RESIST_PER_FIRE, POINT_RESIST_PER_FIRE, },
+	{ APPLY_RESIST_PER_ELEC, POINT_RESIST_PER_ELEC, },
+	{ APPLY_RESIST_PER_MAGIC, POINT_RESIST_PER_MAGIC, },
+	{ APPLY_RESIST_PER_WIND, POINT_RESIST_PER_WIND, },
+
+	{ APPLY_HIT_BUFF_SUNGMA_STR, POINT_HIT_BUFF_SUNGMA_STR, },
+	{ APPLY_HIT_BUFF_SUNGMA_MOVE, POINT_HIT_BUFF_SUNGMA_MOVE, },
+	{ APPLY_HIT_BUFF_SUNGMA_HP, POINT_HIT_BUFF_SUNGMA_HP, },
+	{ APPLY_HIT_BUFF_SUNGMA_IMMUNE, POINT_HIT_BUFF_SUNGMA_IMMUNE, },
+
+	{ APPLY_MOUNT_MELEE_MAGIC_ATTBONUS_PER, POINT_MOUNT_MELEE_MAGIC_ATTBONUS_PER, },
+	{ APPLY_DISMOUNT_MOVE_SPEED_BONUS_PER, POINT_DISMOUNT_MOVE_SPEED_BONUS_PER, },
+
+	{ APPLY_HIT_AUTO_HP_RECOVERY, POINT_HIT_AUTO_HP_RECOVERY, },
+	{ APPLY_HIT_AUTO_SP_RECOVERY, POINT_HIT_AUTO_SP_RECOVERY, },
+
+	{ APPLY_USE_SKILL_COOLTIME_DECREASE_ALL, POINT_USE_SKILL_COOLTIME_DECREASE_ALL, },
+
+	{ APPLY_HIT_STONE_ATTBONUS_STONE, POINT_HIT_STONE_ATTBONUS_STONE, },
+	{ APPLY_HIT_STONE_DEF_GRADE_BONUS, POINT_HIT_STONE_DEF_GRADE_BONUS, },
+
+	{ APPLY_KILL_BOSS_ITEM_BONUS, POINT_KILL_BOSS_ITEM_BONUS, },
+	{ APPLY_MOB_HIT_MOB_AGGRESSIVE, POINT_MOB_HIT_MOB_AGGRESSIVE, },
+	{ APPLY_NO_DEATH_AND_HP_RECOVERY30, POINT_NO_DEATH_AND_HP_RECOVERY30, },
+
+	{ APPLY_AUTO_PICKUP, POINT_AUTO_PICKUP, },
+	{ APPLY_MOUNT_NO_KNOCKBACK, POINT_MOUNT_NO_KNOCKBACK, },
+
+	{ APPLY_SUNGMA_PER_STR, POINT_SUNGMA_PER_STR, },
+	{ APPLY_SUNGMA_PER_HP, POINT_SUNGMA_PER_HP, },
+	{ APPLY_SUNGMA_PER_MOVE, POINT_SUNGMA_PER_MOVE, },
+	{ APPLY_SUNGMA_PER_IMMUNE, POINT_SUNGMA_PER_IMMUNE, },
+
+	{ APPLY_IMMUNE_POISON100, POINT_IMMUNE_POISON100, },
+	{ APPLY_IMMUNE_BLEEDING100, POINT_IMMUNE_BLEEDING100, },
+
+	{ APPLY_MONSTER_DEFEND_BONUS, POINT_MONSTER_DEFEND_BONUS, },
+};
+
+const int aiItemMagicAttributePercentHigh[ITEM_ATTRIBUTE_MAX_LEVEL] =
+{
+	//25, 25, 40, 8, 2,
+	30, 40, 20, 8, 2
+};
+
+const int aiItemMagicAttributePercentLow[ITEM_ATTRIBUTE_MAX_LEVEL] =
+{
+	//45, 25, 20, 10, 0,
+	50, 40, 10, 0, 0
+};
+
+// ADD_ITEM_ATTRIBUTE
+const int aiItemAttributeAddPercent[ITEM_ATTRIBUTE_MAX_NUM] =
+{
+	100, 80, 60, 50, 30, 0, 0,
+};
+// END_OF_ADD_ITEM_ATTRIBUTE
+
+const int aiExpLossPercents[PLAYER_EXP_TABLE_MAX + 1] =
+{
+	0,
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 4, // 1 - 10
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, // 11 - 20
+	4, 4, 4, 4, 4, 4, 4, 3, 3, 3, // 21 - 30
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, // 31 - 40
+	3, 3, 3, 3, 2, 2, 2, 2, 2, 2, // 41 - 50
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 51 - 60
+	2, 2, 1, 1, 1, 1, 1, 1, 1, 1, // 61 - 70
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 71 - 80
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 81 - 90
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 91 - 100
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 101 - 110
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 111 - 120
+};
+
+const int aiSkillBookCountForLevelUp[10] =
+{
+	3, 3, 3, 3, 3, 4, 4, 5, 5, 6
+};
+
+// ADD_GRANDMASTER_SKILL
+const int aiGrandMasterSkillBookCountForLevelUp[10] =
+{
+	3, 3, 5, 5, 7, 7, 10, 10, 10, 20,
+};
+
+const int aiGrandMasterSkillBookMinCount[10] =
+{
+	// 1, 1, 3, 5, 10, 15, 20, 30, 40, 50,
+	// 3, 3, 5, 5, 10, 10, 15, 15, 20, 30
+	1, 1, 1, 2, 2, 3, 3, 4, 5, 6
+};
+
+const int aiGrandMasterSkillBookMaxCount[10] =
+{
+	// 6, 15, 30, 45, 60, 80, 100, 120, 160, 200,
+	// 6, 10, 15, 20, 30, 40, 50, 60, 70, 80
+	5, 7, 9, 11, 13, 15, 20, 25, 30, 35
+};
+// END_OF_ADD_GRANDMASTER_SKILL
+
+const int CHN_aiPartyBonusExpPercentByMemberCount[9] =
+{
+	0, 0, 12, 18, 26, 40, 53, 70, 100
+};
+
+// UPGRADE_PARTY_BONUS
+const int KOR_aiPartyBonusExpPercentByMemberCount[9] =
+{
+	0,
+	0,
+	30, // 66% * 2 - 100
+	60, // 53% * 3 - 100
+	75, // 44% * 4 - 100
+	90, // 38% * 5 - 100
+	105, // 34% * 6 - 100
+	110, // 30% * 7 - 100
+	140, // 30% * 8 - 100
+};
+
+const int KOR_aiUniqueItemPartyBonusExpPercentByMemberCount[9] =
+{
+	0,
+	0,
+	15 * 2,
+	14 * 3,
+	13 * 4,
+	12 * 5,
+	11 * 6,
+	10 * 7,
+	10 * 8,
+};
+// END_OF_UPGRADE_PARTY_BONUS
+
+const int* aiChainLightningCountBySkillLevel = NULL;
+
+const int aiChainLightningCountBySkillLevel_euckr[SKILL_MAX_LEVEL + 1] =
+{
+	0, // 0
+	2, // 1
+	2, // 2
+	2, // 3
+	2, // 4
+	2, // 5
+	2, // 6
+	2, // 7
+	2, // 8
+	3, // 9
+	3, // 10
+	3, // 11
+	3, // 12
+	3, // 13
+	3, // 14
+	3, // 15
+	3, // 16
+	3, // 17
+	3, // 18
+	4, // 19
+	4, // 20
+	4, // 21
+	4, // 22
+	4, // 23
+	5, // 24
+	5, // 25
+	5, // 26
+	5, // 27
+	5, // 28
+	5, // 29
+	5, // 30
+	5, // 31
+	5, // 32
+	5, // 33
+	5, // 34
+	5, // 35
+	5, // 36
+	5, // 37
+	5, // 38
+	5, // 39
+	5, // 40
+};
+
+const SStoneDropInfo aStoneDrop[STONE_INFO_MAX_NUM] =
+{
+	// mob pct { +0 +1 +2 +3 +4 }
+	{ 8005, 60, { 30, 30, 30, 9, 1 } },
+	{ 8006, 60, { 28, 29, 31, 11, 1 } },
+	{ 8007, 60, { 24, 29, 32, 13, 2 } },
+	{ 8008, 60, { 22, 28, 33, 15, 2 } },
+	{ 8009, 60, { 21, 27, 33, 17, 2 } },
+	{ 8010, 60, { 18, 26, 34, 20, 2 } },
+	{ 8011, 60, { 14, 26, 35, 22, 3 } },
+	{ 8012, 60, { 10, 26, 37, 24, 3 } },
+	{ 8013, 60, { 2, 26, 40, 29, 3 } },
+	{ 8014, 60, { 0, 26, 41, 30, 3 } },
+	{ 8018, 60, { 0, 25, 42, 30, 3 } },
+	{ 8019, 60, { 0, 23, 42, 32, 3 } },
+	{ 8024, 60, { 0, 22, 43, 32, 3 } },
+	{ 8025, 60, { 0, 21, 43, 32, 4 } },
+	{ 8026, 60, { 0, 19, 44, 33, 4 } },
+	{ 8027, 60, { 0, 17, 45, 34, 4 } },
+	{ 8051, 60, { 0, 15, 46, 34, 5 } },
+	{ 8052, 60, { 0, 15, 46, 34, 5 } },
+	{ 8053, 60, { 0, 12, 47, 36, 5 } },
+	{ 8054, 60, { 0, 12, 47, 36, 5 } },
+	{ 8055, 60, { 0, 9, 48, 37, 6 } },
+	{ 8056, 60, { 0, 9, 48, 37, 6 } },
+};
+
+const char* c_apszEmpireNames[EMPIRE_MAX_NUM] =
+{
+#if defined(__LOCALE_CLIENT__)
+	"[LS;1037]",
+	"[LS;793]",
+	"[LS;794]",
+	"[LS;795]"
+#else
+	"",
+	"탉",
+	"천",
+	"諭"
+#endif
+};
+
+const char* c_apszPrivNames[MAX_PRIV_NUM] =
+{
+#if defined(__LOCALE_CLIENT__)
+	"",
+	"[LS;1038]",
+	"[LS;1039]",
+	"[LS;1031]",
+	"[LS;1040]"
+#else
+	"",
+	"  확",
+	"  확",
+	"   확",
+	"치 "
+#endif
+};
+
+const int aiPolymorphPowerByLevel[SKILL_MAX_LEVEL + 1] =
+{
+	0, // 0
+	10, // 1
+	11, // 2
+	11, // 3
+	12, // 4
+	13, // 5
+	13, // 6
+	14, // 7
+	15, // 8
+	16, // 9
+	17, // 10
+	18, // 11
+	19, // 12
+	20, // 13
+	22, // 14
+	23, // 15
+	24, // 16
+	26, // 17
+	27, // 18
+	29, // 19
+	31, // 20 M1
+	33, // 21
+	35, // 22
+	37, // 23
+	39, // 24
+	41, // 25
+	44, // 26
+	46, // 27
+	49, // 28
+	52, // 29
+	55, // 30 G1
+	59, // 31
+	62, // 32
+	66, // 33
+	70, // 34
+	74, // 35
+	79, // 36
+	84, // 37
+	89, // 38
+	94,	// 39
+	100, // 40 P
+};
+
+#if defined(__PARTY_PROFICY__)
+const int aiProficiencyPowerByLevel[SKILL_MAX_LEVEL + 1] = {
+	0, 1, 2, 3, 4, 5, 6, 7,8, 9,
+	10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
+	20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
+	30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
+	50,
+};
+#endif
+
+const int aiPrecisionPowerByLevel[SKILL_MAX_LEVEL + 1] =
+{
+	0,	// 0
+	0,	// 1
+	0,	// 2
+	1,	// 3
+	1,	// 4
+	1,	// 5
+	2,	// 6
+	2,	// 7
+	2,	// 8
+	3,	// 9
+	3,	// 10
+	3,	// 11
+	4,	// 12
+	4,	// 13
+	4,	// 14
+	5,	// 15
+	5,	// 16
+	5,	// 17
+	6,	// 18
+	6,	// 19
+	8,	// 20
+	8,	// 21
+	8,	// 22
+	9,	// 23
+	9,	// 24
+	9,	// 25
+	10,	// 26
+	10,	// 27
+	11,	// 28
+	11,	// 29
+	13,	// 30
+	13,	// 31
+	14,	// 32
+	14,	// 33
+	15,	// 34
+	16,	// 35
+	16,	// 36
+	17,	// 37
+	18,	// 38
+	18,	// 39
+	20,	// 40
+};
+
+TGuildWarInfo KOR_aGuildWarInfo[GUILD_WAR_TYPE_MAX_NUM] =
+/*
+{
+	long lMapIndex;
+	int iWarPrice;
+	int iWinnerPotionRewardPctToWinner;
+	int iLoserPotionRewardPctToWinner;
+	int iInitialScore;
+	int iEndScore;
+};
+*/
+{
+	{ 0, 0, 0, 0, 0, 0 },
+	{ 110, 0, 100, 50, 0, 100 },
+	{ 111, 0, 100, 50, 0, 10 },
+};
+
+//
+// 퓬 臼 치
+//
+
+// 潔틘  煞  확
+const int aiAccessorySocketAddPct[ITEM_ACCESSORY_SOCKET_MAX_NUM] =
+{
+	50, 50, 50
+};
+
+// 퓬 치  %큼  煞求
+const int aiAccessorySocketEffectivePct[ITEM_ACCESSORY_SOCKET_MAX_NUM + 1] =
+{
+	0, 10, 20, 40
+};
+
+//  擔챨 24, 12, 6
+const int aiAccessorySocketDegradeTime[ITEM_ACCESSORY_SOCKET_MAX_NUM + 1] =
+{
+	0, 3600 * 24, 3600 * 12, 3600 * 6
+};
+
+//   
+const int aiAccessorySocketPutPct[ITEM_ACCESSORY_SOCKET_MAX_NUM + 1] =
+{
+	90, 80, 70, 0
+};
+// END_OF_ACCESSORY_REFINE
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+const int aiAcceDrainRateAdvancePct[ACCE_MAX_DRAINRATE + 1] =
+{
+	100, // 0
+	100, // 1
+	100, // 2
+	100, // 3
+	100, // 4
+	100, // 5
+	100, // 6
+	100, // 7
+	100, // 8
+	100, // 9
+	100, // 10
+	100, // 11
+	100, // 12
+	100, // 13
+	100, // 14
+	100, // 15
+	100, // 16
+	90, // 17
+	80, // 18
+	50, // 19
+	40, // 20
+	35, // 21
+	30, // 22
+	25, // 23
+	20, // 24
+	0 // 25
+};
+#endif
+
+#include "../../common/length.h"
+// from import_item_proto.c
+typedef struct SValueName
+{
+	const char* c_pszName;
+	long lValue;
+} TValueName;
+
+TValueName c_aApplyTypeNames[] =
+{
+	// APPLY_NONE
+	{ "MAX_HP", APPLY_MAX_HP },
+	{ "MAX_SP", APPLY_MAX_SP },
+	{ "CON", APPLY_CON },
+	{ "INT", APPLY_INT },
+	{ "STR", APPLY_STR },
+	{ "DEX", APPLY_DEX },
+	{ "ATT_SPEED", APPLY_ATT_SPEED },
+	{ "MOV_SPEED", APPLY_MOV_SPEED },
+	{ "CAST_SPEED", APPLY_CAST_SPEED },
+	{ "HP_REGEN", APPLY_HP_REGEN },
+	{ "SP_REGEN", APPLY_SP_REGEN },
+	{ "POISON_PCT", APPLY_POISON_PCT },
+	{ "STUN_PCT", APPLY_STUN_PCT },
+	{ "SLOW_PCT", APPLY_SLOW_PCT },
+	{ "CRITICAL_PCT", APPLY_CRITICAL_PCT },
+	{ "PENETRATE_PCT", APPLY_PENETRATE_PCT },
+	{ "ATTBONUS_HUMAN", APPLY_ATTBONUS_HUMAN },
+	{ "ATTBONUS_ANIMAL", APPLY_ATTBONUS_ANIMAL },
+	{ "ATTBONUS_ORC", APPLY_ATTBONUS_ORC },
+	{ "ATTBONUS_MILGYO", APPLY_ATTBONUS_MILGYO },
+	{ "ATTBONUS_UNDEAD", APPLY_ATTBONUS_UNDEAD },
+	{ "ATTBONUS_DEVIL", APPLY_ATTBONUS_DEVIL },
+	{ "STEAL_HP", APPLY_STEAL_HP },
+	{ "STEAL_SP", APPLY_STEAL_SP },
+	{ "MANA_BURN_PCT", APPLY_MANA_BURN_PCT },
+	{ "DAMAGE_SP_RECOVER", APPLY_DAMAGE_SP_RECOVER },
+	{ "BLOCK", APPLY_BLOCK },
+	{ "DODGE", APPLY_DODGE },
+	{ "RESIST_SWORD", APPLY_RESIST_SWORD },
+	{ "RESIST_TWOHAND", APPLY_RESIST_TWOHAND },
+	{ "RESIST_DAGGER", APPLY_RESIST_DAGGER },
+	{ "RESIST_BELL", APPLY_RESIST_BELL },
+	{ "RESIST_FAN", APPLY_RESIST_FAN },
+	{ "RESIST_BOW", APPLY_RESIST_BOW },
+	{ "RESIST_FIRE", APPLY_RESIST_FIRE },
+	{ "RESIST_ELEC", APPLY_RESIST_ELEC },
+	{ "RESIST_MAGIC", APPLY_RESIST_MAGIC },
+	{ "RESIST_WIND", APPLY_RESIST_WIND },
+	{ "REFLECT_MELEE", APPLY_REFLECT_MELEE },
+	{ "REFLECT_CURSE", APPLY_REFLECT_CURSE },
+	{ "POISON_REDUCE", APPLY_POISON_REDUCE },
+	{ "KILL_SP_RECOVER", APPLY_KILL_SP_RECOVER },
+	{ "EXP_DOUBLE_BONUS", APPLY_EXP_DOUBLE_BONUS },
+	{ "GOLD_DOUBLE_BONUS", APPLY_GOLD_DOUBLE_BONUS },
+	{ "ITEM_DROP_BONUS", APPLY_ITEM_DROP_BONUS },
+	{ "POTION_BONUS", APPLY_POTION_BONUS },
+	{ "KILL_HP_RECOVER", APPLY_KILL_HP_RECOVER },
+	{ "IMMUNE_STUN", APPLY_IMMUNE_STUN },
+	{ "IMMUNE_SLOW", APPLY_IMMUNE_SLOW },
+	{ "IMMUNE_FALL", APPLY_IMMUNE_FALL },
+	{ "SKILL", APPLY_SKILL },
+	{ "BOW_DISTANCE", APPLY_BOW_DISTANCE },
+	{ "ATT_GRADE_BONUS", APPLY_ATT_GRADE_BONUS },
+	{ "DEF_GRADE_BONUS", APPLY_DEF_GRADE_BONUS },
+	{ "MAGIC_ATT_GRADE", APPLY_MAGIC_ATT_GRADE },
+	{ "MAGIC_DEF_GRADE", APPLY_MAGIC_DEF_GRADE },
+	{ "CURSE_PCT", APPLY_CURSE_PCT },
+	{ "MAX_STAMINA", APPLY_MAX_STAMINA },
+
+	{ "ATTBONUS_WARRIOR", APPLY_ATTBONUS_WARRIOR },
+	{ "ATTBONUS_ASSASSIN", APPLY_ATTBONUS_ASSASSIN },
+	{ "ATTBONUS_SURA", APPLY_ATTBONUS_SURA },
+	{ "ATTBONUS_SHAMAN", APPLY_ATTBONUS_SHAMAN },
+	{ "ATTBONUS_MONSTER", APPLY_ATTBONUS_MONSTER },
+
+	{ "MALL_ATTBONUS", APPLY_MALL_ATTBONUS },
+	{ "MALL_DEFBONUS", APPLY_MALL_DEFBONUS },
+	{ "MALL_EXPBONUS", APPLY_MALL_EXPBONUS },
+	{ "MALL_ITEMBONUS", APPLY_MALL_ITEMBONUS },
+	{ "MALL_GOLDBONUS", APPLY_MALL_GOLDBONUS },
+
+	{ "MAX_HP_PCT", APPLY_MAX_HP_PCT },
+	{ "MAX_SP_PCT", APPLY_MAX_SP_PCT },
+
+	{ "SKILL_DAMAGE_BONUS", APPLY_SKILL_DAMAGE_BONUS },
+	{ "NORMAL_HIT_DAMAGE_BONUS", APPLY_NORMAL_HIT_DAMAGE_BONUS },
+
+	{ "SKILL_DEFEND_BONUS", APPLY_SKILL_DEFEND_BONUS },
+
+	{ "NORMAL_HIT_DEFEND_BONUS", APPLY_NORMAL_HIT_DEFEND_BONUS },
+	{ "PC_BANG_EXP_BONUS", APPLY_PC_BANG_EXP_BONUS },
+	{ "PC_BANG_DROP_BONUS", APPLY_PC_BANG_DROP_BONUS },
+
+	{ "EXTRACT_HP_PCT", APPLY_EXTRACT_HP_PCT },
+
+	{ "RESIST_WARRIOR", APPLY_RESIST_WARRIOR },
+	{ "RESIST_ASSASSIN", APPLY_RESIST_ASSASSIN },
+	{ "RESIST_SURA", APPLY_RESIST_SURA },
+	{ "RESIST_SHAMAN", APPLY_RESIST_SHAMAN },
+
+	{ "ENERGY", APPLY_ENERGY },
+	{ "DEF_GRADE", APPLY_DEF_GRADE },
+	{ "COSTUME_ATTR_BONUS", APPLY_COSTUME_ATTR_BONUS },
+	{ "MAGIC_ATTBONUS_PER", APPLY_MAGIC_ATTBONUS_PER },
+	{ "MELEE_MAGIC_ATTBONUS_PER", APPLY_MELEE_MAGIC_ATTBONUS_PER },
+
+	{ "RESIST_ICE", APPLY_RESIST_ICE },
+	{ "RESIST_EARTH", APPLY_RESIST_EARTH },
+	{ "RESIST_DARK", APPLY_RESIST_DARK },
+
+	{ "RESIST_CRITICAL", APPLY_ANTI_CRITICAL_PCT /* APPLY_RESIST_CRITICAL */ },
+	{ "RESIST_PENETRATE", APPLY_ANTI_PENETRATE_PCT /* APPLY_RESIST_PENETRATE */ },
+
+	{ "BLEEDING_REDUCE", APPLY_BLEEDING_REDUCE },
+	{ "BLEEDING_PCT", APPLY_BLEEDING_PCT },
+	{ "ATTBONUS_WOLFMAN", APPLY_ATTBONUS_WOLFMAN },
+	{ "RESIST_WOLFMAN", APPLY_RESIST_WOLFMAN },
+	{ "RESIST_CLAW", APPLY_RESIST_CLAW },
+
+	{ "ACCEDRAIN_RATE", APPLY_ACCEDRAIN_RATE },
+	{ "RESIST_MAGIC_REDUCTION", APPLY_RESIST_MAGIC_REDUCTION },
+
+	{ "ENCHANT_ELECT", APPLY_ENCHANT_ELECT },
+	{ "ENCHANT_FIRE", APPLY_ENCHANT_FIRE },
+	{ "ENCHANT_ICE", APPLY_ENCHANT_ICE },
+	{ "ENCHANT_WIND", APPLY_ENCHANT_WIND },
+	{ "ENCHANT_EARTH", APPLY_ENCHANT_EARTH },
+	{ "ENCHANT_DARK", APPLY_ENCHANT_DARK },
+
+	{ "ATTBONUS_CZ", APPLY_ATTBONUS_CZ },
+	{ "ATTBONUS_INSECT", APPLY_ATTBONUS_INSECT },
+	{ "ATTBONUS_DESERT", APPLY_ATTBONUS_DESERT },
+	{ "ATTBONUS_SWORD", APPLY_ATTBONUS_SWORD },
+	{ "ATTBONUS_TWOHAND", APPLY_ATTBONUS_TWOHAND },
+	{ "ATTBONUS_DAGGER", APPLY_ATTBONUS_DAGGER },
+	{ "ATTBONUS_BELL", APPLY_ATTBONUS_BELL },
+	{ "ATTBONUS_FAN", APPLY_ATTBONUS_FAN },
+	{ "ATTBONUS_BOW", APPLY_ATTBONUS_BOW },
+	{ "ATTBONUS_CLAW", APPLY_ATTBONUS_CLAW },
+
+	{ "RESIST_HUMAN", APPLY_RESIST_HUMAN },
+	{ "RESIST_MOUNT_FALL", APPLY_RESIST_MOUNT_FALL },
+	{ "RESIST_FIST", APPLY_RESIST_FIST },
+
+	{ "MOUNT", APPLY_MOUNT },
+
+	{ "SKILL_DAMAGE_SAMYEON", APPLY_SKILL_DAMAGE_SAMYEON },
+	{ "SKILL_DAMAGE_TANHWAN", APPLY_SKILL_DAMAGE_TANHWAN },
+	{ "SKILL_DAMAGE_PALBANG", APPLY_SKILL_DAMAGE_PALBANG },
+	{ "SKILL_DAMAGE_GIGONGCHAM", APPLY_SKILL_DAMAGE_GIGONGCHAM },
+	{ "SKILL_DAMAGE_GYOKSAN", APPLY_SKILL_DAMAGE_GYOKSAN },
+	{ "SKILL_DAMAGE_GEOMPUNG", APPLY_SKILL_DAMAGE_GEOMPUNG },
+	{ "SKILL_DAMAGE_AMSEOP", APPLY_SKILL_DAMAGE_AMSEOP },
+	{ "SKILL_DAMAGE_GUNGSIN", APPLY_SKILL_DAMAGE_GUNGSIN },
+	{ "SKILL_DAMAGE_CHARYUN", APPLY_SKILL_DAMAGE_CHARYUN },
+	{ "SKILL_DAMAGE_SANGONG", APPLY_SKILL_DAMAGE_SANGONG },
+	{ "SKILL_DAMAGE_YEONSA", APPLY_SKILL_DAMAGE_YEONSA },
+	{ "SKILL_DAMAGE_KWANKYEOK", APPLY_SKILL_DAMAGE_KWANKYEOK },
+	{ "SKILL_DAMAGE_GIGUNG", APPLY_SKILL_DAMAGE_GIGUNG },
+	{ "SKILL_DAMAGE_HWAJO", APPLY_SKILL_DAMAGE_HWAJO },
+	{ "SKILL_DAMAGE_SWAERYUNG", APPLY_SKILL_DAMAGE_SWAERYUNG },
+	{ "SKILL_DAMAGE_YONGKWON", APPLY_SKILL_DAMAGE_YONGKWON },
+	{ "SKILL_DAMAGE_PABEOB", APPLY_SKILL_DAMAGE_PABEOB },
+	{ "SKILL_DAMAGE_MARYUNG", APPLY_SKILL_DAMAGE_MARYUNG },
+	{ "SKILL_DAMAGE_HWAYEOMPOK", APPLY_SKILL_DAMAGE_HWAYEOMPOK },
+	{ "SKILL_DAMAGE_MAHWAN", APPLY_SKILL_DAMAGE_MAHWAN },
+	{ "SKILL_DAMAGE_BIPABU", APPLY_SKILL_DAMAGE_BIPABU },
+	{ "SKILL_DAMAGE_YONGBI", APPLY_SKILL_DAMAGE_YONGBI },
+	{ "SKILL_DAMAGE_PAERYONG", APPLY_SKILL_DAMAGE_PAERYONG },
+	{ "SKILL_DAMAGE_NOEJEON", APPLY_SKILL_DAMAGE_NOEJEON },
+	{ "SKILL_DAMAGE_BYEURAK", APPLY_SKILL_DAMAGE_BYEURAK },
+	{ "SKILL_DAMAGE_CHAIN", APPLY_SKILL_DAMAGE_CHAIN },
+	{ "SKILL_DAMAGE_CHAYEOL", APPLY_SKILL_DAMAGE_CHAYEOL },
+	{ "SKILL_DAMAGE_SALPOONG", APPLY_SKILL_DAMAGE_SALPOONG },
+	{ "SKILL_DAMAGE_GONGDAB", APPLY_SKILL_DAMAGE_GONGDAB },
+	{ "SKILL_DAMAGE_PASWAE", APPLY_SKILL_DAMAGE_PASWAE },
+
+	{ "NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE", APPLY_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE },
+	{ "SKILL_DEFEND_BONUS_BOSS_OR_MORE", APPLY_SKILL_DEFEND_BONUS_BOSS_OR_MORE },
+	{ "NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE", APPLY_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE },
+	{ "SKILL_DAMAGE_BONUS_BOSS_OR_MORE", APPLY_SKILL_DAMAGE_BONUS_BOSS_OR_MORE },
+
+	{ "HIT_BUFF_ENCHANT_FIRE", APPLY_HIT_BUFF_ENCHANT_FIRE },
+	{ "HIT_BUFF_ENCHANT_ICE", APPLY_HIT_BUFF_ENCHANT_ICE },
+	{ "HIT_BUFF_ENCHANT_ELEC", APPLY_HIT_BUFF_ENCHANT_ELEC },
+	{ "HIT_BUFF_ENCHANT_WIND", APPLY_HIT_BUFF_ENCHANT_WIND },
+	{ "HIT_BUFF_ENCHANT_DARK", APPLY_HIT_BUFF_ENCHANT_DARK },
+	{ "HIT_BUFF_ENCHANT_EARTH", APPLY_HIT_BUFF_ENCHANT_EARTH },
+	{ "HIT_BUFF_RESIST_FIRE", APPLY_HIT_BUFF_RESIST_FIRE },
+	{ "HIT_BUFF_RESIST_ICE", APPLY_HIT_BUFF_RESIST_ICE },
+	{ "HIT_BUFF_RESIST_ELEC", APPLY_HIT_BUFF_RESIST_ELEC },
+	{ "HIT_BUFF_RESIST_WIND", APPLY_HIT_BUFF_RESIST_WIND },
+	{ "HIT_BUFF_RESIST_DARK", APPLY_HIT_BUFF_RESIST_DARK },
+	{ "HIT_BUFF_RESIST_EARTH", APPLY_HIT_BUFF_RESIST_EARTH },
+
+	{ "USE_SKILL_CHEONGRANG_MOV_SPEED", APPLY_USE_SKILL_CHEONGRANG_MOV_SPEED },
+	{ "USE_SKILL_CHEONGRANG_CASTING_SPEED", APPLY_USE_SKILL_CHEONGRANG_CASTING_SPEED },
+	{ "USE_SKILL_CHAYEOL_CRITICAL_PCT", APPLY_USE_SKILL_CHAYEOL_CRITICAL_PCT },
+	{ "USE_SKILL_SANGONG_ATT_GRADE_BONUS", APPLY_USE_SKILL_SANGONG_ATT_GRADE_BONUS },
+	{ "USE_SKILL_GIGUNG_ATT_GRADE_BONUS", APPLY_USE_SKILL_GIGUNG_ATT_GRADE_BONUS },
+	{ "USE_SKILL_JEOKRANG_DEF_BONUS", APPLY_USE_SKILL_JEOKRANG_DEF_BONUS },
+	{ "USE_SKILL_GWIGEOM_DEF_BONUS", APPLY_USE_SKILL_GWIGEOM_DEF_BONUS },
+	{ "USE_SKILL_TERROR_ATT_GRADE_BONUS", APPLY_USE_SKILL_TERROR_ATT_GRADE_BONUS },
+	{ "USE_SKILL_MUYEONG_ATT_GRADE_BONUS", APPLY_USE_SKILL_MUYEONG_ATT_GRADE_BONUS },
+	{ "USE_SKILL_MANASHILED_CASTING_SPEED", APPLY_USE_SKILL_MANASHILED_CASTING_SPEED },
+	{ "USE_SKILL_HOSIN_DEF_BONUS", APPLY_USE_SKILL_HOSIN_DEF_BONUS },
+	{ "USE_SKILL_GICHEON_ATT_GRADE_BONUS", APPLY_USE_SKILL_GICHEON_ATT_GRADE_BONUS },
+	{ "USE_SKILL_JEONGEOP_ATT_GRADE_BONUS", APPLY_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS },
+	{ "USE_SKILL_JEUNGRYEOK_DEF_BONUS", APPLY_USE_SKILL_JEUNGRYEOK_DEF_BONUS },
+	{ "USE_SKILL_GIHYEOL_ATT_GRADE_BONUS", APPLY_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS },
+	{ "USE_SKILL_CHUNKEON_CASTING_SPEED", APPLY_USE_SKILL_CHUNKEON_CASTING_SPEED },
+	{ "USE_SKILL_NOEGEOM_ATT_GRADE_BONUS", APPLY_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS },
+
+	{ "SKILL_DURATION_INCREASE_EUNHYUNG", APPLY_SKILL_DURATION_INCREASE_EUNHYUNG },
+	{ "SKILL_DURATION_INCREASE_GYEONGGONG", APPLY_SKILL_DURATION_INCREASE_GYEONGGONG },
+	{ "SKILL_DURATION_INCREASE_GEOMKYUNG", APPLY_SKILL_DURATION_INCREASE_GEOMKYUNG },
+	{ "SKILL_DURATION_INCREASE_JEOKRANG", APPLY_SKILL_DURATION_INCREASE_JEOKRANG },
+
+	{ "USE_SKILL_PALBANG_HP_ABSORB", APPLY_USE_SKILL_PALBANG_HP_ABSORB },
+	{ "USE_SKILL_AMSEOP_HP_ABSORB", APPLY_USE_SKILL_AMSEOP_HP_ABSORB },
+	{ "USE_SKILL_YEONSA_HP_ABSORB", APPLY_USE_SKILL_YEONSA_HP_ABSORB },
+	{ "USE_SKILL_YONGBI_HP_ABSORB", APPLY_USE_SKILL_YONGBI_HP_ABSORB },
+	{ "USE_SKILL_CHAIN_HP_ABSORB", APPLY_USE_SKILL_CHAIN_HP_ABSORB },
+	{ "USE_SKILL_PASWAE_SP_ABSORB", APPLY_USE_SKILL_PASWAE_SP_ABSORB },
+
+	{ "USE_SKILL_GIGONGCHAM_STUN", APPLY_USE_SKILL_GIGONGCHAM_STUN },
+	{ "USE_SKILL_CHARYUN_STUN", APPLY_USE_SKILL_CHARYUN_STUN },
+	{ "USE_SKILL_PABEOB_STUN", APPLY_USE_SKILL_PABEOB_STUN },
+	{ "USE_SKILL_MAHWAN_STUN", APPLY_USE_SKILL_MAHWAN_STUN },
+	{ "USE_SKILL_GONGDAB_STUN", APPLY_USE_SKILL_GONGDAB_STUN },
+	{ "USE_SKILL_SAMYEON_STUN", APPLY_USE_SKILL_SAMYEON_STUN },
+
+	{ "USE_SKILL_GYOKSAN_KNOCKBACK", APPLY_USE_SKILL_GYOKSAN_KNOCKBACK },
+	{ "USE_SKILL_SEOMJEON_KNOCKBACK", APPLY_USE_SKILL_SEOMJEON_KNOCKBACK },
+	{ "USE_SKILL_SWAERYUNG_KNOCKBACK", APPLY_USE_SKILL_SWAERYUNG_KNOCKBACK },
+	{ "USE_SKILL_HWAYEOMPOK_KNOCKBACK", APPLY_USE_SKILL_HWAYEOMPOK_KNOCKBACK },
+	{ "USE_SKILL_GONGDAB_KNOCKBACK", APPLY_USE_SKILL_GONGDAB_KNOCKBACK },
+	{ "USE_SKILL_KWANKYEOK_KNOCKBACK", APPLY_USE_SKILL_KWANKYEOK_KNOCKBACK },
+
+	{ "USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER },
+	{ "USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER },
+	{ "USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER },
+	{ "USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER },
+	{ "USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER },
+	{ "USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER },
+	{ "USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER },
+	{ "USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER },
+	{ "USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER },
+	{ "USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER", APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER },
+
+	{ "ATTBONUS_STONE", APPLY_ATTBONUS_STONE },
+
+	{ "DAMAGE_HP_RECOVERY", APPLY_DAMAGE_HP_RECOVERY },
+	{ "DAMAGE_SP_RECOVERY", APPLY_DAMAGE_SP_RECOVERY },
+
+	{ "ALIGNMENT_DAMAGE_BONUS", APPLY_ALIGNMENT_DAMAGE_BONUS },
+
+	{ "NORMAL_DAMAGE_GUARD", APPLY_NORMAL_DAMAGE_GUARD },
+	{ "MORE_THEN_HP90_DAMAGE_REDUCE", APPLY_MORE_THEN_HP90_DAMAGE_REDUCE },
+
+	{ "USE_SKILL_TUSOK_HP_ABSORB", APPLY_USE_SKILL_TUSOK_HP_ABSORB },
+	{ "USE_SKILL_PAERYONG_HP_ABSORB", APPLY_USE_SKILL_PAERYONG_HP_ABSORB },
+	{ "USE_SKILL_BYEURAK_HP_ABSORB", APPLY_USE_SKILL_BYEURAK_HP_ABSORB },
+
+	{ "FIRST_ATTRIBUTE_BONUS", APPLY_FIRST_ATTRIBUTE_BONUS },
+	{ "SECOND_ATTRIBUTE_BONUS", APPLY_SECOND_ATTRIBUTE_BONUS },
+	{ "THIRD_ATTRIBUTE_BONUS", APPLY_THIRD_ATTRIBUTE_BONUS },
+	{ "FOURTH_ATTRIBUTE_BONUS", APPLY_FOURTH_ATTRIBUTE_BONUS },
+	{ "FIFTH_ATTRIBUTE_BONUS", APPLY_FIFTH_ATTRIBUTE_BONUS },
+
+	{ "USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER },
+	{ "USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER },
+	{ "USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER },
+	{ "USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER },
+	{ "USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER },
+	{ "USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER },
+	{ "USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER },
+	{ "USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER },
+	{ "USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER },
+	{ "USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER", APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER },
+	{ "USE_SKILL_CHAYEOL_HP_ABSORB", APPLY_USE_SKILL_CHAYEOL_HP_ABSORB },
+
+	{ "SUNGMA_STR", APPLY_SUNGMA_STR },
+	{ "SUNGMA_HP", APPLY_SUNGMA_HP },
+	{ "SUNGMA_MOVE", APPLY_SUNGMA_MOVE },
+	{ "SUNGMA_IMMUNE", APPLY_SUNGMA_IMMUNE },
+
+	{ "HIT_PCT", APPLY_HIT_PCT },
+#if defined(__ITEM_APPLY_RANDOM__)
+	{ "RANDOM", APPLY_NONE },
+#endif
+
+	{ "ATTBONUS_PER_HUMAN", APPLY_ATTBONUS_PER_HUMAN },
+	{ "ATTBONUS_PER_ANIMAL", APPLY_ATTBONUS_PER_ANIMAL },
+	{ "ATTBONUS_PER_ORC", APPLY_ATTBONUS_PER_ORC },
+	{ "ATTBONUS_PER_MILGYO", APPLY_ATTBONUS_PER_MILGYO },
+	{ "ATTBONUS_PER_UNDEAD", APPLY_ATTBONUS_PER_UNDEAD },
+	{ "ATTBONUS_PER_DEVIL", APPLY_ATTBONUS_PER_DEVIL },
+
+	{ "ENCHANT_PER_ELECT", APPLY_ENCHANT_PER_ELECT },
+	{ "ENCHANT_PER_FIRE", APPLY_ENCHANT_PER_FIRE },
+	{ "ENCHANT_PER_ICE", APPLY_ENCHANT_PER_ICE },
+	{ "ENCHANT_PER_WIND", APPLY_ENCHANT_PER_WIND },
+	{ "ENCHANT_PER_EARTH", APPLY_ENCHANT_PER_EARTH },
+	{ "ENCHANT_PER_DARK", APPLY_ENCHANT_PER_DARK },
+
+	{ "ATTBONUS_PER_CZ", APPLY_ATTBONUS_PER_CZ },
+	{ "ATTBONUS_PER_INSECT", APPLY_ATTBONUS_PER_INSECT },
+	{ "ATTBONUS_PER_DESERT", APPLY_ATTBONUS_PER_DESERT },
+	{ "ATTBONUS_PER_STONE", APPLY_ATTBONUS_PER_STONE },
+	{ "ATTBONUS_PER_MONSTER", APPLY_ATTBONUS_PER_MONSTER },
+
+	{ "RESIST_PER_HUMAN", APPLY_RESIST_PER_HUMAN },
+	{ "RESIST_PER_ICE", APPLY_RESIST_PER_ICE },
+	{ "RESIST_PER_DARK", APPLY_RESIST_PER_DARK },
+	{ "RESIST_PER_EARTH", APPLY_RESIST_PER_EARTH },
+	{ "RESIST_PER_FIRE", APPLY_RESIST_PER_FIRE },
+	{ "RESIST_PER_ELEC", APPLY_RESIST_PER_ELEC },
+	{ "RESIST_PER_MAGIC", APPLY_RESIST_PER_MAGIC },
+	{ "RESIST_PER_WIND", APPLY_RESIST_PER_WIND },
+
+	{ "HIT_BUFF_SUNGMA_STR", APPLY_HIT_BUFF_SUNGMA_STR },
+	{ "HIT_BUFF_SUNGMA_MOVE", APPLY_HIT_BUFF_SUNGMA_MOVE },
+	{ "HIT_BUFF_SUNGMA_HP", APPLY_HIT_BUFF_SUNGMA_HP },
+	{ "HIT_BUFF_SUNGMA_IMMUNE", APPLY_HIT_BUFF_SUNGMA_IMMUNE },
+
+	{ "MOUNT_MELEE_MAGIC_ATTBONUS_PER", APPLY_MOUNT_MELEE_MAGIC_ATTBONUS_PER },
+	{ "DISMOUNT_MOVE_SPEED_BONUS_PER", APPLY_DISMOUNT_MOVE_SPEED_BONUS_PER },
+
+	{ "HIT_AUTO_HP_RECOVERY", APPLY_HIT_AUTO_HP_RECOVERY },
+	{ "HIT_AUTO_SP_RECOVERY", APPLY_HIT_AUTO_SP_RECOVERY },
+
+	{ "USE_SKILL_COOLTIME_DECREASE_ALL", APPLY_USE_SKILL_COOLTIME_DECREASE_ALL },
+
+	{ "HIT_STONE_ATTBONUS_STONE", APPLY_HIT_STONE_ATTBONUS_STONE },
+	{ "HIT_STONE_DEF_GRADE_BONUS", APPLY_HIT_STONE_DEF_GRADE_BONUS },
+
+	{ "KILL_BOSS_ITEM_BONUS", APPLY_KILL_BOSS_ITEM_BONUS },
+	{ "MOB_HIT_MOB_AGGRESSIVE", APPLY_MOB_HIT_MOB_AGGRESSIVE },
+	{ "NO_DEATH_AND_HP_RECOVERY30", APPLY_NO_DEATH_AND_HP_RECOVERY30 },
+
+	{ "AUTO_PICKUP", APPLY_AUTO_PICKUP },
+	{ "MOUNT_NO_KNOCKBACK", APPLY_MOUNT_NO_KNOCKBACK },
+
+	{ "SUNGMA_PER_STR", APPLY_SUNGMA_PER_STR },
+	{ "SUNGMA_PER_HP", APPLY_SUNGMA_PER_HP },
+	{ "SUNGMA_PER_MOVE", APPLY_SUNGMA_PER_MOVE },
+	{ "SUNGMA_PER_IMMUNE", APPLY_SUNGMA_PER_IMMUNE },
+
+	{ "IMMUNE_POISON100", APPLY_IMMUNE_POISON100 },
+	{ "IMMUNE_BLEEDING100", APPLY_IMMUNE_BLEEDING100 },
+
+	{ "MONSTER_DEFEND_BONUS", APPLY_MONSTER_DEFEND_BONUS },
+
+	// by mhh game/affect.h 풩퓸. INFINITE_AFFECT_DURATION = 0x1FFFFFFF
+	{ "INFINITE_AFFECT_DURATION", 0x1FFFFFFF },
+
+	// 20200806.Owsap : Old apply values support.
+	{ "ATTACK_SPEED", APPLY_ATT_SPEED },
+	{ "MOVE_SPEED", APPLY_MOV_SPEED },
+	{ "ATT_BONUS", APPLY_ATT_GRADE_BONUS },
+	{ "DEF_BONUS", APPLY_DEF_GRADE_BONUS },
+	{ "ATT_BONUS_TO_WARRIOR", APPLY_ATTBONUS_WARRIOR },
+	{ "ATT_BONUS_TO_ASSASSIN", APPLY_ATTBONUS_ASSASSIN },
+	{ "ATT_BONUS_TO_SURA", APPLY_ATTBONUS_SURA },
+	{ "ATT_BONUS_TO_SHAMAN", APPLY_ATTBONUS_SHAMAN },
+	{ "ATT_BONUS_TO_WOLFMAN", APPLY_ATTBONUS_WOLFMAN },
+
+	{ NULL, 0 }
+};
+// from import_item_proto.c
+
+long FN_get_apply_type(const char* apply_type_string)
+{
+	TValueName* value_name;
+	for (value_name = c_aApplyTypeNames; value_name->c_pszName; ++value_name)
+	{
+		if (0 == strcasecmp(value_name->c_pszName, apply_type_string))
+			return value_name->lValue;
+	}
+	return 0;
+}
+
+#if defined(__SOUL_SYSTEM__)
+const int soul_refine_prob[SOUL_GRADE_MAX + 1] = { 0, 60, 40, 20, 30, 15 };
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+/*
+* By hard coding the required keys, the code becomes more readable
+* and maintainable, as anyone reading the code can immediately can
+* immediately see the requiremented keys for each stage.
+*/
+const BYTE abInvenStageKeys[EX_INVENTORY_STAGE_MAX] =
+{
+	// 90 - 135
+	2, 2, 2,
+	3, 3, 3,
+	4, 4, 4,
+	// 135 - 180
+	5, 5, 5,
+	6, 6, 6,
+	7, 7, 7
+};
+#endif
+
+TEmotionInfoMap EmotionInfoMap
+{
+	{ EMOTION_NONE, { 0, 0.0f } },
+	{ EMOTION_CLAP, { EMOTION_FLAG_SELF, 2.66667f } },
+	{ EMOTION_CONGRATULATION, { EMOTION_FLAG_SELF, 6.33333f } },
+	{ EMOTION_FORGIVE, { EMOTION_FLAG_SELF, 8.33333f } },
+	{ EMOTION_ANGRY, { EMOTION_FLAG_SELF, 4.33333f } },
+	{ EMOTION_ATTRACTIVE, { EMOTION_FLAG_SELF, 4.83333f } },
+	{ EMOTION_SAD, { EMOTION_FLAG_SELF, 7.33333f } },
+	{ EMOTION_SHY, { EMOTION_FLAG_SELF, 4.66667f } },
+	{ EMOTION_CHEERUP, { EMOTION_FLAG_SELF, 5.0f } },
+	{ EMOTION_BANTER, { EMOTION_FLAG_SELF, 7.0f } },
+	{ EMOTION_JOY, { EMOTION_FLAG_SELF, 5.33333f } },
+	{ EMOTION_CHEERS_1, { EMOTION_FLAG_SELF, 2.33333f } },
+	{ EMOTION_CHEERS_2, { EMOTION_FLAG_SELF, 2.33333f } },
+	{ EMOTION_DANCE_1, { EMOTION_FLAG_SELF, 28.3333f } },
+	{ EMOTION_DANCE_2, { EMOTION_FLAG_SELF, 4.76667f } },
+	{ EMOTION_DANCE_3, { EMOTION_FLAG_SELF, 27.3333f } },
+	{ EMOTION_DANCE_4, { EMOTION_FLAG_SELF, 30.3333f } },
+	{ EMOTION_DANCE_5, { EMOTION_FLAG_SELF, 21.1f } },
+	{ EMOTION_DANCE_6, { EMOTION_FLAG_SELF, 30.433332f } },
+	{ EMOTION_KISS, { EMOTION_FLAG_TARGET | EMOTION_FLAG_OTHER_SEX, 1.5f } },
+	{ EMOTION_FRENCH_KISS, { EMOTION_FLAG_TARGET | EMOTION_FLAG_OTHER_SEX, 4.0f } },
+	{ EMOTION_SLAP, { EMOTION_FLAG_TARGET, 2.0f } },
+#if defined(__EXPRESSING_EMOTIONS__)
+	{ EMOTION_PUSH_UP, { EMOTION_FLAG_SELF, 6.666667f } },
+	{ EMOTION_DANCE_7, { EMOTION_FLAG_SELF, 12.0f } },
+	{ EMOTION_EXERCISE, { EMOTION_FLAG_SELF, 6.333333f } },
+	{ EMOTION_DOZE, { EMOTION_FLAG_SELF, 4.666667f } },
+	{ EMOTION_SELFIE, { EMOTION_FLAG_SELF, 3.000000f } },
+	{ EMOTION_CHARGING, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_NOSAY, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_WEATHER_1, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_WEATHER_2, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_WEATHER_3, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_HUNGRY, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_SIREN, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_LETTER, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_CALL, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_CELEBRATION, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_ALCOHOL, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_BUSY, { EMOTION_FLAG_SELF, 0.0f } },
+	{ EMOTION_WHIRL, { EMOTION_FLAG_SELF, 0.0f } },
+#endif
+};
+
+#if defined(__HIDE_COSTUME_SYSTEM__)
+THiddenCostumePartMap HiddenCostumePartMap
+{
+	{ COSTUME_BODY, "costume_option.hide_body" },
+	{ COSTUME_HAIR, "costume_option.hide_hair" },
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	{ COSTUME_ACCE, "costume_option.hide_acce" },
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+	{ COSTUME_WEAPON, "costume_option.hide_weapon" },
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	{ COSTUME_AURA, "costume_option.hide_aura" },
+#endif
+};
+#endif
diff --git a/server/server/home/metin2/Source/Server/game/src/exchange.cpp b/server/server/home/metin2/Source/Server/game/src/exchange.cpp
index 69efbca..44092a1 100644
--- a/server/server/home/metin2/Source/Server/game/src/exchange.cpp
+++ b/server/server/home/metin2/Source/Server/game/src/exchange.cpp
@@ -1,887 +1,885 @@
-#include "stdafx.h"
-#include "../../libgame/include/grid.h"
-#include "utils.h"
-#include "desc.h"
-#include "desc_client.h"
-#include "char.h"
-#include "item.h"
-#include "item_manager.h"
-#include "packet.h"
-#include "log.h"
-#include "db.h"
-#include "locale_service.h"
-#include "../../common/length.h"
-#include "exchange.h"
-#include "questmanager.h"
-#include "DragonSoul.h"
-#if defined(__PET_SYSTEM__)
-#	include "PetSystem.h"
-#endif
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-#	include "messenger_manager.h"
-#endif
-
-void exchange_packet(LPCHARACTER ch, BYTE sub_header, bool is_me, DWORD arg1, TItemPos arg2, DWORD arg3, void* pvData = NULL);
-
-// 교환 패킷
-void exchange_packet(LPCHARACTER ch, BYTE sub_header, bool is_me, DWORD arg1, TItemPos arg2, DWORD arg3, void* pvData)
-{
-	if (!ch->GetDesc())
-		return;
-
-	struct packet_exchange pack_exchg;
-
-	pack_exchg.header = HEADER_GC_EXCHANGE;
-	pack_exchg.sub_header = sub_header;
-	pack_exchg.is_me = is_me;
-	pack_exchg.arg1 = arg1;
-	pack_exchg.arg2 = arg2;
-	pack_exchg.arg3 = arg3;
-
-	if (sub_header == EXCHANGE_SUBHEADER_GC_ITEM_ADD && pvData)
-	{
-		pack_exchg.arg4 = TItemPos(((LPITEM)pvData)->GetWindow(), ((LPITEM)pvData)->GetCell());
-
-		thecore_memcpy(&pack_exchg.alSockets, ((LPITEM)pvData)->GetSockets(), sizeof(pack_exchg.alSockets));
-		thecore_memcpy(&pack_exchg.aAttr, ((LPITEM)pvData)->GetAttributes(), sizeof(pack_exchg.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		pack_exchg.dwTransmutationVnum = static_cast<LPITEM>(pvData)->GetTransmutationVnum();
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		thecore_memcpy(&pack_exchg.RefineElement, ((LPITEM)pvData)->GetRefineElement(), sizeof(pack_exchg.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-		thecore_memcpy(&pack_exchg.aApplyRandom, ((LPITEM)pvData)->GetRandomApplies(), sizeof(pack_exchg.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-		pack_exchg.bSetItem = static_cast<LPITEM>(pvData)->GetItemSetValue();
-#endif
-	}
-	else
-	{
-		pack_exchg.arg4 = TItemPos(RESERVED_WINDOW, 0);
-
-		memset(&pack_exchg.alSockets, 0, sizeof(pack_exchg.alSockets));
-		memset(&pack_exchg.aAttr, 0, sizeof(pack_exchg.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		pack_exchg.dwTransmutationVnum = 0;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		memset(&pack_exchg.RefineElement, 0, sizeof(pack_exchg.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-		memset(&pack_exchg.aApplyRandom, 0, sizeof(pack_exchg.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-		pack_exchg.bSetItem = 0;
-#endif
-	}
-
-	ch->GetDesc()->Packet(&pack_exchg, sizeof(pack_exchg));
-}
-
-// 교환을 시작
-bool CHARACTER::ExchangeStart(LPCHARACTER victim)
-{
-	if (this == victim) // 자기 자신과는 교환을 못한다.
-		return false;
-
-	if (IsObserverMode())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("관전 상태에서는 교환을 할 수 없습니다."));
-		return false;
-	}
-
-	if (victim->IsRunningQuest())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("The other person is currently busy so you cannot trade right now."));
-		return false;
-	}
-
-	if (IsRunningQuest())
-		return false;
-
-	if (victim->IsNPC())
-		return false;
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc."));
-		return false;
-	}
-
-	if (victim->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || victim->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot trade while your trading partner is modifying their pet's stats."));
-		return false;
-	}
-
-	/*
-	if (GetActiveGrowthPet())
-	{
-		ChatPacket(CHAT_TYPE_INFO, "You cannot open a private shop whilst summoning your pet.");
-		return false;
-	}
-
-	if (victim->GetActiveGrowthPet())
-	{
-		ChatPacket(CHAT_TYPE_INFO, "You cannot trade whilst your partner is summoning their pet.");
-		return false;
-	}
-	*/
-#endif
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	if (CMessengerManager::instance().IsBlocked(GetName(), victim->GetName()))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", victim->GetName()));
-		return false;
-	}
-	else if (CMessengerManager::instance().IsBlocked(victim->GetName(), GetName()))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", victim->GetName()));
-		return false;
-	}
-#endif
-
-	// PREVENT_TRADE_WINDOW
-	if (PreventTradeWindow(WND_EXCHANGE, true/*except*/))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 거래창이 열려있을경우 거래를 할수 없습니다."));
-		return false;
-	}
-
-	if (victim->PreventTradeWindow(WND_EXCHANGE, true/*except*/))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 다른 거래중이라 거래를 할수 없습니다."));
-		return false;
-	}
-	// END_PREVENT_TRADE_WINDOW
-
-	int iDist = DISTANCE_APPROX(GetX() - victim->GetX(), GetY() - victim->GetY());
-
-	// 거리 체크
-	if (iDist >= EXCHANGE_MAX_DISTANCE)
-		return false;
-
-	if (GetExchange())
-		return false;
-
-	if (victim->GetExchange())
-	{
-		exchange_packet(this, EXCHANGE_SUBHEADER_GC_ALREADY, 0, 0, NPOS, 0);
-		return false;
-	}
-
-	if (victim->IsBlockMode(BLOCK_EXCHANGE))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 교환 거부 상태입니다."));
-		return false;
-	}
-
-	SetExchange(M2_NEW CExchange(this));
-	victim->SetExchange(M2_NEW CExchange(victim));
-
-	victim->GetExchange()->SetCompany(GetExchange());
-	GetExchange()->SetCompany(victim->GetExchange());
-
-	//
-	SetExchangeTime();
-	victim->SetExchangeTime();
-
-	exchange_packet(victim, EXCHANGE_SUBHEADER_GC_START, 0, GetVID(), NPOS, 0);
-	exchange_packet(this, EXCHANGE_SUBHEADER_GC_START, 0, victim->GetVID(), NPOS, 0);
-
-	return true;
-}
-
-CExchange::CExchange(LPCHARACTER pOwner)
-{
-	m_pCompany = NULL;
-
-	m_bAccept = false;
-
-	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		m_apItems[i] = NULL;
-		m_aItemPos[i] = NPOS;
-		m_abItemDisplayPos[i] = 0;
-	}
-
-	m_lGold = 0;
-#if defined(__CHEQUE_SYSTEM__)
-	m_lCheque = 0;
-#endif
-
-	m_pOwner = pOwner;
-	pOwner->SetExchange(this);
-
-	m_pGrid = M2_NEW CGrid(4, 3);
-}
-
-CExchange::~CExchange()
-{
-	M2_DELETE(m_pGrid);
-}
-
-bool CExchange::AddItem(TItemPos item_pos, BYTE display_pos)
-{
-	assert(m_pOwner != NULL && GetCompany());
-
-	if (!item_pos.IsValidItemPosition())
-		return false;
-
-	// 장비는 교환할 수 없음
-	if (item_pos.IsEquipPosition())
-		return false;
-
-	if (m_pGrid && display_pos >= m_pGrid->GetSize())
-	{
-		sys_err("EXCHANGE invalid display_pos %u", display_pos);
-		return false;
-	}
-
-	LPITEM item;
-
-	if (!(item = m_pOwner->GetItem(item_pos)))
-		return false;
-
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_GIVE))
-	{
-		m_pOwner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템을 건네줄 수 없습니다."));
-		return false;
-	}
-
-	if (true == item->isLocked())
-		return false;
-
-#if defined(__PET_SYSTEM__)
-	CPetSystem* pPetSystem = m_pOwner->GetPetSystem();
-	if (pPetSystem && pPetSystem->GetSummonItemVID() == item->GetVID())
-		return false;
-#endif
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (item->IsSealed())
-	{
-		m_pOwner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot give away a soulbound item."));
-		return false;
-	}
-#endif
-
-	// 이미 교환창에 추가된 아이템인가?
-	if (item->IsExchanging())
-	{
-		sys_log(0, "EXCHANGE under exchanging");
-		return false;
-	}
-
-	if (!m_pGrid->IsEmpty(display_pos, 1, item->GetSize()))
-	{
-		sys_log(0, "EXCHANGE not empty item_pos %d %d %d", display_pos, 1, item->GetSize());
-		return false;
-	}
-
-	Accept(false);
-	GetCompany()->Accept(false);
-
-	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		if (m_apItems[i])
-			continue;
-
-		m_apItems[i] = item;
-		m_aItemPos[i] = item_pos;
-		m_abItemDisplayPos[i] = display_pos;
-		m_pGrid->Put(display_pos, 1, item->GetSize());
-
-		item->SetExchanging(true);
-
-#ifdef __GROWTH_PET_SYSTEM__
-		if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
-		{
-			LPGROWTH_PET pkPet = item->GetOwner()->GetGrowthPet(item->GetSocket(2));
-
-			// Pet might not be stored in the bag
-			if (pkPet)
-				pkPet->PetSetExchangePacket(GetCompany()->GetOwner());
-		}
-#endif
-
-		exchange_packet(m_pOwner,
-			EXCHANGE_SUBHEADER_GC_ITEM_ADD,
-			true,
-			item->GetVnum(),
-			TItemPos(RESERVED_WINDOW, display_pos),
-			item->GetCount(),
-			item);
-
-		exchange_packet(GetCompany()->GetOwner(),
-			EXCHANGE_SUBHEADER_GC_ITEM_ADD,
-			false,
-			item->GetVnum(),
-			TItemPos(RESERVED_WINDOW, display_pos),
-			item->GetCount(),
-			item);
-
-		sys_log(0, "EXCHANGE AddItem success %s pos(%d, %d) %d", item->GetName(), item_pos.window_type, item_pos.cell, display_pos);
-
-		return true;
-	}
-
-	// 추가할 공간이 없음
-	return false;
-}
-
-bool CExchange::RemoveItem(BYTE pos)
-{
-	if (pos >= EXCHANGE_ITEM_MAX_NUM)
-		return false;
-
-	if (!m_apItems[pos])
-		return false;
-
-	TItemPos PosOfInventory = m_aItemPos[pos];
-	m_apItems[pos]->SetExchanging(false);
-
-	m_pGrid->Get(m_abItemDisplayPos[pos], 1, m_apItems[pos]->GetSize());
-
-	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_ITEM_DEL, true, pos, NPOS, 0);
-	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_ITEM_DEL, false, pos, PosOfInventory, 0);
-
-	Accept(false);
-	GetCompany()->Accept(false);
-
-	m_apItems[pos] = NULL;
-	m_aItemPos[pos] = NPOS;
-	m_abItemDisplayPos[pos] = 0;
-	return true;
-}
-
-bool CExchange::AddGold(long gold)
-{
-	if (gold <= 0 || gold > EXCHANGE_YANG_MAX)
-		return false;
-
-	if (GetOwner()->GetGold() < gold)
-	{
-		// 가지고 있는 돈이 부족.
-		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_GOLD, 0, 0, NPOS, 0);
-		return false;
-	}
-
-	if (LC_IsCanada() == true || LC_IsEurope() == true)
-	{
-		if (m_lGold > 0)
-		{
-			return false;
-		}
-	}
-
-	Accept(false);
-	GetCompany()->Accept(false);
-
-	m_lGold = gold;
-
-	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_GOLD_ADD, true, m_lGold, NPOS, 0);
-	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_GOLD_ADD, false, m_lGold, NPOS, 0);
-	return true;
-}
-
-#if defined(__CHEQUE_SYSTEM__)
-bool CExchange::AddCheque(long cheque)
-{
-	if (cheque <= 0 || cheque > EXCHANGE_CHEQUE_MAX)
-		return false;
-
-	if (GetOwner()->GetCheque() < cheque)
-	{
-		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
-		return false;
-	}
-
-	LPCHARACTER victim = GetCompany()->GetOwner();
-
-	if (m_lCheque)
-	{
-		long vic_cheque = victim->GetCheque() + m_lCheque;
-		if (vic_cheque > CHEQUE_MAX)
-		{
-			exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("This user can not accept that much cheque."));
-			return false;
-		}
-	}
-
-	if (LC_IsCanada() == true || LC_IsEurope() == true)
-	{
-		if (m_lCheque > 0)
-		{
-			return false;
-		}
-	}
-
-	Accept(false);
-	GetCompany()->Accept(false);
-
-	m_lCheque = cheque;
-
-	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, true, m_lCheque, NPOS, 0);
-	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, false, m_lCheque, NPOS, 0);
-	return true;
-}
-#endif
-
-// 돈이 충분히 있는지, 교환하려는 아이템이 실제로 있는지 확인 한다.
-bool CExchange::Check(int* piItemCount)
-{
-	if (GetOwner()->GetGold() < m_lGold)
-		return false;
-
-#if defined(__CHEQUE_SYSTEM__)
-	if (GetOwner()->GetCheque() < m_lCheque)
-		return false;
-#endif
-
-	int item_count = 0;
-
-	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		if (!m_apItems[i])
-			continue;
-
-		if (!m_aItemPos[i].IsValidItemPosition())
-			return false;
-
-		if (m_apItems[i] != GetOwner()->GetItem(m_aItemPos[i]))
-			return false;
-
-		++item_count;
-	}
-
-	*piItemCount = item_count;
-	return true;
-}
-
-bool CExchange::CheckSpace()
-{
-	static CGrid s_grid1(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
-	static CGrid s_grid2(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	static CGrid s_grid3(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
-	static CGrid s_grid4(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
-#endif
-
-	s_grid1.Clear();
-	s_grid2.Clear();
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	s_grid3.Clear();
-	s_grid4.Clear();
-#endif
-
-	LPCHARACTER victim = GetCompany()->GetOwner();
-	LPITEM item;
-
-	int i;
-
-	for (i = 0; i < INVENTORY_PAGE_SIZE * 1; ++i)
-	{
-		if (!(item = victim->GetInventoryItem(i)))
-			continue;
-
-		s_grid1.Put(i, 1, item->GetSize());
-	}
-	for (i = INVENTORY_PAGE_SIZE * 1; i < INVENTORY_PAGE_SIZE * 2; ++i)
-	{
-		if (!(item = victim->GetInventoryItem(i)))
-			continue;
-
-		s_grid2.Put(i - INVENTORY_PAGE_SIZE * 1, 1, item->GetSize());
-	}
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (i = INVENTORY_PAGE_SIZE * 2; i < INVENTORY_PAGE_SIZE * 3; ++i)
-	{
-		if (!(item = victim->GetInventoryItem(i)))
-			continue;
-
-		s_grid3.Put(i - INVENTORY_PAGE_SIZE * 2, 1, item->GetSize());
-	}
-	for (i = INVENTORY_PAGE_SIZE * 3; i < INVENTORY_PAGE_SIZE * 4; ++i)
-	{
-		if (!(item = victim->GetInventoryItem(i)))
-			continue;
-
-		s_grid4.Put(i - INVENTORY_PAGE_SIZE * 3, 1, item->GetSize());
-	}
-#endif
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	// 아... 뭔가 개병신 같지만... 용혼석 인벤을 노멀 인벤 보고 따라 만든 내 잘못이다 ㅠㅠ
-	static std::vector <WORD> s_vDSGrid(DRAGON_SOUL_INVENTORY_MAX_NUM);
-
-	// 일단 용혼석을 교환하지 않을 가능성이 크므로, 용혼석 인벤 복사는 용혼석이 있을 때 하도록 한다.
-	bool bDSInitialized = false;
-#endif
-
-	for (i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		if (!(item = m_apItems[i]))
-			continue;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-		{
-			if (!victim->DragonSoul_IsQualified())
-				return false;
-
-			if (!bDSInitialized)
-			{
-				bDSInitialized = true;
-				victim->CopyDragonSoulItemGrid(s_vDSGrid);
-			}
-
-			bool bExistEmptySpace = false;
-			WORD wBasePos = DSManager::instance().GetBasePosition(item);
-			if (wBasePos >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-				return false;
-
-			for (int i = 0; i < DRAGON_SOUL_BOX_SIZE; i++)
-			{
-				WORD wPos = wBasePos + i;
-				if (0 == s_vDSGrid[wPos])
-				{
-					bool bEmpty = true;
-					for (int j = 1; j < item->GetSize(); j++)
-					{
-						if (s_vDSGrid[wPos + j * DRAGON_SOUL_BOX_COLUMN_NUM])
-						{
-							bEmpty = false;
-							break;
-						}
-					}
-					if (bEmpty)
-					{
-						for (int j = 0; j < item->GetSize(); j++)
-						{
-							s_vDSGrid[wPos + j * DRAGON_SOUL_BOX_COLUMN_NUM] = wPos + 1;
-						}
-						bExistEmptySpace = true;
-						break;
-					}
-				}
-				if (bExistEmptySpace)
-					break;
-			}
-			if (!bExistEmptySpace)
-				return false;
-		}
-		else
-#endif
-		{
-			int iPos;
-
-			if ((iPos = s_grid1.FindBlank(1, item->GetSize())) >= 0)
-				s_grid1.Put(iPos, 1, item->GetSize());
-			else if ((iPos = s_grid2.FindBlank(1, item->GetSize())) >= 0)
-				s_grid2.Put(iPos, 1, item->GetSize());
-#if defined(__EXTEND_INVEN_SYSTEM__)
-			else if ((iPos = s_grid3.FindBlank(1, item->GetSize())) >= 0)
-			{
-				int iExtendMaxPos = (INVENTORY_WIDTH * victim->GetExtendInvenStage()) - 1;
-				if (iPos > iExtendMaxPos)
-					return false;
-
-				if (item->GetSize() > 1)
-				{
-					iExtendMaxPos -= (INVENTORY_WIDTH * (item->GetSize() - 1));
-					if (iPos > iExtendMaxPos)
-						return false;
-				}
-				s_grid3.Put(iPos, 1, item->GetSize());
-			}
-			else if ((iPos = s_grid4.FindBlank(1, item->GetSize())) >= 0)
-			{
-				int iExtendMaxPos = (INVENTORY_WIDTH * (victim->GetExtendInvenStage() - INVENTORY_HEIGHT)) - 1;
-				if (iPos > iExtendMaxPos)
-					return false;
-
-				if (item->GetSize() > 1)
-				{
-					iExtendMaxPos -= (INVENTORY_WIDTH * (item->GetSize() - 1));
-					if (iPos > iExtendMaxPos)
-						return false;
-				}
-				s_grid4.Put(iPos, 1, item->GetSize());
-			}
-#endif
-			else
-				return false; // No space left in inventory
-		}
-	}
-
-	return true;
-}
-
-// 교환 끝 (아이템과 돈 등을 실제로 옮긴다)
-bool CExchange::Done()
-{
-	int empty_pos, i;
-	LPITEM item;
-
-	LPCHARACTER victim = GetCompany()->GetOwner();
-
-#if defined(__CHEQUE_SYSTEM__)
-	if (m_lCheque)
-	{
-		long vic_cheque = victim->GetCheque() + m_lCheque;
-		if (vic_cheque > CHEQUE_MAX)
-		{
-			// exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The has reached cheque limit."));
-			return false;
-		}
-	}
-#endif
-
-	for (i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		if (!(item = m_apItems[i]))
-			continue;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-			empty_pos = victim->GetEmptyDragonSoulInventory(item);
-		else
-#endif
-			empty_pos = victim->GetEmptyInventory(item->GetSize());
-
-		if (empty_pos < 0)
-		{
-			sys_err("Exchange::Done : Cannot find blank position in inventory %s <-> %s item %s",
-				m_pOwner->GetName(), victim->GetName(), item->GetName());
-			continue;
-		}
-
-		if (empty_pos < 0)
-		{
-			sys_err("Exchange::Done : Cannot find blank position in inventory %s <-> %s item %s",
-					m_pOwner->GetName(), victim->GetName(), item->GetName());
-			continue;
-		}
-
-		assert(empty_pos >= 0);
-
-		m_pOwner->SyncQuickslot(SLOT_TYPE_INVENTORY, item->GetCell(), WORD_MAX);
-
-#ifdef __GROWTH_PET_SYSTEM__
-		if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
-		{
-			LPGROWTH_PET pkPet = item->GetOwner()->GetGrowthPet(item->GetSocket(2));
-			if (pkPet)
-			{
-				// Remove from previous owner
-				item->GetOwner()->DeleteGrowthPet(item->GetSocket(2));
-
-				// Add to the new owner
-				victim->SetGrowthPet(pkPet);
-				pkPet->Save();
-			}
-		}
-#endif
-
-		item->RemoveFromCharacter();
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-			item->AddToCharacter(victim, TItemPos(DRAGON_SOUL_INVENTORY, empty_pos));
-		else
-#endif
-			item->AddToCharacter(victim, TItemPos(INVENTORY, empty_pos));
-		ITEM_MANAGER::instance().FlushDelayedSave(item);
-
-		item->SetExchanging(false);
-		{
-			char exchange_buf[51];
-
-			snprintf(exchange_buf, sizeof(exchange_buf), "%s %u %u", item->GetName(), GetOwner()->GetPlayerID(), item->GetCount());
-			LogManager::instance().ItemLog(victim, item, "EXCHANGE_TAKE", exchange_buf);
-
-			snprintf(exchange_buf, sizeof(exchange_buf), "%s %u %u", item->GetName(), victim->GetPlayerID(), item->GetCount());
-			LogManager::instance().ItemLog(GetOwner(), item, "EXCHANGE_GIVE", exchange_buf);
-
-			if (item->GetVnum() >= 80003 && item->GetVnum() <= 80007)
-			{
-				LogManager::instance().GoldBarLog(victim->GetPlayerID(), item->GetID(), EXCHANGE_TAKE, "");
-				LogManager::instance().GoldBarLog(GetOwner()->GetPlayerID(), item->GetID(), EXCHANGE_GIVE, "");
-			}
-
-			m_pOwner->CreateFly(FLY_SP_MEDIUM, victim);
-			for (int i = 0; i < 3; i++)
-				m_pOwner->CreateFly(FLY_SP_SMALL, victim);
-		}
-
-		m_apItems[i] = NULL;
-	}
-
-	if (m_lGold)
-	{
-		GetOwner()->PointChange(POINT_GOLD, -m_lGold, true);
-		victim->PointChange(POINT_GOLD, m_lGold, true);
-
-		if (m_lGold > 1000)
-		{
-			char exchange_buf[51];
-			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", GetOwner()->GetPlayerID(), GetOwner()->GetName());
-			LogManager::instance().CharLog(victim, m_lGold, "EXCHANGE_GOLD_TAKE", exchange_buf);
-
-			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", victim->GetPlayerID(), victim->GetName());
-			LogManager::instance().CharLog(GetOwner(), m_lGold, "EXCHANGE_GOLD_GIVE", exchange_buf);
-		}
-	}
-
-#if defined(__CHEQUE_SYSTEM__)
-	if (m_lCheque)
-	{
-		GetOwner()->PointChange(POINT_CHEQUE, -m_lCheque, true);
-		victim->PointChange(POINT_CHEQUE, m_lCheque, true);
-
-		if (m_lCheque > 1000)
-		{
-			char exchange_buf[51];
-			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", GetOwner()->GetPlayerID(), GetOwner()->GetName());
-			LogManager::instance().CharLog(victim, m_lCheque, "EXCHANGE_GOLD_TAKE", exchange_buf);
-
-			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", victim->GetPlayerID(), victim->GetName());
-			LogManager::instance().CharLog(GetOwner(), m_lCheque, "EXCHANGE_GOLD_GIVE", exchange_buf);
-		}
-	}
-#endif
-
-	m_pGrid->Clear();
-	return true;
-}
-
-// 교환을 동의
-bool CExchange::Accept(bool bAccept)
-{
-	if (m_bAccept == bAccept)
-		return true;
-
-	m_bAccept = bAccept;
-
-	// 둘 다 동의 했으므로 교환 성립
-	if (m_bAccept && GetCompany()->m_bAccept)
-	{
-		int iItemCount;
-
-		LPCHARACTER victim = GetCompany()->GetOwner();
-
-		// PREVENT_PORTAL_AFTER_EXCHANGE
-		GetOwner()->SetExchangeTime();
-		victim->SetExchangeTime();
-		// END_PREVENT_PORTAL_AFTER_EXCHANGE
-
-		if (GetOwner()->IsRunningQuest() || victim->IsRunningQuest())
-			goto EXCHANGE_END;
-	
-		// exchange_check 에서는 교환할 아이템들이 제자리에 있나 확인하고,
-		// 엘크도 충분히 있나 확인한다, 두번째 인자로 교환할 아이템 개수
-		// 를 리턴한다.
-		if (!Check(&iItemCount))
-		{
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("돈이 부족하거나 아이템이 제자리에 없습니다."));
-			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방의 돈이 부족하거나 아이템이 제자리에 없습니다."));
-			goto EXCHANGE_END;
-		}
-
-		// 리턴 받은 아이템 개수로 상대방의 소지품에 남은 자리가 있나 확인한다.
-		if (!CheckSpace())
-		{
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방의 소지품에 빈 공간이 없습니다."));
-			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지품에 빈 공간이 없습니다."));
-			goto EXCHANGE_END;
-		}
-
-		// 상대방도 마찬가지로..
-		if (!GetCompany()->Check(&iItemCount))
-		{
-			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("돈이 부족하거나 아이템이 제자리에 없습니다."));
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방의 돈이 부족하거나 아이템이 제자리에 없습니다."));
-			goto EXCHANGE_END;
-		}
-
-		if (!GetCompany()->CheckSpace())
-		{
-			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방의 소지품에 빈 공간이 없습니다."));
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("소지품에 빈 공간이 없습니다."));
-			goto EXCHANGE_END;
-		}
-
-		if (db_clientdesc->GetSocket() == INVALID_SOCKET)
-		{
-			sys_err("Cannot use exchange feature while DB cache connection is dead.");
-			victim->ChatPacket(CHAT_TYPE_INFO, "Unknown error");
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, "Unknown error");
-			goto EXCHANGE_END;
-		}
-
-		if (Done())
-		{
-			if (m_lGold) // 돈이 있을 떄만 저장
-				GetOwner()->Save();
-
-#if defined(__CHEQUE_SYSTEM__)
-			if (m_lCheque)
-				GetOwner()->Save();
-#endif
-
-			if (GetCompany()->Done())
-			{
-				if (GetCompany()->m_lGold) // 돈이 있을 때만 저장
-					victim->Save();
-
-#if defined(__CHEQUE_SYSTEM__)
-				if (GetCompany()->m_lCheque)
-					victim->Save();
-#endif
-
-				// INTERNATIONAL_VERSION
-				GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 님과의 교환이 성사 되었습니다.", victim->GetName()));
-				victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 님과의 교환이 성사 되었습니다.", GetOwner()->GetName()));
-				// END_OF_INTERNATIONAL_VERSION
-			}
-		}
-
-	EXCHANGE_END:
-		Cancel();
-		return false;
-	}
-	else
-	{
-		// 아니면 accept에 대한 패킷을 보내자.
-		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_ACCEPT, true, m_bAccept, NPOS, 0);
-		exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_ACCEPT, false, m_bAccept, NPOS, 0);
-		return true;
-	}
-}
-
-// 교환 취소
-void CExchange::Cancel()
-{
-	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_END, 0, 0, NPOS, 0);
-	GetOwner()->SetExchange(NULL);
-
-	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		if (m_apItems[i])
-			m_apItems[i]->SetExchanging(false);
-	}
-
-	if (GetCompany())
-	{
-		GetCompany()->SetCompany(NULL);
-		GetCompany()->Cancel();
-	}
-
-	M2_DELETE(this);
-}
+#include "stdafx.h"
+#include "../../libgame/include/grid.h"
+#include "utils.h"
+#include "desc.h"
+#include "desc_client.h"
+#include "char.h"
+#include "item.h"
+#include "item_manager.h"
+#include "packet.h"
+#include "log.h"
+#include "db.h"
+#include "locale_service.h"
+#include "../../common/length.h"
+#include "exchange.h"
+#include "questmanager.h"
+#include "DragonSoul.h"
+#if defined(__PET_SYSTEM__)
+#	include "PetSystem.h"
+#endif
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+#	include "messenger_manager.h"
+#endif
+
+void exchange_packet(LPCHARACTER ch, BYTE sub_header, bool is_me, DWORD arg1, TItemPos arg2, DWORD arg3, void* pvData = NULL);
+
+// 환 킷
+void exchange_packet(LPCHARACTER ch, BYTE sub_header, bool is_me, DWORD arg1, TItemPos arg2, DWORD arg3, void* pvData)
+{
+	if (!ch->GetDesc())
+		return;
+
+	struct packet_exchange pack_exchg;
+
+	pack_exchg.header = HEADER_GC_EXCHANGE;
+	pack_exchg.sub_header = sub_header;
+	pack_exchg.is_me = is_me;
+	pack_exchg.arg1 = arg1;
+	pack_exchg.arg2 = arg2;
+	pack_exchg.arg3 = arg3;
+
+	if (sub_header == EXCHANGE_SUBHEADER_GC_ITEM_ADD && pvData)
+	{
+		pack_exchg.arg4 = TItemPos(((LPITEM)pvData)->GetWindow(), ((LPITEM)pvData)->GetCell());
+
+		thecore_memcpy(&pack_exchg.alSockets, ((LPITEM)pvData)->GetSockets(), sizeof(pack_exchg.alSockets));
+		thecore_memcpy(&pack_exchg.aAttr, ((LPITEM)pvData)->GetAttributes(), sizeof(pack_exchg.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		pack_exchg.dwTransmutationVnum = static_cast<LPITEM>(pvData)->GetTransmutationVnum();
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		thecore_memcpy(&pack_exchg.RefineElement, ((LPITEM)pvData)->GetRefineElement(), sizeof(pack_exchg.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+		thecore_memcpy(&pack_exchg.aApplyRandom, ((LPITEM)pvData)->GetRandomApplies(), sizeof(pack_exchg.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+		pack_exchg.bSetItem = static_cast<LPITEM>(pvData)->GetItemSetValue();
+#endif
+	}
+	else
+	{
+		pack_exchg.arg4 = TItemPos(RESERVED_WINDOW, 0);
+
+		memset(&pack_exchg.alSockets, 0, sizeof(pack_exchg.alSockets));
+		memset(&pack_exchg.aAttr, 0, sizeof(pack_exchg.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		pack_exchg.dwTransmutationVnum = 0;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		memset(&pack_exchg.RefineElement, 0, sizeof(pack_exchg.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+		memset(&pack_exchg.aApplyRandom, 0, sizeof(pack_exchg.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+		pack_exchg.bSetItem = 0;
+#endif
+	}
+
+	ch->GetDesc()->Packet(&pack_exchg, sizeof(pack_exchg));
+}
+
+// 환 
+bool CHARACTER::ExchangeStart(LPCHARACTER victim)
+{
+	if (this == victim) // 未 黴키 환 磯.
+		return false;
+
+	if (IsObserverMode())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 쩔 환   求."));
+		return false;
+	}
+
+	if (victim->IsRunningQuest())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("The other person is currently busy so you cannot trade right now."));
+		return false;
+	}
+
+	if (IsRunningQuest())
+		return false;
+
+	if (victim->IsNPC())
+		return false;
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		ChatPacket(CHAT_TYPE_INFO, "While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc.");
+		return false;
+	}
+
+	if (victim->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || victim->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		ChatPacket(CHAT_TYPE_INFO, "You cannot trade while your trading partner is modifying their pet's stats.");
+		return false;
+	}
+
+	if (GetActiveGrowthPet())
+	{
+		ChatPacket(CHAT_TYPE_INFO, "You cannot open a private shop whilst summoning your pet.");
+		return false;
+	}
+
+	if (victim->GetActiveGrowthPet())
+	{
+		ChatPacket(CHAT_TYPE_INFO, "You cannot trade whilst your partner is summoning their pet.");
+		return false;
+	}
+#endif
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	if (CMessengerManager::instance().IsBlocked(GetName(), victim->GetName()))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", victim->GetName()));
+		return false;
+	}
+	else if (CMessengerManager::instance().IsBlocked(victim->GetName(), GetName()))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", victim->GetName()));
+		return false;
+	}
+#endif
+
+	// PREVENT_TRADE_WINDOW
+	if (PreventTradeWindow(WND_EXCHANGE, true/*except*/))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 킹창  킹 寗 求."));
+		return false;
+	}
+
+	if (victim->PreventTradeWindow(WND_EXCHANGE, true/*except*/))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 摸 킹繭 킹 寗 求."));
+		return false;
+	}
+	// END_PREVENT_TRADE_WINDOW
+
+	int iDist = DISTANCE_APPROX(GetX() - victim->GetX(), GetY() - victim->GetY());
+
+	// 타 체크
+	if (iDist >= EXCHANGE_MAX_DISTANCE)
+		return false;
+
+	if (GetExchange())
+		return false;
+
+	if (victim->GetExchange())
+	{
+		exchange_packet(this, EXCHANGE_SUBHEADER_GC_ALREADY, 0, 0, NPOS, 0);
+		return false;
+	}
+
+	if (victim->IsBlockMode(BLOCK_EXCHANGE))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 환 탄 都求."));
+		return false;
+	}
+
+	SetExchange(M2_NEW CExchange(this));
+	victim->SetExchange(M2_NEW CExchange(victim));
+
+	victim->GetExchange()->SetCompany(GetExchange());
+	GetExchange()->SetCompany(victim->GetExchange());
+
+	//
+	SetExchangeTime();
+	victim->SetExchangeTime();
+
+	exchange_packet(victim, EXCHANGE_SUBHEADER_GC_START, 0, GetVID(), NPOS, 0);
+	exchange_packet(this, EXCHANGE_SUBHEADER_GC_START, 0, victim->GetVID(), NPOS, 0);
+
+	return true;
+}
+
+CExchange::CExchange(LPCHARACTER pOwner)
+{
+	m_pCompany = NULL;
+
+	m_bAccept = false;
+
+	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		m_apItems[i] = NULL;
+		m_aItemPos[i] = NPOS;
+		m_abItemDisplayPos[i] = 0;
+	}
+
+	m_lGold = 0;
+#if defined(__CHEQUE_SYSTEM__)
+	m_lCheque = 0;
+#endif
+
+	m_pOwner = pOwner;
+	pOwner->SetExchange(this);
+
+	m_pGrid = M2_NEW CGrid(4, 3);
+}
+
+CExchange::~CExchange()
+{
+	M2_DELETE(m_pGrid);
+}
+
+bool CExchange::AddItem(TItemPos item_pos, BYTE display_pos)
+{
+	assert(m_pOwner != NULL && GetCompany());
+
+	if (!item_pos.IsValidItemPosition())
+		return false;
+
+	//  환  
+	if (item_pos.IsEquipPosition())
+		return false;
+
+	if (m_pGrid && display_pos >= m_pGrid->GetSize())
+	{
+		sys_err("EXCHANGE invalid display_pos %u", display_pos);
+		return false;
+	}
+
+	LPITEM item;
+
+	if (!(item = m_pOwner->GetItem(item_pos)))
+		return false;
+
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_GIVE))
+	{
+		m_pOwner->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 풍  求."));
+		return false;
+	}
+
+	if (true == item->isLocked())
+		return false;
+
+#if defined(__PET_SYSTEM__)
+	CPetSystem* pPetSystem = m_pOwner->GetPetSystem();
+	if (pPetSystem && pPetSystem->GetSummonItemVID() == item->GetVID())
+		return false;
+#endif
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (item->IsSealed())
+	{
+		m_pOwner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot give away a soulbound item."));
+		return false;
+	}
+#endif
+
+	// 譴 환창 煞 寬?
+	if (item->IsExchanging())
+	{
+		sys_log(0, "EXCHANGE under exchanging");
+		return false;
+	}
+
+	if (!m_pGrid->IsEmpty(display_pos, 1, item->GetSize()))
+	{
+		sys_log(0, "EXCHANGE not empty item_pos %d %d %d", display_pos, 1, item->GetSize());
+		return false;
+	}
+
+	Accept(false);
+	GetCompany()->Accept(false);
+
+	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		if (m_apItems[i])
+			continue;
+
+		m_apItems[i] = item;
+		m_aItemPos[i] = item_pos;
+		m_abItemDisplayPos[i] = display_pos;
+		m_pGrid->Put(display_pos, 1, item->GetSize());
+
+		item->SetExchanging(true);
+
+#ifdef __GROWTH_PET_SYSTEM__
+		if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
+		{
+			LPGROWTH_PET pkPet = item->GetOwner()->GetGrowthPet(item->GetSocket(2));
+
+			// Pet might not be stored in the bag
+			if (pkPet)
+				pkPet->PetSetExchangePacket(GetCompany()->GetOwner());
+		}
+#endif
+
+		exchange_packet(m_pOwner,
+			EXCHANGE_SUBHEADER_GC_ITEM_ADD,
+			true,
+			item->GetVnum(),
+			TItemPos(RESERVED_WINDOW, display_pos),
+			item->GetCount(),
+			item);
+
+		exchange_packet(GetCompany()->GetOwner(),
+			EXCHANGE_SUBHEADER_GC_ITEM_ADD,
+			false,
+			item->GetVnum(),
+			TItemPos(RESERVED_WINDOW, display_pos),
+			item->GetCount(),
+			item);
+
+		sys_log(0, "EXCHANGE AddItem success %s pos(%d, %d) %d", item->GetName(), item_pos.window_type, item_pos.cell, display_pos);
+
+		return true;
+	}
+
+	// 煞  
+	return false;
+}
+
+bool CExchange::RemoveItem(BYTE pos)
+{
+	if (pos >= EXCHANGE_ITEM_MAX_NUM)
+		return false;
+
+	if (!m_apItems[pos])
+		return false;
+
+	TItemPos PosOfInventory = m_aItemPos[pos];
+	m_apItems[pos]->SetExchanging(false);
+
+	m_pGrid->Get(m_abItemDisplayPos[pos], 1, m_apItems[pos]->GetSize());
+
+	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_ITEM_DEL, true, pos, NPOS, 0);
+	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_ITEM_DEL, false, pos, PosOfInventory, 0);
+
+	Accept(false);
+	GetCompany()->Accept(false);
+
+	m_apItems[pos] = NULL;
+	m_aItemPos[pos] = NPOS;
+	m_abItemDisplayPos[pos] = 0;
+	return true;
+}
+
+bool CExchange::AddGold(long gold)
+{
+	if (gold <= 0 || gold > EXCHANGE_YANG_MAX)
+		return false;
+
+	if (GetOwner()->GetGold() < gold)
+	{
+		//  獵  .
+		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_GOLD, 0, 0, NPOS, 0);
+		return false;
+	}
+
+	if (LC_IsCanada() == true || LC_IsEurope() == true)
+	{
+		if (m_lGold > 0)
+		{
+			return false;
+		}
+	}
+
+	Accept(false);
+	GetCompany()->Accept(false);
+
+	m_lGold = gold;
+
+	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_GOLD_ADD, true, m_lGold, NPOS, 0);
+	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_GOLD_ADD, false, m_lGold, NPOS, 0);
+	return true;
+}
+
+#if defined(__CHEQUE_SYSTEM__)
+bool CExchange::AddCheque(long cheque)
+{
+	if (cheque <= 0 || cheque > EXCHANGE_CHEQUE_MAX)
+		return false;
+
+	if (GetOwner()->GetCheque() < cheque)
+	{
+		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
+		return false;
+	}
+
+	LPCHARACTER victim = GetCompany()->GetOwner();
+
+	if (m_lCheque)
+	{
+		long vic_cheque = victim->GetCheque() + m_lCheque;
+		if (vic_cheque > CHEQUE_MAX)
+		{
+			exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("This user can not accept that much cheque."));
+			return false;
+		}
+	}
+
+	if (LC_IsCanada() == true || LC_IsEurope() == true)
+	{
+		if (m_lCheque > 0)
+		{
+			return false;
+		}
+	}
+
+	Accept(false);
+	GetCompany()->Accept(false);
+
+	m_lCheque = cheque;
+
+	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, true, m_lCheque, NPOS, 0);
+	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, false, m_lCheque, NPOS, 0);
+	return true;
+}
+#endif
+
+//   獵, 환狗   獵 확 磯.
+bool CExchange::Check(int* piItemCount)
+{
+	if (GetOwner()->GetGold() < m_lGold)
+		return false;
+
+#if defined(__CHEQUE_SYSTEM__)
+	if (GetOwner()->GetCheque() < m_lCheque)
+		return false;
+#endif
+
+	int item_count = 0;
+
+	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		if (!m_apItems[i])
+			continue;
+
+		if (!m_aItemPos[i].IsValidItemPosition())
+			return false;
+
+		if (m_apItems[i] != GetOwner()->GetItem(m_aItemPos[i]))
+			return false;
+
+		++item_count;
+	}
+
+	*piItemCount = item_count;
+	return true;
+}
+
+bool CExchange::CheckSpace()
+{
+	static CGrid s_grid1(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+	static CGrid s_grid2(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	static CGrid s_grid3(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+	static CGrid s_grid4(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+#endif
+
+	s_grid1.Clear();
+	s_grid2.Clear();
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	s_grid3.Clear();
+	s_grid4.Clear();
+#endif
+
+	LPCHARACTER victim = GetCompany()->GetOwner();
+	LPITEM item;
+
+	int i;
+
+	for (i = 0; i < INVENTORY_PAGE_SIZE * 1; ++i)
+	{
+		if (!(item = victim->GetInventoryItem(i)))
+			continue;
+
+		s_grid1.Put(i, 1, item->GetSize());
+	}
+	for (i = INVENTORY_PAGE_SIZE * 1; i < INVENTORY_PAGE_SIZE * 2; ++i)
+	{
+		if (!(item = victim->GetInventoryItem(i)))
+			continue;
+
+		s_grid2.Put(i - INVENTORY_PAGE_SIZE * 1, 1, item->GetSize());
+	}
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (i = INVENTORY_PAGE_SIZE * 2; i < INVENTORY_PAGE_SIZE * 3; ++i)
+	{
+		if (!(item = victim->GetInventoryItem(i)))
+			continue;
+
+		s_grid3.Put(i - INVENTORY_PAGE_SIZE * 2, 1, item->GetSize());
+	}
+	for (i = INVENTORY_PAGE_SIZE * 3; i < INVENTORY_PAGE_SIZE * 4; ++i)
+	{
+		if (!(item = victim->GetInventoryItem(i)))
+			continue;
+
+		s_grid4.Put(i - INVENTORY_PAGE_SIZE * 3, 1, item->GetSize());
+	}
+#endif
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	// ...   ... 혼 觀  觀     蔘甄 圭
+	static std::vector <WORD> s_vDSGrid(DRAGON_SOUL_INVENTORY_MAX_NUM);
+
+	// 求 혼 환   크퓐, 혼 觀  혼   溝 磯.
+	bool bDSInitialized = false;
+#endif
+
+	for (i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		if (!(item = m_apItems[i]))
+			continue;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+		{
+			if (!victim->DragonSoul_IsQualified())
+				return false;
+
+			if (!bDSInitialized)
+			{
+				bDSInitialized = true;
+				victim->CopyDragonSoulItemGrid(s_vDSGrid);
+			}
+
+			bool bExistEmptySpace = false;
+			WORD wBasePos = DSManager::instance().GetBasePosition(item);
+			if (wBasePos >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+				return false;
+
+			for (int i = 0; i < DRAGON_SOUL_BOX_SIZE; i++)
+			{
+				WORD wPos = wBasePos + i;
+				if (0 == s_vDSGrid[wPos])
+				{
+					bool bEmpty = true;
+					for (int j = 1; j < item->GetSize(); j++)
+					{
+						if (s_vDSGrid[wPos + j * DRAGON_SOUL_BOX_COLUMN_NUM])
+						{
+							bEmpty = false;
+							break;
+						}
+					}
+					if (bEmpty)
+					{
+						for (int j = 0; j < item->GetSize(); j++)
+						{
+							s_vDSGrid[wPos + j * DRAGON_SOUL_BOX_COLUMN_NUM] = wPos + 1;
+						}
+						bExistEmptySpace = true;
+						break;
+					}
+				}
+				if (bExistEmptySpace)
+					break;
+			}
+			if (!bExistEmptySpace)
+				return false;
+		}
+		else
+#endif
+		{
+			int iPos;
+
+			if ((iPos = s_grid1.FindBlank(1, item->GetSize())) >= 0)
+				s_grid1.Put(iPos, 1, item->GetSize());
+			else if ((iPos = s_grid2.FindBlank(1, item->GetSize())) >= 0)
+				s_grid2.Put(iPos, 1, item->GetSize());
+#if defined(__EXTEND_INVEN_SYSTEM__)
+			else if ((iPos = s_grid3.FindBlank(1, item->GetSize())) >= 0)
+			{
+				int iExtendMaxPos = (INVENTORY_WIDTH * victim->GetExtendInvenStage()) - 1;
+				if (iPos > iExtendMaxPos)
+					return false;
+
+				if (item->GetSize() > 1)
+				{
+					iExtendMaxPos -= (INVENTORY_WIDTH * (item->GetSize() - 1));
+					if (iPos > iExtendMaxPos)
+						return false;
+				}
+				s_grid3.Put(iPos, 1, item->GetSize());
+			}
+			else if ((iPos = s_grid4.FindBlank(1, item->GetSize())) >= 0)
+			{
+				int iExtendMaxPos = (INVENTORY_WIDTH * (victim->GetExtendInvenStage() - INVENTORY_HEIGHT)) - 1;
+				if (iPos > iExtendMaxPos)
+					return false;
+
+				if (item->GetSize() > 1)
+				{
+					iExtendMaxPos -= (INVENTORY_WIDTH * (item->GetSize() - 1));
+					if (iPos > iExtendMaxPos)
+						return false;
+				}
+				s_grid4.Put(iPos, 1, item->GetSize());
+			}
+#endif
+			else
+				return false; // No space left in inventory
+		}
+	}
+
+	return true;
+}
+
+// 환  (方    킥)
+bool CExchange::Done()
+{
+	int empty_pos, i;
+	LPITEM item;
+
+	LPCHARACTER victim = GetCompany()->GetOwner();
+
+#if defined(__CHEQUE_SYSTEM__)
+	if (m_lCheque)
+	{
+		long vic_cheque = victim->GetCheque() + m_lCheque;
+		if (vic_cheque > CHEQUE_MAX)
+		{
+			// exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The has reached cheque limit."));
+			return false;
+		}
+	}
+#endif
+
+	for (i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		if (!(item = m_apItems[i]))
+			continue;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+			empty_pos = victim->GetEmptyDragonSoulInventory(item);
+		else
+#endif
+			empty_pos = victim->GetEmptyInventory(item->GetSize());
+
+		if (empty_pos < 0)
+		{
+			sys_err("Exchange::Done : Cannot find blank position in inventory %s <-> %s item %s",
+				m_pOwner->GetName(), victim->GetName(), item->GetName());
+			continue;
+		}
+
+		if (empty_pos < 0)
+		{
+			sys_err("Exchange::Done : Cannot find blank position in inventory %s <-> %s item %s",
+					m_pOwner->GetName(), victim->GetName(), item->GetName());
+			continue;
+		}
+
+		assert(empty_pos >= 0);
+
+		m_pOwner->SyncQuickslot(SLOT_TYPE_INVENTORY, item->GetCell(), WORD_MAX);
+
+#ifdef __GROWTH_PET_SYSTEM__
+		if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
+		{
+			LPGROWTH_PET pkPet = item->GetOwner()->GetGrowthPet(item->GetSocket(2));
+			if (pkPet)
+			{
+				// Remove from previous owner
+				item->GetOwner()->DeleteGrowthPet(item->GetSocket(2));
+
+				// Add to the new owner
+				victim->SetGrowthPet(pkPet);
+				pkPet->Save();
+			}
+		}
+#endif
+
+		item->RemoveFromCharacter();
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+			item->AddToCharacter(victim, TItemPos(DRAGON_SOUL_INVENTORY, empty_pos));
+		else
+#endif
+			item->AddToCharacter(victim, TItemPos(INVENTORY, empty_pos));
+		ITEM_MANAGER::instance().FlushDelayedSave(item);
+
+		item->SetExchanging(false);
+		{
+			char exchange_buf[51];
+
+			snprintf(exchange_buf, sizeof(exchange_buf), "%s %u %u", item->GetName(), GetOwner()->GetPlayerID(), item->GetCount());
+			LogManager::instance().ItemLog(victim, item, "EXCHANGE_TAKE", exchange_buf);
+
+			snprintf(exchange_buf, sizeof(exchange_buf), "%s %u %u", item->GetName(), victim->GetPlayerID(), item->GetCount());
+			LogManager::instance().ItemLog(GetOwner(), item, "EXCHANGE_GIVE", exchange_buf);
+
+			if (item->GetVnum() >= 80003 && item->GetVnum() <= 80007)
+			{
+				LogManager::instance().GoldBarLog(victim->GetPlayerID(), item->GetID(), EXCHANGE_TAKE, "");
+				LogManager::instance().GoldBarLog(GetOwner()->GetPlayerID(), item->GetID(), EXCHANGE_GIVE, "");
+			}
+
+			m_pOwner->CreateFly(FLY_SP_MEDIUM, victim);
+			for (int i = 0; i < 3; i++)
+				m_pOwner->CreateFly(FLY_SP_SMALL, victim);
+		}
+
+		m_apItems[i] = NULL;
+	}
+
+	if (m_lGold)
+	{
+		GetOwner()->PointChange(POINT_GOLD, -m_lGold, true);
+		victim->PointChange(POINT_GOLD, m_lGold, true);
+
+		if (m_lGold > 1000)
+		{
+			char exchange_buf[51];
+			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", GetOwner()->GetPlayerID(), GetOwner()->GetName());
+			LogManager::instance().CharLog(victim, m_lGold, "EXCHANGE_GOLD_TAKE", exchange_buf);
+
+			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", victim->GetPlayerID(), victim->GetName());
+			LogManager::instance().CharLog(GetOwner(), m_lGold, "EXCHANGE_GOLD_GIVE", exchange_buf);
+		}
+	}
+
+#if defined(__CHEQUE_SYSTEM__)
+	if (m_lCheque)
+	{
+		GetOwner()->PointChange(POINT_CHEQUE, -m_lCheque, true);
+		victim->PointChange(POINT_CHEQUE, m_lCheque, true);
+
+		if (m_lCheque > 1000)
+		{
+			char exchange_buf[51];
+			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", GetOwner()->GetPlayerID(), GetOwner()->GetName());
+			LogManager::instance().CharLog(victim, m_lCheque, "EXCHANGE_GOLD_TAKE", exchange_buf);
+
+			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", victim->GetPlayerID(), victim->GetName());
+			LogManager::instance().CharLog(GetOwner(), m_lCheque, "EXCHANGE_GOLD_GIVE", exchange_buf);
+		}
+	}
+#endif
+
+	m_pGrid->Clear();
+	return true;
+}
+
+// 환 
+bool CExchange::Accept(bool bAccept)
+{
+	if (m_bAccept == bAccept)
+		return true;
+
+	m_bAccept = bAccept;
+
+	//    퓐 환 
+	if (m_bAccept && GetCompany()->m_bAccept)
+	{
+		int iItemCount;
+
+		LPCHARACTER victim = GetCompany()->GetOwner();
+
+		// PREVENT_PORTAL_AFTER_EXCHANGE
+		GetOwner()->SetExchangeTime();
+		victim->SetExchangeTime();
+		// END_PREVENT_PORTAL_AFTER_EXCHANGE
+
+		if (GetOwner()->IsRunningQuest() || victim->IsRunningQuest())
+			goto EXCHANGE_END;
+	
+		// exchange_check  환 滂 美 簾 확構,
+		// 크  簾 확磯, 菅째 米 환  
+		//  磯.
+		if (!Check(&iItemCount))
+		{
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 構킬  美 求."));
+			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  構킬  美 求."));
+			goto EXCHANGE_END;
+		}
+
+		//      품  美 簾 확磯.
+		if (!CheckSpace())
+		{
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 품   求."));
+			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("품   求."));
+			goto EXCHANGE_END;
+		}
+
+		// 役 ..
+		if (!GetCompany()->Check(&iItemCount))
+		{
+			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 構킬  美 求."));
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  構킬  美 求."));
+			goto EXCHANGE_END;
+		}
+
+		if (!GetCompany()->CheckSpace())
+		{
+			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 품   求."));
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("품   求."));
+			goto EXCHANGE_END;
+		}
+
+		if (db_clientdesc->GetSocket() == INVALID_SOCKET)
+		{
+			sys_err("Cannot use exchange feature while DB cache connection is dead.");
+			victim->ChatPacket(CHAT_TYPE_INFO, "Unknown error");
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, "Unknown error");
+			goto EXCHANGE_END;
+		}
+
+		if (Done())
+		{
+			if (m_lGold) //    
+				GetOwner()->Save();
+
+#if defined(__CHEQUE_SYSTEM__)
+			if (m_lCheque)
+				GetOwner()->Save();
+#endif
+
+			if (GetCompany()->Done())
+			{
+				if (GetCompany()->m_lGold) //    
+					victim->Save();
+
+#if defined(__CHEQUE_SYSTEM__)
+				if (GetCompany()->m_lCheque)
+					victim->Save();
+#endif
+
+				// INTERNATIONAL_VERSION
+				GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 蹈 환  퓸求.", victim->GetName()));
+				victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 蹈 환  퓸求.", GetOwner()->GetName()));
+				// END_OF_INTERNATIONAL_VERSION
+			}
+		}
+
+	EXCHANGE_END:
+		Cancel();
+		return false;
+	}
+	else
+	{
+		// 틈玖 accept  킷 .
+		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_ACCEPT, true, m_bAccept, NPOS, 0);
+		exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_ACCEPT, false, m_bAccept, NPOS, 0);
+		return true;
+	}
+}
+
+// 환 
+void CExchange::Cancel()
+{
+	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_END, 0, 0, NPOS, 0);
+	GetOwner()->SetExchange(NULL);
+
+	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		if (m_apItems[i])
+			m_apItems[i]->SetExchanging(false);
+	}
+
+	if (GetCompany())
+	{
+		GetCompany()->SetCompany(NULL);
+		GetCompany()->Cancel();
+	}
+
+	M2_DELETE(this);
+}
diff --git a/server/server/home/metin2/Source/Server/game/src/input.h b/server/server/home/metin2/Source/Server/game/src/input.h
index 576da8c..e09fd30 100644
--- a/server/server/home/metin2/Source/Server/game/src/input.h
+++ b/server/server/home/metin2/Source/Server/game/src/input.h
@@ -1,570 +1,570 @@
-#ifndef __INC_INPUT_PROCESSOR_H__
-#define __INC_INPUT_PROCESSOR_H__
-
-#include "packet_info.h"
-
-enum
-{
-	INPROC_CLOSE,
-	INPROC_HANDSHAKE,
-	INPROC_LOGIN,
-	INPROC_MAIN,
-	INPROC_DEAD,
-	INPROC_DB,
-	INPROC_UDP,
-	INPROC_P2P,
-	INPROC_AUTH,
-};
-
-void LoginFailure(LPDESC d, const char* c_pszStatus);
-
-class CInputProcessor
-{
-public:
-	CInputProcessor();
-	virtual ~CInputProcessor() {};
-
-	virtual bool Process(LPDESC d, const void* c_pvOrig, int iBytes, int& r_iBytesProceed);
-	virtual BYTE GetType() = 0;
-
-	void BindPacketInfo(CPacketInfo* pPacketInfo);
-	void Pong(LPDESC d);
-	void Handshake(LPDESC d, const char* c_pData);
-	void Version(LPCHARACTER ch, const char* c_pData);
-
-protected:
-	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData) = 0;
-
-	CPacketInfo* m_pPacketInfo;
-	int m_iBufferLeft;
-
-	CPacketInfoCG m_packetInfoCG;
-};
-
-class CInputClose : public CInputProcessor
-{
-public:
-	virtual BYTE GetType() { return INPROC_CLOSE; }
-
-protected:
-	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData) { return m_iBufferLeft; }
-};
-
-class CInputHandshake : public CInputProcessor
-{
-public:
-	CInputHandshake();
-	virtual ~CInputHandshake();
-
-	virtual BYTE GetType() { return INPROC_HANDSHAKE; }
-
-protected:
-	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
-
-protected:
-	void GuildMarkLogin(LPDESC d, const char* c_pData);
-
-	CPacketInfo* m_pMainPacketInfo;
-};
-
-class CInputLogin : public CInputProcessor
-{
-public:
-	virtual BYTE GetType() { return INPROC_LOGIN; }
-
-protected:
-	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
-
-protected:
-	void Login(LPDESC d, const char* data);
-	void LoginByKey(LPDESC d, const char* data);
-
-	void CharacterSelect(LPDESC d, const char* data);
-	void CharacterCreate(LPDESC d, const char* data);
-	void CharacterDelete(LPDESC d, const char* data);
-
-	void Entergame(LPDESC d, const char* data);
-	void Empire(LPDESC d, const char* c_pData);
-	void GuildMarkCRCList(LPDESC d, const char* c_pData);
-	// MARK_BUG_FIX
-	void GuildMarkIDXList(LPDESC d, const char* c_pData);
-	// END_OF_MARK_BUG_FIX
-	void GuildMarkUpload(LPDESC d, const char* c_pData);
-	int GuildSymbolUpload(LPDESC d, const char* c_pData, size_t uiBytes);
-	void GuildSymbolCRC(LPDESC d, const char* c_pData);
-	void ChangeName(LPDESC d, const char* data);
-};
-
-class CInputMain : public CInputProcessor
-{
-public:
-	virtual BYTE GetType() { return INPROC_MAIN; }
-
-protected:
-	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
-
-protected:
-	void Attack(LPCHARACTER ch, const BYTE header, const char* data);
-
-	int Whisper(LPCHARACTER ch, const char* data, size_t uiBytes);
-	int Chat(LPCHARACTER ch, const char* data, size_t uiBytes);
-	void ItemUse(LPCHARACTER ch, const char* data);
-	void ItemDrop(LPCHARACTER ch, const char* data);
-	void ItemDrop2(LPCHARACTER ch, const char* data);
-#if defined(__NEW_DROP_DIALOG__)
-	void ItemDestroy(LPCHARACTER ch, const char* data);
-#endif
-	void ItemMove(LPCHARACTER ch, const char* data);
-	void ItemPickup(LPCHARACTER ch, const char* data);
-	void ItemToItem(LPCHARACTER ch, const char* pcData);
-	void QuickslotAdd(LPCHARACTER ch, const char* data);
-	void QuickslotDelete(LPCHARACTER ch, const char* data);
-	void QuickslotSwap(LPCHARACTER ch, const char* data);
-	int Shop(LPCHARACTER ch, const char* data, size_t uiBytes);
-	void OnClick(LPCHARACTER ch, const char* data);
-	void Exchange(LPCHARACTER ch, const char* data);
-	void Position(LPCHARACTER ch, const char* data);
-	void Move(LPCHARACTER ch, const char* data);
-	int SyncPosition(LPCHARACTER ch, const char* data, size_t uiBytes);
-	void FlyTarget(LPCHARACTER ch, const char* pcData, BYTE bHeader);
-	void UseSkill(LPCHARACTER ch, const char* pcData);
-
-	void ScriptAnswer(LPCHARACTER ch, const void* pvData);
-	void ScriptButton(LPCHARACTER ch, const void* pvData);
-	void ScriptSelectItem(LPCHARACTER ch, const void* pvData);
-#if defined(__GEM_SYSTEM__)
-	void SelectItemEx(LPCHARACTER c_lpCh, const void* c_pvData);
-#endif
-#if defined(__QUEST_REQUEST_EVENT__)
-	void RequestEventQuest(LPCHARACTER pChar, const void* c_pvData);
-#endif
-
-	void QuestInputString(LPCHARACTER ch, const void* pvData);
-#if defined(__OX_RENEWAL__)
-	void QuestInputLongString(LPCHARACTER ch, const void* pvData);
-#endif
-	void QuestConfirm(LPCHARACTER ch, const void* pvData);
-	void Target(LPCHARACTER ch, const char* pcData);
-	void Warp(LPCHARACTER ch, const char* pcData);
-	void SafeboxCheckin(LPCHARACTER ch, const char* c_pData);
-	void SafeboxCheckout(LPCHARACTER ch, const char* c_pData, bool bMall);
-	void SafeboxItemMove(LPCHARACTER ch, const char* data);
-	int Messenger(const LPCHARACTER c_lpChar, const char* c_pData, std::size_t uiBytes);
-
-	void PartyInvite(LPCHARACTER ch, const char* c_pData);
-	void PartyInviteAnswer(LPCHARACTER ch, const char* c_pData);
-	void PartyRemove(LPCHARACTER ch, const char* c_pData);
-	void PartySetState(LPCHARACTER ch, const char* c_pData);
-	void PartyUseSkill(LPCHARACTER ch, const char* c_pData);
-	void PartyParameter(LPCHARACTER ch, const char* c_pData);
-
-	int Guild(LPCHARACTER ch, const char* data, size_t uiBytes);
-	void AnswerMakeGuild(LPCHARACTER ch, const char* c_pData);
-
-	void Fishing(LPCHARACTER ch, const char* c_pData);
-
-#if defined(__FISHING_GAME__)
-	// Fishing Game
-	void FishingGame(const LPCHARACTER c_lpChar, const char* c_pszData);
-#endif
-
-	void ItemGive(LPCHARACTER ch, const char* c_pData);
-	void Hack(LPCHARACTER ch, const char* c_pData);
-	int MyShop(LPCHARACTER ch, const char* c_pData, size_t uiBytes);
-
-#if defined(__MYSHOP_DECO__)
-	void MyShopDecoState(LPCHARACTER ch, const char* c_pData);
-	void MyShopDecoAdd(LPCHARACTER ch, const char* c_pData);
-#endif
-
-	void Refine(LPCHARACTER ch, const char* c_pData);
-
-#ifdef __GROWTH_PET_SYSTEM__
-	void PetHatch(LPCHARACTER ch, const char* c_pData);
-	void PetWindow(LPCHARACTER ch, const char* c_pData);
-	void PetWindowType(LPCHARACTER ch, const char* c_pData);
-	void PetFeed(LPCHARACTER ch, const char* c_pData);
-	void PetDetermine(LPCHARACTER ch, const char* c_pData);
-	void PetAttrChange(LPCHARACTER ch, const char* c_pData);
-	void PetRevive(LPCHARACTER ch, const char* c_pData);
-	void PetLearnSkill(LPCHARACTER ch, const char* c_pData);
-	void PetSkillUpgrade(LPCHARACTER ch, const char* c_pData);
-	void PetDeleteSkill(LPCHARACTER ch, const char* c_pData);
-	void PetDeleteAllSkill(LPCHARACTER ch, const char* c_pData);
-	void PetNameChange(LPCHARACTER ch, const char* c_pData);
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	int ReciveExtBattlePassActions(LPCHARACTER ch, const char* data, size_t uiBytes);
-	int ReciveExtBattlePassPremiumItem(LPCHARACTER ch, const char* data, size_t uiBytes);
-#endif
-
-#if defined(__CUBE_RENEWAL__)
-	// Cube
-	void Cube(const LPCHARACTER pChar, const char* pData);
-#endif
-
-#if defined(__SEND_TARGET_INFO__)
-	void TargetInfo(LPCHARACTER pChar, const char* c_pszData);
-#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-	// Item Combination
-	void ItemCombination(LPCHARACTER ch, const char* c_pData);
-	void ItemCombinationCancel(LPCHARACTER ch, const char* c_pData);
-#endif
-
-#if defined(__CHANGED_ATTR__)
-	// Select Attribute
-	void ItemSelectAttr(LPCHARACTER ch, const char* c_pData);
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	// Acce Refine
-	int AcceRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes);
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-	// Aura Refine
-	int AuraRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes);
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	// Change Look
-	void ChangeLook(LPCHARACTER lpCh, const char* c_pszData);
-#endif
-
-#if defined(__SKILLBOOK_COMB_SYSTEM__)
-	// Skill Book Combination
-	bool SkillBookCombination(LPCHARACTER ch, TItemPos(&CombItemGrid)[SKILLBOOK_COMB_SLOT_MAX], BYTE bAction);
-#endif
-
-#if defined(__MAILBOX__)
-	// Mail Box
-	void MailboxWrite(LPCHARACTER ch, const char* data);
-	void MailboxConfirm(LPCHARACTER ch, const char* data);
-	void MailboxProcess(LPCHARACTER ch, const char* c_pData);
-#endif
-
-#ifdef __SHOP_SEARCH__
-	void ShopSearchByName(LPCHARACTER ch, const char* data);
-	int ShopSearchByOptions(LPCHARACTER ch, const char* data, size_t uiBytes);
-	void ShopSearchBuy(LPCHARACTER ch, const char* data);
-	void ShopSearchOwnerMessage(LPCHARACTER ch, const char* data);
-	void ShopSearchRequestSoldInfo(LPCHARACTER ch, const char* data);
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-	// Loot Filter
-	void LootFilter(LPCHARACTER ch, const char* c_pData);
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-	// Mini-Game Rumi
-	void MiniGameRumi(LPCHARACTER pChar, const char* pszData);
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__)
-	// Mini-Game Yutnori
-	void MiniGameYutnori(LPCHARACTER pChar, const char* pszData);
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-	// 6th and 7th Attribute
-	void Attr67Add(LPCHARACTER ch, const char* c_pData);
-#endif
-
-#if defined(__LUCKY_BOX__)
-	// Lucky Box
-	void LuckyBox(LPCHARACTER ch, const char* c_pData);
-#endif
-
-#if defined(__GEM_SHOP__)
-	// Gem Shop
-	void GemShop(LPCHARACTER c_lpCh, const char* c_pszData);
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	// Extend Inven
-	void ExtendInven(LPCHARACTER pChar, const char* c_pszData);
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-	// Snowflake Stick Event
-	void SnowflakeStickEvent(LPCHARACTER pChar, const char* c_pszData);
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	// Refine Element
-	void RefineElement(LPCHARACTER pChar, const char* c_pszData);
-#endif
-
-#if defined(__LEFT_SEAT__)
-	// Left Seat
-	void LeftSeat(LPCHARACTER pChar, const char* c_pszData);
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	// Mini-Game Roulette (Late Summer Event)
-	void MiniGameRoulette(LPCHARACTER pChar, const char* pszData);
-#endif
-
-#if defined(__FLOWER_EVENT__)
-	// Flower Event
-	void FlowerEvent(LPCHARACTER pChar, const char* pszData);
-#endif
-};
-
-class CInputDead : public CInputMain
-{
-public:
-	virtual BYTE GetType() { return INPROC_DEAD; }
-
-protected:
-	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
-};
-
-class CInputDB : public CInputProcessor
-{
-public:
-	virtual bool Process(LPDESC d, const void* c_pvOrig, int iBytes, int& r_iBytesProceed);
-	virtual BYTE GetType() { return INPROC_DB; }
-
-protected:
-	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
-
-protected:
-	void MapLocations(const char* c_pData);
-	void LoginSuccess(DWORD dwHandle, const char* data);
-	void PlayerCreateFailure(LPDESC d, BYTE bType); // 0 = 일반 실패 1 = 이미 있음
-	void PlayerDeleteSuccess(LPDESC d, const char* data);
-	void PlayerDeleteFail(LPDESC d
-#if defined(__DELETE_FAILURE_TYPE__)
-		, const char* c_pszData
-#endif
-	);
-	void PlayerLoad(LPDESC d, const char* data);
-	void PlayerCreateSuccess(LPDESC d, const char* data);
-	void Boot(const char* data);
-	void QuestLoad(LPDESC d, const char* c_pData);
-	void SafeboxLoad(LPDESC d, const char* c_pData);
-	void SafeboxChangeSize(LPDESC d, const char* c_pData);
-	void SafeboxWrongPassword(LPDESC d);
-	void SafeboxChangePasswordAnswer(LPDESC d, const char* c_pData);
-	void MallLoad(LPDESC d, const char* c_pData);
-	void EmpireSelect(LPDESC d, const char* c_pData);
-	void P2P(const char* c_pData);
-	void ItemLoad(LPDESC d, const char* c_pData);
-	void AffectLoad(LPDESC d, const char* c_pData);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	void ExtBattlePassLoad(LPDESC d, const char* c_pData);
-#endif
-
-	void GuildLoad(const char* c_pData);
-	void GuildSkillUpdate(const char* c_pData);
-	void GuildSkillRecharge();
-	void GuildExpUpdate(const char* c_pData);
-	void GuildAddMember(const char* c_pData);
-	void GuildRemoveMember(const char* c_pData);
-	void GuildChangeGrade(const char* c_pData);
-	void GuildChangeMemberData(const char* c_pData);
-	void GuildDisband(const char* c_pData);
-	void GuildLadder(const char* c_pData);
-	void GuildWar(const char* c_pData);
-	void GuildWarScore(const char* c_pData);
-	void GuildSkillUsableChange(const char* c_pData);
-	void GuildMoneyChange(const char* c_pData);
-	void GuildWithdrawMoney(const char* c_pData);
-	void GuildWarReserveAdd(TGuildWarReserve* p);
-	void GuildWarReserveUpdate(TGuildWarReserve* p);
-	void GuildWarReserveDelete(DWORD dwID);
-	void GuildWarBet(TPacketGDGuildWarBet* p);
-	void GuildChangeMaster(TPacketChangeGuildMaster* p);
-
-	void LoginAlready(LPDESC d, const char* c_pData);
-
-	void PartyCreate(const char* c_pData);
-	void PartyDelete(const char* c_pData);
-	void PartyAdd(const char* c_pData);
-	void PartyRemove(const char* c_pData);
-	void PartyStateChange(const char* c_pData);
-	void PartySetMemberLevel(const char* c_pData);
-
-	void Time(const char* c_pData);
-
-	void ReloadProto(const char* c_pData);
-	void ChangeName(LPDESC d, const char* data);
-
-	void AuthLogin(LPDESC d, const char* c_pData);
-	void ItemAward(const char* c_pData);
-
-	void ChangeEmpirePriv(const char* c_pData);
-	void ChangeGuildPriv(const char* c_pData);
-	void ChangeCharacterPriv(const char* c_pData);
-
-	void MoneyLog(const char* c_pData);
-
-	void SetEventFlag(const char* c_pData);
-
-	void CreateObject(const char* c_pData);
-	void DeleteObject(const char* c_pData);
-	void UpdateLand(const char* c_pData);
-
-	void Notice(const char* c_pData);
-
-	void MarriageAdd(TPacketMarriageAdd* p);
-	void MarriageUpdate(TPacketMarriageUpdate* p);
-	void MarriageRemove(TPacketMarriageRemove* p);
-
-	void WeddingRequest(TPacketWeddingRequest* p);
-	void WeddingReady(TPacketWeddingReady* p);
-	void WeddingStart(TPacketWeddingStart* p);
-	void WeddingEnd(TPacketWeddingEnd* p);
-
-	void TakeMonarchMoney(LPDESC d, const char* data);
-	void AddMonarchMoney(LPDESC d, const char* data);
-	void DecMonarchMoney(LPDESC d, const char* data);
-	void SetMonarch(LPDESC d, const char* data);
-
-	void ChangeMonarchLord(TPacketChangeMonarchLordACK* data);
-	void UpdateMonarchInfo(TMonarchInfo* data);
-	void AddBlockCountryIp(TPacketBlockCountryIp* data);
-	void BlockException(TPacketBlockException* data);
-
-	// MYSHOP_PRICE_LIST
-	/// 아이템 가격정보 리스트 요청에 대한 응답 패킷(HEADER_DG_MYSHOP_PRICELIST_RES) 처리함수
-	/**
-	* @param d 아이템 가격정보 리스트를 요청한 플레이어의 descriptor
-	* @param p 패킷데이터의 포인터
-	*/
-	void MyshopPricelistRes(LPDESC d, const TPacketMyshopPricelistHeader* p);
-	// END_OF_MYSHOP_PRICE_LIST
-
-	//RELOAD_ADMIN
-	void ReloadAdmin(const char* c_pData);
-	//END_RELOAD_ADMIN
-
-	void DetailLog(const TPacketNeedLoginLogInfo* info);
-	// 독일 선물 기능 테스트
-	void ItemAwardInformer(TPacketItemAwardInfromer* data);
-
-	void RespondChannelStatus(LPDESC desc, const char* pcData);
-
-#if defined(__MOVE_CHANNEL__)
-	void MoveChannel(LPDESC desc, const char* pcData);
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	// Emotions
-	void EmoteLoad(LPDESC pDesc, const char* c_pData);
-	void EmoteGet(LPDESC pDesc, const char* c_pData);
-#endif
-
-#if defined(__MAILBOX__)
-	void MailBoxRespondLoad(LPDESC d, const char* c_pData);
-	void MailBoxRespondName(LPDESC d, const char* c_pData);
-	void MailBoxRespondUnreadData(LPDESC d, const char* c_pData);
-#endif
-
-#if defined(__GEM_SHOP__)
-	// Gem Shop
-	void GemShopLoad(LPDESC lpDesc, const char* c_pszData);
-	void GemShopUpdate(LPDESC lpDesc, const char* c_pszData);
-#endif
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	void GuildSetEventFlag(const char* c_pData);
-#endif
-#ifdef __OFFLINE_SHOP__
-	void RespondOfflineShopId(const char* data);
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-	void GrowthPetLoad(LPDESC d, const char* c_pData);
-#endif
-
-protected:
-	DWORD m_dwHandle;
-};
-
-class CInputUDP : public CInputProcessor
-{
-public:
-	CInputUDP();
-	virtual bool Process(LPDESC d, const void* c_pvOrig, int iBytes, int& r_iBytesProceed);
-
-	virtual BYTE GetType() { return INPROC_UDP; }
-	void SetSockAddr(struct sockaddr_in& rSockAddr) { m_SockAddr = rSockAddr; };
-
-protected:
-	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
-
-protected:
-	void Handshake(LPDESC lpDesc, const char* c_pData);
-	void StateChecker(const char* c_pData);
-
-protected:
-	struct sockaddr_in m_SockAddr;
-	CPacketInfoUDP m_packetInfoUDP;
-};
-
-class CInputP2P : public CInputProcessor
-{
-public:
-	CInputP2P();
-	virtual BYTE GetType() { return INPROC_P2P; }
-
-protected:
-	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
-
-public:
-	void Setup(LPDESC d, const char* c_pData);
-	void Login(LPDESC d, const char* c_pData);
-	void Logout(LPDESC d, const char* c_pData);
-	int Relay(LPDESC d, const char* c_pData, size_t uiBytes);
-	int Notice(LPDESC d, const char* c_pData, size_t uiBytes);
-	int MonarchNotice(LPDESC d, const char* c_pData, size_t uiBytes);
-	int MonarchTransfer(LPDESC d, const char* c_pData);
-	int Guild(LPDESC d, const char* c_pData, size_t uiBytes);
-	void Shout(const char* c_pData);
-	void Disconnect(const char* c_pData);
-	void MessengerAdd(const char* c_pData);
-	void MessengerRemove(const char* c_pData);
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	void MessengerBlockAdd(const char* c_pData);
-	void MessengerBlockRemove(const char* c_pData);
-#endif
-	void FindPosition(LPDESC d, const char* c_pData);
-	void WarpCharacter(const char* c_pData);
-	void GuildWarZoneMapIndex(const char* c_pData);
-	void Transfer(const char* c_pData);
-#if defined(__XMAS_EVENT_2008__)
-	void XmasWarpSanta(const char* c_pData);
-	void XmasWarpSantaReply(const char* c_pData);
-#endif
-	void LoginPing(LPDESC d, const char* c_pData);
-	void BlockChat(const char* c_pData);
-	void PCBangUpdate(const char* c_pData);
-	void IamAwake(LPDESC d, const char* c_pData);
-#ifdef __OFFLINE_SHOP__
-	void UpdateSellHistory(LPDESC d, const char* c_pData);
-#endif
-
-protected:
-	CPacketInfoGG m_packetInfoGG;
-};
-
-class CInputAuth : public CInputProcessor
-{
-public:
-	CInputAuth();
-	virtual BYTE GetType() { return INPROC_AUTH; }
-
-protected:
-	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
-
-public:
-	void Login(LPDESC d, const char* c_pData);
-
-};
-#endif // __INC_INPUT_PROCESSOR_H__
+#ifndef __INC_INPUT_PROCESSOR_H__
+#define __INC_INPUT_PROCESSOR_H__
+
+#include "packet_info.h"
+
+enum
+{
+	INPROC_CLOSE,
+	INPROC_HANDSHAKE,
+	INPROC_LOGIN,
+	INPROC_MAIN,
+	INPROC_DEAD,
+	INPROC_DB,
+	INPROC_UDP,
+	INPROC_P2P,
+	INPROC_AUTH,
+};
+
+void LoginFailure(LPDESC d, const char* c_pszStatus);
+
+class CInputProcessor
+{
+public:
+	CInputProcessor();
+	virtual ~CInputProcessor() {};
+
+	virtual bool Process(LPDESC d, const void* c_pvOrig, int iBytes, int& r_iBytesProceed);
+	virtual BYTE GetType() = 0;
+
+	void BindPacketInfo(CPacketInfo* pPacketInfo);
+	void Pong(LPDESC d);
+	void Handshake(LPDESC d, const char* c_pData);
+	void Version(LPCHARACTER ch, const char* c_pData);
+
+protected:
+	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData) = 0;
+
+	CPacketInfo* m_pPacketInfo;
+	int m_iBufferLeft;
+
+	CPacketInfoCG m_packetInfoCG;
+};
+
+class CInputClose : public CInputProcessor
+{
+public:
+	virtual BYTE GetType() { return INPROC_CLOSE; }
+
+protected:
+	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData) { return m_iBufferLeft; }
+};
+
+class CInputHandshake : public CInputProcessor
+{
+public:
+	CInputHandshake();
+	virtual ~CInputHandshake();
+
+	virtual BYTE GetType() { return INPROC_HANDSHAKE; }
+
+protected:
+	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
+
+protected:
+	void GuildMarkLogin(LPDESC d, const char* c_pData);
+
+	CPacketInfo* m_pMainPacketInfo;
+};
+
+class CInputLogin : public CInputProcessor
+{
+public:
+	virtual BYTE GetType() { return INPROC_LOGIN; }
+
+protected:
+	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
+
+protected:
+	void Login(LPDESC d, const char* data);
+	void LoginByKey(LPDESC d, const char* data);
+
+	void CharacterSelect(LPDESC d, const char* data);
+	void CharacterCreate(LPDESC d, const char* data);
+	void CharacterDelete(LPDESC d, const char* data);
+
+	void Entergame(LPDESC d, const char* data);
+	void Empire(LPDESC d, const char* c_pData);
+	void GuildMarkCRCList(LPDESC d, const char* c_pData);
+	// MARK_BUG_FIX
+	void GuildMarkIDXList(LPDESC d, const char* c_pData);
+	// END_OF_MARK_BUG_FIX
+	void GuildMarkUpload(LPDESC d, const char* c_pData);
+	int GuildSymbolUpload(LPDESC d, const char* c_pData, size_t uiBytes);
+	void GuildSymbolCRC(LPDESC d, const char* c_pData);
+	void ChangeName(LPDESC d, const char* data);
+};
+
+class CInputMain : public CInputProcessor
+{
+public:
+	virtual BYTE GetType() { return INPROC_MAIN; }
+
+protected:
+	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
+
+protected:
+	void Attack(LPCHARACTER ch, const BYTE header, const char* data);
+
+	int Whisper(LPCHARACTER ch, const char* data, size_t uiBytes);
+	int Chat(LPCHARACTER ch, const char* data, size_t uiBytes);
+	void ItemUse(LPCHARACTER ch, const char* data);
+	void ItemDrop(LPCHARACTER ch, const char* data);
+	void ItemDrop2(LPCHARACTER ch, const char* data);
+#if defined(__NEW_DROP_DIALOG__)
+	void ItemDestroy(LPCHARACTER ch, const char* data);
+#endif
+	void ItemMove(LPCHARACTER ch, const char* data);
+	void ItemPickup(LPCHARACTER ch, const char* data);
+	void ItemToItem(LPCHARACTER ch, const char* pcData);
+	void QuickslotAdd(LPCHARACTER ch, const char* data);
+	void QuickslotDelete(LPCHARACTER ch, const char* data);
+	void QuickslotSwap(LPCHARACTER ch, const char* data);
+	int Shop(LPCHARACTER ch, const char* data, size_t uiBytes);
+	void OnClick(LPCHARACTER ch, const char* data);
+	void Exchange(LPCHARACTER ch, const char* data);
+	void Position(LPCHARACTER ch, const char* data);
+	void Move(LPCHARACTER ch, const char* data);
+	int SyncPosition(LPCHARACTER ch, const char* data, size_t uiBytes);
+	void FlyTarget(LPCHARACTER ch, const char* pcData, BYTE bHeader);
+	void UseSkill(LPCHARACTER ch, const char* pcData);
+
+	void ScriptAnswer(LPCHARACTER ch, const void* pvData);
+	void ScriptButton(LPCHARACTER ch, const void* pvData);
+	void ScriptSelectItem(LPCHARACTER ch, const void* pvData);
+#if defined(__GEM_SYSTEM__)
+	void SelectItemEx(LPCHARACTER c_lpCh, const void* c_pvData);
+#endif
+#if defined(__QUEST_REQUEST_EVENT__)
+	void RequestEventQuest(LPCHARACTER pChar, const void* c_pvData);
+#endif
+
+	void QuestInputString(LPCHARACTER ch, const void* pvData);
+#if defined(__OX_RENEWAL__)
+	void QuestInputLongString(LPCHARACTER ch, const void* pvData);
+#endif
+	void QuestConfirm(LPCHARACTER ch, const void* pvData);
+	void Target(LPCHARACTER ch, const char* pcData);
+	void Warp(LPCHARACTER ch, const char* pcData);
+	void SafeboxCheckin(LPCHARACTER ch, const char* c_pData);
+	void SafeboxCheckout(LPCHARACTER ch, const char* c_pData, bool bMall);
+	void SafeboxItemMove(LPCHARACTER ch, const char* data);
+	int Messenger(const LPCHARACTER c_lpChar, const char* c_pData, std::size_t uiBytes);
+
+	void PartyInvite(LPCHARACTER ch, const char* c_pData);
+	void PartyInviteAnswer(LPCHARACTER ch, const char* c_pData);
+	void PartyRemove(LPCHARACTER ch, const char* c_pData);
+	void PartySetState(LPCHARACTER ch, const char* c_pData);
+	void PartyUseSkill(LPCHARACTER ch, const char* c_pData);
+	void PartyParameter(LPCHARACTER ch, const char* c_pData);
+
+	int Guild(LPCHARACTER ch, const char* data, size_t uiBytes);
+	void AnswerMakeGuild(LPCHARACTER ch, const char* c_pData);
+
+	void Fishing(LPCHARACTER ch, const char* c_pData);
+
+#if defined(__FISHING_GAME__)
+	// Fishing Game
+	void FishingGame(const LPCHARACTER c_lpChar, const char* c_pszData);
+#endif
+
+	void ItemGive(LPCHARACTER ch, const char* c_pData);
+	void Hack(LPCHARACTER ch, const char* c_pData);
+	int MyShop(LPCHARACTER ch, const char* c_pData, size_t uiBytes);
+
+#if defined(__MYSHOP_DECO__)
+	void MyShopDecoState(LPCHARACTER ch, const char* c_pData);
+	void MyShopDecoAdd(LPCHARACTER ch, const char* c_pData);
+#endif
+
+	void Refine(LPCHARACTER ch, const char* c_pData);
+
+#ifdef __GROWTH_PET_SYSTEM__
+	void		PetHatch(LPCHARACTER ch, const char* c_pData);
+	void		PetWindow(LPCHARACTER ch, const char* c_pData);
+	void		PetWindowType(LPCHARACTER ch, const char* c_pData);
+	void		PetFeed(LPCHARACTER ch, const char* c_pData);
+	void		PetDetermine(LPCHARACTER ch, const char* c_pData);
+	void		PetAttrChange(LPCHARACTER ch, const char* c_pData);
+	void		PetRevive(LPCHARACTER ch, const char* c_pData);
+	void		PetLearnSkill(LPCHARACTER ch, const char* c_pData);
+	void		PetSkillUpgrade(LPCHARACTER ch, const char* c_pData);
+	void		PetDeleteSkill(LPCHARACTER ch, const char* c_pData);
+	void		PetDeleteAllSkill(LPCHARACTER ch, const char* c_pData);
+	void		PetNameChange(LPCHARACTER ch, const char* c_pData);
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	int ReciveExtBattlePassActions(LPCHARACTER ch, const char* data, size_t uiBytes);
+	int ReciveExtBattlePassPremiumItem(LPCHARACTER ch, const char* data, size_t uiBytes);
+#endif
+
+#if defined(__CUBE_RENEWAL__)
+	// Cube
+	void Cube(const LPCHARACTER pChar, const char* pData);
+#endif
+
+#if defined(__SEND_TARGET_INFO__)
+	void TargetInfo(LPCHARACTER pChar, const char* c_pszData);
+#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+	// Item Combination
+	void ItemCombination(LPCHARACTER ch, const char* c_pData);
+	void ItemCombinationCancel(LPCHARACTER ch, const char* c_pData);
+#endif
+
+#if defined(__CHANGED_ATTR__)
+	// Select Attribute
+	void ItemSelectAttr(LPCHARACTER ch, const char* c_pData);
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	// Acce Refine
+	int AcceRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes);
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+	// Aura Refine
+	int AuraRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes);
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	// Change Look
+	void ChangeLook(LPCHARACTER lpCh, const char* c_pszData);
+#endif
+
+#if defined(__SKILLBOOK_COMB_SYSTEM__)
+	// Skill Book Combination
+	bool SkillBookCombination(LPCHARACTER ch, TItemPos(&CombItemGrid)[SKILLBOOK_COMB_SLOT_MAX], BYTE bAction);
+#endif
+
+#if defined(__MAILBOX__)
+	// Mail Box
+	void MailboxWrite(LPCHARACTER ch, const char* data);
+	void MailboxConfirm(LPCHARACTER ch, const char* data);
+	void MailboxProcess(LPCHARACTER ch, const char* c_pData);
+#endif
+
+#ifdef __SHOP_SEARCH__
+	void ShopSearchByName(LPCHARACTER ch, const char* data);
+	int ShopSearchByOptions(LPCHARACTER ch, const char* data, size_t uiBytes);
+	void ShopSearchBuy(LPCHARACTER ch, const char* data);
+	void ShopSearchOwnerMessage(LPCHARACTER ch, const char* data);
+	void ShopSearchRequestSoldInfo(LPCHARACTER ch, const char* data);
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+	// Loot Filter
+	void LootFilter(LPCHARACTER ch, const char* c_pData);
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+	// Mini-Game Rumi
+	void MiniGameRumi(LPCHARACTER pChar, const char* pszData);
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__)
+	// Mini-Game Yutnori
+	void MiniGameYutnori(LPCHARACTER pChar, const char* pszData);
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+	// 6th and 7th Attribute
+	void Attr67Add(LPCHARACTER ch, const char* c_pData);
+#endif
+
+#if defined(__LUCKY_BOX__)
+	// Lucky Box
+	void LuckyBox(LPCHARACTER ch, const char* c_pData);
+#endif
+
+#if defined(__GEM_SHOP__)
+	// Gem Shop
+	void GemShop(LPCHARACTER c_lpCh, const char* c_pszData);
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	// Extend Inven
+	void ExtendInven(LPCHARACTER pChar, const char* c_pszData);
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+	// Snowflake Stick Event
+	void SnowflakeStickEvent(LPCHARACTER pChar, const char* c_pszData);
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	// Refine Element
+	void RefineElement(LPCHARACTER pChar, const char* c_pszData);
+#endif
+
+#if defined(__LEFT_SEAT__)
+	// Left Seat
+	void LeftSeat(LPCHARACTER pChar, const char* c_pszData);
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	// Mini-Game Roulette (Late Summer Event)
+	void MiniGameRoulette(LPCHARACTER pChar, const char* pszData);
+#endif
+
+#if defined(__FLOWER_EVENT__)
+	// Flower Event
+	void FlowerEvent(LPCHARACTER pChar, const char* pszData);
+#endif
+};
+
+class CInputDead : public CInputMain
+{
+public:
+	virtual BYTE GetType() { return INPROC_DEAD; }
+
+protected:
+	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
+};
+
+class CInputDB : public CInputProcessor
+{
+public:
+	virtual bool Process(LPDESC d, const void* c_pvOrig, int iBytes, int& r_iBytesProceed);
+	virtual BYTE GetType() { return INPROC_DB; }
+
+protected:
+	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
+
+protected:
+	void MapLocations(const char* c_pData);
+	void LoginSuccess(DWORD dwHandle, const char* data);
+	void PlayerCreateFailure(LPDESC d, BYTE bType); // 0 = 球  1 = 譴 
+	void PlayerDeleteSuccess(LPDESC d, const char* data);
+	void PlayerDeleteFail(LPDESC d
+#if defined(__DELETE_FAILURE_TYPE__)
+		, const char* c_pszData
+#endif
+	);
+	void PlayerLoad(LPDESC d, const char* data);
+	void PlayerCreateSuccess(LPDESC d, const char* data);
+	void Boot(const char* data);
+	void QuestLoad(LPDESC d, const char* c_pData);
+	void SafeboxLoad(LPDESC d, const char* c_pData);
+	void SafeboxChangeSize(LPDESC d, const char* c_pData);
+	void SafeboxWrongPassword(LPDESC d);
+	void SafeboxChangePasswordAnswer(LPDESC d, const char* c_pData);
+	void MallLoad(LPDESC d, const char* c_pData);
+	void EmpireSelect(LPDESC d, const char* c_pData);
+	void P2P(const char* c_pData);
+	void ItemLoad(LPDESC d, const char* c_pData);
+	void AffectLoad(LPDESC d, const char* c_pData);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	void ExtBattlePassLoad(LPDESC d, const char* c_pData);
+#endif
+
+	void GuildLoad(const char* c_pData);
+	void GuildSkillUpdate(const char* c_pData);
+	void GuildSkillRecharge();
+	void GuildExpUpdate(const char* c_pData);
+	void GuildAddMember(const char* c_pData);
+	void GuildRemoveMember(const char* c_pData);
+	void GuildChangeGrade(const char* c_pData);
+	void GuildChangeMemberData(const char* c_pData);
+	void GuildDisband(const char* c_pData);
+	void GuildLadder(const char* c_pData);
+	void GuildWar(const char* c_pData);
+	void GuildWarScore(const char* c_pData);
+	void GuildSkillUsableChange(const char* c_pData);
+	void GuildMoneyChange(const char* c_pData);
+	void GuildWithdrawMoney(const char* c_pData);
+	void GuildWarReserveAdd(TGuildWarReserve* p);
+	void GuildWarReserveUpdate(TGuildWarReserve* p);
+	void GuildWarReserveDelete(DWORD dwID);
+	void GuildWarBet(TPacketGDGuildWarBet* p);
+	void GuildChangeMaster(TPacketChangeGuildMaster* p);
+
+	void LoginAlready(LPDESC d, const char* c_pData);
+
+	void PartyCreate(const char* c_pData);
+	void PartyDelete(const char* c_pData);
+	void PartyAdd(const char* c_pData);
+	void PartyRemove(const char* c_pData);
+	void PartyStateChange(const char* c_pData);
+	void PartySetMemberLevel(const char* c_pData);
+
+	void Time(const char* c_pData);
+
+	void ReloadProto(const char* c_pData);
+	void ChangeName(LPDESC d, const char* data);
+
+	void AuthLogin(LPDESC d, const char* c_pData);
+	void ItemAward(const char* c_pData);
+
+	void ChangeEmpirePriv(const char* c_pData);
+	void ChangeGuildPriv(const char* c_pData);
+	void ChangeCharacterPriv(const char* c_pData);
+
+	void MoneyLog(const char* c_pData);
+
+	void SetEventFlag(const char* c_pData);
+
+	void CreateObject(const char* c_pData);
+	void DeleteObject(const char* c_pData);
+	void UpdateLand(const char* c_pData);
+
+	void Notice(const char* c_pData);
+
+	void MarriageAdd(TPacketMarriageAdd* p);
+	void MarriageUpdate(TPacketMarriageUpdate* p);
+	void MarriageRemove(TPacketMarriageRemove* p);
+
+	void WeddingRequest(TPacketWeddingRequest* p);
+	void WeddingReady(TPacketWeddingReady* p);
+	void WeddingStart(TPacketWeddingStart* p);
+	void WeddingEnd(TPacketWeddingEnd* p);
+
+	void TakeMonarchMoney(LPDESC d, const char* data);
+	void AddMonarchMoney(LPDESC d, const char* data);
+	void DecMonarchMoney(LPDESC d, const char* data);
+	void SetMonarch(LPDESC d, const char* data);
+
+	void ChangeMonarchLord(TPacketChangeMonarchLordACK* data);
+	void UpdateMonarchInfo(TMonarchInfo* data);
+	void AddBlockCountryIp(TPacketBlockCountryIp* data);
+	void BlockException(TPacketBlockException* data);
+
+	// MYSHOP_PRICE_LIST
+	///   트 청   킷(HEADER_DG_MYSHOP_PRICELIST_RES) 처獨
+	/**
+	* @param d   트 청 첨潔 descriptor
+	* @param p 킷 
+	*/
+	void MyshopPricelistRes(LPDESC d, const TPacketMyshopPricelistHeader* p);
+	// END_OF_MYSHOP_PRICE_LIST
+
+	//RELOAD_ADMIN
+	void ReloadAdmin(const char* c_pData);
+	//END_RELOAD_ADMIN
+
+	void DetailLog(const TPacketNeedLoginLogInfo* info);
+	//    謬트
+	void ItemAwardInformer(TPacketItemAwardInfromer* data);
+
+	void RespondChannelStatus(LPDESC desc, const char* pcData);
+
+#if defined(__MOVE_CHANNEL__)
+	void MoveChannel(LPDESC desc, const char* pcData);
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	// Emotions
+	void EmoteLoad(LPDESC pDesc, const char* c_pData);
+	void EmoteGet(LPDESC pDesc, const char* c_pData);
+#endif
+
+#if defined(__MAILBOX__)
+	void MailBoxRespondLoad(LPDESC d, const char* c_pData);
+	void MailBoxRespondName(LPDESC d, const char* c_pData);
+	void MailBoxRespondUnreadData(LPDESC d, const char* c_pData);
+#endif
+
+#if defined(__GEM_SHOP__)
+	// Gem Shop
+	void GemShopLoad(LPDESC lpDesc, const char* c_pszData);
+	void GemShopUpdate(LPDESC lpDesc, const char* c_pszData);
+#endif
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	void GuildSetEventFlag(const char* c_pData);
+#endif
+#ifdef __OFFLINE_SHOP__
+	void RespondOfflineShopId(const char* data);
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+	void GrowthPetLoad(LPDESC d, const char* c_pData);
+#endif
+
+protected:
+	DWORD m_dwHandle;
+};
+
+class CInputUDP : public CInputProcessor
+{
+public:
+	CInputUDP();
+	virtual bool Process(LPDESC d, const void* c_pvOrig, int iBytes, int& r_iBytesProceed);
+
+	virtual BYTE GetType() { return INPROC_UDP; }
+	void SetSockAddr(struct sockaddr_in& rSockAddr) { m_SockAddr = rSockAddr; };
+
+protected:
+	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
+
+protected:
+	void Handshake(LPDESC lpDesc, const char* c_pData);
+	void StateChecker(const char* c_pData);
+
+protected:
+	struct sockaddr_in m_SockAddr;
+	CPacketInfoUDP m_packetInfoUDP;
+};
+
+class CInputP2P : public CInputProcessor
+{
+public:
+	CInputP2P();
+	virtual BYTE GetType() { return INPROC_P2P; }
+
+protected:
+	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
+
+public:
+	void Setup(LPDESC d, const char* c_pData);
+	void Login(LPDESC d, const char* c_pData);
+	void Logout(LPDESC d, const char* c_pData);
+	int Relay(LPDESC d, const char* c_pData, size_t uiBytes);
+	int Notice(LPDESC d, const char* c_pData, size_t uiBytes);
+	int MonarchNotice(LPDESC d, const char* c_pData, size_t uiBytes);
+	int MonarchTransfer(LPDESC d, const char* c_pData);
+	int Guild(LPDESC d, const char* c_pData, size_t uiBytes);
+	void Shout(const char* c_pData);
+	void Disconnect(const char* c_pData);
+	void MessengerAdd(const char* c_pData);
+	void MessengerRemove(const char* c_pData);
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	void MessengerBlockAdd(const char* c_pData);
+	void MessengerBlockRemove(const char* c_pData);
+#endif
+	void FindPosition(LPDESC d, const char* c_pData);
+	void WarpCharacter(const char* c_pData);
+	void GuildWarZoneMapIndex(const char* c_pData);
+	void Transfer(const char* c_pData);
+#if defined(__XMAS_EVENT_2008__)
+	void XmasWarpSanta(const char* c_pData);
+	void XmasWarpSantaReply(const char* c_pData);
+#endif
+	void LoginPing(LPDESC d, const char* c_pData);
+	void BlockChat(const char* c_pData);
+	void PCBangUpdate(const char* c_pData);
+	void IamAwake(LPDESC d, const char* c_pData);
+#ifdef __OFFLINE_SHOP__
+	void UpdateSellHistory(LPDESC d, const char* c_pData);
+#endif
+
+protected:
+	CPacketInfoGG m_packetInfoGG;
+};
+
+class CInputAuth : public CInputProcessor
+{
+public:
+	CInputAuth();
+	virtual BYTE GetType() { return INPROC_AUTH; }
+
+protected:
+	virtual int Analyze(LPDESC d, BYTE bHeader, const char* c_pData);
+
+public:
+	void Login(LPDESC d, const char* c_pData);
+
+};
+#endif // __INC_INPUT_PROCESSOR_H__
diff --git a/server/server/home/metin2/Source/Server/game/src/input_db.cpp b/server/server/home/metin2/Source/Server/game/src/input_db.cpp
index b65bccb..fcc697b 100644
--- a/server/server/home/metin2/Source/Server/game/src/input_db.cpp
+++ b/server/server/home/metin2/Source/Server/game/src/input_db.cpp
@@ -1,3179 +1,3207 @@
-#include "stdafx.h" 
-#include "constants.h"
-#include "config.h"
-#include "utils.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "item.h"
-#include "item_manager.h"
-#include "packet.h"
-#include "protocol.h"
-#include "mob_manager.h"
-#include "shop_manager.h"
-#include "sectree_manager.h"
-#include "skill.h"
-#include "questmanager.h"
-#include "p2p.h"
-#include "guild.h"
-#include "guild_manager.h"
-#include "start_position.h"
-#include "party.h"
-#include "refine.h"
-#include "banword.h"
-#include "priv_manager.h"
-#include "db.h"
-#include "building.h"
-#include "login_sim.h"
-#include "wedding.h"
-#include "login_data.h"
-#include "unique_item.h"
-
-#include "monarch.h"
-#include "affect.h"
-#include "castle.h"
-#include "block_country.h"
-#include "motion.h"
-
-#include "dev_log.h"
-
-#include "log.h"
-
-#include "horsename_manager.h"
-#include "pcbang.h"
-#include "gm.h"
-#include "panama.h"
-#include "map_location.h"
-
-#include "DragonSoul.h"
-#if defined(__CUBE_RENEWAL__)
-#include "cube.h"
-#endif
-
-#if defined(__MT_THUNDER_DUNGEON__)
-#include "mt_thunder_dungeon.h"
-#endif
-
-#if defined(__MAILBOX__)
-#	include "MailBox.h"
-#endif
-
-#ifdef __OFFLINE_SHOP__
-#include "OfflineShop.h"
-#include "DynamicPacket.h"
-#endif
-
-#if defined(__SHOP_SEARCH__)
-	#include "ShopSearchManager.h"
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-#include "battlepass_manager.h"
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	#include "safebox.h"
-#endif
-
-extern BYTE g_bAuthServer;
-
-extern void gm_insert(const char* name, BYTE level);
-extern BYTE gm_get_level(const char* name, const char* host, const char* account);
-extern void gm_host_insert(const char* host);
-
-#define MAPNAME_DEFAULT "none"
-
-bool GetServerLocation(TAccountTable& rTab, BYTE bEmpire)
-{
-	bool bFound = false;
-
-	for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
-	{
-		if (0 == rTab.players[i].dwID)
-			continue;
-
-		bFound = true;
-		long lIndex = 0;
-
-		if (!CMapLocation::instance().Get(rTab.players[i].x,
-			rTab.players[i].y,
-			lIndex,
-			rTab.players[i].lAddr,
-			rTab.players[i].wPort))
-		{
-			sys_err("location error name %s mapindex %d %d x %d empire %d",
-				rTab.players[i].szName, lIndex, rTab.players[i].x, rTab.players[i].y, rTab.bEmpire);
-
-			rTab.players[i].x = EMPIRE_START_X(rTab.bEmpire);
-			rTab.players[i].y = EMPIRE_START_Y(rTab.bEmpire);
-
-			lIndex = 0;
-
-			if (!CMapLocation::instance().Get(rTab.players[i].x, rTab.players[i].y, lIndex, rTab.players[i].lAddr, rTab.players[i].wPort))
-			{
-				sys_err("cannot find server for mapindex %d %d x %d (name %s)",
-					lIndex,
-					rTab.players[i].x,
-					rTab.players[i].y,
-					rTab.players[i].szName);
-
-#if defined(__PROXY_IP__)
-				if (!g_stProxyIP.empty())
-					rTab.players[i].lAddr = inet_addr(g_stProxyIP.c_str());
-#endif
-
-				continue;
-			}
-		}
-
-#if defined(__PROXY_IP__)
-		if (!g_stProxyIP.empty())
-			rTab.players[i].lAddr = inet_addr(g_stProxyIP.c_str());
-#endif
-
-		struct in_addr in;
-		in.s_addr = rTab.players[i].lAddr;
-		sys_log(0, "success to %s:%d", inet_ntoa(in), rTab.players[i].wPort);
-	}
-
-	return bFound;
-}
-
-extern std::map<DWORD, CLoginSim*> g_sim;
-extern std::map<DWORD, CLoginSim*> g_simByPID;
-
-void CInputDB::LoginSuccess(DWORD dwHandle, const char* data)
-{
-	sys_log(0, "LoginSuccess");
-
-	TAccountTable* pTab = (TAccountTable*)data;
-
-	auto it = g_sim.find(pTab->id);
-	if (g_sim.end() != it)
-	{
-		sys_log(0, "CInputDB::LoginSuccess - already exist sim [%s]", pTab->login);
-		it->second->SendLoad();
-		return;
-	}
-
-	LPDESC d = DESC_MANAGER::instance().FindByHandle(dwHandle);
-
-	if (!d)
-	{
-		sys_log(0, "CInputDB::LoginSuccess - cannot find handle [%s]", pTab->login);
-
-		TLogoutPacket pack;
-
-		strlcpy(pack.login, pTab->login, sizeof(pack.login));
-		db_clientdesc->DBPacket(HEADER_GD_LOGOUT, dwHandle, &pack, sizeof(pack));
-		return;
-	}
-
-	if (strcmp(pTab->status, "OK")) // OK가 아니면
-	{
-		sys_log(0, "CInputDB::LoginSuccess - status[%s] is not OK [%s]", pTab->status, pTab->login);
-
-		TLogoutPacket pack;
-
-		strlcpy(pack.login, pTab->login, sizeof(pack.login));
-		db_clientdesc->DBPacket(HEADER_GD_LOGOUT, dwHandle, &pack, sizeof(pack));
-
-		LoginFailure(d, pTab->status);
-		return;
-	}
-
-	for (int i = 0; i != PLAYER_PER_ACCOUNT; ++i)
-	{
-		TSimplePlayer& player = pTab->players[i];
-		sys_log(0, "\tplayer(%s).job(%d)", player.szName, player.byJob);
-	}
-
-	bool bFound = GetServerLocation(*pTab, pTab->bEmpire);
-
-	d->BindAccountTable(pTab);
-
-	if (!bFound) // 캐릭터가 없으면 랜덤한 제국으로 보낸다.. -_-
-	{
-		TPacketGCEmpire pe;
-		pe.bHeader = HEADER_GC_EMPIRE;
-		pe.bEmpire = number(1, 3);
-		d->Packet(&pe, sizeof(pe));
-	}
-	else
-	{
-		TPacketGCEmpire pe;
-		pe.bHeader = HEADER_GC_EMPIRE;
-		pe.bEmpire = d->GetEmpire();
-		d->Packet(&pe, sizeof(pe));
-	}
-
-	d->SetPhase(PHASE_SELECT);
-	d->SendLoginSuccessPacket();
-
-	sys_log(0, "InputDB::login_success: %s", pTab->login);
-}
-
-void CInputDB::PlayerCreateFailure(LPDESC d, BYTE bType)
-{
-	if (!d)
-		return;
-
-	TPacketGCCreateFailure pack;
-
-	pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
-	pack.bType = bType;
-
-	d->Packet(&pack, sizeof(pack));
-}
-
-void CInputDB::PlayerCreateSuccess(LPDESC d, const char* data)
-{
-	if (!d)
-		return;
-
-	TPacketDGCreateSuccess* pPacketDB = (TPacketDGCreateSuccess*)data;
-
-	if (pPacketDB->bAccountCharacterIndex >= PLAYER_PER_ACCOUNT)
-	{
-		d->Packet(encode_byte(HEADER_GC_CHARACTER_CREATE_FAILURE), 1);
-		return;
-	}
-
-	long lIndex = 0;
-
-	if (!CMapLocation::instance().Get(pPacketDB->player.x,
-		pPacketDB->player.y,
-		lIndex,
-		pPacketDB->player.lAddr,
-		pPacketDB->player.wPort))
-	{
-		sys_err("InputDB::PlayerCreateSuccess: cannot find server for mapindex %d %d x %d (name %s)",
-			lIndex,
-			pPacketDB->player.x,
-			pPacketDB->player.y,
-			pPacketDB->player.szName);
-	}
-
-	TAccountTable& r_Tab = d->GetAccountTable();
-	r_Tab.players[pPacketDB->bAccountCharacterIndex] = pPacketDB->player;
-
-	TPacketGCPlayerCreateSuccess pack;
-
-	pack.header = HEADER_GC_CHARACTER_CREATE_SUCCESS;
-	pack.bAccountCharacterIndex = pPacketDB->bAccountCharacterIndex;
-	pack.player = pPacketDB->player;
-#if defined(__PROXY_IP__)
-	if (!g_stProxyIP.empty())
-		pack.player.lAddr = inet_addr(g_stProxyIP.c_str());
-#endif
-
-	d->Packet(&pack, sizeof(TPacketGCPlayerCreateSuccess));
-
-	// 기본 무기와 귀환부를 지급
-	TPlayerItem t;
-	memset(&t, 0, sizeof(t));
-
-	if (china_event_server)
-	{
-		t.bWindow = INVENTORY;
-		t.dwCount = 1;
-		t.dwOwner = r_Tab.players[pPacketDB->bAccountCharacterIndex].dwID;
-
-		//무사: 자인갑+3,철편투구+3,금편신발+3,남만도+3,백금목걸이+3, 흑단귀걸이+3, 소산부+3, 오각패+3, 흑단팔찌+3 
-		//자객：영린+3,연환두건+3,금편신발+3,마안도+3,화안궁+3,옥목걸이+3, 옥귀걸이+3, 오각패+3, 흑단팔찌+3 
-		//수라：음양갑+3,애희투구+3,금편신발+3,남만도+3,진주목걸이+3, 백금귀걸이+3, 오각패+3, 흑단팔찌+3
-		//무당：서천의+3,태을모+3,금편신발+3,자린선+3,매화령+3,진주목걸이+3, 백금귀걸이+3, 오각패+3, 흑단팔찌+3
-
-		struct SInitialItem
-		{
-			DWORD dwVnum;
-			BYTE pos;
-		};
-
-		const int MAX_INITIAL_ITEM = 9;
-
-		static SInitialItem initialItems[JOB_MAX_NUM][MAX_INITIAL_ITEM] =
-		{
-			{
-				{ 11243, 2 },
-				{ 12223, 3 },
-				{ 15103, 4 },
-				{ 93, 1 },
-				{ 16143, 8 },
-				{ 17103, 9 },
-				{ 3083, 0 },
-				{ 13193, 11 },
-				{ 14103, 12 },
-			},
-			{
-				{ 11443, 0 },
-				{ 12363, 3 },
-				{ 15103, 4 },
-				{ 1053, 2 },
-				{ 2083, 1 },
-				{16083, 7 },
-				{17083, 8 },
-				{13193, 9 },
-				{14103, 10 },
-			},
-			{
-				{ 11643, 0 },
-				{ 12503, 2 },
-				{ 15103, 3 },
-				{ 93, 1 },
-				{ 16123, 4 },
-				{ 17143, 7 },
-				{ 13193, 8 },
-				{ 14103, 9 },
-				{ 0, 0 },
-			},
-			{
-				{ 11843, 0 },
-				{ 12643, 1 },
-				{ 15103, 2 },
-				{ 7083, 3 },
-				{ 5053, 4 },
-				{ 16123, 6 },
-				{ 17143, 7 },
-				{ 13193, 8 },
-				{ 14103, 9 },
-			},
-			{
-				{ 21023, 2 },
-				{ 12223, 3 },
-				{ 21513, 4 },
-				{ 6023, 1 },
-				{ 16143, 8 },
-				{ 17103, 9 },
-				{ 0, 0 },
-				{ 13193, 11 },
-				{ 14103, 12 },
-			},
-		};
-
-		int job = pPacketDB->player.byJob;
-		for (int i = 0; i < MAX_INITIAL_ITEM; i++)
-		{
-			if (initialItems[job][i].dwVnum == 0)
-				continue;
-
-			t.dwID = ITEM_MANAGER::instance().GetNewID();
-			t.wPos = initialItems[job][i].pos;
-			t.dwVnum = initialItems[job][i].dwVnum;
-
-			db_clientdesc->DBPacketHeader(HEADER_GD_ITEM_SAVE, 0, sizeof(TPlayerItem));
-			db_clientdesc->Packet(&t, sizeof(TPlayerItem));
-		}
-	}
-
-	LogManager::instance().CharLog(pack.player.dwID, 0, 0, 0, "CREATE PLAYER", "", d->GetHostName());
-}
-
-void CInputDB::PlayerDeleteSuccess(LPDESC d, const char* data)
-{
-	if (!d)
-		return;
-
-	BYTE account_index;
-	account_index = decode_byte(data);
-	d->BufferedPacket(encode_byte(HEADER_GC_CHARACTER_DELETE_SUCCESS), 1);
-	d->Packet(encode_byte(account_index), 1);
-
-	d->GetAccountTable().players[account_index].dwID = 0;
-}
-
-void CInputDB::PlayerDeleteFail(LPDESC d
-#if defined(__DELETE_FAILURE_TYPE__)
-	, const char* c_pszData
-#endif
-)
-{
-	if (!d)
-		return;
-
-#if defined(__DELETE_FAILURE_TYPE__)
-	const TPlayerDeleteFailurePacket* pPacket = reinterpret_cast<const TPlayerDeleteFailurePacket*>(c_pszData);
-	if (pPacket == nullptr)
-		return;
-
-	d->BufferedPacket(encode_byte(HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID), sizeof(BYTE));
-	d->BufferedPacket(&pPacket->bType, sizeof(pPacket->bType));
-	d->Packet(&pPacket->iTime, sizeof(pPacket->iTime));
-#else
-	d->Packet(encode_byte(HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID), 1);
-#endif
-}
-
-void CInputDB::ChangeName(LPDESC d, const char* data)
-{
-	if (!d)
-		return;
-
-	TPacketDGChangeName* p = (TPacketDGChangeName*)data;
-
-	TAccountTable& r = d->GetAccountTable();
-
-	if (!r.id)
-		return;
-
-	for (size_t i = 0; i < PLAYER_PER_ACCOUNT; ++i)
-		if (r.players[i].dwID == p->pid)
-		{
-			strlcpy(r.players[i].szName, p->name, sizeof(r.players[i].szName));
-			r.players[i].bChangeName = 0;
-
-			TPacketGCChangeName pgc;
-
-			pgc.header = HEADER_GC_CHANGE_NAME;
-			pgc.pid = p->pid;
-			strlcpy(pgc.name, p->name, sizeof(pgc.name));
-
-			d->Packet(&pgc, sizeof(TPacketGCChangeName));
-			break;
-		}
-}
-
-void CInputDB::PlayerLoad(LPDESC d, const char* data)
-{
-	TPlayerTable* pTab = (TPlayerTable*)data;
-
-	if (!d)
-		return;
-
-	long lMapIndex = pTab->lMapIndex;
-	PIXEL_POSITION pos;
-
-	if (lMapIndex == 0)
-	{
-		lMapIndex = SECTREE_MANAGER::instance().GetMapIndex(pTab->x, pTab->y);
-
-		if (lMapIndex == 0) // 좌표를 찾을 수 없다.
-		{
-			lMapIndex = EMPIRE_START_MAP(d->GetAccountTable().bEmpire);
-			pos.x = EMPIRE_START_X(d->GetAccountTable().bEmpire);
-			pos.y = EMPIRE_START_Y(d->GetAccountTable().bEmpire);
-		}
-		else
-		{
-			pos.x = pTab->x;
-			pos.y = pTab->y;
-		}
-	}
-	pTab->lMapIndex = lMapIndex;
-
-	// Private 맵에 있었는데, Private 맵이 사라진 상태라면 출구로 돌아가야 한다.
-	// ----
-	// 근데 출구로 돌아가야 한다면서... 왜 출구가 아니라 private map 상에 대응되는 pulic map의 위치를 찾냐고...
-	// 역사를 모르니... 또 하드코딩 한다.
-	// 아귀동굴이면, 출구로...
-	// by rtsummit
-	if (!SECTREE_MANAGER::instance().GetValidLocation(pTab->lMapIndex, pTab->x, pTab->y, lMapIndex, pos, d->GetEmpire()))
-	{
-		//sys_err("InputDB::PlayerLoad : cannot find valid location %d x %d (name: %s)", pTab->x, pTab->y, pTab->name);
-		sys_err("InputDB::PlayerLoad : cannot find valid location %d x %d (name: %s) sending to village", pTab->x, pTab->y, pTab->name);
-
-		lMapIndex = EMPIRE_START_MAP(d->GetAccountTable().bEmpire);
-		pos.x = EMPIRE_START_X(d->GetAccountTable().bEmpire);
-		pos.y = EMPIRE_START_Y(d->GetAccountTable().bEmpire);
-
-		d->SetPhase(PHASE_CLOSE);
-		return;
-	}
-
-	pTab->x = pos.x;
-	pTab->y = pos.y;
-	pTab->lMapIndex = lMapIndex;
-
-	if (d->GetCharacter() || d->IsPhase(PHASE_GAME))
-	{
-		LPCHARACTER p = d->GetCharacter();
-		sys_err("login state already has main state (character %s %p)", p->GetName(), get_pointer(p));
-		return;
-	}
-
-	if (NULL != CHARACTER_MANAGER::Instance().FindPC(pTab->name))
-	{
-		sys_err("InputDB: PlayerLoad : %s already exist in game", pTab->name);
-		return;
-	}
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().CreateCharacter(pTab->name, pTab->id);
-
-	ch->BindDesc(d);
-	ch->SetPlayerProto(pTab);
-	ch->SetEmpire(d->GetEmpire());
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	ch->SetCountry(LocaleService_GetCountry(d->GetAccountTable().country));
-#endif
-
-	d->BindCharacter(ch);
-
-	{
-		// P2P Login
-		TPacketGGLogin p;
-
-		p.bHeader = HEADER_GG_LOGIN;
-		strlcpy(p.szName, ch->GetName(), sizeof(p.szName));
-		p.dwPID = ch->GetPlayerID();
-		p.bEmpire = ch->GetEmpire();
-		p.lMapIndex = SECTREE_MANAGER::instance().GetMapIndex(ch->GetX(), ch->GetY());
-		p.bChannel = g_bChannel;
-
-		P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGLogin));
-
-#if defined(__CHEQUE_SYSTEM__) && defined(__GEM_SYSTEM__)
-		char buf[55];
-		snprintf(buf, sizeof(buf), "%s %d %d %d %d %ld %d",
-			inet_ntoa(ch->GetDesc()->GetAddr().sin_addr), ch->GetGold(), ch->GetCheque(), ch->GetGem(), g_bChannel, ch->GetMapIndex(), ch->GetAlignment());
-#elif defined(__CHEQUE_SYSTEM__)
-		char buf[55];
-		snprintf(buf, sizeof(buf), "%s %d %d %d %ld %d",
-			inet_ntoa(ch->GetDesc()->GetAddr().sin_addr), ch->GetGold(), ch->GetCheque(), g_bChannel, ch->GetMapIndex(), ch->GetAlignment());
-#else
-		char buf[51];
-		snprintf(buf, sizeof(buf), "%s %d %d %ld %d",
-			inet_ntoa(ch->GetDesc()->GetAddr().sin_addr), ch->GetGold(), g_bChannel, ch->GetMapIndex(), ch->GetAlignment());
-#endif
-
-		LogManager::instance().CharLog(ch, 0, "LOGIN", buf);
-
-		// if (LC_IsYMIR() || LC_IsKorea() || LC_IsBrazil() || LC_IsJapan())
-		{
-			LogManager::instance().LoginLog(true,
-				ch->GetDesc()->GetAccountTable().id, ch->GetPlayerID(), ch->GetLevel(), ch->GetJob(), ch->GetRealPoint(POINT_PLAYTIME));
-
-			// if (LC_IsBrazil() != true)
-			{
-				ch->SetPCBang(CPCBangManager::instance().IsPCBangIP(ch->GetDesc()->GetHostName()));
-			}
-		}
-	}
-
-	d->SetPhase(PHASE_LOADING);
-	ch->MainCharacterPacket();
-
-	long lPublicMapIndex = lMapIndex >= 10000 ? lMapIndex / 10000 : lMapIndex;
-
-	// Send Supplementary Data Block if new map requires security packages in loading this map
-	const TMapRegion* rMapRgn = SECTREE_MANAGER::instance().GetMapRegion(lPublicMapIndex);
-	if (rMapRgn)
-	{
-		DESC_MANAGER::instance().SendClientPackageSDBToLoadMap(d, rMapRgn->strMapName.c_str());
-	}
-	//if (!map_allow_find(lMapIndex >= 10000 ? lMapIndex / 10000 : lMapIndex) || !CheckEmpire(ch, lMapIndex))
-	if (!map_allow_find(lPublicMapIndex))
-	{
-		sys_err("InputDB::PlayerLoad : entering %d map is not allowed here (name: %s, empire %u)",
-			lMapIndex, pTab->name, d->GetEmpire());
-
-		ch->SetWarpLocation(EMPIRE_START_MAP(d->GetEmpire()),
-			EMPIRE_START_X(d->GetEmpire()) / 100,
-			EMPIRE_START_Y(d->GetEmpire()) / 100);
-
-		d->SetPhase(PHASE_CLOSE);
-		return;
-	}
-
-	quest::CQuestManager::instance().BroadcastEventFlagOnLogin(ch);
-
-	for (int i = 0; i < QUICKSLOT_MAX_NUM; ++i)
-		ch->SetQuickslot(i, pTab->quickslot[i]);
-
-	ch->PointsPacket();
-	ch->SkillLevelPacket();
-
-	sys_log(0, "InputDB: player_load %s %dx%dx%d LEVEL %d MOV_SPEED %d JOB %d ATG %d DFG %d GMLv %d",
-		pTab->name,
-		ch->GetX(), ch->GetY(), ch->GetZ(),
-		ch->GetLevel(),
-		ch->GetPoint(POINT_MOV_SPEED),
-		ch->GetJob(),
-		ch->GetPoint(POINT_ATT_GRADE),
-		ch->GetPoint(POINT_DEF_GRADE),
-		ch->GetGMLevel());
-
-	ch->QuerySafeboxSize();
-}
-
-void CInputDB::Boot(const char* data)
-{
-	signal_timer_disable();
-
-	// 패킷 사이즈 체크
-	DWORD dwPacketSize = decode_4bytes(data);
-	data += 4;
-
-	// 패킷 버전 체크
-	BYTE bVersion = decode_byte(data);
-	data += 1;
-
-	sys_log(0, "BOOT: PACKET: %d", dwPacketSize);
-	sys_log(0, "BOOT: VERSION: %d", bVersion);
-	if (bVersion != 6)
-	{
-		sys_err("boot version error");
-		thecore_shutdown();
-	}
-
-	sys_log(0, "sizeof(TMobTable) = %d", sizeof(TMobTable));
-	sys_log(0, "sizeof(TItemTable) = %d", sizeof(TItemTable));
-	sys_log(0, "sizeof(TShopTable) = %d", sizeof(TShopTable));
-	sys_log(0, "sizeof(TSkillTable) = %d", sizeof(TSkillTable));
-	sys_log(0, "sizeof(TRefineTable) = %d", sizeof(TRefineTable));
-	sys_log(0, "sizeof(TItemAttrTable) = %d", sizeof(TItemAttrTable));
-	sys_log(0, "sizeof(TItemRareTable) = %d", sizeof(TItemAttrTable));
-	sys_log(0, "sizeof(TBanwordTable) = %d", sizeof(TBanwordTable));
-	sys_log(0, "sizeof(TLand) = %d", sizeof(building::TLand));
-	sys_log(0, "sizeof(TObjectProto) = %d", sizeof(building::TObjectProto));
-	sys_log(0, "sizeof(TObject) = %d", sizeof(building::TObject));
-#ifdef __GROWTH_PET_SYSTEM__
-	sys_log(0, "sizeof(TGrowthPetSkillTable) = %d", sizeof(TGrowthPetSkillTable));
-#endif
-	// ADMIN_MANAGER
-	sys_log(0, "sizeof(TAdminManager) = %d", sizeof(TAdminInfo));
-	// END_ADMIN_MANAGER
-
-	WORD size;
-
-	/*
-	* MOB
-	*/
-
-	if (decode_2bytes(data) != sizeof(TMobTable))
-	{
-		sys_err("mob table size error");
-		thecore_shutdown();
-		return;
-	}
-	data += 2;
-
-	size = decode_2bytes(data);
-	data += 2;
-	sys_log(0, "BOOT: MOB: %d", size);
-
-	if (size)
-	{
-		CMobManager::instance().Initialize((TMobTable*)data, size);
-		data += size * sizeof(TMobTable);
-	}
-
-	/*
-	* ITEM
-	*/
-
-	if (decode_2bytes(data) != sizeof(TItemTable))
-	{
-		sys_err("item table size error");
-		thecore_shutdown();
-		return;
-	}
-	data += 2;
-
-	size = decode_2bytes(data);
-	data += 2;
-	sys_log(0, "BOOT: ITEM: %d", size);
-
-	if (size)
-	{
-		ITEM_MANAGER::instance().Initialize((TItemTable*)data, size);
-		data += size * sizeof(TItemTable);
-	}
-
-	/*
-	* SHOP
-	*/
-
-	if (decode_2bytes(data) != sizeof(TShopTable))
-	{
-		sys_err("shop table size error");
-		thecore_shutdown();
-		return;
-	}
-	data += 2;
-
-	size = decode_2bytes(data);
-	data += 2;
-	sys_log(0, "BOOT: SHOP: %d", size);
-
-	if (size)
-	{
-		if (!CShopManager::instance().Initialize((TShopTable*)data, size))
-		{
-			sys_err("shop table Initialize error");
-			thecore_shutdown();
-			return;
-		}
-		data += size * sizeof(TShopTable);
-	}
-
-	/*
-	* SKILL
-	*/
-
-	if (decode_2bytes(data) != sizeof(TSkillTable))
-	{
-		sys_err("skill table size error");
-		thecore_shutdown();
-		return;
-	}
-	data += 2;
-
-	size = decode_2bytes(data);
-	data += 2;
-	sys_log(0, "BOOT: SKILL: %d", size);
-
-	if (size)
-	{
-		if (!CSkillManager::instance().Initialize((TSkillTable*)data, size))
-		{
-			sys_err("cannot initialize skill table");
-			thecore_shutdown();
-			return;
-		}
-
-		data += size * sizeof(TSkillTable);
-	}
-	/*
-	* REFINE RECIPE
-	*/
-
-	if (decode_2bytes(data) != sizeof(TRefineTable))
-	{
-		sys_err("refine table size error");
-		thecore_shutdown();
-		return;
-	}
-	data += 2;
-
-	size = decode_2bytes(data);
-	data += 2;
-	sys_log(0, "BOOT: REFINE: %d", size);
-
-	if (size)
-	{
-		CRefineManager::instance().Initialize((TRefineTable*)data, size);
-		data += size * sizeof(TRefineTable);
-	}
-
-	/*
-	* ITEM ATTR
-	*/
-
-	if (decode_2bytes(data) != sizeof(TItemAttrTable))
-	{
-		sys_err("item attr table size error");
-		thecore_shutdown();
-		return;
-	}
-	data += 2;
-
-	size = decode_2bytes(data);
-	data += 2;
-	sys_log(0, "BOOT: ITEM_ATTR: %d", size);
-
-	if (size)
-	{
-		TItemAttrTable* p = (TItemAttrTable*)data;
-
-		for (int i = 0; i < size; ++i, ++p)
-		{
-			if (p->wApplyIndex >= MAX_APPLY_NUM)
-				continue;
-
-			g_map_itemAttr[p->wApplyIndex] = *p;
-			sys_log(0, "ITEM_ATTR[%d]: %s %u", p->wApplyIndex, p->szApply, p->dwProb);
-		}
-	}
-
-	data += size * sizeof(TItemAttrTable);
-
-	/*
-	* ITEM RARE
-	*/
-
-	if (decode_2bytes(data) != sizeof(TItemAttrTable))
-	{
-		sys_err("item rare table size error");
-		thecore_shutdown();
-		return;
-	}
-	data += 2;
-
-	size = decode_2bytes(data);
-	data += 2;
-	sys_log(0, "BOOT: ITEM_RARE: %d", size);
-
-	if (size)
-	{
-		TItemAttrTable* p = (TItemAttrTable*)data;
-
-		for (int i = 0; i < size; ++i, ++p)
-		{
-			if (p->wApplyIndex >= MAX_APPLY_NUM)
-				continue;
-
-			g_map_itemRare[p->wApplyIndex] = *p;
-			sys_log(0, "ITEM_RARE[%d]: %s %u", p->wApplyIndex, p->szApply, p->dwProb);
-		}
-	}
-
-	data += size * sizeof(TItemAttrTable);
-
-	/*
-	* BANWORDS
-	*/
-
-	if (decode_2bytes(data) != sizeof(TBanwordTable))
-	{
-		sys_err("ban word table size error");
-		thecore_shutdown();
-		return;
-	}
-	data += 2;
-
-	size = decode_2bytes(data);
-	data += 2;
-
-	CBanwordManager::instance().Initialize((TBanwordTable*)data, size);
-	data += size * sizeof(TBanwordTable);
-
-	{
-		using namespace building;
-
-		/*
-		* LANDS
-		*/
-
-		if (decode_2bytes(data) != sizeof(TLand))
-		{
-			sys_err("land table size error");
-			thecore_shutdown();
-			return;
-		}
-		data += 2;
-
-		size = decode_2bytes(data);
-		data += 2;
-
-		TLand* kLand = (TLand*)data;
-		data += size * sizeof(TLand);
-
-		for (WORD i = 0; i < size; ++i, ++kLand)
-			CManager::instance().LoadLand(kLand);
-
-		/*
-		* OBJECT PROTO
-		*/
-
-		if (decode_2bytes(data) != sizeof(TObjectProto))
-		{
-			sys_err("object proto table size error");
-			thecore_shutdown();
-			return;
-		}
-		data += 2;
-
-		size = decode_2bytes(data);
-		data += 2;
-
-		CManager::instance().LoadObjectProto((TObjectProto*)data, size);
-		data += size * sizeof(TObjectProto);
-
-		/*
-		* OBJECT
-		*/
-
-		if (decode_2bytes(data) != sizeof(TObject))
-		{
-			sys_err("object table size error");
-			thecore_shutdown();
-			return;
-		}
-		data += 2;
-
-		size = decode_2bytes(data);
-		data += 2;
-
-		TObject* kObj = (TObject*)data;
-		data += size * sizeof(TObject);
-
-		for (WORD i = 0; i < size; ++i, ++kObj)
-			CManager::instance().LoadObject(kObj, true);
-	}
-
-#ifdef __GROWTH_PET_SYSTEM__
-	/*
-	* GROWTH PET SKILL
-	*/
-
-	if (decode_2bytes(data) != sizeof(TGrowthPetSkillTable))
-	{
-		sys_err("growth pet table size error");
-		thecore_shutdown();
-		return;
-	}
-	data += 2;
-
-	size = decode_2bytes(data);
-	data += 2;
-	sys_log(0, "BOOT: GROWTH PET SKILL: %d", size);
-
-	if (size)
-	{
-		CGrowthPetManager::instance().InitializeSkill((TGrowthPetSkillTable*)data, size);
-		data += size * sizeof(TGrowthPetSkillTable);
-	}
-#endif
-
-	set_global_time(*(time_t*)data);
-	data += sizeof(time_t);
-
-	if (decode_2bytes(data) != sizeof(TItemIDRangeTable))
-	{
-		sys_err("ITEM ID RANGE size error");
-		thecore_shutdown();
-		return;
-	}
-	data += 2;
-
-	size = decode_2bytes(data);
-	data += 2;
-
-	TItemIDRangeTable* range = (TItemIDRangeTable*)data;
-	data += size * sizeof(TItemIDRangeTable);
-
-	TItemIDRangeTable* rangespare = (TItemIDRangeTable*)data;
-	data += size * sizeof(TItemIDRangeTable);
-
-	// ADMIN_MANAGER
-	// 관리자 등록
-	int ChunkSize = decode_2bytes(data);
-	data += 2;
-	int HostSize = decode_2bytes(data);
-	data += 2;
-	sys_log(0, "GM Value Count %d %d", HostSize, ChunkSize);
-	for (int n = 0; n < HostSize; ++n)
-	{
-		gm_new_host_inert(data);
-		sys_log(0, "GM HOST : IP[%s] ", data);
-		data += ChunkSize;
-	}
-
-	data += 2;
-	int adminsize = decode_2bytes(data);
-	data += 2;
-
-	for (int n = 0; n < adminsize; ++n)
-	{
-		tAdminInfo& rAdminInfo = *(tAdminInfo*)data;
-
-		gm_new_insert(rAdminInfo);
-
-		data += sizeof(rAdminInfo);
-	}
-	// END_ADMIN_MANAGER
-
-	// MONARCH
-	data += 2;
-	data += 2;
-
-	TMonarchInfo& p = *(TMonarchInfo*)data;
-	data += sizeof(TMonarchInfo);
-
-	CMonarch::instance().SetMonarchInfo(&p);
-
-	for (int n = 1; n < 4; ++n)
-	{
-		if (p.name[n] && *p.name[n])
-			sys_log(0, "[MONARCH] Empire %d Pid %d Money %d %s", n, p.pid[n], p.money[n], p.name[n]);
-	}
-
-	int CandidacySize = decode_2bytes(data);
-	data += 2;
-
-	int CandidacyCount = decode_2bytes(data);
-	data += 2;
-
-	if (test_server)
-		sys_log(0, "[MONARCH] Size %d Count %d", CandidacySize, CandidacyCount);
-
-	data += CandidacySize * CandidacyCount;
-	// END_MONARCH
-
-#ifdef __OFFLINE_SHOP__
-	{
-		CDynamicPacket packet(data);
-
-		auto size = *packet.Get<uint32_t>();
-		if (size != sizeof(TOfflineShop)) {
-			sys_err("TOfflineShop size error! Expected size %u.", sizeof(TOfflineShop));
-			thecore_shutdown();
-			return;
-		}
-
-		auto count = *packet.Get<uint32_t>();
-		while (count > 0) {
-			count--;
-
-			const auto& shopData = *packet.Get<TOfflineShop>();
-			if (shopData.channel != g_bChannel || !map_allow_find(shopData.mapIndex)) {
-				continue;
-			}
-
-			COfflineShop::LoadShop(shopData);
-		}
-
-
-		size = *packet.Get<uint32_t>();
-		if (size != sizeof(TOfflineShopItem)) {
-			sys_err("TOfflineShopItem size error! Expected size %u.", sizeof(TOfflineShopItem));
-			thecore_shutdown();
-			return;
-		}
-
-		count = *packet.Get<uint32_t>();
-		while (count > 0) {
-			count--;
-
-			const auto& itemData = *packet.Get<TOfflineShopItem>();
-
-			auto shop = COfflineShop::Get(itemData.id.first);
-			if (!shop) {
-				continue;
-			}
-
-			shop->get()->AddItem(itemData);
-		}
-
-		data += packet.GetExtraSize();
-	}
-#endif
-
-	WORD endCheck = decode_2bytes(data);
-	if (endCheck != 0xffff)
-	{
-		sys_err("boot packet end check error [%x]!=0xffff", endCheck);
-		thecore_shutdown();
-		return;
-	}
-	else
-		sys_log(0, "boot packet end check ok [%x]==0xffff", endCheck);
-	data += 2;
-
-	if (!ITEM_MANAGER::instance().SetMaxItemID(*range))
-	{
-		sys_err("not enough item id contact your administrator!");
-		thecore_shutdown();
-		return;
-	}
-
-	if (!ITEM_MANAGER::instance().SetMaxSpareItemID(*rangespare))
-	{
-		sys_err("not enough item id for spare contact your administrator!");
-		thecore_shutdown();
-		return;
-	}
-
-	// LOCALE_SERVICE
-	const int FILE_NAME_LEN = 256;
-	char szCommonDropItemFileName[FILE_NAME_LEN];
-	char szETCDropItemFileName[FILE_NAME_LEN];
-	char szMOBDropItemFileName[FILE_NAME_LEN];
-	char szDropItemGroupFileName[FILE_NAME_LEN];
-	char szSpecialItemGroupFileName[FILE_NAME_LEN];
-	char szMapIndexFileName[FILE_NAME_LEN];
-#if defined(__CONQUEROR_LEVEL__)
-	char szNewWorldMapIndexFileName[FILE_NAME_LEN];
-#endif
-	char szItemVnumMaskTableFileName[FILE_NAME_LEN];
-	char szDragonSoulTableFileName[FILE_NAME_LEN];
-#if defined(__LUCKY_BOX__)
-	char szLuckyBoxFileName[FILE_NAME_LEN];
-#endif
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	char szRouletteTableFileName[FILE_NAME_LEN];
-#endif
-
-	snprintf(szCommonDropItemFileName, sizeof(szCommonDropItemFileName),
-		"%s/common_drop_item.txt", LocaleService_GetBasePath().c_str());
-	snprintf(szETCDropItemFileName, sizeof(szETCDropItemFileName),
-		"%s/etc_drop_item.txt", LocaleService_GetBasePath().c_str());
-	snprintf(szMOBDropItemFileName, sizeof(szMOBDropItemFileName),
-		"%s/mob_drop_item.txt", LocaleService_GetBasePath().c_str());
-	snprintf(szSpecialItemGroupFileName, sizeof(szSpecialItemGroupFileName),
-		"%s/special_item_group.txt", LocaleService_GetBasePath().c_str());
-	snprintf(szDropItemGroupFileName, sizeof(szDropItemGroupFileName),
-		"%s/drop_item_group.txt", LocaleService_GetBasePath().c_str());
-	snprintf(szMapIndexFileName, sizeof(szMapIndexFileName),
-		"%s/index.txt", LocaleService_GetMapPath().c_str());
-#if defined(__CONQUEROR_LEVEL__)
-	snprintf(szNewWorldMapIndexFileName, sizeof(szNewWorldMapIndexFileName),
-		"%s/new_world.txt", LocaleService_GetMapPath().c_str());
-#endif
-	snprintf(szItemVnumMaskTableFileName, sizeof(szItemVnumMaskTableFileName),
-		"%s/ori_to_new_table.txt", LocaleService_GetBasePath().c_str());
-	snprintf(szDragonSoulTableFileName, sizeof(szDragonSoulTableFileName),
-		"%s/dragon_soul_table.txt", LocaleService_GetBasePath().c_str());
-#if defined(__LUCKY_BOX__)
-	snprintf(szLuckyBoxFileName, sizeof(szLuckyBoxFileName),
-		"%s/lucky_box.txt", LocaleService_GetBasePath().c_str());
-#endif
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	snprintf(szRouletteTableFileName, sizeof(szRouletteTableFileName),
-		"%s/roulette_table.txt", LocaleService_GetBasePath().c_str());
-#endif
-
-#if !defined(__CUBE_RENEWAL__)
-	sys_log(0, "Initializing Informations of Cube System");
-	if (!Cube_InformationInitialize())
-	{
-		sys_err("cannot init cube infomation.");
-		thecore_shutdown();
-		return;
-	}
-#endif
-
-	sys_log(0, "LoadLocaleFile: CommonDropItem: %s", szCommonDropItemFileName);
-	if (!ITEM_MANAGER::instance().ReadCommonDropItemFile(szCommonDropItemFileName))
-	{
-		sys_err("cannot load CommonDropItem: %s", szCommonDropItemFileName);
-		thecore_shutdown();
-		return;
-	}
-
-	sys_log(0, "LoadLocaleFile: ETCDropItem: %s", szETCDropItemFileName);
-	if (!ITEM_MANAGER::instance().ReadEtcDropItemFile(szETCDropItemFileName))
-	{
-		sys_err("cannot load ETCDropItem: %s", szETCDropItemFileName);
-		thecore_shutdown();
-		return;
-	}
-
-	sys_log(0, "LoadLocaleFile: DropItemGroup: %s", szDropItemGroupFileName);
-	if (!ITEM_MANAGER::instance().ReadDropItemGroup(szDropItemGroupFileName))
-	{
-		sys_err("cannot load DropItemGroup: %s", szDropItemGroupFileName);
-		thecore_shutdown();
-		return;
-	}
-
-	sys_log(0, "LoadLocaleFile: SpecialItemGroup: %s", szSpecialItemGroupFileName);
-	if (!ITEM_MANAGER::instance().ReadSpecialDropItemFile(szSpecialItemGroupFileName))
-	{
-		sys_err("cannot load SpecialItemGroup: %s", szSpecialItemGroupFileName);
-		thecore_shutdown();
-		return;
-	}
-
-	sys_log(0, "LoadLocaleFile: ItemVnumMaskTable : %s", szItemVnumMaskTableFileName);
-	if (!ITEM_MANAGER::instance().ReadItemVnumMaskTable(szItemVnumMaskTableFileName))
-	{
-		sys_log(0, "Could not open MaskItemTable");
-	}
-
-	sys_log(0, "LoadLocaleFile: MOBDropItemFile: %s", szMOBDropItemFileName);
-	if (!ITEM_MANAGER::instance().ReadMonsterDropItemGroup(szMOBDropItemFileName))
-	{
-		sys_err("cannot load MOBDropItemFile: %s", szMOBDropItemFileName);
-		thecore_shutdown();
-		return;
-	}
-
-	sys_log(0, "LoadLocaleFile: MapIndex: %s", szMapIndexFileName);
-	if (!SECTREE_MANAGER::instance().Build(szMapIndexFileName, LocaleService_GetMapPath().c_str()))
-	{
-		sys_err("cannot load MapIndex: %s", szMapIndexFileName);
-		thecore_shutdown();
-		return;
-	}
-
-#if defined(__CONQUEROR_LEVEL__)
-	sys_log(0, "LoadLocaleFile: NewWorldMapIndex: %s", szNewWorldMapIndexFileName);
-	if (!SECTREE_MANAGER::Instance().LoadNewWorldMapIndexFile(szNewWorldMapIndexFileName))
-		sys_err("cannot load NewWorldMapIndex: %s", szNewWorldMapIndexFileName);
-#endif
-
-	SECTREE_MANAGER::instance().LoadBlockFilterMapIndexFile(SECTREE_MANAGER::PET_BLOCK_MAP_INDEX);
-	SECTREE_MANAGER::instance().LoadBlockFilterMapIndexFile(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX);
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	sys_log(0, "LoadLocaleFile: DragonSoulTable: %s", szDragonSoulTableFileName);
-	if (!DSManager::instance().ReadDragonSoulTableFile(szDragonSoulTableFileName))
-	{
-		sys_err("cannot load DragonSoulTable: %s", szDragonSoulTableFileName);
-		//thecore_shutdown();
-		//return;
-	}
-#endif
-
-#if defined(__LUCKY_BOX__)
-	sys_log(0, "LoadLocaleFile: LuckyBoxFile: %s", szLuckyBoxFileName);
-	if (!ITEM_MANAGER::instance().ReadLuckyBoxFile(szLuckyBoxFileName))
-	{
-		sys_err("cannot load LuckyBoxFile: %s", szLuckyBoxFileName);
-		thecore_shutdown();
-		return;
-	}
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-	char szApplyRandomTableFileName[FILE_NAME_LEN];
-	snprintf(szApplyRandomTableFileName, sizeof(szApplyRandomTableFileName),
-		"%s/apply_random_table.txt", LocaleService_GetBasePath().c_str());
-	sys_log(0, "LoadLocaleFile: ApplyRandomTable: %s", szApplyRandomTableFileName);
-	if (!ITEM_MANAGER::instance().ReadApplyRandomTableFile(szApplyRandomTableFileName))
-	{
-		sys_err("LoadLocaleFile: Cannot load ApplyRandomTable: %s", szApplyRandomTableFileName);
-		thecore_shutdown();
-		return;
-	}
-#endif
-
-#if defined(__GEM_SHOP__)
-	char szGemShopTableFileName[FILE_NAME_LEN];
-	snprintf(szGemShopTableFileName, sizeof(szGemShopTableFileName),
-		"%s/gem_shop_table.txt", LocaleService_GetBasePath().c_str());
-	sys_log(0, "LoadLocaleFile: GemShopTable: %s", szGemShopTableFileName);
-	if (!ITEM_MANAGER::instance().ReadGemShopItemGroup(szGemShopTableFileName))
-		sys_err("LoadLocaleFile: Cannot load GemShopTable: %s", szGemShopTableFileName);
-#endif
-
-#if defined(__SET_ITEM__)
-	char szSetItemTableFileName[FILE_NAME_LEN];
-	snprintf(szSetItemTableFileName, sizeof(szSetItemTableFileName),
-		"%s/set_item_table.txt", LocaleService_GetBasePath().c_str());
-	sys_log(0, "LoadLocaleFile: SetItemTable: %s", szSetItemTableFileName);
-	if (!ITEM_MANAGER::instance().LoadSetItemTable(szSetItemTableFileName))
-		sys_err("LoadLocaleFile: Cannot load SetItemTable: %s", szSetItemTableFileName);
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	sys_log(0, "LoadLocaleFile: RouletteTable: %s", szRouletteTableFileName);
-	if (!CRouletteManager::Instance().ReadRouletteTableFile(szRouletteTableFileName))
-	{
-		sys_err("cannot load RouletteTable: %s", szRouletteTableFileName);
-		thecore_shutdown();
-		return;
-	}
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	if (!CBattlePassManager::instance().InitializeBattlePass())
-		sys_err("Failure to Initialize Extended BattlePass!");
-#endif
-
-	// END_OF_LOCALE_SERVICE
-
-	building::CManager::instance().FinalizeBoot();
-
-	CMotionManager::instance().Build();
-
-	signal_timer_enable(30);
-
-	if (test_server)
-	{
-		CMobManager::instance().DumpRegenCount("mob_count");
-	}
-
-	CPCBangManager::instance().RequestUpdateIPList(0);
-#ifdef __OFFLINE_SHOP__
-	COfflineShop::OpenShops();
-#endif
-	// castle_boot
-	castle_boot();
-
-#if defined(__MT_THUNDER_DUNGEON__)
-	CMTThunderDungeon::Instance().Initialize();
-#endif
-
-	// request blocked_country_ip
-	{
-		db_clientdesc->DBPacket(HEADER_GD_BLOCK_COUNTRY_IP, 0, NULL, 0);
-		dev_log(LOG_DEB0, "<sent HEADER_GD_BLOCK_COUNTRY_IP>");
-	}
-}
-
-EVENTINFO(quest_login_event_info)
-{
-	DWORD dwPID;
-
-	quest_login_event_info()
-		: dwPID(0)
-	{
-	}
-};
-
-EVENTFUNC(quest_login_event)
-{
-	quest_login_event_info* info = dynamic_cast<quest_login_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("quest_login_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	DWORD dwPID = info->dwPID;
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(dwPID);
-
-	if (!ch)
-		return 0;
-
-	LPDESC d = ch->GetDesc();
-
-	if (!d)
-		return 0;
-
-	if (d->IsPhase(PHASE_HANDSHAKE) ||
-		d->IsPhase(PHASE_LOGIN) ||
-		d->IsPhase(PHASE_SELECT) ||
-		d->IsPhase(PHASE_DEAD) ||
-		d->IsPhase(PHASE_LOADING))
-	{
-		return PASSES_PER_SEC(1);
-	}
-	else if (d->IsPhase(PHASE_CLOSE))
-	{
-		return 0;
-	}
-	else if (d->IsPhase(PHASE_GAME))
-	{
-		sys_log(0, "QUEST_LOAD: Login pc %d by event", ch->GetPlayerID());
-		quest::CQuestManager::instance().Login(ch->GetPlayerID());
-		return 0;
-	}
-	else
-	{
-		sys_err(0, "input_db.cpp:quest_login_event INVALID PHASE pid %d", ch->GetPlayerID());
-		return 0;
-	}
-}
-
-void CInputDB::QuestLoad(LPDESC d, const char* c_pData)
-{
-	if (NULL == d)
-		return;
-
-	LPCHARACTER ch = d->GetCharacter();
-
-	if (NULL == ch)
-		return;
-
-	const DWORD dwCount = decode_4bytes(c_pData);
-
-	const TQuestTable* pQuestTable = reinterpret_cast<const TQuestTable*>(c_pData + 4);
-
-	if (NULL != pQuestTable)
-	{
-		if (dwCount != 0)
-		{
-			if (ch->GetPlayerID() != pQuestTable[0].dwPID)
-			{
-				sys_err("PID differs %u %u", ch->GetPlayerID(), pQuestTable[0].dwPID);
-				return;
-			}
-		}
-
-		sys_log(0, "QUEST_LOAD: count %d", dwCount);
-
-		quest::PC* pkPC = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
-
-		if (!pkPC)
-		{
-			sys_err("null quest::PC with id %u", pQuestTable[0].dwPID);
-			return;
-		}
-
-		if (pkPC->IsLoaded())
-			return;
-
-		for (unsigned int i = 0; i < dwCount; ++i)
-		{
-			std::string st(pQuestTable[i].szName);
-
-			st += ".";
-			st += pQuestTable[i].szState;
-
-			sys_log(0, "            %s %d", st.c_str(), pQuestTable[i].lValue);
-			pkPC->SetFlag(st.c_str(), pQuestTable[i].lValue, false);
-		}
-
-		pkPC->SetLoaded();
-		pkPC->Build();
-
-		if (ch->GetDesc()->IsPhase(PHASE_GAME))
-		{
-			sys_log(0, "QUEST_LOAD: Login pc %d", pQuestTable[0].dwPID);
-			quest::CQuestManager::instance().Login(pQuestTable[0].dwPID);
-		}
-		else
-		{
-			quest_login_event_info* info = AllocEventInfo<quest_login_event_info>();
-			info->dwPID = ch->GetPlayerID();
-
-			event_create(quest_login_event, info, PASSES_PER_SEC(1));
-		}
-	}
-}
-
-void CInputDB::SafeboxLoad(LPDESC d, const char* c_pData)
-{
-	if (!d)
-		return;
-
-	TSafeboxTable* p = (TSafeboxTable*)c_pData;
-
-	if (d->GetAccountTable().id != p->dwID)
-	{
-		sys_err("SafeboxLoad: safebox has different id %u != %u", d->GetAccountTable().id, p->dwID);
-		return;
-	}
-
-	if (!d->GetCharacter())
-		return;
-
-	BYTE bSize = 1;
-
-	LPCHARACTER ch = d->GetCharacter();
-
-	// PREVENT_TRADE_WINDOW
-	if (ch->PreventTradeWindow(WND_SAFEBOX, true/*except*/))
-	{
-		d->GetCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른거래창이 열린상태에서는 창고를 열수가 없습니다."));
-		d->GetCharacter()->CancelSafeboxLoad();
-		return;
-	}
-	// END_PREVENT_TRADE_WINDOW
-
-	// ADD_PREMIUM
-	if (d->GetCharacter()->GetPremiumRemainSeconds(PREMIUM_SAFEBOX) > 0)
-		bSize = 3;
-	// END_OF_ADD_PREMIUM
-
-	if (d->GetCharacter()->IsEquipUniqueGroup(UNIQUE_GROUP_LARGE_SAFEBOX))
-		bSize = 3; // 창고확장권
-
-	//d->GetCharacter()->LoadSafebox(p->bSize * SAFEBOX_PAGE_SIZE, p->dwGold, p->wItemCount, (TPlayerItem *) (c_pData + sizeof(TSafeboxTable)));
-	d->GetCharacter()->LoadSafebox(bSize * SAFEBOX_PAGE_SIZE, p->dwGold, p->wItemCount, (TPlayerItem*)(c_pData + sizeof(TSafeboxTable)));
-#ifdef __GROWTH_PET_SYSTEM__
-	c_pData += sizeof(TSafeboxTable) + sizeof(TPlayerItem) * p->wItemCount;
-
-	WORD dwPetCount =*(WORD*)c_pData;
-	c_pData += sizeof(WORD);
-
-	d->GetCharacter()->GetSafebox()->LoadPet(dwPetCount, (TGrowthPet*)c_pData);
-#endif
-}
-
-void CInputDB::SafeboxChangeSize(LPDESC d, const char* c_pData)
-{
-	if (!d)
-		return;
-
-	BYTE bSize = *(BYTE*)c_pData;
-
-	if (!d->GetCharacter())
-		return;
-
-	d->GetCharacter()->ChangeSafeboxSize(bSize);
-}
-
-//
-// @version 05/06/20 Bang2ni - ReqSafeboxLoad 의 취소
-//
-void CInputDB::SafeboxWrongPassword(LPDESC d)
-{
-	if (!d)
-		return;
-
-	if (!d->GetCharacter())
-		return;
-
-	TPacketCGSafeboxWrongPassword p;
-	p.bHeader = HEADER_GC_SAFEBOX_WRONG_PASSWORD;
-	d->Packet(&p, sizeof(p));
-
-	d->GetCharacter()->CancelSafeboxLoad();
-}
-
-void CInputDB::SafeboxChangePasswordAnswer(LPDESC d, const char* c_pData)
-{
-	if (!d)
-		return;
-
-	if (!d->GetCharacter())
-		return;
-
-	TSafeboxChangePasswordPacketAnswer* p = (TSafeboxChangePasswordPacketAnswer*)c_pData;
-	if (p->flag)
-	{
-		d->GetCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 창고 비밀번호가 변경되었습니다."));
-		d->GetCharacter()->SetSafeboxBuff();
-	}
-	else
-	{
-		d->GetCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 기존 비밀번호가 틀렸습니다."));
-	}
-}
-
-void CInputDB::MallLoad(LPDESC d, const char* c_pData)
-{
-	if (!d)
-		return;
-
-	TSafeboxTable* p = (TSafeboxTable*)c_pData;
-
-	if (d->GetAccountTable().id != p->dwID)
-	{
-		sys_err("safebox has different id %u != %u", d->GetAccountTable().id, p->dwID);
-		return;
-	}
-
-	if (!d->GetCharacter())
-		return;
-
-	d->GetCharacter()->LoadMall(p->wItemCount, (TPlayerItem*)(c_pData + sizeof(TSafeboxTable)));
-}
-
-void CInputDB::LoginAlready(LPDESC d, const char* c_pData)
-{
-	if (!d)
-		return;
-
-	// INTERNATIONAL_VERSION 이미 접속중이면 접속 끊음
-	{
-		TPacketDGLoginAlready* p = (TPacketDGLoginAlready*)c_pData;
-
-		LPDESC d2 = DESC_MANAGER::instance().FindByLoginName(p->szLogin);
-
-		if (d2)
-			d2->DisconnectOfSameLogin();
-		else
-		{
-			TPacketGGDisconnect pgg;
-
-			pgg.bHeader = HEADER_GG_DISCONNECT;
-			strlcpy(pgg.szLogin, p->szLogin, sizeof(pgg.szLogin));
-
-			P2P_MANAGER::instance().Send(&pgg, sizeof(TPacketGGDisconnect));
-		}
-	}
-	// END_OF_INTERNATIONAL_VERSION
-
-	LoginFailure(d, "ALREADY");
-}
-
-void CInputDB::EmpireSelect(LPDESC d, const char* c_pData)
-{
-	sys_log(0, "EmpireSelect %p", get_pointer(d));
-
-	if (!d)
-		return;
-
-	TAccountTable& rTable = d->GetAccountTable();
-	rTable.bEmpire = *(BYTE*)c_pData;
-
-	TPacketGCEmpire pe;
-	pe.bHeader = HEADER_GC_EMPIRE;
-	pe.bEmpire = rTable.bEmpire;
-	d->Packet(&pe, sizeof(pe));
-
-	for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
-	{
-		if (rTable.players[i].dwID)
-		{
-			rTable.players[i].x = EMPIRE_START_X(rTable.bEmpire);
-			rTable.players[i].y = EMPIRE_START_Y(rTable.bEmpire);
-		}
-	}
-
-	GetServerLocation(d->GetAccountTable(), rTable.bEmpire);
-
-	d->SendLoginSuccessPacket();
-}
-
-void CInputDB::MapLocations(const char* c_pData)
-{
-	BYTE bCount = *(BYTE*)(c_pData++);
-
-	sys_log(0, "InputDB::MapLocations %d", bCount);
-
-	TMapLocation* pLoc = (TMapLocation*)c_pData;
-
-	while (bCount--)
-	{
-		for (int i = 0; i < MAX_MAP_ALLOW; ++i)
-		{
-			if (0 == pLoc->alMaps[i])
-				break;
-
-			CMapLocation::instance().Insert(pLoc->alMaps[i], pLoc->szHost, pLoc->wPort);
-		}
-
-		pLoc++;
-	}
-}
-
-void CInputDB::P2P(const char* c_pData)
-{
-	extern LPFDWATCH main_fdw;
-
-	TPacketDGP2P* p = (TPacketDGP2P*)c_pData;
-
-	P2P_MANAGER& mgr = P2P_MANAGER::instance();
-
-	if (false == DESC_MANAGER::instance().IsP2PDescExist(p->szHost, p->wPort))
-	{
-		LPCLIENT_DESC pkDesc = NULL;
-		sys_log(0, "InputDB:P2P %s:%u", p->szHost, p->wPort);
-		pkDesc = DESC_MANAGER::instance().CreateConnectionDesc(main_fdw, p->szHost, p->wPort, PHASE_P2P, false);
-		mgr.RegisterConnector(pkDesc);
-		pkDesc->SetP2P(p->szHost, p->wPort, p->bChannel);
-	}
-}
-
-void CInputDB::GuildLoad(const char* c_pData)
-{
-	CGuildManager::instance().LoadGuild(*(DWORD*)c_pData);
-}
-
-void CInputDB::GuildSkillUpdate(const char* c_pData)
-{
-	TPacketGuildSkillUpdate* p = (TPacketGuildSkillUpdate*)c_pData;
-
-	CGuild* g = CGuildManager::instance().TouchGuild(p->guild_id);
-
-	if (g)
-	{
-		g->UpdateSkill(p->skill_point, p->skill_levels);
-		g->GuildPointChange(POINT_SP, p->amount, p->save ? true : false);
-	}
-}
-
-void CInputDB::GuildWar(const char* c_pData)
-{
-	TPacketGuildWar* p = (TPacketGuildWar*)c_pData;
-
-	sys_log(0, "InputDB::GuildWar %u %u state %d", p->dwGuildFrom, p->dwGuildTo, p->bWar);
-
-	switch (p->bWar)
-	{
-		case GUILD_WAR_SEND_DECLARE:
-		case GUILD_WAR_RECV_DECLARE:
-			CGuildManager::instance().DeclareWar(p->dwGuildFrom, p->dwGuildTo, p->bType);
-			break;
-
-		case GUILD_WAR_REFUSE:
-			CGuildManager::instance().RefuseWar(p->dwGuildFrom, p->dwGuildTo);
-			break;
-
-		case GUILD_WAR_WAIT_START:
-			CGuildManager::instance().WaitStartWar(p->dwGuildFrom, p->dwGuildTo);
-			break;
-
-		case GUILD_WAR_CANCEL:
-			CGuildManager::instance().CancelWar(p->dwGuildFrom, p->dwGuildTo);
-			break;
-
-		case GUILD_WAR_ON_WAR:
-			CGuildManager::instance().StartWar(p->dwGuildFrom, p->dwGuildTo);
-			break;
-
-		case GUILD_WAR_END:
-			CGuildManager::instance().EndWar(p->dwGuildFrom, p->dwGuildTo);
-			break;
-
-		case GUILD_WAR_OVER:
-			CGuildManager::instance().WarOver(p->dwGuildFrom, p->dwGuildTo, p->bType);
-			break;
-
-		case GUILD_WAR_RESERVE:
-			CGuildManager::instance().ReserveWar(p->dwGuildFrom, p->dwGuildTo, p->bType);
-			break;
-
-		default:
-			sys_err("Unknown guild war state");
-			break;
-	}
-}
-
-void CInputDB::GuildWarScore(const char* c_pData)
-{
-	TPacketGuildWarScore* p = (TPacketGuildWarScore*)c_pData;
-	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuildGainPoint);
-	g->SetWarScoreAgainstTo(p->dwGuildOpponent, p->lScore);
-}
-
-void CInputDB::GuildSkillRecharge()
-{
-	CGuildManager::instance().SkillRecharge();
-}
-
-void CInputDB::GuildExpUpdate(const char* c_pData)
-{
-	TPacketGuildSkillUpdate* p = (TPacketGuildSkillUpdate*)c_pData;
-	sys_log(1, "GuildExpUpdate %d", p->amount);
-
-	CGuild* g = CGuildManager::instance().TouchGuild(p->guild_id);
-
-	if (g)
-		g->GuildPointChange(POINT_EXP, p->amount);
-}
-
-void CInputDB::GuildAddMember(const char* c_pData)
-{
-	TPacketDGGuildMember* p = (TPacketDGGuildMember*)c_pData;
-	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
-
-	if (g)
-		g->AddMember(p);
-}
-
-void CInputDB::GuildRemoveMember(const char* c_pData)
-{
-	TPacketGuild* p = (TPacketGuild*)c_pData;
-	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
-
-	if (g)
-		g->RemoveMember(p->dwInfo);
-}
-
-void CInputDB::GuildChangeGrade(const char* c_pData)
-{
-	TPacketGuild* p = (TPacketGuild*)c_pData;
-	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
-
-	if (g)
-		g->P2PChangeGrade((BYTE)p->dwInfo);
-}
-
-void CInputDB::GuildChangeMemberData(const char* c_pData)
-{
-	sys_log(0, "Recv GuildChangeMemberData");
-	TPacketGuildChangeMemberData* p = (TPacketGuildChangeMemberData*)c_pData;
-	CGuild* g = CGuildManager::instance().TouchGuild(p->guild_id);
-
-	if (g)
-		g->ChangeMemberData(p->pid, p->offer, p->level, p->grade);
-}
-
-void CInputDB::GuildDisband(const char* c_pData)
-{
-	TPacketGuild* p = (TPacketGuild*)c_pData;
-	CGuildManager::instance().DisbandGuild(p->dwGuild);
-}
-
-void CInputDB::GuildLadder(const char* c_pData)
-{
-	TPacketGuildLadder* p = (TPacketGuildLadder*)c_pData;
-	sys_log(0, "Recv GuildLadder %u %d / w %d d %d l %d", p->dwGuild, p->lLadderPoint, p->lWin, p->lDraw, p->lLoss);
-	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
-
-	g->SetLadderPoint(p->lLadderPoint);
-	g->SetWarData(p->lWin, p->lDraw, p->lLoss);
-}
-
-void CInputDB::ItemLoad(LPDESC d, const char* c_pData)
-{
-	LPCHARACTER ch;
-
-	if (!d || !(ch = d->GetCharacter()))
-		return;
-
-	if (ch->IsItemLoaded())
-		return;
-
-	DWORD dwCount = decode_4bytes(c_pData);
-	c_pData += sizeof(DWORD);
-
-	sys_log(0, "ITEM_LOAD: COUNT %s %u", ch->GetName(), dwCount);
-
-	std::vector<LPITEM> v;
-
-	TPlayerItem* p = (TPlayerItem*)c_pData;
-
-	for (DWORD i = 0; i < dwCount; ++i, ++p)
-	{
-		LPITEM item = ITEM_MANAGER::instance().CreateItem(p->dwVnum, p->dwCount, p->dwID);
-
-		if (!item)
-		{
-			sys_err("cannot create item by vnum %u (name %s id %u)", p->dwVnum, ch->GetName(), p->dwID);
-			continue;
-		}
-
-		item->SetSkipSave(true);
-#if defined(__SOUL_BIND_SYSTEM__)
-		item->SealItem(p->lSealDate);
-#endif
-		item->SetSockets(p->alSockets);
-		item->SetAttributes(p->aAttr);
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		item->SetTransmutationVnum(p->dwTransmutationVnum);
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		item->SetRefineElement(&p->RefineElement);
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-		item->SetRandomApplies(p->aApplyRandom);
-#endif
-#if defined(__SET_ITEM__)
-		item->SetItemSetValue(p->bSetValue);
-#endif
-
-		if ((p->bWindow == INVENTORY && ch->GetInventoryItem(p->wPos)) ||
-			(p->bWindow == EQUIPMENT && ch->GetEquipmentItem(p->wPos)))
-		{
-			sys_log(0, "ITEM_RESTORE: %s %s", ch->GetName(), item->GetName());
-			v.emplace_back(item);
-		}
-		else
-		{
-			switch (p->bWindow)
-			{
-				case INVENTORY:
-				case DRAGON_SOUL_INVENTORY:
-				case BELT_INVENTORY:
-#if defined(__ATTR_6TH_7TH__)
-				case NPC_STORAGE:
-#endif
-				{
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-					item->AddToCharacter(ch, TItemPos(p->bWindow, p->wPos), false);
-#else
-					item->AddToCharacter(ch, TItemPos(p->bWindow, p->wPos));
-#endif
-				}
-				break;
-
-				case EQUIPMENT:
-				{
-					if (item->CheckItemUseLevel(ch->GetLevel()) == true)
-					{
-						if (item->EquipTo(ch, p->wPos) == false)
-						{
-							v.emplace_back(item);
-						}
-					}
-					else
-					{
-						v.emplace_back(item);
-					}
-				}
-				break;
-			}
-		}
-
-		if (false == item->OnAfterCreatedItem())
-			sys_err("Failed to call ITEM::OnAfterCreatedItem (vnum: %d, id: %d)", item->GetVnum(), item->GetID());
-
-		item->SetSkipSave(false);
-	}
-
-	auto it = v.begin();
-	while (it != v.end())
-	{
-		LPITEM item = *(it++);
-
-		int pos = ch->GetEmptyInventory(item->GetSize());
-		if (pos < 0)
-		{
-			PIXEL_POSITION coord;
-			coord.x = ch->GetX();
-			coord.y = ch->GetY();
-
-			item->AddToGround(ch->GetMapIndex(), coord);
-			item->SetOwnership(ch, 180);
-			item->StartDestroyEvent();
-		}
-		else
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			item->AddToCharacter(ch, TItemPos(INVENTORY, pos), false);
-#else
-			item->AddToCharacter(ch, TItemPos(INVENTORY, pos));
-#endif
-	}
-
-#if defined(__WEAPON_COSTUME_SYSTEM__) && defined(__HIDE_WEAPON_COSTUME_WITH_NO_MAIN_WEAPON__)
-	if (ch->GetWear(WEAR_COSTUME_WEAPON) && !ch->GetWear(WEAR_WEAPON))
-		ch->SetPart(PART_WEAPON, 0);
-#endif
-
-	ch->CheckMaximumPoints();
-	ch->PointsPacket();
-
-	ch->SetItemLoaded();
-}
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-void CInputDB::ExtBattlePassLoad(LPDESC d, const char* c_pData)
-{
-	if (!d || !d->GetCharacter())
-		return;
-
-	LPCHARACTER ch = d->GetCharacter();
-	if (!ch)
-		return;
-
-	DWORD dwPID = decode_4bytes(c_pData);
-	c_pData += sizeof(DWORD);
-
-	DWORD dwCount = decode_4bytes(c_pData);
-	c_pData += sizeof(DWORD);
-
-	if (ch->GetPlayerID() != dwPID)
-		return;
-
-	ch->LoadExtBattlePass(dwCount, (TPlayerExtBattlePassMission*)c_pData);
-}
-#endif
-
-void CInputDB::AffectLoad(LPDESC d, const char* c_pData)
-{
-	if (!d)
-		return;
-
-	if (!d->GetCharacter())
-		return;
-
-	LPCHARACTER ch = d->GetCharacter();
-
-	DWORD dwPID = decode_4bytes(c_pData);
-	c_pData += sizeof(DWORD);
-
-	DWORD dwCount = decode_4bytes(c_pData);
-	c_pData += sizeof(DWORD);
-
-	if (ch->GetPlayerID() != dwPID)
-		return;
-
-	ch->LoadAffect(dwCount, (TPacketAffectElement*)c_pData);
-}
-
-void CInputDB::PartyCreate(const char* c_pData)
-{
-	TPacketPartyCreate* p = (TPacketPartyCreate*)c_pData;
-	CPartyManager::instance().P2PCreateParty(p->dwLeaderPID);
-}
-
-void CInputDB::PartyDelete(const char* c_pData)
-{
-	TPacketPartyDelete* p = (TPacketPartyDelete*)c_pData;
-	CPartyManager::instance().P2PDeleteParty(p->dwLeaderPID);
-}
-
-void CInputDB::PartyAdd(const char* c_pData)
-{
-	TPacketPartyAdd* p = (TPacketPartyAdd*)c_pData;
-	CPartyManager::instance().P2PJoinParty(p->dwLeaderPID, p->dwPID, p->bState);
-}
-
-void CInputDB::PartyRemove(const char* c_pData)
-{
-	TPacketPartyRemove* p = (TPacketPartyRemove*)c_pData;
-	CPartyManager::instance().P2PQuitParty(p->dwPID);
-}
-
-void CInputDB::PartyStateChange(const char* c_pData)
-{
-	TPacketPartyStateChange* p = (TPacketPartyStateChange*)c_pData;
-	LPPARTY pParty = CPartyManager::instance().P2PCreateParty(p->dwLeaderPID);
-
-	if (!pParty)
-		return;
-
-	pParty->SetRole(p->dwPID, p->bRole, p->bFlag);
-}
-
-void CInputDB::PartySetMemberLevel(const char* c_pData)
-{
-	TPacketPartySetMemberLevel* p = (TPacketPartySetMemberLevel*)c_pData;
-	LPPARTY pParty = CPartyManager::instance().P2PCreateParty(p->dwLeaderPID);
-
-	if (!pParty)
-		return;
-
-	pParty->P2PSetMemberLevel(p->dwPID, p->bLevel);
-}
-
-void CInputDB::Time(const char* c_pData)
-{
-	set_global_time(*(time_t*)c_pData);
-}
-
-void CInputDB::ReloadProto(const char* c_pData)
-{
-	WORD wSize;
-
-	/*
-	* Skill
-	*/
-
-	wSize = decode_2bytes(c_pData);
-	c_pData += sizeof(WORD);
-	if (wSize) CSkillManager::instance().Initialize((TSkillTable*)c_pData, wSize);
-	c_pData += sizeof(TSkillTable) * wSize;
-
-	/*
-	* Banwords
-	*/
-
-	wSize = decode_2bytes(c_pData);
-	c_pData += sizeof(WORD);
-	CBanwordManager::instance().Initialize((TBanwordTable*)c_pData, wSize);
-	c_pData += sizeof(TBanwordTable) * wSize;
-
-	/*
-	* ITEM
-	*/
-
-	wSize = decode_2bytes(c_pData);
-	c_pData += 2;
-	sys_log(0, "RELOAD: ITEM: %d", wSize);
-
-	if (wSize)
-	{
-		ITEM_MANAGER::instance().Initialize((TItemTable*)c_pData, wSize);
-		c_pData += wSize * sizeof(TItemTable);
-	}
-
-	/*
-	* MONSTER
-	*/
-
-	wSize = decode_2bytes(c_pData);
-	c_pData += 2;
-	sys_log(0, "RELOAD: MOB: %d", wSize);
-
-	if (wSize)
-	{
-		CMobManager::instance().Initialize((TMobTable*)c_pData, wSize);
-		c_pData += wSize * sizeof(TMobTable);
-	}
-
-	/*
-	* REFINE
-	*/
-
-	wSize = decode_2bytes(c_pData);
-	c_pData += 2;
-	sys_log(0, "RELOAD: REFINE: %d", wSize);
-
-	if (wSize)
-	{
-		CRefineManager::instance().Initialize((TRefineTable*)c_pData, wSize);
-		c_pData += wSize * sizeof(TRefineTable);
-	}
-
-#ifdef __GROWTH_PET_SYSTEM__
-	/*
-	* GROWTH PET SKILL
-	*/
-	wSize = decode_2bytes(c_pData);
-	c_pData += 2;
-	sys_log(0, "RELOAD: Growth Pet Skill: %d", wSize);
-
-	if (wSize)
-	{
-		CGrowthPetManager::instance().InitializeSkill((TGrowthPetSkillTable*)c_pData, wSize);
-		c_pData += wSize * sizeof(TGrowthPetSkillTable);
-	}
-#endif
-
-	CMotionManager::instance().Build();
-
-	CHARACTER_MANAGER::instance().for_each_pc(std::mem_fn(&CHARACTER::ComputePoints));
-}
-
-void CInputDB::GuildSkillUsableChange(const char* c_pData)
-{
-	TPacketGuildSkillUsableChange* p = (TPacketGuildSkillUsableChange*)c_pData;
-
-	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
-
-	g->SkillUsableChange(p->dwSkillVnum, p->bUsable ? true : false);
-}
-
-void CInputDB::AuthLogin(LPDESC d, const char* c_pData)
-{
-	if (!d)
-		return;
-
-	BYTE bResult = *(BYTE*)c_pData;
-
-	TPacketGCAuthSuccess ptoc;
-
-	ptoc.bHeader = HEADER_GC_AUTH_SUCCESS;
-
-	if (bResult)
-	{
-		// Panama 암호화 팩에 필요한 키 보내기
-		SendPanamaList(d);
-		ptoc.dwLoginKey = d->GetLoginKey();
-
-		// NOTE: AuthSucess보다 먼저 보내야지 안그러면 PHASE Close가 되서 보내지지 않는다.-_-
-		// Send Client Package CryptKey
-		{
-			DESC_MANAGER::instance().SendClientPackageCryptKey(d);
-			DESC_MANAGER::instance().SendClientPackageSDBToLoadMap(d, MAPNAME_DEFAULT);
-		}
-	}
-	else
-	{
-		ptoc.dwLoginKey = 0;
-	}
-
-	ptoc.bResult = bResult;
-
-	d->Packet(&ptoc, sizeof(TPacketGCAuthSuccess));
-	sys_log(0, "AuthLogin result %u key %u", bResult, d->GetLoginKey());
-}
-
-void CInputDB::ChangeEmpirePriv(const char* c_pData)
-{
-	TPacketDGChangeEmpirePriv* p = (TPacketDGChangeEmpirePriv*)c_pData;
-
-	// ADD_EMPIRE_PRIV_TIME
-	CPrivManager::instance().GiveEmpirePriv(p->empire, p->type, p->value, p->bLog, p->end_time_sec);
-	// END_OF_ADD_EMPIRE_PRIV_TIME
-}
-
-/**
-* @version 05/06/08 Bang2ni - 지속시간 추가
-**/
-void CInputDB::ChangeGuildPriv(const char* c_pData)
-{
-	TPacketDGChangeGuildPriv* p = (TPacketDGChangeGuildPriv*)c_pData;
-
-	// ADD_GUILD_PRIV_TIME
-	CPrivManager::instance().GiveGuildPriv(p->guild_id, p->type, p->value, p->bLog, p->end_time_sec);
-	// END_OF_ADD_GUILD_PRIV_TIME
-}
-
-void CInputDB::ChangeCharacterPriv(const char* c_pData)
-{
-	TPacketDGChangeCharacterPriv* p = (TPacketDGChangeCharacterPriv*)c_pData;
-	CPrivManager::instance().GiveCharacterPriv(p->pid, p->type, p->value, p->bLog);
-}
-
-void CInputDB::MoneyLog(const char* c_pData)
-{
-	TPacketMoneyLog* p = (TPacketMoneyLog*)c_pData;
-
-	if (p->type == 4) // QUEST_MONEY_LOG_SKIP
-		return;
-
-	if (g_bAuthServer == true)
-		return;
-
-	LogManager::instance().MoneyLog(p->type, p->vnum, p->gold
-#if defined(__CHEQUE_SYSTEM__)
-		, p->cheque
-#endif
-	);
-}
-
-void CInputDB::GuildMoneyChange(const char* c_pData)
-{
-	TPacketDGGuildMoneyChange* p = (TPacketDGGuildMoneyChange*)c_pData;
-
-	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
-	if (g)
-	{
-		g->RecvMoneyChange(p->iTotalGold);
-	}
-}
-
-void CInputDB::GuildWithdrawMoney(const char* c_pData)
-{
-	TPacketDGGuildMoneyWithdraw* p = (TPacketDGGuildMoneyWithdraw*)c_pData;
-
-	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
-	if (g)
-	{
-		g->RecvWithdrawMoneyGive(p->iChangeGold);
-	}
-}
-
-void CInputDB::SetEventFlag(const char* c_pData)
-{
-	TPacketSetEventFlag* p = (TPacketSetEventFlag*)c_pData;
-	quest::CQuestManager::instance().SetEventFlag(p->szFlagName, p->lValue);
-}
-
-void CInputDB::CreateObject(const char* c_pData)
-{
-	using namespace building;
-	CManager::instance().LoadObject((TObject*)c_pData);
-}
-
-void CInputDB::DeleteObject(const char* c_pData)
-{
-	using namespace building;
-	CManager::instance().DeleteObject(*(DWORD*)c_pData);
-}
-
-void CInputDB::UpdateLand(const char* c_pData)
-{
-	using namespace building;
-	CManager::instance().UpdateLand((TLand*)c_pData);
-}
-
-void CInputDB::Notice(const char* c_pData)
-{
-	extern void SendNotice(const char* c_pszBuf, const bool c_bBigFont = false);
-
-	char szBuf[256 + 1];
-	strlcpy(szBuf, c_pData, sizeof(szBuf));
-
-	sys_log(0, "InputDB:: Notice: %s", szBuf);
-
-	//SendNotice(LC_STRING(szBuf));
-	SendNotice(szBuf);
-}
-
-void CInputDB::GuildWarReserveAdd(TGuildWarReserve* p)
-{
-	CGuildManager::instance().ReserveWarAdd(p);
-}
-
-void CInputDB::GuildWarReserveDelete(DWORD dwID)
-{
-	CGuildManager::instance().ReserveWarDelete(dwID);
-}
-
-void CInputDB::GuildWarBet(TPacketGDGuildWarBet* p)
-{
-	CGuildManager::instance().ReserveWarBet(p);
-}
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-void CInputDB::GuildSetEventFlag(const char* c_pData)
-{
-	const TPacketSetGuildEventFlag* p = (TPacketSetGuildEventFlag*)c_pData;
-	CGuildManager::Instance().SetEventFlag(p->dwGuildID, p->szFlagName, p->lValue);
-}
-#endif
-
-void CInputDB::MarriageAdd(TPacketMarriageAdd* p)
-{
-	sys_log(0, "MarriageAdd %u %u %u %s %s", p->dwPID1, p->dwPID2, (DWORD)p->tMarryTime, p->szName1, p->szName2);
-	marriage::CManager::instance().Add(p->dwPID1, p->dwPID2, p->tMarryTime, p->szName1, p->szName2);
-}
-
-void CInputDB::MarriageUpdate(TPacketMarriageUpdate* p)
-{
-	sys_log(0, "MarriageUpdate %u %u %d %d", p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
-	marriage::CManager::instance().Update(p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
-}
-
-void CInputDB::MarriageRemove(TPacketMarriageRemove* p)
-{
-	sys_log(0, "MarriageRemove %u %u", p->dwPID1, p->dwPID2);
-	marriage::CManager::instance().Remove(p->dwPID1, p->dwPID2);
-}
-
-void CInputDB::WeddingRequest(TPacketWeddingRequest* p)
-{
-	marriage::WeddingManager::instance().Request(p->dwPID1, p->dwPID2);
-}
-
-void CInputDB::WeddingReady(TPacketWeddingReady* p)
-{
-	sys_log(0, "WeddingReady %u %u %u", p->dwPID1, p->dwPID2, p->dwMapIndex);
-	marriage::CManager::instance().WeddingReady(p->dwPID1, p->dwPID2, p->dwMapIndex);
-}
-
-void CInputDB::WeddingStart(TPacketWeddingStart* p)
-{
-	sys_log(0, "WeddingStart %u %u", p->dwPID1, p->dwPID2);
-	marriage::CManager::instance().WeddingStart(p->dwPID1, p->dwPID2);
-}
-
-void CInputDB::WeddingEnd(TPacketWeddingEnd* p)
-{
-	sys_log(0, "WeddingEnd %u %u", p->dwPID1, p->dwPID2);
-	marriage::CManager::instance().WeddingEnd(p->dwPID1, p->dwPID2);
-}
-
-// MYSHOP_PRICE_LIST
-void CInputDB::MyshopPricelistRes(LPDESC d, const TPacketMyshopPricelistHeader* p)
-{
-	LPCHARACTER ch;
-
-	if (!d || !(ch = d->GetCharacter()))
-		return;
-
-	sys_log(0, "RecvMyshopPricelistRes name[%s]", ch->GetName());
-	ch->UseSilkBotaryReal(p);
-
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-// RELOAD_ADMIN
-void CInputDB::ReloadAdmin(const char* c_pData)
-{
-	gm_new_clear();
-	int ChunkSize = decode_2bytes(c_pData);
-	c_pData += 2;
-	int HostSize = decode_2bytes(c_pData);
-	c_pData += 2;
-
-	for (int n = 0; n < HostSize; ++n)
-	{
-		gm_new_host_inert(c_pData);
-		c_pData += ChunkSize;
-	}
-
-	c_pData += 2;
-	int size = decode_2bytes(c_pData);
-	c_pData += 2;
-
-	for (int n = 0; n < size; ++n)
-	{
-		tAdminInfo& rAdminInfo = *(tAdminInfo*)c_pData;
-
-		gm_new_insert(rAdminInfo);
-
-		c_pData += sizeof(tAdminInfo);
-
-		LPCHARACTER pChar = CHARACTER_MANAGER::instance().FindPC(rAdminInfo.m_szName);
-		if (pChar)
-		{
-			pChar->SetGMLevel();
-		}
-	}
-}
-// END_RELOAD_ADMIN
-
-////////////////////////////////////////////////////////////////////
-// Analyze
-// @version 05/06/10 Bang2ni - 아이템 가격정보 리스트 패킷(HEADER_DG_MYSHOP_PRICELIST_RES) 처리루틴 추가.
-////////////////////////////////////////////////////////////////////
-int CInputDB::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
-{
-	switch (bHeader)
-	{
-		case HEADER_DG_BOOT:
-			Boot(c_pData);
-			break;
-
-		case HEADER_DG_LOGIN_SUCCESS:
-			LoginSuccess(m_dwHandle, c_pData);
-			break;
-
-		case HEADER_DG_LOGIN_NOT_EXIST:
-			LoginFailure(DESC_MANAGER::instance().FindByHandle(m_dwHandle), "NOID");
-			break;
-
-		case HEADER_DG_LOGIN_WRONG_PASSWD:
-			LoginFailure(DESC_MANAGER::instance().FindByHandle(m_dwHandle), "WRONGPWD");
-			break;
-
-		case HEADER_DG_LOGIN_ALREADY:
-			LoginAlready(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_PLAYER_LOAD_SUCCESS:
-			PlayerLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_PLAYER_CREATE_SUCCESS:
-			PlayerCreateSuccess(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_PLAYER_CREATE_FAILED:
-			PlayerCreateFailure(DESC_MANAGER::instance().FindByHandle(m_dwHandle), 0);
-			break;
-
-		case HEADER_DG_PLAYER_CREATE_ALREADY:
-			PlayerCreateFailure(DESC_MANAGER::instance().FindByHandle(m_dwHandle), 1);
-			break;
-
-		case HEADER_DG_PLAYER_DELETE_SUCCESS:
-			PlayerDeleteSuccess(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_PLAYER_LOAD_FAILED:
-			//sys_log(0, "PLAYER_LOAD_FAILED");
-			break;
-
-		case HEADER_DG_PLAYER_DELETE_FAILED:
-			//sys_log(0, "PLAYER_DELETE_FAILED");
-#if defined(__DELETE_FAILURE_TYPE__)
-			PlayerDeleteFail(DESC_MANAGER::Instance().FindByHandle(m_dwHandle), c_pData);
-#else
-			PlayerDeleteFail(DESC_MANAGER::instance().FindByHandle(m_dwHandle));
-#endif
-			break;
-
-		case HEADER_DG_ITEM_LOAD:
-			ItemLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_QUEST_LOAD:
-			QuestLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_AFFECT_LOAD:
-			AffectLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_SAFEBOX_LOAD:
-			SafeboxLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_SAFEBOX_CHANGE_SIZE:
-			SafeboxChangeSize(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_SAFEBOX_WRONG_PASSWORD:
-			SafeboxWrongPassword(DESC_MANAGER::instance().FindByHandle(m_dwHandle));
-			break;
-
-		case HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER:
-			SafeboxChangePasswordAnswer(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_MALL_LOAD:
-			MallLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_EMPIRE_SELECT:
-			EmpireSelect(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_MAP_LOCATIONS:
-			MapLocations(c_pData);
-			break;
-
-		case HEADER_DG_P2P:
-			P2P(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_SKILL_UPDATE:
-			GuildSkillUpdate(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_LOAD:
-			GuildLoad(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_SKILL_RECHARGE:
-			GuildSkillRecharge();
-			break;
-
-		case HEADER_DG_GUILD_EXP_UPDATE:
-			GuildExpUpdate(c_pData);
-			break;
-
-		case HEADER_DG_PARTY_CREATE:
-			PartyCreate(c_pData);
-			break;
-
-		case HEADER_DG_PARTY_DELETE:
-			PartyDelete(c_pData);
-			break;
-
-		case HEADER_DG_PARTY_ADD:
-			PartyAdd(c_pData);
-			break;
-
-		case HEADER_DG_PARTY_REMOVE:
-			PartyRemove(c_pData);
-			break;
-
-		case HEADER_DG_PARTY_STATE_CHANGE:
-			PartyStateChange(c_pData);
-			break;
-
-		case HEADER_DG_PARTY_SET_MEMBER_LEVEL:
-			PartySetMemberLevel(c_pData);
-			break;
-
-		case HEADER_DG_TIME:
-			Time(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_ADD_MEMBER:
-			GuildAddMember(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_REMOVE_MEMBER:
-			GuildRemoveMember(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_CHANGE_GRADE:
-			GuildChangeGrade(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_CHANGE_MEMBER_DATA:
-			GuildChangeMemberData(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_DISBAND:
-			GuildDisband(c_pData);
-			break;
-
-		case HEADER_DG_RELOAD_PROTO:
-			ReloadProto(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_WAR:
-			GuildWar(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_WAR_SCORE:
-			GuildWarScore(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_LADDER:
-			GuildLadder(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_SKILL_USABLE_CHANGE:
-			GuildSkillUsableChange(c_pData);
-			break;
-
-		case HEADER_DG_CHANGE_NAME:
-			ChangeName(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_AUTH_LOGIN:
-			AuthLogin(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_CHANGE_EMPIRE_PRIV:
-			ChangeEmpirePriv(c_pData);
-			break;
-
-		case HEADER_DG_CHANGE_GUILD_PRIV:
-			ChangeGuildPriv(c_pData);
-			break;
-
-		case HEADER_DG_CHANGE_CHARACTER_PRIV:
-			ChangeCharacterPriv(c_pData);
-			break;
-
-		case HEADER_DG_MONEY_LOG:
-			MoneyLog(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_WITHDRAW_MONEY_GIVE:
-			GuildWithdrawMoney(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_MONEY_CHANGE:
-			GuildMoneyChange(c_pData);
-			break;
-
-		case HEADER_DG_SET_EVENT_FLAG:
-			SetEventFlag(c_pData);
-			break;
-
-		case HEADER_DG_CREATE_OBJECT:
-			CreateObject(c_pData);
-			break;
-
-		case HEADER_DG_DELETE_OBJECT:
-			DeleteObject(c_pData);
-			break;
-
-		case HEADER_DG_UPDATE_LAND:
-			UpdateLand(c_pData);
-			break;
-
-		case HEADER_DG_NOTICE:
-			Notice(c_pData);
-			break;
-
-		case HEADER_DG_GUILD_WAR_RESERVE_ADD:
-			GuildWarReserveAdd((TGuildWarReserve*)c_pData);
-			break;
-
-		case HEADER_DG_GUILD_WAR_RESERVE_DEL:
-			GuildWarReserveDelete(*(DWORD*)c_pData);
-			break;
-
-		case HEADER_DG_GUILD_WAR_BET:
-			GuildWarBet((TPacketGDGuildWarBet*)c_pData);
-			break;
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-		case HEADER_DG_GUILD_EVENT_FLAG:
-			GuildSetEventFlag(c_pData);
-			break;
-#endif
-
-		case HEADER_DG_MARRIAGE_ADD:
-			MarriageAdd((TPacketMarriageAdd*)c_pData);
-			break;
-
-		case HEADER_DG_MARRIAGE_UPDATE:
-			MarriageUpdate((TPacketMarriageUpdate*)c_pData);
-			break;
-
-		case HEADER_DG_MARRIAGE_REMOVE:
-			MarriageRemove((TPacketMarriageRemove*)c_pData);
-			break;
-
-		case HEADER_DG_WEDDING_REQUEST:
-			WeddingRequest((TPacketWeddingRequest*)c_pData);
-			break;
-
-		case HEADER_DG_WEDDING_READY:
-			WeddingReady((TPacketWeddingReady*)c_pData);
-			break;
-
-		case HEADER_DG_WEDDING_START:
-			WeddingStart((TPacketWeddingStart*)c_pData);
-			break;
-
-		case HEADER_DG_WEDDING_END:
-			WeddingEnd((TPacketWeddingEnd*)c_pData);
-			break;
-
-			// MYSHOP_PRICE_LIST
-		case HEADER_DG_MYSHOP_PRICELIST_RES:
-			MyshopPricelistRes(DESC_MANAGER::instance().FindByHandle(m_dwHandle), (TPacketMyshopPricelistHeader*)c_pData);
-			break;
-			// END_OF_MYSHOP_PRICE_LIST
-
-			// RELOAD_ADMIN
-		case HEADER_DG_RELOAD_ADMIN:
-			ReloadAdmin(c_pData);
-			break;
-			// END_RELOAD_ADMIN
-
-		case HEADER_DG_ADD_MONARCH_MONEY:
-			AddMonarchMoney(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_DEC_MONARCH_MONEY:
-			DecMonarchMoney(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_TAKE_MONARCH_MONEY:
-			TakeMonarchMoney(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_CHANGE_MONARCH_LORD_ACK:
-			ChangeMonarchLord((TPacketChangeMonarchLordACK*)c_pData);
-			break;
-
-		case HEADER_DG_UPDATE_MONARCH_INFO:
-			UpdateMonarchInfo((TMonarchInfo*)c_pData);
-			break;
-
-		case HEADER_DG_BLOCK_COUNTRY_IP:
-			this->AddBlockCountryIp((TPacketBlockCountryIp*)c_pData);
-			break;
-		case HEADER_DG_BLOCK_EXCEPTION:
-			this->BlockException((TPacketBlockException*)c_pData);
-			break;
-
-		case HEADER_DG_ACK_CHANGE_GUILD_MASTER:
-			this->GuildChangeMaster((TPacketChangeGuildMaster*)c_pData);
-			break;
-
-		case HEADER_DG_ACK_SPARE_ITEM_ID_RANGE:
-			ITEM_MANAGER::instance().SetMaxSpareItemID(*((TItemIDRangeTable*)c_pData));
-			break;
-
-		case HEADER_DG_UPDATE_HORSE_NAME:
-		case HEADER_DG_ACK_HORSE_NAME:
-			CHorseNameManager::instance().UpdateHorseName(
-				((TPacketUpdateHorseName*)c_pData)->dwPlayerID,
-				((TPacketUpdateHorseName*)c_pData)->szHorseName);
-			break;
-
-		case HEADER_DG_NEED_LOGIN_LOG:
-			DetailLog((TPacketNeedLoginLogInfo*)c_pData);
-			break;
-
-			// 독일 선물 기능 테스트
-		case HEADER_DG_ITEMAWARD_INFORMER:
-			ItemAwardInformer((TPacketItemAwardInfromer*)c_pData);
-			break;
-
-		case HEADER_DG_RESPOND_CHANNELSTATUS:
-			RespondChannelStatus(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-#if defined(__MOVE_CHANNEL__)
-		case HEADER_DG_CHANNEL_RESULT:
-			MoveChannel(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-#endif
-
-#if defined(__MAILBOX__)
-		case HEADER_DG_RESPOND_MAILBOX_LOAD:
-			MailBoxRespondLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_RESPOND_MAILBOX_CHECK_NAME:
-			MailBoxRespondName(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_RESPOND_MAILBOX_UNREAD:
-			MailBoxRespondUnreadData(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-#endif
-
-#if defined(__GEM_SHOP__)
-		case HEADER_DG_GEM_SHOP_LOAD:
-			GemShopLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_GEM_SHOP_UPDATE:
-			GemShopUpdate(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-		case HEADER_DG_EMOTE_LOAD:
-			EmoteLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_EMOTE_GET:
-			EmoteGet(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-#endif
-
-#ifdef __SHOP_SEARCH__
-		case HEADER_DG_SHOP_SEARCH_RESULT:
-		{
-			LPDESC chDesc = DESC_MANAGER::instance().FindByHandle(m_dwHandle);
-			if (!chDesc || !chDesc->GetCharacter())
-				break;
-
-			WORD maxPageNum = *(WORD*)c_pData;
-			c_pData += sizeof(WORD);
-			WORD itemCount = *(WORD*)c_pData;
-			c_pData += sizeof(WORD);
-
-			CShopSearchManager::DB_ResultSearch(chDesc->GetCharacter(), maxPageNum, (const TShopSearchClientItem*)c_pData, itemCount);
-		}
-		break;
-
-		case HEADER_DG_SHOP_SEARCH_BUY_FROM_SHOP:
-			CShopSearchManager::DB_BuyFromShop((const TPacketDGShopSearchBuyFromShop*)c_pData);
-			break;
-
-		case HEADER_DG_SHOP_SEARCH_BUY_RESULT:
-			CShopSearchManager::DB_BuyResult(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-
-		case HEADER_DG_SHOP_SEARCH_SOLD_INFO:
-		{
-			LPDESC chDesc = DESC_MANAGER::instance().FindByHandle(m_dwHandle);
-			if (!chDesc || !chDesc->GetCharacter())
-				break;
-
-			bool hasResults = *(bool*)c_pData;
-			c_pData += sizeof(bool);
-
-			CShopSearchManager::DB_SoldInfo(chDesc->GetCharacter(), hasResults, (const TShopSearchSoldItemInfo*)c_pData);
-		}
-		break;
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-		case HEADER_DG_GROWTH_PET_LOAD:
-			GrowthPetLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-#endif
-
-#ifdef __OFFLINE_SHOP__
-		case HEADER_DG_RESPOND_OFFLINE_SHOP_ID:
-			RespondOfflineShopId(c_pData);
-			break;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		case HEADER_DG_EXT_BATTLE_PASS_LOAD:
-			ExtBattlePassLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
-			break;
-#endif
-
-		default:
-			return (-1);
-	}
-
-	return 0;
-}
-
-bool CInputDB::Process(LPDESC d, const void* orig, int bytes, int& r_iBytesProceed)
-{
-	const char* c_pData = (const char*)orig;
-	BYTE bHeader, bLastHeader = 0;
-	int iSize;
-	int iLastPacketLen = 0;
-
-	for (m_iBufferLeft = bytes; m_iBufferLeft > 0;)
-	{
-		if (m_iBufferLeft < 9)
-			return true;
-
-		bHeader = *((BYTE*)(c_pData)); // 1
-		m_dwHandle = *((DWORD*)(c_pData + 1)); // 4
-		iSize = *((DWORD*)(c_pData + 5)); // 4
-
-		sys_log(1, "DBCLIENT: header %d handle %d size %d bytes %d", bHeader, m_dwHandle, iSize, bytes);
-
-		if (m_iBufferLeft - 9 < iSize)
-			return true;
-
-		const char* pRealData = (c_pData + 9);
-
-		if (Analyze(d, bHeader, pRealData) < 0)
-		{
-			sys_err("in InputDB: UNKNOWN HEADER: %d, LAST HEADER: %d(%d), REMAIN BYTES: %d, DESC: %d",
-				bHeader, bLastHeader, iLastPacketLen, m_iBufferLeft, d->GetSocket());
-
-			// printdata((BYTE*) orig, bytes);
-			// d->SetPhase(PHASE_CLOSE);
-		}
-
-		c_pData += 9 + iSize;
-		m_iBufferLeft -= 9 + iSize;
-		r_iBytesProceed += 9 + iSize;
-
-		iLastPacketLen = 9 + iSize;
-		bLastHeader = bHeader;
-	}
-
-	return true;
-}
-
-void CInputDB::AddMonarchMoney(LPDESC d, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	CMonarch::instance().AddMoney(Money, Empire);
-
-	DWORD pid = CMonarch::instance().GetMonarchPID(Empire);
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
-
-	if (ch)
-	{
-		if (number(1, 100) > 95)
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("현재 %s 국고에는 %u 의 돈이 있습니다", EMPIRE_NAME(Empire), CMonarch::instance().GetMoney(Empire)));
-	}
-}
-
-void CInputDB::DecMonarchMoney(LPDESC d, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	CMonarch::instance().DecMoney(Money, Empire);
-
-	DWORD pid = CMonarch::instance().GetMonarchPID(Empire);
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
-
-	if (ch)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("현재 %s 국고에는 %d 의 돈이 있습니다", EMPIRE_NAME(Empire), CMonarch::instance().GetMoney(Empire)));
-	}
-}
-
-void CInputDB::TakeMonarchMoney(LPDESC d, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	if (!CMonarch::instance().DecMoney(Money, Empire))
-	{
-		if (!d)
-			return;
-
-		if (!d->GetCharacter())
-			return;
-
-		LPCHARACTER ch = d->GetCharacter();
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("국고에 돈이 부족하거나 돈을 가져올수 없는 상황입니다"));
-	}
-}
-
-void CInputDB::ChangeMonarchLord(TPacketChangeMonarchLordACK* info)
-{
-	char notice[256];
-	snprintf(notice, sizeof(notice), LC_STRING("%s의 군주가 %s 님으로 교체되었습니다.", EMPIRE_NAME(info->bEmpire), info->szName));
-	SendNotice(notice);
-}
-
-void CInputDB::UpdateMonarchInfo(TMonarchInfo* info)
-{
-	CMonarch::instance().SetMonarchInfo(info);
-	sys_log(0, "MONARCH INFO UPDATED");
-}
-
-void CInputDB::AddBlockCountryIp(TPacketBlockCountryIp* data)
-{
-	add_blocked_country_ip(data);
-}
-
-void CInputDB::BlockException(TPacketBlockException* data)
-{
-	block_exception(data);
-}
-
-void CInputDB::GuildChangeMaster(TPacketChangeGuildMaster* p)
-{
-	CGuildManager::instance().ChangeMaster(p->dwGuildID);
-}
-
-void CInputDB::DetailLog(const TPacketNeedLoginLogInfo* info)
-{
-	if (true == LC_IsEurope() || true == LC_IsYMIR() || true == LC_IsKorea())
-	{
-		LPCHARACTER pChar = CHARACTER_MANAGER::instance().FindByPID(info->dwPlayerID);
-
-		if (NULL != pChar)
-		{
-			LogManager::instance().DetailLoginLog(true, pChar);
-		}
-	}
-}
-
-void CInputDB::ItemAwardInformer(TPacketItemAwardInfromer* data)
-{
-	LPDESC d = DESC_MANAGER::instance().FindByLoginName(data->login); // login 정보
-
-	if (d == NULL)
-		return;
-
-	if (d->GetCharacter())
-	{
-		LPCHARACTER ch = d->GetCharacter();
-		ch->SetItemAward_vnum(data->vnum); // ch 에 임시 저장해놨다가 QuestLoad 함수에서 처리
-		ch->SetItemAward_cmd(data->command);
-
-		if (d->IsPhase(PHASE_GAME)) // 게임페이즈일때
-		{
-			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("You have recieved a gift! Check your Item Shop-Storeroom."));
-			ch->ChatPacket(CHAT_TYPE_COMMAND, "gift");
-
-			quest::CQuestManager::instance().ItemInformer(ch->GetPlayerID(), ch->GetItemAward_vnum()); // questmanager 호출
-		}
-	}
-}
-
-void CInputDB::RespondChannelStatus(LPDESC desc, const char* pcData)
-{
-	if (!desc)
-		return;
-
-	const int nSize = decode_4bytes(pcData);
-	pcData += sizeof(nSize);
-
-	BYTE bHeader = HEADER_GC_RESPOND_CHANNELSTATUS;
-	desc->BufferedPacket(&bHeader, sizeof(BYTE));
-	desc->BufferedPacket(&nSize, sizeof(nSize));
-	if (0 < nSize)
-	{
-		desc->BufferedPacket(pcData, sizeof(TChannelStatus) * nSize);
-	}
-
-	BYTE bSuccess = 1;
-	desc->Packet(&bSuccess, sizeof(bSuccess));
-	desc->SetChannelStatusRequested(false);
-}
-
-#if defined(__MOVE_CHANNEL__)
-void CInputDB::MoveChannel(LPDESC d, const char* pcData)
-{
-	if (!d || !d->GetCharacter())
-	{
-		sys_err("Change channel request with empty or invalid description handle!");
-		return;
-	}
-
-	TPacketReturnChannel* p = (TPacketReturnChannel*)pcData;
-
-	if (!p->lAddr || !p->wPort)
-	{
-		std::string pName = d->GetCharacter()->GetName();
-		d->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Cannot change channel."));
-		sys_err("Can't move channel for player %s!", pName.c_str());
-		return;
-	}
-
-	d->GetCharacter()->StartMoveChannel(p->lAddr, p->wPort);
-}
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-void CInputDB::EmoteLoad(LPDESC pDesc, const char* c_pData)
-{
-	if (pDesc == nullptr)
-		return;
-
-	const LPCHARACTER pkChar = pDesc->GetCharacter();
-	if (pkChar == nullptr)
-		return;
-
-	WORD wSize;
-	if (decode_2bytes(c_pData) != sizeof(TPacketGDEmote))
-	{
-		sys_err("emotion table size error");
-		return;
-	}
-
-	c_pData += 2;
-	wSize = decode_2bytes(c_pData);
-	c_pData += 2;
-
-	pkChar->SetEmotes((TPacketGDEmote*)c_pData, wSize);
-}
-
-void CInputDB::EmoteGet(LPDESC pDesc, const char* c_pData)
-{
-	const TPacketGDEmote* pPacket = reinterpret_cast<const TPacketGDEmote*>(c_pData);
-	if (pPacket == nullptr || pDesc == nullptr)
-		return;
-
-	TPacketGCEmote GCPacket;
-	GCPacket.bHeader = HEADER_GC_EMOTE;
-	GCPacket.bSubHeader = SUBHEADER_EMOTE_ADD;
-	GCPacket.dwEmoteVnum = pPacket->dwVnum;
-	GCPacket.dwDuration = pPacket->dwDuration;
-	pDesc->Packet(&GCPacket, sizeof(TPacketGCEmote));
-}
-#endif
-
-#if defined(__MAILBOX__)
-void CInputDB::MailBoxRespondLoad(LPDESC d, const char* c_pData)
-{
-	if (!d)
-		return;
-
-	const LPCHARACTER ch = d->GetCharacter();
-	if (ch == nullptr)
-		return;
-
-	WORD size;
-
-	if (decode_2bytes(c_pData) != sizeof(TMailBoxTable))
-	{
-		sys_err("mailbox table size error");
-		return;
-	}
-
-	c_pData += 2;
-	size = decode_2bytes(c_pData);
-	c_pData += 2;
-
-	CMailBox::Create(ch, (TMailBoxTable*)c_pData, size);
-}
-
-void CInputDB::MailBoxRespondName(LPDESC d, const char* c_pData)
-{
-	if (d == nullptr)
-		return;
-
-	const LPCHARACTER ch = d->GetCharacter();
-	if (ch == nullptr)
-		return;
-
-	CMailBox* mail = ch->GetMailBox();
-	if (mail == nullptr)
-		return;
-
-	mail->CheckPlayerResult((TMailBox*)c_pData);
-}
-
-void CInputDB::MailBoxRespondUnreadData(LPDESC d, const char* c_pData)
-{
-	if (d == nullptr)
-		return;
-
-	CMailBox::ResultUnreadData(d->GetCharacter(), (TMailBoxRespondUnreadData*)c_pData);
-}
-#endif
-
-#if defined(__GEM_SHOP__)
-void CInputDB::GemShopLoad(LPDESC lpDesc, const char* c_pszData)
-{
-	if (!lpDesc)
-		return;
-
-	const LPCHARACTER c_lpCh = lpDesc->GetCharacter();
-	if (c_lpCh == nullptr)
-		return;
-
-	CGemShop::Create(c_lpCh, (TGemShopTable*)c_pszData);
-}
-
-void CInputDB::GemShopUpdate(LPDESC lpDesc, const char* c_pszData)
-{
-	if (!lpDesc)
-		return;
-
-	const LPCHARACTER c_lpCh = lpDesc->GetCharacter();
-	if (c_lpCh == nullptr)
-		return;
-
-	CGemShop* pGemShop = c_lpCh->GetGemShop();
-	if (pGemShop == nullptr)
-		return;
-
-	pGemShop->Update((TGemShopTable*)c_pszData);
-}
-#endif
-
-#ifdef __OFFLINE_SHOP__
-void CInputDB::RespondOfflineShopId(const char* data)
-{
-	auto queueId = *reinterpret_cast<const uint32_t*>(data);
-	auto shopId = *reinterpret_cast<const uint32_t*>(data + sizeof(uint32_t));
-
-	COfflineShop::DequeueCreate(queueId, shopId);
-}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-void CInputDB::GrowthPetLoad(LPDESC d, const char* c_pData)
-{
-	LPCHARACTER ch;
-
-	if (!d || !(ch = d->GetCharacter()))
-		return;
-
-	if (ch->IsGrowthPetLoaded())
-		return;
-
-	DWORD dwCount = decode_4bytes(c_pData);
-	c_pData += sizeof(DWORD);
-
-	sys_log(0, "GROWTH_PET_LOAD: COUNT %s %u", ch->GetName(), dwCount);
-
-	TGrowthPet* p = (TGrowthPet*)c_pData;
-
-	for (DWORD i = 0; i < dwCount; ++i, ++p)
-	{
-		LPGROWTH_PET pPet = CGrowthPetManager::Instance().CreateGrowthPet(ch, p->dwID);
-		if (pPet)
-		{
-			pPet->SetGrowthPetProto(p);
-			ch->SetGrowthPet(pPet);
-		}
-	}
-
-	ch->SetGrowthPetLoaded(true);
-}
-#endif
+#include "stdafx.h" 
+#include "constants.h"
+#include "config.h"
+#include "utils.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "item.h"
+#include "item_manager.h"
+#include "packet.h"
+#include "protocol.h"
+#include "mob_manager.h"
+#include "shop_manager.h"
+#include "sectree_manager.h"
+#include "skill.h"
+#include "questmanager.h"
+#include "p2p.h"
+#include "guild.h"
+#include "guild_manager.h"
+#include "start_position.h"
+#include "party.h"
+#include "refine.h"
+#include "banword.h"
+#include "priv_manager.h"
+#include "db.h"
+#include "building.h"
+#include "login_sim.h"
+#include "wedding.h"
+#include "login_data.h"
+#include "unique_item.h"
+
+#include "monarch.h"
+#include "affect.h"
+#include "castle.h"
+#include "block_country.h"
+#include "motion.h"
+
+#include "dev_log.h"
+
+#include "log.h"
+
+#include "horsename_manager.h"
+#include "pcbang.h"
+#include "gm.h"
+#include "panama.h"
+#include "map_location.h"
+
+#include "DragonSoul.h"
+#if defined(__CUBE_RENEWAL__)
+#include "cube.h"
+#endif
+
+#if defined(__MT_THUNDER_DUNGEON__)
+#include "mt_thunder_dungeon.h"
+#endif
+
+#if defined(__MAILBOX__)
+#	include "MailBox.h"
+#endif
+
+#ifdef __OFFLINE_SHOP__
+#include "OfflineShop.h"
+#include "DynamicPacket.h"
+#endif
+
+#if defined(__SHOP_SEARCH__)
+	#include "ShopSearchManager.h"
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+#include "battlepass_manager.h"
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	sys_log(0, "sizeof(TGrowthPetSkillTable) = %d", sizeof(TGrowthPetSkillTable));
+#endif
+
+extern BYTE g_bAuthServer;
+
+extern void gm_insert(const char* name, BYTE level);
+extern BYTE gm_get_level(const char* name, const char* host, const char* account);
+extern void gm_host_insert(const char* host);
+
+#define MAPNAME_DEFAULT "none"
+
+bool GetServerLocation(TAccountTable& rTab, BYTE bEmpire)
+{
+	bool bFound = false;
+
+	for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
+	{
+		if (0 == rTab.players[i].dwID)
+			continue;
+
+		bFound = true;
+		long lIndex = 0;
+
+		if (!CMapLocation::instance().Get(rTab.players[i].x,
+			rTab.players[i].y,
+			lIndex,
+			rTab.players[i].lAddr,
+			rTab.players[i].wPort))
+		{
+			sys_err("location error name %s mapindex %d %d x %d empire %d",
+				rTab.players[i].szName, lIndex, rTab.players[i].x, rTab.players[i].y, rTab.bEmpire);
+
+			rTab.players[i].x = EMPIRE_START_X(rTab.bEmpire);
+			rTab.players[i].y = EMPIRE_START_Y(rTab.bEmpire);
+
+			lIndex = 0;
+
+			if (!CMapLocation::instance().Get(rTab.players[i].x, rTab.players[i].y, lIndex, rTab.players[i].lAddr, rTab.players[i].wPort))
+			{
+				sys_err("cannot find server for mapindex %d %d x %d (name %s)",
+					lIndex,
+					rTab.players[i].x,
+					rTab.players[i].y,
+					rTab.players[i].szName);
+
+#if defined(__PROXY_IP__)
+				if (!g_stProxyIP.empty())
+					rTab.players[i].lAddr = inet_addr(g_stProxyIP.c_str());
+#endif
+
+				continue;
+			}
+		}
+
+#if defined(__PROXY_IP__)
+		if (!g_stProxyIP.empty())
+			rTab.players[i].lAddr = inet_addr(g_stProxyIP.c_str());
+#endif
+
+		struct in_addr in;
+		in.s_addr = rTab.players[i].lAddr;
+		sys_log(0, "success to %s:%d", inet_ntoa(in), rTab.players[i].wPort);
+	}
+
+	return bFound;
+}
+
+extern std::map<DWORD, CLoginSim*> g_sim;
+extern std::map<DWORD, CLoginSim*> g_simByPID;
+
+void CInputDB::LoginSuccess(DWORD dwHandle, const char* data)
+{
+	sys_log(0, "LoginSuccess");
+
+	TAccountTable* pTab = (TAccountTable*)data;
+
+	auto it = g_sim.find(pTab->id);
+	if (g_sim.end() != it)
+	{
+		sys_log(0, "CInputDB::LoginSuccess - already exist sim [%s]", pTab->login);
+		it->second->SendLoad();
+		return;
+	}
+
+	LPDESC d = DESC_MANAGER::instance().FindByHandle(dwHandle);
+
+	if (!d)
+	{
+		sys_log(0, "CInputDB::LoginSuccess - cannot find handle [%s]", pTab->login);
+
+		TLogoutPacket pack;
+
+		strlcpy(pack.login, pTab->login, sizeof(pack.login));
+		db_clientdesc->DBPacket(HEADER_GD_LOGOUT, dwHandle, &pack, sizeof(pack));
+		return;
+	}
+
+	if (strcmp(pTab->status, "OK")) // OK 틈玖
+	{
+		sys_log(0, "CInputDB::LoginSuccess - status[%s] is not OK [%s]", pTab->status, pTab->login);
+
+		TLogoutPacket pack;
+
+		strlcpy(pack.login, pTab->login, sizeof(pack.login));
+		db_clientdesc->DBPacket(HEADER_GD_LOGOUT, dwHandle, &pack, sizeof(pack));
+
+		LoginFailure(d, pTab->status);
+		return;
+	}
+
+	for (int i = 0; i != PLAYER_PER_ACCOUNT; ++i)
+	{
+		TSimplePlayer& player = pTab->players[i];
+		sys_log(0, "\tplayer(%s).job(%d)", player.szName, player.byJob);
+	}
+
+	bool bFound = GetServerLocation(*pTab, pTab->bEmpire);
+
+	d->BindAccountTable(pTab);
+
+	if (!bFound) // 캐叩    .. -_-
+	{
+		TPacketGCEmpire pe;
+		pe.bHeader = HEADER_GC_EMPIRE;
+		pe.bEmpire = number(1, 3);
+		d->Packet(&pe, sizeof(pe));
+	}
+	else
+	{
+		TPacketGCEmpire pe;
+		pe.bHeader = HEADER_GC_EMPIRE;
+		pe.bEmpire = d->GetEmpire();
+		d->Packet(&pe, sizeof(pe));
+	}
+
+	d->SetPhase(PHASE_SELECT);
+	d->SendLoginSuccessPacket();
+
+	sys_log(0, "InputDB::login_success: %s", pTab->login);
+}
+
+void CInputDB::PlayerCreateFailure(LPDESC d, BYTE bType)
+{
+	if (!d)
+		return;
+
+	TPacketGCCreateFailure pack;
+
+	pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
+	pack.bType = bType;
+
+	d->Packet(&pack, sizeof(pack));
+}
+
+void CInputDB::PlayerCreateSuccess(LPDESC d, const char* data)
+{
+	if (!d)
+		return;
+
+	TPacketDGCreateSuccess* pPacketDB = (TPacketDGCreateSuccess*)data;
+
+	if (pPacketDB->bAccountCharacterIndex >= PLAYER_PER_ACCOUNT)
+	{
+		d->Packet(encode_byte(HEADER_GC_CHARACTER_CREATE_FAILURE), 1);
+		return;
+	}
+
+	long lIndex = 0;
+
+	if (!CMapLocation::instance().Get(pPacketDB->player.x,
+		pPacketDB->player.y,
+		lIndex,
+		pPacketDB->player.lAddr,
+		pPacketDB->player.wPort))
+	{
+		sys_err("InputDB::PlayerCreateSuccess: cannot find server for mapindex %d %d x %d (name %s)",
+			lIndex,
+			pPacketDB->player.x,
+			pPacketDB->player.y,
+			pPacketDB->player.szName);
+	}
+
+	TAccountTable& r_Tab = d->GetAccountTable();
+	r_Tab.players[pPacketDB->bAccountCharacterIndex] = pPacketDB->player;
+
+	TPacketGCPlayerCreateSuccess pack;
+
+	pack.header = HEADER_GC_CHARACTER_CREATE_SUCCESS;
+	pack.bAccountCharacterIndex = pPacketDB->bAccountCharacterIndex;
+	pack.player = pPacketDB->player;
+#if defined(__PROXY_IP__)
+	if (!g_stProxyIP.empty())
+		pack.player.lAddr = inet_addr(g_stProxyIP.c_str());
+#endif
+
+	d->Packet(&pack, sizeof(TPacketGCPlayerCreateSuccess));
+
+	// 羞  환罐 
+	TPlayerItem t;
+	memset(&t, 0, sizeof(t));
+
+	if (china_event_server)
+	{
+		t.bWindow = INVENTORY;
+		t.dwCount = 1;
+		t.dwOwner = r_Tab.players[pPacketDB->bAccountCharacterIndex].dwID;
+
+		//: 寬+3,철+3,탁+3,+3,賻+3, 倂叩+3, 寧+3, +3, +3 
+		//微+3,환寬+3,탁+3,홴+3,화홧+3,+3, 叩+3, +3, +3 
+		//怜+3,+3,탁+3,+3,寧+3, 膚叩+3, +3, +3
+		//髥봤+3,+3,탁+3,美+3,화+3,寧+3, 膚叩+3, +3, +3
+
+		struct SInitialItem
+		{
+			DWORD dwVnum;
+			BYTE pos;
+		};
+
+		const int MAX_INITIAL_ITEM = 9;
+
+		static SInitialItem initialItems[JOB_MAX_NUM][MAX_INITIAL_ITEM] =
+		{
+			{
+				{ 11243, 2 },
+				{ 12223, 3 },
+				{ 15103, 4 },
+				{ 93, 1 },
+				{ 16143, 8 },
+				{ 17103, 9 },
+				{ 3083, 0 },
+				{ 13193, 11 },
+				{ 14103, 12 },
+			},
+			{
+				{ 11443, 0 },
+				{ 12363, 3 },
+				{ 15103, 4 },
+				{ 1053, 2 },
+				{ 2083, 1 },
+				{16083, 7 },
+				{17083, 8 },
+				{13193, 9 },
+				{14103, 10 },
+			},
+			{
+				{ 11643, 0 },
+				{ 12503, 2 },
+				{ 15103, 3 },
+				{ 93, 1 },
+				{ 16123, 4 },
+				{ 17143, 7 },
+				{ 13193, 8 },
+				{ 14103, 9 },
+				{ 0, 0 },
+			},
+			{
+				{ 11843, 0 },
+				{ 12643, 1 },
+				{ 15103, 2 },
+				{ 7083, 3 },
+				{ 5053, 4 },
+				{ 16123, 6 },
+				{ 17143, 7 },
+				{ 13193, 8 },
+				{ 14103, 9 },
+			},
+			{
+				{ 21023, 2 },
+				{ 12223, 3 },
+				{ 21513, 4 },
+				{ 6023, 1 },
+				{ 16143, 8 },
+				{ 17103, 9 },
+				{ 0, 0 },
+				{ 13193, 11 },
+				{ 14103, 12 },
+			},
+		};
+
+		int job = pPacketDB->player.byJob;
+		for (int i = 0; i < MAX_INITIAL_ITEM; i++)
+		{
+			if (initialItems[job][i].dwVnum == 0)
+				continue;
+
+			t.dwID = ITEM_MANAGER::instance().GetNewID();
+			t.wPos = initialItems[job][i].pos;
+			t.dwVnum = initialItems[job][i].dwVnum;
+
+			db_clientdesc->DBPacketHeader(HEADER_GD_ITEM_SAVE, 0, sizeof(TPlayerItem));
+			db_clientdesc->Packet(&t, sizeof(TPlayerItem));
+		}
+	}
+
+	LogManager::instance().CharLog(pack.player.dwID, 0, 0, 0, "CREATE PLAYER", "", d->GetHostName());
+}
+
+void CInputDB::PlayerDeleteSuccess(LPDESC d, const char* data)
+{
+	if (!d)
+		return;
+
+	BYTE account_index;
+	account_index = decode_byte(data);
+	d->BufferedPacket(encode_byte(HEADER_GC_CHARACTER_DELETE_SUCCESS), 1);
+	d->Packet(encode_byte(account_index), 1);
+
+	d->GetAccountTable().players[account_index].dwID = 0;
+}
+
+void CInputDB::PlayerDeleteFail(LPDESC d
+#if defined(__DELETE_FAILURE_TYPE__)
+	, const char* c_pszData
+#endif
+)
+{
+	if (!d)
+		return;
+
+#if defined(__DELETE_FAILURE_TYPE__)
+	const TPlayerDeleteFailurePacket* pPacket = reinterpret_cast<const TPlayerDeleteFailurePacket*>(c_pszData);
+	if (pPacket == nullptr)
+		return;
+
+	d->BufferedPacket(encode_byte(HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID), sizeof(BYTE));
+	d->BufferedPacket(&pPacket->bType, sizeof(pPacket->bType));
+	d->Packet(&pPacket->iTime, sizeof(pPacket->iTime));
+#else
+	d->Packet(encode_byte(HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID), 1);
+#endif
+}
+
+void CInputDB::ChangeName(LPDESC d, const char* data)
+{
+	if (!d)
+		return;
+
+	TPacketDGChangeName* p = (TPacketDGChangeName*)data;
+
+	TAccountTable& r = d->GetAccountTable();
+
+	if (!r.id)
+		return;
+
+	for (size_t i = 0; i < PLAYER_PER_ACCOUNT; ++i)
+		if (r.players[i].dwID == p->pid)
+		{
+			strlcpy(r.players[i].szName, p->name, sizeof(r.players[i].szName));
+			r.players[i].bChangeName = 0;
+
+			TPacketGCChangeName pgc;
+
+			pgc.header = HEADER_GC_CHANGE_NAME;
+			pgc.pid = p->pid;
+			strlcpy(pgc.name, p->name, sizeof(pgc.name));
+
+			d->Packet(&pgc, sizeof(TPacketGCChangeName));
+			break;
+		}
+}
+
+void CInputDB::PlayerLoad(LPDESC d, const char* data)
+{
+	TPlayerTable* pTab = (TPlayerTable*)data;
+
+	if (!d)
+		return;
+
+	long lMapIndex = pTab->lMapIndex;
+	PIXEL_POSITION pos;
+
+	if (lMapIndex == 0)
+	{
+		lMapIndex = SECTREE_MANAGER::instance().GetMapIndex(pTab->x, pTab->y);
+
+		if (lMapIndex == 0) // 표 찾  .
+		{
+			lMapIndex = EMPIRE_START_MAP(d->GetAccountTable().bEmpire);
+			pos.x = EMPIRE_START_X(d->GetAccountTable().bEmpire);
+			pos.y = EMPIRE_START_Y(d->GetAccountTable().bEmpire);
+		}
+		else
+		{
+			pos.x = pTab->x;
+			pos.y = pTab->y;
+		}
+	}
+	pTab->lMapIndex = lMapIndex;
+
+	// Private 却 羚쨉, Private   쨋 瘦 튼 磯.
+	// ----
+	// 姆 瘦 튼 磯摸庸...  瘦 틈灸 private map  풔 pulic map 치 찾캅...
+	// 潁 霽４...  溝湄 磯.
+	// 튿孤見, 瘦...
+	// by rtsummit
+	if (!SECTREE_MANAGER::instance().GetValidLocation(pTab->lMapIndex, pTab->x, pTab->y, lMapIndex, pos, d->GetEmpire()))
+	{
+		//sys_err("InputDB::PlayerLoad : cannot find valid location %d x %d (name: %s)", pTab->x, pTab->y, pTab->name);
+		sys_err("InputDB::PlayerLoad : cannot find valid location %d x %d (name: %s) sending to village", pTab->x, pTab->y, pTab->name);
+
+		lMapIndex = EMPIRE_START_MAP(d->GetAccountTable().bEmpire);
+		pos.x = EMPIRE_START_X(d->GetAccountTable().bEmpire);
+		pos.y = EMPIRE_START_Y(d->GetAccountTable().bEmpire);
+
+		d->SetPhase(PHASE_CLOSE);
+		return;
+	}
+
+	pTab->x = pos.x;
+	pTab->y = pos.y;
+	pTab->lMapIndex = lMapIndex;
+
+	if (d->GetCharacter() || d->IsPhase(PHASE_GAME))
+	{
+		LPCHARACTER p = d->GetCharacter();
+		sys_err("login state already has main state (character %s %p)", p->GetName(), get_pointer(p));
+		return;
+	}
+
+	if (NULL != CHARACTER_MANAGER::Instance().FindPC(pTab->name))
+	{
+		sys_err("InputDB: PlayerLoad : %s already exist in game", pTab->name);
+		return;
+	}
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().CreateCharacter(pTab->name, pTab->id);
+
+	ch->BindDesc(d);
+	ch->SetPlayerProto(pTab);
+	ch->SetEmpire(d->GetEmpire());
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	ch->SetCountry(LocaleService_GetCountry(d->GetAccountTable().country));
+#endif
+
+	d->BindCharacter(ch);
+
+	{
+		// P2P Login
+		TPacketGGLogin p;
+
+		p.bHeader = HEADER_GG_LOGIN;
+		strlcpy(p.szName, ch->GetName(), sizeof(p.szName));
+		p.dwPID = ch->GetPlayerID();
+		p.bEmpire = ch->GetEmpire();
+		p.lMapIndex = SECTREE_MANAGER::instance().GetMapIndex(ch->GetX(), ch->GetY());
+		p.bChannel = g_bChannel;
+
+		P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGLogin));
+
+#if defined(__CHEQUE_SYSTEM__) && defined(__GEM_SYSTEM__)
+		char buf[55];
+		snprintf(buf, sizeof(buf), "%s %d %d %d %d %ld %d",
+			inet_ntoa(ch->GetDesc()->GetAddr().sin_addr), ch->GetGold(), ch->GetCheque(), ch->GetGem(), g_bChannel, ch->GetMapIndex(), ch->GetAlignment());
+#elif defined(__CHEQUE_SYSTEM__)
+		char buf[55];
+		snprintf(buf, sizeof(buf), "%s %d %d %d %ld %d",
+			inet_ntoa(ch->GetDesc()->GetAddr().sin_addr), ch->GetGold(), ch->GetCheque(), g_bChannel, ch->GetMapIndex(), ch->GetAlignment());
+#else
+		char buf[51];
+		snprintf(buf, sizeof(buf), "%s %d %d %ld %d",
+			inet_ntoa(ch->GetDesc()->GetAddr().sin_addr), ch->GetGold(), g_bChannel, ch->GetMapIndex(), ch->GetAlignment());
+#endif
+
+		LogManager::instance().CharLog(ch, 0, "LOGIN", buf);
+
+		// if (LC_IsYMIR() || LC_IsKorea() || LC_IsBrazil() || LC_IsJapan())
+		{
+			LogManager::instance().LoginLog(true,
+				ch->GetDesc()->GetAccountTable().id, ch->GetPlayerID(), ch->GetLevel(), ch->GetJob(), ch->GetRealPoint(POINT_PLAYTIME));
+
+			// if (LC_IsBrazil() != true)
+			{
+				ch->SetPCBang(CPCBangManager::instance().IsPCBangIP(ch->GetDesc()->GetHostName()));
+			}
+		}
+	}
+
+	d->SetPhase(PHASE_LOADING);
+	ch->MainCharacterPacket();
+
+	long lPublicMapIndex = lMapIndex >= 10000 ? lMapIndex / 10000 : lMapIndex;
+
+	// Send Supplementary Data Block if new map requires security packages in loading this map
+	const TMapRegion* rMapRgn = SECTREE_MANAGER::instance().GetMapRegion(lPublicMapIndex);
+	if (rMapRgn)
+	{
+		DESC_MANAGER::instance().SendClientPackageSDBToLoadMap(d, rMapRgn->strMapName.c_str());
+	}
+	//if (!map_allow_find(lMapIndex >= 10000 ? lMapIndex / 10000 : lMapIndex) || !CheckEmpire(ch, lMapIndex))
+	if (!map_allow_find(lPublicMapIndex))
+	{
+		sys_err("InputDB::PlayerLoad : entering %d map is not allowed here (name: %s, empire %u)",
+			lMapIndex, pTab->name, d->GetEmpire());
+
+		ch->SetWarpLocation(EMPIRE_START_MAP(d->GetEmpire()),
+			EMPIRE_START_X(d->GetEmpire()) / 100,
+			EMPIRE_START_Y(d->GetEmpire()) / 100);
+
+		d->SetPhase(PHASE_CLOSE);
+		return;
+	}
+
+	quest::CQuestManager::instance().BroadcastEventFlagOnLogin(ch);
+
+	for (int i = 0; i < QUICKSLOT_MAX_NUM; ++i)
+		ch->SetQuickslot(i, pTab->quickslot[i]);
+
+	ch->PointsPacket();
+	ch->SkillLevelPacket();
+
+	sys_log(0, "InputDB: player_load %s %dx%dx%d LEVEL %d MOV_SPEED %d JOB %d ATG %d DFG %d GMLv %d",
+		pTab->name,
+		ch->GetX(), ch->GetY(), ch->GetZ(),
+		ch->GetLevel(),
+		ch->GetPoint(POINT_MOV_SPEED),
+		ch->GetJob(),
+		ch->GetPoint(POINT_ATT_GRADE),
+		ch->GetPoint(POINT_DEF_GRADE),
+		ch->GetGMLevel());
+
+	ch->QuerySafeboxSize();
+}
+
+void CInputDB::Boot(const char* data)
+{
+	signal_timer_disable();
+
+	// 킷  체크
+	DWORD dwPacketSize = decode_4bytes(data);
+	data += 4;
+
+	// 킷  체크
+	BYTE bVersion = decode_byte(data);
+	data += 1;
+
+	sys_log(0, "BOOT: PACKET: %d", dwPacketSize);
+	sys_log(0, "BOOT: VERSION: %d", bVersion);
+	if (bVersion != 6)
+	{
+		sys_err("boot version error");
+		thecore_shutdown();
+	}
+
+	sys_log(0, "sizeof(TMobTable) = %d", sizeof(TMobTable));
+	sys_log(0, "sizeof(TItemTable) = %d", sizeof(TItemTable));
+	sys_log(0, "sizeof(TShopTable) = %d", sizeof(TShopTable));
+	sys_log(0, "sizeof(TSkillTable) = %d", sizeof(TSkillTable));
+	sys_log(0, "sizeof(TRefineTable) = %d", sizeof(TRefineTable));
+	sys_log(0, "sizeof(TItemAttrTable) = %d", sizeof(TItemAttrTable));
+	sys_log(0, "sizeof(TItemRareTable) = %d", sizeof(TItemAttrTable));
+	sys_log(0, "sizeof(TBanwordTable) = %d", sizeof(TBanwordTable));
+	sys_log(0, "sizeof(TLand) = %d", sizeof(building::TLand));
+	sys_log(0, "sizeof(TObjectProto) = %d", sizeof(building::TObjectProto));
+	sys_log(0, "sizeof(TObject) = %d", sizeof(building::TObject));
+#ifdef __GROWTH_PET_SYSTEM__
+	/*
+	* GROWTH PET SKILL
+	*/
+
+	if (decode_2bytes(data) != sizeof(TGrowthPetSkillTable))
+	{
+		sys_err("event table size error");
+		thecore_shutdown();
+		return;
+	}
+	data += 2;
+
+	size = decode_2bytes(data);
+	data += 2;
+	sys_log(0, "BOOT: GROWTH PET SKILL: %d", size);
+
+	if (size)
+	{
+		CGrowthPetManager::instance().InitializeSkill((TGrowthPetSkillTable*)data, size);
+		data += size * sizeof(TGrowthPetSkillTable);
+	}
+#endif
+	// ADMIN_MANAGER
+	sys_log(0, "sizeof(TAdminManager) = %d", sizeof(TAdminInfo));
+	// END_ADMIN_MANAGER
+
+	WORD size;
+
+	/*
+	* MOB
+	*/
+
+	if (decode_2bytes(data) != sizeof(TMobTable))
+	{
+		sys_err("mob table size error");
+		thecore_shutdown();
+		return;
+	}
+	data += 2;
+
+	size = decode_2bytes(data);
+	data += 2;
+	sys_log(0, "BOOT: MOB: %d", size);
+
+	if (size)
+	{
+		CMobManager::instance().Initialize((TMobTable*)data, size);
+		data += size * sizeof(TMobTable);
+	}
+
+	/*
+	* ITEM
+	*/
+
+	if (decode_2bytes(data) != sizeof(TItemTable))
+	{
+		sys_err("item table size error");
+		thecore_shutdown();
+		return;
+	}
+	data += 2;
+
+	size = decode_2bytes(data);
+	data += 2;
+	sys_log(0, "BOOT: ITEM: %d", size);
+
+	if (size)
+	{
+		ITEM_MANAGER::instance().Initialize((TItemTable*)data, size);
+		data += size * sizeof(TItemTable);
+	}
+
+	/*
+	* SHOP
+	*/
+
+	if (decode_2bytes(data) != sizeof(TShopTable))
+	{
+		sys_err("shop table size error");
+		thecore_shutdown();
+		return;
+	}
+	data += 2;
+
+	size = decode_2bytes(data);
+	data += 2;
+	sys_log(0, "BOOT: SHOP: %d", size);
+
+	if (size)
+	{
+		if (!CShopManager::instance().Initialize((TShopTable*)data, size))
+		{
+			sys_err("shop table Initialize error");
+			thecore_shutdown();
+			return;
+		}
+		data += size * sizeof(TShopTable);
+	}
+
+	/*
+	* SKILL
+	*/
+
+	if (decode_2bytes(data) != sizeof(TSkillTable))
+	{
+		sys_err("skill table size error");
+		thecore_shutdown();
+		return;
+	}
+	data += 2;
+
+	size = decode_2bytes(data);
+	data += 2;
+	sys_log(0, "BOOT: SKILL: %d", size);
+
+	if (size)
+	{
+		if (!CSkillManager::instance().Initialize((TSkillTable*)data, size))
+		{
+			sys_err("cannot initialize skill table");
+			thecore_shutdown();
+			return;
+		}
+
+		data += size * sizeof(TSkillTable);
+	}
+	/*
+	* REFINE RECIPE
+	*/
+
+	if (decode_2bytes(data) != sizeof(TRefineTable))
+	{
+		sys_err("refine table size error");
+		thecore_shutdown();
+		return;
+	}
+	data += 2;
+
+	size = decode_2bytes(data);
+	data += 2;
+	sys_log(0, "BOOT: REFINE: %d", size);
+
+	if (size)
+	{
+		CRefineManager::instance().Initialize((TRefineTable*)data, size);
+		data += size * sizeof(TRefineTable);
+	}
+
+	/*
+	* ITEM ATTR
+	*/
+
+	if (decode_2bytes(data) != sizeof(TItemAttrTable))
+	{
+		sys_err("item attr table size error");
+		thecore_shutdown();
+		return;
+	}
+	data += 2;
+
+	size = decode_2bytes(data);
+	data += 2;
+	sys_log(0, "BOOT: ITEM_ATTR: %d", size);
+
+	if (size)
+	{
+		TItemAttrTable* p = (TItemAttrTable*)data;
+
+		for (int i = 0; i < size; ++i, ++p)
+		{
+			if (p->wApplyIndex >= MAX_APPLY_NUM)
+				continue;
+
+			g_map_itemAttr[p->wApplyIndex] = *p;
+			sys_log(0, "ITEM_ATTR[%d]: %s %u", p->wApplyIndex, p->szApply, p->dwProb);
+		}
+	}
+
+	data += size * sizeof(TItemAttrTable);
+
+	/*
+	* ITEM RARE
+	*/
+
+	if (decode_2bytes(data) != sizeof(TItemAttrTable))
+	{
+		sys_err("item rare table size error");
+		thecore_shutdown();
+		return;
+	}
+	data += 2;
+
+	size = decode_2bytes(data);
+	data += 2;
+	sys_log(0, "BOOT: ITEM_RARE: %d", size);
+
+	if (size)
+	{
+		TItemAttrTable* p = (TItemAttrTable*)data;
+
+		for (int i = 0; i < size; ++i, ++p)
+		{
+			if (p->wApplyIndex >= MAX_APPLY_NUM)
+				continue;
+
+			g_map_itemRare[p->wApplyIndex] = *p;
+			sys_log(0, "ITEM_RARE[%d]: %s %u", p->wApplyIndex, p->szApply, p->dwProb);
+		}
+	}
+
+	data += size * sizeof(TItemAttrTable);
+
+	/*
+	* BANWORDS
+	*/
+
+	if (decode_2bytes(data) != sizeof(TBanwordTable))
+	{
+		sys_err("ban word table size error");
+		thecore_shutdown();
+		return;
+	}
+	data += 2;
+
+	size = decode_2bytes(data);
+	data += 2;
+
+	CBanwordManager::instance().Initialize((TBanwordTable*)data, size);
+	data += size * sizeof(TBanwordTable);
+
+	{
+		using namespace building;
+
+		/*
+		* LANDS
+		*/
+
+		if (decode_2bytes(data) != sizeof(TLand))
+		{
+			sys_err("land table size error");
+			thecore_shutdown();
+			return;
+		}
+		data += 2;
+
+		size = decode_2bytes(data);
+		data += 2;
+
+		TLand* kLand = (TLand*)data;
+		data += size * sizeof(TLand);
+
+		for (WORD i = 0; i < size; ++i, ++kLand)
+			CManager::instance().LoadLand(kLand);
+
+		/*
+		* OBJECT PROTO
+		*/
+
+		if (decode_2bytes(data) != sizeof(TObjectProto))
+		{
+			sys_err("object proto table size error");
+			thecore_shutdown();
+			return;
+		}
+		data += 2;
+
+		size = decode_2bytes(data);
+		data += 2;
+
+		CManager::instance().LoadObjectProto((TObjectProto*)data, size);
+		data += size * sizeof(TObjectProto);
+
+		/*
+		* OBJECT
+		*/
+
+		if (decode_2bytes(data) != sizeof(TObject))
+		{
+			sys_err("object table size error");
+			thecore_shutdown();
+			return;
+		}
+		data += 2;
+
+		size = decode_2bytes(data);
+		data += 2;
+
+		TObject* kObj = (TObject*)data;
+		data += size * sizeof(TObject);
+
+		for (WORD i = 0; i < size; ++i, ++kObj)
+			CManager::instance().LoadObject(kObj, true);
+	}
+
+#ifdef __GROWTH_PET_SYSTEM__
+	c_pData += sizeof(TSafeboxTable) + sizeof(TPlayerItem) * p->wItemCount;
+
+	WORD dwPetCount =*(WORD*)c_pData;
+	c_pData += sizeof(WORD);
+
+	d->GetCharacter()->GetSafebox()->LoadPet(dwPetCount, (TGrowthPet*)c_pData);
+#endif
+
+	set_global_time(*(time_t*)data);
+	data += sizeof(time_t);
+
+	if (decode_2bytes(data) != sizeof(TItemIDRangeTable))
+	{
+		sys_err("ITEM ID RANGE size error");
+		thecore_shutdown();
+		return;
+	}
+	data += 2;
+
+	size = decode_2bytes(data);
+	data += 2;
+
+	TItemIDRangeTable* range = (TItemIDRangeTable*)data;
+	data += size * sizeof(TItemIDRangeTable);
+
+	TItemIDRangeTable* rangespare = (TItemIDRangeTable*)data;
+	data += size * sizeof(TItemIDRangeTable);
+
+	// ADMIN_MANAGER
+	//  
+	int ChunkSize = decode_2bytes(data);
+	data += 2;
+	int HostSize = decode_2bytes(data);
+	data += 2;
+	sys_log(0, "GM Value Count %d %d", HostSize, ChunkSize);
+	for (int n = 0; n < HostSize; ++n)
+	{
+		gm_new_host_inert(data);
+		sys_log(0, "GM HOST : IP[%s] ", data);
+		data += ChunkSize;
+	}
+
+	data += 2;
+	int adminsize = decode_2bytes(data);
+	data += 2;
+
+	for (int n = 0; n < adminsize; ++n)
+	{
+		tAdminInfo& rAdminInfo = *(tAdminInfo*)data;
+
+		gm_new_insert(rAdminInfo);
+
+		data += sizeof(rAdminInfo);
+	}
+	// END_ADMIN_MANAGER
+
+	// MONARCH
+	data += 2;
+	data += 2;
+
+	TMonarchInfo& p = *(TMonarchInfo*)data;
+	data += sizeof(TMonarchInfo);
+
+	CMonarch::instance().SetMonarchInfo(&p);
+
+	for (int n = 1; n < 4; ++n)
+	{
+		if (p.name[n] && *p.name[n])
+			sys_log(0, "[MONARCH] Empire %d Pid %d Money %d %s", n, p.pid[n], p.money[n], p.name[n]);
+	}
+
+	int CandidacySize = decode_2bytes(data);
+	data += 2;
+
+	int CandidacyCount = decode_2bytes(data);
+	data += 2;
+
+	if (test_server)
+		sys_log(0, "[MONARCH] Size %d Count %d", CandidacySize, CandidacyCount);
+
+	data += CandidacySize * CandidacyCount;
+	// END_MONARCH
+
+#ifdef __OFFLINE_SHOP__
+	{
+		CDynamicPacket packet(data);
+
+		auto size = *packet.Get<uint32_t>();
+		if (size != sizeof(TOfflineShop)) {
+			sys_err("TOfflineShop size error! Expected size %u.", sizeof(TOfflineShop));
+			thecore_shutdown();
+			return;
+		}
+
+		auto count = *packet.Get<uint32_t>();
+		while (count > 0) {
+			count--;
+
+			const auto& shopData = *packet.Get<TOfflineShop>();
+			if (shopData.channel != g_bChannel || !map_allow_find(shopData.mapIndex)) {
+				continue;
+			}
+
+			COfflineShop::LoadShop(shopData);
+		}
+
+
+		size = *packet.Get<uint32_t>();
+		if (size != sizeof(TOfflineShopItem)) {
+			sys_err("TOfflineShopItem size error! Expected size %u.", sizeof(TOfflineShopItem));
+			thecore_shutdown();
+			return;
+		}
+
+		count = *packet.Get<uint32_t>();
+		while (count > 0) {
+			count--;
+
+			const auto& itemData = *packet.Get<TOfflineShopItem>();
+
+			auto shop = COfflineShop::Get(itemData.id.first);
+			if (!shop) {
+				continue;
+			}
+
+			shop->get()->AddItem(itemData);
+		}
+
+		data += packet.GetExtraSize();
+	}
+#endif
+
+	WORD endCheck = decode_2bytes(data);
+	if (endCheck != 0xffff)
+	{
+		sys_err("boot packet end check error [%x]!=0xffff", endCheck);
+		thecore_shutdown();
+		return;
+	}
+	else
+		sys_log(0, "boot packet end check ok [%x]==0xffff", endCheck);
+	data += 2;
+
+	if (!ITEM_MANAGER::instance().SetMaxItemID(*range))
+	{
+		sys_err("not enough item id contact your administrator!");
+		thecore_shutdown();
+		return;
+	}
+
+	if (!ITEM_MANAGER::instance().SetMaxSpareItemID(*rangespare))
+	{
+		sys_err("not enough item id for spare contact your administrator!");
+		thecore_shutdown();
+		return;
+	}
+
+	// LOCALE_SERVICE
+	const int FILE_NAME_LEN = 256;
+	char szCommonDropItemFileName[FILE_NAME_LEN];
+	char szETCDropItemFileName[FILE_NAME_LEN];
+	char szMOBDropItemFileName[FILE_NAME_LEN];
+	char szDropItemGroupFileName[FILE_NAME_LEN];
+	char szSpecialItemGroupFileName[FILE_NAME_LEN];
+	char szMapIndexFileName[FILE_NAME_LEN];
+#if defined(__CONQUEROR_LEVEL__)
+	char szNewWorldMapIndexFileName[FILE_NAME_LEN];
+#endif
+	char szItemVnumMaskTableFileName[FILE_NAME_LEN];
+	char szDragonSoulTableFileName[FILE_NAME_LEN];
+#if defined(__LUCKY_BOX__)
+	char szLuckyBoxFileName[FILE_NAME_LEN];
+#endif
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	char szRouletteTableFileName[FILE_NAME_LEN];
+#endif
+
+	snprintf(szCommonDropItemFileName, sizeof(szCommonDropItemFileName),
+		"%s/common_drop_item.txt", LocaleService_GetBasePath().c_str());
+	snprintf(szETCDropItemFileName, sizeof(szETCDropItemFileName),
+		"%s/etc_drop_item.txt", LocaleService_GetBasePath().c_str());
+	snprintf(szMOBDropItemFileName, sizeof(szMOBDropItemFileName),
+		"%s/mob_drop_item.txt", LocaleService_GetBasePath().c_str());
+	snprintf(szSpecialItemGroupFileName, sizeof(szSpecialItemGroupFileName),
+		"%s/special_item_group.txt", LocaleService_GetBasePath().c_str());
+	snprintf(szDropItemGroupFileName, sizeof(szDropItemGroupFileName),
+		"%s/drop_item_group.txt", LocaleService_GetBasePath().c_str());
+	snprintf(szMapIndexFileName, sizeof(szMapIndexFileName),
+		"%s/index.txt", LocaleService_GetMapPath().c_str());
+#if defined(__CONQUEROR_LEVEL__)
+	snprintf(szNewWorldMapIndexFileName, sizeof(szNewWorldMapIndexFileName),
+		"%s/new_world.txt", LocaleService_GetMapPath().c_str());
+#endif
+	snprintf(szItemVnumMaskTableFileName, sizeof(szItemVnumMaskTableFileName),
+		"%s/ori_to_new_table.txt", LocaleService_GetBasePath().c_str());
+	snprintf(szDragonSoulTableFileName, sizeof(szDragonSoulTableFileName),
+		"%s/dragon_soul_table.txt", LocaleService_GetBasePath().c_str());
+#if defined(__LUCKY_BOX__)
+	snprintf(szLuckyBoxFileName, sizeof(szLuckyBoxFileName),
+		"%s/lucky_box.txt", LocaleService_GetBasePath().c_str());
+#endif
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	snprintf(szRouletteTableFileName, sizeof(szRouletteTableFileName),
+		"%s/roulette_table.txt", LocaleService_GetBasePath().c_str());
+#endif
+
+#if !defined(__CUBE_RENEWAL__)
+	sys_log(0, "Initializing Informations of Cube System");
+	if (!Cube_InformationInitialize())
+	{
+		sys_err("cannot init cube infomation.");
+		thecore_shutdown();
+		return;
+	}
+#endif
+
+	sys_log(0, "LoadLocaleFile: CommonDropItem: %s", szCommonDropItemFileName);
+	if (!ITEM_MANAGER::instance().ReadCommonDropItemFile(szCommonDropItemFileName))
+	{
+		sys_err("cannot load CommonDropItem: %s", szCommonDropItemFileName);
+		thecore_shutdown();
+		return;
+	}
+
+	sys_log(0, "LoadLocaleFile: ETCDropItem: %s", szETCDropItemFileName);
+	if (!ITEM_MANAGER::instance().ReadEtcDropItemFile(szETCDropItemFileName))
+	{
+		sys_err("cannot load ETCDropItem: %s", szETCDropItemFileName);
+		thecore_shutdown();
+		return;
+	}
+
+	sys_log(0, "LoadLocaleFile: DropItemGroup: %s", szDropItemGroupFileName);
+	if (!ITEM_MANAGER::instance().ReadDropItemGroup(szDropItemGroupFileName))
+	{
+		sys_err("cannot load DropItemGroup: %s", szDropItemGroupFileName);
+		thecore_shutdown();
+		return;
+	}
+
+	sys_log(0, "LoadLocaleFile: SpecialItemGroup: %s", szSpecialItemGroupFileName);
+	if (!ITEM_MANAGER::instance().ReadSpecialDropItemFile(szSpecialItemGroupFileName))
+	{
+		sys_err("cannot load SpecialItemGroup: %s", szSpecialItemGroupFileName);
+		thecore_shutdown();
+		return;
+	}
+
+	sys_log(0, "LoadLocaleFile: ItemVnumMaskTable : %s", szItemVnumMaskTableFileName);
+	if (!ITEM_MANAGER::instance().ReadItemVnumMaskTable(szItemVnumMaskTableFileName))
+	{
+		sys_log(0, "Could not open MaskItemTable");
+	}
+
+	sys_log(0, "LoadLocaleFile: MOBDropItemFile: %s", szMOBDropItemFileName);
+	if (!ITEM_MANAGER::instance().ReadMonsterDropItemGroup(szMOBDropItemFileName))
+	{
+		sys_err("cannot load MOBDropItemFile: %s", szMOBDropItemFileName);
+		thecore_shutdown();
+		return;
+	}
+
+	sys_log(0, "LoadLocaleFile: MapIndex: %s", szMapIndexFileName);
+	if (!SECTREE_MANAGER::instance().Build(szMapIndexFileName, LocaleService_GetMapPath().c_str()))
+	{
+		sys_err("cannot load MapIndex: %s", szMapIndexFileName);
+		thecore_shutdown();
+		return;
+	}
+
+#if defined(__CONQUEROR_LEVEL__)
+	sys_log(0, "LoadLocaleFile: NewWorldMapIndex: %s", szNewWorldMapIndexFileName);
+	if (!SECTREE_MANAGER::Instance().LoadNewWorldMapIndexFile(szNewWorldMapIndexFileName))
+		sys_err("cannot load NewWorldMapIndex: %s", szNewWorldMapIndexFileName);
+#endif
+
+	SECTREE_MANAGER::instance().LoadBlockFilterMapIndexFile(SECTREE_MANAGER::PET_BLOCK_MAP_INDEX);
+	SECTREE_MANAGER::instance().LoadBlockFilterMapIndexFile(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX);
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	sys_log(0, "LoadLocaleFile: DragonSoulTable: %s", szDragonSoulTableFileName);
+	if (!DSManager::instance().ReadDragonSoulTableFile(szDragonSoulTableFileName))
+	{
+		sys_err("cannot load DragonSoulTable: %s", szDragonSoulTableFileName);
+		//thecore_shutdown();
+		//return;
+	}
+#endif
+
+#if defined(__LUCKY_BOX__)
+	sys_log(0, "LoadLocaleFile: LuckyBoxFile: %s", szLuckyBoxFileName);
+	if (!ITEM_MANAGER::instance().ReadLuckyBoxFile(szLuckyBoxFileName))
+	{
+		sys_err("cannot load LuckyBoxFile: %s", szLuckyBoxFileName);
+		thecore_shutdown();
+		return;
+	}
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+	char szApplyRandomTableFileName[FILE_NAME_LEN];
+	snprintf(szApplyRandomTableFileName, sizeof(szApplyRandomTableFileName),
+		"%s/apply_random_table.txt", LocaleService_GetBasePath().c_str());
+	sys_log(0, "LoadLocaleFile: ApplyRandomTable: %s", szApplyRandomTableFileName);
+	if (!ITEM_MANAGER::instance().ReadApplyRandomTableFile(szApplyRandomTableFileName))
+	{
+		sys_err("LoadLocaleFile: Cannot load ApplyRandomTable: %s", szApplyRandomTableFileName);
+		thecore_shutdown();
+		return;
+	}
+#endif
+
+#if defined(__GEM_SHOP__)
+	char szGemShopTableFileName[FILE_NAME_LEN];
+	snprintf(szGemShopTableFileName, sizeof(szGemShopTableFileName),
+		"%s/gem_shop_table.txt", LocaleService_GetBasePath().c_str());
+	sys_log(0, "LoadLocaleFile: GemShopTable: %s", szGemShopTableFileName);
+	if (!ITEM_MANAGER::instance().ReadGemShopItemGroup(szGemShopTableFileName))
+		sys_err("LoadLocaleFile: Cannot load GemShopTable: %s", szGemShopTableFileName);
+#endif
+
+#if defined(__SET_ITEM__)
+	char szSetItemTableFileName[FILE_NAME_LEN];
+	snprintf(szSetItemTableFileName, sizeof(szSetItemTableFileName),
+		"%s/set_item_table.txt", LocaleService_GetBasePath().c_str());
+	sys_log(0, "LoadLocaleFile: SetItemTable: %s", szSetItemTableFileName);
+	if (!ITEM_MANAGER::instance().LoadSetItemTable(szSetItemTableFileName))
+		sys_err("LoadLocaleFile: Cannot load SetItemTable: %s", szSetItemTableFileName);
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	sys_log(0, "LoadLocaleFile: RouletteTable: %s", szRouletteTableFileName);
+	if (!CRouletteManager::Instance().ReadRouletteTableFile(szRouletteTableFileName))
+	{
+		sys_err("cannot load RouletteTable: %s", szRouletteTableFileName);
+		thecore_shutdown();
+		return;
+	}
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	if (!CBattlePassManager::instance().InitializeBattlePass())
+		sys_err("Failure to Initialize Extended BattlePass!");
+#endif
+
+	// END_OF_LOCALE_SERVICE
+
+	building::CManager::instance().FinalizeBoot();
+
+	CMotionManager::instance().Build();
+
+	signal_timer_enable(30);
+
+	if (test_server)
+	{
+		CMobManager::instance().DumpRegenCount("mob_count");
+	}
+
+	CPCBangManager::instance().RequestUpdateIPList(0);
+#ifdef __OFFLINE_SHOP__
+	COfflineShop::OpenShops();
+#endif
+	// castle_boot
+	castle_boot();
+
+#if defined(__MT_THUNDER_DUNGEON__)
+	CMTThunderDungeon::Instance().Initialize();
+#endif
+
+	// request blocked_country_ip
+	{
+		db_clientdesc->DBPacket(HEADER_GD_BLOCK_COUNTRY_IP, 0, NULL, 0);
+		dev_log(LOG_DEB0, "<sent HEADER_GD_BLOCK_COUNTRY_IP>");
+	}
+}
+
+EVENTINFO(quest_login_event_info)
+{
+	DWORD dwPID;
+
+	quest_login_event_info()
+		: dwPID(0)
+	{
+	}
+};
+
+EVENTFUNC(quest_login_event)
+{
+	quest_login_event_info* info = dynamic_cast<quest_login_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("quest_login_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	DWORD dwPID = info->dwPID;
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(dwPID);
+
+	if (!ch)
+		return 0;
+
+	LPDESC d = ch->GetDesc();
+
+	if (!d)
+		return 0;
+
+	if (d->IsPhase(PHASE_HANDSHAKE) ||
+		d->IsPhase(PHASE_LOGIN) ||
+		d->IsPhase(PHASE_SELECT) ||
+		d->IsPhase(PHASE_DEAD) ||
+		d->IsPhase(PHASE_LOADING))
+	{
+		return PASSES_PER_SEC(1);
+	}
+	else if (d->IsPhase(PHASE_CLOSE))
+	{
+		return 0;
+	}
+	else if (d->IsPhase(PHASE_GAME))
+	{
+		sys_log(0, "QUEST_LOAD: Login pc %d by event", ch->GetPlayerID());
+		quest::CQuestManager::instance().Login(ch->GetPlayerID());
+		return 0;
+	}
+	else
+	{
+		sys_err(0, "input_db.cpp:quest_login_event INVALID PHASE pid %d", ch->GetPlayerID());
+		return 0;
+	}
+}
+
+void CInputDB::QuestLoad(LPDESC d, const char* c_pData)
+{
+	if (NULL == d)
+		return;
+
+	LPCHARACTER ch = d->GetCharacter();
+
+	if (NULL == ch)
+		return;
+
+	const DWORD dwCount = decode_4bytes(c_pData);
+
+	const TQuestTable* pQuestTable = reinterpret_cast<const TQuestTable*>(c_pData + 4);
+
+	if (NULL != pQuestTable)
+	{
+		if (dwCount != 0)
+		{
+			if (ch->GetPlayerID() != pQuestTable[0].dwPID)
+			{
+				sys_err("PID differs %u %u", ch->GetPlayerID(), pQuestTable[0].dwPID);
+				return;
+			}
+		}
+
+		sys_log(0, "QUEST_LOAD: count %d", dwCount);
+
+		quest::PC* pkPC = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
+
+		if (!pkPC)
+		{
+			sys_err("null quest::PC with id %u", pQuestTable[0].dwPID);
+			return;
+		}
+
+		if (pkPC->IsLoaded())
+			return;
+
+		for (unsigned int i = 0; i < dwCount; ++i)
+		{
+			std::string st(pQuestTable[i].szName);
+
+			st += ".";
+			st += pQuestTable[i].szState;
+
+			sys_log(0, "            %s %d", st.c_str(), pQuestTable[i].lValue);
+			pkPC->SetFlag(st.c_str(), pQuestTable[i].lValue, false);
+		}
+
+		pkPC->SetLoaded();
+		pkPC->Build();
+
+		if (ch->GetDesc()->IsPhase(PHASE_GAME))
+		{
+			sys_log(0, "QUEST_LOAD: Login pc %d", pQuestTable[0].dwPID);
+			quest::CQuestManager::instance().Login(pQuestTable[0].dwPID);
+		}
+		else
+		{
+			quest_login_event_info* info = AllocEventInfo<quest_login_event_info>();
+			info->dwPID = ch->GetPlayerID();
+
+			event_create(quest_login_event, info, PASSES_PER_SEC(1));
+		}
+	}
+}
+
+void CInputDB::SafeboxLoad(LPDESC d, const char* c_pData)
+{
+	if (!d)
+		return;
+
+	TSafeboxTable* p = (TSafeboxTable*)c_pData;
+
+	if (d->GetAccountTable().id != p->dwID)
+	{
+		sys_err("SafeboxLoad: safebox has different id %u != %u", d->GetAccountTable().id, p->dwID);
+		return;
+	}
+
+	if (!d->GetCharacter())
+		return;
+
+	BYTE bSize = 1;
+
+	LPCHARACTER ch = d->GetCharacter();
+
+	// PREVENT_TRADE_WINDOW
+	if (ch->PreventTradeWindow(WND_SAFEBOX, true/*except*/))
+	{
+		d->GetCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸킹창 쩔 창  求."));
+		d->GetCharacter()->CancelSafeboxLoad();
+		return;
+	}
+	// END_PREVENT_TRADE_WINDOW
+
+	// ADD_PREMIUM
+	if (d->GetCharacter()->GetPremiumRemainSeconds(PREMIUM_SAFEBOX) > 0)
+		bSize = 3;
+	// END_OF_ADD_PREMIUM
+
+	if (d->GetCharacter()->IsEquipUniqueGroup(UNIQUE_GROUP_LARGE_SAFEBOX))
+		bSize = 3; // 창확
+
+	//d->GetCharacter()->LoadSafebox(p->bSize * SAFEBOX_PAGE_SIZE, p->dwGold, p->wItemCount, (TPlayerItem *) (c_pData + sizeof(TSafeboxTable)));
+	d->GetCharacter()->LoadSafebox(bSize * SAFEBOX_PAGE_SIZE, p->dwGold, p->wItemCount, (TPlayerItem*)(c_pData + sizeof(TSafeboxTable)));
+#ifdef __GROWTH_PET_SYSTEM__
+	/*
+	* GROWTH PET SKILL
+	*/
+	wSize = decode_2bytes(c_pData);
+	c_pData += 2;
+	sys_log(0, "RELOAD: Growth Pet Skill: %d", wSize);
+
+	if (wSize)
+	{
+		CGrowthPetManager::instance().InitializeSkill((TGrowthPetSkillTable*)c_pData, wSize);
+		c_pData += wSize * sizeof(TGrowthPetSkillTable);
+	}
+#endif
+}
+
+void CInputDB::SafeboxChangeSize(LPDESC d, const char* c_pData)
+{
+	if (!d)
+		return;
+
+	BYTE bSize = *(BYTE*)c_pData;
+
+	if (!d->GetCharacter())
+		return;
+
+	d->GetCharacter()->ChangeSafeboxSize(bSize);
+}
+
+//
+// @version 05/06/20 Bang2ni - ReqSafeboxLoad  
+//
+void CInputDB::SafeboxWrongPassword(LPDESC d)
+{
+	if (!d)
+		return;
+
+	if (!d->GetCharacter())
+		return;
+
+	TPacketCGSafeboxWrongPassword p;
+	p.bHeader = HEADER_GC_SAFEBOX_WRONG_PASSWORD;
+	d->Packet(&p, sizeof(p));
+
+	d->GetCharacter()->CancelSafeboxLoad();
+}
+
+void CInputDB::SafeboxChangePasswordAnswer(LPDESC d, const char* c_pData)
+{
+	if (!d)
+		return;
+
+	if (!d->GetCharacter())
+		return;
+
+	TSafeboxChangePasswordPacketAnswer* p = (TSafeboxChangePasswordPacketAnswer*)c_pData;
+	if (p->flag)
+	{
+		d->GetCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창> 창 橘호 퓸求."));
+		d->GetCharacter()->SetSafeboxBuff();
+	}
+	else
+	{
+		d->GetCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창>  橘호 틀횟求."));
+	}
+}
+
+void CInputDB::MallLoad(LPDESC d, const char* c_pData)
+{
+	if (!d)
+		return;
+
+	TSafeboxTable* p = (TSafeboxTable*)c_pData;
+
+	if (d->GetAccountTable().id != p->dwID)
+	{
+		sys_err("safebox has different id %u != %u", d->GetAccountTable().id, p->dwID);
+		return;
+	}
+
+	if (!d->GetCharacter())
+		return;
+
+	d->GetCharacter()->LoadMall(p->wItemCount, (TPlayerItem*)(c_pData + sizeof(TSafeboxTable)));
+}
+
+void CInputDB::LoginAlready(LPDESC d, const char* c_pData)
+{
+	if (!d)
+		return;
+
+	// INTERNATIONAL_VERSION 譴 見  
+	{
+		TPacketDGLoginAlready* p = (TPacketDGLoginAlready*)c_pData;
+
+		LPDESC d2 = DESC_MANAGER::instance().FindByLoginName(p->szLogin);
+
+		if (d2)
+			d2->DisconnectOfSameLogin();
+		else
+		{
+			TPacketGGDisconnect pgg;
+
+			pgg.bHeader = HEADER_GG_DISCONNECT;
+			strlcpy(pgg.szLogin, p->szLogin, sizeof(pgg.szLogin));
+
+			P2P_MANAGER::instance().Send(&pgg, sizeof(TPacketGGDisconnect));
+		}
+	}
+	// END_OF_INTERNATIONAL_VERSION
+
+	LoginFailure(d, "ALREADY");
+}
+
+void CInputDB::EmpireSelect(LPDESC d, const char* c_pData)
+{
+	sys_log(0, "EmpireSelect %p", get_pointer(d));
+
+	if (!d)
+		return;
+
+	TAccountTable& rTable = d->GetAccountTable();
+	rTable.bEmpire = *(BYTE*)c_pData;
+
+	TPacketGCEmpire pe;
+	pe.bHeader = HEADER_GC_EMPIRE;
+	pe.bEmpire = rTable.bEmpire;
+	d->Packet(&pe, sizeof(pe));
+
+	for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
+	{
+		if (rTable.players[i].dwID)
+		{
+			rTable.players[i].x = EMPIRE_START_X(rTable.bEmpire);
+			rTable.players[i].y = EMPIRE_START_Y(rTable.bEmpire);
+		}
+	}
+
+	GetServerLocation(d->GetAccountTable(), rTable.bEmpire);
+
+	d->SendLoginSuccessPacket();
+}
+
+void CInputDB::MapLocations(const char* c_pData)
+{
+	BYTE bCount = *(BYTE*)(c_pData++);
+
+	sys_log(0, "InputDB::MapLocations %d", bCount);
+
+	TMapLocation* pLoc = (TMapLocation*)c_pData;
+
+	while (bCount--)
+	{
+		for (int i = 0; i < MAX_MAP_ALLOW; ++i)
+		{
+			if (0 == pLoc->alMaps[i])
+				break;
+
+			CMapLocation::instance().Insert(pLoc->alMaps[i], pLoc->szHost, pLoc->wPort);
+		}
+
+		pLoc++;
+	}
+}
+
+void CInputDB::P2P(const char* c_pData)
+{
+	extern LPFDWATCH main_fdw;
+
+	TPacketDGP2P* p = (TPacketDGP2P*)c_pData;
+
+	P2P_MANAGER& mgr = P2P_MANAGER::instance();
+
+	if (false == DESC_MANAGER::instance().IsP2PDescExist(p->szHost, p->wPort))
+	{
+		LPCLIENT_DESC pkDesc = NULL;
+		sys_log(0, "InputDB:P2P %s:%u", p->szHost, p->wPort);
+		pkDesc = DESC_MANAGER::instance().CreateConnectionDesc(main_fdw, p->szHost, p->wPort, PHASE_P2P, false);
+		mgr.RegisterConnector(pkDesc);
+		pkDesc->SetP2P(p->szHost, p->wPort, p->bChannel);
+	}
+}
+
+void CInputDB::GuildLoad(const char* c_pData)
+{
+	CGuildManager::instance().LoadGuild(*(DWORD*)c_pData);
+}
+
+void CInputDB::GuildSkillUpdate(const char* c_pData)
+{
+	TPacketGuildSkillUpdate* p = (TPacketGuildSkillUpdate*)c_pData;
+
+	CGuild* g = CGuildManager::instance().TouchGuild(p->guild_id);
+
+	if (g)
+	{
+		g->UpdateSkill(p->skill_point, p->skill_levels);
+		g->GuildPointChange(POINT_SP, p->amount, p->save ? true : false);
+	}
+}
+
+void CInputDB::GuildWar(const char* c_pData)
+{
+	TPacketGuildWar* p = (TPacketGuildWar*)c_pData;
+
+	sys_log(0, "InputDB::GuildWar %u %u state %d", p->dwGuildFrom, p->dwGuildTo, p->bWar);
+
+	switch (p->bWar)
+	{
+		case GUILD_WAR_SEND_DECLARE:
+		case GUILD_WAR_RECV_DECLARE:
+			CGuildManager::instance().DeclareWar(p->dwGuildFrom, p->dwGuildTo, p->bType);
+			break;
+
+		case GUILD_WAR_REFUSE:
+			CGuildManager::instance().RefuseWar(p->dwGuildFrom, p->dwGuildTo);
+			break;
+
+		case GUILD_WAR_WAIT_START:
+			CGuildManager::instance().WaitStartWar(p->dwGuildFrom, p->dwGuildTo);
+			break;
+
+		case GUILD_WAR_CANCEL:
+			CGuildManager::instance().CancelWar(p->dwGuildFrom, p->dwGuildTo);
+			break;
+
+		case GUILD_WAR_ON_WAR:
+			CGuildManager::instance().StartWar(p->dwGuildFrom, p->dwGuildTo);
+			break;
+
+		case GUILD_WAR_END:
+			CGuildManager::instance().EndWar(p->dwGuildFrom, p->dwGuildTo);
+			break;
+
+		case GUILD_WAR_OVER:
+			CGuildManager::instance().WarOver(p->dwGuildFrom, p->dwGuildTo, p->bType);
+			break;
+
+		case GUILD_WAR_RESERVE:
+			CGuildManager::instance().ReserveWar(p->dwGuildFrom, p->dwGuildTo, p->bType);
+			break;
+
+		default:
+			sys_err("Unknown guild war state");
+			break;
+	}
+}
+
+void CInputDB::GuildWarScore(const char* c_pData)
+{
+	TPacketGuildWarScore* p = (TPacketGuildWarScore*)c_pData;
+	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuildGainPoint);
+	g->SetWarScoreAgainstTo(p->dwGuildOpponent, p->lScore);
+}
+
+void CInputDB::GuildSkillRecharge()
+{
+	CGuildManager::instance().SkillRecharge();
+}
+
+void CInputDB::GuildExpUpdate(const char* c_pData)
+{
+	TPacketGuildSkillUpdate* p = (TPacketGuildSkillUpdate*)c_pData;
+	sys_log(1, "GuildExpUpdate %d", p->amount);
+
+	CGuild* g = CGuildManager::instance().TouchGuild(p->guild_id);
+
+	if (g)
+		g->GuildPointChange(POINT_EXP, p->amount);
+}
+
+void CInputDB::GuildAddMember(const char* c_pData)
+{
+	TPacketDGGuildMember* p = (TPacketDGGuildMember*)c_pData;
+	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
+
+	if (g)
+		g->AddMember(p);
+}
+
+void CInputDB::GuildRemoveMember(const char* c_pData)
+{
+	TPacketGuild* p = (TPacketGuild*)c_pData;
+	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
+
+	if (g)
+		g->RemoveMember(p->dwInfo);
+}
+
+void CInputDB::GuildChangeGrade(const char* c_pData)
+{
+	TPacketGuild* p = (TPacketGuild*)c_pData;
+	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
+
+	if (g)
+		g->P2PChangeGrade((BYTE)p->dwInfo);
+}
+
+void CInputDB::GuildChangeMemberData(const char* c_pData)
+{
+	sys_log(0, "Recv GuildChangeMemberData");
+	TPacketGuildChangeMemberData* p = (TPacketGuildChangeMemberData*)c_pData;
+	CGuild* g = CGuildManager::instance().TouchGuild(p->guild_id);
+
+	if (g)
+		g->ChangeMemberData(p->pid, p->offer, p->level, p->grade);
+}
+
+void CInputDB::GuildDisband(const char* c_pData)
+{
+	TPacketGuild* p = (TPacketGuild*)c_pData;
+	CGuildManager::instance().DisbandGuild(p->dwGuild);
+}
+
+void CInputDB::GuildLadder(const char* c_pData)
+{
+	TPacketGuildLadder* p = (TPacketGuildLadder*)c_pData;
+	sys_log(0, "Recv GuildLadder %u %d / w %d d %d l %d", p->dwGuild, p->lLadderPoint, p->lWin, p->lDraw, p->lLoss);
+	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
+
+	g->SetLadderPoint(p->lLadderPoint);
+	g->SetWarData(p->lWin, p->lDraw, p->lLoss);
+}
+
+void CInputDB::ItemLoad(LPDESC d, const char* c_pData)
+{
+	LPCHARACTER ch;
+
+	if (!d || !(ch = d->GetCharacter()))
+		return;
+
+	if (ch->IsItemLoaded())
+		return;
+
+	DWORD dwCount = decode_4bytes(c_pData);
+	c_pData += sizeof(DWORD);
+
+	sys_log(0, "ITEM_LOAD: COUNT %s %u", ch->GetName(), dwCount);
+
+	std::vector<LPITEM> v;
+
+	TPlayerItem* p = (TPlayerItem*)c_pData;
+
+	for (DWORD i = 0; i < dwCount; ++i, ++p)
+	{
+		LPITEM item = ITEM_MANAGER::instance().CreateItem(p->dwVnum, p->dwCount, p->dwID);
+
+		if (!item)
+		{
+			sys_err("cannot create item by vnum %u (name %s id %u)", p->dwVnum, ch->GetName(), p->dwID);
+			continue;
+		}
+
+		item->SetSkipSave(true);
+#if defined(__SOUL_BIND_SYSTEM__)
+		item->SealItem(p->lSealDate);
+#endif
+		item->SetSockets(p->alSockets);
+		item->SetAttributes(p->aAttr);
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		item->SetTransmutationVnum(p->dwTransmutationVnum);
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		item->SetRefineElement(&p->RefineElement);
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+		item->SetRandomApplies(p->aApplyRandom);
+#endif
+#if defined(__SET_ITEM__)
+		item->SetItemSetValue(p->bSetValue);
+#endif
+
+		if ((p->bWindow == INVENTORY && ch->GetInventoryItem(p->wPos)) ||
+			(p->bWindow == EQUIPMENT && ch->GetEquipmentItem(p->wPos)))
+		{
+			sys_log(0, "ITEM_RESTORE: %s %s", ch->GetName(), item->GetName());
+			v.emplace_back(item);
+		}
+		else
+		{
+			switch (p->bWindow)
+			{
+				case INVENTORY:
+				case DRAGON_SOUL_INVENTORY:
+				case BELT_INVENTORY:
+#if defined(__ATTR_6TH_7TH__)
+				case NPC_STORAGE:
+#endif
+				{
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+					item->AddToCharacter(ch, TItemPos(p->bWindow, p->wPos), false);
+#else
+					item->AddToCharacter(ch, TItemPos(p->bWindow, p->wPos));
+#endif
+				}
+				break;
+
+				case EQUIPMENT:
+				{
+					if (item->CheckItemUseLevel(ch->GetLevel()) == true)
+					{
+						if (item->EquipTo(ch, p->wPos) == false)
+						{
+							v.emplace_back(item);
+						}
+					}
+					else
+					{
+						v.emplace_back(item);
+					}
+				}
+				break;
+			}
+		}
+
+		if (false == item->OnAfterCreatedItem())
+			sys_err("Failed to call ITEM::OnAfterCreatedItem (vnum: %d, id: %d)", item->GetVnum(), item->GetID());
+
+		item->SetSkipSave(false);
+	}
+
+	auto it = v.begin();
+	while (it != v.end())
+	{
+		LPITEM item = *(it++);
+
+		int pos = ch->GetEmptyInventory(item->GetSize());
+		if (pos < 0)
+		{
+			PIXEL_POSITION coord;
+			coord.x = ch->GetX();
+			coord.y = ch->GetY();
+
+			item->AddToGround(ch->GetMapIndex(), coord);
+			item->SetOwnership(ch, 180);
+			item->StartDestroyEvent();
+		}
+		else
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			item->AddToCharacter(ch, TItemPos(INVENTORY, pos), false);
+#else
+			item->AddToCharacter(ch, TItemPos(INVENTORY, pos));
+#endif
+	}
+
+#if defined(__WEAPON_COSTUME_SYSTEM__) && defined(__HIDE_WEAPON_COSTUME_WITH_NO_MAIN_WEAPON__)
+	if (ch->GetWear(WEAR_COSTUME_WEAPON) && !ch->GetWear(WEAR_WEAPON))
+		ch->SetPart(PART_WEAPON, 0);
+#endif
+
+	ch->CheckMaximumPoints();
+	ch->PointsPacket();
+
+	ch->SetItemLoaded();
+}
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+void CInputDB::ExtBattlePassLoad(LPDESC d, const char* c_pData)
+{
+	if (!d || !d->GetCharacter())
+		return;
+
+	LPCHARACTER ch = d->GetCharacter();
+	if (!ch)
+		return;
+
+	DWORD dwPID = decode_4bytes(c_pData);
+	c_pData += sizeof(DWORD);
+
+	DWORD dwCount = decode_4bytes(c_pData);
+	c_pData += sizeof(DWORD);
+
+	if (ch->GetPlayerID() != dwPID)
+		return;
+
+	ch->LoadExtBattlePass(dwCount, (TPlayerExtBattlePassMission*)c_pData);
+}
+#endif
+
+void CInputDB::AffectLoad(LPDESC d, const char* c_pData)
+{
+	if (!d)
+		return;
+
+	if (!d->GetCharacter())
+		return;
+
+	LPCHARACTER ch = d->GetCharacter();
+
+	DWORD dwPID = decode_4bytes(c_pData);
+	c_pData += sizeof(DWORD);
+
+	DWORD dwCount = decode_4bytes(c_pData);
+	c_pData += sizeof(DWORD);
+
+	if (ch->GetPlayerID() != dwPID)
+		return;
+
+	ch->LoadAffect(dwCount, (TPacketAffectElement*)c_pData);
+}
+
+void CInputDB::PartyCreate(const char* c_pData)
+{
+	TPacketPartyCreate* p = (TPacketPartyCreate*)c_pData;
+	CPartyManager::instance().P2PCreateParty(p->dwLeaderPID);
+}
+
+void CInputDB::PartyDelete(const char* c_pData)
+{
+	TPacketPartyDelete* p = (TPacketPartyDelete*)c_pData;
+	CPartyManager::instance().P2PDeleteParty(p->dwLeaderPID);
+}
+
+void CInputDB::PartyAdd(const char* c_pData)
+{
+	TPacketPartyAdd* p = (TPacketPartyAdd*)c_pData;
+	CPartyManager::instance().P2PJoinParty(p->dwLeaderPID, p->dwPID, p->bState);
+}
+
+void CInputDB::PartyRemove(const char* c_pData)
+{
+	TPacketPartyRemove* p = (TPacketPartyRemove*)c_pData;
+	CPartyManager::instance().P2PQuitParty(p->dwPID);
+}
+
+void CInputDB::PartyStateChange(const char* c_pData)
+{
+	TPacketPartyStateChange* p = (TPacketPartyStateChange*)c_pData;
+	LPPARTY pParty = CPartyManager::instance().P2PCreateParty(p->dwLeaderPID);
+
+	if (!pParty)
+		return;
+
+	pParty->SetRole(p->dwPID, p->bRole, p->bFlag);
+}
+
+void CInputDB::PartySetMemberLevel(const char* c_pData)
+{
+	TPacketPartySetMemberLevel* p = (TPacketPartySetMemberLevel*)c_pData;
+	LPPARTY pParty = CPartyManager::instance().P2PCreateParty(p->dwLeaderPID);
+
+	if (!pParty)
+		return;
+
+	pParty->P2PSetMemberLevel(p->dwPID, p->bLevel);
+}
+
+void CInputDB::Time(const char* c_pData)
+{
+	set_global_time(*(time_t*)c_pData);
+}
+
+void CInputDB::ReloadProto(const char* c_pData)
+{
+	WORD wSize;
+
+	/*
+	* Skill
+	*/
+
+	wSize = decode_2bytes(c_pData);
+	c_pData += sizeof(WORD);
+	if (wSize) CSkillManager::instance().Initialize((TSkillTable*)c_pData, wSize);
+	c_pData += sizeof(TSkillTable) * wSize;
+
+	/*
+	* Banwords
+	*/
+
+	wSize = decode_2bytes(c_pData);
+	c_pData += sizeof(WORD);
+	CBanwordManager::instance().Initialize((TBanwordTable*)c_pData, wSize);
+	c_pData += sizeof(TBanwordTable) * wSize;
+
+	/*
+	* ITEM
+	*/
+
+	wSize = decode_2bytes(c_pData);
+	c_pData += 2;
+	sys_log(0, "RELOAD: ITEM: %d", wSize);
+
+	if (wSize)
+	{
+		ITEM_MANAGER::instance().Initialize((TItemTable*)c_pData, wSize);
+		c_pData += wSize * sizeof(TItemTable);
+	}
+
+	/*
+	* MONSTER
+	*/
+
+	wSize = decode_2bytes(c_pData);
+	c_pData += 2;
+	sys_log(0, "RELOAD: MOB: %d", wSize);
+
+	if (wSize)
+	{
+		CMobManager::instance().Initialize((TMobTable*)c_pData, wSize);
+		c_pData += wSize * sizeof(TMobTable);
+	}
+
+	/*
+	* REFINE
+	*/
+
+	wSize = decode_2bytes(c_pData);
+	c_pData += 2;
+	sys_log(0, "RELOAD: REFINE: %d", wSize);
+
+	if (wSize)
+	{
+		CRefineManager::instance().Initialize((TRefineTable*)c_pData, wSize);
+		c_pData += wSize * sizeof(TRefineTable);
+	}
+
+#ifdef __GROWTH_PET_SYSTEM__
+void CInputDB::GrowthPetLoad(LPDESC d, const char* c_pData)
+{
+	LPCHARACTER ch;
+
+	if (!d || !(ch = d->GetCharacter()))
+		return;
+
+	if (ch->IsGrowthPetLoaded())
+		return;
+
+	DWORD dwCount = decode_4bytes(c_pData);
+	c_pData += sizeof(DWORD);
+
+	sys_log(0, "GROWTH_PET_LOAD: COUNT %s %u", ch->GetName(), dwCount);
+
+	TGrowthPet* p = (TGrowthPet*)c_pData;
+
+	for (DWORD i = 0; i < dwCount; ++i, ++p)
+	{
+		LPGROWTH_PET pPet = CGrowthPetManager::Instance().CreateGrowthPet(ch, p->dwID);
+		if (pPet)
+		{
+			pPet->SetGrowthPetProto(p);
+			ch->SetGrowthPet(pPet);
+		}
+	}
+
+	ch->SetGrowthPetLoaded(true);
+}
+#endif
+
+	CMotionManager::instance().Build();
+
+	CHARACTER_MANAGER::instance().for_each_pc(std::mem_fn(&CHARACTER::ComputePoints));
+}
+
+void CInputDB::GuildSkillUsableChange(const char* c_pData)
+{
+	TPacketGuildSkillUsableChange* p = (TPacketGuildSkillUsableChange*)c_pData;
+
+	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
+
+	g->SkillUsableChange(p->dwSkillVnum, p->bUsable ? true : false);
+}
+
+void CInputDB::AuthLogin(LPDESC d, const char* c_pData)
+{
+	if (!d)
+		return;
+
+	BYTE bResult = *(BYTE*)c_pData;
+
+	TPacketGCAuthSuccess ptoc;
+
+	ptoc.bHeader = HEADER_GC_AUTH_SUCCESS;
+
+	if (bResult)
+	{
+		// Panama 호화 肌 却 키 
+		SendPanamaList(d);
+		ptoc.dwLoginKey = d->GetLoginKey();
+
+		// NOTE: AuthSucess   홧瀏 PHASE Close 퓬  苛쨈.-_-
+		// Send Client Package CryptKey
+		{
+			DESC_MANAGER::instance().SendClientPackageCryptKey(d);
+			DESC_MANAGER::instance().SendClientPackageSDBToLoadMap(d, MAPNAME_DEFAULT);
+		}
+	}
+	else
+	{
+		ptoc.dwLoginKey = 0;
+	}
+
+	ptoc.bResult = bResult;
+
+	d->Packet(&ptoc, sizeof(TPacketGCAuthSuccess));
+	sys_log(0, "AuthLogin result %u key %u", bResult, d->GetLoginKey());
+}
+
+void CInputDB::ChangeEmpirePriv(const char* c_pData)
+{
+	TPacketDGChangeEmpirePriv* p = (TPacketDGChangeEmpirePriv*)c_pData;
+
+	// ADD_EMPIRE_PRIV_TIME
+	CPrivManager::instance().GiveEmpirePriv(p->empire, p->type, p->value, p->bLog, p->end_time_sec);
+	// END_OF_ADD_EMPIRE_PRIV_TIME
+}
+
+/**
+* @version 05/06/08 Bang2ni - 擔챨 煞
+**/
+void CInputDB::ChangeGuildPriv(const char* c_pData)
+{
+	TPacketDGChangeGuildPriv* p = (TPacketDGChangeGuildPriv*)c_pData;
+
+	// ADD_GUILD_PRIV_TIME
+	CPrivManager::instance().GiveGuildPriv(p->guild_id, p->type, p->value, p->bLog, p->end_time_sec);
+	// END_OF_ADD_GUILD_PRIV_TIME
+}
+
+void CInputDB::ChangeCharacterPriv(const char* c_pData)
+{
+	TPacketDGChangeCharacterPriv* p = (TPacketDGChangeCharacterPriv*)c_pData;
+	CPrivManager::instance().GiveCharacterPriv(p->pid, p->type, p->value, p->bLog);
+}
+
+void CInputDB::MoneyLog(const char* c_pData)
+{
+	TPacketMoneyLog* p = (TPacketMoneyLog*)c_pData;
+
+	if (p->type == 4) // QUEST_MONEY_LOG_SKIP
+		return;
+
+	if (g_bAuthServer == true)
+		return;
+
+	LogManager::instance().MoneyLog(p->type, p->vnum, p->gold
+#if defined(__CHEQUE_SYSTEM__)
+		, p->cheque
+#endif
+	);
+}
+
+void CInputDB::GuildMoneyChange(const char* c_pData)
+{
+	TPacketDGGuildMoneyChange* p = (TPacketDGGuildMoneyChange*)c_pData;
+
+	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
+	if (g)
+	{
+		g->RecvMoneyChange(p->iTotalGold);
+	}
+}
+
+void CInputDB::GuildWithdrawMoney(const char* c_pData)
+{
+	TPacketDGGuildMoneyWithdraw* p = (TPacketDGGuildMoneyWithdraw*)c_pData;
+
+	CGuild* g = CGuildManager::instance().TouchGuild(p->dwGuild);
+	if (g)
+	{
+		g->RecvWithdrawMoneyGive(p->iChangeGold);
+	}
+}
+
+void CInputDB::SetEventFlag(const char* c_pData)
+{
+	TPacketSetEventFlag* p = (TPacketSetEventFlag*)c_pData;
+	quest::CQuestManager::instance().SetEventFlag(p->szFlagName, p->lValue);
+}
+
+void CInputDB::CreateObject(const char* c_pData)
+{
+	using namespace building;
+	CManager::instance().LoadObject((TObject*)c_pData);
+}
+
+void CInputDB::DeleteObject(const char* c_pData)
+{
+	using namespace building;
+	CManager::instance().DeleteObject(*(DWORD*)c_pData);
+}
+
+void CInputDB::UpdateLand(const char* c_pData)
+{
+	using namespace building;
+	CManager::instance().UpdateLand((TLand*)c_pData);
+}
+
+void CInputDB::Notice(const char* c_pData)
+{
+	extern void SendNotice(const char* c_pszBuf, const bool c_bBigFont = false);
+
+	char szBuf[256 + 1];
+	strlcpy(szBuf, c_pData, sizeof(szBuf));
+
+	sys_log(0, "InputDB:: Notice: %s", szBuf);
+
+	//SendNotice(LC_STRING(szBuf));
+	SendNotice(szBuf);
+}
+
+void CInputDB::GuildWarReserveAdd(TGuildWarReserve* p)
+{
+	CGuildManager::instance().ReserveWarAdd(p);
+}
+
+void CInputDB::GuildWarReserveDelete(DWORD dwID)
+{
+	CGuildManager::instance().ReserveWarDelete(dwID);
+}
+
+void CInputDB::GuildWarBet(TPacketGDGuildWarBet* p)
+{
+	CGuildManager::instance().ReserveWarBet(p);
+}
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+void CInputDB::GuildSetEventFlag(const char* c_pData)
+{
+	const TPacketSetGuildEventFlag* p = (TPacketSetGuildEventFlag*)c_pData;
+	CGuildManager::Instance().SetEventFlag(p->dwGuildID, p->szFlagName, p->lValue);
+}
+#endif
+
+void CInputDB::MarriageAdd(TPacketMarriageAdd* p)
+{
+	sys_log(0, "MarriageAdd %u %u %u %s %s", p->dwPID1, p->dwPID2, (DWORD)p->tMarryTime, p->szName1, p->szName2);
+	marriage::CManager::instance().Add(p->dwPID1, p->dwPID2, p->tMarryTime, p->szName1, p->szName2);
+}
+
+void CInputDB::MarriageUpdate(TPacketMarriageUpdate* p)
+{
+	sys_log(0, "MarriageUpdate %u %u %d %d", p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
+	marriage::CManager::instance().Update(p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
+}
+
+void CInputDB::MarriageRemove(TPacketMarriageRemove* p)
+{
+	sys_log(0, "MarriageRemove %u %u", p->dwPID1, p->dwPID2);
+	marriage::CManager::instance().Remove(p->dwPID1, p->dwPID2);
+}
+
+void CInputDB::WeddingRequest(TPacketWeddingRequest* p)
+{
+	marriage::WeddingManager::instance().Request(p->dwPID1, p->dwPID2);
+}
+
+void CInputDB::WeddingReady(TPacketWeddingReady* p)
+{
+	sys_log(0, "WeddingReady %u %u %u", p->dwPID1, p->dwPID2, p->dwMapIndex);
+	marriage::CManager::instance().WeddingReady(p->dwPID1, p->dwPID2, p->dwMapIndex);
+}
+
+void CInputDB::WeddingStart(TPacketWeddingStart* p)
+{
+	sys_log(0, "WeddingStart %u %u", p->dwPID1, p->dwPID2);
+	marriage::CManager::instance().WeddingStart(p->dwPID1, p->dwPID2);
+}
+
+void CInputDB::WeddingEnd(TPacketWeddingEnd* p)
+{
+	sys_log(0, "WeddingEnd %u %u", p->dwPID1, p->dwPID2);
+	marriage::CManager::instance().WeddingEnd(p->dwPID1, p->dwPID2);
+}
+
+// MYSHOP_PRICE_LIST
+void CInputDB::MyshopPricelistRes(LPDESC d, const TPacketMyshopPricelistHeader* p)
+{
+	LPCHARACTER ch;
+
+	if (!d || !(ch = d->GetCharacter()))
+		return;
+
+	sys_log(0, "RecvMyshopPricelistRes name[%s]", ch->GetName());
+	ch->UseSilkBotaryReal(p);
+
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+// RELOAD_ADMIN
+void CInputDB::ReloadAdmin(const char* c_pData)
+{
+	gm_new_clear();
+	int ChunkSize = decode_2bytes(c_pData);
+	c_pData += 2;
+	int HostSize = decode_2bytes(c_pData);
+	c_pData += 2;
+
+	for (int n = 0; n < HostSize; ++n)
+	{
+		gm_new_host_inert(c_pData);
+		c_pData += ChunkSize;
+	}
+
+	c_pData += 2;
+	int size = decode_2bytes(c_pData);
+	c_pData += 2;
+
+	for (int n = 0; n < size; ++n)
+	{
+		tAdminInfo& rAdminInfo = *(tAdminInfo*)c_pData;
+
+		gm_new_insert(rAdminInfo);
+
+		c_pData += sizeof(tAdminInfo);
+
+		LPCHARACTER pChar = CHARACTER_MANAGER::instance().FindPC(rAdminInfo.m_szName);
+		if (pChar)
+		{
+			pChar->SetGMLevel();
+		}
+	}
+}
+// END_RELOAD_ADMIN
+
+////////////////////////////////////////////////////////////////////
+// Analyze
+// @version 05/06/10 Bang2ni -   트 킷(HEADER_DG_MYSHOP_PRICELIST_RES) 처틴 煞.
+////////////////////////////////////////////////////////////////////
+int CInputDB::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
+{
+	switch (bHeader)
+	{
+		case HEADER_DG_BOOT:
+			Boot(c_pData);
+			break;
+
+		case HEADER_DG_LOGIN_SUCCESS:
+			LoginSuccess(m_dwHandle, c_pData);
+			break;
+
+		case HEADER_DG_LOGIN_NOT_EXIST:
+			LoginFailure(DESC_MANAGER::instance().FindByHandle(m_dwHandle), "NOID");
+			break;
+
+		case HEADER_DG_LOGIN_WRONG_PASSWD:
+			LoginFailure(DESC_MANAGER::instance().FindByHandle(m_dwHandle), "WRONGPWD");
+			break;
+
+		case HEADER_DG_LOGIN_ALREADY:
+			LoginAlready(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_PLAYER_LOAD_SUCCESS:
+			PlayerLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_PLAYER_CREATE_SUCCESS:
+			PlayerCreateSuccess(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_PLAYER_CREATE_FAILED:
+			PlayerCreateFailure(DESC_MANAGER::instance().FindByHandle(m_dwHandle), 0);
+			break;
+
+		case HEADER_DG_PLAYER_CREATE_ALREADY:
+			PlayerCreateFailure(DESC_MANAGER::instance().FindByHandle(m_dwHandle), 1);
+			break;
+
+		case HEADER_DG_PLAYER_DELETE_SUCCESS:
+			PlayerDeleteSuccess(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_PLAYER_LOAD_FAILED:
+			//sys_log(0, "PLAYER_LOAD_FAILED");
+			break;
+
+		case HEADER_DG_PLAYER_DELETE_FAILED:
+			//sys_log(0, "PLAYER_DELETE_FAILED");
+#if defined(__DELETE_FAILURE_TYPE__)
+			PlayerDeleteFail(DESC_MANAGER::Instance().FindByHandle(m_dwHandle), c_pData);
+#else
+			PlayerDeleteFail(DESC_MANAGER::instance().FindByHandle(m_dwHandle));
+#endif
+			break;
+
+		case HEADER_DG_ITEM_LOAD:
+			ItemLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_QUEST_LOAD:
+			QuestLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_AFFECT_LOAD:
+			AffectLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_SAFEBOX_LOAD:
+			SafeboxLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_SAFEBOX_CHANGE_SIZE:
+			SafeboxChangeSize(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_SAFEBOX_WRONG_PASSWORD:
+			SafeboxWrongPassword(DESC_MANAGER::instance().FindByHandle(m_dwHandle));
+			break;
+
+		case HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER:
+			SafeboxChangePasswordAnswer(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_MALL_LOAD:
+			MallLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_EMPIRE_SELECT:
+			EmpireSelect(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_MAP_LOCATIONS:
+			MapLocations(c_pData);
+			break;
+
+		case HEADER_DG_P2P:
+			P2P(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_SKILL_UPDATE:
+			GuildSkillUpdate(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_LOAD:
+			GuildLoad(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_SKILL_RECHARGE:
+			GuildSkillRecharge();
+			break;
+
+		case HEADER_DG_GUILD_EXP_UPDATE:
+			GuildExpUpdate(c_pData);
+			break;
+
+		case HEADER_DG_PARTY_CREATE:
+			PartyCreate(c_pData);
+			break;
+
+		case HEADER_DG_PARTY_DELETE:
+			PartyDelete(c_pData);
+			break;
+
+		case HEADER_DG_PARTY_ADD:
+			PartyAdd(c_pData);
+			break;
+
+		case HEADER_DG_PARTY_REMOVE:
+			PartyRemove(c_pData);
+			break;
+
+		case HEADER_DG_PARTY_STATE_CHANGE:
+			PartyStateChange(c_pData);
+			break;
+
+		case HEADER_DG_PARTY_SET_MEMBER_LEVEL:
+			PartySetMemberLevel(c_pData);
+			break;
+
+		case HEADER_DG_TIME:
+			Time(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_ADD_MEMBER:
+			GuildAddMember(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_REMOVE_MEMBER:
+			GuildRemoveMember(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_CHANGE_GRADE:
+			GuildChangeGrade(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_CHANGE_MEMBER_DATA:
+			GuildChangeMemberData(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_DISBAND:
+			GuildDisband(c_pData);
+			break;
+
+		case HEADER_DG_RELOAD_PROTO:
+			ReloadProto(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_WAR:
+			GuildWar(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_WAR_SCORE:
+			GuildWarScore(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_LADDER:
+			GuildLadder(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_SKILL_USABLE_CHANGE:
+			GuildSkillUsableChange(c_pData);
+			break;
+
+		case HEADER_DG_CHANGE_NAME:
+			ChangeName(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_AUTH_LOGIN:
+			AuthLogin(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_CHANGE_EMPIRE_PRIV:
+			ChangeEmpirePriv(c_pData);
+			break;
+
+		case HEADER_DG_CHANGE_GUILD_PRIV:
+			ChangeGuildPriv(c_pData);
+			break;
+
+		case HEADER_DG_CHANGE_CHARACTER_PRIV:
+			ChangeCharacterPriv(c_pData);
+			break;
+
+		case HEADER_DG_MONEY_LOG:
+			MoneyLog(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_WITHDRAW_MONEY_GIVE:
+			GuildWithdrawMoney(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_MONEY_CHANGE:
+			GuildMoneyChange(c_pData);
+			break;
+
+		case HEADER_DG_SET_EVENT_FLAG:
+			SetEventFlag(c_pData);
+			break;
+
+		case HEADER_DG_CREATE_OBJECT:
+			CreateObject(c_pData);
+			break;
+
+		case HEADER_DG_DELETE_OBJECT:
+			DeleteObject(c_pData);
+			break;
+
+		case HEADER_DG_UPDATE_LAND:
+			UpdateLand(c_pData);
+			break;
+
+		case HEADER_DG_NOTICE:
+			Notice(c_pData);
+			break;
+
+		case HEADER_DG_GUILD_WAR_RESERVE_ADD:
+			GuildWarReserveAdd((TGuildWarReserve*)c_pData);
+			break;
+
+		case HEADER_DG_GUILD_WAR_RESERVE_DEL:
+			GuildWarReserveDelete(*(DWORD*)c_pData);
+			break;
+
+		case HEADER_DG_GUILD_WAR_BET:
+			GuildWarBet((TPacketGDGuildWarBet*)c_pData);
+			break;
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+		case HEADER_DG_GUILD_EVENT_FLAG:
+			GuildSetEventFlag(c_pData);
+			break;
+#endif
+
+		case HEADER_DG_MARRIAGE_ADD:
+			MarriageAdd((TPacketMarriageAdd*)c_pData);
+			break;
+
+		case HEADER_DG_MARRIAGE_UPDATE:
+			MarriageUpdate((TPacketMarriageUpdate*)c_pData);
+			break;
+
+		case HEADER_DG_MARRIAGE_REMOVE:
+			MarriageRemove((TPacketMarriageRemove*)c_pData);
+			break;
+
+		case HEADER_DG_WEDDING_REQUEST:
+			WeddingRequest((TPacketWeddingRequest*)c_pData);
+			break;
+
+		case HEADER_DG_WEDDING_READY:
+			WeddingReady((TPacketWeddingReady*)c_pData);
+			break;
+
+		case HEADER_DG_WEDDING_START:
+			WeddingStart((TPacketWeddingStart*)c_pData);
+			break;
+
+		case HEADER_DG_WEDDING_END:
+			WeddingEnd((TPacketWeddingEnd*)c_pData);
+			break;
+
+			// MYSHOP_PRICE_LIST
+		case HEADER_DG_MYSHOP_PRICELIST_RES:
+			MyshopPricelistRes(DESC_MANAGER::instance().FindByHandle(m_dwHandle), (TPacketMyshopPricelistHeader*)c_pData);
+			break;
+			// END_OF_MYSHOP_PRICE_LIST
+
+			// RELOAD_ADMIN
+		case HEADER_DG_RELOAD_ADMIN:
+			ReloadAdmin(c_pData);
+			break;
+			// END_RELOAD_ADMIN
+
+		case HEADER_DG_ADD_MONARCH_MONEY:
+			AddMonarchMoney(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_DEC_MONARCH_MONEY:
+			DecMonarchMoney(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_TAKE_MONARCH_MONEY:
+			TakeMonarchMoney(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_CHANGE_MONARCH_LORD_ACK:
+			ChangeMonarchLord((TPacketChangeMonarchLordACK*)c_pData);
+			break;
+
+		case HEADER_DG_UPDATE_MONARCH_INFO:
+			UpdateMonarchInfo((TMonarchInfo*)c_pData);
+			break;
+
+		case HEADER_DG_BLOCK_COUNTRY_IP:
+			this->AddBlockCountryIp((TPacketBlockCountryIp*)c_pData);
+			break;
+		case HEADER_DG_BLOCK_EXCEPTION:
+			this->BlockException((TPacketBlockException*)c_pData);
+			break;
+
+		case HEADER_DG_ACK_CHANGE_GUILD_MASTER:
+			this->GuildChangeMaster((TPacketChangeGuildMaster*)c_pData);
+			break;
+
+		case HEADER_DG_ACK_SPARE_ITEM_ID_RANGE:
+			ITEM_MANAGER::instance().SetMaxSpareItemID(*((TItemIDRangeTable*)c_pData));
+			break;
+
+		case HEADER_DG_UPDATE_HORSE_NAME:
+		case HEADER_DG_ACK_HORSE_NAME:
+			CHorseNameManager::instance().UpdateHorseName(
+				((TPacketUpdateHorseName*)c_pData)->dwPlayerID,
+				((TPacketUpdateHorseName*)c_pData)->szHorseName);
+			break;
+
+		case HEADER_DG_NEED_LOGIN_LOG:
+			DetailLog((TPacketNeedLoginLogInfo*)c_pData);
+			break;
+
+			//    謬트
+		case HEADER_DG_ITEMAWARD_INFORMER:
+			ItemAwardInformer((TPacketItemAwardInfromer*)c_pData);
+			break;
+
+		case HEADER_DG_RESPOND_CHANNELSTATUS:
+			RespondChannelStatus(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+#if defined(__MOVE_CHANNEL__)
+		case HEADER_DG_CHANNEL_RESULT:
+			MoveChannel(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+#endif
+
+#if defined(__MAILBOX__)
+		case HEADER_DG_RESPOND_MAILBOX_LOAD:
+			MailBoxRespondLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_RESPOND_MAILBOX_CHECK_NAME:
+			MailBoxRespondName(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_RESPOND_MAILBOX_UNREAD:
+			MailBoxRespondUnreadData(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+#endif
+
+#if defined(__GEM_SHOP__)
+		case HEADER_DG_GEM_SHOP_LOAD:
+			GemShopLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_GEM_SHOP_UPDATE:
+			GemShopUpdate(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+		case HEADER_DG_EMOTE_LOAD:
+			EmoteLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_EMOTE_GET:
+			EmoteGet(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+#endif
+
+#ifdef __SHOP_SEARCH__
+		case HEADER_DG_SHOP_SEARCH_RESULT:
+		{
+			LPDESC chDesc = DESC_MANAGER::instance().FindByHandle(m_dwHandle);
+			if (!chDesc || !chDesc->GetCharacter())
+				break;
+
+			WORD maxPageNum = *(WORD*)c_pData;
+			c_pData += sizeof(WORD);
+			WORD itemCount = *(WORD*)c_pData;
+			c_pData += sizeof(WORD);
+
+			CShopSearchManager::DB_ResultSearch(chDesc->GetCharacter(), maxPageNum, (const TShopSearchClientItem*)c_pData, itemCount);
+		}
+		break;
+
+		case HEADER_DG_SHOP_SEARCH_BUY_FROM_SHOP:
+			CShopSearchManager::DB_BuyFromShop((const TPacketDGShopSearchBuyFromShop*)c_pData);
+			break;
+
+		case HEADER_DG_SHOP_SEARCH_BUY_RESULT:
+			CShopSearchManager::DB_BuyResult(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+
+		case HEADER_DG_SHOP_SEARCH_SOLD_INFO:
+		{
+			LPDESC chDesc = DESC_MANAGER::instance().FindByHandle(m_dwHandle);
+			if (!chDesc || !chDesc->GetCharacter())
+				break;
+
+			bool hasResults = *(bool*)c_pData;
+			c_pData += sizeof(bool);
+
+			CShopSearchManager::DB_SoldInfo(chDesc->GetCharacter(), hasResults, (const TShopSearchSoldItemInfo*)c_pData);
+		}
+		break;
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	case HEADER_DG_GROWTH_PET_LOAD:
+		GrowthPetLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+		break;
+#endif
+
+#ifdef __OFFLINE_SHOP__
+		case HEADER_DG_RESPOND_OFFLINE_SHOP_ID:
+			RespondOfflineShopId(c_pData);
+			break;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		case HEADER_DG_EXT_BATTLE_PASS_LOAD:
+			ExtBattlePassLoad(DESC_MANAGER::instance().FindByHandle(m_dwHandle), c_pData);
+			break;
+#endif
+
+		default:
+			return (-1);
+	}
+
+	return 0;
+}
+
+bool CInputDB::Process(LPDESC d, const void* orig, int bytes, int& r_iBytesProceed)
+{
+	const char* c_pData = (const char*)orig;
+	BYTE bHeader, bLastHeader = 0;
+	int iSize;
+	int iLastPacketLen = 0;
+
+	for (m_iBufferLeft = bytes; m_iBufferLeft > 0;)
+	{
+		if (m_iBufferLeft < 9)
+			return true;
+
+		bHeader = *((BYTE*)(c_pData)); // 1
+		m_dwHandle = *((DWORD*)(c_pData + 1)); // 4
+		iSize = *((DWORD*)(c_pData + 5)); // 4
+
+		sys_log(1, "DBCLIENT: header %d handle %d size %d bytes %d", bHeader, m_dwHandle, iSize, bytes);
+
+		if (m_iBufferLeft - 9 < iSize)
+			return true;
+
+		const char* pRealData = (c_pData + 9);
+
+		if (Analyze(d, bHeader, pRealData) < 0)
+		{
+			sys_err("in InputDB: UNKNOWN HEADER: %d, LAST HEADER: %d(%d), REMAIN BYTES: %d, DESC: %d",
+				bHeader, bLastHeader, iLastPacketLen, m_iBufferLeft, d->GetSocket());
+
+			// printdata((BYTE*) orig, bytes);
+			// d->SetPhase(PHASE_CLOSE);
+		}
+
+		c_pData += 9 + iSize;
+		m_iBufferLeft -= 9 + iSize;
+		r_iBytesProceed += 9 + iSize;
+
+		iLastPacketLen = 9 + iSize;
+		bLastHeader = bHeader;
+	}
+
+	return true;
+}
+
+void CInputDB::AddMonarchMoney(LPDESC d, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	CMonarch::instance().AddMoney(Money, Empire);
+
+	DWORD pid = CMonarch::instance().GetMonarchPID(Empire);
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
+
+	if (ch)
+	{
+		if (number(1, 100) > 95)
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" %s  %u   笭求", EMPIRE_NAME(Empire), CMonarch::instance().GetMoney(Empire)));
+	}
+}
+
+void CInputDB::DecMonarchMoney(LPDESC d, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	CMonarch::instance().DecMoney(Money, Empire);
+
+	DWORD pid = CMonarch::instance().GetMonarchPID(Empire);
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(pid);
+
+	if (ch)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" %s  %d   笭求", EMPIRE_NAME(Empire), CMonarch::instance().GetMoney(Empire)));
+	}
+}
+
+void CInputDB::TakeMonarchMoney(LPDESC d, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	if (!CMonarch::instance().DecMoney(Money, Empire))
+	{
+		if (!d)
+			return;
+
+		if (!d->GetCharacter())
+			return;
+
+		LPCHARACTER ch = d->GetCharacter();
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  構킬  체  황都求"));
+	}
+}
+
+void CInputDB::ChangeMonarchLord(TPacketChangeMonarchLordACK* info)
+{
+	char notice[256];
+	snprintf(notice, sizeof(notice), LC_STRING("%s 斂 %s  체퓸求.", EMPIRE_NAME(info->bEmpire), info->szName));
+	SendNotice(notice);
+}
+
+void CInputDB::UpdateMonarchInfo(TMonarchInfo* info)
+{
+	CMonarch::instance().SetMonarchInfo(info);
+	sys_log(0, "MONARCH INFO UPDATED");
+}
+
+void CInputDB::AddBlockCountryIp(TPacketBlockCountryIp* data)
+{
+	add_blocked_country_ip(data);
+}
+
+void CInputDB::BlockException(TPacketBlockException* data)
+{
+	block_exception(data);
+}
+
+void CInputDB::GuildChangeMaster(TPacketChangeGuildMaster* p)
+{
+	CGuildManager::instance().ChangeMaster(p->dwGuildID);
+}
+
+void CInputDB::DetailLog(const TPacketNeedLoginLogInfo* info)
+{
+	if (true == LC_IsEurope() || true == LC_IsYMIR() || true == LC_IsKorea())
+	{
+		LPCHARACTER pChar = CHARACTER_MANAGER::instance().FindByPID(info->dwPlayerID);
+
+		if (NULL != pChar)
+		{
+			LogManager::instance().DetailLoginLog(true, pChar);
+		}
+	}
+}
+
+void CInputDB::ItemAwardInformer(TPacketItemAwardInfromer* data)
+{
+	LPDESC d = DESC_MANAGER::instance().FindByLoginName(data->login); // login 
+
+	if (d == NULL)
+		return;
+
+	if (d->GetCharacter())
+	{
+		LPCHARACTER ch = d->GetCharacter();
+		ch->SetItemAward_vnum(data->vnum); // ch  擔 卍鳴 QuestLoad 獨 처
+		ch->SetItemAward_cmd(data->command);
+
+		if (d->IsPhase(PHASE_GAME)) // 灸
+		{
+			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("You have recieved a gift! Check your Item Shop-Storeroom."));
+			ch->ChatPacket(CHAT_TYPE_COMMAND, "gift");
+
+			quest::CQuestManager::instance().ItemInformer(ch->GetPlayerID(), ch->GetItemAward_vnum()); // questmanager 호
+		}
+	}
+}
+
+void CInputDB::RespondChannelStatus(LPDESC desc, const char* pcData)
+{
+	if (!desc)
+		return;
+
+	const int nSize = decode_4bytes(pcData);
+	pcData += sizeof(nSize);
+
+	BYTE bHeader = HEADER_GC_RESPOND_CHANNELSTATUS;
+	desc->BufferedPacket(&bHeader, sizeof(BYTE));
+	desc->BufferedPacket(&nSize, sizeof(nSize));
+	if (0 < nSize)
+	{
+		desc->BufferedPacket(pcData, sizeof(TChannelStatus) * nSize);
+	}
+
+	BYTE bSuccess = 1;
+	desc->Packet(&bSuccess, sizeof(bSuccess));
+	desc->SetChannelStatusRequested(false);
+}
+
+#if defined(__MOVE_CHANNEL__)
+void CInputDB::MoveChannel(LPDESC d, const char* pcData)
+{
+	if (!d || !d->GetCharacter())
+	{
+		sys_err("Change channel request with empty or invalid description handle!");
+		return;
+	}
+
+	TPacketReturnChannel* p = (TPacketReturnChannel*)pcData;
+
+	if (!p->lAddr || !p->wPort)
+	{
+		std::string pName = d->GetCharacter()->GetName();
+		d->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Cannot change channel."));
+		sys_err("Can't move channel for player %s!", pName.c_str());
+		return;
+	}
+
+	d->GetCharacter()->StartMoveChannel(p->lAddr, p->wPort);
+}
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+void CInputDB::EmoteLoad(LPDESC pDesc, const char* c_pData)
+{
+	if (pDesc == nullptr)
+		return;
+
+	const LPCHARACTER pkChar = pDesc->GetCharacter();
+	if (pkChar == nullptr)
+		return;
+
+	WORD wSize;
+	if (decode_2bytes(c_pData) != sizeof(TPacketGDEmote))
+	{
+		sys_err("emotion table size error");
+		return;
+	}
+
+	c_pData += 2;
+	wSize = decode_2bytes(c_pData);
+	c_pData += 2;
+
+	pkChar->SetEmotes((TPacketGDEmote*)c_pData, wSize);
+}
+
+void CInputDB::EmoteGet(LPDESC pDesc, const char* c_pData)
+{
+	const TPacketGDEmote* pPacket = reinterpret_cast<const TPacketGDEmote*>(c_pData);
+	if (pPacket == nullptr || pDesc == nullptr)
+		return;
+
+	TPacketGCEmote GCPacket;
+	GCPacket.bHeader = HEADER_GC_EMOTE;
+	GCPacket.bSubHeader = SUBHEADER_EMOTE_ADD;
+	GCPacket.dwEmoteVnum = pPacket->dwVnum;
+	GCPacket.dwDuration = pPacket->dwDuration;
+	pDesc->Packet(&GCPacket, sizeof(TPacketGCEmote));
+}
+#endif
+
+#if defined(__MAILBOX__)
+void CInputDB::MailBoxRespondLoad(LPDESC d, const char* c_pData)
+{
+	if (!d)
+		return;
+
+	const LPCHARACTER ch = d->GetCharacter();
+	if (ch == nullptr)
+		return;
+
+	WORD size;
+
+	if (decode_2bytes(c_pData) != sizeof(TMailBoxTable))
+	{
+		sys_err("mailbox table size error");
+		return;
+	}
+
+	c_pData += 2;
+	size = decode_2bytes(c_pData);
+	c_pData += 2;
+
+	CMailBox::Create(ch, (TMailBoxTable*)c_pData, size);
+}
+
+void CInputDB::MailBoxRespondName(LPDESC d, const char* c_pData)
+{
+	if (d == nullptr)
+		return;
+
+	const LPCHARACTER ch = d->GetCharacter();
+	if (ch == nullptr)
+		return;
+
+	CMailBox* mail = ch->GetMailBox();
+	if (mail == nullptr)
+		return;
+
+	mail->CheckPlayerResult((TMailBox*)c_pData);
+}
+
+void CInputDB::MailBoxRespondUnreadData(LPDESC d, const char* c_pData)
+{
+	if (d == nullptr)
+		return;
+
+	CMailBox::ResultUnreadData(d->GetCharacter(), (TMailBoxRespondUnreadData*)c_pData);
+}
+#endif
+
+#if defined(__GEM_SHOP__)
+void CInputDB::GemShopLoad(LPDESC lpDesc, const char* c_pszData)
+{
+	if (!lpDesc)
+		return;
+
+	const LPCHARACTER c_lpCh = lpDesc->GetCharacter();
+	if (c_lpCh == nullptr)
+		return;
+
+	CGemShop::Create(c_lpCh, (TGemShopTable*)c_pszData);
+}
+
+void CInputDB::GemShopUpdate(LPDESC lpDesc, const char* c_pszData)
+{
+	if (!lpDesc)
+		return;
+
+	const LPCHARACTER c_lpCh = lpDesc->GetCharacter();
+	if (c_lpCh == nullptr)
+		return;
+
+	CGemShop* pGemShop = c_lpCh->GetGemShop();
+	if (pGemShop == nullptr)
+		return;
+
+	pGemShop->Update((TGemShopTable*)c_pszData);
+}
+#endif
+
+#ifdef __OFFLINE_SHOP__
+void CInputDB::RespondOfflineShopId(const char* data)
+{
+	auto queueId = *reinterpret_cast<const uint32_t*>(data);
+	auto shopId = *reinterpret_cast<const uint32_t*>(data + sizeof(uint32_t));
+
+	COfflineShop::DequeueCreate(queueId, shopId);
+}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+void CInputDB::GrowthPetLoad(LPDESC d, const char* c_pData)
+{
+	LPCHARACTER ch;
+
+	if (!d || !(ch = d->GetCharacter()))
+		return;
+
+	if (ch->IsGrowthPetLoaded())
+		return;
+
+	DWORD dwCount = decode_4bytes(c_pData);
+	c_pData += sizeof(DWORD);
+
+	sys_log(0, "GROWTH_PET_LOAD: COUNT %s %u", ch->GetName(), dwCount);
+
+	TGrowthPet* p = (TGrowthPet*)c_pData;
+
+	for (DWORD i = 0; i < dwCount; ++i, ++p)
+	{
+		LPGROWTH_PET pPet = CGrowthPetManager::Instance().CreateGrowthPet(ch, p->dwID);
+		if (pPet)
+		{
+			pPet->SetGrowthPetProto(p);
+			ch->SetGrowthPet(pPet);
+		}
+	}
+
+	ch->SetGrowthPetLoaded(true);
+}
+#endif
diff --git a/server/server/home/metin2/Source/Server/game/src/input_login.cpp b/server/server/home/metin2/Source/Server/game/src/input_login.cpp
index 33e711e..b1c28b0 100644
--- a/server/server/home/metin2/Source/Server/game/src/input_login.cpp
+++ b/server/server/home/metin2/Source/Server/game/src/input_login.cpp
@@ -1,1297 +1,1283 @@
-#include "stdafx.h"
-#include "constants.h"
-#include "config.h"
-#include "utils.h"
-#include "input.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "cmd.h"
-#include "buffer_manager.h"
-#include "protocol.h"
-#include "pvp.h"
-#include "start_position.h"
-#include "messenger_manager.h"
-#include "guild_manager.h"
-#include "party.h"
-#include "dungeon.h"
-#include "war_map.h"
-#include "questmanager.h"
-#include "building.h"
-#include "wedding.h"
-#include "affect.h"
-#include "arena.h"
-#include "OXEvent.h"
-#include "priv_manager.h"
-#include "block_country.h"
-#include "dev_log.h"
-#include "log.h"
-#include "horsename_manager.h"
-#include "MarkManager.h"
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-#	include "xmas_event.h"
-#endif
-#if defined(__DEFENSE_WAVE__)
-#	include "defense_wave.h"
-#endif
-
-#ifdef __OFFLINE_SHOP__
-#include "OfflineShop.h"
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-	#include "item_manager.h"
-#endif
-
-static void _send_bonus_info(LPCHARACTER ch)
-{
-	int item_drop_bonus = 0;
-	int gold_drop_bonus = 0;
-	int gold10_drop_bonus = 0;
-	int exp_bonus = 0;
-
-	item_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_ITEM_DROP);
-	gold_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_GOLD_DROP);
-	gold10_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_GOLD10_DROP);
-	exp_bonus = CPrivManager::instance().GetPriv(ch, PRIV_EXP_PCT);
-
-	if (item_drop_bonus)
-	{
-		ch->ChatPacket(CHAT_TYPE_NOTICE,
-			LC_STRING("아이템 드롭률  %d%% 추가 이벤트 중입니다.", item_drop_bonus));
-	}
-	if (gold_drop_bonus)
-	{
-		ch->ChatPacket(CHAT_TYPE_NOTICE,
-			LC_STRING("골드 드롭률 %d%% 추가 이벤트 중입니다.", gold_drop_bonus));
-	}
-	if (gold10_drop_bonus)
-	{
-		ch->ChatPacket(CHAT_TYPE_NOTICE,
-			LC_STRING("대박골드 드롭률 %d%% 추가 이벤트 중입니다.", gold10_drop_bonus));
-	}
-	if (exp_bonus)
-	{
-		ch->ChatPacket(CHAT_TYPE_NOTICE,
-			LC_STRING("경험치 %d%% 추가 획득 이벤트 중입니다.", exp_bonus));
-	}
-}
-
-static bool FN_is_battle_zone(LPCHARACTER ch)
-{
-	switch (ch->GetMapIndex())
-	{
-		case 1: // 신수 1차 마을
-		case 2: // 신수 2차 마을
-		case 21: // 천조 1차 마을
-		case 23: // 천조 2차 마을
-		case 41: // 진노 1차 마을
-		case 43: // 진노 2차 마을
-		case 113: // OX 맵
-			return false;
-	}
-
-	return true;
-}
-
-void CInputLogin::Login(LPDESC d, const char* data)
-{
-	TPacketCGLogin* pinfo = (TPacketCGLogin*)data;
-
-	char login[LOGIN_MAX_LEN + 1];
-	trim_and_lower(pinfo->login, login, sizeof(login));
-
-	sys_log(0, "InputLogin::Login : %s", login);
-
-	TPacketGCLoginFailure failurePacket;
-
-	if (g_iUseLocale && !test_server)
-	{
-		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
-		strlcpy(failurePacket.szStatus, "VERSION", sizeof(failurePacket.szStatus));
-		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
-		return;
-	}
-
-	if (g_bNoMoreClient)
-	{
-		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
-		strlcpy(failurePacket.szStatus, "SHUTDOWN", sizeof(failurePacket.szStatus));
-		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
-		return;
-	}
-
-	if (g_iUserLimit > 0)
-	{
-		int iTotal;
-		int* paiEmpireUserCount;
-		int iLocal;
-
-		DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
-
-		if (g_iUserLimit <= iTotal)
-		{
-			failurePacket.header = HEADER_GC_LOGIN_FAILURE;
-			strlcpy(failurePacket.szStatus, "FULL", sizeof(failurePacket.szStatus));
-			d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
-			return;
-		}
-	}
-
-	TLoginPacket login_packet;
-
-	strlcpy(login_packet.login, login, sizeof(login_packet.login));
-	strlcpy(login_packet.passwd, pinfo->passwd, sizeof(login_packet.passwd));
-
-	db_clientdesc->DBPacket(HEADER_GD_LOGIN, d->GetHandle(), &login_packet, sizeof(TLoginPacket));
-}
-
-void CInputLogin::LoginByKey(LPDESC d, const char* data)
-{
-	TPacketCGLogin2* pinfo = (TPacketCGLogin2*)data;
-
-	char login[LOGIN_MAX_LEN + 1];
-	trim_and_lower(pinfo->login, login, sizeof(login));
-
-	// is blocked ip?
-	{
-		dev_log(LOG_DEB0, "check_blocked_country_start");
-
-		if (!is_block_exception(login) && is_blocked_country_ip(d->GetHostName()))
-		{
-			sys_log(0, "BLOCK_COUNTRY_IP (%s)", d->GetHostName());
-			d->SetPhase(PHASE_CLOSE);
-			return;
-		}
-
-		dev_log(LOG_DEB0, "check_blocked_country_end");
-	}
-
-	if (g_bNoMoreClient)
-	{
-		TPacketGCLoginFailure failurePacket;
-
-		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
-		strlcpy(failurePacket.szStatus, "SHUTDOWN", sizeof(failurePacket.szStatus));
-		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
-		return;
-	}
-
-	if (g_iUserLimit > 0)
-	{
-		int iTotal;
-		int* paiEmpireUserCount;
-		int iLocal;
-
-		DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
-
-		if (g_iUserLimit <= iTotal)
-		{
-			TPacketGCLoginFailure failurePacket;
-
-			failurePacket.header = HEADER_GC_LOGIN_FAILURE;
-			strlcpy(failurePacket.szStatus, "FULL", sizeof(failurePacket.szStatus));
-
-			d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
-			return;
-		}
-	}
-
-	sys_log(0, "LOGIN_BY_KEY: %s key %u", login, pinfo->dwLoginKey);
-
-	d->SetLoginKey(pinfo->dwLoginKey);
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-	d->SetSecurityKey(pinfo->adwClientKey);
-#endif
-
-	TPacketGDLoginByKey ptod;
-
-	strlcpy(ptod.szLogin, login, sizeof(ptod.szLogin));
-	ptod.dwLoginKey = pinfo->dwLoginKey;
-	thecore_memcpy(ptod.adwClientKey, pinfo->adwClientKey, sizeof(DWORD) * 4);
-	strlcpy(ptod.szIP, d->GetHostName(), sizeof(ptod.szIP));
-
-	db_clientdesc->DBPacket(HEADER_GD_LOGIN_BY_KEY, d->GetHandle(), &ptod, sizeof(TPacketGDLoginByKey));
-}
-
-void CInputLogin::ChangeName(LPDESC d, const char* data)
-{
-	TPacketCGChangeName* p = (TPacketCGChangeName*)data;
-	const TAccountTable& c_r = d->GetAccountTable();
-
-	if (!c_r.id)
-	{
-		sys_err("no account table");
-		return;
-	}
-
-	if (p->index >= PLAYER_PER_ACCOUNT || p->index < 0)
-	{
-		sys_err("index overflow %d, login: %s", p->index, c_r.login);
-		return;
-	}
-
-	if (!c_r.players[p->index].dwID)
-	{
-		sys_err("no player id, login %s", c_r.login);
-		return;
-	}
-
-	if (!c_r.players[p->index].bChangeName)
-		return;
-
-	if (!check_name(p->name))
-	{
-		TPacketGCCreateFailure pack;
-		pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
-		pack.bType = 0;
-		d->Packet(&pack, sizeof(pack));
-		return;
-	}
-
-	TPacketGDChangeName pdb;
-
-	pdb.pid = c_r.players[p->index].dwID;
-	strlcpy(pdb.name, p->name, sizeof(pdb.name));
-	db_clientdesc->DBPacket(HEADER_GD_CHANGE_NAME, d->GetHandle(), &pdb, sizeof(TPacketGDChangeName));
-}
-
-void CInputLogin::CharacterSelect(LPDESC d, const char* data)
-{
-	struct command_player_select* pinfo = (struct command_player_select*)data;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	TAccountTable& c_r = d->GetAccountTable();
-#else
-	const TAccountTable& c_r = d->GetAccountTable();
-#endif
-
-	sys_log(0, "player_select: login: %s index: %d", c_r.login, pinfo->index);
-
-	if (!c_r.id)
-	{
-		sys_err("no account table");
-		return;
-	}
-
-	if (pinfo->index >= PLAYER_PER_ACCOUNT || pinfo->index < 0)
-	{
-		sys_err("index overflow %d, login: %s", pinfo->index, c_r.login);
-		return;
-	}
-
-	if (!c_r.players[pinfo->index].dwID)
-	{
-		sys_err("no player id, login %s", c_r.login);
-		return;
-	}
-
-	if (c_r.players[pinfo->index].bChangeName)
-	{
-		sys_err("name must be changed idx %d, login %s, name %s",
-			pinfo->index, c_r.login, c_r.players[pinfo->index].szName);
-		return;
-	}
-
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	if (!LocaleService_GetLocale(pinfo->country))
-	{
-		sys_err("cannot find locale country %s, login %s, name %s",
-			pinfo->country, c_r.login, c_r.players[pinfo->index].szName);
-		return;
-	}
-
-	if (strcmp(c_r.country, pinfo->country))
-	{
-		thecore_memcpy(c_r.country, pinfo->country, sizeof(c_r.country));
-
-		char query[128];
-		snprintf(query, sizeof(query), "UPDATE `account`.`account` SET `country` = '%s' WHERE `id` = %u",
-			LocaleService_GetCountry(pinfo->country), c_r.id);
-		std::unique_ptr<SQLMsg> msg(DBManager::instance().DirectQuery(query));
-	}
-#endif
-
-	TPlayerLoadPacket player_load_packet;
-
-	player_load_packet.account_id = c_r.id;
-	player_load_packet.player_id = c_r.players[pinfo->index].dwID;
-	player_load_packet.account_index = pinfo->index;
-
-	db_clientdesc->DBPacket(HEADER_GD_PLAYER_LOAD, d->GetHandle(), &player_load_packet, sizeof(TPlayerLoadPacket));
-}
-
-bool NewPlayerTable(TPlayerTable* table,
-	const char* name,
-	BYTE job,
-	BYTE shape,
-	BYTE bEmpire,
-	BYTE bCon,
-	BYTE bInt,
-	BYTE bStr,
-	BYTE bDex)
-{
-	if (job >= JOB_MAX_NUM)
-		return false;
-
-	memset(table, 0, sizeof(TPlayerTable));
-
-	strlcpy(table->name, name, sizeof(table->name));
-
-	table->level = 1;
-	table->job = job;
-	table->voice = 0;
-	table->part_base = shape;
-
-	table->st = JobInitialPoints[job].st;
-	table->dx = JobInitialPoints[job].dx;
-	table->ht = JobInitialPoints[job].ht;
-	table->iq = JobInitialPoints[job].iq;
-
-	table->hp = JobInitialPoints[job].max_hp + table->ht * JobInitialPoints[job].hp_per_ht;
-	table->sp = JobInitialPoints[job].max_sp + table->iq * JobInitialPoints[job].sp_per_iq;
-	table->stamina = JobInitialPoints[job].max_stamina;
-
-	table->x = CREATE_START_X(bEmpire, job) + number(-300, 300);
-	table->y = CREATE_START_Y(bEmpire, job) + number(-300, 300);
-
-	table->z = 0;
-	table->dir = 0;
-	table->playtime = 0;
-	table->gold = 0;
-
-	table->skill_group = 0;
-
-	if (china_event_server)
-	{
-		table->level = 35;
-
-		for (int i = 1; i < 35; ++i)
-		{
-			int iHP = number(JobInitialPoints[job].hp_per_lv_begin, JobInitialPoints[job].hp_per_lv_end);
-			int iSP = number(JobInitialPoints[job].sp_per_lv_begin, JobInitialPoints[job].sp_per_lv_end);
-			table->sRandomHP += iHP;
-			table->sRandomSP += iSP;
-			table->stat_point += 3;
-		}
-
-		table->hp += table->sRandomHP;
-		table->sp += table->sRandomSP;
-
-		table->gold = 1000000;
-	}
-
-	return true;
-}
-
-bool RaceToJob(BYTE race, BYTE* ret_job)
-{
-	*ret_job = 0;
-
-	if (race >= MAIN_RACE_MAX_NUM)
-		return false;
-
-	switch (race)
-	{
-		case MAIN_RACE_WARRIOR_M:
-			*ret_job = JOB_WARRIOR;
-			break;
-
-		case MAIN_RACE_WARRIOR_W:
-			*ret_job = JOB_WARRIOR;
-			break;
-
-		case MAIN_RACE_ASSASSIN_M:
-			*ret_job = JOB_ASSASSIN;
-			break;
-
-		case MAIN_RACE_ASSASSIN_W:
-			*ret_job = JOB_ASSASSIN;
-			break;
-
-		case MAIN_RACE_SURA_M:
-			*ret_job = JOB_SURA;
-			break;
-
-		case MAIN_RACE_SURA_W:
-			*ret_job = JOB_SURA;
-			break;
-
-		case MAIN_RACE_SHAMAN_M:
-			*ret_job = JOB_SHAMAN;
-			break;
-
-		case MAIN_RACE_SHAMAN_W:
-			*ret_job = JOB_SHAMAN;
-			break;
-
-		case MAIN_RACE_WOLFMAN_M:
-			*ret_job = JOB_WOLFMAN;
-			break;
-
-		default:
-			return false;
-			break;
-	}
-	return true;
-}
-
-// 신규 캐릭터 지원
-bool NewPlayerTable2(TPlayerTable* table, const char* name, BYTE race, BYTE shape, BYTE bEmpire)
-{
-	if (race >= MAIN_RACE_MAX_NUM)
-	{
-		sys_err("NewPlayerTable2.OUT_OF_RACE_RANGE(%d >= max(%d))\n", race, MAIN_RACE_MAX_NUM);
-		return false;
-	}
-
-	BYTE job;
-	if (!RaceToJob(race, &job))
-	{
-		sys_err("NewPlayerTable2.RACE_TO_JOB_ERROR(%d)\n", race);
-		return false;
-	}
-
-	sys_log(0, "NewPlayerTable2(name=%s, race=%d, job=%d)", name, race, job);
-
-	memset(table, 0, sizeof(TPlayerTable));
-
-	strlcpy(table->name, name, sizeof(table->name));
-
-	table->level = 1;
-	table->job = race; // 직업대신 종족을 넣는다
-	table->voice = 0;
-	table->part_base = shape;
-
-	table->st = JobInitialPoints[job].st;
-	table->dx = JobInitialPoints[job].dx;
-	table->ht = JobInitialPoints[job].ht;
-	table->iq = JobInitialPoints[job].iq;
-
-	table->hp = JobInitialPoints[job].max_hp + table->ht * JobInitialPoints[job].hp_per_ht;
-	table->sp = JobInitialPoints[job].max_sp + table->iq * JobInitialPoints[job].sp_per_iq;
-	table->stamina = JobInitialPoints[job].max_stamina;
-
-	table->x = CREATE_START_X(bEmpire, job) + number(-300, 300);
-	table->y = CREATE_START_Y(bEmpire, job) + number(-300, 300);
-
-	table->z = 0;
-	table->dir = 0;
-	table->playtime = 0;
-	table->gold = 0;
-
-	table->skill_group = 0;
-
-	return true;
-}
-
-void CInputLogin::CharacterCreate(LPDESC d, const char* data)
-{
-	struct command_player_create* pinfo = (struct command_player_create*)data;
-	TPlayerCreatePacket player_create_packet;
-
-	sys_log(0, "PlayerCreate: name %s pos %d job %d shape %d",
-		pinfo->name,
-		pinfo->index,
-		pinfo->job,
-		pinfo->shape
-	);
-
-	TPacketGCLoginFailure packFailure;
-	memset(&packFailure, 0, sizeof(packFailure));
-	packFailure.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
-
-	if (true == g_BlockCharCreation)
-	{
-		d->Packet(&packFailure, sizeof(packFailure));
-		return;
-	}
-
-	if (!g_bWolfmanCreation)
-	{
-		if (pinfo->job == MAIN_RACE_WOLFMAN_M)
-		{
-			d->Packet(&packFailure, sizeof(packFailure));
-			return;
-		}
-	}
-
-	// 사용할 수 없는 이름이거나, 잘못된 평상복이면 생설 실패
-	if (!check_name(pinfo->name) || pinfo->shape > 1)
-	{
-		if (LC_IsCanada() == true)
-		{
-			TPacketGCCreateFailure pack;
-			pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
-			pack.bType = 1;
-
-			d->Packet(&pack, sizeof(pack));
-			return;
-		}
-
-		d->Packet(&packFailure, sizeof(packFailure));
-		return;
-	}
-
-	if (LC_IsEurope() == true)
-	{
-		const TAccountTable& c_rAccountTable = d->GetAccountTable();
-
-		if (0 == strcmp(c_rAccountTable.login, pinfo->name))
-		{
-			TPacketGCCreateFailure pack;
-			pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
-			pack.bType = 1;
-
-			d->Packet(&pack, sizeof(pack));
-			return;
-		}
-	}
-
-	memset(&player_create_packet, 0, sizeof(TPlayerCreatePacket));
-
-	if (!NewPlayerTable2(&player_create_packet.player_table, pinfo->name, pinfo->job, pinfo->shape, d->GetEmpire()))
-	{
-		sys_err("player_prototype error: job %d face %d ", pinfo->job);
-		d->Packet(&packFailure, sizeof(packFailure));
-		return;
-	}
-
-	const TAccountTable& c_rAccountTable = d->GetAccountTable();
-
-	trim_and_lower(c_rAccountTable.login, player_create_packet.login, sizeof(player_create_packet.login));
-	strlcpy(player_create_packet.passwd, c_rAccountTable.passwd, sizeof(player_create_packet.passwd));
-
-	player_create_packet.account_id = c_rAccountTable.id;
-	player_create_packet.account_index = pinfo->index;
-
-	sys_log(0, "PlayerCreate: name %s account_id %d, TPlayerCreatePacketSize(%d), Packet->Gold %d",
-		pinfo->name,
-		pinfo->index,
-		sizeof(TPlayerCreatePacket),
-		player_create_packet.player_table.gold);
-
-	db_clientdesc->DBPacket(HEADER_GD_PLAYER_CREATE, d->GetHandle(), &player_create_packet, sizeof(TPlayerCreatePacket));
-}
-
-void CInputLogin::CharacterDelete(LPDESC d, const char* data)
-{
-	struct command_player_delete* pinfo = (struct command_player_delete*)data;
-	const TAccountTable& c_rAccountTable = d->GetAccountTable();
-
-	if (!c_rAccountTable.id)
-	{
-		sys_err("PlayerDelete: no login data");
-		return;
-	}
-
-	sys_log(0, "PlayerDelete: login: %s index: %d, social_id %s", c_rAccountTable.login, pinfo->index, pinfo->private_code);
-
-	if (pinfo->index >= PLAYER_PER_ACCOUNT || pinfo->index < 0)
-	{
-		sys_err("PlayerDelete: index overflow %d, login: %s", pinfo->index, c_rAccountTable.login);
-		return;
-	}
-
-	if (!c_rAccountTable.players[pinfo->index].dwID)
-	{
-		sys_err("PlayerDelete: Wrong Social ID index %d, login: %s", pinfo->index, c_rAccountTable.login);
-		d->Packet(encode_byte(HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID), 1);
-		return;
-	}
-
-	TPlayerDeletePacket player_delete_packet;
-
-	trim_and_lower(c_rAccountTable.login, player_delete_packet.login, sizeof(player_delete_packet.login));
-	player_delete_packet.player_id = c_rAccountTable.players[pinfo->index].dwID;
-	player_delete_packet.account_index = pinfo->index;
-	strlcpy(player_delete_packet.private_code, pinfo->private_code, sizeof(player_delete_packet.private_code));
-
-	db_clientdesc->DBPacket(HEADER_GD_PLAYER_DELETE, d->GetHandle(), &player_delete_packet, sizeof(TPlayerDeletePacket));
-}
-
-#pragma pack(1)
-typedef struct SPacketGTLogin
-{
-	BYTE header;
-	WORD empty;
-	DWORD id;
-} TPacketGTLogin;
-#pragma pack()
-
-void CInputLogin::Entergame(LPDESC d, const char* data)
-{
-	LPCHARACTER ch;
-
-	if (!(ch = d->GetCharacter()))
-	{
-		d->SetPhase(PHASE_CLOSE);
-		return;
-	}
-
-	// Hardening: never allow observer mode to persist across logins (e.g. Alt+F4 while observing).
-	if (ch->IsObserverMode())
-		ch->SetObserverMode(false);
-	ch->SetArenaObserverMode(false);
-
-	PIXEL_POSITION pos = ch->GetXYZ();
-	if (!SECTREE_MANAGER::instance().GetMovablePosition(ch->GetMapIndex(), pos.x, pos.y, pos))
-	{
-		PIXEL_POSITION pos2;
-		SECTREE_MANAGER::instance().GetRecallPositionByEmpire(ch->GetMapIndex(), ch->GetEmpire(), pos2);
-
-		sys_err("!GetMovablePosition (name %s %dx%d map %d changed to %dx%d)",
-			ch->GetName(),
-			pos.x, pos.y,
-			ch->GetMapIndex(),
-			pos2.x, pos2.y);
-		pos = pos2;
-	}
-
-	CGuildManager::instance().LoginMember(ch);
-
-	// 캐릭터를 맵에 추가
-	ch->Show(ch->GetMapIndex(), pos.x, pos.y, pos.z);
-	ch->ReviveInvisible(5);
-
-#if !defined(__BINARY_ATLAS_MARK_INFO__)
-	SECTREE_MANAGER::instance().SendNPCPosition(ch);
-#endif
-
-	d->SetPhase(PHASE_GAME);
-
-#if defined(__HIDE_COSTUME_SYSTEM__)
-	ch->SetHiddenCostumeParts();
-#endif
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	const LPITEM& rkCostumeMount = ch->GetWear(WEAR_COSTUME_MOUNT);
-	if (rkCostumeMount)
-		ch->MountVnum(rkCostumeMount->GetMountVnum());
-	else if (ch->GetHorseLevel() > 0)
-		ch->EnterHorse();
-#else
-	if (ch->GetHorseLevel() > 0)
-		ch->EnterHorse();
-#endif
-
-	if (ch->GetItemAward_cmd()[0] != '\0') // 게임페이즈 들어가면
-		quest::CQuestManager::instance().ItemInformer(ch->GetPlayerID(), ch->GetItemAward_vnum()); // questmanager 호출
-
-	sys_log(0, "ENTERGAME: %s %dx%dx%d %s map_index %d",
-		ch->GetName(), ch->GetX(), ch->GetY(), ch->GetZ(), d->GetHostName(), ch->GetMapIndex());
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	ch->SendExtendInvenPacket();
-#endif
-
-	// Check unwanted quickslot items.
-	ch->CheckQuickSlotItems();
-
-	// 플레이시간 레코딩 시작
-	ch->ResetPlayTime();
-
-	// 자동 저장 이벤트 추가
-	ch->StartSaveEvent();
-	ch->StartRecoveryEvent();
-	ch->StartCheckSpeedHackEvent();
-	ch->SetQuestFlag("item.last_time", get_global_time());
-
-	CPVPManager::instance().Connect(ch);
-	CPVPManager::instance().SendList(d);
-
-	CMessengerManager::instance().Login(ch->GetName());
-
-	CPartyManager::instance().SetParty(ch);
-	CGuildManager::instance().SendGuildWar(ch);
-
-	building::CManager::instance().SendLandList(d, ch->GetMapIndex());
-
-	marriage::CManager::instance().Login(ch);
-
-#ifdef __OFFLINE_SHOP__
-	COfflineShop::Login(ch);
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	TPacketGDEmote GDPacket = {};
-	GDPacket.dwPID = ch->GetPlayerID();
-	db_clientdesc->DBPacket(HEADER_GD_EMOTE_LOAD, ch->GetDesc()->GetHandle(), &GDPacket, sizeof(GDPacket));
-#endif
-
-	TPacketGCTime p;
-	p.bHeader = HEADER_GC_TIME;
-	p.time = get_global_time();
-	d->Packet(&p, sizeof(p));
-
-	TPacketGCChannel p2;
-	p2.header = HEADER_GC_CHANNEL;
-	p2.channel = g_bChannel;
-	d->Packet(&p2, sizeof(p2));
-
-#if defined(__LOOT_FILTER_SYSTEM__) && !defined(__PREMIUM_LOOT_FILTER__)
-	ch->SetLootFilter();
-#endif
-
-#if defined(__MAILBOX__)
-	CMailBox::UnreadData(ch);
-#endif
-
-	ch->SendGreetMessage();
-	_send_bonus_info(ch);
-
-	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("UPDATE player%s SET `last_play` = NOW() WHERE `name` = '%s'",
-		get_table_postfix(), ch->GetName())
-	);
-
-	ch->LoadSafeboxBuff();
-
-	for (int i = 0; i <= PREMIUM_MAX_NUM; ++i)
-	{
-		int remain = ch->GetPremiumRemainSeconds(i);
-
-		if (remain <= 0)
-			continue;
-
-#if defined(__CONQUEROR_LEVEL__)
-		int idx = AFFECT_PREMIUM_START + i;
-		if (idx == AFFECT_SUNGMA_BONUS)
-		{
-			for (int affect = POINT_SUNGMA_STR; affect <= POINT_SUNGMA_IMMUNE; ++affect)
-				ch->AddAffect(idx, affect, 10, 0, remain, 0, true, true);
-		}
-		else
-			ch->AddAffect(idx, POINT_NONE, 0, 0, remain, 0, true);
-#else
-		ch->AddAffect(AFFECT_PREMIUM_START + i, POINT_NONE, 0, 0, remain, 0, true);
-#endif
-		sys_log(0, "PREMIUM: %s type %d %dmin", ch->GetName(), i, remain);
-	}
-#ifdef __OFFLINE_SHOP__
-	int remainBuy = ch->GetQuestFlag("decoration.limit_time") - get_global_time();
-	if (remainBuy > 0)
-		ch->AddAffect(AFFECT_OFFLINE_SHOP_DECORATION, POINT_NONE, 0, 0, remainBuy, 0, true);
-#endif
-
-	if (g_bCheckClientVersion)
-	{
-		sys_log(0, "VERSION CHECK %s %s", g_stClientVersion.c_str(), d->GetClientVersion());
-
-		if (!d->GetClientVersion())
-		{
-			d->DelayedDisconnect(10);
-		}
-		else
-		{
-			if (0 != g_stClientVersion.compare(d->GetClientVersion()))
-			{
-				ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("클라이언트 버전이 틀려 로그아웃 됩니다. 정상적으로 패치 후 접속하세요."));
-				d->DelayedDisconnect(0);
-				LogManager::instance().HackLog("VERSION_CONFLICT", ch);
-
-				sys_log(0, "VERSION : WRONG VERSION USER : account:%s name:%s hostName:%s server_version:%s client_version:%s",
-					d->GetAccountTable().login,
-					ch->GetName(),
-					d->GetHostName(),
-					g_stClientVersion.c_str(),
-					d->GetClientVersion());
-			}
-		}
-	}
-	else
-	{
-		sys_log(0, "VERSION : NO CHECK");
-	}
-
-	if (ch->IsGM() == true)
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "ConsoleEnable");
-
-#if defined(__POPUP_NOTICE__)
-	if (quest::CQuestManager::instance().GetEventFlag("PopupNoticeEventFlag") > 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "PopupNoticeProcess %d %s",
-			ch->GetQuestFlag("popup_notice.checkbox"), g_strWebPopupNoticeURL.c_str());
-	}
-#endif
-
-#if defined(__MOVE_CHANNEL__)
-	ch->ChatPacket(CHAT_TYPE_COMMAND, "server_info %d %d", g_bChannel, ch->GetMapIndex());
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-	CSnowflakeStickEvent::EnterGame(ch);
-#endif
-
-	if (ch->GetMapIndex() >= 10000)
-	{
-		if (CWarMapManager::instance().IsWarMap(ch->GetMapIndex()))
-		{
-			ch->SetWarMap(CWarMapManager::instance().Find(ch->GetMapIndex()));
-		}
-		else if (marriage::WeddingManager::instance().IsWeddingMap(ch->GetMapIndex()))
-		{
-			ch->SetWeddingMap(marriage::WeddingManager::instance().Find(ch->GetMapIndex()));
-		}
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-		else if (CGuildDragonLairManager::Instance().IsRedDragonLair(ch->GetMapIndex()))
-		{
-			ch->SetGuildDragonLair(CGuildDragonLairManager::Instance().FindByMapIndex(ch->GetMapIndex()));
-		}
-#endif
-#if defined(__DEFENSE_WAVE__)
-		else if (CDefenseWaveManager::instance().IsDefenseWaveMap(ch->GetMapIndex()))
-		{
-			ch->SetDefenseWave(CDefenseWaveManager::instance().FindByMapIndex(ch->GetMapIndex()));
-		}
-#endif
-		else
-		{
-			ch->SetDungeon(CDungeonManager::instance().FindByMapIndex(ch->GetMapIndex()));
-		}
-	}
-	else if (CArenaManager::instance().IsArenaMap(ch->GetMapIndex()))
-	{
-		int memberFlag = CArenaManager::instance().IsMember(ch->GetMapIndex(), ch->GetPlayerID());
-		if (memberFlag == MEMBER_OBSERVER)
-		{
-			ch->SetObserverMode(true);
-			ch->SetArenaObserverMode(true);
-			if (CArenaManager::instance().RegisterObserverPtr(ch, ch->GetMapIndex(), ch->GetX() / 100, ch->GetY() / 100))
-			{
-				sys_log(0, "ARENA : Observer add failed");
-			}
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-			ch->UnMount(ch);
-#else
-			if (ch->IsHorseRiding() == true)
-			{
-				ch->StopRiding();
-				ch->HorseSummon(false);
-			}
-#endif
-		}
-		else if (memberFlag == MEMBER_DUELIST)
-		{
-			TPacketGCDuelStart duelStart;
-			duelStart.header = HEADER_GC_DUEL_START;
-			duelStart.wSize = sizeof(TPacketGCDuelStart);
-
-			ch->GetDesc()->Packet(&duelStart, sizeof(TPacketGCDuelStart));
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-			ch->UnMount(ch);
-#else
-			if (ch->IsHorseRiding() == true)
-			{
-				ch->StopRiding();
-				ch->HorseSummon(false);
-			}
-#endif
-
-			LPPARTY pParty = ch->GetParty();
-			if (pParty != NULL)
-			{
-				if (pParty->GetMemberCount() == 2)
-				{
-					CPartyManager::instance().DeleteParty(pParty);
-				}
-				else
-				{
-					pParty->Quit(ch->GetPlayerID());
-				}
-			}
-		}
-		/*
-		else if (memberFlag == MEMBER_NO)
-		{
-			if (ch->GetGMLevel() == GM_PLAYER)
-				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
-		}
-		else
-		{
-			// wtf
-		}
-		*/
-	}
-	else if (ch->GetMapIndex() == MAP_OXEVENT)
-	{
-		// ox 이벤트 맵
-		if (COXEventManager::instance().Enter(ch) == false)
-		{
-			// ox 맵 진입 허가가 나지 않음. 플레이어면 마을로 보내자
-			if (ch->GetGMLevel() == GM_PLAYER)
-				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
-		}
-	}
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	else if (ch->GetMapIndex() == MAP_N_FLAME_DRAGON)
-	{
-		CGuildDragonLairManager::Instance().Exit(ch);
-	}
-#endif
-	else
-	{
-		if (CWarMapManager::instance().IsWarMap(ch->GetMapIndex()) ||
-			marriage::WeddingManager::instance().IsWeddingMap(ch->GetMapIndex()))
-		{
-			if (!test_server)
-				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
-		}
-
-#if defined(__ELEMENTAL_DUNGEON__)
-		if (ch->GetMapIndex() == MAP_ELEMENTAL_04)
-			ch->StartElementalCurseEvent();
-		else
-			ch->StopElementalCurseEvent();
-#endif
-	}
-
-	if (ch->GetHorseLevel() > 0)
-	{
-		DWORD pid = ch->GetPlayerID();
-
-		if (pid > 0)
-		{
-			const char* horseName = CHorseNameManager::instance().GetHorseName(pid);
-			if (!horseName || !*horseName)
-				db_clientdesc->DBPacket(HEADER_GD_REQ_HORSE_NAME, 0, &pid, sizeof(DWORD));
-		}
-	}
-
-	// 중립맵에 들어갔을때 안내하기
-	if (g_noticeBattleZone)
-	{
-		if (FN_is_battle_zone(ch))
-		{
-			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("이 맵에선 강제적인 대전이 있을수 도 있습니다."));
-			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("이 조항에 동의하지 않을시"));
-			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("본인의 주성 및 부성으로 돌아가시기 바랍니다."));
-		}
-	}
-#ifdef __GROWTH_PET_SYSTEM__
-	if (!IS_BLOCKED_PET(ch->GetMapIndex()))
-	{
-		DWORD growthPetID = ch->GetQuestFlag("system.grow_pet_summoned");
-		if (growthPetID)
-		{
-			LPITEM petSeal = ITEM_MANAGER::instance().Find(growthPetID);
-			if (petSeal && petSeal->GetType() == ITEM_PET && petSeal->GetSubType() == PET_UPBRINGING)
-			{
-				LPGROWTH_PET pPet = ch->GetGrowthPet(petSeal->GetSocket(2));
-				if (pPet)
-				{
-					if (!ch->GetActiveGrowthPet())
-					{
-						LPGROWTH_PET pkPet = pPet->Summon(petSeal);
-						ch->SetActiveGrowthPet(pkPet);
-					}
-				}
-			}
-		}
-	}
-#endif
-}
-
-void CInputLogin::Empire(LPDESC d, const char* c_pData)
-{
-	const TPacketCGEmpire* p = reinterpret_cast<const TPacketCGEmpire*>(c_pData);
-
-	if (EMPIRE_MAX_NUM <= p->bEmpire)
-	{
-		d->SetPhase(PHASE_CLOSE);
-		return;
-	}
-
-	const TAccountTable& r = d->GetAccountTable();
-
-	if (r.bEmpire != 0)
-	{
-		for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
-		{
-			if (0 != r.players[i].dwID)
-			{
-				sys_err("EmpireSelectFailed %d", r.players[i].dwID);
-				return;
-			}
-		}
-	}
-
-	TEmpireSelectPacket pd;
-
-	pd.dwAccountID = r.id;
-	pd.bEmpire = p->bEmpire;
-
-	db_clientdesc->DBPacket(HEADER_GD_EMPIRE_SELECT, d->GetHandle(), &pd, sizeof(pd));
-}
-
-int CInputLogin::GuildSymbolUpload(LPDESC d, const char* c_pData, size_t uiBytes)
-{
-	if (uiBytes < sizeof(TPacketCGGuildSymbolUpload))
-		return -1;
-
-	sys_log(0, "GuildSymbolUpload uiBytes %u", uiBytes);
-
-	TPacketCGGuildSymbolUpload* p = (TPacketCGGuildSymbolUpload*)c_pData;
-
-	if (uiBytes < p->size)
-		return -1;
-
-	int iSymbolSize = p->size - sizeof(TPacketCGGuildSymbolUpload);
-
-	if (iSymbolSize <= 0 || iSymbolSize > 64 * 1024)
-	{
-		// 64k 보다 큰 길드 심볼은 올릴수없다
-		// 접속을 끊고 무시
-		d->SetPhase(PHASE_CLOSE);
-		return 0;
-	}
-
-	// 땅을 소유하지 않은 길드인 경우.
-	if (!test_server)
-		if (!building::CManager::instance().FindLandByGuild(p->guild_id))
-		{
-			d->SetPhase(PHASE_CLOSE);
-			return 0;
-		}
-
-	sys_log(0, "GuildSymbolUpload Do Upload %02X%02X%02X%02X %d", c_pData[7], c_pData[8], c_pData[9], c_pData[10], sizeof(*p));
-
-	CGuildMarkManager::instance().UploadSymbol(p->guild_id, iSymbolSize, (const BYTE*)(c_pData + sizeof(*p)));
-	CGuildMarkManager::instance().SaveSymbol(GUILD_SYMBOL_FILENAME);
-	return iSymbolSize;
-}
-
-void CInputLogin::GuildSymbolCRC(LPDESC d, const char* c_pData)
-{
-	const TPacketCGSymbolCRC& CGPacket = *((TPacketCGSymbolCRC*)c_pData);
-
-	sys_log(0, "GuildSymbolCRC %u %u %u", CGPacket.guild_id, CGPacket.crc, CGPacket.size);
-
-	const CGuildMarkManager::TGuildSymbol* pkGS = CGuildMarkManager::instance().GetGuildSymbol(CGPacket.guild_id);
-
-	if (!pkGS)
-		return;
-
-	sys_log(0, "  Server %u %u", pkGS->crc, pkGS->raw.size());
-
-	if (pkGS->raw.size() != CGPacket.size || pkGS->crc != CGPacket.crc)
-	{
-		TPacketGCGuildSymbolData GCPacket;
-
-		GCPacket.header = HEADER_GC_SYMBOL_DATA;
-		GCPacket.size = sizeof(GCPacket) + pkGS->raw.size();
-		GCPacket.guild_id = CGPacket.guild_id;
-
-		d->BufferedPacket(&GCPacket, sizeof(GCPacket));
-		d->Packet(&pkGS->raw[0], pkGS->raw.size());
-
-		sys_log(0, "SendGuildSymbolHead %02X%02X%02X%02X Size %d",
-			pkGS->raw[0], pkGS->raw[1], pkGS->raw[2], pkGS->raw[3], pkGS->raw.size());
-	}
-}
-
-void CInputLogin::GuildMarkUpload(LPDESC d, const char* c_pData)
-{
-	TPacketCGMarkUpload* p = (TPacketCGMarkUpload*)c_pData;
-	CGuildManager& rkGuildMgr = CGuildManager::instance();
-	CGuild* pkGuild;
-
-	if (!(pkGuild = rkGuildMgr.FindGuild(p->gid)))
-	{
-		sys_err("MARK_SERVER: GuildMarkUpload: no guild. gid %u", p->gid);
-		return;
-	}
-
-	if (pkGuild->GetLevel() < guild_mark_min_level)
-	{
-		sys_log(0, "MARK_SERVER: GuildMarkUpload: level < %u (%u)", guild_mark_min_level, pkGuild->GetLevel());
-		return;
-	}
-
-	CGuildMarkManager& rkMarkMgr = CGuildMarkManager::instance();
-
-	sys_log(0, "MARK_SERVER: GuildMarkUpload: gid %u", p->gid);
-
-	bool isEmpty = true;
-
-	for (DWORD iPixel = 0; iPixel < SGuildMark::SIZE; ++iPixel)
-		if (*((DWORD*)p->image + iPixel) != 0x00000000)
-			isEmpty = false;
-
-	if (isEmpty)
-		rkMarkMgr.DeleteMark(p->gid);
-	else
-		rkMarkMgr.SaveMark(p->gid, p->image);
-}
-
-void CInputLogin::GuildMarkIDXList(LPDESC d, const char* c_pData)
-{
-	CGuildMarkManager& rkMarkMgr = CGuildMarkManager::instance();
-
-	DWORD bufSize = sizeof(WORD) * 2 * rkMarkMgr.GetMarkCount();
-	char* buf = NULL;
-
-	if (bufSize > 0)
-	{
-		buf = (char*)malloc(bufSize);
-		rkMarkMgr.CopyMarkIdx(buf);
-	}
-
-	TPacketGCMarkIDXList p;
-	p.header = HEADER_GC_MARK_IDXLIST;
-	p.bufSize = sizeof(p) + bufSize;
-	p.count = rkMarkMgr.GetMarkCount();
-
-	if (buf)
-	{
-		d->BufferedPacket(&p, sizeof(p));
-		d->LargePacket(buf, bufSize);
-		free(buf);
-	}
-	else
-		d->Packet(&p, sizeof(p));
-
-	sys_log(0, "MARK_SERVER: GuildMarkIDXList %d bytes sent.", p.bufSize);
-}
-
-void CInputLogin::GuildMarkCRCList(LPDESC d, const char* c_pData)
-{
-	TPacketCGMarkCRCList* pCG = (TPacketCGMarkCRCList*)c_pData;
-
-	std::map<BYTE, const SGuildMarkBlock*> mapDiffBlocks;
-	CGuildMarkManager::instance().GetDiffBlocks(pCG->imgIdx, pCG->crclist, mapDiffBlocks);
-
-	DWORD blockCount = 0;
-	TEMP_BUFFER buf(1024 * 1024); // 1M 버퍼
-
-	for (auto it = mapDiffBlocks.begin(); it != mapDiffBlocks.end(); ++it)
-	{
-		BYTE posBlock = it->first;
-		const SGuildMarkBlock& rkBlock = *it->second;
-
-		buf.write(&posBlock, sizeof(BYTE));
-		buf.write(&rkBlock.m_sizeCompBuf, sizeof(DWORD));
-		buf.write(rkBlock.m_abCompBuf, rkBlock.m_sizeCompBuf);
-
-		++blockCount;
-	}
-
-	TPacketGCMarkBlock pGC;
-
-	pGC.header = HEADER_GC_MARK_BLOCK;
-	pGC.imgIdx = pCG->imgIdx;
-	pGC.bufSize = buf.size() + sizeof(TPacketGCMarkBlock);
-	pGC.count = blockCount;
-
-	sys_log(0, "MARK_SERVER: Sending blocks. (imgIdx %u diff %u size %u)", pCG->imgIdx, mapDiffBlocks.size(), pGC.bufSize);
-
-	if (buf.size() > 0)
-	{
-		d->BufferedPacket(&pGC, sizeof(TPacketGCMarkBlock));
-		d->LargePacket(buf.read_peek(), buf.size());
-	}
-	else
-		d->Packet(&pGC, sizeof(TPacketGCMarkBlock));
-}
-
-int CInputLogin::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
-{
-	int iExtraLen = 0;
-
-	switch (bHeader)
-	{
-		case HEADER_CG_PONG:
-			Pong(d);
-			break;
-
-		case HEADER_CG_TIME_SYNC:
-			Handshake(d, c_pData);
-			break;
-
-		case HEADER_CG_LOGIN:
-			Login(d, c_pData);
-			break;
-
-		case HEADER_CG_LOGIN2:
-			LoginByKey(d, c_pData);
-			break;
-
-		case HEADER_CG_CHARACTER_SELECT:
-			CharacterSelect(d, c_pData);
-			break;
-
-		case HEADER_CG_CHARACTER_CREATE:
-			CharacterCreate(d, c_pData);
-			break;
-
-		case HEADER_CG_CHARACTER_DELETE:
-			CharacterDelete(d, c_pData);
-			break;
-
-		case HEADER_CG_ENTERGAME:
-			Entergame(d, c_pData);
-			break;
-
-		case HEADER_CG_EMPIRE:
-			Empire(d, c_pData);
-			break;
-
-		case HEADER_CG_MOVE:
-		case HEADER_CG_ITEM_USE:
-		case HEADER_CG_TARGET:
-			break;
-
-			///////////////////////////////////////
-			// Guild Mark
-			/////////////////////////////////////
-		case HEADER_CG_MARK_LOGIN:
-			break;
-
-		case HEADER_CG_MARK_CRCLIST:
-			GuildMarkCRCList(d, c_pData);
-			break;
-
-		case HEADER_CG_MARK_IDXLIST:
-			GuildMarkIDXList(d, c_pData);
-			break;
-
-		case HEADER_CG_MARK_UPLOAD:
-			GuildMarkUpload(d, c_pData);
-			break;
-
-			//////////////////////////////////////
-			// Guild Symbol
-			/////////////////////////////////////
-		case HEADER_CG_GUILD_SYMBOL_UPLOAD:
-			if ((iExtraLen = GuildSymbolUpload(d, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_SYMBOL_CRC:
-			GuildSymbolCRC(d, c_pData);
-			break;
-			/////////////////////////////////////
-
-		case HEADER_CG_HACK:
-			break;
-
-		case HEADER_CG_CHANGE_NAME:
-			ChangeName(d, c_pData);
-			break;
-
-		case HEADER_CG_CLIENT_VERSION:
-			Version(d->GetCharacter(), c_pData);
-			break;
-
-		case HEADER_CG_CLIENT_VERSION2:
-			Version(d->GetCharacter(), c_pData);
-			break;
-
-		default:
-			sys_err("login phase does not handle this packet! header %d", bHeader);
-			//d->SetPhase(PHASE_CLOSE);
-			return (0);
-	}
-
-	return (iExtraLen);
-}
+#include "stdafx.h"
+#include "constants.h"
+#include "config.h"
+#include "utils.h"
+#include "input.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "cmd.h"
+#include "buffer_manager.h"
+#include "protocol.h"
+#include "pvp.h"
+#include "start_position.h"
+#include "messenger_manager.h"
+#include "guild_manager.h"
+#include "party.h"
+#include "dungeon.h"
+#include "war_map.h"
+#include "questmanager.h"
+#include "building.h"
+#include "wedding.h"
+#include "affect.h"
+#include "arena.h"
+#include "OXEvent.h"
+#include "priv_manager.h"
+#include "block_country.h"
+#include "dev_log.h"
+#include "log.h"
+#include "horsename_manager.h"
+#include "MarkManager.h"
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+#	include "xmas_event.h"
+#endif
+#if defined(__DEFENSE_WAVE__)
+#	include "defense_wave.h"
+#endif
+
+#ifdef __OFFLINE_SHOP__
+#include "OfflineShop.h"
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+	ch->SendDeadPetMessage();
+#endif
+
+static void _send_bonus_info(LPCHARACTER ch)
+{
+	int item_drop_bonus = 0;
+	int gold_drop_bonus = 0;
+	int gold10_drop_bonus = 0;
+	int exp_bonus = 0;
+
+	item_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_ITEM_DROP);
+	gold_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_GOLD_DROP);
+	gold10_drop_bonus = CPrivManager::instance().GetPriv(ch, PRIV_GOLD10_DROP);
+	exp_bonus = CPrivManager::instance().GetPriv(ch, PRIV_EXP_PCT);
+
+	if (item_drop_bonus)
+	{
+		ch->ChatPacket(CHAT_TYPE_NOTICE,
+			LC_STRING(" 獺  %d%% 煞 遣트 都求.", item_drop_bonus));
+	}
+	if (gold_drop_bonus)
+	{
+		ch->ChatPacket(CHAT_TYPE_NOTICE,
+			LC_STRING(" 獺 %d%% 煞 遣트 都求.", gold_drop_bonus));
+	}
+	if (gold10_drop_bonus)
+	{
+		ch->ChatPacket(CHAT_TYPE_NOTICE,
+			LC_STRING("微 獺 %d%% 煞 遣트 都求.", gold10_drop_bonus));
+	}
+	if (exp_bonus)
+	{
+		ch->ChatPacket(CHAT_TYPE_NOTICE,
+			LC_STRING("치 %d%% 煞 획 遣트 都求.", exp_bonus));
+	}
+}
+
+static bool FN_is_battle_zone(LPCHARACTER ch)
+{
+	switch (ch->GetMapIndex())
+	{
+		case 1: // 탉 1 
+		case 2: // 탉 2 
+		case 21: // 천 1 
+		case 23: // 천 2 
+		case 41: //  1 
+		case 43: //  2 
+		case 113: // OX 
+			return false;
+	}
+
+	return true;
+}
+
+void CInputLogin::Login(LPDESC d, const char* data)
+{
+	TPacketCGLogin* pinfo = (TPacketCGLogin*)data;
+
+	char login[LOGIN_MAX_LEN + 1];
+	trim_and_lower(pinfo->login, login, sizeof(login));
+
+	sys_log(0, "InputLogin::Login : %s", login);
+
+	TPacketGCLoginFailure failurePacket;
+
+	if (g_iUseLocale && !test_server)
+	{
+		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
+		strlcpy(failurePacket.szStatus, "VERSION", sizeof(failurePacket.szStatus));
+		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
+		return;
+	}
+
+	if (g_bNoMoreClient)
+	{
+		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
+		strlcpy(failurePacket.szStatus, "SHUTDOWN", sizeof(failurePacket.szStatus));
+		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
+		return;
+	}
+
+	if (g_iUserLimit > 0)
+	{
+		int iTotal;
+		int* paiEmpireUserCount;
+		int iLocal;
+
+		DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
+
+		if (g_iUserLimit <= iTotal)
+		{
+			failurePacket.header = HEADER_GC_LOGIN_FAILURE;
+			strlcpy(failurePacket.szStatus, "FULL", sizeof(failurePacket.szStatus));
+			d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
+			return;
+		}
+	}
+
+	TLoginPacket login_packet;
+
+	strlcpy(login_packet.login, login, sizeof(login_packet.login));
+	strlcpy(login_packet.passwd, pinfo->passwd, sizeof(login_packet.passwd));
+
+	db_clientdesc->DBPacket(HEADER_GD_LOGIN, d->GetHandle(), &login_packet, sizeof(TLoginPacket));
+}
+
+void CInputLogin::LoginByKey(LPDESC d, const char* data)
+{
+	TPacketCGLogin2* pinfo = (TPacketCGLogin2*)data;
+
+	char login[LOGIN_MAX_LEN + 1];
+	trim_and_lower(pinfo->login, login, sizeof(login));
+
+	// is blocked ip?
+	{
+		dev_log(LOG_DEB0, "check_blocked_country_start");
+
+		if (!is_block_exception(login) && is_blocked_country_ip(d->GetHostName()))
+		{
+			sys_log(0, "BLOCK_COUNTRY_IP (%s)", d->GetHostName());
+			d->SetPhase(PHASE_CLOSE);
+			return;
+		}
+
+		dev_log(LOG_DEB0, "check_blocked_country_end");
+	}
+
+	if (g_bNoMoreClient)
+	{
+		TPacketGCLoginFailure failurePacket;
+
+		failurePacket.header = HEADER_GC_LOGIN_FAILURE;
+		strlcpy(failurePacket.szStatus, "SHUTDOWN", sizeof(failurePacket.szStatus));
+		d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
+		return;
+	}
+
+	if (g_iUserLimit > 0)
+	{
+		int iTotal;
+		int* paiEmpireUserCount;
+		int iLocal;
+
+		DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
+
+		if (g_iUserLimit <= iTotal)
+		{
+			TPacketGCLoginFailure failurePacket;
+
+			failurePacket.header = HEADER_GC_LOGIN_FAILURE;
+			strlcpy(failurePacket.szStatus, "FULL", sizeof(failurePacket.szStatus));
+
+			d->Packet(&failurePacket, sizeof(TPacketGCLoginFailure));
+			return;
+		}
+	}
+
+	sys_log(0, "LOGIN_BY_KEY: %s key %u", login, pinfo->dwLoginKey);
+
+	d->SetLoginKey(pinfo->dwLoginKey);
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+	d->SetSecurityKey(pinfo->adwClientKey);
+#endif
+
+	TPacketGDLoginByKey ptod;
+
+	strlcpy(ptod.szLogin, login, sizeof(ptod.szLogin));
+	ptod.dwLoginKey = pinfo->dwLoginKey;
+	thecore_memcpy(ptod.adwClientKey, pinfo->adwClientKey, sizeof(DWORD) * 4);
+	strlcpy(ptod.szIP, d->GetHostName(), sizeof(ptod.szIP));
+
+	db_clientdesc->DBPacket(HEADER_GD_LOGIN_BY_KEY, d->GetHandle(), &ptod, sizeof(TPacketGDLoginByKey));
+}
+
+void CInputLogin::ChangeName(LPDESC d, const char* data)
+{
+	TPacketCGChangeName* p = (TPacketCGChangeName*)data;
+	const TAccountTable& c_r = d->GetAccountTable();
+
+	if (!c_r.id)
+	{
+		sys_err("no account table");
+		return;
+	}
+
+	if (p->index >= PLAYER_PER_ACCOUNT || p->index < 0)
+	{
+		sys_err("index overflow %d, login: %s", p->index, c_r.login);
+		return;
+	}
+
+	if (!c_r.players[p->index].dwID)
+	{
+		sys_err("no player id, login %s", c_r.login);
+		return;
+	}
+
+	if (!c_r.players[p->index].bChangeName)
+		return;
+
+	if (!check_name(p->name))
+	{
+		TPacketGCCreateFailure pack;
+		pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
+		pack.bType = 0;
+		d->Packet(&pack, sizeof(pack));
+		return;
+	}
+
+	TPacketGDChangeName pdb;
+
+	pdb.pid = c_r.players[p->index].dwID;
+	strlcpy(pdb.name, p->name, sizeof(pdb.name));
+	db_clientdesc->DBPacket(HEADER_GD_CHANGE_NAME, d->GetHandle(), &pdb, sizeof(TPacketGDChangeName));
+}
+
+void CInputLogin::CharacterSelect(LPDESC d, const char* data)
+{
+	struct command_player_select* pinfo = (struct command_player_select*)data;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	TAccountTable& c_r = d->GetAccountTable();
+#else
+	const TAccountTable& c_r = d->GetAccountTable();
+#endif
+
+	sys_log(0, "player_select: login: %s index: %d", c_r.login, pinfo->index);
+
+	if (!c_r.id)
+	{
+		sys_err("no account table");
+		return;
+	}
+
+	if (pinfo->index >= PLAYER_PER_ACCOUNT || pinfo->index < 0)
+	{
+		sys_err("index overflow %d, login: %s", pinfo->index, c_r.login);
+		return;
+	}
+
+	if (!c_r.players[pinfo->index].dwID)
+	{
+		sys_err("no player id, login %s", c_r.login);
+		return;
+	}
+
+	if (c_r.players[pinfo->index].bChangeName)
+	{
+		sys_err("name must be changed idx %d, login %s, name %s",
+			pinfo->index, c_r.login, c_r.players[pinfo->index].szName);
+		return;
+	}
+
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	if (!LocaleService_GetLocale(pinfo->country))
+	{
+		sys_err("cannot find locale country %s, login %s, name %s",
+			pinfo->country, c_r.login, c_r.players[pinfo->index].szName);
+		return;
+	}
+
+	if (strcmp(c_r.country, pinfo->country))
+	{
+		thecore_memcpy(c_r.country, pinfo->country, sizeof(c_r.country));
+
+		char query[128];
+		snprintf(query, sizeof(query), "UPDATE `account`.`account` SET `country` = '%s' WHERE `id` = %u",
+			LocaleService_GetCountry(pinfo->country), c_r.id);
+		std::unique_ptr<SQLMsg> msg(DBManager::instance().DirectQuery(query));
+	}
+#endif
+
+	TPlayerLoadPacket player_load_packet;
+
+	player_load_packet.account_id = c_r.id;
+	player_load_packet.player_id = c_r.players[pinfo->index].dwID;
+	player_load_packet.account_index = pinfo->index;
+
+	db_clientdesc->DBPacket(HEADER_GD_PLAYER_LOAD, d->GetHandle(), &player_load_packet, sizeof(TPlayerLoadPacket));
+}
+
+bool NewPlayerTable(TPlayerTable* table,
+	const char* name,
+	BYTE job,
+	BYTE shape,
+	BYTE bEmpire,
+	BYTE bCon,
+	BYTE bInt,
+	BYTE bStr,
+	BYTE bDex)
+{
+	if (job >= JOB_MAX_NUM)
+		return false;
+
+	memset(table, 0, sizeof(TPlayerTable));
+
+	strlcpy(table->name, name, sizeof(table->name));
+
+	table->level = 1;
+	table->job = job;
+	table->voice = 0;
+	table->part_base = shape;
+
+	table->st = JobInitialPoints[job].st;
+	table->dx = JobInitialPoints[job].dx;
+	table->ht = JobInitialPoints[job].ht;
+	table->iq = JobInitialPoints[job].iq;
+
+	table->hp = JobInitialPoints[job].max_hp + table->ht * JobInitialPoints[job].hp_per_ht;
+	table->sp = JobInitialPoints[job].max_sp + table->iq * JobInitialPoints[job].sp_per_iq;
+	table->stamina = JobInitialPoints[job].max_stamina;
+
+	table->x = CREATE_START_X(bEmpire, job) + number(-300, 300);
+	table->y = CREATE_START_Y(bEmpire, job) + number(-300, 300);
+
+	table->z = 0;
+	table->dir = 0;
+	table->playtime = 0;
+	table->gold = 0;
+
+	table->skill_group = 0;
+
+	if (china_event_server)
+	{
+		table->level = 35;
+
+		for (int i = 1; i < 35; ++i)
+		{
+			int iHP = number(JobInitialPoints[job].hp_per_lv_begin, JobInitialPoints[job].hp_per_lv_end);
+			int iSP = number(JobInitialPoints[job].sp_per_lv_begin, JobInitialPoints[job].sp_per_lv_end);
+			table->sRandomHP += iHP;
+			table->sRandomSP += iSP;
+			table->stat_point += 3;
+		}
+
+		table->hp += table->sRandomHP;
+		table->sp += table->sRandomSP;
+
+		table->gold = 1000000;
+	}
+
+	return true;
+}
+
+bool RaceToJob(BYTE race, BYTE* ret_job)
+{
+	*ret_job = 0;
+
+	if (race >= MAIN_RACE_MAX_NUM)
+		return false;
+
+	switch (race)
+	{
+		case MAIN_RACE_WARRIOR_M:
+			*ret_job = JOB_WARRIOR;
+			break;
+
+		case MAIN_RACE_WARRIOR_W:
+			*ret_job = JOB_WARRIOR;
+			break;
+
+		case MAIN_RACE_ASSASSIN_M:
+			*ret_job = JOB_ASSASSIN;
+			break;
+
+		case MAIN_RACE_ASSASSIN_W:
+			*ret_job = JOB_ASSASSIN;
+			break;
+
+		case MAIN_RACE_SURA_M:
+			*ret_job = JOB_SURA;
+			break;
+
+		case MAIN_RACE_SURA_W:
+			*ret_job = JOB_SURA;
+			break;
+
+		case MAIN_RACE_SHAMAN_M:
+			*ret_job = JOB_SHAMAN;
+			break;
+
+		case MAIN_RACE_SHAMAN_W:
+			*ret_job = JOB_SHAMAN;
+			break;
+
+		case MAIN_RACE_WOLFMAN_M:
+			*ret_job = JOB_WOLFMAN;
+			break;
+
+		default:
+			return false;
+			break;
+	}
+	return true;
+}
+
+// 킥 캐 
+bool NewPlayerTable2(TPlayerTable* table, const char* name, BYTE race, BYTE shape, BYTE bEmpire)
+{
+	if (race >= MAIN_RACE_MAX_NUM)
+	{
+		sys_err("NewPlayerTable2.OUT_OF_RACE_RANGE(%d >= max(%d))\n", race, MAIN_RACE_MAX_NUM);
+		return false;
+	}
+
+	BYTE job;
+	if (!RaceToJob(race, &job))
+	{
+		sys_err("NewPlayerTable2.RACE_TO_JOB_ERROR(%d)\n", race);
+		return false;
+	}
+
+	sys_log(0, "NewPlayerTable2(name=%s, race=%d, job=%d)", name, race, job);
+
+	memset(table, 0, sizeof(TPlayerTable));
+
+	strlcpy(table->name, name, sizeof(table->name));
+
+	table->level = 1;
+	table->job = race; //   獵쨈
+	table->voice = 0;
+	table->part_base = shape;
+
+	table->st = JobInitialPoints[job].st;
+	table->dx = JobInitialPoints[job].dx;
+	table->ht = JobInitialPoints[job].ht;
+	table->iq = JobInitialPoints[job].iq;
+
+	table->hp = JobInitialPoints[job].max_hp + table->ht * JobInitialPoints[job].hp_per_ht;
+	table->sp = JobInitialPoints[job].max_sp + table->iq * JobInitialPoints[job].sp_per_iq;
+	table->stamina = JobInitialPoints[job].max_stamina;
+
+	table->x = CREATE_START_X(bEmpire, job) + number(-300, 300);
+	table->y = CREATE_START_Y(bEmpire, job) + number(-300, 300);
+
+	table->z = 0;
+	table->dir = 0;
+	table->playtime = 0;
+	table->gold = 0;
+
+	table->skill_group = 0;
+
+	return true;
+}
+
+void CInputLogin::CharacterCreate(LPDESC d, const char* data)
+{
+	struct command_player_create* pinfo = (struct command_player_create*)data;
+	TPlayerCreatePacket player_create_packet;
+
+	sys_log(0, "PlayerCreate: name %s pos %d job %d shape %d",
+		pinfo->name,
+		pinfo->index,
+		pinfo->job,
+		pinfo->shape
+	);
+
+	TPacketGCLoginFailure packFailure;
+	memset(&packFailure, 0, sizeof(packFailure));
+	packFailure.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
+
+	if (true == g_BlockCharCreation)
+	{
+		d->Packet(&packFailure, sizeof(packFailure));
+		return;
+	}
+
+	if (!g_bWolfmanCreation)
+	{
+		if (pinfo->job == MAIN_RACE_WOLFMAN_M)
+		{
+			d->Packet(&packFailure, sizeof(packFailure));
+			return;
+		}
+	}
+
+	//    見隔킬, 蔘 見  
+	if (!check_name(pinfo->name) || pinfo->shape > 1)
+	{
+		if (LC_IsCanada() == true)
+		{
+			TPacketGCCreateFailure pack;
+			pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
+			pack.bType = 1;
+
+			d->Packet(&pack, sizeof(pack));
+			return;
+		}
+
+		d->Packet(&packFailure, sizeof(packFailure));
+		return;
+	}
+
+	if (LC_IsEurope() == true)
+	{
+		const TAccountTable& c_rAccountTable = d->GetAccountTable();
+
+		if (0 == strcmp(c_rAccountTable.login, pinfo->name))
+		{
+			TPacketGCCreateFailure pack;
+			pack.header = HEADER_GC_CHARACTER_CREATE_FAILURE;
+			pack.bType = 1;
+
+			d->Packet(&pack, sizeof(pack));
+			return;
+		}
+	}
+
+	memset(&player_create_packet, 0, sizeof(TPlayerCreatePacket));
+
+	if (!NewPlayerTable2(&player_create_packet.player_table, pinfo->name, pinfo->job, pinfo->shape, d->GetEmpire()))
+	{
+		sys_err("player_prototype error: job %d face %d ", pinfo->job);
+		d->Packet(&packFailure, sizeof(packFailure));
+		return;
+	}
+
+	const TAccountTable& c_rAccountTable = d->GetAccountTable();
+
+	trim_and_lower(c_rAccountTable.login, player_create_packet.login, sizeof(player_create_packet.login));
+	strlcpy(player_create_packet.passwd, c_rAccountTable.passwd, sizeof(player_create_packet.passwd));
+
+	player_create_packet.account_id = c_rAccountTable.id;
+	player_create_packet.account_index = pinfo->index;
+
+	sys_log(0, "PlayerCreate: name %s account_id %d, TPlayerCreatePacketSize(%d), Packet->Gold %d",
+		pinfo->name,
+		pinfo->index,
+		sizeof(TPlayerCreatePacket),
+		player_create_packet.player_table.gold);
+
+	db_clientdesc->DBPacket(HEADER_GD_PLAYER_CREATE, d->GetHandle(), &player_create_packet, sizeof(TPlayerCreatePacket));
+}
+
+void CInputLogin::CharacterDelete(LPDESC d, const char* data)
+{
+	struct command_player_delete* pinfo = (struct command_player_delete*)data;
+	const TAccountTable& c_rAccountTable = d->GetAccountTable();
+
+	if (!c_rAccountTable.id)
+	{
+		sys_err("PlayerDelete: no login data");
+		return;
+	}
+
+	sys_log(0, "PlayerDelete: login: %s index: %d, social_id %s", c_rAccountTable.login, pinfo->index, pinfo->private_code);
+
+	if (pinfo->index >= PLAYER_PER_ACCOUNT || pinfo->index < 0)
+	{
+		sys_err("PlayerDelete: index overflow %d, login: %s", pinfo->index, c_rAccountTable.login);
+		return;
+	}
+
+	if (!c_rAccountTable.players[pinfo->index].dwID)
+	{
+		sys_err("PlayerDelete: Wrong Social ID index %d, login: %s", pinfo->index, c_rAccountTable.login);
+		d->Packet(encode_byte(HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID), 1);
+		return;
+	}
+
+	TPlayerDeletePacket player_delete_packet;
+
+	trim_and_lower(c_rAccountTable.login, player_delete_packet.login, sizeof(player_delete_packet.login));
+	player_delete_packet.player_id = c_rAccountTable.players[pinfo->index].dwID;
+	player_delete_packet.account_index = pinfo->index;
+	strlcpy(player_delete_packet.private_code, pinfo->private_code, sizeof(player_delete_packet.private_code));
+
+	db_clientdesc->DBPacket(HEADER_GD_PLAYER_DELETE, d->GetHandle(), &player_delete_packet, sizeof(TPlayerDeletePacket));
+}
+
+#pragma pack(1)
+typedef struct SPacketGTLogin
+{
+	BYTE header;
+	WORD empty;
+	DWORD id;
+} TPacketGTLogin;
+#pragma pack()
+
+void CInputLogin::Entergame(LPDESC d, const char* data)
+{
+	LPCHARACTER ch;
+
+	if (!(ch = d->GetCharacter()))
+	{
+		d->SetPhase(PHASE_CLOSE);
+		return;
+	}
+
+	// Hardening: never allow observer mode to persist across logins (e.g. Alt+F4 while observing).
+	if (ch->IsObserverMode())
+		ch->SetObserverMode(false);
+	ch->SetArenaObserverMode(false);
+
+	PIXEL_POSITION pos = ch->GetXYZ();
+	if (!SECTREE_MANAGER::instance().GetMovablePosition(ch->GetMapIndex(), pos.x, pos.y, pos))
+	{
+		PIXEL_POSITION pos2;
+		SECTREE_MANAGER::instance().GetRecallPositionByEmpire(ch->GetMapIndex(), ch->GetEmpire(), pos2);
+
+		sys_err("!GetMovablePosition (name %s %dx%d map %d changed to %dx%d)",
+			ch->GetName(),
+			pos.x, pos.y,
+			ch->GetMapIndex(),
+			pos2.x, pos2.y);
+		pos = pos2;
+	}
+
+	CGuildManager::instance().LoginMember(ch);
+
+	// 캐拷 却 煞
+	ch->Show(ch->GetMapIndex(), pos.x, pos.y, pos.z);
+	ch->ReviveInvisible(5);
+
+#if !defined(__BINARY_ATLAS_MARK_INFO__)
+	SECTREE_MANAGER::instance().SendNPCPosition(ch);
+#endif
+
+	d->SetPhase(PHASE_GAME);
+
+#if defined(__HIDE_COSTUME_SYSTEM__)
+	ch->SetHiddenCostumeParts();
+#endif
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	const LPITEM& rkCostumeMount = ch->GetWear(WEAR_COSTUME_MOUNT);
+	if (rkCostumeMount)
+		ch->MountVnum(rkCostumeMount->GetMountVnum());
+	else if (ch->GetHorseLevel() > 0)
+		ch->EnterHorse();
+#else
+	if (ch->GetHorseLevel() > 0)
+		ch->EnterHorse();
+#endif
+
+	if (ch->GetItemAward_cmd()[0] != '\0') //  載
+		quest::CQuestManager::instance().ItemInformer(ch->GetPlayerID(), ch->GetItemAward_vnum()); // questmanager 호
+
+	sys_log(0, "ENTERGAME: %s %dx%dx%d %s map_index %d",
+		ch->GetName(), ch->GetX(), ch->GetY(), ch->GetZ(), d->GetHostName(), ch->GetMapIndex());
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	ch->SendExtendInvenPacket();
+#endif
+
+	// Check unwanted quickslot items.
+	ch->CheckQuickSlotItems();
+
+	// 첨決챨 湄 
+	ch->ResetPlayTime();
+
+	// 湄  遣트 煞
+	ch->StartSaveEvent();
+	ch->StartRecoveryEvent();
+	ch->StartCheckSpeedHackEvent();
+	ch->SetQuestFlag("item.last_time", get_global_time());
+
+	CPVPManager::instance().Connect(ch);
+	CPVPManager::instance().SendList(d);
+
+	CMessengerManager::instance().Login(ch->GetName());
+
+	CPartyManager::instance().SetParty(ch);
+	CGuildManager::instance().SendGuildWar(ch);
+
+	building::CManager::instance().SendLandList(d, ch->GetMapIndex());
+
+	marriage::CManager::instance().Login(ch);
+
+#ifdef __OFFLINE_SHOP__
+	COfflineShop::Login(ch);
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	TPacketGDEmote GDPacket = {};
+	GDPacket.dwPID = ch->GetPlayerID();
+	db_clientdesc->DBPacket(HEADER_GD_EMOTE_LOAD, ch->GetDesc()->GetHandle(), &GDPacket, sizeof(GDPacket));
+#endif
+
+	TPacketGCTime p;
+	p.bHeader = HEADER_GC_TIME;
+	p.time = get_global_time();
+	d->Packet(&p, sizeof(p));
+
+	TPacketGCChannel p2;
+	p2.header = HEADER_GC_CHANNEL;
+	p2.channel = g_bChannel;
+	d->Packet(&p2, sizeof(p2));
+
+#if defined(__LOOT_FILTER_SYSTEM__) && !defined(__PREMIUM_LOOT_FILTER__)
+	ch->SetLootFilter();
+#endif
+
+#if defined(__MAILBOX__)
+	CMailBox::UnreadData(ch);
+#endif
+
+	ch->SendGreetMessage();
+	_send_bonus_info(ch);
+
+	std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("UPDATE player%s SET `last_play` = NOW() WHERE `name` = '%s'",
+		get_table_postfix(), ch->GetName())
+	);
+
+	ch->LoadSafeboxBuff();
+
+	for (int i = 0; i <= PREMIUM_MAX_NUM; ++i)
+	{
+		int remain = ch->GetPremiumRemainSeconds(i);
+
+		if (remain <= 0)
+			continue;
+
+#if defined(__CONQUEROR_LEVEL__)
+		int idx = AFFECT_PREMIUM_START + i;
+		if (idx == AFFECT_SUNGMA_BONUS)
+		{
+			for (int affect = POINT_SUNGMA_STR; affect <= POINT_SUNGMA_IMMUNE; ++affect)
+				ch->AddAffect(idx, affect, 10, 0, remain, 0, true, true);
+		}
+		else
+			ch->AddAffect(idx, POINT_NONE, 0, 0, remain, 0, true);
+#else
+		ch->AddAffect(AFFECT_PREMIUM_START + i, POINT_NONE, 0, 0, remain, 0, true);
+#endif
+		sys_log(0, "PREMIUM: %s type %d %dmin", ch->GetName(), i, remain);
+	}
+#ifdef __OFFLINE_SHOP__
+	int remainBuy = ch->GetQuestFlag("decoration.limit_time") - get_global_time();
+	if (remainBuy > 0)
+		ch->AddAffect(AFFECT_OFFLINE_SHOP_DECORATION, POINT_NONE, 0, 0, remainBuy, 0, true);
+#endif
+
+	if (g_bCheckClientVersion)
+	{
+		sys_log(0, "VERSION CHECK %s %s", g_stClientVersion.c_str(), d->GetClientVersion());
+
+		if (!d->GetClientVersion())
+		{
+			d->DelayedDisconnect(10);
+		}
+		else
+		{
+			if (0 != g_stClientVersion.compare(d->GetClientVersion()))
+			{
+				ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("클潔트  틀 慣類틸 絳求.  치  究."));
+				d->DelayedDisconnect(0);
+				LogManager::instance().HackLog("VERSION_CONFLICT", ch);
+
+				sys_log(0, "VERSION : WRONG VERSION USER : account:%s name:%s hostName:%s server_version:%s client_version:%s",
+					d->GetAccountTable().login,
+					ch->GetName(),
+					d->GetHostName(),
+					g_stClientVersion.c_str(),
+					d->GetClientVersion());
+			}
+		}
+	}
+	else
+	{
+		sys_log(0, "VERSION : NO CHECK");
+	}
+
+	if (ch->IsGM() == true)
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "ConsoleEnable");
+
+#if defined(__POPUP_NOTICE__)
+	if (quest::CQuestManager::instance().GetEventFlag("PopupNoticeEventFlag") > 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "PopupNoticeProcess %d %s",
+			ch->GetQuestFlag("popup_notice.checkbox"), g_strWebPopupNoticeURL.c_str());
+	}
+#endif
+
+#if defined(__MOVE_CHANNEL__)
+	ch->ChatPacket(CHAT_TYPE_COMMAND, "server_info %d %d", g_bChannel, ch->GetMapIndex());
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+	CSnowflakeStickEvent::EnterGame(ch);
+#endif
+
+	if (ch->GetMapIndex() >= 10000)
+	{
+		if (CWarMapManager::instance().IsWarMap(ch->GetMapIndex()))
+		{
+			ch->SetWarMap(CWarMapManager::instance().Find(ch->GetMapIndex()));
+		}
+		else if (marriage::WeddingManager::instance().IsWeddingMap(ch->GetMapIndex()))
+		{
+			ch->SetWeddingMap(marriage::WeddingManager::instance().Find(ch->GetMapIndex()));
+		}
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+		else if (CGuildDragonLairManager::Instance().IsRedDragonLair(ch->GetMapIndex()))
+		{
+			ch->SetGuildDragonLair(CGuildDragonLairManager::Instance().FindByMapIndex(ch->GetMapIndex()));
+		}
+#endif
+#if defined(__DEFENSE_WAVE__)
+		else if (CDefenseWaveManager::instance().IsDefenseWaveMap(ch->GetMapIndex()))
+		{
+			ch->SetDefenseWave(CDefenseWaveManager::instance().FindByMapIndex(ch->GetMapIndex()));
+		}
+#endif
+		else
+		{
+			ch->SetDungeon(CDungeonManager::instance().FindByMapIndex(ch->GetMapIndex()));
+		}
+	}
+	else if (CArenaManager::instance().IsArenaMap(ch->GetMapIndex()))
+	{
+		int memberFlag = CArenaManager::instance().IsMember(ch->GetMapIndex(), ch->GetPlayerID());
+		if (memberFlag == MEMBER_OBSERVER)
+		{
+			ch->SetObserverMode(true);
+			ch->SetArenaObserverMode(true);
+			if (CArenaManager::instance().RegisterObserverPtr(ch, ch->GetMapIndex(), ch->GetX() / 100, ch->GetY() / 100))
+			{
+				sys_log(0, "ARENA : Observer add failed");
+			}
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+			ch->UnMount(ch);
+#else
+			if (ch->IsHorseRiding() == true)
+			{
+				ch->StopRiding();
+				ch->HorseSummon(false);
+			}
+#endif
+		}
+		else if (memberFlag == MEMBER_DUELIST)
+		{
+			TPacketGCDuelStart duelStart;
+			duelStart.header = HEADER_GC_DUEL_START;
+			duelStart.wSize = sizeof(TPacketGCDuelStart);
+
+			ch->GetDesc()->Packet(&duelStart, sizeof(TPacketGCDuelStart));
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+			ch->UnMount(ch);
+#else
+			if (ch->IsHorseRiding() == true)
+			{
+				ch->StopRiding();
+				ch->HorseSummon(false);
+			}
+#endif
+
+			LPPARTY pParty = ch->GetParty();
+			if (pParty != NULL)
+			{
+				if (pParty->GetMemberCount() == 2)
+				{
+					CPartyManager::instance().DeleteParty(pParty);
+				}
+				else
+				{
+					pParty->Quit(ch->GetPlayerID());
+				}
+			}
+		}
+		/*
+		else if (memberFlag == MEMBER_NO)
+		{
+			if (ch->GetGMLevel() == GM_PLAYER)
+				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
+		}
+		else
+		{
+			// wtf
+		}
+		*/
+	}
+	else if (ch->GetMapIndex() == MAP_OXEVENT)
+	{
+		// ox 遣트 
+		if (COXEventManager::instance().Enter(ch) == false)
+		{
+			// ox   昇  . 첨潔  
+			if (ch->GetGMLevel() == GM_PLAYER)
+				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
+		}
+	}
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	else if (ch->GetMapIndex() == MAP_N_FLAME_DRAGON)
+	{
+		CGuildDragonLairManager::Instance().Exit(ch);
+	}
+#endif
+	else
+	{
+		if (CWarMapManager::instance().IsWarMap(ch->GetMapIndex()) ||
+			marriage::WeddingManager::instance().IsWeddingMap(ch->GetMapIndex()))
+		{
+			if (!test_server)
+				ch->WarpSet(EMPIRE_START_X(ch->GetEmpire()), EMPIRE_START_Y(ch->GetEmpire()));
+		}
+
+#if defined(__ELEMENTAL_DUNGEON__)
+		if (ch->GetMapIndex() == MAP_ELEMENTAL_04)
+			ch->StartElementalCurseEvent();
+		else
+			ch->StopElementalCurseEvent();
+#endif
+	}
+
+	if (ch->GetHorseLevel() > 0)
+	{
+		DWORD pid = ch->GetPlayerID();
+
+		if (pid > 0)
+		{
+			const char* horseName = CHorseNameManager::instance().GetHorseName(pid);
+			if (!horseName || !*horseName)
+				db_clientdesc->DBPacket(HEADER_GD_REQ_HORSE_NAME, 0, &pid, sizeof(DWORD));
+		}
+	}
+
+	// 蔘却 載 홰歐
+	if (g_noticeBattleZone)
+	{
+		if (FN_is_battle_zone(ch))
+		{
+			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING(" 却     笭求."));
+			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING(" 六  "));
+			ch->ChatPacket(CHAT_TYPE_NOTICE, LC_STRING(" 玲  關 튼챰 帽求."));
+		}
+	}
+#ifdef __GROWTH_PET_SYSTEM__
+	/*
+		This packet is sent at python window initialization. No need
+		to update anything.
+	*/
+	case HEADER_CG_PET_WINDOW_TYPE:
+		break;
+#endif
+}
+
+void CInputLogin::Empire(LPDESC d, const char* c_pData)
+{
+	const TPacketCGEmpire* p = reinterpret_cast<const TPacketCGEmpire*>(c_pData);
+
+	if (EMPIRE_MAX_NUM <= p->bEmpire)
+	{
+		d->SetPhase(PHASE_CLOSE);
+		return;
+	}
+
+	const TAccountTable& r = d->GetAccountTable();
+
+	if (r.bEmpire != 0)
+	{
+		for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
+		{
+			if (0 != r.players[i].dwID)
+			{
+				sys_err("EmpireSelectFailed %d", r.players[i].dwID);
+				return;
+			}
+		}
+	}
+
+	TEmpireSelectPacket pd;
+
+	pd.dwAccountID = r.id;
+	pd.bEmpire = p->bEmpire;
+
+	db_clientdesc->DBPacket(HEADER_GD_EMPIRE_SELECT, d->GetHandle(), &pd, sizeof(pd));
+}
+
+int CInputLogin::GuildSymbolUpload(LPDESC d, const char* c_pData, size_t uiBytes)
+{
+	if (uiBytes < sizeof(TPacketCGGuildSymbolUpload))
+		return -1;
+
+	sys_log(0, "GuildSymbolUpload uiBytes %u", uiBytes);
+
+	TPacketCGGuildSymbolUpload* p = (TPacketCGGuildSymbolUpload*)c_pData;
+
+	if (uiBytes < p->size)
+		return -1;
+
+	int iSymbolSize = p->size - sizeof(TPacketCGGuildSymbolUpload);
+
+	if (iSymbolSize <= 0 || iSymbolSize > 64 * 1024)
+	{
+		// 64k  큰   첩
+		//   
+		d->SetPhase(PHASE_CLOSE);
+		return 0;
+	}
+
+	//     .
+	if (!test_server)
+		if (!building::CManager::instance().FindLandByGuild(p->guild_id))
+		{
+			d->SetPhase(PHASE_CLOSE);
+			return 0;
+		}
+
+	sys_log(0, "GuildSymbolUpload Do Upload %02X%02X%02X%02X %d", c_pData[7], c_pData[8], c_pData[9], c_pData[10], sizeof(*p));
+
+	CGuildMarkManager::instance().UploadSymbol(p->guild_id, iSymbolSize, (const BYTE*)(c_pData + sizeof(*p)));
+	CGuildMarkManager::instance().SaveSymbol(GUILD_SYMBOL_FILENAME);
+	return iSymbolSize;
+}
+
+void CInputLogin::GuildSymbolCRC(LPDESC d, const char* c_pData)
+{
+	const TPacketCGSymbolCRC& CGPacket = *((TPacketCGSymbolCRC*)c_pData);
+
+	sys_log(0, "GuildSymbolCRC %u %u %u", CGPacket.guild_id, CGPacket.crc, CGPacket.size);
+
+	const CGuildMarkManager::TGuildSymbol* pkGS = CGuildMarkManager::instance().GetGuildSymbol(CGPacket.guild_id);
+
+	if (!pkGS)
+		return;
+
+	sys_log(0, "  Server %u %u", pkGS->crc, pkGS->raw.size());
+
+	if (pkGS->raw.size() != CGPacket.size || pkGS->crc != CGPacket.crc)
+	{
+		TPacketGCGuildSymbolData GCPacket;
+
+		GCPacket.header = HEADER_GC_SYMBOL_DATA;
+		GCPacket.size = sizeof(GCPacket) + pkGS->raw.size();
+		GCPacket.guild_id = CGPacket.guild_id;
+
+		d->BufferedPacket(&GCPacket, sizeof(GCPacket));
+		d->Packet(&pkGS->raw[0], pkGS->raw.size());
+
+		sys_log(0, "SendGuildSymbolHead %02X%02X%02X%02X Size %d",
+			pkGS->raw[0], pkGS->raw[1], pkGS->raw[2], pkGS->raw[3], pkGS->raw.size());
+	}
+}
+
+void CInputLogin::GuildMarkUpload(LPDESC d, const char* c_pData)
+{
+	TPacketCGMarkUpload* p = (TPacketCGMarkUpload*)c_pData;
+	CGuildManager& rkGuildMgr = CGuildManager::instance();
+	CGuild* pkGuild;
+
+	if (!(pkGuild = rkGuildMgr.FindGuild(p->gid)))
+	{
+		sys_err("MARK_SERVER: GuildMarkUpload: no guild. gid %u", p->gid);
+		return;
+	}
+
+	if (pkGuild->GetLevel() < guild_mark_min_level)
+	{
+		sys_log(0, "MARK_SERVER: GuildMarkUpload: level < %u (%u)", guild_mark_min_level, pkGuild->GetLevel());
+		return;
+	}
+
+	CGuildMarkManager& rkMarkMgr = CGuildMarkManager::instance();
+
+	sys_log(0, "MARK_SERVER: GuildMarkUpload: gid %u", p->gid);
+
+	bool isEmpty = true;
+
+	for (DWORD iPixel = 0; iPixel < SGuildMark::SIZE; ++iPixel)
+		if (*((DWORD*)p->image + iPixel) != 0x00000000)
+			isEmpty = false;
+
+	if (isEmpty)
+		rkMarkMgr.DeleteMark(p->gid);
+	else
+		rkMarkMgr.SaveMark(p->gid, p->image);
+}
+
+void CInputLogin::GuildMarkIDXList(LPDESC d, const char* c_pData)
+{
+	CGuildMarkManager& rkMarkMgr = CGuildMarkManager::instance();
+
+	DWORD bufSize = sizeof(WORD) * 2 * rkMarkMgr.GetMarkCount();
+	char* buf = NULL;
+
+	if (bufSize > 0)
+	{
+		buf = (char*)malloc(bufSize);
+		rkMarkMgr.CopyMarkIdx(buf);
+	}
+
+	TPacketGCMarkIDXList p;
+	p.header = HEADER_GC_MARK_IDXLIST;
+	p.bufSize = sizeof(p) + bufSize;
+	p.count = rkMarkMgr.GetMarkCount();
+
+	if (buf)
+	{
+		d->BufferedPacket(&p, sizeof(p));
+		d->LargePacket(buf, bufSize);
+		free(buf);
+	}
+	else
+		d->Packet(&p, sizeof(p));
+
+	sys_log(0, "MARK_SERVER: GuildMarkIDXList %d bytes sent.", p.bufSize);
+}
+
+void CInputLogin::GuildMarkCRCList(LPDESC d, const char* c_pData)
+{
+	TPacketCGMarkCRCList* pCG = (TPacketCGMarkCRCList*)c_pData;
+
+	std::map<BYTE, const SGuildMarkBlock*> mapDiffBlocks;
+	CGuildMarkManager::instance().GetDiffBlocks(pCG->imgIdx, pCG->crclist, mapDiffBlocks);
+
+	DWORD blockCount = 0;
+	TEMP_BUFFER buf(1024 * 1024); // 1M 
+
+	for (auto it = mapDiffBlocks.begin(); it != mapDiffBlocks.end(); ++it)
+	{
+		BYTE posBlock = it->first;
+		const SGuildMarkBlock& rkBlock = *it->second;
+
+		buf.write(&posBlock, sizeof(BYTE));
+		buf.write(&rkBlock.m_sizeCompBuf, sizeof(DWORD));
+		buf.write(rkBlock.m_abCompBuf, rkBlock.m_sizeCompBuf);
+
+		++blockCount;
+	}
+
+	TPacketGCMarkBlock pGC;
+
+	pGC.header = HEADER_GC_MARK_BLOCK;
+	pGC.imgIdx = pCG->imgIdx;
+	pGC.bufSize = buf.size() + sizeof(TPacketGCMarkBlock);
+	pGC.count = blockCount;
+
+	sys_log(0, "MARK_SERVER: Sending blocks. (imgIdx %u diff %u size %u)", pCG->imgIdx, mapDiffBlocks.size(), pGC.bufSize);
+
+	if (buf.size() > 0)
+	{
+		d->BufferedPacket(&pGC, sizeof(TPacketGCMarkBlock));
+		d->LargePacket(buf.read_peek(), buf.size());
+	}
+	else
+		d->Packet(&pGC, sizeof(TPacketGCMarkBlock));
+}
+
+int CInputLogin::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
+{
+	int iExtraLen = 0;
+
+	switch (bHeader)
+	{
+		case HEADER_CG_PONG:
+			Pong(d);
+			break;
+
+		case HEADER_CG_TIME_SYNC:
+			Handshake(d, c_pData);
+			break;
+
+		case HEADER_CG_LOGIN:
+			Login(d, c_pData);
+			break;
+
+		case HEADER_CG_LOGIN2:
+			LoginByKey(d, c_pData);
+			break;
+
+		case HEADER_CG_CHARACTER_SELECT:
+			CharacterSelect(d, c_pData);
+			break;
+
+		case HEADER_CG_CHARACTER_CREATE:
+			CharacterCreate(d, c_pData);
+			break;
+
+		case HEADER_CG_CHARACTER_DELETE:
+			CharacterDelete(d, c_pData);
+			break;
+
+		case HEADER_CG_ENTERGAME:
+			Entergame(d, c_pData);
+			break;
+
+		case HEADER_CG_EMPIRE:
+			Empire(d, c_pData);
+			break;
+
+		case HEADER_CG_MOVE:
+		case HEADER_CG_ITEM_USE:
+		case HEADER_CG_TARGET:
+			break;
+
+			///////////////////////////////////////
+			// Guild Mark
+			/////////////////////////////////////
+		case HEADER_CG_MARK_LOGIN:
+			break;
+
+		case HEADER_CG_MARK_CRCLIST:
+			GuildMarkCRCList(d, c_pData);
+			break;
+
+		case HEADER_CG_MARK_IDXLIST:
+			GuildMarkIDXList(d, c_pData);
+			break;
+
+		case HEADER_CG_MARK_UPLOAD:
+			GuildMarkUpload(d, c_pData);
+			break;
+
+			//////////////////////////////////////
+			// Guild Symbol
+			/////////////////////////////////////
+		case HEADER_CG_GUILD_SYMBOL_UPLOAD:
+			if ((iExtraLen = GuildSymbolUpload(d, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_SYMBOL_CRC:
+			GuildSymbolCRC(d, c_pData);
+			break;
+			/////////////////////////////////////
+
+		case HEADER_CG_HACK:
+			break;
+
+		case HEADER_CG_CHANGE_NAME:
+			ChangeName(d, c_pData);
+			break;
+
+		case HEADER_CG_CLIENT_VERSION:
+			Version(d->GetCharacter(), c_pData);
+			break;
+
+		case HEADER_CG_CLIENT_VERSION2:
+			Version(d->GetCharacter(), c_pData);
+			break;
+
+		default:
+			sys_err("login phase does not handle this packet! header %d", bHeader);
+			//d->SetPhase(PHASE_CLOSE);
+			return (0);
+	}
+
+	return (iExtraLen);
+}
diff --git a/server/server/home/metin2/Source/Server/game/src/input_main.cpp b/server/server/home/metin2/Source/Server/game/src/input_main.cpp
index 397e324..e9b18ef 100644
--- a/server/server/home/metin2/Source/Server/game/src/input_main.cpp
+++ b/server/server/home/metin2/Source/Server/game/src/input_main.cpp
@@ -1,5611 +1,5611 @@
-#include "stdafx.h"
-#include <cstring>
-#include "constants.h"
-#include "config.h"
-#include "utils.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "buffer_manager.h"
-#include "packet.h"
-#include "protocol.h"
-#include "char.h"
-#include "char_manager.h"
-#include "item.h"
-#include "item_manager.h"
-#ifdef ENABLE_QUEEN_NETHIS
-#include "SnakeLair.h"
-#endif
-#include "cmd.h"
-#include "shop.h"
-#include "shop_manager.h"
-#include "safebox.h"
-#include "regen.h"
-#include "battle.h"
-#include "exchange.h"
-#include "questmanager.h"
-#include "profiler.h"
-#include "messenger_manager.h"
-#include "party.h"
-#include "p2p.h"
-#include "affect.h"
-#include "guild.h"
-#include "guild_manager.h"
-#include "log.h"
-#include "banword.h"
-#include "empire_text_convert.h"
-#include "unique_item.h"
-#include "building.h"
-#include "locale_service.h"
-#include "gm.h"
-#include "spam.h"
-#include "ani.h"
-#include "motion.h"
-#include "OXEvent.h"
-#include "locale_service.h"
-#include "DragonSoul.h"
-#include "belt_inventory_helper.h"
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-#	include "LootFilter.h"
-#endif
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-#	include "xmas_event.h"
-#endif
-
-#if defined(__DEFENSE_WAVE__)
-#	include "defense_wave.h"
-#endif
-
-#if defined(__OFFLINE_SHOP__)
-#include "OfflineShop.h"
-#endif
-
-#if defined(__SHOP_SEARCH__)
-	#include "ShopSearchManager.h"
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-#include "battlepass_manager.h"
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-#include "growth_pet.h"
-#endif
-
-extern void SendShout(const char* szText, BYTE bEmpire
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	, const char* c_szName
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	, const char* c_szCountry
-#endif
-);
-
-extern int g_nPortalLimitTime;
-
-static int __deposit_limit()
-{
-	return (1000 * 10000); // 1천만
-}
-
-void SendBlockChatInfo(LPCHARACTER ch, int sec)
-{
-	if (sec <= 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("채팅 금지 상태입니다."));
-		return;
-	}
-
-	long hour = sec / 3600;
-	sec -= hour * 3600;
-
-	long min = (sec / 60);
-	sec -= min * 60;
-
-	if (hour > 0 && min > 0)
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d 시간 %d 분 %d 초 동안 채팅금지 상태입니다", hour, min, sec));
-	else if (hour > 0 && min == 0)
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d 시간 %d 초 동안 채팅금지 상태입니다", hour, sec));
-	else if (hour == 0 && min > 0)
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d 분 %d 초 동안 채팅금지 상태입니다", min, sec));
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d 초 동안 채팅금지 상태입니다", sec));
-}
-
-EVENTINFO(spam_event_info)
-{
-	char host[MAX_HOST_LENGTH + 1];
-
-	spam_event_info()
-	{
-		::memset(host, 0, MAX_HOST_LENGTH + 1);
-	}
-};
-
-typedef std::unordered_map<std::string, std::pair<unsigned int, LPEVENT>> spam_score_of_ip_t;
-spam_score_of_ip_t spam_score_of_ip;
-
-EVENTFUNC(block_chat_by_ip_event)
-{
-	spam_event_info* info = dynamic_cast<spam_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("block_chat_by_ip_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	const char* host = info->host;
-
-	spam_score_of_ip_t::iterator it = spam_score_of_ip.find(host);
-
-	if (it != spam_score_of_ip.end())
-	{
-		it->second.first = 0;
-		it->second.second = NULL;
-	}
-
-	return 0;
-}
-
-bool SpamBlockCheck(LPCHARACTER ch, const char* const buf, const size_t buflen)
-{
-	extern int g_iSpamBlockMaxLevel;
-
-	if (ch->GetLevel() < g_iSpamBlockMaxLevel)
-	{
-		spam_score_of_ip_t::iterator it = spam_score_of_ip.find(ch->GetDesc()->GetHostName());
-
-		if (it == spam_score_of_ip.end())
-		{
-			spam_score_of_ip.insert(std::make_pair(ch->GetDesc()->GetHostName(), std::make_pair(0, (LPEVENT)NULL)));
-			it = spam_score_of_ip.find(ch->GetDesc()->GetHostName());
-		}
-
-		if (it->second.second)
-		{
-			SendBlockChatInfo(ch, event_time(it->second.second) / passes_per_sec);
-			return true;
-		}
-
-		unsigned int score;
-		const char* word = SpamManager::instance().GetSpamScore(buf, buflen, score);
-
-		it->second.first += score;
-
-		if (word)
-			sys_log(0, "SPAM_SCORE: %s text: %s score: %u total: %u word: %s", ch->GetName(), buf, score, it->second.first, word);
-
-		extern unsigned int g_uiSpamBlockScore;
-		extern unsigned int g_uiSpamBlockDuration;
-
-		if (it->second.first >= g_uiSpamBlockScore)
-		{
-			spam_event_info* info = AllocEventInfo<spam_event_info>();
-			strlcpy(info->host, ch->GetDesc()->GetHostName(), sizeof(info->host));
-
-			it->second.second = event_create(block_chat_by_ip_event, info, PASSES_PER_SEC(g_uiSpamBlockDuration));
-			sys_log(0, "SPAM_IP: %s for %u seconds", info->host, g_uiSpamBlockDuration);
-
-			LogManager::instance().CharLog(ch, 0, "SPAM", word);
-
-			SendBlockChatInfo(ch, event_time(it->second.second) / passes_per_sec);
-
-			return true;
-		}
-	}
-
-	return false;
-}
-
-enum
-{
-	TEXT_TAG_PLAIN,
-	TEXT_TAG_TAG, // ||
-	TEXT_TAG_COLOR, // |cffffffff
-	TEXT_TAG_HYPERLINK_START, // |H
-	TEXT_TAG_HYPERLINK_END, // |h ex) |Hitem:1234:1:1:1|h
-	TEXT_TAG_RESTORE_COLOR,
-};
-
-int GetTextTag(const char* src, int maxLen, int& tagLen, std::string& extraInfo)
-{
-	tagLen = 1;
-
-	if (maxLen < 2 || *src != '|')
-		return TEXT_TAG_PLAIN;
-
-	const char* cur = ++src;
-
-	if (*cur == '|') // ||는 |로 표시한다.
-	{
-		tagLen = 2;
-		return TEXT_TAG_TAG;
-	}
-	else if (*cur == 'c') // color |cffffffffblahblah|r
-	{
-		tagLen = 2;
-		return TEXT_TAG_COLOR;
-	}
-	else if (*cur == 'H') // hyperlink |Hitem:10000:0:0:0:0|h[이름]|h
-	{
-		tagLen = 2;
-		return TEXT_TAG_HYPERLINK_START;
-	}
-	else if (*cur == 'h') // end of hyperlink
-	{
-		tagLen = 2;
-		return TEXT_TAG_HYPERLINK_END;
-	}
-
-	return TEXT_TAG_PLAIN;
-}
-
-void GetTextTagInfo(const char* src, int src_len, int& hyperlinks, bool& colored)
-{
-	colored = false;
-	hyperlinks = 0;
-
-	int len;
-	std::string extraInfo;
-
-	for (int i = 0; i < src_len;)
-	{
-		int tag = GetTextTag(&src[i], src_len - i, len, extraInfo);
-
-		if (tag == TEXT_TAG_HYPERLINK_START)
-			++hyperlinks;
-
-		if (tag == TEXT_TAG_COLOR)
-			colored = true;
-
-		i += len;
-	}
-}
-
-int ProcessTextTag(LPCHARACTER ch, const char* c_pszText, size_t len)
-{
-	// 20120517 김용욱
-	// 0 : 정상적으로 사용
-	// 1 : 금강경 부족
-	// 2 : 금강경이 있으나, 개인상점에서 사용중
-	// 3 : 교환중
-	// 4 : 에러
-
-	int hyperlinks;
-	bool colored;
-
-	GetTextTagInfo(c_pszText, len, hyperlinks, colored);
-
-	if (colored == true && hyperlinks == 0)
-		return 4;
-
-	if (ch->GetExchange())
-	{
-		if (hyperlinks == 0)
-			return 0;
-		else
-			return 3;
-	}
-
-	int nPrismCount = ch->CountSpecifyItem(ITEM_PRISM);
-
-	if (nPrismCount < hyperlinks)
-		return 1;
-
-	if (!ch->GetMyShop())
-	{
-		ch->RemoveSpecifyItem(ITEM_PRISM, hyperlinks);
-		return 0;
-	}
-	else
-	{
-		int sellingNumber = ch->GetMyShop()->GetNumberByVnum(ITEM_PRISM);
-		if (nPrismCount - sellingNumber < hyperlinks)
-		{
-			return 2;
-		}
-		else
-		{
-			ch->RemoveSpecifyItem(ITEM_PRISM, hyperlinks);
-			return 0;
-		}
-	}
-
-	return 4;
-}
-
-int CInputMain::Whisper(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	const TPacketCGWhisper* pinfo = reinterpret_cast<const TPacketCGWhisper*>(data);
-
-	if (uiBytes < pinfo->wSize)
-		return -1;
-
-	int iExtraLen = pinfo->wSize - sizeof(TPacketCGWhisper);
-
-	if (iExtraLen < 0)
-	{
-		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->wSize, uiBytes);
-		ch->GetDesc()->SetPhase(PHASE_CLOSE);
-		return -1;
-	}
-
-	ch->IncreaseWhisperCounter();
-	if (ch->GetWhisperCounter() == 10 && !ch->IsGM())
-	{
-		sys_log(0, "WHISPER_HACK: %s", ch->GetName());
-		//ch->GetDesc()->DelayedDisconnect(5);
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Please do not spam the chat."));
-		ch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, 10, 0, true);
-
-		return iExtraLen;
-	}
-
-	if (ch->FindAffect(AFFECT_BLOCK_CHAT))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("채팅 금지 상태입니다."));
-		return (iExtraLen);
-	}
-
-	LPCHARACTER pkChr = CHARACTER_MANAGER::instance().FindPC(pinfo->szNameTo);
-
-	if (pkChr == ch && !test_server)
-		return iExtraLen;
-
-	LPDESC pkDesc = NULL;
-	BYTE bOpponentEmpire = 0;
-	DWORD dwOpponentPID = 0;
-
-	if (test_server)
-	{
-		if (!pkChr)
-			sys_log(0, "Whisper to %s(%s) from %s", "Null", pinfo->szNameTo, ch->GetName());
-		else
-			sys_log(0, "Whisper to %s(%s) from %s", pkChr->GetName(), pinfo->szNameTo, ch->GetName());
-	}
-
-	if (ch->IsBlockMode(BLOCK_WHISPER))
-	{
-		if (ch->GetDesc())
-		{
-			TPacketGCWhisper pack;
-			pack.bHeader = HEADER_GC_WHISPER;
-			pack.bType = WHISPER_TYPE_SENDER_BLOCKED;
-			pack.wSize = sizeof(TPacketGCWhisper);
-			strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-			ch->GetDesc()->Packet(&pack, sizeof(pack));
-		}
-		return iExtraLen;
-	}
-
-	if (!pkChr)
-	{
-		CCI* pkCCI = P2P_MANAGER::instance().Find(pinfo->szNameTo);
-
-		if (pkCCI)
-		{
-			pkDesc = pkCCI->pkDesc;
-			pkDesc->SetRelay(pinfo->szNameTo);
-			bOpponentEmpire = pkCCI->bEmpire;
-			dwOpponentPID = pkCCI->dwPID;
-
-			if (test_server)
-				sys_log(0, "Whisper to %s from %s (Channel %d Mapindex %d)", "Null", ch->GetName(), pkCCI->bChannel, pkCCI->lMapIndex);
-		}
-	}
-	else
-	{
-		pkDesc = pkChr->GetDesc();
-		bOpponentEmpire = pkChr->GetEmpire();
-		dwOpponentPID = pkChr->GetPlayerID();
-	}
-
-	if (!pkDesc)
-	{
-		if (ch->GetDesc())
-		{
-			TPacketGCWhisper pack;
-
-			pack.bHeader = HEADER_GC_WHISPER;
-			pack.bType = WHISPER_TYPE_NOT_EXIST;
-			pack.wSize = sizeof(TPacketGCWhisper);
-			strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-
-			ch->GetDesc()->Packet(&pack, sizeof(TPacketGCWhisper));
-			sys_log(0, "WHISPER: no player");
-		}
-	}
-	else
-	{
-		if (ch->IsBlockMode(BLOCK_WHISPER))
-		{
-			if (ch->GetDesc())
-			{
-				TPacketGCWhisper pack;
-				pack.bHeader = HEADER_GC_WHISPER;
-				pack.bType = WHISPER_TYPE_SENDER_BLOCKED;
-				pack.wSize = sizeof(TPacketGCWhisper);
-				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-				ch->GetDesc()->Packet(&pack, sizeof(pack));
-			}
-		}
-		else if (pkChr && pkChr->IsBlockMode(BLOCK_WHISPER))
-		{
-			if (ch->GetDesc())
-			{
-				TPacketGCWhisper pack;
-				pack.bHeader = HEADER_GC_WHISPER;
-				pack.bType = WHISPER_TYPE_TARGET_BLOCKED;
-				pack.wSize = sizeof(TPacketGCWhisper);
-				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-				ch->GetDesc()->Packet(&pack, sizeof(pack));
-			}
-		}
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		else if (pkDesc && CMessengerManager::instance().IsBlocked(ch->GetName(), pinfo->szNameTo))
-		{
-			if (ch->GetDesc())
-			{
-				TPacketGCWhisper pack;
-
-				char msg[CHAT_MAX_LEN + 1];
-				snprintf(msg, sizeof(msg), LC_STRING("Unblock %s to continue.", pinfo->szNameTo));
-				int len = MIN(CHAT_MAX_LEN, strlen(msg) + 1);
-
-				pack.bHeader = HEADER_GC_WHISPER;
-				pack.wSize = sizeof(TPacketGCWhisper) + len;
-				pack.bType = WHISPER_TYPE_SYSTEM;
-				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-
-				TEMP_BUFFER buf;
-
-				buf.write(&pack, sizeof(TPacketGCWhisper));
-				buf.write(msg, len);
-				ch->GetDesc()->Packet(buf.read_peek(), buf.size());
-
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", pinfo->szNameTo));
-			}
-		}
-		else if (pkDesc && CMessengerManager::instance().IsBlocked(pinfo->szNameTo, ch->GetName()))
-		{
-			if (ch->GetDesc())
-			{
-				TPacketGCWhisper pack;
-
-				char msg[CHAT_MAX_LEN + 1];
-				snprintf(msg, sizeof(msg), LC_STRING("%s has blocked you.", pinfo->szNameTo));
-				int len = MIN(CHAT_MAX_LEN, strlen(msg) + 1);
-
-				pack.bHeader = HEADER_GC_WHISPER;
-				pack.wSize = sizeof(TPacketGCWhisper) + len;
-				pack.bType = WHISPER_TYPE_SYSTEM;
-				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-
-				TEMP_BUFFER buf;
-
-				buf.write(&pack, sizeof(TPacketGCWhisper));
-				buf.write(msg, len);
-				ch->GetDesc()->Packet(buf.read_peek(), buf.size());
-
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", pinfo->szNameTo));
-			}
-		}
-#endif
-		else
-		{
-			BYTE bType = WHISPER_TYPE_NORMAL;
-
-			char buf[CHAT_MAX_LEN + 1];
-			strlcpy(buf, data + sizeof(TPacketCGWhisper), MIN(iExtraLen + 1, sizeof(buf)));
-			const size_t buflen = strlen(buf);
-
-			//if (true == SpamBlockCheck(ch, buf, buflen))
-			//{
-			//	if (!pkChr)
-			//	{
-			//		CCI* pkCCI = P2P_MANAGER::instance().Find(pinfo->szNameTo);
-			//
-			//		if (pkCCI)
-			//		{
-			//			pkDesc->SetRelay("");
-			//		}
-			//	}
-			//	return iExtraLen;
-			//}
-
-			//if (LC_IsCanada() == false)
-			//{
-			//	CBanwordManager::instance().ConvertString(buf, buflen);
-			//}
-
-			if (!g_bEmpireWhisper)
-			{
-				if (!ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
-				{
-					if (!(pkChr && pkChr->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)))
-					{
-						if (bOpponentEmpire != ch->GetEmpire() && ch->GetEmpire() && bOpponentEmpire // 서로 제국이 다르면서
-							&& ch->GetGMLevel() == GM_PLAYER && gm_get_level(pinfo->szNameTo) == GM_PLAYER) // 둘다 일반 플레이어이면
-							// 이름 밖에 모르니 gm_get_level 함수를 사용
-						{
-							if (!pkChr)
-							{
-								// 다른 서버에 있으니 제국 표시만 한다. bType의 상위 4비트를 Empire번호로 사용한다.
-								bType = ch->GetEmpire() << 4;
-							}
-							else
-							{
-								ConvertEmpireText(ch->GetEmpire(), buf, buflen, 10 + 2 * pkChr->GetSkillPower(SKILL_LANGUAGE1 + ch->GetEmpire() - 1) /* 변환확률 */);
-							}
-						}
-					}
-				}
-			}
-
-			if (!g_bDisableGlassInsight)
-			{
-				int processReturn = ProcessTextTag(ch, buf, buflen);
-				if (processReturn != 0)
-				{
-					if (ch->GetDesc())
-					{
-						TItemTable* pTable = ITEM_MANAGER::instance().GetTable(ITEM_PRISM);
-
-						if (pTable)
-						{
-							char buf[128];
-							int len;
-							if (processReturn == 3) // 교환중
-								len = snprintf(buf, sizeof(buf), LC_STRING("다른 거래중(창고,교환,상점)에는 개인상점을 사용할 수 없습니다."));
-							else
-							{
-								len = snprintf(buf, sizeof(buf), LC_STRING("%s 아이템이 필요합니다", LC_ITEM(pTable->dwVnum)));
-							}
-
-							if (len < 0 || len >= (int)sizeof(buf))
-								len = sizeof(buf) - 1;
-
-							++len; // \0 문자 포함
-
-							TPacketGCWhisper pack;
-
-							pack.bHeader = HEADER_GC_WHISPER;
-							pack.bType = WHISPER_TYPE_ERROR;
-							pack.wSize = sizeof(TPacketGCWhisper) + len;
-							strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-
-							ch->GetDesc()->BufferedPacket(&pack, sizeof(pack));
-							ch->GetDesc()->Packet(buf, len);
-
-							sys_log(0, "WHISPER: not enough %s: char: %s", pTable->szLocaleName, ch->GetName());
-						}
-					}
-
-					// 릴래이 상태일 수 있으므로 릴래이를 풀어준다.
-					pkDesc->SetRelay("");
-					return (iExtraLen);
-				}
-			}
-
-			if (ch->IsGM())
-				bType = (bType & 0xF0) | WHISPER_TYPE_GM;
-
-			if (buflen > 0)
-			{
-				TPacketGCWhisper pack;
-
-				pack.bHeader = HEADER_GC_WHISPER;
-				pack.wSize = sizeof(TPacketGCWhisper) + buflen;
-				pack.bType = bType;
-				strlcpy(pack.szNameFrom, ch->GetName(), sizeof(pack.szNameFrom));
-#if defined(__LOCALE_CLIENT__)
-				pack.bCanFormat = false;
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-				strlcpy(pack.szCountry, ch->GetCountry(), sizeof(pack.szCountry));
-#endif
-
-				// desc->BufferedPacket을 하지 않고 버퍼에 써야하는 이유는 
-				// P2P relay되어 패킷이 캡슐화 될 수 있기 때문이다.
-				TEMP_BUFFER tmpbuf;
-
-				tmpbuf.write(&pack, sizeof(pack));
-				tmpbuf.write(buf, buflen);
-
-				pkDesc->Packet(tmpbuf.read_peek(), tmpbuf.size());
-
-				if (test_server)
-					sys_log(0, "WHISPER: %s -> %s : %s", ch->GetName(), pinfo->szNameTo, buf);
-
-				if (g_bWhisperLog)
-					LogManager::instance().WhisperLog(ch->GetPlayerID(), dwOpponentPID, buf);
-			}
-		}
-	}
-	if (pkDesc)
-		pkDesc->SetRelay("");
-
-	return (iExtraLen);
-}
-
-struct RawPacketToCharacterFunc
-{
-	const void* m_buf;
-	int m_buf_len;
-
-	RawPacketToCharacterFunc(const void* buf, int buf_len) : m_buf(buf), m_buf_len(buf_len)
-	{
-	}
-
-	void operator () (LPCHARACTER c)
-	{
-		if (!c->GetDesc())
-			return;
-
-		c->GetDesc()->Packet(m_buf, m_buf_len);
-	}
-};
-
-struct FEmpireChatPacket
-{
-	packet_chat& p;
-	const char* orig_msg;
-	int orig_len;
-	char converted_msg[CHAT_MAX_LEN + 1];
-
-	BYTE bEmpire;
-	int iMapIndex;
-	int namelen;
-
-	FEmpireChatPacket(packet_chat& p, const char* chat_msg, int len, BYTE bEmpire, int iMapIndex, int iNameLen)
-		: p(p), orig_msg(chat_msg), orig_len(len), bEmpire(bEmpire), iMapIndex(iMapIndex), namelen(iNameLen)
-	{
-		memset(converted_msg, 0, sizeof(converted_msg));
-	}
-
-	void operator () (LPDESC d)
-	{
-		if (!d->GetCharacter())
-			return;
-
-		if (d->GetCharacter()->GetMapIndex() != iMapIndex)
-			return;
-
-		d->BufferedPacket(&p, sizeof(packet_chat));
-
-		if (d->GetEmpire() == bEmpire ||
-			bEmpire == 0 ||
-			d->GetCharacter()->GetGMLevel() > GM_PLAYER ||
-			d->GetCharacter()->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
-		{
-			d->Packet(orig_msg, orig_len);
-		}
-		else
-		{
-			// 사람마다 스킬레벨이 다르니 매번 해야합니다
-			size_t len = strlcpy(converted_msg, orig_msg, sizeof(converted_msg));
-
-			if (len >= sizeof(converted_msg))
-				len = sizeof(converted_msg) - 1;
-
-			ConvertEmpireText(bEmpire, converted_msg + namelen, len - namelen, 10 + 2 * d->GetCharacter()->GetSkillPower(SKILL_LANGUAGE1 + bEmpire - 1));
-			d->Packet(converted_msg, orig_len);
-		}
-	}
-};
-
-struct FYmirChatPacket
-{
-	packet_chat& packet;
-	const char* m_szChat;
-	size_t m_lenChat;
-	const char* m_szName;
-
-	int m_iMapIndex;
-	BYTE m_bEmpire;
-	bool m_ring;
-
-	char m_orig_msg[CHAT_MAX_LEN + 1];
-	int m_len_orig_msg;
-	char m_conv_msg[CHAT_MAX_LEN + 1];
-	int m_len_conv_msg;
-
-	FYmirChatPacket(packet_chat& p, const char* chat, size_t len_chat, const char* name, size_t len_name, int iMapIndex, BYTE empire, bool ring)
-		: packet(p),
-		m_szChat(chat), m_lenChat(len_chat),
-		m_szName(name),
-		m_iMapIndex(iMapIndex), m_bEmpire(empire),
-		m_ring(ring)
-	{
-		m_len_orig_msg = snprintf(m_orig_msg, sizeof(m_orig_msg), "%s : %s", m_szName, m_szChat) + 1; // 널 문자 포함
-
-		if (m_len_orig_msg < 0 || m_len_orig_msg >= (int)sizeof(m_orig_msg))
-			m_len_orig_msg = sizeof(m_orig_msg) - 1;
-
-		m_len_conv_msg = snprintf(m_conv_msg, sizeof(m_conv_msg), "??? : %s", m_szChat) + 1; // 널 문자 미포함
-
-		if (m_len_conv_msg < 0 || m_len_conv_msg >= (int)sizeof(m_conv_msg))
-			m_len_conv_msg = sizeof(m_conv_msg) - 1;
-
-		ConvertEmpireText(m_bEmpire, m_conv_msg + 6, m_len_conv_msg - 6, 10); // 6은 "??? : "의 길이
-	}
-
-	void operator() (LPDESC d)
-	{
-		if (!d->GetCharacter())
-			return;
-
-		if (d->GetCharacter()->GetMapIndex() != m_iMapIndex)
-			return;
-
-		if (m_ring ||
-			d->GetEmpire() == m_bEmpire ||
-			d->GetCharacter()->GetGMLevel() > GM_PLAYER ||
-			d->GetCharacter()->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
-		{
-			packet.size = m_len_orig_msg + sizeof(TPacketGCChat);
-
-			d->BufferedPacket(&packet, sizeof(packet_chat));
-			d->Packet(m_orig_msg, m_len_orig_msg);
-		}
-		else
-		{
-			packet.size = m_len_conv_msg + sizeof(TPacketGCChat);
-
-			d->BufferedPacket(&packet, sizeof(packet_chat));
-			d->Packet(m_conv_msg, m_len_conv_msg);
-		}
-	}
-};
-
-int CInputMain::Chat(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	const TPacketCGChat* pinfo = reinterpret_cast<const TPacketCGChat*>(data);
-
-	if (uiBytes < pinfo->size)
-		return -1;
-
-	const int iExtraLen = pinfo->size - sizeof(TPacketCGChat);
-
-	if (iExtraLen < 0)
-	{
-		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->size, uiBytes);
-		ch->GetDesc()->SetPhase(PHASE_CLOSE);
-		return -1;
-	}
-
-	char buf[CHAT_MAX_LEN - (CHARACTER_NAME_MAX_LEN + 3) + 1];
-	strlcpy(buf, data + sizeof(TPacketCGChat), MIN(iExtraLen + 1, sizeof(buf)));
-	const size_t buflen = strlen(buf);
-
-	if (buflen > 1 && *buf == '/')
-	{
-		// NOTE : Block players from accessing the command interpreter
-		// through normal chat. (CHAT_TYPE_TALKING) 20230607.Owsap
-		if (!ch->IsGM() && pinfo->type == CHAT_TYPE_TALKING)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("그런 명령어는 없습니다"));
-			return iExtraLen;
-		}
-
-		interpret_command(ch, buf + 1, buflen - 1);
-		return iExtraLen;
-	}
-
-	ch->IncreaseChatCounter();
-	if (ch->GetChatCounter() == 10 && !ch->IsGM())
-	{
-		sys_log(0, "CHAT_HACK: %s", ch->GetName());
-		//ch->GetDesc()->DelayedDisconnect(5);
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Please do not spam the chat."));
-		ch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, 10, 0, true);
-
-		return iExtraLen;
-	}
-
-	// 채팅 금지 Affect 처리
-	const CAffect* pAffect = ch->FindAffect(AFFECT_BLOCK_CHAT);
-
-	if (pAffect != NULL)
-	{
-		SendBlockChatInfo(ch, pAffect->lDuration);
-		return iExtraLen;
-	}
-
-	if (SpamBlockCheck(ch, buf, buflen))
-		return iExtraLen;
-
-	if (CHAT_TYPE_SHOUT == pinfo->type && g_bDisableShout && !ch->IsGM())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The shout is disabled."));
-		return iExtraLen;
-	}
-
-	char chatbuf[CHAT_MAX_LEN + 1];
-	int len = snprintf(chatbuf, sizeof(chatbuf), "%s : %s", ch->GetName(), buf);
-
-	if (CHAT_TYPE_SHOUT == pinfo->type)
-	{
-		LogManager::instance().ShoutLog(g_bChannel, ch->GetEmpire(), chatbuf);
-	}
-
-	CBanwordManager::instance().ConvertString(buf, buflen);
-
-	if (len < 0 || len >= (int)sizeof(chatbuf))
-		len = sizeof(chatbuf) - 1;
-
-	if (!g_bDisableGlassInsight)
-	{
-		int processReturn = ProcessTextTag(ch, chatbuf, len);
-		if (processReturn != 0)
-		{
-			const TItemTable* pTable = ITEM_MANAGER::instance().GetTable(ITEM_PRISM);
-
-			if (NULL != pTable)
-			{
-				if (3 == processReturn) //교환중
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 거래중(창고,교환,상점)에는 개인상점을 사용할 수 없습니다."));
-				else
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 아이템이 필요합니다", LC_ITEM(pTable->dwVnum)));
-				}
-			}
-
-			return iExtraLen;
-		}
-	}
-
-	if (pinfo->type == CHAT_TYPE_SHOUT)
-	{
-		const int SHOUT_LIMIT_LEVEL = g_iUseLocale ? 15 : 3;
-
-		if (ch->GetLevel() < SHOUT_LIMIT_LEVEL)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("외치기는 레벨 %d 이상만 사용 가능 합니다.", SHOUT_LIMIT_LEVEL));
-			return (iExtraLen);
-		}
-
-		if (thecore_heart->pulse - (int)ch->GetLastShoutPulse() < passes_per_sec * 15 && !ch->IsGM())
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can only call every 15 seconds."));
-			return (iExtraLen);
-		}
-
-		ch->SetLastShoutPulse(thecore_heart->pulse);
-
-		TPacketGGShout p;
-		p.bHeader = HEADER_GG_SHOUT;
-		p.bEmpire = ch->GetEmpire();
-		strlcpy(p.szText, chatbuf, sizeof(p.szText));
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		strlcpy(p.szName, ch->GetName(), sizeof(p.szName));
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		strlcpy(p.szCountry, ch->GetCountry(), sizeof(p.szCountry));
-#endif
-
-		P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGShout));
-
-		SendShout(chatbuf, ch->GetEmpire()
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-			, ch->GetName()
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			, ch->GetCountry()
-#endif
-		);
-
-		return (iExtraLen);
-	}
-
-	TPacketGCChat pack_chat;
-	pack_chat.header = HEADER_GC_CHAT;
-	pack_chat.size = sizeof(TPacketGCChat) + len;
-	pack_chat.type = pinfo->type;
-	pack_chat.id = ch->GetVID();
-#if defined(__LOCALE_CLIENT__)
-	pack_chat.bCanFormat = false;
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	strlcpy(pack_chat.szCountry, ch->GetCountry(), sizeof(pack_chat.szCountry));
-#endif
-
-	switch (pinfo->type)
-	{
-		case CHAT_TYPE_TALKING:
-		{
-			const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
-
-			if (false)
-			{
-				std::for_each(c_ref_set.begin(), c_ref_set.end(),
-					FYmirChatPacket(pack_chat,
-						buf,
-						strlen(buf),
-						ch->GetName(),
-						strlen(ch->GetName()),
-						ch->GetMapIndex(),
-						ch->GetEmpire(),
-						ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)));
-			}
-			else
-			{
-				std::for_each(c_ref_set.begin(), c_ref_set.end(),
-					FEmpireChatPacket(pack_chat,
-						chatbuf,
-						len,
-						(ch->GetGMLevel() > GM_PLAYER ||
-							ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)) ? 0 : ch->GetEmpire(),
-						ch->GetMapIndex(), strlen(ch->GetName())));
-			}
-		}
-		break;
-
-		case CHAT_TYPE_PARTY:
-		{
-			if (!ch->GetParty())
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("파티 중이 아닙니다."));
-			else
-			{
-				TEMP_BUFFER tbuf;
-
-				tbuf.write(&pack_chat, sizeof(pack_chat));
-				tbuf.write(chatbuf, len);
-
-				RawPacketToCharacterFunc f(tbuf.read_peek(), tbuf.size());
-				ch->GetParty()->ForEachOnlineMember(f);
-			}
-		}
-		break;
-
-		case CHAT_TYPE_GUILD:
-		{
-			if (!ch->GetGuild())
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("길드에 가입하지 않았습니다."));
-			else
-				ch->GetGuild()->Chat(chatbuf);
-		}
-		break;
-
-		default:
-			sys_err("Unknown chat type %d", pinfo->type);
-			break;
-	}
-
-	return (iExtraLen);
-}
-
-void CInputMain::ItemUse(LPCHARACTER ch, const char* data)
-{
-	ch->UseItem(((struct command_item_use*)data)->Cell);
-}
-
-void CInputMain::ItemToItem(LPCHARACTER ch, const char* pcData)
-{
-	TPacketCGItemUseToItem* p = (TPacketCGItemUseToItem*)pcData;
-	if (ch)
-		ch->UseItem(p->Cell, p->TargetCell);
-}
-
-void CInputMain::ItemDrop(LPCHARACTER ch, const char* data)
-{
-	struct command_item_drop* pinfo = (struct command_item_drop*)data;
-
-	// MONARCH_LIMIT
-	//if (ch->IsMonarch())
-	//	return;
-	// END_MONARCH_LIMIT
-	if (!ch)
-		return;
-
-	// 엘크가 0보다 크면 엘크를 버리는 것 이다.
-	if (pinfo->gold > 0)
-		ch->DropGold(pinfo->gold);
-#if defined(__CHEQUE_SYSTEM__)
-	else if (pinfo->cheque > 0)
-		ch->DropCheque(pinfo->cheque);
-#endif
-	else
-		ch->DropItem(pinfo->Cell);
-}
-
-void CInputMain::ItemDrop2(LPCHARACTER ch, const char* data)
-{
-	// MONARCH_LIMIT
-	//if (ch->IsMonarch())
-	//	return;
-	// END_MONARCH_LIMIT
-
-	TPacketCGItemDrop2* pinfo = (TPacketCGItemDrop2*)data;
-
-	// 엘크가 0보다 크면 엘크를 버리는 것 이다.
-
-	if (!ch)
-		return;
-	if (pinfo->gold > 0)
-		ch->DropGold(pinfo->gold);
-#if defined(__CHEQUE_SYSTEM__)
-	else if (pinfo->cheque > 0)
-		ch->DropCheque(pinfo->cheque);
-#endif
-	else
-		ch->DropItem(pinfo->Cell, pinfo->count);
-}
-
-#if defined(__NEW_DROP_DIALOG__)
-void CInputMain::ItemDestroy(LPCHARACTER ch, const char* data)
-{
-	struct command_item_destroy* pinfo = (struct command_item_destroy*)data;
-	if (ch)
-		ch->DestroyItem(pinfo->Cell);
-}
-#endif
-
-void CInputMain::ItemMove(LPCHARACTER ch, const char* data)
-{
-	struct command_item_move* pinfo = (struct command_item_move*)data;
-
-	if (ch)
-		ch->MoveItem(pinfo->Cell, pinfo->CellTo, pinfo->count);
-}
-
-void CInputMain::ItemPickup(LPCHARACTER ch, const char* data)
-{
-	struct command_item_pickup* pinfo = (struct command_item_pickup*)data;
-	if (ch)
-		ch->PickupItem(pinfo->vid);
-}
-
-void CInputMain::QuickslotAdd(LPCHARACTER ch, const char* data)
-{
-	struct command_quickslot_add* pinfo = (struct command_quickslot_add*)data;
-	ch->SetQuickslot(pinfo->pos, pinfo->slot);
-}
-
-void CInputMain::QuickslotDelete(LPCHARACTER ch, const char* data)
-{
-	struct command_quickslot_del* pinfo = (struct command_quickslot_del*)data;
-	ch->DelQuickslot(pinfo->pos);
-}
-
-void CInputMain::QuickslotSwap(LPCHARACTER ch, const char* data)
-{
-	struct command_quickslot_swap* pinfo = (struct command_quickslot_swap*)data;
-	ch->SwapQuickslot(pinfo->pos, pinfo->change_pos);
-}
-
-int CInputMain::Messenger(const LPCHARACTER c_lpChar, const char* c_pData, std::size_t uiBytes)
-{
-	const TPacketCGMessenger* c_pPacket = reinterpret_cast<const TPacketCGMessenger*>(c_pData);
-	if (uiBytes < sizeof(TPacketCGMessenger))
-		return -1;
-
-	c_pData += sizeof(TPacketCGMessenger);
-	uiBytes -= sizeof(TPacketCGMessenger);
-
-	switch (c_pPacket->bSubHeader)
-	{
-		case MESSENGER_SUBHEADER_CG_ADD_BY_VID:
-		{
-			if (uiBytes < sizeof(TPacketCGMessengerAddByVID))
-				return -1;
-
-			const TPacketCGMessengerAddByVID* c_pAddByVIDPacket = reinterpret_cast<const TPacketCGMessengerAddByVID*>(c_pData);
-			const LPCHARACTER c_lpCharCompanion = CHARACTER_MANAGER::instance().Find(c_pAddByVIDPacket->dwVID);
-
-			if (c_lpCharCompanion == nullptr)
-				return sizeof(TPacketCGMessengerAddByVID);
-
-			if (c_lpCharCompanion->IsObserverMode())
-				return sizeof(TPacketCGMessengerAddByVID);
-
-			if (c_lpCharCompanion->IsBlockMode(BLOCK_MESSENGER_INVITE))
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 메신져 추가 거부 상태입니다."));
-				return sizeof(TPacketCGMessengerAddByVID);
-			}
-
-			const LPDESC c_lpCompanionDesc = c_lpCharCompanion->GetDesc();
-			if (c_lpCompanionDesc == nullptr)
-				return sizeof(TPacketCGMessengerAddByVID);
-
-			if (c_lpChar->GetGMLevel() == GM_PLAYER && c_lpCharCompanion->GetGMLevel() != GM_PLAYER)
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<메신져> 운영자는 메신져에 추가할 수 없습니다."));
-				return sizeof(TPacketCGMessengerAddByVID);
-			}
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", c_lpCharCompanion->GetName()));
-				return sizeof(TPacketCGMessengerAddByVID);
-			}
-			else if (CMessengerManager::instance().IsBlocked(c_lpCharCompanion->GetName(), c_lpChar->GetName()))
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", c_lpCharCompanion->GetName()));
-				return sizeof(TPacketCGMessengerAddByVID);
-			}
-#endif
-
-			if (c_lpChar->GetDesc() == c_lpCompanionDesc) // 자신은 추가할 수 없다.
-				return sizeof(TPacketCGMessengerAddByVID);
-
-			CMessengerManager::instance().RequestToAdd(c_lpChar, c_lpCharCompanion);
-			//CMessengerManager::instance().AddToList(c_lpChar->GetName(), c_lpCharCompanion->GetName());
-		}
-		return sizeof(TPacketCGMessengerAddByVID);
-
-		case MESSENGER_SUBHEADER_CG_ADD_BY_NAME:
-		{
-			if (uiBytes < CHARACTER_NAME_MAX_LEN)
-				return -1;
-
-			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
-			strlcpy(szName, c_pData, sizeof(szName));
-
-			if (c_lpChar->GetGMLevel() == GM_PLAYER && gm_get_level(szName) != GM_PLAYER)
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<메신져> 운영자는 메신져에 추가할 수 없습니다."));
-				return CHARACTER_NAME_MAX_LEN;
-			}
-
-			const LPCHARACTER c_lpCharTarget = CHARACTER_MANAGER::instance().FindPC(szName);
-			if (c_lpCharTarget == nullptr)
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 님은 접속되 있지 않습니다.", szName));
-			else
-			{
-				if (c_lpCharTarget == c_lpChar) // 자신은 추가할 수 없다.
-					return CHARACTER_NAME_MAX_LEN;
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharTarget->GetName()))
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", c_lpCharTarget->GetName()));
-					return CHARACTER_NAME_MAX_LEN;
-				}
-				else if (CMessengerManager::instance().IsBlocked(c_lpCharTarget->GetName(), c_lpChar->GetName()))
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", c_lpCharTarget->GetName()));
-					return CHARACTER_NAME_MAX_LEN;
-				}
-#endif
-
-				if (c_lpCharTarget->IsBlockMode(BLOCK_MESSENGER_INVITE) == true)
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상대방이 메신져 추가 거부 상태입니다."));
-				}
-				else
-				{
-					// 메신저가 캐릭터단위가 되면서 변경
-					CMessengerManager::instance().RequestToAdd(c_lpChar, c_lpCharTarget);
-					//CMessengerManager::instance().AddToList(c_lpChar->GetName(), c_lpCharTarget->GetName());
-				}
-			}
-		}
-		return CHARACTER_NAME_MAX_LEN;
-
-		case MESSENGER_SUBHEADER_CG_REMOVE:
-		{
-			if (uiBytes < CHARACTER_NAME_MAX_LEN)
-				return -1;
-
-			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
-			strlcpy(szName, c_pData, sizeof(szName));
-			CMessengerManager::instance().RemoveFromList(c_lpChar->GetName(), szName);
-		}
-		return CHARACTER_NAME_MAX_LEN;
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		case MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID:
-		{
-			if (uiBytes < sizeof(TPacketCGMessengerAddBlockByVID))
-				return -1;
-
-			const TPacketCGMessengerAddBlockByVID* c_pAddBlockByVIDPacket = reinterpret_cast<const TPacketCGMessengerAddBlockByVID*>(c_pData);
-			const LPCHARACTER c_lpCharCompanion = CHARACTER_MANAGER::instance().Find(c_pAddBlockByVIDPacket->dwVID);
-			if (c_lpCharCompanion == nullptr)
-				return sizeof(TPacketCGMessengerAddBlockByVID);
-
-			if (c_lpChar->IsObserverMode())
-				return sizeof(TPacketCGMessengerAddBlockByVID);
-
-			const LPDESC c_lpDescCompanion = c_lpCharCompanion->GetDesc();
-			if (c_lpDescCompanion == nullptr)
-				return sizeof(TPacketCGMessengerAddByVID);
-
-			const LPCHARACTER c_pPartner = c_lpChar->GetMarryPartner();
-			if (c_pPartner)
-			{
-				if (c_lpCharCompanion->GetName() == c_pPartner->GetName())
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block your spouse."));
-					return sizeof(TPacketCGMessengerAddBlockByVID);
-				}
-			}
-
-			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Remove %s from your friends list to continue.", c_lpCharCompanion->GetName()));
-				return sizeof(TPacketCGMessengerAddBlockByVID);
-			}
-
-			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is already being blocked.", c_lpCharCompanion->GetName()));
-				return sizeof(TPacketCGMessengerAddBlockByVID);
-			}
-
-			if (c_lpChar->GetGMLevel() == GM_PLAYER && c_lpCharCompanion->GetGMLevel() != GM_PLAYER && !test_server)
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block this player."));
-				return sizeof(TPacketCGMessengerAddByVID);
-			}
-
-			if (c_lpChar->GetDesc() == c_lpDescCompanion)
-				return sizeof(TPacketCGMessengerAddBlockByVID);
-
-			CMessengerManager::instance().AddToBlockList(c_lpChar->GetName(), c_lpCharCompanion->GetName());
-		}
-		return sizeof(TPacketCGMessengerAddBlockByVID);
-
-		case MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME:
-		{
-			if (uiBytes < CHARACTER_NAME_MAX_LEN)
-				return -1;
-
-			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
-			strlcpy(szName, c_pData, sizeof(szName));
-
-			if (gm_get_level(szName) != GM_PLAYER && !test_server)
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block this player."));
-				return CHARACTER_NAME_MAX_LEN;
-			}
-
-			const LPCHARACTER c_lpCharTarget = CHARACTER_MANAGER::instance().FindPC(szName);
-			if (c_lpCharTarget == c_lpChar)
-				return CHARACTER_NAME_MAX_LEN;
-
-			LPDESC pDescTarget = nullptr;
-			if (c_lpCharTarget == nullptr)
-			{
-				const CCI* c_pCCI = P2P_MANAGER::instance().Find(szName);
-				if (c_pCCI)
-					pDescTarget = c_pCCI->pkDesc;
-			}
-			else
-				pDescTarget = c_lpCharTarget->GetDesc();
-
-			if (pDescTarget == nullptr)
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is not online.", szName));
-				return CHARACTER_NAME_MAX_LEN;
-			}
-			else
-			{
-				const LPCHARACTER c_pPartner = c_lpChar->GetMarryPartner();
-				if (c_pPartner)
-				{
-					if (c_pPartner->GetName() == szName)
-					{
-						c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block your spouse."));
-						return CHARACTER_NAME_MAX_LEN;
-					}
-				}
-
-				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Remove %s from your friends list to continue.", szName));
-					return CHARACTER_NAME_MAX_LEN;
-				}
-
-				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is already being blocked.", szName));
-					return CHARACTER_NAME_MAX_LEN;
-				}
-
-				CMessengerManager::instance().AddToBlockList(c_lpChar->GetName(), szName);
-			}
-		}
-		return CHARACTER_NAME_MAX_LEN;
-
-		case MESSENGER_SUBHEADER_CG_BLOCK_REMOVE:
-		{
-			if (uiBytes < CHARACTER_NAME_MAX_LEN)
-				return -1;
-
-			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
-			strlcpy(szName, c_pData, sizeof(szName));
-
-			if (!CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
-				return CHARACTER_NAME_MAX_LEN;
-
-			CMessengerManager::instance().RemoveFromBlockList(c_lpChar->GetName(), szName);
-		}
-		return CHARACTER_NAME_MAX_LEN;
-#endif
-
-		default:
-			sys_err("CInputMain::Messenger : Unknown subheader %d : %s", c_pPacket->bSubHeader, c_lpChar->GetName());
-			break;
-	}
-
-	return 0;
-}
-
-int CInputMain::Shop(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	TPacketCGShop* p = (TPacketCGShop*)data;
-
-	if (uiBytes < sizeof(TPacketCGShop))
-		return -1;
-
-	if (test_server)
-		sys_log(0, "CInputMain::Shop() ==> SubHeader %d", p->subheader);
-
-	const char* c_pData = data + sizeof(TPacketCGShop);
-	uiBytes -= sizeof(TPacketCGShop);
-
-	switch (p->subheader)
-	{
-		case SHOP_SUBHEADER_CG_END:
-			sys_log(1, "INPUT: %s SHOP: END", ch->GetName());
-			CShopManager::instance().StopShopping(ch);
-			return 0;
-
-		case SHOP_SUBHEADER_CG_BUY:
-		{
-			if (uiBytes < sizeof(BYTE) + sizeof(BYTE))
-				return -1;
-
-			BYTE bPos = *(c_pData + 1);
-			sys_log(1, "INPUT: %s SHOP: BUY %d", ch->GetName(), bPos);
-			CShopManager::instance().Buy(ch, bPos);
-			return (sizeof(BYTE) + sizeof(BYTE));
-		}
-
-		case SHOP_SUBHEADER_CG_SELL:
-		{
-			if (uiBytes < sizeof(BYTE))
-				return -1;
-
-			BYTE pos = *c_pData;
-
-			sys_log(0, "INPUT: %s SHOP: SELL", ch->GetName());
-			CShopManager::instance().Sell(ch, pos);
-			return sizeof(BYTE);
-		}
-
-		case SHOP_SUBHEADER_CG_SELL2:
-		{
-			const TPacketCGShopSell* p = reinterpret_cast<const TPacketCGShopSell*>(c_pData);
-
-			sys_log(0, "INPUT: %s SHOP: SELL2", ch->GetName());
-
-			CShopManager::instance().Sell(ch, p->wPos, p->wCount, p->bType);
-			return sizeof(TPacketCGShopSell);
-		}
-
-		default:
-			sys_err("CInputMain::Shop : Unknown subheader %d : %s", p->subheader, ch->GetName());
-			break;
-	}
-
-	return 0;
-}
-
-void CInputMain::OnClick(LPCHARACTER ch, const char* data)
-{
-	struct command_on_click* pinfo = (struct command_on_click*)data;
-	LPCHARACTER victim;
-
-	if ((victim = CHARACTER_MANAGER::instance().Find(pinfo->vid)))
-		victim->OnClick(ch);
-	else if (test_server)
-	{
-		sys_err("CInputMain::OnClick %s.Click.NOT_EXIST_VID[%d]", ch->GetName(), pinfo->vid);
-	}
-}
-
-void CInputMain::Exchange(LPCHARACTER ch, const char* data)
-{
-	struct command_exchange* pinfo = (struct command_exchange*)data;
-	LPCHARACTER to_ch = NULL;
-
-	if (!ch->CanHandleItem())
-		return;
-
-	int iPulse = thecore_pulse();
-
-	if ((to_ch = CHARACTER_MANAGER::instance().Find(pinfo->arg1)))
-	{
-		if (iPulse - to_ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-		{
-			to_ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("거래 후 %d초 이내에 창고를 열수 없습니다.", g_nPortalLimitTime));
-			return;
-		}
-
-		if (true == to_ch->IsDead())
-		{
-			return;
-		}
-	}
-
-	sys_log(0, "CInputMain()::Exchange() SubHeader %d ", pinfo->sub_header);
-
-	if (iPulse - ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("거래 후 %d초 이내에 창고를 열수 없습니다.", g_nPortalLimitTime));
-		return;
-	}
-
-	switch (pinfo->sub_header)
-	{
-		case EXCHANGE_SUBHEADER_CG_START: // arg1 == vid of target character
-			if (!ch->GetExchange())
-			{
-				if ((to_ch = CHARACTER_MANAGER::instance().Find(pinfo->arg1)))
-				{
-					//MONARCH_LIMIT
-					/*
-					if (to_ch->IsMonarch() || ch->IsMonarch())
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("군주와는 거래를 할수가 없습니다", g_nPortalLimitTime));
-						return;
-					}
-					//END_MONARCH_LIMIT
-					*/
-					if (iPulse - ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("창고를 연후 %d초 이내에는 거래를 할수 없습니다.", g_nPortalLimitTime));
-
-						if (test_server)
-							ch->ChatPacket(CHAT_TYPE_INFO, "[TestOnly][Safebox]Pulse %d LoadTime %d PASS %d", iPulse, ch->GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
-						return;
-					}
-
-					if (iPulse - to_ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-					{
-						to_ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("창고를 연후 %d초 이내에는 거래를 할수 없습니다.", g_nPortalLimitTime));
-
-						if (test_server)
-							to_ch->ChatPacket(CHAT_TYPE_INFO, "[TestOnly][Safebox]Pulse %d LoadTime %d PASS %d", iPulse, to_ch->GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
-						return;
-					}
-
-					if (ch->GetGold() >= GOLD_MAX)
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("액수가 20억 냥을 초과하여 거래를 할수가 없습니다.."));
-
-						sys_err("[OVERFLOG_GOLD] START (%d) id %u name %s ", ch->GetGold(), ch->GetPlayerID(), ch->GetName());
-						return;
-					}
-
-#if defined(__CHEQUE_SYSTEM__)
-					if (ch->GetCheque() > CHEQUE_MAX)
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("액수가 20억 냥을 초과하여 거래를 할수가 없습니다.."));
-
-						sys_err("[OVERFLOW_CHEQUE] START (%d) id %u name %s ", ch->GetCheque(), ch->GetPlayerID(), ch->GetName());
-						return;
-					}
-#endif
-
-					if (to_ch->IsPC())
-					{
-						if (quest::CQuestManager::instance().GiveItemToPC(ch->GetPlayerID(), to_ch))
-						{
-							sys_log(0, "Exchange canceled by quest %s %s", ch->GetName(), to_ch->GetName());
-							return;
-						}
-					}
-
-					if (ch->PreventTradeWindow(WND_EXCHANGE, true/*except*/))
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 거래중일경우 개인상점을 열수가 없습니다."));
-						return;
-					}
-
-					ch->ExchangeStart(to_ch);
-				}
-			}
-			break;
-
-		case EXCHANGE_SUBHEADER_CG_ITEM_ADD: // arg1 == position of item, arg2 == position in exchange window
-			if (ch->GetExchange())
-			{
-				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
-					ch->GetExchange()->AddItem(pinfo->Pos, pinfo->arg2);
-			}
-			break;
-
-		case EXCHANGE_SUBHEADER_CG_ITEM_DEL: // arg1 == position of item
-			if (ch->GetExchange())
-			{
-				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
-					ch->GetExchange()->RemoveItem(pinfo->arg1);
-			}
-			break;
-
-		case EXCHANGE_SUBHEADER_CG_ELK_ADD: // arg1 == amount of gold
-			if (ch->GetExchange())
-			{
-				const int64_t nTotalGold = static_cast<int64_t>(ch->GetExchange()->GetCompany()->GetOwner()->GetGold()) + static_cast<int64_t>(pinfo->arg1);
-				if (GOLD_MAX <= nTotalGold)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Yang."));
-
-					sys_err("[OVERFLOW_GOLD] ELK_ADD (%d) id %u name %s ",
-						ch->GetExchange()->GetCompany()->GetOwner()->GetGold(),
-						ch->GetExchange()->GetCompany()->GetOwner()->GetPlayerID(),
-						ch->GetExchange()->GetCompany()->GetOwner()->GetName());
-
-					return;
-				}
-
-				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
-					ch->GetExchange()->AddGold(pinfo->arg1);
-			}
-			break;
-
-#if defined(__CHEQUE_SYSTEM__)
-		case EXCHANGE_SUBHEADER_CG_CHEQUE_ADD: // arg1 == amount of cheque
-			if (ch->GetExchange())
-			{
-				const int64_t nTotalCheque = static_cast<int64_t>(ch->GetExchange()->GetCompany()->GetOwner()->GetCheque()) + static_cast<int64_t>(pinfo->arg1);
-
-				if (nTotalCheque > CHEQUE_MAX)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Won."));
-
-					sys_err("[OVERFLOW_CHEQUE] CHEQUE_ADD (%u) id %u name %s ",
-						ch->GetExchange()->GetCompany()->GetOwner()->GetCheque(),
-						ch->GetExchange()->GetCompany()->GetOwner()->GetPlayerID(),
-						ch->GetExchange()->GetCompany()->GetOwner()->GetName());
-
-					return;
-				}
-
-				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
-					ch->GetExchange()->AddCheque(pinfo->arg1);
-			}
-			break;
-#endif
-
-		case EXCHANGE_SUBHEADER_CG_ACCEPT: // arg1 == not used
-			if (ch->GetExchange())
-			{
-				sys_log(0, "CInputMain()::Exchange() ==> ACCEPT ");
-				ch->GetExchange()->Accept(true);
-			}
-			break;
-
-		case EXCHANGE_SUBHEADER_CG_CANCEL: // arg1 == not used
-			if (ch->GetExchange())
-				ch->GetExchange()->Cancel();
-			break;
-	}
-}
-
-void CInputMain::Position(LPCHARACTER ch, const char* data)
-{
-	struct command_position* pinfo = (struct command_position*)data;
-
-	switch (pinfo->position)
-	{
-		case POSITION_GENERAL:
-			ch->Standup();
-			break;
-
-		case POSITION_SITTING_CHAIR:
-			ch->Sitdown(0);
-			break;
-
-		case POSITION_SITTING_GROUND:
-			ch->Sitdown(1);
-			break;
-	}
-}
-
-static const int ComboSequenceBySkillLevel[3][8] =
-{
-	//	0	1	2	3	4	5	6	7
-	{	14,	15,	16,	17,	0,	0,	0,	0	},
-	{	14,	15,	16,	18,	20,	0,	0,	0	},
-	{	14,	15,	16,	18,	19,	17,	0,	0	},
-};
-
-#define COMBO_HACK_ALLOWABLE_MS 100
-
-bool CheckComboHack(LPCHARACTER ch, BYTE bArg, DWORD dwTime, bool CheckSpeedHack)
-{
-	if (!gHackCheckEnable)
-		return false;
-
-	// 죽거나 기절 상태에서는 공격할 수 없으므로, skip한다.
-	// 이렇게 하지 말고, CHRACTER::CanMove()에 
-	// if (IsStun() || IsDead()) return false;
-	// 를 추가하는게 맞다고 생각하나,
-	// 이미 다른 부분에서 CanMove()는 IsStun(), IsDead()과
-	// 독립적으로 체크하고 있기 때문에 수정에 의한 영향을
-	// 최소화하기 위해 이렇게 땜빵 코드를 써놓는다.
-	if (ch->IsStun() || ch->IsDead())
-		return false;
-	int ComboInterval = dwTime - ch->GetLastComboTime();
-	int HackScalar = 0; // 기본 스칼라 단위 1
-#if 0
-	sys_log(0, "COMBO: %s arg:%u seq:%u delta:%d checkspeedhack:%d",
-		ch->GetName(), bArg, ch->GetComboSequence(), ComboInterval - ch->GetValidComboInterval(), CheckSpeedHack);
-#endif
-	// bArg 14 ~ 21번 까지 총 8콤보 가능
-	// 1. 첫 콤보(14)는 일정 시간 이후에 반복 가능
-	// 2. 15 ~ 21번은 반복 불가능
-	// 3. 차례대로 증가한다.
-	if (bArg == 14)
-	{
-		if (CheckSpeedHack && ComboInterval > 0 && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
-		{
-			// FIXME 첫번째 콤보는 이상하게 빨리 올 수가 있어서 300으로 나눔 -_-;
-			// 다수의 몬스터에 의해 다운되는 상황에서 공격을 하면
-			// 첫번째 콤보가 매우 적은 인터벌로 들어오는 상황 발생.
-			// 이로 인해 콤보핵으로 튕기는 경우가 있어 다음 코드 비 활성화.
-			//HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 300;
-
-			//sys_log(0, "COMBO_HACK: 2 %s arg:%u interval:%d valid:%u atkspd:%u riding:%s",
-			//	ch->GetName(),
-			//	bArg,
-			//	ComboInterval,
-			//	ch->GetValidComboInterval(),
-			//	ch->GetPoint(POINT_ATT_SPEED),
-			//	ch->IsRiding() ? "yes" : "no"
-			//);
-		}
-
-		ch->SetComboSequence(1);
-		ch->SetValidComboInterval((int)(ani_combo_speed(ch, 1) / (ch->GetPoint(POINT_ATT_SPEED) / 100.f)));
-		ch->SetLastComboTime(dwTime);
-	}
-	else if (bArg > 14 && bArg < 22)
-	{
-		int idx = MIN(2, ch->GetComboIndex());
-
-		if (ch->GetComboSequence() > 5) // 현재 6콤보 이상은 없다.
-		{
-			HackScalar = 1;
-			ch->SetValidComboInterval(300);
-			sys_log(0, "COMBO_HACK: 5 %s combo_seq:%d", ch->GetName(), ch->GetComboSequence());
-		}
-		// 자객 쌍수 콤보 예외처리
-		else if (bArg == 21 &&
-			idx == 2 &&
-			ch->GetComboSequence() == 5 &&
-			ch->GetJob() == JOB_ASSASSIN &&
-			ch->GetWear(WEAR_WEAPON) &&
-			ch->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_DAGGER
-			)
-			ch->SetValidComboInterval(300);
-		else if (bArg == 21 &&
-			idx == 2 &&
-			ch->GetComboSequence() == 5 &&
-			ch->GetJob() == JOB_WOLFMAN &&
-			ch->GetWear(WEAR_WEAPON) &&
-			ch->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_CLAW
-			)
-			ch->SetValidComboInterval(300);
-		else if (ComboSequenceBySkillLevel[idx][ch->GetComboSequence()] != bArg)
-		{
-			HackScalar = 1;
-			ch->SetValidComboInterval(300);
-
-			sys_log(0, "COMBO_HACK: 3 %s arg:%u valid:%u combo_idx:%d combo_seq:%d",
-				ch->GetName(),
-				bArg,
-				ComboSequenceBySkillLevel[idx][ch->GetComboSequence()],
-				idx,
-				ch->GetComboSequence());
-		}
-		else
-		{
-			if (CheckSpeedHack && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
-			{
-				HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 100;
-
-				sys_log(0, "COMBO_HACK: 2 %s arg:%u interval:%d valid:%u atkspd:%u riding:%s",
-					ch->GetName(),
-					bArg,
-					ComboInterval,
-					ch->GetValidComboInterval(),
-					ch->GetPoint(POINT_ATT_SPEED),
-					ch->IsRiding() ? "yes" : "no");
-			}
-
-			// 말을 탔을 때는 15번 ~ 16번을 반복한다
-			//if (ch->IsHorseRiding())
-			if (ch->IsRiding())
-				ch->SetComboSequence(ch->GetComboSequence() == 1 ? 2 : 1);
-			else
-				ch->SetComboSequence(ch->GetComboSequence() + 1);
-
-			ch->SetValidComboInterval((int)(ani_combo_speed(ch, bArg - 13) / (ch->GetPoint(POINT_ATT_SPEED) / 100.f)));
-			ch->SetLastComboTime(dwTime);
-		}
-	}
-	else if (bArg == 13) // 기본 공격 (둔갑(Polymorph)했을 때 온다)
-	{
-		if (CheckSpeedHack && ComboInterval > 0 && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
-		{
-			// 다수의 몬스터에 의해 다운되는 상황에서 공격을 하면
-			// 첫번째 콤보가 매우 적은 인터벌로 들어오는 상황 발생.
-			// 이로 인해 콤보핵으로 튕기는 경우가 있어 다음 코드 비 활성화.
-			//HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 100;
-
-			//sys_log(0, "COMBO_HACK: 6 %s arg:%u interval:%d valid:%u atkspd:%u",
-			//	ch->GetName(),
-			//	bArg,
-			//	ComboInterval,
-			//	ch->GetValidComboInterval(),
-			//	ch->GetPoint(POINT_ATT_SPEED)
-			//);
-		}
-
-		if (ch->GetRaceNum() >= MAIN_RACE_MAX_NUM)
-		{
-			// POLYMORPH_BUG_FIX
-
-			// DELETEME
-			/*
-			const CMotion * pkMotion = CMotionManager::instance().GetMotion(ch->GetRaceNum(), MAKE_MOTION_KEY(MOTION_MODE_GENERAL, MOTION_NORMAL_ATTACK));
-
-			if (!pkMotion)
-				sys_err("cannot find motion by race %u", ch->GetRaceNum());
-			else
-			{
-				// 정상적 계산이라면 1000.f를 곱해야 하지만 클라이언트가 애니메이션 속도의 90%에서
-				// 다음 애니메이션 블렌딩을 허용하므로 900.f를 곱한다.
-				int k = (int) (pkMotion->GetDuration() / ((float) ch->GetPoint(POINT_ATT_SPEED) / 100.f) * 900.f);
-				ch->SetValidComboInterval(k);
-				ch->SetLastComboTime(dwTime);
-			}
-			*/
-			float normalAttackDuration = CMotionManager::instance().GetNormalAttackDuration(ch->GetRaceNum());
-			int k = (int)(normalAttackDuration / ((float)ch->GetPoint(POINT_ATT_SPEED) / 100.f) * 900.f);
-			ch->SetValidComboInterval(k);
-			ch->SetLastComboTime(dwTime);
-			// END_OF_POLYMORPH_BUG_FIX
-		}
-		else
-		{
-			// 말이 안되는 콤보가 왔다 해커일 가능성?
-			//if (ch->GetDesc()->DelayedDisconnect(number(2, 9)))
-			//{
-			//	LogManager::instance().HackLog("Hacker", ch);
-			//	sys_log(0, "HACKER: %s arg %u", ch->GetName(), bArg);
-			//}
-
-			// 위 코드로 인해, 폴리모프를 푸는 중에 공격 하면,
-			// 가끔 핵으로 인식하는 경우가 있다.
-
-			// 자세히 말혀면,
-			// 서버에서 poly 0를 처리했지만,
-			// 클라에서 그 패킷을 받기 전에, 몹을 공격. <- 즉, 몹인 상태에서 공격.
-			//
-			// 그러면 클라에서는 서버에 몹 상태로 공격했다는 커맨드를 보내고 (arg == 13)
-			//
-			// 서버에서는 race는 인간인데 공격형태는 몹인 놈이다! 라고 하여 핵체크를 했다.
-
-			// 사실 공격 패턴에 대한 것은 클라이언트에서 판단해서 보낼 것이 아니라,
-			// 서버에서 판단해야 할 것인데... 왜 이렇게 해놨을까...
-			// by rtsummit
-		}
-	}
-	else
-	{
-		// 말이 안되는 콤보가 왔다 해커일 가능성?
-		if (ch->GetDesc()->DelayedDisconnect(number(2, 9)))
-		{
-			LogManager::instance().HackLog("Hacker", ch);
-			sys_log(0, "HACKER: %s arg %u", ch->GetName(), bArg);
-		}
-
-		HackScalar = 10;
-		ch->SetValidComboInterval(300);
-	}
-
-	if (HackScalar)
-	{
-		// 말에 타거나 내렸을 때 1.5초간 공격은 핵으로 간주하지 않되 공격력은 없게 하는 처리
-		if (get_dword_time() - ch->GetLastMountTime() > 1500)
-			ch->IncreaseComboHackCount(1 + HackScalar);
-
-		ch->SkipComboAttackByTime(ch->GetValidComboInterval());
-	}
-
-	return HackScalar;
-}
-
-void CInputMain::Move(LPCHARACTER ch, const char* data)
-{
-	if (!ch->CanMove())
-		return;
-
-	struct command_move* pinfo = (struct command_move*)data;
-
-	if (pinfo->bFunc >= FUNC_MAX_NUM && !(pinfo->bFunc & 0x80))
-	{
-		sys_err("invalid move type: %s", ch->GetName());
-		return;
-	}
-
-	/*
-	enum EMoveFuncType
-	{
-		FUNC_WAIT,
-		FUNC_MOVE,
-		FUNC_ATTACK,
-		FUNC_COMBO,
-		FUNC_MOB_SKILL,
-		_FUNC_SKILL,
-		FUNC_MAX_NUM,
-		FUNC_SKILL = 0x80,
-	};
-	*/
-
-	// 텔레포트 핵 체크
-
-	//if (!test_server) // 20120515 김용욱 : 테섭에서 (무적상태로) 다수 몬스터 상대로 다운되면서 공격시 콤보핵으로 죽는 문제가 있었다.
-	{
-		const float fDist = DISTANCE_SQRT((ch->GetX() - pinfo->lX) / 100, (ch->GetY() - pinfo->lY) / 100);
-#ifdef MOUNT_FIX
-		if (((false == ch->IsRiding() && fDist > 750) || fDist > 999) && OXEVENT_MAP_INDEX != ch->GetMapIndex())
-#else
-		if (((false == ch->IsRiding() && fDist > 25) || fDist > 60) && OXEVENT_MAP_INDEX != ch->GetMapIndex())
-#endif
-		{
-			sys_log(0, "MOVE: %s trying to move too far (dist: %.1fm) Riding(%d)", ch->GetName(), fDist, ch->IsRiding());
-
-			ch->Show(ch->GetMapIndex(), ch->GetX(), ch->GetY(), ch->GetZ());
-			ch->Stop();
-			return;
-		}
-
-		//
-		// 스피드핵(SPEEDHACK) Check
-		//
-		int dwCurTime = get_dword_time();
-		// 시간을 Sync하고 7초 후 부터 검사한다. (20090702 이전엔 5초였음)
-		bool CheckSpeedHack = (false == ch->GetDesc()->IsHandshaking() && dwCurTime - ch->GetDesc()->GetClientTime() > 7000);
-
-		if (CheckSpeedHack)
-		{
-			int iDelta = (int)(dwCurTime - pinfo->dwTime);
-			int iServerDelta = (int)(dwCurTime - ch->GetDesc()->GetClientTime());
-
-			iDelta = (int)(dwCurTime - pinfo->dwTime);
-
-			// 시간이 늦게간다. 일단 로그만 해둔다. 진짜 이런 사람들이 많은지 체크해야함. TODO
-			if (iDelta >= 30000)
-			{
-				sys_log(0, "SPEEDHACK: slow timer name %s delta %d", ch->GetName(), iDelta);
-				ch->GetDesc()->DelayedDisconnect(3);
-			}
-			// 1초에 20msec 빨리 가는거 까지는 이해한다.
-			else if (iDelta < -(iServerDelta / 50))
-			{
-				sys_log(0, "SPEEDHACK: DETECTED! %s (delta %d %d)", ch->GetName(), iDelta, iServerDelta);
-				ch->GetDesc()->DelayedDisconnect(3);
-			}
-		}
-
-		//
-		// 콤보핵 및 스피드핵 체크
-		//
-		if (pinfo->bFunc == FUNC_COMBO && g_bCheckMultiHack)
-		{
-			// DoS mitigation: rate-limit combo packets
-			if (ch->CheckComboFlood(dwCurTime))
-				return;
-			CheckComboHack(ch, pinfo->bArg, pinfo->dwTime, CheckSpeedHack);
-		}
-	}
-
-	if (pinfo->bFunc == FUNC_MOVE)
-	{
-		if (ch->GetLimitPoint(POINT_MOV_SPEED) == 0)
-			return;
-
-		ch->SetRotation(pinfo->bRot * 5);
-		ch->ResetStopTime();
-
-		ch->Goto(pinfo->lX, pinfo->lY);
-	}
-	else
-	{
-		if (pinfo->bFunc == FUNC_ATTACK || pinfo->bFunc == FUNC_COMBO)
-			ch->OnMove(true);
-		else if (pinfo->bFunc & FUNC_SKILL)
-		{
-			const int MASK_SKILL_MOTION = 0x7F;
-			unsigned int motion = pinfo->bFunc & MASK_SKILL_MOTION;
-
-			if (!ch->IsUsableSkillMotion(motion))
-			{
-				const char* name = ch->GetName();
-				unsigned int job = ch->GetJob();
-				unsigned int group = ch->GetSkillGroup();
-
-				char szBuf[256];
-				snprintf(szBuf, sizeof(szBuf), "SKILL_HACK: name=%s, job=%d, group=%d, motion=%d", name, job, group, motion);
-				LogManager::Instance().HackLog(szBuf, ch->GetDesc()->GetAccountTable().login, ch->GetName(), ch->GetDesc()->GetHostName());
-				sys_log(0, "%s", szBuf);
-
-				if (test_server)
-				{
-					ch->GetDesc()->DelayedDisconnect(number(2, 8));
-					ch->ChatPacket(CHAT_TYPE_INFO, szBuf);
-				}
-				else
-				{
-					ch->GetDesc()->DelayedDisconnect(number(150, 500));
-				}
-			}
-
-			ch->OnMove();
-		}
-
-		ch->SetRotation(pinfo->bRot * 5); // 중복 코드
-		ch->ResetStopTime(); // ""
-
-		ch->Move(pinfo->lX, pinfo->lY);
-		ch->Stop();
-		ch->StopStaminaConsume();
-	}
-
-	TPacketGCMove pack;
-
-	pack.bHeader = HEADER_GC_MOVE;
-	pack.bFunc = pinfo->bFunc;
-	pack.bArg = pinfo->bArg;
-	pack.bRot = pinfo->bRot;
-	pack.dwVID = ch->GetVID();
-	pack.lX = pinfo->lX;
-	pack.lY = pinfo->lY;
-	pack.dwTime = pinfo->dwTime;
-	pack.dwDuration = (pinfo->bFunc == FUNC_MOVE) ? ch->GetCurrentMoveDuration() : 0;
-
-	ch->PacketAround(&pack, sizeof(TPacketGCMove), ch);
-	/*
-		if (pinfo->dwTime == 10653691) // 디버거 발견
-		{
-			if (ch->GetDesc()->DelayedDisconnect(number(15, 30)))
-				LogManager::instance().HackLog("Debugger", ch);
-
-		}
-		else if (pinfo->dwTime == 10653971) // Softice 발견
-		{
-			if (ch->GetDesc()->DelayedDisconnect(number(15, 30)))
-				LogManager::instance().HackLog("Softice", ch);
-		}
-	*/
-	/*
-	sys_log(0,
-			"MOVE: %s Func:%u Arg:%u Pos:%dx%d Time:%u Dist:%.1f",
-			ch->GetName(),
-			pinfo->bFunc,
-			pinfo->bArg,
-			pinfo->lX / 100,
-			pinfo->lY / 100,
-			pinfo->dwTime,
-			fDist);
-	*/
-}
-
-void CInputMain::Attack(LPCHARACTER ch, const BYTE header, const char* data)
-{
-	if (NULL == ch)
-		return;
-
-	// [Security] Spectator/observer characters must never be able to attack (packet injection / ghost attack)
-	if (ch->IsObserverMode() || ch->IsDead())
-		return;
-
-	struct type_identifier
-	{
-		BYTE header;
-		BYTE type;
-	};
-
-	const struct type_identifier* const type = reinterpret_cast<const struct type_identifier*>(data);
-
-	if (type->type > 0)
-	{
-		if (false == ch->CanUseSkill(type->type))
-		{
-			return;
-		}
-
-		switch (type->type)
-		{
-			case SKILL_GEOMPUNG:
-			case SKILL_SANGONG:
-			case SKILL_YEONSA:
-			case SKILL_KWANKYEOK:
-			case SKILL_HWAJO:
-			case SKILL_GIGUNG:
-			case SKILL_PABEOB:
-			case SKILL_MARYUNG:
-			case SKILL_TUSOK:
-#if defined(__9TH_SKILL__)
-			case SKILL_ILGWANGPYO:
-			case SKILL_PUNGLOEPO:
-			case SKILL_MABEOBAGGWI:
-			case SKILL_METEO:
-#endif
-			case SKILL_MAHWAN:
-			case SKILL_BIPABU:
-			case SKILL_NOEJEON:
-			case SKILL_CHAIN:
-			case SKILL_HORSE_WILDATTACK_RANGE:
-				if (HEADER_CG_SHOOT != type->header)
-				{
-					if (test_server)
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Attack :name[%s] Vnum[%d] can't use skill by attack(warning)", type->type));
-					return;
-				}
-				break;
-		}
-	}
-
-	switch (header)
-	{
-		case HEADER_CG_ATTACK:
-		{
-			if (NULL == ch->GetDesc())
-				return;
-
-			const TPacketCGAttack* const packMelee = reinterpret_cast<const TPacketCGAttack*>(data);
-
-			ch->GetDesc()->AssembleCRCMagicCube(packMelee->bCRCMagicCubeProcPiece, packMelee->bCRCMagicCubeFilePiece);
-
-			LPCHARACTER victim = CHARACTER_MANAGER::instance().Find(packMelee->dwVID);
-
-			if (NULL == victim || ch == victim)
-				return;
-
-			switch (victim->GetCharType())
-			{
-				case CHAR_TYPE_NPC:
-				case CHAR_TYPE_WARP:
-				case CHAR_TYPE_GOTO:
-				case CHAR_TYPE_HORSE:
-					//#if defined(__GROWTH_PET_SYSTEM__)
-				case CHAR_TYPE_PET:
-					//#endif
-				case CHAR_TYPE_PET_PAY:
-				case CHAR_TYPE_SHOP:
-					return;
-			}
-
-			if (packMelee->bType > 0)
-			{
-				if (false == ch->CheckSkillHitCount(packMelee->bType, victim->GetVID()))
-				{
-					return;
-				}
-			}
-
-			ch->Attack(victim, packMelee->bType);
-		}
-		break;
-
-		case HEADER_CG_SHOOT:
-		{
-			const TPacketCGShoot* const packShoot = reinterpret_cast<const TPacketCGShoot*>(data);
-
-			ch->Shoot(packShoot->bType);
-		}
-		break;
-	}
-}
-
-int CInputMain::SyncPosition(LPCHARACTER ch, const char* c_pcData, size_t uiBytes)
-{
-	const TPacketCGSyncPosition* pinfo = reinterpret_cast<const TPacketCGSyncPosition*>(c_pcData);
-
-	if (uiBytes < pinfo->wSize)
-		return -1;
-
-	int iExtraLen = pinfo->wSize - sizeof(TPacketCGSyncPosition);
-
-	if (iExtraLen < 0)
-	{
-		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->wSize, uiBytes);
-		ch->GetDesc()->SetPhase(PHASE_CLOSE);
-		return -1;
-	}
-
-	if (0 != (iExtraLen % sizeof(TPacketCGSyncPositionElement)))
-	{
-		sys_err("invalid packet length %d (name: %s)", pinfo->wSize, ch->GetName());
-		return iExtraLen;
-	}
-
-	int iCount = iExtraLen / sizeof(TPacketCGSyncPositionElement);
-
-	if (iCount <= 0)
-		return iExtraLen;
-
-	static const int nCountLimit = 16;
-
-	if (iCount > nCountLimit)
-	{
-		// LogManager::instance().HackLog( "SYNC_POSITION_HACK", ch );
-		sys_err("Too many SyncPosition Count(%d) from Name(%s)", iCount, ch->GetName());
-		// ch->GetDesc()->SetPhase(PHASE_CLOSE);
-		// return -1;
-		iCount = nCountLimit;
-	}
-
-	TEMP_BUFFER tbuf;
-	LPBUFFER lpBuf = tbuf.getptr();
-
-	TPacketGCSyncPosition* pHeader = (TPacketGCSyncPosition*)buffer_write_peek(lpBuf);
-	buffer_write_proceed(lpBuf, sizeof(TPacketGCSyncPosition));
-
-	const TPacketCGSyncPositionElement* e =
-		reinterpret_cast<const TPacketCGSyncPositionElement*>(c_pcData + sizeof(TPacketCGSyncPosition));
-
-	timeval tvCurTime;
-	gettimeofday(&tvCurTime, NULL);
-
-	for (int i = 0; i < iCount; ++i, ++e)
-	{
-		LPCHARACTER victim = CHARACTER_MANAGER::instance().Find(e->dwVID);
-
-		if (!victim)
-			continue;
-
-		switch (victim->GetCharType())
-		{
-			case CHAR_TYPE_NPC:
-			case CHAR_TYPE_WARP:
-			case CHAR_TYPE_GOTO:
-			case CHAR_TYPE_HORSE:
-				//#if defined(__GROWTH_PET_SYSTEM__)
-			case CHAR_TYPE_PET:
-				//#endif
-			case CHAR_TYPE_PET_PAY:
-			case CHAR_TYPE_SHOP:
-				continue;
-		}
-
-		// 소유권 검사
-		if (!victim->SetSyncOwner(ch))
-			continue;
-
-		const float fDistWithSyncOwner = DISTANCE_SQRT((victim->GetX() - ch->GetX()) / 100, (victim->GetY() - ch->GetY()) / 100);
-		static const float fLimitDistWithSyncOwner = 2500.f + 1000.f;
-		// victim과의 거리가 2500 + a 이상이면 핵으로 간주.
-		// 거리 참조 : 클라이언트의 __GetSkillTargetRange, __GetBowRange 함수
-		// 2500 : 스킬 proto에서 가장 사거리가 긴 스킬의 사거리, 또는 활의 사거리
-		// a = POINT_BOW_DISTANCE 값... 인데 실제로 사용하는 값인지는 잘 모르겠음. 아이템이나 포션, 스킬, 퀘스트에는 없는데...
-		// 그래도 혹시나 하는 마음에 버퍼로 사용할 겸해서 1000.f 로 둠...
-		if (fDistWithSyncOwner > fLimitDistWithSyncOwner)
-		{
-			// g_iSyncHackLimitCount번 까지는 봐줌.
-			if (ch->GetSyncHackCount() < g_iSyncHackLimitCount)
-			{
-				ch->SetSyncHackCount(ch->GetSyncHackCount() + 1);
-				continue;
-			}
-			else
-			{
-				LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
-
-				sys_err("Too far SyncPosition DistanceWithSyncOwner(%f)(%s) from Name(%s) CH(%d,%d) VICTIM(%d,%d) SYNC(%d,%d)",
-					fDistWithSyncOwner, victim->GetName(), ch->GetName(), ch->GetX(), ch->GetY(), victim->GetX(), victim->GetY(),
-					e->lX, e->lY);
-
-				ch->GetDesc()->SetPhase(PHASE_CLOSE);
-
-				return -1;
-			}
-		}
-
-		const float fDist = DISTANCE_SQRT((victim->GetX() - e->lX) / 100, (victim->GetY() - e->lY) / 100);
-		static const long g_lValidSyncInterval = 100 * 1000; // 100ms
-		const timeval& tvLastSyncTime = victim->GetLastSyncTime();
-		timeval* tvDiff = timediff(&tvCurTime, &tvLastSyncTime);
-
-		// SyncPosition을 악용하여 타유저를 이상한 곳으로 보내는 핵 방어하기 위하여,
-		// 같은 유저를 g_lValidSyncInterval ms 이내에 다시 SyncPosition하려고 하면 핵으로 간주.
-		if (tvDiff->tv_sec == 0 && tvDiff->tv_usec < g_lValidSyncInterval)
-		{
-			// g_iSyncHackLimitCount번 까지는 봐줌.
-			if (ch->GetSyncHackCount() < g_iSyncHackLimitCount)
-			{
-				ch->SetSyncHackCount(ch->GetSyncHackCount() + 1);
-				continue;
-			}
-			else
-			{
-				LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
-
-				sys_err("Too often SyncPosition Interval(%ldms)(%s) from Name(%s) VICTIM(%d,%d) SYNC(%d,%d)",
-					tvDiff->tv_sec * 1000 + tvDiff->tv_usec / 1000, victim->GetName(), ch->GetName(), victim->GetX(), victim->GetY(),
-					e->lX, e->lY);
-
-				ch->GetDesc()->SetPhase(PHASE_CLOSE);
-
-				return -1;
-			}
-		}
-		else if (fDist > 25.0f)
-		{
-			LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
-
-			sys_err("Too far SyncPosition Distance(%f)(%s) from Name(%s) CH(%d,%d) VICTIM(%d,%d) SYNC(%d,%d)",
-				fDist, victim->GetName(), ch->GetName(), ch->GetX(), ch->GetY(), victim->GetX(), victim->GetY(),
-				e->lX, e->lY);
-
-			ch->GetDesc()->SetPhase(PHASE_CLOSE);
-
-			return -1;
-		}
-		else
-		{
-			victim->SetLastSyncTime(tvCurTime);
-			victim->Sync(e->lX, e->lY);
-			buffer_write(lpBuf, e, sizeof(TPacketCGSyncPositionElement));
-		}
-	}
-
-	if (buffer_size(lpBuf) != sizeof(TPacketGCSyncPosition))
-	{
-		pHeader->bHeader = HEADER_GC_SYNC_POSITION;
-		pHeader->wSize = buffer_size(lpBuf);
-
-		ch->PacketAround(buffer_read_peek(lpBuf), buffer_size(lpBuf), ch);
-	}
-
-	return iExtraLen;
-}
-
-void CInputMain::FlyTarget(LPCHARACTER ch, const char* pcData, BYTE bHeader)
-{
-	TPacketCGFlyTargeting* p = (TPacketCGFlyTargeting*)pcData;
-	ch->FlyTarget(p->dwTargetVID, p->x, p->y, bHeader);
-}
-
-void CInputMain::UseSkill(LPCHARACTER ch, const char* pcData)
-{
-	TPacketCGUseSkill* p = (TPacketCGUseSkill*)pcData;
-	ch->UseSkill(p->dwVnum, CHARACTER_MANAGER::instance().Find(p->dwVID));
-}
-
-void CInputMain::ScriptButton(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGScriptButton* p = (TPacketCGScriptButton*)c_pData;
-	sys_log(0, "QUEST ScriptButton pid %d idx %u", ch->GetPlayerID(), p->idx);
-
-	quest::PC* pc = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
-	if (pc && pc->IsConfirmWait())
-	{
-		quest::CQuestManager::instance().Confirm(ch->GetPlayerID(), quest::CONFIRM_TIMEOUT);
-	}
-	else if (p->idx & 0x80000000)
-	{
-		quest::CQuestManager::Instance().QuestInfo(ch->GetPlayerID(), p->idx & 0x7fffffff);
-	}
-	else
-	{
-		quest::CQuestManager::Instance().QuestButton(ch->GetPlayerID(), p->idx);
-	}
-}
-
-void CInputMain::ScriptAnswer(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGScriptAnswer* p = (TPacketCGScriptAnswer*)c_pData;
-	sys_log(0, "QUEST ScriptAnswer pid %d answer %d", ch->GetPlayerID(), p->answer);
-
-	if (p->answer > 250) // 다음 버튼에 대한 응답으로 온 패킷인 경우
-	{
-		quest::CQuestManager::Instance().Resume(ch->GetPlayerID());
-	}
-	else // 선택 버튼을 골라서 온 패킷인 경우
-	{
-		quest::CQuestManager::Instance().Select(ch->GetPlayerID(), p->answer);
-	}
-}
-
-// SCRIPT_SELECT_ITEM
-void CInputMain::ScriptSelectItem(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGScriptSelectItem* p = (TPacketCGScriptSelectItem*)c_pData;
-	sys_log(0, "QUEST ScriptSelectItem pid %d answer %d", ch->GetPlayerID(), p->selection);
-	quest::CQuestManager::Instance().SelectItem(ch->GetPlayerID(), p->selection);
-}
-// END_OF_SCRIPT_SELECT_ITEM
-
-#if defined(__GEM_SYSTEM__)
-void CInputMain::SelectItemEx(LPCHARACTER c_lpCh, const void* c_pvData)
-{
-	if (c_lpCh == nullptr)
-		return;
-
-	TPacketCGSelectItemEx* pPacket = (TPacketCGSelectItemEx*)c_pvData;
-	sys_log(0, "SelectItemEx player (pid: %d) item (pos: %d)", c_lpCh->GetPlayerID(), pPacket->dwItemPos);
-	c_lpCh->SelectItemEx(pPacket->dwItemPos, pPacket->bType);
-}
-#endif
-
-#if defined(__QUEST_REQUEST_EVENT__)
-void CInputMain::RequestEventQuest(LPCHARACTER pChar, const void* c_pvData)
-{
-	const TPacketCGRequestEventQuest* c_pData = reinterpret_cast<const TPacketCGRequestEventQuest*>(c_pvData);
-	unsigned int uiQuestIndex = quest::CQuestManager::instance().GetQuestIndexByName(c_pData->szEventQuest);
-	if (uiQuestIndex)
-	{
-		if (quest::CQuestManager::instance().GetPCForce(pChar->GetPlayerID())->IsRunning())
-			return;
-
-		sys_log(0, "QUEST RequestEventQuest pid(%d), qid(%d)", pChar->GetPlayerID(), uiQuestIndex);
-		quest::CQuestManager::instance().RequestEvent(pChar->GetPlayerID(), uiQuestIndex, 0);
-	}
-}
-#endif
-
-void CInputMain::QuestInputString(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGQuestInputString* p = (TPacketCGQuestInputString*)c_pData;
-
-	char msg[65];
-	strlcpy(msg, p->msg, sizeof(msg));
-	sys_log(0, "QUEST InputString pid %u msg %s", ch->GetPlayerID(), msg);
-
-	quest::CQuestManager::Instance().Input(ch->GetPlayerID(), msg);
-}
-
-#if defined(__OX_RENEWAL__)
-void CInputMain::QuestInputLongString(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGQuestInputLongString* p = (TPacketCGQuestInputLongString*)c_pData;
-
-	char msg[129];
-	strlcpy(msg, p->msg, sizeof(msg));
-	sys_log(0, "QUEST InputLongString pid %u msg %s", ch->GetPlayerID(), msg);
-
-	quest::CQuestManager::Instance().Input(ch->GetPlayerID(), msg);
-}
-#endif
-
-void CInputMain::QuestConfirm(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGQuestConfirm* p = (TPacketCGQuestConfirm*)c_pData;
-	LPCHARACTER ch_wait = CHARACTER_MANAGER::instance().FindByPID(p->requestPID);
-	if (p->answer)
-		p->answer = quest::CONFIRM_YES;
-	sys_log(0, "QuestConfirm from %s pid %u name %s answer %d", ch->GetName(), p->requestPID, (ch_wait) ? ch_wait->GetName() : "", p->answer);
-	if (ch_wait)
-	{
-		quest::CQuestManager::Instance().Confirm(ch_wait->GetPlayerID(), (quest::EQuestConfirmType)p->answer, ch->GetPlayerID());
-	}
-}
-
-void CInputMain::Target(LPCHARACTER ch, const char* pcData)
-{
-	TPacketCGTarget* p = (TPacketCGTarget*)pcData;
-
-	building::LPOBJECT pkObj = building::CManager::instance().FindObjectByVID(p->dwVID);
-
-	if (pkObj)
-	{
-		TPacketGCTarget pckTarget;
-		pckTarget.header = HEADER_GC_TARGET;
-		pckTarget.dwVID = p->dwVID;
-#if defined(__DEFENSE_WAVE__)
-		pckTarget.bAlliance = false;
-#endif
-		ch->GetDesc()->Packet(&pckTarget, sizeof(TPacketGCTarget));
-	}
-	else
-		ch->SetTarget(CHARACTER_MANAGER::instance().Find(p->dwVID));
-}
-
-void CInputMain::Warp(LPCHARACTER ch, const char* pcData)
-{
-	ch->WarpEnd();
-}
-
-void CInputMain::SafeboxCheckin(LPCHARACTER ch, const char* c_pData)
-{
-	if (quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID())->IsRunning() == true)
-		return;
-
-	TPacketCGSafeboxCheckin* p = (TPacketCGSafeboxCheckin*)c_pData;
-
-	if (!ch->CanHandleItem())
-		return;
-
-	// [Security] Mutual exclusion: forbid safebox actions while other trade windows are open
-	if (!ch->IsOpenSafebox())
-		return;
-	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
-		return;
-
-	CSafebox* pkSafebox = ch->GetSafebox();
-	LPITEM pkItem = ch->GetItem(p->ItemPos);
-
-	if (!pkSafebox || !pkItem)
-		return;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	if (pkItem->GetCell() >= ch->GetExtendInvenMax() && IS_SET(pkItem->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-#else
-	if (pkItem->GetCell() >= INVENTORY_MAX_NUM && IS_SET(pkItem->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-#endif
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 창고로 옮길 수 없는 아이템 입니다."));
-		return;
-	}
-
-	if (!pkSafebox->IsEmpty(p->bSafePos, pkItem->GetSize()))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 옮길 수 없는 위치입니다."));
-		return;
-	}
-
-	if (pkItem->GetSIGVnum() == UNIQUE_GROUP_LARGE_SAFEBOX)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 이 아이템은 넣을 수 없습니다."));
-		return;
-	}
-
-	if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_SAFEBOX))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 이 아이템은 넣을 수 없습니다."));
-		return;
-	}
-
-	if (pkItem->IsEquipped())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Storeroom] An item that is currently being used cannot be stored."));
-		return;
-	}
-
-#if defined(__PET_SYSTEM__)
-	CPetSystem* pPetSystem = ch->GetPetSystem();
-	if (pPetSystem && pPetSystem->GetSummonItemVID() == pkItem->GetVID())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Storeroom] An item that is currently being used cannot be stored."));
-		return;
-	}
-#endif
-
-	if (true == pkItem->isLocked())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 이 아이템은 넣을 수 없습니다."));
-		return;
-	}
-
-	// Prevent items from the belt inventory checking-in the safebox.
-	if (p->ItemPos.window_type == BELT_INVENTORY)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Cannot proceed."));
-		return;
-	}
-
-	pkItem->RemoveFromCharacter();
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (!pkItem->IsDragonSoul())
-#endif
-		ch->SyncQuickslot(SLOT_TYPE_INVENTORY, p->ItemPos.cell, WORD_MAX);
-
-	pkSafebox->Add(p->bSafePos, pkItem);
-#ifdef __GROWTH_PET_SYSTEM__
-	if (pkItem->GetType() == ITEM_PET)
-	{
-		if (pkItem->GetSubType() == PET_UPBRINGING || pkItem->GetSubType() == PET_BAG)
-		{
-			LPGROWTH_PET pPet = ch->GetGrowthPet(pkItem->GetSocket(2));
-			if (pPet)
-				pkSafebox->AddPet(pPet);
-		}
-	}
-#endif
-	char szHint[128];
-	snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
-	LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX PUT", szHint);
-}
-
-void CInputMain::SafeboxCheckout(LPCHARACTER ch, const char* c_pData, bool bMall)
-{
-	TPacketCGSafeboxCheckout* p = (TPacketCGSafeboxCheckout*)c_pData;
-
-	if (!ch->CanHandleItem())
-		return;
-
-	// [Security] Mutual exclusion: safebox operations must not be possible alongside exchange/shop/cube (packet overlap / dup prevention)
-	if (!bMall && !ch->IsOpenSafebox())
-		return;
-	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
-		return;
-
-	CSafebox* pkSafebox;
-
-	if (bMall)
-		pkSafebox = ch->GetMall();
-	else
-		pkSafebox = ch->GetSafebox();
-
-	if (!pkSafebox)
-		return;
-
-	LPITEM pkItem = pkSafebox->Get(p->bSafePos);
-	if (!pkItem)
-		return;
-
-	if (p->ItemPos.IsBeltInventoryPosition())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Cannot proceed."));
-		return;
-	}
-
-#if defined(__SAFEBOX_IMPROVING__)
-	if ((p->ItemPos.window_type == INVENTORY) && (p->ItemPos.cell == 0))
-	{
-		BYTE bWindow = INVENTORY;
-		INT iCell = -1;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (pkItem->IsDragonSoul())
-		{
-			bWindow = DRAGON_SOUL_INVENTORY;
-			iCell = ch->GetEmptyDragonSoulInventory(pkItem);
-		}
-
-		else
-#endif
-		{
-			bWindow = INVENTORY;
-			iCell = ch->GetEmptyInventory(pkItem->GetSize());
-		}
-
-
-		if (iCell < 0)
-			return;
-
-		pkSafebox->Remove(p->bSafePos);
-		if (bMall)
-		{
-			if (NULL == pkItem->GetProto())
-			{
-				sys_err("pkItem->GetProto() == NULL (id : %d)", pkItem->GetID());
-				return;
-			}
-			// 100% 확률로 속성이 붙어야 하는데 안 붙어있다면 새로 붙힌다. ...............
-			if (100 == pkItem->GetProto()->bAlterToMagicItemPct && 0 == pkItem->GetAttributeCount())
-			{
-				pkItem->AlterToMagicItem(number(40, 50), number(10, 15));
-			}
-		}
-		pkItem->AddToCharacter(ch, TItemPos(bWindow, (WORD)iCell)
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			, false
-#endif
-		);
-		ITEM_MANAGER::Instance().FlushDelayedSave(pkItem);
-
-		DWORD dwID = pkItem->GetID();
-		db_clientdesc->DBPacketHeader(HEADER_GD_ITEM_FLUSH, 0, sizeof(DWORD));
-		db_clientdesc->Packet(&dwID, sizeof(DWORD));
-
-		char szHint[128];
-		snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
-		if (bMall)
-			LogManager::instance().ItemLog(ch, pkItem, "MALL GET", szHint);
-		else
-			LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX GET", szHint);
-
-		return;
-	}
-#endif
-
-	if (!ch->IsEmptyItemGrid(p->ItemPos, pkItem->GetSize()))
-		return;
-
-	// 아이템 몰에서 인벤으로 옮기는 부분에서 용혼석 특수 처리
-	// (몰에서 만드는 아이템은 item_proto에 정의된대로 속성이 붙기 때문에,
-	// 용혼석의 경우, 이 처리를 하지 않으면 속성이 하나도 붙지 않게 된다.)
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (pkItem->IsDragonSoul())
-	{
-		if (bMall)
-		{
-			DSManager::instance().DragonSoulItemInitialize(pkItem);
-		}
-
-		if (DRAGON_SOUL_INVENTORY != p->ItemPos.window_type)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 옮길 수 없는 위치입니다."));
-			return;
-		}
-
-		TItemPos DestPos = p->ItemPos;
-		if (!DSManager::instance().IsValidCellForThisItem(pkItem, DestPos))
-		{
-			int iCell = ch->GetEmptyDragonSoulInventory(pkItem);
-			if (iCell < 0)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 옮길 수 없는 위치입니다."));
-				return;
-			}
-			DestPos = TItemPos(DRAGON_SOUL_INVENTORY, iCell);
-		}
-
-		pkSafebox->Remove(p->bSafePos);
-		pkItem->AddToCharacter(ch, DestPos);
-		ITEM_MANAGER::instance().FlushDelayedSave(pkItem);
-	}
-	else
-#endif
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (DRAGON_SOUL_INVENTORY == p->ItemPos.window_type)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창고> 옮길 수 없는 위치입니다."));
-			return;
-		}
-#endif
-
-		pkSafebox->Remove(p->bSafePos);
-		if (bMall)
-		{
-			if (NULL == pkItem->GetProto())
-			{
-				sys_err("pkItem->GetProto() == NULL (id : %d)", pkItem->GetID());
-				return;
-			}
-			// 100% 확률로 속성이 붙어야 하는데 안 붙어있다면 새로 붙힌다. ...............
-			if (100 == pkItem->GetProto()->bAlterToMagicItemPct && 0 == pkItem->GetAttributeCount())
-			{
-				pkItem->AlterToMagicItem(number(40, 50), number(10, 15));
-			}
-		}
-		pkItem->AddToCharacter(ch, p->ItemPos);
-		ITEM_MANAGER::instance().FlushDelayedSave(pkItem);
-#ifdef __GROWTH_PET_SYSTEM__
-		if (pkItem->GetType() == ITEM_PET)
-		{
-			if (pkItem->GetSubType() == PET_UPBRINGING || pkItem->GetSubType() == PET_BAG)
-				pkSafebox->RemovePet(pkItem);
-		}
-#endif
-	}
-
-	DWORD dwID = pkItem->GetID();
-	db_clientdesc->DBPacketHeader(HEADER_GD_ITEM_FLUSH, 0, sizeof(DWORD));
-	db_clientdesc->Packet(&dwID, sizeof(DWORD));
-
-	char szHint[128];
-	snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
-	if (bMall)
-		LogManager::instance().ItemLog(ch, pkItem, "MALL GET", szHint);
-	else
-		LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX GET", szHint);
-}
-
-void CInputMain::SafeboxItemMove(LPCHARACTER ch, const char* data)
-{
-	struct command_item_move* pinfo = (struct command_item_move*)data;
-
-	if (!ch->CanHandleItem())
-		return;
-
-	// [Security] Mutual exclusion: block safebox operations while other trade windows are open
-	if (!ch->IsOpenSafebox())
-		return;
-	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
-		return;
-
-	if (!ch->GetSafebox())
-		return;
-
-	ch->GetSafebox()->MoveItem(pinfo->Cell.cell, pinfo->CellTo.cell, pinfo->count);
-}
-
-// PARTY_JOIN_BUG_FIX
-void CInputMain::PartyInvite(LPCHARACTER ch, const char* c_pData)
-{
-	if (!ch)
-		return;
-
-	if (ch->GetArena())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련장에서 사용하실 수 없습니다."));
-		return;
-	}
-
-	if (m_iBufferLeft < (int)sizeof(TPacketCGPartyInvite))
-	{
-		sys_err("PARTY_INVITE: malformed packet (len=%d < %u)", m_iBufferLeft, (unsigned)sizeof(TPacketCGPartyInvite));
-		return;
-	}
-
-	TPacketCGPartyInvite* p = (TPacketCGPartyInvite*)c_pData;
-
-	LPCHARACTER pInvitee = CHARACTER_MANAGER::instance().Find(p->vid);
-	if (ch == pInvitee)
-		return;
-
-	if (!pInvitee || !ch->GetDesc() || !pInvitee->GetDesc() || !pInvitee->IsPC() || !ch->IsPC())
-	{
-		sys_err("PARTY Cannot find invited character");
-		return;
-	}
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	if (CMessengerManager::instance().IsBlocked(ch->GetName(), pInvitee->GetName()))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", pInvitee->GetName()));
-		return;
-	}
-	else if (CMessengerManager::instance().IsBlocked(pInvitee->GetName(), ch->GetName()))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", pInvitee->GetName()));
-		return;
-	}
-#endif
-
-	ch->PartyInvite(pInvitee);
-}
-
-void CInputMain::PartyInviteAnswer(LPCHARACTER ch, const char* c_pData)
-{
-	if (!ch)
-		return;
-
-	if (ch->GetArena())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련장에서 사용하실 수 없습니다."));
-		return;
-	}
-
-	if (m_iBufferLeft < (int)sizeof(TPacketCGPartyInviteAnswer))
-	{
-		sys_err("PARTY_INVITE_ANSWER: malformed packet (len=%d < %u)", m_iBufferLeft, (unsigned)sizeof(TPacketCGPartyInviteAnswer));
-		return;
-	}
-
-	TPacketCGPartyInviteAnswer* p = (TPacketCGPartyInviteAnswer*)c_pData;
-
-	LPCHARACTER pInviter = CHARACTER_MANAGER::instance().Find(p->leader_vid);
-
-	// pInviter 가 ch 에게 파티 요청을 했었다.
-
-	if (!pInviter || !pInviter->IsPC())
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티요청을 한 캐릭터를 찾을수 없습니다."));
-	else if (!p->accept)
-		pInviter->PartyInviteDeny(ch->GetPlayerID());
-	else
-		pInviter->PartyInviteAccept(ch);
-}
-// END_OF_PARTY_JOIN_BUG_FIX
-
-void CInputMain::PartySetState(LPCHARACTER ch, const char* c_pData)
-{
-	if (!CPartyManager::instance().IsEnablePCParty())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 서버 문제로 파티 관련 처리를 할 수 없습니다."));
-		return;
-	}
-
-	TPacketCGPartySetState* p = (TPacketCGPartySetState*)c_pData;
-
-	if (!ch->GetParty())
-		return;
-
-	if (ch->GetParty()->GetLeaderPID() != ch->GetPlayerID())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 리더만 변경할 수 있습니다."));
-		return;
-	}
-
-	// HARDENING: disallow assigning party roles to self (prevents spoofed packets / recursion edge-cases)
-	if (p->pid == ch->GetPlayerID() && p->byRole != PARTY_ROLE_NORMAL)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, "<Party> You cannot assign a party role to yourself.");
-		return;
-	}
-
-	if (!ch->GetParty()->IsMember(p->pid))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 상태를 변경하려는 사람이 파티원이 아닙니다."));
-		return;
-	}
-
-	DWORD pid = p->pid;
-	sys_log(0, "PARTY SetRole pid %d to role %d state %s", pid, p->byRole, p->flag ? "on" : "off");
-
-	switch (p->byRole)
-	{
-		case PARTY_ROLE_NORMAL:
-			break;
-
-		case PARTY_ROLE_ATTACKER:
-		case PARTY_ROLE_TANKER:
-		case PARTY_ROLE_BUFFER:
-		case PARTY_ROLE_SKILL_MASTER:
-		case PARTY_ROLE_HASTE:
-		case PARTY_ROLE_DEFENDER:
-			if (ch->GetParty()->SetRole(pid, p->byRole, p->flag))
-			{
-				TPacketPartyStateChange pack;
-				pack.dwLeaderPID = ch->GetPlayerID();
-				pack.dwPID = p->pid;
-				pack.bRole = p->byRole;
-				pack.bFlag = p->flag;
-				db_clientdesc->DBPacket(HEADER_GD_PARTY_STATE_CHANGE, 0, &pack, sizeof(pack));
-			}
-			/*
-			else
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 어태커 설정에 실패하였습니다."));
-			*/
-			break;
-
-		default:
-			sys_err("wrong byRole in PartySetState Packet name %s state %d", ch->GetName(), p->byRole);
-			break;
-	}
-}
-
-void CInputMain::PartyRemove(LPCHARACTER ch, const char* c_pData)
-{
-	if (ch->GetArena())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("대련장에서 사용하실 수 없습니다."));
-		return;
-	}
-
-	if (!CPartyManager::instance().IsEnablePCParty())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 서버 문제로 파티 관련 처리를 할 수 없습니다."));
-		return;
-	}
-
-#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
-	if (ch->GetGuildDragonLair())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot disband the group while you are still active in Meley's Lair."));
-		return;
-	}
-#endif
-
-	TPacketCGPartyRemove* p = (TPacketCGPartyRemove*)c_pData;
-	LPPARTY pParty = ch->GetParty();
-
-	if (!pParty)
-		return;
-
-	if (pParty->GetDungeon_for_Only_party())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 던전 안에서는 파티에서 나갈 수 없습니다."));
-		return;
-	}
-
-	if (pParty->GetLeaderPID() == ch->GetPlayerID())
-	{
-		if (ch->GetDungeon()
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-			|| ch->GetGuildDragonLair()
-#endif
-#if defined(__DEFENSE_WAVE__)
-			|| ch->GetDefenseWave()
-#endif
-			)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 던젼내에서는 파티원을 추방할 수 없습니다."));
-		}
-		else
-		{
-#ifdef ENABLE_QUEEN_NETHIS
-			if (SnakeLair::CSnk::instance().IsSnakeMap(ch->GetMapIndex()))
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 던젼내에서는 파티원을 추방할 수 없습니다."));
-				return;
-			}
-#endif
-			// leader can remove any member
-			if (p->pid == ch->GetPlayerID() || pParty->GetMemberCount() == 2)
-			{
-				// party disband
-				CPartyManager::instance().DeleteParty(pParty);
-			}
-			else
-			{
-				LPCHARACTER B = CHARACTER_MANAGER::instance().FindByPID(p->pid);
-				if (B)
-				{
-					//pParty->SendPartyRemoveOneToAll(B);
-					B->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티에서 추방당하셨습니다."));
-					//pParty->Unlink(B);
-					//CPartyManager::instance().SetPartyMember(B->GetPlayerID(), NULL);
-				}
-				pParty->Quit(p->pid);
-			}
-		}
-	}
-	else
-	{
-		// otherwise, only remove itself
-		if (p->pid == ch->GetPlayerID())
-		{
-			if (ch->GetDungeon()
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-				|| ch->GetGuildDragonLair()
-#endif
-#if defined(__DEFENSE_WAVE__)
-				|| ch->GetDefenseWave()
-#endif
-				)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 던젼내에서는 파티를 나갈 수 없습니다."));
-			}
-			else
-			{
-#ifdef ENABLE_QUEEN_NETHIS
-				if (SnakeLair::CSnk::instance().IsSnakeMap(ch->GetMapIndex()))
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 던젼내에서는 파티원을 추방할 수 없습니다."));
-					return;
-				}
-#endif
-				if (pParty->GetMemberCount() == 2)
-				{
-					// party disband
-					CPartyManager::instance().DeleteParty(pParty);
-				}
-				else
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티에서 나가셨습니다."));
-					//pParty->SendPartyRemoveOneToAll(ch);
-					pParty->Quit(ch->GetPlayerID());
-					//pParty->SendPartyRemoveAllToOne(ch);
-					//CPartyManager::instance().SetPartyMember(ch->GetPlayerID(), NULL);
-				}
-			}
-		}
-		else
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 다른 파티원을 탈퇴시킬 수 없습니다."));
-		}
-	}
-}
-
-void CInputMain::AnswerMakeGuild(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGAnswerMakeGuild* p = (TPacketCGAnswerMakeGuild*)c_pData;
-
-	if (ch->GetGold() < 200000)
-		return;
-
-	if (ch->GetLevel() < 40)
-		return;
-
-	if (get_global_time() - ch->GetQuestFlag("guild_manage.new_disband_time") <
-		CGuildManager::instance().GetDisbandDelay())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 해산한 후 %d일 이내에는 길드를 만들 수 없습니다.",
-			quest::CQuestManager::instance().GetEventFlag("guild_disband_delay")));
-		return;
-	}
-
-	if (get_global_time() - ch->GetQuestFlag("guild_manage.new_withdraw_time") <
-		CGuildManager::instance().GetWithdrawDelay())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 탈퇴한 후 %d일 이내에는 길드를 만들 수 없습니다.",
-			quest::CQuestManager::instance().GetEventFlag("guild_withdraw_delay")));
-		return;
-	}
-
-	if (ch->GetGuild())
-		return;
-
-	CGuildManager& gm = CGuildManager::instance();
-
-	TGuildCreateParameter cp;
-	memset(&cp, 0, sizeof(cp));
-
-	cp.master = ch;
-	strlcpy(cp.name, p->guild_name, sizeof(cp.name));
-
-	if (cp.name[0] == 0 || !check_name(cp.name))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("적합하지 않은 길드 이름 입니다."));
-		return;
-	}
-
-	DWORD dwGuildID = gm.CreateGuild(cp);
-
-	if (dwGuildID)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> [%s] 길드가 생성되었습니다.", cp.name));
-
-		int GuildCreateFee;
-
-		if (LC_IsBrazil())
-		{
-			GuildCreateFee = 500000;
-		}
-		else
-		{
-			GuildCreateFee = 200000;
-		}
-
-		ch->PointChange(POINT_GOLD, -GuildCreateFee);
-		DBManager::instance().SendMoneyLog(MONEY_LOG_GUILD, ch->GetPlayerID(), -GuildCreateFee);
-
-		char Log[128];
-		snprintf(Log, sizeof(Log), "GUILD_NAME %s MASTER %s", cp.name, ch->GetName());
-		LogManager::instance().CharLog(ch, 0, "MAKE_GUILD", Log);
-
-		if (g_iUseLocale)
-			ch->RemoveSpecifyItem(GUILD_CREATE_ITEM_VNUM, 1);
-		//ch->SendGuildName(dwGuildID);
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-		CGuildManager::Instance().RequestSetEventFlag(dwGuildID, "create_time", get_global_time());
-#endif
-	}
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드 생성에 실패하였습니다."));
-}
-
-void CInputMain::PartyUseSkill(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGPartyUseSkill* p = (TPacketCGPartyUseSkill*)c_pData;
-	if (!ch->GetParty())
-		return;
-
-	if (ch->GetPlayerID() != ch->GetParty()->GetLeaderPID())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 파티 기술은 파티장만 사용할 수 있습니다."));
-		return;
-	}
-
-	switch (p->bySkillIndex)
-	{
-		case PARTY_SKILL_HEAL:
-			ch->GetParty()->HealParty();
-			break;
-		case PARTY_SKILL_WARP:
-		{
-			LPCHARACTER pch = CHARACTER_MANAGER::instance().Find(p->vid);
-			if (pch && pch->IsPC())
-				ch->GetParty()->SummonToLeader(pch->GetPlayerID());
-			else
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<파티> 소환하려는 대상을 찾을 수 없습니다."));
-		}
-		break;
-	}
-}
-
-void CInputMain::PartyParameter(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGPartyParameter* p = (TPacketCGPartyParameter*)c_pData;
-
-	if (ch->GetParty() && ch->GetParty()->GetLeaderPID() == ch->GetPlayerID())
-		ch->GetParty()->SetParameter(p->bDistributeMode);
-}
-
-size_t GetSubPacketSize(const GUILD_SUBHEADER_CG& header)
-{
-	switch (header)
-	{
-		case GUILD_SUBHEADER_CG_DEPOSIT_MONEY: return sizeof(int);
-		case GUILD_SUBHEADER_CG_WITHDRAW_MONEY: return sizeof(int);
-		case GUILD_SUBHEADER_CG_ADD_MEMBER: return sizeof(DWORD);
-		case GUILD_SUBHEADER_CG_REMOVE_MEMBER: return sizeof(DWORD);
-		case GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME: return 10;
-		case GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY: return sizeof(BYTE) + sizeof(BYTE);
-		case GUILD_SUBHEADER_CG_OFFER: return sizeof(DWORD);
-		case GUILD_SUBHEADER_CG_CHARGE_GSP: return sizeof(int);
-		case GUILD_SUBHEADER_CG_POST_COMMENT: return 1;
-		case GUILD_SUBHEADER_CG_DELETE_COMMENT: return sizeof(DWORD);
-		case GUILD_SUBHEADER_CG_REFRESH_COMMENT: return 0;
-		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE: return sizeof(DWORD) + sizeof(BYTE);
-		case GUILD_SUBHEADER_CG_USE_SKILL: return sizeof(TPacketCGGuildUseSkill);
-		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL: return sizeof(DWORD) + sizeof(BYTE);
-		case GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER: return sizeof(DWORD) + sizeof(BYTE);
-	}
-
-	return 0;
-}
-
-int CInputMain::Guild(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	if (uiBytes < sizeof(TPacketCGGuild))
-		return -1;
-
-	const TPacketCGGuild* p = reinterpret_cast<const TPacketCGGuild*>(data);
-	const char* c_pData = data + sizeof(TPacketCGGuild);
-
-	uiBytes -= sizeof(TPacketCGGuild);
-
-	const GUILD_SUBHEADER_CG SubHeader = static_cast<GUILD_SUBHEADER_CG>(p->subheader);
-	const size_t SubPacketLen = GetSubPacketSize(SubHeader);
-
-	if (uiBytes < SubPacketLen)
-	{
-		return -1;
-	}
-
-	CGuild* pGuild = ch->GetGuild();
-
-	if (NULL == pGuild)
-	{
-		if (SubHeader != GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드에 속해있지 않습니다."));
-			return SubPacketLen;
-		}
-	}
-
-	switch (SubHeader)
-	{
-		case GUILD_SUBHEADER_CG_DEPOSIT_MONEY:
-		{
-			// by mhh : 길드자금은 당분간 넣을 수 없다.
-			return SubPacketLen;
-
-			const int gold = MIN(*reinterpret_cast<const int*>(c_pData), __deposit_limit());
-
-			if (gold < 0)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 잘못된 금액입니다."));
-				return SubPacketLen;
-			}
-
-			if (ch->GetGold() < gold)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 가지고 있는 돈이 부족합니다."));
-				return SubPacketLen;
-			}
-
-			pGuild->RequestDepositMoney(ch, gold);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_WITHDRAW_MONEY:
-		{
-			// by mhh : 길드자금은 당분간 뺄 수 없다.
-			return SubPacketLen;
-
-			const int gold = MIN(*reinterpret_cast<const int*>(c_pData), 500000);
-
-			if (gold < 0)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 잘못된 금액입니다."));
-				return SubPacketLen;
-			}
-
-			pGuild->RequestWithdrawMoney(ch, gold);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_ADD_MEMBER:
-		{
-			const DWORD vid = *reinterpret_cast<const DWORD*>(c_pData);
-			LPCHARACTER newmember = CHARACTER_MANAGER::instance().Find(vid);
-
-			if (!newmember)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 그러한 사람을 찾을 수 없습니다."));
-				return SubPacketLen;
-			}
-
-			if (!ch->IsPC() || !newmember->IsPC())
-				return SubPacketLen;
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-			if (CMessengerManager::instance().IsBlocked(ch->GetName(), newmember->GetName()))
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", newmember->GetName()));
-				return SubPacketLen;
-			}
-			else if (CMessengerManager::instance().IsBlocked(newmember->GetName(), ch->GetName()))
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", newmember->GetName()));
-				return SubPacketLen;
-			}
-#endif
-
-			if (newmember->GetQuestFlag("change_guild_master.be_other_member") > get_global_time())
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 아직 가입할 수 없는 캐릭터입니다"));
-				return SubPacketLen;
-			}
-
-			pGuild->Invite(ch, newmember);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_REMOVE_MEMBER:
-		{
-			if (pGuild->UnderAnyWar() != 0)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드전 중에는 길드원을 탈퇴시킬 수 없습니다."));
-				return SubPacketLen;
-			}
-
-			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			LPCHARACTER member = CHARACTER_MANAGER::instance().FindByPID(pid);
-
-			if (member)
-			{
-				if (member->GetGuild() != pGuild)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 상대방이 같은 길드가 아닙니다."));
-					return SubPacketLen;
-				}
-
-				if (!pGuild->HasGradeAuth(m->grade, GUILD_AUTH_REMOVE_MEMBER))
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드원을 강제 탈퇴 시킬 권한이 없습니다."));
-					return SubPacketLen;
-				}
-
-				member->SetQuestFlag("guild_manage.new_withdraw_time", get_global_time());
-				pGuild->RequestRemoveMember(member->GetPlayerID());
-
-				if (LC_IsBrazil() == true)
-				{
-					DBManager::instance().Query("REPLACE INTO guild_invite_limit VALUES(%d, %d)", pGuild->GetID(), get_global_time());
-				}
-			}
-			else
-			{
-				if (!pGuild->HasGradeAuth(m->grade, GUILD_AUTH_REMOVE_MEMBER))
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드원을 강제 탈퇴 시킬 권한이 없습니다."));
-					return SubPacketLen;
-				}
-
-				if (pGuild->RequestRemoveMember(pid))
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드원을 강제 탈퇴 시켰습니다."));
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 그러한 사람을 찾을 수 없습니다."));
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME:
-		{
-			char gradename[GUILD_GRADE_NAME_MAX_LEN + 1];
-			strlcpy(gradename, c_pData + 1, sizeof(gradename));
-
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			if (m->grade != GUILD_LEADER_GRADE)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 직위 이름을 변경할 권한이 없습니다."));
-			}
-			else if (*c_pData == GUILD_LEADER_GRADE)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드장의 직위 이름은 변경할 수 없습니다."));
-			}
-			else if (!check_name(gradename))
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 적합하지 않은 직위 이름 입니다."));
-			}
-			else
-			{
-				pGuild->ChangeGradeName(*c_pData, gradename);
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY:
-		{
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			if (m->grade != GUILD_LEADER_GRADE)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 직위 권한을 변경할 권한이 없습니다."));
-			}
-			else if (*c_pData == GUILD_LEADER_GRADE)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드장의 권한은 변경할 수 없습니다."));
-			}
-			else
-			{
-				pGuild->ChangeGradeAuth(*c_pData, *(c_pData + 1));
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_OFFER:
-		{
-			DWORD offer = *reinterpret_cast<const DWORD*>(c_pData);
-
-			if (pGuild->GetLevel() >= GUILD_MAX_LEVEL && LC_IsHongKong() == false)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드가 이미 최고 레벨입니다."));
-			}
-			else
-			{
-				offer /= 100;
-				offer *= 100;
-
-				if (pGuild->OfferExp(ch, offer))
-				{
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-					ch->UpdateExtBattlePassMissionProgress(GUILD_SPENT_EXP, offer, 0);
-#endif
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> %u의 경험치를 투자하였습니다.", offer));
-				}
-				else
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 경험치 투자에 실패하였습니다."));
-				}
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_CHARGE_GSP:
-		{
-			const int offer = *reinterpret_cast<const int*>(c_pData);
-			const int gold = offer * 100;
-
-			if (offer < 0 || gold < offer || gold < 0 || ch->GetGold() < gold)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 돈이 부족합니다."));
-				return SubPacketLen;
-			}
-
-			if (!pGuild->ChargeSP(ch, offer))
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 용신력 회복에 실패하였습니다."));
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_POST_COMMENT:
-		{
-			const size_t length = *c_pData;
-
-			if (length > GUILD_COMMENT_MAX_LEN)
-			{
-				// 잘못된 길이.. 끊어주자.
-				sys_err("POST_COMMENT: %s comment too long (length: %u)", ch->GetName(), length);
-				ch->GetDesc()->SetPhase(PHASE_CLOSE);
-				return -1;
-			}
-
-			if (uiBytes < 1 + length)
-				return -1;
-
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			if (length && !pGuild->HasGradeAuth(m->grade, GUILD_AUTH_NOTICE) && *(c_pData + 1) == '!')
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 공지글을 작성할 권한이 없습니다."));
-			}
-			else
-			{
-				std::string str(c_pData + 1, length);
-				pGuild->AddComment(ch, str);
-			}
-
-			return (1 + length);
-		}
-
-		case GUILD_SUBHEADER_CG_DELETE_COMMENT:
-		{
-			const DWORD comment_id = *reinterpret_cast<const DWORD*>(c_pData);
-
-			pGuild->DeleteComment(ch, comment_id);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_REFRESH_COMMENT:
-			pGuild->RefreshComment(ch);
-			return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE:
-		{
-			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
-			const BYTE grade = *(c_pData + sizeof(DWORD));
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			if (m->grade != GUILD_LEADER_GRADE)
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 직위를 변경할 권한이 없습니다."));
-			else if (ch->GetPlayerID() == pid)
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드장의 직위는 변경할 수 없습니다."));
-			else if (grade == 1)
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 길드장으로 직위를 변경할 수 없습니다."));
-			else
-				pGuild->ChangeMemberGrade(pid, grade);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_USE_SKILL:
-		{
-			const TPacketCGGuildUseSkill* p = reinterpret_cast<const TPacketCGGuildUseSkill*>(c_pData);
-
-			pGuild->UseSkill(p->dwVnum, ch, p->dwPID);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL:
-		{
-			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
-			const BYTE is_general = *(c_pData + sizeof(DWORD));
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			if (m->grade != GUILD_LEADER_GRADE)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 장군을 지정할 권한이 없습니다."));
-			}
-			else
-			{
-				if (!pGuild->ChangeMemberGeneral(pid, is_general))
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<길드> 더이상 장수를 지정할 수 없습니다."));
-				}
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER:
-		{
-			const DWORD guild_id = *reinterpret_cast<const DWORD*>(c_pData);
-			const BYTE accept = *(c_pData + sizeof(DWORD));
-
-			CGuild* g = CGuildManager::instance().FindGuild(guild_id);
-
-			if (g)
-			{
-				if (accept)
-					g->InviteAccept(ch);
-				else
-					g->InviteDeny(ch->GetPlayerID());
-			}
-		}
-		return SubPacketLen;
-
-	}
-
-	return 0;
-}
-
-void CInputMain::Fishing(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGFishing* p = (TPacketCGFishing*)c_pData;
-	ch->SetRotation(p->dir * 5);
-	ch->fishing();
-	return;
-}
-
-#if defined(__FISHING_GAME__)
-#include "fishing.h"
-void CInputMain::FishingGame(const LPCHARACTER c_lpChar, const char* c_pszData)
-{
-	const TPacketCGFishingGame* c_pData = reinterpret_cast<const TPacketCGFishingGame*>(c_pszData);
-	if (c_pData == nullptr || c_lpChar == nullptr)
-		return;
-
-	const LPITEM c_lpFishingRod = c_lpChar->GetWear(WEAR_WEAPON);
-	if (c_lpFishingRod && c_lpFishingRod->GetType() == ITEM_ROD)
-	{
-		if (c_lpChar->m_pkFishingEvent)
-		{
-			switch (c_pData->bSubHeader)
-			{
-				case FISHING_GAME_SUBHEADER_GOAL:
-				{
-					c_lpChar->SetFishingGameGoals(c_pData->bGoals);
-					if (c_lpChar->GetFishingGameGoals() >= 3)
-						c_lpChar->fishing();
-				}
-				break;
-
-				case FISHING_GAME_SUBHEADER_QUIT:
-				{
-					event_cancel(&c_lpChar->m_pkFishingEvent);
-					c_lpFishingRod->SetSocket(2, 0);
-					fishing::FishingFail(c_lpChar);
-				}
-				break;
-			};
-		}
-	}
-}
-#endif
-
-void CInputMain::ItemGive(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGGiveItem* p = (TPacketCGGiveItem*)c_pData;
-	LPCHARACTER to_ch = CHARACTER_MANAGER::instance().Find(p->dwTargetVID);
-
-	if (to_ch)
-		ch->GiveItem(to_ch, p->ItemPos);
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템을 건네줄 수 없습니다."));
-}
-
-void CInputMain::Hack(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGHack* p = (TPacketCGHack*)c_pData;
-
-	char buf[sizeof(p->szBuf)];
-	strlcpy(buf, p->szBuf, sizeof(buf));
-
-	sys_err("HACK_DETECT: %s %s", ch->GetName(), buf);
-
-	// 현재 클라이언트에서 이 패킷을 보내는 경우가 없으므로 무조건 끊도록 한다
-	ch->GetDesc()->SetPhase(PHASE_CLOSE);
-}
-
-#if defined(__MYSHOP_DECO__)
-void CInputMain::MyShopDecoState(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGMyShopDecoState* p = (TPacketCGMyShopDecoState*)c_pData;
-	ch->SetMyShopDecoState(p->bState);
-}
-
-void CInputMain::MyShopDecoAdd(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGMyShopDecoAdd* p = (TPacketCGMyShopDecoAdd*)c_pData;
-	if (ch->GetMyShopDecoState())
-	{
-		if (p->dwPolyVnum < 30000 && p->dwPolyVnum > 30008)
-		{
-			sys_err("MyShopDecoAdd : Unknown PolyVnum");
-			return;
-		}
-
-		ch->SetMyShopDecoType(p->bType);
-		ch->SetMyShopDecoPolyVnum(p->dwPolyVnum);
-
-#if defined(__MYSHOP_EXPANSION__)
-		//ch->OpenPrivateShop(2, true);
-		// NOTE : Ideally, the Kashmir Bundle should have the same benefits as the Silk Bundle.
-		ch->UseSilkBotary();
-#else
-		ch->OpenPrivateShop(1, true);
-#endif
-	}
-	else
-	{
-		sys_err("MyShopDecoAdd : Unknown State");
-		return;
-	}
-}
-#endif
-
-int CInputMain::MyShop(LPCHARACTER ch, const char* c_pData, size_t uiBytes)
-{
-	const TPacketCGMyShop* p = (TPacketCGMyShop*)c_pData;
-	const int iExtraLen = p->bCount * sizeof(TShopItemTable);
-
-	if (uiBytes < sizeof(TPacketCGMyShop) + iExtraLen)
-		return -1;
-
-	if (ch->GetGold() >= GOLD_MAX)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("소유 돈이 20억냥을 넘어 거래를 핼수가 없습니다."));
-		sys_log(0, "MyShop ==> OverFlow Gold id %u name %s ", ch->GetPlayerID(), ch->GetName());
-		return (iExtraLen);
-	}
-
-#if defined(__CHEQUE_SYSTEM__)
-	if (ch->GetCheque() > CHEQUE_MAX)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("소유 돈이 20억냥을 넘어 거래를 핼수가 없습니다."));
-		sys_log(0, "MyShop ==> OverFlow Cheque id %u name %s ", ch->GetPlayerID(), ch->GetName());
-		return (iExtraLen);
-	}
-#endif
-
-	if (ch->IsStun() || ch->IsDead())
-		return (iExtraLen);
-
-	if (ch->PreventTradeWindow(WND_MYSHOP, true/*except*/))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 거래중일경우 개인상점을 열수가 없습니다."));
-		return (iExtraLen);
-	}
-
-	sys_log(0, "MyShop count %u", p->bCount);
-	char szSign[SHOP_SIGN_MAX_LEN + 1];
-	strlcpy(szSign, p->szSign, sizeof(szSign));
-	for (size_t i = 0; i < sizeof(szSign) && szSign[i]; ++i)
-	{
-		const unsigned char c = static_cast<unsigned char>(szSign[i]);
-		if (c < 0x20 || c == 0x7F)
-			szSign[i] = ' ';
-	}
-
-	ch->OpenMyShop(szSign, (TShopItemTable*)(c_pData + sizeof(TPacketCGMyShop)), p->bCount);
-	return (iExtraLen);
-}
-
-void CInputMain::Refine(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGRefine* p = reinterpret_cast<const TPacketCGRefine*>(c_pData);
-
-	if (ch->PreventTradeWindow(WND_REFINE, true/*except*/))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("창고,거래창등이 열린 상태에서는 개량을 할수가 없습니다"));
-		ch->ClearRefineMode();
-		return;
-	}
-
-	if (p->type == 255)
-	{
-		// DoRefine Cancel
-		ch->ClearRefineMode();
-		return;
-	}
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	if (p->pos >= ch->GetExtendInvenMax())
-#else
-	if (p->pos >= INVENTORY_MAX_NUM)
-#endif
-	{
-		ch->ClearRefineMode();
-		return;
-	}
-
-	LPITEM item = ch->GetInventoryItem(p->pos);
-	if (!item)
-	{
-		ch->ClearRefineMode();
-		return;
-	}
-
-	ch->SetRefineTime();
-
-	if (p->type == REFINE_TYPE_NORMAL)
-	{
-		sys_log(0, "refine_type_noraml");
-		ch->DoRefine(item);
-	}
-	else if (p->type == REFINE_TYPE_SCROLL
-		|| p->type == REFINE_TYPE_NOT_USED1
-		|| p->type == REFINE_TYPE_HYUNIRON
-		|| p->type == REFINE_TYPE_MUSIN
-		|| p->type == REFINE_TYPE_BDRAGON
-#if defined(__STONE_OF_BLESS__)
-		|| p->type == REFINE_TYPE_BLESSING_STONE
-#endif
-		)
-	{
-		sys_log(0, "refine_type_scroll, ...");
-		ch->DoRefineWithScroll(item);
-	}
-#if defined(__SOUL_SYSTEM__)
-	else if (p->type == REFINE_TYPE_SOUL_AWAKE || p->type == REFINE_TYPE_SOUL_EVOLVE)
-	{
-		ch->DoRefineSoul(item);
-	}
-#endif
-	else if (p->type == REFINE_TYPE_MONEY_ONLY)
-	{
-		const LPITEM item = ch->GetInventoryItem(p->pos);
-
-		if (NULL != item)
-		{
-			if (500 <= item->GetRefineSet())
-			{
-				LogManager::instance().HackLog("DEVIL_TOWER_REFINE_HACK", ch);
-			}
-			else
-			{
-				if (ch->GetQuestFlag("deviltower_zone.can_refine"))
-				{
-					ch->DoRefine(item, true);
-					ch->SetQuestFlag("deviltower_zone.can_refine", 0);
-				}
-				else
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, "사귀 타워 완료 보상은 한번까지 사용가능합니다.");
-				}
-			}
-		}
-	}
-
-	ch->ClearRefineMode();
-}
-
-#if defined(__CUBE_RENEWAL__)
-void CInputMain::Cube(const LPCHARACTER pChar, const char* pData)
-{
-	const TPacketCGCube* pPacket = reinterpret_cast<const TPacketCGCube*>(pData);
-	if (pPacket == nullptr)
-		return;
-
-	const DWORD dwFileCrc = CCubeManager::Instance().GetFileCrc();
-	if (pPacket->dwFileCrc != dwFileCrc)
-	{
-		const char* szSubHeader[] = {
-			{ "SUBHEADER_CG_CUBE_CLOSE" },
-			{ "SUBHEADER_CG_CUBE_MAKE" },
-		};
-
-		if (test_server)
-			pChar->ChatPacket(CHAT_TYPE_INFO, "cube crc mismatch: %u != %u",
-				pPacket->dwFileCrc, dwFileCrc);
-
-		sys_log(0, "cube: recv %s ch %s file crc mismatch: %u != %u",
-			szSubHeader[pPacket->bSubHeader], pChar->GetName(),
-			pPacket->dwFileCrc, dwFileCrc);
-
-		LogManager::instance().CharLog(pChar, 0, "CUBE FILE MISMATCH", "");
-		CCubeManager::Instance().CloseCube(pChar);
-	}
-
-	if (pChar->PreventTradeWindow(WND_CUBE, true/*except*/))
-	{
-		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("창고,거래창등이 열린 상태에서는 개량을 할수가 없습니다"));
-		return;
-	}
-
-	switch (pPacket->bSubHeader)
-	{
-		case SUBHEADER_CG_CUBE_CLOSE:
-			CCubeManager::Instance().CloseCube(pChar);
-			break;
-
-		case SUBHEADER_CG_CUBE_MAKE:
-			CCubeManager::Instance().MakeCube(pChar, pPacket->iCubeIndex, pPacket->iQuantity, pPacket->iImproveItemPos);
-			break;
-	}
-}
-#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-void CInputMain::ItemCombination(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGItemCombination* p = reinterpret_cast<const TPacketCGItemCombination*>(c_pData);
-
-	ch->ItemCombination(p->MediumIndex, p->BaseIndex, p->MaterialIndex);
-}
-
-void CInputMain::ItemCombinationCancel(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGItemCombinationCancel* p = reinterpret_cast<const TPacketCGItemCombinationCancel*>(c_pData);
-
-	ch->SetItemCombNpc(NULL);
-}
-#endif
-
-#if defined(__CHANGED_ATTR__)
-void CInputMain::ItemSelectAttr(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGItemSelectAttr* p = reinterpret_cast<const TPacketCGItemSelectAttr*>(c_pData);
-
-	ch->SelectAttrResult(p->bNew, p->pItemPos);
-}
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-static size_t GetAcceSubPacketLength(const ESubHeaderCGAcceRefine& eSubHeader)
-{
-	switch (eSubHeader)
-	{
-		case ACCE_REFINE_SUBHEADER_CG_CHECKIN:
-			return sizeof(TSubPacketCGAcceRefineCheckIn);
-		case ACCE_REFINE_SUBHEADER_CG_CHECKOUT:
-			return sizeof(TSubPacketCGAcceRefineCheckOut);
-		case ACCE_REFINE_SUBHEADER_CG_ACCEPT:
-			return sizeof(TSubPacketCGAcceRefineAccept);
-		case ACCE_REFINE_SUBHEADER_CG_CANCEL:
-			return 0;
-	}
-	return 0;
-}
-
-int CInputMain::AcceRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes)
-{
-	if (uiBytes < sizeof(TPacketCGAcceRefine))
-		return -1;
-
-	const TPacketCGAcceRefine* pPacket = reinterpret_cast<const TPacketCGAcceRefine*>(pszData);
-	const char* pszDataPacket = pszData + sizeof(TPacketCGAcceRefine);
-
-	uiBytes -= sizeof(TPacketCGAcceRefine);
-
-	const ESubHeaderCGAcceRefine eSubHeader = static_cast<ESubHeaderCGAcceRefine>(pPacket->bSubHeader);
-	const size_t uiSubPacketLength = GetAcceSubPacketLength(eSubHeader);
-	if (uiBytes < uiSubPacketLength)
-	{
-		sys_err("Invalid AcceRefine SubPacket length (SubPacketLength %d Size %u Buffer %u)", uiSubPacketLength, sizeof(TPacketCGAcceRefine), uiBytes);
-		return -1;
-	}
-
-	switch (eSubHeader)
-	{
-		case ACCE_REFINE_SUBHEADER_CG_CHECKIN:
-		{
-			const TSubPacketCGAcceRefineCheckIn* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineCheckIn*>(pszDataPacket);
-			pChar->AcceRefineWindowCheckIn(pSubPacket->bType, pSubPacket->SelectedPos, pSubPacket->AttachedPos);
-		}
-		return uiSubPacketLength;
-
-		case ACCE_REFINE_SUBHEADER_CG_CHECKOUT:
-		{
-			const TSubPacketCGAcceRefineCheckOut* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineCheckOut*>(pszDataPacket);
-			pChar->AcceRefineWindowCheckOut(pSubPacket->bType, pSubPacket->SelectedPos);
-		}
-		return uiSubPacketLength;
-
-		case ACCE_REFINE_SUBHEADER_CG_ACCEPT:
-		{
-			const TSubPacketCGAcceRefineAccept* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineAccept*>(pszDataPacket);
-			pChar->AcceRefineWindowAccept(pSubPacket->bType);
-		}
-		return uiSubPacketLength;
-
-		case ACCE_REFINE_SUBHEADER_CG_CANCEL:
-		{
-			pChar->AcceRefineWindowClose();
-		}
-		return uiSubPacketLength;
-	}
-
-	return 0;
-}
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-static size_t GetAuraSubPacketLength(const ESubHeaderCGAuraRefine& eSubHeader)
-{
-	switch (eSubHeader)
-	{
-		case AURA_REFINE_SUBHEADER_CG_CHECKIN:
-			return sizeof(TSubPacketCGAuraRefineCheckIn);
-		case AURA_REFINE_SUBHEADER_CG_CHECKOUT:
-			return sizeof(TSubPacketCGAuraRefineCheckOut);
-		case AURA_REFINE_SUBHEADER_CG_ACCEPT:
-			return sizeof(TSubPacketCGAuraRefineAccept);
-		case AURA_REFINE_SUBHEADER_CG_CANCEL:
-			return 0;
-	}
-	return 0;
-}
-
-int CInputMain::AuraRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes)
-{
-	if (uiBytes < sizeof(TPacketCGAuraRefine))
-		return -1;
-
-	const TPacketCGAuraRefine* pPacket = reinterpret_cast<const TPacketCGAuraRefine*>(pszData);
-	const char* pszDataPacket = pszData + sizeof(TPacketCGAuraRefine);
-
-	uiBytes -= sizeof(TPacketCGAuraRefine);
-
-	const ESubHeaderCGAuraRefine eSubHeader = static_cast<ESubHeaderCGAuraRefine>(pPacket->bSubHeader);
-	const size_t uiSubPacketLength = GetAuraSubPacketLength(eSubHeader);
-	if (uiBytes < uiSubPacketLength)
-	{
-		sys_err("Invalid AuraRefine SubPacket length (SubPacketLength %d Size %u Buffer %u)", uiSubPacketLength, sizeof(TPacketCGAuraRefine), uiBytes);
-		return -1;
-	}
-
-	switch (eSubHeader)
-	{
-		case AURA_REFINE_SUBHEADER_CG_CHECKIN:
-		{
-			const TSubPacketCGAuraRefineCheckIn* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineCheckIn*>(pszDataPacket);
-			pChar->AuraRefineWindowCheckIn(c_pSubPacket->bType, c_pSubPacket->SelectedPos, c_pSubPacket->AttachedPos);
-		}
-		return uiSubPacketLength;
-
-		case AURA_REFINE_SUBHEADER_CG_CHECKOUT:
-		{
-			const TSubPacketCGAuraRefineCheckOut* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineCheckOut*>(pszDataPacket);
-			pChar->AuraRefineWindowCheckOut(c_pSubPacket->bType, c_pSubPacket->SelectedPos);
-		}
-		return uiSubPacketLength;
-
-		case AURA_REFINE_SUBHEADER_CG_ACCEPT:
-		{
-			const TSubPacketCGAuraRefineAccept* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineAccept*>(pszDataPacket);
-			pChar->AuraRefineWindowAccept(c_pSubPacket->bType);
-		}
-		return uiSubPacketLength;
-
-		case AURA_REFINE_SUBHEADER_CG_CANCEL:
-		{
-			pChar->AuraRefineWindowClose();
-		}
-		return uiSubPacketLength;
-	}
-
-	return 0;
-}
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-void CInputMain::ChangeLook(LPCHARACTER lpCh, const char* c_pszData)
-{
-	const TPacketCGChangeLook* c_pData = reinterpret_cast<const TPacketCGChangeLook*>(c_pszData);
-
-	CChangeLook* pChangeLook = lpCh->GetChangeLook();
-	if (pChangeLook == nullptr)
-		return;
-
-	switch (static_cast<EPacketCGChangeLookSubHeader>(c_pData->bSubHeader))
-	{
-		case EPacketCGChangeLookSubHeader::ITEM_CHECK_IN:
-			pChangeLook->ItemCheckIn(c_pData->ItemPos, c_pData->bSlotIndex);
-			break;
-		case EPacketCGChangeLookSubHeader::ITEM_CHECK_OUT:
-			pChangeLook->ItemCheckOut(c_pData->bSlotIndex);
-			break;
-		case EPacketCGChangeLookSubHeader::FREE_ITEM_CHECK_IN:
-			pChangeLook->FreeItemCheckIn(c_pData->ItemPos);
-			break;
-		case EPacketCGChangeLookSubHeader::FREE_ITEM_CHECK_OUT:
-			pChangeLook->FreeItemCheckOut();
-			break;
-		case EPacketCGChangeLookSubHeader::ACCEPT:
-			pChangeLook->Accept();
-			break;
-		case EPacketCGChangeLookSubHeader::CANCEL:
-			lpCh->SetChangeLook(nullptr);
-			break;
-		default:
-			sys_err("Unknown Subheader ch:%s, %d", lpCh->GetName(), c_pData->bSubHeader);
-			return;
-	}
-}
-#endif
-
-#if defined(__SEND_TARGET_INFO__)
-void CInputMain::TargetInfo(LPCHARACTER pChar, const char* c_pszData)
-{
-	const TPacketCGTargetInfo* c_pData = reinterpret_cast<const TPacketCGTargetInfo*>(c_pszData);
-	const LPCHARACTER pkTarget = CHARACTER_MANAGER::instance().Find(c_pData->dwVID);
-	if (pChar == nullptr || pkTarget == nullptr)
-		return;
-
-	const DWORD dwVID = pkTarget->GetVID();
-	const DWORD dwRaceVnum = pkTarget->GetRaceNum();
-
-	if (pkTarget->IsMonster() || pkTarget->IsStone())
-	{
-		MonsterItemDropMap ItemDropMap; bool bDropMetinStone = false;
-		ITEM_MANAGER::instance().GetMonsterItemDropMap(pkTarget, pChar, ItemDropMap, bDropMetinStone);
-
-		TEMP_BUFFER TempBuffer;
-		for (const MonsterItemDropMap::value_type& it : ItemDropMap)
-		{
-			TPacketGCTargetDropInfo DropInfoPacket;
-			DropInfoPacket.dwVnum = it.first;
-			DropInfoPacket.bCount = it.second;
-			TempBuffer.write(&DropInfoPacket, sizeof(DropInfoPacket));
-		}
-
-		TPacketGCTargetInfo TargetInfoPacket;
-		TargetInfoPacket.bHeader = HEADER_GC_TARGET_INFO;
-		TargetInfoPacket.wSize = sizeof(TargetInfoPacket) + TempBuffer.size();
-		TargetInfoPacket.dwRaceVnum = dwRaceVnum;
-		TargetInfoPacket.dwVID = dwVID;
-		TargetInfoPacket.bDropMetinStone = bDropMetinStone;
-
-		if (TempBuffer.size())
-		{
-			pChar->GetDesc()->BufferedPacket(&TargetInfoPacket, sizeof(TargetInfoPacket));
-			pChar->GetDesc()->Packet(TempBuffer.read_peek(), TempBuffer.size());
-		}
-		else
-			pChar->GetDesc()->Packet(&TargetInfoPacket, sizeof(TargetInfoPacket));
-	}
-
-	pChar->ChatPacket(CHAT_TYPE_COMMAND, "RefreshMonsterDropInfo %d", pkTarget->GetRaceNum());
-}
-#endif
-
-#if defined(__SKILLBOOK_COMB_SYSTEM__)
-bool CInputMain::SkillBookCombination(LPCHARACTER ch, TItemPos(&CombItemGrid)[SKILLBOOK_COMB_SLOT_MAX], BYTE bAction)
-{
-	if (!ch->GetDesc())
-		return false;
-
-	// if (CombItemGrid.empty())
-		// return false;
-
-	if (ch->PreventTradeWindow(WND_ALL))
-		return false;
-
-	if (bAction != 2/*COMBI_START*/)
-		return false;
-
-	std::set <LPITEM> set_items;
-	for (int i = 0; i < SKILLBOOK_COMB_SLOT_MAX; i++)
-	{
-		LPITEM pItem = ch->GetItem(CombItemGrid[i]);
-		if (pItem)
-		{
-			if (pItem->GetType() != ITEM_SKILLBOOK)
-				return false;
-
-			set_items.insert(pItem);
-		}
-	}
-
-	if (set_items.empty())
-		return false;
-
-	if (ch->GetGold() < SKILLBOOK_COMB_COST)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Yang to trade books with me."));
-		return false;
-	}
-
-	for (std::set <LPITEM>::iterator it = set_items.begin(); it != set_items.end(); ++it)
-	{
-		LPITEM pItem = *it;
-		if (pItem)
-		{
-			pItem->SetCount(pItem->GetCount() - 1);
-			//pItem->RemoveFromCharacter();
-			//M2_DESTROY_ITEM(pItem);
-		}
-	}
-
-	DWORD dwBooks[JOB_MAX_NUM][2/*SKILL_GROUPS*/][2] = {
-		{ // 0 - Warrior
-			{50401, 50406}, // Skill Group 1
-			{50416, 50421}, // Skill Group 2
-		},
-		{ // 1 - Ninja
-			{50431, 50436}, // Skill Group 1
-			{50446, 50451}, // Skill Group 2
-		},
-		{ // 2 - Sura
-			{50461, 50466}, // Skill Group 1
-			{50476, 50481}, // Skill Group 2
-		},
-		{ // 3 - Shaman
-			{50491, 50496}, // Skill Group 1
-			{50506, 50511}, // Skill Group 2
-		},
-		{ // 4 - Wolfman
-			{50530, 50535}, // Skill Group 1
-			{0, 0}, // Skill Group 2
-		},
-	};
-
-	ch->PointChange(POINT_GOLD, -SKILLBOOK_COMB_COST);
-
-	if (ch->GetSkillGroup() != 0)
-	{
-		DWORD dwMinRandomBook = dwBooks[ch->GetJob()][ch->GetSkillGroup() - 1][0];
-		DWORD dwMaxRandomBook = dwBooks[ch->GetJob()][ch->GetSkillGroup() - 1][1];
-
-		std::random_device rd;
-		std::mt19937 gen(rd());
-		std::uniform_real_distribution<> dis(dwMinRandomBook, dwMaxRandomBook);
-		DWORD dwRandomBook = dis(gen);
-
-		ch->AutoGiveItem(dwRandomBook, 1);
-	}
-	else
-		ch->AutoGiveItem(ITEM_SKILLBOOK_VNUM, 1);
-
-	return true;
-}
-#endif
-
-#if defined(__MAILBOX__)
-void CInputMain::MailboxWrite(LPCHARACTER ch, const char* c_pData)
-{
-	const auto* p = reinterpret_cast<const TPacketCGMailboxWrite*>(c_pData);
-	if (p == nullptr)
-		return;
-
-	CMailBox* mail = ch->GetMailBox();
-	if (mail == nullptr)
-		return;
-
-	mail->Write(p->szName, p->szTitle, p->szMessage, p->pos, p->iYang, p->iWon);
-}
-
-void CInputMain::MailboxConfirm(LPCHARACTER ch, const char* c_pData)
-{
-	const auto* p = reinterpret_cast<const TPacketCGMailboxWriteConfirm*>(c_pData);
-	if (p == nullptr)
-		return;
-
-	CMailBox* mail = ch->GetMailBox();
-	if (mail == nullptr)
-		return;
-
-	mail->CheckPlayer(p->szName);
-}
-
-void CInputMain::MailboxProcess(LPCHARACTER ch, const char* c_pData)
-{
-	const auto* p = reinterpret_cast<const TPacketMailboxProcess*>(c_pData);
-	if (p == nullptr)
-		return;
-
-	CMailBox* mail = ch->GetMailBox();
-	if (mail == nullptr)
-		return;
-
-	switch (p->bSubHeader)
-	{
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_CLOSE:
-			ch->SetMailBox(nullptr);
-			break;
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_DELETE:
-			mail->DeleteMail(p->bArg1, false);
-			break;
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_DELETE:
-			mail->DeleteAllMails();
-			break;
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_GET_ITEMS:
-			mail->GetItem(p->bArg1, false);
-			break;
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_GET_ITEMS:
-			mail->GetAllItems();
-			break;
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ADD_DATA:
-			mail->AddData(p->bArg1, p->bArg2);
-			break;
-		default:
-			sys_err("CInputMain::MailboxProcess Unknown SubHeader (ch: %s) (%d)", ch->GetName(), p->bSubHeader);
-			break;
-	}
-}
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-void CInputMain::MiniGameRumi(LPCHARACTER pChar, const char* pszData)
-{
-	const TPacketCGMiniGameRumi* pkData = reinterpret_cast<const TPacketCGMiniGameRumi*>(pszData);
-	if (pkData == nullptr)
-		return;
-
-	switch (pkData->bSubHeader)
-	{
-		case RUMI_CG_SUBHEADER_END:
-			CMiniGameRumi::EndGame(pChar);
-			break;
-
-		case RUMI_CG_SUBHEADER_START:
-			CMiniGameRumi::StartGame(pChar);
-			break;
-
-		case RUMI_CG_SUBHEADER_DECK_CARD_CLICK:
-		case RUMI_CG_SUBHEADER_HAND_CARD_CLICK:
-		case RUMI_CG_SUBHEADER_FIELD_CARD_CLICK:
-			CMiniGameRumi::Analyze(pChar, pkData->bSubHeader, pkData->bUseCard, pkData->bIndex);
-			break;
-
-#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
-		case RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG:
-			CMiniGameRumi::RequestQuestFlag(pChar, RUMI_GC_SUBHEADER_SET_QUEST_FLAG);
-			break;
-#endif
-
-		default:
-			sys_err("CInputMain::MiniGameRumi Unknown SubHeader (ch: %s) (%d)", pChar->GetName(), pkData->bSubHeader);
-			break;
-	}
-}
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__)
-void CInputMain::MiniGameYutnori(LPCHARACTER pChar, const char* pszData)
-{
-	const TPacketCGMiniGameYutnori* pkData = reinterpret_cast<const TPacketCGMiniGameYutnori*>(pszData);
-	if (pkData == nullptr)
-	{
-		sys_err("CInputMain::MiniGameYutnori - Null Data! (ch: %s)", pChar->GetName());
-		return;
-	}
-
-	switch (pkData->bSubHeader)
-	{
-		case YUTNORI_CG_SUBHEADER_START:
-			CMiniGameYutnori::Create(pChar);
-			break;
-
-		case YUTNORI_CG_SUBHEADER_GIVEUP:
-			CMiniGameYutnori::Destroy(pChar);
-			break;
-
-#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-		case YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG:
-			CMiniGameYutnori::RequestQuestFlag(pChar, YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG);
-			break;
-#endif
-
-		default:
-			CMiniGameYutnori::Analyze(pChar, pkData->bSubHeader, pkData->bArgument);
-			break;
-	}
-}
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-void CInputMain::LootFilter(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGLootFilter* p = reinterpret_cast<const TPacketCGLootFilter*>(c_pData);
-	if (ch->GetLootFilter())
-		ch->GetLootFilter()->SetLootFilterSettings(p->settings);
-}
-#endif
-
-#if defined(__GEM_SHOP__)
-void CInputMain::GemShop(LPCHARACTER c_lpCh, const char* c_pszData)
-{
-	const TPacketCGGemShop* c_pPacket = reinterpret_cast<const TPacketCGGemShop*>(c_pszData);
-	if (c_pPacket == nullptr)
-		return;
-
-	CGemShop* pGemShop = c_lpCh->GetGemShop();
-	if (pGemShop == nullptr)
-		return;
-
-	switch (c_pPacket->bSubHeader)
-	{
-		case SUBHEADER_GEM_SHOP_CLOSE:
-			c_lpCh->SetGemShop(nullptr);
-			break;
-		case SUBHEADER_GEM_SHOP_BUY:
-			pGemShop->Buy(c_pPacket->bSlotIndex);
-			break;
-		case SUBHEADER_GEM_SHOP_SLOT_ADD:
-			pGemShop->AddSlot();
-			break;
-		case SUBHEADER_GEM_SHOP_REFRESH:
-			pGemShop->Refresh();
-			break;
-		default:
-			sys_err("CInputMain::GemShop Unknown SubHeader (ch: %s) (%d)", c_lpCh->GetName(), c_pPacket->bSubHeader);
-			break;
-	}
-}
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-void CInputMain::Attr67Add(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGAttr67Add* pkPacket = (TPacketCGAttr67Add*)c_pData;
-	switch (pkPacket->bySubHeader)
-	{
-		case SUBHEADER_CG_ATTR67_ADD_CLOSE:
-			ch->SetOpenAttr67Add(false);
-			break;
-		case SUBHEADER_CG_ATTR67_ADD_OPEN:
-			if (!ch->IsOpenAttr67Add())
-				ch->SetOpenAttr67Add(true);
-			break;
-		case SUBHEADER_CG_ATTR67_ADD_REGIST:
-			if (ch->IsOpenAttr67Add())
-				ch->Attr67Add(pkPacket->Attr67AddData);
-			break;
-		default:
-			return;
-	}
-}
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-void CInputMain::ExtendInven(LPCHARACTER pChar, const char* c_pszData)
-{
-	const TPacketCGExtendInven* pPacket = reinterpret_cast<const TPacketCGExtendInven*>(c_pszData);
-	if (pPacket == nullptr)
-		return;
-
-	if (pPacket->bUpgrade)
-		pChar->ExtendInvenUpgrade();
-	else
-		pChar->ExtendInvenRequest();
-}
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-void CInputMain::SnowflakeStickEvent(LPCHARACTER pChar, const char* c_pszData)
-{
-	const TPacketCGSnowflakeStickEvent* pPacket = reinterpret_cast<const TPacketCGSnowflakeStickEvent*>(c_pszData);
-	if (pPacket == nullptr)
-		return;
-
-	switch (pPacket->bSubHeader)
-	{
-		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_REQUEST_INFO:
-			CSnowflakeStickEvent::Process(pChar, SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO);
-			break;
-
-		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_STICK:
-		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_PET:
-		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_MOUNT:
-			CSnowflakeStickEvent::Exchange(pChar, pPacket->bSubHeader);
-			break;
-
-		default:
-			return;
-	}
-}
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-void CInputMain::RefineElement(LPCHARACTER pChar, const char* c_pszData)
-{
-	const TPacketCGRefineElement* pPacket = reinterpret_cast<const TPacketCGRefineElement*>(c_pszData);
-	if (pPacket == nullptr)
-		return;
-
-	switch (pPacket->bSubHeader)
-	{
-		case REFINE_ELEMENT_CG_CLOSE:
-			pChar->SetUnderRefineElement(false);
-			break;
-
-		case REFINE_ELEMENT_CG_REFINE:
-			pChar->RefineElement(pPacket->wChangeElement);
-			break;
-
-		default:
-			sys_err("CInputMain::RefineElement: %s received unknown sub header.", pChar->GetName());
-			break;
-	}
-}
-#endif
-
-#if defined(__LEFT_SEAT__)
-void CInputMain::LeftSeat(LPCHARACTER pChar, const char* c_pszData)
-{
-	const TPacketCGLeftSeat* c_pPacket = reinterpret_cast<const TPacketCGLeftSeat*>(c_pszData);
-	if (c_pPacket == nullptr)
-		return;
-
-	switch (c_pPacket->bSubHeader)
-	{
-		case LEFT_SEAT_SET_WAIT_TIME_INDEX:
-			pChar->SetLeftSeatWaitTime(c_pPacket->bIndex);
-			break;
-
-		case LEFT_SEAT_SET_LOGOUT_TIME_INDEX:
-			pChar->SetLeftSeatLogoutTime(c_pPacket->bIndex);
-			break;
-
-		case LEFT_SEAT_DISABLE_LOGOUT_STATE:
-			pChar->DisableLeftSeatLogOutState(false);
-			break;
-
-		default:
-			sys_err("CInputMain::LeftSeat: %s received unknown sub header.", pChar->GetName());
-			break;
-	}
-}
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-void CInputMain::MiniGameRoulette(LPCHARACTER pChar, const char* pszData)
-{
-	const TPacketCGMiniGameRoulette* pData = reinterpret_cast<const TPacketCGMiniGameRoulette*>(pszData);
-	if (pData == nullptr)
-	{
-		sys_err("CInputMain::MiniGameRoulette : Data NULL (ch: %s)", pChar->GetName());
-		return;
-	}
-
-	CMiniGameRoulette* pMiniGameRoulette = pChar->GetMiniGameRoulette();
-	if (pMiniGameRoulette == nullptr)
-	{
-		sys_err("CInputMain::MiniGameRoulette : MiniGameRoulette NULL (ch: %s)", pChar->GetName());
-		return;
-	}
-
-	switch (pData->bSubHeader)
-	{
-		case ROULETTE_CG_START:
-			pMiniGameRoulette->Start();
-			break;
-
-		case ROULETTE_CG_REQUEST:
-			pMiniGameRoulette->Request();
-			break;
-
-		case ROULETTE_CG_END:
-			pMiniGameRoulette->End();
-			break;
-
-		case ROULETTE_CG_CLOSE:
-			pMiniGameRoulette->Close();
-			break;
-
-		default:
-			sys_err("CInputMain::MiniGameRoulette : Unknown SubHeader %u (ch: %s)",
-				pData->bSubHeader, pChar->GetName());
-			break;
-	}
-}
-#endif
-
-#if defined(__FLOWER_EVENT__)
-void CInputMain::FlowerEvent(LPCHARACTER pChar, const char* pszData)
-{
-	if (!quest::CQuestManager::instance().GetEventFlag("e_flower_drop"))
-		return;
-
-	const TPacketCGFlowerEvent* pPacketData = reinterpret_cast<const TPacketCGFlowerEvent*>(pszData);
-	if (NULL == pPacketData)
-	{
-		sys_err("NULL TPacketCGFlowerEvent (ch: %s)", pChar->GetName());
-		return;
-	}
-
-	switch (pPacketData->bSubHeader)
-	{
-		case FLOWER_EVENT_SUBHEADER_CG_INFO_ALL:
-			CFlowerEvent::RequestAllInfo(pChar);
-			break;
-
-		case FLOWER_EVENT_SUBHEADER_CG_EXCHANGE:
-			CFlowerEvent::Exchange(pChar, pPacketData->bShootType, pPacketData->bExchangeKey);
-			break;
-
-		default:
-			sys_err("Unknown SubHeader %u (ch: %s)",
-				pPacketData->bSubHeader, pChar->GetName());
-			break;
-	}
-}
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-int CInputMain::ReciveExtBattlePassActions(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	TPacketCGExtBattlePassAction* p = (TPacketCGExtBattlePassAction*)data;
-
-	if (uiBytes < sizeof(TPacketCGExtBattlePassAction))
-		return -1;
-
-	const char* c_pData = data + sizeof(TPacketCGExtBattlePassAction);
-	uiBytes -= sizeof(TPacketCGExtBattlePassAction);
-
-	switch (p->bAction)
-	{
-		case 1:
-			CBattlePassManager::instance().BattlePassRequestOpen(ch);
-			return 0;
-
-		case 2:
-			if(get_dword_time() < ch->GetLastReciveExtBattlePassOpenRanking()) {
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NEXT_REFRESH_RANKLIST_TIME"), ((ch->GetLastReciveExtBattlePassOpenRanking() - get_dword_time()) / 1000) + 1 );
-				return 0;
-			}
-			ch->SetLastReciveExtBattlePassOpenRanking(get_dword_time() + 10000);
-			
-			for (BYTE bBattlePassType = 1; bBattlePassType <= 3 ; ++bBattlePassType)
-			{
-				BYTE bBattlePassID;
-				if (bBattlePassType == 1)
-					bBattlePassID = CBattlePassManager::instance().GetNormalBattlePassID();
-				if (bBattlePassType == 2){
-					bBattlePassID = CBattlePassManager::instance().GetPremiumBattlePassID();
-					if (bBattlePassID != ch->GetExtBattlePassPremiumID())
-						continue;
-				}
-				if (bBattlePassType == 3)
-					bBattlePassID = CBattlePassManager::instance().GetEventBattlePassID();
-
-				std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("SELECT player_name, battlepass_type+0, battlepass_id, UNIX_TIMESTAMP(start_time), UNIX_TIMESTAMP(end_time) FROM player.battlepass_playerindex WHERE battlepass_type = %d and battlepass_id = %d and battlepass_completed = 1 and not player_name LIKE '[%%' ORDER BY (UNIX_TIMESTAMP(end_time)-UNIX_TIMESTAMP(start_time)) ASC LIMIT 40", bBattlePassType, bBattlePassID));
-				if (pMsg->uiSQLErrno)
-					return 0;
-
-				MYSQL_ROW row;
-
-				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-				{
-					TPacketGCExtBattlePassRanking pack;
-					pack.bHeader = HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING;
-					strlcpy(pack.szPlayerName, row[0], sizeof(pack.szPlayerName));
-					pack.bBattlePassType = std::atoi(row[1]);
-					pack.bBattlePassID = std::atoll(row[2]);
-					pack.dwStartTime = std::atoll(row[3]);
-					pack.dwEndTime = std::atoll(row[4]);
-
-					ch->GetDesc()->Packet(&pack, sizeof(pack));
-				}
-			}
-			break;
-
-		case 10:
-			CBattlePassManager::instance().BattlePassRequestReward(ch, 1);
-			return 0;
-			
-		case 11:
-			CBattlePassManager::instance().BattlePassRequestReward(ch, 2);
-			return 0;
-			
-		case 12:
-			CBattlePassManager::instance().BattlePassRequestReward(ch, 3);
-			return 0;
-
-
-		default:
-			break;
-	}
-
-	return 0;
-}
-
-int CInputMain::ReciveExtBattlePassPremiumItem(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	TPacketCGExtBattlePassSendPremiumItem* p = (TPacketCGExtBattlePassSendPremiumItem*)data;
-
-	if (uiBytes < sizeof(TPacketCGExtBattlePassSendPremiumItem))
-		return -1;
-
-	const char* c_pData = data + sizeof(TPacketCGExtBattlePassSendPremiumItem);
-	uiBytes -= sizeof(TPacketCGExtBattlePassSendPremiumItem);
-
-	LPITEM item = ch->GetInventoryItem(p->iSlotIndex);
-	if (item != NULL and item->GetVnum() == 93100)
-	{
-		ch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, CBattlePassManager::instance().GetPremiumBattlePassID());
-		CBattlePassManager::instance().BattlePassRequestOpen(ch);
-		item->SetCount(item->GetCount() - 1);
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NOW_IS_ACTIVATED_PREMIUM_BATTLEPASS_OWN"));
-	}
-	return 0;
-}
-#endif
-
-int CInputMain::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
-{
-	LPCHARACTER ch;
-
-	if (!(ch = d->GetCharacter()))
-	{
-		sys_err("no character on desc");
-		d->SetPhase(PHASE_CLOSE);
-		return (0);
-	}
-
-	int iExtraLen = 0;
-
-	if (test_server && bHeader != HEADER_CG_MOVE)
-		sys_log(0, "CInputMain::Analyze() ==> Header [%d] ", bHeader);
-
-#if defined(__LEFT_SEAT__)
-	const std::unordered_set<BYTE> bExcludeLeftSeatHeader = {
-		HEADER_CG_LEFT_SEAT,
-		HEADER_CG_TIME_SYNC,
-		HEADER_CG_PONG,
-	};
-
-	if (bExcludeLeftSeatHeader.find(bHeader) == bExcludeLeftSeatHeader.end())
-	{
-		if (ch->LeftSeat())
-			ch->DisableLeftSeatLogOutState(true);
-
-		ch->SetLastRequestTime(get_dword_time());
-	}
-#endif
-
-	switch (bHeader)
-	{
-		case HEADER_CG_PONG:
-			Pong(d);
-			break;
-
-		case HEADER_CG_TIME_SYNC:
-			Handshake(d, c_pData);
-			break;
-
-		case HEADER_CG_CHAT:
-			if (test_server)
-			{
-				char* pBuf = (char*)c_pData;
-				sys_log(0, "%s", pBuf + sizeof(TPacketCGChat));
-			}
-
-			if ((iExtraLen = Chat(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-
-			break;
-
-		case HEADER_CG_WHISPER:
-			if ((iExtraLen = Whisper(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_MOVE:
-			Move(ch, c_pData);
-			break;
-
-		case HEADER_CG_CHARACTER_POSITION:
-			Position(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_USE:
-			if (!ch->IsObserverMode())
-				ItemUse(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_DROP:
-			if (!ch->IsObserverMode())
-			{
-				ItemDrop(ch, c_pData);
-			}
-			break;
-
-		case HEADER_CG_ITEM_DROP2:
-			if (!ch->IsObserverMode())
-				ItemDrop2(ch, c_pData);
-			break;
-
-#if defined(__NEW_DROP_DIALOG__)
-		case HEADER_CG_ITEM_DESTROY:
-			if (!ch->IsObserverMode())
-				ItemDestroy(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_ITEM_MOVE:
-			if (!ch->IsObserverMode())
-				ItemMove(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_PICKUP:
-			if (!ch->IsObserverMode())
-				ItemPickup(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_USE_TO_ITEM:
-			if (!ch->IsObserverMode())
-				ItemToItem(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_GIVE:
-			if (!ch->IsObserverMode())
-				ItemGive(ch, c_pData);
-			break;
-
-		case HEADER_CG_EXCHANGE:
-			if (!ch->IsObserverMode())
-				Exchange(ch, c_pData);
-			break;
-
-		case HEADER_CG_ATTACK:
-		case HEADER_CG_SHOOT:
-			if (!ch->IsObserverMode())
-			{
-				Attack(ch, bHeader, c_pData);
-			}
-			break;
-
-		case HEADER_CG_USE_SKILL:
-			if (!ch->IsObserverMode())
-				UseSkill(ch, c_pData);
-			break;
-
-#ifdef __OFFLINE_SHOP__
-		case HEADER_CG_OFFLINE_SHOP:
-		{
-			if ((iExtraLen = COfflineShop::ReceivePacket(ch, c_pData, m_iBufferLeft)) < 0) {
-				return -1;
-			}
-
-			break;
-		}
-#endif
-
-#ifdef __SHOP_SEARCH__
-		case HEADER_CG_SHOP_SEARCH_BY_NAME:
-			ShopSearchByName(ch, c_pData);
-			break;
-
-		case HEADER_CG_SHOP_SEARCH_BY_OPTION:
-			if ((iExtraLen = ShopSearchByOptions(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_SHOP_SEARCH_BUY:
-			ShopSearchBuy(ch, c_pData);
-			break;
-
-		case HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE:
-			ShopSearchOwnerMessage(ch, c_pData);
-			break;
-
-		case HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO:
-			ShopSearchRequestSoldInfo(ch, c_pData);
-			break;
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-		case HEADER_CG_PET_HATCH:
-			PetHatch(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_WINDOW:
-			PetWindow(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_WINDOW_TYPE:
-			PetWindowType(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_NAME_CHANGE:
-			PetNameChange(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_FEED:
-			PetFeed(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_DETERMINE:
-			PetDetermine(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_ATTR_CHANGE:
-			PetAttrChange(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_REVIVE:
-			PetRevive(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_LEARN_SKILL:
-			PetLearnSkill(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_SKILL_UPGRADE:
-			PetSkillUpgrade(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_DELETE_SKILL:
-			PetDeleteSkill(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_DELETE_ALL_SKILL:
-			PetDeleteAllSkill(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_QUICKSLOT_ADD:
-			QuickslotAdd(ch, c_pData);
-			break;
-
-		case HEADER_CG_QUICKSLOT_DEL:
-			QuickslotDelete(ch, c_pData);
-			break;
-
-		case HEADER_CG_QUICKSLOT_SWAP:
-			QuickslotSwap(ch, c_pData);
-			break;
-
-		case HEADER_CG_SHOP:
-			if ((iExtraLen = Shop(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_MESSENGER:
-			if ((iExtraLen = Messenger(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_ON_CLICK:
-			OnClick(ch, c_pData);
-			break;
-
-		case HEADER_CG_SYNC_POSITION:
-			if ((iExtraLen = SyncPosition(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_ADD_FLY_TARGETING:
-		case HEADER_CG_FLY_TARGETING:
-			FlyTarget(ch, c_pData, bHeader);
-			break;
-
-		case HEADER_CG_SCRIPT_BUTTON:
-			ScriptButton(ch, c_pData);
-			break;
-
-			// SCRIPT_SELECT_ITEM
-		case HEADER_CG_SCRIPT_SELECT_ITEM:
-			ScriptSelectItem(ch, c_pData);
-			break;
-			// END_OF_SCRIPT_SELECT_ITEM
-
-		case HEADER_CG_SCRIPT_ANSWER:
-			ScriptAnswer(ch, c_pData);
-			break;
-
-#if defined(__GEM_SYSTEM__)
-		case HEADER_CG_SELECT_ITEM_EX:
-			SelectItemEx(ch, c_pData);
-			break;
-#endif
-
-#if defined(__QUEST_REQUEST_EVENT__)
-		case HEADER_CG_REQUEST_EVENT_QUEST:
-			RequestEventQuest(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_QUEST_INPUT_STRING:
-			QuestInputString(ch, c_pData);
-			break;
-
-#if defined(__OX_RENEWAL__)
-		case HEADER_CG_QUEST_INPUT_LONG_STRING:
-			QuestInputLongString(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_QUEST_CONFIRM:
-			QuestConfirm(ch, c_pData);
-			break;
-
-		case HEADER_CG_TARGET:
-			Target(ch, c_pData);
-			break;
-
-		case HEADER_CG_WARP:
-			Warp(ch, c_pData);
-			break;
-
-		case HEADER_CG_SAFEBOX_CHECKIN:
-			SafeboxCheckin(ch, c_pData);
-			break;
-
-		case HEADER_CG_SAFEBOX_CHECKOUT:
-			SafeboxCheckout(ch, c_pData, false);
-			break;
-
-		case HEADER_CG_SAFEBOX_ITEM_MOVE:
-			SafeboxItemMove(ch, c_pData);
-			break;
-
-		case HEADER_CG_MALL_CHECKOUT:
-			SafeboxCheckout(ch, c_pData, true);
-			break;
-
-		case HEADER_CG_PARTY_INVITE:
-			PartyInvite(ch, c_pData);
-			break;
-
-		case HEADER_CG_PARTY_REMOVE:
-			PartyRemove(ch, c_pData);
-			break;
-
-		case HEADER_CG_PARTY_INVITE_ANSWER:
-			PartyInviteAnswer(ch, c_pData);
-			break;
-
-		case HEADER_CG_PARTY_SET_STATE:
-			PartySetState(ch, c_pData);
-			break;
-
-		case HEADER_CG_PARTY_USE_SKILL:
-			PartyUseSkill(ch, c_pData);
-			break;
-
-		case HEADER_CG_PARTY_PARAMETER:
-			PartyParameter(ch, c_pData);
-			break;
-
-		case HEADER_CG_ANSWER_MAKE_GUILD:
-			AnswerMakeGuild(ch, c_pData);
-			break;
-
-		case HEADER_CG_GUILD:
-			if ((iExtraLen = Guild(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_FISHING:
-			Fishing(ch, c_pData);
-			break;
-
-#if defined(__FISHING_GAME__)
-		case HEADER_CG_FISHING_GAME:
-			FishingGame(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_HACK:
-			Hack(ch, c_pData);
-			break;
-
-		case HEADER_CG_MYSHOP:
-			if ((iExtraLen = MyShop(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-#if defined(__MYSHOP_DECO__)
-		case HEADER_CG_MYSHOP_DECO_STATE:
-			MyShopDecoState(ch, c_pData);
-			break;
-
-		case HEADER_CG_MYSHOP_DECO_ADD:
-			MyShopDecoAdd(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_REFINE:
-			Refine(ch, c_pData);
-			break;
-
-#if defined(__CUBE_RENEWAL__)
-		case HEADER_CG_CUBE:
-			Cube(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_CLIENT_VERSION:
-			Version(ch, c_pData);
-			break;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case HEADER_CG_DRAGON_SOUL_REFINE:
-		{
-			TPacketCGDragonSoulRefine* p = reinterpret_cast <TPacketCGDragonSoulRefine*>((void*)c_pData);
-			switch (p->bSubType)
-			{
-				case DS_SUB_HEADER_CLOSE:
-					ch->DragonSoul_RefineWindow_Close();
-					break;
-
-				case DS_SUB_HEADER_DO_REFINE_GRADE:
-				{
-					DSManager::instance().DoRefineGrade(ch, p->ItemGrid);
-				}
-				break;
-
-				case DS_SUB_HEADER_DO_REFINE_STEP:
-				{
-					DSManager::instance().DoRefineStep(ch, p->ItemGrid);
-				}
-				break;
-
-				case DS_SUB_HEADER_DO_REFINE_STRENGTH:
-				{
-					DSManager::instance().DoRefineStrength(ch, p->ItemGrid);
-				}
-				break;
-
-#if defined(__DS_CHANGE_ATTR__)
-				case DS_SUB_HEADER_DO_CHANGE_ATTR:
-				{
-					DSManager::instance().DoChangeAttribute(ch, p->ItemGrid);
-				}
-				break;
-#endif
-			}
-		}
-		break;
-#endif
-
-#if defined(__SEND_TARGET_INFO__)
-		case HEADER_CG_TARGET_INFO:
-			TargetInfo(ch, c_pData);
-			break;
-#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-		case HEADER_CG_ITEM_COMBINATION:
-			ItemCombination(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_COMBINATION_CANCEL:
-			ItemCombinationCancel(ch, c_pData);
-			break;
-#endif
-
-#if defined(__CHANGED_ATTR__)
-		case HEADER_CG_ITEM_SELECT_ATTR:
-			ItemSelectAttr(ch, c_pData);
-			break;
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case HEADER_CG_ACCE_REFINE:
-			if ((iExtraLen = AcceRefine(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-		case HEADER_CG_AURA_REFINE:
-			if ((iExtraLen = AuraRefine(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		case HEADER_CG_CHANGE_LOOK:
-			ChangeLook(ch, c_pData);
-			break;
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__)
-		case HEADER_CG_MINI_GAME_CATCH_KING:
-			if ((iExtraLen = CMiniGameCatchKing::Process(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-#endif
-
-#if defined(__SKILLBOOK_COMB_SYSTEM__)
-		case HEADER_CG_SKILLBOOK_COMB:
-		{
-			TPacketCGSkillBookCombination* p = reinterpret_cast <TPacketCGSkillBookCombination*>((void*)c_pData);
-			SkillBookCombination(ch, p->CombItemGrid, p->bAction);
-		}
-		break;
-#endif
-
-#if defined(__MAILBOX__)
-		case HEADER_CG_MAILBOX_WRITE:
-			MailboxWrite(ch, c_pData);
-			break;
-
-		case HEADER_CG_MAILBOX_WRITE_CONFIRM:
-			MailboxConfirm(ch, c_pData);
-			break;
-
-		case HEADER_CG_MAILBOX_PROCESS:
-			MailboxProcess(ch, c_pData);
-			break;
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-		case HEADER_CG_LOOT_FILTER:
-			LootFilter(ch, c_pData);
-			break;
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-		case HEADER_CG_MINI_GAME_RUMI:
-			MiniGameRumi(ch, c_pData);
-			break;
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__)
-		case HEADER_CG_MINI_GAME_YUTNORI:
-			MiniGameYutnori(ch, c_pData);
-			break;
-#endif
-
-#if defined(__LUCKY_BOX__)
-		case HEADER_CG_LUCKY_BOX:
-			LuckyBox(ch, c_pData);
-			break;
-#endif
-
-#if defined(__GEM_SHOP__)
-		case HEADER_CG_GEM_SHOP:
-			GemShop(ch, c_pData);
-			break;
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		case HEADER_CG_EXTEND_INVEN:
-			ExtendInven(ch, c_pData);
-			break;
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-		case HEADER_CG_ATTR67_ADD:
-			Attr67Add(ch, c_pData);
-			break;
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-		case HEADER_CG_SNOWFLAKE_STICK_EVENT:
-			SnowflakeStickEvent(ch, c_pData);
-			break;
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		case HEADER_CG_REFINE_ELEMENT:
-			RefineElement(ch, c_pData);
-			break;
-#endif
-
-#if defined(__LEFT_SEAT__)
-		case HEADER_CG_LEFT_SEAT:
-			LeftSeat(ch, c_pData);
-			break;
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-		case HEADER_CG_MINI_GAME_ROULETTE:
-			MiniGameRoulette(ch, c_pData);
-			break;
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-		case HEADER_CG_FLOWER_EVENT:
-			FlowerEvent(ch, c_pData);
-			break;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		case HEADER_CG_EXT_BATTLE_PASS_ACTION:
-			if ((iExtraLen = ReciveExtBattlePassActions(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-			
-		case HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM:
-			if ((iExtraLen = ReciveExtBattlePassPremiumItem(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-#endif
-	}
-
-	return (iExtraLen);
-}
-
-#if defined(__LUCKY_BOX__)
-void CInputMain::LuckyBox(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGLuckyBox* c_pPacket = reinterpret_cast<const TPacketCGLuckyBox*>(c_pData);
-
-	switch (c_pPacket->bAction)
-	{
-		case ELUCKY_BOX_ACTION::LUCKY_BOX_ACTION_RETRY:
-			ch->LuckyBoxRetry();
-			break;
-		case ELUCKY_BOX_ACTION::LUCKY_BOX_ACTION_RECEIVE:
-			ch->LuckyBoxReceive();
-			break;
-		default:
-			sys_err("CInputMain::LuckyBox : Unknown action %d : %s", c_pPacket->bAction, ch->GetName());
-			return;
-	}
-}
-#endif
-
-#ifdef __SHOP_SEARCH__
-void CInputMain::ShopSearchByName(LPCHARACTER ch, const char* data)
-{
-	if (!ch || !ch->GetDesc())
-		return;
-
-	if (!ch->CheckShopSearchFlood())
-		return;
-
-	TPacketCGShopSearchByName* p = (TPacketCGShopSearchByName*)data;
-
-	const size_t nameLen = strnlen(p->itemName, sizeof(p->itemName));
-	if (nameLen == 0 || nameLen >= sizeof(p->itemName))
-		return;
-
-	// Prevent extremely expensive broad searches (e.g. "a")
-	if (nameLen < 2)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Search term is too short."));
-		return;
-	}
-
-	CShopSearchManager::PC_RequestSearch(ch, p->itemName, p->page, p->entryCountIdx, p->sortType);
-}
-
-int CInputMain::ShopSearchByOptions(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	if (!ch || !ch->GetDesc())
-		return -1;
-
-	if (!ch->CheckShopSearchFlood())
-		return -1;
-
-	TPacketCGShopSearchByOptions* p = (TPacketCGShopSearchByOptions*)data;
-	// Hard upper bounds to avoid pathological packets.
-	if (p->options.typeFlagCount > 32 || p->options.specificVnumCount > 32)
-		return -1;
-	data += sizeof(TPacketCGShopSearchByOptions);
-	uiBytes -= sizeof(TPacketCGShopSearchByOptions);
-
-	if (uiBytes < sizeof(TShopSearchItemType) * p->options.typeFlagCount)
-		return -1;
-
-	TShopSearchItemType* itemTypeFlags = (TShopSearchItemType*)data;
-	data += sizeof(TShopSearchItemType) * p->options.typeFlagCount;
-	uiBytes -= sizeof(TShopSearchItemType) * p->options.typeFlagCount;
-
-	if (uiBytes < sizeof(DWORD) * p->options.specificVnumCount)
-		return -1;
-
-	CShopSearchManager::PC_RequestSearch(ch, &p->options, itemTypeFlags, (const DWORD*)data, p->page, p->entryCountIdx, p->sortType);
-
-	return sizeof(TShopSearchItemType) * p->options.typeFlagCount + sizeof(DWORD) * p->options.specificVnumCount;
-}
-
-void CInputMain::ShopSearchBuy(LPCHARACTER ch, const char* data)
-{
-	if (!ch || !ch->GetDesc())
-		return;
-
-	// Buying can also be spammed; keep it under control.
-	if (!ch->CheckShopSearchFlood())
-		return;
-
-	TPacketCGShopSearchBuy* p = (TPacketCGShopSearchBuy*)data;
-
-	CShopSearchManager::PC_RequestBuy(ch, p->itemID, p->itemVnum, p->itemPrice);
-}
-
-void CInputMain::ShopSearchOwnerMessage(LPCHARACTER ch, const char* data)
-{
-	if (!ch || !ch->GetDesc())
-		return;
-
-	if (!ch->CheckShopSearchFlood())
-		return;
-
-	TPacketCGShopSearchOwnerMessage* p = (TPacketCGShopSearchOwnerMessage*)data;
-
-	TPacketGCShopSearchOwnerMessage pack;
-	pack.header = HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE;
-	memset(pack.ownerName, 0, sizeof(pack.ownerName));
-
-	if (LPCHARACTER tch = CHARACTER_MANAGER::instance().FindByPID(p->ownerID))
-		strlcpy(pack.ownerName, tch->GetName(), sizeof(pack.ownerName));
-	else if (CCI* pkCCI = P2P_MANAGER::instance().FindByPID(p->ownerID))
-		strlcpy(pack.ownerName, pkCCI->szName, sizeof(pack.ownerName));
-	else
-	{
-		std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("SELECT name FROM player WHERE id = %u", p->ownerID));
-		if (MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult))
-		{
-			strlcpy(pack.ownerName, row[0], sizeof(pack.ownerName));
-		}
-	}
-
-	ch->GetDesc()->Packet(&pack, sizeof(pack));
-}
-
-void CInputMain::ShopSearchRequestSoldInfo(LPCHARACTER ch, const char* data)
-{
-	if (!ch || !ch->GetDesc())
-		return;
-
-	if (!ch->CheckShopSearchFlood())
-		return;
-
-	TPacketCGShopSearchRequestSoldInfo* p = (TPacketCGShopSearchRequestSoldInfo*)data;
-
-	CShopSearchManager::PC_RequestSoldInfo(ch, p->itemVnum);
-}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-void CInputMain::PetHatch(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetHatch* p = reinterpret_cast<const TPacketCGPetHatch*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-	
-	CGrowthPetManager::Instance().EggHatch(ch, p->name, p->eggPos);
-}
-
-void CInputMain::PetWindow(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetWindow* p = reinterpret_cast<const TPacketCGPetWindow*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	switch (p->window)
-	{
-		case PET_WINDOW_HATCH:
-			ch->SetPetHatchWindow(p->state);
-			break;
-
-		case PET_WINDOW_NAME_CHANGE:
-			ch->SetPetChangeNameWindow(p->state);
-			break;
-	}
-}
-
-void CInputMain::PetWindowType(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetWindowType* p = reinterpret_cast<const TPacketCGPetWindowType*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	BYTE bWindowType = p->type;
-
-	if (bWindowType == ch->GetPetWindowType())
-		return;
-
-	if (bWindowType == PET_WINDOW_ATTR_CHANGE || bWindowType == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-
-		if ((ch->GetExchange() || ch->IsOpenSafebox() || ch->GetShopOwner()) || ch->IsCubeOpen())
-			return;
-	}
-
-	ch->SetPetWindowType(bWindowType);
-
-	TPacketGCPet packet;
-	packet.header = HEADER_GC_PET;
-	packet.subheader = SUBHEADER_PET_WINDOW_TYPE_INFO + bWindowType;
-
-	ch->GetDesc()->Packet(&packet, sizeof(packet));
-}
-
-void CInputMain::PetFeed(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetFeed* p = reinterpret_cast<const TPacketCGPetFeed*>(c_pData);
-	
-	if (!ch || !ch->GetDesc())
-		return;
-
-	if (ch->GetActiveGrowthPet())
-		ch->GetActiveGrowthPet()->Feed(p);
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-}
-
-void CInputMain::PetDetermine(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetDetermine* p = reinterpret_cast<const TPacketCGPetDetermine*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pDetermineItem = ch->GetInventoryItem(p->determinePos.cell);
-	if (!pDetermineItem)
-		return;
-
-	if (pDetermineItem->GetType() != ITEM_PET || pDetermineItem->GetSubType() != PET_ATTR_DETERMINE)
-		return;
-
-	if (!ch->GetActiveGrowthPet())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-		return;
-	}
-
-	ch->GetActiveGrowthPet()->AttrDetermine(pDetermineItem);
-}
-
-void CInputMain::PetAttrChange(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetAttrChange* p = reinterpret_cast<const TPacketCGPetAttrChange*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
-	if (!pUpBringingItem)
-		return;
-
-	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
-		return;
-
-	LPITEM pChangeAttrItem = ch->GetInventoryItem(p->attrChangePos.cell);
-	if (!pChangeAttrItem)
-		return;
-
-	if (pChangeAttrItem->GetType() != ITEM_PET || pChangeAttrItem->GetSubType() != PET_ATTR_CHANGE)
-		return;
-
-	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
-	if (!pPet)
-		return;
-
-	pPet->AttrChange(pUpBringingItem, pChangeAttrItem);
-}
-
-void CInputMain::PetRevive(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetRevive* p = reinterpret_cast<const TPacketCGPetRevive*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
-	if (!pUpBringingItem)
-		return;
-
-	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
-		return;
-
-	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
-	if (!pPet)
-		return;
-
-	pPet->PremiumFeed(p, pUpBringingItem);
-}
-
-void CInputMain::PetLearnSkill(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetLearnSkill* p = reinterpret_cast<const TPacketCGPetLearnSkill*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pSkillBookItem = ch->GetInventoryItem(p->learnSkillPos.cell);
-	if (!pSkillBookItem)
-		return;
-
-	if (pSkillBookItem->GetType() != ITEM_PET || pSkillBookItem->GetSubType() != PET_SKILL)
-		return;
-
-	if (!ch->GetActiveGrowthPet())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-		return;
-	}
-
-	ch->GetActiveGrowthPet()->LearnSkill(p->slotIndex, pSkillBookItem);
-}
-
-void CInputMain::PetSkillUpgrade(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetSkillUpgrade* p = reinterpret_cast<const TPacketCGPetSkillUpgrade*>(c_pData);
-
-	if (!ch->GetActiveGrowthPet())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-		return;
-	}
-
-	ch->GetActiveGrowthPet()->SkillUpgrade(p->slotIndex);
-}
-
-void CInputMain::PetDeleteSkill(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetDeleteSkill* p = reinterpret_cast<const TPacketCGPetDeleteSkill*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pDeleteSkillItem = ch->GetInventoryItem(p->deleteSkillPos.cell);
-	if (!pDeleteSkillItem)
-		return;
-
-	if (pDeleteSkillItem->GetType() != ITEM_PET || pDeleteSkillItem->GetSubType() != PET_SKILL_DEL_BOOK)
-		return;
-
-	if (!ch->GetActiveGrowthPet())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-		return;
-	}
-
-	ch->GetActiveGrowthPet()->DeleteSkill(p->slotIndex, pDeleteSkillItem);
-}
-
-void CInputMain::PetDeleteAllSkill(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetDeleteAllSkill* p = reinterpret_cast<const TPacketCGPetDeleteAllSkill*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pDeleteAllSkillItem = ch->GetInventoryItem(p->deleteAllSkillPos.cell);
-	if (!pDeleteAllSkillItem)
-		return;
-
-	if (pDeleteAllSkillItem->GetType() != ITEM_PET || pDeleteAllSkillItem->GetSubType() != PET_SKILL_ALL_DEL_BOOK)
-		return;
-
-	if (!ch->GetActiveGrowthPet())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-		return;
-	}
-
-	ch->GetActiveGrowthPet()->DeleteAllSkill(pDeleteAllSkillItem);
-}
-
-void CInputMain::PetNameChange(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetNameChange* p = reinterpret_cast<const TPacketCGPetNameChange*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pNameChangeItem = ch->GetInventoryItem(p->changeNamePos.cell);
-	if (!pNameChangeItem)
-		return;
-
-	if (pNameChangeItem->GetType() != ITEM_PET || pNameChangeItem->GetSubType() != PET_NAME_CHANGE)
-		return;
-
-	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
-	if (!pUpBringingItem)
-		return;
-
-	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
-		return;
-
-	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
-	if (!pPet)
-		return;
-
-	if (pPet->GetOwner() != ch)
-		return;
-
-	pPet->NameChange(p->name, pNameChangeItem, pUpBringingItem);
-}
-#endif
-
-int CInputDead::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
-{
-	LPCHARACTER ch;
-
-	if (!(ch = d->GetCharacter()))
-	{
-		sys_err("no character on desc");
-		return 0;
-	}
-
-	int iExtraLen = 0;
-
-	switch (bHeader)
-	{
-		case HEADER_CG_PONG:
-			Pong(d);
-			break;
-
-		case HEADER_CG_TIME_SYNC:
-			Handshake(d, c_pData);
-			break;
-
-		case HEADER_CG_CHAT:
-			if ((iExtraLen = Chat(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-
-			break;
-
-		case HEADER_CG_WHISPER:
-			if ((iExtraLen = Whisper(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-
-			break;
-
-		case HEADER_CG_HACK:
-			Hack(ch, c_pData);
-			break;
-
-		default:
-			return (0);
-	}
-
-	return (iExtraLen);
-}
+#include "stdafx.h"
+#include <cstring>
+#include "constants.h"
+#include "config.h"
+#include "utils.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "buffer_manager.h"
+#include "packet.h"
+#include "protocol.h"
+#include "char.h"
+#include "char_manager.h"
+#include "item.h"
+#include "item_manager.h"
+#ifdef ENABLE_QUEEN_NETHIS
+#include "SnakeLair.h"
+#endif
+#include "cmd.h"
+#include "shop.h"
+#include "shop_manager.h"
+#include "safebox.h"
+#include "regen.h"
+#include "battle.h"
+#include "exchange.h"
+#include "questmanager.h"
+#include "profiler.h"
+#include "messenger_manager.h"
+#include "party.h"
+#include "p2p.h"
+#include "affect.h"
+#include "guild.h"
+#include "guild_manager.h"
+#include "log.h"
+#include "banword.h"
+#include "empire_text_convert.h"
+#include "unique_item.h"
+#include "building.h"
+#include "locale_service.h"
+#include "gm.h"
+#include "spam.h"
+#include "ani.h"
+#include "motion.h"
+#include "OXEvent.h"
+#include "locale_service.h"
+#include "DragonSoul.h"
+#include "belt_inventory_helper.h"
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+#	include "LootFilter.h"
+#endif
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+#	include "xmas_event.h"
+#endif
+
+#if defined(__DEFENSE_WAVE__)
+#	include "defense_wave.h"
+#endif
+
+#if defined(__OFFLINE_SHOP__)
+#include "OfflineShop.h"
+#endif
+
+#if defined(__SHOP_SEARCH__)
+	#include "ShopSearchManager.h"
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+#include "battlepass_manager.h"
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+#include "growth_pet.h"
+#endif
+
+extern void SendShout(const char* szText, BYTE bEmpire
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	, const char* c_szName
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	, const char* c_szCountry
+#endif
+);
+
+extern int g_nPortalLimitTime;
+
+static int __deposit_limit()
+{
+	return (1000 * 10000); // 1천
+}
+
+void SendBlockChatInfo(LPCHARACTER ch, int sec)
+{
+	if (sec <= 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("채  都求."));
+		return;
+	}
+
+	long hour = sec / 3600;
+	sec -= hour * 3600;
+
+	long min = (sec / 60);
+	sec -= min * 60;
+
+	if (hour > 0 && min > 0)
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d 챨 %d  %d   채챰 都求", hour, min, sec));
+	else if (hour > 0 && min == 0)
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d 챨 %d   채챰 都求", hour, sec));
+	else if (hour == 0 && min > 0)
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d  %d   채챰 都求", min, sec));
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d   채챰 都求", sec));
+}
+
+EVENTINFO(spam_event_info)
+{
+	char host[MAX_HOST_LENGTH + 1];
+
+	spam_event_info()
+	{
+		::memset(host, 0, MAX_HOST_LENGTH + 1);
+	}
+};
+
+typedef std::unordered_map<std::string, std::pair<unsigned int, LPEVENT>> spam_score_of_ip_t;
+spam_score_of_ip_t spam_score_of_ip;
+
+EVENTFUNC(block_chat_by_ip_event)
+{
+	spam_event_info* info = dynamic_cast<spam_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("block_chat_by_ip_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	const char* host = info->host;
+
+	spam_score_of_ip_t::iterator it = spam_score_of_ip.find(host);
+
+	if (it != spam_score_of_ip.end())
+	{
+		it->second.first = 0;
+		it->second.second = NULL;
+	}
+
+	return 0;
+}
+
+bool SpamBlockCheck(LPCHARACTER ch, const char* const buf, const size_t buflen)
+{
+	extern int g_iSpamBlockMaxLevel;
+
+	if (ch->GetLevel() < g_iSpamBlockMaxLevel)
+	{
+		spam_score_of_ip_t::iterator it = spam_score_of_ip.find(ch->GetDesc()->GetHostName());
+
+		if (it == spam_score_of_ip.end())
+		{
+			spam_score_of_ip.insert(std::make_pair(ch->GetDesc()->GetHostName(), std::make_pair(0, (LPEVENT)NULL)));
+			it = spam_score_of_ip.find(ch->GetDesc()->GetHostName());
+		}
+
+		if (it->second.second)
+		{
+			SendBlockChatInfo(ch, event_time(it->second.second) / passes_per_sec);
+			return true;
+		}
+
+		unsigned int score;
+		const char* word = SpamManager::instance().GetSpamScore(buf, buflen, score);
+
+		it->second.first += score;
+
+		if (word)
+			sys_log(0, "SPAM_SCORE: %s text: %s score: %u total: %u word: %s", ch->GetName(), buf, score, it->second.first, word);
+
+		extern unsigned int g_uiSpamBlockScore;
+		extern unsigned int g_uiSpamBlockDuration;
+
+		if (it->second.first >= g_uiSpamBlockScore)
+		{
+			spam_event_info* info = AllocEventInfo<spam_event_info>();
+			strlcpy(info->host, ch->GetDesc()->GetHostName(), sizeof(info->host));
+
+			it->second.second = event_create(block_chat_by_ip_event, info, PASSES_PER_SEC(g_uiSpamBlockDuration));
+			sys_log(0, "SPAM_IP: %s for %u seconds", info->host, g_uiSpamBlockDuration);
+
+			LogManager::instance().CharLog(ch, 0, "SPAM", word);
+
+			SendBlockChatInfo(ch, event_time(it->second.second) / passes_per_sec);
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
+enum
+{
+	TEXT_TAG_PLAIN,
+	TEXT_TAG_TAG, // ||
+	TEXT_TAG_COLOR, // |cffffffff
+	TEXT_TAG_HYPERLINK_START, // |H
+	TEXT_TAG_HYPERLINK_END, // |h ex) |Hitem:1234:1:1:1|h
+	TEXT_TAG_RESTORE_COLOR,
+};
+
+int GetTextTag(const char* src, int maxLen, int& tagLen, std::string& extraInfo)
+{
+	tagLen = 1;
+
+	if (maxLen < 2 || *src != '|')
+		return TEXT_TAG_PLAIN;
+
+	const char* cur = ++src;
+
+	if (*cur == '|') // || | 표磯.
+	{
+		tagLen = 2;
+		return TEXT_TAG_TAG;
+	}
+	else if (*cur == 'c') // color |cffffffffblahblah|r
+	{
+		tagLen = 2;
+		return TEXT_TAG_COLOR;
+	}
+	else if (*cur == 'H') // hyperlink |Hitem:10000:0:0:0:0|h[見]|h
+	{
+		tagLen = 2;
+		return TEXT_TAG_HYPERLINK_START;
+	}
+	else if (*cur == 'h') // end of hyperlink
+	{
+		tagLen = 2;
+		return TEXT_TAG_HYPERLINK_END;
+	}
+
+	return TEXT_TAG_PLAIN;
+}
+
+void GetTextTagInfo(const char* src, int src_len, int& hyperlinks, bool& colored)
+{
+	colored = false;
+	hyperlinks = 0;
+
+	int len;
+	std::string extraInfo;
+
+	for (int i = 0; i < src_len;)
+	{
+		int tag = GetTextTag(&src[i], src_len - i, len, extraInfo);
+
+		if (tag == TEXT_TAG_HYPERLINK_START)
+			++hyperlinks;
+
+		if (tag == TEXT_TAG_COLOR)
+			colored = true;
+
+		i += len;
+	}
+}
+
+int ProcessTextTag(LPCHARACTER ch, const char* c_pszText, size_t len)
+{
+	// 20120517 
+	// 0 :  
+	// 1 : 腑 
+	// 2 : 腑 , 貫 
+	// 3 : 환
+	// 4 : 
+
+	int hyperlinks;
+	bool colored;
+
+	GetTextTagInfo(c_pszText, len, hyperlinks, colored);
+
+	if (colored == true && hyperlinks == 0)
+		return 4;
+
+	if (ch->GetExchange())
+	{
+		if (hyperlinks == 0)
+			return 0;
+		else
+			return 3;
+	}
+
+	int nPrismCount = ch->CountSpecifyItem(ITEM_PRISM);
+
+	if (nPrismCount < hyperlinks)
+		return 1;
+
+	if (!ch->GetMyShop())
+	{
+		ch->RemoveSpecifyItem(ITEM_PRISM, hyperlinks);
+		return 0;
+	}
+	else
+	{
+		int sellingNumber = ch->GetMyShop()->GetNumberByVnum(ITEM_PRISM);
+		if (nPrismCount - sellingNumber < hyperlinks)
+		{
+			return 2;
+		}
+		else
+		{
+			ch->RemoveSpecifyItem(ITEM_PRISM, hyperlinks);
+			return 0;
+		}
+	}
+
+	return 4;
+}
+
+int CInputMain::Whisper(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	const TPacketCGWhisper* pinfo = reinterpret_cast<const TPacketCGWhisper*>(data);
+
+	if (uiBytes < pinfo->wSize)
+		return -1;
+
+	int iExtraLen = pinfo->wSize - sizeof(TPacketCGWhisper);
+
+	if (iExtraLen < 0)
+	{
+		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->wSize, uiBytes);
+		ch->GetDesc()->SetPhase(PHASE_CLOSE);
+		return -1;
+	}
+
+	ch->IncreaseWhisperCounter();
+	if (ch->GetWhisperCounter() == 10 && !ch->IsGM())
+	{
+		sys_log(0, "WHISPER_HACK: %s", ch->GetName());
+		//ch->GetDesc()->DelayedDisconnect(5);
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Please do not spam the chat."));
+		ch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, 10, 0, true);
+
+		return iExtraLen;
+	}
+
+	if (ch->FindAffect(AFFECT_BLOCK_CHAT))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("채  都求."));
+		return (iExtraLen);
+	}
+
+	LPCHARACTER pkChr = CHARACTER_MANAGER::instance().FindPC(pinfo->szNameTo);
+
+	if (pkChr == ch && !test_server)
+		return iExtraLen;
+
+	LPDESC pkDesc = NULL;
+	BYTE bOpponentEmpire = 0;
+	DWORD dwOpponentPID = 0;
+
+	if (test_server)
+	{
+		if (!pkChr)
+			sys_log(0, "Whisper to %s(%s) from %s", "Null", pinfo->szNameTo, ch->GetName());
+		else
+			sys_log(0, "Whisper to %s(%s) from %s", pkChr->GetName(), pinfo->szNameTo, ch->GetName());
+	}
+
+	if (ch->IsBlockMode(BLOCK_WHISPER))
+	{
+		if (ch->GetDesc())
+		{
+			TPacketGCWhisper pack;
+			pack.bHeader = HEADER_GC_WHISPER;
+			pack.bType = WHISPER_TYPE_SENDER_BLOCKED;
+			pack.wSize = sizeof(TPacketGCWhisper);
+			strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+			ch->GetDesc()->Packet(&pack, sizeof(pack));
+		}
+		return iExtraLen;
+	}
+
+	if (!pkChr)
+	{
+		CCI* pkCCI = P2P_MANAGER::instance().Find(pinfo->szNameTo);
+
+		if (pkCCI)
+		{
+			pkDesc = pkCCI->pkDesc;
+			pkDesc->SetRelay(pinfo->szNameTo);
+			bOpponentEmpire = pkCCI->bEmpire;
+			dwOpponentPID = pkCCI->dwPID;
+
+			if (test_server)
+				sys_log(0, "Whisper to %s from %s (Channel %d Mapindex %d)", "Null", ch->GetName(), pkCCI->bChannel, pkCCI->lMapIndex);
+		}
+	}
+	else
+	{
+		pkDesc = pkChr->GetDesc();
+		bOpponentEmpire = pkChr->GetEmpire();
+		dwOpponentPID = pkChr->GetPlayerID();
+	}
+
+	if (!pkDesc)
+	{
+		if (ch->GetDesc())
+		{
+			TPacketGCWhisper pack;
+
+			pack.bHeader = HEADER_GC_WHISPER;
+			pack.bType = WHISPER_TYPE_NOT_EXIST;
+			pack.wSize = sizeof(TPacketGCWhisper);
+			strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+
+			ch->GetDesc()->Packet(&pack, sizeof(TPacketGCWhisper));
+			sys_log(0, "WHISPER: no player");
+		}
+	}
+	else
+	{
+		if (ch->IsBlockMode(BLOCK_WHISPER))
+		{
+			if (ch->GetDesc())
+			{
+				TPacketGCWhisper pack;
+				pack.bHeader = HEADER_GC_WHISPER;
+				pack.bType = WHISPER_TYPE_SENDER_BLOCKED;
+				pack.wSize = sizeof(TPacketGCWhisper);
+				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+				ch->GetDesc()->Packet(&pack, sizeof(pack));
+			}
+		}
+		else if (pkChr && pkChr->IsBlockMode(BLOCK_WHISPER))
+		{
+			if (ch->GetDesc())
+			{
+				TPacketGCWhisper pack;
+				pack.bHeader = HEADER_GC_WHISPER;
+				pack.bType = WHISPER_TYPE_TARGET_BLOCKED;
+				pack.wSize = sizeof(TPacketGCWhisper);
+				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+				ch->GetDesc()->Packet(&pack, sizeof(pack));
+			}
+		}
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		else if (pkDesc && CMessengerManager::instance().IsBlocked(ch->GetName(), pinfo->szNameTo))
+		{
+			if (ch->GetDesc())
+			{
+				TPacketGCWhisper pack;
+
+				char msg[CHAT_MAX_LEN + 1];
+				snprintf(msg, sizeof(msg), LC_STRING("Unblock %s to continue.", pinfo->szNameTo));
+				int len = MIN(CHAT_MAX_LEN, strlen(msg) + 1);
+
+				pack.bHeader = HEADER_GC_WHISPER;
+				pack.wSize = sizeof(TPacketGCWhisper) + len;
+				pack.bType = WHISPER_TYPE_SYSTEM;
+				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+
+				TEMP_BUFFER buf;
+
+				buf.write(&pack, sizeof(TPacketGCWhisper));
+				buf.write(msg, len);
+				ch->GetDesc()->Packet(buf.read_peek(), buf.size());
+
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", pinfo->szNameTo));
+			}
+		}
+		else if (pkDesc && CMessengerManager::instance().IsBlocked(pinfo->szNameTo, ch->GetName()))
+		{
+			if (ch->GetDesc())
+			{
+				TPacketGCWhisper pack;
+
+				char msg[CHAT_MAX_LEN + 1];
+				snprintf(msg, sizeof(msg), LC_STRING("%s has blocked you.", pinfo->szNameTo));
+				int len = MIN(CHAT_MAX_LEN, strlen(msg) + 1);
+
+				pack.bHeader = HEADER_GC_WHISPER;
+				pack.wSize = sizeof(TPacketGCWhisper) + len;
+				pack.bType = WHISPER_TYPE_SYSTEM;
+				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+
+				TEMP_BUFFER buf;
+
+				buf.write(&pack, sizeof(TPacketGCWhisper));
+				buf.write(msg, len);
+				ch->GetDesc()->Packet(buf.read_peek(), buf.size());
+
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", pinfo->szNameTo));
+			}
+		}
+#endif
+		else
+		{
+			BYTE bType = WHISPER_TYPE_NORMAL;
+
+			char buf[CHAT_MAX_LEN + 1];
+			strlcpy(buf, data + sizeof(TPacketCGWhisper), MIN(iExtraLen + 1, sizeof(buf)));
+			const size_t buflen = strlen(buf);
+
+			//if (true == SpamBlockCheck(ch, buf, buflen))
+			//{
+			//	if (!pkChr)
+			//	{
+			//		CCI* pkCCI = P2P_MANAGER::instance().Find(pinfo->szNameTo);
+			//
+			//		if (pkCCI)
+			//		{
+			//			pkDesc->SetRelay("");
+			//		}
+			//	}
+			//	return iExtraLen;
+			//}
+
+			//if (LC_IsCanada() == false)
+			//{
+			//	CBanwordManager::instance().ConvertString(buf, buflen);
+			//}
+
+			if (!g_bEmpireWhisper)
+			{
+				if (!ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
+				{
+					if (!(pkChr && pkChr->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)))
+					{
+						if (bOpponentEmpire != ch->GetEmpire() && ch->GetEmpire() && bOpponentEmpire //   摸庸
+							&& ch->GetGMLevel() == GM_PLAYER && gm_get_level(pinfo->szNameTo) == GM_PLAYER) // 磯 球 첨潔見
+							// 見 謗 霽４ gm_get_level 獨 
+						{
+							if (!pkChr)
+							{
+								// 摸    표첩 磯. bType  4트 Empire호 磯.
+								bType = ch->GetEmpire() << 4;
+							}
+							else
+							{
+								ConvertEmpireText(ch->GetEmpire(), buf, buflen, 10 + 2 * pkChr->GetSkillPower(SKILL_LANGUAGE1 + ch->GetEmpire() - 1) /* 환확 */);
+							}
+						}
+					}
+				}
+			}
+
+			if (!g_bDisableGlassInsight)
+			{
+				int processReturn = ProcessTextTag(ch, buf, buflen);
+				if (processReturn != 0)
+				{
+					if (ch->GetDesc())
+					{
+						TItemTable* pTable = ITEM_MANAGER::instance().GetTable(ITEM_PRISM);
+
+						if (pTable)
+						{
+							char buf[128];
+							int len;
+							if (processReturn == 3) // 환
+								len = snprintf(buf, sizeof(buf), LC_STRING("摸 킹(창,환,) 貫   求."));
+							else
+							{
+								len = snprintf(buf, sizeof(buf), LC_STRING("%s  却爛求", LC_ITEM(pTable->dwVnum)));
+							}
+
+							if (len < 0 || len >= (int)sizeof(buf))
+								len = sizeof(buf) - 1;
+
+							++len; // \0  
+
+							TPacketGCWhisper pack;
+
+							pack.bHeader = HEADER_GC_WHISPER;
+							pack.bType = WHISPER_TYPE_ERROR;
+							pack.wSize = sizeof(TPacketGCWhisper) + len;
+							strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+
+							ch->GetDesc()->BufferedPacket(&pack, sizeof(pack));
+							ch->GetDesc()->Packet(buf, len);
+
+							sys_log(0, "WHISPER: not enough %s: char: %s", pTable->szLocaleName, ch->GetName());
+						}
+					}
+
+					//    퓐 見 풀娩.
+					pkDesc->SetRelay("");
+					return (iExtraLen);
+				}
+			}
+
+			if (ch->IsGM())
+				bType = (bType & 0xF0) | WHISPER_TYPE_GM;
+
+			if (buflen > 0)
+			{
+				TPacketGCWhisper pack;
+
+				pack.bHeader = HEADER_GC_WHISPER;
+				pack.wSize = sizeof(TPacketGCWhisper) + buflen;
+				pack.bType = bType;
+				strlcpy(pack.szNameFrom, ch->GetName(), sizeof(pack.szNameFrom));
+#if defined(__LOCALE_CLIENT__)
+				pack.bCanFormat = false;
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+				strlcpy(pack.szCountry, ch->GetCountry(), sizeof(pack.szCountry));
+#endif
+
+				// desc->BufferedPacket  歌 謗 求  
+				// P2P relay퓸 킷 캡화   殮 甄.
+				TEMP_BUFFER tmpbuf;
+
+				tmpbuf.write(&pack, sizeof(pack));
+				tmpbuf.write(buf, buflen);
+
+				pkDesc->Packet(tmpbuf.read_peek(), tmpbuf.size());
+
+				if (test_server)
+					sys_log(0, "WHISPER: %s -> %s : %s", ch->GetName(), pinfo->szNameTo, buf);
+
+				if (g_bWhisperLog)
+					LogManager::instance().WhisperLog(ch->GetPlayerID(), dwOpponentPID, buf);
+			}
+		}
+	}
+	if (pkDesc)
+		pkDesc->SetRelay("");
+
+	return (iExtraLen);
+}
+
+struct RawPacketToCharacterFunc
+{
+	const void* m_buf;
+	int m_buf_len;
+
+	RawPacketToCharacterFunc(const void* buf, int buf_len) : m_buf(buf), m_buf_len(buf_len)
+	{
+	}
+
+	void operator () (LPCHARACTER c)
+	{
+		if (!c->GetDesc())
+			return;
+
+		c->GetDesc()->Packet(m_buf, m_buf_len);
+	}
+};
+
+struct FEmpireChatPacket
+{
+	packet_chat& p;
+	const char* orig_msg;
+	int orig_len;
+	char converted_msg[CHAT_MAX_LEN + 1];
+
+	BYTE bEmpire;
+	int iMapIndex;
+	int namelen;
+
+	FEmpireChatPacket(packet_chat& p, const char* chat_msg, int len, BYTE bEmpire, int iMapIndex, int iNameLen)
+		: p(p), orig_msg(chat_msg), orig_len(len), bEmpire(bEmpire), iMapIndex(iMapIndex), namelen(iNameLen)
+	{
+		memset(converted_msg, 0, sizeof(converted_msg));
+	}
+
+	void operator () (LPDESC d)
+	{
+		if (!d->GetCharacter())
+			return;
+
+		if (d->GetCharacter()->GetMapIndex() != iMapIndex)
+			return;
+
+		d->BufferedPacket(&p, sizeof(packet_chat));
+
+		if (d->GetEmpire() == bEmpire ||
+			bEmpire == 0 ||
+			d->GetCharacter()->GetGMLevel() > GM_PLAYER ||
+			d->GetCharacter()->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
+		{
+			d->Packet(orig_msg, orig_len);
+		}
+		else
+		{
+			//  킬 摸 탁 瞞爛求
+			size_t len = strlcpy(converted_msg, orig_msg, sizeof(converted_msg));
+
+			if (len >= sizeof(converted_msg))
+				len = sizeof(converted_msg) - 1;
+
+			ConvertEmpireText(bEmpire, converted_msg + namelen, len - namelen, 10 + 2 * d->GetCharacter()->GetSkillPower(SKILL_LANGUAGE1 + bEmpire - 1));
+			d->Packet(converted_msg, orig_len);
+		}
+	}
+};
+
+struct FYmirChatPacket
+{
+	packet_chat& packet;
+	const char* m_szChat;
+	size_t m_lenChat;
+	const char* m_szName;
+
+	int m_iMapIndex;
+	BYTE m_bEmpire;
+	bool m_ring;
+
+	char m_orig_msg[CHAT_MAX_LEN + 1];
+	int m_len_orig_msg;
+	char m_conv_msg[CHAT_MAX_LEN + 1];
+	int m_len_conv_msg;
+
+	FYmirChatPacket(packet_chat& p, const char* chat, size_t len_chat, const char* name, size_t len_name, int iMapIndex, BYTE empire, bool ring)
+		: packet(p),
+		m_szChat(chat), m_lenChat(len_chat),
+		m_szName(name),
+		m_iMapIndex(iMapIndex), m_bEmpire(empire),
+		m_ring(ring)
+	{
+		m_len_orig_msg = snprintf(m_orig_msg, sizeof(m_orig_msg), "%s : %s", m_szName, m_szChat) + 1; //   
+
+		if (m_len_orig_msg < 0 || m_len_orig_msg >= (int)sizeof(m_orig_msg))
+			m_len_orig_msg = sizeof(m_orig_msg) - 1;
+
+		m_len_conv_msg = snprintf(m_conv_msg, sizeof(m_conv_msg), "??? : %s", m_szChat) + 1; //   
+
+		if (m_len_conv_msg < 0 || m_len_conv_msg >= (int)sizeof(m_conv_msg))
+			m_len_conv_msg = sizeof(m_conv_msg) - 1;
+
+		ConvertEmpireText(m_bEmpire, m_conv_msg + 6, m_len_conv_msg - 6, 10); // 6 "??? : " 
+	}
+
+	void operator() (LPDESC d)
+	{
+		if (!d->GetCharacter())
+			return;
+
+		if (d->GetCharacter()->GetMapIndex() != m_iMapIndex)
+			return;
+
+		if (m_ring ||
+			d->GetEmpire() == m_bEmpire ||
+			d->GetCharacter()->GetGMLevel() > GM_PLAYER ||
+			d->GetCharacter()->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
+		{
+			packet.size = m_len_orig_msg + sizeof(TPacketGCChat);
+
+			d->BufferedPacket(&packet, sizeof(packet_chat));
+			d->Packet(m_orig_msg, m_len_orig_msg);
+		}
+		else
+		{
+			packet.size = m_len_conv_msg + sizeof(TPacketGCChat);
+
+			d->BufferedPacket(&packet, sizeof(packet_chat));
+			d->Packet(m_conv_msg, m_len_conv_msg);
+		}
+	}
+};
+
+int CInputMain::Chat(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	const TPacketCGChat* pinfo = reinterpret_cast<const TPacketCGChat*>(data);
+
+	if (uiBytes < pinfo->size)
+		return -1;
+
+	const int iExtraLen = pinfo->size - sizeof(TPacketCGChat);
+
+	if (iExtraLen < 0)
+	{
+		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->size, uiBytes);
+		ch->GetDesc()->SetPhase(PHASE_CLOSE);
+		return -1;
+	}
+
+	char buf[CHAT_MAX_LEN - (CHARACTER_NAME_MAX_LEN + 3) + 1];
+	strlcpy(buf, data + sizeof(TPacketCGChat), MIN(iExtraLen + 1, sizeof(buf)));
+	const size_t buflen = strlen(buf);
+
+	if (buflen > 1 && *buf == '/')
+	{
+		// NOTE : Block players from accessing the command interpreter
+		// through normal chat. (CHAT_TYPE_TALKING) 20230607.Owsap
+		if (!ch->IsGM() && pinfo->type == CHAT_TYPE_TALKING)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("瀏  求"));
+			return iExtraLen;
+		}
+
+		interpret_command(ch, buf + 1, buflen - 1);
+		return iExtraLen;
+	}
+
+	ch->IncreaseChatCounter();
+	if (ch->GetChatCounter() == 10 && !ch->IsGM())
+	{
+		sys_log(0, "CHAT_HACK: %s", ch->GetName());
+		//ch->GetDesc()->DelayedDisconnect(5);
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Please do not spam the chat."));
+		ch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, 10, 0, true);
+
+		return iExtraLen;
+	}
+
+	// 채  Affect 처
+	const CAffect* pAffect = ch->FindAffect(AFFECT_BLOCK_CHAT);
+
+	if (pAffect != NULL)
+	{
+		SendBlockChatInfo(ch, pAffect->lDuration);
+		return iExtraLen;
+	}
+
+	if (SpamBlockCheck(ch, buf, buflen))
+		return iExtraLen;
+
+	if (CHAT_TYPE_SHOUT == pinfo->type && g_bDisableShout && !ch->IsGM())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The shout is disabled."));
+		return iExtraLen;
+	}
+
+	char chatbuf[CHAT_MAX_LEN + 1];
+	int len = snprintf(chatbuf, sizeof(chatbuf), "%s : %s", ch->GetName(), buf);
+
+	if (CHAT_TYPE_SHOUT == pinfo->type)
+	{
+		LogManager::instance().ShoutLog(g_bChannel, ch->GetEmpire(), chatbuf);
+	}
+
+	CBanwordManager::instance().ConvertString(buf, buflen);
+
+	if (len < 0 || len >= (int)sizeof(chatbuf))
+		len = sizeof(chatbuf) - 1;
+
+	if (!g_bDisableGlassInsight)
+	{
+		int processReturn = ProcessTextTag(ch, chatbuf, len);
+		if (processReturn != 0)
+		{
+			const TItemTable* pTable = ITEM_MANAGER::instance().GetTable(ITEM_PRISM);
+
+			if (NULL != pTable)
+			{
+				if (3 == processReturn) //환
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 킹(창,환,) 貫   求."));
+				else
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s  却爛求", LC_ITEM(pTable->dwVnum)));
+				}
+			}
+
+			return iExtraLen;
+		}
+	}
+
+	if (pinfo->type == CHAT_TYPE_SHOUT)
+	{
+		const int SHOUT_LIMIT_LEVEL = g_iUseLocale ? 15 : 3;
+
+		if (ch->GetLevel() < SHOUT_LIMIT_LEVEL)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("치  %d 鵑   爛求.", SHOUT_LIMIT_LEVEL));
+			return (iExtraLen);
+		}
+
+		if (thecore_heart->pulse - (int)ch->GetLastShoutPulse() < passes_per_sec * 15 && !ch->IsGM())
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can only call every 15 seconds."));
+			return (iExtraLen);
+		}
+
+		ch->SetLastShoutPulse(thecore_heart->pulse);
+
+		TPacketGGShout p;
+		p.bHeader = HEADER_GG_SHOUT;
+		p.bEmpire = ch->GetEmpire();
+		strlcpy(p.szText, chatbuf, sizeof(p.szText));
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		strlcpy(p.szName, ch->GetName(), sizeof(p.szName));
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		strlcpy(p.szCountry, ch->GetCountry(), sizeof(p.szCountry));
+#endif
+
+		P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGShout));
+
+		SendShout(chatbuf, ch->GetEmpire()
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+			, ch->GetName()
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			, ch->GetCountry()
+#endif
+		);
+
+		return (iExtraLen);
+	}
+
+	TPacketGCChat pack_chat;
+	pack_chat.header = HEADER_GC_CHAT;
+	pack_chat.size = sizeof(TPacketGCChat) + len;
+	pack_chat.type = pinfo->type;
+	pack_chat.id = ch->GetVID();
+#if defined(__LOCALE_CLIENT__)
+	pack_chat.bCanFormat = false;
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	strlcpy(pack_chat.szCountry, ch->GetCountry(), sizeof(pack_chat.szCountry));
+#endif
+
+	switch (pinfo->type)
+	{
+		case CHAT_TYPE_TALKING:
+		{
+			const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
+
+			if (false)
+			{
+				std::for_each(c_ref_set.begin(), c_ref_set.end(),
+					FYmirChatPacket(pack_chat,
+						buf,
+						strlen(buf),
+						ch->GetName(),
+						strlen(ch->GetName()),
+						ch->GetMapIndex(),
+						ch->GetEmpire(),
+						ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)));
+			}
+			else
+			{
+				std::for_each(c_ref_set.begin(), c_ref_set.end(),
+					FEmpireChatPacket(pack_chat,
+						chatbuf,
+						len,
+						(ch->GetGMLevel() > GM_PLAYER ||
+							ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)) ? 0 : ch->GetEmpire(),
+						ch->GetMapIndex(), strlen(ch->GetName())));
+			}
+		}
+		break;
+
+		case CHAT_TYPE_PARTY:
+		{
+			if (!ch->GetParty())
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("티  틈爛求."));
+			else
+			{
+				TEMP_BUFFER tbuf;
+
+				tbuf.write(&pack_chat, sizeof(pack_chat));
+				tbuf.write(chatbuf, len);
+
+				RawPacketToCharacterFunc f(tbuf.read_peek(), tbuf.size());
+				ch->GetParty()->ForEachOnlineMember(f);
+			}
+		}
+		break;
+
+		case CHAT_TYPE_GUILD:
+		{
+			if (!ch->GetGuild())
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("恙  刻努求."));
+			else
+				ch->GetGuild()->Chat(chatbuf);
+		}
+		break;
+
+		default:
+			sys_err("Unknown chat type %d", pinfo->type);
+			break;
+	}
+
+	return (iExtraLen);
+}
+
+void CInputMain::ItemUse(LPCHARACTER ch, const char* data)
+{
+	ch->UseItem(((struct command_item_use*)data)->Cell);
+}
+
+void CInputMain::ItemToItem(LPCHARACTER ch, const char* pcData)
+{
+	TPacketCGItemUseToItem* p = (TPacketCGItemUseToItem*)pcData;
+	if (ch)
+		ch->UseItem(p->Cell, p->TargetCell);
+}
+
+void CInputMain::ItemDrop(LPCHARACTER ch, const char* data)
+{
+	struct command_item_drop* pinfo = (struct command_item_drop*)data;
+
+	// MONARCH_LIMIT
+	//if (ch->IsMonarch())
+	//	return;
+	// END_MONARCH_LIMIT
+	if (!ch)
+		return;
+
+	// 크 0 크 크   甄.
+	if (pinfo->gold > 0)
+		ch->DropGold(pinfo->gold);
+#if defined(__CHEQUE_SYSTEM__)
+	else if (pinfo->cheque > 0)
+		ch->DropCheque(pinfo->cheque);
+#endif
+	else
+		ch->DropItem(pinfo->Cell);
+}
+
+void CInputMain::ItemDrop2(LPCHARACTER ch, const char* data)
+{
+	// MONARCH_LIMIT
+	//if (ch->IsMonarch())
+	//	return;
+	// END_MONARCH_LIMIT
+
+	TPacketCGItemDrop2* pinfo = (TPacketCGItemDrop2*)data;
+
+	// 크 0 크 크   甄.
+
+	if (!ch)
+		return;
+	if (pinfo->gold > 0)
+		ch->DropGold(pinfo->gold);
+#if defined(__CHEQUE_SYSTEM__)
+	else if (pinfo->cheque > 0)
+		ch->DropCheque(pinfo->cheque);
+#endif
+	else
+		ch->DropItem(pinfo->Cell, pinfo->count);
+}
+
+#if defined(__NEW_DROP_DIALOG__)
+void CInputMain::ItemDestroy(LPCHARACTER ch, const char* data)
+{
+	struct command_item_destroy* pinfo = (struct command_item_destroy*)data;
+	if (ch)
+		ch->DestroyItem(pinfo->Cell);
+}
+#endif
+
+void CInputMain::ItemMove(LPCHARACTER ch, const char* data)
+{
+	struct command_item_move* pinfo = (struct command_item_move*)data;
+
+	if (ch)
+		ch->MoveItem(pinfo->Cell, pinfo->CellTo, pinfo->count);
+}
+
+void CInputMain::ItemPickup(LPCHARACTER ch, const char* data)
+{
+	struct command_item_pickup* pinfo = (struct command_item_pickup*)data;
+	if (ch)
+		ch->PickupItem(pinfo->vid);
+}
+
+void CInputMain::QuickslotAdd(LPCHARACTER ch, const char* data)
+{
+	struct command_quickslot_add* pinfo = (struct command_quickslot_add*)data;
+	ch->SetQuickslot(pinfo->pos, pinfo->slot);
+}
+
+void CInputMain::QuickslotDelete(LPCHARACTER ch, const char* data)
+{
+	struct command_quickslot_del* pinfo = (struct command_quickslot_del*)data;
+	ch->DelQuickslot(pinfo->pos);
+}
+
+void CInputMain::QuickslotSwap(LPCHARACTER ch, const char* data)
+{
+	struct command_quickslot_swap* pinfo = (struct command_quickslot_swap*)data;
+	ch->SwapQuickslot(pinfo->pos, pinfo->change_pos);
+}
+
+int CInputMain::Messenger(const LPCHARACTER c_lpChar, const char* c_pData, std::size_t uiBytes)
+{
+	const TPacketCGMessenger* c_pPacket = reinterpret_cast<const TPacketCGMessenger*>(c_pData);
+	if (uiBytes < sizeof(TPacketCGMessenger))
+		return -1;
+
+	c_pData += sizeof(TPacketCGMessenger);
+	uiBytes -= sizeof(TPacketCGMessenger);
+
+	switch (c_pPacket->bSubHeader)
+	{
+		case MESSENGER_SUBHEADER_CG_ADD_BY_VID:
+		{
+			if (uiBytes < sizeof(TPacketCGMessengerAddByVID))
+				return -1;
+
+			const TPacketCGMessengerAddByVID* c_pAddByVIDPacket = reinterpret_cast<const TPacketCGMessengerAddByVID*>(c_pData);
+			const LPCHARACTER c_lpCharCompanion = CHARACTER_MANAGER::instance().Find(c_pAddByVIDPacket->dwVID);
+
+			if (c_lpCharCompanion == nullptr)
+				return sizeof(TPacketCGMessengerAddByVID);
+
+			if (c_lpCharCompanion->IsObserverMode())
+				return sizeof(TPacketCGMessengerAddByVID);
+
+			if (c_lpCharCompanion->IsBlockMode(BLOCK_MESSENGER_INVITE))
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 聘 煞 탄 都求."));
+				return sizeof(TPacketCGMessengerAddByVID);
+			}
+
+			const LPDESC c_lpCompanionDesc = c_lpCharCompanion->GetDesc();
+			if (c_lpCompanionDesc == nullptr)
+				return sizeof(TPacketCGMessengerAddByVID);
+
+			if (c_lpChar->GetGMLevel() == GM_PLAYER && c_lpCharCompanion->GetGMLevel() != GM_PLAYER)
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<聘> 楮뒤 聘 煞  求."));
+				return sizeof(TPacketCGMessengerAddByVID);
+			}
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", c_lpCharCompanion->GetName()));
+				return sizeof(TPacketCGMessengerAddByVID);
+			}
+			else if (CMessengerManager::instance().IsBlocked(c_lpCharCompanion->GetName(), c_lpChar->GetName()))
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", c_lpCharCompanion->GetName()));
+				return sizeof(TPacketCGMessengerAddByVID);
+			}
+#endif
+
+			if (c_lpChar->GetDesc() == c_lpCompanionDesc) // 黴 煞  .
+				return sizeof(TPacketCGMessengerAddByVID);
+
+			CMessengerManager::instance().RequestToAdd(c_lpChar, c_lpCharCompanion);
+			//CMessengerManager::instance().AddToList(c_lpChar->GetName(), c_lpCharCompanion->GetName());
+		}
+		return sizeof(TPacketCGMessengerAddByVID);
+
+		case MESSENGER_SUBHEADER_CG_ADD_BY_NAME:
+		{
+			if (uiBytes < CHARACTER_NAME_MAX_LEN)
+				return -1;
+
+			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
+			strlcpy(szName, c_pData, sizeof(szName));
+
+			if (c_lpChar->GetGMLevel() == GM_PLAYER && gm_get_level(szName) != GM_PLAYER)
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<聘> 楮뒤 聘 煞  求."));
+				return CHARACTER_NAME_MAX_LEN;
+			}
+
+			const LPCHARACTER c_lpCharTarget = CHARACTER_MANAGER::instance().FindPC(szName);
+			if (c_lpCharTarget == nullptr)
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s  撻  駕求.", szName));
+			else
+			{
+				if (c_lpCharTarget == c_lpChar) // 黴 煞  .
+					return CHARACTER_NAME_MAX_LEN;
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharTarget->GetName()))
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", c_lpCharTarget->GetName()));
+					return CHARACTER_NAME_MAX_LEN;
+				}
+				else if (CMessengerManager::instance().IsBlocked(c_lpCharTarget->GetName(), c_lpChar->GetName()))
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", c_lpCharTarget->GetName()));
+					return CHARACTER_NAME_MAX_LEN;
+				}
+#endif
+
+				if (c_lpCharTarget->IsBlockMode(BLOCK_MESSENGER_INVITE) == true)
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 聘 煞 탄 都求."));
+				}
+				else
+				{
+					// 聘 캐姑 퓔庸 
+					CMessengerManager::instance().RequestToAdd(c_lpChar, c_lpCharTarget);
+					//CMessengerManager::instance().AddToList(c_lpChar->GetName(), c_lpCharTarget->GetName());
+				}
+			}
+		}
+		return CHARACTER_NAME_MAX_LEN;
+
+		case MESSENGER_SUBHEADER_CG_REMOVE:
+		{
+			if (uiBytes < CHARACTER_NAME_MAX_LEN)
+				return -1;
+
+			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
+			strlcpy(szName, c_pData, sizeof(szName));
+			CMessengerManager::instance().RemoveFromList(c_lpChar->GetName(), szName);
+		}
+		return CHARACTER_NAME_MAX_LEN;
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		case MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID:
+		{
+			if (uiBytes < sizeof(TPacketCGMessengerAddBlockByVID))
+				return -1;
+
+			const TPacketCGMessengerAddBlockByVID* c_pAddBlockByVIDPacket = reinterpret_cast<const TPacketCGMessengerAddBlockByVID*>(c_pData);
+			const LPCHARACTER c_lpCharCompanion = CHARACTER_MANAGER::instance().Find(c_pAddBlockByVIDPacket->dwVID);
+			if (c_lpCharCompanion == nullptr)
+				return sizeof(TPacketCGMessengerAddBlockByVID);
+
+			if (c_lpChar->IsObserverMode())
+				return sizeof(TPacketCGMessengerAddBlockByVID);
+
+			const LPDESC c_lpDescCompanion = c_lpCharCompanion->GetDesc();
+			if (c_lpDescCompanion == nullptr)
+				return sizeof(TPacketCGMessengerAddByVID);
+
+			const LPCHARACTER c_pPartner = c_lpChar->GetMarryPartner();
+			if (c_pPartner)
+			{
+				if (c_lpCharCompanion->GetName() == c_pPartner->GetName())
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block your spouse."));
+					return sizeof(TPacketCGMessengerAddBlockByVID);
+				}
+			}
+
+			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Remove %s from your friends list to continue.", c_lpCharCompanion->GetName()));
+				return sizeof(TPacketCGMessengerAddBlockByVID);
+			}
+
+			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is already being blocked.", c_lpCharCompanion->GetName()));
+				return sizeof(TPacketCGMessengerAddBlockByVID);
+			}
+
+			if (c_lpChar->GetGMLevel() == GM_PLAYER && c_lpCharCompanion->GetGMLevel() != GM_PLAYER && !test_server)
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block this player."));
+				return sizeof(TPacketCGMessengerAddByVID);
+			}
+
+			if (c_lpChar->GetDesc() == c_lpDescCompanion)
+				return sizeof(TPacketCGMessengerAddBlockByVID);
+
+			CMessengerManager::instance().AddToBlockList(c_lpChar->GetName(), c_lpCharCompanion->GetName());
+		}
+		return sizeof(TPacketCGMessengerAddBlockByVID);
+
+		case MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME:
+		{
+			if (uiBytes < CHARACTER_NAME_MAX_LEN)
+				return -1;
+
+			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
+			strlcpy(szName, c_pData, sizeof(szName));
+
+			if (gm_get_level(szName) != GM_PLAYER && !test_server)
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block this player."));
+				return CHARACTER_NAME_MAX_LEN;
+			}
+
+			const LPCHARACTER c_lpCharTarget = CHARACTER_MANAGER::instance().FindPC(szName);
+			if (c_lpCharTarget == c_lpChar)
+				return CHARACTER_NAME_MAX_LEN;
+
+			LPDESC pDescTarget = nullptr;
+			if (c_lpCharTarget == nullptr)
+			{
+				const CCI* c_pCCI = P2P_MANAGER::instance().Find(szName);
+				if (c_pCCI)
+					pDescTarget = c_pCCI->pkDesc;
+			}
+			else
+				pDescTarget = c_lpCharTarget->GetDesc();
+
+			if (pDescTarget == nullptr)
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is not online.", szName));
+				return CHARACTER_NAME_MAX_LEN;
+			}
+			else
+			{
+				const LPCHARACTER c_pPartner = c_lpChar->GetMarryPartner();
+				if (c_pPartner)
+				{
+					if (c_pPartner->GetName() == szName)
+					{
+						c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block your spouse."));
+						return CHARACTER_NAME_MAX_LEN;
+					}
+				}
+
+				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Remove %s from your friends list to continue.", szName));
+					return CHARACTER_NAME_MAX_LEN;
+				}
+
+				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is already being blocked.", szName));
+					return CHARACTER_NAME_MAX_LEN;
+				}
+
+				CMessengerManager::instance().AddToBlockList(c_lpChar->GetName(), szName);
+			}
+		}
+		return CHARACTER_NAME_MAX_LEN;
+
+		case MESSENGER_SUBHEADER_CG_BLOCK_REMOVE:
+		{
+			if (uiBytes < CHARACTER_NAME_MAX_LEN)
+				return -1;
+
+			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
+			strlcpy(szName, c_pData, sizeof(szName));
+
+			if (!CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
+				return CHARACTER_NAME_MAX_LEN;
+
+			CMessengerManager::instance().RemoveFromBlockList(c_lpChar->GetName(), szName);
+		}
+		return CHARACTER_NAME_MAX_LEN;
+#endif
+
+		default:
+			sys_err("CInputMain::Messenger : Unknown subheader %d : %s", c_pPacket->bSubHeader, c_lpChar->GetName());
+			break;
+	}
+
+	return 0;
+}
+
+int CInputMain::Shop(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	TPacketCGShop* p = (TPacketCGShop*)data;
+
+	if (uiBytes < sizeof(TPacketCGShop))
+		return -1;
+
+	if (test_server)
+		sys_log(0, "CInputMain::Shop() ==> SubHeader %d", p->subheader);
+
+	const char* c_pData = data + sizeof(TPacketCGShop);
+	uiBytes -= sizeof(TPacketCGShop);
+
+	switch (p->subheader)
+	{
+		case SHOP_SUBHEADER_CG_END:
+			sys_log(1, "INPUT: %s SHOP: END", ch->GetName());
+			CShopManager::instance().StopShopping(ch);
+			return 0;
+
+		case SHOP_SUBHEADER_CG_BUY:
+		{
+			if (uiBytes < sizeof(BYTE) + sizeof(BYTE))
+				return -1;
+
+			BYTE bPos = *(c_pData + 1);
+			sys_log(1, "INPUT: %s SHOP: BUY %d", ch->GetName(), bPos);
+			CShopManager::instance().Buy(ch, bPos);
+			return (sizeof(BYTE) + sizeof(BYTE));
+		}
+
+		case SHOP_SUBHEADER_CG_SELL:
+		{
+			if (uiBytes < sizeof(BYTE))
+				return -1;
+
+			BYTE pos = *c_pData;
+
+			sys_log(0, "INPUT: %s SHOP: SELL", ch->GetName());
+			CShopManager::instance().Sell(ch, pos);
+			return sizeof(BYTE);
+		}
+
+		case SHOP_SUBHEADER_CG_SELL2:
+		{
+			const TPacketCGShopSell* p = reinterpret_cast<const TPacketCGShopSell*>(c_pData);
+
+			sys_log(0, "INPUT: %s SHOP: SELL2", ch->GetName());
+
+			CShopManager::instance().Sell(ch, p->wPos, p->wCount, p->bType);
+			return sizeof(TPacketCGShopSell);
+		}
+
+		default:
+			sys_err("CInputMain::Shop : Unknown subheader %d : %s", p->subheader, ch->GetName());
+			break;
+	}
+
+	return 0;
+}
+
+void CInputMain::OnClick(LPCHARACTER ch, const char* data)
+{
+	struct command_on_click* pinfo = (struct command_on_click*)data;
+	LPCHARACTER victim;
+
+	if ((victim = CHARACTER_MANAGER::instance().Find(pinfo->vid)))
+		victim->OnClick(ch);
+	else if (test_server)
+	{
+		sys_err("CInputMain::OnClick %s.Click.NOT_EXIST_VID[%d]", ch->GetName(), pinfo->vid);
+	}
+}
+
+void CInputMain::Exchange(LPCHARACTER ch, const char* data)
+{
+	struct command_exchange* pinfo = (struct command_exchange*)data;
+	LPCHARACTER to_ch = NULL;
+
+	if (!ch->CanHandleItem())
+		return;
+
+	int iPulse = thecore_pulse();
+
+	if ((to_ch = CHARACTER_MANAGER::instance().Find(pinfo->arg1)))
+	{
+		if (iPulse - to_ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+		{
+			to_ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("킹  %d 犬 창  求.", g_nPortalLimitTime));
+			return;
+		}
+
+		if (true == to_ch->IsDead())
+		{
+			return;
+		}
+	}
+
+	sys_log(0, "CInputMain()::Exchange() SubHeader %d ", pinfo->sub_header);
+
+	if (iPulse - ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("킹  %d 犬 창  求.", g_nPortalLimitTime));
+		return;
+	}
+
+	switch (pinfo->sub_header)
+	{
+		case EXCHANGE_SUBHEADER_CG_START: // arg1 == vid of target character
+			if (!ch->GetExchange())
+			{
+				if ((to_ch = CHARACTER_MANAGER::instance().Find(pinfo->arg1)))
+				{
+					//MONARCH_LIMIT
+					/*
+					if (to_ch->IsMonarch() || ch->IsMonarch())
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("翎姑 킹 寗 求", g_nPortalLimitTime));
+						return;
+					}
+					//END_MONARCH_LIMIT
+					*/
+					if (iPulse - ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("창  %d 犬 킹 寗 求.", g_nPortalLimitTime));
+
+						if (test_server)
+							ch->ChatPacket(CHAT_TYPE_INFO, "[TestOnly][Safebox]Pulse %d LoadTime %d PASS %d", iPulse, ch->GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
+						return;
+					}
+
+					if (iPulse - to_ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+					{
+						to_ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("창  %d 犬 킹 寗 求.", g_nPortalLimitTime));
+
+						if (test_server)
+							to_ch->ChatPacket(CHAT_TYPE_INFO, "[TestOnly][Safebox]Pulse %d LoadTime %d PASS %d", iPulse, to_ch->GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
+						return;
+					}
+
+					if (ch->GetGold() >= GOLD_MAX)
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("硫 20  歌臼 킹 寗 求.."));
+
+						sys_err("[OVERFLOG_GOLD] START (%d) id %u name %s ", ch->GetGold(), ch->GetPlayerID(), ch->GetName());
+						return;
+					}
+
+#if defined(__CHEQUE_SYSTEM__)
+					if (ch->GetCheque() > CHEQUE_MAX)
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("硫 20  歌臼 킹 寗 求.."));
+
+						sys_err("[OVERFLOW_CHEQUE] START (%d) id %u name %s ", ch->GetCheque(), ch->GetPlayerID(), ch->GetName());
+						return;
+					}
+#endif
+
+					if (to_ch->IsPC())
+					{
+						if (quest::CQuestManager::instance().GiveItemToPC(ch->GetPlayerID(), to_ch))
+						{
+							sys_log(0, "Exchange canceled by quest %s %s", ch->GetName(), to_ch->GetName());
+							return;
+						}
+					}
+
+					if (ch->PreventTradeWindow(WND_EXCHANGE, true/*except*/))
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 킹構 貫  求."));
+						return;
+					}
+
+					ch->ExchangeStart(to_ch);
+				}
+			}
+			break;
+
+		case EXCHANGE_SUBHEADER_CG_ITEM_ADD: // arg1 == position of item, arg2 == position in exchange window
+			if (ch->GetExchange())
+			{
+				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
+					ch->GetExchange()->AddItem(pinfo->Pos, pinfo->arg2);
+			}
+			break;
+
+		case EXCHANGE_SUBHEADER_CG_ITEM_DEL: // arg1 == position of item
+			if (ch->GetExchange())
+			{
+				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
+					ch->GetExchange()->RemoveItem(pinfo->arg1);
+			}
+			break;
+
+		case EXCHANGE_SUBHEADER_CG_ELK_ADD: // arg1 == amount of gold
+			if (ch->GetExchange())
+			{
+				const int64_t nTotalGold = static_cast<int64_t>(ch->GetExchange()->GetCompany()->GetOwner()->GetGold()) + static_cast<int64_t>(pinfo->arg1);
+				if (GOLD_MAX <= nTotalGold)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Yang."));
+
+					sys_err("[OVERFLOW_GOLD] ELK_ADD (%d) id %u name %s ",
+						ch->GetExchange()->GetCompany()->GetOwner()->GetGold(),
+						ch->GetExchange()->GetCompany()->GetOwner()->GetPlayerID(),
+						ch->GetExchange()->GetCompany()->GetOwner()->GetName());
+
+					return;
+				}
+
+				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
+					ch->GetExchange()->AddGold(pinfo->arg1);
+			}
+			break;
+
+#if defined(__CHEQUE_SYSTEM__)
+		case EXCHANGE_SUBHEADER_CG_CHEQUE_ADD: // arg1 == amount of cheque
+			if (ch->GetExchange())
+			{
+				const int64_t nTotalCheque = static_cast<int64_t>(ch->GetExchange()->GetCompany()->GetOwner()->GetCheque()) + static_cast<int64_t>(pinfo->arg1);
+
+				if (nTotalCheque > CHEQUE_MAX)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Won."));
+
+					sys_err("[OVERFLOW_CHEQUE] CHEQUE_ADD (%u) id %u name %s ",
+						ch->GetExchange()->GetCompany()->GetOwner()->GetCheque(),
+						ch->GetExchange()->GetCompany()->GetOwner()->GetPlayerID(),
+						ch->GetExchange()->GetCompany()->GetOwner()->GetName());
+
+					return;
+				}
+
+				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
+					ch->GetExchange()->AddCheque(pinfo->arg1);
+			}
+			break;
+#endif
+
+		case EXCHANGE_SUBHEADER_CG_ACCEPT: // arg1 == not used
+			if (ch->GetExchange())
+			{
+				sys_log(0, "CInputMain()::Exchange() ==> ACCEPT ");
+				ch->GetExchange()->Accept(true);
+			}
+			break;
+
+		case EXCHANGE_SUBHEADER_CG_CANCEL: // arg1 == not used
+			if (ch->GetExchange())
+				ch->GetExchange()->Cancel();
+			break;
+	}
+}
+
+void CInputMain::Position(LPCHARACTER ch, const char* data)
+{
+	struct command_position* pinfo = (struct command_position*)data;
+
+	switch (pinfo->position)
+	{
+		case POSITION_GENERAL:
+			ch->Standup();
+			break;
+
+		case POSITION_SITTING_CHAIR:
+			ch->Sitdown(0);
+			break;
+
+		case POSITION_SITTING_GROUND:
+			ch->Sitdown(1);
+			break;
+	}
+}
+
+static const int ComboSequenceBySkillLevel[3][8] =
+{
+	//	0	1	2	3	4	5	6	7
+	{	14,	15,	16,	17,	0,	0,	0,	0	},
+	{	14,	15,	16,	18,	20,	0,	0,	0	},
+	{	14,	15,	16,	18,	19,	17,	0,	0	},
+};
+
+#define COMBO_HACK_ALLOWABLE_MS 100
+
+bool CheckComboHack(LPCHARACTER ch, BYTE bArg, DWORD dwTime, bool CheckSpeedHack)
+{
+	if (!gHackCheckEnable)
+		return false;
+
+	// 陋킬  쩔   퓐, skip磯.
+	// 肩  , CHRACTER::CanMove() 
+	// if (IsStun() || IsDead()) return false;
+	//  煞求째 쨈鳴 毬,
+	// 譴 摸 觀極 CanMove() IsStun(), IsDead()
+	//  체크構 殮    
+	// 玲화歐  肩  湄躍 쨈.
+	if (ch->IsStun() || ch->IsDead())
+		return false;
+	int ComboInterval = dwTime - ch->GetLastComboTime();
+	int HackScalar = 0; // 羞 칼  1
+#if 0
+	sys_log(0, "COMBO: %s arg:%u seq:%u delta:%d checkspeedhack:%d",
+		ch->GetName(), bArg, ch->GetComboSequence(), ComboInterval - ch->GetValidComboInterval(), CheckSpeedHack);
+#endif
+	// bArg 14 ~ 21   8頻 
+	// 1. 첫 頻(14)  챨 커 趺 
+	// 2. 15 ~ 21 趺 柰
+	// 3. 苛 磯.
+	if (bArg == 14)
+	{
+		if (CheckSpeedHack && ComboInterval > 0 && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
+		{
+			// FIXME 첫째 頻 鵑構    羚底 300  -_-;
+			// 模 沽  牟풔 황  玖
+			// 첫째 頻 탓  攷  황 澁.
+			// 肩  頻 튕 李 羚  湄  활화.
+			//HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 300;
+
+			//sys_log(0, "COMBO_HACK: 2 %s arg:%u interval:%d valid:%u atkspd:%u riding:%s",
+			//	ch->GetName(),
+			//	bArg,
+			//	ComboInterval,
+			//	ch->GetValidComboInterval(),
+			//	ch->GetPoint(POINT_ATT_SPEED),
+			//	ch->IsRiding() ? "yes" : "no"
+			//);
+		}
+
+		ch->SetComboSequence(1);
+		ch->SetValidComboInterval((int)(ani_combo_speed(ch, 1) / (ch->GetPoint(POINT_ATT_SPEED) / 100.f)));
+		ch->SetLastComboTime(dwTime);
+	}
+	else if (bArg > 14 && bArg < 22)
+	{
+		int idx = MIN(2, ch->GetComboIndex());
+
+		if (ch->GetComboSequence() > 5) //  6頻 鵑 .
+		{
+			HackScalar = 1;
+			ch->SetValidComboInterval(300);
+			sys_log(0, "COMBO_HACK: 5 %s combo_seq:%d", ch->GetName(), ch->GetComboSequence());
+		}
+		// 微 玲 頻 처
+		else if (bArg == 21 &&
+			idx == 2 &&
+			ch->GetComboSequence() == 5 &&
+			ch->GetJob() == JOB_ASSASSIN &&
+			ch->GetWear(WEAR_WEAPON) &&
+			ch->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_DAGGER
+			)
+			ch->SetValidComboInterval(300);
+		else if (bArg == 21 &&
+			idx == 2 &&
+			ch->GetComboSequence() == 5 &&
+			ch->GetJob() == JOB_WOLFMAN &&
+			ch->GetWear(WEAR_WEAPON) &&
+			ch->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_CLAW
+			)
+			ch->SetValidComboInterval(300);
+		else if (ComboSequenceBySkillLevel[idx][ch->GetComboSequence()] != bArg)
+		{
+			HackScalar = 1;
+			ch->SetValidComboInterval(300);
+
+			sys_log(0, "COMBO_HACK: 3 %s arg:%u valid:%u combo_idx:%d combo_seq:%d",
+				ch->GetName(),
+				bArg,
+				ComboSequenceBySkillLevel[idx][ch->GetComboSequence()],
+				idx,
+				ch->GetComboSequence());
+		}
+		else
+		{
+			if (CheckSpeedHack && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
+			{
+				HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 100;
+
+				sys_log(0, "COMBO_HACK: 2 %s arg:%u interval:%d valid:%u atkspd:%u riding:%s",
+					ch->GetName(),
+					bArg,
+					ComboInterval,
+					ch->GetValidComboInterval(),
+					ch->GetPoint(POINT_ATT_SPEED),
+					ch->IsRiding() ? "yes" : "no");
+			}
+
+			//    15 ~ 16 趺磯
+			//if (ch->IsHorseRiding())
+			if (ch->IsRiding())
+				ch->SetComboSequence(ch->GetComboSequence() == 1 ? 2 : 1);
+			else
+				ch->SetComboSequence(ch->GetComboSequence() + 1);
+
+			ch->SetValidComboInterval((int)(ani_combo_speed(ch, bArg - 13) / (ch->GetPoint(POINT_ATT_SPEED) / 100.f)));
+			ch->SetLastComboTime(dwTime);
+		}
+	}
+	else if (bArg == 13) // 羞  (逵(Polymorph)  쨈)
+	{
+		if (CheckSpeedHack && ComboInterval > 0 && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
+		{
+			// 模 沽  牟풔 황  玖
+			// 첫째 頻 탓  攷  황 澁.
+			// 肩  頻 튕 李 羚  湄  활화.
+			//HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 100;
+
+			//sys_log(0, "COMBO_HACK: 6 %s arg:%u interval:%d valid:%u atkspd:%u",
+			//	ch->GetName(),
+			//	bArg,
+			//	ComboInterval,
+			//	ch->GetValidComboInterval(),
+			//	ch->GetPoint(POINT_ATT_SPEED)
+			//);
+		}
+
+		if (ch->GetRaceNum() >= MAIN_RACE_MAX_NUM)
+		{
+			// POLYMORPH_BUG_FIX
+
+			// DELETEME
+			/*
+			const CMotion * pkMotion = CMotionManager::instance().GetMotion(ch->GetRaceNum(), MAKE_MOTION_KEY(MOTION_MODE_GENERAL, MOTION_NORMAL_ATTACK));
+
+			if (!pkMotion)
+				sys_err("cannot find motion by race %u", ch->GetRaceNum());
+			else
+			{
+				//  繭 1000.f 瞞  클潔트 獵玖抉 撻 90%
+				//  獵玖抉  球퓐 900.f 磯.
+				int k = (int) (pkMotion->GetDuration() / ((float) ch->GetPoint(POINT_ATT_SPEED) / 100.f) * 900.f);
+				ch->SetValidComboInterval(k);
+				ch->SetLastComboTime(dwTime);
+			}
+			*/
+			float normalAttackDuration = CMotionManager::instance().GetNormalAttackDuration(ch->GetRaceNum());
+			int k = (int)(normalAttackDuration / ((float)ch->GetPoint(POINT_ATT_SPEED) / 100.f) * 900.f);
+			ch->SetValidComboInterval(k);
+			ch->SetLastComboTime(dwTime);
+			// END_OF_POLYMORPH_BUG_FIX
+		}
+		else
+		{
+			//  홴풔 頻 都 커 ?
+			//if (ch->GetDesc()->DelayedDisconnect(number(2, 9)))
+			//{
+			//	LogManager::instance().HackLog("Hacker", ch);
+			//	sys_log(0, "HACKER: %s arg %u", ch->GetName(), bArg);
+			//}
+
+			//  湄 ,  푸 傷  玖,
+			//   館求 李 獵.
+
+			// 靡 ,
+			//  poly 0 처,
+			// 클璨【  킷 檳 ,  . <- ,  쩔 .
+			//
+			// 瀏 클璨【   쨌 杉募 커풩躍  (arg == 13)
+			//
+			//  race 寬琯 쨈  甄!  臼 체크 杉.
+
+			//   臼   클潔트 풔漫   틈灸,
+			//  풔瞞  琯...  肩 卍...
+			// by rtsummit
+		}
+	}
+	else
+	{
+		//  홴풔 頻 都 커 ?
+		if (ch->GetDesc()->DelayedDisconnect(number(2, 9)))
+		{
+			LogManager::instance().HackLog("Hacker", ch);
+			sys_log(0, "HACKER: %s arg %u", ch->GetName(), bArg);
+		}
+
+		HackScalar = 10;
+		ch->SetValidComboInterval(300);
+	}
+
+	if (HackScalar)
+	{
+		//  타킬   1.5歌    茄 賦  求 처
+		if (get_dword_time() - ch->GetLastMountTime() > 1500)
+			ch->IncreaseComboHackCount(1 + HackScalar);
+
+		ch->SkipComboAttackByTime(ch->GetValidComboInterval());
+	}
+
+	return HackScalar;
+}
+
+void CInputMain::Move(LPCHARACTER ch, const char* data)
+{
+	if (!ch->CanMove())
+		return;
+
+	struct command_move* pinfo = (struct command_move*)data;
+
+	if (pinfo->bFunc >= FUNC_MAX_NUM && !(pinfo->bFunc & 0x80))
+	{
+		sys_err("invalid move type: %s", ch->GetName());
+		return;
+	}
+
+	/*
+	enum EMoveFuncType
+	{
+		FUNC_WAIT,
+		FUNC_MOVE,
+		FUNC_ATTACK,
+		FUNC_COMBO,
+		FUNC_MOB_SKILL,
+		_FUNC_SKILL,
+		FUNC_MAX_NUM,
+		FUNC_SKILL = 0x80,
+	};
+	*/
+
+	// 米트  체크
+
+	//if (!test_server) // 20120515  : 硫 (쨌) 模   牟퓔庸 阜 頻 榴  羚.
+	{
+		const float fDist = DISTANCE_SQRT((ch->GetX() - pinfo->lX) / 100, (ch->GetY() - pinfo->lY) / 100);
+#ifdef MOUNT_FIX
+		if (((false == ch->IsRiding() && fDist > 750) || fDist > 999) && OXEVENT_MAP_INDEX != ch->GetMapIndex())
+#else
+		if (((false == ch->IsRiding() && fDist > 25) || fDist > 60) && OXEVENT_MAP_INDEX != ch->GetMapIndex())
+#endif
+		{
+			sys_log(0, "MOVE: %s trying to move too far (dist: %.1fm) Riding(%d)", ch->GetName(), fDist, ch->IsRiding());
+
+			ch->Show(ch->GetMapIndex(), ch->GetX(), ch->GetY(), ch->GetZ());
+			ch->Stop();
+			return;
+		}
+
+		//
+		// 풩(SPEEDHACK) Check
+		//
+		int dwCurTime = get_dword_time();
+		// 챨 Sync構 7   講磯. (20090702  5却)
+		bool CheckSpeedHack = (false == ch->GetDesc()->IsHandshaking() && dwCurTime - ch->GetDesc()->GetClientTime() > 7000);
+
+		if (CheckSpeedHack)
+		{
+			int iDelta = (int)(dwCurTime - pinfo->dwTime);
+			int iServerDelta = (int)(dwCurTime - ch->GetDesc()->GetClientTime());
+
+			iDelta = (int)(dwCurTime - pinfo->dwTime);
+
+			// 챨 歌蹈. 求 慣琉 巒畇. 짜 肩   체크瞞. TODO
+			if (iDelta >= 30000)
+			{
+				sys_log(0, "SPEEDHACK: slow timer name %s delta %d", ch->GetName(), iDelta);
+				ch->GetDesc()->DelayedDisconnect(3);
+			}
+			// 1却 20msec  째  磯.
+			else if (iDelta < -(iServerDelta / 50))
+			{
+				sys_log(0, "SPEEDHACK: DETECTED! %s (delta %d %d)", ch->GetName(), iDelta, iServerDelta);
+				ch->GetDesc()->DelayedDisconnect(3);
+			}
+		}
+
+		//
+		// 頻  풩 체크
+		//
+		if (pinfo->bFunc == FUNC_COMBO && g_bCheckMultiHack)
+		{
+			// DoS mitigation: rate-limit combo packets
+			if (ch->CheckComboFlood(dwCurTime))
+				return;
+			CheckComboHack(ch, pinfo->bArg, pinfo->dwTime, CheckSpeedHack);
+		}
+	}
+
+	if (pinfo->bFunc == FUNC_MOVE)
+	{
+		if (ch->GetLimitPoint(POINT_MOV_SPEED) == 0)
+			return;
+
+		ch->SetRotation(pinfo->bRot * 5);
+		ch->ResetStopTime();
+
+		ch->Goto(pinfo->lX, pinfo->lY);
+	}
+	else
+	{
+		if (pinfo->bFunc == FUNC_ATTACK || pinfo->bFunc == FUNC_COMBO)
+			ch->OnMove(true);
+		else if (pinfo->bFunc & FUNC_SKILL)
+		{
+			const int MASK_SKILL_MOTION = 0x7F;
+			unsigned int motion = pinfo->bFunc & MASK_SKILL_MOTION;
+
+			if (!ch->IsUsableSkillMotion(motion))
+			{
+				const char* name = ch->GetName();
+				unsigned int job = ch->GetJob();
+				unsigned int group = ch->GetSkillGroup();
+
+				char szBuf[256];
+				snprintf(szBuf, sizeof(szBuf), "SKILL_HACK: name=%s, job=%d, group=%d, motion=%d", name, job, group, motion);
+				LogManager::Instance().HackLog(szBuf, ch->GetDesc()->GetAccountTable().login, ch->GetName(), ch->GetDesc()->GetHostName());
+				sys_log(0, "%s", szBuf);
+
+				if (test_server)
+				{
+					ch->GetDesc()->DelayedDisconnect(number(2, 8));
+					ch->ChatPacket(CHAT_TYPE_INFO, szBuf);
+				}
+				else
+				{
+					ch->GetDesc()->DelayedDisconnect(number(150, 500));
+				}
+			}
+
+			ch->OnMove();
+		}
+
+		ch->SetRotation(pinfo->bRot * 5); // 揷 湄
+		ch->ResetStopTime(); // ""
+
+		ch->Move(pinfo->lX, pinfo->lY);
+		ch->Stop();
+		ch->StopStaminaConsume();
+	}
+
+	TPacketGCMove pack;
+
+	pack.bHeader = HEADER_GC_MOVE;
+	pack.bFunc = pinfo->bFunc;
+	pack.bArg = pinfo->bArg;
+	pack.bRot = pinfo->bRot;
+	pack.dwVID = ch->GetVID();
+	pack.lX = pinfo->lX;
+	pack.lY = pinfo->lY;
+	pack.dwTime = pinfo->dwTime;
+	pack.dwDuration = (pinfo->bFunc == FUNC_MOVE) ? ch->GetCurrentMoveDuration() : 0;
+
+	ch->PacketAround(&pack, sizeof(TPacketGCMove), ch);
+	/*
+		if (pinfo->dwTime == 10653691) //  煞
+		{
+			if (ch->GetDesc()->DelayedDisconnect(number(15, 30)))
+				LogManager::instance().HackLog("Debugger", ch);
+
+		}
+		else if (pinfo->dwTime == 10653971) // Softice 煞
+		{
+			if (ch->GetDesc()->DelayedDisconnect(number(15, 30)))
+				LogManager::instance().HackLog("Softice", ch);
+		}
+	*/
+	/*
+	sys_log(0,
+			"MOVE: %s Func:%u Arg:%u Pos:%dx%d Time:%u Dist:%.1f",
+			ch->GetName(),
+			pinfo->bFunc,
+			pinfo->bArg,
+			pinfo->lX / 100,
+			pinfo->lY / 100,
+			pinfo->dwTime,
+			fDist);
+	*/
+}
+
+void CInputMain::Attack(LPCHARACTER ch, const BYTE header, const char* data)
+{
+	if (NULL == ch)
+		return;
+
+	// [Security] Spectator/observer characters must never be able to attack (packet injection / ghost attack)
+	if (ch->IsObserverMode() || ch->IsDead())
+		return;
+
+	struct type_identifier
+	{
+		BYTE header;
+		BYTE type;
+	};
+
+	const struct type_identifier* const type = reinterpret_cast<const struct type_identifier*>(data);
+
+	if (type->type > 0)
+	{
+		if (false == ch->CanUseSkill(type->type))
+		{
+			return;
+		}
+
+		switch (type->type)
+		{
+			case SKILL_GEOMPUNG:
+			case SKILL_SANGONG:
+			case SKILL_YEONSA:
+			case SKILL_KWANKYEOK:
+			case SKILL_HWAJO:
+			case SKILL_GIGUNG:
+			case SKILL_PABEOB:
+			case SKILL_MARYUNG:
+			case SKILL_TUSOK:
+#if defined(__9TH_SKILL__)
+			case SKILL_ILGWANGPYO:
+			case SKILL_PUNGLOEPO:
+			case SKILL_MABEOBAGGWI:
+			case SKILL_METEO:
+#endif
+			case SKILL_MAHWAN:
+			case SKILL_BIPABU:
+			case SKILL_NOEJEON:
+			case SKILL_CHAIN:
+			case SKILL_HORSE_WILDATTACK_RANGE:
+				if (HEADER_CG_SHOOT != type->header)
+				{
+					if (test_server)
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Attack :name[%s] Vnum[%d] can't use skill by attack(warning)", type->type));
+					return;
+				}
+				break;
+		}
+	}
+
+	switch (header)
+	{
+		case HEADER_CG_ATTACK:
+		{
+			if (NULL == ch->GetDesc())
+				return;
+
+			const TPacketCGAttack* const packMelee = reinterpret_cast<const TPacketCGAttack*>(data);
+
+			ch->GetDesc()->AssembleCRCMagicCube(packMelee->bCRCMagicCubeProcPiece, packMelee->bCRCMagicCubeFilePiece);
+
+			LPCHARACTER victim = CHARACTER_MANAGER::instance().Find(packMelee->dwVID);
+
+			if (NULL == victim || ch == victim)
+				return;
+
+			switch (victim->GetCharType())
+			{
+				case CHAR_TYPE_NPC:
+				case CHAR_TYPE_WARP:
+				case CHAR_TYPE_GOTO:
+				case CHAR_TYPE_HORSE:
+					//#if defined(__GROWTH_PET_SYSTEM__)
+				case CHAR_TYPE_PET:
+					//#endif
+				case CHAR_TYPE_PET_PAY:
+				case CHAR_TYPE_SHOP:
+					return;
+			}
+
+			if (packMelee->bType > 0)
+			{
+				if (false == ch->CheckSkillHitCount(packMelee->bType, victim->GetVID()))
+				{
+					return;
+				}
+			}
+
+			ch->Attack(victim, packMelee->bType);
+		}
+		break;
+
+		case HEADER_CG_SHOOT:
+		{
+			const TPacketCGShoot* const packShoot = reinterpret_cast<const TPacketCGShoot*>(data);
+
+			ch->Shoot(packShoot->bType);
+		}
+		break;
+	}
+}
+
+int CInputMain::SyncPosition(LPCHARACTER ch, const char* c_pcData, size_t uiBytes)
+{
+	const TPacketCGSyncPosition* pinfo = reinterpret_cast<const TPacketCGSyncPosition*>(c_pcData);
+
+	if (uiBytes < pinfo->wSize)
+		return -1;
+
+	int iExtraLen = pinfo->wSize - sizeof(TPacketCGSyncPosition);
+
+	if (iExtraLen < 0)
+	{
+		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->wSize, uiBytes);
+		ch->GetDesc()->SetPhase(PHASE_CLOSE);
+		return -1;
+	}
+
+	if (0 != (iExtraLen % sizeof(TPacketCGSyncPositionElement)))
+	{
+		sys_err("invalid packet length %d (name: %s)", pinfo->wSize, ch->GetName());
+		return iExtraLen;
+	}
+
+	int iCount = iExtraLen / sizeof(TPacketCGSyncPositionElement);
+
+	if (iCount <= 0)
+		return iExtraLen;
+
+	static const int nCountLimit = 16;
+
+	if (iCount > nCountLimit)
+	{
+		// LogManager::instance().HackLog( "SYNC_POSITION_HACK", ch );
+		sys_err("Too many SyncPosition Count(%d) from Name(%s)", iCount, ch->GetName());
+		// ch->GetDesc()->SetPhase(PHASE_CLOSE);
+		// return -1;
+		iCount = nCountLimit;
+	}
+
+	TEMP_BUFFER tbuf;
+	LPBUFFER lpBuf = tbuf.getptr();
+
+	TPacketGCSyncPosition* pHeader = (TPacketGCSyncPosition*)buffer_write_peek(lpBuf);
+	buffer_write_proceed(lpBuf, sizeof(TPacketGCSyncPosition));
+
+	const TPacketCGSyncPositionElement* e =
+		reinterpret_cast<const TPacketCGSyncPositionElement*>(c_pcData + sizeof(TPacketCGSyncPosition));
+
+	timeval tvCurTime;
+	gettimeofday(&tvCurTime, NULL);
+
+	for (int i = 0; i < iCount; ++i, ++e)
+	{
+		LPCHARACTER victim = CHARACTER_MANAGER::instance().Find(e->dwVID);
+
+		if (!victim)
+			continue;
+
+		switch (victim->GetCharType())
+		{
+			case CHAR_TYPE_NPC:
+			case CHAR_TYPE_WARP:
+			case CHAR_TYPE_GOTO:
+			case CHAR_TYPE_HORSE:
+				//#if defined(__GROWTH_PET_SYSTEM__)
+			case CHAR_TYPE_PET:
+				//#endif
+			case CHAR_TYPE_PET_PAY:
+			case CHAR_TYPE_SHOP:
+				continue;
+		}
+
+		//  講
+		if (!victim->SetSyncOwner(ch))
+			continue;
+
+		const float fDistWithSyncOwner = DISTANCE_SQRT((victim->GetX() - ch->GetX()) / 100, (victim->GetY() - ch->GetY()) / 100);
+		static const float fLimitDistWithSyncOwner = 2500.f + 1000.f;
+		// victim 타 2500 + a 鵑見  .
+		// 타  : 클潔트 __GetSkillTargetRange, __GetBowRange 獨
+		// 2500 : 킬 proto  타  킬 타, 풔 활 타
+		// a = POINT_BOW_DISTANCE ... 琯  求   霽０. 犬 , 킬, 트 쨉...
+		// 瀏 혹처 求  紡  漫 1000.f  ...
+		if (fDistWithSyncOwner > fLimitDistWithSyncOwner)
+		{
+			// g_iSyncHackLimitCount  .
+			if (ch->GetSyncHackCount() < g_iSyncHackLimitCount)
+			{
+				ch->SetSyncHackCount(ch->GetSyncHackCount() + 1);
+				continue;
+			}
+			else
+			{
+				LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
+
+				sys_err("Too far SyncPosition DistanceWithSyncOwner(%f)(%s) from Name(%s) CH(%d,%d) VICTIM(%d,%d) SYNC(%d,%d)",
+					fDistWithSyncOwner, victim->GetName(), ch->GetName(), ch->GetX(), ch->GetY(), victim->GetX(), victim->GetY(),
+					e->lX, e->lY);
+
+				ch->GetDesc()->SetPhase(PHASE_CLOSE);
+
+				return -1;
+			}
+		}
+
+		const float fDist = DISTANCE_SQRT((victim->GetX() - e->lX) / 100, (victim->GetY() - e->lY) / 100);
+		static const long g_lValidSyncInterval = 100 * 1000; // 100ms
+		const timeval& tvLastSyncTime = victim->GetLastSyncTime();
+		timeval* tvDiff = timediff(&tvCurTime, &tvLastSyncTime);
+
+		// SyncPosition 퓻臼 타 鵑    歐 臼,
+		//   g_lValidSyncInterval ms 犬 母 SyncPosition狗 玖  .
+		if (tvDiff->tv_sec == 0 && tvDiff->tv_usec < g_lValidSyncInterval)
+		{
+			// g_iSyncHackLimitCount  .
+			if (ch->GetSyncHackCount() < g_iSyncHackLimitCount)
+			{
+				ch->SetSyncHackCount(ch->GetSyncHackCount() + 1);
+				continue;
+			}
+			else
+			{
+				LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
+
+				sys_err("Too often SyncPosition Interval(%ldms)(%s) from Name(%s) VICTIM(%d,%d) SYNC(%d,%d)",
+					tvDiff->tv_sec * 1000 + tvDiff->tv_usec / 1000, victim->GetName(), ch->GetName(), victim->GetX(), victim->GetY(),
+					e->lX, e->lY);
+
+				ch->GetDesc()->SetPhase(PHASE_CLOSE);
+
+				return -1;
+			}
+		}
+		else if (fDist > 25.0f)
+		{
+			LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
+
+			sys_err("Too far SyncPosition Distance(%f)(%s) from Name(%s) CH(%d,%d) VICTIM(%d,%d) SYNC(%d,%d)",
+				fDist, victim->GetName(), ch->GetName(), ch->GetX(), ch->GetY(), victim->GetX(), victim->GetY(),
+				e->lX, e->lY);
+
+			ch->GetDesc()->SetPhase(PHASE_CLOSE);
+
+			return -1;
+		}
+		else
+		{
+			victim->SetLastSyncTime(tvCurTime);
+			victim->Sync(e->lX, e->lY);
+			buffer_write(lpBuf, e, sizeof(TPacketCGSyncPositionElement));
+		}
+	}
+
+	if (buffer_size(lpBuf) != sizeof(TPacketGCSyncPosition))
+	{
+		pHeader->bHeader = HEADER_GC_SYNC_POSITION;
+		pHeader->wSize = buffer_size(lpBuf);
+
+		ch->PacketAround(buffer_read_peek(lpBuf), buffer_size(lpBuf), ch);
+	}
+
+	return iExtraLen;
+}
+
+void CInputMain::FlyTarget(LPCHARACTER ch, const char* pcData, BYTE bHeader)
+{
+	TPacketCGFlyTargeting* p = (TPacketCGFlyTargeting*)pcData;
+	ch->FlyTarget(p->dwTargetVID, p->x, p->y, bHeader);
+}
+
+void CInputMain::UseSkill(LPCHARACTER ch, const char* pcData)
+{
+	TPacketCGUseSkill* p = (TPacketCGUseSkill*)pcData;
+	ch->UseSkill(p->dwVnum, CHARACTER_MANAGER::instance().Find(p->dwVID));
+}
+
+void CInputMain::ScriptButton(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGScriptButton* p = (TPacketCGScriptButton*)c_pData;
+	sys_log(0, "QUEST ScriptButton pid %d idx %u", ch->GetPlayerID(), p->idx);
+
+	quest::PC* pc = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
+	if (pc && pc->IsConfirmWait())
+	{
+		quest::CQuestManager::instance().Confirm(ch->GetPlayerID(), quest::CONFIRM_TIMEOUT);
+	}
+	else if (p->idx & 0x80000000)
+	{
+		quest::CQuestManager::Instance().QuestInfo(ch->GetPlayerID(), p->idx & 0x7fffffff);
+	}
+	else
+	{
+		quest::CQuestManager::Instance().QuestButton(ch->GetPlayerID(), p->idx);
+	}
+}
+
+void CInputMain::ScriptAnswer(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGScriptAnswer* p = (TPacketCGScriptAnswer*)c_pData;
+	sys_log(0, "QUEST ScriptAnswer pid %d answer %d", ch->GetPlayerID(), p->answer);
+
+	if (p->answer > 250) //  튼    킷 
+	{
+		quest::CQuestManager::Instance().Resume(ch->GetPlayerID());
+	}
+	else //  튼   킷 
+	{
+		quest::CQuestManager::Instance().Select(ch->GetPlayerID(), p->answer);
+	}
+}
+
+// SCRIPT_SELECT_ITEM
+void CInputMain::ScriptSelectItem(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGScriptSelectItem* p = (TPacketCGScriptSelectItem*)c_pData;
+	sys_log(0, "QUEST ScriptSelectItem pid %d answer %d", ch->GetPlayerID(), p->selection);
+	quest::CQuestManager::Instance().SelectItem(ch->GetPlayerID(), p->selection);
+}
+// END_OF_SCRIPT_SELECT_ITEM
+
+#if defined(__GEM_SYSTEM__)
+void CInputMain::SelectItemEx(LPCHARACTER c_lpCh, const void* c_pvData)
+{
+	if (c_lpCh == nullptr)
+		return;
+
+	TPacketCGSelectItemEx* pPacket = (TPacketCGSelectItemEx*)c_pvData;
+	sys_log(0, "SelectItemEx player (pid: %d) item (pos: %d)", c_lpCh->GetPlayerID(), pPacket->dwItemPos);
+	c_lpCh->SelectItemEx(pPacket->dwItemPos, pPacket->bType);
+}
+#endif
+
+#if defined(__QUEST_REQUEST_EVENT__)
+void CInputMain::RequestEventQuest(LPCHARACTER pChar, const void* c_pvData)
+{
+	const TPacketCGRequestEventQuest* c_pData = reinterpret_cast<const TPacketCGRequestEventQuest*>(c_pvData);
+	unsigned int uiQuestIndex = quest::CQuestManager::instance().GetQuestIndexByName(c_pData->szEventQuest);
+	if (uiQuestIndex)
+	{
+		if (quest::CQuestManager::instance().GetPCForce(pChar->GetPlayerID())->IsRunning())
+			return;
+
+		sys_log(0, "QUEST RequestEventQuest pid(%d), qid(%d)", pChar->GetPlayerID(), uiQuestIndex);
+		quest::CQuestManager::instance().RequestEvent(pChar->GetPlayerID(), uiQuestIndex, 0);
+	}
+}
+#endif
+
+void CInputMain::QuestInputString(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGQuestInputString* p = (TPacketCGQuestInputString*)c_pData;
+
+	char msg[65];
+	strlcpy(msg, p->msg, sizeof(msg));
+	sys_log(0, "QUEST InputString pid %u msg %s", ch->GetPlayerID(), msg);
+
+	quest::CQuestManager::Instance().Input(ch->GetPlayerID(), msg);
+}
+
+#if defined(__OX_RENEWAL__)
+void CInputMain::QuestInputLongString(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGQuestInputLongString* p = (TPacketCGQuestInputLongString*)c_pData;
+
+	char msg[129];
+	strlcpy(msg, p->msg, sizeof(msg));
+	sys_log(0, "QUEST InputLongString pid %u msg %s", ch->GetPlayerID(), msg);
+
+	quest::CQuestManager::Instance().Input(ch->GetPlayerID(), msg);
+}
+#endif
+
+void CInputMain::QuestConfirm(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGQuestConfirm* p = (TPacketCGQuestConfirm*)c_pData;
+	LPCHARACTER ch_wait = CHARACTER_MANAGER::instance().FindByPID(p->requestPID);
+	if (p->answer)
+		p->answer = quest::CONFIRM_YES;
+	sys_log(0, "QuestConfirm from %s pid %u name %s answer %d", ch->GetName(), p->requestPID, (ch_wait) ? ch_wait->GetName() : "", p->answer);
+	if (ch_wait)
+	{
+		quest::CQuestManager::Instance().Confirm(ch_wait->GetPlayerID(), (quest::EQuestConfirmType)p->answer, ch->GetPlayerID());
+	}
+}
+
+void CInputMain::Target(LPCHARACTER ch, const char* pcData)
+{
+	TPacketCGTarget* p = (TPacketCGTarget*)pcData;
+
+	building::LPOBJECT pkObj = building::CManager::instance().FindObjectByVID(p->dwVID);
+
+	if (pkObj)
+	{
+		TPacketGCTarget pckTarget;
+		pckTarget.header = HEADER_GC_TARGET;
+		pckTarget.dwVID = p->dwVID;
+#if defined(__DEFENSE_WAVE__)
+		pckTarget.bAlliance = false;
+#endif
+		ch->GetDesc()->Packet(&pckTarget, sizeof(TPacketGCTarget));
+	}
+	else
+		ch->SetTarget(CHARACTER_MANAGER::instance().Find(p->dwVID));
+}
+
+void CInputMain::Warp(LPCHARACTER ch, const char* pcData)
+{
+	ch->WarpEnd();
+}
+
+void CInputMain::SafeboxCheckin(LPCHARACTER ch, const char* c_pData)
+{
+	if (quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID())->IsRunning() == true)
+		return;
+
+	TPacketCGSafeboxCheckin* p = (TPacketCGSafeboxCheckin*)c_pData;
+
+	if (!ch->CanHandleItem())
+		return;
+
+	// [Security] Mutual exclusion: forbid safebox actions while other trade windows are open
+	if (!ch->IsOpenSafebox())
+		return;
+	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
+		return;
+
+	CSafebox* pkSafebox = ch->GetSafebox();
+	LPITEM pkItem = ch->GetItem(p->ItemPos);
+
+	if (!pkSafebox || !pkItem)
+		return;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	if (pkItem->GetCell() >= ch->GetExtendInvenMax() && IS_SET(pkItem->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+#else
+	if (pkItem->GetCell() >= INVENTORY_MAX_NUM && IS_SET(pkItem->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+#endif
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창> 창 킥    都求."));
+		return;
+	}
+
+	if (!pkSafebox->IsEmpty(p->bSafePos, pkItem->GetSize()))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창> 킥   치都求."));
+		return;
+	}
+
+	if (pkItem->GetSIGVnum() == UNIQUE_GROUP_LARGE_SAFEBOX)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창>     求."));
+		return;
+	}
+
+	if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_SAFEBOX))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창>     求."));
+		return;
+	}
+
+	if (pkItem->IsEquipped())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Storeroom] An item that is currently being used cannot be stored."));
+		return;
+	}
+
+#if defined(__PET_SYSTEM__)
+	CPetSystem* pPetSystem = ch->GetPetSystem();
+	if (pPetSystem && pPetSystem->GetSummonItemVID() == pkItem->GetVID())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Storeroom] An item that is currently being used cannot be stored."));
+		return;
+	}
+#endif
+
+	if (true == pkItem->isLocked())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창>     求."));
+		return;
+	}
+
+	// Prevent items from the belt inventory checking-in the safebox.
+	if (p->ItemPos.window_type == BELT_INVENTORY)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Cannot proceed."));
+		return;
+	}
+
+	pkItem->RemoveFromCharacter();
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (!pkItem->IsDragonSoul())
+#endif
+		ch->SyncQuickslot(SLOT_TYPE_INVENTORY, p->ItemPos.cell, WORD_MAX);
+
+	pkSafebox->Add(p->bSafePos, pkItem);
+#ifdef __GROWTH_PET_SYSTEM__
+	if (pkItem->GetType() == ITEM_PET)
+	{
+		if (pkItem->GetSubType() == PET_UPBRINGING || pkItem->GetSubType() == PET_BAG)
+		{
+			LPGROWTH_PET pPet = ch->GetGrowthPet(pkItem->GetSocket(2));
+			if (pPet)
+				pkSafebox->AddPet(pPet);
+		}
+	}
+#endif
+	char szHint[128];
+	snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
+	LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX PUT", szHint);
+}
+
+void CInputMain::SafeboxCheckout(LPCHARACTER ch, const char* c_pData, bool bMall)
+{
+	TPacketCGSafeboxCheckout* p = (TPacketCGSafeboxCheckout*)c_pData;
+
+	if (!ch->CanHandleItem())
+		return;
+
+	// [Security] Mutual exclusion: safebox operations must not be possible alongside exchange/shop/cube (packet overlap / dup prevention)
+	if (!bMall && !ch->IsOpenSafebox())
+		return;
+	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
+		return;
+
+	CSafebox* pkSafebox;
+
+	if (bMall)
+		pkSafebox = ch->GetMall();
+	else
+		pkSafebox = ch->GetSafebox();
+
+	if (!pkSafebox)
+		return;
+
+	LPITEM pkItem = pkSafebox->Get(p->bSafePos);
+	if (!pkItem)
+		return;
+
+	if (p->ItemPos.IsBeltInventoryPosition())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Cannot proceed."));
+		return;
+	}
+
+#if defined(__SAFEBOX_IMPROVING__)
+	if ((p->ItemPos.window_type == INVENTORY) && (p->ItemPos.cell == 0))
+	{
+		BYTE bWindow = INVENTORY;
+		INT iCell = -1;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (pkItem->IsDragonSoul())
+		{
+			bWindow = DRAGON_SOUL_INVENTORY;
+			iCell = ch->GetEmptyDragonSoulInventory(pkItem);
+		}
+
+		else
+#endif
+		{
+			bWindow = INVENTORY;
+			iCell = ch->GetEmptyInventory(pkItem->GetSize());
+		}
+
+
+		if (iCell < 0)
+			return;
+
+		pkSafebox->Remove(p->bSafePos);
+		if (bMall)
+		{
+			if (NULL == pkItem->GetProto())
+			{
+				sys_err("pkItem->GetProto() == NULL (id : %d)", pkItem->GetID());
+				return;
+			}
+			// 100% 확 憺 毛 求쨉  毛獵摸  . ...............
+			if (100 == pkItem->GetProto()->bAlterToMagicItemPct && 0 == pkItem->GetAttributeCount())
+			{
+				pkItem->AlterToMagicItem(number(40, 50), number(10, 15));
+			}
+		}
+		pkItem->AddToCharacter(ch, TItemPos(bWindow, (WORD)iCell)
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			, false
+#endif
+		);
+		ITEM_MANAGER::Instance().FlushDelayedSave(pkItem);
+
+		DWORD dwID = pkItem->GetID();
+		db_clientdesc->DBPacketHeader(HEADER_GD_ITEM_FLUSH, 0, sizeof(DWORD));
+		db_clientdesc->Packet(&dwID, sizeof(DWORD));
+
+		char szHint[128];
+		snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
+		if (bMall)
+			LogManager::instance().ItemLog(ch, pkItem, "MALL GET", szHint);
+		else
+			LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX GET", szHint);
+
+		return;
+	}
+#endif
+
+	if (!ch->IsEmptyItemGrid(p->ItemPos, pkItem->GetSize()))
+		return;
+
+	//   觀 킥 觀極 혼 특 처
+	// (   item_proto 풩홱 憺 袂 ,
+	// 혼 ,  처   憺 毬  歌 홱.)
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (pkItem->IsDragonSoul())
+	{
+		if (bMall)
+		{
+			DSManager::instance().DragonSoulItemInitialize(pkItem);
+		}
+
+		if (DRAGON_SOUL_INVENTORY != p->ItemPos.window_type)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창> 킥   치都求."));
+			return;
+		}
+
+		TItemPos DestPos = p->ItemPos;
+		if (!DSManager::instance().IsValidCellForThisItem(pkItem, DestPos))
+		{
+			int iCell = ch->GetEmptyDragonSoulInventory(pkItem);
+			if (iCell < 0)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창> 킥   치都求."));
+				return;
+			}
+			DestPos = TItemPos(DRAGON_SOUL_INVENTORY, iCell);
+		}
+
+		pkSafebox->Remove(p->bSafePos);
+		pkItem->AddToCharacter(ch, DestPos);
+		ITEM_MANAGER::instance().FlushDelayedSave(pkItem);
+	}
+	else
+#endif
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (DRAGON_SOUL_INVENTORY == p->ItemPos.window_type)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<창> 킥   치都求."));
+			return;
+		}
+#endif
+
+		pkSafebox->Remove(p->bSafePos);
+		if (bMall)
+		{
+			if (NULL == pkItem->GetProto())
+			{
+				sys_err("pkItem->GetProto() == NULL (id : %d)", pkItem->GetID());
+				return;
+			}
+			// 100% 확 憺 毛 求쨉  毛獵摸  . ...............
+			if (100 == pkItem->GetProto()->bAlterToMagicItemPct && 0 == pkItem->GetAttributeCount())
+			{
+				pkItem->AlterToMagicItem(number(40, 50), number(10, 15));
+			}
+		}
+		pkItem->AddToCharacter(ch, p->ItemPos);
+		ITEM_MANAGER::instance().FlushDelayedSave(pkItem);
+#ifdef __GROWTH_PET_SYSTEM__
+		if (pkItem->GetType() == ITEM_PET)
+		{
+			if (pkItem->GetSubType() == PET_UPBRINGING || pkItem->GetSubType() == PET_BAG)
+				pkSafebox->RemovePet(pkItem);
+		}
+#endif
+	}
+
+	DWORD dwID = pkItem->GetID();
+	db_clientdesc->DBPacketHeader(HEADER_GD_ITEM_FLUSH, 0, sizeof(DWORD));
+	db_clientdesc->Packet(&dwID, sizeof(DWORD));
+
+	char szHint[128];
+	snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
+	if (bMall)
+		LogManager::instance().ItemLog(ch, pkItem, "MALL GET", szHint);
+	else
+		LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX GET", szHint);
+}
+
+void CInputMain::SafeboxItemMove(LPCHARACTER ch, const char* data)
+{
+	struct command_item_move* pinfo = (struct command_item_move*)data;
+
+	if (!ch->CanHandleItem())
+		return;
+
+	// [Security] Mutual exclusion: block safebox operations while other trade windows are open
+	if (!ch->IsOpenSafebox())
+		return;
+	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
+		return;
+
+	if (!ch->GetSafebox())
+		return;
+
+	ch->GetSafebox()->MoveItem(pinfo->Cell.cell, pinfo->CellTo.cell, pinfo->count);
+}
+
+// PARTY_JOIN_BUG_FIX
+void CInputMain::PartyInvite(LPCHARACTER ch, const char* c_pData)
+{
+	if (!ch)
+		return;
+
+	if (ch->GetArena())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("恙 絿  求."));
+		return;
+	}
+
+	if (m_iBufferLeft < (int)sizeof(TPacketCGPartyInvite))
+	{
+		sys_err("PARTY_INVITE: malformed packet (len=%d < %u)", m_iBufferLeft, (unsigned)sizeof(TPacketCGPartyInvite));
+		return;
+	}
+
+	TPacketCGPartyInvite* p = (TPacketCGPartyInvite*)c_pData;
+
+	LPCHARACTER pInvitee = CHARACTER_MANAGER::instance().Find(p->vid);
+	if (ch == pInvitee)
+		return;
+
+	if (!pInvitee || !ch->GetDesc() || !pInvitee->GetDesc() || !pInvitee->IsPC() || !ch->IsPC())
+	{
+		sys_err("PARTY Cannot find invited character");
+		return;
+	}
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	if (CMessengerManager::instance().IsBlocked(ch->GetName(), pInvitee->GetName()))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", pInvitee->GetName()));
+		return;
+	}
+	else if (CMessengerManager::instance().IsBlocked(pInvitee->GetName(), ch->GetName()))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", pInvitee->GetName()));
+		return;
+	}
+#endif
+
+	ch->PartyInvite(pInvitee);
+}
+
+void CInputMain::PartyInviteAnswer(LPCHARACTER ch, const char* c_pData)
+{
+	if (!ch)
+		return;
+
+	if (ch->GetArena())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("恙 絿  求."));
+		return;
+	}
+
+	if (m_iBufferLeft < (int)sizeof(TPacketCGPartyInviteAnswer))
+	{
+		sys_err("PARTY_INVITE_ANSWER: malformed packet (len=%d < %u)", m_iBufferLeft, (unsigned)sizeof(TPacketCGPartyInviteAnswer));
+		return;
+	}
+
+	TPacketCGPartyInviteAnswer* p = (TPacketCGPartyInviteAnswer*)c_pData;
+
+	LPCHARACTER pInviter = CHARACTER_MANAGER::instance().Find(p->leader_vid);
+
+	// pInviter  ch  티 청 上.
+
+	if (!pInviter || !pInviter->IsPC())
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티청  캐拷 찾 求."));
+	else if (!p->accept)
+		pInviter->PartyInviteDeny(ch->GetPlayerID());
+	else
+		pInviter->PartyInviteAccept(ch);
+}
+// END_OF_PARTY_JOIN_BUG_FIX
+
+void CInputMain::PartySetState(LPCHARACTER ch, const char* c_pData)
+{
+	if (!CPartyManager::instance().IsEnablePCParty())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>   티  처   求."));
+		return;
+	}
+
+	TPacketCGPartySetState* p = (TPacketCGPartySetState*)c_pData;
+
+	if (!ch->GetParty())
+		return;
+
+	if (ch->GetParty()->GetLeaderPID() != ch->GetPlayerID())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>    笭求."));
+		return;
+	}
+
+	// HARDENING: disallow assigning party roles to self (prevents spoofed packets / recursion edge-cases)
+	if (p->pid == ch->GetPlayerID() && p->byRole != PARTY_ROLE_NORMAL)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "<Party> You cannot assign a party role to yourself.");
+		return;
+	}
+
+	if (!ch->GetParty()->IsMember(p->pid))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 쨍 狗  티 틈爛求."));
+		return;
+	}
+
+	DWORD pid = p->pid;
+	sys_log(0, "PARTY SetRole pid %d to role %d state %s", pid, p->byRole, p->flag ? "on" : "off");
+
+	switch (p->byRole)
+	{
+		case PARTY_ROLE_NORMAL:
+			break;
+
+		case PARTY_ROLE_ATTACKER:
+		case PARTY_ROLE_TANKER:
+		case PARTY_ROLE_BUFFER:
+		case PARTY_ROLE_SKILL_MASTER:
+		case PARTY_ROLE_HASTE:
+		case PARTY_ROLE_DEFENDER:
+			if (ch->GetParty()->SetRole(pid, p->byRole, p->flag))
+			{
+				TPacketPartyStateChange pack;
+				pack.dwLeaderPID = ch->GetPlayerID();
+				pack.dwPID = p->pid;
+				pack.bRole = p->byRole;
+				pack.bFlag = p->flag;
+				db_clientdesc->DBPacket(HEADER_GD_PARTY_STATE_CHANGE, 0, &pack, sizeof(pack));
+			}
+			/*
+			else
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 커  臼求."));
+			*/
+			break;
+
+		default:
+			sys_err("wrong byRole in PartySetState Packet name %s state %d", ch->GetName(), p->byRole);
+			break;
+	}
+}
+
+void CInputMain::PartyRemove(LPCHARACTER ch, const char* c_pData)
+{
+	if (ch->GetArena())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("恙 絿  求."));
+		return;
+	}
+
+	if (!CPartyManager::instance().IsEnablePCParty())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>   티  처   求."));
+		return;
+	}
+
+#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
+	if (ch->GetGuildDragonLair())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot disband the group while you are still active in Meley's Lair."));
+		return;
+	}
+#endif
+
+	TPacketCGPartyRemove* p = (TPacketCGPartyRemove*)c_pData;
+	LPPARTY pParty = ch->GetParty();
+
+	if (!pParty)
+		return;
+
+	if (pParty->GetDungeon_for_Only_party())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  효 티   求."));
+		return;
+	}
+
+	if (pParty->GetLeaderPID() == ch->GetPlayerID())
+	{
+		if (ch->GetDungeon()
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+			|| ch->GetGuildDragonLair()
+#endif
+#if defined(__DEFENSE_WAVE__)
+			|| ch->GetDefenseWave()
+#endif
+			)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  티 衫  求."));
+		}
+		else
+		{
+#ifdef ENABLE_QUEEN_NETHIS
+			if (SnakeLair::CSnk::instance().IsSnakeMap(ch->GetMapIndex()))
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  티 衫  求."));
+				return;
+			}
+#endif
+			// leader can remove any member
+			if (p->pid == ch->GetPlayerID() || pParty->GetMemberCount() == 2)
+			{
+				// party disband
+				CPartyManager::instance().DeleteParty(pParty);
+			}
+			else
+			{
+				LPCHARACTER B = CHARACTER_MANAGER::instance().FindByPID(p->pid);
+				if (B)
+				{
+					//pParty->SendPartyRemoveOneToAll(B);
+					B->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 衫究決求."));
+					//pParty->Unlink(B);
+					//CPartyManager::instance().SetPartyMember(B->GetPlayerID(), NULL);
+				}
+				pParty->Quit(p->pid);
+			}
+		}
+	}
+	else
+	{
+		// otherwise, only remove itself
+		if (p->pid == ch->GetPlayerID())
+		{
+			if (ch->GetDungeon()
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+				|| ch->GetGuildDragonLair()
+#endif
+#if defined(__DEFENSE_WAVE__)
+				|| ch->GetDefenseWave()
+#endif
+				)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  티   求."));
+			}
+			else
+			{
+#ifdef ENABLE_QUEEN_NETHIS
+				if (SnakeLair::CSnk::instance().IsSnakeMap(ch->GetMapIndex()))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티>  티 衫  求."));
+					return;
+				}
+#endif
+				if (pParty->GetMemberCount() == 2)
+				{
+					// party disband
+					CPartyManager::instance().DeleteParty(pParty);
+				}
+				else
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티 決求."));
+					//pParty->SendPartyRemoveOneToAll(ch);
+					pParty->Quit(ch->GetPlayerID());
+					//pParty->SendPartyRemoveAllToOne(ch);
+					//CPartyManager::instance().SetPartyMember(ch->GetPlayerID(), NULL);
+				}
+			}
+		}
+		else
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 摸 티 탈킬  求."));
+		}
+	}
+}
+
+void CInputMain::AnswerMakeGuild(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGAnswerMakeGuild* p = (TPacketCGAnswerMakeGuild*)c_pData;
+
+	if (ch->GetGold() < 200000)
+		return;
+
+	if (ch->GetLevel() < 40)
+		return;
+
+	if (get_global_time() - ch->GetQuestFlag("guild_manage.new_disband_time") <
+		CGuildManager::instance().GetDisbandDelay())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 滿  %d 犬 躍   求.",
+			quest::CQuestManager::instance().GetEventFlag("guild_disband_delay")));
+		return;
+	}
+
+	if (get_global_time() - ch->GetQuestFlag("guild_manage.new_withdraw_time") <
+		CGuildManager::instance().GetWithdrawDelay())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 탈  %d 犬 躍   求.",
+			quest::CQuestManager::instance().GetEventFlag("guild_withdraw_delay")));
+		return;
+	}
+
+	if (ch->GetGuild())
+		return;
+
+	CGuildManager& gm = CGuildManager::instance();
+
+	TGuildCreateParameter cp;
+	memset(&cp, 0, sizeof(cp));
+
+	cp.master = ch;
+	strlcpy(cp.name, p->guild_name, sizeof(cp.name));
+
+	if (cp.name[0] == 0 || !check_name(cp.name))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   見 都求."));
+		return;
+	}
+
+	DWORD dwGuildID = gm.CreateGuild(cp);
+
+	if (dwGuildID)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> [%s] 弱 퓸求.", cp.name));
+
+		int GuildCreateFee;
+
+		if (LC_IsBrazil())
+		{
+			GuildCreateFee = 500000;
+		}
+		else
+		{
+			GuildCreateFee = 200000;
+		}
+
+		ch->PointChange(POINT_GOLD, -GuildCreateFee);
+		DBManager::instance().SendMoneyLog(MONEY_LOG_GUILD, ch->GetPlayerID(), -GuildCreateFee);
+
+		char Log[128];
+		snprintf(Log, sizeof(Log), "GUILD_NAME %s MASTER %s", cp.name, ch->GetName());
+		LogManager::instance().CharLog(ch, 0, "MAKE_GUILD", Log);
+
+		if (g_iUseLocale)
+			ch->RemoveSpecifyItem(GUILD_CREATE_ITEM_VNUM, 1);
+		//ch->SendGuildName(dwGuildID);
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+		CGuildManager::Instance().RequestSetEventFlag(dwGuildID, "create_time", get_global_time());
+#endif
+	}
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   臼求."));
+}
+
+void CInputMain::PartyUseSkill(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGPartyUseSkill* p = (TPacketCGPartyUseSkill*)c_pData;
+	if (!ch->GetParty())
+		return;
+
+	if (ch->GetPlayerID() != ch->GetParty()->GetLeaderPID())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 티  티躍   笭求."));
+		return;
+	}
+
+	switch (p->bySkillIndex)
+	{
+		case PARTY_SKILL_HEAL:
+			ch->GetParty()->HealParty();
+			break;
+		case PARTY_SKILL_WARP:
+		{
+			LPCHARACTER pch = CHARACTER_MANAGER::instance().Find(p->vid);
+			if (pch && pch->IsPC())
+				ch->GetParty()->SummonToLeader(pch->GetPlayerID());
+			else
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<티> 환狗  찾  求."));
+		}
+		break;
+	}
+}
+
+void CInputMain::PartyParameter(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGPartyParameter* p = (TPacketCGPartyParameter*)c_pData;
+
+	if (ch->GetParty() && ch->GetParty()->GetLeaderPID() == ch->GetPlayerID())
+		ch->GetParty()->SetParameter(p->bDistributeMode);
+}
+
+size_t GetSubPacketSize(const GUILD_SUBHEADER_CG& header)
+{
+	switch (header)
+	{
+		case GUILD_SUBHEADER_CG_DEPOSIT_MONEY: return sizeof(int);
+		case GUILD_SUBHEADER_CG_WITHDRAW_MONEY: return sizeof(int);
+		case GUILD_SUBHEADER_CG_ADD_MEMBER: return sizeof(DWORD);
+		case GUILD_SUBHEADER_CG_REMOVE_MEMBER: return sizeof(DWORD);
+		case GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME: return 10;
+		case GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY: return sizeof(BYTE) + sizeof(BYTE);
+		case GUILD_SUBHEADER_CG_OFFER: return sizeof(DWORD);
+		case GUILD_SUBHEADER_CG_CHARGE_GSP: return sizeof(int);
+		case GUILD_SUBHEADER_CG_POST_COMMENT: return 1;
+		case GUILD_SUBHEADER_CG_DELETE_COMMENT: return sizeof(DWORD);
+		case GUILD_SUBHEADER_CG_REFRESH_COMMENT: return 0;
+		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE: return sizeof(DWORD) + sizeof(BYTE);
+		case GUILD_SUBHEADER_CG_USE_SKILL: return sizeof(TPacketCGGuildUseSkill);
+		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL: return sizeof(DWORD) + sizeof(BYTE);
+		case GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER: return sizeof(DWORD) + sizeof(BYTE);
+	}
+
+	return 0;
+}
+
+int CInputMain::Guild(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	if (uiBytes < sizeof(TPacketCGGuild))
+		return -1;
+
+	const TPacketCGGuild* p = reinterpret_cast<const TPacketCGGuild*>(data);
+	const char* c_pData = data + sizeof(TPacketCGGuild);
+
+	uiBytes -= sizeof(TPacketCGGuild);
+
+	const GUILD_SUBHEADER_CG SubHeader = static_cast<GUILD_SUBHEADER_CG>(p->subheader);
+	const size_t SubPacketLen = GetSubPacketSize(SubHeader);
+
+	if (uiBytes < SubPacketLen)
+	{
+		return -1;
+	}
+
+	CGuild* pGuild = ch->GetGuild();
+
+	if (NULL == pGuild)
+	{
+		if (SubHeader != GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 恙  駕求."));
+			return SubPacketLen;
+		}
+	}
+
+	switch (SubHeader)
+	{
+		case GUILD_SUBHEADER_CG_DEPOSIT_MONEY:
+		{
+			// by mhh : 未 逵   .
+			return SubPacketLen;
+
+			const int gold = MIN(*reinterpret_cast<const int*>(c_pData), __deposit_limit());
+
+			if (gold < 0)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 蔘 附都求."));
+				return SubPacketLen;
+			}
+
+			if (ch->GetGold() < gold)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  獵  爛求."));
+				return SubPacketLen;
+			}
+
+			pGuild->RequestDepositMoney(ch, gold);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_WITHDRAW_MONEY:
+		{
+			// by mhh : 未 逵   .
+			return SubPacketLen;
+
+			const int gold = MIN(*reinterpret_cast<const int*>(c_pData), 500000);
+
+			if (gold < 0)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 蔘 附都求."));
+				return SubPacketLen;
+			}
+
+			pGuild->RequestWithdrawMoney(ch, gold);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_ADD_MEMBER:
+		{
+			const DWORD vid = *reinterpret_cast<const DWORD*>(c_pData);
+			LPCHARACTER newmember = CHARACTER_MANAGER::instance().Find(vid);
+
+			if (!newmember)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 瀏  찾  求."));
+				return SubPacketLen;
+			}
+
+			if (!ch->IsPC() || !newmember->IsPC())
+				return SubPacketLen;
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+			if (CMessengerManager::instance().IsBlocked(ch->GetName(), newmember->GetName()))
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", newmember->GetName()));
+				return SubPacketLen;
+			}
+			else if (CMessengerManager::instance().IsBlocked(newmember->GetName(), ch->GetName()))
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", newmember->GetName()));
+				return SubPacketLen;
+			}
+#endif
+
+			if (newmember->GetQuestFlag("change_guild_master.be_other_member") > get_global_time())
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>     캐都求"));
+				return SubPacketLen;
+			}
+
+			pGuild->Invite(ch, newmember);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_REMOVE_MEMBER:
+		{
+			if (pGuild->UnderAnyWar() != 0)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  傷  탈킬  求."));
+				return SubPacketLen;
+			}
+
+			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			LPCHARACTER member = CHARACTER_MANAGER::instance().FindByPID(pid);
+
+			if (member)
+			{
+				if (member->GetGuild() != pGuild)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   弱 틈爛求."));
+					return SubPacketLen;
+				}
+
+				if (!pGuild->HasGradeAuth(m->grade, GUILD_AUTH_REMOVE_MEMBER))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   탈 킬  求."));
+					return SubPacketLen;
+				}
+
+				member->SetQuestFlag("guild_manage.new_withdraw_time", get_global_time());
+				pGuild->RequestRemoveMember(member->GetPlayerID());
+
+				if (LC_IsBrazil() == true)
+				{
+					DBManager::instance().Query("REPLACE INTO guild_invite_limit VALUES(%d, %d)", pGuild->GetID(), get_global_time());
+				}
+			}
+			else
+			{
+				if (!pGuild->HasGradeAuth(m->grade, GUILD_AUTH_REMOVE_MEMBER))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   탈 킬  求."));
+					return SubPacketLen;
+				}
+
+				if (pGuild->RequestRemoveMember(pid))
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   탈 謬求."));
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 瀏  찾  求."));
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME:
+		{
+			char gradename[GUILD_GRADE_NAME_MAX_LEN + 1];
+			strlcpy(gradename, c_pData + 1, sizeof(gradename));
+
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			if (m->grade != GUILD_LEADER_GRADE)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  見   求."));
+			}
+			else if (*c_pData == GUILD_LEADER_GRADE)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   見   求."));
+			}
+			else if (!check_name(gradename))
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>    見 都求."));
+			}
+			else
+			{
+				pGuild->ChangeGradeName(*c_pData, gradename);
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY:
+		{
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			if (m->grade != GUILD_LEADER_GRADE)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>     求."));
+			}
+			else if (*c_pData == GUILD_LEADER_GRADE)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>     求."));
+			}
+			else
+			{
+				pGuild->ChangeGradeAuth(*c_pData, *(c_pData + 1));
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_OFFER:
+		{
+			DWORD offer = *reinterpret_cast<const DWORD*>(c_pData);
+
+			if (pGuild->GetLevel() >= GUILD_MAX_LEVEL && LC_IsHongKong() == false)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 弱 譴 斂 都求."));
+			}
+			else
+			{
+				offer /= 100;
+				offer *= 100;
+
+				if (pGuild->OfferExp(ch, offer))
+				{
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+					ch->UpdateExtBattlePassMissionProgress(GUILD_SPENT_EXP, offer, 0);
+#endif
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> %u 치 臼求.", offer));
+				}
+				else
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 치 悶 臼求."));
+				}
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_CHARGE_GSP:
+		{
+			const int offer = *reinterpret_cast<const int*>(c_pData);
+			const int gold = offer * 100;
+
+			if (offer < 0 || gold < offer || gold < 0 || ch->GetGold() < gold)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  爛求."));
+				return SubPacketLen;
+			}
+
+			if (!pGuild->ChargeSP(ch, offer))
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 킹 회 臼求."));
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_POST_COMMENT:
+		{
+			const size_t length = *c_pData;
+
+			if (length > GUILD_COMMENT_MAX_LEN)
+			{
+				// 蔘 .. .
+				sys_err("POST_COMMENT: %s comment too long (length: %u)", ch->GetName(), length);
+				ch->GetDesc()->SetPhase(PHASE_CLOSE);
+				return -1;
+			}
+
+			if (uiBytes < 1 + length)
+				return -1;
+
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			if (length && !pGuild->HasGradeAuth(m->grade, GUILD_AUTH_NOTICE) && *(c_pData + 1) == '!')
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  蒡  求."));
+			}
+			else
+			{
+				std::string str(c_pData + 1, length);
+				pGuild->AddComment(ch, str);
+			}
+
+			return (1 + length);
+		}
+
+		case GUILD_SUBHEADER_CG_DELETE_COMMENT:
+		{
+			const DWORD comment_id = *reinterpret_cast<const DWORD*>(c_pData);
+
+			pGuild->DeleteComment(ch, comment_id);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_REFRESH_COMMENT:
+			pGuild->RefreshComment(ch);
+			return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE:
+		{
+			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
+			const BYTE grade = *(c_pData + sizeof(DWORD));
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			if (m->grade != GUILD_LEADER_GRADE)
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>    求."));
+			else if (ch->GetPlayerID() == pid)
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>     求."));
+			else if (grade == 1)
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>     求."));
+			else
+				pGuild->ChangeMemberGrade(pid, grade);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_USE_SKILL:
+		{
+			const TPacketCGGuildUseSkill* p = reinterpret_cast<const TPacketCGGuildUseSkill*>(c_pData);
+
+			pGuild->UseSkill(p->dwVnum, ch, p->dwPID);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL:
+		{
+			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
+			const BYTE is_general = *(c_pData + sizeof(DWORD));
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			if (m->grade != GUILD_LEADER_GRADE)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 掠   求."));
+			}
+			else
+			{
+				if (!pGuild->ChangeMemberGeneral(pid, is_general))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> 鵑    求."));
+				}
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER:
+		{
+			const DWORD guild_id = *reinterpret_cast<const DWORD*>(c_pData);
+			const BYTE accept = *(c_pData + sizeof(DWORD));
+
+			CGuild* g = CGuildManager::instance().FindGuild(guild_id);
+
+			if (g)
+			{
+				if (accept)
+					g->InviteAccept(ch);
+				else
+					g->InviteDeny(ch->GetPlayerID());
+			}
+		}
+		return SubPacketLen;
+
+	}
+
+	return 0;
+}
+
+void CInputMain::Fishing(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGFishing* p = (TPacketCGFishing*)c_pData;
+	ch->SetRotation(p->dir * 5);
+	ch->fishing();
+	return;
+}
+
+#if defined(__FISHING_GAME__)
+#include "fishing.h"
+void CInputMain::FishingGame(const LPCHARACTER c_lpChar, const char* c_pszData)
+{
+	const TPacketCGFishingGame* c_pData = reinterpret_cast<const TPacketCGFishingGame*>(c_pszData);
+	if (c_pData == nullptr || c_lpChar == nullptr)
+		return;
+
+	const LPITEM c_lpFishingRod = c_lpChar->GetWear(WEAR_WEAPON);
+	if (c_lpFishingRod && c_lpFishingRod->GetType() == ITEM_ROD)
+	{
+		if (c_lpChar->m_pkFishingEvent)
+		{
+			switch (c_pData->bSubHeader)
+			{
+				case FISHING_GAME_SUBHEADER_GOAL:
+				{
+					c_lpChar->SetFishingGameGoals(c_pData->bGoals);
+					if (c_lpChar->GetFishingGameGoals() >= 3)
+						c_lpChar->fishing();
+				}
+				break;
+
+				case FISHING_GAME_SUBHEADER_QUIT:
+				{
+					event_cancel(&c_lpChar->m_pkFishingEvent);
+					c_lpFishingRod->SetSocket(2, 0);
+					fishing::FishingFail(c_lpChar);
+				}
+				break;
+			};
+		}
+	}
+}
+#endif
+
+void CInputMain::ItemGive(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGGiveItem* p = (TPacketCGGiveItem*)c_pData;
+	LPCHARACTER to_ch = CHARACTER_MANAGER::instance().Find(p->dwTargetVID);
+
+	if (to_ch)
+		ch->GiveItem(to_ch, p->ItemPos);
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 풍  求."));
+}
+
+void CInputMain::Hack(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGHack* p = (TPacketCGHack*)c_pData;
+
+	char buf[sizeof(p->szBuf)];
+	strlcpy(buf, p->szBuf, sizeof(buf));
+
+	sys_err("HACK_DETECT: %s %s", ch->GetName(), buf);
+
+	//  클潔트  킷  李 퓐   磯
+	ch->GetDesc()->SetPhase(PHASE_CLOSE);
+}
+
+#if defined(__MYSHOP_DECO__)
+void CInputMain::MyShopDecoState(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGMyShopDecoState* p = (TPacketCGMyShopDecoState*)c_pData;
+	ch->SetMyShopDecoState(p->bState);
+}
+
+void CInputMain::MyShopDecoAdd(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGMyShopDecoAdd* p = (TPacketCGMyShopDecoAdd*)c_pData;
+	if (ch->GetMyShopDecoState())
+	{
+		if (p->dwPolyVnum < 30000 && p->dwPolyVnum > 30008)
+		{
+			sys_err("MyShopDecoAdd : Unknown PolyVnum");
+			return;
+		}
+
+		ch->SetMyShopDecoType(p->bType);
+		ch->SetMyShopDecoPolyVnum(p->dwPolyVnum);
+
+#if defined(__MYSHOP_EXPANSION__)
+		//ch->OpenPrivateShop(2, true);
+		// NOTE : Ideally, the Kashmir Bundle should have the same benefits as the Silk Bundle.
+		ch->UseSilkBotary();
+#else
+		ch->OpenPrivateShop(1, true);
+#endif
+	}
+	else
+	{
+		sys_err("MyShopDecoAdd : Unknown State");
+		return;
+	}
+}
+#endif
+
+int CInputMain::MyShop(LPCHARACTER ch, const char* c_pData, size_t uiBytes)
+{
+	const TPacketCGMyShop* p = (TPacketCGMyShop*)c_pData;
+	const int iExtraLen = p->bCount * sizeof(TShopItemTable);
+
+	if (uiBytes < sizeof(TPacketCGMyShop) + iExtraLen)
+		return -1;
+
+	if (ch->GetGold() >= GOLD_MAX)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  20 耭 킹 蒡 求."));
+		sys_log(0, "MyShop ==> OverFlow Gold id %u name %s ", ch->GetPlayerID(), ch->GetName());
+		return (iExtraLen);
+	}
+
+#if defined(__CHEQUE_SYSTEM__)
+	if (ch->GetCheque() > CHEQUE_MAX)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  20 耭 킹 蒡 求."));
+		sys_log(0, "MyShop ==> OverFlow Cheque id %u name %s ", ch->GetPlayerID(), ch->GetName());
+		return (iExtraLen);
+	}
+#endif
+
+	if (ch->IsStun() || ch->IsDead())
+		return (iExtraLen);
+
+	if (ch->PreventTradeWindow(WND_MYSHOP, true/*except*/))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 킹構 貫  求."));
+		return (iExtraLen);
+	}
+
+	sys_log(0, "MyShop count %u", p->bCount);
+	char szSign[SHOP_SIGN_MAX_LEN + 1];
+	strlcpy(szSign, p->szSign, sizeof(szSign));
+	for (size_t i = 0; i < sizeof(szSign) && szSign[i]; ++i)
+	{
+		const unsigned char c = static_cast<unsigned char>(szSign[i]);
+		if (c < 0x20 || c == 0x7F)
+			szSign[i] = ' ';
+	}
+
+	ch->OpenMyShop(szSign, (TShopItemTable*)(c_pData + sizeof(TPacketCGMyShop)), p->bCount);
+	return (iExtraLen);
+}
+
+void CInputMain::Refine(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGRefine* p = reinterpret_cast<const TPacketCGRefine*>(c_pData);
+
+	if (ch->PreventTradeWindow(WND_REFINE, true/*except*/))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("창,킹창  쩔  寗 求"));
+		ch->ClearRefineMode();
+		return;
+	}
+
+	if (p->type == 255)
+	{
+		// DoRefine Cancel
+		ch->ClearRefineMode();
+		return;
+	}
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	if (p->pos >= ch->GetExtendInvenMax())
+#else
+	if (p->pos >= INVENTORY_MAX_NUM)
+#endif
+	{
+		ch->ClearRefineMode();
+		return;
+	}
+
+	LPITEM item = ch->GetInventoryItem(p->pos);
+	if (!item)
+	{
+		ch->ClearRefineMode();
+		return;
+	}
+
+	ch->SetRefineTime();
+
+	if (p->type == REFINE_TYPE_NORMAL)
+	{
+		sys_log(0, "refine_type_noraml");
+		ch->DoRefine(item);
+	}
+	else if (p->type == REFINE_TYPE_SCROLL
+		|| p->type == REFINE_TYPE_NOT_USED1
+		|| p->type == REFINE_TYPE_HYUNIRON
+		|| p->type == REFINE_TYPE_MUSIN
+		|| p->type == REFINE_TYPE_BDRAGON
+#if defined(__STONE_OF_BLESS__)
+		|| p->type == REFINE_TYPE_BLESSING_STONE
+#endif
+		)
+	{
+		sys_log(0, "refine_type_scroll, ...");
+		ch->DoRefineWithScroll(item);
+	}
+#if defined(__SOUL_SYSTEM__)
+	else if (p->type == REFINE_TYPE_SOUL_AWAKE || p->type == REFINE_TYPE_SOUL_EVOLVE)
+	{
+		ch->DoRefineSoul(item);
+	}
+#endif
+	else if (p->type == REFINE_TYPE_MONEY_ONLY)
+	{
+		const LPITEM item = ch->GetInventoryItem(p->pos);
+
+		if (NULL != item)
+		{
+			if (500 <= item->GetRefineSet())
+			{
+				LogManager::instance().HackLog("DEVIL_TOWER_REFINE_HACK", ch);
+			}
+			else
+			{
+				if (ch->GetQuestFlag("deviltower_zone.can_refine"))
+				{
+					ch->DoRefine(item, true);
+					ch->SetQuestFlag("deviltower_zone.can_refine", 0);
+				}
+				else
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, " 타 狗  箕 諛≡니.");
+				}
+			}
+		}
+	}
+
+	ch->ClearRefineMode();
+}
+
+#if defined(__CUBE_RENEWAL__)
+void CInputMain::Cube(const LPCHARACTER pChar, const char* pData)
+{
+	const TPacketCGCube* pPacket = reinterpret_cast<const TPacketCGCube*>(pData);
+	if (pPacket == nullptr)
+		return;
+
+	const DWORD dwFileCrc = CCubeManager::Instance().GetFileCrc();
+	if (pPacket->dwFileCrc != dwFileCrc)
+	{
+		const char* szSubHeader[] = {
+			{ "SUBHEADER_CG_CUBE_CLOSE" },
+			{ "SUBHEADER_CG_CUBE_MAKE" },
+		};
+
+		if (test_server)
+			pChar->ChatPacket(CHAT_TYPE_INFO, "cube crc mismatch: %u != %u",
+				pPacket->dwFileCrc, dwFileCrc);
+
+		sys_log(0, "cube: recv %s ch %s file crc mismatch: %u != %u",
+			szSubHeader[pPacket->bSubHeader], pChar->GetName(),
+			pPacket->dwFileCrc, dwFileCrc);
+
+		LogManager::instance().CharLog(pChar, 0, "CUBE FILE MISMATCH", "");
+		CCubeManager::Instance().CloseCube(pChar);
+	}
+
+	if (pChar->PreventTradeWindow(WND_CUBE, true/*except*/))
+	{
+		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("창,킹창  쩔  寗 求"));
+		return;
+	}
+
+	switch (pPacket->bSubHeader)
+	{
+		case SUBHEADER_CG_CUBE_CLOSE:
+			CCubeManager::Instance().CloseCube(pChar);
+			break;
+
+		case SUBHEADER_CG_CUBE_MAKE:
+			CCubeManager::Instance().MakeCube(pChar, pPacket->iCubeIndex, pPacket->iQuantity, pPacket->iImproveItemPos);
+			break;
+	}
+}
+#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+void CInputMain::ItemCombination(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGItemCombination* p = reinterpret_cast<const TPacketCGItemCombination*>(c_pData);
+
+	ch->ItemCombination(p->MediumIndex, p->BaseIndex, p->MaterialIndex);
+}
+
+void CInputMain::ItemCombinationCancel(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGItemCombinationCancel* p = reinterpret_cast<const TPacketCGItemCombinationCancel*>(c_pData);
+
+	ch->SetItemCombNpc(NULL);
+}
+#endif
+
+#if defined(__CHANGED_ATTR__)
+void CInputMain::ItemSelectAttr(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGItemSelectAttr* p = reinterpret_cast<const TPacketCGItemSelectAttr*>(c_pData);
+
+	ch->SelectAttrResult(p->bNew, p->pItemPos);
+}
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+static size_t GetAcceSubPacketLength(const ESubHeaderCGAcceRefine& eSubHeader)
+{
+	switch (eSubHeader)
+	{
+		case ACCE_REFINE_SUBHEADER_CG_CHECKIN:
+			return sizeof(TSubPacketCGAcceRefineCheckIn);
+		case ACCE_REFINE_SUBHEADER_CG_CHECKOUT:
+			return sizeof(TSubPacketCGAcceRefineCheckOut);
+		case ACCE_REFINE_SUBHEADER_CG_ACCEPT:
+			return sizeof(TSubPacketCGAcceRefineAccept);
+		case ACCE_REFINE_SUBHEADER_CG_CANCEL:
+			return 0;
+	}
+	return 0;
+}
+
+int CInputMain::AcceRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes)
+{
+	if (uiBytes < sizeof(TPacketCGAcceRefine))
+		return -1;
+
+	const TPacketCGAcceRefine* pPacket = reinterpret_cast<const TPacketCGAcceRefine*>(pszData);
+	const char* pszDataPacket = pszData + sizeof(TPacketCGAcceRefine);
+
+	uiBytes -= sizeof(TPacketCGAcceRefine);
+
+	const ESubHeaderCGAcceRefine eSubHeader = static_cast<ESubHeaderCGAcceRefine>(pPacket->bSubHeader);
+	const size_t uiSubPacketLength = GetAcceSubPacketLength(eSubHeader);
+	if (uiBytes < uiSubPacketLength)
+	{
+		sys_err("Invalid AcceRefine SubPacket length (SubPacketLength %d Size %u Buffer %u)", uiSubPacketLength, sizeof(TPacketCGAcceRefine), uiBytes);
+		return -1;
+	}
+
+	switch (eSubHeader)
+	{
+		case ACCE_REFINE_SUBHEADER_CG_CHECKIN:
+		{
+			const TSubPacketCGAcceRefineCheckIn* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineCheckIn*>(pszDataPacket);
+			pChar->AcceRefineWindowCheckIn(pSubPacket->bType, pSubPacket->SelectedPos, pSubPacket->AttachedPos);
+		}
+		return uiSubPacketLength;
+
+		case ACCE_REFINE_SUBHEADER_CG_CHECKOUT:
+		{
+			const TSubPacketCGAcceRefineCheckOut* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineCheckOut*>(pszDataPacket);
+			pChar->AcceRefineWindowCheckOut(pSubPacket->bType, pSubPacket->SelectedPos);
+		}
+		return uiSubPacketLength;
+
+		case ACCE_REFINE_SUBHEADER_CG_ACCEPT:
+		{
+			const TSubPacketCGAcceRefineAccept* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineAccept*>(pszDataPacket);
+			pChar->AcceRefineWindowAccept(pSubPacket->bType);
+		}
+		return uiSubPacketLength;
+
+		case ACCE_REFINE_SUBHEADER_CG_CANCEL:
+		{
+			pChar->AcceRefineWindowClose();
+		}
+		return uiSubPacketLength;
+	}
+
+	return 0;
+}
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+static size_t GetAuraSubPacketLength(const ESubHeaderCGAuraRefine& eSubHeader)
+{
+	switch (eSubHeader)
+	{
+		case AURA_REFINE_SUBHEADER_CG_CHECKIN:
+			return sizeof(TSubPacketCGAuraRefineCheckIn);
+		case AURA_REFINE_SUBHEADER_CG_CHECKOUT:
+			return sizeof(TSubPacketCGAuraRefineCheckOut);
+		case AURA_REFINE_SUBHEADER_CG_ACCEPT:
+			return sizeof(TSubPacketCGAuraRefineAccept);
+		case AURA_REFINE_SUBHEADER_CG_CANCEL:
+			return 0;
+	}
+	return 0;
+}
+
+int CInputMain::AuraRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes)
+{
+	if (uiBytes < sizeof(TPacketCGAuraRefine))
+		return -1;
+
+	const TPacketCGAuraRefine* pPacket = reinterpret_cast<const TPacketCGAuraRefine*>(pszData);
+	const char* pszDataPacket = pszData + sizeof(TPacketCGAuraRefine);
+
+	uiBytes -= sizeof(TPacketCGAuraRefine);
+
+	const ESubHeaderCGAuraRefine eSubHeader = static_cast<ESubHeaderCGAuraRefine>(pPacket->bSubHeader);
+	const size_t uiSubPacketLength = GetAuraSubPacketLength(eSubHeader);
+	if (uiBytes < uiSubPacketLength)
+	{
+		sys_err("Invalid AuraRefine SubPacket length (SubPacketLength %d Size %u Buffer %u)", uiSubPacketLength, sizeof(TPacketCGAuraRefine), uiBytes);
+		return -1;
+	}
+
+	switch (eSubHeader)
+	{
+		case AURA_REFINE_SUBHEADER_CG_CHECKIN:
+		{
+			const TSubPacketCGAuraRefineCheckIn* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineCheckIn*>(pszDataPacket);
+			pChar->AuraRefineWindowCheckIn(c_pSubPacket->bType, c_pSubPacket->SelectedPos, c_pSubPacket->AttachedPos);
+		}
+		return uiSubPacketLength;
+
+		case AURA_REFINE_SUBHEADER_CG_CHECKOUT:
+		{
+			const TSubPacketCGAuraRefineCheckOut* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineCheckOut*>(pszDataPacket);
+			pChar->AuraRefineWindowCheckOut(c_pSubPacket->bType, c_pSubPacket->SelectedPos);
+		}
+		return uiSubPacketLength;
+
+		case AURA_REFINE_SUBHEADER_CG_ACCEPT:
+		{
+			const TSubPacketCGAuraRefineAccept* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineAccept*>(pszDataPacket);
+			pChar->AuraRefineWindowAccept(c_pSubPacket->bType);
+		}
+		return uiSubPacketLength;
+
+		case AURA_REFINE_SUBHEADER_CG_CANCEL:
+		{
+			pChar->AuraRefineWindowClose();
+		}
+		return uiSubPacketLength;
+	}
+
+	return 0;
+}
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+void CInputMain::ChangeLook(LPCHARACTER lpCh, const char* c_pszData)
+{
+	const TPacketCGChangeLook* c_pData = reinterpret_cast<const TPacketCGChangeLook*>(c_pszData);
+
+	CChangeLook* pChangeLook = lpCh->GetChangeLook();
+	if (pChangeLook == nullptr)
+		return;
+
+	switch (static_cast<EPacketCGChangeLookSubHeader>(c_pData->bSubHeader))
+	{
+		case EPacketCGChangeLookSubHeader::ITEM_CHECK_IN:
+			pChangeLook->ItemCheckIn(c_pData->ItemPos, c_pData->bSlotIndex);
+			break;
+		case EPacketCGChangeLookSubHeader::ITEM_CHECK_OUT:
+			pChangeLook->ItemCheckOut(c_pData->bSlotIndex);
+			break;
+		case EPacketCGChangeLookSubHeader::FREE_ITEM_CHECK_IN:
+			pChangeLook->FreeItemCheckIn(c_pData->ItemPos);
+			break;
+		case EPacketCGChangeLookSubHeader::FREE_ITEM_CHECK_OUT:
+			pChangeLook->FreeItemCheckOut();
+			break;
+		case EPacketCGChangeLookSubHeader::ACCEPT:
+			pChangeLook->Accept();
+			break;
+		case EPacketCGChangeLookSubHeader::CANCEL:
+			lpCh->SetChangeLook(nullptr);
+			break;
+		default:
+			sys_err("Unknown Subheader ch:%s, %d", lpCh->GetName(), c_pData->bSubHeader);
+			return;
+	}
+}
+#endif
+
+#if defined(__SEND_TARGET_INFO__)
+void CInputMain::TargetInfo(LPCHARACTER pChar, const char* c_pszData)
+{
+	const TPacketCGTargetInfo* c_pData = reinterpret_cast<const TPacketCGTargetInfo*>(c_pszData);
+	const LPCHARACTER pkTarget = CHARACTER_MANAGER::instance().Find(c_pData->dwVID);
+	if (pChar == nullptr || pkTarget == nullptr)
+		return;
+
+	const DWORD dwVID = pkTarget->GetVID();
+	const DWORD dwRaceVnum = pkTarget->GetRaceNum();
+
+	if (pkTarget->IsMonster() || pkTarget->IsStone())
+	{
+		MonsterItemDropMap ItemDropMap; bool bDropMetinStone = false;
+		ITEM_MANAGER::instance().GetMonsterItemDropMap(pkTarget, pChar, ItemDropMap, bDropMetinStone);
+
+		TEMP_BUFFER TempBuffer;
+		for (const MonsterItemDropMap::value_type& it : ItemDropMap)
+		{
+			TPacketGCTargetDropInfo DropInfoPacket;
+			DropInfoPacket.dwVnum = it.first;
+			DropInfoPacket.bCount = it.second;
+			TempBuffer.write(&DropInfoPacket, sizeof(DropInfoPacket));
+		}
+
+		TPacketGCTargetInfo TargetInfoPacket;
+		TargetInfoPacket.bHeader = HEADER_GC_TARGET_INFO;
+		TargetInfoPacket.wSize = sizeof(TargetInfoPacket) + TempBuffer.size();
+		TargetInfoPacket.dwRaceVnum = dwRaceVnum;
+		TargetInfoPacket.dwVID = dwVID;
+		TargetInfoPacket.bDropMetinStone = bDropMetinStone;
+
+		if (TempBuffer.size())
+		{
+			pChar->GetDesc()->BufferedPacket(&TargetInfoPacket, sizeof(TargetInfoPacket));
+			pChar->GetDesc()->Packet(TempBuffer.read_peek(), TempBuffer.size());
+		}
+		else
+			pChar->GetDesc()->Packet(&TargetInfoPacket, sizeof(TargetInfoPacket));
+	}
+
+	pChar->ChatPacket(CHAT_TYPE_COMMAND, "RefreshMonsterDropInfo %d", pkTarget->GetRaceNum());
+}
+#endif
+
+#if defined(__SKILLBOOK_COMB_SYSTEM__)
+bool CInputMain::SkillBookCombination(LPCHARACTER ch, TItemPos(&CombItemGrid)[SKILLBOOK_COMB_SLOT_MAX], BYTE bAction)
+{
+	if (!ch->GetDesc())
+		return false;
+
+	// if (CombItemGrid.empty())
+		// return false;
+
+	if (ch->PreventTradeWindow(WND_ALL))
+		return false;
+
+	if (bAction != 2/*COMBI_START*/)
+		return false;
+
+	std::set <LPITEM> set_items;
+	for (int i = 0; i < SKILLBOOK_COMB_SLOT_MAX; i++)
+	{
+		LPITEM pItem = ch->GetItem(CombItemGrid[i]);
+		if (pItem)
+		{
+			if (pItem->GetType() != ITEM_SKILLBOOK)
+				return false;
+
+			set_items.insert(pItem);
+		}
+	}
+
+	if (set_items.empty())
+		return false;
+
+	if (ch->GetGold() < SKILLBOOK_COMB_COST)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Yang to trade books with me."));
+		return false;
+	}
+
+	for (std::set <LPITEM>::iterator it = set_items.begin(); it != set_items.end(); ++it)
+	{
+		LPITEM pItem = *it;
+		if (pItem)
+		{
+			pItem->SetCount(pItem->GetCount() - 1);
+			//pItem->RemoveFromCharacter();
+			//M2_DESTROY_ITEM(pItem);
+		}
+	}
+
+	DWORD dwBooks[JOB_MAX_NUM][2/*SKILL_GROUPS*/][2] = {
+		{ // 0 - Warrior
+			{50401, 50406}, // Skill Group 1
+			{50416, 50421}, // Skill Group 2
+		},
+		{ // 1 - Ninja
+			{50431, 50436}, // Skill Group 1
+			{50446, 50451}, // Skill Group 2
+		},
+		{ // 2 - Sura
+			{50461, 50466}, // Skill Group 1
+			{50476, 50481}, // Skill Group 2
+		},
+		{ // 3 - Shaman
+			{50491, 50496}, // Skill Group 1
+			{50506, 50511}, // Skill Group 2
+		},
+		{ // 4 - Wolfman
+			{50530, 50535}, // Skill Group 1
+			{0, 0}, // Skill Group 2
+		},
+	};
+
+	ch->PointChange(POINT_GOLD, -SKILLBOOK_COMB_COST);
+
+	if (ch->GetSkillGroup() != 0)
+	{
+		DWORD dwMinRandomBook = dwBooks[ch->GetJob()][ch->GetSkillGroup() - 1][0];
+		DWORD dwMaxRandomBook = dwBooks[ch->GetJob()][ch->GetSkillGroup() - 1][1];
+
+		std::random_device rd;
+		std::mt19937 gen(rd());
+		std::uniform_real_distribution<> dis(dwMinRandomBook, dwMaxRandomBook);
+		DWORD dwRandomBook = dis(gen);
+
+		ch->AutoGiveItem(dwRandomBook, 1);
+	}
+	else
+		ch->AutoGiveItem(ITEM_SKILLBOOK_VNUM, 1);
+
+	return true;
+}
+#endif
+
+#if defined(__MAILBOX__)
+void CInputMain::MailboxWrite(LPCHARACTER ch, const char* c_pData)
+{
+	const auto* p = reinterpret_cast<const TPacketCGMailboxWrite*>(c_pData);
+	if (p == nullptr)
+		return;
+
+	CMailBox* mail = ch->GetMailBox();
+	if (mail == nullptr)
+		return;
+
+	mail->Write(p->szName, p->szTitle, p->szMessage, p->pos, p->iYang, p->iWon);
+}
+
+void CInputMain::MailboxConfirm(LPCHARACTER ch, const char* c_pData)
+{
+	const auto* p = reinterpret_cast<const TPacketCGMailboxWriteConfirm*>(c_pData);
+	if (p == nullptr)
+		return;
+
+	CMailBox* mail = ch->GetMailBox();
+	if (mail == nullptr)
+		return;
+
+	mail->CheckPlayer(p->szName);
+}
+
+void CInputMain::MailboxProcess(LPCHARACTER ch, const char* c_pData)
+{
+	const auto* p = reinterpret_cast<const TPacketMailboxProcess*>(c_pData);
+	if (p == nullptr)
+		return;
+
+	CMailBox* mail = ch->GetMailBox();
+	if (mail == nullptr)
+		return;
+
+	switch (p->bSubHeader)
+	{
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_CLOSE:
+			ch->SetMailBox(nullptr);
+			break;
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_DELETE:
+			mail->DeleteMail(p->bArg1, false);
+			break;
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_DELETE:
+			mail->DeleteAllMails();
+			break;
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_GET_ITEMS:
+			mail->GetItem(p->bArg1, false);
+			break;
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_GET_ITEMS:
+			mail->GetAllItems();
+			break;
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ADD_DATA:
+			mail->AddData(p->bArg1, p->bArg2);
+			break;
+		default:
+			sys_err("CInputMain::MailboxProcess Unknown SubHeader (ch: %s) (%d)", ch->GetName(), p->bSubHeader);
+			break;
+	}
+}
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+void CInputMain::MiniGameRumi(LPCHARACTER pChar, const char* pszData)
+{
+	const TPacketCGMiniGameRumi* pkData = reinterpret_cast<const TPacketCGMiniGameRumi*>(pszData);
+	if (pkData == nullptr)
+		return;
+
+	switch (pkData->bSubHeader)
+	{
+		case RUMI_CG_SUBHEADER_END:
+			CMiniGameRumi::EndGame(pChar);
+			break;
+
+		case RUMI_CG_SUBHEADER_START:
+			CMiniGameRumi::StartGame(pChar);
+			break;
+
+		case RUMI_CG_SUBHEADER_DECK_CARD_CLICK:
+		case RUMI_CG_SUBHEADER_HAND_CARD_CLICK:
+		case RUMI_CG_SUBHEADER_FIELD_CARD_CLICK:
+			CMiniGameRumi::Analyze(pChar, pkData->bSubHeader, pkData->bUseCard, pkData->bIndex);
+			break;
+
+#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
+		case RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG:
+			CMiniGameRumi::RequestQuestFlag(pChar, RUMI_GC_SUBHEADER_SET_QUEST_FLAG);
+			break;
+#endif
+
+		default:
+			sys_err("CInputMain::MiniGameRumi Unknown SubHeader (ch: %s) (%d)", pChar->GetName(), pkData->bSubHeader);
+			break;
+	}
+}
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__)
+void CInputMain::MiniGameYutnori(LPCHARACTER pChar, const char* pszData)
+{
+	const TPacketCGMiniGameYutnori* pkData = reinterpret_cast<const TPacketCGMiniGameYutnori*>(pszData);
+	if (pkData == nullptr)
+	{
+		sys_err("CInputMain::MiniGameYutnori - Null Data! (ch: %s)", pChar->GetName());
+		return;
+	}
+
+	switch (pkData->bSubHeader)
+	{
+		case YUTNORI_CG_SUBHEADER_START:
+			CMiniGameYutnori::Create(pChar);
+			break;
+
+		case YUTNORI_CG_SUBHEADER_GIVEUP:
+			CMiniGameYutnori::Destroy(pChar);
+			break;
+
+#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+		case YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG:
+			CMiniGameYutnori::RequestQuestFlag(pChar, YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG);
+			break;
+#endif
+
+		default:
+			CMiniGameYutnori::Analyze(pChar, pkData->bSubHeader, pkData->bArgument);
+			break;
+	}
+}
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+void CInputMain::LootFilter(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGLootFilter* p = reinterpret_cast<const TPacketCGLootFilter*>(c_pData);
+	if (ch->GetLootFilter())
+		ch->GetLootFilter()->SetLootFilterSettings(p->settings);
+}
+#endif
+
+#if defined(__GEM_SHOP__)
+void CInputMain::GemShop(LPCHARACTER c_lpCh, const char* c_pszData)
+{
+	const TPacketCGGemShop* c_pPacket = reinterpret_cast<const TPacketCGGemShop*>(c_pszData);
+	if (c_pPacket == nullptr)
+		return;
+
+	CGemShop* pGemShop = c_lpCh->GetGemShop();
+	if (pGemShop == nullptr)
+		return;
+
+	switch (c_pPacket->bSubHeader)
+	{
+		case SUBHEADER_GEM_SHOP_CLOSE:
+			c_lpCh->SetGemShop(nullptr);
+			break;
+		case SUBHEADER_GEM_SHOP_BUY:
+			pGemShop->Buy(c_pPacket->bSlotIndex);
+			break;
+		case SUBHEADER_GEM_SHOP_SLOT_ADD:
+			pGemShop->AddSlot();
+			break;
+		case SUBHEADER_GEM_SHOP_REFRESH:
+			pGemShop->Refresh();
+			break;
+		default:
+			sys_err("CInputMain::GemShop Unknown SubHeader (ch: %s) (%d)", c_lpCh->GetName(), c_pPacket->bSubHeader);
+			break;
+	}
+}
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+void CInputMain::Attr67Add(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGAttr67Add* pkPacket = (TPacketCGAttr67Add*)c_pData;
+	switch (pkPacket->bySubHeader)
+	{
+		case SUBHEADER_CG_ATTR67_ADD_CLOSE:
+			ch->SetOpenAttr67Add(false);
+			break;
+		case SUBHEADER_CG_ATTR67_ADD_OPEN:
+			if (!ch->IsOpenAttr67Add())
+				ch->SetOpenAttr67Add(true);
+			break;
+		case SUBHEADER_CG_ATTR67_ADD_REGIST:
+			if (ch->IsOpenAttr67Add())
+				ch->Attr67Add(pkPacket->Attr67AddData);
+			break;
+		default:
+			return;
+	}
+}
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+void CInputMain::ExtendInven(LPCHARACTER pChar, const char* c_pszData)
+{
+	const TPacketCGExtendInven* pPacket = reinterpret_cast<const TPacketCGExtendInven*>(c_pszData);
+	if (pPacket == nullptr)
+		return;
+
+	if (pPacket->bUpgrade)
+		pChar->ExtendInvenUpgrade();
+	else
+		pChar->ExtendInvenRequest();
+}
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+void CInputMain::SnowflakeStickEvent(LPCHARACTER pChar, const char* c_pszData)
+{
+	const TPacketCGSnowflakeStickEvent* pPacket = reinterpret_cast<const TPacketCGSnowflakeStickEvent*>(c_pszData);
+	if (pPacket == nullptr)
+		return;
+
+	switch (pPacket->bSubHeader)
+	{
+		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_REQUEST_INFO:
+			CSnowflakeStickEvent::Process(pChar, SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO);
+			break;
+
+		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_STICK:
+		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_PET:
+		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_MOUNT:
+			CSnowflakeStickEvent::Exchange(pChar, pPacket->bSubHeader);
+			break;
+
+		default:
+			return;
+	}
+}
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+void CInputMain::RefineElement(LPCHARACTER pChar, const char* c_pszData)
+{
+	const TPacketCGRefineElement* pPacket = reinterpret_cast<const TPacketCGRefineElement*>(c_pszData);
+	if (pPacket == nullptr)
+		return;
+
+	switch (pPacket->bSubHeader)
+	{
+		case REFINE_ELEMENT_CG_CLOSE:
+			pChar->SetUnderRefineElement(false);
+			break;
+
+		case REFINE_ELEMENT_CG_REFINE:
+			pChar->RefineElement(pPacket->wChangeElement);
+			break;
+
+		default:
+			sys_err("CInputMain::RefineElement: %s received unknown sub header.", pChar->GetName());
+			break;
+	}
+}
+#endif
+
+#if defined(__LEFT_SEAT__)
+void CInputMain::LeftSeat(LPCHARACTER pChar, const char* c_pszData)
+{
+	const TPacketCGLeftSeat* c_pPacket = reinterpret_cast<const TPacketCGLeftSeat*>(c_pszData);
+	if (c_pPacket == nullptr)
+		return;
+
+	switch (c_pPacket->bSubHeader)
+	{
+		case LEFT_SEAT_SET_WAIT_TIME_INDEX:
+			pChar->SetLeftSeatWaitTime(c_pPacket->bIndex);
+			break;
+
+		case LEFT_SEAT_SET_LOGOUT_TIME_INDEX:
+			pChar->SetLeftSeatLogoutTime(c_pPacket->bIndex);
+			break;
+
+		case LEFT_SEAT_DISABLE_LOGOUT_STATE:
+			pChar->DisableLeftSeatLogOutState(false);
+			break;
+
+		default:
+			sys_err("CInputMain::LeftSeat: %s received unknown sub header.", pChar->GetName());
+			break;
+	}
+}
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+void CInputMain::MiniGameRoulette(LPCHARACTER pChar, const char* pszData)
+{
+	const TPacketCGMiniGameRoulette* pData = reinterpret_cast<const TPacketCGMiniGameRoulette*>(pszData);
+	if (pData == nullptr)
+	{
+		sys_err("CInputMain::MiniGameRoulette : Data NULL (ch: %s)", pChar->GetName());
+		return;
+	}
+
+	CMiniGameRoulette* pMiniGameRoulette = pChar->GetMiniGameRoulette();
+	if (pMiniGameRoulette == nullptr)
+	{
+		sys_err("CInputMain::MiniGameRoulette : MiniGameRoulette NULL (ch: %s)", pChar->GetName());
+		return;
+	}
+
+	switch (pData->bSubHeader)
+	{
+		case ROULETTE_CG_START:
+			pMiniGameRoulette->Start();
+			break;
+
+		case ROULETTE_CG_REQUEST:
+			pMiniGameRoulette->Request();
+			break;
+
+		case ROULETTE_CG_END:
+			pMiniGameRoulette->End();
+			break;
+
+		case ROULETTE_CG_CLOSE:
+			pMiniGameRoulette->Close();
+			break;
+
+		default:
+			sys_err("CInputMain::MiniGameRoulette : Unknown SubHeader %u (ch: %s)",
+				pData->bSubHeader, pChar->GetName());
+			break;
+	}
+}
+#endif
+
+#if defined(__FLOWER_EVENT__)
+void CInputMain::FlowerEvent(LPCHARACTER pChar, const char* pszData)
+{
+	if (!quest::CQuestManager::instance().GetEventFlag("e_flower_drop"))
+		return;
+
+	const TPacketCGFlowerEvent* pPacketData = reinterpret_cast<const TPacketCGFlowerEvent*>(pszData);
+	if (NULL == pPacketData)
+	{
+		sys_err("NULL TPacketCGFlowerEvent (ch: %s)", pChar->GetName());
+		return;
+	}
+
+	switch (pPacketData->bSubHeader)
+	{
+		case FLOWER_EVENT_SUBHEADER_CG_INFO_ALL:
+			CFlowerEvent::RequestAllInfo(pChar);
+			break;
+
+		case FLOWER_EVENT_SUBHEADER_CG_EXCHANGE:
+			CFlowerEvent::Exchange(pChar, pPacketData->bShootType, pPacketData->bExchangeKey);
+			break;
+
+		default:
+			sys_err("Unknown SubHeader %u (ch: %s)",
+				pPacketData->bSubHeader, pChar->GetName());
+			break;
+	}
+}
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+int CInputMain::ReciveExtBattlePassActions(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	TPacketCGExtBattlePassAction* p = (TPacketCGExtBattlePassAction*)data;
+
+	if (uiBytes < sizeof(TPacketCGExtBattlePassAction))
+		return -1;
+
+	const char* c_pData = data + sizeof(TPacketCGExtBattlePassAction);
+	uiBytes -= sizeof(TPacketCGExtBattlePassAction);
+
+	switch (p->bAction)
+	{
+		case 1:
+			CBattlePassManager::instance().BattlePassRequestOpen(ch);
+			return 0;
+
+		case 2:
+			if(get_dword_time() < ch->GetLastReciveExtBattlePassOpenRanking()) {
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NEXT_REFRESH_RANKLIST_TIME"), ((ch->GetLastReciveExtBattlePassOpenRanking() - get_dword_time()) / 1000) + 1 );
+				return 0;
+			}
+			ch->SetLastReciveExtBattlePassOpenRanking(get_dword_time() + 10000);
+			
+			for (BYTE bBattlePassType = 1; bBattlePassType <= 3 ; ++bBattlePassType)
+			{
+				BYTE bBattlePassID;
+				if (bBattlePassType == 1)
+					bBattlePassID = CBattlePassManager::instance().GetNormalBattlePassID();
+				if (bBattlePassType == 2){
+					bBattlePassID = CBattlePassManager::instance().GetPremiumBattlePassID();
+					if (bBattlePassID != ch->GetExtBattlePassPremiumID())
+						continue;
+				}
+				if (bBattlePassType == 3)
+					bBattlePassID = CBattlePassManager::instance().GetEventBattlePassID();
+
+				std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("SELECT player_name, battlepass_type+0, battlepass_id, UNIX_TIMESTAMP(start_time), UNIX_TIMESTAMP(end_time) FROM player.battlepass_playerindex WHERE battlepass_type = %d and battlepass_id = %d and battlepass_completed = 1 and not player_name LIKE '[%%' ORDER BY (UNIX_TIMESTAMP(end_time)-UNIX_TIMESTAMP(start_time)) ASC LIMIT 40", bBattlePassType, bBattlePassID));
+				if (pMsg->uiSQLErrno)
+					return 0;
+
+				MYSQL_ROW row;
+
+				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+				{
+					TPacketGCExtBattlePassRanking pack;
+					pack.bHeader = HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING;
+					strlcpy(pack.szPlayerName, row[0], sizeof(pack.szPlayerName));
+					pack.bBattlePassType = std::atoi(row[1]);
+					pack.bBattlePassID = std::atoll(row[2]);
+					pack.dwStartTime = std::atoll(row[3]);
+					pack.dwEndTime = std::atoll(row[4]);
+
+					ch->GetDesc()->Packet(&pack, sizeof(pack));
+				}
+			}
+			break;
+
+		case 10:
+			CBattlePassManager::instance().BattlePassRequestReward(ch, 1);
+			return 0;
+			
+		case 11:
+			CBattlePassManager::instance().BattlePassRequestReward(ch, 2);
+			return 0;
+			
+		case 12:
+			CBattlePassManager::instance().BattlePassRequestReward(ch, 3);
+			return 0;
+
+
+		default:
+			break;
+	}
+
+	return 0;
+}
+
+int CInputMain::ReciveExtBattlePassPremiumItem(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	TPacketCGExtBattlePassSendPremiumItem* p = (TPacketCGExtBattlePassSendPremiumItem*)data;
+
+	if (uiBytes < sizeof(TPacketCGExtBattlePassSendPremiumItem))
+		return -1;
+
+	const char* c_pData = data + sizeof(TPacketCGExtBattlePassSendPremiumItem);
+	uiBytes -= sizeof(TPacketCGExtBattlePassSendPremiumItem);
+
+	LPITEM item = ch->GetInventoryItem(p->iSlotIndex);
+	if (item != NULL and item->GetVnum() == 93100)
+	{
+		ch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, CBattlePassManager::instance().GetPremiumBattlePassID());
+		CBattlePassManager::instance().BattlePassRequestOpen(ch);
+		item->SetCount(item->GetCount() - 1);
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NOW_IS_ACTIVATED_PREMIUM_BATTLEPASS_OWN"));
+	}
+	return 0;
+}
+#endif
+
+int CInputMain::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
+{
+	LPCHARACTER ch;
+
+	if (!(ch = d->GetCharacter()))
+	{
+		sys_err("no character on desc");
+		d->SetPhase(PHASE_CLOSE);
+		return (0);
+	}
+
+	int iExtraLen = 0;
+
+	if (test_server && bHeader != HEADER_CG_MOVE)
+		sys_log(0, "CInputMain::Analyze() ==> Header [%d] ", bHeader);
+
+#if defined(__LEFT_SEAT__)
+	const std::unordered_set<BYTE> bExcludeLeftSeatHeader = {
+		HEADER_CG_LEFT_SEAT,
+		HEADER_CG_TIME_SYNC,
+		HEADER_CG_PONG,
+	};
+
+	if (bExcludeLeftSeatHeader.find(bHeader) == bExcludeLeftSeatHeader.end())
+	{
+		if (ch->LeftSeat())
+			ch->DisableLeftSeatLogOutState(true);
+
+		ch->SetLastRequestTime(get_dword_time());
+	}
+#endif
+
+	switch (bHeader)
+	{
+		case HEADER_CG_PONG:
+			Pong(d);
+			break;
+
+		case HEADER_CG_TIME_SYNC:
+			Handshake(d, c_pData);
+			break;
+
+		case HEADER_CG_CHAT:
+			if (test_server)
+			{
+				char* pBuf = (char*)c_pData;
+				sys_log(0, "%s", pBuf + sizeof(TPacketCGChat));
+			}
+
+			if ((iExtraLen = Chat(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+
+			break;
+
+		case HEADER_CG_WHISPER:
+			if ((iExtraLen = Whisper(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_MOVE:
+			Move(ch, c_pData);
+			break;
+
+		case HEADER_CG_CHARACTER_POSITION:
+			Position(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_USE:
+			if (!ch->IsObserverMode())
+				ItemUse(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_DROP:
+			if (!ch->IsObserverMode())
+			{
+				ItemDrop(ch, c_pData);
+			}
+			break;
+
+		case HEADER_CG_ITEM_DROP2:
+			if (!ch->IsObserverMode())
+				ItemDrop2(ch, c_pData);
+			break;
+
+#if defined(__NEW_DROP_DIALOG__)
+		case HEADER_CG_ITEM_DESTROY:
+			if (!ch->IsObserverMode())
+				ItemDestroy(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_ITEM_MOVE:
+			if (!ch->IsObserverMode())
+				ItemMove(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_PICKUP:
+			if (!ch->IsObserverMode())
+				ItemPickup(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_USE_TO_ITEM:
+			if (!ch->IsObserverMode())
+				ItemToItem(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_GIVE:
+			if (!ch->IsObserverMode())
+				ItemGive(ch, c_pData);
+			break;
+
+		case HEADER_CG_EXCHANGE:
+			if (!ch->IsObserverMode())
+				Exchange(ch, c_pData);
+			break;
+
+		case HEADER_CG_ATTACK:
+		case HEADER_CG_SHOOT:
+			if (!ch->IsObserverMode())
+			{
+				Attack(ch, bHeader, c_pData);
+			}
+			break;
+
+		case HEADER_CG_USE_SKILL:
+			if (!ch->IsObserverMode())
+				UseSkill(ch, c_pData);
+			break;
+
+#ifdef __OFFLINE_SHOP__
+		case HEADER_CG_OFFLINE_SHOP:
+		{
+			if ((iExtraLen = COfflineShop::ReceivePacket(ch, c_pData, m_iBufferLeft)) < 0) {
+				return -1;
+			}
+
+			break;
+		}
+#endif
+
+#ifdef __SHOP_SEARCH__
+		case HEADER_CG_SHOP_SEARCH_BY_NAME:
+			ShopSearchByName(ch, c_pData);
+			break;
+
+		case HEADER_CG_SHOP_SEARCH_BY_OPTION:
+			if ((iExtraLen = ShopSearchByOptions(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_SHOP_SEARCH_BUY:
+			ShopSearchBuy(ch, c_pData);
+			break;
+
+		case HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE:
+			ShopSearchOwnerMessage(ch, c_pData);
+			break;
+
+		case HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO:
+			ShopSearchRequestSoldInfo(ch, c_pData);
+			break;
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+void CInputMain::PetHatch(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetHatch* p = reinterpret_cast<const TPacketCGPetHatch*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	CGrowthPetManager::Instance().EggHatch(ch, p->name, p->eggPos);
+}
+
+void CInputMain::PetWindow(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetWindow* p = reinterpret_cast<const TPacketCGPetWindow*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	switch (p->window)
+	{
+		case PET_WINDOW_HATCH:
+			ch->SetPetHatchWindow(p->state);
+			break;
+
+		case PET_WINDOW_NAME_CHANGE:
+			ch->SetPetChangeNameWindow(p->state);
+			break;
+	}
+}
+
+void CInputMain::PetWindowType(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetWindowType* p = reinterpret_cast<const TPacketCGPetWindowType*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	BYTE bWindowType = p->type;
+
+	if (bWindowType == ch->GetPetWindowType())
+		return;
+
+	if (bWindowType == PET_WINDOW_ATTR_CHANGE || bWindowType == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+
+		if ((ch->GetExchange() || ch->IsOpenSafebox() || ch->GetShopOwner()) || ch->IsCubeOpen())
+			return;
+	}
+
+	ch->SetPetWindowType(bWindowType);
+
+	TPacketGCPet packet;
+	packet.header = HEADER_GC_PET;
+	packet.subheader = SUBHEADER_PET_WINDOW_TYPE_INFO + bWindowType;
+
+	ch->GetDesc()->Packet(&packet, sizeof(packet));
+}
+
+void CInputMain::PetFeed(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetFeed* p = reinterpret_cast<const TPacketCGPetFeed*>(c_pData);
+	
+	if (!ch || !ch->GetDesc())
+		return;
+
+	if (ch->GetActiveGrowthPet())
+		ch->GetActiveGrowthPet()->Feed(p);
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, "Activate your pet first.");
+}
+
+void CInputMain::PetDetermine(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetDetermine* p = reinterpret_cast<const TPacketCGPetDetermine*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pDetermineItem = ch->GetInventoryItem(p->determinePos.cell);
+	if (!pDetermineItem)
+		return;
+
+	if (pDetermineItem->GetType() != ITEM_PET || pDetermineItem->GetSubType() != PET_ATTR_DETERMINE)
+		return;
+
+	if (!ch->GetActiveGrowthPet())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Activate your pet first.");
+		return;
+	}
+
+	ch->GetActiveGrowthPet()->AttrDetermine(pDetermineItem);
+}
+
+void CInputMain::PetAttrChange(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetAttrChange* p = reinterpret_cast<const TPacketCGPetAttrChange*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
+	if (!pUpBringingItem)
+		return;
+
+	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
+		return;
+
+	LPITEM pChangeAttrItem = ch->GetInventoryItem(p->attrChangePos.cell);
+	if (!pChangeAttrItem)
+		return;
+
+	if (pChangeAttrItem->GetType() != ITEM_PET || pChangeAttrItem->GetSubType() != PET_ATTR_CHANGE)
+		return;
+
+	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
+	if (!pPet)
+		return;
+
+	pPet->AttrChange(pUpBringingItem, pChangeAttrItem);
+}
+
+void CInputMain::PetRevive(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetRevive* p = reinterpret_cast<const TPacketCGPetRevive*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
+	if (!pUpBringingItem)
+		return;
+
+	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
+		return;
+
+	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
+	if (!pPet)
+		return;
+
+	pPet->PremiumFeed(p, pUpBringingItem);
+}
+
+void CInputMain::PetLearnSkill(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetLearnSkill* p = reinterpret_cast<const TPacketCGPetLearnSkill*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pSkillBookItem = ch->GetInventoryItem(p->learnSkillPos.cell);
+	if (!pSkillBookItem)
+		return;
+
+	if (pSkillBookItem->GetType() != ITEM_PET || pSkillBookItem->GetSubType() != PET_SKILL)
+		return;
+
+	if (!ch->GetActiveGrowthPet())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Activate your pet first.");
+		return;
+	}
+
+	ch->GetActiveGrowthPet()->LearnSkill(p->slotIndex, pSkillBookItem);
+}
+
+void CInputMain::PetSkillUpgrade(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetSkillUpgrade* p = reinterpret_cast<const TPacketCGPetSkillUpgrade*>(c_pData);
+
+	if (!ch->GetActiveGrowthPet())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Activate your pet first.");
+		return;
+	}
+
+	ch->GetActiveGrowthPet()->SkillUpgrade(p->slotIndex);
+}
+
+void CInputMain::PetDeleteSkill(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetDeleteSkill* p = reinterpret_cast<const TPacketCGPetDeleteSkill*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pDeleteSkillItem = ch->GetInventoryItem(p->deleteSkillPos.cell);
+	if (!pDeleteSkillItem)
+		return;
+
+	if (pDeleteSkillItem->GetType() != ITEM_PET || pDeleteSkillItem->GetSubType() != PET_SKILL_DEL_BOOK)
+		return;
+
+	if (!ch->GetActiveGrowthPet())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Activate your pet first.");
+		return;
+	}
+
+	ch->GetActiveGrowthPet()->DeleteSkill(p->slotIndex, pDeleteSkillItem);
+}
+
+void CInputMain::PetDeleteAllSkill(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetDeleteAllSkill* p = reinterpret_cast<const TPacketCGPetDeleteAllSkill*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pDeleteAllSkillItem = ch->GetInventoryItem(p->deleteAllSkillPos.cell);
+	if (!pDeleteAllSkillItem)
+		return;
+
+	if (pDeleteAllSkillItem->GetType() != ITEM_PET || pDeleteAllSkillItem->GetSubType() != PET_SKILL_ALL_DEL_BOOK)
+		return;
+
+	if (!ch->GetActiveGrowthPet())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, "Activate your pet first.");
+		return;
+	}
+
+	ch->GetActiveGrowthPet()->DeleteAllSkill(pDeleteAllSkillItem);
+}
+
+void CInputMain::PetNameChange(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetNameChange* p = reinterpret_cast<const TPacketCGPetNameChange*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pNameChangeItem = ch->GetInventoryItem(p->changeNamePos.cell);
+	if (!pNameChangeItem)
+		return;
+
+	if (pNameChangeItem->GetType() != ITEM_PET || pNameChangeItem->GetSubType() != PET_NAME_CHANGE)
+		return;
+
+	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
+	if (!pUpBringingItem)
+		return;
+
+	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
+		return;
+
+	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
+	if (!pPet)
+		return;
+
+	if (pPet->GetOwner() != ch)
+		return;
+
+	pPet->NameChange(p->name, pNameChangeItem, pUpBringingItem);
+}
+#endif
+
+		case HEADER_CG_QUICKSLOT_ADD:
+			QuickslotAdd(ch, c_pData);
+			break;
+
+		case HEADER_CG_QUICKSLOT_DEL:
+			QuickslotDelete(ch, c_pData);
+			break;
+
+		case HEADER_CG_QUICKSLOT_SWAP:
+			QuickslotSwap(ch, c_pData);
+			break;
+
+		case HEADER_CG_SHOP:
+			if ((iExtraLen = Shop(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_MESSENGER:
+			if ((iExtraLen = Messenger(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_ON_CLICK:
+			OnClick(ch, c_pData);
+			break;
+
+		case HEADER_CG_SYNC_POSITION:
+			if ((iExtraLen = SyncPosition(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_ADD_FLY_TARGETING:
+		case HEADER_CG_FLY_TARGETING:
+			FlyTarget(ch, c_pData, bHeader);
+			break;
+
+		case HEADER_CG_SCRIPT_BUTTON:
+			ScriptButton(ch, c_pData);
+			break;
+
+			// SCRIPT_SELECT_ITEM
+		case HEADER_CG_SCRIPT_SELECT_ITEM:
+			ScriptSelectItem(ch, c_pData);
+			break;
+			// END_OF_SCRIPT_SELECT_ITEM
+
+		case HEADER_CG_SCRIPT_ANSWER:
+			ScriptAnswer(ch, c_pData);
+			break;
+
+#if defined(__GEM_SYSTEM__)
+		case HEADER_CG_SELECT_ITEM_EX:
+			SelectItemEx(ch, c_pData);
+			break;
+#endif
+
+#if defined(__QUEST_REQUEST_EVENT__)
+		case HEADER_CG_REQUEST_EVENT_QUEST:
+			RequestEventQuest(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_QUEST_INPUT_STRING:
+			QuestInputString(ch, c_pData);
+			break;
+
+#if defined(__OX_RENEWAL__)
+		case HEADER_CG_QUEST_INPUT_LONG_STRING:
+			QuestInputLongString(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_QUEST_CONFIRM:
+			QuestConfirm(ch, c_pData);
+			break;
+
+		case HEADER_CG_TARGET:
+			Target(ch, c_pData);
+			break;
+
+		case HEADER_CG_WARP:
+			Warp(ch, c_pData);
+			break;
+
+		case HEADER_CG_SAFEBOX_CHECKIN:
+			SafeboxCheckin(ch, c_pData);
+			break;
+
+		case HEADER_CG_SAFEBOX_CHECKOUT:
+			SafeboxCheckout(ch, c_pData, false);
+			break;
+
+		case HEADER_CG_SAFEBOX_ITEM_MOVE:
+			SafeboxItemMove(ch, c_pData);
+			break;
+
+		case HEADER_CG_MALL_CHECKOUT:
+			SafeboxCheckout(ch, c_pData, true);
+			break;
+
+		case HEADER_CG_PARTY_INVITE:
+			PartyInvite(ch, c_pData);
+			break;
+
+		case HEADER_CG_PARTY_REMOVE:
+			PartyRemove(ch, c_pData);
+			break;
+
+		case HEADER_CG_PARTY_INVITE_ANSWER:
+			PartyInviteAnswer(ch, c_pData);
+			break;
+
+		case HEADER_CG_PARTY_SET_STATE:
+			PartySetState(ch, c_pData);
+			break;
+
+		case HEADER_CG_PARTY_USE_SKILL:
+			PartyUseSkill(ch, c_pData);
+			break;
+
+		case HEADER_CG_PARTY_PARAMETER:
+			PartyParameter(ch, c_pData);
+			break;
+
+		case HEADER_CG_ANSWER_MAKE_GUILD:
+			AnswerMakeGuild(ch, c_pData);
+			break;
+
+		case HEADER_CG_GUILD:
+			if ((iExtraLen = Guild(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_FISHING:
+			Fishing(ch, c_pData);
+			break;
+
+#if defined(__FISHING_GAME__)
+		case HEADER_CG_FISHING_GAME:
+			FishingGame(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_HACK:
+			Hack(ch, c_pData);
+			break;
+
+		case HEADER_CG_MYSHOP:
+			if ((iExtraLen = MyShop(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+#if defined(__MYSHOP_DECO__)
+		case HEADER_CG_MYSHOP_DECO_STATE:
+			MyShopDecoState(ch, c_pData);
+			break;
+
+		case HEADER_CG_MYSHOP_DECO_ADD:
+			MyShopDecoAdd(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_REFINE:
+			Refine(ch, c_pData);
+			break;
+
+#if defined(__CUBE_RENEWAL__)
+		case HEADER_CG_CUBE:
+			Cube(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_CLIENT_VERSION:
+			Version(ch, c_pData);
+			break;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case HEADER_CG_DRAGON_SOUL_REFINE:
+		{
+			TPacketCGDragonSoulRefine* p = reinterpret_cast <TPacketCGDragonSoulRefine*>((void*)c_pData);
+			switch (p->bSubType)
+			{
+				case DS_SUB_HEADER_CLOSE:
+					ch->DragonSoul_RefineWindow_Close();
+					break;
+
+				case DS_SUB_HEADER_DO_REFINE_GRADE:
+				{
+					DSManager::instance().DoRefineGrade(ch, p->ItemGrid);
+				}
+				break;
+
+				case DS_SUB_HEADER_DO_REFINE_STEP:
+				{
+					DSManager::instance().DoRefineStep(ch, p->ItemGrid);
+				}
+				break;
+
+				case DS_SUB_HEADER_DO_REFINE_STRENGTH:
+				{
+					DSManager::instance().DoRefineStrength(ch, p->ItemGrid);
+				}
+				break;
+
+#if defined(__DS_CHANGE_ATTR__)
+				case DS_SUB_HEADER_DO_CHANGE_ATTR:
+				{
+					DSManager::instance().DoChangeAttribute(ch, p->ItemGrid);
+				}
+				break;
+#endif
+			}
+		}
+		break;
+#endif
+
+#if defined(__SEND_TARGET_INFO__)
+		case HEADER_CG_TARGET_INFO:
+			TargetInfo(ch, c_pData);
+			break;
+#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+		case HEADER_CG_ITEM_COMBINATION:
+			ItemCombination(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_COMBINATION_CANCEL:
+			ItemCombinationCancel(ch, c_pData);
+			break;
+#endif
+
+#if defined(__CHANGED_ATTR__)
+		case HEADER_CG_ITEM_SELECT_ATTR:
+			ItemSelectAttr(ch, c_pData);
+			break;
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case HEADER_CG_ACCE_REFINE:
+			if ((iExtraLen = AcceRefine(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+		case HEADER_CG_AURA_REFINE:
+			if ((iExtraLen = AuraRefine(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		case HEADER_CG_CHANGE_LOOK:
+			ChangeLook(ch, c_pData);
+			break;
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__)
+		case HEADER_CG_MINI_GAME_CATCH_KING:
+			if ((iExtraLen = CMiniGameCatchKing::Process(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+#endif
+
+#if defined(__SKILLBOOK_COMB_SYSTEM__)
+		case HEADER_CG_SKILLBOOK_COMB:
+		{
+			TPacketCGSkillBookCombination* p = reinterpret_cast <TPacketCGSkillBookCombination*>((void*)c_pData);
+			SkillBookCombination(ch, p->CombItemGrid, p->bAction);
+		}
+		break;
+#endif
+
+#if defined(__MAILBOX__)
+		case HEADER_CG_MAILBOX_WRITE:
+			MailboxWrite(ch, c_pData);
+			break;
+
+		case HEADER_CG_MAILBOX_WRITE_CONFIRM:
+			MailboxConfirm(ch, c_pData);
+			break;
+
+		case HEADER_CG_MAILBOX_PROCESS:
+			MailboxProcess(ch, c_pData);
+			break;
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+		case HEADER_CG_LOOT_FILTER:
+			LootFilter(ch, c_pData);
+			break;
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+		case HEADER_CG_MINI_GAME_RUMI:
+			MiniGameRumi(ch, c_pData);
+			break;
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__)
+		case HEADER_CG_MINI_GAME_YUTNORI:
+			MiniGameYutnori(ch, c_pData);
+			break;
+#endif
+
+#if defined(__LUCKY_BOX__)
+		case HEADER_CG_LUCKY_BOX:
+			LuckyBox(ch, c_pData);
+			break;
+#endif
+
+#if defined(__GEM_SHOP__)
+		case HEADER_CG_GEM_SHOP:
+			GemShop(ch, c_pData);
+			break;
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		case HEADER_CG_EXTEND_INVEN:
+			ExtendInven(ch, c_pData);
+			break;
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+		case HEADER_CG_ATTR67_ADD:
+			Attr67Add(ch, c_pData);
+			break;
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+		case HEADER_CG_SNOWFLAKE_STICK_EVENT:
+			SnowflakeStickEvent(ch, c_pData);
+			break;
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		case HEADER_CG_REFINE_ELEMENT:
+			RefineElement(ch, c_pData);
+			break;
+#endif
+
+#if defined(__LEFT_SEAT__)
+		case HEADER_CG_LEFT_SEAT:
+			LeftSeat(ch, c_pData);
+			break;
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+		case HEADER_CG_MINI_GAME_ROULETTE:
+			MiniGameRoulette(ch, c_pData);
+			break;
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+		case HEADER_CG_FLOWER_EVENT:
+			FlowerEvent(ch, c_pData);
+			break;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		case HEADER_CG_EXT_BATTLE_PASS_ACTION:
+			if ((iExtraLen = ReciveExtBattlePassActions(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+			
+		case HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM:
+			if ((iExtraLen = ReciveExtBattlePassPremiumItem(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+#endif
+	}
+
+	return (iExtraLen);
+}
+
+#if defined(__LUCKY_BOX__)
+void CInputMain::LuckyBox(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGLuckyBox* c_pPacket = reinterpret_cast<const TPacketCGLuckyBox*>(c_pData);
+
+	switch (c_pPacket->bAction)
+	{
+		case ELUCKY_BOX_ACTION::LUCKY_BOX_ACTION_RETRY:
+			ch->LuckyBoxRetry();
+			break;
+		case ELUCKY_BOX_ACTION::LUCKY_BOX_ACTION_RECEIVE:
+			ch->LuckyBoxReceive();
+			break;
+		default:
+			sys_err("CInputMain::LuckyBox : Unknown action %d : %s", c_pPacket->bAction, ch->GetName());
+			return;
+	}
+}
+#endif
+
+#ifdef __SHOP_SEARCH__
+void CInputMain::ShopSearchByName(LPCHARACTER ch, const char* data)
+{
+	if (!ch || !ch->GetDesc())
+		return;
+
+	if (!ch->CheckShopSearchFlood())
+		return;
+
+	TPacketCGShopSearchByName* p = (TPacketCGShopSearchByName*)data;
+
+	const size_t nameLen = strnlen(p->itemName, sizeof(p->itemName));
+	if (nameLen == 0 || nameLen >= sizeof(p->itemName))
+		return;
+
+	// Prevent extremely expensive broad searches (e.g. "a")
+	if (nameLen < 2)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Search term is too short."));
+		return;
+	}
+
+	CShopSearchManager::PC_RequestSearch(ch, p->itemName, p->page, p->entryCountIdx, p->sortType);
+}
+
+int CInputMain::ShopSearchByOptions(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	if (!ch || !ch->GetDesc())
+		return -1;
+
+	if (!ch->CheckShopSearchFlood())
+		return -1;
+
+	TPacketCGShopSearchByOptions* p = (TPacketCGShopSearchByOptions*)data;
+	// Hard upper bounds to avoid pathological packets.
+	if (p->options.typeFlagCount > 32 || p->options.specificVnumCount > 32)
+		return -1;
+	data += sizeof(TPacketCGShopSearchByOptions);
+	uiBytes -= sizeof(TPacketCGShopSearchByOptions);
+
+	if (uiBytes < sizeof(TShopSearchItemType) * p->options.typeFlagCount)
+		return -1;
+
+	TShopSearchItemType* itemTypeFlags = (TShopSearchItemType*)data;
+	data += sizeof(TShopSearchItemType) * p->options.typeFlagCount;
+	uiBytes -= sizeof(TShopSearchItemType) * p->options.typeFlagCount;
+
+	if (uiBytes < sizeof(DWORD) * p->options.specificVnumCount)
+		return -1;
+
+	CShopSearchManager::PC_RequestSearch(ch, &p->options, itemTypeFlags, (const DWORD*)data, p->page, p->entryCountIdx, p->sortType);
+
+	return sizeof(TShopSearchItemType) * p->options.typeFlagCount + sizeof(DWORD) * p->options.specificVnumCount;
+}
+
+void CInputMain::ShopSearchBuy(LPCHARACTER ch, const char* data)
+{
+	if (!ch || !ch->GetDesc())
+		return;
+
+	// Buying can also be spammed; keep it under control.
+	if (!ch->CheckShopSearchFlood())
+		return;
+
+	TPacketCGShopSearchBuy* p = (TPacketCGShopSearchBuy*)data;
+
+	CShopSearchManager::PC_RequestBuy(ch, p->itemID, p->itemVnum, p->itemPrice);
+}
+
+void CInputMain::ShopSearchOwnerMessage(LPCHARACTER ch, const char* data)
+{
+	if (!ch || !ch->GetDesc())
+		return;
+
+	if (!ch->CheckShopSearchFlood())
+		return;
+
+	TPacketCGShopSearchOwnerMessage* p = (TPacketCGShopSearchOwnerMessage*)data;
+
+	TPacketGCShopSearchOwnerMessage pack;
+	pack.header = HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE;
+	memset(pack.ownerName, 0, sizeof(pack.ownerName));
+
+	if (LPCHARACTER tch = CHARACTER_MANAGER::instance().FindByPID(p->ownerID))
+		strlcpy(pack.ownerName, tch->GetName(), sizeof(pack.ownerName));
+	else if (CCI* pkCCI = P2P_MANAGER::instance().FindByPID(p->ownerID))
+		strlcpy(pack.ownerName, pkCCI->szName, sizeof(pack.ownerName));
+	else
+	{
+		std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("SELECT name FROM player WHERE id = %u", p->ownerID));
+		if (MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult))
+		{
+			strlcpy(pack.ownerName, row[0], sizeof(pack.ownerName));
+		}
+	}
+
+	ch->GetDesc()->Packet(&pack, sizeof(pack));
+}
+
+void CInputMain::ShopSearchRequestSoldInfo(LPCHARACTER ch, const char* data)
+{
+	if (!ch || !ch->GetDesc())
+		return;
+
+	if (!ch->CheckShopSearchFlood())
+		return;
+
+	TPacketCGShopSearchRequestSoldInfo* p = (TPacketCGShopSearchRequestSoldInfo*)data;
+
+	CShopSearchManager::PC_RequestSoldInfo(ch, p->itemVnum);
+}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	case HEADER_CG_PET_HATCH:
+		PetHatch(ch, c_pData);
+		break;
+
+	case HEADER_CG_PET_WINDOW:
+		PetWindow(ch, c_pData);
+		break;
+
+	case HEADER_CG_PET_WINDOW_TYPE:
+		PetWindowType(ch, c_pData);
+		break;
+
+	case HEADER_CG_PET_NAME_CHANGE:
+		PetNameChange(ch, c_pData);
+		break;
+
+	case HEADER_CG_PET_FEED:
+		PetFeed(ch, c_pData);
+		break;
+
+	case HEADER_CG_PET_DETERMINE:
+		PetDetermine(ch, c_pData);
+		break;
+
+	case HEADER_CG_PET_ATTR_CHANGE:
+		PetAttrChange(ch, c_pData);
+		break;
+
+	case HEADER_CG_PET_REVIVE:
+		PetRevive(ch, c_pData);
+		break;
+
+	case HEADER_CG_PET_LEARN_SKILL:
+		PetLearnSkill(ch, c_pData);
+		break;
+
+	case HEADER_CG_PET_SKILL_UPGRADE:
+		PetSkillUpgrade(ch, c_pData);
+		break;
+
+	case HEADER_CG_PET_DELETE_SKILL:
+		PetDeleteSkill(ch, c_pData);
+		break;
+
+	case HEADER_CG_PET_DELETE_ALL_SKILL:
+		PetDeleteAllSkill(ch, c_pData);
+		break;
+#endif
+
+int CInputDead::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
+{
+	LPCHARACTER ch;
+
+	if (!(ch = d->GetCharacter()))
+	{
+		sys_err("no character on desc");
+		return 0;
+	}
+
+	int iExtraLen = 0;
+
+	switch (bHeader)
+	{
+		case HEADER_CG_PONG:
+			Pong(d);
+			break;
+
+		case HEADER_CG_TIME_SYNC:
+			Handshake(d, c_pData);
+			break;
+
+		case HEADER_CG_CHAT:
+			if ((iExtraLen = Chat(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+
+			break;
+
+		case HEADER_CG_WHISPER:
+			if ((iExtraLen = Whisper(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+
+			break;
+
+		case HEADER_CG_HACK:
+			Hack(ch, c_pData);
+			break;
+
+		default:
+			return (0);
+	}
+
+	return (iExtraLen);
+}
diff --git a/server/server/home/metin2/Source/Server/game/src/item.cpp b/server/server/home/metin2/Source/Server/game/src/item.cpp
index e3052dc..7948e45 100644
--- a/server/server/home/metin2/Source/Server/game/src/item.cpp
+++ b/server/server/home/metin2/Source/Server/game/src/item.cpp
@@ -1,3008 +1,3008 @@
-#include "stdafx.h"
-#include "utils.h"
-#include "config.h"
-#include "char.h"
-#include "desc.h"
-#include "sectree_manager.h"
-#include "packet.h"
-#include "protocol.h"
-#include "log.h"
-#include "skill.h"
-#include "unique_item.h"
-#include "profiler.h"
-#include "marriage.h"
-#include "item_addon.h"
-#include "dev_log.h"
-#include "locale_service.h"
-#include "item.h"
-#include "item_manager.h"
-#include "affect.h"
-#include "DragonSoul.h"
-#include "buff_on_attributes.h"
-#include "belt_inventory_helper.h"
-#include "../../common/VnumHelper.h"
-#include "mob_manager.h"
-#include "PetSystem.h"
-
-CItem::CItem(DWORD dwVnum)
-	: m_dwVnum(dwVnum), m_bWindow(0), m_dwID(0), m_bEquipped(false), m_dwVID(0), m_wCell(0), m_dwCount(0), m_lFlag(0), m_dwLastOwnerPID(0),
-	m_bExchanging(false), m_pkDestroyEvent(NULL), m_pkUniqueExpireEvent(NULL), m_pkTimerBasedOnWearExpireEvent(NULL), m_pkRealTimeExpireEvent(NULL),
-	m_pkExpireEvent(NULL),
-	m_pkAccessorySocketExpireEvent(NULL), m_pkOwnershipEvent(NULL), m_dwOwnershipPID(0), m_bSkipSave(false), m_isLocked(false),
-	m_dwMaskVnum(0), m_dwSIGVnum(0)
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	, m_dwTransmutationVnum(0)
-#endif
-#if defined(__SET_ITEM__)
-	, m_bSetValue(0)
-#endif
-#if defined(__SOUL_BIND_SYSTEM__)
-	, m_lSealDate(E_SEAL_DATE_DEFAULT_TIMESTAMP)
-	, m_pkSealDateExpireEvent(NULL)
-#endif
-#if defined(__SOUL_SYSTEM__)
-	, m_pkSoulTimerUseEvent(nullptr)
-#endif
-{
-	memset(&m_alSockets, 0, sizeof(m_alSockets));
-	memset(&m_aAttr, 0, sizeof(m_aAttr));
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	memset(&m_RefineElement, 0, sizeof(m_RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	memset(&m_aApplyRandom, 0, sizeof(m_aApplyRandom));
-#endif
-}
-
-CItem::~CItem()
-{
-	Destroy();
-}
-
-void CItem::Initialize()
-{
-	CEntity::Initialize(ENTITY_ITEM);
-
-	m_bWindow = RESERVED_WINDOW;
-	m_pOwner = NULL;
-	m_bEquipped = false;
-	m_dwID = m_dwVID = m_dwCount = 0;
-	m_wCell = 0;
-	m_lFlag = 0;
-	m_pProto = NULL;
-	m_bExchanging = false;
-	memset(&m_alSockets, 0, sizeof(m_alSockets));
-	memset(&m_aAttr, 0, sizeof(m_aAttr));
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	memset(&m_RefineElement, 0, sizeof(m_RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	memset(&m_aApplyRandom, 0, sizeof(m_aApplyRandom));
-#endif
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	m_lSealDate = 0;
-	m_pkSealDateExpireEvent = NULL;
-#endif
-
-	m_pkDestroyEvent = NULL;
-	m_pkOwnershipEvent = NULL;
-	m_dwOwnershipPID = 0;
-	m_pkUniqueExpireEvent = NULL;
-	m_pkTimerBasedOnWearExpireEvent = NULL;
-	m_pkRealTimeExpireEvent = NULL;
-
-	m_pkAccessorySocketExpireEvent = NULL;
-#if defined(__SOUL_SYSTEM__)
-	m_pkSoulTimerUseEvent = NULL;
-#endif
-
-	m_bSkipSave = false;
-	m_dwLastOwnerPID = 0;
-}
-
-void CItem::Destroy()
-{
-	event_cancel(&m_pkDestroyEvent);
-	event_cancel(&m_pkOwnershipEvent);
-	event_cancel(&m_pkUniqueExpireEvent);
-	event_cancel(&m_pkTimerBasedOnWearExpireEvent);
-	event_cancel(&m_pkRealTimeExpireEvent);
-	event_cancel(&m_pkAccessorySocketExpireEvent);
-#if defined(__SOUL_BIND_SYSTEM__)
-	event_cancel(&m_pkSealDateExpireEvent);
-#endif
-#if defined(__SOUL_SYSTEM__)
-	event_cancel(&m_pkSoulTimerUseEvent);
-#endif
-
-	CEntity::Destroy();
-
-	if (GetSectree())
-		GetSectree()->RemoveEntity(this);
-}
-
-EVENTFUNC(item_destroy_event)
-{
-	item_event_info* info = dynamic_cast<item_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("item_destroy_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPITEM pkItem = info->item;
-
-	if (pkItem->GetOwner())
-		sys_err("item_destroy_event: Owner exist. (item %s owner %s)", pkItem->GetName(), pkItem->GetOwner()->GetName());
-
-	pkItem->SetDestroyEvent(NULL);
-	M2_DESTROY_ITEM(pkItem);
-	return 0;
-}
-
-void CItem::SetDestroyEvent(LPEVENT pkEvent)
-{
-	m_pkDestroyEvent = pkEvent;
-}
-
-void CItem::StartDestroyEvent(int iSec)
-{
-	if (m_pkDestroyEvent)
-		return;
-
-	item_event_info* info = AllocEventInfo<item_event_info>();
-	info->item = this;
-
-	SetDestroyEvent(event_create(item_destroy_event, info, PASSES_PER_SEC(iSec)));
-}
-
-void CItem::EncodeInsertPacket(LPENTITY ent)
-{
-	LPDESC d;
-
-	if (!(d = ent->GetDesc()))
-		return;
-
-	const PIXEL_POSITION& c_pos = GetXYZ();
-
-	struct packet_item_ground_add pack;
-
-	pack.bHeader = HEADER_GC_ITEM_GROUND_ADD;
-	pack.lX = c_pos.x;
-	pack.lY = c_pos.y;
-	pack.lZ = c_pos.z;
-	pack.dwVID = m_dwVID;
-	pack.dwVnum = GetVnum();
-#if defined(__SET_ITEM__)
-	pack.bSetValue = GetItemSetValue();
-#endif
-
-#if defined(__ITEM_DROP_RENEWAL__)
-	for (size_t i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-		pack.alSockets[i] = GetSocket(i);
-
-	thecore_memcpy(pack.aAttrs, GetAttributes(), sizeof(pack.aAttrs));
-#endif
-
-	d->Packet(&pack, sizeof(pack));
-
-	if (m_pkOwnershipEvent != NULL)
-	{
-		item_event_info* info = dynamic_cast<item_event_info*>(m_pkOwnershipEvent->info);
-
-		if (info == NULL)
-		{
-			sys_err("CItem::EncodeInsertPacket> <Factor> Null pointer");
-			return;
-		}
-
-		TPacketGCItemOwnership p;
-
-		p.bHeader = HEADER_GC_ITEM_OWNERSHIP;
-		p.dwVID = m_dwVID;
-		strlcpy(p.szName, info->szOwnerName, sizeof(p.szName));
-
-		d->Packet(&p, sizeof(TPacketGCItemOwnership));
-	}
-}
-
-void CItem::EncodeRemovePacket(LPENTITY ent)
-{
-	LPDESC d;
-
-	if (!(d = ent->GetDesc()))
-		return;
-
-	struct packet_item_ground_del pack;
-
-	pack.bHeader = HEADER_GC_ITEM_GROUND_DEL;
-	pack.dwVID = m_dwVID;
-
-	d->Packet(&pack, sizeof(pack));
-	sys_log(2, "Item::EncodeRemovePacket %s to %s", GetName(), ((LPCHARACTER)ent)->GetName());
-}
-
-void CItem::SetProto(const TItemTable* table)
-{
-	assert(table != NULL);
-	m_pProto = table;
-	SetFlag(m_pProto->dwFlags);
-}
-
-void CItem::UsePacketEncode(LPCHARACTER ch, LPCHARACTER victim, struct packet_item_use* packet)
-{
-	if (!GetVnum())
-		return;
-
-	packet->header = HEADER_GC_ITEM_USE;
-	packet->ch_vid = ch->GetVID();
-	packet->victim_vid = victim->GetVID();
-	packet->Cell = TItemPos(GetWindow(), m_wCell);
-	packet->vnum = GetVnum();
-}
-
-void CItem::RemoveFlag(long bit)
-{
-	REMOVE_BIT(m_lFlag, bit);
-}
-
-void CItem::AddFlag(long bit)
-{
-	SET_BIT(m_lFlag, bit);
-}
-
-void CItem::UpdatePacket()
-{
-	if (!m_pOwner || !m_pOwner->GetDesc())
-		return;
-
-	TPacketGCItemUpdate pack;
-
-	pack.bHeader = HEADER_GC_ITEM_UPDATE;
-	pack.Cell = TItemPos(GetWindow(), m_wCell);
-	pack.dwCount = m_dwCount;
-#if defined(__SOUL_BIND_SYSTEM__)
-	pack.lSealDate = m_lSealDate;
-#endif
-	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-		pack.alSockets[i] = m_alSockets[i];
-	thecore_memcpy(pack.aAttr, GetAttributes(), sizeof(pack.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	pack.dwTransmutationVnum = GetTransmutationVnum();
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	thecore_memcpy(&pack.RefineElement, GetRefineElement(), sizeof(pack.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	thecore_memcpy(pack.aApplyRandom, GetRandomApplies(), sizeof(pack.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-	pack.bSetValue = GetItemSetValue();
-#endif
-
-	sys_log(2, "UpdatePacket %s -> %s", GetName(), m_pOwner->GetName());
-	m_pOwner->GetDesc()->Packet(&pack, sizeof(pack));
-}
-
-DWORD CItem::GetCount()
-{
-	if (GetType() == ITEM_ELK)
-		return MIN(m_dwCount, LONG_MAX);
-	else
-		return MIN(m_dwCount, ITEM_MAX_COUNT);
-}
-
-bool CItem::SetCount(DWORD count)
-{
-	if (GetType() == ITEM_ELK)
-	{
-		m_dwCount = MIN(count, LONG_MAX);
-	}
-	else
-	{
-		m_dwCount = MIN(count, ITEM_MAX_COUNT);
-	}
-
-	if (count == 0 && m_pOwner)
-	{
-		if (GetSubType() == USE_ABILITY_UP || GetSubType() == USE_POTION)
-		{
-			LPCHARACTER pOwner = GetOwner();
-			BYTE bWindow = GetWindow();
-			WORD wCell = GetCell();
-
-			RemoveFromCharacter();
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			if (!IsDragonSoul())
-#endif
-			{
-				LPITEM pItem = pOwner->FindSpecifyItem(GetVnum());
-
-				if (NULL != pItem)
-				{
-					if (bWindow == INVENTORY)
-						pOwner->ChainQuickslotItem(pItem, SLOT_TYPE_INVENTORY, wCell);
-					else if (bWindow == BELT_INVENTORY)
-						pOwner->SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, wCell, WORD_MAX);
-				}
-				else
-				{
-					if (bWindow == INVENTORY)
-						pOwner->SyncQuickslot(SLOT_TYPE_INVENTORY, wCell, WORD_MAX);
-					else if (bWindow == BELT_INVENTORY)
-						pOwner->SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, wCell, WORD_MAX);
-				}
-			}
-
-			M2_DESTROY_ITEM(this);
-		}
-		else
-		{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			if (!IsDragonSoul())
-				m_pOwner->SyncQuickslot(SLOT_TYPE_INVENTORY, m_wCell, WORD_MAX);
-#else
-			m_pOwner->SyncQuickslot(SLOT_TYPE_INVENTORY, m_wCell, WORD_MAX);
-#endif
-			M2_DESTROY_ITEM(RemoveFromCharacter());
-		}
-
-		return false;
-	}
-
-	UpdatePacket();
-
-	Save();
-	return true;
-}
-
-#if defined(__SOUL_BIND_SYSTEM__)
-bool CItem::CanSealItem() const
-{
-	switch (GetType())
-	{
-		case ITEM_WEAPON:
-		{
-			switch (GetSubType())
-			{
-				case WEAPON_ARROW:
-				case WEAPON_MOUNT_SPEAR:
-#if defined(__QUIVER_SYSTEM__)
-				case WEAPON_QUIVER:
-#endif
-					//case WEAPON_BOUQUET:
-					return false;
-				default:
-					return true;
-			}
-		}
-
-		case ITEM_COSTUME:
-		{
-			switch (GetSubType())
-			{
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-				case COSTUME_MOUNT:
-#endif
-					return false;
-				default:
-					return true;
-			}
-		}
-
-		case ITEM_ARMOR:
-		case ITEM_BELT:
-			return true;
-
-#if defined(__DRAGON_SOUL_SYSTEM__) && defined(__DRAGON_SOUL_SEAL__)
-		case ITEM_DS:
-		{
-			const BYTE bGradeIdx = (GetVnum() / 1000) % 10;
-			if (bGradeIdx >= DRAGON_SOUL_GRADE_ANCIENT)
-				return true;
-
-			return false;
-		}
-#endif
-
-		default:
-			return false;
-	}
-
-	return false;
-}
-
-EVENTFUNC(SealDateExpireEvent)
-{
-	const item_vid_event_info* info = reinterpret_cast<const item_vid_event_info*>(event->info);
-	if (!info)
-		return 0;
-
-	const LPITEM item = ITEM_MANAGER::instance().FindByVID(info->item_vid);
-	if (!item)
-		return 0;
-
-	const time_t cur = get_global_time();
-	if (cur > item->GetSealDate())
-	{
-		item->SealItem(E_SEAL_DATE_DEFAULT_TIMESTAMP);
-		item->StopSealDateExpireTimerEvent();
-		return 0;
-	}
-
-	return PASSES_PER_SEC(1);
-}
-
-void CItem::SealItem(long lSealDate)
-{
-	m_lSealDate = lSealDate;
-	UpdatePacket();
-	Save();
-}
-
-void CItem::StartSealDateExpireTimerEvent()
-{
-	if (m_pkSealDateExpireEvent)
-		return;
-
-	item_vid_event_info* info = AllocEventInfo<item_vid_event_info>();
-	info->item_vid = GetVID();
-
-	m_pkSealDateExpireEvent = event_create(SealDateExpireEvent, info, PASSES_PER_SEC(1));
-	sys_log(0, "SEAL_DATE_TIME_EXPIRE: StartSealDateExpireTimerEvent");
-}
-
-void CItem::StopSealDateExpireTimerEvent()
-{
-	if (m_pkSealDateExpireEvent)
-		event_cancel(&m_pkSealDateExpireEvent);
-
-	sys_log(0, "SEAL_DATE_TIME_EXPIRE: StopSealDateExpireTimerEvent");
-}
-#endif
-
-LPITEM CItem::RemoveFromCharacter()
-{
-	if (!m_pOwner)
-	{
-		sys_err("Item::RemoveFromCharacter owner null");
-		return this;
-	}
-
-	LPCHARACTER pOwner = m_pOwner;
-	if (!pOwner)
-	{
-		sys_err("Item::RemoveFromCharacter owner null");
-		return this;
-	}
-
-	if (m_bEquipped) // 장착되었는가?
-	{
-		Unequip();
-		//pOwner->UpdatePacket();
-
-		SetWindow(RESERVED_WINDOW);
-		Save();
-		return this;
-	}
-	else
-	{
-		if (GetWindow() != SAFEBOX && GetWindow() != MALL
-#if defined(__ATTR_6TH_7TH__)
-			&& GetWindow() != NPC_STORAGE
-#endif
-			)
-		{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			if (IsDragonSoul())
-			{
-				if (m_wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-					sys_err("CItem::RemoveFromCharacter: pos >= DRAGON_SOUL_INVENTORY_MAX_NUM");
-				else
-					pOwner->SetItem(TItemPos(m_bWindow, m_wCell), NULL);
-			}
-			else if (GetWindow() == EQUIPMENT)
-#else
-			if (GetWindow() == EQUIPMENT)
-#endif
-			{
-				if (m_wCell >= EQUIPMENT_MAX_NUM)
-					sys_err("CItem::RemoveFromCharacter: pos >= EQUIPMENT_MAX_NUM");
-				else
-					pOwner->SetItem(TItemPos(m_bWindow, m_wCell), nullptr);
-			}
-			else if (GetWindow() == BELT_INVENTORY)
-			{
-				if (m_wCell >= BELT_INVENTORY_MAX_NUM)
-					sys_err("CItem::RemoveFromCharacter: pos >= BELT_INVENTORY_MAX_NUM");
-				else
-					pOwner->SetItem(TItemPos(m_bWindow, m_wCell), nullptr);
-			}
-			else
-			{
-				const TItemPos cell(INVENTORY, m_wCell);
-
-				if (cell.IsInventoryPosition() == false && cell.IsBeltInventoryPosition() == false) // 아니면 소지품에?
-				{
-					sys_err("CItem::RemoveFromCharacter: Invalid Item Position");
-				}
-				else
-				{
-					pOwner->SetItem(cell, nullptr);
-				}
-			}
-		}
-
-#if defined(__ATTR_6TH_7TH__)
-		else if (GetWindow() == NPC_STORAGE)
-			pOwner->SetItem(TItemPos(NPC_STORAGE, 0), nullptr);
-#endif
-
-		m_pOwner = nullptr;
-		m_wCell = 0;
-
-		SetWindow(RESERVED_WINDOW);
-		Save();
-		return this;
-	}
-}
-
-bool CItem::AddToCharacter(LPCHARACTER ch, const TItemPos& Cell
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-	, bool isHighLight
-#endif
-)
-{
-	assert(GetSectree() == NULL);
-	assert(m_pOwner == NULL);
-
-	BYTE bWindowType = Cell.window_type;
-	WORD wCell = Cell.cell;
-
-	switch (bWindowType)
-	{
-		case INVENTORY:
-		{
-#if defined(__EXTEND_INVEN_SYSTEM__)
-			if (m_wCell >= ch->GetExtendInvenMax())
-#else
-			if (m_wCell >= INVENTORY_MAX_NUM)
-#endif
-			{
-				sys_err("CItem::AddToCharacter: cell overflow: %s to %s cell %d", m_pProto->szName, ch->GetName(), m_wCell);
-				return false;
-			}
-		}
-		break;
-
-		case EQUIPMENT:
-		{
-			if (m_wCell >= EQUIPMENT_MAX_NUM)
-			{
-				sys_err("CItem::AddToCharacter: cell overflow: %s to %s cell %d", m_pProto->szName, ch->GetName(), m_wCell);
-				return false;
-			}
-		}
-		break;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case DRAGON_SOUL_INVENTORY:
-		{
-			if (m_wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-			{
-				sys_err("CItem::AddToCharacter: cell overflow: %s to %s cell %d", m_pProto->szName, ch->GetName(), m_wCell);
-				return false;
-			}
-		}
-		break;
-#endif
-
-		case BELT_INVENTORY:
-		{
-			if (m_wCell >= BELT_INVENTORY_SLOT_COUNT)
-			{
-				sys_err("CItem::AddToCharacter: cell overflow: %s to %s cell %d", m_pProto->szName, ch->GetName(), m_wCell);
-				return false;
-			}
-		}
-		break;
-	}
-
-	if (ch->GetDesc())
-		m_dwLastOwnerPID = ch->GetPlayerID();
-
-	event_cancel(&m_pkDestroyEvent);
-
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-	ch->SetItem(TItemPos(bWindowType, wCell), this, isHighLight);
-#else
-	ch->SetItem(TItemPos(bWindowType, wCell), this);
-#endif
-	m_pOwner = ch;
-
-	Save();
-	return true;
-}
-
-LPITEM CItem::RemoveFromGround()
-{
-	if (GetSectree())
-	{
-		SetOwnership(NULL);
-
-		GetSectree()->RemoveEntity(this);
-
-		ViewCleanup();
-
-		Save();
-	}
-
-	return (this);
-}
-
-bool CItem::AddToGround(long lMapIndex, const PIXEL_POSITION& pos, bool skipOwnerCheck)
-{
-	if (0 == lMapIndex)
-	{
-		sys_err("wrong map index argument: %d", lMapIndex);
-		return false;
-	}
-
-	if (GetSectree())
-	{
-		sys_err("sectree already assigned");
-		return false;
-	}
-
-	if (!skipOwnerCheck && m_pOwner)
-	{
-		sys_err("owner pointer not null");
-		return false;
-	}
-
-	LPSECTREE tree = SECTREE_MANAGER::instance().Get(lMapIndex, pos.x, pos.y);
-
-	if (!tree)
-	{
-		sys_err("cannot find sectree by %dx%d", pos.x, pos.y);
-		return false;
-	}
-
-	//tree->Touch();
-
-	SetWindow(GROUND);
-	SetXYZ(pos.x, pos.y, pos.z);
-	tree->InsertEntity(this);
-	UpdateSectree();
-	Save();
-	return true;
-}
-
-bool CItem::DistanceValid(LPCHARACTER ch)
-{
-	if (!GetSectree())
-		return false;
-
-	int iDist = DISTANCE_APPROX(GetX() - ch->GetX(), GetY() - ch->GetY());
-
-	if (iDist > 300)
-		return false;
-
-	return true;
-}
-
-bool CItem::CanUsedBy(LPCHARACTER ch)
-{
-	// Anti flag check
-	switch (ch->GetJob())
-	{
-		case JOB_WARRIOR:
-			if (GetAntiFlag() & ITEM_ANTIFLAG_WARRIOR)
-				return false;
-			break;
-
-		case JOB_ASSASSIN:
-			if (GetAntiFlag() & ITEM_ANTIFLAG_ASSASSIN)
-				return false;
-			break;
-
-		case JOB_SHAMAN:
-			if (GetAntiFlag() & ITEM_ANTIFLAG_SHAMAN)
-				return false;
-			break;
-
-		case JOB_SURA:
-			if (GetAntiFlag() & ITEM_ANTIFLAG_SURA)
-				return false;
-			break;
-
-		case JOB_WOLFMAN:
-			if (GetAntiFlag() & ITEM_ANTIFLAG_WOLFMAN)
-				return false;
-			break;
-
-	}
-
-	return true;
-}
-
-int CItem::FindEquipCell(LPCHARACTER ch, int iCandidateCell)
-{
-	// 코스츔 아이템(ITEM_COSTUME)은 WearFlag 없어도 됨. (sub type으로 착용위치 구분. 귀찮게 또 wear flag 줄 필요가 있나..)
-	// 용혼석(ITEM_DS, ITEM_SPECIAL_DS)도 SUB_TYPE으로 구분. 신규 반지, 벨트는 ITEM_TYPE으로 구분 -_-
-	if ((0 == GetWearFlag() || ITEM_TOTEM == GetType()) && ITEM_COSTUME != GetType()
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		&& ITEM_DS != GetType() && ITEM_SPECIAL_DS != GetType()
-#endif
-		&& ITEM_RING != GetType() && ITEM_BELT != GetType()
-		)
-		return -1;
-
-	// 용혼석 슬롯을 WEAR로 처리할 수가 없어서(WEAR는 최대 32개까지 가능한데 용혼석을 추가하면 32가 넘는다.)
-	// 인벤토리의 특정 위치((INVENTORY_MAX_NUM + WEAR_MAX_NUM)부터 (INVENTORY_MAX_NUM + WEAR_MAX_NUM + DRAGON_SOUL_DECK_MAX_NUM * DS_SLOT_MAX - 1)까지)를
-	// 용혼석 슬롯으로 정함.
-	// return 할 때에, INVENTORY_MAX_NUM을 뺀 이유는,
-	// 본래 WearCell이 INVENTORY_MAX_NUM를 빼고 return 하기 때문.
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (GetType() == ITEM_DS || GetType() == ITEM_SPECIAL_DS)
-	{
-		if (iCandidateCell < 0)
-		{
-			return WEAR_MAX_NUM + GetSubType();
-		}
-
-		for (int i = 0; i < DRAGON_SOUL_DECK_MAX_NUM; i++)
-		{
-			if (WEAR_MAX_NUM + i * DS_SLOT_MAX + GetSubType() == iCandidateCell)
-			{
-				return iCandidateCell;
-			}
-		}
-		return -1;
-	}
-#endif
-
-	if (GetType() == ITEM_COSTUME)
-	{
-		switch (GetSubType())
-		{
-			case COSTUME_BODY:
-				return WEAR_COSTUME_BODY;
-			case COSTUME_HAIR:
-				return WEAR_COSTUME_HAIR;
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-			case COSTUME_MOUNT:
-				return WEAR_COSTUME_MOUNT;
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-			case COSTUME_ACCE:
-				return WEAR_COSTUME_ACCE;
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-			case COSTUME_WEAPON:
-				return WEAR_COSTUME_WEAPON;
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-			case COSTUME_AURA:
-				return WEAR_COSTUME_AURA;
-#endif
-		}
-	}
-
-	else if (GetWearFlag() & WEARABLE_BODY)
-		return WEAR_BODY;
-	else if (GetWearFlag() & WEARABLE_HEAD)
-		return WEAR_HEAD;
-	else if (GetWearFlag() & WEARABLE_FOOTS)
-		return WEAR_FOOTS;
-	else if (GetWearFlag() & WEARABLE_WRIST)
-		return WEAR_WRIST;
-	else if (GetWearFlag() & WEARABLE_WEAPON)
-		return WEAR_WEAPON;
-	else if (GetWearFlag() & WEARABLE_NECK)
-		return WEAR_NECK;
-	else if (GetWearFlag() & WEARABLE_EAR)
-		return WEAR_EAR;
-	else if (GetWearFlag() & WEARABLE_UNIQUE)
-	{
-		if (ch->GetWear(WEAR_UNIQUE1))
-			return WEAR_UNIQUE2;
-		else
-			return WEAR_UNIQUE1;
-	}
-	else if (GetWearFlag() & WEARABLE_SHIELD)
-		return WEAR_SHIELD;
-	else if (GetWearFlag() & WEARABLE_ARROW)
-		return WEAR_ARROW;
-	else if (GetType() == ITEM_BELT)
-		return WEAR_BELT;
-#if defined(__PENDANT_SYSTEM__)
-	else if (GetWearFlag() & WEARABLE_PENDANT)
-		return WEAR_PENDANT;
-#endif
-#if defined(__GLOVE_SYSTEM__)
-	else if (GetWearFlag() & WEARABLE_GLOVE)
-		return WEAR_GLOVE;
-#endif
-
-	return -1;
-}
-
-//#define __CHECK_MODIFY_POINTS_PERF__
-
-void CItem::ModifyPoints(bool bAdd)
-{
-#if defined(__CHECK_MODIFY_POINTS_PERF__)
-	auto _modify_s1 = std::chrono::steady_clock::now();
-#endif
-
-	BYTE bAccessoryGrade = 0;
-
-	// 무기와 갑옷만 소켓을 적용시킨다.
-	if (!IsAccessoryForSocket())
-	{
-#if defined(__QUIVER_SYSTEM__)
-		if ((m_pProto->bType == ITEM_WEAPON && m_pProto->bSubType != WEAPON_QUIVER) || m_pProto->bType == ITEM_ARMOR)
-#else
-		if (m_pProto->bType == ITEM_WEAPON || m_pProto->bType == ITEM_ARMOR)
-#endif
-		{
-#if defined(__CHECK_MODIFY_POINTS_PERF__)
-			auto _accessory_s1 = std::chrono::steady_clock::now();
-#endif
-			// 소켓이 속성강화에 사용되는 경우 적용하지 않는다 (ARMOR_WRIST ARMOR_NECK ARMOR_EAR ARMOR_GLOVE)
-			for (BYTE bSocketIndex = 0; bSocketIndex < METIN_SOCKET_MAX_NUM; ++bSocketIndex)
-			{
-#if defined(__GLOVE_SYSTEM__)
-				if (m_pProto->bType == ITEM_ARMOR && m_pProto->bSubType == ARMOR_GLOVE)
-				{
-					const DWORD dwData = GetSocket(bSocketIndex);
-					if (dwData < 1000000)
-						continue;
-
-					const WORD wType = (dwData / 10000) % 1000;
-					if (wType == APPLY_NONE)
-						continue;
-
-					const long lValue = dwData % 100;
-					m_pOwner->ApplyPoint(wType, (bAdd) ? lValue : -lValue);
-				}
-				else
-#endif
-				{
-					const DWORD dwVnum = GetSocket(bSocketIndex);
-					if (dwVnum <= 2)
-						continue;
-
-					const TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwVnum);
-					if (pItemTable == nullptr)
-					{
-						sys_err("cannot find table by vnum %lu", dwVnum);
-						continue;
-					}
-
-					if (ITEM_METIN == pItemTable->bType
-#if defined(__GLOVE_SYSTEM__)
-						&& pItemTable->bSubType != METIN_SUNGMA
-#endif
-						)
-					{
-						for (BYTE bApplyIndex = 0; bApplyIndex < ITEM_APPLY_MAX_NUM; ++bApplyIndex)
-						{
-							if (pItemTable->aApplies[bApplyIndex].wType == APPLY_NONE)
-								continue;
-
-							if (pItemTable->aApplies[bApplyIndex].wType == APPLY_SKILL)
-								m_pOwner->ApplyPoint(pItemTable->aApplies[bApplyIndex].wType,
-									(bAdd) ? pItemTable->aApplies[bApplyIndex].lValue : pItemTable->aApplies[bApplyIndex].lValue ^ 0x00800000);
-							else
-								m_pOwner->ApplyPoint(pItemTable->aApplies[bApplyIndex].wType,
-									(bAdd) ? pItemTable->aApplies[bApplyIndex].lValue : -pItemTable->aApplies[bApplyIndex].lValue);
-						}
-					}
-				}
-			}
-#if defined(__CHECK_MODIFY_POINTS_PERF__)
-			auto _accessory_e1 = std::chrono::steady_clock::now();
-			auto _accessory_d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(_accessory_e1 - _accessory_s1).count();
-			m_pOwner->ChatPacket(CHAT_TYPE_INFO, "!IsAccessoryForSocket() took %lld nanoseconds.", static_cast<long long>(_accessory_d1));
-#endif
-		}
-
-		bAccessoryGrade = 0;
-	}
-	else
-	{
-		bAccessoryGrade = static_cast<BYTE>(MIN(GetAccessorySocketGrade(), ITEM_ACCESSORY_SOCKET_MAX_NUM));
-	}
-
-#if defined(__CHECK_MODIFY_POINTS_PERF__)
-	auto _apply_s1 = std::chrono::steady_clock::now();
-#endif
-	for (BYTE bApplyIndex = 0; bApplyIndex < ITEM_APPLY_MAX_NUM; ++bApplyIndex)
-	{
-		if (m_pProto->aApplies[bApplyIndex].wType == APPLY_NONE)
-			continue;
-
-		long lValue = m_pProto->aApplies[bApplyIndex].lValue;
-		if (m_pProto->aApplies[bApplyIndex].wType == APPLY_SKILL)
-		{
-			m_pOwner->ApplyPoint(m_pProto->aApplies[bApplyIndex].wType, bAdd ? lValue : lValue ^ 0x00800000);
-		}
-#if defined(__ITEM_APPLY_RANDOM__)
-		else if (m_pProto->aApplies[bApplyIndex].wType == APPLY_RANDOM && GetRandomApplyType(bApplyIndex))
-		{
-			const TPlayerItemAttribute& rItemApplyRandom = GetRandomApply(bApplyIndex);
-			lValue = rItemApplyRandom.lValue;
-
-			if (rItemApplyRandom.wType == APPLY_SKILL)
-			{
-				m_pOwner->ApplyPoint(rItemApplyRandom.wType, bAdd ? lValue : lValue ^ 0x00800000);
-			}
-			else
-			{
-				if (0 != bAccessoryGrade)
-					lValue += MAX(bAccessoryGrade, lValue * aiAccessorySocketEffectivePct[bAccessoryGrade] / 100);
-
-				m_pOwner->ApplyPoint(rItemApplyRandom.wType, bAdd ? lValue : -lValue);
-			}
-		}
-#endif
-		else
-		{
-			if (0 != bAccessoryGrade)
-				lValue += MAX(bAccessoryGrade, lValue * aiAccessorySocketEffectivePct[bAccessoryGrade] / 100);
-
-			m_pOwner->ApplyPoint(m_pProto->aApplies[bApplyIndex].wType, bAdd ? lValue : -lValue);
-		}
-	}
-
-#if defined(__CHECK_MODIFY_POINTS_PERF__)
-	auto _apply_e1 = std::chrono::steady_clock::now();
-	auto _apply_d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(_apply_e1 - _apply_s1).count();
-	m_pOwner->ChatPacket(CHAT_TYPE_INFO, "Item applies took %lld nanoseconds.", static_cast<long long>(_apply_d1));
-#endif
-
-#if defined(__CHECK_MODIFY_POINTS_PERF__)
-	auto _acce_s1 = std::chrono::steady_clock::now();
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	if (m_pProto->bType == ITEM_COSTUME && m_pProto->bSubType == COSTUME_ACCE)
-		m_pOwner->ModifyAccePoints(this, bAdd);
-#endif
-#if defined(__CHECK_MODIFY_POINTS_PERF__)
-	auto _acce_e1 = std::chrono::steady_clock::now();
-	auto _acce_d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(_acce_e1 - _acce_s1).count();
-	m_pOwner->ChatPacket(CHAT_TYPE_INFO, "ModifyAccePoints %lld nanoseconds.", static_cast<long long>(_acce_d1));
-#endif
-
-#if defined(__CHECK_MODIFY_POINTS_PERF__)
-	auto _aura_s1 = std::chrono::steady_clock::now();
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	if (m_pProto->bType == ITEM_COSTUME && m_pProto->bSubType == COSTUME_AURA)
-		m_pOwner->ModifyAuraPoints(this, bAdd);
-#endif
-#if defined(__CHECK_MODIFY_POINTS_PERF__)
-	auto _aura_e1 = std::chrono::steady_clock::now();
-	auto _aura_d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(_aura_e1 - _aura_s1).count();
-	m_pOwner->ChatPacket(CHAT_TYPE_INFO, "ModifyAuraPoints %lld nanoseconds.", static_cast<long long>(_aura_d1));
-#endif
-
-	// 초승달의 반지, 할로윈 사탕, 행복의 반지, 영원한 사랑의 펜던트의 경우
-	// 기존의 하드 코딩으로 강제로 속성을 부여했지만,
-	// 그 부분을 제거하고 special item group 테이블에서 속성을 부여하도록 변경하였다.
-	// 하지만 하드 코딩되어있을 때 생성된 아이템이 남아있을 수도 있어서 특수처리 해놓는다.
-	// 이 아이템들의 경우, 밑에 ITEM_UNIQUE일 때의 처리로 속성이 부여되기 때문에,
-	// 아이템에 박혀있는 attribute는 적용하지 않고 넘어간다.
-	//if (true == CItemVnumHelper::IsRamadanMoonRing(GetVnum()) || true == CItemVnumHelper::IsHalloweenCandy(GetVnum())
-		//|| true == CItemVnumHelper::IsHappinessRing(GetVnum()) || true == CItemVnumHelper::IsLovePendant(GetVnum()))
-	if (CItemVnumHelper::IsUniqueItem(GetVnum()))
-	{
-		// Do not anything.
-	}
-	else
-	{
-#if defined(__CHECK_MODIFY_POINTS_PERF__)
-		auto _attr_s1 = std::chrono::steady_clock::now();
-#endif
-		for (BYTE bAttrIndex = 0; bAttrIndex < ITEM_ATTRIBUTE_MAX_NUM; ++bAttrIndex)
-		{
-#if defined(__ACCE_COSTUME_SYSTEM__)
-			if (GetType() == ITEM_COSTUME && GetSubType() == COSTUME_ACCE)
-				break; // Modifying at @ ModifyAccePoints
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-			if (GetType() == ITEM_COSTUME && GetSubType() == COSTUME_AURA)
-				break; // Modifying at @ ModifyAuraPoints
-#endif
-
-			if (GetAttributeType(bAttrIndex))
-			{
-				const TPlayerItemAttribute& rItemAttribute = GetAttribute(bAttrIndex);
-#if defined(__DRAGON_SOUL_SYSTEM__) && defined(__DS_SET__)
-				long lValue = rItemAttribute.lValue;
-				if (IsDragonSoul() && m_pOwner->FindAffect(AFFECT_DS_SET))
-				{
-					if (bAttrIndex < DSManager::instance().GetApplyCount(GetVnum()))
-					{
-						lValue += DSManager::instance().GetBasicApplyValue(GetVnum(), rItemAttribute.wType, true);
-					}
-					else
-					{
-						lValue += DSManager::instance().GetAdditionalApplyValue(GetVnum(), rItemAttribute.wType, true);
-					}
-				}
-
-				if (rItemAttribute.wType == APPLY_SKILL)
-					m_pOwner->ApplyPoint(rItemAttribute.wType, bAdd ? lValue : lValue ^ 0x00800000);
-				else
-					m_pOwner->ApplyPoint(rItemAttribute.wType, bAdd ? lValue : -lValue);
-#else
-				if (rItemAttribute.wType == APPLY_SKILL)
-					m_pOwner->ApplyPoint(rItemAttribute.wType, bAdd ? rItemAttribute.lValue : rItemAttribute.lValue ^ 0x00800000);
-				else
-					m_pOwner->ApplyPoint(rItemAttribute.wType, bAdd ? rItemAttribute.lValue : -rItemAttribute.lValue);
-#endif
-			}
-		}
-#if defined(__CHECK_MODIFY_POINTS_PERF__)
-		auto _attr_e1 = std::chrono::steady_clock::now();
-		auto _attr_d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(_attr_e1 - _attr_s1).count();
-		m_pOwner->ChatPacket(CHAT_TYPE_INFO, "Item attributes took % lld nanoseconds.", static_cast<long long>(_attr_d1));
-#endif
-	}
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	if (m_pProto->bType == ITEM_WEAPON && GetRefineElementGrade() != 0)
-	{
-		const long lValue = static_cast<long>(GetRefineElementValue());
-		if (lValue > 0)
-			m_pOwner->ApplyPoint(GetRefineElementApplyType(), bAdd ? lValue : -lValue);
-
-		const long lBonusValue = static_cast<long>(GetRefineElementBonusValue());
-		if (lBonusValue > 0)
-			m_pOwner->ApplyPoint(APPLY_ATT_GRADE_BONUS, bAdd ? lBonusValue : -lBonusValue);
-	}
-#endif
-
-	switch (m_pProto->bType)
-	{
-		case ITEM_PICK:
-		case ITEM_ROD:
-		{
-			if (bAdd)
-			{
-				if (m_wCell == WEAR_WEAPON)
-					m_pOwner->SetPart(PART_WEAPON, GetVnum());
-			}
-			else
-			{
-				if (m_wCell == WEAR_WEAPON)
-					m_pOwner->SetPart(PART_WEAPON, m_pOwner->GetOriginalPart(PART_WEAPON));
-			}
-		}
-		break;
-
-		case ITEM_WEAPON:
-		{
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-			// 코스츔 body를 입고있다면 armor는 벗던 입던 상관 없이 비주얼에 영향을 주면 안 됨.
-			if (m_pOwner->GetWear(WEAR_COSTUME_WEAPON) != 0)
-			{
-#if defined(__HIDE_WEAPON_COSTUME_WITH_NO_MAIN_WEAPON__)
-				m_pOwner->SetPart(PART_WEAPON, m_pOwner->GetWear(WEAR_COSTUME_WEAPON)->GetVnum());
-#endif
-				return;
-			}
-#endif
-
-			if (bAdd)
-			{
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				if (m_wCell == WEAR_WEAPON)
-					m_pOwner->SetPart(PART_WEAPON, (GetTransmutationVnum() != 0) ? GetTransmutationVnum() : GetVnum());
-#else
-				if (m_wCell == WEAR_WEAPON)
-					m_pOwner->SetPart(PART_WEAPON, GetVnum());
-#endif
-			}
-			else
-			{
-				if (m_wCell == WEAR_WEAPON)
-					m_pOwner->SetPart(PART_WEAPON, m_pOwner->GetOriginalPart(PART_WEAPON));
-			}
-		}
-		break;
-
-		case ITEM_ARMOR:
-		{
-#if defined(__COSTUME_SYSTEM__)
-			// 코스츔 body를 입고있다면 armor는 벗던 입던 상관 없이 비주얼에 영향을 주면 안 됨.
-			if (m_pOwner->GetWear(WEAR_COSTUME_BODY) != 0)
-				break;
-#endif
-
-			if (GetSubType() == ARMOR_BODY || GetSubType() == ARMOR_HEAD || GetSubType() == ARMOR_FOOTS || GetSubType() == ARMOR_SHIELD)
-			{
-				if (bAdd)
-				{
-#if defined(__CHANGE_LOOK_SYSTEM__)
-					if (GetProto()->bSubType == ARMOR_BODY)
-						m_pOwner->SetPart(PART_MAIN, (GetTransmutationVnum() != 0) ? GetTransmutationVnum() : GetVnum());
-#else
-					if (GetProto()->bSubType == ARMOR_BODY)
-						m_pOwner->SetPart(PART_MAIN, GetVnum());
-#endif
-				}
-				else
-				{
-					if (GetProto()->bSubType == ARMOR_BODY)
-						m_pOwner->SetPart(PART_MAIN, m_pOwner->GetOriginalPart(PART_MAIN));
-				}
-			}
-		}
-		break;
-
-#if defined(__COSTUME_SYSTEM__)
-		// 코스츔 아이템 입었을 때 캐릭터 parts 정보 세팅. 기존 스타일대로 추가함..
-		case ITEM_COSTUME:
-		{
-			DWORD dwToSetValue = GetVnum();
-			BYTE bSetPart = PART_MAX_NUM;
-
-			switch (GetSubType())
-			{
-				// 갑옷 코스츔
-				case COSTUME_BODY:
-				{
-					bSetPart = PART_MAIN;
-
-					if (!bAdd)
-					{
-						// 코스츔 갑옷을 벗었을 때 원래 갑옷을 입고 있었다면 그 갑옷으로 look 세팅, 입지 않았다면 default look
-						const CItem* pArmor = m_pOwner->GetWear(WEAR_BODY);
-#if defined(__CHANGE_LOOK_SYSTEM__)
-						if (pArmor)
-							dwToSetValue = (pArmor->GetTransmutationVnum() != 0) ? pArmor->GetTransmutationVnum() : pArmor->GetVnum();
-						else
-							dwToSetValue = m_pOwner->GetOriginalPart(PART_MAIN);
-#else
-						dwToSetValue = (pArmor != nullptr) ? pArmor->GetVnum() : m_pOwner->GetOriginalPart(PART_MAIN);
-#endif
-					}
-#if defined(__CHANGE_LOOK_SYSTEM__)
-					else
-						dwToSetValue = (GetTransmutationVnum() != 0) ? GetTransmutationVnum() : GetVnum();
-#endif
-				}
-				break;
-
-				// 헤어 코스츔
-				case COSTUME_HAIR:
-				{
-					bSetPart = PART_HAIR;
-
-					// 코스츔 헤어는 shape값을 item proto의 value3에 세팅하도록 함. 특별한 이유는 없고 기존 갑옷(ARMOR_BODY)의 shape값이 프로토의 value3에 있어서 헤어도 같이 value3으로 함.
-					// [NOTE] 갑옷은 아이템 vnum을 보내고 헤어는 shape(value3)값을 보내는 이유는.. 기존 시스템이 그렇게 되어있음...
-#if defined(__CHANGE_LOOK_SYSTEM__)
-					const DWORD dwTransmutationVnum = GetTransmutationVnum();
-					if (dwTransmutationVnum != 0)
-					{
-						const TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwTransmutationVnum);
-						dwToSetValue = (pItemTable != nullptr) ? pItemTable->alValues[3] : GetValue(3);
-					}
-					else
-						dwToSetValue = (bAdd) ? GetValue(3) : 0;
-#else
-					dwToSetValue = (bAdd) ? GetValue(3) : 0;
-#endif
-				}
-				break;
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-				case COSTUME_ACCE:
-				{
-					bSetPart = PART_ACCE;
-					dwToSetValue = (bAdd) ? dwToSetValue : 0;
-				}
-				break;
-#endif
-
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-				case COSTUME_WEAPON:
-				{
-					bSetPart = PART_WEAPON;
-
-					if (!bAdd)
-					{
-						// 코스츔 갑옷을 벗었을 때 원래 갑옷을 입고 있었다면 그 갑옷으로 look 세팅, 입지 않았다면 default look
-						const CItem* pWeapon = m_pOwner->GetWear(WEAR_WEAPON);
-#if defined(__CHANGE_LOOK_SYSTEM__)
-						if (pWeapon)
-							dwToSetValue = (pWeapon->GetTransmutationVnum() != 0) ? pWeapon->GetTransmutationVnum() : pWeapon->GetVnum();
-						else
-							dwToSetValue = 0;
-#else
-						dwToSetValue = (pWeapon != nullptr) ? pWeapon->GetVnum() : m_pOwner->GetOriginalPart(PART_WEAPON);
-#endif
-					}
-#if defined(__CHANGE_LOOK_SYSTEM__)
-					else
-						dwToSetValue = (GetTransmutationVnum() != 0) ? GetTransmutationVnum() : GetVnum();
-#endif
-				}
-				break;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-				case COSTUME_AURA:
-				{
-					bSetPart = PART_AURA;
-					dwToSetValue = (bAdd) ? dwToSetValue : 0;
-				}
-				break;
-#endif
-			}
-
-			if (PART_MAX_NUM != bSetPart)
-			{
-				m_pOwner->SetPart(bSetPart, dwToSetValue);
-				m_pOwner->UpdatePacket();
-			}
-		}
-		break;
-#endif
-
-		case ITEM_UNIQUE:
-		{
-			sys_log(0, "ITEM_UNIQUE Process");
-			if (GetSIGVnum() != 0)
-			{
-				sys_log(0, "ITEM_UNIQUE Contains SIGVnum %u", GetSIGVnum());
-
-				const CSpecialItemGroup* pItemGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(GetSIGVnum());
-				if (pItemGroup == nullptr)
-				{
-					sys_log(0, "ITEM_UNIQUE No pointer for item group?");
-					break;
-				}
-
-				const DWORD dwAttrVnum = pItemGroup->GetAttrVnum(GetVnum());
-				const CSpecialAttrGroup* pAttrGroup = ITEM_MANAGER::instance().GetSpecialAttrGroup(dwAttrVnum);
-				if (pAttrGroup == nullptr)
-				{
-					sys_log(0, "ITEM_UNIQUE No pointer for attr group?");
-					break;
-				}
-
-				for (const CSpecialAttrInfo& it : pAttrGroup->m_vecAttrs)
-					m_pOwner->ApplyPoint(it.apply_type, bAdd ? it.apply_value : -it.apply_value);
-			}
-		}
-		break;
-	}
-
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-	if (m_pOwner->GetWear(WEAR_COSTUME_WEAPON) && !m_pOwner->GetWear(WEAR_WEAPON))
-		m_pOwner->SetPart(PART_WEAPON, 0);
-#endif
-}
-
-bool CItem::IsEquipable() const
-{
-	switch (this->GetType())
-	{
-		case ITEM_COSTUME:
-		case ITEM_ARMOR:
-		case ITEM_WEAPON:
-		case ITEM_ROD:
-		case ITEM_PICK:
-		case ITEM_UNIQUE:
-		case ITEM_DS:
-		case ITEM_SPECIAL_DS:
-		case ITEM_RING:
-		case ITEM_BELT:
-			return true;
-	}
-
-	return false;
-}
-
-// return false on error state
-bool CItem::EquipTo(LPCHARACTER ch, BYTE bWearCell)
-{
-	if (!ch)
-	{
-		sys_err("EquipTo: null character");
-		return false;
-	}
-
-	// 용혼석 슬롯 index는 WEAR_MAX_NUM 보다 큼.
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (IsDragonSoul())
-	{
-		if (bWearCell < WEAR_MAX_NUM || bWearCell >= WEAR_MAX_NUM + DRAGON_SOUL_DECK_MAX_NUM * DS_SLOT_MAX)
-		{
-			sys_err("EquipTo: invalid dragon soul cell (this: #%d %s wearflag: %d cell: %d)", GetOriginalVnum(), GetName(), GetSubType(), bWearCell - WEAR_MAX_NUM);
-			return false;
-		}
-	}
-	else
-#endif
-	{
-		if (bWearCell >= WEAR_MAX_NUM)
-		{
-			sys_err("EquipTo: invalid wear cell (this: #%d %s wearflag: %d cell: %d)", GetOriginalVnum(), GetName(), GetWearFlag(), bWearCell);
-			return false;
-		}
-	}
-
-	if (ch->GetWear(bWearCell))
-	{
-		sys_err("EquipTo: item already exist (this: #%d %s cell: %d %s)", GetOriginalVnum(), GetName(), bWearCell, ch->GetWear(bWearCell)->GetName());
-		return false;
-	}
-
-	if (GetOwner())
-		RemoveFromCharacter();
-
-	ch->SetWear(bWearCell, this); // 여기서 패킷 나감
-
-	m_pOwner = ch;
-	m_bEquipped = true;
-	m_wCell = bWearCell;
-
-	DWORD dwImmuneFlag = 0;
-
-	for (int i = 0; i < WEAR_MAX_NUM; ++i)
-	{
-		if (m_pOwner->GetWear(i))
-		{
-			SET_BIT(dwImmuneFlag, m_pOwner->GetWear(i)->GetRealImmuneFlag());
-		}
-	}
-
-	m_pOwner->SetImmuneFlag(dwImmuneFlag);
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (IsDragonSoul())
-	{
-		DSManager::instance().ActivateDragonSoul(this);
-#if defined(__DS_SET__)
-		m_pOwner->DragonSoul_SetBonus();
-#endif
-	}
-	else
-#endif
-	{
-		ModifyPoints(true);
-		StartUniqueExpireEvent();
-		if (-1 != GetProto()->cLimitTimerBasedOnWearIndex)
-			StartTimerBasedOnWearExpireEvent();
-
-		// ACCESSORY_REFINE
-		StartAccessorySocketExpireEvent();
-		// END_OF_ACCESSORY_REFINE
-	}
-
-	m_pOwner->BuffOnAttr_AddBuffsFromItem(this);
-
-#if defined(__SET_ITEM__)
-	if (IsCostume() || IsUnique())
-		m_pOwner->RefreshItemSetBonus();
-
-	if (GetItemSetValue())
-		m_pOwner->RefreshItemSetBonusByValue();
-#endif
-
-	m_pOwner->ComputeBattlePoints();
-	m_pOwner->UpdatePacket();
-
-	Save();
-
-	return (true);
-}
-
-bool CItem::Unequip()
-{
-	if (!m_pOwner || GetCell() > EQUIPMENT_MAX_NUM)
-	{
-		// ITEM_OWNER_INVALID_PTR_BUG
-		sys_err("%s %u m_pOwner %p, GetCell %d",
-			GetName(), GetID(), get_pointer(m_pOwner), GetCell());
-		// END_OF_ITEM_OWNER_INVALID_PTR_BUG
-		return false;
-	}
-
-	if (this != m_pOwner->GetWear(GetCell()))
-	{
-		sys_err("m_pOwner->GetWear() != this");
-		return false;
-	}
-
-	// 신규 말 아이템 제거시 처리
-	if (IsRideItem())
-		ClearMountAttributeAndAffect();
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (IsDragonSoul())
-	{
-		DSManager::instance().DeactivateDragonSoul(this);
-#if defined(__DS_SET__)
-		m_pOwner->DragonSoul_SetBonus();
-#endif
-	}
-	else
-#endif
-	{
-		ModifyPoints(false);
-	}
-
-	StopUniqueExpireEvent();
-
-	if (-1 != GetProto()->cLimitTimerBasedOnWearIndex)
-		StopTimerBasedOnWearExpireEvent();
-
-	// ACCESSORY_REFINE
-	StopAccessorySocketExpireEvent();
-	// END_OF_ACCESSORY_REFINE
-
-	m_pOwner->BuffOnAttr_RemoveBuffsFromItem(this);
-	m_pOwner->SetWear(GetCell(), nullptr);
-
-	DWORD dwImmuneFlag = 0;
-	for (int i = 0; i < WEAR_MAX_NUM; ++i)
-	{
-		if (m_pOwner->GetWear(i))
-		{
-			SET_BIT(dwImmuneFlag, m_pOwner->GetWear(i)->GetRealImmuneFlag());
-		}
-	}
-	m_pOwner->SetImmuneFlag(dwImmuneFlag);
-
-#if defined(__SET_ITEM__)
-	if (IsCostume() || IsUnique())
-		m_pOwner->RefreshItemSetBonus();
-
-	if (GetItemSetValue())
-		m_pOwner->RefreshItemSetBonusByValue();
-#endif
-
-	m_pOwner->ComputeBattlePoints();
-	m_pOwner->UpdatePacket();
-
-	m_pOwner = nullptr;
-	m_wCell = 0;
-	m_bEquipped = false;
-
-	return true;
-}
-
-long CItem::GetValue(DWORD idx)
-{
-	assert(idx < ITEM_VALUES_MAX_NUM);
-	return GetProto()->alValues[idx];
-}
-
-void CItem::SetExchanging(bool bOn)
-{
-	m_bExchanging = bOn;
-}
-
-void CItem::Save()
-{
-	if (m_bSkipSave)
-		return;
-
-	ITEM_MANAGER::instance().DelayedSave(this);
-}
-
-#if defined(__MOVE_COSTUME_ATTR__)
-bool CItem::CanChangeCostumeAttr() const
-{
-	if (GetType() != ITEM_COSTUME)
-		return false;
-
-	switch (GetSubType())
-	{
-		case COSTUME_BODY:
-		case COSTUME_HAIR:
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-		case COSTUME_WEAPON:
-#endif
-			return true;
-	}
-
-	return false;
-}
-#endif
-
-bool CItem::CreateSocket(BYTE bSlot, BYTE bGold)
-{
-	assert(bSlot < ITEM_SOCKET_MAX_NUM);
-
-	if (m_alSockets[bSlot] != 0)
-	{
-		sys_err("Item::CreateSocket : socket already exist %s %d", GetName(), bSlot);
-		return false;
-	}
-
-	if (bGold)
-		m_alSockets[bSlot] = 2;
-	else
-		m_alSockets[bSlot] = 1;
-
-	UpdatePacket();
-
-	Save();
-	return true;
-}
-
-void CItem::SetSockets(const long* c_al)
-{
-	thecore_memcpy(m_alSockets, c_al, sizeof(m_alSockets));
-	Save();
-}
-
-void CItem::SetSocket(int i, long v, bool bLog)
-{
-	assert(i < ITEM_SOCKET_MAX_NUM);
-	m_alSockets[i] = v;
-	UpdatePacket();
-	Save();
-	if (bLog)
-		LogManager::instance().ItemLog(i, v, 0, GetID(), "SET_SOCKET", "", "", GetOriginalVnum());
-}
-
-int CItem::GetGold()
-{
-	if (IS_SET(GetFlag(), ITEM_FLAG_COUNT_PER_1GOLD))
-	{
-		if (GetProto()->dwShopSellPrice == 0)
-			return GetCount();
-		else
-			return GetCount() / GetProto()->dwShopSellPrice;
-	}
-	else
-		return GetProto()->dwShopSellPrice;
-}
-
-int CItem::GetShopBuyPrice()
-{
-	return GetProto()->dwShopBuyPrice;
-}
-
-int CItem::GetShopSellPrice()
-{
-	return GetProto()->dwShopSellPrice;
-}
-
-bool CItem::IsOwnership(LPCHARACTER ch)
-{
-	if (!m_pkOwnershipEvent)
-		return true;
-
-	return m_dwOwnershipPID == ch->GetPlayerID() ? true : false;
-}
-
-EVENTFUNC(ownership_event)
-{
-	item_event_info* info = dynamic_cast<item_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("ownership_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPITEM pkItem = info->item;
-
-	pkItem->SetOwnershipEvent(NULL);
-
-	TPacketGCItemOwnership p;
-
-	p.bHeader = HEADER_GC_ITEM_OWNERSHIP;
-	p.dwVID = pkItem->GetVID();
-	p.szName[0] = '\0';
-
-	pkItem->PacketAround(&p, sizeof(p));
-	return 0;
-}
-
-void CItem::SetOwnershipEvent(LPEVENT pkEvent)
-{
-	m_pkOwnershipEvent = pkEvent;
-}
-
-void CItem::SetOwnership(LPCHARACTER ch, int iSec)
-{
-	if (!ch)
-	{
-		if (m_pkOwnershipEvent)
-		{
-			event_cancel(&m_pkOwnershipEvent);
-			m_dwOwnershipPID = 0;
-
-			TPacketGCItemOwnership p;
-
-			p.bHeader = HEADER_GC_ITEM_OWNERSHIP;
-			p.dwVID = m_dwVID;
-			p.szName[0] = '\0';
-
-			PacketAround(&p, sizeof(p));
-		}
-		return;
-	}
-
-	if (m_pkOwnershipEvent)
-		return;
-
-	if (true == LC_IsEurope())
-	{
-		if (iSec <= 10)
-			iSec = 30;
-	}
-
-	m_dwOwnershipPID = ch->GetPlayerID();
-
-	item_event_info* info = AllocEventInfo<item_event_info>();
-	strlcpy(info->szOwnerName, ch->GetName(), sizeof(info->szOwnerName));
-	info->item = this;
-
-	SetOwnershipEvent(event_create(ownership_event, info, PASSES_PER_SEC(iSec)));
-
-	TPacketGCItemOwnership p;
-
-	p.bHeader = HEADER_GC_ITEM_OWNERSHIP;
-	p.dwVID = m_dwVID;
-	strlcpy(p.szName, ch->GetName(), sizeof(p.szName));
-
-	PacketAround(&p, sizeof(p));
-}
-
-int CItem::GetSocketCount()
-{
-	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
-	{
-		if (GetSocket(i) == 0)
-			return i;
-	}
-	return ITEM_SOCKET_MAX_NUM;
-}
-
-bool CItem::AddSocket()
-{
-	int count = GetSocketCount();
-	if (count == ITEM_SOCKET_MAX_NUM)
-		return false;
-	m_alSockets[count] = 1;
-	return true;
-}
-
-void CItem::AlterToSocketItem(int iSocketCount)
-{
-	if (iSocketCount >= METIN_SOCKET_MAX_NUM)
-	{
-		sys_log(0, "Invalid Socket Count %d, set to maximum", METIN_SOCKET_MAX_NUM);
-		iSocketCount = METIN_SOCKET_MAX_NUM;
-	}
-
-	for (int i = 0; i < iSocketCount; ++i)
-		SetSocket(i, 1);
-}
-
-void CItem::AlterToMagicItem(int iSecondPct /*= 0*/, int iThirdPct /*= 0 */)
-{
-	int idx = GetAttributeSetIndex();
-
-	if (idx < 0)
-		return;
-
-	//			Appeariance	Second	Third
-	// Weapon	50			20		5
-	// Armor	30			10		2
-	// Acc		20			10		1
-
-	//int iSecondPct;
-	//int iThirdPct;
-
-	switch (GetType())
-	{
-		case ITEM_WEAPON:
-		{
-			iSecondPct = 20;
-			iThirdPct = 5;
-		}
-		break;
-
-		case ITEM_ARMOR:
-		{
-			if (GetSubType() == ARMOR_BODY)
-			{
-				iSecondPct = 10;
-				iThirdPct = 2;
-			}
-			else
-			{
-				iSecondPct = 10;
-				iThirdPct = 1;
-			}
-		}
-		break;
-
-#if defined(__MOVE_COSTUME_ATTR__)
-		case ITEM_COSTUME:
-		{
-			if (GetSubType() == COSTUME_BODY)
-			{
-				iSecondPct = 30;
-				iThirdPct = 10;
-			}
-			else if (GetSubType() == COSTUME_HAIR)
-			{
-				iSecondPct = 30;
-				iThirdPct = 10;
-			}
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-			else if (GetSubType() == COSTUME_WEAPON)
-			{
-				iSecondPct = 30;
-				iThirdPct = 10;
-			}
-#endif
-			else
-			{
-				iSecondPct = 0;
-				iThirdPct = 0;
-			}
-		}
-		break;
-#endif
-
-		default:
-			return;
-	}
-
-	// 100% 확률로 좋은 속성 하나
-	PutAttribute(aiItemMagicAttributePercentHigh);
-
-	if (number(1, 100) <= iSecondPct)
-		PutAttribute(aiItemMagicAttributePercentLow);
-
-	if (number(1, 100) <= iThirdPct)
-		PutAttribute(aiItemMagicAttributePercentLow);
-}
-
-DWORD CItem::GetRefineFromVnum()
-{
-	return ITEM_MANAGER::instance().GetRefineFromVnum(GetVnum());
-}
-
-int CItem::GetRefineLevel()
-{
-	const char* name = GetBaseName();
-	char* p = const_cast<char*>(strrchr(name, '+'));
-
-	if (!p)
-		return 0;
-
-	int	rtn = 0;
-	str_to_number(rtn, p + 1);
-
-	const char* locale_name = GetName();
-	p = const_cast<char*>(strrchr(locale_name, '+'));
-
-	if (p)
-	{
-		int	locale_rtn = 0;
-		str_to_number(locale_rtn, p + 1);
-		if (locale_rtn != rtn)
-		{
-			sys_err("refine_level_based_on_NAME(%d) is not equal to refine_level_based_on_LOCALE_NAME(%d).", rtn, locale_rtn);
-		}
-	}
-
-	return rtn;
-}
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-long CItem::GetWearingLevelLimit() const
-{
-	if (m_pProto)
-	{
-		for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-			if (m_pProto->aLimits[i].bType == LIMIT_LEVEL)
-				return m_pProto->aLimits[i].lValue;
-	}
-
-	return 0;
-}
-
-bool CItem::IsHairDye() const
-{
-	switch (GetVnum())
-	{
-		case 70202:
-		case 70203:
-		case 70204:
-		case 70205:
-		case 70206:
-			return true;
-		default:
-			return false;
-	}
-}
-#endif
-
-bool CItem::IsPolymorphItem()
-{
-	return GetType() == ITEM_POLYMORPH;
-}
-
-EVENTFUNC(unique_expire_event)
-{
-	item_event_info* info = dynamic_cast<item_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("unique_expire_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPITEM pkItem = info->item;
-
-	if (pkItem->GetValue(2) == 0)
-	{
-		if (pkItem->GetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME) <= 1)
-		{
-			sys_log(0, "UNIQUE_ITEM: expire %s %u", pkItem->GetName(), pkItem->GetID());
-			pkItem->SetUniqueExpireEvent(NULL);
-			ITEM_MANAGER::instance().RemoveItem(pkItem, "UNIQUE_EXPIRE");
-			return 0;
-		}
-		else
-		{
-			pkItem->SetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME, pkItem->GetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME) - 1);
-			return PASSES_PER_SEC(60);
-		}
-	}
-	else
-	{
-		time_t cur = get_global_time();
-
-		if (pkItem->GetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME) <= cur)
-		{
-			pkItem->SetUniqueExpireEvent(NULL);
-			ITEM_MANAGER::instance().RemoveItem(pkItem, "UNIQUE_EXPIRE");
-			return 0;
-		}
-		else
-		{
-			// 게임 내에 시간제 아이템들이 빠릿빠릿하게 사라지지 않는 버그가 있어
-			// 수정
-			// by rtsummit
-			if (pkItem->GetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME) - cur < 600)
-				return PASSES_PER_SEC(pkItem->GetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME) - cur);
-			else
-				return PASSES_PER_SEC(600);
-		}
-	}
-}
-
-// 시간 후불제
-// timer를 시작할 때에 시간 차감하는 것이 아니라, 
-// timer가 발화할 때에 timer가 동작한 시간 만큼 시간 차감을 한다.
-EVENTFUNC(timer_based_on_wear_expire_event)
-{
-	item_event_info* info = dynamic_cast<item_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("expire_event <Factor> Null pointer");
-		return 0;
-	}
-
-	LPITEM pkItem = info->item;
-	int remain_time = pkItem->GetSocket(ITEM_SOCKET_REMAIN_SEC) - processing_time / passes_per_sec;
-	if (remain_time <= 0)
-	{
-		sys_log(0, "ITEM EXPIRED : expired %s %u", pkItem->GetName(), pkItem->GetID());
-		pkItem->SetTimerBasedOnWearExpireEvent(NULL);
-		pkItem->SetSocket(ITEM_SOCKET_REMAIN_SEC, 0);
-
-		// 일단 timer based on wear 용혼석은 시간 다 되었다고 없애지 않는다.
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (pkItem->IsDragonSoul())
-		{
-			DSManager::instance().DeactivateDragonSoul(pkItem);
-#if defined(__DS_SET__)
-			if (pkItem->GetOwner())
-				pkItem->GetOwner()->DragonSoul_SetBonus();
-#endif
-		}
-		else
-#endif
-		{
-			ITEM_MANAGER::instance().RemoveItem(pkItem, "TIMER_BASED_ON_WEAR_EXPIRE");
-		}
-		return 0;
-	}
-	pkItem->SetSocket(ITEM_SOCKET_REMAIN_SEC, remain_time);
-	return PASSES_PER_SEC(MIN(60, remain_time));
-}
-
-void CItem::SetUniqueExpireEvent(LPEVENT pkEvent)
-{
-	m_pkUniqueExpireEvent = pkEvent;
-}
-
-void CItem::SetTimerBasedOnWearExpireEvent(LPEVENT pkEvent)
-{
-	m_pkTimerBasedOnWearExpireEvent = pkEvent;
-}
-
-EVENTFUNC(real_time_expire_event)
-{
-	const item_vid_event_info* info = reinterpret_cast<const item_vid_event_info*>(event->info);
-
-	if (NULL == info)
-		return 0;
-
-	const LPITEM item = ITEM_MANAGER::instance().FindByVID(info->item_vid);
-
-	if (NULL == item)
-		return 0;
-
-	const time_t current = get_global_time();
-
-	if (current > item->GetSocket(0))
-	{
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		LPCHARACTER owner = item->GetOwner();
-		if (owner)
-		{
-			CChangeLook* pChangeLook = owner->GetChangeLook();
-			if (pChangeLook)
-				pChangeLook->Clear();
-		}
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-		if (item->GetType() == ITEM_PET && item->GetSubType() == PET_UPBRINGING)
-		{
-			if (item->GetOwner()->GetActiveGrowthPet())
-			{
-				if (item->GetOwner()->GetActiveGrowthPet()->GetPetID() == item->GetSocket(2))
-					item->GetOwner()->GetActiveGrowthPet()->Unsummon();
-			}
-		}
-
-		if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_RT_REMOVE))
-		{
-			item->StopRealTimeExpireEvent();
-			return 0;
-		}
-
-#endif
-		ITEM_MANAGER::instance().RemoveItem(item, "REAL_TIME_EXPIRE");
-		return 0;
-	}
-
-	return PASSES_PER_SEC(1);
-}
-
-#if defined(__GROWTH_PET_SYSTEM__)
-void CItem::StopRealTimeExpireEvent()
-{
-	if (!m_pkRealTimeExpireEvent)
-		return;
-
-	event_cancel(&m_pkRealTimeExpireEvent);
-	m_pkRealTimeExpireEvent = nullptr;
-}
-#endif
-
-void CItem::StartRealTimeExpireEvent()
-{
-	if (m_pkRealTimeExpireEvent)
-		return;
-
-	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-	{
-		if (LIMIT_REAL_TIME == GetProto()->aLimits[i].bType || LIMIT_REAL_TIME_START_FIRST_USE == GetProto()->aLimits[i].bType)
-		{
-			item_vid_event_info* info = AllocEventInfo<item_vid_event_info>();
-			info->item_vid = GetVID();
-
-			m_pkRealTimeExpireEvent = event_create(real_time_expire_event, info, PASSES_PER_SEC(1));
-
-			sys_log(0, "REAL_TIME_EXPIRE: StartRealTimeExpireEvent");
-
-			return;
-		}
-	}
-}
-
-bool CItem::IsRealTimeItem()
-{
-	if (!GetProto())
-		return false;
-
-	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-	{
-		if (LIMIT_REAL_TIME == GetProto()->aLimits[i].bType || LIMIT_REAL_TIME_START_FIRST_USE == GetProto()->aLimits[i].bType)
-			return true;
-	}
-
-	return false;
-}
-
-bool CItem::IsUsedTimeItem()
-{
-	return m_pkRealTimeExpireEvent != NULL;
-}
-
-void CItem::StartUniqueExpireEvent()
-{
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	if (GetType() != ITEM_UNIQUE && !IsRideItem())
-		return;
-#else
-	if (GetType() != ITEM_UNIQUE)
-		return;
-#endif
-
-	if (m_pkUniqueExpireEvent)
-		return;
-
-	// 기간제 아이템일 경우 시간제 아이템은 동작하지 않는다
-	if (IsRealTimeItem())
-		return;
-
-	// HARD CODING
-	if (GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
-		if (m_pOwner) m_pOwner->ShowAlignment(false);
-
-	int iSec = GetSocket(ITEM_SOCKET_UNIQUE_SAVE_TIME);
-
-	if (iSec == 0)
-		iSec = 60;
-	else
-		iSec = MIN(iSec, 60);
-
-	SetSocket(ITEM_SOCKET_UNIQUE_SAVE_TIME, 0);
-
-	item_event_info* info = AllocEventInfo<item_event_info>();
-	info->item = this;
-
-	SetUniqueExpireEvent(event_create(unique_expire_event, info, PASSES_PER_SEC(iSec)));
-}
-
-// 시간 후불제
-// timer_based_on_wear_expire_event 설명 참조
-void CItem::StartTimerBasedOnWearExpireEvent()
-{
-	if (m_pkTimerBasedOnWearExpireEvent)
-		return;
-
-	// 기간제 아이템일 경우 시간제 아이템은 동작하지 않는다
-	if (IsRealTimeItem())
-		return;
-
-	if (-1 == GetProto()->cLimitTimerBasedOnWearIndex)
-		return;
-
-	int iSec = GetSocket(0);
-
-	if (0 != iSec)
-	{
-		iSec %= 60;
-		if (0 == iSec)
-			iSec = 60;
-	}
-
-	item_event_info* info = AllocEventInfo<item_event_info>();
-	info->item = this;
-
-	SetTimerBasedOnWearExpireEvent(event_create(timer_based_on_wear_expire_event, info, PASSES_PER_SEC(iSec)));
-}
-
-void CItem::StopUniqueExpireEvent()
-{
-	if (!m_pOwner)
-		return;
-
-	if (!m_pkUniqueExpireEvent)
-		return;
-
-	if (GetValue(2) != 0) // 게임시간제 이외의 아이템은 UniqueExpireEvent를 중단할 수 없다.
-		return;
-
-	// HARD CODING
-	if (GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
-		m_pOwner->ShowAlignment(true);
-
-	SetSocket(ITEM_SOCKET_UNIQUE_SAVE_TIME, event_time(m_pkUniqueExpireEvent) / passes_per_sec);
-	event_cancel(&m_pkUniqueExpireEvent);
-
-	ITEM_MANAGER::instance().SaveSingleItem(this);
-}
-
-void CItem::StopTimerBasedOnWearExpireEvent()
-{
-	if (!m_pkTimerBasedOnWearExpireEvent)
-		return;
-
-	int remain_time = GetSocket(ITEM_SOCKET_REMAIN_SEC) - event_processing_time(m_pkTimerBasedOnWearExpireEvent) / passes_per_sec;
-
-	SetSocket(ITEM_SOCKET_REMAIN_SEC, remain_time);
-	event_cancel(&m_pkTimerBasedOnWearExpireEvent);
-
-	ITEM_MANAGER::instance().SaveSingleItem(this);
-}
-
-void CItem::ApplyAddon(int iAddonType)
-{
-	CItemAddonManager::instance().ApplyAddonTo(iAddonType, this);
-}
-
-int CItem::GetSpecialGroup() const
-{
-	return ITEM_MANAGER::instance().GetSpecialGroupFromItem(GetVnum());
-}
-
-//
-// 악세서리 소켓 처리.
-//
-bool CItem::IsAccessoryForSocket()
-{
-	return (m_pProto->bType == ITEM_ARMOR && (m_pProto->bSubType == ARMOR_WRIST || m_pProto->bSubType == ARMOR_NECK || m_pProto->bSubType == ARMOR_EAR)) ||
-		(m_pProto->bType == ITEM_BELT); // 2013년 2월 새로 추가된 '벨트' 아이템의 경우 기획팀에서 악세서리 소켓 시스템을 그대로 이용하자고 함.
-}
-
-bool CItem::IsRemovableSocket()
-{
-	if (m_pProto->bType == ITEM_ARMOR)
-		return m_pProto->bSubType == ARMOR_BODY
-#if defined(__GLOVE_SYSTEM__)
-		|| m_pProto->bSubType == ARMOR_GLOVE
-#endif
-		;
-
-	if (m_pProto->bType == ITEM_WEAPON)
-		return !(m_pProto->bSubType == WEAPON_ARROW
-			|| m_pProto->bSubType == WEAPON_MOUNT_SPEAR
-#if defined(__QUIVER_SYSTEM__)
-			|| m_pProto->bSubType == WEAPON_QUIVER
-#endif
-			|| m_pProto->bSubType == WEAPON_BOUQUET);
-
-	return false;
-}
-
-void CItem::SetAccessorySocketGrade(int iGrade)
-{
-	SetSocket(0, MINMAX(0, iGrade, GetAccessorySocketMaxGrade()));
-
-	int iDownTime = aiAccessorySocketDegradeTime[GetAccessorySocketGrade()];
-
-	//if (test_server)
-	//	iDownTime /= 60;
-
-	SetAccessorySocketDownGradeTime(iDownTime);
-}
-
-void CItem::SetAccessorySocketMaxGrade(int iMaxGrade)
-{
-	SetSocket(1, MINMAX(0, iMaxGrade, ITEM_ACCESSORY_SOCKET_MAX_NUM));
-}
-
-void CItem::SetAccessorySocketDownGradeTime(DWORD time)
-{
-	SetSocket(2, time);
-
-	if (test_server && GetOwner())
-		GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s에서 소켓 빠질때까지 남은 시간 %d", LC_ITEM(GetVnum()), time));
-}
-
-EVENTFUNC(accessory_socket_expire_event)
-{
-	item_vid_event_info* info = dynamic_cast<item_vid_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("accessory_socket_expire_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPITEM item = ITEM_MANAGER::instance().FindByVID(info->item_vid);
-
-	if (item->GetAccessorySocketDownGradeTime() <= 1)
-	{
-	degrade:
-		item->SetAccessorySocketExpireEvent(NULL);
-		item->AccessorySocketDegrade();
-		return 0;
-	}
-	else
-	{
-		int iTime = item->GetAccessorySocketDownGradeTime() - 60;
-
-		if (iTime <= 1)
-			goto degrade;
-
-		item->SetAccessorySocketDownGradeTime(iTime);
-
-		if (iTime > 60)
-			return PASSES_PER_SEC(60);
-		else
-			return PASSES_PER_SEC(iTime);
-	}
-}
-
-void CItem::StartAccessorySocketExpireEvent()
-{
-	if (!IsAccessoryForSocket())
-		return;
-
-	if (m_pkAccessorySocketExpireEvent)
-		return;
-
-	if (GetAccessorySocketMaxGrade() == 0)
-		return;
-
-	if (GetAccessorySocketGrade() == 0)
-		return;
-
-	int iSec = GetAccessorySocketDownGradeTime();
-	SetAccessorySocketExpireEvent(NULL);
-
-	if (iSec <= 1)
-		iSec = 5;
-	else
-		iSec = MIN(iSec, 60);
-
-	item_vid_event_info* info = AllocEventInfo<item_vid_event_info>();
-	info->item_vid = GetVID();
-
-	SetAccessorySocketExpireEvent(event_create(accessory_socket_expire_event, info, PASSES_PER_SEC(iSec)));
-}
-
-void CItem::StopAccessorySocketExpireEvent()
-{
-	if (!m_pkAccessorySocketExpireEvent)
-		return;
-
-	if (!IsAccessoryForSocket())
-		return;
-
-	int new_time = GetAccessorySocketDownGradeTime() - (60 - event_time(m_pkAccessorySocketExpireEvent) / passes_per_sec);
-
-	event_cancel(&m_pkAccessorySocketExpireEvent);
-
-	if (new_time <= 1)
-	{
-		AccessorySocketDegrade();
-	}
-	else
-	{
-		SetAccessorySocketDownGradeTime(new_time);
-	}
-}
-
-bool CItem::IsRideItem()
-{
-	if (ITEM_UNIQUE == GetType() && UNIQUE_SPECIAL_RIDE == GetSubType())
-		return true;
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	if (ITEM_COSTUME == GetType() && COSTUME_MOUNT == GetSubType())
-		return true;
-#endif
-
-	return false;
-}
-
-void CItem::ClearMountAttributeAndAffect()
-{
-	LPCHARACTER ch = GetOwner();
-
-	ch->RemoveAffect(AFFECT_MOUNT);
-	ch->RemoveAffect(AFFECT_MOUNT_BONUS);
-
-	ch->MountVnum(0);
-
-	ch->PointChange(POINT_ST, 0);
-	ch->PointChange(POINT_DX, 0);
-	ch->PointChange(POINT_HT, 0);
-	ch->PointChange(POINT_IQ, 0);
-}
-
-void CItem::SetAccessorySocketExpireEvent(LPEVENT pkEvent)
-{
-	m_pkAccessorySocketExpireEvent = pkEvent;
-}
-
-void CItem::AccessorySocketDegrade()
-{
-	if (GetAccessorySocketGrade() > 0)
-	{
-		LPCHARACTER ch = GetOwner();
-
-		if (ch)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s에 박혀있던 보석이 사라집니다.", LC_ITEM(GetVnum())));
-		}
-
-		ModifyPoints(false);
-		SetAccessorySocketGrade(GetAccessorySocketGrade() - 1);
-		ModifyPoints(true);
-
-		int iDownTime = aiAccessorySocketDegradeTime[GetAccessorySocketGrade()];
-
-		if (test_server)
-			iDownTime /= 60;
-
-		SetAccessorySocketDownGradeTime(iDownTime);
-
-		if (iDownTime)
-			StartAccessorySocketExpireEvent();
-	}
-}
-
-// ring에 item을 박을 수 있는지 여부를 체크해서 리턴
-static const bool CanPutIntoRing(LPITEM ring, LPITEM item)
-{
-	const DWORD vnum = item->GetVnum();
-	return false;
-}
-
-bool CItem::CanPutInto(LPITEM item)
-{
-	if (item->GetType() == ITEM_BELT)
-		return this->GetSubType() == USE_PUT_INTO_BELT_SOCKET;
-
-	else if (item->GetType() == ITEM_RING)
-		return CanPutIntoRing(item, this);
-
-	else if (item->GetType() != ITEM_ARMOR)
-		return false;
-
-	DWORD vnum = item->GetVnum();
-
-	struct JewelAccessoryInfo
-	{
-		DWORD jewel;
-		DWORD wrist;
-		DWORD neck;
-		DWORD ear;
-	};
-	const static JewelAccessoryInfo infos[] = {
-		{ 50634, 14420, 16220, 17220 },
-		{ 50635, 14500, 16500, 17500 },
-		{ 50636, 14520, 16520, 17520 },
-		{ 50637, 14540, 16540, 17540 },
-		{ 50638, 14560, 16560, 17560 },
-		{ 50639, 14570, 16570, 0 },
-#if defined(__CONQUEROR_LEVEL__)
-		{ 50661, 14590, 16590, 17580 },
-		{ 50662, 14600, 16600, 17590 },
-		{ 50663, 14610, 16610, 17600 },
-		{ 50664, 14580, 16580, 17570 },
-#endif
-	};
-
-	DWORD item_type = (item->GetVnum() / 10) * 10;
-	for (int i = 0; i < sizeof(infos) / sizeof(infos[0]); i++)
-	{
-		const JewelAccessoryInfo& info = infos[i];
-		switch (item->GetSubType())
-		{
-			case ARMOR_WRIST:
-				if (info.wrist == item_type)
-				{
-					if (info.jewel == GetVnum())
-					{
-						return true;
-					}
-					else
-					{
-						return false;
-					}
-				}
-				break;
-			case ARMOR_NECK:
-				if (info.neck == item_type)
-				{
-					if (info.jewel == GetVnum())
-					{
-						return true;
-					}
-					else
-					{
-						return false;
-					}
-				}
-				break;
-			case ARMOR_EAR:
-				if (info.ear == item_type)
-				{
-					if (info.jewel == GetVnum())
-					{
-						return true;
-					}
-					else
-					{
-						return false;
-					}
-				}
-				break;
-		}
-	}
-	if (item->GetSubType() == ARMOR_WRIST)
-		vnum -= 14000;
-	else if (item->GetSubType() == ARMOR_NECK)
-		vnum -= 16000;
-	else if (item->GetSubType() == ARMOR_EAR)
-		vnum -= 17000;
-	else
-		return false;
-
-	DWORD type = vnum / 20;
-
-	if (type < 0 || type > 11)
-	{
-		type = (vnum - 170) / 20;
-
-		if (50623 + type != GetVnum())
-			return false;
-		else
-			return true;
-	}
-	else if (item->GetVnum() >= 16210 && item->GetVnum() <= 16219)
-	{
-		if (50625 != GetVnum())
-			return false;
-		else
-			return true;
-	}
-	else if (item->GetVnum() >= 16230 && item->GetVnum() <= 16239)
-	{
-		if (50626 != GetVnum())
-			return false;
-		else
-			return true;
-	}
-
-	return 50623 + type == GetVnum();
-}
-
-bool CItem::IsStackable()
-{
-	return (GetFlag() & ITEM_FLAG_STACKABLE) ? true : false;
-}
-
-bool CItem::CheckItemUseLevel(int nLevel)
-{
-	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-	{
-		if (this->m_pProto->aLimits[i].bType == LIMIT_LEVEL)
-		{
-			if (this->m_pProto->aLimits[i].lValue > nLevel) return false;
-			else return true;
-		}
-	}
-	return true;
-}
-
-POINT_VALUE CItem::FindApplyValue(POINT_TYPE wApplyType)
-{
-	if (m_pProto == NULL)
-		return 0;
-
-	for (int i = 0; i < ITEM_APPLY_MAX_NUM; ++i)
-	{
-		if (m_pProto->aApplies[i].wType == wApplyType)
-			return m_pProto->aApplies[i].lValue;
-	}
-
-	return 0;
-}
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-DWORD CItem::GetMountVnum()
-{
-	if (!IsCostumeMount())
-		return 0;
-
-	const DWORD dwMountVnum = FindApplyValue(APPLY_MOUNT);
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	const DWORD c_dwTransmutationVnum = GetTransmutationVnum();
-	if (c_dwTransmutationVnum != 0)
-	{
-		TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(c_dwTransmutationVnum);
-		if (pItemTable)
-			return static_cast<DWORD>(pItemTable->FindApplyValue(APPLY_MOUNT));
-	}
-#endif
-	return dwMountVnum;
-}
-#endif
-
-void CItem::CopySocketTo(LPITEM pItem)
-{
-	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-	{
-		pItem->m_alSockets[i] = m_alSockets[i];
-	}
-}
-
-int CItem::GetAccessorySocketGrade()
-{
-	return MINMAX(0, GetSocket(0), GetAccessorySocketMaxGrade());
-}
-
-int CItem::GetAccessorySocketMaxGrade()
-{
-	return MINMAX(0, GetSocket(1), ITEM_ACCESSORY_SOCKET_MAX_NUM);
-}
-
-int CItem::GetAccessorySocketDownGradeTime()
-{
-	return MINMAX(0, GetSocket(2), aiAccessorySocketDegradeTime[GetAccessorySocketGrade()]);
-}
-
-void CItem::AttrLog()
-{
-	const char* pszIP = NULL;
-
-	if (GetOwner() && GetOwner()->GetDesc())
-		pszIP = GetOwner()->GetDesc()->GetHostName();
-
-	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-	{
-		if (m_alSockets[i])
-		{
-			LogManager::instance().ItemLog(i, m_alSockets[i], 0, GetID(), "INFO_SOCKET", "", pszIP ? pszIP : "", GetOriginalVnum());
-		}
-	}
-
-	for (int i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
-	{
-		POINT_TYPE type = m_aAttr[i].wType;
-		POINT_VALUE value = m_aAttr[i].lValue;
-
-		if (type)
-			LogManager::instance().ItemLog(i, type, value, GetID(), "INFO_ATTR", "", pszIP ? pszIP : "", GetOriginalVnum());
-	}
-}
-
-int CItem::GetLevelLimit()
-{
-	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-	{
-		if (this->m_pProto->aLimits[i].bType == LIMIT_LEVEL)
-		{
-			return this->m_pProto->aLimits[i].lValue;
-		}
-	}
-	return 0;
-}
-
-int CItem::GetDurationLimit()
-{
-	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-	{
-		if (this->m_pProto->aLimits[i].bType == LIMIT_DURATION)
-		{
-			return this->m_pProto->aLimits[i].lValue;
-		}
-	}
-	return 0;
-}
-
-bool CItem::OnAfterCreatedItem()
-{
-#if defined(__SOUL_SYSTEM__)
-	if (GetType() == ITEM_SOUL && GetLimitValue(1) != 0)
-		StartSoulTimerUseEvent();
-#endif
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (GetSealDate() > E_SEAL_DATE_DEFAULT_TIMESTAMP)
-		StartSealDateExpireTimerEvent();
-#endif
-
-	// 아이템을 한 번이라도 사용했다면, 그 이후엔 사용 중이지 않아도 시간이 차감되는 방식
-	if (-1 != this->GetProto()->cLimitRealTimeFirstUseIndex)
-	{
-		// Socket1에 아이템의 사용 횟수가 기록되어 있으니, 한 번이라도 사용한 아이템은 타이머를 시작한다.
-		if (0 != GetSocket(1))
-		{
-			StartRealTimeExpireEvent();
-		}
-	}
-
-	return true;
-}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-bool CItem::IsDragonSoul()
-{
-	return GetType() == ITEM_DS;
-}
-
-int CItem::GiveMoreTime_Per(float fPercent)
-{
-	if (IsDragonSoul())
-	{
-		DWORD duration = DSManager::instance().GetDuration(this);
-		DWORD remain_sec = GetSocket(ITEM_SOCKET_REMAIN_SEC);
-		DWORD given_time = fPercent * duration / 100u;
-
-		if (remain_sec == duration)
-			return false;
-
-		if ((given_time + remain_sec) >= duration)
-		{
-			SetSocket(ITEM_SOCKET_REMAIN_SEC, duration);
-			return duration - remain_sec;
-		}
-		else
-		{
-			SetSocket(ITEM_SOCKET_REMAIN_SEC, given_time + remain_sec);
-			return given_time;
-		}
-	}
-	// 우선 용혼석에 관해서만 하도록 한다.
-	else
-		return 0;
-}
-
-int CItem::GiveMoreTime_Fix(DWORD dwTime)
-{
-	if (IsDragonSoul())
-	{
-		DWORD duration = DSManager::instance().GetDuration(this);
-		DWORD remain_sec = GetSocket(ITEM_SOCKET_REMAIN_SEC);
-
-		if (remain_sec == duration)
-			return false;
-
-		if ((dwTime + remain_sec) >= duration)
-		{
-			SetSocket(ITEM_SOCKET_REMAIN_SEC, duration);
-			return duration - remain_sec;
-		}
-		else
-		{
-			SetSocket(ITEM_SOCKET_REMAIN_SEC, dwTime + remain_sec);
-			return dwTime;
-		}
-	}
-	// 우선 용혼석에 관해서만 하도록 한다.
-	else
-		return 0;
-}
-#endif
-
-int CItem::GetDuration()
-{
-	if (!GetProto())
-		return -1;
-
-	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-	{
-		if (LIMIT_REAL_TIME == GetProto()->aLimits[i].bType)
-			return GetProto()->aLimits[i].lValue;
-	}
-
-	if (-1 != GetProto()->cLimitTimerBasedOnWearIndex)
-		return GetProto()->aLimits[GetProto()->cLimitTimerBasedOnWearIndex].lValue;
-
-	return -1;
-}
-
-bool CItem::IsSameSpecialGroup(const LPITEM item) const
-{
-	// 서로 VNUM이 같다면 같은 그룹인 것으로 간주
-	if (this->GetVnum() == item->GetVnum())
-		return true;
-
-	if (GetSpecialGroup() && (item->GetSpecialGroup() == GetSpecialGroup()))
-		return true;
-
-	return false;
-}
-
-DWORD CItem::GetRealImmuneFlag()
-{
-	DWORD dwImmuneFlag = m_pProto->dwImmuneFlag;
-	for (int i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
-	{
-		if (GetAttributeType(i))
-		{
-			const TPlayerItemAttribute& ia = GetAttribute(i);
-
-			if (ia.wType == APPLY_IMMUNE_STUN && !IS_SET(dwImmuneFlag, IMMUNE_STUN))
-				SET_BIT(dwImmuneFlag, IMMUNE_STUN);
-			else if (ia.wType == APPLY_IMMUNE_FALL && !IS_SET(dwImmuneFlag, IMMUNE_FALL))
-				SET_BIT(dwImmuneFlag, IMMUNE_FALL);
-			else if (ia.wType == APPLY_IMMUNE_SLOW && !IS_SET(dwImmuneFlag, IMMUNE_SLOW))
-				SET_BIT(dwImmuneFlag, IMMUNE_SLOW);
-		}
-	}
-
-	return dwImmuneFlag;
-}
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-void CItem::SetTransmutationVnum(DWORD blVnum)
-{
-	m_dwTransmutationVnum = blVnum;
-	Save();
-}
-
-DWORD CItem::GetTransmutationVnum() const
-{
-	return m_dwTransmutationVnum;
-}
-#endif
-
-#if defined(__SET_ITEM__)
-void CItem::SetItemSetValue(BYTE bSet)
-{
-	m_bSetValue = bSet;
-	UpdatePacket();
-}
-
-BYTE CItem::GetItemSetValue() const
-{
-	return m_bSetValue;
-}
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-void CItem::SetRefineElement(const TPlayerItemRefineElement* pTable)
-{
-	thecore_memcpy(&m_RefineElement, pTable, sizeof(m_RefineElement));
-
-	UpdatePacket();
-	Save();
-}
-
-void CItem::CopyElementTo(const LPITEM pItem)
-{
-	pItem->SetRefineElement(&m_RefineElement);
-}
-
-void CItem::UpgradeRefineElement(WORD wApplyType, BYTE bValue, BYTE bBonusValue)
-{
-	BYTE& bGrade = m_RefineElement.bGrade;
-	if (bGrade >= REFINE_ELEMENT_MAX)
-		return;
-
-	++bGrade;
-
-	m_RefineElement.abValue[bGrade - 1] = bValue;
-	m_RefineElement.abBonusValue[bGrade - 1] = bBonusValue;
-	m_RefineElement.wApplyType = wApplyType;
-
-	UpdatePacket();
-	Save();
-}
-
-void CItem::DowngradeRefineElement()
-{
-	BYTE& bGrade = m_RefineElement.bGrade;
-	if (bGrade == 0)
-		return;
-
-	--bGrade;
-
-	m_RefineElement.abValue[bGrade] = 0;
-	m_RefineElement.abBonusValue[bGrade] = 0;
-
-	if (bGrade == 0)
-		m_RefineElement.wApplyType = 0;
-
-	UpdatePacket();
-	Save();
-}
-
-void CItem::ChangeRefineElement(WORD wApplyType)
-{
-	m_RefineElement.wApplyType = wApplyType;
-
-	UpdatePacket();
-	Save();
-}
-
-BYTE CItem::GetRefineElementValue() const
-{
-	const BYTE& bGrade = m_RefineElement.bGrade;
-	if (bGrade == 0)
-		return 0;
-
-	BYTE bValue = 0;
-	for (BYTE bPos = 0; bPos < REFINE_ELEMENT_MAX && bPos < bGrade; ++bPos)
-		bValue += m_RefineElement.abValue[bPos];
-
-	return bValue;
-}
-
-BYTE CItem::GetRefineElementBonusValue() const
-{
-	const BYTE& bGrade = m_RefineElement.bGrade;
-	if (bGrade == 0)
-		return 0;
-
-	BYTE bValue = 0;
-	for (BYTE bPos = 0; bPos < REFINE_ELEMENT_MAX && bPos < bGrade; ++bPos)
-		bValue += m_RefineElement.abBonusValue[bPos];
-
-	return bValue;
-}
-#endif
-
-#if defined(__SOUL_SYSTEM__)
-EVENTFUNC(soul_timer_use_event)
-{
-	const item_vid_event_info* info = reinterpret_cast<const item_vid_event_info*>(event->info);
-	if (info == nullptr)
-		return 0;
-
-	LPITEM item = ITEM_MANAGER::instance().FindByVID(info->item_vid);
-	if (item == nullptr)
-		return 0;
-
-	long data = item->GetSocket(2);
-	if (data == 0)
-		data = item->GetValue(2);
-
-	long keep_time = data / 10000;
-	long max_time = item->GetLimitValue(1);
-	int min_time = 60;
-	long remain_count = data % 10000;
-
-	if (keep_time % min_time == 0 && keep_time > 0 && item->GetSocket(1) != TRUE)
-		if (const LPCHARACTER& ch = item->GetOwner())
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Soul System] Use %s to receive the effect.", LC_ITEM(item->GetVnum())));
-
-	if (keep_time >= max_time)
-		return 0;
-
-	auto new_data = ((keep_time + 1) * 10000) + remain_count;
-	item->SetSocket(2, new_data, false /* log */);
-
-	return PASSES_PER_SEC(test_server ? 1 : 60);
-}
-
-void CItem::StartSoulTimerUseEvent()
-{
-	if (m_pkSoulTimerUseEvent)
-		return;
-
-	item_vid_event_info* info = AllocEventInfo<item_vid_event_info>();
-	info->item_vid = GetVID();
-	m_pkSoulTimerUseEvent = event_create(soul_timer_use_event, info, PASSES_PER_SEC(test_server ? 1 : 60));
-}
-
-void CItem::ResetSoulTimerUseEvent()
-{
-	if (m_pkSoulTimerUseEvent)
-		event_cancel(&m_pkSoulTimerUseEvent);
-
-	StartSoulTimerUseEvent();
-}
-#endif
-
-#if defined(__GLOVE_SYSTEM__)
-DWORD CItem::GetRandomSungMaSocketValue(BYTE bType, int iRefineLevel, bool bMultiplier)
-{
-	/*
-	* NOTE : If you're planning to edit this function be very careful with its limitations.
-	* The maximum data size cannot be more than a `LONG_MAX` value and each parameter has to
-	* respect certain values.
-	*
-	* @param bType - Value5 of the Spirit Stone.
-	* @param iRefineLeveL - Level of the Spirit Stone.
-	* These parameters cannot be valued above 9!
-	*
-	* @param bMultiplier - Chance given to multiply the value of the bonus.
-	*
-	* Additional limitations to be respected:
-	*	- ApplyType < 999 !
-	*	- ApplyValue < 99 !
-	*
-	* Need Debugging?
-	*	. 2394230 APPLY_SUNGMA_STR		RefineLevel 4	Type 2	ApplyValue 30
-	*	. 2404230 APPLY_SUNGMA_HP		RefineLevel 4	Type 2	ApplyValue 30
-	*	. 2414230 APPLY_SUNGMA_MOVE		RefineLevel 4	Type 2	ApplyValue 30
-	*	. 2424230 APPLY_SUNGMA_IMMUNE	RefineLevel 4	Type 2	ApplyValue 30
-	*
-	* 20230511.Owsap
-	*/
-
-	if (bType >= 10 || iRefineLevel >= 10)
-	{
-		sys_err("CItem::GetRandomSungMaSocketValue:: bType %d (Value5) or iRefineLevel %d is too high to store in the socket data.", bType, iRefineLevel);
-		return 0;
-	}
-
-	std::vector<WORD> vApplyTypes
-	{
-		APPLY_SUNGMA_STR,
-		APPLY_SUNGMA_HP,
-		APPLY_SUNGMA_MOVE,
-		APPLY_SUNGMA_IMMUNE,
-	};
-
-	const BYTE bDefaultValues[] = { 1, 3, 6, 9, 15 };
-	WORD wApplyType = vApplyTypes[number(0, (vApplyTypes.size() - 1))];
-
-	// DUPLICATE_APPLY_TYPE_FIX
-	std::unordered_set<WORD> wRepeatedSet;
-	for (BYTE bSocketIndex = 0; bSocketIndex < ITEM_SOCKET_MAX_NUM; ++bSocketIndex)
-	{
-		const DWORD dwData = GetSocket(bSocketIndex);
-		if (dwData < 1000000)
-			continue;
-
-		const WORD wSocketApplyType = (dwData / 10000) % 1000;
-		if (std::find(vApplyTypes.begin(), vApplyTypes.end(), wSocketApplyType) != vApplyTypes.end())
-			wRepeatedSet.emplace(wSocketApplyType);
-	}
-
-	bool bCheckRepeat = true;
-	while (bCheckRepeat)
-	{
-		wApplyType = vApplyTypes[number(0, (vApplyTypes.size() - 1))];
-		if (wRepeatedSet.count(wApplyType) == 0)
-			bCheckRepeat = false;
-	}
-	// END_OF_DUPLICATE_APPLY_TYPE_FIX
-
-	long lValue = bDefaultValues[iRefineLevel];
-	if (lValue >= 100)
-	{
-		sys_err("CItem::GetRandomSungMaSocketValue:: ApplyValue %ld is too high to store in the socket data.", lValue);
-		return 0;
-	}
-
-	if (bMultiplier)
-		lValue *= 2;
-
-	DWORD dwData = (wApplyType * 10000) + (iRefineLevel * 1000) + (bType * 100) + lValue;
-	if (dwData >= LONG_MAX)
-	{
-		sys_err("CItem::GetRandomSungMaSocketValue:: Unsupported data!");
-		return 0;
-	}
-
-	return dwData;
-}
-#endif
-
-#ifdef __OFFLINE_SHOP__
-void CItem::CopySockets(std::array<int32_t, ITEM_SOCKET_MAX_NUM>& sockets)
-{
-	std::copy(std::begin(m_alSockets), std::end(m_alSockets), sockets.begin());
-}
-
-void CItem::CopyAttributes(std::array<TPlayerItemAttribute, ITEM_ATTRIBUTE_MAX_NUM>& attributes)
-{
-	std::copy(std::begin(m_aAttr), std::end(m_aAttr), attributes.begin());
-}
-
-#if defined(__ITEM_APPLY_RANDOM__)
-void CItem::CopyApplyRandom(std::array<TPlayerItemAttribute, ITEM_APPLY_MAX_NUM>& ApplyRandom)
-{
-	std::copy(std::begin(m_aApplyRandom), std::end(m_aApplyRandom), ApplyRandom.begin());
-}
-#endif
-#endif
+#include "stdafx.h"
+#include "utils.h"
+#include "config.h"
+#include "char.h"
+#include "desc.h"
+#include "sectree_manager.h"
+#include "packet.h"
+#include "protocol.h"
+#include "log.h"
+#include "skill.h"
+#include "unique_item.h"
+#include "profiler.h"
+#include "marriage.h"
+#include "item_addon.h"
+#include "dev_log.h"
+#include "locale_service.h"
+#include "item.h"
+#include "item_manager.h"
+#include "affect.h"
+#include "DragonSoul.h"
+#include "buff_on_attributes.h"
+#include "belt_inventory_helper.h"
+#include "../../common/VnumHelper.h"
+#include "mob_manager.h"
+#include "PetSystem.h"
+
+CItem::CItem(DWORD dwVnum)
+	: m_dwVnum(dwVnum), m_bWindow(0), m_dwID(0), m_bEquipped(false), m_dwVID(0), m_wCell(0), m_dwCount(0), m_lFlag(0), m_dwLastOwnerPID(0),
+	m_bExchanging(false), m_pkDestroyEvent(NULL), m_pkUniqueExpireEvent(NULL), m_pkTimerBasedOnWearExpireEvent(NULL), m_pkRealTimeExpireEvent(NULL),
+	m_pkExpireEvent(NULL),
+	m_pkAccessorySocketExpireEvent(NULL), m_pkOwnershipEvent(NULL), m_dwOwnershipPID(0), m_bSkipSave(false), m_isLocked(false),
+	m_dwMaskVnum(0), m_dwSIGVnum(0)
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	, m_dwTransmutationVnum(0)
+#endif
+#if defined(__SET_ITEM__)
+	, m_bSetValue(0)
+#endif
+#if defined(__SOUL_BIND_SYSTEM__)
+	, m_lSealDate(E_SEAL_DATE_DEFAULT_TIMESTAMP)
+	, m_pkSealDateExpireEvent(NULL)
+#endif
+#if defined(__SOUL_SYSTEM__)
+	, m_pkSoulTimerUseEvent(nullptr)
+#endif
+{
+	memset(&m_alSockets, 0, sizeof(m_alSockets));
+	memset(&m_aAttr, 0, sizeof(m_aAttr));
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	memset(&m_RefineElement, 0, sizeof(m_RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	memset(&m_aApplyRandom, 0, sizeof(m_aApplyRandom));
+#endif
+}
+
+CItem::~CItem()
+{
+	Destroy();
+}
+
+void CItem::Initialize()
+{
+	CEntity::Initialize(ENTITY_ITEM);
+
+	m_bWindow = RESERVED_WINDOW;
+	m_pOwner = NULL;
+	m_bEquipped = false;
+	m_dwID = m_dwVID = m_dwCount = 0;
+	m_wCell = 0;
+	m_lFlag = 0;
+	m_pProto = NULL;
+	m_bExchanging = false;
+	memset(&m_alSockets, 0, sizeof(m_alSockets));
+	memset(&m_aAttr, 0, sizeof(m_aAttr));
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	memset(&m_RefineElement, 0, sizeof(m_RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	memset(&m_aApplyRandom, 0, sizeof(m_aApplyRandom));
+#endif
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	m_lSealDate = 0;
+	m_pkSealDateExpireEvent = NULL;
+#endif
+
+	m_pkDestroyEvent = NULL;
+	m_pkOwnershipEvent = NULL;
+	m_dwOwnershipPID = 0;
+	m_pkUniqueExpireEvent = NULL;
+	m_pkTimerBasedOnWearExpireEvent = NULL;
+	m_pkRealTimeExpireEvent = NULL;
+
+	m_pkAccessorySocketExpireEvent = NULL;
+#if defined(__SOUL_SYSTEM__)
+	m_pkSoulTimerUseEvent = NULL;
+#endif
+
+	m_bSkipSave = false;
+	m_dwLastOwnerPID = 0;
+}
+
+void CItem::Destroy()
+{
+	event_cancel(&m_pkDestroyEvent);
+	event_cancel(&m_pkOwnershipEvent);
+	event_cancel(&m_pkUniqueExpireEvent);
+	event_cancel(&m_pkTimerBasedOnWearExpireEvent);
+	event_cancel(&m_pkRealTimeExpireEvent);
+	event_cancel(&m_pkAccessorySocketExpireEvent);
+#if defined(__SOUL_BIND_SYSTEM__)
+	event_cancel(&m_pkSealDateExpireEvent);
+#endif
+#if defined(__SOUL_SYSTEM__)
+	event_cancel(&m_pkSoulTimerUseEvent);
+#endif
+
+	CEntity::Destroy();
+
+	if (GetSectree())
+		GetSectree()->RemoveEntity(this);
+}
+
+EVENTFUNC(item_destroy_event)
+{
+	item_event_info* info = dynamic_cast<item_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("item_destroy_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPITEM pkItem = info->item;
+
+	if (pkItem->GetOwner())
+		sys_err("item_destroy_event: Owner exist. (item %s owner %s)", pkItem->GetName(), pkItem->GetOwner()->GetName());
+
+	pkItem->SetDestroyEvent(NULL);
+	M2_DESTROY_ITEM(pkItem);
+	return 0;
+}
+
+void CItem::SetDestroyEvent(LPEVENT pkEvent)
+{
+	m_pkDestroyEvent = pkEvent;
+}
+
+void CItem::StartDestroyEvent(int iSec)
+{
+	if (m_pkDestroyEvent)
+		return;
+
+	item_event_info* info = AllocEventInfo<item_event_info>();
+	info->item = this;
+
+	SetDestroyEvent(event_create(item_destroy_event, info, PASSES_PER_SEC(iSec)));
+}
+
+void CItem::EncodeInsertPacket(LPENTITY ent)
+{
+	LPDESC d;
+
+	if (!(d = ent->GetDesc()))
+		return;
+
+	const PIXEL_POSITION& c_pos = GetXYZ();
+
+	struct packet_item_ground_add pack;
+
+	pack.bHeader = HEADER_GC_ITEM_GROUND_ADD;
+	pack.lX = c_pos.x;
+	pack.lY = c_pos.y;
+	pack.lZ = c_pos.z;
+	pack.dwVID = m_dwVID;
+	pack.dwVnum = GetVnum();
+#if defined(__SET_ITEM__)
+	pack.bSetValue = GetItemSetValue();
+#endif
+
+#if defined(__ITEM_DROP_RENEWAL__)
+	for (size_t i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+		pack.alSockets[i] = GetSocket(i);
+
+	thecore_memcpy(pack.aAttrs, GetAttributes(), sizeof(pack.aAttrs));
+#endif
+
+	d->Packet(&pack, sizeof(pack));
+
+	if (m_pkOwnershipEvent != NULL)
+	{
+		item_event_info* info = dynamic_cast<item_event_info*>(m_pkOwnershipEvent->info);
+
+		if (info == NULL)
+		{
+			sys_err("CItem::EncodeInsertPacket> <Factor> Null pointer");
+			return;
+		}
+
+		TPacketGCItemOwnership p;
+
+		p.bHeader = HEADER_GC_ITEM_OWNERSHIP;
+		p.dwVID = m_dwVID;
+		strlcpy(p.szName, info->szOwnerName, sizeof(p.szName));
+
+		d->Packet(&p, sizeof(TPacketGCItemOwnership));
+	}
+}
+
+void CItem::EncodeRemovePacket(LPENTITY ent)
+{
+	LPDESC d;
+
+	if (!(d = ent->GetDesc()))
+		return;
+
+	struct packet_item_ground_del pack;
+
+	pack.bHeader = HEADER_GC_ITEM_GROUND_DEL;
+	pack.dwVID = m_dwVID;
+
+	d->Packet(&pack, sizeof(pack));
+	sys_log(2, "Item::EncodeRemovePacket %s to %s", GetName(), ((LPCHARACTER)ent)->GetName());
+}
+
+void CItem::SetProto(const TItemTable* table)
+{
+	assert(table != NULL);
+	m_pProto = table;
+	SetFlag(m_pProto->dwFlags);
+}
+
+void CItem::UsePacketEncode(LPCHARACTER ch, LPCHARACTER victim, struct packet_item_use* packet)
+{
+	if (!GetVnum())
+		return;
+
+	packet->header = HEADER_GC_ITEM_USE;
+	packet->ch_vid = ch->GetVID();
+	packet->victim_vid = victim->GetVID();
+	packet->Cell = TItemPos(GetWindow(), m_wCell);
+	packet->vnum = GetVnum();
+}
+
+void CItem::RemoveFlag(long bit)
+{
+	REMOVE_BIT(m_lFlag, bit);
+}
+
+void CItem::AddFlag(long bit)
+{
+	SET_BIT(m_lFlag, bit);
+}
+
+void CItem::UpdatePacket()
+{
+	if (!m_pOwner || !m_pOwner->GetDesc())
+		return;
+
+	TPacketGCItemUpdate pack;
+
+	pack.bHeader = HEADER_GC_ITEM_UPDATE;
+	pack.Cell = TItemPos(GetWindow(), m_wCell);
+	pack.dwCount = m_dwCount;
+#if defined(__SOUL_BIND_SYSTEM__)
+	pack.lSealDate = m_lSealDate;
+#endif
+	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+		pack.alSockets[i] = m_alSockets[i];
+	thecore_memcpy(pack.aAttr, GetAttributes(), sizeof(pack.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	pack.dwTransmutationVnum = GetTransmutationVnum();
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	thecore_memcpy(&pack.RefineElement, GetRefineElement(), sizeof(pack.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	thecore_memcpy(pack.aApplyRandom, GetRandomApplies(), sizeof(pack.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+	pack.bSetValue = GetItemSetValue();
+#endif
+
+	sys_log(2, "UpdatePacket %s -> %s", GetName(), m_pOwner->GetName());
+	m_pOwner->GetDesc()->Packet(&pack, sizeof(pack));
+}
+
+DWORD CItem::GetCount()
+{
+	if (GetType() == ITEM_ELK)
+		return MIN(m_dwCount, LONG_MAX);
+	else
+		return MIN(m_dwCount, ITEM_MAX_COUNT);
+}
+
+bool CItem::SetCount(DWORD count)
+{
+	if (GetType() == ITEM_ELK)
+	{
+		m_dwCount = MIN(count, LONG_MAX);
+	}
+	else
+	{
+		m_dwCount = MIN(count, ITEM_MAX_COUNT);
+	}
+
+	if (count == 0 && m_pOwner)
+	{
+		if (GetSubType() == USE_ABILITY_UP || GetSubType() == USE_POTION)
+		{
+			LPCHARACTER pOwner = GetOwner();
+			BYTE bWindow = GetWindow();
+			WORD wCell = GetCell();
+
+			RemoveFromCharacter();
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			if (!IsDragonSoul())
+#endif
+			{
+				LPITEM pItem = pOwner->FindSpecifyItem(GetVnum());
+
+				if (NULL != pItem)
+				{
+					if (bWindow == INVENTORY)
+						pOwner->ChainQuickslotItem(pItem, SLOT_TYPE_INVENTORY, wCell);
+					else if (bWindow == BELT_INVENTORY)
+						pOwner->SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, wCell, WORD_MAX);
+				}
+				else
+				{
+					if (bWindow == INVENTORY)
+						pOwner->SyncQuickslot(SLOT_TYPE_INVENTORY, wCell, WORD_MAX);
+					else if (bWindow == BELT_INVENTORY)
+						pOwner->SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, wCell, WORD_MAX);
+				}
+			}
+
+			M2_DESTROY_ITEM(this);
+		}
+		else
+		{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			if (!IsDragonSoul())
+				m_pOwner->SyncQuickslot(SLOT_TYPE_INVENTORY, m_wCell, WORD_MAX);
+#else
+			m_pOwner->SyncQuickslot(SLOT_TYPE_INVENTORY, m_wCell, WORD_MAX);
+#endif
+			M2_DESTROY_ITEM(RemoveFromCharacter());
+		}
+
+		return false;
+	}
+
+	UpdatePacket();
+
+	Save();
+	return true;
+}
+
+#if defined(__SOUL_BIND_SYSTEM__)
+bool CItem::CanSealItem() const
+{
+	switch (GetType())
+	{
+		case ITEM_WEAPON:
+		{
+			switch (GetSubType())
+			{
+				case WEAPON_ARROW:
+				case WEAPON_MOUNT_SPEAR:
+#if defined(__QUIVER_SYSTEM__)
+				case WEAPON_QUIVER:
+#endif
+					//case WEAPON_BOUQUET:
+					return false;
+				default:
+					return true;
+			}
+		}
+
+		case ITEM_COSTUME:
+		{
+			switch (GetSubType())
+			{
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+				case COSTUME_MOUNT:
+#endif
+					return false;
+				default:
+					return true;
+			}
+		}
+
+		case ITEM_ARMOR:
+		case ITEM_BELT:
+			return true;
+
+#if defined(__DRAGON_SOUL_SYSTEM__) && defined(__DRAGON_SOUL_SEAL__)
+		case ITEM_DS:
+		{
+			const BYTE bGradeIdx = (GetVnum() / 1000) % 10;
+			if (bGradeIdx >= DRAGON_SOUL_GRADE_ANCIENT)
+				return true;
+
+			return false;
+		}
+#endif
+
+		default:
+			return false;
+	}
+
+	return false;
+}
+
+EVENTFUNC(SealDateExpireEvent)
+{
+	const item_vid_event_info* info = reinterpret_cast<const item_vid_event_info*>(event->info);
+	if (!info)
+		return 0;
+
+	const LPITEM item = ITEM_MANAGER::instance().FindByVID(info->item_vid);
+	if (!item)
+		return 0;
+
+	const time_t cur = get_global_time();
+	if (cur > item->GetSealDate())
+	{
+		item->SealItem(E_SEAL_DATE_DEFAULT_TIMESTAMP);
+		item->StopSealDateExpireTimerEvent();
+		return 0;
+	}
+
+	return PASSES_PER_SEC(1);
+}
+
+void CItem::SealItem(long lSealDate)
+{
+	m_lSealDate = lSealDate;
+	UpdatePacket();
+	Save();
+}
+
+void CItem::StartSealDateExpireTimerEvent()
+{
+	if (m_pkSealDateExpireEvent)
+		return;
+
+	item_vid_event_info* info = AllocEventInfo<item_vid_event_info>();
+	info->item_vid = GetVID();
+
+	m_pkSealDateExpireEvent = event_create(SealDateExpireEvent, info, PASSES_PER_SEC(1));
+	sys_log(0, "SEAL_DATE_TIME_EXPIRE: StartSealDateExpireTimerEvent");
+}
+
+void CItem::StopSealDateExpireTimerEvent()
+{
+	if (m_pkSealDateExpireEvent)
+		event_cancel(&m_pkSealDateExpireEvent);
+
+	sys_log(0, "SEAL_DATE_TIME_EXPIRE: StopSealDateExpireTimerEvent");
+}
+#endif
+
+LPITEM CItem::RemoveFromCharacter()
+{
+	if (!m_pOwner)
+	{
+		sys_err("Item::RemoveFromCharacter owner null");
+		return this;
+	}
+
+	LPCHARACTER pOwner = m_pOwner;
+	if (!pOwner)
+	{
+		sys_err("Item::RemoveFromCharacter owner null");
+		return this;
+	}
+
+	if (m_bEquipped) // 퓸째?
+	{
+		Unequip();
+		//pOwner->UpdatePacket();
+
+		SetWindow(RESERVED_WINDOW);
+		Save();
+		return this;
+	}
+	else
+	{
+		if (GetWindow() != SAFEBOX && GetWindow() != MALL
+#if defined(__ATTR_6TH_7TH__)
+			&& GetWindow() != NPC_STORAGE
+#endif
+			)
+		{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			if (IsDragonSoul())
+			{
+				if (m_wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+					sys_err("CItem::RemoveFromCharacter: pos >= DRAGON_SOUL_INVENTORY_MAX_NUM");
+				else
+					pOwner->SetItem(TItemPos(m_bWindow, m_wCell), NULL);
+			}
+			else if (GetWindow() == EQUIPMENT)
+#else
+			if (GetWindow() == EQUIPMENT)
+#endif
+			{
+				if (m_wCell >= EQUIPMENT_MAX_NUM)
+					sys_err("CItem::RemoveFromCharacter: pos >= EQUIPMENT_MAX_NUM");
+				else
+					pOwner->SetItem(TItemPos(m_bWindow, m_wCell), nullptr);
+			}
+			else if (GetWindow() == BELT_INVENTORY)
+			{
+				if (m_wCell >= BELT_INVENTORY_MAX_NUM)
+					sys_err("CItem::RemoveFromCharacter: pos >= BELT_INVENTORY_MAX_NUM");
+				else
+					pOwner->SetItem(TItemPos(m_bWindow, m_wCell), nullptr);
+			}
+			else
+			{
+				const TItemPos cell(INVENTORY, m_wCell);
+
+				if (cell.IsInventoryPosition() == false && cell.IsBeltInventoryPosition() == false) // 틈玖 품?
+				{
+					sys_err("CItem::RemoveFromCharacter: Invalid Item Position");
+				}
+				else
+				{
+					pOwner->SetItem(cell, nullptr);
+				}
+			}
+		}
+
+#if defined(__ATTR_6TH_7TH__)
+		else if (GetWindow() == NPC_STORAGE)
+			pOwner->SetItem(TItemPos(NPC_STORAGE, 0), nullptr);
+#endif
+
+		m_pOwner = nullptr;
+		m_wCell = 0;
+
+		SetWindow(RESERVED_WINDOW);
+		Save();
+		return this;
+	}
+}
+
+bool CItem::AddToCharacter(LPCHARACTER ch, const TItemPos& Cell
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+	, bool isHighLight
+#endif
+)
+{
+	assert(GetSectree() == NULL);
+	assert(m_pOwner == NULL);
+
+	BYTE bWindowType = Cell.window_type;
+	WORD wCell = Cell.cell;
+
+	switch (bWindowType)
+	{
+		case INVENTORY:
+		{
+#if defined(__EXTEND_INVEN_SYSTEM__)
+			if (m_wCell >= ch->GetExtendInvenMax())
+#else
+			if (m_wCell >= INVENTORY_MAX_NUM)
+#endif
+			{
+				sys_err("CItem::AddToCharacter: cell overflow: %s to %s cell %d", m_pProto->szName, ch->GetName(), m_wCell);
+				return false;
+			}
+		}
+		break;
+
+		case EQUIPMENT:
+		{
+			if (m_wCell >= EQUIPMENT_MAX_NUM)
+			{
+				sys_err("CItem::AddToCharacter: cell overflow: %s to %s cell %d", m_pProto->szName, ch->GetName(), m_wCell);
+				return false;
+			}
+		}
+		break;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case DRAGON_SOUL_INVENTORY:
+		{
+			if (m_wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+			{
+				sys_err("CItem::AddToCharacter: cell overflow: %s to %s cell %d", m_pProto->szName, ch->GetName(), m_wCell);
+				return false;
+			}
+		}
+		break;
+#endif
+
+		case BELT_INVENTORY:
+		{
+			if (m_wCell >= BELT_INVENTORY_SLOT_COUNT)
+			{
+				sys_err("CItem::AddToCharacter: cell overflow: %s to %s cell %d", m_pProto->szName, ch->GetName(), m_wCell);
+				return false;
+			}
+		}
+		break;
+	}
+
+	if (ch->GetDesc())
+		m_dwLastOwnerPID = ch->GetPlayerID();
+
+	event_cancel(&m_pkDestroyEvent);
+
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+	ch->SetItem(TItemPos(bWindowType, wCell), this, isHighLight);
+#else
+	ch->SetItem(TItemPos(bWindowType, wCell), this);
+#endif
+	m_pOwner = ch;
+
+	Save();
+	return true;
+}
+
+LPITEM CItem::RemoveFromGround()
+{
+	if (GetSectree())
+	{
+		SetOwnership(NULL);
+
+		GetSectree()->RemoveEntity(this);
+
+		ViewCleanup();
+
+		Save();
+	}
+
+	return (this);
+}
+
+bool CItem::AddToGround(long lMapIndex, const PIXEL_POSITION& pos, bool skipOwnerCheck)
+{
+	if (0 == lMapIndex)
+	{
+		sys_err("wrong map index argument: %d", lMapIndex);
+		return false;
+	}
+
+	if (GetSectree())
+	{
+		sys_err("sectree already assigned");
+		return false;
+	}
+
+	if (!skipOwnerCheck && m_pOwner)
+	{
+		sys_err("owner pointer not null");
+		return false;
+	}
+
+	LPSECTREE tree = SECTREE_MANAGER::instance().Get(lMapIndex, pos.x, pos.y);
+
+	if (!tree)
+	{
+		sys_err("cannot find sectree by %dx%d", pos.x, pos.y);
+		return false;
+	}
+
+	//tree->Touch();
+
+	SetWindow(GROUND);
+	SetXYZ(pos.x, pos.y, pos.z);
+	tree->InsertEntity(this);
+	UpdateSectree();
+	Save();
+	return true;
+}
+
+bool CItem::DistanceValid(LPCHARACTER ch)
+{
+	if (!GetSectree())
+		return false;
+
+	int iDist = DISTANCE_APPROX(GetX() - ch->GetX(), GetY() - ch->GetY());
+
+	if (iDist > 300)
+		return false;
+
+	return true;
+}
+
+bool CItem::CanUsedBy(LPCHARACTER ch)
+{
+	// Anti flag check
+	switch (ch->GetJob())
+	{
+		case JOB_WARRIOR:
+			if (GetAntiFlag() & ITEM_ANTIFLAG_WARRIOR)
+				return false;
+			break;
+
+		case JOB_ASSASSIN:
+			if (GetAntiFlag() & ITEM_ANTIFLAG_ASSASSIN)
+				return false;
+			break;
+
+		case JOB_SHAMAN:
+			if (GetAntiFlag() & ITEM_ANTIFLAG_SHAMAN)
+				return false;
+			break;
+
+		case JOB_SURA:
+			if (GetAntiFlag() & ITEM_ANTIFLAG_SURA)
+				return false;
+			break;
+
+		case JOB_WOLFMAN:
+			if (GetAntiFlag() & ITEM_ANTIFLAG_WOLFMAN)
+				return false;
+			break;
+
+	}
+
+	return true;
+}
+
+int CItem::FindEquipCell(LPCHARACTER ch, int iCandidateCell)
+{
+	// 黴 (ITEM_COSTUME) WearFlag 諍 . (sub type 치 .   wear flag  却娥 簾..)
+	// 혼(ITEM_DS, ITEM_SPECIAL_DS) SUB_TYPE . 킥 , 트 ITEM_TYPE  -_-
+	if ((0 == GetWearFlag() || ITEM_TOTEM == GetType()) && ITEM_COSTUME != GetType()
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		&& ITEM_DS != GetType() && ITEM_SPECIAL_DS != GetType()
+#endif
+		&& ITEM_RING != GetType() && ITEM_BELT != GetType()
+		)
+		return -1;
+
+	// 혼  WEAR 처  底(WEAR 獵 32 祁 혼 煞玖 32 磯쨈.)
+	// 觀訝 특 치((INVENTORY_MAX_NUM + WEAR_MAX_NUM) (INVENTORY_MAX_NUM + WEAR_MAX_NUM + DRAGON_SOUL_DECK_MAX_NUM * DS_SLOT_MAX - 1))
+	// 혼  .
+	// return  , INVENTORY_MAX_NUM  ,
+	//  WearCell INVENTORY_MAX_NUM  return 歐 .
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (GetType() == ITEM_DS || GetType() == ITEM_SPECIAL_DS)
+	{
+		if (iCandidateCell < 0)
+		{
+			return WEAR_MAX_NUM + GetSubType();
+		}
+
+		for (int i = 0; i < DRAGON_SOUL_DECK_MAX_NUM; i++)
+		{
+			if (WEAR_MAX_NUM + i * DS_SLOT_MAX + GetSubType() == iCandidateCell)
+			{
+				return iCandidateCell;
+			}
+		}
+		return -1;
+	}
+#endif
+
+	if (GetType() == ITEM_COSTUME)
+	{
+		switch (GetSubType())
+		{
+			case COSTUME_BODY:
+				return WEAR_COSTUME_BODY;
+			case COSTUME_HAIR:
+				return WEAR_COSTUME_HAIR;
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+			case COSTUME_MOUNT:
+				return WEAR_COSTUME_MOUNT;
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+			case COSTUME_ACCE:
+				return WEAR_COSTUME_ACCE;
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+			case COSTUME_WEAPON:
+				return WEAR_COSTUME_WEAPON;
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+			case COSTUME_AURA:
+				return WEAR_COSTUME_AURA;
+#endif
+		}
+	}
+
+	else if (GetWearFlag() & WEARABLE_BODY)
+		return WEAR_BODY;
+	else if (GetWearFlag() & WEARABLE_HEAD)
+		return WEAR_HEAD;
+	else if (GetWearFlag() & WEARABLE_FOOTS)
+		return WEAR_FOOTS;
+	else if (GetWearFlag() & WEARABLE_WRIST)
+		return WEAR_WRIST;
+	else if (GetWearFlag() & WEARABLE_WEAPON)
+		return WEAR_WEAPON;
+	else if (GetWearFlag() & WEARABLE_NECK)
+		return WEAR_NECK;
+	else if (GetWearFlag() & WEARABLE_EAR)
+		return WEAR_EAR;
+	else if (GetWearFlag() & WEARABLE_UNIQUE)
+	{
+		if (ch->GetWear(WEAR_UNIQUE1))
+			return WEAR_UNIQUE2;
+		else
+			return WEAR_UNIQUE1;
+	}
+	else if (GetWearFlag() & WEARABLE_SHIELD)
+		return WEAR_SHIELD;
+	else if (GetWearFlag() & WEARABLE_ARROW)
+		return WEAR_ARROW;
+	else if (GetType() == ITEM_BELT)
+		return WEAR_BELT;
+#if defined(__PENDANT_SYSTEM__)
+	else if (GetWearFlag() & WEARABLE_PENDANT)
+		return WEAR_PENDANT;
+#endif
+#if defined(__GLOVE_SYSTEM__)
+	else if (GetWearFlag() & WEARABLE_GLOVE)
+		return WEAR_GLOVE;
+#endif
+
+	return -1;
+}
+
+//#define __CHECK_MODIFY_POINTS_PERF__
+
+void CItem::ModifyPoints(bool bAdd)
+{
+#if defined(__CHECK_MODIFY_POINTS_PERF__)
+	auto _modify_s1 = std::chrono::steady_clock::now();
+#endif
+
+	BYTE bAccessoryGrade = 0;
+
+	//  訶  킨.
+	if (!IsAccessoryForSocket())
+	{
+#if defined(__QUIVER_SYSTEM__)
+		if ((m_pProto->bType == ITEM_WEAPON && m_pProto->bSubType != WEAPON_QUIVER) || m_pProto->bType == ITEM_ARMOR)
+#else
+		if (m_pProto->bType == ITEM_WEAPON || m_pProto->bType == ITEM_ARMOR)
+#endif
+		{
+#if defined(__CHECK_MODIFY_POINTS_PERF__)
+			auto _accessory_s1 = std::chrono::steady_clock::now();
+#endif
+			//  憺화 풔   苛쨈 (ARMOR_WRIST ARMOR_NECK ARMOR_EAR ARMOR_GLOVE)
+			for (BYTE bSocketIndex = 0; bSocketIndex < METIN_SOCKET_MAX_NUM; ++bSocketIndex)
+			{
+#if defined(__GLOVE_SYSTEM__)
+				if (m_pProto->bType == ITEM_ARMOR && m_pProto->bSubType == ARMOR_GLOVE)
+				{
+					const DWORD dwData = GetSocket(bSocketIndex);
+					if (dwData < 1000000)
+						continue;
+
+					const WORD wType = (dwData / 10000) % 1000;
+					if (wType == APPLY_NONE)
+						continue;
+
+					const long lValue = dwData % 100;
+					m_pOwner->ApplyPoint(wType, (bAdd) ? lValue : -lValue);
+				}
+				else
+#endif
+				{
+					const DWORD dwVnum = GetSocket(bSocketIndex);
+					if (dwVnum <= 2)
+						continue;
+
+					const TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwVnum);
+					if (pItemTable == nullptr)
+					{
+						sys_err("cannot find table by vnum %lu", dwVnum);
+						continue;
+					}
+
+					if (ITEM_METIN == pItemTable->bType
+#if defined(__GLOVE_SYSTEM__)
+						&& pItemTable->bSubType != METIN_SUNGMA
+#endif
+						)
+					{
+						for (BYTE bApplyIndex = 0; bApplyIndex < ITEM_APPLY_MAX_NUM; ++bApplyIndex)
+						{
+							if (pItemTable->aApplies[bApplyIndex].wType == APPLY_NONE)
+								continue;
+
+							if (pItemTable->aApplies[bApplyIndex].wType == APPLY_SKILL)
+								m_pOwner->ApplyPoint(pItemTable->aApplies[bApplyIndex].wType,
+									(bAdd) ? pItemTable->aApplies[bApplyIndex].lValue : pItemTable->aApplies[bApplyIndex].lValue ^ 0x00800000);
+							else
+								m_pOwner->ApplyPoint(pItemTable->aApplies[bApplyIndex].wType,
+									(bAdd) ? pItemTable->aApplies[bApplyIndex].lValue : -pItemTable->aApplies[bApplyIndex].lValue);
+						}
+					}
+				}
+			}
+#if defined(__CHECK_MODIFY_POINTS_PERF__)
+			auto _accessory_e1 = std::chrono::steady_clock::now();
+			auto _accessory_d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(_accessory_e1 - _accessory_s1).count();
+			m_pOwner->ChatPacket(CHAT_TYPE_INFO, "!IsAccessoryForSocket() took %lld nanoseconds.", static_cast<long long>(_accessory_d1));
+#endif
+		}
+
+		bAccessoryGrade = 0;
+	}
+	else
+	{
+		bAccessoryGrade = static_cast<BYTE>(MIN(GetAccessorySocketGrade(), ITEM_ACCESSORY_SOCKET_MAX_NUM));
+	}
+
+#if defined(__CHECK_MODIFY_POINTS_PERF__)
+	auto _apply_s1 = std::chrono::steady_clock::now();
+#endif
+	for (BYTE bApplyIndex = 0; bApplyIndex < ITEM_APPLY_MAX_NUM; ++bApplyIndex)
+	{
+		if (m_pProto->aApplies[bApplyIndex].wType == APPLY_NONE)
+			continue;
+
+		long lValue = m_pProto->aApplies[bApplyIndex].lValue;
+		if (m_pProto->aApplies[bApplyIndex].wType == APPLY_SKILL)
+		{
+			m_pOwner->ApplyPoint(m_pProto->aApplies[bApplyIndex].wType, bAdd ? lValue : lValue ^ 0x00800000);
+		}
+#if defined(__ITEM_APPLY_RANDOM__)
+		else if (m_pProto->aApplies[bApplyIndex].wType == APPLY_RANDOM && GetRandomApplyType(bApplyIndex))
+		{
+			const TPlayerItemAttribute& rItemApplyRandom = GetRandomApply(bApplyIndex);
+			lValue = rItemApplyRandom.lValue;
+
+			if (rItemApplyRandom.wType == APPLY_SKILL)
+			{
+				m_pOwner->ApplyPoint(rItemApplyRandom.wType, bAdd ? lValue : lValue ^ 0x00800000);
+			}
+			else
+			{
+				if (0 != bAccessoryGrade)
+					lValue += MAX(bAccessoryGrade, lValue * aiAccessorySocketEffectivePct[bAccessoryGrade] / 100);
+
+				m_pOwner->ApplyPoint(rItemApplyRandom.wType, bAdd ? lValue : -lValue);
+			}
+		}
+#endif
+		else
+		{
+			if (0 != bAccessoryGrade)
+				lValue += MAX(bAccessoryGrade, lValue * aiAccessorySocketEffectivePct[bAccessoryGrade] / 100);
+
+			m_pOwner->ApplyPoint(m_pProto->aApplies[bApplyIndex].wType, bAdd ? lValue : -lValue);
+		}
+	}
+
+#if defined(__CHECK_MODIFY_POINTS_PERF__)
+	auto _apply_e1 = std::chrono::steady_clock::now();
+	auto _apply_d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(_apply_e1 - _apply_s1).count();
+	m_pOwner->ChatPacket(CHAT_TYPE_INFO, "Item applies took %lld nanoseconds.", static_cast<long long>(_apply_d1));
+#endif
+
+#if defined(__CHECK_MODIFY_POINTS_PERF__)
+	auto _acce_s1 = std::chrono::steady_clock::now();
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	if (m_pProto->bType == ITEM_COSTUME && m_pProto->bSubType == COSTUME_ACCE)
+		m_pOwner->ModifyAccePoints(this, bAdd);
+#endif
+#if defined(__CHECK_MODIFY_POINTS_PERF__)
+	auto _acce_e1 = std::chrono::steady_clock::now();
+	auto _acce_d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(_acce_e1 - _acce_s1).count();
+	m_pOwner->ChatPacket(CHAT_TYPE_INFO, "ModifyAccePoints %lld nanoseconds.", static_cast<long long>(_acce_d1));
+#endif
+
+#if defined(__CHECK_MODIFY_POINTS_PERF__)
+	auto _aura_s1 = std::chrono::steady_clock::now();
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	if (m_pProto->bType == ITEM_COSTUME && m_pProto->bSubType == COSTUME_AURA)
+		m_pOwner->ModifyAuraPoints(this, bAdd);
+#endif
+#if defined(__CHECK_MODIFY_POINTS_PERF__)
+	auto _aura_e1 = std::chrono::steady_clock::now();
+	auto _aura_d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(_aura_e1 - _aura_s1).count();
+	m_pOwner->ChatPacket(CHAT_TYPE_INFO, "ModifyAuraPoints %lld nanoseconds.", static_cast<long long>(_aura_d1));
+#endif
+
+	// 駕쨈 , 念 , 僊 ,   트 
+	//  溝 湄  憺 恝,
+	//  觀 構 special item group 遣 憺 恝溝 臼.
+	//  溝 湄퓸      羚底 특처 卍쨈.
+	//  滂 , 萬 ITEM_UNIQUE  처 憺 恝풉 ,
+	// 謗 獵 attribute  歌 耭載.
+	//if (true == CItemVnumHelper::IsRamadanMoonRing(GetVnum()) || true == CItemVnumHelper::IsHalloweenCandy(GetVnum())
+		//|| true == CItemVnumHelper::IsHappinessRing(GetVnum()) || true == CItemVnumHelper::IsLovePendant(GetVnum()))
+	if (CItemVnumHelper::IsUniqueItem(GetVnum()))
+	{
+		// Do not anything.
+	}
+	else
+	{
+#if defined(__CHECK_MODIFY_POINTS_PERF__)
+		auto _attr_s1 = std::chrono::steady_clock::now();
+#endif
+		for (BYTE bAttrIndex = 0; bAttrIndex < ITEM_ATTRIBUTE_MAX_NUM; ++bAttrIndex)
+		{
+#if defined(__ACCE_COSTUME_SYSTEM__)
+			if (GetType() == ITEM_COSTUME && GetSubType() == COSTUME_ACCE)
+				break; // Modifying at @ ModifyAccePoints
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+			if (GetType() == ITEM_COSTUME && GetSubType() == COSTUME_AURA)
+				break; // Modifying at @ ModifyAuraPoints
+#endif
+
+			if (GetAttributeType(bAttrIndex))
+			{
+				const TPlayerItemAttribute& rItemAttribute = GetAttribute(bAttrIndex);
+#if defined(__DRAGON_SOUL_SYSTEM__) && defined(__DS_SET__)
+				long lValue = rItemAttribute.lValue;
+				if (IsDragonSoul() && m_pOwner->FindAffect(AFFECT_DS_SET))
+				{
+					if (bAttrIndex < DSManager::instance().GetApplyCount(GetVnum()))
+					{
+						lValue += DSManager::instance().GetBasicApplyValue(GetVnum(), rItemAttribute.wType, true);
+					}
+					else
+					{
+						lValue += DSManager::instance().GetAdditionalApplyValue(GetVnum(), rItemAttribute.wType, true);
+					}
+				}
+
+				if (rItemAttribute.wType == APPLY_SKILL)
+					m_pOwner->ApplyPoint(rItemAttribute.wType, bAdd ? lValue : lValue ^ 0x00800000);
+				else
+					m_pOwner->ApplyPoint(rItemAttribute.wType, bAdd ? lValue : -lValue);
+#else
+				if (rItemAttribute.wType == APPLY_SKILL)
+					m_pOwner->ApplyPoint(rItemAttribute.wType, bAdd ? rItemAttribute.lValue : rItemAttribute.lValue ^ 0x00800000);
+				else
+					m_pOwner->ApplyPoint(rItemAttribute.wType, bAdd ? rItemAttribute.lValue : -rItemAttribute.lValue);
+#endif
+			}
+		}
+#if defined(__CHECK_MODIFY_POINTS_PERF__)
+		auto _attr_e1 = std::chrono::steady_clock::now();
+		auto _attr_d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(_attr_e1 - _attr_s1).count();
+		m_pOwner->ChatPacket(CHAT_TYPE_INFO, "Item attributes took % lld nanoseconds.", static_cast<long long>(_attr_d1));
+#endif
+	}
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	if (m_pProto->bType == ITEM_WEAPON && GetRefineElementGrade() != 0)
+	{
+		const long lValue = static_cast<long>(GetRefineElementValue());
+		if (lValue > 0)
+			m_pOwner->ApplyPoint(GetRefineElementApplyType(), bAdd ? lValue : -lValue);
+
+		const long lBonusValue = static_cast<long>(GetRefineElementBonusValue());
+		if (lBonusValue > 0)
+			m_pOwner->ApplyPoint(APPLY_ATT_GRADE_BONUS, bAdd ? lBonusValue : -lBonusValue);
+	}
+#endif
+
+	switch (m_pProto->bType)
+	{
+		case ITEM_PICK:
+		case ITEM_ROD:
+		{
+			if (bAdd)
+			{
+				if (m_wCell == WEAR_WEAPON)
+					m_pOwner->SetPart(PART_WEAPON, GetVnum());
+			}
+			else
+			{
+				if (m_wCell == WEAR_WEAPON)
+					m_pOwner->SetPart(PART_WEAPON, m_pOwner->GetOriginalPart(PART_WEAPON));
+			}
+		}
+		break;
+
+		case ITEM_WEAPON:
+		{
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+			// 黴 body 蹈獵摸 armor  都   羚  寧  .
+			if (m_pOwner->GetWear(WEAR_COSTUME_WEAPON) != 0)
+			{
+#if defined(__HIDE_WEAPON_COSTUME_WITH_NO_MAIN_WEAPON__)
+				m_pOwner->SetPart(PART_WEAPON, m_pOwner->GetWear(WEAR_COSTUME_WEAPON)->GetVnum());
+#endif
+				return;
+			}
+#endif
+
+			if (bAdd)
+			{
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				if (m_wCell == WEAR_WEAPON)
+					m_pOwner->SetPart(PART_WEAPON, (GetTransmutationVnum() != 0) ? GetTransmutationVnum() : GetVnum());
+#else
+				if (m_wCell == WEAR_WEAPON)
+					m_pOwner->SetPart(PART_WEAPON, GetVnum());
+#endif
+			}
+			else
+			{
+				if (m_wCell == WEAR_WEAPON)
+					m_pOwner->SetPart(PART_WEAPON, m_pOwner->GetOriginalPart(PART_WEAPON));
+			}
+		}
+		break;
+
+		case ITEM_ARMOR:
+		{
+#if defined(__COSTUME_SYSTEM__)
+			// 黴 body 蹈獵摸 armor  都   羚  寧  .
+			if (m_pOwner->GetWear(WEAR_COSTUME_BODY) != 0)
+				break;
+#endif
+
+			if (GetSubType() == ARMOR_BODY || GetSubType() == ARMOR_HEAD || GetSubType() == ARMOR_FOOTS || GetSubType() == ARMOR_SHIELD)
+			{
+				if (bAdd)
+				{
+#if defined(__CHANGE_LOOK_SYSTEM__)
+					if (GetProto()->bSubType == ARMOR_BODY)
+						m_pOwner->SetPart(PART_MAIN, (GetTransmutationVnum() != 0) ? GetTransmutationVnum() : GetVnum());
+#else
+					if (GetProto()->bSubType == ARMOR_BODY)
+						m_pOwner->SetPart(PART_MAIN, GetVnum());
+#endif
+				}
+				else
+				{
+					if (GetProto()->bSubType == ARMOR_BODY)
+						m_pOwner->SetPart(PART_MAIN, m_pOwner->GetOriginalPart(PART_MAIN));
+				}
+			}
+		}
+		break;
+
+#if defined(__COSTUME_SYSTEM__)
+		// 黴  禿  캐 parts  .  타求 煞..
+		case ITEM_COSTUME:
+		{
+			DWORD dwToSetValue = GetVnum();
+			BYTE bSetPart = PART_MAX_NUM;
+
+			switch (GetSubType())
+			{
+				//  黴
+				case COSTUME_BODY:
+				{
+					bSetPart = PART_MAIN;
+
+					if (!bAdd)
+					{
+						// 黴      蹈 羚摸   look ,  刻年摸 default look
+						const CItem* pArmor = m_pOwner->GetWear(WEAR_BODY);
+#if defined(__CHANGE_LOOK_SYSTEM__)
+						if (pArmor)
+							dwToSetValue = (pArmor->GetTransmutationVnum() != 0) ? pArmor->GetTransmutationVnum() : pArmor->GetVnum();
+						else
+							dwToSetValue = m_pOwner->GetOriginalPart(PART_MAIN);
+#else
+						dwToSetValue = (pArmor != nullptr) ? pArmor->GetVnum() : m_pOwner->GetOriginalPart(PART_MAIN);
+#endif
+					}
+#if defined(__CHANGE_LOOK_SYSTEM__)
+					else
+						dwToSetValue = (GetTransmutationVnum() != 0) ? GetTransmutationVnum() : GetVnum();
+#endif
+				}
+				break;
+
+				//  黴
+				case COSTUME_HAIR:
+				{
+					bSetPart = PART_HAIR;
+
+					// 黴  shape item proto value3 溝 . 특    (ARMOR_BODY) shape  value3 羚底 諍  value3 .
+					// [NOTE]   vnum   shape(value3)  ..  첵 瀏 퓸...
+#if defined(__CHANGE_LOOK_SYSTEM__)
+					const DWORD dwTransmutationVnum = GetTransmutationVnum();
+					if (dwTransmutationVnum != 0)
+					{
+						const TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwTransmutationVnum);
+						dwToSetValue = (pItemTable != nullptr) ? pItemTable->alValues[3] : GetValue(3);
+					}
+					else
+						dwToSetValue = (bAdd) ? GetValue(3) : 0;
+#else
+					dwToSetValue = (bAdd) ? GetValue(3) : 0;
+#endif
+				}
+				break;
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+				case COSTUME_ACCE:
+				{
+					bSetPart = PART_ACCE;
+					dwToSetValue = (bAdd) ? dwToSetValue : 0;
+				}
+				break;
+#endif
+
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+				case COSTUME_WEAPON:
+				{
+					bSetPart = PART_WEAPON;
+
+					if (!bAdd)
+					{
+						// 黴      蹈 羚摸   look ,  刻年摸 default look
+						const CItem* pWeapon = m_pOwner->GetWear(WEAR_WEAPON);
+#if defined(__CHANGE_LOOK_SYSTEM__)
+						if (pWeapon)
+							dwToSetValue = (pWeapon->GetTransmutationVnum() != 0) ? pWeapon->GetTransmutationVnum() : pWeapon->GetVnum();
+						else
+							dwToSetValue = 0;
+#else
+						dwToSetValue = (pWeapon != nullptr) ? pWeapon->GetVnum() : m_pOwner->GetOriginalPart(PART_WEAPON);
+#endif
+					}
+#if defined(__CHANGE_LOOK_SYSTEM__)
+					else
+						dwToSetValue = (GetTransmutationVnum() != 0) ? GetTransmutationVnum() : GetVnum();
+#endif
+				}
+				break;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+				case COSTUME_AURA:
+				{
+					bSetPart = PART_AURA;
+					dwToSetValue = (bAdd) ? dwToSetValue : 0;
+				}
+				break;
+#endif
+			}
+
+			if (PART_MAX_NUM != bSetPart)
+			{
+				m_pOwner->SetPart(bSetPart, dwToSetValue);
+				m_pOwner->UpdatePacket();
+			}
+		}
+		break;
+#endif
+
+		case ITEM_UNIQUE:
+		{
+			sys_log(0, "ITEM_UNIQUE Process");
+			if (GetSIGVnum() != 0)
+			{
+				sys_log(0, "ITEM_UNIQUE Contains SIGVnum %u", GetSIGVnum());
+
+				const CSpecialItemGroup* pItemGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(GetSIGVnum());
+				if (pItemGroup == nullptr)
+				{
+					sys_log(0, "ITEM_UNIQUE No pointer for item group?");
+					break;
+				}
+
+				const DWORD dwAttrVnum = pItemGroup->GetAttrVnum(GetVnum());
+				const CSpecialAttrGroup* pAttrGroup = ITEM_MANAGER::instance().GetSpecialAttrGroup(dwAttrVnum);
+				if (pAttrGroup == nullptr)
+				{
+					sys_log(0, "ITEM_UNIQUE No pointer for attr group?");
+					break;
+				}
+
+				for (const CSpecialAttrInfo& it : pAttrGroup->m_vecAttrs)
+					m_pOwner->ApplyPoint(it.apply_type, bAdd ? it.apply_value : -it.apply_value);
+			}
+		}
+		break;
+	}
+
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+	if (m_pOwner->GetWear(WEAR_COSTUME_WEAPON) && !m_pOwner->GetWear(WEAR_WEAPON))
+		m_pOwner->SetPart(PART_WEAPON, 0);
+#endif
+}
+
+bool CItem::IsEquipable() const
+{
+	switch (this->GetType())
+	{
+		case ITEM_COSTUME:
+		case ITEM_ARMOR:
+		case ITEM_WEAPON:
+		case ITEM_ROD:
+		case ITEM_PICK:
+		case ITEM_UNIQUE:
+		case ITEM_DS:
+		case ITEM_SPECIAL_DS:
+		case ITEM_RING:
+		case ITEM_BELT:
+			return true;
+	}
+
+	return false;
+}
+
+// return false on error state
+bool CItem::EquipTo(LPCHARACTER ch, BYTE bWearCell)
+{
+	if (!ch)
+	{
+		sys_err("EquipTo: null character");
+		return false;
+	}
+
+	// 혼  index WEAR_MAX_NUM  큼.
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (IsDragonSoul())
+	{
+		if (bWearCell < WEAR_MAX_NUM || bWearCell >= WEAR_MAX_NUM + DRAGON_SOUL_DECK_MAX_NUM * DS_SLOT_MAX)
+		{
+			sys_err("EquipTo: invalid dragon soul cell (this: #%d %s wearflag: %d cell: %d)", GetOriginalVnum(), GetName(), GetSubType(), bWearCell - WEAR_MAX_NUM);
+			return false;
+		}
+	}
+	else
+#endif
+	{
+		if (bWearCell >= WEAR_MAX_NUM)
+		{
+			sys_err("EquipTo: invalid wear cell (this: #%d %s wearflag: %d cell: %d)", GetOriginalVnum(), GetName(), GetWearFlag(), bWearCell);
+			return false;
+		}
+	}
+
+	if (ch->GetWear(bWearCell))
+	{
+		sys_err("EquipTo: item already exist (this: #%d %s cell: %d %s)", GetOriginalVnum(), GetName(), bWearCell, ch->GetWear(bWearCell)->GetName());
+		return false;
+	}
+
+	if (GetOwner())
+		RemoveFromCharacter();
+
+	ch->SetWear(bWearCell, this); // 茱 킷 
+
+	m_pOwner = ch;
+	m_bEquipped = true;
+	m_wCell = bWearCell;
+
+	DWORD dwImmuneFlag = 0;
+
+	for (int i = 0; i < WEAR_MAX_NUM; ++i)
+	{
+		if (m_pOwner->GetWear(i))
+		{
+			SET_BIT(dwImmuneFlag, m_pOwner->GetWear(i)->GetRealImmuneFlag());
+		}
+	}
+
+	m_pOwner->SetImmuneFlag(dwImmuneFlag);
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (IsDragonSoul())
+	{
+		DSManager::instance().ActivateDragonSoul(this);
+#if defined(__DS_SET__)
+		m_pOwner->DragonSoul_SetBonus();
+#endif
+	}
+	else
+#endif
+	{
+		ModifyPoints(true);
+		StartUniqueExpireEvent();
+		if (-1 != GetProto()->cLimitTimerBasedOnWearIndex)
+			StartTimerBasedOnWearExpireEvent();
+
+		// ACCESSORY_REFINE
+		StartAccessorySocketExpireEvent();
+		// END_OF_ACCESSORY_REFINE
+	}
+
+	m_pOwner->BuffOnAttr_AddBuffsFromItem(this);
+
+#if defined(__SET_ITEM__)
+	if (IsCostume() || IsUnique())
+		m_pOwner->RefreshItemSetBonus();
+
+	if (GetItemSetValue())
+		m_pOwner->RefreshItemSetBonusByValue();
+#endif
+
+	m_pOwner->ComputeBattlePoints();
+	m_pOwner->UpdatePacket();
+
+	Save();
+
+	return (true);
+}
+
+bool CItem::Unequip()
+{
+	if (!m_pOwner || GetCell() > EQUIPMENT_MAX_NUM)
+	{
+		// ITEM_OWNER_INVALID_PTR_BUG
+		sys_err("%s %u m_pOwner %p, GetCell %d",
+			GetName(), GetID(), get_pointer(m_pOwner), GetCell());
+		// END_OF_ITEM_OWNER_INVALID_PTR_BUG
+		return false;
+	}
+
+	if (this != m_pOwner->GetWear(GetCell()))
+	{
+		sys_err("m_pOwner->GetWear() != this");
+		return false;
+	}
+
+	// 킥   탐 처
+	if (IsRideItem())
+		ClearMountAttributeAndAffect();
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (IsDragonSoul())
+	{
+		DSManager::instance().DeactivateDragonSoul(this);
+#if defined(__DS_SET__)
+		m_pOwner->DragonSoul_SetBonus();
+#endif
+	}
+	else
+#endif
+	{
+		ModifyPoints(false);
+	}
+
+	StopUniqueExpireEvent();
+
+	if (-1 != GetProto()->cLimitTimerBasedOnWearIndex)
+		StopTimerBasedOnWearExpireEvent();
+
+	// ACCESSORY_REFINE
+	StopAccessorySocketExpireEvent();
+	// END_OF_ACCESSORY_REFINE
+
+	m_pOwner->BuffOnAttr_RemoveBuffsFromItem(this);
+	m_pOwner->SetWear(GetCell(), nullptr);
+
+	DWORD dwImmuneFlag = 0;
+	for (int i = 0; i < WEAR_MAX_NUM; ++i)
+	{
+		if (m_pOwner->GetWear(i))
+		{
+			SET_BIT(dwImmuneFlag, m_pOwner->GetWear(i)->GetRealImmuneFlag());
+		}
+	}
+	m_pOwner->SetImmuneFlag(dwImmuneFlag);
+
+#if defined(__SET_ITEM__)
+	if (IsCostume() || IsUnique())
+		m_pOwner->RefreshItemSetBonus();
+
+	if (GetItemSetValue())
+		m_pOwner->RefreshItemSetBonusByValue();
+#endif
+
+	m_pOwner->ComputeBattlePoints();
+	m_pOwner->UpdatePacket();
+
+	m_pOwner = nullptr;
+	m_wCell = 0;
+	m_bEquipped = false;
+
+	return true;
+}
+
+long CItem::GetValue(DWORD idx)
+{
+	assert(idx < ITEM_VALUES_MAX_NUM);
+	return GetProto()->alValues[idx];
+}
+
+void CItem::SetExchanging(bool bOn)
+{
+	m_bExchanging = bOn;
+}
+
+void CItem::Save()
+{
+	if (m_bSkipSave)
+		return;
+
+	ITEM_MANAGER::instance().DelayedSave(this);
+}
+
+#if defined(__MOVE_COSTUME_ATTR__)
+bool CItem::CanChangeCostumeAttr() const
+{
+	if (GetType() != ITEM_COSTUME)
+		return false;
+
+	switch (GetSubType())
+	{
+		case COSTUME_BODY:
+		case COSTUME_HAIR:
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+		case COSTUME_WEAPON:
+#endif
+			return true;
+	}
+
+	return false;
+}
+#endif
+
+bool CItem::CreateSocket(BYTE bSlot, BYTE bGold)
+{
+	assert(bSlot < ITEM_SOCKET_MAX_NUM);
+
+	if (m_alSockets[bSlot] != 0)
+	{
+		sys_err("Item::CreateSocket : socket already exist %s %d", GetName(), bSlot);
+		return false;
+	}
+
+	if (bGold)
+		m_alSockets[bSlot] = 2;
+	else
+		m_alSockets[bSlot] = 1;
+
+	UpdatePacket();
+
+	Save();
+	return true;
+}
+
+void CItem::SetSockets(const long* c_al)
+{
+	thecore_memcpy(m_alSockets, c_al, sizeof(m_alSockets));
+	Save();
+}
+
+void CItem::SetSocket(int i, long v, bool bLog)
+{
+	assert(i < ITEM_SOCKET_MAX_NUM);
+	m_alSockets[i] = v;
+	UpdatePacket();
+	Save();
+	if (bLog)
+		LogManager::instance().ItemLog(i, v, 0, GetID(), "SET_SOCKET", "", "", GetOriginalVnum());
+}
+
+int CItem::GetGold()
+{
+	if (IS_SET(GetFlag(), ITEM_FLAG_COUNT_PER_1GOLD))
+	{
+		if (GetProto()->dwShopSellPrice == 0)
+			return GetCount();
+		else
+			return GetCount() / GetProto()->dwShopSellPrice;
+	}
+	else
+		return GetProto()->dwShopSellPrice;
+}
+
+int CItem::GetShopBuyPrice()
+{
+	return GetProto()->dwShopBuyPrice;
+}
+
+int CItem::GetShopSellPrice()
+{
+	return GetProto()->dwShopSellPrice;
+}
+
+bool CItem::IsOwnership(LPCHARACTER ch)
+{
+	if (!m_pkOwnershipEvent)
+		return true;
+
+	return m_dwOwnershipPID == ch->GetPlayerID() ? true : false;
+}
+
+EVENTFUNC(ownership_event)
+{
+	item_event_info* info = dynamic_cast<item_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("ownership_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPITEM pkItem = info->item;
+
+	pkItem->SetOwnershipEvent(NULL);
+
+	TPacketGCItemOwnership p;
+
+	p.bHeader = HEADER_GC_ITEM_OWNERSHIP;
+	p.dwVID = pkItem->GetVID();
+	p.szName[0] = '\0';
+
+	pkItem->PacketAround(&p, sizeof(p));
+	return 0;
+}
+
+void CItem::SetOwnershipEvent(LPEVENT pkEvent)
+{
+	m_pkOwnershipEvent = pkEvent;
+}
+
+void CItem::SetOwnership(LPCHARACTER ch, int iSec)
+{
+	if (!ch)
+	{
+		if (m_pkOwnershipEvent)
+		{
+			event_cancel(&m_pkOwnershipEvent);
+			m_dwOwnershipPID = 0;
+
+			TPacketGCItemOwnership p;
+
+			p.bHeader = HEADER_GC_ITEM_OWNERSHIP;
+			p.dwVID = m_dwVID;
+			p.szName[0] = '\0';
+
+			PacketAround(&p, sizeof(p));
+		}
+		return;
+	}
+
+	if (m_pkOwnershipEvent)
+		return;
+
+	if (true == LC_IsEurope())
+	{
+		if (iSec <= 10)
+			iSec = 30;
+	}
+
+	m_dwOwnershipPID = ch->GetPlayerID();
+
+	item_event_info* info = AllocEventInfo<item_event_info>();
+	strlcpy(info->szOwnerName, ch->GetName(), sizeof(info->szOwnerName));
+	info->item = this;
+
+	SetOwnershipEvent(event_create(ownership_event, info, PASSES_PER_SEC(iSec)));
+
+	TPacketGCItemOwnership p;
+
+	p.bHeader = HEADER_GC_ITEM_OWNERSHIP;
+	p.dwVID = m_dwVID;
+	strlcpy(p.szName, ch->GetName(), sizeof(p.szName));
+
+	PacketAround(&p, sizeof(p));
+}
+
+int CItem::GetSocketCount()
+{
+	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
+	{
+		if (GetSocket(i) == 0)
+			return i;
+	}
+	return ITEM_SOCKET_MAX_NUM;
+}
+
+bool CItem::AddSocket()
+{
+	int count = GetSocketCount();
+	if (count == ITEM_SOCKET_MAX_NUM)
+		return false;
+	m_alSockets[count] = 1;
+	return true;
+}
+
+void CItem::AlterToSocketItem(int iSocketCount)
+{
+	if (iSocketCount >= METIN_SOCKET_MAX_NUM)
+	{
+		sys_log(0, "Invalid Socket Count %d, set to maximum", METIN_SOCKET_MAX_NUM);
+		iSocketCount = METIN_SOCKET_MAX_NUM;
+	}
+
+	for (int i = 0; i < iSocketCount; ++i)
+		SetSocket(i, 1);
+}
+
+void CItem::AlterToMagicItem(int iSecondPct /*= 0*/, int iThirdPct /*= 0 */)
+{
+	int idx = GetAttributeSetIndex();
+
+	if (idx < 0)
+		return;
+
+	//			Appeariance	Second	Third
+	// Weapon	50			20		5
+	// Armor	30			10		2
+	// Acc		20			10		1
+
+	//int iSecondPct;
+	//int iThirdPct;
+
+	switch (GetType())
+	{
+		case ITEM_WEAPON:
+		{
+			iSecondPct = 20;
+			iThirdPct = 5;
+		}
+		break;
+
+		case ITEM_ARMOR:
+		{
+			if (GetSubType() == ARMOR_BODY)
+			{
+				iSecondPct = 10;
+				iThirdPct = 2;
+			}
+			else
+			{
+				iSecondPct = 10;
+				iThirdPct = 1;
+			}
+		}
+		break;
+
+#if defined(__MOVE_COSTUME_ATTR__)
+		case ITEM_COSTUME:
+		{
+			if (GetSubType() == COSTUME_BODY)
+			{
+				iSecondPct = 30;
+				iThirdPct = 10;
+			}
+			else if (GetSubType() == COSTUME_HAIR)
+			{
+				iSecondPct = 30;
+				iThirdPct = 10;
+			}
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+			else if (GetSubType() == COSTUME_WEAPON)
+			{
+				iSecondPct = 30;
+				iThirdPct = 10;
+			}
+#endif
+			else
+			{
+				iSecondPct = 0;
+				iThirdPct = 0;
+			}
+		}
+		break;
+#endif
+
+		default:
+			return;
+	}
+
+	// 100% 확  憺 毬
+	PutAttribute(aiItemMagicAttributePercentHigh);
+
+	if (number(1, 100) <= iSecondPct)
+		PutAttribute(aiItemMagicAttributePercentLow);
+
+	if (number(1, 100) <= iThirdPct)
+		PutAttribute(aiItemMagicAttributePercentLow);
+}
+
+DWORD CItem::GetRefineFromVnum()
+{
+	return ITEM_MANAGER::instance().GetRefineFromVnum(GetVnum());
+}
+
+int CItem::GetRefineLevel()
+{
+	const char* name = GetBaseName();
+	char* p = const_cast<char*>(strrchr(name, '+'));
+
+	if (!p)
+		return 0;
+
+	int	rtn = 0;
+	str_to_number(rtn, p + 1);
+
+	const char* locale_name = GetName();
+	p = const_cast<char*>(strrchr(locale_name, '+'));
+
+	if (p)
+	{
+		int	locale_rtn = 0;
+		str_to_number(locale_rtn, p + 1);
+		if (locale_rtn != rtn)
+		{
+			sys_err("refine_level_based_on_NAME(%d) is not equal to refine_level_based_on_LOCALE_NAME(%d).", rtn, locale_rtn);
+		}
+	}
+
+	return rtn;
+}
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+long CItem::GetWearingLevelLimit() const
+{
+	if (m_pProto)
+	{
+		for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+			if (m_pProto->aLimits[i].bType == LIMIT_LEVEL)
+				return m_pProto->aLimits[i].lValue;
+	}
+
+	return 0;
+}
+
+bool CItem::IsHairDye() const
+{
+	switch (GetVnum())
+	{
+		case 70202:
+		case 70203:
+		case 70204:
+		case 70205:
+		case 70206:
+			return true;
+		default:
+			return false;
+	}
+}
+#endif
+
+bool CItem::IsPolymorphItem()
+{
+	return GetType() == ITEM_POLYMORPH;
+}
+
+EVENTFUNC(unique_expire_event)
+{
+	item_event_info* info = dynamic_cast<item_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("unique_expire_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPITEM pkItem = info->item;
+
+	if (pkItem->GetValue(2) == 0)
+	{
+		if (pkItem->GetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME) <= 1)
+		{
+			sys_log(0, "UNIQUE_ITEM: expire %s %u", pkItem->GetName(), pkItem->GetID());
+			pkItem->SetUniqueExpireEvent(NULL);
+			ITEM_MANAGER::instance().RemoveItem(pkItem, "UNIQUE_EXPIRE");
+			return 0;
+		}
+		else
+		{
+			pkItem->SetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME, pkItem->GetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME) - 1);
+			return PASSES_PER_SEC(60);
+		}
+	}
+	else
+	{
+		time_t cur = get_global_time();
+
+		if (pkItem->GetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME) <= cur)
+		{
+			pkItem->SetUniqueExpireEvent(NULL);
+			ITEM_MANAGER::instance().RemoveItem(pkItem, "UNIQUE_EXPIRE");
+			return 0;
+		}
+		else
+		{
+			//   챨 滂 構  苛 陋 羚
+			// 
+			// by rtsummit
+			if (pkItem->GetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME) - cur < 600)
+				return PASSES_PER_SEC(pkItem->GetSocket(ITEM_SOCKET_UNIQUE_REMAIN_TIME) - cur);
+			else
+				return PASSES_PER_SEC(600);
+		}
+	}
+}
+
+// 챨 캤
+// timer   챨 求  틈灸, 
+// timer 화  timer  챨 큼 챨  磯.
+EVENTFUNC(timer_based_on_wear_expire_event)
+{
+	item_event_info* info = dynamic_cast<item_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("expire_event <Factor> Null pointer");
+		return 0;
+	}
+
+	LPITEM pkItem = info->item;
+	int remain_time = pkItem->GetSocket(ITEM_SOCKET_REMAIN_SEC) - processing_time / passes_per_sec;
+	if (remain_time <= 0)
+	{
+		sys_log(0, "ITEM EXPIRED : expired %s %u", pkItem->GetName(), pkItem->GetID());
+		pkItem->SetTimerBasedOnWearExpireEvent(NULL);
+		pkItem->SetSocket(ITEM_SOCKET_REMAIN_SEC, 0);
+
+		// 求 timer based on wear 혼 챨  퓸鳴  苛쨈.
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (pkItem->IsDragonSoul())
+		{
+			DSManager::instance().DeactivateDragonSoul(pkItem);
+#if defined(__DS_SET__)
+			if (pkItem->GetOwner())
+				pkItem->GetOwner()->DragonSoul_SetBonus();
+#endif
+		}
+		else
+#endif
+		{
+			ITEM_MANAGER::instance().RemoveItem(pkItem, "TIMER_BASED_ON_WEAR_EXPIRE");
+		}
+		return 0;
+	}
+	pkItem->SetSocket(ITEM_SOCKET_REMAIN_SEC, remain_time);
+	return PASSES_PER_SEC(MIN(60, remain_time));
+}
+
+void CItem::SetUniqueExpireEvent(LPEVENT pkEvent)
+{
+	m_pkUniqueExpireEvent = pkEvent;
+}
+
+void CItem::SetTimerBasedOnWearExpireEvent(LPEVENT pkEvent)
+{
+	m_pkTimerBasedOnWearExpireEvent = pkEvent;
+}
+
+EVENTFUNC(real_time_expire_event)
+{
+	const item_vid_event_info* info = reinterpret_cast<const item_vid_event_info*>(event->info);
+
+	if (NULL == info)
+		return 0;
+
+	const LPITEM item = ITEM_MANAGER::instance().FindByVID(info->item_vid);
+
+	if (NULL == item)
+		return 0;
+
+	const time_t current = get_global_time();
+
+	if (current > item->GetSocket(0))
+	{
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		LPCHARACTER owner = item->GetOwner();
+		if (owner)
+		{
+			CChangeLook* pChangeLook = owner->GetChangeLook();
+			if (pChangeLook)
+				pChangeLook->Clear();
+		}
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+		if (item->GetType() == ITEM_PET && item->GetSubType() == PET_UPBRINGING)
+		{
+			if (item->GetOwner()->GetActiveGrowthPet())
+			{
+				if (item->GetOwner()->GetActiveGrowthPet()->GetPetID() == item->GetSocket(2))
+					item->GetOwner()->GetActiveGrowthPet()->Unsummon();
+			}
+		}
+
+
+		if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_RT_REMOVE))
+		{
+			item->StopRealTimeExpireEvent();
+			return 0;
+		}
+#endif
+		ITEM_MANAGER::instance().RemoveItem(item, "REAL_TIME_EXPIRE");
+		return 0;
+	}
+
+	return PASSES_PER_SEC(1);
+}
+
+#ifdef __GROWTH_PET_SYSTEM__
+void CItem::StopRealTimeExpireEvent()
+{
+	if (!m_pkRealTimeExpireEvent)
+		return;
+
+	event_cancel(&m_pkRealTimeExpireEvent);
+	m_pkRealTimeExpireEvent = nullptr;
+}
+#endif
+
+void CItem::StartRealTimeExpireEvent()
+{
+	if (m_pkRealTimeExpireEvent)
+		return;
+
+	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+	{
+		if (LIMIT_REAL_TIME == GetProto()->aLimits[i].bType || LIMIT_REAL_TIME_START_FIRST_USE == GetProto()->aLimits[i].bType)
+		{
+			item_vid_event_info* info = AllocEventInfo<item_vid_event_info>();
+			info->item_vid = GetVID();
+
+			m_pkRealTimeExpireEvent = event_create(real_time_expire_event, info, PASSES_PER_SEC(1));
+
+			sys_log(0, "REAL_TIME_EXPIRE: StartRealTimeExpireEvent");
+
+			return;
+		}
+	}
+}
+
+bool CItem::IsRealTimeItem()
+{
+	if (!GetProto())
+		return false;
+
+	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+	{
+		if (LIMIT_REAL_TIME == GetProto()->aLimits[i].bType || LIMIT_REAL_TIME_START_FIRST_USE == GetProto()->aLimits[i].bType)
+			return true;
+	}
+
+	return false;
+}
+
+bool CItem::IsUsedTimeItem()
+{
+	return m_pkRealTimeExpireEvent != NULL;
+}
+
+void CItem::StartUniqueExpireEvent()
+{
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	if (GetType() != ITEM_UNIQUE && !IsRideItem())
+		return;
+#else
+	if (GetType() != ITEM_UNIQUE)
+		return;
+#endif
+
+	if (m_pkUniqueExpireEvent)
+		return;
+
+	// 璲   챨   苛쨈
+	if (IsRealTimeItem())
+		return;
+
+	// HARD CODING
+	if (GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
+		if (m_pOwner) m_pOwner->ShowAlignment(false);
+
+	int iSec = GetSocket(ITEM_SOCKET_UNIQUE_SAVE_TIME);
+
+	if (iSec == 0)
+		iSec = 60;
+	else
+		iSec = MIN(iSec, 60);
+
+	SetSocket(ITEM_SOCKET_UNIQUE_SAVE_TIME, 0);
+
+	item_event_info* info = AllocEventInfo<item_event_info>();
+	info->item = this;
+
+	SetUniqueExpireEvent(event_create(unique_expire_event, info, PASSES_PER_SEC(iSec)));
+}
+
+// 챨 캤
+// timer_based_on_wear_expire_event  
+void CItem::StartTimerBasedOnWearExpireEvent()
+{
+	if (m_pkTimerBasedOnWearExpireEvent)
+		return;
+
+	// 璲   챨   苛쨈
+	if (IsRealTimeItem())
+		return;
+
+	if (-1 == GetProto()->cLimitTimerBasedOnWearIndex)
+		return;
+
+	int iSec = GetSocket(0);
+
+	if (0 != iSec)
+	{
+		iSec %= 60;
+		if (0 == iSec)
+			iSec = 60;
+	}
+
+	item_event_info* info = AllocEventInfo<item_event_info>();
+	info->item = this;
+
+	SetTimerBasedOnWearExpireEvent(event_create(timer_based_on_wear_expire_event, info, PASSES_PER_SEC(iSec)));
+}
+
+void CItem::StopUniqueExpireEvent()
+{
+	if (!m_pOwner)
+		return;
+
+	if (!m_pkUniqueExpireEvent)
+		return;
+
+	if (GetValue(2) != 0) // 擔챨 結  UniqueExpireEvent 杉  .
+		return;
+
+	// HARD CODING
+	if (GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
+		m_pOwner->ShowAlignment(true);
+
+	SetSocket(ITEM_SOCKET_UNIQUE_SAVE_TIME, event_time(m_pkUniqueExpireEvent) / passes_per_sec);
+	event_cancel(&m_pkUniqueExpireEvent);
+
+	ITEM_MANAGER::instance().SaveSingleItem(this);
+}
+
+void CItem::StopTimerBasedOnWearExpireEvent()
+{
+	if (!m_pkTimerBasedOnWearExpireEvent)
+		return;
+
+	int remain_time = GetSocket(ITEM_SOCKET_REMAIN_SEC) - event_processing_time(m_pkTimerBasedOnWearExpireEvent) / passes_per_sec;
+
+	SetSocket(ITEM_SOCKET_REMAIN_SEC, remain_time);
+	event_cancel(&m_pkTimerBasedOnWearExpireEvent);
+
+	ITEM_MANAGER::instance().SaveSingleItem(this);
+}
+
+void CItem::ApplyAddon(int iAddonType)
+{
+	CItemAddonManager::instance().ApplyAddonTo(iAddonType, this);
+}
+
+int CItem::GetSpecialGroup() const
+{
+	return ITEM_MANAGER::instance().GetSpecialGroupFromItem(GetVnum());
+}
+
+//
+// 퓬  처.
+//
+bool CItem::IsAccessoryForSocket()
+{
+	return (m_pProto->bType == ITEM_ARMOR && (m_pProto->bSubType == ARMOR_WRIST || m_pProto->bSubType == ARMOR_NECK || m_pProto->bSubType == ARMOR_EAR)) ||
+		(m_pProto->bType == ITEM_BELT); // 2013 2  煞 '트'   획 퓬  첵 榴 結微 .
+}
+
+bool CItem::IsRemovableSocket()
+{
+	if (m_pProto->bType == ITEM_ARMOR)
+		return m_pProto->bSubType == ARMOR_BODY
+#if defined(__GLOVE_SYSTEM__)
+		|| m_pProto->bSubType == ARMOR_GLOVE
+#endif
+		;
+
+	if (m_pProto->bType == ITEM_WEAPON)
+		return !(m_pProto->bSubType == WEAPON_ARROW
+			|| m_pProto->bSubType == WEAPON_MOUNT_SPEAR
+#if defined(__QUIVER_SYSTEM__)
+			|| m_pProto->bSubType == WEAPON_QUIVER
+#endif
+			|| m_pProto->bSubType == WEAPON_BOUQUET);
+
+	return false;
+}
+
+void CItem::SetAccessorySocketGrade(int iGrade)
+{
+	SetSocket(0, MINMAX(0, iGrade, GetAccessorySocketMaxGrade()));
+
+	int iDownTime = aiAccessorySocketDegradeTime[GetAccessorySocketGrade()];
+
+	//if (test_server)
+	//	iDownTime /= 60;
+
+	SetAccessorySocketDownGradeTime(iDownTime);
+}
+
+void CItem::SetAccessorySocketMaxGrade(int iMaxGrade)
+{
+	SetSocket(1, MINMAX(0, iMaxGrade, ITEM_ACCESSORY_SOCKET_MAX_NUM));
+}
+
+void CItem::SetAccessorySocketDownGradeTime(DWORD time)
+{
+	SetSocket(2, time);
+
+	if (test_server && GetOwner())
+		GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s    챨 %d", LC_ITEM(GetVnum()), time));
+}
+
+EVENTFUNC(accessory_socket_expire_event)
+{
+	item_vid_event_info* info = dynamic_cast<item_vid_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("accessory_socket_expire_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPITEM item = ITEM_MANAGER::instance().FindByVID(info->item_vid);
+
+	if (item->GetAccessorySocketDownGradeTime() <= 1)
+	{
+	degrade:
+		item->SetAccessorySocketExpireEvent(NULL);
+		item->AccessorySocketDegrade();
+		return 0;
+	}
+	else
+	{
+		int iTime = item->GetAccessorySocketDownGradeTime() - 60;
+
+		if (iTime <= 1)
+			goto degrade;
+
+		item->SetAccessorySocketDownGradeTime(iTime);
+
+		if (iTime > 60)
+			return PASSES_PER_SEC(60);
+		else
+			return PASSES_PER_SEC(iTime);
+	}
+}
+
+void CItem::StartAccessorySocketExpireEvent()
+{
+	if (!IsAccessoryForSocket())
+		return;
+
+	if (m_pkAccessorySocketExpireEvent)
+		return;
+
+	if (GetAccessorySocketMaxGrade() == 0)
+		return;
+
+	if (GetAccessorySocketGrade() == 0)
+		return;
+
+	int iSec = GetAccessorySocketDownGradeTime();
+	SetAccessorySocketExpireEvent(NULL);
+
+	if (iSec <= 1)
+		iSec = 5;
+	else
+		iSec = MIN(iSec, 60);
+
+	item_vid_event_info* info = AllocEventInfo<item_vid_event_info>();
+	info->item_vid = GetVID();
+
+	SetAccessorySocketExpireEvent(event_create(accessory_socket_expire_event, info, PASSES_PER_SEC(iSec)));
+}
+
+void CItem::StopAccessorySocketExpireEvent()
+{
+	if (!m_pkAccessorySocketExpireEvent)
+		return;
+
+	if (!IsAccessoryForSocket())
+		return;
+
+	int new_time = GetAccessorySocketDownGradeTime() - (60 - event_time(m_pkAccessorySocketExpireEvent) / passes_per_sec);
+
+	event_cancel(&m_pkAccessorySocketExpireEvent);
+
+	if (new_time <= 1)
+	{
+		AccessorySocketDegrade();
+	}
+	else
+	{
+		SetAccessorySocketDownGradeTime(new_time);
+	}
+}
+
+bool CItem::IsRideItem()
+{
+	if (ITEM_UNIQUE == GetType() && UNIQUE_SPECIAL_RIDE == GetSubType())
+		return true;
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	if (ITEM_COSTUME == GetType() && COSTUME_MOUNT == GetSubType())
+		return true;
+#endif
+
+	return false;
+}
+
+void CItem::ClearMountAttributeAndAffect()
+{
+	LPCHARACTER ch = GetOwner();
+
+	ch->RemoveAffect(AFFECT_MOUNT);
+	ch->RemoveAffect(AFFECT_MOUNT_BONUS);
+
+	ch->MountVnum(0);
+
+	ch->PointChange(POINT_ST, 0);
+	ch->PointChange(POINT_DX, 0);
+	ch->PointChange(POINT_HT, 0);
+	ch->PointChange(POINT_IQ, 0);
+}
+
+void CItem::SetAccessorySocketExpireEvent(LPEVENT pkEvent)
+{
+	m_pkAccessorySocketExpireEvent = pkEvent;
+}
+
+void CItem::AccessorySocketDegrade()
+{
+	if (GetAccessorySocketGrade() > 0)
+	{
+		LPCHARACTER ch = GetOwner();
+
+		if (ch)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s 獵  求.", LC_ITEM(GetVnum())));
+		}
+
+		ModifyPoints(false);
+		SetAccessorySocketGrade(GetAccessorySocketGrade() - 1);
+		ModifyPoints(true);
+
+		int iDownTime = aiAccessorySocketDegradeTime[GetAccessorySocketGrade()];
+
+		if (test_server)
+			iDownTime /= 60;
+
+		SetAccessorySocketDownGradeTime(iDownTime);
+
+		if (iDownTime)
+			StartAccessorySocketExpireEvent();
+	}
+}
+
+// ring item   獵 罐 체크漫 
+static const bool CanPutIntoRing(LPITEM ring, LPITEM item)
+{
+	const DWORD vnum = item->GetVnum();
+	return false;
+}
+
+bool CItem::CanPutInto(LPITEM item)
+{
+	if (item->GetType() == ITEM_BELT)
+		return this->GetSubType() == USE_PUT_INTO_BELT_SOCKET;
+
+	else if (item->GetType() == ITEM_RING)
+		return CanPutIntoRing(item, this);
+
+	else if (item->GetType() != ITEM_ARMOR)
+		return false;
+
+	DWORD vnum = item->GetVnum();
+
+	struct JewelAccessoryInfo
+	{
+		DWORD jewel;
+		DWORD wrist;
+		DWORD neck;
+		DWORD ear;
+	};
+	const static JewelAccessoryInfo infos[] = {
+		{ 50634, 14420, 16220, 17220 },
+		{ 50635, 14500, 16500, 17500 },
+		{ 50636, 14520, 16520, 17520 },
+		{ 50637, 14540, 16540, 17540 },
+		{ 50638, 14560, 16560, 17560 },
+		{ 50639, 14570, 16570, 0 },
+#if defined(__CONQUEROR_LEVEL__)
+		{ 50661, 14590, 16590, 17580 },
+		{ 50662, 14600, 16600, 17590 },
+		{ 50663, 14610, 16610, 17600 },
+		{ 50664, 14580, 16580, 17570 },
+#endif
+	};
+
+	DWORD item_type = (item->GetVnum() / 10) * 10;
+	for (int i = 0; i < sizeof(infos) / sizeof(infos[0]); i++)
+	{
+		const JewelAccessoryInfo& info = infos[i];
+		switch (item->GetSubType())
+		{
+			case ARMOR_WRIST:
+				if (info.wrist == item_type)
+				{
+					if (info.jewel == GetVnum())
+					{
+						return true;
+					}
+					else
+					{
+						return false;
+					}
+				}
+				break;
+			case ARMOR_NECK:
+				if (info.neck == item_type)
+				{
+					if (info.jewel == GetVnum())
+					{
+						return true;
+					}
+					else
+					{
+						return false;
+					}
+				}
+				break;
+			case ARMOR_EAR:
+				if (info.ear == item_type)
+				{
+					if (info.jewel == GetVnum())
+					{
+						return true;
+					}
+					else
+					{
+						return false;
+					}
+				}
+				break;
+		}
+	}
+	if (item->GetSubType() == ARMOR_WRIST)
+		vnum -= 14000;
+	else if (item->GetSubType() == ARMOR_NECK)
+		vnum -= 16000;
+	else if (item->GetSubType() == ARMOR_EAR)
+		vnum -= 17000;
+	else
+		return false;
+
+	DWORD type = vnum / 20;
+
+	if (type < 0 || type > 11)
+	{
+		type = (vnum - 170) / 20;
+
+		if (50623 + type != GetVnum())
+			return false;
+		else
+			return true;
+	}
+	else if (item->GetVnum() >= 16210 && item->GetVnum() <= 16219)
+	{
+		if (50625 != GetVnum())
+			return false;
+		else
+			return true;
+	}
+	else if (item->GetVnum() >= 16230 && item->GetVnum() <= 16239)
+	{
+		if (50626 != GetVnum())
+			return false;
+		else
+			return true;
+	}
+
+	return 50623 + type == GetVnum();
+}
+
+bool CItem::IsStackable()
+{
+	return (GetFlag() & ITEM_FLAG_STACKABLE) ? true : false;
+}
+
+bool CItem::CheckItemUseLevel(int nLevel)
+{
+	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+	{
+		if (this->m_pProto->aLimits[i].bType == LIMIT_LEVEL)
+		{
+			if (this->m_pProto->aLimits[i].lValue > nLevel) return false;
+			else return true;
+		}
+	}
+	return true;
+}
+
+POINT_VALUE CItem::FindApplyValue(POINT_TYPE wApplyType)
+{
+	if (m_pProto == NULL)
+		return 0;
+
+	for (int i = 0; i < ITEM_APPLY_MAX_NUM; ++i)
+	{
+		if (m_pProto->aApplies[i].wType == wApplyType)
+			return m_pProto->aApplies[i].lValue;
+	}
+
+	return 0;
+}
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+DWORD CItem::GetMountVnum()
+{
+	if (!IsCostumeMount())
+		return 0;
+
+	const DWORD dwMountVnum = FindApplyValue(APPLY_MOUNT);
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	const DWORD c_dwTransmutationVnum = GetTransmutationVnum();
+	if (c_dwTransmutationVnum != 0)
+	{
+		TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(c_dwTransmutationVnum);
+		if (pItemTable)
+			return static_cast<DWORD>(pItemTable->FindApplyValue(APPLY_MOUNT));
+	}
+#endif
+	return dwMountVnum;
+}
+#endif
+
+void CItem::CopySocketTo(LPITEM pItem)
+{
+	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+	{
+		pItem->m_alSockets[i] = m_alSockets[i];
+	}
+}
+
+int CItem::GetAccessorySocketGrade()
+{
+	return MINMAX(0, GetSocket(0), GetAccessorySocketMaxGrade());
+}
+
+int CItem::GetAccessorySocketMaxGrade()
+{
+	return MINMAX(0, GetSocket(1), ITEM_ACCESSORY_SOCKET_MAX_NUM);
+}
+
+int CItem::GetAccessorySocketDownGradeTime()
+{
+	return MINMAX(0, GetSocket(2), aiAccessorySocketDegradeTime[GetAccessorySocketGrade()]);
+}
+
+void CItem::AttrLog()
+{
+	const char* pszIP = NULL;
+
+	if (GetOwner() && GetOwner()->GetDesc())
+		pszIP = GetOwner()->GetDesc()->GetHostName();
+
+	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+	{
+		if (m_alSockets[i])
+		{
+			LogManager::instance().ItemLog(i, m_alSockets[i], 0, GetID(), "INFO_SOCKET", "", pszIP ? pszIP : "", GetOriginalVnum());
+		}
+	}
+
+	for (int i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
+	{
+		POINT_TYPE type = m_aAttr[i].wType;
+		POINT_VALUE value = m_aAttr[i].lValue;
+
+		if (type)
+			LogManager::instance().ItemLog(i, type, value, GetID(), "INFO_ATTR", "", pszIP ? pszIP : "", GetOriginalVnum());
+	}
+}
+
+int CItem::GetLevelLimit()
+{
+	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+	{
+		if (this->m_pProto->aLimits[i].bType == LIMIT_LEVEL)
+		{
+			return this->m_pProto->aLimits[i].lValue;
+		}
+	}
+	return 0;
+}
+
+int CItem::GetDurationLimit()
+{
+	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+	{
+		if (this->m_pProto->aLimits[i].bType == LIMIT_DURATION)
+		{
+			return this->m_pProto->aLimits[i].lValue;
+		}
+	}
+	return 0;
+}
+
+bool CItem::OnAfterCreatedItem()
+{
+#if defined(__SOUL_SYSTEM__)
+	if (GetType() == ITEM_SOUL && GetLimitValue(1) != 0)
+		StartSoulTimerUseEvent();
+#endif
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (GetSealDate() > E_SEAL_DATE_DEFAULT_TIMESTAMP)
+		StartSealDateExpireTimerEvent();
+#endif
+
+	//   繭 杉摸,  커   刻틉 챨 풔 
+	if (-1 != this->GetProto()->cLimitRealTimeFirstUseIndex)
+	{
+		// Socket1   횟 溝퓸 ,  繭   타見疸 磯.
+		if (0 != GetSocket(1))
+		{
+			StartRealTimeExpireEvent();
+		}
+	}
+
+	return true;
+}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+bool CItem::IsDragonSoul()
+{
+	return GetType() == ITEM_DS;
+}
+
+int CItem::GiveMoreTime_Per(float fPercent)
+{
+	if (IsDragonSoul())
+	{
+		DWORD duration = DSManager::instance().GetDuration(this);
+		DWORD remain_sec = GetSocket(ITEM_SOCKET_REMAIN_SEC);
+		DWORD given_time = fPercent * duration / 100u;
+
+		if (remain_sec == duration)
+			return false;
+
+		if ((given_time + remain_sec) >= duration)
+		{
+			SetSocket(ITEM_SOCKET_REMAIN_SEC, duration);
+			return duration - remain_sec;
+		}
+		else
+		{
+			SetSocket(ITEM_SOCKET_REMAIN_SEC, given_time + remain_sec);
+			return given_time;
+		}
+	}
+	// 耳 혼 漫 溝 磯.
+	else
+		return 0;
+}
+
+int CItem::GiveMoreTime_Fix(DWORD dwTime)
+{
+	if (IsDragonSoul())
+	{
+		DWORD duration = DSManager::instance().GetDuration(this);
+		DWORD remain_sec = GetSocket(ITEM_SOCKET_REMAIN_SEC);
+
+		if (remain_sec == duration)
+			return false;
+
+		if ((dwTime + remain_sec) >= duration)
+		{
+			SetSocket(ITEM_SOCKET_REMAIN_SEC, duration);
+			return duration - remain_sec;
+		}
+		else
+		{
+			SetSocket(ITEM_SOCKET_REMAIN_SEC, dwTime + remain_sec);
+			return dwTime;
+		}
+	}
+	// 耳 혼 漫 溝 磯.
+	else
+		return 0;
+}
+#endif
+
+int CItem::GetDuration()
+{
+	if (!GetProto())
+		return -1;
+
+	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+	{
+		if (LIMIT_REAL_TIME == GetProto()->aLimits[i].bType)
+			return GetProto()->aLimits[i].lValue;
+	}
+
+	if (-1 != GetProto()->cLimitTimerBasedOnWearIndex)
+		return GetProto()->aLimits[GetProto()->cLimitTimerBasedOnWearIndex].lValue;
+
+	return -1;
+}
+
+bool CItem::IsSameSpecialGroup(const LPITEM item) const
+{
+	//  VNUM 摸  瀏  
+	if (this->GetVnum() == item->GetVnum())
+		return true;
+
+	if (GetSpecialGroup() && (item->GetSpecialGroup() == GetSpecialGroup()))
+		return true;
+
+	return false;
+}
+
+DWORD CItem::GetRealImmuneFlag()
+{
+	DWORD dwImmuneFlag = m_pProto->dwImmuneFlag;
+	for (int i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
+	{
+		if (GetAttributeType(i))
+		{
+			const TPlayerItemAttribute& ia = GetAttribute(i);
+
+			if (ia.wType == APPLY_IMMUNE_STUN && !IS_SET(dwImmuneFlag, IMMUNE_STUN))
+				SET_BIT(dwImmuneFlag, IMMUNE_STUN);
+			else if (ia.wType == APPLY_IMMUNE_FALL && !IS_SET(dwImmuneFlag, IMMUNE_FALL))
+				SET_BIT(dwImmuneFlag, IMMUNE_FALL);
+			else if (ia.wType == APPLY_IMMUNE_SLOW && !IS_SET(dwImmuneFlag, IMMUNE_SLOW))
+				SET_BIT(dwImmuneFlag, IMMUNE_SLOW);
+		}
+	}
+
+	return dwImmuneFlag;
+}
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+void CItem::SetTransmutationVnum(DWORD blVnum)
+{
+	m_dwTransmutationVnum = blVnum;
+	Save();
+}
+
+DWORD CItem::GetTransmutationVnum() const
+{
+	return m_dwTransmutationVnum;
+}
+#endif
+
+#if defined(__SET_ITEM__)
+void CItem::SetItemSetValue(BYTE bSet)
+{
+	m_bSetValue = bSet;
+	UpdatePacket();
+}
+
+BYTE CItem::GetItemSetValue() const
+{
+	return m_bSetValue;
+}
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+void CItem::SetRefineElement(const TPlayerItemRefineElement* pTable)
+{
+	thecore_memcpy(&m_RefineElement, pTable, sizeof(m_RefineElement));
+
+	UpdatePacket();
+	Save();
+}
+
+void CItem::CopyElementTo(const LPITEM pItem)
+{
+	pItem->SetRefineElement(&m_RefineElement);
+}
+
+void CItem::UpgradeRefineElement(WORD wApplyType, BYTE bValue, BYTE bBonusValue)
+{
+	BYTE& bGrade = m_RefineElement.bGrade;
+	if (bGrade >= REFINE_ELEMENT_MAX)
+		return;
+
+	++bGrade;
+
+	m_RefineElement.abValue[bGrade - 1] = bValue;
+	m_RefineElement.abBonusValue[bGrade - 1] = bBonusValue;
+	m_RefineElement.wApplyType = wApplyType;
+
+	UpdatePacket();
+	Save();
+}
+
+void CItem::DowngradeRefineElement()
+{
+	BYTE& bGrade = m_RefineElement.bGrade;
+	if (bGrade == 0)
+		return;
+
+	--bGrade;
+
+	m_RefineElement.abValue[bGrade] = 0;
+	m_RefineElement.abBonusValue[bGrade] = 0;
+
+	if (bGrade == 0)
+		m_RefineElement.wApplyType = 0;
+
+	UpdatePacket();
+	Save();
+}
+
+void CItem::ChangeRefineElement(WORD wApplyType)
+{
+	m_RefineElement.wApplyType = wApplyType;
+
+	UpdatePacket();
+	Save();
+}
+
+BYTE CItem::GetRefineElementValue() const
+{
+	const BYTE& bGrade = m_RefineElement.bGrade;
+	if (bGrade == 0)
+		return 0;
+
+	BYTE bValue = 0;
+	for (BYTE bPos = 0; bPos < REFINE_ELEMENT_MAX && bPos < bGrade; ++bPos)
+		bValue += m_RefineElement.abValue[bPos];
+
+	return bValue;
+}
+
+BYTE CItem::GetRefineElementBonusValue() const
+{
+	const BYTE& bGrade = m_RefineElement.bGrade;
+	if (bGrade == 0)
+		return 0;
+
+	BYTE bValue = 0;
+	for (BYTE bPos = 0; bPos < REFINE_ELEMENT_MAX && bPos < bGrade; ++bPos)
+		bValue += m_RefineElement.abBonusValue[bPos];
+
+	return bValue;
+}
+#endif
+
+#if defined(__SOUL_SYSTEM__)
+EVENTFUNC(soul_timer_use_event)
+{
+	const item_vid_event_info* info = reinterpret_cast<const item_vid_event_info*>(event->info);
+	if (info == nullptr)
+		return 0;
+
+	LPITEM item = ITEM_MANAGER::instance().FindByVID(info->item_vid);
+	if (item == nullptr)
+		return 0;
+
+	long data = item->GetSocket(2);
+	if (data == 0)
+		data = item->GetValue(2);
+
+	long keep_time = data / 10000;
+	long max_time = item->GetLimitValue(1);
+	int min_time = 60;
+	long remain_count = data % 10000;
+
+	if (keep_time % min_time == 0 && keep_time > 0 && item->GetSocket(1) != TRUE)
+		if (const LPCHARACTER& ch = item->GetOwner())
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Soul System] Use %s to receive the effect.", LC_ITEM(item->GetVnum())));
+
+	if (keep_time >= max_time)
+		return 0;
+
+	auto new_data = ((keep_time + 1) * 10000) + remain_count;
+	item->SetSocket(2, new_data, false /* log */);
+
+	return PASSES_PER_SEC(test_server ? 1 : 60);
+}
+
+void CItem::StartSoulTimerUseEvent()
+{
+	if (m_pkSoulTimerUseEvent)
+		return;
+
+	item_vid_event_info* info = AllocEventInfo<item_vid_event_info>();
+	info->item_vid = GetVID();
+	m_pkSoulTimerUseEvent = event_create(soul_timer_use_event, info, PASSES_PER_SEC(test_server ? 1 : 60));
+}
+
+void CItem::ResetSoulTimerUseEvent()
+{
+	if (m_pkSoulTimerUseEvent)
+		event_cancel(&m_pkSoulTimerUseEvent);
+
+	StartSoulTimerUseEvent();
+}
+#endif
+
+#if defined(__GLOVE_SYSTEM__)
+DWORD CItem::GetRandomSungMaSocketValue(BYTE bType, int iRefineLevel, bool bMultiplier)
+{
+	/*
+	* NOTE : If you're planning to edit this function be very careful with its limitations.
+	* The maximum data size cannot be more than a `LONG_MAX` value and each parameter has to
+	* respect certain values.
+	*
+	* @param bType - Value5 of the Spirit Stone.
+	* @param iRefineLeveL - Level of the Spirit Stone.
+	* These parameters cannot be valued above 9!
+	*
+	* @param bMultiplier - Chance given to multiply the value of the bonus.
+	*
+	* Additional limitations to be respected:
+	*	- ApplyType < 999 !
+	*	- ApplyValue < 99 !
+	*
+	* Need Debugging?
+	*	. 2394230 APPLY_SUNGMA_STR		RefineLevel 4	Type 2	ApplyValue 30
+	*	. 2404230 APPLY_SUNGMA_HP		RefineLevel 4	Type 2	ApplyValue 30
+	*	. 2414230 APPLY_SUNGMA_MOVE		RefineLevel 4	Type 2	ApplyValue 30
+	*	. 2424230 APPLY_SUNGMA_IMMUNE	RefineLevel 4	Type 2	ApplyValue 30
+	*
+	* 20230511.Owsap
+	*/
+
+	if (bType >= 10 || iRefineLevel >= 10)
+	{
+		sys_err("CItem::GetRandomSungMaSocketValue:: bType %d (Value5) or iRefineLevel %d is too high to store in the socket data.", bType, iRefineLevel);
+		return 0;
+	}
+
+	std::vector<WORD> vApplyTypes
+	{
+		APPLY_SUNGMA_STR,
+		APPLY_SUNGMA_HP,
+		APPLY_SUNGMA_MOVE,
+		APPLY_SUNGMA_IMMUNE,
+	};
+
+	const BYTE bDefaultValues[] = { 1, 3, 6, 9, 15 };
+	WORD wApplyType = vApplyTypes[number(0, (vApplyTypes.size() - 1))];
+
+	// DUPLICATE_APPLY_TYPE_FIX
+	std::unordered_set<WORD> wRepeatedSet;
+	for (BYTE bSocketIndex = 0; bSocketIndex < ITEM_SOCKET_MAX_NUM; ++bSocketIndex)
+	{
+		const DWORD dwData = GetSocket(bSocketIndex);
+		if (dwData < 1000000)
+			continue;
+
+		const WORD wSocketApplyType = (dwData / 10000) % 1000;
+		if (std::find(vApplyTypes.begin(), vApplyTypes.end(), wSocketApplyType) != vApplyTypes.end())
+			wRepeatedSet.emplace(wSocketApplyType);
+	}
+
+	bool bCheckRepeat = true;
+	while (bCheckRepeat)
+	{
+		wApplyType = vApplyTypes[number(0, (vApplyTypes.size() - 1))];
+		if (wRepeatedSet.count(wApplyType) == 0)
+			bCheckRepeat = false;
+	}
+	// END_OF_DUPLICATE_APPLY_TYPE_FIX
+
+	long lValue = bDefaultValues[iRefineLevel];
+	if (lValue >= 100)
+	{
+		sys_err("CItem::GetRandomSungMaSocketValue:: ApplyValue %ld is too high to store in the socket data.", lValue);
+		return 0;
+	}
+
+	if (bMultiplier)
+		lValue *= 2;
+
+	DWORD dwData = (wApplyType * 10000) + (iRefineLevel * 1000) + (bType * 100) + lValue;
+	if (dwData >= LONG_MAX)
+	{
+		sys_err("CItem::GetRandomSungMaSocketValue:: Unsupported data!");
+		return 0;
+	}
+
+	return dwData;
+}
+#endif
+
+#ifdef __OFFLINE_SHOP__
+void CItem::CopySockets(std::array<int32_t, ITEM_SOCKET_MAX_NUM>& sockets)
+{
+	std::copy(std::begin(m_alSockets), std::end(m_alSockets), sockets.begin());
+}
+
+void CItem::CopyAttributes(std::array<TPlayerItemAttribute, ITEM_ATTRIBUTE_MAX_NUM>& attributes)
+{
+	std::copy(std::begin(m_aAttr), std::end(m_aAttr), attributes.begin());
+}
+
+#if defined(__ITEM_APPLY_RANDOM__)
+void CItem::CopyApplyRandom(std::array<TPlayerItemAttribute, ITEM_APPLY_MAX_NUM>& ApplyRandom)
+{
+	std::copy(std::begin(m_aApplyRandom), std::end(m_aApplyRandom), ApplyRandom.begin());
+}
+#endif
+#endif
diff --git a/server/server/home/metin2/Source/Server/game/src/item.h b/server/server/home/metin2/Source/Server/game/src/item.h
index 5e40f81..954f6cb 100644
--- a/server/server/home/metin2/Source/Server/game/src/item.h
+++ b/server/server/home/metin2/Source/Server/game/src/item.h
@@ -1,535 +1,535 @@
-#ifndef __INC_ITEM_H__
-#define __INC_ITEM_H__
-
-#include "entity.h"
-#include "../common/VnumHelper.h"
-#if defined(__ITEM_APPLY_RANDOM__)
-#	include "item_apply_random_table.h"
-#endif
-
-class CItem : public CEntity
-{
-protected:
-	// override methods from ENTITY class
-	virtual void EncodeInsertPacket(LPENTITY entity);
-	virtual void EncodeRemovePacket(LPENTITY entity);
-
-public:
-	CItem(DWORD dwVnum = -1);
-	virtual ~CItem();
-
-	int GetLevelLimit();
-	int GetDurationLimit();
-
-	bool CheckItemUseLevel(int nLevel);
-	POINT_VALUE FindApplyValue(POINT_TYPE wApplyType);
-
-	bool IsStackable();
-
-	void Initialize();
-	void Destroy();
-
-	void Save();
-
-	void SetWindow(BYTE b) { m_bWindow = b; }
-	BYTE GetWindow() { return m_bWindow; }
-
-	void SetID(DWORD id) { m_dwID = id; }
-	DWORD GetID() { return m_dwID; }
-
-	void SetProto(const TItemTable* table);
-	TItemTable const* GetProto() { return m_pProto; }
-
-	int GetGold();
-	int GetShopSellPrice();
-	int GetShopBuyPrice();
-	const char* GetName() { return m_pProto ? m_pProto->szLocaleName : NULL; }
-	const char* GetBaseName() { return m_pProto ? m_pProto->szName : NULL; }
-	BYTE GetSize() { return m_pProto ? m_pProto->bSize : 0; }
-
-	void SetFlag(long flag) { m_lFlag = flag; }
-	long GetFlag() { return m_lFlag; }
-
-	void AddFlag(long bit);
-	void RemoveFlag(long bit);
-
-	DWORD GetWearFlag() { return m_pProto ? m_pProto->dwWearFlags : 0; }
-	uint64_t GetAntiFlag() { return m_pProto ? m_pProto->ullAntiFlags : 0; }
-	DWORD GetImmuneFlag() { return m_pProto ? m_pProto->dwImmuneFlag : 0; }
-
-	void SetVID(DWORD vid) { m_dwVID = vid; }
-	DWORD GetVID() { return m_dwVID; }
-
-	bool SetCount(DWORD count);
-	DWORD GetCount();
-
-	// GetVnum과 GetOriginalVnum에 대한 comment
-	// GetVnum은 Masking 된 Vnum이다. 이를 사용함으로써, 아이템의 실제 Vnum은 10이지만, Vnum이 20인 것처럼 동작할 수 있는 것이다.
-	// Masking 값은 ori_to_new.txt에서 정의된 값이다.
-	// GetOriginalVnum은 아이템 고유의 Vnum으로, 로그 남길 때, 클라이언트에 아이템 정보 보낼 때, 저장할 때는 이 Vnum을 사용하여야 한다.
-	DWORD GetVnum() const { return m_dwMaskVnum ? m_dwMaskVnum : m_dwVnum; }
-	DWORD GetOriginalVnum() const { return m_dwVnum; }
-	BYTE GetType() const { return m_pProto ? m_pProto->bType : 0; }
-	BYTE GetSubType() const { return m_pProto ? m_pProto->bSubType : 0; }
-	BYTE GetLimitType(DWORD idx) const { return m_pProto ? m_pProto->aLimits[idx].bType : 0; }
-	long GetLimitValue(DWORD idx) const { return m_pProto ? m_pProto->aLimits[idx].lValue : 0; }
-
-	bool IsSocketModifyingItem()
-	{
-		return GetType() == ITEM_USE && (GetSubType() == USE_PUT_INTO_BELT_SOCKET
-			|| GetSubType() == USE_PUT_INTO_RING_SOCKET
-			|| GetSubType() == USE_PUT_INTO_ACCESSORY_SOCKET
-			|| GetSubType() == USE_ADD_ACCESSORY_SOCKET
-			|| GetSubType() == USE_CLEAN_SOCKET);
-	}
-
-	// Weapon
-	bool IsWeapon() { return GetType() == ITEM_WEAPON; }
-	bool IsMainWeapon()
-	{
-		return GetType() == ITEM_WEAPON && (
-			GetSubType() == WEAPON_SWORD
-			|| GetSubType() == WEAPON_DAGGER
-			|| GetSubType() == WEAPON_BOW
-			|| GetSubType() == WEAPON_TWO_HANDED
-			|| GetSubType() == WEAPON_BELL
-			|| GetSubType() == WEAPON_FAN
-			|| GetSubType() == WEAPON_CLAW
-			);
-	}
-	bool IsSword() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_SWORD; }
-	bool IsDagger() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_DAGGER; }
-	bool IsBow() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_BOW; }
-	bool IsTwoHandSword() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_TWO_HANDED; }
-	bool IsBell() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_BELL; }
-	bool IsFan() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_FAN; }
-	bool IsArrow() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_ARROW; }
-	bool IsMountSpear() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_MOUNT_SPEAR; }
-#if defined(__QUIVER_SYSTEM__)
-	bool IsQuiver() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_QUIVER; }
-#endif
-	bool IsClaw() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_CLAW; }
-
-	// Armor
-	bool IsArmor() { return GetType() == ITEM_ARMOR; }
-	bool IsArmorType(BYTE bArmorType) { return GetType() == ITEM_ARMOR && GetSubType() == bArmorType; }
-	bool IsArmorBody() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_BODY; }
-	bool IsHelmet() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_HEAD; }
-	bool IsShield() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_SHIELD; }
-	bool IsWrist() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_WRIST; }
-	bool IsShoe() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_FOOTS; }
-	bool IsNecklace() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_NECK; }
-	bool IsEarRing() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_EAR; }
-
-	bool IsBelt() { return GetType() == ITEM_BELT; }
-#if defined(__PENDANT_SYSTEM__)
-	bool IsPendant() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_PENDANT; }
-#endif
-#if defined(__GLOVE_SYSTEM__)
-	bool IsGlove() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_GLOVE; }
-#endif
-	bool IsRing() { return GetType() == ITEM_RING; }
-	bool IsUnique() { return GetType() == ITEM_UNIQUE; }
-	bool IsCostume() { return GetType() == ITEM_COSTUME; }
-	bool IsCostumeHair() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_HAIR; }
-	bool IsCostumeBody() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_BODY; }
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	bool IsCostumeMount() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_MOUNT; }
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	bool IsCostumeAcce() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_ACCE; }
-	bool IsAcceReverseScroll() { return GetVnum() == 39046 || GetVnum() == 90000; }
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	bool IsCostumeAura() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_AURA; }
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-	bool IsCostumeWeapon() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_WEAPON; }
-#endif
-	bool IsPet() { return GetType() == ITEM_PET && (GetSubType() == PET_PAY || GetSubType() == PET_UPBRINGING); }
-#if defined(__EXPRESSING_EMOTIONS__)
-	bool IsEmotionPack() { return GetType() == ITEM_USE && GetSubType() == USE_EMOTION_PACK; }
-#endif
-	bool IsOldHair() { return GetVnum() >= 74001 && GetVnum() <= 75620; }
-
-	DWORD GetRealImmuneFlag();
-
-	long GetValue(DWORD idx);
-
-	void SetCell(LPCHARACTER ch, WORD pos) { m_pOwner = ch, m_wCell = pos; }
-	WORD GetCell() { return m_wCell; }
-
-	LPITEM RemoveFromCharacter();
-
-	bool AddToCharacter(LPCHARACTER ch, const TItemPos& Cell
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		, bool isHighLight = true
-#endif
-	);
-
-	LPCHARACTER GetOwner() { return m_pOwner; }
-
-	LPITEM RemoveFromGround();
-	bool AddToGround(long lMapIndex, const PIXEL_POSITION& pos, bool skipOwnerCheck = false);
-
-	int FindEquipCell(LPCHARACTER ch, int bCandidateCell = -1);
-	bool IsEquipped() const { return m_bEquipped; }
-	bool EquipTo(LPCHARACTER ch, BYTE bWearCell);
-	bool IsEquipable() const;
-
-	bool CanUsedBy(LPCHARACTER ch);
-
-	bool DistanceValid(LPCHARACTER ch);
-
-	void UpdatePacket();
-	void UsePacketEncode(LPCHARACTER ch, LPCHARACTER victim, struct packet_item_use* packet);
-
-	void SetExchanging(bool isOn = true);
-	bool IsExchanging() { return m_bExchanging; }
-
-#if defined(__MOVE_COSTUME_ATTR__)
-	bool CanChangeCostumeAttr() const;
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-	long GetWearingLevelLimit() const;
-	bool IsHairDye() const;
-#endif
-
-	bool IsPolymorphItem();
-
-	void ModifyPoints(bool bAdd); // 아이템의 효과를 캐릭터에 부여 한다. bAdd가 false이면 제거함
-
-	bool CreateSocket(BYTE bSlot, BYTE bGold);
-	const long* GetSockets() { return &m_alSockets[0]; }
-	long GetSocket(int i) { return (i >= 0 && i < ITEM_SOCKET_MAX_NUM) ? m_alSockets[i] : 0; }
-
-	void SetSockets(const long* al);
-	void SetSocket(int i, long v, bool bLog = true);
-
-	int GetSocketCount();
-	bool AddSocket();
-
-	const TPlayerItemAttribute* GetAttributes() { return m_aAttr; }
-	const TPlayerItemAttribute& GetAttribute(BYTE bIndex) { return m_aAttr[bIndex]; }
-
-#if defined(__ITEM_APPLY_RANDOM__)
-	const TPlayerItemAttribute* GetRandomApplies() { return m_aApplyRandom; }
-	const TPlayerItemAttribute& GetRandomApply(BYTE bIndex) { return m_aApplyRandom[bIndex]; }
-
-	void GetRandomApplyTable(TPlayerItemAttribute* pApplyRandomTable, BYTE bGetType = CApplyRandomTable::GET_CURRENT);
-	void SetRandomApplies(const TPlayerItemAttribute* c_pApplyRandom);
-
-	POINT_TYPE GetRandomApplyType(BYTE bIndex) { return m_aApplyRandom[bIndex].wType; }
-	POINT_VALUE GetRandomApplyValue(BYTE bIndex) { return m_aApplyRandom[bIndex].lValue; }
-	BYTE GetRandomApplyPath(BYTE bIndex) { return m_aApplyRandom[bIndex].bPath; }
-#endif
-
-#if defined(__GLOVE_SYSTEM__)
-	DWORD GetRandomSungMaSocketValue(BYTE bType, int iRefineLevel, bool bMultiplier);
-#endif
-
-	POINT_TYPE GetAttributeType(BYTE bIndex) { return m_aAttr[bIndex].wType; }
-	POINT_VALUE GetAttributeValue(BYTE bIndex) { return m_aAttr[bIndex].lValue; }
-
-	void SetAttributes(const TPlayerItemAttribute* c_pAttribute);
-
-	int FindAttribute(POINT_TYPE wType);
-	bool RemoveAttributeAt(int index);
-	bool RemoveAttributeType(POINT_TYPE wType);
-
-	bool HasAttr(POINT_TYPE wApply);
-	bool HasRareAttr(POINT_TYPE wApply);
-
-	void SetDestroyEvent(LPEVENT pkEvent);
-	void StartDestroyEvent(int iSec = 300);
-
-	DWORD GetRefinedVnum() { return m_pProto ? m_pProto->dwRefinedVnum : 0; }
-	DWORD GetRefineFromVnum();
-	int GetRefineLevel();
-
-	void SetSkipSave(bool b) { m_bSkipSave = b; }
-	bool GetSkipSave() { return m_bSkipSave; }
-
-	bool IsOwnership(LPCHARACTER ch);
-	void SetOwnership(LPCHARACTER ch, int iSec = 10);
-	void SetOwnershipEvent(LPEVENT pkEvent);
-
-	DWORD GetLastOwnerPID() { return m_dwLastOwnerPID; }
-
-	int GetAttributeSetIndex(); // 속성 붙는것을 지정한 배열의 어느 인덱스를 사용하는지 돌려준다.
-	void AlterToMagicItem(int iSecondPct = 0, int iThirdPct = 0);
-	void AlterToSocketItem(int iSocketCount);
-
-	WORD GetRefineSet() { return m_pProto ? m_pProto->wRefineSet : 0; }
-	DWORD Get67AttrMaterial() { return m_pProto ? m_pProto->dw67AttrMaterial : 0; }
-
-	void StartUniqueExpireEvent();
-	void SetUniqueExpireEvent(LPEVENT pkEvent);
-
-	void StartTimerBasedOnWearExpireEvent();
-	void SetTimerBasedOnWearExpireEvent(LPEVENT pkEvent);
-
-	void StartRealTimeExpireEvent();
-#if defined(__GROWTH_PET_SYSTEM__)
-	void StopRealTimeExpireEvent();
-#endif
-	bool IsRealTimeItem();
-	bool IsUsedTimeItem();
-
-	void StopUniqueExpireEvent();
-	void StopTimerBasedOnWearExpireEvent();
-	void StopAccessorySocketExpireEvent();
-
-	// 일단 REAL_TIME과 TIMER_BASED_ON_WEAR 아이템에 대해서만 제대로 동작함.
-	int GetDuration();
-
-	BYTE GetAttributeCount();
-	void ClearAttribute();
-	void ClearAllAttribute();
-	void ChangeAttribute(const int* aiChangeProb = NULL);
-	void AddAttribute();
-	void AddAttribute(POINT_TYPE dwType, POINT_VALUE llValue);
-#if defined(__CHANGED_ATTR__)
-	void GetSelectAttr(TPlayerItemAttribute(&arr)[ITEM_ATTRIBUTE_MAX_NUM]);
-#endif
-
-	void ApplyAddon(int iAddonType);
-
-	int GetSpecialGroup() const;
-	bool IsSameSpecialGroup(const LPITEM item) const;
-
-	// ACCESSORY_REFINE
-	// 액세서리에 광산을 통해 소켓을 추가
-	bool IsAccessoryForSocket();
-	bool IsRemovableSocket();
-
-	int GetAccessorySocketGrade();
-	int GetAccessorySocketMaxGrade();
-	int GetAccessorySocketDownGradeTime();
-
-	void SetAccessorySocketGrade(int iGrade);
-	void SetAccessorySocketMaxGrade(int iMaxGrade);
-	void SetAccessorySocketDownGradeTime(DWORD time);
-
-	void AccessorySocketDegrade();
-
-	// 악세사리 를 아이템에 밖았을때 타이머 돌아가는것( 구리, 등 )
-	void StartAccessorySocketExpireEvent();
-	void SetAccessorySocketExpireEvent(LPEVENT pkEvent);
-
-	bool CanPutInto(LPITEM item);
-	// END_OF_ACCESSORY_REFINE
-
-	void CopyAttributeTo(LPITEM pItem);
-#if defined(__ITEM_APPLY_RANDOM__)
-	void CopyRandomAppliesTo(LPITEM pItem);
-#endif
-	void CopySocketTo(LPITEM pItem);
-
-	BYTE GetRareAttrCount();
-	bool AddRareAttribute();
-	bool ChangeRareAttribute();
-
-	void AttrLog();
-
-	void Lock(bool f) { m_isLocked = f; }
-	bool isLocked() const { return m_isLocked; }
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	void SetTransmutationVnum(DWORD blVnum);
-	DWORD GetTransmutationVnum() const;
-#endif
-
-#if defined(__SET_ITEM__)
-	void SetItemSetValue(BYTE bSet);
-	BYTE GetItemSetValue() const;
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-public:
-	void SetRefineElement(const TPlayerItemRefineElement* pTable);
-	void CopyElementTo(const LPITEM pItem);
-
-	void UpgradeRefineElement(WORD wApplyType, BYTE bValue, BYTE bBonus);
-	void DowngradeRefineElement();
-	void ChangeRefineElement(WORD wApplyType);
-
-	BYTE GetRefineElementGrade() const { return m_RefineElement.bGrade; }
-	WORD GetRefineElementApplyType() const { return m_RefineElement.wApplyType; }
-	BYTE GetRefineElementValue() const;
-	BYTE GetRefineElementBonusValue() const;
-
-	BYTE GetRefineElementValue(BYTE bGrade) const { return m_RefineElement.abValue[bGrade]; }
-	BYTE GetRefineElementBonusValue(BYTE bGrade) const { return m_RefineElement.abBonusValue[bGrade]; }
-
-	const TPlayerItemRefineElement* GetRefineElement() const { return &m_RefineElement; }
-private:
-	TPlayerItemRefineElement m_RefineElement;
-#endif
-
-private:
-	void SetAttribute(BYTE bIndex, POINT_TYPE wType, POINT_VALUE lValue);
-#if defined(__ITEM_APPLY_RANDOM__)
-	void SetRandomApply(BYTE bIndex, POINT_TYPE wType, POINT_VALUE lValue, BYTE bPath);
-#endif
-public:
-	void SetForceAttribute(BYTE bIndex, POINT_TYPE wType, POINT_VALUE lValue);
-#if defined(__ITEM_APPLY_RANDOM__)
-	void SetForceRandomApply(BYTE bIndex, POINT_TYPE wType, POINT_VALUE lValue, BYTE bPath);
-#endif
-
-protected:
-	bool EquipEx(bool is_equip);
-	bool Unequip();
-
-	void AddAttr(POINT_TYPE wApply, BYTE bLevel);
-	void PutAttribute(const int* aiAttrPercentTable);
-	void PutAttributeWithLevel(BYTE bLevel);
-
-public:
-	friend class CInputDB;
-	bool OnAfterCreatedItem(); // 서버상에 아이템이 모든 정보와 함께 완전히 생성(로드)된 후 불리우는 함수.
-
-public:
-	bool IsRideItem();
-
-	void ClearMountAttributeAndAffect();
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	DWORD GetMountVnum();
-#endif
-
-	// 독일에서 기존 캐시 아이템과 같지만, 교환 가능한 캐시 아이템을 만든다고 하여,
-	// 오리지널 아이템에, 교환 금지 플래그만 삭제한 새로운 아이템들을 새로운 아이템 대역에 할당하였다.
-	// 문제는 새로운 아이템도 오리지널 아이템과 같은 효과를 내야하는데,
-	// 서버건, 클라건, vnum 기반으로 되어있어
-	// 새로운 vnum을 죄다 서버에 새로 다 박아야하는 안타까운 상황에 맞닿았다.
-	// 그래서 새 vnum의 아이템이면, 서버에서 돌아갈 때는 오리지널 아이템 vnum으로 바꿔서 돌고 하고,
-	// 저장할 때에 본래 vnum으로 바꿔주도록 한다.
-
-	// Mask vnum은 어떤 이유(ex. 위의 상황)로 인해 vnum이 바뀌어 돌아가는 아이템을 위해 있다.
-	void SetMaskVnum(DWORD vnum) { m_dwMaskVnum = vnum; }
-	DWORD GetMaskVnum() { return m_dwMaskVnum; }
-	bool IsMaskedItem() { return m_dwMaskVnum != 0; }
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	// 용혼석
-	bool IsDragonSoul();
-
-	int GiveMoreTime_Per(float fPercent);
-	int GiveMoreTime_Fix(DWORD dwTime);
-#endif
-
-private:
-	TItemTable const* m_pProto; // 프로토 타잎
-
-	DWORD m_dwVnum;
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD m_dwTransmutationVnum;
-#endif
-#if defined(__SET_ITEM__)
-	BYTE m_bSetValue;
-#endif
-	LPCHARACTER m_pOwner;
-
-	BYTE m_bWindow; // 현재 아이템이 위치한 윈도우 
-	DWORD m_dwID; // 고유번호
-	bool m_bEquipped; // 장착 되었는가?
-	DWORD m_dwVID; // VID
-	WORD m_wCell; // 위치
-	DWORD m_dwCount; // 개수
-	long m_lFlag; // 추가 flag
-	DWORD m_dwLastOwnerPID; // 마지막 가지고 있었던 사람의 PID
-
-	bool m_bExchanging; ///< 현재 교환중 상태
-
-	long m_alSockets[ITEM_SOCKET_MAX_NUM]; // 아이템 소캣
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute m_aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-	TPlayerItemAttribute m_aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-
-	LPEVENT m_pkDestroyEvent;
-	LPEVENT m_pkExpireEvent;
-	LPEVENT m_pkUniqueExpireEvent;
-	LPEVENT m_pkTimerBasedOnWearExpireEvent;
-	LPEVENT m_pkRealTimeExpireEvent;
-	LPEVENT m_pkAccessorySocketExpireEvent;
-	LPEVENT m_pkOwnershipEvent;
-
-	DWORD m_dwOwnershipPID;
-
-	bool m_bSkipSave;
-
-	bool m_isLocked;
-
-	DWORD m_dwMaskVnum;
-	DWORD m_dwSIGVnum;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-public:
-	bool CanSealItem() const;
-
-	void SealItem(long lSealDate = U_SEAL_DATE_DEFAULT_TIMESTAMP);
-	bool IsSealed() const { return m_lSealDate != E_SEAL_DATE_DEFAULT_TIMESTAMP; }
-	long GetSealDate() const { return m_lSealDate; }
-
-	void StartSealDateExpireTimerEvent();
-	void StopSealDateExpireTimerEvent();
-
-private:
-	long m_lSealDate;
-	LPEVENT m_pkSealDateExpireEvent;
-#endif
-
-#if defined(__SOUL_SYSTEM__)
-public:
-	void StartSoulTimerUseEvent();
-	void ResetSoulTimerUseEvent();
-private:
-	LPEVENT m_pkSoulTimerUseEvent;
-#endif
-
-public:
-	void SetSIGVnum(DWORD dwSIG)
-	{
-		m_dwSIGVnum = dwSIG;
-	}
-	DWORD GetSIGVnum() const
-	{
-		return m_dwSIGVnum;
-	}
-#ifdef __OFFLINE_SHOP__
-public:
-	void CopySockets(std::array<int32_t, ITEM_SOCKET_MAX_NUM>& sockets);
-	void CopyAttributes(std::array<TPlayerItemAttribute, ITEM_ATTRIBUTE_MAX_NUM>& attributes);
-#if defined(__ITEM_APPLY_RANDOM__)
-	void CopyApplyRandom(std::array<TPlayerItemAttribute, ITEM_APPLY_MAX_NUM>& ApplyRandom);
-#endif
-#endif
-};
-
-EVENTINFO(item_event_info)
-{
-	LPITEM item;
-	char szOwnerName[CHARACTER_NAME_MAX_LEN];
-
-	item_event_info()
-		: item(0)
-	{
-		::memset(szOwnerName, 0, CHARACTER_NAME_MAX_LEN);
-	}
-};
-
-EVENTINFO(item_vid_event_info)
-{
-	DWORD item_vid;
-
-	item_vid_event_info()
-		: item_vid(0)
-	{
-	}
-};
-
-#endif // __INC_ITEM_H__
+#ifndef __INC_ITEM_H__
+#define __INC_ITEM_H__
+
+#include "entity.h"
+#include "../common/VnumHelper.h"
+#if defined(__ITEM_APPLY_RANDOM__)
+#	include "item_apply_random_table.h"
+#endif
+
+class CItem : public CEntity
+{
+protected:
+	// override methods from ENTITY class
+	virtual void EncodeInsertPacket(LPENTITY entity);
+	virtual void EncodeRemovePacket(LPENTITY entity);
+
+public:
+	CItem(DWORD dwVnum = -1);
+	virtual ~CItem();
+
+	int GetLevelLimit();
+	int GetDurationLimit();
+
+	bool CheckItemUseLevel(int nLevel);
+	POINT_VALUE FindApplyValue(POINT_TYPE wApplyType);
+
+	bool IsStackable();
+
+	void Initialize();
+	void Destroy();
+
+	void Save();
+
+	void SetWindow(BYTE b) { m_bWindow = b; }
+	BYTE GetWindow() { return m_bWindow; }
+
+	void SetID(DWORD id) { m_dwID = id; }
+	DWORD GetID() { return m_dwID; }
+
+	void SetProto(const TItemTable* table);
+	TItemTable const* GetProto() { return m_pProto; }
+
+	int GetGold();
+	int GetShopSellPrice();
+	int GetShopBuyPrice();
+	const char* GetName() { return m_pProto ? m_pProto->szLocaleName : NULL; }
+	const char* GetBaseName() { return m_pProto ? m_pProto->szName : NULL; }
+	BYTE GetSize() { return m_pProto ? m_pProto->bSize : 0; }
+
+	void SetFlag(long flag) { m_lFlag = flag; }
+	long GetFlag() { return m_lFlag; }
+
+	void AddFlag(long bit);
+	void RemoveFlag(long bit);
+
+	DWORD GetWearFlag() { return m_pProto ? m_pProto->dwWearFlags : 0; }
+	uint64_t GetAntiFlag() { return m_pProto ? m_pProto->ullAntiFlags : 0; }
+	DWORD GetImmuneFlag() { return m_pProto ? m_pProto->dwImmuneFlag : 0; }
+
+	void SetVID(DWORD vid) { m_dwVID = vid; }
+	DWORD GetVID() { return m_dwVID; }
+
+	bool SetCount(DWORD count);
+	DWORD GetCount();
+
+	// GetVnum GetOriginalVnum  comment
+	// GetVnum Masking  Vnum甄. 見 館,   Vnum 10, Vnum 20 처   獵 甄.
+	// Masking  ori_to_new.txt 풩 甄.
+	// GetOriginalVnum   Vnum, 慣  , 클潔트    ,    Vnum 臼 磯.
+	DWORD GetVnum() const { return m_dwMaskVnum ? m_dwMaskVnum : m_dwVnum; }
+	DWORD GetOriginalVnum() const { return m_dwVnum; }
+	BYTE GetType() const { return m_pProto ? m_pProto->bType : 0; }
+	BYTE GetSubType() const { return m_pProto ? m_pProto->bSubType : 0; }
+	BYTE GetLimitType(DWORD idx) const { return m_pProto ? m_pProto->aLimits[idx].bType : 0; }
+	long GetLimitValue(DWORD idx) const { return m_pProto ? m_pProto->aLimits[idx].lValue : 0; }
+
+	bool IsSocketModifyingItem()
+	{
+		return GetType() == ITEM_USE && (GetSubType() == USE_PUT_INTO_BELT_SOCKET
+			|| GetSubType() == USE_PUT_INTO_RING_SOCKET
+			|| GetSubType() == USE_PUT_INTO_ACCESSORY_SOCKET
+			|| GetSubType() == USE_ADD_ACCESSORY_SOCKET
+			|| GetSubType() == USE_CLEAN_SOCKET);
+	}
+
+	// Weapon
+	bool IsWeapon() { return GetType() == ITEM_WEAPON; }
+	bool IsMainWeapon()
+	{
+		return GetType() == ITEM_WEAPON && (
+			GetSubType() == WEAPON_SWORD
+			|| GetSubType() == WEAPON_DAGGER
+			|| GetSubType() == WEAPON_BOW
+			|| GetSubType() == WEAPON_TWO_HANDED
+			|| GetSubType() == WEAPON_BELL
+			|| GetSubType() == WEAPON_FAN
+			|| GetSubType() == WEAPON_CLAW
+			);
+	}
+	bool IsSword() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_SWORD; }
+	bool IsDagger() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_DAGGER; }
+	bool IsBow() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_BOW; }
+	bool IsTwoHandSword() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_TWO_HANDED; }
+	bool IsBell() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_BELL; }
+	bool IsFan() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_FAN; }
+	bool IsArrow() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_ARROW; }
+	bool IsMountSpear() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_MOUNT_SPEAR; }
+#if defined(__QUIVER_SYSTEM__)
+	bool IsQuiver() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_QUIVER; }
+#endif
+	bool IsClaw() { return GetType() == ITEM_WEAPON && GetSubType() == WEAPON_CLAW; }
+
+	// Armor
+	bool IsArmor() { return GetType() == ITEM_ARMOR; }
+	bool IsArmorType(BYTE bArmorType) { return GetType() == ITEM_ARMOR && GetSubType() == bArmorType; }
+	bool IsArmorBody() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_BODY; }
+	bool IsHelmet() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_HEAD; }
+	bool IsShield() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_SHIELD; }
+	bool IsWrist() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_WRIST; }
+	bool IsShoe() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_FOOTS; }
+	bool IsNecklace() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_NECK; }
+	bool IsEarRing() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_EAR; }
+
+	bool IsBelt() { return GetType() == ITEM_BELT; }
+#if defined(__PENDANT_SYSTEM__)
+	bool IsPendant() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_PENDANT; }
+#endif
+#if defined(__GLOVE_SYSTEM__)
+	bool IsGlove() { return GetType() == ITEM_ARMOR && GetSubType() == ARMOR_GLOVE; }
+#endif
+	bool IsRing() { return GetType() == ITEM_RING; }
+	bool IsUnique() { return GetType() == ITEM_UNIQUE; }
+	bool IsCostume() { return GetType() == ITEM_COSTUME; }
+	bool IsCostumeHair() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_HAIR; }
+	bool IsCostumeBody() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_BODY; }
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	bool IsCostumeMount() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_MOUNT; }
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	bool IsCostumeAcce() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_ACCE; }
+	bool IsAcceReverseScroll() { return GetVnum() == 39046 || GetVnum() == 90000; }
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	bool IsCostumeAura() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_AURA; }
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+	bool IsCostumeWeapon() { return GetType() == ITEM_COSTUME && GetSubType() == COSTUME_WEAPON; }
+#endif
+	bool IsPet() { return GetType() == ITEM_PET && (GetSubType() == PET_PAY || GetSubType() == PET_UPBRINGING); }
+#if defined(__EXPRESSING_EMOTIONS__)
+	bool IsEmotionPack() { return GetType() == ITEM_USE && GetSubType() == USE_EMOTION_PACK; }
+#endif
+	bool IsOldHair() { return GetVnum() >= 74001 && GetVnum() <= 75620; }
+
+	DWORD GetRealImmuneFlag();
+
+	long GetValue(DWORD idx);
+
+	void SetCell(LPCHARACTER ch, WORD pos) { m_pOwner = ch, m_wCell = pos; }
+	WORD GetCell() { return m_wCell; }
+
+	LPITEM RemoveFromCharacter();
+
+	bool AddToCharacter(LPCHARACTER ch, const TItemPos& Cell
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		, bool isHighLight = true
+#endif
+	);
+
+	LPCHARACTER GetOwner() { return m_pOwner; }
+
+	LPITEM RemoveFromGround();
+	bool AddToGround(long lMapIndex, const PIXEL_POSITION& pos, bool skipOwnerCheck = false);
+
+	int FindEquipCell(LPCHARACTER ch, int bCandidateCell = -1);
+	bool IsEquipped() const { return m_bEquipped; }
+	bool EquipTo(LPCHARACTER ch, BYTE bWearCell);
+	bool IsEquipable() const;
+
+	bool CanUsedBy(LPCHARACTER ch);
+
+	bool DistanceValid(LPCHARACTER ch);
+
+	void UpdatePacket();
+	void UsePacketEncode(LPCHARACTER ch, LPCHARACTER victim, struct packet_item_use* packet);
+
+	void SetExchanging(bool isOn = true);
+	bool IsExchanging() { return m_bExchanging; }
+
+#if defined(__MOVE_COSTUME_ATTR__)
+	bool CanChangeCostumeAttr() const;
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+	long GetWearingLevelLimit() const;
+	bool IsHairDye() const;
+#endif
+
+	bool IsPolymorphItem();
+
+	void ModifyPoints(bool bAdd); //  효 캐沽 恝 磯. bAdd false見 
+
+	bool CreateSocket(BYTE bSlot, BYTE bGold);
+	const long* GetSockets() { return &m_alSockets[0]; }
+	long GetSocket(int i) { return (i >= 0 && i < ITEM_SOCKET_MAX_NUM) ? m_alSockets[i] : 0; }
+
+	void SetSockets(const long* al);
+	void SetSocket(int i, long v, bool bLog = true);
+
+	int GetSocketCount();
+	bool AddSocket();
+
+	const TPlayerItemAttribute* GetAttributes() { return m_aAttr; }
+	const TPlayerItemAttribute& GetAttribute(BYTE bIndex) { return m_aAttr[bIndex]; }
+
+#if defined(__ITEM_APPLY_RANDOM__)
+	const TPlayerItemAttribute* GetRandomApplies() { return m_aApplyRandom; }
+	const TPlayerItemAttribute& GetRandomApply(BYTE bIndex) { return m_aApplyRandom[bIndex]; }
+
+	void GetRandomApplyTable(TPlayerItemAttribute* pApplyRandomTable, BYTE bGetType = CApplyRandomTable::GET_CURRENT);
+	void SetRandomApplies(const TPlayerItemAttribute* c_pApplyRandom);
+
+	POINT_TYPE GetRandomApplyType(BYTE bIndex) { return m_aApplyRandom[bIndex].wType; }
+	POINT_VALUE GetRandomApplyValue(BYTE bIndex) { return m_aApplyRandom[bIndex].lValue; }
+	BYTE GetRandomApplyPath(BYTE bIndex) { return m_aApplyRandom[bIndex].bPath; }
+#endif
+
+#if defined(__GLOVE_SYSTEM__)
+	DWORD GetRandomSungMaSocketValue(BYTE bType, int iRefineLevel, bool bMultiplier);
+#endif
+
+	POINT_TYPE GetAttributeType(BYTE bIndex) { return m_aAttr[bIndex].wType; }
+	POINT_VALUE GetAttributeValue(BYTE bIndex) { return m_aAttr[bIndex].lValue; }
+
+	void SetAttributes(const TPlayerItemAttribute* c_pAttribute);
+
+	int FindAttribute(POINT_TYPE wType);
+	bool RemoveAttributeAt(int index);
+	bool RemoveAttributeType(POINT_TYPE wType);
+
+	bool HasAttr(POINT_TYPE wApply);
+	bool HasRareAttr(POINT_TYPE wApply);
+
+	void SetDestroyEvent(LPEVENT pkEvent);
+	void StartDestroyEvent(int iSec = 300);
+
+	DWORD GetRefinedVnum() { return m_pProto ? m_pProto->dwRefinedVnum : 0; }
+	DWORD GetRefineFromVnum();
+	int GetRefineLevel();
+
+	void SetSkipSave(bool b) { m_bSkipSave = b; }
+	bool GetSkipSave() { return m_bSkipSave; }
+
+	bool IsOwnership(LPCHARACTER ch);
+	void SetOwnership(LPCHARACTER ch, int iSec = 10);
+	void SetOwnershipEvent(LPEVENT pkEvent);
+
+	DWORD GetLastOwnerPID() { return m_dwLastOwnerPID; }
+
+	int GetAttributeSetIndex(); // 憺 募째  瓦  琯 求 娩.
+	void AlterToMagicItem(int iSecondPct = 0, int iThirdPct = 0);
+	void AlterToSocketItem(int iSocketCount);
+
+	WORD GetRefineSet() { return m_pProto ? m_pProto->wRefineSet : 0; }
+	DWORD Get67AttrMaterial() { return m_pProto ? m_pProto->dw67AttrMaterial : 0; }
+
+	void StartUniqueExpireEvent();
+	void SetUniqueExpireEvent(LPEVENT pkEvent);
+
+	void StartTimerBasedOnWearExpireEvent();
+	void SetTimerBasedOnWearExpireEvent(LPEVENT pkEvent);
+
+	void StartRealTimeExpireEvent();
+#if defined(__GROWTH_PET_SYSTEM__)
+	bool IsGrowthPet() { return GetType() == ITEM_PET && GetSubType() == PET_UPBRINGING; }
+#endif
+	bool IsRealTimeItem();
+	bool IsUsedTimeItem();
+
+	void StopUniqueExpireEvent();
+	void StopTimerBasedOnWearExpireEvent();
+	void StopAccessorySocketExpireEvent();
+
+	// 求 REAL_TIME TIMER_BASED_ON_WEAR 謗 漫  .
+	int GetDuration();
+
+	BYTE GetAttributeCount();
+	void ClearAttribute();
+	void ClearAllAttribute();
+	void ChangeAttribute(const int* aiChangeProb = NULL);
+	void AddAttribute();
+	void AddAttribute(POINT_TYPE dwType, POINT_VALUE llValue);
+#if defined(__CHANGED_ATTR__)
+	void GetSelectAttr(TPlayerItemAttribute(&arr)[ITEM_ATTRIBUTE_MAX_NUM]);
+#endif
+
+	void ApplyAddon(int iAddonType);
+
+	int GetSpecialGroup() const;
+	bool IsSameSpecialGroup(const LPITEM item) const;
+
+	// ACCESSORY_REFINE
+	// 硫    煞
+	bool IsAccessoryForSocket();
+	bool IsRemovableSocket();
+
+	int GetAccessorySocketGrade();
+	int GetAccessorySocketMaxGrade();
+	int GetAccessorySocketDownGradeTime();
+
+	void SetAccessorySocketGrade(int iGrade);
+	void SetAccessorySocketMaxGrade(int iMaxGrade);
+	void SetAccessorySocketDownGradeTime(DWORD time);
+
+	void AccessorySocketDegrade();
+
+	// 퓬潁  謗 訪 타見 튼째( ,  )
+	void StartAccessorySocketExpireEvent();
+	void SetAccessorySocketExpireEvent(LPEVENT pkEvent);
+
+	bool CanPutInto(LPITEM item);
+	// END_OF_ACCESSORY_REFINE
+
+	void CopyAttributeTo(LPITEM pItem);
+#if defined(__ITEM_APPLY_RANDOM__)
+	void CopyRandomAppliesTo(LPITEM pItem);
+#endif
+	void CopySocketTo(LPITEM pItem);
+
+	BYTE GetRareAttrCount();
+	bool AddRareAttribute();
+	bool ChangeRareAttribute();
+
+	void AttrLog();
+
+	void Lock(bool f) { m_isLocked = f; }
+	bool isLocked() const { return m_isLocked; }
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	void SetTransmutationVnum(DWORD blVnum);
+	DWORD GetTransmutationVnum() const;
+#endif
+
+#if defined(__SET_ITEM__)
+	void SetItemSetValue(BYTE bSet);
+	BYTE GetItemSetValue() const;
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+public:
+	void SetRefineElement(const TPlayerItemRefineElement* pTable);
+	void CopyElementTo(const LPITEM pItem);
+
+	void UpgradeRefineElement(WORD wApplyType, BYTE bValue, BYTE bBonus);
+	void DowngradeRefineElement();
+	void ChangeRefineElement(WORD wApplyType);
+
+	BYTE GetRefineElementGrade() const { return m_RefineElement.bGrade; }
+	WORD GetRefineElementApplyType() const { return m_RefineElement.wApplyType; }
+	BYTE GetRefineElementValue() const;
+	BYTE GetRefineElementBonusValue() const;
+
+	BYTE GetRefineElementValue(BYTE bGrade) const { return m_RefineElement.abValue[bGrade]; }
+	BYTE GetRefineElementBonusValue(BYTE bGrade) const { return m_RefineElement.abBonusValue[bGrade]; }
+
+	const TPlayerItemRefineElement* GetRefineElement() const { return &m_RefineElement; }
+private:
+	TPlayerItemRefineElement m_RefineElement;
+#endif
+
+private:
+	void SetAttribute(BYTE bIndex, POINT_TYPE wType, POINT_VALUE lValue);
+#if defined(__ITEM_APPLY_RANDOM__)
+	void SetRandomApply(BYTE bIndex, POINT_TYPE wType, POINT_VALUE lValue, BYTE bPath);
+#endif
+public:
+	void SetForceAttribute(BYTE bIndex, POINT_TYPE wType, POINT_VALUE lValue);
+#if defined(__ITEM_APPLY_RANDOM__)
+	void SetForceRandomApply(BYTE bIndex, POINT_TYPE wType, POINT_VALUE lValue, BYTE bPath);
+#endif
+
+protected:
+	bool EquipEx(bool is_equip);
+	bool Unequip();
+
+	void AddAttr(POINT_TYPE wApply, BYTE bLevel);
+	void PutAttribute(const int* aiAttrPercentTable);
+	void PutAttributeWithLevel(BYTE bLevel);
+
+public:
+	friend class CInputDB;
+	bool OnAfterCreatedItem(); //     途  (琯)  恬 獨.
+
+public:
+	bool IsRideItem();
+
+	void ClearMountAttributeAndAffect();
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	DWORD GetMountVnum();
+#endif
+
+	// 臼  캐 方 , 환  캐  鳴 臼,
+	//  謗, 환  첨琉  恝 滂 恝  肉 年臼.
+	//  恝 滂  方  효 求쨉,
+	// , 클, vnum  퓸羚
+	// 恝 vnum 絳    岷틴求 타 황 쨈年.
+	// 瀏  vnum 見,  튼    vnum 侮市  構,
+	//    vnum 侮令 磯.
+
+	// Mask vnum 錚 (ex.  황)  vnum 侮 튼   獵.
+	void SetMaskVnum(DWORD vnum) { m_dwMaskVnum = vnum; }
+	DWORD GetMaskVnum() { return m_dwMaskVnum; }
+	bool IsMaskedItem() { return m_dwMaskVnum != 0; }
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	// 혼
+	bool IsDragonSoul();
+
+	int GiveMoreTime_Per(float fPercent);
+	int GiveMoreTime_Fix(DWORD dwTime);
+#endif
+
+private:
+	TItemTable const* m_pProto; //  타
+
+	DWORD m_dwVnum;
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD m_dwTransmutationVnum;
+#endif
+#if defined(__SET_ITEM__)
+	BYTE m_bSetValue;
+#endif
+	LPCHARACTER m_pOwner;
+
+	BYTE m_bWindow; //   치  
+	DWORD m_dwID; // 호
+	bool m_bEquipped; //  퓸째?
+	DWORD m_dwVID; // VID
+	WORD m_wCell; // 치
+	DWORD m_dwCount; // 
+	long m_lFlag; // 煞 flag
+	DWORD m_dwLastOwnerPID; //   羚  PID
+
+	bool m_bExchanging; ///<  환 
+
+	long m_alSockets[ITEM_SOCKET_MAX_NUM]; //  캣
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute m_aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+	TPlayerItemAttribute m_aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+
+	LPEVENT m_pkDestroyEvent;
+	LPEVENT m_pkExpireEvent;
+	LPEVENT m_pkUniqueExpireEvent;
+	LPEVENT m_pkTimerBasedOnWearExpireEvent;
+	LPEVENT m_pkRealTimeExpireEvent;
+	LPEVENT m_pkAccessorySocketExpireEvent;
+	LPEVENT m_pkOwnershipEvent;
+
+	DWORD m_dwOwnershipPID;
+
+	bool m_bSkipSave;
+
+	bool m_isLocked;
+
+	DWORD m_dwMaskVnum;
+	DWORD m_dwSIGVnum;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+public:
+	bool CanSealItem() const;
+
+	void SealItem(long lSealDate = U_SEAL_DATE_DEFAULT_TIMESTAMP);
+	bool IsSealed() const { return m_lSealDate != E_SEAL_DATE_DEFAULT_TIMESTAMP; }
+	long GetSealDate() const { return m_lSealDate; }
+
+	void StartSealDateExpireTimerEvent();
+	void StopSealDateExpireTimerEvent();
+
+private:
+	long m_lSealDate;
+	LPEVENT m_pkSealDateExpireEvent;
+#endif
+
+#if defined(__SOUL_SYSTEM__)
+public:
+	void StartSoulTimerUseEvent();
+	void ResetSoulTimerUseEvent();
+private:
+	LPEVENT m_pkSoulTimerUseEvent;
+#endif
+
+public:
+	void SetSIGVnum(DWORD dwSIG)
+	{
+		m_dwSIGVnum = dwSIG;
+	}
+	DWORD GetSIGVnum() const
+	{
+		return m_dwSIGVnum;
+	}
+#ifdef __OFFLINE_SHOP__
+public:
+	void CopySockets(std::array<int32_t, ITEM_SOCKET_MAX_NUM>& sockets);
+	void CopyAttributes(std::array<TPlayerItemAttribute, ITEM_ATTRIBUTE_MAX_NUM>& attributes);
+#if defined(__ITEM_APPLY_RANDOM__)
+	void CopyApplyRandom(std::array<TPlayerItemAttribute, ITEM_APPLY_MAX_NUM>& ApplyRandom);
+#endif
+#endif
+};
+
+EVENTINFO(item_event_info)
+{
+	LPITEM item;
+	char szOwnerName[CHARACTER_NAME_MAX_LEN];
+
+	item_event_info()
+		: item(0)
+	{
+		::memset(szOwnerName, 0, CHARACTER_NAME_MAX_LEN);
+	}
+};
+
+EVENTINFO(item_vid_event_info)
+{
+	DWORD item_vid;
+
+	item_vid_event_info()
+		: item_vid(0)
+	{
+	}
+};
+
+#endif // __INC_ITEM_H__
diff --git a/server/server/home/metin2/Source/Server/game/src/packet.h b/server/server/home/metin2/Source/Server/game/src/packet.h
index d7580ac..99cbe2c 100644
--- a/server/server/home/metin2/Source/Server/game/src/packet.h
+++ b/server/server/home/metin2/Source/Server/game/src/packet.h
@@ -1,4480 +1,4480 @@
-#ifndef __INC_PACKET_H__
-#define __INC_PACKET_H__
-
-enum CG_HEADERS
-{
-	HEADER_CG_LOGIN = 1,
-	HEADER_CG_ATTACK = 2,
-	HEADER_CG_CHAT = 3,
-	HEADER_CG_CHARACTER_CREATE = 4,
-	HEADER_CG_CHARACTER_DELETE = 5,
-	HEADER_CG_CHARACTER_SELECT = 6,
-	HEADER_CG_MOVE = 7,
-	HEADER_CG_SYNC_POSITION = 8,
-	//HEADER_CG_DIRECT_ENTER = 9,
-	HEADER_CG_ENTERGAME = 10,
-
-	HEADER_CG_ITEM_USE = 11,
-	HEADER_CG_ITEM_DROP = 12,
-	HEADER_CG_ITEM_MOVE = 13,
-	//HEADER_CG_UNUSED = 14,
-	HEADER_CG_ITEM_PICKUP = 15,
-
-	HEADER_CG_QUICKSLOT_ADD = 16,
-	HEADER_CG_QUICKSLOT_DEL = 17,
-	HEADER_CG_QUICKSLOT_SWAP = 18,
-	HEADER_CG_WHISPER = 19,
-	HEADER_CG_ITEM_DROP2 = 20,
-#if defined(__NEW_DROP_DIALOG__)
-	HEADER_CG_ITEM_DESTROY = 21,
-#endif
-
-	//HEADER_CG_UNUSED = 22,
-	//HEADER_CG_UNUSED = 23,
-	//HEADER_CG_UNUSED = 24,
-	//HEADER_CG_UNUSED = 25,
-
-	HEADER_CG_ON_CLICK = 26,
-	HEADER_CG_EXCHANGE = 27,
-	HEADER_CG_CHARACTER_POSITION = 28,
-	HEADER_CG_SCRIPT_ANSWER = 29,
-	HEADER_CG_QUEST_INPUT_STRING = 30,
-	HEADER_CG_QUEST_CONFIRM = 31,
-#if defined(__OX_RENEWAL__)
-	HEADER_CG_QUEST_INPUT_LONG_STRING = 32,
-#endif
-#if defined(__OFFLINE_SHOP__)
-	HEADER_CG_OFFLINE_SHOP = 33,
-#endif
-	//HEADER_CG_UNUSED = 34,
-
-#ifdef __GROWTH_PET_SYSTEM__
-	HEADER_CG_PET_HATCH = 35,
-	HEADER_CG_PET_WINDOW_TYPE = 36,
-	HEADER_CG_PET_WINDOW = 37,
-	HEADER_CG_PET_NAME_CHANGE = 38,
-	HEADER_CG_PET_FEED = 39,
-	HEADER_CG_PET_DETERMINE = 40,
-	HEADER_CG_PET_ATTR_CHANGE = 41,
-	HEADER_CG_PET_REVIVE = 42,
-	HEADER_CG_PET_LEARN_SKILL = 43,
-	HEADER_CG_PET_SKILL_UPGRADE = 44,
-	HEADER_CG_PET_DELETE_SKILL = 45,
-	HEADER_CG_PET_DELETE_ALL_SKILL = 46,
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	HEADER_CG_EXTEND_INVEN = 47,
-#endif
-	//HEADER_CG_UNUSED = 48,
-	//HEADER_CG_UNUSED = 49,
-
-	HEADER_CG_SHOP = 50,
-	HEADER_CG_FLY_TARGETING = 51,
-	HEADER_CG_USE_SKILL = 52,
-	HEADER_CG_ADD_FLY_TARGETING = 53,
-	HEADER_CG_SHOOT = 54,
-	HEADER_CG_MYSHOP = 55,
-#if defined(__MYSHOP_DECO__)
-	HEADER_CG_MYSHOP_DECO_STATE = 56,
-	HEADER_CG_MYSHOP_DECO_ADD = 57,
-#endif
-	//HEADER_CG_UNUSED = 58,
-
-#if defined(__SEND_TARGET_INFO__)
-	HEADER_CG_TARGET_INFO = 59,
-#endif
-	HEADER_CG_ITEM_USE_TO_ITEM = 60,
-	HEADER_CG_TARGET = 61,
-
-	//HEADER_CG_UNUSED = 62,
-	//HEADER_CG_UNUSED = 63,
-	HEADER_CG_TEXT = 64, // @ 로 시작되면 텍스트를 파싱한다.
-	HEADER_CG_WARP = 65,
-	HEADER_CG_SCRIPT_BUTTON = 66,
-	HEADER_CG_MESSENGER = 67,
-	//HEADER_CG_UNUSED = 68,
-
-	HEADER_CG_MALL_CHECKOUT = 69,
-	HEADER_CG_SAFEBOX_CHECKIN = 70, // 아이템을 창고에 넣넎는다.
-	HEADER_CG_SAFEBOX_CHECKOUT = 71, // 아이템을 창고로 부터 빼온다.
-
-	HEADER_CG_PARTY_INVITE = 72,
-	HEADER_CG_PARTY_INVITE_ANSWER = 73,
-	HEADER_CG_PARTY_REMOVE = 74,
-	HEADER_CG_PARTY_SET_STATE = 75,
-	HEADER_CG_PARTY_USE_SKILL = 76,
-	HEADER_CG_SAFEBOX_ITEM_MOVE = 77,
-	HEADER_CG_PARTY_PARAMETER = 78,
-	//HEADER_CG_UNUSED = 79,
-
-	HEADER_CG_GUILD = 80,
-	HEADER_CG_ANSWER_MAKE_GUILD = 81,
-	HEADER_CG_FISHING = 82,
-	HEADER_CG_ITEM_GIVE = 83,
-#ifdef __SHOP_SEARCH__
-	HEADER_CG_SHOP_SEARCH_BY_NAME = 84,
-	HEADER_CG_SHOP_SEARCH_BY_OPTION = 85,
-	HEADER_CG_SHOP_SEARCH_BUY = 86,
-	HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE = 87,
-	HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO = 88,
-#endif
-	HEADER_CG_EMPIRE = 90,
-	//HEADER_CG_UNUSED = 91,
-	//HEADER_CG_UNUSED = 92,
-	//HEADER_CG_UNUSED = 93,
-	//HEADER_CG_UNUSED = 94,
-	//HEADER_CG_UNUSED = 95,
-
-	HEADER_CG_REFINE = 96,
-#if defined(__CUBE_RENEWAL__)
-	HEADER_CG_CUBE = 97,
-#endif
-	//HEADER_CG_UNUSED = 98,
-	//HEADER_CG_UNUSED = 99,
-
-	HEADER_CG_MARK_LOGIN = 100,
-	HEADER_CG_MARK_CRCLIST = 101,
-	HEADER_CG_MARK_UPLOAD = 102,
-	//HEADER_CG_CRC_REPORT = 103,
-	HEADER_CG_MARK_IDXLIST = 104,
-
-	HEADER_CG_HACK = 105,
-	HEADER_CG_CHANGE_NAME = 106,
-	//HEADER_CG_UNUSED = 107,
-	//HEADER_CG_UNUSED = 108,
-	HEADER_CG_LOGIN2 = 109,
-	HEADER_CG_DUNGEON = 110,
-	HEADER_CG_LOGIN3 = 111,
-
-	HEADER_CG_GUILD_SYMBOL_UPLOAD = 112,
-	HEADER_CG_SYMBOL_CRC = 113,
-
-	// SCRIPT_SELECT_ITEM
-	HEADER_CG_SCRIPT_SELECT_ITEM = 114,
-	// END_OF_SCRIPT_SELECT_ITEM
-
-#if defined(__GEM_SYSTEM__)
-	HEADER_CG_SELECT_ITEM_EX = 115,
-#endif
-
-	//HEADER_CG_UNUSED = 116,
-	//HEADER_CG_UNUSED = 117,
-	//HEADER_CG_UNUSED = 118,
-	//HEADER_CG_UNUSED = 119,
-#if defined(__QUEST_REQUEST_EVENT__)
-	HEADER_CG_REQUEST_EVENT_QUEST = 120,
-#endif
-#if defined(__LEFT_SEAT__)
-	HEADER_CG_LEFT_SEAT = 121,
-#endif
-	//HEADER_CG_UNUSED = 122,
-	//HEADER_CG_UNUSED = 123,
-	//HEADER_CG_UNUSED = 124,
-	//HEADER_CG_UNUSED = 125,
-	//HEADER_CG_UNUSED = 126,
-	//HEADER_CG_UNUSED = 127,
-	//HEADER_CG_UNUSED = 128,
-	//HEADER_CG_UNUSED = 129,
-	//HEADER_CG_UNUSED = 130,
-	//HEADER_CG_UNUSED = 131,
-	//HEADER_CG_UNUSED = 132,
-	//HEADER_CG_UNUSED = 133,
-	//HEADER_CG_UNUSED = 134,
-	//HEADER_CG_UNUSED = 135,
-	//HEADER_CG_UNUSED = 136,
-	//HEADER_CG_UNUSED = 137,
-	//HEADER_CG_UNUSED = 138,
-	//HEADER_CG_UNUSED = 139,
-	//HEADER_CG_UNUSED = 140,
-	//HEADER_CG_UNUSED = 141,
-	//HEADER_CG_UNUSED = 142,
-	//HEADER_CG_UNUSED = 143,
-	//HEADER_CG_UNUSED = 144,
-#if defined(__FISHING_GAME__)
-	HEADER_CG_FISHING_GAME = 145,
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	HEADER_CG_REFINE_ELEMENT = 146,
-#endif
-	//HEADER_CG_UNUSED = 147,
-	//HEADER_CG_UNUSED = 148,
-	//HEADER_CG_UNUSED = 149,
-	//HEADER_CG_UNUSED = 150,
-#if defined(__SKILLBOOK_COMB_SYSTEM__)
-	HEADER_CG_SKILLBOOK_COMB = 151,
-#endif
-	//HEADER_CG_UNUSED = 152,
-	//HEADER_CG_UNUSED = 153,
-	//HEADER_CG_UNUSED = 154,
-	//HEADER_CG_UNUSED = 155,
-	//HEADER_CG_UNUSED = 156,
-	//HEADER_CG_UNUSED = 157,
-	//HEADER_CG_UNUSED = 158,
-	//HEADER_CG_UNUSED = 159,
-	//HEADER_CG_UNUSED = 160,
-	//HEADER_CG_UNUSED = 161,
-	//HEADER_CG_UNUSED = 162,
-	//HEADER_CG_UNUSED = 163,
-	//HEADER_CG_UNUSED = 164,
-	//HEADER_CG_UNUSED = 165,
-	//HEADER_CG_UNUSED = 166,
-	//HEADER_CG_UNUSED = 167,
-	//HEADER_CG_UNUSED = 168,
-#if defined(__ATTR_6TH_7TH__)
-	HEADER_CG_ATTR67_ADD = 169,
-#endif
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-	HEADER_CG_SNOWFLAKE_STICK_EVENT = 170,
-#endif
-	//HEADER_CG_UNUSED = 171,
-	//HEADER_CG_UNUSED = 172,
-	//HEADER_CG_UNUSED = 173,
-	//HEADER_CG_UNUSED = 174,
-	//HEADER_CG_UNUSED = 175,
-	//HEADER_CG_UNUSED = 176,
-	//HEADER_CG_UNUSED = 177,
-	//HEADER_CG_UNUSED = 178,
-	//HEADER_CG_UNUSED = 179,
-	//HEADER_CG_UNUSED = 180,
-#if defined(__MINI_GAME_RUMI__)
-	HEADER_CG_MINI_GAME_RUMI = 181,
-#endif
-#if defined(__MINI_GAME_YUTNORI__)
-	HEADER_CG_MINI_GAME_YUTNORI = 182,
-#endif
-#if defined(__GEM_SHOP__)
-	HEADER_CG_GEM_SHOP = 183,
-#endif
-	//HEADER_CG_UNUSED = 184,
-	//HEADER_CG_UNUSED = 185,
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	HEADER_CG_MINI_GAME_ROULETTE = 186,
-#endif
-#if defined(__FLOWER_EVENT__)
-	HEADER_CG_FLOWER_EVENT = 187,
-#endif
-	//HEADER_CG_UNUSED = 188,
-	//HEADER_CG_UNUSED = 189,
-	//HEADER_CG_UNUSED = 190,
-	//HEADER_CG_UNUSED = 191,
-	//HEADER_CG_UNUSED = 192,
-	//HEADER_CG_UNUSED = 193,
-	//HEADER_CG_UNUSED = 194,
-	//HEADER_CG_UNUSED = 195,
-	//HEADER_CG_UNUSED = 196,
-	//HEADER_CG_UNUSED = 197,
-	//HEADER_CG_UNUSED = 198,
-	//HEADER_CG_UNUSED = 199,
-	//HEADER_CG_UNUSED = 200,
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	HEADER_CG_EXT_BATTLE_PASS_ACTION = 201,
-	HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM = 202,
-#endif
-
-	// NOTE : 이런 개XXX 정말 이거 Packet설계한 사람은 누구냐. 이렇게 코딩하고 밥이 넘어가나.
-	// enum을 별도로 구별을 하던가. 아님 namepsace로 구별을 하던가..
-	// 정말 packet generator까지는 바라지도 않는다. 이런 씨XX
-	// 이러다가 숫자 겹치면 누가 책임지는데???
-	//HEADER_CG_HS_ACK = 203,
-	//HEADER_CG_XTRAP_ACK = 204,
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	HEADER_CG_DRAGON_SOUL_REFINE = 205,
-#endif
-	HEADER_CG_STATE_CHECKER = 206,
-
-	//HEADER_CG_UNUSED = 207,
-#if defined(__LUCKY_BOX__)
-	HEADER_CG_LUCKY_BOX = 208,
-#endif
-	//HEADER_CG_UNUSED = 210,
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	HEADER_CG_ACCE_REFINE = 211,
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	HEADER_CG_AURA_REFINE = 212,
-#endif
-	//HEADER_CG_UNUSED = 213,
-	//HEADER_CG_UNUSED = 214,
-#if defined(__MAILBOX__)
-	HEADER_CG_MAILBOX_WRITE = 215,
-	HEADER_CG_MAILBOX_WRITE_CONFIRM = 216,
-	HEADER_CG_MAILBOX_PROCESS = 217,
-#endif
-#if defined(__MOVE_COSTUME_ATTR__)
-	HEADER_CG_ITEM_COMBINATION = 218,
-	HEADER_CG_ITEM_COMBINATION_CANCEL = 219,
-#endif
-	//HEADER_CG_UNUSED = 223,
-	//HEADER_CG_UNUSED = 224,
-	//HEADER_CG_UNUSED = 225,
-#if defined(__MINI_GAME_CATCH_KING__)
-	HEADER_CG_MINI_GAME_CATCH_KING = 226,
-#endif
-#if defined(__CHANGED_ATTR__)
-	HEADER_CG_ITEM_SELECT_ATTR = 227,
-#endif
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	HEADER_CG_CHANGE_LOOK = 228,
-#endif
-	//HEADER_CG_UNUSED = 229,
-	//HEADER_CG_UNUSED = 230,
-	//HEADER_CG_UNUSED = 231,
-	//HEADER_CG_UNUSED = 232,
-	//HEADER_CG_UNUSED = 233,
-	//HEADER_CG_UNUSED = 234,
-#if defined(__LOOT_FILTER_SYSTEM__)
-	HEADER_CG_LOOT_FILTER = 235,
-#endif
-	//HEADER_CG_UNUSED = 236,
-	//HEADER_CG_UNUSED = 237,
-	//HEADER_CG_UNUSED = 238,
-	//HEADER_CG_UNUSED = 239,
-	//HEADER_CG_UNUSED = 240,
-	HEADER_CG_CLIENT_VERSION2 = 0xf1, // 241
-	//HEADER_CG_UNUSED = 242,
-	//HEADER_CG_UNUSED = 243,
-	//HEADER_CG_UNUSED = 244,
-	//HEADER_CG_UNUSED = 245,
-	//HEADER_CG_UNUSED = 246,
-	//HEADER_CG_UNUSED = 247,
-	//HEADER_CG_UNUSED = 248,
-	//HEADER_CG_UNUSED = 249,
-	//HEADER_CG_UNUSED = 250,
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	HEADER_CG_KEY_AGREEMENT = 0xfb, // 251
-#endif
-	HEADER_CG_TIME_SYNC = 0xfc, // 252
-	HEADER_CG_CLIENT_VERSION = 0xfd, // 253
-	HEADER_CG_PONG = 0xfe, // 254
-	HEADER_CG_HANDSHAKE = 0xff, // 255
-};
-
-enum GC_HEADERS
-{
-	HEADER_GC_CHARACTER_ADD = 1,
-	HEADER_GC_CHARACTER_DEL = 2,
-	HEADER_GC_MOVE = 3,
-	HEADER_GC_CHAT = 4,
-	HEADER_GC_SYNC_POSITION = 5,
-
-	HEADER_GC_LOGIN_SUCCESS = 6,
-	HEADER_GC_LOGIN_FAILURE = 7,
-
-	HEADER_GC_CHARACTER_CREATE_SUCCESS = 8,
-	HEADER_GC_CHARACTER_CREATE_FAILURE = 9,
-	HEADER_GC_CHARACTER_DELETE_SUCCESS = 10,
-	HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID = 11,
-
-	//HEADER_GC_UNUSED = 12,
-	HEADER_GC_STUN = 13,
-	HEADER_GC_DEAD = 14,
-
-	HEADER_GC_MAIN_CHARACTER_OLD = 15,
-	HEADER_GC_CHARACTER_POINTS = 16,
-	HEADER_GC_CHARACTER_POINT_CHANGE = 17,
-	HEADER_GC_CHANGE_SPEED = 18,
-	HEADER_GC_CHARACTER_UPDATE = 19,
-
-	HEADER_GC_ITEM_DEL = 20,
-	HEADER_GC_ITEM_SET = 21,
-	HEADER_GC_ITEM_USE = 22,
-	HEADER_GC_ITEM_DROP = 23,
-
-	//HEADER_GC_UNUSED = 24,
-	HEADER_GC_ITEM_UPDATE = 25,
-	HEADER_GC_ITEM_GROUND_ADD = 26,
-	HEADER_GC_ITEM_GROUND_DEL = 27,
-
-	HEADER_GC_QUICKSLOT_ADD = 28,
-	HEADER_GC_QUICKSLOT_DEL = 29,
-	HEADER_GC_QUICKSLOT_SWAP = 30,
-
-	HEADER_GC_ITEM_OWNERSHIP = 31,
-
-	HEADER_GC_LOGIN_SUCCESS_NEWSLOT = 32,
-
-	//HEADER_GC_UNUSED = 33,
-	HEADER_GC_WHISPER = 34,
-	//HEADER_GC_UNUSED = 35,
-
-	HEADER_GC_MOTION = 36,
-	HEADER_GC_EMOTE = 37,
-
-	HEADER_GC_SHOP = 38,
-	HEADER_GC_SHOP_SIGN = 39,
-
-	HEADER_GC_DUEL_START = 40,
-	HEADER_GC_PVP = 41,
-	HEADER_GC_EXCHANGE = 42,
-	HEADER_GC_CHARACTER_POSITION = 43,
-
-	HEADER_GC_PING = 44,
-	HEADER_GC_SCRIPT = 45,
-	HEADER_GC_QUEST_CONFIRM = 46,
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	HEADER_GC_EXTEND_INVEN = 47,
-	HEADER_GC_EXTEND_INVEN_ITEM_USE = 48,
-#endif
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	HEADER_GC_GUILD_DRAGONLAIR = 49,
-#endif
-#if defined(__CLIENT_TIMER__)
-	HEADER_GC_CLIENT_TIMER = 50,
-#endif
-#if defined(__OFFLINE_SHOP__)
-	HEADER_GC_OFFLINE_SHOP = 51,
-#endif
-	//HEADER_GC_UNUSED = 52,
-	//HEADER_GC_UNUSED = 53,
-	//HEADER_GC_UNUSED = 54,
-	//HEADER_GC_UNUSED = 55,
-	//HEADER_GC_UNUSED = 56,
-	//HEADER_GC_UNUSED = 57,
-#if defined(__SEND_TARGET_INFO__)
-	HEADER_GC_TARGET_INFO = 58,
-#endif
-	//HEADER_GC_UNUSED = 59,
-	//HEADER_GC_UNUSED = 60,
-	HEADER_GC_MOUNT = 61,
-	HEADER_GC_OWNERSHIP = 62,
-	HEADER_GC_TARGET = 63,
-	//HEADER_GC_UNUSED = 64,
-	HEADER_GC_WARP = 65,
-	//HEADER_GC_UNUSED = 66,
-	//HEADER_GC_UNUSED = 67,
-	//HEADER_GC_UNUSED = 68,
-	HEADER_GC_ADD_FLY_TARGETING = 69,
-
-	HEADER_GC_CREATE_FLY = 70,
-	HEADER_GC_FLY_TARGETING = 71,
-	HEADER_GC_SKILL_LEVEL_OLD = 72,
-	//HEADER_GC_UNUSED = 73,
-	HEADER_GC_MESSENGER = 74,
-	HEADER_GC_GUILD = 75,
-	HEADER_GC_SKILL_LEVEL = 76,
-
-	HEADER_GC_PARTY_INVITE = 77,
-	HEADER_GC_PARTY_ADD = 78,
-	HEADER_GC_PARTY_UPDATE = 79,
-	HEADER_GC_PARTY_REMOVE = 80,
-
-	HEADER_GC_QUEST_INFO = 81,
-	HEADER_GC_REQUEST_MAKE_GUILD = 82,
-	HEADER_GC_PARTY_PARAMETER = 83,
-	//HEADER_GC_UNUSED = 84,
-
-	HEADER_GC_SAFEBOX_SET = 85,
-	HEADER_GC_SAFEBOX_DEL = 86,
-	HEADER_GC_SAFEBOX_WRONG_PASSWORD = 87,
-	HEADER_GC_SAFEBOX_SIZE = 88,
-
-	HEADER_GC_FISHING = 89,
-
-	HEADER_GC_EMPIRE = 90,
-
-	HEADER_GC_PARTY_LINK = 91,
-	HEADER_GC_PARTY_UNLINK = 92,
-	//HEADER_GC_UNUSED = 93,
-	//HEADER_GC_UNUSED = 94,
-	//HEADER_GC_UNUSED = 95,
-	//HEADER_GC_UNUSED = 96,
-#if defined(__CUBE_RENEWAL__)
-	HEADER_GC_CUBE = 97,
-#endif
-	//HEADER_GC_UNUSED = 98,
-	HEADER_GC_VIEW_EQUIP = 99,
-
-	HEADER_GC_MARK_BLOCK = 100,
-	//HEADER_GC_MARK_DIFF_DATA = 101,
-	HEADER_GC_MARK_IDXLIST = 102,
-	//HEADER_GC_UNUSED = 103,
-	//HEADER_GC_UNUSED = 104,
-	//HEADER_GC_SLOW_TIMER = 105,
-	HEADER_GC_TIME = 106,
-	HEADER_GC_CHANGE_NAME = 107,
-	//HEADER_GC_UNUSED = 108,
-	//HEADER_GC_UNUSED = 109,
-
-	HEADER_GC_DUNGEON = 110,
-
-	HEADER_GC_WALK_MODE = 111,
-	HEADER_GC_SKILL_GROUP = 112,
-	HEADER_GC_MAIN_CHARACTER = 113,
-
-	HEADER_GC_SEPCIAL_EFFECT = 114,
-	HEADER_GC_NPC_POSITION = 115,
-
-	//HEADER_CG_UNUSED = 116,
-	//HEADER_GC_UNUSED = 117,
-	HEADER_GC_LOGIN_KEY = 118,
-
-	HEADER_GC_REFINE_INFORMATION = 119,
-	//HEADER_GC_UNUSED = 120,
-	HEADER_GC_CHANNEL = 121,
-
-	HEADER_GC_MALL_OPEN = 122,
-
-	HEADER_GC_TARGET_UPDATE = 123,
-	HEADER_GC_TARGET_DELETE = 124,
-	HEADER_GC_TARGET_CREATE = 125,
-
-	HEADER_GC_AFFECT_ADD = 126,
-	HEADER_GC_AFFECT_REMOVE = 127,
-
-	HEADER_GC_MALL_SET = 128,
-	HEADER_GC_MALL_DEL = 129,
-
-	HEADER_GC_LAND_LIST = 130,
-	HEADER_GC_LOVER_INFO = 131,
-	HEADER_GC_LOVE_POINT_UPDATE = 132,
-
-	HEADER_GC_SYMBOL_DATA = 133,
-
-	// MINING
-	HEADER_GC_DIG_MOTION = 134,
-	// END_OF_MINING
-
-	HEADER_GC_DAMAGE_INFO = 135,
-	HEADER_GC_CHAR_ADDITIONAL_INFO = 136,
-
-	// SUPPORT_BGM
-	HEADER_GC_MAIN_CHARACTER3_BGM = 137,
-	HEADER_GC_MAIN_CHARACTER4_BGM_VOL = 138,
-	// END_OF_SUPPORT_BGM
-
-	//HEADER_GC_UNUSED = 140,
-	//HEADER_GC_UNUSED = 141,
-	//HEADER_GC_UNUSED = 142,
-	//HEADER_GC_UNUSED = 143,
-	//HEADER_GC_UNUSED = 144,
-#if defined(__FISHING_GAME__)
-	HEADER_GC_FISHING_GAME = 145,
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	HEADER_GC_REFINE_ELEMENT = 146,
-#endif
-	//HEADER_GC_UNUSED = 147,
-	//HEADER_GC_UNUSED = 148,
-	//HEADER_GC_UNUSED = 149,
-
-	HEADER_GC_AUTH_SUCCESS = 150,
-	HEADER_GC_PANAMA_PACK = 151,
-
-	// HYBRID CRYPT
-	HEADER_GC_HYBRIDCRYPT_KEYS = 152,
-	HEADER_GC_HYBRIDCRYPT_SDB = 153, // SDB means Supplmentary Data Blocks
-	// HYBRID CRYPT
-
-#ifdef __SHOP_SEARCH__
-	HEADER_GC_SHOP_SEARCH_RESULT = 164,
-	HEADER_GC_SHOP_SEARCH_BUY_RESULT = 165,
-	HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE = 166,
-	HEADER_GC_SHOP_SEARCH_SOLD_INFO = 167,
-	HEADER_GC_ENTITY = 168,
-#endif
-	//HEADER_GC_UNUSED = 169,
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-	HEADER_GC_SNOWFLAKE_STICK_EVENT = 170,
-#endif
-	//HEADER_GC_UNUSED = 171,
-	//HEADER_GC_UNUSED = 172,
-	//HEADER_GC_UNUSED = 173,
-	//HEADER_GC_UNUSED = 174,
-	//HEADER_GC_UNUSED = 175,
-	//HEADER_GC_UNUSED = 176,
-	//HEADER_GC_UNUSED = 177,
-	//HEADER_GC_UNUSED = 178,
-	//HEADER_GC_UNUSED = 179,
-	//HEADER_GC_UNUSED = 180,
-#if defined(__MINI_GAME_RUMI__)
-	HEADER_GC_MINI_GAME_RUMI = 181,
-#endif
-#if defined(__MINI_GAME_YUTNORI__)
-	HEADER_GC_MINI_GAME_YUTNORI = 182,
-#endif
-	//HEADER_GC_UNUSED = 183,
-	//HEADER_GC_UNUSED = 184,
-	//HEADER_GC_UNUSED = 185,
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	HEADER_GC_MINI_GAME_ROULETTE = 186,
-#endif
-#if defined(__FLOWER_EVENT__)
-	HEADER_GC_FLOWER_EVENT = 187,
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	HEADER_GC_PET = 188,
-	HEADER_GC_PET_SET = 189,
-	HEADER_GC_PET_SET_EXCHANGE = 190,
-	HEADER_GC_PET_DEL = 191,
-	HEADER_GC_PET_SUMMON = 192,
-	HEADER_GC_PET_POINT_CHANGE = 193,
-	HEADER_GC_PET_NAME_CHANGE_RESULT = 194,
-	HEADER_GC_PET_DETERMINE_RESULT = 195,
-	HEADER_GC_PET_ATTR_CHANGE_RESULT = 196,
-	HEADER_GC_PET_SKILL_UPDATE = 197,
-	HEADER_GC_PET_SKILL_COOLTIME = 198,
-#endif
-
-	//HEADER_GC_UNUSED = 199,
-	//HEADER_GC_UNUSED = 200,
-
-#if defined(__GEM_SHOP__)
-	HEADER_GC_GEM_SHOP = 201,
-	HEADER_GC_GEM_SHOP_PROCESS = 202,
-#endif
-	//HEADER_GC_UNUSED = 203,
-	//HEADER_GC_UNUSED = 204,
-	//HEADER_GC_UNUSED = 205,
-	//HEADER_GC_UNUSED = 206,
-	//HEADER_GC_UNUSED = 207,
-
-	HEADER_GC_SPECIFIC_EFFECT = 208,
-
-	HEADER_GC_DRAGON_SOUL_REFINE = 209,
-	HEADER_GC_RESPOND_CHANNELSTATUS = 210,
-
-	//HEADER_GC_UNUSED = 212,
-	//HEADER_GC_UNUSED = 213,
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	HEADER_GC_ACCE_REFINE = 214,
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	HEADER_GC_AURA_REFINE = 215,
-#endif
-	//HEADER_GC_UNUSED = 216,
-#if defined(__LUCKY_BOX__)
-	HEADER_GC_LUCKY_BOX = 217,
-#endif
-	//HEADER_GC_UNUSED = 218,
-	//HEADER_GC_UNUSED = 219,
-	//HEADER_GC_UNUSED = 220,
-#if defined(__MAILBOX__)
-	HEADER_GC_MAILBOX_PROCESS = 221,
-	HEADER_GC_MAILBOX = 222,
-	HEADER_GC_MAILBOX_ADD_DATA = 223,
-	HEADER_GC_MAILBOX_ALL = 224,
-	HEADER_GC_MAILBOX_UNREAD = 225,
-#endif
-	//HEADER_GC_UNUSED = 226,
-#if defined(__CHANGED_ATTR__)
-	HEADER_GC_ITEM_SELECT_ATTR = 227,
-#endif
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	HEADER_GC_CHANGE_LOOK_SET = 228,
-	HEADER_GC_CHANGE_LOOK_DEL = 229,
-	HEADER_GC_CHANGE_LOOK_FREE_SET = 230,
-	HEADER_GC_CHANGE_LOOK_FREE_DEL = 231,
-#endif
-	//HEADER_GC_UNUSED = 232,
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	HEADER_GC_EXT_BATTLE_PASS_OPEN = 233,
-	HEADER_GC_EXT_BATTLE_PASS_GENERAL_INFO = 234,
-	HEADER_GC_EXT_BATTLE_PASS_MISSION_INFO = 235,
-	HEADER_GC_EXT_BATTLE_PASS_MISSION_UPDATE = 236,
-	HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING = 237,
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__)
-	HEADER_GC_MINI_GAME_CATCH_KING = 238,
-#endif
-	//HEADER_GC_UNUSED = 239,
-#if defined(__RANKING_SYSTEM__)
-	HEADER_GC_RANKING = 240,
-#endif
-	//HEADER_GC_UNUSED = 241,
-	//HEADER_GC_UNUSED = 242,
-	//HEADER_GC_UNUSED = 243,
-	//HEADER_GC_UNUSED = 244,
-#if defined(__LOOT_FILTER_SYSTEM__)
-	HEADER_GC_LOOT_FILTER = 245,
-#endif
-	//HEADER_GC_UNUSED = 246,
-	//HEADER_GC_UNUSED = 247,
-	//HEADER_GC_UNUSED = 248,
-	//HEADER_GC_UNUSED = 249,
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	HEADER_GC_KEY_AGREEMENT_COMPLETED = 250, // 250
-	HEADER_GC_KEY_AGREEMENT = 251, // 251
-#endif
-	HEADER_GC_HANDSHAKE_OK = 252, // 252 (0xfc)
-	HEADER_GC_TIME_SYNC = 252, // legacy alias (handshake ok)
-	HEADER_GC_PHASE = 253, // 253
-	HEADER_GC_BINDUDP = 254, // 254
-	HEADER_GC_HANDSHAKE = 255, // 255
-};
-
-enum GG_HEADERS
-{
-	HEADER_GG_LOGIN = 1,
-	HEADER_GG_LOGOUT = 2,
-	HEADER_GG_RELAY = 3,
-	HEADER_GG_NOTICE = 4,
-	HEADER_GG_SHUTDOWN = 5,
-	HEADER_GG_GUILD = 6,
-	HEADER_GG_DISCONNECT = 7, // 누군가의 접속을 강제로 끊을 때
-	HEADER_GG_SHOUT = 8,
-	HEADER_GG_SETUP = 9,
-	HEADER_GG_MESSENGER_ADD = 10,
-	HEADER_GG_MESSENGER_REMOVE = 11,
-	HEADER_GG_FIND_POSITION = 12,
-	HEADER_GG_WARP_CHARACTER = 13,
-	//HEADER_GG_UNUSED = 14,
-	HEADER_GG_GUILD_WAR_ZONE_MAP_INDEX = 15,
-	HEADER_GG_TRANSFER = 16,
-#if defined(__XMAS_EVENT_2008__)
-	HEADER_GG_XMAS_WARP_SANTA = 17,
-	HEADER_GG_XMAS_WARP_SANTA_REPLY = 18,
-#endif
-	HEADER_GG_RELOAD_CRC_LIST = 19,
-	HEADER_GG_LOGIN_PING = 20,
-	HEADER_GG_CHECK_CLIENT_VERSION = 21,
-	HEADER_GG_BLOCK_CHAT = 22,
-	HEADER_GG_BIG_NOTICE = 23,
-	HEADER_GG_BLOCK_EXCEPTION = 24,
-	HEADER_GG_SIEGE = 25,
-	HEADER_GG_MONARCH_NOTICE = 26,
-	HEADER_GG_MONARCH_TRANSFER = 27,
-	HEADER_GG_PCBANG_UPDATE = 28,
-	HEADER_GG_CHECK_AWAKENESS = 29,
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	HEADER_GG_MESSENGER_BLOCK_ADD = 30,
-	HEADER_GG_MESSENGER_BLOCK_REMOVE = 31,
-#endif
-#if defined(__OFFLINE_SHOP__)
-	HEADER_GG_OFFLINE_SHOP = 33,
-	HEADER_GG_UPDATE_SELL_HISTORY = 34,
-#endif
-};
-
-#pragma pack(1)
-typedef struct SPacketGGSetup
-{
-	BYTE bHeader;
-	WORD wPort;
-	BYTE bChannel;
-} TPacketGGSetup;
-
-typedef struct SPacketGGLogin
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	DWORD dwPID;
-	BYTE bEmpire;
-	long lMapIndex;
-	BYTE bChannel;
-} TPacketGGLogin;
-
-typedef struct SPacketGGLogout
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGGLogout;
-
-typedef struct SPacketGGRelay
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	long lSize;
-} TPacketGGRelay;
-
-typedef struct SPacketGGNotice
-{
-	BYTE bHeader;
-	long lSize;
-	char szArg[CHAT_MAX_LEN + 1];
-	bool bBigFont;
-} TPacketGGNotice;
-
-typedef struct SPacketGGMonarchNotice
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-	long lSize;
-} TPacketGGMonarchNotice;
-
-// FORKED_ROAD
-typedef struct SPacketGGForkedMapInfo
-{
-	BYTE bHeader;
-	BYTE bPass;
-	BYTE bSungzi;
-} TPacketGGForkedMapInfo;
-// END_FORKED_ROAD
-
-typedef struct SPacketGGShutdown
-{
-	BYTE bHeader;
-} TPacketGGShutdown;
-
-typedef struct SPacketGGGuild
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwGuild;
-} TPacketGGGuild;
-
-enum
-{
-	GUILD_SUBHEADER_GG_CHAT,
-	GUILD_SUBHEADER_GG_SET_MEMBER_COUNT_BONUS,
-};
-
-typedef struct SPacketGGGuildChat
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwGuild;
-	char szText[CHAT_MAX_LEN + 1];
-} TPacketGGGuildChat;
-
-typedef struct SPacketGGParty
-{
-	BYTE header;
-	BYTE subheader;
-	DWORD pid;
-	DWORD leaderpid;
-} TPacketGGParty;
-
-enum
-{
-	PARTY_SUBHEADER_GG_CREATE,
-	PARTY_SUBHEADER_GG_DESTROY,
-	PARTY_SUBHEADER_GG_JOIN,
-	PARTY_SUBHEADER_GG_QUIT,
-};
-
-typedef struct SPacketGGDisconnect
-{
-	BYTE bHeader;
-	char szLogin[LOGIN_MAX_LEN + 1];
-} TPacketGGDisconnect;
-
-typedef struct SPacketGGShout
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-	char szText[CHAT_MAX_LEN + 1];
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketGGShout;
-
-#if defined(__XMAS_EVENT_2008__)
-typedef struct SPacketGGXmasWarpSanta
-{
-	BYTE bHeader;
-	BYTE bChannel;
-	long lMapIndex;
-} TPacketGGXmasWarpSanta;
-
-typedef struct SPacketGGXmasWarpSantaReply
-{
-	BYTE bHeader;
-	BYTE bChannel;
-} TPacketGGXmasWarpSantaReply;
-#endif
-
-typedef struct SPacketGGMessenger
-{
-	BYTE bHeader;
-	char szAccount[CHARACTER_NAME_MAX_LEN + 1];
-	char szCompanion[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGGMessenger;
-
-typedef struct SPacketGGFindPosition
-{
-	BYTE header;
-	DWORD dwFromPID; // 저 위치로 워프하려는 사람
-	DWORD dwTargetPID; // 찾는 사람
-} TPacketGGFindPosition;
-
-typedef struct SPacketGGWarpCharacter
-{
-	BYTE header;
-	DWORD pid;
-	long x;
-	long y;
-} TPacketGGWarpCharacter;
-
-//HEADER_GG_GUILD_WAR_ZONE_MAP_INDEX = 15,
-
-typedef struct SPacketGGGuildWarMapIndex
-{
-	BYTE bHeader;
-	DWORD dwGuildID1;
-	DWORD dwGuildID2;
-	long lMapIndex;
-} TPacketGGGuildWarMapIndex;
-
-typedef struct SPacketGGTransfer
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	long lX, lY;
-} TPacketGGTransfer;
-
-typedef struct SPacketGGLoginPing
-{
-	BYTE bHeader;
-	char szLogin[LOGIN_MAX_LEN + 1];
-} TPacketGGLoginPing;
-
-typedef struct SPacketGGBlockChat
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	long lBlockDuration;
-} TPacketGGBlockChat;
-
-/* 클라이언트 측에서 보내는 패킷 */
-typedef struct command_text
-{
-	BYTE bHeader;
-} TPacketCGText;
-
-typedef struct command_phase
-{
-	BYTE bHeader;
-} TPacketCGPhase;
-
-/* 로그인 (1) */
-typedef struct command_handshake
-{
-	BYTE bHeader;
-	DWORD dwHandshake;
-	DWORD dwTime;
-	long lDelta;
-} TPacketCGHandshake;
-
-typedef struct command_login
-{
-	BYTE header;
-	char login[LOGIN_MAX_LEN + 1];
-	char passwd[PASSWD_MAX_LEN + 1];
-} TPacketCGLogin;
-
-typedef struct command_login2
-{
-	BYTE header;
-	char login[LOGIN_MAX_LEN + 1];
-	DWORD dwLoginKey;
-	DWORD adwClientKey[4];
-} TPacketCGLogin2;
-
-typedef struct command_login3
-{
-	BYTE header;
-	char login[LOGIN_MAX_LEN + 1];
-	char passwd[PASSWD_MAX_LEN + 1];
-	DWORD adwClientKey[4];
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char country[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketCGLogin3;
-
-typedef struct packet_login_key
-{
-	BYTE bHeader;
-	DWORD dwLoginKey;
-} TPacketGCLoginKey;
-
-typedef struct command_player_select
-{
-	BYTE header;
-	BYTE index;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char country[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketCGPlayerSelect;
-
-typedef struct command_player_delete
-{
-	BYTE header;
-	BYTE index;
-	char private_code[8];
-} TPacketCGPlayerDelete;
-
-typedef struct command_player_create
-{
-	BYTE header;
-	BYTE index;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	WORD job;
-	BYTE shape;
-	BYTE Con;
-	BYTE Int;
-	BYTE Str;
-	BYTE Dex;
-} TPacketCGPlayerCreate;
-
-typedef struct command_player_create_success
-{
-	BYTE header;
-	BYTE bAccountCharacterIndex;
-	TSimplePlayer player;
-} TPacketGCPlayerCreateSuccess;
-
-// 공격
-typedef struct command_attack
-{
-	BYTE bHeader;
-	BYTE bType;
-	DWORD dwVID;
-	BYTE bCRCMagicCubeProcPiece;
-	BYTE bCRCMagicCubeFilePiece;
-} TPacketCGAttack;
-
-enum EMoveFuncType
-{
-	FUNC_WAIT,
-	FUNC_MOVE,
-	FUNC_ATTACK,
-	FUNC_COMBO,
-	FUNC_MOB_SKILL,
-	_FUNC_SKILL,
-	FUNC_MAX_NUM,
-	FUNC_SKILL = 0x80,
-};
-
-// 이동
-typedef struct command_move
-{
-	BYTE bHeader;
-	BYTE bFunc;
-	BYTE bArg;
-	BYTE bRot;
-	long lX;
-	long lY;
-	DWORD dwTime;
-} TPacketCGMove;
-
-typedef struct command_sync_position_element
-{
-	DWORD dwVID;
-	long lX;
-	long lY;
-} TPacketCGSyncPositionElement;
-
-// 위치 동기화
-typedef struct command_sync_position // 가변 패킷
-{
-	BYTE bHeader;
-	WORD wSize;
-} TPacketCGSyncPosition;
-
-/* 채팅 (3) */
-typedef struct command_chat // 가변 패킷
-{
-	BYTE header;
-	WORD size;
-	BYTE type;
-} TPacketCGChat;
-
-/* 귓속말 */
-typedef struct command_whisper
-{
-	BYTE bHeader;
-	WORD wSize;
-	char szNameTo[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketCGWhisper;
-
-typedef struct command_entergame
-{
-	BYTE header;
-} TPacketCGEnterGame;
-
-typedef struct command_item_use
-{
-	BYTE header;
-	TItemPos Cell;
-} TPacketCGItemUse;
-
-typedef struct command_item_use_to_item
-{
-	BYTE header;
-	TItemPos Cell;
-	TItemPos TargetCell;
-} TPacketCGItemUseToItem;
-
-typedef struct command_item_drop
-{
-	BYTE header;
-	TItemPos Cell;
-	DWORD gold;
-#if defined(__CHEQUE_SYSTEM__)
-	DWORD cheque;
-#endif
-} TPacketCGItemDrop;
-
-typedef struct command_item_drop2
-{
-	BYTE header;
-	TItemPos Cell;
-	DWORD gold;
-#if defined(__CHEQUE_SYSTEM__)
-	DWORD cheque;
-#endif
-	WORD count;
-} TPacketCGItemDrop2;
-
-#if defined(__NEW_DROP_DIALOG__)
-typedef struct command_item_destroy
-{
-	BYTE header;
-	TItemPos Cell;
-} TPacketCGItemDestroy;
-#endif
-
-typedef struct command_item_move
-{
-	BYTE header;
-	TItemPos Cell;
-	TItemPos CellTo;
-	WORD count;
-} TPacketCGItemMove;
-
-typedef struct command_item_pickup
-{
-	BYTE header;
-	DWORD vid;
-} TPacketCGItemPickup;
-
-typedef struct command_quickslot_add
-{
-	BYTE header;
-	BYTE pos;
-	TQuickslot slot;
-} TPacketCGQuickslotAdd;
-
-typedef struct command_quickslot_del
-{
-	BYTE header;
-	BYTE pos;
-} TPacketCGQuickslotDel;
-
-typedef struct command_quickslot_swap
-{
-	BYTE header;
-	BYTE pos;
-	BYTE change_pos;
-} TPacketCGQuickslotSwap;
-
-enum
-{
-	SHOP_SUBHEADER_CG_END,
-	SHOP_SUBHEADER_CG_BUY,
-	SHOP_SUBHEADER_CG_SELL,
-	SHOP_SUBHEADER_CG_SELL2,
-};
-
-typedef struct command_shop_buy
-{
-	BYTE count;
-} TPacketCGShopBuy;
-
-typedef struct command_shop_sell
-{
-	WORD wPos;
-	WORD wCount;
-	BYTE bType;
-} TPacketCGShopSell;
-
-typedef struct command_shop
-{
-	BYTE header;
-	WORD subheader;
-} TPacketCGShop;
-
-typedef struct command_on_click
-{
-	BYTE header;
-	DWORD vid;
-} TPacketCGOnClick;
-
-enum
-{
-	EXCHANGE_SUBHEADER_CG_START, /* arg1 == vid of target character */
-	EXCHANGE_SUBHEADER_CG_ITEM_ADD, /* arg1 == position of item */
-	EXCHANGE_SUBHEADER_CG_ITEM_DEL, /* arg1 == position of item */
-	EXCHANGE_SUBHEADER_CG_ELK_ADD, /* arg1 == amount of gold */
-#if defined(__CHEQUE_SYSTEM__)
-	EXCHANGE_SUBHEADER_CG_CHEQUE_ADD, /* arg1 == amount of cheque */
-#endif
-	EXCHANGE_SUBHEADER_CG_ACCEPT, /* arg1 == not used */
-	EXCHANGE_SUBHEADER_CG_CANCEL, /* arg1 == not used */
-};
-
-typedef struct command_exchange
-{
-	BYTE header;
-	BYTE sub_header;
-	DWORD arg1;
-	BYTE arg2;
-	TItemPos Pos;
-} TPacketCGExchange;
-
-typedef struct command_position
-{
-	BYTE header;
-	BYTE position;
-} TPacketCGPosition;
-
-typedef struct command_script_answer
-{
-	BYTE header;
-	BYTE answer;
-	//char file[32 + 1];
-	//BYTE answer[16 + 1];
-} TPacketCGScriptAnswer;
-
-typedef struct command_script_button
-{
-	BYTE header;
-	unsigned int idx;
-} TPacketCGScriptButton;
-
-typedef struct command_quest_input_string
-{
-	BYTE header;
-	char msg[64 + 1];
-} TPacketCGQuestInputString;
-
-#if defined(__OX_RENEWAL__)
-typedef struct command_quest_input_long_string
-{
-	BYTE header;
-	char msg[128 + 1];
-} TPacketCGQuestInputLongString;
-#endif
-
-typedef struct command_quest_confirm
-{
-	BYTE header;
-	BYTE answer;
-	DWORD requestPID;
-} TPacketCGQuestConfirm;
-
-/*
-* 서버 측에서 보내는 패킷
-*/
-typedef struct packet_quest_confirm
-{
-	BYTE header;
-	char msg[128 + 1];
-	long timeout;
-	DWORD requestPID;
-} TPacketGCQuestConfirm;
-
-typedef struct packet_handshake
-{
-	BYTE bHeader;
-	DWORD dwHandshake;
-	DWORD dwTime;
-	long lDelta;
-} TPacketGCHandshake;
-
-enum EPhase
-{
-	PHASE_CLOSE,
-	PHASE_HANDSHAKE,
-	PHASE_LOGIN,
-	PHASE_SELECT,
-	PHASE_LOADING,
-	PHASE_GAME,
-	PHASE_DEAD,
-
-	PHASE_CLIENT_CONNECTING,
-	PHASE_DBCLIENT,
-	PHASE_P2P,
-	PHASE_AUTH,
-};
-
-typedef struct packet_phase
-{
-	BYTE header;
-	BYTE phase;
-} TPacketGCPhase;
-
-typedef struct packet_bindudp
-{
-	BYTE header;
-	DWORD addr;
-	WORD port;
-} TPacketGCBindUDP;
-
-typedef struct packet_login_success
-{
-	BYTE bHeader;
-	TSimplePlayer players[PLAYER_PER_ACCOUNT];
-	DWORD guild_id[PLAYER_PER_ACCOUNT];
-	char guild_name[PLAYER_PER_ACCOUNT][GUILD_NAME_MAX_LEN + 1];
-
-	DWORD handle;
-	DWORD random_key;
-} TPacketGCLoginSuccess;
-
-typedef struct packet_auth_success
-{
-	BYTE bHeader;
-	DWORD dwLoginKey;
-	BYTE bResult;
-	BOOL bState;
-} TPacketGCAuthSuccess;
-
-enum ELoginFailure
-{
-	LOGIN_FAILURE_NONE,
-	LOGIN_FAILURE_ALREADY,
-	LOGIN_FAILURE_NOID,
-	LOGIN_FAILURE_WRONGPWD,
-	LOGIN_FAILURE_FULL,
-	LOGIN_FAILURE_SHUTDOWN,
-	LOGIN_FAILURE_REPAIR,
-	LOGIN_FAILURE_BLOCK,
-	LOGIN_FAILURE_WRONGMAT,
-	LOGIN_FAILURE_QUIT,
-	LOGIN_FAILURE_BESAMEKEY,
-	LOGIN_FAILURE_NOTAVAIL,
-	LOGIN_FAILURE_BLKLOGIN,
-	LOGIN_FAILURE_WEBBLK,
-	LOGIN_FAILURE_BADSCLID,
-	LOGIN_FAILURE_AGELIMIT,
-	LOGIN_FAILURE_CONFIRM,
-	LOGIN_FAILURE_INACTIVE,
-	LOGIN_FAILURE_UNMIGRATION,
-	LOGIN_FAILURE_MPROCESSING,
-	LOGIN_FAILURE_LOCKED,
-	LOGIN_FAILURE_BACKENDERR,
-	LOGIN_FAILURE_INTEGRTING,
-	LOGIN_FAILURE_COUNTRYERR,
-	LOGIN_FAILURE_IOVATION,
-	LOGIN_FAILURE_TNTERR,
-	LOGIN_FAILURE_SERVER_CLOSED,
-	LOGIN_FAILURE_SERVER_GRADE,
-};
-
-typedef struct packet_login_failure
-{
-	BYTE header;
-	char szStatus[ACCOUNT_STATUS_MAX_LEN + 1];
-} TPacketGCLoginFailure;
-
-typedef struct packet_create_failure
-{
-	BYTE header;
-	BYTE bType;
-} TPacketGCCreateFailure;
-
-enum
-{
-	ADD_CHARACTER_STATE_DEAD = (1 << 0),
-	ADD_CHARACTER_STATE_SPAWN = (1 << 1),
-	ADD_CHARACTER_STATE_GUNGON = (1 << 2),
-	ADD_CHARACTER_STATE_KILLER = (1 << 3),
-	ADD_CHARACTER_STATE_PARTY = (1 << 4),
-};
-
-enum ECharacterEquipmentPart
-{
-	CHR_EQUIPPART_ARMOR,
-	CHR_EQUIPPART_WEAPON,
-	CHR_EQUIPPART_HEAD,
-	CHR_EQUIPPART_HAIR,
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	CHR_EQUIPPART_ACCE,
-#endif
-	CHR_EQUIPPART_AURA,
-
-	CHR_EQUIPPART_NUM,
-};
-
-typedef struct packet_add_char
-{
-	BYTE header;
-	DWORD dwVID;
-
-#if defined(__WJ_SHOW_MOB_INFO__)
-	DWORD dwLevel;
-	DWORD dwAIFlag;
-#endif
-
-	float angle;
-	long x;
-	long y;
-	long z;
-
-	BYTE bType;
-	WORD wRaceNum;
-#if defined(__RACE_SWAP__)
-	DWORD dwEventRaceNum;
-#endif
-	BYTE bMovingSpeed;
-	BYTE bAttackSpeed;
-
-	BYTE bStateFlag;
-	DWORD dwAffectFlag[3]; // 효과
-} TPacketGCCharacterAdd;
-
-typedef struct packet_char_additional_info
-{
-	BYTE header;
-	DWORD dwVID;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	DWORD adwPart[CHR_EQUIPPART_NUM];
-	BYTE bEmpire;
-	DWORD dwGuildID;
-	DWORD dwLevel;
-#if defined(__CONQUEROR_LEVEL__)
-	DWORD dwConquerorLevel;
-#endif
-	short sAlignment; // 선악치
-	BYTE bPKMode;
-	DWORD dwMountVnum;
-#if defined(__QUIVER_SYSTEM__)
-	DWORD dwArrow;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	WORD wRefineElementAffectType;
-#endif
-#if defined(__GUILD_LEADER_GRADE_NAME__)
-	BYTE bGuildLeaderGrade;
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-	BYTE bCharacterSize;
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketGCCharacterAdditionalInfo;
-
-typedef struct packet_update_char
-{
-	BYTE header;
-	DWORD dwVID;
-
-	DWORD adwPart[CHR_EQUIPPART_NUM];
-
-	BYTE bMovingSpeed;
-	BYTE bAttackSpeed;
-
-	BYTE bStateFlag;
-	DWORD dwAffectFlag[3];
-
-	DWORD dwGuildID;
-	short sAlignment;
-	DWORD dwLevel;
-#if defined(__CONQUEROR_LEVEL__)
-	DWORD dwConquerorLevel;
-#endif
-	BYTE bPKMode;
-	DWORD dwMountVnum;
-#if defined(__QUIVER_SYSTEM__)
-	DWORD dwArrow;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	WORD wRefineElementAffectType;
-#endif
-#if defined(__GUILD_LEADER_GRADE_NAME__)
-	BYTE bGuildLeaderGrade;
-#endif
-#if defined(__LEFT_SEAT__)
-	bool bLeftSeat;
-#endif
-} TPacketGCCharacterUpdate;
-
-typedef struct packet_del_char
-{
-	BYTE header;
-	DWORD id;
-} TPacketGCCharacterDelete;
-
-typedef struct packet_chat // 가변 패킷
-{
-	BYTE header;
-	WORD size;
-	BYTE type;
-	DWORD id;
-	BYTE bEmpire;
-#if defined(__LOCALE_CLIENT__)
-	bool bCanFormat;
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-#if defined(__LOCALE_CLIENT__)
-	packet_chat() : bCanFormat(true) {}
-#endif
-} TPacketGCChat;
-
-typedef struct packet_whisper // 가변 패킷
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bType;
-	char szNameFrom[CHARACTER_NAME_MAX_LEN + 1];
-#if defined(__LOCALE_CLIENT__)
-	bool bCanFormat;
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-#if defined(__LOCALE_CLIENT__)
-	packet_whisper() : bCanFormat(true) {}
-#endif
-} TPacketGCWhisper;
-
-typedef struct packet_main_character
-{
-	BYTE header;
-	DWORD dwVID;
-	WORD wRaceNum;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	long lx, ly, lz;
-	BYTE empire;
-	BYTE skill_group;
-} TPacketGCMainCharacter;
-
-// SUPPORT_BGM
-typedef struct packet_main_character3_bgm
-{
-	enum
-	{
-		MUSIC_NAME_LEN = 24,
-	};
-
-	BYTE header;
-	DWORD dwVID;
-	WORD wRaceNum;
-	char szChrName[CHARACTER_NAME_MAX_LEN + 1];
-	char szBGMName[MUSIC_NAME_LEN + 1];
-	long lx, ly, lz;
-	BYTE empire;
-	BYTE skill_group;
-} TPacketGCMainCharacter3_BGM;
-
-typedef struct packet_main_character4_bgm_vol
-{
-	enum
-	{
-		MUSIC_NAME_LEN = 24,
-	};
-
-	BYTE header;
-	DWORD dwVID;
-	WORD wRaceNum;
-	char szChrName[CHARACTER_NAME_MAX_LEN + 1];
-	char szBGMName[MUSIC_NAME_LEN + 1];
-	float fBGMVol;
-	long lx, ly, lz;
-	BYTE empire;
-	BYTE skill_group;
-} TPacketGCMainCharacter4_BGM_VOL;
-// END_OF_SUPPORT_BGM
-
-typedef struct packet_points
-{
-	BYTE bHeader;
-	POINT_VALUE lPoints[POINT_MAX_NUM];
-} TPacketGCPoints;
-
-typedef struct packet_skill_level
-{
-	BYTE bHeader;
-	TPlayerSkill skills[SKILL_MAX_NUM];
-} TPacketGCSkillLevel;
-
-typedef struct packet_point_change
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	POINT_TYPE wType;
-	POINT_VALUE lAmount;
-	POINT_VALUE lValue;
-} TPacketGCPointChange;
-
-typedef struct packet_stun
-{
-	BYTE header;
-	DWORD vid;
-} TPacketGCStun;
-
-typedef struct packet_dead
-{
-	BYTE header;
-	DWORD vid;
-	BYTE dialog_type;
-	long map_index;
-	packet_dead() : dialog_type(DEAD_DIALOG_NORMAL), map_index(0) {}
-} TPacketGCDead;
-
-typedef struct packet_item_set_empty
-{
-	BYTE bHeader;
-	TItemPos Cell;
-	DWORD dwVnum;
-	DWORD dwCount;
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-} TPacketGCItemSetEmpty;
-
-typedef struct packet_item_set
-{
-	BYTE bHeader;
-	TItemPos Cell;
-	DWORD dwVnum;
-	DWORD dwCount;
-	DWORD dwFlags;
-	DWORD dwAntiFlags;
-	bool bHighLight;
-#if defined(__SOUL_BIND_SYSTEM__)
-	long lSealDate;
-#endif
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-} TPacketGCItemSet;
-
-typedef struct packet_item_del
-{
-	BYTE header;
-	BYTE pos;
-} TPacketGCItemDel;
-
-struct packet_item_use
-{
-	BYTE header;
-	TItemPos Cell;
-	DWORD ch_vid;
-	DWORD victim_vid;
-	DWORD vnum;
-};
-
-struct packet_item_move
-{
-	BYTE header;
-	TItemPos Cell;
-	TItemPos CellTo;
-};
-
-typedef struct packet_item_update
-{
-	BYTE bHeader;
-	TItemPos Cell;
-	DWORD dwCount;
-#if defined(__SOUL_BIND_SYSTEM__)
-	long lSealDate;
-#endif
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-} TPacketGCItemUpdate;
-
-typedef struct packet_item_ground_add
-{
-#if defined(__ITEM_DROP_RENEWAL__)
-	packet_item_ground_add()
-	{
-		memset(&alSockets, 0, sizeof(alSockets));
-		memset(&aAttrs, 0, sizeof(aAttrs));
-	}
-#endif
-
-	BYTE bHeader;
-	long lX, lY, lZ;
-	DWORD dwVID;
-	DWORD dwVnum;
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-
-#if defined(__ITEM_DROP_RENEWAL__)
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttrs[ITEM_ATTRIBUTE_MAX_NUM];
-#endif
-} TPacketGCItemGroundAdd;
-
-typedef struct packet_item_ownership
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGCItemOwnership;
-
-typedef struct packet_item_ground_del
-{
-	BYTE bHeader;
-	DWORD dwVID;
-} TPacketGCItemGroundDel;
-
-struct packet_quickslot_add
-{
-	BYTE header;
-	BYTE pos;
-	TQuickslot slot;
-};
-
-struct packet_quickslot_del
-{
-	BYTE header;
-	BYTE pos;
-};
-
-struct packet_quickslot_swap
-{
-	BYTE header;
-	BYTE pos;
-	BYTE pos_to;
-};
-
-struct packet_motion
-{
-	BYTE header;
-	DWORD vid;
-	DWORD victim_vid;
-	WORD motion;
-};
-
-enum EPacketShopSubHeaders
-{
-	SHOP_SUBHEADER_GC_NONE,
-	SHOP_SUBHEADER_GC_START,
-	SHOP_SUBHEADER_GC_END,
-	SHOP_SUBHEADER_GC_UPDATE_ITEM,
-	SHOP_SUBHEADER_GC_UPDATE_PRICE,
-	SHOP_SUBHEADER_GC_OK,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY,
-	SHOP_SUBHEADER_GC_SOLDOUT,
-	SHOP_SUBHEADER_GC_INVENTORY_FULL,
-	SHOP_SUBHEADER_GC_INVALID_POS,
-	SHOP_SUBHEADER_GC_SOLD_OUT,
-	SHOP_SUBHEADER_GC_START_EX,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY_EX,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_BP,
-	SHOP_SUBHEADER_GC_EXCEED_LIMIT_TODAY,
-#if defined(__MYSHOP_DECO__)
-	SHOP_SUBHEADER_GC_MYPRIV_SHOP_OPEN,
-#endif
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_10TH_COIN,
-	SHOP_SUBHEADER_GC_LIMITED_PURCHASE_OVER,
-	SHOP_SUBHEADER_GC_LIMITED_DATA_LOADING,
-	SHOP_SUBHEADER_GC_UNK_19,
-	SHOP_SUBHEADER_GC_UNK_20,
-	SHOP_SUBHEADER_GC_UNK_21,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_MEDAL_OF_HONOR,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_GUILD_LEVEL,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_BNW,
-#if defined(__SHOPEX_RENEWAL__)
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_ITEM,
-#endif
-};
-
-struct packet_shop_item
-{
-	DWORD dwVnum;
-	DWORD dwCount;
-	DWORD dwPrice;
-#if defined(__CHEQUE_SYSTEM__)
-	DWORD dwCheque;
-#endif
-	BYTE bDisplayPos;
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-#if defined(__SHOPEX_RENEWAL__)
-	BYTE bPriceType;
-	DWORD dwPriceVnum;
-#endif
-	packet_shop_item()
-	{
-#if defined(__CHEQUE_SYSTEM__)
-		dwCheque = 0;
-#endif
-		memset(&alSockets, 0, sizeof(alSockets));
-		memset(&aAttr, 0, sizeof(aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		dwTransmutationVnum = 0;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		memset(&RefineElement, 0, sizeof(RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-		memset(&aApplyRandom, 0, sizeof(aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-		bSetValue = 0;
-#endif
-#if defined(__SHOPEX_RENEWAL__)
-		bPriceType = SHOP_COIN_TYPE_GOLD;
-		dwPriceVnum = 0;
-#endif
-	}
-};
-
-typedef struct packet_shop_start
-{
-	DWORD owner_vid;
-#if defined(__MYSHOP_DECO__)
-	BYTE shop_tab_count;
-#endif
-#if defined(__MYSHOP_EXPANSION__)
-	struct packet_shop_item items[SHOP_HOST_ITEM_MAX];
-#else
-	struct packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
-#endif
-} TPacketGCShopStart;
-
-typedef struct packet_shop_start_ex // 다음에 TSubPacketShopTab* shop_tabs 이 따라옴.
-{
-	typedef struct sub_packet_shop_tab
-	{
-		char name[SHOP_TAB_NAME_MAX];
-		BYTE coin_type;
-		packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
-	} TSubPacketShopTab;
-	DWORD owner_vid;
-	BYTE shop_tab_count;
-} TPacketGCShopStartEx;
-
-typedef struct packet_shop_update_item
-{
-	BYTE pos;
-	struct packet_shop_item item;
-} TPacketGCShopUpdateItem;
-
-typedef struct packet_shop_update_price
-{
-	int iPrice;
-#if defined(__CHEQUE_SYSTEM__)
-	int iCheque;
-#endif
-} TPacketGCShopUpdatePrice;
-
-typedef struct packet_shop // 가변 패킷
-{
-	BYTE header;
-	WORD size;
-	BYTE subheader;
-} TPacketGCShop;
-
-typedef struct packet_exchange
-{
-	BYTE header;
-	BYTE sub_header;
-	BYTE is_me;
-	DWORD arg1; // vnum
-	TItemPos arg2; // cell
-	DWORD arg3; // count
-	TItemPos arg4;
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetItem;
-#endif
-} TPacketGCExchange;
-
-enum EPacketTradeSubHeaders
-{
-	EXCHANGE_SUBHEADER_GC_START, /* arg1 == vid */
-	EXCHANGE_SUBHEADER_GC_ITEM_ADD, /* arg1 == vnum arg2 == pos arg3 == count */
-	EXCHANGE_SUBHEADER_GC_ITEM_DEL,
-	EXCHANGE_SUBHEADER_GC_GOLD_ADD, /* arg1 == gold */
-#if defined(__CHEQUE_SYSTEM__)
-	EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, /* arg1 == cheque */
-#endif
-	EXCHANGE_SUBHEADER_GC_ACCEPT, /* arg1 == accept */
-	EXCHANGE_SUBHEADER_GC_END, /* arg1 == not used */
-	EXCHANGE_SUBHEADER_GC_ALREADY, /* arg1 == not used */
-	EXCHANGE_SUBHEADER_GC_LESS_GOLD, /* arg1 == not used */
-#if defined(__CHEQUE_SYSTEM__)
-	EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, /* arg1 == not used */
-#endif
-};
-
-struct packet_position
-{
-	BYTE header;
-	DWORD vid;
-	BYTE position;
-};
-
-typedef struct packet_ping
-{
-	BYTE header;
-} TPacketGCPing;
-
-struct packet_script
-{
-	BYTE header;
-	WORD size;
-	BYTE skin;
-	WORD src_size;
-};
-
-typedef struct packet_change_speed
-{
-	BYTE header;
-	DWORD vid;
-	WORD moving_speed;
-} TPacketGCChangeSpeed;
-
-struct packet_mount
-{
-	BYTE header;
-	DWORD vid;
-	DWORD mount_vid;
-	BYTE pos;
-	DWORD x, y;
-};
-
-typedef struct packet_move
-{
-	BYTE bHeader;
-	BYTE bFunc;
-	BYTE bArg;
-	BYTE bRot;
-	DWORD dwVID;
-	long lX;
-	long lY;
-	DWORD dwTime;
-	DWORD dwDuration;
-} TPacketGCMove;
-
-// 소유권
-typedef struct packet_ownership
-{
-	BYTE bHeader;
-	DWORD dwOwnerVID;
-	DWORD dwVictimVID;
-} TPacketGCOwnership;
-
-// 위치 동기화 패킷의 bCount 만큼 붙는 단위
-typedef struct packet_sync_position_element
-{
-	DWORD dwVID;
-	long lX;
-	long lY;
-} TPacketGCSyncPositionElement;
-
-// 위치 동기화
-typedef struct packet_sync_position // 가변 패킷
-{
-	BYTE bHeader;
-	WORD wSize; // 개수 = (wSize - sizeof(TPacketGCSyncPosition)) / sizeof(TPacketGCSyncPositionElement) 
-} TPacketGCSyncPosition;
-
-typedef struct packet_fly
-{
-	BYTE bHeader;
-	BYTE bType;
-	DWORD dwStartVID;
-	DWORD dwEndVID;
-} TPacketGCCreateFly;
-
-typedef struct command_fly_targeting
-{
-	BYTE bHeader;
-	DWORD dwTargetVID;
-	long x, y;
-} TPacketCGFlyTargeting;
-
-typedef struct packet_fly_targeting
-{
-	BYTE bHeader;
-	DWORD dwShooterVID;
-	DWORD dwTargetVID;
-	long x, y;
-} TPacketGCFlyTargeting;
-
-typedef struct packet_shoot
-{
-	BYTE bHeader;
-	BYTE bType;
-} TPacketCGShoot;
-
-typedef struct packet_duel_start
-{
-	BYTE header;
-	WORD wSize; // DWORD가 몇개? 개수 = (wSize - sizeof(TPacketGCPVPList)) / 4
-} TPacketGCDuelStart;
-
-enum EPVPModes
-{
-	PVP_MODE_NONE,
-	PVP_MODE_AGREE,
-	PVP_MODE_FIGHT,
-	PVP_MODE_REVENGE
-};
-
-typedef struct packet_pvp
-{
-	BYTE bHeader;
-	DWORD dwVIDSrc;
-	DWORD dwVIDDst;
-	BYTE bMode; // 0 이면 끔, 1이면 켬
-} TPacketGCPVP;
-
-typedef struct command_use_skill
-{
-	BYTE bHeader;
-	DWORD dwVnum;
-	DWORD dwVID;
-} TPacketCGUseSkill;
-
-typedef struct command_target
-{
-	BYTE header;
-	DWORD dwVID;
-} TPacketCGTarget;
-
-typedef struct packet_target
-{
-	BYTE header;
-	DWORD dwVID;
-	BYTE bHPPercent;
-#if defined(__VIEW_TARGET_HP__) || defined(__DEFENSE_WAVE__)
-	int iMinHP;
-	int iMaxHP;
-	bool bAlliance;
-#endif
-#if defined(__ELEMENT_SYSTEM__)
-	BYTE bElement[MOB_ELEMENT_MAX_NUM];
-#endif
-	packet_target() : dwVID(0), bHPPercent(0)
-	{
-#if defined(__VIEW_TARGET_HP__) || defined(__DEFENSE_WAVE__)
-		iMinHP = 0;
-		iMaxHP = 0;
-		bAlliance = false;
-#endif
-#if defined(__ELEMENT_SYSTEM__)
-		memset(&bElement, 0, sizeof(bElement));
-#endif
-	}
-} TPacketGCTarget;
-
-#if defined(__SEND_TARGET_INFO__)
-typedef struct SPacketGCTargetDropInfo
-{
-	DWORD dwVnum;
-	BYTE bCount;
-} TPacketGCTargetDropInfo;
-
-typedef struct SPacketGCTargetInfo
-{
-	BYTE bHeader;
-	WORD wSize;
-	DWORD dwRaceVnum;
-	DWORD dwVID;
-	bool bDropMetinStone;
-} TPacketGCTargetInfo;
-
-typedef struct SPacketCGTargetInfo
-{
-	BYTE bHeader;
-	DWORD dwVID;
-} TPacketCGTargetInfo;
-#endif
-
-typedef struct packet_warp
-{
-	BYTE bHeader;
-	long lX;
-	long lY;
-	long lAddr;
-	WORD wPort;
-} TPacketGCWarp;
-
-typedef struct command_warp
-{
-	BYTE bHeader;
-} TPacketCGWarp;
-
-struct packet_quest_info
-{
-	BYTE header;
-	WORD size;
-	WORD index;
-#if defined(__QUEST_RENEWAL__)
-	BYTE type;
-	bool is_confirmed;
-#endif
-	BYTE flag;
-};
-
-typedef struct command_safebox_checkout
-{
-	BYTE bHeader;
-	BYTE bSafePos;
-	TItemPos ItemPos;
-} TPacketCGSafeboxCheckout;
-
-typedef struct command_safebox_checkin
-{
-	BYTE bHeader;
-	BYTE bSafePos;
-	TItemPos ItemPos;
-} TPacketCGSafeboxCheckin;
-
-///////////////////////////////////////////////////////////////////////////////////
-// Messenger
-
-enum EMessengerConnectedState
-{
-	MESSENGER_CONNECTED_STATE_OFFLINE,
-	MESSENGER_CONNECTED_STATE_ONLINE
-};
-
-enum EGCMessengerSubHeader
-{
-	MESSENGER_SUBHEADER_GC_LIST,
-	MESSENGER_SUBHEADER_GC_LOGIN,
-	MESSENGER_SUBHEADER_GC_LOGOUT,
-	MESSENGER_SUBHEADER_GC_INVITE,
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	MESSENGER_SUBHEADER_GC_BLOCK_LIST,
-	MESSENGER_SUBHEADER_GC_BLOCK_LOGIN,
-	MESSENGER_SUBHEADER_GC_BLOCK_LOGOUT,
-#endif
-#if defined(__MESSENGER_GM__)
-	MESSENGER_SUBHEADER_GC_GM_LIST,
-	MESSENGER_SUBHEADER_GC_GM_LOGIN,
-	MESSENGER_SUBHEADER_GC_GM_LOGOUT,
-#endif
-};
-
-typedef struct packet_messenger
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMessenger;
-
-typedef struct packet_messenger_list
-{
-	packet_messenger_list() :
-		bConnected(MESSENGER_CONNECTED_STATE_OFFLINE)
-#if defined(__MESSENGER_DETAILS__)
-		, dwLastPlayTime(0)
-#endif
-	{
-	}
-	BYTE bConnected;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-#if defined(__MESSENGER_DETAILS__)
-	DWORD dwLastPlayTime;
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1]{};
-#endif
-#endif
-} TPacketGCMessengerList;
-
-enum ECGMessengerSubHeader
-{
-	MESSENGER_SUBHEADER_CG_ADD_BY_VID,
-	MESSENGER_SUBHEADER_CG_ADD_BY_NAME,
-	MESSENGER_SUBHEADER_CG_REMOVE,
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID,
-	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME,
-	MESSENGER_SUBHEADER_CG_BLOCK_REMOVE,
-#endif
-};
-
-typedef struct command_messenger
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-} TPacketCGMessenger;
-
-typedef struct command_messenger_add_by_vid
-{
-	DWORD dwVID;
-} TPacketCGMessengerAddByVID;
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-typedef struct command_messenger_add_block_by_vid
-{
-	DWORD dwVID;
-} TPacketCGMessengerAddBlockByVID;
-#endif
-
-///////////////////////////////////////////////////////////////////////////////////
-// Party
-typedef struct command_party_parameter
-{
-	BYTE bHeader;
-	BYTE bDistributeMode;
-} TPacketCGPartyParameter;
-
-typedef struct paryt_parameter
-{
-	BYTE bHeader;
-	BYTE bDistributeMode;
-} TPacketGCPartyParameter;
-
-typedef struct packet_party_add
-{
-	BYTE header;
-	DWORD pid;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	long mapIdx;
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-	BYTE channel;
-#endif
-} TPacketGCPartyAdd;
-
-typedef struct command_party_invite
-{
-	BYTE header;
-	DWORD vid;
-} TPacketCGPartyInvite;
-
-typedef struct packet_party_invite
-{
-	BYTE header;
-	DWORD leader_vid;
-} TPacketGCPartyInvite;
-
-typedef struct command_party_invite_answer
-{
-	BYTE header;
-	DWORD leader_vid;
-	BYTE accept;
-} TPacketCGPartyInviteAnswer;
-
-typedef struct packet_party_update
-{
-	BYTE header;
-	DWORD pid;
-	BYTE role;
-	BYTE percent_hp;
-	short affects[7];
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	long x;
-	long y;
-#endif
-} TPacketGCPartyUpdate;
-
-typedef struct packet_party_remove
-{
-	BYTE header;
-	DWORD pid;
-} TPacketGCPartyRemove;
-
-typedef struct packet_party_link
-{
-	BYTE header;
-	DWORD pid;
-	DWORD vid;
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	long mapIdx;
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-	BYTE channel;
-#endif
-} TPacketGCPartyLink;
-
-typedef struct command_party_remove
-{
-	BYTE header;
-	DWORD pid;
-} TPacketCGPartyRemove;
-
-typedef struct command_party_set_state
-{
-	BYTE header;
-	DWORD pid;
-	BYTE byRole;
-	BYTE flag;
-} TPacketCGPartySetState;
-
-enum
-{
-	PARTY_SKILL_HEAL = 1,
-	PARTY_SKILL_WARP = 2
-};
-
-typedef struct command_party_use_skill
-{
-	BYTE header;
-	BYTE bySkillIndex;
-	DWORD vid;
-} TPacketCGPartyUseSkill;
-
-typedef struct packet_safebox_size
-{
-	BYTE bHeader;
-	BYTE bSize;
-} TPacketCGSafeboxSize;
-
-typedef struct packet_safebox_wrong_password
-{
-	BYTE bHeader;
-} TPacketCGSafeboxWrongPassword;
-
-typedef struct command_empire
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-} TPacketCGEmpire;
-
-typedef struct packet_empire
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-} TPacketGCEmpire;
-
-enum
-{
-	SAFEBOX_MONEY_STATE_SAVE,
-	SAFEBOX_MONEY_STATE_WITHDRAW,
-};
-
-typedef struct command_safebox_money
-{
-	BYTE bHeader;
-	BYTE bState;
-	long lMoney;
-} TPacketCGSafeboxMoney;
-
-typedef struct packet_safebox_money_change
-{
-	BYTE bHeader;
-	long lMoney;
-} TPacketGCSafeboxMoneyChange;
-
-// Guild
-enum
-{
-	GUILD_SUBHEADER_GC_LOGIN,
-	GUILD_SUBHEADER_GC_LOGOUT,
-	GUILD_SUBHEADER_GC_LIST,
-	GUILD_SUBHEADER_GC_GRADE,
-	GUILD_SUBHEADER_GC_ADD,
-	GUILD_SUBHEADER_GC_REMOVE,
-	GUILD_SUBHEADER_GC_GRADE_NAME,
-	GUILD_SUBHEADER_GC_GRADE_AUTH,
-	GUILD_SUBHEADER_GC_INFO,
-	GUILD_SUBHEADER_GC_COMMENTS,
-	GUILD_SUBHEADER_GC_CHANGE_EXP,
-	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GRADE,
-	GUILD_SUBHEADER_GC_SKILL_INFO,
-	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GENERAL,
-	GUILD_SUBHEADER_GC_GUILD_INVITE,
-	GUILD_SUBHEADER_GC_WAR,
-	GUILD_SUBHEADER_GC_GUILD_NAME,
-	GUILD_SUBHEADER_GC_GUILD_WAR_LIST,
-	GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST,
-	GUILD_SUBHEADER_GC_WAR_SCORE,
-	GUILD_SUBHEADER_GC_MONEY_CHANGE,
-};
-
-enum GUILD_SUBHEADER_CG
-{
-	GUILD_SUBHEADER_CG_ADD_MEMBER,
-	GUILD_SUBHEADER_CG_REMOVE_MEMBER,
-	GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME,
-	GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY,
-	GUILD_SUBHEADER_CG_OFFER,
-	GUILD_SUBHEADER_CG_POST_COMMENT,
-	GUILD_SUBHEADER_CG_DELETE_COMMENT,
-	GUILD_SUBHEADER_CG_REFRESH_COMMENT,
-	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE,
-	GUILD_SUBHEADER_CG_USE_SKILL,
-	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL,
-	GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER,
-	GUILD_SUBHEADER_CG_CHARGE_GSP,
-	GUILD_SUBHEADER_CG_DEPOSIT_MONEY,
-	GUILD_SUBHEADER_CG_WITHDRAW_MONEY,
-};
-
-typedef struct packet_guild
-{
-	BYTE header;
-	WORD size;
-	BYTE subheader;
-} TPacketGCGuild;
-
-typedef struct packet_guild_name_t
-{
-	BYTE header;
-	WORD size;
-	BYTE subheader;
-	DWORD guildID;
-	char guildName[GUILD_NAME_MAX_LEN];
-} TPacketGCGuildName;
-
-typedef struct packet_guild_war
-{
-	DWORD dwGuildSelf;
-	DWORD dwGuildOpp;
-	BYTE bType;
-	BYTE bWarState;
-} TPacketGCGuildWar;
-
-typedef struct command_guild
-{
-	BYTE header;
-	BYTE subheader;
-} TPacketCGGuild;
-
-typedef struct command_guild_answer_make_guild
-{
-	BYTE header;
-	char guild_name[GUILD_NAME_MAX_LEN + 1];
-} TPacketCGAnswerMakeGuild;
-
-typedef struct command_guild_use_skill
-{
-	DWORD dwVnum;
-	DWORD dwPID;
-} TPacketCGGuildUseSkill;
-
-// Guild Mark
-typedef struct command_mark_login
-{
-	BYTE header;
-	DWORD handle;
-	DWORD random_key;
-} TPacketCGMarkLogin;
-
-typedef struct command_mark_upload
-{
-	BYTE header;
-	DWORD gid;
-	BYTE image[16 * 12 * 4];
-} TPacketCGMarkUpload;
-
-typedef struct command_mark_idxlist
-{
-	BYTE header;
-} TPacketCGMarkIDXList;
-
-typedef struct command_mark_crclist
-{
-	BYTE header;
-	BYTE imgIdx;
-	DWORD crclist[80];
-} TPacketCGMarkCRCList;
-
-typedef struct packet_mark_idxlist
-{
-	BYTE header;
-	DWORD bufSize;
-	WORD count;
-	// 뒤에 size * (WORD + WORD)만큼 데이터 붙음
-} TPacketGCMarkIDXList;
-
-typedef struct packet_mark_block
-{
-	BYTE header;
-	DWORD bufSize;
-	BYTE imgIdx;
-	DWORD count;
-	// 뒤에 64 x 48 x 픽셀크기(4바이트) = 12288만큼 데이터 붙음
-} TPacketGCMarkBlock;
-
-typedef struct command_symbol_upload
-{
-	BYTE header;
-	WORD size;
-	DWORD guild_id;
-} TPacketCGGuildSymbolUpload;
-
-typedef struct command_symbol_crc
-{
-	BYTE header;
-	DWORD guild_id;
-	DWORD crc;
-	DWORD size;
-} TPacketCGSymbolCRC;
-
-typedef struct packet_symbol_data
-{
-	BYTE header;
-	WORD size;
-	DWORD guild_id;
-} TPacketGCGuildSymbolData;
-
-// Fishing
-typedef struct command_fishing
-{
-	BYTE header;
-	BYTE dir;
-} TPacketCGFishing;
-
-typedef struct packet_fishing
-{
-	BYTE header;
-	BYTE subheader;
-	DWORD info;
-	BYTE dir;
-} TPacketGCFishing;
-
-enum
-{
-	FISHING_SUBHEADER_GC_START,
-	FISHING_SUBHEADER_GC_STOP,
-	FISHING_SUBHEADER_GC_REACT,
-	FISHING_SUBHEADER_GC_SUCCESS,
-	FISHING_SUBHEADER_GC_FAIL,
-	FISHING_SUBHEADER_GC_FISH,
-};
-
-#if defined(__FISHING_GAME__)
-enum EFishingGameSubHeader
-{
-	FISHING_GAME_SUBHEADER_OPEN,
-	FISHING_GAME_SUBHEADER_GOAL,
-	FISHING_GAME_SUBHEADER_QUIT,
-};
-
-enum EFishingGameMisc
-{
-	FISHING_GAME_DURATION = 15,
-};
-
-typedef struct SPacketGCFishingGame
-{
-	SPacketGCFishingGame(const BYTE bSubHeader, const BYTE bLevel = 0) :
-		bHeader(HEADER_GC_FISHING_GAME),
-		bSubHeader(bSubHeader),
-		bLevel(bLevel)
-	{}
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bLevel;
-} TPacketGCFishingGame;
-
-typedef struct SPacketCGFishingGame
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bGoals;
-} TPacketCGFishingGame;
-#endif
-
-typedef struct command_give_item
-{
-	BYTE byHeader;
-	DWORD dwTargetVID;
-	TItemPos ItemPos;
-	WORD wItemCount;
-} TPacketCGGiveItem;
-
-typedef struct SPacketCGHack
-{
-	BYTE bHeader;
-	char szBuf[255 + 1];
-} TPacketCGHack;
-
-// SubHeader - Dungeon
-enum
-{
-	DUNGEON_SUBHEADER_GC_TIME_ATTACK_START = 0,
-	DUNGEON_SUBHEADER_GC_DESTINATION_POSITION = 1,
-};
-
-typedef struct packet_dungeon
-{
-	BYTE bHeader;
-	WORD size;
-	BYTE subheader;
-} TPacketGCDungeon;
-
-typedef struct packet_dungeon_dest_position
-{
-	long x;
-	long y;
-} TPacketGCDungeonDestPosition;
-
-typedef struct SPacketGCShopSign
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	char szSign[SHOP_SIGN_MAX_LEN + 1];
-#if defined(__MYSHOP_DECO__)
-	BYTE bType;
-#endif
-} TPacketGCShopSign;
-
-typedef struct SPacketCGMyShop
-{
-	BYTE bHeader;
-	char szSign[SHOP_SIGN_MAX_LEN + 1];
-	BYTE bCount; // Count of TShopItemTable
-} TPacketCGMyShop;
-
-#if defined(__MYSHOP_DECO__)
-typedef struct SPacketGCMyPrivShopOpen
-{
-	BYTE bHeader;
-	bool bCashItem;
-	BYTE bTabCount;
-} TPacketGCMyPrivShopOpen;
-
-typedef struct SPacketCGMyShopDecoState
-{
-	BYTE bHeader;
-	BYTE bState;
-} TPacketCGMyShopDecoState;
-
-typedef struct SPacketCGMyShopDecoAdd
-{
-	BYTE bHeader;
-	BYTE bType;
-	DWORD dwPolyVnum;
-} TPacketCGMyShopDecoAdd;
-#endif
-
-typedef struct SPacketGCTime
-{
-	BYTE bHeader;
-	time_t time;
-} TPacketGCTime;
-
-enum
-{
-	WALKMODE_RUN,
-	WALKMODE_WALK,
-};
-
-typedef struct SPacketGCWalkMode
-{
-	BYTE header;
-	DWORD vid;
-	BYTE mode;
-} TPacketGCWalkMode;
-
-typedef struct SPacketGCChangeSkillGroup
-{
-	BYTE header;
-	BYTE skill_group;
-} TPacketGCChangeSkillGroup;
-
-typedef struct SPacketCGRefine
-{
-	BYTE header;
-	BYTE pos;
-	BYTE type;
-} TPacketCGRefine;
-
-typedef struct SPacketCGRequestRefineInfo
-{
-	BYTE header;
-	BYTE pos;
-} TPacketCGRequestRefineInfo;
-
-typedef struct SPacketGCRefineInformaion
-{
-	BYTE header;
-	BYTE type;
-	BYTE pos;
-	DWORD src_vnum;
-	DWORD result_vnum;
-	WORD material_count;
-	int cost; // 소요 비용
-	int prob; // 확률
-	TRefineMaterial materials[REFINE_MATERIAL_MAX_NUM];
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-} TPacketGCRefineInformation;
-
-struct TNPCPosition
-{
-	BYTE bType;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	long x;
-	long y;
-};
-
-typedef struct SPacketGCNPCPosition
-{
-	BYTE header;
-	WORD size;
-	WORD count;
-	// array of TNPCPosition
-} TPacketGCNPCPosition;
-
-enum ESpecialEffectType
-{
-	SE_TYPE_NORMAL,
-	SE_TYPE_POSITION,
-};
-
-typedef struct SPacketGCSpecialEffect
-{
-	BYTE bHeader;
-	BYTE bEffectNum;
-	DWORD dwVID;
-	BYTE bEffectType;
-	long xEffectPos, yEffectPos;
-	SPacketGCSpecialEffect()
-		: bEffectType(SE_TYPE_NORMAL)
-		, xEffectPos(0)
-		, yEffectPos(0)
-	{}
-} TPacketGCSpecialEffect;
-
-typedef struct SPacketCGChangeName
-{
-	BYTE header;
-	BYTE index;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketCGChangeName;
-
-typedef struct SPacketGCChangeName
-{
-	BYTE header;
-	DWORD pid;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGCChangeName;
-
-typedef struct command_client_version
-{
-	BYTE header;
-	char filename[32 + 1];
-	char timestamp[32 + 1];
-} TPacketCGClientVersion;
-
-typedef struct command_client_version2
-{
-	BYTE header;
-	char filename[32 + 1];
-	char timestamp[32 + 1];
-} TPacketCGClientVersion2;
-
-typedef struct packet_channel
-{
-	BYTE header;
-	BYTE channel;
-} TPacketGCChannel;
-
-typedef struct SEquipmentItemSet
-{
-	DWORD dwVnum;
-	BYTE bCount;
-	long alSockets[ITEM_SOCKET_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-#endif
-#if defined(__SET_ITEM__)
-	BYTE bSetValue;
-#endif
-} TEquipmentItemSet;
-
-typedef struct pakcet_view_equip
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	TEquipmentItemSet Equips[WEAR_MAX_NUM];
-} TPacketGCViewEquip;
-
-typedef struct
-{
-	DWORD dwID;
-	long x, y;
-	long width, height;
-	DWORD dwGuildID;
-} TLandPacketElement;
-
-typedef struct packet_land_list
-{
-	BYTE header;
-	WORD size;
-} TPacketGCLandList;
-
-typedef struct
-{
-	BYTE bHeader;
-	long lID;
-	char szName[32 + 1];
-	DWORD dwVID;
-	BYTE bType;
-} TPacketGCTargetCreate;
-
-typedef struct
-{
-	BYTE bHeader;
-	long lID;
-	long lX, lY;
-} TPacketGCTargetUpdate;
-
-typedef struct
-{
-	BYTE bHeader;
-	long lID;
-} TPacketGCTargetDelete;
-
-typedef struct
-{
-	BYTE bHeader;
-	TPacketAffectElement elem;
-} TPacketGCAffectAdd;
-
-typedef struct
-{
-	BYTE bHeader;
-	DWORD dwType;
-	POINT_TYPE wApplyOn;
-} TPacketGCAffectRemove;
-
-typedef struct packet_lover_info
-{
-	BYTE header;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	BYTE love_point;
-} TPacketGCLoverInfo;
-
-typedef struct packet_love_point_update
-{
-	BYTE header;
-	BYTE love_point;
-} TPacketGCLovePointUpdate;
-
-// MINING
-typedef struct packet_dig_motion
-{
-	BYTE header;
-	DWORD vid;
-	DWORD target_vid;
-	BYTE count;
-} TPacketGCDigMotion;
-// END_OF_MINING
-
-// SCRIPT_SELECT_ITEM
-typedef struct command_script_select_item
-{
-	BYTE header;
-	DWORD selection;
-} TPacketCGScriptSelectItem;
-// END_OF_SCRIPT_SELECT_ITEM
-
-#if defined(__GEM_SHOP__)
-typedef struct command_select_item_ex
-{
-	BYTE bHeader;
-	DWORD dwItemPos;
-	BYTE bType;
-} TPacketCGSelectItemEx;
-#endif
-
-typedef struct packet_damage_info
-{
-	BYTE header;
-	DWORD dwVID;
-	BYTE flag;
-	int damage;
-} TPacketGCDamageInfo;
-
-typedef struct tag_GGSiege
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-	BYTE bTowerCount;
-} TPacketGGSiege;
-
-typedef struct SPacketGGMonarchTransfer
-{
-	BYTE bHeader;
-	DWORD dwTargetPID;
-	long x;
-	long y;
-} TPacketMonarchGGTransfer;
-
-typedef struct SPacketGGPCBangUpdate
-{
-	BYTE bHeader;
-	unsigned long ulPCBangID;
-} TPacketPCBangUpdate;
-
-typedef struct SPacketGGCheckAwakeness
-{
-	BYTE bHeader;
-} TPacketGGCheckAwakeness;
-
-typedef struct SPacketGCPanamaPack
-{
-	BYTE bHeader;
-	char szPackName[256];
-	BYTE abIV[32];
-} TPacketGCPanamaPack;
-
-// TODO : 아우 짱나..가변패킷 사이즈 받아들일수 있게 패킷 핸들러 Refactoring 하자. 
-typedef struct SPacketGCHybridCryptKeys
-{
-	SPacketGCHybridCryptKeys() : m_pStream(NULL) {}
-	~SPacketGCHybridCryptKeys()
-	{
-		// GCC 에선 NULL delete 해도 괜찮나? 일단 안전하게 NULL 체크 하자. ( 근데 이거 C++ 표준아니었나 --a )
-		if (m_pStream)
-		{
-			delete[] m_pStream;
-			m_pStream = NULL;
-		}
-	}
-
-	DWORD GetStreamSize()
-	{
-		return sizeof(bHeader) + sizeof(WORD) + sizeof(int) + KeyStreamLen;
-	}
-
-	BYTE* GetStreamData()
-	{
-		if (m_pStream)
-			delete[] m_pStream;
-
-		uDynamicPacketSize = (WORD)GetStreamSize();
-
-		m_pStream = new BYTE[uDynamicPacketSize];
-
-		memcpy(m_pStream, &bHeader, 1);
-		memcpy(m_pStream + 1, &uDynamicPacketSize, 2);
-		memcpy(m_pStream + 3, &KeyStreamLen, 4);
-
-		if (KeyStreamLen > 0)
-			memcpy(m_pStream + 7, pDataKeyStream, KeyStreamLen);
-
-		return m_pStream;
-	}
-
-	BYTE bHeader;
-	WORD uDynamicPacketSize; // 빌어먹을 클라 DynamicPacketHeader 구조때문에 맞춰줘야한다 -_-;
-	int KeyStreamLen;
-	BYTE* pDataKeyStream;
-
-private:
-	BYTE* m_pStream;
-
-} TPacketGCHybridCryptKeys;
-
-typedef struct SPacketGCPackageSDB
-{
-	SPacketGCPackageSDB() : m_pDataSDBStream(NULL), m_pStream(NULL) {}
-	~SPacketGCPackageSDB()
-	{
-		if (m_pStream)
-		{
-			delete[] m_pStream;
-			m_pStream = NULL;
-		}
-	}
-
-	DWORD GetStreamSize()
-	{
-		return sizeof(bHeader) + sizeof(WORD) + sizeof(int) + iStreamLen;
-	}
-
-	BYTE* GetStreamData()
-	{
-		if (m_pStream)
-			delete[] m_pStream;
-
-		uDynamicPacketSize = static_cast<WORD>(GetStreamSize());
-
-		m_pStream = new BYTE[uDynamicPacketSize];
-
-		memcpy(m_pStream, &bHeader, 1);
-		memcpy(m_pStream + 1, &uDynamicPacketSize, 2);
-		memcpy(m_pStream + 3, &iStreamLen, 4);
-
-		if (iStreamLen > 0)
-			memcpy(m_pStream + 7, m_pDataSDBStream, iStreamLen);
-
-		return m_pStream;
-	}
-
-	BYTE bHeader;
-	WORD uDynamicPacketSize; // 빌어먹을 클라 DynamicPacketHeader 구조때문에 맞춰줘야한다 -_-;
-	int iStreamLen;
-	BYTE* m_pDataSDBStream;
-
-private:
-	BYTE* m_pStream;
-
-} TPacketGCPackageSDB;
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-struct TPacketKeyAgreement
-{
-	static const int MAX_DATA_LEN = 256;
-	BYTE bHeader;
-	WORD wAgreedLength;
-	WORD wDataLength;
-	BYTE data[MAX_DATA_LEN];
-};
-
-struct TPacketKeyAgreementCompleted
-{
-	BYTE bHeader;
-	BYTE data[3]; // dummy (not used)
-};
-#endif
-
-#define MAX_EFFECT_FILE_NAME 128
-typedef struct SPacketGCSpecificEffect
-{
-	BYTE header;
-	DWORD vid;
-	char effect_file[MAX_EFFECT_FILE_NAME];
-} TPacketGCSpecificEffect;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-// 용혼석
-enum EDragonSoulRefineWindowRefineType
-{
-	DragonSoulRefineWindow_UPGRADE,
-	DragonSoulRefineWindow_IMPROVEMENT,
-	DragonSoulRefineWindow_REFINE,
-};
-
-enum EPacketCGDragonSoulSubHeaderType
-{
-	DS_SUB_HEADER_OPEN,
-	DS_SUB_HEADER_CLOSE,
-	DS_SUB_HEADER_DO_REFINE_GRADE,
-	DS_SUB_HEADER_DO_REFINE_STEP,
-	DS_SUB_HEADER_DO_REFINE_STRENGTH,
-	DS_SUB_HEADER_REFINE_FAIL,
-	DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE,
-	DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL,
-	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY,
-	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL,
-	DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL,
-	DS_SUB_HEADER_REFINE_SUCCEED,
-#if defined(__DS_CHANGE_ATTR__)
-	DS_SUB_HEADER_OPEN_CHANGE_ATTR,
-	DS_SUB_HEADER_DO_CHANGE_ATTR,
-#endif
-};
-
-typedef struct SPacketCGDragonSoulRefine
-{
-	SPacketCGDragonSoulRefine() : header(HEADER_CG_DRAGON_SOUL_REFINE)
-	{}
-	BYTE header;
-	BYTE bSubType;
-	TItemPos ItemGrid[DRAGON_SOUL_REFINE_GRID_SIZE];
-} TPacketCGDragonSoulRefine;
-
-typedef struct SPacketGCDragonSoulRefine
-{
-	SPacketGCDragonSoulRefine() : header(HEADER_GC_DRAGON_SOUL_REFINE)
-	{}
-	BYTE header;
-	BYTE bSubType;
-	TItemPos Pos;
-} TPacketGCDragonSoulRefine;
-#endif
-
-typedef struct SPacketCGStateCheck
-{
-	BYTE header;
-	unsigned long key;
-	unsigned long index;
-} TPacketCGStateCheck;
-
-typedef struct SPacketGCStateCheck
-{
-	BYTE header;
-	unsigned long key;
-	unsigned long index;
-	unsigned char state;
-} TPacketGCStateCheck;
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-enum ESubHeaderGCAcceRefine
-{
-	ACCE_REFINE_SUBHEADER_GC_CLOSE,
-	ACCE_REFINE_SUBHEADER_GC_OPEN,
-	ACCE_REFINE_SUBHEADER_GC_SET_ITEM,
-	ACCE_REFINE_SUBHEADER_GC_CLEAR_SLOT,
-	ACCE_REFINE_SUBHEADER_GC_CLEAR_ALL,
-	ACCE_REFINE_SUBHEADER_GC_CLEAR_RIGHT
-};
-
-typedef struct SSubPacketGCAcceRefineOpenClose
-{
-	BYTE bType;
-	bool bServerClose;
-} TSubPacketGCAcceRefineOpenClose;
-
-typedef struct SSubPacketGCAcceRefineSetItem
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	TItemData Item;
-} TSubPacketGCAcceRefineSetItem;
-
-typedef struct SSubPacketGCAcceRefineClearSlot
-{
-	BYTE bSlotIndex;
-} TSubPacketGCAcceRefineClearSlot;
-
-enum ESubHeaderCGAcceRefine
-{
-	ACCE_REFINE_SUBHEADER_CG_CHECKIN,
-	ACCE_REFINE_SUBHEADER_CG_CHECKOUT,
-	ACCE_REFINE_SUBHEADER_CG_ACCEPT,
-	ACCE_REFINE_SUBHEADER_CG_CANCEL
-};
-
-typedef struct SSubPacketCGAcceRefineCheckIn
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAcceRefineCheckIn;
-
-typedef struct SSubPacketCGAcceRefineCheckOut
-{
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAcceRefineCheckOut;
-
-typedef struct SSubPacketCGAcceRefineAccept
-{
-	BYTE bType;
-} TSubPacketCGAcceRefineAccept;
-
-typedef struct SPacketGCAcceRefine
-{
-	SPacketGCAcceRefine() : bHeader(HEADER_GC_ACCE_REFINE) {}
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCAcceRefine;
-
-typedef struct SPacketCGAcceRefine
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketCGAcceRefine;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-enum ESubHeaderGCAuraRefine
-{
-	AURA_REFINE_SUBHEADER_GC_CLOSE,
-	AURA_REFINE_SUBHEADER_GC_OPEN,
-	AURA_REFINE_SUBHEADER_GC_SET_ITEM,
-	AURA_REFINE_SUBHEADER_GC_CLEAR_SLOT,
-	AURA_REFINE_SUBHEADER_GC_CLEAR_ALL,
-	AURA_REFINE_SUBHEADER_GC_INFO
-};
-
-typedef struct SSubPacketGCAuraRefineOpenClose
-{
-	BYTE bType;
-	bool bServerClose;
-} TSubPacketGCAuraRefineOpenClose;
-
-typedef struct SSubPacketGCAuraRefineSetItem
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	TItemData Item;
-} TSubPacketGCAuraRefineSetItem;
-
-typedef struct SSubPacketGCAuraRefineClearSlot
-{
-	BYTE bSlotIndex;
-} TSubPacketGCAuraRefineClearSlot;
-
-typedef struct SSubPacketGCAuraRefineInfo
-{
-	BYTE bInfoType;
-	BYTE bInfoLevel;
-	BYTE bInfoExpPercent;
-} TSubPacketGCAuraRefineInfo;
-
-enum ESubHeaderCGAuraRefine
-{
-	AURA_REFINE_SUBHEADER_CG_CHECKIN,
-	AURA_REFINE_SUBHEADER_CG_CHECKOUT,
-	AURA_REFINE_SUBHEADER_CG_ACCEPT,
-	AURA_REFINE_SUBHEADER_CG_CANCEL
-};
-
-typedef struct SSubPacketCGAuraRefineCheckIn
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAuraRefineCheckIn;
-
-typedef struct SSubPacketCGAuraRefineCheckOut
-{
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAuraRefineCheckOut;
-
-typedef struct SSubPacketCGAuraRefineAccept
-{
-	BYTE bType;
-} TSubPacketCGAuraRefineAccept;
-
-typedef struct SPacketGCAuraRefine
-{
-	SPacketGCAuraRefine() : bHeader(HEADER_GC_AURA_REFINE) {}
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCAuraRefine;
-
-typedef struct SPacketCGAuraRefine
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketCGAuraRefine;
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__)
-enum EMiniGameCatchKingCGSubHeader
-{
-	CATCHKING_CG_START,
-	CATCHKING_CG_CLICK_HAND,
-	CATCHKING_CG_CLICK_CARD,
-	CATCHKING_CG_REWARD,
-#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
-	CATCHKING_CG_REQUEST_QUEST_FLAG,
-#endif
-};
-
-enum EMiniGameCatchKingGCSubHeader
-{
-	CATCHKING_GC_START,
-	CATCHKING_GC_SET_CARD,
-	CATCHKING_GC_RESULT_FIELD,
-	CATCHKING_GC_SET_END_CARD,
-	CATCHKING_GC_REWARD,
-#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
-	CATCHKING_GC_SET_CARD_PIECE_FLAG,
-	CATCHKING_GC_SET_CARD_FLAG,
-	CATCHKING_GC_SET_QUEST_FLAG,
-	CATCHKING_GC_NO_MORE_GAIN,
-#endif
-};
-
-typedef struct SCatchKingCard
-{
-	SCatchKingCard() { bIndex = 0; bIsExposed = false; }
-	SCatchKingCard(BYTE index, bool isExposed)
-	{
-		bIndex = index;
-		bIsExposed = isExposed;
-	}
-
-	BYTE bIndex;
-	bool bIsExposed;
-} TCatchKingCard;
-
-typedef struct SPacketCGMiniGameCatchKing
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSubArgument;
-} TPacketCGMiniGameCatchKing;
-
-typedef struct SPacketGCMiniGameCatchKing
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMiniGameCatchKing;
-
-typedef struct SPacketGCMiniGameCatchKingResult
-{
-	DWORD dwPoints;
-	BYTE bRowType;
-	BYTE bCardPos;
-	BYTE bCardValue;
-	bool bKeepFieldCard;
-	bool bDestroyHandCard;
-	bool bGetReward;
-	bool bIsFiveNearBy;
-} TPacketGCMiniGameCatchKingResult;
-
-typedef struct SPacketGCMiniGameCatchKingSetEndCard
-{
-	BYTE bCardPos;
-	BYTE bCardValue;
-} TPacketGCMiniGameCatchKingSetEndCard;
-
-#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
-typedef struct SPacketGCMiniGameCatchKingQuestFlag
-{
-	WORD wPieceCount, wPackCount;
-	SPacketGCMiniGameCatchKingQuestFlag(WORD wPieceCount, WORD wPackCount) :
-		wPieceCount(wPieceCount), wPackCount(wPackCount) {}
-} TPacketGCMiniGameCatchKingQuestFlag;
-#endif
-#endif
-
-#if defined(__SKILLBOOK_COMB_SYSTEM__)
-typedef struct SPacketCGSkillBookCombination
-{
-	BYTE bHeader;
-	BYTE bAction;
-	TItemPos CombItemGrid[SKILLBOOK_COMB_SLOT_MAX];
-} TPacketCGSkillBookCombination;
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-enum class EPacketCGChangeLookSubHeader : BYTE
-{
-	ITEM_CHECK_IN,
-	ITEM_CHECK_OUT,
-	FREE_ITEM_CHECK_IN,
-	FREE_ITEM_CHECK_OUT,
-	ACCEPT,
-	CANCEL
-};
-
-typedef struct packet_set_changelook
-{
-	BYTE bHeader;
-	WORD wCell;
-	BYTE bSlotIndex;
-} TPacketGCChangeLookSet;
-
-typedef struct packet_changelook_del
-{
-	BYTE bHeader;
-	WORD wCell;
-	BYTE bSlotIndex;
-} TPacketGCChangeLookDel;
-
-typedef struct command_changelook
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSlotIndex;
-	TItemPos ItemPos;
-} TPacketCGChangeLook;
-#endif
-
-#if defined(__MAILBOX__)
-typedef struct packet_mailbox_process
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bArg1;
-	BYTE bArg2;
-} TPacketMailboxProcess;
-
-typedef struct packet_mailbox_process_all
-{
-	BYTE Index;
-} TPacketGCMailboxProcessAll;
-
-typedef struct packet_mailbox
-{
-	BYTE bHeader;
-	WORD wSize;
-} TPacketGCMailBox;
-
-typedef struct packet_mailbox_write
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	char szTitle[25 + 1];
-	char szMessage[100 + 1];
-	TItemPos pos;
-	int iYang;
-	int iWon;
-} TPacketCGMailboxWrite;
-
-typedef struct packet_mailbox_write_confirm
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketCGMailboxWriteConfirm;
-#endif
-
-#if defined(__RANKING_SYSTEM__)
-typedef struct SPacketGCRanking
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bType;
-	BYTE bCategory;
-} TPacketGCRanking;
-#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-typedef struct packet_cg_item_combination
-{
-	BYTE Header;
-	short MediumIndex;
-	short BaseIndex;
-	short MaterialIndex;
-} TPacketCGItemCombination;
-
-typedef struct packet_cg_item_combination_cancel
-{
-	BYTE Header;
-} TPacketCGItemCombinationCancel;
-#endif
-
-#if defined(__CHANGED_ATTR__)
-typedef struct packet_gc_item_select_attr
-{
-	BYTE bHeader;
-	TItemPos pItemPos;
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
-} TPacketGCItemSelectAttr;
-
-typedef struct packet_cg_item_select_attr
-{
-	BYTE bHeader;
-	bool bNew;
-	TItemPos pItemPos;
-} TPacketCGItemSelectAttr;
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-typedef struct SPacketCGLootFilter
-{
-	BYTE header;
-	BYTE settings[ELootFilter::LOOT_FILTER_SETTINGS_MAX];
-} TPacketCGLootFilter;
-
-typedef struct SPacketGCLootFilter
-{
-	BYTE header;
-	bool enable;
-	DWORD vid;
-} TPacketGCLootFilter;
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-enum EMiniGameRumiCGSubHeader
-{
-	RUMI_CG_SUBHEADER_END,
-	RUMI_CG_SUBHEADER_START,
-	RUMI_CG_SUBHEADER_DECK_CARD_CLICK,
-	RUMI_CG_SUBHEADER_HAND_CARD_CLICK,
-	RUMI_CG_SUBHEADER_FIELD_CARD_CLICK,
-#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
-	RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
-#endif
-};
-
-enum EMiniGameRumiGCSubHeader
-{
-	RUMI_GC_SUBHEADER_END,
-	RUMI_GC_SUBHEADER_START,
-	RUMI_GC_SUBHEADER_SET_DECK,
-	RUMI_GC_SUBHEADER_SET_SCORE,
-	RUMI_GC_SUBHEADER_MOVE_CARD,
-#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
-	RUMI_GC_SUBHEADER_SET_CARD_PIECE_FLAG,
-	RUMI_GC_SUBHEADER_SET_CARD_FLAG,
-	RUMI_GC_SUBHEADER_SET_QUEST_FLAG,
-	RUMI_GC_SUBHEADER_NO_MORE_GAIN,
-#endif
-};
-
-typedef struct SPacketCGMiniGameRumi
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BOOL bUseCard;
-	BYTE bIndex;
-} TPacketCGMiniGameRumi;
-
-typedef struct SPacketGCMiniGameRumiSetDeck
-{
-	BYTE bDeckCount;
-	SPacketGCMiniGameRumiSetDeck(BYTE bDeckCount) : bDeckCount(bDeckCount) {}
-} TPacketGCMiniGameRumiSetDeck;
-
-typedef struct SPacketGCMiniGameRumiMoveCard
-{
-	BYTE bSrcPos, bSrcIndex, bSrcColor, bSrcNumber;
-	BYTE bDstPos, bDstIndex, bDstColor, bDstNumber;
-	SPacketGCMiniGameRumiMoveCard() :
-		bSrcPos(0), bSrcIndex(0), bSrcColor(0), bSrcNumber(0),
-		bDstPos(0), bDstIndex(0), bDstColor(0), bDstNumber(0) {}
-} TPacketGCMiniGameRumiMoveCard;
-
-typedef struct SPacketGCMiniGameRumiSetScore
-{
-	WORD wScore, wTotalScore;
-	SPacketGCMiniGameRumiSetScore(WORD wScore, WORD wTotalScore) :
-		wScore(wScore), wTotalScore(wTotalScore) {}
-} TPacketGCMiniGameRumiSetScore;
-
-#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
-typedef struct SPacketGCMiniGameRumiQuestFlag
-{
-	WORD wCardPieceCount, wCardCount;
-	SPacketGCMiniGameRumiQuestFlag(WORD wCardPieceCount, WORD wCardCount) :
-		wCardPieceCount(wCardPieceCount), wCardCount(wCardCount) {}
-} TPacketGCMiniGameRumiQuestFlag;
-#endif
-
-typedef struct SPacketGCMiniGameRumi
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMiniGameRumi;
-#endif
-
-#if defined(__LUCKY_BOX__)
-enum ELUCKY_BOX_ACTION
-{
-	LUCKY_BOX_ACTION_RETRY,
-	LUCKY_BOX_ACTION_RECEIVE,
-};
-
-typedef struct SPacketCGLuckyBox
-{
-	BYTE bHeader;
-	BYTE bAction;
-} TPacketCGLuckyBox;
-
-typedef struct SPacketGCLuckyBox
-{
-	BYTE bHeader;
-	DWORD dwVNum;
-	BYTE bCount;
-	int iNeedMoney;
-	WORD wSlotIndex;
-} TPacketGCLuckyBox;
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-enum EAttr67AddSubHeader
-{
-	SUBHEADER_CG_ATTR67_ADD_CLOSE,
-	SUBHEADER_CG_ATTR67_ADD_OPEN,
-	SUBHEADER_CG_ATTR67_ADD_REGIST,
-};
-
-typedef struct SPacketCGAttr67Add
-{
-	BYTE byHeader;
-	BYTE bySubHeader;
-	TAttr67AddData Attr67AddData;
-} TPacketCGAttr67Add;
-#endif
-
-#if defined(__GEM_SHOP__)
-enum EGemShopSubHeader : BYTE
-{
-	SUBHEADER_GEM_SHOP_CLOSE,
-	SUBHEADER_GEM_SHOP_OPEN,
-	SUBHEADER_GEM_SHOP_BUY,
-	SUBHEADER_GEM_SHOP_SLOT_ADD,
-	SUBHEADER_GEM_SHOP_REFRESH,
-	SUBHEADER_GEM_SHOP_MAX,
-};
-
-typedef struct SPacketGCGemShop
-{
-	BYTE bHeader;
-	WORD wSize;
-} TPacketGCGemShop;
-
-typedef struct SPacketGCGemShopProcess
-{
-	SPacketGCGemShopProcess(const BYTE c_bSubHeader) :
-		bHeader(HEADER_GC_GEM_SHOP_PROCESS),
-		bSubHeader(c_bSubHeader),
-		bSlotIndex(GEM_SHOP_SLOT_COUNT),
-		bEnable(false)
-	{}
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSlotIndex;
-	bool bEnable;
-} TPacketGCGemShopProcess;
-
-typedef struct command_gem_shop
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSlotIndex;
-} TPacketCGGemShop;
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-typedef struct SPacketCGExtendInven
-{
-	BYTE bHeader;
-	bool bUpgrade;
-	BYTE bIndex;
-} TPacketCGExtendInven;
-
-typedef struct SPacketGCExtendInven
-{
-	BYTE bHeader;
-	BYTE bStage;
-	WORD wMaxNum;
-} TPacketGCExtendInven;
-
-typedef struct SPacketGCExtendInvenItemUse
-{
-	BYTE bHeader;
-	BYTE bMsgResult;
-	BYTE bEnoughCount;
-} TPacketGCExtendInvenItemUse;
-#endif
-
-#if defined(__CLIENT_TIMER__)
-enum EClientTimerSubHeader
-{
-	CLIENT_TIMER_SUBHEADER_GC_SET,
-	CLIENT_TIMER_SUBHEADER_GC_DELETE
-};
-
-enum EClientTimer
-{
-	ECLIENT_TIMER_END_TIME,
-	ECLIENT_TIMER_ALARM_SECOND,
-	ECLIENT_TIMER_MAX
-};
-
-typedef struct SPacketGCClientTimer
-{
-	SPacketGCClientTimer(const BYTE _bSubHeader)
-		: bHeader(HEADER_GC_CLIENT_TIMER), bSubHeader(_bSubHeader)
-	{
-		memset(&dwData, 0, sizeof(dwData));
-	};
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwData[ECLIENT_TIMER_MAX];
-} TPacketGCClientTimer;
-#endif
-
-enum EEmoteSubHeader
-{
-	SUBHEADER_EMOTE_ADD,
-	SUBHEADER_EMOTE_CLEAR,
-	SUBHEADER_EMOTE_MOTION,
-	SUBHEADER_EMOTE_ICON,
-};
-
-typedef struct SPacketGCEmote
-{
-	SPacketGCEmote() : bHeader(HEADER_GC_EMOTE) {}
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwEmoteVnum;
-	DWORD dwDuration;
-	DWORD dwMainVID, dwTargetVID;
-} TPacketGCEmote;
-
-#if defined(__CUBE_RENEWAL__)
-enum ECubeSubHeader
-{
-	SUBHEADER_GC_CUBE_OPEN = 0,
-	SUBHEADER_GC_CUBE_CLOSE,
-	SUBHEADER_GC_CUBE_RESULT,
-
-	SUBHEADER_CG_CUBE_CLOSE = 0,
-	SUBHEADER_CG_CUBE_MAKE,
-};
-
-typedef struct SPacketGCCube
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwNPCVnum;
-	BOOL bSuccess;
-	DWORD dwFileCrc;
-} TPacketGCCube;
-
-typedef struct SPacketCGCube
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	UINT iCubeIndex;
-	UINT iQuantity;
-	INT iImproveItemPos;
-	DWORD dwFileCrc;
-} TPacketCGCube;
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-enum ESubPacketGCSnowflakeStickEvent
-{
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_SNOW_BALL,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_TREE_BRANCH,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_SNOW_BALL_MAX,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_TREE_BRANCH_MAX,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_STICK_SUCCESS,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_PET_SUCCESS,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_MOUNT_SUCCESS,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_USE_STICK_FAILED,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_RANK_BUFF,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_SNOWFLAKE_BUFF,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ENABLE,
-};
-
-enum ESnowflakeStickEventQuestFlagType
-{
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_SNOW_BALL,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_TREE_BRANCH,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK_COOLDOWN,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_PET,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_MOUNT,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_USE_STICK_COOLDOWN,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM,
-};
-
-typedef struct SPacketGCSnowflakeStickEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM];
-	SPacketGCSnowflakeStickEvent(const BYTE c_bSubHeader)
-		: bHeader(HEADER_GC_SNOWFLAKE_STICK_EVENT), bSubHeader(c_bSubHeader)
-	{;
-		memset(&dwValue, 0, sizeof(dwValue));
-	}
-} TPacketGCSnowflakeStickEvent;
-
-enum ESubPacketCGSnowflakeStickEvent
-{
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_REQUEST_INFO,
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_STICK,
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_PET,
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_MOUNT
-};
-
-typedef struct SPacketCGSnowflakeStickEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-} TPacketCGSnowflakeStickEvent;
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-enum EPacketGCRefineElement
-{
-	REFINE_ELEMENT_GC_OPEN,
-	REFINE_ELEMENT_GC_RESULT
-};
-
-enum EPacketCGRefineElement
-{
-	REFINE_ELEMENT_CG_CLOSE,
-	REFINE_ELEMENT_CG_REFINE,
-};
-
-typedef struct SPacketGCRefineElement
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bRefineType;
-	BYTE bResult;
-	TItemPos SrcPos;
-	TItemPos DestPos;
-} TPacketGCRefineElement;
-
-typedef struct SPacketCGRefineElement
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	WORD wChangeElement;
-} TPacketCGRefineElement;
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__)
-enum EMiniGameYutnoriGCSubHeader
-{
-	YUTNORI_GC_SUBHEADER_START,
-	YUTNORI_GC_SUBHEADER_STOP,
-	YUTNORI_GC_SUBHEADER_SET_PROB,
-	YUTNORI_GC_SUBHEADER_THROW,
-	YUTNORI_GC_SUBHEADER_MOVE,
-	YUTNORI_GC_SUBHEADER_AVAILABLE_AREA,
-	YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT,
-	YUTNORI_GC_SUBHEADER_SET_SCORE,
-	YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT,
-	YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN,
-#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-	YUTNORI_GC_SUBHEADER_SET_YUT_PIECE_FLAG,
-	YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG,
-	YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG,
-	YUTNORI_GC_SUBHEADER_NO_MORE_GAIN,
-#endif
-};
-
-enum EMiniGameYutnoriCGSubHeader
-{
-	YUTNORI_CG_SUBHEADER_START,
-	YUTNORI_CG_SUBHEADER_GIVEUP,
-	YUTNORI_CG_SUBHEADER_SET_PROB,
-	YUTNORI_CG_SUBHEADER_CLICK_CHAR,
-	YUTNORI_CG_SUBHEADER_THROW,
-	YUTNORI_CG_SUBHEADER_MOVE,
-	YUTNORI_CG_SUBHEADER_REQUEST_COM_ACTION,
-	YUTNORI_CG_SUBHEADER_REWARD,
-#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-	YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
-#endif
-};
-
-typedef struct SPacketCGMiniGameYutnori
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bArgument;
-} TPacketCGMiniGameYutnori;
-
-typedef struct SPacketGCMiniGameYutnori
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMiniGameYutnori;
-
-typedef struct SPacketGCMiniGameYutnoriSetProb
-{
-	BYTE bProbIndex;
-	SPacketGCMiniGameYutnoriSetProb(BYTE bProbIndex)
-		: bProbIndex(bProbIndex) {}
-} TPacketGCMiniGameYutnoriSetProb;
-
-typedef struct SPacketGCMiniGameYutnoriThrow
-{
-	bool bPC;
-	BYTE bYut;
-	SPacketGCMiniGameYutnoriThrow(bool bPC, BYTE bYut)
-		: bPC(bPC), bYut(bYut) {}
-} TPacketGCMiniGameYutnoriThrow;
-
-typedef struct SPacketGCMiniGameYutnoriMove
-{
-	bool bPC;
-	BYTE bUnitIndex;
-	bool bIsCatch;
-	BYTE bStartIndex;
-	BYTE bDestIndex;
-	SPacketGCMiniGameYutnoriMove(bool bPC, BYTE bUnitIndex, bool bIsCatch, BYTE bStartIndex, BYTE bDestIndex)
-		: bPC(bPC), bUnitIndex(bUnitIndex), bIsCatch(bIsCatch), bStartIndex(bStartIndex), bDestIndex(bDestIndex) {}
-} TPacketGCMiniGameYutnoriMove;
-
-typedef struct SPacketGCMiniGameYutnoriAvailableArea
-{
-	BYTE bPlayerIndex;
-	BYTE bAvailableIndex;
-	SPacketGCMiniGameYutnoriAvailableArea(BYTE bPlayerIndex, BYTE bAvailableIndex)
-		: bPlayerIndex(bPlayerIndex), bAvailableIndex(bAvailableIndex) {}
-} TPacketGCMiniGameYutnoriAvailableArea;
-
-typedef struct SPacketGCMiniGameYutnoriPushCatchYut
-{
-	bool bPC;
-	BYTE bUnitIndex;
-	SPacketGCMiniGameYutnoriPushCatchYut(bool bPC, BYTE bUnitIndex)
-		: bPC(bPC), bUnitIndex(bUnitIndex) {}
-} TPacketGCMiniGameYutnoriPushCatchYut;
-
-typedef struct SPacketGCMiniGameYutnoriSetScore
-{
-	WORD wScore;
-	SPacketGCMiniGameYutnoriSetScore(WORD wScore)
-		: wScore(wScore) {}
-} TPacketGCMiniGameYutnoriSetScore;
-
-typedef struct SPacketGCMiniGameYutnoriSetRemainCount
-{
-	BYTE bRemainCount;
-	SPacketGCMiniGameYutnoriSetRemainCount(BYTE bRemainCount)
-		: bRemainCount(bRemainCount) {}
-} TPacketGCMiniGameYutnoriSetRemainCount;
-
-typedef struct SPacketGCMiniGameYutnoriPushNextTurn
-{
-	bool bPC;
-	BYTE bState;
-	SPacketGCMiniGameYutnoriPushNextTurn(bool bPC, BYTE bState)
-		: bPC(bPC), bState(bState) {}
-} TPacketGCMiniGameYutnoriPushNextTurn;
-
-#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-typedef struct SPacketGCMiniGameYutnoriQuestFlag
-{
-	WORD wYutPieceCount;
-	WORD wYutBoardCount;
-	SPacketGCMiniGameYutnoriQuestFlag(WORD wYutPieceCount, WORD wYutBoardCount)
-		: wYutPieceCount(wYutPieceCount), wYutBoardCount(wYutBoardCount) {}
-} TPacketGCMiniGameYutnoriQuestFlag;
-#endif
-#endif
-
-#if defined(__QUEST_REQUEST_EVENT__)
-typedef struct SPacketCGRequestEventQuest
-{
-	BYTE bHeader;
-	char szEventQuest[64 + 1];
-} TPacketCGRequestEventQuest;
-#endif
-
-#if defined(__LEFT_SEAT__)
-enum ELeftSeatCGSubHeader
-{
-	LEFT_SEAT_SET_WAIT_TIME_INDEX,
-	LEFT_SEAT_SET_LOGOUT_TIME_INDEX,
-	LEFT_SEAT_DISABLE_LOGOUT_STATE,
-};
-
-typedef struct SPacketCGLeftSeat
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bIndex;
-} TPacketCGLeftSeat;
-#endif
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-enum EGuildDragonLairType
-{
-	GUILD_DRAGONLAIR_TYPE_RED,
-	GUILD_DRAGONLAIR_TYPE_BLUE,
-	GUILD_DRAGONLAIR_TYPE_GREEN,
-	GUILD_DRAGONLAIR_TYPE_MAX_NUM
-};
-
-enum EGuildDragonLairSubHeader
-{
-	GUILD_DRAGONLAIR_GC_SUBHEADER_RANKING,
-#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
-	GUILD_DRAGONLAIR_GC_SUBHEADER_1ST_GUILD_TEXT,
-	GUILD_DRAGONLAIR_GC_SUBHEADER_START,
-	GUILD_DRAGONLAIR_GC_SUBHEADER_SUCCESS,
-#endif
-};
-
-typedef struct SPacketGCGuildDragonLair
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-	BYTE bType;
-#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
-	DWORD dwFirstRankingTime;
-#endif
-} TPacketGCGuildDragonLair;
-
-typedef struct SPacketGCGuildDragonLairRanking
-{
-	BYTE bType;
-	DWORD dwGuildID;
-	char szGuildName[GUILD_NAME_MAX_LEN + 1];
-	BYTE bMemberCount;
-	DWORD dwTime;
-} TPacketGCGuildDragonLairRanking;
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-enum EPacketGCMiniGameRouletteSubHeader
-{
-	ROULETTE_GC_OPEN,
-	ROULETTE_GC_START,
-	ROULETTE_GC_REQUEST,
-	ROULETTE_GC_END,
-	ROULETTE_GC_CLOSE
-};
-
-enum EPacketCGMiniGameRouletteSubHeader
-{
-	ROULETTE_CG_START,
-	ROULETTE_CG_REQUEST,
-	ROULETTE_CG_END,
-	ROULETTE_CG_CLOSE
-};
-
-typedef struct SPacketGCMiniGameRoulette
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bResult;
-	DWORD dwExpireTime;
-	struct
-	{
-		DWORD dwVnum;
-		BYTE bCount;
-	} ItemData[ROULETTE_ITEM_MAX];
-} TPacketGCMiniGameRoulette;
-
-typedef struct SPacketCGMiniGameRoulette
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-} TPacketCGMiniGameRoulette;
-#endif
-
-#if defined(__FLOWER_EVENT__)
-enum EPacketGCFlowerEvent
-{
-	FLOWER_EVENT_SUBHEADER_GC_INFO_ALL,
-	FLOWER_EVENT_SUBHEADER_GC_GET_INFO,
-	FLOWER_EVENT_SUBHEADER_GC_UPDATE_INFO,
-};
-
-typedef struct SPacketGCFlowerEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bChatType;
-	BYTE bShootType;
-	int aiShootCount[SHOOT_TYPE_MAX + 1];
-	SPacketGCFlowerEvent()
-		: bHeader(HEADER_GC_FLOWER_EVENT)
-		, bSubHeader(FLOWER_EVENT_SUBHEADER_GC_INFO_ALL)
-		, bChatType(FLOWER_EVENT_CHAT_TYPE_MAX)
-		, bShootType(SHOOT_TYPE_MAX)
-	{
-		memset(&aiShootCount, 0, sizeof(aiShootCount));
-	}
-} TPacketGCFlowerEvent;
-
-enum EPacketCGFlowerEvent
-{
-	FLOWER_EVENT_SUBHEADER_CG_INFO_ALL,
-	FLOWER_EVENT_SUBHEADER_CG_EXCHANGE
-};
-
-typedef struct SPacketCGFlowerEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bShootType;
-	BYTE bExchangeKey;
-}TPacketCGFlowerEvent;
-#endif
-
-#if defined(__OFFLINE_SHOP__)
-typedef struct SPacketGGUpdateSellHistory {
-	BYTE		bHeader;
-	DWORD		pid;
-	TMySellHistory	sellItem;
-} TPacketGGUpdateSellHistory;
-#endif
-
-#ifdef __SHOP_SEARCH__
-typedef struct SPacketCGShopSearchByName {
-	BYTE	header;
-	char	itemName[ITEM_NAME_MAX_LEN + 1];
-	WORD	page;
-	BYTE	entryCountIdx;
-	BYTE	sortType;
-} TPacketCGShopSearchByName;
-
-typedef struct SPacketCGShopSearchByOptions {
-	BYTE	header;
-	TShopSearchOptions	options;
-	WORD	page;
-	BYTE	entryCountIdx;
-	BYTE	sortType;
-} TPacketCGShopSearchByOptions;
-
-typedef struct SPacketGCShopSearchResult {
-	BYTE	header;
-	WORD	size;
-	WORD	itemCount;
-	WORD	maxPageNum;
-} TPacketGCShopSearchResult;
-typedef struct SPacketCGShopSearchBuy {
-	BYTE	header;
-	TOfflineItemID	itemID;
-	DWORD	itemVnum;
-	int64_t	itemPrice;
-
-} TPacketCGShopSearchBuy;
-
-typedef struct SPacketGCShopSearchBuyResult {
-	BYTE	header;
-	BYTE	result;
-} TPacketGCShopSearchBuyResult;
-
-typedef struct SPacketCGShopSearchOwnerMessage {
-	BYTE	header;
-	DWORD	ownerID;
-} TPacketCGShopSearchOwnerMessage;
-
-typedef struct SPacketGCShopSearchOwnerMessage {
-	BYTE	header;
-	char	ownerName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGCShopSearchOwnerMessage;
-
-typedef struct SPacketCGShopSearchRequestSoldInfo {
-	BYTE	header;
-	DWORD	itemVnum;
-} TPacketCGShopSearchRequestSoldInfo;
-
-typedef struct SPacketGCShopSearchSoldInfo {
-	BYTE	header;
-	WORD	size;
-	bool	results;
-} TPacketGCShopSearchSoldInfo;
-
-using TPacketGCEntity = struct SPacketGCEntity
-{
-	BYTE bHeader;
-	WORD wSize;
-};
-using TPacketEntityInfo = struct SPacketEntityInfo
-{
-	DWORD dwVID;
-	DWORD dwRaceVNum;
-	WORD wPart[CHR_EQUIPPART_NUM];
-	LONG xPos, yPos;
-};
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-typedef struct SPacketCGExtBattlePassAction
-{
-	BYTE bHeader;
-	BYTE bAction;
-} TPacketCGExtBattlePassAction;
-
-typedef struct SPacketCGExtBattlePassSendPremiumItem
-{
-	BYTE bHeader;
-	int iSlotIndex;
-} TPacketCGExtBattlePassSendPremiumItem;
-
-typedef struct SPacketGCExtBattlePassOpen
-{
-	BYTE bHeader;
-} TPacketGCExtBattlePassOpen;
-
-typedef struct SPacketGCExtBattlePassGeneralInfo
-{
-	BYTE bHeader;
-	BYTE bBattlePassType;
-	char	szSeasonName[64+1];
-	DWORD dwBattlePassID;
-	DWORD dwBattlePassStartTime;
-	DWORD dwBattlePassEndTime;
-} TPacketGCExtBattlePassGeneralInfo;
-
-typedef struct SPacketGCExtBattlePassMissionInfo
-{
-	BYTE bHeader;
-	WORD wSize;
-	WORD wRewardSize;
-	BYTE bBattlePassType;
-	DWORD dwBattlePassID;
-} TPacketGCExtBattlePassMissionInfo;
-
-typedef struct SPacketGCExtBattlePassMissionUpdate
-{
-	BYTE bHeader;
-	BYTE bBattlePassType;
-	BYTE bMissionIndex;
-	BYTE bMissionType;
-	DWORD dwNewProgress;
-} TPacketGCExtBattlePassMissionUpdate;
-
-typedef struct SPacketGCExtBattlePassRanking
-{
-	BYTE bHeader;
-	char	szPlayerName[CHARACTER_NAME_MAX_LEN + 1];
-	BYTE bBattlePassType;
-	BYTE	bBattlePassID;
-	DWORD	dwStartTime;
-	DWORD	dwEndTime;
-} TPacketGCExtBattlePassRanking;
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-enum EGrowthPetPoints
-{
-	POINT_UPBRINGING_PET_LEVEL,
-	POINT_UPBRINGING_PET_EXP,
-	POINT_UPBRINGING_PET_ITEM_EXP,
-	POINT_UPBRINGING_PET_NEXT_EXP,
-	POINT_UPBRINGING_PET_EVOL_LEVEL,
-	POINT_UPBRINGING_PET_HP,
-	POINT_UPBRINGING_PET_DEF_GRADE,
-	POINT_UPBRINGING_PET_SP,
-	POINT_UPBRINGING_DURATION,
-	POINT_UPBRINGING_MAX_DURATION,
-	POINT_UPBRINGING_BIRTHDAY,
-	
-	POINT_UPBRINGING_MAX_NUM
-};
-
-enum EGrowthPetSubheader
-{
-	SUBHEADER_PET_EGG_USE_SUCCESS,
-	SUBHEADER_PET_EGG_USE_FAILED_BECAUSE_NAME,
-	SUBHEADER_PET_EGG_USE_FAILED_TIMEOVER,
-	SUBHEADER_PET_UNSUMMON,
-	SUBHEADER_PET_FEED_FAILED,
-	SUBHEADER_PET_FEED_SUCCESS,
-	SUBHEADER_PET_REVIVE_FAILED,
-	SUBHEADER_PET_REVIVE_SUCCESS,
-	SUBHEADER_PET_NAME_CHANGE_FAILED,
-	SUBHEADER_PET_NAME_CHANGE_SUCCESS,
-	SUBHEADER_PET_WINDOW_TYPE_INFO,
-	SUBHEADER_PET_WINDOW_TYPE_ATTR_CHANGE,
-	SUBHEADER_PET_WINDOW_TYPE_PREMIUM_FEED,
-};
-
-enum EGrowthPetWindow
-{
-	PET_WINDOW_HATCH,
-	PET_WINDOW_NAME_CHANGE,
-};
-
-typedef struct SPacketGCPet
-{
-	BYTE	header;
-	BYTE	subheader;
-} TPacketGCPet;
-
-typedef struct SPacketGCPetSet
-{
-	BYTE		header;
-	DWORD		dwID;
-	DWORD		dwSummonItemVnum;
-	char		szName[PET_NAME_MAX_SIZE + 1];
-	TPetSkill	aSkill[PET_SKILL_COUNT_MAX];
-	DWORD		dwPoints[POINT_UPBRINGING_MAX_NUM];
-} TPacketGCPetSet;
-
-typedef struct SPacketGCPetDelete
-{
-	BYTE		header;
-	DWORD		dwID;
-} TPacketGCPetDelete;
-
-typedef struct SPacketGCPetPointUpdate
-{
-	BYTE	header;
-	DWORD	dwID;
-	BYTE	bPoint;
-	DWORD	dwValue;
-} TPacketGCPetPointUpdate;
-
-typedef struct SPacketGCPetSummon
-{
-	BYTE		header;
-	DWORD		dwID;
-} TPacketGCPetSummon;
-
-typedef struct SPacketGCPetDetermineResult
-{
-	BYTE		header;
-	BYTE		type;
-} TPacketGCPetDetermineResult;
-
-typedef struct SPacketGCPetAttrChangeResult
-{
-	BYTE		header;
-	BYTE		type;
-	TItemPos	pos;
-} TPacketGCPetAttrChangeResult;
-
-typedef struct SPetSkillUpdatePacket
-{
-	bool	bLocked;
-	BYTE	bSkill;
-	BYTE	bLevel;
-	DWORD	dwCooltime;
-	BYTE	bSkillFormula1[PET_GROWTH_SKILL_LEVEL_MAX];
-	WORD	wSkillFormula2[PET_GROWTH_SKILL_LEVEL_MAX];
-	BYTE	bSkillFormula3[PET_GROWTH_SKILL_LEVEL_MAX];
-} TPetSkillUpdatePacket;
-
-typedef struct SPacketGCPetSkillCooltime
-{
-	BYTE		header;
-	DWORD		dwID;
-	BYTE		bSlot;
-	DWORD		dwCooltime;
-} TPacketGCPetSkillCooltime;
-
-typedef struct SPacketGCPetSkillUpdate
-{
-	BYTE		header;
-	DWORD		dwID;
-	TPetSkillUpdatePacket	aSkill[PET_SKILL_COUNT_MAX];
-} TPacketGCPetSkillUpdate;
-
-typedef struct SPacketGCPetNameChangeResult
-{
-	BYTE		header;
-	BYTE		subheader;
-	DWORD		dwID;
-	char		szName[PET_NAME_MAX_SIZE + 1];
-} TPacketGCPetNameChangeResult;
-
-typedef struct SPacketCGPetHatch
-{
-	BYTE		header;
-	char		name[PET_NAME_MAX_SIZE + 1];
-	TItemPos	eggPos;
-} TPacketCGPetHatch;
-
-typedef struct SPacketCGPetWindow
-{
-	BYTE	header;
-	BYTE	window;
-	bool	state;
-} TPacketCGPetWindow;
-
-typedef struct SPacketCGPetWindowType
-{
-	BYTE	header;
-	BYTE	type;
-} TPacketCGPetWindowType;
-
-typedef struct SPacketCGPeFeed
-{
-	BYTE		header;
-	BYTE		index;
-	WORD		pos[PET_FEED_SLOT_MAX];
-	WORD		count[PET_FEED_SLOT_MAX];
-} TPacketCGPetFeed;
-
-typedef struct SPacketCGPetDetermine
-{
-	BYTE		header;
-	TItemPos	determinePos;
-} TPacketCGPetDetermine;
-
-typedef struct SPacketCGPetAttrChange
-{
-	BYTE		header;
-	TItemPos	upBringingPos;
-	TItemPos	attrChangePos;
-} TPacketCGPetAttrChange;
-
-typedef struct SPacketCGPetRevive
-{
-	BYTE		header;
-	TItemPos	upBringingPos;
-	WORD		pos[PET_REVIVE_MATERIAL_SLOT_MAX];
-	WORD		count[PET_REVIVE_MATERIAL_SLOT_MAX];
-} TPacketCGPetRevive;
-
-typedef struct SPacketCGPetLearnSkill
-{
-	BYTE		header;
-	BYTE		slotIndex;
-	TItemPos	learnSkillPos;
-} TPacketCGPetLearnSkill;
-
-typedef struct SPacketCGPetUpgradeSkill
-{
-	BYTE		header;
-	BYTE		slotIndex;
-} TPacketCGPetSkillUpgrade;
-
-typedef struct SPacketCGPetDeleteSkill
-{
-	BYTE		header;
-	BYTE		slotIndex;
-	TItemPos	deleteSkillPos;
-} TPacketCGPetDeleteSkill;
-
-typedef struct SPacketCGPetAllDeleteSkill
-{
-	BYTE		header;
-	TItemPos	deleteAllSkillPos;
-} TPacketCGPetDeleteAllSkill;
-
-typedef struct SPacketCGPetNameChange
-{
-	BYTE		header;
-	char		name[PET_NAME_MAX_SIZE + 1];
-	TItemPos	changeNamePos;
-	TItemPos	upBringingPos;
-} TPacketCGPetNameChange;
-#endif
-
-#pragma pack()
-#endif // __INC_PACKET_H__
+#ifndef __INC_PACKET_H__
+#define __INC_PACKET_H__
+
+enum CG_HEADERS
+{
+	HEADER_CG_LOGIN = 1,
+	HEADER_CG_ATTACK = 2,
+	HEADER_CG_CHAT = 3,
+	HEADER_CG_CHARACTER_CREATE = 4,
+	HEADER_CG_CHARACTER_DELETE = 5,
+	HEADER_CG_CHARACTER_SELECT = 6,
+	HEADER_CG_MOVE = 7,
+	HEADER_CG_SYNC_POSITION = 8,
+	//HEADER_CG_DIRECT_ENTER = 9,
+	HEADER_CG_ENTERGAME = 10,
+
+	HEADER_CG_ITEM_USE = 11,
+	HEADER_CG_ITEM_DROP = 12,
+	HEADER_CG_ITEM_MOVE = 13,
+	//HEADER_CG_UNUSED = 14,
+	HEADER_CG_ITEM_PICKUP = 15,
+
+	HEADER_CG_QUICKSLOT_ADD = 16,
+	HEADER_CG_QUICKSLOT_DEL = 17,
+	HEADER_CG_QUICKSLOT_SWAP = 18,
+	HEADER_CG_WHISPER = 19,
+	HEADER_CG_ITEM_DROP2 = 20,
+#if defined(__NEW_DROP_DIALOG__)
+	HEADER_CG_ITEM_DESTROY = 21,
+#endif
+
+	//HEADER_CG_UNUSED = 22,
+	//HEADER_CG_UNUSED = 23,
+	//HEADER_CG_UNUSED = 24,
+	//HEADER_CG_UNUSED = 25,
+
+	HEADER_CG_ON_CLICK = 26,
+	HEADER_CG_EXCHANGE = 27,
+	HEADER_CG_CHARACTER_POSITION = 28,
+	HEADER_CG_SCRIPT_ANSWER = 29,
+	HEADER_CG_QUEST_INPUT_STRING = 30,
+	HEADER_CG_QUEST_CONFIRM = 31,
+#if defined(__OX_RENEWAL__)
+	HEADER_CG_QUEST_INPUT_LONG_STRING = 32,
+#endif
+#if defined(__OFFLINE_SHOP__)
+	HEADER_CG_OFFLINE_SHOP = 33,
+#endif
+	//HEADER_CG_UNUSED = 34,
+
+#ifdef __GROWTH_PET_SYSTEM__
+	HEADER_CG_PET_HATCH = 118,
+	HEADER_CG_PET_WINDOW_TYPE = 119,
+	HEADER_CG_PET_WINDOW = 120,
+	HEADER_CG_PET_NAME_CHANGE = 121,
+	HEADER_CG_PET_FEED = 122,
+	HEADER_CG_PET_DETERMINE = 123,
+	HEADER_CG_PET_ATTR_CHANGE = 124,
+	HEADER_CG_PET_REVIVE = 125,
+	HEADER_CG_PET_LEARN_SKILL = 126,
+	HEADER_CG_PET_SKILL_UPGRADE = 127,
+	HEADER_CG_PET_DELETE_SKILL = 128,
+	HEADER_CG_PET_DELETE_ALL_SKILL = 129,
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	HEADER_CG_EXTEND_INVEN = 47,
+#endif
+	//HEADER_CG_UNUSED = 48,
+	//HEADER_CG_UNUSED = 49,
+
+	HEADER_CG_SHOP = 50,
+	HEADER_CG_FLY_TARGETING = 51,
+	HEADER_CG_USE_SKILL = 52,
+	HEADER_CG_ADD_FLY_TARGETING = 53,
+	HEADER_CG_SHOOT = 54,
+	HEADER_CG_MYSHOP = 55,
+#if defined(__MYSHOP_DECO__)
+	HEADER_CG_MYSHOP_DECO_STATE = 56,
+	HEADER_CG_MYSHOP_DECO_ADD = 57,
+#endif
+	//HEADER_CG_UNUSED = 58,
+
+#if defined(__SEND_TARGET_INFO__)
+	HEADER_CG_TARGET_INFO = 59,
+#endif
+	HEADER_CG_ITEM_USE_TO_ITEM = 60,
+	HEADER_CG_TARGET = 61,
+
+	//HEADER_CG_UNUSED = 62,
+	//HEADER_CG_UNUSED = 63,
+	HEADER_CG_TEXT = 64, // @  滂퓔 灣트 캭磯.
+	HEADER_CG_WARP = 65,
+	HEADER_CG_SCRIPT_BUTTON = 66,
+	HEADER_CG_MESSENGER = 67,
+	//HEADER_CG_UNUSED = 68,
+
+	HEADER_CG_MALL_CHECKOUT = 69,
+	HEADER_CG_SAFEBOX_CHECKIN = 70, //  창 녌.
+	HEADER_CG_SAFEBOX_CHECKOUT = 71, //  창  쨈.
+
+	HEADER_CG_PARTY_INVITE = 72,
+	HEADER_CG_PARTY_INVITE_ANSWER = 73,
+	HEADER_CG_PARTY_REMOVE = 74,
+	HEADER_CG_PARTY_SET_STATE = 75,
+	HEADER_CG_PARTY_USE_SKILL = 76,
+	HEADER_CG_SAFEBOX_ITEM_MOVE = 77,
+	HEADER_CG_PARTY_PARAMETER = 78,
+	//HEADER_CG_UNUSED = 79,
+
+	HEADER_CG_GUILD = 80,
+	HEADER_CG_ANSWER_MAKE_GUILD = 81,
+	HEADER_CG_FISHING = 82,
+	HEADER_CG_ITEM_GIVE = 83,
+#ifdef __SHOP_SEARCH__
+	HEADER_CG_SHOP_SEARCH_BY_NAME = 84,
+	HEADER_CG_SHOP_SEARCH_BY_OPTION = 85,
+	HEADER_CG_SHOP_SEARCH_BUY = 86,
+	HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE = 87,
+	HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO = 88,
+#endif
+	HEADER_CG_EMPIRE = 90,
+	//HEADER_CG_UNUSED = 91,
+	//HEADER_CG_UNUSED = 92,
+	//HEADER_CG_UNUSED = 93,
+	//HEADER_CG_UNUSED = 94,
+	//HEADER_CG_UNUSED = 95,
+
+	HEADER_CG_REFINE = 96,
+#if defined(__CUBE_RENEWAL__)
+	HEADER_CG_CUBE = 97,
+#endif
+	//HEADER_CG_UNUSED = 98,
+	//HEADER_CG_UNUSED = 99,
+
+	HEADER_CG_MARK_LOGIN = 100,
+	HEADER_CG_MARK_CRCLIST = 101,
+	HEADER_CG_MARK_UPLOAD = 102,
+	//HEADER_CG_CRC_REPORT = 103,
+	HEADER_CG_MARK_IDXLIST = 104,
+
+	HEADER_CG_HACK = 105,
+	HEADER_CG_CHANGE_NAME = 106,
+	//HEADER_CG_UNUSED = 107,
+	//HEADER_CG_UNUSED = 108,
+	HEADER_CG_LOGIN2 = 109,
+	HEADER_CG_DUNGEON = 110,
+	HEADER_CG_LOGIN3 = 111,
+
+	HEADER_CG_GUILD_SYMBOL_UPLOAD = 112,
+	HEADER_CG_SYMBOL_CRC = 113,
+
+	// SCRIPT_SELECT_ITEM
+	HEADER_CG_SCRIPT_SELECT_ITEM = 114,
+	// END_OF_SCRIPT_SELECT_ITEM
+
+#if defined(__GEM_SYSTEM__)
+	HEADER_CG_SELECT_ITEM_EX = 115,
+#endif
+
+	//HEADER_CG_UNUSED = 116,
+	//HEADER_CG_UNUSED = 117,
+	//HEADER_CG_UNUSED = 118,
+	//HEADER_CG_UNUSED = 119,
+#if defined(__QUEST_REQUEST_EVENT__)
+	HEADER_CG_REQUEST_EVENT_QUEST = 120,
+#endif
+#if defined(__LEFT_SEAT__)
+	HEADER_CG_LEFT_SEAT = 121,
+#endif
+	//HEADER_CG_UNUSED = 122,
+	//HEADER_CG_UNUSED = 123,
+	//HEADER_CG_UNUSED = 124,
+	//HEADER_CG_UNUSED = 125,
+	//HEADER_CG_UNUSED = 126,
+	//HEADER_CG_UNUSED = 127,
+	//HEADER_CG_UNUSED = 128,
+	//HEADER_CG_UNUSED = 129,
+	//HEADER_CG_UNUSED = 130,
+	//HEADER_CG_UNUSED = 131,
+	//HEADER_CG_UNUSED = 132,
+	//HEADER_CG_UNUSED = 133,
+	//HEADER_CG_UNUSED = 134,
+	//HEADER_CG_UNUSED = 135,
+	//HEADER_CG_UNUSED = 136,
+	//HEADER_CG_UNUSED = 137,
+	//HEADER_CG_UNUSED = 138,
+	//HEADER_CG_UNUSED = 139,
+	//HEADER_CG_UNUSED = 140,
+	//HEADER_CG_UNUSED = 141,
+	//HEADER_CG_UNUSED = 142,
+	//HEADER_CG_UNUSED = 143,
+	//HEADER_CG_UNUSED = 144,
+#if defined(__FISHING_GAME__)
+	HEADER_CG_FISHING_GAME = 145,
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	HEADER_CG_REFINE_ELEMENT = 146,
+#endif
+	//HEADER_CG_UNUSED = 147,
+	//HEADER_CG_UNUSED = 148,
+	//HEADER_CG_UNUSED = 149,
+	//HEADER_CG_UNUSED = 150,
+#if defined(__SKILLBOOK_COMB_SYSTEM__)
+	HEADER_CG_SKILLBOOK_COMB = 151,
+#endif
+	//HEADER_CG_UNUSED = 152,
+	//HEADER_CG_UNUSED = 153,
+	//HEADER_CG_UNUSED = 154,
+	//HEADER_CG_UNUSED = 155,
+	//HEADER_CG_UNUSED = 156,
+	//HEADER_CG_UNUSED = 157,
+	//HEADER_CG_UNUSED = 158,
+	//HEADER_CG_UNUSED = 159,
+	//HEADER_CG_UNUSED = 160,
+	//HEADER_CG_UNUSED = 161,
+	//HEADER_CG_UNUSED = 162,
+	//HEADER_CG_UNUSED = 163,
+	//HEADER_CG_UNUSED = 164,
+	//HEADER_CG_UNUSED = 165,
+	//HEADER_CG_UNUSED = 166,
+	//HEADER_CG_UNUSED = 167,
+	//HEADER_CG_UNUSED = 168,
+#if defined(__ATTR_6TH_7TH__)
+	HEADER_CG_ATTR67_ADD = 169,
+#endif
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+	HEADER_CG_SNOWFLAKE_STICK_EVENT = 170,
+#endif
+	//HEADER_CG_UNUSED = 171,
+	//HEADER_CG_UNUSED = 172,
+	//HEADER_CG_UNUSED = 173,
+	//HEADER_CG_UNUSED = 174,
+	//HEADER_CG_UNUSED = 175,
+	//HEADER_CG_UNUSED = 176,
+	//HEADER_CG_UNUSED = 177,
+	//HEADER_CG_UNUSED = 178,
+	//HEADER_CG_UNUSED = 179,
+	//HEADER_CG_UNUSED = 180,
+#if defined(__MINI_GAME_RUMI__)
+	HEADER_CG_MINI_GAME_RUMI = 181,
+#endif
+#if defined(__MINI_GAME_YUTNORI__)
+	HEADER_CG_MINI_GAME_YUTNORI = 182,
+#endif
+#if defined(__GEM_SHOP__)
+	HEADER_CG_GEM_SHOP = 183,
+#endif
+	//HEADER_CG_UNUSED = 184,
+	//HEADER_CG_UNUSED = 185,
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	HEADER_CG_MINI_GAME_ROULETTE = 186,
+#endif
+#if defined(__FLOWER_EVENT__)
+	HEADER_CG_FLOWER_EVENT = 187,
+#endif
+	//HEADER_CG_UNUSED = 188,
+	//HEADER_CG_UNUSED = 189,
+	//HEADER_CG_UNUSED = 190,
+	//HEADER_CG_UNUSED = 191,
+	//HEADER_CG_UNUSED = 192,
+	//HEADER_CG_UNUSED = 193,
+	//HEADER_CG_UNUSED = 194,
+	//HEADER_CG_UNUSED = 195,
+	//HEADER_CG_UNUSED = 196,
+	//HEADER_CG_UNUSED = 197,
+	//HEADER_CG_UNUSED = 198,
+	//HEADER_CG_UNUSED = 199,
+	//HEADER_CG_UNUSED = 200,
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	HEADER_CG_EXT_BATTLE_PASS_ACTION = 201,
+	HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM = 202,
+#endif
+
+	// NOTE : 肩 XXX  隔 Packet  . 肩 湄構  耭載.
+	// enum   求. 틈 namepsace  求..
+	//  packet generator 帽 苛쨈. 肩 XX
+	// 肩鳴  치  책쨉???
+	//HEADER_CG_HS_ACK = 203,
+	//HEADER_CG_XTRAP_ACK = 204,
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	HEADER_CG_DRAGON_SOUL_REFINE = 205,
+#endif
+	HEADER_CG_STATE_CHECKER = 206,
+
+	//HEADER_CG_UNUSED = 207,
+#if defined(__LUCKY_BOX__)
+	HEADER_CG_LUCKY_BOX = 208,
+#endif
+	//HEADER_CG_UNUSED = 210,
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	HEADER_CG_ACCE_REFINE = 211,
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	HEADER_CG_AURA_REFINE = 212,
+#endif
+	//HEADER_CG_UNUSED = 213,
+	//HEADER_CG_UNUSED = 214,
+#if defined(__MAILBOX__)
+	HEADER_CG_MAILBOX_WRITE = 215,
+	HEADER_CG_MAILBOX_WRITE_CONFIRM = 216,
+	HEADER_CG_MAILBOX_PROCESS = 217,
+#endif
+#if defined(__MOVE_COSTUME_ATTR__)
+	HEADER_CG_ITEM_COMBINATION = 218,
+	HEADER_CG_ITEM_COMBINATION_CANCEL = 219,
+#endif
+	//HEADER_CG_UNUSED = 223,
+	//HEADER_CG_UNUSED = 224,
+	//HEADER_CG_UNUSED = 225,
+#if defined(__MINI_GAME_CATCH_KING__)
+	HEADER_CG_MINI_GAME_CATCH_KING = 226,
+#endif
+#if defined(__CHANGED_ATTR__)
+	HEADER_CG_ITEM_SELECT_ATTR = 227,
+#endif
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	HEADER_CG_CHANGE_LOOK = 228,
+#endif
+	//HEADER_CG_UNUSED = 229,
+	//HEADER_CG_UNUSED = 230,
+	//HEADER_CG_UNUSED = 231,
+	//HEADER_CG_UNUSED = 232,
+	//HEADER_CG_UNUSED = 233,
+	//HEADER_CG_UNUSED = 234,
+#if defined(__LOOT_FILTER_SYSTEM__)
+	HEADER_CG_LOOT_FILTER = 235,
+#endif
+	//HEADER_CG_UNUSED = 236,
+	//HEADER_CG_UNUSED = 237,
+	//HEADER_CG_UNUSED = 238,
+	//HEADER_CG_UNUSED = 239,
+	//HEADER_CG_UNUSED = 240,
+	HEADER_CG_CLIENT_VERSION2 = 0xf1, // 241
+	//HEADER_CG_UNUSED = 242,
+	//HEADER_CG_UNUSED = 243,
+	//HEADER_CG_UNUSED = 244,
+	//HEADER_CG_UNUSED = 245,
+	//HEADER_CG_UNUSED = 246,
+	//HEADER_CG_UNUSED = 247,
+	//HEADER_CG_UNUSED = 248,
+	//HEADER_CG_UNUSED = 249,
+	//HEADER_CG_UNUSED = 250,
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	HEADER_CG_KEY_AGREEMENT = 0xfb, // 251
+#endif
+	HEADER_CG_TIME_SYNC = 0xfc, // 252
+	HEADER_CG_CLIENT_VERSION = 0xfd, // 253
+	HEADER_CG_PONG = 0xfe, // 254
+	HEADER_CG_HANDSHAKE = 0xff, // 255
+};
+
+enum GC_HEADERS
+{
+	HEADER_GC_CHARACTER_ADD = 1,
+	HEADER_GC_CHARACTER_DEL = 2,
+	HEADER_GC_MOVE = 3,
+	HEADER_GC_CHAT = 4,
+	HEADER_GC_SYNC_POSITION = 5,
+
+	HEADER_GC_LOGIN_SUCCESS = 6,
+	HEADER_GC_LOGIN_FAILURE = 7,
+
+	HEADER_GC_CHARACTER_CREATE_SUCCESS = 8,
+	HEADER_GC_CHARACTER_CREATE_FAILURE = 9,
+	HEADER_GC_CHARACTER_DELETE_SUCCESS = 10,
+	HEADER_GC_CHARACTER_DELETE_WRONG_SOCIAL_ID = 11,
+
+	//HEADER_GC_UNUSED = 12,
+	HEADER_GC_STUN = 13,
+	HEADER_GC_DEAD = 14,
+
+	HEADER_GC_MAIN_CHARACTER_OLD = 15,
+	HEADER_GC_CHARACTER_POINTS = 16,
+	HEADER_GC_CHARACTER_POINT_CHANGE = 17,
+	HEADER_GC_CHANGE_SPEED = 18,
+	HEADER_GC_CHARACTER_UPDATE = 19,
+
+	HEADER_GC_ITEM_DEL = 20,
+	HEADER_GC_ITEM_SET = 21,
+	HEADER_GC_ITEM_USE = 22,
+	HEADER_GC_ITEM_DROP = 23,
+
+	//HEADER_GC_UNUSED = 24,
+	HEADER_GC_ITEM_UPDATE = 25,
+	HEADER_GC_ITEM_GROUND_ADD = 26,
+	HEADER_GC_ITEM_GROUND_DEL = 27,
+
+	HEADER_GC_QUICKSLOT_ADD = 28,
+	HEADER_GC_QUICKSLOT_DEL = 29,
+	HEADER_GC_QUICKSLOT_SWAP = 30,
+
+	HEADER_GC_ITEM_OWNERSHIP = 31,
+
+	HEADER_GC_LOGIN_SUCCESS_NEWSLOT = 32,
+
+	//HEADER_GC_UNUSED = 33,
+	HEADER_GC_WHISPER = 34,
+	//HEADER_GC_UNUSED = 35,
+
+	HEADER_GC_MOTION = 36,
+	HEADER_GC_EMOTE = 37,
+
+	HEADER_GC_SHOP = 38,
+	HEADER_GC_SHOP_SIGN = 39,
+
+	HEADER_GC_DUEL_START = 40,
+	HEADER_GC_PVP = 41,
+	HEADER_GC_EXCHANGE = 42,
+	HEADER_GC_CHARACTER_POSITION = 43,
+
+	HEADER_GC_PING = 44,
+	HEADER_GC_SCRIPT = 45,
+	HEADER_GC_QUEST_CONFIRM = 46,
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	HEADER_GC_EXTEND_INVEN = 47,
+	HEADER_GC_EXTEND_INVEN_ITEM_USE = 48,
+#endif
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	HEADER_GC_GUILD_DRAGONLAIR = 49,
+#endif
+#if defined(__CLIENT_TIMER__)
+	HEADER_GC_CLIENT_TIMER = 50,
+#endif
+#if defined(__OFFLINE_SHOP__)
+	HEADER_GC_OFFLINE_SHOP = 51,
+#endif
+	//HEADER_GC_UNUSED = 52,
+	//HEADER_GC_UNUSED = 53,
+	//HEADER_GC_UNUSED = 54,
+	//HEADER_GC_UNUSED = 55,
+	//HEADER_GC_UNUSED = 56,
+	//HEADER_GC_UNUSED = 57,
+#if defined(__SEND_TARGET_INFO__)
+	HEADER_GC_TARGET_INFO = 58,
+#endif
+	//HEADER_GC_UNUSED = 59,
+	//HEADER_GC_UNUSED = 60,
+	HEADER_GC_MOUNT = 61,
+	HEADER_GC_OWNERSHIP = 62,
+	HEADER_GC_TARGET = 63,
+	//HEADER_GC_UNUSED = 64,
+	HEADER_GC_WARP = 65,
+	//HEADER_GC_UNUSED = 66,
+	//HEADER_GC_UNUSED = 67,
+	//HEADER_GC_UNUSED = 68,
+	HEADER_GC_ADD_FLY_TARGETING = 69,
+
+	HEADER_GC_CREATE_FLY = 70,
+	HEADER_GC_FLY_TARGETING = 71,
+	HEADER_GC_SKILL_LEVEL_OLD = 72,
+	//HEADER_GC_UNUSED = 73,
+	HEADER_GC_MESSENGER = 74,
+	HEADER_GC_GUILD = 75,
+	HEADER_GC_SKILL_LEVEL = 76,
+
+	HEADER_GC_PARTY_INVITE = 77,
+	HEADER_GC_PARTY_ADD = 78,
+	HEADER_GC_PARTY_UPDATE = 79,
+	HEADER_GC_PARTY_REMOVE = 80,
+
+	HEADER_GC_QUEST_INFO = 81,
+	HEADER_GC_REQUEST_MAKE_GUILD = 82,
+	HEADER_GC_PARTY_PARAMETER = 83,
+	//HEADER_GC_UNUSED = 84,
+
+	HEADER_GC_SAFEBOX_SET = 85,
+	HEADER_GC_SAFEBOX_DEL = 86,
+	HEADER_GC_SAFEBOX_WRONG_PASSWORD = 87,
+	HEADER_GC_SAFEBOX_SIZE = 88,
+
+	HEADER_GC_FISHING = 89,
+
+	HEADER_GC_EMPIRE = 90,
+
+	HEADER_GC_PARTY_LINK = 91,
+	HEADER_GC_PARTY_UNLINK = 92,
+	//HEADER_GC_UNUSED = 93,
+	//HEADER_GC_UNUSED = 94,
+	//HEADER_GC_UNUSED = 95,
+	//HEADER_GC_UNUSED = 96,
+#if defined(__CUBE_RENEWAL__)
+	HEADER_GC_CUBE = 97,
+#endif
+	//HEADER_GC_UNUSED = 98,
+	HEADER_GC_VIEW_EQUIP = 99,
+
+	HEADER_GC_MARK_BLOCK = 100,
+	//HEADER_GC_MARK_DIFF_DATA = 101,
+	HEADER_GC_MARK_IDXLIST = 102,
+	//HEADER_GC_UNUSED = 103,
+	//HEADER_GC_UNUSED = 104,
+	//HEADER_GC_SLOW_TIMER = 105,
+	HEADER_GC_TIME = 106,
+	HEADER_GC_CHANGE_NAME = 107,
+	//HEADER_GC_UNUSED = 108,
+	//HEADER_GC_UNUSED = 109,
+
+	HEADER_GC_DUNGEON = 110,
+
+	HEADER_GC_WALK_MODE = 111,
+	HEADER_GC_SKILL_GROUP = 112,
+	HEADER_GC_MAIN_CHARACTER = 113,
+
+	HEADER_GC_SEPCIAL_EFFECT = 114,
+	HEADER_GC_NPC_POSITION = 115,
+
+	//HEADER_CG_UNUSED = 116,
+	//HEADER_GC_UNUSED = 117,
+	HEADER_GC_LOGIN_KEY = 118,
+
+	HEADER_GC_REFINE_INFORMATION = 119,
+	//HEADER_GC_UNUSED = 120,
+	HEADER_GC_CHANNEL = 121,
+
+	HEADER_GC_MALL_OPEN = 122,
+
+	HEADER_GC_TARGET_UPDATE = 123,
+	HEADER_GC_TARGET_DELETE = 124,
+	HEADER_GC_TARGET_CREATE = 125,
+
+	HEADER_GC_AFFECT_ADD = 126,
+	HEADER_GC_AFFECT_REMOVE = 127,
+
+	HEADER_GC_MALL_SET = 128,
+	HEADER_GC_MALL_DEL = 129,
+
+	HEADER_GC_LAND_LIST = 130,
+	HEADER_GC_LOVER_INFO = 131,
+	HEADER_GC_LOVE_POINT_UPDATE = 132,
+
+	HEADER_GC_SYMBOL_DATA = 133,
+
+	// MINING
+	HEADER_GC_DIG_MOTION = 134,
+	// END_OF_MINING
+
+	HEADER_GC_DAMAGE_INFO = 135,
+	HEADER_GC_CHAR_ADDITIONAL_INFO = 136,
+
+	// SUPPORT_BGM
+	HEADER_GC_MAIN_CHARACTER3_BGM = 137,
+	HEADER_GC_MAIN_CHARACTER4_BGM_VOL = 138,
+	// END_OF_SUPPORT_BGM
+
+	//HEADER_GC_UNUSED = 140,
+	//HEADER_GC_UNUSED = 141,
+	//HEADER_GC_UNUSED = 142,
+	//HEADER_GC_UNUSED = 143,
+	//HEADER_GC_UNUSED = 144,
+#if defined(__FISHING_GAME__)
+	HEADER_GC_FISHING_GAME = 145,
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	HEADER_GC_REFINE_ELEMENT = 146,
+#endif
+	//HEADER_GC_UNUSED = 147,
+	//HEADER_GC_UNUSED = 148,
+	//HEADER_GC_UNUSED = 149,
+
+	HEADER_GC_AUTH_SUCCESS = 150,
+	HEADER_GC_PANAMA_PACK = 151,
+
+	// HYBRID CRYPT
+	HEADER_GC_HYBRIDCRYPT_KEYS = 152,
+	HEADER_GC_HYBRIDCRYPT_SDB = 153, // SDB means Supplmentary Data Blocks
+	// HYBRID CRYPT
+
+#ifdef __SHOP_SEARCH__
+	HEADER_GC_SHOP_SEARCH_RESULT = 164,
+	HEADER_GC_SHOP_SEARCH_BUY_RESULT = 165,
+	HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE = 166,
+	HEADER_GC_SHOP_SEARCH_SOLD_INFO = 167,
+	HEADER_GC_ENTITY = 168,
+#endif
+	//HEADER_GC_UNUSED = 169,
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+	HEADER_GC_SNOWFLAKE_STICK_EVENT = 170,
+#endif
+	//HEADER_GC_UNUSED = 171,
+	//HEADER_GC_UNUSED = 172,
+	//HEADER_GC_UNUSED = 173,
+	//HEADER_GC_UNUSED = 174,
+	//HEADER_GC_UNUSED = 175,
+	//HEADER_GC_UNUSED = 176,
+	//HEADER_GC_UNUSED = 177,
+	//HEADER_GC_UNUSED = 178,
+	//HEADER_GC_UNUSED = 179,
+	//HEADER_GC_UNUSED = 180,
+#if defined(__MINI_GAME_RUMI__)
+	HEADER_GC_MINI_GAME_RUMI = 181,
+#endif
+#if defined(__MINI_GAME_YUTNORI__)
+	HEADER_GC_MINI_GAME_YUTNORI = 182,
+#endif
+	//HEADER_GC_UNUSED = 183,
+	//HEADER_GC_UNUSED = 184,
+	//HEADER_GC_UNUSED = 185,
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	HEADER_GC_MINI_GAME_ROULETTE = 186,
+#endif
+#if defined(__FLOWER_EVENT__)
+	HEADER_GC_FLOWER_EVENT = 187,
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	HEADER_GC_PET = 158,
+	HEADER_GC_PET_SET = 159,
+	HEADER_GC_PET_SET_EXCHANGE = 160,
+	HEADER_GC_PET_DEL = 161,
+	HEADER_GC_PET_SUMMON = 162,
+	HEADER_GC_PET_POINT_CHANGE = 163,
+	HEADER_GC_PET_NAME_CHANGE_RESULT = 164,
+	HEADER_GC_PET_DETERMINE_RESULT = 165,
+	HEADER_GC_PET_ATTR_CHANGE_RESULT = 166,
+	HEADER_GC_PET_SKILL_UPDATE = 167,
+	HEADER_GC_PET_SKILL_COOLTIME = 168,
+#endif
+
+	//HEADER_GC_UNUSED = 199,
+	//HEADER_GC_UNUSED = 200,
+
+#if defined(__GEM_SHOP__)
+	HEADER_GC_GEM_SHOP = 201,
+	HEADER_GC_GEM_SHOP_PROCESS = 202,
+#endif
+	//HEADER_GC_UNUSED = 203,
+	//HEADER_GC_UNUSED = 204,
+	//HEADER_GC_UNUSED = 205,
+	//HEADER_GC_UNUSED = 206,
+	//HEADER_GC_UNUSED = 207,
+
+	HEADER_GC_SPECIFIC_EFFECT = 208,
+
+	HEADER_GC_DRAGON_SOUL_REFINE = 209,
+	HEADER_GC_RESPOND_CHANNELSTATUS = 210,
+
+	//HEADER_GC_UNUSED = 212,
+	//HEADER_GC_UNUSED = 213,
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	HEADER_GC_ACCE_REFINE = 214,
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	HEADER_GC_AURA_REFINE = 215,
+#endif
+	//HEADER_GC_UNUSED = 216,
+#if defined(__LUCKY_BOX__)
+	HEADER_GC_LUCKY_BOX = 217,
+#endif
+	//HEADER_GC_UNUSED = 218,
+	//HEADER_GC_UNUSED = 219,
+	//HEADER_GC_UNUSED = 220,
+#if defined(__MAILBOX__)
+	HEADER_GC_MAILBOX_PROCESS = 221,
+	HEADER_GC_MAILBOX = 222,
+	HEADER_GC_MAILBOX_ADD_DATA = 223,
+	HEADER_GC_MAILBOX_ALL = 224,
+	HEADER_GC_MAILBOX_UNREAD = 225,
+#endif
+	//HEADER_GC_UNUSED = 226,
+#if defined(__CHANGED_ATTR__)
+	HEADER_GC_ITEM_SELECT_ATTR = 227,
+#endif
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	HEADER_GC_CHANGE_LOOK_SET = 228,
+	HEADER_GC_CHANGE_LOOK_DEL = 229,
+	HEADER_GC_CHANGE_LOOK_FREE_SET = 230,
+	HEADER_GC_CHANGE_LOOK_FREE_DEL = 231,
+#endif
+	//HEADER_GC_UNUSED = 232,
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	HEADER_GC_EXT_BATTLE_PASS_OPEN = 233,
+	HEADER_GC_EXT_BATTLE_PASS_GENERAL_INFO = 234,
+	HEADER_GC_EXT_BATTLE_PASS_MISSION_INFO = 235,
+	HEADER_GC_EXT_BATTLE_PASS_MISSION_UPDATE = 236,
+	HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING = 237,
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__)
+	HEADER_GC_MINI_GAME_CATCH_KING = 238,
+#endif
+	//HEADER_GC_UNUSED = 239,
+#if defined(__RANKING_SYSTEM__)
+	HEADER_GC_RANKING = 240,
+#endif
+	//HEADER_GC_UNUSED = 241,
+	//HEADER_GC_UNUSED = 242,
+	//HEADER_GC_UNUSED = 243,
+	//HEADER_GC_UNUSED = 244,
+#if defined(__LOOT_FILTER_SYSTEM__)
+	HEADER_GC_LOOT_FILTER = 245,
+#endif
+	//HEADER_GC_UNUSED = 246,
+	//HEADER_GC_UNUSED = 247,
+	//HEADER_GC_UNUSED = 248,
+	//HEADER_GC_UNUSED = 249,
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	HEADER_GC_KEY_AGREEMENT_COMPLETED = 250, // 250
+	HEADER_GC_KEY_AGREEMENT = 251, // 251
+#endif
+	HEADER_GC_HANDSHAKE_OK = 252, // 252 (0xfc)
+	HEADER_GC_TIME_SYNC = 252, // legacy alias (handshake ok)
+	HEADER_GC_PHASE = 253, // 253
+	HEADER_GC_BINDUDP = 254, // 254
+	HEADER_GC_HANDSHAKE = 255, // 255
+};
+
+enum GG_HEADERS
+{
+	HEADER_GG_LOGIN = 1,
+	HEADER_GG_LOGOUT = 2,
+	HEADER_GG_RELAY = 3,
+	HEADER_GG_NOTICE = 4,
+	HEADER_GG_SHUTDOWN = 5,
+	HEADER_GG_GUILD = 6,
+	HEADER_GG_DISCONNECT = 7, //     
+	HEADER_GG_SHOUT = 8,
+	HEADER_GG_SETUP = 9,
+	HEADER_GG_MESSENGER_ADD = 10,
+	HEADER_GG_MESSENGER_REMOVE = 11,
+	HEADER_GG_FIND_POSITION = 12,
+	HEADER_GG_WARP_CHARACTER = 13,
+	//HEADER_GG_UNUSED = 14,
+	HEADER_GG_GUILD_WAR_ZONE_MAP_INDEX = 15,
+	HEADER_GG_TRANSFER = 16,
+#if defined(__XMAS_EVENT_2008__)
+	HEADER_GG_XMAS_WARP_SANTA = 17,
+	HEADER_GG_XMAS_WARP_SANTA_REPLY = 18,
+#endif
+	HEADER_GG_RELOAD_CRC_LIST = 19,
+	HEADER_GG_LOGIN_PING = 20,
+	HEADER_GG_CHECK_CLIENT_VERSION = 21,
+	HEADER_GG_BLOCK_CHAT = 22,
+	HEADER_GG_BIG_NOTICE = 23,
+	HEADER_GG_BLOCK_EXCEPTION = 24,
+	HEADER_GG_SIEGE = 25,
+	HEADER_GG_MONARCH_NOTICE = 26,
+	HEADER_GG_MONARCH_TRANSFER = 27,
+	HEADER_GG_PCBANG_UPDATE = 28,
+	HEADER_GG_CHECK_AWAKENESS = 29,
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	HEADER_GG_MESSENGER_BLOCK_ADD = 30,
+	HEADER_GG_MESSENGER_BLOCK_REMOVE = 31,
+#endif
+#if defined(__OFFLINE_SHOP__)
+	HEADER_GG_OFFLINE_SHOP = 33,
+	HEADER_GG_UPDATE_SELL_HISTORY = 34,
+#endif
+};
+
+#pragma pack(1)
+typedef struct SPacketGGSetup
+{
+	BYTE bHeader;
+	WORD wPort;
+	BYTE bChannel;
+} TPacketGGSetup;
+
+typedef struct SPacketGGLogin
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	DWORD dwPID;
+	BYTE bEmpire;
+	long lMapIndex;
+	BYTE bChannel;
+} TPacketGGLogin;
+
+typedef struct SPacketGGLogout
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGGLogout;
+
+typedef struct SPacketGGRelay
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	long lSize;
+} TPacketGGRelay;
+
+typedef struct SPacketGGNotice
+{
+	BYTE bHeader;
+	long lSize;
+	char szArg[CHAT_MAX_LEN + 1];
+	bool bBigFont;
+} TPacketGGNotice;
+
+typedef struct SPacketGGMonarchNotice
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+	long lSize;
+} TPacketGGMonarchNotice;
+
+// FORKED_ROAD
+typedef struct SPacketGGForkedMapInfo
+{
+	BYTE bHeader;
+	BYTE bPass;
+	BYTE bSungzi;
+} TPacketGGForkedMapInfo;
+// END_FORKED_ROAD
+
+typedef struct SPacketGGShutdown
+{
+	BYTE bHeader;
+} TPacketGGShutdown;
+
+typedef struct SPacketGGGuild
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwGuild;
+} TPacketGGGuild;
+
+enum
+{
+	GUILD_SUBHEADER_GG_CHAT,
+	GUILD_SUBHEADER_GG_SET_MEMBER_COUNT_BONUS,
+};
+
+typedef struct SPacketGGGuildChat
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwGuild;
+	char szText[CHAT_MAX_LEN + 1];
+} TPacketGGGuildChat;
+
+typedef struct SPacketGGParty
+{
+	BYTE header;
+	BYTE subheader;
+	DWORD pid;
+	DWORD leaderpid;
+} TPacketGGParty;
+
+enum
+{
+	PARTY_SUBHEADER_GG_CREATE,
+	PARTY_SUBHEADER_GG_DESTROY,
+	PARTY_SUBHEADER_GG_JOIN,
+	PARTY_SUBHEADER_GG_QUIT,
+};
+
+typedef struct SPacketGGDisconnect
+{
+	BYTE bHeader;
+	char szLogin[LOGIN_MAX_LEN + 1];
+} TPacketGGDisconnect;
+
+typedef struct SPacketGGShout
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+	char szText[CHAT_MAX_LEN + 1];
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketGGShout;
+
+#if defined(__XMAS_EVENT_2008__)
+typedef struct SPacketGGXmasWarpSanta
+{
+	BYTE bHeader;
+	BYTE bChannel;
+	long lMapIndex;
+} TPacketGGXmasWarpSanta;
+
+typedef struct SPacketGGXmasWarpSantaReply
+{
+	BYTE bHeader;
+	BYTE bChannel;
+} TPacketGGXmasWarpSantaReply;
+#endif
+
+typedef struct SPacketGGMessenger
+{
+	BYTE bHeader;
+	char szAccount[CHARACTER_NAME_MAX_LEN + 1];
+	char szCompanion[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGGMessenger;
+
+typedef struct SPacketGGFindPosition
+{
+	BYTE header;
+	DWORD dwFromPID; //  치 狗 
+	DWORD dwTargetPID; // 찾 
+} TPacketGGFindPosition;
+
+typedef struct SPacketGGWarpCharacter
+{
+	BYTE header;
+	DWORD pid;
+	long x;
+	long y;
+} TPacketGGWarpCharacter;
+
+//HEADER_GG_GUILD_WAR_ZONE_MAP_INDEX = 15,
+
+typedef struct SPacketGGGuildWarMapIndex
+{
+	BYTE bHeader;
+	DWORD dwGuildID1;
+	DWORD dwGuildID2;
+	long lMapIndex;
+} TPacketGGGuildWarMapIndex;
+
+typedef struct SPacketGGTransfer
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	long lX, lY;
+} TPacketGGTransfer;
+
+typedef struct SPacketGGLoginPing
+{
+	BYTE bHeader;
+	char szLogin[LOGIN_MAX_LEN + 1];
+} TPacketGGLoginPing;
+
+typedef struct SPacketGGBlockChat
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	long lBlockDuration;
+} TPacketGGBlockChat;
+
+/* 클潔트   킷 */
+typedef struct command_text
+{
+	BYTE bHeader;
+} TPacketCGText;
+
+typedef struct command_phase
+{
+	BYTE bHeader;
+} TPacketCGPhase;
+
+/* 慣 (1) */
+typedef struct command_handshake
+{
+	BYTE bHeader;
+	DWORD dwHandshake;
+	DWORD dwTime;
+	long lDelta;
+} TPacketCGHandshake;
+
+typedef struct command_login
+{
+	BYTE header;
+	char login[LOGIN_MAX_LEN + 1];
+	char passwd[PASSWD_MAX_LEN + 1];
+} TPacketCGLogin;
+
+typedef struct command_login2
+{
+	BYTE header;
+	char login[LOGIN_MAX_LEN + 1];
+	DWORD dwLoginKey;
+	DWORD adwClientKey[4];
+} TPacketCGLogin2;
+
+typedef struct command_login3
+{
+	BYTE header;
+	char login[LOGIN_MAX_LEN + 1];
+	char passwd[PASSWD_MAX_LEN + 1];
+	DWORD adwClientKey[4];
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char country[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketCGLogin3;
+
+typedef struct packet_login_key
+{
+	BYTE bHeader;
+	DWORD dwLoginKey;
+} TPacketGCLoginKey;
+
+typedef struct command_player_select
+{
+	BYTE header;
+	BYTE index;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char country[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketCGPlayerSelect;
+
+typedef struct command_player_delete
+{
+	BYTE header;
+	BYTE index;
+	char private_code[8];
+} TPacketCGPlayerDelete;
+
+typedef struct command_player_create
+{
+	BYTE header;
+	BYTE index;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	WORD job;
+	BYTE shape;
+	BYTE Con;
+	BYTE Int;
+	BYTE Str;
+	BYTE Dex;
+} TPacketCGPlayerCreate;
+
+typedef struct command_player_create_success
+{
+	BYTE header;
+	BYTE bAccountCharacterIndex;
+	TSimplePlayer player;
+} TPacketGCPlayerCreateSuccess;
+
+// 
+typedef struct command_attack
+{
+	BYTE bHeader;
+	BYTE bType;
+	DWORD dwVID;
+	BYTE bCRCMagicCubeProcPiece;
+	BYTE bCRCMagicCubeFilePiece;
+} TPacketCGAttack;
+
+enum EMoveFuncType
+{
+	FUNC_WAIT,
+	FUNC_MOVE,
+	FUNC_ATTACK,
+	FUNC_COMBO,
+	FUNC_MOB_SKILL,
+	_FUNC_SKILL,
+	FUNC_MAX_NUM,
+	FUNC_SKILL = 0x80,
+};
+
+// 絹
+typedef struct command_move
+{
+	BYTE bHeader;
+	BYTE bFunc;
+	BYTE bArg;
+	BYTE bRot;
+	long lX;
+	long lY;
+	DWORD dwTime;
+} TPacketCGMove;
+
+typedef struct command_sync_position_element
+{
+	DWORD dwVID;
+	long lX;
+	long lY;
+} TPacketCGSyncPositionElement;
+
+// 치 화
+typedef struct command_sync_position //  킷
+{
+	BYTE bHeader;
+	WORD wSize;
+} TPacketCGSyncPosition;
+
+/* 채 (3) */
+typedef struct command_chat //  킷
+{
+	BYTE header;
+	WORD size;
+	BYTE type;
+} TPacketCGChat;
+
+/* 憺疸 */
+typedef struct command_whisper
+{
+	BYTE bHeader;
+	WORD wSize;
+	char szNameTo[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketCGWhisper;
+
+typedef struct command_entergame
+{
+	BYTE header;
+} TPacketCGEnterGame;
+
+typedef struct command_item_use
+{
+	BYTE header;
+	TItemPos Cell;
+} TPacketCGItemUse;
+
+typedef struct command_item_use_to_item
+{
+	BYTE header;
+	TItemPos Cell;
+	TItemPos TargetCell;
+} TPacketCGItemUseToItem;
+
+typedef struct command_item_drop
+{
+	BYTE header;
+	TItemPos Cell;
+	DWORD gold;
+#if defined(__CHEQUE_SYSTEM__)
+	DWORD cheque;
+#endif
+} TPacketCGItemDrop;
+
+typedef struct command_item_drop2
+{
+	BYTE header;
+	TItemPos Cell;
+	DWORD gold;
+#if defined(__CHEQUE_SYSTEM__)
+	DWORD cheque;
+#endif
+	WORD count;
+} TPacketCGItemDrop2;
+
+#if defined(__NEW_DROP_DIALOG__)
+typedef struct command_item_destroy
+{
+	BYTE header;
+	TItemPos Cell;
+} TPacketCGItemDestroy;
+#endif
+
+typedef struct command_item_move
+{
+	BYTE header;
+	TItemPos Cell;
+	TItemPos CellTo;
+	WORD count;
+} TPacketCGItemMove;
+
+typedef struct command_item_pickup
+{
+	BYTE header;
+	DWORD vid;
+} TPacketCGItemPickup;
+
+typedef struct command_quickslot_add
+{
+	BYTE header;
+	BYTE pos;
+	TQuickslot slot;
+} TPacketCGQuickslotAdd;
+
+typedef struct command_quickslot_del
+{
+	BYTE header;
+	BYTE pos;
+} TPacketCGQuickslotDel;
+
+typedef struct command_quickslot_swap
+{
+	BYTE header;
+	BYTE pos;
+	BYTE change_pos;
+} TPacketCGQuickslotSwap;
+
+enum
+{
+	SHOP_SUBHEADER_CG_END,
+	SHOP_SUBHEADER_CG_BUY,
+	SHOP_SUBHEADER_CG_SELL,
+	SHOP_SUBHEADER_CG_SELL2,
+};
+
+typedef struct command_shop_buy
+{
+	BYTE count;
+} TPacketCGShopBuy;
+
+typedef struct command_shop_sell
+{
+	WORD wPos;
+	WORD wCount;
+	BYTE bType;
+} TPacketCGShopSell;
+
+typedef struct command_shop
+{
+	BYTE header;
+	WORD subheader;
+} TPacketCGShop;
+
+typedef struct command_on_click
+{
+	BYTE header;
+	DWORD vid;
+} TPacketCGOnClick;
+
+enum
+{
+	EXCHANGE_SUBHEADER_CG_START, /* arg1 == vid of target character */
+	EXCHANGE_SUBHEADER_CG_ITEM_ADD, /* arg1 == position of item */
+	EXCHANGE_SUBHEADER_CG_ITEM_DEL, /* arg1 == position of item */
+	EXCHANGE_SUBHEADER_CG_ELK_ADD, /* arg1 == amount of gold */
+#if defined(__CHEQUE_SYSTEM__)
+	EXCHANGE_SUBHEADER_CG_CHEQUE_ADD, /* arg1 == amount of cheque */
+#endif
+	EXCHANGE_SUBHEADER_CG_ACCEPT, /* arg1 == not used */
+	EXCHANGE_SUBHEADER_CG_CANCEL, /* arg1 == not used */
+};
+
+typedef struct command_exchange
+{
+	BYTE header;
+	BYTE sub_header;
+	DWORD arg1;
+	BYTE arg2;
+	TItemPos Pos;
+} TPacketCGExchange;
+
+typedef struct command_position
+{
+	BYTE header;
+	BYTE position;
+} TPacketCGPosition;
+
+typedef struct command_script_answer
+{
+	BYTE header;
+	BYTE answer;
+	//char file[32 + 1];
+	//BYTE answer[16 + 1];
+} TPacketCGScriptAnswer;
+
+typedef struct command_script_button
+{
+	BYTE header;
+	unsigned int idx;
+} TPacketCGScriptButton;
+
+typedef struct command_quest_input_string
+{
+	BYTE header;
+	char msg[64 + 1];
+} TPacketCGQuestInputString;
+
+#if defined(__OX_RENEWAL__)
+typedef struct command_quest_input_long_string
+{
+	BYTE header;
+	char msg[128 + 1];
+} TPacketCGQuestInputLongString;
+#endif
+
+typedef struct command_quest_confirm
+{
+	BYTE header;
+	BYTE answer;
+	DWORD requestPID;
+} TPacketCGQuestConfirm;
+
+/*
+*    킷
+*/
+typedef struct packet_quest_confirm
+{
+	BYTE header;
+	char msg[128 + 1];
+	long timeout;
+	DWORD requestPID;
+} TPacketGCQuestConfirm;
+
+typedef struct packet_handshake
+{
+	BYTE bHeader;
+	DWORD dwHandshake;
+	DWORD dwTime;
+	long lDelta;
+} TPacketGCHandshake;
+
+enum EPhase
+{
+	PHASE_CLOSE,
+	PHASE_HANDSHAKE,
+	PHASE_LOGIN,
+	PHASE_SELECT,
+	PHASE_LOADING,
+	PHASE_GAME,
+	PHASE_DEAD,
+
+	PHASE_CLIENT_CONNECTING,
+	PHASE_DBCLIENT,
+	PHASE_P2P,
+	PHASE_AUTH,
+};
+
+typedef struct packet_phase
+{
+	BYTE header;
+	BYTE phase;
+} TPacketGCPhase;
+
+typedef struct packet_bindudp
+{
+	BYTE header;
+	DWORD addr;
+	WORD port;
+} TPacketGCBindUDP;
+
+typedef struct packet_login_success
+{
+	BYTE bHeader;
+	TSimplePlayer players[PLAYER_PER_ACCOUNT];
+	DWORD guild_id[PLAYER_PER_ACCOUNT];
+	char guild_name[PLAYER_PER_ACCOUNT][GUILD_NAME_MAX_LEN + 1];
+
+	DWORD handle;
+	DWORD random_key;
+} TPacketGCLoginSuccess;
+
+typedef struct packet_auth_success
+{
+	BYTE bHeader;
+	DWORD dwLoginKey;
+	BYTE bResult;
+	BOOL bState;
+} TPacketGCAuthSuccess;
+
+enum ELoginFailure
+{
+	LOGIN_FAILURE_NONE,
+	LOGIN_FAILURE_ALREADY,
+	LOGIN_FAILURE_NOID,
+	LOGIN_FAILURE_WRONGPWD,
+	LOGIN_FAILURE_FULL,
+	LOGIN_FAILURE_SHUTDOWN,
+	LOGIN_FAILURE_REPAIR,
+	LOGIN_FAILURE_BLOCK,
+	LOGIN_FAILURE_WRONGMAT,
+	LOGIN_FAILURE_QUIT,
+	LOGIN_FAILURE_BESAMEKEY,
+	LOGIN_FAILURE_NOTAVAIL,
+	LOGIN_FAILURE_BLKLOGIN,
+	LOGIN_FAILURE_WEBBLK,
+	LOGIN_FAILURE_BADSCLID,
+	LOGIN_FAILURE_AGELIMIT,
+	LOGIN_FAILURE_CONFIRM,
+	LOGIN_FAILURE_INACTIVE,
+	LOGIN_FAILURE_UNMIGRATION,
+	LOGIN_FAILURE_MPROCESSING,
+	LOGIN_FAILURE_LOCKED,
+	LOGIN_FAILURE_BACKENDERR,
+	LOGIN_FAILURE_INTEGRTING,
+	LOGIN_FAILURE_COUNTRYERR,
+	LOGIN_FAILURE_IOVATION,
+	LOGIN_FAILURE_TNTERR,
+	LOGIN_FAILURE_SERVER_CLOSED,
+	LOGIN_FAILURE_SERVER_GRADE,
+};
+
+typedef struct packet_login_failure
+{
+	BYTE header;
+	char szStatus[ACCOUNT_STATUS_MAX_LEN + 1];
+} TPacketGCLoginFailure;
+
+typedef struct packet_create_failure
+{
+	BYTE header;
+	BYTE bType;
+} TPacketGCCreateFailure;
+
+enum
+{
+	ADD_CHARACTER_STATE_DEAD = (1 << 0),
+	ADD_CHARACTER_STATE_SPAWN = (1 << 1),
+	ADD_CHARACTER_STATE_GUNGON = (1 << 2),
+	ADD_CHARACTER_STATE_KILLER = (1 << 3),
+	ADD_CHARACTER_STATE_PARTY = (1 << 4),
+};
+
+enum ECharacterEquipmentPart
+{
+	CHR_EQUIPPART_ARMOR,
+	CHR_EQUIPPART_WEAPON,
+	CHR_EQUIPPART_HEAD,
+	CHR_EQUIPPART_HAIR,
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	CHR_EQUIPPART_ACCE,
+#endif
+	CHR_EQUIPPART_AURA,
+
+	CHR_EQUIPPART_NUM,
+};
+
+typedef struct packet_add_char
+{
+	BYTE header;
+	DWORD dwVID;
+
+#if defined(__WJ_SHOW_MOB_INFO__)
+	DWORD dwLevel;
+	DWORD dwAIFlag;
+#endif
+
+	float angle;
+	long x;
+	long y;
+	long z;
+
+	BYTE bType;
+	WORD wRaceNum;
+#if defined(__RACE_SWAP__)
+	DWORD dwEventRaceNum;
+#endif
+	BYTE bMovingSpeed;
+	BYTE bAttackSpeed;
+
+	BYTE bStateFlag;
+	DWORD dwAffectFlag[3]; // 효
+} TPacketGCCharacterAdd;
+
+typedef struct packet_char_additional_info
+{
+	BYTE header;
+	DWORD dwVID;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	DWORD adwPart[CHR_EQUIPPART_NUM];
+	BYTE bEmpire;
+	DWORD dwGuildID;
+	DWORD dwLevel;
+#if defined(__CONQUEROR_LEVEL__)
+	DWORD dwConquerorLevel;
+#endif
+	short sAlignment; // 치
+	BYTE bPKMode;
+	DWORD dwMountVnum;
+#if defined(__QUIVER_SYSTEM__)
+	DWORD dwArrow;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	WORD wRefineElementAffectType;
+#endif
+#if defined(__GUILD_LEADER_GRADE_NAME__)
+	BYTE bGuildLeaderGrade;
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+	BYTE	bCharacterSize;
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketGCCharacterAdditionalInfo;
+
+typedef struct packet_update_char
+{
+	BYTE header;
+	DWORD dwVID;
+
+	DWORD adwPart[CHR_EQUIPPART_NUM];
+
+	BYTE bMovingSpeed;
+	BYTE bAttackSpeed;
+
+	BYTE bStateFlag;
+	DWORD dwAffectFlag[3];
+
+	DWORD dwGuildID;
+	short sAlignment;
+	DWORD dwLevel;
+#if defined(__CONQUEROR_LEVEL__)
+	DWORD dwConquerorLevel;
+#endif
+	BYTE bPKMode;
+	DWORD dwMountVnum;
+#if defined(__QUIVER_SYSTEM__)
+	DWORD dwArrow;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	WORD wRefineElementAffectType;
+#endif
+#if defined(__GUILD_LEADER_GRADE_NAME__)
+	BYTE bGuildLeaderGrade;
+#endif
+#if defined(__LEFT_SEAT__)
+	bool bLeftSeat;
+#endif
+} TPacketGCCharacterUpdate;
+
+typedef struct packet_del_char
+{
+	BYTE header;
+	DWORD id;
+} TPacketGCCharacterDelete;
+
+typedef struct packet_chat //  킷
+{
+	BYTE header;
+	WORD size;
+	BYTE type;
+	DWORD id;
+	BYTE bEmpire;
+#if defined(__LOCALE_CLIENT__)
+	bool bCanFormat;
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+#if defined(__LOCALE_CLIENT__)
+	packet_chat() : bCanFormat(true) {}
+#endif
+} TPacketGCChat;
+
+typedef struct packet_whisper //  킷
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bType;
+	char szNameFrom[CHARACTER_NAME_MAX_LEN + 1];
+#if defined(__LOCALE_CLIENT__)
+	bool bCanFormat;
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+#if defined(__LOCALE_CLIENT__)
+	packet_whisper() : bCanFormat(true) {}
+#endif
+} TPacketGCWhisper;
+
+typedef struct packet_main_character
+{
+	BYTE header;
+	DWORD dwVID;
+	WORD wRaceNum;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	long lx, ly, lz;
+	BYTE empire;
+	BYTE skill_group;
+} TPacketGCMainCharacter;
+
+// SUPPORT_BGM
+typedef struct packet_main_character3_bgm
+{
+	enum
+	{
+		MUSIC_NAME_LEN = 24,
+	};
+
+	BYTE header;
+	DWORD dwVID;
+	WORD wRaceNum;
+	char szChrName[CHARACTER_NAME_MAX_LEN + 1];
+	char szBGMName[MUSIC_NAME_LEN + 1];
+	long lx, ly, lz;
+	BYTE empire;
+	BYTE skill_group;
+} TPacketGCMainCharacter3_BGM;
+
+typedef struct packet_main_character4_bgm_vol
+{
+	enum
+	{
+		MUSIC_NAME_LEN = 24,
+	};
+
+	BYTE header;
+	DWORD dwVID;
+	WORD wRaceNum;
+	char szChrName[CHARACTER_NAME_MAX_LEN + 1];
+	char szBGMName[MUSIC_NAME_LEN + 1];
+	float fBGMVol;
+	long lx, ly, lz;
+	BYTE empire;
+	BYTE skill_group;
+} TPacketGCMainCharacter4_BGM_VOL;
+// END_OF_SUPPORT_BGM
+
+typedef struct packet_points
+{
+	BYTE bHeader;
+	POINT_VALUE lPoints[POINT_MAX_NUM];
+} TPacketGCPoints;
+
+typedef struct packet_skill_level
+{
+	BYTE bHeader;
+	TPlayerSkill skills[SKILL_MAX_NUM];
+} TPacketGCSkillLevel;
+
+typedef struct packet_point_change
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	POINT_TYPE wType;
+	POINT_VALUE lAmount;
+	POINT_VALUE lValue;
+} TPacketGCPointChange;
+
+typedef struct packet_stun
+{
+	BYTE header;
+	DWORD vid;
+} TPacketGCStun;
+
+typedef struct packet_dead
+{
+	BYTE header;
+	DWORD vid;
+	BYTE dialog_type;
+	long map_index;
+	packet_dead() : dialog_type(DEAD_DIALOG_NORMAL), map_index(0) {}
+} TPacketGCDead;
+
+typedef struct packet_item_set_empty
+{
+	BYTE bHeader;
+	TItemPos Cell;
+	DWORD dwVnum;
+	DWORD dwCount;
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+} TPacketGCItemSetEmpty;
+
+typedef struct packet_item_set
+{
+	BYTE bHeader;
+	TItemPos Cell;
+	DWORD dwVnum;
+	DWORD dwCount;
+	DWORD dwFlags;
+	DWORD dwAntiFlags;
+	bool bHighLight;
+#if defined(__SOUL_BIND_SYSTEM__)
+	long lSealDate;
+#endif
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+} TPacketGCItemSet;
+
+typedef struct packet_item_del
+{
+	BYTE header;
+	BYTE pos;
+} TPacketGCItemDel;
+
+struct packet_item_use
+{
+	BYTE header;
+	TItemPos Cell;
+	DWORD ch_vid;
+	DWORD victim_vid;
+	DWORD vnum;
+};
+
+struct packet_item_move
+{
+	BYTE header;
+	TItemPos Cell;
+	TItemPos CellTo;
+};
+
+typedef struct packet_item_update
+{
+	BYTE bHeader;
+	TItemPos Cell;
+	DWORD dwCount;
+#if defined(__SOUL_BIND_SYSTEM__)
+	long lSealDate;
+#endif
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+} TPacketGCItemUpdate;
+
+typedef struct packet_item_ground_add
+{
+#if defined(__ITEM_DROP_RENEWAL__)
+	packet_item_ground_add()
+	{
+		memset(&alSockets, 0, sizeof(alSockets));
+		memset(&aAttrs, 0, sizeof(aAttrs));
+	}
+#endif
+
+	BYTE bHeader;
+	long lX, lY, lZ;
+	DWORD dwVID;
+	DWORD dwVnum;
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+
+#if defined(__ITEM_DROP_RENEWAL__)
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttrs[ITEM_ATTRIBUTE_MAX_NUM];
+#endif
+} TPacketGCItemGroundAdd;
+
+typedef struct packet_item_ownership
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGCItemOwnership;
+
+typedef struct packet_item_ground_del
+{
+	BYTE bHeader;
+	DWORD dwVID;
+} TPacketGCItemGroundDel;
+
+struct packet_quickslot_add
+{
+	BYTE header;
+	BYTE pos;
+	TQuickslot slot;
+};
+
+struct packet_quickslot_del
+{
+	BYTE header;
+	BYTE pos;
+};
+
+struct packet_quickslot_swap
+{
+	BYTE header;
+	BYTE pos;
+	BYTE pos_to;
+};
+
+struct packet_motion
+{
+	BYTE header;
+	DWORD vid;
+	DWORD victim_vid;
+	WORD motion;
+};
+
+enum EPacketShopSubHeaders
+{
+	SHOP_SUBHEADER_GC_NONE,
+	SHOP_SUBHEADER_GC_START,
+	SHOP_SUBHEADER_GC_END,
+	SHOP_SUBHEADER_GC_UPDATE_ITEM,
+	SHOP_SUBHEADER_GC_UPDATE_PRICE,
+	SHOP_SUBHEADER_GC_OK,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY,
+	SHOP_SUBHEADER_GC_SOLDOUT,
+	SHOP_SUBHEADER_GC_INVENTORY_FULL,
+	SHOP_SUBHEADER_GC_INVALID_POS,
+	SHOP_SUBHEADER_GC_SOLD_OUT,
+	SHOP_SUBHEADER_GC_START_EX,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY_EX,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_BP,
+	SHOP_SUBHEADER_GC_EXCEED_LIMIT_TODAY,
+#if defined(__MYSHOP_DECO__)
+	SHOP_SUBHEADER_GC_MYPRIV_SHOP_OPEN,
+#endif
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_10TH_COIN,
+	SHOP_SUBHEADER_GC_LIMITED_PURCHASE_OVER,
+	SHOP_SUBHEADER_GC_LIMITED_DATA_LOADING,
+	SHOP_SUBHEADER_GC_UNK_19,
+	SHOP_SUBHEADER_GC_UNK_20,
+	SHOP_SUBHEADER_GC_UNK_21,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_MEDAL_OF_HONOR,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_GUILD_LEVEL,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_BNW,
+#if defined(__SHOPEX_RENEWAL__)
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_ITEM,
+#endif
+};
+
+struct packet_shop_item
+{
+	DWORD dwVnum;
+	DWORD dwCount;
+	DWORD dwPrice;
+#if defined(__CHEQUE_SYSTEM__)
+	DWORD dwCheque;
+#endif
+	BYTE bDisplayPos;
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+#if defined(__SHOPEX_RENEWAL__)
+	BYTE bPriceType;
+	DWORD dwPriceVnum;
+#endif
+	packet_shop_item()
+	{
+#if defined(__CHEQUE_SYSTEM__)
+		dwCheque = 0;
+#endif
+		memset(&alSockets, 0, sizeof(alSockets));
+		memset(&aAttr, 0, sizeof(aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		dwTransmutationVnum = 0;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		memset(&RefineElement, 0, sizeof(RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+		memset(&aApplyRandom, 0, sizeof(aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+		bSetValue = 0;
+#endif
+#if defined(__SHOPEX_RENEWAL__)
+		bPriceType = SHOP_COIN_TYPE_GOLD;
+		dwPriceVnum = 0;
+#endif
+	}
+};
+
+typedef struct packet_shop_start
+{
+	DWORD owner_vid;
+#if defined(__MYSHOP_DECO__)
+	BYTE shop_tab_count;
+#endif
+#if defined(__MYSHOP_EXPANSION__)
+	struct packet_shop_item items[SHOP_HOST_ITEM_MAX];
+#else
+	struct packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
+#endif
+} TPacketGCShopStart;
+
+typedef struct packet_shop_start_ex //  TSubPacketShopTab* shop_tabs  .
+{
+	typedef struct sub_packet_shop_tab
+	{
+		char name[SHOP_TAB_NAME_MAX];
+		BYTE coin_type;
+		packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
+	} TSubPacketShopTab;
+	DWORD owner_vid;
+	BYTE shop_tab_count;
+} TPacketGCShopStartEx;
+
+typedef struct packet_shop_update_item
+{
+	BYTE pos;
+	struct packet_shop_item item;
+} TPacketGCShopUpdateItem;
+
+typedef struct packet_shop_update_price
+{
+	int iPrice;
+#if defined(__CHEQUE_SYSTEM__)
+	int iCheque;
+#endif
+} TPacketGCShopUpdatePrice;
+
+typedef struct packet_shop //  킷
+{
+	BYTE header;
+	WORD size;
+	BYTE subheader;
+} TPacketGCShop;
+
+typedef struct packet_exchange
+{
+	BYTE header;
+	BYTE sub_header;
+	BYTE is_me;
+	DWORD arg1; // vnum
+	TItemPos arg2; // cell
+	DWORD arg3; // count
+	TItemPos arg4;
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetItem;
+#endif
+} TPacketGCExchange;
+
+enum EPacketTradeSubHeaders
+{
+	EXCHANGE_SUBHEADER_GC_START, /* arg1 == vid */
+	EXCHANGE_SUBHEADER_GC_ITEM_ADD, /* arg1 == vnum arg2 == pos arg3 == count */
+	EXCHANGE_SUBHEADER_GC_ITEM_DEL,
+	EXCHANGE_SUBHEADER_GC_GOLD_ADD, /* arg1 == gold */
+#if defined(__CHEQUE_SYSTEM__)
+	EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, /* arg1 == cheque */
+#endif
+	EXCHANGE_SUBHEADER_GC_ACCEPT, /* arg1 == accept */
+	EXCHANGE_SUBHEADER_GC_END, /* arg1 == not used */
+	EXCHANGE_SUBHEADER_GC_ALREADY, /* arg1 == not used */
+	EXCHANGE_SUBHEADER_GC_LESS_GOLD, /* arg1 == not used */
+#if defined(__CHEQUE_SYSTEM__)
+	EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, /* arg1 == not used */
+#endif
+};
+
+struct packet_position
+{
+	BYTE header;
+	DWORD vid;
+	BYTE position;
+};
+
+typedef struct packet_ping
+{
+	BYTE header;
+} TPacketGCPing;
+
+struct packet_script
+{
+	BYTE header;
+	WORD size;
+	BYTE skin;
+	WORD src_size;
+};
+
+typedef struct packet_change_speed
+{
+	BYTE header;
+	DWORD vid;
+	WORD moving_speed;
+} TPacketGCChangeSpeed;
+
+struct packet_mount
+{
+	BYTE header;
+	DWORD vid;
+	DWORD mount_vid;
+	BYTE pos;
+	DWORD x, y;
+};
+
+typedef struct packet_move
+{
+	BYTE bHeader;
+	BYTE bFunc;
+	BYTE bArg;
+	BYTE bRot;
+	DWORD dwVID;
+	long lX;
+	long lY;
+	DWORD dwTime;
+	DWORD dwDuration;
+} TPacketGCMove;
+
+// 
+typedef struct packet_ownership
+{
+	BYTE bHeader;
+	DWORD dwOwnerVID;
+	DWORD dwVictimVID;
+} TPacketGCOwnership;
+
+// 치 화 킷 bCount 큼 募 
+typedef struct packet_sync_position_element
+{
+	DWORD dwVID;
+	long lX;
+	long lY;
+} TPacketGCSyncPositionElement;
+
+// 치 화
+typedef struct packet_sync_position //  킷
+{
+	BYTE bHeader;
+	WORD wSize; //  = (wSize - sizeof(TPacketGCSyncPosition)) / sizeof(TPacketGCSyncPositionElement) 
+} TPacketGCSyncPosition;
+
+typedef struct packet_fly
+{
+	BYTE bHeader;
+	BYTE bType;
+	DWORD dwStartVID;
+	DWORD dwEndVID;
+} TPacketGCCreateFly;
+
+typedef struct command_fly_targeting
+{
+	BYTE bHeader;
+	DWORD dwTargetVID;
+	long x, y;
+} TPacketCGFlyTargeting;
+
+typedef struct packet_fly_targeting
+{
+	BYTE bHeader;
+	DWORD dwShooterVID;
+	DWORD dwTargetVID;
+	long x, y;
+} TPacketGCFlyTargeting;
+
+typedef struct packet_shoot
+{
+	BYTE bHeader;
+	BYTE bType;
+} TPacketCGShoot;
+
+typedef struct packet_duel_start
+{
+	BYTE header;
+	WORD wSize; // DWORD 載?  = (wSize - sizeof(TPacketGCPVPList)) / 4
+} TPacketGCDuelStart;
+
+enum EPVPModes
+{
+	PVP_MODE_NONE,
+	PVP_MODE_AGREE,
+	PVP_MODE_FIGHT,
+	PVP_MODE_REVENGE
+};
+
+typedef struct packet_pvp
+{
+	BYTE bHeader;
+	DWORD dwVIDSrc;
+	DWORD dwVIDDst;
+	BYTE bMode; // 0 見 , 1見 
+} TPacketGCPVP;
+
+typedef struct command_use_skill
+{
+	BYTE bHeader;
+	DWORD dwVnum;
+	DWORD dwVID;
+} TPacketCGUseSkill;
+
+typedef struct command_target
+{
+	BYTE header;
+	DWORD dwVID;
+} TPacketCGTarget;
+
+typedef struct packet_target
+{
+	BYTE header;
+	DWORD dwVID;
+	BYTE bHPPercent;
+#if defined(__VIEW_TARGET_HP__) || defined(__DEFENSE_WAVE__)
+	int iMinHP;
+	int iMaxHP;
+	bool bAlliance;
+#endif
+#if defined(__ELEMENT_SYSTEM__)
+	BYTE bElement[MOB_ELEMENT_MAX_NUM];
+#endif
+	packet_target() : dwVID(0), bHPPercent(0)
+	{
+#if defined(__VIEW_TARGET_HP__) || defined(__DEFENSE_WAVE__)
+		iMinHP = 0;
+		iMaxHP = 0;
+		bAlliance = false;
+#endif
+#if defined(__ELEMENT_SYSTEM__)
+		memset(&bElement, 0, sizeof(bElement));
+#endif
+	}
+} TPacketGCTarget;
+
+#if defined(__SEND_TARGET_INFO__)
+typedef struct SPacketGCTargetDropInfo
+{
+	DWORD dwVnum;
+	BYTE bCount;
+} TPacketGCTargetDropInfo;
+
+typedef struct SPacketGCTargetInfo
+{
+	BYTE bHeader;
+	WORD wSize;
+	DWORD dwRaceVnum;
+	DWORD dwVID;
+	bool bDropMetinStone;
+} TPacketGCTargetInfo;
+
+typedef struct SPacketCGTargetInfo
+{
+	BYTE bHeader;
+	DWORD dwVID;
+} TPacketCGTargetInfo;
+#endif
+
+typedef struct packet_warp
+{
+	BYTE bHeader;
+	long lX;
+	long lY;
+	long lAddr;
+	WORD wPort;
+} TPacketGCWarp;
+
+typedef struct command_warp
+{
+	BYTE bHeader;
+} TPacketCGWarp;
+
+struct packet_quest_info
+{
+	BYTE header;
+	WORD size;
+	WORD index;
+#if defined(__QUEST_RENEWAL__)
+	BYTE type;
+	bool is_confirmed;
+#endif
+	BYTE flag;
+};
+
+typedef struct command_safebox_checkout
+{
+	BYTE bHeader;
+	BYTE bSafePos;
+	TItemPos ItemPos;
+} TPacketCGSafeboxCheckout;
+
+typedef struct command_safebox_checkin
+{
+	BYTE bHeader;
+	BYTE bSafePos;
+	TItemPos ItemPos;
+} TPacketCGSafeboxCheckin;
+
+///////////////////////////////////////////////////////////////////////////////////
+// Messenger
+
+enum EMessengerConnectedState
+{
+	MESSENGER_CONNECTED_STATE_OFFLINE,
+	MESSENGER_CONNECTED_STATE_ONLINE
+};
+
+enum EGCMessengerSubHeader
+{
+	MESSENGER_SUBHEADER_GC_LIST,
+	MESSENGER_SUBHEADER_GC_LOGIN,
+	MESSENGER_SUBHEADER_GC_LOGOUT,
+	MESSENGER_SUBHEADER_GC_INVITE,
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	MESSENGER_SUBHEADER_GC_BLOCK_LIST,
+	MESSENGER_SUBHEADER_GC_BLOCK_LOGIN,
+	MESSENGER_SUBHEADER_GC_BLOCK_LOGOUT,
+#endif
+#if defined(__MESSENGER_GM__)
+	MESSENGER_SUBHEADER_GC_GM_LIST,
+	MESSENGER_SUBHEADER_GC_GM_LOGIN,
+	MESSENGER_SUBHEADER_GC_GM_LOGOUT,
+#endif
+};
+
+typedef struct packet_messenger
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMessenger;
+
+typedef struct packet_messenger_list
+{
+	packet_messenger_list() :
+		bConnected(MESSENGER_CONNECTED_STATE_OFFLINE)
+#if defined(__MESSENGER_DETAILS__)
+		, dwLastPlayTime(0)
+#endif
+	{
+	}
+	BYTE bConnected;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+#if defined(__MESSENGER_DETAILS__)
+	DWORD dwLastPlayTime;
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1]{};
+#endif
+#endif
+} TPacketGCMessengerList;
+
+enum ECGMessengerSubHeader
+{
+	MESSENGER_SUBHEADER_CG_ADD_BY_VID,
+	MESSENGER_SUBHEADER_CG_ADD_BY_NAME,
+	MESSENGER_SUBHEADER_CG_REMOVE,
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID,
+	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME,
+	MESSENGER_SUBHEADER_CG_BLOCK_REMOVE,
+#endif
+};
+
+typedef struct command_messenger
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+} TPacketCGMessenger;
+
+typedef struct command_messenger_add_by_vid
+{
+	DWORD dwVID;
+} TPacketCGMessengerAddByVID;
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+typedef struct command_messenger_add_block_by_vid
+{
+	DWORD dwVID;
+} TPacketCGMessengerAddBlockByVID;
+#endif
+
+///////////////////////////////////////////////////////////////////////////////////
+// Party
+typedef struct command_party_parameter
+{
+	BYTE bHeader;
+	BYTE bDistributeMode;
+} TPacketCGPartyParameter;
+
+typedef struct paryt_parameter
+{
+	BYTE bHeader;
+	BYTE bDistributeMode;
+} TPacketGCPartyParameter;
+
+typedef struct packet_party_add
+{
+	BYTE header;
+	DWORD pid;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	long mapIdx;
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+	BYTE channel;
+#endif
+} TPacketGCPartyAdd;
+
+typedef struct command_party_invite
+{
+	BYTE header;
+	DWORD vid;
+} TPacketCGPartyInvite;
+
+typedef struct packet_party_invite
+{
+	BYTE header;
+	DWORD leader_vid;
+} TPacketGCPartyInvite;
+
+typedef struct command_party_invite_answer
+{
+	BYTE header;
+	DWORD leader_vid;
+	BYTE accept;
+} TPacketCGPartyInviteAnswer;
+
+typedef struct packet_party_update
+{
+	BYTE header;
+	DWORD pid;
+	BYTE role;
+	BYTE percent_hp;
+	short affects[7];
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	long x;
+	long y;
+#endif
+} TPacketGCPartyUpdate;
+
+typedef struct packet_party_remove
+{
+	BYTE header;
+	DWORD pid;
+} TPacketGCPartyRemove;
+
+typedef struct packet_party_link
+{
+	BYTE header;
+	DWORD pid;
+	DWORD vid;
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	long mapIdx;
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+	BYTE channel;
+#endif
+} TPacketGCPartyLink;
+
+typedef struct command_party_remove
+{
+	BYTE header;
+	DWORD pid;
+} TPacketCGPartyRemove;
+
+typedef struct command_party_set_state
+{
+	BYTE header;
+	DWORD pid;
+	BYTE byRole;
+	BYTE flag;
+} TPacketCGPartySetState;
+
+enum
+{
+	PARTY_SKILL_HEAL = 1,
+	PARTY_SKILL_WARP = 2
+};
+
+typedef struct command_party_use_skill
+{
+	BYTE header;
+	BYTE bySkillIndex;
+	DWORD vid;
+} TPacketCGPartyUseSkill;
+
+typedef struct packet_safebox_size
+{
+	BYTE bHeader;
+	BYTE bSize;
+} TPacketCGSafeboxSize;
+
+typedef struct packet_safebox_wrong_password
+{
+	BYTE bHeader;
+} TPacketCGSafeboxWrongPassword;
+
+typedef struct command_empire
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+} TPacketCGEmpire;
+
+typedef struct packet_empire
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+} TPacketGCEmpire;
+
+enum
+{
+	SAFEBOX_MONEY_STATE_SAVE,
+	SAFEBOX_MONEY_STATE_WITHDRAW,
+};
+
+typedef struct command_safebox_money
+{
+	BYTE bHeader;
+	BYTE bState;
+	long lMoney;
+} TPacketCGSafeboxMoney;
+
+typedef struct packet_safebox_money_change
+{
+	BYTE bHeader;
+	long lMoney;
+} TPacketGCSafeboxMoneyChange;
+
+// Guild
+enum
+{
+	GUILD_SUBHEADER_GC_LOGIN,
+	GUILD_SUBHEADER_GC_LOGOUT,
+	GUILD_SUBHEADER_GC_LIST,
+	GUILD_SUBHEADER_GC_GRADE,
+	GUILD_SUBHEADER_GC_ADD,
+	GUILD_SUBHEADER_GC_REMOVE,
+	GUILD_SUBHEADER_GC_GRADE_NAME,
+	GUILD_SUBHEADER_GC_GRADE_AUTH,
+	GUILD_SUBHEADER_GC_INFO,
+	GUILD_SUBHEADER_GC_COMMENTS,
+	GUILD_SUBHEADER_GC_CHANGE_EXP,
+	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GRADE,
+	GUILD_SUBHEADER_GC_SKILL_INFO,
+	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GENERAL,
+	GUILD_SUBHEADER_GC_GUILD_INVITE,
+	GUILD_SUBHEADER_GC_WAR,
+	GUILD_SUBHEADER_GC_GUILD_NAME,
+	GUILD_SUBHEADER_GC_GUILD_WAR_LIST,
+	GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST,
+	GUILD_SUBHEADER_GC_WAR_SCORE,
+	GUILD_SUBHEADER_GC_MONEY_CHANGE,
+};
+
+enum GUILD_SUBHEADER_CG
+{
+	GUILD_SUBHEADER_CG_ADD_MEMBER,
+	GUILD_SUBHEADER_CG_REMOVE_MEMBER,
+	GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME,
+	GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY,
+	GUILD_SUBHEADER_CG_OFFER,
+	GUILD_SUBHEADER_CG_POST_COMMENT,
+	GUILD_SUBHEADER_CG_DELETE_COMMENT,
+	GUILD_SUBHEADER_CG_REFRESH_COMMENT,
+	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE,
+	GUILD_SUBHEADER_CG_USE_SKILL,
+	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL,
+	GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER,
+	GUILD_SUBHEADER_CG_CHARGE_GSP,
+	GUILD_SUBHEADER_CG_DEPOSIT_MONEY,
+	GUILD_SUBHEADER_CG_WITHDRAW_MONEY,
+};
+
+typedef struct packet_guild
+{
+	BYTE header;
+	WORD size;
+	BYTE subheader;
+} TPacketGCGuild;
+
+typedef struct packet_guild_name_t
+{
+	BYTE header;
+	WORD size;
+	BYTE subheader;
+	DWORD guildID;
+	char guildName[GUILD_NAME_MAX_LEN];
+} TPacketGCGuildName;
+
+typedef struct packet_guild_war
+{
+	DWORD dwGuildSelf;
+	DWORD dwGuildOpp;
+	BYTE bType;
+	BYTE bWarState;
+} TPacketGCGuildWar;
+
+typedef struct command_guild
+{
+	BYTE header;
+	BYTE subheader;
+} TPacketCGGuild;
+
+typedef struct command_guild_answer_make_guild
+{
+	BYTE header;
+	char guild_name[GUILD_NAME_MAX_LEN + 1];
+} TPacketCGAnswerMakeGuild;
+
+typedef struct command_guild_use_skill
+{
+	DWORD dwVnum;
+	DWORD dwPID;
+} TPacketCGGuildUseSkill;
+
+// Guild Mark
+typedef struct command_mark_login
+{
+	BYTE header;
+	DWORD handle;
+	DWORD random_key;
+} TPacketCGMarkLogin;
+
+typedef struct command_mark_upload
+{
+	BYTE header;
+	DWORD gid;
+	BYTE image[16 * 12 * 4];
+} TPacketCGMarkUpload;
+
+typedef struct command_mark_idxlist
+{
+	BYTE header;
+} TPacketCGMarkIDXList;
+
+typedef struct command_mark_crclist
+{
+	BYTE header;
+	BYTE imgIdx;
+	DWORD crclist[80];
+} TPacketCGMarkCRCList;
+
+typedef struct packet_mark_idxlist
+{
+	BYTE header;
+	DWORD bufSize;
+	WORD count;
+	// 悶 size * (WORD + WORD)큼  
+} TPacketGCMarkIDXList;
+
+typedef struct packet_mark_block
+{
+	BYTE header;
+	DWORD bufSize;
+	BYTE imgIdx;
+	DWORD count;
+	// 悶 64 x 48 x 횝크(4트) = 12288큼  
+} TPacketGCMarkBlock;
+
+typedef struct command_symbol_upload
+{
+	BYTE header;
+	WORD size;
+	DWORD guild_id;
+} TPacketCGGuildSymbolUpload;
+
+typedef struct command_symbol_crc
+{
+	BYTE header;
+	DWORD guild_id;
+	DWORD crc;
+	DWORD size;
+} TPacketCGSymbolCRC;
+
+typedef struct packet_symbol_data
+{
+	BYTE header;
+	WORD size;
+	DWORD guild_id;
+} TPacketGCGuildSymbolData;
+
+// Fishing
+typedef struct command_fishing
+{
+	BYTE header;
+	BYTE dir;
+} TPacketCGFishing;
+
+typedef struct packet_fishing
+{
+	BYTE header;
+	BYTE subheader;
+	DWORD info;
+	BYTE dir;
+} TPacketGCFishing;
+
+enum
+{
+	FISHING_SUBHEADER_GC_START,
+	FISHING_SUBHEADER_GC_STOP,
+	FISHING_SUBHEADER_GC_REACT,
+	FISHING_SUBHEADER_GC_SUCCESS,
+	FISHING_SUBHEADER_GC_FAIL,
+	FISHING_SUBHEADER_GC_FISH,
+};
+
+#if defined(__FISHING_GAME__)
+enum EFishingGameSubHeader
+{
+	FISHING_GAME_SUBHEADER_OPEN,
+	FISHING_GAME_SUBHEADER_GOAL,
+	FISHING_GAME_SUBHEADER_QUIT,
+};
+
+enum EFishingGameMisc
+{
+	FISHING_GAME_DURATION = 15,
+};
+
+typedef struct SPacketGCFishingGame
+{
+	SPacketGCFishingGame(const BYTE bSubHeader, const BYTE bLevel = 0) :
+		bHeader(HEADER_GC_FISHING_GAME),
+		bSubHeader(bSubHeader),
+		bLevel(bLevel)
+	{}
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bLevel;
+} TPacketGCFishingGame;
+
+typedef struct SPacketCGFishingGame
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bGoals;
+} TPacketCGFishingGame;
+#endif
+
+typedef struct command_give_item
+{
+	BYTE byHeader;
+	DWORD dwTargetVID;
+	TItemPos ItemPos;
+	WORD wItemCount;
+} TPacketCGGiveItem;
+
+typedef struct SPacketCGHack
+{
+	BYTE bHeader;
+	char szBuf[255 + 1];
+} TPacketCGHack;
+
+// SubHeader - Dungeon
+enum
+{
+	DUNGEON_SUBHEADER_GC_TIME_ATTACK_START = 0,
+	DUNGEON_SUBHEADER_GC_DESTINATION_POSITION = 1,
+};
+
+typedef struct packet_dungeon
+{
+	BYTE bHeader;
+	WORD size;
+	BYTE subheader;
+} TPacketGCDungeon;
+
+typedef struct packet_dungeon_dest_position
+{
+	long x;
+	long y;
+} TPacketGCDungeonDestPosition;
+
+typedef struct SPacketGCShopSign
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	char szSign[SHOP_SIGN_MAX_LEN + 1];
+#if defined(__MYSHOP_DECO__)
+	BYTE bType;
+#endif
+} TPacketGCShopSign;
+
+typedef struct SPacketCGMyShop
+{
+	BYTE bHeader;
+	char szSign[SHOP_SIGN_MAX_LEN + 1];
+	BYTE bCount; // Count of TShopItemTable
+} TPacketCGMyShop;
+
+#if defined(__MYSHOP_DECO__)
+typedef struct SPacketGCMyPrivShopOpen
+{
+	BYTE bHeader;
+	bool bCashItem;
+	BYTE bTabCount;
+} TPacketGCMyPrivShopOpen;
+
+typedef struct SPacketCGMyShopDecoState
+{
+	BYTE bHeader;
+	BYTE bState;
+} TPacketCGMyShopDecoState;
+
+typedef struct SPacketCGMyShopDecoAdd
+{
+	BYTE bHeader;
+	BYTE bType;
+	DWORD dwPolyVnum;
+} TPacketCGMyShopDecoAdd;
+#endif
+
+typedef struct SPacketGCTime
+{
+	BYTE bHeader;
+	time_t time;
+} TPacketGCTime;
+
+enum
+{
+	WALKMODE_RUN,
+	WALKMODE_WALK,
+};
+
+typedef struct SPacketGCWalkMode
+{
+	BYTE header;
+	DWORD vid;
+	BYTE mode;
+} TPacketGCWalkMode;
+
+typedef struct SPacketGCChangeSkillGroup
+{
+	BYTE header;
+	BYTE skill_group;
+} TPacketGCChangeSkillGroup;
+
+typedef struct SPacketCGRefine
+{
+	BYTE header;
+	BYTE pos;
+	BYTE type;
+} TPacketCGRefine;
+
+typedef struct SPacketCGRequestRefineInfo
+{
+	BYTE header;
+	BYTE pos;
+} TPacketCGRequestRefineInfo;
+
+typedef struct SPacketGCRefineInformaion
+{
+	BYTE header;
+	BYTE type;
+	BYTE pos;
+	DWORD src_vnum;
+	DWORD result_vnum;
+	WORD material_count;
+	int cost; // 奴 
+	int prob; // 확
+	TRefineMaterial materials[REFINE_MATERIAL_MAX_NUM];
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+} TPacketGCRefineInformation;
+
+struct TNPCPosition
+{
+	BYTE bType;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	long x;
+	long y;
+};
+
+typedef struct SPacketGCNPCPosition
+{
+	BYTE header;
+	WORD size;
+	WORD count;
+	// array of TNPCPosition
+} TPacketGCNPCPosition;
+
+enum ESpecialEffectType
+{
+	SE_TYPE_NORMAL,
+	SE_TYPE_POSITION,
+};
+
+typedef struct SPacketGCSpecialEffect
+{
+	BYTE bHeader;
+	BYTE bEffectNum;
+	DWORD dwVID;
+	BYTE bEffectType;
+	long xEffectPos, yEffectPos;
+	SPacketGCSpecialEffect()
+		: bEffectType(SE_TYPE_NORMAL)
+		, xEffectPos(0)
+		, yEffectPos(0)
+	{}
+} TPacketGCSpecialEffect;
+
+typedef struct SPacketCGChangeName
+{
+	BYTE header;
+	BYTE index;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketCGChangeName;
+
+typedef struct SPacketGCChangeName
+{
+	BYTE header;
+	DWORD pid;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGCChangeName;
+
+typedef struct command_client_version
+{
+	BYTE header;
+	char filename[32 + 1];
+	char timestamp[32 + 1];
+} TPacketCGClientVersion;
+
+typedef struct command_client_version2
+{
+	BYTE header;
+	char filename[32 + 1];
+	char timestamp[32 + 1];
+} TPacketCGClientVersion2;
+
+typedef struct packet_channel
+{
+	BYTE header;
+	BYTE channel;
+} TPacketGCChannel;
+
+typedef struct SEquipmentItemSet
+{
+	DWORD dwVnum;
+	BYTE bCount;
+	long alSockets[ITEM_SOCKET_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+#endif
+#if defined(__SET_ITEM__)
+	BYTE bSetValue;
+#endif
+} TEquipmentItemSet;
+
+typedef struct pakcet_view_equip
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	TEquipmentItemSet Equips[WEAR_MAX_NUM];
+} TPacketGCViewEquip;
+
+typedef struct
+{
+	DWORD dwID;
+	long x, y;
+	long width, height;
+	DWORD dwGuildID;
+} TLandPacketElement;
+
+typedef struct packet_land_list
+{
+	BYTE header;
+	WORD size;
+} TPacketGCLandList;
+
+typedef struct
+{
+	BYTE bHeader;
+	long lID;
+	char szName[32 + 1];
+	DWORD dwVID;
+	BYTE bType;
+} TPacketGCTargetCreate;
+
+typedef struct
+{
+	BYTE bHeader;
+	long lID;
+	long lX, lY;
+} TPacketGCTargetUpdate;
+
+typedef struct
+{
+	BYTE bHeader;
+	long lID;
+} TPacketGCTargetDelete;
+
+typedef struct
+{
+	BYTE bHeader;
+	TPacketAffectElement elem;
+} TPacketGCAffectAdd;
+
+typedef struct
+{
+	BYTE bHeader;
+	DWORD dwType;
+	POINT_TYPE wApplyOn;
+} TPacketGCAffectRemove;
+
+typedef struct packet_lover_info
+{
+	BYTE header;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	BYTE love_point;
+} TPacketGCLoverInfo;
+
+typedef struct packet_love_point_update
+{
+	BYTE header;
+	BYTE love_point;
+} TPacketGCLovePointUpdate;
+
+// MINING
+typedef struct packet_dig_motion
+{
+	BYTE header;
+	DWORD vid;
+	DWORD target_vid;
+	BYTE count;
+} TPacketGCDigMotion;
+// END_OF_MINING
+
+// SCRIPT_SELECT_ITEM
+typedef struct command_script_select_item
+{
+	BYTE header;
+	DWORD selection;
+} TPacketCGScriptSelectItem;
+// END_OF_SCRIPT_SELECT_ITEM
+
+#if defined(__GEM_SHOP__)
+typedef struct command_select_item_ex
+{
+	BYTE bHeader;
+	DWORD dwItemPos;
+	BYTE bType;
+} TPacketCGSelectItemEx;
+#endif
+
+typedef struct packet_damage_info
+{
+	BYTE header;
+	DWORD dwVID;
+	BYTE flag;
+	int damage;
+} TPacketGCDamageInfo;
+
+typedef struct tag_GGSiege
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+	BYTE bTowerCount;
+} TPacketGGSiege;
+
+typedef struct SPacketGGMonarchTransfer
+{
+	BYTE bHeader;
+	DWORD dwTargetPID;
+	long x;
+	long y;
+} TPacketMonarchGGTransfer;
+
+typedef struct SPacketGGPCBangUpdate
+{
+	BYTE bHeader;
+	unsigned long ulPCBangID;
+} TPacketPCBangUpdate;
+
+typedef struct SPacketGGCheckAwakeness
+{
+	BYTE bHeader;
+} TPacketGGCheckAwakeness;
+
+typedef struct SPacketGCPanamaPack
+{
+	BYTE bHeader;
+	char szPackName[256];
+	BYTE abIV[32];
+} TPacketGCPanamaPack;
+
+// TODO : 틸 짱..킷  騁틉究 斂 킷 湄冗 Refactoring . 
+typedef struct SPacketGCHybridCryptKeys
+{
+	SPacketGCHybridCryptKeys() : m_pStream(NULL) {}
+	~SPacketGCHybridCryptKeys()
+	{
+		// GCC  NULL delete 巒 ? 求 構 NULL 체크 . ( 姆 隔 C++ 표瞞틈耉 --a )
+		if (m_pStream)
+		{
+			delete[] m_pStream;
+			m_pStream = NULL;
+		}
+	}
+
+	DWORD GetStreamSize()
+	{
+		return sizeof(bHeader) + sizeof(WORD) + sizeof(int) + KeyStreamLen;
+	}
+
+	BYTE* GetStreamData()
+	{
+		if (m_pStream)
+			delete[] m_pStream;
+
+		uDynamicPacketSize = (WORD)GetStreamSize();
+
+		m_pStream = new BYTE[uDynamicPacketSize];
+
+		memcpy(m_pStream, &bHeader, 1);
+		memcpy(m_pStream + 1, &uDynamicPacketSize, 2);
+		memcpy(m_pStream + 3, &KeyStreamLen, 4);
+
+		if (KeyStreamLen > 0)
+			memcpy(m_pStream + 7, pDataKeyStream, KeyStreamLen);
+
+		return m_pStream;
+	}
+
+	BYTE bHeader;
+	WORD uDynamicPacketSize; //  클 DynamicPacketHeader  磯 -_-;
+	int KeyStreamLen;
+	BYTE* pDataKeyStream;
+
+private:
+	BYTE* m_pStream;
+
+} TPacketGCHybridCryptKeys;
+
+typedef struct SPacketGCPackageSDB
+{
+	SPacketGCPackageSDB() : m_pDataSDBStream(NULL), m_pStream(NULL) {}
+	~SPacketGCPackageSDB()
+	{
+		if (m_pStream)
+		{
+			delete[] m_pStream;
+			m_pStream = NULL;
+		}
+	}
+
+	DWORD GetStreamSize()
+	{
+		return sizeof(bHeader) + sizeof(WORD) + sizeof(int) + iStreamLen;
+	}
+
+	BYTE* GetStreamData()
+	{
+		if (m_pStream)
+			delete[] m_pStream;
+
+		uDynamicPacketSize = static_cast<WORD>(GetStreamSize());
+
+		m_pStream = new BYTE[uDynamicPacketSize];
+
+		memcpy(m_pStream, &bHeader, 1);
+		memcpy(m_pStream + 1, &uDynamicPacketSize, 2);
+		memcpy(m_pStream + 3, &iStreamLen, 4);
+
+		if (iStreamLen > 0)
+			memcpy(m_pStream + 7, m_pDataSDBStream, iStreamLen);
+
+		return m_pStream;
+	}
+
+	BYTE bHeader;
+	WORD uDynamicPacketSize; //  클 DynamicPacketHeader  磯 -_-;
+	int iStreamLen;
+	BYTE* m_pDataSDBStream;
+
+private:
+	BYTE* m_pStream;
+
+} TPacketGCPackageSDB;
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+struct TPacketKeyAgreement
+{
+	static const int MAX_DATA_LEN = 256;
+	BYTE bHeader;
+	WORD wAgreedLength;
+	WORD wDataLength;
+	BYTE data[MAX_DATA_LEN];
+};
+
+struct TPacketKeyAgreementCompleted
+{
+	BYTE bHeader;
+	BYTE data[3]; // dummy (not used)
+};
+#endif
+
+#define MAX_EFFECT_FILE_NAME 128
+typedef struct SPacketGCSpecificEffect
+{
+	BYTE header;
+	DWORD vid;
+	char effect_file[MAX_EFFECT_FILE_NAME];
+} TPacketGCSpecificEffect;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+// 혼
+enum EDragonSoulRefineWindowRefineType
+{
+	DragonSoulRefineWindow_UPGRADE,
+	DragonSoulRefineWindow_IMPROVEMENT,
+	DragonSoulRefineWindow_REFINE,
+};
+
+enum EPacketCGDragonSoulSubHeaderType
+{
+	DS_SUB_HEADER_OPEN,
+	DS_SUB_HEADER_CLOSE,
+	DS_SUB_HEADER_DO_REFINE_GRADE,
+	DS_SUB_HEADER_DO_REFINE_STEP,
+	DS_SUB_HEADER_DO_REFINE_STRENGTH,
+	DS_SUB_HEADER_REFINE_FAIL,
+	DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE,
+	DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL,
+	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY,
+	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL,
+	DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL,
+	DS_SUB_HEADER_REFINE_SUCCEED,
+#if defined(__DS_CHANGE_ATTR__)
+	DS_SUB_HEADER_OPEN_CHANGE_ATTR,
+	DS_SUB_HEADER_DO_CHANGE_ATTR,
+#endif
+};
+
+typedef struct SPacketCGDragonSoulRefine
+{
+	SPacketCGDragonSoulRefine() : header(HEADER_CG_DRAGON_SOUL_REFINE)
+	{}
+	BYTE header;
+	BYTE bSubType;
+	TItemPos ItemGrid[DRAGON_SOUL_REFINE_GRID_SIZE];
+} TPacketCGDragonSoulRefine;
+
+typedef struct SPacketGCDragonSoulRefine
+{
+	SPacketGCDragonSoulRefine() : header(HEADER_GC_DRAGON_SOUL_REFINE)
+	{}
+	BYTE header;
+	BYTE bSubType;
+	TItemPos Pos;
+} TPacketGCDragonSoulRefine;
+#endif
+
+typedef struct SPacketCGStateCheck
+{
+	BYTE header;
+	unsigned long key;
+	unsigned long index;
+} TPacketCGStateCheck;
+
+typedef struct SPacketGCStateCheck
+{
+	BYTE header;
+	unsigned long key;
+	unsigned long index;
+	unsigned char state;
+} TPacketGCStateCheck;
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+enum ESubHeaderGCAcceRefine
+{
+	ACCE_REFINE_SUBHEADER_GC_CLOSE,
+	ACCE_REFINE_SUBHEADER_GC_OPEN,
+	ACCE_REFINE_SUBHEADER_GC_SET_ITEM,
+	ACCE_REFINE_SUBHEADER_GC_CLEAR_SLOT,
+	ACCE_REFINE_SUBHEADER_GC_CLEAR_ALL,
+	ACCE_REFINE_SUBHEADER_GC_CLEAR_RIGHT
+};
+
+typedef struct SSubPacketGCAcceRefineOpenClose
+{
+	BYTE bType;
+	bool bServerClose;
+} TSubPacketGCAcceRefineOpenClose;
+
+typedef struct SSubPacketGCAcceRefineSetItem
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	TItemData Item;
+} TSubPacketGCAcceRefineSetItem;
+
+typedef struct SSubPacketGCAcceRefineClearSlot
+{
+	BYTE bSlotIndex;
+} TSubPacketGCAcceRefineClearSlot;
+
+enum ESubHeaderCGAcceRefine
+{
+	ACCE_REFINE_SUBHEADER_CG_CHECKIN,
+	ACCE_REFINE_SUBHEADER_CG_CHECKOUT,
+	ACCE_REFINE_SUBHEADER_CG_ACCEPT,
+	ACCE_REFINE_SUBHEADER_CG_CANCEL
+};
+
+typedef struct SSubPacketCGAcceRefineCheckIn
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAcceRefineCheckIn;
+
+typedef struct SSubPacketCGAcceRefineCheckOut
+{
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAcceRefineCheckOut;
+
+typedef struct SSubPacketCGAcceRefineAccept
+{
+	BYTE bType;
+} TSubPacketCGAcceRefineAccept;
+
+typedef struct SPacketGCAcceRefine
+{
+	SPacketGCAcceRefine() : bHeader(HEADER_GC_ACCE_REFINE) {}
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCAcceRefine;
+
+typedef struct SPacketCGAcceRefine
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketCGAcceRefine;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+enum ESubHeaderGCAuraRefine
+{
+	AURA_REFINE_SUBHEADER_GC_CLOSE,
+	AURA_REFINE_SUBHEADER_GC_OPEN,
+	AURA_REFINE_SUBHEADER_GC_SET_ITEM,
+	AURA_REFINE_SUBHEADER_GC_CLEAR_SLOT,
+	AURA_REFINE_SUBHEADER_GC_CLEAR_ALL,
+	AURA_REFINE_SUBHEADER_GC_INFO
+};
+
+typedef struct SSubPacketGCAuraRefineOpenClose
+{
+	BYTE bType;
+	bool bServerClose;
+} TSubPacketGCAuraRefineOpenClose;
+
+typedef struct SSubPacketGCAuraRefineSetItem
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	TItemData Item;
+} TSubPacketGCAuraRefineSetItem;
+
+typedef struct SSubPacketGCAuraRefineClearSlot
+{
+	BYTE bSlotIndex;
+} TSubPacketGCAuraRefineClearSlot;
+
+typedef struct SSubPacketGCAuraRefineInfo
+{
+	BYTE bInfoType;
+	BYTE bInfoLevel;
+	BYTE bInfoExpPercent;
+} TSubPacketGCAuraRefineInfo;
+
+enum ESubHeaderCGAuraRefine
+{
+	AURA_REFINE_SUBHEADER_CG_CHECKIN,
+	AURA_REFINE_SUBHEADER_CG_CHECKOUT,
+	AURA_REFINE_SUBHEADER_CG_ACCEPT,
+	AURA_REFINE_SUBHEADER_CG_CANCEL
+};
+
+typedef struct SSubPacketCGAuraRefineCheckIn
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAuraRefineCheckIn;
+
+typedef struct SSubPacketCGAuraRefineCheckOut
+{
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAuraRefineCheckOut;
+
+typedef struct SSubPacketCGAuraRefineAccept
+{
+	BYTE bType;
+} TSubPacketCGAuraRefineAccept;
+
+typedef struct SPacketGCAuraRefine
+{
+	SPacketGCAuraRefine() : bHeader(HEADER_GC_AURA_REFINE) {}
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCAuraRefine;
+
+typedef struct SPacketCGAuraRefine
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketCGAuraRefine;
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__)
+enum EMiniGameCatchKingCGSubHeader
+{
+	CATCHKING_CG_START,
+	CATCHKING_CG_CLICK_HAND,
+	CATCHKING_CG_CLICK_CARD,
+	CATCHKING_CG_REWARD,
+#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
+	CATCHKING_CG_REQUEST_QUEST_FLAG,
+#endif
+};
+
+enum EMiniGameCatchKingGCSubHeader
+{
+	CATCHKING_GC_START,
+	CATCHKING_GC_SET_CARD,
+	CATCHKING_GC_RESULT_FIELD,
+	CATCHKING_GC_SET_END_CARD,
+	CATCHKING_GC_REWARD,
+#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
+	CATCHKING_GC_SET_CARD_PIECE_FLAG,
+	CATCHKING_GC_SET_CARD_FLAG,
+	CATCHKING_GC_SET_QUEST_FLAG,
+	CATCHKING_GC_NO_MORE_GAIN,
+#endif
+};
+
+typedef struct SCatchKingCard
+{
+	SCatchKingCard() { bIndex = 0; bIsExposed = false; }
+	SCatchKingCard(BYTE index, bool isExposed)
+	{
+		bIndex = index;
+		bIsExposed = isExposed;
+	}
+
+	BYTE bIndex;
+	bool bIsExposed;
+} TCatchKingCard;
+
+typedef struct SPacketCGMiniGameCatchKing
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSubArgument;
+} TPacketCGMiniGameCatchKing;
+
+typedef struct SPacketGCMiniGameCatchKing
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMiniGameCatchKing;
+
+typedef struct SPacketGCMiniGameCatchKingResult
+{
+	DWORD dwPoints;
+	BYTE bRowType;
+	BYTE bCardPos;
+	BYTE bCardValue;
+	bool bKeepFieldCard;
+	bool bDestroyHandCard;
+	bool bGetReward;
+	bool bIsFiveNearBy;
+} TPacketGCMiniGameCatchKingResult;
+
+typedef struct SPacketGCMiniGameCatchKingSetEndCard
+{
+	BYTE bCardPos;
+	BYTE bCardValue;
+} TPacketGCMiniGameCatchKingSetEndCard;
+
+#if defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
+typedef struct SPacketGCMiniGameCatchKingQuestFlag
+{
+	WORD wPieceCount, wPackCount;
+	SPacketGCMiniGameCatchKingQuestFlag(WORD wPieceCount, WORD wPackCount) :
+		wPieceCount(wPieceCount), wPackCount(wPackCount) {}
+} TPacketGCMiniGameCatchKingQuestFlag;
+#endif
+#endif
+
+#if defined(__SKILLBOOK_COMB_SYSTEM__)
+typedef struct SPacketCGSkillBookCombination
+{
+	BYTE bHeader;
+	BYTE bAction;
+	TItemPos CombItemGrid[SKILLBOOK_COMB_SLOT_MAX];
+} TPacketCGSkillBookCombination;
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+enum class EPacketCGChangeLookSubHeader : BYTE
+{
+	ITEM_CHECK_IN,
+	ITEM_CHECK_OUT,
+	FREE_ITEM_CHECK_IN,
+	FREE_ITEM_CHECK_OUT,
+	ACCEPT,
+	CANCEL
+};
+
+typedef struct packet_set_changelook
+{
+	BYTE bHeader;
+	WORD wCell;
+	BYTE bSlotIndex;
+} TPacketGCChangeLookSet;
+
+typedef struct packet_changelook_del
+{
+	BYTE bHeader;
+	WORD wCell;
+	BYTE bSlotIndex;
+} TPacketGCChangeLookDel;
+
+typedef struct command_changelook
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSlotIndex;
+	TItemPos ItemPos;
+} TPacketCGChangeLook;
+#endif
+
+#if defined(__MAILBOX__)
+typedef struct packet_mailbox_process
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bArg1;
+	BYTE bArg2;
+} TPacketMailboxProcess;
+
+typedef struct packet_mailbox_process_all
+{
+	BYTE Index;
+} TPacketGCMailboxProcessAll;
+
+typedef struct packet_mailbox
+{
+	BYTE bHeader;
+	WORD wSize;
+} TPacketGCMailBox;
+
+typedef struct packet_mailbox_write
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	char szTitle[25 + 1];
+	char szMessage[100 + 1];
+	TItemPos pos;
+	int iYang;
+	int iWon;
+} TPacketCGMailboxWrite;
+
+typedef struct packet_mailbox_write_confirm
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketCGMailboxWriteConfirm;
+#endif
+
+#if defined(__RANKING_SYSTEM__)
+typedef struct SPacketGCRanking
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bType;
+	BYTE bCategory;
+} TPacketGCRanking;
+#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+typedef struct packet_cg_item_combination
+{
+	BYTE Header;
+	short MediumIndex;
+	short BaseIndex;
+	short MaterialIndex;
+} TPacketCGItemCombination;
+
+typedef struct packet_cg_item_combination_cancel
+{
+	BYTE Header;
+} TPacketCGItemCombinationCancel;
+#endif
+
+#if defined(__CHANGED_ATTR__)
+typedef struct packet_gc_item_select_attr
+{
+	BYTE bHeader;
+	TItemPos pItemPos;
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_MAX_NUM];
+} TPacketGCItemSelectAttr;
+
+typedef struct packet_cg_item_select_attr
+{
+	BYTE bHeader;
+	bool bNew;
+	TItemPos pItemPos;
+} TPacketCGItemSelectAttr;
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+typedef struct SPacketCGLootFilter
+{
+	BYTE header;
+	BYTE settings[ELootFilter::LOOT_FILTER_SETTINGS_MAX];
+} TPacketCGLootFilter;
+
+typedef struct SPacketGCLootFilter
+{
+	BYTE header;
+	bool enable;
+	DWORD vid;
+} TPacketGCLootFilter;
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+enum EMiniGameRumiCGSubHeader
+{
+	RUMI_CG_SUBHEADER_END,
+	RUMI_CG_SUBHEADER_START,
+	RUMI_CG_SUBHEADER_DECK_CARD_CLICK,
+	RUMI_CG_SUBHEADER_HAND_CARD_CLICK,
+	RUMI_CG_SUBHEADER_FIELD_CARD_CLICK,
+#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
+	RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
+#endif
+};
+
+enum EMiniGameRumiGCSubHeader
+{
+	RUMI_GC_SUBHEADER_END,
+	RUMI_GC_SUBHEADER_START,
+	RUMI_GC_SUBHEADER_SET_DECK,
+	RUMI_GC_SUBHEADER_SET_SCORE,
+	RUMI_GC_SUBHEADER_MOVE_CARD,
+#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
+	RUMI_GC_SUBHEADER_SET_CARD_PIECE_FLAG,
+	RUMI_GC_SUBHEADER_SET_CARD_FLAG,
+	RUMI_GC_SUBHEADER_SET_QUEST_FLAG,
+	RUMI_GC_SUBHEADER_NO_MORE_GAIN,
+#endif
+};
+
+typedef struct SPacketCGMiniGameRumi
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BOOL bUseCard;
+	BYTE bIndex;
+} TPacketCGMiniGameRumi;
+
+typedef struct SPacketGCMiniGameRumiSetDeck
+{
+	BYTE bDeckCount;
+	SPacketGCMiniGameRumiSetDeck(BYTE bDeckCount) : bDeckCount(bDeckCount) {}
+} TPacketGCMiniGameRumiSetDeck;
+
+typedef struct SPacketGCMiniGameRumiMoveCard
+{
+	BYTE bSrcPos, bSrcIndex, bSrcColor, bSrcNumber;
+	BYTE bDstPos, bDstIndex, bDstColor, bDstNumber;
+	SPacketGCMiniGameRumiMoveCard() :
+		bSrcPos(0), bSrcIndex(0), bSrcColor(0), bSrcNumber(0),
+		bDstPos(0), bDstIndex(0), bDstColor(0), bDstNumber(0) {}
+} TPacketGCMiniGameRumiMoveCard;
+
+typedef struct SPacketGCMiniGameRumiSetScore
+{
+	WORD wScore, wTotalScore;
+	SPacketGCMiniGameRumiSetScore(WORD wScore, WORD wTotalScore) :
+		wScore(wScore), wTotalScore(wTotalScore) {}
+} TPacketGCMiniGameRumiSetScore;
+
+#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
+typedef struct SPacketGCMiniGameRumiQuestFlag
+{
+	WORD wCardPieceCount, wCardCount;
+	SPacketGCMiniGameRumiQuestFlag(WORD wCardPieceCount, WORD wCardCount) :
+		wCardPieceCount(wCardPieceCount), wCardCount(wCardCount) {}
+} TPacketGCMiniGameRumiQuestFlag;
+#endif
+
+typedef struct SPacketGCMiniGameRumi
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMiniGameRumi;
+#endif
+
+#if defined(__LUCKY_BOX__)
+enum ELUCKY_BOX_ACTION
+{
+	LUCKY_BOX_ACTION_RETRY,
+	LUCKY_BOX_ACTION_RECEIVE,
+};
+
+typedef struct SPacketCGLuckyBox
+{
+	BYTE bHeader;
+	BYTE bAction;
+} TPacketCGLuckyBox;
+
+typedef struct SPacketGCLuckyBox
+{
+	BYTE bHeader;
+	DWORD dwVNum;
+	BYTE bCount;
+	int iNeedMoney;
+	WORD wSlotIndex;
+} TPacketGCLuckyBox;
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+enum EAttr67AddSubHeader
+{
+	SUBHEADER_CG_ATTR67_ADD_CLOSE,
+	SUBHEADER_CG_ATTR67_ADD_OPEN,
+	SUBHEADER_CG_ATTR67_ADD_REGIST,
+};
+
+typedef struct SPacketCGAttr67Add
+{
+	BYTE byHeader;
+	BYTE bySubHeader;
+	TAttr67AddData Attr67AddData;
+} TPacketCGAttr67Add;
+#endif
+
+#if defined(__GEM_SHOP__)
+enum EGemShopSubHeader : BYTE
+{
+	SUBHEADER_GEM_SHOP_CLOSE,
+	SUBHEADER_GEM_SHOP_OPEN,
+	SUBHEADER_GEM_SHOP_BUY,
+	SUBHEADER_GEM_SHOP_SLOT_ADD,
+	SUBHEADER_GEM_SHOP_REFRESH,
+	SUBHEADER_GEM_SHOP_MAX,
+};
+
+typedef struct SPacketGCGemShop
+{
+	BYTE bHeader;
+	WORD wSize;
+} TPacketGCGemShop;
+
+typedef struct SPacketGCGemShopProcess
+{
+	SPacketGCGemShopProcess(const BYTE c_bSubHeader) :
+		bHeader(HEADER_GC_GEM_SHOP_PROCESS),
+		bSubHeader(c_bSubHeader),
+		bSlotIndex(GEM_SHOP_SLOT_COUNT),
+		bEnable(false)
+	{}
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSlotIndex;
+	bool bEnable;
+} TPacketGCGemShopProcess;
+
+typedef struct command_gem_shop
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSlotIndex;
+} TPacketCGGemShop;
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+typedef struct SPacketCGExtendInven
+{
+	BYTE bHeader;
+	bool bUpgrade;
+	BYTE bIndex;
+} TPacketCGExtendInven;
+
+typedef struct SPacketGCExtendInven
+{
+	BYTE bHeader;
+	BYTE bStage;
+	WORD wMaxNum;
+} TPacketGCExtendInven;
+
+typedef struct SPacketGCExtendInvenItemUse
+{
+	BYTE bHeader;
+	BYTE bMsgResult;
+	BYTE bEnoughCount;
+} TPacketGCExtendInvenItemUse;
+#endif
+
+#if defined(__CLIENT_TIMER__)
+enum EClientTimerSubHeader
+{
+	CLIENT_TIMER_SUBHEADER_GC_SET,
+	CLIENT_TIMER_SUBHEADER_GC_DELETE
+};
+
+enum EClientTimer
+{
+	ECLIENT_TIMER_END_TIME,
+	ECLIENT_TIMER_ALARM_SECOND,
+	ECLIENT_TIMER_MAX
+};
+
+typedef struct SPacketGCClientTimer
+{
+	SPacketGCClientTimer(const BYTE _bSubHeader)
+		: bHeader(HEADER_GC_CLIENT_TIMER), bSubHeader(_bSubHeader)
+	{
+		memset(&dwData, 0, sizeof(dwData));
+	};
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwData[ECLIENT_TIMER_MAX];
+} TPacketGCClientTimer;
+#endif
+
+enum EEmoteSubHeader
+{
+	SUBHEADER_EMOTE_ADD,
+	SUBHEADER_EMOTE_CLEAR,
+	SUBHEADER_EMOTE_MOTION,
+	SUBHEADER_EMOTE_ICON,
+};
+
+typedef struct SPacketGCEmote
+{
+	SPacketGCEmote() : bHeader(HEADER_GC_EMOTE) {}
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwEmoteVnum;
+	DWORD dwDuration;
+	DWORD dwMainVID, dwTargetVID;
+} TPacketGCEmote;
+
+#if defined(__CUBE_RENEWAL__)
+enum ECubeSubHeader
+{
+	SUBHEADER_GC_CUBE_OPEN = 0,
+	SUBHEADER_GC_CUBE_CLOSE,
+	SUBHEADER_GC_CUBE_RESULT,
+
+	SUBHEADER_CG_CUBE_CLOSE = 0,
+	SUBHEADER_CG_CUBE_MAKE,
+};
+
+typedef struct SPacketGCCube
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwNPCVnum;
+	BOOL bSuccess;
+	DWORD dwFileCrc;
+} TPacketGCCube;
+
+typedef struct SPacketCGCube
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	UINT iCubeIndex;
+	UINT iQuantity;
+	INT iImproveItemPos;
+	DWORD dwFileCrc;
+} TPacketCGCube;
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+enum ESubPacketGCSnowflakeStickEvent
+{
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_SNOW_BALL,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_TREE_BRANCH,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_SNOW_BALL_MAX,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_TREE_BRANCH_MAX,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_STICK_SUCCESS,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_PET_SUCCESS,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_MOUNT_SUCCESS,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_USE_STICK_FAILED,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_RANK_BUFF,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_SNOWFLAKE_BUFF,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ENABLE,
+};
+
+enum ESnowflakeStickEventQuestFlagType
+{
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_SNOW_BALL,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_TREE_BRANCH,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK_COOLDOWN,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_PET,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_MOUNT,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_USE_STICK_COOLDOWN,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM,
+};
+
+typedef struct SPacketGCSnowflakeStickEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM];
+	SPacketGCSnowflakeStickEvent(const BYTE c_bSubHeader)
+		: bHeader(HEADER_GC_SNOWFLAKE_STICK_EVENT), bSubHeader(c_bSubHeader)
+	{;
+		memset(&dwValue, 0, sizeof(dwValue));
+	}
+} TPacketGCSnowflakeStickEvent;
+
+enum ESubPacketCGSnowflakeStickEvent
+{
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_REQUEST_INFO,
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_STICK,
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_PET,
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_MOUNT
+};
+
+typedef struct SPacketCGSnowflakeStickEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+} TPacketCGSnowflakeStickEvent;
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+enum EPacketGCRefineElement
+{
+	REFINE_ELEMENT_GC_OPEN,
+	REFINE_ELEMENT_GC_RESULT
+};
+
+enum EPacketCGRefineElement
+{
+	REFINE_ELEMENT_CG_CLOSE,
+	REFINE_ELEMENT_CG_REFINE,
+};
+
+typedef struct SPacketGCRefineElement
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bRefineType;
+	BYTE bResult;
+	TItemPos SrcPos;
+	TItemPos DestPos;
+} TPacketGCRefineElement;
+
+typedef struct SPacketCGRefineElement
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	WORD wChangeElement;
+} TPacketCGRefineElement;
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__)
+enum EMiniGameYutnoriGCSubHeader
+{
+	YUTNORI_GC_SUBHEADER_START,
+	YUTNORI_GC_SUBHEADER_STOP,
+	YUTNORI_GC_SUBHEADER_SET_PROB,
+	YUTNORI_GC_SUBHEADER_THROW,
+	YUTNORI_GC_SUBHEADER_MOVE,
+	YUTNORI_GC_SUBHEADER_AVAILABLE_AREA,
+	YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT,
+	YUTNORI_GC_SUBHEADER_SET_SCORE,
+	YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT,
+	YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN,
+#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+	YUTNORI_GC_SUBHEADER_SET_YUT_PIECE_FLAG,
+	YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG,
+	YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG,
+	YUTNORI_GC_SUBHEADER_NO_MORE_GAIN,
+#endif
+};
+
+enum EMiniGameYutnoriCGSubHeader
+{
+	YUTNORI_CG_SUBHEADER_START,
+	YUTNORI_CG_SUBHEADER_GIVEUP,
+	YUTNORI_CG_SUBHEADER_SET_PROB,
+	YUTNORI_CG_SUBHEADER_CLICK_CHAR,
+	YUTNORI_CG_SUBHEADER_THROW,
+	YUTNORI_CG_SUBHEADER_MOVE,
+	YUTNORI_CG_SUBHEADER_REQUEST_COM_ACTION,
+	YUTNORI_CG_SUBHEADER_REWARD,
+#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+	YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
+#endif
+};
+
+typedef struct SPacketCGMiniGameYutnori
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bArgument;
+} TPacketCGMiniGameYutnori;
+
+typedef struct SPacketGCMiniGameYutnori
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMiniGameYutnori;
+
+typedef struct SPacketGCMiniGameYutnoriSetProb
+{
+	BYTE bProbIndex;
+	SPacketGCMiniGameYutnoriSetProb(BYTE bProbIndex)
+		: bProbIndex(bProbIndex) {}
+} TPacketGCMiniGameYutnoriSetProb;
+
+typedef struct SPacketGCMiniGameYutnoriThrow
+{
+	bool bPC;
+	BYTE bYut;
+	SPacketGCMiniGameYutnoriThrow(bool bPC, BYTE bYut)
+		: bPC(bPC), bYut(bYut) {}
+} TPacketGCMiniGameYutnoriThrow;
+
+typedef struct SPacketGCMiniGameYutnoriMove
+{
+	bool bPC;
+	BYTE bUnitIndex;
+	bool bIsCatch;
+	BYTE bStartIndex;
+	BYTE bDestIndex;
+	SPacketGCMiniGameYutnoriMove(bool bPC, BYTE bUnitIndex, bool bIsCatch, BYTE bStartIndex, BYTE bDestIndex)
+		: bPC(bPC), bUnitIndex(bUnitIndex), bIsCatch(bIsCatch), bStartIndex(bStartIndex), bDestIndex(bDestIndex) {}
+} TPacketGCMiniGameYutnoriMove;
+
+typedef struct SPacketGCMiniGameYutnoriAvailableArea
+{
+	BYTE bPlayerIndex;
+	BYTE bAvailableIndex;
+	SPacketGCMiniGameYutnoriAvailableArea(BYTE bPlayerIndex, BYTE bAvailableIndex)
+		: bPlayerIndex(bPlayerIndex), bAvailableIndex(bAvailableIndex) {}
+} TPacketGCMiniGameYutnoriAvailableArea;
+
+typedef struct SPacketGCMiniGameYutnoriPushCatchYut
+{
+	bool bPC;
+	BYTE bUnitIndex;
+	SPacketGCMiniGameYutnoriPushCatchYut(bool bPC, BYTE bUnitIndex)
+		: bPC(bPC), bUnitIndex(bUnitIndex) {}
+} TPacketGCMiniGameYutnoriPushCatchYut;
+
+typedef struct SPacketGCMiniGameYutnoriSetScore
+{
+	WORD wScore;
+	SPacketGCMiniGameYutnoriSetScore(WORD wScore)
+		: wScore(wScore) {}
+} TPacketGCMiniGameYutnoriSetScore;
+
+typedef struct SPacketGCMiniGameYutnoriSetRemainCount
+{
+	BYTE bRemainCount;
+	SPacketGCMiniGameYutnoriSetRemainCount(BYTE bRemainCount)
+		: bRemainCount(bRemainCount) {}
+} TPacketGCMiniGameYutnoriSetRemainCount;
+
+typedef struct SPacketGCMiniGameYutnoriPushNextTurn
+{
+	bool bPC;
+	BYTE bState;
+	SPacketGCMiniGameYutnoriPushNextTurn(bool bPC, BYTE bState)
+		: bPC(bPC), bState(bState) {}
+} TPacketGCMiniGameYutnoriPushNextTurn;
+
+#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+typedef struct SPacketGCMiniGameYutnoriQuestFlag
+{
+	WORD wYutPieceCount;
+	WORD wYutBoardCount;
+	SPacketGCMiniGameYutnoriQuestFlag(WORD wYutPieceCount, WORD wYutBoardCount)
+		: wYutPieceCount(wYutPieceCount), wYutBoardCount(wYutBoardCount) {}
+} TPacketGCMiniGameYutnoriQuestFlag;
+#endif
+#endif
+
+#if defined(__QUEST_REQUEST_EVENT__)
+typedef struct SPacketCGRequestEventQuest
+{
+	BYTE bHeader;
+	char szEventQuest[64 + 1];
+} TPacketCGRequestEventQuest;
+#endif
+
+#if defined(__LEFT_SEAT__)
+enum ELeftSeatCGSubHeader
+{
+	LEFT_SEAT_SET_WAIT_TIME_INDEX,
+	LEFT_SEAT_SET_LOGOUT_TIME_INDEX,
+	LEFT_SEAT_DISABLE_LOGOUT_STATE,
+};
+
+typedef struct SPacketCGLeftSeat
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bIndex;
+} TPacketCGLeftSeat;
+#endif
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+enum EGuildDragonLairType
+{
+	GUILD_DRAGONLAIR_TYPE_RED,
+	GUILD_DRAGONLAIR_TYPE_BLUE,
+	GUILD_DRAGONLAIR_TYPE_GREEN,
+	GUILD_DRAGONLAIR_TYPE_MAX_NUM
+};
+
+enum EGuildDragonLairSubHeader
+{
+	GUILD_DRAGONLAIR_GC_SUBHEADER_RANKING,
+#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
+	GUILD_DRAGONLAIR_GC_SUBHEADER_1ST_GUILD_TEXT,
+	GUILD_DRAGONLAIR_GC_SUBHEADER_START,
+	GUILD_DRAGONLAIR_GC_SUBHEADER_SUCCESS,
+#endif
+};
+
+typedef struct SPacketGCGuildDragonLair
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+	BYTE bType;
+#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
+	DWORD dwFirstRankingTime;
+#endif
+} TPacketGCGuildDragonLair;
+
+typedef struct SPacketGCGuildDragonLairRanking
+{
+	BYTE bType;
+	DWORD dwGuildID;
+	char szGuildName[GUILD_NAME_MAX_LEN + 1];
+	BYTE bMemberCount;
+	DWORD dwTime;
+} TPacketGCGuildDragonLairRanking;
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+enum EPacketGCMiniGameRouletteSubHeader
+{
+	ROULETTE_GC_OPEN,
+	ROULETTE_GC_START,
+	ROULETTE_GC_REQUEST,
+	ROULETTE_GC_END,
+	ROULETTE_GC_CLOSE
+};
+
+enum EPacketCGMiniGameRouletteSubHeader
+{
+	ROULETTE_CG_START,
+	ROULETTE_CG_REQUEST,
+	ROULETTE_CG_END,
+	ROULETTE_CG_CLOSE
+};
+
+typedef struct SPacketGCMiniGameRoulette
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bResult;
+	DWORD dwExpireTime;
+	struct
+	{
+		DWORD dwVnum;
+		BYTE bCount;
+	} ItemData[ROULETTE_ITEM_MAX];
+} TPacketGCMiniGameRoulette;
+
+typedef struct SPacketCGMiniGameRoulette
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+} TPacketCGMiniGameRoulette;
+#endif
+
+#if defined(__FLOWER_EVENT__)
+enum EPacketGCFlowerEvent
+{
+	FLOWER_EVENT_SUBHEADER_GC_INFO_ALL,
+	FLOWER_EVENT_SUBHEADER_GC_GET_INFO,
+	FLOWER_EVENT_SUBHEADER_GC_UPDATE_INFO,
+};
+
+typedef struct SPacketGCFlowerEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bChatType;
+	BYTE bShootType;
+	int aiShootCount[SHOOT_TYPE_MAX + 1];
+	SPacketGCFlowerEvent()
+		: bHeader(HEADER_GC_FLOWER_EVENT)
+		, bSubHeader(FLOWER_EVENT_SUBHEADER_GC_INFO_ALL)
+		, bChatType(FLOWER_EVENT_CHAT_TYPE_MAX)
+		, bShootType(SHOOT_TYPE_MAX)
+	{
+		memset(&aiShootCount, 0, sizeof(aiShootCount));
+	}
+} TPacketGCFlowerEvent;
+
+enum EPacketCGFlowerEvent
+{
+	FLOWER_EVENT_SUBHEADER_CG_INFO_ALL,
+	FLOWER_EVENT_SUBHEADER_CG_EXCHANGE
+};
+
+typedef struct SPacketCGFlowerEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bShootType;
+	BYTE bExchangeKey;
+}TPacketCGFlowerEvent;
+#endif
+
+#if defined(__OFFLINE_SHOP__)
+typedef struct SPacketGGUpdateSellHistory {
+	BYTE		bHeader;
+	DWORD		pid;
+	TMySellHistory	sellItem;
+} TPacketGGUpdateSellHistory;
+#endif
+
+#ifdef __SHOP_SEARCH__
+typedef struct SPacketCGShopSearchByName {
+	BYTE	header;
+	char	itemName[ITEM_NAME_MAX_LEN + 1];
+	WORD	page;
+	BYTE	entryCountIdx;
+	BYTE	sortType;
+} TPacketCGShopSearchByName;
+
+typedef struct SPacketCGShopSearchByOptions {
+	BYTE	header;
+	TShopSearchOptions	options;
+	WORD	page;
+	BYTE	entryCountIdx;
+	BYTE	sortType;
+} TPacketCGShopSearchByOptions;
+
+typedef struct SPacketGCShopSearchResult {
+	BYTE	header;
+	WORD	size;
+	WORD	itemCount;
+	WORD	maxPageNum;
+} TPacketGCShopSearchResult;
+typedef struct SPacketCGShopSearchBuy {
+	BYTE	header;
+	TOfflineItemID	itemID;
+	DWORD	itemVnum;
+	int64_t	itemPrice;
+
+} TPacketCGShopSearchBuy;
+
+typedef struct SPacketGCShopSearchBuyResult {
+	BYTE	header;
+	BYTE	result;
+} TPacketGCShopSearchBuyResult;
+
+typedef struct SPacketCGShopSearchOwnerMessage {
+	BYTE	header;
+	DWORD	ownerID;
+} TPacketCGShopSearchOwnerMessage;
+
+typedef struct SPacketGCShopSearchOwnerMessage {
+	BYTE	header;
+	char	ownerName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGCShopSearchOwnerMessage;
+
+typedef struct SPacketCGShopSearchRequestSoldInfo {
+	BYTE	header;
+	DWORD	itemVnum;
+} TPacketCGShopSearchRequestSoldInfo;
+
+typedef struct SPacketGCShopSearchSoldInfo {
+	BYTE	header;
+	WORD	size;
+	bool	results;
+} TPacketGCShopSearchSoldInfo;
+
+using TPacketGCEntity = struct SPacketGCEntity
+{
+	BYTE bHeader;
+	WORD wSize;
+};
+using TPacketEntityInfo = struct SPacketEntityInfo
+{
+	DWORD dwVID;
+	DWORD dwRaceVNum;
+	WORD wPart[CHR_EQUIPPART_NUM];
+	LONG xPos, yPos;
+};
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+typedef struct SPacketCGExtBattlePassAction
+{
+	BYTE bHeader;
+	BYTE bAction;
+} TPacketCGExtBattlePassAction;
+
+typedef struct SPacketCGExtBattlePassSendPremiumItem
+{
+	BYTE bHeader;
+	int iSlotIndex;
+} TPacketCGExtBattlePassSendPremiumItem;
+
+typedef struct SPacketGCExtBattlePassOpen
+{
+	BYTE bHeader;
+} TPacketGCExtBattlePassOpen;
+
+typedef struct SPacketGCExtBattlePassGeneralInfo
+{
+	BYTE bHeader;
+	BYTE bBattlePassType;
+	char	szSeasonName[64+1];
+	DWORD dwBattlePassID;
+	DWORD dwBattlePassStartTime;
+	DWORD dwBattlePassEndTime;
+} TPacketGCExtBattlePassGeneralInfo;
+
+typedef struct SPacketGCExtBattlePassMissionInfo
+{
+	BYTE bHeader;
+	WORD wSize;
+	WORD wRewardSize;
+	BYTE bBattlePassType;
+	DWORD dwBattlePassID;
+} TPacketGCExtBattlePassMissionInfo;
+
+typedef struct SPacketGCExtBattlePassMissionUpdate
+{
+	BYTE bHeader;
+	BYTE bBattlePassType;
+	BYTE bMissionIndex;
+	BYTE bMissionType;
+	DWORD dwNewProgress;
+} TPacketGCExtBattlePassMissionUpdate;
+
+typedef struct SPacketGCExtBattlePassRanking
+{
+	BYTE bHeader;
+	char	szPlayerName[CHARACTER_NAME_MAX_LEN + 1];
+	BYTE bBattlePassType;
+	BYTE	bBattlePassID;
+	DWORD	dwStartTime;
+	DWORD	dwEndTime;
+} TPacketGCExtBattlePassRanking;
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+enum EGrowthPetPoints
+{
+	POINT_UPBRINGING_PET_LEVEL,
+	POINT_UPBRINGING_PET_EXP,
+	POINT_UPBRINGING_PET_ITEM_EXP,
+	POINT_UPBRINGING_PET_NEXT_EXP,
+	POINT_UPBRINGING_PET_EVOL_LEVEL,
+	POINT_UPBRINGING_PET_HP,
+	POINT_UPBRINGING_PET_DEF_GRADE,
+	POINT_UPBRINGING_PET_SP,
+	POINT_UPBRINGING_DURATION,
+	POINT_UPBRINGING_MAX_DURATION,
+	POINT_UPBRINGING_BIRTHDAY,
+	
+	POINT_UPBRINGING_MAX_NUM
+};
+
+enum EGrowthPetSubheader
+{
+	SUBHEADER_PET_EGG_USE_SUCCESS,
+	SUBHEADER_PET_EGG_USE_FAILED_BECAUSE_NAME,
+	SUBHEADER_PET_EGG_USE_FAILED_TIMEOVER,
+	SUBHEADER_PET_UNSUMMON,
+	SUBHEADER_PET_FEED_FAILED,
+	SUBHEADER_PET_FEED_SUCCESS,
+	SUBHEADER_PET_REVIVE_FAILED,
+	SUBHEADER_PET_REVIVE_SUCCESS,
+	SUBHEADER_PET_NAME_CHANGE_FAILED,
+	SUBHEADER_PET_NAME_CHANGE_SUCCESS,
+	SUBHEADER_PET_WINDOW_TYPE_INFO,
+	SUBHEADER_PET_WINDOW_TYPE_ATTR_CHANGE,
+	SUBHEADER_PET_WINDOW_TYPE_PREMIUM_FEED,
+};
+
+enum EGrowthPetWindow
+{
+	PET_WINDOW_HATCH,
+	PET_WINDOW_NAME_CHANGE,
+};
+
+typedef struct SPacketGCPet
+{
+	BYTE	header;
+	BYTE	subheader;
+} TPacketGCPet;
+
+typedef struct SPacketGCPetSet
+{
+	BYTE		header;
+	DWORD		dwID;
+	DWORD		dwSummonItemVnum;
+	char		szName[PET_NAME_MAX_SIZE + 1];
+	TPetSkill	aSkill[PET_SKILL_COUNT_MAX];
+	DWORD		dwPoints[POINT_UPBRINGING_MAX_NUM];
+} TPacketGCPetSet;
+
+typedef struct SPacketGCPetDelete
+{
+	BYTE		header;
+	DWORD		dwID;
+} TPacketGCPetDelete;
+
+typedef struct SPacketGCPetPointUpdate
+{
+	BYTE	header;
+	DWORD	dwID;
+	BYTE	bPoint;
+	DWORD	dwValue;
+} TPacketGCPetPointUpdate;
+
+typedef struct SPacketGCPetSummon
+{
+	BYTE		header;
+	DWORD		dwID;
+} TPacketGCPetSummon;
+
+typedef struct SPacketGCPetDetermineResult
+{
+	BYTE		header;
+	BYTE		type;
+} TPacketGCPetDetermineResult;
+
+typedef struct SPacketGCPetAttrChangeResult
+{
+	BYTE		header;
+	BYTE		type;
+	TItemPos	pos;
+} TPacketGCPetAttrChangeResult;
+
+typedef struct SPetSkillUpdatePacket
+{
+	bool	bLocked;
+	BYTE	bSkill;
+	BYTE	bLevel;
+	DWORD	dwCooltime;
+	BYTE	bSkillFormula1[PET_GROWTH_SKILL_LEVEL_MAX];
+	WORD	wSkillFormula2[PET_GROWTH_SKILL_LEVEL_MAX];
+	BYTE	bSkillFormula3[PET_GROWTH_SKILL_LEVEL_MAX];
+} TPetSkillUpdatePacket;
+
+typedef struct SPacketGCPetSkillCooltime
+{
+	BYTE		header;
+	DWORD		dwID;
+	BYTE		bSlot;
+	DWORD		dwCooltime;
+} TPacketGCPetSkillCooltime;
+
+typedef struct SPacketGCPetSkillUpdate
+{
+	BYTE		header;
+	DWORD		dwID;
+	TPetSkillUpdatePacket	aSkill[PET_SKILL_COUNT_MAX];
+} TPacketGCPetSkillUpdate;
+
+typedef struct SPacketGCPetNameChangeResult
+{
+	BYTE		header;
+	BYTE		subheader;
+	DWORD		dwID;
+	char		szName[PET_NAME_MAX_SIZE + 1];
+} TPacketGCPetNameChangeResult;
+
+typedef struct SPacketCGPetHatch
+{
+	BYTE		header;
+	char		name[PET_NAME_MAX_SIZE + 1];
+	TItemPos	eggPos;
+} TPacketCGPetHatch;
+
+typedef struct SPacketCGPetWindow
+{
+	BYTE	header;
+	BYTE	window;
+	bool	state;
+} TPacketCGPetWindow;
+
+typedef struct SPacketCGPetWindowType
+{
+	BYTE	header;
+	BYTE	type;
+} TPacketCGPetWindowType;
+
+typedef struct SPacketCGPeFeed
+{
+	BYTE		header;
+	BYTE		index;
+	WORD		pos[PET_FEED_SLOT_MAX];
+	WORD		count[PET_FEED_SLOT_MAX];
+} TPacketCGPetFeed;
+
+typedef struct SPacketCGPetDetermine
+{
+	BYTE		header;
+	TItemPos	determinePos;
+} TPacketCGPetDetermine;
+
+typedef struct SPacketCGPetAttrChange
+{
+	BYTE		header;
+	TItemPos	upBringingPos;
+	TItemPos	attrChangePos;
+} TPacketCGPetAttrChange;
+
+typedef struct SPacketCGPetRevive
+{
+	BYTE		header;
+	TItemPos	upBringingPos;
+	WORD		pos[PET_REVIVE_MATERIAL_SLOT_MAX];
+	WORD		count[PET_REVIVE_MATERIAL_SLOT_MAX];
+} TPacketCGPetRevive;
+
+typedef struct SPacketCGPetLearnSkill
+{
+	BYTE		header;
+	BYTE		slotIndex;
+	TItemPos	learnSkillPos;
+} TPacketCGPetLearnSkill;
+
+typedef struct SPacketCGPetUpgradeSkill
+{
+	BYTE		header;
+	BYTE		slotIndex;
+} TPacketCGPetSkillUpgrade;
+
+typedef struct SPacketCGPetDeleteSkill
+{
+	BYTE		header;
+	BYTE		slotIndex;
+	TItemPos	deleteSkillPos;
+} TPacketCGPetDeleteSkill;
+
+typedef struct SPacketCGPetAllDeleteSkill
+{
+	BYTE		header;
+	TItemPos	deleteAllSkillPos;
+} TPacketCGPetDeleteAllSkill;
+
+typedef struct SPacketCGPetNameChange
+{
+	BYTE		header;
+	char		name[PET_NAME_MAX_SIZE + 1];
+	TItemPos	changeNamePos;
+	TItemPos	upBringingPos;
+} TPacketCGPetNameChange;
+#endif
+
+#pragma pack()
+#endif // __INC_PACKET_H__
diff --git a/server/server/home/metin2/Source/Server/game/src/shop_manager.cpp b/server/server/home/metin2/Source/Server/game/src/shop_manager.cpp
index b1c6c08..00ed9c5 100644
--- a/server/server/home/metin2/Source/Server/game/src/shop_manager.cpp
+++ b/server/server/home/metin2/Source/Server/game/src/shop_manager.cpp
@@ -1,707 +1,705 @@
-#include "stdafx.h"
-#include "../../libgame/include/grid.h"
-#include "constants.h"
-#include "utils.h"
-#include "config.h"
-#include "shop.h"
-#include "desc.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "item.h"
-#include "item_manager.h"
-#include "buffer_manager.h"
-#include "packet.h"
-#include "log.h"
-#include "db.h"
-#include "questmanager.h"
-#include "monarch.h"
-#include "mob_manager.h"
-#include "locale_service.h"
-#include "desc_client.h"
-#include "shop_manager.h"
-#include "group_text_parse_tree.h"
-#include "shopEx.h"
-#include "shop_manager.h"
-#include <cctype>
-
-CShopManager::CShopManager()
-{
-}
-
-CShopManager::~CShopManager()
-{
-	Destroy();
-}
-
-bool CShopManager::Initialize(TShopTable* table, int size)
-{
-	if (!m_map_pkShop.empty())
-		return false;
-
-	int i;
-
-	for (i = 0; i < size; ++i, ++table)
-	{
-		LPSHOP shop = M2_NEW CShop;
-
-		if (!shop->Create(table->dwVnum, table->dwNPCVnum, table->items))
-		{
-			M2_DELETE(shop);
-			continue;
-		}
-
-		m_map_pkShop.insert(TShopMap::value_type(table->dwVnum, shop));
-		m_map_pkShopByNPCVnum.insert(TShopMap::value_type(table->dwNPCVnum, shop));
-	}
-
-	char szShopTableExFileName[256];
-	snprintf(szShopTableExFileName, sizeof(szShopTableExFileName),
-		"%s/shop_table_ex.txt", LocaleService_GetBasePath().c_str());
-
-	return ReadShopTableEx(szShopTableExFileName);
-}
-
-void CShopManager::Destroy()
-{
-	TShopMap::iterator it = m_map_pkShop.begin();
-	std::unordered_set<decltype(m_map_pkShop)::value_type::second_type> collector; // avoid delete duplicate objects(unique key)
-	while (it != m_map_pkShop.end())
-	{
-		//delete it->second;
-		collector.insert(it->second);
-		++it;
-	}
-	for (auto& v : collector)
-		delete v;
-
-	m_map_pkShop.clear();
-}
-
-LPSHOP CShopManager::Get(DWORD dwVnum)
-{
-	TShopMap::const_iterator it = m_map_pkShop.find(dwVnum);
-
-	if (it == m_map_pkShop.end())
-		return NULL;
-
-	return (it->second);
-}
-
-LPSHOP CShopManager::GetByNPCVnum(DWORD dwVnum)
-{
-	TShopMap::const_iterator it = m_map_pkShopByNPCVnum.find(dwVnum);
-
-	if (it == m_map_pkShopByNPCVnum.end())
-		return NULL;
-
-	return (it->second);
-}
-
-/*
-* 인터페이스 함수들
-*/
-
-// 상점 거래를 시작
-bool CShopManager::StartShopping(LPCHARACTER pkChr, LPCHARACTER pkChrShopKeeper, int iShopVnum)
-{
-#if defined(__QUEST_EVENT_BUY_SELL__)
-	if (pkChr->GetShop())
-		return false;
-#endif
-
-	if (pkChr->GetShopOwner() == pkChrShopKeeper)
-		return false;
-
-	// this method is only for NPC
-	if (pkChrShopKeeper->IsPC())
-		return false;
-
-#ifdef __GROWTH_PET_SYSTEM__
-	/*
-	if (pkChr->GetActiveGrowthPet())
-	{
-		pkChr->ChatPacket(CHAT_TYPE_INFO, "You cannot open a private shop whilst summoning your pet.");
-		return false;
-	}
-	*/
-	
-	if (pkChr->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || pkChr->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		pkChr->ChatPacket(CHAT_TYPE_INFO, LC_STRING("While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc."));
-		return false;
-	}
-#endif
-
-	// PREVENT_TRADE_WINDOW
-	if (pkChr->PreventTradeWindow(WND_SHOPOWNER, true/*except*/))
-	{
-		pkChr->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 거래창이 열린상태에서는 상점거래를 할수 가 없습니다."));
-		return false;
-	}
-	// END_PREVENT_TRADE_WINDOW
-
-	long distance = DISTANCE_APPROX(pkChr->GetX() - pkChrShopKeeper->GetX(), pkChr->GetY() - pkChrShopKeeper->GetY());
-
-	if (distance >= SHOP_MAX_DISTANCE)
-	{
-		sys_log(1, "SHOP: TOO_FAR: %s distance %d", pkChr->GetName(), distance);
-		return false;
-	}
-
-	LPSHOP pkShop;
-
-	if (iShopVnum)
-		pkShop = Get(iShopVnum);
-	else
-		pkShop = GetByNPCVnum(pkChrShopKeeper->GetRaceNum());
-
-	if (!pkShop)
-	{
-		sys_log(1, "SHOP: NO SHOP");
-		return false;
-	}
-
-	bool bOtherEmpire = false;
-
-	if (pkChr->GetEmpire() != pkChrShopKeeper->GetEmpire())
-		bOtherEmpire = true;
-
-	pkShop->AddGuest(pkChr, pkChrShopKeeper->GetVID(), bOtherEmpire);
-	pkChr->SetShopOwner(pkChrShopKeeper);
-	sys_log(0, "SHOP: START: %s", pkChr->GetName());
-	return true;
-}
-
-LPSHOP CShopManager::FindPCShop(DWORD dwVID)
-{
-	TShopMap::iterator it = m_map_pkShopByPC.find(dwVID);
-
-	if (it == m_map_pkShopByPC.end())
-		return NULL;
-
-	return it->second;
-}
-
-LPSHOP CShopManager::CreatePCShop(LPCHARACTER ch, TShopItemTable* pTable, BYTE bItemCount)
-{
-	if (FindPCShop(ch->GetVID()))
-		return NULL;
-
-	LPSHOP pkShop = M2_NEW CShop;
-	pkShop->SetPCShop(ch);
-	pkShop->SetShopItems(pTable, bItemCount);
-
-	m_map_pkShopByPC.insert(TShopMap::value_type(ch->GetVID(), pkShop));
-	return pkShop;
-}
-
-void CShopManager::DestroyPCShop(LPCHARACTER ch)
-{
-	LPSHOP pkShop = FindPCShop(ch->GetVID());
-
-	if (!pkShop)
-		return;
-
-	// PREVENT_ITEM_COPY;
-	ch->SetMyShopTime();
-	// END_PREVENT_ITEM_COPY
-
-	m_map_pkShopByPC.erase(ch->GetVID());
-	M2_DELETE(pkShop);
-}
-
-// 상점 거래를 종료
-void CShopManager::StopShopping(LPCHARACTER ch)
-{
-	LPSHOP shop;
-
-	if (!(shop = ch->GetShop()))
-		return;
-
-	// PREVENT_ITEM_COPY;
-	ch->SetMyShopTime();
-	// END_PREVENT_ITEM_COPY
-
-	shop->RemoveGuest(ch);
-	sys_log(0, "SHOP: END: %s", ch->GetName());
-}
-
-// 아이템 구입
-void CShopManager::Buy(LPCHARACTER ch, BYTE pos)
-{
-	if (!ch->GetShop())
-		return;
-
-	if (!ch->GetShopOwner())
-		return;
-
-	if (DISTANCE_APPROX(ch->GetX() - ch->GetShopOwner()->GetX(), ch->GetY() - ch->GetShopOwner()->GetY()) > 2000)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상점과의 거리가 너무 멀어 물건을 살 수 없습니다."));
-		return;
-	}
-
-	CShop* pkShop = ch->GetShop();
-	if (!pkShop)
-		return;
-
-	// PREVENT_ITEM_COPY
-	ch->SetMyShopTime();
-	// END_PREVENT_ITEM_COPY
-
-	int ret = pkShop->Buy(ch, pos);
-
-	if (SHOP_SUBHEADER_GC_OK != ret) // 문제가 있었으면 보낸다.
-	{
-		TPacketGCShop pack;
-
-		pack.header = HEADER_GC_SHOP;
-		pack.subheader = ret;
-		pack.size = sizeof(TPacketGCShop);
-
-		ch->GetDesc()->Packet(&pack, sizeof(pack));
-	}
-}
-
-void CShopManager::Sell(LPCHARACTER ch, WORD wCell, WORD wCount, BYTE bType)
-{
-	if (!ch->GetShop())
-		return;
-
-	if (!ch->GetShopOwner())
-		return;
-
-	if (!ch->CanHandleItem())
-		return;
-
-	if (ch->GetShop()->IsPCShop())
-		return;
-
-	if (DISTANCE_APPROX(ch->GetX() - ch->GetShopOwner()->GetX(), ch->GetY() - ch->GetShopOwner()->GetY()) > 2000)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("상점과의 거리가 너무 멀어 물건을 팔 수 없습니다."));
-		return;
-	}
-
-	LPITEM item = ch->GetInventoryItem(wCell);
-
-	if (!item)
-		return;
-
-	if (item->IsEquipped() == true)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("착용 중인 아이템은 판매할 수 없습니다."));
-		return;
-	}
-
-	if (true == item->isLocked())
-		return;
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (item->IsPet())
-		return;
-#endif
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (item->IsSealed())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot sell a soulbound item."));
-		return;
-	}
-#endif
-
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_SELL))
-		return;
-
-	DWORD dwPrice;
-
-	if (wCount == 0 || wCount > item->GetCount())
-		wCount = item->GetCount();
-
-	dwPrice = item->GetShopSellPrice();
-
-	if (IS_SET(item->GetFlag(), ITEM_FLAG_COUNT_PER_1GOLD))
-	{
-		if (dwPrice == 0)
-			dwPrice = wCount;
-		else
-			dwPrice = wCount / dwPrice;
-	}
-	else
-		dwPrice *= wCount;
-
-	dwPrice /= 5;
-
-	// 세금 계산
-	DWORD dwTax = 0;
-	int iVal = 3;
-
-	dwTax = dwPrice * iVal / 100;
-	dwPrice -= dwTax;
-
-	if (test_server)
-		sys_log(0, "Sell Item price id %d %s itemid %d", ch->GetPlayerID(), ch->GetName(), item->GetID());
-
-	const int64_t nTotalMoney = static_cast<int64_t>(ch->GetGold()) + static_cast<int64_t>(dwPrice);
-	if (GOLD_MAX <= nTotalMoney)
-	{
-		sys_err("[OVERFLOW_GOLD] id %u name %s gold %d", ch->GetPlayerID(), ch->GetName(), ch->GetGold());
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("20억냥이 초과하여 물품을 팔수 없습니다."));
-		return;
-	}
-
-	// 20050802.myevan.상점 판매 로그에 아이템 ID 추가
-	sys_log(0, "SHOP: SELL: %s item name: %s(x%d):%u price: %u", ch->GetName(), item->GetName(), wCount, item->GetID(), dwPrice);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	ch->UpdateExtBattlePassMissionProgress(BP_ITEM_SELL, wCount, item->GetVnum());
-#endif
-
-	if (iVal > 0)
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("판매금액의 %d %% 가 세금으로 나가게됩니다", iVal));
-
-	DBManager::instance().SendMoneyLog(MONEY_LOG_SHOP, item->GetVnum(), dwPrice);
-
-#if defined(__QUEST_EVENT_BUY_SELL__)
-	CShop* pkShop = ch->GetShop();
-	if (pkShop)
-	{
-		ch->SetQuestNPCID(ch->GetShopOwner() ? ch->GetShopOwner()->GetVID() : 0);
-		quest::CQuestManager::instance().SellItem(ch->GetPlayerID(), pkShop->GetNPCVnum(), item);
-	}
-#endif
-
-	if (wCount == item->GetCount())
-		ITEM_MANAGER::instance().RemoveItem(item, "SELL");
-	else
-		item->SetCount(item->GetCount() - wCount);
-
-	// 군주 시스템 : 세금 징수
-	CMonarch::instance().SendtoDBAddMoney(dwTax, ch->GetEmpire(), ch);
-
-	ch->PointChange(POINT_GOLD, dwPrice, false);
-}
-
-bool CompareShopItemName(const SShopItemTable& lhs, const SShopItemTable& rhs)
-{
-	TItemTable* lItem = ITEM_MANAGER::instance().GetTable(lhs.vnum);
-	TItemTable* rItem = ITEM_MANAGER::instance().GetTable(rhs.vnum);
-	if (lItem && rItem)
-		return strcmp(lItem->szLocaleName, rItem->szLocaleName) < 0;
-	else
-		return true;
-}
-
-#if defined(__SHOPEX_RENEWAL__)
-bool CompareShopItemVnum(const SShopItemTable& lhs, const SShopItemTable& rhs)
-{
-	return lhs.vnum > rhs.vnum;
-}
-
-bool CompareShopItemPrice(const SShopItemTable& lhs, const SShopItemTable& rhs)
-{
-	return lhs.price > rhs.price;
-}
-
-bool CompareShopItemType(const SShopItemTable& lhs, const SShopItemTable& rhs)
-{
-	const TItemTable* lItem = ITEM_MANAGER::instance().GetTable(lhs.vnum);
-	const TItemTable* rItem = ITEM_MANAGER::instance().GetTable(rhs.vnum);
-	return (lItem && rItem) ? lItem->bType > rItem->bType : true;
-}
-#endif
-
-static bool iequals(const std::string& a, const std::string& b)
-{
-	return std::equal(a.begin(), a.end(),
-		b.begin(), b.end(),
-		[](char a, char b) {
-			return tolower(a) == tolower(b);
-		});
-}
-
-bool ConvertToShopItemTable(IN CGroupNode* pNode, OUT TShopTableEx& shopTable)
-{
-	if (!pNode->GetValue("vnum", 0, shopTable.dwVnum))
-	{
-		sys_err("Group %s does not have vnum.", pNode->GetNodeName().c_str());
-		return false;
-	}
-
-	if (!pNode->GetValue("name", 0, shopTable.name))
-	{
-		sys_err("Group %s does not have name.", pNode->GetNodeName().c_str());
-		return false;
-	}
-
-	if (shopTable.name.length() >= SHOP_TAB_NAME_MAX)
-	{
-		sys_err("Shop name length must be less than %d. Error in Group %s, name %s", SHOP_TAB_NAME_MAX, pNode->GetNodeName().c_str(), shopTable.name.c_str());
-		return false;
-	}
-
-	std::string stCoinType;
-	if (!pNode->GetValue("cointype", 0, stCoinType))
-	{
-		stCoinType = "Gold";
-	}
-
-	if (iequals(stCoinType, "Gold"))
-	{
-		shopTable.coinType = SHOP_COIN_TYPE_GOLD;
-	}
-	else if (iequals(stCoinType, "SecondaryCoin"))
-	{
-		shopTable.coinType = SHOP_COIN_TYPE_SECONDARY_COIN;
-	}
-	else
-	{
-		sys_err("Group %s has undefine cointype(%s).", pNode->GetNodeName().c_str(), stCoinType.c_str());
-		return false;
-	}
-
-	CGroupNode* pItemGroup = pNode->GetChildNode("items");
-	if (!pItemGroup)
-	{
-		sys_err("Group %s does not have 'group items'.", pNode->GetNodeName().c_str());
-		return false;
-	}
-
-	size_t itemGroupSize = pItemGroup->GetRowCount();
-	std::vector<TShopItemTable> shopItems(itemGroupSize);
-	if (itemGroupSize >= SHOP_HOST_ITEM_MAX_NUM)
-	{
-		sys_err("count(%d) of rows of group items of group %s must be smaller than %d", itemGroupSize, pNode->GetNodeName().c_str(), SHOP_HOST_ITEM_MAX_NUM);
-		return false;
-	}
-
-	for (size_t i = 0; i < itemGroupSize; i++)
-	{
-		if (!pItemGroup->GetValue(i, "vnum", shopItems[i].vnum))
-		{
-			sys_err("row(%d) of group items of group %s does not have vnum column", i, pNode->GetNodeName().c_str());
-			return false;
-		}
-
-		if (!pItemGroup->GetValue(i, "count", shopItems[i].count))
-		{
-			sys_err("row(%d) of group items of group %s does not have count column", i, pNode->GetNodeName().c_str());
-			return false;
-		}
-
-		if (!pItemGroup->GetValue(i, "price", shopItems[i].price))
-		{
-			sys_err("row(%d) of group items of group %s does not have price column", i, pNode->GetNodeName().c_str());
-			return false;
-		}
-
-		// NOTE : Set the item price to the default item proto shop buy price.
-		if (shopItems[i].price == 0)
-		{
-			TItemTable* itemTable = ITEM_MANAGER::instance().GetTable(shopItems[i].vnum);
-			if (itemTable != NULL)
-				shopItems[i].price = itemTable->dwShopBuyPrice * shopItems[i].count;
-		}
-
-#if defined(__SHOPEX_RENEWAL__)
-		if (shopItems[i].bPriceType >= SHOP_COIN_MAX_TYPE)
-		{
-			sys_err("row(%d) of group items of group %s price_type is wrong!", i, pNode->GetNodeName().c_str());
-			return false;
-		}
-
-		char getval[20];
-		for (int j = 0; j < ITEM_SOCKET_MAX_NUM; j++)
-		{
-			snprintf(getval, sizeof(getval), "socket%d", j);
-			if (!pItemGroup->GetValue(i, getval, shopItems[i].alSockets[j]))
-			{
-				sys_err("row(%d) stage %d of group items of group %s does not have socket column", i, j, pNode->GetNodeName().c_str());
-				return false;
-			}
-		}
-
-		if (pItemGroup->GetValue(i, "price_type", shopItems[i].bPriceType) &&
-			pItemGroup->GetValue(i, "price_vnum", shopItems[i].dwPriceVnum) &&
-			shopItems[i].bPriceType == SHOP_COIN_TYPE_ITEM)
-		{
-			if (!ITEM_MANAGER::instance().GetTable(shopItems[i].dwPriceVnum))
-			{
-				sys_err("CANNOT GET ITEM PROTO %d", shopItems[i].dwPriceVnum);
-				return false;
-			}
-		}
-#endif
-	}
-
-	std::string stSort;
-	if (!pNode->GetValue("sort", 0, stSort))
-		stSort = "None";
-
-	if (iequals(stSort, "Asc"))
-		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemName);
-	else if (iequals(stSort, "Desc"))
-		std::sort(shopItems.rbegin(), shopItems.rend(), CompareShopItemName);
-#if defined(__SHOPEX_RENEWAL__)
-	else if (iequals(stSort, "Vnum"))
-		std::sort(shopItems.rbegin(), shopItems.rend(), CompareShopItemVnum);
-	else if (iequals(stSort, "Price"))
-		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemPrice);
-	else if (iequals(stSort, "Name"))
-		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemName);
-	else if (iequals(stSort, "Type"))
-		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemType);
-#endif
-
-	CGrid grid = CGrid(CShop::SHOP_GRID_WIDTH, CShop::SHOP_GRID_HEIGHT);
-	int iPos;
-
-	memset(&shopTable.items[0], 0, sizeof(shopTable.items));
-
-	for (size_t i = 0; i < shopItems.size(); i++)
-	{
-		TItemTable* item_table = ITEM_MANAGER::instance().GetTable(shopItems[i].vnum);
-		if (!item_table)
-		{
-			sys_err("vnum(%d) of group items of group %s does not exist", shopItems[i].vnum, pNode->GetNodeName().c_str());
-			return false;
-		}
-
-		iPos = grid.FindBlank(1, item_table->bSize);
-
-		grid.Put(iPos, 1, item_table->bSize);
-		shopTable.items[iPos] = shopItems[i];
-	}
-
-	shopTable.bItemCount = shopItems.size();
-	return true;
-}
-
-bool CShopManager::ReadShopTableEx(const char* stFileName)
-{
-	// file 유무 체크.
-	// 없는 경우는 에러로 처리하지 않는다.
-	FILE* fp = fopen(stFileName, "rb");
-	if (NULL == fp)
-		return true;
-	fclose(fp);
-
-	CGroupTextParseTreeLoader loader;
-	if (!loader.Load(stFileName))
-	{
-		sys_err("%s Load fail.", stFileName);
-		return false;
-	}
-
-	CGroupNode* pShopNPCGroup = loader.GetGroup("shopnpc");
-	if (NULL == pShopNPCGroup)
-	{
-		sys_err("Group ShopNPC is not exist.");
-		return false;
-	}
-
-	typedef std::multimap <DWORD, TShopTableEx> TMapNPCshop;
-	TMapNPCshop map_npcShop;
-
-#if defined(__SHOPEX_RENEWAL__)
-	{
-		std::unordered_set<CShop*> v;
-		// include unordered_set
-		auto ExDelete = [&v](TShopMap& c)
-		{
-			for (auto it = c.begin(); !c.empty() && it != c.end();)
-			{
-				const auto shop = it->second;
-				if (shop && shop->IsShopEx())
-				{
-					it = c.erase(it);
-					v.insert(shop);
-				}
-				else
-					++it;
-			}
-		};
-		ExDelete(m_map_pkShopByNPCVnum);
-		ExDelete(m_map_pkShop);
-		for (const auto& del : v)
-			delete del;
-	}
-#endif
-
-	for (size_t i = 0; i < pShopNPCGroup->GetRowCount(); i++)
-	{
-		DWORD npcVnum;
-		std::string shopName;
-		if (!pShopNPCGroup->GetValue(i, "npc", npcVnum) || !pShopNPCGroup->GetValue(i, "group", shopName))
-		{
-			sys_err("Invalid row(%d). Group ShopNPC rows must have 'npc', 'group' columns", i);
-			return false;
-		}
-		std::transform(shopName.begin(), shopName.end(), shopName.begin(), (int(*)(int))std::tolower);
-		CGroupNode* pShopGroup = loader.GetGroup(shopName.c_str());
-		if (!pShopGroup)
-		{
-			sys_err("Group %s is not exist.", shopName.c_str());
-			return false;
-		}
-		TShopTableEx table;
-		if (!ConvertToShopItemTable(pShopGroup, table))
-		{
-			sys_err("Cannot read Group %s.", shopName.c_str());
-			return false;
-		}
-		if (m_map_pkShopByNPCVnum.find(npcVnum) != m_map_pkShopByNPCVnum.end())
-		{
-			sys_err("%d cannot have both original shop and extended shop", npcVnum);
-			return false;
-		}
-
-		map_npcShop.insert(TMapNPCshop::value_type(npcVnum, table));
-	}
-
-	for (TMapNPCshop::iterator it = map_npcShop.begin(); it != map_npcShop.end(); ++it)
-	{
-		DWORD npcVnum = it->first;
-		TShopTableEx& table = it->second;
-		if (m_map_pkShop.find(table.dwVnum) != m_map_pkShop.end())
-		{
-			sys_err("Shop vnum(%d) already exists", table.dwVnum);
-			return false;
-		}
-		TShopMap::iterator shop_it = m_map_pkShopByNPCVnum.find(npcVnum);
-
-		LPSHOPEX pkShopEx = NULL;
-		if (m_map_pkShopByNPCVnum.end() == shop_it)
-		{
-			pkShopEx = M2_NEW CShopEx;
-			pkShopEx->Create(0, npcVnum);
-			m_map_pkShopByNPCVnum.insert(TShopMap::value_type(npcVnum, pkShopEx));
-		}
-		else
-		{
-			pkShopEx = dynamic_cast <CShopEx*> (shop_it->second);
-			if (NULL == pkShopEx)
-			{
-				sys_err("WTF!!! It can't be happend. NPC(%d) Shop is not extended version.", shop_it->first);
-				return false;
-			}
-		}
-
-		if (pkShopEx->GetTabCount() >= SHOP_TAB_COUNT_MAX)
-		{
-			sys_err("ShopEx cannot have tab more than %d", SHOP_TAB_COUNT_MAX);
-			return false;
-		}
-
-		if (m_map_pkShop.find(table.dwVnum) != m_map_pkShop.end())
-		{
-			sys_err("Shop vnum(%d) already exist.", table.dwVnum);
-			return false;
-		}
-		m_map_pkShop.insert(TShopMap::value_type(table.dwVnum, pkShopEx));
-		pkShopEx->AddShopTable(table);
-	}
-
-	return true;
-}
+#include "stdafx.h"
+#include "../../libgame/include/grid.h"
+#include "constants.h"
+#include "utils.h"
+#include "config.h"
+#include "shop.h"
+#include "desc.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "item.h"
+#include "item_manager.h"
+#include "buffer_manager.h"
+#include "packet.h"
+#include "log.h"
+#include "db.h"
+#include "questmanager.h"
+#include "monarch.h"
+#include "mob_manager.h"
+#include "locale_service.h"
+#include "desc_client.h"
+#include "shop_manager.h"
+#include "group_text_parse_tree.h"
+#include "shopEx.h"
+#include "shop_manager.h"
+#include <cctype>
+
+CShopManager::CShopManager()
+{
+}
+
+CShopManager::~CShopManager()
+{
+	Destroy();
+}
+
+bool CShopManager::Initialize(TShopTable* table, int size)
+{
+	if (!m_map_pkShop.empty())
+		return false;
+
+	int i;
+
+	for (i = 0; i < size; ++i, ++table)
+	{
+		LPSHOP shop = M2_NEW CShop;
+
+		if (!shop->Create(table->dwVnum, table->dwNPCVnum, table->items))
+		{
+			M2_DELETE(shop);
+			continue;
+		}
+
+		m_map_pkShop.insert(TShopMap::value_type(table->dwVnum, shop));
+		m_map_pkShopByNPCVnum.insert(TShopMap::value_type(table->dwNPCVnum, shop));
+	}
+
+	char szShopTableExFileName[256];
+	snprintf(szShopTableExFileName, sizeof(szShopTableExFileName),
+		"%s/shop_table_ex.txt", LocaleService_GetBasePath().c_str());
+
+	return ReadShopTableEx(szShopTableExFileName);
+}
+
+void CShopManager::Destroy()
+{
+	TShopMap::iterator it = m_map_pkShop.begin();
+	std::unordered_set<decltype(m_map_pkShop)::value_type::second_type> collector; // avoid delete duplicate objects(unique key)
+	while (it != m_map_pkShop.end())
+	{
+		//delete it->second;
+		collector.insert(it->second);
+		++it;
+	}
+	for (auto& v : collector)
+		delete v;
+
+	m_map_pkShop.clear();
+}
+
+LPSHOP CShopManager::Get(DWORD dwVnum)
+{
+	TShopMap::const_iterator it = m_map_pkShop.find(dwVnum);
+
+	if (it == m_map_pkShop.end())
+		return NULL;
+
+	return (it->second);
+}
+
+LPSHOP CShopManager::GetByNPCVnum(DWORD dwVnum)
+{
+	TShopMap::const_iterator it = m_map_pkShopByNPCVnum.find(dwVnum);
+
+	if (it == m_map_pkShopByNPCVnum.end())
+		return NULL;
+
+	return (it->second);
+}
+
+/*
+* 決 獨
+*/
+
+//  킹 
+bool CShopManager::StartShopping(LPCHARACTER pkChr, LPCHARACTER pkChrShopKeeper, int iShopVnum)
+{
+#if defined(__QUEST_EVENT_BUY_SELL__)
+	if (pkChr->GetShop())
+		return false;
+#endif
+
+	if (pkChr->GetShopOwner() == pkChrShopKeeper)
+		return false;
+
+	// this method is only for NPC
+	if (pkChrShopKeeper->IsPC())
+		return false;
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (pkChr->GetActiveGrowthPet())
+	{
+		pkChr->ChatPacket(CHAT_TYPE_INFO, "You cannot open a private shop whilst summoning your pet.");
+		return false;
+	}
+	
+	if (pkChr->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || pkChr->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		pkChr->ChatPacket(CHAT_TYPE_INFO, "While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc.");
+		return false;
+	}
+#endif
+
+	// PREVENT_TRADE_WINDOW
+	if (pkChr->PreventTradeWindow(WND_SHOPOWNER, true/*except*/))
+	{
+		pkChr->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 킹창 쩔 킹 寗  求."));
+		return false;
+	}
+	// END_PREVENT_TRADE_WINDOW
+
+	long distance = DISTANCE_APPROX(pkChr->GetX() - pkChrShopKeeper->GetX(), pkChr->GetY() - pkChrShopKeeper->GetY());
+
+	if (distance >= SHOP_MAX_DISTANCE)
+	{
+		sys_log(1, "SHOP: TOO_FAR: %s distance %d", pkChr->GetName(), distance);
+		return false;
+	}
+
+	LPSHOP pkShop;
+
+	if (iShopVnum)
+		pkShop = Get(iShopVnum);
+	else
+		pkShop = GetByNPCVnum(pkChrShopKeeper->GetRaceNum());
+
+	if (!pkShop)
+	{
+		sys_log(1, "SHOP: NO SHOP");
+		return false;
+	}
+
+	bool bOtherEmpire = false;
+
+	if (pkChr->GetEmpire() != pkChrShopKeeper->GetEmpire())
+		bOtherEmpire = true;
+
+	pkShop->AddGuest(pkChr, pkChrShopKeeper->GetVID(), bOtherEmpire);
+	pkChr->SetShopOwner(pkChrShopKeeper);
+	sys_log(0, "SHOP: START: %s", pkChr->GetName());
+	return true;
+}
+
+LPSHOP CShopManager::FindPCShop(DWORD dwVID)
+{
+	TShopMap::iterator it = m_map_pkShopByPC.find(dwVID);
+
+	if (it == m_map_pkShopByPC.end())
+		return NULL;
+
+	return it->second;
+}
+
+LPSHOP CShopManager::CreatePCShop(LPCHARACTER ch, TShopItemTable* pTable, BYTE bItemCount)
+{
+	if (FindPCShop(ch->GetVID()))
+		return NULL;
+
+	LPSHOP pkShop = M2_NEW CShop;
+	pkShop->SetPCShop(ch);
+	pkShop->SetShopItems(pTable, bItemCount);
+
+	m_map_pkShopByPC.insert(TShopMap::value_type(ch->GetVID(), pkShop));
+	return pkShop;
+}
+
+void CShopManager::DestroyPCShop(LPCHARACTER ch)
+{
+	LPSHOP pkShop = FindPCShop(ch->GetVID());
+
+	if (!pkShop)
+		return;
+
+	// PREVENT_ITEM_COPY;
+	ch->SetMyShopTime();
+	// END_PREVENT_ITEM_COPY
+
+	m_map_pkShopByPC.erase(ch->GetVID());
+	M2_DELETE(pkShop);
+}
+
+//  킹 
+void CShopManager::StopShopping(LPCHARACTER ch)
+{
+	LPSHOP shop;
+
+	if (!(shop = ch->GetShop()))
+		return;
+
+	// PREVENT_ITEM_COPY;
+	ch->SetMyShopTime();
+	// END_PREVENT_ITEM_COPY
+
+	shop->RemoveGuest(ch);
+	sys_log(0, "SHOP: END: %s", ch->GetName());
+}
+
+//  
+void CShopManager::Buy(LPCHARACTER ch, BYTE pos)
+{
+	if (!ch->GetShop())
+		return;
+
+	if (!ch->GetShopOwner())
+		return;
+
+	if (DISTANCE_APPROX(ch->GetX() - ch->GetShopOwner()->GetX(), ch->GetY() - ch->GetShopOwner()->GetY()) > 2000)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 타 賈 羚    求."));
+		return;
+	}
+
+	CShop* pkShop = ch->GetShop();
+	if (!pkShop)
+		return;
+
+	// PREVENT_ITEM_COPY
+	ch->SetMyShopTime();
+	// END_PREVENT_ITEM_COPY
+
+	int ret = pkShop->Buy(ch, pos);
+
+	if (SHOP_SUBHEADER_GC_OK != ret) //  羚 .
+	{
+		TPacketGCShop pack;
+
+		pack.header = HEADER_GC_SHOP;
+		pack.subheader = ret;
+		pack.size = sizeof(TPacketGCShop);
+
+		ch->GetDesc()->Packet(&pack, sizeof(pack));
+	}
+}
+
+void CShopManager::Sell(LPCHARACTER ch, WORD wCell, WORD wCount, BYTE bType)
+{
+	if (!ch->GetShop())
+		return;
+
+	if (!ch->GetShopOwner())
+		return;
+
+	if (!ch->CanHandleItem())
+		return;
+
+	if (ch->GetShop()->IsPCShop())
+		return;
+
+	if (DISTANCE_APPROX(ch->GetX() - ch->GetShopOwner()->GetX(), ch->GetY() - ch->GetShopOwner()->GetY()) > 2000)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 타 賈 羚    求."));
+		return;
+	}
+
+	LPITEM item = ch->GetInventoryItem(wCell);
+
+	if (!item)
+		return;
+
+	if (item->IsEquipped() == true)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   퓔  求."));
+		return;
+	}
+
+	if (true == item->isLocked())
+		return;
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (item->IsPet())
+		return;
+#endif
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (item->IsSealed())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot sell a soulbound item."));
+		return;
+	}
+#endif
+
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_SELL))
+		return;
+
+	DWORD dwPrice;
+
+	if (wCount == 0 || wCount > item->GetCount())
+		wCount = item->GetCount();
+
+	dwPrice = item->GetShopSellPrice();
+
+	if (IS_SET(item->GetFlag(), ITEM_FLAG_COUNT_PER_1GOLD))
+	{
+		if (dwPrice == 0)
+			dwPrice = wCount;
+		else
+			dwPrice = wCount / dwPrice;
+	}
+	else
+		dwPrice *= wCount;
+
+	dwPrice /= 5;
+
+	//  
+	DWORD dwTax = 0;
+	int iVal = 3;
+
+	dwTax = dwPrice * iVal / 100;
+	dwPrice -= dwTax;
+
+	if (test_server)
+		sys_log(0, "Sell Item price id %d %s itemid %d", ch->GetPlayerID(), ch->GetName(), item->GetID());
+
+	const int64_t nTotalMoney = static_cast<int64_t>(ch->GetGold()) + static_cast<int64_t>(dwPrice);
+	if (GOLD_MAX <= nTotalMoney)
+	{
+		sys_err("[OVERFLOW_GOLD] id %u name %s gold %d", ch->GetPlayerID(), ch->GetName(), ch->GetGold());
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("20 歌臼 품 횝 求."));
+		return;
+	}
+
+	// 20050802.myevan. 퓔 慣六  ID 煞
+	sys_log(0, "SHOP: SELL: %s item name: %s(x%d):%u price: %u", ch->GetName(), item->GetName(), wCount, item->GetID(), dwPrice);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	ch->UpdateExtBattlePassMissionProgress(BP_ITEM_SELL, wCount, item->GetVnum());
+#endif
+
+	if (iVal > 0)
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("퓔킥附 %d %%   鍍絳求", iVal));
+
+	DBManager::instance().SendMoneyLog(MONEY_LOG_SHOP, item->GetVnum(), dwPrice);
+
+#if defined(__QUEST_EVENT_BUY_SELL__)
+	CShop* pkShop = ch->GetShop();
+	if (pkShop)
+	{
+		ch->SetQuestNPCID(ch->GetShopOwner() ? ch->GetShopOwner()->GetVID() : 0);
+		quest::CQuestManager::instance().SellItem(ch->GetPlayerID(), pkShop->GetNPCVnum(), item);
+	}
+#endif
+
+	if (wCount == item->GetCount())
+		ITEM_MANAGER::instance().RemoveItem(item, "SELL");
+	else
+		item->SetCount(item->GetCount() - wCount);
+
+	//  첵 :  징
+	CMonarch::instance().SendtoDBAddMoney(dwTax, ch->GetEmpire(), ch);
+
+	ch->PointChange(POINT_GOLD, dwPrice, false);
+}
+
+bool CompareShopItemName(const SShopItemTable& lhs, const SShopItemTable& rhs)
+{
+	TItemTable* lItem = ITEM_MANAGER::instance().GetTable(lhs.vnum);
+	TItemTable* rItem = ITEM_MANAGER::instance().GetTable(rhs.vnum);
+	if (lItem && rItem)
+		return strcmp(lItem->szLocaleName, rItem->szLocaleName) < 0;
+	else
+		return true;
+}
+
+#if defined(__SHOPEX_RENEWAL__)
+bool CompareShopItemVnum(const SShopItemTable& lhs, const SShopItemTable& rhs)
+{
+	return lhs.vnum > rhs.vnum;
+}
+
+bool CompareShopItemPrice(const SShopItemTable& lhs, const SShopItemTable& rhs)
+{
+	return lhs.price > rhs.price;
+}
+
+bool CompareShopItemType(const SShopItemTable& lhs, const SShopItemTable& rhs)
+{
+	const TItemTable* lItem = ITEM_MANAGER::instance().GetTable(lhs.vnum);
+	const TItemTable* rItem = ITEM_MANAGER::instance().GetTable(rhs.vnum);
+	return (lItem && rItem) ? lItem->bType > rItem->bType : true;
+}
+#endif
+
+static bool iequals(const std::string& a, const std::string& b)
+{
+	return std::equal(a.begin(), a.end(),
+		b.begin(), b.end(),
+		[](char a, char b) {
+			return tolower(a) == tolower(b);
+		});
+}
+
+bool ConvertToShopItemTable(IN CGroupNode* pNode, OUT TShopTableEx& shopTable)
+{
+	if (!pNode->GetValue("vnum", 0, shopTable.dwVnum))
+	{
+		sys_err("Group %s does not have vnum.", pNode->GetNodeName().c_str());
+		return false;
+	}
+
+	if (!pNode->GetValue("name", 0, shopTable.name))
+	{
+		sys_err("Group %s does not have name.", pNode->GetNodeName().c_str());
+		return false;
+	}
+
+	if (shopTable.name.length() >= SHOP_TAB_NAME_MAX)
+	{
+		sys_err("Shop name length must be less than %d. Error in Group %s, name %s", SHOP_TAB_NAME_MAX, pNode->GetNodeName().c_str(), shopTable.name.c_str());
+		return false;
+	}
+
+	std::string stCoinType;
+	if (!pNode->GetValue("cointype", 0, stCoinType))
+	{
+		stCoinType = "Gold";
+	}
+
+	if (iequals(stCoinType, "Gold"))
+	{
+		shopTable.coinType = SHOP_COIN_TYPE_GOLD;
+	}
+	else if (iequals(stCoinType, "SecondaryCoin"))
+	{
+		shopTable.coinType = SHOP_COIN_TYPE_SECONDARY_COIN;
+	}
+	else
+	{
+		sys_err("Group %s has undefine cointype(%s).", pNode->GetNodeName().c_str(), stCoinType.c_str());
+		return false;
+	}
+
+	CGroupNode* pItemGroup = pNode->GetChildNode("items");
+	if (!pItemGroup)
+	{
+		sys_err("Group %s does not have 'group items'.", pNode->GetNodeName().c_str());
+		return false;
+	}
+
+	size_t itemGroupSize = pItemGroup->GetRowCount();
+	std::vector<TShopItemTable> shopItems(itemGroupSize);
+	if (itemGroupSize >= SHOP_HOST_ITEM_MAX_NUM)
+	{
+		sys_err("count(%d) of rows of group items of group %s must be smaller than %d", itemGroupSize, pNode->GetNodeName().c_str(), SHOP_HOST_ITEM_MAX_NUM);
+		return false;
+	}
+
+	for (size_t i = 0; i < itemGroupSize; i++)
+	{
+		if (!pItemGroup->GetValue(i, "vnum", shopItems[i].vnum))
+		{
+			sys_err("row(%d) of group items of group %s does not have vnum column", i, pNode->GetNodeName().c_str());
+			return false;
+		}
+
+		if (!pItemGroup->GetValue(i, "count", shopItems[i].count))
+		{
+			sys_err("row(%d) of group items of group %s does not have count column", i, pNode->GetNodeName().c_str());
+			return false;
+		}
+
+		if (!pItemGroup->GetValue(i, "price", shopItems[i].price))
+		{
+			sys_err("row(%d) of group items of group %s does not have price column", i, pNode->GetNodeName().c_str());
+			return false;
+		}
+
+		// NOTE : Set the item price to the default item proto shop buy price.
+		if (shopItems[i].price == 0)
+		{
+			TItemTable* itemTable = ITEM_MANAGER::instance().GetTable(shopItems[i].vnum);
+			if (itemTable != NULL)
+				shopItems[i].price = itemTable->dwShopBuyPrice * shopItems[i].count;
+		}
+
+#if defined(__SHOPEX_RENEWAL__)
+		if (shopItems[i].bPriceType >= SHOP_COIN_MAX_TYPE)
+		{
+			sys_err("row(%d) of group items of group %s price_type is wrong!", i, pNode->GetNodeName().c_str());
+			return false;
+		}
+
+		char getval[20];
+		for (int j = 0; j < ITEM_SOCKET_MAX_NUM; j++)
+		{
+			snprintf(getval, sizeof(getval), "socket%d", j);
+			if (!pItemGroup->GetValue(i, getval, shopItems[i].alSockets[j]))
+			{
+				sys_err("row(%d) stage %d of group items of group %s does not have socket column", i, j, pNode->GetNodeName().c_str());
+				return false;
+			}
+		}
+
+		if (pItemGroup->GetValue(i, "price_type", shopItems[i].bPriceType) &&
+			pItemGroup->GetValue(i, "price_vnum", shopItems[i].dwPriceVnum) &&
+			shopItems[i].bPriceType == SHOP_COIN_TYPE_ITEM)
+		{
+			if (!ITEM_MANAGER::instance().GetTable(shopItems[i].dwPriceVnum))
+			{
+				sys_err("CANNOT GET ITEM PROTO %d", shopItems[i].dwPriceVnum);
+				return false;
+			}
+		}
+#endif
+	}
+
+	std::string stSort;
+	if (!pNode->GetValue("sort", 0, stSort))
+		stSort = "None";
+
+	if (iequals(stSort, "Asc"))
+		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemName);
+	else if (iequals(stSort, "Desc"))
+		std::sort(shopItems.rbegin(), shopItems.rend(), CompareShopItemName);
+#if defined(__SHOPEX_RENEWAL__)
+	else if (iequals(stSort, "Vnum"))
+		std::sort(shopItems.rbegin(), shopItems.rend(), CompareShopItemVnum);
+	else if (iequals(stSort, "Price"))
+		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemPrice);
+	else if (iequals(stSort, "Name"))
+		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemName);
+	else if (iequals(stSort, "Type"))
+		std::sort(shopItems.begin(), shopItems.end(), CompareShopItemType);
+#endif
+
+	CGrid grid = CGrid(CShop::SHOP_GRID_WIDTH, CShop::SHOP_GRID_HEIGHT);
+	int iPos;
+
+	memset(&shopTable.items[0], 0, sizeof(shopTable.items));
+
+	for (size_t i = 0; i < shopItems.size(); i++)
+	{
+		TItemTable* item_table = ITEM_MANAGER::instance().GetTable(shopItems[i].vnum);
+		if (!item_table)
+		{
+			sys_err("vnum(%d) of group items of group %s does not exist", shopItems[i].vnum, pNode->GetNodeName().c_str());
+			return false;
+		}
+
+		iPos = grid.FindBlank(1, item_table->bSize);
+
+		grid.Put(iPos, 1, item_table->bSize);
+		shopTable.items[iPos] = shopItems[i];
+	}
+
+	shopTable.bItemCount = shopItems.size();
+	return true;
+}
+
+bool CShopManager::ReadShopTableEx(const char* stFileName)
+{
+	// file  체크.
+	//    처 苛쨈.
+	FILE* fp = fopen(stFileName, "rb");
+	if (NULL == fp)
+		return true;
+	fclose(fp);
+
+	CGroupTextParseTreeLoader loader;
+	if (!loader.Load(stFileName))
+	{
+		sys_err("%s Load fail.", stFileName);
+		return false;
+	}
+
+	CGroupNode* pShopNPCGroup = loader.GetGroup("shopnpc");
+	if (NULL == pShopNPCGroup)
+	{
+		sys_err("Group ShopNPC is not exist.");
+		return false;
+	}
+
+	typedef std::multimap <DWORD, TShopTableEx> TMapNPCshop;
+	TMapNPCshop map_npcShop;
+
+#if defined(__SHOPEX_RENEWAL__)
+	{
+		std::unordered_set<CShop*> v;
+		// include unordered_set
+		auto ExDelete = [&v](TShopMap& c)
+		{
+			for (auto it = c.begin(); !c.empty() && it != c.end();)
+			{
+				const auto shop = it->second;
+				if (shop && shop->IsShopEx())
+				{
+					it = c.erase(it);
+					v.insert(shop);
+				}
+				else
+					++it;
+			}
+		};
+		ExDelete(m_map_pkShopByNPCVnum);
+		ExDelete(m_map_pkShop);
+		for (const auto& del : v)
+			delete del;
+	}
+#endif
+
+	for (size_t i = 0; i < pShopNPCGroup->GetRowCount(); i++)
+	{
+		DWORD npcVnum;
+		std::string shopName;
+		if (!pShopNPCGroup->GetValue(i, "npc", npcVnum) || !pShopNPCGroup->GetValue(i, "group", shopName))
+		{
+			sys_err("Invalid row(%d). Group ShopNPC rows must have 'npc', 'group' columns", i);
+			return false;
+		}
+		std::transform(shopName.begin(), shopName.end(), shopName.begin(), (int(*)(int))std::tolower);
+		CGroupNode* pShopGroup = loader.GetGroup(shopName.c_str());
+		if (!pShopGroup)
+		{
+			sys_err("Group %s is not exist.", shopName.c_str());
+			return false;
+		}
+		TShopTableEx table;
+		if (!ConvertToShopItemTable(pShopGroup, table))
+		{
+			sys_err("Cannot read Group %s.", shopName.c_str());
+			return false;
+		}
+		if (m_map_pkShopByNPCVnum.find(npcVnum) != m_map_pkShopByNPCVnum.end())
+		{
+			sys_err("%d cannot have both original shop and extended shop", npcVnum);
+			return false;
+		}
+
+		map_npcShop.insert(TMapNPCshop::value_type(npcVnum, table));
+	}
+
+	for (TMapNPCshop::iterator it = map_npcShop.begin(); it != map_npcShop.end(); ++it)
+	{
+		DWORD npcVnum = it->first;
+		TShopTableEx& table = it->second;
+		if (m_map_pkShop.find(table.dwVnum) != m_map_pkShop.end())
+		{
+			sys_err("Shop vnum(%d) already exists", table.dwVnum);
+			return false;
+		}
+		TShopMap::iterator shop_it = m_map_pkShopByNPCVnum.find(npcVnum);
+
+		LPSHOPEX pkShopEx = NULL;
+		if (m_map_pkShopByNPCVnum.end() == shop_it)
+		{
+			pkShopEx = M2_NEW CShopEx;
+			pkShopEx->Create(0, npcVnum);
+			m_map_pkShopByNPCVnum.insert(TShopMap::value_type(npcVnum, pkShopEx));
+		}
+		else
+		{
+			pkShopEx = dynamic_cast <CShopEx*> (shop_it->second);
+			if (NULL == pkShopEx)
+			{
+				sys_err("WTF!!! It can't be happend. NPC(%d) Shop is not extended version.", shop_it->first);
+				return false;
+			}
+		}
+
+		if (pkShopEx->GetTabCount() >= SHOP_TAB_COUNT_MAX)
+		{
+			sys_err("ShopEx cannot have tab more than %d", SHOP_TAB_COUNT_MAX);
+			return false;
+		}
+
+		if (m_map_pkShop.find(table.dwVnum) != m_map_pkShop.end())
+		{
+			sys_err("Shop vnum(%d) already exist.", table.dwVnum);
+			return false;
+		}
+		m_map_pkShop.insert(TShopMap::value_type(table.dwVnum, pkShopEx));
+		pkShopEx->AddShopTable(table);
+	}
+
+	return true;
+}
diff --git a/sql.sql b/sql.sql
index 34b7835..4bb7328 100644
--- a/sql.sql
+++ b/sql.sql
@@ -2428,90 +2428,315 @@ UNLOCK TABLES;
 DROP TABLE IF EXISTS `growth_pet`;
 /*!40101 SET @saved_cs_client     = @@character_set_client */;
 /*!50503 SET character_set_client = utf8mb4 */;
-CREATE TABLE `growth_pet` (
-  `id` int NOT NULL,
-  `owner_id` int NOT NULL,
-  `vnum` int NOT NULL,
-  `state` enum('UPBRINGING','BAG','SAFEBOX') NOT NULL DEFAULT 'UPBRINGING',
-  `name` varchar(20) DEFAULT NULL,
-  `size` tinyint NOT NULL DEFAULT '0',
-  `level` int NOT NULL DEFAULT '1',
-  `level_step` tinyint NOT NULL DEFAULT '0',
-  `evolution` tinyint NOT NULL DEFAULT '1',
-  `type` tinyint DEFAULT NULL,
-  `hp` int NOT NULL DEFAULT '0',
-  `sp` int NOT NULL DEFAULT '0',
-  `def` int NOT NULL DEFAULT '0',
-  `hp_apply` tinyint NOT NULL DEFAULT '0',
-  `sp_apply` tinyint NOT NULL DEFAULT '0',
-  `def_apply` tinyint NOT NULL DEFAULT '0',
-  `age_apply` tinyint NOT NULL DEFAULT '0',
-  `skill_level` blob,
-  `exp` int NOT NULL DEFAULT '0',
-  `item_exp` int NOT NULL DEFAULT '0',
-  `birthday` datetime DEFAULT NULL,
-  `end_time` int NOT NULL DEFAULT '0',
-  `max_time` int NOT NULL DEFAULT '0',
-  PRIMARY KEY (`id`),
-  KEY `idx_owner_id` (`owner_id`)
-) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
-/*!40101 SET character_set_client = @saved_cs_client */;
-
---
--- Dumping data for table `growth_pet`
---
-
-LOCK TABLES `growth_pet` WRITE;
-/*!40000 ALTER TABLE `growth_pet` DISABLE KEYS */;
-/*!40000 ALTER TABLE `growth_pet` ENABLE KEYS */;
-UNLOCK TABLES;
+DROP TABLE IF EXISTS `growth_pet`;
+CREATE TABLE `growth_pet`  (
+  `id` int(0) NOT NULL,
+  `owner_id` int(0) NOT NULL,
+  `vnum` int(0) NOT NULL,
+  `state` enum('UPBRINGING','BAG','SAFEBOX') CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT 'UPBRINGING',
+  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
+  `size` tinyint(0) NOT NULL,
+  `level` int(0) NULL DEFAULT 1,
+  `level_step` tinyint(1) NULL DEFAULT 0,
+  `evolution` tinyint(1) NULL DEFAULT 1,
+  `type` tinyint(1) NULL DEFAULT NULL,
+  `hp` int(0) NULL DEFAULT 0,
+  `sp` int(0) NULL DEFAULT 0,
+  `def` int(0) NULL DEFAULT 0,
+  `hp_apply` tinyint(0) NULL DEFAULT 0,
+  `sp_apply` tinyint(0) NULL DEFAULT 0,
+  `def_apply` tinyint(0) NULL DEFAULT 0,
+  `age_apply` tinyint(0) NULL DEFAULT 0,
+  `skill_level` tinyblob NULL,
+  `exp` int(0) NULL DEFAULT NULL,
+  `item_exp` int(0) NULL DEFAULT NULL,
+  `birthday` datetime(0) NULL DEFAULT NULL,
+  `end_time` int(0) NULL DEFAULT 0,
+  `max_time` int(0) NULL DEFAULT NULL,
+  PRIMARY KEY (`id`) USING BTREE
+) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;
 
---
--- Table structure for table `growth_pet_skill_proto`
---
 
 DROP TABLE IF EXISTS `growth_pet_skill_proto`;
-/*!40101 SET @saved_cs_client     = @@character_set_client */;
-/*!50503 SET character_set_client = utf8mb4 */;
-CREATE TABLE `growth_pet_skill_proto` (
-  `dwPetVnum` int NOT NULL,
-  `dwSkillVnum` int NOT NULL,
-  `szName` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  `bType` enum('PASSIVE','AUTO') CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  `dwCooldown` int NOT NULL,
-  `setAffectFlag` enum('JIJOONG_WARRIOR','JIJOONG_SURA','JIJOONG_ASSASSIN','JIJOONG_SHAMAN','JIJOONG_WOLFMAN','PACHEON','BANYA','CHEONRYEONG','CHOEHOENBIMU','HEAL','STEALHP','STEALMP','BLOCK','REFLECT_MELEE','GOLD_DROP','BOW_DISTANCE','INVINCIBILITY','REMOVAL','POTION','MOB_BONUS','EXP','HP_RECOVER','FEATHER','STONE','BOSS','RESIST_SKILL','RESIST_DAMAGE') CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
-  `szPointOn` enum('RESIST_WARRIOR','RESIST_SURA','RESIST_ASSASSIN','RESIST_SHAMAN','RESIST_WOLFMAN','RESIST_MAGIC_REDUCTION','MELEE_MAGIC_ATT_BONUS_PER','ATTBONUS_MONSTER','PENETRATE_PCT','CASTING_SPEED','BOW_DISTANCE','STEAL_SP','STEAL_HP','KILL_HP_RECOVERY','BLOCK','REFLECT_MELEE','GOLD_DOUBLE_BONUS','EXP_DOUBLE_BONUS','POTION_BONUS','STONE_BONUS','BOSS_BONUS','RESIST_SKILL','RESIST_HIT') CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
-  `szPointPoly1` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  `szPointPoly2` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  `szPointPoly3` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  `szPointPoly4` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  `szPointPoly5` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  `szPointPoly6` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  `szPointPoly7` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  `szPointPoly8` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  `szActivatePctPoly` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  `szDurationPoly` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
-  PRIMARY KEY (`dwPetVnum`,`dwSkillVnum`) USING BTREE
-) ENGINE=MyISAM DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
-/*!40101 SET character_set_client = @saved_cs_client */;
+CREATE TABLE `growth_pet_skill_proto`  (
+  `dwPetVnum` int(11) NOT NULL,
+  `dwSkillVnum` int(11) NOT NULL,
+  `szName` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  `bType` enum('PASSIVE','AUTO') CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  `dwCooldown` int(3) NOT NULL,
+  `setAffectFlag` enum('JIJOONG_WARRIOR','JIJOONG_SURA','JIJOONG_ASSASSIN','JIJOONG_SHAMAN','JIJOONG_WOLFMAN','PACHEON','BANYA','CHEONRYEONG','CHOEHOENBIMU','HEAL','STEALHP','STEALMP','BLOCK','REFLECT_MELEE','GOLD_DROP','BOW_DISTANCE','INVINCIBILITY','REMOVAL','POTION','MOB_BONUS','EXP','HP_RECOVER','FEATHER','') CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
+  `szPointOn` enum('RESIST_WARRIOR','RESIST_SURA','RESIST_ASSASSIN','RESIST_SHAMAN','RESIST_WOLFMAN','RESIST_MAGIC_REDUCTION','MELEE_MAGIC_ATT_BONUS_PER','ATTBONUS_MONSTER','PENETRATE_PCT','CASTING_SPEED','BOW_DISTANCE','STEAL_SP','STEAL_HP','KILL_HP_RECOVERY','BLOCK','REFLECT_MELEE','GOLD_DOUBLE_BONUS','EXP_DOUBLE_BONUS','POTION_BONUS') CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
+  `szPointPoly1` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  `szPointPoly2` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  `szPointPoly3` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  `szPointPoly4` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  `szPointPoly5` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  `szPointPoly6` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  `szPointPoly7` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  `szPointPoly8` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  `szActivatePctPoly` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  `szDurationPoly` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
+  PRIMARY KEY (`dwPetVnum`, `dwSkillVnum`) USING BTREE
+) ENGINE = MyISAM CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
+
+-- ----------------------------
+-- Records of growth_pet_skill_proto
+-- ----------------------------
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 1, 'Resistance (Warrior)', 'PASSIVE', 0, 'JIJOONG_WARRIOR', 'RESIST_WARRIOR', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 2, 'Resistance (Sura)', 'PASSIVE', 0, 'JIJOONG_SURA', 'RESIST_SURA', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 3, 'Resistance (Ninja)', 'PASSIVE', 0, 'JIJOONG_ASSASSIN', 'RESIST_ASSASSIN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 4, 'Resistance (Shaman)', 'PASSIVE', 0, 'JIJOONG_SHAMAN', 'RESIST_SHAMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 5, 'Resistance (Lycan)', 'PASSIVE', 0, 'JIJOONG_WOLFMAN', 'RESIST_WOLFMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 6, 'Berserker', 'PASSIVE', 0, 'PACHEON', 'MELEE_MAGIC_ATT_BONUS_PER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 7, 'Anti-Magic', 'PASSIVE', 0, 'BANYA', 'RESIST_MAGIC_REDUCTION', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 8, 'Haste', 'PASSIVE', 0, 'CHEONRYEONG', 'CASTING_SPEED', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 9, 'Drill', 'PASSIVE', 0, 'CHOEHOENBIMU', 'PENETRATE_PCT', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 10, 'Restoration', 'AUTO', 480, 'HEAL', '', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '58', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 11, 'Vampirism', 'PASSIVE', 0, 'STEALHP', 'STEAL_HP', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 12, 'Spiritualism', 'PASSIVE', 0, 'STEALMP', 'STEAL_SP', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 13, 'Bulwark', 'PASSIVE', 0, 'BLOCK', 'BLOCK', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 14, 'Reflection', 'PASSIVE', 0, 'REFLECT_MELEE', 'REFLECT_MELEE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 15, 'Yang Drop', 'PASSIVE', 0, 'GOLD_DROP', 'GOLD_DOUBLE_BONUS', '10.6 + (k*3.339 + lv*1.1925)', '10.8 + (k*3.402 + lv*1.215)', '10.8 + (k*3.402 + lv*1.215)', '11.2 + (k*3.528 + lv*1.26)', '11.2 + (k*3.528 + lv*1.26)', '11.6 + (k*3.654 + lv*1.305)', '11.6 + (k*3.654 + lv*1.305)', '11.6 + (k*3.654 + lv*1.305)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 16, 'Range', 'PASSIVE', 0, 'BOW_DISTANCE', 'BOW_DISTANCE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 17, 'Immortal', 'AUTO', 600, 'INVINCIBILITY', '', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '53', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 18, 'Panacea', 'AUTO', 480, 'REMOVAL', '', '0', '0', '0', '0', '0', '0', '0', '0', '41', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 19, 'Master Brewer', 'PASSIVE', 0, 'POTION', 'POTION_BONUS', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 20, 'Monster Hunter', 'PASSIVE', 0, 'MOB_BONUS', 'ATTBONUS_MONSTER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 21, 'Eagle Eyes', 'PASSIVE', 0, 'EXP', 'EXP_DOUBLE_BONUS', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 22, 'Life Drain', 'PASSIVE', 0, 'HP_RECOVER', 'KILL_HP_RECOVERY', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55701, 23, 'Light as a Feather', 'AUTO', 10, 'FEATHER', '', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '44+ (k*0.455 + lv*0.1625)', '50 + (k*2.8 + lv*1)');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 1, 'Resistance (Warrior)', 'PASSIVE', 0, 'JIJOONG_WARRIOR', 'RESIST_WARRIOR', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 2, 'Resistance (Sura)', 'PASSIVE', 0, 'JIJOONG_SURA', 'RESIST_SURA', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 3, 'Resistance (Ninja)', 'PASSIVE', 0, 'JIJOONG_ASSASSIN', 'RESIST_ASSASSIN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 4, 'Resistance (Shaman)', 'PASSIVE', 0, 'JIJOONG_SHAMAN', 'RESIST_SHAMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 5, 'Resistance (Lycan)', 'PASSIVE', 0, 'JIJOONG_WOLFMAN', 'RESIST_WOLFMAN', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 6, 'Berserker', 'PASSIVE', 0, 'PACHEON', 'MELEE_MAGIC_ATT_BONUS_PER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 7, 'Anti-Magic', 'PASSIVE', 0, 'BANYA', 'RESIST_MAGIC_REDUCTION', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 8, 'Haste', 'PASSIVE', 0, 'CHEONRYEONG', 'CASTING_SPEED', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 9, 'Drill', 'PASSIVE', 0, 'CHOEHOENBIMU', 'PENETRATE_PCT', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 10, 'Restoration', 'AUTO', 480, 'HEAL', '', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '58', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 11, 'Vampirism', 'PASSIVE', 0, 'STEALHP', 'STEAL_HP', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 12, 'Spiritualism', 'PASSIVE', 0, 'STEALMP', 'STEAL_SP', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 13, 'Bulwark', 'PASSIVE', 0, 'BLOCK', 'BLOCK', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 14, 'Reflection', 'PASSIVE', 0, 'REFLECT_MELEE', 'REFLECT_MELEE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 15, 'Yang Drop', 'PASSIVE', 0, 'GOLD_DROP', 'GOLD_DOUBLE_BONUS', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 16, 'Range', 'PASSIVE', 0, 'BOW_DISTANCE', 'BOW_DISTANCE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 17, 'Immortal', 'AUTO', 600, 'INVINCIBILITY', '', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '10 + (k*0.665 + lv*0.2375)', '10 + (k*0.665 + lv*0.2375)', '10 + (k*0.665 + lv*0.2375)', '10 + (k*0.665 + lv*0.2375)', '53', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 18, 'Panacea', 'AUTO', 480, 'REMOVAL', '', '0', '0', '0', '0', '0', '0', '0', '0', '41', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 19, 'Master Brewer', 'PASSIVE', 0, 'POTION', 'POTION_BONUS', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 20, 'Monster Hunter', 'PASSIVE', 0, 'MOB_BONUS', 'ATTBONUS_MONSTER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 21, 'Eagle Eyes', 'PASSIVE', 0, 'EXP', 'EXP_DOUBLE_BONUS', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 22, 'Life Drain', 'PASSIVE', 0, 'HP_RECOVER', 'KILL_HP_RECOVERY', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55702, 23, 'Light as a Feather', 'AUTO', 180, 'FEATHER', '', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '44+ (k*0.455 + lv*0.1625)', '50 + (k*2.8 + lv*1)');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 1, 'Resistance (Warrior)', 'PASSIVE', 0, 'JIJOONG_WARRIOR', 'RESIST_WARRIOR', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 2, 'Resistance (Sura)', 'PASSIVE', 0, 'JIJOONG_SURA', 'RESIST_SURA', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 3, 'Resistance (Ninja)', 'PASSIVE', 0, 'JIJOONG_ASSASSIN', 'RESIST_ASSASSIN', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 4, 'Resistance (Shaman)', 'PASSIVE', 0, 'JIJOONG_SHAMAN', 'RESIST_SHAMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 5, 'Resistance (Lycan)', 'PASSIVE', 0, 'JIJOONG_WOLFMAN', 'RESIST_WOLFMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 6, 'Berserker', 'PASSIVE', 0, 'PACHEON', 'MELEE_MAGIC_ATT_BONUS_PER', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 7, 'Anti-Magic', 'PASSIVE', 0, 'BANYA', 'RESIST_MAGIC_REDUCTION', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 8, 'Haste', 'PASSIVE', 0, 'CHEONRYEONG', 'CASTING_SPEED', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 9, 'Drill', 'PASSIVE', 0, 'CHOEHOENBIMU', 'PENETRATE_PCT', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 10, 'Restoration', 'AUTO', 480, 'HEAL', '', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '58', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 11, 'Vampirism', 'PASSIVE', 0, 'STEALHP', 'STEAL_HP', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 12, 'Spiritualism', 'PASSIVE', 0, 'STEALMP', 'STEAL_SP', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 13, 'Bulwark', 'PASSIVE', 0, 'BLOCK', 'BLOCK', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 14, 'Reflection', 'PASSIVE', 0, 'REFLECT_MELEE', 'REFLECT_MELEE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 15, 'Yang Drop', 'PASSIVE', 0, 'GOLD_DROP', 'GOLD_DOUBLE_BONUS', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 16, 'Range', 'PASSIVE', 0, 'BOW_DISTANCE', 'BOW_DISTANCE', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 17, 'Immortal', 'AUTO', 600, 'INVINCIBILITY', '', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '53', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 18, 'Panacea', 'AUTO', 480, 'REMOVAL', '', '0', '0', '0', '0', '0', '0', '0', '0', '41', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 19, 'Master Brewer', 'PASSIVE', 0, 'POTION', 'POTION_BONUS', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 20, 'Monster Hunter', 'PASSIVE', 0, 'MOB_BONUS', 'ATTBONUS_MONSTER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 21, 'Eagle Eyes', 'PASSIVE', 0, 'EXP', 'EXP_DOUBLE_BONUS', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 22, 'Life Drain', 'PASSIVE', 0, 'HP_RECOVER', 'KILL_HP_RECOVERY', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55703, 23, 'Light as a Feather', 'AUTO', 180, 'FEATHER', '', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '44+ (k*0.455 + lv*0.1625)', '50 + (k*2.8 + lv*1)');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 1, 'Resistance (Warrior)', 'PASSIVE', 0, 'JIJOONG_WARRIOR', 'RESIST_WARRIOR', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 2, 'Resistance (Sura)', 'PASSIVE', 0, 'JIJOONG_SURA', 'RESIST_SURA', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 3, 'Resistance (Ninja)', 'PASSIVE', 0, 'JIJOONG_ASSASSIN', 'RESIST_ASSASSIN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 4, 'Resistance (Shaman)', 'PASSIVE', 0, 'JIJOONG_SHAMAN', 'RESIST_SHAMAN', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 5, 'Resistance (Lycan)', 'PASSIVE', 0, 'JIJOONG_WOLFMAN', 'RESIST_WOLFMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 6, 'Berserker', 'PASSIVE', 0, 'PACHEON', 'MELEE_MAGIC_ATT_BONUS_PER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 7, 'Anti-Magic', 'PASSIVE', 0, 'BANYA', 'RESIST_MAGIC_REDUCTION', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 8, 'Haste', 'PASSIVE', 0, 'CHEONRYEONG', 'CASTING_SPEED', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 9, 'Drill', 'PASSIVE', 0, 'CHOEHOENBIMU', 'PENETRATE_PCT', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 10, 'Restoration', 'AUTO', 480, 'HEAL', '', '713.3 + (k*224.689 + lv*80.2463)', '713.3 + (k*224.689 + lv*80.2463)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '733.3 + (k*230.99 + lv*82.4963)', '733.3 + (k*230.99 + lv*82.4963)', '733.3 + (k*230.99 + lv*82.4963)', '733.3 + (k*230.99 + lv*82.4963)', '58', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 11, 'Vampirism', 'PASSIVE', 0, 'STEALHP', 'STEAL_HP', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 12, 'Spiritualism', 'PASSIVE', 0, 'STEALMP', 'STEAL_SP', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 13, 'Bulwark', 'PASSIVE', 0, 'BLOCK', 'BLOCK', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 14, 'Reflection', 'PASSIVE', 0, 'REFLECT_MELEE', 'REFLECT_MELEE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 15, 'Yang Drop', 'PASSIVE', 0, 'GOLD_DROP', 'GOLD_DOUBLE_BONUS', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 16, 'Range', 'PASSIVE', 0, 'BOW_DISTANCE', 'BOW_DISTANCE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 17, 'Immortal', 'AUTO', 600, 'INVINCIBILITY', '', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '53', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 18, 'Panacea', 'AUTO', 480, 'REMOVAL', '', '0', '0', '0', '0', '0', '0', '0', '0', '41', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 19, 'Master Brewer', 'PASSIVE', 0, 'POTION', 'POTION_BONUS', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 20, 'Monster Hunter', 'PASSIVE', 0, 'MOB_BONUS', 'ATTBONUS_MONSTER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 21, 'Eagle Eyes', 'PASSIVE', 0, 'EXP', 'EXP_DOUBLE_BONUS', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 22, 'Life Drain', 'PASSIVE', 0, 'HP_RECOVER', 'KILL_HP_RECOVERY', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55704, 23, 'Light as a Feather', 'AUTO', 180, 'FEATHER', '', '162.5 + (k*5.6875 + lv*2.03125)', '162.5 + (k*5.6875 + lv*2.03125)', '262.5 + (k*9.1875 + lv*3.28125)', '262.5 + (k*9.1875 + lv*3.28125)', '337.5 + (k*11.8125 + lv*4.21875)', '337.5 + (k*11.8125 + lv*4.21875)', '387.5 + (k*13.5625 + lv*4.84375)', '387.5 + (k*13.5625 + lv*4.84375)', '44+ (k*0.455 + lv*0.1625)', '50 + (k*2.8 + lv*1)');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 1, 'Resistance (Warrior)', 'PASSIVE', 0, 'JIJOONG_WARRIOR', 'RESIST_WARRIOR', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 2, 'Resistance (Sura)', 'PASSIVE', 0, 'JIJOONG_SURA', 'RESIST_SURA', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 3, 'Resistance (Ninja)', 'PASSIVE', 0, 'JIJOONG_ASSASSIN', 'RESIST_ASSASSIN', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 4, 'Resistance (Shaman)', 'PASSIVE', 0, 'JIJOONG_SHAMAN', 'RESIST_SHAMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 5, 'Resistance (Lycan)', 'PASSIVE', 0, 'JIJOONG_WOLFMAN', 'RESIST_WOLFMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 6, 'Berserker', 'PASSIVE', 0, 'PACHEON', 'MELEE_MAGIC_ATT_BONUS_PER', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 7, 'Anti-Magic', 'PASSIVE', 0, 'BANYA', 'RESIST_MAGIC_REDUCTION', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 8, 'Haste', 'PASSIVE', 0, 'CHEONRYEONG', 'CASTING_SPEED', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 9, 'Drill', 'PASSIVE', 0, 'CHOEHOENBIMU', 'PENETRATE_PCT', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 10, 'Restoration', 'AUTO', 480, 'HEAL', '', '713.3 + (k*224.689 + lv*80.2463)', '713.3 + (k*224.689 + lv*80.2463)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '733.3 + (k*230.99 + lv*82.4963)', '733.3 + (k*230.99 + lv*82.4963)', '733.3 + (k*230.99 + lv*82.4963)', '733.3 + (k*230.99 + lv*82.4963)', '58', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 11, 'Vampirism', 'PASSIVE', 0, 'STEALHP', 'STEAL_HP', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 12, 'Spiritualism', 'PASSIVE', 0, 'STEALMP', 'STEAL_SP', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 13, 'Bulwark', 'PASSIVE', 0, 'BLOCK', 'BLOCK', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 14, 'Reflection', 'PASSIVE', 0, 'REFLECT_MELEE', 'REFLECT_MELEE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 15, 'Yang Drop', 'PASSIVE', 0, 'GOLD_DROP', 'GOLD_DOUBLE_BONUS', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 16, 'Range', 'PASSIVE', 0, 'BOW_DISTANCE', 'BOW_DISTANCE', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 17, 'Immortal', 'AUTO', 600, 'INVINCIBILITY', '', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '53', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 18, 'Panacea', 'AUTO', 480, 'REMOVAL', '', '0', '0', '0', '0', '0', '0', '0', '0', '41', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 19, 'Master Brewer', 'PASSIVE', 0, 'POTION', 'POTION_BONUS', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 20, 'Monster Hunter', 'PASSIVE', 0, 'MOB_BONUS', 'ATTBONUS_MONSTER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 21, 'Eagle Eyes', 'PASSIVE', 0, 'EXP', 'EXP_DOUBLE_BONUS', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 22, 'Life Drain', 'PASSIVE', 0, 'HP_RECOVER', 'KILL_HP_RECOVERY', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55705, 23, 'Light as a Feather', 'AUTO', 180, 'FEATHER', '', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '44+ (k*0.455 + lv*0.1625)', '50 + (k*2.8 + lv*1)');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 1, 'Resistance (Warrior)', 'PASSIVE', 0, 'JIJOONG_WARRIOR', 'RESIST_WARRIOR', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 2, 'Resistance (Sura)', 'PASSIVE', 0, 'JIJOONG_SURA', 'RESIST_SURA', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 3, 'Resistance (Ninja)', 'PASSIVE', 0, 'JIJOONG_ASSASSIN', 'RESIST_ASSASSIN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 4, 'Resistance (Shaman)', 'PASSIVE', 0, 'JIJOONG_SHAMAN', 'RESIST_SHAMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 5, 'Resistance (Lycan)', 'PASSIVE', 0, 'JIJOONG_WOLFMAN', 'RESIST_WOLFMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 6, 'Berserker', 'PASSIVE', 0, 'PACHEON', 'MELEE_MAGIC_ATT_BONUS_PER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 7, 'Anti-Magic', 'PASSIVE', 0, 'BANYA', 'RESIST_MAGIC_REDUCTION', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 8, 'Haste', 'PASSIVE', 0, 'CHEONRYEONG', 'CASTING_SPEED', '1 + (k*0.63 + lv*0.225)', '1 + (k*0.63 + lv*0.225)', '1 + (k*0.665 + lv*0.2375)', '1 + (k*0.665 + lv*0.2375)', '1 + (k*0.735 + lv*0.2625)', '1 + (k*0.735 + lv*0.2625)', '1 + (k*0.735 + lv*0.2625)', '1 + (k*0.735 + lv*0.2625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 9, 'Drill', 'PASSIVE', 0, 'CHOEHOENBIMU', 'PENETRATE_PCT', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 10, 'Restoration', 'AUTO', 480, 'HEAL', '', '713.3 + (k*224.689 + lv*80.2463)', '713.3 + (k*224.689 + lv*80.2463)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '733.3 + (k*230.99 + lv*82.4963)', '733.3 + (k*230.99 + lv*82.4963)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '58', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 11, 'Vampirism', 'PASSIVE', 0, 'STEALHP', 'STEAL_HP', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 12, 'Spiritualism', 'PASSIVE', 0, 'STEALMP', 'STEAL_SP', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 13, 'Bulwark', 'PASSIVE', 0, 'BLOCK', 'BLOCK', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.49 + lv*0.175)', '1 + (k*0.49 + lv*0.175)', '1 + (k*0.49 + lv*0.175)', '1 + (k*0.49 + lv*0.175)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 14, 'Reflection', 'PASSIVE', 0, 'REFLECT_MELEE', 'REFLECT_MELEE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 15, 'Yang Drop', 'PASSIVE', 0, 'GOLD_DROP', 'GOLD_DOUBLE_BONUS', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 16, 'Range', 'PASSIVE', 0, 'BOW_DISTANCE', 'BOW_DISTANCE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 17, 'Immortal', 'AUTO', 600, 'INVINCIBILITY', '', '10 + (k*0.63 + lv*0.225)', '10 + (k*0.63 + lv*0.225)', '10 + (k*0.665 + lv*0.2375)', '10 + (k*0.665 + lv*0.2375)', '10 + (k*0.7 + lv*0.25)', '10 + (k*0.7 + lv*0.25)', '10 + (k*0.7 + lv*0.25)', '10 + (k*0.7 + lv*0.25)', '53', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 18, 'Panacea', 'AUTO', 480, 'REMOVAL', '', '0', '0', '0', '0', '0', '0', '0', '0', '41', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 19, 'Master Brewer', 'PASSIVE', 0, 'POTION', 'POTION_BONUS', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 20, 'Monster Hunter', 'PASSIVE', 0, 'MOB_BONUS', 'ATTBONUS_MONSTER', '1 + (k*0.28 + lv*0.1)', '1 + (k*0.28 + lv*0.1)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 21, 'Eagle Eyes', 'PASSIVE', 0, 'EXP', 'EXP_DOUBLE_BONUS', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 22, 'Life Drain', 'PASSIVE', 0, 'HP_RECOVER', 'KILL_HP_RECOVERY', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55706, 23, 'Light as a Feather', 'AUTO', 180, 'FEATHER', '', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '44+ (k*0.455 + lv*0.1625)', '50 + (k*2.8 + lv*1)');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 1, 'Resistance (Warrior)', 'PASSIVE', 0, 'JIJOONG_WARRIOR', 'RESIST_WARRIOR', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 2, 'Resistance (Sura)', 'PASSIVE', 0, 'JIJOONG_SURA', 'RESIST_SURA', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 3, 'Resistance (Ninja)', 'PASSIVE', 0, 'JIJOONG_ASSASSIN', 'RESIST_ASSASSIN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 4, 'Resistance (Shaman)', 'PASSIVE', 0, 'JIJOONG_SHAMAN', 'RESIST_SHAMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 5, 'Resistance (Lycan)', 'PASSIVE', 0, 'JIJOONG_WOLFMAN', 'RESIST_WOLFMAN', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 6, 'Berserker', 'PASSIVE', 0, 'PACHEON', 'MELEE_MAGIC_ATT_BONUS_PER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 7, 'Anti-Magic', 'PASSIVE', 0, 'BANYA', 'RESIST_MAGIC_REDUCTION', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 8, 'Haste', 'PASSIVE', 0, 'CHEONRYEONG', 'CASTING_SPEED', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 9, 'Drill', 'PASSIVE', 0, 'CHOEHOENBIMU', 'PENETRATE_PCT', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 10, 'Restoration', 'AUTO', 480, 'HEAL', '', '706.6 + (k*222.579 + lv*79.4925)', '706.6 + (k*222.579 + lv*79.4925)', '713.3 + (k*224.689 + lv*80.2463)', '713.3 + (k*224.689 + lv*80.2463)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '58', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 11, 'Vampirism', 'PASSIVE', 0, 'STEALHP', 'STEAL_HP', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 12, 'Spiritualism', 'PASSIVE', 0, 'STEALMP', 'STEAL_SP', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 13, 'Bulwark', 'PASSIVE', 0, 'BLOCK', 'BLOCK', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 14, 'Reflection', 'PASSIVE', 0, 'REFLECT_MELEE', 'REFLECT_MELEE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 15, 'Yang Drop', 'PASSIVE', 0, 'GOLD_DROP', 'GOLD_DOUBLE_BONUS', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 16, 'Range', 'PASSIVE', 0, 'BOW_DISTANCE', 'BOW_DISTANCE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 17, 'Immortal', 'AUTO', 600, 'INVINCIBILITY', '', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.63 + lv*0.225)', '10 + (k*0.63 + lv*0.225)', '10 + (k*0.665 + lv*0.2375)', '10 + (k*0.665 + lv*0.2375)', '10 + (k*0.665 + lv*0.2375)', '10 + (k*0.665 + lv*0.2375)', '53', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 18, 'Panacea', 'AUTO', 480, 'REMOVAL', '', '0', '0', '0', '0', '0', '0', '0', '0', '41', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 19, 'Master Brewer', 'PASSIVE', 0, 'POTION', 'POTION_BONUS', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 20, 'Monster Hunter', 'PASSIVE', 0, 'MOB_BONUS', 'ATTBONUS_MONSTER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 21, 'Eagle Eyes', 'PASSIVE', 0, 'EXP', 'EXP_DOUBLE_BONUS', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 22, 'Life Drain', 'PASSIVE', 0, 'HP_RECOVER', 'KILL_HP_RECOVERY', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55707, 23, 'Light as a Feather', 'AUTO', 180, 'FEATHER', '', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '44+ (k*0.455 + lv*0.1625)', '50 + (k*2.8 + lv*1)');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 1, 'Resistance (Warrior)', 'PASSIVE', 0, 'JIJOONG_WARRIOR', 'RESIST_WARRIOR', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 2, 'Resistance (Sura)', 'PASSIVE', 0, 'JIJOONG_SURA', 'RESIST_SURA', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 3, 'Resistance (Ninja)', 'PASSIVE', 0, 'JIJOONG_ASSASSIN', 'RESIST_ASSASSIN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 4, 'Resistance (Shaman)', 'PASSIVE', 0, 'JIJOONG_SHAMAN', 'RESIST_SHAMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 5, 'Resistance (Lycan)', 'PASSIVE', 0, 'JIJOONG_WOLFMAN', 'RESIST_WOLFMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 6, 'Berserker', 'PASSIVE', 0, 'PACHEON', 'MELEE_MAGIC_ATT_BONUS_PER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.525 + lv*0.1875)', '1 + (k*0.525 + lv*0.1875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 7, 'Anti-Magic', 'PASSIVE', 0, 'BANYA', 'RESIST_MAGIC_REDUCTION', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 8, 'Haste', 'PASSIVE', 0, 'CHEONRYEONG', 'CASTING_SPEED', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 9, 'Drill', 'PASSIVE', 0, 'CHOEHOENBIMU', 'PENETRATE_PCT', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 10, 'Restoration', 'AUTO', 480, 'HEAL', '', '713.3 + (k*224.689 + lv*80.2463)', '713.3 + (k*224.689 + lv*80.2463)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '58', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 11, 'Vampirism', 'PASSIVE', 0, 'STEALHP', 'STEAL_HP', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 12, 'Spiritualism', 'PASSIVE', 0, 'STEALMP', 'STEAL_SP', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 13, 'Bulwark', 'PASSIVE', 0, 'BLOCK', 'BLOCK', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 14, 'Reflection', 'PASSIVE', 0, 'REFLECT_MELEE', 'REFLECT_MELEE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 15, 'Yang Drop', 'PASSIVE', 0, 'GOLD_DROP', 'GOLD_DOUBLE_BONUS', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 16, 'Range', 'PASSIVE', 0, 'BOW_DISTANCE', 'BOW_DISTANCE', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 17, 'Immortal', 'AUTO', 600, 'INVINCIBILITY', '', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '53', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 18, 'Panacea', 'AUTO', 480, 'REMOVAL', '', '0', '0', '0', '0', '0', '0', '0', '0', '41', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 19, 'Master Brewer', 'PASSIVE', 0, 'POTION', 'POTION_BONUS', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 20, 'Monster Hunter', 'PASSIVE', 0, 'MOB_BONUS', 'ATTBONUS_MONSTER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 21, 'Eagle Eyes', 'PASSIVE', 0, 'EXP', 'EXP_DOUBLE_BONUS', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 22, 'Life Drain', 'PASSIVE', 0, 'HP_RECOVER', 'KILL_HP_RECOVERY', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55708, 23, 'Light as a Feather', 'AUTO', 180, 'FEATHER', '', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '44+ (k*0.455 + lv*0.1625)', '50 + (k*2.8 + lv*1)');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 1, 'Resistance (Warrior)', 'PASSIVE', 0, 'JIJOONG_WARRIOR', 'RESIST_WARRIOR', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 2, 'Resistance (Sura)', 'PASSIVE', 0, 'JIJOONG_SURA', 'RESIST_SURA', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 3, 'Resistance (Ninja)', 'PASSIVE', 0, 'JIJOONG_ASSASSIN', 'RESIST_ASSASSIN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 4, 'Resistance (Shaman)', 'PASSIVE', 0, 'JIJOONG_SHAMAN', 'RESIST_SHAMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 5, 'Resistance (Lycan)', 'PASSIVE', 0, 'JIJOONG_WOLFMAN', 'RESIST_WOLFMAN', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 6, 'Berserker', 'PASSIVE', 0, 'PACHEON', 'MELEE_MAGIC_ATT_BONUS_PER', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 7, 'Anti-Magic', 'PASSIVE', 0, 'BANYA', 'RESIST_MAGIC_REDUCTION', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 8, 'Haste', 'PASSIVE', 0, 'CHEONRYEONG', 'CASTING_SPEED', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 9, 'Drill', 'PASSIVE', 0, 'CHOEHOENBIMU', 'PENETRATE_PCT', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 10, 'Restoration', 'AUTO', 480, 'HEAL', '', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '58', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 11, 'Vampirism', 'PASSIVE', 0, 'STEALHP', 'STEAL_HP', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 12, 'Spiritualism', 'PASSIVE', 0, 'STEALMP', 'STEAL_SP', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 13, 'Bulwark', 'PASSIVE', 0, 'BLOCK', 'BLOCK', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 14, 'Reflection', 'PASSIVE', 0, 'REFLECT_MELEE', 'REFLECT_MELEE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 15, 'Yang Drop', 'PASSIVE', 0, 'GOLD_DROP', 'GOLD_DOUBLE_BONUS', '10.8 + (k*3.402 + lv*1.215)', '10.8 + (k*3.402 + lv*1.215)', '11.2 + (k*3.528 + lv*1.26)', '11.2 + (k*3.528 + lv*1.26)', '11.6 + (k*3.654 + lv*1.305)', '11.6 + (k*3.654 + lv*1.305)', '11.6 + (k*3.654 + lv*1.305)', '11.6 + (k*3.654 + lv*1.305)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 16, 'Range', 'PASSIVE', 0, 'BOW_DISTANCE', 'BOW_DISTANCE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 17, 'Immortal', 'AUTO', 600, 'INVINCIBILITY', '', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '53', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 18, 'Panacea', 'AUTO', 480, 'REMOVAL', '', '0', '0', '0', '0', '0', '0', '0', '0', '41', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 19, 'Master Brewer', 'PASSIVE', 0, 'POTION', 'POTION_BONUS', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 20, 'Monster Hunter', 'PASSIVE', 0, 'MOB_BONUS', 'ATTBONUS_MONSTER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 21, 'Eagle Eyes', 'PASSIVE', 0, 'EXP', 'EXP_DOUBLE_BONUS', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 22, 'Life Drain', 'PASSIVE', 0, 'HP_RECOVER', 'KILL_HP_RECOVERY', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55709, 23, 'Light as a Feather', 'AUTO', 180, 'FEATHER', '', '187.5 + (k*6.5625 + lv*2.34375)', '187.5 + (k*6.5625 + lv*2.34375)', '287.5 + (k*10.0625 + lv*3.59375)', '287.5 + (k*10.0625 + lv*3.59375)', '287.5 + (k*10.0625 + lv*3.59375)', '387.5 + (k*13.5625 + lv*4.84375)', '387.5 + (k*13.5625 + lv*4.84375)', '387.5 + (k*13.5625 + lv*4.84375)', '44+ (k*0.455 + lv*0.1625)', '50 + (k*2.8 + lv*1)');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 1, 'Resistance (Warrior)', 'PASSIVE', 0, 'JIJOONG_WARRIOR', 'RESIST_WARRIOR', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 2, 'Resistance (Sura)', 'PASSIVE', 0, 'JIJOONG_SURA', 'RESIST_SURA', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 3, 'Resistance (Ninja)', 'PASSIVE', 0, 'JIJOONG_ASSASSIN', 'RESIST_ASSASSIN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 4, 'Resistance (Shaman)', 'PASSIVE', 0, 'JIJOONG_SHAMAN', 'RESIST_SHAMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 5, 'Resistance (Lycan)', 'PASSIVE', 0, 'JIJOONG_WOLFMAN', 'RESIST_WOLFMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 6, 'Berserker', 'PASSIVE', 0, 'PACHEON', 'MELEE_MAGIC_ATT_BONUS_PER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 7, 'Anti-Magic', 'PASSIVE', 0, 'BANYA', 'RESIST_MAGIC_REDUCTION', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 8, 'Haste', 'PASSIVE', 0, 'CHEONRYEONG', 'CASTING_SPEED', '1 + (k*0.63 + lv*0.225)', '1 + (k*0.63 + lv*0.225)', '1 + (k*0.665 + lv*0.2375)', '1 + (k*0.665 + lv*0.2375)', '1 + (k*0.735 + lv*0.2625)', '1 + (k*0.735 + lv*0.2625)', '1 + (k*0.735 + lv*0.2625)', '1 + (k*0.735 + lv*0.2625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 9, 'Drill', 'PASSIVE', 0, 'CHOEHOENBIMU', 'PENETRATE_PCT', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 10, 'Restoration', 'AUTO', 480, 'HEAL', '', '713.3 + (k*224.689 + lv*80.2463)', '713.3 + (k*224.689 + lv*80.2463)', '720 + (k*226.8 + lv*81)', '720 + (k*226.8 + lv*81)', '733.3 + (k*230.99 + lv*82.4963)', '720 + (k*226.8 + lv*81)', '733.3 + (k*230.99 + lv*82.4963)', '720 + (k*226.8 + lv*81)', '58', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 11, 'Vampirism', 'PASSIVE', 0, 'STEALHP', 'STEAL_HP', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 12, 'Spiritualism', 'PASSIVE', 0, 'STEALMP', 'STEAL_SP', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 13, 'Bulwark', 'PASSIVE', 0, 'BLOCK', 'BLOCK', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.49 + lv*0.175)', '1 + (k*0.49 + lv*0.175)', '1 + (k*0.49 + lv*0.175)', '1 + (k*0.49 + lv*0.175)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 14, 'Reflection', 'PASSIVE', 0, 'REFLECT_MELEE', 'REFLECT_MELEE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 15, 'Yang Drop', 'PASSIVE', 0, 'GOLD_DROP', 'GOLD_DOUBLE_BONUS', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '10.6 + (k*3.339 + lv*1.1925)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 16, 'Range', 'PASSIVE', 0, 'BOW_DISTANCE', 'BOW_DISTANCE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 17, 'Immortal', 'AUTO', 600, 'INVINCIBILITY', '', '10 + (k*0.63 + lv*0.225)', '10 + (k*0.63 + lv*0.225)', '10 + (k*0.665 + lv*0.2375)', '10 + (k*0.665 + lv*0.2375)', '10 + (k*0.7 + lv*0.25)', '10 + (k*0.7 + lv*0.25)', '10 + (k*0.7 + lv*0.25)', '10 + (k*0.7 + lv*0.25)', '53', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 18, 'Panacea', 'AUTO', 480, 'REMOVAL', '', '0', '0', '0', '0', '0', '0', '0', '0', '41', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 19, 'Master Brewer', 'PASSIVE', 0, 'POTION', 'POTION_BONUS', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 20, 'Monster Hunter', 'PASSIVE', 0, 'MOB_BONUS', 'ATTBONUS_MONSTER', '1 + (k*0.28 + lv*0.1)', '1 + (k*0.28 + lv*0.1)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 21, 'Eagle Eyes', 'PASSIVE', 0, 'EXP', 'EXP_DOUBLE_BONUS', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 22, 'Life Drain', 'PASSIVE', 0, 'HP_RECOVER', 'KILL_HP_RECOVERY', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55710, 23, 'Light as a Feather', 'AUTO', 180, 'FEATHER', '', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '150 + (k*5.25 + lv*1.875)', '44+ (k*0.455 + lv*0.1625)', '50 + (k*2.8 + lv*1)');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 1, 'Resistance (Warrior)', 'PASSIVE', 0, 'JIJOONG_WARRIOR', 'RESIST_WARRIOR', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 2, 'Resistance (Sura)', 'PASSIVE', 0, 'JIJOONG_SURA', 'RESIST_SURA', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 3, 'Resistance (Ninja)', 'PASSIVE', 0, 'JIJOONG_ASSASSIN', 'RESIST_ASSASSIN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 4, 'Resistance (Shaman)', 'PASSIVE', 0, 'JIJOONG_SHAMAN', 'RESIST_SHAMAN', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 5, 'Resistance (Lycan)', 'PASSIVE', 0, 'JIJOONG_WOLFMAN', 'RESIST_WOLFMAN', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '1 + (k*0.455 + lv*0.1625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 6, 'Berserker', 'PASSIVE', 0, 'PACHEON', 'MELEE_MAGIC_ATT_BONUS_PER', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.35 + lv*0.125)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '1 + (k*0.42 + lv*0.15)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 7, 'Anti-Magic', 'PASSIVE', 0, 'BANYA', 'RESIST_MAGIC_REDUCTION', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 8, 'Haste', 'PASSIVE', 0, 'CHEONRYEONG', 'CASTING_SPEED', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '1 + (k*0.595 + lv*0.2125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 9, 'Drill', 'PASSIVE', 0, 'CHOEHOENBIMU', 'PENETRATE_PCT', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 10, 'Restoration', 'AUTO', 480, 'HEAL', '', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '700 + (k*220.5 + lv*78.75)', '58', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 11, 'Vampirism', 'PASSIVE', 0, 'STEALHP', 'STEAL_HP', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 12, 'Spiritualism', 'PASSIVE', 0, 'STEALMP', 'STEAL_SP', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.21 + lv*0.075)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 13, 'Bulwark', 'PASSIVE', 0, 'BLOCK', 'BLOCK', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '1 + (k*0.385 + lv*0.1375)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 14, 'Reflection', 'PASSIVE', 0, 'REFLECT_MELEE', 'REFLECT_MELEE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 15, 'Yang Drop', 'PASSIVE', 0, 'GOLD_DROP', 'GOLD_DOUBLE_BONUS', '10.8 + (k*3.402 + lv*1.215)', '10.8 + (k*3.402 + lv*1.215)', '11.2 + (k*3.528 + lv*1.26)', '11.2 + (k*3.528 + lv*1.26)', '11.6 + (k*3.654 + lv*1.305)', '11.6 + (k*3.654 + lv*1.305)', '11.6 + (k*3.654 + lv*1.305)', '11.6 + (k*3.654 + lv*1.305)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 16, 'Range', 'PASSIVE', 0, 'BOW_DISTANCE', 'BOW_DISTANCE', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 17, 'Immortal', 'AUTO', 600, 'INVINCIBILITY', '', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '10 + (k*0.595 + lv*0.2125)', '53', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 18, 'Panacea', 'AUTO', 480, 'REMOVAL', '', '0', '0', '0', '0', '0', '0', '0', '0', '41', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 19, 'Master Brewer', 'PASSIVE', 0, 'POTION', 'POTION_BONUS', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '1 + (k*0.315 + lv*0.1125)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 20, 'Monster Hunter', 'PASSIVE', 0, 'MOB_BONUS', 'ATTBONUS_MONSTER', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '1 + (k*0.245 + lv*0.0875)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 21, 'Eagle Eyes', 'PASSIVE', 0, 'EXP', 'EXP_DOUBLE_BONUS', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 22, 'Life Drain', 'PASSIVE', 0, 'HP_RECOVER', 'KILL_HP_RECOVERY', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '1 + (k*0.175 + lv*0.0625)', '0', '0');
+INSERT INTO `growth_pet_skill_proto` VALUES (55711, 23, 'Light as a Feather', 'AUTO', 180, 'FEATHER', '', '187.5 + (k*6.5625 + lv*2.34375)', '187.5 + (k*6.5625 + lv*2.34375)', '287.5 + (k*10.0625 + lv*3.59375)', '287.5 + (k*10.0625 + lv*3.59375)', '287.5 + (k*10.0625 + lv*3.59375)', '387.5 + (k*13.5625 + lv*4.84375)', '387.5 + (k*13.5625 + lv*4.84375)', '387.5 + (k*13.5625 + lv*4.84375)', '44+ (k*0.455 + lv*0.1625)', '50 + (k*2.8 + lv*1)');
 
---
--- Dumping data for table `growth_pet_skill_proto`
---
 
-LOCK TABLES `growth_pet_skill_proto` WRITE;
-/*!40000 ALTER TABLE `growth_pet_skill_proto` DISABLE KEYS */;
-INSERT INTO `growth_pet_skill_proto` VALUES (55701,1,'Resistance (Warrior)','PASSIVE',0,'JIJOONG_WARRIOR','RESIST_WARRIOR','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','0','0'),(55701,2,'Resistance (Sura)','PASSIVE',0,'JIJOONG_SURA','RESIST_SURA','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','0','0'),(55701,3,'Resistance (Ninja)','PASSIVE',0,'JIJOONG_ASSASSIN','RESIST_ASSASSIN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55701,4,'Resistance (Shaman)','PASSIVE',0,'JIJOONG_SHAMAN','RESIST_SHAMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55701,5,'Resistance (Lycan)','PASSIVE',0,'JIJOONG_WOLFMAN','RESIST_WOLFMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55701,6,'Berserker','PASSIVE',0,'PACHEON','MELEE_MAGIC_ATT_BONUS_PER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55701,7,'Anti-Magic','PASSIVE',0,'BANYA','RESIST_MAGIC_REDUCTION','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','0','0'),(55701,8,'Haste','PASSIVE',0,'CHEONRYEONG','CASTING_SPEED','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55701,9,'Drill','PASSIVE',0,'CHOEHOENBIMU','PENETRATE_PCT','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55701,10,'Restoration','AUTO',360,'HEAL','','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','30+ (k*0.455 + lv*0.1625)','0'),(55701,11,'Vampirism','PASSIVE',0,'STEALHP','STEAL_HP','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55701,12,'Spiritualism','PASSIVE',0,'STEALMP','STEAL_SP','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55701,13,'Bulwark','PASSIVE',0,'BLOCK','BLOCK','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55701,14,'Reflection','PASSIVE',0,'REFLECT_MELEE','REFLECT_MELEE','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55701,15,'Yang Drop','PASSIVE',0,'GOLD_DROP','GOLD_DOUBLE_BONUS','10.6 + (k*3.339 + lv*1.1925)','10.8 + (k*3.402 + lv*1.215)','10.8 + (k*3.402 + lv*1.215)','11.2 + (k*3.528 + lv*1.26)','11.2 + (k*3.528 + lv*1.26)','11.6 + (k*3.654 + lv*1.305)','11.6 + (k*3.654 + lv*1.305)','11.6 + (k*3.654 + lv*1.305)','0','0'),(55701,16,'Range','PASSIVE',0,'BOW_DISTANCE','BOW_DISTANCE','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55701,17,'Immortal','AUTO',450,'INVINCIBILITY','','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','300+ (k*0.455 + lv*0.1625)','0'),(55701,18,'Panacea','AUTO',360,'REMOVAL','','0','0','0','0','0','0','0','0','30+ (k*0.455 + lv*0.1625)','0'),(55701,19,'Master Brewer','PASSIVE',0,'POTION','POTION_BONUS','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55701,20,'Monster Hunter','PASSIVE',0,'MOB_BONUS','ATTBONUS_MONSTER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55701,21,'Eagle Eyes','PASSIVE',0,'EXP','EXP_DOUBLE_BONUS','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55701,22,'Life Drain','PASSIVE',0,'HP_RECOVER','KILL_HP_RECOVERY','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55701,23,'Light as a Feather','AUTO',10,'FEATHER','','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','44+ (k*0.455 + lv*0.1625)','50 + (k*2.8 + lv*1)'),(55702,1,'Resistance (Warrior)','PASSIVE',0,'JIJOONG_WARRIOR','RESIST_WARRIOR','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55702,2,'Resistance (Sura)','PASSIVE',0,'JIJOONG_SURA','RESIST_SURA','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55702,3,'Resistance (Ninja)','PASSIVE',0,'JIJOONG_ASSASSIN','RESIST_ASSASSIN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55702,4,'Resistance (Shaman)','PASSIVE',0,'JIJOONG_SHAMAN','RESIST_SHAMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55702,5,'Resistance (Lycan)','PASSIVE',0,'JIJOONG_WOLFMAN','RESIST_WOLFMAN','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','0','0'),(55702,6,'Berserker','PASSIVE',0,'PACHEON','MELEE_MAGIC_ATT_BONUS_PER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55702,7,'Anti-Magic','PASSIVE',0,'BANYA','RESIST_MAGIC_REDUCTION','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','0','0'),(55702,8,'Haste','PASSIVE',0,'CHEONRYEONG','CASTING_SPEED','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55702,9,'Drill','PASSIVE',0,'CHOEHOENBIMU','PENETRATE_PCT','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55702,10,'Restoration','AUTO',360,'HEAL','','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','706.6 + (k*222.579 + lv*79.4925)','30+ (k*0.455 + lv*0.1625)','0'),(55702,11,'Vampirism','PASSIVE',0,'STEALHP','STEAL_HP','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55702,12,'Spiritualism','PASSIVE',0,'STEALMP','STEAL_SP','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55702,13,'Bulwark','PASSIVE',0,'BLOCK','BLOCK','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55702,14,'Reflection','PASSIVE',0,'REFLECT_MELEE','REFLECT_MELEE','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55702,15,'Yang Drop','PASSIVE',0,'GOLD_DROP','GOLD_DOUBLE_BONUS','10.6 + (k*3.339 + lv*1.1925)','10.8 + (k*3.402 + lv*1.215)','10.8 + (k*3.402 + lv*1.215)','11.2 + (k*3.528 + lv*1.26)','11.2 + (k*3.528 + lv*1.26)','11.6 + (k*3.654 + lv*1.305)','11.6 + (k*3.654 + lv*1.305)','11.6 + (k*3.654 + lv*1.305)','0','0'),(55702,16,'Range','PASSIVE',0,'BOW_DISTANCE','BOW_DISTANCE','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55702,17,'Immortal','AUTO',450,'INVINCIBILITY','','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','300+ (k*0.455 + lv*0.1625)','0'),(55702,18,'Panacea','AUTO',360,'REMOVAL','','0','0','0','0','0','0','0','0','30+ (k*0.455 + lv*0.1625)','0'),(55702,19,'Master Brewer','PASSIVE',0,'POTION','POTION_BONUS','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55702,20,'Monster Hunter','PASSIVE',0,'MOB_BONUS','ATTBONUS_MONSTER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55702,21,'Eagle Eyes','PASSIVE',0,'EXP','EXP_DOUBLE_BONUS','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55702,22,'Life Drain','PASSIVE',0,'HP_RECOVER','KILL_HP_RECOVERY','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55702,23,'Light as a Feather','AUTO',180,'FEATHER','','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','44+ (k*0.455 + lv*0.1625)','50 + (k*2.8 + lv*1)'),(55703,1,'Resistance (Warrior)','PASSIVE',0,'JIJOONG_WARRIOR','RESIST_WARRIOR','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55703,2,'Resistance (Sura)','PASSIVE',0,'JIJOONG_SURA','RESIST_SURA','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55703,3,'Resistance (Ninja)','PASSIVE',0,'JIJOONG_ASSASSIN','RESIST_ASSASSIN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55703,4,'Resistance (Shaman)','PASSIVE',0,'JIJOONG_SHAMAN','RESIST_SHAMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55703,5,'Resistance (Lycan)','PASSIVE',0,'JIJOONG_WOLFMAN','RESIST_WOLFMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55703,6,'Berserker','PASSIVE',0,'PACHEON','MELEE_MAGIC_ATT_BONUS_PER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55703,7,'Anti-Magic','PASSIVE',0,'BANYA','RESIST_MAGIC_REDUCTION','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','0','0'),(55703,8,'Haste','PASSIVE',0,'CHEONRYEONG','CASTING_SPEED','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','0','0'),(55703,9,'Drill','PASSIVE',0,'CHOEHOENBIMU','PENETRATE_PCT','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55703,10,'Restoration','AUTO',360,'HEAL','','713.3 + (k*224.689 + lv*80.2463)','713.3 + (k*224.689 + lv*80.2463)','720 + (k*226.8 + lv*81)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','720 + (k*226.8 + lv*81)','70+ (k*0.455 + lv*0.1625)','0'),(55703,11,'Vampirism','PASSIVE',0,'STEALHP','STEAL_HP','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55703,12,'Spiritualism','PASSIVE',0,'STEALMP','STEAL_SP','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55703,13,'Bulwark','PASSIVE',0,'BLOCK','BLOCK','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55703,14,'Reflection','PASSIVE',0,'REFLECT_MELEE','REFLECT_MELEE','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55703,15,'Yang Drop','PASSIVE',0,'GOLD_DROP','GOLD_DOUBLE_BONUS','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','0','0'),(55703,16,'Range','PASSIVE',0,'BOW_DISTANCE','BOW_DISTANCE','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55703,17,'Immortal','AUTO',450,'INVINCIBILITY','','10 + (k*0.63 + lv*0.225)','10 + (k*0.63 + lv*0.225)','10 + (k*0.665 + lv*0.2375)','10 + (k*0.665 + lv*0.2375)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','300+ (k*0.455 + lv*0.1625)','0'),(55703,18,'Panacea','AUTO',360,'REMOVAL','','0','0','0','0','0','0','0','0','70+ (k*0.455 + lv*0.1625)','0'),(55703,19,'Master Brewer','PASSIVE',0,'POTION','POTION_BONUS','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55703,20,'Monster Hunter','PASSIVE',0,'MOB_BONUS','ATTBONUS_MONSTER','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','0','0'),(55703,21,'Eagle Eyes','PASSIVE',0,'EXP','EXP_DOUBLE_BONUS','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','0','0'),(55703,22,'Life Drain','PASSIVE',0,'HP_RECOVER','KILL_HP_RECOVERY','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55703,23,'Light as a Feather','AUTO',180,'FEATHER','','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','44+ (k*0.455 + lv*0.1625)','50 + (k*2.8 + lv*1)'),(55704,1,'Resistance (Warrior)','PASSIVE',0,'JIJOONG_WARRIOR','RESIST_WARRIOR','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55704,2,'Resistance (Sura)','PASSIVE',0,'JIJOONG_SURA','RESIST_SURA','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55704,3,'Resistance (Ninja)','PASSIVE',0,'JIJOONG_ASSASSIN','RESIST_ASSASSIN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55704,4,'Resistance (Shaman)','PASSIVE',0,'JIJOONG_SHAMAN','RESIST_SHAMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55704,5,'Resistance (Lycan)','PASSIVE',0,'JIJOONG_WOLFMAN','RESIST_WOLFMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55704,6,'Berserker','PASSIVE',0,'PACHEON','MELEE_MAGIC_ATT_BONUS_PER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55704,7,'Anti-Magic','PASSIVE',0,'BANYA','RESIST_MAGIC_REDUCTION','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','0','0'),(55704,8,'Haste','PASSIVE',0,'CHEONRYEONG','CASTING_SPEED','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','0','0'),(55704,9,'Drill','PASSIVE',0,'CHOEHOENBIMU','PENETRATE_PCT','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55704,10,'Restoration','AUTO',360,'HEAL','','713.3 + (k*224.689 + lv*80.2463)','713.3 + (k*224.689 + lv*80.2463)','720 + (k*226.8 + lv*81)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','720 + (k*226.8 + lv*81)','70+ (k*0.455 + lv*0.1625)','0'),(55704,11,'Vampirism','PASSIVE',0,'STEALHP','STEAL_HP','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55704,12,'Spiritualism','PASSIVE',0,'STEALMP','STEAL_SP','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55704,13,'Bulwark','PASSIVE',0,'BLOCK','BLOCK','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55704,14,'Reflection','PASSIVE',0,'REFLECT_MELEE','REFLECT_MELEE','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55704,15,'Yang Drop','PASSIVE',0,'GOLD_DROP','GOLD_DOUBLE_BONUS','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','0','0'),(55704,16,'Range','PASSIVE',0,'BOW_DISTANCE','BOW_DISTANCE','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55704,17,'Immortal','AUTO',450,'INVINCIBILITY','','10 + (k*0.63 + lv*0.225)','10 + (k*0.63 + lv*0.225)','10 + (k*0.665 + lv*0.2375)','10 + (k*0.665 + lv*0.2375)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','300+ (k*0.455 + lv*0.1625)','0'),(55704,18,'Panacea','AUTO',360,'REMOVAL','','0','0','0','0','0','0','0','0','70+ (k*0.455 + lv*0.1625)','0'),(55704,19,'Master Brewer','PASSIVE',0,'POTION','POTION_BONUS','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55704,20,'Monster Hunter','PASSIVE',0,'MOB_BONUS','ATTBONUS_MONSTER','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','0','0'),(55704,21,'Eagle Eyes','PASSIVE',0,'EXP','EXP_DOUBLE_BONUS','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','0','0'),(55704,22,'Life Drain','PASSIVE',0,'HP_RECOVER','KILL_HP_RECOVERY','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55704,23,'Light as a Feather','AUTO',180,'FEATHER','','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','44+ (k*0.455 + lv*0.1625)','50 + (k*2.8 + lv*1)'),(55705,1,'Resistance (Warrior)','PASSIVE',0,'JIJOONG_WARRIOR','RESIST_WARRIOR','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55705,2,'Resistance (Sura)','PASSIVE',0,'JIJOONG_SURA','RESIST_SURA','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55705,3,'Resistance (Ninja)','PASSIVE',0,'JIJOONG_ASSASSIN','RESIST_ASSASSIN','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','0','0'),(55705,4,'Resistance (Shaman)','PASSIVE',0,'JIJOONG_SHAMAN','RESIST_SHAMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55705,5,'Resistance (Lycan)','PASSIVE',0,'JIJOONG_WOLFMAN','RESIST_WOLFMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55705,6,'Berserker','PASSIVE',0,'PACHEON','MELEE_MAGIC_ATT_BONUS_PER','1 + (k*0.35 + lv*0.125)','1 + (k*0.35 + lv*0.125)','1 + (k*0.35 + lv*0.125)','1 + (k*0.35 + lv*0.125)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','0','0'),(55705,7,'Anti-Magic','PASSIVE',0,'BANYA','RESIST_MAGIC_REDUCTION','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55705,8,'Haste','PASSIVE',0,'CHEONRYEONG','CASTING_SPEED','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','0','0'),(55705,9,'Drill','PASSIVE',0,'CHOEHOENBIMU','PENETRATE_PCT','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55705,10,'Restoration','AUTO',360,'HEAL','','713.3 + (k*224.689 + lv*80.2463)','713.3 + (k*224.689 + lv*80.2463)','720 + (k*226.8 + lv*81)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','733.3 + (k*230.99 + lv*82.4963)','733.3 + (k*230.99 + lv*82.4963)','733.3 + (k*230.99 + lv*82.4963)','50+ (k*0.455 + lv*0.1625)','0'),(55705,11,'Vampirism','PASSIVE',0,'STEALHP','STEAL_HP','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55705,12,'Spiritualism','PASSIVE',0,'STEALMP','STEAL_SP','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55705,13,'Bulwark','PASSIVE',0,'BLOCK','BLOCK','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55705,14,'Reflection','PASSIVE',0,'REFLECT_MELEE','REFLECT_MELEE','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55705,15,'Yang Drop','PASSIVE',0,'GOLD_DROP','GOLD_DOUBLE_BONUS','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','0','0'),(55705,16,'Range','PASSIVE',0,'BOW_DISTANCE','BOW_DISTANCE','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55705,17,'Immortal','AUTO',450,'INVINCIBILITY','','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','300+ (k*0.455 + lv*0.1625)','0'),(55705,18,'Panacea','AUTO',360,'REMOVAL','','0','0','0','0','0','0','0','0','50+ (k*0.455 + lv*0.1625)','0'),(55705,19,'Master Brewer','PASSIVE',0,'POTION','POTION_BONUS','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55705,20,'Monster Hunter','PASSIVE',0,'MOB_BONUS','ATTBONUS_MONSTER','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55705,21,'Eagle Eyes','PASSIVE',0,'EXP','EXP_DOUBLE_BONUS','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','0','0'),(55705,22,'Life Drain','PASSIVE',0,'HP_RECOVER','KILL_HP_RECOVERY','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55705,23,'Light as a Feather','AUTO',180,'FEATHER','','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','0','50 + (k*2.8 + lv*1)'),(55706,1,'Resistance (Warrior)','PASSIVE',0,'JIJOONG_WARRIOR','RESIST_WARRIOR','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55706,2,'Resistance (Sura)','PASSIVE',0,'JIJOONG_SURA','RESIST_SURA','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55706,3,'Resistance (Ninja)','PASSIVE',0,'JIJOONG_ASSASSIN','RESIST_ASSASSIN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55706,4,'Resistance (Shaman)','PASSIVE',0,'JIJOONG_SHAMAN','RESIST_SHAMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55706,5,'Resistance (Lycan)','PASSIVE',0,'JIJOONG_WOLFMAN','RESIST_WOLFMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55706,6,'Berserker','PASSIVE',0,'PACHEON','MELEE_MAGIC_ATT_BONUS_PER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55706,7,'Anti-Magic','PASSIVE',0,'BANYA','RESIST_MAGIC_REDUCTION','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','0','0'),(55706,8,'Haste','PASSIVE',0,'CHEONRYEONG','CASTING_SPEED','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','0','0'),(55706,9,'Drill','PASSIVE',0,'CHOEHOENBIMU','PENETRATE_PCT','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55706,10,'Restoration','AUTO',360,'HEAL','','713.3 + (k*224.689 + lv*80.2463)','713.3 + (k*224.689 + lv*80.2463)','720 + (k*226.8 + lv*81)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','720 + (k*226.8 + lv*81)','70+ (k*0.455 + lv*0.1625)','0'),(55706,11,'Vampirism','PASSIVE',0,'STEALHP','STEAL_HP','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55706,12,'Spiritualism','PASSIVE',0,'STEALMP','STEAL_SP','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55706,13,'Bulwark','PASSIVE',0,'BLOCK','BLOCK','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55706,14,'Reflection','PASSIVE',0,'REFLECT_MELEE','REFLECT_MELEE','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55706,15,'Yang Drop','PASSIVE',0,'GOLD_DROP','GOLD_DOUBLE_BONUS','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','0','0'),(55706,16,'Range','PASSIVE',0,'BOW_DISTANCE','BOW_DISTANCE','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55706,17,'Immortal','AUTO',450,'INVINCIBILITY','','10 + (k*0.63 + lv*0.225)','10 + (k*0.63 + lv*0.225)','10 + (k*0.665 + lv*0.2375)','10 + (k*0.665 + lv*0.2375)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','300+ (k*0.455 + lv*0.1625)','0'),(55706,18,'Panacea','AUTO',360,'REMOVAL','','0','0','0','0','0','0','0','0','70+ (k*0.455 + lv*0.1625)','0'),(55706,19,'Master Brewer','PASSIVE',0,'POTION','POTION_BONUS','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55706,20,'Monster Hunter','PASSIVE',0,'MOB_BONUS','ATTBONUS_MONSTER','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','0','0'),(55706,21,'Eagle Eyes','PASSIVE',0,'EXP','EXP_DOUBLE_BONUS','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','0','0'),(55706,22,'Life Drain','PASSIVE',0,'HP_RECOVER','KILL_HP_RECOVERY','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55706,23,'Light as a Feather','AUTO',180,'FEATHER','','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','44+ (k*0.455 + lv*0.1625)','50 + (k*2.8 + lv*1)'),(55707,1,'Resistance (Warrior)','PASSIVE',0,'JIJOONG_WARRIOR','RESIST_WARRIOR','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55707,2,'Resistance (Sura)','PASSIVE',0,'JIJOONG_SURA','RESIST_SURA','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55707,3,'Resistance (Ninja)','PASSIVE',0,'JIJOONG_ASSASSIN','RESIST_ASSASSIN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55707,4,'Resistance (Shaman)','PASSIVE',0,'JIJOONG_SHAMAN','RESIST_SHAMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55707,5,'Resistance (Lycan)','PASSIVE',0,'JIJOONG_WOLFMAN','RESIST_WOLFMAN','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','0','0'),(55707,6,'Berserker','PASSIVE',0,'PACHEON','MELEE_MAGIC_ATT_BONUS_PER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55707,7,'Anti-Magic','PASSIVE',0,'BANYA','RESIST_MAGIC_REDUCTION','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55707,8,'Haste','PASSIVE',0,'CHEONRYEONG','CASTING_SPEED','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','0','0'),(55707,9,'Drill','PASSIVE',0,'CHOEHOENBIMU','PENETRATE_PCT','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55707,10,'Restoration','AUTO',360,'HEAL','','713.3 + (k*224.689 + lv*80.2463)','713.3 + (k*224.689 + lv*80.2463)','720 + (k*226.8 + lv*81)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','733.3 + (k*230.99 + lv*82.4963)','733.3 + (k*230.99 + lv*82.4963)','733.3 + (k*230.99 + lv*82.4963)','50+ (k*0.455 + lv*0.1625)','0'),(55707,11,'Vampirism','PASSIVE',0,'STEALHP','STEAL_HP','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55707,12,'Spiritualism','PASSIVE',0,'STEALMP','STEAL_SP','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55707,13,'Bulwark','PASSIVE',0,'BLOCK','BLOCK','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55707,14,'Reflection','PASSIVE',0,'REFLECT_MELEE','REFLECT_MELEE','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55707,15,'Yang Drop','PASSIVE',0,'GOLD_DROP','GOLD_DOUBLE_BONUS','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','0','0'),(55707,16,'Range','PASSIVE',0,'BOW_DISTANCE','BOW_DISTANCE','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55707,17,'Immortal','AUTO',450,'INVINCIBILITY','','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','300+ (k*0.455 + lv*0.1625)','0'),(55707,18,'Panacea','AUTO',360,'REMOVAL','','0','0','0','0','0','0','0','0','50+ (k*0.455 + lv*0.1625)','0'),(55707,19,'Master Brewer','PASSIVE',0,'POTION','POTION_BONUS','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55707,20,'Monster Hunter','PASSIVE',0,'MOB_BONUS','ATTBONUS_MONSTER','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55707,21,'Eagle Eyes','PASSIVE',0,'EXP','EXP_DOUBLE_BONUS','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','0','0'),(55707,22,'Life Drain','PASSIVE',0,'HP_RECOVER','KILL_HP_RECOVERY','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55707,23,'Light as a Feather','AUTO',180,'FEATHER','','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','0','50 + (k*2.8 + lv*1)'),(55708,1,'Resistance (Warrior)','PASSIVE',0,'JIJOONG_WARRIOR','RESIST_WARRIOR','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55708,2,'Resistance (Sura)','PASSIVE',0,'JIJOONG_SURA','RESIST_SURA','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55708,3,'Resistance (Ninja)','PASSIVE',0,'JIJOONG_ASSASSIN','RESIST_ASSASSIN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55708,4,'Resistance (Shaman)','PASSIVE',0,'JIJOONG_SHAMAN','RESIST_SHAMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55708,5,'Resistance (Lycan)','PASSIVE',0,'JIJOONG_WOLFMAN','RESIST_WOLFMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55708,6,'Berserker','PASSIVE',0,'PACHEON','MELEE_MAGIC_ATT_BONUS_PER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55708,7,'Anti-Magic','PASSIVE',0,'BANYA','RESIST_MAGIC_REDUCTION','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','0','0'),(55708,8,'Haste','PASSIVE',0,'CHEONRYEONG','CASTING_SPEED','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','0','0'),(55708,9,'Drill','PASSIVE',0,'CHOEHOENBIMU','PENETRATE_PCT','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55708,10,'Restoration','AUTO',360,'HEAL','','713.3 + (k*224.689 + lv*80.2463)','713.3 + (k*224.689 + lv*80.2463)','720 + (k*226.8 + lv*81)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','720 + (k*226.8 + lv*81)','70+ (k*0.455 + lv*0.1625)','0'),(55708,11,'Vampirism','PASSIVE',0,'STEALHP','STEAL_HP','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55708,12,'Spiritualism','PASSIVE',0,'STEALMP','STEAL_SP','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55708,13,'Bulwark','PASSIVE',0,'BLOCK','BLOCK','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55708,14,'Reflection','PASSIVE',0,'REFLECT_MELEE','REFLECT_MELEE','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55708,15,'Yang Drop','PASSIVE',0,'GOLD_DROP','GOLD_DOUBLE_BONUS','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','0','0'),(55708,16,'Range','PASSIVE',0,'BOW_DISTANCE','BOW_DISTANCE','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55708,17,'Immortal','AUTO',450,'INVINCIBILITY','','10 + (k*0.63 + lv*0.225)','10 + (k*0.63 + lv*0.225)','10 + (k*0.665 + lv*0.2375)','10 + (k*0.665 + lv*0.2375)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','300+ (k*0.455 + lv*0.1625)','0'),(55708,18,'Panacea','AUTO',360,'REMOVAL','','0','0','0','0','0','0','0','0','70+ (k*0.455 + lv*0.1625)','0'),(55708,19,'Master Brewer','PASSIVE',0,'POTION','POTION_BONUS','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55708,20,'Monster Hunter','PASSIVE',0,'MOB_BONUS','ATTBONUS_MONSTER','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','0','0'),(55708,21,'Eagle Eyes','PASSIVE',0,'EXP','EXP_DOUBLE_BONUS','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','0','0'),(55708,22,'Life Drain','PASSIVE',0,'HP_RECOVER','KILL_HP_RECOVERY','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55708,23,'Light as a Feather','AUTO',180,'FEATHER','','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','44+ (k*0.455 + lv*0.1625)','50 + (k*2.8 + lv*1)'),(55709,1,'Resistance (Warrior)','PASSIVE',0,'JIJOONG_WARRIOR','RESIST_WARRIOR','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55709,2,'Resistance (Sura)','PASSIVE',0,'JIJOONG_SURA','RESIST_SURA','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55709,3,'Resistance (Ninja)','PASSIVE',0,'JIJOONG_ASSASSIN','RESIST_ASSASSIN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55709,4,'Resistance (Shaman)','PASSIVE',0,'JIJOONG_SHAMAN','RESIST_SHAMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55709,5,'Resistance (Lycan)','PASSIVE',0,'JIJOONG_WOLFMAN','RESIST_WOLFMAN','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','0','0'),(55709,6,'Berserker','PASSIVE',0,'PACHEON','MELEE_MAGIC_ATT_BONUS_PER','1 + (k*0.35 + lv*0.125)','1 + (k*0.35 + lv*0.125)','1 + (k*0.35 + lv*0.125)','1 + (k*0.35 + lv*0.125)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','0','0'),(55709,7,'Anti-Magic','PASSIVE',0,'BANYA','RESIST_MAGIC_REDUCTION','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55709,8,'Haste','PASSIVE',0,'CHEONRYEONG','CASTING_SPEED','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','0','0'),(55709,9,'Drill','PASSIVE',0,'CHOEHOENBIMU','PENETRATE_PCT','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55709,10,'Restoration','AUTO',480,'HEAL','','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','58','0'),(55709,11,'Vampirism','PASSIVE',0,'STEALHP','STEAL_HP','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55709,12,'Spiritualism','PASSIVE',0,'STEALMP','STEAL_SP','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55709,13,'Bulwark','PASSIVE',0,'BLOCK','BLOCK','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55709,14,'Reflection','PASSIVE',0,'REFLECT_MELEE','REFLECT_MELEE','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55709,15,'Yang Drop','PASSIVE',0,'GOLD_DROP','GOLD_DOUBLE_BONUS','10.8 + (k*3.402 + lv*1.215)','10.8 + (k*3.402 + lv*1.215)','11.2 + (k*3.528 + lv*1.26)','11.2 + (k*3.528 + lv*1.26)','11.6 + (k*3.654 + lv*1.305)','11.6 + (k*3.654 + lv*1.305)','11.6 + (k*3.654 + lv*1.305)','11.6 + (k*3.654 + lv*1.305)','0','0'),(55709,16,'Range','PASSIVE',0,'BOW_DISTANCE','BOW_DISTANCE','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55709,17,'Immortal','AUTO',600,'INVINCIBILITY','','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','53','0'),(55709,18,'Panacea','AUTO',480,'REMOVAL','','0','0','0','0','0','0','0','0','41','0'),(55709,19,'Master Brewer','PASSIVE',0,'POTION','POTION_BONUS','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55709,20,'Monster Hunter','PASSIVE',0,'MOB_BONUS','ATTBONUS_MONSTER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55709,21,'Eagle Eyes','PASSIVE',0,'EXP','EXP_DOUBLE_BONUS','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55709,22,'Life Drain','PASSIVE',0,'HP_RECOVER','KILL_HP_RECOVERY','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55709,23,'Light as a Feather','AUTO',180,'FEATHER','','187.5 + (k*6.5625 + lv*2.34375)','187.5 + (k*6.5625 + lv*2.34375)','287.5 + (k*10.0625 + lv*3.59375)','287.5 + (k*10.0625 + lv*3.59375)','287.5 + (k*10.0625 + lv*3.59375)','387.5 + (k*13.5625 + lv*4.84375)','387.5 + (k*13.5625 + lv*4.84375)','387.5 + (k*13.5625 + lv*4.84375)','44+ (k*0.455 + lv*0.1625)','50 + (k*2.8 + lv*1)'),(55710,1,'Resistance (Warrior)','PASSIVE',0,'JIJOONG_WARRIOR','RESIST_WARRIOR','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55710,2,'Resistance (Sura)','PASSIVE',0,'JIJOONG_SURA','RESIST_SURA','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55710,3,'Resistance (Ninja)','PASSIVE',0,'JIJOONG_ASSASSIN','RESIST_ASSASSIN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55710,4,'Resistance (Shaman)','PASSIVE',0,'JIJOONG_SHAMAN','RESIST_SHAMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55710,5,'Resistance (Lycan)','PASSIVE',0,'JIJOONG_WOLFMAN','RESIST_WOLFMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55710,6,'Berserker','PASSIVE',0,'PACHEON','MELEE_MAGIC_ATT_BONUS_PER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55710,7,'Anti-Magic','PASSIVE',0,'BANYA','RESIST_MAGIC_REDUCTION','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','0','0'),(55710,8,'Haste','PASSIVE',0,'CHEONRYEONG','CASTING_SPEED','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','0','0'),(55710,9,'Drill','PASSIVE',0,'CHOEHOENBIMU','PENETRATE_PCT','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55710,10,'Restoration','AUTO',360,'HEAL','','713.3 + (k*224.689 + lv*80.2463)','713.3 + (k*224.689 + lv*80.2463)','720 + (k*226.8 + lv*81)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','720 + (k*226.8 + lv*81)','733.3 + (k*230.99 + lv*82.4963)','720 + (k*226.8 + lv*81)','70+ (k*0.455 + lv*0.1625)','0'),(55710,11,'Vampirism','PASSIVE',0,'STEALHP','STEAL_HP','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55710,12,'Spiritualism','PASSIVE',0,'STEALMP','STEAL_SP','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55710,13,'Bulwark','PASSIVE',0,'BLOCK','BLOCK','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55710,14,'Reflection','PASSIVE',0,'REFLECT_MELEE','REFLECT_MELEE','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55710,15,'Yang Drop','PASSIVE',0,'GOLD_DROP','GOLD_DOUBLE_BONUS','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','10.6 + (k*3.339 + lv*1.1925)','0','0'),(55710,16,'Range','PASSIVE',0,'BOW_DISTANCE','BOW_DISTANCE','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55710,17,'Immortal','AUTO',450,'INVINCIBILITY','','10 + (k*0.63 + lv*0.225)','10 + (k*0.63 + lv*0.225)','10 + (k*0.665 + lv*0.2375)','10 + (k*0.665 + lv*0.2375)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','10 + (k*0.7 + lv*0.25)','300+ (k*0.455 + lv*0.1625)','0'),(55710,18,'Panacea','AUTO',360,'REMOVAL','','0','0','0','0','0','0','0','0','70+ (k*0.455 + lv*0.1625)','0'),(55710,19,'Master Brewer','PASSIVE',0,'POTION','POTION_BONUS','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55710,20,'Monster Hunter','PASSIVE',0,'MOB_BONUS','ATTBONUS_MONSTER','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','1 + (k*0.525 + lv*0.1775)','0','0'),(55710,21,'Eagle Eyes','PASSIVE',0,'EXP','EXP_DOUBLE_BONUS','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','1 + (k*0.900 + lv*0.2505)','0','0'),(55710,22,'Life Drain','PASSIVE',0,'HP_RECOVER','KILL_HP_RECOVERY','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55710,23,'Light as a Feather','AUTO',180,'FEATHER','','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','150 + (k*5.25 + lv*1.875)','44+ (k*0.455 + lv*0.1625)','50 + (k*2.8 + lv*1)'),(55711,1,'Resistance (Warrior)','PASSIVE',0,'JIJOONG_WARRIOR','RESIST_WARRIOR','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55711,2,'Resistance (Sura)','PASSIVE',0,'JIJOONG_SURA','RESIST_SURA','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55711,3,'Resistance (Ninja)','PASSIVE',0,'JIJOONG_ASSASSIN','RESIST_ASSASSIN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55711,4,'Resistance (Shaman)','PASSIVE',0,'JIJOONG_SHAMAN','RESIST_SHAMAN','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55711,5,'Resistance (Lycan)','PASSIVE',0,'JIJOONG_WOLFMAN','RESIST_WOLFMAN','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','1 + (k*0.455 + lv*0.1625)','0','0'),(55711,6,'Berserker','PASSIVE',0,'PACHEON','MELEE_MAGIC_ATT_BONUS_PER','1 + (k*0.35 + lv*0.125)','1 + (k*0.35 + lv*0.125)','1 + (k*0.35 + lv*0.125)','1 + (k*0.35 + lv*0.125)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','1 + (k*0.42 + lv*0.15)','0','0'),(55711,7,'Anti-Magic','PASSIVE',0,'BANYA','RESIST_MAGIC_REDUCTION','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','300+ (k*0.455 + lv*0.1625)','0'),(55711,8,'Haste','PASSIVE',0,'CHEONRYEONG','CASTING_SPEED','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','1 + (k*0.595 + lv*0.2125)','30+ (k*0.455 + lv*0.1625)','0'),(55711,9,'Drill','PASSIVE',0,'CHOEHOENBIMU','PENETRATE_PCT','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55711,10,'Restoration','AUTO',480,'HEAL','','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','700 + (k*220.5 + lv*78.75)','0','0'),(55711,11,'Vampirism','PASSIVE',0,'STEALHP','STEAL_HP','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55711,12,'Spiritualism','PASSIVE',0,'STEALMP','STEAL_SP','1 + (k*0.21 + lv*0.075)','1 + (k*0.21 + lv*0.075)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55711,13,'Bulwark','PASSIVE',0,'BLOCK','BLOCK','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','1 + (k*0.385 + lv*0.1375)','0','0'),(55711,14,'Reflection','PASSIVE',0,'REFLECT_MELEE','REFLECT_MELEE','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55711,15,'Yang Drop','PASSIVE',0,'GOLD_DROP','GOLD_DOUBLE_BONUS','10.8 + (k*3.402 + lv*1.215)','10.8 + (k*3.402 + lv*1.215)','11.2 + (k*3.528 + lv*1.26)','11.2 + (k*3.528 + lv*1.26)','11.6 + (k*3.654 + lv*1.305)','11.6 + (k*3.654 + lv*1.305)','11.6 + (k*3.654 + lv*1.305)','11.6 + (k*3.654 + lv*1.305)','0','0'),(55711,16,'Range','PASSIVE',0,'BOW_DISTANCE','BOW_DISTANCE','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55711,17,'Immortal','AUTO',600,'INVINCIBILITY','','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','10 + (k*0.595 + lv*0.2125)','53','0'),(55711,18,'Panacea','AUTO',480,'REMOVAL','','0','0','0','0','0','0','0','0','41','0'),(55711,19,'Master Brewer','PASSIVE',0,'POTION','POTION_BONUS','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','1 + (k*0.315 + lv*0.1125)','0','0'),(55711,20,'Monster Hunter','PASSIVE',0,'MOB_BONUS','ATTBONUS_MONSTER','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','1 + (k*0.245 + lv*0.0875)','0','0'),(55711,21,'Eagle Eyes','PASSIVE',0,'EXP','EXP_DOUBLE_BONUS','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55711,22,'Life Drain','PASSIVE',0,'HP_RECOVER','KILL_HP_RECOVERY','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','1 + (k*0.175 + lv*0.0625)','0','0'),(55711,23,'Light as a Feather','AUTO',180,'FEATHER','','187.5 + (k*6.5625 + lv*2.34375)','187.5 + (k*6.5625 + lv*2.34375)','287.5 + (k*10.0625 + lv*3.59375)','287.5 + (k*10.0625 + lv*3.59375)','287.5 + (k*10.0625 + lv*3.59375)','387.5 + (k*13.5625 + lv*4.84375)','387.5 + (k*13.5625 + lv*4.84375)','387.5 + (k*13.5625 + lv*4.84375)','44+ (k*0.455 + lv*0.1625)','50 + (k*2.8 + lv*1)');
-/*!40000 ALTER TABLE `growth_pet_skill_proto` ENABLE KEYS */;
-UNLOCK TABLES;
-
---
--- Table structure for table `guild`
---
-
-DROP TABLE IF EXISTS `guild`;
-/*!40101 SET @saved_cs_client     = @@character_set_client */;
-/*!50503 SET character_set_client = utf8mb4 */;
 CREATE TABLE `guild` (
   `id` int unsigned NOT NULL AUTO_INCREMENT,
   `name` varchar(12) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '',
@@ -4435,7 +4660,7 @@ CREATE TABLE `skill_proto` (
 
 LOCK TABLES `skill_proto` WRITE;
 /*!40000 ALTER TABLE `skill_proto` DISABLE KEYS */;
-INSERT INTO `skill_proto` VALUES (1,_binary '삼연\참',1,1,1,0,'HP','-(1.1*atk+(0.5*atk+1.5*str)*k)','40+100*k','','','12','-(1.1*atk+(0.5*atk+1.5*str)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','40+100*k',0,0,'MELEE',5,'1',0,200),(2,_binary '\팔\戀냄\',1,1,1,0,'HP','-(3*atk+(0.8*atk+str*5+dex*3+con)*k)','50+130*k','','','15','-(3*atk+(0.8*atk+str*5+dex*3+con)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','50+130*k',0,0,'MELEE',12,'1',0,200),(3,_binary '전\苦',1,1,1,0,'ATT_SPEED','50*k','50+140*k','60+90*k','','63+90*k','50*k','','SELFONLY','JEONGWIHON','MOV_SPEED','20*k','60+90*k','','','','','50+140*k',0,0,'NORMAL',1,'1',0,0),(4,_binary '검\',1,1,1,0,'ATT_GRADE','(100+str+lv*3)*k','100+200*k','30+50*k','','33+50*k','(100+str+lv*3)*k','','SELFONLY','GEOMGYEONG','NONE','','','','','','','100+200*k',0,0,'NORMAL',1,'1',0,0),(5,_binary '탄환\',1,1,1,0,'HP','-(2*atk+(atk+dex*3+str*7+con)*k)','60+120*k','','','12','-(2*atk+(atk+dex*3+str*7+con)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','MOV_SPEED','150','3','','','','','60+120*k',0,0,'MELEE',4,'1',0,200),(6,_binary '\\\\\釉\',1,1,1,0,'HP','-(3*atk+(atk+1.5*str)*k)*1.07','300+150*k','','','60','-(3*atk+(atk+1.5*str)*k)*1.07','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','300+150*k',0,0,'MELEE',5,'1',0,0),(16,_binary '\璲\참',1,1,1,0,'HP','-(2.3*atk+(4*atk+str*4+con)*k)','60+120*k','','','15','-(2.3*atk+(4*atk+str*4+con)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','60+120*k',0,0,'MELEE',4,'1',0,100),(17,_binary '격\月맙\',1,1,1,0,'HP','-(2.3*atk+(3*atk+str*4+con*3)*k)','60+150*k','','','15','-(2.3*atk+(3*atk+str*4+con*3)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','60+150*k',0,0,'MELEE',8,'1',0,200),(18,_binary '\陸彭',1,1,1,0,'HP','-(2*atk+(2*atk+2*dex+2*con+str*4)*k)','50+140*k','','','25','-(2*atk+(2*atk+2*dex+2*con+str*4)*k)','','ATTACK,USE_MELEE_DAMAGE,SELFONLY,SPLASH,ATTACK_STUN','','NONE','100+k*1000/6','2','','','','','50+140*k',0,0,'MELEE',10,'1',0,400),(19,_binary '천\\\',1,1,1,0,'DEF_GRADE','(200+str*0.2+con*0.5)*k','80+220*k','60+90*k','','63+90*k','(200+str*0.2+con*0.5)*k','','SELFONLY','CHEONGEUN','MOV_SPEED','-(1+9*k)','60+90*k','','','','','80+220*k',0,0,'NORMAL',1,'1',0,0),(20,_binary '\改',1,1,1,0,'HP','-(2*atk+(atk+dex*3+str*5+con)*k)','40+120*k','','','20','-(2*atk+(atk+dex*3+str*5+con)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','40+120*k',0,0,'MELEE',10,'1',1200,200),(21,_binary '뇌검도래',1,1,1,0,'HP','-(2*atk+(2*atk+2*dex+2*con+str*4)*k)*1.1','300+180*k','','','60','-(2*atk+(2*atk+2*dex+2*con+str*4)*k)*1.1','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','300+180*k',0,0,'MELEE',10,'1',0,400),(31,_binary '암습',2,1,1,0,'HP','-(atk+(1.2*atk+number(500,700)+dex*4+str*4)*k)','40+160*k','','','15','-(atk+(1.2*atk+number(500,700)+dex*4+str*4)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','40+160*k',0,0,'MELEE',6,'1',0,0),(32,_binary '궁\탤봇',2,1,1,0,'HP','-(atk+(1.6*atk+number(200,300)+dex*7+str*7)*k)','40+160*k','','','20','-(atk+(1.6*atk+number(200,300)+dex*7+str*7)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','40+160*k',0,0,'MELEE',6,'1',800,0),(33,_binary '\\湯互\',2,1,1,0,'HP','-(2*atk+(0.5*atk+dex*9+str*7)*k)','50+140*k','','','25','-(2*atk+(0.5*atk+dex*9+str*7)*k)','','ATTACK,USE_MELEE_DAMAGE,ATTACK_POISON','','NONE','40*k','','','','','','50+140*k',0,0,'MELEE',12,'1',0,0),(34,_binary '은\형법',2,1,1,0,'NONE','','30+60*k','15+30*k','','60','','','SELFONLY','EUNHYUNG','NONE','','','','','','','30+60*k',0,0,'NORMAL',1,'1',0,0),(35,_binary '\媛編\',2,1,1,0,'HP','-(lv*2+(atk+str*3+dex*18)*k)','40+130*k','','','25','-(lv*2+(atk+str*3+dex*18)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_POISON','','NONE','60*k','5+25*k','','','','','40+130*k',0,0,'MELEE',12,'1',800,200),(36,_binary '\흑섬\',2,1,1,0,'HP','-((lv*2+(atk+str*3+dex*18)*k)*1.1)','300+180*k','','','60','-((lv*2+(atk+str*3+dex*18)*k)*1.1)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_POISON','','NONE','60*k','5+25*k','','','','','300+180*k',0,0,'MELEE',6,'1',800,300),(46,_binary '연\',2,1,1,0,'HP','-(atk+0.2*atk*floor(2+k*6)+(0.8*atk+dex*8*ar+iq*2)*k)','40+160*k','','','10','-(atk+0.2*atk*floor(2+k*6)+(0.8*atk+dex*8*ar+iq*2)*k)','','ATTACK,USE_ARROW_DAMAGE,KNOCKBACK','','NONE','','','','','','','40+160*k',0,0,'RANGE',1,'1',2500,0),(47,_binary '관격술',2,1,1,0,'HP','-(atk+(1.7*atk+dex*5+str)*k)','30+150*k','','','15','-(atk+(1.7*atk+dex*5+str)*k)','','ATTACK,SPLASH,USE_ARROW_DAMAGE,ATTACK_SLOW','','NONE','50+dex*6*k','1+iq*0.4*k*0.1','','','','','30+150*k',0,0,'RANGE',8,'0.6',2500,200),(48,_binary '화조\\',2,1,1,0,'HP','-(1.5*atk+(2.6*atk+0.9*iq+number(100,300))*k)','30+160*k','','','15','-(1.5*atk+(2.6*atk+0.9*iq+number(100,300))*k)','','ATTACK,SPLASH,USE_ARROW_DAMAGE,ATTACK_FIRE_CONT','','NONE','lv+5*iq*k','(350+iq*4*k)/10','','','','','30+160*k',0,0,'RANGE',12,'1',2500,300),(49,_binary '\麗遍',2,1,1,0,'MOV_SPEED','60*k','60+220*k','3+(90*k)/10','','4+8*k','60*k','','SELFONLY','GYEONGGONG','NONE','(Lv*2+(3*dex+number(100,300))+str*2+iq*2)*k)','','','','','','60+220*k',0,0,'NORMAL',1,'1',0,200),(50,_binary '독\瘦\',2,1,1,0,'HP','-(atk+(1.4*atk+number(100,200)+dex*7+str*4+iq*4)*k)','40+160*k','','','18','-(atk+(1.4*atk+number(100,200)+dex*7+str*4+iq*4)*k)','','ATTACK,SPLASH,USE_ARROW_DAMAGE,CRUSH,ATTACK_POISON','','NONE','(50+dex*6*k)/10','15+30*k','','','','','40+160*k',0,0,'RANGE',12,'1',2500,600),(51,_binary '섬광탄',2,1,1,0,'HP','-((atk+(1.2*atk+number(100,200)+dex*6+str*3+iq*3)*k)*1.2)','200+200*k','1+iq*0.4*k*0.1','','60','-((atk+(1.2*atk+number(100,200)+dex*6+str*3+iq*3)*k)*1.2)','','ATTACK,SPLASH,USE_ARROW_DAMAGE,CRUSH,ATTACK_POISON','','NONE','(50+dex*6*k)/10','15+30*k','','','','','200+200*k',0,0,'RANGE',5,'1',0,400),(61,_binary '\綏\\',3,1,1,0,'HP','-(atk+2*lv+iq*2+(2*atk+str*4+iq*14)*k)','30+140*k','','','10','-(atk+2*lv+iq*2+(2*atk+str*4+iq*14)*k)','','ATTACK,USE_MELEE_DAMAGE,PENETRATE','','NONE','1+k*9','','','','','','30+140*k',0,0,'MELEE',4,'1',0,0),(62,_binary '\諭\\\',3,1,1,0,'HP','-(1.1*atk+2*lv+iq*2+(1.5*atk+str+iq*12)*k)','50+150*k','','','15','-(1.1*atk+2*lv+iq*2+(1.5*atk+str+iq*12)*k)','','ATTACK,USE_MELEE_DAMAGE,SELFONLY,SPLASH,IGNORE_TARGET_RATING','','NONE','1+k*9','','','','','','50+150*k',0,0,'MELEE',12,'1',0,500),(63,_binary '귀\',3,1,1,0,'ATT_GRADE','(3*iq+2*lv)*k','20+240*k','50+100*k','2+23*k','0','(3*iq+2*lv)*k','','SELFONLY,TOGGLE','GWIGUM','HIT_HP_RECOVER','10*k','50+100*k','','','','','20+240*k',0,0,'NORMAL',1,'1',0,0),(64,_binary '공\\',3,1,1,0,'DODGE','1+29*k','60+120*k','60+100*k','','100','1+29*k','','SELFONLY','TERROR','NONE','','','','','','','60+120*k',0,0,'NORMAL',1,'1',0,0),(65,_binary '주마갑',3,1,1,0,'DEF_GRADE','(iq+30)*k','70+170*k','30+120*k','','33+140*k','(iq+30)*k','','SELFONLY','JUMAGAP','REFLECT_MELEE','(iq/4+10)*k','30+120*k','','','','','70+170*k',0,0,'NORMAL',1,'1',0,0),(66,_binary '\파법술',3,1,1,0,'HP','-(40+5*lv+2*iq+(10*iq+7*mwep+number(50,1))*ar*k)','30+120*k','','','12','-(40+5*lv+2*iq+(10*iq+7*mwep+number(50,1))*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH,REMOVE_GOOD_AFFECT','','NONE','10+40*k','7+23*k','','','','','30+120*k',0,0,'NORMAL',5,'1',1800,200),(76,_binary '마\',3,1,1,0,'HP','-(40+5*lv+2*iq+(13*iq+6*mwep+number(50,1))*ar*k)','30+140*k','','','7','-(40+5*lv+2*iq+(13*iq+6*mwep+number(50,1))*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH','','NONE','','','','','','','30+140*k',0,0,'MAGIC',5,'1',1500,200),(77,_binary '화염\폭',3,1,1,0,'HP','-(5*lv+2*iq+(10*iq+6*mwep+str*4+con*2+number(180,2))*k)','60+140*k','','','12','-(5*lv+2*iq+(10*iq+6*mwep+str*4+con*2+number(180,2))*k)','','ATTACK,SELFONLY,COMPUTE_MAGIC_DAMAGE,SPLASH','','NONE','','','','','','','60+140*k',0,0,'MAGIC',15,'0.8',0,500),(78,_binary '무영진',3,1,1,0,'HP','-(30+2*lv+2*iq+(7*iq+6*mwep+number(200,5))*ar*k)','20+30*k','40+30*k','5+40*k','43+30*k','-(30+2*lv+2*iq+(7*iq+6*mwep+number(200,5))*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH,TOGGLE','','NONE','','','','','','','20+30*k',0,0,'MAGIC',1,'1',800,100),(79,_binary '\\逆탉\致',3,1,1,0,'DEF_GRADE','(0.5*iq+15)*k','20+30*k','60+120*k','5+10*k','63+120*k','(0.5*iq+15)*k','','SELFONLY,TOGGLE','MANASHIELD','MANASHIELD','100-((iq*0.84)*k)','60+120*k','','','','','20+30*k',0,0,'MAGIC',1,'1',0,0),(80,_binary '\\忖疸떱\',3,1,1,0,'HP','-(40+2*lv+2*iq+(2*con+2*dex+13*iq+6*mwep+number(180,2))*ar*k)','40+120*k','','','12','-(40+2*lv+2*iq+(2*con+2*dex+13*iq+6*mwep+number(180,2))*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH,ATTACK_SLOW','','NONE','333+300*k','10+10*k','','','','','40+120*k',0,0,'MAGIC',9,'1',1200,400),(81,_binary '마환\',3,1,1,0,'HP','-(120+6*lv+(5*con+5*dex+29*iq+9*mwep)*ar*k)','80+220*k','','','24','-(120+6*lv+(5*con+5*dex+29*iq+9*mwep)*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH','','NONE','','','','','','','80+220*k',0,0,'MAGIC',9,'1',1500,200),(91,_binary '\\파\',4,1,1,0,'HP','-(70+5*lv+(18*iq+str*7+5*mwep+50)*ar*k)','30+200*k','','','9','-(70+5*lv+(18*iq+str*7+5*mwep+50)*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH,ATTACK_SLOW','','NONE','3+iq*7*k','1+dex*0.4*k*0.1','','','','','30+200*k',0,0,'MAGIC',5,'1',1800,400),(92,_binary '\\파\',4,1,1,0,'HP','-(60+5*lv+(16*iq+dex*6+6*mwep+120)*ar*k)','50+280*k','','','10','-(60+5*lv+(16*iq+dex*6+6*mwep+120)*ar*k)','','ATTACK,ATTACK_FIRE_CONT,KNOCKBACK','','NONE','lv+5*iq*k','(100+iq*5*k)/10','','','','','50+280*k',0,0,'MAGIC',10,'1',800,0),(93,_binary '\패\\폭',4,1,1,0,'HP','-(70+3*lv+(20*iq+str*3+10*mwep+100)*ar*k)','70+380*k','','','12','-(70+3*lv+(20*iq+str*3+10*mwep+100)*ar*k)','','ATTACK,SPLASH,ATTACK_FIRE_CONT','','NONE','lv+5*iq*k','(100+iq*5*k)/10','','','','','70+380*k',0,0,'MAGIC',15,'1',2500,500),(94,_binary '호\',4,1,1,0,'RESIST_NORMAL','((iq*0.3+5)*(2*k+0.5)+(dex*0.3))/(k+2.3)','40+190*k','50+80*k','','10','((iq*0.3+5)*(2*k+0.5)+(dex*0.3))/(k+2.3)','','PARTY','HOSIN','NONE','','','','','','','40+190*k',0,0,'NORMAL',1,'1',2000,0),(95,_binary '반\',4,1,1,0,'REFLECT_MELEE','5+(iq*0.2+str*0.1)*k','60+120*(k+k)','60+200*k','','10','5+(iq*0.2+str*0.1)*k','','PARTY','BOHO','NONE','','','','','','','60+120*(k+k)',0,0,'NORMAL',1,'1',2000,0),(96,_binary '\輸뎬\諛',4,1,1,0,'CRITICAL','(iq*0.3+5)*(2*k)/(k+3)','50+180*k','60+100*k','','10','(iq*0.3+5)*(2*k)/(k+3)','','PARTY','GICHEON','NONE','','','','','','','50+180*k',0,0,'NORMAL',1,'1',2000,0),(106,_binary '뇌전\',4,1,1,0,'HP','-(60+5*lv+(8*iq+dex*2+8*mwep+number(iq*5,iq*15))*ar*k)','30+200*k','','','8','-(60+5*lv+(8*iq+dex*2+8*mwep+number(iq*5,iq*15))*ar*k)','','ATTACK,SPLASH','','NONE','','','','','','','30+200*k',0,0,'MAGIC',5,'1',1800,400),(107,_binary '벼\',4,1,1,0,'HP','-(40+4*lv+(13*iq+str*2+10*mwep+number(iq*5,iq*16))*ar*k)','50+300*k','','','10','-(40+4*lv+(13*iq+str*2+10*mwep+number(iq*5,iq*16))*ar*k)','','ATTACK,SPLASH,ATTACK_STUN','','NONE','30+70*2*k','1+str*0.2*k*0.1','','','','','50+300*k',0,0,'MAGIC',15,'1',1500,400),(108,_binary '\폭뢰\',4,1,1,0,'HP','-(50+5*lv+(8*iq+str*2+8*mwep+number(1,800))*ar*k)*(1-chain*0.13)','40+200*k','','','9','-(50+5*lv+(8*iq+str*2+8*mwep+number(1,800))*ar*k)*(1-chain*0.13)','','ATTACK,SPLASH,ATTACK_SLOW','','NONE','80+iq*5*k','1+str*0.4*k*0.1','','','','','40+200*k',0,0,'MAGIC',7,'1',2500,100),(109,_binary '정\汰\',4,1,1,0,'HP','150+5*lv+(10*iq+6*mwep+number(600,800))*(k+0.15)','40+250*k','','','10','150+5*lv+(10*iq+6*mwep+number(600,800))*(k+0.15)','','REMOVE_BAD_AFFECT,PARTY','','NONE','20+80*k','0','','','','','40+250*k',0,0,'NORMAL',1,'1',1000,0),(110,_binary '\\雍\',4,1,1,0,'MOV_SPEED','(dex*0.2)+35*k','60+120*k','60+100*k','','10','(dex*0.2)+35*k','','PARTY','KWAESOK','CASTING_SPEED','3+33*k','60+100*k','','','','','60+120*k',0,0,'NORMAL',1,'1',2000,0),(111,_binary '\燭쩌',4,1,1,0,'ATT_GRADE','3+(iq*0.2+str*0.1+11)*k','60+150*k','60+100*k','','10','3+(iq*0.2+str*0.1+11)*k','','PARTY','JEUNGRYEOK','NONE','','','','','','','60+150*k',0,0,'NORMAL',1,'1',2000,0),(121,_binary '\\堉囹\',0,1,40,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(122,_binary '연\穩\',0,1,2,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(124,_binary '채광술',0,1,40,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(125,_binary '변\',0,1,40,0,'NONE','','','10+1000*k','','','','','','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(126,_binary '신\淄\',0,1,20,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(127,_binary '천조\',0,1,20,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(128,_binary '진\毓\',0,1,20,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(129,_binary '둔갑술',0,1,40,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(130,_binary '승마',0,1,1,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(131,_binary '말\蘆',0,1,10,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(132,_binary 'AutoAttack',0,0,0,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(133,_binary 'RoleProficiency',0,1,40,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(134,_binary 'InSight',0,1,40,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(137,_binary '난무',5,1,1,50,'HP','-(atk+(2*atk*k))','60+80*k','','','5-(4*k)','-(atk+(2*atk*k))','','ATTACK,USE_MELEE_DAMAGE,CRUSH','','NONE','','','','','','','60+80*k',0,0,'MELEE',10,'1',300,0),(138,_binary '돌\',5,1,1,52,'HP','-(2.4*(200+1.5*lv)+(3*200*k))','60+120*k','','','15','-(2.4*(200+1.5*lv)+(3*200*k))','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH_LONG','','MOV_SPEED','50','5','','','','','60+120*k',0,0,'MELEE',6,'1',400,100),(139,_binary '탈\\',5,1,1,55,'HP','-(2*(200+1.5*lv)+(3*200*k))','60+160*k','','','20','-(2*(200+1.5*lv)+(3*200*k))','','ATTACK,USE_MELEE_DAMAGE,SELFONLY,SPLASH,CRUSH','','NONE','','','','','','','60+160*k',0,0,'MELEE',12,'1',400,250),(140,_binary '난무(활)',5,1,1,50,'HP','-(atk+(2*atk*k))','60+80*k','','','10','-(atk+(2*atk*k))','','ATTACK,USE_ARROW_DAMAGE,CRUSH','','NONE','','','','','','','60+80*k',0,0,'RANGE',5,'1',2500,0),(151,_binary '\毓\',0,1,7,0,'NONE','','','','','','','','','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(152,_binary '\戮\탔\\\',0,1,7,0,'MAX_HP','maxhp*0.2*k','150+150*k','300','','600','maxhp*0.2*k','','','','NONE','','','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(153,_binary '\戮\탔\\축복',0,1,7,0,'MAX_SP','maxsp*0.2*k','150+150*k','300','','600','maxsp*0.2*k','','','','NONE','','','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(154,_binary '성\휘갑',0,1,7,0,'DEF_GRADE','odef*0.1*k','150+150*k','180','','480','odef*0.1*k','','','','NONE','','','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(155,_binary '가\談',0,1,7,0,'MOV_SPEED','15*k','150+150*k','180','','480','15*k','','','','ATT_SPEED','15*k','180','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(156,_binary '\戮\탔퓟均\',0,1,7,0,'CRITICAL','50*k','150+150*k','180','','480','50*k','','','','NONE','','','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(157,_binary '주문술',0,1,7,0,'CASTING_SPEED','50*k','150+150*k','180','','480','50*k','','','','NONE','','','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(158,_binary '\役\揚絹',0,1,3,0,'NONE','','','','','','','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(159,_binary '공간의문',0,1,5,0,'NONE','','','','','','','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(160,_binary '가\談',0,1,5,0,'NONE','3*k','80-12*k','300','','','3*k','','SELFONLY','','NONE','','','','','','','80-12*k',0,0,'NORMAL',0,'1',0,0),(161,_binary '공간의문',0,1,2,0,'NONE','','50','','','','','','','','NONE','','','','','','','50',0,0,'NORMAL',0,'1',0,0),(162,_binary '공간이동',0,1,2,0,'NONE','','20','','','','','','','','NONE','','','','','','','20',0,0,'NORMAL',0,'1',0,0),(170,_binary '\\殆',7,1,1,0,'HP','-(1.1*atk+(0.3*atk+1.5*str)*k)','40+100*k','','','12','-(1.1*atk+(0.3*atk+1.5*str)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_BLEEDING','','NONE','60*k','5+25*k','','','','','40+100*k',0,0,'MELEE',5,'1',300,200),(171,_binary '\飴',7,1,1,0,'HP','-(2*atk+(atk+dex*3+str*5+con)*k)','40+120*k','','','20','-(2*atk+(atk+dex*3+str*5+con)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN,KNOCKBACK','','NONE','30+70*2*k','2','','','','','40+120*k',0,0,'MELEE',10,'1',1000,200),(172,_binary '공\\참',7,1,1,0,'HP','-(atk+(1.6*atk+200+dex*7+str*7)*k)','40+100*k','','','12','-(atk+(1.6*atk+200+dex*7+str*7)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','40+100*k',0,0,'MELEE',5,'1',800,100),(173,_binary '\파\',7,1,1,0,'HP','-(3*atk+(0.8*atk+str*6+dex*2+con)*k)','40+100*k','','','12','-(3*atk+(0.8*atk+str*6+dex*2+con)*k)','','ATTACK,USE_MELEE_DAMAGE','','DEF_GRADE','-30*k','5','','','','','40+100*k',0,0,'MELEE',10,'1',800,100),(174,_binary '적랑빙\',7,1,1,0,'ATT_GRADE','7+(4*iq+13)*k','20+240*k','45+60*k','2+23*k','10+10*k','7+(4*iq+13)*k','','SELFONLY,TOGGLE','RED_POSSESSION','PENETRATE','1+((iq*0.4)*k)*0.24','45+60*k','RED_POSSESSION','','','','20+240*k',0,0,'NORMAL',1,'1',0,0),(175,_binary '청랑빙\',7,1,1,0,'ATT_SPEED','20*k','80+220*k','200','','300','20*k','','PARTY','BLUE_POSSESSION','DODGE','1+10*k','200','','','','','80+220*k',0,0,'NORMAL',1,'1',1000,0),(176,_binary '\피니쉬',1,1,1,0,'HP','-(3*atk+(0.9*atk+number(1,1000)+str*5+dex*3+lv)*k)','200+200*k','','','35+20*k','-(3*atk+(0.9*atk+number(1,1000)+str*5+dex*3+lv)*k)','','ATTACK,USE_MELEE_DAMAGE,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MELEE',8,'1',0,200),(177,_binary '일광표',2,1,1,0,'HP','-(atk+(1.7*atk+number(1,1000)+dex*6+lv*5)*k)','200+200*k','','','35+20*k','-(atk+(1.7*atk+number(1,1000)+dex*6+lv*5)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MELEE',10,'1',2000,200),(178,_binary '풍\\\',2,1,1,0,'HP','-(1.9*atk+(2.6*atk+number(1,1000))*k)','200+200*k','','','35+20*k','-(1.9*atk+(2.6*atk+number(1,1000))*k)','','ATTACK,SPLASH,USE_ARROW_DAMAGE,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'RANGE',8,'1',2500,200),(179,_binary '악\',3,1,1,0,'HP','-(1.9*atk+(2.6*atk+number(1,1000))*k)','200+200*k','','','35+20*k','-(1.9*atk+(2.6*atk+number(1,1000))*k)','','ATTACK,USE_MELEE_DAMAGE,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MELEE',4,'1',0,0),(180,_binary '\흑마악\',3,1,1,0,'HP','-(120+6*lv+(5*con+5*dex+30*iq+number(1,1)+9*mwep)*ar*k)','200+200*k','','','35+20*k','-(120+6*lv+(5*con+5*dex+30*iq+number(1,1)+9*mwep)*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MAGIC',5,'1',2000,200),(181,_binary '\\테오',4,1,1,0,'HP','-(120+6*lv+(5*con+5*dex+30*iq+number(1,1)+9*mwep)*ar*k)','200+200*k','','','35+20*k','-(120+6*lv+(5*con+5*dex+30*iq+number(1,1)+9*mwep)*ar*k)','','ATTACK,SPLASH,ATTACK_FIRE_CONT,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MAGIC',5,'1',2000,500),(182,_binary '천\',4,1,1,0,'NONE','0.4*k+(18*k)','200+200*k','50+(8*k)','','386+(80*k)','0.4*k+(18*k)','','DISABLE_BY_POINT_UP,PARTY','','NONE','4*k','','','','','','200+200*k',0,0,'NORMAL',1,'1',2000,0),(183,_binary '이리풍\',7,1,1,0,'HP','-(1.8*atk+(atk+dex*6+number(1,1000)+str*3+lv)*k)','200+200*k','','','35+20*k','-(1.8*atk+(atk+dex*6+number(1,1000)+str*3+lv)*k)','','ATTACK,USE_MELEE_DAMAGE,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MELEE',8,'1',0,200),(221,_binary '\팔\戀냄\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(222,_binary '암습\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(223,_binary '\綏\\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(224,_binary '\\파\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(225,_binary '\璲\참\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(226,_binary '화조\\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(227,_binary '마\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(228,_binary '벼\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(229,_binary '\飴\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(236,_binary '\팔\戀냄李화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(237,_binary '암습강화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(238,_binary '\綏\\側화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(239,_binary '\\파산강화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(240,_binary '\璲\참강화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(241,_binary '화조\파강화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(242,_binary '마령강화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(243,_binary '벼\瘠화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(244,_binary '\飴낡화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(246,_binary 'hit',0,1,40,0,'NONE','0.4*k+(32*k/2)','','','','','0.4*k+(32*k/2)','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(256,_binary 'CRUSH200스킬',0,1,1,0,'HP','-5*k*atk','','','','2','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,300),(257,_binary '일반범위350스킬',0,1,1,0,'HP','-5*k*atk','','','','5','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,525),(258,_binary 'CRUSH300스킬',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,450),(259,_binary '일반범위200스킬',0,1,1,0,'HP','-5*k*atk','','','','9','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,300),(260,_binary 'CURSH400스킬',0,1,1,0,'HP','-5*k*atk','','','','10','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,600),(261,_binary '독250스킬',0,1,1,0,'HP','-5*k*atk','','','','9','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_POISON','','NONE','80','','','','','','',0,0,'MELEE',0,'1',0,375),(262,_binary 'SLOW300스킬',0,1,1,0,'HP','-5*k*atk','','','','12','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','MOV_SPEED','-20','10','','','','','',0,0,'MELEE',0,'1',0,450),(263,_binary 'SLOW4000스킬',0,1,1,0,'HP','-5*k*atk','','','','12','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','MOV_SPEED','-70','3','SLOW','','','','',0,0,'MELEE',0,'1',2000,6000),(264,_binary 'THUNDER스킬',0,1,1,0,'HP','-maxhp*k','','','','12','-maxhp*k','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,500),(265,_binary 'HEAL4000스킬',0,1,1,0,'HP','0.1*maxhp*k','','','','5','0.1*maxhp*k','','PARTY','','NONE','','','','','','','',0,0,'NORMAL',1,'1',3000,0),(266,_binary 'ATTACK_SLOW',0,1,1,0,'NONE','','','','','','','','SELFONLY,SPLASH','','NONE','','','','','','','',0,0,'NORMAL',1,'1',0,3000),(267,_binary '일\0스킬',0,1,1,0,'HP','-5*k*atk','','','','10','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,0),(268,_binary 'CRUSH0스킬',0,1,1,0,'HP','-5*k*atk','','','','10','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,CRUSH','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,0),(269,_binary 'STUN200',0,1,1,0,'HP','-5*k*atk','','','','10','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN','','NONE','1000','3','','','','','',0,0,'MELEE',0,'1',0,300),(270,_binary 'normal_range_attack_confustion',0,1,1,0,'HP','-5*k*atk','','','','5','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','80*k','','','','','','',0,0,'MELEE',0,'1',0,525),(271,_binary 'knockback_hp_absorb',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,HP_ABSORB,CRUSH','','NONE','10','','','','','','',0,0,'MELEE',0,'1',0,350),(272,_binary 'knockback_bleeding',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH,ATTACK_BLEEDING','','NONE','100','','','','','','',0,0,'MELEE',0,'1',0,350),(273,_binary 'wide_area_damage_stun',0,1,1,0,'HP','-maxhp*k','','','','12','-maxhp*k','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN,CRUSH','','NONE','1000','4','','','','','',0,0,'MELEE',0,'1',0,500),(274,_binary 'wide_area_damage_sungma_str',0,1,1,0,'SUNGMA_STR','-40*k','','10','','12','-40*k','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','HP','-maxhp*k','0','','','','','',0,0,'MELEE',0,'1',1000,300),(275,_binary 'splash400_bleeding',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_BLEEDING','','NONE','30','','','','','','',0,0,'MELEE',0,'1',0,400),(276,_binary 'stun300',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN','','NONE','200','3','','','','','',0,0,'MELEE',0,'1',0,300),(277,_binary 'splash400_poison',0,1,1,0,'HP','-5*k*atk','','','','5','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_POISON','','NONE','10','','','','','','',0,0,'MELEE',0,'1',0,400),(278,_binary 'stun400',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN','','NONE','200','3','','','','','',0,0,'MELEE',0,'1',0,400),(279,_binary 'maze_keingnoll_boss_skill3',0,1,1,0,'HP','-5*k*atk','','','','20','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,HP_ABSORB','','NONE','50','','','','','','',0,0,'NORMAL',0,'1',0,400),(280,_binary 'posion_damage_sungma_move',0,1,1,1,'HP','-5*k*atk','','','','9','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_POISON','','NONE','80','','','','','','',0,0,'MELEE',0,'1',0,375),(281,_binary 'crush_damage_sungma_str',0,1,1,1,'HP','-5*k*atk','','','','17','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','SUNGMA_STR','-20','10','','','','','',0,0,'MELEE',0,'1',0,375),(282,_binary 'shackle_damage',0,1,1,1,'HP','-5*k*atk','','','','25','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','MOV_SPEED','0','3','','','','','',0,0,'MELEE',0,'1',0,450),(283,_binary 'white_dragon_skill0',0,1,1,0,'HP','-5*k*atk','','','','24','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','0','0','','','','','',0,0,'MELEE',0,'1',0,300),(284,_binary 'white_dragon_skill2',0,1,1,0,'HP','-5*k*atk','','','','45','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','50','','','','','','',0,0,'MELEE',0,'1',0,900),(285,_binary '날쌘돌\(이\)',8,1,1,0,'MOUNT_UPGRADE_NIMBLE','(4+(horselv*skilllv/100))*(skilllv/3)','','3+(skilllv*(horselv*0.4))/20','','180','(4+(horselv*skilllv/100))*(skilllv/3)','','SELFONLY','','MOV_SPEED','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(286,_binary '\\\蝸',8,1,1,0,'MALL_EXPBONUS','((horselv*skilllv/100)+1.5)+(skilllv/8)','','','','','((horselv*skilllv/100)+1.5)+(skilllv/8)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(287,_binary '질풍(공\)',8,1,1,0,'MOUNT_UPGRADE_SPEED','(5+(horselv*skilllv/600))*(skilllv/5)','','3+(skilllv*(horselv*0.4))/20','','180','(5+(horselv*skilllv/600))*(skilllv/5)','','SELFONLY','','ATT_SPEED','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(288,_binary '\麗遍',8,1,1,0,'NONE','(horselv*(skilllv*number(5,10)))/40*skilllv','','1+(skilllv*(horselv*0.3))/20','','300','(horselv*(skilllv*number(5,10)))/40*skilllv','','','','NONE','(horselv*(skilllv*10))/40*skilllv','','','','','','',0,0,'NORMAL',0,'1',1000,0),(289,_binary '무적',8,1,1,0,'NONE','','','(horselv*(skilllv*0.3))/60','','600','','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(290,_binary '넉\埇譴森',8,1,1,0,'MOUNT_UPGRADE_NO_KNOCKBACK','','','3+(skilllv*(horselv*0.5))/20','','180','','','','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(291,_binary '랜덤에게강\\纛寬',8,1,1,0,'ATTBONUS_HUMAN','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(292,_binary '랜덤에게강\함동물',8,1,1,0,'ATTBONUS_ANIMAL','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(293,_binary '랜덤에게강\함\超\',8,1,1,0,'ATTBONUS_ORC','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(294,_binary '랜덤에게강\함밀교',8,1,1,0,'ATTBONUS_MILGYO','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(295,_binary '랜덤에게강\함언데\',8,1,1,0,'ATTBONUS_UNDEAD','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(296,_binary '랜덤에게강\함악마',8,1,1,0,'ATTBONUS_DEVIL','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(297,_binary '랜덤에게강\함\各\訣\',8,1,1,0,'ATTBONUS_CZ','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(298,_binary '랜덤에게강\함사막',8,1,1,0,'ATTBONUS_DESERT','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(299,_binary '랜덤에게강\함\\\',8,1,1,0,'ATTBONUS_INSECT','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(300,_binary '랜덤에게강\함\醍\潁\澯\\',8,1,1,0,'ATTBONUS_MONSTER','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(301,_binary '탑\쩝\像罐뗄\箸효과\澯\',8,1,1,0,'NONE','k*(skilllv/(140-horselv))','','','','','k*(skilllv/(140-horselv))','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(302,_binary '\態\耽\\(무\)',8,1,1,0,'ATTBONUS_WARRIOR','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(303,_binary '\態\耽\\(자객)',8,1,1,0,'ATTBONUS_ASSASSIN','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(304,_binary '\態\耽\\(\侈\)',8,1,1,0,'ATTBONUS_SURA','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(305,_binary '\態\耽\\(무\)',8,1,1,0,'ATTBONUS_SHAMAN','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(306,_binary '\態\耽\\(\痔\)',8,1,1,0,'ATTBONUS_WOLF','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(307,_binary '성마\\힘',8,1,1,0,'MOUNT_UPGRADE_SUNGMA_STR','3+(horselv*skilllv)*(skilllv/500)','','3+(skilllv*(horselv*0.4))/20','','180','3+(horselv*skilllv)*(skilllv/500)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(308,_binary '성마의\택',8,1,1,0,'MOUNT_UPGRADE_SUNGMA_HP','3+(horselv*skilllv)*(skilllv/500)','','3+(skilllv*(horselv*0.4))/20','','180','3+(horselv*skilllv)*(skilllv/500)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(309,_binary '성마\\항\',8,1,1,0,'MOUNT_UPGRADE_SUNGMA_MOVE','3+(horselv*skilllv)*(skilllv/500)','','3+(skilllv*(horselv*0.4))/20','','180','3+(horselv*skilllv)*(skilllv/500)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(310,_binary '성마\프\梔',8,1,1,0,'MOUNT_UPGRADE_SUNGMA_IMMUNE','3+(horselv*skilllv)*(skilllv/500)','','3+(skilllv*(horselv*0.4))/20','','180','3+(horselv*skilllv)*(skilllv/500)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(311,_binary '\雌\',8,1,1,0,'HIT_PCT','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(312,_binary '동\쪽\瑛\(스킬1)',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,HP_ABSORB','','NONE','20','','','','','','',0,0,'MELEE',1,'1',0,400),(313,_binary '동\쪽\瑛\(스킬2)',0,1,1,0,'HP','-15*k*atk','','','','23','-15*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,1000),(314,_binary '서\쪽\瑛\(스킬2)',0,1,1,0,'HP','-5*k*atk','','','','18','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH,ATTACK_BLEEDING','','NONE','30','','','','','','',0,0,'MELEE',0,'1',0,400),(315,_binary '남\쪽\瑛\(스킬1)',0,1,1,0,'HP','-5*k*atk','','','','30','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,HP_ABSORB','','NONE','10','','','','','','',0,0,'MELEE',1,'1',0,400),(316,_binary '남\쪽\瑛\(스킬2)',0,1,1,0,'HP','-5*k*atk','','','','47','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,1000),(317,_binary '\\쪽\瑛\(스킬1)',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN','','NONE','1000','3','','','','','',0,0,'MELEE',1,'1',0,400),(318,_binary '\\쪽\瑛\(스킬2)',0,1,1,0,'HP','-5*k*atk','','','','15','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,400),(319,_binary '염\(스킬1)',0,1,1,0,'HP','-5*k*atk','','','','6','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,300),(320,_binary '염\(스킬2)',0,1,1,0,'HP','-5*k*atk','','','','31','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,300),(321,_binary '염\(스킬3)',0,1,1,0,'HP','-5*k*atk','','','','14','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_BLEEDING','','NONE','100','','','','','','',0,0,'MELEE',0,'1',0,1000),(322,_binary 'change_equipment_page',0,0,0,0,'NONE','','','','','3','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(329,_binary '\騈\(스킬1)',0,1,1,0,'HP','-5*k*atk','','','','12','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,1500),(330,_binary '\騈\(스킬2)',0,1,1,0,'HP','-5*k*atk','','','','33','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','100','','','','','','',0,0,'MELEE',0,'1',0,1200),(331,_binary '\騈\(스킬3)',0,1,1,0,'HP','-5*k*atk','','','','20','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,1500),(332,_binary '티\車\(스킬1)',0,1,1,0,'HP','-5*k*atk','','','','12','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH,ATTACK_POISON','','NONE','10','31','','','','','',0,0,'MELEE',0,'1',0,500),(333,_binary '티\車\(스킬2)',0,1,1,0,'HP','-5*k*atk','','','','17','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN,CRUSH','','NONE','20','3','','','','','',0,0,'MELEE',0,'1',0,300),(334,_binary '티\車\(스킬3)',0,1,1,0,'HP','-5*k*atk','','','','26','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,600);
+INSERT INTO `skill_proto` VALUES (1,_binary '占\',1,1,1,0,'HP','-(1.1*atk+(0.5*atk+1.5*str)*k)','40+100*k','','','12','-(1.1*atk+(0.5*atk+1.5*str)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','40+100*k',0,0,'MELEE',5,'1',0,200),(2,_binary '\획\풍\',1,1,1,0,'HP','-(3*atk+(0.8*atk+str*5+dex*3+con)*k)','50+130*k','','','15','-(3*atk+(0.8*atk+str*5+dex*3+con)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','50+130*k',0,0,'MELEE',12,'1',0,200),(3,_binary '\혼',1,1,1,0,'ATT_SPEED','50*k','50+140*k','60+90*k','','63+90*k','50*k','','SELFONLY','JEONGWIHON','MOV_SPEED','20*k','60+90*k','','','','','50+140*k',0,0,'NORMAL',1,'1',0,0),(4,_binary '江\',1,1,1,0,'ATT_GRADE','(100+str+lv*3)*k','100+200*k','30+50*k','','33+50*k','(100+str+lv*3)*k','','SELFONLY','GEOMGYEONG','NONE','','','','','','','100+200*k',0,0,'NORMAL',1,'1',0,0),(5,_binary '탄환\',1,1,1,0,'HP','-(2*atk+(atk+dex*3+str*7+con)*k)','60+120*k','','','12','-(2*atk+(atk+dex*3+str*7+con)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','MOV_SPEED','150','3','','','','','60+120*k',0,0,'MELEE',4,'1',0,200),(6,_binary '\\\\\\',1,1,1,0,'HP','-(3*atk+(atk+1.5*str)*k)*1.07','300+150*k','','','60','-(3*atk+(atk+1.5*str)*k)*1.07','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','300+150*k',0,0,'MELEE',5,'1',0,0),(16,_binary '\\',1,1,1,0,'HP','-(2.3*atk+(4*atk+str*4+con)*k)','60+120*k','','','15','-(2.3*atk+(4*atk+str*4+con)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','60+120*k',0,0,'MELEE',4,'1',0,100),(17,_binary '部\타\',1,1,1,0,'HP','-(2.3*atk+(3*atk+str*4+con*3)*k)','60+150*k','','','15','-(2.3*atk+(3*atk+str*4+con*3)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','60+150*k',0,0,'MELEE',8,'1',0,200),(18,_binary '\',1,1,1,0,'HP','-(2*atk+(2*atk+2*dex+2*con+str*4)*k)','50+140*k','','','25','-(2*atk+(2*atk+2*dex+2*con+str*4)*k)','','ATTACK,USE_MELEE_DAMAGE,SELFONLY,SPLASH,ATTACK_STUN','','NONE','100+k*1000/6','2','','','','','50+140*k',0,0,'MELEE',10,'1',0,400),(19,_binary '천\\\',1,1,1,0,'DEF_GRADE','(200+str*0.2+con*0.5)*k','80+220*k','60+90*k','','63+90*k','(200+str*0.2+con*0.5)*k','','SELFONLY','CHEONGEUN','MOV_SPEED','-(1+9*k)','60+90*k','','','','','80+220*k',0,0,'NORMAL',1,'1',0,0),(20,_binary '\풍',1,1,1,0,'HP','-(2*atk+(atk+dex*3+str*5+con)*k)','40+120*k','','','20','-(2*atk+(atk+dex*3+str*5+con)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','40+120*k',0,0,'MELEE',10,'1',1200,200),(21,_binary '綱',1,1,1,0,'HP','-(2*atk+(2*atk+2*dex+2*con+str*4)*k)*1.1','300+180*k','','','60','-(2*atk+(2*atk+2*dex+2*con+str*4)*k)*1.1','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','300+180*k',0,0,'MELEE',10,'1',0,400),(31,_binary '絿',2,1,1,0,'HP','-(atk+(1.2*atk+number(500,700)+dex*4+str*4)*k)','40+160*k','','','15','-(atk+(1.2*atk+number(500,700)+dex*4+str*4)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','40+160*k',0,0,'MELEE',6,'1',0,0),(32,_binary '첵\탄',2,1,1,0,'HP','-(atk+(1.6*atk+number(200,300)+dex*7+str*7)*k)','40+160*k','','','20','-(atk+(1.6*atk+number(200,300)+dex*7+str*7)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','40+160*k',0,0,'MELEE',6,'1',800,0),(33,_binary '\\\',2,1,1,0,'HP','-(2*atk+(0.5*atk+dex*9+str*7)*k)','50+140*k','','','25','-(2*atk+(0.5*atk+dex*9+str*7)*k)','','ATTACK,USE_MELEE_DAMAGE,ATTACK_POISON','','NONE','40*k','','','','','','50+140*k',0,0,'MELEE',12,'1',0,0),(34,_binary '\',2,1,1,0,'NONE','','30+60*k','15+30*k','','60','','','SELFONLY','EUNHYUNG','NONE','','','','','','','30+60*k',0,0,'NORMAL',1,'1',0,0),(35,_binary '\\',2,1,1,0,'HP','-(lv*2+(atk+str*3+dex*18)*k)','40+130*k','','','25','-(lv*2+(atk+str*3+dex*18)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_POISON','','NONE','60*k','5+25*k','','','','','40+130*k',0,0,'MELEE',12,'1',800,200),(36,_binary '\轢\',2,1,1,0,'HP','-((lv*2+(atk+str*3+dex*18)*k)*1.1)','300+180*k','','','60','-((lv*2+(atk+str*3+dex*18)*k)*1.1)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_POISON','','NONE','60*k','5+25*k','','','','','300+180*k',0,0,'MELEE',6,'1',800,300),(46,_binary '\',2,1,1,0,'HP','-(atk+0.2*atk*floor(2+k*6)+(0.8*atk+dex*8*ar+iq*2)*k)','40+160*k','','','10','-(atk+0.2*atk*floor(2+k*6)+(0.8*atk+dex*8*ar+iq*2)*k)','','ATTACK,USE_ARROW_DAMAGE,KNOCKBACK','','NONE','','','','','','','40+160*k',0,0,'RANGE',1,'1',2500,0),(47,_binary '釜',2,1,1,0,'HP','-(atk+(1.7*atk+dex*5+str)*k)','30+150*k','','','15','-(atk+(1.7*atk+dex*5+str)*k)','','ATTACK,SPLASH,USE_ARROW_DAMAGE,ATTACK_SLOW','','NONE','50+dex*6*k','1+iq*0.4*k*0.1','','','','','30+150*k',0,0,'RANGE',8,'0.6',2500,200),(48,_binary '화\\',2,1,1,0,'HP','-(1.5*atk+(2.6*atk+0.9*iq+number(100,300))*k)','30+160*k','','','15','-(1.5*atk+(2.6*atk+0.9*iq+number(100,300))*k)','','ATTACK,SPLASH,USE_ARROW_DAMAGE,ATTACK_FIRE_CONT','','NONE','lv+5*iq*k','(350+iq*4*k)/10','','','','','30+160*k',0,0,'RANGE',12,'1',2500,300),(49,_binary '\',2,1,1,0,'MOV_SPEED','60*k','60+220*k','3+(90*k)/10','','4+8*k','60*k','','SELFONLY','GYEONGGONG','NONE','(Lv*2+(3*dex+number(100,300))+str*2+iq*2)*k)','','','','','','60+220*k',0,0,'NORMAL',1,'1',0,200),(50,_binary '\\',2,1,1,0,'HP','-(atk+(1.4*atk+number(100,200)+dex*7+str*4+iq*4)*k)','40+160*k','','','18','-(atk+(1.4*atk+number(100,200)+dex*7+str*4+iq*4)*k)','','ATTACK,SPLASH,USE_ARROW_DAMAGE,CRUSH,ATTACK_POISON','','NONE','(50+dex*6*k)/10','15+30*k','','','','','40+160*k',0,0,'RANGE',12,'1',2500,600),(51,_binary '탄',2,1,1,0,'HP','-((atk+(1.2*atk+number(100,200)+dex*6+str*3+iq*3)*k)*1.2)','200+200*k','1+iq*0.4*k*0.1','','60','-((atk+(1.2*atk+number(100,200)+dex*6+str*3+iq*3)*k)*1.2)','','ATTACK,SPLASH,USE_ARROW_DAMAGE,CRUSH,ATTACK_POISON','','NONE','(50+dex*6*k)/10','15+30*k','','','','','200+200*k',0,0,'RANGE',5,'1',0,400),(61,_binary '\\\',3,1,1,0,'HP','-(atk+2*lv+iq*2+(2*atk+str*4+iq*14)*k)','30+140*k','','','10','-(atk+2*lv+iq*2+(2*atk+str*4+iq*14)*k)','','ATTACK,USE_MELEE_DAMAGE,PENETRATE','','NONE','1+k*9','','','','','','30+140*k',0,0,'MELEE',4,'1',0,0),(62,_binary '\\\\',3,1,1,0,'HP','-(1.1*atk+2*lv+iq*2+(1.5*atk+str+iq*12)*k)','50+150*k','','','15','-(1.1*atk+2*lv+iq*2+(1.5*atk+str+iq*12)*k)','','ATTACK,USE_MELEE_DAMAGE,SELFONLY,SPLASH,IGNORE_TARGET_RATING','','NONE','1+k*9','','','','','','50+150*k',0,0,'MELEE',12,'1',0,500),(63,_binary '叩\',3,1,1,0,'ATT_GRADE','(3*iq+2*lv)*k','20+240*k','50+100*k','2+23*k','0','(3*iq+2*lv)*k','','SELFONLY,TOGGLE','GWIGUM','HIT_HP_RECOVER','10*k','50+100*k','','','','','20+240*k',0,0,'NORMAL',1,'1',0,0),(64,_binary '\\',3,1,1,0,'DODGE','1+29*k','60+120*k','60+100*k','','100','1+29*k','','SELFONLY','TERROR','NONE','','','','','','','60+120*k',0,0,'NORMAL',1,'1',0,0),(65,_binary '寧',3,1,1,0,'DEF_GRADE','(iq+30)*k','70+170*k','30+120*k','','33+140*k','(iq+30)*k','','SELFONLY','JUMAGAP','REFLECT_MELEE','(iq/4+10)*k','30+120*k','','','','','70+170*k',0,0,'NORMAL',1,'1',0,0),(66,_binary '\캣',3,1,1,0,'HP','-(40+5*lv+2*iq+(10*iq+7*mwep+number(50,1))*ar*k)','30+120*k','','','12','-(40+5*lv+2*iq+(10*iq+7*mwep+number(50,1))*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH,REMOVE_GOOD_AFFECT','','NONE','10+40*k','7+23*k','','','','','30+120*k',0,0,'NORMAL',5,'1',1800,200),(76,_binary '\',3,1,1,0,'HP','-(40+5*lv+2*iq+(13*iq+6*mwep+number(50,1))*ar*k)','30+140*k','','','7','-(40+5*lv+2*iq+(13*iq+6*mwep+number(50,1))*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH','','NONE','','','','','','','30+140*k',0,0,'MAGIC',5,'1',1500,200),(77,_binary '화\',3,1,1,0,'HP','-(5*lv+2*iq+(10*iq+6*mwep+str*4+con*2+number(180,2))*k)','60+140*k','','','12','-(5*lv+2*iq+(10*iq+6*mwep+str*4+con*2+number(180,2))*k)','','ATTACK,SELFONLY,COMPUTE_MAGIC_DAMAGE,SPLASH','','NONE','','','','','','','60+140*k',0,0,'MAGIC',15,'0.8',0,500),(78,_binary '',3,1,1,0,'HP','-(30+2*lv+2*iq+(7*iq+6*mwep+number(200,5))*ar*k)','20+30*k','40+30*k','5+40*k','43+30*k','-(30+2*lv+2*iq+(7*iq+6*mwep+number(200,5))*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH,TOGGLE','','NONE','','','','','','','20+30*k',0,0,'MAGIC',1,'1',800,100),(79,_binary '\\탉\호',3,1,1,0,'DEF_GRADE','(0.5*iq+15)*k','20+30*k','60+120*k','5+10*k','63+120*k','(0.5*iq+15)*k','','SELFONLY,TOGGLE','MANASHIELD','MANASHIELD','100-((iq*0.84)*k)','60+120*k','','','','','20+30*k',0,0,'MAGIC',1,'1',0,0),(80,_binary '\\疸\',3,1,1,0,'HP','-(40+2*lv+2*iq+(2*con+2*dex+13*iq+6*mwep+number(180,2))*ar*k)','40+120*k','','','12','-(40+2*lv+2*iq+(2*con+2*dex+13*iq+6*mwep+number(180,2))*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH,ATTACK_SLOW','','NONE','333+300*k','10+10*k','','','','','40+120*k',0,0,'MAGIC',9,'1',1200,400),(81,_binary '환\',3,1,1,0,'HP','-(120+6*lv+(5*con+5*dex+29*iq+9*mwep)*ar*k)','80+220*k','','','24','-(120+6*lv+(5*con+5*dex+29*iq+9*mwep)*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH','','NONE','','','','','','','80+220*k',0,0,'MAGIC',9,'1',1500,200),(91,_binary '\\캤\',4,1,1,0,'HP','-(70+5*lv+(18*iq+str*7+5*mwep+50)*ar*k)','30+200*k','','','9','-(70+5*lv+(18*iq+str*7+5*mwep+50)*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH,ATTACK_SLOW','','NONE','3+iq*7*k','1+dex*0.4*k*0.1','','','','','30+200*k',0,0,'MAGIC',5,'1',1800,400),(92,_binary '\\캥\',4,1,1,0,'HP','-(60+5*lv+(16*iq+dex*6+6*mwep+120)*ar*k)','50+280*k','','','10','-(60+5*lv+(16*iq+dex*6+6*mwep+120)*ar*k)','','ATTACK,ATTACK_FIRE_CONT,KNOCKBACK','','NONE','lv+5*iq*k','(100+iq*5*k)/10','','','','','50+280*k',0,0,'MAGIC',10,'1',800,0),(93,_binary '\鈞\\',4,1,1,0,'HP','-(70+3*lv+(20*iq+str*3+10*mwep+100)*ar*k)','70+380*k','','','12','-(70+3*lv+(20*iq+str*3+10*mwep+100)*ar*k)','','ATTACK,SPLASH,ATTACK_FIRE_CONT','','NONE','lv+5*iq*k','(100+iq*5*k)/10','','','','','70+380*k',0,0,'MAGIC',15,'1',2500,500),(94,_binary '호\',4,1,1,0,'RESIST_NORMAL','((iq*0.3+5)*(2*k+0.5)+(dex*0.3))/(k+2.3)','40+190*k','50+80*k','','10','((iq*0.3+5)*(2*k+0.5)+(dex*0.3))/(k+2.3)','','PARTY','HOSIN','NONE','','','','','','','40+190*k',0,0,'NORMAL',1,'1',2000,0),(95,_binary '部\',4,1,1,0,'REFLECT_MELEE','5+(iq*0.2+str*0.1)*k','60+120*(k+k)','60+200*k','','10','5+(iq*0.2+str*0.1)*k','','PARTY','BOHO','NONE','','','','','','','60+120*(k+k)',0,0,'NORMAL',1,'1',2000,0),(96,_binary '\천\',4,1,1,0,'CRITICAL','(iq*0.3+5)*(2*k)/(k+3)','50+180*k','60+100*k','','10','(iq*0.3+5)*(2*k)/(k+3)','','PARTY','GICHEON','NONE','','','','','','','50+180*k',0,0,'NORMAL',1,'1',2000,0),(106,_binary '\',4,1,1,0,'HP','-(60+5*lv+(8*iq+dex*2+8*mwep+number(iq*5,iq*15))*ar*k)','30+200*k','','','8','-(60+5*lv+(8*iq+dex*2+8*mwep+number(iq*5,iq*15))*ar*k)','','ATTACK,SPLASH','','NONE','','','','','','','30+200*k',0,0,'MAGIC',5,'1',1800,400),(107,_binary '\',4,1,1,0,'HP','-(40+4*lv+(13*iq+str*2+10*mwep+number(iq*5,iq*16))*ar*k)','50+300*k','','','10','-(40+4*lv+(13*iq+str*2+10*mwep+number(iq*5,iq*16))*ar*k)','','ATTACK,SPLASH,ATTACK_STUN','','NONE','30+70*2*k','1+str*0.2*k*0.1','','','','','50+300*k',0,0,'MAGIC',15,'1',1500,400),(108,_binary '\微\',4,1,1,0,'HP','-(50+5*lv+(8*iq+str*2+8*mwep+number(1,800))*ar*k)*(1-chain*0.13)','40+200*k','','','9','-(50+5*lv+(8*iq+str*2+8*mwep+number(1,800))*ar*k)*(1-chain*0.13)','','ATTACK,SPLASH,ATTACK_SLOW','','NONE','80+iq*5*k','1+str*0.4*k*0.1','','','','','40+200*k',0,0,'MAGIC',7,'1',2500,100),(109,_binary '\\',4,1,1,0,'HP','150+5*lv+(10*iq+6*mwep+number(600,800))*(k+0.15)','40+250*k','','','10','150+5*lv+(10*iq+6*mwep+number(600,800))*(k+0.15)','','REMOVE_BAD_AFFECT,PARTY','','NONE','20+80*k','0','','','','','40+250*k',0,0,'NORMAL',1,'1',1000,0),(110,_binary '\\\',4,1,1,0,'MOV_SPEED','(dex*0.2)+35*k','60+120*k','60+100*k','','10','(dex*0.2)+35*k','','PARTY','KWAESOK','CASTING_SPEED','3+33*k','60+100*k','','','','','60+120*k',0,0,'NORMAL',1,'1',2000,0),(111,_binary '\쩌',4,1,1,0,'ATT_GRADE','3+(iq*0.2+str*0.1+11)*k','60+150*k','60+100*k','','10','3+(iq*0.2+str*0.1+11)*k','','PARTY','JEUNGRYEOK','NONE','','','','','','','60+150*k',0,0,'NORMAL',1,'1',2000,0),(121,_binary '\\囹\',0,1,40,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(122,_binary '\\',0,1,2,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(124,_binary '채',0,1,40,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(125,_binary '\',0,1,40,0,'NONE','','','10+1000*k','','','','','','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(126,_binary '탉\\',0,1,20,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(127,_binary '천\',0,1,20,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(128,_binary '\\',0,1,20,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(129,_binary '逵',0,1,40,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(130,_binary '쨍',0,1,1,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(131,_binary '\환',0,1,10,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(132,_binary 'AutoAttack',0,0,0,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(133,_binary 'RoleProficiency',0,1,40,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(134,_binary 'InSight',0,1,40,0,'NONE','','','','','','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(137,_binary '',5,1,1,50,'HP','-(atk+(2*atk*k))','60+80*k','','','5-(4*k)','-(atk+(2*atk*k))','','ATTACK,USE_MELEE_DAMAGE,CRUSH','','NONE','','','','','','','60+80*k',0,0,'MELEE',10,'1',300,0),(138,_binary '\',5,1,1,52,'HP','-(2.4*(200+1.5*lv)+(3*200*k))','60+120*k','','','15','-(2.4*(200+1.5*lv)+(3*200*k))','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH_LONG','','MOV_SPEED','50','5','','','','','60+120*k',0,0,'MELEE',6,'1',400,100),(139,_binary '탈\\',5,1,1,55,'HP','-(2*(200+1.5*lv)+(3*200*k))','60+160*k','','','20','-(2*(200+1.5*lv)+(3*200*k))','','ATTACK,USE_MELEE_DAMAGE,SELFONLY,SPLASH,CRUSH','','NONE','','','','','','','60+160*k',0,0,'MELEE',12,'1',400,250),(140,_binary '(활)',5,1,1,50,'HP','-(atk+(2*atk*k))','60+80*k','','','10','-(atk+(2*atk*k))','','ATTACK,USE_ARROW_DAMAGE,CRUSH','','NONE','','','','','','','60+80*k',0,0,'RANGE',5,'1',2500,0),(151,_binary '\\',0,1,7,0,'NONE','','','','','','','','','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(152,_binary '\\\\\',0,1,7,0,'MAX_HP','maxhp*0.2*k','150+150*k','300','','600','maxhp*0.2*k','','','','NONE','','','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(153,_binary '\\\\僊',0,1,7,0,'MAX_SP','maxsp*0.2*k','150+150*k','300','','600','maxsp*0.2*k','','','','NONE','','','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(154,_binary '\斂',0,1,7,0,'DEF_GRADE','odef*0.1*k','150+150*k','180','','480','odef*0.1*k','','','','NONE','','','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(155,_binary '\화',0,1,7,0,'MOV_SPEED','15*k','150+150*k','180','','480','15*k','','','','ATT_SPEED','15*k','180','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(156,_binary '\\퓟均\',0,1,7,0,'CRITICAL','50*k','150+150*k','180','','480','50*k','','','','NONE','','','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(157,_binary '岺',0,1,7,0,'CASTING_SPEED','50*k','150+150*k','180','','480','50*k','','','','NONE','','','','','','','150+150*k',0,0,'NORMAL',0,'1',0,0),(158,_binary '\\絹',0,1,3,0,'NONE','','','','','','','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(159,_binary '퓜',0,1,5,0,'NONE','','','','','','','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(160,_binary '\화',0,1,5,0,'NONE','3*k','80-12*k','300','','','3*k','','SELFONLY','','NONE','','','','','','','80-12*k',0,0,'NORMAL',0,'1',0,0),(161,_binary '퓜',0,1,2,0,'NONE','','50','','','','','','','','NONE','','','','','','','50',0,0,'NORMAL',0,'1',0,0),(162,_binary '絹',0,1,2,0,'NONE','','20','','','','','','','','NONE','','','','','','','20',0,0,'NORMAL',0,'1',0,0),(170,_binary '\\',7,1,1,0,'HP','-(1.1*atk+(0.3*atk+1.5*str)*k)','40+100*k','','','12','-(1.1*atk+(0.3*atk+1.5*str)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_BLEEDING','','NONE','60*k','5+25*k','','','','','40+100*k',0,0,'MELEE',5,'1',300,200),(171,_binary '\풍',7,1,1,0,'HP','-(2*atk+(atk+dex*3+str*5+con)*k)','40+120*k','','','20','-(2*atk+(atk+dex*3+str*5+con)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN,KNOCKBACK','','NONE','30+70*2*k','2','','','','','40+120*k',0,0,'MELEE',10,'1',1000,200),(172,_binary '\\',7,1,1,0,'HP','-(atk+(1.6*atk+200+dex*7+str*7)*k)','40+100*k','','','12','-(atk+(1.6*atk+200+dex*7+str*7)*k)','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','40+100*k',0,0,'MELEE',5,'1',800,100),(173,_binary '\캬\',7,1,1,0,'HP','-(3*atk+(0.8*atk+str*6+dex*2+con)*k)','40+100*k','','','12','-(3*atk+(0.8*atk+str*6+dex*2+con)*k)','','ATTACK,USE_MELEE_DAMAGE','','DEF_GRADE','-30*k','5','','','','','40+100*k',0,0,'MELEE',10,'1',800,100),(174,_binary '\',7,1,1,0,'ATT_GRADE','7+(4*iq+13)*k','20+240*k','45+60*k','2+23*k','10+10*k','7+(4*iq+13)*k','','SELFONLY,TOGGLE','RED_POSSESSION','PENETRATE','1+((iq*0.4)*k)*0.24','45+60*k','RED_POSSESSION','','','','20+240*k',0,0,'NORMAL',1,'1',0,0),(175,_binary '청\',7,1,1,0,'ATT_SPEED','20*k','80+220*k','200','','300','20*k','','PARTY','BLUE_POSSESSION','DODGE','1+10*k','200','','','','','80+220*k',0,0,'NORMAL',1,'1',1000,0),(176,_binary '\풔絿',1,1,1,0,'HP','-(3*atk+(0.9*atk+number(1,1000)+str*5+dex*3+lv)*k)','200+200*k','','','35+20*k','-(3*atk+(0.9*atk+number(1,1000)+str*5+dex*3+lv)*k)','','ATTACK,USE_MELEE_DAMAGE,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MELEE',8,'1',0,200),(177,_binary '歐표',2,1,1,0,'HP','-(atk+(1.7*atk+number(1,1000)+dex*6+lv*5)*k)','200+200*k','','','35+20*k','-(atk+(1.7*atk+number(1,1000)+dex*6+lv*5)*k)','','ATTACK,USE_MELEE_DAMAGE,SPLASH,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MELEE',10,'1',2000,200),(178,_binary '풍\\\',2,1,1,0,'HP','-(1.9*atk+(2.6*atk+number(1,1000))*k)','200+200*k','','','35+20*k','-(1.9*atk+(2.6*atk+number(1,1000))*k)','','ATTACK,SPLASH,USE_ARROW_DAMAGE,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'RANGE',8,'1',2500,200),(179,_binary '풉\',3,1,1,0,'HP','-(1.9*atk+(2.6*atk+number(1,1000))*k)','200+200*k','','','35+20*k','-(1.9*atk+(2.6*atk+number(1,1000))*k)','','ATTACK,USE_MELEE_DAMAGE,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MELEE',4,'1',0,0),(180,_binary '\歷또\',3,1,1,0,'HP','-(120+6*lv+(5*con+5*dex+30*iq+number(1,1)+9*mwep)*ar*k)','200+200*k','','','35+20*k','-(120+6*lv+(5*con+5*dex+30*iq+number(1,1)+9*mwep)*ar*k)','','ATTACK,COMPUTE_MAGIC_DAMAGE,SPLASH,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MAGIC',5,'1',2000,200),(181,_binary '\\六',4,1,1,0,'HP','-(120+6*lv+(5*con+5*dex+30*iq+number(1,1)+9*mwep)*ar*k)','200+200*k','','','35+20*k','-(120+6*lv+(5*con+5*dex+30*iq+number(1,1)+9*mwep)*ar*k)','','ATTACK,SPLASH,ATTACK_FIRE_CONT,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MAGIC',5,'1',2000,500),(182,_binary '천\',4,1,1,0,'NONE','0.4*k+(18*k)','200+200*k','50+(8*k)','','386+(80*k)','0.4*k+(18*k)','','DISABLE_BY_POINT_UP,PARTY','','NONE','4*k','','','','','','200+200*k',0,0,'NORMAL',1,'1',2000,0),(183,_binary '見풍\',7,1,1,0,'HP','-(1.8*atk+(atk+dex*6+number(1,1000)+str*3+lv)*k)','200+200*k','','','35+20*k','-(1.8*atk+(atk+dex*6+number(1,1000)+str*3+lv)*k)','','ATTACK,USE_MELEE_DAMAGE,DISABLE_BY_POINT_UP','','HIT_PCT','0.4*k+(32*k/2)','20*k','','','','','200+200*k',0,0,'MELEE',8,'1',0,200),(221,_binary '\획\풍\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(222,_binary '絿\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(223,_binary '\\\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(224,_binary '\\캥\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(225,_binary '\\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(226,_binary '화\\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(227,_binary '\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(228,_binary '\\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(229,_binary '\풍\\\\',6,1,1,0,'NONE','24*k','','','','','24*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(236,_binary '\획\풍李화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(237,_binary '絿화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(238,_binary '\\\화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(239,_binary '\\캥媛화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(240,_binary '\\화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(241,_binary '화\캅화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(242,_binary '걷',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(243,_binary '\화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(244,_binary '\풍화',6,1,1,0,'NONE','16*k','','','','','16*k','','','','NONE','','','','','','','',0,0,'NORMAL',1,'1',1000,0),(246,_binary 'hit',0,1,40,0,'NONE','0.4*k+(32*k/2)','','','','','0.4*k+(32*k/2)','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(256,_binary 'CRUSH200킬',0,1,1,0,'HP','-5*k*atk','','','','2','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,300),(257,_binary '球赴350킬',0,1,1,0,'HP','-5*k*atk','','','','5','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,525),(258,_binary 'CRUSH300킬',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,450),(259,_binary '球赴200킬',0,1,1,0,'HP','-5*k*atk','','','','9','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,300),(260,_binary 'CURSH400킬',0,1,1,0,'HP','-5*k*atk','','','','10','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,600),(261,_binary '250킬',0,1,1,0,'HP','-5*k*atk','','','','9','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_POISON','','NONE','80','','','','','','',0,0,'MELEE',0,'1',0,375),(262,_binary 'SLOW300킬',0,1,1,0,'HP','-5*k*atk','','','','12','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','MOV_SPEED','-20','10','','','','','',0,0,'MELEE',0,'1',0,450),(263,_binary 'SLOW4000킬',0,1,1,0,'HP','-5*k*atk','','','','12','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','MOV_SPEED','-70','3','SLOW','','','','',0,0,'MELEE',0,'1',2000,6000),(264,_binary 'THUNDER킬',0,1,1,0,'HP','-maxhp*k','','','','12','-maxhp*k','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,500),(265,_binary 'HEAL4000킬',0,1,1,0,'HP','0.1*maxhp*k','','','','5','0.1*maxhp*k','','PARTY','','NONE','','','','','','','',0,0,'NORMAL',1,'1',3000,0),(266,_binary 'ATTACK_SLOW',0,1,1,0,'NONE','','','','','','','','SELFONLY,SPLASH','','NONE','','','','','','','',0,0,'NORMAL',1,'1',0,3000),(267,_binary '球\0킬',0,1,1,0,'HP','-5*k*atk','','','','10','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,0),(268,_binary 'CRUSH0킬',0,1,1,0,'HP','-5*k*atk','','','','10','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,CRUSH','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,0),(269,_binary 'STUN200',0,1,1,0,'HP','-5*k*atk','','','','10','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN','','NONE','1000','3','','','','','',0,0,'MELEE',0,'1',0,300),(270,_binary 'normal_range_attack_confustion',0,1,1,0,'HP','-5*k*atk','','','','5','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','80*k','','','','','','',0,0,'MELEE',0,'1',0,525),(271,_binary 'knockback_hp_absorb',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,HP_ABSORB,CRUSH','','NONE','10','','','','','','',0,0,'MELEE',0,'1',0,350),(272,_binary 'knockback_bleeding',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH,ATTACK_BLEEDING','','NONE','100','','','','','','',0,0,'MELEE',0,'1',0,350),(273,_binary 'wide_area_damage_stun',0,1,1,0,'HP','-maxhp*k','','','','12','-maxhp*k','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN,CRUSH','','NONE','1000','4','','','','','',0,0,'MELEE',0,'1',0,500),(274,_binary 'wide_area_damage_sungma_str',0,1,1,0,'SUNGMA_STR','-40*k','','10','','12','-40*k','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','HP','-maxhp*k','0','','','','','',0,0,'MELEE',0,'1',1000,300),(275,_binary 'splash400_bleeding',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_BLEEDING','','NONE','30','','','','','','',0,0,'MELEE',0,'1',0,400),(276,_binary 'stun300',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN','','NONE','200','3','','','','','',0,0,'MELEE',0,'1',0,300),(277,_binary 'splash400_poison',0,1,1,0,'HP','-5*k*atk','','','','5','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_POISON','','NONE','10','','','','','','',0,0,'MELEE',0,'1',0,400),(278,_binary 'stun400',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN','','NONE','200','3','','','','','',0,0,'MELEE',0,'1',0,400),(279,_binary 'maze_keingnoll_boss_skill3',0,1,1,0,'HP','-5*k*atk','','','','20','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,HP_ABSORB','','NONE','50','','','','','','',0,0,'NORMAL',0,'1',0,400),(280,_binary 'posion_damage_sungma_move',0,1,1,1,'HP','-5*k*atk','','','','9','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_POISON','','NONE','80','','','','','','',0,0,'MELEE',0,'1',0,375),(281,_binary 'crush_damage_sungma_str',0,1,1,1,'HP','-5*k*atk','','','','17','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','SUNGMA_STR','-20','10','','','','','',0,0,'MELEE',0,'1',0,375),(282,_binary 'shackle_damage',0,1,1,1,'HP','-5*k*atk','','','','25','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','MOV_SPEED','0','3','','','','','',0,0,'MELEE',0,'1',0,450),(283,_binary 'white_dragon_skill0',0,1,1,0,'HP','-5*k*atk','','','','24','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','0','0','','','','','',0,0,'MELEE',0,'1',0,300),(284,_binary 'white_dragon_skill2',0,1,1,0,'HP','-5*k*atk','','','','45','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','50','','','','','','',0,0,'MELEE',0,'1',0,900),(285,_binary '湄\(抉\)',8,1,1,0,'MOUNT_UPGRADE_NIMBLE','(4+(horselv*skilllv/100))*(skilllv/3)','','3+(skilllv*(horselv*0.4))/20','','180','(4+(horselv*skilllv/100))*(skilllv/3)','','SELFONLY','','MOV_SPEED','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(286,_binary '\\\치',8,1,1,0,'MALL_EXPBONUS','((horselv*skilllv/100)+1.5)+(skilllv/8)','','','','','((horselv*skilllv/100)+1.5)+(skilllv/8)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(287,_binary '풍(\)',8,1,1,0,'MOUNT_UPGRADE_SPEED','(5+(horselv*skilllv/600))*(skilllv/5)','','3+(skilllv*(horselv*0.4))/20','','180','(5+(horselv*skilllv/600))*(skilllv/5)','','SELFONLY','','ATT_SPEED','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(288,_binary '\',8,1,1,0,'NONE','(horselv*(skilllv*number(5,10)))/40*skilllv','','1+(skilllv*(horselv*0.3))/20','','300','(horselv*(skilllv*number(5,10)))/40*skilllv','','','','NONE','(horselv*(skilllv*10))/40*skilllv','','','','','','',0,0,'NORMAL',0,'1',1000,0),(289,_binary '',8,1,1,0,'NONE','','','(horselv*(skilllv*0.3))/60','','600','','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(290,_binary '薑\譴森',8,1,1,0,'MOUNT_UPGRADE_NO_KNOCKBACK','','','3+(skilllv*(horselv*0.5))/20','','180','','','','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(291,_binary '蹈\\寬',8,1,1,0,'ATTBONUS_HUMAN','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(292,_binary '蹈\鍍',8,1,1,0,'ATTBONUS_ANIMAL','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(293,_binary '蹈\篤\\',8,1,1,0,'ATTBONUS_ORC','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(294,_binary '蹈\瀆閨',8,1,1,0,'ATTBONUS_MILGYO','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(295,_binary '蹈\禿醍Ⅵ\',8,1,1,0,'ATTBONUS_UNDEAD','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(296,_binary '蹈\禿퓔',8,1,1,0,'ATTBONUS_DEVIL','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(297,_binary '蹈\督\\\',8,1,1,0,'ATTBONUS_CZ','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(298,_binary '蹈\犢潁',8,1,1,0,'ATTBONUS_DESERT','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(299,_binary '蹈\蹈\\\',8,1,1,0,'ATTBONUS_INSECT','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(300,_binary '蹈\毒\\\\\',8,1,1,0,'ATTBONUS_MONSTER','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(301,_binary '탑\\罐\트효\\',8,1,1,0,'NONE','k*(skilllv/(140-horselv))','','','','','k*(skilllv/(140-horselv))','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(302,_binary '\\\\(\)',8,1,1,0,'ATTBONUS_WARRIOR','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(303,_binary '\\\\(微)',8,1,1,0,'ATTBONUS_ASSASSIN','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(304,_binary '\\\\(\\)',8,1,1,0,'ATTBONUS_SURA','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(305,_binary '\\\\(\)',8,1,1,0,'ATTBONUS_SHAMAN','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(306,_binary '\\\\(\\)',8,1,1,0,'ATTBONUS_WOLF','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(307,_binary '\\',8,1,1,0,'MOUNT_UPGRADE_SUNGMA_STR','3+(horselv*skilllv)*(skilllv/500)','','3+(skilllv*(horselv*0.4))/20','','180','3+(horselv*skilllv)*(skilllv/500)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(308,_binary '퓰\체',8,1,1,0,'MOUNT_UPGRADE_SUNGMA_HP','3+(horselv*skilllv)*(skilllv/500)','','3+(skilllv*(horselv*0.4))/20','','180','3+(horselv*skilllv)*(skilllv/500)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(309,_binary '\\瀏\',8,1,1,0,'MOUNT_UPGRADE_SUNGMA_MOVE','3+(horselv*skilllv)*(skilllv/500)','','3+(skilllv*(horselv*0.4))/20','','180','3+(horselv*skilllv)*(skilllv/500)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(310,_binary '\\',8,1,1,0,'MOUNT_UPGRADE_SUNGMA_IMMUNE','3+(horselv*skilllv)*(skilllv/500)','','3+(skilllv*(horselv*0.4))/20','','180','3+(horselv*skilllv)*(skilllv/500)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(311,_binary '\\',8,1,1,0,'HIT_PCT','1+(skilllv*horselv/100)','','','','','1+(skilllv*horselv/100)','','SELFONLY','','NONE','','','','','','','',0,0,'NORMAL',0,'1',1000,0),(312,_binary '\軻\\(킬1)',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,HP_ABSORB','','NONE','20','','','','','','',0,0,'MELEE',1,'1',0,400),(313,_binary '\軻\\(킬2)',0,1,1,0,'HP','-15*k*atk','','','','23','-15*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,1000),(314,_binary '\軻\\(킬2)',0,1,1,0,'HP','-5*k*atk','','','','18','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH,ATTACK_BLEEDING','','NONE','30','','','','','','',0,0,'MELEE',0,'1',0,400),(315,_binary '\軻\\(킬1)',0,1,1,0,'HP','-5*k*atk','','','','30','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,HP_ABSORB','','NONE','10','','','','','','',0,0,'MELEE',1,'1',0,400),(316,_binary '\軻\\(킬2)',0,1,1,0,'HP','-5*k*atk','','','','47','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,1000),(317,_binary '\\軻\\(킬1)',0,1,1,0,'HP','-5*k*atk','','','','7','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN','','NONE','1000','3','','','','','',0,0,'MELEE',1,'1',0,400),(318,_binary '\\軻\\(킬2)',0,1,1,0,'HP','-5*k*atk','','','','15','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,400),(319,_binary '\(킬1)',0,1,1,0,'HP','-5*k*atk','','','','6','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',1,'1',0,300),(320,_binary '\(킬2)',0,1,1,0,'HP','-5*k*atk','','','','31','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,300),(321,_binary '\(킬3)',0,1,1,0,'HP','-5*k*atk','','','','14','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_BLEEDING','','NONE','100','','','','','','',0,0,'MELEE',0,'1',0,1000),(322,_binary 'change_equipment_page',0,0,0,0,'NONE','','','','','3','','','DISABLE_BY_POINT_UP','','NONE','','','','','','','',0,0,'NORMAL',0,'1',0,0),(329,_binary '\\(킬1)',0,1,1,0,'HP','-5*k*atk','','','','12','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,1500),(330,_binary '\\(킬2)',0,1,1,0,'HP','-5*k*atk','','','','33','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH','','NONE','100','','','','','','',0,0,'MELEE',0,'1',0,1200),(331,_binary '\\(킬3)',0,1,1,0,'HP','-5*k*atk','','','','20','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,1500),(332,_binary '티\\(킬1)',0,1,1,0,'HP','-5*k*atk','','','','12','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,CRUSH,ATTACK_POISON','','NONE','10','31','','','','','',0,0,'MELEE',0,'1',0,500),(333,_binary '티\\(킬2)',0,1,1,0,'HP','-5*k*atk','','','','17','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN,CRUSH','','NONE','20','3','','','','','',0,0,'MELEE',0,'1',0,300),(334,_binary '티\\(킬3)',0,1,1,0,'HP','-5*k*atk','','','','26','-5*k*atk','','ATTACK,USE_MELEE_DAMAGE,SPLASH,ATTACK_STUN','','NONE','','','','','','','',0,0,'MELEE',0,'1',0,600);
 /*!40000 ALTER TABLE `skill_proto` ENABLE KEYS */;
 UNLOCK TABLES;
 
