--- a/server/metin2/Source/Server/game/src/input_main.cpp
+++ b/server/metin2/Source/Server/game/src/input_main.cpp
@@ -2003,6 +2003,10 @@
 	if (NULL == ch)
 		return;
 
+	// [Security] Spectator/observer characters must never be able to attack (packet injection / ghost attack)
+	if (ch->IsObserverMode() || ch->IsDead())
+		return;
+
 	struct type_identifier
 	{
 		BYTE header;
@@ -2421,6 +2425,12 @@
 	if (!ch->CanHandleItem())
 		return;
 
+	// [Security] Mutual exclusion: forbid safebox actions while other trade windows are open
+	if (!ch->IsOpenSafebox())
+		return;
+	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
+		return;
+
 	CSafebox* pkSafebox = ch->GetSafebox();
 	LPITEM pkItem = ch->GetItem(p->ItemPos);
 
@@ -2513,6 +2523,12 @@
 	if (!ch->CanHandleItem())
 		return;
 
+	// [Security] Mutual exclusion: safebox operations must not be possible alongside exchange/shop/cube (packet overlap / dup prevention)
+	if (!bMall && !ch->IsOpenSafebox())
+		return;
+	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
+		return;
+
 	CSafebox* pkSafebox;
 
 	if (bMall)
@@ -2684,6 +2700,12 @@
 	if (!ch->CanHandleItem())
 		return;
 
+	// [Security] Mutual exclusion: block safebox operations while other trade windows are open
+	if (!ch->IsOpenSafebox())
+		return;
+	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
+		return;
+
 	if (!ch->GetSafebox())
 		return;
 

--- a/server/metin2/Source/Server/game/src/char.h
+++ b/server/metin2/Source/Server/game/src/char.h
@@ -2589,6 +2589,7 @@
 	LPITEM* GetCubeItem() { return m_pointsInstant.pCubeItems; }
 #endif
 	bool IsCubeOpen() const { return (m_pointsInstant.pCubeNpc ? true : false); }
+	LPCHARACTER GetCubeNpc() const { return m_pointsInstant.pCubeNpc; }
 	void SetCubeNpc(LPCHARACTER npc) { m_pointsInstant.pCubeNpc = npc; }
 	bool CanDoCube() const;
 

--- a/server/metin2/Source/Server/game/src/cube.cpp
+++ b/server/metin2/Source/Server/game/src/cube.cpp
@@ -281,10 +281,25 @@
 	if (pChar->IsCubeOpen() == false)
 		return;
 
-	const LPCHARACTER pNPC = pChar->GetQuestNPC();
+	const LPCHARACTER pNPC = pChar->GetCubeNpc();
 	if (pNPC == nullptr)
 		return;
 
+	// [Security] Re-validate proximity to the cube NPC on every craft (prevents remote crafting via packet injection)
+	if (pNPC->GetMapIndex() != pChar->GetMapIndex())
+	{
+		CCubeManager::Instance().CloseCube(pChar);
+		return;
+	}
+
+	const int kMaxCubeDistance = 500;
+	if (DISTANCE_APPROX(pChar->GetX() - pNPC->GetX(), pChar->GetY() - pNPC->GetY()) > kMaxCubeDistance)
+	{
+		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You are too far away from the crafting NPC."));
+		CCubeManager::Instance().CloseCube(pChar);
+		return;
+	}
+
 	try
 	{
 		const SCubeData& pkCube = GetCubeData(pNPC->GetRaceNum(), iCubeIndex);

--- a/server/metin2/Source/Server/game/src/war_map.cpp
+++ b/server/metin2/Source/Server/game/src/war_map.cpp
@@ -574,6 +574,81 @@
 	sys_log(0, "WarMap: Timeout %u %u winner %u loser %u reward %d map %d",
 		m_TeamData[0].dwID, m_TeamData[1].dwID, dwWinner, dwLoser, iRewardGold, m_kMapInfo.lMapIndex);
 
+	// [Security] Guild ladder anti-farming: minimum duration, level gap check, and per-pair cooldown
+	if (dwWinner)
+	{
+		const DWORD kMinDurationMs = 60000 * 3; // 3 minutes
+		const int kMaxAvgLevelDiff = 30;
+		const DWORD kPairCooldownSec = 60 * 60 * 24; // 24 hours
+
+		// Duration gate (DB treats draw as no ladder adjustment)
+		if (get_dword_time() - m_dwStartTime < kMinDurationMs)
+		{
+			Notice(LC_STRING("Guild war ended too quickly. No ladder points awarded."));
+			dwWinner = 0;
+			dwLoser = 0;
+			iRewardGold = 0;
+		}
+		else
+		{
+			// Average level gate
+			long long sum[2] = {0, 0};
+			int cnt[2] = {0, 0};
+			for (auto it = m_set_pkChr.begin(); it != m_set_pkChr.end(); ++it)
+			{
+				LPCHARACTER pk = *it;
+				if (!pk || !pk->IsPC())
+					continue;
+				CGuild* g = pk->GetGuild();
+				if (!g)
+					continue;
+				DWORD gid = g->GetID();
+				int idx = (gid == m_TeamData[0].dwID) ? 0 : ((gid == m_TeamData[1].dwID) ? 1 : -1);
+				if (idx < 0)
+					continue;
+				sum[idx] += pk->GetLevel();
+				cnt[idx] += 1;
+			}
+
+			if (cnt[0] > 0 && cnt[1] > 0)
+			{
+				int avg0 = int(sum[0] / cnt[0]);
+				int avg1 = int(sum[1] / cnt[1]);
+				int diff = avg0 - avg1;
+				if (diff < 0) diff = -diff;
+				if (diff > kMaxAvgLevelDiff)
+				{
+					Notice(LC_STRING("Guild war level gap too large. No ladder points awarded."));
+					dwWinner = 0;
+					dwLoser = 0;
+					iRewardGold = 0;
+				}
+			}
+
+			// Per guild-pair cooldown gate
+			if (dwWinner)
+			{
+				static std::map<std::pair<DWORD, DWORD>, time_t> s_lastLadderReward;
+				DWORD a = MIN(m_TeamData[0].dwID, m_TeamData[1].dwID);
+				DWORD b = MAX(m_TeamData[0].dwID, m_TeamData[1].dwID);
+				std::pair<DWORD, DWORD> key = std::make_pair(a, b);
+				const time_t now = get_global_time();
+				auto f = s_lastLadderReward.find(key);
+				if (f != s_lastLadderReward.end() && now - f->second < (time_t)kPairCooldownSec)
+				{
+					Notice(LC_STRING("Guild war ladder points for this opponent are on cooldown."));
+					dwWinner = 0;
+					dwLoser = 0;
+					iRewardGold = 0;
+				}
+				else
+				{
+					s_lastLadderReward[key] = now;
+				}
+			}
+		}
+	}
+
 	if (dwWinner)
 		CGuildManager::instance().RequestWarOver(dwWinner, dwLoser, dwWinner, iRewardGold);
 	else

