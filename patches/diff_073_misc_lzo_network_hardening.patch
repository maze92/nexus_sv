diff --git a/game/src/lzo_manager.h b/game/src/lzo_manager.h
--- a/game/src/lzo_manager.h
+++ b/game/src/lzo_manager.h
@@ -7,6 +7,11 @@
 class LZOManager : public singleton<LZOManager>
 {
 public:
+	// Hard cap to prevent pathological decompression (DoS / zip-bomb style inputs).
+	// Note: In this codebase, LZO is primarily used for files (sectree attrs) and guild mark blocks,
+	// not for general client packet compression. Still, enforcing a cap is cheap hardening.
+	static const size_t MAX_LZO_DECOMPRESS_SIZE = 32 * 1024 * 1024; // 32MB
+
 	LZOManager();
 	virtual ~LZOManager();

diff --git a/game/src/lzo_manager.cpp b/game/src/lzo_manager.cpp
--- a/game/src/lzo_manager.cpp
+++ b/game/src/lzo_manager.cpp
@@ -26,6 +26,12 @@

 bool LZOManager::Decompress(const BYTE* src, size_t srcsize, BYTE* dest, lzo_uint* puiDestSize)
 {
+	if (!src || !dest || !puiDestSize)
+		return false;
+
+	if (*puiDestSize > (lzo_uint)MAX_LZO_DECOMPRESS_SIZE)
+		return false;
+
 	int ret = lzo1x_decompress_safe(src, srcsize, dest, puiDestSize, GetWorkMemory());

 	if (ret != LZO_E_OK)
 		return false;

 	return true;
 }
diff --git a/game/src/MarkImage.cpp b/game/src/MarkImage.cpp
--- a/game/src/MarkImage.cpp
+++ b/game/src/MarkImage.cpp
@@ -1,3 +1,4 @@
+#include <algorithm>
 #include "stdafx.h"
 #include "MarkImage.h"

@@ -214,6 +215,14 @@ SaveBlockFromCompressedData(DWORD posBlock, const BYTE* pbComp, DWORD dwCompSize)
 	if (posBlock >= BLOCK_TOTAL_COUNT)
 		return false;

+	// Defensive cap: guild mark blocks are very small; oversized compressed data is suspicious
+	// and can be used for CPU exhaustion attempts.
+	// (Decompressed size is already enforced by sizeBuf == sizeof(apxBuf).)
+	static const DWORD MAX_MARK_BLOCK_COMPRESSED = 8 * 1024; // 8KB
+	if (!pbComp || dwCompSize == 0 || dwCompSize > MAX_MARK_BLOCK_COMPRESSED)
+		return false;
+
 	Pixel apxBuf[SGuildMarkBlock::SIZE];
 	lzo_uint sizeBuf = sizeof(apxBuf);
