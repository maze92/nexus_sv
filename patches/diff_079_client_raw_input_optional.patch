--- Nexus OS/src-client/Client/EterLib/Input.h
+++ Nexus OS/src-client/Client/EterLib/Input.h
@@ -40,4 +40,14 @@
 	static bool ms_bPressedKey[256];
 	static char ms_diks[256];
 
+
+#if defined(ENABLE_RAW_INPUT)
+public:
+	static void SetUseRawInput(bool enable);
+	static bool IsUsingRawInput();
+	static bool RegisterRawInputKeyboard(HWND hWnd);
+	static void ProcessRawInput(LPARAM lParam);
+private:
+	static bool ms_bUseRawInput;
+#endif
 };
--- Nexus OS/src-client/Client/EterLib/Input.cpp
+++ Nexus OS/src-client/Client/EterLib/Input.cpp
@@ -1,11 +1,16 @@
 #include "StdAfx.h"
 #include "Input.h"
+#include <vector>
 
 LPDIRECTINPUT8 CInputDevice::ms_lpDI = NULL;
 LPDIRECTINPUTDEVICE8 CInputKeyboard::ms_lpKeyboard = NULL;
 
 bool CInputKeyboard::ms_bPressedKey[256];
 char CInputKeyboard::ms_diks[256];
+
+#if defined(ENABLE_RAW_INPUT)
+bool CInputKeyboard::ms_bUseRawInput = false;
+#endif
 
 CInputDevice::CInputDevice()
 {
@@ -88,6 +93,11 @@
 
 void CInputKeyboard::UpdateKeyboard()
 {
+#if defined(ENABLE_RAW_INPUT)
+	if (ms_bUseRawInput)
+		return;
+#endif
+
 	if (!ms_lpKeyboard)
 		return;
 
@@ -132,3 +142,83 @@
 {
 	return ms_bPressedKey[iIndex];
 }
+
+
+#if defined(ENABLE_RAW_INPUT)
+void CInputKeyboard::SetUseRawInput(bool enable)
+{
+	ms_bUseRawInput = enable;
+}
+
+bool CInputKeyboard::IsUsingRawInput()
+{
+	return ms_bUseRawInput;
+}
+
+bool CInputKeyboard::RegisterRawInputKeyboard(HWND hWnd)
+{
+	RAWINPUTDEVICE rid;
+	rid.usUsagePage = 0x01; // generic desktop controls
+	rid.usUsage = 0x06;     // keyboard
+	rid.dwFlags = RIDEV_INPUTSINK;
+	rid.hwndTarget = hWnd;
+
+	return RegisterRawInputDevices(&rid, 1, sizeof(rid)) == TRUE;
+}
+
+static int __RawInputMakeDik(const RAWKEYBOARD& rk)
+{
+	// DirectInput DIK codes are largely Set 1 make codes.
+	UINT make = rk.MakeCode & 0xFF;
+	UINT flags = rk.Flags;
+
+	// Filter out fake shift events generated with E0 for PrintScreen
+	if ((flags & RI_KEY_E0) && (make == 0x2A || make == 0x36))
+		return -1;
+
+	// Pause/Break (E1) special-case
+	if ((flags & RI_KEY_E1) && make == 0x1D)
+		return 0xC5; // DIK_PAUSE
+
+	int dik = (int)make;
+	if (flags & RI_KEY_E0)
+		dik |= 0x80;
+
+	return dik;
+}
+
+void CInputKeyboard::ProcessRawInput(LPARAM lParam)
+{
+	if (!ms_bUseRawInput)
+		return;
+
+	UINT dwSize = 0;
+	if (GetRawInputData((HRAWINPUT)lParam, RID_INPUT, NULL, &dwSize, sizeof(RAWINPUTHEADER)) != 0)
+		return;
+
+	std::vector<BYTE> buffer(dwSize);
+	if (GetRawInputData((HRAWINPUT)lParam, RID_INPUT, buffer.data(), &dwSize, sizeof(RAWINPUTHEADER)) != dwSize)
+		return;
+
+	const RAWINPUT* raw = (const RAWINPUT*)buffer.data();
+	if (raw->header.dwType != RIM_TYPEKEYBOARD)
+		return;
+
+	const RAWKEYBOARD& rk = raw->data.keyboard;
+	int dik = __RawInputMakeDik(rk);
+	if (dik < 0 || dik >= 256)
+		return;
+
+	const bool isBreak = (rk.Flags & RI_KEY_BREAK) != 0;
+	if (isBreak)
+	{
+		if (IsPressed(dik))
+			KeyUp(dik);
+	}
+	else
+	{
+		if (!IsPressed(dik))
+			KeyDown(dik);
+	}
+}
+#endif
--- Nexus OS/src-client/Client/EterLib/MSWindow.cpp
+++ Nexus OS/src-client/Client/EterLib/MSWindow.cpp
@@ -1,5 +1,6 @@
 #include "StdAfx.h"
 #include "MsWindow.h"
+#include "Input.h"
 
 #include <windowsx.h>
 
@@ -80,6 +81,12 @@
 		return false;
 
 	SetWindowLongPtr(m_hWnd, GWLP_USERDATA, (DWORD)this);
+
+#if defined(ENABLE_RAW_INPUT)
+	CInputKeyboard::RegisterRawInputKeyboard(m_hWnd);
+	CInputKeyboard::SetUseRawInput(true);
+#endif
+
 	//DestroyWindow(ImmGetDefaultIMEWnd(m_hWnd));
 
 	return true;
--- Nexus OS/src-client/Client/UserInterface/PythonApplicationProcedure.cpp
+++ Nexus OS/src-client/Client/UserInterface/PythonApplicationProcedure.cpp
@@ -2,6 +2,7 @@
 
 #include "PythonApplication.h"
 #include "../EterLib/Camera.h"
+#include "../EterLib/Input.h"
 #if defined(ENABLE_BADGE_NOTIFICATION_MANAGER)
 	#include "BadgeNotificationManager.h"
 #endif
@@ -147,7 +148,14 @@
 			return CPythonIME::Instance().WMChar(hWnd, uiMsg, wParam, lParam);
 		}
 
-		case WM_KEYDOWN:
+		
+#if defined(ENABLE_RAW_INPUT)
+		case WM_INPUT:
+			CInputKeyboard::ProcessRawInput(lParam);
+			return 0;
+#endif
+
+case WM_KEYDOWN:
 		{
 #if defined(__IMGUI__)
 			if (ImGui::GetIO().WantCaptureKeyboard)

