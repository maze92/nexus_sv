diff --git a/Client/EterLib/GrpTextInstance.cpp b/Client/EterLib/GrpTextInstance.cpp
index 73d50d6..b34bac9 100644
--- a/Client/EterLib/GrpTextInstance.cpp
+++ b/Client/EterLib/GrpTextInstance.cpp
@@ -1,6 +1,7 @@
 #include "StdAfx.h"
 
 #include "GrpTextInstance.h"
+#include "GrpBase.h"
 #include "StateManager.h"
 #include "IME.h"
 #include "TextTag.h"
@@ -23,6 +24,138 @@ static int gs_my = 0;
 
 static std::wstring gs_hyperlinkText;
 
+namespace
+{
+	struct TAggressiveTextBatch
+	{
+		bool active = false;
+		CGraphicFontTexture* font = nullptr;
+		int texIndex = -1;
+
+		DWORD fogEnable = FALSE;
+		DWORD lighting = FALSE;
+
+		int vtxCount = 0;
+		SPDTVertexRaw vtx[CGraphicBase::PDT_TEXTLINE_VERTEX_NUM];
+
+		inline void Reset()
+		{
+			font = nullptr;
+			texIndex = -1;
+			vtxCount = 0;
+		}
+
+		inline void SetupStates()
+		{
+			STATEMANAGER.SaveRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
+			STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
+
+			fogEnable = STATEMANAGER.GetRenderState(D3DRS_FOGENABLE);
+			lighting = STATEMANAGER.GetRenderState(D3DRS_LIGHTING);
+
+			STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);
+			STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);
+
+			STATEMANAGER.SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1);
+			STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
+			STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
+			STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
+			STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
+			STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
+			STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
+		}
+
+		inline void RestoreStates()
+		{
+			STATEMANAGER.SetTexture(0, nullptr);
+			STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, fogEnable);
+			STATEMANAGER.SetRenderState(D3DRS_LIGHTING, lighting);
+
+			STATEMANAGER.RestoreRenderState(D3DRS_SRCBLEND);
+			STATEMANAGER.RestoreRenderState(D3DRS_DESTBLEND);
+		}
+
+		inline void Flush()
+		{
+			if (vtxCount <= 0 || !font || texIndex < 0)
+			{
+				vtxCount = 0;
+				return;
+			}
+
+			font->SelectTexture(texIndex);
+			STATEMANAGER.SetTexture(0, font->GetD3DTexture());
+
+			if (CGraphicBase::SetPDTTextLineStream(vtx, vtxCount))
+				STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLELIST, 0, vtxCount / 3);
+
+			vtxCount = 0;
+		}
+
+		inline void EnsureBucket(CGraphicFontTexture* newFont, int newTexIndex, int neededVertices)
+		{
+			if (!newFont)
+				return;
+
+			if (newTexIndex < 0)
+				newTexIndex = 0;
+
+			// Texture page switch: flush first
+			if (font && (font != newFont || texIndex != newTexIndex))
+				Flush();
+
+			font = newFont;
+			texIndex = newTexIndex;
+
+			// Capacity: flush before overflow
+			if (vtxCount + neededVertices >= (int)CGraphicBase::PDT_TEXTLINE_VERTEX_NUM)
+				Flush();
+		}
+
+		inline void PushTri(const SPDTVertexRaw& a, const SPDTVertexRaw& b, const SPDTVertexRaw& c)
+		{
+			if (vtxCount + 3 >= (int)CGraphicBase::PDT_TEXTLINE_VERTEX_NUM)
+				Flush();
+
+			vtx[vtxCount++] = a;
+			vtx[vtxCount++] = b;
+			vtx[vtxCount++] = c;
+		}
+
+		inline void PushQuad(float sx, float sy, float ex, float ey, float u0, float v0, float u1, float v1, DWORD color)
+		{
+			SPDTVertexRaw vA{ sx, sy, 0.0f, color, u0, v0 };
+			SPDTVertexRaw vB{ ex, sy, 0.0f, color, u1, v0 };
+			SPDTVertexRaw vC{ sx, ey, 0.0f, color, u0, v1 };
+			SPDTVertexRaw vD{ ex, ey, 0.0f, color, u1, v1 };
+
+			PushTri(vA, vB, vC);
+			PushTri(vB, vD, vC);
+		}
+
+		inline void SubmitGlyph(CGraphicFontTexture* newFont, int newTexIndex,
+			float sx, float sy, float ex, float ey,
+			float u0, float v0, float u1, float v1,
+			DWORD textColor, bool outline, DWORD outlineColor)
+		{
+			const int quadVerts = outline ? (6 * 5) : 6;
+			EnsureBucket(newFont, newTexIndex, quadVerts);
+
+			if (outline)
+			{
+				PushQuad(sx - 1.0f, sy, ex - 1.0f, ey, u0, v0, u1, v1, outlineColor);
+				PushQuad(sx + 1.0f, sy, ex + 1.0f, ey, u0, v0, u1, v1, outlineColor);
+				PushQuad(sx, sy - 1.0f, ex, ey - 1.0f, u0, v0, u1, v1, outlineColor);
+				PushQuad(sx, sy + 1.0f, ex, ey + 1.0f, u0, v0, u1, v1, outlineColor);
+			}
+
+			PushQuad(sx, sy, ex, ey, u0, v0, u1, v1, textColor);
+		}
+	};
+
+	static TAggressiveTextBatch g_TextBatch;
+}
+
 void CGraphicTextInstance::Hyperlink_UpdateMousePos(int x, int y)
 {
 	gs_mx = x;
@@ -40,6 +173,32 @@ int CGraphicTextInstance::Hyperlink_GetText(char* buf, int len)
 	return Ymir_WideCharToMultiByte(codePage, 0, gs_hyperlinkText.c_str(), gs_hyperlinkText.length(), buf, len, NULL, NULL);
 }
 
+bool CGraphicTextInstance::IsAggressiveBatching()
+{
+	return g_TextBatch.active;
+}
+
+void CGraphicTextInstance::BeginAggressiveBatch()
+{
+	if (g_TextBatch.active)
+		return;
+
+	g_TextBatch.active = true;
+	g_TextBatch.Reset();
+	g_TextBatch.SetupStates();
+}
+
+void CGraphicTextInstance::EndAggressiveBatch()
+{
+	if (!g_TextBatch.active)
+		return;
+
+	g_TextBatch.Flush();
+	g_TextBatch.RestoreStates();
+	g_TextBatch.Reset();
+	g_TextBatch.active = false;
+}
+
 int CGraphicTextInstance::__DrawCharacter(CGraphicFontTexture* pFontTexture, WORD codePage, wchar_t text, DWORD dwColor)
 {
 	CGraphicFontTexture::TCharacterInfomation* pInsCharInfo = pFontTexture->GetCharacterInfomation(codePage, text);
@@ -147,6 +306,85 @@ void CGraphicTextInstance::Update()
 	if (!pFontTexture)
 		return;
 
+	// Tier 24: aggressive batching path (TextTail-heavy scenes).
+	// Only used when a higher-level caller wraps rendering in Begin/EndAggressiveBatch().
+	if (g_TextBatch.active && !pClipRect && !m_isCursor)
+	{
+		float fStanX = m_v3Position.x;
+		float fStanY = m_v3Position.y + 1.0f;
+
+		UINT defCodePage = GetDefaultCodePage();
+
+		if (defCodePage == CP_ARABIC)
+		{
+			switch (m_hAlign)
+			{
+				case HORIZONTAL_ALIGN_LEFT:   fStanX -= m_textWidth; break;
+				case HORIZONTAL_ALIGN_CENTER: fStanX -= float(m_textWidth / 2); break;
+			}
+		}
+		else
+		{
+			switch (m_hAlign)
+			{
+				case HORIZONTAL_ALIGN_RIGHT:  fStanX -= m_textWidth; break;
+				case HORIZONTAL_ALIGN_CENTER: fStanX -= float(m_textWidth / 2); break;
+			}
+		}
+
+		switch (m_vAlign)
+		{
+			case VERTICAL_ALIGN_BOTTOM: fStanY -= m_textHeight; break;
+			case VERTICAL_ALIGN_CENTER: fStanY -= float(m_textHeight) / 2.0f; break;
+		}
+
+		float fCurX = fStanX;
+		float fCurY = fStanY;
+		float fLineMaxH = 0.0f;
+
+		for (int i = 0; i < (int)m_pCharInfoVector.size(); ++i)
+		{
+			CGraphicFontTexture::TCharacterInfomation* pCurCharInfo = m_pCharInfoVector[i];
+			if (!pCurCharInfo)
+				continue;
+
+			const float w = float(pCurCharInfo->width);
+			const float h = float(pCurCharInfo->height);
+			const float adv = float(pCurCharInfo->advance);
+
+			if (m_isMultiLine && (fCurX + w) - m_v3Position.x > m_fLimitWidth)
+			{
+				fCurX = fStanX;
+				fCurY += fLineMaxH;
+				fLineMaxH = 0.0f;
+			}
+
+			const float sx = fCurX;
+			const float sy = fCurY;
+			const float ex = sx + w;
+			const float ey = sy + h;
+
+			const DWORD color = (m_dwColorInfoVector.size() > (size_t)i) ? m_dwColorInfoVector[i] : m_dwTextColor;
+
+			g_TextBatch.SubmitGlyph(
+				pFontTexture,
+				pCurCharInfo->index,
+				sx, sy, ex, ey,
+				pCurCharInfo->left, pCurCharInfo->top,
+				pCurCharInfo->right, pCurCharInfo->bottom,
+				color,
+				m_isOutline,
+				m_dwOutlineColor
+			);
+
+			fCurX += adv;
+			if (h > fLineMaxH)
+				fLineMaxH = h;
+		}
+
+		return;
+	}
+
 	UINT defCodePage = GetDefaultCodePage();
 
 	UINT dataCodePage = defCodePage; // 아랍 및 베트남 내부 데이터를 UTF8 을 사용하려 했으나 실패
diff --git a/Client/EterLib/GrpTextInstance.h b/Client/EterLib/GrpTextInstance.h
index ed95669..fcbfee5 100644
--- a/Client/EterLib/GrpTextInstance.h
+++ b/Client/EterLib/GrpTextInstance.h
@@ -14,6 +14,12 @@ class CGraphicTextInstance
 public:
 	typedef CDynamicPool<CGraphicTextInstance> TPool;
 
+public:
+	// Tier 24: aggressive text batching across many instances (TextTail heavy scenes)
+	static void BeginAggressiveBatch();
+	static void EndAggressiveBatch();
+	static bool IsAggressiveBatching();
+
 public:
 	enum EHorizontalAlign
 	{
diff --git a/Client/UserInterface/PythonTextTail.cpp b/Client/UserInterface/PythonTextTail.cpp
index bd6bf1e..34d43fe 100644
--- a/Client/UserInterface/PythonTextTail.cpp
+++ b/Client/UserInterface/PythonTextTail.cpp
@@ -6,6 +6,7 @@
 #include "resource.h"
 #include "PythonApplication.h"
 #include "PythonTextTail.h"
+#include "GrpTextInstance.h"
 #include "PythonCharacterManager.h"
 #include "PythonGuild.h"
 #include "Locale.h"
@@ -145,6 +146,11 @@ void CPythonTextTail::UpdateShowingTextTail()
 {
 	TTextTailList::iterator itor;
 
+	CGraphicTextInstance::EndAggressiveBatch();
+	for (auto* pImg : deferredImages)
+		if (pImg)
+			pImg->Render();
+
 #if defined(ENABLE_GRAPHIC_ON_OFF)
 	if (CPythonGraphicOnOff::Instance().CanRenderDropItem(4))
 	{
@@ -560,6 +566,10 @@ void CPythonTextTail::ArrangeTextTail()
 
 void CPythonTextTail::Render()
 {
+	std::vector<CGraphicImageInstance*> deferredImages;
+	deferredImages.reserve(256);
+
+	CGraphicTextInstance::BeginAggressiveBatch();
 	TTextTailList::iterator itor;
 
 	for (itor = m_CharacterTextTailList.begin(); itor != m_CharacterTextTailList.end(); ++itor)
@@ -584,7 +594,7 @@ void CPythonTextTail::Render()
 
 		if (pTextTail->pMarkInstance && pTextTail->pGuildNameTextInstance)
 		{
-			pTextTail->pMarkInstance->Render();
+			deferredImages.push_back(pTextTail->pMarkInstance);
 			pTextTail->pGuildNameTextInstance->Render();
 		}
 
@@ -605,7 +615,7 @@ void CPythonTextTail::Render()
 
 #if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
 		if (pTextTail->pCountryFlagImageInstance && CPythonSystem::Instance().IsAlwaysShowCountry())
-			pTextTail->pCountryFlagImageInstance->Render();
+			deferredImages.push_back(pTextTail->pCountryFlagImageInstance);
 #endif
 
 #if defined(ENABLE_LEFT_SEAT)
