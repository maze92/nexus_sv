Binary files a/server/metin2/Source/Server/libthecore/src/utils.c and b/server/metin2/Source/Server/libthecore/src/utils.c differ
--- a/server/metin2/Source/Server/libthecore/src/log.c
+++ b/server/metin2/Source/Server/libthecore/src/log.c
@@ -1,456 +1,474 @@
-/**
-* Filename: log.c
-* Author: 비엽 aka. Cronan
-* Description: local log file 관련
-**/
-
-#define __LIBTHECORE__
-#include "stdafx.h"
-
-#ifndef __WIN32__
-#define SYSLOG_FILENAME "syslog"
-#define SYSERR_FILENAME "syserr"
-#define PTS_FILENAME "PTS"
-#else
-#define SYSLOG_FILENAME "syslog.txt"
-#define SYSERR_FILENAME "syserr.txt"
-#define PTS_FILENAME "PTS.txt"
-#endif
-
-typedef struct log_file_s* LPLOGFILE;
-typedef struct log_file_s LOGFILE;
-
-struct log_file_s
-{
-	char* filename;
-	FILE* fp;
-
-	int last_hour;
-	int last_day;
-};
-
-LPLOGFILE log_file_sys = NULL;
-LPLOGFILE log_file_err = NULL;
-LPLOGFILE log_file_pt = NULL;
-static char log_dir[32] = { 0, };
-unsigned int log_keep_days = 3;
-
-// Internal functions
-LPLOGFILE log_file_init(const char* filename, const char* openmode);
-void log_file_destroy(LPLOGFILE logfile);
-void log_file_rotate(LPLOGFILE logfile);
-void log_file_check(LPLOGFILE logfile);
-void log_file_set_dir(const char* dir);
-
-static unsigned int log_level_bits = 0;
-
-void log_set_level(unsigned int bit)
-{
-	log_level_bits |= bit;
-}
-
-void log_unset_level(unsigned int bit)
-{
-	log_level_bits &= ~bit;
-}
-
-void log_set_expiration_days(unsigned int days)
-{
-	log_keep_days = days;
-}
-
-int log_get_expiration_days(void)
-{
-	return log_keep_days;
-}
-
-int log_init(void)
-{
-	log_file_set_dir("./log");
-
-	do
-	{
-		log_file_sys = log_file_init(SYSLOG_FILENAME, "a+");
-		if (NULL == log_file_sys) break;
-
-		log_file_err = log_file_init(SYSERR_FILENAME, "a+");
-		if (NULL == log_file_err) break;
-
-		log_file_pt = log_file_init(PTS_FILENAME, "w");
-		if (NULL == log_file_pt) break;
-
-		return true;
-	} while (false);
-
-	return false;
-}
-
-void log_destroy(void)
-{
-	log_file_destroy(log_file_sys);
-	log_file_destroy(log_file_err);
-	log_file_destroy(log_file_pt);
-
-	log_file_sys = NULL;
-	log_file_err = NULL;
-	log_file_pt = NULL;
-}
-
-void log_rotate(void)
-{
-	log_file_check(log_file_sys);
-	log_file_check(log_file_err);
-	log_file_check(log_file_pt);
-
-	log_file_rotate(log_file_sys);
-}
-
-#ifndef __WIN32__
-void _sys_err(const char* func, int line, const char* format, ...)
-{
-	va_list args;
-	time_t ct = time(0);
-	char* time_s = asctime(localtime(&ct));
-
-	char buf[1024 + 2]; // \n을 붙이기 위해..
-	int len;
-
-	if (!log_file_err)
-		return;
-
-	time_s[strlen(time_s) - 1] = '\0';
-	len = snprintf(buf, 1024, "SYSERR: %-15.15s :: %s: ", time_s + 4, func);
-	buf[1025] = '\0';
-
-	if (len < 1024)
-	{
-		va_start(args, format);
-		vsnprintf(buf + len, 1024 - len, format, args);
-		va_end(args);
-	}
-
-	strcat(buf, "\n");
-
-	// log_file_err 에 출력
-	fputs(buf, log_file_err->fp);
-	fflush(log_file_err->fp);
-
-	// log_file_sys 에도 출력
-	fputs(buf, log_file_sys->fp);
-	fflush(log_file_sys->fp);
-}
-#else
-void _sys_err(const char* func, int line, const char* format, ...)
-{
-	va_list args;
-	time_t ct = time(0);
-	char* time_s = asctime(localtime(&ct));
-
-	char buf[1024 + 2]; // \n을 붙이기 위해..
-	int len;
-
-	if (!log_file_err)
-		return;
-
-	time_s[strlen(time_s) - 1] = '\0';
-	len = snprintf(buf, 1024, "SYSERR: %-15.15s :: %s: ", time_s + 4, func);
-	buf[1025] = '\0';
-
-	if (len < 1024)
-	{
-		va_start(args, format);
-		vsnprintf(buf + len, 1024 - len, format, args);
-		va_end(args);
-	}
-
-	strcat(buf, "\n");
-
-	// log_file_err 에 출력
-	fputs(buf, log_file_err->fp);
-	fflush(log_file_err->fp);
-
-	// log_file_sys 에도 출력
-	fputs(buf, log_file_sys->fp);
-	fflush(log_file_sys->fp);
-
-	fputs(buf, stdout);
-	fflush(stdout);
-}
-#endif
-
-static char sys_log_header_string[33] = { 0, };
-
-void sys_log_header(const char* header)
-{
-	strncpy(sys_log_header_string, header, 32);
-}
-
-void sys_log(unsigned int bit, const char* format, ...)
-{
-	va_list args;
-
-	if (bit != 0 && !(log_level_bits & bit))
-		return;
-
-	if (log_file_sys)
-	{
-		time_t ct = time(0);
-		char* time_s = asctime(localtime(&ct));
-
-		fprintf(log_file_sys->fp, "%s", sys_log_header_string);
-
-		time_s[strlen(time_s) - 1] = '\0';
-		fprintf(log_file_sys->fp, "%-15.15s :: ", time_s + 4);
-
-		va_start(args, format);
-		vfprintf(log_file_sys->fp, format, args);
-		va_end(args);
-
-		fputc('\n', log_file_sys->fp);
-		fflush(log_file_sys->fp);
-	}
-
-#ifndef __WIN32__
-	// log_level이 1 이상일 경우에는 테스트일 경우가 많으니 stdout에도 출력한다.
-	if (log_level_bits > 1)
-	{
-#endif
-		fprintf(stdout, "%s", sys_log_header_string);
-
-		va_start(args, format);
-		vfprintf(stdout, format, args);
-		va_end(args);
-
-		fputc('\n', stdout);
-		fflush(stdout);
-#ifndef __WIN32__
-	}
-#endif
-}
-
-void pt_log(const char* format, ...)
-{
-	va_list args;
-
-	if (!log_file_pt)
-		return;
-
-	va_start(args, format);
-	vfprintf(log_file_pt->fp, format, args);
-	va_end(args);
-
-	fputc('\n', log_file_pt->fp);
-	fflush(log_file_pt->fp);
-}
-
-LPLOGFILE log_file_init(const char* filename, const char* openmode)
-{
-	LPLOGFILE logfile;
-	FILE* fp;
-	struct tm curr_tm;
-	time_t time_s;
-
-	time_s = time(0);
-	curr_tm = *localtime(&time_s);
-
-	fp = fopen(filename, openmode);
-
-	if (!fp)
-		return NULL;
-
-	logfile = (LPLOGFILE)malloc(sizeof(LOGFILE));
-	logfile->filename = strdup(filename);
-	logfile->fp = fp;
-	logfile->last_hour = curr_tm.tm_hour;
-	logfile->last_day = curr_tm.tm_mday;
-
-	return (logfile);
-}
-
-void log_file_destroy(LPLOGFILE logfile)
-{
-	if (logfile == NULL)
-		return;
-
-	if (logfile->filename)
-	{
-		free(logfile->filename);
-		logfile->filename = NULL;
-	}
-
-	if (logfile->fp)
-	{
-		fclose(logfile->fp);
-		logfile->fp = NULL;
-	}
-
-	free(logfile);
-}
-
-void log_file_check(LPLOGFILE logfile)
-{
-	struct stat sb;
-
-	// 파일이 없으므로 다시 연다.
-	if (stat(logfile->filename, &sb) != 0 && errno == ENOENT)
-	{
-		fclose(logfile->fp);
-		logfile->fp = fopen(logfile->filename, "a+");
-	}
-}
-
-void log_file_delete_old(const char* filename)
-{
-	struct stat sb;
-	int num1, num2;
-	char buf[32];
-	char system_cmd[64];
-	struct tm new_tm;
-
-	if (stat(filename, &sb) == -1)
-	{
-		perror("log_file_delete_old: stat");
-		return;
-	}
-
-	if (!S_ISDIR(sb.st_mode))
-		return;
-
-	new_tm = *tm_calc(NULL, -static_cast<int>(log_keep_days));
-	sprintf(buf, "%04d%02d%02d", new_tm.tm_year + 1900, new_tm.tm_mon + 1, new_tm.tm_mday);
-	num1 = atoi(buf);
-#ifndef __WIN32__
-	{
-		struct dirent** namelist;
-		int n;
-
-		n = scandir(filename, &namelist, 0, alphasort);
-
-		if (n < 0)
-			perror("scandir");
-		else
-		{
-			char name[MAXNAMLEN + 1];
-
-			while (n-- > 0)
-			{
-				strncpy(name, namelist[n]->d_name, 255);
-				name[255] = '\0';
-
-				free(namelist[n]);
-
-				if (*name == '.')
-					continue;
-
-				if (!isdigit(*name))
-					continue;
-
-				num2 = atoi(name);
-
-				if (num2 <= num1)
-				{
-					sprintf(system_cmd, "rm -rf %s/%s", filename, name);
-					system(system_cmd);
-
-					sys_log(0, "%s: SYSTEM_CMD: %s", __FUNCTION__, system_cmd);
-					fprintf(stderr, "%s: SYSTEM_CMD: %s %s:%d %s:%d\n", __FUNCTION__, system_cmd, buf, num1, name, num2);
-				}
-			}
-		}
-
-		free(namelist);
-	}
-#else
-	{
-		WIN32_FIND_DATA fdata;
-		HANDLE hFind;
-		if ((hFind = FindFirstFile(filename, &fdata)) != INVALID_HANDLE_VALUE)
-		{
-			do
-			{
-				if (!isdigit(*fdata.cFileName))
-					continue;
-
-				num2 = atoi(fdata.cFileName);
-
-				if (num2 <= num1)
-				{
-					sprintf(system_cmd, "del %s\\%s", filename, fdata.cFileName);
-					system(system_cmd);
-
-					sys_log(0, "SYSTEM_CMD: %s", system_cmd);
-				}
-			} while (FindNextFile(hFind, &fdata));
-		}
-	}
-#endif
-}
-
-void log_file_rotate(LPLOGFILE logfile)
-{
-	struct tm curr_tm;
-	time_t time_s;
-	char dir[128];
-	char system_cmd[128];
-
-	time_s = time(0);
-	curr_tm = *localtime(&time_s);
-
-	if (curr_tm.tm_mday != logfile->last_day)
-	{
-		struct tm new_tm;
-		new_tm = *tm_calc(&curr_tm, -3);
-
-#ifndef __WIN32__
-		sprintf(system_cmd, "rm -rf %s/%04d%02d%02d", log_dir, new_tm.tm_year + 1900, new_tm.tm_mon + 1, new_tm.tm_mday);
-#else
-		sprintf(system_cmd, "del %s\\%04d%02d%02d", log_dir, new_tm.tm_year + 1900, new_tm.tm_mon + 1, new_tm.tm_mday);
-#endif
-		system(system_cmd);
-
-		sys_log(0, "SYSTEM_CMD: %s", system_cmd);
-
-		logfile->last_day = curr_tm.tm_mday;
-	}
-
-	if (curr_tm.tm_hour != logfile->last_hour)
-	{
-		struct stat stat_buf;
-		snprintf(dir, 128, "%s/%04d%02d%02d", log_dir, curr_tm.tm_year + 1900, curr_tm.tm_mon + 1, curr_tm.tm_mday);
-
-		if (stat(dir, &stat_buf) != 0 || S_ISDIR(stat_buf.st_mode))
-		{
-#ifdef __WIN32__
-			CreateDirectory(dir, NULL);
-#else
-			mkdir(dir, S_IRWXU);
-#endif
-		}
-
-		sys_log(0, "SYSTEM: LOG ROTATE (%04d-%02d-%02d %d)",
-			curr_tm.tm_year + 1900, curr_tm.tm_mon + 1, curr_tm.tm_mday, logfile->last_hour);
-
-		// 로그 파일을 닫고
-		fclose(logfile->fp);
-
-		// 옮긴다.
-#ifndef __WIN32__
-		snprintf(system_cmd, 128, "mv %s %s/%s.%02d", logfile->filename, dir, logfile->filename, logfile->last_hour);
-#else
-		snprintf(system_cmd, 128, "move %s %s\\%s.%02d", logfile->filename, dir, logfile->filename, logfile->last_hour);
-#endif
-		system(system_cmd);
-
-		// 마지막 저장시간 저장
-		logfile->last_hour = curr_tm.tm_hour;
-
-		// 로그 파일을 다시 연다.
-		logfile->fp = fopen(logfile->filename, "a+");
-	}
-}
-
-void log_file_set_dir(const char* dir)
-{
-	strcpy(log_dir, dir);
-	log_file_delete_old(log_dir);
-}
+/**
+* Filename: log.c
+* Author:  aka. Cronan
+* Description: local log file 
+**/
+
+#define __LIBTHECORE__
+#include "stdafx.h"
+
+#ifndef __WIN32__
+#define SYSLOG_FILENAME "syslog"
+#define SYSERR_FILENAME "syserr"
+#define PTS_FILENAME "PTS"
+#else
+#define SYSLOG_FILENAME "syslog.txt"
+#define SYSERR_FILENAME "syserr.txt"
+#define PTS_FILENAME "PTS.txt"
+#endif
+
+typedef struct log_file_s* LPLOGFILE;
+typedef struct log_file_s LOGFILE;
+
+struct log_file_s
+{
+	char* filename;
+	FILE* fp;
+
+	int last_hour;
+	int last_day;
+};
+
+LPLOGFILE log_file_sys = NULL;
+LPLOGFILE log_file_err = NULL;
+LPLOGFILE log_file_pt = NULL;
+static char log_dir[32] = { 0, };
+unsigned int log_keep_days = 3;
+
+// Internal functions
+LPLOGFILE log_file_init(const char* filename, const char* openmode);
+void log_file_destroy(LPLOGFILE logfile);
+void log_file_rotate(LPLOGFILE logfile);
+void log_file_check(LPLOGFILE logfile);
+void log_file_set_dir(const char* dir);
+
+static unsigned int log_level_bits = 0;
+
+void log_set_level(unsigned int bit)
+{
+	log_level_bits |= bit;
+}
+
+void log_unset_level(unsigned int bit)
+{
+	log_level_bits &= ~bit;
+}
+
+void log_set_expiration_days(unsigned int days)
+{
+	log_keep_days = days;
+}
+
+int log_get_expiration_days(void)
+{
+	return log_keep_days;
+}
+
+int log_init(void)
+{
+	log_file_set_dir("./log");
+
+	do
+	{
+		log_file_sys = log_file_init(SYSLOG_FILENAME, "a+");
+		if (NULL == log_file_sys) break;
+
+		log_file_err = log_file_init(SYSERR_FILENAME, "a+");
+		if (NULL == log_file_err) break;
+
+		log_file_pt = log_file_init(PTS_FILENAME, "w");
+		if (NULL == log_file_pt) break;
+
+		return true;
+	} while (false);
+
+	return false;
+}
+
+void log_destroy(void)
+{
+	log_file_destroy(log_file_sys);
+	log_file_destroy(log_file_err);
+	log_file_destroy(log_file_pt);
+
+	log_file_sys = NULL;
+	log_file_err = NULL;
+	log_file_pt = NULL;
+}
+
+void log_rotate(void)
+{
+	log_file_check(log_file_sys);
+	log_file_check(log_file_err);
+	log_file_check(log_file_pt);
+
+	log_file_rotate(log_file_sys);
+}
+
+#ifndef __WIN32__
+void _sys_err(const char* func, int line, const char* format, ...)
+{
+	va_list args;
+	time_t ct = time(0);
+		char time_s[32];
+		struct tm tm_buf;
+
+#if defined(_WIN32) || defined(_WIN64)
+		localtime_s(&tm_buf, &ct);
+#else
+		localtime_r(&ct, &tm_buf);
+#endif
+		strftime(time_s, sizeof(time_s), "%b %d %H:%M:%S", &tm_buf);
+char buf[1024 + 2]; // \n 堅 ..
+	int len;
+
+	if (!log_file_err)
+		return;	len = snprintf(buf, 1024, "SYSERR: %-15.15s :: %s: ", time_s + 4, func);
+	buf[1025] = '\0';
+
+	if (len < 1024)
+	{
+		va_start(args, format);
+		vsnprintf(buf + len, 1024 - len, format, args);
+		va_end(args);
+	}
+
+	strcat(buf, "\n");
+
+	// log_file_err  
+	fputs(buf, log_file_err->fp);
+	fflush(log_file_err->fp);
+
+	// log_file_sys  
+	fputs(buf, log_file_sys->fp);
+	fflush(log_file_sys->fp);
+}
+#else
+void _sys_err(const char* func, int line, const char* format, ...)
+{
+	va_list args;
+	time_t ct = time(0);
+		char time_s[32];
+		struct tm tm_buf;
+
+#if defined(_WIN32) || defined(_WIN64)
+		localtime_s(&tm_buf, &ct);
+#else
+		localtime_r(&ct, &tm_buf);
+#endif
+		strftime(time_s, sizeof(time_s), "%b %d %H:%M:%S", &tm_buf);
+char buf[1024 + 2]; // \n 堅 ..
+	int len;
+
+	if (!log_file_err)
+		return;	len = snprintf(buf, 1024, "SYSERR: %-15.15s :: %s: ", time_s + 4, func);
+	buf[1025] = '\0';
+
+	if (len < 1024)
+	{
+		va_start(args, format);
+		vsnprintf(buf + len, 1024 - len, format, args);
+		va_end(args);
+	}
+
+	strcat(buf, "\n");
+
+	// log_file_err  
+	fputs(buf, log_file_err->fp);
+	fflush(log_file_err->fp);
+
+	// log_file_sys  
+	fputs(buf, log_file_sys->fp);
+	fflush(log_file_sys->fp);
+
+	fputs(buf, stdout);
+	fflush(stdout);
+}
+#endif
+
+static char sys_log_header_string[33] = { 0, };
+
+void sys_log_header(const char* header)
+{
+	strncpy(sys_log_header_string, header, 32);
+}
+
+void sys_log(unsigned int bit, const char* format, ...)
+{
+	va_list args;
+
+	if (bit != 0 && !(log_level_bits & bit))
+		return;
+
+	if (log_file_sys)
+	{
+		time_t ct = time(0);
+		char time_s[32];
+		struct tm tm_buf;
+
+#if defined(_WIN32) || defined(_WIN64)
+		localtime_s(&tm_buf, &ct);
+#else
+		localtime_r(&ct, &tm_buf);
+#endif
+		strftime(time_s, sizeof(time_s), "%b %d %H:%M:%S", &tm_buf);
+fprintf(log_file_sys->fp, "%s", sys_log_header_string);		fprintf(log_file_sys->fp, "%-15.15s :: ", time_s + 4);
+
+		va_start(args, format);
+		vfprintf(log_file_sys->fp, format, args);
+		va_end(args);
+
+		fputc('\n', log_file_sys->fp);
+		fflush(log_file_sys->fp);
+	}
+
+#ifndef __WIN32__
+	// log_level 1 鵑 荑 謬트 李  stdout 磯.
+	if (log_level_bits > 1)
+	{
+#endif
+		fprintf(stdout, "%s", sys_log_header_string);
+
+		va_start(args, format);
+		vfprintf(stdout, format, args);
+		va_end(args);
+
+		fputc('\n', stdout);
+		fflush(stdout);
+#ifndef __WIN32__
+	}
+#endif
+}
+
+void pt_log(const char* format, ...)
+{
+	va_list args;
+
+	if (!log_file_pt)
+		return;
+
+	va_start(args, format);
+	vfprintf(log_file_pt->fp, format, args);
+	va_end(args);
+
+	fputc('\n', log_file_pt->fp);
+	fflush(log_file_pt->fp);
+}
+
+LPLOGFILE log_file_init(const char* filename, const char* openmode)
+{
+	LPLOGFILE logfile;
+	FILE* fp;
+	struct tm curr_tm;
+	time_t time_s;
+
+	time_s = time(0);
+	#if defined(_WIN32) || defined(_WIN64)
+	localtime_s(&curr_tm, &time_s);
+#else
+	localtime_r(&time_s, &curr_tm);
+#endif
+fp = fopen(filename, openmode);
+
+	if (!fp)
+		return NULL;
+
+	logfile = (LPLOGFILE)malloc(sizeof(LOGFILE));
+	logfile->filename = strdup(filename);
+	logfile->fp = fp;
+	logfile->last_hour = curr_tm.tm_hour;
+	logfile->last_day = curr_tm.tm_mday;
+
+	return (logfile);
+}
+
+void log_file_destroy(LPLOGFILE logfile)
+{
+	if (logfile == NULL)
+		return;
+
+	if (logfile->filename)
+	{
+		free(logfile->filename);
+		logfile->filename = NULL;
+	}
+
+	if (logfile->fp)
+	{
+		fclose(logfile->fp);
+		logfile->fp = NULL;
+	}
+
+	free(logfile);
+}
+
+void log_file_check(LPLOGFILE logfile)
+{
+	struct stat sb;
+
+	//  퓐 母 .
+	if (stat(logfile->filename, &sb) != 0 && errno == ENOENT)
+	{
+		fclose(logfile->fp);
+		logfile->fp = fopen(logfile->filename, "a+");
+	}
+}
+
+void log_file_delete_old(const char* filename)
+{
+	struct stat sb;
+	int num1, num2;
+	char buf[32];
+	char system_cmd[64];
+	struct tm new_tm;
+
+	if (stat(filename, &sb) == -1)
+	{
+		perror("log_file_delete_old: stat");
+		return;
+	}
+
+	if (!S_ISDIR(sb.st_mode))
+		return;
+
+	new_tm = *tm_calc(NULL, -static_cast<int>(log_keep_days));
+	sprintf(buf, "%04d%02d%02d", new_tm.tm_year + 1900, new_tm.tm_mon + 1, new_tm.tm_mday);
+	num1 = atoi(buf);
+#ifndef __WIN32__
+	{
+		struct dirent** namelist;
+		int n;
+
+		n = scandir(filename, &namelist, 0, alphasort);
+
+		if (n < 0)
+			perror("scandir");
+		else
+		{
+			char name[MAXNAMLEN + 1];
+
+			while (n-- > 0)
+			{
+				strncpy(name, namelist[n]->d_name, 255);
+				name[255] = '\0';
+
+				free(namelist[n]);
+
+				if (*name == '.')
+					continue;
+
+				if (!isdigit(*name))
+					continue;
+
+				num2 = atoi(name);
+
+				if (num2 <= num1)
+				{
+					sprintf(system_cmd, "rm -rf %s/%s", filename, name);
+					system(system_cmd);
+
+					sys_log(0, "%s: SYSTEM_CMD: %s", __FUNCTION__, system_cmd);
+					fprintf(stderr, "%s: SYSTEM_CMD: %s %s:%d %s:%d\n", __FUNCTION__, system_cmd, buf, num1, name, num2);
+				}
+			}
+		}
+
+		free(namelist);
+	}
+#else
+	{
+		WIN32_FIND_DATA fdata;
+		HANDLE hFind;
+		if ((hFind = FindFirstFile(filename, &fdata)) != INVALID_HANDLE_VALUE)
+		{
+			do
+			{
+				if (!isdigit(*fdata.cFileName))
+					continue;
+
+				num2 = atoi(fdata.cFileName);
+
+				if (num2 <= num1)
+				{
+					sprintf(system_cmd, "del %s\\%s", filename, fdata.cFileName);
+					system(system_cmd);
+
+					sys_log(0, "SYSTEM_CMD: %s", system_cmd);
+				}
+			} while (FindNextFile(hFind, &fdata));
+		}
+	}
+#endif
+}
+
+void log_file_rotate(LPLOGFILE logfile)
+{
+	struct tm curr_tm;
+	time_t time_s;
+	char dir[128];
+	char system_cmd[128];
+
+	time_s = time(0);
+	#if defined(_WIN32) || defined(_WIN64)
+	localtime_s(&curr_tm, &time_s);
+#else
+	localtime_r(&time_s, &curr_tm);
+#endif
+if (curr_tm.tm_mday != logfile->last_day)
+	{
+		struct tm new_tm;
+		new_tm = *tm_calc(&curr_tm, -3);
+
+#ifndef __WIN32__
+		sprintf(system_cmd, "rm -rf %s/%04d%02d%02d", log_dir, new_tm.tm_year + 1900, new_tm.tm_mon + 1, new_tm.tm_mday);
+#else
+		sprintf(system_cmd, "del %s\\%04d%02d%02d", log_dir, new_tm.tm_year + 1900, new_tm.tm_mon + 1, new_tm.tm_mday);
+#endif
+		system(system_cmd);
+
+		sys_log(0, "SYSTEM_CMD: %s", system_cmd);
+
+		logfile->last_day = curr_tm.tm_mday;
+	}
+
+	if (curr_tm.tm_hour != logfile->last_hour)
+	{
+		struct stat stat_buf;
+		snprintf(dir, 128, "%s/%04d%02d%02d", log_dir, curr_tm.tm_year + 1900, curr_tm.tm_mon + 1, curr_tm.tm_mday);
+
+		if (stat(dir, &stat_buf) != 0 || S_ISDIR(stat_buf.st_mode))
+		{
+#ifdef __WIN32__
+			CreateDirectory(dir, NULL);
+#else
+			mkdir(dir, S_IRWXU);
+#endif
+		}
+
+		sys_log(0, "SYSTEM: LOG ROTATE (%04d-%02d-%02d %d)",
+			curr_tm.tm_year + 1900, curr_tm.tm_mon + 1, curr_tm.tm_mday, logfile->last_hour);
+
+		// 慣  腑
+		fclose(logfile->fp);
+
+		// 킥.
+#ifndef __WIN32__
+		snprintf(system_cmd, 128, "mv %s %s/%s.%02d", logfile->filename, dir, logfile->filename, logfile->last_hour);
+#else
+		snprintf(system_cmd, 128, "move %s %s\\%s.%02d", logfile->filename, dir, logfile->filename, logfile->last_hour);
+#endif
+		system(system_cmd);
+
+		//  챨 
+		logfile->last_hour = curr_tm.tm_hour;
+
+		// 慣  母 .
+		logfile->fp = fopen(logfile->filename, "a+");
+	}
+}
+
+void log_file_set_dir(const char* dir)
+{
+	strcpy(log_dir, dir);
+	log_file_delete_old(log_dir);
+}
--- a/server/metin2/Source/Server/game/src/desc.cpp
+++ b/server/metin2/Source/Server/game/src/desc.cpp
@@ -1,1125 +1,1130 @@
-#include "stdafx.h"
-#include "config.h"
-#include "utils.h"
-#include "desc.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "protocol.h"
-#include "packet.h"
-#include "messenger_manager.h"
-#include "sectree_manager.h"
-#include "p2p.h"
-#include "buffer_manager.h"
-#if defined(__SEND_SEQUENCE__)
-#	include "sequence.h"
-#endif
-#include "guild.h"
-#include "guild_manager.h"
-#include "TrafficProfiler.h"
-#include "locale_service.h"
-#include "log.h"
-
-extern int max_bytes_written;
-extern int current_bytes_written;
-extern int total_bytes_written;
-
-DESC::DESC()
-{
-	Initialize();
-}
-
-DESC::~DESC()
-{
-}
-
-void DESC::Initialize()
-{
-	m_bDestroyed = false;
-
-	m_pInputProcessor = NULL;
-	m_lpFdw = NULL;
-	m_sock = INVALID_SOCKET;
-	m_iPhase = PHASE_CLOSE;
-	m_dwHandle = 0;
-
-	m_wPort = 0;
-	m_LastTryToConnectTime = 0;
-
-	m_lpInputBuffer = NULL;
-	m_iMinInputBufferLen = 0;
-
-	m_dwHandshake = 0;
-	m_dwHandshakeSentTime = 0;
-	m_iHandshakeRetry = 0;
-	m_dwClientTime = 0;
-	m_bHandshaking = false;
-
-	m_lpBufferedOutputBuffer = NULL;
-	m_lpOutputBuffer = NULL;
-
-	m_pkPingEvent = NULL;
-	m_lpCharacter = NULL;
-	memset(&m_accountTable, 0, sizeof(m_accountTable));
-
-	memset(&m_SockAddr, 0, sizeof(m_SockAddr));
-	memset(&m_UDPSockAddr, 0, sizeof(m_UDPSockAddr));
-
-	m_pLogFile = NULL;
-
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-	m_bEncrypted = false;
-#endif
-
-	m_wP2PPort = 0;
-	m_bP2PChannel = 0;
-
-	m_bAdminMode = false;
-	m_bPong = true;
-	m_bChannelStatusRequested = false;
-
-#if defined(__SEND_SEQUENCE__)
-	m_iCurrentSequence = 0;
-	m_seq_vector.clear();
-#endif
-
-	m_pkLoginKey = NULL;
-	m_dwLoginKey = 0;
-	m_dwPanamaKey = 0;
-
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-	memset(m_adwDecryptionKey, 0, sizeof(m_adwDecryptionKey));
-	memset(m_adwEncryptionKey, 0, sizeof(m_adwEncryptionKey));
-#endif
-
-	m_bCRCMagicCubeIdx = 0;
-	m_dwProcCRC = 0;
-	m_dwFileCRC = 0;
-	m_bHackCRCQuery = 0;
-
-	m_outtime = 0;
-	m_playtime = 0;
-	m_offtime = 0;
-
-	m_pkDisconnectEvent = NULL;
-}
-
-void DESC::Destroy()
-{
-	if (m_bDestroyed)
-		return;
-
-	m_bDestroyed = true;
-
-	if (m_pkLoginKey)
-		m_pkLoginKey->Expire();
-
-	if (GetAccountTable().id)
-		DESC_MANAGER::instance().DisconnectAccount(GetAccountTable().login);
-
-	if (m_pLogFile)
-	{
-		fclose(m_pLogFile);
-		m_pLogFile = NULL;
-	}
-
-	if (m_lpCharacter)
-	{
-		m_lpCharacter->Disconnect("DESC::~DESC");
-		m_lpCharacter = NULL;
-	}
-
-	SAFE_BUFFER_DELETE(m_lpOutputBuffer);
-	SAFE_BUFFER_DELETE(m_lpInputBuffer);
-
-	event_cancel(&m_pkPingEvent);
-	event_cancel(&m_pkDisconnectEvent);
-
-	if (!g_bAuthServer)
-	{
-		if (m_accountTable.login[0] && m_accountTable.passwd[0])
-		{
-			TLogoutPacket pack;
-
-			strlcpy(pack.login, m_accountTable.login, sizeof(pack.login));
-			strlcpy(pack.passwd, m_accountTable.passwd, sizeof(pack.passwd));
-
-			db_clientdesc->DBPacket(HEADER_GD_LOGOUT, m_dwHandle, &pack, sizeof(TLogoutPacket));
-		}
-	}
-
-	if (m_sock != INVALID_SOCKET)
-	{
-		sys_log(0, "SYSTEM: closing socket. DESC #%d", m_sock);
-		Log("SYSTEM: closing socket. DESC #%d", m_sock);
-		fdwatch_del_fd(m_lpFdw, m_sock);
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-		cipher_.CleanUp();
-#endif
-
-		socket_close(m_sock);
-		m_sock = INVALID_SOCKET;
-	}
-
-#if defined(__SEND_SEQUENCE__)
-	m_seq_vector.clear();
-#endif
-}
-
-EVENTFUNC(ping_event)
-{
-	DESC::desc_event_info* info = dynamic_cast<DESC::desc_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("ping_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPDESC desc = info->desc;
-
-	if (desc->IsAdminMode())
-		return (ping_event_second_cycle);
-
-	if (!desc->IsPong())
-	{
-		sys_log(0, "PING_EVENT: no pong %s", desc->GetHostName());
-
-		desc->SetPhase(PHASE_CLOSE);
-
-		return (ping_event_second_cycle);
-	}
-	else
-	{
-		TPacketGCPing p;
-		p.header = HEADER_GC_PING;
-		desc->Packet(&p, sizeof(struct packet_ping));
-		desc->SetPong(false);
-	}
-
-	desc->SendHandshake(get_dword_time(), 0);
-
-	return (ping_event_second_cycle);
-}
-
-bool DESC::IsPong()
-{
-	return m_bPong;
-}
-
-void DESC::SetPong(bool b)
-{
-	m_bPong = b;
-}
-
-bool DESC::Setup(LPFDWATCH _fdw, socket_t _fd, const struct sockaddr_in& c_rSockAddr, DWORD _handle, DWORD _handshake)
-{
-	m_lpFdw = _fdw;
-	m_sock = _fd;
-
-	m_stHost = inet_ntoa(c_rSockAddr.sin_addr);
-	m_wPort = c_rSockAddr.sin_port;
-	m_dwHandle = _handle;
-
-	//if (LC_IsEurope() == true || LC_IsNewCIBN())
-	//	m_lpOutputBuffer = buffer_new(DEFAULT_PACKET_BUFFER_SIZE * 2);
-	//else
-	// NOTE: 이걸 나라별로 다르게 잡아야할 이유가 있나?
-	m_lpOutputBuffer = buffer_new(DEFAULT_PACKET_BUFFER_SIZE * 2);
-
-	m_iMinInputBufferLen = MAX_INPUT_LEN >> 1;
-	m_lpInputBuffer = buffer_new(MAX_INPUT_LEN);
-
-	m_SockAddr = c_rSockAddr;
-
-	fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_READ, false);
-
-	// Ping Event 
-	desc_event_info* info = AllocEventInfo<desc_event_info>();
-
-	info->desc = this;
-	assert(m_pkPingEvent == NULL);
-
-	m_pkPingEvent = event_create(ping_event, info, ping_event_second_cycle);
-
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-	thecore_memcpy(m_adwEncryptionKey, "r5eZXhqBAeT5p2c9", sizeof(DWORD) * 4);
-	thecore_memcpy(m_adwDecryptionKey, "r5eZXhqBAeT5p2c9", sizeof(DWORD) * 4);
-#endif
-
-	// Set Phase to handshake
-	SetPhase(PHASE_HANDSHAKE);
-	StartHandshake(_handshake);
-
-	sys_log(0, "SYSTEM: new connection from [%s] fd: %d handshake %u output input_len %d, ptr %p",
-		m_stHost.c_str(), m_sock, m_dwHandshake, buffer_size(m_lpInputBuffer), this);
-
-	Log("SYSTEM: new connection from [%s] fd: %d handshake %u ptr %p", m_stHost.c_str(), m_sock, m_dwHandshake, this);
-	return true;
-}
-
-int DESC::ProcessInput()
-{
-	ssize_t bytes_read;
-
-	if (!m_lpInputBuffer)
-	{
-		sys_err("DESC::ProcessInput : nil input buffer");
-		return -1;
-	}
-
-	buffer_adjust_size(m_lpInputBuffer, m_iMinInputBufferLen);
-	bytes_read = socket_read(m_sock, (char*)buffer_write_peek(m_lpInputBuffer), buffer_has_space(m_lpInputBuffer));
-
-	if (bytes_read < 0)
-		return -1;
-	else if (bytes_read == 0)
-		return 0;
-
-	buffer_write_proceed(m_lpInputBuffer, bytes_read);
-
-	if (!m_pInputProcessor)
-		sys_err("no input processor");
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	else
-	{
-		// making a temporary buffer used to decrypt memory
-		TEMP_BUFFER temporary;
-
-		// checking for non read byes on decrypted buffer
-		// moving the stored buffer to the temporary one
-		if(m_lpInputDecryptedBuffer.size() != 0)
-			temporary.write(m_lpInputDecryptedBuffer.read_peek(), m_lpInputDecryptedBuffer.size());
-
-		// adding the readable memory from the input buffer
-		auto readableInput = buffer_size(m_lpInputBuffer);
-		if(readableInput > temporary.size())
-		{
-			const auto readPoint = (const char*) buffer_read_peek(m_lpInputBuffer);
-			temporary.write(readPoint + temporary.size(), readableInput - temporary.size());
-		}
-
-		if(temporary.size() == 0)
-			return 0;
-
-		// decrypting only non decrypted chunk of memory
-		if (cipher_.activated())
-		{
-			const auto decryptPoint = ((const char*)temporary.read_peek()) + m_lpInputDecryptedBuffer.size();
-			cipher_.Decrypt((void*)(decryptPoint), readableInput - m_lpInputDecryptedBuffer.size());
-		}
-
-		auto processingPoint = (const char*) temporary.read_peek();
-		auto processingRemainSize = temporary.size();
-		auto processingTotalSize = 0;
-
-		int iBytesProceed = 0;
-
-		// false가 리턴 되면 다른 phase로 바뀐 것이므로 다시 프로세스로 돌입한다!
-		while (processingRemainSize > 0 && !m_pInputProcessor->Process(this, (const void*)processingPoint, processingRemainSize, iBytesProceed))
-		{
-			processingPoint += iBytesProceed;
-			processingTotalSize += iBytesProceed;
-			processingRemainSize -= iBytesProceed;
-			iBytesProceed = 0;
-		}
-
-		processingPoint += iBytesProceed;
-		processingTotalSize += iBytesProceed;
-		processingRemainSize -= iBytesProceed;
-
-		// applying result on input buffer
-		buffer_read_proceed(m_lpInputBuffer, processingTotalSize);
-
-		// registering remaining unprocessed (but decrypted) bytes
-		m_lpInputDecryptedBuffer.reset();
-		if(processingTotalSize < temporary.size()){
-			const auto storingPoint = ((const char*) temporary.read_peek()) + processingTotalSize;
-			m_lpInputDecryptedBuffer.write(storingPoint, temporary.size() - processingTotalSize);
-		}
-	}
-#else
-	else if (!m_bEncrypted)
-	{
-		int iBytesProceed = 0;
-
-		// false가 리턴 되면 다른 phase로 바뀐 것이므로 다시 프로세스로 돌입한다!
-		while (!m_pInputProcessor->Process(this, buffer_read_peek(m_lpInputBuffer), buffer_size(m_lpInputBuffer), iBytesProceed))
-		{
-			buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
-			iBytesProceed = 0;
-		}
-
-		buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
-	}
-	else
-	{
-		int iSizeBuffer = buffer_size(m_lpInputBuffer);
-
-		// 8바이트 단위로만 처리한다. 8바이트 단위에 부족하면 잘못된 암호화 버퍼를 복호화
-		// 할 가능성이 있으므로 짤라서 처리하기로 한다.
-		if (iSizeBuffer & 7) // & 7은 % 8과 같다. 2의 승수에서만 가능
-			iSizeBuffer -= iSizeBuffer & 7;
-
-		if (iSizeBuffer > 0)
-		{
-			TEMP_BUFFER tempbuf;
-			LPBUFFER lpBufferDecrypt = tempbuf.getptr();
-			buffer_adjust_size(lpBufferDecrypt, iSizeBuffer);
-
-			int iSizeAfter = TEA_Decrypt((DWORD*)buffer_write_peek(lpBufferDecrypt),
-				(DWORD*)buffer_read_peek(m_lpInputBuffer),
-				GetDecryptionKey(),
-				iSizeBuffer);
-
-			buffer_write_proceed(lpBufferDecrypt, iSizeAfter);
-
-			int iBytesProceed = 0;
-
-			// false가 리턴 되면 다른 phase로 바뀐 것이므로 다시 프로세스로 돌입한다!
-			while (!m_pInputProcessor->Process(this, buffer_read_peek(lpBufferDecrypt), buffer_size(lpBufferDecrypt), iBytesProceed))
-			{
-				if (iBytesProceed > iSizeBuffer)
-				{
-					buffer_read_proceed(m_lpInputBuffer, iSizeBuffer);
-					iSizeBuffer = 0;
-					iBytesProceed = 0;
-					break;
-				}
-
-				buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
-				iSizeBuffer -= iBytesProceed;
-
-				buffer_read_proceed(lpBufferDecrypt, iBytesProceed);
-				iBytesProceed = 0;
-			}
-
-			buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
-		}
-	}
-#endif
-
-	return (bytes_read);
-}
-
-int DESC::ProcessOutput()
-{
-	if (buffer_size(m_lpOutputBuffer) <= 0)
-		return 0;
-
-	int buffer_left = fdwatch_get_buffer_size(m_lpFdw, m_sock);
-
-	if (buffer_left <= 0)
-		return 0;
-
-	int bytes_to_write = MIN(buffer_left, buffer_size(m_lpOutputBuffer));
-
-	if (bytes_to_write == 0)
-		return 0;
-
-	int result = socket_write(m_sock, (const char*)buffer_read_peek(m_lpOutputBuffer), bytes_to_write);
-
-	if (result == 0)
-	{
-		//sys_log(0, "%d bytes written to %s first %u", bytes_to_write, GetHostName(), *(BYTE *) buffer_read_peek(m_lpOutputBuffer));
-		//Log("%d bytes written", bytes_to_write);
-		max_bytes_written = MAX(bytes_to_write, max_bytes_written);
-
-		total_bytes_written += bytes_to_write;
-		current_bytes_written += bytes_to_write;
-
-		buffer_read_proceed(m_lpOutputBuffer, bytes_to_write);
-
-		if (buffer_size(m_lpOutputBuffer) != 0)
-			fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_WRITE, true);
-	}
-
-	return (result);
-}
-
-void DESC::BufferedPacket(const void* c_pvData, int iSize)
-{
-	if (m_iPhase == PHASE_CLOSE)
-		return;
-
-	if (!m_lpBufferedOutputBuffer)
-		m_lpBufferedOutputBuffer = buffer_new(MAX(1024, iSize));
-
-	buffer_write(m_lpBufferedOutputBuffer, c_pvData, iSize);
-}
-
-void DESC::Packet(const void* c_pvData, int iSize)
-{
-	assert(iSize > 0);
-
-	if (m_iPhase == PHASE_CLOSE) // 끊는 상태면 보내지 않는다.
-		return;
-
-	if (m_stRelayName.length() != 0)
-	{
-		// Relay 패킷은 암호화하지 않는다.
-		TPacketGGRelay p;
-
-		p.bHeader = HEADER_GG_RELAY;
-		strlcpy(p.szName, m_stRelayName.c_str(), sizeof(p.szName));
-		p.lSize = iSize;
-
-		if (!packet_encode(m_lpOutputBuffer, &p, sizeof(p)))
-		{
-			m_iPhase = PHASE_CLOSE;
-			return;
-		}
-
-		m_stRelayName.clear();
-
-		if (!packet_encode(m_lpOutputBuffer, c_pvData, iSize))
-		{
-			m_iPhase = PHASE_CLOSE;
-			return;
-		}
-	}
-	else
-	{
-		if (m_lpBufferedOutputBuffer)
-		{
-			buffer_write(m_lpBufferedOutputBuffer, c_pvData, iSize);
-
-			c_pvData = buffer_read_peek(m_lpBufferedOutputBuffer);
-			iSize = buffer_size(m_lpBufferedOutputBuffer);
-		}
-
-		// TRAFFIC_PROFILE
-		if (g_bTrafficProfileOn)
-			TrafficProfiler::instance().Report(TrafficProfiler::IODIR_OUTPUT, *(BYTE*)c_pvData, iSize);
-		// END_OF_TRAFFIC_PROFILER
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-		void* buf = buffer_write_peek(m_lpOutputBuffer);
-
-		if (packet_encode(m_lpOutputBuffer, c_pvData, iSize))
-		{
-			if (cipher_.activated())
-			{
-				cipher_.Encrypt(buf, iSize);
-			}
-		}
-		else
-		{
-			m_iPhase = PHASE_CLOSE;
-		}
-#else
-		if (!m_bEncrypted)
-		{
-			if (!packet_encode(m_lpOutputBuffer, c_pvData, iSize))
-			{
-				m_iPhase = PHASE_CLOSE;
-			}
-		}
-		else
-		{
-			if (buffer_has_space(m_lpOutputBuffer) < iSize + 8)
-			{
-				sys_err("desc buffer mem_size overflow. memsize(%u) write_pos(%u) iSize(%d)",
-					m_lpOutputBuffer->mem_size, m_lpOutputBuffer->write_point_pos, iSize);
-
-				m_iPhase = PHASE_CLOSE;
-			}
-			else
-			{
-				// 암호화에 필요한 충분한 버퍼 크기를 확보한다.
-				/* buffer_adjust_size(m_lpOutputBuffer, iSize + 8); */
-				DWORD* pdwWritePoint = (DWORD*)buffer_write_peek(m_lpOutputBuffer);
-
-				if (packet_encode(m_lpOutputBuffer, c_pvData, iSize))
-				{
-					int iSize2 = TEA_Encrypt(pdwWritePoint, pdwWritePoint, GetEncryptionKey(), iSize);
-
-					if (iSize2 > iSize)
-						buffer_write_proceed(m_lpOutputBuffer, iSize2 - iSize);
-				}
-			}
-		}
-#endif
-
-		SAFE_BUFFER_DELETE(m_lpBufferedOutputBuffer);
-	}
-
-	//sys_log(0, "%d bytes written (first byte %d)", iSize, *(BYTE *) c_pvData);
-	if (m_iPhase != PHASE_CLOSE)
-		fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_WRITE, true);
-}
-
-void DESC::LargePacket(const void* c_pvData, int iSize)
-{
-	buffer_adjust_size(m_lpOutputBuffer, iSize);
-	sys_log(0, "LargePacket Size %d", iSize, buffer_size(m_lpOutputBuffer));
-
-	Packet(c_pvData, iSize);
-}
-
-void DESC::SetPhase(int _phase)
-{
-	m_iPhase = _phase;
-
-	TPacketGCPhase pack;
-	pack.header = HEADER_GC_PHASE;
-	pack.phase = _phase;
-	Packet(&pack, sizeof(TPacketGCPhase));
-
-	switch (m_iPhase)
-	{
-	case PHASE_CLOSE:
-		// 메신저가 캐릭터단위가 되면서 삭제
-		// CMessengerManager::instance().Logout(GetAccountTable().login);
-		m_pInputProcessor = &m_inputClose;
-		break;
-
-	case PHASE_HANDSHAKE:
-		m_pInputProcessor = &m_inputHandshake;
-		break;
-
-	case PHASE_SELECT:
-		// 메신저가 캐릭터단위가 되면서 삭제
-		// CMessengerManager::instance().Logout(GetAccountTable().login); // 의도적으로 break 안검
-	case PHASE_LOGIN:
-	case PHASE_LOADING:
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-		m_bEncrypted = true;
-#endif
-		m_pInputProcessor = &m_inputLogin;
-		break;
-
-	case PHASE_GAME:
-	case PHASE_DEAD:
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-		m_bEncrypted = true;
-#endif
-		m_pInputProcessor = &m_inputMain;
-		break;
-
-	case PHASE_AUTH:
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-		m_bEncrypted = true;
-#endif
-		m_pInputProcessor = &m_inputAuth;
-		sys_log(0, "AUTH_PHASE %p", this);
-		break;
-	}
-}
-
-void DESC::BindAccountTable(TAccountTable* pAccountTable)
-{
-	assert(pAccountTable != NULL);
-	thecore_memcpy(&m_accountTable, pAccountTable, sizeof(TAccountTable));
-	DESC_MANAGER::instance().ConnectAccount(m_accountTable.login, this);
-}
-
-void DESC::UDPGrant(const struct sockaddr_in& c_rSockAddr)
-{
-	m_UDPSockAddr = c_rSockAddr;
-
-	TPacketGCBindUDP pack;
-
-	pack.header = HEADER_GC_BINDUDP;
-	pack.addr = m_UDPSockAddr.sin_addr.s_addr;
-	pack.port = m_UDPSockAddr.sin_port;
-
-	Packet(&pack, sizeof(TPacketGCBindUDP));
-}
-
-void DESC::Log(const char* format, ...)
-{
-	if (!m_pLogFile)
-		return;
-
-	va_list args;
-
-	time_t ct = get_global_time();
-	struct tm tm = *localtime(&ct);
-
-	fprintf(m_pLogFile,
-		"%02d %02d %02d:%02d:%02d | ",
-		tm.tm_mon + 1,
-		tm.tm_mday,
-		tm.tm_hour,
-		tm.tm_min,
-		tm.tm_sec);
-
-	va_start(args, format);
-	vfprintf(m_pLogFile, format, args);
-	va_end(args);
-
-	fputs("\n", m_pLogFile);
-
-	fflush(m_pLogFile);
-}
-
-void DESC::StartHandshake(DWORD _handshake)
-{
-	// Handshake
-	m_dwHandshake = _handshake;
-
-	SendHandshake(get_dword_time(), 0);
-
-	m_iHandshakeRetry = 0;
-}
-
-void DESC::SendHandshake(DWORD dwCurTime, long lNewDelta)
-{
-	TPacketGCHandshake pack;
-
-	pack.bHeader = HEADER_GC_HANDSHAKE;
-	pack.dwHandshake = m_dwHandshake;
-	pack.dwTime = dwCurTime;
-	pack.lDelta = lNewDelta;
-
-	Packet(&pack, sizeof(TPacketGCHandshake));
-
-	m_dwHandshakeSentTime = dwCurTime;
-	m_bHandshaking = true;
-}
-
-bool DESC::HandshakeProcess(DWORD dwTime, long lDelta, bool bInfiniteRetry)
-{
-	DWORD dwCurTime = get_dword_time();
-
-	if (lDelta < 0)
-	{
-		sys_err("Desc::HandshakeProcess : value error (lDelta %d, ip %s)", lDelta, m_stHost.c_str());
-		return false;
-	}
-
-	int bias = (int)(dwCurTime - (dwTime + lDelta));
-
-	if (bias >= 0 && bias <= 50)
-	{
-		if (bInfiniteRetry)
-		{
-			BYTE bHeader = HEADER_GC_TIME_SYNC;
-			Packet(&bHeader, sizeof(BYTE));
-		}
-
-		if (GetCharacter())
-			sys_log(0, "Handshake: client_time %u server_time %u name: %s", m_dwClientTime, dwCurTime, GetCharacter()->GetName());
-		else
-			sys_log(0, "Handshake: client_time %u server_time %u", m_dwClientTime, dwCurTime, lDelta);
-
-		m_dwClientTime = dwCurTime;
-		m_bHandshaking = false;
-		return true;
-	}
-
-	long lNewDelta = (long)(dwCurTime - dwTime) / 2;
-
-	if (lNewDelta < 0)
-	{
-		sys_log(0, "Handshake: lower than zero %d", lNewDelta);
-		lNewDelta = (dwCurTime - m_dwHandshakeSentTime) / 2;
-	}
-
-	sys_log(1, "Handshake: ServerTime %u dwTime %u lDelta %d SentTime %u lNewDelta %d", dwCurTime, dwTime, lDelta, m_dwHandshakeSentTime, lNewDelta);
-
-	if (!bInfiniteRetry)
-		if (++m_iHandshakeRetry > HANDSHAKE_RETRY_LIMIT)
-		{
-			sys_err("handshake retry limit reached! (limit %d character %s)",
-				HANDSHAKE_RETRY_LIMIT, GetCharacter() ? GetCharacter()->GetName() : "!NO CHARACTER!");
-			SetPhase(PHASE_CLOSE);
-			return false;
-		}
-
-	SendHandshake(dwCurTime, lNewDelta);
-	return false;
-}
-
-bool DESC::IsHandshaking()
-{
-	return m_bHandshaking;
-}
-
-DWORD DESC::GetClientTime()
-{
-	return m_dwClientTime;
-}
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-void DESC::SendKeyAgreement()
-{
-	TPacketKeyAgreement packet;
-
-	size_t data_length = TPacketKeyAgreement::MAX_DATA_LEN;
-	size_t agreed_length = cipher_.Prepare(packet.data, &data_length);
-	if (agreed_length == 0)
-	{
-		// Initialization failure
-		SetPhase(PHASE_CLOSE);
-		return;
-	}
-	assert(data_length <= TPacketKeyAgreement::MAX_DATA_LEN);
-
-	packet.bHeader = HEADER_GC_KEY_AGREEMENT;
-	packet.wAgreedLength = (WORD)agreed_length;
-	packet.wDataLength = (WORD)data_length;
-
-	Packet(&packet, sizeof(packet));
-}
-
-void DESC::SendKeyAgreementCompleted()
-{
-	TPacketKeyAgreementCompleted packet;
-
-	packet.bHeader = HEADER_GC_KEY_AGREEMENT_COMPLETED;
-
-	Packet(&packet, sizeof(packet));
-}
-
-bool DESC::FinishHandshake(size_t agreed_length, const void* buffer, size_t length)
-{
-	return cipher_.Activate(false, agreed_length, buffer, length);
-}
-
-bool DESC::IsCipherPrepared()
-{
-	return cipher_.IsKeyPrepared();
-}
-#endif
-
-void DESC::SetRelay(const char* c_pszName)
-{
-	m_stRelayName = c_pszName;
-}
-
-void DESC::BindCharacter(LPCHARACTER ch)
-{
-	m_lpCharacter = ch;
-}
-
-void DESC::FlushOutput()
-{
-	if (m_sock == INVALID_SOCKET)
-		return;
-
-	if (buffer_size(m_lpOutputBuffer) <= 0)
-		return;
-
-	struct timeval sleep_tv, now_tv, start_tv;
-	int event_triggered = false;
-
-	gettimeofday(&start_tv, NULL);
-
-	socket_block(m_sock);
-	sys_log(0, "FLUSH START %d", buffer_size(m_lpOutputBuffer));
-
-	while (buffer_size(m_lpOutputBuffer) > 0)
-	{
-		gettimeofday(&now_tv, NULL);
-
-		int iSecondsPassed = now_tv.tv_sec - start_tv.tv_sec;
-
-		if (iSecondsPassed > 10)
-		{
-			if (!event_triggered || iSecondsPassed > 20)
-			{
-				SetPhase(PHASE_CLOSE);
-				break;
-			}
-		}
-
-		sleep_tv.tv_sec = 0;
-		sleep_tv.tv_usec = 10000;
-
-		int num_events = fdwatch(m_lpFdw, &sleep_tv);
-
-		if (num_events < 0)
-		{
-			sys_err("num_events < 0 : %d", num_events);
-			break;
-		}
-
-		int event_idx;
-
-		for (event_idx = 0; event_idx < num_events; ++event_idx)
-		{
-			LPDESC d2 = (LPDESC)fdwatch_get_client_data(m_lpFdw, event_idx);
-
-			if (d2 != this)
-				continue;
-
-			switch (fdwatch_check_event(m_lpFdw, m_sock, event_idx))
-			{
-			case FDW_WRITE:
-				event_triggered = true;
-
-				if (ProcessOutput() < 0)
-				{
-					sys_err("Cannot flush output buffer");
-					SetPhase(PHASE_CLOSE);
-				}
-				break;
-
-			case FDW_EOF:
-				SetPhase(PHASE_CLOSE);
-				break;
-			}
-		}
-
-		if (IsPhase(PHASE_CLOSE))
-			break;
-	}
-
-	if (buffer_size(m_lpOutputBuffer) == 0)
-		sys_log(0, "FLUSH SUCCESS");
-	else
-		sys_log(0, "FLUSH FAIL");
-
-	usleep(250000);
-}
-
-EVENTFUNC(disconnect_event)
-{
-	DESC::desc_event_info* info = dynamic_cast<DESC::desc_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("disconnect_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPDESC d = info->desc;
-
-	d->m_pkDisconnectEvent = NULL;
-	d->SetPhase(PHASE_CLOSE);
-	return 0;
-}
-
-bool DESC::DelayedDisconnect(int iSec)
-{
-	if (m_pkDisconnectEvent != NULL)
-		return false;
-
-	desc_event_info* info = AllocEventInfo<desc_event_info>();
-	info->desc = this;
-
-	m_pkDisconnectEvent = event_create(disconnect_event, info, PASSES_PER_SEC(iSec));
-	return true;
-}
-
-void DESC::DisconnectOfSameLogin()
-{
-	if (GetCharacter())
-	{
-		if (m_pkDisconnectEvent)
-			return;
-
-		GetCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("다른 컴퓨터에서 로그인 하여 접속을 종료 합니다."));
-		DelayedDisconnect(5);
-	}
-	else
-	{
-		SetPhase(PHASE_CLOSE);
-	}
-}
-
-void DESC::SetAdminMode()
-{
-	m_bAdminMode = true;
-}
-
-bool DESC::IsAdminMode()
-{
-	return m_bAdminMode;
-}
-
-#if defined(__SEND_SEQUENCE__)
-BYTE DESC::GetSequence()
-{
-	return gc_abSequence[m_iCurrentSequence];
-}
-
-void DESC::SetNextSequence()
-{
-	if (++m_iCurrentSequence == SEQUENCE_MAX_NUM)
-		m_iCurrentSequence = 0;
-}
-#endif
-
-void DESC::SendLoginSuccessPacket()
-{
-	TAccountTable& rTable = GetAccountTable();
-
-	TPacketGCLoginSuccess p;
-
-	p.bHeader = HEADER_GC_LOGIN_SUCCESS_NEWSLOT;
-
-	p.handle = GetHandle();
-	p.random_key = DESC_MANAGER::instance().MakeRandomKey(GetHandle()); // FOR MARK
-	thecore_memcpy(p.players, rTable.players, sizeof(rTable.players));
-
-	for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
-	{
-#if defined(__PROXY_IP__)
-		if (!g_stProxyIP.empty())
-			rTable.players[i].lAddr = inet_addr(g_stProxyIP.c_str());
-#endif
-
-		CGuild* g = CGuildManager::instance().GetLinkedGuild(rTable.players[i].dwID);
-
-		if (g)
-		{
-			p.guild_id[i] = g->GetID();
-			strlcpy(p.guild_name[i], g->GetName(), sizeof(p.guild_name[i]));
-		}
-		else
-		{
-			p.guild_id[i] = 0;
-			p.guild_name[i][0] = '\0';
-		}
-	}
-
-	Packet(&p, sizeof(TPacketGCLoginSuccess));
-}
-
-//void DESC::SendServerStatePacket(int nIndex)
-//{
-//	TPacketGCStateCheck rp;
-//
-//	int iTotal; 
-//	int * paiEmpireUserCount;
-//	int iLocal;
-//
-//	DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
-//
-//	rp.header	= 1; 
-//	rp.key		= 0;
-//	rp.index	= nIndex;
-//
-//	if (g_bNoMoreClient) rp.state = 0;
-//	else rp.state = iTotal > g_iFullUserCount ? 3 : iTotal > g_iBusyUserCount ? 2 : 1;
-//	
-//	this->Packet(&rp, sizeof(rp));
-//	//printf("STATE_CHECK PACKET PROCESSED.\n");
-//}
-
-void DESC::SetLoginKey(DWORD dwKey)
-{
-	m_dwLoginKey = dwKey;
-}
-
-void DESC::SetLoginKey(CLoginKey* pkKey)
-{
-	m_pkLoginKey = pkKey;
-	sys_log(0, "SetLoginKey %u", m_pkLoginKey->m_dwKey);
-}
-
-DWORD DESC::GetLoginKey()
-{
-	if (m_pkLoginKey)
-		return m_pkLoginKey->m_dwKey;
-
-	return m_dwLoginKey;
-}
-
-const BYTE* GetKey()
-{
-	static bool bGenerated = false;
-	static DWORD s_adwKey[1938];
-
-	if (!bGenerated)
-	{
-		bGenerated = true;
-		DWORD seed = 1491971513;
-
-		for (UINT i = 0; i < BYTE(seed); ++i)
-		{
-			seed ^= 2148941891ul;
-			seed += 3592385981ul;
-
-			s_adwKey[i] = seed;
-		}
-	}
-
-	return (const BYTE*)s_adwKey;
-}
-
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-void DESC::SetSecurityKey(const DWORD* c_pdwKey)
-{
-	const BYTE* c_pszKey = GetKey() + 37;
-
-	thecore_memcpy(&m_adwDecryptionKey, c_pdwKey, 16);
-	TEA_Encrypt(&m_adwEncryptionKey[0], &m_adwDecryptionKey[0], (const DWORD*)c_pszKey, 16);
-
-	sys_log(0, "SetSecurityKey decrypt %u %u %u %u encrypt %u %u %u %u",
-		m_adwDecryptionKey[0], m_adwDecryptionKey[1], m_adwDecryptionKey[2], m_adwDecryptionKey[3],
-		m_adwEncryptionKey[0], m_adwEncryptionKey[1], m_adwEncryptionKey[2], m_adwEncryptionKey[3]);
-}
-#endif
-
-void DESC::AssembleCRCMagicCube(BYTE bProcPiece, BYTE bFilePiece)
-{
-	static BYTE abXORTable[32] =
-	{
-		102, 30, 0, 0, 0, 0, 0, 0,
-		188, 44, 0, 0, 0, 0, 0, 0,
-		39, 201, 0, 0, 0, 0, 0, 0,
-		43, 5, 0, 0, 0, 0, 0, 0,
-	};
-
-	bProcPiece = (bProcPiece ^ abXORTable[m_bCRCMagicCubeIdx]);
-	bFilePiece = (bFilePiece ^ abXORTable[m_bCRCMagicCubeIdx + 1]);
-
-	m_dwProcCRC |= bProcPiece << m_bCRCMagicCubeIdx;
-	m_dwFileCRC |= bFilePiece << m_bCRCMagicCubeIdx;
-
-	m_bCRCMagicCubeIdx += 8;
-
-	if (!(m_bCRCMagicCubeIdx & 31))
-	{
-		m_dwProcCRC = 0;
-		m_dwFileCRC = 0;
-		m_bCRCMagicCubeIdx = 0;
-	}
-}
-
-#if defined(__SEND_SEQUENCE__)
-void DESC::push_seq(BYTE hdr, BYTE seq)
-{
-	if (m_seq_vector.size() >= 20)
-	{
-		m_seq_vector.erase(m_seq_vector.begin());
-	}
-
-	seq_t info = { hdr, seq };
-	m_seq_vector.push_back(info);
-}
-#endif
-
-BYTE DESC::GetEmpire()
-{
-	return m_accountTable.bEmpire;
-}
-
-void DESC::ChatPacket(BYTE type, const char* format, ...)
-{
-	char chatbuf[CHAT_MAX_LEN + 1];
-	va_list args;
-
-	va_start(args, format);
-	int len = vsnprintf(chatbuf, sizeof(chatbuf), format, args);
-	va_end(args);
-
-	struct packet_chat pack_chat;
-
-	pack_chat.header = HEADER_GC_CHAT;
-	pack_chat.size = sizeof(struct packet_chat) + len;
-	pack_chat.type = type;
-	pack_chat.id = 0;
-	pack_chat.bEmpire = GetEmpire();
-
-	TEMP_BUFFER buf;
-	buf.write(&pack_chat, sizeof(struct packet_chat));
-	buf.write(chatbuf, len);
-
-	Packet(buf.read_peek(), buf.size());
-}
+#include "stdafx.h"
+#include "config.h"
+#include "utils.h"
+#include "desc.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "protocol.h"
+#include "packet.h"
+#include "messenger_manager.h"
+#include "sectree_manager.h"
+#include "p2p.h"
+#include "buffer_manager.h"
+#if defined(__SEND_SEQUENCE__)
+#	include "sequence.h"
+#endif
+#include "guild.h"
+#include "guild_manager.h"
+#include "TrafficProfiler.h"
+#include "locale_service.h"
+#include "log.h"
+
+extern int max_bytes_written;
+extern int current_bytes_written;
+extern int total_bytes_written;
+
+DESC::DESC()
+{
+	Initialize();
+}
+
+DESC::~DESC()
+{
+}
+
+void DESC::Initialize()
+{
+	m_bDestroyed = false;
+
+	m_pInputProcessor = NULL;
+	m_lpFdw = NULL;
+	m_sock = INVALID_SOCKET;
+	m_iPhase = PHASE_CLOSE;
+	m_dwHandle = 0;
+
+	m_wPort = 0;
+	m_LastTryToConnectTime = 0;
+
+	m_lpInputBuffer = NULL;
+	m_iMinInputBufferLen = 0;
+
+	m_dwHandshake = 0;
+	m_dwHandshakeSentTime = 0;
+	m_iHandshakeRetry = 0;
+	m_dwClientTime = 0;
+	m_bHandshaking = false;
+
+	m_lpBufferedOutputBuffer = NULL;
+	m_lpOutputBuffer = NULL;
+
+	m_pkPingEvent = NULL;
+	m_lpCharacter = NULL;
+	memset(&m_accountTable, 0, sizeof(m_accountTable));
+
+	memset(&m_SockAddr, 0, sizeof(m_SockAddr));
+	memset(&m_UDPSockAddr, 0, sizeof(m_UDPSockAddr));
+
+	m_pLogFile = NULL;
+
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+	m_bEncrypted = false;
+#endif
+
+	m_wP2PPort = 0;
+	m_bP2PChannel = 0;
+
+	m_bAdminMode = false;
+	m_bPong = true;
+	m_bChannelStatusRequested = false;
+
+#if defined(__SEND_SEQUENCE__)
+	m_iCurrentSequence = 0;
+	m_seq_vector.clear();
+#endif
+
+	m_pkLoginKey = NULL;
+	m_dwLoginKey = 0;
+	m_dwPanamaKey = 0;
+
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+	memset(m_adwDecryptionKey, 0, sizeof(m_adwDecryptionKey));
+	memset(m_adwEncryptionKey, 0, sizeof(m_adwEncryptionKey));
+#endif
+
+	m_bCRCMagicCubeIdx = 0;
+	m_dwProcCRC = 0;
+	m_dwFileCRC = 0;
+	m_bHackCRCQuery = 0;
+
+	m_outtime = 0;
+	m_playtime = 0;
+	m_offtime = 0;
+
+	m_pkDisconnectEvent = NULL;
+}
+
+void DESC::Destroy()
+{
+	if (m_bDestroyed)
+		return;
+
+	m_bDestroyed = true;
+
+	if (m_pkLoginKey)
+		m_pkLoginKey->Expire();
+
+	if (GetAccountTable().id)
+		DESC_MANAGER::instance().DisconnectAccount(GetAccountTable().login);
+
+	if (m_pLogFile)
+	{
+		fclose(m_pLogFile);
+		m_pLogFile = NULL;
+	}
+
+	if (m_lpCharacter)
+	{
+		m_lpCharacter->Disconnect("DESC::~DESC");
+		m_lpCharacter = NULL;
+	}
+
+	SAFE_BUFFER_DELETE(m_lpOutputBuffer);
+	SAFE_BUFFER_DELETE(m_lpInputBuffer);
+
+	event_cancel(&m_pkPingEvent);
+	event_cancel(&m_pkDisconnectEvent);
+
+	if (!g_bAuthServer)
+	{
+		if (m_accountTable.login[0] && m_accountTable.passwd[0])
+		{
+			TLogoutPacket pack;
+
+			strlcpy(pack.login, m_accountTable.login, sizeof(pack.login));
+			strlcpy(pack.passwd, m_accountTable.passwd, sizeof(pack.passwd));
+
+			db_clientdesc->DBPacket(HEADER_GD_LOGOUT, m_dwHandle, &pack, sizeof(TLogoutPacket));
+		}
+	}
+
+	if (m_sock != INVALID_SOCKET)
+	{
+		sys_log(0, "SYSTEM: closing socket. DESC #%d", m_sock);
+		Log("SYSTEM: closing socket. DESC #%d", m_sock);
+		fdwatch_del_fd(m_lpFdw, m_sock);
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+		cipher_.CleanUp();
+#endif
+
+		socket_close(m_sock);
+		m_sock = INVALID_SOCKET;
+	}
+
+#if defined(__SEND_SEQUENCE__)
+	m_seq_vector.clear();
+#endif
+}
+
+EVENTFUNC(ping_event)
+{
+	DESC::desc_event_info* info = dynamic_cast<DESC::desc_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("ping_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPDESC desc = info->desc;
+
+	if (desc->IsAdminMode())
+		return (ping_event_second_cycle);
+
+	if (!desc->IsPong())
+	{
+		sys_log(0, "PING_EVENT: no pong %s", desc->GetHostName());
+
+		desc->SetPhase(PHASE_CLOSE);
+
+		return (ping_event_second_cycle);
+	}
+	else
+	{
+		TPacketGCPing p;
+		p.header = HEADER_GC_PING;
+		desc->Packet(&p, sizeof(struct packet_ping));
+		desc->SetPong(false);
+	}
+
+	desc->SendHandshake(get_dword_time(), 0);
+
+	return (ping_event_second_cycle);
+}
+
+bool DESC::IsPong()
+{
+	return m_bPong;
+}
+
+void DESC::SetPong(bool b)
+{
+	m_bPong = b;
+}
+
+bool DESC::Setup(LPFDWATCH _fdw, socket_t _fd, const struct sockaddr_in& c_rSockAddr, DWORD _handle, DWORD _handshake)
+{
+	m_lpFdw = _fdw;
+	m_sock = _fd;
+
+	m_stHost = inet_ntoa(c_rSockAddr.sin_addr);
+	m_wPort = c_rSockAddr.sin_port;
+	m_dwHandle = _handle;
+
+	//if (LC_IsEurope() == true || LC_IsNewCIBN())
+	//	m_lpOutputBuffer = buffer_new(DEFAULT_PACKET_BUFFER_SIZE * 2);
+	//else
+	// NOTE: 隔 鑿갬 摸 틴  簾?
+	m_lpOutputBuffer = buffer_new(DEFAULT_PACKET_BUFFER_SIZE * 2);
+
+	m_iMinInputBufferLen = MAX_INPUT_LEN >> 1;
+	m_lpInputBuffer = buffer_new(MAX_INPUT_LEN);
+
+	m_SockAddr = c_rSockAddr;
+
+	fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_READ, false);
+
+	// Ping Event 
+	desc_event_info* info = AllocEventInfo<desc_event_info>();
+
+	info->desc = this;
+	assert(m_pkPingEvent == NULL);
+
+	m_pkPingEvent = event_create(ping_event, info, ping_event_second_cycle);
+
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+	thecore_memcpy(m_adwEncryptionKey, "r5eZXhqBAeT5p2c9", sizeof(DWORD) * 4);
+	thecore_memcpy(m_adwDecryptionKey, "r5eZXhqBAeT5p2c9", sizeof(DWORD) * 4);
+#endif
+
+	// Set Phase to handshake
+	SetPhase(PHASE_HANDSHAKE);
+	StartHandshake(_handshake);
+
+	sys_log(0, "SYSTEM: new connection from [%s] fd: %d handshake %u output input_len %d, ptr %p",
+		m_stHost.c_str(), m_sock, m_dwHandshake, buffer_size(m_lpInputBuffer), this);
+
+	Log("SYSTEM: new connection from [%s] fd: %d handshake %u ptr %p", m_stHost.c_str(), m_sock, m_dwHandshake, this);
+	return true;
+}
+
+int DESC::ProcessInput()
+{
+	ssize_t bytes_read;
+
+	if (!m_lpInputBuffer)
+	{
+		sys_err("DESC::ProcessInput : nil input buffer");
+		return -1;
+	}
+
+	buffer_adjust_size(m_lpInputBuffer, m_iMinInputBufferLen);
+	bytes_read = socket_read(m_sock, (char*)buffer_write_peek(m_lpInputBuffer), buffer_has_space(m_lpInputBuffer));
+
+	if (bytes_read < 0)
+		return -1;
+	else if (bytes_read == 0)
+		return 0;
+
+	buffer_write_proceed(m_lpInputBuffer, bytes_read);
+
+	if (!m_pInputProcessor)
+		sys_err("no input processor");
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	else
+	{
+		// making a temporary buffer used to decrypt memory
+		TEMP_BUFFER temporary;
+
+		// checking for non read byes on decrypted buffer
+		// moving the stored buffer to the temporary one
+		if(m_lpInputDecryptedBuffer.size() != 0)
+			temporary.write(m_lpInputDecryptedBuffer.read_peek(), m_lpInputDecryptedBuffer.size());
+
+		// adding the readable memory from the input buffer
+		auto readableInput = buffer_size(m_lpInputBuffer);
+		if(readableInput > temporary.size())
+		{
+			const auto readPoint = (const char*) buffer_read_peek(m_lpInputBuffer);
+			temporary.write(readPoint + temporary.size(), readableInput - temporary.size());
+		}
+
+		if(temporary.size() == 0)
+			return 0;
+
+		// decrypting only non decrypted chunk of memory
+		if (cipher_.activated())
+		{
+			const auto decryptPoint = ((const char*)temporary.read_peek()) + m_lpInputDecryptedBuffer.size();
+			cipher_.Decrypt((void*)(decryptPoint), readableInput - m_lpInputDecryptedBuffer.size());
+		}
+
+		auto processingPoint = (const char*) temporary.read_peek();
+		auto processingRemainSize = temporary.size();
+		auto processingTotalSize = 0;
+
+		int iBytesProceed = 0;
+
+		// false  퓔 摸 phase 侮 譴퓐 母 關 磯!
+		while (processingRemainSize > 0 && !m_pInputProcessor->Process(this, (const void*)processingPoint, processingRemainSize, iBytesProceed))
+		{
+			processingPoint += iBytesProceed;
+			processingTotalSize += iBytesProceed;
+			processingRemainSize -= iBytesProceed;
+			iBytesProceed = 0;
+		}
+
+		processingPoint += iBytesProceed;
+		processingTotalSize += iBytesProceed;
+		processingRemainSize -= iBytesProceed;
+
+		// applying result on input buffer
+		buffer_read_proceed(m_lpInputBuffer, processingTotalSize);
+
+		// registering remaining unprocessed (but decrypted) bytes
+		m_lpInputDecryptedBuffer.reset();
+		if(processingTotalSize < temporary.size()){
+			const auto storingPoint = ((const char*) temporary.read_peek()) + processingTotalSize;
+			m_lpInputDecryptedBuffer.write(storingPoint, temporary.size() - processingTotalSize);
+		}
+	}
+#else
+	else if (!m_bEncrypted)
+	{
+		int iBytesProceed = 0;
+
+		// false  퓔 摸 phase 侮 譴퓐 母 關 磯!
+		while (!m_pInputProcessor->Process(this, buffer_read_peek(m_lpInputBuffer), buffer_size(m_lpInputBuffer), iBytesProceed))
+		{
+			buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
+			iBytesProceed = 0;
+		}
+
+		buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
+	}
+	else
+	{
+		int iSizeBuffer = buffer_size(m_lpInputBuffer);
+
+		// 8트 罐 처磯. 8트  玖 蔘 호화 肪 호화
+		//   퓐 짤 처歐 磯.
+		if (iSizeBuffer & 7) // & 7 % 8 . 2 쩌 
+			iSizeBuffer -= iSizeBuffer & 7;
+
+		if (iSizeBuffer > 0)
+		{
+			TEMP_BUFFER tempbuf;
+			LPBUFFER lpBufferDecrypt = tempbuf.getptr();
+			buffer_adjust_size(lpBufferDecrypt, iSizeBuffer);
+
+			int iSizeAfter = TEA_Decrypt((DWORD*)buffer_write_peek(lpBufferDecrypt),
+				(DWORD*)buffer_read_peek(m_lpInputBuffer),
+				GetDecryptionKey(),
+				iSizeBuffer);
+
+			buffer_write_proceed(lpBufferDecrypt, iSizeAfter);
+
+			int iBytesProceed = 0;
+
+			// false  퓔 摸 phase 侮 譴퓐 母 關 磯!
+			while (!m_pInputProcessor->Process(this, buffer_read_peek(lpBufferDecrypt), buffer_size(lpBufferDecrypt), iBytesProceed))
+			{
+				if (iBytesProceed > iSizeBuffer)
+				{
+					buffer_read_proceed(m_lpInputBuffer, iSizeBuffer);
+					iSizeBuffer = 0;
+					iBytesProceed = 0;
+					break;
+				}
+
+				buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
+				iSizeBuffer -= iBytesProceed;
+
+				buffer_read_proceed(lpBufferDecrypt, iBytesProceed);
+				iBytesProceed = 0;
+			}
+
+			buffer_read_proceed(m_lpInputBuffer, iBytesProceed);
+		}
+	}
+#endif
+
+	return (bytes_read);
+}
+
+int DESC::ProcessOutput()
+{
+	if (buffer_size(m_lpOutputBuffer) <= 0)
+		return 0;
+
+	int buffer_left = fdwatch_get_buffer_size(m_lpFdw, m_sock);
+
+	if (buffer_left <= 0)
+		return 0;
+
+	int bytes_to_write = MIN(buffer_left, buffer_size(m_lpOutputBuffer));
+
+	if (bytes_to_write == 0)
+		return 0;
+
+	int result = socket_write(m_sock, (const char*)buffer_read_peek(m_lpOutputBuffer), bytes_to_write);
+
+	if (result == 0)
+	{
+		//sys_log(0, "%d bytes written to %s first %u", bytes_to_write, GetHostName(), *(BYTE *) buffer_read_peek(m_lpOutputBuffer));
+		//Log("%d bytes written", bytes_to_write);
+		max_bytes_written = MAX(bytes_to_write, max_bytes_written);
+
+		total_bytes_written += bytes_to_write;
+		current_bytes_written += bytes_to_write;
+
+		buffer_read_proceed(m_lpOutputBuffer, bytes_to_write);
+
+		if (buffer_size(m_lpOutputBuffer) != 0)
+			fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_WRITE, true);
+	}
+
+	return (result);
+}
+
+void DESC::BufferedPacket(const void* c_pvData, int iSize)
+{
+	if (m_iPhase == PHASE_CLOSE)
+		return;
+
+	if (!m_lpBufferedOutputBuffer)
+		m_lpBufferedOutputBuffer = buffer_new(MAX(1024, iSize));
+
+	buffer_write(m_lpBufferedOutputBuffer, c_pvData, iSize);
+}
+
+void DESC::Packet(const void* c_pvData, int iSize)
+{
+	assert(iSize > 0);
+
+	if (m_iPhase == PHASE_CLOSE) //  쨍  苛쨈.
+		return;
+
+	if (m_stRelayName.length() != 0)
+	{
+		// Relay 킷 호화 苛쨈.
+		TPacketGGRelay p;
+
+		p.bHeader = HEADER_GG_RELAY;
+		strlcpy(p.szName, m_stRelayName.c_str(), sizeof(p.szName));
+		p.lSize = iSize;
+
+		if (!packet_encode(m_lpOutputBuffer, &p, sizeof(p)))
+		{
+			m_iPhase = PHASE_CLOSE;
+			return;
+		}
+
+		m_stRelayName.clear();
+
+		if (!packet_encode(m_lpOutputBuffer, c_pvData, iSize))
+		{
+			m_iPhase = PHASE_CLOSE;
+			return;
+		}
+	}
+	else
+	{
+		if (m_lpBufferedOutputBuffer)
+		{
+			buffer_write(m_lpBufferedOutputBuffer, c_pvData, iSize);
+
+			c_pvData = buffer_read_peek(m_lpBufferedOutputBuffer);
+			iSize = buffer_size(m_lpBufferedOutputBuffer);
+		}
+
+		// TRAFFIC_PROFILE
+		if (g_bTrafficProfileOn)
+			TrafficProfiler::instance().Report(TrafficProfiler::IODIR_OUTPUT, *(BYTE*)c_pvData, iSize);
+		// END_OF_TRAFFIC_PROFILER
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+		void* buf = buffer_write_peek(m_lpOutputBuffer);
+
+		if (packet_encode(m_lpOutputBuffer, c_pvData, iSize))
+		{
+			if (cipher_.activated())
+			{
+				cipher_.Encrypt(buf, iSize);
+			}
+		}
+		else
+		{
+			m_iPhase = PHASE_CLOSE;
+		}
+#else
+		if (!m_bEncrypted)
+		{
+			if (!packet_encode(m_lpOutputBuffer, c_pvData, iSize))
+			{
+				m_iPhase = PHASE_CLOSE;
+			}
+		}
+		else
+		{
+			if (buffer_has_space(m_lpOutputBuffer) < iSize + 8)
+			{
+				sys_err("desc buffer mem_size overflow. memsize(%u) write_pos(%u) iSize(%d)",
+					m_lpOutputBuffer->mem_size, m_lpOutputBuffer->write_point_pos, iSize);
+
+				m_iPhase = PHASE_CLOSE;
+			}
+			else
+			{
+				// 호화 却   크綬 확磯.
+				/* buffer_adjust_size(m_lpOutputBuffer, iSize + 8); */
+				DWORD* pdwWritePoint = (DWORD*)buffer_write_peek(m_lpOutputBuffer);
+
+				if (packet_encode(m_lpOutputBuffer, c_pvData, iSize))
+				{
+					int iSize2 = TEA_Encrypt(pdwWritePoint, pdwWritePoint, GetEncryptionKey(), iSize);
+
+					if (iSize2 > iSize)
+						buffer_write_proceed(m_lpOutputBuffer, iSize2 - iSize);
+				}
+			}
+		}
+#endif
+
+		SAFE_BUFFER_DELETE(m_lpBufferedOutputBuffer);
+	}
+
+	//sys_log(0, "%d bytes written (first byte %d)", iSize, *(BYTE *) c_pvData);
+	if (m_iPhase != PHASE_CLOSE)
+		fdwatch_add_fd(m_lpFdw, m_sock, this, FDW_WRITE, true);
+}
+
+void DESC::LargePacket(const void* c_pvData, int iSize)
+{
+	buffer_adjust_size(m_lpOutputBuffer, iSize);
+	sys_log(0, "LargePacket Size %d", iSize, buffer_size(m_lpOutputBuffer));
+
+	Packet(c_pvData, iSize);
+}
+
+void DESC::SetPhase(int _phase)
+{
+	m_iPhase = _phase;
+
+	TPacketGCPhase pack;
+	pack.header = HEADER_GC_PHASE;
+	pack.phase = _phase;
+	Packet(&pack, sizeof(TPacketGCPhase));
+
+	switch (m_iPhase)
+	{
+	case PHASE_CLOSE:
+		// 聘 캐姑 퓔庸 
+		// CMessengerManager::instance().Logout(GetAccountTable().login);
+		m_pInputProcessor = &m_inputClose;
+		break;
+
+	case PHASE_HANDSHAKE:
+		m_pInputProcessor = &m_inputHandshake;
+		break;
+
+	case PHASE_SELECT:
+		// 聘 캐姑 퓔庸 
+		// CMessengerManager::instance().Logout(GetAccountTable().login); // 풩 break 활
+	case PHASE_LOGIN:
+	case PHASE_LOADING:
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+		m_bEncrypted = true;
+#endif
+		m_pInputProcessor = &m_inputLogin;
+		break;
+
+	case PHASE_GAME:
+	case PHASE_DEAD:
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+		m_bEncrypted = true;
+#endif
+		m_pInputProcessor = &m_inputMain;
+		break;
+
+	case PHASE_AUTH:
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+		m_bEncrypted = true;
+#endif
+		m_pInputProcessor = &m_inputAuth;
+		sys_log(0, "AUTH_PHASE %p", this);
+		break;
+	}
+}
+
+void DESC::BindAccountTable(TAccountTable* pAccountTable)
+{
+	assert(pAccountTable != NULL);
+	thecore_memcpy(&m_accountTable, pAccountTable, sizeof(TAccountTable));
+	DESC_MANAGER::instance().ConnectAccount(m_accountTable.login, this);
+}
+
+void DESC::UDPGrant(const struct sockaddr_in& c_rSockAddr)
+{
+	m_UDPSockAddr = c_rSockAddr;
+
+	TPacketGCBindUDP pack;
+
+	pack.header = HEADER_GC_BINDUDP;
+	pack.addr = m_UDPSockAddr.sin_addr.s_addr;
+	pack.port = m_UDPSockAddr.sin_port;
+
+	Packet(&pack, sizeof(TPacketGCBindUDP));
+}
+
+void DESC::Log(const char* format, ...)
+{
+	if (!m_pLogFile)
+		return;
+
+	va_list args;
+
+	time_t ct = get_global_time();
+	struct tm tm;
+#if defined(_WIN32) || defined(_WIN64)
+	localtime_s(&tm, &ct);
+#else
+	localtime_r(&ct, &tm);
+#endif
+
+	fprintf(m_pLogFile,
+		"%02d %02d %02d:%02d:%02d | ",
+		tm.tm_mon + 1,
+		tm.tm_mday,
+		tm.tm_hour,
+		tm.tm_min,
+		tm.tm_sec);
+
+	va_start(args, format);
+	vfprintf(m_pLogFile, format, args);
+	va_end(args);
+
+	fputs("\n", m_pLogFile);
+
+	fflush(m_pLogFile);
+}
+
+void DESC::StartHandshake(DWORD _handshake)
+{
+	// Handshake
+	m_dwHandshake = _handshake;
+
+	SendHandshake(get_dword_time(), 0);
+
+	m_iHandshakeRetry = 0;
+}
+
+void DESC::SendHandshake(DWORD dwCurTime, long lNewDelta)
+{
+	TPacketGCHandshake pack;
+
+	pack.bHeader = HEADER_GC_HANDSHAKE;
+	pack.dwHandshake = m_dwHandshake;
+	pack.dwTime = dwCurTime;
+	pack.lDelta = lNewDelta;
+
+	Packet(&pack, sizeof(TPacketGCHandshake));
+
+	m_dwHandshakeSentTime = dwCurTime;
+	m_bHandshaking = true;
+}
+
+bool DESC::HandshakeProcess(DWORD dwTime, long lDelta, bool bInfiniteRetry)
+{
+	DWORD dwCurTime = get_dword_time();
+
+	if (lDelta < 0)
+	{
+		sys_err("Desc::HandshakeProcess : value error (lDelta %d, ip %s)", lDelta, m_stHost.c_str());
+		return false;
+	}
+
+	int bias = (int)(dwCurTime - (dwTime + lDelta));
+
+	if (bias >= 0 && bias <= 50)
+	{
+		if (bInfiniteRetry)
+		{
+			BYTE bHeader = HEADER_GC_TIME_SYNC;
+			Packet(&bHeader, sizeof(BYTE));
+		}
+
+		if (GetCharacter())
+			sys_log(0, "Handshake: client_time %u server_time %u name: %s", m_dwClientTime, dwCurTime, GetCharacter()->GetName());
+		else
+			sys_log(0, "Handshake: client_time %u server_time %u", m_dwClientTime, dwCurTime, lDelta);
+
+		m_dwClientTime = dwCurTime;
+		m_bHandshaking = false;
+		return true;
+	}
+
+	long lNewDelta = (long)(dwCurTime - dwTime) / 2;
+
+	if (lNewDelta < 0)
+	{
+		sys_log(0, "Handshake: lower than zero %d", lNewDelta);
+		lNewDelta = (dwCurTime - m_dwHandshakeSentTime) / 2;
+	}
+
+	sys_log(1, "Handshake: ServerTime %u dwTime %u lDelta %d SentTime %u lNewDelta %d", dwCurTime, dwTime, lDelta, m_dwHandshakeSentTime, lNewDelta);
+
+	if (!bInfiniteRetry)
+		if (++m_iHandshakeRetry > HANDSHAKE_RETRY_LIMIT)
+		{
+			sys_err("handshake retry limit reached! (limit %d character %s)",
+				HANDSHAKE_RETRY_LIMIT, GetCharacter() ? GetCharacter()->GetName() : "!NO CHARACTER!");
+			SetPhase(PHASE_CLOSE);
+			return false;
+		}
+
+	SendHandshake(dwCurTime, lNewDelta);
+	return false;
+}
+
+bool DESC::IsHandshaking()
+{
+	return m_bHandshaking;
+}
+
+DWORD DESC::GetClientTime()
+{
+	return m_dwClientTime;
+}
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+void DESC::SendKeyAgreement()
+{
+	TPacketKeyAgreement packet;
+
+	size_t data_length = TPacketKeyAgreement::MAX_DATA_LEN;
+	size_t agreed_length = cipher_.Prepare(packet.data, &data_length);
+	if (agreed_length == 0)
+	{
+		// Initialization failure
+		SetPhase(PHASE_CLOSE);
+		return;
+	}
+	assert(data_length <= TPacketKeyAgreement::MAX_DATA_LEN);
+
+	packet.bHeader = HEADER_GC_KEY_AGREEMENT;
+	packet.wAgreedLength = (WORD)agreed_length;
+	packet.wDataLength = (WORD)data_length;
+
+	Packet(&packet, sizeof(packet));
+}
+
+void DESC::SendKeyAgreementCompleted()
+{
+	TPacketKeyAgreementCompleted packet;
+
+	packet.bHeader = HEADER_GC_KEY_AGREEMENT_COMPLETED;
+
+	Packet(&packet, sizeof(packet));
+}
+
+bool DESC::FinishHandshake(size_t agreed_length, const void* buffer, size_t length)
+{
+	return cipher_.Activate(false, agreed_length, buffer, length);
+}
+
+bool DESC::IsCipherPrepared()
+{
+	return cipher_.IsKeyPrepared();
+}
+#endif
+
+void DESC::SetRelay(const char* c_pszName)
+{
+	m_stRelayName = c_pszName;
+}
+
+void DESC::BindCharacter(LPCHARACTER ch)
+{
+	m_lpCharacter = ch;
+}
+
+void DESC::FlushOutput()
+{
+	if (m_sock == INVALID_SOCKET)
+		return;
+
+	if (buffer_size(m_lpOutputBuffer) <= 0)
+		return;
+
+	struct timeval sleep_tv, now_tv, start_tv;
+	int event_triggered = false;
+
+	gettimeofday(&start_tv, NULL);
+
+	socket_block(m_sock);
+	sys_log(0, "FLUSH START %d", buffer_size(m_lpOutputBuffer));
+
+	while (buffer_size(m_lpOutputBuffer) > 0)
+	{
+		gettimeofday(&now_tv, NULL);
+
+		int iSecondsPassed = now_tv.tv_sec - start_tv.tv_sec;
+
+		if (iSecondsPassed > 10)
+		{
+			if (!event_triggered || iSecondsPassed > 20)
+			{
+				SetPhase(PHASE_CLOSE);
+				break;
+			}
+		}
+
+		sleep_tv.tv_sec = 0;
+		sleep_tv.tv_usec = 10000;
+
+		int num_events = fdwatch(m_lpFdw, &sleep_tv);
+
+		if (num_events < 0)
+		{
+			sys_err("num_events < 0 : %d", num_events);
+			break;
+		}
+
+		int event_idx;
+
+		for (event_idx = 0; event_idx < num_events; ++event_idx)
+		{
+			LPDESC d2 = (LPDESC)fdwatch_get_client_data(m_lpFdw, event_idx);
+
+			if (d2 != this)
+				continue;
+
+			switch (fdwatch_check_event(m_lpFdw, m_sock, event_idx))
+			{
+			case FDW_WRITE:
+				event_triggered = true;
+
+				if (ProcessOutput() < 0)
+				{
+					sys_err("Cannot flush output buffer");
+					SetPhase(PHASE_CLOSE);
+				}
+				break;
+
+			case FDW_EOF:
+				SetPhase(PHASE_CLOSE);
+				break;
+			}
+		}
+
+		if (IsPhase(PHASE_CLOSE))
+			break;
+	}
+
+	if (buffer_size(m_lpOutputBuffer) == 0)
+		sys_log(0, "FLUSH SUCCESS");
+	else
+		sys_log(0, "FLUSH FAIL");
+
+	usleep(250000);
+}
+
+EVENTFUNC(disconnect_event)
+{
+	DESC::desc_event_info* info = dynamic_cast<DESC::desc_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("disconnect_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPDESC d = info->desc;
+
+	d->m_pkDisconnectEvent = NULL;
+	d->SetPhase(PHASE_CLOSE);
+	return 0;
+}
+
+bool DESC::DelayedDisconnect(int iSec)
+{
+	if (m_pkDisconnectEvent != NULL)
+		return false;
+
+	desc_event_info* info = AllocEventInfo<desc_event_info>();
+	info->desc = this;
+
+	m_pkDisconnectEvent = event_create(disconnect_event, info, PASSES_PER_SEC(iSec));
+	return true;
+}
+
+void DESC::DisconnectOfSameLogin()
+{
+	if (GetCharacter())
+	{
+		if (m_pkDisconnectEvent)
+			return;
+
+		GetCharacter()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("摸 퓨沽 慣 臼   爛求."));
+		DelayedDisconnect(5);
+	}
+	else
+	{
+		SetPhase(PHASE_CLOSE);
+	}
+}
+
+void DESC::SetAdminMode()
+{
+	m_bAdminMode = true;
+}
+
+bool DESC::IsAdminMode()
+{
+	return m_bAdminMode;
+}
+
+#if defined(__SEND_SEQUENCE__)
+BYTE DESC::GetSequence()
+{
+	return gc_abSequence[m_iCurrentSequence];
+}
+
+void DESC::SetNextSequence()
+{
+	if (++m_iCurrentSequence == SEQUENCE_MAX_NUM)
+		m_iCurrentSequence = 0;
+}
+#endif
+
+void DESC::SendLoginSuccessPacket()
+{
+	TAccountTable& rTable = GetAccountTable();
+
+	TPacketGCLoginSuccess p;
+
+	p.bHeader = HEADER_GC_LOGIN_SUCCESS_NEWSLOT;
+
+	p.handle = GetHandle();
+	p.random_key = DESC_MANAGER::instance().MakeRandomKey(GetHandle()); // FOR MARK
+	thecore_memcpy(p.players, rTable.players, sizeof(rTable.players));
+
+	for (int i = 0; i < PLAYER_PER_ACCOUNT; ++i)
+	{
+#if defined(__PROXY_IP__)
+		if (!g_stProxyIP.empty())
+			rTable.players[i].lAddr = inet_addr(g_stProxyIP.c_str());
+#endif
+
+		CGuild* g = CGuildManager::instance().GetLinkedGuild(rTable.players[i].dwID);
+
+		if (g)
+		{
+			p.guild_id[i] = g->GetID();
+			strlcpy(p.guild_name[i], g->GetName(), sizeof(p.guild_name[i]));
+		}
+		else
+		{
+			p.guild_id[i] = 0;
+			p.guild_name[i][0] = '\0';
+		}
+	}
+
+	Packet(&p, sizeof(TPacketGCLoginSuccess));
+}
+
+//void DESC::SendServerStatePacket(int nIndex)
+//{
+//	TPacketGCStateCheck rp;
+//
+//	int iTotal; 
+//	int * paiEmpireUserCount;
+//	int iLocal;
+//
+//	DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
+//
+//	rp.header	= 1; 
+//	rp.key		= 0;
+//	rp.index	= nIndex;
+//
+//	if (g_bNoMoreClient) rp.state = 0;
+//	else rp.state = iTotal > g_iFullUserCount ? 3 : iTotal > g_iBusyUserCount ? 2 : 1;
+//	
+//	this->Packet(&rp, sizeof(rp));
+//	//printf("STATE_CHECK PACKET PROCESSED.\n");
+//}
+
+void DESC::SetLoginKey(DWORD dwKey)
+{
+	m_dwLoginKey = dwKey;
+}
+
+void DESC::SetLoginKey(CLoginKey* pkKey)
+{
+	m_pkLoginKey = pkKey;
+	sys_log(0, "SetLoginKey %u", m_pkLoginKey->m_dwKey);
+}
+
+DWORD DESC::GetLoginKey()
+{
+	if (m_pkLoginKey)
+		return m_pkLoginKey->m_dwKey;
+
+	return m_dwLoginKey;
+}
+
+const BYTE* GetKey()
+{
+	static bool bGenerated = false;
+	static DWORD s_adwKey[1938];
+
+	if (!bGenerated)
+	{
+		bGenerated = true;
+		DWORD seed = 1491971513;
+
+		for (UINT i = 0; i < BYTE(seed); ++i)
+		{
+			seed ^= 2148941891ul;
+			seed += 3592385981ul;
+
+			s_adwKey[i] = seed;
+		}
+	}
+
+	return (const BYTE*)s_adwKey;
+}
+
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+void DESC::SetSecurityKey(const DWORD* c_pdwKey)
+{
+	const BYTE* c_pszKey = GetKey() + 37;
+
+	thecore_memcpy(&m_adwDecryptionKey, c_pdwKey, 16);
+	TEA_Encrypt(&m_adwEncryptionKey[0], &m_adwDecryptionKey[0], (const DWORD*)c_pszKey, 16);
+
+	sys_log(0, "SetSecurityKey decrypt %u %u %u %u encrypt %u %u %u %u",
+		m_adwDecryptionKey[0], m_adwDecryptionKey[1], m_adwDecryptionKey[2], m_adwDecryptionKey[3],
+		m_adwEncryptionKey[0], m_adwEncryptionKey[1], m_adwEncryptionKey[2], m_adwEncryptionKey[3]);
+}
+#endif
+
+void DESC::AssembleCRCMagicCube(BYTE bProcPiece, BYTE bFilePiece)
+{
+	static BYTE abXORTable[32] =
+	{
+		102, 30, 0, 0, 0, 0, 0, 0,
+		188, 44, 0, 0, 0, 0, 0, 0,
+		39, 201, 0, 0, 0, 0, 0, 0,
+		43, 5, 0, 0, 0, 0, 0, 0,
+	};
+
+	bProcPiece = (bProcPiece ^ abXORTable[m_bCRCMagicCubeIdx]);
+	bFilePiece = (bFilePiece ^ abXORTable[m_bCRCMagicCubeIdx + 1]);
+
+	m_dwProcCRC |= bProcPiece << m_bCRCMagicCubeIdx;
+	m_dwFileCRC |= bFilePiece << m_bCRCMagicCubeIdx;
+
+	m_bCRCMagicCubeIdx += 8;
+
+	if (!(m_bCRCMagicCubeIdx & 31))
+	{
+		m_dwProcCRC = 0;
+		m_dwFileCRC = 0;
+		m_bCRCMagicCubeIdx = 0;
+	}
+}
+
+#if defined(__SEND_SEQUENCE__)
+void DESC::push_seq(BYTE hdr, BYTE seq)
+{
+	if (m_seq_vector.size() >= 20)
+	{
+		m_seq_vector.erase(m_seq_vector.begin());
+	}
+
+	seq_t info = { hdr, seq };
+	m_seq_vector.push_back(info);
+}
+#endif
+
+BYTE DESC::GetEmpire()
+{
+	return m_accountTable.bEmpire;
+}
+
+void DESC::ChatPacket(BYTE type, const char* format, ...)
+{
+	char chatbuf[CHAT_MAX_LEN + 1];
+	va_list args;
+
+	va_start(args, format);
+	int len = vsnprintf(chatbuf, sizeof(chatbuf), format, args);
+	va_end(args);
+
+	struct packet_chat pack_chat;
+
+	pack_chat.header = HEADER_GC_CHAT;
+	pack_chat.size = sizeof(struct packet_chat) + len;
+	pack_chat.type = type;
+	pack_chat.id = 0;
+	pack_chat.bEmpire = GetEmpire();
+
+	TEMP_BUFFER buf;
+	buf.write(&pack_chat, sizeof(struct packet_chat));
+	buf.write(chatbuf, len);
+
+	Packet(buf.read_peek(), buf.size());
+}
--- a/server/metin2/Source/Server/game/src/db.cpp
+++ b/server/metin2/Source/Server/game/src/db.cpp
@@ -1,921 +1,924 @@
-#include "stdafx.h"
-#include <sstream>
-
-#include "../../common/length.h"
-
-#include "db.h"
-
-#include "config.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "char_manager.h"
-#include "item.h"
-#include "item_manager.h"
-#include "p2p.h"
-#include "log.h"
-#include "login_data.h"
-#include "locale_service.h"
-#include "pcbang.h"
-#include "spam.h"
-#include "auth_brazil.h"
-
-extern std::string g_stBlockDate;
-
-DBManager::DBManager() : m_bIsConnect(false)
-{
-}
-
-DBManager::~DBManager()
-{
-}
-
-bool DBManager::Connect(const char* host, const int port, const char* user, const char* pwd, const char* db)
-{
-	if (m_sql.Setup(host, user, pwd, db, g_stLocale.c_str(), false, port))
-		m_bIsConnect = true;
-
-	if (!m_sql_direct.Setup(host, user, pwd, db, g_stLocale.c_str(), true, port))
-		sys_err("cannot open direct sql connection to host %s", host);
-
-	if (m_bIsConnect && !g_bAuthServer)
-	{
-		LoadDBString();
-	}
-
-	return m_bIsConnect;
-}
-
-void DBManager::Query(const char* c_pszFormat, ...)
-{
-	char szQuery[4096];
-	va_list args;
-
-	va_start(args, c_pszFormat);
-	vsnprintf(szQuery, sizeof(szQuery), c_pszFormat, args);
-	va_end(args);
-
-	m_sql.AsyncQuery(szQuery);
-}
-
-SQLMsg* DBManager::DirectQuery(const char* c_pszFormat, ...)
-{
-	char szQuery[4096];
-	va_list args;
-
-	va_start(args, c_pszFormat);
-	vsnprintf(szQuery, sizeof(szQuery), c_pszFormat, args);
-	va_end(args);
-
-	return m_sql_direct.DirectQuery(szQuery);
-}
-
-bool DBManager::IsConnected()
-{
-	return m_bIsConnect;
-}
-
-void DBManager::ReturnQuery(int iType, DWORD dwIdent, void* pvData, const char* c_pszFormat, ...)
-{
-	//sys_log(0, "ReturnQuery %s", c_pszQuery);
-	char szQuery[4096];
-	va_list args;
-
-	va_start(args, c_pszFormat);
-	vsnprintf(szQuery, sizeof(szQuery), c_pszFormat, args);
-	va_end(args);
-
-	CReturnQueryInfo* p = M2_NEW CReturnQueryInfo;
-
-	p->iQueryType = QUERY_TYPE_RETURN;
-	p->iType = iType;
-	p->dwIdent = dwIdent;
-	p->pvData = pvData;
-
-	m_sql.ReturnQuery(szQuery, p);
-}
-
-SQLMsg* DBManager::PopResult()
-{
-	SQLMsg* p;
-
-	if (m_sql.PopResult(&p))
-		return p;
-
-	return NULL;
-}
-
-void DBManager::Process()
-{
-	SQLMsg* pMsg = NULL;
-
-	while ((pMsg = PopResult()))
-	{
-		if (NULL != pMsg->pvUserData)
-		{
-			switch (reinterpret_cast<CQueryInfo*>(pMsg->pvUserData)->iQueryType)
-			{
-				case QUERY_TYPE_RETURN:
-					AnalyzeReturnQuery(pMsg);
-					break;
-
-				case QUERY_TYPE_FUNCTION:
-				{
-					CFuncQueryInfo* qi = reinterpret_cast<CFuncQueryInfo*>(pMsg->pvUserData);
-					qi->f(pMsg);
-					M2_DELETE(qi);
-				}
-				break;
-
-				case QUERY_TYPE_AFTER_FUNCTION:
-				{
-					CFuncAfterQueryInfo* qi = reinterpret_cast<CFuncAfterQueryInfo*>(pMsg->pvUserData);
-					qi->f();
-					M2_DELETE(qi);
-				}
-				break;
-			}
-		}
-
-		delete pMsg;
-	}
-}
-
-CLoginData* DBManager::GetLoginData(DWORD dwKey)
-{
-	std::map<DWORD, CLoginData*>::iterator it = m_map_pkLoginData.find(dwKey);
-
-	if (it == m_map_pkLoginData.end())
-		return NULL;
-
-	return it->second;
-}
-
-void DBManager::InsertLoginData(CLoginData* pkLD)
-{
-	m_map_pkLoginData.insert(std::make_pair(pkLD->GetKey(), pkLD));
-}
-
-void DBManager::DeleteLoginData(CLoginData* pkLD)
-{
-	std::map<DWORD, CLoginData*>::iterator it = m_map_pkLoginData.find(pkLD->GetKey());
-
-	if (it == m_map_pkLoginData.end())
-		return;
-
-	sys_log(0, "DeleteLoginData %s %p", pkLD->GetLogin(), pkLD);
-
-	M2_DELETE(it->second);
-	m_map_pkLoginData.erase(it);
-}
-
-void DBManager::SendLoginPing(const char* c_pszLogin)
-{
-	TPacketGGLoginPing ptog;
-
-	ptog.bHeader = HEADER_GG_LOGIN_PING;
-	strlcpy(ptog.szLogin, c_pszLogin, sizeof(ptog.szLogin));
-
-	if (!g_pkAuthMasterDesc) // If I am master, broadcast to others
-	{
-		P2P_MANAGER::instance().Send(&ptog, sizeof(TPacketGGLoginPing));
-	}
-	else // If I am slave send login ping to master
-	{
-		g_pkAuthMasterDesc->Packet(&ptog, sizeof(TPacketGGLoginPing));
-	}
-}
-
-void DBManager::SendAuthLogin(LPDESC d)
-{
-	const TAccountTable& r = d->GetAccountTable();
-
-	CLoginData* pkLD = GetLoginData(d->GetLoginKey());
-
-	if (!pkLD)
-		return;
-
-	TPacketGDAuthLogin ptod;
-	ptod.dwID = r.id;
-
-	trim_and_lower(r.login, ptod.szLogin, sizeof(ptod.szLogin));
-	strlcpy(ptod.szSocialID, r.social_id, sizeof(ptod.szSocialID));
-	ptod.dwLoginKey = d->GetLoginKey();
-
-	thecore_memcpy(ptod.iPremiumTimes, pkLD->GetPremiumPtr(), sizeof(ptod.iPremiumTimes));
-	thecore_memcpy(&ptod.adwClientKey, pkLD->GetClientKey(), sizeof(DWORD) * 4);
-
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	strlcpy(ptod.szCountry, r.country, sizeof(ptod.szCountry));
-#endif
-
-	db_clientdesc->DBPacket(HEADER_GD_AUTH_LOGIN, d->GetHandle(), &ptod, sizeof(TPacketGDAuthLogin));
-	sys_log(0, "SendAuthLogin %s key %u", ptod.szLogin, ptod.dwID);
-
-	SendLoginPing(r.login);
-}
-
-void DBManager::LoginPrepare(long lRemainSecs, LPDESC d, DWORD* pdwClientKey, int* paiPremiumTimes)
-{
-	const TAccountTable& r = d->GetAccountTable();
-
-	CLoginData* pkLD = M2_NEW CLoginData;
-
-	pkLD->SetKey(d->GetLoginKey());
-	pkLD->SetLogin(r.login);
-	pkLD->SetRemainSecs(lRemainSecs);
-	pkLD->SetIP(d->GetHostName());
-	pkLD->SetClientKey(pdwClientKey);
-
-	if (paiPremiumTimes)
-		pkLD->SetPremium(paiPremiumTimes);
-
-	InsertLoginData(pkLD);
-
-	SendAuthLogin(d);
-}
-
-void DBManager::AnalyzeReturnQuery(SQLMsg* pMsg)
-{
-	CReturnQueryInfo* qi = (CReturnQueryInfo*)pMsg->pvUserData;
-
-	switch (qi->iType)
-	{
-		case QID_AUTH_LOGIN:
-		{
-			TPacketCGLogin3* pinfo = (TPacketCGLogin3*)qi->pvData;
-			LPDESC d = DESC_MANAGER::instance().FindByLoginKey(qi->dwIdent);
-
-			if (!d)
-			{
-				M2_DELETE(pinfo);
-				break;
-			}
-
-			// 위치 변경 - By SeMinZ
-			d->SetLogin(pinfo->login);
-
-			sys_log(0, "QID_AUTH_LOGIN: START %u %p", qi->dwIdent, get_pointer(d));
-
-			if (pMsg->Get()->uiNumRows == 0)
-			{
-				if (true == LC_IsBrazil())
-				{
-					// 계정이 없으면 새로 만들어야 한다
-					ReturnQuery(QID_BRAZIL_CREATE_ID, qi->dwIdent, pinfo,
-						"INSERT INTO account(login, password, social_id, create_time) "
-						"VALUES('%s', password('%s'), '0000000', NOW()) ;",
-						pinfo->login, pinfo->passwd);
-
-					sys_log(0, "[AUTH_BRAZIL] : Create A new AccountID From OnGame");
-				}
-				else
-				{
-					sys_log(0, "   NOID");
-					LoginFailure(d, "NOID");
-					M2_DELETE(pinfo);
-				}
-			}
-			else
-			{
-				MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-				int col = 0;
-
-				// PASSWORD('%s'), password, securitycode, social_id, id, status
-				char szEncrytPassword[45 + 1];
-				char szPassword[45 + 1];
-				char szSocialID[SOCIAL_ID_MAX_LEN + 1];
-				char szStatus[ACCOUNT_STATUS_MAX_LEN + 1];
-				DWORD dwID = 0;
-
-				if (!row[col])
-				{
-					sys_err("error column %d", col);
-					M2_DELETE(pinfo);
-					break;
-				}
-				strlcpy(szEncrytPassword, row[col++], sizeof(szEncrytPassword));
-
-				if (!row[col])
-				{
-					sys_err("error column %d", col);
-					M2_DELETE(pinfo);
-					break;
-				}
-				strlcpy(szPassword, row[col++], sizeof(szPassword));
-
-				if (!row[col])
-				{
-					sys_err("error column %d", col);
-					M2_DELETE(pinfo);
-					break;
-				}
-				strlcpy(szSocialID, row[col++], sizeof(szSocialID));
-
-				if (!row[col])
-				{
-					sys_err("error column %d", col);
-					M2_DELETE(pinfo);
-					break;
-				}
-				str_to_number(dwID, row[col++]);
-
-				if (!row[col])
-				{
-					sys_err("error column %d", col);
-					M2_DELETE(pinfo);
-					break;
-				}
-				strlcpy(szStatus, row[col++], sizeof(szStatus));
-
-				BYTE bNotAvail = 0;
-				str_to_number(bNotAvail, row[col++]);
-
-				int aiPremiumTimes[PREMIUM_MAX_NUM];
-				memset(&aiPremiumTimes, 0, sizeof(aiPremiumTimes));
-
-				char szCreateDate[256] = "00000000";
-
-				if (!g_iUseLocale)
-				{
-					str_to_number(aiPremiumTimes[PREMIUM_EXP], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_ITEM], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_SAFEBOX], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_AUTOLOOT], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_FISH_MIND], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_MARRIAGE_FAST], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_GOLD], row[col++]);
-#if defined(__CONQUEROR_LEVEL__)
-					str_to_number(aiPremiumTimes[PREMIUM_SUNGMA], row[col++]);
-#endif
-				}
-				else
-				{
-					str_to_number(aiPremiumTimes[PREMIUM_EXP], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_ITEM], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_SAFEBOX], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_AUTOLOOT], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_FISH_MIND], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_MARRIAGE_FAST], row[col++]);
-					str_to_number(aiPremiumTimes[PREMIUM_GOLD], row[col++]);
-#if defined(__CONQUEROR_LEVEL__)
-					str_to_number(aiPremiumTimes[PREMIUM_SUNGMA], row[col++]);
-#endif
-
-					if (LC_IsEurope() || test_server)
-					{
-						long retValue = 0;
-						str_to_number(retValue, row[col]);
-
-						time_t create_time = retValue;
-						struct tm* tm1;
-						tm1 = localtime(&create_time);
-						strftime(szCreateDate, 255, "%Y%m%d", tm1);
-
-						sys_log(0, "Create_Time %d %s", retValue, szCreateDate);
-						sys_log(0, "Block Time %d ", strncmp(szCreateDate, g_stBlockDate.c_str(), 8));
-					}
-				}
-
-				int nPasswordDiff = strcmp(szEncrytPassword, szPassword);
-
-				if (true == LC_IsBrazil())
-				{
-					nPasswordDiff = 0; // 브라질 버전에서는 비밀번호 체크를 하지 않는다.
-				}
-
-				if (nPasswordDiff)
-				{
-					LoginFailure(d, "WRONGPWD");
-					sys_log(0, "   WRONGPWD");
-					M2_DELETE(pinfo);
-				}
-				else if (bNotAvail)
-				{
-					LoginFailure(d, "NOTAVAIL");
-					sys_log(0, "   NOTAVAIL");
-					M2_DELETE(pinfo);
-				}
-				else if (DESC_MANAGER::instance().FindByLoginName(pinfo->login))
-				{
-					LoginFailure(d, "ALREADY");
-					sys_log(0, "   ALREADY");
-					M2_DELETE(pinfo);
-				}
-				else if (strcmp(szStatus, "OK"))
-				{
-					LoginFailure(d, szStatus);
-					sys_log(0, "   STATUS: %s", szStatus);
-					M2_DELETE(pinfo);
-				}
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-				else if (!LocaleService_GetLocale(pinfo->country))
-				{
-					LoginFailure(d, "COUNTRYERR");
-					sys_log(0, "   COUNTRYERR");
-					M2_DELETE(pinfo);
-				}
-#endif
-				else
-				{
-					if (LC_IsEurope())
-					{
-						// stBlockData >= 0 == 날짜가 BlockDate 보다 미래
-						if (strncmp(szCreateDate, g_stBlockDate.c_str(), 8) >= 0)
-						{
-							LoginFailure(d, "BLKLOGIN");
-							sys_log(0, "   BLKLOGIN");
-							M2_DELETE(pinfo);
-							break;
-						}
-
-						char szQuery[1024];
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-						snprintf(szQuery, sizeof(szQuery), "UPDATE `account` SET `last_play` = NOW(), `country` = '%s' WHERE `id` = %u",
-							LocaleService_GetCountry(pinfo->country), dwID);
-#else
-						snprintf(szQuery, sizeof(szQuery), "UPDATE `account` SET `last_play` = NOW() WHERE `id` = %u", dwID);
-#endif
-						std::unique_ptr<SQLMsg> msg(DBManager::instance().DirectQuery(szQuery));
-					}
-
-					TAccountTable& r = d->GetAccountTable();
-
-					r.id = dwID;
-					trim_and_lower(pinfo->login, r.login, sizeof(r.login));
-					strlcpy(r.passwd, pinfo->passwd, sizeof(r.passwd));
-					strlcpy(r.social_id, szSocialID, sizeof(r.social_id));
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-					strlcpy(r.country, pinfo->country, sizeof(r.country));
-#endif
-
-					DESC_MANAGER::instance().ConnectAccount(r.login, d);
-
-					{
-						LoginPrepare(0, d, pinfo->adwClientKey, aiPremiumTimes);
-						// By SeMinZ
-						M2_DELETE(pinfo);
-						break;
-					}
-
-					sys_log(0, "QID_AUTH_LOGIN: SUCCESS %s", pinfo->login);
-				}
-			}
-		}
-		break;
-
-		case QID_SAFEBOX_SIZE:
-		{
-			LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(qi->dwIdent);
-
-			if (ch)
-			{
-				if (pMsg->Get()->uiNumRows > 0)
-				{
-					MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-					int size = 0;
-					str_to_number(size, row[0]);
-					ch->SetSafeboxSize(SAFEBOX_PAGE_SIZE * size);
-				}
-			}
-		}
-		break;
-
-		case QID_DB_STRING:
-		{
-			m_map_dbstring.clear();
-			m_vec_GreetMessage.clear();
-
-			for (uint i = 0; i < pMsg->Get()->uiNumRows; ++i)
-			{
-				MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-				//ch->SetSafeboxSize(SAFEBOX_PAGE_SIZE * atoi(row[0]));
-				if (row[0] && row[1])
-				{
-					m_map_dbstring.insert(make_pair(std::string(row[0]), std::string(row[1])));
-					sys_log(0, "DBSTR '%s' '%s'", row[0], row[1]);
-				}
-			}
-			if (m_map_dbstring.find("GREET") != m_map_dbstring.end())
-			{
-				std::istringstream is(m_map_dbstring["GREET"]);
-				while (!is.eof())
-				{
-					std::string str;
-					getline(is, str);
-					m_vec_GreetMessage.push_back(str);
-				}
-			}
-		}
-		break;
-
-		case QID_LOTTO:
-		{
-			LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(qi->dwIdent);
-			DWORD* pdw = (DWORD*)qi->pvData;
-
-			if (ch)
-			{
-				if (pMsg->Get()->uiAffectedRows == 0 || pMsg->Get()->uiAffectedRows == (uint32_t)-1)
-				{
-					sys_log(0, "GIVE LOTTO FAIL TO pid %u", ch->GetPlayerID());
-				}
-				else
-				{
-					LPITEM pkItem = ch->AutoGiveItem(pdw[0], pdw[1]);
-
-					if (pkItem)
-					{
-						sys_log(0, "GIVE LOTTO SUCCESS TO %s (pid %u)", ch->GetName(), qi->dwIdent);
-						//ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("아이템 획득: %s", LC_ITEM(pkItem->GetVnum())));
-
-						pkItem->SetSocket(0, pMsg->Get()->uiInsertID);
-						pkItem->SetSocket(1, pdw[2]);
-					}
-					else
-						sys_log(0, "GIVE LOTTO FAIL2 TO pid %u", ch->GetPlayerID());
-				}
-			}
-
-			M2_DELETE_ARRAY(pdw);
-		}
-		break;
-
-		case QID_HIGHSCORE_REGISTER:
-		{
-			THighscoreRegisterQueryInfo* info = (THighscoreRegisterQueryInfo*)qi->pvData;
-			bool bQuery = true;
-
-			if (pMsg->Get()->uiNumRows)
-			{
-				MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-
-				if (row && row[0])
-				{
-					int iCur = 0;
-					str_to_number(iCur, row[0]);
-
-					if ((info->bOrder && iCur >= info->iValue) ||
-						(!info->bOrder && iCur <= info->iValue))
-						bQuery = false;
-				}
-			}
-
-			if (bQuery)
-				Query("REPLACE INTO highscore%s VALUES('%s', %u, %d)",
-					get_table_postfix(), info->szBoard, info->dwPID, info->iValue);
-
-			M2_DELETE(info);
-		}
-		break;
-
-		case QID_HIGHSCORE_SHOW:
-		{
-		}
-		break;
-
-		// BLOCK_CHAT
-		case QID_BLOCK_CHAT_LIST:
-		{
-			LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(qi->dwIdent);
-
-			if (ch == NULL)
-				break;
-			if (pMsg->Get()->uiNumRows)
-			{
-				MYSQL_ROW row;
-				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, "%s %s sec", row[0], row[1]);
-				}
-			}
-			else
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, "No one currently blocked.");
-			}
-		}
-		break;
-		// END_OF_BLOCK_CHAT
-
-		// PCBANG_IP_LIST
-		case QID_PCBANG_IP_LIST_CHECK:
-		{
-			const std::string PCBANG_IP_TABLE_NAME("pcbang_ip");
-
-			if (pMsg->Get()->uiNumRows > 0)
-			{
-				MYSQL_ROW row;
-				bool isFinded = false;
-
-				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-				{
-					const char* c_szName = row[0];
-					const char* c_szUpdateTime = row[12];
-
-					if (test_server)
-						sys_log(0, "%s:%s", c_szName, c_szUpdateTime);
-
-					if (PCBANG_IP_TABLE_NAME == c_szName)
-					{
-						isFinded = true;
-
-						static std::string s_stLastTime;
-						if (s_stLastTime != c_szUpdateTime)
-						{
-							s_stLastTime = c_szUpdateTime;
-							sys_log(0, "'%s' mysql table is UPDATED(%s)", PCBANG_IP_TABLE_NAME.c_str(), c_szUpdateTime);
-							ReturnQuery(QID_PCBANG_IP_LIST_SELECT, 0, NULL, "SELECT pcbang_id, ip FROM %s;", PCBANG_IP_TABLE_NAME.c_str());
-						}
-						else
-						{
-							sys_log(0, "'%s' mysql table is NOT updated(%s)", PCBANG_IP_TABLE_NAME.c_str(), c_szUpdateTime);
-						}
-						break;
-					}
-				}
-
-				if (!isFinded)
-				{
-					sys_err(0, "'%s' mysql table CANNOT FIND", PCBANG_IP_TABLE_NAME.c_str());
-				}
-			}
-			else if (test_server)
-			{
-				sys_err(0, "'%s' mysql table is NOT EXIST", PCBANG_IP_TABLE_NAME.c_str());
-			}
-		}
-		break;
-
-		case QID_PCBANG_IP_LIST_SELECT:
-		{
-			if (pMsg->Get()->uiNumRows > 0)
-			{
-				MYSQL_ROW row;
-
-				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-				{
-					CPCBangManager::instance().InsertIP(row[0], row[1]);
-				}
-			}
-			else if (test_server)
-			{
-				sys_log(0, "PCBANG_IP_LIST is EMPTY");
-			}
-		}
-		break;
-
-		// END_OF_PCBANG_IP_LIST
-
-		case QID_BRAZIL_CREATE_ID:
-		{
-			TPacketCGLogin3* pinfo = (TPacketCGLogin3*)qi->pvData;
-
-			if (pMsg->Get()->uiAffectedRows == 0 || pMsg->Get()->uiAffectedRows == (uint32_t)-1)
-			{
-				LPDESC d = DESC_MANAGER::instance().FindByLoginKey(qi->dwIdent);
-				sys_log(0, "[AUTH_BRAZIL]   NOID");
-				sys_log(0, "[AUTH_BRAZIL] : Failed to create a new account %s", pinfo->login);
-				LoginFailure(d, "NOID");
-				M2_DELETE(pinfo);
-			}
-			else
-			{
-				sys_log(0, "[AUTH_BRAZIL] : Succeed to create a new account %s", pinfo->login);
-
-				ReturnQuery(QID_AUTH_LOGIN, qi->dwIdent, pinfo,
-					"SELECT CONCAT('*', UPPER(SHA1(UNHEX(SHA1('%s'))))), `password`, `securitycode`, `social_id`, `id`, `status`"
-					", `availDt` - NOW() > 0"
-					", UNIX_TIMESTAMP(`silver_expire`)"
-					", UNIX_TIMESTAMP(`gold_expire`)"
-					", UNIX_TIMESTAMP(`safebox_expire`)"
-					", UNIX_TIMESTAMP(`autoloot_expire`)"
-					", UNIX_TIMESTAMP(`fish_mind_expire`)"
-					", UNIX_TIMESTAMP(`marriage_fast_expire`)"
-					", UNIX_TIMESTAMP(`money_drop_rate_expire`)"
-#if defined(__CONQUEROR_LEVEL__)
-					", UNIX_TIMESTAMP(`sungma_expire`)"
-#endif
-					", UNIX_TIMESTAMP(`create_time`)"
-					" FROM account WHERE `login` = '%s'",
-					pinfo->passwd, pinfo->login);
-			}
-		}
-		break;
-
-		default:
-			sys_err("FATAL ERROR!!! Unhandled return query id %d", qi->iType);
-			break;
-	}
-
-	M2_DELETE(qi);
-}
-
-void DBManager::LoadDBString()
-{
-	ReturnQuery(QID_DB_STRING, 0, NULL, "SELECT `name`, `text` FROM `string%s`", get_table_postfix());
-}
-
-const std::string& DBManager::GetDBString(const std::string& key)
-{
-	static std::string null_str = "";
-	auto it = m_map_dbstring.find(key);
-	if (it == m_map_dbstring.end())
-		return null_str;
-	return it->second;
-}
-
-const std::vector<std::string>& DBManager::GetGreetMessage()
-{
-	return m_vec_GreetMessage;
-}
-
-void DBManager::SendMoneyLog(BYTE type, DWORD vnum, int gold
-#if defined(__CHEQUE_SYSTEM__)
-	, int cheque
-#endif
-)
-{
-	if (!gold)
-		return;
-
-	TPacketMoneyLog p;
-	p.type = type;
-	p.vnum = vnum;
-	p.gold = gold;
-#if defined(__CHEQUE_SYSTEM__)
-	p.cheque = cheque;
-#endif
-	db_clientdesc->DBPacket(HEADER_GD_MONEY_LOG, 0, &p, sizeof(p));
-}
-
-void DBManager::RequestBlockException(const char* login, int cmd)
-{
-	TPacketBlockException packet;
-
-	packet.cmd = cmd;
-	strlcpy(packet.login, login, sizeof(packet.login));
-	db_clientdesc->DBPacket(HEADER_GD_BLOCK_EXCEPTION, 0, &packet, sizeof(packet));
-}
-
-size_t DBManager::EscapeString(char* dst, size_t dstSize, const char* src, size_t srcSize)
-{
-	return m_sql_direct.EscapeString(dst, dstSize, src, srcSize);
-}
-
-//
-// Common SQL
-//
-AccountDB::AccountDB() :
-	m_IsConnect(false)
-{
-}
-
-bool AccountDB::IsConnected()
-{
-	return m_IsConnect;
-}
-
-bool AccountDB::Connect(const char* host, const int port, const char* user, const char* pwd, const char* db)
-{
-	m_IsConnect = m_sql_direct.Setup(host, user, pwd, db, "", true, port);
-
-	if (false == m_IsConnect)
-	{
-		fprintf(stderr, "cannot open direct sql connection to host: %s user: %s db: %s\n", host, user, db);
-		return false;
-	}
-
-	return m_IsConnect;
-}
-
-bool AccountDB::ConnectAsync(const char* host, const int port, const char* user, const char* pwd, const char* db, const char* locale)
-{
-	m_sql.Setup(host, user, pwd, db, locale, false, port);
-	return true;
-}
-
-void AccountDB::SetLocale(const std::string& stLocale)
-{
-	m_sql_direct.SetLocale(stLocale);
-	m_sql_direct.QueryLocaleSet();
-}
-
-SQLMsg* AccountDB::DirectQuery(const char* query)
-{
-	return m_sql_direct.DirectQuery(query);
-}
-
-void AccountDB::AsyncQuery(const char* query)
-{
-	m_sql.AsyncQuery(query);
-}
-
-void AccountDB::ReturnQuery(int iType, DWORD dwIdent, void* pvData, const char* c_pszFormat, ...)
-{
-	char szQuery[4096];
-	va_list args;
-
-	va_start(args, c_pszFormat);
-	vsnprintf(szQuery, sizeof(szQuery), c_pszFormat, args);
-	va_end(args);
-
-	CReturnQueryInfo* p = M2_NEW CReturnQueryInfo;
-
-	p->iQueryType = QUERY_TYPE_RETURN;
-	p->iType = iType;
-	p->dwIdent = dwIdent;
-	p->pvData = pvData;
-
-	m_sql.ReturnQuery(szQuery, p);
-}
-
-SQLMsg* AccountDB::PopResult()
-{
-	SQLMsg* p;
-
-	if (m_sql.PopResult(&p))
-		return p;
-
-	return NULL;
-}
-
-void AccountDB::Process()
-{
-	SQLMsg* pMsg = NULL;
-
-	while ((pMsg = PopResult()))
-	{
-		CQueryInfo* qi = (CQueryInfo*)pMsg->pvUserData;
-
-		switch (qi->iQueryType)
-		{
-			case QUERY_TYPE_RETURN:
-				AnalyzeReturnQuery(pMsg);
-				break;
-		}
-	}
-
-	delete pMsg;
-}
-
-extern unsigned int g_uiSpamReloadCycle;
-
-enum EAccountQID
-{
-	QID_SPAM_DB,
-};
-
-// 10분마다 리로드
-static LPEVENT s_pkReloadSpamEvent = NULL;
-
-EVENTINFO(reload_spam_event_info)
-{
-	// used to send command
-	DWORD empty;
-};
-
-EVENTFUNC(reload_spam_event)
-{
-	AccountDB::instance().ReturnQuery(QID_SPAM_DB, 0, NULL, "SELECT word, score FROM spam_db WHERE type='SPAM'");
-	return PASSES_PER_SEC(g_uiSpamReloadCycle);
-}
-
-void LoadSpamDB()
-{
-	AccountDB::instance().ReturnQuery(QID_SPAM_DB, 0, NULL, "SELECT word, score FROM spam_db WHERE type='SPAM'");
-
-	if (NULL == s_pkReloadSpamEvent)
-	{
-		reload_spam_event_info* info = AllocEventInfo<reload_spam_event_info>();
-		s_pkReloadSpamEvent = event_create(reload_spam_event, info, PASSES_PER_SEC(g_uiSpamReloadCycle));
-	}
-}
-
-void CancelReloadSpamEvent()
-{
-	s_pkReloadSpamEvent = NULL;
-}
-
-void AccountDB::AnalyzeReturnQuery(SQLMsg* pMsg)
-{
-	CReturnQueryInfo* qi = (CReturnQueryInfo*)pMsg->pvUserData;
-
-	switch (qi->iType)
-	{
-		case QID_SPAM_DB:
-		{
-			if (pMsg->Get()->uiNumRows > 0)
-			{
-				MYSQL_ROW row;
-
-				SpamManager::instance().Clear();
-
-				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-					SpamManager::instance().Insert(row[0], atoi(row[1]));
-			}
-		}
-		break;
-	}
-
-	M2_DELETE(qi);
-}
+#include "stdafx.h"
+#include <sstream>
+
+#include "../../common/length.h"
+
+#include "db.h"
+
+#include "config.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "char_manager.h"
+#include "item.h"
+#include "item_manager.h"
+#include "p2p.h"
+#include "log.h"
+#include "login_data.h"
+#include "locale_service.h"
+#include "pcbang.h"
+#include "spam.h"
+#include "auth_brazil.h"
+
+extern std::string g_stBlockDate;
+
+DBManager::DBManager() : m_bIsConnect(false)
+{
+}
+
+DBManager::~DBManager()
+{
+}
+
+bool DBManager::Connect(const char* host, const int port, const char* user, const char* pwd, const char* db)
+{
+	if (m_sql.Setup(host, user, pwd, db, g_stLocale.c_str(), false, port))
+		m_bIsConnect = true;
+
+	if (!m_sql_direct.Setup(host, user, pwd, db, g_stLocale.c_str(), true, port))
+		sys_err("cannot open direct sql connection to host %s", host);
+
+	if (m_bIsConnect && !g_bAuthServer)
+	{
+		LoadDBString();
+	}
+
+	return m_bIsConnect;
+}
+
+void DBManager::Query(const char* c_pszFormat, ...)
+{
+	char szQuery[4096];
+	va_list args;
+
+	va_start(args, c_pszFormat);
+	vsnprintf(szQuery, sizeof(szQuery), c_pszFormat, args);
+	va_end(args);
+
+	m_sql.AsyncQuery(szQuery);
+}
+
+SQLMsg* DBManager::DirectQuery(const char* c_pszFormat, ...)
+{
+	char szQuery[4096];
+	va_list args;
+
+	va_start(args, c_pszFormat);
+	vsnprintf(szQuery, sizeof(szQuery), c_pszFormat, args);
+	va_end(args);
+
+	return m_sql_direct.DirectQuery(szQuery);
+}
+
+bool DBManager::IsConnected()
+{
+	return m_bIsConnect;
+}
+
+void DBManager::ReturnQuery(int iType, DWORD dwIdent, void* pvData, const char* c_pszFormat, ...)
+{
+	//sys_log(0, "ReturnQuery %s", c_pszQuery);
+	char szQuery[4096];
+	va_list args;
+
+	va_start(args, c_pszFormat);
+	vsnprintf(szQuery, sizeof(szQuery), c_pszFormat, args);
+	va_end(args);
+
+	CReturnQueryInfo* p = M2_NEW CReturnQueryInfo;
+
+	p->iQueryType = QUERY_TYPE_RETURN;
+	p->iType = iType;
+	p->dwIdent = dwIdent;
+	p->pvData = pvData;
+
+	m_sql.ReturnQuery(szQuery, p);
+}
+
+SQLMsg* DBManager::PopResult()
+{
+	SQLMsg* p;
+
+	if (m_sql.PopResult(&p))
+		return p;
+
+	return NULL;
+}
+
+void DBManager::Process()
+{
+	SQLMsg* pMsg = NULL;
+
+	while ((pMsg = PopResult()))
+	{
+		if (NULL != pMsg->pvUserData)
+		{
+			switch (reinterpret_cast<CQueryInfo*>(pMsg->pvUserData)->iQueryType)
+			{
+				case QUERY_TYPE_RETURN:
+					AnalyzeReturnQuery(pMsg);
+					break;
+
+				case QUERY_TYPE_FUNCTION:
+				{
+					CFuncQueryInfo* qi = reinterpret_cast<CFuncQueryInfo*>(pMsg->pvUserData);
+					qi->f(pMsg);
+					M2_DELETE(qi);
+				}
+				break;
+
+				case QUERY_TYPE_AFTER_FUNCTION:
+				{
+					CFuncAfterQueryInfo* qi = reinterpret_cast<CFuncAfterQueryInfo*>(pMsg->pvUserData);
+					qi->f();
+					M2_DELETE(qi);
+				}
+				break;
+			}
+		}
+
+		delete pMsg;
+	}
+}
+
+CLoginData* DBManager::GetLoginData(DWORD dwKey)
+{
+	std::map<DWORD, CLoginData*>::iterator it = m_map_pkLoginData.find(dwKey);
+
+	if (it == m_map_pkLoginData.end())
+		return NULL;
+
+	return it->second;
+}
+
+void DBManager::InsertLoginData(CLoginData* pkLD)
+{
+	m_map_pkLoginData.insert(std::make_pair(pkLD->GetKey(), pkLD));
+}
+
+void DBManager::DeleteLoginData(CLoginData* pkLD)
+{
+	std::map<DWORD, CLoginData*>::iterator it = m_map_pkLoginData.find(pkLD->GetKey());
+
+	if (it == m_map_pkLoginData.end())
+		return;
+
+	sys_log(0, "DeleteLoginData %s %p", pkLD->GetLogin(), pkLD);
+
+	M2_DELETE(it->second);
+	m_map_pkLoginData.erase(it);
+}
+
+void DBManager::SendLoginPing(const char* c_pszLogin)
+{
+	TPacketGGLoginPing ptog;
+
+	ptog.bHeader = HEADER_GG_LOGIN_PING;
+	strlcpy(ptog.szLogin, c_pszLogin, sizeof(ptog.szLogin));
+
+	if (!g_pkAuthMasterDesc) // If I am master, broadcast to others
+	{
+		P2P_MANAGER::instance().Send(&ptog, sizeof(TPacketGGLoginPing));
+	}
+	else // If I am slave send login ping to master
+	{
+		g_pkAuthMasterDesc->Packet(&ptog, sizeof(TPacketGGLoginPing));
+	}
+}
+
+void DBManager::SendAuthLogin(LPDESC d)
+{
+	const TAccountTable& r = d->GetAccountTable();
+
+	CLoginData* pkLD = GetLoginData(d->GetLoginKey());
+
+	if (!pkLD)
+		return;
+
+	TPacketGDAuthLogin ptod;
+	ptod.dwID = r.id;
+
+	trim_and_lower(r.login, ptod.szLogin, sizeof(ptod.szLogin));
+	strlcpy(ptod.szSocialID, r.social_id, sizeof(ptod.szSocialID));
+	ptod.dwLoginKey = d->GetLoginKey();
+
+	thecore_memcpy(ptod.iPremiumTimes, pkLD->GetPremiumPtr(), sizeof(ptod.iPremiumTimes));
+	thecore_memcpy(&ptod.adwClientKey, pkLD->GetClientKey(), sizeof(DWORD) * 4);
+
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	strlcpy(ptod.szCountry, r.country, sizeof(ptod.szCountry));
+#endif
+
+	db_clientdesc->DBPacket(HEADER_GD_AUTH_LOGIN, d->GetHandle(), &ptod, sizeof(TPacketGDAuthLogin));
+	sys_log(0, "SendAuthLogin %s key %u", ptod.szLogin, ptod.dwID);
+
+	SendLoginPing(r.login);
+}
+
+void DBManager::LoginPrepare(long lRemainSecs, LPDESC d, DWORD* pdwClientKey, int* paiPremiumTimes)
+{
+	const TAccountTable& r = d->GetAccountTable();
+
+	CLoginData* pkLD = M2_NEW CLoginData;
+
+	pkLD->SetKey(d->GetLoginKey());
+	pkLD->SetLogin(r.login);
+	pkLD->SetRemainSecs(lRemainSecs);
+	pkLD->SetIP(d->GetHostName());
+	pkLD->SetClientKey(pdwClientKey);
+
+	if (paiPremiumTimes)
+		pkLD->SetPremium(paiPremiumTimes);
+
+	InsertLoginData(pkLD);
+
+	SendAuthLogin(d);
+}
+
+void DBManager::AnalyzeReturnQuery(SQLMsg* pMsg)
+{
+	CReturnQueryInfo* qi = (CReturnQueryInfo*)pMsg->pvUserData;
+
+	switch (qi->iType)
+	{
+		case QID_AUTH_LOGIN:
+		{
+			TPacketCGLogin3* pinfo = (TPacketCGLogin3*)qi->pvData;
+			LPDESC d = DESC_MANAGER::instance().FindByLoginKey(qi->dwIdent);
+
+			if (!d)
+			{
+				M2_DELETE(pinfo);
+				break;
+			}
+
+			// 치  - By SeMinZ
+			d->SetLogin(pinfo->login);
+
+			sys_log(0, "QID_AUTH_LOGIN: START %u %p", qi->dwIdent, get_pointer(d));
+
+			if (pMsg->Get()->uiNumRows == 0)
+			{
+				if (true == LC_IsBrazil())
+				{
+					//     磯
+					ReturnQuery(QID_BRAZIL_CREATE_ID, qi->dwIdent, pinfo,
+						"INSERT INTO account(login, password, social_id, create_time) "
+						"VALUES('%s', password('%s'), '0000000', NOW()) ;",
+						pinfo->login, pinfo->passwd);
+
+					sys_log(0, "[AUTH_BRAZIL] : Create A new AccountID From OnGame");
+				}
+				else
+				{
+					sys_log(0, "   NOID");
+					LoginFailure(d, "NOID");
+					M2_DELETE(pinfo);
+				}
+			}
+			else
+			{
+				MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+				int col = 0;
+
+				// PASSWORD('%s'), password, securitycode, social_id, id, status
+				char szEncrytPassword[45 + 1];
+				char szPassword[45 + 1];
+				char szSocialID[SOCIAL_ID_MAX_LEN + 1];
+				char szStatus[ACCOUNT_STATUS_MAX_LEN + 1];
+				DWORD dwID = 0;
+
+				if (!row[col])
+				{
+					sys_err("error column %d", col);
+					M2_DELETE(pinfo);
+					break;
+				}
+				strlcpy(szEncrytPassword, row[col++], sizeof(szEncrytPassword));
+
+				if (!row[col])
+				{
+					sys_err("error column %d", col);
+					M2_DELETE(pinfo);
+					break;
+				}
+				strlcpy(szPassword, row[col++], sizeof(szPassword));
+
+				if (!row[col])
+				{
+					sys_err("error column %d", col);
+					M2_DELETE(pinfo);
+					break;
+				}
+				strlcpy(szSocialID, row[col++], sizeof(szSocialID));
+
+				if (!row[col])
+				{
+					sys_err("error column %d", col);
+					M2_DELETE(pinfo);
+					break;
+				}
+				str_to_number(dwID, row[col++]);
+
+				if (!row[col])
+				{
+					sys_err("error column %d", col);
+					M2_DELETE(pinfo);
+					break;
+				}
+				strlcpy(szStatus, row[col++], sizeof(szStatus));
+
+				BYTE bNotAvail = 0;
+				str_to_number(bNotAvail, row[col++]);
+
+				int aiPremiumTimes[PREMIUM_MAX_NUM];
+				memset(&aiPremiumTimes, 0, sizeof(aiPremiumTimes));
+
+				char szCreateDate[256] = "00000000";
+
+				if (!g_iUseLocale)
+				{
+					str_to_number(aiPremiumTimes[PREMIUM_EXP], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_ITEM], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_SAFEBOX], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_AUTOLOOT], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_FISH_MIND], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_MARRIAGE_FAST], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_GOLD], row[col++]);
+#if defined(__CONQUEROR_LEVEL__)
+					str_to_number(aiPremiumTimes[PREMIUM_SUNGMA], row[col++]);
+#endif
+				}
+				else
+				{
+					str_to_number(aiPremiumTimes[PREMIUM_EXP], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_ITEM], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_SAFEBOX], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_AUTOLOOT], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_FISH_MIND], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_MARRIAGE_FAST], row[col++]);
+					str_to_number(aiPremiumTimes[PREMIUM_GOLD], row[col++]);
+#if defined(__CONQUEROR_LEVEL__)
+					str_to_number(aiPremiumTimes[PREMIUM_SUNGMA], row[col++]);
+#endif
+
+					if (LC_IsEurope() || test_server)
+					{
+						long retValue = 0;
+						str_to_number(retValue, row[col]);
+
+						time_t create_time = retValue;
+						struct tm tm1;
+#if defined(_WIN32) || defined(_WIN64)
+							localtime_s(&tm1, &create_time);
+#else
+							localtime_r(&create_time, &tm1);
+#endif
+							strftime(szCreateDate, 255, "%Y%m%d", &tm1);
+sys_log(0, "Create_Time %d %s", retValue, szCreateDate);
+						sys_log(0, "Block Time %d ", strncmp(szCreateDate, g_stBlockDate.c_str(), 8));
+					}
+				}
+
+				int nPasswordDiff = strcmp(szEncrytPassword, szPassword);
+
+				if (true == LC_IsBrazil())
+				{
+					nPasswordDiff = 0; //   橘호 체크  苛쨈.
+				}
+
+				if (nPasswordDiff)
+				{
+					LoginFailure(d, "WRONGPWD");
+					sys_log(0, "   WRONGPWD");
+					M2_DELETE(pinfo);
+				}
+				else if (bNotAvail)
+				{
+					LoginFailure(d, "NOTAVAIL");
+					sys_log(0, "   NOTAVAIL");
+					M2_DELETE(pinfo);
+				}
+				else if (DESC_MANAGER::instance().FindByLoginName(pinfo->login))
+				{
+					LoginFailure(d, "ALREADY");
+					sys_log(0, "   ALREADY");
+					M2_DELETE(pinfo);
+				}
+				else if (strcmp(szStatus, "OK"))
+				{
+					LoginFailure(d, szStatus);
+					sys_log(0, "   STATUS: %s", szStatus);
+					M2_DELETE(pinfo);
+				}
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+				else if (!LocaleService_GetLocale(pinfo->country))
+				{
+					LoginFailure(d, "COUNTRYERR");
+					sys_log(0, "   COUNTRYERR");
+					M2_DELETE(pinfo);
+				}
+#endif
+				else
+				{
+					if (LC_IsEurope())
+					{
+						// stBlockData >= 0 == 짜 BlockDate  肩
+						if (strncmp(szCreateDate, g_stBlockDate.c_str(), 8) >= 0)
+						{
+							LoginFailure(d, "BLKLOGIN");
+							sys_log(0, "   BLKLOGIN");
+							M2_DELETE(pinfo);
+							break;
+						}
+
+						char szQuery[1024];
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+						snprintf(szQuery, sizeof(szQuery), "UPDATE `account` SET `last_play` = NOW(), `country` = '%s' WHERE `id` = %u",
+							LocaleService_GetCountry(pinfo->country), dwID);
+#else
+						snprintf(szQuery, sizeof(szQuery), "UPDATE `account` SET `last_play` = NOW() WHERE `id` = %u", dwID);
+#endif
+						std::unique_ptr<SQLMsg> msg(DBManager::instance().DirectQuery(szQuery));
+					}
+
+					TAccountTable& r = d->GetAccountTable();
+
+					r.id = dwID;
+					trim_and_lower(pinfo->login, r.login, sizeof(r.login));
+					strlcpy(r.passwd, pinfo->passwd, sizeof(r.passwd));
+					strlcpy(r.social_id, szSocialID, sizeof(r.social_id));
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+					strlcpy(r.country, pinfo->country, sizeof(r.country));
+#endif
+
+					DESC_MANAGER::instance().ConnectAccount(r.login, d);
+
+					{
+						LoginPrepare(0, d, pinfo->adwClientKey, aiPremiumTimes);
+						// By SeMinZ
+						M2_DELETE(pinfo);
+						break;
+					}
+
+					sys_log(0, "QID_AUTH_LOGIN: SUCCESS %s", pinfo->login);
+				}
+			}
+		}
+		break;
+
+		case QID_SAFEBOX_SIZE:
+		{
+			LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(qi->dwIdent);
+
+			if (ch)
+			{
+				if (pMsg->Get()->uiNumRows > 0)
+				{
+					MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+					int size = 0;
+					str_to_number(size, row[0]);
+					ch->SetSafeboxSize(SAFEBOX_PAGE_SIZE * size);
+				}
+			}
+		}
+		break;
+
+		case QID_DB_STRING:
+		{
+			m_map_dbstring.clear();
+			m_vec_GreetMessage.clear();
+
+			for (uint i = 0; i < pMsg->Get()->uiNumRows; ++i)
+			{
+				MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+				//ch->SetSafeboxSize(SAFEBOX_PAGE_SIZE * atoi(row[0]));
+				if (row[0] && row[1])
+				{
+					m_map_dbstring.insert(make_pair(std::string(row[0]), std::string(row[1])));
+					sys_log(0, "DBSTR '%s' '%s'", row[0], row[1]);
+				}
+			}
+			if (m_map_dbstring.find("GREET") != m_map_dbstring.end())
+			{
+				std::istringstream is(m_map_dbstring["GREET"]);
+				while (!is.eof())
+				{
+					std::string str;
+					getline(is, str);
+					m_vec_GreetMessage.push_back(str);
+				}
+			}
+		}
+		break;
+
+		case QID_LOTTO:
+		{
+			LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(qi->dwIdent);
+			DWORD* pdw = (DWORD*)qi->pvData;
+
+			if (ch)
+			{
+				if (pMsg->Get()->uiAffectedRows == 0 || pMsg->Get()->uiAffectedRows == (uint32_t)-1)
+				{
+					sys_log(0, "GIVE LOTTO FAIL TO pid %u", ch->GetPlayerID());
+				}
+				else
+				{
+					LPITEM pkItem = ch->AutoGiveItem(pdw[0], pdw[1]);
+
+					if (pkItem)
+					{
+						sys_log(0, "GIVE LOTTO SUCCESS TO %s (pid %u)", ch->GetName(), qi->dwIdent);
+						//ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 획: %s", LC_ITEM(pkItem->GetVnum())));
+
+						pkItem->SetSocket(0, pMsg->Get()->uiInsertID);
+						pkItem->SetSocket(1, pdw[2]);
+					}
+					else
+						sys_log(0, "GIVE LOTTO FAIL2 TO pid %u", ch->GetPlayerID());
+				}
+			}
+
+			M2_DELETE_ARRAY(pdw);
+		}
+		break;
+
+		case QID_HIGHSCORE_REGISTER:
+		{
+			THighscoreRegisterQueryInfo* info = (THighscoreRegisterQueryInfo*)qi->pvData;
+			bool bQuery = true;
+
+			if (pMsg->Get()->uiNumRows)
+			{
+				MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+
+				if (row && row[0])
+				{
+					int iCur = 0;
+					str_to_number(iCur, row[0]);
+
+					if ((info->bOrder && iCur >= info->iValue) ||
+						(!info->bOrder && iCur <= info->iValue))
+						bQuery = false;
+				}
+			}
+
+			if (bQuery)
+				Query("REPLACE INTO highscore%s VALUES('%s', %u, %d)",
+					get_table_postfix(), info->szBoard, info->dwPID, info->iValue);
+
+			M2_DELETE(info);
+		}
+		break;
+
+		case QID_HIGHSCORE_SHOW:
+		{
+		}
+		break;
+
+		// BLOCK_CHAT
+		case QID_BLOCK_CHAT_LIST:
+		{
+			LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(qi->dwIdent);
+
+			if (ch == NULL)
+				break;
+			if (pMsg->Get()->uiNumRows)
+			{
+				MYSQL_ROW row;
+				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, "%s %s sec", row[0], row[1]);
+				}
+			}
+			else
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, "No one currently blocked.");
+			}
+		}
+		break;
+		// END_OF_BLOCK_CHAT
+
+		// PCBANG_IP_LIST
+		case QID_PCBANG_IP_LIST_CHECK:
+		{
+			const std::string PCBANG_IP_TABLE_NAME("pcbang_ip");
+
+			if (pMsg->Get()->uiNumRows > 0)
+			{
+				MYSQL_ROW row;
+				bool isFinded = false;
+
+				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+				{
+					const char* c_szName = row[0];
+					const char* c_szUpdateTime = row[12];
+
+					if (test_server)
+						sys_log(0, "%s:%s", c_szName, c_szUpdateTime);
+
+					if (PCBANG_IP_TABLE_NAME == c_szName)
+					{
+						isFinded = true;
+
+						static std::string s_stLastTime;
+						if (s_stLastTime != c_szUpdateTime)
+						{
+							s_stLastTime = c_szUpdateTime;
+							sys_log(0, "'%s' mysql table is UPDATED(%s)", PCBANG_IP_TABLE_NAME.c_str(), c_szUpdateTime);
+							ReturnQuery(QID_PCBANG_IP_LIST_SELECT, 0, NULL, "SELECT pcbang_id, ip FROM %s;", PCBANG_IP_TABLE_NAME.c_str());
+						}
+						else
+						{
+							sys_log(0, "'%s' mysql table is NOT updated(%s)", PCBANG_IP_TABLE_NAME.c_str(), c_szUpdateTime);
+						}
+						break;
+					}
+				}
+
+				if (!isFinded)
+				{
+					sys_err(0, "'%s' mysql table CANNOT FIND", PCBANG_IP_TABLE_NAME.c_str());
+				}
+			}
+			else if (test_server)
+			{
+				sys_err(0, "'%s' mysql table is NOT EXIST", PCBANG_IP_TABLE_NAME.c_str());
+			}
+		}
+		break;
+
+		case QID_PCBANG_IP_LIST_SELECT:
+		{
+			if (pMsg->Get()->uiNumRows > 0)
+			{
+				MYSQL_ROW row;
+
+				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+				{
+					CPCBangManager::instance().InsertIP(row[0], row[1]);
+				}
+			}
+			else if (test_server)
+			{
+				sys_log(0, "PCBANG_IP_LIST is EMPTY");
+			}
+		}
+		break;
+
+		// END_OF_PCBANG_IP_LIST
+
+		case QID_BRAZIL_CREATE_ID:
+		{
+			TPacketCGLogin3* pinfo = (TPacketCGLogin3*)qi->pvData;
+
+			if (pMsg->Get()->uiAffectedRows == 0 || pMsg->Get()->uiAffectedRows == (uint32_t)-1)
+			{
+				LPDESC d = DESC_MANAGER::instance().FindByLoginKey(qi->dwIdent);
+				sys_log(0, "[AUTH_BRAZIL]   NOID");
+				sys_log(0, "[AUTH_BRAZIL] : Failed to create a new account %s", pinfo->login);
+				LoginFailure(d, "NOID");
+				M2_DELETE(pinfo);
+			}
+			else
+			{
+				sys_log(0, "[AUTH_BRAZIL] : Succeed to create a new account %s", pinfo->login);
+
+				ReturnQuery(QID_AUTH_LOGIN, qi->dwIdent, pinfo,
+					"SELECT CONCAT('*', UPPER(SHA1(UNHEX(SHA1('%s'))))), `password`, `securitycode`, `social_id`, `id`, `status`"
+					", `availDt` - NOW() > 0"
+					", UNIX_TIMESTAMP(`silver_expire`)"
+					", UNIX_TIMESTAMP(`gold_expire`)"
+					", UNIX_TIMESTAMP(`safebox_expire`)"
+					", UNIX_TIMESTAMP(`autoloot_expire`)"
+					", UNIX_TIMESTAMP(`fish_mind_expire`)"
+					", UNIX_TIMESTAMP(`marriage_fast_expire`)"
+					", UNIX_TIMESTAMP(`money_drop_rate_expire`)"
+#if defined(__CONQUEROR_LEVEL__)
+					", UNIX_TIMESTAMP(`sungma_expire`)"
+#endif
+					", UNIX_TIMESTAMP(`create_time`)"
+					" FROM account WHERE `login` = '%s'",
+					pinfo->passwd, pinfo->login);
+			}
+		}
+		break;
+
+		default:
+			sys_err("FATAL ERROR!!! Unhandled return query id %d", qi->iType);
+			break;
+	}
+
+	M2_DELETE(qi);
+}
+
+void DBManager::LoadDBString()
+{
+	ReturnQuery(QID_DB_STRING, 0, NULL, "SELECT `name`, `text` FROM `string%s`", get_table_postfix());
+}
+
+const std::string& DBManager::GetDBString(const std::string& key)
+{
+	static std::string null_str = "";
+	auto it = m_map_dbstring.find(key);
+	if (it == m_map_dbstring.end())
+		return null_str;
+	return it->second;
+}
+
+const std::vector<std::string>& DBManager::GetGreetMessage()
+{
+	return m_vec_GreetMessage;
+}
+
+void DBManager::SendMoneyLog(BYTE type, DWORD vnum, int gold
+#if defined(__CHEQUE_SYSTEM__)
+	, int cheque
+#endif
+)
+{
+	if (!gold)
+		return;
+
+	TPacketMoneyLog p;
+	p.type = type;
+	p.vnum = vnum;
+	p.gold = gold;
+#if defined(__CHEQUE_SYSTEM__)
+	p.cheque = cheque;
+#endif
+	db_clientdesc->DBPacket(HEADER_GD_MONEY_LOG, 0, &p, sizeof(p));
+}
+
+void DBManager::RequestBlockException(const char* login, int cmd)
+{
+	TPacketBlockException packet;
+
+	packet.cmd = cmd;
+	strlcpy(packet.login, login, sizeof(packet.login));
+	db_clientdesc->DBPacket(HEADER_GD_BLOCK_EXCEPTION, 0, &packet, sizeof(packet));
+}
+
+size_t DBManager::EscapeString(char* dst, size_t dstSize, const char* src, size_t srcSize)
+{
+	return m_sql_direct.EscapeString(dst, dstSize, src, srcSize);
+}
+
+//
+// Common SQL
+//
+AccountDB::AccountDB() :
+	m_IsConnect(false)
+{
+}
+
+bool AccountDB::IsConnected()
+{
+	return m_IsConnect;
+}
+
+bool AccountDB::Connect(const char* host, const int port, const char* user, const char* pwd, const char* db)
+{
+	m_IsConnect = m_sql_direct.Setup(host, user, pwd, db, "", true, port);
+
+	if (false == m_IsConnect)
+	{
+		fprintf(stderr, "cannot open direct sql connection to host: %s user: %s db: %s\n", host, user, db);
+		return false;
+	}
+
+	return m_IsConnect;
+}
+
+bool AccountDB::ConnectAsync(const char* host, const int port, const char* user, const char* pwd, const char* db, const char* locale)
+{
+	m_sql.Setup(host, user, pwd, db, locale, false, port);
+	return true;
+}
+
+void AccountDB::SetLocale(const std::string& stLocale)
+{
+	m_sql_direct.SetLocale(stLocale);
+	m_sql_direct.QueryLocaleSet();
+}
+
+SQLMsg* AccountDB::DirectQuery(const char* query)
+{
+	return m_sql_direct.DirectQuery(query);
+}
+
+void AccountDB::AsyncQuery(const char* query)
+{
+	m_sql.AsyncQuery(query);
+}
+
+void AccountDB::ReturnQuery(int iType, DWORD dwIdent, void* pvData, const char* c_pszFormat, ...)
+{
+	char szQuery[4096];
+	va_list args;
+
+	va_start(args, c_pszFormat);
+	vsnprintf(szQuery, sizeof(szQuery), c_pszFormat, args);
+	va_end(args);
+
+	CReturnQueryInfo* p = M2_NEW CReturnQueryInfo;
+
+	p->iQueryType = QUERY_TYPE_RETURN;
+	p->iType = iType;
+	p->dwIdent = dwIdent;
+	p->pvData = pvData;
+
+	m_sql.ReturnQuery(szQuery, p);
+}
+
+SQLMsg* AccountDB::PopResult()
+{
+	SQLMsg* p;
+
+	if (m_sql.PopResult(&p))
+		return p;
+
+	return NULL;
+}
+
+void AccountDB::Process()
+{
+	SQLMsg* pMsg = NULL;
+
+	while ((pMsg = PopResult()))
+	{
+		CQueryInfo* qi = (CQueryInfo*)pMsg->pvUserData;
+
+		switch (qi->iQueryType)
+		{
+			case QUERY_TYPE_RETURN:
+				AnalyzeReturnQuery(pMsg);
+				break;
+		}
+	}
+
+	delete pMsg;
+}
+
+extern unsigned int g_uiSpamReloadCycle;
+
+enum EAccountQID
+{
+	QID_SPAM_DB,
+};
+
+// 10龜 琯
+static LPEVENT s_pkReloadSpamEvent = NULL;
+
+EVENTINFO(reload_spam_event_info)
+{
+	// used to send command
+	DWORD empty;
+};
+
+EVENTFUNC(reload_spam_event)
+{
+	AccountDB::instance().ReturnQuery(QID_SPAM_DB, 0, NULL, "SELECT word, score FROM spam_db WHERE type='SPAM'");
+	return PASSES_PER_SEC(g_uiSpamReloadCycle);
+}
+
+void LoadSpamDB()
+{
+	AccountDB::instance().ReturnQuery(QID_SPAM_DB, 0, NULL, "SELECT word, score FROM spam_db WHERE type='SPAM'");
+
+	if (NULL == s_pkReloadSpamEvent)
+	{
+		reload_spam_event_info* info = AllocEventInfo<reload_spam_event_info>();
+		s_pkReloadSpamEvent = event_create(reload_spam_event, info, PASSES_PER_SEC(g_uiSpamReloadCycle));
+	}
+}
+
+void CancelReloadSpamEvent()
+{
+	s_pkReloadSpamEvent = NULL;
+}
+
+void AccountDB::AnalyzeReturnQuery(SQLMsg* pMsg)
+{
+	CReturnQueryInfo* qi = (CReturnQueryInfo*)pMsg->pvUserData;
+
+	switch (qi->iType)
+	{
+		case QID_SPAM_DB:
+		{
+			if (pMsg->Get()->uiNumRows > 0)
+			{
+				MYSQL_ROW row;
+
+				SpamManager::instance().Clear();
+
+				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+					SpamManager::instance().Insert(row[0], atoi(row[1]));
+			}
+		}
+		break;
+	}
+
+	M2_DELETE(qi);
+}
--- a/server/metin2/Source/Server/game/src/debug_allocator_adapter.h
+++ b/server/metin2/Source/Server/game/src/debug_allocator_adapter.h
@@ -1,361 +1,367 @@
-#ifndef __INC_DEBUG_ADAPTER_H__
-#define __INC_DEBUG_ADAPTER_H__
-
-// Intended to be included only in "debug_allocator.h"
-
-#define DBGALLOC_NO_STACKTRACE
-
-#ifndef DBGALLOC_NO_STACKTRACE
-#include <execinfo.h>
-#endif
-#include <ctime>
-#include <iostream>
-#include <fstream>
-
-#define DBGALLOC_LOG_FILENAME "dbgalloc.log"
-#define DBGALLOC_REPORT_FILENAME "dbgalloc_report.log"
-
-// A struct to hold the allocation information of a single pointer value.
-struct AllocTag
-{
-	AllocTag(const char* file, size_t line) : in_use(true), age(1)
-	{
-		this->file = file;
-		this->line = line;
-	}
-	void Reuse(const char* file, size_t line)
-	{
-		in_use = true;
-		this->file = file;
-		this->line = line;
-		age = IncreaseAge(age);
-	}
-	void Unuse(const char* file, size_t line)
-	{
-		in_use = false;
-		this->file = file;
-		this->line = line;
-		age = IncreaseAge(age);
-	}
-	static size_t IncreaseAge(size_t value)
-	{
-		size_t result = value;
-		++result;
-		// Avoid zero on roll-over
-		if (result == 0)
-			result = 1;
-
-		return result;
-	}
-	bool in_use;
-	const char* file;
-	size_t line;
-	size_t age; // incremented on both the cases; alloc and free
-};
-
-inline std::ostream& operator<<(std::ostream& os, const AllocTag tag)
-{
-	return os << "<" << tag.file << " line:" << tag.line <<
-		" age:" << tag.age << ">";
-}
-
-// Scoped(guarded) wrapper for std::ofstream
-struct ScopedOutputFile {
-	ScopedOutputFile(const char* filename,
-		std::ios_base::openmode mode = std::ios_base::app)
-	{
-		stream.open(filename, mode);
-	}
-	~ScopedOutputFile()
-	{
-		if (stream.is_open())
-		{
-			stream.close();
-		}
-	}
-	std::ostream& Datetime()
-	{
-		char buf[24];
-		time_t t = ::time(NULL);
-		::strftime(buf, 24, "%Y-%m-%d %H:%M:%S", ::localtime(&t));
-		return stream << buf;
-	}
-	std::ofstream stream;
-};
-
-template<typename T> class DebugPtr;
-
-// Debug allocator adapter that extends the implementation detail specified
-// by the template parameter class Detail.
-// Note that this is definitely NOT thread-safe.
-template<class Detail>
-class DebugAllocatorAdapter
-{
-public:
-	~DebugAllocatorAdapter() {}
-
-	// Static initializer.
-	static void StaticSetUp()
-	{
-		GetInstance().detail_.SetUp(); // singleton instantiation
-	}
-	// Static finalizer.
-	static void StaticTearDown()
-	{
-		DebugAllocatorAdapter& instance = GetInstance();
-		instance.DumpLeakReport();
-		instance.detail_.TearDown();
-	}
-
-	// Allocates a memory block.
-	static void* Alloc(size_t size)
-	{
-		return GetInstance().detail_.Alloc(size);
-	}
-	// Deallocates a memory block.
-	static void Free(void* p)
-	{
-		GetInstance().detail_.Free(p);
-	}
-
-	// Marks the specified heap pointer as acquired in the given context.
-	static size_t MarkAcquired(void* p, const char* file, size_t line, const char* context)
-	{
-		if (p == NULL)
-			return 0;
-
-		AllocMapType& alloc_map = GetInstance().alloc_map_;
-		size_t age = 0;
-		AllocMapType::iterator it = alloc_map.find(p);
-		if (it == alloc_map.end())
-		{
-			AllocTag tag(file, line);
-			alloc_map.insert(AllocMapType::value_type(p, tag));
-			age = tag.age;
-		}
-		else
-		{
-			AllocTag& tag = it->second;
-			if (!tag.in_use)
-			{
-				tag.Reuse(file, line);
-				age = tag.age;
-			}
-			else
-			{
-				// Is the Detail insane or...?
-				ScopedOutputFile of(DBGALLOC_LOG_FILENAME);
-				if (of.stream.is_open())
-				{
-					of.Datetime() << " [" << context << "] " <<
-						p << " " << tag << " already in use. " <<
-						"(" << file << " line:" << line << ")" <<
-						std::endl;
-#ifndef DBGALLOC_NO_STACKTRACE
-					PrintStack(of.stream);
-#endif
-				}
-			}
-		}
-		return age;
-	}
-
-	// Marks the specified heap pointer as released in the given context.
-	template<typename T>
-	static T* MarkReleased(T* p, const char* file, size_t line, const char* context)
-	{
-		return (GetInstance().VerifyReference(p, file, line, context, true) ? p : NULL);
-	}
-	template<typename T>
-	static T* MarkReleased(DebugPtr<T>& ptr, const char* file, size_t line, const char* context)
-	{
-		return (GetInstance().VerifyReference(ptr.Get(), file, line, context, true, true, ptr.GetAge()) ? ptr.Get() : NULL);
-	}
-
-	// Retrieves the age of the specified heap pointer.
-	static size_t RetrieveAge(void* p)
-	{
-		if (p == NULL)
-			return 0;
-
-		AllocMapType& alloc_map = GetInstance().alloc_map_;
-		AllocMapType::iterator it = alloc_map.find(p);
-		if (it != alloc_map.end())
-		{
-			AllocTag& tag = it->second;
-			if (tag.in_use)
-				return tag.age;
-		}
-		return 0;
-	}
-
-	// Verifies the specified heap pointer with its age.
-	template<typename T>
-	static T* Verify(T* p, size_t age, const char* file = NULL, size_t line = 0)
-	{
-		return (GetInstance().VerifyReference(p, file, line, "ref", false, true, age) ? p : NULL);
-	}
-
-	template<typename T>
-	static T* VerifyDeletion(T* p, const char* file, size_t line, bool verify_age = false, size_t age = 0)
-	{
-		return (GetInstance().VerifyReference(p, file, line, "pre_delete", false, verify_age, age) ? p : NULL);
-	}
-
-	static void LogBoundaryCorruption(void* p, size_t age)
-	{
-		AllocMapType& alloc_map = GetInstance().alloc_map_;
-		AllocMapType::iterator it = alloc_map.find(p);
-		if (it != alloc_map.end())
-		{
-			AllocTag& tag = it->second;
-			ScopedOutputFile of(DBGALLOC_LOG_FILENAME);
-			if (of.stream.is_open())
-			{
-				of.Datetime() << " [boundary] " <<
-					p << " " << tag << " age header corrupted:" <<
-					" current age value " << age << std::endl;
-#ifndef DBGALLOC_NO_STACKTRACE
-				PrintStack(of.stream);
-#endif
-			}
-		}
-	}
-
-private:
-	// Private constructor to prohibit explicit instantiation.
-	DebugAllocatorAdapter() {}
-
-	// Returns the reference to the singleton instance.
-	static DebugAllocatorAdapter& GetInstance()
-	{
-		static DebugAllocatorAdapter instance;
-		return instance;
-	}
-
-	bool VerifyReference(void* p, const char* file, size_t line,
-		const char* context, bool mark_released,
-		bool verify_age = false, size_t age = 0)
-	{
-		if (p == NULL)
-			return mark_released;
-
-		AllocMapType::iterator it = alloc_map_.find(p);
-		if (it != alloc_map_.end())
-		{
-			AllocTag& tag = it->second;
-			if (tag.in_use)
-			{
-				if (verify_age && tag.age != age)
-				{
-					ScopedOutputFile of(DBGALLOC_LOG_FILENAME);
-					if (of.stream.is_open())
-					{
-						of.Datetime() << " [" << context << "] " <<
-							p << " " << tag << " has different age with " <<
-							age << " (" << file << " line:" << line << ")" <<
-							std::endl;
-#ifndef DBGALLOC_NO_STACKTRACE
-						PrintStack(of.stream);
-#endif
-					}
-				}
-				else
-				{
-					if (mark_released)
-					{
-						tag.Unuse(file, line);
-					}
-					return true;
-				}
-			}
-			else
-			{
-				ScopedOutputFile of(DBGALLOC_LOG_FILENAME);
-				if (of.stream.is_open())
-				{
-					of.Datetime() << " [" << context << "] " <<
-						p << " " << tag << " already freed. " <<
-						"(" << file << " line:" << line << ")" <<
-						std::endl;
-#ifndef DBGALLOC_NO_STACKTRACE
-					PrintStack(of.stream);
-#endif
-				}
-			}
-		}
-		else
-		{
-			ScopedOutputFile of(DBGALLOC_LOG_FILENAME);
-			if (of.stream.is_open())
-			{
-				of.Datetime() << " [" << context << "] " <<
-					p << " is not a valid entry. " <<
-					"(" << file << " line:" << line << ")" <<
-					std::endl;
-#ifndef DBGALLOC_NO_STACKTRACE
-				PrintStack(of.stream);
-#endif
-			}
-		}
-		return false;
-	}
-
-	// Prints out memory leak report.
-	void DumpLeakReport()
-	{
-		AllocMapType::iterator it = alloc_map_.begin(), end = alloc_map_.end();
-		for (; it != end; ++it)
-		{
-			if (it->second.in_use)
-			{
-				break;
-			}
-		}
-		if (it == end)
-			return;
-
-		ScopedOutputFile of(DBGALLOC_REPORT_FILENAME);
-		if (!of.stream.is_open())
-		{
-			return;
-		}
-		of.Datetime() << std::endl;
-		for (; it != end; ++it)
-		{
-			AllocTag& tag = it->second;
-			if (tag.in_use)
-			{
-				of.stream << "[leak] " << it->first << " " << tag << std::endl;
-			}
-		}
-	}
-
-#ifndef DBGALLOC_NO_STACKTRACE
-	void PrintStack(std::ostream& out)
-	{
-		void* array[200];
-		std::size_t size;
-		char** symbols;
-
-		size = backtrace(array, 200);
-		symbols = backtrace_symbols(array, size);
-
-		out << std::endl;
-
-		for (std::size_t i = 0; i < size; ++i)
-		{
-			out << "Stack> " << symbols[i] << std::endl;
-		}
-
-		free(symbols);
-	}
-#endif
-
-	typedef std::unordered_map<void*, AllocTag> AllocMapType;
-
-	Detail detail_;
-	AllocMapType alloc_map_;
-};
-
-#endif // __INC_DEBUG_ADAPTER_H__
+#ifndef __INC_DEBUG_ADAPTER_H__
+#define __INC_DEBUG_ADAPTER_H__
+
+// Intended to be included only in "debug_allocator.h"
+
+#define DBGALLOC_NO_STACKTRACE
+
+#ifndef DBGALLOC_NO_STACKTRACE
+#include <execinfo.h>
+#endif
+#include <ctime>
+#include <iostream>
+#include <fstream>
+
+#define DBGALLOC_LOG_FILENAME "dbgalloc.log"
+#define DBGALLOC_REPORT_FILENAME "dbgalloc_report.log"
+
+// A struct to hold the allocation information of a single pointer value.
+struct AllocTag
+{
+	AllocTag(const char* file, size_t line) : in_use(true), age(1)
+	{
+		this->file = file;
+		this->line = line;
+	}
+	void Reuse(const char* file, size_t line)
+	{
+		in_use = true;
+		this->file = file;
+		this->line = line;
+		age = IncreaseAge(age);
+	}
+	void Unuse(const char* file, size_t line)
+	{
+		in_use = false;
+		this->file = file;
+		this->line = line;
+		age = IncreaseAge(age);
+	}
+	static size_t IncreaseAge(size_t value)
+	{
+		size_t result = value;
+		++result;
+		// Avoid zero on roll-over
+		if (result == 0)
+			result = 1;
+
+		return result;
+	}
+	bool in_use;
+	const char* file;
+	size_t line;
+	size_t age; // incremented on both the cases; alloc and free
+};
+
+inline std::ostream& operator<<(std::ostream& os, const AllocTag tag)
+{
+	return os << "<" << tag.file << " line:" << tag.line <<
+		" age:" << tag.age << ">";
+}
+
+// Scoped(guarded) wrapper for std::ofstream
+struct ScopedOutputFile {
+	ScopedOutputFile(const char* filename,
+		std::ios_base::openmode mode = std::ios_base::app)
+	{
+		stream.open(filename, mode);
+	}
+	~ScopedOutputFile()
+	{
+		if (stream.is_open())
+		{
+			stream.close();
+		}
+	}
+	std::ostream& Datetime()
+	{
+		char buf[24];
+		time_t t = ::time(NULL);
+		struct tm tm_buf;
+#if defined(_WIN32) || defined(_WIN64)
+			localtime_s(&tm_buf, &t);
+#else
+			localtime_r(&t, &tm_buf);
+#endif
+			::strftime(buf, 24, "%Y-%m-%d %H:%M:%S", &tm_buf);
+		return stream << buf;
+	}
+	std::ofstream stream;
+};
+
+template<typename T> class DebugPtr;
+
+// Debug allocator adapter that extends the implementation detail specified
+// by the template parameter class Detail.
+// Note that this is definitely NOT thread-safe.
+template<class Detail>
+class DebugAllocatorAdapter
+{
+public:
+	~DebugAllocatorAdapter() {}
+
+	// Static initializer.
+	static void StaticSetUp()
+	{
+		GetInstance().detail_.SetUp(); // singleton instantiation
+	}
+	// Static finalizer.
+	static void StaticTearDown()
+	{
+		DebugAllocatorAdapter& instance = GetInstance();
+		instance.DumpLeakReport();
+		instance.detail_.TearDown();
+	}
+
+	// Allocates a memory block.
+	static void* Alloc(size_t size)
+	{
+		return GetInstance().detail_.Alloc(size);
+	}
+	// Deallocates a memory block.
+	static void Free(void* p)
+	{
+		GetInstance().detail_.Free(p);
+	}
+
+	// Marks the specified heap pointer as acquired in the given context.
+	static size_t MarkAcquired(void* p, const char* file, size_t line, const char* context)
+	{
+		if (p == NULL)
+			return 0;
+
+		AllocMapType& alloc_map = GetInstance().alloc_map_;
+		size_t age = 0;
+		AllocMapType::iterator it = alloc_map.find(p);
+		if (it == alloc_map.end())
+		{
+			AllocTag tag(file, line);
+			alloc_map.insert(AllocMapType::value_type(p, tag));
+			age = tag.age;
+		}
+		else
+		{
+			AllocTag& tag = it->second;
+			if (!tag.in_use)
+			{
+				tag.Reuse(file, line);
+				age = tag.age;
+			}
+			else
+			{
+				// Is the Detail insane or...?
+				ScopedOutputFile of(DBGALLOC_LOG_FILENAME);
+				if (of.stream.is_open())
+				{
+					of.Datetime() << " [" << context << "] " <<
+						p << " " << tag << " already in use. " <<
+						"(" << file << " line:" << line << ")" <<
+						std::endl;
+#ifndef DBGALLOC_NO_STACKTRACE
+					PrintStack(of.stream);
+#endif
+				}
+			}
+		}
+		return age;
+	}
+
+	// Marks the specified heap pointer as released in the given context.
+	template<typename T>
+	static T* MarkReleased(T* p, const char* file, size_t line, const char* context)
+	{
+		return (GetInstance().VerifyReference(p, file, line, context, true) ? p : NULL);
+	}
+	template<typename T>
+	static T* MarkReleased(DebugPtr<T>& ptr, const char* file, size_t line, const char* context)
+	{
+		return (GetInstance().VerifyReference(ptr.Get(), file, line, context, true, true, ptr.GetAge()) ? ptr.Get() : NULL);
+	}
+
+	// Retrieves the age of the specified heap pointer.
+	static size_t RetrieveAge(void* p)
+	{
+		if (p == NULL)
+			return 0;
+
+		AllocMapType& alloc_map = GetInstance().alloc_map_;
+		AllocMapType::iterator it = alloc_map.find(p);
+		if (it != alloc_map.end())
+		{
+			AllocTag& tag = it->second;
+			if (tag.in_use)
+				return tag.age;
+		}
+		return 0;
+	}
+
+	// Verifies the specified heap pointer with its age.
+	template<typename T>
+	static T* Verify(T* p, size_t age, const char* file = NULL, size_t line = 0)
+	{
+		return (GetInstance().VerifyReference(p, file, line, "ref", false, true, age) ? p : NULL);
+	}
+
+	template<typename T>
+	static T* VerifyDeletion(T* p, const char* file, size_t line, bool verify_age = false, size_t age = 0)
+	{
+		return (GetInstance().VerifyReference(p, file, line, "pre_delete", false, verify_age, age) ? p : NULL);
+	}
+
+	static void LogBoundaryCorruption(void* p, size_t age)
+	{
+		AllocMapType& alloc_map = GetInstance().alloc_map_;
+		AllocMapType::iterator it = alloc_map.find(p);
+		if (it != alloc_map.end())
+		{
+			AllocTag& tag = it->second;
+			ScopedOutputFile of(DBGALLOC_LOG_FILENAME);
+			if (of.stream.is_open())
+			{
+				of.Datetime() << " [boundary] " <<
+					p << " " << tag << " age header corrupted:" <<
+					" current age value " << age << std::endl;
+#ifndef DBGALLOC_NO_STACKTRACE
+				PrintStack(of.stream);
+#endif
+			}
+		}
+	}
+
+private:
+	// Private constructor to prohibit explicit instantiation.
+	DebugAllocatorAdapter() {}
+
+	// Returns the reference to the singleton instance.
+	static DebugAllocatorAdapter& GetInstance()
+	{
+		static DebugAllocatorAdapter instance;
+		return instance;
+	}
+
+	bool VerifyReference(void* p, const char* file, size_t line,
+		const char* context, bool mark_released,
+		bool verify_age = false, size_t age = 0)
+	{
+		if (p == NULL)
+			return mark_released;
+
+		AllocMapType::iterator it = alloc_map_.find(p);
+		if (it != alloc_map_.end())
+		{
+			AllocTag& tag = it->second;
+			if (tag.in_use)
+			{
+				if (verify_age && tag.age != age)
+				{
+					ScopedOutputFile of(DBGALLOC_LOG_FILENAME);
+					if (of.stream.is_open())
+					{
+						of.Datetime() << " [" << context << "] " <<
+							p << " " << tag << " has different age with " <<
+							age << " (" << file << " line:" << line << ")" <<
+							std::endl;
+#ifndef DBGALLOC_NO_STACKTRACE
+						PrintStack(of.stream);
+#endif
+					}
+				}
+				else
+				{
+					if (mark_released)
+					{
+						tag.Unuse(file, line);
+					}
+					return true;
+				}
+			}
+			else
+			{
+				ScopedOutputFile of(DBGALLOC_LOG_FILENAME);
+				if (of.stream.is_open())
+				{
+					of.Datetime() << " [" << context << "] " <<
+						p << " " << tag << " already freed. " <<
+						"(" << file << " line:" << line << ")" <<
+						std::endl;
+#ifndef DBGALLOC_NO_STACKTRACE
+					PrintStack(of.stream);
+#endif
+				}
+			}
+		}
+		else
+		{
+			ScopedOutputFile of(DBGALLOC_LOG_FILENAME);
+			if (of.stream.is_open())
+			{
+				of.Datetime() << " [" << context << "] " <<
+					p << " is not a valid entry. " <<
+					"(" << file << " line:" << line << ")" <<
+					std::endl;
+#ifndef DBGALLOC_NO_STACKTRACE
+				PrintStack(of.stream);
+#endif
+			}
+		}
+		return false;
+	}
+
+	// Prints out memory leak report.
+	void DumpLeakReport()
+	{
+		AllocMapType::iterator it = alloc_map_.begin(), end = alloc_map_.end();
+		for (; it != end; ++it)
+		{
+			if (it->second.in_use)
+			{
+				break;
+			}
+		}
+		if (it == end)
+			return;
+
+		ScopedOutputFile of(DBGALLOC_REPORT_FILENAME);
+		if (!of.stream.is_open())
+		{
+			return;
+		}
+		of.Datetime() << std::endl;
+		for (; it != end; ++it)
+		{
+			AllocTag& tag = it->second;
+			if (tag.in_use)
+			{
+				of.stream << "[leak] " << it->first << " " << tag << std::endl;
+			}
+		}
+	}
+
+#ifndef DBGALLOC_NO_STACKTRACE
+	void PrintStack(std::ostream& out)
+	{
+		void* array[200];
+		std::size_t size;
+		char** symbols;
+
+		size = backtrace(array, 200);
+		symbols = backtrace_symbols(array, size);
+
+		out << std::endl;
+
+		for (std::size_t i = 0; i < size; ++i)
+		{
+			out << "Stack> " << symbols[i] << std::endl;
+		}
+
+		free(symbols);
+	}
+#endif
+
+	typedef std::unordered_map<void*, AllocTag> AllocMapType;
+
+	Detail detail_;
+	AllocMapType alloc_map_;
+};
+
+#endif // __INC_DEBUG_ADAPTER_H__
--- a/server/metin2/Source/Server/db/src/ClientManager.cpp
+++ b/server/metin2/Source/Server/db/src/ClientManager.cpp
@@ -1,5926 +1,5934 @@
-#include "stdafx.h"
-
-#include "../../common/building.h"
-#include "../../common/VnumHelper.h"
-#include "../../libgame/include/grid.h"
-
-#include "ClientManager.h"
-
-#include "Main.h"
-#include "Config.h"
-#include "DBManager.h"
-#include "QID.h"
-#include "GuildManager.h"
-#include "PrivManager.h"
-#include "MoneyLog.h"
-#include "ItemAwardManager.h"
-#include "Marriage.h"
-#include "Monarch.h"
-#include "BlockCountry.h"
-#include "ItemIDRangeManager.h"
-#include "Cache.h"
-
-#include <sstream>
-#if defined(__SHOP_SEARCH__)
-	#include "ShopSearchManager.h"
-#endif
-
-extern int g_iPlayerCacheFlushSeconds;
-extern int g_iItemCacheFlushSeconds;
-extern int g_test_server;
-extern int g_log;
-extern std::string g_stLocale;
-extern std::string g_stLocaleNameColumn;
-bool CreateItemTableFromRes(MYSQL_RES* res, std::vector<TPlayerItem>* pVec, DWORD dwPID);
-
-DWORD g_dwUsageMax = 0;
-DWORD g_dwUsageAvg = 0;
-
-CPacketInfo g_query_info;
-CPacketInfo g_item_info;
-
-int g_item_count = 0;
-int g_query_count[2];
-
-CClientManager::CClientManager() :
-	m_pkAuthPeer(NULL),
-	m_iPlayerIDStart(0),
-	m_iPlayerDeleteLevelLimit(0),
-	m_iPlayerDeleteLevelLimitLower(0),
-	m_bChinaEventServer(false),
-	m_iShopTableSize(0),
-	m_pShopTable(NULL),
-	m_iRefineTableSize(0),
-	m_pRefineTable(NULL),
-	m_bShutdowned(false),
-	m_iCacheFlushCount(0),
-	m_iCacheFlushCountLimit(200)
-#if defined(__EXPRESSING_EMOTIONS__)
-	, m_iEmoteDumpDelay(3600)
-#endif
-#if defined(__MAILBOX__)
-	, m_iMailBoxBackupSec(3600)
-#endif
-#if defined(__GEM_SHOP__)
-	, m_iGemShopFlushDelay(3600)
-#endif
-{
-	m_itemRange.dwMin = 0;
-	m_itemRange.dwMax = 0;
-	m_itemRange.dwUsableItemIDMin = 0;
-
-	memset(g_query_count, 0, sizeof(g_query_count));
-}
-
-CClientManager::~CClientManager()
-{
-	Destroy();
-}
-
-void CClientManager::SetPlayerIDStart(int iIDStart)
-{
-	m_iPlayerIDStart = iIDStart;
-}
-
-void CClientManager::Destroy()
-{
-	m_mChannelStatus.clear();
-	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		(*i)->Destroy();
-
-	m_peerList.clear();
-
-	if (m_fdAccept > 0)
-	{
-		socket_close(m_fdAccept);
-		m_fdAccept = -1;
-	}
-}
-
-bool CClientManager::Initialize()
-{
-	int tmpValue;
-
-	// BOOT_LOCALIZATION
-	if (!InitializeLocalization())
-	{
-		fprintf(stderr, "Failed Localization Infomation so exit\n");
-		return false;
-	}
-	// END_BOOT_LOCALIZATION
-
-	// ITEM_UNIQUE_ID
-	if (!InitializeNowItemID())
-	{
-		fprintf(stderr, " Item range Initialize Failed. Exit DBCache Server\n");
-		return false;
-	}
-	// END_ITEM_UNIQUE_ID
-
-	m_bWolfmanCharacter = true;
-	int iWolfmanCharacter = 0;
-	if (CConfig::instance().GetValue("WOLFMAN_CHARACTER", &iWolfmanCharacter))
-		m_bWolfmanCharacter = (iWolfmanCharacter);
-	sys_log(0, "WOLFMAN_CHARACTER %s", m_bWolfmanCharacter ? "true" : "false");
-
-	m_bDelayedCharacterCreation = true;
-	int iDelayedCharacterCreation = 0;
-	if (CConfig::instance().GetValue("DELAYED_CHARACTER_CREATION", &iDelayedCharacterCreation))
-		m_bDelayedCharacterCreation = (iDelayedCharacterCreation);
-	sys_log(0, "DELAYED_CHARACTER_CREATION %s", m_bDelayedCharacterCreation ? "true" : "false");
-
-	if (!InitializeTables())
-	{
-		sys_err("Table Initialize FAILED");
-		return false;
-	}
-
-	CGuildManager::instance().BootReserveWar();
-
-	if (!CConfig::instance().GetValue("BIND_PORT", &tmpValue))
-		tmpValue = 5300;
-
-	char szBindIP[128];
-
-	if (!CConfig::instance().GetValue("BIND_IP", szBindIP, 128))
-		strlcpy(szBindIP, "0", sizeof(szBindIP));
-
-	m_fdAccept = socket_tcp_bind(szBindIP, tmpValue);
-
-	if (m_fdAccept < 0)
-	{
-		perror("socket");
-		return false;
-	}
-
-	sys_log(0, "ACCEPT_HANDLE: %u", m_fdAccept);
-	fdwatch_add_fd(m_fdWatcher, m_fdAccept, NULL, FDW_READ, false);
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	CConfig::instance().GetValue("EMOTE_DUMP_DELAY", &m_iEmoteDumpDelay);
-#endif
-
-#if defined(__MAILBOX__)
-	CConfig::instance().GetValue("MAILBOX_BACKUP_SEC", &m_iMailBoxBackupSec);
-#endif
-
-#if defined(__GEM_SHOP__)
-	CConfig::instance().GetValue("GEM_SHOP_FLUSH_DELAY", &m_iGemShopFlushDelay);
-#endif
-
-	if (!CConfig::instance().GetValue("BACKUP_LIMIT_SEC", &tmpValue))
-		tmpValue = 600;
-
-	m_looping = true;
-
-	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT", &m_iPlayerDeleteLevelLimit))
-	{
-		sys_err("config.txt: Cannot find PLAYER_DELETE_LEVEL_LIMIT, use default level %d", PLAYER_MAX_LEVEL_CONST + 1);
-		m_iPlayerDeleteLevelLimit = PLAYER_MAX_LEVEL_CONST + 1;
-	}
-
-	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT_LOWER", &m_iPlayerDeleteLevelLimitLower))
-	{
-		m_iPlayerDeleteLevelLimitLower = 0;
-	}
-
-	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT set to %d", m_iPlayerDeleteLevelLimit);
-	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT_LOWER set to %d", m_iPlayerDeleteLevelLimitLower);
-
-	m_bChinaEventServer = false;
-
-	int iChinaEventServer = 0;
-
-	if (CConfig::instance().GetValue("CHINA_EVENT_SERVER", &iChinaEventServer))
-		m_bChinaEventServer = (iChinaEventServer);
-
-	sys_log(0, "CHINA_EVENT_SERVER %s", CClientManager::instance().IsChinaEventServer() ? "true" : "false");
-
-	LoadEventFlag();
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	LoadGuildEventFlag();
-#endif
-
-	// database character-set을 강제로 맞춤
-	if (g_stLocale == "big5" || g_stLocale == "sjis")
-		CDBManager::instance().QueryLocaleSet();
-
-	return true;
-}
-
-void CClientManager::MainLoop()
-{
-	SQLMsg* tmp;
-
-	sys_log(0, "ClientManager pointer is %p", this);
-
-	// 메인루프
-	while (!m_bShutdowned)
-	{
-		while ((tmp = CDBManager::instance().PopResult()))
-		{
-			AnalyzeQueryResult(tmp);
-			delete tmp;
-		}
-
-		if (!Process())
-			break;
-
-		log_rotate();
-	}
-
-	//
-	// 메인루프 종료처리
-	//
-	sys_log(0, "MainLoop exited, Starting cache flushing");
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	CClientManager::instance().QUERY_EMOTE_DUMP();
-#endif
-
-#if defined(__MAILBOX__)
-	CClientManager::instance().MAILBOX_BACKUP();
-#endif
-
-#if defined(__GEM_SHOP__)
-	// Gem Shop Item Data List Flush
-	CClientManager::instance().FlushGemShop();
-#endif
-
-	signal_timer_disable();
-
-	// 플레이어 테이블 캐쉬 플러쉬
-	auto it = m_map_playerCache.begin();
-	while (it != m_map_playerCache.end())
-	{
-		CPlayerTableCache* c = (it++)->second;
-
-		c->Flush();
-		delete c;
-	}
-	m_map_playerCache.clear();
-
-	// 아이템 플러쉬
-	auto it2 = m_map_itemCache.begin();
-	while (it2 != m_map_itemCache.end())
-	{
-		CItemCache* c = (it2++)->second;
-
-		c->Flush();
-		delete c;
-	}
-	m_map_itemCache.clear();
-
-	// MYSHOP_PRICE_LIST
-	//
-	// 개인상점 아이템 가격 리스트 Flush
-	//
-	for (auto itPriceList = m_mapItemPriceListCache.begin(); itPriceList != m_mapItemPriceListCache.end(); ++itPriceList)
-	{
-		CItemPriceListTableCache* pCache = itPriceList->second;
-		pCache->Flush();
-		delete pCache;
-	}
-
-	m_mapItemPriceListCache.clear();
-#ifdef __OFFLINE_SHOP__
-	FlushOfflineShops();
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	auto growthPetCache = m_map_growthPetCache.begin();
-
-	while (growthPetCache != m_map_growthPetCache.end())
-	{
-		CGrowthPetCache* c = (growthPetCache++)->second;
-
-		c->Flush();
-		delete c;
-	}
-	m_map_growthPetCache.clear();
-#endif
-
-	// END_OF_MYSHOP_PRICE_LIST
-}
-
-void CClientManager::Quit()
-{
-	m_bShutdowned = true;
-}
-
-void CClientManager::QUERY_BOOT(CPeer* peer, TPacketGDBoot* p)
-{
-	const BYTE bPacketVersion = 6; // BOOT 패킷이 바뀔때마다 번호를 올리도록 한다.
-
-	std::vector<tAdminInfo> vAdmin;
-	std::vector<std::string> vHost;
-
-	__GetHostInfo(vHost);
-	__GetAdminInfo(p->szIP, vAdmin);
-
-	sys_log(0, "QUERY_BOOT : AdminInfo (Request ServerIp %s) ", p->szIP);
-
-	DWORD dwPacketSize =
-		sizeof(DWORD) +
-		sizeof(BYTE) +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TShopTable) * m_iShopTableSize +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemAttrTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemRareTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(building::TLand) * m_vec_kLandTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObjectProto) * m_vec_kObjectProto.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObject) * m_map_pkObjectTable.size() +
-#ifdef __GROWTH_PET_SYSTEM__
-		sizeof(WORD) + sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size() +
-#endif
-		sizeof(time_t) +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemIDRangeTable) * 2 +
-		// ADMIN_MANAGER
-		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
-		// END_ADMIN_MANAGER
-		sizeof(WORD) + sizeof(WORD) + sizeof(TMonarchInfo) +
-		sizeof(WORD) + sizeof(WORD) + sizeof(MonarchCandidacy) * CMonarch::instance().MonarchCandidacySize() +
-		sizeof(WORD);
-
-	peer->EncodeHeader(HEADER_DG_BOOT, 0, dwPacketSize);
-	peer->Encode(&dwPacketSize, sizeof(DWORD));
-	peer->Encode(&bPacketVersion, sizeof(BYTE));
-
-	sys_log(0, "BOOT: PACKET: %d", dwPacketSize);
-	sys_log(0, "BOOT: VERSION: %d", bPacketVersion);
-
-	sys_log(0, "sizeof(TMobTable) = %d", sizeof(TMobTable));
-	sys_log(0, "sizeof(TItemTable) = %d", sizeof(TItemTable));
-	sys_log(0, "sizeof(TShopTable) = %d", sizeof(TShopTable));
-	sys_log(0, "sizeof(TSkillTable) = %d", sizeof(TSkillTable));
-	sys_log(0, "sizeof(TRefineTable) = %d", sizeof(TRefineTable));
-	sys_log(0, "sizeof(TItemAttrTable) = %d", sizeof(TItemAttrTable));
-	sys_log(0, "sizeof(TItemRareTable) = %d", sizeof(TItemAttrTable));
-	sys_log(0, "sizeof(TBanwordTable) = %d", sizeof(TBanwordTable));
-	sys_log(0, "sizeof(TLand) = %d", sizeof(building::TLand));
-	sys_log(0, "sizeof(TObjectProto) = %d", sizeof(building::TObjectProto));
-	sys_log(0, "sizeof(TObject) = %d", sizeof(building::TObject));
-	// ADMIN_MANAGER
-	sys_log(0, "sizeof(tAdminInfo) = %d * %d ", sizeof(tAdminInfo) * vAdmin.size());
-	// END_ADMIN_MANAGER
-	sys_log(0, "sizeof(TMonarchInfo) = %d * %d", sizeof(TMonarchInfo));
-#ifdef __GROWTH_PET_SYSTEM__
-	sys_log(0, "sizeof(TGrowthPetSkillTable) = %d", sizeof(TGrowthPetSkillTable));
-#endif
-
-	peer->EncodeWORD(sizeof(TMobTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
-	peer->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
-
-	peer->EncodeWORD(sizeof(TItemTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
-	peer->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
-
-	peer->EncodeWORD(sizeof(TShopTable));
-	peer->EncodeWORD(m_iShopTableSize);
-	peer->Encode(m_pShopTable, sizeof(TShopTable) * m_iShopTableSize);
-
-	peer->EncodeWORD(sizeof(TSkillTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
-	peer->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
-
-	peer->EncodeWORD(sizeof(TRefineTable));
-	peer->EncodeWORD(m_iRefineTableSize);
-	peer->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
-
-	peer->EncodeWORD(sizeof(TItemAttrTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_itemAttrTable.size()));
-	peer->Encode(&m_vec_itemAttrTable[0], sizeof(TItemAttrTable) * m_vec_itemAttrTable.size());
-
-	peer->EncodeWORD(sizeof(TItemAttrTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_itemRareTable.size()));
-	peer->Encode(&m_vec_itemRareTable[0], sizeof(TItemAttrTable) * m_vec_itemRareTable.size());
-
-	peer->EncodeWORD(sizeof(TBanwordTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
-	peer->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
-
-	peer->EncodeWORD(sizeof(building::TLand));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_kLandTable.size()));
-	peer->Encode(&m_vec_kLandTable[0], sizeof(building::TLand) * m_vec_kLandTable.size());
-
-	peer->EncodeWORD(sizeof(building::TObjectProto));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_kObjectProto.size()));
-	peer->Encode(&m_vec_kObjectProto[0], sizeof(building::TObjectProto) * m_vec_kObjectProto.size());
-
-	peer->EncodeWORD(sizeof(building::TObject));
-	peer->EncodeWORD(static_cast<WORD>(m_map_pkObjectTable.size()));
-
-	auto it = m_map_pkObjectTable.begin();
-	while (it != m_map_pkObjectTable.end())
-		peer->Encode((it++)->second, sizeof(building::TObject));
-
-#ifdef __GROWTH_PET_SYSTEM__
-	peer->EncodeWORD(sizeof(TGrowthPetSkillTable));
-	peer->EncodeWORD(m_vec_growthPetSkillTable.size());
-	if (m_vec_growthPetSkillTable.size())
-		peer->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
-#endif
-
-	time_t now = time(0);
-	peer->Encode(&now, sizeof(time_t));
-
-	TItemIDRangeTable itemRange = CItemIDRangeManager::instance().GetRange();
-	TItemIDRangeTable itemRangeSpare = CItemIDRangeManager::instance().GetRange();
-
-	peer->EncodeWORD(sizeof(TItemIDRangeTable));
-	peer->EncodeWORD(1);
-	peer->Encode(&itemRange, sizeof(TItemIDRangeTable));
-	peer->Encode(&itemRangeSpare, sizeof(TItemIDRangeTable));
-
-	peer->SetItemIDRange(itemRange);
-	peer->SetSpareItemIDRange(itemRangeSpare);
-
-	// ADMIN_MANAGER
-	peer->EncodeWORD(16);
-	peer->EncodeWORD(static_cast<WORD>(vHost.size()));
-
-	for (size_t n = 0; n < vHost.size(); ++n)
-	{
-		peer->Encode(vHost[n].c_str(), 16);
-		sys_log(0, "GMHosts %s", vHost[n].c_str());
-	}
-
-	peer->EncodeWORD(sizeof(tAdminInfo));
-	peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
-
-	for (size_t n = 0; n < vAdmin.size(); ++n)
-	{
-		peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
-		sys_log(0, "Admin name %s ConntactIP %s", vAdmin[n].m_szName, vAdmin[n].m_szContactIP);
-	}
-	// END_ADMIN_MANAGER
-
-	// MONARCH
-	peer->EncodeWORD(sizeof(TMonarchInfo));
-	peer->EncodeWORD(1);
-	peer->Encode(CMonarch::instance().GetMonarch(), sizeof(TMonarchInfo));
-
-	CMonarch::VEC_MONARCHCANDIDACY& rVecMonarchCandidacy = CMonarch::instance().GetVecMonarchCandidacy();
-
-	size_t num_monarch_candidacy = CMonarch::instance().MonarchCandidacySize();
-	peer->EncodeWORD(sizeof(MonarchCandidacy));
-	peer->EncodeWORD(static_cast<WORD>(num_monarch_candidacy));
-	if (num_monarch_candidacy != 0)
-	{
-		peer->Encode(&rVecMonarchCandidacy[0], sizeof(MonarchCandidacy) * num_monarch_candidacy);
-	}
-	// END_MONARCE
-
-	if (g_test_server)
-		sys_log(0, "MONARCHCandidacy Size %d", CMonarch::instance().MonarchCandidacySize());
-
-#ifdef __OFFLINE_SHOP__
-	peer->EncodeDWORD(sizeof(TOfflineShop));
-	peer->EncodeDWORD(offlineShopCache_.size());
-	for (const auto& entry : offlineShopCache_) {
-		peer->Encode(entry.second->Get(), sizeof(TOfflineShop));
-	}
-
-	peer->EncodeDWORD(sizeof(TOfflineShopItem));
-	peer->EncodeDWORD(offlineShopItemCache_.size());
-	for (const auto& entry : offlineShopItemCache_) {
-		peer->Encode(entry.second->Get(), sizeof(TOfflineShopItem));
-	}
-#endif
-
-	peer->EncodeWORD(0xffff);
-}
-
-void CClientManager::SendPartyOnSetup(CPeer* pkPeer)
-{
-	TPartyMap& pm = m_map_pkChannelParty[pkPeer->GetChannel()];
-	for (auto it_party = pm.begin(); it_party != pm.end(); ++it_party)
-	{
-		sys_log(0, "PARTY SendPartyOnSetup Party [%u]", it_party->first);
-		pkPeer->EncodeHeader(HEADER_DG_PARTY_CREATE, 0, sizeof(TPacketPartyCreate));
-		pkPeer->Encode(&it_party->first, sizeof(DWORD));
-
-		for (auto it_member = it_party->second.begin(); it_member != it_party->second.end(); ++it_member)
-		{
-			sys_log(0, "PARTY SendPartyOnSetup Party [%u] Member [%u]", it_party->first, it_member->first);
-			pkPeer->EncodeHeader(HEADER_DG_PARTY_ADD, 0, sizeof(TPacketPartyAdd));
-			pkPeer->Encode(&it_party->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->second.bRole, sizeof(BYTE));
-
-			pkPeer->EncodeHeader(HEADER_DG_PARTY_SET_MEMBER_LEVEL, 0, sizeof(TPacketPartySetMemberLevel));
-			pkPeer->Encode(&it_party->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->second.bLevel, sizeof(BYTE));
-		}
-	}
-}
-
-void CClientManager::QUERY_PLAYER_COUNT(CPeer* pkPeer, TPlayerCountPacket* pPacket)
-{
-	pkPeer->SetUserCount(pPacket->dwCount);
-}
-
-void CClientManager::QUERY_QUEST_SAVE(CPeer* pkPeer, TQuestTable* pTable, DWORD dwLen)
-{
-	if (0 != (dwLen % sizeof(TQuestTable)))
-	{
-		sys_err("invalid packet size %d, sizeof(TQuestTable) == %d", dwLen, sizeof(TQuestTable));
-		return;
-	}
-
-	int iSize = dwLen / sizeof(TQuestTable);
-
-	char szQuery[1024];
-
-	for (int i = 0; i < iSize; ++i, ++pTable)
-	{
-		if (pTable->lValue == 0)
-		{
-			snprintf(szQuery, sizeof(szQuery), "DELETE FROM quest%s WHERE `dwPID` = %d AND `szName` = '%s' AND `szState` ='%s'",
-				GetTablePostfix(), pTable->dwPID, pTable->szName, pTable->szState);
-		}
-		else
-		{
-			snprintf(szQuery, sizeof(szQuery), "REPLACE INTO quest%s (`dwPID`, `szName`, `szState`, `lValue`) VALUES(%d, '%s', '%s', %ld)",
-				GetTablePostfix(), pTable->dwPID, pTable->szName, pTable->szState, pTable->lValue);
-		}
-
-		CDBManager::instance().ReturnQuery(szQuery, QID_QUEST_SAVE, pkPeer->GetHandle(), NULL);
-	}
-}
-
-void CClientManager::QUERY_SAFEBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TSafeboxLoadPacket* packet, bool bMall)
-{
-	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
-	strlcpy(pi->safebox_password, packet->szPassword, sizeof(pi->safebox_password));
-	pi->account_id = packet->dwID;
-	pi->account_index = 0;
-	pi->ip[0] = bMall ? 1 : 0;
-	strlcpy(pi->login, packet->szLogin, sizeof(pi->login));
-
-	char szQuery[QUERY_MAX_LEN];
-	snprintf(szQuery, sizeof(szQuery),
-		"SELECT `account_id`, `size`, `password` FROM safebox%s WHERE `account_id` = %u",
-		GetTablePostfix(), packet->dwID);
-
-	if (g_log)
-		sys_log(0, "HEADER_GD_SAFEBOX_LOAD (handle: %d account.id %u is_mall %d)", dwHandle, packet->dwID, bMall ? 1 : 0);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
-}
-
-void CClientManager::RESULT_SAFEBOX_LOAD(CPeer* pkPeer, SQLMsg* msg)
-{
-	sys_log(0, "RESULT_SAFEBOX_LOAD");
-
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = pi->dwHandle;
-
-	// 여기에서 사용하는 account_index는 쿼리 순서를 말한다.
-	// 첫번째 패스워드 알아내기 위해 하는 쿼리가 0
-	// 두번째 실제 데이터를 얻어놓는 쿼리가 1
-
-	if (pi->account_index == 0)
-	{
-		sys_log(0, "RESULT_SAFEBOX_LOAD account_index == 0");
-
-		char szSafeboxPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
-		strlcpy(szSafeboxPassword, pi->safebox_password, sizeof(szSafeboxPassword));
-
-		TSafeboxTable* pSafebox = new TSafeboxTable;
-		memset(pSafebox, 0, sizeof(TSafeboxTable));
-
-		SQLResult* res = msg->Get();
-
-		if (res->uiNumRows == 0)
-		{
-			if (strcmp("000000", szSafeboxPassword))
-			{
-				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
-				delete pSafebox;
-				delete pi;
-				return;
-			}
-		}
-		else
-		{
-			sys_log(0, "RESULT_SAFEBOX_LOAD get rows");
-
-			MYSQL_ROW row = mysql_fetch_row(res->pSQLResult);
-
-			// 비밀번호가 틀리면..
-			if (((!row[2] || !*row[2]) && strcmp("000000", szSafeboxPassword)) ||
-				((row[2] && *row[2]) && strcmp(row[2], szSafeboxPassword)))
-			{
-				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
-				delete pSafebox;
-				delete pi;
-				return;
-			}
-
-			if (!row[0])
-				pSafebox->dwID = 0;
-			else
-				str_to_number(pSafebox->dwID, row[0]);
-
-			if (!row[1])
-				pSafebox->bSize = 0;
-			else
-				str_to_number(pSafebox->bSize, row[1]);
-			/*
-			if (!row[3])
-				pSafebox->dwGold = 0;
-			else
-				pSafebox->dwGold = atoi(row[3]);
-			*/
-			if (pi->ip[0] == 1)
-			{
-#if defined(__EXTEND_MALLBOX__)
-				pSafebox->bSize = 5;
-#else
-				pSafebox->bSize = 1;
-#endif
-				sys_log(0, "MALL id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
-			}
-			else
-				sys_log(0, "SAFEBOX id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
-		}
-
-		if (0 == pSafebox->dwID)
-			pSafebox->dwID = pi->account_id;
-
-		pi->pSafebox = pSafebox;
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
-#if defined(__SOUL_BIND_SYSTEM__)
-			", `soulbind`"
-#endif
-			", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-			", `socket3`, `socket4`, `socket5`"
-#endif
-			", `attrtype0`, `attrvalue0`"
-			", `attrtype1`, `attrvalue1`"
-			", `attrtype2`, `attrvalue2`"
-			", `attrtype3`, `attrvalue3`"
-			", `attrtype4`, `attrvalue4`"
-			", `attrtype5`, `attrvalue5`"
-			", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			", `transmutation`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			", `refine_element_apply_type`"
-			", `refine_element_grade`"
-			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			", `apply_type0`, `apply_value0`, `apply_path0`"
-			", `apply_type1`, `apply_value1`, `apply_path1`"
-			", `apply_type2`, `apply_value2`, `apply_path2`"
-			", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-			", `set_value`"
-#endif
-			" FROM `item%s` WHERE `owner_id` = %u AND `window` = '%s'",
-			GetTablePostfix(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL");
-
-		pi->account_index = 1;
-
-		CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
-	}
-	else
-	{
-		sys_log(0, "RESULT_SAFEBOX_LOAD YES!!!!!!!!!!!");
-
-		if (!pi->pSafebox)
-		{
-			sys_err("null safebox pointer!");
-			delete pi;
-			return;
-		}
-
-		// 쿼리에 에러가 있었으므로 응답할 경우 창고가 비어있는 것 처럼
-		// 보이기 때문에 창고가 아얘 안열리는게 나음
-		if (!msg->Get()->pSQLResult)
-		{
-			sys_err("null safebox result");
-			delete pi;
-			return;
-		}
-
-		static std::vector<TPlayerItem> s_items;
-		CreateItemTableFromRes(msg->Get()->pSQLResult, &s_items, pi->account_id);
-
-		ItemAwardSet* pSet = ItemAwardManager::instance().GetByLogin(pi->login);
-
-		if (pSet && !m_vec_itemTable.empty())
-		{
-#if defined(__EXTEND_MALLBOX__)
-			CGrid grid(5, MAX(1, 5) * 9);
-#else
-			CGrid grid(5, MAX(1, pi->pSafebox->bSize) * 9);
-#endif
-			bool bEscape = false;
-
-			for (DWORD i = 0; i < s_items.size(); ++i)
-			{
-				TPlayerItem& r = s_items[i];
-
-				auto it = m_map_itemTableByVnum.find(r.dwVnum);
-				if (it == m_map_itemTableByVnum.end())
-				{
-					bEscape = true;
-					sys_err("invalid item vnum %u in safebox: login %s", r.dwVnum, pi->login);
-					break;
-				}
-
-				grid.Put(r.wPos, 1, it->second->bSize);
-			}
-
-			if (!bEscape)
-			{
-				std::vector<std::pair<DWORD, DWORD> > vec_dwFinishedAwardID;
-				ItemAwardSet::const_iterator it = pSet->begin();
-				char szQuery[512];
-
-				while (it != pSet->end())
-				{
-					TItemAward* pItemAward = *(it++);
-					const DWORD& dwItemVnum = pItemAward->dwVnum;
-
-					if (pItemAward->bTaken)
-						continue;
-
-					if (pi->ip[0] == 0 && pItemAward->bMall)
-						continue;
-
-					if (pi->ip[0] == 1 && !pItemAward->bMall)
-						continue;
-
-					auto it = m_map_itemTableByVnum.find(pItemAward->dwVnum);
-					if (it == m_map_itemTableByVnum.end())
-					{
-						sys_err("invalid item vnum %u in item_award: login %s", pItemAward->dwVnum, pi->login);
-						continue;
-					}
-
-					TItemTable* pItemTable = it->second;
-
-					int iPos;
-
-					if ((iPos = grid.FindBlank(1, it->second->bSize)) == -1)
-						break;
-
-					TPlayerItem item;
-					memset(&item, 0, sizeof(TPlayerItem));
-
-#if defined(__EXTENDED_ITEM_AWARD__)
-					DWORD dwSocket0 = pItemAward->dwSocket0;
-					DWORD dwSocket2 = pItemAward->dwSocket2;
-					DWORD dwSocket4 = pItemAward->dwSocket4;
-					DWORD dwSocket5 = pItemAward->dwSocket5;
-#else
-					DWORD dwSocket2 = 0;
-#endif
-
-					if (pItemTable->bType == ITEM_UNIQUE)
-					{
-#if defined(__EXTENDED_ITEM_AWARD__)
-						// 12.04.2019 - Correction for unique items based on the real time.
-						const long lValue0 = pItemTable->alValues[ITEM_SOCKET_REMAIN_SEC];
-						const long lValue2 = pItemTable->alValues[ITEM_SOCKET_UNIQUE_REMAIN_TIME];
-						const time_t tNow = CClientManager::instance().GetCurrentTime();
-						dwSocket2 = (lValue2 == 0) ? static_cast<DWORD>(lValue0) : static_cast<DWORD>(tNow + lValue0);
-#else
-						if (pItemAward->dwSocket2 != 0)
-							dwSocket2 = pItemAward->dwSocket2;
-						else
-							dwSocket2 = pItemTable->alValues[0];
-#endif
-					}
-					else if ((dwItemVnum == ITEM_SKILLBOOK_VNUM || dwItemVnum == ITEM_SKILLFORGET_VNUM) && pItemAward->dwSocket0 == 0)
-					{
-						DWORD dwSkillIdx;
-						DWORD dwSkillVnum;
-
-						do
-						{
-							dwSkillIdx = number(0, m_vec_skillTable.size() - 1);
-
-							dwSkillVnum = m_vec_skillTable[dwSkillIdx].dwVnum;
-
-							if (dwSkillVnum > 120)
-								continue;
-
-							break;
-						} while (1);
-
-#if !defined(__EXTENDED_ITEM_AWARD__)
-						pItemAward->dwSocket0 = dwSkillVnum;
-#endif
-					}
-					else
-					{
-						switch (dwItemVnum)
-						{
-							case 72723: case 72724: case 72725: case 72726:
-							case 72727: case 72728: case 72729: case 72730:
-								// 무시무시하지만 이전에 하던 걸 고치기는 무섭고...
-								// 그래서 그냥 하드 코딩. 선물 상자용 자동물약 아이템들.
-							case 76004: case 76005: case 76021: case 76022:
-							case 79012: case 79013:
-								if (pItemAward->dwSocket2 == 0)
-								{
-									dwSocket2 = pItemTable->alValues[0];
-								}
-								else
-								{
-									dwSocket2 = pItemAward->dwSocket2;
-								}
-								break;
-						}
-					}
-
-					if (GetItemID() > m_itemRange.dwMax)
-					{
-						sys_err("UNIQUE ID OVERFLOW!!");
-						break;
-					}
-
-					{
-						auto it = m_map_itemTableByVnum.find(dwItemVnum);
-						if (it == m_map_itemTableByVnum.end())
-						{
-							sys_err("Invalid item(vnum : %d). It is not in m_map_itemTableByVnum.", dwItemVnum);
-							continue;
-						}
-						TItemTable* item_table = it->second;
-						if (item_table == NULL)
-						{
-							sys_err("Invalid item_table (vnum : %d). It's value is NULL in m_map_itemTableByVnum.", dwItemVnum);
-							continue;
-						}
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-						if ((item_table->bType == ITEM_UNIQUE && item_table->bType == COSTUME_MOUNT))
-						{
-							if (pItemAward->dwSocket4 == 0)
-								dwSocket4 = pItemTable->alValues[0];
-							else
-								dwSocket4 = pItemAward->dwSocket4;
-						}
-#endif
-
-						if (0 == pItemAward->dwSocket0)
-						{
-							// Load default values
-							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-							{
-								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
-									break;
-								}
-								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
-									break;
-								}
-							}
-						}
-						else
-						{
-#if defined(__EXTENDED_ITEM_AWARD__)
-							// Load set values
-							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-							{
-								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
-								{
-									dwSocket0 = time(0) + pItemAward->dwSocket0;
-									break;
-								}
-								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
-								{
-									dwSocket0 = pItemAward->dwSocket0;
-									break;
-								}
-							}
-#else
-							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-							{
-								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
-
-									break;
-								}
-								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
-
-									break;
-								}
-							}
-#endif
-						}
-
-#if defined(__EXTENDED_ITEM_AWARD__)
-						ItemAwardManager::instance().CheckItemCount(*pItemAward, *pItemTable);
-						ItemAwardManager::instance().CheckItemBlend(*pItemAward, *pItemTable);
-						ItemAwardManager::instance().CheckItemAddonType(*pItemAward, *pItemTable);
-						ItemAwardManager::instance().CheckItemSkillBook(*pItemAward, m_vec_skillTable);
-						ItemAwardManager::instance().CheckItemAttributes(*pItemAward, *pItemTable, m_vec_itemAttrTable);
-
-						// START_OF_AUTO_QUERY
-						char szColumns[QUERY_MAX_LEN], szValues[QUERY_MAX_LEN];
-
-						int iLen = snprintf(szColumns, sizeof(szColumns), "`id`, `owner_id`, `window`, `pos`, `vnum`, `count`");
-						int iValueLen = snprintf(szValues, sizeof(szValues), "%u, %u, '%s', %d, %u, %u", GainItemID(), pi->account_id, (pi->ip[0] == 0) ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount);
-
-#if defined(__ITEM_SOCKET6__)
-						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`, `socket3`, `socket4`, `socket5`");
-						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u, %u, %u, %u", dwSocket0, pItemAward->dwSocket1, dwSocket2, pItemAward->dwSocket3, pItemAward->dwSocket4, pItemAward->dwSocket5);
-#else
-						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`");
-						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u", pItemAward->dwSocket0, pItemAward->dwSocket1, dwSocket2);
-#endif
-
-						for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
-						{
-							iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `attrtype%d`, `attrvalue%d`", i, i);
-							iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %ld", pItemAward->aAttr[i].wType, pItemAward->aAttr[i].lValue);
-						}
-						// END_OF_AUTO_QUERY
-
-						snprintf(szQuery, sizeof(szQuery), "INSERT INTO item%s (%s) VALUES(%s)", GetTablePostfix(), szColumns, szValues);
-#else
-						snprintf(szQuery, sizeof(szQuery),
-							"INSERT INTO item%s (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
-							", `socket0`"
-							", `socket1`"
-							", `socket2`"
-#if defined(__ITEM_SOCKET6__)
-							", `socket3`"
-							", `socket4`"
-							", `socket5`"
-#endif
-							") VALUES (%u, %u, '%s', %d, %u, %u"
-							", %u"
-							", %u"
-							", %u"
-#if defined(__ITEM_SOCKET6__)
-							", %u"
-							", %u"
-							", %u"
-#endif
-							")",
-							GetTablePostfix(), GainItemID(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount
-							, pItemAward->dwSocket0
-							, pItemAward->dwSocket1
-							, dwSocket2
-#if defined(__ITEM_SOCKET6__)
-							, pItemAward->dwSocket3
-							, pItemAward->dwSocket4
-							, pItemAward->dwSocket5
-#endif
-						);
-#endif
-					}
-
-					std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-					SQLResult* pRes = pmsg->Get();
-					sys_log(0, "SAFEBOX Query : [%s]", szQuery);
-
-					if (pRes->uiAffectedRows == 0 || pRes->uiInsertID == 0 || pRes->uiAffectedRows == (uint32_t)-1)
-						break;
-
-					item.dwID = pmsg->Get()->uiInsertID;
-					if (pi->ip[0] == 0)
-						item.bWindow = SAFEBOX, item.wPos = iPos;
-					else
-						item.bWindow = MALL, item.wPos = iPos;
-					item.dwVnum = pItemAward->dwVnum;
-					item.dwCount = pItemAward->dwCount;
-#if defined(__EXTENDED_ITEM_AWARD__)
-					item.alSockets[0] = dwSocket0;
-#else
-					item.alSockets[0] = pItemAward->dwSocket0;
-#endif
-					item.alSockets[1] = pItemAward->dwSocket1;
-					item.alSockets[2] = dwSocket2;
-#if defined(__ITEM_SOCKET6__)
-					item.alSockets[3] = pItemAward->dwSocket3;
-					item.alSockets[4] = dwSocket4;
-					item.alSockets[5] = dwSocket5;
-#endif
-#if defined(__EXTENDED_ITEM_AWARD__)
-					thecore_memcpy(&item.aAttr, pItemAward->aAttr, sizeof(item.aAttr));
-#endif
-					s_items.push_back(item);
-
-					vec_dwFinishedAwardID.push_back(std::make_pair(pItemAward->dwID, item.dwID));
-					grid.Put(iPos, 1, it->second->bSize);
-				}
-
-				for (DWORD i = 0; i < vec_dwFinishedAwardID.size(); ++i)
-					ItemAwardManager::instance().Taken(vec_dwFinishedAwardID[i].first, vec_dwFinishedAwardID[i].second);
-			}
-		}
-
-		pi->pSafebox->wItemCount = static_cast<WORD>(s_items.size());
-
-#ifdef __GROWTH_PET_SYSTEM__
-		static std::vector<TGrowthPet> s_petVec;
-
-		// Loads pets only when opening safebox with items
-		if (pi->ip[0] == 0 && !s_items.empty())
-		{
-			char szQuery[QUERY_MAX_LEN];
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT id,vnum,state+0,name,size,level,level_step,evolution,type,hp,sp,def,hp_apply,sp_apply,def_apply,"
-				"age_apply,skill_level,exp,item_exp,UNIX_TIMESTAMP(birthday),end_time,max_time "
-				"FROM growth_pet%s WHERE owner_id=%d AND state=%d",
-				GetTablePostfix(), pi->account_id, STATE_SAFEBOX);
-
-			std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(szQuery));
-			MYSQL_RES* pRes = pkMsg->Get()->pSQLResult;
-			CreateGrowthPetTableFromRes(pRes, &s_petVec, pi->account_id);
-		}
-#endif
-
-		if (pi->ip[0] == 0)
-			pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
-#ifdef __GROWTH_PET_SYSTEM__
-			+ sizeof(WORD) + sizeof(TGrowthPet) * s_petVec.size()
-#endif
-		);
-		else
-			pkPeer->EncodeHeader(HEADER_DG_MALL_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
-
-		);
-
-		pkPeer->Encode(pi->pSafebox, sizeof(TSafeboxTable));
-
-		if (!s_items.empty())
-			pkPeer->Encode(&s_items[0], sizeof(TPlayerItem) * s_items.size());
-
-#ifdef __GROWTH_PET_SYSTEM__
-		pkPeer->EncodeWORD((WORD)s_petVec.size());
-
-		if (!s_petVec.empty())
-			pkPeer->Encode(&s_petVec[0], sizeof(TGrowthPet) * s_petVec.size());
-#endif
-
-		delete pi;
-	}
-}
-
-void CClientManager::QUERY_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangeSizePacket* p)
-{
-	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
-	pi->account_index = p->bSize; // account_index를 사이즈로 임시로 사용
-
-	char szQuery[QUERY_MAX_LEN];
-
-	if (p->bSize == 1)
-		snprintf(szQuery, sizeof(szQuery), "INSERT INTO safebox%s (`account_id`, `size`) VALUES(%u, %u)", GetTablePostfix(), p->dwID, p->bSize);
-	else
-		snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `size` = %u WHERE `account_id` = %u", GetTablePostfix(), p->bSize, p->dwID);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_SIZE, pkPeer->GetHandle(), pi);
-}
-
-void CClientManager::RESULT_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = p->dwHandle;
-	BYTE bSize = p->account_index;
-
-	delete p;
-
-	if (msg->Get()->uiNumRows > 0)
-	{
-		pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_SIZE, dwHandle, sizeof(BYTE));
-		pkPeer->EncodeBYTE(bSize);
-	}
-}
-
-void CClientManager::QUERY_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangePasswordPacket* p)
-{
-	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
-	strlcpy(pi->safebox_password, p->szNewPassword, sizeof(pi->safebox_password));
-	strlcpy(pi->login, p->szOldPassword, sizeof(pi->login));
-	pi->account_id = p->dwID;
-
-	char szQuery[QUERY_MAX_LEN];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `password` FROM safebox%s WHERE `account_id` = %u", GetTablePostfix(), p->dwID);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD, pkPeer->GetHandle(), pi);
-}
-
-void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = p->dwHandle;
-
-	if (msg->Get()->uiNumRows > 0)
-	{
-		MYSQL_ROW row = mysql_fetch_row(msg->Get()->pSQLResult);
-
-		if ((row[0] && *row[0] && !strcasecmp(row[0], p->login)) || ((!row[0] || !*row[0]) && !strcmp("000000", p->login)))
-		{
-			char szQuery[QUERY_MAX_LEN];
-			char escape_pwd[64];
-			CDBManager::instance().EscapeString(escape_pwd, p->safebox_password, strlen(p->safebox_password));
-
-			snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `password` = '%s' WHERE `account_id` = %u", GetTablePostfix(), escape_pwd, p->account_id);
-
-			CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD_SECOND, pkPeer->GetHandle(), p);
-			return;
-		}
-	}
-
-	delete p;
-
-	// Wrong old password
-	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
-	pkPeer->EncodeBYTE(0);
-}
-
-void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(CPeer* pkPeer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = p->dwHandle;
-	delete p;
-
-	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
-	pkPeer->EncodeBYTE(1);
-}
-
-// MYSHOP_PRICE_LIST
-void CClientManager::RESULT_PRICELIST_LOAD(CPeer* peer, SQLMsg* pMsg)
-{
-	TItemPricelistReqInfo* pReqInfo = (TItemPricelistReqInfo*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
-
-	//
-	// DB 에서 로드한 정보를 Cache 에 저장
-	//
-
-	TItemPriceListTable table;
-	table.dwOwnerID = pReqInfo->second;
-	table.byCount = 0;
-
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
-		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
-#if defined(__CHEQUE_SYSTEM__)
-		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
-#endif
-		table.byCount++;
-	}
-
-	PutItemPriceListCache(&table);
-
-	//
-	// 로드한 데이터를 Game server 에 전송
-	//
-
-	TPacketMyshopPricelistHeader header;
-
-	header.dwOwnerID = pReqInfo->second;
-	header.byCount = table.byCount;
-
-	size_t sizePriceListSize = sizeof(TItemPriceInfo) * header.byCount;
-
-	peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, pReqInfo->first, sizeof(header) + sizePriceListSize);
-	peer->Encode(&header, sizeof(header));
-	peer->Encode(table.aPriceInfo, sizePriceListSize);
-
-	sys_log(0, "Load MyShopPricelist handle[%d] pid[%d] count[%d]", pReqInfo->first, pReqInfo->second, header.byCount);
-
-	delete pReqInfo;
-}
-
-void CClientManager::RESULT_PRICELIST_LOAD_FOR_UPDATE(SQLMsg* pMsg)
-{
-	TItemPriceListTable* pUpdateTable = (TItemPriceListTable*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
-
-	//
-	// DB 에서 로드한 정보를 Cache 에 저장
-	//
-
-	TItemPriceListTable table{};
-	table.dwOwnerID = pUpdateTable->dwOwnerID;
-	table.byCount = 0;
-
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
-		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
-#if defined(__CHEQUE_SYSTEM__)
-		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
-#endif
-		table.byCount++;
-	}
-
-	PutItemPriceListCache(&table);
-
-	// Update cache
-	GetItemPriceListCache(pUpdateTable->dwOwnerID)->UpdateList(pUpdateTable);
-
-	delete pUpdateTable;
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-void CClientManager::QUERY_SAFEBOX_SAVE(CPeer* pkPeer, TSafeboxTable* pTable)
-{
-	char szQuery[QUERY_MAX_LEN];
-
-	snprintf(szQuery, sizeof(szQuery),
-		"UPDATE safebox%s SET `gold` = '%u' WHERE `account_id` = %u",
-		GetTablePostfix(), pTable->dwGold, pTable->dwID);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_SAVE, pkPeer->GetHandle(), NULL);
-}
-
-void CClientManager::QUERY_EMPIRE_SELECT(CPeer* pkPeer, DWORD dwHandle, TEmpireSelectPacket* p)
-{
-	char szQuery[QUERY_MAX_LEN];
-
-	snprintf(szQuery, sizeof(szQuery), "UPDATE player_index%s SET `empire` = %u WHERE `id` = %u", GetTablePostfix(), p->bEmpire, p->dwAccountID);
-	delete CDBManager::instance().DirectQuery(szQuery);
-
-	sys_log(0, "EmpireSelect: %s", szQuery);
-	{
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `pid1`"
-			", `pid2`"
-			", `pid3`"
-			", `pid4`"
-#if defined(__PLAYER_PER_ACCOUNT5__)
-			", `pid5`"
-#endif
-			" FROM player_index%s WHERE `id` = %u", GetTablePostfix(), p->dwAccountID);
-
-		std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-		SQLResult* pRes = pmsg->Get();
-
-		if (pRes->uiNumRows)
-		{
-			sys_log(0, "EMPIRE %lu", pRes->uiNumRows);
-
-			MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
-			DWORD pids[3];
-
-			UINT g_start_map[4] =
-			{
-				0, // reserved
-				1, // 신수국
-				21, // 천조국
-				41 // 진노국
-			};
-
-			// FIXME share with game
-			DWORD g_start_position[4][2] =
-			{
-				{ 0, 0 },
-				{ 469300, 964200 }, // 신수국
-				{ 55700, 157900 }, // 천조국
-				{ 969600, 278400 } // 진노국
-			};
-
-			for (int i = 0; i < 3; ++i)
-			{
-				str_to_number(pids[i], row[i]);
-				sys_log(0, "EMPIRE PIDS[%d]", pids[i]);
-
-				if (pids[i])
-				{
-					sys_log(0, "EMPIRE move to pid[%d] to villiage of %u, map_index %d",
-						pids[i], p->bEmpire, g_start_map[p->bEmpire]);
-
-					snprintf(szQuery, sizeof(szQuery), "UPDATE player%s SET `map_index` = %u, `x` = %u, `y` = %u WHERE `id` = %u",
-						GetTablePostfix(),
-						g_start_map[p->bEmpire],
-						g_start_position[p->bEmpire][0],
-						g_start_position[p->bEmpire][1],
-						pids[i]);
-
-					std::unique_ptr<SQLMsg> pmsg2(CDBManager::instance().DirectQuery(szQuery));
-				}
-			}
-		}
-	}
-
-	pkPeer->EncodeHeader(HEADER_DG_EMPIRE_SELECT, dwHandle, sizeof(BYTE));
-	pkPeer->EncodeBYTE(p->bEmpire);
-}
-
-void CClientManager::QUERY_SETUP(CPeer* peer, DWORD dwHandle, const char* c_pData)
-{
-	TPacketGDSetup* p = (TPacketGDSetup*)c_pData;
-	c_pData += sizeof(TPacketGDSetup);
-
-	if (p->bAuthServer)
-	{
-		sys_log(0, "AUTH_PEER ptr %p", peer);
-
-		m_pkAuthPeer = peer;
-		return;
-	}
-
-	peer->SetPublicIP(p->szPublicIP);
-	peer->SetChannel(p->bChannel);
-	peer->SetListenPort(p->wListenPort);
-	peer->SetP2PPort(p->wP2PPort);
-	peer->SetMaps(p->alMaps);
-
-	//
-	// 어떤 맵이 어떤 서버에 있는지 보내기
-	//
-	TMapLocation kMapLocations;
-
-	strlcpy(kMapLocations.szHost, peer->GetPublicIP(), sizeof(kMapLocations.szHost));
-	kMapLocations.wPort = peer->GetListenPort();
-	thecore_memcpy(kMapLocations.alMaps, peer->GetMaps(), sizeof(kMapLocations.alMaps));
-
-	BYTE bMapCount;
-
-	std::vector<TMapLocation> vec_kMapLocations;
-
-	if (peer->GetChannel() == 1)
-	{
-		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		{
-			CPeer* tmp = *i;
-
-			if (tmp == peer)
-				continue;
-
-			if (!tmp->GetChannel())
-				continue;
-
-			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
-			{
-				TMapLocation kMapLocation2;
-				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
-				kMapLocation2.wPort = tmp->GetListenPort();
-				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
-				vec_kMapLocations.push_back(kMapLocation2);
-
-				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
-				bMapCount = 1;
-				tmp->EncodeBYTE(bMapCount);
-				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
-			}
-		}
-	}
-	else if (peer->GetChannel() == GUILD_WARP_WAR_CHANNEL)
-	{
-		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		{
-			CPeer* tmp = *i;
-
-			if (tmp == peer)
-				continue;
-
-			if (!tmp->GetChannel())
-				continue;
-
-			if (tmp->GetChannel() == 1 || tmp->GetChannel() == peer->GetChannel())
-			{
-				TMapLocation kMapLocation2;
-				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
-				kMapLocation2.wPort = tmp->GetListenPort();
-				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
-				vec_kMapLocations.push_back(kMapLocation2);
-			}
-
-			tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
-			bMapCount = 1;
-			tmp->EncodeBYTE(bMapCount);
-			tmp->Encode(&kMapLocations, sizeof(TMapLocation));
-		}
-	}
-	else
-	{
-		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		{
-			CPeer* tmp = *i;
-
-			if (tmp == peer)
-				continue;
-
-			if (!tmp->GetChannel())
-				continue;
-
-			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
-			{
-				TMapLocation kMapLocation2;
-
-				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
-				kMapLocation2.wPort = tmp->GetListenPort();
-				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
-
-				vec_kMapLocations.push_back(kMapLocation2);
-			}
-
-			if (tmp->GetChannel() == peer->GetChannel())
-			{
-				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
-				bMapCount = 1;
-				tmp->EncodeBYTE(bMapCount);
-				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
-			}
-		}
-	}
-
-	vec_kMapLocations.push_back(kMapLocations);
-
-	peer->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation) * vec_kMapLocations.size());
-	bMapCount = static_cast<BYTE>(vec_kMapLocations.size());
-	peer->EncodeBYTE(bMapCount);
-	peer->Encode(&vec_kMapLocations[0], sizeof(TMapLocation) * vec_kMapLocations.size());
-
-	//
-	// 셋업 : 접속한 피어에 다른 피어들이 접속하게 만든다. (P2P 컨넥션 생성)
-	//
-	sys_log(0, "SETUP: channel %u listen %u p2p %u count %u", peer->GetChannel(), p->wListenPort, p->wP2PPort, bMapCount);
-
-	TPacketDGP2P p2pSetupPacket;
-	p2pSetupPacket.wPort = peer->GetP2PPort();
-	p2pSetupPacket.bChannel = peer->GetChannel();
-	strlcpy(p2pSetupPacket.szHost, peer->GetPublicIP(), sizeof(p2pSetupPacket.szHost));
-
-	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* tmp = *i;
-
-		if (tmp == peer)
-			continue;
-
-		// 채널이 0이라면 아직 SETUP 패킷이 오지 않은 피어 또는 auth라고 간주할 수 있음
-		if (0 == tmp->GetChannel())
-			continue;
-
-		tmp->EncodeHeader(HEADER_DG_P2P, 0, sizeof(TPacketDGP2P));
-		tmp->Encode(&p2pSetupPacket, sizeof(TPacketDGP2P));
-	}
-
-	//
-	// 로그인 및 빌링정보 보내기
-	//
-	TPacketLoginOnSetup* pck = (TPacketLoginOnSetup*)c_pData;
-
-	for (DWORD c = 0; c < p->dwLoginCount; ++c, ++pck)
-	{
-		CLoginData* pkLD = new CLoginData;
-
-		pkLD->SetKey(pck->dwLoginKey);
-		pkLD->SetClientKey(pck->adwClientKey);
-		pkLD->SetIP(pck->szHost);
-
-		TAccountTable& r = pkLD->GetAccountRef();
-
-		r.id = pck->dwID;
-		trim_and_lower(pck->szLogin, r.login, sizeof(r.login));
-		strlcpy(r.social_id, pck->szSocialID, sizeof(r.social_id));
-		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		strlcpy(r.country, pck->szCountry, sizeof(r.country));
-#endif
-
-		InsertLoginData(pkLD);
-
-		if (InsertLogonAccount(pck->szLogin, peer->GetHandle(), pck->szHost))
-		{
-			sys_log(0, "SETUP: login %u %s login_key %u host %s", pck->dwID, pck->szLogin, pck->dwLoginKey, pck->szHost);
-			pkLD->SetPlay(true);
-		}
-		else
-			sys_log(0, "SETUP: login_fail %u %s login_key %u", pck->dwID, pck->szLogin, pck->dwLoginKey);
-	}
-
-	SendPartyOnSetup(peer);
-
-	CGuildManager::instance().OnSetup(peer);
-	CPrivManager::instance().SendPrivOnSetup(peer);
-
-	SendEventFlagsOnSetup(peer);
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	SendGuildEventFlagsOnSetup(peer);
-#endif
-
-	marriage::CManager::instance().OnSetup(peer);
-}
-
-void CClientManager::QUERY_ITEM_FLUSH(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwID = *(DWORD*)c_pData;
-
-	if (g_log)
-		sys_log(0, "HEADER_GD_ITEM_FLUSH: %u", dwID);
-
-	CItemCache* c = GetItemCache(dwID);
-
-	if (c)
-		c->Flush();
-}
-
-void CClientManager::QUERY_ITEM_SAVE(CPeer* pkPeer, const char* c_pData)
-{
-	TPlayerItem* p = (TPlayerItem*)c_pData;
-
-	// 창고면 캐쉬하지 않고, 캐쉬에 있던 것도 빼버려야 한다.
-
-	if (p->bWindow == SAFEBOX || p->bWindow == MALL
-	)
-	{
-		CItemCache* c = GetItemCache(p->dwID);
-
-		if (c)
-		{
-			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
-
-			if (it != m_map_pkItemCacheSetPtr.end())
-			{
-				if (g_test_server)
-					sys_log(0, "ITEM_CACHE: safebox owner %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-
-				it->second->erase(c);
-			}
-
-			m_map_itemCache.erase(p->dwID);
-
-			delete c;
-		}
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"REPLACE INTO `item%s` (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
-#if defined(__SOUL_BIND_SYSTEM__)
-			", `soulbind`"
-#endif
-			", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-			", `socket3`, `socket4`, `socket5`"
-#endif
-			", `attrtype0`, `attrvalue0`"
-			", `attrtype1`, `attrvalue1`"
-			", `attrtype2`, `attrvalue2`"
-			", `attrtype3`, `attrvalue3`"
-			", `attrtype4`, `attrvalue4`"
-			", `attrtype5`, `attrvalue5`"
-			", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			", `transmutation`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			", `refine_element_apply_type`"
-			", `refine_element_grade`"
-			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			", `apply_type0`, `apply_value0`, `apply_path0`"
-			", `apply_type1`, `apply_value1`, `apply_path1`"
-			", `apply_type2`, `apply_value2`, `apply_path2`"
-			", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-			", `set_value`"
-#endif
-			") VALUES(%u, %u, %u, %u, %u, %u"
-#if defined(__SOUL_BIND_SYSTEM__)
-			", %ld"
-#endif
-			", %ld, %ld, %ld"
-#if defined(__ITEM_SOCKET6__)
-			", %ld, %ld, %ld"
-#endif
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			", %u"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			", %u"
-			", %u"
-			", %u, %u, %u"
-			", %u, %u, %u"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			", %u, %ld, %u"
-			", %u, %ld, %u"
-			", %u, %ld, %u"
-			", %u, %ld, %u"
-#endif
-#if defined(__SET_ITEM__)
-			", %u"
-#endif
-			")", GetTablePostfix()
-			, p->dwID
-			, p->dwOwner
-			, p->bWindow
-			, p->wPos
-			, p->dwVnum
-			, p->dwCount
-#if defined(__SOUL_BIND_SYSTEM__)
-			, p->lSealDate
-#endif
-			, p->alSockets[0], p->alSockets[1], p->alSockets[2]
-#if defined(__ITEM_SOCKET6__)
-			, p->alSockets[3], p->alSockets[4], p->alSockets[5]
-#endif
-			, p->aAttr[0].wType, p->aAttr[0].lValue
-			, p->aAttr[1].wType, p->aAttr[1].lValue
-			, p->aAttr[2].wType, p->aAttr[2].lValue
-			, p->aAttr[3].wType, p->aAttr[3].lValue
-			, p->aAttr[4].wType, p->aAttr[4].lValue
-			, p->aAttr[5].wType, p->aAttr[5].lValue
-			, p->aAttr[6].wType, p->aAttr[6].lValue
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			, p->dwTransmutationVnum
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			, p->RefineElement.wApplyType
-			, p->RefineElement.bGrade
-			, p->RefineElement.abValue[0], p->RefineElement.abValue[1], p->RefineElement.abValue[2]
-			, p->RefineElement.abBonusValue[0], p->RefineElement.abBonusValue[1], p->RefineElement.abBonusValue[2]
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			, p->aApplyRandom[0].wType, p->aApplyRandom[0].lValue, p->aApplyRandom[0].bPath
-			, p->aApplyRandom[1].wType, p->aApplyRandom[1].lValue, p->aApplyRandom[1].bPath
-			, p->aApplyRandom[2].wType, p->aApplyRandom[2].lValue, p->aApplyRandom[2].bPath
-			, p->aApplyRandom[3].wType, p->aApplyRandom[3].lValue, p->aApplyRandom[3].bPath
-#endif
-#if defined(__SET_ITEM__)
-			, p->bSetValue
-#endif
-		);
-
-		CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_SAVE, pkPeer->GetHandle(), NULL);
-	}
-	else
-	{
-		if (g_test_server)
-			sys_log(0, "QUERY_ITEM_SAVE => PutItemCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
-
-		PutItemCache(p);
-	}
-}
-
-CClientManager::TItemCacheSet* CClientManager::GetItemCacheSet(DWORD pid)
-{
-	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
-
-	if (it == m_map_pkItemCacheSetPtr.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::CreateItemCacheSet(DWORD pid)
-{
-	if (m_map_pkItemCacheSetPtr.find(pid) != m_map_pkItemCacheSetPtr.end())
-		return;
-
-	TItemCacheSet* pSet = new TItemCacheSet;
-	m_map_pkItemCacheSetPtr.insert(TItemCacheSetPtrMap::value_type(pid, pSet));
-
-	if (g_log)
-		sys_log(0, "ITEM_CACHE: new cache %u", pid);
-}
-
-void CClientManager::FlushItemCacheSet(DWORD pid)
-{
-	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
-
-	if (it == m_map_pkItemCacheSetPtr.end())
-	{
-		sys_log(0, "FLUSH_ITEMCACHESET : No ItemCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TItemCacheSet* pSet = it->second;
-	TItemCacheSet::iterator it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CItemCache* c = *it_set++;
-		c->Flush();
-
-		m_map_itemCache.erase(c->Get()->dwID);
-		delete c;
-	}
-
-	pSet->clear();
-	delete pSet;
-
-	m_map_pkItemCacheSetPtr.erase(it);
-
-	if (g_log)
-		sys_log(0, "FLUSH_ITEMCACHESET : Deleted pid(%d)", pid);
-}
-
-CItemCache* CClientManager::GetItemCache(DWORD id)
-{
-	TItemCacheMap::iterator it = m_map_itemCache.find(id);
-
-	if (it == m_map_itemCache.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::PutItemCache(TPlayerItem* pNew, bool bSkipQuery)
-{
-	CItemCache* c;
-
-	c = GetItemCache(pNew->dwID);
-
-	// 아이템 새로 생성
-	if (!c)
-	{
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: PutItemCache ==> New CItemCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
-
-		c = new CItemCache;
-		m_map_itemCache.insert(TItemCacheMap::value_type(pNew->dwID, c));
-	}
-	// 있을시
-	else
-	{
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: PutItemCache ==> Have Cache");
-
-		// 소유자가 틀리면
-		if (pNew->dwOwner != c->Get()->dwOwner)
-		{
-			// 이미 이 아이템을 가지고 있었던 유저로 부터 아이템을 삭제한다.
-			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
-
-			if (it != m_map_pkItemCacheSetPtr.end())
-			{
-				if (g_log)
-					sys_log(0, "ITEM_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
-				it->second->erase(c);
-			}
-		}
-	}
-
-	// 새로운 정보 업데이트
-	c->Put(pNew, bSkipQuery);
-
-	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
-
-	if (it != m_map_pkItemCacheSetPtr.end())
-	{
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		it->second->insert(c);
-	}
-	else
-	{
-		// 현재 소유자가 없으므로 바로 저장해야 다음 접속이 올 때 SQL에 쿼리하여
-		// 받을 수 있으므로 바로 저장한다.
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-
-		c->OnFlush();
-	}
-}
-
-bool CClientManager::DeleteItemCache(DWORD dwID)
-{
-	CItemCache* c = GetItemCache(dwID);
-
-	if (!c)
-		return false;
-
-	c->Delete();
-	return true;
-}
-
-// MYSHOP_PRICE_LIST
-CItemPriceListTableCache* CClientManager::GetItemPriceListCache(DWORD dwID)
-{
-	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.find(dwID);
-
-	if (it == m_mapItemPriceListCache.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::PutItemPriceListCache(const TItemPriceListTable* pItemPriceList)
-{
-	CItemPriceListTableCache* pCache = GetItemPriceListCache(pItemPriceList->dwOwnerID);
-
-	if (!pCache)
-	{
-		pCache = new CItemPriceListTableCache;
-		m_mapItemPriceListCache.insert(TItemPriceListCacheMap::value_type(pItemPriceList->dwOwnerID, pCache));
-	}
-
-	pCache->Put(const_cast<TItemPriceListTable*>(pItemPriceList), true);
-}
-
-void CClientManager::UpdatePlayerCache()
-{
-	TPlayerTableCacheMap::iterator it = m_map_playerCache.begin();
-
-	while (it != m_map_playerCache.end())
-	{
-		CPlayerTableCache* c = (it++)->second;
-
-		if (c->CheckTimeout())
-		{
-			if (g_log)
-				sys_log(0, "UPDATE : UpdatePlayerCache() ==> FlushPlayerCache %d %s ", c->Get(false)->id, c->Get(false)->name);
-
-			c->Flush();
-
-			// Item Cache도 업데이트
-			UpdateItemCacheSet(c->Get()->id);
-#ifdef __GROWTH_PET_SYSTEM__
-			UpdateGrowthPetCacheSet(c->Get()->id);
-#endif
-		}
-		else if (c->CheckFlushTimeout())
-			c->Flush();
-	}
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-void CClientManager::SetCacheFlushCountLimit(int iLimit)
-{
-	m_iCacheFlushCountLimit = MAX(10, iLimit);
-	sys_log(0, "CACHE_FLUSH_LIMIT_PER_SECOND: %d", m_iCacheFlushCountLimit);
-}
-
-void CClientManager::UpdateItemCache()
-{
-	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-		return;
-
-	TItemCacheMap::iterator it = m_map_itemCache.begin();
-
-	while (it != m_map_itemCache.end())
-	{
-		CItemCache* c = (it++)->second;
-
-		// 아이템은 Flush만 한다.
-		if (c->CheckFlushTimeout())
-		{
-			if (g_test_server)
-				sys_log(0, "UpdateItemCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
-
-			c->Flush();
-
-			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-				break;
-		}
-	}
-}
-
-void CClientManager::UpdateItemPriceListCache()
-{
-	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.begin();
-
-	while (it != m_mapItemPriceListCache.end())
-	{
-		CItemPriceListTableCache* pCache = it->second;
-
-		if (pCache->CheckFlushTimeout())
-		{
-			pCache->Flush();
-			m_mapItemPriceListCache.erase(it++);
-		}
-		else
-			++it;
-	}
-}
-
-void CClientManager::QUERY_ITEM_DESTROY(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwID = *(DWORD*)c_pData;
-	c_pData += sizeof(DWORD);
-
-	DWORD dwPID = *(DWORD*)c_pData;
-
-	if (!DeleteItemCache(dwID))
-	{
-		char szQuery[64];
-		snprintf(szQuery, sizeof(szQuery), "DELETE FROM item%s WHERE `id` = %u", GetTablePostfix(), dwID);
-
-		if (g_log)
-			sys_log(0, "HEADER_GD_ITEM_DESTROY: PID %u ID %u", dwPID, dwID);
-
-		if (dwPID == 0) // 아무도 가진 사람이 없었다면, 비동기 쿼리
-			CDBManager::instance().AsyncQuery(szQuery);
-		else
-			CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_DESTROY, pkPeer->GetHandle(), NULL);
-	}
-}
-
-void CClientManager::QUERY_FLUSH_CACHE(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwPID = *(DWORD*)c_pData;
-
-	CPlayerTableCache* pkCache = GetPlayerCache(dwPID);
-
-	if (!pkCache)
-		return;
-
-	sys_log(0, "FLUSH_CACHE: %u", dwPID);
-
-	pkCache->Flush();
-	FlushItemCacheSet(dwPID);
-#ifdef __GROWTH_PET_SYSTEM__
-	FlushGrowthPetCacheSet(dwPID);
-#endif
-	m_map_playerCache.erase(dwPID);
-	delete pkCache;
-}
-
-void CClientManager::QUERY_RELOAD_PROTO()
-{
-	if (!InitializeTables())
-	{
-		sys_err("QUERY_RELOAD_PROTO: cannot load tables");
-		return;
-	}
-
-	for (TPeerList::iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* tmp = *i;
-
-		if (!tmp->GetChannel())
-			continue;
-
-		tmp->EncodeHeader(HEADER_DG_RELOAD_PROTO, 0,
-			sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
-			sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
-			sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
-			sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
-			sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize
-#ifdef __GROWTH_PET_SYSTEM__
-			+ sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size()
-#endif
-		);
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
-		tmp->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
-		tmp->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
-		tmp->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
-		tmp->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_iRefineTableSize));
-		tmp->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
-
-#ifdef __GROWTH_PET_SYSTEM__
-		tmp->EncodeWORD(m_vec_growthPetSkillTable.size());
-		if (m_vec_growthPetSkillTable.size())
-			tmp->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
-#endif
-	}
-}
-
-// ADD_GUILD_PRIV_TIME
-/**
-* @version 05/06/08 Bang2ni - 지속시간 추가
-**/
-void CClientManager::AddGuildPriv(TPacketGiveGuildPriv* p)
-{
-	CPrivManager::instance().AddGuildPriv(p->guild_id, p->type, p->value, p->duration_sec);
-}
-
-void CClientManager::AddEmpirePriv(TPacketGiveEmpirePriv* p)
-{
-	CPrivManager::instance().AddEmpirePriv(p->empire, p->type, p->value, p->duration_sec);
-}
-// END_OF_ADD_GUILD_PRIV_TIME
-
-void CClientManager::AddCharacterPriv(TPacketGiveCharacterPriv* p)
-{
-	CPrivManager::instance().AddCharPriv(p->pid, p->type, p->value);
-}
-
-void CClientManager::MoneyLog(TPacketMoneyLog* p)
-{
-	CMoneyLog::instance().AddLog(p->type, p->vnum, p->gold
-#if defined(__CHEQUE_SYSTEM__)
-		, p->cheque
-#endif
-	);
-}
-
-CLoginData* CClientManager::GetLoginData(DWORD dwKey)
-{
-	TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(dwKey);
-
-	if (it == m_map_pkLoginData.end())
-		return NULL;
-
-	return it->second;
-}
-
-CLoginData* CClientManager::GetLoginDataByLogin(const char* c_pszLogin)
-{
-	char szLogin[LOGIN_MAX_LEN + 1];
-	trim_and_lower(c_pszLogin, szLogin, sizeof(szLogin));
-
-	TLoginDataByLogin::iterator it = m_map_pkLoginDataByLogin.find(szLogin);
-
-	if (it == m_map_pkLoginDataByLogin.end())
-		return NULL;
-
-	return it->second;
-}
-
-CLoginData* CClientManager::GetLoginDataByAID(DWORD dwAID)
-{
-	TLoginDataByAID::iterator it = m_map_pkLoginDataByAID.find(dwAID);
-
-	if (it == m_map_pkLoginDataByAID.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::InsertLoginData(CLoginData* pkLD)
-{
-	char szLogin[LOGIN_MAX_LEN + 1];
-	trim_and_lower(pkLD->GetAccountRef().login, szLogin, sizeof(szLogin));
-
-	m_map_pkLoginData.insert(std::make_pair(pkLD->GetKey(), pkLD));
-	m_map_pkLoginDataByLogin.insert(std::make_pair(szLogin, pkLD));
-	m_map_pkLoginDataByAID.insert(std::make_pair(pkLD->GetAccountRef().id, pkLD));
-}
-
-void CClientManager::DeleteLoginData(CLoginData* pkLD)
-{
-	m_map_pkLoginData.erase(pkLD->GetKey());
-	m_map_pkLoginDataByLogin.erase(pkLD->GetAccountRef().login);
-	m_map_pkLoginDataByAID.erase(pkLD->GetAccountRef().id);
-
-	if (m_map_kLogonAccount.find(pkLD->GetAccountRef().login) == m_map_kLogonAccount.end())
-		delete pkLD;
-	else
-		pkLD->SetDeleted(true);
-}
-
-void CClientManager::QUERY_AUTH_LOGIN(CPeer* pkPeer, DWORD dwHandle, TPacketGDAuthLogin* p)
-{
-	if (g_test_server)
-		sys_log(0, "QUERY_AUTH_LOGIN %d %d %s", p->dwID, p->dwLoginKey, p->szLogin);
-
-	CLoginData* pkLD = GetLoginDataByLogin(p->szLogin);
-
-	if (pkLD)
-	{
-		DeleteLoginData(pkLD);
-	}
-
-	BYTE bResult;
-
-	if (GetLoginData(p->dwLoginKey))
-	{
-		sys_err("LoginData already exist key %u login %s", p->dwLoginKey, p->szLogin);
-		bResult = 0;
-
-		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
-		pkPeer->EncodeBYTE(bResult);
-	}
-	else
-	{
-		CLoginData* pkLD = new CLoginData;
-
-		pkLD->SetKey(p->dwLoginKey);
-		pkLD->SetClientKey(p->adwClientKey);
-		pkLD->SetPremium(p->iPremiumTimes);
-
-		TAccountTable& r = pkLD->GetAccountRef();
-
-		r.id = p->dwID;
-		trim_and_lower(p->szLogin, r.login, sizeof(r.login));
-		strlcpy(r.social_id, p->szSocialID, sizeof(r.social_id));
-		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		strlcpy(r.country, p->szCountry, sizeof(r.country));
-#endif
-
-		sys_log(0, "AUTH_LOGIN id(%u) login(%s)"
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			" country(%s)"
-#endif
-			" social_id(%s) login_key(%u), client_key(%u %u %u %u)",
-			p->dwID,
-			p->szLogin,
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			p->szCountry,
-#endif
-			p->szSocialID,
-			p->dwLoginKey,
-			p->adwClientKey[0], p->adwClientKey[1], p->adwClientKey[2], p->adwClientKey[3]
-		);
-
-		bResult = 1;
-
-		InsertLoginData(pkLD);
-
-		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
-		pkPeer->EncodeBYTE(bResult);
-	}
-}
-
-void CClientManager::GuildDepositMoney(TPacketGDGuildMoney* p)
-{
-	CGuildManager::instance().DepositMoney(p->dwGuild, p->iGold);
-}
-
-void CClientManager::GuildWithdrawMoney(CPeer* peer, TPacketGDGuildMoney* p)
-{
-	CGuildManager::instance().WithdrawMoney(peer, p->dwGuild, p->iGold);
-}
-
-void CClientManager::GuildWithdrawMoneyGiveReply(TPacketGDGuildMoneyWithdrawGiveReply* p)
-{
-	CGuildManager::instance().WithdrawMoneyReply(p->dwGuild, p->bGiveSuccess, p->iChangeGold);
-}
-
-void CClientManager::GuildWarBet(TPacketGDGuildWarBet* p)
-{
-	CGuildManager::instance().Bet(p->dwWarID, p->szLogin, p->dwGold, p->dwGuild);
-}
-
-void CClientManager::CreateObject(TPacketGDCreateObject* p)
-{
-	using namespace building;
-
-	char szQuery[512];
-
-	snprintf(szQuery, sizeof(szQuery),
-		"INSERT INTO object%s (`land_id`, `vnum`, `map_index`, `x`, `y`, `x_rot`, `y_rot`, `z_rot`) VALUES(%u, %u, %d, %d, %d, %f, %f, %f)",
-		GetTablePostfix(), p->dwLandID, p->dwVnum, p->lMapIndex, p->x, p->y, p->xRot, p->yRot, p->zRot);
-
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-	if (pmsg->Get()->uiInsertID == 0)
-	{
-		sys_err("cannot insert object");
-		return;
-	}
-
-	TObject* pkObj = new TObject;
-
-	memset(pkObj, 0, sizeof(TObject));
-
-	pkObj->dwID = pmsg->Get()->uiInsertID;
-	pkObj->dwVnum = p->dwVnum;
-	pkObj->dwLandID = p->dwLandID;
-	pkObj->lMapIndex = p->lMapIndex;
-	pkObj->x = p->x;
-	pkObj->y = p->y;
-	pkObj->xRot = p->xRot;
-	pkObj->yRot = p->yRot;
-	pkObj->zRot = p->zRot;
-	pkObj->lLife = 0;
-
-	ForwardPacket(HEADER_DG_CREATE_OBJECT, pkObj, sizeof(TObject));
-
-	m_map_pkObjectTable.insert(std::make_pair(pkObj->dwID, pkObj));
-}
-
-void CClientManager::DeleteObject(DWORD dwID)
-{
-	char szQuery[128];
-
-	snprintf(szQuery, sizeof(szQuery), "DELETE FROM object%s WHERE `id` = %u", GetTablePostfix(), dwID);
-
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
-	{
-		sys_err("no object by id %u", dwID);
-		return;
-	}
-
-	//pkObjectTableMap::const_iterator it = m_map_pkObjectTable.find(dwID);
-	auto it = m_map_pkObjectTable.find(dwID);
-	if (it != m_map_pkObjectTable.end())
-	{
-		delete it->second;
-		m_map_pkObjectTable.erase(it);
-	}
-
-	ForwardPacket(HEADER_DG_DELETE_OBJECT, &dwID, sizeof(DWORD));
-}
-
-void CClientManager::UpdateLand(DWORD* pdw)
-{
-	DWORD dwID = pdw[0];
-	DWORD dwGuild = pdw[1];
-
-	building::TLand* p = &m_vec_kLandTable[0];
-
-	DWORD i;
-
-	for (i = 0; i < m_vec_kLandTable.size(); ++i, ++p)
-	{
-		if (p->dwID == dwID)
-		{
-			char buf[256];
-			snprintf(buf, sizeof(buf), "UPDATE land%s SET `guild_id` = %u WHERE `id` = %u", GetTablePostfix(), dwGuild, dwID);
-			CDBManager::instance().AsyncQuery(buf);
-
-			p->dwGuildID = dwGuild;
-			break;
-		}
-	}
-
-	if (i < m_vec_kLandTable.size())
-		ForwardPacket(HEADER_DG_UPDATE_LAND, p, sizeof(building::TLand));
-}
-
-// BLOCK_CHAT
-void CClientManager::BlockChat(TPacketBlockChat* p)
-{
-	char szQuery[256];
-
-	if (g_stLocale == "sjis")
-		snprintf(szQuery, sizeof(szQuery), "SELECT `id `FROM player%s WHERE `name` = '%s' COLLATE sjis_japanese_ci", GetTablePostfix(), p->szName);
-	else
-		snprintf(szQuery, sizeof(szQuery), "SELECT `id` FROM player%s WHERE `name` = '%s'", GetTablePostfix(), p->szName);
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-	SQLResult* pRes = pmsg->Get();
-
-	if (pRes->uiNumRows)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
-		DWORD pid = strtoul(row[0], NULL, 10);
-
-		TPacketGDAddAffect pa;
-		pa.dwPID = pid;
-		pa.elem.dwType = 223;
-		pa.elem.wApplyOn = 0;
-		pa.elem.lApplyValue = 0;
-		pa.elem.dwFlag = 0;
-		pa.elem.lDuration = p->lDuration;
-		pa.elem.lSPCost = 0;
-		QUERY_ADD_AFFECT(NULL, &pa);
-	}
-	else
-	{
-		// cannot find user with that name
-	}
-}
-// END_OF_BLOCK_CHAT
-
-void CClientManager::MarriageAdd(TPacketMarriageAdd* p)
-{
-	sys_log(0, "MarriageAdd %u %u %s %s", p->dwPID1, p->dwPID2, p->szName1, p->szName2);
-	marriage::CManager::instance().Add(p->dwPID1, p->dwPID2, p->szName1, p->szName2);
-}
-
-void CClientManager::MarriageUpdate(TPacketMarriageUpdate* p)
-{
-	sys_log(0, "MarriageUpdate PID:%u %u LP:%d ST:%d", p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
-	marriage::CManager::instance().Update(p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
-}
-
-void CClientManager::MarriageRemove(TPacketMarriageRemove* p)
-{
-	sys_log(0, "MarriageRemove %u %u", p->dwPID1, p->dwPID2);
-	marriage::CManager::instance().Remove(p->dwPID1, p->dwPID2);
-}
-
-void CClientManager::WeddingRequest(TPacketWeddingRequest* p)
-{
-	sys_log(0, "WeddingRequest %u %u", p->dwPID1, p->dwPID2);
-	ForwardPacket(HEADER_DG_WEDDING_REQUEST, p, sizeof(TPacketWeddingRequest));
-	//marriage::CManager::instance().RegisterWedding(p->dwPID1, p->szName1, p->dwPID2, p->szName2);
-}
-
-void CClientManager::WeddingReady(TPacketWeddingReady* p)
-{
-	sys_log(0, "WeddingReady %u %u", p->dwPID1, p->dwPID2);
-	ForwardPacket(HEADER_DG_WEDDING_READY, p, sizeof(TPacketWeddingReady));
-	marriage::CManager::instance().ReadyWedding(p->dwMapIndex, p->dwPID1, p->dwPID2);
-}
-
-void CClientManager::WeddingEnd(TPacketWeddingEnd* p)
-{
-	sys_log(0, "WeddingEnd %u %u", p->dwPID1, p->dwPID2);
-	marriage::CManager::instance().EndWedding(p->dwPID1, p->dwPID2);
-}
-
-//
-// 캐시에 가격정보가 있으면 캐시를 업데이트 하고 캐시에 가격정보가 없다면
-// 우선 기존의 데이터를 로드한 뒤에 기존의 정보로 캐시를 만들고 새로 받은 가격정보를 업데이트 한다.
-//
-void CClientManager::MyshopPricelistUpdate(const TItemPriceListTable* pPacket)
-{
-	if (pPacket->byCount > SHOP_PRICELIST_MAX_NUM)
-	{
-		sys_err("count overflow!");
-		return;
-	}
-
-	CItemPriceListTableCache* pCache = GetItemPriceListCache(pPacket->dwOwnerID);
-
-	if (pCache)
-	{
-		TItemPriceListTable table;
-
-		table.dwOwnerID = pPacket->dwOwnerID;
-		table.byCount = pPacket->byCount;
-
-		thecore_memcpy(table.aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
-
-		pCache->UpdateList(&table);
-	}
-	else
-	{
-		TItemPriceListTable* pUpdateTable = new TItemPriceListTable;
-
-		pUpdateTable->dwOwnerID = pPacket->dwOwnerID;
-		pUpdateTable->byCount = pPacket->byCount;
-
-		thecore_memcpy(pUpdateTable->aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `item_vnum`, `price`"
-#if defined(__CHEQUE_SYSTEM__)
-			", `cheque`"
-#endif
-			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), pPacket->dwOwnerID);
-		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD_FOR_UPDATE, 0, pUpdateTable);
-	}
-}
-
-// MYSHOP_PRICE_LIST
-// 캐시된 가격정보가 있으면 캐시를 읽어 바로 전송하고 캐시에 정보가 없으면 DB 에 쿼리를 한다.
-//
-void CClientManager::MyshopPricelistRequest(CPeer* peer, DWORD dwHandle, DWORD dwPlayerID)
-{
-	if (CItemPriceListTableCache* pCache = GetItemPriceListCache(dwPlayerID))
-	{
-		sys_log(0, "Cache MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
-
-		TItemPriceListTable* pTable = pCache->Get(false);
-
-		TPacketMyshopPricelistHeader header =
-		{
-			pTable->dwOwnerID,
-			pTable->byCount
-		};
-
-		size_t sizePriceListSize = sizeof(TItemPriceInfo) * pTable->byCount;
-
-		peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, dwHandle, sizeof(header) + sizePriceListSize);
-		peer->Encode(&header, sizeof(header));
-		peer->Encode(pTable->aPriceInfo, sizePriceListSize);
-	}
-	else
-	{
-		sys_log(0, "Query MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `item_vnum`, `price`"
-#if defined(__CHEQUE_SYSTEM__)
-			", `cheque`"
-#endif
-			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), dwPlayerID);
-		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD, peer->GetHandle(), new TItemPricelistReqInfo(dwHandle, dwPlayerID));
-	}
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-void CPacketInfo::Add(int header)
-{
-	auto it = m_map_info.find(header);
-	if (it == m_map_info.end())
-		m_map_info.insert(std::map<int, int>::value_type(header, 1));
-	else
-		++it->second;
-}
-
-void CPacketInfo::Reset()
-{
-	m_map_info.clear();
-}
-
-void CClientManager::ProcessPackets(CPeer* peer)
-{
-	BYTE header;
-	DWORD dwHandle;
-	DWORD dwLength;
-	const char* data = NULL;
-	int i = 0;
-	int iCount = 0;
-
-	while (peer->PeekPacket(i, header, dwHandle, dwLength, &data))
-	{
-		// DISABLE_DB_HEADER_LOG
-		// sys_log(0, "header %d %p size %d", header, this, dwLength);
-		// END_OF_DISABLE_DB_HEADER_LOG
-		m_bLastHeader = header;
-		++iCount;
-
-#if defined(_DEBUG)
-		if (header != 10)
-			sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
-#endif
-
-		if (g_test_server)
-		{
-			if (header != 10)
-				sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
-		}
-
-		// test log by mhh
-		{
-			if (HEADER_GD_BLOCK_COUNTRY_IP == header)
-				sys_log(0, "recved : HEADER_GD_BLOCK_COUNTRY_IP");
-		}
-
-		switch (header)
-		{
-			case HEADER_GD_BOOT:
-				QUERY_BOOT(peer, (TPacketGDBoot*)data);
-				break;
-
-			case HEADER_GD_HAMMER_OF_TOR:
-				break;
-
-			case HEADER_GD_LOGIN_BY_KEY:
-				QUERY_LOGIN_BY_KEY(peer, dwHandle, (TPacketGDLoginByKey*)data);
-				break;
-
-			case HEADER_GD_LOGOUT:
-				//sys_log(0, "HEADER_GD_LOGOUT (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_LOGOUT(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_PLAYER_LOAD:
-				sys_log(1, "HEADER_GD_PLAYER_LOAD (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_PLAYER_LOAD(peer, dwHandle, (TPlayerLoadPacket*)data);
-				break;
-
-			case HEADER_GD_PLAYER_SAVE:
-				sys_log(1, "HEADER_GD_PLAYER_SAVE (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_PLAYER_SAVE(peer, dwHandle, (TPlayerTable*)data);
-				break;
-
-			case HEADER_GD_PLAYER_CREATE:
-				sys_log(0, "HEADER_GD_PLAYER_CREATE (handle: %d length: %d)", dwHandle, dwLength);
-				__QUERY_PLAYER_CREATE(peer, dwHandle, (TPlayerCreatePacket*)data);
-				sys_log(0, "END");
-				break;
-
-			case HEADER_GD_PLAYER_DELETE:
-				sys_log(1, "HEADER_GD_PLAYER_DELETE (handle: %d length: %d)", dwHandle, dwLength);
-				__QUERY_PLAYER_DELETE(peer, dwHandle, (TPlayerDeletePacket*)data);
-				break;
-
-			case HEADER_GD_PLAYER_COUNT:
-				QUERY_PLAYER_COUNT(peer, (TPlayerCountPacket*)data);
-				break;
-
-			case HEADER_GD_QUEST_SAVE:
-				sys_log(1, "HEADER_GD_QUEST_SAVE (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_QUEST_SAVE(peer, (TQuestTable*)data, dwLength);
-				break;
-
-			case HEADER_GD_SAFEBOX_LOAD:
-				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 0);
-				break;
-
-			case HEADER_GD_SAFEBOX_SAVE:
-				sys_log(1, "HEADER_GD_SAFEBOX_SAVE (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_SAFEBOX_SAVE(peer, (TSafeboxTable*)data);
-				break;
-
-			case HEADER_GD_SAFEBOX_CHANGE_SIZE:
-				QUERY_SAFEBOX_CHANGE_SIZE(peer, dwHandle, (TSafeboxChangeSizePacket*)data);
-				break;
-
-			case HEADER_GD_SAFEBOX_CHANGE_PASSWORD:
-				QUERY_SAFEBOX_CHANGE_PASSWORD(peer, dwHandle, (TSafeboxChangePasswordPacket*)data);
-				break;
-
-			case HEADER_GD_MALL_LOAD:
-				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 1);
-				break;
-
-			case HEADER_GD_EMPIRE_SELECT:
-				QUERY_EMPIRE_SELECT(peer, dwHandle, (TEmpireSelectPacket*)data);
-				break;
-
-			case HEADER_GD_SETUP:
-				QUERY_SETUP(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_GUILD_CREATE:
-				GuildCreate(peer, *(DWORD*)data);
-				break;
-
-			case HEADER_GD_GUILD_SKILL_UPDATE:
-				GuildSkillUpdate(peer, (TPacketGuildSkillUpdate*)data);
-				break;
-
-			case HEADER_GD_GUILD_EXP_UPDATE:
-				GuildExpUpdate(peer, (TPacketGuildExpUpdate*)data);
-				break;
-
-			case HEADER_GD_GUILD_ADD_MEMBER:
-				GuildAddMember(peer, (TPacketGDGuildAddMember*)data);
-				break;
-
-			case HEADER_GD_GUILD_REMOVE_MEMBER:
-				GuildRemoveMember(peer, (TPacketGuild*)data);
-				break;
-
-			case HEADER_GD_GUILD_CHANGE_GRADE:
-				GuildChangeGrade(peer, (TPacketGuild*)data);
-				break;
-
-			case HEADER_GD_GUILD_CHANGE_MEMBER_DATA:
-				GuildChangeMemberData(peer, (TPacketGuildChangeMemberData*)data);
-				break;
-
-			case HEADER_GD_GUILD_DISBAND:
-				GuildDisband(peer, (TPacketGuild*)data);
-				break;
-
-			case HEADER_GD_GUILD_WAR:
-				GuildWar(peer, (TPacketGuildWar*)data);
-				break;
-
-			case HEADER_GD_GUILD_WAR_SCORE:
-				GuildWarScore(peer, (TPacketGuildWarScore*)data);
-				break;
-
-			case HEADER_GD_GUILD_CHANGE_LADDER_POINT:
-				GuildChangeLadderPoint((TPacketGuildLadderPoint*)data);
-				break;
-
-			case HEADER_GD_GUILD_USE_SKILL:
-				GuildUseSkill((TPacketGuildUseSkill*)data);
-				break;
-
-			case HEADER_GD_FLUSH_CACHE:
-				QUERY_FLUSH_CACHE(peer, data);
-				break;
-
-			case HEADER_GD_ITEM_SAVE:
-				QUERY_ITEM_SAVE(peer, data);
-				break;
-
-			case HEADER_GD_ITEM_DESTROY:
-				QUERY_ITEM_DESTROY(peer, data);
-				break;
-
-			case HEADER_GD_ITEM_FLUSH:
-				QUERY_ITEM_FLUSH(peer, data);
-				break;
-
-			case HEADER_GD_ADD_AFFECT:
-				sys_log(1, "HEADER_GD_ADD_AFFECT");
-				QUERY_ADD_AFFECT(peer, (TPacketGDAddAffect*)data);
-				break;
-
-			case HEADER_GD_REMOVE_AFFECT:
-				sys_log(1, "HEADER_GD_REMOVE_AFFECT");
-				QUERY_REMOVE_AFFECT(peer, (TPacketGDRemoveAffect*)data);
-				break;
-
-			case HEADER_GD_HIGHSCORE_REGISTER:
-				QUERY_HIGHSCORE_REGISTER(peer, (TPacketGDHighscore*)data);
-				break;
-
-			case HEADER_GD_PARTY_CREATE:
-				QUERY_PARTY_CREATE(peer, (TPacketPartyCreate*)data);
-				break;
-
-			case HEADER_GD_PARTY_DELETE:
-				QUERY_PARTY_DELETE(peer, (TPacketPartyDelete*)data);
-				break;
-
-			case HEADER_GD_PARTY_ADD:
-				QUERY_PARTY_ADD(peer, (TPacketPartyAdd*)data);
-				break;
-
-			case HEADER_GD_PARTY_REMOVE:
-				QUERY_PARTY_REMOVE(peer, (TPacketPartyRemove*)data);
-				break;
-
-			case HEADER_GD_PARTY_STATE_CHANGE:
-				QUERY_PARTY_STATE_CHANGE(peer, (TPacketPartyStateChange*)data);
-				break;
-
-			case HEADER_GD_PARTY_SET_MEMBER_LEVEL:
-				QUERY_PARTY_SET_MEMBER_LEVEL(peer, (TPacketPartySetMemberLevel*)data);
-				break;
-
-			case HEADER_GD_RELOAD_PROTO:
-				QUERY_RELOAD_PROTO();
-				break;
-
-			case HEADER_GD_CHANGE_NAME:
-				QUERY_CHANGE_NAME(peer, dwHandle, (TPacketGDChangeName*)data);
-				break;
-
-			case HEADER_GD_AUTH_LOGIN:
-				QUERY_AUTH_LOGIN(peer, dwHandle, (TPacketGDAuthLogin*)data);
-				break;
-
-			case HEADER_GD_REQUEST_GUILD_PRIV:
-				AddGuildPriv((TPacketGiveGuildPriv*)data);
-				break;
-
-			case HEADER_GD_REQUEST_EMPIRE_PRIV:
-				AddEmpirePriv((TPacketGiveEmpirePriv*)data);
-				break;
-
-			case HEADER_GD_REQUEST_CHARACTER_PRIV:
-				AddCharacterPriv((TPacketGiveCharacterPriv*)data);
-				break;
-
-			case HEADER_GD_MONEY_LOG:
-				MoneyLog((TPacketMoneyLog*)data);
-				break;
-
-			case HEADER_GD_GUILD_DEPOSIT_MONEY:
-				GuildDepositMoney((TPacketGDGuildMoney*)data);
-				break;
-
-			case HEADER_GD_GUILD_WITHDRAW_MONEY:
-				GuildWithdrawMoney(peer, (TPacketGDGuildMoney*)data);
-				break;
-
-			case HEADER_GD_GUILD_WITHDRAW_MONEY_GIVE_REPLY:
-				GuildWithdrawMoneyGiveReply((TPacketGDGuildMoneyWithdrawGiveReply*)data);
-				break;
-
-			case HEADER_GD_GUILD_WAR_BET:
-				GuildWarBet((TPacketGDGuildWarBet*)data);
-				break;
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-			case HEADER_GD_GUILD_EVENT_FLAG:
-				GuildSetEventFlag((TPacketSetGuildEventFlag*)data);
-				break;
-#endif
-
-			case HEADER_GD_SET_EVENT_FLAG:
-				SetEventFlag((TPacketSetEventFlag*)data);
-				break;
-
-			case HEADER_GD_CREATE_OBJECT:
-				CreateObject((TPacketGDCreateObject*)data);
-				break;
-
-			case HEADER_GD_DELETE_OBJECT:
-				DeleteObject(*(DWORD*)data);
-				break;
-
-			case HEADER_GD_UPDATE_LAND:
-				UpdateLand((DWORD*)data);
-				break;
-
-			case HEADER_GD_MARRIAGE_ADD:
-				MarriageAdd((TPacketMarriageAdd*)data);
-				break;
-
-			case HEADER_GD_MARRIAGE_UPDATE:
-				MarriageUpdate((TPacketMarriageUpdate*)data);
-				break;
-
-			case HEADER_GD_MARRIAGE_REMOVE:
-				MarriageRemove((TPacketMarriageRemove*)data);
-				break;
-
-			case HEADER_GD_WEDDING_REQUEST:
-				WeddingRequest((TPacketWeddingRequest*)data);
-				break;
-
-			case HEADER_GD_WEDDING_READY:
-				WeddingReady((TPacketWeddingReady*)data);
-				break;
-
-			case HEADER_GD_WEDDING_END:
-				WeddingEnd((TPacketWeddingEnd*)data);
-				break;
-
-				// BLOCK_CHAT
-			case HEADER_GD_BLOCK_CHAT:
-				BlockChat((TPacketBlockChat*)data);
-				break;
-				// END_OF_BLOCK_CHAT
-
-				// MYSHOP_PRICE_LIST
-			case HEADER_GD_MYSHOP_PRICELIST_UPDATE:
-				MyshopPricelistUpdate((TItemPriceListTable*)data);
-				break;
-
-			case HEADER_GD_MYSHOP_PRICELIST_REQ:
-				MyshopPricelistRequest(peer, dwHandle, *(DWORD*)data);
-				break;
-				// END_OF_MYSHOP_PRICE_LIST
-
-				// RELOAD_ADMIN
-			case HEADER_GD_RELOAD_ADMIN:
-				ReloadAdmin(peer, (TPacketReloadAdmin*)data);
-				break;
-				// END_RELOAD_ADMIN
-
-			case HEADER_GD_BREAK_MARRIAGE:
-				BreakMarriage(peer, data);
-				break;
-
-				// MOANRCH
-			case HEADER_GD_ELECT_MONARCH:
-				Election(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_CANDIDACY:
-				Candidacy(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_ADD_MONARCH_MONEY:
-				AddMonarchMoney(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_DEC_MONARCH_MONEY:
-				DecMonarchMoney(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_TAKE_MONARCH_MONEY:
-				TakeMonarchMoney(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_COME_TO_VOTE:
-				ComeToVote(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_RMCANDIDACY: ///< 후보 제거 (운영자)
-				RMCandidacy(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_SETMONARCH: ///< 군주설정 (운영자)
-				SetMonarch(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_RMMONARCH: ///< 군주삭제
-				RMMonarch(peer, dwHandle, data);
-				break;
-				// END_MONARCH
-
-			case HEADER_GD_CHANGE_MONARCH_LORD:
-				ChangeMonarchLord(peer, dwHandle, (TPacketChangeMonarchLord*)data);
-				break;
-
-			case HEADER_GD_BLOCK_COUNTRY_IP:
-				sys_log(0, "HEADER_GD_BLOCK_COUNTRY_IP received");
-				CBlockCountry::instance().SendBlockedCountryIp(peer);
-				CBlockCountry::instance().SendBlockException(peer);
-				break;
-
-			case HEADER_GD_BLOCK_EXCEPTION:
-				sys_log(0, "HEADER_GD_BLOCK_EXCEPTION received");
-				BlockException((TPacketBlockException*)data);
-				break;
-
-			case HEADER_GD_REQ_SPARE_ITEM_ID_RANGE:
-				SendSpareItemIDRange(peer);
-				break;
-
-			case HEADER_GD_REQ_CHANGE_GUILD_MASTER:
-				GuildChangeMaster((TPacketChangeGuildMaster*)data);
-				break;
-
-			case HEADER_GD_UPDATE_HORSE_NAME:
-				UpdateHorseName((TPacketUpdateHorseName*)data, peer);
-				break;
-
-			case HEADER_GD_REQ_HORSE_NAME:
-				AckHorseName(*(DWORD*)data, peer);
-				break;
-
-			case HEADER_GD_DC:
-				DeleteLoginKey((TPacketDC*)data);
-				break;
-
-			case HEADER_GD_VALID_LOGOUT:
-				ResetLastPlayerID((TPacketNeedLoginLogInfo*)data);
-				break;
-
-			case HEADER_GD_REQUEST_CHARGE_CASH:
-				ChargeCash((TRequestChargeCash*)data);
-				break;
-
-				// delete gift notify icon
-			case HEADER_GD_DELETE_AWARDID:
-				DeleteAwardId((TPacketDeleteAwardID*)data);
-				break;
-
-			case HEADER_GD_UPDATE_CHANNELSTATUS:
-				UpdateChannelStatus((SChannelStatus*)data);
-				break;
-
-			case HEADER_GD_REQUEST_CHANNELSTATUS:
-				RequestChannelStatus(peer, dwHandle);
-				break;
-
-#if defined(__MOVE_CHANNEL__)
-			case HEADER_GD_FIND_CHANNEL:
-				FindChannel(peer, dwHandle, (TPacketChangeChannel*)data);
-				break;
-#endif
-
-#if defined(__GEM_SHOP__)
-			case HEADER_GD_GEM_SHOP_LOAD:
-				LoadGemShop(peer, dwHandle, (TGemShopLoad*)data);
-				break;
-
-			case HEADER_GD_GEM_SHOP_UPDATE:
-				UpdateGemShop(peer, dwHandle, (TGemShopTable*)data);
-				break;
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-			case HEADER_GD_EMOTE_LOAD:
-				QUERY_EMOTE_LOAD(peer, dwHandle, (TPacketGDEmote*)data);
-				break;
-
-			case HEADER_GD_EMOTE_CLEAR:
-				QUERY_EMOTE_CLEAR(peer, dwHandle, (TPacketGDEmote*)data);
-				break;
-
-			case HEADER_GD_EMOTE_ADD:
-				QUERY_EMOTE_ADD(peer, dwHandle, (TPacketGDEmote*)data);
-				break;
-#endif
-
-#if defined(__MAILBOX__)
-			case HEADER_GD_MAILBOX_LOAD:
-				QUERY_MAILBOX_LOAD(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_CHECK_NAME:
-				QUERY_MAILBOX_CHECK_NAME(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_WRITE:
-				QUERY_MAILBOX_WRITE(peer, dwHandle, (TMailBoxTable*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_DELETE:
-				QUERY_MAILBOX_DELETE(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_CONFIRM:
-				QUERY_MAILBOX_CONFIRM(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_GET:
-				QUERY_MAILBOX_GET(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_UNREAD:
-				QUERY_MAILBOX_UNREAD(peer, dwHandle, (TMailBox*)data);
-				break;
-#endif
-
-#ifdef __SHOP_SEARCH__
-			case HEADER_GD_SHOP_SEARCH_REGISTER_ITEM:
-				CShopSearchManager::Instance().RecvRegisterItem(peer, *reinterpret_cast<const TShopSearchItem*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_UNREGISTER_ITEM:
-				CShopSearchManager::Instance().RecvUnregisterItem(*reinterpret_cast<const TShopSearchItem*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_SOLD_ITEM:
-				CShopSearchManager::Instance().RecvSoldItem(*reinterpret_cast<const TPacketGDShopSearchSoldItem*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BY_NAME:
-				CShopSearchManager::Instance().RecvSearchByName(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchByName*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BY_OPTIONS:
-			{
-				const TPacketGDShopSearchByOptions& packet = *reinterpret_cast<const TPacketGDShopSearchByOptions*>(data);
-				data += sizeof(TPacketGDShopSearchByOptions);
-				const TShopSearchItemType* itemTypeFlags = (const TShopSearchItemType*)data;
-				data += sizeof(TShopSearchItemType) * packet.options.typeFlagCount;
-				CShopSearchManager::Instance().RecvSearchByOptions(peer, dwHandle, packet, itemTypeFlags, (const DWORD*)data);
-			}
-			break;
-
-			case HEADER_GD_SHOP_SEARCH_REQUEST_BUY:
-				CShopSearchManager::Instance().RecvBuyItem(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchRequestBuy*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BUY_FROM_SHOP_ERROR:
-				CShopSearchManager::Instance().RecvBuyFromShopError(*reinterpret_cast<const TPacketDGShopSearchBuyFromShop*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BOUGHT_FROM_SHOP:
-				CShopSearchManager::Instance().RecvBoughtFromShop(dwHandle, *reinterpret_cast<const TPacketGDShopSearchBoughtFromShop*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_REQUEST_SOLD_INFO:
-				CShopSearchManager::Instance().RecvRequestSoldInfo(peer, dwHandle, *reinterpret_cast<const DWORD*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_RELOAD_AVERAGE:
-				CShopSearchManager::Instance().Initialize();
-				break;
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-			case HEADER_GD_GROWTH_PET_SAVE:
-				QUERY_GROWTH_PET_SAVE(peer, data);
-				break;
-
-			case HEADER_GD_GROWTH_PET_DELETE:
-				QUERY_GROWTH_PET_DELETE(peer, data);
-				break;
-#endif
-
-#ifdef __OFFLINE_SHOP__
-			case HEADER_GD_REQUEST_OFFLINE_SHOP_ID:
-				RequestOfflineShopId(peer, *reinterpret_cast<const uint32_t*>(data));
-				break;
-
-			case HEADER_GD_OFFLINE_SHOP_SAVE:
-				SaveOfflineShop(*reinterpret_cast<const TOfflineShop*>(data));
-				break;
-
-			case HEADER_GD_OFFLINE_SHOP_SAVE_ITEM:
-				SaveOfflineShopItem(*reinterpret_cast<const TOfflineShopItem*>(data));
-				break;
-
-			case HEADER_GD_OFFLINE_SHOP_DESTROY:
-				DestroyOfflineShop(*reinterpret_cast<const uint32_t*>(data));
-				break;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			case HEADER_GD_SAVE_EXT_BATTLE_PASS:
-				QUERY_SAVE_EXT_BATTLE_PASS(peer, dwHandle, (TPlayerExtBattlePassMission*)data);
-				break;
-#endif
-
-			default:
-				sys_err("Unknown header (header: %d handle: %d length: %d)", header, dwHandle, dwLength);
-				break;
-		}
-	}
-
-	peer->RecvEnd(i);
-}
-
-void CClientManager::AddPeer(socket_t fd)
-{
-	CPeer* pPeer = new CPeer;
-
-	if (pPeer->Accept(fd))
-		m_peerList.push_front(pPeer);
-	else
-		delete pPeer;
-}
-
-void CClientManager::RemovePeer(CPeer* pPeer)
-{
-	if (m_pkAuthPeer == pPeer)
-	{
-		m_pkAuthPeer = NULL;
-	}
-	else
-	{
-		TLogonAccountMap::iterator it = m_map_kLogonAccount.begin();
-
-		while (it != m_map_kLogonAccount.end())
-		{
-			CLoginData* pkLD = it->second;
-
-			if (pkLD->GetConnectedPeerHandle() == pPeer->GetHandle())
-			{
-				if (pkLD->IsPlay())
-					pkLD->SetPlay(false);
-
-				if (pkLD->IsDeleted())
-				{
-					sys_log(0, "DELETING LoginData");
-					delete pkLD;
-				}
-
-				m_map_kLogonAccount.erase(it++);
-			}
-			else
-				++it;
-		}
-	}
-
-	m_peerList.remove(pPeer);
-	delete pPeer;
-}
-
-CPeer* CClientManager::GetPeer(IDENT ident)
-{
-	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* tmp = *i;
-
-		if (tmp->GetHandle() == ident)
-			return tmp;
-	}
-
-	return NULL;
-}
-
-CPeer* CClientManager::GetAnyPeer()
-{
-	if (m_peerList.empty())
-		return NULL;
-
-	return m_peerList.front();
-}
-
-// DB 매니저로 부터 받은 결과를 처리한다.
-//
-// @version	05/06/10 Bang2ni - 가격정보 관련 쿼리(QID_ITEMPRICE_XXX) 추가
-int CClientManager::AnalyzeQueryResult(SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	CPeer* peer = GetPeer(qi->dwIdent);
-
-#if defined(_DEBUG)
-	if (qi->iType != QID_ITEM_AWARD_LOAD)
-		sys_log(0, "AnalyzeQueryResult %d", qi->iType);
-#endif
-
-	switch (qi->iType)
-	{
-		case QID_ITEM_AWARD_LOAD:
-			ItemAwardManager::instance().Load(msg);
-			delete qi;
-			return true;
-
-		case QID_GUILD_RANKING:
-			CGuildManager::instance().ResultRanking(msg->Get()->pSQLResult);
-			break;
-
-			// MYSHOP_PRICE_LIST
-		case QID_ITEMPRICE_LOAD_FOR_UPDATE:
-			RESULT_PRICELIST_LOAD_FOR_UPDATE(msg);
-			break;
-			// END_OF_MYSHOP_PRICE_LIST
-	}
-
-	if (!peer)
-	{
-		//sys_err("CClientManager::AnalyzeQueryResult: peer not exist anymore. (ident: %d)", qi->dwIdent);
-		delete qi;
-		return true;
-	}
-
-	switch (qi->iType)
-	{
-		case QID_PLAYER:
-		case QID_ITEM:
-		case QID_QUEST:
-		case QID_AFFECT:
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		case QID_EXT_BATTLE_PASS:
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-		case QID_GROWTH_PET:
-#endif
-			RESULT_COMPOSITE_PLAYER(peer, msg, qi->iType);
-			break;
-
-		case QID_LOGIN:
-			RESULT_LOGIN(peer, msg);
-			break;
-
-		case QID_SAFEBOX_LOAD:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_LOAD");
-			RESULT_SAFEBOX_LOAD(peer, msg);
-			break;
-
-		case QID_SAFEBOX_CHANGE_SIZE:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_SIZE");
-			RESULT_SAFEBOX_CHANGE_SIZE(peer, msg);
-			break;
-
-		case QID_SAFEBOX_CHANGE_PASSWORD:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
-			RESULT_SAFEBOX_CHANGE_PASSWORD(peer, msg);
-			break;
-
-		case QID_SAFEBOX_CHANGE_PASSWORD_SECOND:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
-			RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(peer, msg);
-			break;
-
-		case QID_HIGHSCORE_REGISTER:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_HIGHSCORE_REGISTER %p", msg);
-			RESULT_HIGHSCORE_REGISTER(peer, msg);
-			break;
-
-		case QID_SAFEBOX_SAVE:
-		case QID_ITEM_SAVE:
-		case QID_ITEM_DESTROY:
-		case QID_QUEST_SAVE:
-		case QID_PLAYER_SAVE:
-		case QID_ITEM_AWARD_TAKEN:
-#ifdef __GROWTH_PET_SYSTEM__
-		case QID_GROWTH_PET_SAVE:
-		case QID_GROWTH_PET_DELETE:
-#endif
-			break;
-
-			// PLAYER_INDEX_CREATE_BUG_FIX
-		case QID_PLAYER_INDEX_CREATE:
-			RESULT_PLAYER_INDEX_CREATE(peer, msg);
-			break;
-			// END_PLAYER_INDEX_CREATE_BUG_FIX
-
-		case QID_PLAYER_DELETE:
-			__RESULT_PLAYER_DELETE(peer, msg);
-			break;
-
-		case QID_LOGIN_BY_KEY:
-			RESULT_LOGIN_BY_KEY(peer, msg);
-			break;
-
-			// MYSHOP_PRICE_LIST
-		case QID_ITEMPRICE_LOAD:
-			RESULT_PRICELIST_LOAD(peer, msg);
-			break;
-			// END_OF_MYSHOP_PRICE_LIST
-
-		default:
-			sys_log(0, "CClientManager::AnalyzeQueryResult unknown query result type: %d, str: %s", qi->iType, msg->stQuery.c_str());
-			break;
-	}
-
-	delete qi;
-	return true;
-}
-
-void UsageLog()
-{
-	FILE* fp = NULL;
-
-	time_t ct;
-	char* time_s;
-	struct tm lt;
-
-	int avg = g_dwUsageAvg / 3600; // 60 초 * 60 분
-
-	fp = fopen("usage.txt", "a+");
-
-	if (!fp)
-		return;
-
-	ct = time(0);
-	lt = *localtime(&ct);
-	time_s = asctime(&lt);
-
-	time_s[strlen(time_s) - 1] = '\0';
-
-	fprintf(fp, "| %4d %-15.15s | %5d | %5u |", lt.tm_year + 1900, time_s + 4, avg, g_dwUsageMax);
-
-	fprintf(fp, "\n");
-	fclose(fp);
-
-	g_dwUsageMax = g_dwUsageAvg = 0;
-}
-
-int CClientManager::Process()
-{
-	int pulses;
-
-	if (!(pulses = thecore_idle()))
-		return 0;
-
-	while (pulses--)
-	{
-		++thecore_heart->pulse;
-
-		/*
-		// 30분마다 변경
-		if (((thecore_pulse() % (60 * 30 * 10)) == 0))
-		{
-			g_iPlayerCacheFlushSeconds = MAX(60, rand() % 180);
-			g_iItemCacheFlushSeconds = MAX(60, rand() % 180);
-			sys_log(0, "[SAVE_TIME]Change saving time item %d player %d", g_iPlayerCacheFlushSeconds, g_iItemCacheFlushSeconds);
-		}
-		*/
-
-		if (!(thecore_heart->pulse % thecore_heart->passes_per_sec))
-		{
-			if (g_test_server)
-			{
-				if (!(thecore_heart->pulse % thecore_heart->passes_per_sec * 10))
-
-				{
-					pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d/%d",
-						thecore_heart->pulse,
-						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-						CDBManager::instance().CountReturnResult(SQL_PLAYER),
-						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-						CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
-						CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
-
-					if ((thecore_heart->pulse % 50) == 0)
-						sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
-							thecore_heart->pulse,
-							CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-							CDBManager::instance().CountReturnResult(SQL_PLAYER),
-							CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-							CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-							CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-							CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
-				}
-			}
-			else
-			{
-				pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d%/%d",
-					thecore_heart->pulse,
-					CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-					CDBManager::instance().CountReturnResult(SQL_PLAYER),
-					CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-					CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
-					CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-					CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-					CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
-					CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
-
-				if ((thecore_heart->pulse % 50) == 0)
-					sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
-						thecore_heart->pulse,
-						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-						CDBManager::instance().CountReturnResult(SQL_PLAYER),
-						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
-			}
-
-			CDBManager::instance().ResetCounter();
-
-			DWORD dwCount = CClientManager::instance().GetUserCount();
-
-			g_dwUsageAvg += dwCount;
-			g_dwUsageMax = MAX(g_dwUsageMax, dwCount);
-
-			memset(&thecore_profiler[0], 0, sizeof(thecore_profiler));
-
-#if defined(__EXPRESSING_EMOTIONS__)
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iEmoteDumpDelay)))
-				CClientManager::instance().QUERY_EMOTE_DUMP();
-#endif
-
-#if defined(__MAILBOX__)
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iMailBoxBackupSec)))
-				CClientManager::instance().MAILBOX_BACKUP();
-#endif
-
-#if defined(__GEM_SHOP__)
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iGemShopFlushDelay)))
-				CClientManager::instance().FlushGemShop();
-#endif
-
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600)))
-				UsageLog();
-
-			m_iCacheFlushCount = 0;
-
-			// 플레이어 플러쉬
-			UpdatePlayerCache();
-			// 아이템 플러쉬
-			UpdateItemCache();
-			//로그아웃시 처리- 캐쉬셋 플러쉬
-			UpdateLogoutPlayer();
-
-			// MYSHOP_PRICE_LIST
-			UpdateItemPriceListCache();
-			// END_OF_MYSHOP_PRICE_LIST
-#ifdef __OFFLINE_SHOP__
-			UpdateOfflineShopCache();
-			UpdateOfflineShopItemCache();
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-			UpdateGrowthPetCache();
-#endif
-			CGuildManager::instance().Update();
-			CPrivManager::instance().Update();
-			marriage::CManager::instance().Update();
-#ifdef __SHOP_SEARCH__
-			CShopSearchManager::Instance().Update();
-#endif
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 5)))
-		{
-			ItemAwardManager::instance().RequestLoad();
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 10)))
-		{
-			/*
-			char buf[4096 + 1];
-			int len
-
-			/////////////////////////////////////////////////////////////////
-			buf[0] = '\0';
-			len = 0;
-
-			auto it = g_query_info.m_map_info.begin();
-
-			int count = 0;
-
-			while (it != g_query_info.m_map_info.end())
-			{
-				len += snprintf(buf + len, sizeof(buf) - len, "%2d %3d\n", it->first, it->second);
-				count += it->second;
-				it++;
-			}
-
-			pt_log("QUERY:\n%s-------------------- MAX : %d\n", buf, count);
-			g_query_info.Reset();
-			*/
-			pt_log("QUERY: MAIN[%d] ASYNC[%d]", g_query_count[0], g_query_count[1]);
-			g_query_count[0] = 0;
-			g_query_count[1] = 0;
-			/////////////////////////////////////////////////////////////////
-
-			/////////////////////////////////////////////////////////////////
-			/*
-			buf[0] = '\0';
-			len = 0;
-
-			it = g_item_info.m_map_info.begin();
-
-			count = 0;
-			while (it != g_item_info.m_map_info.end())
-			{
-				len += snprintf(buf + len, sizeof(buf) - len, "%5d %3d\n", it->first, it->second);
-				count += it->second;
-				it++;
-			}
-
-			pt_log("ITEM:\n%s-------------------- MAX : %d\n", buf, count);
-			g_item_info.Reset();
-			*/
-			pt_log("ITEM:%d\n", g_item_count);
-			g_item_count = 0;
-			/////////////////////////////////////////////////////////////////
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60))) // 60초에 한번
-		{
-			// 유니크 아이템을 위한 시간을 보낸다.
-			CClientManager::instance().SendTime();
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600))) // 한시간에 한번
-		{
-			CMoneyLog::instance().Save();
-		}
-
-#if defined(__ENVIRONMENT_SYSTEM__)
-		static bool OnSetup = true;
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60 * 20)) || OnSetup)
-		{
-			UpdateEnvironment();
-			OnSetup = false;
-		}
-#endif
-	}
-
-	int num_events = fdwatch(m_fdWatcher, 0);
-	int idx;
-	CPeer* peer;
-
-	for (idx = 0; idx < num_events; ++idx) // 인풋
-	{
-		peer = (CPeer*)fdwatch_get_client_data(m_fdWatcher, idx);
-
-		if (!peer)
-		{
-			if (fdwatch_check_event(m_fdWatcher, m_fdAccept, idx) == FDW_READ)
-			{
-				AddPeer(m_fdAccept);
-				fdwatch_clear_event(m_fdWatcher, m_fdAccept, idx);
-			}
-			else
-			{
-				sys_log(0, "FDWATCH: peer null in event: ident %d", fdwatch_get_ident(m_fdWatcher, idx));
-			}
-
-			continue;
-		}
-
-		switch (fdwatch_check_event(m_fdWatcher, peer->GetFd(), idx))
-		{
-			case FDW_READ:
-				if (peer->Recv() < 0)
-				{
-					sys_err("Recv failed");
-					RemovePeer(peer);
-				}
-				else
-				{
-					if (peer == m_pkAuthPeer)
-						if (g_log)
-							sys_log(0, "AUTH_PEER_READ: size %d", peer->GetRecvLength());
-
-					ProcessPackets(peer);
-				}
-				break;
-
-			case FDW_WRITE:
-				if (peer == m_pkAuthPeer)
-					if (g_log)
-						sys_log(0, "AUTH_PEER_WRITE: size %d", peer->GetSendLength());
-
-				if (peer->Send() < 0)
-				{
-					sys_err("Send failed");
-					RemovePeer(peer);
-				}
-
-				break;
-
-			case FDW_EOF:
-				RemovePeer(peer);
-				break;
-
-			default:
-				sys_err("fdwatch_check_fd returned unknown result");
-				RemovePeer(peer);
-				break;
-		}
-	}
-
-#ifdef __WIN32__
-	if (_kbhit())
-	{
-		int c = _getch();
-		switch (c)
-		{
-			case 0x1b: // Esc
-				return 0; // shutdown
-				break;
-			default:
-				break;
-		}
-	}
-#endif
-
-	return 1;
-}
-
-DWORD CClientManager::GetUserCount()
-{
-	// 단순히 로그인 카운트를 센다.. --;
-	return m_map_kLogonAccount.size();
-}
-
-void CClientManager::SendAllGuildSkillRechargePacket()
-{
-	ForwardPacket(HEADER_DG_GUILD_SKILL_RECHARGE, NULL, 0);
-}
-
-void CClientManager::SendTime()
-{
-	time_t now = GetCurrentTime();
-	ForwardPacket(HEADER_DG_TIME, &now, sizeof(time_t));
-}
-
-void CClientManager::ForwardPacket(BYTE header, const void* data, int size, BYTE bChannel, CPeer* except)
-{
-	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* peer = *it;
-
-		if (peer == except)
-			continue;
-
-		if (!peer->GetChannel())
-			continue;
-
-		if (bChannel && peer->GetChannel() != bChannel)
-			continue;
-
-		peer->EncodeHeader(header, 0, size);
-
-		if (size > 0 && data)
-			peer->Encode(data, size);
-	}
-}
-
-void CClientManager::SendNotice(const char* c_pszFormat, ...)
-{
-	char szBuf[255 + 1];
-	va_list args;
-
-	va_start(args, c_pszFormat);
-	int len = vsnprintf(szBuf, sizeof(szBuf), c_pszFormat, args);
-	va_end(args);
-	szBuf[len] = '\0';
-
-	ForwardPacket(HEADER_DG_NOTICE, szBuf, len + 1);
-}
-
-time_t CClientManager::GetCurrentTime()
-{
-	return time(0);
-}
-
-// ITEM_UNIQUE_ID
-bool CClientManager::InitializeNowItemID()
-{
-	DWORD dwMin, dwMax;
-
-	// 아이템 ID를 초기화 한다.
-	if (!CConfig::instance().GetTwoValue("ITEM_ID_RANGE", &dwMin, &dwMax))
-	{
-		sys_err("config.txt: Cannot find ITEM_ID_RANGE [start_item_id] [end_item_id]");
-		return false;
-	}
-
-	sys_log(0, "ItemRange From File %u ~ %u ", dwMin, dwMax);
-
-	if (CItemIDRangeManager::instance().BuildRange(dwMin, dwMax, m_itemRange) == false)
-	{
-		sys_err("Can not build ITEM_ID_RANGE");
-		return false;
-	}
-
-	sys_log(0, " Init Success Start %u End %u Now %u\n", m_itemRange.dwMin, m_itemRange.dwMax, m_itemRange.dwUsableItemIDMin);
-
-	return true;
-}
-
-DWORD CClientManager::GainItemID()
-{
-	return m_itemRange.dwUsableItemIDMin++;
-}
-
-DWORD CClientManager::GetItemID()
-{
-	return m_itemRange.dwUsableItemIDMin;
-}
-// ITEM_UNIQUE_ID_END
-
-// BOOT_LOCALIZATION
-bool CClientManager::InitializeLocalization()
-{
-	char szQuery[512];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `mValue`, `mKey` FROM `locale`");
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
-
-	if (pMsg->Get()->uiNumRows == 0)
-	{
-		sys_err("InitializeLocalization() ==> DirectQuery failed(%s)", szQuery);
-		delete pMsg;
-		return false;
-	}
-
-	sys_log(0, "InitializeLocalization() - LoadLocaleTable(count:%d)", pMsg->Get()->uiNumRows);
-
-	m_vec_Locale.clear();
-
-	MYSQL_ROW row = NULL;
-
-	for (; (row = mysql_fetch_row(pMsg->Get()->pSQLResult)) != NULL;)
-	{
-		int col = 0;
-		tLocale locale;
-
-		strlcpy(locale.szValue, row[col++], sizeof(locale.szValue));
-		strlcpy(locale.szKey, row[col++], sizeof(locale.szKey));
-
-		// DB_NAME_COLUMN Setting
-		if (strcmp(locale.szKey, "LOCALE") == 0)
-		{
-			if (strcmp(locale.szValue, "cibn") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
-
-				g_stLocale = "gb2312";
-				g_stLocaleNameColumn = "gb2312name";
-			}
-			else if (strcmp(locale.szValue, "ymir") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "euckr";
-				g_stLocaleNameColumn = "name";
-			}
-			else if (strcmp(locale.szValue, "japan") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "sjis");
-
-				g_stLocale = "sjis";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "english") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "germany") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "france") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "italy") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "spain") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "uk") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "turkey") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin5";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "poland") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "portugal") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "hongkong") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
-
-				g_stLocale = "big5";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "newcibn") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
-
-				g_stLocale = "gb2312";
-				g_stLocaleNameColumn = "gb2312name";
-			}
-			else if (strcmp(locale.szValue, "korea") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "euckr";
-				g_stLocaleNameColumn = "name";
-			}
-			else if (strcmp(locale.szValue, "canada") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "gb2312name";
-			}
-			else if (strcmp(locale.szValue, "brazil") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "greek") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "greek";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "russia") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "cp1251";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "denmark") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "bulgaria") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "cp1251";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "croatia") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "cp1251";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "mexico") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "arabia") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "cp1256";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "czech") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "hungary") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "romania") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "netherlands") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "singapore") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "vietnam") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "thailand") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "usa") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "we_korea") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "euckr";
-				g_stLocaleNameColumn = "name";
-			}
-			else if (strcmp(locale.szValue, "taiwan") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
-				g_stLocale = "big5";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "europe") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else
-			{
-				sys_err("locale[LOCALE] = UNKNOWN(%s)", locale.szValue);
-				exit(0);
-			}
-
-			CDBManager::instance().SetLocale(g_stLocale.c_str());
-		}
-		else if (strcmp(locale.szKey, "DB_NAME_COLUMN") == 0)
-		{
-			sys_log(0, "locale[DB_NAME_COLUMN] = %s", locale.szValue);
-			g_stLocaleNameColumn = locale.szValue;
-		}
-		else
-		{
-			sys_log(0, "locale[UNKNOWN_KEY(%s)] = %s", locale.szKey, locale.szValue);
-		}
-		m_vec_Locale.push_back(locale);
-	}
-
-	delete pMsg;
-
-	return true;
-}
-// END_BOOT_LOCALIZATION
-
-// ADMIN_MANAGER
-bool CClientManager::__GetAdminInfo(const char* szIP, std::vector<tAdminInfo>& rAdminVec)
-{
-	// szIP == NULL 일경우 모든서버에 운영자 권한을 갖는다.
-	char szQuery[512];
-	snprintf(szQuery, sizeof(szQuery),
-		"SELECT `mID`, `mAccount`, `mName`, `mContactIP`, `mServerIP`, `mAuthority` FROM `gmlist` WHERE `mServerIP` = 'ALL' OR `mServerIP` = '%s'",
-		szIP ? szIP : "ALL");
-
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
-
-	if (pMsg->Get()->uiNumRows == 0)
-	{
-		sys_err("__GetAdminInfo() ==> DirectQuery failed(%s)", szQuery);
-		delete pMsg;
-		return false;
-	}
-
-	MYSQL_ROW row;
-	rAdminVec.reserve(pMsg->Get()->uiNumRows);
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		int idx = 0;
-		tAdminInfo Info;
-
-		str_to_number(Info.m_ID, row[idx++]);
-		trim_and_lower(row[idx++], Info.m_szAccount, sizeof(Info.m_szAccount));
-		strlcpy(Info.m_szName, row[idx++], sizeof(Info.m_szName));
-		strlcpy(Info.m_szContactIP, row[idx++], sizeof(Info.m_szContactIP));
-		strlcpy(Info.m_szServerIP, row[idx++], sizeof(Info.m_szServerIP));
-		std::string stAuth = row[idx++];
-
-		if (!stAuth.compare("IMPLEMENTOR"))
-			Info.m_Authority = GM_IMPLEMENTOR;
-		else if (!stAuth.compare("GOD"))
-			Info.m_Authority = GM_GOD;
-		else if (!stAuth.compare("HIGH_WIZARD"))
-			Info.m_Authority = GM_HIGH_WIZARD;
-		else if (!stAuth.compare("LOW_WIZARD"))
-			Info.m_Authority = GM_LOW_WIZARD;
-		else if (!stAuth.compare("WIZARD"))
-			Info.m_Authority = GM_WIZARD;
-		else
-			continue;
-
-		rAdminVec.push_back(Info);
-
-		sys_log(0, "GM: PID %u Login %s Character %s ContactIP %s ServerIP %s Authority %d[%s]",
-			Info.m_ID, Info.m_szAccount, Info.m_szName, Info.m_szContactIP, Info.m_szServerIP, Info.m_Authority, stAuth.c_str());
-	}
-
-	delete pMsg;
-
-	return true;
-}
-
-bool CClientManager::__GetHostInfo(std::vector<std::string>& rIPVec)
-{
-	char szQuery[512];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `mIP` FROM `gmhost`");
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
-
-	if (pMsg->Get()->uiNumRows == 0)
-	{
-		sys_err("__GetHostInfo() ==> DirectQuery failed(%s)", szQuery);
-		delete pMsg;
-		return false;
-	}
-
-	rIPVec.reserve(pMsg->Get()->uiNumRows);
-
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		if (row[0] && *row[0])
-		{
-			rIPVec.push_back(row[0]);
-			sys_log(0, "GMHOST: %s", row[0]);
-		}
-	}
-
-	delete pMsg;
-	return true;
-}
-// END_ADMIN_MANAGER
-
-void CClientManager::ReloadAdmin(CPeer*, TPacketReloadAdmin* p)
-{
-	std::vector<tAdminInfo> vAdmin;
-	std::vector<std::string> vHost;
-
-	__GetHostInfo(vHost);
-	__GetAdminInfo(p->szIP, vAdmin);
-
-	DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
-		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size();
-
-	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* peer = *it;
-
-		if (!peer->GetChannel())
-			continue;
-
-		peer->EncodeHeader(HEADER_DG_RELOAD_ADMIN, 0, dwPacketSize);
-
-		peer->EncodeWORD(16);
-		peer->EncodeWORD(static_cast<WORD>(vHost.size()));
-
-		for (size_t n = 0; n < vHost.size(); ++n)
-			peer->Encode(vHost[n].c_str(), 16);
-
-		peer->EncodeWORD(sizeof(tAdminInfo));
-		peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
-
-		for (size_t n = 0; n < vAdmin.size(); ++n)
-			peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
-	}
-
-	sys_log(0, "ReloadAdmin End %s", p->szIP);
-}
-
-// BREAK_MARRIAGE
-void CClientManager::BreakMarriage(CPeer* peer, const char* data)
-{
-	DWORD pid1, pid2;
-
-	pid1 = *(int*)data;
-	data += sizeof(int);
-
-	pid2 = *(int*)data;
-	data += sizeof(int);
-
-	sys_log(0, "Breaking off a marriage engagement! pid %d and pid %d", pid1, pid2);
-	marriage::CManager::instance().Remove(pid1, pid2);
-}
-// END_BREAK_MARIIAGE
-
-void CClientManager::UpdateItemCacheSet(DWORD pid)
-{
-	auto it = m_map_pkItemCacheSetPtr.find(pid);
-	if (it == m_map_pkItemCacheSetPtr.end())
-	{
-		if (g_test_server)
-			sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCacheSet ==> No ItemCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TItemCacheSet* pSet = it->second;
-	TItemCacheSet::iterator it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CItemCache* c = *it_set++;
-		c->Flush();
-	}
-
-	if (g_log)
-		sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCachsSet pid(%d)", pid);
-}
-
-void CClientManager::Election(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	DWORD idx;
-	DWORD selectingpid;
-
-	idx = *(DWORD*)data;
-	data += sizeof(DWORD);
-
-	selectingpid = *(DWORD*)data;
-	data += sizeof(DWORD);
-
-	int Success = 0;
-
-	if (!(Success = CMonarch::instance().VoteMonarch(selectingpid, idx)))
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_VOTE] Failed %d %d", idx, selectingpid);
-		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
-		peer->Encode(&Success, sizeof(int));
-		return;
-	}
-	else
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_VOTE] Success %d %d", idx, selectingpid);
-		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
-		peer->Encode(&Success, sizeof(int));
-		return;
-	}
-
-}
-
-void CClientManager::Candidacy(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	DWORD pid;
-
-	pid = *(DWORD*)data;
-	data += sizeof(DWORD);
-
-	if (!CMonarch::instance().AddCandidacy(pid, data))
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_CANDIDACY] Failed %d %s", pid, data);
-
-		peer->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
-		peer->Encode(0, sizeof(int));
-		peer->Encode(data, 32);
-		return;
-	}
-	else
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_CANDIDACY] Success %d %s", pid, data);
-
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (0 && p->GetChannel() != 0)
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
-				p->Encode(&pid, sizeof(int));
-				p->Encode(data, 32);
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_CANDIDACY, 0, sizeof(int) + 32);
-				p->Encode(&pid, sizeof(int));
-				p->Encode(data, 32);
-			}
-		}
-	}
-}
-
-void CClientManager::AddMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH] Add money Empire(%d) Money(%d)", Empire, Money);
-
-	CMonarch::instance().AddMoney(Empire, Money);
-
-	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* p = *it;
-
-		if (!p->GetChannel())
-			continue;
-
-		if (p == peer)
-		{
-			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-		else
-		{
-			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-
-	}
-}
-
-void CClientManager::DecMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH] Dec money Empire(%d) Money(%d)", Empire, Money);
-
-	CMonarch::instance().DecMoney(Empire, Money);
-
-	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* p = *it;
-
-		if (!p->GetChannel())
-			continue;
-
-		if (p == peer)
-		{
-			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-		else
-		{
-			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-	}
-}
-
-void CClientManager::TakeMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	DWORD pid = *(DWORD*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH] Take money Empire(%d) Money(%d)", Empire, Money);
-
-	if (CMonarch::instance().TakeMoney(Empire, pid, Money) == true)
-	{
-		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-		peer->Encode(&Empire, sizeof(int));
-		peer->Encode(&Money, sizeof(int));
-	}
-	else
-	{
-		Money = 0;
-		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-		peer->Encode(&Empire, sizeof(int));
-		peer->Encode(&Money, sizeof(int));
-	}
-}
-
-void CClientManager::ComeToVote(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	CMonarch::instance().ElectMonarch();
-}
-
-void CClientManager::RMCandidacy(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	char szName[32];
-
-	strlcpy(szName, data, sizeof(szName));
-	sys_log(0, "[MONARCH_GM] Remove candidacy name(%s)", szName);
-
-	int iRet = CMonarch::instance().DelCandidacy(szName) ? 1 : 0;
-
-	if (1 == iRet)
-	{
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-		}
-	}
-	else
-	{
-		CPeer* p = peer;
-		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-		p->Encode(&iRet, sizeof(int));
-		p->Encode(szName, sizeof(szName));
-	}
-}
-
-void CClientManager::SetMonarch(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	char szName[32];
-
-	strlcpy(szName, data, sizeof(szName));
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH_GM] Set Monarch name(%s)", szName);
-
-	int iRet = CMonarch::instance().SetMonarch(szName) ? 1 : 0;
-
-	if (1 == iRet)
-	{
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-		}
-	}
-	else
-	{
-		CPeer* p = peer;
-		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-		p->Encode(&iRet, sizeof(int));
-		p->Encode(szName, sizeof(szName));
-	}
-}
-
-void CClientManager::RMMonarch(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	char szName[32];
-
-	strlcpy(szName, data, sizeof(szName));
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH_GM] Remove Monarch name(%s)", szName);
-
-	CMonarch::instance().DelMonarch(szName);
-
-	int iRet = CMonarch::instance().DelMonarch(szName) ? 1 : 0;
-
-	if (1 == iRet)
-	{
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-		}
-	}
-	else
-	{
-		CPeer* p = peer;
-		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-		p->Encode(&iRet, sizeof(int));
-		p->Encode(szName, sizeof(szName));
-	}
-}
-
-void CClientManager::ChangeMonarchLord(CPeer* peer, DWORD dwHandle, TPacketChangeMonarchLord* info)
-{
-	char szQuery[1024];
-	snprintf(szQuery, sizeof(szQuery),
-		"SELECT a.`name`, NOW() FROM player%s AS a, player_index%s AS b WHERE (a.`account_id` = b.`id` AND a.`id` = %u AND b.`empire` = %u) AND "
-		"(b.`pid1` = %u OR "
-		"b.`pid2` = %u OR "
-		"b.`pid3` = %u OR "
-		"b.`pid4` = %u"
-#if defined(__PLAYER_PER_ACCOUNT5__)
-		" OR b.`pid5` = %u"
-#endif
-		")",
-		GetTablePostfix(),
-		GetTablePostfix(),
-		info->dwPID,
-		info->bEmpire,
-		info->dwPID,
-		info->dwPID,
-		info->dwPID,
-		info->dwPID
-#if defined(__PLAYER_PER_ACCOUNT5__)
-		, info->dwPID
-#endif
-	);
-
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
-
-	if (pMsg->Get()->uiNumRows != 0)
-	{
-		TPacketChangeMonarchLordACK ack;
-		ack.bEmpire = info->bEmpire;
-		ack.dwPID = info->dwPID;
-
-		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-		strlcpy(ack.szName, row[0], sizeof(ack.szName));
-		strlcpy(ack.szDate, row[1], sizeof(ack.szDate));
-
-		snprintf(szQuery, sizeof(szQuery), "UPDATE `monarch` SET `pid` = %u, `windate` = NOW() WHERE `empire` = %d", ack.dwPID, ack.bEmpire);
-		SQLMsg* pMsg2 = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
-
-		if (pMsg2->Get()->uiAffectedRows > 0)
-		{
-			CMonarch::instance().LoadMonarch();
-
-			TMonarchInfo* newInfo = CMonarch::instance().GetMonarch();
-
-			for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-			{
-				CPeer* client = *it;
-
-				client->EncodeHeader(HEADER_DG_CHANGE_MONARCH_LORD_ACK, 0, sizeof(TPacketChangeMonarchLordACK));
-				client->Encode(&ack, sizeof(TPacketChangeMonarchLordACK));
-
-				client->EncodeHeader(HEADER_DG_UPDATE_MONARCH_INFO, 0, sizeof(TMonarchInfo));
-				client->Encode(newInfo, sizeof(TMonarchInfo));
-			}
-		}
-
-		delete pMsg2;
-	}
-
-	delete pMsg;
-}
-
-void CClientManager::BlockException(TPacketBlockException* data)
-{
-	sys_log(0, "[BLOCK_EXCEPTION] CMD(%d) login(%s)", data->cmd, data->login);
-
-	// save sql
-	{
-		char buf[1024];
-
-		switch (data->cmd)
-		{
-			case BLOCK_EXCEPTION_CMD_ADD:
-				snprintf(buf, sizeof(buf), "INSERT INTO `block_exception` VALUES('%s')", data->login);
-				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
-				CBlockCountry::instance().AddBlockException(data->login);
-				break;
-			case BLOCK_EXCEPTION_CMD_DEL:
-				snprintf(buf, sizeof(buf), "DELETE FROM `block_exception` WHERE `login` = %s", data->login);
-				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
-				CBlockCountry::instance().DelBlockException(data->login);
-				break;
-			default:
-				return;
-		}
-
-	}
-
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* peer = *it;
-
-		if (!peer->GetChannel())
-			continue;
-
-		CBlockCountry::instance().SendBlockExceptionOne(peer, data->login, data->cmd);
-	}
-}
-
-void CClientManager::SendSpareItemIDRange(CPeer* peer)
-{
-	peer->SendSpareItemIDRange();
-}
-
-//
-// Login Key만 맵에서 지운다.
-//
-void CClientManager::DeleteLoginKey(TPacketDC* data)
-{
-	char login[LOGIN_MAX_LEN + 1] = { 0 };
-	trim_and_lower(data->login, login, sizeof(login));
-
-	CLoginData* pkLD = GetLoginDataByLogin(login);
-
-	if (pkLD)
-	{
-		TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(pkLD->GetKey());
-
-		if (it != m_map_pkLoginData.end())
-			m_map_pkLoginData.erase(it);
-	}
-}
-
-// delete gift notify icon
-void CClientManager::DeleteAwardId(TPacketDeleteAwardID* data)
-{
-	// sys_log(0, "data from game server arrived %d", data->dwID);
-	std::map<DWORD, TItemAward*>::iterator it;
-	it = ItemAwardManager::Instance().GetMapAward().find(data->dwID);
-	if (it != ItemAwardManager::Instance().GetMapAward().end())
-	{
-		std::set<TItemAward*>& kSet = ItemAwardManager::Instance().GetMapkSetAwardByLogin()[it->second->szLogin];
-		if (kSet.erase(it->second))
-			sys_log(0, "erase ItemAward id: %d from cache", data->dwID);
-		ItemAwardManager::Instance().GetMapAward().erase(data->dwID);
-	}
-	else
-	{
-		sys_log(0, "DELETE_AWARDID : could not find the id: %d", data->dwID);
-	}
-}
-
-void CClientManager::UpdateChannelStatus(TChannelStatus* pData)
-{
-	TChannelStatusMap::iterator it = m_mChannelStatus.find(pData->nPort);
-	if (it != m_mChannelStatus.end())
-	{
-		it->second = pData->bStatus;
-	}
-	else
-	{
-		m_mChannelStatus.insert(TChannelStatusMap::value_type(pData->nPort, pData->bStatus));
-	}
-}
-
-void CClientManager::RequestChannelStatus(CPeer* peer, DWORD dwHandle)
-{
-	const int nSize = m_mChannelStatus.size();
-	peer->EncodeHeader(HEADER_DG_RESPOND_CHANNELSTATUS, dwHandle, sizeof(TChannelStatus) * nSize + sizeof(int));
-	peer->Encode(&nSize, sizeof(int));
-	for (TChannelStatusMap::iterator it = m_mChannelStatus.begin(); it != m_mChannelStatus.end(); ++it)
-	{
-		peer->Encode(&it->first, sizeof(short));
-		peer->Encode(&it->second, sizeof(BYTE));
-	}
-}
-
-void CClientManager::ResetLastPlayerID(const TPacketNeedLoginLogInfo* data)
-{
-	CLoginData* pkLD = GetLoginDataByAID(data->dwPlayerID);
-
-	if (NULL != pkLD)
-	{
-		pkLD->SetLastPlayerID(0);
-	}
-}
-
-void CClientManager::ChargeCash(const TRequestChargeCash* packet)
-{
-	char szQuery[512];
-
-	if (ERequestCharge_Cash == packet->eChargeType)
-		sprintf(szQuery, "update account set `cash` = `cash` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
-	else if (ERequestCharge_Mileage == packet->eChargeType)
-		sprintf(szQuery, "update account set `mileage` = `mileage` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
-	else
-	{
-		sys_err("Invalid request charge type (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
-		return;
-	}
-
-	sys_err("Request Charge (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
-
-	CDBManager::Instance().AsyncQuery(szQuery, SQL_ACCOUNT);
-}
-
-#if defined(__MOVE_CHANNEL__)
-void CClientManager::FindChannel(CPeer* requestPeer, DWORD dwHandle, TPacketChangeChannel* p)
-{
-	if (!p->lMapIndex || !p->iChannel)
-		return;
-
-	long lAddr = 0;
-	WORD wPort = 0;
-
-	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* peer = *i;
-		if (peer->GetChannel() != p->iChannel) // not the channel we are looking for!
-			continue;
-
-		TMapLocation kMapLocation;
-		thecore_memcpy(kMapLocation.alMaps, peer->GetMaps(), sizeof(kMapLocation.alMaps));
-		int iLen = sizeof(kMapLocation.alMaps) / sizeof(kMapLocation.alMaps[0]);
-
-		for (int i = 0; i < iLen; ++i)
-		{
-			if (kMapLocation.alMaps[i] == p->lMapIndex)
-			{
-				// Get host, and convert to int
-				char host[16];
-				strlcpy(host, peer->GetPublicIP(), sizeof(kMapLocation.szHost));
-				lAddr = inet_addr(host);
-
-				// Target port
-				wPort = peer->GetListenPort();
-
-				break;
-			}
-		}
-
-		if (lAddr && wPort) // We already obtained them
-			break;
-	}
-
-	TPacketReturnChannel r;
-	r.lAddr = lAddr;
-	r.wPort = wPort;
-
-	requestPeer->EncodeHeader(HEADER_DG_CHANNEL_RESULT, dwHandle, sizeof(r));
-	requestPeer->Encode(&r, sizeof(r));
-}
-#endif
-
-#if defined(__ENVIRONMENT_SYSTEM__)
-enum DayMode : BYTE { DAY, NIGHT };
-
-static BYTE GetDayMode(int Hour)
-{
-	if (Hour >= 6 && Hour <= 20)
-		return DayMode::DAY;
-	return DayMode::NIGHT;
-}
-
-static bool IsWinter(int Month)
-{
-	return (Month >= 11 || Month <= 0);
-}
-
-void CClientManager::UpdateEnvironment()
-{
-	time_t CurrentTime = time(nullptr);
-	tm* tm = localtime(&CurrentTime);
-
-	auto SendFlag = [&](const char* flag, BYTE val)
-		{
-			TEventFlagMap::const_iterator it = m_map_lEventFlag.find(flag);
-			if ((it != m_map_lEventFlag.end() && it->second == val) == false)
-			{
-				TPacketSetEventFlag p;
-				std::strcpy(p.szFlagName, flag);
-				p.lValue = val;
-				SetEventFlag(&p);
-			}
-		};
-
-	SendFlag("eclipse", GetDayMode(tm->tm_hour));
-	BOOL Winter = IsWinter(tm->tm_mon);
-	for (const auto& Flag : { "xmas_snow" })
-		SendFlag(Flag, Winter);
-}
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-void CClientManager::QUERY_EMOTE_LOAD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
-{
-	if (pTable == nullptr)
-		return;
-
-	TEmoteTableVector* pVec = nullptr;
-	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
-	if (it != m_map_kPlayerEmote.end())
-		pVec = &it->second;
-
-	if (pVec && !pVec->empty())
-	{
-		const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
-		pVec->erase(std::remove_if(pVec->begin(), pVec->end(),
-			[dwCurrentTime](const TPacketGDEmote& rkTable)
-			{
-				return dwCurrentTime > rkTable.dwDuration;
-			}
-		), pVec->end());
-	}
-
-	const WORD wSize = pVec ? static_cast<WORD>(pVec->size()) : 0;
-	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(TPacketGDEmote) * wSize;
-
-	pkPeer->EncodeHeader(HEADER_DG_EMOTE_LOAD, dwHandle, dwPacketSize);
-	pkPeer->EncodeWORD(sizeof(TPacketGDEmote));
-	pkPeer->EncodeWORD(wSize);
-	if (pVec && !pVec->empty())
-		pkPeer->Encode(&(*pVec)[0], sizeof(TPacketGDEmote) * wSize);
-}
-
-void CClientManager::QUERY_EMOTE_CLEAR(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
-{
-	if (pTable == nullptr)
-		return;
-
-	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
-	if (it != m_map_kPlayerEmote.end())
-		it->second.clear();
-
-	QUERY_EMOTE_LOAD(pkPeer, dwHandle, pTable);
-}
-
-void CClientManager::QUERY_EMOTE_ADD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
-{
-	if (!pkPeer || !pTable)
-		return;
-
-	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
-
-	TPacketGDEmote GDPacket;
-	GDPacket.dwPID = pTable->dwPID;
-	GDPacket.dwVnum = pTable->dwVnum;
-	GDPacket.dwDuration = dwCurrentTime + pTable->dwDuration;
-
-	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
-	if (it != m_map_kPlayerEmote.end())
-	{
-		TEmoteTableVector& rkVec = it->second;
-		if (rkVec.size() >= SPECIAL_ACTION_SLOT_COUNT)
-		{
-			TPacketGDEmote& rkTable = rkVec[number(0, rkVec.size() - 1)];
-			if (dwCurrentTime >= rkTable.dwDuration)
-				rkTable.dwDuration = dwCurrentTime + pTable->dwDuration;
-			else
-				rkTable.dwDuration += pTable->dwDuration;
-
-			GDPacket.dwVnum = rkTable.dwVnum;
-			GDPacket.dwDuration = rkTable.dwDuration;
-		}
-		else
-		{
-			TEmoteTableVector::iterator itVec = std::find_if(rkVec.begin(), rkVec.end(),
-				[pTable](const TPacketGDEmote& rkTable)
-				{
-					return rkTable.dwVnum == pTable->dwVnum;
-				});
-
-			if (itVec != rkVec.end())
-			{
-				if (dwCurrentTime >= itVec->dwDuration)
-					itVec->dwDuration = dwCurrentTime + pTable->dwDuration;
-				else
-					itVec->dwDuration += pTable->dwDuration;
-
-				GDPacket.dwDuration = itVec->dwDuration;
-			}
-			else
-			{
-				pTable->dwDuration = GDPacket.dwDuration;
-				rkVec.emplace_back(*pTable);
-			}
-		}
-	}
-	else
-	{
-		pTable->dwDuration = GDPacket.dwDuration;
-		m_map_kPlayerEmote[pTable->dwPID].emplace_back(*pTable);
-	}
-
-	pkPeer->EncodeHeader(HEADER_DG_EMOTE_GET, dwHandle, sizeof(GDPacket));
-	pkPeer->Encode(&GDPacket, sizeof(GDPacket));
-}
-
-void CClientManager::QUERY_EMOTE_DUMP()
-{
-	CDBManager::instance().DirectQuery("TRUNCATE TABLE `player`.`emotions`");
-
-	if (m_map_kPlayerEmote.empty())
-		return;
-
-	char szQuery[1024];
-	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
-
-	for (TPlayerEmoteMap::value_type& it : m_map_kPlayerEmote)
-	{
-		TEmoteTableVector& rkVec = it.second;
-		if (rkVec.empty())
-			continue;
-
-		rkVec.erase(std::remove_if(rkVec.begin(), rkVec.end(),
-			[dwCurrentTime](const TPacketGDEmote& rkTable)
-			{
-				return dwCurrentTime > rkTable.dwDuration;
-			}
-		), rkVec.end());
-
-		for (const TPacketGDEmote& rkTable : rkVec)
-		{
-			snprintf(szQuery, sizeof(szQuery),
-				"REPLACE INTO emotions%s (`pid`, `vnum`, `duration`) VALUES(%d, %d, FROM_UNIXTIME(%d))",
-				GetTablePostfix(), rkTable.dwPID, rkTable.dwVnum, rkTable.dwDuration
-			);
-
-			std::unique_ptr<SQLMsg> pkInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-}
-#endif
-
-#if defined(__MAILBOX__)
-void CClientManager::QUERY_MAILBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	if (g_log)
-		sys_log(0, "QUERY_MAILBOX (handle: %d ch: %s)", dwHandle, p->szName);
-
-	std::vector<SMailBoxTable>* vec = nullptr;
-	auto it = m_map_mailbox.find(p->szName);
-	if (it != m_map_mailbox.end())
-		vec = &it->second;
-
-	if (vec)
-	{
-		const time_t now = std::time(nullptr);
-
-		vec->erase(std::remove_if(vec->begin(), vec->end(),
-			[now](const TMailBoxTable& mail)
-			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
-		), vec->end());
-
-		std::sort(vec->begin(), vec->end(),
-			[](const TMailBoxTable& l, const TMailBoxTable& r)
-			{
-				return l.Message.SendTime > r.Message.SendTime;
-			});
-	}
-
-	const WORD size = vec ? static_cast<WORD>(vec->size()) : 0;
-	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(SMailBoxTable) * size;
-
-	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_LOAD, dwHandle, dwPacketSize);
-	pkPeer->EncodeWORD(sizeof(SMailBoxTable));
-	pkPeer->EncodeWORD(size);
-
-	if (vec && vec->empty() == false)
-		pkPeer->Encode(&(*vec)[0], sizeof(SMailBoxTable) * size);
-}
-
-void CClientManager::QUERY_MAILBOX_CHECK_NAME(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	TMailBox t;
-	std::memcpy(t.szName, "", sizeof(t.szName));
-	t.Index = 0; // Index: Mail Count
-
-	static std::unordered_set<std::string> NameSet;
-	bool bFound = NameSet.find(p->szName) != NameSet.end();
-
-	if (bFound == false)
-	{
-		char s_szQuery[128];
-		//snprintf(s_szQuery, sizeof(s_szQuery), "SELECT * FROM player%s WHERE `name` = '%s' LIMIT 1", GetTablePostfix(), p->szName);
-		snprintf(s_szQuery, sizeof(s_szQuery), "SELECT * FROM player%s WHERE `name` = convert('%s' using utf8mb4) collate utf8mb4_bin LIMIT 1", GetTablePostfix(), p->szName);
-		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(s_szQuery));
-		bFound = pMsg->Get()->uiNumRows > 0;
-	}
-
-	if (bFound)
-	{
-		NameSet.emplace(p->szName); // player exists, next time we will use this to avoid using mysql.
-		std::memcpy(t.szName, p->szName, sizeof(t.szName));
-		auto it = m_map_mailbox.find(p->szName);
-		if (it != m_map_mailbox.end())
-		{
-			const time_t now = time(nullptr);
-			for (const SMailBoxTable& mail : it->second)
-			{
-				if (mail.bIsDeleted)
-					continue;
-
-				if (std::difftime(mail.Message.DeleteTime, now) <= 0)
-					continue;
-
-				t.Index++;
-			}
-		}
-	}
-
-	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_CHECK_NAME, dwHandle, sizeof(TMailBox));
-	pkPeer->Encode(&t, sizeof(TMailBox));
-}
-
-void CClientManager::QUERY_MAILBOX_WRITE(CPeer* pkPeer, DWORD dwHandle, TMailBoxTable* p)
-{
-	m_map_mailbox[p->szName].emplace_back(*p);
-}
-
-bool CClientManager::GET_MAIL(const char* name, const BYTE index, SMailBoxTable** mail)
-{
-	auto it = m_map_mailbox.find(name);
-	if (it == m_map_mailbox.end())
-		return false;
-
-	MailVec& mailvec = it->second;
-	if (index >= mailvec.size())
-		return false;
-
-	*mail = &mailvec.at(index);
-	return true;
-}
-
-void CClientManager::QUERY_MAILBOX_DELETE(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	SMailBoxTable* mail = nullptr;
-	if (GET_MAIL(p->szName, p->Index, &mail) == false)
-		return;
-
-	mail->bIsDeleted = true;
-}
-
-void CClientManager::QUERY_MAILBOX_CONFIRM(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	SMailBoxTable* mail = nullptr;
-	if (GET_MAIL(p->szName, p->Index, &mail) == false)
-		return;
-
-	mail->Message.bIsConfirm = true;
-}
-
-void CClientManager::QUERY_MAILBOX_GET(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	SMailBoxTable* mail = nullptr;
-	if (GET_MAIL(p->szName, p->Index, &mail) == false)
-		return;
-
-	mail->AddData.iYang = 0;
-	mail->AddData.iWon = 0;
-	mail->Message.bIsItemExist = false;
-	mail->Message.bIsConfirm = true;
-	mail->AddData.dwItemVnum = 0;
-	mail->AddData.dwItemCount = 0;
-	memset(mail->AddData.alSockets, 0, sizeof(mail->AddData.alSockets));
-	memset(mail->AddData.aAttr, 0, sizeof(mail->AddData.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	mail->AddData.dwChangeLookVnum = 0;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	memset(&mail->AddData.RefineElement, 0, sizeof(mail->AddData.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	memset(mail->AddData.aApplyRandom, 0, sizeof(mail->AddData.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-	mail->AddData.bSetValue = 0;
-#endif
-}
-
-void CClientManager::QUERY_MAILBOX_UNREAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	auto it = m_map_mailbox.find(p->szName);
-	if (it == m_map_mailbox.end())
-		return;
-
-	const MailVec& mailvec = it->second;
-	if (mailvec.empty())
-		return;
-
-	const time_t now = time(nullptr);
-	TMailBoxRespondUnreadData t;
-
-	for (const SMailBoxTable& mail : it->second)
-	{
-		if (mail.bIsDeleted)
-			continue;
-
-		if (mail.Message.bIsConfirm)
-			continue;
-
-		if (std::difftime(mail.Message.DeleteTime, now) <= 0)
-			continue;
-
-		if (mail.Message.bIsGMPost)
-			t.bGMVisible = true;
-
-		if (mail.Message.bIsItemExist)
-			t.bItemMessageCount++;
-		else
-			t.bCommonMessageCount++;
-	}
-
-	if ((t.bItemMessageCount + t.bCommonMessageCount) < 1)
-		return;
-
-	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_UNREAD, dwHandle, sizeof(TMailBoxRespondUnreadData));
-	pkPeer->Encode(&t, sizeof(TMailBoxRespondUnreadData));
-}
-
-void CClientManager::MAILBOX_BACKUP()
-{
-	CDBManager::instance().DirectQuery("TRUNCATE TABLE player.mailbox");
-
-	if (m_map_mailbox.empty())
-		return;
-
-	char szQuery[QUERY_MAX_LEN];
-	const time_t now = std::time(nullptr);
-
-	for (auto& p : m_map_mailbox)
-	{
-		auto& mailvec = p.second;
-		if (mailvec.empty())
-			continue;
-
-		mailvec.erase(std::remove_if(mailvec.begin(), mailvec.end(),
-			[now](const TMailBoxTable& mail)
-			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
-		), mailvec.end());
-
-		std::sort(mailvec.begin(), mailvec.end(),
-			[](const TMailBoxTable& l, const TMailBoxTable& r)
-			{
-				return l.Message.SendTime > r.Message.SendTime;
-			});
-
-		for (const auto& mail : mailvec)
-		{
-			snprintf(szQuery, sizeof(szQuery),
-				"INSERT INTO `mailbox%s` (`name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`"
-				", `gold`, `won`, `vnum`, `count`"
-				", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-				", `socket3`, `socket4`, `socket5`"
-#endif
-				", `attrtype0`, `attrvalue0`"
-				", `attrtype1`, `attrvalue1`"
-				", `attrtype2`, `attrvalue2`"
-				", `attrtype3`, `attrvalue3`"
-				", `attrtype4`, `attrvalue4`"
-				", `attrtype5`, `attrvalue5`"
-				", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				", `changelookvnum`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				", `refine_element_apply_type`"
-				", `refine_element_grade`"
-				", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-				", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-				", `apply_type0`, `apply_value0`, `apply_path0`"
-				", `apply_type1`, `apply_value1`, `apply_path1`"
-				", `apply_type2`, `apply_value2`, `apply_path2`"
-				", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-				", `set_value`"
-#endif
-				") VALUES ('%s', '%s', '%s', '%s', %d, %d, %d, %d" // `name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`
-				", %u, %u, %u, %u" // `gold`, `won`, `vnum`, `count`
-				", %ld, %ld, %ld" // `socket0`, `socket1`, `socket2`
-#if defined(__ITEM_SOCKET6__)
-				", %ld, %ld, %ld" // `socket3`, `socket4`, `socket5`
-#endif
-				", %u, %ld" // `attrtype0`, `attrvalue0`
-				", %u, %ld" // `attrtype1`, `attrvalue1`
-				", %u, %ld" // `attrtype2`, `attrvalue2`
-				", %u, %ld" // `attrtype3`, `attrvalue3`
-				", %u, %ld" // `attrtype4`, `attrvalue4`
-				", %u, %ld" // `attrtype5`, `attrvalue5`
-				", %u, %ld" // `attrtype6`, `attrvalue6`
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				", %u" // `changelookvnum`
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				", %u" // `refine_element_apply_type`
-				", %u" // `refine_element_grade`
-				", %u, %u, %u" // `refine_element_value0`, `refine_element_value1`, `refine_element_value2`
-				", %u, %u, %u" // `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-				", %u, %ld, %d" // `apply_type0`, `apply_value0`, `apply_path0`
-				", %u, %ld, %d" // `apply_type1`, `apply_value1`, `apply_path1`
-				", %u, %ld, %d" // `apply_type2`, `apply_value2`, `apply_path2`
-				", %u, %ld, %d" // `apply_type3`, `apply_value3`, `apply_path3`
-#endif
-#if defined(__SET_ITEM__)
-				", %d" // `set_value`
-#endif
-				")", GetTablePostfix()
-				, mail.szName
-				, mail.AddData.szFrom
-				, mail.Message.szTitle
-				, mail.AddData.szMessage
-				, mail.Message.bIsGMPost
-				, mail.Message.bIsConfirm
-				, mail.Message.SendTime
-				, mail.Message.DeleteTime
-				, mail.AddData.iYang
-				, mail.AddData.iWon
-				, mail.AddData.dwItemVnum
-				, mail.AddData.dwItemCount
-				, mail.AddData.alSockets[0], mail.AddData.alSockets[1], mail.AddData.alSockets[2]
-#if defined(__ITEM_SOCKET6__)
-				, mail.AddData.alSockets[3], mail.AddData.alSockets[4], mail.AddData.alSockets[5]
-#endif
-				, mail.AddData.aAttr[0].wType, mail.AddData.aAttr[0].lValue
-				, mail.AddData.aAttr[1].wType, mail.AddData.aAttr[1].lValue
-				, mail.AddData.aAttr[2].wType, mail.AddData.aAttr[2].lValue
-				, mail.AddData.aAttr[3].wType, mail.AddData.aAttr[3].lValue
-				, mail.AddData.aAttr[4].wType, mail.AddData.aAttr[4].lValue
-				, mail.AddData.aAttr[5].wType, mail.AddData.aAttr[5].lValue
-				, mail.AddData.aAttr[6].wType, mail.AddData.aAttr[6].lValue
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				, mail.AddData.dwChangeLookVnum
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				, mail.AddData.RefineElement.wApplyType
-				, mail.AddData.RefineElement.bGrade
-				, mail.AddData.RefineElement.abValue[0], mail.AddData.RefineElement.abValue[1], mail.AddData.RefineElement.abValue[2]
-				, mail.AddData.RefineElement.abBonusValue[0], mail.AddData.RefineElement.abBonusValue[1], mail.AddData.RefineElement.abBonusValue[2]
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-				, mail.AddData.aApplyRandom[0].wType, mail.AddData.aApplyRandom[0].lValue, mail.AddData.aApplyRandom[0].bPath
-				, mail.AddData.aApplyRandom[1].wType, mail.AddData.aApplyRandom[1].lValue, mail.AddData.aApplyRandom[1].bPath
-				, mail.AddData.aApplyRandom[2].wType, mail.AddData.aApplyRandom[2].lValue, mail.AddData.aApplyRandom[2].bPath
-				, mail.AddData.aApplyRandom[3].wType, mail.AddData.aApplyRandom[3].lValue, mail.AddData.aApplyRandom[3].bPath
-#endif
-#if defined(__SET_ITEM__)
-				, mail.AddData.bSetValue
-#endif
-			);
-
-			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-}
-#endif
-
-#if defined(__GEM_SHOP__)
-void CClientManager::LoadGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopLoad* pTable, bool bUpdate)
-{
-	if (g_log)
-		sys_log(0, "LoadGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
-
-	TGemShopTable GemShopTable = {};
-#	if defined(__CONQUEROR_LEVEL__)
-	GemShopTable.bSpecial = pTable->bSpecial;
-	if (GemShopTable.bSpecial)
-	{
-		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
-		if (it != m_mapGemShopSpecialTable.end())
-			GemShopTable = it->second;
-	}
-	else
-#	endif
-	{
-		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
-		if (it != m_mapGemShopTable.end())
-			GemShopTable = it->second;
-	}
-
-	pPeer->EncodeHeader(bUpdate ? HEADER_DG_GEM_SHOP_UPDATE : HEADER_DG_GEM_SHOP_LOAD, dwHandle, sizeof(GemShopTable));
-	pPeer->Encode(&GemShopTable, sizeof(GemShopTable));
-}
-
-void CClientManager::UpdateGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopTable* pTable)
-{
-	if (g_log)
-		sys_log(0, "UpdateGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
-
-#	if defined(__CONQUEROR_LEVEL__)
-	if (pTable->bSpecial)
-	{
-		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
-		if (it != m_mapGemShopSpecialTable.end())
-			it->second = *pTable;
-		else
-			m_mapGemShopSpecialTable.emplace(std::make_pair(pTable->dwPID, *pTable));
-	}
-	else
-#	endif
-	{
-		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
-		if (it != m_mapGemShopTable.end())
-			it->second = *pTable;
-		else
-			m_mapGemShopTable.emplace(std::make_pair(pTable->dwPID, *pTable));
-	}
-
-	// NOTE : Request Gem Shop Load
-	TGemShopLoad Packet;
-	Packet.dwPID = pTable->dwPID;
-#	if defined(__CONQUEROR_LEVEL__)
-	Packet.bSpecial = pTable->bSpecial;
-#	endif
-	LoadGemShop(pPeer, dwHandle, &Packet, true);
-}
-
-void CClientManager::FlushGemShop()
-{
-	// Flush Default Gem Shop Table
-	{
-		if (m_mapGemShopTable.empty())
-			return;
-
-		char szQuery[1024] = {};
-		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop%s`", GetTablePostfix());
-		CDBManager::instance().DirectQuery(szQuery);
-
-		GemShopTableMap::iterator it = m_mapGemShopTable.begin();
-		for (; it != m_mapGemShopTable.end(); ++it)
-		{
-			TGemShopTable GemShopTable = it->second;
-			if (it->first != GemShopTable.dwPID)
-				continue;
-
-			char szColumns[1024] = {};
-			char szValues[1024] = {};
-
-			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
-			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
-
-			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
-			{
-				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
-					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
-				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
-					GemShopTable.GemShopItem[bSlotIndex].bEnable,
-					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
-					GemShopTable.GemShopItem[bSlotIndex].bCount,
-					GemShopTable.GemShopItem[bSlotIndex].dwPrice
-				);
-			}
-
-			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop%s` (%s) VALUES(%s)",
-				GetTablePostfix(), szColumns, szValues);
-
-			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-
-#	if defined(__CONQUEROR_LEVEL__)
-	// Flush Port (Special) Gem Shop Table
-	{
-		if (m_mapGemShopSpecialTable.empty())
-			return;
-
-		char szQuery[1024] = {};
-		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop_port%s`", GetTablePostfix());
-		CDBManager::instance().DirectQuery(szQuery);
-
-		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.begin();
-		for (; it != m_mapGemShopSpecialTable.end(); ++it)
-		{
-			TGemShopTable GemShopTable = it->second;
-			if (it->first != GemShopTable.dwPID)
-				continue;
-
-			char szColumns[1024] = {};
-			char szValues[1024] = {};
-
-			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
-			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
-
-			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
-			{
-				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
-					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
-				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
-					GemShopTable.GemShopItem[bSlotIndex].bEnable,
-					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
-					GemShopTable.GemShopItem[bSlotIndex].bCount,
-					GemShopTable.GemShopItem[bSlotIndex].dwPrice
-				);
-			}
-
-			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop_port%s` (%s) VALUES(%s)",
-				GetTablePostfix(), szColumns, szValues);
-
-			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-#	endif
-}
-#endif
-
-#ifdef __OFFLINE_SHOP__
-void CClientManager::InitializeNextOfflineShopId()
-{
-	std::stringstream query;
-	query << "SELECT MAX(id) + 1 FROM offline_shop" << GetTablePostfix();
-
-	std::unique_ptr<SQLMsg> msg(CDBManager::Instance().DirectQuery(query.str().c_str()));
-	if (msg && msg->Get()->uiNumRows > 0) {
-		auto row = mysql_fetch_row(msg->Get()->pSQLResult);
-		str_to_number(nextOfflineShopId_, row[0]);
-	}
-	else {
-		nextOfflineShopId_ = 1;
-	}
-
-	sys_log(0, "Next offline shop id: %u", nextOfflineShopId_);
-}
-
-void CClientManager::RequestOfflineShopId(CPeer* peer, uint32_t queueId)
-{
-	peer->EncodeHeader(HEADER_DG_RESPOND_OFFLINE_SHOP_ID, 0, sizeof(uint32_t) + sizeof(uint32_t));
-	peer->Encode(&queueId, sizeof(uint32_t));
-	peer->Encode(&nextOfflineShopId_, sizeof(uint32_t));
-
-	nextOfflineShopId_++;
-}
-
-void CClientManager::SaveOfflineShop(const TOfflineShop& data, bool skipQuery)
-{
-	auto it = offlineShopCache_.find(data.id);
-	if (it != offlineShopCache_.end()) {
-		it->second->Put(&data);
-	}
-	else {
-		auto cache = std::unique_ptr<COfflineShopCache>(new COfflineShopCache());
-		cache->Put(&data, skipQuery);
-
-		offlineShopCache_.insert(std::make_pair(data.id, std::move(cache)));
-	}
-}
-
-void CClientManager::SaveOfflineShopItem(const TOfflineShopItem& data, bool skipQuery)
-{
-	auto it = offlineShopItemCache_.find(data.id);
-	if (it != offlineShopItemCache_.end()) {
-		it->second->Put(&data);
-	}
-	else {
-		auto cache = std::unique_ptr<COfflineShopItemCache>(new COfflineShopItemCache());
-		cache->Put(&data, skipQuery);
-
-		offlineShopItemCache_.insert(std::make_pair(data.id, std::move(cache)));
-	}
-}
-
-void CClientManager::DestroyOfflineShop(uint32_t id)
-{
-	auto it = offlineShopCache_.find(id);
-	if (it != offlineShopCache_.end()) {
-		offlineShopCache_.erase(it);
-	}
-
-	std::pair<uint32_t, uint16_t> key = { id, 0 };
-	for (uint16_t i = 0; i < OFFLINE_SHOP_ITEM_COUNT; ++i) {
-		key.second = i;
-
-		auto it = offlineShopItemCache_.find(key);
-		if (it != offlineShopItemCache_.end()) {
-			offlineShopItemCache_.erase(it);
-		}
-	}
-
-	std::stringstream queryDeleteOfflineShop;
-	queryDeleteOfflineShop << "DELETE FROM offline_shop" << GetTablePostfix() << " WHERE id = " << id;
-	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShop.str().c_str());
-
-	std::stringstream queryDeleteOfflineShopItems;
-	queryDeleteOfflineShopItems << "DELETE FROM offline_shop_item" << GetTablePostfix() << " WHERE owner_pid = " << id;
-	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShopItems.str().c_str());
-}
-
-void CClientManager::UpdateOfflineShopCache()
-{
-	auto it = offlineShopCache_.begin();
-	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopCache_.end()) {
-		if (it->second->CheckFlushTimeout()) {
-			it->second->Flush();
-
-			m_iCacheFlushCount++;
-		}
-
-		it++;
-	}
-}
-
-void CClientManager::UpdateOfflineShopItemCache()
-{
-	auto it = offlineShopItemCache_.begin();
-	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopItemCache_.end()) {
-		if (it->second->CheckFlushTimeout()) {
-			it->second->Flush();
-
-			m_iCacheFlushCount++;
-		}
-
-		it++;
-	}
-}
-
-void CClientManager::FlushOfflineShops()
-{
-	for (auto it = offlineShopCache_.begin(); it != offlineShopCache_.end(); ++it) {
-		it->second->Flush();
-	}
-
-	for (auto it = offlineShopItemCache_.begin(); it != offlineShopItemCache_.end(); ++it) {
-		it->second->Flush();
-	}
-}
-
-const TItemTable* CClientManager::GetItemTable(DWORD vnum) const
-{
-	auto it = m_map_itemTableByVnum.find(vnum);
-	if (it == m_map_itemTableByVnum.end())
-	{
-		return NULL;
-	}
-
-	return it->second;
-}
-
-BYTE CClientManager::GetRealItemType(DWORD vnum)
-{
-	if (vnum >= 110000 && vnum <= 165499)
-		return ITEM_DS;
-	
-	
-	/* SHIT :
-	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
-	{
-		if (it->second->dwVnum == vnum)
-		{
-			return it->second->bType;
-		}
-	}
-	*/
-	
-	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
-	{
-		if (it->dwVnum == vnum)
-		{
-			return it->bType;
-		}
-	}
-	
-	return ITEM_NONE;
-}
-
-BYTE CClientManager::GetRealItemSubType(DWORD vnum)
-{
-	/* SHIT:
-	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
-	{
-		if (it->second->dwVnum == vnum)
-		{
-			return it->second->bSubType;
-		}
-	}
-	*/
-	
-	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
-	{
-		if (it->dwVnum == vnum)
-		{
-			return it->bSubType;
-		}
-	}
-	
-	return 0;
-}
-
-void CClientManager::GetRealItemLimit(DWORD vnum, int & limitType, DWORD & limitValue)
-{
-	/* BUGGED SHIT :
-	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
-	{
-		if (it->second->dwVnum == vnum)
-		{
-			limitType = it->second->aLimits[0].bType;
-			limitValue = it->second->aLimits[0].lValue;
-			return;
-		}
-	}
-	*/
-	
-	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
-	{
-		if (it->dwVnum == vnum)
-		{
-			limitType = it->aLimits[0].bType;
-			limitValue = it->aLimits[0].lValue;
-			return;
-		}
-	}
-}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-CClientManager::TGrowthPetCacheSet* CClientManager::GetGrowthPetCacheSet(DWORD pid)
-{
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
-
-	if (it == m_map_pkGrowthPetCacheSetPtr.end())
-		return nullptr;
-
-	return it->second;
-}
-
-void CClientManager::CreateGrowthPetCacheSet(DWORD pid)
-{
-	if (m_map_pkGrowthPetCacheSetPtr.find(pid) != m_map_pkGrowthPetCacheSetPtr.end())
-		return;
-				 
-	TGrowthPetCacheSet* pSet = new TGrowthPetCacheSet;
-	m_map_pkGrowthPetCacheSetPtr.insert(TGrowthPetCacheSetPtrMap::value_type(pid, pSet));
-
-	if (g_log)
-		sys_log(0, "GROWTH_PET_CACHE: new cache %u", pid);
-}
-
-void CClientManager::FlushGrowthPetCacheSet(DWORD pid)
-{
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
-
-	if (it == m_map_pkGrowthPetCacheSetPtr.end())
-	{
-		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : No GrowthPetCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TGrowthPetCacheSet* pSet = it->second;
-	auto it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CGrowthPetCache* c = *it_set++;
-		c->Flush();
-
-		m_map_growthPetCache.erase(c->Get()->dwID);
-		delete c;
-	}
-
-	pSet->clear();
-	delete pSet;
-
-	m_map_pkGrowthPetCacheSetPtr.erase(it);
-
-	if (g_log)
-		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : Deleted pid(%d)", pid);
-}
-
-CGrowthPetCache* CClientManager::GetGrowthPetCache(DWORD id)
-{
-	auto it = m_map_growthPetCache.find(id);
-
-	if (it == m_map_growthPetCache.end())
-		return nullptr;
-
-	return it->second;
-}
-
-void CClientManager::PutGrowthPetCache(TGrowthPet* pNew, bool bSkipQuery)
-{
-	CGrowthPetCache* c;
-
-	c = GetGrowthPetCache(pNew->dwID);
-	if (!c)
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> New CGrowthPetCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
-
-		c = new CGrowthPetCache;
-		m_map_growthPetCache.insert(TGrowthPetCacheMap::value_type(pNew->dwID, c));
-	}
-	else
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> Have Cache");
-		if (pNew->dwOwner != c->Get()->dwOwner)
-		{
-			auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
-
-			if (it != m_map_pkGrowthPetCacheSetPtr.end())
-			{
-				if (g_log)
-					sys_log(0, "GROWTH_PET_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
-				it->second->erase(c);
-			}
-		}
-	}
-	c->Put(pNew, bSkipQuery);
-
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
-
-	if (it != m_map_pkGrowthPetCacheSetPtr.end())
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		it->second->insert(c);
-	}
-	else
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-
-		c->OnFlush();
-	}
-}
-
-bool CClientManager::DeleteGrowthPetCache(DWORD dwID)
-{
-	CGrowthPetCache* c = GetGrowthPetCache(dwID);
-
-	if (!c)
-		return false;
-
-	c->Delete();
-	return true;
-}
-
-void CClientManager::UpdateGrowthPetCache()
-{
-	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-		return;
-
-	auto it = m_map_growthPetCache.begin();
-
-	while (it != m_map_growthPetCache.end())
-	{
-		CGrowthPetCache* c = (it++)->second;
-
-		if (c->CheckFlushTimeout())
-		{
-			if (g_test_server)
-				sys_log(0, "UpdateGrowthPetCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
-
-			c->Flush();
-
-			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-				break;
-		}
-	}
-}
-
-void CClientManager::UpdateGrowthPetCacheSet(DWORD pid)
-{
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
-
-	if (it == m_map_pkGrowthPetCacheSetPtr.end())
-	{
-		if (g_test_server)
-			sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet ==> No GrowthPetCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TGrowthPetCacheSet* pSet = it->second;
-	auto it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CGrowthPetCache* c = *it_set++;
-		c->Flush();
-	}
-
-	if (g_log)
-		sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet pid(%d)", pid);
-}
-
-void CClientManager::QUERY_GROWTH_PET_SAVE(CPeer* pkPeer, const char* c_pData)
-{
-	TGrowthPet* p = (TGrowthPet*)c_pData;
-	if (g_test_server)
-		sys_log(0, "QUERY_GROWTH_PET_SAVE => PutGrowthPetCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
-
-	PutGrowthPetCache(p);
-}
-
-void CClientManager::QUERY_GROWTH_PET_DELETE(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwID = *(DWORD*)c_pData;
-	c_pData += sizeof(DWORD);
-
-	DWORD dwPID = *(DWORD*)c_pData;
-
-	if (!DeleteGrowthPetCache(dwID))
-	{
-		char szQuery[64];
-		snprintf(szQuery, sizeof(szQuery), "DELETE FROM growth_pet%s WHERE id=%u", GetTablePostfix(), dwID);
-
-		if (dwPID == 0)
-			CDBManager::instance().AsyncQuery(szQuery);
-		else
-			CDBManager::instance().ReturnQuery(szQuery, QID_GROWTH_PET_DELETE, pkPeer->GetHandle(), NULL);
-	}
-}
-
-bool CClientManager::CreateGrowthPetTableFromRes(MYSQL_RES* res, std::vector<TGrowthPet>* pVec, DWORD dwPID)
-{
-	if (!res)
-	{
-		pVec->clear();
-		return true;
-	}
-
-	int rows;
-
-	if ((rows = mysql_num_rows(res)) <= 0)
-	{
-		pVec->clear();
-		return true;
-	}
-
-	pVec->resize(rows);
-
-	for (int i = 0; i < rows; ++i)
-	{
-		MYSQL_ROW row = mysql_fetch_row(res);
-		TGrowthPet& pet = pVec->at(i);
-
-		int cur = 0;
-
-		str_to_number(pet.dwID, row[cur++]);
-		str_to_number(pet.dwVnum, row[cur++]);
-		str_to_number(pet.bState, row[cur++]);
-		strlcpy(pet.szName, row[cur++], sizeof(pet.szName));
-		str_to_number(pet.bSize, row[cur++]);
-		str_to_number(pet.dwLevel, row[cur++]);
-		str_to_number(pet.bLevelStep, row[cur++]);
-		str_to_number(pet.bEvolution, row[cur++]);
-		str_to_number(pet.bType, row[cur++]);
-		str_to_number(pet.dwHP, row[cur++]);
-		str_to_number(pet.dwSP, row[cur++]);
-		str_to_number(pet.dwDef, row[cur++]);
-		str_to_number(pet.dwHPApply, row[cur++]);
-		str_to_number(pet.dwSPApply, row[cur++]);
-		str_to_number(pet.dwDefApply, row[cur++]);
-		str_to_number(pet.dwAgeApply, row[cur++]);
-		thecore_memcpy(pet.aSkill, row[cur++], sizeof(pet.aSkill));
-		str_to_number(pet.lExp, row[cur++]);
-		str_to_number(pet.lItemExp, row[cur++]);
-		str_to_number(pet.lBirthday, row[cur++]);
-		str_to_number(pet.lEndTime, row[cur++]);
-		str_to_number(pet.lMaxTime, row[cur++]);
-
-		pet.dwOwner = dwPID;
-	}
-
-	return true;
-}
-
-void CClientManager::RESULT_GROWTH_PET_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID)
-{
-	static std::vector<TGrowthPet> s_petVec;
-	CreateGrowthPetTableFromRes(pRes, &s_petVec, dwPID);
-	DWORD dwCount = s_petVec.size();
-
-	peer->EncodeHeader(HEADER_DG_GROWTH_PET_LOAD, dwHandle, sizeof(DWORD) + sizeof(TGrowthPet) * dwCount);
-	peer->EncodeDWORD(dwCount);
-
-	CreateGrowthPetCacheSet(dwPID);
-
-	sys_log(0, "GROWTH_PET_LOAD: count %u pid %u", dwCount, dwPID);
-
-	if (dwCount)
-	{
-		peer->Encode(&s_petVec[0], sizeof(TGrowthPet) * dwCount);
-
-		for (DWORD i = 0; i < dwCount; ++i)
-			PutGrowthPetCache(&s_petVec[i], true);
-	}
-}
-#endif
+#include "stdafx.h"
+
+#include "../../common/building.h"
+#include "../../common/VnumHelper.h"
+#include "../../libgame/include/grid.h"
+
+#include "ClientManager.h"
+
+#include "Main.h"
+#include "Config.h"
+#include "DBManager.h"
+#include "QID.h"
+#include "GuildManager.h"
+#include "PrivManager.h"
+#include "MoneyLog.h"
+#include "ItemAwardManager.h"
+#include "Marriage.h"
+#include "Monarch.h"
+#include "BlockCountry.h"
+#include "ItemIDRangeManager.h"
+#include "Cache.h"
+
+#include <sstream>
+#if defined(__SHOP_SEARCH__)
+	#include "ShopSearchManager.h"
+#endif
+
+extern int g_iPlayerCacheFlushSeconds;
+extern int g_iItemCacheFlushSeconds;
+extern int g_test_server;
+extern int g_log;
+extern std::string g_stLocale;
+extern std::string g_stLocaleNameColumn;
+bool CreateItemTableFromRes(MYSQL_RES* res, std::vector<TPlayerItem>* pVec, DWORD dwPID);
+
+DWORD g_dwUsageMax = 0;
+DWORD g_dwUsageAvg = 0;
+
+CPacketInfo g_query_info;
+CPacketInfo g_item_info;
+
+int g_item_count = 0;
+int g_query_count[2];
+
+CClientManager::CClientManager() :
+	m_pkAuthPeer(NULL),
+	m_iPlayerIDStart(0),
+	m_iPlayerDeleteLevelLimit(0),
+	m_iPlayerDeleteLevelLimitLower(0),
+	m_bChinaEventServer(false),
+	m_iShopTableSize(0),
+	m_pShopTable(NULL),
+	m_iRefineTableSize(0),
+	m_pRefineTable(NULL),
+	m_bShutdowned(false),
+	m_iCacheFlushCount(0),
+	m_iCacheFlushCountLimit(200)
+#if defined(__EXPRESSING_EMOTIONS__)
+	, m_iEmoteDumpDelay(3600)
+#endif
+#if defined(__MAILBOX__)
+	, m_iMailBoxBackupSec(3600)
+#endif
+#if defined(__GEM_SHOP__)
+	, m_iGemShopFlushDelay(3600)
+#endif
+{
+	m_itemRange.dwMin = 0;
+	m_itemRange.dwMax = 0;
+	m_itemRange.dwUsableItemIDMin = 0;
+
+	memset(g_query_count, 0, sizeof(g_query_count));
+}
+
+CClientManager::~CClientManager()
+{
+	Destroy();
+}
+
+void CClientManager::SetPlayerIDStart(int iIDStart)
+{
+	m_iPlayerIDStart = iIDStart;
+}
+
+void CClientManager::Destroy()
+{
+	m_mChannelStatus.clear();
+	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		(*i)->Destroy();
+
+	m_peerList.clear();
+
+	if (m_fdAccept > 0)
+	{
+		socket_close(m_fdAccept);
+		m_fdAccept = -1;
+	}
+}
+
+bool CClientManager::Initialize()
+{
+	int tmpValue;
+
+	// BOOT_LOCALIZATION
+	if (!InitializeLocalization())
+	{
+		fprintf(stderr, "Failed Localization Infomation so exit\n");
+		return false;
+	}
+	// END_BOOT_LOCALIZATION
+
+	// ITEM_UNIQUE_ID
+	if (!InitializeNowItemID())
+	{
+		fprintf(stderr, " Item range Initialize Failed. Exit DBCache Server\n");
+		return false;
+	}
+	// END_ITEM_UNIQUE_ID
+
+	m_bWolfmanCharacter = true;
+	int iWolfmanCharacter = 0;
+	if (CConfig::instance().GetValue("WOLFMAN_CHARACTER", &iWolfmanCharacter))
+		m_bWolfmanCharacter = (iWolfmanCharacter);
+	sys_log(0, "WOLFMAN_CHARACTER %s", m_bWolfmanCharacter ? "true" : "false");
+
+	m_bDelayedCharacterCreation = true;
+	int iDelayedCharacterCreation = 0;
+	if (CConfig::instance().GetValue("DELAYED_CHARACTER_CREATION", &iDelayedCharacterCreation))
+		m_bDelayedCharacterCreation = (iDelayedCharacterCreation);
+	sys_log(0, "DELAYED_CHARACTER_CREATION %s", m_bDelayedCharacterCreation ? "true" : "false");
+
+	if (!InitializeTables())
+	{
+		sys_err("Table Initialize FAILED");
+		return false;
+	}
+
+	CGuildManager::instance().BootReserveWar();
+
+	if (!CConfig::instance().GetValue("BIND_PORT", &tmpValue))
+		tmpValue = 5300;
+
+	char szBindIP[128];
+
+	if (!CConfig::instance().GetValue("BIND_IP", szBindIP, 128))
+		strlcpy(szBindIP, "0", sizeof(szBindIP));
+
+	m_fdAccept = socket_tcp_bind(szBindIP, tmpValue);
+
+	if (m_fdAccept < 0)
+	{
+		perror("socket");
+		return false;
+	}
+
+	sys_log(0, "ACCEPT_HANDLE: %u", m_fdAccept);
+	fdwatch_add_fd(m_fdWatcher, m_fdAccept, NULL, FDW_READ, false);
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	CConfig::instance().GetValue("EMOTE_DUMP_DELAY", &m_iEmoteDumpDelay);
+#endif
+
+#if defined(__MAILBOX__)
+	CConfig::instance().GetValue("MAILBOX_BACKUP_SEC", &m_iMailBoxBackupSec);
+#endif
+
+#if defined(__GEM_SHOP__)
+	CConfig::instance().GetValue("GEM_SHOP_FLUSH_DELAY", &m_iGemShopFlushDelay);
+#endif
+
+	if (!CConfig::instance().GetValue("BACKUP_LIMIT_SEC", &tmpValue))
+		tmpValue = 600;
+
+	m_looping = true;
+
+	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT", &m_iPlayerDeleteLevelLimit))
+	{
+		sys_err("config.txt: Cannot find PLAYER_DELETE_LEVEL_LIMIT, use default level %d", PLAYER_MAX_LEVEL_CONST + 1);
+		m_iPlayerDeleteLevelLimit = PLAYER_MAX_LEVEL_CONST + 1;
+	}
+
+	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT_LOWER", &m_iPlayerDeleteLevelLimitLower))
+	{
+		m_iPlayerDeleteLevelLimitLower = 0;
+	}
+
+	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT set to %d", m_iPlayerDeleteLevelLimit);
+	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT_LOWER set to %d", m_iPlayerDeleteLevelLimitLower);
+
+	m_bChinaEventServer = false;
+
+	int iChinaEventServer = 0;
+
+	if (CConfig::instance().GetValue("CHINA_EVENT_SERVER", &iChinaEventServer))
+		m_bChinaEventServer = (iChinaEventServer);
+
+	sys_log(0, "CHINA_EVENT_SERVER %s", CClientManager::instance().IsChinaEventServer() ? "true" : "false");
+
+	LoadEventFlag();
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	LoadGuildEventFlag();
+#endif
+
+	// database character-set  
+	if (g_stLocale == "big5" || g_stLocale == "sjis")
+		CDBManager::instance().QueryLocaleSet();
+
+	return true;
+}
+
+void CClientManager::MainLoop()
+{
+	SQLMsg* tmp;
+
+	sys_log(0, "ClientManager pointer is %p", this);
+
+	// 管
+	while (!m_bShutdowned)
+	{
+		while ((tmp = CDBManager::instance().PopResult()))
+		{
+			AnalyzeQueryResult(tmp);
+			delete tmp;
+		}
+
+		if (!Process())
+			break;
+
+		log_rotate();
+	}
+
+	//
+	// 管 처
+	//
+	sys_log(0, "MainLoop exited, Starting cache flushing");
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	CClientManager::instance().QUERY_EMOTE_DUMP();
+#endif
+
+#if defined(__MAILBOX__)
+	CClientManager::instance().MAILBOX_BACKUP();
+#endif
+
+#if defined(__GEM_SHOP__)
+	// Gem Shop Item Data List Flush
+	CClientManager::instance().FlushGemShop();
+#endif
+
+	signal_timer_disable();
+
+	// 첨潔 遣 캐 첨
+	auto it = m_map_playerCache.begin();
+	while (it != m_map_playerCache.end())
+	{
+		CPlayerTableCache* c = (it++)->second;
+
+		c->Flush();
+		delete c;
+	}
+	m_map_playerCache.clear();
+
+	//  첨
+	auto it2 = m_map_itemCache.begin();
+	while (it2 != m_map_itemCache.end())
+	{
+		CItemCache* c = (it2++)->second;
+
+		c->Flush();
+		delete c;
+	}
+	m_map_itemCache.clear();
+
+	// MYSHOP_PRICE_LIST
+	//
+	// 貫   트 Flush
+	//
+	for (auto itPriceList = m_mapItemPriceListCache.begin(); itPriceList != m_mapItemPriceListCache.end(); ++itPriceList)
+	{
+		CItemPriceListTableCache* pCache = itPriceList->second;
+		pCache->Flush();
+		delete pCache;
+	}
+
+	m_mapItemPriceListCache.clear();
+#ifdef __OFFLINE_SHOP__
+	FlushOfflineShops();
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	auto growthPetCache = m_map_growthPetCache.begin();
+
+	while (growthPetCache != m_map_growthPetCache.end())
+	{
+		CGrowthPetCache* c = (growthPetCache++)->second;
+
+		c->Flush();
+		delete c;
+	}
+	m_map_growthPetCache.clear();
+#endif
+
+	// END_OF_MYSHOP_PRICE_LIST
+}
+
+void CClientManager::Quit()
+{
+	m_bShutdowned = true;
+}
+
+void CClientManager::QUERY_BOOT(CPeer* peer, TPacketGDBoot* p)
+{
+	const BYTE bPacketVersion = 6; // BOOT 킷 侮除㎏ 호 첩 磯.
+
+	std::vector<tAdminInfo> vAdmin;
+	std::vector<std::string> vHost;
+
+	__GetHostInfo(vHost);
+	__GetAdminInfo(p->szIP, vAdmin);
+
+	sys_log(0, "QUERY_BOOT : AdminInfo (Request ServerIp %s) ", p->szIP);
+
+	DWORD dwPacketSize =
+		sizeof(DWORD) +
+		sizeof(BYTE) +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TShopTable) * m_iShopTableSize +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemAttrTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemRareTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(building::TLand) * m_vec_kLandTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObjectProto) * m_vec_kObjectProto.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObject) * m_map_pkObjectTable.size() +
+#ifdef __GROWTH_PET_SYSTEM__
+		sizeof(WORD) + sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size() +
+#endif
+		sizeof(time_t) +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemIDRangeTable) * 2 +
+		// ADMIN_MANAGER
+		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
+		// END_ADMIN_MANAGER
+		sizeof(WORD) + sizeof(WORD) + sizeof(TMonarchInfo) +
+		sizeof(WORD) + sizeof(WORD) + sizeof(MonarchCandidacy) * CMonarch::instance().MonarchCandidacySize() +
+		sizeof(WORD);
+
+	peer->EncodeHeader(HEADER_DG_BOOT, 0, dwPacketSize);
+	peer->Encode(&dwPacketSize, sizeof(DWORD));
+	peer->Encode(&bPacketVersion, sizeof(BYTE));
+
+	sys_log(0, "BOOT: PACKET: %d", dwPacketSize);
+	sys_log(0, "BOOT: VERSION: %d", bPacketVersion);
+
+	sys_log(0, "sizeof(TMobTable) = %d", sizeof(TMobTable));
+	sys_log(0, "sizeof(TItemTable) = %d", sizeof(TItemTable));
+	sys_log(0, "sizeof(TShopTable) = %d", sizeof(TShopTable));
+	sys_log(0, "sizeof(TSkillTable) = %d", sizeof(TSkillTable));
+	sys_log(0, "sizeof(TRefineTable) = %d", sizeof(TRefineTable));
+	sys_log(0, "sizeof(TItemAttrTable) = %d", sizeof(TItemAttrTable));
+	sys_log(0, "sizeof(TItemRareTable) = %d", sizeof(TItemAttrTable));
+	sys_log(0, "sizeof(TBanwordTable) = %d", sizeof(TBanwordTable));
+	sys_log(0, "sizeof(TLand) = %d", sizeof(building::TLand));
+	sys_log(0, "sizeof(TObjectProto) = %d", sizeof(building::TObjectProto));
+	sys_log(0, "sizeof(TObject) = %d", sizeof(building::TObject));
+	// ADMIN_MANAGER
+	sys_log(0, "sizeof(tAdminInfo) = %d * %d ", sizeof(tAdminInfo) * vAdmin.size());
+	// END_ADMIN_MANAGER
+	sys_log(0, "sizeof(TMonarchInfo) = %d * %d", sizeof(TMonarchInfo));
+#ifdef __GROWTH_PET_SYSTEM__
+	sys_log(0, "sizeof(TGrowthPetSkillTable) = %d", sizeof(TGrowthPetSkillTable));
+#endif
+
+	peer->EncodeWORD(sizeof(TMobTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
+	peer->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
+
+	peer->EncodeWORD(sizeof(TItemTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
+	peer->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
+
+	peer->EncodeWORD(sizeof(TShopTable));
+	peer->EncodeWORD(m_iShopTableSize);
+	peer->Encode(m_pShopTable, sizeof(TShopTable) * m_iShopTableSize);
+
+	peer->EncodeWORD(sizeof(TSkillTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
+	peer->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
+
+	peer->EncodeWORD(sizeof(TRefineTable));
+	peer->EncodeWORD(m_iRefineTableSize);
+	peer->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
+
+	peer->EncodeWORD(sizeof(TItemAttrTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_itemAttrTable.size()));
+	peer->Encode(&m_vec_itemAttrTable[0], sizeof(TItemAttrTable) * m_vec_itemAttrTable.size());
+
+	peer->EncodeWORD(sizeof(TItemAttrTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_itemRareTable.size()));
+	peer->Encode(&m_vec_itemRareTable[0], sizeof(TItemAttrTable) * m_vec_itemRareTable.size());
+
+	peer->EncodeWORD(sizeof(TBanwordTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
+	peer->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
+
+	peer->EncodeWORD(sizeof(building::TLand));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_kLandTable.size()));
+	peer->Encode(&m_vec_kLandTable[0], sizeof(building::TLand) * m_vec_kLandTable.size());
+
+	peer->EncodeWORD(sizeof(building::TObjectProto));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_kObjectProto.size()));
+	peer->Encode(&m_vec_kObjectProto[0], sizeof(building::TObjectProto) * m_vec_kObjectProto.size());
+
+	peer->EncodeWORD(sizeof(building::TObject));
+	peer->EncodeWORD(static_cast<WORD>(m_map_pkObjectTable.size()));
+
+	auto it = m_map_pkObjectTable.begin();
+	while (it != m_map_pkObjectTable.end())
+		peer->Encode((it++)->second, sizeof(building::TObject));
+
+#ifdef __GROWTH_PET_SYSTEM__
+	peer->EncodeWORD(sizeof(TGrowthPetSkillTable));
+	peer->EncodeWORD(m_vec_growthPetSkillTable.size());
+	if (m_vec_growthPetSkillTable.size())
+		peer->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
+#endif
+
+	time_t now = time(0);
+	peer->Encode(&now, sizeof(time_t));
+
+	TItemIDRangeTable itemRange = CItemIDRangeManager::instance().GetRange();
+	TItemIDRangeTable itemRangeSpare = CItemIDRangeManager::instance().GetRange();
+
+	peer->EncodeWORD(sizeof(TItemIDRangeTable));
+	peer->EncodeWORD(1);
+	peer->Encode(&itemRange, sizeof(TItemIDRangeTable));
+	peer->Encode(&itemRangeSpare, sizeof(TItemIDRangeTable));
+
+	peer->SetItemIDRange(itemRange);
+	peer->SetSpareItemIDRange(itemRangeSpare);
+
+	// ADMIN_MANAGER
+	peer->EncodeWORD(16);
+	peer->EncodeWORD(static_cast<WORD>(vHost.size()));
+
+	for (size_t n = 0; n < vHost.size(); ++n)
+	{
+		peer->Encode(vHost[n].c_str(), 16);
+		sys_log(0, "GMHosts %s", vHost[n].c_str());
+	}
+
+	peer->EncodeWORD(sizeof(tAdminInfo));
+	peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
+
+	for (size_t n = 0; n < vAdmin.size(); ++n)
+	{
+		peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
+		sys_log(0, "Admin name %s ConntactIP %s", vAdmin[n].m_szName, vAdmin[n].m_szContactIP);
+	}
+	// END_ADMIN_MANAGER
+
+	// MONARCH
+	peer->EncodeWORD(sizeof(TMonarchInfo));
+	peer->EncodeWORD(1);
+	peer->Encode(CMonarch::instance().GetMonarch(), sizeof(TMonarchInfo));
+
+	CMonarch::VEC_MONARCHCANDIDACY& rVecMonarchCandidacy = CMonarch::instance().GetVecMonarchCandidacy();
+
+	size_t num_monarch_candidacy = CMonarch::instance().MonarchCandidacySize();
+	peer->EncodeWORD(sizeof(MonarchCandidacy));
+	peer->EncodeWORD(static_cast<WORD>(num_monarch_candidacy));
+	if (num_monarch_candidacy != 0)
+	{
+		peer->Encode(&rVecMonarchCandidacy[0], sizeof(MonarchCandidacy) * num_monarch_candidacy);
+	}
+	// END_MONARCE
+
+	if (g_test_server)
+		sys_log(0, "MONARCHCandidacy Size %d", CMonarch::instance().MonarchCandidacySize());
+
+#ifdef __OFFLINE_SHOP__
+	peer->EncodeDWORD(sizeof(TOfflineShop));
+	peer->EncodeDWORD(offlineShopCache_.size());
+	for (const auto& entry : offlineShopCache_) {
+		peer->Encode(entry.second->Get(), sizeof(TOfflineShop));
+	}
+
+	peer->EncodeDWORD(sizeof(TOfflineShopItem));
+	peer->EncodeDWORD(offlineShopItemCache_.size());
+	for (const auto& entry : offlineShopItemCache_) {
+		peer->Encode(entry.second->Get(), sizeof(TOfflineShopItem));
+	}
+#endif
+
+	peer->EncodeWORD(0xffff);
+}
+
+void CClientManager::SendPartyOnSetup(CPeer* pkPeer)
+{
+	TPartyMap& pm = m_map_pkChannelParty[pkPeer->GetChannel()];
+	for (auto it_party = pm.begin(); it_party != pm.end(); ++it_party)
+	{
+		sys_log(0, "PARTY SendPartyOnSetup Party [%u]", it_party->first);
+		pkPeer->EncodeHeader(HEADER_DG_PARTY_CREATE, 0, sizeof(TPacketPartyCreate));
+		pkPeer->Encode(&it_party->first, sizeof(DWORD));
+
+		for (auto it_member = it_party->second.begin(); it_member != it_party->second.end(); ++it_member)
+		{
+			sys_log(0, "PARTY SendPartyOnSetup Party [%u] Member [%u]", it_party->first, it_member->first);
+			pkPeer->EncodeHeader(HEADER_DG_PARTY_ADD, 0, sizeof(TPacketPartyAdd));
+			pkPeer->Encode(&it_party->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->second.bRole, sizeof(BYTE));
+
+			pkPeer->EncodeHeader(HEADER_DG_PARTY_SET_MEMBER_LEVEL, 0, sizeof(TPacketPartySetMemberLevel));
+			pkPeer->Encode(&it_party->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->second.bLevel, sizeof(BYTE));
+		}
+	}
+}
+
+void CClientManager::QUERY_PLAYER_COUNT(CPeer* pkPeer, TPlayerCountPacket* pPacket)
+{
+	pkPeer->SetUserCount(pPacket->dwCount);
+}
+
+void CClientManager::QUERY_QUEST_SAVE(CPeer* pkPeer, TQuestTable* pTable, DWORD dwLen)
+{
+	if (0 != (dwLen % sizeof(TQuestTable)))
+	{
+		sys_err("invalid packet size %d, sizeof(TQuestTable) == %d", dwLen, sizeof(TQuestTable));
+		return;
+	}
+
+	int iSize = dwLen / sizeof(TQuestTable);
+
+	char szQuery[1024];
+
+	for (int i = 0; i < iSize; ++i, ++pTable)
+	{
+		if (pTable->lValue == 0)
+		{
+			snprintf(szQuery, sizeof(szQuery), "DELETE FROM quest%s WHERE `dwPID` = %d AND `szName` = '%s' AND `szState` ='%s'",
+				GetTablePostfix(), pTable->dwPID, pTable->szName, pTable->szState);
+		}
+		else
+		{
+			snprintf(szQuery, sizeof(szQuery), "REPLACE INTO quest%s (`dwPID`, `szName`, `szState`, `lValue`) VALUES(%d, '%s', '%s', %ld)",
+				GetTablePostfix(), pTable->dwPID, pTable->szName, pTable->szState, pTable->lValue);
+		}
+
+		CDBManager::instance().ReturnQuery(szQuery, QID_QUEST_SAVE, pkPeer->GetHandle(), NULL);
+	}
+}
+
+void CClientManager::QUERY_SAFEBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TSafeboxLoadPacket* packet, bool bMall)
+{
+	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
+	strlcpy(pi->safebox_password, packet->szPassword, sizeof(pi->safebox_password));
+	pi->account_id = packet->dwID;
+	pi->account_index = 0;
+	pi->ip[0] = bMall ? 1 : 0;
+	strlcpy(pi->login, packet->szLogin, sizeof(pi->login));
+
+	char szQuery[QUERY_MAX_LEN];
+	snprintf(szQuery, sizeof(szQuery),
+		"SELECT `account_id`, `size`, `password` FROM safebox%s WHERE `account_id` = %u",
+		GetTablePostfix(), packet->dwID);
+
+	if (g_log)
+		sys_log(0, "HEADER_GD_SAFEBOX_LOAD (handle: %d account.id %u is_mall %d)", dwHandle, packet->dwID, bMall ? 1 : 0);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
+}
+
+void CClientManager::RESULT_SAFEBOX_LOAD(CPeer* pkPeer, SQLMsg* msg)
+{
+	sys_log(0, "RESULT_SAFEBOX_LOAD");
+
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = pi->dwHandle;
+
+	// 藪 求 account_index   磯.
+	// 첫째 戟 鱇틂  求  0
+	// 菅째  拷   1
+
+	if (pi->account_index == 0)
+	{
+		sys_log(0, "RESULT_SAFEBOX_LOAD account_index == 0");
+
+		char szSafeboxPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
+		strlcpy(szSafeboxPassword, pi->safebox_password, sizeof(szSafeboxPassword));
+
+		TSafeboxTable* pSafebox = new TSafeboxTable;
+		memset(pSafebox, 0, sizeof(TSafeboxTable));
+
+		SQLResult* res = msg->Get();
+
+		if (res->uiNumRows == 0)
+		{
+			if (strcmp("000000", szSafeboxPassword))
+			{
+				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
+				delete pSafebox;
+				delete pi;
+				return;
+			}
+		}
+		else
+		{
+			sys_log(0, "RESULT_SAFEBOX_LOAD get rows");
+
+			MYSQL_ROW row = mysql_fetch_row(res->pSQLResult);
+
+			// 橘호 틀..
+			if (((!row[2] || !*row[2]) && strcmp("000000", szSafeboxPassword)) ||
+				((row[2] && *row[2]) && strcmp(row[2], szSafeboxPassword)))
+			{
+				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
+				delete pSafebox;
+				delete pi;
+				return;
+			}
+
+			if (!row[0])
+				pSafebox->dwID = 0;
+			else
+				str_to_number(pSafebox->dwID, row[0]);
+
+			if (!row[1])
+				pSafebox->bSize = 0;
+			else
+				str_to_number(pSafebox->bSize, row[1]);
+			/*
+			if (!row[3])
+				pSafebox->dwGold = 0;
+			else
+				pSafebox->dwGold = atoi(row[3]);
+			*/
+			if (pi->ip[0] == 1)
+			{
+#if defined(__EXTEND_MALLBOX__)
+				pSafebox->bSize = 5;
+#else
+				pSafebox->bSize = 1;
+#endif
+				sys_log(0, "MALL id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
+			}
+			else
+				sys_log(0, "SAFEBOX id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
+		}
+
+		if (0 == pSafebox->dwID)
+			pSafebox->dwID = pi->account_id;
+
+		pi->pSafebox = pSafebox;
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
+#if defined(__SOUL_BIND_SYSTEM__)
+			", `soulbind`"
+#endif
+			", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+			", `socket3`, `socket4`, `socket5`"
+#endif
+			", `attrtype0`, `attrvalue0`"
+			", `attrtype1`, `attrvalue1`"
+			", `attrtype2`, `attrvalue2`"
+			", `attrtype3`, `attrvalue3`"
+			", `attrtype4`, `attrvalue4`"
+			", `attrtype5`, `attrvalue5`"
+			", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			", `transmutation`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			", `refine_element_apply_type`"
+			", `refine_element_grade`"
+			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			", `apply_type0`, `apply_value0`, `apply_path0`"
+			", `apply_type1`, `apply_value1`, `apply_path1`"
+			", `apply_type2`, `apply_value2`, `apply_path2`"
+			", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+			", `set_value`"
+#endif
+			" FROM `item%s` WHERE `owner_id` = %u AND `window` = '%s'",
+			GetTablePostfix(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL");
+
+		pi->account_index = 1;
+
+		CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
+	}
+	else
+	{
+		sys_log(0, "RESULT_SAFEBOX_LOAD YES!!!!!!!!!!!");
+
+		if (!pi->pSafebox)
+		{
+			sys_err("null safebox pointer!");
+			delete pi;
+			return;
+		}
+
+		//   羚퓐   창 獵  처
+		// 堅  창 틴 효째 
+		if (!msg->Get()->pSQLResult)
+		{
+			sys_err("null safebox result");
+			delete pi;
+			return;
+		}
+
+		static std::vector<TPlayerItem> s_items;
+		CreateItemTableFromRes(msg->Get()->pSQLResult, &s_items, pi->account_id);
+
+		ItemAwardSet* pSet = ItemAwardManager::instance().GetByLogin(pi->login);
+
+		if (pSet && !m_vec_itemTable.empty())
+		{
+#if defined(__EXTEND_MALLBOX__)
+			CGrid grid(5, MAX(1, 5) * 9);
+#else
+			CGrid grid(5, MAX(1, pi->pSafebox->bSize) * 9);
+#endif
+			bool bEscape = false;
+
+			for (DWORD i = 0; i < s_items.size(); ++i)
+			{
+				TPlayerItem& r = s_items[i];
+
+				auto it = m_map_itemTableByVnum.find(r.dwVnum);
+				if (it == m_map_itemTableByVnum.end())
+				{
+					bEscape = true;
+					sys_err("invalid item vnum %u in safebox: login %s", r.dwVnum, pi->login);
+					break;
+				}
+
+				grid.Put(r.wPos, 1, it->second->bSize);
+			}
+
+			if (!bEscape)
+			{
+				std::vector<std::pair<DWORD, DWORD> > vec_dwFinishedAwardID;
+				ItemAwardSet::const_iterator it = pSet->begin();
+				char szQuery[512];
+
+				while (it != pSet->end())
+				{
+					TItemAward* pItemAward = *(it++);
+					const DWORD& dwItemVnum = pItemAward->dwVnum;
+
+					if (pItemAward->bTaken)
+						continue;
+
+					if (pi->ip[0] == 0 && pItemAward->bMall)
+						continue;
+
+					if (pi->ip[0] == 1 && !pItemAward->bMall)
+						continue;
+
+					auto it = m_map_itemTableByVnum.find(pItemAward->dwVnum);
+					if (it == m_map_itemTableByVnum.end())
+					{
+						sys_err("invalid item vnum %u in item_award: login %s", pItemAward->dwVnum, pi->login);
+						continue;
+					}
+
+					TItemTable* pItemTable = it->second;
+
+					int iPos;
+
+					if ((iPos = grid.FindBlank(1, it->second->bSize)) == -1)
+						break;
+
+					TPlayerItem item;
+					memset(&item, 0, sizeof(TPlayerItem));
+
+#if defined(__EXTENDED_ITEM_AWARD__)
+					DWORD dwSocket0 = pItemAward->dwSocket0;
+					DWORD dwSocket2 = pItemAward->dwSocket2;
+					DWORD dwSocket4 = pItemAward->dwSocket4;
+					DWORD dwSocket5 = pItemAward->dwSocket5;
+#else
+					DWORD dwSocket2 = 0;
+#endif
+
+					if (pItemTable->bType == ITEM_UNIQUE)
+					{
+#if defined(__EXTENDED_ITEM_AWARD__)
+						// 12.04.2019 - Correction for unique items based on the real time.
+						const long lValue0 = pItemTable->alValues[ITEM_SOCKET_REMAIN_SEC];
+						const long lValue2 = pItemTable->alValues[ITEM_SOCKET_UNIQUE_REMAIN_TIME];
+						const time_t tNow = CClientManager::instance().GetCurrentTime();
+						dwSocket2 = (lValue2 == 0) ? static_cast<DWORD>(lValue0) : static_cast<DWORD>(tNow + lValue0);
+#else
+						if (pItemAward->dwSocket2 != 0)
+							dwSocket2 = pItemAward->dwSocket2;
+						else
+							dwSocket2 = pItemTable->alValues[0];
+#endif
+					}
+					else if ((dwItemVnum == ITEM_SKILLBOOK_VNUM || dwItemVnum == ITEM_SKILLFORGET_VNUM) && pItemAward->dwSocket0 == 0)
+					{
+						DWORD dwSkillIdx;
+						DWORD dwSkillVnum;
+
+						do
+						{
+							dwSkillIdx = number(0, m_vec_skillTable.size() - 1);
+
+							dwSkillVnum = m_vec_skillTable[dwSkillIdx].dwVnum;
+
+							if (dwSkillVnum > 120)
+								continue;
+
+							break;
+						} while (1);
+
+#if !defined(__EXTENDED_ITEM_AWARD__)
+						pItemAward->dwSocket0 = dwSkillVnum;
+#endif
+					}
+					else
+					{
+						switch (dwItemVnum)
+						{
+							case 72723: case 72724: case 72725: case 72726:
+							case 72727: case 72728: case 72729: case 72730:
+								// 첫  求  치 ...
+								// 瀏 柳 溝 湄.  悶 湄 滂.
+							case 76004: case 76005: case 76021: case 76022:
+							case 79012: case 79013:
+								if (pItemAward->dwSocket2 == 0)
+								{
+									dwSocket2 = pItemTable->alValues[0];
+								}
+								else
+								{
+									dwSocket2 = pItemAward->dwSocket2;
+								}
+								break;
+						}
+					}
+
+					if (GetItemID() > m_itemRange.dwMax)
+					{
+						sys_err("UNIQUE ID OVERFLOW!!");
+						break;
+					}
+
+					{
+						auto it = m_map_itemTableByVnum.find(dwItemVnum);
+						if (it == m_map_itemTableByVnum.end())
+						{
+							sys_err("Invalid item(vnum : %d). It is not in m_map_itemTableByVnum.", dwItemVnum);
+							continue;
+						}
+						TItemTable* item_table = it->second;
+						if (item_table == NULL)
+						{
+							sys_err("Invalid item_table (vnum : %d). It's value is NULL in m_map_itemTableByVnum.", dwItemVnum);
+							continue;
+						}
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+						if ((item_table->bType == ITEM_UNIQUE && item_table->bType == COSTUME_MOUNT))
+						{
+							if (pItemAward->dwSocket4 == 0)
+								dwSocket4 = pItemTable->alValues[0];
+							else
+								dwSocket4 = pItemAward->dwSocket4;
+						}
+#endif
+
+						if (0 == pItemAward->dwSocket0)
+						{
+							// Load default values
+							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+							{
+								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
+									break;
+								}
+								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
+									break;
+								}
+							}
+						}
+						else
+						{
+#if defined(__EXTENDED_ITEM_AWARD__)
+							// Load set values
+							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+							{
+								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
+								{
+									dwSocket0 = time(0) + pItemAward->dwSocket0;
+									break;
+								}
+								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
+								{
+									dwSocket0 = pItemAward->dwSocket0;
+									break;
+								}
+							}
+#else
+							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+							{
+								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
+
+									break;
+								}
+								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
+
+									break;
+								}
+							}
+#endif
+						}
+
+#if defined(__EXTENDED_ITEM_AWARD__)
+						ItemAwardManager::instance().CheckItemCount(*pItemAward, *pItemTable);
+						ItemAwardManager::instance().CheckItemBlend(*pItemAward, *pItemTable);
+						ItemAwardManager::instance().CheckItemAddonType(*pItemAward, *pItemTable);
+						ItemAwardManager::instance().CheckItemSkillBook(*pItemAward, m_vec_skillTable);
+						ItemAwardManager::instance().CheckItemAttributes(*pItemAward, *pItemTable, m_vec_itemAttrTable);
+
+						// START_OF_AUTO_QUERY
+						char szColumns[QUERY_MAX_LEN], szValues[QUERY_MAX_LEN];
+
+						int iLen = snprintf(szColumns, sizeof(szColumns), "`id`, `owner_id`, `window`, `pos`, `vnum`, `count`");
+						int iValueLen = snprintf(szValues, sizeof(szValues), "%u, %u, '%s', %d, %u, %u", GainItemID(), pi->account_id, (pi->ip[0] == 0) ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount);
+
+#if defined(__ITEM_SOCKET6__)
+						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`, `socket3`, `socket4`, `socket5`");
+						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u, %u, %u, %u", dwSocket0, pItemAward->dwSocket1, dwSocket2, pItemAward->dwSocket3, pItemAward->dwSocket4, pItemAward->dwSocket5);
+#else
+						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`");
+						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u", pItemAward->dwSocket0, pItemAward->dwSocket1, dwSocket2);
+#endif
+
+						for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
+						{
+							iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `attrtype%d`, `attrvalue%d`", i, i);
+							iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %ld", pItemAward->aAttr[i].wType, pItemAward->aAttr[i].lValue);
+						}
+						// END_OF_AUTO_QUERY
+
+						snprintf(szQuery, sizeof(szQuery), "INSERT INTO item%s (%s) VALUES(%s)", GetTablePostfix(), szColumns, szValues);
+#else
+						snprintf(szQuery, sizeof(szQuery),
+							"INSERT INTO item%s (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
+							", `socket0`"
+							", `socket1`"
+							", `socket2`"
+#if defined(__ITEM_SOCKET6__)
+							", `socket3`"
+							", `socket4`"
+							", `socket5`"
+#endif
+							") VALUES (%u, %u, '%s', %d, %u, %u"
+							", %u"
+							", %u"
+							", %u"
+#if defined(__ITEM_SOCKET6__)
+							", %u"
+							", %u"
+							", %u"
+#endif
+							")",
+							GetTablePostfix(), GainItemID(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount
+							, pItemAward->dwSocket0
+							, pItemAward->dwSocket1
+							, dwSocket2
+#if defined(__ITEM_SOCKET6__)
+							, pItemAward->dwSocket3
+							, pItemAward->dwSocket4
+							, pItemAward->dwSocket5
+#endif
+						);
+#endif
+					}
+
+					std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+					SQLResult* pRes = pmsg->Get();
+					sys_log(0, "SAFEBOX Query : [%s]", szQuery);
+
+					if (pRes->uiAffectedRows == 0 || pRes->uiInsertID == 0 || pRes->uiAffectedRows == (uint32_t)-1)
+						break;
+
+					item.dwID = pmsg->Get()->uiInsertID;
+					if (pi->ip[0] == 0)
+						item.bWindow = SAFEBOX, item.wPos = iPos;
+					else
+						item.bWindow = MALL, item.wPos = iPos;
+					item.dwVnum = pItemAward->dwVnum;
+					item.dwCount = pItemAward->dwCount;
+#if defined(__EXTENDED_ITEM_AWARD__)
+					item.alSockets[0] = dwSocket0;
+#else
+					item.alSockets[0] = pItemAward->dwSocket0;
+#endif
+					item.alSockets[1] = pItemAward->dwSocket1;
+					item.alSockets[2] = dwSocket2;
+#if defined(__ITEM_SOCKET6__)
+					item.alSockets[3] = pItemAward->dwSocket3;
+					item.alSockets[4] = dwSocket4;
+					item.alSockets[5] = dwSocket5;
+#endif
+#if defined(__EXTENDED_ITEM_AWARD__)
+					thecore_memcpy(&item.aAttr, pItemAward->aAttr, sizeof(item.aAttr));
+#endif
+					s_items.push_back(item);
+
+					vec_dwFinishedAwardID.push_back(std::make_pair(pItemAward->dwID, item.dwID));
+					grid.Put(iPos, 1, it->second->bSize);
+				}
+
+				for (DWORD i = 0; i < vec_dwFinishedAwardID.size(); ++i)
+					ItemAwardManager::instance().Taken(vec_dwFinishedAwardID[i].first, vec_dwFinishedAwardID[i].second);
+			}
+		}
+
+		pi->pSafebox->wItemCount = static_cast<WORD>(s_items.size());
+
+#ifdef __GROWTH_PET_SYSTEM__
+		static std::vector<TGrowthPet> s_petVec;
+
+		// Loads pets only when opening safebox with items
+		if (pi->ip[0] == 0 && !s_items.empty())
+		{
+			char szQuery[QUERY_MAX_LEN];
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT id,vnum,state+0,name,size,level,level_step,evolution,type,hp,sp,def,hp_apply,sp_apply,def_apply,"
+				"age_apply,skill_level,exp,item_exp,UNIX_TIMESTAMP(birthday),end_time,max_time "
+				"FROM growth_pet%s WHERE owner_id=%d AND state=%d",
+				GetTablePostfix(), pi->account_id, STATE_SAFEBOX);
+
+			std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(szQuery));
+			MYSQL_RES* pRes = pkMsg->Get()->pSQLResult;
+			CreateGrowthPetTableFromRes(pRes, &s_petVec, pi->account_id);
+		}
+#endif
+
+		if (pi->ip[0] == 0)
+			pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
+#ifdef __GROWTH_PET_SYSTEM__
+			+ sizeof(WORD) + sizeof(TGrowthPet) * s_petVec.size()
+#endif
+		);
+		else
+			pkPeer->EncodeHeader(HEADER_DG_MALL_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
+
+		);
+
+		pkPeer->Encode(pi->pSafebox, sizeof(TSafeboxTable));
+
+		if (!s_items.empty())
+			pkPeer->Encode(&s_items[0], sizeof(TPlayerItem) * s_items.size());
+
+#ifdef __GROWTH_PET_SYSTEM__
+		pkPeer->EncodeWORD((WORD)s_petVec.size());
+
+		if (!s_petVec.empty())
+			pkPeer->Encode(&s_petVec[0], sizeof(TGrowthPet) * s_petVec.size());
+#endif
+
+		delete pi;
+	}
+}
+
+void CClientManager::QUERY_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangeSizePacket* p)
+{
+	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
+	pi->account_index = p->bSize; // account_index  擔첨 
+
+	char szQuery[QUERY_MAX_LEN];
+
+	if (p->bSize == 1)
+		snprintf(szQuery, sizeof(szQuery), "INSERT INTO safebox%s (`account_id`, `size`) VALUES(%u, %u)", GetTablePostfix(), p->dwID, p->bSize);
+	else
+		snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `size` = %u WHERE `account_id` = %u", GetTablePostfix(), p->bSize, p->dwID);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_SIZE, pkPeer->GetHandle(), pi);
+}
+
+void CClientManager::RESULT_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = p->dwHandle;
+	BYTE bSize = p->account_index;
+
+	delete p;
+
+	if (msg->Get()->uiNumRows > 0)
+	{
+		pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_SIZE, dwHandle, sizeof(BYTE));
+		pkPeer->EncodeBYTE(bSize);
+	}
+}
+
+void CClientManager::QUERY_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangePasswordPacket* p)
+{
+	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
+	strlcpy(pi->safebox_password, p->szNewPassword, sizeof(pi->safebox_password));
+	strlcpy(pi->login, p->szOldPassword, sizeof(pi->login));
+	pi->account_id = p->dwID;
+
+	char szQuery[QUERY_MAX_LEN];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `password` FROM safebox%s WHERE `account_id` = %u", GetTablePostfix(), p->dwID);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD, pkPeer->GetHandle(), pi);
+}
+
+void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = p->dwHandle;
+
+	if (msg->Get()->uiNumRows > 0)
+	{
+		MYSQL_ROW row = mysql_fetch_row(msg->Get()->pSQLResult);
+
+		if ((row[0] && *row[0] && !strcasecmp(row[0], p->login)) || ((!row[0] || !*row[0]) && !strcmp("000000", p->login)))
+		{
+			char szQuery[QUERY_MAX_LEN];
+			char escape_pwd[64];
+			CDBManager::instance().EscapeString(escape_pwd, p->safebox_password, strlen(p->safebox_password));
+
+			snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `password` = '%s' WHERE `account_id` = %u", GetTablePostfix(), escape_pwd, p->account_id);
+
+			CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD_SECOND, pkPeer->GetHandle(), p);
+			return;
+		}
+	}
+
+	delete p;
+
+	// Wrong old password
+	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
+	pkPeer->EncodeBYTE(0);
+}
+
+void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(CPeer* pkPeer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = p->dwHandle;
+	delete p;
+
+	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
+	pkPeer->EncodeBYTE(1);
+}
+
+// MYSHOP_PRICE_LIST
+void CClientManager::RESULT_PRICELIST_LOAD(CPeer* peer, SQLMsg* pMsg)
+{
+	TItemPricelistReqInfo* pReqInfo = (TItemPricelistReqInfo*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
+
+	//
+	// DB  琯  Cache  
+	//
+
+	TItemPriceListTable table;
+	table.dwOwnerID = pReqInfo->second;
+	table.byCount = 0;
+
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
+		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
+#if defined(__CHEQUE_SYSTEM__)
+		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
+#endif
+		table.byCount++;
+	}
+
+	PutItemPriceListCache(&table);
+
+	//
+	// 琯 拷 Game server  
+	//
+
+	TPacketMyshopPricelistHeader header;
+
+	header.dwOwnerID = pReqInfo->second;
+	header.byCount = table.byCount;
+
+	size_t sizePriceListSize = sizeof(TItemPriceInfo) * header.byCount;
+
+	peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, pReqInfo->first, sizeof(header) + sizePriceListSize);
+	peer->Encode(&header, sizeof(header));
+	peer->Encode(table.aPriceInfo, sizePriceListSize);
+
+	sys_log(0, "Load MyShopPricelist handle[%d] pid[%d] count[%d]", pReqInfo->first, pReqInfo->second, header.byCount);
+
+	delete pReqInfo;
+}
+
+void CClientManager::RESULT_PRICELIST_LOAD_FOR_UPDATE(SQLMsg* pMsg)
+{
+	TItemPriceListTable* pUpdateTable = (TItemPriceListTable*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
+
+	//
+	// DB  琯  Cache  
+	//
+
+	TItemPriceListTable table{};
+	table.dwOwnerID = pUpdateTable->dwOwnerID;
+	table.byCount = 0;
+
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
+		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
+#if defined(__CHEQUE_SYSTEM__)
+		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
+#endif
+		table.byCount++;
+	}
+
+	PutItemPriceListCache(&table);
+
+	// Update cache
+	GetItemPriceListCache(pUpdateTable->dwOwnerID)->UpdateList(pUpdateTable);
+
+	delete pUpdateTable;
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+void CClientManager::QUERY_SAFEBOX_SAVE(CPeer* pkPeer, TSafeboxTable* pTable)
+{
+	char szQuery[QUERY_MAX_LEN];
+
+	snprintf(szQuery, sizeof(szQuery),
+		"UPDATE safebox%s SET `gold` = '%u' WHERE `account_id` = %u",
+		GetTablePostfix(), pTable->dwGold, pTable->dwID);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_SAVE, pkPeer->GetHandle(), NULL);
+}
+
+void CClientManager::QUERY_EMPIRE_SELECT(CPeer* pkPeer, DWORD dwHandle, TEmpireSelectPacket* p)
+{
+	char szQuery[QUERY_MAX_LEN];
+
+	snprintf(szQuery, sizeof(szQuery), "UPDATE player_index%s SET `empire` = %u WHERE `id` = %u", GetTablePostfix(), p->bEmpire, p->dwAccountID);
+	delete CDBManager::instance().DirectQuery(szQuery);
+
+	sys_log(0, "EmpireSelect: %s", szQuery);
+	{
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `pid1`"
+			", `pid2`"
+			", `pid3`"
+			", `pid4`"
+#if defined(__PLAYER_PER_ACCOUNT5__)
+			", `pid5`"
+#endif
+			" FROM player_index%s WHERE `id` = %u", GetTablePostfix(), p->dwAccountID);
+
+		std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+		SQLResult* pRes = pmsg->Get();
+
+		if (pRes->uiNumRows)
+		{
+			sys_log(0, "EMPIRE %lu", pRes->uiNumRows);
+
+			MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
+			DWORD pids[3];
+
+			UINT g_start_map[4] =
+			{
+				0, // reserved
+				1, // 탉
+				21, // 천
+				41 // 諭
+			};
+
+			// FIXME share with game
+			DWORD g_start_position[4][2] =
+			{
+				{ 0, 0 },
+				{ 469300, 964200 }, // 탉
+				{ 55700, 157900 }, // 천
+				{ 969600, 278400 } // 諭
+			};
+
+			for (int i = 0; i < 3; ++i)
+			{
+				str_to_number(pids[i], row[i]);
+				sys_log(0, "EMPIRE PIDS[%d]", pids[i]);
+
+				if (pids[i])
+				{
+					sys_log(0, "EMPIRE move to pid[%d] to villiage of %u, map_index %d",
+						pids[i], p->bEmpire, g_start_map[p->bEmpire]);
+
+					snprintf(szQuery, sizeof(szQuery), "UPDATE player%s SET `map_index` = %u, `x` = %u, `y` = %u WHERE `id` = %u",
+						GetTablePostfix(),
+						g_start_map[p->bEmpire],
+						g_start_position[p->bEmpire][0],
+						g_start_position[p->bEmpire][1],
+						pids[i]);
+
+					std::unique_ptr<SQLMsg> pmsg2(CDBManager::instance().DirectQuery(szQuery));
+				}
+			}
+		}
+	}
+
+	pkPeer->EncodeHeader(HEADER_DG_EMPIRE_SELECT, dwHandle, sizeof(BYTE));
+	pkPeer->EncodeBYTE(p->bEmpire);
+}
+
+void CClientManager::QUERY_SETUP(CPeer* peer, DWORD dwHandle, const char* c_pData)
+{
+	TPacketGDSetup* p = (TPacketGDSetup*)c_pData;
+	c_pData += sizeof(TPacketGDSetup);
+
+	if (p->bAuthServer)
+	{
+		sys_log(0, "AUTH_PEER ptr %p", peer);
+
+		m_pkAuthPeer = peer;
+		return;
+	}
+
+	peer->SetPublicIP(p->szPublicIP);
+	peer->SetChannel(p->bChannel);
+	peer->SetListenPort(p->wListenPort);
+	peer->SetP2PPort(p->wP2PPort);
+	peer->SetMaps(p->alMaps);
+
+	//
+	// 錚  錚  獵 
+	//
+	TMapLocation kMapLocations;
+
+	strlcpy(kMapLocations.szHost, peer->GetPublicIP(), sizeof(kMapLocations.szHost));
+	kMapLocations.wPort = peer->GetListenPort();
+	thecore_memcpy(kMapLocations.alMaps, peer->GetMaps(), sizeof(kMapLocations.alMaps));
+
+	BYTE bMapCount;
+
+	std::vector<TMapLocation> vec_kMapLocations;
+
+	if (peer->GetChannel() == 1)
+	{
+		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		{
+			CPeer* tmp = *i;
+
+			if (tmp == peer)
+				continue;
+
+			if (!tmp->GetChannel())
+				continue;
+
+			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
+			{
+				TMapLocation kMapLocation2;
+				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
+				kMapLocation2.wPort = tmp->GetListenPort();
+				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
+				vec_kMapLocations.push_back(kMapLocation2);
+
+				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
+				bMapCount = 1;
+				tmp->EncodeBYTE(bMapCount);
+				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
+			}
+		}
+	}
+	else if (peer->GetChannel() == GUILD_WARP_WAR_CHANNEL)
+	{
+		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		{
+			CPeer* tmp = *i;
+
+			if (tmp == peer)
+				continue;
+
+			if (!tmp->GetChannel())
+				continue;
+
+			if (tmp->GetChannel() == 1 || tmp->GetChannel() == peer->GetChannel())
+			{
+				TMapLocation kMapLocation2;
+				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
+				kMapLocation2.wPort = tmp->GetListenPort();
+				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
+				vec_kMapLocations.push_back(kMapLocation2);
+			}
+
+			tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
+			bMapCount = 1;
+			tmp->EncodeBYTE(bMapCount);
+			tmp->Encode(&kMapLocations, sizeof(TMapLocation));
+		}
+	}
+	else
+	{
+		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		{
+			CPeer* tmp = *i;
+
+			if (tmp == peer)
+				continue;
+
+			if (!tmp->GetChannel())
+				continue;
+
+			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
+			{
+				TMapLocation kMapLocation2;
+
+				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
+				kMapLocation2.wPort = tmp->GetListenPort();
+				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
+
+				vec_kMapLocations.push_back(kMapLocation2);
+			}
+
+			if (tmp->GetChannel() == peer->GetChannel())
+			{
+				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
+				bMapCount = 1;
+				tmp->EncodeBYTE(bMapCount);
+				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
+			}
+		}
+	}
+
+	vec_kMapLocations.push_back(kMapLocations);
+
+	peer->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation) * vec_kMapLocations.size());
+	bMapCount = static_cast<BYTE>(vec_kMapLocations.size());
+	peer->EncodeBYTE(bMapCount);
+	peer->Encode(&vec_kMapLocations[0], sizeof(TMapLocation) * vec_kMapLocations.size());
+
+	//
+	// 쩐 :  퓸楮 摸 퓸 構 . (P2P 漫 )
+	//
+	sys_log(0, "SETUP: channel %u listen %u p2p %u count %u", peer->GetChannel(), p->wListenPort, p->wP2PPort, bMapCount);
+
+	TPacketDGP2P p2pSetupPacket;
+	p2pSetupPacket.wPort = peer->GetP2PPort();
+	p2pSetupPacket.bChannel = peer->GetChannel();
+	strlcpy(p2pSetupPacket.szHost, peer->GetPublicIP(), sizeof(p2pSetupPacket.szHost));
+
+	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* tmp = *i;
+
+		if (tmp == peer)
+			continue;
+
+		// 채 0繭  SETUP 킷   퓸 풔 auth   
+		if (0 == tmp->GetChannel())
+			continue;
+
+		tmp->EncodeHeader(HEADER_DG_P2P, 0, sizeof(TPacketDGP2P));
+		tmp->Encode(&p2pSetupPacket, sizeof(TPacketDGP2P));
+	}
+
+	//
+	// 慣   
+	//
+	TPacketLoginOnSetup* pck = (TPacketLoginOnSetup*)c_pData;
+
+	for (DWORD c = 0; c < p->dwLoginCount; ++c, ++pck)
+	{
+		CLoginData* pkLD = new CLoginData;
+
+		pkLD->SetKey(pck->dwLoginKey);
+		pkLD->SetClientKey(pck->adwClientKey);
+		pkLD->SetIP(pck->szHost);
+
+		TAccountTable& r = pkLD->GetAccountRef();
+
+		r.id = pck->dwID;
+		trim_and_lower(pck->szLogin, r.login, sizeof(r.login));
+		strlcpy(r.social_id, pck->szSocialID, sizeof(r.social_id));
+		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		strlcpy(r.country, pck->szCountry, sizeof(r.country));
+#endif
+
+		InsertLoginData(pkLD);
+
+		if (InsertLogonAccount(pck->szLogin, peer->GetHandle(), pck->szHost))
+		{
+			sys_log(0, "SETUP: login %u %s login_key %u host %s", pck->dwID, pck->szLogin, pck->dwLoginKey, pck->szHost);
+			pkLD->SetPlay(true);
+		}
+		else
+			sys_log(0, "SETUP: login_fail %u %s login_key %u", pck->dwID, pck->szLogin, pck->dwLoginKey);
+	}
+
+	SendPartyOnSetup(peer);
+
+	CGuildManager::instance().OnSetup(peer);
+	CPrivManager::instance().SendPrivOnSetup(peer);
+
+	SendEventFlagsOnSetup(peer);
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	SendGuildEventFlagsOnSetup(peer);
+#endif
+
+	marriage::CManager::instance().OnSetup(peer);
+}
+
+void CClientManager::QUERY_ITEM_FLUSH(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwID = *(DWORD*)c_pData;
+
+	if (g_log)
+		sys_log(0, "HEADER_GD_ITEM_FLUSH: %u", dwID);
+
+	CItemCache* c = GetItemCache(dwID);
+
+	if (c)
+		c->Flush();
+}
+
+void CClientManager::QUERY_ITEM_SAVE(CPeer* pkPeer, const char* c_pData)
+{
+	TPlayerItem* p = (TPlayerItem*)c_pData;
+
+	// 창 캐 歌, 캐 獵 孤  磯.
+
+	if (p->bWindow == SAFEBOX || p->bWindow == MALL
+	)
+	{
+		CItemCache* c = GetItemCache(p->dwID);
+
+		if (c)
+		{
+			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
+
+			if (it != m_map_pkItemCacheSetPtr.end())
+			{
+				if (g_test_server)
+					sys_log(0, "ITEM_CACHE: safebox owner %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+
+				it->second->erase(c);
+			}
+
+			m_map_itemCache.erase(p->dwID);
+
+			delete c;
+		}
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"REPLACE INTO `item%s` (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
+#if defined(__SOUL_BIND_SYSTEM__)
+			", `soulbind`"
+#endif
+			", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+			", `socket3`, `socket4`, `socket5`"
+#endif
+			", `attrtype0`, `attrvalue0`"
+			", `attrtype1`, `attrvalue1`"
+			", `attrtype2`, `attrvalue2`"
+			", `attrtype3`, `attrvalue3`"
+			", `attrtype4`, `attrvalue4`"
+			", `attrtype5`, `attrvalue5`"
+			", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			", `transmutation`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			", `refine_element_apply_type`"
+			", `refine_element_grade`"
+			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			", `apply_type0`, `apply_value0`, `apply_path0`"
+			", `apply_type1`, `apply_value1`, `apply_path1`"
+			", `apply_type2`, `apply_value2`, `apply_path2`"
+			", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+			", `set_value`"
+#endif
+			") VALUES(%u, %u, %u, %u, %u, %u"
+#if defined(__SOUL_BIND_SYSTEM__)
+			", %ld"
+#endif
+			", %ld, %ld, %ld"
+#if defined(__ITEM_SOCKET6__)
+			", %ld, %ld, %ld"
+#endif
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			", %u"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			", %u"
+			", %u"
+			", %u, %u, %u"
+			", %u, %u, %u"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			", %u, %ld, %u"
+			", %u, %ld, %u"
+			", %u, %ld, %u"
+			", %u, %ld, %u"
+#endif
+#if defined(__SET_ITEM__)
+			", %u"
+#endif
+			")", GetTablePostfix()
+			, p->dwID
+			, p->dwOwner
+			, p->bWindow
+			, p->wPos
+			, p->dwVnum
+			, p->dwCount
+#if defined(__SOUL_BIND_SYSTEM__)
+			, p->lSealDate
+#endif
+			, p->alSockets[0], p->alSockets[1], p->alSockets[2]
+#if defined(__ITEM_SOCKET6__)
+			, p->alSockets[3], p->alSockets[4], p->alSockets[5]
+#endif
+			, p->aAttr[0].wType, p->aAttr[0].lValue
+			, p->aAttr[1].wType, p->aAttr[1].lValue
+			, p->aAttr[2].wType, p->aAttr[2].lValue
+			, p->aAttr[3].wType, p->aAttr[3].lValue
+			, p->aAttr[4].wType, p->aAttr[4].lValue
+			, p->aAttr[5].wType, p->aAttr[5].lValue
+			, p->aAttr[6].wType, p->aAttr[6].lValue
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			, p->dwTransmutationVnum
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			, p->RefineElement.wApplyType
+			, p->RefineElement.bGrade
+			, p->RefineElement.abValue[0], p->RefineElement.abValue[1], p->RefineElement.abValue[2]
+			, p->RefineElement.abBonusValue[0], p->RefineElement.abBonusValue[1], p->RefineElement.abBonusValue[2]
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			, p->aApplyRandom[0].wType, p->aApplyRandom[0].lValue, p->aApplyRandom[0].bPath
+			, p->aApplyRandom[1].wType, p->aApplyRandom[1].lValue, p->aApplyRandom[1].bPath
+			, p->aApplyRandom[2].wType, p->aApplyRandom[2].lValue, p->aApplyRandom[2].bPath
+			, p->aApplyRandom[3].wType, p->aApplyRandom[3].lValue, p->aApplyRandom[3].bPath
+#endif
+#if defined(__SET_ITEM__)
+			, p->bSetValue
+#endif
+		);
+
+		CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_SAVE, pkPeer->GetHandle(), NULL);
+	}
+	else
+	{
+		if (g_test_server)
+			sys_log(0, "QUERY_ITEM_SAVE => PutItemCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
+
+		PutItemCache(p);
+	}
+}
+
+CClientManager::TItemCacheSet* CClientManager::GetItemCacheSet(DWORD pid)
+{
+	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
+
+	if (it == m_map_pkItemCacheSetPtr.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::CreateItemCacheSet(DWORD pid)
+{
+	if (m_map_pkItemCacheSetPtr.find(pid) != m_map_pkItemCacheSetPtr.end())
+		return;
+
+	TItemCacheSet* pSet = new TItemCacheSet;
+	m_map_pkItemCacheSetPtr.insert(TItemCacheSetPtrMap::value_type(pid, pSet));
+
+	if (g_log)
+		sys_log(0, "ITEM_CACHE: new cache %u", pid);
+}
+
+void CClientManager::FlushItemCacheSet(DWORD pid)
+{
+	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
+
+	if (it == m_map_pkItemCacheSetPtr.end())
+	{
+		sys_log(0, "FLUSH_ITEMCACHESET : No ItemCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TItemCacheSet* pSet = it->second;
+	TItemCacheSet::iterator it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CItemCache* c = *it_set++;
+		c->Flush();
+
+		m_map_itemCache.erase(c->Get()->dwID);
+		delete c;
+	}
+
+	pSet->clear();
+	delete pSet;
+
+	m_map_pkItemCacheSetPtr.erase(it);
+
+	if (g_log)
+		sys_log(0, "FLUSH_ITEMCACHESET : Deleted pid(%d)", pid);
+}
+
+CItemCache* CClientManager::GetItemCache(DWORD id)
+{
+	TItemCacheMap::iterator it = m_map_itemCache.find(id);
+
+	if (it == m_map_itemCache.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::PutItemCache(TPlayerItem* pNew, bool bSkipQuery)
+{
+	CItemCache* c;
+
+	c = GetItemCache(pNew->dwID);
+
+	//   
+	if (!c)
+	{
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: PutItemCache ==> New CItemCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
+
+		c = new CItemCache;
+		m_map_itemCache.insert(TItemCacheMap::value_type(pNew->dwID, c));
+	}
+	// 
+	else
+	{
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: PutItemCache ==> Have Cache");
+
+		// 微 틀
+		if (pNew->dwOwner != c->Get()->dwOwner)
+		{
+			// 譴    羚    磯.
+			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
+
+			if (it != m_map_pkItemCacheSetPtr.end())
+			{
+				if (g_log)
+					sys_log(0, "ITEM_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
+				it->second->erase(c);
+			}
+		}
+	}
+
+	// 恝  트
+	c->Put(pNew, bSkipQuery);
+
+	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
+
+	if (it != m_map_pkItemCacheSetPtr.end())
+	{
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		it->second->insert(c);
+	}
+	else
+	{
+		//  微 퓐 慕 瞞     SQL 臼
+		//   퓐 慕 磯.
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+
+		c->OnFlush();
+	}
+}
+
+bool CClientManager::DeleteItemCache(DWORD dwID)
+{
+	CItemCache* c = GetItemCache(dwID);
+
+	if (!c)
+		return false;
+
+	c->Delete();
+	return true;
+}
+
+// MYSHOP_PRICE_LIST
+CItemPriceListTableCache* CClientManager::GetItemPriceListCache(DWORD dwID)
+{
+	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.find(dwID);
+
+	if (it == m_mapItemPriceListCache.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::PutItemPriceListCache(const TItemPriceListTable* pItemPriceList)
+{
+	CItemPriceListTableCache* pCache = GetItemPriceListCache(pItemPriceList->dwOwnerID);
+
+	if (!pCache)
+	{
+		pCache = new CItemPriceListTableCache;
+		m_mapItemPriceListCache.insert(TItemPriceListCacheMap::value_type(pItemPriceList->dwOwnerID, pCache));
+	}
+
+	pCache->Put(const_cast<TItemPriceListTable*>(pItemPriceList), true);
+}
+
+void CClientManager::UpdatePlayerCache()
+{
+	TPlayerTableCacheMap::iterator it = m_map_playerCache.begin();
+
+	while (it != m_map_playerCache.end())
+	{
+		CPlayerTableCache* c = (it++)->second;
+
+		if (c->CheckTimeout())
+		{
+			if (g_log)
+				sys_log(0, "UPDATE : UpdatePlayerCache() ==> FlushPlayerCache %d %s ", c->Get(false)->id, c->Get(false)->name);
+
+			c->Flush();
+
+			// Item Cache 트
+			UpdateItemCacheSet(c->Get()->id);
+#ifdef __GROWTH_PET_SYSTEM__
+			UpdateGrowthPetCacheSet(c->Get()->id);
+#endif
+		}
+		else if (c->CheckFlushTimeout())
+			c->Flush();
+	}
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+void CClientManager::SetCacheFlushCountLimit(int iLimit)
+{
+	m_iCacheFlushCountLimit = MAX(10, iLimit);
+	sys_log(0, "CACHE_FLUSH_LIMIT_PER_SECOND: %d", m_iCacheFlushCountLimit);
+}
+
+void CClientManager::UpdateItemCache()
+{
+	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+		return;
+
+	TItemCacheMap::iterator it = m_map_itemCache.begin();
+
+	while (it != m_map_itemCache.end())
+	{
+		CItemCache* c = (it++)->second;
+
+		//  Flush 磯.
+		if (c->CheckFlushTimeout())
+		{
+			if (g_test_server)
+				sys_log(0, "UpdateItemCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
+
+			c->Flush();
+
+			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+				break;
+		}
+	}
+}
+
+void CClientManager::UpdateItemPriceListCache()
+{
+	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.begin();
+
+	while (it != m_mapItemPriceListCache.end())
+	{
+		CItemPriceListTableCache* pCache = it->second;
+
+		if (pCache->CheckFlushTimeout())
+		{
+			pCache->Flush();
+			m_mapItemPriceListCache.erase(it++);
+		}
+		else
+			++it;
+	}
+}
+
+void CClientManager::QUERY_ITEM_DESTROY(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwID = *(DWORD*)c_pData;
+	c_pData += sizeof(DWORD);
+
+	DWORD dwPID = *(DWORD*)c_pData;
+
+	if (!DeleteItemCache(dwID))
+	{
+		char szQuery[64];
+		snprintf(szQuery, sizeof(szQuery), "DELETE FROM item%s WHERE `id` = %u", GetTablePostfix(), dwID);
+
+		if (g_log)
+			sys_log(0, "HEADER_GD_ITEM_DESTROY: PID %u ID %u", dwPID, dwID);
+
+		if (dwPID == 0) // 틜   摸, 宙엽 
+			CDBManager::instance().AsyncQuery(szQuery);
+		else
+			CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_DESTROY, pkPeer->GetHandle(), NULL);
+	}
+}
+
+void CClientManager::QUERY_FLUSH_CACHE(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwPID = *(DWORD*)c_pData;
+
+	CPlayerTableCache* pkCache = GetPlayerCache(dwPID);
+
+	if (!pkCache)
+		return;
+
+	sys_log(0, "FLUSH_CACHE: %u", dwPID);
+
+	pkCache->Flush();
+	FlushItemCacheSet(dwPID);
+#ifdef __GROWTH_PET_SYSTEM__
+	FlushGrowthPetCacheSet(dwPID);
+#endif
+	m_map_playerCache.erase(dwPID);
+	delete pkCache;
+}
+
+void CClientManager::QUERY_RELOAD_PROTO()
+{
+	if (!InitializeTables())
+	{
+		sys_err("QUERY_RELOAD_PROTO: cannot load tables");
+		return;
+	}
+
+	for (TPeerList::iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* tmp = *i;
+
+		if (!tmp->GetChannel())
+			continue;
+
+		tmp->EncodeHeader(HEADER_DG_RELOAD_PROTO, 0,
+			sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
+			sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
+			sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
+			sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
+			sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize
+#ifdef __GROWTH_PET_SYSTEM__
+			+ sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size()
+#endif
+		);
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
+		tmp->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
+		tmp->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
+		tmp->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
+		tmp->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_iRefineTableSize));
+		tmp->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
+
+#ifdef __GROWTH_PET_SYSTEM__
+		tmp->EncodeWORD(m_vec_growthPetSkillTable.size());
+		if (m_vec_growthPetSkillTable.size())
+			tmp->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
+#endif
+	}
+}
+
+// ADD_GUILD_PRIV_TIME
+/**
+* @version 05/06/08 Bang2ni - 擔챨 煞
+**/
+void CClientManager::AddGuildPriv(TPacketGiveGuildPriv* p)
+{
+	CPrivManager::instance().AddGuildPriv(p->guild_id, p->type, p->value, p->duration_sec);
+}
+
+void CClientManager::AddEmpirePriv(TPacketGiveEmpirePriv* p)
+{
+	CPrivManager::instance().AddEmpirePriv(p->empire, p->type, p->value, p->duration_sec);
+}
+// END_OF_ADD_GUILD_PRIV_TIME
+
+void CClientManager::AddCharacterPriv(TPacketGiveCharacterPriv* p)
+{
+	CPrivManager::instance().AddCharPriv(p->pid, p->type, p->value);
+}
+
+void CClientManager::MoneyLog(TPacketMoneyLog* p)
+{
+	CMoneyLog::instance().AddLog(p->type, p->vnum, p->gold
+#if defined(__CHEQUE_SYSTEM__)
+		, p->cheque
+#endif
+	);
+}
+
+CLoginData* CClientManager::GetLoginData(DWORD dwKey)
+{
+	TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(dwKey);
+
+	if (it == m_map_pkLoginData.end())
+		return NULL;
+
+	return it->second;
+}
+
+CLoginData* CClientManager::GetLoginDataByLogin(const char* c_pszLogin)
+{
+	char szLogin[LOGIN_MAX_LEN + 1];
+	trim_and_lower(c_pszLogin, szLogin, sizeof(szLogin));
+
+	TLoginDataByLogin::iterator it = m_map_pkLoginDataByLogin.find(szLogin);
+
+	if (it == m_map_pkLoginDataByLogin.end())
+		return NULL;
+
+	return it->second;
+}
+
+CLoginData* CClientManager::GetLoginDataByAID(DWORD dwAID)
+{
+	TLoginDataByAID::iterator it = m_map_pkLoginDataByAID.find(dwAID);
+
+	if (it == m_map_pkLoginDataByAID.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::InsertLoginData(CLoginData* pkLD)
+{
+	char szLogin[LOGIN_MAX_LEN + 1];
+	trim_and_lower(pkLD->GetAccountRef().login, szLogin, sizeof(szLogin));
+
+	m_map_pkLoginData.insert(std::make_pair(pkLD->GetKey(), pkLD));
+	m_map_pkLoginDataByLogin.insert(std::make_pair(szLogin, pkLD));
+	m_map_pkLoginDataByAID.insert(std::make_pair(pkLD->GetAccountRef().id, pkLD));
+}
+
+void CClientManager::DeleteLoginData(CLoginData* pkLD)
+{
+	m_map_pkLoginData.erase(pkLD->GetKey());
+	m_map_pkLoginDataByLogin.erase(pkLD->GetAccountRef().login);
+	m_map_pkLoginDataByAID.erase(pkLD->GetAccountRef().id);
+
+	if (m_map_kLogonAccount.find(pkLD->GetAccountRef().login) == m_map_kLogonAccount.end())
+		delete pkLD;
+	else
+		pkLD->SetDeleted(true);
+}
+
+void CClientManager::QUERY_AUTH_LOGIN(CPeer* pkPeer, DWORD dwHandle, TPacketGDAuthLogin* p)
+{
+	if (g_test_server)
+		sys_log(0, "QUERY_AUTH_LOGIN %d %d %s", p->dwID, p->dwLoginKey, p->szLogin);
+
+	CLoginData* pkLD = GetLoginDataByLogin(p->szLogin);
+
+	if (pkLD)
+	{
+		DeleteLoginData(pkLD);
+	}
+
+	BYTE bResult;
+
+	if (GetLoginData(p->dwLoginKey))
+	{
+		sys_err("LoginData already exist key %u login %s", p->dwLoginKey, p->szLogin);
+		bResult = 0;
+
+		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
+		pkPeer->EncodeBYTE(bResult);
+	}
+	else
+	{
+		CLoginData* pkLD = new CLoginData;
+
+		pkLD->SetKey(p->dwLoginKey);
+		pkLD->SetClientKey(p->adwClientKey);
+		pkLD->SetPremium(p->iPremiumTimes);
+
+		TAccountTable& r = pkLD->GetAccountRef();
+
+		r.id = p->dwID;
+		trim_and_lower(p->szLogin, r.login, sizeof(r.login));
+		strlcpy(r.social_id, p->szSocialID, sizeof(r.social_id));
+		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		strlcpy(r.country, p->szCountry, sizeof(r.country));
+#endif
+
+		sys_log(0, "AUTH_LOGIN id(%u) login(%s)"
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			" country(%s)"
+#endif
+			" social_id(%s) login_key(%u), client_key(%u %u %u %u)",
+			p->dwID,
+			p->szLogin,
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			p->szCountry,
+#endif
+			p->szSocialID,
+			p->dwLoginKey,
+			p->adwClientKey[0], p->adwClientKey[1], p->adwClientKey[2], p->adwClientKey[3]
+		);
+
+		bResult = 1;
+
+		InsertLoginData(pkLD);
+
+		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
+		pkPeer->EncodeBYTE(bResult);
+	}
+}
+
+void CClientManager::GuildDepositMoney(TPacketGDGuildMoney* p)
+{
+	CGuildManager::instance().DepositMoney(p->dwGuild, p->iGold);
+}
+
+void CClientManager::GuildWithdrawMoney(CPeer* peer, TPacketGDGuildMoney* p)
+{
+	CGuildManager::instance().WithdrawMoney(peer, p->dwGuild, p->iGold);
+}
+
+void CClientManager::GuildWithdrawMoneyGiveReply(TPacketGDGuildMoneyWithdrawGiveReply* p)
+{
+	CGuildManager::instance().WithdrawMoneyReply(p->dwGuild, p->bGiveSuccess, p->iChangeGold);
+}
+
+void CClientManager::GuildWarBet(TPacketGDGuildWarBet* p)
+{
+	CGuildManager::instance().Bet(p->dwWarID, p->szLogin, p->dwGold, p->dwGuild);
+}
+
+void CClientManager::CreateObject(TPacketGDCreateObject* p)
+{
+	using namespace building;
+
+	char szQuery[512];
+
+	snprintf(szQuery, sizeof(szQuery),
+		"INSERT INTO object%s (`land_id`, `vnum`, `map_index`, `x`, `y`, `x_rot`, `y_rot`, `z_rot`) VALUES(%u, %u, %d, %d, %d, %f, %f, %f)",
+		GetTablePostfix(), p->dwLandID, p->dwVnum, p->lMapIndex, p->x, p->y, p->xRot, p->yRot, p->zRot);
+
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+	if (pmsg->Get()->uiInsertID == 0)
+	{
+		sys_err("cannot insert object");
+		return;
+	}
+
+	TObject* pkObj = new TObject;
+
+	memset(pkObj, 0, sizeof(TObject));
+
+	pkObj->dwID = pmsg->Get()->uiInsertID;
+	pkObj->dwVnum = p->dwVnum;
+	pkObj->dwLandID = p->dwLandID;
+	pkObj->lMapIndex = p->lMapIndex;
+	pkObj->x = p->x;
+	pkObj->y = p->y;
+	pkObj->xRot = p->xRot;
+	pkObj->yRot = p->yRot;
+	pkObj->zRot = p->zRot;
+	pkObj->lLife = 0;
+
+	ForwardPacket(HEADER_DG_CREATE_OBJECT, pkObj, sizeof(TObject));
+
+	m_map_pkObjectTable.insert(std::make_pair(pkObj->dwID, pkObj));
+}
+
+void CClientManager::DeleteObject(DWORD dwID)
+{
+	char szQuery[128];
+
+	snprintf(szQuery, sizeof(szQuery), "DELETE FROM object%s WHERE `id` = %u", GetTablePostfix(), dwID);
+
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
+	{
+		sys_err("no object by id %u", dwID);
+		return;
+	}
+
+	//pkObjectTableMap::const_iterator it = m_map_pkObjectTable.find(dwID);
+	auto it = m_map_pkObjectTable.find(dwID);
+	if (it != m_map_pkObjectTable.end())
+	{
+		delete it->second;
+		m_map_pkObjectTable.erase(it);
+	}
+
+	ForwardPacket(HEADER_DG_DELETE_OBJECT, &dwID, sizeof(DWORD));
+}
+
+void CClientManager::UpdateLand(DWORD* pdw)
+{
+	DWORD dwID = pdw[0];
+	DWORD dwGuild = pdw[1];
+
+	building::TLand* p = &m_vec_kLandTable[0];
+
+	DWORD i;
+
+	for (i = 0; i < m_vec_kLandTable.size(); ++i, ++p)
+	{
+		if (p->dwID == dwID)
+		{
+			char buf[256];
+			snprintf(buf, sizeof(buf), "UPDATE land%s SET `guild_id` = %u WHERE `id` = %u", GetTablePostfix(), dwGuild, dwID);
+			CDBManager::instance().AsyncQuery(buf);
+
+			p->dwGuildID = dwGuild;
+			break;
+		}
+	}
+
+	if (i < m_vec_kLandTable.size())
+		ForwardPacket(HEADER_DG_UPDATE_LAND, p, sizeof(building::TLand));
+}
+
+// BLOCK_CHAT
+void CClientManager::BlockChat(TPacketBlockChat* p)
+{
+	char szQuery[256];
+
+	if (g_stLocale == "sjis")
+		snprintf(szQuery, sizeof(szQuery), "SELECT `id `FROM player%s WHERE `name` = '%s' COLLATE sjis_japanese_ci", GetTablePostfix(), p->szName);
+	else
+		snprintf(szQuery, sizeof(szQuery), "SELECT `id` FROM player%s WHERE `name` = '%s'", GetTablePostfix(), p->szName);
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+	SQLResult* pRes = pmsg->Get();
+
+	if (pRes->uiNumRows)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
+		DWORD pid = strtoul(row[0], NULL, 10);
+
+		TPacketGDAddAffect pa;
+		pa.dwPID = pid;
+		pa.elem.dwType = 223;
+		pa.elem.wApplyOn = 0;
+		pa.elem.lApplyValue = 0;
+		pa.elem.dwFlag = 0;
+		pa.elem.lDuration = p->lDuration;
+		pa.elem.lSPCost = 0;
+		QUERY_ADD_AFFECT(NULL, &pa);
+	}
+	else
+	{
+		// cannot find user with that name
+	}
+}
+// END_OF_BLOCK_CHAT
+
+void CClientManager::MarriageAdd(TPacketMarriageAdd* p)
+{
+	sys_log(0, "MarriageAdd %u %u %s %s", p->dwPID1, p->dwPID2, p->szName1, p->szName2);
+	marriage::CManager::instance().Add(p->dwPID1, p->dwPID2, p->szName1, p->szName2);
+}
+
+void CClientManager::MarriageUpdate(TPacketMarriageUpdate* p)
+{
+	sys_log(0, "MarriageUpdate PID:%u %u LP:%d ST:%d", p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
+	marriage::CManager::instance().Update(p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
+}
+
+void CClientManager::MarriageRemove(TPacketMarriageRemove* p)
+{
+	sys_log(0, "MarriageRemove %u %u", p->dwPID1, p->dwPID2);
+	marriage::CManager::instance().Remove(p->dwPID1, p->dwPID2);
+}
+
+void CClientManager::WeddingRequest(TPacketWeddingRequest* p)
+{
+	sys_log(0, "WeddingRequest %u %u", p->dwPID1, p->dwPID2);
+	ForwardPacket(HEADER_DG_WEDDING_REQUEST, p, sizeof(TPacketWeddingRequest));
+	//marriage::CManager::instance().RegisterWedding(p->dwPID1, p->szName1, p->dwPID2, p->szName2);
+}
+
+void CClientManager::WeddingReady(TPacketWeddingReady* p)
+{
+	sys_log(0, "WeddingReady %u %u", p->dwPID1, p->dwPID2);
+	ForwardPacket(HEADER_DG_WEDDING_READY, p, sizeof(TPacketWeddingReady));
+	marriage::CManager::instance().ReadyWedding(p->dwMapIndex, p->dwPID1, p->dwPID2);
+}
+
+void CClientManager::WeddingEnd(TPacketWeddingEnd* p)
+{
+	sys_log(0, "WeddingEnd %u %u", p->dwPID1, p->dwPID2);
+	marriage::CManager::instance().EndWedding(p->dwPID1, p->dwPID2);
+}
+
+//
+// 캐첼   캐첩 트 構 캐첼  摸
+// 耳  拷 琯 悶   캐첩     트 磯.
+//
+void CClientManager::MyshopPricelistUpdate(const TItemPriceListTable* pPacket)
+{
+	if (pPacket->byCount > SHOP_PRICELIST_MAX_NUM)
+	{
+		sys_err("count overflow!");
+		return;
+	}
+
+	CItemPriceListTableCache* pCache = GetItemPriceListCache(pPacket->dwOwnerID);
+
+	if (pCache)
+	{
+		TItemPriceListTable table;
+
+		table.dwOwnerID = pPacket->dwOwnerID;
+		table.byCount = pPacket->byCount;
+
+		thecore_memcpy(table.aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
+
+		pCache->UpdateList(&table);
+	}
+	else
+	{
+		TItemPriceListTable* pUpdateTable = new TItemPriceListTable;
+
+		pUpdateTable->dwOwnerID = pPacket->dwOwnerID;
+		pUpdateTable->byCount = pPacket->byCount;
+
+		thecore_memcpy(pUpdateTable->aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `item_vnum`, `price`"
+#if defined(__CHEQUE_SYSTEM__)
+			", `cheque`"
+#endif
+			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), pPacket->dwOwnerID);
+		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD_FOR_UPDATE, 0, pUpdateTable);
+	}
+}
+
+// MYSHOP_PRICE_LIST
+// 캐천   캐첩 棘 慕 構 캐첼   DB   磯.
+//
+void CClientManager::MyshopPricelistRequest(CPeer* peer, DWORD dwHandle, DWORD dwPlayerID)
+{
+	if (CItemPriceListTableCache* pCache = GetItemPriceListCache(dwPlayerID))
+	{
+		sys_log(0, "Cache MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
+
+		TItemPriceListTable* pTable = pCache->Get(false);
+
+		TPacketMyshopPricelistHeader header =
+		{
+			pTable->dwOwnerID,
+			pTable->byCount
+		};
+
+		size_t sizePriceListSize = sizeof(TItemPriceInfo) * pTable->byCount;
+
+		peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, dwHandle, sizeof(header) + sizePriceListSize);
+		peer->Encode(&header, sizeof(header));
+		peer->Encode(pTable->aPriceInfo, sizePriceListSize);
+	}
+	else
+	{
+		sys_log(0, "Query MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `item_vnum`, `price`"
+#if defined(__CHEQUE_SYSTEM__)
+			", `cheque`"
+#endif
+			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), dwPlayerID);
+		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD, peer->GetHandle(), new TItemPricelistReqInfo(dwHandle, dwPlayerID));
+	}
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+void CPacketInfo::Add(int header)
+{
+	auto it = m_map_info.find(header);
+	if (it == m_map_info.end())
+		m_map_info.insert(std::map<int, int>::value_type(header, 1));
+	else
+		++it->second;
+}
+
+void CPacketInfo::Reset()
+{
+	m_map_info.clear();
+}
+
+void CClientManager::ProcessPackets(CPeer* peer)
+{
+	BYTE header;
+	DWORD dwHandle;
+	DWORD dwLength;
+	const char* data = NULL;
+	int i = 0;
+	int iCount = 0;
+
+	while (peer->PeekPacket(i, header, dwHandle, dwLength, &data))
+	{
+		// DISABLE_DB_HEADER_LOG
+		// sys_log(0, "header %d %p size %d", header, this, dwLength);
+		// END_OF_DISABLE_DB_HEADER_LOG
+		m_bLastHeader = header;
+		++iCount;
+
+#if defined(_DEBUG)
+		if (header != 10)
+			sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
+#endif
+
+		if (g_test_server)
+		{
+			if (header != 10)
+				sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
+		}
+
+		// test log by mhh
+		{
+			if (HEADER_GD_BLOCK_COUNTRY_IP == header)
+				sys_log(0, "recved : HEADER_GD_BLOCK_COUNTRY_IP");
+		}
+
+		switch (header)
+		{
+			case HEADER_GD_BOOT:
+				QUERY_BOOT(peer, (TPacketGDBoot*)data);
+				break;
+
+			case HEADER_GD_HAMMER_OF_TOR:
+				break;
+
+			case HEADER_GD_LOGIN_BY_KEY:
+				QUERY_LOGIN_BY_KEY(peer, dwHandle, (TPacketGDLoginByKey*)data);
+				break;
+
+			case HEADER_GD_LOGOUT:
+				//sys_log(0, "HEADER_GD_LOGOUT (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_LOGOUT(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_PLAYER_LOAD:
+				sys_log(1, "HEADER_GD_PLAYER_LOAD (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_PLAYER_LOAD(peer, dwHandle, (TPlayerLoadPacket*)data);
+				break;
+
+			case HEADER_GD_PLAYER_SAVE:
+				sys_log(1, "HEADER_GD_PLAYER_SAVE (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_PLAYER_SAVE(peer, dwHandle, (TPlayerTable*)data);
+				break;
+
+			case HEADER_GD_PLAYER_CREATE:
+				sys_log(0, "HEADER_GD_PLAYER_CREATE (handle: %d length: %d)", dwHandle, dwLength);
+				__QUERY_PLAYER_CREATE(peer, dwHandle, (TPlayerCreatePacket*)data);
+				sys_log(0, "END");
+				break;
+
+			case HEADER_GD_PLAYER_DELETE:
+				sys_log(1, "HEADER_GD_PLAYER_DELETE (handle: %d length: %d)", dwHandle, dwLength);
+				__QUERY_PLAYER_DELETE(peer, dwHandle, (TPlayerDeletePacket*)data);
+				break;
+
+			case HEADER_GD_PLAYER_COUNT:
+				QUERY_PLAYER_COUNT(peer, (TPlayerCountPacket*)data);
+				break;
+
+			case HEADER_GD_QUEST_SAVE:
+				sys_log(1, "HEADER_GD_QUEST_SAVE (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_QUEST_SAVE(peer, (TQuestTable*)data, dwLength);
+				break;
+
+			case HEADER_GD_SAFEBOX_LOAD:
+				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 0);
+				break;
+
+			case HEADER_GD_SAFEBOX_SAVE:
+				sys_log(1, "HEADER_GD_SAFEBOX_SAVE (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_SAFEBOX_SAVE(peer, (TSafeboxTable*)data);
+				break;
+
+			case HEADER_GD_SAFEBOX_CHANGE_SIZE:
+				QUERY_SAFEBOX_CHANGE_SIZE(peer, dwHandle, (TSafeboxChangeSizePacket*)data);
+				break;
+
+			case HEADER_GD_SAFEBOX_CHANGE_PASSWORD:
+				QUERY_SAFEBOX_CHANGE_PASSWORD(peer, dwHandle, (TSafeboxChangePasswordPacket*)data);
+				break;
+
+			case HEADER_GD_MALL_LOAD:
+				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 1);
+				break;
+
+			case HEADER_GD_EMPIRE_SELECT:
+				QUERY_EMPIRE_SELECT(peer, dwHandle, (TEmpireSelectPacket*)data);
+				break;
+
+			case HEADER_GD_SETUP:
+				QUERY_SETUP(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_GUILD_CREATE:
+				GuildCreate(peer, *(DWORD*)data);
+				break;
+
+			case HEADER_GD_GUILD_SKILL_UPDATE:
+				GuildSkillUpdate(peer, (TPacketGuildSkillUpdate*)data);
+				break;
+
+			case HEADER_GD_GUILD_EXP_UPDATE:
+				GuildExpUpdate(peer, (TPacketGuildExpUpdate*)data);
+				break;
+
+			case HEADER_GD_GUILD_ADD_MEMBER:
+				GuildAddMember(peer, (TPacketGDGuildAddMember*)data);
+				break;
+
+			case HEADER_GD_GUILD_REMOVE_MEMBER:
+				GuildRemoveMember(peer, (TPacketGuild*)data);
+				break;
+
+			case HEADER_GD_GUILD_CHANGE_GRADE:
+				GuildChangeGrade(peer, (TPacketGuild*)data);
+				break;
+
+			case HEADER_GD_GUILD_CHANGE_MEMBER_DATA:
+				GuildChangeMemberData(peer, (TPacketGuildChangeMemberData*)data);
+				break;
+
+			case HEADER_GD_GUILD_DISBAND:
+				GuildDisband(peer, (TPacketGuild*)data);
+				break;
+
+			case HEADER_GD_GUILD_WAR:
+				GuildWar(peer, (TPacketGuildWar*)data);
+				break;
+
+			case HEADER_GD_GUILD_WAR_SCORE:
+				GuildWarScore(peer, (TPacketGuildWarScore*)data);
+				break;
+
+			case HEADER_GD_GUILD_CHANGE_LADDER_POINT:
+				GuildChangeLadderPoint((TPacketGuildLadderPoint*)data);
+				break;
+
+			case HEADER_GD_GUILD_USE_SKILL:
+				GuildUseSkill((TPacketGuildUseSkill*)data);
+				break;
+
+			case HEADER_GD_FLUSH_CACHE:
+				QUERY_FLUSH_CACHE(peer, data);
+				break;
+
+			case HEADER_GD_ITEM_SAVE:
+				QUERY_ITEM_SAVE(peer, data);
+				break;
+
+			case HEADER_GD_ITEM_DESTROY:
+				QUERY_ITEM_DESTROY(peer, data);
+				break;
+
+			case HEADER_GD_ITEM_FLUSH:
+				QUERY_ITEM_FLUSH(peer, data);
+				break;
+
+			case HEADER_GD_ADD_AFFECT:
+				sys_log(1, "HEADER_GD_ADD_AFFECT");
+				QUERY_ADD_AFFECT(peer, (TPacketGDAddAffect*)data);
+				break;
+
+			case HEADER_GD_REMOVE_AFFECT:
+				sys_log(1, "HEADER_GD_REMOVE_AFFECT");
+				QUERY_REMOVE_AFFECT(peer, (TPacketGDRemoveAffect*)data);
+				break;
+
+			case HEADER_GD_HIGHSCORE_REGISTER:
+				QUERY_HIGHSCORE_REGISTER(peer, (TPacketGDHighscore*)data);
+				break;
+
+			case HEADER_GD_PARTY_CREATE:
+				QUERY_PARTY_CREATE(peer, (TPacketPartyCreate*)data);
+				break;
+
+			case HEADER_GD_PARTY_DELETE:
+				QUERY_PARTY_DELETE(peer, (TPacketPartyDelete*)data);
+				break;
+
+			case HEADER_GD_PARTY_ADD:
+				QUERY_PARTY_ADD(peer, (TPacketPartyAdd*)data);
+				break;
+
+			case HEADER_GD_PARTY_REMOVE:
+				QUERY_PARTY_REMOVE(peer, (TPacketPartyRemove*)data);
+				break;
+
+			case HEADER_GD_PARTY_STATE_CHANGE:
+				QUERY_PARTY_STATE_CHANGE(peer, (TPacketPartyStateChange*)data);
+				break;
+
+			case HEADER_GD_PARTY_SET_MEMBER_LEVEL:
+				QUERY_PARTY_SET_MEMBER_LEVEL(peer, (TPacketPartySetMemberLevel*)data);
+				break;
+
+			case HEADER_GD_RELOAD_PROTO:
+				QUERY_RELOAD_PROTO();
+				break;
+
+			case HEADER_GD_CHANGE_NAME:
+				QUERY_CHANGE_NAME(peer, dwHandle, (TPacketGDChangeName*)data);
+				break;
+
+			case HEADER_GD_AUTH_LOGIN:
+				QUERY_AUTH_LOGIN(peer, dwHandle, (TPacketGDAuthLogin*)data);
+				break;
+
+			case HEADER_GD_REQUEST_GUILD_PRIV:
+				AddGuildPriv((TPacketGiveGuildPriv*)data);
+				break;
+
+			case HEADER_GD_REQUEST_EMPIRE_PRIV:
+				AddEmpirePriv((TPacketGiveEmpirePriv*)data);
+				break;
+
+			case HEADER_GD_REQUEST_CHARACTER_PRIV:
+				AddCharacterPriv((TPacketGiveCharacterPriv*)data);
+				break;
+
+			case HEADER_GD_MONEY_LOG:
+				MoneyLog((TPacketMoneyLog*)data);
+				break;
+
+			case HEADER_GD_GUILD_DEPOSIT_MONEY:
+				GuildDepositMoney((TPacketGDGuildMoney*)data);
+				break;
+
+			case HEADER_GD_GUILD_WITHDRAW_MONEY:
+				GuildWithdrawMoney(peer, (TPacketGDGuildMoney*)data);
+				break;
+
+			case HEADER_GD_GUILD_WITHDRAW_MONEY_GIVE_REPLY:
+				GuildWithdrawMoneyGiveReply((TPacketGDGuildMoneyWithdrawGiveReply*)data);
+				break;
+
+			case HEADER_GD_GUILD_WAR_BET:
+				GuildWarBet((TPacketGDGuildWarBet*)data);
+				break;
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+			case HEADER_GD_GUILD_EVENT_FLAG:
+				GuildSetEventFlag((TPacketSetGuildEventFlag*)data);
+				break;
+#endif
+
+			case HEADER_GD_SET_EVENT_FLAG:
+				SetEventFlag((TPacketSetEventFlag*)data);
+				break;
+
+			case HEADER_GD_CREATE_OBJECT:
+				CreateObject((TPacketGDCreateObject*)data);
+				break;
+
+			case HEADER_GD_DELETE_OBJECT:
+				DeleteObject(*(DWORD*)data);
+				break;
+
+			case HEADER_GD_UPDATE_LAND:
+				UpdateLand((DWORD*)data);
+				break;
+
+			case HEADER_GD_MARRIAGE_ADD:
+				MarriageAdd((TPacketMarriageAdd*)data);
+				break;
+
+			case HEADER_GD_MARRIAGE_UPDATE:
+				MarriageUpdate((TPacketMarriageUpdate*)data);
+				break;
+
+			case HEADER_GD_MARRIAGE_REMOVE:
+				MarriageRemove((TPacketMarriageRemove*)data);
+				break;
+
+			case HEADER_GD_WEDDING_REQUEST:
+				WeddingRequest((TPacketWeddingRequest*)data);
+				break;
+
+			case HEADER_GD_WEDDING_READY:
+				WeddingReady((TPacketWeddingReady*)data);
+				break;
+
+			case HEADER_GD_WEDDING_END:
+				WeddingEnd((TPacketWeddingEnd*)data);
+				break;
+
+				// BLOCK_CHAT
+			case HEADER_GD_BLOCK_CHAT:
+				BlockChat((TPacketBlockChat*)data);
+				break;
+				// END_OF_BLOCK_CHAT
+
+				// MYSHOP_PRICE_LIST
+			case HEADER_GD_MYSHOP_PRICELIST_UPDATE:
+				MyshopPricelistUpdate((TItemPriceListTable*)data);
+				break;
+
+			case HEADER_GD_MYSHOP_PRICELIST_REQ:
+				MyshopPricelistRequest(peer, dwHandle, *(DWORD*)data);
+				break;
+				// END_OF_MYSHOP_PRICE_LIST
+
+				// RELOAD_ADMIN
+			case HEADER_GD_RELOAD_ADMIN:
+				ReloadAdmin(peer, (TPacketReloadAdmin*)data);
+				break;
+				// END_RELOAD_ADMIN
+
+			case HEADER_GD_BREAK_MARRIAGE:
+				BreakMarriage(peer, data);
+				break;
+
+				// MOANRCH
+			case HEADER_GD_ELECT_MONARCH:
+				Election(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_CANDIDACY:
+				Candidacy(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_ADD_MONARCH_MONEY:
+				AddMonarchMoney(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_DEC_MONARCH_MONEY:
+				DecMonarchMoney(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_TAKE_MONARCH_MONEY:
+				TakeMonarchMoney(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_COME_TO_VOTE:
+				ComeToVote(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_RMCANDIDACY: ///< 캤  (楮)
+				RMCandidacy(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_SETMONARCH: ///< 玲 (楮)
+				SetMonarch(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_RMMONARCH: ///< 怜
+				RMMonarch(peer, dwHandle, data);
+				break;
+				// END_MONARCH
+
+			case HEADER_GD_CHANGE_MONARCH_LORD:
+				ChangeMonarchLord(peer, dwHandle, (TPacketChangeMonarchLord*)data);
+				break;
+
+			case HEADER_GD_BLOCK_COUNTRY_IP:
+				sys_log(0, "HEADER_GD_BLOCK_COUNTRY_IP received");
+				CBlockCountry::instance().SendBlockedCountryIp(peer);
+				CBlockCountry::instance().SendBlockException(peer);
+				break;
+
+			case HEADER_GD_BLOCK_EXCEPTION:
+				sys_log(0, "HEADER_GD_BLOCK_EXCEPTION received");
+				BlockException((TPacketBlockException*)data);
+				break;
+
+			case HEADER_GD_REQ_SPARE_ITEM_ID_RANGE:
+				SendSpareItemIDRange(peer);
+				break;
+
+			case HEADER_GD_REQ_CHANGE_GUILD_MASTER:
+				GuildChangeMaster((TPacketChangeGuildMaster*)data);
+				break;
+
+			case HEADER_GD_UPDATE_HORSE_NAME:
+				UpdateHorseName((TPacketUpdateHorseName*)data, peer);
+				break;
+
+			case HEADER_GD_REQ_HORSE_NAME:
+				AckHorseName(*(DWORD*)data, peer);
+				break;
+
+			case HEADER_GD_DC:
+				DeleteLoginKey((TPacketDC*)data);
+				break;
+
+			case HEADER_GD_VALID_LOGOUT:
+				ResetLastPlayerID((TPacketNeedLoginLogInfo*)data);
+				break;
+
+			case HEADER_GD_REQUEST_CHARGE_CASH:
+				ChargeCash((TRequestChargeCash*)data);
+				break;
+
+				// delete gift notify icon
+			case HEADER_GD_DELETE_AWARDID:
+				DeleteAwardId((TPacketDeleteAwardID*)data);
+				break;
+
+			case HEADER_GD_UPDATE_CHANNELSTATUS:
+				UpdateChannelStatus((SChannelStatus*)data);
+				break;
+
+			case HEADER_GD_REQUEST_CHANNELSTATUS:
+				RequestChannelStatus(peer, dwHandle);
+				break;
+
+#if defined(__MOVE_CHANNEL__)
+			case HEADER_GD_FIND_CHANNEL:
+				FindChannel(peer, dwHandle, (TPacketChangeChannel*)data);
+				break;
+#endif
+
+#if defined(__GEM_SHOP__)
+			case HEADER_GD_GEM_SHOP_LOAD:
+				LoadGemShop(peer, dwHandle, (TGemShopLoad*)data);
+				break;
+
+			case HEADER_GD_GEM_SHOP_UPDATE:
+				UpdateGemShop(peer, dwHandle, (TGemShopTable*)data);
+				break;
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+			case HEADER_GD_EMOTE_LOAD:
+				QUERY_EMOTE_LOAD(peer, dwHandle, (TPacketGDEmote*)data);
+				break;
+
+			case HEADER_GD_EMOTE_CLEAR:
+				QUERY_EMOTE_CLEAR(peer, dwHandle, (TPacketGDEmote*)data);
+				break;
+
+			case HEADER_GD_EMOTE_ADD:
+				QUERY_EMOTE_ADD(peer, dwHandle, (TPacketGDEmote*)data);
+				break;
+#endif
+
+#if defined(__MAILBOX__)
+			case HEADER_GD_MAILBOX_LOAD:
+				QUERY_MAILBOX_LOAD(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_CHECK_NAME:
+				QUERY_MAILBOX_CHECK_NAME(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_WRITE:
+				QUERY_MAILBOX_WRITE(peer, dwHandle, (TMailBoxTable*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_DELETE:
+				QUERY_MAILBOX_DELETE(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_CONFIRM:
+				QUERY_MAILBOX_CONFIRM(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_GET:
+				QUERY_MAILBOX_GET(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_UNREAD:
+				QUERY_MAILBOX_UNREAD(peer, dwHandle, (TMailBox*)data);
+				break;
+#endif
+
+#ifdef __SHOP_SEARCH__
+			case HEADER_GD_SHOP_SEARCH_REGISTER_ITEM:
+				CShopSearchManager::Instance().RecvRegisterItem(peer, *reinterpret_cast<const TShopSearchItem*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_UNREGISTER_ITEM:
+				CShopSearchManager::Instance().RecvUnregisterItem(*reinterpret_cast<const TShopSearchItem*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_SOLD_ITEM:
+				CShopSearchManager::Instance().RecvSoldItem(*reinterpret_cast<const TPacketGDShopSearchSoldItem*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BY_NAME:
+				CShopSearchManager::Instance().RecvSearchByName(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchByName*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BY_OPTIONS:
+			{
+				const TPacketGDShopSearchByOptions& packet = *reinterpret_cast<const TPacketGDShopSearchByOptions*>(data);
+				data += sizeof(TPacketGDShopSearchByOptions);
+				const TShopSearchItemType* itemTypeFlags = (const TShopSearchItemType*)data;
+				data += sizeof(TShopSearchItemType) * packet.options.typeFlagCount;
+				CShopSearchManager::Instance().RecvSearchByOptions(peer, dwHandle, packet, itemTypeFlags, (const DWORD*)data);
+			}
+			break;
+
+			case HEADER_GD_SHOP_SEARCH_REQUEST_BUY:
+				CShopSearchManager::Instance().RecvBuyItem(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchRequestBuy*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BUY_FROM_SHOP_ERROR:
+				CShopSearchManager::Instance().RecvBuyFromShopError(*reinterpret_cast<const TPacketDGShopSearchBuyFromShop*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BOUGHT_FROM_SHOP:
+				CShopSearchManager::Instance().RecvBoughtFromShop(dwHandle, *reinterpret_cast<const TPacketGDShopSearchBoughtFromShop*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_REQUEST_SOLD_INFO:
+				CShopSearchManager::Instance().RecvRequestSoldInfo(peer, dwHandle, *reinterpret_cast<const DWORD*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_RELOAD_AVERAGE:
+				CShopSearchManager::Instance().Initialize();
+				break;
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+			case HEADER_GD_GROWTH_PET_SAVE:
+				QUERY_GROWTH_PET_SAVE(peer, data);
+				break;
+
+			case HEADER_GD_GROWTH_PET_DELETE:
+				QUERY_GROWTH_PET_DELETE(peer, data);
+				break;
+#endif
+
+#ifdef __OFFLINE_SHOP__
+			case HEADER_GD_REQUEST_OFFLINE_SHOP_ID:
+				RequestOfflineShopId(peer, *reinterpret_cast<const uint32_t*>(data));
+				break;
+
+			case HEADER_GD_OFFLINE_SHOP_SAVE:
+				SaveOfflineShop(*reinterpret_cast<const TOfflineShop*>(data));
+				break;
+
+			case HEADER_GD_OFFLINE_SHOP_SAVE_ITEM:
+				SaveOfflineShopItem(*reinterpret_cast<const TOfflineShopItem*>(data));
+				break;
+
+			case HEADER_GD_OFFLINE_SHOP_DESTROY:
+				DestroyOfflineShop(*reinterpret_cast<const uint32_t*>(data));
+				break;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			case HEADER_GD_SAVE_EXT_BATTLE_PASS:
+				QUERY_SAVE_EXT_BATTLE_PASS(peer, dwHandle, (TPlayerExtBattlePassMission*)data);
+				break;
+#endif
+
+			default:
+				sys_err("Unknown header (header: %d handle: %d length: %d)", header, dwHandle, dwLength);
+				break;
+		}
+	}
+
+	peer->RecvEnd(i);
+}
+
+void CClientManager::AddPeer(socket_t fd)
+{
+	CPeer* pPeer = new CPeer;
+
+	if (pPeer->Accept(fd))
+		m_peerList.push_front(pPeer);
+	else
+		delete pPeer;
+}
+
+void CClientManager::RemovePeer(CPeer* pPeer)
+{
+	if (m_pkAuthPeer == pPeer)
+	{
+		m_pkAuthPeer = NULL;
+	}
+	else
+	{
+		TLogonAccountMap::iterator it = m_map_kLogonAccount.begin();
+
+		while (it != m_map_kLogonAccount.end())
+		{
+			CLoginData* pkLD = it->second;
+
+			if (pkLD->GetConnectedPeerHandle() == pPeer->GetHandle())
+			{
+				if (pkLD->IsPlay())
+					pkLD->SetPlay(false);
+
+				if (pkLD->IsDeleted())
+				{
+					sys_log(0, "DELETING LoginData");
+					delete pkLD;
+				}
+
+				m_map_kLogonAccount.erase(it++);
+			}
+			else
+				++it;
+		}
+	}
+
+	m_peerList.remove(pPeer);
+	delete pPeer;
+}
+
+CPeer* CClientManager::GetPeer(IDENT ident)
+{
+	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* tmp = *i;
+
+		if (tmp->GetHandle() == ident)
+			return tmp;
+	}
+
+	return NULL;
+}
+
+CPeer* CClientManager::GetAnyPeer()
+{
+	if (m_peerList.empty())
+		return NULL;
+
+	return m_peerList.front();
+}
+
+// DB 킴    처磯.
+//
+// @version	05/06/10 Bang2ni -   (QID_ITEMPRICE_XXX) 煞
+int CClientManager::AnalyzeQueryResult(SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	CPeer* peer = GetPeer(qi->dwIdent);
+
+#if defined(_DEBUG)
+	if (qi->iType != QID_ITEM_AWARD_LOAD)
+		sys_log(0, "AnalyzeQueryResult %d", qi->iType);
+#endif
+
+	switch (qi->iType)
+	{
+		case QID_ITEM_AWARD_LOAD:
+			ItemAwardManager::instance().Load(msg);
+			delete qi;
+			return true;
+
+		case QID_GUILD_RANKING:
+			CGuildManager::instance().ResultRanking(msg->Get()->pSQLResult);
+			break;
+
+			// MYSHOP_PRICE_LIST
+		case QID_ITEMPRICE_LOAD_FOR_UPDATE:
+			RESULT_PRICELIST_LOAD_FOR_UPDATE(msg);
+			break;
+			// END_OF_MYSHOP_PRICE_LIST
+	}
+
+	if (!peer)
+	{
+		//sys_err("CClientManager::AnalyzeQueryResult: peer not exist anymore. (ident: %d)", qi->dwIdent);
+		delete qi;
+		return true;
+	}
+
+	switch (qi->iType)
+	{
+		case QID_PLAYER:
+		case QID_ITEM:
+		case QID_QUEST:
+		case QID_AFFECT:
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		case QID_EXT_BATTLE_PASS:
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+		case QID_GROWTH_PET:
+#endif
+			RESULT_COMPOSITE_PLAYER(peer, msg, qi->iType);
+			break;
+
+		case QID_LOGIN:
+			RESULT_LOGIN(peer, msg);
+			break;
+
+		case QID_SAFEBOX_LOAD:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_LOAD");
+			RESULT_SAFEBOX_LOAD(peer, msg);
+			break;
+
+		case QID_SAFEBOX_CHANGE_SIZE:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_SIZE");
+			RESULT_SAFEBOX_CHANGE_SIZE(peer, msg);
+			break;
+
+		case QID_SAFEBOX_CHANGE_PASSWORD:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
+			RESULT_SAFEBOX_CHANGE_PASSWORD(peer, msg);
+			break;
+
+		case QID_SAFEBOX_CHANGE_PASSWORD_SECOND:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
+			RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(peer, msg);
+			break;
+
+		case QID_HIGHSCORE_REGISTER:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_HIGHSCORE_REGISTER %p", msg);
+			RESULT_HIGHSCORE_REGISTER(peer, msg);
+			break;
+
+		case QID_SAFEBOX_SAVE:
+		case QID_ITEM_SAVE:
+		case QID_ITEM_DESTROY:
+		case QID_QUEST_SAVE:
+		case QID_PLAYER_SAVE:
+		case QID_ITEM_AWARD_TAKEN:
+#ifdef __GROWTH_PET_SYSTEM__
+		case QID_GROWTH_PET_SAVE:
+		case QID_GROWTH_PET_DELETE:
+#endif
+			break;
+
+			// PLAYER_INDEX_CREATE_BUG_FIX
+		case QID_PLAYER_INDEX_CREATE:
+			RESULT_PLAYER_INDEX_CREATE(peer, msg);
+			break;
+			// END_PLAYER_INDEX_CREATE_BUG_FIX
+
+		case QID_PLAYER_DELETE:
+			__RESULT_PLAYER_DELETE(peer, msg);
+			break;
+
+		case QID_LOGIN_BY_KEY:
+			RESULT_LOGIN_BY_KEY(peer, msg);
+			break;
+
+			// MYSHOP_PRICE_LIST
+		case QID_ITEMPRICE_LOAD:
+			RESULT_PRICELIST_LOAD(peer, msg);
+			break;
+			// END_OF_MYSHOP_PRICE_LIST
+
+		default:
+			sys_log(0, "CClientManager::AnalyzeQueryResult unknown query result type: %d, str: %s", qi->iType, msg->stQuery.c_str());
+			break;
+	}
+
+	delete qi;
+	return true;
+}
+
+void UsageLog()
+{
+	FILE* fp = NULL;
+
+	time_t ct;
+	struct tm lt;
+	char time_buf[32];
+
+	int avg = g_dwUsageAvg / 3600; // 60 sec * 60 min
+
+	fp = fopen("usage.txt", "a+");
+
+	if (!fp)
+		return;
+
+	ct = time(0);
+
+#if defined(_WIN32) || defined(_WIN64)
+	localtime_s(&lt, &ct);
+#else
+	localtime_r(&ct, &lt);
+#endif
+
+	strftime(time_buf, sizeof(time_buf), "%b %d %H:%M:%S", &lt);
+
+	fprintf(fp, "| %4d %-15.15s | %5d | %5u |\\n", lt.tm_year + 1900, time_buf, avg, g_dwUsageMax);
+	fclose(fp);
+
+	g_dwUsageMax = g_dwUsageAvg = 0;
+}
+
+
+int CClientManager::Process()
+{
+	int pulses;
+
+	if (!(pulses = thecore_idle()))
+		return 0;
+
+	while (pulses--)
+	{
+		++thecore_heart->pulse;
+
+		/*
+		// 30龜 
+		if (((thecore_pulse() % (60 * 30 * 10)) == 0))
+		{
+			g_iPlayerCacheFlushSeconds = MAX(60, rand() % 180);
+			g_iItemCacheFlushSeconds = MAX(60, rand() % 180);
+			sys_log(0, "[SAVE_TIME]Change saving time item %d player %d", g_iPlayerCacheFlushSeconds, g_iItemCacheFlushSeconds);
+		}
+		*/
+
+		if (!(thecore_heart->pulse % thecore_heart->passes_per_sec))
+		{
+			if (g_test_server)
+			{
+				if (!(thecore_heart->pulse % thecore_heart->passes_per_sec * 10))
+
+				{
+					pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d/%d",
+						thecore_heart->pulse,
+						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+						CDBManager::instance().CountReturnResult(SQL_PLAYER),
+						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+						CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
+						CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
+
+					if ((thecore_heart->pulse % 50) == 0)
+						sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
+							thecore_heart->pulse,
+							CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+							CDBManager::instance().CountReturnResult(SQL_PLAYER),
+							CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+							CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+							CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+							CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
+				}
+			}
+			else
+			{
+				pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d%/%d",
+					thecore_heart->pulse,
+					CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+					CDBManager::instance().CountReturnResult(SQL_PLAYER),
+					CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+					CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
+					CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+					CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+					CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
+					CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
+
+				if ((thecore_heart->pulse % 50) == 0)
+					sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
+						thecore_heart->pulse,
+						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+						CDBManager::instance().CountReturnResult(SQL_PLAYER),
+						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
+			}
+
+			CDBManager::instance().ResetCounter();
+
+			DWORD dwCount = CClientManager::instance().GetUserCount();
+
+			g_dwUsageAvg += dwCount;
+			g_dwUsageMax = MAX(g_dwUsageMax, dwCount);
+
+			memset(&thecore_profiler[0], 0, sizeof(thecore_profiler));
+
+#if defined(__EXPRESSING_EMOTIONS__)
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iEmoteDumpDelay)))
+				CClientManager::instance().QUERY_EMOTE_DUMP();
+#endif
+
+#if defined(__MAILBOX__)
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iMailBoxBackupSec)))
+				CClientManager::instance().MAILBOX_BACKUP();
+#endif
+
+#if defined(__GEM_SHOP__)
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iGemShopFlushDelay)))
+				CClientManager::instance().FlushGemShop();
+#endif
+
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600)))
+				UsageLog();
+
+			m_iCacheFlushCount = 0;
+
+			// 첨潔 첨
+			UpdatePlayerCache();
+			//  첨
+			UpdateItemCache();
+			//慣類틸 처- 캐 첨
+			UpdateLogoutPlayer();
+
+			// MYSHOP_PRICE_LIST
+			UpdateItemPriceListCache();
+			// END_OF_MYSHOP_PRICE_LIST
+#ifdef __OFFLINE_SHOP__
+			UpdateOfflineShopCache();
+			UpdateOfflineShopItemCache();
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+			UpdateGrowthPetCache();
+#endif
+			CGuildManager::instance().Update();
+			CPrivManager::instance().Update();
+			marriage::CManager::instance().Update();
+#ifdef __SHOP_SEARCH__
+			CShopSearchManager::Instance().Update();
+#endif
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 5)))
+		{
+			ItemAwardManager::instance().RequestLoad();
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 10)))
+		{
+			/*
+			char buf[4096 + 1];
+			int len
+
+			/////////////////////////////////////////////////////////////////
+			buf[0] = '\0';
+			len = 0;
+
+			auto it = g_query_info.m_map_info.begin();
+
+			int count = 0;
+
+			while (it != g_query_info.m_map_info.end())
+			{
+				len += snprintf(buf + len, sizeof(buf) - len, "%2d %3d\n", it->first, it->second);
+				count += it->second;
+				it++;
+			}
+
+			pt_log("QUERY:\n%s-------------------- MAX : %d\n", buf, count);
+			g_query_info.Reset();
+			*/
+			pt_log("QUERY: MAIN[%d] ASYNC[%d]", g_query_count[0], g_query_count[1]);
+			g_query_count[0] = 0;
+			g_query_count[1] = 0;
+			/////////////////////////////////////////////////////////////////
+
+			/////////////////////////////////////////////////////////////////
+			/*
+			buf[0] = '\0';
+			len = 0;
+
+			it = g_item_info.m_map_info.begin();
+
+			count = 0;
+			while (it != g_item_info.m_map_info.end())
+			{
+				len += snprintf(buf + len, sizeof(buf) - len, "%5d %3d\n", it->first, it->second);
+				count += it->second;
+				it++;
+			}
+
+			pt_log("ITEM:\n%s-------------------- MAX : %d\n", buf, count);
+			g_item_info.Reset();
+			*/
+			pt_log("ITEM:%d\n", g_item_count);
+			g_item_count = 0;
+			/////////////////////////////////////////////////////////////////
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60))) // 60却 箕
+		{
+			// 크   챨 .
+			CClientManager::instance().SendTime();
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600))) // 耆챨 箕
+		{
+			CMoneyLog::instance().Save();
+		}
+
+#if defined(__ENVIRONMENT_SYSTEM__)
+		static bool OnSetup = true;
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60 * 20)) || OnSetup)
+		{
+			UpdateEnvironment();
+			OnSetup = false;
+		}
+#endif
+	}
+
+	int num_events = fdwatch(m_fdWatcher, 0);
+	int idx;
+	CPeer* peer;
+
+	for (idx = 0; idx < num_events; ++idx) // 풋
+	{
+		peer = (CPeer*)fdwatch_get_client_data(m_fdWatcher, idx);
+
+		if (!peer)
+		{
+			if (fdwatch_check_event(m_fdWatcher, m_fdAccept, idx) == FDW_READ)
+			{
+				AddPeer(m_fdAccept);
+				fdwatch_clear_event(m_fdWatcher, m_fdAccept, idx);
+			}
+			else
+			{
+				sys_log(0, "FDWATCH: peer null in event: ident %d", fdwatch_get_ident(m_fdWatcher, idx));
+			}
+
+			continue;
+		}
+
+		switch (fdwatch_check_event(m_fdWatcher, peer->GetFd(), idx))
+		{
+			case FDW_READ:
+				if (peer->Recv() < 0)
+				{
+					sys_err("Recv failed");
+					RemovePeer(peer);
+				}
+				else
+				{
+					if (peer == m_pkAuthPeer)
+						if (g_log)
+							sys_log(0, "AUTH_PEER_READ: size %d", peer->GetRecvLength());
+
+					ProcessPackets(peer);
+				}
+				break;
+
+			case FDW_WRITE:
+				if (peer == m_pkAuthPeer)
+					if (g_log)
+						sys_log(0, "AUTH_PEER_WRITE: size %d", peer->GetSendLength());
+
+				if (peer->Send() < 0)
+				{
+					sys_err("Send failed");
+					RemovePeer(peer);
+				}
+
+				break;
+
+			case FDW_EOF:
+				RemovePeer(peer);
+				break;
+
+			default:
+				sys_err("fdwatch_check_fd returned unknown result");
+				RemovePeer(peer);
+				break;
+		}
+	}
+
+#ifdef __WIN32__
+	if (_kbhit())
+	{
+		int c = _getch();
+		switch (c)
+		{
+			case 0x1b: // Esc
+				return 0; // shutdown
+				break;
+			default:
+				break;
+		}
+	}
+#endif
+
+	return 1;
+}
+
+DWORD CClientManager::GetUserCount()
+{
+	// 秉 慣 카트 .. --;
+	return m_map_kLogonAccount.size();
+}
+
+void CClientManager::SendAllGuildSkillRechargePacket()
+{
+	ForwardPacket(HEADER_DG_GUILD_SKILL_RECHARGE, NULL, 0);
+}
+
+void CClientManager::SendTime()
+{
+	time_t now = GetCurrentTime();
+	ForwardPacket(HEADER_DG_TIME, &now, sizeof(time_t));
+}
+
+void CClientManager::ForwardPacket(BYTE header, const void* data, int size, BYTE bChannel, CPeer* except)
+{
+	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* peer = *it;
+
+		if (peer == except)
+			continue;
+
+		if (!peer->GetChannel())
+			continue;
+
+		if (bChannel && peer->GetChannel() != bChannel)
+			continue;
+
+		peer->EncodeHeader(header, 0, size);
+
+		if (size > 0 && data)
+			peer->Encode(data, size);
+	}
+}
+
+void CClientManager::SendNotice(const char* c_pszFormat, ...)
+{
+	char szBuf[255 + 1];
+	va_list args;
+
+	va_start(args, c_pszFormat);
+	int len = vsnprintf(szBuf, sizeof(szBuf), c_pszFormat, args);
+	va_end(args);
+	szBuf[len] = '\0';
+
+	ForwardPacket(HEADER_DG_NOTICE, szBuf, len + 1);
+}
+
+time_t CClientManager::GetCurrentTime()
+{
+	return time(0);
+}
+
+// ITEM_UNIQUE_ID
+bool CClientManager::InitializeNowItemID()
+{
+	DWORD dwMin, dwMax;
+
+	//  ID 珂화 磯.
+	if (!CConfig::instance().GetTwoValue("ITEM_ID_RANGE", &dwMin, &dwMax))
+	{
+		sys_err("config.txt: Cannot find ITEM_ID_RANGE [start_item_id] [end_item_id]");
+		return false;
+	}
+
+	sys_log(0, "ItemRange From File %u ~ %u ", dwMin, dwMax);
+
+	if (CItemIDRangeManager::instance().BuildRange(dwMin, dwMax, m_itemRange) == false)
+	{
+		sys_err("Can not build ITEM_ID_RANGE");
+		return false;
+	}
+
+	sys_log(0, " Init Success Start %u End %u Now %u\n", m_itemRange.dwMin, m_itemRange.dwMax, m_itemRange.dwUsableItemIDMin);
+
+	return true;
+}
+
+DWORD CClientManager::GainItemID()
+{
+	return m_itemRange.dwUsableItemIDMin++;
+}
+
+DWORD CClientManager::GetItemID()
+{
+	return m_itemRange.dwUsableItemIDMin;
+}
+// ITEM_UNIQUE_ID_END
+
+// BOOT_LOCALIZATION
+bool CClientManager::InitializeLocalization()
+{
+	char szQuery[512];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `mValue`, `mKey` FROM `locale`");
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
+
+	if (pMsg->Get()->uiNumRows == 0)
+	{
+		sys_err("InitializeLocalization() ==> DirectQuery failed(%s)", szQuery);
+		delete pMsg;
+		return false;
+	}
+
+	sys_log(0, "InitializeLocalization() - LoadLocaleTable(count:%d)", pMsg->Get()->uiNumRows);
+
+	m_vec_Locale.clear();
+
+	MYSQL_ROW row = NULL;
+
+	for (; (row = mysql_fetch_row(pMsg->Get()->pSQLResult)) != NULL;)
+	{
+		int col = 0;
+		tLocale locale;
+
+		strlcpy(locale.szValue, row[col++], sizeof(locale.szValue));
+		strlcpy(locale.szKey, row[col++], sizeof(locale.szKey));
+
+		// DB_NAME_COLUMN Setting
+		if (strcmp(locale.szKey, "LOCALE") == 0)
+		{
+			if (strcmp(locale.szValue, "cibn") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
+
+				g_stLocale = "gb2312";
+				g_stLocaleNameColumn = "gb2312name";
+			}
+			else if (strcmp(locale.szValue, "ymir") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "euckr";
+				g_stLocaleNameColumn = "name";
+			}
+			else if (strcmp(locale.szValue, "japan") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "sjis");
+
+				g_stLocale = "sjis";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "english") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "germany") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "france") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "italy") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "spain") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "uk") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "turkey") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin5";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "poland") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "portugal") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "hongkong") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
+
+				g_stLocale = "big5";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "newcibn") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
+
+				g_stLocale = "gb2312";
+				g_stLocaleNameColumn = "gb2312name";
+			}
+			else if (strcmp(locale.szValue, "korea") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "euckr";
+				g_stLocaleNameColumn = "name";
+			}
+			else if (strcmp(locale.szValue, "canada") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "gb2312name";
+			}
+			else if (strcmp(locale.szValue, "brazil") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "greek") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "greek";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "russia") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "cp1251";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "denmark") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "bulgaria") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "cp1251";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "croatia") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "cp1251";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "mexico") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "arabia") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "cp1256";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "czech") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "hungary") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "romania") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "netherlands") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "singapore") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "vietnam") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "thailand") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "usa") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "we_korea") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "euckr";
+				g_stLocaleNameColumn = "name";
+			}
+			else if (strcmp(locale.szValue, "taiwan") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
+				g_stLocale = "big5";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "europe") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else
+			{
+				sys_err("locale[LOCALE] = UNKNOWN(%s)", locale.szValue);
+				exit(0);
+			}
+
+			CDBManager::instance().SetLocale(g_stLocale.c_str());
+		}
+		else if (strcmp(locale.szKey, "DB_NAME_COLUMN") == 0)
+		{
+			sys_log(0, "locale[DB_NAME_COLUMN] = %s", locale.szValue);
+			g_stLocaleNameColumn = locale.szValue;
+		}
+		else
+		{
+			sys_log(0, "locale[UNKNOWN_KEY(%s)] = %s", locale.szKey, locale.szValue);
+		}
+		m_vec_Locale.push_back(locale);
+	}
+
+	delete pMsg;
+
+	return true;
+}
+// END_BOOT_LOCALIZATION
+
+// ADMIN_MANAGER
+bool CClientManager::__GetAdminInfo(const char* szIP, std::vector<tAdminInfo>& rAdminVec)
+{
+	// szIP == NULL 構 煐 楮  쨈.
+	char szQuery[512];
+	snprintf(szQuery, sizeof(szQuery),
+		"SELECT `mID`, `mAccount`, `mName`, `mContactIP`, `mServerIP`, `mAuthority` FROM `gmlist` WHERE `mServerIP` = 'ALL' OR `mServerIP` = '%s'",
+		szIP ? szIP : "ALL");
+
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
+
+	if (pMsg->Get()->uiNumRows == 0)
+	{
+		sys_err("__GetAdminInfo() ==> DirectQuery failed(%s)", szQuery);
+		delete pMsg;
+		return false;
+	}
+
+	MYSQL_ROW row;
+	rAdminVec.reserve(pMsg->Get()->uiNumRows);
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		int idx = 0;
+		tAdminInfo Info;
+
+		str_to_number(Info.m_ID, row[idx++]);
+		trim_and_lower(row[idx++], Info.m_szAccount, sizeof(Info.m_szAccount));
+		strlcpy(Info.m_szName, row[idx++], sizeof(Info.m_szName));
+		strlcpy(Info.m_szContactIP, row[idx++], sizeof(Info.m_szContactIP));
+		strlcpy(Info.m_szServerIP, row[idx++], sizeof(Info.m_szServerIP));
+		std::string stAuth = row[idx++];
+
+		if (!stAuth.compare("IMPLEMENTOR"))
+			Info.m_Authority = GM_IMPLEMENTOR;
+		else if (!stAuth.compare("GOD"))
+			Info.m_Authority = GM_GOD;
+		else if (!stAuth.compare("HIGH_WIZARD"))
+			Info.m_Authority = GM_HIGH_WIZARD;
+		else if (!stAuth.compare("LOW_WIZARD"))
+			Info.m_Authority = GM_LOW_WIZARD;
+		else if (!stAuth.compare("WIZARD"))
+			Info.m_Authority = GM_WIZARD;
+		else
+			continue;
+
+		rAdminVec.push_back(Info);
+
+		sys_log(0, "GM: PID %u Login %s Character %s ContactIP %s ServerIP %s Authority %d[%s]",
+			Info.m_ID, Info.m_szAccount, Info.m_szName, Info.m_szContactIP, Info.m_szServerIP, Info.m_Authority, stAuth.c_str());
+	}
+
+	delete pMsg;
+
+	return true;
+}
+
+bool CClientManager::__GetHostInfo(std::vector<std::string>& rIPVec)
+{
+	char szQuery[512];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `mIP` FROM `gmhost`");
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
+
+	if (pMsg->Get()->uiNumRows == 0)
+	{
+		sys_err("__GetHostInfo() ==> DirectQuery failed(%s)", szQuery);
+		delete pMsg;
+		return false;
+	}
+
+	rIPVec.reserve(pMsg->Get()->uiNumRows);
+
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		if (row[0] && *row[0])
+		{
+			rIPVec.push_back(row[0]);
+			sys_log(0, "GMHOST: %s", row[0]);
+		}
+	}
+
+	delete pMsg;
+	return true;
+}
+// END_ADMIN_MANAGER
+
+void CClientManager::ReloadAdmin(CPeer*, TPacketReloadAdmin* p)
+{
+	std::vector<tAdminInfo> vAdmin;
+	std::vector<std::string> vHost;
+
+	__GetHostInfo(vHost);
+	__GetAdminInfo(p->szIP, vAdmin);
+
+	DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
+		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size();
+
+	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* peer = *it;
+
+		if (!peer->GetChannel())
+			continue;
+
+		peer->EncodeHeader(HEADER_DG_RELOAD_ADMIN, 0, dwPacketSize);
+
+		peer->EncodeWORD(16);
+		peer->EncodeWORD(static_cast<WORD>(vHost.size()));
+
+		for (size_t n = 0; n < vHost.size(); ++n)
+			peer->Encode(vHost[n].c_str(), 16);
+
+		peer->EncodeWORD(sizeof(tAdminInfo));
+		peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
+
+		for (size_t n = 0; n < vAdmin.size(); ++n)
+			peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
+	}
+
+	sys_log(0, "ReloadAdmin End %s", p->szIP);
+}
+
+// BREAK_MARRIAGE
+void CClientManager::BreakMarriage(CPeer* peer, const char* data)
+{
+	DWORD pid1, pid2;
+
+	pid1 = *(int*)data;
+	data += sizeof(int);
+
+	pid2 = *(int*)data;
+	data += sizeof(int);
+
+	sys_log(0, "Breaking off a marriage engagement! pid %d and pid %d", pid1, pid2);
+	marriage::CManager::instance().Remove(pid1, pid2);
+}
+// END_BREAK_MARIIAGE
+
+void CClientManager::UpdateItemCacheSet(DWORD pid)
+{
+	auto it = m_map_pkItemCacheSetPtr.find(pid);
+	if (it == m_map_pkItemCacheSetPtr.end())
+	{
+		if (g_test_server)
+			sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCacheSet ==> No ItemCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TItemCacheSet* pSet = it->second;
+	TItemCacheSet::iterator it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CItemCache* c = *it_set++;
+		c->Flush();
+	}
+
+	if (g_log)
+		sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCachsSet pid(%d)", pid);
+}
+
+void CClientManager::Election(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	DWORD idx;
+	DWORD selectingpid;
+
+	idx = *(DWORD*)data;
+	data += sizeof(DWORD);
+
+	selectingpid = *(DWORD*)data;
+	data += sizeof(DWORD);
+
+	int Success = 0;
+
+	if (!(Success = CMonarch::instance().VoteMonarch(selectingpid, idx)))
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_VOTE] Failed %d %d", idx, selectingpid);
+		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
+		peer->Encode(&Success, sizeof(int));
+		return;
+	}
+	else
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_VOTE] Success %d %d", idx, selectingpid);
+		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
+		peer->Encode(&Success, sizeof(int));
+		return;
+	}
+
+}
+
+void CClientManager::Candidacy(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	DWORD pid;
+
+	pid = *(DWORD*)data;
+	data += sizeof(DWORD);
+
+	if (!CMonarch::instance().AddCandidacy(pid, data))
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_CANDIDACY] Failed %d %s", pid, data);
+
+		peer->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
+		peer->Encode(0, sizeof(int));
+		peer->Encode(data, 32);
+		return;
+	}
+	else
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_CANDIDACY] Success %d %s", pid, data);
+
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (0 && p->GetChannel() != 0)
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
+				p->Encode(&pid, sizeof(int));
+				p->Encode(data, 32);
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_CANDIDACY, 0, sizeof(int) + 32);
+				p->Encode(&pid, sizeof(int));
+				p->Encode(data, 32);
+			}
+		}
+	}
+}
+
+void CClientManager::AddMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH] Add money Empire(%d) Money(%d)", Empire, Money);
+
+	CMonarch::instance().AddMoney(Empire, Money);
+
+	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* p = *it;
+
+		if (!p->GetChannel())
+			continue;
+
+		if (p == peer)
+		{
+			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+		else
+		{
+			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+
+	}
+}
+
+void CClientManager::DecMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH] Dec money Empire(%d) Money(%d)", Empire, Money);
+
+	CMonarch::instance().DecMoney(Empire, Money);
+
+	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* p = *it;
+
+		if (!p->GetChannel())
+			continue;
+
+		if (p == peer)
+		{
+			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+		else
+		{
+			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+	}
+}
+
+void CClientManager::TakeMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	DWORD pid = *(DWORD*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH] Take money Empire(%d) Money(%d)", Empire, Money);
+
+	if (CMonarch::instance().TakeMoney(Empire, pid, Money) == true)
+	{
+		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+		peer->Encode(&Empire, sizeof(int));
+		peer->Encode(&Money, sizeof(int));
+	}
+	else
+	{
+		Money = 0;
+		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+		peer->Encode(&Empire, sizeof(int));
+		peer->Encode(&Money, sizeof(int));
+	}
+}
+
+void CClientManager::ComeToVote(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	CMonarch::instance().ElectMonarch();
+}
+
+void CClientManager::RMCandidacy(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	char szName[32];
+
+	strlcpy(szName, data, sizeof(szName));
+	sys_log(0, "[MONARCH_GM] Remove candidacy name(%s)", szName);
+
+	int iRet = CMonarch::instance().DelCandidacy(szName) ? 1 : 0;
+
+	if (1 == iRet)
+	{
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+		}
+	}
+	else
+	{
+		CPeer* p = peer;
+		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+		p->Encode(&iRet, sizeof(int));
+		p->Encode(szName, sizeof(szName));
+	}
+}
+
+void CClientManager::SetMonarch(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	char szName[32];
+
+	strlcpy(szName, data, sizeof(szName));
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH_GM] Set Monarch name(%s)", szName);
+
+	int iRet = CMonarch::instance().SetMonarch(szName) ? 1 : 0;
+
+	if (1 == iRet)
+	{
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+		}
+	}
+	else
+	{
+		CPeer* p = peer;
+		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+		p->Encode(&iRet, sizeof(int));
+		p->Encode(szName, sizeof(szName));
+	}
+}
+
+void CClientManager::RMMonarch(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	char szName[32];
+
+	strlcpy(szName, data, sizeof(szName));
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH_GM] Remove Monarch name(%s)", szName);
+
+	CMonarch::instance().DelMonarch(szName);
+
+	int iRet = CMonarch::instance().DelMonarch(szName) ? 1 : 0;
+
+	if (1 == iRet)
+	{
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+		}
+	}
+	else
+	{
+		CPeer* p = peer;
+		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+		p->Encode(&iRet, sizeof(int));
+		p->Encode(szName, sizeof(szName));
+	}
+}
+
+void CClientManager::ChangeMonarchLord(CPeer* peer, DWORD dwHandle, TPacketChangeMonarchLord* info)
+{
+	char szQuery[1024];
+	snprintf(szQuery, sizeof(szQuery),
+		"SELECT a.`name`, NOW() FROM player%s AS a, player_index%s AS b WHERE (a.`account_id` = b.`id` AND a.`id` = %u AND b.`empire` = %u) AND "
+		"(b.`pid1` = %u OR "
+		"b.`pid2` = %u OR "
+		"b.`pid3` = %u OR "
+		"b.`pid4` = %u"
+#if defined(__PLAYER_PER_ACCOUNT5__)
+		" OR b.`pid5` = %u"
+#endif
+		")",
+		GetTablePostfix(),
+		GetTablePostfix(),
+		info->dwPID,
+		info->bEmpire,
+		info->dwPID,
+		info->dwPID,
+		info->dwPID,
+		info->dwPID
+#if defined(__PLAYER_PER_ACCOUNT5__)
+		, info->dwPID
+#endif
+	);
+
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
+
+	if (pMsg->Get()->uiNumRows != 0)
+	{
+		TPacketChangeMonarchLordACK ack;
+		ack.bEmpire = info->bEmpire;
+		ack.dwPID = info->dwPID;
+
+		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+		strlcpy(ack.szName, row[0], sizeof(ack.szName));
+		strlcpy(ack.szDate, row[1], sizeof(ack.szDate));
+
+		snprintf(szQuery, sizeof(szQuery), "UPDATE `monarch` SET `pid` = %u, `windate` = NOW() WHERE `empire` = %d", ack.dwPID, ack.bEmpire);
+		SQLMsg* pMsg2 = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
+
+		if (pMsg2->Get()->uiAffectedRows > 0)
+		{
+			CMonarch::instance().LoadMonarch();
+
+			TMonarchInfo* newInfo = CMonarch::instance().GetMonarch();
+
+			for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+			{
+				CPeer* client = *it;
+
+				client->EncodeHeader(HEADER_DG_CHANGE_MONARCH_LORD_ACK, 0, sizeof(TPacketChangeMonarchLordACK));
+				client->Encode(&ack, sizeof(TPacketChangeMonarchLordACK));
+
+				client->EncodeHeader(HEADER_DG_UPDATE_MONARCH_INFO, 0, sizeof(TMonarchInfo));
+				client->Encode(newInfo, sizeof(TMonarchInfo));
+			}
+		}
+
+		delete pMsg2;
+	}
+
+	delete pMsg;
+}
+
+void CClientManager::BlockException(TPacketBlockException* data)
+{
+	sys_log(0, "[BLOCK_EXCEPTION] CMD(%d) login(%s)", data->cmd, data->login);
+
+	// save sql
+	{
+		char buf[1024];
+
+		switch (data->cmd)
+		{
+			case BLOCK_EXCEPTION_CMD_ADD:
+				snprintf(buf, sizeof(buf), "INSERT INTO `block_exception` VALUES('%s')", data->login);
+				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
+				CBlockCountry::instance().AddBlockException(data->login);
+				break;
+			case BLOCK_EXCEPTION_CMD_DEL:
+				snprintf(buf, sizeof(buf), "DELETE FROM `block_exception` WHERE `login` = %s", data->login);
+				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
+				CBlockCountry::instance().DelBlockException(data->login);
+				break;
+			default:
+				return;
+		}
+
+	}
+
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* peer = *it;
+
+		if (!peer->GetChannel())
+			continue;
+
+		CBlockCountry::instance().SendBlockExceptionOne(peer, data->login, data->cmd);
+	}
+}
+
+void CClientManager::SendSpareItemIDRange(CPeer* peer)
+{
+	peer->SendSpareItemIDRange();
+}
+
+//
+// Login Key 却 .
+//
+void CClientManager::DeleteLoginKey(TPacketDC* data)
+{
+	char login[LOGIN_MAX_LEN + 1] = { 0 };
+	trim_and_lower(data->login, login, sizeof(login));
+
+	CLoginData* pkLD = GetLoginDataByLogin(login);
+
+	if (pkLD)
+	{
+		TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(pkLD->GetKey());
+
+		if (it != m_map_pkLoginData.end())
+			m_map_pkLoginData.erase(it);
+	}
+}
+
+// delete gift notify icon
+void CClientManager::DeleteAwardId(TPacketDeleteAwardID* data)
+{
+	// sys_log(0, "data from game server arrived %d", data->dwID);
+	std::map<DWORD, TItemAward*>::iterator it;
+	it = ItemAwardManager::Instance().GetMapAward().find(data->dwID);
+	if (it != ItemAwardManager::Instance().GetMapAward().end())
+	{
+		std::set<TItemAward*>& kSet = ItemAwardManager::Instance().GetMapkSetAwardByLogin()[it->second->szLogin];
+		if (kSet.erase(it->second))
+			sys_log(0, "erase ItemAward id: %d from cache", data->dwID);
+		ItemAwardManager::Instance().GetMapAward().erase(data->dwID);
+	}
+	else
+	{
+		sys_log(0, "DELETE_AWARDID : could not find the id: %d", data->dwID);
+	}
+}
+
+void CClientManager::UpdateChannelStatus(TChannelStatus* pData)
+{
+	TChannelStatusMap::iterator it = m_mChannelStatus.find(pData->nPort);
+	if (it != m_mChannelStatus.end())
+	{
+		it->second = pData->bStatus;
+	}
+	else
+	{
+		m_mChannelStatus.insert(TChannelStatusMap::value_type(pData->nPort, pData->bStatus));
+	}
+}
+
+void CClientManager::RequestChannelStatus(CPeer* peer, DWORD dwHandle)
+{
+	const int nSize = m_mChannelStatus.size();
+	peer->EncodeHeader(HEADER_DG_RESPOND_CHANNELSTATUS, dwHandle, sizeof(TChannelStatus) * nSize + sizeof(int));
+	peer->Encode(&nSize, sizeof(int));
+	for (TChannelStatusMap::iterator it = m_mChannelStatus.begin(); it != m_mChannelStatus.end(); ++it)
+	{
+		peer->Encode(&it->first, sizeof(short));
+		peer->Encode(&it->second, sizeof(BYTE));
+	}
+}
+
+void CClientManager::ResetLastPlayerID(const TPacketNeedLoginLogInfo* data)
+{
+	CLoginData* pkLD = GetLoginDataByAID(data->dwPlayerID);
+
+	if (NULL != pkLD)
+	{
+		pkLD->SetLastPlayerID(0);
+	}
+}
+
+void CClientManager::ChargeCash(const TRequestChargeCash* packet)
+{
+	char szQuery[512];
+
+	if (ERequestCharge_Cash == packet->eChargeType)
+		sprintf(szQuery, "update account set `cash` = `cash` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
+	else if (ERequestCharge_Mileage == packet->eChargeType)
+		sprintf(szQuery, "update account set `mileage` = `mileage` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
+	else
+	{
+		sys_err("Invalid request charge type (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
+		return;
+	}
+
+	sys_err("Request Charge (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
+
+	CDBManager::Instance().AsyncQuery(szQuery, SQL_ACCOUNT);
+}
+
+#if defined(__MOVE_CHANNEL__)
+void CClientManager::FindChannel(CPeer* requestPeer, DWORD dwHandle, TPacketChangeChannel* p)
+{
+	if (!p->lMapIndex || !p->iChannel)
+		return;
+
+	long lAddr = 0;
+	WORD wPort = 0;
+
+	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* peer = *i;
+		if (peer->GetChannel() != p->iChannel) // not the channel we are looking for!
+			continue;
+
+		TMapLocation kMapLocation;
+		thecore_memcpy(kMapLocation.alMaps, peer->GetMaps(), sizeof(kMapLocation.alMaps));
+		int iLen = sizeof(kMapLocation.alMaps) / sizeof(kMapLocation.alMaps[0]);
+
+		for (int i = 0; i < iLen; ++i)
+		{
+			if (kMapLocation.alMaps[i] == p->lMapIndex)
+			{
+				// Get host, and convert to int
+				char host[16];
+				strlcpy(host, peer->GetPublicIP(), sizeof(kMapLocation.szHost));
+				lAddr = inet_addr(host);
+
+				// Target port
+				wPort = peer->GetListenPort();
+
+				break;
+			}
+		}
+
+		if (lAddr && wPort) // We already obtained them
+			break;
+	}
+
+	TPacketReturnChannel r;
+	r.lAddr = lAddr;
+	r.wPort = wPort;
+
+	requestPeer->EncodeHeader(HEADER_DG_CHANNEL_RESULT, dwHandle, sizeof(r));
+	requestPeer->Encode(&r, sizeof(r));
+}
+#endif
+
+#if defined(__ENVIRONMENT_SYSTEM__)
+enum DayMode : BYTE { DAY, NIGHT };
+
+static BYTE GetDayMode(int Hour)
+{
+	if (Hour >= 6 && Hour <= 20)
+		return DayMode::DAY;
+	return DayMode::NIGHT;
+}
+
+static bool IsWinter(int Month)
+{
+	return (Month >= 11 || Month <= 0);
+}
+
+void CClientManager::UpdateEnvironment()
+{
+	time_t CurrentTime = time(nullptr);
+	struct tm tm_buf;
+#if defined(_WIN32) || defined(_WIN64)
+	localtime_s(&tm_buf, &CurrentTime);
+#else
+	localtime_r(&CurrentTime, &tm_buf);
+#endif
+
+	auto SendFlag = [&](const char* flag, BYTE val)
+		{
+			TEventFlagMap::const_iterator it = m_map_lEventFlag.find(flag);
+			if ((it != m_map_lEventFlag.end() && it->second == val) == false)
+			{
+				TPacketSetEventFlag p;
+				std::strcpy(p.szFlagName, flag);
+				p.lValue = val;
+				SetEventFlag(&p);
+			}
+		};
+
+	SendFlag("eclipse", GetDayMode(tm_buf.tm_hour));
+	BOOL Winter = IsWinter(tm_buf.tm_mon);
+	for (const auto& Flag : { "xmas_snow" })
+		SendFlag(Flag, Winter);
+}
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+void CClientManager::QUERY_EMOTE_LOAD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
+{
+	if (pTable == nullptr)
+		return;
+
+	TEmoteTableVector* pVec = nullptr;
+	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
+	if (it != m_map_kPlayerEmote.end())
+		pVec = &it->second;
+
+	if (pVec && !pVec->empty())
+	{
+		const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
+		pVec->erase(std::remove_if(pVec->begin(), pVec->end(),
+			[dwCurrentTime](const TPacketGDEmote& rkTable)
+			{
+				return dwCurrentTime > rkTable.dwDuration;
+			}
+		), pVec->end());
+	}
+
+	const WORD wSize = pVec ? static_cast<WORD>(pVec->size()) : 0;
+	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(TPacketGDEmote) * wSize;
+
+	pkPeer->EncodeHeader(HEADER_DG_EMOTE_LOAD, dwHandle, dwPacketSize);
+	pkPeer->EncodeWORD(sizeof(TPacketGDEmote));
+	pkPeer->EncodeWORD(wSize);
+	if (pVec && !pVec->empty())
+		pkPeer->Encode(&(*pVec)[0], sizeof(TPacketGDEmote) * wSize);
+}
+
+void CClientManager::QUERY_EMOTE_CLEAR(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
+{
+	if (pTable == nullptr)
+		return;
+
+	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
+	if (it != m_map_kPlayerEmote.end())
+		it->second.clear();
+
+	QUERY_EMOTE_LOAD(pkPeer, dwHandle, pTable);
+}
+
+void CClientManager::QUERY_EMOTE_ADD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
+{
+	if (!pkPeer || !pTable)
+		return;
+
+	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
+
+	TPacketGDEmote GDPacket;
+	GDPacket.dwPID = pTable->dwPID;
+	GDPacket.dwVnum = pTable->dwVnum;
+	GDPacket.dwDuration = dwCurrentTime + pTable->dwDuration;
+
+	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
+	if (it != m_map_kPlayerEmote.end())
+	{
+		TEmoteTableVector& rkVec = it->second;
+		if (rkVec.size() >= SPECIAL_ACTION_SLOT_COUNT)
+		{
+			TPacketGDEmote& rkTable = rkVec[number(0, rkVec.size() - 1)];
+			if (dwCurrentTime >= rkTable.dwDuration)
+				rkTable.dwDuration = dwCurrentTime + pTable->dwDuration;
+			else
+				rkTable.dwDuration += pTable->dwDuration;
+
+			GDPacket.dwVnum = rkTable.dwVnum;
+			GDPacket.dwDuration = rkTable.dwDuration;
+		}
+		else
+		{
+			TEmoteTableVector::iterator itVec = std::find_if(rkVec.begin(), rkVec.end(),
+				[pTable](const TPacketGDEmote& rkTable)
+				{
+					return rkTable.dwVnum == pTable->dwVnum;
+				});
+
+			if (itVec != rkVec.end())
+			{
+				if (dwCurrentTime >= itVec->dwDuration)
+					itVec->dwDuration = dwCurrentTime + pTable->dwDuration;
+				else
+					itVec->dwDuration += pTable->dwDuration;
+
+				GDPacket.dwDuration = itVec->dwDuration;
+			}
+			else
+			{
+				pTable->dwDuration = GDPacket.dwDuration;
+				rkVec.emplace_back(*pTable);
+			}
+		}
+	}
+	else
+	{
+		pTable->dwDuration = GDPacket.dwDuration;
+		m_map_kPlayerEmote[pTable->dwPID].emplace_back(*pTable);
+	}
+
+	pkPeer->EncodeHeader(HEADER_DG_EMOTE_GET, dwHandle, sizeof(GDPacket));
+	pkPeer->Encode(&GDPacket, sizeof(GDPacket));
+}
+
+void CClientManager::QUERY_EMOTE_DUMP()
+{
+	CDBManager::instance().DirectQuery("TRUNCATE TABLE `player`.`emotions`");
+
+	if (m_map_kPlayerEmote.empty())
+		return;
+
+	char szQuery[1024];
+	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
+
+	for (TPlayerEmoteMap::value_type& it : m_map_kPlayerEmote)
+	{
+		TEmoteTableVector& rkVec = it.second;
+		if (rkVec.empty())
+			continue;
+
+		rkVec.erase(std::remove_if(rkVec.begin(), rkVec.end(),
+			[dwCurrentTime](const TPacketGDEmote& rkTable)
+			{
+				return dwCurrentTime > rkTable.dwDuration;
+			}
+		), rkVec.end());
+
+		for (const TPacketGDEmote& rkTable : rkVec)
+		{
+			snprintf(szQuery, sizeof(szQuery),
+				"REPLACE INTO emotions%s (`pid`, `vnum`, `duration`) VALUES(%d, %d, FROM_UNIXTIME(%d))",
+				GetTablePostfix(), rkTable.dwPID, rkTable.dwVnum, rkTable.dwDuration
+			);
+
+			std::unique_ptr<SQLMsg> pkInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+}
+#endif
+
+#if defined(__MAILBOX__)
+void CClientManager::QUERY_MAILBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	if (g_log)
+		sys_log(0, "QUERY_MAILBOX (handle: %d ch: %s)", dwHandle, p->szName);
+
+	std::vector<SMailBoxTable>* vec = nullptr;
+	auto it = m_map_mailbox.find(p->szName);
+	if (it != m_map_mailbox.end())
+		vec = &it->second;
+
+	if (vec)
+	{
+		const time_t now = std::time(nullptr);
+
+		vec->erase(std::remove_if(vec->begin(), vec->end(),
+			[now](const TMailBoxTable& mail)
+			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
+		), vec->end());
+
+		std::sort(vec->begin(), vec->end(),
+			[](const TMailBoxTable& l, const TMailBoxTable& r)
+			{
+				return l.Message.SendTime > r.Message.SendTime;
+			});
+	}
+
+	const WORD size = vec ? static_cast<WORD>(vec->size()) : 0;
+	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(SMailBoxTable) * size;
+
+	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_LOAD, dwHandle, dwPacketSize);
+	pkPeer->EncodeWORD(sizeof(SMailBoxTable));
+	pkPeer->EncodeWORD(size);
+
+	if (vec && vec->empty() == false)
+		pkPeer->Encode(&(*vec)[0], sizeof(SMailBoxTable) * size);
+}
+
+void CClientManager::QUERY_MAILBOX_CHECK_NAME(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	TMailBox t;
+	std::memcpy(t.szName, "", sizeof(t.szName));
+	t.Index = 0; // Index: Mail Count
+
+	static std::unordered_set<std::string> NameSet;
+	bool bFound = NameSet.find(p->szName) != NameSet.end();
+
+	if (bFound == false)
+	{
+		char s_szQuery[128];
+		//snprintf(s_szQuery, sizeof(s_szQuery), "SELECT * FROM player%s WHERE `name` = '%s' LIMIT 1", GetTablePostfix(), p->szName);
+		snprintf(s_szQuery, sizeof(s_szQuery), "SELECT * FROM player%s WHERE `name` = convert('%s' using utf8mb4) collate utf8mb4_bin LIMIT 1", GetTablePostfix(), p->szName);
+		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(s_szQuery));
+		bFound = pMsg->Get()->uiNumRows > 0;
+	}
+
+	if (bFound)
+	{
+		NameSet.emplace(p->szName); // player exists, next time we will use this to avoid using mysql.
+		std::memcpy(t.szName, p->szName, sizeof(t.szName));
+		auto it = m_map_mailbox.find(p->szName);
+		if (it != m_map_mailbox.end())
+		{
+			const time_t now = time(nullptr);
+			for (const SMailBoxTable& mail : it->second)
+			{
+				if (mail.bIsDeleted)
+					continue;
+
+				if (std::difftime(mail.Message.DeleteTime, now) <= 0)
+					continue;
+
+				t.Index++;
+			}
+		}
+	}
+
+	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_CHECK_NAME, dwHandle, sizeof(TMailBox));
+	pkPeer->Encode(&t, sizeof(TMailBox));
+}
+
+void CClientManager::QUERY_MAILBOX_WRITE(CPeer* pkPeer, DWORD dwHandle, TMailBoxTable* p)
+{
+	m_map_mailbox[p->szName].emplace_back(*p);
+}
+
+bool CClientManager::GET_MAIL(const char* name, const BYTE index, SMailBoxTable** mail)
+{
+	auto it = m_map_mailbox.find(name);
+	if (it == m_map_mailbox.end())
+		return false;
+
+	MailVec& mailvec = it->second;
+	if (index >= mailvec.size())
+		return false;
+
+	*mail = &mailvec.at(index);
+	return true;
+}
+
+void CClientManager::QUERY_MAILBOX_DELETE(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	SMailBoxTable* mail = nullptr;
+	if (GET_MAIL(p->szName, p->Index, &mail) == false)
+		return;
+
+	mail->bIsDeleted = true;
+}
+
+void CClientManager::QUERY_MAILBOX_CONFIRM(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	SMailBoxTable* mail = nullptr;
+	if (GET_MAIL(p->szName, p->Index, &mail) == false)
+		return;
+
+	mail->Message.bIsConfirm = true;
+}
+
+void CClientManager::QUERY_MAILBOX_GET(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	SMailBoxTable* mail = nullptr;
+	if (GET_MAIL(p->szName, p->Index, &mail) == false)
+		return;
+
+	mail->AddData.iYang = 0;
+	mail->AddData.iWon = 0;
+	mail->Message.bIsItemExist = false;
+	mail->Message.bIsConfirm = true;
+	mail->AddData.dwItemVnum = 0;
+	mail->AddData.dwItemCount = 0;
+	memset(mail->AddData.alSockets, 0, sizeof(mail->AddData.alSockets));
+	memset(mail->AddData.aAttr, 0, sizeof(mail->AddData.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	mail->AddData.dwChangeLookVnum = 0;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	memset(&mail->AddData.RefineElement, 0, sizeof(mail->AddData.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	memset(mail->AddData.aApplyRandom, 0, sizeof(mail->AddData.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+	mail->AddData.bSetValue = 0;
+#endif
+}
+
+void CClientManager::QUERY_MAILBOX_UNREAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	auto it = m_map_mailbox.find(p->szName);
+	if (it == m_map_mailbox.end())
+		return;
+
+	const MailVec& mailvec = it->second;
+	if (mailvec.empty())
+		return;
+
+	const time_t now = time(nullptr);
+	TMailBoxRespondUnreadData t;
+
+	for (const SMailBoxTable& mail : it->second)
+	{
+		if (mail.bIsDeleted)
+			continue;
+
+		if (mail.Message.bIsConfirm)
+			continue;
+
+		if (std::difftime(mail.Message.DeleteTime, now) <= 0)
+			continue;
+
+		if (mail.Message.bIsGMPost)
+			t.bGMVisible = true;
+
+		if (mail.Message.bIsItemExist)
+			t.bItemMessageCount++;
+		else
+			t.bCommonMessageCount++;
+	}
+
+	if ((t.bItemMessageCount + t.bCommonMessageCount) < 1)
+		return;
+
+	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_UNREAD, dwHandle, sizeof(TMailBoxRespondUnreadData));
+	pkPeer->Encode(&t, sizeof(TMailBoxRespondUnreadData));
+}
+
+void CClientManager::MAILBOX_BACKUP()
+{
+	CDBManager::instance().DirectQuery("TRUNCATE TABLE player.mailbox");
+
+	if (m_map_mailbox.empty())
+		return;
+
+	char szQuery[QUERY_MAX_LEN];
+	const time_t now = std::time(nullptr);
+
+	for (auto& p : m_map_mailbox)
+	{
+		auto& mailvec = p.second;
+		if (mailvec.empty())
+			continue;
+
+		mailvec.erase(std::remove_if(mailvec.begin(), mailvec.end(),
+			[now](const TMailBoxTable& mail)
+			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
+		), mailvec.end());
+
+		std::sort(mailvec.begin(), mailvec.end(),
+			[](const TMailBoxTable& l, const TMailBoxTable& r)
+			{
+				return l.Message.SendTime > r.Message.SendTime;
+			});
+
+		for (const auto& mail : mailvec)
+		{
+			snprintf(szQuery, sizeof(szQuery),
+				"INSERT INTO `mailbox%s` (`name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`"
+				", `gold`, `won`, `vnum`, `count`"
+				", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+				", `socket3`, `socket4`, `socket5`"
+#endif
+				", `attrtype0`, `attrvalue0`"
+				", `attrtype1`, `attrvalue1`"
+				", `attrtype2`, `attrvalue2`"
+				", `attrtype3`, `attrvalue3`"
+				", `attrtype4`, `attrvalue4`"
+				", `attrtype5`, `attrvalue5`"
+				", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				", `changelookvnum`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				", `refine_element_apply_type`"
+				", `refine_element_grade`"
+				", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+				", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+				", `apply_type0`, `apply_value0`, `apply_path0`"
+				", `apply_type1`, `apply_value1`, `apply_path1`"
+				", `apply_type2`, `apply_value2`, `apply_path2`"
+				", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+				", `set_value`"
+#endif
+				") VALUES ('%s', '%s', '%s', '%s', %d, %d, %d, %d" // `name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`
+				", %u, %u, %u, %u" // `gold`, `won`, `vnum`, `count`
+				", %ld, %ld, %ld" // `socket0`, `socket1`, `socket2`
+#if defined(__ITEM_SOCKET6__)
+				", %ld, %ld, %ld" // `socket3`, `socket4`, `socket5`
+#endif
+				", %u, %ld" // `attrtype0`, `attrvalue0`
+				", %u, %ld" // `attrtype1`, `attrvalue1`
+				", %u, %ld" // `attrtype2`, `attrvalue2`
+				", %u, %ld" // `attrtype3`, `attrvalue3`
+				", %u, %ld" // `attrtype4`, `attrvalue4`
+				", %u, %ld" // `attrtype5`, `attrvalue5`
+				", %u, %ld" // `attrtype6`, `attrvalue6`
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				", %u" // `changelookvnum`
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				", %u" // `refine_element_apply_type`
+				", %u" // `refine_element_grade`
+				", %u, %u, %u" // `refine_element_value0`, `refine_element_value1`, `refine_element_value2`
+				", %u, %u, %u" // `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+				", %u, %ld, %d" // `apply_type0`, `apply_value0`, `apply_path0`
+				", %u, %ld, %d" // `apply_type1`, `apply_value1`, `apply_path1`
+				", %u, %ld, %d" // `apply_type2`, `apply_value2`, `apply_path2`
+				", %u, %ld, %d" // `apply_type3`, `apply_value3`, `apply_path3`
+#endif
+#if defined(__SET_ITEM__)
+				", %d" // `set_value`
+#endif
+				")", GetTablePostfix()
+				, mail.szName
+				, mail.AddData.szFrom
+				, mail.Message.szTitle
+				, mail.AddData.szMessage
+				, mail.Message.bIsGMPost
+				, mail.Message.bIsConfirm
+				, mail.Message.SendTime
+				, mail.Message.DeleteTime
+				, mail.AddData.iYang
+				, mail.AddData.iWon
+				, mail.AddData.dwItemVnum
+				, mail.AddData.dwItemCount
+				, mail.AddData.alSockets[0], mail.AddData.alSockets[1], mail.AddData.alSockets[2]
+#if defined(__ITEM_SOCKET6__)
+				, mail.AddData.alSockets[3], mail.AddData.alSockets[4], mail.AddData.alSockets[5]
+#endif
+				, mail.AddData.aAttr[0].wType, mail.AddData.aAttr[0].lValue
+				, mail.AddData.aAttr[1].wType, mail.AddData.aAttr[1].lValue
+				, mail.AddData.aAttr[2].wType, mail.AddData.aAttr[2].lValue
+				, mail.AddData.aAttr[3].wType, mail.AddData.aAttr[3].lValue
+				, mail.AddData.aAttr[4].wType, mail.AddData.aAttr[4].lValue
+				, mail.AddData.aAttr[5].wType, mail.AddData.aAttr[5].lValue
+				, mail.AddData.aAttr[6].wType, mail.AddData.aAttr[6].lValue
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				, mail.AddData.dwChangeLookVnum
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				, mail.AddData.RefineElement.wApplyType
+				, mail.AddData.RefineElement.bGrade
+				, mail.AddData.RefineElement.abValue[0], mail.AddData.RefineElement.abValue[1], mail.AddData.RefineElement.abValue[2]
+				, mail.AddData.RefineElement.abBonusValue[0], mail.AddData.RefineElement.abBonusValue[1], mail.AddData.RefineElement.abBonusValue[2]
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+				, mail.AddData.aApplyRandom[0].wType, mail.AddData.aApplyRandom[0].lValue, mail.AddData.aApplyRandom[0].bPath
+				, mail.AddData.aApplyRandom[1].wType, mail.AddData.aApplyRandom[1].lValue, mail.AddData.aApplyRandom[1].bPath
+				, mail.AddData.aApplyRandom[2].wType, mail.AddData.aApplyRandom[2].lValue, mail.AddData.aApplyRandom[2].bPath
+				, mail.AddData.aApplyRandom[3].wType, mail.AddData.aApplyRandom[3].lValue, mail.AddData.aApplyRandom[3].bPath
+#endif
+#if defined(__SET_ITEM__)
+				, mail.AddData.bSetValue
+#endif
+			);
+
+			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+}
+#endif
+
+#if defined(__GEM_SHOP__)
+void CClientManager::LoadGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopLoad* pTable, bool bUpdate)
+{
+	if (g_log)
+		sys_log(0, "LoadGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
+
+	TGemShopTable GemShopTable = {};
+#	if defined(__CONQUEROR_LEVEL__)
+	GemShopTable.bSpecial = pTable->bSpecial;
+	if (GemShopTable.bSpecial)
+	{
+		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
+		if (it != m_mapGemShopSpecialTable.end())
+			GemShopTable = it->second;
+	}
+	else
+#	endif
+	{
+		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
+		if (it != m_mapGemShopTable.end())
+			GemShopTable = it->second;
+	}
+
+	pPeer->EncodeHeader(bUpdate ? HEADER_DG_GEM_SHOP_UPDATE : HEADER_DG_GEM_SHOP_LOAD, dwHandle, sizeof(GemShopTable));
+	pPeer->Encode(&GemShopTable, sizeof(GemShopTable));
+}
+
+void CClientManager::UpdateGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopTable* pTable)
+{
+	if (g_log)
+		sys_log(0, "UpdateGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
+
+#	if defined(__CONQUEROR_LEVEL__)
+	if (pTable->bSpecial)
+	{
+		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
+		if (it != m_mapGemShopSpecialTable.end())
+			it->second = *pTable;
+		else
+			m_mapGemShopSpecialTable.emplace(std::make_pair(pTable->dwPID, *pTable));
+	}
+	else
+#	endif
+	{
+		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
+		if (it != m_mapGemShopTable.end())
+			it->second = *pTable;
+		else
+			m_mapGemShopTable.emplace(std::make_pair(pTable->dwPID, *pTable));
+	}
+
+	// NOTE : Request Gem Shop Load
+	TGemShopLoad Packet;
+	Packet.dwPID = pTable->dwPID;
+#	if defined(__CONQUEROR_LEVEL__)
+	Packet.bSpecial = pTable->bSpecial;
+#	endif
+	LoadGemShop(pPeer, dwHandle, &Packet, true);
+}
+
+void CClientManager::FlushGemShop()
+{
+	// Flush Default Gem Shop Table
+	{
+		if (m_mapGemShopTable.empty())
+			return;
+
+		char szQuery[1024] = {};
+		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop%s`", GetTablePostfix());
+		CDBManager::instance().DirectQuery(szQuery);
+
+		GemShopTableMap::iterator it = m_mapGemShopTable.begin();
+		for (; it != m_mapGemShopTable.end(); ++it)
+		{
+			TGemShopTable GemShopTable = it->second;
+			if (it->first != GemShopTable.dwPID)
+				continue;
+
+			char szColumns[1024] = {};
+			char szValues[1024] = {};
+
+			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
+			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
+
+			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
+			{
+				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
+					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
+				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
+					GemShopTable.GemShopItem[bSlotIndex].bEnable,
+					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
+					GemShopTable.GemShopItem[bSlotIndex].bCount,
+					GemShopTable.GemShopItem[bSlotIndex].dwPrice
+				);
+			}
+
+			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop%s` (%s) VALUES(%s)",
+				GetTablePostfix(), szColumns, szValues);
+
+			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+
+#	if defined(__CONQUEROR_LEVEL__)
+	// Flush Port (Special) Gem Shop Table
+	{
+		if (m_mapGemShopSpecialTable.empty())
+			return;
+
+		char szQuery[1024] = {};
+		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop_port%s`", GetTablePostfix());
+		CDBManager::instance().DirectQuery(szQuery);
+
+		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.begin();
+		for (; it != m_mapGemShopSpecialTable.end(); ++it)
+		{
+			TGemShopTable GemShopTable = it->second;
+			if (it->first != GemShopTable.dwPID)
+				continue;
+
+			char szColumns[1024] = {};
+			char szValues[1024] = {};
+
+			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
+			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
+
+			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
+			{
+				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
+					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
+				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
+					GemShopTable.GemShopItem[bSlotIndex].bEnable,
+					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
+					GemShopTable.GemShopItem[bSlotIndex].bCount,
+					GemShopTable.GemShopItem[bSlotIndex].dwPrice
+				);
+			}
+
+			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop_port%s` (%s) VALUES(%s)",
+				GetTablePostfix(), szColumns, szValues);
+
+			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+#	endif
+}
+#endif
+
+#ifdef __OFFLINE_SHOP__
+void CClientManager::InitializeNextOfflineShopId()
+{
+	std::stringstream query;
+	query << "SELECT MAX(id) + 1 FROM offline_shop" << GetTablePostfix();
+
+	std::unique_ptr<SQLMsg> msg(CDBManager::Instance().DirectQuery(query.str().c_str()));
+	if (msg && msg->Get()->uiNumRows > 0) {
+		auto row = mysql_fetch_row(msg->Get()->pSQLResult);
+		str_to_number(nextOfflineShopId_, row[0]);
+	}
+	else {
+		nextOfflineShopId_ = 1;
+	}
+
+	sys_log(0, "Next offline shop id: %u", nextOfflineShopId_);
+}
+
+void CClientManager::RequestOfflineShopId(CPeer* peer, uint32_t queueId)
+{
+	peer->EncodeHeader(HEADER_DG_RESPOND_OFFLINE_SHOP_ID, 0, sizeof(uint32_t) + sizeof(uint32_t));
+	peer->Encode(&queueId, sizeof(uint32_t));
+	peer->Encode(&nextOfflineShopId_, sizeof(uint32_t));
+
+	nextOfflineShopId_++;
+}
+
+void CClientManager::SaveOfflineShop(const TOfflineShop& data, bool skipQuery)
+{
+	auto it = offlineShopCache_.find(data.id);
+	if (it != offlineShopCache_.end()) {
+		it->second->Put(&data);
+	}
+	else {
+		auto cache = std::unique_ptr<COfflineShopCache>(new COfflineShopCache());
+		cache->Put(&data, skipQuery);
+
+		offlineShopCache_.insert(std::make_pair(data.id, std::move(cache)));
+	}
+}
+
+void CClientManager::SaveOfflineShopItem(const TOfflineShopItem& data, bool skipQuery)
+{
+	auto it = offlineShopItemCache_.find(data.id);
+	if (it != offlineShopItemCache_.end()) {
+		it->second->Put(&data);
+	}
+	else {
+		auto cache = std::unique_ptr<COfflineShopItemCache>(new COfflineShopItemCache());
+		cache->Put(&data, skipQuery);
+
+		offlineShopItemCache_.insert(std::make_pair(data.id, std::move(cache)));
+	}
+}
+
+void CClientManager::DestroyOfflineShop(uint32_t id)
+{
+	auto it = offlineShopCache_.find(id);
+	if (it != offlineShopCache_.end()) {
+		offlineShopCache_.erase(it);
+	}
+
+	std::pair<uint32_t, uint16_t> key = { id, 0 };
+	for (uint16_t i = 0; i < OFFLINE_SHOP_ITEM_COUNT; ++i) {
+		key.second = i;
+
+		auto it = offlineShopItemCache_.find(key);
+		if (it != offlineShopItemCache_.end()) {
+			offlineShopItemCache_.erase(it);
+		}
+	}
+
+	std::stringstream queryDeleteOfflineShop;
+	queryDeleteOfflineShop << "DELETE FROM offline_shop" << GetTablePostfix() << " WHERE id = " << id;
+	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShop.str().c_str());
+
+	std::stringstream queryDeleteOfflineShopItems;
+	queryDeleteOfflineShopItems << "DELETE FROM offline_shop_item" << GetTablePostfix() << " WHERE owner_pid = " << id;
+	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShopItems.str().c_str());
+}
+
+void CClientManager::UpdateOfflineShopCache()
+{
+	auto it = offlineShopCache_.begin();
+	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopCache_.end()) {
+		if (it->second->CheckFlushTimeout()) {
+			it->second->Flush();
+
+			m_iCacheFlushCount++;
+		}
+
+		it++;
+	}
+}
+
+void CClientManager::UpdateOfflineShopItemCache()
+{
+	auto it = offlineShopItemCache_.begin();
+	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopItemCache_.end()) {
+		if (it->second->CheckFlushTimeout()) {
+			it->second->Flush();
+
+			m_iCacheFlushCount++;
+		}
+
+		it++;
+	}
+}
+
+void CClientManager::FlushOfflineShops()
+{
+	for (auto it = offlineShopCache_.begin(); it != offlineShopCache_.end(); ++it) {
+		it->second->Flush();
+	}
+
+	for (auto it = offlineShopItemCache_.begin(); it != offlineShopItemCache_.end(); ++it) {
+		it->second->Flush();
+	}
+}
+
+const TItemTable* CClientManager::GetItemTable(DWORD vnum) const
+{
+	auto it = m_map_itemTableByVnum.find(vnum);
+	if (it == m_map_itemTableByVnum.end())
+	{
+		return NULL;
+	}
+
+	return it->second;
+}
+
+BYTE CClientManager::GetRealItemType(DWORD vnum)
+{
+	if (vnum >= 110000 && vnum <= 165499)
+		return ITEM_DS;
+	
+	
+	/* SHIT :
+	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
+	{
+		if (it->second->dwVnum == vnum)
+		{
+			return it->second->bType;
+		}
+	}
+	*/
+	
+	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
+	{
+		if (it->dwVnum == vnum)
+		{
+			return it->bType;
+		}
+	}
+	
+	return ITEM_NONE;
+}
+
+BYTE CClientManager::GetRealItemSubType(DWORD vnum)
+{
+	/* SHIT:
+	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
+	{
+		if (it->second->dwVnum == vnum)
+		{
+			return it->second->bSubType;
+		}
+	}
+	*/
+	
+	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
+	{
+		if (it->dwVnum == vnum)
+		{
+			return it->bSubType;
+		}
+	}
+	
+	return 0;
+}
+
+void CClientManager::GetRealItemLimit(DWORD vnum, int & limitType, DWORD & limitValue)
+{
+	/* BUGGED SHIT :
+	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
+	{
+		if (it->second->dwVnum == vnum)
+		{
+			limitType = it->second->aLimits[0].bType;
+			limitValue = it->second->aLimits[0].lValue;
+			return;
+		}
+	}
+	*/
+	
+	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
+	{
+		if (it->dwVnum == vnum)
+		{
+			limitType = it->aLimits[0].bType;
+			limitValue = it->aLimits[0].lValue;
+			return;
+		}
+	}
+}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+CClientManager::TGrowthPetCacheSet* CClientManager::GetGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+		return nullptr;
+
+	return it->second;
+}
+
+void CClientManager::CreateGrowthPetCacheSet(DWORD pid)
+{
+	if (m_map_pkGrowthPetCacheSetPtr.find(pid) != m_map_pkGrowthPetCacheSetPtr.end())
+		return;
+				 
+	TGrowthPetCacheSet* pSet = new TGrowthPetCacheSet;
+	m_map_pkGrowthPetCacheSetPtr.insert(TGrowthPetCacheSetPtrMap::value_type(pid, pSet));
+
+	if (g_log)
+		sys_log(0, "GROWTH_PET_CACHE: new cache %u", pid);
+}
+
+void CClientManager::FlushGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : No GrowthPetCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TGrowthPetCacheSet* pSet = it->second;
+	auto it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CGrowthPetCache* c = *it_set++;
+		c->Flush();
+
+		m_map_growthPetCache.erase(c->Get()->dwID);
+		delete c;
+	}
+
+	pSet->clear();
+	delete pSet;
+
+	m_map_pkGrowthPetCacheSetPtr.erase(it);
+
+	if (g_log)
+		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : Deleted pid(%d)", pid);
+}
+
+CGrowthPetCache* CClientManager::GetGrowthPetCache(DWORD id)
+{
+	auto it = m_map_growthPetCache.find(id);
+
+	if (it == m_map_growthPetCache.end())
+		return nullptr;
+
+	return it->second;
+}
+
+void CClientManager::PutGrowthPetCache(TGrowthPet* pNew, bool bSkipQuery)
+{
+	CGrowthPetCache* c;
+
+	c = GetGrowthPetCache(pNew->dwID);
+	if (!c)
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> New CGrowthPetCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
+
+		c = new CGrowthPetCache;
+		m_map_growthPetCache.insert(TGrowthPetCacheMap::value_type(pNew->dwID, c));
+	}
+	else
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> Have Cache");
+		if (pNew->dwOwner != c->Get()->dwOwner)
+		{
+			auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
+
+			if (it != m_map_pkGrowthPetCacheSetPtr.end())
+			{
+				if (g_log)
+					sys_log(0, "GROWTH_PET_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
+				it->second->erase(c);
+			}
+		}
+	}
+	c->Put(pNew, bSkipQuery);
+
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
+
+	if (it != m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		it->second->insert(c);
+	}
+	else
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+
+		c->OnFlush();
+	}
+}
+
+bool CClientManager::DeleteGrowthPetCache(DWORD dwID)
+{
+	CGrowthPetCache* c = GetGrowthPetCache(dwID);
+
+	if (!c)
+		return false;
+
+	c->Delete();
+	return true;
+}
+
+void CClientManager::UpdateGrowthPetCache()
+{
+	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+		return;
+
+	auto it = m_map_growthPetCache.begin();
+
+	while (it != m_map_growthPetCache.end())
+	{
+		CGrowthPetCache* c = (it++)->second;
+
+		if (c->CheckFlushTimeout())
+		{
+			if (g_test_server)
+				sys_log(0, "UpdateGrowthPetCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
+
+			c->Flush();
+
+			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+				break;
+		}
+	}
+}
+
+void CClientManager::UpdateGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		if (g_test_server)
+			sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet ==> No GrowthPetCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TGrowthPetCacheSet* pSet = it->second;
+	auto it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CGrowthPetCache* c = *it_set++;
+		c->Flush();
+	}
+
+	if (g_log)
+		sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet pid(%d)", pid);
+}
+
+void CClientManager::QUERY_GROWTH_PET_SAVE(CPeer* pkPeer, const char* c_pData)
+{
+	TGrowthPet* p = (TGrowthPet*)c_pData;
+	if (g_test_server)
+		sys_log(0, "QUERY_GROWTH_PET_SAVE => PutGrowthPetCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
+
+	PutGrowthPetCache(p);
+}
+
+void CClientManager::QUERY_GROWTH_PET_DELETE(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwID = *(DWORD*)c_pData;
+	c_pData += sizeof(DWORD);
+
+	DWORD dwPID = *(DWORD*)c_pData;
+
+	if (!DeleteGrowthPetCache(dwID))
+	{
+		char szQuery[64];
+		snprintf(szQuery, sizeof(szQuery), "DELETE FROM growth_pet%s WHERE id=%u", GetTablePostfix(), dwID);
+
+		if (dwPID == 0)
+			CDBManager::instance().AsyncQuery(szQuery);
+		else
+			CDBManager::instance().ReturnQuery(szQuery, QID_GROWTH_PET_DELETE, pkPeer->GetHandle(), NULL);
+	}
+}
+
+bool CClientManager::CreateGrowthPetTableFromRes(MYSQL_RES* res, std::vector<TGrowthPet>* pVec, DWORD dwPID)
+{
+	if (!res)
+	{
+		pVec->clear();
+		return true;
+	}
+
+	int rows;
+
+	if ((rows = mysql_num_rows(res)) <= 0)
+	{
+		pVec->clear();
+		return true;
+	}
+
+	pVec->resize(rows);
+
+	for (int i = 0; i < rows; ++i)
+	{
+		MYSQL_ROW row = mysql_fetch_row(res);
+		TGrowthPet& pet = pVec->at(i);
+
+		int cur = 0;
+
+		str_to_number(pet.dwID, row[cur++]);
+		str_to_number(pet.dwVnum, row[cur++]);
+		str_to_number(pet.bState, row[cur++]);
+		strlcpy(pet.szName, row[cur++], sizeof(pet.szName));
+		str_to_number(pet.bSize, row[cur++]);
+		str_to_number(pet.dwLevel, row[cur++]);
+		str_to_number(pet.bLevelStep, row[cur++]);
+		str_to_number(pet.bEvolution, row[cur++]);
+		str_to_number(pet.bType, row[cur++]);
+		str_to_number(pet.dwHP, row[cur++]);
+		str_to_number(pet.dwSP, row[cur++]);
+		str_to_number(pet.dwDef, row[cur++]);
+		str_to_number(pet.dwHPApply, row[cur++]);
+		str_to_number(pet.dwSPApply, row[cur++]);
+		str_to_number(pet.dwDefApply, row[cur++]);
+		str_to_number(pet.dwAgeApply, row[cur++]);
+		thecore_memcpy(pet.aSkill, row[cur++], sizeof(pet.aSkill));
+		str_to_number(pet.lExp, row[cur++]);
+		str_to_number(pet.lItemExp, row[cur++]);
+		str_to_number(pet.lBirthday, row[cur++]);
+		str_to_number(pet.lEndTime, row[cur++]);
+		str_to_number(pet.lMaxTime, row[cur++]);
+
+		pet.dwOwner = dwPID;
+	}
+
+	return true;
+}
+
+void CClientManager::RESULT_GROWTH_PET_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID)
+{
+	static std::vector<TGrowthPet> s_petVec;
+	CreateGrowthPetTableFromRes(pRes, &s_petVec, dwPID);
+	DWORD dwCount = s_petVec.size();
+
+	peer->EncodeHeader(HEADER_DG_GROWTH_PET_LOAD, dwHandle, sizeof(DWORD) + sizeof(TGrowthPet) * dwCount);
+	peer->EncodeDWORD(dwCount);
+
+	CreateGrowthPetCacheSet(dwPID);
+
+	sys_log(0, "GROWTH_PET_LOAD: count %u pid %u", dwCount, dwPID);
+
+	if (dwCount)
+	{
+		peer->Encode(&s_petVec[0], sizeof(TGrowthPet) * dwCount);
+
+		for (DWORD i = 0; i < dwCount; ++i)
+			PutGrowthPetCache(&s_petVec[i], true);
+	}
+}
+#endif
--- a/server/metin2/Source/Server/db/src/HB.cpp
+++ b/server/metin2/Source/Server/db/src/HB.cpp
@@ -1,82 +1,87 @@
-#include "stdafx.h"
-#include "HB.h"
-#include "Main.h"
-#include "DBManager.h"
-
-PlayerHB::PlayerHB()
-{
-	m_iExpireTime = 3600; // 1 hour hotbackup default.
-}
-
-PlayerHB::~PlayerHB()
-{
-}
-
-bool PlayerHB::Initialize()
-{
-	char szQuery[128];
-	snprintf(szQuery, sizeof(szQuery), "SHOW CREATE TABLE player%s", GetTablePostfix());
-
-	std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(szQuery));
-
-	if (pMsg->Get()->uiNumRows == 0)
-		return false;
-
-	MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-	m_stCreateTableQuery = row[1];
-	return true;
-}
-
-//
-// @version 05/07/05 Bang2ni - id 에 해당하는 data 가 없을 때 쿼리하고 data 를 insert 하는코드 추가.
-//
-void PlayerHB::Put(DWORD id)
-{
-	auto it = m_map_data.find(id);
-	if (it == m_map_data.end())
-	{
-		Query(id);
-		m_map_data.insert(std::pair< DWORD, time_t >(id, get_dword_time()));
-		return;
-	}
-
-	if (time(0) - it->second > m_iExpireTime)
-		Query(id);
-}
-
-//
-// @version 05/07/05 Bang2ni - Query string 버퍼가 작아서 늘려줌.
-//
-bool PlayerHB::Query(DWORD id)
-{
-	time_t ct = time(0);
-	struct tm curr_tm = *localtime(&ct);
-	char szTableName[64];
-	snprintf(szTableName, sizeof(szTableName), "hb_%02d%02d%02d%02d_player%s",
-		curr_tm.tm_year - 100, curr_tm.tm_mon + 1, curr_tm.tm_mday, curr_tm.tm_hour, GetTablePostfix());
-
-	char szQuery[4096];
-
-	if (m_stTableName.compare(szTableName))
-	{
-		char szFind[32];
-		snprintf(szFind, sizeof(szFind), "CREATE TABLE `player%s`", GetTablePostfix());
-		int pos = m_stCreateTableQuery.find(szFind);
-
-		if (pos < 0)
-		{
-			sys_err("cannot find %s ", szFind);
-			//sys_err("cannot find %s in %s", szFind, m_stCreateTableQuery.c_str());
-			return false;
-		}
-
-		snprintf(szQuery, sizeof(szQuery), "CREATE TABLE IF NOT EXISTS %s%s", szTableName, m_stCreateTableQuery.c_str() + strlen(szFind));
-		//sys_log(0, "%s", szQuery);
-		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(szQuery, SQL_HOTBACKUP));
-		m_stTableName = szTableName;
-	}
-
-	snprintf(szQuery, sizeof(szQuery), "REPLACE INTO %s SELECT * FROM %splayer%s WHERE id=%u", m_stTableName.c_str(), GetPlayerDBName(), GetTablePostfix(), id);
-	CDBManager::instance().AsyncQuery(szQuery, SQL_HOTBACKUP);
-	return true;
-}
+#include "stdafx.h"
+#include "HB.h"
+#include "Main.h"
+#include "DBManager.h"
+
+PlayerHB::PlayerHB()
+{
+	m_iExpireTime = 3600; // 1 hour hotbackup default.
+}
+
+PlayerHB::~PlayerHB()
+{
+}
+
+bool PlayerHB::Initialize()
+{
+	char szQuery[128];
+	snprintf(szQuery, sizeof(szQuery), "SHOW CREATE TABLE player%s", GetTablePostfix());
+
+	std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(szQuery));
+
+	if (pMsg->Get()->uiNumRows == 0)
+		return false;
+
+	MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+	m_stCreateTableQuery = row[1];
+	return true;
+}
+
+//
+// @version 05/07/05 Bang2ni - id  娩求 data    構 data  insert 求湄 煞.
+//
+void PlayerHB::Put(DWORD id)
+{
+	auto it = m_map_data.find(id);
+	if (it == m_map_data.end())
+	{
+		Query(id);
+		m_map_data.insert(std::pair< DWORD, time_t >(id, get_dword_time()));
+		return;
+	}
+
+	if (time(0) - it->second > m_iExpireTime)
+		Query(id);
+}
+
+//
+// @version 05/07/05 Bang2ni - Query string 方 訪티 첨.
+//
+bool PlayerHB::Query(DWORD id)
+{
+	time_t ct = time(0);
+	struct tm curr_tm;
+#if defined(_WIN32) || defined(_WIN64)
+	localtime_s(&curr_tm, &ct);
+#else
+	localtime_r(&ct, &curr_tm);
+#endif
+	char szTableName[64];
+	snprintf(szTableName, sizeof(szTableName), "hb_%02d%02d%02d%02d_player%s",
+		curr_tm.tm_year - 100, curr_tm.tm_mon + 1, curr_tm.tm_mday, curr_tm.tm_hour, GetTablePostfix());
+
+	char szQuery[4096];
+
+	if (m_stTableName.compare(szTableName))
+	{
+		char szFind[32];
+		snprintf(szFind, sizeof(szFind), "CREATE TABLE `player%s`", GetTablePostfix());
+		int pos = m_stCreateTableQuery.find(szFind);
+
+		if (pos < 0)
+		{
+			sys_err("cannot find %s ", szFind);
+			//sys_err("cannot find %s in %s", szFind, m_stCreateTableQuery.c_str());
+			return false;
+		}
+
+		snprintf(szQuery, sizeof(szQuery), "CREATE TABLE IF NOT EXISTS %s%s", szTableName, m_stCreateTableQuery.c_str() + strlen(szFind));
+		//sys_log(0, "%s", szQuery);
+		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(szQuery, SQL_HOTBACKUP));
+		m_stTableName = szTableName;
+	}
+
+	snprintf(szQuery, sizeof(szQuery), "REPLACE INTO %s SELECT * FROM %splayer%s WHERE id=%u", m_stTableName.c_str(), GetPlayerDBName(), GetTablePostfix(), id);
+	CDBManager::instance().AsyncQuery(szQuery, SQL_HOTBACKUP);
+	return true;
+}
--- a/server/metin2/Source/Server/db/src/ShopSearchManager.cpp
+++ b/server/metin2/Source/Server/db/src/ShopSearchManager.cpp
@@ -665,7 +665,13 @@
 int CShopSearchManager::GetCurrentMonthDay()
 {
 	time_t now = time(NULL);
-	return localtime(&now)->tm_mday;
+	struct tm tm_buf;
+#if defined(_WIN32) || defined(_WIN64)
+	localtime_s(&tm_buf, &now);
+#else
+	localtime_r(&now, &tm_buf);
+#endif
+	return tm_buf.tm_mday;
 }
 
 #endif
--- a/server/metin2/Source/Server/liblua/src/lib/liolib.c
+++ b/server/metin2/Source/Server/liblua/src/lib/liolib.c
@@ -1,777 +1,790 @@
-/*
-* $Id: liolib.c,v 2.39b 2003/03/19 21:16:12 roberto Exp $
-* Standard I/O (and system) library
-* See Copyright Notice in lua.h
-*/
-
-#include <errno.h>
-#include <locale.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-
-#include "lua.h"
-
-#include "lauxlib.h"
-#include "lualib.h"
-
-typedef struct FileHandle
-{
-	FILE* f;
-	int ispipe;
-} FileHandle;
-
-/*
-* by default, gcc does not get `tmpname'
-*/
-#ifndef USE_TMPNAME
-#ifdef __GNUC__
-#define USE_TMPNAME 0
-#else
-#define USE_TMPNAME 1
-#endif
-#endif
-
-/*
-* by default, posix systems get `popen'
-*/
-#ifndef USE_POPEN
-#ifdef _POSIX_C_SOURCE
-#if _POSIX_C_SOURCE >= 2
-#define USE_POPEN 1
-#endif
-#endif
-#endif
-
-#ifndef USE_POPEN
-#define USE_POPEN 0
-#endif
-
-/*
-* {======================================================
-* FILE Operations
-* =======================================================
-*/
-
-#if !USE_POPEN
-#define pclose(f) (-1)
-#endif
-
-#define FILEHANDLE "FILE*"
-
-#define IO_INPUT "_input"
-#define IO_OUTPUT "_output"
-
-static int pushresult(lua_State* L, int i, const char* filename)
-{
-	if (i)
-	{
-		lua_pushboolean(L, 1);
-		return 1;
-	}
-	else
-	{
-		lua_pushnil(L);
-		if (filename)
-			lua_pushfstring(L, "%s: %s", filename, strerror(errno));
-		else
-			lua_pushfstring(L, "%s", strerror(errno));
-		lua_pushnumber(L, errno);
-		return 3;
-	}
-}
-
-static FileHandle* topfile(lua_State* L, int findex)
-{
-	FileHandle* fh = (FileHandle*)luaL_checkudata(L, findex, FILEHANDLE);
-	if (fh == NULL) luaL_argerror(L, findex, "bad file");
-	return fh;
-}
-
-static int io_type(lua_State* L)
-{
-	FileHandle* fh = (FileHandle*)luaL_checkudata(L, 1, FILEHANDLE);
-	if (fh == NULL) lua_pushnil(L);
-	else if (fh->f == NULL)
-		lua_pushliteral(L, "closed file");
-	else
-		lua_pushliteral(L, "file");
-	return 1;
-}
-
-#define tofile(L,i) (tofileh(L,i)->f)
-
-static FileHandle* tofileh(lua_State* L, int findex)
-{
-	FileHandle* fh = topfile(L, findex);
-	if (fh->f == NULL)
-		luaL_error(L, "attempt to use a closed file");
-	return fh;
-}
-
-#define newfile(L) (&(newfileh(L)->f))
-
-/*
-* When creating file handles, always creates a `closed' file handle
-* before opening the actual file; so, if there is a memory error, the
-* file is not left opened.
-*/
-static FileHandle* newfileh(lua_State* L)
-{
-	FileHandle* fh = (FileHandle*)lua_newuserdata(L, sizeof(FileHandle));
-	fh->f = NULL; /* file handle is currently `closed' */
-	fh->ispipe = 0;
-	luaL_getmetatable(L, FILEHANDLE);
-	lua_setmetatable(L, -2);
-	return fh;
-}
-
-/*
-* assumes that top of the stack is the `io' library, and next is
-* the `io' metatable
-*/
-static void registerfile(lua_State* L, FILE* f, const char* name, const char* impname)
-{
-	lua_pushstring(L, name);
-	*newfile(L) = f;
-	if (impname)
-	{
-		lua_pushstring(L, impname);
-		lua_pushvalue(L, -2);
-		lua_settable(L, -6); /* metatable[impname] = file */
-	}
-	lua_settable(L, -3); /* io[name] = file */
-}
-
-static int aux_close(lua_State* L)
-{
-	FileHandle* fh = tofileh(L, 1);
-	FILE* f = fh->f;
-	if (f == stdin || f == stdout || f == stderr)
-		return 0; /* file cannot be closed */
-	else
-	{
-		int ok = fh->ispipe ? (pclose(f) != -1) : (fclose(f) == 0);
-		fh->f = NULL; /* mark file as closed */
-		return ok;
-	}
-}
-
-static int io_close(lua_State* L)
-{
-	if (lua_isnone(L, 1) && lua_type(L, lua_upvalueindex(1)) == LUA_TTABLE)
-	{
-		lua_pushstring(L, IO_OUTPUT);
-		lua_rawget(L, lua_upvalueindex(1));
-	}
-	return pushresult(L, aux_close(L), NULL);
-}
-
-static int io_gc(lua_State* L)
-{
-	FileHandle* fh = topfile(L, 1);
-	if (fh->f != NULL) /* ignore closed files */
-		aux_close(L);
-	return 0;
-}
-
-static int io_tostring(lua_State* L)
-{
-	char buff[128];
-	FileHandle* fh = topfile(L, 1);
-	if (fh->f == NULL)
-		strcpy(buff, "closed");
-	else
-		sprintf(buff, "%p", lua_touserdata(L, 1));
-	lua_pushfstring(L, "file (%s)", buff);
-	return 1;
-}
-
-static int io_open(lua_State* L)
-{
-	const char* filename = luaL_checkstring(L, 1);
-	const char* mode = luaL_optstring(L, 2, "r");
-	FILE** pf = newfile(L);
-	*pf = fopen(filename, mode);
-	return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
-}
-
-static int io_popen(lua_State* L)
-{
-#if !USE_POPEN
-	luaL_error(L, "`popen' not supported");
-	return 0;
-#else
-	const char* filename = luaL_checkstring(L, 1);
-	const char* mode = luaL_optstring(L, 2, "r");
-	FileHandle* fh = newfileh(L);
-	fh->f = popen(filename, mode);
-	fh->ispipe = 1;
-	return (fh->f == NULL) ? pushresult(L, 0, filename) : 1;
-#endif
-}
-
-static int io_tmpfile(lua_State* L)
-{
-	FILE** pf = newfile(L);
-	*pf = tmpfile();
-	return (*pf == NULL) ? pushresult(L, 0, NULL) : 1;
-}
-
-static FILE* getiofile(lua_State* L, const char* name)
-{
-	lua_pushstring(L, name);
-	lua_rawget(L, lua_upvalueindex(1));
-	return tofile(L, -1);
-}
-
-static int g_iofile(lua_State* L, const char* name, const char* mode)
-{
-	if (!lua_isnoneornil(L, 1))
-	{
-		const char* filename = lua_tostring(L, 1);
-		lua_pushstring(L, name);
-		if (filename)
-		{
-			FILE** pf = newfile(L);
-			*pf = fopen(filename, mode);
-			if (*pf == NULL)
-			{
-				lua_pushfstring(L, "%s: %s", filename, strerror(errno));
-				luaL_argerror(L, 1, lua_tostring(L, -1));
-			}
-		}
-		else
-		{
-			tofile(L, 1); /* check that it's a valid file handle */
-			lua_pushvalue(L, 1);
-		}
-		lua_rawset(L, lua_upvalueindex(1));
-	}
-	/* return current value */
-	lua_pushstring(L, name);
-	lua_rawget(L, lua_upvalueindex(1));
-	return 1;
-}
-
-static int io_input(lua_State* L)
-{
-	return g_iofile(L, IO_INPUT, "r");
-}
-
-static int io_output(lua_State* L)
-{
-	return g_iofile(L, IO_OUTPUT, "w");
-}
-
-static int io_readline(lua_State* L);
-
-static void aux_lines(lua_State* L, int idx, int close)
-{
-	lua_pushliteral(L, FILEHANDLE);
-	lua_rawget(L, LUA_REGISTRYINDEX);
-	lua_pushvalue(L, idx);
-	lua_pushboolean(L, close); /* close/not close file when finished */
-	lua_pushcclosure(L, io_readline, 3);
-}
-
-static int f_lines(lua_State* L)
-{
-	tofile(L, 1); /* check that it's a valid file handle */
-	aux_lines(L, 1, 0);
-	return 1;
-}
-
-static int io_lines(lua_State* L)
-{
-	if (lua_isnoneornil(L, 1))
-	{ /* no arguments? */
-		lua_pushstring(L, IO_INPUT);
-		lua_rawget(L, lua_upvalueindex(1)); /* will iterate over default input */
-		return f_lines(L);
-	}
-	else
-	{
-		const char* filename = luaL_checkstring(L, 1);
-		FILE** pf = newfile(L);
-		*pf = fopen(filename, "r");
-		luaL_argcheck(L, *pf, 1, strerror(errno));
-		aux_lines(L, lua_gettop(L), 1);
-		return 1;
-	}
-}
-
-/*
-* {======================================================
-* READ
-* =======================================================
-*/
-
-static int read_number(lua_State* L, FILE* f)
-{
-	lua_Number d;
-	if (fscanf(f, LUA_NUMBER_SCAN, &d) == 1)
-	{
-		lua_pushnumber(L, d);
-		return 1;
-	}
-	else return 0; /* read fails */
-}
-
-static int test_eof(lua_State* L, FILE* f)
-{
-	int c = getc(f);
-	ungetc(c, f);
-	lua_pushlstring(L, NULL, 0);
-	return (c != EOF);
-}
-
-static int read_line(lua_State* L, FILE* f)
-{
-	luaL_Buffer b;
-	luaL_buffinit(L, &b);
-	for (;;)
-	{
-		size_t l;
-		char* p = luaL_prepbuffer(&b);
-		if (fgets(p, LUAL_BUFFERSIZE, f) == NULL)
-		{ /* eof? */
-			luaL_pushresult(&b); /* close buffer */
-			return (lua_strlen(L, -1) > 0); /* check whether read something */
-		}
-		l = strlen(p);
-		if (p[l - 1] != '\n')
-			luaL_addsize(&b, l);
-		else
-		{
-			luaL_addsize(&b, l - 1); /* do not include `eol' */
-			luaL_pushresult(&b); /* close buffer */
-			return 1; /* read at least an `eol' */
-		}
-	}
-}
-
-static int read_chars(lua_State* L, FILE* f, size_t n)
-{
-	size_t rlen; /* how much to read */
-	size_t nr; /* number of chars actually read */
-	luaL_Buffer b;
-	luaL_buffinit(L, &b);
-	rlen = LUAL_BUFFERSIZE; /* try to read that much each time */
-	do
-	{
-		char* p = luaL_prepbuffer(&b);
-		if (rlen > n) rlen = n; /* cannot read more than asked */
-		nr = fread(p, sizeof(char), rlen, f);
-		luaL_addsize(&b, nr);
-		n -= nr; /* still have to read `n' chars */
-	} while (n > 0 && nr == rlen); /* until end of count or eof */
-	luaL_pushresult(&b); /* close buffer */
-	return (n == 0 || lua_strlen(L, -1) > 0);
-}
-
-static int g_read(lua_State* L, FILE* f, int first)
-{
-	int nargs = lua_gettop(L) - 1;
-	int success;
-	int n;
-	if (nargs == 0)
-	{ /* no arguments? */
-		success = read_line(L, f);
-		n = first + 1; /* to return 1 result */
-	}
-	else
-	{ /* ensure stack space for all results and for auxlib's buffer */
-		luaL_checkstack(L, nargs + LUA_MINSTACK, "too many arguments");
-		success = 1;
-		for (n = first; nargs-- && success; n++)
-		{
-			if (lua_type(L, n) == LUA_TNUMBER)
-			{
-				size_t l = (size_t)lua_tonumber(L, n);
-				success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
-			}
-			else
-			{
-				const char* p = lua_tostring(L, n);
-				luaL_argcheck(L, p && p[0] == '*', n, "invalid option");
-				switch (p[1])
-				{
-				case 'n': /* number */
-					success = read_number(L, f);
-					break;
-				case 'l': /* line */
-					success = read_line(L, f);
-					break;
-				case 'a': /* file */
-					read_chars(L, f, ~((size_t)0)); /* read MAX_SIZE_T chars */
-					success = 1; /* always success */
-					break;
-				case 'w': /* word */
-					return luaL_error(L, "obsolete option `*w' to `read'");
-				default:
-					return luaL_argerror(L, n, "invalid format");
-				}
-			}
-		}
-	}
-	if (!success)
-	{
-		lua_pop(L, 1); /* remove last result */
-		lua_pushnil(L); /* push nil instead */
-	}
-	return n - first;
-}
-
-static int io_read(lua_State* L)
-{
-	return g_read(L, getiofile(L, IO_INPUT), 1);
-}
-
-static int f_read(lua_State* L)
-{
-	return g_read(L, tofile(L, 1), 2);
-}
-
-static int io_readline(lua_State* L)
-{
-	FILE* f = *(FILE**)lua_touserdata(L, lua_upvalueindex(2));
-	if (f == NULL) /* file is already closed? */
-		luaL_error(L, "file is already closed");
-	if (read_line(L, f)) return 1;
-	else
-	{ /* EOF */
-		if (lua_toboolean(L, lua_upvalueindex(3)))
-		{ /* generator created file? */
-			lua_settop(L, 0);
-			lua_pushvalue(L, lua_upvalueindex(2));
-			aux_close(L); /* close it */
-		}
-		return 0;
-	}
-}
-
-/* }====================================================== */
-
-static int g_write(lua_State* L, FILE* f, int arg)
-{
-	int nargs = lua_gettop(L) - 1;
-	int status = 1;
-	for (; nargs--; arg++)
-	{
-		if (lua_type(L, arg) == LUA_TNUMBER)
-		{
-			/* optimization: could be done exactly as for strings */
-			status = status &&
-				fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
-		}
-		else
-		{
-			size_t l;
-			const char* s = luaL_checklstring(L, arg, &l);
-			status = status && (fwrite(s, sizeof(char), l, f) == l);
-		}
-	}
-	return pushresult(L, status, NULL);
-}
-
-static int io_write(lua_State* L)
-{
-	return g_write(L, getiofile(L, IO_OUTPUT), 1);
-}
-
-static int f_write(lua_State* L)
-{
-	return g_write(L, tofile(L, 1), 2);
-}
-
-static int f_seek(lua_State* L)
-{
-	static const int mode[] = { SEEK_SET, SEEK_CUR, SEEK_END };
-	static const char* const modenames[] = { "set", "cur", "end", NULL };
-	FILE* f = tofile(L, 1);
-	int op = luaL_findstring(luaL_optstring(L, 2, "cur"), modenames);
-	long offset = luaL_optlong(L, 3, 0);
-	luaL_argcheck(L, op != -1, 2, "invalid mode");
-	op = fseek(f, offset, mode[op]);
-	if (op)
-		return pushresult(L, 0, NULL); /* error */
-	else
-	{
-		lua_pushnumber(L, ftell(f));
-		return 1;
-	}
-}
-
-static int io_flush(lua_State* L)
-{
-	return pushresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
-}
-
-static int f_flush(lua_State* L)
-{
-	return pushresult(L, fflush(tofile(L, 1)) == 0, NULL);
-}
-
-static const luaL_reg iolib[] = {
-	{ "input", io_input },
-	{ "output", io_output },
-	{ "lines", io_lines },
-	{ "close", io_close },
-	{ "flush", io_flush },
-	{ "open", io_open },
-	{ "popen", io_popen },
-	{ "read", io_read },
-	{ "tmpfile", io_tmpfile },
-	{ "type", io_type },
-	{ "write", io_write },
-	{ NULL, NULL }
-};
-
-static const luaL_reg flib[] = {
-	{ "flush", f_flush },
-	{ "read", f_read },
-	{ "lines", f_lines },
-	{ "seek", f_seek },
-	{ "write", f_write },
-	{ "close", io_close },
-	{ "__gc", io_gc },
-	{ "__tostring", io_tostring },
-	{ NULL, NULL }
-};
-
-static void createmeta(lua_State* L)
-{
-	luaL_newmetatable(L, FILEHANDLE); /* create new metatable for file handles */
-	/* file methods */
-	lua_pushliteral(L, "__index");
-	lua_pushvalue(L, -2); /* push metatable */
-	lua_rawset(L, -3); /* metatable.__index = metatable */
-	luaL_openlib(L, NULL, flib, 0);
-}
-
-/* }====================================================== */
-
-/*
-* {======================================================
-* Other O.S. Operations
-* =======================================================
-*/
-
-static int io_execute(lua_State* L)
-{
-	lua_pushnumber(L, system(luaL_checkstring(L, 1)));
-	return 1;
-}
-
-static int io_remove(lua_State* L)
-{
-	const char* filename = luaL_checkstring(L, 1);
-	return pushresult(L, remove(filename) == 0, filename);
-}
-
-static int io_rename(lua_State* L)
-{
-	const char* fromname = luaL_checkstring(L, 1);
-	const char* toname = luaL_checkstring(L, 2);
-	return pushresult(L, rename(fromname, toname) == 0, fromname);
-}
-
-static int io_tmpname(lua_State* L)
-{
-#if !USE_TMPNAME
-	luaL_error(L, "`tmpname' not supported");
-	return 0;
-#else
-	char buff[L_tmpnam];
-	if (tmpnam(buff) != buff)
-		return luaL_error(L, "unable to generate a unique filename in `tmpname'");
-	lua_pushstring(L, buff);
-	return 1;
-#endif
-}
-
-static int io_getenv(lua_State* L)
-{
-	lua_pushstring(L, getenv(luaL_checkstring(L, 1))); /* if NULL push nil */
-	return 1;
-}
-
-static int io_clock(lua_State* L)
-{
-	lua_pushnumber(L, ((lua_Number)clock()) / (lua_Number)CLOCKS_PER_SEC);
-	return 1;
-}
-
-/*
-* {======================================================
-* Time/Date operations
-* { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
-* wday=%w+1, yday=%j, isdst=? }
-* =======================================================
-*/
-
-static void setfield(lua_State* L, const char* key, int value)
-{
-	lua_pushstring(L, key);
-	lua_pushnumber(L, value);
-	lua_rawset(L, -3);
-}
-
-static void setboolfield(lua_State* L, const char* key, int value)
-{
-	lua_pushstring(L, key);
-	lua_pushboolean(L, value);
-	lua_rawset(L, -3);
-}
-
-static int getboolfield(lua_State* L, const char* key)
-{
-	int res;
-	lua_pushstring(L, key);
-	lua_gettable(L, -2);
-	res = lua_toboolean(L, -1);
-	lua_pop(L, 1);
-	return res;
-}
-
-static int getfield(lua_State* L, const char* key, int d)
-{
-	int res;
-	lua_pushstring(L, key);
-	lua_gettable(L, -2);
-	if (lua_isnumber(L, -1))
-		res = (int)(lua_tonumber(L, -1));
-	else
-	{
-		if (d == -2)
-			return luaL_error(L, "field `%s' missing in date table", key);
-		res = d;
-	}
-	lua_pop(L, 1);
-	return res;
-}
-
-static int io_date(lua_State* L)
-{
-	const char* s = luaL_optstring(L, 1, "%c");
-	time_t t = (time_t)(luaL_optnumber(L, 2, -1));
-	struct tm* stm;
-	if (t == (time_t)(-1)) /* no time given? */
-		t = time(NULL); /* use current time */
-	if (*s == '!')
-	{ /* UTC? */
-		stm = gmtime(&t);
-		s++; /* skip `!' */
-	}
-	else
-		stm = localtime(&t);
-	if (stm == NULL) /* invalid date? */
-		lua_pushnil(L);
-	else if (strcmp(s, "*t") == 0)
-	{
-		lua_newtable(L);
-		setfield(L, "sec", stm->tm_sec);
-		setfield(L, "min", stm->tm_min);
-		setfield(L, "hour", stm->tm_hour);
-		setfield(L, "day", stm->tm_mday);
-		setfield(L, "month", stm->tm_mon + 1);
-		setfield(L, "year", stm->tm_year + 1900);
-		setfield(L, "wday", stm->tm_wday + 1);
-		setfield(L, "yday", stm->tm_yday + 1);
-		setboolfield(L, "isdst", stm->tm_isdst);
-	}
-	else
-	{
-		char b[256];
-		if (strftime(b, sizeof(b), s, stm))
-			lua_pushstring(L, b);
-		else
-			return luaL_error(L, "`date' format too long");
-	}
-	return 1;
-}
-
-static int io_time(lua_State* L)
-{
-	if (lua_isnoneornil(L, 1)) /* called without args? */
-		lua_pushnumber(L, time(NULL)); /* return current time */
-	else
-	{
-		time_t t;
-		struct tm ts;
-		luaL_checktype(L, 1, LUA_TTABLE);
-		lua_settop(L, 1); /* make sure table is at the top */
-		ts.tm_sec = getfield(L, "sec", 0);
-		ts.tm_min = getfield(L, "min", 0);
-		ts.tm_hour = getfield(L, "hour", 12);
-		ts.tm_mday = getfield(L, "day", -2);
-		ts.tm_mon = getfield(L, "month", -2) - 1;
-		ts.tm_year = getfield(L, "year", -2) - 1900;
-		ts.tm_isdst = getboolfield(L, "isdst");
-		t = mktime(&ts);
-		if (t == (time_t)(-1))
-			lua_pushnil(L);
-		else
-			lua_pushnumber(L, t);
-	}
-	return 1;
-}
-
-static int io_difftime(lua_State* L)
-{
-	lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
-		(time_t)(luaL_optnumber(L, 2, 0))));
-	return 1;
-}
-
-/* }====================================================== */
-
-static int io_setloc(lua_State* L)
-{
-	static const int cat[] = { LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME };
-	static const char* const catnames[] = { "all", "collate", "ctype", "monetary", "numeric", "time", NULL };
-	const char* l = lua_tostring(L, 1);
-	int op = luaL_findstring(luaL_optstring(L, 2, "all"), catnames);
-	luaL_argcheck(L, l || lua_isnoneornil(L, 1), 1, "string expected");
-	luaL_argcheck(L, op != -1, 2, "invalid option");
-	lua_pushstring(L, setlocale(cat[op], l));
-	return 1;
-}
-
-static int io_exit(lua_State* L)
-{
-	exit(luaL_optint(L, 1, EXIT_SUCCESS));
-	return 0; /* to avoid warnings */
-}
-
-static const luaL_reg syslib[] = {
-	{ "clock", io_clock },
-	{ "date", io_date },
-	{ "difftime", io_difftime },
-	{ "execute", io_execute },
-	{ "exit", io_exit },
-	{ "getenv", io_getenv },
-	{ "remove", io_remove },
-	{ "rename", io_rename },
-	{ "setlocale", io_setloc },
-	{ "time", io_time },
-	{ "tmpname", io_tmpname },
-	{ NULL, NULL}
-};
-
-/* }====================================================== */
-
-LUALIB_API int luaopen_io(lua_State* L)
-{
-	luaL_openlib(L, LUA_OSLIBNAME, syslib, 0);
-	createmeta(L);
-	lua_pushvalue(L, -1);
-	luaL_openlib(L, LUA_IOLIBNAME, iolib, 1);
-	/* put predefined file handles into `io' table */
-	registerfile(L, stdin, "stdin", IO_INPUT);
-	registerfile(L, stdout, "stdout", IO_OUTPUT);
-	registerfile(L, stderr, "stderr", NULL);
-	return 1;
-}
+/*
+* $Id: liolib.c,v 2.39b 2003/03/19 21:16:12 roberto Exp $
+* Standard I/O (and system) library
+* See Copyright Notice in lua.h
+*/
+
+#include <errno.h>
+#include <locale.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+typedef struct FileHandle
+{
+	FILE* f;
+	int ispipe;
+} FileHandle;
+
+/*
+* by default, gcc does not get `tmpname'
+*/
+#ifndef USE_TMPNAME
+#ifdef __GNUC__
+#define USE_TMPNAME 0
+#else
+#define USE_TMPNAME 1
+#endif
+#endif
+
+/*
+* by default, posix systems get `popen'
+*/
+#ifndef USE_POPEN
+#ifdef _POSIX_C_SOURCE
+#if _POSIX_C_SOURCE >= 2
+#define USE_POPEN 1
+#endif
+#endif
+#endif
+
+#ifndef USE_POPEN
+#define USE_POPEN 0
+#endif
+
+/*
+* {======================================================
+* FILE Operations
+* =======================================================
+*/
+
+#if !USE_POPEN
+#define pclose(f) (-1)
+#endif
+
+#define FILEHANDLE "FILE*"
+
+#define IO_INPUT "_input"
+#define IO_OUTPUT "_output"
+
+static int pushresult(lua_State* L, int i, const char* filename)
+{
+	if (i)
+	{
+		lua_pushboolean(L, 1);
+		return 1;
+	}
+	else
+	{
+		lua_pushnil(L);
+		if (filename)
+			lua_pushfstring(L, "%s: %s", filename, strerror(errno));
+		else
+			lua_pushfstring(L, "%s", strerror(errno));
+		lua_pushnumber(L, errno);
+		return 3;
+	}
+}
+
+static FileHandle* topfile(lua_State* L, int findex)
+{
+	FileHandle* fh = (FileHandle*)luaL_checkudata(L, findex, FILEHANDLE);
+	if (fh == NULL) luaL_argerror(L, findex, "bad file");
+	return fh;
+}
+
+static int io_type(lua_State* L)
+{
+	FileHandle* fh = (FileHandle*)luaL_checkudata(L, 1, FILEHANDLE);
+	if (fh == NULL) lua_pushnil(L);
+	else if (fh->f == NULL)
+		lua_pushliteral(L, "closed file");
+	else
+		lua_pushliteral(L, "file");
+	return 1;
+}
+
+#define tofile(L,i) (tofileh(L,i)->f)
+
+static FileHandle* tofileh(lua_State* L, int findex)
+{
+	FileHandle* fh = topfile(L, findex);
+	if (fh->f == NULL)
+		luaL_error(L, "attempt to use a closed file");
+	return fh;
+}
+
+#define newfile(L) (&(newfileh(L)->f))
+
+/*
+* When creating file handles, always creates a `closed' file handle
+* before opening the actual file; so, if there is a memory error, the
+* file is not left opened.
+*/
+static FileHandle* newfileh(lua_State* L)
+{
+	FileHandle* fh = (FileHandle*)lua_newuserdata(L, sizeof(FileHandle));
+	fh->f = NULL; /* file handle is currently `closed' */
+	fh->ispipe = 0;
+	luaL_getmetatable(L, FILEHANDLE);
+	lua_setmetatable(L, -2);
+	return fh;
+}
+
+/*
+* assumes that top of the stack is the `io' library, and next is
+* the `io' metatable
+*/
+static void registerfile(lua_State* L, FILE* f, const char* name, const char* impname)
+{
+	lua_pushstring(L, name);
+	*newfile(L) = f;
+	if (impname)
+	{
+		lua_pushstring(L, impname);
+		lua_pushvalue(L, -2);
+		lua_settable(L, -6); /* metatable[impname] = file */
+	}
+	lua_settable(L, -3); /* io[name] = file */
+}
+
+static int aux_close(lua_State* L)
+{
+	FileHandle* fh = tofileh(L, 1);
+	FILE* f = fh->f;
+	if (f == stdin || f == stdout || f == stderr)
+		return 0; /* file cannot be closed */
+	else
+	{
+		int ok = fh->ispipe ? (pclose(f) != -1) : (fclose(f) == 0);
+		fh->f = NULL; /* mark file as closed */
+		return ok;
+	}
+}
+
+static int io_close(lua_State* L)
+{
+	if (lua_isnone(L, 1) && lua_type(L, lua_upvalueindex(1)) == LUA_TTABLE)
+	{
+		lua_pushstring(L, IO_OUTPUT);
+		lua_rawget(L, lua_upvalueindex(1));
+	}
+	return pushresult(L, aux_close(L), NULL);
+}
+
+static int io_gc(lua_State* L)
+{
+	FileHandle* fh = topfile(L, 1);
+	if (fh->f != NULL) /* ignore closed files */
+		aux_close(L);
+	return 0;
+}
+
+static int io_tostring(lua_State* L)
+{
+	char buff[128];
+	FileHandle* fh = topfile(L, 1);
+	if (fh->f == NULL)
+		strcpy(buff, "closed");
+	else
+		sprintf(buff, "%p", lua_touserdata(L, 1));
+	lua_pushfstring(L, "file (%s)", buff);
+	return 1;
+}
+
+static int io_open(lua_State* L)
+{
+	const char* filename = luaL_checkstring(L, 1);
+	const char* mode = luaL_optstring(L, 2, "r");
+	FILE** pf = newfile(L);
+	*pf = fopen(filename, mode);
+	return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
+}
+
+static int io_popen(lua_State* L)
+{
+#if !USE_POPEN
+	luaL_error(L, "`popen' not supported");
+	return 0;
+#else
+	const char* filename = luaL_checkstring(L, 1);
+	const char* mode = luaL_optstring(L, 2, "r");
+	FileHandle* fh = newfileh(L);
+	fh->f = popen(filename, mode);
+	fh->ispipe = 1;
+	return (fh->f == NULL) ? pushresult(L, 0, filename) : 1;
+#endif
+}
+
+static int io_tmpfile(lua_State* L)
+{
+	FILE** pf = newfile(L);
+	*pf = tmpfile();
+	return (*pf == NULL) ? pushresult(L, 0, NULL) : 1;
+}
+
+static FILE* getiofile(lua_State* L, const char* name)
+{
+	lua_pushstring(L, name);
+	lua_rawget(L, lua_upvalueindex(1));
+	return tofile(L, -1);
+}
+
+static int g_iofile(lua_State* L, const char* name, const char* mode)
+{
+	if (!lua_isnoneornil(L, 1))
+	{
+		const char* filename = lua_tostring(L, 1);
+		lua_pushstring(L, name);
+		if (filename)
+		{
+			FILE** pf = newfile(L);
+			*pf = fopen(filename, mode);
+			if (*pf == NULL)
+			{
+				lua_pushfstring(L, "%s: %s", filename, strerror(errno));
+				luaL_argerror(L, 1, lua_tostring(L, -1));
+			}
+		}
+		else
+		{
+			tofile(L, 1); /* check that it's a valid file handle */
+			lua_pushvalue(L, 1);
+		}
+		lua_rawset(L, lua_upvalueindex(1));
+	}
+	/* return current value */
+	lua_pushstring(L, name);
+	lua_rawget(L, lua_upvalueindex(1));
+	return 1;
+}
+
+static int io_input(lua_State* L)
+{
+	return g_iofile(L, IO_INPUT, "r");
+}
+
+static int io_output(lua_State* L)
+{
+	return g_iofile(L, IO_OUTPUT, "w");
+}
+
+static int io_readline(lua_State* L);
+
+static void aux_lines(lua_State* L, int idx, int close)
+{
+	lua_pushliteral(L, FILEHANDLE);
+	lua_rawget(L, LUA_REGISTRYINDEX);
+	lua_pushvalue(L, idx);
+	lua_pushboolean(L, close); /* close/not close file when finished */
+	lua_pushcclosure(L, io_readline, 3);
+}
+
+static int f_lines(lua_State* L)
+{
+	tofile(L, 1); /* check that it's a valid file handle */
+	aux_lines(L, 1, 0);
+	return 1;
+}
+
+static int io_lines(lua_State* L)
+{
+	if (lua_isnoneornil(L, 1))
+	{ /* no arguments? */
+		lua_pushstring(L, IO_INPUT);
+		lua_rawget(L, lua_upvalueindex(1)); /* will iterate over default input */
+		return f_lines(L);
+	}
+	else
+	{
+		const char* filename = luaL_checkstring(L, 1);
+		FILE** pf = newfile(L);
+		*pf = fopen(filename, "r");
+		luaL_argcheck(L, *pf, 1, strerror(errno));
+		aux_lines(L, lua_gettop(L), 1);
+		return 1;
+	}
+}
+
+/*
+* {======================================================
+* READ
+* =======================================================
+*/
+
+static int read_number(lua_State* L, FILE* f)
+{
+	lua_Number d;
+	if (fscanf(f, LUA_NUMBER_SCAN, &d) == 1)
+	{
+		lua_pushnumber(L, d);
+		return 1;
+	}
+	else return 0; /* read fails */
+}
+
+static int test_eof(lua_State* L, FILE* f)
+{
+	int c = getc(f);
+	ungetc(c, f);
+	lua_pushlstring(L, NULL, 0);
+	return (c != EOF);
+}
+
+static int read_line(lua_State* L, FILE* f)
+{
+	luaL_Buffer b;
+	luaL_buffinit(L, &b);
+	for (;;)
+	{
+		size_t l;
+		char* p = luaL_prepbuffer(&b);
+		if (fgets(p, LUAL_BUFFERSIZE, f) == NULL)
+		{ /* eof? */
+			luaL_pushresult(&b); /* close buffer */
+			return (lua_strlen(L, -1) > 0); /* check whether read something */
+		}
+		l = strlen(p);
+		if (p[l - 1] != '\n')
+			luaL_addsize(&b, l);
+		else
+		{
+			luaL_addsize(&b, l - 1); /* do not include `eol' */
+			luaL_pushresult(&b); /* close buffer */
+			return 1; /* read at least an `eol' */
+		}
+	}
+}
+
+static int read_chars(lua_State* L, FILE* f, size_t n)
+{
+	size_t rlen; /* how much to read */
+	size_t nr; /* number of chars actually read */
+	luaL_Buffer b;
+	luaL_buffinit(L, &b);
+	rlen = LUAL_BUFFERSIZE; /* try to read that much each time */
+	do
+	{
+		char* p = luaL_prepbuffer(&b);
+		if (rlen > n) rlen = n; /* cannot read more than asked */
+		nr = fread(p, sizeof(char), rlen, f);
+		luaL_addsize(&b, nr);
+		n -= nr; /* still have to read `n' chars */
+	} while (n > 0 && nr == rlen); /* until end of count or eof */
+	luaL_pushresult(&b); /* close buffer */
+	return (n == 0 || lua_strlen(L, -1) > 0);
+}
+
+static int g_read(lua_State* L, FILE* f, int first)
+{
+	int nargs = lua_gettop(L) - 1;
+	int success;
+	int n;
+	if (nargs == 0)
+	{ /* no arguments? */
+		success = read_line(L, f);
+		n = first + 1; /* to return 1 result */
+	}
+	else
+	{ /* ensure stack space for all results and for auxlib's buffer */
+		luaL_checkstack(L, nargs + LUA_MINSTACK, "too many arguments");
+		success = 1;
+		for (n = first; nargs-- && success; n++)
+		{
+			if (lua_type(L, n) == LUA_TNUMBER)
+			{
+				size_t l = (size_t)lua_tonumber(L, n);
+				success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
+			}
+			else
+			{
+				const char* p = lua_tostring(L, n);
+				luaL_argcheck(L, p && p[0] == '*', n, "invalid option");
+				switch (p[1])
+				{
+				case 'n': /* number */
+					success = read_number(L, f);
+					break;
+				case 'l': /* line */
+					success = read_line(L, f);
+					break;
+				case 'a': /* file */
+					read_chars(L, f, ~((size_t)0)); /* read MAX_SIZE_T chars */
+					success = 1; /* always success */
+					break;
+				case 'w': /* word */
+					return luaL_error(L, "obsolete option `*w' to `read'");
+				default:
+					return luaL_argerror(L, n, "invalid format");
+				}
+			}
+		}
+	}
+	if (!success)
+	{
+		lua_pop(L, 1); /* remove last result */
+		lua_pushnil(L); /* push nil instead */
+	}
+	return n - first;
+}
+
+static int io_read(lua_State* L)
+{
+	return g_read(L, getiofile(L, IO_INPUT), 1);
+}
+
+static int f_read(lua_State* L)
+{
+	return g_read(L, tofile(L, 1), 2);
+}
+
+static int io_readline(lua_State* L)
+{
+	FILE* f = *(FILE**)lua_touserdata(L, lua_upvalueindex(2));
+	if (f == NULL) /* file is already closed? */
+		luaL_error(L, "file is already closed");
+	if (read_line(L, f)) return 1;
+	else
+	{ /* EOF */
+		if (lua_toboolean(L, lua_upvalueindex(3)))
+		{ /* generator created file? */
+			lua_settop(L, 0);
+			lua_pushvalue(L, lua_upvalueindex(2));
+			aux_close(L); /* close it */
+		}
+		return 0;
+	}
+}
+
+/* }====================================================== */
+
+static int g_write(lua_State* L, FILE* f, int arg)
+{
+	int nargs = lua_gettop(L) - 1;
+	int status = 1;
+	for (; nargs--; arg++)
+	{
+		if (lua_type(L, arg) == LUA_TNUMBER)
+		{
+			/* optimization: could be done exactly as for strings */
+			status = status &&
+				fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
+		}
+		else
+		{
+			size_t l;
+			const char* s = luaL_checklstring(L, arg, &l);
+			status = status && (fwrite(s, sizeof(char), l, f) == l);
+		}
+	}
+	return pushresult(L, status, NULL);
+}
+
+static int io_write(lua_State* L)
+{
+	return g_write(L, getiofile(L, IO_OUTPUT), 1);
+}
+
+static int f_write(lua_State* L)
+{
+	return g_write(L, tofile(L, 1), 2);
+}
+
+static int f_seek(lua_State* L)
+{
+	static const int mode[] = { SEEK_SET, SEEK_CUR, SEEK_END };
+	static const char* const modenames[] = { "set", "cur", "end", NULL };
+	FILE* f = tofile(L, 1);
+	int op = luaL_findstring(luaL_optstring(L, 2, "cur"), modenames);
+	long offset = luaL_optlong(L, 3, 0);
+	luaL_argcheck(L, op != -1, 2, "invalid mode");
+	op = fseek(f, offset, mode[op]);
+	if (op)
+		return pushresult(L, 0, NULL); /* error */
+	else
+	{
+		lua_pushnumber(L, ftell(f));
+		return 1;
+	}
+}
+
+static int io_flush(lua_State* L)
+{
+	return pushresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
+}
+
+static int f_flush(lua_State* L)
+{
+	return pushresult(L, fflush(tofile(L, 1)) == 0, NULL);
+}
+
+static const luaL_reg iolib[] = {
+	{ "input", io_input },
+	{ "output", io_output },
+	{ "lines", io_lines },
+	{ "close", io_close },
+	{ "flush", io_flush },
+	{ "open", io_open },
+	{ "popen", io_popen },
+	{ "read", io_read },
+	{ "tmpfile", io_tmpfile },
+	{ "type", io_type },
+	{ "write", io_write },
+	{ NULL, NULL }
+};
+
+static const luaL_reg flib[] = {
+	{ "flush", f_flush },
+	{ "read", f_read },
+	{ "lines", f_lines },
+	{ "seek", f_seek },
+	{ "write", f_write },
+	{ "close", io_close },
+	{ "__gc", io_gc },
+	{ "__tostring", io_tostring },
+	{ NULL, NULL }
+};
+
+static void createmeta(lua_State* L)
+{
+	luaL_newmetatable(L, FILEHANDLE); /* create new metatable for file handles */
+	/* file methods */
+	lua_pushliteral(L, "__index");
+	lua_pushvalue(L, -2); /* push metatable */
+	lua_rawset(L, -3); /* metatable.__index = metatable */
+	luaL_openlib(L, NULL, flib, 0);
+}
+
+/* }====================================================== */
+
+/*
+* {======================================================
+* Other O.S. Operations
+* =======================================================
+*/
+
+static int io_execute(lua_State* L)
+{
+	lua_pushnumber(L, system(luaL_checkstring(L, 1)));
+	return 1;
+}
+
+static int io_remove(lua_State* L)
+{
+	const char* filename = luaL_checkstring(L, 1);
+	return pushresult(L, remove(filename) == 0, filename);
+}
+
+static int io_rename(lua_State* L)
+{
+	const char* fromname = luaL_checkstring(L, 1);
+	const char* toname = luaL_checkstring(L, 2);
+	return pushresult(L, rename(fromname, toname) == 0, fromname);
+}
+
+static int io_tmpname(lua_State* L)
+{
+#if !USE_TMPNAME
+	luaL_error(L, "`tmpname' not supported");
+	return 0;
+#else
+	char buff[L_tmpnam];
+	if (tmpnam(buff) != buff)
+		return luaL_error(L, "unable to generate a unique filename in `tmpname'");
+	lua_pushstring(L, buff);
+	return 1;
+#endif
+}
+
+static int io_getenv(lua_State* L)
+{
+	lua_pushstring(L, getenv(luaL_checkstring(L, 1))); /* if NULL push nil */
+	return 1;
+}
+
+static int io_clock(lua_State* L)
+{
+	lua_pushnumber(L, ((lua_Number)clock()) / (lua_Number)CLOCKS_PER_SEC);
+	return 1;
+}
+
+/*
+* {======================================================
+* Time/Date operations
+* { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
+* wday=%w+1, yday=%j, isdst=? }
+* =======================================================
+*/
+
+static void setfield(lua_State* L, const char* key, int value)
+{
+	lua_pushstring(L, key);
+	lua_pushnumber(L, value);
+	lua_rawset(L, -3);
+}
+
+static void setboolfield(lua_State* L, const char* key, int value)
+{
+	lua_pushstring(L, key);
+	lua_pushboolean(L, value);
+	lua_rawset(L, -3);
+}
+
+static int getboolfield(lua_State* L, const char* key)
+{
+	int res;
+	lua_pushstring(L, key);
+	lua_gettable(L, -2);
+	res = lua_toboolean(L, -1);
+	lua_pop(L, 1);
+	return res;
+}
+
+static int getfield(lua_State* L, const char* key, int d)
+{
+	int res;
+	lua_pushstring(L, key);
+	lua_gettable(L, -2);
+	if (lua_isnumber(L, -1))
+		res = (int)(lua_tonumber(L, -1));
+	else
+	{
+		if (d == -2)
+			return luaL_error(L, "field `%s' missing in date table", key);
+		res = d;
+	}
+	lua_pop(L, 1);
+	return res;
+}
+
+static int io_date(lua_State* L)
+{
+	const char* s = luaL_optstring(L, 1, "%c");
+	time_t t = (time_t)(luaL_optnumber(L, 2, -1));
+		struct tm tm_buf;
+	struct tm* stm;
+	if (t == (time_t)(-1)) /* no time given? */
+		t = time(NULL); /* use current time */
+	if (*s == '!')
+	{ /* UTC? */
+#if defined(_WIN32) || defined(_WIN64)
+		gmtime_s(&tm_buf, &t);
+#else
+		gmtime_r(&t, &tm_buf);
+#endif
+		stm = &tm_buf;
+		s++; /* skip `!' */
+	}
+	else
+	{
+#if defined(_WIN32) || defined(_WIN64)
+		localtime_s(&tm_buf, &t);
+#else
+		localtime_r(&t, &tm_buf);
+#endif
+		stm = &tm_buf;
+	}
+if (stm == NULL) /* invalid date? */
+		lua_pushnil(L);
+	else if (strcmp(s, "*t") == 0)
+	{
+		lua_newtable(L);
+		setfield(L, "sec", stm->tm_sec);
+		setfield(L, "min", stm->tm_min);
+		setfield(L, "hour", stm->tm_hour);
+		setfield(L, "day", stm->tm_mday);
+		setfield(L, "month", stm->tm_mon + 1);
+		setfield(L, "year", stm->tm_year + 1900);
+		setfield(L, "wday", stm->tm_wday + 1);
+		setfield(L, "yday", stm->tm_yday + 1);
+		setboolfield(L, "isdst", stm->tm_isdst);
+	}
+	else
+	{
+		char b[256];
+		if (strftime(b, sizeof(b), s, stm))
+			lua_pushstring(L, b);
+		else
+			return luaL_error(L, "`date' format too long");
+	}
+	return 1;
+}
+
+static int io_time(lua_State* L)
+{
+	if (lua_isnoneornil(L, 1)) /* called without args? */
+		lua_pushnumber(L, time(NULL)); /* return current time */
+	else
+	{
+		time_t t;
+		struct tm ts;
+		luaL_checktype(L, 1, LUA_TTABLE);
+		lua_settop(L, 1); /* make sure table is at the top */
+		ts.tm_sec = getfield(L, "sec", 0);
+		ts.tm_min = getfield(L, "min", 0);
+		ts.tm_hour = getfield(L, "hour", 12);
+		ts.tm_mday = getfield(L, "day", -2);
+		ts.tm_mon = getfield(L, "month", -2) - 1;
+		ts.tm_year = getfield(L, "year", -2) - 1900;
+		ts.tm_isdst = getboolfield(L, "isdst");
+		t = mktime(&ts);
+		if (t == (time_t)(-1))
+			lua_pushnil(L);
+		else
+			lua_pushnumber(L, t);
+	}
+	return 1;
+}
+
+static int io_difftime(lua_State* L)
+{
+	lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
+		(time_t)(luaL_optnumber(L, 2, 0))));
+	return 1;
+}
+
+/* }====================================================== */
+
+static int io_setloc(lua_State* L)
+{
+	static const int cat[] = { LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME };
+	static const char* const catnames[] = { "all", "collate", "ctype", "monetary", "numeric", "time", NULL };
+	const char* l = lua_tostring(L, 1);
+	int op = luaL_findstring(luaL_optstring(L, 2, "all"), catnames);
+	luaL_argcheck(L, l || lua_isnoneornil(L, 1), 1, "string expected");
+	luaL_argcheck(L, op != -1, 2, "invalid option");
+	lua_pushstring(L, setlocale(cat[op], l));
+	return 1;
+}
+
+static int io_exit(lua_State* L)
+{
+	exit(luaL_optint(L, 1, EXIT_SUCCESS));
+	return 0; /* to avoid warnings */
+}
+
+static const luaL_reg syslib[] = {
+	{ "clock", io_clock },
+	{ "date", io_date },
+	{ "difftime", io_difftime },
+	{ "execute", io_execute },
+	{ "exit", io_exit },
+	{ "getenv", io_getenv },
+	{ "remove", io_remove },
+	{ "rename", io_rename },
+	{ "setlocale", io_setloc },
+	{ "time", io_time },
+	{ "tmpname", io_tmpname },
+	{ NULL, NULL}
+};
+
+/* }====================================================== */
+
+LUALIB_API int luaopen_io(lua_State* L)
+{
+	luaL_openlib(L, LUA_OSLIBNAME, syslib, 0);
+	createmeta(L);
+	lua_pushvalue(L, -1);
+	luaL_openlib(L, LUA_IOLIBNAME, iolib, 1);
+	/* put predefined file handles into `io' table */
+	registerfile(L, stdin, "stdin", IO_INPUT);
+	registerfile(L, stdout, "stdout", IO_OUTPUT);
+	registerfile(L, stderr, "stderr", NULL);
+	return 1;
+}
