A seguir fica um tutorial completo, em FreeBSD, de tudo o que fizemos: porquê, o que cada regra faz, como aplicar com segurança via PuTTY, como validar, como reverter, e como manter “jogável” (portas do jogo abertas) enquanto proteges o Auth contra spam de ligações.

────────────────────────────────────────
1) Objetivo e contexto
────────────────────────────────────────
Problema: ataque “connect/disconnect” ao Auth para exaurir recursos (TIME_WAIT/FD). Em FreeBSD, TIME_WAIT é kernel-level; o que resolve na prática é limitar a taxa de novas conexões e impedir que o processo aceite milhares por segundo.

Solução aplicada:
A) ativar pf (firewall nativo do FreeBSD)
B) bloquear por defeito inbound (seguro)
C) permitir apenas:
   - SSH (admin)
   - Auth (porta 11150) com rate-limit e ban automático
   - Portas públicas do game (12101–12106, 19900–19901)
D) opcional: permitir MySQL só ao teu IP (para Navicat), sem abrir ao público

O que NÃO fizemos:
- não mexemos em sysctls TCP (msl, etc.) porque é tuning e não era necessário para já
- não fizemos bind local de MySQL (porque queres aceder remotamente)

────────────────────────────────────────
2) Conceitos rápidos (para entender as regras)
────────────────────────────────────────
pf (Packet Filter): firewall que aplica regras no kernel.

“block in all”: tudo o que entra é bloqueado, a menos que exista “pass in …”.

“keep state”: pf cria um estado (state) para permitir o tráfego de retorno automaticamente.

Rate-limit no pf:
- max-src-conn: máximo de conexões simultâneas por IP
- max-src-conn-rate X/Y: máximo de novas conexões por Y segundos; se passar X, marca como abusador
- overload <abusers> flush global: se passar o rate, mete o IP numa tabela (blacklist) e mata estados associados

table <abusers>: lista dinâmica de IPs abusadores.

────────────────────────────────────────
3) Verificar se pf está ativo (e porquê)
────────────────────────────────────────
Antes, confirmámos que pf não existia:
- `service pf onestatus` -> “pf.ko is not loaded”

Para confirmar estado:
```sh
service pf onestatus
kldstat | egrep 'pf|pflog'
```

────────────────────────────────────────
4) Ativar pf (carregar módulo + arrancar no boot)
────────────────────────────────────────
Carregar já (sem reboot):
```sh
kldload pf
kldload pflog || true
```

Ativar no boot (recomendado):
```sh
sysrc pf_enable="YES"
sysrc pf_rules="/etc/pf.conf"
sysrc pflog_enable="YES"
```

Opcional (garantir load no boot pelo loader):
```sh
printf '%s\n' 'pf_load="YES"' 'pflog_load="YES"' >> /boot/loader.conf
```

Notas:
- Se falhares numa regra e perderes acesso, podes desativar pf localmente com `pfctl -d` (se ainda tiveres consola).

────────────────────────────────────────
5) Descobrir as portas reais que o servidor usa
────────────────────────────────────────
Isto é crítico. Não se assume nada.

No teu caso:
- Auth PORT: 11150 (do teu config)
- Game ports: vistas no sockstat
- Vimos também DB core e MySQL a ouvir, mas não são para público

Comando para listar o que está a ouvir:
```sh
sockstat -4l
```

Do teu output:
- SSH: :22
- Auth: :11150
- P2P: :11250 (não precisa público num host único)
- DB core: :11000 (não precisa público num host único)
- Game: :12101–12106, :19900, :19901 (público)
- MySQL: :3306, :33060 (se quiseres Navicat remoto)

────────────────────────────────────────
6) Construir o /etc/pf.conf correto para “jogável e protegido”
────────────────────────────────────────
Regra base:
- bloquear tudo inbound
- permitir só as portas necessárias

6.1) Config “jogável + proteção Auth + sem MySQL remoto”
Conteúdo base (o que aplicaste e ficou validado):

```pf
ext_if = "vtnet0"
auth_port = "11150"
ssh_port  = "22"
game_ports = "{ 12101:12106, 19900, 19901 }"

set block-policy drop
set skip on lo

table <abusers> persist

block in all
pass out all keep state

pass in on $ext_if proto tcp to port $ssh_port keep state

pass in on $ext_if proto tcp to port $auth_port flags S/SA \
  keep state (max-src-conn 30, max-src-conn-rate 20/1, overload <abusers> flush global)

block in quick from <abusers> to any

pass in on $ext_if proto tcp to port $game_ports flags S/SA keep state
```

O que isto faz:
- SSH continua acessível.
- Auth 11150:
  - permite conexões normais
  - se um IP criar demasiadas conexões novas por segundo, entra em `<abusers>` e é bloqueado
- As portas do game ficam abertas ao público.
- Tudo o resto fica fechado (inclui 11000, 11250, 3306, etc.)

6.2) Extensão: permitir MySQL remoto apenas ao teu IP (Navicat)
Se quiseres manter MySQL acessível remotamente, NÃO abras ao mundo. Faz whitelist.

Adicionar ao pf.conf:
- declarar tabela e portas MySQL
- permitir apenas de `<mysql_allow>`

Exemplo completo (inclui tudo):
```pf
ext_if = "vtnet0"
auth_port = "11150"
ssh_port  = "22"
game_ports = "{ 12101:12106, 19900, 19901 }"

mysql_ports = "{ 3306, 33060 }"
table <mysql_allow> persist

set block-policy drop
set skip on lo

table <abusers> persist

block in all
pass out all keep state

pass in on $ext_if proto tcp to port $ssh_port keep state

pass in on $ext_if proto tcp to port $auth_port flags S/SA \
  keep state (max-src-conn 30, max-src-conn-rate 20/1, overload <abusers> flush global)

block in quick from <abusers> to any

pass in on $ext_if proto tcp to port $game_ports flags S/SA keep state

# MySQL apenas para IP(s) autorizados
pass in on $ext_if proto tcp from <mysql_allow> to port $mysql_ports flags S/SA keep state
```

Depois adicionas IPs autorizados:
```sh
MYIP=$(fetch -q -o - https://api.ipify.org)
pfctl -t mysql_allow -T add "$MYIP"
pfctl -t mysql_allow -T show
```

Se não precisares de 33060, remove-o e fica só 3306 (mais seguro):
`mysql_ports = "{ 3306 }"`

────────────────────────────────────────
7) Como aplicar via PuTTY (sem nano)
────────────────────────────────────────
Como `nano` não existia, usamos “cat > ficheiro” para evitar erros do vi.

Procedimento seguro:
1) Backup:
```sh
cp -a /etc/pf.conf /etc/pf.conf.bak.$(date +%Y%m%d_%H%M%S)
```

2) Escrever o ficheiro:
```sh
cat > /etc/pf.conf <<'EOF'
...conteúdo...
EOF
```

3) Validar antes de aplicar (obrigatório):
```sh
pfctl -nf /etc/pf.conf
```

4) Aplicar:
```sh
pfctl -f /etc/pf.conf
service pf reload || service pf restart || service pf start
```

5) Confirmar regras:
```sh
pfctl -sr
```

────────────────────────────────────────
8) Como confirmar que está tudo operacional
────────────────────────────────────────
Ver regras:
```sh
pfctl -sr
```

Ver o que está a ouvir:
```sh
sockstat -4l
```

Ver estados:
```sh
pfctl -ss | head
```

Ver abusadores:
```sh
pfctl -t abusers -T show
```

Se `<abusers>` começar a encher com IPs legítimos (NAT/launchers), sobe o rate-limit:
- de 20/1 para 50/1:

```sh
sed -i '' 's/max-src-conn-rate 20\/1/max-src-conn-rate 50\/1/' /etc/pf.conf
pfctl -nf /etc/pf.conf && pfctl -f /etc/pf.conf && service pf reload
```

────────────────────────────────────────
9) Reversão rápida (se algo correr mal)
────────────────────────────────────────
Desativar pf imediatamente:
```sh
pfctl -d
```

Restaurar backup do pf.conf (exemplo, escolhe o mais recente):
```sh
ls -1 /etc/pf.conf.bak.*
cp -a /etc/pf.conf.bak.YYYYMMDD_HHMMSS /etc/pf.conf
pfctl -nf /etc/pf.conf && pfctl -f /etc/pf.conf
service pf reload
```

────────────────────────────────────────
10) O que esta solução resolve e o que não resolve
────────────────────────────────────────
Resolve bem:
- spam de novas conexões no Auth (connect/disconnect rápido)
- “starvation” por excesso de conexões por IP (ban automático)
- reduz risco de esgotar FD/sockets por ataques simples

Não resolve sozinho:
- DDoS volumétrico (muito tráfego distribuído por milhares de IPs). Para isso precisas também do lado OVH (anti-DDoS, firewall de rede) e possivelmente regras mais sofisticadas (por subnet, geofencing, etc.)

────────────────────────────────────────
11) Recomendações finais para estabilidade real
────────────────────────────────────────
A) Subir limites de file descriptors (muito importante)
Mesmo com pf, isto ajuda contra picos reais.

```sh
sysctl kern.maxfiles=200000
sysctl kern.maxfilesperproc=200000

grep -q 'kern.maxfiles=' /etc/sysctl.conf || cat >> /etc/sysctl.conf <<'EOF'
kern.maxfiles=200000
kern.maxfilesperproc=200000
EOF
```

E no arranque dos processos (script), garantir:
```sh
ulimit -n 200000
```

B) OVH firewall
No painel da OVH, ativa firewall/regras para permitir apenas as portas necessárias (SSH + auth + game). Isto corta tráfego antes de chegar ao teu FreeBSD.

────────────────────────────────────────
12) “Checklist” para re-implementar no futuro (resumo curto)
────────────────────────────────────────
1) `sockstat -4l` → listar portas reais
2) `kldload pf` + `sysrc pf_enable=YES pf_rules=/etc/pf.conf`
3) criar `/etc/pf.conf` com:
   - block in all
   - pass SSH
   - pass Auth com rate-limit + abusers
   - pass game ports
   - opcional pass MySQL só whitelist
4) `pfctl -nf` (validar)
5) `pfctl -f` + `service pf reload`
6) confirmar com `pfctl -sr`, `pfctl -t abusers -T show`
