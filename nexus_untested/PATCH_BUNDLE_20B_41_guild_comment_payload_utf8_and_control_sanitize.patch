--- a/game/src/input_main.cpp
+++ b/game/src/input_main.cpp
@@ -3353,6 +3353,76 @@
 			if (uiBytes < 1 + length)
 				return -1;
 
+			// Harden: validate guild comment payload to avoid DB truncation edge cases and invalid UTF-8/control-byte injection
+			if (length)
+			{
+				const char* pText = c_pData + 1;
+				// Disallow embedded NULs (can desync SQL builders / logs)
+				if (memchr(pText, '\0', length) != nullptr)
+				{
+					sys_err("POST_COMMENT: %s comment contains NUL byte", ch->GetName());
+					ch->GetDesc()->SetPhase(PHASE_CLOSE);
+					return -1;
+				}
+				// Disallow control chars except whitespace
+				for (size_t i = 0; i < length; ++i)
+				{
+					const unsigned char c = static_cast<unsigned char>(pText[i]);
+					if (c < 0x20 && c != '\n' && c != '\r' && c != '\t')
+					{
+						sys_err("POST_COMMENT: %s comment contains control byte 0x%02X", ch->GetName(), c);
+						ch->GetDesc()->SetPhase(PHASE_CLOSE);
+						return -1;
+					}
+				}
+				// Basic UTF-8 validation (reject overlong/invalid sequences)
+				auto is_valid_utf8 = [](const char* s, size_t n) -> bool
+				{
+					size_t i = 0;
+					while (i < n)
+					{
+						unsigned char c = static_cast<unsigned char>(s[i]);
+						if (c <= 0x7F) { ++i; continue; }
+						if (c >= 0xC2 && c <= 0xDF)
+						{
+							if (i + 1 >= n) return false;
+							unsigned char c1 = static_cast<unsigned char>(s[i + 1]);
+							if ((c1 & 0xC0) != 0x80) return false;
+							i += 2; continue;
+						}
+						if (c >= 0xE0 && c <= 0xEF)
+						{
+							if (i + 2 >= n) return false;
+							unsigned char c1 = static_cast<unsigned char>(s[i + 1]);
+							unsigned char c2 = static_cast<unsigned char>(s[i + 2]);
+							if ((c1 & 0xC0) != 0x80 || (c2 & 0xC0) != 0x80) return false;
+							if (c == 0xE0 && c1 < 0xA0) return false;
+							if (c == 0xED && c1 >= 0xA0) return false;
+							i += 3; continue;
+						}
+						if (c >= 0xF0 && c <= 0xF4)
+						{
+							if (i + 3 >= n) return false;
+							unsigned char c1 = static_cast<unsigned char>(s[i + 1]);
+							unsigned char c2 = static_cast<unsigned char>(s[i + 2]);
+							unsigned char c3 = static_cast<unsigned char>(s[i + 3]);
+							if ((c1 & 0xC0) != 0x80 || (c2 & 0xC0) != 0x80 || (c3 & 0xC0) != 0x80) return false;
+							if (c == 0xF0 && c1 < 0x90) return false;
+							if (c == 0xF4 && c1 > 0x8F) return false;
+							i += 4; continue;
+						}
+						return false;
+					}
+					return true;
+				};
+				if (!is_valid_utf8(pText, length))
+				{
+					sys_err("POST_COMMENT: %s invalid UTF-8 in comment", ch->GetName());
+					ch->GetDesc()->SetPhase(PHASE_CLOSE);
+					return -1;
+				}
+			}
+
 			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
 
 			if (NULL == m)
--- a/game/src/guild.cpp
+++ b/game/src/guild.cpp
@@ -1047,6 +1047,17 @@
 		return;
 	}
 
+	// Harden: avoid log/DB edge-cases with control bytes (and potential SQL truncation oddities)
+	for (size_t i = 0; i < str.size(); ++i)
+	{
+		const unsigned char c = static_cast<unsigned char>(str[i]);
+		if (c == 0x00 || (c < 0x20 && c != '\n' && c != '\r' && c != '\t'))
+		{
+			sys_err("POST_COMMENT: %s comment contains invalid byte 0x%02X", ch->GetName(), c);
+			return;
+		}
+	}
+
 	if (m_guildPostCommentPulse > thecore_pulse() && !ch->IsGM())
 	{
 		int iDeltaSecs = ((m_guildPostCommentPulse / PASSES_PER_SEC(1)) - (thecore_pulse() / PASSES_PER_SEC(1)));
