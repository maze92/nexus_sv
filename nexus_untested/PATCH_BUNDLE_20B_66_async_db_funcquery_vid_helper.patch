--- /mnt/data/_patch_orig/db_h_db.h	2024-12-27 19:09:36.000000000 +0000
+++ "/mnt/data/nexus_src/Nexus OS/server/metin2/Source/Server/game/src/db.h"	2026-02-17 05:21:46.002902935 +0000
@@ -3,6 +3,7 @@
 
 #include "../../libsql/AsyncSQL.h"
 #include "any_function.h"
+#include "char_manager.h"
 
 enum
 {
@@ -119,6 +120,40 @@
 	const std::vector<std::string>& GetGreetMessage();
 
 	template<class Functor> void FuncQuery(Functor f, const char* c_pszFormat, ...); // 결과를 f인자로 호출함 (SQLMsg *) 알아서 해제됨
+
+	// Safe async-query helper: resolves the character by VID when the callback runs.
+	// Use this instead of capturing LPCHARACTER in lambdas/binds for async DB queries.
+	// Callback signature: void(LPCHARACTER ch, SQLMsg* msg)
+	template <class TCharMsgFunc>
+	void FuncQueryWithVID(DWORD dwVID, TCharMsgFunc func, const char* c_pszFormat, ...)
+	{
+		char szQuery[4096];
+		va_list args;
+		va_start(args, c_pszFormat);
+		vsnprintf(szQuery, sizeof(szQuery), c_pszFormat, args);
+		va_end(args);
+
+		struct TVIDWrapper
+		{
+			DWORD vid;
+			TCharMsgFunc f;
+
+			TVIDWrapper(DWORD v, const TCharMsgFunc& _f) : vid(v), f(_f) {}
+
+			void operator()(SQLMsg* msg)
+			{
+				LPCHARACTER ch = CHARACTER_MANAGER::instance().Find(vid);
+				if (!ch)
+					return;
+				f(ch, msg);
+			}
+		};
+
+		CFuncQueryInfo* p = M2_NEW CFuncQueryInfo;
+		p->iQueryType = QUERY_TYPE_FUNCTION;
+		p->f = TVIDWrapper(dwVID, func);
+		m_sql.ReturnQuery(szQuery, p);
+	}
 	template<class Functor> void FuncAfterQuery(Functor f, const char* c_pszFormat, ...); // 끝나고 나면 f가 호출됨 void f(void) 형태
 
 	size_t EscapeString(char* dst, size_t dstSize, const char* src, size_t srcSize);
