--- a/server/metin2/Source/Server/game/src/char_item.cpp
+++ b/server/metin2/Source/Server/game/src/char_item.cpp
@@ -3057,6 +3057,41 @@
 				return false;
 			}
 
+			// [Anti-Grief] Prevent stacking campfires to block NPCs/bridges (limit 1 campfire within ~5m)
+			struct FCampfireNear
+			{
+				long x, y;
+				bool found;
+				FCampfireNear(long _x, long _y) : x(_x), y(_y), found(false) {}
+				void operator()(LPENTITY ent)
+				{
+					if (found || !ent || !ent->IsType(ENTITY_CHARACTER))
+						return;
+
+					LPCHARACTER pkChr = (LPCHARACTER)ent;
+					if (!pkChr || !pkChr->IsNPC())
+						return;
+
+					if (pkChr->GetRaceNum() != fishing::CAMPFIRE_MOB)
+						return;
+
+					int dist = DISTANCE_APPROX(pkChr->GetX() - x, pkChr->GetY() - y);
+					if (dist < 500)
+						found = true;
+				}
+			};
+
+			const long lCampX = (long)(GetX() + fx);
+			const long lCampY = (long)(GetY() + fy);
+			FCampfireNear fCamp(lCampX, lCampY);
+			tree->ForEachAround(fCamp);
+
+			if (fCamp.found)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot place another campfire so close to an existing one."));
+				return false;
+			}
+
 			LPCHARACTER campfire = CHARACTER_MANAGER::instance().SpawnMob(fishing::CAMPFIRE_MOB, GetMapIndex(), (long)(GetX() + fx), (long)(GetY() + fy), 0, false, number(0, 359));
 
 			char_event_info* info = AllocEventInfo<char_event_info>();
@@ -4320,6 +4355,42 @@
 										break;
 									}
 								}
+
+								LPCHARACTER pkOther = NULL;
+								if (pMarriage->m_pid1 == GetPlayerID())
+									pkOther = pMarriage->ch2;
+								else if (pMarriage->m_pid2 == GetPlayerID())
+									pkOther = pMarriage->ch1;
+
+								if (pkOther)
+								{
+									const long lOtherMapIndex = pkOther->GetMapIndex();
+
+									// [Security] Prevent wedding-ring dungeon/war/event/GM-map taxi
+									if (pkOther->GetDungeon() != NULL)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot teleport to your partner inside a dungeon."));
+										break;
+									}
+
+									if (CWarMapManager::instance().IsWarMap(lOtherMapIndex))
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot teleport to your partner on a war map."));
+										break;
+									}
+
+									if (!IS_SUMMONABLE_ZONE(lOtherMapIndex))
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot teleport to your partner in this area."));
+										break;
+									}
+
+									if (!IsGM() && pkOther->GetGMLevel() > GM_PLAYER)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot teleport to your partner in this area."));
+										break;
+									}
+								}
 
 								int consumeSP = CalculateConsumeSP(this);
 
--- a/server/metin2/Source/Server/game/src/input_main.cpp
+++ b/server/metin2/Source/Server/game/src/input_main.cpp
@@ -44,6 +44,8 @@
 #include "DragonSoul.h"
 #include "belt_inventory_helper.h"
 
+#include <vector>
+
 #if defined(__LOOT_FILTER_SYSTEM__)
 #	include "LootFilter.h"
 #endif
@@ -314,6 +316,152 @@
 	return 4;
 }
 
+static bool __ParseItemLinkParts(const std::string& payload, std::vector<long long>& out)
+{
+	out.clear();
+
+	// Expect "item:" prefix
+	if (payload.size() < 5 || payload.compare(0, 5, "item:") != 0)
+		return false;
+
+	const char* p = payload.c_str() + 5;
+	const char* end = payload.c_str() + payload.size();
+
+	while (p < end)
+	{
+		char* next = NULL;
+		long long v = strtoll(p, &next, 10);
+		if (next == p)
+			break;
+
+		out.push_back(v);
+
+		p = next;
+		if (p < end && *p == ':')
+			++p;
+		else
+			break;
+	}
+
+	return !out.empty();
+}
+
+static bool __HasMatchingItemForLink(LPCHARACTER ch, const std::vector<long long>& parts)
+{
+	if (!ch || parts.empty())
+		return false;
+
+	const DWORD vnum = (DWORD)parts[0];
+
+	// If sockets are present, validate the first 3 sockets
+	const bool hasSockets = (parts.size() >= 4);
+	DWORD s0 = 0, s1 = 0, s2 = 0;
+	if (hasSockets)
+	{
+		s0 = (DWORD)parts[1];
+		s1 = (DWORD)parts[2];
+		s2 = (DWORD)parts[3];
+	}
+
+	// If attributes are present in classic format, validate 7 attribute pairs (type,value)
+	const bool hasAttrs = (parts.size() >= 18);
+
+	auto matches = [&](LPITEM item) -> bool
+	{
+		if (!item)
+			return false;
+
+		if (item->GetVnum() != vnum)
+			return false;
+
+		if (hasSockets)
+		{
+			if (item->GetSocket(0) != s0 || item->GetSocket(1) != s1 || item->GetSocket(2) != s2)
+				return false;
+		}
+
+		if (hasAttrs)
+		{
+			for (int i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
+			{
+				const TPlayerItemAttribute& a = item->GetAttribute(i);
+				const int type = (int)parts[4 + i * 2];
+				const int val = (int)parts[5 + i * 2];
+
+				if (a.bType != type || a.sValue != val)
+					return false;
+			}
+		}
+
+		return true;
+	};
+
+	// Inventory
+	int maxInv = INVENTORY_MAX_NUM;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	maxInv = ch->GetExtendInvenMax();
+#endif
+	for (int i = 0; i < maxInv; ++i)
+	{
+		LPITEM item = ch->GetInventoryItem(i);
+		if (matches(item))
+			return true;
+	}
+
+	// Equipment
+	for (int i = 0; i < WEAR_MAX_NUM; ++i)
+	{
+		LPITEM item = ch->GetWear(i);
+		if (matches(item))
+			return true;
+	}
+
+	// Belt inventory
+	for (int i = 0; i < BELT_INVENTORY_SLOT_COUNT; ++i)
+	{
+		LPITEM item = ch->GetItem(TItemPos(BELT_INVENTORY, i));
+		if (matches(item))
+			return true;
+	}
+
+	return false;
+}
+
+static bool __ValidateItemLinksInText(LPCHARACTER ch, const char* text, size_t len)
+{
+	if (!ch || !text || len == 0)
+		return true;
+
+	// Allow GMs to link freely
+	if (ch->IsGM())
+		return true;
+
+	std::string s(text, len);
+	size_t pos = 0;
+
+	std::vector<long long> parts;
+
+	while ((pos = s.find("|Hitem:", pos)) != std::string::npos)
+	{
+		const size_t payloadStart = pos + 2; // skip "|H"
+		const size_t hEnd = s.find("|h", payloadStart);
+		if (hEnd == std::string::npos)
+			return false; // malformed hyperlink
+
+		const std::string payload = s.substr(payloadStart, hEnd - payloadStart);
+
+		if (!__ParseItemLinkParts(payload, parts))
+			return false;
+
+		if (!__HasMatchingItemForLink(ch, parts))
+			return false;
+
+		pos = hEnd + 2;
+	}
+
+	return true;
+}
+
 int CInputMain::Whisper(LPCHARACTER ch, const char* data, size_t uiBytes)
 {
 	const TPacketCGWhisper* pinfo = reinterpret_cast<const TPacketCGWhisper*>(data);
@@ -544,6 +692,12 @@
 
 			if (!g_bDisableGlassInsight)
 			{
+				if (!__ValidateItemLinksInText(ch, buf, buflen))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Invalid item link."));
+					return iExtraLen;
+				}
+
 				int processReturn = ProcessTextTag(ch, buf, buflen);
 				if (processReturn != 0)
 				{
@@ -836,6 +990,12 @@
 
 	if (!g_bDisableGlassInsight)
 	{
+		if (!__ValidateItemLinksInText(ch, buf, buflen))
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Invalid item link."));
+			return iExtraLen;
+		}
+
 		int processReturn = ProcessTextTag(ch, chatbuf, len);
 		if (processReturn != 0)
 		{
--- a/server/metin2/Source/Server/game/src/input_main.cpp
+++ b/server/metin2/Source/Server/game/src/input_main.cpp
@@ -44,6 +44,8 @@
 #include "DragonSoul.h"
 #include "belt_inventory_helper.h"
 
+#include <vector>
+
 #if defined(__LOOT_FILTER_SYSTEM__)
 #	include "LootFilter.h"
 #endif
@@ -314,6 +316,152 @@
 	return 4;
 }
 
+static bool __ParseItemLinkParts(const std::string& payload, std::vector<long long>& out)
+{
+	out.clear();
+
+	// Expect "item:" prefix
+	if (payload.size() < 5 || payload.compare(0, 5, "item:") != 0)
+		return false;
+
+	const char* p = payload.c_str() + 5;
+	const char* end = payload.c_str() + payload.size();
+
+	while (p < end)
+	{
+		char* next = NULL;
+		long long v = strtoll(p, &next, 10);
+		if (next == p)
+			break;
+
+		out.push_back(v);
+
+		p = next;
+		if (p < end && *p == ':')
+			++p;
+		else
+			break;
+	}
+
+	return !out.empty();
+}
+
+static bool __HasMatchingItemForLink(LPCHARACTER ch, const std::vector<long long>& parts)
+{
+	if (!ch || parts.empty())
+		return false;
+
+	const DWORD vnum = (DWORD)parts[0];
+
+	// If sockets are present, validate the first 3 sockets
+	const bool hasSockets = (parts.size() >= 4);
+	DWORD s0 = 0, s1 = 0, s2 = 0;
+	if (hasSockets)
+	{
+		s0 = (DWORD)parts[1];
+		s1 = (DWORD)parts[2];
+		s2 = (DWORD)parts[3];
+	}
+
+	// If attributes are present in classic format, validate 7 attribute pairs (type,value)
+	const bool hasAttrs = (parts.size() >= 18);
+
+	auto matches = [&](LPITEM item) -> bool
+	{
+		if (!item)
+			return false;
+
+		if (item->GetVnum() != vnum)
+			return false;
+
+		if (hasSockets)
+		{
+			if (item->GetSocket(0) != s0 || item->GetSocket(1) != s1 || item->GetSocket(2) != s2)
+				return false;
+		}
+
+		if (hasAttrs)
+		{
+			for (int i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
+			{
+				const TPlayerItemAttribute& a = item->GetAttribute(i);
+				const int type = (int)parts[4 + i * 2];
+				const int val = (int)parts[5 + i * 2];
+
+				if (a.bType != type || a.sValue != val)
+					return false;
+			}
+		}
+
+		return true;
+	};
+
+	// Inventory
+	int maxInv = INVENTORY_MAX_NUM;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	maxInv = ch->GetExtendInvenMax();
+#endif
+	for (int i = 0; i < maxInv; ++i)
+	{
+		LPITEM item = ch->GetInventoryItem(i);
+		if (matches(item))
+			return true;
+	}
+
+	// Equipment
+	for (int i = 0; i < WEAR_MAX_NUM; ++i)
+	{
+		LPITEM item = ch->GetWear(i);
+		if (matches(item))
+			return true;
+	}
+
+	// Belt inventory
+	for (int i = 0; i < BELT_INVENTORY_SLOT_COUNT; ++i)
+	{
+		LPITEM item = ch->GetItem(TItemPos(BELT_INVENTORY, i));
+		if (matches(item))
+			return true;
+	}
+
+	return false;
+}
+
+static bool __ValidateItemLinksInText(LPCHARACTER ch, const char* text, size_t len)
+{
+	if (!ch || !text || len == 0)
+		return true;
+
+	// Allow GMs to link freely
+	if (ch->IsGM())
+		return true;
+
+	std::string s(text, len);
+	size_t pos = 0;
+
+	std::vector<long long> parts;
+
+	while ((pos = s.find("|Hitem:", pos)) != std::string::npos)
+	{
+		const size_t payloadStart = pos + 2; // skip "|H"
+		const size_t hEnd = s.find("|h", payloadStart);
+		if (hEnd == std::string::npos)
+			return false; // malformed hyperlink
+
+		const std::string payload = s.substr(payloadStart, hEnd - payloadStart);
+
+		if (!__ParseItemLinkParts(payload, parts))
+			return false;
+
+		if (!__HasMatchingItemForLink(ch, parts))
+			return false;
+
+		pos = hEnd + 2;
+	}
+
+	return true;
+}
+
 int CInputMain::Whisper(LPCHARACTER ch, const char* data, size_t uiBytes)
 {
 	const TPacketCGWhisper* pinfo = reinterpret_cast<const TPacketCGWhisper*>(data);
@@ -544,6 +692,12 @@
 
 			if (!g_bDisableGlassInsight)
 			{
+				if (!__ValidateItemLinksInText(ch, buf, buflen))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Invalid item link."));
+					return iExtraLen;
+				}
+
 				int processReturn = ProcessTextTag(ch, buf, buflen);
 				if (processReturn != 0)
 				{
@@ -836,6 +990,12 @@
 
 	if (!g_bDisableGlassInsight)
 	{
+		if (!__ValidateItemLinksInText(ch, buf, buflen))
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Invalid item link."));
+			return iExtraLen;
+		}
+
 		int processReturn = ProcessTextTag(ch, chatbuf, len);
 		if (processReturn != 0)
 		{
