--- a/server/metin2/Source/Server/db/src/ItemIDRangeManager.cpp
+++ b/server/metin2/Source/Server/db/src/ItemIDRangeManager.cpp
@@ -5,6 +5,141 @@
 #include "ClientManager.h"
 #include "Peer.h"
 
+namespace
+{
+	// Persistent range allocator (prevents duplicated ITEM ID ranges across simultaneous requests and DB restarts).
+	// Uses an atomic counter in the player DB. If the table cannot be created/used, code falls back to legacy scan-based ranges.
+	static const char* kItemIDRangeAllocatorTable = "item_id_range_allocator";
+	static const DWORD kRangeStep = 10000000UL;       // must match CItemIDRangeManager::cs_dwMinimumRange
+	static const DWORD kMaxItemID = 4290000000UL;     // must match CItemIDRangeManager::cs_dwMaxItemID
+
+	inline bool RangeOverlaps(DWORD aMin, DWORD aMax, DWORD bMin, DWORD bMax)
+	{
+		return (aMin <= bMax) && (bMin <= aMax);
+	}
+
+	DWORD GetCurrentMaxItemID()
+	{
+		char szQuery[256];
+		DWORD dwItemMaxID = 0;
+		SQLMsg* pMsg = NULL;
+		MYSQL_ROW row;
+
+		snprintf(szQuery, sizeof(szQuery), "SELECT MAX(id) FROM item%s", GetTablePostfix());
+		pMsg = CDBManager::instance().DirectQuery(szQuery);
+
+		if (pMsg != NULL)
+		{
+			if (pMsg->Get()->uiNumRows > 0)
+			{
+				row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+				str_to_number(dwItemMaxID, row[0]);
+			}
+			delete pMsg;
+		}
+
+		return dwItemMaxID;
+	}
+
+	DWORD ComputeInitialNextIndex()
+	{
+		// next_index is the next segment index to allocate (0 => first range starts at 10,000,001).
+		const DWORD dwMaxID = GetCurrentMaxItemID();
+		if (dwMaxID == 0)
+			return 0;
+
+		// Ensure next range starts after current max id (round up to the next segment).
+		return (dwMaxID - 1) / kRangeStep;
+	}
+
+	bool EnsureAllocatorTable(DWORD dwInitialNextIndex)
+	{
+		static bool s_bTried = false;
+		static bool s_bOk = false;
+
+		if (s_bTried)
+			return s_bOk;
+
+		s_bTried = true;
+
+		char szQuery[512];
+		SQLMsg* pMsg = NULL;
+
+		// InnoDB + single row counter = atomic increments via LAST_INSERT_ID().
+		snprintf(szQuery, sizeof(szQuery),
+			"CREATE TABLE IF NOT EXISTS `%s` ("
+			"`id` TINYINT UNSIGNED NOT NULL PRIMARY KEY, "
+			"`next_index` INT UNSIGNED NOT NULL"
+			") ENGINE=InnoDB",
+			kItemIDRangeAllocatorTable);
+
+		pMsg = CDBManager::instance().DirectQuery(szQuery);
+		if (!pMsg)
+			return false;
+		delete pMsg;
+
+		snprintf(szQuery, sizeof(szQuery),
+			"INSERT IGNORE INTO `%s` (`id`, `next_index`) VALUES (1, %u)",
+			kItemIDRangeAllocatorTable, dwInitialNextIndex);
+
+		pMsg = CDBManager::instance().DirectQuery(szQuery);
+		if (!pMsg)
+			return false;
+		delete pMsg;
+
+		snprintf(szQuery, sizeof(szQuery),
+			"UPDATE `%s` SET `next_index` = GREATEST(`next_index`, %u) WHERE `id` = 1",
+			kItemIDRangeAllocatorTable, dwInitialNextIndex);
+
+		pMsg = CDBManager::instance().DirectQuery(szQuery);
+		if (!pMsg)
+			return false;
+		delete pMsg;
+
+		s_bOk = true;
+		return true;
+	}
+
+	bool AllocateNextIndex(DWORD& dwOutIndex)
+	{
+		char szQuery[256];
+		SQLMsg* pMsg = NULL;
+		MYSQL_ROW row;
+
+		// Atomically increment and stash new value into LAST_INSERT_ID().
+		snprintf(szQuery, sizeof(szQuery),
+			"UPDATE `%s` SET `next_index` = LAST_INSERT_ID(`next_index` + 1) WHERE `id` = 1",
+			kItemIDRangeAllocatorTable);
+
+		pMsg = CDBManager::instance().DirectQuery(szQuery);
+		if (!pMsg)
+			return false;
+		delete pMsg;
+
+		pMsg = CDBManager::instance().DirectQuery("SELECT LAST_INSERT_ID()");
+		if (!pMsg)
+			return false;
+
+		if (pMsg->Get()->uiNumRows == 0)
+		{
+			delete pMsg;
+			return false;
+		}
+
+		row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+		DWORD dwNext = 0;
+		str_to_number(dwNext, row[0]);
+		delete pMsg;
+
+		if (dwNext == 0)
+			return false;
+
+		// dwNext is the post-increment value; allocated index is the previous value.
+		dwOutIndex = dwNext - 1;
+		return true;
+	}
+}
+
 CItemIDRangeManager::CItemIDRangeManager()
 {
 	m_listData.clear();
@@ -64,6 +199,42 @@
 	ret.dwMax = 0;
 	ret.dwUsableItemIDMin = 0;
 
+	// Prefer a persistent, atomic allocator table to prevent duplicated ranges across concurrent requests and DB restarts.
+	// If unavailable (permissions / older schema), fall back to the legacy scan-based allocator.
+	const DWORD dwInitialNextIndex = ComputeInitialNextIndex();
+	if (EnsureAllocatorTable(dwInitialNextIndex))
+	{
+		const TItemIDRangeTable reserved = CClientManager::instance().GetItemRange();
+
+		for (int iTries = 0; iTries < 10000; ++iTries)
+		{
+			DWORD dwIndex = 0;
+			if (!AllocateNextIndex(dwIndex))
+				break;
+
+			const uint64_t uMin = (uint64_t)kRangeStep * ((uint64_t)dwIndex + 1) + 1;
+			const uint64_t uMax = (uint64_t)kRangeStep * ((uint64_t)dwIndex + 2);
+
+			if (uMax >= (uint64_t)kMaxItemID)
+			{
+				sys_err("ITEM_ID_RANGE allocator exhausted (index=%u)", dwIndex);
+				break;
+			}
+
+			ret.dwMin = (DWORD)uMin;
+			ret.dwMax = (DWORD)uMax;
+			ret.dwUsableItemIDMin = ret.dwMin;
+
+			// Skip the DB reserved range.
+			if (reserved.dwMin != 0 && reserved.dwMax != 0 && RangeOverlaps(ret.dwMin, ret.dwMax, reserved.dwMin, reserved.dwMax))
+				continue;
+
+			return ret;
+		}
+
+		sys_err("ITEM_ID_RANGE allocator table present but allocation failed; falling back to legacy allocator");
+	}
+
 	if (m_listData.size() > 0)
 	{
 		while (m_listData.size() > 0)
--- a/SQL/player.sql
+++ b/SQL/player.sql
@@ -3217,3 +3217,11 @@
 -- ----------------------------
 
 SET FOREIGN_KEY_CHECKS = 1;
+-- PATCH_BUNDLE_20B: Persistent allocator to avoid duplicated item ID ranges across concurrent requests / DB restarts.
+CREATE TABLE IF NOT EXISTS `item_id_range_allocator` (
+  `id` TINYINT UNSIGNED NOT NULL PRIMARY KEY,
+  `next_index` INT UNSIGNED NOT NULL
+) ENGINE=InnoDB;
+
+INSERT IGNORE INTO `item_id_range_allocator` (`id`, `next_index`) VALUES (1, 0);
+
--- a/SQL/SQL/player.sql
+++ b/SQL/SQL/player.sql
@@ -3217,3 +3217,11 @@
 -- ----------------------------
 
 SET FOREIGN_KEY_CHECKS = 1;
+-- PATCH_BUNDLE_20B: Persistent allocator to avoid duplicated item ID ranges across concurrent requests / DB restarts.
+CREATE TABLE IF NOT EXISTS `item_id_range_allocator` (
+  `id` TINYINT UNSIGNED NOT NULL PRIMARY KEY,
+  `next_index` INT UNSIGNED NOT NULL
+) ENGINE=InnoDB;
+
+INSERT IGNORE INTO `item_id_range_allocator` (`id`, `next_index`) VALUES (1, 0);
+
