diff --git a/SQL/player.sql b/SQL/player.sql
index 4016539..d1e5c1d 100644
--- a/SQL/player.sql
+++ b/SQL/player.sql
@@ -3214,6 +3214,13 @@ CREATE TABLE `string`  (
 
 -- ----------------------------
 -- Records of string
--- ----------------------------
-
-SET FOREIGN_KEY_CHECKS = 1;
+-- ----------------------------
+
+SET FOREIGN_KEY_CHECKS = 1;
+-- PATCH_BUNDLE_20B: Persistent allocator to avoid duplicated item ID ranges across concurrent requests / DB restarts.
+CREATE TABLE IF NOT EXISTS `item_id_range_allocator` (
+  `id` TINYINT UNSIGNED NOT NULL PRIMARY KEY,
+  `next_index` INT UNSIGNED NOT NULL
+) ENGINE=InnoDB;
+
+INSERT IGNORE INTO `item_id_range_allocator` (`id`, `next_index`) VALUES (1, 0);
diff --git a/server/metin2/Source/Server/common/service.h b/server/metin2/Source/Server/common/service.h
index 6e8ad5c..5c00f3c 100644
--- a/server/metin2/Source/Server/common/service.h
+++ b/server/metin2/Source/Server/common/service.h
@@ -1,270 +1,267 @@
-#if !defined(__INC_COMMON_SERVICE_H__)
-#define __INC_COMMON_SERVICE_H__
-
-#define __LOCALE_SERVICE_EUROPE__
-#define __LOCALE_SERVICE_OWSAP__
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-///////////////////////////////////////////////////////////////////////// Farques
-#define ENABLE_QUEEN_NETHIS // < Krali챌e Nethis Zindan캇
-#define SORF_TAHTASI
-#ifdef SORF_TAHTASI
-	#define SURFBOARD 40003 // -- S철rf tahtas캇 mob proto id'si yaz캇lcak
-#endif
-#define __YMIR_REGEN_FIX__ // < Ymir regen FIX
-#define MOUNT_FIX // < Binek geri atma fix
-
-//#define __OFFLINE_SHOP__
-//#define __SHOP_SEARCH__
-
-#define ENABLE_EXTENDED_BATTLE_PASS 	// Extended Battlepass-System by Aslan
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	#define RESTRICT_COMMAND_GET_INFO					GM_LOW_WIZARD
-	#define RESTRICT_COMMAND_SET_MISSION				GM_IMPLEMENTOR
-	#define RESTRICT_COMMAND_PREMIUM_ACTIVATE	GM_IMPLEMENTOR	
-#endif
-
-#define __GROWTH_PET_SYSTEM__ // < Offical Pet
-
-
-
-////////////////////////////////////////////////////////////////////////////////
-// Game Related
-#define __MAILBOX__ // Mail Box System
-#define __QUEST_RENEWAL__ // Quest Page Renewal
-#if defined(__QUEST_RENEWAL__)
-#	define __QUEST_EVENT_DAMAGE__ // Damage Quest Event
-#	define __QUEST_EVENT_DEAD__ // Dead Quest Event
-#	define __QUEST_EVENT_FISH__ // Fishing Quest Event
-#	define __QUEST_EVENT_MINE__ // Mining Quest Event
-#	define __QUEST_EVENT_BUY_SELL__ // NPC Buy/Sell Quest Event
-#	define __QUEST_EVENT_CRAFT__ // Craft Quest Event
-#	define __QUEST_EVENT_EMOTION__ // Emotion Quest Event
-#	define __QUEST_EVENT_RESTART_HERE__ // Restart Here Quest Event
-#	define __QUEST_REQUEST_EVENT__ // Request Quest Event
-#endif
-#define __CHATTING_WINDOW_RENEWAL__ // Chatting Window Renewal (Mini Version)
-#define __CUBE_RENEWAL__ // Cube Renewal
-#define __RANKING_SYSTEM__ // Ranking System
-#define __ELEMENT_SYSTEM__ // Element System
-#define __SEND_TARGET_INFO__ // Monster Information & Drops
-#define __PVP_COUNTDOWN__ // PvP Duel Countdown
-#define __REFINE_MSG_ADD__ // Extended refine fail message
-#define __PVP_BALANCE_IMPROVING__ // PvP Balance Improving
-
-////////////////////////////////////////////////////////////////////////////////
-// Map & Dungeon Related
-#define __SNOW_DUNGEON__ // Snow Dungeon
-#define __DUNGEON_RENEWAL__ // Extended Dungeon Functions
-#define __BLUE_DRAGON_RENEWAL__ // Blue Dragon Rework
-#define __MT_THUNDER_DUNGEON__ // Ochao Temple
-#define __DAWNMIST_DUNGEON__ // Erebus Dungeon
-#define __DEFENSE_WAVE__ // Defense Wave
-#define __CLIENT_TIMER__ // Client Timer (Used for instances)
-#define __LABYRINTH_DUNGEON__ // Labyrinth Dungeon (Utils)
-#define __ELEMENTAL_DUNGEON__ // Elemental Dungeon
-#define __GUILD_DRAGONLAIR_SYSTEM__ // Guild Dragon Lair
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-#	define __GUILD_DRAGONLAIR_PARTY_SYSTEM__ // Guild Dragon Lair Party
-#endif
-
-////////////////////////////////////////////////////////////////////////////////
-// Mini-Game Related
-#define __MINI_GAME_RUMI__ // Mini-Game Rumi
-#if defined(__MINI_GAME_RUMI__)
-#	define __OKEY_EVENT_FLAG_RENEWAL__
-#endif
-#define __MINI_GAME_YUTNORI__ // Mini-Game Yutnori
-#if defined(__MINI_GAME_YUTNORI__)
-#	define __YUTNORI_EVENT_FLAG_RENEWAL__
-#endif
-#define __MINI_GAME_CATCH_KING__ // Mini-Game Catch King
-#if defined(__MINI_GAME_CATCH_KING__)
-#	define __CATCH_KING_EVENT_FLAG_RENEWAL__
-#endif
-#define __FISHING_GAME__ // Fishing Game
-#define __SUMMER_EVENT_ROULETTE__ // Mini-Game Roulette (Late Summer Event)
-
-////////////////////////////////////////////////////////////////////////////////
-// Event Related
-#define __EASTER_EVENT__ // Easter Event 2011
-#define __XMAS_EVENT_2008__ // Christmas Event 2008
-#define __XMAS_EVENT_2012__ // Christmas Event 2012
-#define __2016_VALENTINE_EVENT__ // Valentine Event 2016~2024
-#define __HALLOWEEN_EVENT_2014__ // Halloween Event 2011~2014 (Halloween Hair)
-#define __OX_RENEWAL__ // OX Renewal
-#define __EVENT_BANNER_FLAG__ // Event Banner Flags
-#define __METINSTONE_SWAP__ // Swap Stone Shape
-#define __RACE_SWAP__ // Swap Race Shape
-#define __SNOWFLAKE_STICK_EVENT__ // Snowflake Stick Event
-#define __INGAME_EVENT_MANAGER__ // InGame Event Manager
-#define __FLOWER_EVENT__ // Flower Event
-
-////////////////////////////////////////////////////////////////////////////////
-// Currency Related
-#define __CHEQUE_SYSTEM__ // Cheque (Won) System
-#define __GEM_SYSTEM__ // Gem (Gaya) System
-
-////////////////////////////////////////////////////////////////////////////////
-// Shop Related
-#define __SHOPEX_RENEWAL__ // ShopEX Renewal
-#if defined(__SHOPEX_RENEWAL__)
-#	define __SHOPEX_TAB4__ // ShopEx 4 Tabs
-#endif
-//#define __SHOPEX_EMPIRE_TAX__ // ShopEx Tax (Triple Price)
-#define __MYSHOP_DECO__ // Private Shop Decoration
-#define __MYSHOP_EXPANSION__ // Additional Private Shop Tab
-#if defined(__GEM_SYSTEM__)
-#	define __GEM_SHOP__ // Gem (Gaya) Shop
-#endif
-
-////////////////////////////////////////////////////////////////////////////////
-// Dragon Soul Related
-#define __DRAGON_SOUL_SYSTEM__ // Dragon Soul System
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	#define __DS_GRADE_MYTH__ // Dragon Soul Mythical Grade
-	#define __DS_SET__ // Dragon Soul Table Handling
-	#define __DS_CHANGE_ATTR__ // Dragon Soul Change Attribute
-	#define __DS_7_SLOT__ // Dragon Soul 7th Slot
-#endif
-
-////////////////////////////////////////////////////////////////////////////////
-// Pet Related
-#define __PET_SYSTEM__ // Pet System
-#define __PET_LOOT__ // Pet Loot
-//#define __PET_LOOT_AI__ // Pet Loot AI (Goes and picks items)
-
-////////////////////////////////////////////////////////////////////////////////
-// Character Related
-#define __PLAYER_PER_ACCOUNT5__ // Players Per Account (5)
-#define __WOLFMAN_CHARACTER__ // Wolfman Character
-#if defined(__WOLFMAN_CHARACTER__)
-//#	define __DISABLE_WOLFMAN_CREATION__ // Disable Wolfman Creation
-#endif
-#define __VIEW_TARGET_HP__ // View Target HP
-#if defined(__VIEW_TARGET_HP__)
-#	define __VIEW_TARGET_PLAYER_HP__ // View Player Target HP
-#endif
-#define __IMPROVED_LOGOUT_POINTS__ // Improved Logout Points
-#define __EXPRESSING_EMOTIONS__ // Special Actions
-#define __CONQUEROR_LEVEL__ // Conqueror Level
-#define __MULTI_LANGUAGE_SYSTEM__ // Multi Language System
-#define __DELETE_FAILURE_TYPE__ // Delete Character Failure Type
-#define __LEFT_SEAT__ // Left Seat (AFK)
-#define __AFFECT_RENEWAL__ // Affect Renewal
-
-////////////////////////////////////////////////////////////////////////////////
-// Skill Related
-#define __7AND8TH_SKILLS__ // 7th, 8th Passive Skills
-#define __SKILL_COOLTIME_UPDATE__ // Refresh Skill Cooldown After Death
-#define __9TH_SKILL__ // 9th Player Skill
-#define __PARTY_PROFICY__ // Party Proficiency Passive Skill
-#define __PARTY_INSIGHT__ // Party InSight Passive Skill
-
-////////////////////////////////////////////////////////////////////////////////
-// Party & Guild Related
-#define __DICE_SYSTEM__ // New Dice System (Party)
-#define __WJ_SHOW_PARTY_ON_MINIMAP__ // Party Member Atlas (Map)
-#define __PARTY_CHANNEL_FIX__ // Party Channel Fix
-#define __GUILD_LEADER_GRADE_NAME__ // Guild Leader Grade Name (TextTail)
-#define __PARTY_KILL_RENEWAL__ // All kill events count towards the party.
-#define __GUILD_WAR_AUTO_JOIN_LEADER__ // Join the Guild War automatically as the Leader.
-#define __GUILD_EVENT_FLAG__ // Guild Event Flag
-
-////////////////////////////////////////////////////////////////////////////////
-// Messenger Related
-#define __MESSENGER_BLOCK_SYSTEM__ // Messenger Block System
-#define __MESSENGER_GM__ // Messenger GM List
-#define __MESSENGER_DETAILS__ // Messenger Details
-
-////////////////////////////////////////////////////////////////////////////////
-// Inventory Related
-#define __EXTEND_INVEN_SYSTEM__ // Extended Inventory System
-#define __EXTEND_MALLBOX__ // Extended Mallbox
-#define __SAFEBOX_IMPROVING__ // Safebox Improving
-
-////////////////////////////////////////////////////////////////////////////////
-// Equipment Related
-#define __QUIVER_SYSTEM__ // Quiver Equipment
-#define __PENDANT_SYSTEM__ // Talisman Elements
-#define __GLOVE_SYSTEM__ // Glove Equipment
-
-////////////////////////////////////////////////////////////////////////////////
-// Costume Related
-#define __COSTUME_SYSTEM__ // Costume System
-#define __MOUNT_COSTUME_SYSTEM__ // Mount Costume System
-#define __ACCE_COSTUME_SYSTEM__ // Acce (Sash) Costume System
-#define __AURA_COSTUME_SYSTEM__ // Aura Costume System
-#define __WEAPON_COSTUME_SYSTEM__ // Weapon Costume System
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-#	define __HIDE_WEAPON_COSTUME_WITH_NO_MAIN_WEAPON__
-#endif
-#define __MOVE_COSTUME_ATTR__ // Move Costume Attribute (Item Combination)
-#define __HIDE_COSTUME_SYSTEM__ // Hide Costume System
-
-////////////////////////////////////////////////////////////////////////////////
-// Item Related
-#define __MAGIC_REDUCTION__ // Magic Reduction Item
-#define __STONE_OF_BLESS__ // Stone of Bless (Refinement Item)
-#define __REFINE_PICKAXE_RENEWAL__ // Refine Pickaxe Renewal
-#define __REFINE_FISHINGROD_RENEWAL__ // Refine Fishing Rod Renewal
-#define __SOUL_BIND_SYSTEM__ // Seal Scroll System
-#if defined(__SOUL_BIND_SYSTEM__)
-#	define __DRAGON_SOUL_SEAL__ // Dragon Soul Seal
-#	define __UN_SEAL_SCROLL_PLUS__ // Unseal Scroll Plus
-#endif
-//#define __SOUL_SYSTEM__ // Soul System
-#if defined(__SOUL_SYSTEM__)
-#	define __SOUL_SYSTEM_CALC_FINAL_DAMAGE__
-#endif
-#define __ITEM_APPLY4__ // Extended Apply Bonus (4)
-#define __ITEM_SOCKET6__ // Extended Item Sockets (6)
-#define __ITEM_VALUE10__ // Extended Item Values
-#define __ITEM_APPLY_RANDOM__ // Apply Random Bonus (Base Bonus)
-#define __CHANGED_ATTR__ // Change / Select Attribute
-#define __ATTR_6TH_7TH__ // 6th and 7th Attribute
-#define __SKILLBOOK_COMB_SYSTEM__ // Skill Book Combination
-#define __CHANGE_LOOK_SYSTEM__ // Change Look System (Item Look)
-#define __LOOT_FILTER_SYSTEM__ // Looting System
-#if defined(__LOOT_FILTER_SYSTEM__)
-#	define __PREMIUM_LOOT_FILTER__ // Enable Premium Usage of the Loot Filter System
-#endif
-#define __GACHA_SYSTEM__ // Boss (Gacha) Boxes (Open x Times)
-#define __LUCKY_BOX__ // Lucky Box
-#define __SET_ITEM__ // Set Item Bonus
-#define __GEM_CONVERTER__ // Gem Converter
-#define __REFINE_ELEMENT_SYSTEM__ // Refine Element System
-#define __USE_NEXT_AUTO_POTION__ // When the automatic potion runs out, use the next one.
-#define __REFINE_STACK_FIX__ // Refine Stack Fix (Used for stones)
-
-////////////////////////////////////////////////////////////////////////////////
-// UI Related
-#define __WJ_SHOW_MOB_INFO__ // Monsters Level & Aggressive Flag
-#define __WJ_PICKUP_ITEM_EFFECT__ // Picking Item Effect
-#define __NEW_USER_CARE__ // User Care (Control)
-#define __BINARY_ATLAS_MARK_INFO__ // Atlas Mark Info Load
-#define __POPUP_NOTICE__ // Pop-up notification
-#define __NEW_DROP_DIALOG__ // New Drop Dialog w/ Delete Item Option
-#define __ITEM_DROP_RENEWAL__ // Item Drop Renewal w/ Color Effect
-#define __GAME_OPTION_ESCAPE__ // Game Option (Escape)
-
-////////////////////////////////////////////////////////////////////////////////
-// Miscellaneous
-#define __EXTENDED_RELOAD__ // Extended GM Reload Commands (For drops)
-#define __EXTENDED_ITEM_AWARD__ // Extended Item Award
-#define __ENVIRONMENT_SYSTEM__ // Environment System
-#define __LOCALE_CLIENT__ // Locale Client
-
-////////////////////////////////////////////////////////////////////////////////
-// Network Related
-//#define __IMPROVED_PACKET_ENCRYPTION__ // Improved Packet Encryption
-//#define __SEND_SEQUENCE__ // Sequence Matching
-#define __UDP_BLOCK__ // UDP Block
-//#define __ALLOW_EXTERNAL_PEER__ // Allow External Peer API
-#define __PROXY_IP__ // Proxy IP
-#define __MOVE_CHANNEL__ // Move Game Channel
-#define __CHECK_PORT_STATUS__ // Check Port Status
-#define __AUTO_DETECT_INTERNAL_IP__ // Detect Internal IP
-
-#include "disclaimer.h"
-#endif // __INC_COMMON_SERVICE_H__
+#if !defined(__INC_COMMON_SERVICE_H__)
+#define __INC_COMMON_SERVICE_H__
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////// Farques
+#define ENABLE_QUEEN_NETHIS // < Krali챌e Nethis Zindan캇
+#define SORF_TAHTASI
+#ifdef SORF_TAHTASI
+	#define SURFBOARD 40003 // -- S철rf tahtas캇 mob proto id'si yaz캇lcak
+#endif
+#define __YMIR_REGEN_FIX__ // < Ymir regen FIX
+#define MOUNT_FIX // < Binek geri atma fix
+
+//#define __OFFLINE_SHOP__
+//#define __SHOP_SEARCH__
+
+#define ENABLE_EXTENDED_BATTLE_PASS 	// Extended Battlepass-System by Aslan
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	#define RESTRICT_COMMAND_GET_INFO					GM_LOW_WIZARD
+	#define RESTRICT_COMMAND_SET_MISSION				GM_IMPLEMENTOR
+	#define RESTRICT_COMMAND_PREMIUM_ACTIVATE	GM_IMPLEMENTOR	
+#endif
+
+#define __GROWTH_PET_SYSTEM__ // < Offical Pet
+
+
+
+////////////////////////////////////////////////////////////////////////////////
+// Game Related
+#define __MAILBOX__ // Mail Box System
+#define __QUEST_RENEWAL__ // Quest Page Renewal
+#if defined(__QUEST_RENEWAL__)
+#	define __QUEST_EVENT_DAMAGE__ // Damage Quest Event
+#	define __QUEST_EVENT_DEAD__ // Dead Quest Event
+#	define __QUEST_EVENT_FISH__ // Fishing Quest Event
+#	define __QUEST_EVENT_MINE__ // Mining Quest Event
+#	define __QUEST_EVENT_BUY_SELL__ // NPC Buy/Sell Quest Event
+#	define __QUEST_EVENT_CRAFT__ // Craft Quest Event
+#	define __QUEST_EVENT_EMOTION__ // Emotion Quest Event
+#	define __QUEST_EVENT_RESTART_HERE__ // Restart Here Quest Event
+#	define __QUEST_REQUEST_EVENT__ // Request Quest Event
+#endif
+#define __CHATTING_WINDOW_RENEWAL__ // Chatting Window Renewal (Mini Version)
+#define __CUBE_RENEWAL__ // Cube Renewal
+#define __RANKING_SYSTEM__ // Ranking System
+#define __ELEMENT_SYSTEM__ // Element System
+#define __SEND_TARGET_INFO__ // Monster Information & Drops
+#define __PVP_COUNTDOWN__ // PvP Duel Countdown
+#define __REFINE_MSG_ADD__ // Extended refine fail message
+#define __PVP_BALANCE_IMPROVING__ // PvP Balance Improving
+
+////////////////////////////////////////////////////////////////////////////////
+// Map & Dungeon Related
+#define __SNOW_DUNGEON__ // Snow Dungeon
+#define __DUNGEON_RENEWAL__ // Extended Dungeon Functions
+#define __BLUE_DRAGON_RENEWAL__ // Blue Dragon Rework
+#define __MT_THUNDER_DUNGEON__ // Ochao Temple
+#define __DAWNMIST_DUNGEON__ // Erebus Dungeon
+#define __DEFENSE_WAVE__ // Defense Wave
+#define __CLIENT_TIMER__ // Client Timer (Used for instances)
+#define __LABYRINTH_DUNGEON__ // Labyrinth Dungeon (Utils)
+#define __ELEMENTAL_DUNGEON__ // Elemental Dungeon
+#define __GUILD_DRAGONLAIR_SYSTEM__ // Guild Dragon Lair
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+#	define __GUILD_DRAGONLAIR_PARTY_SYSTEM__ // Guild Dragon Lair Party
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// Mini-Game Related
+#define __MINI_GAME_RUMI__ // Mini-Game Rumi
+#if defined(__MINI_GAME_RUMI__)
+#	define __OKEY_EVENT_FLAG_RENEWAL__
+#endif
+#define __MINI_GAME_YUTNORI__ // Mini-Game Yutnori
+#if defined(__MINI_GAME_YUTNORI__)
+#	define __YUTNORI_EVENT_FLAG_RENEWAL__
+#endif
+#define __MINI_GAME_CATCH_KING__ // Mini-Game Catch King
+#if defined(__MINI_GAME_CATCH_KING__)
+#	define __CATCH_KING_EVENT_FLAG_RENEWAL__
+#endif
+#define __FISHING_GAME__ // Fishing Game
+#define __SUMMER_EVENT_ROULETTE__ // Mini-Game Roulette (Late Summer Event)
+
+////////////////////////////////////////////////////////////////////////////////
+// Event Related
+#define __EASTER_EVENT__ // Easter Event 2011
+#define __XMAS_EVENT_2008__ // Christmas Event 2008
+#define __XMAS_EVENT_2012__ // Christmas Event 2012
+#define __2016_VALENTINE_EVENT__ // Valentine Event 2016~2024
+#define __HALLOWEEN_EVENT_2014__ // Halloween Event 2011~2014 (Halloween Hair)
+#define __OX_RENEWAL__ // OX Renewal
+#define __EVENT_BANNER_FLAG__ // Event Banner Flags
+#define __METINSTONE_SWAP__ // Swap Stone Shape
+#define __RACE_SWAP__ // Swap Race Shape
+#define __SNOWFLAKE_STICK_EVENT__ // Snowflake Stick Event
+#define __INGAME_EVENT_MANAGER__ // InGame Event Manager
+#define __FLOWER_EVENT__ // Flower Event
+
+////////////////////////////////////////////////////////////////////////////////
+// Currency Related
+#define __CHEQUE_SYSTEM__ // Cheque (Won) System
+#define __GEM_SYSTEM__ // Gem (Gaya) System
+
+////////////////////////////////////////////////////////////////////////////////
+// Shop Related
+#define __SHOPEX_RENEWAL__ // ShopEX Renewal
+#if defined(__SHOPEX_RENEWAL__)
+#	define __SHOPEX_TAB4__ // ShopEx 4 Tabs
+#endif
+//#define __SHOPEX_EMPIRE_TAX__ // ShopEx Tax (Triple Price)
+#define __MYSHOP_DECO__ // Private Shop Decoration
+#define __MYSHOP_EXPANSION__ // Additional Private Shop Tab
+#if defined(__GEM_SYSTEM__)
+#	define __GEM_SHOP__ // Gem (Gaya) Shop
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// Dragon Soul Related
+#define __DRAGON_SOUL_SYSTEM__ // Dragon Soul System
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	#define __DS_GRADE_MYTH__ // Dragon Soul Mythical Grade
+	#define __DS_SET__ // Dragon Soul Table Handling
+	#define __DS_CHANGE_ATTR__ // Dragon Soul Change Attribute
+	#define __DS_7_SLOT__ // Dragon Soul 7th Slot
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// Pet Related
+#define __PET_SYSTEM__ // Pet System
+#define __PET_LOOT__ // Pet Loot
+//#define __PET_LOOT_AI__ // Pet Loot AI (Goes and picks items)
+
+////////////////////////////////////////////////////////////////////////////////
+// Character Related
+#define __PLAYER_PER_ACCOUNT5__ // Players Per Account (5)
+#define __WOLFMAN_CHARACTER__ // Wolfman Character
+#if defined(__WOLFMAN_CHARACTER__)
+//#	define __DISABLE_WOLFMAN_CREATION__ // Disable Wolfman Creation
+#endif
+#define __VIEW_TARGET_HP__ // View Target HP
+#if defined(__VIEW_TARGET_HP__)
+#	define __VIEW_TARGET_PLAYER_HP__ // View Player Target HP
+#endif
+#define __IMPROVED_LOGOUT_POINTS__ // Improved Logout Points
+#define __EXPRESSING_EMOTIONS__ // Special Actions
+#define __CONQUEROR_LEVEL__ // Conqueror Level
+#define __MULTI_LANGUAGE_SYSTEM__ // Multi Language System
+#define __DELETE_FAILURE_TYPE__ // Delete Character Failure Type
+#define __LEFT_SEAT__ // Left Seat (AFK)
+#define __AFFECT_RENEWAL__ // Affect Renewal
+
+////////////////////////////////////////////////////////////////////////////////
+// Skill Related
+#define __7AND8TH_SKILLS__ // 7th, 8th Passive Skills
+#define __SKILL_COOLTIME_UPDATE__ // Refresh Skill Cooldown After Death
+#define __9TH_SKILL__ // 9th Player Skill
+#define __PARTY_PROFICY__ // Party Proficiency Passive Skill
+#define __PARTY_INSIGHT__ // Party InSight Passive Skill
+
+////////////////////////////////////////////////////////////////////////////////
+// Party & Guild Related
+#define __DICE_SYSTEM__ // New Dice System (Party)
+#define __WJ_SHOW_PARTY_ON_MINIMAP__ // Party Member Atlas (Map)
+#define __PARTY_CHANNEL_FIX__ // Party Channel Fix
+#define __GUILD_LEADER_GRADE_NAME__ // Guild Leader Grade Name (TextTail)
+#define __PARTY_KILL_RENEWAL__ // All kill events count towards the party.
+#define __GUILD_WAR_AUTO_JOIN_LEADER__ // Join the Guild War automatically as the Leader.
+#define __GUILD_EVENT_FLAG__ // Guild Event Flag
+
+////////////////////////////////////////////////////////////////////////////////
+// Messenger Related
+#define __MESSENGER_BLOCK_SYSTEM__ // Messenger Block System
+#define __MESSENGER_GM__ // Messenger GM List
+#define __MESSENGER_DETAILS__ // Messenger Details
+
+////////////////////////////////////////////////////////////////////////////////
+// Inventory Related
+#define __EXTEND_INVEN_SYSTEM__ // Extended Inventory System
+#define __EXTEND_MALLBOX__ // Extended Mallbox
+#define __SAFEBOX_IMPROVING__ // Safebox Improving
+
+////////////////////////////////////////////////////////////////////////////////
+// Equipment Related
+#define __QUIVER_SYSTEM__ // Quiver Equipment
+#define __PENDANT_SYSTEM__ // Talisman Elements
+#define __GLOVE_SYSTEM__ // Glove Equipment
+
+////////////////////////////////////////////////////////////////////////////////
+// Costume Related
+#define __COSTUME_SYSTEM__ // Costume System
+#define __MOUNT_COSTUME_SYSTEM__ // Mount Costume System
+#define __ACCE_COSTUME_SYSTEM__ // Acce (Sash) Costume System
+#define __AURA_COSTUME_SYSTEM__ // Aura Costume System
+#define __WEAPON_COSTUME_SYSTEM__ // Weapon Costume System
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+#	define __HIDE_WEAPON_COSTUME_WITH_NO_MAIN_WEAPON__
+#endif
+#define __MOVE_COSTUME_ATTR__ // Move Costume Attribute (Item Combination)
+#define __HIDE_COSTUME_SYSTEM__ // Hide Costume System
+
+////////////////////////////////////////////////////////////////////////////////
+// Item Related
+#define __MAGIC_REDUCTION__ // Magic Reduction Item
+#define __STONE_OF_BLESS__ // Stone of Bless (Refinement Item)
+#define __REFINE_PICKAXE_RENEWAL__ // Refine Pickaxe Renewal
+#define __REFINE_FISHINGROD_RENEWAL__ // Refine Fishing Rod Renewal
+#define __SOUL_BIND_SYSTEM__ // Seal Scroll System
+#if defined(__SOUL_BIND_SYSTEM__)
+#	define __DRAGON_SOUL_SEAL__ // Dragon Soul Seal
+#	define __UN_SEAL_SCROLL_PLUS__ // Unseal Scroll Plus
+#endif
+//#define __SOUL_SYSTEM__ // Soul System
+#if defined(__SOUL_SYSTEM__)
+#	define __SOUL_SYSTEM_CALC_FINAL_DAMAGE__
+#endif
+#define __ITEM_APPLY4__ // Extended Apply Bonus (4)
+#define __ITEM_SOCKET6__ // Extended Item Sockets (6)
+#define __ITEM_VALUE10__ // Extended Item Values
+#define __ITEM_APPLY_RANDOM__ // Apply Random Bonus (Base Bonus)
+#define __CHANGED_ATTR__ // Change / Select Attribute
+#define __ATTR_6TH_7TH__ // 6th and 7th Attribute
+#define __SKILLBOOK_COMB_SYSTEM__ // Skill Book Combination
+#define __CHANGE_LOOK_SYSTEM__ // Change Look System (Item Look)
+#define __LOOT_FILTER_SYSTEM__ // Looting System
+#if defined(__LOOT_FILTER_SYSTEM__)
+#	define __PREMIUM_LOOT_FILTER__ // Enable Premium Usage of the Loot Filter System
+#endif
+#define __GACHA_SYSTEM__ // Boss (Gacha) Boxes (Open x Times)
+#define __LUCKY_BOX__ // Lucky Box
+#define __SET_ITEM__ // Set Item Bonus
+#define __GEM_CONVERTER__ // Gem Converter
+#define __REFINE_ELEMENT_SYSTEM__ // Refine Element System
+#define __USE_NEXT_AUTO_POTION__ // When the automatic potion runs out, use the next one.
+#define __REFINE_STACK_FIX__ // Refine Stack Fix (Used for stones)
+
+////////////////////////////////////////////////////////////////////////////////
+// UI Related
+#define __WJ_SHOW_MOB_INFO__ // Monsters Level & Aggressive Flag
+#define __WJ_PICKUP_ITEM_EFFECT__ // Picking Item Effect
+#define __NEW_USER_CARE__ // User Care (Control)
+#define __BINARY_ATLAS_MARK_INFO__ // Atlas Mark Info Load
+#define __POPUP_NOTICE__ // Pop-up notification
+#define __NEW_DROP_DIALOG__ // New Drop Dialog w/ Delete Item Option
+#define __ITEM_DROP_RENEWAL__ // Item Drop Renewal w/ Color Effect
+#define __GAME_OPTION_ESCAPE__ // Game Option (Escape)
+
+////////////////////////////////////////////////////////////////////////////////
+// Miscellaneous
+#define __EXTENDED_RELOAD__ // Extended GM Reload Commands (For drops)
+#define __EXTENDED_ITEM_AWARD__ // Extended Item Award
+#define __ENVIRONMENT_SYSTEM__ // Environment System
+#define __LOCALE_CLIENT__ // Locale Client
+
+////////////////////////////////////////////////////////////////////////////////
+// Network Related
+//#define __IMPROVED_PACKET_ENCRYPTION__ // Improved Packet Encryption
+//#define __SEND_SEQUENCE__ // Sequence Matching
+#define __UDP_BLOCK__ // UDP Block
+//#define __ALLOW_EXTERNAL_PEER__ // Allow External Peer API
+#define __PROXY_IP__ // Proxy IP
+#define __MOVE_CHANNEL__ // Move Game Channel
+#define __CHECK_PORT_STATUS__ // Check Port Status
+#define __AUTO_DETECT_INTERNAL_IP__ // Detect Internal IP
+
+#include "disclaimer.h"
+#endif // __INC_COMMON_SERVICE_H__
diff --git a/server/metin2/Source/Server/db/src/ClientManager.cpp b/server/metin2/Source/Server/db/src/ClientManager.cpp
index 0d59167..5b25a4a 100644
--- a/server/metin2/Source/Server/db/src/ClientManager.cpp
+++ b/server/metin2/Source/Server/db/src/ClientManager.cpp
@@ -1,5926 +1,6001 @@
-#include "stdafx.h"
-
-#include "../../common/building.h"
-#include "../../common/VnumHelper.h"
-#include "../../libgame/include/grid.h"
-
-#include "ClientManager.h"
-
-#include "Main.h"
-#include "Config.h"
-#include "DBManager.h"
-#include "QID.h"
-#include "GuildManager.h"
-#include "PrivManager.h"
-#include "MoneyLog.h"
-#include "ItemAwardManager.h"
-#include "Marriage.h"
-#include "Monarch.h"
-#include "BlockCountry.h"
-#include "ItemIDRangeManager.h"
-#include "Cache.h"
-
-#include <sstream>
-#if defined(__SHOP_SEARCH__)
-	#include "ShopSearchManager.h"
-#endif
-
-extern int g_iPlayerCacheFlushSeconds;
-extern int g_iItemCacheFlushSeconds;
-extern int g_test_server;
-extern int g_log;
-extern std::string g_stLocale;
-extern std::string g_stLocaleNameColumn;
-bool CreateItemTableFromRes(MYSQL_RES* res, std::vector<TPlayerItem>* pVec, DWORD dwPID);
-
-DWORD g_dwUsageMax = 0;
-DWORD g_dwUsageAvg = 0;
-
-CPacketInfo g_query_info;
-CPacketInfo g_item_info;
-
-int g_item_count = 0;
-int g_query_count[2];
-
-CClientManager::CClientManager() :
-	m_pkAuthPeer(NULL),
-	m_iPlayerIDStart(0),
-	m_iPlayerDeleteLevelLimit(0),
-	m_iPlayerDeleteLevelLimitLower(0),
-	m_bChinaEventServer(false),
-	m_iShopTableSize(0),
-	m_pShopTable(NULL),
-	m_iRefineTableSize(0),
-	m_pRefineTable(NULL),
-	m_bShutdowned(false),
-	m_iCacheFlushCount(0),
-	m_iCacheFlushCountLimit(200)
-#if defined(__EXPRESSING_EMOTIONS__)
-	, m_iEmoteDumpDelay(3600)
-#endif
-#if defined(__MAILBOX__)
-	, m_iMailBoxBackupSec(3600)
-#endif
-#if defined(__GEM_SHOP__)
-	, m_iGemShopFlushDelay(3600)
-#endif
-{
-	m_itemRange.dwMin = 0;
-	m_itemRange.dwMax = 0;
-	m_itemRange.dwUsableItemIDMin = 0;
-
-	memset(g_query_count, 0, sizeof(g_query_count));
-}
-
-CClientManager::~CClientManager()
-{
-	Destroy();
-}
-
-void CClientManager::SetPlayerIDStart(int iIDStart)
-{
-	m_iPlayerIDStart = iIDStart;
-}
-
-void CClientManager::Destroy()
-{
-	m_mChannelStatus.clear();
-	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		(*i)->Destroy();
-
-	m_peerList.clear();
-
-	if (m_fdAccept > 0)
-	{
-		socket_close(m_fdAccept);
-		m_fdAccept = -1;
-	}
-}
-
-bool CClientManager::Initialize()
-{
-	int tmpValue;
-
-	// BOOT_LOCALIZATION
-	if (!InitializeLocalization())
-	{
-		fprintf(stderr, "Failed Localization Infomation so exit\n");
-		return false;
-	}
-	// END_BOOT_LOCALIZATION
-
-	// ITEM_UNIQUE_ID
-	if (!InitializeNowItemID())
-	{
-		fprintf(stderr, " Item range Initialize Failed. Exit DBCache Server\n");
-		return false;
-	}
-	// END_ITEM_UNIQUE_ID
-
-	m_bWolfmanCharacter = true;
-	int iWolfmanCharacter = 0;
-	if (CConfig::instance().GetValue("WOLFMAN_CHARACTER", &iWolfmanCharacter))
-		m_bWolfmanCharacter = (iWolfmanCharacter);
-	sys_log(0, "WOLFMAN_CHARACTER %s", m_bWolfmanCharacter ? "true" : "false");
-
-	m_bDelayedCharacterCreation = true;
-	int iDelayedCharacterCreation = 0;
-	if (CConfig::instance().GetValue("DELAYED_CHARACTER_CREATION", &iDelayedCharacterCreation))
-		m_bDelayedCharacterCreation = (iDelayedCharacterCreation);
-	sys_log(0, "DELAYED_CHARACTER_CREATION %s", m_bDelayedCharacterCreation ? "true" : "false");
-
-	if (!InitializeTables())
-	{
-		sys_err("Table Initialize FAILED");
-		return false;
-	}
-
-	CGuildManager::instance().BootReserveWar();
-
-	if (!CConfig::instance().GetValue("BIND_PORT", &tmpValue))
-		tmpValue = 5300;
-
-	char szBindIP[128];
-
-	if (!CConfig::instance().GetValue("BIND_IP", szBindIP, 128))
-		strlcpy(szBindIP, "0", sizeof(szBindIP));
-
-	m_fdAccept = socket_tcp_bind(szBindIP, tmpValue);
-
-	if (m_fdAccept < 0)
-	{
-		perror("socket");
-		return false;
-	}
-
-	sys_log(0, "ACCEPT_HANDLE: %u", m_fdAccept);
-	fdwatch_add_fd(m_fdWatcher, m_fdAccept, NULL, FDW_READ, false);
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	CConfig::instance().GetValue("EMOTE_DUMP_DELAY", &m_iEmoteDumpDelay);
-#endif
-
-#if defined(__MAILBOX__)
-	CConfig::instance().GetValue("MAILBOX_BACKUP_SEC", &m_iMailBoxBackupSec);
-#endif
-
-#if defined(__GEM_SHOP__)
-	CConfig::instance().GetValue("GEM_SHOP_FLUSH_DELAY", &m_iGemShopFlushDelay);
-#endif
-
-	if (!CConfig::instance().GetValue("BACKUP_LIMIT_SEC", &tmpValue))
-		tmpValue = 600;
-
-	m_looping = true;
-
-	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT", &m_iPlayerDeleteLevelLimit))
-	{
-		sys_err("config.txt: Cannot find PLAYER_DELETE_LEVEL_LIMIT, use default level %d", PLAYER_MAX_LEVEL_CONST + 1);
-		m_iPlayerDeleteLevelLimit = PLAYER_MAX_LEVEL_CONST + 1;
-	}
-
-	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT_LOWER", &m_iPlayerDeleteLevelLimitLower))
-	{
-		m_iPlayerDeleteLevelLimitLower = 0;
-	}
-
-	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT set to %d", m_iPlayerDeleteLevelLimit);
-	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT_LOWER set to %d", m_iPlayerDeleteLevelLimitLower);
-
-	m_bChinaEventServer = false;
-
-	int iChinaEventServer = 0;
-
-	if (CConfig::instance().GetValue("CHINA_EVENT_SERVER", &iChinaEventServer))
-		m_bChinaEventServer = (iChinaEventServer);
-
-	sys_log(0, "CHINA_EVENT_SERVER %s", CClientManager::instance().IsChinaEventServer() ? "true" : "false");
-
-	LoadEventFlag();
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	LoadGuildEventFlag();
-#endif
-
-	// database character-set을 강제로 맞춤
-	if (g_stLocale == "big5" || g_stLocale == "sjis")
-		CDBManager::instance().QueryLocaleSet();
-
-	return true;
-}
-
-void CClientManager::MainLoop()
-{
-	SQLMsg* tmp;
-
-	sys_log(0, "ClientManager pointer is %p", this);
-
-	// 메인루프
-	while (!m_bShutdowned)
-	{
-		while ((tmp = CDBManager::instance().PopResult()))
-		{
-			AnalyzeQueryResult(tmp);
-			delete tmp;
-		}
-
-		if (!Process())
-			break;
-
-		log_rotate();
-	}
-
-	//
-	// 메인루프 종료처리
-	//
-	sys_log(0, "MainLoop exited, Starting cache flushing");
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	CClientManager::instance().QUERY_EMOTE_DUMP();
-#endif
-
-#if defined(__MAILBOX__)
-	CClientManager::instance().MAILBOX_BACKUP();
-#endif
-
-#if defined(__GEM_SHOP__)
-	// Gem Shop Item Data List Flush
-	CClientManager::instance().FlushGemShop();
-#endif
-
-	signal_timer_disable();
-
-	// 플레이어 테이블 캐쉬 플러쉬
-	auto it = m_map_playerCache.begin();
-	while (it != m_map_playerCache.end())
-	{
-		CPlayerTableCache* c = (it++)->second;
-
-		c->Flush();
-		delete c;
-	}
-	m_map_playerCache.clear();
-
-	// 아이템 플러쉬
-	auto it2 = m_map_itemCache.begin();
-	while (it2 != m_map_itemCache.end())
-	{
-		CItemCache* c = (it2++)->second;
-
-		c->Flush();
-		delete c;
-	}
-	m_map_itemCache.clear();
-
-	// MYSHOP_PRICE_LIST
-	//
-	// 개인상점 아이템 가격 리스트 Flush
-	//
-	for (auto itPriceList = m_mapItemPriceListCache.begin(); itPriceList != m_mapItemPriceListCache.end(); ++itPriceList)
-	{
-		CItemPriceListTableCache* pCache = itPriceList->second;
-		pCache->Flush();
-		delete pCache;
-	}
-
-	m_mapItemPriceListCache.clear();
-#ifdef __OFFLINE_SHOP__
-	FlushOfflineShops();
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	auto growthPetCache = m_map_growthPetCache.begin();
-
-	while (growthPetCache != m_map_growthPetCache.end())
-	{
-		CGrowthPetCache* c = (growthPetCache++)->second;
-
-		c->Flush();
-		delete c;
-	}
-	m_map_growthPetCache.clear();
-#endif
-
-	// END_OF_MYSHOP_PRICE_LIST
-}
-
-void CClientManager::Quit()
-{
-	m_bShutdowned = true;
-}
-
-void CClientManager::QUERY_BOOT(CPeer* peer, TPacketGDBoot* p)
-{
-	const BYTE bPacketVersion = 6; // BOOT 패킷이 바뀔때마다 번호를 올리도록 한다.
-
-	std::vector<tAdminInfo> vAdmin;
-	std::vector<std::string> vHost;
-
-	__GetHostInfo(vHost);
-	__GetAdminInfo(p->szIP, vAdmin);
-
-	sys_log(0, "QUERY_BOOT : AdminInfo (Request ServerIp %s) ", p->szIP);
-
-	DWORD dwPacketSize =
-		sizeof(DWORD) +
-		sizeof(BYTE) +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TShopTable) * m_iShopTableSize +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemAttrTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemRareTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(building::TLand) * m_vec_kLandTable.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObjectProto) * m_vec_kObjectProto.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObject) * m_map_pkObjectTable.size() +
-#ifdef __GROWTH_PET_SYSTEM__
-		sizeof(WORD) + sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size() +
-#endif
-		sizeof(time_t) +
-		sizeof(WORD) + sizeof(WORD) + sizeof(TItemIDRangeTable) * 2 +
-		// ADMIN_MANAGER
-		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size() +
-		sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
-		// END_ADMIN_MANAGER
-		sizeof(WORD) + sizeof(WORD) + sizeof(TMonarchInfo) +
-		sizeof(WORD) + sizeof(WORD) + sizeof(MonarchCandidacy) * CMonarch::instance().MonarchCandidacySize() +
-		sizeof(WORD);
-
-	peer->EncodeHeader(HEADER_DG_BOOT, 0, dwPacketSize);
-	peer->Encode(&dwPacketSize, sizeof(DWORD));
-	peer->Encode(&bPacketVersion, sizeof(BYTE));
-
-	sys_log(0, "BOOT: PACKET: %d", dwPacketSize);
-	sys_log(0, "BOOT: VERSION: %d", bPacketVersion);
-
-	sys_log(0, "sizeof(TMobTable) = %d", sizeof(TMobTable));
-	sys_log(0, "sizeof(TItemTable) = %d", sizeof(TItemTable));
-	sys_log(0, "sizeof(TShopTable) = %d", sizeof(TShopTable));
-	sys_log(0, "sizeof(TSkillTable) = %d", sizeof(TSkillTable));
-	sys_log(0, "sizeof(TRefineTable) = %d", sizeof(TRefineTable));
-	sys_log(0, "sizeof(TItemAttrTable) = %d", sizeof(TItemAttrTable));
-	sys_log(0, "sizeof(TItemRareTable) = %d", sizeof(TItemAttrTable));
-	sys_log(0, "sizeof(TBanwordTable) = %d", sizeof(TBanwordTable));
-	sys_log(0, "sizeof(TLand) = %d", sizeof(building::TLand));
-	sys_log(0, "sizeof(TObjectProto) = %d", sizeof(building::TObjectProto));
-	sys_log(0, "sizeof(TObject) = %d", sizeof(building::TObject));
-	// ADMIN_MANAGER
-	sys_log(0, "sizeof(tAdminInfo) = %d * %d ", sizeof(tAdminInfo) * vAdmin.size());
-	// END_ADMIN_MANAGER
-	sys_log(0, "sizeof(TMonarchInfo) = %d * %d", sizeof(TMonarchInfo));
-#ifdef __GROWTH_PET_SYSTEM__
-	sys_log(0, "sizeof(TGrowthPetSkillTable) = %d", sizeof(TGrowthPetSkillTable));
-#endif
-
-	peer->EncodeWORD(sizeof(TMobTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
-	peer->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
-
-	peer->EncodeWORD(sizeof(TItemTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
-	peer->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
-
-	peer->EncodeWORD(sizeof(TShopTable));
-	peer->EncodeWORD(m_iShopTableSize);
-	peer->Encode(m_pShopTable, sizeof(TShopTable) * m_iShopTableSize);
-
-	peer->EncodeWORD(sizeof(TSkillTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
-	peer->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
-
-	peer->EncodeWORD(sizeof(TRefineTable));
-	peer->EncodeWORD(m_iRefineTableSize);
-	peer->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
-
-	peer->EncodeWORD(sizeof(TItemAttrTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_itemAttrTable.size()));
-	peer->Encode(&m_vec_itemAttrTable[0], sizeof(TItemAttrTable) * m_vec_itemAttrTable.size());
-
-	peer->EncodeWORD(sizeof(TItemAttrTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_itemRareTable.size()));
-	peer->Encode(&m_vec_itemRareTable[0], sizeof(TItemAttrTable) * m_vec_itemRareTable.size());
-
-	peer->EncodeWORD(sizeof(TBanwordTable));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
-	peer->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
-
-	peer->EncodeWORD(sizeof(building::TLand));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_kLandTable.size()));
-	peer->Encode(&m_vec_kLandTable[0], sizeof(building::TLand) * m_vec_kLandTable.size());
-
-	peer->EncodeWORD(sizeof(building::TObjectProto));
-	peer->EncodeWORD(static_cast<WORD>(m_vec_kObjectProto.size()));
-	peer->Encode(&m_vec_kObjectProto[0], sizeof(building::TObjectProto) * m_vec_kObjectProto.size());
-
-	peer->EncodeWORD(sizeof(building::TObject));
-	peer->EncodeWORD(static_cast<WORD>(m_map_pkObjectTable.size()));
-
-	auto it = m_map_pkObjectTable.begin();
-	while (it != m_map_pkObjectTable.end())
-		peer->Encode((it++)->second, sizeof(building::TObject));
-
-#ifdef __GROWTH_PET_SYSTEM__
-	peer->EncodeWORD(sizeof(TGrowthPetSkillTable));
-	peer->EncodeWORD(m_vec_growthPetSkillTable.size());
-	if (m_vec_growthPetSkillTable.size())
-		peer->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
-#endif
-
-	time_t now = time(0);
-	peer->Encode(&now, sizeof(time_t));
-
-	TItemIDRangeTable itemRange = CItemIDRangeManager::instance().GetRange();
-	TItemIDRangeTable itemRangeSpare = CItemIDRangeManager::instance().GetRange();
-
-	peer->EncodeWORD(sizeof(TItemIDRangeTable));
-	peer->EncodeWORD(1);
-	peer->Encode(&itemRange, sizeof(TItemIDRangeTable));
-	peer->Encode(&itemRangeSpare, sizeof(TItemIDRangeTable));
-
-	peer->SetItemIDRange(itemRange);
-	peer->SetSpareItemIDRange(itemRangeSpare);
-
-	// ADMIN_MANAGER
-	peer->EncodeWORD(16);
-	peer->EncodeWORD(static_cast<WORD>(vHost.size()));
-
-	for (size_t n = 0; n < vHost.size(); ++n)
-	{
-		peer->Encode(vHost[n].c_str(), 16);
-		sys_log(0, "GMHosts %s", vHost[n].c_str());
-	}
-
-	peer->EncodeWORD(sizeof(tAdminInfo));
-	peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
-
-	for (size_t n = 0; n < vAdmin.size(); ++n)
-	{
-		peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
-		sys_log(0, "Admin name %s ConntactIP %s", vAdmin[n].m_szName, vAdmin[n].m_szContactIP);
-	}
-	// END_ADMIN_MANAGER
-
-	// MONARCH
-	peer->EncodeWORD(sizeof(TMonarchInfo));
-	peer->EncodeWORD(1);
-	peer->Encode(CMonarch::instance().GetMonarch(), sizeof(TMonarchInfo));
-
-	CMonarch::VEC_MONARCHCANDIDACY& rVecMonarchCandidacy = CMonarch::instance().GetVecMonarchCandidacy();
-
-	size_t num_monarch_candidacy = CMonarch::instance().MonarchCandidacySize();
-	peer->EncodeWORD(sizeof(MonarchCandidacy));
-	peer->EncodeWORD(static_cast<WORD>(num_monarch_candidacy));
-	if (num_monarch_candidacy != 0)
-	{
-		peer->Encode(&rVecMonarchCandidacy[0], sizeof(MonarchCandidacy) * num_monarch_candidacy);
-	}
-	// END_MONARCE
-
-	if (g_test_server)
-		sys_log(0, "MONARCHCandidacy Size %d", CMonarch::instance().MonarchCandidacySize());
-
-#ifdef __OFFLINE_SHOP__
-	peer->EncodeDWORD(sizeof(TOfflineShop));
-	peer->EncodeDWORD(offlineShopCache_.size());
-	for (const auto& entry : offlineShopCache_) {
-		peer->Encode(entry.second->Get(), sizeof(TOfflineShop));
-	}
-
-	peer->EncodeDWORD(sizeof(TOfflineShopItem));
-	peer->EncodeDWORD(offlineShopItemCache_.size());
-	for (const auto& entry : offlineShopItemCache_) {
-		peer->Encode(entry.second->Get(), sizeof(TOfflineShopItem));
-	}
-#endif
-
-	peer->EncodeWORD(0xffff);
-}
-
-void CClientManager::SendPartyOnSetup(CPeer* pkPeer)
-{
-	TPartyMap& pm = m_map_pkChannelParty[pkPeer->GetChannel()];
-	for (auto it_party = pm.begin(); it_party != pm.end(); ++it_party)
-	{
-		sys_log(0, "PARTY SendPartyOnSetup Party [%u]", it_party->first);
-		pkPeer->EncodeHeader(HEADER_DG_PARTY_CREATE, 0, sizeof(TPacketPartyCreate));
-		pkPeer->Encode(&it_party->first, sizeof(DWORD));
-
-		for (auto it_member = it_party->second.begin(); it_member != it_party->second.end(); ++it_member)
-		{
-			sys_log(0, "PARTY SendPartyOnSetup Party [%u] Member [%u]", it_party->first, it_member->first);
-			pkPeer->EncodeHeader(HEADER_DG_PARTY_ADD, 0, sizeof(TPacketPartyAdd));
-			pkPeer->Encode(&it_party->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->second.bRole, sizeof(BYTE));
-
-			pkPeer->EncodeHeader(HEADER_DG_PARTY_SET_MEMBER_LEVEL, 0, sizeof(TPacketPartySetMemberLevel));
-			pkPeer->Encode(&it_party->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->first, sizeof(DWORD));
-			pkPeer->Encode(&it_member->second.bLevel, sizeof(BYTE));
-		}
-	}
-}
-
-void CClientManager::QUERY_PLAYER_COUNT(CPeer* pkPeer, TPlayerCountPacket* pPacket)
-{
-	pkPeer->SetUserCount(pPacket->dwCount);
-}
-
-void CClientManager::QUERY_QUEST_SAVE(CPeer* pkPeer, TQuestTable* pTable, DWORD dwLen)
-{
-	if (0 != (dwLen % sizeof(TQuestTable)))
-	{
-		sys_err("invalid packet size %d, sizeof(TQuestTable) == %d", dwLen, sizeof(TQuestTable));
-		return;
-	}
-
-	int iSize = dwLen / sizeof(TQuestTable);
-
-	char szQuery[1024];
-
-	for (int i = 0; i < iSize; ++i, ++pTable)
-	{
-		if (pTable->lValue == 0)
-		{
-			snprintf(szQuery, sizeof(szQuery), "DELETE FROM quest%s WHERE `dwPID` = %d AND `szName` = '%s' AND `szState` ='%s'",
-				GetTablePostfix(), pTable->dwPID, pTable->szName, pTable->szState);
-		}
-		else
-		{
-			snprintf(szQuery, sizeof(szQuery), "REPLACE INTO quest%s (`dwPID`, `szName`, `szState`, `lValue`) VALUES(%d, '%s', '%s', %ld)",
-				GetTablePostfix(), pTable->dwPID, pTable->szName, pTable->szState, pTable->lValue);
-		}
-
-		CDBManager::instance().ReturnQuery(szQuery, QID_QUEST_SAVE, pkPeer->GetHandle(), NULL);
-	}
-}
-
-void CClientManager::QUERY_SAFEBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TSafeboxLoadPacket* packet, bool bMall)
-{
-	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
-	strlcpy(pi->safebox_password, packet->szPassword, sizeof(pi->safebox_password));
-	pi->account_id = packet->dwID;
-	pi->account_index = 0;
-	pi->ip[0] = bMall ? 1 : 0;
-	strlcpy(pi->login, packet->szLogin, sizeof(pi->login));
-
-	char szQuery[QUERY_MAX_LEN];
-	snprintf(szQuery, sizeof(szQuery),
-		"SELECT `account_id`, `size`, `password` FROM safebox%s WHERE `account_id` = %u",
-		GetTablePostfix(), packet->dwID);
-
-	if (g_log)
-		sys_log(0, "HEADER_GD_SAFEBOX_LOAD (handle: %d account.id %u is_mall %d)", dwHandle, packet->dwID, bMall ? 1 : 0);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
-}
-
-void CClientManager::RESULT_SAFEBOX_LOAD(CPeer* pkPeer, SQLMsg* msg)
-{
-	sys_log(0, "RESULT_SAFEBOX_LOAD");
-
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = pi->dwHandle;
-
-	// 여기에서 사용하는 account_index는 쿼리 순서를 말한다.
-	// 첫번째 패스워드 알아내기 위해 하는 쿼리가 0
-	// 두번째 실제 데이터를 얻어놓는 쿼리가 1
-
-	if (pi->account_index == 0)
-	{
-		sys_log(0, "RESULT_SAFEBOX_LOAD account_index == 0");
-
-		char szSafeboxPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
-		strlcpy(szSafeboxPassword, pi->safebox_password, sizeof(szSafeboxPassword));
-
-		TSafeboxTable* pSafebox = new TSafeboxTable;
-		memset(pSafebox, 0, sizeof(TSafeboxTable));
-
-		SQLResult* res = msg->Get();
-
-		if (res->uiNumRows == 0)
-		{
-			if (strcmp("000000", szSafeboxPassword))
-			{
-				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
-				delete pSafebox;
-				delete pi;
-				return;
-			}
-		}
-		else
-		{
-			sys_log(0, "RESULT_SAFEBOX_LOAD get rows");
-
-			MYSQL_ROW row = mysql_fetch_row(res->pSQLResult);
-
-			// 비밀번호가 틀리면..
-			if (((!row[2] || !*row[2]) && strcmp("000000", szSafeboxPassword)) ||
-				((row[2] && *row[2]) && strcmp(row[2], szSafeboxPassword)))
-			{
-				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
-				delete pSafebox;
-				delete pi;
-				return;
-			}
-
-			if (!row[0])
-				pSafebox->dwID = 0;
-			else
-				str_to_number(pSafebox->dwID, row[0]);
-
-			if (!row[1])
-				pSafebox->bSize = 0;
-			else
-				str_to_number(pSafebox->bSize, row[1]);
-			/*
-			if (!row[3])
-				pSafebox->dwGold = 0;
-			else
-				pSafebox->dwGold = atoi(row[3]);
-			*/
-			if (pi->ip[0] == 1)
-			{
-#if defined(__EXTEND_MALLBOX__)
-				pSafebox->bSize = 5;
-#else
-				pSafebox->bSize = 1;
-#endif
-				sys_log(0, "MALL id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
-			}
-			else
-				sys_log(0, "SAFEBOX id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
-		}
-
-		if (0 == pSafebox->dwID)
-			pSafebox->dwID = pi->account_id;
-
-		pi->pSafebox = pSafebox;
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
-#if defined(__SOUL_BIND_SYSTEM__)
-			", `soulbind`"
-#endif
-			", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-			", `socket3`, `socket4`, `socket5`"
-#endif
-			", `attrtype0`, `attrvalue0`"
-			", `attrtype1`, `attrvalue1`"
-			", `attrtype2`, `attrvalue2`"
-			", `attrtype3`, `attrvalue3`"
-			", `attrtype4`, `attrvalue4`"
-			", `attrtype5`, `attrvalue5`"
-			", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			", `transmutation`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			", `refine_element_apply_type`"
-			", `refine_element_grade`"
-			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			", `apply_type0`, `apply_value0`, `apply_path0`"
-			", `apply_type1`, `apply_value1`, `apply_path1`"
-			", `apply_type2`, `apply_value2`, `apply_path2`"
-			", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-			", `set_value`"
-#endif
-			" FROM `item%s` WHERE `owner_id` = %u AND `window` = '%s'",
-			GetTablePostfix(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL");
-
-		pi->account_index = 1;
-
-		CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
-	}
-	else
-	{
-		sys_log(0, "RESULT_SAFEBOX_LOAD YES!!!!!!!!!!!");
-
-		if (!pi->pSafebox)
-		{
-			sys_err("null safebox pointer!");
-			delete pi;
-			return;
-		}
-
-		// 쿼리에 에러가 있었으므로 응답할 경우 창고가 비어있는 것 처럼
-		// 보이기 때문에 창고가 아얘 안열리는게 나음
-		if (!msg->Get()->pSQLResult)
-		{
-			sys_err("null safebox result");
-			delete pi;
-			return;
-		}
-
-		static std::vector<TPlayerItem> s_items;
-		CreateItemTableFromRes(msg->Get()->pSQLResult, &s_items, pi->account_id);
-
-		ItemAwardSet* pSet = ItemAwardManager::instance().GetByLogin(pi->login);
-
-		if (pSet && !m_vec_itemTable.empty())
-		{
-#if defined(__EXTEND_MALLBOX__)
-			CGrid grid(5, MAX(1, 5) * 9);
-#else
-			CGrid grid(5, MAX(1, pi->pSafebox->bSize) * 9);
-#endif
-			bool bEscape = false;
-
-			for (DWORD i = 0; i < s_items.size(); ++i)
-			{
-				TPlayerItem& r = s_items[i];
-
-				auto it = m_map_itemTableByVnum.find(r.dwVnum);
-				if (it == m_map_itemTableByVnum.end())
-				{
-					bEscape = true;
-					sys_err("invalid item vnum %u in safebox: login %s", r.dwVnum, pi->login);
-					break;
-				}
-
-				grid.Put(r.wPos, 1, it->second->bSize);
-			}
-
-			if (!bEscape)
-			{
-				std::vector<std::pair<DWORD, DWORD> > vec_dwFinishedAwardID;
-				ItemAwardSet::const_iterator it = pSet->begin();
-				char szQuery[512];
-
-				while (it != pSet->end())
-				{
-					TItemAward* pItemAward = *(it++);
-					const DWORD& dwItemVnum = pItemAward->dwVnum;
-
-					if (pItemAward->bTaken)
-						continue;
-
-					if (pi->ip[0] == 0 && pItemAward->bMall)
-						continue;
-
-					if (pi->ip[0] == 1 && !pItemAward->bMall)
-						continue;
-
-					auto it = m_map_itemTableByVnum.find(pItemAward->dwVnum);
-					if (it == m_map_itemTableByVnum.end())
-					{
-						sys_err("invalid item vnum %u in item_award: login %s", pItemAward->dwVnum, pi->login);
-						continue;
-					}
-
-					TItemTable* pItemTable = it->second;
-
-					int iPos;
-
-					if ((iPos = grid.FindBlank(1, it->second->bSize)) == -1)
-						break;
-
-					TPlayerItem item;
-					memset(&item, 0, sizeof(TPlayerItem));
-
-#if defined(__EXTENDED_ITEM_AWARD__)
-					DWORD dwSocket0 = pItemAward->dwSocket0;
-					DWORD dwSocket2 = pItemAward->dwSocket2;
-					DWORD dwSocket4 = pItemAward->dwSocket4;
-					DWORD dwSocket5 = pItemAward->dwSocket5;
-#else
-					DWORD dwSocket2 = 0;
-#endif
-
-					if (pItemTable->bType == ITEM_UNIQUE)
-					{
-#if defined(__EXTENDED_ITEM_AWARD__)
-						// 12.04.2019 - Correction for unique items based on the real time.
-						const long lValue0 = pItemTable->alValues[ITEM_SOCKET_REMAIN_SEC];
-						const long lValue2 = pItemTable->alValues[ITEM_SOCKET_UNIQUE_REMAIN_TIME];
-						const time_t tNow = CClientManager::instance().GetCurrentTime();
-						dwSocket2 = (lValue2 == 0) ? static_cast<DWORD>(lValue0) : static_cast<DWORD>(tNow + lValue0);
-#else
-						if (pItemAward->dwSocket2 != 0)
-							dwSocket2 = pItemAward->dwSocket2;
-						else
-							dwSocket2 = pItemTable->alValues[0];
-#endif
-					}
-					else if ((dwItemVnum == ITEM_SKILLBOOK_VNUM || dwItemVnum == ITEM_SKILLFORGET_VNUM) && pItemAward->dwSocket0 == 0)
-					{
-						DWORD dwSkillIdx;
-						DWORD dwSkillVnum;
-
-						do
-						{
-							dwSkillIdx = number(0, m_vec_skillTable.size() - 1);
-
-							dwSkillVnum = m_vec_skillTable[dwSkillIdx].dwVnum;
-
-							if (dwSkillVnum > 120)
-								continue;
-
-							break;
-						} while (1);
-
-#if !defined(__EXTENDED_ITEM_AWARD__)
-						pItemAward->dwSocket0 = dwSkillVnum;
-#endif
-					}
-					else
-					{
-						switch (dwItemVnum)
-						{
-							case 72723: case 72724: case 72725: case 72726:
-							case 72727: case 72728: case 72729: case 72730:
-								// 무시무시하지만 이전에 하던 걸 고치기는 무섭고...
-								// 그래서 그냥 하드 코딩. 선물 상자용 자동물약 아이템들.
-							case 76004: case 76005: case 76021: case 76022:
-							case 79012: case 79013:
-								if (pItemAward->dwSocket2 == 0)
-								{
-									dwSocket2 = pItemTable->alValues[0];
-								}
-								else
-								{
-									dwSocket2 = pItemAward->dwSocket2;
-								}
-								break;
-						}
-					}
-
-					if (GetItemID() > m_itemRange.dwMax)
-					{
-						sys_err("UNIQUE ID OVERFLOW!!");
-						break;
-					}
-
-					{
-						auto it = m_map_itemTableByVnum.find(dwItemVnum);
-						if (it == m_map_itemTableByVnum.end())
-						{
-							sys_err("Invalid item(vnum : %d). It is not in m_map_itemTableByVnum.", dwItemVnum);
-							continue;
-						}
-						TItemTable* item_table = it->second;
-						if (item_table == NULL)
-						{
-							sys_err("Invalid item_table (vnum : %d). It's value is NULL in m_map_itemTableByVnum.", dwItemVnum);
-							continue;
-						}
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-						if ((item_table->bType == ITEM_UNIQUE && item_table->bType == COSTUME_MOUNT))
-						{
-							if (pItemAward->dwSocket4 == 0)
-								dwSocket4 = pItemTable->alValues[0];
-							else
-								dwSocket4 = pItemAward->dwSocket4;
-						}
-#endif
-
-						if (0 == pItemAward->dwSocket0)
-						{
-							// Load default values
-							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-							{
-								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
-									break;
-								}
-								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
-									break;
-								}
-							}
-						}
-						else
-						{
-#if defined(__EXTENDED_ITEM_AWARD__)
-							// Load set values
-							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-							{
-								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
-								{
-									dwSocket0 = time(0) + pItemAward->dwSocket0;
-									break;
-								}
-								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
-								{
-									dwSocket0 = pItemAward->dwSocket0;
-									break;
-								}
-							}
-#else
-							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
-							{
-								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
-
-									break;
-								}
-								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
-								{
-									if (0 == item_table->aLimits[i].lValue)
-										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
-									else
-										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
-
-									break;
-								}
-							}
-#endif
-						}
-
-#if defined(__EXTENDED_ITEM_AWARD__)
-						ItemAwardManager::instance().CheckItemCount(*pItemAward, *pItemTable);
-						ItemAwardManager::instance().CheckItemBlend(*pItemAward, *pItemTable);
-						ItemAwardManager::instance().CheckItemAddonType(*pItemAward, *pItemTable);
-						ItemAwardManager::instance().CheckItemSkillBook(*pItemAward, m_vec_skillTable);
-						ItemAwardManager::instance().CheckItemAttributes(*pItemAward, *pItemTable, m_vec_itemAttrTable);
-
-						// START_OF_AUTO_QUERY
-						char szColumns[QUERY_MAX_LEN], szValues[QUERY_MAX_LEN];
-
-						int iLen = snprintf(szColumns, sizeof(szColumns), "`id`, `owner_id`, `window`, `pos`, `vnum`, `count`");
-						int iValueLen = snprintf(szValues, sizeof(szValues), "%u, %u, '%s', %d, %u, %u", GainItemID(), pi->account_id, (pi->ip[0] == 0) ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount);
-
-#if defined(__ITEM_SOCKET6__)
-						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`, `socket3`, `socket4`, `socket5`");
-						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u, %u, %u, %u", dwSocket0, pItemAward->dwSocket1, dwSocket2, pItemAward->dwSocket3, pItemAward->dwSocket4, pItemAward->dwSocket5);
-#else
-						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`");
-						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u", pItemAward->dwSocket0, pItemAward->dwSocket1, dwSocket2);
-#endif
-
-						for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
-						{
-							iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `attrtype%d`, `attrvalue%d`", i, i);
-							iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %ld", pItemAward->aAttr[i].wType, pItemAward->aAttr[i].lValue);
-						}
-						// END_OF_AUTO_QUERY
-
-						snprintf(szQuery, sizeof(szQuery), "INSERT INTO item%s (%s) VALUES(%s)", GetTablePostfix(), szColumns, szValues);
-#else
-						snprintf(szQuery, sizeof(szQuery),
-							"INSERT INTO item%s (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
-							", `socket0`"
-							", `socket1`"
-							", `socket2`"
-#if defined(__ITEM_SOCKET6__)
-							", `socket3`"
-							", `socket4`"
-							", `socket5`"
-#endif
-							") VALUES (%u, %u, '%s', %d, %u, %u"
-							", %u"
-							", %u"
-							", %u"
-#if defined(__ITEM_SOCKET6__)
-							", %u"
-							", %u"
-							", %u"
-#endif
-							")",
-							GetTablePostfix(), GainItemID(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount
-							, pItemAward->dwSocket0
-							, pItemAward->dwSocket1
-							, dwSocket2
-#if defined(__ITEM_SOCKET6__)
-							, pItemAward->dwSocket3
-							, pItemAward->dwSocket4
-							, pItemAward->dwSocket5
-#endif
-						);
-#endif
-					}
-
-					std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-					SQLResult* pRes = pmsg->Get();
-					sys_log(0, "SAFEBOX Query : [%s]", szQuery);
-
-					if (pRes->uiAffectedRows == 0 || pRes->uiInsertID == 0 || pRes->uiAffectedRows == (uint32_t)-1)
-						break;
-
-					item.dwID = pmsg->Get()->uiInsertID;
-					if (pi->ip[0] == 0)
-						item.bWindow = SAFEBOX, item.wPos = iPos;
-					else
-						item.bWindow = MALL, item.wPos = iPos;
-					item.dwVnum = pItemAward->dwVnum;
-					item.dwCount = pItemAward->dwCount;
-#if defined(__EXTENDED_ITEM_AWARD__)
-					item.alSockets[0] = dwSocket0;
-#else
-					item.alSockets[0] = pItemAward->dwSocket0;
-#endif
-					item.alSockets[1] = pItemAward->dwSocket1;
-					item.alSockets[2] = dwSocket2;
-#if defined(__ITEM_SOCKET6__)
-					item.alSockets[3] = pItemAward->dwSocket3;
-					item.alSockets[4] = dwSocket4;
-					item.alSockets[5] = dwSocket5;
-#endif
-#if defined(__EXTENDED_ITEM_AWARD__)
-					thecore_memcpy(&item.aAttr, pItemAward->aAttr, sizeof(item.aAttr));
-#endif
-					s_items.push_back(item);
-
-					vec_dwFinishedAwardID.push_back(std::make_pair(pItemAward->dwID, item.dwID));
-					grid.Put(iPos, 1, it->second->bSize);
-				}
-
-				for (DWORD i = 0; i < vec_dwFinishedAwardID.size(); ++i)
-					ItemAwardManager::instance().Taken(vec_dwFinishedAwardID[i].first, vec_dwFinishedAwardID[i].second);
-			}
-		}
-
-		pi->pSafebox->wItemCount = static_cast<WORD>(s_items.size());
-
-#ifdef __GROWTH_PET_SYSTEM__
-		static std::vector<TGrowthPet> s_petVec;
-
-		// Loads pets only when opening safebox with items
-		if (pi->ip[0] == 0 && !s_items.empty())
-		{
-			char szQuery[QUERY_MAX_LEN];
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT id,vnum,state+0,name,size,level,level_step,evolution,type,hp,sp,def,hp_apply,sp_apply,def_apply,"
-				"age_apply,skill_level,exp,item_exp,UNIX_TIMESTAMP(birthday),end_time,max_time "
-				"FROM growth_pet%s WHERE owner_id=%d AND state=%d",
-				GetTablePostfix(), pi->account_id, STATE_SAFEBOX);
-
-			std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(szQuery));
-			MYSQL_RES* pRes = pkMsg->Get()->pSQLResult;
-			CreateGrowthPetTableFromRes(pRes, &s_petVec, pi->account_id);
-		}
-#endif
-
-		if (pi->ip[0] == 0)
-			pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
-#ifdef __GROWTH_PET_SYSTEM__
-			+ sizeof(WORD) + sizeof(TGrowthPet) * s_petVec.size()
-#endif
-		);
-		else
-			pkPeer->EncodeHeader(HEADER_DG_MALL_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
-
-		);
-
-		pkPeer->Encode(pi->pSafebox, sizeof(TSafeboxTable));
-
-		if (!s_items.empty())
-			pkPeer->Encode(&s_items[0], sizeof(TPlayerItem) * s_items.size());
-
-#ifdef __GROWTH_PET_SYSTEM__
-		pkPeer->EncodeWORD((WORD)s_petVec.size());
-
-		if (!s_petVec.empty())
-			pkPeer->Encode(&s_petVec[0], sizeof(TGrowthPet) * s_petVec.size());
-#endif
-
-		delete pi;
-	}
-}
-
-void CClientManager::QUERY_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangeSizePacket* p)
-{
-	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
-	pi->account_index = p->bSize; // account_index를 사이즈로 임시로 사용
-
-	char szQuery[QUERY_MAX_LEN];
-
-	if (p->bSize == 1)
-		snprintf(szQuery, sizeof(szQuery), "INSERT INTO safebox%s (`account_id`, `size`) VALUES(%u, %u)", GetTablePostfix(), p->dwID, p->bSize);
-	else
-		snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `size` = %u WHERE `account_id` = %u", GetTablePostfix(), p->bSize, p->dwID);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_SIZE, pkPeer->GetHandle(), pi);
-}
-
-void CClientManager::RESULT_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = p->dwHandle;
-	BYTE bSize = p->account_index;
-
-	delete p;
-
-	if (msg->Get()->uiNumRows > 0)
-	{
-		pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_SIZE, dwHandle, sizeof(BYTE));
-		pkPeer->EncodeBYTE(bSize);
-	}
-}
-
-void CClientManager::QUERY_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangePasswordPacket* p)
-{
-	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
-	strlcpy(pi->safebox_password, p->szNewPassword, sizeof(pi->safebox_password));
-	strlcpy(pi->login, p->szOldPassword, sizeof(pi->login));
-	pi->account_id = p->dwID;
-
-	char szQuery[QUERY_MAX_LEN];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `password` FROM safebox%s WHERE `account_id` = %u", GetTablePostfix(), p->dwID);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD, pkPeer->GetHandle(), pi);
-}
-
-void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = p->dwHandle;
-
-	if (msg->Get()->uiNumRows > 0)
-	{
-		MYSQL_ROW row = mysql_fetch_row(msg->Get()->pSQLResult);
-
-		if ((row[0] && *row[0] && !strcasecmp(row[0], p->login)) || ((!row[0] || !*row[0]) && !strcmp("000000", p->login)))
-		{
-			char szQuery[QUERY_MAX_LEN];
-			char escape_pwd[64];
-			CDBManager::instance().EscapeString(escape_pwd, p->safebox_password, strlen(p->safebox_password));
-
-			snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `password` = '%s' WHERE `account_id` = %u", GetTablePostfix(), escape_pwd, p->account_id);
-
-			CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD_SECOND, pkPeer->GetHandle(), p);
-			return;
-		}
-	}
-
-	delete p;
-
-	// Wrong old password
-	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
-	pkPeer->EncodeBYTE(0);
-}
-
-void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(CPeer* pkPeer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
-	DWORD dwHandle = p->dwHandle;
-	delete p;
-
-	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
-	pkPeer->EncodeBYTE(1);
-}
-
-// MYSHOP_PRICE_LIST
-void CClientManager::RESULT_PRICELIST_LOAD(CPeer* peer, SQLMsg* pMsg)
-{
-	TItemPricelistReqInfo* pReqInfo = (TItemPricelistReqInfo*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
-
-	//
-	// DB 에서 로드한 정보를 Cache 에 저장
-	//
-
-	TItemPriceListTable table;
-	table.dwOwnerID = pReqInfo->second;
-	table.byCount = 0;
-
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
-		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
-#if defined(__CHEQUE_SYSTEM__)
-		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
-#endif
-		table.byCount++;
-	}
-
-	PutItemPriceListCache(&table);
-
-	//
-	// 로드한 데이터를 Game server 에 전송
-	//
-
-	TPacketMyshopPricelistHeader header;
-
-	header.dwOwnerID = pReqInfo->second;
-	header.byCount = table.byCount;
-
-	size_t sizePriceListSize = sizeof(TItemPriceInfo) * header.byCount;
-
-	peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, pReqInfo->first, sizeof(header) + sizePriceListSize);
-	peer->Encode(&header, sizeof(header));
-	peer->Encode(table.aPriceInfo, sizePriceListSize);
-
-	sys_log(0, "Load MyShopPricelist handle[%d] pid[%d] count[%d]", pReqInfo->first, pReqInfo->second, header.byCount);
-
-	delete pReqInfo;
-}
-
-void CClientManager::RESULT_PRICELIST_LOAD_FOR_UPDATE(SQLMsg* pMsg)
-{
-	TItemPriceListTable* pUpdateTable = (TItemPriceListTable*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
-
-	//
-	// DB 에서 로드한 정보를 Cache 에 저장
-	//
-
-	TItemPriceListTable table{};
-	table.dwOwnerID = pUpdateTable->dwOwnerID;
-	table.byCount = 0;
-
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
-		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
-#if defined(__CHEQUE_SYSTEM__)
-		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
-#endif
-		table.byCount++;
-	}
-
-	PutItemPriceListCache(&table);
-
-	// Update cache
-	GetItemPriceListCache(pUpdateTable->dwOwnerID)->UpdateList(pUpdateTable);
-
-	delete pUpdateTable;
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-void CClientManager::QUERY_SAFEBOX_SAVE(CPeer* pkPeer, TSafeboxTable* pTable)
-{
-	char szQuery[QUERY_MAX_LEN];
-
-	snprintf(szQuery, sizeof(szQuery),
-		"UPDATE safebox%s SET `gold` = '%u' WHERE `account_id` = %u",
-		GetTablePostfix(), pTable->dwGold, pTable->dwID);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_SAVE, pkPeer->GetHandle(), NULL);
-}
-
-void CClientManager::QUERY_EMPIRE_SELECT(CPeer* pkPeer, DWORD dwHandle, TEmpireSelectPacket* p)
-{
-	char szQuery[QUERY_MAX_LEN];
-
-	snprintf(szQuery, sizeof(szQuery), "UPDATE player_index%s SET `empire` = %u WHERE `id` = %u", GetTablePostfix(), p->bEmpire, p->dwAccountID);
-	delete CDBManager::instance().DirectQuery(szQuery);
-
-	sys_log(0, "EmpireSelect: %s", szQuery);
-	{
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `pid1`"
-			", `pid2`"
-			", `pid3`"
-			", `pid4`"
-#if defined(__PLAYER_PER_ACCOUNT5__)
-			", `pid5`"
-#endif
-			" FROM player_index%s WHERE `id` = %u", GetTablePostfix(), p->dwAccountID);
-
-		std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-		SQLResult* pRes = pmsg->Get();
-
-		if (pRes->uiNumRows)
-		{
-			sys_log(0, "EMPIRE %lu", pRes->uiNumRows);
-
-			MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
-			DWORD pids[3];
-
-			UINT g_start_map[4] =
-			{
-				0, // reserved
-				1, // 신수국
-				21, // 천조국
-				41 // 진노국
-			};
-
-			// FIXME share with game
-			DWORD g_start_position[4][2] =
-			{
-				{ 0, 0 },
-				{ 469300, 964200 }, // 신수국
-				{ 55700, 157900 }, // 천조국
-				{ 969600, 278400 } // 진노국
-			};
-
-			for (int i = 0; i < 3; ++i)
-			{
-				str_to_number(pids[i], row[i]);
-				sys_log(0, "EMPIRE PIDS[%d]", pids[i]);
-
-				if (pids[i])
-				{
-					sys_log(0, "EMPIRE move to pid[%d] to villiage of %u, map_index %d",
-						pids[i], p->bEmpire, g_start_map[p->bEmpire]);
-
-					snprintf(szQuery, sizeof(szQuery), "UPDATE player%s SET `map_index` = %u, `x` = %u, `y` = %u WHERE `id` = %u",
-						GetTablePostfix(),
-						g_start_map[p->bEmpire],
-						g_start_position[p->bEmpire][0],
-						g_start_position[p->bEmpire][1],
-						pids[i]);
-
-					std::unique_ptr<SQLMsg> pmsg2(CDBManager::instance().DirectQuery(szQuery));
-				}
-			}
-		}
-	}
-
-	pkPeer->EncodeHeader(HEADER_DG_EMPIRE_SELECT, dwHandle, sizeof(BYTE));
-	pkPeer->EncodeBYTE(p->bEmpire);
-}
-
-void CClientManager::QUERY_SETUP(CPeer* peer, DWORD dwHandle, const char* c_pData)
-{
-	TPacketGDSetup* p = (TPacketGDSetup*)c_pData;
-	c_pData += sizeof(TPacketGDSetup);
-
-	if (p->bAuthServer)
-	{
-		sys_log(0, "AUTH_PEER ptr %p", peer);
-
-		m_pkAuthPeer = peer;
-		return;
-	}
-
-	peer->SetPublicIP(p->szPublicIP);
-	peer->SetChannel(p->bChannel);
-	peer->SetListenPort(p->wListenPort);
-	peer->SetP2PPort(p->wP2PPort);
-	peer->SetMaps(p->alMaps);
-
-	//
-	// 어떤 맵이 어떤 서버에 있는지 보내기
-	//
-	TMapLocation kMapLocations;
-
-	strlcpy(kMapLocations.szHost, peer->GetPublicIP(), sizeof(kMapLocations.szHost));
-	kMapLocations.wPort = peer->GetListenPort();
-	thecore_memcpy(kMapLocations.alMaps, peer->GetMaps(), sizeof(kMapLocations.alMaps));
-
-	BYTE bMapCount;
-
-	std::vector<TMapLocation> vec_kMapLocations;
-
-	if (peer->GetChannel() == 1)
-	{
-		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		{
-			CPeer* tmp = *i;
-
-			if (tmp == peer)
-				continue;
-
-			if (!tmp->GetChannel())
-				continue;
-
-			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
-			{
-				TMapLocation kMapLocation2;
-				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
-				kMapLocation2.wPort = tmp->GetListenPort();
-				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
-				vec_kMapLocations.push_back(kMapLocation2);
-
-				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
-				bMapCount = 1;
-				tmp->EncodeBYTE(bMapCount);
-				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
-			}
-		}
-	}
-	else if (peer->GetChannel() == GUILD_WARP_WAR_CHANNEL)
-	{
-		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		{
-			CPeer* tmp = *i;
-
-			if (tmp == peer)
-				continue;
-
-			if (!tmp->GetChannel())
-				continue;
-
-			if (tmp->GetChannel() == 1 || tmp->GetChannel() == peer->GetChannel())
-			{
-				TMapLocation kMapLocation2;
-				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
-				kMapLocation2.wPort = tmp->GetListenPort();
-				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
-				vec_kMapLocations.push_back(kMapLocation2);
-			}
-
-			tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
-			bMapCount = 1;
-			tmp->EncodeBYTE(bMapCount);
-			tmp->Encode(&kMapLocations, sizeof(TMapLocation));
-		}
-	}
-	else
-	{
-		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-		{
-			CPeer* tmp = *i;
-
-			if (tmp == peer)
-				continue;
-
-			if (!tmp->GetChannel())
-				continue;
-
-			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
-			{
-				TMapLocation kMapLocation2;
-
-				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
-				kMapLocation2.wPort = tmp->GetListenPort();
-				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
-
-				vec_kMapLocations.push_back(kMapLocation2);
-			}
-
-			if (tmp->GetChannel() == peer->GetChannel())
-			{
-				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
-				bMapCount = 1;
-				tmp->EncodeBYTE(bMapCount);
-				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
-			}
-		}
-	}
-
-	vec_kMapLocations.push_back(kMapLocations);
-
-	peer->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation) * vec_kMapLocations.size());
-	bMapCount = static_cast<BYTE>(vec_kMapLocations.size());
-	peer->EncodeBYTE(bMapCount);
-	peer->Encode(&vec_kMapLocations[0], sizeof(TMapLocation) * vec_kMapLocations.size());
-
-	//
-	// 셋업 : 접속한 피어에 다른 피어들이 접속하게 만든다. (P2P 컨넥션 생성)
-	//
-	sys_log(0, "SETUP: channel %u listen %u p2p %u count %u", peer->GetChannel(), p->wListenPort, p->wP2PPort, bMapCount);
-
-	TPacketDGP2P p2pSetupPacket;
-	p2pSetupPacket.wPort = peer->GetP2PPort();
-	p2pSetupPacket.bChannel = peer->GetChannel();
-	strlcpy(p2pSetupPacket.szHost, peer->GetPublicIP(), sizeof(p2pSetupPacket.szHost));
-
-	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* tmp = *i;
-
-		if (tmp == peer)
-			continue;
-
-		// 채널이 0이라면 아직 SETUP 패킷이 오지 않은 피어 또는 auth라고 간주할 수 있음
-		if (0 == tmp->GetChannel())
-			continue;
-
-		tmp->EncodeHeader(HEADER_DG_P2P, 0, sizeof(TPacketDGP2P));
-		tmp->Encode(&p2pSetupPacket, sizeof(TPacketDGP2P));
-	}
-
-	//
-	// 로그인 및 빌링정보 보내기
-	//
-	TPacketLoginOnSetup* pck = (TPacketLoginOnSetup*)c_pData;
-
-	for (DWORD c = 0; c < p->dwLoginCount; ++c, ++pck)
-	{
-		CLoginData* pkLD = new CLoginData;
-
-		pkLD->SetKey(pck->dwLoginKey);
-		pkLD->SetClientKey(pck->adwClientKey);
-		pkLD->SetIP(pck->szHost);
-
-		TAccountTable& r = pkLD->GetAccountRef();
-
-		r.id = pck->dwID;
-		trim_and_lower(pck->szLogin, r.login, sizeof(r.login));
-		strlcpy(r.social_id, pck->szSocialID, sizeof(r.social_id));
-		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		strlcpy(r.country, pck->szCountry, sizeof(r.country));
-#endif
-
-		InsertLoginData(pkLD);
-
-		if (InsertLogonAccount(pck->szLogin, peer->GetHandle(), pck->szHost))
-		{
-			sys_log(0, "SETUP: login %u %s login_key %u host %s", pck->dwID, pck->szLogin, pck->dwLoginKey, pck->szHost);
-			pkLD->SetPlay(true);
-		}
-		else
-			sys_log(0, "SETUP: login_fail %u %s login_key %u", pck->dwID, pck->szLogin, pck->dwLoginKey);
-	}
-
-	SendPartyOnSetup(peer);
-
-	CGuildManager::instance().OnSetup(peer);
-	CPrivManager::instance().SendPrivOnSetup(peer);
-
-	SendEventFlagsOnSetup(peer);
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	SendGuildEventFlagsOnSetup(peer);
-#endif
-
-	marriage::CManager::instance().OnSetup(peer);
-}
-
-void CClientManager::QUERY_ITEM_FLUSH(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwID = *(DWORD*)c_pData;
-
-	if (g_log)
-		sys_log(0, "HEADER_GD_ITEM_FLUSH: %u", dwID);
-
-	CItemCache* c = GetItemCache(dwID);
-
-	if (c)
-		c->Flush();
-}
-
-void CClientManager::QUERY_ITEM_SAVE(CPeer* pkPeer, const char* c_pData)
-{
-	TPlayerItem* p = (TPlayerItem*)c_pData;
-
-	// 창고면 캐쉬하지 않고, 캐쉬에 있던 것도 빼버려야 한다.
-
-	if (p->bWindow == SAFEBOX || p->bWindow == MALL
-	)
-	{
-		CItemCache* c = GetItemCache(p->dwID);
-
-		if (c)
-		{
-			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
-
-			if (it != m_map_pkItemCacheSetPtr.end())
-			{
-				if (g_test_server)
-					sys_log(0, "ITEM_CACHE: safebox owner %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-
-				it->second->erase(c);
-			}
-
-			m_map_itemCache.erase(p->dwID);
-
-			delete c;
-		}
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"REPLACE INTO `item%s` (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
-#if defined(__SOUL_BIND_SYSTEM__)
-			", `soulbind`"
-#endif
-			", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-			", `socket3`, `socket4`, `socket5`"
-#endif
-			", `attrtype0`, `attrvalue0`"
-			", `attrtype1`, `attrvalue1`"
-			", `attrtype2`, `attrvalue2`"
-			", `attrtype3`, `attrvalue3`"
-			", `attrtype4`, `attrvalue4`"
-			", `attrtype5`, `attrvalue5`"
-			", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			", `transmutation`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			", `refine_element_apply_type`"
-			", `refine_element_grade`"
-			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			", `apply_type0`, `apply_value0`, `apply_path0`"
-			", `apply_type1`, `apply_value1`, `apply_path1`"
-			", `apply_type2`, `apply_value2`, `apply_path2`"
-			", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-			", `set_value`"
-#endif
-			") VALUES(%u, %u, %u, %u, %u, %u"
-#if defined(__SOUL_BIND_SYSTEM__)
-			", %ld"
-#endif
-			", %ld, %ld, %ld"
-#if defined(__ITEM_SOCKET6__)
-			", %ld, %ld, %ld"
-#endif
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-			", %u, %ld"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			", %u"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			", %u"
-			", %u"
-			", %u, %u, %u"
-			", %u, %u, %u"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			", %u, %ld, %u"
-			", %u, %ld, %u"
-			", %u, %ld, %u"
-			", %u, %ld, %u"
-#endif
-#if defined(__SET_ITEM__)
-			", %u"
-#endif
-			")", GetTablePostfix()
-			, p->dwID
-			, p->dwOwner
-			, p->bWindow
-			, p->wPos
-			, p->dwVnum
-			, p->dwCount
-#if defined(__SOUL_BIND_SYSTEM__)
-			, p->lSealDate
-#endif
-			, p->alSockets[0], p->alSockets[1], p->alSockets[2]
-#if defined(__ITEM_SOCKET6__)
-			, p->alSockets[3], p->alSockets[4], p->alSockets[5]
-#endif
-			, p->aAttr[0].wType, p->aAttr[0].lValue
-			, p->aAttr[1].wType, p->aAttr[1].lValue
-			, p->aAttr[2].wType, p->aAttr[2].lValue
-			, p->aAttr[3].wType, p->aAttr[3].lValue
-			, p->aAttr[4].wType, p->aAttr[4].lValue
-			, p->aAttr[5].wType, p->aAttr[5].lValue
-			, p->aAttr[6].wType, p->aAttr[6].lValue
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			, p->dwTransmutationVnum
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			, p->RefineElement.wApplyType
-			, p->RefineElement.bGrade
-			, p->RefineElement.abValue[0], p->RefineElement.abValue[1], p->RefineElement.abValue[2]
-			, p->RefineElement.abBonusValue[0], p->RefineElement.abBonusValue[1], p->RefineElement.abBonusValue[2]
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			, p->aApplyRandom[0].wType, p->aApplyRandom[0].lValue, p->aApplyRandom[0].bPath
-			, p->aApplyRandom[1].wType, p->aApplyRandom[1].lValue, p->aApplyRandom[1].bPath
-			, p->aApplyRandom[2].wType, p->aApplyRandom[2].lValue, p->aApplyRandom[2].bPath
-			, p->aApplyRandom[3].wType, p->aApplyRandom[3].lValue, p->aApplyRandom[3].bPath
-#endif
-#if defined(__SET_ITEM__)
-			, p->bSetValue
-#endif
-		);
-
-		CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_SAVE, pkPeer->GetHandle(), NULL);
-	}
-	else
-	{
-		if (g_test_server)
-			sys_log(0, "QUERY_ITEM_SAVE => PutItemCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
-
-		PutItemCache(p);
-	}
-}
-
-CClientManager::TItemCacheSet* CClientManager::GetItemCacheSet(DWORD pid)
-{
-	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
-
-	if (it == m_map_pkItemCacheSetPtr.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::CreateItemCacheSet(DWORD pid)
-{
-	if (m_map_pkItemCacheSetPtr.find(pid) != m_map_pkItemCacheSetPtr.end())
-		return;
-
-	TItemCacheSet* pSet = new TItemCacheSet;
-	m_map_pkItemCacheSetPtr.insert(TItemCacheSetPtrMap::value_type(pid, pSet));
-
-	if (g_log)
-		sys_log(0, "ITEM_CACHE: new cache %u", pid);
-}
-
-void CClientManager::FlushItemCacheSet(DWORD pid)
-{
-	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
-
-	if (it == m_map_pkItemCacheSetPtr.end())
-	{
-		sys_log(0, "FLUSH_ITEMCACHESET : No ItemCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TItemCacheSet* pSet = it->second;
-	TItemCacheSet::iterator it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CItemCache* c = *it_set++;
-		c->Flush();
-
-		m_map_itemCache.erase(c->Get()->dwID);
-		delete c;
-	}
-
-	pSet->clear();
-	delete pSet;
-
-	m_map_pkItemCacheSetPtr.erase(it);
-
-	if (g_log)
-		sys_log(0, "FLUSH_ITEMCACHESET : Deleted pid(%d)", pid);
-}
-
-CItemCache* CClientManager::GetItemCache(DWORD id)
-{
-	TItemCacheMap::iterator it = m_map_itemCache.find(id);
-
-	if (it == m_map_itemCache.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::PutItemCache(TPlayerItem* pNew, bool bSkipQuery)
-{
-	CItemCache* c;
-
-	c = GetItemCache(pNew->dwID);
-
-	// 아이템 새로 생성
-	if (!c)
-	{
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: PutItemCache ==> New CItemCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
-
-		c = new CItemCache;
-		m_map_itemCache.insert(TItemCacheMap::value_type(pNew->dwID, c));
-	}
-	// 있을시
-	else
-	{
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: PutItemCache ==> Have Cache");
-
-		// 소유자가 틀리면
-		if (pNew->dwOwner != c->Get()->dwOwner)
-		{
-			// 이미 이 아이템을 가지고 있었던 유저로 부터 아이템을 삭제한다.
-			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
-
-			if (it != m_map_pkItemCacheSetPtr.end())
-			{
-				if (g_log)
-					sys_log(0, "ITEM_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
-				it->second->erase(c);
-			}
-		}
-	}
-
-	// 새로운 정보 업데이트
-	c->Put(pNew, bSkipQuery);
-
-	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
-
-	if (it != m_map_pkItemCacheSetPtr.end())
-	{
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		it->second->insert(c);
-	}
-	else
-	{
-		// 현재 소유자가 없으므로 바로 저장해야 다음 접속이 올 때 SQL에 쿼리하여
-		// 받을 수 있으므로 바로 저장한다.
-		if (g_log)
-			sys_log(0, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-
-		c->OnFlush();
-	}
-}
-
-bool CClientManager::DeleteItemCache(DWORD dwID)
-{
-	CItemCache* c = GetItemCache(dwID);
-
-	if (!c)
-		return false;
-
-	c->Delete();
-	return true;
-}
-
-// MYSHOP_PRICE_LIST
-CItemPriceListTableCache* CClientManager::GetItemPriceListCache(DWORD dwID)
-{
-	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.find(dwID);
-
-	if (it == m_mapItemPriceListCache.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::PutItemPriceListCache(const TItemPriceListTable* pItemPriceList)
-{
-	CItemPriceListTableCache* pCache = GetItemPriceListCache(pItemPriceList->dwOwnerID);
-
-	if (!pCache)
-	{
-		pCache = new CItemPriceListTableCache;
-		m_mapItemPriceListCache.insert(TItemPriceListCacheMap::value_type(pItemPriceList->dwOwnerID, pCache));
-	}
-
-	pCache->Put(const_cast<TItemPriceListTable*>(pItemPriceList), true);
-}
-
-void CClientManager::UpdatePlayerCache()
-{
-	TPlayerTableCacheMap::iterator it = m_map_playerCache.begin();
-
-	while (it != m_map_playerCache.end())
-	{
-		CPlayerTableCache* c = (it++)->second;
-
-		if (c->CheckTimeout())
-		{
-			if (g_log)
-				sys_log(0, "UPDATE : UpdatePlayerCache() ==> FlushPlayerCache %d %s ", c->Get(false)->id, c->Get(false)->name);
-
-			c->Flush();
-
-			// Item Cache도 업데이트
-			UpdateItemCacheSet(c->Get()->id);
-#ifdef __GROWTH_PET_SYSTEM__
-			UpdateGrowthPetCacheSet(c->Get()->id);
-#endif
-		}
-		else if (c->CheckFlushTimeout())
-			c->Flush();
-	}
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-void CClientManager::SetCacheFlushCountLimit(int iLimit)
-{
-	m_iCacheFlushCountLimit = MAX(10, iLimit);
-	sys_log(0, "CACHE_FLUSH_LIMIT_PER_SECOND: %d", m_iCacheFlushCountLimit);
-}
-
-void CClientManager::UpdateItemCache()
-{
-	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-		return;
-
-	TItemCacheMap::iterator it = m_map_itemCache.begin();
-
-	while (it != m_map_itemCache.end())
-	{
-		CItemCache* c = (it++)->second;
-
-		// 아이템은 Flush만 한다.
-		if (c->CheckFlushTimeout())
-		{
-			if (g_test_server)
-				sys_log(0, "UpdateItemCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
-
-			c->Flush();
-
-			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-				break;
-		}
-	}
-}
-
-void CClientManager::UpdateItemPriceListCache()
-{
-	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.begin();
-
-	while (it != m_mapItemPriceListCache.end())
-	{
-		CItemPriceListTableCache* pCache = it->second;
-
-		if (pCache->CheckFlushTimeout())
-		{
-			pCache->Flush();
-			m_mapItemPriceListCache.erase(it++);
-		}
-		else
-			++it;
-	}
-}
-
-void CClientManager::QUERY_ITEM_DESTROY(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwID = *(DWORD*)c_pData;
-	c_pData += sizeof(DWORD);
-
-	DWORD dwPID = *(DWORD*)c_pData;
-
-	if (!DeleteItemCache(dwID))
-	{
-		char szQuery[64];
-		snprintf(szQuery, sizeof(szQuery), "DELETE FROM item%s WHERE `id` = %u", GetTablePostfix(), dwID);
-
-		if (g_log)
-			sys_log(0, "HEADER_GD_ITEM_DESTROY: PID %u ID %u", dwPID, dwID);
-
-		if (dwPID == 0) // 아무도 가진 사람이 없었다면, 비동기 쿼리
-			CDBManager::instance().AsyncQuery(szQuery);
-		else
-			CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_DESTROY, pkPeer->GetHandle(), NULL);
-	}
-}
-
-void CClientManager::QUERY_FLUSH_CACHE(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwPID = *(DWORD*)c_pData;
-
-	CPlayerTableCache* pkCache = GetPlayerCache(dwPID);
-
-	if (!pkCache)
-		return;
-
-	sys_log(0, "FLUSH_CACHE: %u", dwPID);
-
-	pkCache->Flush();
-	FlushItemCacheSet(dwPID);
-#ifdef __GROWTH_PET_SYSTEM__
-	FlushGrowthPetCacheSet(dwPID);
-#endif
-	m_map_playerCache.erase(dwPID);
-	delete pkCache;
-}
-
-void CClientManager::QUERY_RELOAD_PROTO()
-{
-	if (!InitializeTables())
-	{
-		sys_err("QUERY_RELOAD_PROTO: cannot load tables");
-		return;
-	}
-
-	for (TPeerList::iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* tmp = *i;
-
-		if (!tmp->GetChannel())
-			continue;
-
-		tmp->EncodeHeader(HEADER_DG_RELOAD_PROTO, 0,
-			sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
-			sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
-			sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
-			sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
-			sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize
-#ifdef __GROWTH_PET_SYSTEM__
-			+ sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size()
-#endif
-		);
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
-		tmp->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
-		tmp->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
-		tmp->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
-		tmp->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
-
-		tmp->EncodeWORD(static_cast<WORD>(m_iRefineTableSize));
-		tmp->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
-
-#ifdef __GROWTH_PET_SYSTEM__
-		tmp->EncodeWORD(m_vec_growthPetSkillTable.size());
-		if (m_vec_growthPetSkillTable.size())
-			tmp->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
-#endif
-	}
-}
-
-// ADD_GUILD_PRIV_TIME
-/**
-* @version 05/06/08 Bang2ni - 지속시간 추가
-**/
-void CClientManager::AddGuildPriv(TPacketGiveGuildPriv* p)
-{
-	CPrivManager::instance().AddGuildPriv(p->guild_id, p->type, p->value, p->duration_sec);
-}
-
-void CClientManager::AddEmpirePriv(TPacketGiveEmpirePriv* p)
-{
-	CPrivManager::instance().AddEmpirePriv(p->empire, p->type, p->value, p->duration_sec);
-}
-// END_OF_ADD_GUILD_PRIV_TIME
-
-void CClientManager::AddCharacterPriv(TPacketGiveCharacterPriv* p)
-{
-	CPrivManager::instance().AddCharPriv(p->pid, p->type, p->value);
-}
-
-void CClientManager::MoneyLog(TPacketMoneyLog* p)
-{
-	CMoneyLog::instance().AddLog(p->type, p->vnum, p->gold
-#if defined(__CHEQUE_SYSTEM__)
-		, p->cheque
-#endif
-	);
-}
-
-CLoginData* CClientManager::GetLoginData(DWORD dwKey)
-{
-	TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(dwKey);
-
-	if (it == m_map_pkLoginData.end())
-		return NULL;
-
-	return it->second;
-}
-
-CLoginData* CClientManager::GetLoginDataByLogin(const char* c_pszLogin)
-{
-	char szLogin[LOGIN_MAX_LEN + 1];
-	trim_and_lower(c_pszLogin, szLogin, sizeof(szLogin));
-
-	TLoginDataByLogin::iterator it = m_map_pkLoginDataByLogin.find(szLogin);
-
-	if (it == m_map_pkLoginDataByLogin.end())
-		return NULL;
-
-	return it->second;
-}
-
-CLoginData* CClientManager::GetLoginDataByAID(DWORD dwAID)
-{
-	TLoginDataByAID::iterator it = m_map_pkLoginDataByAID.find(dwAID);
-
-	if (it == m_map_pkLoginDataByAID.end())
-		return NULL;
-
-	return it->second;
-}
-
-void CClientManager::InsertLoginData(CLoginData* pkLD)
-{
-	char szLogin[LOGIN_MAX_LEN + 1];
-	trim_and_lower(pkLD->GetAccountRef().login, szLogin, sizeof(szLogin));
-
-	m_map_pkLoginData.insert(std::make_pair(pkLD->GetKey(), pkLD));
-	m_map_pkLoginDataByLogin.insert(std::make_pair(szLogin, pkLD));
-	m_map_pkLoginDataByAID.insert(std::make_pair(pkLD->GetAccountRef().id, pkLD));
-}
-
-void CClientManager::DeleteLoginData(CLoginData* pkLD)
-{
-	m_map_pkLoginData.erase(pkLD->GetKey());
-	m_map_pkLoginDataByLogin.erase(pkLD->GetAccountRef().login);
-	m_map_pkLoginDataByAID.erase(pkLD->GetAccountRef().id);
-
-	if (m_map_kLogonAccount.find(pkLD->GetAccountRef().login) == m_map_kLogonAccount.end())
-		delete pkLD;
-	else
-		pkLD->SetDeleted(true);
-}
-
-void CClientManager::QUERY_AUTH_LOGIN(CPeer* pkPeer, DWORD dwHandle, TPacketGDAuthLogin* p)
-{
-	if (g_test_server)
-		sys_log(0, "QUERY_AUTH_LOGIN %d %d %s", p->dwID, p->dwLoginKey, p->szLogin);
-
-	CLoginData* pkLD = GetLoginDataByLogin(p->szLogin);
-
-	if (pkLD)
-	{
-		DeleteLoginData(pkLD);
-	}
-
-	BYTE bResult;
-
-	if (GetLoginData(p->dwLoginKey))
-	{
-		sys_err("LoginData already exist key %u login %s", p->dwLoginKey, p->szLogin);
-		bResult = 0;
-
-		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
-		pkPeer->EncodeBYTE(bResult);
-	}
-	else
-	{
-		CLoginData* pkLD = new CLoginData;
-
-		pkLD->SetKey(p->dwLoginKey);
-		pkLD->SetClientKey(p->adwClientKey);
-		pkLD->SetPremium(p->iPremiumTimes);
-
-		TAccountTable& r = pkLD->GetAccountRef();
-
-		r.id = p->dwID;
-		trim_and_lower(p->szLogin, r.login, sizeof(r.login));
-		strlcpy(r.social_id, p->szSocialID, sizeof(r.social_id));
-		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		strlcpy(r.country, p->szCountry, sizeof(r.country));
-#endif
-
-		sys_log(0, "AUTH_LOGIN id(%u) login(%s)"
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			" country(%s)"
-#endif
-			" social_id(%s) login_key(%u), client_key(%u %u %u %u)",
-			p->dwID,
-			p->szLogin,
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			p->szCountry,
-#endif
-			p->szSocialID,
-			p->dwLoginKey,
-			p->adwClientKey[0], p->adwClientKey[1], p->adwClientKey[2], p->adwClientKey[3]
-		);
-
-		bResult = 1;
-
-		InsertLoginData(pkLD);
-
-		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
-		pkPeer->EncodeBYTE(bResult);
-	}
-}
-
-void CClientManager::GuildDepositMoney(TPacketGDGuildMoney* p)
-{
-	CGuildManager::instance().DepositMoney(p->dwGuild, p->iGold);
-}
-
-void CClientManager::GuildWithdrawMoney(CPeer* peer, TPacketGDGuildMoney* p)
-{
-	CGuildManager::instance().WithdrawMoney(peer, p->dwGuild, p->iGold);
-}
-
-void CClientManager::GuildWithdrawMoneyGiveReply(TPacketGDGuildMoneyWithdrawGiveReply* p)
-{
-	CGuildManager::instance().WithdrawMoneyReply(p->dwGuild, p->bGiveSuccess, p->iChangeGold);
-}
-
-void CClientManager::GuildWarBet(TPacketGDGuildWarBet* p)
-{
-	CGuildManager::instance().Bet(p->dwWarID, p->szLogin, p->dwGold, p->dwGuild);
-}
-
-void CClientManager::CreateObject(TPacketGDCreateObject* p)
-{
-	using namespace building;
-
-	char szQuery[512];
-
-	snprintf(szQuery, sizeof(szQuery),
-		"INSERT INTO object%s (`land_id`, `vnum`, `map_index`, `x`, `y`, `x_rot`, `y_rot`, `z_rot`) VALUES(%u, %u, %d, %d, %d, %f, %f, %f)",
-		GetTablePostfix(), p->dwLandID, p->dwVnum, p->lMapIndex, p->x, p->y, p->xRot, p->yRot, p->zRot);
-
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-	if (pmsg->Get()->uiInsertID == 0)
-	{
-		sys_err("cannot insert object");
-		return;
-	}
-
-	TObject* pkObj = new TObject;
-
-	memset(pkObj, 0, sizeof(TObject));
-
-	pkObj->dwID = pmsg->Get()->uiInsertID;
-	pkObj->dwVnum = p->dwVnum;
-	pkObj->dwLandID = p->dwLandID;
-	pkObj->lMapIndex = p->lMapIndex;
-	pkObj->x = p->x;
-	pkObj->y = p->y;
-	pkObj->xRot = p->xRot;
-	pkObj->yRot = p->yRot;
-	pkObj->zRot = p->zRot;
-	pkObj->lLife = 0;
-
-	ForwardPacket(HEADER_DG_CREATE_OBJECT, pkObj, sizeof(TObject));
-
-	m_map_pkObjectTable.insert(std::make_pair(pkObj->dwID, pkObj));
-}
-
-void CClientManager::DeleteObject(DWORD dwID)
-{
-	char szQuery[128];
-
-	snprintf(szQuery, sizeof(szQuery), "DELETE FROM object%s WHERE `id` = %u", GetTablePostfix(), dwID);
-
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
-	{
-		sys_err("no object by id %u", dwID);
-		return;
-	}
-
-	//pkObjectTableMap::const_iterator it = m_map_pkObjectTable.find(dwID);
-	auto it = m_map_pkObjectTable.find(dwID);
-	if (it != m_map_pkObjectTable.end())
-	{
-		delete it->second;
-		m_map_pkObjectTable.erase(it);
-	}
-
-	ForwardPacket(HEADER_DG_DELETE_OBJECT, &dwID, sizeof(DWORD));
-}
-
-void CClientManager::UpdateLand(DWORD* pdw)
-{
-	DWORD dwID = pdw[0];
-	DWORD dwGuild = pdw[1];
-
-	building::TLand* p = &m_vec_kLandTable[0];
-
-	DWORD i;
-
-	for (i = 0; i < m_vec_kLandTable.size(); ++i, ++p)
-	{
-		if (p->dwID == dwID)
-		{
-			char buf[256];
-			snprintf(buf, sizeof(buf), "UPDATE land%s SET `guild_id` = %u WHERE `id` = %u", GetTablePostfix(), dwGuild, dwID);
-			CDBManager::instance().AsyncQuery(buf);
-
-			p->dwGuildID = dwGuild;
-			break;
-		}
-	}
-
-	if (i < m_vec_kLandTable.size())
-		ForwardPacket(HEADER_DG_UPDATE_LAND, p, sizeof(building::TLand));
-}
-
-// BLOCK_CHAT
-void CClientManager::BlockChat(TPacketBlockChat* p)
-{
-	char szQuery[256];
-
-	if (g_stLocale == "sjis")
-		snprintf(szQuery, sizeof(szQuery), "SELECT `id `FROM player%s WHERE `name` = '%s' COLLATE sjis_japanese_ci", GetTablePostfix(), p->szName);
-	else
-		snprintf(szQuery, sizeof(szQuery), "SELECT `id` FROM player%s WHERE `name` = '%s'", GetTablePostfix(), p->szName);
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-	SQLResult* pRes = pmsg->Get();
-
-	if (pRes->uiNumRows)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
-		DWORD pid = strtoul(row[0], NULL, 10);
-
-		TPacketGDAddAffect pa;
-		pa.dwPID = pid;
-		pa.elem.dwType = 223;
-		pa.elem.wApplyOn = 0;
-		pa.elem.lApplyValue = 0;
-		pa.elem.dwFlag = 0;
-		pa.elem.lDuration = p->lDuration;
-		pa.elem.lSPCost = 0;
-		QUERY_ADD_AFFECT(NULL, &pa);
-	}
-	else
-	{
-		// cannot find user with that name
-	}
-}
-// END_OF_BLOCK_CHAT
-
-void CClientManager::MarriageAdd(TPacketMarriageAdd* p)
-{
-	sys_log(0, "MarriageAdd %u %u %s %s", p->dwPID1, p->dwPID2, p->szName1, p->szName2);
-	marriage::CManager::instance().Add(p->dwPID1, p->dwPID2, p->szName1, p->szName2);
-}
-
-void CClientManager::MarriageUpdate(TPacketMarriageUpdate* p)
-{
-	sys_log(0, "MarriageUpdate PID:%u %u LP:%d ST:%d", p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
-	marriage::CManager::instance().Update(p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
-}
-
-void CClientManager::MarriageRemove(TPacketMarriageRemove* p)
-{
-	sys_log(0, "MarriageRemove %u %u", p->dwPID1, p->dwPID2);
-	marriage::CManager::instance().Remove(p->dwPID1, p->dwPID2);
-}
-
-void CClientManager::WeddingRequest(TPacketWeddingRequest* p)
-{
-	sys_log(0, "WeddingRequest %u %u", p->dwPID1, p->dwPID2);
-	ForwardPacket(HEADER_DG_WEDDING_REQUEST, p, sizeof(TPacketWeddingRequest));
-	//marriage::CManager::instance().RegisterWedding(p->dwPID1, p->szName1, p->dwPID2, p->szName2);
-}
-
-void CClientManager::WeddingReady(TPacketWeddingReady* p)
-{
-	sys_log(0, "WeddingReady %u %u", p->dwPID1, p->dwPID2);
-	ForwardPacket(HEADER_DG_WEDDING_READY, p, sizeof(TPacketWeddingReady));
-	marriage::CManager::instance().ReadyWedding(p->dwMapIndex, p->dwPID1, p->dwPID2);
-}
-
-void CClientManager::WeddingEnd(TPacketWeddingEnd* p)
-{
-	sys_log(0, "WeddingEnd %u %u", p->dwPID1, p->dwPID2);
-	marriage::CManager::instance().EndWedding(p->dwPID1, p->dwPID2);
-}
-
-//
-// 캐시에 가격정보가 있으면 캐시를 업데이트 하고 캐시에 가격정보가 없다면
-// 우선 기존의 데이터를 로드한 뒤에 기존의 정보로 캐시를 만들고 새로 받은 가격정보를 업데이트 한다.
-//
-void CClientManager::MyshopPricelistUpdate(const TItemPriceListTable* pPacket)
-{
-	if (pPacket->byCount > SHOP_PRICELIST_MAX_NUM)
-	{
-		sys_err("count overflow!");
-		return;
-	}
-
-	CItemPriceListTableCache* pCache = GetItemPriceListCache(pPacket->dwOwnerID);
-
-	if (pCache)
-	{
-		TItemPriceListTable table;
-
-		table.dwOwnerID = pPacket->dwOwnerID;
-		table.byCount = pPacket->byCount;
-
-		thecore_memcpy(table.aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
-
-		pCache->UpdateList(&table);
-	}
-	else
-	{
-		TItemPriceListTable* pUpdateTable = new TItemPriceListTable;
-
-		pUpdateTable->dwOwnerID = pPacket->dwOwnerID;
-		pUpdateTable->byCount = pPacket->byCount;
-
-		thecore_memcpy(pUpdateTable->aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `item_vnum`, `price`"
-#if defined(__CHEQUE_SYSTEM__)
-			", `cheque`"
-#endif
-			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), pPacket->dwOwnerID);
-		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD_FOR_UPDATE, 0, pUpdateTable);
-	}
-}
-
-// MYSHOP_PRICE_LIST
-// 캐시된 가격정보가 있으면 캐시를 읽어 바로 전송하고 캐시에 정보가 없으면 DB 에 쿼리를 한다.
-//
-void CClientManager::MyshopPricelistRequest(CPeer* peer, DWORD dwHandle, DWORD dwPlayerID)
-{
-	if (CItemPriceListTableCache* pCache = GetItemPriceListCache(dwPlayerID))
-	{
-		sys_log(0, "Cache MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
-
-		TItemPriceListTable* pTable = pCache->Get(false);
-
-		TPacketMyshopPricelistHeader header =
-		{
-			pTable->dwOwnerID,
-			pTable->byCount
-		};
-
-		size_t sizePriceListSize = sizeof(TItemPriceInfo) * pTable->byCount;
-
-		peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, dwHandle, sizeof(header) + sizePriceListSize);
-		peer->Encode(&header, sizeof(header));
-		peer->Encode(pTable->aPriceInfo, sizePriceListSize);
-	}
-	else
-	{
-		sys_log(0, "Query MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
-
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT `item_vnum`, `price`"
-#if defined(__CHEQUE_SYSTEM__)
-			", `cheque`"
-#endif
-			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), dwPlayerID);
-		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD, peer->GetHandle(), new TItemPricelistReqInfo(dwHandle, dwPlayerID));
-	}
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-void CPacketInfo::Add(int header)
-{
-	auto it = m_map_info.find(header);
-	if (it == m_map_info.end())
-		m_map_info.insert(std::map<int, int>::value_type(header, 1));
-	else
-		++it->second;
-}
-
-void CPacketInfo::Reset()
-{
-	m_map_info.clear();
-}
-
-void CClientManager::ProcessPackets(CPeer* peer)
-{
-	BYTE header;
-	DWORD dwHandle;
-	DWORD dwLength;
-	const char* data = NULL;
-	int i = 0;
-	int iCount = 0;
-
-	while (peer->PeekPacket(i, header, dwHandle, dwLength, &data))
-	{
-		// DISABLE_DB_HEADER_LOG
-		// sys_log(0, "header %d %p size %d", header, this, dwLength);
-		// END_OF_DISABLE_DB_HEADER_LOG
-		m_bLastHeader = header;
-		++iCount;
-
-#if defined(_DEBUG)
-		if (header != 10)
-			sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
-#endif
-
-		if (g_test_server)
-		{
-			if (header != 10)
-				sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
-		}
-
-		// test log by mhh
-		{
-			if (HEADER_GD_BLOCK_COUNTRY_IP == header)
-				sys_log(0, "recved : HEADER_GD_BLOCK_COUNTRY_IP");
-		}
-
-		switch (header)
-		{
-			case HEADER_GD_BOOT:
-				QUERY_BOOT(peer, (TPacketGDBoot*)data);
-				break;
-
-			case HEADER_GD_HAMMER_OF_TOR:
-				break;
-
-			case HEADER_GD_LOGIN_BY_KEY:
-				QUERY_LOGIN_BY_KEY(peer, dwHandle, (TPacketGDLoginByKey*)data);
-				break;
-
-			case HEADER_GD_LOGOUT:
-				//sys_log(0, "HEADER_GD_LOGOUT (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_LOGOUT(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_PLAYER_LOAD:
-				sys_log(1, "HEADER_GD_PLAYER_LOAD (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_PLAYER_LOAD(peer, dwHandle, (TPlayerLoadPacket*)data);
-				break;
-
-			case HEADER_GD_PLAYER_SAVE:
-				sys_log(1, "HEADER_GD_PLAYER_SAVE (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_PLAYER_SAVE(peer, dwHandle, (TPlayerTable*)data);
-				break;
-
-			case HEADER_GD_PLAYER_CREATE:
-				sys_log(0, "HEADER_GD_PLAYER_CREATE (handle: %d length: %d)", dwHandle, dwLength);
-				__QUERY_PLAYER_CREATE(peer, dwHandle, (TPlayerCreatePacket*)data);
-				sys_log(0, "END");
-				break;
-
-			case HEADER_GD_PLAYER_DELETE:
-				sys_log(1, "HEADER_GD_PLAYER_DELETE (handle: %d length: %d)", dwHandle, dwLength);
-				__QUERY_PLAYER_DELETE(peer, dwHandle, (TPlayerDeletePacket*)data);
-				break;
-
-			case HEADER_GD_PLAYER_COUNT:
-				QUERY_PLAYER_COUNT(peer, (TPlayerCountPacket*)data);
-				break;
-
-			case HEADER_GD_QUEST_SAVE:
-				sys_log(1, "HEADER_GD_QUEST_SAVE (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_QUEST_SAVE(peer, (TQuestTable*)data, dwLength);
-				break;
-
-			case HEADER_GD_SAFEBOX_LOAD:
-				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 0);
-				break;
-
-			case HEADER_GD_SAFEBOX_SAVE:
-				sys_log(1, "HEADER_GD_SAFEBOX_SAVE (handle: %d length: %d)", dwHandle, dwLength);
-				QUERY_SAFEBOX_SAVE(peer, (TSafeboxTable*)data);
-				break;
-
-			case HEADER_GD_SAFEBOX_CHANGE_SIZE:
-				QUERY_SAFEBOX_CHANGE_SIZE(peer, dwHandle, (TSafeboxChangeSizePacket*)data);
-				break;
-
-			case HEADER_GD_SAFEBOX_CHANGE_PASSWORD:
-				QUERY_SAFEBOX_CHANGE_PASSWORD(peer, dwHandle, (TSafeboxChangePasswordPacket*)data);
-				break;
-
-			case HEADER_GD_MALL_LOAD:
-				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 1);
-				break;
-
-			case HEADER_GD_EMPIRE_SELECT:
-				QUERY_EMPIRE_SELECT(peer, dwHandle, (TEmpireSelectPacket*)data);
-				break;
-
-			case HEADER_GD_SETUP:
-				QUERY_SETUP(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_GUILD_CREATE:
-				GuildCreate(peer, *(DWORD*)data);
-				break;
-
-			case HEADER_GD_GUILD_SKILL_UPDATE:
-				GuildSkillUpdate(peer, (TPacketGuildSkillUpdate*)data);
-				break;
-
-			case HEADER_GD_GUILD_EXP_UPDATE:
-				GuildExpUpdate(peer, (TPacketGuildExpUpdate*)data);
-				break;
-
-			case HEADER_GD_GUILD_ADD_MEMBER:
-				GuildAddMember(peer, (TPacketGDGuildAddMember*)data);
-				break;
-
-			case HEADER_GD_GUILD_REMOVE_MEMBER:
-				GuildRemoveMember(peer, (TPacketGuild*)data);
-				break;
-
-			case HEADER_GD_GUILD_CHANGE_GRADE:
-				GuildChangeGrade(peer, (TPacketGuild*)data);
-				break;
-
-			case HEADER_GD_GUILD_CHANGE_MEMBER_DATA:
-				GuildChangeMemberData(peer, (TPacketGuildChangeMemberData*)data);
-				break;
-
-			case HEADER_GD_GUILD_DISBAND:
-				GuildDisband(peer, (TPacketGuild*)data);
-				break;
-
-			case HEADER_GD_GUILD_WAR:
-				GuildWar(peer, (TPacketGuildWar*)data);
-				break;
-
-			case HEADER_GD_GUILD_WAR_SCORE:
-				GuildWarScore(peer, (TPacketGuildWarScore*)data);
-				break;
-
-			case HEADER_GD_GUILD_CHANGE_LADDER_POINT:
-				GuildChangeLadderPoint((TPacketGuildLadderPoint*)data);
-				break;
-
-			case HEADER_GD_GUILD_USE_SKILL:
-				GuildUseSkill((TPacketGuildUseSkill*)data);
-				break;
-
-			case HEADER_GD_FLUSH_CACHE:
-				QUERY_FLUSH_CACHE(peer, data);
-				break;
-
-			case HEADER_GD_ITEM_SAVE:
-				QUERY_ITEM_SAVE(peer, data);
-				break;
-
-			case HEADER_GD_ITEM_DESTROY:
-				QUERY_ITEM_DESTROY(peer, data);
-				break;
-
-			case HEADER_GD_ITEM_FLUSH:
-				QUERY_ITEM_FLUSH(peer, data);
-				break;
-
-			case HEADER_GD_ADD_AFFECT:
-				sys_log(1, "HEADER_GD_ADD_AFFECT");
-				QUERY_ADD_AFFECT(peer, (TPacketGDAddAffect*)data);
-				break;
-
-			case HEADER_GD_REMOVE_AFFECT:
-				sys_log(1, "HEADER_GD_REMOVE_AFFECT");
-				QUERY_REMOVE_AFFECT(peer, (TPacketGDRemoveAffect*)data);
-				break;
-
-			case HEADER_GD_HIGHSCORE_REGISTER:
-				QUERY_HIGHSCORE_REGISTER(peer, (TPacketGDHighscore*)data);
-				break;
-
-			case HEADER_GD_PARTY_CREATE:
-				QUERY_PARTY_CREATE(peer, (TPacketPartyCreate*)data);
-				break;
-
-			case HEADER_GD_PARTY_DELETE:
-				QUERY_PARTY_DELETE(peer, (TPacketPartyDelete*)data);
-				break;
-
-			case HEADER_GD_PARTY_ADD:
-				QUERY_PARTY_ADD(peer, (TPacketPartyAdd*)data);
-				break;
-
-			case HEADER_GD_PARTY_REMOVE:
-				QUERY_PARTY_REMOVE(peer, (TPacketPartyRemove*)data);
-				break;
-
-			case HEADER_GD_PARTY_STATE_CHANGE:
-				QUERY_PARTY_STATE_CHANGE(peer, (TPacketPartyStateChange*)data);
-				break;
-
-			case HEADER_GD_PARTY_SET_MEMBER_LEVEL:
-				QUERY_PARTY_SET_MEMBER_LEVEL(peer, (TPacketPartySetMemberLevel*)data);
-				break;
-
-			case HEADER_GD_RELOAD_PROTO:
-				QUERY_RELOAD_PROTO();
-				break;
-
-			case HEADER_GD_CHANGE_NAME:
-				QUERY_CHANGE_NAME(peer, dwHandle, (TPacketGDChangeName*)data);
-				break;
-
-			case HEADER_GD_AUTH_LOGIN:
-				QUERY_AUTH_LOGIN(peer, dwHandle, (TPacketGDAuthLogin*)data);
-				break;
-
-			case HEADER_GD_REQUEST_GUILD_PRIV:
-				AddGuildPriv((TPacketGiveGuildPriv*)data);
-				break;
-
-			case HEADER_GD_REQUEST_EMPIRE_PRIV:
-				AddEmpirePriv((TPacketGiveEmpirePriv*)data);
-				break;
-
-			case HEADER_GD_REQUEST_CHARACTER_PRIV:
-				AddCharacterPriv((TPacketGiveCharacterPriv*)data);
-				break;
-
-			case HEADER_GD_MONEY_LOG:
-				MoneyLog((TPacketMoneyLog*)data);
-				break;
-
-			case HEADER_GD_GUILD_DEPOSIT_MONEY:
-				GuildDepositMoney((TPacketGDGuildMoney*)data);
-				break;
-
-			case HEADER_GD_GUILD_WITHDRAW_MONEY:
-				GuildWithdrawMoney(peer, (TPacketGDGuildMoney*)data);
-				break;
-
-			case HEADER_GD_GUILD_WITHDRAW_MONEY_GIVE_REPLY:
-				GuildWithdrawMoneyGiveReply((TPacketGDGuildMoneyWithdrawGiveReply*)data);
-				break;
-
-			case HEADER_GD_GUILD_WAR_BET:
-				GuildWarBet((TPacketGDGuildWarBet*)data);
-				break;
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-			case HEADER_GD_GUILD_EVENT_FLAG:
-				GuildSetEventFlag((TPacketSetGuildEventFlag*)data);
-				break;
-#endif
-
-			case HEADER_GD_SET_EVENT_FLAG:
-				SetEventFlag((TPacketSetEventFlag*)data);
-				break;
-
-			case HEADER_GD_CREATE_OBJECT:
-				CreateObject((TPacketGDCreateObject*)data);
-				break;
-
-			case HEADER_GD_DELETE_OBJECT:
-				DeleteObject(*(DWORD*)data);
-				break;
-
-			case HEADER_GD_UPDATE_LAND:
-				UpdateLand((DWORD*)data);
-				break;
-
-			case HEADER_GD_MARRIAGE_ADD:
-				MarriageAdd((TPacketMarriageAdd*)data);
-				break;
-
-			case HEADER_GD_MARRIAGE_UPDATE:
-				MarriageUpdate((TPacketMarriageUpdate*)data);
-				break;
-
-			case HEADER_GD_MARRIAGE_REMOVE:
-				MarriageRemove((TPacketMarriageRemove*)data);
-				break;
-
-			case HEADER_GD_WEDDING_REQUEST:
-				WeddingRequest((TPacketWeddingRequest*)data);
-				break;
-
-			case HEADER_GD_WEDDING_READY:
-				WeddingReady((TPacketWeddingReady*)data);
-				break;
-
-			case HEADER_GD_WEDDING_END:
-				WeddingEnd((TPacketWeddingEnd*)data);
-				break;
-
-				// BLOCK_CHAT
-			case HEADER_GD_BLOCK_CHAT:
-				BlockChat((TPacketBlockChat*)data);
-				break;
-				// END_OF_BLOCK_CHAT
-
-				// MYSHOP_PRICE_LIST
-			case HEADER_GD_MYSHOP_PRICELIST_UPDATE:
-				MyshopPricelistUpdate((TItemPriceListTable*)data);
-				break;
-
-			case HEADER_GD_MYSHOP_PRICELIST_REQ:
-				MyshopPricelistRequest(peer, dwHandle, *(DWORD*)data);
-				break;
-				// END_OF_MYSHOP_PRICE_LIST
-
-				// RELOAD_ADMIN
-			case HEADER_GD_RELOAD_ADMIN:
-				ReloadAdmin(peer, (TPacketReloadAdmin*)data);
-				break;
-				// END_RELOAD_ADMIN
-
-			case HEADER_GD_BREAK_MARRIAGE:
-				BreakMarriage(peer, data);
-				break;
-
-				// MOANRCH
-			case HEADER_GD_ELECT_MONARCH:
-				Election(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_CANDIDACY:
-				Candidacy(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_ADD_MONARCH_MONEY:
-				AddMonarchMoney(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_DEC_MONARCH_MONEY:
-				DecMonarchMoney(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_TAKE_MONARCH_MONEY:
-				TakeMonarchMoney(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_COME_TO_VOTE:
-				ComeToVote(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_RMCANDIDACY: ///< 후보 제거 (운영자)
-				RMCandidacy(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_SETMONARCH: ///< 군주설정 (운영자)
-				SetMonarch(peer, dwHandle, data);
-				break;
-
-			case HEADER_GD_RMMONARCH: ///< 군주삭제
-				RMMonarch(peer, dwHandle, data);
-				break;
-				// END_MONARCH
-
-			case HEADER_GD_CHANGE_MONARCH_LORD:
-				ChangeMonarchLord(peer, dwHandle, (TPacketChangeMonarchLord*)data);
-				break;
-
-			case HEADER_GD_BLOCK_COUNTRY_IP:
-				sys_log(0, "HEADER_GD_BLOCK_COUNTRY_IP received");
-				CBlockCountry::instance().SendBlockedCountryIp(peer);
-				CBlockCountry::instance().SendBlockException(peer);
-				break;
-
-			case HEADER_GD_BLOCK_EXCEPTION:
-				sys_log(0, "HEADER_GD_BLOCK_EXCEPTION received");
-				BlockException((TPacketBlockException*)data);
-				break;
-
-			case HEADER_GD_REQ_SPARE_ITEM_ID_RANGE:
-				SendSpareItemIDRange(peer);
-				break;
-
-			case HEADER_GD_REQ_CHANGE_GUILD_MASTER:
-				GuildChangeMaster((TPacketChangeGuildMaster*)data);
-				break;
-
-			case HEADER_GD_UPDATE_HORSE_NAME:
-				UpdateHorseName((TPacketUpdateHorseName*)data, peer);
-				break;
-
-			case HEADER_GD_REQ_HORSE_NAME:
-				AckHorseName(*(DWORD*)data, peer);
-				break;
-
-			case HEADER_GD_DC:
-				DeleteLoginKey((TPacketDC*)data);
-				break;
-
-			case HEADER_GD_VALID_LOGOUT:
-				ResetLastPlayerID((TPacketNeedLoginLogInfo*)data);
-				break;
-
-			case HEADER_GD_REQUEST_CHARGE_CASH:
-				ChargeCash((TRequestChargeCash*)data);
-				break;
-
-				// delete gift notify icon
-			case HEADER_GD_DELETE_AWARDID:
-				DeleteAwardId((TPacketDeleteAwardID*)data);
-				break;
-
-			case HEADER_GD_UPDATE_CHANNELSTATUS:
-				UpdateChannelStatus((SChannelStatus*)data);
-				break;
-
-			case HEADER_GD_REQUEST_CHANNELSTATUS:
-				RequestChannelStatus(peer, dwHandle);
-				break;
-
-#if defined(__MOVE_CHANNEL__)
-			case HEADER_GD_FIND_CHANNEL:
-				FindChannel(peer, dwHandle, (TPacketChangeChannel*)data);
-				break;
-#endif
-
-#if defined(__GEM_SHOP__)
-			case HEADER_GD_GEM_SHOP_LOAD:
-				LoadGemShop(peer, dwHandle, (TGemShopLoad*)data);
-				break;
-
-			case HEADER_GD_GEM_SHOP_UPDATE:
-				UpdateGemShop(peer, dwHandle, (TGemShopTable*)data);
-				break;
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-			case HEADER_GD_EMOTE_LOAD:
-				QUERY_EMOTE_LOAD(peer, dwHandle, (TPacketGDEmote*)data);
-				break;
-
-			case HEADER_GD_EMOTE_CLEAR:
-				QUERY_EMOTE_CLEAR(peer, dwHandle, (TPacketGDEmote*)data);
-				break;
-
-			case HEADER_GD_EMOTE_ADD:
-				QUERY_EMOTE_ADD(peer, dwHandle, (TPacketGDEmote*)data);
-				break;
-#endif
-
-#if defined(__MAILBOX__)
-			case HEADER_GD_MAILBOX_LOAD:
-				QUERY_MAILBOX_LOAD(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_CHECK_NAME:
-				QUERY_MAILBOX_CHECK_NAME(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_WRITE:
-				QUERY_MAILBOX_WRITE(peer, dwHandle, (TMailBoxTable*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_DELETE:
-				QUERY_MAILBOX_DELETE(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_CONFIRM:
-				QUERY_MAILBOX_CONFIRM(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_GET:
-				QUERY_MAILBOX_GET(peer, dwHandle, (TMailBox*)data);
-				break;
-
-			case HEADER_GD_MAILBOX_UNREAD:
-				QUERY_MAILBOX_UNREAD(peer, dwHandle, (TMailBox*)data);
-				break;
-#endif
-
-#ifdef __SHOP_SEARCH__
-			case HEADER_GD_SHOP_SEARCH_REGISTER_ITEM:
-				CShopSearchManager::Instance().RecvRegisterItem(peer, *reinterpret_cast<const TShopSearchItem*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_UNREGISTER_ITEM:
-				CShopSearchManager::Instance().RecvUnregisterItem(*reinterpret_cast<const TShopSearchItem*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_SOLD_ITEM:
-				CShopSearchManager::Instance().RecvSoldItem(*reinterpret_cast<const TPacketGDShopSearchSoldItem*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BY_NAME:
-				CShopSearchManager::Instance().RecvSearchByName(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchByName*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BY_OPTIONS:
-			{
-				const TPacketGDShopSearchByOptions& packet = *reinterpret_cast<const TPacketGDShopSearchByOptions*>(data);
-				data += sizeof(TPacketGDShopSearchByOptions);
-				const TShopSearchItemType* itemTypeFlags = (const TShopSearchItemType*)data;
-				data += sizeof(TShopSearchItemType) * packet.options.typeFlagCount;
-				CShopSearchManager::Instance().RecvSearchByOptions(peer, dwHandle, packet, itemTypeFlags, (const DWORD*)data);
-			}
-			break;
-
-			case HEADER_GD_SHOP_SEARCH_REQUEST_BUY:
-				CShopSearchManager::Instance().RecvBuyItem(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchRequestBuy*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BUY_FROM_SHOP_ERROR:
-				CShopSearchManager::Instance().RecvBuyFromShopError(*reinterpret_cast<const TPacketDGShopSearchBuyFromShop*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_BOUGHT_FROM_SHOP:
-				CShopSearchManager::Instance().RecvBoughtFromShop(dwHandle, *reinterpret_cast<const TPacketGDShopSearchBoughtFromShop*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_REQUEST_SOLD_INFO:
-				CShopSearchManager::Instance().RecvRequestSoldInfo(peer, dwHandle, *reinterpret_cast<const DWORD*>(data));
-				break;
-
-			case HEADER_GD_SHOP_SEARCH_RELOAD_AVERAGE:
-				CShopSearchManager::Instance().Initialize();
-				break;
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-			case HEADER_GD_GROWTH_PET_SAVE:
-				QUERY_GROWTH_PET_SAVE(peer, data);
-				break;
-
-			case HEADER_GD_GROWTH_PET_DELETE:
-				QUERY_GROWTH_PET_DELETE(peer, data);
-				break;
-#endif
-
-#ifdef __OFFLINE_SHOP__
-			case HEADER_GD_REQUEST_OFFLINE_SHOP_ID:
-				RequestOfflineShopId(peer, *reinterpret_cast<const uint32_t*>(data));
-				break;
-
-			case HEADER_GD_OFFLINE_SHOP_SAVE:
-				SaveOfflineShop(*reinterpret_cast<const TOfflineShop*>(data));
-				break;
-
-			case HEADER_GD_OFFLINE_SHOP_SAVE_ITEM:
-				SaveOfflineShopItem(*reinterpret_cast<const TOfflineShopItem*>(data));
-				break;
-
-			case HEADER_GD_OFFLINE_SHOP_DESTROY:
-				DestroyOfflineShop(*reinterpret_cast<const uint32_t*>(data));
-				break;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			case HEADER_GD_SAVE_EXT_BATTLE_PASS:
-				QUERY_SAVE_EXT_BATTLE_PASS(peer, dwHandle, (TPlayerExtBattlePassMission*)data);
-				break;
-#endif
-
-			default:
-				sys_err("Unknown header (header: %d handle: %d length: %d)", header, dwHandle, dwLength);
-				break;
-		}
-	}
-
-	peer->RecvEnd(i);
-}
-
-void CClientManager::AddPeer(socket_t fd)
-{
-	CPeer* pPeer = new CPeer;
-
-	if (pPeer->Accept(fd))
-		m_peerList.push_front(pPeer);
-	else
-		delete pPeer;
-}
-
-void CClientManager::RemovePeer(CPeer* pPeer)
-{
-	if (m_pkAuthPeer == pPeer)
-	{
-		m_pkAuthPeer = NULL;
-	}
-	else
-	{
-		TLogonAccountMap::iterator it = m_map_kLogonAccount.begin();
-
-		while (it != m_map_kLogonAccount.end())
-		{
-			CLoginData* pkLD = it->second;
-
-			if (pkLD->GetConnectedPeerHandle() == pPeer->GetHandle())
-			{
-				if (pkLD->IsPlay())
-					pkLD->SetPlay(false);
-
-				if (pkLD->IsDeleted())
-				{
-					sys_log(0, "DELETING LoginData");
-					delete pkLD;
-				}
-
-				m_map_kLogonAccount.erase(it++);
-			}
-			else
-				++it;
-		}
-	}
-
-	m_peerList.remove(pPeer);
-	delete pPeer;
-}
-
-CPeer* CClientManager::GetPeer(IDENT ident)
-{
-	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* tmp = *i;
-
-		if (tmp->GetHandle() == ident)
-			return tmp;
-	}
-
-	return NULL;
-}
-
-CPeer* CClientManager::GetAnyPeer()
-{
-	if (m_peerList.empty())
-		return NULL;
-
-	return m_peerList.front();
-}
-
-// DB 매니저로 부터 받은 결과를 처리한다.
-//
-// @version	05/06/10 Bang2ni - 가격정보 관련 쿼리(QID_ITEMPRICE_XXX) 추가
-int CClientManager::AnalyzeQueryResult(SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	CPeer* peer = GetPeer(qi->dwIdent);
-
-#if defined(_DEBUG)
-	if (qi->iType != QID_ITEM_AWARD_LOAD)
-		sys_log(0, "AnalyzeQueryResult %d", qi->iType);
-#endif
-
-	switch (qi->iType)
-	{
-		case QID_ITEM_AWARD_LOAD:
-			ItemAwardManager::instance().Load(msg);
-			delete qi;
-			return true;
-
-		case QID_GUILD_RANKING:
-			CGuildManager::instance().ResultRanking(msg->Get()->pSQLResult);
-			break;
-
-			// MYSHOP_PRICE_LIST
-		case QID_ITEMPRICE_LOAD_FOR_UPDATE:
-			RESULT_PRICELIST_LOAD_FOR_UPDATE(msg);
-			break;
-			// END_OF_MYSHOP_PRICE_LIST
-	}
-
-	if (!peer)
-	{
-		//sys_err("CClientManager::AnalyzeQueryResult: peer not exist anymore. (ident: %d)", qi->dwIdent);
-		delete qi;
-		return true;
-	}
-
-	switch (qi->iType)
-	{
-		case QID_PLAYER:
-		case QID_ITEM:
-		case QID_QUEST:
-		case QID_AFFECT:
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		case QID_EXT_BATTLE_PASS:
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-		case QID_GROWTH_PET:
-#endif
-			RESULT_COMPOSITE_PLAYER(peer, msg, qi->iType);
-			break;
-
-		case QID_LOGIN:
-			RESULT_LOGIN(peer, msg);
-			break;
-
-		case QID_SAFEBOX_LOAD:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_LOAD");
-			RESULT_SAFEBOX_LOAD(peer, msg);
-			break;
-
-		case QID_SAFEBOX_CHANGE_SIZE:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_SIZE");
-			RESULT_SAFEBOX_CHANGE_SIZE(peer, msg);
-			break;
-
-		case QID_SAFEBOX_CHANGE_PASSWORD:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
-			RESULT_SAFEBOX_CHANGE_PASSWORD(peer, msg);
-			break;
-
-		case QID_SAFEBOX_CHANGE_PASSWORD_SECOND:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
-			RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(peer, msg);
-			break;
-
-		case QID_HIGHSCORE_REGISTER:
-			sys_log(0, "QUERY_RESULT: HEADER_GD_HIGHSCORE_REGISTER %p", msg);
-			RESULT_HIGHSCORE_REGISTER(peer, msg);
-			break;
-
-		case QID_SAFEBOX_SAVE:
-		case QID_ITEM_SAVE:
-		case QID_ITEM_DESTROY:
-		case QID_QUEST_SAVE:
-		case QID_PLAYER_SAVE:
-		case QID_ITEM_AWARD_TAKEN:
-#ifdef __GROWTH_PET_SYSTEM__
-		case QID_GROWTH_PET_SAVE:
-		case QID_GROWTH_PET_DELETE:
-#endif
-			break;
-
-			// PLAYER_INDEX_CREATE_BUG_FIX
-		case QID_PLAYER_INDEX_CREATE:
-			RESULT_PLAYER_INDEX_CREATE(peer, msg);
-			break;
-			// END_PLAYER_INDEX_CREATE_BUG_FIX
-
-		case QID_PLAYER_DELETE:
-			__RESULT_PLAYER_DELETE(peer, msg);
-			break;
-
-		case QID_LOGIN_BY_KEY:
-			RESULT_LOGIN_BY_KEY(peer, msg);
-			break;
-
-			// MYSHOP_PRICE_LIST
-		case QID_ITEMPRICE_LOAD:
-			RESULT_PRICELIST_LOAD(peer, msg);
-			break;
-			// END_OF_MYSHOP_PRICE_LIST
-
-		default:
-			sys_log(0, "CClientManager::AnalyzeQueryResult unknown query result type: %d, str: %s", qi->iType, msg->stQuery.c_str());
-			break;
-	}
-
-	delete qi;
-	return true;
-}
-
-void UsageLog()
-{
-	FILE* fp = NULL;
-
-	time_t ct;
-	char* time_s;
-	struct tm lt;
-
-	int avg = g_dwUsageAvg / 3600; // 60 초 * 60 분
-
-	fp = fopen("usage.txt", "a+");
-
-	if (!fp)
-		return;
-
-	ct = time(0);
-	lt = *localtime(&ct);
-	time_s = asctime(&lt);
-
-	time_s[strlen(time_s) - 1] = '\0';
-
-	fprintf(fp, "| %4d %-15.15s | %5d | %5u |", lt.tm_year + 1900, time_s + 4, avg, g_dwUsageMax);
-
-	fprintf(fp, "\n");
-	fclose(fp);
-
-	g_dwUsageMax = g_dwUsageAvg = 0;
-}
-
-int CClientManager::Process()
-{
-	int pulses;
-
-	if (!(pulses = thecore_idle()))
-		return 0;
-
-	while (pulses--)
-	{
-		++thecore_heart->pulse;
-
-		/*
-		// 30분마다 변경
-		if (((thecore_pulse() % (60 * 30 * 10)) == 0))
-		{
-			g_iPlayerCacheFlushSeconds = MAX(60, rand() % 180);
-			g_iItemCacheFlushSeconds = MAX(60, rand() % 180);
-			sys_log(0, "[SAVE_TIME]Change saving time item %d player %d", g_iPlayerCacheFlushSeconds, g_iItemCacheFlushSeconds);
-		}
-		*/
-
-		if (!(thecore_heart->pulse % thecore_heart->passes_per_sec))
-		{
-			if (g_test_server)
-			{
-				if (!(thecore_heart->pulse % thecore_heart->passes_per_sec * 10))
-
-				{
-					pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d/%d",
-						thecore_heart->pulse,
-						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-						CDBManager::instance().CountReturnResult(SQL_PLAYER),
-						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-						CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
-						CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
-
-					if ((thecore_heart->pulse % 50) == 0)
-						sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
-							thecore_heart->pulse,
-							CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-							CDBManager::instance().CountReturnResult(SQL_PLAYER),
-							CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-							CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-							CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-							CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
-				}
-			}
-			else
-			{
-				pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d%/%d",
-					thecore_heart->pulse,
-					CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-					CDBManager::instance().CountReturnResult(SQL_PLAYER),
-					CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-					CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
-					CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-					CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-					CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
-					CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
-
-				if ((thecore_heart->pulse % 50) == 0)
-					sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
-						thecore_heart->pulse,
-						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
-						CDBManager::instance().CountReturnResult(SQL_PLAYER),
-						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
-						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
-						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
-			}
-
-			CDBManager::instance().ResetCounter();
-
-			DWORD dwCount = CClientManager::instance().GetUserCount();
-
-			g_dwUsageAvg += dwCount;
-			g_dwUsageMax = MAX(g_dwUsageMax, dwCount);
-
-			memset(&thecore_profiler[0], 0, sizeof(thecore_profiler));
-
-#if defined(__EXPRESSING_EMOTIONS__)
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iEmoteDumpDelay)))
-				CClientManager::instance().QUERY_EMOTE_DUMP();
-#endif
-
-#if defined(__MAILBOX__)
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iMailBoxBackupSec)))
-				CClientManager::instance().MAILBOX_BACKUP();
-#endif
-
-#if defined(__GEM_SHOP__)
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iGemShopFlushDelay)))
-				CClientManager::instance().FlushGemShop();
-#endif
-
-			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600)))
-				UsageLog();
-
-			m_iCacheFlushCount = 0;
-
-			// 플레이어 플러쉬
-			UpdatePlayerCache();
-			// 아이템 플러쉬
-			UpdateItemCache();
-			//로그아웃시 처리- 캐쉬셋 플러쉬
-			UpdateLogoutPlayer();
-
-			// MYSHOP_PRICE_LIST
-			UpdateItemPriceListCache();
-			// END_OF_MYSHOP_PRICE_LIST
-#ifdef __OFFLINE_SHOP__
-			UpdateOfflineShopCache();
-			UpdateOfflineShopItemCache();
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-			UpdateGrowthPetCache();
-#endif
-			CGuildManager::instance().Update();
-			CPrivManager::instance().Update();
-			marriage::CManager::instance().Update();
-#ifdef __SHOP_SEARCH__
-			CShopSearchManager::Instance().Update();
-#endif
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 5)))
-		{
-			ItemAwardManager::instance().RequestLoad();
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 10)))
-		{
-			/*
-			char buf[4096 + 1];
-			int len
-
-			/////////////////////////////////////////////////////////////////
-			buf[0] = '\0';
-			len = 0;
-
-			auto it = g_query_info.m_map_info.begin();
-
-			int count = 0;
-
-			while (it != g_query_info.m_map_info.end())
-			{
-				len += snprintf(buf + len, sizeof(buf) - len, "%2d %3d\n", it->first, it->second);
-				count += it->second;
-				it++;
-			}
-
-			pt_log("QUERY:\n%s-------------------- MAX : %d\n", buf, count);
-			g_query_info.Reset();
-			*/
-			pt_log("QUERY: MAIN[%d] ASYNC[%d]", g_query_count[0], g_query_count[1]);
-			g_query_count[0] = 0;
-			g_query_count[1] = 0;
-			/////////////////////////////////////////////////////////////////
-
-			/////////////////////////////////////////////////////////////////
-			/*
-			buf[0] = '\0';
-			len = 0;
-
-			it = g_item_info.m_map_info.begin();
-
-			count = 0;
-			while (it != g_item_info.m_map_info.end())
-			{
-				len += snprintf(buf + len, sizeof(buf) - len, "%5d %3d\n", it->first, it->second);
-				count += it->second;
-				it++;
-			}
-
-			pt_log("ITEM:\n%s-------------------- MAX : %d\n", buf, count);
-			g_item_info.Reset();
-			*/
-			pt_log("ITEM:%d\n", g_item_count);
-			g_item_count = 0;
-			/////////////////////////////////////////////////////////////////
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60))) // 60초에 한번
-		{
-			// 유니크 아이템을 위한 시간을 보낸다.
-			CClientManager::instance().SendTime();
-		}
-
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600))) // 한시간에 한번
-		{
-			CMoneyLog::instance().Save();
-		}
-
-#if defined(__ENVIRONMENT_SYSTEM__)
-		static bool OnSetup = true;
-		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60 * 20)) || OnSetup)
-		{
-			UpdateEnvironment();
-			OnSetup = false;
-		}
-#endif
-	}
-
-	int num_events = fdwatch(m_fdWatcher, 0);
-	int idx;
-	CPeer* peer;
-
-	for (idx = 0; idx < num_events; ++idx) // 인풋
-	{
-		peer = (CPeer*)fdwatch_get_client_data(m_fdWatcher, idx);
-
-		if (!peer)
-		{
-			if (fdwatch_check_event(m_fdWatcher, m_fdAccept, idx) == FDW_READ)
-			{
-				AddPeer(m_fdAccept);
-				fdwatch_clear_event(m_fdWatcher, m_fdAccept, idx);
-			}
-			else
-			{
-				sys_log(0, "FDWATCH: peer null in event: ident %d", fdwatch_get_ident(m_fdWatcher, idx));
-			}
-
-			continue;
-		}
-
-		switch (fdwatch_check_event(m_fdWatcher, peer->GetFd(), idx))
-		{
-			case FDW_READ:
-				if (peer->Recv() < 0)
-				{
-					sys_err("Recv failed");
-					RemovePeer(peer);
-				}
-				else
-				{
-					if (peer == m_pkAuthPeer)
-						if (g_log)
-							sys_log(0, "AUTH_PEER_READ: size %d", peer->GetRecvLength());
-
-					ProcessPackets(peer);
-				}
-				break;
-
-			case FDW_WRITE:
-				if (peer == m_pkAuthPeer)
-					if (g_log)
-						sys_log(0, "AUTH_PEER_WRITE: size %d", peer->GetSendLength());
-
-				if (peer->Send() < 0)
-				{
-					sys_err("Send failed");
-					RemovePeer(peer);
-				}
-
-				break;
-
-			case FDW_EOF:
-				RemovePeer(peer);
-				break;
-
-			default:
-				sys_err("fdwatch_check_fd returned unknown result");
-				RemovePeer(peer);
-				break;
-		}
-	}
-
-#ifdef __WIN32__
-	if (_kbhit())
-	{
-		int c = _getch();
-		switch (c)
-		{
-			case 0x1b: // Esc
-				return 0; // shutdown
-				break;
-			default:
-				break;
-		}
-	}
-#endif
-
-	return 1;
-}
-
-DWORD CClientManager::GetUserCount()
-{
-	// 단순히 로그인 카운트를 센다.. --;
-	return m_map_kLogonAccount.size();
-}
-
-void CClientManager::SendAllGuildSkillRechargePacket()
-{
-	ForwardPacket(HEADER_DG_GUILD_SKILL_RECHARGE, NULL, 0);
-}
-
-void CClientManager::SendTime()
-{
-	time_t now = GetCurrentTime();
-	ForwardPacket(HEADER_DG_TIME, &now, sizeof(time_t));
-}
-
-void CClientManager::ForwardPacket(BYTE header, const void* data, int size, BYTE bChannel, CPeer* except)
-{
-	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* peer = *it;
-
-		if (peer == except)
-			continue;
-
-		if (!peer->GetChannel())
-			continue;
-
-		if (bChannel && peer->GetChannel() != bChannel)
-			continue;
-
-		peer->EncodeHeader(header, 0, size);
-
-		if (size > 0 && data)
-			peer->Encode(data, size);
-	}
-}
-
-void CClientManager::SendNotice(const char* c_pszFormat, ...)
-{
-	char szBuf[255 + 1];
-	va_list args;
-
-	va_start(args, c_pszFormat);
-	int len = vsnprintf(szBuf, sizeof(szBuf), c_pszFormat, args);
-	va_end(args);
-	szBuf[len] = '\0';
-
-	ForwardPacket(HEADER_DG_NOTICE, szBuf, len + 1);
-}
-
-time_t CClientManager::GetCurrentTime()
-{
-	return time(0);
-}
-
-// ITEM_UNIQUE_ID
-bool CClientManager::InitializeNowItemID()
-{
-	DWORD dwMin, dwMax;
-
-	// 아이템 ID를 초기화 한다.
-	if (!CConfig::instance().GetTwoValue("ITEM_ID_RANGE", &dwMin, &dwMax))
-	{
-		sys_err("config.txt: Cannot find ITEM_ID_RANGE [start_item_id] [end_item_id]");
-		return false;
-	}
-
-	sys_log(0, "ItemRange From File %u ~ %u ", dwMin, dwMax);
-
-	if (CItemIDRangeManager::instance().BuildRange(dwMin, dwMax, m_itemRange) == false)
-	{
-		sys_err("Can not build ITEM_ID_RANGE");
-		return false;
-	}
-
-	sys_log(0, " Init Success Start %u End %u Now %u\n", m_itemRange.dwMin, m_itemRange.dwMax, m_itemRange.dwUsableItemIDMin);
-
-	return true;
-}
-
-DWORD CClientManager::GainItemID()
-{
-	return m_itemRange.dwUsableItemIDMin++;
-}
-
-DWORD CClientManager::GetItemID()
-{
-	return m_itemRange.dwUsableItemIDMin;
-}
-// ITEM_UNIQUE_ID_END
-
-// BOOT_LOCALIZATION
-bool CClientManager::InitializeLocalization()
-{
-	char szQuery[512];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `mValue`, `mKey` FROM `locale`");
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
-
-	if (pMsg->Get()->uiNumRows == 0)
-	{
-		sys_err("InitializeLocalization() ==> DirectQuery failed(%s)", szQuery);
-		delete pMsg;
-		return false;
-	}
-
-	sys_log(0, "InitializeLocalization() - LoadLocaleTable(count:%d)", pMsg->Get()->uiNumRows);
-
-	m_vec_Locale.clear();
-
-	MYSQL_ROW row = NULL;
-
-	for (; (row = mysql_fetch_row(pMsg->Get()->pSQLResult)) != NULL;)
-	{
-		int col = 0;
-		tLocale locale;
-
-		strlcpy(locale.szValue, row[col++], sizeof(locale.szValue));
-		strlcpy(locale.szKey, row[col++], sizeof(locale.szKey));
-
-		// DB_NAME_COLUMN Setting
-		if (strcmp(locale.szKey, "LOCALE") == 0)
-		{
-			if (strcmp(locale.szValue, "cibn") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
-
-				g_stLocale = "gb2312";
-				g_stLocaleNameColumn = "gb2312name";
-			}
-			else if (strcmp(locale.szValue, "ymir") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "euckr";
-				g_stLocaleNameColumn = "name";
-			}
-			else if (strcmp(locale.szValue, "japan") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "sjis");
-
-				g_stLocale = "sjis";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "english") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "germany") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "france") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "italy") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "spain") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "uk") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "turkey") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin5";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "poland") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "portugal") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "hongkong") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
-
-				g_stLocale = "big5";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "newcibn") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
-
-				g_stLocale = "gb2312";
-				g_stLocaleNameColumn = "gb2312name";
-			}
-			else if (strcmp(locale.szValue, "korea") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "euckr";
-				g_stLocaleNameColumn = "name";
-			}
-			else if (strcmp(locale.szValue, "canada") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "gb2312name";
-			}
-			else if (strcmp(locale.szValue, "brazil") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "greek") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "greek";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "russia") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "cp1251";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "denmark") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "bulgaria") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "cp1251";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "croatia") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "cp1251";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "mexico") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "arabia") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "cp1256";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "czech") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "hungary") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "romania") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin2";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "netherlands") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "singapore") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "vietnam") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "thailand") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "usa") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "we_korea") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
-
-				g_stLocale = "euckr";
-				g_stLocaleNameColumn = "name";
-			}
-			else if (strcmp(locale.szValue, "taiwan") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
-				g_stLocale = "big5";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else if (strcmp(locale.szValue, "europe") == 0)
-			{
-				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
-
-				if (g_stLocale != locale.szValue)
-					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
-
-				g_stLocale = "latin1";
-				g_stLocaleNameColumn = "locale_name";
-			}
-			else
-			{
-				sys_err("locale[LOCALE] = UNKNOWN(%s)", locale.szValue);
-				exit(0);
-			}
-
-			CDBManager::instance().SetLocale(g_stLocale.c_str());
-		}
-		else if (strcmp(locale.szKey, "DB_NAME_COLUMN") == 0)
-		{
-			sys_log(0, "locale[DB_NAME_COLUMN] = %s", locale.szValue);
-			g_stLocaleNameColumn = locale.szValue;
-		}
-		else
-		{
-			sys_log(0, "locale[UNKNOWN_KEY(%s)] = %s", locale.szKey, locale.szValue);
-		}
-		m_vec_Locale.push_back(locale);
-	}
-
-	delete pMsg;
-
-	return true;
-}
-// END_BOOT_LOCALIZATION
-
-// ADMIN_MANAGER
-bool CClientManager::__GetAdminInfo(const char* szIP, std::vector<tAdminInfo>& rAdminVec)
-{
-	// szIP == NULL 일경우 모든서버에 운영자 권한을 갖는다.
-	char szQuery[512];
-	snprintf(szQuery, sizeof(szQuery),
-		"SELECT `mID`, `mAccount`, `mName`, `mContactIP`, `mServerIP`, `mAuthority` FROM `gmlist` WHERE `mServerIP` = 'ALL' OR `mServerIP` = '%s'",
-		szIP ? szIP : "ALL");
-
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
-
-	if (pMsg->Get()->uiNumRows == 0)
-	{
-		sys_err("__GetAdminInfo() ==> DirectQuery failed(%s)", szQuery);
-		delete pMsg;
-		return false;
-	}
-
-	MYSQL_ROW row;
-	rAdminVec.reserve(pMsg->Get()->uiNumRows);
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		int idx = 0;
-		tAdminInfo Info;
-
-		str_to_number(Info.m_ID, row[idx++]);
-		trim_and_lower(row[idx++], Info.m_szAccount, sizeof(Info.m_szAccount));
-		strlcpy(Info.m_szName, row[idx++], sizeof(Info.m_szName));
-		strlcpy(Info.m_szContactIP, row[idx++], sizeof(Info.m_szContactIP));
-		strlcpy(Info.m_szServerIP, row[idx++], sizeof(Info.m_szServerIP));
-		std::string stAuth = row[idx++];
-
-		if (!stAuth.compare("IMPLEMENTOR"))
-			Info.m_Authority = GM_IMPLEMENTOR;
-		else if (!stAuth.compare("GOD"))
-			Info.m_Authority = GM_GOD;
-		else if (!stAuth.compare("HIGH_WIZARD"))
-			Info.m_Authority = GM_HIGH_WIZARD;
-		else if (!stAuth.compare("LOW_WIZARD"))
-			Info.m_Authority = GM_LOW_WIZARD;
-		else if (!stAuth.compare("WIZARD"))
-			Info.m_Authority = GM_WIZARD;
-		else
-			continue;
-
-		rAdminVec.push_back(Info);
-
-		sys_log(0, "GM: PID %u Login %s Character %s ContactIP %s ServerIP %s Authority %d[%s]",
-			Info.m_ID, Info.m_szAccount, Info.m_szName, Info.m_szContactIP, Info.m_szServerIP, Info.m_Authority, stAuth.c_str());
-	}
-
-	delete pMsg;
-
-	return true;
-}
-
-bool CClientManager::__GetHostInfo(std::vector<std::string>& rIPVec)
-{
-	char szQuery[512];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `mIP` FROM `gmhost`");
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
-
-	if (pMsg->Get()->uiNumRows == 0)
-	{
-		sys_err("__GetHostInfo() ==> DirectQuery failed(%s)", szQuery);
-		delete pMsg;
-		return false;
-	}
-
-	rIPVec.reserve(pMsg->Get()->uiNumRows);
-
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-	{
-		if (row[0] && *row[0])
-		{
-			rIPVec.push_back(row[0]);
-			sys_log(0, "GMHOST: %s", row[0]);
-		}
-	}
-
-	delete pMsg;
-	return true;
-}
-// END_ADMIN_MANAGER
-
-void CClientManager::ReloadAdmin(CPeer*, TPacketReloadAdmin* p)
-{
-	std::vector<tAdminInfo> vAdmin;
-	std::vector<std::string> vHost;
-
-	__GetHostInfo(vHost);
-	__GetAdminInfo(p->szIP, vAdmin);
-
-	DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
-		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size();
-
-	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* peer = *it;
-
-		if (!peer->GetChannel())
-			continue;
-
-		peer->EncodeHeader(HEADER_DG_RELOAD_ADMIN, 0, dwPacketSize);
-
-		peer->EncodeWORD(16);
-		peer->EncodeWORD(static_cast<WORD>(vHost.size()));
-
-		for (size_t n = 0; n < vHost.size(); ++n)
-			peer->Encode(vHost[n].c_str(), 16);
-
-		peer->EncodeWORD(sizeof(tAdminInfo));
-		peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
-
-		for (size_t n = 0; n < vAdmin.size(); ++n)
-			peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
-	}
-
-	sys_log(0, "ReloadAdmin End %s", p->szIP);
-}
-
-// BREAK_MARRIAGE
-void CClientManager::BreakMarriage(CPeer* peer, const char* data)
-{
-	DWORD pid1, pid2;
-
-	pid1 = *(int*)data;
-	data += sizeof(int);
-
-	pid2 = *(int*)data;
-	data += sizeof(int);
-
-	sys_log(0, "Breaking off a marriage engagement! pid %d and pid %d", pid1, pid2);
-	marriage::CManager::instance().Remove(pid1, pid2);
-}
-// END_BREAK_MARIIAGE
-
-void CClientManager::UpdateItemCacheSet(DWORD pid)
-{
-	auto it = m_map_pkItemCacheSetPtr.find(pid);
-	if (it == m_map_pkItemCacheSetPtr.end())
-	{
-		if (g_test_server)
-			sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCacheSet ==> No ItemCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TItemCacheSet* pSet = it->second;
-	TItemCacheSet::iterator it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CItemCache* c = *it_set++;
-		c->Flush();
-	}
-
-	if (g_log)
-		sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCachsSet pid(%d)", pid);
-}
-
-void CClientManager::Election(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	DWORD idx;
-	DWORD selectingpid;
-
-	idx = *(DWORD*)data;
-	data += sizeof(DWORD);
-
-	selectingpid = *(DWORD*)data;
-	data += sizeof(DWORD);
-
-	int Success = 0;
-
-	if (!(Success = CMonarch::instance().VoteMonarch(selectingpid, idx)))
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_VOTE] Failed %d %d", idx, selectingpid);
-		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
-		peer->Encode(&Success, sizeof(int));
-		return;
-	}
-	else
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_VOTE] Success %d %d", idx, selectingpid);
-		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
-		peer->Encode(&Success, sizeof(int));
-		return;
-	}
-
-}
-
-void CClientManager::Candidacy(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	DWORD pid;
-
-	pid = *(DWORD*)data;
-	data += sizeof(DWORD);
-
-	if (!CMonarch::instance().AddCandidacy(pid, data))
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_CANDIDACY] Failed %d %s", pid, data);
-
-		peer->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
-		peer->Encode(0, sizeof(int));
-		peer->Encode(data, 32);
-		return;
-	}
-	else
-	{
-		if (g_test_server)
-			sys_log(0, "[MONARCH_CANDIDACY] Success %d %s", pid, data);
-
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (0 && p->GetChannel() != 0)
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
-				p->Encode(&pid, sizeof(int));
-				p->Encode(data, 32);
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_CANDIDACY, 0, sizeof(int) + 32);
-				p->Encode(&pid, sizeof(int));
-				p->Encode(data, 32);
-			}
-		}
-	}
-}
-
-void CClientManager::AddMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH] Add money Empire(%d) Money(%d)", Empire, Money);
-
-	CMonarch::instance().AddMoney(Empire, Money);
-
-	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* p = *it;
-
-		if (!p->GetChannel())
-			continue;
-
-		if (p == peer)
-		{
-			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-		else
-		{
-			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-
-	}
-}
-
-void CClientManager::DecMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH] Dec money Empire(%d) Money(%d)", Empire, Money);
-
-	CMonarch::instance().DecMoney(Empire, Money);
-
-	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* p = *it;
-
-		if (!p->GetChannel())
-			continue;
-
-		if (p == peer)
-		{
-			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-		else
-		{
-			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
-			p->Encode(&Empire, sizeof(int));
-			p->Encode(&Money, sizeof(int));
-		}
-	}
-}
-
-void CClientManager::TakeMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	int Empire = *(int*)data;
-	data += sizeof(int);
-
-	DWORD pid = *(DWORD*)data;
-	data += sizeof(int);
-
-	int Money = *(int*)data;
-	data += sizeof(int);
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH] Take money Empire(%d) Money(%d)", Empire, Money);
-
-	if (CMonarch::instance().TakeMoney(Empire, pid, Money) == true)
-	{
-		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-		peer->Encode(&Empire, sizeof(int));
-		peer->Encode(&Money, sizeof(int));
-	}
-	else
-	{
-		Money = 0;
-		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
-		peer->Encode(&Empire, sizeof(int));
-		peer->Encode(&Money, sizeof(int));
-	}
-}
-
-void CClientManager::ComeToVote(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	CMonarch::instance().ElectMonarch();
-}
-
-void CClientManager::RMCandidacy(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	char szName[32];
-
-	strlcpy(szName, data, sizeof(szName));
-	sys_log(0, "[MONARCH_GM] Remove candidacy name(%s)", szName);
-
-	int iRet = CMonarch::instance().DelCandidacy(szName) ? 1 : 0;
-
-	if (1 == iRet)
-	{
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-		}
-	}
-	else
-	{
-		CPeer* p = peer;
-		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-		p->Encode(&iRet, sizeof(int));
-		p->Encode(szName, sizeof(szName));
-	}
-}
-
-void CClientManager::SetMonarch(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	char szName[32];
-
-	strlcpy(szName, data, sizeof(szName));
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH_GM] Set Monarch name(%s)", szName);
-
-	int iRet = CMonarch::instance().SetMonarch(szName) ? 1 : 0;
-
-	if (1 == iRet)
-	{
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-		}
-	}
-	else
-	{
-		CPeer* p = peer;
-		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-		p->Encode(&iRet, sizeof(int));
-		p->Encode(szName, sizeof(szName));
-	}
-}
-
-void CClientManager::RMMonarch(CPeer* peer, DWORD dwHandle, const char* data)
-{
-	char szName[32];
-
-	strlcpy(szName, data, sizeof(szName));
-
-	if (g_test_server)
-		sys_log(0, "[MONARCH_GM] Remove Monarch name(%s)", szName);
-
-	CMonarch::instance().DelMonarch(szName);
-
-	int iRet = CMonarch::instance().DelMonarch(szName) ? 1 : 0;
-
-	if (1 == iRet)
-	{
-		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-		{
-			CPeer* p = *it;
-
-			if (!p->GetChannel())
-				continue;
-
-			if (p == peer)
-			{
-				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-			else
-			{
-				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
-				p->Encode(&iRet, sizeof(int));
-				p->Encode(szName, sizeof(szName));
-			}
-		}
-	}
-	else
-	{
-		CPeer* p = peer;
-		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
-		p->Encode(&iRet, sizeof(int));
-		p->Encode(szName, sizeof(szName));
-	}
-}
-
-void CClientManager::ChangeMonarchLord(CPeer* peer, DWORD dwHandle, TPacketChangeMonarchLord* info)
-{
-	char szQuery[1024];
-	snprintf(szQuery, sizeof(szQuery),
-		"SELECT a.`name`, NOW() FROM player%s AS a, player_index%s AS b WHERE (a.`account_id` = b.`id` AND a.`id` = %u AND b.`empire` = %u) AND "
-		"(b.`pid1` = %u OR "
-		"b.`pid2` = %u OR "
-		"b.`pid3` = %u OR "
-		"b.`pid4` = %u"
-#if defined(__PLAYER_PER_ACCOUNT5__)
-		" OR b.`pid5` = %u"
-#endif
-		")",
-		GetTablePostfix(),
-		GetTablePostfix(),
-		info->dwPID,
-		info->bEmpire,
-		info->dwPID,
-		info->dwPID,
-		info->dwPID,
-		info->dwPID
-#if defined(__PLAYER_PER_ACCOUNT5__)
-		, info->dwPID
-#endif
-	);
-
-	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
-
-	if (pMsg->Get()->uiNumRows != 0)
-	{
-		TPacketChangeMonarchLordACK ack;
-		ack.bEmpire = info->bEmpire;
-		ack.dwPID = info->dwPID;
-
-		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-		strlcpy(ack.szName, row[0], sizeof(ack.szName));
-		strlcpy(ack.szDate, row[1], sizeof(ack.szDate));
-
-		snprintf(szQuery, sizeof(szQuery), "UPDATE `monarch` SET `pid` = %u, `windate` = NOW() WHERE `empire` = %d", ack.dwPID, ack.bEmpire);
-		SQLMsg* pMsg2 = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
-
-		if (pMsg2->Get()->uiAffectedRows > 0)
-		{
-			CMonarch::instance().LoadMonarch();
-
-			TMonarchInfo* newInfo = CMonarch::instance().GetMonarch();
-
-			for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-			{
-				CPeer* client = *it;
-
-				client->EncodeHeader(HEADER_DG_CHANGE_MONARCH_LORD_ACK, 0, sizeof(TPacketChangeMonarchLordACK));
-				client->Encode(&ack, sizeof(TPacketChangeMonarchLordACK));
-
-				client->EncodeHeader(HEADER_DG_UPDATE_MONARCH_INFO, 0, sizeof(TMonarchInfo));
-				client->Encode(newInfo, sizeof(TMonarchInfo));
-			}
-		}
-
-		delete pMsg2;
-	}
-
-	delete pMsg;
-}
-
-void CClientManager::BlockException(TPacketBlockException* data)
-{
-	sys_log(0, "[BLOCK_EXCEPTION] CMD(%d) login(%s)", data->cmd, data->login);
-
-	// save sql
-	{
-		char buf[1024];
-
-		switch (data->cmd)
-		{
-			case BLOCK_EXCEPTION_CMD_ADD:
-				snprintf(buf, sizeof(buf), "INSERT INTO `block_exception` VALUES('%s')", data->login);
-				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
-				CBlockCountry::instance().AddBlockException(data->login);
-				break;
-			case BLOCK_EXCEPTION_CMD_DEL:
-				snprintf(buf, sizeof(buf), "DELETE FROM `block_exception` WHERE `login` = %s", data->login);
-				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
-				CBlockCountry::instance().DelBlockException(data->login);
-				break;
-			default:
-				return;
-		}
-
-	}
-
-	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		CPeer* peer = *it;
-
-		if (!peer->GetChannel())
-			continue;
-
-		CBlockCountry::instance().SendBlockExceptionOne(peer, data->login, data->cmd);
-	}
-}
-
-void CClientManager::SendSpareItemIDRange(CPeer* peer)
-{
-	peer->SendSpareItemIDRange();
-}
-
-//
-// Login Key만 맵에서 지운다.
-//
-void CClientManager::DeleteLoginKey(TPacketDC* data)
-{
-	char login[LOGIN_MAX_LEN + 1] = { 0 };
-	trim_and_lower(data->login, login, sizeof(login));
-
-	CLoginData* pkLD = GetLoginDataByLogin(login);
-
-	if (pkLD)
-	{
-		TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(pkLD->GetKey());
-
-		if (it != m_map_pkLoginData.end())
-			m_map_pkLoginData.erase(it);
-	}
-}
-
-// delete gift notify icon
-void CClientManager::DeleteAwardId(TPacketDeleteAwardID* data)
-{
-	// sys_log(0, "data from game server arrived %d", data->dwID);
-	std::map<DWORD, TItemAward*>::iterator it;
-	it = ItemAwardManager::Instance().GetMapAward().find(data->dwID);
-	if (it != ItemAwardManager::Instance().GetMapAward().end())
-	{
-		std::set<TItemAward*>& kSet = ItemAwardManager::Instance().GetMapkSetAwardByLogin()[it->second->szLogin];
-		if (kSet.erase(it->second))
-			sys_log(0, "erase ItemAward id: %d from cache", data->dwID);
-		ItemAwardManager::Instance().GetMapAward().erase(data->dwID);
-	}
-	else
-	{
-		sys_log(0, "DELETE_AWARDID : could not find the id: %d", data->dwID);
-	}
-}
-
-void CClientManager::UpdateChannelStatus(TChannelStatus* pData)
-{
-	TChannelStatusMap::iterator it = m_mChannelStatus.find(pData->nPort);
-	if (it != m_mChannelStatus.end())
-	{
-		it->second = pData->bStatus;
-	}
-	else
-	{
-		m_mChannelStatus.insert(TChannelStatusMap::value_type(pData->nPort, pData->bStatus));
-	}
-}
-
-void CClientManager::RequestChannelStatus(CPeer* peer, DWORD dwHandle)
-{
-	const int nSize = m_mChannelStatus.size();
-	peer->EncodeHeader(HEADER_DG_RESPOND_CHANNELSTATUS, dwHandle, sizeof(TChannelStatus) * nSize + sizeof(int));
-	peer->Encode(&nSize, sizeof(int));
-	for (TChannelStatusMap::iterator it = m_mChannelStatus.begin(); it != m_mChannelStatus.end(); ++it)
-	{
-		peer->Encode(&it->first, sizeof(short));
-		peer->Encode(&it->second, sizeof(BYTE));
-	}
-}
-
-void CClientManager::ResetLastPlayerID(const TPacketNeedLoginLogInfo* data)
-{
-	CLoginData* pkLD = GetLoginDataByAID(data->dwPlayerID);
-
-	if (NULL != pkLD)
-	{
-		pkLD->SetLastPlayerID(0);
-	}
-}
-
-void CClientManager::ChargeCash(const TRequestChargeCash* packet)
-{
-	char szQuery[512];
-
-	if (ERequestCharge_Cash == packet->eChargeType)
-		sprintf(szQuery, "update account set `cash` = `cash` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
-	else if (ERequestCharge_Mileage == packet->eChargeType)
-		sprintf(szQuery, "update account set `mileage` = `mileage` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
-	else
-	{
-		sys_err("Invalid request charge type (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
-		return;
-	}
-
-	sys_err("Request Charge (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
-
-	CDBManager::Instance().AsyncQuery(szQuery, SQL_ACCOUNT);
-}
-
-#if defined(__MOVE_CHANNEL__)
-void CClientManager::FindChannel(CPeer* requestPeer, DWORD dwHandle, TPacketChangeChannel* p)
-{
-	if (!p->lMapIndex || !p->iChannel)
-		return;
-
-	long lAddr = 0;
-	WORD wPort = 0;
-
-	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
-	{
-		CPeer* peer = *i;
-		if (peer->GetChannel() != p->iChannel) // not the channel we are looking for!
-			continue;
-
-		TMapLocation kMapLocation;
-		thecore_memcpy(kMapLocation.alMaps, peer->GetMaps(), sizeof(kMapLocation.alMaps));
-		int iLen = sizeof(kMapLocation.alMaps) / sizeof(kMapLocation.alMaps[0]);
-
-		for (int i = 0; i < iLen; ++i)
-		{
-			if (kMapLocation.alMaps[i] == p->lMapIndex)
-			{
-				// Get host, and convert to int
-				char host[16];
-				strlcpy(host, peer->GetPublicIP(), sizeof(kMapLocation.szHost));
-				lAddr = inet_addr(host);
-
-				// Target port
-				wPort = peer->GetListenPort();
-
-				break;
-			}
-		}
-
-		if (lAddr && wPort) // We already obtained them
-			break;
-	}
-
-	TPacketReturnChannel r;
-	r.lAddr = lAddr;
-	r.wPort = wPort;
-
-	requestPeer->EncodeHeader(HEADER_DG_CHANNEL_RESULT, dwHandle, sizeof(r));
-	requestPeer->Encode(&r, sizeof(r));
-}
-#endif
-
-#if defined(__ENVIRONMENT_SYSTEM__)
-enum DayMode : BYTE { DAY, NIGHT };
-
-static BYTE GetDayMode(int Hour)
-{
-	if (Hour >= 6 && Hour <= 20)
-		return DayMode::DAY;
-	return DayMode::NIGHT;
-}
-
-static bool IsWinter(int Month)
-{
-	return (Month >= 11 || Month <= 0);
-}
-
-void CClientManager::UpdateEnvironment()
-{
-	time_t CurrentTime = time(nullptr);
-	tm* tm = localtime(&CurrentTime);
-
-	auto SendFlag = [&](const char* flag, BYTE val)
-		{
-			TEventFlagMap::const_iterator it = m_map_lEventFlag.find(flag);
-			if ((it != m_map_lEventFlag.end() && it->second == val) == false)
-			{
-				TPacketSetEventFlag p;
-				std::strcpy(p.szFlagName, flag);
-				p.lValue = val;
-				SetEventFlag(&p);
-			}
-		};
-
-	SendFlag("eclipse", GetDayMode(tm->tm_hour));
-	BOOL Winter = IsWinter(tm->tm_mon);
-	for (const auto& Flag : { "xmas_snow" })
-		SendFlag(Flag, Winter);
-}
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-void CClientManager::QUERY_EMOTE_LOAD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
-{
-	if (pTable == nullptr)
-		return;
-
-	TEmoteTableVector* pVec = nullptr;
-	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
-	if (it != m_map_kPlayerEmote.end())
-		pVec = &it->second;
-
-	if (pVec && !pVec->empty())
-	{
-		const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
-		pVec->erase(std::remove_if(pVec->begin(), pVec->end(),
-			[dwCurrentTime](const TPacketGDEmote& rkTable)
-			{
-				return dwCurrentTime > rkTable.dwDuration;
-			}
-		), pVec->end());
-	}
-
-	const WORD wSize = pVec ? static_cast<WORD>(pVec->size()) : 0;
-	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(TPacketGDEmote) * wSize;
-
-	pkPeer->EncodeHeader(HEADER_DG_EMOTE_LOAD, dwHandle, dwPacketSize);
-	pkPeer->EncodeWORD(sizeof(TPacketGDEmote));
-	pkPeer->EncodeWORD(wSize);
-	if (pVec && !pVec->empty())
-		pkPeer->Encode(&(*pVec)[0], sizeof(TPacketGDEmote) * wSize);
-}
-
-void CClientManager::QUERY_EMOTE_CLEAR(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
-{
-	if (pTable == nullptr)
-		return;
-
-	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
-	if (it != m_map_kPlayerEmote.end())
-		it->second.clear();
-
-	QUERY_EMOTE_LOAD(pkPeer, dwHandle, pTable);
-}
-
-void CClientManager::QUERY_EMOTE_ADD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
-{
-	if (!pkPeer || !pTable)
-		return;
-
-	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
-
-	TPacketGDEmote GDPacket;
-	GDPacket.dwPID = pTable->dwPID;
-	GDPacket.dwVnum = pTable->dwVnum;
-	GDPacket.dwDuration = dwCurrentTime + pTable->dwDuration;
-
-	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
-	if (it != m_map_kPlayerEmote.end())
-	{
-		TEmoteTableVector& rkVec = it->second;
-		if (rkVec.size() >= SPECIAL_ACTION_SLOT_COUNT)
-		{
-			TPacketGDEmote& rkTable = rkVec[number(0, rkVec.size() - 1)];
-			if (dwCurrentTime >= rkTable.dwDuration)
-				rkTable.dwDuration = dwCurrentTime + pTable->dwDuration;
-			else
-				rkTable.dwDuration += pTable->dwDuration;
-
-			GDPacket.dwVnum = rkTable.dwVnum;
-			GDPacket.dwDuration = rkTable.dwDuration;
-		}
-		else
-		{
-			TEmoteTableVector::iterator itVec = std::find_if(rkVec.begin(), rkVec.end(),
-				[pTable](const TPacketGDEmote& rkTable)
-				{
-					return rkTable.dwVnum == pTable->dwVnum;
-				});
-
-			if (itVec != rkVec.end())
-			{
-				if (dwCurrentTime >= itVec->dwDuration)
-					itVec->dwDuration = dwCurrentTime + pTable->dwDuration;
-				else
-					itVec->dwDuration += pTable->dwDuration;
-
-				GDPacket.dwDuration = itVec->dwDuration;
-			}
-			else
-			{
-				pTable->dwDuration = GDPacket.dwDuration;
-				rkVec.emplace_back(*pTable);
-			}
-		}
-	}
-	else
-	{
-		pTable->dwDuration = GDPacket.dwDuration;
-		m_map_kPlayerEmote[pTable->dwPID].emplace_back(*pTable);
-	}
-
-	pkPeer->EncodeHeader(HEADER_DG_EMOTE_GET, dwHandle, sizeof(GDPacket));
-	pkPeer->Encode(&GDPacket, sizeof(GDPacket));
-}
-
-void CClientManager::QUERY_EMOTE_DUMP()
-{
-	CDBManager::instance().DirectQuery("TRUNCATE TABLE `player`.`emotions`");
-
-	if (m_map_kPlayerEmote.empty())
-		return;
-
-	char szQuery[1024];
-	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
-
-	for (TPlayerEmoteMap::value_type& it : m_map_kPlayerEmote)
-	{
-		TEmoteTableVector& rkVec = it.second;
-		if (rkVec.empty())
-			continue;
-
-		rkVec.erase(std::remove_if(rkVec.begin(), rkVec.end(),
-			[dwCurrentTime](const TPacketGDEmote& rkTable)
-			{
-				return dwCurrentTime > rkTable.dwDuration;
-			}
-		), rkVec.end());
-
-		for (const TPacketGDEmote& rkTable : rkVec)
-		{
-			snprintf(szQuery, sizeof(szQuery),
-				"REPLACE INTO emotions%s (`pid`, `vnum`, `duration`) VALUES(%d, %d, FROM_UNIXTIME(%d))",
-				GetTablePostfix(), rkTable.dwPID, rkTable.dwVnum, rkTable.dwDuration
-			);
-
-			std::unique_ptr<SQLMsg> pkInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-}
-#endif
-
-#if defined(__MAILBOX__)
-void CClientManager::QUERY_MAILBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	if (g_log)
-		sys_log(0, "QUERY_MAILBOX (handle: %d ch: %s)", dwHandle, p->szName);
-
-	std::vector<SMailBoxTable>* vec = nullptr;
-	auto it = m_map_mailbox.find(p->szName);
-	if (it != m_map_mailbox.end())
-		vec = &it->second;
-
-	if (vec)
-	{
-		const time_t now = std::time(nullptr);
-
-		vec->erase(std::remove_if(vec->begin(), vec->end(),
-			[now](const TMailBoxTable& mail)
-			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
-		), vec->end());
-
-		std::sort(vec->begin(), vec->end(),
-			[](const TMailBoxTable& l, const TMailBoxTable& r)
-			{
-				return l.Message.SendTime > r.Message.SendTime;
-			});
-	}
-
-	const WORD size = vec ? static_cast<WORD>(vec->size()) : 0;
-	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(SMailBoxTable) * size;
-
-	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_LOAD, dwHandle, dwPacketSize);
-	pkPeer->EncodeWORD(sizeof(SMailBoxTable));
-	pkPeer->EncodeWORD(size);
-
-	if (vec && vec->empty() == false)
-		pkPeer->Encode(&(*vec)[0], sizeof(SMailBoxTable) * size);
-}
-
-void CClientManager::QUERY_MAILBOX_CHECK_NAME(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	TMailBox t;
-	std::memcpy(t.szName, "", sizeof(t.szName));
-	t.Index = 0; // Index: Mail Count
-
-	static std::unordered_set<std::string> NameSet;
-	bool bFound = NameSet.find(p->szName) != NameSet.end();
-
-	if (bFound == false)
-	{
-		char s_szQuery[128];
-		//snprintf(s_szQuery, sizeof(s_szQuery), "SELECT * FROM player%s WHERE `name` = '%s' LIMIT 1", GetTablePostfix(), p->szName);
-		snprintf(s_szQuery, sizeof(s_szQuery), "SELECT * FROM player%s WHERE `name` = convert('%s' using utf8mb4) collate utf8mb4_bin LIMIT 1", GetTablePostfix(), p->szName);
-		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(s_szQuery));
-		bFound = pMsg->Get()->uiNumRows > 0;
-	}
-
-	if (bFound)
-	{
-		NameSet.emplace(p->szName); // player exists, next time we will use this to avoid using mysql.
-		std::memcpy(t.szName, p->szName, sizeof(t.szName));
-		auto it = m_map_mailbox.find(p->szName);
-		if (it != m_map_mailbox.end())
-		{
-			const time_t now = time(nullptr);
-			for (const SMailBoxTable& mail : it->second)
-			{
-				if (mail.bIsDeleted)
-					continue;
-
-				if (std::difftime(mail.Message.DeleteTime, now) <= 0)
-					continue;
-
-				t.Index++;
-			}
-		}
-	}
-
-	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_CHECK_NAME, dwHandle, sizeof(TMailBox));
-	pkPeer->Encode(&t, sizeof(TMailBox));
-}
-
-void CClientManager::QUERY_MAILBOX_WRITE(CPeer* pkPeer, DWORD dwHandle, TMailBoxTable* p)
-{
-	m_map_mailbox[p->szName].emplace_back(*p);
-}
-
-bool CClientManager::GET_MAIL(const char* name, const BYTE index, SMailBoxTable** mail)
-{
-	auto it = m_map_mailbox.find(name);
-	if (it == m_map_mailbox.end())
-		return false;
-
-	MailVec& mailvec = it->second;
-	if (index >= mailvec.size())
-		return false;
-
-	*mail = &mailvec.at(index);
-	return true;
-}
-
-void CClientManager::QUERY_MAILBOX_DELETE(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	SMailBoxTable* mail = nullptr;
-	if (GET_MAIL(p->szName, p->Index, &mail) == false)
-		return;
-
-	mail->bIsDeleted = true;
-}
-
-void CClientManager::QUERY_MAILBOX_CONFIRM(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	SMailBoxTable* mail = nullptr;
-	if (GET_MAIL(p->szName, p->Index, &mail) == false)
-		return;
-
-	mail->Message.bIsConfirm = true;
-}
-
-void CClientManager::QUERY_MAILBOX_GET(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	SMailBoxTable* mail = nullptr;
-	if (GET_MAIL(p->szName, p->Index, &mail) == false)
-		return;
-
-	mail->AddData.iYang = 0;
-	mail->AddData.iWon = 0;
-	mail->Message.bIsItemExist = false;
-	mail->Message.bIsConfirm = true;
-	mail->AddData.dwItemVnum = 0;
-	mail->AddData.dwItemCount = 0;
-	memset(mail->AddData.alSockets, 0, sizeof(mail->AddData.alSockets));
-	memset(mail->AddData.aAttr, 0, sizeof(mail->AddData.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	mail->AddData.dwChangeLookVnum = 0;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	memset(&mail->AddData.RefineElement, 0, sizeof(mail->AddData.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-	memset(mail->AddData.aApplyRandom, 0, sizeof(mail->AddData.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-	mail->AddData.bSetValue = 0;
-#endif
-}
-
-void CClientManager::QUERY_MAILBOX_UNREAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
-{
-	auto it = m_map_mailbox.find(p->szName);
-	if (it == m_map_mailbox.end())
-		return;
-
-	const MailVec& mailvec = it->second;
-	if (mailvec.empty())
-		return;
-
-	const time_t now = time(nullptr);
-	TMailBoxRespondUnreadData t;
-
-	for (const SMailBoxTable& mail : it->second)
-	{
-		if (mail.bIsDeleted)
-			continue;
-
-		if (mail.Message.bIsConfirm)
-			continue;
-
-		if (std::difftime(mail.Message.DeleteTime, now) <= 0)
-			continue;
-
-		if (mail.Message.bIsGMPost)
-			t.bGMVisible = true;
-
-		if (mail.Message.bIsItemExist)
-			t.bItemMessageCount++;
-		else
-			t.bCommonMessageCount++;
-	}
-
-	if ((t.bItemMessageCount + t.bCommonMessageCount) < 1)
-		return;
-
-	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_UNREAD, dwHandle, sizeof(TMailBoxRespondUnreadData));
-	pkPeer->Encode(&t, sizeof(TMailBoxRespondUnreadData));
-}
-
-void CClientManager::MAILBOX_BACKUP()
-{
-	CDBManager::instance().DirectQuery("TRUNCATE TABLE player.mailbox");
-
-	if (m_map_mailbox.empty())
-		return;
-
-	char szQuery[QUERY_MAX_LEN];
-	const time_t now = std::time(nullptr);
-
-	for (auto& p : m_map_mailbox)
-	{
-		auto& mailvec = p.second;
-		if (mailvec.empty())
-			continue;
-
-		mailvec.erase(std::remove_if(mailvec.begin(), mailvec.end(),
-			[now](const TMailBoxTable& mail)
-			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
-		), mailvec.end());
-
-		std::sort(mailvec.begin(), mailvec.end(),
-			[](const TMailBoxTable& l, const TMailBoxTable& r)
-			{
-				return l.Message.SendTime > r.Message.SendTime;
-			});
-
-		for (const auto& mail : mailvec)
-		{
-			snprintf(szQuery, sizeof(szQuery),
-				"INSERT INTO `mailbox%s` (`name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`"
-				", `gold`, `won`, `vnum`, `count`"
-				", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-				", `socket3`, `socket4`, `socket5`"
-#endif
-				", `attrtype0`, `attrvalue0`"
-				", `attrtype1`, `attrvalue1`"
-				", `attrtype2`, `attrvalue2`"
-				", `attrtype3`, `attrvalue3`"
-				", `attrtype4`, `attrvalue4`"
-				", `attrtype5`, `attrvalue5`"
-				", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				", `changelookvnum`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				", `refine_element_apply_type`"
-				", `refine_element_grade`"
-				", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-				", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-				", `apply_type0`, `apply_value0`, `apply_path0`"
-				", `apply_type1`, `apply_value1`, `apply_path1`"
-				", `apply_type2`, `apply_value2`, `apply_path2`"
-				", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-				", `set_value`"
-#endif
-				") VALUES ('%s', '%s', '%s', '%s', %d, %d, %d, %d" // `name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`
-				", %u, %u, %u, %u" // `gold`, `won`, `vnum`, `count`
-				", %ld, %ld, %ld" // `socket0`, `socket1`, `socket2`
-#if defined(__ITEM_SOCKET6__)
-				", %ld, %ld, %ld" // `socket3`, `socket4`, `socket5`
-#endif
-				", %u, %ld" // `attrtype0`, `attrvalue0`
-				", %u, %ld" // `attrtype1`, `attrvalue1`
-				", %u, %ld" // `attrtype2`, `attrvalue2`
-				", %u, %ld" // `attrtype3`, `attrvalue3`
-				", %u, %ld" // `attrtype4`, `attrvalue4`
-				", %u, %ld" // `attrtype5`, `attrvalue5`
-				", %u, %ld" // `attrtype6`, `attrvalue6`
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				", %u" // `changelookvnum`
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				", %u" // `refine_element_apply_type`
-				", %u" // `refine_element_grade`
-				", %u, %u, %u" // `refine_element_value0`, `refine_element_value1`, `refine_element_value2`
-				", %u, %u, %u" // `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-				", %u, %ld, %d" // `apply_type0`, `apply_value0`, `apply_path0`
-				", %u, %ld, %d" // `apply_type1`, `apply_value1`, `apply_path1`
-				", %u, %ld, %d" // `apply_type2`, `apply_value2`, `apply_path2`
-				", %u, %ld, %d" // `apply_type3`, `apply_value3`, `apply_path3`
-#endif
-#if defined(__SET_ITEM__)
-				", %d" // `set_value`
-#endif
-				")", GetTablePostfix()
-				, mail.szName
-				, mail.AddData.szFrom
-				, mail.Message.szTitle
-				, mail.AddData.szMessage
-				, mail.Message.bIsGMPost
-				, mail.Message.bIsConfirm
-				, mail.Message.SendTime
-				, mail.Message.DeleteTime
-				, mail.AddData.iYang
-				, mail.AddData.iWon
-				, mail.AddData.dwItemVnum
-				, mail.AddData.dwItemCount
-				, mail.AddData.alSockets[0], mail.AddData.alSockets[1], mail.AddData.alSockets[2]
-#if defined(__ITEM_SOCKET6__)
-				, mail.AddData.alSockets[3], mail.AddData.alSockets[4], mail.AddData.alSockets[5]
-#endif
-				, mail.AddData.aAttr[0].wType, mail.AddData.aAttr[0].lValue
-				, mail.AddData.aAttr[1].wType, mail.AddData.aAttr[1].lValue
-				, mail.AddData.aAttr[2].wType, mail.AddData.aAttr[2].lValue
-				, mail.AddData.aAttr[3].wType, mail.AddData.aAttr[3].lValue
-				, mail.AddData.aAttr[4].wType, mail.AddData.aAttr[4].lValue
-				, mail.AddData.aAttr[5].wType, mail.AddData.aAttr[5].lValue
-				, mail.AddData.aAttr[6].wType, mail.AddData.aAttr[6].lValue
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				, mail.AddData.dwChangeLookVnum
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				, mail.AddData.RefineElement.wApplyType
-				, mail.AddData.RefineElement.bGrade
-				, mail.AddData.RefineElement.abValue[0], mail.AddData.RefineElement.abValue[1], mail.AddData.RefineElement.abValue[2]
-				, mail.AddData.RefineElement.abBonusValue[0], mail.AddData.RefineElement.abBonusValue[1], mail.AddData.RefineElement.abBonusValue[2]
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-				, mail.AddData.aApplyRandom[0].wType, mail.AddData.aApplyRandom[0].lValue, mail.AddData.aApplyRandom[0].bPath
-				, mail.AddData.aApplyRandom[1].wType, mail.AddData.aApplyRandom[1].lValue, mail.AddData.aApplyRandom[1].bPath
-				, mail.AddData.aApplyRandom[2].wType, mail.AddData.aApplyRandom[2].lValue, mail.AddData.aApplyRandom[2].bPath
-				, mail.AddData.aApplyRandom[3].wType, mail.AddData.aApplyRandom[3].lValue, mail.AddData.aApplyRandom[3].bPath
-#endif
-#if defined(__SET_ITEM__)
-				, mail.AddData.bSetValue
-#endif
-			);
-
-			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-}
-#endif
-
-#if defined(__GEM_SHOP__)
-void CClientManager::LoadGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopLoad* pTable, bool bUpdate)
-{
-	if (g_log)
-		sys_log(0, "LoadGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
-
-	TGemShopTable GemShopTable = {};
-#	if defined(__CONQUEROR_LEVEL__)
-	GemShopTable.bSpecial = pTable->bSpecial;
-	if (GemShopTable.bSpecial)
-	{
-		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
-		if (it != m_mapGemShopSpecialTable.end())
-			GemShopTable = it->second;
-	}
-	else
-#	endif
-	{
-		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
-		if (it != m_mapGemShopTable.end())
-			GemShopTable = it->second;
-	}
-
-	pPeer->EncodeHeader(bUpdate ? HEADER_DG_GEM_SHOP_UPDATE : HEADER_DG_GEM_SHOP_LOAD, dwHandle, sizeof(GemShopTable));
-	pPeer->Encode(&GemShopTable, sizeof(GemShopTable));
-}
-
-void CClientManager::UpdateGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopTable* pTable)
-{
-	if (g_log)
-		sys_log(0, "UpdateGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
-
-#	if defined(__CONQUEROR_LEVEL__)
-	if (pTable->bSpecial)
-	{
-		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
-		if (it != m_mapGemShopSpecialTable.end())
-			it->second = *pTable;
-		else
-			m_mapGemShopSpecialTable.emplace(std::make_pair(pTable->dwPID, *pTable));
-	}
-	else
-#	endif
-	{
-		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
-		if (it != m_mapGemShopTable.end())
-			it->second = *pTable;
-		else
-			m_mapGemShopTable.emplace(std::make_pair(pTable->dwPID, *pTable));
-	}
-
-	// NOTE : Request Gem Shop Load
-	TGemShopLoad Packet;
-	Packet.dwPID = pTable->dwPID;
-#	if defined(__CONQUEROR_LEVEL__)
-	Packet.bSpecial = pTable->bSpecial;
-#	endif
-	LoadGemShop(pPeer, dwHandle, &Packet, true);
-}
-
-void CClientManager::FlushGemShop()
-{
-	// Flush Default Gem Shop Table
-	{
-		if (m_mapGemShopTable.empty())
-			return;
-
-		char szQuery[1024] = {};
-		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop%s`", GetTablePostfix());
-		CDBManager::instance().DirectQuery(szQuery);
-
-		GemShopTableMap::iterator it = m_mapGemShopTable.begin();
-		for (; it != m_mapGemShopTable.end(); ++it)
-		{
-			TGemShopTable GemShopTable = it->second;
-			if (it->first != GemShopTable.dwPID)
-				continue;
-
-			char szColumns[1024] = {};
-			char szValues[1024] = {};
-
-			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
-			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
-
-			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
-			{
-				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
-					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
-				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
-					GemShopTable.GemShopItem[bSlotIndex].bEnable,
-					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
-					GemShopTable.GemShopItem[bSlotIndex].bCount,
-					GemShopTable.GemShopItem[bSlotIndex].dwPrice
-				);
-			}
-
-			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop%s` (%s) VALUES(%s)",
-				GetTablePostfix(), szColumns, szValues);
-
-			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-
-#	if defined(__CONQUEROR_LEVEL__)
-	// Flush Port (Special) Gem Shop Table
-	{
-		if (m_mapGemShopSpecialTable.empty())
-			return;
-
-		char szQuery[1024] = {};
-		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop_port%s`", GetTablePostfix());
-		CDBManager::instance().DirectQuery(szQuery);
-
-		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.begin();
-		for (; it != m_mapGemShopSpecialTable.end(); ++it)
-		{
-			TGemShopTable GemShopTable = it->second;
-			if (it->first != GemShopTable.dwPID)
-				continue;
-
-			char szColumns[1024] = {};
-			char szValues[1024] = {};
-
-			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
-			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
-
-			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
-			{
-				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
-					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
-				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
-					GemShopTable.GemShopItem[bSlotIndex].bEnable,
-					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
-					GemShopTable.GemShopItem[bSlotIndex].bCount,
-					GemShopTable.GemShopItem[bSlotIndex].dwPrice
-				);
-			}
-
-			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop_port%s` (%s) VALUES(%s)",
-				GetTablePostfix(), szColumns, szValues);
-
-			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
-		}
-	}
-#	endif
-}
-#endif
-
-#ifdef __OFFLINE_SHOP__
-void CClientManager::InitializeNextOfflineShopId()
-{
-	std::stringstream query;
-	query << "SELECT MAX(id) + 1 FROM offline_shop" << GetTablePostfix();
-
-	std::unique_ptr<SQLMsg> msg(CDBManager::Instance().DirectQuery(query.str().c_str()));
-	if (msg && msg->Get()->uiNumRows > 0) {
-		auto row = mysql_fetch_row(msg->Get()->pSQLResult);
-		str_to_number(nextOfflineShopId_, row[0]);
-	}
-	else {
-		nextOfflineShopId_ = 1;
-	}
-
-	sys_log(0, "Next offline shop id: %u", nextOfflineShopId_);
-}
-
-void CClientManager::RequestOfflineShopId(CPeer* peer, uint32_t queueId)
-{
-	peer->EncodeHeader(HEADER_DG_RESPOND_OFFLINE_SHOP_ID, 0, sizeof(uint32_t) + sizeof(uint32_t));
-	peer->Encode(&queueId, sizeof(uint32_t));
-	peer->Encode(&nextOfflineShopId_, sizeof(uint32_t));
-
-	nextOfflineShopId_++;
-}
-
-void CClientManager::SaveOfflineShop(const TOfflineShop& data, bool skipQuery)
-{
-	auto it = offlineShopCache_.find(data.id);
-	if (it != offlineShopCache_.end()) {
-		it->second->Put(&data);
-	}
-	else {
-		auto cache = std::unique_ptr<COfflineShopCache>(new COfflineShopCache());
-		cache->Put(&data, skipQuery);
-
-		offlineShopCache_.insert(std::make_pair(data.id, std::move(cache)));
-	}
-}
-
-void CClientManager::SaveOfflineShopItem(const TOfflineShopItem& data, bool skipQuery)
-{
-	auto it = offlineShopItemCache_.find(data.id);
-	if (it != offlineShopItemCache_.end()) {
-		it->second->Put(&data);
-	}
-	else {
-		auto cache = std::unique_ptr<COfflineShopItemCache>(new COfflineShopItemCache());
-		cache->Put(&data, skipQuery);
-
-		offlineShopItemCache_.insert(std::make_pair(data.id, std::move(cache)));
-	}
-}
-
-void CClientManager::DestroyOfflineShop(uint32_t id)
-{
-	auto it = offlineShopCache_.find(id);
-	if (it != offlineShopCache_.end()) {
-		offlineShopCache_.erase(it);
-	}
-
-	std::pair<uint32_t, uint16_t> key = { id, 0 };
-	for (uint16_t i = 0; i < OFFLINE_SHOP_ITEM_COUNT; ++i) {
-		key.second = i;
-
-		auto it = offlineShopItemCache_.find(key);
-		if (it != offlineShopItemCache_.end()) {
-			offlineShopItemCache_.erase(it);
-		}
-	}
-
-	std::stringstream queryDeleteOfflineShop;
-	queryDeleteOfflineShop << "DELETE FROM offline_shop" << GetTablePostfix() << " WHERE id = " << id;
-	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShop.str().c_str());
-
-	std::stringstream queryDeleteOfflineShopItems;
-	queryDeleteOfflineShopItems << "DELETE FROM offline_shop_item" << GetTablePostfix() << " WHERE owner_pid = " << id;
-	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShopItems.str().c_str());
-}
-
-void CClientManager::UpdateOfflineShopCache()
-{
-	auto it = offlineShopCache_.begin();
-	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopCache_.end()) {
-		if (it->second->CheckFlushTimeout()) {
-			it->second->Flush();
-
-			m_iCacheFlushCount++;
-		}
-
-		it++;
-	}
-}
-
-void CClientManager::UpdateOfflineShopItemCache()
-{
-	auto it = offlineShopItemCache_.begin();
-	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopItemCache_.end()) {
-		if (it->second->CheckFlushTimeout()) {
-			it->second->Flush();
-
-			m_iCacheFlushCount++;
-		}
-
-		it++;
-	}
-}
-
-void CClientManager::FlushOfflineShops()
-{
-	for (auto it = offlineShopCache_.begin(); it != offlineShopCache_.end(); ++it) {
-		it->second->Flush();
-	}
-
-	for (auto it = offlineShopItemCache_.begin(); it != offlineShopItemCache_.end(); ++it) {
-		it->second->Flush();
-	}
-}
-
-const TItemTable* CClientManager::GetItemTable(DWORD vnum) const
-{
-	auto it = m_map_itemTableByVnum.find(vnum);
-	if (it == m_map_itemTableByVnum.end())
-	{
-		return NULL;
-	}
-
-	return it->second;
-}
-
-BYTE CClientManager::GetRealItemType(DWORD vnum)
-{
-	if (vnum >= 110000 && vnum <= 165499)
-		return ITEM_DS;
-	
-	
-	/* SHIT :
-	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
-	{
-		if (it->second->dwVnum == vnum)
-		{
-			return it->second->bType;
-		}
-	}
-	*/
-	
-	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
-	{
-		if (it->dwVnum == vnum)
-		{
-			return it->bType;
-		}
-	}
-	
-	return ITEM_NONE;
-}
-
-BYTE CClientManager::GetRealItemSubType(DWORD vnum)
-{
-	/* SHIT:
-	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
-	{
-		if (it->second->dwVnum == vnum)
-		{
-			return it->second->bSubType;
-		}
-	}
-	*/
-	
-	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
-	{
-		if (it->dwVnum == vnum)
-		{
-			return it->bSubType;
-		}
-	}
-	
-	return 0;
-}
-
-void CClientManager::GetRealItemLimit(DWORD vnum, int & limitType, DWORD & limitValue)
-{
-	/* BUGGED SHIT :
-	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
-	{
-		if (it->second->dwVnum == vnum)
-		{
-			limitType = it->second->aLimits[0].bType;
-			limitValue = it->second->aLimits[0].lValue;
-			return;
-		}
-	}
-	*/
-	
-	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
-	{
-		if (it->dwVnum == vnum)
-		{
-			limitType = it->aLimits[0].bType;
-			limitValue = it->aLimits[0].lValue;
-			return;
-		}
-	}
-}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-CClientManager::TGrowthPetCacheSet* CClientManager::GetGrowthPetCacheSet(DWORD pid)
-{
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
-
-	if (it == m_map_pkGrowthPetCacheSetPtr.end())
-		return nullptr;
-
-	return it->second;
-}
-
-void CClientManager::CreateGrowthPetCacheSet(DWORD pid)
-{
-	if (m_map_pkGrowthPetCacheSetPtr.find(pid) != m_map_pkGrowthPetCacheSetPtr.end())
-		return;
-				 
-	TGrowthPetCacheSet* pSet = new TGrowthPetCacheSet;
-	m_map_pkGrowthPetCacheSetPtr.insert(TGrowthPetCacheSetPtrMap::value_type(pid, pSet));
-
-	if (g_log)
-		sys_log(0, "GROWTH_PET_CACHE: new cache %u", pid);
-}
-
-void CClientManager::FlushGrowthPetCacheSet(DWORD pid)
-{
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
-
-	if (it == m_map_pkGrowthPetCacheSetPtr.end())
-	{
-		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : No GrowthPetCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TGrowthPetCacheSet* pSet = it->second;
-	auto it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CGrowthPetCache* c = *it_set++;
-		c->Flush();
-
-		m_map_growthPetCache.erase(c->Get()->dwID);
-		delete c;
-	}
-
-	pSet->clear();
-	delete pSet;
-
-	m_map_pkGrowthPetCacheSetPtr.erase(it);
-
-	if (g_log)
-		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : Deleted pid(%d)", pid);
-}
-
-CGrowthPetCache* CClientManager::GetGrowthPetCache(DWORD id)
-{
-	auto it = m_map_growthPetCache.find(id);
-
-	if (it == m_map_growthPetCache.end())
-		return nullptr;
-
-	return it->second;
-}
-
-void CClientManager::PutGrowthPetCache(TGrowthPet* pNew, bool bSkipQuery)
-{
-	CGrowthPetCache* c;
-
-	c = GetGrowthPetCache(pNew->dwID);
-	if (!c)
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> New CGrowthPetCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
-
-		c = new CGrowthPetCache;
-		m_map_growthPetCache.insert(TGrowthPetCacheMap::value_type(pNew->dwID, c));
-	}
-	else
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> Have Cache");
-		if (pNew->dwOwner != c->Get()->dwOwner)
-		{
-			auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
-
-			if (it != m_map_pkGrowthPetCacheSetPtr.end())
-			{
-				if (g_log)
-					sys_log(0, "GROWTH_PET_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
-				it->second->erase(c);
-			}
-		}
-	}
-	c->Put(pNew, bSkipQuery);
-
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
-
-	if (it != m_map_pkGrowthPetCacheSetPtr.end())
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		it->second->insert(c);
-	}
-	else
-	{
-		if (g_log)
-			sys_log(0, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-		else
-			sys_log(1, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
-
-		c->OnFlush();
-	}
-}
-
-bool CClientManager::DeleteGrowthPetCache(DWORD dwID)
-{
-	CGrowthPetCache* c = GetGrowthPetCache(dwID);
-
-	if (!c)
-		return false;
-
-	c->Delete();
-	return true;
-}
-
-void CClientManager::UpdateGrowthPetCache()
-{
-	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-		return;
-
-	auto it = m_map_growthPetCache.begin();
-
-	while (it != m_map_growthPetCache.end())
-	{
-		CGrowthPetCache* c = (it++)->second;
-
-		if (c->CheckFlushTimeout())
-		{
-			if (g_test_server)
-				sys_log(0, "UpdateGrowthPetCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
-
-			c->Flush();
-
-			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
-				break;
-		}
-	}
-}
-
-void CClientManager::UpdateGrowthPetCacheSet(DWORD pid)
-{
-	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
-
-	if (it == m_map_pkGrowthPetCacheSetPtr.end())
-	{
-		if (g_test_server)
-			sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet ==> No GrowthPetCacheSet pid(%d)", pid);
-		return;
-	}
-
-	TGrowthPetCacheSet* pSet = it->second;
-	auto it_set = pSet->begin();
-
-	while (it_set != pSet->end())
-	{
-		CGrowthPetCache* c = *it_set++;
-		c->Flush();
-	}
-
-	if (g_log)
-		sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet pid(%d)", pid);
-}
-
-void CClientManager::QUERY_GROWTH_PET_SAVE(CPeer* pkPeer, const char* c_pData)
-{
-	TGrowthPet* p = (TGrowthPet*)c_pData;
-	if (g_test_server)
-		sys_log(0, "QUERY_GROWTH_PET_SAVE => PutGrowthPetCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
-
-	PutGrowthPetCache(p);
-}
-
-void CClientManager::QUERY_GROWTH_PET_DELETE(CPeer* pkPeer, const char* c_pData)
-{
-	DWORD dwID = *(DWORD*)c_pData;
-	c_pData += sizeof(DWORD);
-
-	DWORD dwPID = *(DWORD*)c_pData;
-
-	if (!DeleteGrowthPetCache(dwID))
-	{
-		char szQuery[64];
-		snprintf(szQuery, sizeof(szQuery), "DELETE FROM growth_pet%s WHERE id=%u", GetTablePostfix(), dwID);
-
-		if (dwPID == 0)
-			CDBManager::instance().AsyncQuery(szQuery);
-		else
-			CDBManager::instance().ReturnQuery(szQuery, QID_GROWTH_PET_DELETE, pkPeer->GetHandle(), NULL);
-	}
-}
-
-bool CClientManager::CreateGrowthPetTableFromRes(MYSQL_RES* res, std::vector<TGrowthPet>* pVec, DWORD dwPID)
-{
-	if (!res)
-	{
-		pVec->clear();
-		return true;
-	}
-
-	int rows;
-
-	if ((rows = mysql_num_rows(res)) <= 0)
-	{
-		pVec->clear();
-		return true;
-	}
-
-	pVec->resize(rows);
-
-	for (int i = 0; i < rows; ++i)
-	{
-		MYSQL_ROW row = mysql_fetch_row(res);
-		TGrowthPet& pet = pVec->at(i);
-
-		int cur = 0;
-
-		str_to_number(pet.dwID, row[cur++]);
-		str_to_number(pet.dwVnum, row[cur++]);
-		str_to_number(pet.bState, row[cur++]);
-		strlcpy(pet.szName, row[cur++], sizeof(pet.szName));
-		str_to_number(pet.bSize, row[cur++]);
-		str_to_number(pet.dwLevel, row[cur++]);
-		str_to_number(pet.bLevelStep, row[cur++]);
-		str_to_number(pet.bEvolution, row[cur++]);
-		str_to_number(pet.bType, row[cur++]);
-		str_to_number(pet.dwHP, row[cur++]);
-		str_to_number(pet.dwSP, row[cur++]);
-		str_to_number(pet.dwDef, row[cur++]);
-		str_to_number(pet.dwHPApply, row[cur++]);
-		str_to_number(pet.dwSPApply, row[cur++]);
-		str_to_number(pet.dwDefApply, row[cur++]);
-		str_to_number(pet.dwAgeApply, row[cur++]);
-		thecore_memcpy(pet.aSkill, row[cur++], sizeof(pet.aSkill));
-		str_to_number(pet.lExp, row[cur++]);
-		str_to_number(pet.lItemExp, row[cur++]);
-		str_to_number(pet.lBirthday, row[cur++]);
-		str_to_number(pet.lEndTime, row[cur++]);
-		str_to_number(pet.lMaxTime, row[cur++]);
-
-		pet.dwOwner = dwPID;
-	}
-
-	return true;
-}
-
-void CClientManager::RESULT_GROWTH_PET_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID)
-{
-	static std::vector<TGrowthPet> s_petVec;
-	CreateGrowthPetTableFromRes(pRes, &s_petVec, dwPID);
-	DWORD dwCount = s_petVec.size();
-
-	peer->EncodeHeader(HEADER_DG_GROWTH_PET_LOAD, dwHandle, sizeof(DWORD) + sizeof(TGrowthPet) * dwCount);
-	peer->EncodeDWORD(dwCount);
-
-	CreateGrowthPetCacheSet(dwPID);
-
-	sys_log(0, "GROWTH_PET_LOAD: count %u pid %u", dwCount, dwPID);
-
-	if (dwCount)
-	{
-		peer->Encode(&s_petVec[0], sizeof(TGrowthPet) * dwCount);
-
-		for (DWORD i = 0; i < dwCount; ++i)
-			PutGrowthPetCache(&s_petVec[i], true);
-	}
-}
-#endif
+#include <string>
+#include "stdafx.h"
+
+#include <set>
+
+#include "../../common/building.h"
+#include "../../common/VnumHelper.h"
+#include "../../libgame/include/grid.h"
+
+#include "ClientManager.h"
+
+#include "Main.h"
+#include "Config.h"
+#include "DBManager.h"
+#include "QID.h"
+#include "GuildManager.h"
+#include "PrivManager.h"
+#include "MoneyLog.h"
+#include "ItemAwardManager.h"
+#include "Marriage.h"
+#include "Monarch.h"
+#include "BlockCountry.h"
+#include "ItemIDRangeManager.h"
+#include "Cache.h"
+
+#include <sstream>
+#if defined(__SHOP_SEARCH__)
+	#include "ShopSearchManager.h"
+#include <string.h>
+#endif
+
+extern int g_iPlayerCacheFlushSeconds;
+extern int g_iItemCacheFlushSeconds;
+extern int g_test_server;
+extern int g_log;
+extern std::string g_stLocale;
+extern std::string g_stLocaleNameColumn;
+bool CreateItemTableFromRes(MYSQL_RES* res, std::vector<TPlayerItem>* pVec, DWORD dwPID);
+
+DWORD g_dwUsageMax = 0;
+DWORD g_dwUsageAvg = 0;
+
+CPacketInfo g_query_info;
+CPacketInfo g_item_info;
+
+int g_item_count = 0;
+int g_query_count[2];
+
+CClientManager::CClientManager() :
+	m_pkAuthPeer(NULL),
+	m_iPlayerIDStart(0),
+	m_iPlayerDeleteLevelLimit(0),
+	m_iPlayerDeleteLevelLimitLower(0),
+	m_bChinaEventServer(false),
+	m_iShopTableSize(0),
+	m_pShopTable(NULL),
+	m_iRefineTableSize(0),
+	m_pRefineTable(NULL),
+	m_bShutdowned(false),
+	m_iCacheFlushCount(0),
+	m_iCacheFlushCountLimit(200)
+#if defined(__EXPRESSING_EMOTIONS__)
+	, m_iEmoteDumpDelay(3600)
+#endif
+#if defined(__MAILBOX__)
+	, m_iMailBoxBackupSec(3600)
+#endif
+#if defined(__GEM_SHOP__)
+	, m_iGemShopFlushDelay(3600)
+#endif
+{
+	m_itemRange.dwMin = 0;
+	m_itemRange.dwMax = 0;
+	m_itemRange.dwUsableItemIDMin = 0;
+
+	memset(g_query_count, 0, sizeof(g_query_count));
+}
+
+CClientManager::~CClientManager()
+{
+	Destroy();
+}
+
+void CClientManager::SetPlayerIDStart(int iIDStart)
+{
+	m_iPlayerIDStart = iIDStart;
+}
+
+void CClientManager::Destroy()
+{
+	m_mChannelStatus.clear();
+	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		(*i)->Destroy();
+
+	m_peerList.clear();
+
+	if (m_fdAccept > 0)
+	{
+		socket_close(m_fdAccept);
+		m_fdAccept = -1;
+	}
+}
+
+bool CClientManager::Initialize()
+{
+	int tmpValue;
+
+	// BOOT_LOCALIZATION
+	if (!InitializeLocalization())
+	{
+		fprintf(stderr, "Failed Localization Infomation so exit\n");
+		return false;
+	}
+	// END_BOOT_LOCALIZATION
+
+	// ITEM_UNIQUE_ID
+	if (!InitializeNowItemID())
+	{
+		fprintf(stderr, " Item range Initialize Failed. Exit DBCache Server\n");
+		return false;
+	}
+	// END_ITEM_UNIQUE_ID
+
+	m_bWolfmanCharacter = true;
+	int iWolfmanCharacter = 0;
+	if (CConfig::instance().GetValue("WOLFMAN_CHARACTER", &iWolfmanCharacter))
+		m_bWolfmanCharacter = (iWolfmanCharacter);
+	sys_log(0, "WOLFMAN_CHARACTER %s", m_bWolfmanCharacter ? "true" : "false");
+
+	m_bDelayedCharacterCreation = true;
+	int iDelayedCharacterCreation = 0;
+	if (CConfig::instance().GetValue("DELAYED_CHARACTER_CREATION", &iDelayedCharacterCreation))
+		m_bDelayedCharacterCreation = (iDelayedCharacterCreation);
+	sys_log(0, "DELAYED_CHARACTER_CREATION %s", m_bDelayedCharacterCreation ? "true" : "false");
+
+	if (!InitializeTables())
+	{
+		sys_err("Table Initialize FAILED");
+		return false;
+	}
+
+	CGuildManager::instance().BootReserveWar();
+
+	if (!CConfig::instance().GetValue("BIND_PORT", &tmpValue))
+		tmpValue = 5300;
+
+	char szBindIP[128];
+
+	if (!CConfig::instance().GetValue("BIND_IP", szBindIP, 128))
+		strlcpy(szBindIP, "0", sizeof(szBindIP));
+
+	m_fdAccept = socket_tcp_bind(szBindIP, tmpValue);
+
+	if (m_fdAccept < 0)
+	{
+		perror("socket");
+		return false;
+	}
+
+	sys_log(0, "ACCEPT_HANDLE: %u", m_fdAccept);
+	fdwatch_add_fd(m_fdWatcher, m_fdAccept, NULL, FDW_READ, false);
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	CConfig::instance().GetValue("EMOTE_DUMP_DELAY", &m_iEmoteDumpDelay);
+#endif
+
+#if defined(__MAILBOX__)
+	CConfig::instance().GetValue("MAILBOX_BACKUP_SEC", &m_iMailBoxBackupSec);
+#endif
+
+#if defined(__GEM_SHOP__)
+	CConfig::instance().GetValue("GEM_SHOP_FLUSH_DELAY", &m_iGemShopFlushDelay);
+#endif
+
+	if (!CConfig::instance().GetValue("BACKUP_LIMIT_SEC", &tmpValue))
+		tmpValue = 600;
+
+	m_looping = true;
+
+	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT", &m_iPlayerDeleteLevelLimit))
+	{
+		sys_err("config.txt: Cannot find PLAYER_DELETE_LEVEL_LIMIT, use default level %d", PLAYER_MAX_LEVEL_CONST + 1);
+		m_iPlayerDeleteLevelLimit = PLAYER_MAX_LEVEL_CONST + 1;
+	}
+
+	if (!CConfig::instance().GetValue("PLAYER_DELETE_LEVEL_LIMIT_LOWER", &m_iPlayerDeleteLevelLimitLower))
+	{
+		m_iPlayerDeleteLevelLimitLower = 0;
+	}
+
+	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT set to %d", m_iPlayerDeleteLevelLimit);
+	sys_log(0, "PLAYER_DELETE_LEVEL_LIMIT_LOWER set to %d", m_iPlayerDeleteLevelLimitLower);
+
+	m_bChinaEventServer = false;
+
+	int iChinaEventServer = 0;
+
+	if (CConfig::instance().GetValue("CHINA_EVENT_SERVER", &iChinaEventServer))
+		m_bChinaEventServer = (iChinaEventServer);
+
+	sys_log(0, "CHINA_EVENT_SERVER %s", CClientManager::instance().IsChinaEventServer() ? "true" : "false");
+
+	LoadEventFlag();
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	LoadGuildEventFlag();
+#endif
+
+	// database character-set  
+	if (g_stLocale == "big5" || g_stLocale == "sjis")
+		CDBManager::instance().QueryLocaleSet();
+
+	return true;
+}
+
+void CClientManager::MainLoop()
+{
+	SQLMsg* tmp;
+
+	sys_log(0, "ClientManager pointer is %p", this);
+
+	// 管
+	while (!m_bShutdowned)
+	{
+		while ((tmp = CDBManager::instance().PopResult()))
+		{
+			AnalyzeQueryResult(tmp);
+			delete tmp;
+		}
+
+		if (!Process())
+			break;
+
+		log_rotate();
+	}
+
+	//
+	// 管 처
+	//
+	sys_log(0, "MainLoop exited, Starting cache flushing");
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	CClientManager::instance().QUERY_EMOTE_DUMP();
+#endif
+
+#if defined(__MAILBOX__)
+	CClientManager::instance().MAILBOX_BACKUP();
+#endif
+
+#if defined(__GEM_SHOP__)
+	// Gem Shop Item Data List Flush
+	CClientManager::instance().FlushGemShop();
+#endif
+
+	signal_timer_disable();
+
+	// 첨潔 遣 캐 첨
+	auto it = m_map_playerCache.begin();
+	while (it != m_map_playerCache.end())
+	{
+		CPlayerTableCache* c = (it++)->second;
+
+		c->Flush();
+		delete c;
+	}
+	m_map_playerCache.clear();
+
+	//  첨
+	auto it2 = m_map_itemCache.begin();
+	while (it2 != m_map_itemCache.end())
+	{
+		CItemCache* c = (it2++)->second;
+
+		c->Flush();
+		delete c;
+	}
+	m_map_itemCache.clear();
+
+	// MYSHOP_PRICE_LIST
+	//
+	// 貫   트 Flush
+	//
+	for (auto itPriceList = m_mapItemPriceListCache.begin(); itPriceList != m_mapItemPriceListCache.end(); ++itPriceList)
+	{
+		CItemPriceListTableCache* pCache = itPriceList->second;
+		pCache->Flush();
+		delete pCache;
+	}
+
+	m_mapItemPriceListCache.clear();
+#ifdef __OFFLINE_SHOP__
+	FlushOfflineShops();
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	auto growthPetCache = m_map_growthPetCache.begin();
+
+	while (growthPetCache != m_map_growthPetCache.end())
+	{
+		CGrowthPetCache* c = (growthPetCache++)->second;
+
+		c->Flush();
+		delete c;
+	}
+	m_map_growthPetCache.clear();
+#endif
+
+	// END_OF_MYSHOP_PRICE_LIST
+}
+
+void CClientManager::Quit()
+{
+	m_bShutdowned = true;
+}
+
+void CClientManager::QUERY_BOOT(CPeer* peer, TPacketGDBoot* p)
+{
+	const BYTE bPacketVersion = 6; // BOOT 킷 侮除㎏ 호 첩 磯.
+
+	std::vector<tAdminInfo> vAdmin;
+	std::vector<std::string> vHost;
+
+	__GetHostInfo(vHost);
+	__GetAdminInfo(p->szIP, vAdmin);
+
+	sys_log(0, "QUERY_BOOT : AdminInfo (Request ServerIp %s) ", p->szIP);
+
+	DWORD dwPacketSize =
+		sizeof(DWORD) +
+		sizeof(BYTE) +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TShopTable) * m_iShopTableSize +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemAttrTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemAttrTable) * m_vec_itemRareTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(building::TLand) * m_vec_kLandTable.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObjectProto) * m_vec_kObjectProto.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(building::TObject) * m_map_pkObjectTable.size() +
+#ifdef __GROWTH_PET_SYSTEM__
+		sizeof(WORD) + sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size() +
+#endif
+		sizeof(time_t) +
+		sizeof(WORD) + sizeof(WORD) + sizeof(TItemIDRangeTable) * 2 +
+		// ADMIN_MANAGER
+		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size() +
+		sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
+		// END_ADMIN_MANAGER
+		sizeof(WORD) + sizeof(WORD) + sizeof(TMonarchInfo) +
+		sizeof(WORD) + sizeof(WORD) + sizeof(MonarchCandidacy) * CMonarch::instance().MonarchCandidacySize() +
+		sizeof(WORD);
+
+	peer->EncodeHeader(HEADER_DG_BOOT, 0, dwPacketSize);
+	peer->Encode(&dwPacketSize, sizeof(DWORD));
+	peer->Encode(&bPacketVersion, sizeof(BYTE));
+
+	sys_log(0, "BOOT: PACKET: %d", dwPacketSize);
+	sys_log(0, "BOOT: VERSION: %d", bPacketVersion);
+
+	sys_log(0, "sizeof(TMobTable) = %d", sizeof(TMobTable));
+	sys_log(0, "sizeof(TItemTable) = %d", sizeof(TItemTable));
+	sys_log(0, "sizeof(TShopTable) = %d", sizeof(TShopTable));
+	sys_log(0, "sizeof(TSkillTable) = %d", sizeof(TSkillTable));
+	sys_log(0, "sizeof(TRefineTable) = %d", sizeof(TRefineTable));
+	sys_log(0, "sizeof(TItemAttrTable) = %d", sizeof(TItemAttrTable));
+	sys_log(0, "sizeof(TItemRareTable) = %d", sizeof(TItemAttrTable));
+	sys_log(0, "sizeof(TBanwordTable) = %d", sizeof(TBanwordTable));
+	sys_log(0, "sizeof(TLand) = %d", sizeof(building::TLand));
+	sys_log(0, "sizeof(TObjectProto) = %d", sizeof(building::TObjectProto));
+	sys_log(0, "sizeof(TObject) = %d", sizeof(building::TObject));
+	// ADMIN_MANAGER
+	sys_log(0, "sizeof(tAdminInfo) = %d * %d ", sizeof(tAdminInfo) * vAdmin.size());
+	// END_ADMIN_MANAGER
+	sys_log(0, "sizeof(TMonarchInfo) = %d * %d", sizeof(TMonarchInfo));
+#ifdef __GROWTH_PET_SYSTEM__
+	sys_log(0, "sizeof(TGrowthPetSkillTable) = %d", sizeof(TGrowthPetSkillTable));
+#endif
+
+	peer->EncodeWORD(sizeof(TMobTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
+	peer->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
+
+	peer->EncodeWORD(sizeof(TItemTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
+	peer->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
+
+	peer->EncodeWORD(sizeof(TShopTable));
+	peer->EncodeWORD(m_iShopTableSize);
+	peer->Encode(m_pShopTable, sizeof(TShopTable) * m_iShopTableSize);
+
+	peer->EncodeWORD(sizeof(TSkillTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
+	peer->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
+
+	peer->EncodeWORD(sizeof(TRefineTable));
+	peer->EncodeWORD(m_iRefineTableSize);
+	peer->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
+
+	peer->EncodeWORD(sizeof(TItemAttrTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_itemAttrTable.size()));
+	peer->Encode(&m_vec_itemAttrTable[0], sizeof(TItemAttrTable) * m_vec_itemAttrTable.size());
+
+	peer->EncodeWORD(sizeof(TItemAttrTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_itemRareTable.size()));
+	peer->Encode(&m_vec_itemRareTable[0], sizeof(TItemAttrTable) * m_vec_itemRareTable.size());
+
+	peer->EncodeWORD(sizeof(TBanwordTable));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
+	peer->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
+
+	peer->EncodeWORD(sizeof(building::TLand));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_kLandTable.size()));
+	peer->Encode(&m_vec_kLandTable[0], sizeof(building::TLand) * m_vec_kLandTable.size());
+
+	peer->EncodeWORD(sizeof(building::TObjectProto));
+	peer->EncodeWORD(static_cast<WORD>(m_vec_kObjectProto.size()));
+	peer->Encode(&m_vec_kObjectProto[0], sizeof(building::TObjectProto) * m_vec_kObjectProto.size());
+
+	peer->EncodeWORD(sizeof(building::TObject));
+	peer->EncodeWORD(static_cast<WORD>(m_map_pkObjectTable.size()));
+
+	auto it = m_map_pkObjectTable.begin();
+	while (it != m_map_pkObjectTable.end())
+		peer->Encode((it++)->second, sizeof(building::TObject));
+
+#ifdef __GROWTH_PET_SYSTEM__
+	peer->EncodeWORD(sizeof(TGrowthPetSkillTable));
+	peer->EncodeWORD(m_vec_growthPetSkillTable.size());
+	if (m_vec_growthPetSkillTable.size())
+		peer->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
+#endif
+
+	time_t now = time(0);
+	peer->Encode(&now, sizeof(time_t));
+
+	TItemIDRangeTable itemRange = CItemIDRangeManager::instance().GetRange();
+	TItemIDRangeTable itemRangeSpare = CItemIDRangeManager::instance().GetRange();
+
+	peer->EncodeWORD(sizeof(TItemIDRangeTable));
+	peer->EncodeWORD(1);
+	peer->Encode(&itemRange, sizeof(TItemIDRangeTable));
+	peer->Encode(&itemRangeSpare, sizeof(TItemIDRangeTable));
+
+	peer->SetItemIDRange(itemRange);
+	peer->SetSpareItemIDRange(itemRangeSpare);
+
+	// ADMIN_MANAGER
+	peer->EncodeWORD(16);
+	peer->EncodeWORD(static_cast<WORD>(vHost.size()));
+
+	for (size_t n = 0; n < vHost.size(); ++n)
+	{
+		peer->Encode(vHost[n].c_str(), 16);
+		sys_log(0, "GMHosts %s", vHost[n].c_str());
+	}
+
+	peer->EncodeWORD(sizeof(tAdminInfo));
+	peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
+
+	for (size_t n = 0; n < vAdmin.size(); ++n)
+	{
+		peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
+		sys_log(0, "Admin name %s ConntactIP %s", vAdmin[n].m_szName, vAdmin[n].m_szContactIP);
+	}
+	// END_ADMIN_MANAGER
+
+	// MONARCH
+	peer->EncodeWORD(sizeof(TMonarchInfo));
+	peer->EncodeWORD(1);
+	peer->Encode(CMonarch::instance().GetMonarch(), sizeof(TMonarchInfo));
+
+	CMonarch::VEC_MONARCHCANDIDACY& rVecMonarchCandidacy = CMonarch::instance().GetVecMonarchCandidacy();
+
+	size_t num_monarch_candidacy = CMonarch::instance().MonarchCandidacySize();
+	peer->EncodeWORD(sizeof(MonarchCandidacy));
+	peer->EncodeWORD(static_cast<WORD>(num_monarch_candidacy));
+	if (num_monarch_candidacy != 0)
+	{
+		peer->Encode(&rVecMonarchCandidacy[0], sizeof(MonarchCandidacy) * num_monarch_candidacy);
+	}
+	// END_MONARCE
+
+	if (g_test_server)
+		sys_log(0, "MONARCHCandidacy Size %d", CMonarch::instance().MonarchCandidacySize());
+
+#ifdef __OFFLINE_SHOP__
+	peer->EncodeDWORD(sizeof(TOfflineShop));
+	peer->EncodeDWORD(offlineShopCache_.size());
+	for (const auto& entry : offlineShopCache_) {
+		peer->Encode(entry.second->Get(), sizeof(TOfflineShop));
+	}
+
+	peer->EncodeDWORD(sizeof(TOfflineShopItem));
+	peer->EncodeDWORD(offlineShopItemCache_.size());
+	for (const auto& entry : offlineShopItemCache_) {
+		peer->Encode(entry.second->Get(), sizeof(TOfflineShopItem));
+	}
+#endif
+
+	peer->EncodeWORD(0xffff);
+}
+
+void CClientManager::SendPartyOnSetup(CPeer* pkPeer)
+{
+	TPartyMap& pm = m_map_pkChannelParty[pkPeer->GetChannel()];
+	for (auto it_party = pm.begin(); it_party != pm.end(); ++it_party)
+	{
+		sys_log(0, "PARTY SendPartyOnSetup Party [%u]", it_party->first);
+		pkPeer->EncodeHeader(HEADER_DG_PARTY_CREATE, 0, sizeof(TPacketPartyCreate));
+		pkPeer->Encode(&it_party->first, sizeof(DWORD));
+
+		for (auto it_member = it_party->second.begin(); it_member != it_party->second.end(); ++it_member)
+		{
+			sys_log(0, "PARTY SendPartyOnSetup Party [%u] Member [%u]", it_party->first, it_member->first);
+			pkPeer->EncodeHeader(HEADER_DG_PARTY_ADD, 0, sizeof(TPacketPartyAdd));
+			pkPeer->Encode(&it_party->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->second.bRole, sizeof(BYTE));
+
+			pkPeer->EncodeHeader(HEADER_DG_PARTY_SET_MEMBER_LEVEL, 0, sizeof(TPacketPartySetMemberLevel));
+			pkPeer->Encode(&it_party->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->first, sizeof(DWORD));
+			pkPeer->Encode(&it_member->second.bLevel, sizeof(BYTE));
+		}
+	}
+}
+
+void CClientManager::QUERY_PLAYER_COUNT(CPeer* pkPeer, TPlayerCountPacket* pPacket)
+{
+	pkPeer->SetUserCount(pPacket->dwCount);
+}
+
+void CClientManager::QUERY_QUEST_SAVE(LPPEER pPeer, TQuestTable* pTable, DWORD dwLen)
+{
+	if (0 != (dwLen % sizeof(TQuestTable)))
+	{
+		sys_err("invalid packet size %d, sizeof(TQuestTable) == %d", dwLen, sizeof(TQuestTable));
+		return;
+	}
+
+	int iSize = dwLen / sizeof(TQuestTable);
+
+	char szQuery[1024];
+
+	for (int i = 0; i < iSize; ++i, ++pTable)
+	{
+		char escName[sizeof(pTable->szName) * 2 + 1];
+		char escState[sizeof(pTable->szState) * 2 + 1];
+
+		const size_t nameLen = strnlen(pTable->szName, sizeof(pTable->szName));
+		const size_t stateLen = strnlen(pTable->szState, sizeof(pTable->szState));
+
+		CDBManager::instance().EscapeString(escName, pTable->szName, static_cast<unsigned long>(nameLen));
+		CDBManager::instance().EscapeString(escState, pTable->szState, static_cast<unsigned long>(stateLen));
+
+		if (pTable->lValue == 0)
+		{
+			snprintf(szQuery, sizeof(szQuery), "DELETE FROM quest%s WHERE `dwPID` = %d AND `szName` = '%s' AND `szState` ='%s'",
+				GetTablePostfix(), pTable->dwPID, escName, escState);
+		}
+		else
+		{
+			snprintf(szQuery, sizeof(szQuery), "REPLACE INTO quest%s (`dwPID`, `szName`, `szState`, `lValue`) VALUES(%d, '%s', '%s', %ld)",
+				GetTablePostfix(), pTable->dwPID, escName, escState, pTable->lValue);
+		}
+
+		CDBManager::instance().ReturnQuery(szQuery, QID_QUEST_SAVE, pkPeer->GetHandle(), NULL);
+	}
+}
+
+void CClientManager::QUERY_SAFEBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TSafeboxLoadPacket* packet, bool bMall)
+{
+	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
+	strlcpy(pi->safebox_password, packet->szPassword, sizeof(pi->safebox_password));
+	pi->account_id = packet->dwID;
+	pi->account_index = 0;
+	pi->ip[0] = bMall ? 1 : 0;
+	strlcpy(pi->login, packet->szLogin, sizeof(pi->login));
+
+	char szQuery[QUERY_MAX_LEN];
+
+	// Hardening: Escape name/state to prevent SQL break / injection via quotes.
+	char escName[(CHARACTER_NAME_MAX_LEN + 1) * 2 + 1];
+	char escState[64 * 2 + 1];
+
+	DBManager::instance().EscapeString(escName, sizeof(escName), pTable->szName, strnlen(pTable->szName, sizeof(pTable->szName)));
+	DBManager::instance().EscapeString(escState, sizeof(escState), pTable->szState, strnlen(pTable->szState, sizeof(pTable->szState)));
+	snprintf(szQuery, sizeof(szQuery),
+		"SELECT `account_id`, `size`, `password` FROM safebox%s WHERE `account_id` = %u",
+		GetTablePostfix(), packet->dwID);
+
+	if (g_log)
+		sys_log(0, "HEADER_GD_SAFEBOX_LOAD (handle: %d account.id %u is_mall %d)", dwHandle, packet->dwID, bMall ? 1 : 0);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
+}
+
+void CClientManager::RESULT_SAFEBOX_LOAD(CPeer* pkPeer, SQLMsg* msg)
+{
+	sys_log(0, "RESULT_SAFEBOX_LOAD");
+
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = pi->dwHandle;
+
+	// 藪 求 account_index   磯.
+	// 첫째 戟 鱇틂  求  0
+	// 菅째  拷   1
+
+	if (pi->account_index == 0)
+	{
+		sys_log(0, "RESULT_SAFEBOX_LOAD account_index == 0");
+
+		char szSafeboxPassword[SAFEBOX_PASSWORD_MAX_LEN + 1];
+		strlcpy(szSafeboxPassword, pi->safebox_password, sizeof(szSafeboxPassword));
+
+		TSafeboxTable* pSafebox = new TSafeboxTable;
+		memset(pSafebox, 0, sizeof(TSafeboxTable));
+
+		SQLResult* res = msg->Get();
+
+		if (res->uiNumRows == 0)
+		{
+			if (strcmp("000000", szSafeboxPassword))
+			{
+				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
+				delete pSafebox;
+				delete pi;
+				return;
+			}
+		}
+		else
+		{
+			sys_log(0, "RESULT_SAFEBOX_LOAD get rows");
+
+			MYSQL_ROW row = mysql_fetch_row(res->pSQLResult);
+
+			// 橘호 틀..
+			if (((!row[2] || !*row[2]) && strcmp("000000", szSafeboxPassword)) ||
+				((row[2] && *row[2]) && strcmp(row[2], szSafeboxPassword)))
+			{
+				pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_WRONG_PASSWORD, dwHandle, 0);
+				delete pSafebox;
+				delete pi;
+				return;
+			}
+
+			if (!row[0])
+				pSafebox->dwID = 0;
+			else
+				str_to_number(pSafebox->dwID, row[0]);
+
+			if (!row[1])
+				pSafebox->bSize = 0;
+			else
+				str_to_number(pSafebox->bSize, row[1]);
+			/*
+			if (!row[3])
+				pSafebox->dwGold = 0;
+			else
+				pSafebox->dwGold = atoi(row[3]);
+			*/
+			if (pi->ip[0] == 1)
+			{
+#if defined(__EXTEND_MALLBOX__)
+				pSafebox->bSize = 5;
+#else
+				pSafebox->bSize = 1;
+#endif
+				sys_log(0, "MALL id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
+			}
+			else
+				sys_log(0, "SAFEBOX id[%d] size[%d]", pSafebox->dwID, pSafebox->bSize);
+		}
+
+		if (0 == pSafebox->dwID)
+			pSafebox->dwID = pi->account_id;
+
+		pi->pSafebox = pSafebox;
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
+#if defined(__SOUL_BIND_SYSTEM__)
+			", `soulbind`"
+#endif
+			", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+			", `socket3`, `socket4`, `socket5`"
+#endif
+			", `attrtype0`, `attrvalue0`"
+			", `attrtype1`, `attrvalue1`"
+			", `attrtype2`, `attrvalue2`"
+			", `attrtype3`, `attrvalue3`"
+			", `attrtype4`, `attrvalue4`"
+			", `attrtype5`, `attrvalue5`"
+			", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			", `transmutation`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			", `refine_element_apply_type`"
+			", `refine_element_grade`"
+			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			", `apply_type0`, `apply_value0`, `apply_path0`"
+			", `apply_type1`, `apply_value1`, `apply_path1`"
+			", `apply_type2`, `apply_value2`, `apply_path2`"
+			", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+			", `set_value`"
+#endif
+			" FROM `item%s` WHERE `owner_id` = %u AND `window` = '%s'",
+			GetTablePostfix(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL");
+
+		pi->account_index = 1;
+
+		CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_LOAD, pkPeer->GetHandle(), pi);
+	}
+	else
+	{
+		sys_log(0, "RESULT_SAFEBOX_LOAD YES!!!!!!!!!!!");
+
+		if (!pi->pSafebox)
+		{
+			sys_err("null safebox pointer!");
+			delete pi;
+			return;
+		}
+
+		//   羚퓐   창 獵  처
+		// 堅  창 틴 효째 
+		if (!msg->Get()->pSQLResult)
+		{
+			sys_err("null safebox result");
+			delete pi;
+			return;
+		}
+
+		static std::vector<TPlayerItem> s_items;
+		CreateItemTableFromRes(msg->Get()->pSQLResult, &s_items, pi->account_id);
+
+		ItemAwardSet* pSet = ItemAwardManager::instance().GetByLogin(pi->login);
+
+		// Anti-dupe hardening: prevent duplicate/concurrent processing of item_award for the same login.
+		struct _ItemAwardCheckoutGuard
+		{
+			static std::set<std::string>& Set()
+			{
+				static std::set<std::string> s_inflight;
+				return s_inflight;
+			}
+			std::string login;
+			bool active;
+			_ItemAwardCheckoutGuard(const char* szLogin) : login(szLogin ? szLogin : ""), active(false)
+			{
+				auto& s = Set();
+				if (!login.empty() && s.insert(login).second)
+					active = true;
+			}
+			~_ItemAwardCheckoutGuard()
+			{
+				if (!active) return;
+				auto& s = Set();
+				s.erase(login);
+			}
+			operator bool() const { return active; }
+		};
+		_ItemAwardCheckoutGuard _award_guard(pi->login);
+		if (pSet && !_award_guard)
+		{
+			sys_log(0, "ItemAward checkout skipped (already in progress): %s", pi->login);
+			pSet = NULL;
+		}
+
+
+		if (pSet && !m_vec_itemTable.empty())
+		{
+#if defined(__EXTEND_MALLBOX__)
+			CGrid grid(5, MAX(1, 5) * 9);
+#else
+			CGrid grid(5, MAX(1, pi->pSafebox->bSize) * 9);
+#endif
+			bool bEscape = false;
+
+			for (DWORD i = 0; i < s_items.size(); ++i)
+			{
+				TPlayerItem& r = s_items[i];
+
+				auto it = m_map_itemTableByVnum.find(r.dwVnum);
+				if (it == m_map_itemTableByVnum.end())
+				{
+					bEscape = true;
+					sys_err("invalid item vnum %u in safebox: login %s", r.dwVnum, pi->login);
+					break;
+				}
+
+				grid.Put(r.wPos, 1, it->second->bSize);
+			}
+
+			if (!bEscape)
+			{
+				std::vector<std::pair<DWORD, DWORD> > vec_dwFinishedAwardID;
+				ItemAwardSet::const_iterator it = pSet->begin();
+				char szQuery[512];
+
+				while (it != pSet->end())
+				{
+					TItemAward* pItemAward = *(it++);
+					const DWORD& dwItemVnum = pItemAward->dwVnum;
+
+					if (pItemAward->bTaken)
+						continue;
+
+					if (pi->ip[0] == 0 && pItemAward->bMall)
+						continue;
+
+					if (pi->ip[0] == 1 && !pItemAward->bMall)
+						continue;
+
+					auto it = m_map_itemTableByVnum.find(pItemAward->dwVnum);
+					if (it == m_map_itemTableByVnum.end())
+					{
+						sys_err("invalid item vnum %u in item_award: login %s", pItemAward->dwVnum, pi->login);
+						continue;
+					}
+
+					TItemTable* pItemTable = it->second;
+
+					int iPos;
+
+					if ((iPos = grid.FindBlank(1, it->second->bSize)) == -1)
+						break;
+
+					TPlayerItem item;
+					memset(&item, 0, sizeof(TPlayerItem));
+
+#if defined(__EXTENDED_ITEM_AWARD__)
+					DWORD dwSocket0 = pItemAward->dwSocket0;
+					DWORD dwSocket2 = pItemAward->dwSocket2;
+					DWORD dwSocket4 = pItemAward->dwSocket4;
+					DWORD dwSocket5 = pItemAward->dwSocket5;
+#else
+					DWORD dwSocket2 = 0;
+#endif
+
+					if (pItemTable->bType == ITEM_UNIQUE)
+					{
+#if defined(__EXTENDED_ITEM_AWARD__)
+						// 12.04.2019 - Correction for unique items based on the real time.
+						const long lValue0 = pItemTable->alValues[ITEM_SOCKET_REMAIN_SEC];
+						const long lValue2 = pItemTable->alValues[ITEM_SOCKET_UNIQUE_REMAIN_TIME];
+						const time_t tNow = CClientManager::instance().GetCurrentTime();
+						dwSocket2 = (lValue2 == 0) ? static_cast<DWORD>(lValue0) : static_cast<DWORD>(tNow + lValue0);
+#else
+						if (pItemAward->dwSocket2 != 0)
+							dwSocket2 = pItemAward->dwSocket2;
+						else
+							dwSocket2 = pItemTable->alValues[0];
+#endif
+					}
+					else if ((dwItemVnum == ITEM_SKILLBOOK_VNUM || dwItemVnum == ITEM_SKILLFORGET_VNUM) && pItemAward->dwSocket0 == 0)
+					{
+						DWORD dwSkillIdx;
+						DWORD dwSkillVnum;
+
+						do
+						{
+							dwSkillIdx = number(0, m_vec_skillTable.size() - 1);
+
+							dwSkillVnum = m_vec_skillTable[dwSkillIdx].dwVnum;
+
+							if (dwSkillVnum > 120)
+								continue;
+
+							break;
+						} while (1);
+
+#if !defined(__EXTENDED_ITEM_AWARD__)
+						pItemAward->dwSocket0 = dwSkillVnum;
+#endif
+					}
+					else
+					{
+						switch (dwItemVnum)
+						{
+							case 72723: case 72724: case 72725: case 72726:
+							case 72727: case 72728: case 72729: case 72730:
+								// 첫  求  치 ...
+								// 瀏 柳 溝 湄.  悶 湄 滂.
+							case 76004: case 76005: case 76021: case 76022:
+							case 79012: case 79013:
+								if (pItemAward->dwSocket2 == 0)
+								{
+									dwSocket2 = pItemTable->alValues[0];
+								}
+								else
+								{
+									dwSocket2 = pItemAward->dwSocket2;
+								}
+								break;
+						}
+					}
+
+					if (GetItemID() > m_itemRange.dwMax)
+					{
+						sys_err("UNIQUE ID OVERFLOW!!");
+						break;
+					}
+
+					{
+						auto it = m_map_itemTableByVnum.find(dwItemVnum);
+						if (it == m_map_itemTableByVnum.end())
+						{
+							sys_err("Invalid item(vnum : %d). It is not in m_map_itemTableByVnum.", dwItemVnum);
+							continue;
+						}
+						TItemTable* item_table = it->second;
+						if (item_table == NULL)
+						{
+							sys_err("Invalid item_table (vnum : %d). It's value is NULL in m_map_itemTableByVnum.", dwItemVnum);
+							continue;
+						}
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+						if ((item_table->bType == ITEM_UNIQUE && item_table->bType == COSTUME_MOUNT))
+						{
+							if (pItemAward->dwSocket4 == 0)
+								dwSocket4 = pItemTable->alValues[0];
+							else
+								dwSocket4 = pItemAward->dwSocket4;
+						}
+#endif
+
+						if (0 == pItemAward->dwSocket0)
+						{
+							// Load default values
+							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+							{
+								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
+									break;
+								}
+								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
+									break;
+								}
+							}
+						}
+						else
+						{
+#if defined(__EXTENDED_ITEM_AWARD__)
+							// Load set values
+							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+							{
+								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
+								{
+									dwSocket0 = time(0) + pItemAward->dwSocket0;
+									break;
+								}
+								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
+								{
+									dwSocket0 = pItemAward->dwSocket0;
+									break;
+								}
+							}
+#else
+							for (int i = 0; i < ITEM_LIMIT_MAX_NUM; i++)
+							{
+								if (LIMIT_REAL_TIME == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = time(0) + 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = time(0) + item_table->aLimits[i].lValue;
+
+									break;
+								}
+								else if (LIMIT_REAL_TIME_START_FIRST_USE == item_table->aLimits[i].bType || LIMIT_TIMER_BASED_ON_WEAR == item_table->aLimits[i].bType)
+								{
+									if (0 == item_table->aLimits[i].lValue)
+										pItemAward->dwSocket0 = 60 * 60 * 24 * 7;
+									else
+										pItemAward->dwSocket0 = item_table->aLimits[i].lValue;
+
+									break;
+								}
+							}
+#endif
+						}
+
+#if defined(__EXTENDED_ITEM_AWARD__)
+						ItemAwardManager::instance().CheckItemCount(*pItemAward, *pItemTable);
+						ItemAwardManager::instance().CheckItemBlend(*pItemAward, *pItemTable);
+						ItemAwardManager::instance().CheckItemAddonType(*pItemAward, *pItemTable);
+						ItemAwardManager::instance().CheckItemSkillBook(*pItemAward, m_vec_skillTable);
+						ItemAwardManager::instance().CheckItemAttributes(*pItemAward, *pItemTable, m_vec_itemAttrTable);
+
+						// START_OF_AUTO_QUERY
+						char szColumns[QUERY_MAX_LEN], szValues[QUERY_MAX_LEN];
+
+						int iLen = snprintf(szColumns, sizeof(szColumns), "`id`, `owner_id`, `window`, `pos`, `vnum`, `count`");
+						int iValueLen = snprintf(szValues, sizeof(szValues), "%u, %u, '%s', %d, %u, %u", GainItemID(), pi->account_id, (pi->ip[0] == 0) ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount);
+
+#if defined(__ITEM_SOCKET6__)
+						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`, `socket3`, `socket4`, `socket5`");
+						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u, %u, %u, %u", dwSocket0, pItemAward->dwSocket1, dwSocket2, pItemAward->dwSocket3, pItemAward->dwSocket4, pItemAward->dwSocket5);
+#else
+						iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `socket0`, `socket1`, `socket2`");
+						iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %u, %u", pItemAward->dwSocket0, pItemAward->dwSocket1, dwSocket2);
+#endif
+
+						for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
+						{
+							iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `attrtype%d`, `attrvalue%d`", i, i);
+							iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %u, %ld", pItemAward->aAttr[i].wType, pItemAward->aAttr[i].lValue);
+						}
+						// END_OF_AUTO_QUERY
+
+						snprintf(szQuery, sizeof(szQuery), "INSERT INTO item%s (%s) VALUES(%s)", GetTablePostfix(), szColumns, szValues);
+#else
+						snprintf(szQuery, sizeof(szQuery),
+							"INSERT INTO item%s (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
+							", `socket0`"
+							", `socket1`"
+							", `socket2`"
+#if defined(__ITEM_SOCKET6__)
+							", `socket3`"
+							", `socket4`"
+							", `socket5`"
+#endif
+							") VALUES (%u, %u, '%s', %d, %u, %u"
+							", %u"
+							", %u"
+							", %u"
+#if defined(__ITEM_SOCKET6__)
+							", %u"
+							", %u"
+							", %u"
+#endif
+							")",
+							GetTablePostfix(), GainItemID(), pi->account_id, pi->ip[0] == 0 ? "SAFEBOX" : "MALL", iPos, pItemAward->dwVnum, pItemAward->dwCount
+							, pItemAward->dwSocket0
+							, pItemAward->dwSocket1
+							, dwSocket2
+#if defined(__ITEM_SOCKET6__)
+							, pItemAward->dwSocket3
+							, pItemAward->dwSocket4
+							, pItemAward->dwSocket5
+#endif
+						);
+#endif
+					}
+
+					std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+					SQLResult* pRes = pmsg->Get();
+					sys_log(0, "SAFEBOX Query : [%s]", szQuery);
+
+					if (pRes->uiAffectedRows == 0 || pRes->uiInsertID == 0 || pRes->uiAffectedRows == (uint32_t)-1)
+						break;
+
+					item.dwID = pmsg->Get()->uiInsertID;
+					if (pi->ip[0] == 0)
+						item.bWindow = SAFEBOX, item.wPos = iPos;
+					else
+						item.bWindow = MALL, item.wPos = iPos;
+					item.dwVnum = pItemAward->dwVnum;
+					item.dwCount = pItemAward->dwCount;
+#if defined(__EXTENDED_ITEM_AWARD__)
+					item.alSockets[0] = dwSocket0;
+#else
+					item.alSockets[0] = pItemAward->dwSocket0;
+#endif
+					item.alSockets[1] = pItemAward->dwSocket1;
+					item.alSockets[2] = dwSocket2;
+#if defined(__ITEM_SOCKET6__)
+					item.alSockets[3] = pItemAward->dwSocket3;
+					item.alSockets[4] = dwSocket4;
+					item.alSockets[5] = dwSocket5;
+#endif
+#if defined(__EXTENDED_ITEM_AWARD__)
+					thecore_memcpy(&item.aAttr, pItemAward->aAttr, sizeof(item.aAttr));
+#endif
+					s_items.push_back(item);
+
+					vec_dwFinishedAwardID.push_back(std::make_pair(pItemAward->dwID, item.dwID));
+					grid.Put(iPos, 1, it->second->bSize);
+				}
+
+				for (DWORD i = 0; i < vec_dwFinishedAwardID.size(); ++i)
+					ItemAwardManager::instance().Taken(vec_dwFinishedAwardID[i].first, vec_dwFinishedAwardID[i].second);
+			}
+		}
+
+		pi->pSafebox->wItemCount = static_cast<WORD>(s_items.size());
+
+#ifdef __GROWTH_PET_SYSTEM__
+		static std::vector<TGrowthPet> s_petVec;
+
+		// Loads pets only when opening safebox with items
+		if (pi->ip[0] == 0 && !s_items.empty())
+		{
+			char szQuery[QUERY_MAX_LEN];
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT id,vnum,state+0,name,size,level,level_step,evolution,type,hp,sp,def,hp_apply,sp_apply,def_apply,"
+				"age_apply,skill_level,exp,item_exp,UNIX_TIMESTAMP(birthday),end_time,max_time "
+				"FROM growth_pet%s WHERE owner_id=%d AND state=%d",
+				GetTablePostfix(), pi->account_id, STATE_SAFEBOX);
+
+			std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(szQuery));
+			MYSQL_RES* pRes = pkMsg->Get()->pSQLResult;
+			CreateGrowthPetTableFromRes(pRes, &s_petVec, pi->account_id);
+		}
+#endif
+
+		if (pi->ip[0] == 0)
+			pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
+#ifdef __GROWTH_PET_SYSTEM__
+			+ sizeof(WORD) + sizeof(TGrowthPet) * s_petVec.size()
+#endif
+		);
+		else
+			pkPeer->EncodeHeader(HEADER_DG_MALL_LOAD, dwHandle, sizeof(TSafeboxTable) + sizeof(TPlayerItem) * s_items.size()
+
+		);
+
+		pkPeer->Encode(pi->pSafebox, sizeof(TSafeboxTable));
+
+		if (!s_items.empty())
+			pkPeer->Encode(&s_items[0], sizeof(TPlayerItem) * s_items.size());
+
+#ifdef __GROWTH_PET_SYSTEM__
+		pkPeer->EncodeWORD((WORD)s_petVec.size());
+
+		if (!s_petVec.empty())
+			pkPeer->Encode(&s_petVec[0], sizeof(TGrowthPet) * s_petVec.size());
+#endif
+
+		delete pi;
+	}
+}
+
+void CClientManager::QUERY_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangeSizePacket* p)
+{
+	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
+	pi->account_index = p->bSize; // account_index  擔첨 
+
+	char szQuery[QUERY_MAX_LEN];
+
+	if (p->bSize == 1)
+		snprintf(szQuery, sizeof(szQuery), "INSERT INTO safebox%s (`account_id`, `size`) VALUES(%u, %u)", GetTablePostfix(), p->dwID, p->bSize);
+	else
+		snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `size` = %u WHERE `account_id` = %u", GetTablePostfix(), p->bSize, p->dwID);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_SIZE, pkPeer->GetHandle(), pi);
+}
+
+void CClientManager::RESULT_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = p->dwHandle;
+	BYTE bSize = p->account_index;
+
+	delete p;
+
+	if (msg->Get()->uiNumRows > 0)
+	{
+		pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_SIZE, dwHandle, sizeof(BYTE));
+		pkPeer->EncodeBYTE(bSize);
+	}
+}
+
+void CClientManager::QUERY_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangePasswordPacket* p)
+{
+	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle);
+	strlcpy(pi->safebox_password, p->szNewPassword, sizeof(pi->safebox_password));
+	strlcpy(pi->login, p->szOldPassword, sizeof(pi->login));
+	pi->account_id = p->dwID;
+
+	char szQuery[QUERY_MAX_LEN];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `password` FROM safebox%s WHERE `account_id` = %u", GetTablePostfix(), p->dwID);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD, pkPeer->GetHandle(), pi);
+}
+
+void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = p->dwHandle;
+
+	if (msg->Get()->uiNumRows > 0)
+	{
+		MYSQL_ROW row = mysql_fetch_row(msg->Get()->pSQLResult);
+
+		if ((row[0] && *row[0] && !strcasecmp(row[0], p->login)) || ((!row[0] || !*row[0]) && !strcmp("000000", p->login)))
+		{
+			char szQuery[QUERY_MAX_LEN];
+			char escape_pwd[64];
+			CDBManager::instance().EscapeString(escape_pwd, p->safebox_password, strlen(p->safebox_password));
+
+			snprintf(szQuery, sizeof(szQuery), "UPDATE safebox%s SET `password` = '%s' WHERE `account_id` = %u", GetTablePostfix(), escape_pwd, p->account_id);
+
+			CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_CHANGE_PASSWORD_SECOND, pkPeer->GetHandle(), p);
+			return;
+		}
+	}
+
+	delete p;
+
+	// Wrong old password
+	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
+	pkPeer->EncodeBYTE(0);
+}
+
+void CClientManager::RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(CPeer* pkPeer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* p = (ClientHandleInfo*)qi->pvData;
+	DWORD dwHandle = p->dwHandle;
+	delete p;
+
+	pkPeer->EncodeHeader(HEADER_DG_SAFEBOX_CHANGE_PASSWORD_ANSWER, dwHandle, sizeof(BYTE));
+	pkPeer->EncodeBYTE(1);
+}
+
+// MYSHOP_PRICE_LIST
+void CClientManager::RESULT_PRICELIST_LOAD(CPeer* peer, SQLMsg* pMsg)
+{
+	TItemPricelistReqInfo* pReqInfo = (TItemPricelistReqInfo*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
+
+	//
+	// DB  琯  Cache  
+	//
+
+	TItemPriceListTable table;
+	table.dwOwnerID = pReqInfo->second;
+	table.byCount = 0;
+
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
+		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
+#if defined(__CHEQUE_SYSTEM__)
+		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
+#endif
+		table.byCount++;
+	}
+
+	PutItemPriceListCache(&table);
+
+	//
+	// 琯 拷 Game server  
+	//
+
+	TPacketMyshopPricelistHeader header;
+
+	header.dwOwnerID = pReqInfo->second;
+	header.byCount = table.byCount;
+
+	size_t sizePriceListSize = sizeof(TItemPriceInfo) * header.byCount;
+
+	peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, pReqInfo->first, sizeof(header) + sizePriceListSize);
+	peer->Encode(&header, sizeof(header));
+	peer->Encode(table.aPriceInfo, sizePriceListSize);
+
+	sys_log(0, "Load MyShopPricelist handle[%d] pid[%d] count[%d]", pReqInfo->first, pReqInfo->second, header.byCount);
+
+	delete pReqInfo;
+}
+
+void CClientManager::RESULT_PRICELIST_LOAD_FOR_UPDATE(SQLMsg* pMsg)
+{
+	TItemPriceListTable* pUpdateTable = (TItemPriceListTable*)static_cast<CQueryInfo*>(pMsg->pvUserData)->pvData;
+
+	//
+	// DB  琯  Cache  
+	//
+
+	TItemPriceListTable table{};
+	table.dwOwnerID = pUpdateTable->dwOwnerID;
+	table.byCount = 0;
+
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		str_to_number(table.aPriceInfo[table.byCount].dwVnum, row[0]);
+		str_to_number(table.aPriceInfo[table.byCount].dwPrice, row[1]);
+#if defined(__CHEQUE_SYSTEM__)
+		str_to_number(table.aPriceInfo[table.byCount].dwCheque, row[2]);
+#endif
+		table.byCount++;
+	}
+
+	PutItemPriceListCache(&table);
+
+	// Update cache
+	GetItemPriceListCache(pUpdateTable->dwOwnerID)->UpdateList(pUpdateTable);
+
+	delete pUpdateTable;
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+void CClientManager::QUERY_SAFEBOX_SAVE(CPeer* pkPeer, TSafeboxTable* pTable)
+{
+	char szQuery[QUERY_MAX_LEN];
+
+	snprintf(szQuery, sizeof(szQuery),
+		"UPDATE safebox%s SET `gold` = '%u' WHERE `account_id` = %u",
+		GetTablePostfix(), pTable->dwGold, pTable->dwID);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_SAFEBOX_SAVE, pkPeer->GetHandle(), NULL);
+}
+
+void CClientManager::QUERY_EMPIRE_SELECT(CPeer* pkPeer, DWORD dwHandle, TEmpireSelectPacket* p)
+{
+	char szQuery[QUERY_MAX_LEN];
+
+	snprintf(szQuery, sizeof(szQuery), "UPDATE player_index%s SET `empire` = %u WHERE `id` = %u", GetTablePostfix(), p->bEmpire, p->dwAccountID);
+	delete CDBManager::instance().DirectQuery(szQuery);
+
+	sys_log(0, "EmpireSelect: %s", szQuery);
+	{
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `pid1`"
+			", `pid2`"
+			", `pid3`"
+			", `pid4`"
+#if defined(__PLAYER_PER_ACCOUNT5__)
+			", `pid5`"
+#endif
+			" FROM player_index%s WHERE `id` = %u", GetTablePostfix(), p->dwAccountID);
+
+		std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+		SQLResult* pRes = pmsg->Get();
+
+		if (pRes->uiNumRows)
+		{
+			sys_log(0, "EMPIRE %lu", pRes->uiNumRows);
+
+			MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
+			DWORD pids[3];
+
+			UINT g_start_map[4] =
+			{
+				0, // reserved
+				1, // 탉
+				21, // 천
+				41 // 諭
+			};
+
+			// FIXME share with game
+			DWORD g_start_position[4][2] =
+			{
+				{ 0, 0 },
+				{ 469300, 964200 }, // 탉
+				{ 55700, 157900 }, // 천
+				{ 969600, 278400 } // 諭
+			};
+
+			for (int i = 0; i < 3; ++i)
+			{
+				str_to_number(pids[i], row[i]);
+				sys_log(0, "EMPIRE PIDS[%d]", pids[i]);
+
+				if (pids[i])
+				{
+					sys_log(0, "EMPIRE move to pid[%d] to villiage of %u, map_index %d",
+						pids[i], p->bEmpire, g_start_map[p->bEmpire]);
+
+					snprintf(szQuery, sizeof(szQuery), "UPDATE player%s SET `map_index` = %u, `x` = %u, `y` = %u WHERE `id` = %u",
+						GetTablePostfix(),
+						g_start_map[p->bEmpire],
+						g_start_position[p->bEmpire][0],
+						g_start_position[p->bEmpire][1],
+						pids[i]);
+
+					std::unique_ptr<SQLMsg> pmsg2(CDBManager::instance().DirectQuery(szQuery));
+				}
+			}
+		}
+	}
+
+	pkPeer->EncodeHeader(HEADER_DG_EMPIRE_SELECT, dwHandle, sizeof(BYTE));
+	pkPeer->EncodeBYTE(p->bEmpire);
+}
+
+void CClientManager::QUERY_SETUP(CPeer* peer, DWORD dwHandle, const char* c_pData)
+{
+	TPacketGDSetup* p = (TPacketGDSetup*)c_pData;
+	c_pData += sizeof(TPacketGDSetup);
+
+	if (p->bAuthServer)
+	{
+		sys_log(0, "AUTH_PEER ptr %p", peer);
+
+		m_pkAuthPeer = peer;
+		return;
+	}
+
+	peer->SetPublicIP(p->szPublicIP);
+	peer->SetChannel(p->bChannel);
+	peer->SetListenPort(p->wListenPort);
+	peer->SetP2PPort(p->wP2PPort);
+	peer->SetMaps(p->alMaps);
+
+	//
+	// 錚  錚  獵 
+	//
+	TMapLocation kMapLocations;
+
+	strlcpy(kMapLocations.szHost, peer->GetPublicIP(), sizeof(kMapLocations.szHost));
+	kMapLocations.wPort = peer->GetListenPort();
+	thecore_memcpy(kMapLocations.alMaps, peer->GetMaps(), sizeof(kMapLocations.alMaps));
+
+	BYTE bMapCount;
+
+	std::vector<TMapLocation> vec_kMapLocations;
+
+	if (peer->GetChannel() == 1)
+	{
+		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		{
+			CPeer* tmp = *i;
+
+			if (tmp == peer)
+				continue;
+
+			if (!tmp->GetChannel())
+				continue;
+
+			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
+			{
+				TMapLocation kMapLocation2;
+				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
+				kMapLocation2.wPort = tmp->GetListenPort();
+				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
+				vec_kMapLocations.push_back(kMapLocation2);
+
+				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
+				bMapCount = 1;
+				tmp->EncodeBYTE(bMapCount);
+				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
+			}
+		}
+	}
+	else if (peer->GetChannel() == GUILD_WARP_WAR_CHANNEL)
+	{
+		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		{
+			CPeer* tmp = *i;
+
+			if (tmp == peer)
+				continue;
+
+			if (!tmp->GetChannel())
+				continue;
+
+			if (tmp->GetChannel() == 1 || tmp->GetChannel() == peer->GetChannel())
+			{
+				TMapLocation kMapLocation2;
+				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
+				kMapLocation2.wPort = tmp->GetListenPort();
+				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
+				vec_kMapLocations.push_back(kMapLocation2);
+			}
+
+			tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
+			bMapCount = 1;
+			tmp->EncodeBYTE(bMapCount);
+			tmp->Encode(&kMapLocations, sizeof(TMapLocation));
+		}
+	}
+	else
+	{
+		// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+		{
+			CPeer* tmp = *i;
+
+			if (tmp == peer)
+				continue;
+
+			if (!tmp->GetChannel())
+				continue;
+
+			if (tmp->GetChannel() == GUILD_WARP_WAR_CHANNEL || tmp->GetChannel() == peer->GetChannel())
+			{
+				TMapLocation kMapLocation2;
+
+				strlcpy(kMapLocation2.szHost, tmp->GetPublicIP(), sizeof(kMapLocation2.szHost));
+				kMapLocation2.wPort = tmp->GetListenPort();
+				thecore_memcpy(kMapLocation2.alMaps, tmp->GetMaps(), sizeof(kMapLocation2.alMaps));
+
+				vec_kMapLocations.push_back(kMapLocation2);
+			}
+
+			if (tmp->GetChannel() == peer->GetChannel())
+			{
+				tmp->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation));
+				bMapCount = 1;
+				tmp->EncodeBYTE(bMapCount);
+				tmp->Encode(&kMapLocations, sizeof(TMapLocation));
+			}
+		}
+	}
+
+	vec_kMapLocations.push_back(kMapLocations);
+
+	peer->EncodeHeader(HEADER_DG_MAP_LOCATIONS, 0, sizeof(BYTE) + sizeof(TMapLocation) * vec_kMapLocations.size());
+	bMapCount = static_cast<BYTE>(vec_kMapLocations.size());
+	peer->EncodeBYTE(bMapCount);
+	peer->Encode(&vec_kMapLocations[0], sizeof(TMapLocation) * vec_kMapLocations.size());
+
+	//
+	// 쩐 :  퓸楮 摸 퓸 構 . (P2P 漫 )
+	//
+	sys_log(0, "SETUP: channel %u listen %u p2p %u count %u", peer->GetChannel(), p->wListenPort, p->wP2PPort, bMapCount);
+
+	TPacketDGP2P p2pSetupPacket;
+	p2pSetupPacket.wPort = peer->GetP2PPort();
+	p2pSetupPacket.bChannel = peer->GetChannel();
+	strlcpy(p2pSetupPacket.szHost, peer->GetPublicIP(), sizeof(p2pSetupPacket.szHost));
+
+	//for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* tmp = *i;
+
+		if (tmp == peer)
+			continue;
+
+		// 채 0繭  SETUP 킷   퓸 풔 auth   
+		if (0 == tmp->GetChannel())
+			continue;
+
+		tmp->EncodeHeader(HEADER_DG_P2P, 0, sizeof(TPacketDGP2P));
+		tmp->Encode(&p2pSetupPacket, sizeof(TPacketDGP2P));
+	}
+
+	//
+	// 慣   
+	//
+	TPacketLoginOnSetup* pck = (TPacketLoginOnSetup*)c_pData;
+
+	for (DWORD c = 0; c < p->dwLoginCount; ++c, ++pck)
+	{
+		CLoginData* pkLD = new CLoginData;
+
+		pkLD->SetKey(pck->dwLoginKey);
+		pkLD->SetClientKey(pck->adwClientKey);
+		pkLD->SetIP(pck->szHost);
+
+		TAccountTable& r = pkLD->GetAccountRef();
+
+		r.id = pck->dwID;
+		trim_and_lower(pck->szLogin, r.login, sizeof(r.login));
+		strlcpy(r.social_id, pck->szSocialID, sizeof(r.social_id));
+		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		strlcpy(r.country, pck->szCountry, sizeof(r.country));
+#endif
+
+		InsertLoginData(pkLD);
+
+		if (InsertLogonAccount(pck->szLogin, peer->GetHandle(), pck->szHost))
+		{
+			sys_log(0, "SETUP: login %u %s login_key %u host %s", pck->dwID, pck->szLogin, pck->dwLoginKey, pck->szHost);
+			pkLD->SetPlay(true);
+		}
+		else
+			sys_log(0, "SETUP: login_fail %u %s login_key %u", pck->dwID, pck->szLogin, pck->dwLoginKey);
+	}
+
+	SendPartyOnSetup(peer);
+
+	CGuildManager::instance().OnSetup(peer);
+	CPrivManager::instance().SendPrivOnSetup(peer);
+
+	SendEventFlagsOnSetup(peer);
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	SendGuildEventFlagsOnSetup(peer);
+#endif
+
+	marriage::CManager::instance().OnSetup(peer);
+}
+
+void CClientManager::QUERY_ITEM_FLUSH(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwID = *(DWORD*)c_pData;
+
+	if (g_log)
+		sys_log(0, "HEADER_GD_ITEM_FLUSH: %u", dwID);
+
+	CItemCache* c = GetItemCache(dwID);
+
+	if (c)
+		c->Flush();
+}
+
+void CClientManager::QUERY_ITEM_SAVE(CPeer* pkPeer, const char* c_pData)
+{
+	TPlayerItem* p = (TPlayerItem*)c_pData;
+
+	// 창 캐 歌, 캐 獵 孤  磯.
+
+	if (p->bWindow == SAFEBOX || p->bWindow == MALL
+	)
+	{
+		CItemCache* c = GetItemCache(p->dwID);
+
+		if (c)
+		{
+			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
+
+			if (it != m_map_pkItemCacheSetPtr.end())
+			{
+				if (g_test_server)
+					sys_log(0, "ITEM_CACHE: safebox owner %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+
+				it->second->erase(c);
+			}
+
+			m_map_itemCache.erase(p->dwID);
+
+			delete c;
+		}
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"REPLACE INTO `item%s` (`id`, `owner_id`, `window`, `pos`, `vnum`, `count`"
+#if defined(__SOUL_BIND_SYSTEM__)
+			", `soulbind`"
+#endif
+			", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+			", `socket3`, `socket4`, `socket5`"
+#endif
+			", `attrtype0`, `attrvalue0`"
+			", `attrtype1`, `attrvalue1`"
+			", `attrtype2`, `attrvalue2`"
+			", `attrtype3`, `attrvalue3`"
+			", `attrtype4`, `attrvalue4`"
+			", `attrtype5`, `attrvalue5`"
+			", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			", `transmutation`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			", `refine_element_apply_type`"
+			", `refine_element_grade`"
+			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			", `apply_type0`, `apply_value0`, `apply_path0`"
+			", `apply_type1`, `apply_value1`, `apply_path1`"
+			", `apply_type2`, `apply_value2`, `apply_path2`"
+			", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+			", `set_value`"
+#endif
+			") VALUES(%u, %u, %u, %u, %u, %u"
+#if defined(__SOUL_BIND_SYSTEM__)
+			", %ld"
+#endif
+			", %ld, %ld, %ld"
+#if defined(__ITEM_SOCKET6__)
+			", %ld, %ld, %ld"
+#endif
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+			", %u, %ld"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			", %u"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			", %u"
+			", %u"
+			", %u, %u, %u"
+			", %u, %u, %u"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			", %u, %ld, %u"
+			", %u, %ld, %u"
+			", %u, %ld, %u"
+			", %u, %ld, %u"
+#endif
+#if defined(__SET_ITEM__)
+			", %u"
+#endif
+			")", GetTablePostfix()
+			, p->dwID
+			, p->dwOwner
+			, p->bWindow
+			, p->wPos
+			, p->dwVnum
+			, p->dwCount
+#if defined(__SOUL_BIND_SYSTEM__)
+			, p->lSealDate
+#endif
+			, p->alSockets[0], p->alSockets[1], p->alSockets[2]
+#if defined(__ITEM_SOCKET6__)
+			, p->alSockets[3], p->alSockets[4], p->alSockets[5]
+#endif
+			, p->aAttr[0].wType, p->aAttr[0].lValue
+			, p->aAttr[1].wType, p->aAttr[1].lValue
+			, p->aAttr[2].wType, p->aAttr[2].lValue
+			, p->aAttr[3].wType, p->aAttr[3].lValue
+			, p->aAttr[4].wType, p->aAttr[4].lValue
+			, p->aAttr[5].wType, p->aAttr[5].lValue
+			, p->aAttr[6].wType, p->aAttr[6].lValue
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			, p->dwTransmutationVnum
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			, p->RefineElement.wApplyType
+			, p->RefineElement.bGrade
+			, p->RefineElement.abValue[0], p->RefineElement.abValue[1], p->RefineElement.abValue[2]
+			, p->RefineElement.abBonusValue[0], p->RefineElement.abBonusValue[1], p->RefineElement.abBonusValue[2]
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			, p->aApplyRandom[0].wType, p->aApplyRandom[0].lValue, p->aApplyRandom[0].bPath
+			, p->aApplyRandom[1].wType, p->aApplyRandom[1].lValue, p->aApplyRandom[1].bPath
+			, p->aApplyRandom[2].wType, p->aApplyRandom[2].lValue, p->aApplyRandom[2].bPath
+			, p->aApplyRandom[3].wType, p->aApplyRandom[3].lValue, p->aApplyRandom[3].bPath
+#endif
+#if defined(__SET_ITEM__)
+			, p->bSetValue
+#endif
+		);
+
+		CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_SAVE, pkPeer->GetHandle(), NULL);
+	}
+	else
+	{
+		if (g_test_server)
+			sys_log(0, "QUERY_ITEM_SAVE => PutItemCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
+
+		PutItemCache(p);
+	}
+}
+
+CClientManager::TItemCacheSet* CClientManager::GetItemCacheSet(DWORD pid)
+{
+	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
+
+	if (it == m_map_pkItemCacheSetPtr.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::CreateItemCacheSet(DWORD pid)
+{
+	if (m_map_pkItemCacheSetPtr.find(pid) != m_map_pkItemCacheSetPtr.end())
+		return;
+
+	TItemCacheSet* pSet = new TItemCacheSet;
+	m_map_pkItemCacheSetPtr.insert(TItemCacheSetPtrMap::value_type(pid, pSet));
+
+	if (g_log)
+		sys_log(0, "ITEM_CACHE: new cache %u", pid);
+}
+
+void CClientManager::FlushItemCacheSet(DWORD pid)
+{
+	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(pid);
+
+	if (it == m_map_pkItemCacheSetPtr.end())
+	{
+		sys_log(0, "FLUSH_ITEMCACHESET : No ItemCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TItemCacheSet* pSet = it->second;
+	TItemCacheSet::iterator it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CItemCache* c = *it_set++;
+		c->Flush();
+
+		m_map_itemCache.erase(c->Get()->dwID);
+		delete c;
+	}
+
+	pSet->clear();
+	delete pSet;
+
+	m_map_pkItemCacheSetPtr.erase(it);
+
+	if (g_log)
+		sys_log(0, "FLUSH_ITEMCACHESET : Deleted pid(%d)", pid);
+}
+
+CItemCache* CClientManager::GetItemCache(DWORD id)
+{
+	TItemCacheMap::iterator it = m_map_itemCache.find(id);
+
+	if (it == m_map_itemCache.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::PutItemCache(TPlayerItem* pNew, bool bSkipQuery)
+{
+	CItemCache* c;
+
+	c = GetItemCache(pNew->dwID);
+
+	//   
+	if (!c)
+	{
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: PutItemCache ==> New CItemCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
+
+		c = new CItemCache;
+		m_map_itemCache.insert(TItemCacheMap::value_type(pNew->dwID, c));
+	}
+	// 
+	else
+	{
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: PutItemCache ==> Have Cache");
+
+		// 微 틀
+		if (pNew->dwOwner != c->Get()->dwOwner)
+		{
+			// 譴    羚    磯.
+			TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
+
+			if (it != m_map_pkItemCacheSetPtr.end())
+			{
+				if (g_log)
+					sys_log(0, "ITEM_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
+				it->second->erase(c);
+			}
+		}
+	}
+
+	// 恝  트
+	c->Put(pNew, bSkipQuery);
+
+	TItemCacheSetPtrMap::iterator it = m_map_pkItemCacheSetPtr.find(c->Get()->dwOwner);
+
+	if (it != m_map_pkItemCacheSetPtr.end())
+	{
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "ITEM_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		it->second->insert(c);
+	}
+	else
+	{
+		//  微 퓐 慕 瞞     SQL 臼
+		//   퓐 慕 磯.
+		if (g_log)
+			sys_log(0, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "ITEM_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+
+		c->OnFlush();
+	}
+}
+
+bool CClientManager::DeleteItemCache(DWORD dwID)
+{
+	CItemCache* c = GetItemCache(dwID);
+
+	if (!c)
+		return false;
+
+	c->Delete();
+	return true;
+}
+
+// MYSHOP_PRICE_LIST
+CItemPriceListTableCache* CClientManager::GetItemPriceListCache(DWORD dwID)
+{
+	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.find(dwID);
+
+	if (it == m_mapItemPriceListCache.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::PutItemPriceListCache(const TItemPriceListTable* pItemPriceList)
+{
+	CItemPriceListTableCache* pCache = GetItemPriceListCache(pItemPriceList->dwOwnerID);
+
+	if (!pCache)
+	{
+		pCache = new CItemPriceListTableCache;
+		m_mapItemPriceListCache.insert(TItemPriceListCacheMap::value_type(pItemPriceList->dwOwnerID, pCache));
+	}
+
+	pCache->Put(const_cast<TItemPriceListTable*>(pItemPriceList), true);
+}
+
+void CClientManager::UpdatePlayerCache()
+{
+	TPlayerTableCacheMap::iterator it = m_map_playerCache.begin();
+
+	while (it != m_map_playerCache.end())
+	{
+		CPlayerTableCache* c = (it++)->second;
+
+		if (c->CheckTimeout())
+		{
+			if (g_log)
+				sys_log(0, "UPDATE : UpdatePlayerCache() ==> FlushPlayerCache %d %s ", c->Get(false)->id, c->Get(false)->name);
+
+			c->Flush();
+
+			// Item Cache 트
+			UpdateItemCacheSet(c->Get()->id);
+#ifdef __GROWTH_PET_SYSTEM__
+			UpdateGrowthPetCacheSet(c->Get()->id);
+#endif
+		}
+		else if (c->CheckFlushTimeout())
+			c->Flush();
+	}
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+void CClientManager::SetCacheFlushCountLimit(int iLimit)
+{
+	m_iCacheFlushCountLimit = MAX(10, iLimit);
+	sys_log(0, "CACHE_FLUSH_LIMIT_PER_SECOND: %d", m_iCacheFlushCountLimit);
+}
+
+void CClientManager::UpdateItemCache()
+{
+	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+		return;
+
+	TItemCacheMap::iterator it = m_map_itemCache.begin();
+
+	while (it != m_map_itemCache.end())
+	{
+		CItemCache* c = (it++)->second;
+
+		//  Flush 磯.
+		if (c->CheckFlushTimeout())
+		{
+			if (g_test_server)
+				sys_log(0, "UpdateItemCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
+
+			c->Flush();
+
+			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+				break;
+		}
+	}
+}
+
+void CClientManager::UpdateItemPriceListCache()
+{
+	TItemPriceListCacheMap::iterator it = m_mapItemPriceListCache.begin();
+
+	while (it != m_mapItemPriceListCache.end())
+	{
+		CItemPriceListTableCache* pCache = it->second;
+
+		if (pCache->CheckFlushTimeout())
+		{
+			pCache->Flush();
+			m_mapItemPriceListCache.erase(it++);
+		}
+		else
+			++it;
+	}
+}
+
+void CClientManager::QUERY_ITEM_DESTROY(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwID = *(DWORD*)c_pData;
+	c_pData += sizeof(DWORD);
+
+	DWORD dwPID = *(DWORD*)c_pData;
+
+	if (!DeleteItemCache(dwID))
+	{
+		char szQuery[64];
+		snprintf(szQuery, sizeof(szQuery), "DELETE FROM item%s WHERE `id` = %u", GetTablePostfix(), dwID);
+
+		if (g_log)
+			sys_log(0, "HEADER_GD_ITEM_DESTROY: PID %u ID %u", dwPID, dwID);
+
+		if (dwPID == 0) // 틜   摸, 宙엽 
+			CDBManager::instance().AsyncQuery(szQuery);
+		else
+			CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_DESTROY, pkPeer->GetHandle(), NULL);
+	}
+}
+
+void CClientManager::QUERY_FLUSH_CACHE(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwPID = *(DWORD*)c_pData;
+
+	CPlayerTableCache* pkCache = GetPlayerCache(dwPID);
+
+	if (!pkCache)
+		return;
+
+	sys_log(0, "FLUSH_CACHE: %u", dwPID);
+
+	pkCache->Flush();
+	FlushItemCacheSet(dwPID);
+#ifdef __GROWTH_PET_SYSTEM__
+	FlushGrowthPetCacheSet(dwPID);
+#endif
+	m_map_playerCache.erase(dwPID);
+	delete pkCache;
+}
+
+void CClientManager::QUERY_RELOAD_PROTO()
+{
+	if (!InitializeTables())
+	{
+		sys_err("QUERY_RELOAD_PROTO: cannot load tables");
+		return;
+	}
+
+	for (TPeerList::iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* tmp = *i;
+
+		if (!tmp->GetChannel())
+			continue;
+
+		tmp->EncodeHeader(HEADER_DG_RELOAD_PROTO, 0,
+			sizeof(WORD) + sizeof(TSkillTable) * m_vec_skillTable.size() +
+			sizeof(WORD) + sizeof(TBanwordTable) * m_vec_banwordTable.size() +
+			sizeof(WORD) + sizeof(TItemTable) * m_vec_itemTable.size() +
+			sizeof(WORD) + sizeof(TMobTable) * m_vec_mobTable.size() +
+			sizeof(WORD) + sizeof(TRefineTable) * m_iRefineTableSize
+#ifdef __GROWTH_PET_SYSTEM__
+			+ sizeof(WORD) + sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size()
+#endif
+		);
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_skillTable.size()));
+		tmp->Encode(&m_vec_skillTable[0], sizeof(TSkillTable) * m_vec_skillTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_banwordTable.size()));
+		tmp->Encode(&m_vec_banwordTable[0], sizeof(TBanwordTable) * m_vec_banwordTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_itemTable.size()));
+		tmp->Encode(&m_vec_itemTable[0], sizeof(TItemTable) * m_vec_itemTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_vec_mobTable.size()));
+		tmp->Encode(&m_vec_mobTable[0], sizeof(TMobTable) * m_vec_mobTable.size());
+
+		tmp->EncodeWORD(static_cast<WORD>(m_iRefineTableSize));
+		tmp->Encode(m_pRefineTable, sizeof(TRefineTable) * m_iRefineTableSize);
+
+#ifdef __GROWTH_PET_SYSTEM__
+		tmp->EncodeWORD(m_vec_growthPetSkillTable.size());
+		if (m_vec_growthPetSkillTable.size())
+			tmp->Encode(&m_vec_growthPetSkillTable[0], sizeof(TGrowthPetSkillTable) * m_vec_growthPetSkillTable.size());
+#endif
+	}
+}
+
+// ADD_GUILD_PRIV_TIME
+/**
+* @version 05/06/08 Bang2ni - 擔챨 煞
+**/
+void CClientManager::AddGuildPriv(TPacketGiveGuildPriv* p)
+{
+	CPrivManager::instance().AddGuildPriv(p->guild_id, p->type, p->value, p->duration_sec);
+}
+
+void CClientManager::AddEmpirePriv(TPacketGiveEmpirePriv* p)
+{
+	CPrivManager::instance().AddEmpirePriv(p->empire, p->type, p->value, p->duration_sec);
+}
+// END_OF_ADD_GUILD_PRIV_TIME
+
+void CClientManager::AddCharacterPriv(TPacketGiveCharacterPriv* p)
+{
+	CPrivManager::instance().AddCharPriv(p->pid, p->type, p->value);
+}
+
+void CClientManager::MoneyLog(TPacketMoneyLog* p)
+{
+	CMoneyLog::instance().AddLog(p->type, p->vnum, p->gold
+#if defined(__CHEQUE_SYSTEM__)
+		, p->cheque
+#endif
+	);
+}
+
+CLoginData* CClientManager::GetLoginData(DWORD dwKey)
+{
+	TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(dwKey);
+
+	if (it == m_map_pkLoginData.end())
+		return NULL;
+
+	return it->second;
+}
+
+CLoginData* CClientManager::GetLoginDataByLogin(const char* c_pszLogin)
+{
+	char szLogin[LOGIN_MAX_LEN + 1];
+	trim_and_lower(c_pszLogin, szLogin, sizeof(szLogin));
+
+	TLoginDataByLogin::iterator it = m_map_pkLoginDataByLogin.find(szLogin);
+
+	if (it == m_map_pkLoginDataByLogin.end())
+		return NULL;
+
+	return it->second;
+}
+
+CLoginData* CClientManager::GetLoginDataByAID(DWORD dwAID)
+{
+	TLoginDataByAID::iterator it = m_map_pkLoginDataByAID.find(dwAID);
+
+	if (it == m_map_pkLoginDataByAID.end())
+		return NULL;
+
+	return it->second;
+}
+
+void CClientManager::InsertLoginData(CLoginData* pkLD)
+{
+	char szLogin[LOGIN_MAX_LEN + 1];
+	trim_and_lower(pkLD->GetAccountRef().login, szLogin, sizeof(szLogin));
+
+	m_map_pkLoginData.insert(std::make_pair(pkLD->GetKey(), pkLD));
+	m_map_pkLoginDataByLogin.insert(std::make_pair(szLogin, pkLD));
+	m_map_pkLoginDataByAID.insert(std::make_pair(pkLD->GetAccountRef().id, pkLD));
+}
+
+void CClientManager::DeleteLoginData(CLoginData* pkLD)
+{
+	m_map_pkLoginData.erase(pkLD->GetKey());
+	m_map_pkLoginDataByLogin.erase(pkLD->GetAccountRef().login);
+	m_map_pkLoginDataByAID.erase(pkLD->GetAccountRef().id);
+
+	if (m_map_kLogonAccount.find(pkLD->GetAccountRef().login) == m_map_kLogonAccount.end())
+		delete pkLD;
+	else
+		pkLD->SetDeleted(true);
+}
+
+void CClientManager::QUERY_AUTH_LOGIN(CPeer* pkPeer, DWORD dwHandle, TPacketGDAuthLogin* p)
+{
+	if (g_test_server)
+		sys_log(0, "QUERY_AUTH_LOGIN %d %d %s", p->dwID, p->dwLoginKey, p->szLogin);
+
+	CLoginData* pkLD = GetLoginDataByLogin(p->szLogin);
+
+	if (pkLD)
+	{
+		DeleteLoginData(pkLD);
+	}
+
+	BYTE bResult;
+
+	if (GetLoginData(p->dwLoginKey))
+	{
+		sys_err("LoginData already exist key %u login %s", p->dwLoginKey, p->szLogin);
+		bResult = 0;
+
+		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
+		pkPeer->EncodeBYTE(bResult);
+	}
+	else
+	{
+		CLoginData* pkLD = new CLoginData;
+
+		pkLD->SetKey(p->dwLoginKey);
+		pkLD->SetClientKey(p->adwClientKey);
+		pkLD->SetPremium(p->iPremiumTimes);
+
+		TAccountTable& r = pkLD->GetAccountRef();
+
+		r.id = p->dwID;
+		trim_and_lower(p->szLogin, r.login, sizeof(r.login));
+		strlcpy(r.social_id, p->szSocialID, sizeof(r.social_id));
+		strlcpy(r.passwd, "TEMP", sizeof(r.passwd));
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		strlcpy(r.country, p->szCountry, sizeof(r.country));
+#endif
+
+		sys_log(0, "AUTH_LOGIN id(%u) login(%s)"
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			" country(%s)"
+#endif
+			" social_id(%s) login_key(%u), client_key(%u %u %u %u)",
+			p->dwID,
+			p->szLogin,
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			p->szCountry,
+#endif
+			p->szSocialID,
+			p->dwLoginKey,
+			p->adwClientKey[0], p->adwClientKey[1], p->adwClientKey[2], p->adwClientKey[3]
+		);
+
+		bResult = 1;
+
+		InsertLoginData(pkLD);
+
+		pkPeer->EncodeHeader(HEADER_DG_AUTH_LOGIN, dwHandle, sizeof(BYTE));
+		pkPeer->EncodeBYTE(bResult);
+	}
+}
+
+void CClientManager::GuildDepositMoney(TPacketGDGuildMoney* p)
+{
+	CGuildManager::instance().DepositMoney(p->dwGuild, p->iGold);
+}
+
+void CClientManager::GuildWithdrawMoney(CPeer* peer, TPacketGDGuildMoney* p)
+{
+	CGuildManager::instance().WithdrawMoney(peer, p->dwGuild, p->iGold);
+}
+
+void CClientManager::GuildWithdrawMoneyGiveReply(TPacketGDGuildMoneyWithdrawGiveReply* p)
+{
+	CGuildManager::instance().WithdrawMoneyReply(p->dwGuild, p->bGiveSuccess, p->iChangeGold);
+}
+
+void CClientManager::GuildWarBet(TPacketGDGuildWarBet* p)
+{
+	CGuildManager::instance().Bet(p->dwWarID, p->szLogin, p->dwGold, p->dwGuild);
+}
+
+void CClientManager::CreateObject(TPacketGDCreateObject* p)
+{
+	using namespace building;
+
+	char szQuery[512];
+
+	snprintf(szQuery, sizeof(szQuery),
+		"INSERT INTO object%s (`land_id`, `vnum`, `map_index`, `x`, `y`, `x_rot`, `y_rot`, `z_rot`) VALUES(%u, %u, %d, %d, %d, %f, %f, %f)",
+		GetTablePostfix(), p->dwLandID, p->dwVnum, p->lMapIndex, p->x, p->y, p->xRot, p->yRot, p->zRot);
+
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+	if (pmsg->Get()->uiInsertID == 0)
+	{
+		sys_err("cannot insert object");
+		return;
+	}
+
+	TObject* pkObj = new TObject;
+
+	memset(pkObj, 0, sizeof(TObject));
+
+	pkObj->dwID = pmsg->Get()->uiInsertID;
+	pkObj->dwVnum = p->dwVnum;
+	pkObj->dwLandID = p->dwLandID;
+	pkObj->lMapIndex = p->lMapIndex;
+	pkObj->x = p->x;
+	pkObj->y = p->y;
+	pkObj->xRot = p->xRot;
+	pkObj->yRot = p->yRot;
+	pkObj->zRot = p->zRot;
+	pkObj->lLife = 0;
+
+	ForwardPacket(HEADER_DG_CREATE_OBJECT, pkObj, sizeof(TObject));
+
+	m_map_pkObjectTable.insert(std::make_pair(pkObj->dwID, pkObj));
+}
+
+void CClientManager::DeleteObject(DWORD dwID)
+{
+	char szQuery[128];
+
+	snprintf(szQuery, sizeof(szQuery), "DELETE FROM object%s WHERE `id` = %u", GetTablePostfix(), dwID);
+
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
+	{
+		sys_err("no object by id %u", dwID);
+		return;
+	}
+
+	//pkObjectTableMap::const_iterator it = m_map_pkObjectTable.find(dwID);
+	auto it = m_map_pkObjectTable.find(dwID);
+	if (it != m_map_pkObjectTable.end())
+	{
+		delete it->second;
+		m_map_pkObjectTable.erase(it);
+	}
+
+	ForwardPacket(HEADER_DG_DELETE_OBJECT, &dwID, sizeof(DWORD));
+}
+
+void CClientManager::UpdateLand(DWORD* pdw)
+{
+	DWORD dwID = pdw[0];
+	DWORD dwGuild = pdw[1];
+
+	building::TLand* p = &m_vec_kLandTable[0];
+
+	DWORD i;
+
+	for (i = 0; i < m_vec_kLandTable.size(); ++i, ++p)
+	{
+		if (p->dwID == dwID)
+		{
+			char buf[256];
+			snprintf(buf, sizeof(buf), "UPDATE land%s SET `guild_id` = %u WHERE `id` = %u", GetTablePostfix(), dwGuild, dwID);
+			CDBManager::instance().AsyncQuery(buf);
+
+			p->dwGuildID = dwGuild;
+			break;
+		}
+	}
+
+	if (i < m_vec_kLandTable.size())
+		ForwardPacket(HEADER_DG_UPDATE_LAND, p, sizeof(building::TLand));
+}
+
+// BLOCK_CHAT
+void CClientManager::BlockChat(TPacketBlockChat* p)
+{
+	char szQuery[256];
+
+	char escName[sizeof(p->szName) * 2 + 1];
+	const size_t nameLen = strnlen(p->szName, sizeof(p->szName));
+	CDBManager::instance().EscapeString(escName, p->szName, static_cast<unsigned long>(nameLen));
+
+	if (g_stLocale == "sjis")
+		snprintf(szQuery, sizeof(szQuery), "SELECT `id `FROM player%s WHERE `name` = '%s' COLLATE sjis_japanese_ci",
+			GetTablePostfix(), escName);
+	else
+		snprintf(szQuery, sizeof(szQuery), "SELECT `id` FROM player%s WHERE `name` = '%s'",
+			GetTablePostfix(), escName);
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+	SQLResult* pRes = pmsg->Get();
+
+	if (pRes->uiNumRows)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pRes->pSQLResult);
+		DWORD pid = strtoul(row[0], NULL, 10);
+
+		TPacketGDAddAffect pa;
+		pa.dwPID = pid;
+		pa.elem.dwType = 223;
+		pa.elem.wApplyOn = 0;
+		pa.elem.lApplyValue = 0;
+		pa.elem.dwFlag = 0;
+		pa.elem.lDuration = p->lDuration;
+		pa.elem.lSPCost = 0;
+		QUERY_ADD_AFFECT(NULL, &pa);
+	}
+	else
+	{
+		// cannot find user with that name
+	}
+}
+// END_OF_BLOCK_CHAT
+
+void CClientManager::MarriageAdd(TPacketMarriageAdd* p)
+{
+	sys_log(0, "MarriageAdd %u %u %s %s", p->dwPID1, p->dwPID2, p->szName1, p->szName2);
+	marriage::CManager::instance().Add(p->dwPID1, p->dwPID2, p->szName1, p->szName2);
+}
+
+void CClientManager::MarriageUpdate(TPacketMarriageUpdate* p)
+{
+	sys_log(0, "MarriageUpdate PID:%u %u LP:%d ST:%d", p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
+	marriage::CManager::instance().Update(p->dwPID1, p->dwPID2, p->iLovePoint, p->byMarried);
+}
+
+void CClientManager::MarriageRemove(TPacketMarriageRemove* p)
+{
+	sys_log(0, "MarriageRemove %u %u", p->dwPID1, p->dwPID2);
+	marriage::CManager::instance().Remove(p->dwPID1, p->dwPID2);
+}
+
+void CClientManager::WeddingRequest(TPacketWeddingRequest* p)
+{
+	sys_log(0, "WeddingRequest %u %u", p->dwPID1, p->dwPID2);
+	ForwardPacket(HEADER_DG_WEDDING_REQUEST, p, sizeof(TPacketWeddingRequest));
+	//marriage::CManager::instance().RegisterWedding(p->dwPID1, p->szName1, p->dwPID2, p->szName2);
+}
+
+void CClientManager::WeddingReady(TPacketWeddingReady* p)
+{
+	sys_log(0, "WeddingReady %u %u", p->dwPID1, p->dwPID2);
+	ForwardPacket(HEADER_DG_WEDDING_READY, p, sizeof(TPacketWeddingReady));
+	marriage::CManager::instance().ReadyWedding(p->dwMapIndex, p->dwPID1, p->dwPID2);
+}
+
+void CClientManager::WeddingEnd(TPacketWeddingEnd* p)
+{
+	sys_log(0, "WeddingEnd %u %u", p->dwPID1, p->dwPID2);
+	marriage::CManager::instance().EndWedding(p->dwPID1, p->dwPID2);
+}
+
+//
+// 캐첼   캐첩 트 構 캐첼  摸
+// 耳  拷 琯 悶   캐첩     트 磯.
+//
+void CClientManager::MyshopPricelistUpdate(const TItemPriceListTable* pPacket)
+{
+	if (pPacket->byCount > SHOP_PRICELIST_MAX_NUM)
+	{
+		sys_err("count overflow!");
+		return;
+	}
+
+	CItemPriceListTableCache* pCache = GetItemPriceListCache(pPacket->dwOwnerID);
+
+	if (pCache)
+	{
+		TItemPriceListTable table;
+
+		table.dwOwnerID = pPacket->dwOwnerID;
+		table.byCount = pPacket->byCount;
+
+		thecore_memcpy(table.aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
+
+		pCache->UpdateList(&table);
+	}
+	else
+	{
+		TItemPriceListTable* pUpdateTable = new TItemPriceListTable;
+
+		pUpdateTable->dwOwnerID = pPacket->dwOwnerID;
+		pUpdateTable->byCount = pPacket->byCount;
+
+		thecore_memcpy(pUpdateTable->aPriceInfo, pPacket->aPriceInfo, sizeof(TItemPriceInfo) * pPacket->byCount);
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `item_vnum`, `price`"
+#if defined(__CHEQUE_SYSTEM__)
+			", `cheque`"
+#endif
+			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), pPacket->dwOwnerID);
+		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD_FOR_UPDATE, 0, pUpdateTable);
+	}
+}
+
+// MYSHOP_PRICE_LIST
+// 캐천   캐첩 棘 慕 構 캐첼   DB   磯.
+//
+void CClientManager::MyshopPricelistRequest(CPeer* peer, DWORD dwHandle, DWORD dwPlayerID)
+{
+	if (CItemPriceListTableCache* pCache = GetItemPriceListCache(dwPlayerID))
+	{
+		sys_log(0, "Cache MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
+
+		TItemPriceListTable* pTable = pCache->Get(false);
+
+		TPacketMyshopPricelistHeader header =
+		{
+			pTable->dwOwnerID,
+			pTable->byCount
+		};
+
+		size_t sizePriceListSize = sizeof(TItemPriceInfo) * pTable->byCount;
+
+		peer->EncodeHeader(HEADER_DG_MYSHOP_PRICELIST_RES, dwHandle, sizeof(header) + sizePriceListSize);
+		peer->Encode(&header, sizeof(header));
+		peer->Encode(pTable->aPriceInfo, sizePriceListSize);
+	}
+	else
+	{
+		sys_log(0, "Query MyShopPricelist handle[%d] pid[%d]", dwHandle, dwPlayerID);
+
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT `item_vnum`, `price`"
+#if defined(__CHEQUE_SYSTEM__)
+			", `cheque`"
+#endif
+			" FROM myshop_pricelist%s WHERE `owner_id` = %u", GetTablePostfix(), dwPlayerID);
+		CDBManager::instance().ReturnQuery(szQuery, QID_ITEMPRICE_LOAD, peer->GetHandle(), new TItemPricelistReqInfo(dwHandle, dwPlayerID));
+	}
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+void CPacketInfo::Add(int header)
+{
+	auto it = m_map_info.find(header);
+	if (it == m_map_info.end())
+		m_map_info.insert(std::map<int, int>::value_type(header, 1));
+	else
+		++it->second;
+}
+
+void CPacketInfo::Reset()
+{
+	m_map_info.clear();
+}
+
+void CClientManager::ProcessPackets(CPeer* peer)
+{
+	BYTE header;
+	DWORD dwHandle;
+	DWORD dwLength;
+	const char* data = NULL;
+	int i = 0;
+	int iCount = 0;
+
+	while (peer->PeekPacket(i, header, dwHandle, dwLength, &data))
+	{
+		// DISABLE_DB_HEADER_LOG
+		// sys_log(0, "header %d %p size %d", header, this, dwLength);
+		// END_OF_DISABLE_DB_HEADER_LOG
+		m_bLastHeader = header;
+		++iCount;
+
+#if defined(_DEBUG)
+		if (header != 10)
+			sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
+#endif
+
+		if (g_test_server)
+		{
+			if (header != 10)
+				sys_log(0, " ProcessPacket Header [%d] Handle[%d] Length[%d] iCount[%d]", header, dwHandle, dwLength, iCount);
+		}
+
+		// test log by mhh
+		{
+			if (HEADER_GD_BLOCK_COUNTRY_IP == header)
+				sys_log(0, "recved : HEADER_GD_BLOCK_COUNTRY_IP");
+		}
+
+		switch (header)
+		{
+			case HEADER_GD_BOOT:
+				QUERY_BOOT(peer, (TPacketGDBoot*)data);
+				break;
+
+			case HEADER_GD_HAMMER_OF_TOR:
+				break;
+
+			case HEADER_GD_LOGIN_BY_KEY:
+				QUERY_LOGIN_BY_KEY(peer, dwHandle, (TPacketGDLoginByKey*)data);
+				break;
+
+			case HEADER_GD_LOGOUT:
+				//sys_log(0, "HEADER_GD_LOGOUT (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_LOGOUT(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_PLAYER_LOAD:
+				sys_log(1, "HEADER_GD_PLAYER_LOAD (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_PLAYER_LOAD(peer, dwHandle, (TPlayerLoadPacket*)data);
+				break;
+
+			case HEADER_GD_PLAYER_SAVE:
+				sys_log(1, "HEADER_GD_PLAYER_SAVE (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_PLAYER_SAVE(peer, dwHandle, (TPlayerTable*)data);
+				break;
+
+			case HEADER_GD_PLAYER_CREATE:
+				sys_log(0, "HEADER_GD_PLAYER_CREATE (handle: %d length: %d)", dwHandle, dwLength);
+				__QUERY_PLAYER_CREATE(peer, dwHandle, (TPlayerCreatePacket*)data);
+				sys_log(0, "END");
+				break;
+
+			case HEADER_GD_PLAYER_DELETE:
+				sys_log(1, "HEADER_GD_PLAYER_DELETE (handle: %d length: %d)", dwHandle, dwLength);
+				__QUERY_PLAYER_DELETE(peer, dwHandle, (TPlayerDeletePacket*)data);
+				break;
+
+			case HEADER_GD_PLAYER_COUNT:
+				QUERY_PLAYER_COUNT(peer, (TPlayerCountPacket*)data);
+				break;
+
+			case HEADER_GD_QUEST_SAVE:
+				sys_log(1, "HEADER_GD_QUEST_SAVE (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_QUEST_SAVE(peer, (TQuestTable*)data, dwLength);
+				break;
+
+			case HEADER_GD_SAFEBOX_LOAD:
+				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 0);
+				break;
+
+			case HEADER_GD_SAFEBOX_SAVE:
+				sys_log(1, "HEADER_GD_SAFEBOX_SAVE (handle: %d length: %d)", dwHandle, dwLength);
+				QUERY_SAFEBOX_SAVE(peer, (TSafeboxTable*)data);
+				break;
+
+			case HEADER_GD_SAFEBOX_CHANGE_SIZE:
+				QUERY_SAFEBOX_CHANGE_SIZE(peer, dwHandle, (TSafeboxChangeSizePacket*)data);
+				break;
+
+			case HEADER_GD_SAFEBOX_CHANGE_PASSWORD:
+				QUERY_SAFEBOX_CHANGE_PASSWORD(peer, dwHandle, (TSafeboxChangePasswordPacket*)data);
+				break;
+
+			case HEADER_GD_MALL_LOAD:
+				QUERY_SAFEBOX_LOAD(peer, dwHandle, (TSafeboxLoadPacket*)data, 1);
+				break;
+
+			case HEADER_GD_EMPIRE_SELECT:
+				QUERY_EMPIRE_SELECT(peer, dwHandle, (TEmpireSelectPacket*)data);
+				break;
+
+			case HEADER_GD_SETUP:
+				QUERY_SETUP(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_GUILD_CREATE:
+				GuildCreate(peer, *(DWORD*)data);
+				break;
+
+			case HEADER_GD_GUILD_SKILL_UPDATE:
+				GuildSkillUpdate(peer, (TPacketGuildSkillUpdate*)data);
+				break;
+
+			case HEADER_GD_GUILD_EXP_UPDATE:
+				GuildExpUpdate(peer, (TPacketGuildExpUpdate*)data);
+				break;
+
+			case HEADER_GD_GUILD_ADD_MEMBER:
+				GuildAddMember(peer, (TPacketGDGuildAddMember*)data);
+				break;
+
+			case HEADER_GD_GUILD_REMOVE_MEMBER:
+				GuildRemoveMember(peer, (TPacketGuild*)data);
+				break;
+
+			case HEADER_GD_GUILD_CHANGE_GRADE:
+				GuildChangeGrade(peer, (TPacketGuild*)data);
+				break;
+
+			case HEADER_GD_GUILD_CHANGE_MEMBER_DATA:
+				GuildChangeMemberData(peer, (TPacketGuildChangeMemberData*)data);
+				break;
+
+			case HEADER_GD_GUILD_DISBAND:
+				GuildDisband(peer, (TPacketGuild*)data);
+				break;
+
+			case HEADER_GD_GUILD_WAR:
+				GuildWar(peer, (TPacketGuildWar*)data);
+				break;
+
+			case HEADER_GD_GUILD_WAR_SCORE:
+				GuildWarScore(peer, (TPacketGuildWarScore*)data);
+				break;
+
+			case HEADER_GD_GUILD_CHANGE_LADDER_POINT:
+				GuildChangeLadderPoint((TPacketGuildLadderPoint*)data);
+				break;
+
+			case HEADER_GD_GUILD_USE_SKILL:
+				GuildUseSkill((TPacketGuildUseSkill*)data);
+				break;
+
+			case HEADER_GD_FLUSH_CACHE:
+				QUERY_FLUSH_CACHE(peer, data);
+				break;
+
+			case HEADER_GD_ITEM_SAVE:
+				QUERY_ITEM_SAVE(peer, data);
+				break;
+
+			case HEADER_GD_ITEM_DESTROY:
+				QUERY_ITEM_DESTROY(peer, data);
+				break;
+
+			case HEADER_GD_ITEM_FLUSH:
+				QUERY_ITEM_FLUSH(peer, data);
+				break;
+
+			case HEADER_GD_ADD_AFFECT:
+				sys_log(1, "HEADER_GD_ADD_AFFECT");
+				QUERY_ADD_AFFECT(peer, (TPacketGDAddAffect*)data);
+				break;
+
+			case HEADER_GD_REMOVE_AFFECT:
+				sys_log(1, "HEADER_GD_REMOVE_AFFECT");
+				QUERY_REMOVE_AFFECT(peer, (TPacketGDRemoveAffect*)data);
+				break;
+
+			case HEADER_GD_HIGHSCORE_REGISTER:
+				QUERY_HIGHSCORE_REGISTER(peer, (TPacketGDHighscore*)data);
+				break;
+
+			case HEADER_GD_PARTY_CREATE:
+				QUERY_PARTY_CREATE(peer, (TPacketPartyCreate*)data);
+				break;
+
+			case HEADER_GD_PARTY_DELETE:
+				QUERY_PARTY_DELETE(peer, (TPacketPartyDelete*)data);
+				break;
+
+			case HEADER_GD_PARTY_ADD:
+				QUERY_PARTY_ADD(peer, (TPacketPartyAdd*)data);
+				break;
+
+			case HEADER_GD_PARTY_REMOVE:
+				QUERY_PARTY_REMOVE(peer, (TPacketPartyRemove*)data);
+				break;
+
+			case HEADER_GD_PARTY_STATE_CHANGE:
+				QUERY_PARTY_STATE_CHANGE(peer, (TPacketPartyStateChange*)data);
+				break;
+
+			case HEADER_GD_PARTY_SET_MEMBER_LEVEL:
+				QUERY_PARTY_SET_MEMBER_LEVEL(peer, (TPacketPartySetMemberLevel*)data);
+				break;
+
+			case HEADER_GD_RELOAD_PROTO:
+				QUERY_RELOAD_PROTO();
+				break;
+
+			case HEADER_GD_CHANGE_NAME:
+				QUERY_CHANGE_NAME(peer, dwHandle, (TPacketGDChangeName*)data);
+				break;
+
+			case HEADER_GD_AUTH_LOGIN:
+				QUERY_AUTH_LOGIN(peer, dwHandle, (TPacketGDAuthLogin*)data);
+				break;
+
+			case HEADER_GD_REQUEST_GUILD_PRIV:
+				AddGuildPriv((TPacketGiveGuildPriv*)data);
+				break;
+
+			case HEADER_GD_REQUEST_EMPIRE_PRIV:
+				AddEmpirePriv((TPacketGiveEmpirePriv*)data);
+				break;
+
+			case HEADER_GD_REQUEST_CHARACTER_PRIV:
+				AddCharacterPriv((TPacketGiveCharacterPriv*)data);
+				break;
+
+			case HEADER_GD_MONEY_LOG:
+				MoneyLog((TPacketMoneyLog*)data);
+				break;
+
+			case HEADER_GD_GUILD_DEPOSIT_MONEY:
+				GuildDepositMoney((TPacketGDGuildMoney*)data);
+				break;
+
+			case HEADER_GD_GUILD_WITHDRAW_MONEY:
+				GuildWithdrawMoney(peer, (TPacketGDGuildMoney*)data);
+				break;
+
+			case HEADER_GD_GUILD_WITHDRAW_MONEY_GIVE_REPLY:
+				GuildWithdrawMoneyGiveReply((TPacketGDGuildMoneyWithdrawGiveReply*)data);
+				break;
+
+			case HEADER_GD_GUILD_WAR_BET:
+				GuildWarBet((TPacketGDGuildWarBet*)data);
+				break;
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+			case HEADER_GD_GUILD_EVENT_FLAG:
+				GuildSetEventFlag((TPacketSetGuildEventFlag*)data);
+				break;
+#endif
+
+			case HEADER_GD_SET_EVENT_FLAG:
+				SetEventFlag((TPacketSetEventFlag*)data);
+				break;
+
+			case HEADER_GD_CREATE_OBJECT:
+				CreateObject((TPacketGDCreateObject*)data);
+				break;
+
+			case HEADER_GD_DELETE_OBJECT:
+				DeleteObject(*(DWORD*)data);
+				break;
+
+			case HEADER_GD_UPDATE_LAND:
+				UpdateLand((DWORD*)data);
+				break;
+
+			case HEADER_GD_MARRIAGE_ADD:
+				MarriageAdd((TPacketMarriageAdd*)data);
+				break;
+
+			case HEADER_GD_MARRIAGE_UPDATE:
+				MarriageUpdate((TPacketMarriageUpdate*)data);
+				break;
+
+			case HEADER_GD_MARRIAGE_REMOVE:
+				MarriageRemove((TPacketMarriageRemove*)data);
+				break;
+
+			case HEADER_GD_WEDDING_REQUEST:
+				WeddingRequest((TPacketWeddingRequest*)data);
+				break;
+
+			case HEADER_GD_WEDDING_READY:
+				WeddingReady((TPacketWeddingReady*)data);
+				break;
+
+			case HEADER_GD_WEDDING_END:
+				WeddingEnd((TPacketWeddingEnd*)data);
+				break;
+
+				// BLOCK_CHAT
+			case HEADER_GD_BLOCK_CHAT:
+				BlockChat((TPacketBlockChat*)data);
+				break;
+				// END_OF_BLOCK_CHAT
+
+				// MYSHOP_PRICE_LIST
+			case HEADER_GD_MYSHOP_PRICELIST_UPDATE:
+				MyshopPricelistUpdate((TItemPriceListTable*)data);
+				break;
+
+			case HEADER_GD_MYSHOP_PRICELIST_REQ:
+				MyshopPricelistRequest(peer, dwHandle, *(DWORD*)data);
+				break;
+				// END_OF_MYSHOP_PRICE_LIST
+
+				// RELOAD_ADMIN
+			case HEADER_GD_RELOAD_ADMIN:
+				ReloadAdmin(peer, (TPacketReloadAdmin*)data);
+				break;
+				// END_RELOAD_ADMIN
+
+			case HEADER_GD_BREAK_MARRIAGE:
+				BreakMarriage(peer, data);
+				break;
+
+				// MOANRCH
+			case HEADER_GD_ELECT_MONARCH:
+				Election(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_CANDIDACY:
+				Candidacy(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_ADD_MONARCH_MONEY:
+				AddMonarchMoney(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_DEC_MONARCH_MONEY:
+				DecMonarchMoney(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_TAKE_MONARCH_MONEY:
+				TakeMonarchMoney(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_COME_TO_VOTE:
+				ComeToVote(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_RMCANDIDACY: ///< 캤  (楮)
+				RMCandidacy(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_SETMONARCH: ///< 玲 (楮)
+				SetMonarch(peer, dwHandle, data);
+				break;
+
+			case HEADER_GD_RMMONARCH: ///< 怜
+				RMMonarch(peer, dwHandle, data);
+				break;
+				// END_MONARCH
+
+			case HEADER_GD_CHANGE_MONARCH_LORD:
+				ChangeMonarchLord(peer, dwHandle, (TPacketChangeMonarchLord*)data);
+				break;
+
+			case HEADER_GD_BLOCK_COUNTRY_IP:
+				sys_log(0, "HEADER_GD_BLOCK_COUNTRY_IP received");
+				CBlockCountry::instance().SendBlockedCountryIp(peer);
+				CBlockCountry::instance().SendBlockException(peer);
+				break;
+
+			case HEADER_GD_BLOCK_EXCEPTION:
+				sys_log(0, "HEADER_GD_BLOCK_EXCEPTION received");
+				BlockException((TPacketBlockException*)data);
+				break;
+
+			case HEADER_GD_REQ_SPARE_ITEM_ID_RANGE:
+				SendSpareItemIDRange(peer);
+				break;
+
+			case HEADER_GD_REQ_CHANGE_GUILD_MASTER:
+				GuildChangeMaster((TPacketChangeGuildMaster*)data);
+				break;
+
+			case HEADER_GD_UPDATE_HORSE_NAME:
+				UpdateHorseName((TPacketUpdateHorseName*)data, peer);
+				break;
+
+			case HEADER_GD_REQ_HORSE_NAME:
+				AckHorseName(*(DWORD*)data, peer);
+				break;
+
+			case HEADER_GD_DC:
+				DeleteLoginKey((TPacketDC*)data);
+				break;
+
+			case HEADER_GD_VALID_LOGOUT:
+				ResetLastPlayerID((TPacketNeedLoginLogInfo*)data);
+				break;
+
+			case HEADER_GD_REQUEST_CHARGE_CASH:
+				ChargeCash((TRequestChargeCash*)data);
+				break;
+
+				// delete gift notify icon
+			case HEADER_GD_DELETE_AWARDID:
+				DeleteAwardId((TPacketDeleteAwardID*)data);
+				break;
+
+			case HEADER_GD_UPDATE_CHANNELSTATUS:
+				UpdateChannelStatus((SChannelStatus*)data);
+				break;
+
+			case HEADER_GD_REQUEST_CHANNELSTATUS:
+				RequestChannelStatus(peer, dwHandle);
+				break;
+
+#if defined(__MOVE_CHANNEL__)
+			case HEADER_GD_FIND_CHANNEL:
+				FindChannel(peer, dwHandle, (TPacketChangeChannel*)data);
+				break;
+#endif
+
+#if defined(__GEM_SHOP__)
+			case HEADER_GD_GEM_SHOP_LOAD:
+				LoadGemShop(peer, dwHandle, (TGemShopLoad*)data);
+				break;
+
+			case HEADER_GD_GEM_SHOP_UPDATE:
+				UpdateGemShop(peer, dwHandle, (TGemShopTable*)data);
+				break;
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+			case HEADER_GD_EMOTE_LOAD:
+				QUERY_EMOTE_LOAD(peer, dwHandle, (TPacketGDEmote*)data);
+				break;
+
+			case HEADER_GD_EMOTE_CLEAR:
+				QUERY_EMOTE_CLEAR(peer, dwHandle, (TPacketGDEmote*)data);
+				break;
+
+			case HEADER_GD_EMOTE_ADD:
+				QUERY_EMOTE_ADD(peer, dwHandle, (TPacketGDEmote*)data);
+				break;
+#endif
+
+#if defined(__MAILBOX__)
+			case HEADER_GD_MAILBOX_LOAD:
+				QUERY_MAILBOX_LOAD(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_CHECK_NAME:
+				QUERY_MAILBOX_CHECK_NAME(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_WRITE:
+				QUERY_MAILBOX_WRITE(peer, dwHandle, (TMailBoxTable*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_DELETE:
+				QUERY_MAILBOX_DELETE(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_CONFIRM:
+				QUERY_MAILBOX_CONFIRM(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_GET:
+				QUERY_MAILBOX_GET(peer, dwHandle, (TMailBox*)data);
+				break;
+
+			case HEADER_GD_MAILBOX_UNREAD:
+				QUERY_MAILBOX_UNREAD(peer, dwHandle, (TMailBox*)data);
+				break;
+#endif
+
+#ifdef __SHOP_SEARCH__
+			case HEADER_GD_SHOP_SEARCH_REGISTER_ITEM:
+				CShopSearchManager::Instance().RecvRegisterItem(peer, *reinterpret_cast<const TShopSearchItem*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_UNREGISTER_ITEM:
+				CShopSearchManager::Instance().RecvUnregisterItem(*reinterpret_cast<const TShopSearchItem*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_SOLD_ITEM:
+				CShopSearchManager::Instance().RecvSoldItem(*reinterpret_cast<const TPacketGDShopSearchSoldItem*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BY_NAME:
+				CShopSearchManager::Instance().RecvSearchByName(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchByName*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BY_OPTIONS:
+			{
+				const TPacketGDShopSearchByOptions& packet = *reinterpret_cast<const TPacketGDShopSearchByOptions*>(data);
+				data += sizeof(TPacketGDShopSearchByOptions);
+				const TShopSearchItemType* itemTypeFlags = (const TShopSearchItemType*)data;
+				data += sizeof(TShopSearchItemType) * packet.options.typeFlagCount;
+				CShopSearchManager::Instance().RecvSearchByOptions(peer, dwHandle, packet, itemTypeFlags, (const DWORD*)data);
+			}
+			break;
+
+			case HEADER_GD_SHOP_SEARCH_REQUEST_BUY:
+				CShopSearchManager::Instance().RecvBuyItem(peer, dwHandle, *reinterpret_cast<const TPacketGDShopSearchRequestBuy*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BUY_FROM_SHOP_ERROR:
+				CShopSearchManager::Instance().RecvBuyFromShopError(*reinterpret_cast<const TPacketDGShopSearchBuyFromShop*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_BOUGHT_FROM_SHOP:
+				CShopSearchManager::Instance().RecvBoughtFromShop(dwHandle, *reinterpret_cast<const TPacketGDShopSearchBoughtFromShop*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_REQUEST_SOLD_INFO:
+				CShopSearchManager::Instance().RecvRequestSoldInfo(peer, dwHandle, *reinterpret_cast<const DWORD*>(data));
+				break;
+
+			case HEADER_GD_SHOP_SEARCH_RELOAD_AVERAGE:
+				CShopSearchManager::Instance().Initialize();
+				break;
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+			case HEADER_GD_GROWTH_PET_SAVE:
+				QUERY_GROWTH_PET_SAVE(peer, data);
+				break;
+
+			case HEADER_GD_GROWTH_PET_DELETE:
+				QUERY_GROWTH_PET_DELETE(peer, data);
+				break;
+#endif
+
+#ifdef __OFFLINE_SHOP__
+			case HEADER_GD_REQUEST_OFFLINE_SHOP_ID:
+				RequestOfflineShopId(peer, *reinterpret_cast<const uint32_t*>(data));
+				break;
+
+			case HEADER_GD_OFFLINE_SHOP_SAVE:
+				SaveOfflineShop(*reinterpret_cast<const TOfflineShop*>(data));
+				break;
+
+			case HEADER_GD_OFFLINE_SHOP_SAVE_ITEM:
+				SaveOfflineShopItem(*reinterpret_cast<const TOfflineShopItem*>(data));
+				break;
+
+			case HEADER_GD_OFFLINE_SHOP_DESTROY:
+				DestroyOfflineShop(*reinterpret_cast<const uint32_t*>(data));
+				break;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			case HEADER_GD_SAVE_EXT_BATTLE_PASS:
+				QUERY_SAVE_EXT_BATTLE_PASS(peer, dwHandle, (TPlayerExtBattlePassMission*)data);
+				break;
+#endif
+
+			default:
+				sys_err("Unknown header (header: %d handle: %d length: %d)", header, dwHandle, dwLength);
+				break;
+		}
+	}
+
+	peer->RecvEnd(i);
+}
+
+void CClientManager::AddPeer(socket_t fd)
+{
+	CPeer* pPeer = new CPeer;
+
+	if (pPeer->Accept(fd))
+		m_peerList.push_front(pPeer);
+	else
+		delete pPeer;
+}
+
+void CClientManager::RemovePeer(CPeer* pPeer)
+{
+	if (m_pkAuthPeer == pPeer)
+	{
+		m_pkAuthPeer = NULL;
+	}
+	else
+	{
+		TLogonAccountMap::iterator it = m_map_kLogonAccount.begin();
+
+		while (it != m_map_kLogonAccount.end())
+		{
+			CLoginData* pkLD = it->second;
+
+			if (pkLD->GetConnectedPeerHandle() == pPeer->GetHandle())
+			{
+				if (pkLD->IsPlay())
+					pkLD->SetPlay(false);
+
+				if (pkLD->IsDeleted())
+				{
+					sys_log(0, "DELETING LoginData");
+					delete pkLD;
+				}
+
+				m_map_kLogonAccount.erase(it++);
+			}
+			else
+				++it;
+		}
+	}
+
+	m_peerList.remove(pPeer);
+	delete pPeer;
+}
+
+CPeer* CClientManager::GetPeer(IDENT ident)
+{
+	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* tmp = *i;
+
+		if (tmp->GetHandle() == ident)
+			return tmp;
+	}
+
+	return NULL;
+}
+
+CPeer* CClientManager::GetAnyPeer()
+{
+	if (m_peerList.empty())
+		return NULL;
+
+	return m_peerList.front();
+}
+
+// DB 킴    처磯.
+//
+// @version	05/06/10 Bang2ni -   (QID_ITEMPRICE_XXX) 煞
+int CClientManager::AnalyzeQueryResult(SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	CPeer* peer = GetPeer(qi->dwIdent);
+
+#if defined(_DEBUG)
+	if (qi->iType != QID_ITEM_AWARD_LOAD)
+		sys_log(0, "AnalyzeQueryResult %d", qi->iType);
+#endif
+
+	switch (qi->iType)
+	{
+		case QID_ITEM_AWARD_LOAD:
+			ItemAwardManager::instance().Load(msg);
+			delete qi;
+			return true;
+
+		case QID_GUILD_RANKING:
+			CGuildManager::instance().ResultRanking(msg->Get()->pSQLResult);
+			break;
+
+			// MYSHOP_PRICE_LIST
+		case QID_ITEMPRICE_LOAD_FOR_UPDATE:
+			RESULT_PRICELIST_LOAD_FOR_UPDATE(msg);
+			break;
+			// END_OF_MYSHOP_PRICE_LIST
+	}
+
+	if (!peer)
+	{
+		//sys_err("CClientManager::AnalyzeQueryResult: peer not exist anymore. (ident: %d)", qi->dwIdent);
+		delete qi;
+		return true;
+	}
+
+	switch (qi->iType)
+	{
+		case QID_PLAYER:
+		case QID_ITEM:
+		case QID_QUEST:
+		case QID_AFFECT:
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		case QID_EXT_BATTLE_PASS:
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+		case QID_GROWTH_PET:
+#endif
+			RESULT_COMPOSITE_PLAYER(peer, msg, qi->iType);
+			break;
+
+		case QID_LOGIN:
+			RESULT_LOGIN(peer, msg);
+			break;
+
+		case QID_SAFEBOX_LOAD:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_LOAD");
+			RESULT_SAFEBOX_LOAD(peer, msg);
+			break;
+
+		case QID_SAFEBOX_CHANGE_SIZE:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_SIZE");
+			RESULT_SAFEBOX_CHANGE_SIZE(peer, msg);
+			break;
+
+		case QID_SAFEBOX_CHANGE_PASSWORD:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
+			RESULT_SAFEBOX_CHANGE_PASSWORD(peer, msg);
+			break;
+
+		case QID_SAFEBOX_CHANGE_PASSWORD_SECOND:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_SAFEBOX_CHANGE_PASSWORD %p", msg);
+			RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(peer, msg);
+			break;
+
+		case QID_HIGHSCORE_REGISTER:
+			sys_log(0, "QUERY_RESULT: HEADER_GD_HIGHSCORE_REGISTER %p", msg);
+			RESULT_HIGHSCORE_REGISTER(peer, msg);
+			break;
+
+		case QID_SAFEBOX_SAVE:
+		case QID_ITEM_SAVE:
+		case QID_ITEM_DESTROY:
+		case QID_QUEST_SAVE:
+		case QID_PLAYER_SAVE:
+		case QID_ITEM_AWARD_TAKEN:
+#ifdef __GROWTH_PET_SYSTEM__
+		case QID_GROWTH_PET_SAVE:
+		case QID_GROWTH_PET_DELETE:
+#endif
+			break;
+
+			// PLAYER_INDEX_CREATE_BUG_FIX
+		case QID_PLAYER_INDEX_CREATE:
+			RESULT_PLAYER_INDEX_CREATE(peer, msg);
+			break;
+			// END_PLAYER_INDEX_CREATE_BUG_FIX
+
+		case QID_PLAYER_DELETE:
+			__RESULT_PLAYER_DELETE(peer, msg);
+			break;
+
+		case QID_LOGIN_BY_KEY:
+			RESULT_LOGIN_BY_KEY(peer, msg);
+			break;
+
+			// MYSHOP_PRICE_LIST
+		case QID_ITEMPRICE_LOAD:
+			RESULT_PRICELIST_LOAD(peer, msg);
+			break;
+			// END_OF_MYSHOP_PRICE_LIST
+
+		default:
+			sys_log(0, "CClientManager::AnalyzeQueryResult unknown query result type: %d, str: %s", qi->iType, msg->stQuery.c_str());
+			break;
+	}
+
+	delete qi;
+	return true;
+}
+
+void UsageLog()
+{
+	FILE* fp = NULL;
+
+	time_t ct;
+	char* time_s;
+	struct tm lt;
+
+	int avg = g_dwUsageAvg / 3600; // 60  * 60 
+
+	fp = fopen("usage.txt", "a+");
+
+	if (!fp)
+		return;
+
+	ct = time(0);
+	lt = *localtime(&ct);
+	time_s = asctime(&lt);
+
+	time_s[strlen(time_s) - 1] = '\0';
+
+	fprintf(fp, "| %4d %-15.15s | %5d | %5u |", lt.tm_year + 1900, time_s + 4, avg, g_dwUsageMax);
+
+	fprintf(fp, "\n");
+	fclose(fp);
+
+	g_dwUsageMax = g_dwUsageAvg = 0;
+}
+
+int CClientManager::Process()
+{
+	int pulses;
+
+	if (!(pulses = thecore_idle()))
+		return 0;
+
+	while (pulses--)
+	{
+		++thecore_heart->pulse;
+
+		/*
+		// 30龜 
+		if (((thecore_pulse() % (60 * 30 * 10)) == 0))
+		{
+			g_iPlayerCacheFlushSeconds = MAX(60, rand() % 180);
+			g_iItemCacheFlushSeconds = MAX(60, rand() % 180);
+			sys_log(0, "[SAVE_TIME]Change saving time item %d player %d", g_iPlayerCacheFlushSeconds, g_iItemCacheFlushSeconds);
+		}
+		*/
+
+		if (!(thecore_heart->pulse % thecore_heart->passes_per_sec))
+		{
+			if (g_test_server)
+			{
+				if (!(thecore_heart->pulse % thecore_heart->passes_per_sec * 10))
+
+				{
+					pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d/%d",
+						thecore_heart->pulse,
+						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+						CDBManager::instance().CountReturnResult(SQL_PLAYER),
+						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+						CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
+						CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
+
+					if ((thecore_heart->pulse % 50) == 0)
+						sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
+							thecore_heart->pulse,
+							CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+							CDBManager::instance().CountReturnResult(SQL_PLAYER),
+							CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+							CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+							CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+							CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
+				}
+			}
+			else
+			{
+				pt_log("[%9d] return %d/%d/%d/%d async %d/%d/%d%/%d",
+					thecore_heart->pulse,
+					CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+					CDBManager::instance().CountReturnResult(SQL_PLAYER),
+					CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+					CDBManager::instance().CountReturnCopiedQuery(SQL_PLAYER),
+					CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+					CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+					CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER),
+					CDBManager::instance().CountAsyncCopiedQuery(SQL_PLAYER));
+
+				if ((thecore_heart->pulse % 50) == 0)
+					sys_log(0, "[%9d] return %d/%d/%d async %d/%d/%d",
+						thecore_heart->pulse,
+						CDBManager::instance().CountReturnQuery(SQL_PLAYER),
+						CDBManager::instance().CountReturnResult(SQL_PLAYER),
+						CDBManager::instance().CountReturnQueryFinished(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQuery(SQL_PLAYER),
+						CDBManager::instance().CountAsyncResult(SQL_PLAYER),
+						CDBManager::instance().CountAsyncQueryFinished(SQL_PLAYER));
+			}
+
+			CDBManager::instance().ResetCounter();
+
+			DWORD dwCount = CClientManager::instance().GetUserCount();
+
+			g_dwUsageAvg += dwCount;
+			g_dwUsageMax = MAX(g_dwUsageMax, dwCount);
+
+			memset(&thecore_profiler[0], 0, sizeof(thecore_profiler));
+
+#if defined(__EXPRESSING_EMOTIONS__)
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iEmoteDumpDelay)))
+				CClientManager::instance().QUERY_EMOTE_DUMP();
+#endif
+
+#if defined(__MAILBOX__)
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iMailBoxBackupSec)))
+				CClientManager::instance().MAILBOX_BACKUP();
+#endif
+
+#if defined(__GEM_SHOP__)
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * m_iGemShopFlushDelay)))
+				CClientManager::instance().FlushGemShop();
+#endif
+
+			if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600)))
+				UsageLog();
+
+			m_iCacheFlushCount = 0;
+
+			// 첨潔 첨
+			UpdatePlayerCache();
+			//  첨
+			UpdateItemCache();
+			//慣類틸 처- 캐 첨
+			UpdateLogoutPlayer();
+
+			// MYSHOP_PRICE_LIST
+			UpdateItemPriceListCache();
+			// END_OF_MYSHOP_PRICE_LIST
+#ifdef __OFFLINE_SHOP__
+			UpdateOfflineShopCache();
+			UpdateOfflineShopItemCache();
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+			UpdateGrowthPetCache();
+#endif
+			CGuildManager::instance().Update();
+			CPrivManager::instance().Update();
+			marriage::CManager::instance().Update();
+#ifdef __SHOP_SEARCH__
+			CShopSearchManager::Instance().Update();
+#endif
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 5)))
+		{
+			ItemAwardManager::instance().RequestLoad();
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 10)))
+		{
+			/*
+			char buf[4096 + 1];
+			int len
+
+			/////////////////////////////////////////////////////////////////
+			buf[0] = '\0';
+			len = 0;
+
+			auto it = g_query_info.m_map_info.begin();
+
+			int count = 0;
+
+			while (it != g_query_info.m_map_info.end())
+			{
+				len += snprintf(buf + len, sizeof(buf) - len, "%2d %3d\n", it->first, it->second);
+				count += it->second;
+				it++;
+			}
+
+			pt_log("QUERY:\n%s-------------------- MAX : %d\n", buf, count);
+			g_query_info.Reset();
+			*/
+			pt_log("QUERY: MAIN[%d] ASYNC[%d]", g_query_count[0], g_query_count[1]);
+			g_query_count[0] = 0;
+			g_query_count[1] = 0;
+			/////////////////////////////////////////////////////////////////
+
+			/////////////////////////////////////////////////////////////////
+			/*
+			buf[0] = '\0';
+			len = 0;
+
+			it = g_item_info.m_map_info.begin();
+
+			count = 0;
+			while (it != g_item_info.m_map_info.end())
+			{
+				len += snprintf(buf + len, sizeof(buf) - len, "%5d %3d\n", it->first, it->second);
+				count += it->second;
+				it++;
+			}
+
+			pt_log("ITEM:\n%s-------------------- MAX : %d\n", buf, count);
+			g_item_info.Reset();
+			*/
+			pt_log("ITEM:%d\n", g_item_count);
+			g_item_count = 0;
+			/////////////////////////////////////////////////////////////////
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60))) // 60却 箕
+		{
+			// 크   챨 .
+			CClientManager::instance().SendTime();
+		}
+
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 3600))) // 耆챨 箕
+		{
+			CMoneyLog::instance().Save();
+		}
+
+#if defined(__ENVIRONMENT_SYSTEM__)
+		static bool OnSetup = true;
+		if (!(thecore_heart->pulse % (thecore_heart->passes_per_sec * 60 * 20)) || OnSetup)
+		{
+			UpdateEnvironment();
+			OnSetup = false;
+		}
+#endif
+	}
+
+	int num_events = fdwatch(m_fdWatcher, 0);
+	int idx;
+	CPeer* peer;
+
+	for (idx = 0; idx < num_events; ++idx) // 풋
+	{
+		peer = (CPeer*)fdwatch_get_client_data(m_fdWatcher, idx);
+
+		if (!peer)
+		{
+			if (fdwatch_check_event(m_fdWatcher, m_fdAccept, idx) == FDW_READ)
+			{
+				AddPeer(m_fdAccept);
+				fdwatch_clear_event(m_fdWatcher, m_fdAccept, idx);
+			}
+			else
+			{
+				sys_log(0, "FDWATCH: peer null in event: ident %d", fdwatch_get_ident(m_fdWatcher, idx));
+			}
+
+			continue;
+		}
+
+		switch (fdwatch_check_event(m_fdWatcher, peer->GetFd(), idx))
+		{
+			case FDW_READ:
+				if (peer->Recv() < 0)
+				{
+					sys_err("Recv failed");
+					RemovePeer(peer);
+				}
+				else
+				{
+					if (peer == m_pkAuthPeer)
+						if (g_log)
+							sys_log(0, "AUTH_PEER_READ: size %d", peer->GetRecvLength());
+
+					ProcessPackets(peer);
+				}
+				break;
+
+			case FDW_WRITE:
+				if (peer == m_pkAuthPeer)
+					if (g_log)
+						sys_log(0, "AUTH_PEER_WRITE: size %d", peer->GetSendLength());
+
+				if (peer->Send() < 0)
+				{
+					sys_err("Send failed");
+					RemovePeer(peer);
+				}
+
+				break;
+
+			case FDW_EOF:
+				RemovePeer(peer);
+				break;
+
+			default:
+				sys_err("fdwatch_check_fd returned unknown result");
+				RemovePeer(peer);
+				break;
+		}
+	}
+
+#ifdef __WIN32__
+	if (_kbhit())
+	{
+		int c = _getch();
+		switch (c)
+		{
+			case 0x1b: // Esc
+				return 0; // shutdown
+				break;
+			default:
+				break;
+		}
+	}
+#endif
+
+	return 1;
+}
+
+DWORD CClientManager::GetUserCount()
+{
+	// 秉 慣 카트 .. --;
+	return m_map_kLogonAccount.size();
+}
+
+void CClientManager::SendAllGuildSkillRechargePacket()
+{
+	ForwardPacket(HEADER_DG_GUILD_SKILL_RECHARGE, NULL, 0);
+}
+
+void CClientManager::SendTime()
+{
+	time_t now = GetCurrentTime();
+	ForwardPacket(HEADER_DG_TIME, &now, sizeof(time_t));
+}
+
+void CClientManager::ForwardPacket(BYTE header, const void* data, int size, BYTE bChannel, CPeer* except)
+{
+	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* peer = *it;
+
+		if (peer == except)
+			continue;
+
+		if (!peer->GetChannel())
+			continue;
+
+		if (bChannel && peer->GetChannel() != bChannel)
+			continue;
+
+		peer->EncodeHeader(header, 0, size);
+
+		if (size > 0 && data)
+			peer->Encode(data, size);
+	}
+}
+
+void CClientManager::SendNotice(const char* c_pszFormat, ...)
+{
+	char szBuf[255 + 1];
+	va_list args;
+
+	va_start(args, c_pszFormat);
+	int len = vsnprintf(szBuf, sizeof(szBuf), c_pszFormat, args);
+	va_end(args);
+	szBuf[len] = '\0';
+
+	ForwardPacket(HEADER_DG_NOTICE, szBuf, len + 1);
+}
+
+time_t CClientManager::GetCurrentTime()
+{
+	return time(0);
+}
+
+// ITEM_UNIQUE_ID
+bool CClientManager::InitializeNowItemID()
+{
+	DWORD dwMin, dwMax;
+
+	//  ID 珂화 磯.
+	if (!CConfig::instance().GetTwoValue("ITEM_ID_RANGE", &dwMin, &dwMax))
+	{
+		sys_err("config.txt: Cannot find ITEM_ID_RANGE [start_item_id] [end_item_id]");
+		return false;
+	}
+
+	sys_log(0, "ItemRange From File %u ~ %u ", dwMin, dwMax);
+
+	if (CItemIDRangeManager::instance().BuildRange(dwMin, dwMax, m_itemRange) == false)
+	{
+		sys_err("Can not build ITEM_ID_RANGE");
+		return false;
+	}
+
+	sys_log(0, " Init Success Start %u End %u Now %u\n", m_itemRange.dwMin, m_itemRange.dwMax, m_itemRange.dwUsableItemIDMin);
+
+	return true;
+}
+
+DWORD CClientManager::GainItemID()
+{
+	return m_itemRange.dwUsableItemIDMin++;
+}
+
+DWORD CClientManager::GetItemID()
+{
+	return m_itemRange.dwUsableItemIDMin;
+}
+// ITEM_UNIQUE_ID_END
+
+// BOOT_LOCALIZATION
+bool CClientManager::InitializeLocalization()
+{
+	char szQuery[512];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `mValue`, `mKey` FROM `locale`");
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
+
+	if (pMsg->Get()->uiNumRows == 0)
+	{
+		sys_err("InitializeLocalization() ==> DirectQuery failed(%s)", szQuery);
+		delete pMsg;
+		return false;
+	}
+
+	sys_log(0, "InitializeLocalization() - LoadLocaleTable(count:%d)", pMsg->Get()->uiNumRows);
+
+	m_vec_Locale.clear();
+
+	MYSQL_ROW row = NULL;
+
+	for (; (row = mysql_fetch_row(pMsg->Get()->pSQLResult)) != NULL;)
+	{
+		int col = 0;
+		tLocale locale;
+
+		strlcpy(locale.szValue, row[col++], sizeof(locale.szValue));
+		strlcpy(locale.szKey, row[col++], sizeof(locale.szKey));
+
+		// DB_NAME_COLUMN Setting
+		if (strcmp(locale.szKey, "LOCALE") == 0)
+		{
+			if (strcmp(locale.szValue, "cibn") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
+
+				g_stLocale = "gb2312";
+				g_stLocaleNameColumn = "gb2312name";
+			}
+			else if (strcmp(locale.szValue, "ymir") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "euckr";
+				g_stLocaleNameColumn = "name";
+			}
+			else if (strcmp(locale.szValue, "japan") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "sjis");
+
+				g_stLocale = "sjis";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "english") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "germany") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "france") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "italy") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "spain") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "uk") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "turkey") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin5";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "poland") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "portugal") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "hongkong") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
+
+				g_stLocale = "big5";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "newcibn") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "gb2312");
+
+				g_stLocale = "gb2312";
+				g_stLocaleNameColumn = "gb2312name";
+			}
+			else if (strcmp(locale.szValue, "korea") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "euckr";
+				g_stLocaleNameColumn = "name";
+			}
+			else if (strcmp(locale.szValue, "canada") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "gb2312name";
+			}
+			else if (strcmp(locale.szValue, "brazil") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "greek") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "greek";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "russia") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "cp1251";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "denmark") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "bulgaria") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "cp1251";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "croatia") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "cp1251";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "mexico") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "arabia") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "cp1256";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "czech") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "hungary") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "romania") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin2";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "netherlands") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "singapore") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "vietnam") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "thailand") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "usa") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "we_korea") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "euckr");
+
+				g_stLocale = "euckr";
+				g_stLocaleNameColumn = "name";
+			}
+			else if (strcmp(locale.szValue, "taiwan") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "big5");
+				g_stLocale = "big5";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else if (strcmp(locale.szValue, "europe") == 0)
+			{
+				sys_log(0, "locale[LOCALE] = %s", locale.szValue);
+
+				if (g_stLocale != locale.szValue)
+					sys_log(0, "Changed g_stLocale %s to %s", g_stLocale.c_str(), "latin1");
+
+				g_stLocale = "latin1";
+				g_stLocaleNameColumn = "locale_name";
+			}
+			else
+			{
+				sys_err("locale[LOCALE] = UNKNOWN(%s)", locale.szValue);
+				exit(0);
+			}
+
+			CDBManager::instance().SetLocale(g_stLocale.c_str());
+		}
+		else if (strcmp(locale.szKey, "DB_NAME_COLUMN") == 0)
+		{
+			sys_log(0, "locale[DB_NAME_COLUMN] = %s", locale.szValue);
+			g_stLocaleNameColumn = locale.szValue;
+		}
+		else
+		{
+			sys_log(0, "locale[UNKNOWN_KEY(%s)] = %s", locale.szKey, locale.szValue);
+		}
+		m_vec_Locale.push_back(locale);
+	}
+
+	delete pMsg;
+
+	return true;
+}
+// END_BOOT_LOCALIZATION
+
+// ADMIN_MANAGER
+bool CClientManager::__GetAdminInfo(const char* szIP, std::vector<tAdminInfo>& rAdminVec)
+{
+	// szIP == NULL 構 煐 楮  쨈.
+	char szQuery[512];
+	snprintf(szQuery, sizeof(szQuery),
+		"SELECT `mID`, `mAccount`, `mName`, `mContactIP`, `mServerIP`, `mAuthority` FROM `gmlist` WHERE `mServerIP` = 'ALL' OR `mServerIP` = '%s'",
+		szIP ? szIP : "ALL");
+
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
+
+	if (pMsg->Get()->uiNumRows == 0)
+	{
+		sys_err("__GetAdminInfo() ==> DirectQuery failed(%s)", szQuery);
+		delete pMsg;
+		return false;
+	}
+
+	MYSQL_ROW row;
+	rAdminVec.reserve(pMsg->Get()->uiNumRows);
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		int idx = 0;
+		tAdminInfo Info;
+
+		str_to_number(Info.m_ID, row[idx++]);
+		trim_and_lower(row[idx++], Info.m_szAccount, sizeof(Info.m_szAccount));
+		strlcpy(Info.m_szName, row[idx++], sizeof(Info.m_szName));
+		strlcpy(Info.m_szContactIP, row[idx++], sizeof(Info.m_szContactIP));
+		strlcpy(Info.m_szServerIP, row[idx++], sizeof(Info.m_szServerIP));
+		std::string stAuth = row[idx++];
+
+		if (!stAuth.compare("IMPLEMENTOR"))
+			Info.m_Authority = GM_IMPLEMENTOR;
+		else if (!stAuth.compare("GOD"))
+			Info.m_Authority = GM_GOD;
+		else if (!stAuth.compare("HIGH_WIZARD"))
+			Info.m_Authority = GM_HIGH_WIZARD;
+		else if (!stAuth.compare("LOW_WIZARD"))
+			Info.m_Authority = GM_LOW_WIZARD;
+		else if (!stAuth.compare("WIZARD"))
+			Info.m_Authority = GM_WIZARD;
+		else
+			continue;
+
+		rAdminVec.push_back(Info);
+
+		sys_log(0, "GM: PID %u Login %s Character %s ContactIP %s ServerIP %s Authority %d[%s]",
+			Info.m_ID, Info.m_szAccount, Info.m_szName, Info.m_szContactIP, Info.m_szServerIP, Info.m_Authority, stAuth.c_str());
+	}
+
+	delete pMsg;
+
+	return true;
+}
+
+bool CClientManager::__GetHostInfo(std::vector<std::string>& rIPVec)
+{
+	char szQuery[512];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `mIP` FROM `gmhost`");
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_COMMON);
+
+	if (pMsg->Get()->uiNumRows == 0)
+	{
+		sys_err("__GetHostInfo() ==> DirectQuery failed(%s)", szQuery);
+		delete pMsg;
+		return false;
+	}
+
+	rIPVec.reserve(pMsg->Get()->uiNumRows);
+
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+	{
+		if (row[0] && *row[0])
+		{
+			rIPVec.push_back(row[0]);
+			sys_log(0, "GMHOST: %s", row[0]);
+		}
+	}
+
+	delete pMsg;
+	return true;
+}
+// END_ADMIN_MANAGER
+
+void CClientManager::ReloadAdmin(CPeer*, TPacketReloadAdmin* p)
+{
+	std::vector<tAdminInfo> vAdmin;
+	std::vector<std::string> vHost;
+
+	__GetHostInfo(vHost);
+	__GetAdminInfo(p->szIP, vAdmin);
+
+	DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(tAdminInfo) * vAdmin.size() +
+		sizeof(WORD) + sizeof(WORD) + 16 * vHost.size();
+
+	//for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* peer = *it;
+
+		if (!peer->GetChannel())
+			continue;
+
+		peer->EncodeHeader(HEADER_DG_RELOAD_ADMIN, 0, dwPacketSize);
+
+		peer->EncodeWORD(16);
+		peer->EncodeWORD(static_cast<WORD>(vHost.size()));
+
+		for (size_t n = 0; n < vHost.size(); ++n)
+			peer->Encode(vHost[n].c_str(), 16);
+
+		peer->EncodeWORD(sizeof(tAdminInfo));
+		peer->EncodeWORD(static_cast<WORD>(vAdmin.size()));
+
+		for (size_t n = 0; n < vAdmin.size(); ++n)
+			peer->Encode(&vAdmin[n], sizeof(tAdminInfo));
+	}
+
+	sys_log(0, "ReloadAdmin End %s", p->szIP);
+}
+
+// BREAK_MARRIAGE
+void CClientManager::BreakMarriage(CPeer* peer, const char* data)
+{
+	DWORD pid1, pid2;
+
+	pid1 = *(int*)data;
+	data += sizeof(int);
+
+	pid2 = *(int*)data;
+	data += sizeof(int);
+
+	sys_log(0, "Breaking off a marriage engagement! pid %d and pid %d", pid1, pid2);
+	marriage::CManager::instance().Remove(pid1, pid2);
+}
+// END_BREAK_MARIIAGE
+
+void CClientManager::UpdateItemCacheSet(DWORD pid)
+{
+	auto it = m_map_pkItemCacheSetPtr.find(pid);
+	if (it == m_map_pkItemCacheSetPtr.end())
+	{
+		if (g_test_server)
+			sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCacheSet ==> No ItemCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TItemCacheSet* pSet = it->second;
+	TItemCacheSet::iterator it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CItemCache* c = *it_set++;
+		c->Flush();
+	}
+
+	if (g_log)
+		sys_log(0, "UPDATE_ITEMCACHESET : UpdateItemCachsSet pid(%d)", pid);
+}
+
+void CClientManager::Election(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	DWORD idx;
+	DWORD selectingpid;
+
+	idx = *(DWORD*)data;
+	data += sizeof(DWORD);
+
+	selectingpid = *(DWORD*)data;
+	data += sizeof(DWORD);
+
+	int Success = 0;
+
+	if (!(Success = CMonarch::instance().VoteMonarch(selectingpid, idx)))
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_VOTE] Failed %d %d", idx, selectingpid);
+		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
+		peer->Encode(&Success, sizeof(int));
+		return;
+	}
+	else
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_VOTE] Success %d %d", idx, selectingpid);
+		peer->EncodeHeader(HEADER_DG_ELECT_MONARCH, dwHandle, sizeof(int));
+		peer->Encode(&Success, sizeof(int));
+		return;
+	}
+
+}
+
+void CClientManager::Candidacy(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	DWORD pid;
+
+	pid = *(DWORD*)data;
+	data += sizeof(DWORD);
+
+	if (!CMonarch::instance().AddCandidacy(pid, data))
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_CANDIDACY] Failed %d %s", pid, data);
+
+		peer->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
+		peer->Encode(0, sizeof(int));
+		peer->Encode(data, 32);
+		return;
+	}
+	else
+	{
+		if (g_test_server)
+			sys_log(0, "[MONARCH_CANDIDACY] Success %d %s", pid, data);
+
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (0 && p->GetChannel() != 0)
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_CANDIDACY, dwHandle, sizeof(int) + 32);
+				p->Encode(&pid, sizeof(int));
+				p->Encode(data, 32);
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_CANDIDACY, 0, sizeof(int) + 32);
+				p->Encode(&pid, sizeof(int));
+				p->Encode(data, 32);
+			}
+		}
+	}
+}
+
+void CClientManager::AddMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH] Add money Empire(%d) Money(%d)", Empire, Money);
+
+	CMonarch::instance().AddMoney(Empire, Money);
+
+	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* p = *it;
+
+		if (!p->GetChannel())
+			continue;
+
+		if (p == peer)
+		{
+			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+		else
+		{
+			p->EncodeHeader(HEADER_DG_ADD_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+
+	}
+}
+
+void CClientManager::DecMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH] Dec money Empire(%d) Money(%d)", Empire, Money);
+
+	CMonarch::instance().DecMoney(Empire, Money);
+
+	// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* p = *it;
+
+		if (!p->GetChannel())
+			continue;
+
+		if (p == peer)
+		{
+			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+		else
+		{
+			p->EncodeHeader(HEADER_DG_DEC_MONARCH_MONEY, 0, sizeof(int) + sizeof(int));
+			p->Encode(&Empire, sizeof(int));
+			p->Encode(&Money, sizeof(int));
+		}
+	}
+}
+
+void CClientManager::TakeMonarchMoney(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	int Empire = *(int*)data;
+	data += sizeof(int);
+
+	DWORD pid = *(DWORD*)data;
+	data += sizeof(int);
+
+	int Money = *(int*)data;
+	data += sizeof(int);
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH] Take money Empire(%d) Money(%d)", Empire, Money);
+
+	if (CMonarch::instance().TakeMoney(Empire, pid, Money) == true)
+	{
+		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+		peer->Encode(&Empire, sizeof(int));
+		peer->Encode(&Money, sizeof(int));
+	}
+	else
+	{
+		Money = 0;
+		peer->EncodeHeader(HEADER_DG_TAKE_MONARCH_MONEY, dwHandle, sizeof(int) + sizeof(int));
+		peer->Encode(&Empire, sizeof(int));
+		peer->Encode(&Money, sizeof(int));
+	}
+}
+
+void CClientManager::ComeToVote(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	CMonarch::instance().ElectMonarch();
+}
+
+void CClientManager::RMCandidacy(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	char szName[32];
+
+	strlcpy(szName, data, sizeof(szName));
+	sys_log(0, "[MONARCH_GM] Remove candidacy name(%s)", szName);
+
+	int iRet = CMonarch::instance().DelCandidacy(szName) ? 1 : 0;
+
+	if (1 == iRet)
+	{
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+		}
+	}
+	else
+	{
+		CPeer* p = peer;
+		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+		p->Encode(&iRet, sizeof(int));
+		p->Encode(szName, sizeof(szName));
+	}
+}
+
+void CClientManager::SetMonarch(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	char szName[32];
+
+	strlcpy(szName, data, sizeof(szName));
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH_GM] Set Monarch name(%s)", szName);
+
+	int iRet = CMonarch::instance().SetMonarch(szName) ? 1 : 0;
+
+	if (1 == iRet)
+	{
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+		}
+	}
+	else
+	{
+		CPeer* p = peer;
+		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+		p->Encode(&iRet, sizeof(int));
+		p->Encode(szName, sizeof(szName));
+	}
+}
+
+void CClientManager::RMMonarch(CPeer* peer, DWORD dwHandle, const char* data)
+{
+	char szName[32];
+
+	strlcpy(szName, data, sizeof(szName));
+
+	if (g_test_server)
+		sys_log(0, "[MONARCH_GM] Remove Monarch name(%s)", szName);
+
+	CMonarch::instance().DelMonarch(szName);
+
+	int iRet = CMonarch::instance().DelMonarch(szName) ? 1 : 0;
+
+	if (1 == iRet)
+	{
+		// for (TPeerList::const_iterator it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+		{
+			CPeer* p = *it;
+
+			if (!p->GetChannel())
+				continue;
+
+			if (p == peer)
+			{
+				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+			else
+			{
+				p->EncodeHeader(HEADER_DG_RMMONARCH, dwHandle, sizeof(int) + sizeof(szName));
+				p->Encode(&iRet, sizeof(int));
+				p->Encode(szName, sizeof(szName));
+			}
+		}
+	}
+	else
+	{
+		CPeer* p = peer;
+		p->EncodeHeader(HEADER_DG_RMCANDIDACY, dwHandle, sizeof(int) + sizeof(szName));
+		p->Encode(&iRet, sizeof(int));
+		p->Encode(szName, sizeof(szName));
+	}
+}
+
+void CClientManager::ChangeMonarchLord(CPeer* peer, DWORD dwHandle, TPacketChangeMonarchLord* info)
+{
+	char szQuery[1024];
+	snprintf(szQuery, sizeof(szQuery),
+		"SELECT a.`name`, NOW() FROM player%s AS a, player_index%s AS b WHERE (a.`account_id` = b.`id` AND a.`id` = %u AND b.`empire` = %u) AND "
+		"(b.`pid1` = %u OR "
+		"b.`pid2` = %u OR "
+		"b.`pid3` = %u OR "
+		"b.`pid4` = %u"
+#if defined(__PLAYER_PER_ACCOUNT5__)
+		" OR b.`pid5` = %u"
+#endif
+		")",
+		GetTablePostfix(),
+		GetTablePostfix(),
+		info->dwPID,
+		info->bEmpire,
+		info->dwPID,
+		info->dwPID,
+		info->dwPID,
+		info->dwPID
+#if defined(__PLAYER_PER_ACCOUNT5__)
+		, info->dwPID
+#endif
+	);
+
+	SQLMsg* pMsg = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
+
+	if (pMsg->Get()->uiNumRows != 0)
+	{
+		TPacketChangeMonarchLordACK ack;
+		ack.bEmpire = info->bEmpire;
+		ack.dwPID = info->dwPID;
+
+		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+		strlcpy(ack.szName, row[0], sizeof(ack.szName));
+		strlcpy(ack.szDate, row[1], sizeof(ack.szDate));
+
+		snprintf(szQuery, sizeof(szQuery), "UPDATE `monarch` SET `pid` = %u, `windate` = NOW() WHERE `empire` = %d", ack.dwPID, ack.bEmpire);
+		SQLMsg* pMsg2 = CDBManager::instance().DirectQuery(szQuery, SQL_PLAYER);
+
+		if (pMsg2->Get()->uiAffectedRows > 0)
+		{
+			CMonarch::instance().LoadMonarch();
+
+			TMonarchInfo* newInfo = CMonarch::instance().GetMonarch();
+
+			for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+			{
+				CPeer* client = *it;
+
+				client->EncodeHeader(HEADER_DG_CHANGE_MONARCH_LORD_ACK, 0, sizeof(TPacketChangeMonarchLordACK));
+				client->Encode(&ack, sizeof(TPacketChangeMonarchLordACK));
+
+				client->EncodeHeader(HEADER_DG_UPDATE_MONARCH_INFO, 0, sizeof(TMonarchInfo));
+				client->Encode(newInfo, sizeof(TMonarchInfo));
+			}
+		}
+
+		delete pMsg2;
+	}
+
+	delete pMsg;
+}
+
+void CClientManager::BlockException(TPacketBlockException* data)
+{
+	sys_log(0, "[BLOCK_EXCEPTION] CMD(%d) login(%s)", data->cmd, data->login);
+
+	char login[LOGIN_MAX_LEN + 1] = {0};
+	trim_and_lower(data->login, login, sizeof(login));
+
+	char loginEsc[LOGIN_MAX_LEN * 2 + 1] = {0};
+	CDBManager::instance().EscapeString(loginEsc, login, strlen(login), SQL_ACCOUNT);
+
+	// save sql
+	{
+		char buf[1024];
+
+		switch (data->cmd)
+		{
+			case BLOCK_EXCEPTION_CMD_ADD:
+				snprintf(buf, sizeof(buf),
+					"INSERT INTO `block_exception` (`login`) VALUES ('%s')",
+					loginEsc);
+				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
+				CBlockCountry::instance().AddBlockException(login);
+				break;
+			case BLOCK_EXCEPTION_CMD_DEL:
+				snprintf(buf, sizeof(buf),
+					"DELETE FROM `block_exception` WHERE `login` = '%s'",
+					loginEsc);
+				CDBManager::instance().AsyncQuery(buf, SQL_ACCOUNT);
+				CBlockCountry::instance().DelBlockException(login);
+				break;
+			default:
+				return;
+		}
+
+	}
+
+	for (auto it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		CPeer* peer = *it;
+
+		if (!peer->GetChannel())
+			continue;
+
+		CBlockCountry::instance().SendBlockExceptionOne(peer, login, data->cmd);
+	}
+}
+
+void CClientManager::SendSpareItemIDRange(CPeer* peer)
+{
+	peer->SendSpareItemIDRange();
+}
+
+//
+// Login Key 却 .
+//
+void CClientManager::DeleteLoginKey(TPacketDC* data)
+{
+	char login[LOGIN_MAX_LEN + 1] = { 0 };
+	trim_and_lower(data->login, login, sizeof(login));
+
+	CLoginData* pkLD = GetLoginDataByLogin(login);
+
+	if (pkLD)
+	{
+		TLoginDataByLoginKey::iterator it = m_map_pkLoginData.find(pkLD->GetKey());
+
+		if (it != m_map_pkLoginData.end())
+			m_map_pkLoginData.erase(it);
+	}
+}
+
+// delete gift notify icon
+void CClientManager::DeleteAwardId(TPacketDeleteAwardID* data)
+{
+	// sys_log(0, "data from game server arrived %d", data->dwID);
+	std::map<DWORD, TItemAward*>::iterator it;
+	it = ItemAwardManager::Instance().GetMapAward().find(data->dwID);
+	if (it != ItemAwardManager::Instance().GetMapAward().end())
+	{
+		std::set<TItemAward*>& kSet = ItemAwardManager::Instance().GetMapkSetAwardByLogin()[it->second->szLogin];
+		if (kSet.erase(it->second))
+			sys_log(0, "erase ItemAward id: %d from cache", data->dwID);
+		ItemAwardManager::Instance().GetMapAward().erase(data->dwID);
+	}
+	else
+	{
+		sys_log(0, "DELETE_AWARDID : could not find the id: %d", data->dwID);
+	}
+}
+
+void CClientManager::UpdateChannelStatus(TChannelStatus* pData)
+{
+	TChannelStatusMap::iterator it = m_mChannelStatus.find(pData->nPort);
+	if (it != m_mChannelStatus.end())
+	{
+		it->second = pData->bStatus;
+	}
+	else
+	{
+		m_mChannelStatus.insert(TChannelStatusMap::value_type(pData->nPort, pData->bStatus));
+	}
+}
+
+void CClientManager::RequestChannelStatus(CPeer* peer, DWORD dwHandle)
+{
+	const int nSize = m_mChannelStatus.size();
+	peer->EncodeHeader(HEADER_DG_RESPOND_CHANNELSTATUS, dwHandle, sizeof(TChannelStatus) * nSize + sizeof(int));
+	peer->Encode(&nSize, sizeof(int));
+	for (TChannelStatusMap::iterator it = m_mChannelStatus.begin(); it != m_mChannelStatus.end(); ++it)
+	{
+		peer->Encode(&it->first, sizeof(short));
+		peer->Encode(&it->second, sizeof(BYTE));
+	}
+}
+
+void CClientManager::ResetLastPlayerID(const TPacketNeedLoginLogInfo* data)
+{
+	CLoginData* pkLD = GetLoginDataByAID(data->dwPlayerID);
+
+	if (NULL != pkLD)
+	{
+		pkLD->SetLastPlayerID(0);
+	}
+}
+
+void CClientManager::ChargeCash(const TRequestChargeCash* packet)
+{
+	char szQuery[512];
+
+	if (ERequestCharge_Cash == packet->eChargeType)
+		snprintf(szQuery, sizeof(szQuery), "update account set `cash` = `cash` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
+	else if (ERequestCharge_Mileage == packet->eChargeType)
+		snprintf(szQuery, sizeof(szQuery), "update account set `mileage` = `mileage` + %d where id = %d limit 1", packet->dwAmount, packet->dwAID);
+	else
+	{
+		sys_err("Invalid request charge type (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
+		return;
+	}
+
+	sys_err("Request Charge (type : %d, amount : %d, aid : %d)", packet->eChargeType, packet->dwAmount, packet->dwAID);
+
+	CDBManager::Instance().AsyncQuery(szQuery, SQL_ACCOUNT);
+}
+
+#if defined(__MOVE_CHANNEL__)
+void CClientManager::FindChannel(CPeer* requestPeer, DWORD dwHandle, TPacketChangeChannel* p)
+{
+	if (!p->lMapIndex || !p->iChannel)
+		return;
+
+	long lAddr = 0;
+	WORD wPort = 0;
+
+	// for (TPeerList::const_iterator i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	for (auto i = m_peerList.begin(); i != m_peerList.end(); ++i)
+	{
+		CPeer* peer = *i;
+		if (peer->GetChannel() != p->iChannel) // not the channel we are looking for!
+			continue;
+
+		TMapLocation kMapLocation;
+		thecore_memcpy(kMapLocation.alMaps, peer->GetMaps(), sizeof(kMapLocation.alMaps));
+		int iLen = sizeof(kMapLocation.alMaps) / sizeof(kMapLocation.alMaps[0]);
+
+		for (int i = 0; i < iLen; ++i)
+		{
+			if (kMapLocation.alMaps[i] == p->lMapIndex)
+			{
+				// Get host, and convert to int
+				char host[16];
+				strlcpy(host, peer->GetPublicIP(), sizeof(kMapLocation.szHost));
+				lAddr = inet_addr(host);
+
+				// Target port
+				wPort = peer->GetListenPort();
+
+				break;
+			}
+		}
+
+		if (lAddr && wPort) // We already obtained them
+			break;
+	}
+
+	TPacketReturnChannel r;
+	r.lAddr = lAddr;
+	r.wPort = wPort;
+
+	requestPeer->EncodeHeader(HEADER_DG_CHANNEL_RESULT, dwHandle, sizeof(r));
+	requestPeer->Encode(&r, sizeof(r));
+}
+#endif
+
+#if defined(__ENVIRONMENT_SYSTEM__)
+enum DayMode : BYTE { DAY, NIGHT };
+
+static BYTE GetDayMode(int Hour)
+{
+	if (Hour >= 6 && Hour <= 20)
+		return DayMode::DAY;
+	return DayMode::NIGHT;
+}
+
+static bool IsWinter(int Month)
+{
+	return (Month >= 11 || Month <= 0);
+}
+
+void CClientManager::UpdateEnvironment()
+{
+	time_t CurrentTime = time(nullptr);
+	tm* tm = localtime(&CurrentTime);
+
+	auto SendFlag = [&](const char* flag, BYTE val)
+		{
+			TEventFlagMap::const_iterator it = m_map_lEventFlag.find(flag);
+			if ((it != m_map_lEventFlag.end() && it->second == val) == false)
+			{
+				TPacketSetEventFlag p;
+				strlcpy(p.szFlagName, flag, sizeof(p.szFlagName));
+				p.lValue = val;
+				SetEventFlag(&p);
+			}
+		};
+
+	SendFlag("eclipse", GetDayMode(tm->tm_hour));
+	BOOL Winter = IsWinter(tm->tm_mon);
+	for (const auto& Flag : { "xmas_snow" })
+		SendFlag(Flag, Winter);
+}
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+void CClientManager::QUERY_EMOTE_LOAD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
+{
+	if (pTable == nullptr)
+		return;
+
+	TEmoteTableVector* pVec = nullptr;
+	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
+	if (it != m_map_kPlayerEmote.end())
+		pVec = &it->second;
+
+	if (pVec && !pVec->empty())
+	{
+		const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
+		pVec->erase(std::remove_if(pVec->begin(), pVec->end(),
+			[dwCurrentTime](const TPacketGDEmote& rkTable)
+			{
+				return dwCurrentTime > rkTable.dwDuration;
+			}
+		), pVec->end());
+	}
+
+	const WORD wSize = pVec ? static_cast<WORD>(pVec->size()) : 0;
+	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(TPacketGDEmote) * wSize;
+
+	pkPeer->EncodeHeader(HEADER_DG_EMOTE_LOAD, dwHandle, dwPacketSize);
+	pkPeer->EncodeWORD(sizeof(TPacketGDEmote));
+	pkPeer->EncodeWORD(wSize);
+	if (pVec && !pVec->empty())
+		pkPeer->Encode(&(*pVec)[0], sizeof(TPacketGDEmote) * wSize);
+}
+
+void CClientManager::QUERY_EMOTE_CLEAR(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
+{
+	if (pTable == nullptr)
+		return;
+
+	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
+	if (it != m_map_kPlayerEmote.end())
+		it->second.clear();
+
+	QUERY_EMOTE_LOAD(pkPeer, dwHandle, pTable);
+}
+
+void CClientManager::QUERY_EMOTE_ADD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable)
+{
+	if (!pkPeer || !pTable)
+		return;
+
+	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
+
+	TPacketGDEmote GDPacket;
+	GDPacket.dwPID = pTable->dwPID;
+	GDPacket.dwVnum = pTable->dwVnum;
+	GDPacket.dwDuration = dwCurrentTime + pTable->dwDuration;
+
+	TPlayerEmoteMap::iterator it = m_map_kPlayerEmote.find(pTable->dwPID);
+	if (it != m_map_kPlayerEmote.end())
+	{
+		TEmoteTableVector& rkVec = it->second;
+		if (rkVec.size() >= SPECIAL_ACTION_SLOT_COUNT)
+		{
+			TPacketGDEmote& rkTable = rkVec[number(0, rkVec.size() - 1)];
+			if (dwCurrentTime >= rkTable.dwDuration)
+				rkTable.dwDuration = dwCurrentTime + pTable->dwDuration;
+			else
+				rkTable.dwDuration += pTable->dwDuration;
+
+			GDPacket.dwVnum = rkTable.dwVnum;
+			GDPacket.dwDuration = rkTable.dwDuration;
+		}
+		else
+		{
+			TEmoteTableVector::iterator itVec = std::find_if(rkVec.begin(), rkVec.end(),
+				[pTable](const TPacketGDEmote& rkTable)
+				{
+					return rkTable.dwVnum == pTable->dwVnum;
+				});
+
+			if (itVec != rkVec.end())
+			{
+				if (dwCurrentTime >= itVec->dwDuration)
+					itVec->dwDuration = dwCurrentTime + pTable->dwDuration;
+				else
+					itVec->dwDuration += pTable->dwDuration;
+
+				GDPacket.dwDuration = itVec->dwDuration;
+			}
+			else
+			{
+				pTable->dwDuration = GDPacket.dwDuration;
+				rkVec.emplace_back(*pTable);
+			}
+		}
+	}
+	else
+	{
+		pTable->dwDuration = GDPacket.dwDuration;
+		m_map_kPlayerEmote[pTable->dwPID].emplace_back(*pTable);
+	}
+
+	pkPeer->EncodeHeader(HEADER_DG_EMOTE_GET, dwHandle, sizeof(GDPacket));
+	pkPeer->Encode(&GDPacket, sizeof(GDPacket));
+}
+
+void CClientManager::QUERY_EMOTE_DUMP()
+{
+	CDBManager::instance().DirectQuery("TRUNCATE TABLE `player`.`emotions`");
+
+	if (m_map_kPlayerEmote.empty())
+		return;
+
+	char szQuery[1024];
+	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
+
+	for (TPlayerEmoteMap::value_type& it : m_map_kPlayerEmote)
+	{
+		TEmoteTableVector& rkVec = it.second;
+		if (rkVec.empty())
+			continue;
+
+		rkVec.erase(std::remove_if(rkVec.begin(), rkVec.end(),
+			[dwCurrentTime](const TPacketGDEmote& rkTable)
+			{
+				return dwCurrentTime > rkTable.dwDuration;
+			}
+		), rkVec.end());
+
+		for (const TPacketGDEmote& rkTable : rkVec)
+		{
+			snprintf(szQuery, sizeof(szQuery),
+				"REPLACE INTO emotions%s (`pid`, `vnum`, `duration`) VALUES(%d, %d, FROM_UNIXTIME(%d))",
+				GetTablePostfix(), rkTable.dwPID, rkTable.dwVnum, rkTable.dwDuration
+			);
+
+			std::unique_ptr<SQLMsg> pkInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+}
+#endif
+
+#if defined(__MAILBOX__)
+void CClientManager::QUERY_MAILBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	if (g_log)
+		sys_log(0, "QUERY_MAILBOX (handle: %d ch: %s)", dwHandle, p->szName);
+
+	std::vector<SMailBoxTable>* vec = nullptr;
+	auto it = m_map_mailbox.find(p->szName);
+	if (it != m_map_mailbox.end())
+		vec = &it->second;
+
+	if (vec)
+	{
+		const time_t now = std::time(nullptr);
+
+		vec->erase(std::remove_if(vec->begin(), vec->end(),
+			[now](const TMailBoxTable& mail)
+			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
+		), vec->end());
+
+		std::sort(vec->begin(), vec->end(),
+			[](const TMailBoxTable& l, const TMailBoxTable& r)
+			{
+				return l.Message.SendTime > r.Message.SendTime;
+			});
+	}
+
+	const WORD size = vec ? static_cast<WORD>(vec->size()) : 0;
+	const DWORD dwPacketSize = sizeof(WORD) + sizeof(WORD) + sizeof(SMailBoxTable) * size;
+
+	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_LOAD, dwHandle, dwPacketSize);
+	pkPeer->EncodeWORD(sizeof(SMailBoxTable));
+	pkPeer->EncodeWORD(size);
+
+	if (vec && vec->empty() == false)
+		pkPeer->Encode(&(*vec)[0], sizeof(SMailBoxTable) * size);
+}
+
+void CClientManager::QUERY_MAILBOX_CHECK_NAME(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	TMailBox t;
+	std::memcpy(t.szName, "", sizeof(t.szName));
+	t.Index = 0; // Index: Mail Count
+
+	static std::unordered_set<std::string> NameSet;
+	bool bFound = NameSet.find(p->szName) != NameSet.end();
+
+	if (bFound == false)
+	{
+		char escName[sizeof(p->szName) * 2 + 1];
+		const size_t nameLen = strnlen(p->szName, sizeof(p->szName));
+		CDBManager::instance().EscapeString(escName, p->szName, static_cast<unsigned long>(nameLen));
+
+		char s_szQuery[256];
+		//snprintf(s_szQuery, sizeof(s_szQuery), "SELECT * FROM player%s WHERE `name` = '%s' LIMIT 1", GetTablePostfix(), p->szName);
+		snprintf(s_szQuery, sizeof(s_szQuery),
+			"SELECT * FROM player%s WHERE `name` = convert('%s' using utf8mb4) collate utf8mb4_bin LIMIT 1",
+			GetTablePostfix(), escName);
+		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(s_szQuery));
+		bFound = pMsg->Get()->uiNumRows > 0;
+	}
+
+	if (bFound)
+	{
+		NameSet.emplace(p->szName); // player exists, next time we will use this to avoid using mysql.
+		std::memcpy(t.szName, p->szName, sizeof(t.szName));
+		auto it = m_map_mailbox.find(p->szName);
+		if (it != m_map_mailbox.end())
+		{
+			const time_t now = time(nullptr);
+			for (const SMailBoxTable& mail : it->second)
+			{
+				if (mail.bIsDeleted)
+					continue;
+
+				if (std::difftime(mail.Message.DeleteTime, now) <= 0)
+					continue;
+
+				t.Index++;
+			}
+		}
+	}
+
+	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_CHECK_NAME, dwHandle, sizeof(TMailBox));
+	pkPeer->Encode(&t, sizeof(TMailBox));
+}
+
+void CClientManager::QUERY_MAILBOX_WRITE(CPeer* pkPeer, DWORD dwHandle, TMailBoxTable* p)
+{
+	m_map_mailbox[p->szName].emplace_back(*p);
+}
+
+bool CClientManager::GET_MAIL(const char* name, const BYTE index, SMailBoxTable** mail)
+{
+	auto it = m_map_mailbox.find(name);
+	if (it == m_map_mailbox.end())
+		return false;
+
+	MailVec& mailvec = it->second;
+	if (index >= mailvec.size())
+		return false;
+
+	*mail = &mailvec.at(index);
+	return true;
+}
+
+void CClientManager::QUERY_MAILBOX_DELETE(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	SMailBoxTable* mail = nullptr;
+	if (GET_MAIL(p->szName, p->Index, &mail) == false)
+		return;
+
+	mail->bIsDeleted = true;
+}
+
+void CClientManager::QUERY_MAILBOX_CONFIRM(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	SMailBoxTable* mail = nullptr;
+	if (GET_MAIL(p->szName, p->Index, &mail) == false)
+		return;
+
+	mail->Message.bIsConfirm = true;
+}
+
+void CClientManager::QUERY_MAILBOX_GET(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	SMailBoxTable* mail = nullptr;
+	if (GET_MAIL(p->szName, p->Index, &mail) == false)
+		return;
+
+	mail->AddData.iYang = 0;
+	mail->AddData.iWon = 0;
+	mail->Message.bIsItemExist = false;
+	mail->Message.bIsConfirm = true;
+	mail->AddData.dwItemVnum = 0;
+	mail->AddData.dwItemCount = 0;
+	memset(mail->AddData.alSockets, 0, sizeof(mail->AddData.alSockets));
+	memset(mail->AddData.aAttr, 0, sizeof(mail->AddData.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	mail->AddData.dwChangeLookVnum = 0;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	memset(&mail->AddData.RefineElement, 0, sizeof(mail->AddData.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+	memset(mail->AddData.aApplyRandom, 0, sizeof(mail->AddData.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+	mail->AddData.bSetValue = 0;
+#endif
+}
+
+void CClientManager::QUERY_MAILBOX_UNREAD(CPeer* pkPeer, DWORD dwHandle, TMailBox* p)
+{
+	auto it = m_map_mailbox.find(p->szName);
+	if (it == m_map_mailbox.end())
+		return;
+
+	const MailVec& mailvec = it->second;
+	if (mailvec.empty())
+		return;
+
+	const time_t now = time(nullptr);
+	TMailBoxRespondUnreadData t;
+
+	for (const SMailBoxTable& mail : it->second)
+	{
+		if (mail.bIsDeleted)
+			continue;
+
+		if (mail.Message.bIsConfirm)
+			continue;
+
+		if (std::difftime(mail.Message.DeleteTime, now) <= 0)
+			continue;
+
+		if (mail.Message.bIsGMPost)
+			t.bGMVisible = true;
+
+		if (mail.Message.bIsItemExist)
+			t.bItemMessageCount++;
+		else
+			t.bCommonMessageCount++;
+	}
+
+	if ((t.bItemMessageCount + t.bCommonMessageCount) < 1)
+		return;
+
+	pkPeer->EncodeHeader(HEADER_DG_RESPOND_MAILBOX_UNREAD, dwHandle, sizeof(TMailBoxRespondUnreadData));
+	pkPeer->Encode(&t, sizeof(TMailBoxRespondUnreadData));
+}
+
+void CClientManager::MAILBOX_BACKUP()
+{
+	CDBManager::instance().DirectQuery("TRUNCATE TABLE player.mailbox");
+
+	if (m_map_mailbox.empty())
+		return;
+
+	char szQuery[QUERY_MAX_LEN];
+	const time_t now = std::time(nullptr);
+
+	for (auto& p : m_map_mailbox)
+	{
+		auto& mailvec = p.second;
+		if (mailvec.empty())
+			continue;
+
+		mailvec.erase(std::remove_if(mailvec.begin(), mailvec.end(),
+			[now](const TMailBoxTable& mail)
+			{ return mail.bIsDeleted || std::difftime(mail.Message.DeleteTime, now) <= 0; }
+		), mailvec.end());
+
+		std::sort(mailvec.begin(), mailvec.end(),
+			[](const TMailBoxTable& l, const TMailBoxTable& r)
+			{
+				return l.Message.SendTime > r.Message.SendTime;
+			});
+
+		for (const auto& mail : mailvec)
+		{
+			snprintf(szQuery, sizeof(szQuery),
+				"INSERT INTO `mailbox%s` (`name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`"
+				", `gold`, `won`, `vnum`, `count`"
+				", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+				", `socket3`, `socket4`, `socket5`"
+#endif
+				", `attrtype0`, `attrvalue0`"
+				", `attrtype1`, `attrvalue1`"
+				", `attrtype2`, `attrvalue2`"
+				", `attrtype3`, `attrvalue3`"
+				", `attrtype4`, `attrvalue4`"
+				", `attrtype5`, `attrvalue5`"
+				", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				", `changelookvnum`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				", `refine_element_apply_type`"
+				", `refine_element_grade`"
+				", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+				", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+				", `apply_type0`, `apply_value0`, `apply_path0`"
+				", `apply_type1`, `apply_value1`, `apply_path1`"
+				", `apply_type2`, `apply_value2`, `apply_path2`"
+				", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+				", `set_value`"
+#endif
+				") VALUES ('%s', '%s', '%s', '%s', %d, %d, %d, %d" // `name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`
+				", %u, %u, %u, %u" // `gold`, `won`, `vnum`, `count`
+				", %ld, %ld, %ld" // `socket0`, `socket1`, `socket2`
+#if defined(__ITEM_SOCKET6__)
+				", %ld, %ld, %ld" // `socket3`, `socket4`, `socket5`
+#endif
+				", %u, %ld" // `attrtype0`, `attrvalue0`
+				", %u, %ld" // `attrtype1`, `attrvalue1`
+				", %u, %ld" // `attrtype2`, `attrvalue2`
+				", %u, %ld" // `attrtype3`, `attrvalue3`
+				", %u, %ld" // `attrtype4`, `attrvalue4`
+				", %u, %ld" // `attrtype5`, `attrvalue5`
+				", %u, %ld" // `attrtype6`, `attrvalue6`
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				", %u" // `changelookvnum`
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				", %u" // `refine_element_apply_type`
+				", %u" // `refine_element_grade`
+				", %u, %u, %u" // `refine_element_value0`, `refine_element_value1`, `refine_element_value2`
+				", %u, %u, %u" // `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+				", %u, %ld, %d" // `apply_type0`, `apply_value0`, `apply_path0`
+				", %u, %ld, %d" // `apply_type1`, `apply_value1`, `apply_path1`
+				", %u, %ld, %d" // `apply_type2`, `apply_value2`, `apply_path2`
+				", %u, %ld, %d" // `apply_type3`, `apply_value3`, `apply_path3`
+#endif
+#if defined(__SET_ITEM__)
+				", %d" // `set_value`
+#endif
+				")", GetTablePostfix()
+				, mail.szName
+				, mail.AddData.szFrom
+				, mail.Message.szTitle
+				, mail.AddData.szMessage
+				, mail.Message.bIsGMPost
+				, mail.Message.bIsConfirm
+				, mail.Message.SendTime
+				, mail.Message.DeleteTime
+				, mail.AddData.iYang
+				, mail.AddData.iWon
+				, mail.AddData.dwItemVnum
+				, mail.AddData.dwItemCount
+				, mail.AddData.alSockets[0], mail.AddData.alSockets[1], mail.AddData.alSockets[2]
+#if defined(__ITEM_SOCKET6__)
+				, mail.AddData.alSockets[3], mail.AddData.alSockets[4], mail.AddData.alSockets[5]
+#endif
+				, mail.AddData.aAttr[0].wType, mail.AddData.aAttr[0].lValue
+				, mail.AddData.aAttr[1].wType, mail.AddData.aAttr[1].lValue
+				, mail.AddData.aAttr[2].wType, mail.AddData.aAttr[2].lValue
+				, mail.AddData.aAttr[3].wType, mail.AddData.aAttr[3].lValue
+				, mail.AddData.aAttr[4].wType, mail.AddData.aAttr[4].lValue
+				, mail.AddData.aAttr[5].wType, mail.AddData.aAttr[5].lValue
+				, mail.AddData.aAttr[6].wType, mail.AddData.aAttr[6].lValue
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				, mail.AddData.dwChangeLookVnum
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				, mail.AddData.RefineElement.wApplyType
+				, mail.AddData.RefineElement.bGrade
+				, mail.AddData.RefineElement.abValue[0], mail.AddData.RefineElement.abValue[1], mail.AddData.RefineElement.abValue[2]
+				, mail.AddData.RefineElement.abBonusValue[0], mail.AddData.RefineElement.abBonusValue[1], mail.AddData.RefineElement.abBonusValue[2]
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+				, mail.AddData.aApplyRandom[0].wType, mail.AddData.aApplyRandom[0].lValue, mail.AddData.aApplyRandom[0].bPath
+				, mail.AddData.aApplyRandom[1].wType, mail.AddData.aApplyRandom[1].lValue, mail.AddData.aApplyRandom[1].bPath
+				, mail.AddData.aApplyRandom[2].wType, mail.AddData.aApplyRandom[2].lValue, mail.AddData.aApplyRandom[2].bPath
+				, mail.AddData.aApplyRandom[3].wType, mail.AddData.aApplyRandom[3].lValue, mail.AddData.aApplyRandom[3].bPath
+#endif
+#if defined(__SET_ITEM__)
+				, mail.AddData.bSetValue
+#endif
+			);
+
+			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+}
+#endif
+
+#if defined(__GEM_SHOP__)
+void CClientManager::LoadGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopLoad* pTable, bool bUpdate)
+{
+	if (g_log)
+		sys_log(0, "LoadGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
+
+	TGemShopTable GemShopTable = {};
+#	if defined(__CONQUEROR_LEVEL__)
+	GemShopTable.bSpecial = pTable->bSpecial;
+	if (GemShopTable.bSpecial)
+	{
+		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
+		if (it != m_mapGemShopSpecialTable.end())
+			GemShopTable = it->second;
+	}
+	else
+#	endif
+	{
+		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
+		if (it != m_mapGemShopTable.end())
+			GemShopTable = it->second;
+	}
+
+	pPeer->EncodeHeader(bUpdate ? HEADER_DG_GEM_SHOP_UPDATE : HEADER_DG_GEM_SHOP_LOAD, dwHandle, sizeof(GemShopTable));
+	pPeer->Encode(&GemShopTable, sizeof(GemShopTable));
+}
+
+void CClientManager::UpdateGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopTable* pTable)
+{
+	if (g_log)
+		sys_log(0, "UpdateGemShop (handle: %d pid: %d)", dwHandle, pTable->dwPID);
+
+#	if defined(__CONQUEROR_LEVEL__)
+	if (pTable->bSpecial)
+	{
+		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.find(pTable->dwPID);
+		if (it != m_mapGemShopSpecialTable.end())
+			it->second = *pTable;
+		else
+			m_mapGemShopSpecialTable.emplace(std::make_pair(pTable->dwPID, *pTable));
+	}
+	else
+#	endif
+	{
+		GemShopTableMap::iterator it = m_mapGemShopTable.find(pTable->dwPID);
+		if (it != m_mapGemShopTable.end())
+			it->second = *pTable;
+		else
+			m_mapGemShopTable.emplace(std::make_pair(pTable->dwPID, *pTable));
+	}
+
+	// NOTE : Request Gem Shop Load
+	TGemShopLoad Packet;
+	Packet.dwPID = pTable->dwPID;
+#	if defined(__CONQUEROR_LEVEL__)
+	Packet.bSpecial = pTable->bSpecial;
+#	endif
+	LoadGemShop(pPeer, dwHandle, &Packet, true);
+}
+
+void CClientManager::FlushGemShop()
+{
+	// Flush Default Gem Shop Table
+	{
+		if (m_mapGemShopTable.empty())
+			return;
+
+		char szQuery[1024] = {};
+		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop%s`", GetTablePostfix());
+		CDBManager::instance().DirectQuery(szQuery);
+
+		GemShopTableMap::iterator it = m_mapGemShopTable.begin();
+		for (; it != m_mapGemShopTable.end(); ++it)
+		{
+			TGemShopTable GemShopTable = it->second;
+			if (it->first != GemShopTable.dwPID)
+				continue;
+
+			char szColumns[1024] = {};
+			char szValues[1024] = {};
+
+			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
+			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
+
+			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
+			{
+				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
+					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
+				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
+					GemShopTable.GemShopItem[bSlotIndex].bEnable,
+					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
+					GemShopTable.GemShopItem[bSlotIndex].bCount,
+					GemShopTable.GemShopItem[bSlotIndex].dwPrice
+				);
+			}
+
+			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop%s` (%s) VALUES(%s)",
+				GetTablePostfix(), szColumns, szValues);
+
+			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+
+#	if defined(__CONQUEROR_LEVEL__)
+	// Flush Port (Special) Gem Shop Table
+	{
+		if (m_mapGemShopSpecialTable.empty())
+			return;
+
+		char szQuery[1024] = {};
+		snprintf(szQuery, sizeof(szQuery), "TRUNCATE TABLE `player`.`gem_shop_port%s`", GetTablePostfix());
+		CDBManager::instance().DirectQuery(szQuery);
+
+		GemShopTableMap::iterator it = m_mapGemShopSpecialTable.begin();
+		for (; it != m_mapGemShopSpecialTable.end(); ++it)
+		{
+			TGemShopTable GemShopTable = it->second;
+			if (it->first != GemShopTable.dwPID)
+				continue;
+
+			char szColumns[1024] = {};
+			char szValues[1024] = {};
+
+			int iLen = snprintf(szColumns, sizeof(szColumns), "`pid`, `refresh_time`, `enabled_slots`");
+			int iValueLen = snprintf(szValues, sizeof(szValues), "%u, FROM_UNIXTIME(%ld), %d", GemShopTable.dwPID, GemShopTable.lRefreshTime, GemShopTable.bEnabledSlots);
+
+			for (BYTE bSlotIndex = 0; bSlotIndex < GEM_SHOP_SLOT_COUNT; ++bSlotIndex)
+			{
+				iLen += snprintf(szColumns + iLen, sizeof(szColumns) - iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`",
+					bSlotIndex, bSlotIndex, bSlotIndex, bSlotIndex);
+				iValueLen += snprintf(szValues + iValueLen, sizeof(szValues) - iValueLen, ", %d, %u, %d, %u",
+					GemShopTable.GemShopItem[bSlotIndex].bEnable,
+					GemShopTable.GemShopItem[bSlotIndex].dwItemVnum,
+					GemShopTable.GemShopItem[bSlotIndex].bCount,
+					GemShopTable.GemShopItem[bSlotIndex].dwPrice
+				);
+			}
+
+			snprintf(szQuery, sizeof(szQuery), "INSERT INTO `gem_shop_port%s` (%s) VALUES(%s)",
+				GetTablePostfix(), szColumns, szValues);
+
+			std::unique_ptr<SQLMsg> pInsert(CDBManager::instance().DirectQuery(szQuery));
+		}
+	}
+#	endif
+}
+#endif
+
+#ifdef __OFFLINE_SHOP__
+void CClientManager::InitializeNextOfflineShopId()
+{
+	std::stringstream query;
+	query << "SELECT MAX(id) + 1 FROM offline_shop" << GetTablePostfix();
+
+	std::unique_ptr<SQLMsg> msg(CDBManager::Instance().DirectQuery(query.str().c_str()));
+	if (msg && msg->Get()->uiNumRows > 0) {
+		auto row = mysql_fetch_row(msg->Get()->pSQLResult);
+		str_to_number(nextOfflineShopId_, row[0]);
+	}
+	else {
+		nextOfflineShopId_ = 1;
+	}
+
+	sys_log(0, "Next offline shop id: %u", nextOfflineShopId_);
+}
+
+void CClientManager::RequestOfflineShopId(CPeer* peer, uint32_t queueId)
+{
+	peer->EncodeHeader(HEADER_DG_RESPOND_OFFLINE_SHOP_ID, 0, sizeof(uint32_t) + sizeof(uint32_t));
+	peer->Encode(&queueId, sizeof(uint32_t));
+	peer->Encode(&nextOfflineShopId_, sizeof(uint32_t));
+
+	nextOfflineShopId_++;
+}
+
+void CClientManager::SaveOfflineShop(const TOfflineShop& data, bool skipQuery)
+{
+	auto it = offlineShopCache_.find(data.id);
+	if (it != offlineShopCache_.end()) {
+		it->second->Put(&data);
+	}
+	else {
+		auto cache = std::unique_ptr<COfflineShopCache>(new COfflineShopCache());
+		cache->Put(&data, skipQuery);
+
+		offlineShopCache_.insert(std::make_pair(data.id, std::move(cache)));
+	}
+}
+
+void CClientManager::SaveOfflineShopItem(const TOfflineShopItem& data, bool skipQuery)
+{
+	auto it = offlineShopItemCache_.find(data.id);
+	if (it != offlineShopItemCache_.end()) {
+		it->second->Put(&data);
+	}
+	else {
+		auto cache = std::unique_ptr<COfflineShopItemCache>(new COfflineShopItemCache());
+		cache->Put(&data, skipQuery);
+
+		offlineShopItemCache_.insert(std::make_pair(data.id, std::move(cache)));
+	}
+}
+
+void CClientManager::DestroyOfflineShop(uint32_t id)
+{
+	auto it = offlineShopCache_.find(id);
+	if (it != offlineShopCache_.end()) {
+		offlineShopCache_.erase(it);
+	}
+
+	std::pair<uint32_t, uint16_t> key = { id, 0 };
+	for (uint16_t i = 0; i < OFFLINE_SHOP_ITEM_COUNT; ++i) {
+		key.second = i;
+
+		auto it = offlineShopItemCache_.find(key);
+		if (it != offlineShopItemCache_.end()) {
+			offlineShopItemCache_.erase(it);
+		}
+	}
+
+	std::stringstream queryDeleteOfflineShop;
+	queryDeleteOfflineShop << "DELETE FROM offline_shop" << GetTablePostfix() << " WHERE id = " << id;
+	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShop.str().c_str());
+
+	std::stringstream queryDeleteOfflineShopItems;
+	queryDeleteOfflineShopItems << "DELETE FROM offline_shop_item" << GetTablePostfix() << " WHERE owner_pid = " << id;
+	CDBManager::Instance().AsyncQuery(queryDeleteOfflineShopItems.str().c_str());
+}
+
+void CClientManager::UpdateOfflineShopCache()
+{
+	auto it = offlineShopCache_.begin();
+	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopCache_.end()) {
+		if (it->second->CheckFlushTimeout()) {
+			it->second->Flush();
+
+			m_iCacheFlushCount++;
+		}
+
+		it++;
+	}
+}
+
+void CClientManager::UpdateOfflineShopItemCache()
+{
+	auto it = offlineShopItemCache_.begin();
+	while (m_iCacheFlushCount < m_iCacheFlushCountLimit && it != offlineShopItemCache_.end()) {
+		if (it->second->CheckFlushTimeout()) {
+			it->second->Flush();
+
+			m_iCacheFlushCount++;
+		}
+
+		it++;
+	}
+}
+
+void CClientManager::FlushOfflineShops()
+{
+	for (auto it = offlineShopCache_.begin(); it != offlineShopCache_.end(); ++it) {
+		it->second->Flush();
+	}
+
+	for (auto it = offlineShopItemCache_.begin(); it != offlineShopItemCache_.end(); ++it) {
+		it->second->Flush();
+	}
+}
+
+const TItemTable* CClientManager::GetItemTable(DWORD vnum) const
+{
+	auto it = m_map_itemTableByVnum.find(vnum);
+	if (it == m_map_itemTableByVnum.end())
+	{
+		return NULL;
+	}
+
+	return it->second;
+}
+
+BYTE CClientManager::GetRealItemType(DWORD vnum)
+{
+	if (vnum >= 110000 && vnum <= 165499)
+		return ITEM_DS;
+	
+	
+	/* SHIT :
+	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
+	{
+		if (it->second->dwVnum == vnum)
+		{
+			return it->second->bType;
+		}
+	}
+	*/
+	
+	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
+	{
+		if (it->dwVnum == vnum)
+		{
+			return it->bType;
+		}
+	}
+	
+	return ITEM_NONE;
+}
+
+BYTE CClientManager::GetRealItemSubType(DWORD vnum)
+{
+	/* SHIT:
+	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
+	{
+		if (it->second->dwVnum == vnum)
+		{
+			return it->second->bSubType;
+		}
+	}
+	*/
+	
+	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
+	{
+		if (it->dwVnum == vnum)
+		{
+			return it->bSubType;
+		}
+	}
+	
+	return 0;
+}
+
+void CClientManager::GetRealItemLimit(DWORD vnum, int & limitType, DWORD & limitValue)
+{
+	/* BUGGED SHIT :
+	for (auto it = m_map_itemTableByVnum.begin(); it != m_map_itemTableByVnum.end(); ++it)
+	{
+		if (it->second->dwVnum == vnum)
+		{
+			limitType = it->second->aLimits[0].bType;
+			limitValue = it->second->aLimits[0].lValue;
+			return;
+		}
+	}
+	*/
+	
+	for (auto it = m_vec_itemTable.begin(); it != m_vec_itemTable.end(); ++it)
+	{
+		if (it->dwVnum == vnum)
+		{
+			limitType = it->aLimits[0].bType;
+			limitValue = it->aLimits[0].lValue;
+			return;
+		}
+	}
+}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+CClientManager::TGrowthPetCacheSet* CClientManager::GetGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+		return nullptr;
+
+	return it->second;
+}
+
+void CClientManager::CreateGrowthPetCacheSet(DWORD pid)
+{
+	if (m_map_pkGrowthPetCacheSetPtr.find(pid) != m_map_pkGrowthPetCacheSetPtr.end())
+		return;
+				 
+	TGrowthPetCacheSet* pSet = new TGrowthPetCacheSet;
+	m_map_pkGrowthPetCacheSetPtr.insert(TGrowthPetCacheSetPtrMap::value_type(pid, pSet));
+
+	if (g_log)
+		sys_log(0, "GROWTH_PET_CACHE: new cache %u", pid);
+}
+
+void CClientManager::FlushGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : No GrowthPetCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TGrowthPetCacheSet* pSet = it->second;
+	auto it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CGrowthPetCache* c = *it_set++;
+		c->Flush();
+
+		m_map_growthPetCache.erase(c->Get()->dwID);
+		delete c;
+	}
+
+	pSet->clear();
+	delete pSet;
+
+	m_map_pkGrowthPetCacheSetPtr.erase(it);
+
+	if (g_log)
+		sys_log(0, "FLUSH_GROWTH_PET_CACHESET : Deleted pid(%d)", pid);
+}
+
+CGrowthPetCache* CClientManager::GetGrowthPetCache(DWORD id)
+{
+	auto it = m_map_growthPetCache.find(id);
+
+	if (it == m_map_growthPetCache.end())
+		return nullptr;
+
+	return it->second;
+}
+
+void CClientManager::PutGrowthPetCache(TGrowthPet* pNew, bool bSkipQuery)
+{
+	CGrowthPetCache* c;
+
+	c = GetGrowthPetCache(pNew->dwID);
+	if (!c)
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> New CGrowthPetCache id%d vnum%d new owner%d", pNew->dwID, pNew->dwVnum, pNew->dwOwner);
+
+		c = new CGrowthPetCache;
+		m_map_growthPetCache.insert(TGrowthPetCacheMap::value_type(pNew->dwID, c));
+	}
+	else
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: PutGrowthPetCache ==> Have Cache");
+		if (pNew->dwOwner != c->Get()->dwOwner)
+		{
+			auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
+
+			if (it != m_map_pkGrowthPetCacheSetPtr.end())
+			{
+				if (g_log)
+					sys_log(0, "GROWTH_PET_CACHE: delete owner %u id %u new owner %u", c->Get()->dwOwner, c->Get()->dwID, pNew->dwOwner);
+				it->second->erase(c);
+			}
+		}
+	}
+	c->Put(pNew, bSkipQuery);
+
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(c->Get()->dwOwner);
+
+	if (it != m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "GROWTH_PET_CACHE: save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		it->second->insert(c);
+	}
+	else
+	{
+		if (g_log)
+			sys_log(0, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+		else
+			sys_log(1, "GROWTH_PET_CACHE: direct save %u id %u", c->Get()->dwOwner, c->Get()->dwID);
+
+		c->OnFlush();
+	}
+}
+
+bool CClientManager::DeleteGrowthPetCache(DWORD dwID)
+{
+	CGrowthPetCache* c = GetGrowthPetCache(dwID);
+
+	if (!c)
+		return false;
+
+	c->Delete();
+	return true;
+}
+
+void CClientManager::UpdateGrowthPetCache()
+{
+	if (m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+		return;
+
+	auto it = m_map_growthPetCache.begin();
+
+	while (it != m_map_growthPetCache.end())
+	{
+		CGrowthPetCache* c = (it++)->second;
+
+		if (c->CheckFlushTimeout())
+		{
+			if (g_test_server)
+				sys_log(0, "UpdateGrowthPetCache ==> Flush() vnum %d id owner %d", c->Get()->dwVnum, c->Get()->dwID, c->Get()->dwOwner);
+
+			c->Flush();
+
+			if (++m_iCacheFlushCount >= m_iCacheFlushCountLimit)
+				break;
+		}
+	}
+}
+
+void CClientManager::UpdateGrowthPetCacheSet(DWORD pid)
+{
+	auto it = m_map_pkGrowthPetCacheSetPtr.find(pid);
+
+	if (it == m_map_pkGrowthPetCacheSetPtr.end())
+	{
+		if (g_test_server)
+			sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet ==> No GrowthPetCacheSet pid(%d)", pid);
+		return;
+	}
+
+	TGrowthPetCacheSet* pSet = it->second;
+	auto it_set = pSet->begin();
+
+	while (it_set != pSet->end())
+	{
+		CGrowthPetCache* c = *it_set++;
+		c->Flush();
+	}
+
+	if (g_log)
+		sys_log(0, "UPDATE_GROWTH_PET_CACHESET : UpdateGrowthPetCacheSet pid(%d)", pid);
+}
+
+void CClientManager::QUERY_GROWTH_PET_SAVE(CPeer* pkPeer, const char* c_pData)
+{
+	TGrowthPet* p = (TGrowthPet*)c_pData;
+	if (g_test_server)
+		sys_log(0, "QUERY_GROWTH_PET_SAVE => PutGrowthPetCache() owner %d id %d vnum %d ", p->dwOwner, p->dwID, p->dwVnum);
+
+	PutGrowthPetCache(p);
+}
+
+void CClientManager::QUERY_GROWTH_PET_DELETE(CPeer* pkPeer, const char* c_pData)
+{
+	DWORD dwID = *(DWORD*)c_pData;
+	c_pData += sizeof(DWORD);
+
+	DWORD dwPID = *(DWORD*)c_pData;
+
+	if (!DeleteGrowthPetCache(dwID))
+	{
+		char szQuery[64];
+		snprintf(szQuery, sizeof(szQuery), "DELETE FROM growth_pet%s WHERE id=%u", GetTablePostfix(), dwID);
+
+		if (dwPID == 0)
+			CDBManager::instance().AsyncQuery(szQuery);
+		else
+			CDBManager::instance().ReturnQuery(szQuery, QID_GROWTH_PET_DELETE, pkPeer->GetHandle(), NULL);
+	}
+}
+
+bool CClientManager::CreateGrowthPetTableFromRes(MYSQL_RES* res, std::vector<TGrowthPet>* pVec, DWORD dwPID)
+{
+	if (!res)
+	{
+		pVec->clear();
+		return true;
+	}
+
+	int rows;
+
+	if ((rows = mysql_num_rows(res)) <= 0)
+	{
+		pVec->clear();
+		return true;
+	}
+
+	pVec->resize(rows);
+
+	for (int i = 0; i < rows; ++i)
+	{
+		MYSQL_ROW row = mysql_fetch_row(res);
+		TGrowthPet& pet = pVec->at(i);
+
+		int cur = 0;
+
+		str_to_number(pet.dwID, row[cur++]);
+		str_to_number(pet.dwVnum, row[cur++]);
+		str_to_number(pet.bState, row[cur++]);
+		strlcpy(pet.szName, row[cur++], sizeof(pet.szName));
+		str_to_number(pet.bSize, row[cur++]);
+		str_to_number(pet.dwLevel, row[cur++]);
+		str_to_number(pet.bLevelStep, row[cur++]);
+		str_to_number(pet.bEvolution, row[cur++]);
+		str_to_number(pet.bType, row[cur++]);
+		str_to_number(pet.dwHP, row[cur++]);
+		str_to_number(pet.dwSP, row[cur++]);
+		str_to_number(pet.dwDef, row[cur++]);
+		str_to_number(pet.dwHPApply, row[cur++]);
+		str_to_number(pet.dwSPApply, row[cur++]);
+		str_to_number(pet.dwDefApply, row[cur++]);
+		str_to_number(pet.dwAgeApply, row[cur++]);
+		thecore_memcpy(pet.aSkill, row[cur++], sizeof(pet.aSkill));
+		str_to_number(pet.lExp, row[cur++]);
+		str_to_number(pet.lItemExp, row[cur++]);
+		str_to_number(pet.lBirthday, row[cur++]);
+		str_to_number(pet.lEndTime, row[cur++]);
+		str_to_number(pet.lMaxTime, row[cur++]);
+
+		pet.dwOwner = dwPID;
+	}
+
+	return true;
+}
+
+void CClientManager::RESULT_GROWTH_PET_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID)
+{
+	static std::vector<TGrowthPet> s_petVec;
+	CreateGrowthPetTableFromRes(pRes, &s_petVec, dwPID);
+	DWORD dwCount = s_petVec.size();
+
+	peer->EncodeHeader(HEADER_DG_GROWTH_PET_LOAD, dwHandle, sizeof(DWORD) + sizeof(TGrowthPet) * dwCount);
+	peer->EncodeDWORD(dwCount);
+
+	CreateGrowthPetCacheSet(dwPID);
+
+	sys_log(0, "GROWTH_PET_LOAD: count %u pid %u", dwCount, dwPID);
+
+	if (dwCount)
+	{
+		peer->Encode(&s_petVec[0], sizeof(TGrowthPet) * dwCount);
+
+		for (DWORD i = 0; i < dwCount; ++i)
+			PutGrowthPetCache(&s_petVec[i], true);
+	}
+}
+#endif
+
diff --git a/server/metin2/Source/Server/db/src/ClientManager.h b/server/metin2/Source/Server/db/src/ClientManager.h
index 3a69ab3..1b73c27 100644
--- a/server/metin2/Source/Server/db/src/ClientManager.h
+++ b/server/metin2/Source/Server/db/src/ClientManager.h
@@ -1,707 +1,715 @@
-#ifndef __INC_CLIENTMANAGER_H__
-#define __INC_CLIENTMANAGER_H__
-
-#include <boost/unordered_map.hpp>
-#include <boost/unordered_set.hpp>
-#include <memory>
-
-#include <unordered_map>
-#include <unordered_set>
-#include "Cache.h"
-
-#include "../../common/stl.h"
-#include "../../common/building.h"
-
-#include "Peer.h"
-#include "DBManager.h"
-#include "LoginData.h"
-
-class CPlayerTableCache;
-class CItemCache;
-class CItemPriceListTableCache;
-#ifdef __GROWTH_PET_SYSTEM__
-class CGrowthPetCache;
-#endif
-// typedef std::map<int, int> PacketInfoMap;
-
-class CPacketInfo
-{
-public:
-	void Add(int header);
-	void Reset();
-
-	// PacketInfoMap m_map_info;
-	std::map<int, int> m_map_info;
-};
-
-size_t CreatePlayerSaveQuery(char* pszQuery, size_t querySize, TPlayerTable* pkTab);
-
-// typedef std::vector<TItemTable> ItemTableVector;
-// typedef std::vector<TMobTable> MobTableVector;
-// typedef std::map<DWORD, building::TObject*> pkObjectTableMap;
-// typedef std::map<DWORD, TItemTable*> ItemTableVNumMap;
-
-class CClientManager : public CNetBase, public singleton<CClientManager>
-{
-public:
-	typedef std::list<CPeer*> TPeerList;
-	typedef std::unordered_map<DWORD, CPlayerTableCache*> TPlayerTableCacheMap;
-	typedef std::unordered_map<DWORD, CItemCache*> TItemCacheMap;
-	typedef std::unordered_set<CItemCache*, std::hash<CItemCache*> > TItemCacheSet;
-	typedef std::unordered_map<DWORD, TItemCacheSet*> TItemCacheSetPtrMap;
-	typedef std::unordered_map<DWORD, CItemPriceListTableCache*> TItemPriceListCacheMap;
-	typedef std::unordered_map<short, BYTE> TChannelStatusMap;
-
-#ifdef __GROWTH_PET_SYSTEM__
-	typedef boost::unordered_map<DWORD, CGrowthPetCache*> TGrowthPetCacheMap;
-	typedef boost::unordered_set<CGrowthPetCache*, boost::hash<CGrowthPetCache*> > TGrowthPetCacheSet;
-	typedef boost::unordered_map<DWORD, TGrowthPetCacheSet*> TGrowthPetCacheSetPtrMap;
-#endif
-
-	// MYSHOP_PRICE_LIST
-	/// 아이템 가격정보 리스트 요청 정보
-	/**
-	* first: Peer handle
-	* second: 요청한 플레이어의 ID
-	**/
-	typedef std::pair< DWORD, DWORD > TItemPricelistReqInfo;
-	// END_OF_MYSHOP_PRICE_LIST
-
-	class ClientHandleInfo
-	{
-	public:
-		DWORD dwHandle;
-		DWORD account_id;
-		DWORD player_id;
-		BYTE account_index;
-		char login[LOGIN_MAX_LEN + 1];
-		char safebox_password[SAFEBOX_PASSWORD_MAX_LEN + 1];
-		char ip[MAX_HOST_LENGTH + 1];
-
-		TAccountTable* pAccountTable;
-		TSafeboxTable* pSafebox;
-
-		ClientHandleInfo(DWORD argHandle, DWORD dwPID = 0)
-		{
-			dwHandle = argHandle;
-			pSafebox = NULL;
-			pAccountTable = NULL;
-			player_id = dwPID;
-		};
-
-		// 독일선물기능용 생성자
-		ClientHandleInfo(DWORD argHandle, DWORD dwPID, DWORD accountId)
-		{
-			dwHandle = argHandle;
-			pSafebox = NULL;
-			pAccountTable = NULL;
-			player_id = dwPID;
-			account_id = accountId;
-		};
-
-		~ClientHandleInfo()
-		{
-			if (pSafebox)
-			{
-				delete pSafebox;
-				pSafebox = NULL;
-			}
-		}
-	};
-
-public:
-	CClientManager();
-	~CClientManager();
-
-	bool Initialize();
-	time_t GetCurrentTime();
-
-	void MainLoop();
-	void Quit();
-
-	void SetTablePostfix(const char* c_pszTablePostfix);
-	void SetPlayerIDStart(int iIDStart);
-	int GetPlayerIDStart() { return m_iPlayerIDStart; }
-
-	int GetPlayerDeleteLevelLimit() { return m_iPlayerDeleteLevelLimit; }
-
-	void SetChinaEventServer(bool flag) { m_bChinaEventServer = flag; }
-	bool IsChinaEventServer() { return m_bChinaEventServer; }
-
-	DWORD GetUserCount(); // 접속된 사용자 수를 리턴 한다.
-
-	void SendAllGuildSkillRechargePacket();
-	void SendTime();
-
-	CPlayerTableCache* GetPlayerCache(DWORD id);
-	void PutPlayerCache(TPlayerTable* pNew);
-
-	void CreateItemCacheSet(DWORD dwID);
-	TItemCacheSet* GetItemCacheSet(DWORD dwID);
-	void FlushItemCacheSet(DWORD dwID);
-
-	CItemCache* GetItemCache(DWORD id);
-	void PutItemCache(TPlayerItem* pNew, bool bSkipQuery = false);
-	bool DeleteItemCache(DWORD id);
-
-	CPeer* GetPeer(IDENT ident);
-
-	void UpdatePlayerCache();
-	void UpdateItemCache();
-
-#ifdef __GROWTH_PET_SYSTEM__
-	void			CreateGrowthPetCacheSet(DWORD dwID);
-	TGrowthPetCacheSet* GetGrowthPetCacheSet(DWORD dwID);
-	void			FlushGrowthPetCacheSet(DWORD dwID);
-
-	CGrowthPetCache* GetGrowthPetCache(DWORD id);
-	void			PutGrowthPetCache(TGrowthPet* pNew, bool bSkipQuery = false);
-	bool			DeleteGrowthPetCache(DWORD dwID);
-
-	void			UpdateGrowthPetCache();
-	void			UpdateGrowthPetCacheSet(DWORD pid);
-
-	void		QUERY_GROWTH_PET_SAVE(CPeer* pkPeer, const char* c_pData);
-	void		QUERY_GROWTH_PET_DELETE(CPeer* pkPeer, const char* c_pData);
-	bool		CreateGrowthPetTableFromRes(MYSQL_RES* res, std::vector<TGrowthPet>* pVec, DWORD dwPID);
-	void		RESULT_GROWTH_PET_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
-#endif
-
-	// MYSHOP_PRICE_LIST
-	/// 가격정보 리스트 캐시를 가져온다.
-	/**
-	* @param [in] dwID 가격정보 리스트의 소유자.(플레이어 ID)
-	* @return 가격정보 리스트 캐시의 포인터
-	**/
-	CItemPriceListTableCache* GetItemPriceListCache(DWORD dwID);
-
-	/// 가격정보 리스트 캐시를 넣는다.
-	/**
-	* @param [in] pItemPriceList 캐시에 넣을 아이템 가격정보 리스트
-	*
-	* 캐시가 이미 있으면 Update 가 아닌 replace 한다.
-	**/
-	void PutItemPriceListCache(const TItemPriceListTable* pItemPriceList);
-
-	/// Flush 시간이 만료된 아이템 가격정보 리스트 캐시를 Flush 해주고 캐시에서 삭제한다.
-	void UpdateItemPriceListCache(void);
-	// END_OF_MYSHOP_PRICE_LIST
-
-	void SendGuildSkillUsable(DWORD guild_id, DWORD dwSkillVnum, bool bUsable);
-
-	void SetCacheFlushCountLimit(int iLimit);
-
-	template <class Func>
-	Func for_each_peer(Func f);
-
-	CPeer* GetAnyPeer();
-
-	void ForwardPacket(BYTE header, const void* data, int size, BYTE bChannel = 0, CPeer* except = NULL);
-
-	void SendNotice(const char* c_pszFormat, ...);
-
-	char* GetCommand(char* str, char* command); // 독일선물기능에서 명령어 얻는 함수
-	void ItemAward(CPeer* peer, char* login); // 독일 선물 기능
-
-protected:
-	void Destroy();
-
-private:
-	bool InitializeTables();
-	bool InitializeShopTable();
-
-	bool InitializeMobTable();
-	bool InitializeItemTable();
-
-	// BEGIN NPC TABLE
-	bool InitializeNpcTable();
-	// END NPC TABLE
-
-	bool InitializeQuestItemTable();
-	bool InitializeSkillTable();
-	bool InitializeRefineTable();
-	bool InitializeBanwordTable();
-	bool InitializeItemAttrTable();
-	bool InitializeItemRareTable();
-	bool InitializeLandTable();
-	bool InitializeObjectProto();
-	bool InitializeObjectTable();
-	bool InitializeMonarch();
-
-	void AddPeer(socket_t fd);
-	void RemovePeer(CPeer* pPeer);
-
-	int AnalyzeQueryResult(SQLMsg* msg);
-	int AnalyzeErrorMsg(CPeer* peer, SQLMsg* msg);
-
-	int Process();
-
-	void ProcessPackets(CPeer* peer);
-
-	CLoginData* GetLoginData(DWORD dwKey);
-	CLoginData* GetLoginDataByLogin(const char* c_pszLogin);
-	CLoginData* GetLoginDataByAID(DWORD dwAID);
-
-	void InsertLoginData(CLoginData* pkLD);
-	void DeleteLoginData(CLoginData* pkLD);
-
-	bool InsertLogonAccount(const char* c_pszLogin, DWORD dwHandle, const char* c_pszIP);
-	bool DeleteLogonAccount(const char* c_pszLogin, DWORD dwHandle);
-	bool FindLogonAccount(const char* c_pszLogin);
-
-	void GuildCreate(CPeer* peer, DWORD dwGuildID);
-	void GuildSkillUpdate(CPeer* peer, TPacketGuildSkillUpdate* p);
-	void GuildExpUpdate(CPeer* peer, TPacketGuildExpUpdate* p);
-	void GuildAddMember(CPeer* peer, TPacketGDGuildAddMember* p);
-	void GuildChangeGrade(CPeer* peer, TPacketGuild* p);
-	void GuildRemoveMember(CPeer* peer, TPacketGuild* p);
-	void GuildChangeMemberData(CPeer* peer, TPacketGuildChangeMemberData* p);
-	void GuildDisband(CPeer* peer, TPacketGuild* p);
-	void GuildWar(CPeer* peer, TPacketGuildWar* p);
-	void GuildWarScore(CPeer* peer, TPacketGuildWarScore* p);
-	void GuildChangeLadderPoint(TPacketGuildLadderPoint* p);
-	void GuildUseSkill(TPacketGuildUseSkill* p);
-	void GuildDepositMoney(TPacketGDGuildMoney* p);
-	void GuildWithdrawMoney(CPeer* peer, TPacketGDGuildMoney* p);
-	void GuildWithdrawMoneyGiveReply(TPacketGDGuildMoneyWithdrawGiveReply* p);
-	void GuildWarBet(TPacketGDGuildWarBet* p);
-	void GuildChangeMaster(TPacketChangeGuildMaster* p);
-
-	void SetGuildWarEndTime(DWORD guild_id1, DWORD guild_id2, time_t tEndTime);
-
-	void QUERY_BOOT(CPeer* peer, TPacketGDBoot* p);
-
-	void QUERY_LOGIN(CPeer* peer, DWORD dwHandle, SLoginPacket* data);
-	void QUERY_LOGOUT(CPeer* peer, DWORD dwHandle, const char*);
-
-	void RESULT_LOGIN(CPeer* peer, SQLMsg* msg);
-
-	void QUERY_PLAYER_LOAD(CPeer* peer, DWORD dwHandle, TPlayerLoadPacket*);
-	void RESULT_COMPOSITE_PLAYER(CPeer* peer, SQLMsg* pMsg, DWORD dwQID);
-	void RESULT_PLAYER_LOAD(CPeer* peer, MYSQL_RES* pRes, ClientHandleInfo* pkInfo);
-	void RESULT_ITEM_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
-	void RESULT_QUEST_LOAD(CPeer* pkPeer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
-	void RESULT_AFFECT_LOAD(CPeer* pkPeer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	void RESULT_EXT_BATTLE_PASS_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID);
-	void QUERY_SAVE_EXT_BATTLE_PASS(CPeer* peer, DWORD dwHandle, TPlayerExtBattlePassMission* battlePass);
-#endif
-
-	// PLAYER_INDEX_CREATE_BUG_FIX
-	void RESULT_PLAYER_INDEX_CREATE(CPeer* pkPeer, SQLMsg* msg);
-	// END_PLAYER_INDEX_CREATE_BUG_FIX
-
-	// MYSHOP_PRICE_LIST
-	/// 가격정보 로드 쿼리에 대한 Result 처리
-	/**
-	* @param peer 가격정보를 요청한 Game server 의 peer 객체 포인터
-	* @param pMsg 쿼리의 Result 로 받은 객체의 포인터
-	*
-	* 로드된 가격정보 리스트를 캐시에 저장하고 peer 에게 리스트를 보내준다.
-	**/
-	void RESULT_PRICELIST_LOAD(CPeer* peer, SQLMsg* pMsg);
-
-	/// 가격정보 업데이트를 위한 로드 쿼리에 대한 Result 처리
-	/**
-	* @param pMsg 쿼리의 Result 로 받은 객체의 포인터
-	*
-	* 로드된 정보로 가격정보 리스트 캐시를 만들고 업데이트 받은 가격정보로 업데이트 한다.
-	**/
-	void RESULT_PRICELIST_LOAD_FOR_UPDATE(SQLMsg* pMsg);
-	// END_OF_MYSHOP_PRICE_LIST
-
-	void QUERY_PLAYER_SAVE(CPeer* peer, DWORD dwHandle, TPlayerTable*);
-
-	void __QUERY_PLAYER_CREATE(CPeer* peer, DWORD dwHandle, TPlayerCreatePacket*);
-	void __QUERY_PLAYER_DELETE(CPeer* peer, DWORD dwHandle, TPlayerDeletePacket*);
-	void __RESULT_PLAYER_DELETE(CPeer* peer, SQLMsg* msg);
-
-	void QUERY_PLAYER_COUNT(CPeer* pkPeer, TPlayerCountPacket*);
-
-	void QUERY_ITEM_SAVE(CPeer* pkPeer, const char* c_pData);
-	void QUERY_ITEM_DESTROY(CPeer* pkPeer, const char* c_pData);
-	void QUERY_ITEM_FLUSH(CPeer* pkPeer, const char* c_pData);
-
-	void QUERY_QUEST_SAVE(CPeer* pkPeer, TQuestTable*, DWORD dwLen);
-	void QUERY_ADD_AFFECT(CPeer* pkPeer, TPacketGDAddAffect* p);
-	void QUERY_REMOVE_AFFECT(CPeer* pkPeer, TPacketGDRemoveAffect* p);
-
-	void QUERY_SAFEBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TSafeboxLoadPacket*, bool bMall);
-	void QUERY_SAFEBOX_SAVE(CPeer* pkPeer, TSafeboxTable* pTable);
-	void QUERY_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangeSizePacket* p);
-	void QUERY_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangePasswordPacket* p);
-
-	void RESULT_SAFEBOX_LOAD(CPeer* pkPeer, SQLMsg* msg);
-	void RESULT_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, SQLMsg* msg);
-	void RESULT_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, SQLMsg* msg);
-	void RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(CPeer* pkPeer, SQLMsg* msg);
-
-	void QUERY_EMPIRE_SELECT(CPeer* pkPeer, DWORD dwHandle, TEmpireSelectPacket* p);
-	void QUERY_SETUP(CPeer* pkPeer, DWORD dwHandle, const char* c_pData);
-
-	void SendPartyOnSetup(CPeer* peer);
-
-	void QUERY_HIGHSCORE_REGISTER(CPeer* peer, TPacketGDHighscore* data);
-	void RESULT_HIGHSCORE_REGISTER(CPeer* pkPeer, SQLMsg* msg);
-
-	void QUERY_FLUSH_CACHE(CPeer* pkPeer, const char* c_pData);
-
-	void QUERY_PARTY_CREATE(CPeer* peer, TPacketPartyCreate* p);
-	void QUERY_PARTY_DELETE(CPeer* peer, TPacketPartyDelete* p);
-	void QUERY_PARTY_ADD(CPeer* peer, TPacketPartyAdd* p);
-	void QUERY_PARTY_REMOVE(CPeer* peer, TPacketPartyRemove* p);
-	void QUERY_PARTY_STATE_CHANGE(CPeer* peer, TPacketPartyStateChange* p);
-	void QUERY_PARTY_SET_MEMBER_LEVEL(CPeer* peer, TPacketPartySetMemberLevel* p);
-
-	void QUERY_RELOAD_PROTO();
-
-	void QUERY_CHANGE_NAME(CPeer* peer, DWORD dwHandle, TPacketGDChangeName* p);
-	void GetPlayerFromRes(TPlayerTable* player_table, MYSQL_RES* res);
-
-	void QUERY_LOGIN_KEY(CPeer* pkPeer, TPacketGDLoginKey* p);
-
-	void AddGuildPriv(TPacketGiveGuildPriv* p);
-	void AddEmpirePriv(TPacketGiveEmpirePriv* p);
-	void AddCharacterPriv(TPacketGiveCharacterPriv* p);
-
-	void MoneyLog(TPacketMoneyLog* p);
-
-	void QUERY_AUTH_LOGIN(CPeer* pkPeer, DWORD dwHandle, TPacketGDAuthLogin* p);
-
-	void QUERY_LOGIN_BY_KEY(CPeer* pkPeer, DWORD dwHandle, TPacketGDLoginByKey* p);
-	void RESULT_LOGIN_BY_KEY(CPeer* peer, SQLMsg* msg);
-
-	void ChargeCash(const TRequestChargeCash* p);
-
-	void LoadEventFlag();
-	void SetEventFlag(TPacketSetEventFlag* p);
-	void SendEventFlagsOnSetup(CPeer* peer);
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	void LoadGuildEventFlag();
-	void GuildSetEventFlag(TPacketSetGuildEventFlag* pTable);
-	void SendGuildEventFlagsOnSetup(CPeer* pPeer);
-#endif
-
-	// 결혼
-	void MarriageAdd(TPacketMarriageAdd* p);
-	void MarriageUpdate(TPacketMarriageUpdate* p);
-	void MarriageRemove(TPacketMarriageRemove* p);
-
-	void WeddingRequest(TPacketWeddingRequest* p);
-	void WeddingReady(TPacketWeddingReady* p);
-	void WeddingEnd(TPacketWeddingEnd* p);
-
-#if defined(__MOVE_CHANNEL__)
-	void FindChannel(CPeer* pkPeer, DWORD dwHandle, TPacketChangeChannel* p);
-#endif
-
-	// MYSHOP_PRICE_LIST
-	// 개인상점 가격정보
-
-	/// 아이템 가격정보 리스트 업데이트 패킷(HEADER_GD_MYSHOP_PRICELIST_UPDATE) 처리함수
-	/**
-	* @param [in] pPacket 패킷 데이터의 포인터
-	**/
-	void MyshopPricelistUpdate(const TItemPriceListTable* pPacket);
-
-	/// 아이템 가격정보 리스트 요청 패킷(HEADER_GD_MYSHOP_PRICELIST_REQ) 처리함수
-	/**
-	* @param peer 패킷을 보낸 Game server 의 peer 객체의 포인터
-	* @param [in] dwHandle 가격정보를 요청한 peer 의 핸들
-	* @param [in] dwPlayerID 가격정보 리스트를 요청한 플레이어의 ID
-	**/
-	void MyshopPricelistRequest(CPeer* peer, DWORD dwHandle, DWORD dwPlayerID);
-	// END_OF_MYSHOP_PRICE_LIST
-
-	// Building
-	void CreateObject(TPacketGDCreateObject* p);
-	void DeleteObject(DWORD dwID);
-	void UpdateLand(DWORD* pdw);
-
-	// BLOCK_CHAT
-	void BlockChat(TPacketBlockChat* p);
-	// END_OF_BLOCK_CHAT
-
-#if defined(__ENVIRONMENT_SYSTEM__)
-	void UpdateEnvironment();
-#endif
-
-#ifdef __OFFLINE_SHOP__
-public:
-	const TItemTable* GetItemTable(DWORD vnum) const;
-	BYTE GetRealItemType(DWORD vnum);
-	BYTE GetRealItemSubType(DWORD vnum);
-	void GetRealItemLimit(DWORD vnum, int & limitType, DWORD & limitValue);
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-protected:
-	bool InitializeGrowthPetSkillTable();
-#endif
-
-private:
-	int m_looping;
-	socket_t m_fdAccept; // 접속 받는 소켓
-	TPeerList m_peerList;
-
-	CPeer* m_pkAuthPeer;
-
-	// LoginKey, LoginData pair
-	typedef std::unordered_map<DWORD, CLoginData*> TLoginDataByLoginKey;
-	TLoginDataByLoginKey m_map_pkLoginData;
-
-	// Login LoginData pair
-	typedef std::unordered_map<std::string, CLoginData*> TLoginDataByLogin;
-	TLoginDataByLogin m_map_pkLoginDataByLogin;
-
-	// AccountID LoginData pair
-	typedef std::unordered_map<DWORD, CLoginData*> TLoginDataByAID;
-	TLoginDataByAID m_map_pkLoginDataByAID;
-
-	// Login LoginData pair (실제 로그인 되어있는 계정)
-	typedef std::unordered_map<std::string, CLoginData*> TLogonAccountMap;
-	TLogonAccountMap m_map_kLogonAccount;
-
-	int m_iPlayerIDStart;
-	int m_iPlayerDeleteLevelLimit;
-	int m_iPlayerDeleteLevelLimitLower;
-	bool m_bChinaEventServer;
-	bool m_bWolfmanCharacter;
-	bool m_bDelayedCharacterCreation;
-
-	//MobTableVector m_vec_mobTable;
-	//ItemTableVector m_vec_itemTable;
-	//ItemTableVNumMap m_map_itemTableByVnum;
-	std::vector<TMobTable> m_vec_mobTable;
-	std::vector<TItemTable> m_vec_itemTable;
-	std::map<DWORD, TItemTable *> m_map_itemTableByVnum;
-
-	int m_iShopTableSize;
-	TShopTable* m_pShopTable;
-
-	int m_iRefineTableSize;
-	TRefineTable* m_pRefineTable;
-
-	std::vector<TSkillTable> m_vec_skillTable;
-	std::vector<TBanwordTable> m_vec_banwordTable;
-	std::vector<TItemAttrTable> m_vec_itemAttrTable;
-	std::vector<TItemAttrTable> m_vec_itemRareTable;
-
-	std::vector<building::TLand> m_vec_kLandTable;
-	std::vector<building::TObjectProto> m_vec_kObjectProto;
-	//pkObjectTableMap m_map_pkObjectTable;
-	std::map<DWORD, building::TObject *> m_map_pkObjectTable;
-#ifdef __GROWTH_PET_SYSTEM__
-	std::vector<TGrowthPetSkillTable>		m_vec_growthPetSkillTable;
-	TGrowthPetCacheMap				m_map_growthPetCache;
-	TGrowthPetCacheSetPtrMap		m_map_pkGrowthPetCacheSetPtr;
-#endif
-	bool m_bShutdowned;
-
-	TPlayerTableCacheMap m_map_playerCache; // 플레이어 id가 key
-
-	TItemCacheMap m_map_itemCache; // 아이템 id가 key
-	TItemCacheSetPtrMap m_map_pkItemCacheSetPtr; // 플레이어 id가 key, 이 플레이어가 어떤 아이템 캐쉬를 가지고 있나?
-
-	// MYSHOP_PRICE_LIST
-	/// 플레이어별 아이템 가격정보 리스트 map. key: 플레이어 ID, value: 가격정보 리스트 캐시
-	TItemPriceListCacheMap m_mapItemPriceListCache; ///< 플레이어별 아이템 가격정보 리스트
-	// END_OF_MYSHOP_PRICE_LIST
-
-	TChannelStatusMap m_mChannelStatus;
-
-	struct TPartyInfo
-	{
-		BYTE bRole;
-		BYTE bLevel;
-
-		TPartyInfo() :bRole(0), bLevel(0)
-		{
-		}
-	};
-
-	typedef std::map<DWORD, TPartyInfo> TPartyMember;
-	typedef std::map<DWORD, TPartyMember> TPartyMap;
-	typedef std::map<BYTE, TPartyMap> TPartyChannelMap;
-	TPartyChannelMap m_map_pkChannelParty;
-
-	typedef std::map<std::string, long> TEventFlagMap;
-	TEventFlagMap m_map_lEventFlag;
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-	typedef std::map<DWORD, std::map<std::string, long>> TGuildEventFlagMap;
-	TGuildEventFlagMap m_map_lGuildEventFlag;
-#endif
-
-	BYTE m_bLastHeader;
-	int m_iCacheFlushCount;
-	int m_iCacheFlushCountLimit;
-
-private:
-	TItemIDRangeTable m_itemRange;
-
-public:
-	bool InitializeNowItemID();
-	DWORD GetItemID();
-	DWORD GainItemID();
-	TItemIDRangeTable GetItemRange() { return m_itemRange; }
-
-	// BOOT_LOCALIZATION
-public:
-	/* 로컬 정보 초기화 */
-	bool InitializeLocalization();
-
-private:
-	std::vector<tLocale> m_vec_Locale;
-	// END_BOOT_LOCALIZATION
-
-	// ADMIN_MANAGER
-	bool __GetAdminInfo(const char* szIP, std::vector<tAdminInfo>& rAdminVec);
-	bool __GetHostInfo(std::vector<std::string>& rIPVec);
-	// END_ADMIN_MANAGER
-
-	// RELOAD_ADMIN
-	void ReloadAdmin(CPeer* peer, TPacketReloadAdmin* p);
-	// END_RELOAD_ADMIN
-	void BreakMarriage(CPeer* peer, const char* data);
-
-	struct TLogoutPlayer
-	{
-		DWORD pid;
-		time_t time;
-
-		bool operator < (const TLogoutPlayer& r)
-		{
-			return (pid < r.pid);
-		}
-	};
-
-	typedef std::unordered_map<DWORD, TLogoutPlayer*> TLogoutPlayerMap;
-	TLogoutPlayerMap m_map_logout;
-
-	void InsertLogoutPlayer(DWORD pid);
-	void DeleteLogoutPlayer(DWORD pid);
-	void UpdateLogoutPlayer();
-	void UpdateItemCacheSet(DWORD pid);
-
-	void FlushPlayerCacheSet(DWORD pid);
-
-	// MONARCH
-	void Election(CPeer* peer, DWORD dwHandle, const char* p);
-	void Candidacy(CPeer* peer, DWORD dwHandle, const char* p);
-	void AddMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
-	void TakeMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
-	void ComeToVote(CPeer* peer, DWORD dwHandle, const char* p);
-	void RMCandidacy(CPeer* peer, DWORD dwHandle, const char* p);
-	void SetMonarch(CPeer* peer, DWORD dwHandle, const char* p);
-	void RMMonarch(CPeer* peer, DWORD dwHandle, const char* p);
-
-	void DecMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
-	// END_MONARCH
-
-	void ChangeMonarchLord(CPeer* peer, DWORD dwHandle, TPacketChangeMonarchLord* info);
-	void BlockException(TPacketBlockException* data);
-
-	void SendSpareItemIDRange(CPeer* peer);
-
-	void UpdateHorseName(TPacketUpdateHorseName* data, CPeer* peer);
-	void AckHorseName(DWORD dwPID, CPeer* peer);
-	void DeleteLoginKey(TPacketDC* data);
-	void ResetLastPlayerID(const TPacketNeedLoginLogInfo* data);
-
-	void DeleteAwardId(TPacketDeleteAwardID* data); // delete gift notify icon
-
-	void UpdateChannelStatus(TChannelStatus* pData);
-	void RequestChannelStatus(CPeer* peer, DWORD dwHandle);
-
-#if defined(__EXPRESSING_EMOTIONS__)
-public:
-	typedef std::vector<TPacketGDEmote> TEmoteTableVector;
-	typedef std::unordered_map<DWORD, TEmoteTableVector> TPlayerEmoteMap;
-
-private:
-	bool InitializeEmoteTable();
-
-	void QUERY_EMOTE_LOAD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
-	void QUERY_EMOTE_CLEAR(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
-	void QUERY_EMOTE_ADD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
-	void QUERY_EMOTE_DUMP();
-
-	TPlayerEmoteMap m_map_kPlayerEmote;
-	int m_iEmoteDumpDelay;
-#endif
-
-#if defined(__MAILBOX__)
-public:
-	typedef std::vector<SMailBoxTable> MailVec;
-	typedef std::map<std::string, MailVec> MailBoxMap;
-
-private:
-	bool InitializeMailBoxTable();
-
-	bool GET_MAIL(const char* name, const BYTE index, SMailBoxTable** mail);
-	void QUERY_MAILBOX_LOAD(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
-	void QUERY_MAILBOX_CHECK_NAME(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
-	void QUERY_MAILBOX_WRITE(CPeer * pkPeer, DWORD dwHandle, TMailBoxTable*);
-	void QUERY_MAILBOX_DELETE(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
-	void QUERY_MAILBOX_CONFIRM(CPeer* pkPeer, DWORD dwHandle, TMailBox*);
-	void QUERY_MAILBOX_GET(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
-	void QUERY_MAILBOX_UNREAD(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
-	void MAILBOX_BACKUP();
-
-	int m_iMailBoxBackupSec;
-	std::map<std::string, MailVec> m_map_mailbox;
-#endif
-
-#if defined(__GEM_SHOP__)
-public:
-	using GemShopTableMap = std::map<DWORD, TGemShopTable>;
-
-	bool InitializeGemShopTable();
-
-	void LoadGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopLoad* pTable, bool bUpdate = false);
-	void UpdateGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopTable* pTable);
-	void FlushGemShop();
-
-	GemShopTableMap m_mapGemShopTable;
-#if defined(__CONQUEROR_LEVEL__)
-	GemShopTableMap m_mapGemShopSpecialTable;
-#endif
-	int m_iGemShopFlushDelay;
-#endif
-
-#ifdef __OFFLINE_SHOP__
-private:
-	uint32_t nextOfflineShopId_;
-	std::map<uint32_t, std::unique_ptr<COfflineShopCache>> offlineShopCache_;
-	std::map<TOfflineItemID, std::unique_ptr<COfflineShopItemCache>> offlineShopItemCache_;
-
-private:
-	void InitializeOfflineShops();
-	void RequestOfflineShopId(CPeer* peer, uint32_t queueId);
-	void SaveOfflineShop(const TOfflineShop& data, bool skipQuery = false);
-	void SaveOfflineShopItem(const TOfflineShopItem& data, bool skipQuery = false);
-	void DestroyOfflineShop(uint32_t id);
-	void UpdateOfflineShopCache();
-	void UpdateOfflineShopItemCache();
-
-	void FlushOfflineShops();
-
-public:
-	void InitializeNextOfflineShopId();
-#endif
-};
-
-template<class Func>
-Func CClientManager::for_each_peer(Func f)
-{
-	TPeerList::iterator it;
-	for (it = m_peerList.begin(); it != m_peerList.end(); ++it)
-	{
-		f(*it);
-	}
-	return f;
-}
-#endif
+#ifndef __INC_CLIENTMANAGER_H__
+#define __INC_CLIENTMANAGER_H__
+
+#include <boost/unordered_map.hpp>
+#include <boost/unordered_set.hpp>
+#include <memory>
+
+#include <unordered_map>
+#include <unordered_set>
+#include "Cache.h"
+
+#include "../../common/stl.h"
+#include "../../common/building.h"
+
+#include "Peer.h"
+#include "DBManager.h"
+#include "LoginData.h"
+
+class CPlayerTableCache;
+class CItemCache;
+class CItemPriceListTableCache;
+#ifdef __GROWTH_PET_SYSTEM__
+class CGrowthPetCache;
+#endif
+// typedef std::map<int, int> PacketInfoMap;
+
+class CPacketInfo
+{
+public:
+	void Add(int header);
+	void Reset();
+
+	// PacketInfoMap m_map_info;
+	std::map<int, int> m_map_info;
+};
+
+size_t CreatePlayerSaveQuery(char* pszQuery, size_t querySize, TPlayerTable* pkTab);
+
+// typedef std::vector<TItemTable> ItemTableVector;
+// typedef std::vector<TMobTable> MobTableVector;
+// typedef std::map<DWORD, building::TObject*> pkObjectTableMap;
+// typedef std::map<DWORD, TItemTable*> ItemTableVNumMap;
+
+class CClientManager : public CNetBase, public singleton<CClientManager>
+{
+public:
+	typedef std::list<CPeer*> TPeerList;
+	typedef std::unordered_map<DWORD, CPlayerTableCache*> TPlayerTableCacheMap;
+	typedef std::unordered_map<DWORD, CItemCache*> TItemCacheMap;
+	typedef std::unordered_set<CItemCache*, std::hash<CItemCache*> > TItemCacheSet;
+	typedef std::unordered_map<DWORD, TItemCacheSet*> TItemCacheSetPtrMap;
+	typedef std::unordered_map<DWORD, CItemPriceListTableCache*> TItemPriceListCacheMap;
+	typedef std::unordered_map<short, BYTE> TChannelStatusMap;
+
+#ifdef __GROWTH_PET_SYSTEM__
+	typedef boost::unordered_map<DWORD, CGrowthPetCache*> TGrowthPetCacheMap;
+	typedef boost::unordered_set<CGrowthPetCache*, boost::hash<CGrowthPetCache*> > TGrowthPetCacheSet;
+	typedef boost::unordered_map<DWORD, TGrowthPetCacheSet*> TGrowthPetCacheSetPtrMap;
+#endif
+
+	// MYSHOP_PRICE_LIST
+	///   트 청 
+	/**
+	* first: Peer handle
+	* second: 청 첨潔 ID
+	**/
+	typedef std::pair< DWORD, DWORD > TItemPricelistReqInfo;
+	// END_OF_MYSHOP_PRICE_LIST
+
+	class ClientHandleInfo
+	{
+	public:
+		DWORD dwHandle;
+		DWORD account_id;
+		DWORD player_id;
+		BYTE account_index;
+		char login[LOGIN_MAX_LEN + 1];
+		char safebox_password[SAFEBOX_PASSWORD_MAX_LEN + 1];
+		char ip[MAX_HOST_LENGTH + 1];
+
+		TAccountTable* pAccountTable;
+		TSafeboxTable* pSafebox;
+
+		ClientHandleInfo(DWORD argHandle, DWORD dwPID = 0)
+		{
+			dwHandle = argHandle;
+			pSafebox = NULL;
+			pAccountTable = NULL;
+			player_id = dwPID;
+		};
+
+		// 究 
+		ClientHandleInfo(DWORD argHandle, DWORD dwPID, DWORD accountId)
+		{
+			dwHandle = argHandle;
+			pSafebox = NULL;
+			pAccountTable = NULL;
+			player_id = dwPID;
+			account_id = accountId;
+		};
+
+		~ClientHandleInfo()
+		{
+			if (pSafebox)
+			{
+				delete pSafebox;
+				pSafebox = NULL;
+			}
+		}
+	};
+
+public:
+	CClientManager();
+	~CClientManager();
+
+	bool Initialize();
+	time_t GetCurrentTime();
+
+	void MainLoop();
+	void Quit();
+
+	void SetTablePostfix(const char* c_pszTablePostfix);
+	void SetPlayerIDStart(int iIDStart);
+	int GetPlayerIDStart() { return m_iPlayerIDStart; }
+
+	int GetPlayerDeleteLevelLimit() { return m_iPlayerDeleteLevelLimit; }
+
+	void SetChinaEventServer(bool flag) { m_bChinaEventServer = flag; }
+	bool IsChinaEventServer() { return m_bChinaEventServer; }
+
+	DWORD GetUserCount(); // 撻    磯.
+
+	void SendAllGuildSkillRechargePacket();
+	void SendTime();
+
+	CPlayerTableCache* GetPlayerCache(DWORD id);
+	void PutPlayerCache(TPlayerTable* pNew);
+
+	void CreateItemCacheSet(DWORD dwID);
+	TItemCacheSet* GetItemCacheSet(DWORD dwID);
+	void FlushItemCacheSet(DWORD dwID);
+
+	CItemCache* GetItemCache(DWORD id);
+	void PutItemCache(TPlayerItem* pNew, bool bSkipQuery = false);
+	bool DeleteItemCache(DWORD id);
+
+	CPeer* GetPeer(IDENT ident);
+
+	void UpdatePlayerCache();
+	void UpdateItemCache();
+
+#ifdef __GROWTH_PET_SYSTEM__
+	void			CreateGrowthPetCacheSet(DWORD dwID);
+	TGrowthPetCacheSet* GetGrowthPetCacheSet(DWORD dwID);
+	void			FlushGrowthPetCacheSet(DWORD dwID);
+
+	CGrowthPetCache* GetGrowthPetCache(DWORD id);
+	void			PutGrowthPetCache(TGrowthPet* pNew, bool bSkipQuery = false);
+	bool			DeleteGrowthPetCache(DWORD dwID);
+
+	void			UpdateGrowthPetCache();
+	void			UpdateGrowthPetCacheSet(DWORD pid);
+
+	void		QUERY_GROWTH_PET_SAVE(CPeer* pkPeer, const char* c_pData);
+	void		QUERY_GROWTH_PET_DELETE(CPeer* pkPeer, const char* c_pData);
+	bool		CreateGrowthPetTableFromRes(MYSQL_RES* res, std::vector<TGrowthPet>* pVec, DWORD dwPID);
+	void		RESULT_GROWTH_PET_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
+#endif
+
+	// MYSHOP_PRICE_LIST
+	///  트 캐첩 쨈.
+	/**
+	* @param [in] dwID  트 .(첨潔 ID)
+	* @return  트 캐 
+	**/
+	CItemPriceListTableCache* GetItemPriceListCache(DWORD dwID);
+
+	///  트 캐첩 獵쨈.
+	/**
+	* @param [in] pItemPriceList 캐첼    트
+	*
+	* 캐챨 譴  Update  틈 replace 磯.
+	**/
+	void PutItemPriceListCache(const TItemPriceListTable* pItemPriceList);
+
+	/// Flush 챨    트 캐첩 Flush 斂 캐첼 磯.
+	void UpdateItemPriceListCache(void);
+	// END_OF_MYSHOP_PRICE_LIST
+
+	void SendGuildSkillUsable(DWORD guild_id, DWORD dwSkillVnum, bool bUsable);
+
+	void SetCacheFlushCountLimit(int iLimit);
+
+	template <class Func>
+	Func for_each_peer(Func f);
+
+	CPeer* GetAnyPeer();
+
+	void ForwardPacket(BYTE header, const void* data, int size, BYTE bChannel = 0, CPeer* except = NULL);
+
+	void SendNotice(const char* c_pszFormat, ...);
+
+
+    // Safe parser: extracts command token from a string like "[COMMAND] rest..."
+    // Writes at most commandSize bytes (including NUL). Returns command.
+    char* GetCommand(char* str, char* command, size_t commandSize);
+
+    // Backward-compatible wrapper (legacy signature). Prefer the sized overload above.
+    char* GetCommand(char* str, char* command);
+
+	char* GetCommand(char* str, char* command); // 究   獨
+	void ItemAward(CPeer* peer, char* login); //   
+
+protected:
+	void Destroy();
+
+private:
+	bool InitializeTables();
+	bool InitializeShopTable();
+
+	bool InitializeMobTable();
+	bool InitializeItemTable();
+
+	// BEGIN NPC TABLE
+	bool InitializeNpcTable();
+	// END NPC TABLE
+
+	bool InitializeQuestItemTable();
+	bool InitializeSkillTable();
+	bool InitializeRefineTable();
+	bool InitializeBanwordTable();
+	bool InitializeItemAttrTable();
+	bool InitializeItemRareTable();
+	bool InitializeLandTable();
+	bool InitializeObjectProto();
+	bool InitializeObjectTable();
+	bool InitializeMonarch();
+
+	void AddPeer(socket_t fd);
+	void RemovePeer(CPeer* pPeer);
+
+	int AnalyzeQueryResult(SQLMsg* msg);
+	int AnalyzeErrorMsg(CPeer* peer, SQLMsg* msg);
+
+	int Process();
+
+	void ProcessPackets(CPeer* peer);
+
+	CLoginData* GetLoginData(DWORD dwKey);
+	CLoginData* GetLoginDataByLogin(const char* c_pszLogin);
+	CLoginData* GetLoginDataByAID(DWORD dwAID);
+
+	void InsertLoginData(CLoginData* pkLD);
+	void DeleteLoginData(CLoginData* pkLD);
+
+	bool InsertLogonAccount(const char* c_pszLogin, DWORD dwHandle, const char* c_pszIP);
+	bool DeleteLogonAccount(const char* c_pszLogin, DWORD dwHandle);
+	bool FindLogonAccount(const char* c_pszLogin);
+
+	void GuildCreate(CPeer* peer, DWORD dwGuildID);
+	void GuildSkillUpdate(CPeer* peer, TPacketGuildSkillUpdate* p);
+	void GuildExpUpdate(CPeer* peer, TPacketGuildExpUpdate* p);
+	void GuildAddMember(CPeer* peer, TPacketGDGuildAddMember* p);
+	void GuildChangeGrade(CPeer* peer, TPacketGuild* p);
+	void GuildRemoveMember(CPeer* peer, TPacketGuild* p);
+	void GuildChangeMemberData(CPeer* peer, TPacketGuildChangeMemberData* p);
+	void GuildDisband(CPeer* peer, TPacketGuild* p);
+	void GuildWar(CPeer* peer, TPacketGuildWar* p);
+	void GuildWarScore(CPeer* peer, TPacketGuildWarScore* p);
+	void GuildChangeLadderPoint(TPacketGuildLadderPoint* p);
+	void GuildUseSkill(TPacketGuildUseSkill* p);
+	void GuildDepositMoney(TPacketGDGuildMoney* p);
+	void GuildWithdrawMoney(CPeer* peer, TPacketGDGuildMoney* p);
+	void GuildWithdrawMoneyGiveReply(TPacketGDGuildMoneyWithdrawGiveReply* p);
+	void GuildWarBet(TPacketGDGuildWarBet* p);
+	void GuildChangeMaster(TPacketChangeGuildMaster* p);
+
+	void SetGuildWarEndTime(DWORD guild_id1, DWORD guild_id2, time_t tEndTime);
+
+	void QUERY_BOOT(CPeer* peer, TPacketGDBoot* p);
+
+	void QUERY_LOGIN(CPeer* peer, DWORD dwHandle, SLoginPacket* data);
+	void QUERY_LOGOUT(CPeer* peer, DWORD dwHandle, const char*);
+
+	void RESULT_LOGIN(CPeer* peer, SQLMsg* msg);
+
+	void QUERY_PLAYER_LOAD(CPeer* peer, DWORD dwHandle, TPlayerLoadPacket*);
+	void RESULT_COMPOSITE_PLAYER(CPeer* peer, SQLMsg* pMsg, DWORD dwQID);
+	void RESULT_PLAYER_LOAD(CPeer* peer, MYSQL_RES* pRes, ClientHandleInfo* pkInfo);
+	void RESULT_ITEM_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
+	void RESULT_QUEST_LOAD(CPeer* pkPeer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID);
+	void RESULT_AFFECT_LOAD(CPeer* pkPeer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	void RESULT_EXT_BATTLE_PASS_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID);
+	void QUERY_SAVE_EXT_BATTLE_PASS(CPeer* peer, DWORD dwHandle, TPlayerExtBattlePassMission* battlePass);
+#endif
+
+	// PLAYER_INDEX_CREATE_BUG_FIX
+	void RESULT_PLAYER_INDEX_CREATE(CPeer* pkPeer, SQLMsg* msg);
+	// END_PLAYER_INDEX_CREATE_BUG_FIX
+
+	// MYSHOP_PRICE_LIST
+	///  琯   Result 처
+	/**
+	* @param peer  청 Game server  peer 체 
+	* @param pMsg  Result   체 
+	*
+	* 琯  트 캐첼 構 peer  트 娩.
+	**/
+	void RESULT_PRICELIST_LOAD(CPeer* peer, SQLMsg* pMsg);
+
+	///  트  琯   Result 처
+	/**
+	* @param pMsg  Result   체 
+	*
+	* 琯   트 캐첩  트   트 磯.
+	**/
+	void RESULT_PRICELIST_LOAD_FOR_UPDATE(SQLMsg* pMsg);
+	// END_OF_MYSHOP_PRICE_LIST
+
+	void QUERY_PLAYER_SAVE(CPeer* peer, DWORD dwHandle, TPlayerTable*);
+
+	void __QUERY_PLAYER_CREATE(CPeer* peer, DWORD dwHandle, TPlayerCreatePacket*);
+	void __QUERY_PLAYER_DELETE(CPeer* peer, DWORD dwHandle, TPlayerDeletePacket*);
+	void __RESULT_PLAYER_DELETE(CPeer* peer, SQLMsg* msg);
+
+	void QUERY_PLAYER_COUNT(CPeer* pkPeer, TPlayerCountPacket*);
+
+	void QUERY_ITEM_SAVE(CPeer* pkPeer, const char* c_pData);
+	void QUERY_ITEM_DESTROY(CPeer* pkPeer, const char* c_pData);
+	void QUERY_ITEM_FLUSH(CPeer* pkPeer, const char* c_pData);
+
+	void QUERY_QUEST_SAVE(CPeer* pkPeer, TQuestTable*, DWORD dwLen);
+	void QUERY_ADD_AFFECT(CPeer* pkPeer, TPacketGDAddAffect* p);
+	void QUERY_REMOVE_AFFECT(CPeer* pkPeer, TPacketGDRemoveAffect* p);
+
+	void QUERY_SAFEBOX_LOAD(CPeer* pkPeer, DWORD dwHandle, TSafeboxLoadPacket*, bool bMall);
+	void QUERY_SAFEBOX_SAVE(CPeer* pkPeer, TSafeboxTable* pTable);
+	void QUERY_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangeSizePacket* p);
+	void QUERY_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, DWORD dwHandle, TSafeboxChangePasswordPacket* p);
+
+	void RESULT_SAFEBOX_LOAD(CPeer* pkPeer, SQLMsg* msg);
+	void RESULT_SAFEBOX_CHANGE_SIZE(CPeer* pkPeer, SQLMsg* msg);
+	void RESULT_SAFEBOX_CHANGE_PASSWORD(CPeer* pkPeer, SQLMsg* msg);
+	void RESULT_SAFEBOX_CHANGE_PASSWORD_SECOND(CPeer* pkPeer, SQLMsg* msg);
+
+	void QUERY_EMPIRE_SELECT(CPeer* pkPeer, DWORD dwHandle, TEmpireSelectPacket* p);
+	void QUERY_SETUP(CPeer* pkPeer, DWORD dwHandle, const char* c_pData);
+
+	void SendPartyOnSetup(CPeer* peer);
+
+	void QUERY_HIGHSCORE_REGISTER(CPeer* peer, TPacketGDHighscore* data);
+	void RESULT_HIGHSCORE_REGISTER(CPeer* pkPeer, SQLMsg* msg);
+
+	void QUERY_FLUSH_CACHE(CPeer* pkPeer, const char* c_pData);
+
+	void QUERY_PARTY_CREATE(CPeer* peer, TPacketPartyCreate* p);
+	void QUERY_PARTY_DELETE(CPeer* peer, TPacketPartyDelete* p);
+	void QUERY_PARTY_ADD(CPeer* peer, TPacketPartyAdd* p);
+	void QUERY_PARTY_REMOVE(CPeer* peer, TPacketPartyRemove* p);
+	void QUERY_PARTY_STATE_CHANGE(CPeer* peer, TPacketPartyStateChange* p);
+	void QUERY_PARTY_SET_MEMBER_LEVEL(CPeer* peer, TPacketPartySetMemberLevel* p);
+
+	void QUERY_RELOAD_PROTO();
+
+	void QUERY_CHANGE_NAME(CPeer* peer, DWORD dwHandle, TPacketGDChangeName* p);
+	void GetPlayerFromRes(TPlayerTable* player_table, MYSQL_RES* res);
+
+	void QUERY_LOGIN_KEY(CPeer* pkPeer, TPacketGDLoginKey* p);
+
+	void AddGuildPriv(TPacketGiveGuildPriv* p);
+	void AddEmpirePriv(TPacketGiveEmpirePriv* p);
+	void AddCharacterPriv(TPacketGiveCharacterPriv* p);
+
+	void MoneyLog(TPacketMoneyLog* p);
+
+	void QUERY_AUTH_LOGIN(CPeer* pkPeer, DWORD dwHandle, TPacketGDAuthLogin* p);
+
+	void QUERY_LOGIN_BY_KEY(CPeer* pkPeer, DWORD dwHandle, TPacketGDLoginByKey* p);
+	void RESULT_LOGIN_BY_KEY(CPeer* peer, SQLMsg* msg);
+
+	void ChargeCash(const TRequestChargeCash* p);
+
+	void LoadEventFlag();
+	void SetEventFlag(TPacketSetEventFlag* p);
+	void SendEventFlagsOnSetup(CPeer* peer);
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	void LoadGuildEventFlag();
+	void GuildSetEventFlag(TPacketSetGuildEventFlag* pTable);
+	void SendGuildEventFlagsOnSetup(CPeer* pPeer);
+#endif
+
+	// 혼
+	void MarriageAdd(TPacketMarriageAdd* p);
+	void MarriageUpdate(TPacketMarriageUpdate* p);
+	void MarriageRemove(TPacketMarriageRemove* p);
+
+	void WeddingRequest(TPacketWeddingRequest* p);
+	void WeddingReady(TPacketWeddingReady* p);
+	void WeddingEnd(TPacketWeddingEnd* p);
+
+#if defined(__MOVE_CHANNEL__)
+	void FindChannel(CPeer* pkPeer, DWORD dwHandle, TPacketChangeChannel* p);
+#endif
+
+	// MYSHOP_PRICE_LIST
+	// 貫 
+
+	///   트 트 킷(HEADER_GD_MYSHOP_PRICELIST_UPDATE) 처獨
+	/**
+	* @param [in] pPacket 킷  
+	**/
+	void MyshopPricelistUpdate(const TItemPriceListTable* pPacket);
+
+	///   트 청 킷(HEADER_GD_MYSHOP_PRICELIST_REQ) 처獨
+	/**
+	* @param peer 킷  Game server  peer 체 
+	* @param [in] dwHandle  청 peer  湄
+	* @param [in] dwPlayerID  트 청 첨潔 ID
+	**/
+	void MyshopPricelistRequest(CPeer* peer, DWORD dwHandle, DWORD dwPlayerID);
+	// END_OF_MYSHOP_PRICE_LIST
+
+	// Building
+	void CreateObject(TPacketGDCreateObject* p);
+	void DeleteObject(DWORD dwID);
+	void UpdateLand(DWORD* pdw);
+
+	// BLOCK_CHAT
+	void BlockChat(TPacketBlockChat* p);
+	// END_OF_BLOCK_CHAT
+
+#if defined(__ENVIRONMENT_SYSTEM__)
+	void UpdateEnvironment();
+#endif
+
+#ifdef __OFFLINE_SHOP__
+public:
+	const TItemTable* GetItemTable(DWORD vnum) const;
+	BYTE GetRealItemType(DWORD vnum);
+	BYTE GetRealItemSubType(DWORD vnum);
+	void GetRealItemLimit(DWORD vnum, int & limitType, DWORD & limitValue);
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+protected:
+	bool InitializeGrowthPetSkillTable();
+#endif
+
+private:
+	int m_looping;
+	socket_t m_fdAccept; //  濱 
+	TPeerList m_peerList;
+
+	CPeer* m_pkAuthPeer;
+
+	// LoginKey, LoginData pair
+	typedef std::unordered_map<DWORD, CLoginData*> TLoginDataByLoginKey;
+	TLoginDataByLoginKey m_map_pkLoginData;
+
+	// Login LoginData pair
+	typedef std::unordered_map<std::string, CLoginData*> TLoginDataByLogin;
+	TLoginDataByLogin m_map_pkLoginDataByLogin;
+
+	// AccountID LoginData pair
+	typedef std::unordered_map<DWORD, CLoginData*> TLoginDataByAID;
+	TLoginDataByAID m_map_pkLoginDataByAID;
+
+	// Login LoginData pair ( 慣 퓸獵 )
+	typedef std::unordered_map<std::string, CLoginData*> TLogonAccountMap;
+	TLogonAccountMap m_map_kLogonAccount;
+
+	int m_iPlayerIDStart;
+	int m_iPlayerDeleteLevelLimit;
+	int m_iPlayerDeleteLevelLimitLower;
+	bool m_bChinaEventServer;
+	bool m_bWolfmanCharacter;
+	bool m_bDelayedCharacterCreation;
+
+	//MobTableVector m_vec_mobTable;
+	//ItemTableVector m_vec_itemTable;
+	//ItemTableVNumMap m_map_itemTableByVnum;
+	std::vector<TMobTable> m_vec_mobTable;
+	std::vector<TItemTable> m_vec_itemTable;
+	std::map<DWORD, TItemTable *> m_map_itemTableByVnum;
+
+	int m_iShopTableSize;
+	TShopTable* m_pShopTable;
+
+	int m_iRefineTableSize;
+	TRefineTable* m_pRefineTable;
+
+	std::vector<TSkillTable> m_vec_skillTable;
+	std::vector<TBanwordTable> m_vec_banwordTable;
+	std::vector<TItemAttrTable> m_vec_itemAttrTable;
+	std::vector<TItemAttrTable> m_vec_itemRareTable;
+
+	std::vector<building::TLand> m_vec_kLandTable;
+	std::vector<building::TObjectProto> m_vec_kObjectProto;
+	//pkObjectTableMap m_map_pkObjectTable;
+	std::map<DWORD, building::TObject *> m_map_pkObjectTable;
+#ifdef __GROWTH_PET_SYSTEM__
+	std::vector<TGrowthPetSkillTable>		m_vec_growthPetSkillTable;
+	TGrowthPetCacheMap				m_map_growthPetCache;
+	TGrowthPetCacheSetPtrMap		m_map_pkGrowthPetCacheSetPtr;
+#endif
+	bool m_bShutdowned;
+
+	TPlayerTableCacheMap m_map_playerCache; // 첨潔 id key
+
+	TItemCacheMap m_map_itemCache; //  id key
+	TItemCacheSetPtrMap m_map_pkItemCacheSetPtr; // 첨潔 id key,  첨潔載 錚  캐  簾?
+
+	// MYSHOP_PRICE_LIST
+	/// 첨潔咀   트 map. key: 첨潔 ID, value:  트 캐
+	TItemPriceListCacheMap m_mapItemPriceListCache; ///< 첨潔咀   트
+	// END_OF_MYSHOP_PRICE_LIST
+
+	TChannelStatusMap m_mChannelStatus;
+
+	struct TPartyInfo
+	{
+		BYTE bRole;
+		BYTE bLevel;
+
+		TPartyInfo() :bRole(0), bLevel(0)
+		{
+		}
+	};
+
+	typedef std::map<DWORD, TPartyInfo> TPartyMember;
+	typedef std::map<DWORD, TPartyMember> TPartyMap;
+	typedef std::map<BYTE, TPartyMap> TPartyChannelMap;
+	TPartyChannelMap m_map_pkChannelParty;
+
+	typedef std::map<std::string, long> TEventFlagMap;
+	TEventFlagMap m_map_lEventFlag;
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+	typedef std::map<DWORD, std::map<std::string, long>> TGuildEventFlagMap;
+	TGuildEventFlagMap m_map_lGuildEventFlag;
+#endif
+
+	BYTE m_bLastHeader;
+	int m_iCacheFlushCount;
+	int m_iCacheFlushCountLimit;
+
+private:
+	TItemIDRangeTable m_itemRange;
+
+public:
+	bool InitializeNowItemID();
+	DWORD GetItemID();
+	DWORD GainItemID();
+	TItemIDRangeTable GetItemRange() { return m_itemRange; }
+
+	// BOOT_LOCALIZATION
+public:
+	/*   珂화 */
+	bool InitializeLocalization();
+
+private:
+	std::vector<tLocale> m_vec_Locale;
+	// END_BOOT_LOCALIZATION
+
+	// ADMIN_MANAGER
+	bool __GetAdminInfo(const char* szIP, std::vector<tAdminInfo>& rAdminVec);
+	bool __GetHostInfo(std::vector<std::string>& rIPVec);
+	// END_ADMIN_MANAGER
+
+	// RELOAD_ADMIN
+	void ReloadAdmin(CPeer* peer, TPacketReloadAdmin* p);
+	// END_RELOAD_ADMIN
+	void BreakMarriage(CPeer* peer, const char* data);
+
+	struct TLogoutPlayer
+	{
+		DWORD pid;
+		time_t time;
+
+		bool operator < (const TLogoutPlayer& r)
+		{
+			return (pid < r.pid);
+		}
+	};
+
+	typedef std::unordered_map<DWORD, TLogoutPlayer*> TLogoutPlayerMap;
+	TLogoutPlayerMap m_map_logout;
+
+	void InsertLogoutPlayer(DWORD pid);
+	void DeleteLogoutPlayer(DWORD pid);
+	void UpdateLogoutPlayer();
+	void UpdateItemCacheSet(DWORD pid);
+
+	void FlushPlayerCacheSet(DWORD pid);
+
+	// MONARCH
+	void Election(CPeer* peer, DWORD dwHandle, const char* p);
+	void Candidacy(CPeer* peer, DWORD dwHandle, const char* p);
+	void AddMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
+	void TakeMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
+	void ComeToVote(CPeer* peer, DWORD dwHandle, const char* p);
+	void RMCandidacy(CPeer* peer, DWORD dwHandle, const char* p);
+	void SetMonarch(CPeer* peer, DWORD dwHandle, const char* p);
+	void RMMonarch(CPeer* peer, DWORD dwHandle, const char* p);
+
+	void DecMonarchMoney(CPeer* peer, DWORD dwHandle, const char* p);
+	// END_MONARCH
+
+	void ChangeMonarchLord(CPeer* peer, DWORD dwHandle, TPacketChangeMonarchLord* info);
+	void BlockException(TPacketBlockException* data);
+
+	void SendSpareItemIDRange(CPeer* peer);
+
+	void UpdateHorseName(TPacketUpdateHorseName* data, CPeer* peer);
+	void AckHorseName(DWORD dwPID, CPeer* peer);
+	void DeleteLoginKey(TPacketDC* data);
+	void ResetLastPlayerID(const TPacketNeedLoginLogInfo* data);
+
+	void DeleteAwardId(TPacketDeleteAwardID* data); // delete gift notify icon
+
+	void UpdateChannelStatus(TChannelStatus* pData);
+	void RequestChannelStatus(CPeer* peer, DWORD dwHandle);
+
+#if defined(__EXPRESSING_EMOTIONS__)
+public:
+	typedef std::vector<TPacketGDEmote> TEmoteTableVector;
+	typedef std::unordered_map<DWORD, TEmoteTableVector> TPlayerEmoteMap;
+
+private:
+	bool InitializeEmoteTable();
+
+	void QUERY_EMOTE_LOAD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
+	void QUERY_EMOTE_CLEAR(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
+	void QUERY_EMOTE_ADD(CPeer* pkPeer, DWORD dwHandle, TPacketGDEmote* pTable);
+	void QUERY_EMOTE_DUMP();
+
+	TPlayerEmoteMap m_map_kPlayerEmote;
+	int m_iEmoteDumpDelay;
+#endif
+
+#if defined(__MAILBOX__)
+public:
+	typedef std::vector<SMailBoxTable> MailVec;
+	typedef std::map<std::string, MailVec> MailBoxMap;
+
+private:
+	bool InitializeMailBoxTable();
+
+	bool GET_MAIL(const char* name, const BYTE index, SMailBoxTable** mail);
+	void QUERY_MAILBOX_LOAD(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
+	void QUERY_MAILBOX_CHECK_NAME(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
+	void QUERY_MAILBOX_WRITE(CPeer * pkPeer, DWORD dwHandle, TMailBoxTable*);
+	void QUERY_MAILBOX_DELETE(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
+	void QUERY_MAILBOX_CONFIRM(CPeer* pkPeer, DWORD dwHandle, TMailBox*);
+	void QUERY_MAILBOX_GET(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
+	void QUERY_MAILBOX_UNREAD(CPeer * pkPeer, DWORD dwHandle, TMailBox*);
+	void MAILBOX_BACKUP();
+
+	int m_iMailBoxBackupSec;
+	std::map<std::string, MailVec> m_map_mailbox;
+#endif
+
+#if defined(__GEM_SHOP__)
+public:
+	using GemShopTableMap = std::map<DWORD, TGemShopTable>;
+
+	bool InitializeGemShopTable();
+
+	void LoadGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopLoad* pTable, bool bUpdate = false);
+	void UpdateGemShop(CPeer* pPeer, DWORD dwHandle, TGemShopTable* pTable);
+	void FlushGemShop();
+
+	GemShopTableMap m_mapGemShopTable;
+#if defined(__CONQUEROR_LEVEL__)
+	GemShopTableMap m_mapGemShopSpecialTable;
+#endif
+	int m_iGemShopFlushDelay;
+#endif
+
+#ifdef __OFFLINE_SHOP__
+private:
+	uint32_t nextOfflineShopId_;
+	std::map<uint32_t, std::unique_ptr<COfflineShopCache>> offlineShopCache_;
+	std::map<TOfflineItemID, std::unique_ptr<COfflineShopItemCache>> offlineShopItemCache_;
+
+private:
+	void InitializeOfflineShops();
+	void RequestOfflineShopId(CPeer* peer, uint32_t queueId);
+	void SaveOfflineShop(const TOfflineShop& data, bool skipQuery = false);
+	void SaveOfflineShopItem(const TOfflineShopItem& data, bool skipQuery = false);
+	void DestroyOfflineShop(uint32_t id);
+	void UpdateOfflineShopCache();
+	void UpdateOfflineShopItemCache();
+
+	void FlushOfflineShops();
+
+public:
+	void InitializeNextOfflineShopId();
+#endif
+};
+
+template<class Func>
+Func CClientManager::for_each_peer(Func f)
+{
+	TPeerList::iterator it;
+	for (it = m_peerList.begin(); it != m_peerList.end(); ++it)
+	{
+		f(*it);
+	}
+	return f;
+}
+#endif
diff --git a/server/metin2/Source/Server/db/src/ClientManagerBoot.cpp b/server/metin2/Source/Server/db/src/ClientManagerBoot.cpp
index 08d703e..ac13b95 100644
--- a/server/metin2/Source/Server/db/src/ClientManagerBoot.cpp
+++ b/server/metin2/Source/Server/db/src/ClientManagerBoot.cpp
@@ -1,1523 +1,1546 @@
-#include <map>
-#include "stdafx.h"
-#include "ClientManager.h"
-#include "Main.h"
-#include "Monarch.h"
-#include "CsvReader.h"
-#include "ProtoReader.h"
-
-using namespace std;
-
-extern int g_test_server;
-extern std::string g_stLocaleNameColumn;
-
-bool CClientManager::InitializeTables()
-{
-	if (!InitializeMobTable())
-	{
-		sys_err("InitializeMobTable FAILED");
-		return false;
-	}
-
-	if (!InitializeItemTable())
-	{
-		sys_err("InitializeItemTable FAILED");
-		return false;
-	}
-
-	if (!InitializeShopTable())
-	{
-		sys_err("InitializeShopTable FAILED");
-		return false;
-	}
-
-#if defined(__GEM_SHOP__)
-	if (!InitializeGemShopTable())
-	{
-		sys_err("InitializeGemShopTable FAILED");
-		return false;
-	}
-#endif
-
-	if (!InitializeSkillTable())
-	{
-		sys_err("InitializeSkillTable FAILED");
-		return false;
-	}
-
-	if (!InitializeRefineTable())
-	{
-		sys_err("InitializeRefineTable FAILED");
-		return false;
-	}
-
-	if (!InitializeItemAttrTable())
-	{
-		sys_err("InitializeItemAttrTable FAILED");
-		return false;
-	}
-
-	if (!InitializeItemRareTable())
-	{
-		sys_err("InitializeItemRareTable FAILED");
-		return false;
-	}
-
-	if (!InitializeBanwordTable())
-	{
-		sys_err("InitializeBanwordTable FAILED");
-		return false;
-	}
-
-	if (!InitializeLandTable())
-	{
-		sys_err("InitializeLandTable FAILED");
-		return false;
-	}
-
-	if (!InitializeObjectProto())
-	{
-		sys_err("InitializeObjectProto FAILED");
-		return false;
-	}
-
-	if (!InitializeObjectTable())
-	{
-		sys_err("InitializeObjectTable FAILED");
-		return false;
-	}
-
-	if (!InitializeMonarch())
-	{
-		sys_err("InitializeMonarch FAILED");
-		return false;
-	}
-
-#if defined(__MAILBOX__)
-	if (!InitializeMailBoxTable())
-	{
-		sys_err("InitializeMailBoxTable FAILED");
-		return false;
-	}
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-	if (!InitializeEmoteTable())
-	{
-		sys_err("InitializeEmoteTable FAILED");
-		return false;
-	}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (!InitializeGrowthPetSkillTable())
-	{
-		sys_err("InitializeGrowthPetSkillTable FAILED");
-		return false;
-	}
-#endif
-
-#ifdef __OFFLINE_SHOP__
-		InitializeOfflineShops();
-#endif
-
-	return true;
-}
-
-#ifdef __GROWTH_PET_SYSTEM__
-bool CClientManager::InitializeGrowthPetSkillTable()
-{
-	char query[4096];
-	snprintf(query, sizeof(query), 
-		"SELECT dwPetVnum, dwSkillVnum, szName, bType+0, dwCooldown, setAffectFlag+0, szPointOn," 
-		"szPointPoly1, szPointPoly2, szPointPoly3, szPointPoly4, szPointPoly5, szPointPoly6, "
-		"szPointPoly7, szPointPoly8, szActivatePctPoly, szDurationPoly "
-		"FROM growth_pet_skill_proto%s", GetTablePostfix());
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
-	SQLResult* pRes = pkMsg->Get();
-
-	if (!m_vec_growthPetSkillTable.empty())
-	{
-		sys_log(0, "RELOAD: growth pet skill");
-		m_vec_growthPetSkillTable.clear();
-	}
-
-	m_vec_growthPetSkillTable.reserve(pRes->uiNumRows);
-
-	MYSQL_ROW data;
-	TGrowthPetSkillTable t;
-
-	if (pRes->uiNumRows > 0)
-	{
-		while ((data = mysql_fetch_row(pRes->pSQLResult)))
-		{
-			memset(&t, 0, sizeof(t));
-
-			int col = 0;
-
-			str_to_number(t.dwPetVnum, data[col++]);
-			str_to_number(t.dwSkillVnum, data[col++]);
-			strlcpy(t.szName, data[col++], sizeof(t.szName));
-			str_to_number(t.bType, data[col++]);
-			str_to_number(t.dwCooldown, data[col++]);
-			str_to_number(t.dwAffectFlag, data[col++]);
-			strlcpy(t.szPointOn, data[col++], sizeof(t.szPointOn));
-			strlcpy(t.szPointPoly1, data[col++], sizeof(t.szPointPoly1));
-			strlcpy(t.szPointPoly2, data[col++], sizeof(t.szPointPoly2));
-			strlcpy(t.szPointPoly3, data[col++], sizeof(t.szPointPoly3));
-			strlcpy(t.szPointPoly4, data[col++], sizeof(t.szPointPoly4));
-			strlcpy(t.szPointPoly5, data[col++], sizeof(t.szPointPoly5));
-			strlcpy(t.szPointPoly6, data[col++], sizeof(t.szPointPoly6));
-			strlcpy(t.szPointPoly7, data[col++], sizeof(t.szPointPoly7));
-			strlcpy(t.szPointPoly8, data[col++], sizeof(t.szPointPoly8));
-			strlcpy(t.szActivatePctPoly, data[col++], sizeof(t.szActivatePctPoly));
-			strlcpy(t.szDurationPoly, data[col++], sizeof(t.szDurationPoly));
-
-			sys_log(0, "GROWTH PET SKILL: PET %u  SKILL %u", t.dwPetVnum, t.dwSkillVnum);
-
-			m_vec_growthPetSkillTable.push_back(t);
-		}
-	}
-	else
-		return false;
-
-	return true;
-}
-#endif
-
-bool CClientManager::InitializeRefineTable()
-{
-	char query[2048];
-
-	snprintf(query, sizeof(query),
-		"SELECT `id`, `cost`, `prob`, `vnum0`, `count0`, `vnum1`, `count1`, `vnum2`, `count2`, `vnum3`, `count3`, `vnum4`, `count4` FROM refine_proto%s",
-		GetTablePostfix());
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
-	SQLResult* pRes = pkMsg->Get();
-
-	if (!pRes->uiNumRows)
-		return true;
-
-	if (m_pRefineTable)
-	{
-		sys_log(0, "RELOAD: refine_proto");
-		delete[] m_pRefineTable;
-		m_pRefineTable = NULL;
-	}
-
-	m_iRefineTableSize = pRes->uiNumRows;
-
-	m_pRefineTable = new TRefineTable[m_iRefineTableSize];
-	memset(m_pRefineTable, 0, sizeof(TRefineTable) * m_iRefineTableSize);
-
-	TRefineTable* prt = m_pRefineTable;
-	MYSQL_ROW data;
-
-	while ((data = mysql_fetch_row(pRes->pSQLResult)))
-	{
-		// const char* s_szQuery = "SELECT src_vnum, result_vnum, cost, prob, "
-		// "vnum0, count0, vnum1, count1, vnum2, count2, vnum3, count3, vnum4, count4 "
-
-		int col = 0;
-		// prt->src_vnum = atoi(data[col++]);
-		// prt->result_vnum = atoi(data[col++]);
-		str_to_number(prt->id, data[col++]);
-		str_to_number(prt->cost, data[col++]);
-		str_to_number(prt->prob, data[col++]);
-
-		prt->material_count = REFINE_MATERIAL_MAX_NUM;
-
-		for (int i = 0; i < REFINE_MATERIAL_MAX_NUM; i++)
-		{
-			str_to_number(prt->materials[i].vnum, data[col++]);
-			str_to_number(prt->materials[i].count, data[col++]);
-			if (prt->materials[i].vnum == 0)
-			{
-				prt->material_count = i;
-				break;
-			}
-		}
-
-		sys_log(0, "REFINE: id %ld cost %d prob %d mat1 %lu cnt1 %d", prt->id, prt->cost, prt->prob, prt->materials[0].vnum, prt->materials[0].count);
-
-		prt++;
-	}
-	return true;
-}
-
-class FCompareVnum
-{
-public:
-	bool operator () (const TEntityTable& a, const TEntityTable& b) const
-	{
-		return (a.dwVnum < b.dwVnum);
-	}
-};
-
-bool CClientManager::InitializeMobTable()
-{
-	map<int, const char*> localMap;
-
-	cCsvTable nameData;
-	if (!nameData.Load("mob_names.txt", '\t'))
-	{
-		fprintf(stderr, "Could not load mob_names.txt\n");
-	}
-	else
-	{
-		nameData.Next();
-		while (nameData.Next())
-		{
-			if (nameData.ColCount() < 2)
-				continue;
-
-			localMap[atoi(nameData.AsStringByIndex(0))] = nameData.AsStringByIndex(1);
-		}
-	}
-	//________________________________________________//
-
-	cCsvTable data;
-	if (!data.Load("mob_proto.txt", '\t'))
-	{
-		fprintf(stderr, "Could not load mob_proto.txt. Wrong file format?\n");
-		return false;
-	}
-	data.Next();
-
-	if (!m_vec_mobTable.empty())
-	{
-		sys_log(0, "RELOAD: mob_proto");
-		m_vec_mobTable.clear();
-	}
-	m_vec_mobTable.resize(data.m_File.GetRowCount() - 1);
-
-	memset(&m_vec_mobTable[0], 0, sizeof(TMobTable) * m_vec_mobTable.size());
-	TMobTable* mob_table = &m_vec_mobTable[0];
-
-	while (data.Next())
-	{
-		if (!Set_Proto_Mob_Table(mob_table, data, localMap))
-		{
-			fprintf(stderr, "Could not process entry.\n");
-		}
-
-		sys_log(1, "MOB #%-5d %-24s %-24s level: %-3u rank: %u empire: %d", mob_table->dwVnum, mob_table->szName, mob_table->szLocaleName, mob_table->bLevel, mob_table->bRank, mob_table->bEmpire);
-		++mob_table;
-	}
-
-	sort(m_vec_mobTable.begin(), m_vec_mobTable.end(), FCompareVnum());
-	return true;
-}
-
-bool CClientManager::InitializeShopTable()
-{
-	MYSQL_ROW data;
-	int col;
-
-	static const char* s_szQuery =
-		"SELECT "
-		"shop.vnum, "
-		"shop.npc_vnum, "
-		"shop_item.item_vnum, "
-		"shop_item.count "
-		"FROM shop LEFT JOIN shop_item "
-		"ON shop.vnum = shop_item.shop_vnum ORDER BY shop.vnum, shop_item.item_vnum";
-
-	std::unique_ptr<SQLMsg> pkMsg2(CDBManager::instance().DirectQuery(s_szQuery));
-
-	// shop vnum쨘 쨈쨉짜 shop_item  쩐첩쨩째챈쩔챙... 쩍쨌 쨀쨍짰쨉쨈  쩔채쨍.
-	// 째챠쨀쩐쨘쨘
-	SQLResult* pRes2 = pkMsg2->Get();
-
-	if (!pRes2->uiNumRows)
-	{
-		sys_err("InitializeShopTable : Table count is zero.");
-		return false;
-	}
-
-	std::map<int, TShopTable*> map_shop;
-
-	if (m_pShopTable)
-	{
-		delete[](m_pShopTable);
-		m_pShopTable = NULL;
-	}
-
-	TShopTable* shop_table = m_pShopTable;
-
-	while ((data = mysql_fetch_row(pRes2->pSQLResult)))
-	{
-		col = 0;
-
-		int iShopVnum = 0;
-		str_to_number(iShopVnum, data[col++]);
-
-		if (map_shop.end() == map_shop.find(iShopVnum))
-		{
-			shop_table = new TShopTable;
-			memset(shop_table, 0, sizeof(TShopTable));
-			shop_table->dwVnum = iShopVnum;
-
-			map_shop[iShopVnum] = shop_table;
-		}
-		else
-			shop_table = map_shop[iShopVnum];
-
-		str_to_number(shop_table->dwNPCVnum, data[col++]);
-
-		if (!data[col]) // 쩐 쨀짧쨉쨉 쩐첩쨍쨍챕 NULL 쨍짰 쨉쨔쨌..
-			continue;
-
-		TShopItemTable* pItem = &shop_table->items[shop_table->bItemCount];
-
-		str_to_number(pItem->vnum, data[col++]);
-		str_to_number(pItem->count, data[col++]);
-
-		++shop_table->bItemCount;
-	}
-
-	m_pShopTable = new TShopTable[map_shop.size()];
-	m_iShopTableSize = map_shop.size();
-
-	int i = 0;
-	auto it = map_shop.begin();
-	while (it != map_shop.end())
-	{
-		thecore_memcpy((m_pShopTable + i), (it++)->second, sizeof(TShopTable));
-		sys_log(0, "SHOP: #%d items: %d", (m_pShopTable + i)->dwVnum, (m_pShopTable + i)->bItemCount);
-		++i;
-	}
-
-	return true;
-}
-
-bool CClientManager::InitializeQuestItemTable()
-{
-	using namespace std;
-
-	static const char* s_szQuery = "SELECT vnum, name, %s FROM quest_item_proto ORDER BY vnum";
-
-	char query[1024];
-	snprintf(query, sizeof(query), s_szQuery, g_stLocaleNameColumn.c_str());
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
-	SQLResult* pRes = pkMsg->Get();
-
-	if (!pRes->uiNumRows)
-	{
-		sys_err("query error or no rows: %s", query);
-		return false;
-	}
-
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pRes->pSQLResult)))
-	{
-		int col = 0;
-
-		TItemTable tbl;
-		memset(&tbl, 0, sizeof(tbl));
-
-		str_to_number(tbl.dwVnum, row[col++]);
-
-		if (row[col])
-			strlcpy(tbl.szName, row[col], sizeof(tbl.szName));
-
-		col++;
-
-		if (row[col])
-			strlcpy(tbl.szLocaleName, row[col], sizeof(tbl.szLocaleName));
-
-		col++;
-
-		if (m_map_itemTableByVnum.find(tbl.dwVnum) != m_map_itemTableByVnum.end())
-		{
-			sys_err("QUEST_ITEM_ERROR! %lu vnum already exist! (name %s)", tbl.dwVnum, tbl.szLocaleName);
-			continue;
-		}
-
-		tbl.bType = ITEM_QUEST; // quest_item_proto 쨘챠쩔징 쨈 째쨉챕쨘 쨍챨쨉 ITEM_QUEST 짱체
-		tbl.bSize = 1;
-
-		m_vec_itemTable.push_back(tbl);
-	}
-
-	return true;
-}
-
-bool CClientManager::InitializeItemTable()
-{
-	map<int, const char*> localMap;
-	cCsvTable nameData;
-	if (!nameData.Load("item_names.txt", '\t'))
-	{
-		fprintf(stderr, "Could not load item_names.txt.\n");
-	}
-	else
-	{
-		nameData.Next();
-		while (nameData.Next())
-		{
-			if (nameData.ColCount() < 2)
-				continue;
-
-			localMap[atoi(nameData.AsStringByIndex(0))] = nameData.AsStringByIndex(1);
-		}
-	}
-	//_________________________________________________________________//
-
-	cCsvTable data;
-	if (!data.Load("item_proto.txt", '\t'))
-	{
-		fprintf(stderr, "Could not load item_proto.txt. Wrong file format?\n");
-		return false;
-	}
-	data.Next();
-
-	if (!m_vec_itemTable.empty())
-	{
-		sys_log(0, "RELOAD: item_proto");
-		m_vec_itemTable.clear();
-		m_map_itemTableByVnum.clear();
-	}
-
-	data.Destroy();
-	if (!data.Load("item_proto.txt", '\t'))
-	{
-		fprintf(stderr, "Could not load item_proto.txt. Wrong file format?\n");
-		return false;
-	}
-	data.Next();
-
-	m_vec_itemTable.resize(data.m_File.GetRowCount() - 1);
-	memset(&m_vec_itemTable[0], 0, sizeof(TItemTable) * m_vec_itemTable.size());
-
-	TItemTable* item_table = &m_vec_itemTable[0];
-
-	while (data.Next())
-	{
-		if (!Set_Proto_Item_Table(item_table, data, localMap))
-		{
-			fprintf(stderr, "Invalid item table. VNUM: %d\n", item_table->dwVnum);
-		}
-
-		m_map_itemTableByVnum.insert(std::map<DWORD, TItemTable*>::value_type(item_table->dwVnum, item_table));
-		++item_table;
-	}
-	//_______________________________________________________________________//
-
-	m_map_itemTableByVnum.clear();
-
-	auto it = m_vec_itemTable.begin();
-	while (it != m_vec_itemTable.end())
-	{
-		TItemTable* item_table = &(*(it++));
-
-		sys_log(1, "ITEM: #%-5lu %-24s %-24s VAL: %ld %ld %ld %ld %ld %ld WEAR %lu ANTI %llu IMMUNE %lu REFINE %lu REFINE_SET %u ATTR67_MATERIAL %u MAGIC_PCT %u",
-			item_table->dwVnum,
-			item_table->szName,
-			item_table->szLocaleName,
-			item_table->alValues[0],
-			item_table->alValues[1],
-			item_table->alValues[2],
-			item_table->alValues[3],
-			item_table->alValues[4],
-			item_table->alValues[5],
-			item_table->dwWearFlags,
-			item_table->ullAntiFlags,
-			item_table->dwImmuneFlag,
-			item_table->dwRefinedVnum,
-			item_table->wRefineSet,
-			item_table->dw67AttrMaterial,
-			item_table->bAlterToMagicItemPct);
-
-		m_map_itemTableByVnum.insert(std::map<DWORD, TItemTable*>::value_type(item_table->dwVnum, item_table));
-	}
-	sort(m_vec_itemTable.begin(), m_vec_itemTable.end(), FCompareVnum());
-
-	return true;
-}
-
-bool CClientManager::InitializeSkillTable()
-{
-	char query[4096];
-	snprintf(query, sizeof(query),
-		"SELECT `dwVnum`, `szName`, `bType`, `bMaxLevel`, `dwSplashRange`, "
-		"`szPointOn`, `szPointPoly`, `szSPCostPoly`, `szDurationPoly`, `szDurationSPCostPoly`, "
-		"`szCooldownPoly`, `szMasterBonusPoly`, `setFlag`+0, `setAffectFlag`+0, "
-		"`szPointOn2`, `szPointPoly2`, `szDurationPoly2`, `setAffectFlag2`+0, "
-		"`szPointOn3`, `szPointPoly3`, `szDurationPoly3`, `szGrandMasterAddSPCostPoly`, "
-		"`bLevelStep`, `bLevelLimit`, `prerequisiteSkillVnum`, `prerequisiteSkillLevel`, `iMaxHit`, `szSplashAroundDamageAdjustPoly`, `eSkillType`+0, `dwTargetRange` "
-		"FROM skill_proto%s ORDER BY `dwVnum`",
-		GetTablePostfix());
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
-	SQLResult* pRes = pkMsg->Get();
-
-	if (!pRes->uiNumRows)
-	{
-		sys_err("no result from skill_proto");
-		return false;
-	}
-
-	if (!m_vec_skillTable.empty())
-	{
-		sys_log(0, "RELOAD: skill_proto");
-		m_vec_skillTable.clear();
-	}
-
-	m_vec_skillTable.reserve(pRes->uiNumRows);
-
-	MYSQL_ROW data;
-	int col;
-
-	while ((data = mysql_fetch_row(pRes->pSQLResult)))
-	{
-		TSkillTable t;
-		memset(&t, 0, sizeof(t));
-
-		col = 0;
-
-		str_to_number(t.dwVnum, data[col++]);
-		strlcpy(t.szName, data[col++], sizeof(t.szName));
-		str_to_number(t.bType, data[col++]);
-		str_to_number(t.bMaxLevel, data[col++]);
-		str_to_number(t.dwSplashRange, data[col++]);
-
-		strlcpy(t.szPointOn, data[col++], sizeof(t.szPointOn));
-		strlcpy(t.szPointPoly, data[col++], sizeof(t.szPointPoly));
-		strlcpy(t.szSPCostPoly, data[col++], sizeof(t.szSPCostPoly));
-		strlcpy(t.szDurationPoly, data[col++], sizeof(t.szDurationPoly));
-		strlcpy(t.szDurationSPCostPoly, data[col++], sizeof(t.szDurationSPCostPoly));
-		strlcpy(t.szCooldownPoly, data[col++], sizeof(t.szCooldownPoly));
-		strlcpy(t.szMasterBonusPoly, data[col++], sizeof(t.szMasterBonusPoly));
-
-		str_to_number(t.dwFlag, data[col++]);
-		str_to_number(t.dwAffectFlag, data[col++]);
-
-		strlcpy(t.szPointOn2, data[col++], sizeof(t.szPointOn2));
-		strlcpy(t.szPointPoly2, data[col++], sizeof(t.szPointPoly2));
-		strlcpy(t.szDurationPoly2, data[col++], sizeof(t.szDurationPoly2));
-		str_to_number(t.dwAffectFlag2, data[col++]);
-
-		// ADD_GRANDMASTER_SKILL
-		strlcpy(t.szPointOn3, data[col++], sizeof(t.szPointOn3));
-		strlcpy(t.szPointPoly3, data[col++], sizeof(t.szPointPoly3));
-		strlcpy(t.szDurationPoly3, data[col++], sizeof(t.szDurationPoly3));
-
-		strlcpy(t.szGrandMasterAddSPCostPoly, data[col++], sizeof(t.szGrandMasterAddSPCostPoly));
-		// END_OF_ADD_GRANDMASTER_SKILL
-
-		str_to_number(t.bLevelStep, data[col++]);
-		str_to_number(t.bLevelLimit, data[col++]);
-		str_to_number(t.preSkillVnum, data[col++]);
-		str_to_number(t.preSkillLevel, data[col++]);
-
-		str_to_number(t.lMaxHit, data[col++]);
-
-		strlcpy(t.szSplashAroundDamageAdjustPoly, data[col++], sizeof(t.szSplashAroundDamageAdjustPoly));
-
-		str_to_number(t.bSkillAttrType, data[col++]);
-		str_to_number(t.dwTargetRange, data[col++]);
-
-		sys_log(0, "SKILL: #%d %s flag %u point %s affect %u cooldown %s", t.dwVnum, t.szName, t.dwFlag, t.szPointOn, t.dwAffectFlag, t.szCooldownPoly);
-
-		m_vec_skillTable.push_back(t);
-	}
-
-	return true;
-}
-
-bool CClientManager::InitializeBanwordTable()
-{
-	m_vec_banwordTable.clear();
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery("SELECT word FROM banword"));
-
-	SQLResult* pRes = pkMsg->Get();
-
-	if (pRes->uiNumRows == 0)
-		return true;
-
-	MYSQL_ROW data;
-
-	while ((data = mysql_fetch_row(pRes->pSQLResult)))
-	{
-		TBanwordTable t;
-
-		if (data[0])
-		{
-			strlcpy(t.szWord, data[0], sizeof(t.szWord));
-			m_vec_banwordTable.push_back(t);
-		}
-	}
-
-	sys_log(0, "BANWORD: total %d", m_vec_banwordTable.size());
-	return true;
-}
-
-bool CClientManager::InitializeItemAttrTable()
-{
-	char query[4096];
-	snprintf(query, sizeof(query),
-		"SELECT `apply`, `apply`+0, `prob`, "
-		"`lv1`, `lv2`, `lv3`, `lv4`, `lv5`, "
-#if defined(__ATTR_6TH_7TH__)
-		"`lv6`, `lv7`, `lv8`, `lv9`, `lv10`, "
-#endif
-		"`weapon`, `body`, `wrist`, `foots`, `neck`, `head`, `shield`, `ear`"
-#if defined(__PENDANT_SYSTEM__)
-		", `pendant`"
-#endif
-#if defined(__GLOVE_SYSTEM__)
-		", `glove`"
-#endif
-#if defined(__COSTUME_SYSTEM__)
-		", `costume_body`"
-		", `costume_hair`"
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-		", `costume_weapon`"
-#endif
-#endif
-		" FROM item_attr%s ORDER BY `apply`",
-		GetTablePostfix()
-	);
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
-	SQLResult* pRes = pkMsg->Get();
-
-	if (!pRes->uiNumRows)
-	{
-		sys_err("no result from item_attr");
-		return false;
-	}
-
-	if (!m_vec_itemAttrTable.empty())
-	{
-		sys_log(0, "RELOAD: item_attr");
-		m_vec_itemAttrTable.clear();
-	}
-
-	m_vec_itemAttrTable.reserve(pRes->uiNumRows);
-
-	MYSQL_ROW data;
-
-	while ((data = mysql_fetch_row(pRes->pSQLResult)))
-	{
-		TItemAttrTable t;
-
-		memset(&t, 0, sizeof(TItemAttrTable));
-
-		int col = 0;
-
-		strlcpy(t.szApply, data[col++], sizeof(t.szApply));
-		str_to_number(t.wApplyIndex, data[col++]);
-		str_to_number(t.dwProb, data[col++]);
-		str_to_number(t.lValues[0], data[col++]);
-		str_to_number(t.lValues[1], data[col++]);
-		str_to_number(t.lValues[2], data[col++]);
-		str_to_number(t.lValues[3], data[col++]);
-		str_to_number(t.lValues[4], data[col++]);
-#if defined(__ATTR_6TH_7TH__)
-		str_to_number(t.lValues[5], data[col++]);
-		str_to_number(t.lValues[6], data[col++]);
-		str_to_number(t.lValues[7], data[col++]);
-		str_to_number(t.lValues[8], data[col++]);
-		str_to_number(t.lValues[9], data[col++]);
-#endif
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_WEAPON], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_BODY], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_WRIST], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_FOOTS], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_NECK], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_HEAD], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_SHIELD], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_EAR], data[col++]);
-#if defined(__PENDANT_SYSTEM__)
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_PENDANT], data[col++]);
-#endif
-#if defined(__GLOVE_SYSTEM__)
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_GLOVE], data[col++]);
-#endif
-#if defined(__COSTUME_SYSTEM__)
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_BODY], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_HAIR], data[col++]);
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_WEAPON], data[col++]);
-#endif
-#endif
-
-		if (!m_bWolfmanCharacter)
-		{
-			const char* szWolfApply[6] = {
-				"BLEEDING_REDUCE",
-				"BLEEDING_PCT",
-				"ATT_BONUS_TO_WOLFMAN",
-				"RESIST_WOLFMAN"
-				"RESIST_CLAW",
-#if defined(__ELEMENT_SYSTEM__)
-				"RESIST_CLAW_REDUCTION",
-#endif
-			};
-			for (int i = 0; i < _countof(szWolfApply); ++i)
-				if (strcmp(t.szApply, szWolfApply[i]) == 0)
-					continue;
-		}
-
-		sys_log(0, "ITEM_RARE: %-20s %4lu { %3d %3d %3d %3d %3d "
-#if defined(__ATTR_6TH_7TH__)
-			"%3d %3d %3d %3d %3d"
-#endif
-			"} { %d %d %d %d %d %d %d "
-#if defined(__PENDANT_SYSTEM__)
-			"%d "
-#endif
-#if defined(__GLOVE_SYSTEM__)
-			"%d "
-#endif
-#if defined(__COSTUME_SYSTEM__)
-			"%d "
-			"%d "
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-			"%d "
-#endif
-#endif
-			"}"
-			, t.szApply
-			, t.dwProb
-			, t.lValues[0], t.lValues[1], t.lValues[2], t.lValues[3], t.lValues[4]
-#if defined(__ATTR_6TH_7TH__)
-			, t.lValues[5], t.lValues[6], t.lValues[7], t.lValues[8], t.lValues[9]
-#endif
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_WEAPON]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_BODY]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_WRIST]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_FOOTS]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_NECK]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_HEAD]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_SHIELD]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_EAR]
-#if defined(__PENDANT_SYSTEM__)
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_PENDANT]
-#endif
-#if defined(__GLOVE_SYSTEM__)
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_GLOVE]
-#endif
-#if defined(__COSTUME_SYSTEM__)
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_BODY]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_HAIR]
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_WEAPON]
-#endif
-#endif
-		);
-
-		m_vec_itemAttrTable.push_back(t);
-	}
-
-	return true;
-}
-
-bool CClientManager::InitializeItemRareTable()
-{
-	char query[4096];
-	snprintf(query, sizeof(query),
-		"SELECT `apply`, `apply`+0, `prob`, "
-		"`lv1`, `lv2`, `lv3`, `lv4`, `lv5`, "
-#if defined(__ATTR_6TH_7TH__)
-		"`lv6`, `lv7`, `lv8`, `lv9`, `lv10`, "
-#endif
-		"`weapon`, `body`, `wrist`, `foots`, `neck`, `head`, `shield`, `ear`"
-#if defined(__PENDANT_SYSTEM__)
-		", `pendant`"
-#endif
-#if defined(__GLOVE_SYSTEM__)
-		", `glove`"
-#endif
-		" FROM item_attr_rare%s ORDER BY `apply`",
-		GetTablePostfix()
-	);
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
-	SQLResult* pRes = pkMsg->Get();
-
-	if (!pRes->uiNumRows)
-	{
-		sys_err("no result from item_attr_rare");
-		return false;
-	}
-
-	if (!m_vec_itemRareTable.empty())
-	{
-		sys_log(0, "RELOAD: item_attr_rare");
-		m_vec_itemRareTable.clear();
-	}
-
-	m_vec_itemRareTable.reserve(pRes->uiNumRows);
-
-	MYSQL_ROW data;
-
-	while ((data = mysql_fetch_row(pRes->pSQLResult)))
-	{
-		TItemAttrTable t;
-
-		memset(&t, 0, sizeof(TItemAttrTable));
-
-		int col = 0;
-
-		strlcpy(t.szApply, data[col++], sizeof(t.szApply));
-		str_to_number(t.wApplyIndex, data[col++]);
-		str_to_number(t.dwProb, data[col++]);
-		str_to_number(t.lValues[0], data[col++]);
-		str_to_number(t.lValues[1], data[col++]);
-		str_to_number(t.lValues[2], data[col++]);
-		str_to_number(t.lValues[3], data[col++]);
-		str_to_number(t.lValues[4], data[col++]);
-#if defined(__ATTR_6TH_7TH__)
-		str_to_number(t.lValues[5], data[col++]);
-		str_to_number(t.lValues[6], data[col++]);
-		str_to_number(t.lValues[7], data[col++]);
-		str_to_number(t.lValues[8], data[col++]);
-		str_to_number(t.lValues[9], data[col++]);
-#endif
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_WEAPON], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_BODY], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_WRIST], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_FOOTS], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_NECK], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_HEAD], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_SHIELD], data[col++]);
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_EAR], data[col++]);
-#if defined(__PENDANT_SYSTEM__)
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_PENDANT], data[col++]);
-#endif
-#if defined(__GLOVE_SYSTEM__)
-		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_GLOVE], data[col++]);
-#endif
-
-		sys_log(0, "ITEM_RARE: %-20s %4lu { %3d %3d %3d %3d %3d "
-#if defined(__ATTR_6TH_7TH__)
-			"%3d %3d %3d %3d %3d"
-#endif
-			"} { %d %d %d %d %d %d %d "
-#if defined(__PENDANT_SYSTEM__)
-			"%d "
-#endif
-#if defined(__GLOVE_SYSTEM__)
-			"%d "
-#endif
-			"}"
-			, t.szApply, t.dwProb
-			, t.lValues[0], t.lValues[1], t.lValues[2], t.lValues[3], t.lValues[4]
-#if defined(__ATTR_6TH_7TH__)
-			, t.lValues[5], t.lValues[6], t.lValues[7], t.lValues[8], t.lValues[9]
-#endif
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_WEAPON]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_BODY]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_WRIST]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_FOOTS]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_NECK]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_HEAD]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_SHIELD]
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_EAR]
-#if defined(__PENDANT_SYSTEM__)
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_PENDANT]
-#endif
-#if defined(__GLOVE_SYSTEM__)
-			, t.bMaxLevelBySet[ATTRIBUTE_SET_GLOVE]
-#endif
-		);
-
-		m_vec_itemRareTable.push_back(t);
-	}
-
-	return true;
-}
-
-bool CClientManager::InitializeLandTable()
-{
-	using namespace building;
-
-	char query[4096];
-
-	snprintf(query, sizeof(query),
-		"SELECT `id`, `map_index`, `x`, `y`, `width`, `height`, `guild_id`, `guild_level_limit`, `price` "
-		"FROM land%s WHERE `enable` = 'YES' ORDER BY `id`",
-		GetTablePostfix());
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
-	SQLResult* pRes = pkMsg->Get();
-
-	if (!m_vec_kLandTable.empty())
-	{
-		sys_log(0, "RELOAD: land");
-		m_vec_kLandTable.clear();
-	}
-
-	m_vec_kLandTable.reserve(pRes->uiNumRows);
-
-	MYSQL_ROW data;
-
-	if (pRes->uiNumRows > 0)
-		while ((data = mysql_fetch_row(pRes->pSQLResult)))
-		{
-			TLand t;
-
-			memset(&t, 0, sizeof(t));
-
-			int col = 0;
-
-			str_to_number(t.dwID, data[col++]);
-			str_to_number(t.lMapIndex, data[col++]);
-			str_to_number(t.x, data[col++]);
-			str_to_number(t.y, data[col++]);
-			str_to_number(t.width, data[col++]);
-			str_to_number(t.height, data[col++]);
-			str_to_number(t.dwGuildID, data[col++]);
-			str_to_number(t.bGuildLevelLimit, data[col++]);
-			str_to_number(t.dwPrice, data[col++]);
-
-			sys_log(0, "LAND: %lu map %-4ld %7ldx%-7ld w %-4ld h %-4ld", t.dwID, t.lMapIndex, t.x, t.y, t.width, t.height);
-
-			m_vec_kLandTable.push_back(t);
-		}
-
-	return true;
-}
-
-void parse_pair_number_string(const char* c_pszString, std::vector<std::pair<int, int> >& vec)
-{
-	// format: 10,1/20,3/300,50
-	const char* t = c_pszString;
-	const char* p = strchr(t, '/');
-	std::pair<int, int> k;
-
-	char szNum[32 + 1];
-	char* comma;
-
-	while (p)
-	{
-		if (isnhdigit(*t))
-		{
-			strlcpy(szNum, t, MIN(sizeof(szNum), (p - t) + 1));
-
-			comma = strchr(szNum, ',');
-
-			if (comma)
-			{
-				*comma = '\0';
-				str_to_number(k.second, comma + 1);
-			}
-			else
-				k.second = 0;
-
-			str_to_number(k.first, szNum);
-			vec.push_back(k);
-		}
-
-		t = p + 1;
-		p = strchr(t, '/');
-	}
-
-	if (isnhdigit(*t))
-	{
-		strlcpy(szNum, t, sizeof(szNum));
-
-		comma = strchr(const_cast<char*>(t), ',');
-
-		if (comma)
-		{
-			*comma = '\0';
-			str_to_number(k.second, comma + 1);
-		}
-		else
-			k.second = 0;
-
-		str_to_number(k.first, szNum);
-		vec.push_back(k);
-	}
-}
-
-bool CClientManager::InitializeObjectProto()
-{
-	using namespace building;
-
-	char query[4096];
-	snprintf(query, sizeof(query),
-		"SELECT `vnum`, `price`, `materials`, `upgrade_vnum`, `upgrade_limit_time`, `life`, `reg_1`, `reg_2`, `reg_3`, `reg_4`, `npc`, `group_vnum`, `dependent_group` "
-		"FROM object_proto%s ORDER BY `vnum`",
-		GetTablePostfix());
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
-	SQLResult* pRes = pkMsg->Get();
-
-	if (!m_vec_kObjectProto.empty())
-	{
-		sys_log(0, "RELOAD: object_proto");
-		m_vec_kObjectProto.clear();
-	}
-
-	m_vec_kObjectProto.reserve(MAX(0, pRes->uiNumRows));
-
-	MYSQL_ROW data;
-
-	if (pRes->uiNumRows > 0)
-	{
-		while ((data = mysql_fetch_row(pRes->pSQLResult)))
-		{
-			TObjectProto t;
-
-			memset(&t, 0, sizeof(t));
-
-			int col = 0;
-
-			str_to_number(t.dwVnum, data[col++]);
-			str_to_number(t.dwPrice, data[col++]);
-
-			std::vector<std::pair<int, int> > vec;
-			parse_pair_number_string(data[col++], vec);
-
-			for (unsigned int i = 0; i < OBJECT_MATERIAL_MAX_NUM && i < vec.size(); ++i)
-			{
-				std::pair<int, int>& r = vec[i];
-
-				t.kMaterials[i].dwItemVnum = r.first;
-				t.kMaterials[i].dwCount = r.second;
-			}
-
-			str_to_number(t.dwUpgradeVnum, data[col++]);
-			str_to_number(t.dwUpgradeLimitTime, data[col++]);
-			str_to_number(t.lLife, data[col++]);
-			str_to_number(t.lRegion[0], data[col++]);
-			str_to_number(t.lRegion[1], data[col++]);
-			str_to_number(t.lRegion[2], data[col++]);
-			str_to_number(t.lRegion[3], data[col++]);
-
-			// ADD_BUILDING_NPC
-			str_to_number(t.dwNPCVnum, data[col++]);
-			str_to_number(t.dwGroupVnum, data[col++]);
-			str_to_number(t.dwDependOnGroupVnum, data[col++]);
-
-			t.lNPCX = 0;
-			t.lNPCY = MAX(t.lRegion[1], t.lRegion[3]) + 300;
-			// END_OF_ADD_BUILDING_NPC
-
-			sys_log(0, "OBJ_PROTO: vnum %lu price %lu mat %lu %lu",
-				t.dwVnum, t.dwPrice, t.kMaterials[0].dwItemVnum, t.kMaterials[0].dwCount);
-
-			m_vec_kObjectProto.push_back(t);
-		}
-	}
-
-	return true;
-}
-
-bool CClientManager::InitializeObjectTable()
-{
-	using namespace building;
-
-	char query[4096];
-	snprintf(query, sizeof(query), "SELECT `id`, `land_id`, `vnum`, `map_index`, `x`, `y`, `x_rot`, `y_rot`, `z_rot`, `life` FROM object%s ORDER BY `id`", GetTablePostfix());
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
-	SQLResult* pRes = pkMsg->Get();
-
-	if (!m_map_pkObjectTable.empty())
-	{
-		sys_log(0, "RELOAD: object");
-		m_map_pkObjectTable.clear();
-	}
-
-	MYSQL_ROW data;
-
-	if (pRes->uiNumRows > 0)
-		while ((data = mysql_fetch_row(pRes->pSQLResult)))
-		{
-			TObject* k = new TObject;
-
-			memset(k, 0, sizeof(TObject));
-
-			int col = 0;
-
-			str_to_number(k->dwID, data[col++]);
-			str_to_number(k->dwLandID, data[col++]);
-			str_to_number(k->dwVnum, data[col++]);
-			str_to_number(k->lMapIndex, data[col++]);
-			str_to_number(k->x, data[col++]);
-			str_to_number(k->y, data[col++]);
-			str_to_number(k->xRot, data[col++]);
-			str_to_number(k->yRot, data[col++]);
-			str_to_number(k->zRot, data[col++]);
-			str_to_number(k->lLife, data[col++]);
-
-			sys_log(0, "OBJ: %lu vnum %lu map %-4ld %7ldx%-7ld life %ld",
-				k->dwID, k->dwVnum, k->lMapIndex, k->x, k->y, k->lLife);
-
-			m_map_pkObjectTable.insert(std::make_pair(k->dwID, k));
-		}
-
-	return true;
-}
-
-bool CClientManager::InitializeMonarch()
-{
-	CMonarch::instance().LoadMonarch();
-
-	return true;
-}
-
-#if defined(__EXPRESSING_EMOTIONS__)
-bool CClientManager::InitializeEmoteTable()
-{
-	if (m_map_kPlayerEmote.empty() == false)
-		return true;
-
-	char szQuery[1024];
-	sprintf(szQuery, "SELECT `pid`, `vnum`, UNIX_TIMESTAMP(`duration`) FROM emotions%s", GetTablePostfix());
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(szQuery));
-	const SQLResult* pkRes = pkMsg->Get();
-	if (!pkRes->uiNumRows)
-		return true;
-
-	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
-
-	MYSQL_ROW kData;
-	while ((kData = mysql_fetch_row(pkRes->pSQLResult)))
-	{
-		BYTE bColumn = 0; TPacketGDEmote kTable;
-
-		str_to_number(kTable.dwPID, kData[bColumn++]);
-		str_to_number(kTable.dwVnum, kData[bColumn++]);
-		str_to_number(kTable.dwDuration, kData[bColumn++]);
-
-		if (dwCurrentTime > kTable.dwDuration)
-			continue;
-	
-		m_map_kPlayerEmote[kTable.dwPID].emplace_back(kTable);
-	}
-
-	return true;
-}
-#endif
-
-#if defined(__MAILBOX__)
-bool CClientManager::InitializeMailBoxTable()
-{
-	if (m_map_mailbox.empty() == false)
-		return true;
-
-	char szQuery[QUERY_MAX_LEN];
-	int len = sprintf(szQuery, "SELECT `name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`"
-		", `gold`, `won`, `vnum`, `count`"
-	);
-
-	for (BYTE i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
-		len += sprintf(szQuery + len, ", `socket%u`", i);
-
-	for (BYTE i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; i++)
-		len += sprintf(szQuery + len, ", `attrtype%u`, `attrvalue%u`", i, i);
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	len += sprintf(szQuery + len, ", `changelookvnum`");
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	len += sprintf(szQuery + len,
-		", `refine_element_apply_type`"
-		", `refine_element_grade`"
-		", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-		", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-	);
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-	for (BYTE i = 0; i < ITEM_APPLY_MAX_NUM; i++)
-		len += sprintf(szQuery + len, ", `apply_type%u`, `apply_value%u`, `apply_path%u`", i, i, i);
-#endif
-
-#if defined(__SET_ITEM__)
-	len += sprintf(szQuery + len, ", `set_value`");
-#endif
-
-	len += sprintf(szQuery + len, " FROM `mailbox%s`", GetTablePostfix());
-
-	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(szQuery));
-	const SQLResult* pRes = pkMsg->Get();
-	if (!pRes->uiNumRows)
-		return true;
-
-	MYSQL_ROW data;
-	while ((data = mysql_fetch_row(pRes->pSQLResult)))
-	{
-		uint8_t col = 0;
-		SMailBoxTable mail;
-
-		auto name = data[col++];
-		mail.bIsDeleted = false;
-		mail.AddData.bHeader = 0;
-		mail.AddData.Index = 0;
-
-		std::memcpy(mail.szName, name, sizeof(mail.szName));
-		std::memcpy(mail.AddData.szFrom, data[col++], sizeof(mail.AddData.szFrom));
-		std::memcpy(mail.Message.szTitle, data[col++], sizeof(mail.Message.szTitle));
-		std::memcpy(mail.AddData.szMessage, data[col++], sizeof(mail.AddData.szMessage));
-		str_to_number(mail.Message.bIsGMPost, data[col++]);
-		str_to_number(mail.Message.bIsConfirm, data[col++]);
-		str_to_number(mail.Message.SendTime, data[col++]);
-		str_to_number(mail.Message.DeleteTime, data[col++]);
-		str_to_number(mail.AddData.iYang, data[col++]);
-		str_to_number(mail.AddData.iWon, data[col++]);
-		str_to_number(mail.AddData.dwItemVnum, data[col++]);
-		str_to_number(mail.AddData.dwItemCount, data[col++]);
-
-		mail.Message.bIsItemExist = mail.AddData.dwItemVnum > 0 || mail.AddData.iYang > 0 || mail.AddData.iWon > 0;
-
-		for (BYTE i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
-			str_to_number(mail.AddData.alSockets[i], data[col++]);
-
-		for (BYTE i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; i++)
-		{
-			str_to_number(mail.AddData.aAttr[i].wType, data[col++]);
-			str_to_number(mail.AddData.aAttr[i].lValue, data[col++]);
-		}
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		str_to_number(mail.AddData.dwChangeLookVnum, data[col++]);
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		str_to_number(mail.AddData.RefineElement.wApplyType, data[col++]);
-		str_to_number(mail.AddData.RefineElement.bGrade, data[col++]);
-		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
-			str_to_number(mail.AddData.RefineElement.abValue[i], data[col++]);
-		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
-			str_to_number(mail.AddData.RefineElement.abBonusValue[i], data[col++]);
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-		for (BYTE i = 0; i < ITEM_APPLY_MAX_NUM; i++)
-		{
-			str_to_number(mail.AddData.aApplyRandom[i].wType, data[col++]);
-			str_to_number(mail.AddData.aApplyRandom[i].lValue, data[col++]);
-			str_to_number(mail.AddData.aApplyRandom[i].bPath, data[col++]);
-		}
-#endif
-
-#if defined(__SET_ITEM__)
-		str_to_number(mail.AddData.bSetValue, data[col++]);
-#endif
-
-		m_map_mailbox[name].emplace_back(mail);
-	}
-
-	return true;
-}
-#endif
-
-#if defined(__GEM_SHOP__)
-bool CClientManager::InitializeGemShopTable()
-{
-	// Load Default Gem Shop Table
-	{
-		if (m_mapGemShopTable.empty() == false)
-			return true;
-
-		char szQuery[1024];
-		int iLen = sprintf(szQuery, "SELECT `pid`, UNIX_TIMESTAMP(`refresh_time`), `enabled_slots`");
-
-		for (BYTE i = 0; i < GEM_SHOP_SLOT_COUNT; i++)
-			iLen += sprintf(szQuery + iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`", i, i, i, i);
-
-		iLen += sprintf(szQuery + iLen, " FROM `gem_shop%s`", GetTablePostfix());
-
-		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(szQuery));
-		const SQLResult* c_pRes = pMsg->Get();
-		if (!c_pRes->uiNumRows)
-			return true;
-
-		MYSQL_ROW RowData;
-		while ((RowData = mysql_fetch_row(c_pRes->pSQLResult)))
-		{
-			uint8_t iColumn = 0;
-			SGemShopTable GemShopTable;
-#if defined(__CONQUEROR_LEVEL__)
-			GemShopTable.bSpecial = false;
-#endif
-
-			str_to_number(GemShopTable.dwPID, RowData[iColumn++]);
-			str_to_number(GemShopTable.lRefreshTime, RowData[iColumn++]);
-			str_to_number(GemShopTable.bEnabledSlots, RowData[iColumn++]);
-			for (BYTE i = 0; i < GEM_SHOP_SLOT_COUNT; i++)
-			{
-				str_to_number(GemShopTable.GemShopItem[i].bEnable, RowData[iColumn++]);
-				str_to_number(GemShopTable.GemShopItem[i].dwItemVnum, RowData[iColumn++]);
-				str_to_number(GemShopTable.GemShopItem[i].bCount, RowData[iColumn++]);
-				str_to_number(GemShopTable.GemShopItem[i].dwPrice, RowData[iColumn++]);
-			}
-			m_mapGemShopTable.emplace(std::make_pair(GemShopTable.dwPID, GemShopTable));
-		}
-	}
-
-#	if defined(__CONQUEROR_LEVEL__)
-	// Load Port (Special) Gem Shop Table
-	{
-		if (m_mapGemShopSpecialTable.empty() == false)
-			return true;
-
-		char szQuery[1024];
-		int iLen = sprintf(szQuery, "SELECT `pid`, UNIX_TIMESTAMP(`refresh_time`), `enabled_slots`");
-
-		for (BYTE i = 0; i < GEM_SHOP_SLOT_COUNT; i++)
-			iLen += sprintf(szQuery + iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`", i, i, i, i);
-
-		iLen += sprintf(szQuery + iLen, " FROM `gem_shop_port%s`", GetTablePostfix());
-
-		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(szQuery));
-		const SQLResult* c_pRes = pMsg->Get();
-		if (!c_pRes->uiNumRows)
-			return true;
-
-		MYSQL_ROW RowData;
-		while ((RowData = mysql_fetch_row(c_pRes->pSQLResult)))
-		{
-			uint8_t iColumn = 0;
-			SGemShopTable GemShopTable;
-			GemShopTable.bSpecial = true;
-
-			str_to_number(GemShopTable.dwPID, RowData[iColumn++]);
-			str_to_number(GemShopTable.lRefreshTime, RowData[iColumn++]);
-			str_to_number(GemShopTable.bEnabledSlots, RowData[iColumn++]);
-			for (BYTE i = 0; i < GEM_SHOP_SLOT_COUNT; i++)
-			{
-				str_to_number(GemShopTable.GemShopItem[i].bEnable, RowData[iColumn++]);
-				str_to_number(GemShopTable.GemShopItem[i].dwItemVnum, RowData[iColumn++]);
-				str_to_number(GemShopTable.GemShopItem[i].bCount, RowData[iColumn++]);
-				str_to_number(GemShopTable.GemShopItem[i].dwPrice, RowData[iColumn++]);
-			}
-			m_mapGemShopSpecialTable.emplace(std::make_pair(GemShopTable.dwPID, GemShopTable));
-		}
-	}
-#	endif
-
-	return true;
-}
-#endif
-
-#ifdef __OFFLINE_SHOP__
-void CClientManager::InitializeOfflineShops()
-{
-	std::stringstream shopQuery;
-	shopQuery << "SELECT id, owner_pid, owner_name, name, name_change_time, channel, map_index, x, y, deco_race, deco_board, opening_time, gold FROM offline_shop" << GetTablePostfix();
-
-	std::unique_ptr<SQLMsg> msg(CDBManager::Instance().DirectQuery(shopQuery.str().c_str()));
-	if (!msg) {
-		return;
-	}
-
-	auto result = msg->Get();
-	if (!result || result->uiNumRows < 1) {
-		return;
-	}
-
-	while (auto shopData = mysql_fetch_row(result->pSQLResult)) {
-		size_t col = 0;
-
-		TOfflineShop shop;
-#define NUMBER_FROM_RESULT(field) str_to_number(shop.field, shopData[col++]);
-		NUMBER_FROM_RESULT(id);
-		NUMBER_FROM_RESULT(ownerPid);
-
-		std::string ownerName(shopData[col++]);
-		std::fill(shop.ownerName.begin(), shop.ownerName.end(), '\0');
-		std::copy(ownerName.begin(), ownerName.end(), shop.ownerName.begin());
-
-		std::string shopName(shopData[col++]);
-		std::fill(shop.shopName.begin(), shop.shopName.end(), '\0');
-		std::copy(shopName.begin(), shopName.end(), shop.shopName.begin());
-
-		NUMBER_FROM_RESULT(shopNameChangeTime);
-		NUMBER_FROM_RESULT(channel);
-		NUMBER_FROM_RESULT(mapIndex);
-		NUMBER_FROM_RESULT(x);
-		NUMBER_FROM_RESULT(y);
-		NUMBER_FROM_RESULT(decoRace);
-		NUMBER_FROM_RESULT(decoBoard);
-		NUMBER_FROM_RESULT(openingTime);
-		NUMBER_FROM_RESULT(gold);
-#undef NUMBER_FROM_RESULT
-
-		SaveOfflineShop(shop, true);
-
-
-		std::stringstream itemQuery;
-		itemQuery << "SELECT owner_pid, position, vnum, count, ";
-
-		for (size_t i = 0; i < ITEM_SOCKET_MAX_NUM; ++i) {
-			itemQuery << "socket" << i << ", ";
-		}
-
-		for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i) {
-			itemQuery << "attrtype" << i << ", " << "attrvalue" << i << ", ";
-		}
-
-#if defined(__ITEM_APPLY_RANDOM__)
-		for (size_t i = 0; i < ITEM_APPLY_MAX_NUM; ++i) {
-			itemQuery << "apply_type" << i << ", apply_value" << i << ", apply_path" << i << ", ";
-		}
-#endif
-
-		itemQuery << "transmutation, soulbind, ";
-
-		itemQuery << "price FROM offline_shop_item" << GetTablePostfix() << " WHERE owner_pid = " << shop.id;
-
-		std::unique_ptr<SQLMsg> itemMsg(CDBManager::Instance().DirectQuery(itemQuery.str().c_str()));
-		if (!itemMsg) {
-			continue;
-		}
-
-		auto itemResult = itemMsg->Get();
-		if (!itemResult || itemResult->uiNumRows < 1) {
-			continue;
-		}
-
-		while (auto itemData = mysql_fetch_row(itemResult->pSQLResult)) {
-			col = 0;
-
-			TOfflineShopItem item;
-#define NUMBER_FROM_RESULT(field) str_to_number(item.field, itemData[col++]);
-			NUMBER_FROM_RESULT(id.first);
-			NUMBER_FROM_RESULT(id.second);
-			NUMBER_FROM_RESULT(vnum);
-			NUMBER_FROM_RESULT(count);
-
-			for (size_t i = 0; i < ITEM_SOCKET_MAX_NUM; ++i) {
-				NUMBER_FROM_RESULT(sockets[i]);
-			}
-
-			for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i) {
-				NUMBER_FROM_RESULT(attributes[i].wType);
-				NUMBER_FROM_RESULT(attributes[i].lValue);
-			}
-#if defined(__ITEM_APPLY_RANDOM__)
-			for (size_t i = 0; i < ITEM_APPLY_MAX_NUM; ++i) {
-				NUMBER_FROM_RESULT(ApplyRandom[i].wType);
-				NUMBER_FROM_RESULT(ApplyRandom[i].lValue);
-				NUMBER_FROM_RESULT(ApplyRandom[i].bPath);
-			}
-#endif
-			NUMBER_FROM_RESULT(dwTransmutationVnum);
-			NUMBER_FROM_RESULT(soulbind);
-
-			NUMBER_FROM_RESULT(price);
-#undef NUMBER_FROM_RESULT
-
-			SaveOfflineShopItem(item, true);
-		}
-	}
-
-	sys_log(0, "Initialized %u offline shops with %u items.", offlineShopCache_.size(), offlineShopItemCache_.size());
-}
-#endif
+#include <map>
+#include "stdafx.h"
+#include "ClientManager.h"
+#include "Main.h"
+#include "Monarch.h"
+#include <cstdarg>
+
+// Safe query builder to prevent sprintf overflow in dynamic SELECT composition.
+static bool SafeAppend(char* buf, size_t cap, int& len, const char* fmt, ...)
+{
+	if (!buf || cap == 0) return false;
+	if (len < 0 || (size_t)len >= cap) return false;
+	va_list ap;
+	va_start(ap, fmt);
+	int n = vsnprintf(buf + len, cap - (size_t)len, fmt, ap);
+	va_end(ap);
+	if (n < 0) return false;
+	if ((size_t)n >= cap - (size_t)len) return false;
+	len += n;
+	return true;
+}
+#include "CsvReader.h"
+#include "ProtoReader.h"
+
+using namespace std;
+
+extern int g_test_server;
+extern std::string g_stLocaleNameColumn;
+
+bool CClientManager::InitializeTables()
+{
+	if (!InitializeMobTable())
+	{
+		sys_err("InitializeMobTable FAILED");
+		return false;
+	}
+
+	if (!InitializeItemTable())
+	{
+		sys_err("InitializeItemTable FAILED");
+		return false;
+	}
+
+	if (!InitializeShopTable())
+	{
+		sys_err("InitializeShopTable FAILED");
+		return false;
+	}
+
+#if defined(__GEM_SHOP__)
+	if (!InitializeGemShopTable())
+	{
+		sys_err("InitializeGemShopTable FAILED");
+		return false;
+	}
+#endif
+
+	if (!InitializeSkillTable())
+	{
+		sys_err("InitializeSkillTable FAILED");
+		return false;
+	}
+
+	if (!InitializeRefineTable())
+	{
+		sys_err("InitializeRefineTable FAILED");
+		return false;
+	}
+
+	if (!InitializeItemAttrTable())
+	{
+		sys_err("InitializeItemAttrTable FAILED");
+		return false;
+	}
+
+	if (!InitializeItemRareTable())
+	{
+		sys_err("InitializeItemRareTable FAILED");
+		return false;
+	}
+
+	if (!InitializeBanwordTable())
+	{
+		sys_err("InitializeBanwordTable FAILED");
+		return false;
+	}
+
+	if (!InitializeLandTable())
+	{
+		sys_err("InitializeLandTable FAILED");
+		return false;
+	}
+
+	if (!InitializeObjectProto())
+	{
+		sys_err("InitializeObjectProto FAILED");
+		return false;
+	}
+
+	if (!InitializeObjectTable())
+	{
+		sys_err("InitializeObjectTable FAILED");
+		return false;
+	}
+
+	if (!InitializeMonarch())
+	{
+		sys_err("InitializeMonarch FAILED");
+		return false;
+	}
+
+#if defined(__MAILBOX__)
+	if (!InitializeMailBoxTable())
+	{
+		sys_err("InitializeMailBoxTable FAILED");
+		return false;
+	}
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+	if (!InitializeEmoteTable())
+	{
+		sys_err("InitializeEmoteTable FAILED");
+		return false;
+	}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (!InitializeGrowthPetSkillTable())
+	{
+		sys_err("InitializeGrowthPetSkillTable FAILED");
+		return false;
+	}
+#endif
+
+#ifdef __OFFLINE_SHOP__
+		InitializeOfflineShops();
+#endif
+
+	return true;
+}
+
+#ifdef __GROWTH_PET_SYSTEM__
+bool CClientManager::InitializeGrowthPetSkillTable()
+{
+	char query[4096];
+	snprintf(query, sizeof(query), 
+		"SELECT dwPetVnum, dwSkillVnum, szName, bType+0, dwCooldown, setAffectFlag+0, szPointOn," 
+		"szPointPoly1, szPointPoly2, szPointPoly3, szPointPoly4, szPointPoly5, szPointPoly6, "
+		"szPointPoly7, szPointPoly8, szActivatePctPoly, szDurationPoly "
+		"FROM growth_pet_skill_proto%s", GetTablePostfix());
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
+	SQLResult* pRes = pkMsg->Get();
+
+	if (!m_vec_growthPetSkillTable.empty())
+	{
+		sys_log(0, "RELOAD: growth pet skill");
+		m_vec_growthPetSkillTable.clear();
+	}
+
+	m_vec_growthPetSkillTable.reserve(pRes->uiNumRows);
+
+	MYSQL_ROW data;
+	TGrowthPetSkillTable t;
+
+	if (pRes->uiNumRows > 0)
+	{
+		while ((data = mysql_fetch_row(pRes->pSQLResult)))
+		{
+			memset(&t, 0, sizeof(t));
+
+			int col = 0;
+
+			str_to_number(t.dwPetVnum, data[col++]);
+			str_to_number(t.dwSkillVnum, data[col++]);
+			strlcpy(t.szName, data[col++], sizeof(t.szName));
+			str_to_number(t.bType, data[col++]);
+			str_to_number(t.dwCooldown, data[col++]);
+			str_to_number(t.dwAffectFlag, data[col++]);
+			strlcpy(t.szPointOn, data[col++], sizeof(t.szPointOn));
+			strlcpy(t.szPointPoly1, data[col++], sizeof(t.szPointPoly1));
+			strlcpy(t.szPointPoly2, data[col++], sizeof(t.szPointPoly2));
+			strlcpy(t.szPointPoly3, data[col++], sizeof(t.szPointPoly3));
+			strlcpy(t.szPointPoly4, data[col++], sizeof(t.szPointPoly4));
+			strlcpy(t.szPointPoly5, data[col++], sizeof(t.szPointPoly5));
+			strlcpy(t.szPointPoly6, data[col++], sizeof(t.szPointPoly6));
+			strlcpy(t.szPointPoly7, data[col++], sizeof(t.szPointPoly7));
+			strlcpy(t.szPointPoly8, data[col++], sizeof(t.szPointPoly8));
+			strlcpy(t.szActivatePctPoly, data[col++], sizeof(t.szActivatePctPoly));
+			strlcpy(t.szDurationPoly, data[col++], sizeof(t.szDurationPoly));
+
+			sys_log(0, "GROWTH PET SKILL: PET %u  SKILL %u", t.dwPetVnum, t.dwSkillVnum);
+
+			m_vec_growthPetSkillTable.push_back(t);
+		}
+	}
+	else
+		return false;
+
+	return true;
+}
+#endif
+
+bool CClientManager::InitializeRefineTable()
+{
+	char query[2048];
+
+	snprintf(query, sizeof(query),
+		"SELECT `id`, `cost`, `prob`, `vnum0`, `count0`, `vnum1`, `count1`, `vnum2`, `count2`, `vnum3`, `count3`, `vnum4`, `count4` FROM refine_proto%s",
+		GetTablePostfix());
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
+	SQLResult* pRes = pkMsg->Get();
+
+	if (!pRes->uiNumRows)
+		return true;
+
+	if (m_pRefineTable)
+	{
+		sys_log(0, "RELOAD: refine_proto");
+		delete[] m_pRefineTable;
+		m_pRefineTable = NULL;
+	}
+
+	m_iRefineTableSize = pRes->uiNumRows;
+
+	m_pRefineTable = new TRefineTable[m_iRefineTableSize];
+	memset(m_pRefineTable, 0, sizeof(TRefineTable) * m_iRefineTableSize);
+
+	TRefineTable* prt = m_pRefineTable;
+	MYSQL_ROW data;
+
+	while ((data = mysql_fetch_row(pRes->pSQLResult)))
+	{
+		// const char* s_szQuery = "SELECT src_vnum, result_vnum, cost, prob, "
+		// "vnum0, count0, vnum1, count1, vnum2, count2, vnum3, count3, vnum4, count4 "
+
+		int col = 0;
+		// prt->src_vnum = atoi(data[col++]);
+		// prt->result_vnum = atoi(data[col++]);
+		str_to_number(prt->id, data[col++]);
+		str_to_number(prt->cost, data[col++]);
+		str_to_number(prt->prob, data[col++]);
+
+		prt->material_count = REFINE_MATERIAL_MAX_NUM;
+
+		for (int i = 0; i < REFINE_MATERIAL_MAX_NUM; i++)
+		{
+			str_to_number(prt->materials[i].vnum, data[col++]);
+			str_to_number(prt->materials[i].count, data[col++]);
+			if (prt->materials[i].vnum == 0)
+			{
+				prt->material_count = i;
+				break;
+			}
+		}
+
+		sys_log(0, "REFINE: id %ld cost %d prob %d mat1 %lu cnt1 %d", prt->id, prt->cost, prt->prob, prt->materials[0].vnum, prt->materials[0].count);
+
+		prt++;
+	}
+	return true;
+}
+
+class FCompareVnum
+{
+public:
+	bool operator () (const TEntityTable& a, const TEntityTable& b) const
+	{
+		return (a.dwVnum < b.dwVnum);
+	}
+};
+
+bool CClientManager::InitializeMobTable()
+{
+	map<int, const char*> localMap;
+
+	cCsvTable nameData;
+	if (!nameData.Load("mob_names.txt", '\t'))
+	{
+		fprintf(stderr, "Could not load mob_names.txt\n");
+	}
+	else
+	{
+		nameData.Next();
+		while (nameData.Next())
+		{
+			if (nameData.ColCount() < 2)
+				continue;
+
+			localMap[atoi(nameData.AsStringByIndex(0))] = nameData.AsStringByIndex(1);
+		}
+	}
+	//________________________________________________//
+
+	cCsvTable data;
+	if (!data.Load("mob_proto.txt", '\t'))
+	{
+		fprintf(stderr, "Could not load mob_proto.txt. Wrong file format?\n");
+		return false;
+	}
+	data.Next();
+
+	if (!m_vec_mobTable.empty())
+	{
+		sys_log(0, "RELOAD: mob_proto");
+		m_vec_mobTable.clear();
+	}
+	m_vec_mobTable.resize(data.m_File.GetRowCount() - 1);
+
+	memset(&m_vec_mobTable[0], 0, sizeof(TMobTable) * m_vec_mobTable.size());
+	TMobTable* mob_table = &m_vec_mobTable[0];
+
+	while (data.Next())
+	{
+		if (!Set_Proto_Mob_Table(mob_table, data, localMap))
+		{
+			fprintf(stderr, "Could not process entry.\n");
+		}
+
+		sys_log(1, "MOB #%-5d %-24s %-24s level: %-3u rank: %u empire: %d", mob_table->dwVnum, mob_table->szName, mob_table->szLocaleName, mob_table->bLevel, mob_table->bRank, mob_table->bEmpire);
+		++mob_table;
+	}
+
+	sort(m_vec_mobTable.begin(), m_vec_mobTable.end(), FCompareVnum());
+	return true;
+}
+
+bool CClientManager::InitializeShopTable()
+{
+	MYSQL_ROW data;
+	int col;
+
+	static const char* s_szQuery =
+		"SELECT "
+		"shop.vnum, "
+		"shop.npc_vnum, "
+		"shop_item.item_vnum, "
+		"shop_item.count "
+		"FROM shop LEFT JOIN shop_item "
+		"ON shop.vnum = shop_item.shop_vnum ORDER BY shop.vnum, shop_item.item_vnum";
+
+	std::unique_ptr<SQLMsg> pkMsg2(CDBManager::instance().DirectQuery(s_szQuery));
+
+	// shop vnum쨘 쨈쨉짜 shop_item  쩐첩쨩째챈쩔챙... 쩍쨌 쨀쨍짰쨉쨈  쩔채쨍.
+	// 째챠쨀쩐쨘쨘
+	SQLResult* pRes2 = pkMsg2->Get();
+
+	if (!pRes2->uiNumRows)
+	{
+		sys_err("InitializeShopTable : Table count is zero.");
+		return false;
+	}
+
+	std::map<int, TShopTable*> map_shop;
+
+	if (m_pShopTable)
+	{
+		delete[](m_pShopTable);
+		m_pShopTable = NULL;
+	}
+
+	TShopTable* shop_table = m_pShopTable;
+
+	while ((data = mysql_fetch_row(pRes2->pSQLResult)))
+	{
+		col = 0;
+
+		int iShopVnum = 0;
+		str_to_number(iShopVnum, data[col++]);
+
+		if (map_shop.end() == map_shop.find(iShopVnum))
+		{
+			shop_table = new TShopTable;
+			memset(shop_table, 0, sizeof(TShopTable));
+			shop_table->dwVnum = iShopVnum;
+
+			map_shop[iShopVnum] = shop_table;
+		}
+		else
+			shop_table = map_shop[iShopVnum];
+
+		str_to_number(shop_table->dwNPCVnum, data[col++]);
+
+		if (!data[col]) // 쩐 쨀짧쨉쨉 쩐첩쨍쨍챕 NULL 쨍짰 쨉쨔쨌..
+			continue;
+
+		TShopItemTable* pItem = &shop_table->items[shop_table->bItemCount];
+
+		str_to_number(pItem->vnum, data[col++]);
+		str_to_number(pItem->count, data[col++]);
+
+		++shop_table->bItemCount;
+	}
+
+	m_pShopTable = new TShopTable[map_shop.size()];
+	m_iShopTableSize = map_shop.size();
+
+	int i = 0;
+	auto it = map_shop.begin();
+	while (it != map_shop.end())
+	{
+		thecore_memcpy((m_pShopTable + i), (it++)->second, sizeof(TShopTable));
+		sys_log(0, "SHOP: #%d items: %d", (m_pShopTable + i)->dwVnum, (m_pShopTable + i)->bItemCount);
+		++i;
+	}
+
+	return true;
+}
+
+bool CClientManager::InitializeQuestItemTable()
+{
+	using namespace std;
+
+	static const char* s_szQuery = "SELECT vnum, name, %s FROM quest_item_proto ORDER BY vnum";
+
+	char query[1024];
+	snprintf(query, sizeof(query), s_szQuery, g_stLocaleNameColumn.c_str());
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
+	SQLResult* pRes = pkMsg->Get();
+
+	if (!pRes->uiNumRows)
+	{
+		sys_err("query error or no rows: %s", query);
+		return false;
+	}
+
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pRes->pSQLResult)))
+	{
+		int col = 0;
+
+		TItemTable tbl;
+		memset(&tbl, 0, sizeof(tbl));
+
+		str_to_number(tbl.dwVnum, row[col++]);
+
+		if (row[col])
+			strlcpy(tbl.szName, row[col], sizeof(tbl.szName));
+
+		col++;
+
+		if (row[col])
+			strlcpy(tbl.szLocaleName, row[col], sizeof(tbl.szLocaleName));
+
+		col++;
+
+		if (m_map_itemTableByVnum.find(tbl.dwVnum) != m_map_itemTableByVnum.end())
+		{
+			sys_err("QUEST_ITEM_ERROR! %lu vnum already exist! (name %s)", tbl.dwVnum, tbl.szLocaleName);
+			continue;
+		}
+
+		tbl.bType = ITEM_QUEST; // quest_item_proto 쨘챠쩔징 쨈 째쨉챕쨘 쨍챨쨉 ITEM_QUEST 짱체
+		tbl.bSize = 1;
+
+		m_vec_itemTable.push_back(tbl);
+	}
+
+	return true;
+}
+
+bool CClientManager::InitializeItemTable()
+{
+	map<int, const char*> localMap;
+	cCsvTable nameData;
+	if (!nameData.Load("item_names.txt", '\t'))
+	{
+		fprintf(stderr, "Could not load item_names.txt.\n");
+	}
+	else
+	{
+		nameData.Next();
+		while (nameData.Next())
+		{
+			if (nameData.ColCount() < 2)
+				continue;
+
+			localMap[atoi(nameData.AsStringByIndex(0))] = nameData.AsStringByIndex(1);
+		}
+	}
+	//_________________________________________________________________//
+
+	cCsvTable data;
+	if (!data.Load("item_proto.txt", '\t'))
+	{
+		fprintf(stderr, "Could not load item_proto.txt. Wrong file format?\n");
+		return false;
+	}
+	data.Next();
+
+	if (!m_vec_itemTable.empty())
+	{
+		sys_log(0, "RELOAD: item_proto");
+		m_vec_itemTable.clear();
+		m_map_itemTableByVnum.clear();
+	}
+
+	data.Destroy();
+	if (!data.Load("item_proto.txt", '\t'))
+	{
+		fprintf(stderr, "Could not load item_proto.txt. Wrong file format?\n");
+		return false;
+	}
+	data.Next();
+
+	m_vec_itemTable.resize(data.m_File.GetRowCount() - 1);
+	memset(&m_vec_itemTable[0], 0, sizeof(TItemTable) * m_vec_itemTable.size());
+
+	TItemTable* item_table = &m_vec_itemTable[0];
+
+	while (data.Next())
+	{
+		if (!Set_Proto_Item_Table(item_table, data, localMap))
+		{
+			fprintf(stderr, "Invalid item table. VNUM: %d\n", item_table->dwVnum);
+		}
+
+		m_map_itemTableByVnum.insert(std::map<DWORD, TItemTable*>::value_type(item_table->dwVnum, item_table));
+		++item_table;
+	}
+	//_______________________________________________________________________//
+
+	m_map_itemTableByVnum.clear();
+
+	auto it = m_vec_itemTable.begin();
+	while (it != m_vec_itemTable.end())
+	{
+		TItemTable* item_table = &(*(it++));
+
+		sys_log(1, "ITEM: #%-5lu %-24s %-24s VAL: %ld %ld %ld %ld %ld %ld WEAR %lu ANTI %llu IMMUNE %lu REFINE %lu REFINE_SET %u ATTR67_MATERIAL %u MAGIC_PCT %u",
+			item_table->dwVnum,
+			item_table->szName,
+			item_table->szLocaleName,
+			item_table->alValues[0],
+			item_table->alValues[1],
+			item_table->alValues[2],
+			item_table->alValues[3],
+			item_table->alValues[4],
+			item_table->alValues[5],
+			item_table->dwWearFlags,
+			item_table->ullAntiFlags,
+			item_table->dwImmuneFlag,
+			item_table->dwRefinedVnum,
+			item_table->wRefineSet,
+			item_table->dw67AttrMaterial,
+			item_table->bAlterToMagicItemPct);
+
+		m_map_itemTableByVnum.insert(std::map<DWORD, TItemTable*>::value_type(item_table->dwVnum, item_table));
+	}
+	sort(m_vec_itemTable.begin(), m_vec_itemTable.end(), FCompareVnum());
+
+	return true;
+}
+
+bool CClientManager::InitializeSkillTable()
+{
+	char query[4096];
+	snprintf(query, sizeof(query),
+		"SELECT `dwVnum`, `szName`, `bType`, `bMaxLevel`, `dwSplashRange`, "
+		"`szPointOn`, `szPointPoly`, `szSPCostPoly`, `szDurationPoly`, `szDurationSPCostPoly`, "
+		"`szCooldownPoly`, `szMasterBonusPoly`, `setFlag`+0, `setAffectFlag`+0, "
+		"`szPointOn2`, `szPointPoly2`, `szDurationPoly2`, `setAffectFlag2`+0, "
+		"`szPointOn3`, `szPointPoly3`, `szDurationPoly3`, `szGrandMasterAddSPCostPoly`, "
+		"`bLevelStep`, `bLevelLimit`, `prerequisiteSkillVnum`, `prerequisiteSkillLevel`, `iMaxHit`, `szSplashAroundDamageAdjustPoly`, `eSkillType`+0, `dwTargetRange` "
+		"FROM skill_proto%s ORDER BY `dwVnum`",
+		GetTablePostfix());
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
+	SQLResult* pRes = pkMsg->Get();
+
+	if (!pRes->uiNumRows)
+	{
+		sys_err("no result from skill_proto");
+		return false;
+	}
+
+	if (!m_vec_skillTable.empty())
+	{
+		sys_log(0, "RELOAD: skill_proto");
+		m_vec_skillTable.clear();
+	}
+
+	m_vec_skillTable.reserve(pRes->uiNumRows);
+
+	MYSQL_ROW data;
+	int col;
+
+	while ((data = mysql_fetch_row(pRes->pSQLResult)))
+	{
+		TSkillTable t;
+		memset(&t, 0, sizeof(t));
+
+		col = 0;
+
+		str_to_number(t.dwVnum, data[col++]);
+		strlcpy(t.szName, data[col++], sizeof(t.szName));
+		str_to_number(t.bType, data[col++]);
+		str_to_number(t.bMaxLevel, data[col++]);
+		str_to_number(t.dwSplashRange, data[col++]);
+
+		strlcpy(t.szPointOn, data[col++], sizeof(t.szPointOn));
+		strlcpy(t.szPointPoly, data[col++], sizeof(t.szPointPoly));
+		strlcpy(t.szSPCostPoly, data[col++], sizeof(t.szSPCostPoly));
+		strlcpy(t.szDurationPoly, data[col++], sizeof(t.szDurationPoly));
+		strlcpy(t.szDurationSPCostPoly, data[col++], sizeof(t.szDurationSPCostPoly));
+		strlcpy(t.szCooldownPoly, data[col++], sizeof(t.szCooldownPoly));
+		strlcpy(t.szMasterBonusPoly, data[col++], sizeof(t.szMasterBonusPoly));
+
+		str_to_number(t.dwFlag, data[col++]);
+		str_to_number(t.dwAffectFlag, data[col++]);
+
+		strlcpy(t.szPointOn2, data[col++], sizeof(t.szPointOn2));
+		strlcpy(t.szPointPoly2, data[col++], sizeof(t.szPointPoly2));
+		strlcpy(t.szDurationPoly2, data[col++], sizeof(t.szDurationPoly2));
+		str_to_number(t.dwAffectFlag2, data[col++]);
+
+		// ADD_GRANDMASTER_SKILL
+		strlcpy(t.szPointOn3, data[col++], sizeof(t.szPointOn3));
+		strlcpy(t.szPointPoly3, data[col++], sizeof(t.szPointPoly3));
+		strlcpy(t.szDurationPoly3, data[col++], sizeof(t.szDurationPoly3));
+
+		strlcpy(t.szGrandMasterAddSPCostPoly, data[col++], sizeof(t.szGrandMasterAddSPCostPoly));
+		// END_OF_ADD_GRANDMASTER_SKILL
+
+		str_to_number(t.bLevelStep, data[col++]);
+		str_to_number(t.bLevelLimit, data[col++]);
+		str_to_number(t.preSkillVnum, data[col++]);
+		str_to_number(t.preSkillLevel, data[col++]);
+
+		str_to_number(t.lMaxHit, data[col++]);
+
+		strlcpy(t.szSplashAroundDamageAdjustPoly, data[col++], sizeof(t.szSplashAroundDamageAdjustPoly));
+
+		str_to_number(t.bSkillAttrType, data[col++]);
+		str_to_number(t.dwTargetRange, data[col++]);
+
+		sys_log(0, "SKILL: #%d %s flag %u point %s affect %u cooldown %s", t.dwVnum, t.szName, t.dwFlag, t.szPointOn, t.dwAffectFlag, t.szCooldownPoly);
+
+		m_vec_skillTable.push_back(t);
+	}
+
+	return true;
+}
+
+bool CClientManager::InitializeBanwordTable()
+{
+	m_vec_banwordTable.clear();
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery("SELECT word FROM banword"));
+
+	SQLResult* pRes = pkMsg->Get();
+
+	if (pRes->uiNumRows == 0)
+		return true;
+
+	MYSQL_ROW data;
+
+	while ((data = mysql_fetch_row(pRes->pSQLResult)))
+	{
+		TBanwordTable t;
+
+		if (data[0])
+		{
+			strlcpy(t.szWord, data[0], sizeof(t.szWord));
+			m_vec_banwordTable.push_back(t);
+		}
+	}
+
+	sys_log(0, "BANWORD: total %d", m_vec_banwordTable.size());
+	return true;
+}
+
+bool CClientManager::InitializeItemAttrTable()
+{
+	char query[4096];
+	snprintf(query, sizeof(query),
+		"SELECT `apply`, `apply`+0, `prob`, "
+		"`lv1`, `lv2`, `lv3`, `lv4`, `lv5`, "
+#if defined(__ATTR_6TH_7TH__)
+		"`lv6`, `lv7`, `lv8`, `lv9`, `lv10`, "
+#endif
+		"`weapon`, `body`, `wrist`, `foots`, `neck`, `head`, `shield`, `ear`"
+#if defined(__PENDANT_SYSTEM__)
+		", `pendant`"
+#endif
+#if defined(__GLOVE_SYSTEM__)
+		", `glove`"
+#endif
+#if defined(__COSTUME_SYSTEM__)
+		", `costume_body`"
+		", `costume_hair`"
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+		", `costume_weapon`"
+#endif
+#endif
+		" FROM item_attr%s ORDER BY `apply`",
+		GetTablePostfix()
+	);
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
+	SQLResult* pRes = pkMsg->Get();
+
+	if (!pRes->uiNumRows)
+	{
+		sys_err("no result from item_attr");
+		return false;
+	}
+
+	if (!m_vec_itemAttrTable.empty())
+	{
+		sys_log(0, "RELOAD: item_attr");
+		m_vec_itemAttrTable.clear();
+	}
+
+	m_vec_itemAttrTable.reserve(pRes->uiNumRows);
+
+	MYSQL_ROW data;
+
+	while ((data = mysql_fetch_row(pRes->pSQLResult)))
+	{
+		TItemAttrTable t;
+
+		memset(&t, 0, sizeof(TItemAttrTable));
+
+		int col = 0;
+
+		strlcpy(t.szApply, data[col++], sizeof(t.szApply));
+		str_to_number(t.wApplyIndex, data[col++]);
+		str_to_number(t.dwProb, data[col++]);
+		str_to_number(t.lValues[0], data[col++]);
+		str_to_number(t.lValues[1], data[col++]);
+		str_to_number(t.lValues[2], data[col++]);
+		str_to_number(t.lValues[3], data[col++]);
+		str_to_number(t.lValues[4], data[col++]);
+#if defined(__ATTR_6TH_7TH__)
+		str_to_number(t.lValues[5], data[col++]);
+		str_to_number(t.lValues[6], data[col++]);
+		str_to_number(t.lValues[7], data[col++]);
+		str_to_number(t.lValues[8], data[col++]);
+		str_to_number(t.lValues[9], data[col++]);
+#endif
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_WEAPON], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_BODY], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_WRIST], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_FOOTS], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_NECK], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_HEAD], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_SHIELD], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_EAR], data[col++]);
+#if defined(__PENDANT_SYSTEM__)
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_PENDANT], data[col++]);
+#endif
+#if defined(__GLOVE_SYSTEM__)
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_GLOVE], data[col++]);
+#endif
+#if defined(__COSTUME_SYSTEM__)
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_BODY], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_HAIR], data[col++]);
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_WEAPON], data[col++]);
+#endif
+#endif
+
+		if (!m_bWolfmanCharacter)
+		{
+			const char* szWolfApply[6] = {
+				"BLEEDING_REDUCE",
+				"BLEEDING_PCT",
+				"ATT_BONUS_TO_WOLFMAN",
+				"RESIST_WOLFMAN"
+				"RESIST_CLAW",
+#if defined(__ELEMENT_SYSTEM__)
+				"RESIST_CLAW_REDUCTION",
+#endif
+			};
+			for (int i = 0; i < _countof(szWolfApply); ++i)
+				if (strcmp(t.szApply, szWolfApply[i]) == 0)
+					continue;
+		}
+
+		sys_log(0, "ITEM_RARE: %-20s %4lu { %3d %3d %3d %3d %3d "
+#if defined(__ATTR_6TH_7TH__)
+			"%3d %3d %3d %3d %3d"
+#endif
+			"} { %d %d %d %d %d %d %d "
+#if defined(__PENDANT_SYSTEM__)
+			"%d "
+#endif
+#if defined(__GLOVE_SYSTEM__)
+			"%d "
+#endif
+#if defined(__COSTUME_SYSTEM__)
+			"%d "
+			"%d "
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+			"%d "
+#endif
+#endif
+			"}"
+			, t.szApply
+			, t.dwProb
+			, t.lValues[0], t.lValues[1], t.lValues[2], t.lValues[3], t.lValues[4]
+#if defined(__ATTR_6TH_7TH__)
+			, t.lValues[5], t.lValues[6], t.lValues[7], t.lValues[8], t.lValues[9]
+#endif
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_WEAPON]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_BODY]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_WRIST]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_FOOTS]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_NECK]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_HEAD]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_SHIELD]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_EAR]
+#if defined(__PENDANT_SYSTEM__)
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_PENDANT]
+#endif
+#if defined(__GLOVE_SYSTEM__)
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_GLOVE]
+#endif
+#if defined(__COSTUME_SYSTEM__)
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_BODY]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_HAIR]
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_COSTUME_WEAPON]
+#endif
+#endif
+		);
+
+		m_vec_itemAttrTable.push_back(t);
+	}
+
+	return true;
+}
+
+bool CClientManager::InitializeItemRareTable()
+{
+	char query[4096];
+	snprintf(query, sizeof(query),
+		"SELECT `apply`, `apply`+0, `prob`, "
+		"`lv1`, `lv2`, `lv3`, `lv4`, `lv5`, "
+#if defined(__ATTR_6TH_7TH__)
+		"`lv6`, `lv7`, `lv8`, `lv9`, `lv10`, "
+#endif
+		"`weapon`, `body`, `wrist`, `foots`, `neck`, `head`, `shield`, `ear`"
+#if defined(__PENDANT_SYSTEM__)
+		", `pendant`"
+#endif
+#if defined(__GLOVE_SYSTEM__)
+		", `glove`"
+#endif
+		" FROM item_attr_rare%s ORDER BY `apply`",
+		GetTablePostfix()
+	);
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
+	SQLResult* pRes = pkMsg->Get();
+
+	if (!pRes->uiNumRows)
+	{
+		sys_err("no result from item_attr_rare");
+		return false;
+	}
+
+	if (!m_vec_itemRareTable.empty())
+	{
+		sys_log(0, "RELOAD: item_attr_rare");
+		m_vec_itemRareTable.clear();
+	}
+
+	m_vec_itemRareTable.reserve(pRes->uiNumRows);
+
+	MYSQL_ROW data;
+
+	while ((data = mysql_fetch_row(pRes->pSQLResult)))
+	{
+		TItemAttrTable t;
+
+		memset(&t, 0, sizeof(TItemAttrTable));
+
+		int col = 0;
+
+		strlcpy(t.szApply, data[col++], sizeof(t.szApply));
+		str_to_number(t.wApplyIndex, data[col++]);
+		str_to_number(t.dwProb, data[col++]);
+		str_to_number(t.lValues[0], data[col++]);
+		str_to_number(t.lValues[1], data[col++]);
+		str_to_number(t.lValues[2], data[col++]);
+		str_to_number(t.lValues[3], data[col++]);
+		str_to_number(t.lValues[4], data[col++]);
+#if defined(__ATTR_6TH_7TH__)
+		str_to_number(t.lValues[5], data[col++]);
+		str_to_number(t.lValues[6], data[col++]);
+		str_to_number(t.lValues[7], data[col++]);
+		str_to_number(t.lValues[8], data[col++]);
+		str_to_number(t.lValues[9], data[col++]);
+#endif
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_WEAPON], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_BODY], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_WRIST], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_FOOTS], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_NECK], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_HEAD], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_SHIELD], data[col++]);
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_EAR], data[col++]);
+#if defined(__PENDANT_SYSTEM__)
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_PENDANT], data[col++]);
+#endif
+#if defined(__GLOVE_SYSTEM__)
+		str_to_number(t.bMaxLevelBySet[ATTRIBUTE_SET_GLOVE], data[col++]);
+#endif
+
+		sys_log(0, "ITEM_RARE: %-20s %4lu { %3d %3d %3d %3d %3d "
+#if defined(__ATTR_6TH_7TH__)
+			"%3d %3d %3d %3d %3d"
+#endif
+			"} { %d %d %d %d %d %d %d "
+#if defined(__PENDANT_SYSTEM__)
+			"%d "
+#endif
+#if defined(__GLOVE_SYSTEM__)
+			"%d "
+#endif
+			"}"
+			, t.szApply, t.dwProb
+			, t.lValues[0], t.lValues[1], t.lValues[2], t.lValues[3], t.lValues[4]
+#if defined(__ATTR_6TH_7TH__)
+			, t.lValues[5], t.lValues[6], t.lValues[7], t.lValues[8], t.lValues[9]
+#endif
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_WEAPON]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_BODY]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_WRIST]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_FOOTS]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_NECK]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_HEAD]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_SHIELD]
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_EAR]
+#if defined(__PENDANT_SYSTEM__)
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_PENDANT]
+#endif
+#if defined(__GLOVE_SYSTEM__)
+			, t.bMaxLevelBySet[ATTRIBUTE_SET_GLOVE]
+#endif
+		);
+
+		m_vec_itemRareTable.push_back(t);
+	}
+
+	return true;
+}
+
+bool CClientManager::InitializeLandTable()
+{
+	using namespace building;
+
+	char query[4096];
+
+	snprintf(query, sizeof(query),
+		"SELECT `id`, `map_index`, `x`, `y`, `width`, `height`, `guild_id`, `guild_level_limit`, `price` "
+		"FROM land%s WHERE `enable` = 'YES' ORDER BY `id`",
+		GetTablePostfix());
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
+	SQLResult* pRes = pkMsg->Get();
+
+	if (!m_vec_kLandTable.empty())
+	{
+		sys_log(0, "RELOAD: land");
+		m_vec_kLandTable.clear();
+	}
+
+	m_vec_kLandTable.reserve(pRes->uiNumRows);
+
+	MYSQL_ROW data;
+
+	if (pRes->uiNumRows > 0)
+		while ((data = mysql_fetch_row(pRes->pSQLResult)))
+		{
+			TLand t;
+
+			memset(&t, 0, sizeof(t));
+
+			int col = 0;
+
+			str_to_number(t.dwID, data[col++]);
+			str_to_number(t.lMapIndex, data[col++]);
+			str_to_number(t.x, data[col++]);
+			str_to_number(t.y, data[col++]);
+			str_to_number(t.width, data[col++]);
+			str_to_number(t.height, data[col++]);
+			str_to_number(t.dwGuildID, data[col++]);
+			str_to_number(t.bGuildLevelLimit, data[col++]);
+			str_to_number(t.dwPrice, data[col++]);
+
+			sys_log(0, "LAND: %lu map %-4ld %7ldx%-7ld w %-4ld h %-4ld", t.dwID, t.lMapIndex, t.x, t.y, t.width, t.height);
+
+			m_vec_kLandTable.push_back(t);
+		}
+
+	return true;
+}
+
+void parse_pair_number_string(const char* c_pszString, std::vector<std::pair<int, int> >& vec)
+{
+	// format: 10,1/20,3/300,50
+	const char* t = c_pszString;
+	const char* p = strchr(t, '/');
+	std::pair<int, int> k;
+
+	char szNum[32 + 1];
+	char* comma;
+
+	while (p)
+	{
+		if (isnhdigit(*t))
+		{
+			strlcpy(szNum, t, MIN(sizeof(szNum), (p - t) + 1));
+
+			comma = strchr(szNum, ',');
+
+			if (comma)
+			{
+				*comma = '\0';
+				str_to_number(k.second, comma + 1);
+			}
+			else
+				k.second = 0;
+
+			str_to_number(k.first, szNum);
+			vec.push_back(k);
+		}
+
+		t = p + 1;
+		p = strchr(t, '/');
+	}
+
+	if (isnhdigit(*t))
+	{
+		strlcpy(szNum, t, sizeof(szNum));
+
+		comma = strchr(const_cast<char*>(t), ',');
+
+		if (comma)
+		{
+			*comma = '\0';
+			str_to_number(k.second, comma + 1);
+		}
+		else
+			k.second = 0;
+
+		str_to_number(k.first, szNum);
+		vec.push_back(k);
+	}
+}
+
+bool CClientManager::InitializeObjectProto()
+{
+	using namespace building;
+
+	char query[4096];
+	snprintf(query, sizeof(query),
+		"SELECT `vnum`, `price`, `materials`, `upgrade_vnum`, `upgrade_limit_time`, `life`, `reg_1`, `reg_2`, `reg_3`, `reg_4`, `npc`, `group_vnum`, `dependent_group` "
+		"FROM object_proto%s ORDER BY `vnum`",
+		GetTablePostfix());
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
+	SQLResult* pRes = pkMsg->Get();
+
+	if (!m_vec_kObjectProto.empty())
+	{
+		sys_log(0, "RELOAD: object_proto");
+		m_vec_kObjectProto.clear();
+	}
+
+	m_vec_kObjectProto.reserve(MAX(0, pRes->uiNumRows));
+
+	MYSQL_ROW data;
+
+	if (pRes->uiNumRows > 0)
+	{
+		while ((data = mysql_fetch_row(pRes->pSQLResult)))
+		{
+			TObjectProto t;
+
+			memset(&t, 0, sizeof(t));
+
+			int col = 0;
+
+			str_to_number(t.dwVnum, data[col++]);
+			str_to_number(t.dwPrice, data[col++]);
+
+			std::vector<std::pair<int, int> > vec;
+			parse_pair_number_string(data[col++], vec);
+
+			for (unsigned int i = 0; i < OBJECT_MATERIAL_MAX_NUM && i < vec.size(); ++i)
+			{
+				std::pair<int, int>& r = vec[i];
+
+				t.kMaterials[i].dwItemVnum = r.first;
+				t.kMaterials[i].dwCount = r.second;
+			}
+
+			str_to_number(t.dwUpgradeVnum, data[col++]);
+			str_to_number(t.dwUpgradeLimitTime, data[col++]);
+			str_to_number(t.lLife, data[col++]);
+			str_to_number(t.lRegion[0], data[col++]);
+			str_to_number(t.lRegion[1], data[col++]);
+			str_to_number(t.lRegion[2], data[col++]);
+			str_to_number(t.lRegion[3], data[col++]);
+
+			// ADD_BUILDING_NPC
+			str_to_number(t.dwNPCVnum, data[col++]);
+			str_to_number(t.dwGroupVnum, data[col++]);
+			str_to_number(t.dwDependOnGroupVnum, data[col++]);
+
+			t.lNPCX = 0;
+			t.lNPCY = MAX(t.lRegion[1], t.lRegion[3]) + 300;
+			// END_OF_ADD_BUILDING_NPC
+
+			sys_log(0, "OBJ_PROTO: vnum %lu price %lu mat %lu %lu",
+				t.dwVnum, t.dwPrice, t.kMaterials[0].dwItemVnum, t.kMaterials[0].dwCount);
+
+			m_vec_kObjectProto.push_back(t);
+		}
+	}
+
+	return true;
+}
+
+bool CClientManager::InitializeObjectTable()
+{
+	using namespace building;
+
+	char query[4096];
+	snprintf(query, sizeof(query), "SELECT `id`, `land_id`, `vnum`, `map_index`, `x`, `y`, `x_rot`, `y_rot`, `z_rot`, `life` FROM object%s ORDER BY `id`", GetTablePostfix());
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(query));
+	SQLResult* pRes = pkMsg->Get();
+
+	if (!m_map_pkObjectTable.empty())
+	{
+		sys_log(0, "RELOAD: object");
+		m_map_pkObjectTable.clear();
+	}
+
+	MYSQL_ROW data;
+
+	if (pRes->uiNumRows > 0)
+		while ((data = mysql_fetch_row(pRes->pSQLResult)))
+		{
+			TObject* k = new TObject;
+
+			memset(k, 0, sizeof(TObject));
+
+			int col = 0;
+
+			str_to_number(k->dwID, data[col++]);
+			str_to_number(k->dwLandID, data[col++]);
+			str_to_number(k->dwVnum, data[col++]);
+			str_to_number(k->lMapIndex, data[col++]);
+			str_to_number(k->x, data[col++]);
+			str_to_number(k->y, data[col++]);
+			str_to_number(k->xRot, data[col++]);
+			str_to_number(k->yRot, data[col++]);
+			str_to_number(k->zRot, data[col++]);
+			str_to_number(k->lLife, data[col++]);
+
+			sys_log(0, "OBJ: %lu vnum %lu map %-4ld %7ldx%-7ld life %ld",
+				k->dwID, k->dwVnum, k->lMapIndex, k->x, k->y, k->lLife);
+
+			m_map_pkObjectTable.insert(std::make_pair(k->dwID, k));
+		}
+
+	return true;
+}
+
+bool CClientManager::InitializeMonarch()
+{
+	CMonarch::instance().LoadMonarch();
+
+	return true;
+}
+
+#if defined(__EXPRESSING_EMOTIONS__)
+bool CClientManager::InitializeEmoteTable()
+{
+	if (m_map_kPlayerEmote.empty() == false)
+		return true;
+
+	char szQuery[1024];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `pid`, `vnum`, UNIX_TIMESTAMP(`duration`) FROM emotions%s", GetTablePostfix());
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(szQuery));
+	const SQLResult* pkRes = pkMsg->Get();
+	if (!pkRes->uiNumRows)
+		return true;
+
+	const DWORD dwCurrentTime = static_cast<DWORD>(std::time(nullptr));
+
+	MYSQL_ROW kData;
+	while ((kData = mysql_fetch_row(pkRes->pSQLResult)))
+	{
+		BYTE bColumn = 0; TPacketGDEmote kTable;
+
+		str_to_number(kTable.dwPID, kData[bColumn++]);
+		str_to_number(kTable.dwVnum, kData[bColumn++]);
+		str_to_number(kTable.dwDuration, kData[bColumn++]);
+
+		if (dwCurrentTime > kTable.dwDuration)
+			continue;
+	
+		m_map_kPlayerEmote[kTable.dwPID].emplace_back(kTable);
+	}
+
+	return true;
+}
+#endif
+
+#if defined(__MAILBOX__)
+bool CClientManager::InitializeMailBoxTable()
+{
+	if (m_map_mailbox.empty() == false)
+		return true;
+
+	char szQuery[QUERY_MAX_LEN];
+	int len = 0;
+		if (!SafeAppend(szQuery, sizeof(szQuery), len, "SELECT `name`, `who`, `title`, `message`, `gm`, `confirm`, `send_time`, `delete_time`"
+			", `gold`, `won`, `vnum`, `count`"))
+			return false;
+
+	for (BYTE i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
+		if (!SafeAppend(szQuery, sizeof(szQuery), len, ", `socket%u`", i)) return false;
+
+	for (BYTE i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; i++)
+		if (!SafeAppend(szQuery, sizeof(szQuery), len, ", `attrtype%u`, `attrvalue%u`", i, i)) return false;
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	if (!SafeAppend(szQuery, sizeof(szQuery), len, ", `changelookvnum`")) return false;
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	if (!SafeAppend(szQuery, sizeof(szQuery), len,
+		", `refine_element_apply_type`"
+		", `refine_element_grade`"
+		", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+		", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`")) return false;
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+	for (BYTE i = 0; i < ITEM_APPLY_MAX_NUM; i++)
+		if (!SafeAppend(szQuery, sizeof(szQuery), len, ", `apply_type%u`, `apply_value%u`, `apply_path%u`", i, i, i)) return false;
+#endif
+
+#if defined(__SET_ITEM__)
+	if (!SafeAppend(szQuery, sizeof(szQuery), len, ", `set_value`")) return false;
+#endif
+
+	if (!SafeAppend(szQuery, sizeof(szQuery), len, " FROM `mailbox%s`", GetTablePostfix())) return false;
+
+	std::unique_ptr<SQLMsg> pkMsg(CDBManager::instance().DirectQuery(szQuery));
+	const SQLResult* pRes = pkMsg->Get();
+	if (!pRes->uiNumRows)
+		return true;
+
+	MYSQL_ROW data;
+	while ((data = mysql_fetch_row(pRes->pSQLResult)))
+	{
+		uint8_t col = 0;
+		SMailBoxTable mail;
+
+		auto name = data[col++];
+		mail.bIsDeleted = false;
+		mail.AddData.bHeader = 0;
+		mail.AddData.Index = 0;
+
+		strlcpy(mail.szName, name ? name : "", sizeof(mail.szName));
+		strlcpy(mail.AddData.szFrom, data[col] ? data[col] : "", sizeof(mail.AddData.szFrom));
+			col++;
+		strlcpy(mail.Message.szTitle, data[col] ? data[col] : "", sizeof(mail.Message.szTitle));
+			col++;
+		strlcpy(mail.AddData.szMessage, data[col] ? data[col] : "", sizeof(mail.AddData.szMessage));
+			col++;
+		str_to_number(mail.Message.bIsGMPost, data[col++]);
+		str_to_number(mail.Message.bIsConfirm, data[col++]);
+		str_to_number(mail.Message.SendTime, data[col++]);
+		str_to_number(mail.Message.DeleteTime, data[col++]);
+		str_to_number(mail.AddData.iYang, data[col++]);
+		str_to_number(mail.AddData.iWon, data[col++]);
+		str_to_number(mail.AddData.dwItemVnum, data[col++]);
+		str_to_number(mail.AddData.dwItemCount, data[col++]);
+
+		mail.Message.bIsItemExist = mail.AddData.dwItemVnum > 0 || mail.AddData.iYang > 0 || mail.AddData.iWon > 0;
+
+		for (BYTE i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
+			str_to_number(mail.AddData.alSockets[i], data[col++]);
+
+		for (BYTE i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; i++)
+		{
+			str_to_number(mail.AddData.aAttr[i].wType, data[col++]);
+			str_to_number(mail.AddData.aAttr[i].lValue, data[col++]);
+		}
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		str_to_number(mail.AddData.dwChangeLookVnum, data[col++]);
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		str_to_number(mail.AddData.RefineElement.wApplyType, data[col++]);
+		str_to_number(mail.AddData.RefineElement.bGrade, data[col++]);
+		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
+			str_to_number(mail.AddData.RefineElement.abValue[i], data[col++]);
+		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
+			str_to_number(mail.AddData.RefineElement.abBonusValue[i], data[col++]);
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+		for (BYTE i = 0; i < ITEM_APPLY_MAX_NUM; i++)
+		{
+			str_to_number(mail.AddData.aApplyRandom[i].wType, data[col++]);
+			str_to_number(mail.AddData.aApplyRandom[i].lValue, data[col++]);
+			str_to_number(mail.AddData.aApplyRandom[i].bPath, data[col++]);
+		}
+#endif
+
+#if defined(__SET_ITEM__)
+		str_to_number(mail.AddData.bSetValue, data[col++]);
+#endif
+
+		m_map_mailbox[name].emplace_back(mail);
+	}
+
+	return true;
+}
+#endif
+
+#if defined(__GEM_SHOP__)
+bool CClientManager::InitializeGemShopTable()
+{
+	// Load Default Gem Shop Table
+	{
+		if (m_mapGemShopTable.empty() == false)
+			return true;
+
+		char szQuery[1024];
+		int iLen = 0;
+			if (!SafeAppend(szQuery, sizeof(szQuery), iLen, "SELECT `pid`, UNIX_TIMESTAMP(`refresh_time`), `enabled_slots`"))
+				return false;
+
+		for (BYTE i = 0; i < GEM_SHOP_SLOT_COUNT; i++)
+			if (!SafeAppend(szQuery, sizeof(szQuery), iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`", i, i, i, i)) return false;
+
+		if (!SafeAppend(szQuery, sizeof(szQuery), iLen, " FROM `gem_shop%s`", GetTablePostfix())) return false;
+
+		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(szQuery));
+		const SQLResult* c_pRes = pMsg->Get();
+		if (!c_pRes->uiNumRows)
+			return true;
+
+		MYSQL_ROW RowData;
+		while ((RowData = mysql_fetch_row(c_pRes->pSQLResult)))
+		{
+			uint8_t iColumn = 0;
+			SGemShopTable GemShopTable;
+#if defined(__CONQUEROR_LEVEL__)
+			GemShopTable.bSpecial = false;
+#endif
+
+			str_to_number(GemShopTable.dwPID, RowData[iColumn++]);
+			str_to_number(GemShopTable.lRefreshTime, RowData[iColumn++]);
+			str_to_number(GemShopTable.bEnabledSlots, RowData[iColumn++]);
+			for (BYTE i = 0; i < GEM_SHOP_SLOT_COUNT; i++)
+			{
+				str_to_number(GemShopTable.GemShopItem[i].bEnable, RowData[iColumn++]);
+				str_to_number(GemShopTable.GemShopItem[i].dwItemVnum, RowData[iColumn++]);
+				str_to_number(GemShopTable.GemShopItem[i].bCount, RowData[iColumn++]);
+				str_to_number(GemShopTable.GemShopItem[i].dwPrice, RowData[iColumn++]);
+			}
+			m_mapGemShopTable.emplace(std::make_pair(GemShopTable.dwPID, GemShopTable));
+		}
+	}
+
+#	if defined(__CONQUEROR_LEVEL__)
+	// Load Port (Special) Gem Shop Table
+	{
+		if (m_mapGemShopSpecialTable.empty() == false)
+			return true;
+
+		char szQuery[1024];
+		int iLen = 0;
+			if (!SafeAppend(szQuery, sizeof(szQuery), iLen, "SELECT `pid`, UNIX_TIMESTAMP(`refresh_time`), `enabled_slots`"))
+				return false;
+
+		for (BYTE i = 0; i < GEM_SHOP_SLOT_COUNT; i++)
+			if (!SafeAppend(szQuery, sizeof(szQuery), iLen, ", `slot%d_enable`, `slot%d_vnum`, `slot%d_count`, `slot%d_price`", i, i, i, i)) return false;
+
+		if (!SafeAppend(szQuery, sizeof(szQuery), iLen, " FROM `gem_shop_port%s`", GetTablePostfix())) return false;
+
+		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(szQuery));
+		const SQLResult* c_pRes = pMsg->Get();
+		if (!c_pRes->uiNumRows)
+			return true;
+
+		MYSQL_ROW RowData;
+		while ((RowData = mysql_fetch_row(c_pRes->pSQLResult)))
+		{
+			uint8_t iColumn = 0;
+			SGemShopTable GemShopTable;
+			GemShopTable.bSpecial = true;
+
+			str_to_number(GemShopTable.dwPID, RowData[iColumn++]);
+			str_to_number(GemShopTable.lRefreshTime, RowData[iColumn++]);
+			str_to_number(GemShopTable.bEnabledSlots, RowData[iColumn++]);
+			for (BYTE i = 0; i < GEM_SHOP_SLOT_COUNT; i++)
+			{
+				str_to_number(GemShopTable.GemShopItem[i].bEnable, RowData[iColumn++]);
+				str_to_number(GemShopTable.GemShopItem[i].dwItemVnum, RowData[iColumn++]);
+				str_to_number(GemShopTable.GemShopItem[i].bCount, RowData[iColumn++]);
+				str_to_number(GemShopTable.GemShopItem[i].dwPrice, RowData[iColumn++]);
+			}
+			m_mapGemShopSpecialTable.emplace(std::make_pair(GemShopTable.dwPID, GemShopTable));
+		}
+	}
+#	endif
+
+	return true;
+}
+#endif
+
+#ifdef __OFFLINE_SHOP__
+void CClientManager::InitializeOfflineShops()
+{
+	std::stringstream shopQuery;
+	shopQuery << "SELECT id, owner_pid, owner_name, name, name_change_time, channel, map_index, x, y, deco_race, deco_board, opening_time, gold FROM offline_shop" << GetTablePostfix();
+
+	std::unique_ptr<SQLMsg> msg(CDBManager::Instance().DirectQuery(shopQuery.str().c_str()));
+	if (!msg) {
+		return;
+	}
+
+	auto result = msg->Get();
+	if (!result || result->uiNumRows < 1) {
+		return;
+	}
+
+	while (auto shopData = mysql_fetch_row(result->pSQLResult)) {
+		size_t col = 0;
+
+		TOfflineShop shop;
+#define NUMBER_FROM_RESULT(field) str_to_number(shop.field, shopData[col++]);
+		NUMBER_FROM_RESULT(id);
+		NUMBER_FROM_RESULT(ownerPid);
+
+		std::string ownerName(shopData[col++]);
+		std::fill(shop.ownerName.begin(), shop.ownerName.end(), '\0');
+		std::copy(ownerName.begin(), ownerName.end(), shop.ownerName.begin());
+
+		std::string shopName(shopData[col++]);
+		std::fill(shop.shopName.begin(), shop.shopName.end(), '\0');
+		std::copy(shopName.begin(), shopName.end(), shop.shopName.begin());
+
+		NUMBER_FROM_RESULT(shopNameChangeTime);
+		NUMBER_FROM_RESULT(channel);
+		NUMBER_FROM_RESULT(mapIndex);
+		NUMBER_FROM_RESULT(x);
+		NUMBER_FROM_RESULT(y);
+		NUMBER_FROM_RESULT(decoRace);
+		NUMBER_FROM_RESULT(decoBoard);
+		NUMBER_FROM_RESULT(openingTime);
+		NUMBER_FROM_RESULT(gold);
+#undef NUMBER_FROM_RESULT
+
+		SaveOfflineShop(shop, true);
+
+
+		std::stringstream itemQuery;
+		itemQuery << "SELECT owner_pid, position, vnum, count, ";
+
+		for (size_t i = 0; i < ITEM_SOCKET_MAX_NUM; ++i) {
+			itemQuery << "socket" << i << ", ";
+		}
+
+		for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i) {
+			itemQuery << "attrtype" << i << ", " << "attrvalue" << i << ", ";
+		}
+
+#if defined(__ITEM_APPLY_RANDOM__)
+		for (size_t i = 0; i < ITEM_APPLY_MAX_NUM; ++i) {
+			itemQuery << "apply_type" << i << ", apply_value" << i << ", apply_path" << i << ", ";
+		}
+#endif
+
+		itemQuery << "transmutation, soulbind, ";
+
+		itemQuery << "price FROM offline_shop_item" << GetTablePostfix() << " WHERE owner_pid = " << shop.id;
+
+		std::unique_ptr<SQLMsg> itemMsg(CDBManager::Instance().DirectQuery(itemQuery.str().c_str()));
+		if (!itemMsg) {
+			continue;
+		}
+
+		auto itemResult = itemMsg->Get();
+		if (!itemResult || itemResult->uiNumRows < 1) {
+			continue;
+		}
+
+		while (auto itemData = mysql_fetch_row(itemResult->pSQLResult)) {
+			col = 0;
+
+			TOfflineShopItem item;
+#define NUMBER_FROM_RESULT(field) str_to_number(item.field, itemData[col++]);
+			NUMBER_FROM_RESULT(id.first);
+			NUMBER_FROM_RESULT(id.second);
+			NUMBER_FROM_RESULT(vnum);
+			NUMBER_FROM_RESULT(count);
+
+			for (size_t i = 0; i < ITEM_SOCKET_MAX_NUM; ++i) {
+				NUMBER_FROM_RESULT(sockets[i]);
+			}
+
+			for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i) {
+				NUMBER_FROM_RESULT(attributes[i].wType);
+				NUMBER_FROM_RESULT(attributes[i].lValue);
+			}
+#if defined(__ITEM_APPLY_RANDOM__)
+			for (size_t i = 0; i < ITEM_APPLY_MAX_NUM; ++i) {
+				NUMBER_FROM_RESULT(ApplyRandom[i].wType);
+				NUMBER_FROM_RESULT(ApplyRandom[i].lValue);
+				NUMBER_FROM_RESULT(ApplyRandom[i].bPath);
+			}
+#endif
+			NUMBER_FROM_RESULT(dwTransmutationVnum);
+			NUMBER_FROM_RESULT(soulbind);
+
+			NUMBER_FROM_RESULT(price);
+#undef NUMBER_FROM_RESULT
+
+			SaveOfflineShopItem(item, true);
+		}
+	}
+
+	sys_log(0, "Initialized %u offline shops with %u items.", offlineShopCache_.size(), offlineShopItemCache_.size());
+}
+#endif
diff --git a/server/metin2/Source/Server/db/src/ClientManagerPlayer.cpp b/server/metin2/Source/Server/db/src/ClientManagerPlayer.cpp
index e8d8d9a..cc9d69a 100644
--- a/server/metin2/Source/Server/db/src/ClientManagerPlayer.cpp
+++ b/server/metin2/Source/Server/db/src/ClientManagerPlayer.cpp
@@ -1,1969 +1,1987 @@
-#include "stdafx.h"
-
-#include "ClientManager.h"
-
-#include "Main.h"
-#include "QID.h"
-#include "ItemAwardManager.h"
-#include "HB.h"
-#include "Cache.h"
-
-extern bool g_bHotBackup;
-
-extern std::string g_stLocale;
-extern int g_test_server;
-extern int g_log;
-
-//
-// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-// !!!!!!!!!!! IMPORTANT !!!!!!!!!!!!
-// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-//
-// Check all SELECT syntax on item table before change this function!!!
-//
-bool CreateItemTableFromRes(MYSQL_RES* res, std::vector<TPlayerItem>* pVec, DWORD dwPID)
-{
-	if (!res)
-	{
-		pVec->clear();
-		return true;
-	}
-
-	int rows;
-
-	if ((rows = static_cast<int>(mysql_num_rows(res))) <= 0) // 데이터 없음
-	{
-		pVec->clear();
-		return true;
-	}
-
-	pVec->resize(rows);
-
-	for (int i = 0; i < rows; ++i)
-	{
-		MYSQL_ROW row = mysql_fetch_row(res);
-		TPlayerItem& item = pVec->at(i);
-
-		int cur = 0;
-
-		// Check all SELECT syntax on item table before change this function!!!
-		// Check all SELECT syntax on item table before change this function!!!
-		// Check all SELECT syntax on item table before change this function!!!
-		str_to_number(item.dwID, row[cur++]);
-		str_to_number(item.bWindow, row[cur++]);
-		str_to_number(item.wPos, row[cur++]);
-		str_to_number(item.dwVnum, row[cur++]);
-		str_to_number(item.dwCount, row[cur++]);
-
-#if defined(__SOUL_BIND_SYSTEM__)
-		str_to_number(item.lSealDate, row[cur++]);
-#endif
-
-		for (BYTE i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
-			str_to_number(item.alSockets[i], row[cur++]);
-
-		for (int j = 0; j < ITEM_ATTRIBUTE_MAX_NUM; j++)
-		{
-			str_to_number(item.aAttr[j].wType, row[cur++]);
-			str_to_number(item.aAttr[j].lValue, row[cur++]);
-		}
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		str_to_number(item.dwTransmutationVnum, row[cur++]);
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		str_to_number(item.RefineElement.wApplyType, row[cur++]);
-		str_to_number(item.RefineElement.bGrade, row[cur++]);
-		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
-			str_to_number(item.RefineElement.abValue[i], row[cur++]);
-		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
-			str_to_number(item.RefineElement.abBonusValue[i], row[cur++]);
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-		for (int j = 0; j < ITEM_APPLY_MAX_NUM; j++)
-		{
-			str_to_number(item.aApplyRandom[j].wType, row[cur++]);
-			str_to_number(item.aApplyRandom[j].lValue, row[cur++]);
-			str_to_number(item.aApplyRandom[j].bPath, row[cur++]);
-		}
-#endif
-
-#if defined(__SET_ITEM__)
-		str_to_number(item.bSetValue, row[cur++]);
-#endif
-
-		item.dwOwner = dwPID;
-	}
-
-	return true;
-}
-
-size_t CreatePlayerSaveQuery(char* pszQuery, size_t querySize, TPlayerTable* pkTab)
-{
-	size_t queryLen;
-
-	queryLen = snprintf(pszQuery, querySize,
-		"UPDATE player%s SET "
-		"`job` = %d, "
-		"`voice` = %d, "
-		"`dir` = %d, "
-		"`x` = %d, "
-		"`y` = %d, "
-		"`z` = %d, "
-		"`map_index` = %d, "
-		"`exit_x` = %ld, "
-		"`exit_y` = %ld, "
-		"`exit_map_index` = %ld, "
-		"`hp` = %d, "
-		"`mp` = %d, "
-		"`stamina` = %d, "
-		"`random_hp` = %d, "
-		"`random_sp` = %d, "
-		"`playtime` = %d, "
-		"`level` = %d, "
-		"`level_step` = %d, "
-		"`st` = %d, "
-		"`ht` = %d, "
-		"`dx` = %d, "
-		"`iq` = %d, "
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		"`inven_stage` = %d, "
-#endif
-		"`gold` = %d, "
-#if defined(__CHEQUE_SYSTEM__)
-		"`cheque` = %d, "
-#endif
-#if defined(__GEM_SYSTEM__)
-		"`gem` = %d, "
-#endif
-		"`exp` = %u, "
-		"`stat_point` = %d, "
-		"`skill_point` = %d, "
-		"`sub_skill_point` = %d, "
-		"`stat_reset_count` = %d, "
-		"`ip` = '%s', "
-		"`part_main` = %d, "
-		"`part_hair` = %d, "
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		"`part_acce` = %d, "
-#endif
-		"`last_play` = NOW(), "
-		"`skill_group` = %d, "
-		"`alignment` = %ld, "
-#if defined(__CONQUEROR_LEVEL__)
-		"`conqueror_level` = %d, "
-		"`conqueror_level_step` = %d, "
-		"`sungma_str` = %d, "
-		"`sungma_hp` = %d, "
-		"`sungma_move` = %d, "
-		"`sungma_immune` = %d, "
-		"`conqueror_exp` = %u, "
-		"`conqueror_point` = %d, "
-#endif
-		"`horse_level` = %d, "
-		"`horse_riding` = %d, "
-		"`horse_hp` = %d, "
-		"`horse_hp_droptime` = %u, "
-		"`horse_stamina` = %d, "
-		"`horse_skill_point` = %d, "
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		"`battle_pass_premium_id` = %d, "
-#endif
-		,
-		GetTablePostfix(),
-		pkTab->job,
-		pkTab->voice,
-		pkTab->dir,
-		pkTab->x,
-		pkTab->y,
-		pkTab->z,
-		pkTab->lMapIndex,
-		pkTab->lExitX,
-		pkTab->lExitY,
-		pkTab->lExitMapIndex,
-		pkTab->hp,
-		pkTab->sp,
-		pkTab->stamina,
-		pkTab->sRandomHP,
-		pkTab->sRandomSP,
-		pkTab->playtime,
-		pkTab->level,
-		pkTab->level_step,
-		pkTab->st,
-		pkTab->ht,
-		pkTab->dx,
-		pkTab->iq,
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		pkTab->inven_stage,
-#endif
-		pkTab->gold,
-#if defined(__CHEQUE_SYSTEM__)
-		pkTab->cheque,
-#endif
-#if defined(__GEM_SYSTEM__)
-		pkTab->gem,
-#endif
-		pkTab->exp,
-		pkTab->stat_point,
-		pkTab->skill_point,
-		pkTab->sub_skill_point,
-		pkTab->stat_reset_count,
-		pkTab->ip,
-		pkTab->adwParts[PART_MAIN],
-		pkTab->adwParts[PART_HAIR],
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		pkTab->adwParts[PART_ACCE],
-#endif
-		pkTab->skill_group,
-		pkTab->lAlignment,
-#if defined(__CONQUEROR_LEVEL__)
-		pkTab->conqueror_level,
-		pkTab->conqueror_level_step,
-		pkTab->sungma_str,
-		pkTab->sungma_hp,
-		pkTab->sungma_move,
-		pkTab->sungma_immune,
-		pkTab->conqueror_exp,
-		pkTab->conqueror_point,
-#endif
-		pkTab->horse.bLevel,
-		pkTab->horse.bRiding,
-		pkTab->horse.sHealth,
-		pkTab->horse.dwHorseHealthDropTime,
-		pkTab->horse.sStamina,
-		pkTab->horse_skill_point,
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		pkTab->battle_pass_premium_id
-#endif
-	);
-
-	// Binary 로 바꾸기 위한 임시 공간
-	static char text[QUERY_MAX_LEN];
-
-	CDBManager::instance().EscapeString(text, pkTab->skills, sizeof(pkTab->skills));
-	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, "`skill_level` = '%s', ", text);
-
-	CDBManager::instance().EscapeString(text, pkTab->quickslot, sizeof(pkTab->quickslot));
-	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, "`quickslot` = '%s' ", text);
-
-	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, " WHERE `id` = %d", pkTab->id);
-	return queryLen;
-}
-
-CPlayerTableCache* CClientManager::GetPlayerCache(DWORD id)
-{
-	TPlayerTableCacheMap::iterator it = m_map_playerCache.find(id);
-
-	if (it == m_map_playerCache.end())
-		return NULL;
-
-	TPlayerTable* pTable = it->second->Get(false);
-	pTable->logoff_interval = static_cast<DWORD>(GetCurrentTime()) - it->second->GetLastUpdateTime();
-	return it->second;
-}
-
-void CClientManager::PutPlayerCache(TPlayerTable* pNew)
-{
-	CPlayerTableCache* c;
-
-	c = GetPlayerCache(pNew->id);
-
-	if (!c)
-	{
-		c = new CPlayerTableCache;
-		m_map_playerCache.insert(TPlayerTableCacheMap::value_type(pNew->id, c));
-	}
-
-	if (g_bHotBackup)
-		PlayerHB::instance().Put(pNew->id);
-
-	c->Put(pNew);
-}
-
-/*
-* PLAYER LOAD
-*/
-void CClientManager::QUERY_PLAYER_LOAD(CPeer* peer, DWORD dwHandle, TPlayerLoadPacket* packet)
-{
-	CPlayerTableCache* c;
-	TPlayerTable* pTab;
-
-	//
-	// 한 계정에 속한 모든 캐릭터들 캐쉬처리
-	//
-	CLoginData* pLoginData = GetLoginDataByAID(packet->account_id);
-
-	if (pLoginData)
-	{
-		for (int n = 0; n < PLAYER_PER_ACCOUNT; ++n)
-			if (pLoginData->GetAccountRef().players[n].dwID != 0)
-				DeleteLogoutPlayer(pLoginData->GetAccountRef().players[n].dwID);
-	}
-
-	// ---------------------------------------------------------------
-	// 1. 유저정보가 DBCache 에 존재 : DBCache에서
-	// 2. 유저정보가 DBCache 에 없음 : DB에서
-	// ---------------------------------------------------------------
-
-	// ---------------------------------------------------------------
-	// 1. 유저정보가 DBCache 에 존재 : DBCache에서
-	// ---------------------------------------------------------------
-	if ((c = GetPlayerCache(packet->player_id)))
-	{
-		CLoginData* pkLD = GetLoginDataByAID(packet->account_id);
-
-		if (!pkLD || pkLD->IsPlay())
-		{
-			sys_log(0, "PLAYER_LOAD_ERROR: LoginData %p IsPlay %d", pkLD, pkLD ? pkLD->IsPlay() : 0);
-			peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, dwHandle, 0);
-			return;
-		}
-
-		pTab = c->Get();
-
-		pkLD->SetPlay(true);
-		thecore_memcpy(pTab->aiPremiumTimes, pkLD->GetPremiumPtr(), sizeof(pTab->aiPremiumTimes));
-
-		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_SUCCESS, dwHandle, sizeof(TPlayerTable));
-		peer->Encode(pTab, sizeof(TPlayerTable));
-
-		if (packet->player_id != pkLD->GetLastPlayerID())
-		{
-			TPacketNeedLoginLogInfo logInfo;
-			logInfo.dwPlayerID = packet->player_id;
-
-			pkLD->SetLastPlayerID(packet->player_id);
-
-			peer->EncodeHeader(HEADER_DG_NEED_LOGIN_LOG, dwHandle, sizeof(TPacketNeedLoginLogInfo));
-			peer->Encode(&logInfo, sizeof(TPacketNeedLoginLogInfo));
-		}
-
-		char szQuery[1024] = { 0, };
-
-		TItemCacheSet* pSet = GetItemCacheSet(pTab->id);
-
-		sys_log(0, "[PLAYER_LOAD] ID %s pid %d gold %d "
-#if defined(__CHEQUE_SYSTEM__)
-			"cheque %d "
-#endif
-#if defined(__GEM_SYSTEM__)
-			"gem %d "
-#endif
-			, pTab->name
-			, pTab->id
-			, pTab->gold
-#if defined(__CHEQUE_SYSTEM__)
-			, pTab->cheque
-#endif
-#if defined(__GEM_SYSTEM__)
-			, pTab->gem
-#endif
-		);
-
-		// ---------------------------------------------------------------
-		// 아이템 & AFFECT & QUEST 로딩 :
-		// ---------------------------------------------------------------
-		// 1) 아이템이 DBCache 에 존재 : DBCache 에서 가져옴
-		// 2) 아이템이 DBCache 에 없음 : DB 에서 가져옴
-
-		///////////////////////////////////////////////////////////////
-		// 1) 아이템이 DBCache 에 존재 : DBCache 에서 가져옴
-		///////////////////////////////////////////////////////////////
-		if (pSet)
-		{
-			static std::vector<TPlayerItem> s_items;
-			s_items.resize(pSet->size());
-
-			DWORD dwCount = 0;
-			TItemCacheSet::iterator it = pSet->begin();
-
-			while (it != pSet->end())
-			{
-				CItemCache* c = *it++;
-				TPlayerItem* p = c->Get();
-
-				if (p->dwVnum) // vnum이 없으면 삭제된 아이템이다.
-					thecore_memcpy(&s_items[dwCount++], p, sizeof(TPlayerItem));
-			}
-
-			if (g_test_server)
-				sys_log(0, "ITEM_CACHE: HIT! %s count: %u", pTab->name, dwCount);
-
-			peer->EncodeHeader(HEADER_DG_ITEM_LOAD, dwHandle, sizeof(DWORD) + sizeof(TPlayerItem) * dwCount);
-			peer->EncodeDWORD(dwCount);
-
-			if (dwCount)
-				peer->Encode(&s_items[0], sizeof(TPlayerItem) * dwCount);
-
-			// Quest
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d AND `lValue` <> 0",
-				GetTablePostfix(), pTab->id);
-
-			CDBManager::instance().ReturnQuery(szQuery, QID_QUEST, peer->GetHandle(), new ClientHandleInfo(dwHandle, 0, packet->account_id));
-
-			// Affect
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
-#if defined(__AFFECT_RENEWAL__)
-				", `bRealTime`"
-#endif
-				" FROM `affect%s` WHERE `dwPID` = %d",
-				GetTablePostfix(), pTab->id);
-			CDBManager::instance().ReturnQuery(szQuery, QID_AFFECT, peer->GetHandle(), new ClientHandleInfo(dwHandle, pTab->id));
-		}
-		///////////////////////////////////////////////////////////////
-		// 2) 아이템이 DBCache 에 없음 : DB 에서 가져옴
-		///////////////////////////////////////////////////////////////
-		else
-		{
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
-#if defined(__SOUL_BIND_SYSTEM__)
-				", `soulbind`"
-#endif
-				", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-				", `socket3`, `socket4`, `socket5`"
-#endif
-				", `attrtype0`, `attrvalue0`"
-				", `attrtype1`, `attrvalue1`"
-				", `attrtype2`, `attrvalue2`"
-				", `attrtype3`, `attrvalue3`"
-				", `attrtype4`, `attrvalue4`"
-				", `attrtype5`, `attrvalue5`"
-				", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-				", `transmutation`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				", `refine_element_apply_type`"
-				", `refine_element_grade`"
-				", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-				", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-				", `apply_type0`, `apply_value0`, `apply_path0`"
-				", `apply_type1`, `apply_value1`, `apply_path1`"
-				", `apply_type2`, `apply_value2`, `apply_path2`"
-				", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-				", `set_value`"
-#endif
-				" FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
-				"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
-#if defined(__ATTR_6TH_7TH__)
-				", 'NPC_STORAGE'"
-#endif
-				"))",
-				GetTablePostfix(), pTab->id);
-
-			CDBManager::instance().ReturnQuery(szQuery,
-				QID_ITEM,
-				peer->GetHandle(),
-				new ClientHandleInfo(dwHandle, pTab->id));
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d",
-				GetTablePostfix(), pTab->id);
-
-			CDBManager::instance().ReturnQuery(szQuery,
-				QID_QUEST,
-				peer->GetHandle(),
-				new ClientHandleInfo(dwHandle, pTab->id));
-			snprintf(szQuery, sizeof(szQuery),
-				"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
-#if defined(__AFFECT_RENEWAL__)
-				", `bRealTime`"
-#endif
-				" FROM `affect%s` WHERE `dwPID` = %d",
-				GetTablePostfix(), pTab->id);
-
-			CDBManager::instance().ReturnQuery(szQuery,
-				QID_AFFECT,
-				peer->GetHandle(),
-				new ClientHandleInfo(dwHandle, pTab->id));
-		}
-		// ljw
-		//return;
-	}
-	// ---------------------------------------------------------------
-	// 2. 유저정보가 DBCache 에 없음 : DB에서
-	// ---------------------------------------------------------------
-	else
-	{
-		sys_log(0, "[PLAYER_LOAD] Load from PlayerDB pid[%d]", packet->player_id);
-
-		char queryStr[QUERY_MAX_LEN];
-
-		// ---------------------------------------------------------------
-		// 캐릭터 정보 얻어오기 : 무조건 DB에서
-		// ---------------------------------------------------------------
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT "
-			"`id`, `name`, `job`, `voice`, `dir`, `x`, `y`, `z`, `map_index`, "
-			"`exit_x`, `exit_y`, `exit_map_index`, `hp`, `mp`, `stamina`, `random_hp`, `random_sp`, `playtime`, "
-#if defined(__EXTEND_INVEN_SYSTEM__)
-			"`inven_stage`, "
-#endif
-			"`gold`, "
-#if defined(__CHEQUE_SYSTEM__)
-			"`cheque`, "
-#endif
-#if defined(__GEM_SYSTEM__)
-			"`gem`, "
-#endif
-			"`level`, "
-			"`level_step`, "
-			"`st`, `ht`, `dx`, `iq`, `exp`, "
-			"`stat_point`, "
-			"`skill_point`, "
-			"`sub_skill_point`, "
-			"`stat_reset_count`, "
-			"`part_base`, `part_hair`, "
-#if defined(__ACCE_COSTUME_SYSTEM__)
-			"`part_acce`, "
-#endif
-			"`skill_level`, "
-			"`quickslot`, "
-			"`skill_group`, "
-			"`alignment`, "
-#if defined(__CONQUEROR_LEVEL__)
-			"`conqueror_level`, "
-			"`conqueror_level_step`, "
-			"`sungma_str`, "
-			"`sungma_hp`, "
-			"`sungma_move`, "
-			"`sungma_immune`, "
-			"`conqueror_exp`, "
-			"`conqueror_point`, "
-#endif
-			"`horse_level`, "
-			"`horse_riding`, "
-			"`horse_hp`, "
-			"`horse_hp_droptime`, "
-			"`horse_stamina`, "
-			"UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(`last_play`), "
-			"`horse_skill_point`, "
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			"`battle_pass_premium_id` "
-#endif
-			" FROM player%s WHERE `id` = %d",
-			GetTablePostfix(), packet->player_id);
-
-		ClientHandleInfo* pkInfo = new ClientHandleInfo(dwHandle, packet->player_id);
-		pkInfo->account_id = packet->account_id;
-		CDBManager::instance().ReturnQuery(queryStr, QID_PLAYER, peer->GetHandle(), pkInfo);
-
-		// ---------------------------------------------------------------
-		// 아이템 가져오기
-		// ---------------------------------------------------------------
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
-#if defined(__SOUL_BIND_SYSTEM__)
-			", `soulbind`"
-#endif
-			", `socket0`, `socket1`, `socket2`"
-#if defined(__ITEM_SOCKET6__)
-			", `socket3`, `socket4`, `socket5`"
-#endif
-			", `attrtype0`, `attrvalue0`"
-			", `attrtype1`, `attrvalue1`"
-			", `attrtype2`, `attrvalue2`"
-			", `attrtype3`, `attrvalue3`"
-			", `attrtype4`, `attrvalue4`"
-			", `attrtype5`, `attrvalue5`"
-			", `attrtype6`, `attrvalue6`"
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			", `transmutation`"
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			", `refine_element_apply_type`"
-			", `refine_element_grade`"
-			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
-			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			", `apply_type0`, `apply_value0`, `apply_path0`"
-			", `apply_type1`, `apply_value1`, `apply_path1`"
-			", `apply_type2`, `apply_value2`, `apply_path2`"
-			", `apply_type3`, `apply_value3`, `apply_path3`"
-#endif
-#if defined(__SET_ITEM__)
-			", `set_value`"
-#endif
-			" FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
-			"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
-#if defined(__ATTR_6TH_7TH__)
-			", 'NPC_STORAGE'"
-#endif
-			"))",
-			GetTablePostfix(), packet->player_id);
-
-		CDBManager::instance().ReturnQuery(queryStr, QID_ITEM, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
-
-		// ---------------------------------------------------------------
-		// QUEST 가져오기
-		// ---------------------------------------------------------------
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d",
-			GetTablePostfix(), packet->player_id);
-		CDBManager::instance().ReturnQuery(queryStr, QID_QUEST, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id, packet->account_id));
-		// 독일 선물 기능에서 item_award테이블에서 login 정보를 얻기위해 account id도 넘겨준다
-		// ---------------------------------------------------------------
-		// AFFECT 가져오기 
-		// ---------------------------------------------------------------
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
-#if defined(__AFFECT_RENEWAL__)
-			", `bRealTime`"
-#endif
-			" FROM `affect%s` WHERE `dwPID` = %d",
-			GetTablePostfix(), packet->player_id);
-		CDBManager::instance().ReturnQuery(queryStr, QID_AFFECT, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
-	}
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	// Load all missions from table
-	char queryStrBP[QUERY_MAX_LEN];
-	snprintf(queryStrBP, sizeof(queryStrBP),
-		"SELECT player_id, battlepass_type+0, mission_index, mission_type+0, battle_pass_id, extra_info, completed FROM battlepass_missions WHERE player_id = %d", packet->player_id);
-	CDBManager::instance().ReturnQuery(queryStrBP, QID_EXT_BATTLE_PASS, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	TGrowthPetCacheSet* pSet = GetGrowthPetCacheSet(packet->player_id);
-	if (pSet)
-	{
-		static std::vector<TGrowthPet> s_petVec;
-		s_petVec.resize(pSet->size());
-
-		DWORD dwCount = 0;
-		auto it = pSet->begin();
-
-		while (it != pSet->end())
-		{
-			CGrowthPetCache* c = *it++;
-			TGrowthPet* p = c->Get();
-
-			if (p->dwOwner)
-				thecore_memcpy(&s_petVec[dwCount++], p, sizeof(TGrowthPet));
-		}
-
-		peer->EncodeHeader(HEADER_DG_GROWTH_PET_LOAD, dwHandle, sizeof(DWORD) + sizeof(TGrowthPet) * dwCount);
-		peer->EncodeDWORD(dwCount);
-
-		if (dwCount)
-			peer->Encode(&s_petVec[0], sizeof(TGrowthPet) * dwCount);
-
-	}
-	else
-	{
-		char szQuery[QUERY_MAX_LEN];
-		snprintf(szQuery, sizeof(szQuery),
-			"SELECT id,vnum,state+0,name,size,level,level_step,evolution,type,hp,sp,def,hp_apply,sp_apply,def_apply,"
-			"age_apply,skill_level,exp,item_exp,UNIX_TIMESTAMP(birthday),end_time,max_time "
-			"FROM growth_pet%s WHERE owner_id=%d AND state < %d",
-			GetTablePostfix(), packet->player_id, STATE_SAFEBOX);
-
-		CDBManager::instance().ReturnQuery(szQuery,
-			QID_GROWTH_PET,
-			peer->GetHandle(),
-			new ClientHandleInfo(dwHandle, packet->player_id));
-	}
-#endif
-}
-
-void CClientManager::ItemAward(CPeer* peer, char* login)
-{
-	char login_t[LOGIN_MAX_LEN + 1] = "";
-	strlcpy(login_t, login, LOGIN_MAX_LEN + 1);
-	std::set<TItemAward*>* pSet = ItemAwardManager::instance().GetByLogin(login_t);
-	if (pSet == NULL)
-		return;
-
-	ItemAwardSet::iterator it = pSet->begin(); // taken_time 이 NULL 인것들 읽어옴
-	while (it != pSet->end())
-	{
-		TItemAward* pItemAward = *(it++);
-		char* whyStr = pItemAward->szWhy; // why 콜룸 읽기
-		char cmdStr[100] = ""; // why콜룸에서 읽은 값을 임시 문자열에 복사해둠
-		strcpy(cmdStr, whyStr); // 명령어 얻는 과정에서 토큰쓰면 원본도 토큰화 되기 때문
-		char command[20] = "";
-		GetCommand(cmdStr, command); // command 얻기
-		if (!(strcmp(cmdStr, "GIFT"))) // command 가 GIFT 이면
-		{
-			TPacketItemAwardInfromer giftData;
-			strcpy(giftData.login, pItemAward->szLogin); //로그인 아이디 복사
-			strcpy(giftData.command, command); // 명령어 복사
-			giftData.vnum = pItemAward->dwVnum; // 아이템 vnum 도 복사
-			ForwardPacket(HEADER_DG_ITEMAWARD_INFORMER, &giftData, sizeof(TPacketItemAwardInfromer));
-		}
-	}
-}
-
-char* CClientManager::GetCommand(char* str, char* command)
-{
-	// char* command = new char[20];
-	char* tok;
-
-	if (str[0] == '[')
-	{
-		tok = strtok(str, "]");
-		strcat(command, &tok[1]);
-	}
-
-	return command;
-	// free(command);
-}
-
-bool CreatePlayerTableFromRes(MYSQL_RES* res, TPlayerTable* pkTab)
-{
-	if (mysql_num_rows(res) == 0) // 데이터 없음
-		return false;
-
-	memset(pkTab, 0, sizeof(TPlayerTable));
-
-	MYSQL_ROW row = mysql_fetch_row(res);
-
-	int col = 0;
-
-	str_to_number(pkTab->id, row[col++]);
-	strlcpy(pkTab->name, row[col++], sizeof(pkTab->name));
-	str_to_number(pkTab->job, row[col++]);
-	str_to_number(pkTab->voice, row[col++]);
-	str_to_number(pkTab->dir, row[col++]);
-	str_to_number(pkTab->x, row[col++]);
-	str_to_number(pkTab->y, row[col++]);
-	str_to_number(pkTab->z, row[col++]);
-	str_to_number(pkTab->lMapIndex, row[col++]);
-	str_to_number(pkTab->lExitX, row[col++]);
-	str_to_number(pkTab->lExitY, row[col++]);
-	str_to_number(pkTab->lExitMapIndex, row[col++]);
-	str_to_number(pkTab->hp, row[col++]);
-	str_to_number(pkTab->sp, row[col++]);
-	str_to_number(pkTab->stamina, row[col++]);
-	str_to_number(pkTab->sRandomHP, row[col++]);
-	str_to_number(pkTab->sRandomSP, row[col++]);
-	str_to_number(pkTab->playtime, row[col++]);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	str_to_number(pkTab->inven_stage, row[col++]);
-#endif
-	str_to_number(pkTab->gold, row[col++]);
-#if defined(__CHEQUE_SYSTEM__)
-	str_to_number(pkTab->cheque, row[col++]);
-#endif
-#if defined(__GEM_SYSTEM__)
-	str_to_number(pkTab->gem, row[col++]);
-#endif
-	str_to_number(pkTab->level, row[col++]);
-	str_to_number(pkTab->level_step, row[col++]);
-	str_to_number(pkTab->st, row[col++]);
-	str_to_number(pkTab->ht, row[col++]);
-	str_to_number(pkTab->dx, row[col++]);
-	str_to_number(pkTab->iq, row[col++]);
-	str_to_number(pkTab->exp, row[col++]);
-	str_to_number(pkTab->stat_point, row[col++]);
-	str_to_number(pkTab->skill_point, row[col++]);
-	str_to_number(pkTab->sub_skill_point, row[col++]);
-	str_to_number(pkTab->stat_reset_count, row[col++]);
-	str_to_number(pkTab->part_base, row[col++]);
-	str_to_number(pkTab->adwParts[PART_HAIR], row[col++]);
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	str_to_number(pkTab->adwParts[PART_ACCE], row[col++]);
-#endif
-
-	if (row[col])
-		thecore_memcpy(pkTab->skills, row[col], sizeof(pkTab->skills));
-	else
-		memset(&pkTab->skills, 0, sizeof(pkTab->skills));
-
-	col++;
-
-	if (row[col])
-		thecore_memcpy(pkTab->quickslot, row[col], sizeof(pkTab->quickslot));
-	else
-		memset(pkTab->quickslot, 0, sizeof(pkTab->quickslot));
-
-	col++;
-
-	str_to_number(pkTab->skill_group, row[col++]);
-	str_to_number(pkTab->lAlignment, row[col++]);
-#if defined(__CONQUEROR_LEVEL__)
-	str_to_number(pkTab->conqueror_level, row[col++]);
-	str_to_number(pkTab->conqueror_level_step, row[col++]);
-	str_to_number(pkTab->sungma_str, row[col++]);
-	str_to_number(pkTab->sungma_hp, row[col++]);
-	str_to_number(pkTab->sungma_move, row[col++]);
-	str_to_number(pkTab->sungma_immune, row[col++]);
-	str_to_number(pkTab->conqueror_exp, row[col++]);
-	str_to_number(pkTab->conqueror_point, row[col++]);
-#endif
-	str_to_number(pkTab->horse.bLevel, row[col++]);
-	str_to_number(pkTab->horse.bRiding, row[col++]);
-	str_to_number(pkTab->horse.sHealth, row[col++]);
-	str_to_number(pkTab->horse.dwHorseHealthDropTime, row[col++]);
-	str_to_number(pkTab->horse.sStamina, row[col++]);
-	str_to_number(pkTab->logoff_interval, row[col++]);
-	str_to_number(pkTab->horse_skill_point, row[col++]);
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	str_to_number(pkTab->battle_pass_premium_id, row[col++]);
-#endif
-	// reset sub_skill_point
-	{
-		pkTab->skills[123].bLevel = 0; // SKILL_CREATE
-		if (pkTab->skills[130].bMasterType != 0) // SKILL_HORSE
-			pkTab->skills[130].bMasterType = SKILL_NORMAL;
-
-		if (pkTab->level > 9)
-		{
-			int max_point = pkTab->level - 9;
-
-			int skill_point =
-				MIN(20, pkTab->skills[121].bLevel) + // SKILL_LEADERSHIP 통솔력
-				MIN(20, pkTab->skills[124].bLevel) + // SKILL_MINING 채광
-				MIN(10, pkTab->skills[131].bLevel) + // SKILL_HORSE_SUMMON 말소환
-				MIN(20, pkTab->skills[141].bLevel) + // SKILL_ADD_HP HP보강
-				MIN(20, pkTab->skills[142].bLevel) + // SKILL_RESIST_PENETRATE 관통저항
-#if defined(__PARTY_PROFICY__)
-				MIN(20, pkTab->skills[133].bLevel) + // SKILL_ROLE_PROFICIENCY
-#endif
-#if defined(__PARTY_INSIGHT__)
-				MIN(20, pkTab->skills[134].bLevel) + // SKILL_INSIGHT
-#endif
-				MIN(20, pkTab->skills[246].bLevel); // SKILL_HIT
-
-			pkTab->sub_skill_point = max_point - skill_point;
-		}
-		else
-			pkTab->sub_skill_point = 0;
-	}
-
-	return true;
-}
-
-void CClientManager::RESULT_COMPOSITE_PLAYER(CPeer* peer, SQLMsg* pMsg, DWORD dwQID)
-{
-	CQueryInfo* qi = (CQueryInfo*)pMsg->pvUserData;
-	std::unique_ptr<ClientHandleInfo> info((ClientHandleInfo*)qi->pvData);
-
-	MYSQL_RES* pSQLResult = pMsg->Get()->pSQLResult;
-	if (!pSQLResult)
-	{
-		sys_err("null MYSQL_RES QID %u", dwQID);
-		return;
-	}
-
-	switch (dwQID)
-	{
-	case QID_PLAYER:
-		sys_log(0, "QID_PLAYER %u %u", info->dwHandle, info->player_id);
-		RESULT_PLAYER_LOAD(peer, pSQLResult, info.get());
-		break;
-
-	case QID_ITEM:
-		sys_log(0, "QID_ITEM %u", info->dwHandle);
-		RESULT_ITEM_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
-		break;
-
-	case QID_QUEST:
-	{
-		sys_log(0, "QID_QUEST %u", info->dwHandle);
-		RESULT_QUEST_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
-
-		// aid얻기
-		ClientHandleInfo* temp1 = info.get();
-		if (temp1 == NULL)
-			break;
-
-		CLoginData* pLoginData1 = GetLoginDataByAID(temp1->account_id);
-		// 독일 선물 기능
-		//if (pLoginData1->GetAccountRef().login == NULL)
-		//	break;
-
-		if (pLoginData1 == NULL)
-			break;
-
-		sys_log(0, "info of pLoginData1 before call ItemAwardfunction %d", pLoginData1);
-		ItemAward(peer, pLoginData1->GetAccountRef().login);
-	}
-	break;
-
-	case QID_AFFECT:
-		sys_log(0, "QID_AFFECT %u", info->dwHandle);
-		RESULT_AFFECT_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
-		break;
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	case QID_EXT_BATTLE_PASS:
-		sys_log(0, "QID_EXT_BATTLE_PASS %u", info->dwHandle);
-		RESULT_EXT_BATTLE_PASS_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
-		break;
-#endif
-#ifdef __GROWTH_PET_SYSTEM__
-	case QID_GROWTH_PET:
-		sys_log(0, "QID_GROWTH_PET %u", info->dwHandle);
-		RESULT_GROWTH_PET_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
-		break;
-#endif
-	}
-}
-
-void CClientManager::RESULT_PLAYER_LOAD(CPeer* peer, MYSQL_RES* pRes, ClientHandleInfo* pkInfo)
-{
-	TPlayerTable tab;
-
-	if (!CreatePlayerTableFromRes(pRes, &tab))
-	{
-		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, pkInfo->dwHandle, 0);
-		return;
-	}
-
-	CLoginData* pkLD = GetLoginDataByAID(pkInfo->account_id);
-
-	if (!pkLD || pkLD->IsPlay())
-	{
-		sys_log(0, "PLAYER_LOAD_ERROR: LoginData %p IsPlay %d", pkLD, pkLD ? pkLD->IsPlay() : 0);
-		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, pkInfo->dwHandle, 0);
-		return;
-	}
-
-	pkLD->SetPlay(true);
-	thecore_memcpy(tab.aiPremiumTimes, pkLD->GetPremiumPtr(), sizeof(tab.aiPremiumTimes));
-
-	peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_SUCCESS, pkInfo->dwHandle, sizeof(TPlayerTable));
-	peer->Encode(&tab, sizeof(TPlayerTable));
-
-	if (tab.id != pkLD->GetLastPlayerID())
-	{
-		TPacketNeedLoginLogInfo logInfo;
-		logInfo.dwPlayerID = tab.id;
-
-		pkLD->SetLastPlayerID(tab.id);
-
-		peer->EncodeHeader(HEADER_DG_NEED_LOGIN_LOG, pkInfo->dwHandle, sizeof(TPacketNeedLoginLogInfo));
-		peer->Encode(&logInfo, sizeof(TPacketNeedLoginLogInfo));
-	}
-}
-
-void CClientManager::RESULT_ITEM_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID)
-{
-	static std::vector<TPlayerItem> s_items;
-	// DB에서 아이템 정보를 읽어온다.
-	CreateItemTableFromRes(pRes, &s_items, dwPID);
-	DWORD dwCount = s_items.size();
-
-	peer->EncodeHeader(HEADER_DG_ITEM_LOAD, dwHandle, sizeof(DWORD) + sizeof(TPlayerItem) * dwCount);
-	peer->EncodeDWORD(dwCount);
-
-	// CacheSet을 만든다
-	CreateItemCacheSet(dwPID);
-
-	// ITEM_LOAD_LOG_ATTACH_PID
-	sys_log(0, "ITEM_LOAD: count %u pid %u", dwCount, dwPID);
-	// END_OF_ITEM_LOAD_LOG_ATTACH_PID
-
-	if (dwCount)
-	{
-		peer->Encode(&s_items[0], sizeof(TPlayerItem) * dwCount);
-
-		for (DWORD i = 0; i < dwCount; ++i)
-			PutItemCache(&s_items[i], true); // 로드한 것은 따로 저장할 필요 없으므로, 인자 bSkipQuery에 true를 넣는다.
-	}
-}
-
-void CClientManager::RESULT_AFFECT_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID)
-{
-	int iNumRows;
-
-	if ((iNumRows = static_cast<int>(mysql_num_rows(pRes))) == 0) // 데이터 없음
-	{
-		static DWORD dwPID;
-		static DWORD dwCount = 0; //1;
-		static TPacketAffectElement paeTable = { 0 };
-
-		dwPID = dwRealPID;
-		sys_log(0, "AFFECT_LOAD: count %u PID %u RealPID %u", dwCount, dwPID, dwRealPID);
-
-		peer->EncodeHeader(HEADER_DG_AFFECT_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPacketAffectElement) * dwCount);
-		peer->Encode(&dwPID, sizeof(DWORD));
-		peer->Encode(&dwCount, sizeof(DWORD));
-		peer->Encode(&paeTable, sizeof(TPacketAffectElement) * dwCount);
-		return;
-	}
-
-	static std::vector<TPacketAffectElement> s_elements;
-	s_elements.resize(iNumRows);
-
-	DWORD dwPID = 0;
-
-	MYSQL_ROW row;
-
-	for (int i = 0; i < iNumRows; ++i)
-	{
-		TPacketAffectElement& r = s_elements[i];
-		row = mysql_fetch_row(pRes);
-
-		if (dwPID == 0)
-			str_to_number(dwPID, row[0]);
-
-		str_to_number(r.dwType, row[1]);
-		str_to_number(r.wApplyOn, row[2]);
-		str_to_number(r.lApplyValue, row[3]);
-		str_to_number(r.dwFlag, row[4]);
-		str_to_number(r.lDuration, row[5]);
-		str_to_number(r.lSPCost, row[6]);
-#if defined(__AFFECT_RENEWAL__)
-		str_to_number(r.bRealTime, row[7]);
-		r.bUpdate = false;
-#endif
-	}
-
-	sys_log(0, "AFFECT_LOAD: count %d PID %u", s_elements.size(), dwPID);
-
-	DWORD dwCount = s_elements.size();
-
-	peer->EncodeHeader(HEADER_DG_AFFECT_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPacketAffectElement) * dwCount);
-	peer->Encode(&dwPID, sizeof(DWORD));
-	peer->Encode(&dwCount, sizeof(DWORD));
-	peer->Encode(&s_elements[0], sizeof(TPacketAffectElement) * dwCount);
-}
-
-void CClientManager::RESULT_QUEST_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD pid)
-{
-	int iNumRows;
-
-	if ((iNumRows = static_cast<int>(mysql_num_rows(pRes))) == 0)
-	{
-		DWORD dwCount = 0;
-		peer->EncodeHeader(HEADER_DG_QUEST_LOAD, dwHandle, sizeof(DWORD));
-		peer->Encode(&dwCount, sizeof(DWORD));
-		return;
-	}
-
-	static std::vector<TQuestTable> s_table;
-	s_table.resize(iNumRows);
-
-	MYSQL_ROW row;
-
-	for (int i = 0; i < iNumRows; ++i)
-	{
-		TQuestTable& r = s_table[i];
-
-		row = mysql_fetch_row(pRes);
-
-		str_to_number(r.dwPID, row[0]);
-		strlcpy(r.szName, row[1], sizeof(r.szName));
-		strlcpy(r.szState, row[2], sizeof(r.szState));
-		str_to_number(r.lValue, row[3]);
-	}
-
-	sys_log(0, "QUEST_LOAD: count %d PID %u", s_table.size(), s_table[0].dwPID);
-
-	DWORD dwCount = s_table.size();
-
-	peer->EncodeHeader(HEADER_DG_QUEST_LOAD, dwHandle, sizeof(DWORD) + sizeof(TQuestTable) * dwCount);
-	peer->Encode(&dwCount, sizeof(DWORD));
-	peer->Encode(&s_table[0], sizeof(TQuestTable) * dwCount);
-}
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-void CClientManager::RESULT_EXT_BATTLE_PASS_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID)
-{
-	int iNumRows;
-
-	if ((iNumRows = mysql_num_rows(pRes)) == 0)
-	{
-		DWORD dwCount = 0;
-		TPlayerExtBattlePassMission pbpTable = { 0 };
-
-		sys_log(0, "EXT_BATTLE_PASS_LOAD: count %u PID %u", dwCount, dwRealPID);
-
-		peer->EncodeHeader(HEADER_DG_EXT_BATTLE_PASS_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPlayerExtBattlePassMission) * dwCount);
-		peer->Encode(&dwRealPID, sizeof(DWORD));
-		peer->Encode(&dwCount, sizeof(DWORD));
-		peer->Encode(&pbpTable, sizeof(TPlayerExtBattlePassMission) * dwCount);
-		return;
-	}
-
-	static std::vector<TPlayerExtBattlePassMission> s_mission;
-	s_mission.resize(iNumRows);
-
-	MYSQL_ROW row;
-
-	for (int i = 0; i < iNumRows; ++i)
-	{
-		int col = 0;
-		TPlayerExtBattlePassMission& r = s_mission[i];
-		row = mysql_fetch_row(pRes);
-
-		str_to_number(r.dwPlayerId, row[col++]);
-		str_to_number(r.dwBattlePassType, row[col++]);
-		str_to_number(r.dwMissionIndex, row[col++]);
-		str_to_number(r.dwMissionType, row[col++]);
-		str_to_number(r.dwBattlePassId, row[col++]);
-		str_to_number(r.dwExtraInfo, row[col++]);
-		str_to_number(r.bCompleted, row[col++]);
-
-		r.bIsUpdated = 0;
-	}
-
-	sys_log(0, "EXT_BATTLE_PASS_LOAD: count %d PID %u", s_mission.size(), dwRealPID);
-
-	DWORD dwCount = s_mission.size();
-
-	peer->EncodeHeader(HEADER_DG_EXT_BATTLE_PASS_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPlayerExtBattlePassMission) * dwCount);
-	peer->Encode(&dwRealPID, sizeof(DWORD));
-	peer->Encode(&dwCount, sizeof(DWORD));
-	peer->Encode(&s_mission[0], sizeof(TPlayerExtBattlePassMission) * dwCount);
-}
-
-void CClientManager::QUERY_SAVE_EXT_BATTLE_PASS(CPeer* peer, DWORD dwHandle, TPlayerExtBattlePassMission* battlePass)
-{
-	if (g_test_server)
-		sys_log(0, "QUERY_SAVE_EXT_BATTLE_PASS: %lu", battlePass->dwPlayerId);
-
-	char szQuery[QUERY_MAX_LEN];
-	snprintf(szQuery, sizeof(szQuery),
-		"REPLACE INTO battlepass_missions (player_id, battlepass_type, mission_index, mission_type, battle_pass_id, extra_info, completed) VALUES (%lu, %d, %d, %d, %d, %d, %d)",
-		battlePass->dwPlayerId,
-		battlePass->dwBattlePassType,
-		battlePass->dwMissionIndex,
-		battlePass->dwMissionType,
-		battlePass->dwBattlePassId,
-		battlePass->dwExtraInfo,
-		battlePass->bCompleted ? 1 : 0);
-	CDBManager::instance().AsyncQuery(szQuery);
-}
-#endif
-
-/*
-* PLAYER SAVE
-*/
-void CClientManager::QUERY_PLAYER_SAVE(CPeer* peer, DWORD dwHandle, TPlayerTable* pkTab)
-{
-	if (g_test_server)
-		sys_log(0, "PLAYER_SAVE: %s", pkTab->name);
-
-	PutPlayerCache(pkTab);
-}
-
-typedef std::map<DWORD, time_t> time_by_id_map_t;
-static time_by_id_map_t s_createTimeByAccountID;
-
-/*
-* PLAYER CREATE
-*/
-void CClientManager::__QUERY_PLAYER_CREATE(CPeer* peer, DWORD dwHandle, TPlayerCreatePacket* packet)
-{
-	char queryStr[QUERY_MAX_LEN];
-	int queryLen;
-	int player_id;
-
-	// 한 계정에 X초 내로 캐릭터 생성을 할 수 없다.
-	time_by_id_map_t::iterator it = s_createTimeByAccountID.find(packet->account_id);
-
-	if (m_bDelayedCharacterCreation)
-	{
-		if (it != s_createTimeByAccountID.end())
-		{
-			time_t curtime = time(0);
-
-			if (curtime - it->second < 30)
-			{
-				peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-				return;
-			}
-		}
-	}
-
-	queryLen = snprintf(queryStr, sizeof(queryStr),
-		"SELECT `pid%d` FROM player_index%s WHERE `id` = %d", packet->account_index + 1, GetTablePostfix(), packet->account_id);
-
-	std::unique_ptr<SQLMsg> pMsg0(CDBManager::instance().DirectQuery(queryStr));
-
-	if (pMsg0->Get()->uiNumRows != 0)
-	{
-		if (!pMsg0->Get()->pSQLResult)
-		{
-			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-			return;
-		}
-
-		MYSQL_ROW row = mysql_fetch_row(pMsg0->Get()->pSQLResult);
-
-		DWORD dwPID = 0; str_to_number(dwPID, row[0]);
-		if (row[0] && dwPID > 0)
-		{
-			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
-			sys_log(0, "ALREADY EXIST AccountChrIdx %d ID %d", packet->account_index, dwPID);
-			return;
-		}
-	}
-	else
-	{
-		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-		return;
-	}
-
-	if (g_stLocale == "sjis")
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT COUNT(*) AS count FROM player%s WHERE `name` = '%s' COLLATE sjis_japanese_ci",
-			GetTablePostfix(), packet->player_table.name);
-	else
-		snprintf(queryStr, sizeof(queryStr),
-			"SELECT COUNT(*) AS count FROM player%s WHERE `name` = '%s'", GetTablePostfix(), packet->player_table.name);
-
-	std::unique_ptr<SQLMsg> pMsg1(CDBManager::instance().DirectQuery(queryStr));
-
-	if (pMsg1->Get()->uiNumRows)
-	{
-		if (!pMsg1->Get()->pSQLResult)
-		{
-			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-			return;
-		}
-
-		MYSQL_ROW row = mysql_fetch_row(pMsg1->Get()->pSQLResult);
-
-		if (*row[0] != '0')
-		{
-			sys_log(0, "ALREADY EXIST name %s, row[0] %s query %s", packet->player_table.name, row[0], queryStr);
-			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
-			return;
-		}
-	}
-	else
-	{
-		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-		return;
-	}
-
-	queryLen = snprintf(queryStr, sizeof(queryStr),
-		"INSERT INTO player%s "
-		"(`id`, `account_id`, `name`, `level`, `st`, `ht`, `dx`, `iq`, "
-		"`job`, `voice`, `dir`, `x`, `y`, `z`, "
-		"`hp`, `mp`, `random_hp`, `random_sp`, `stat_point`, `stamina`, "
-		"`part_base`, `part_main`, `part_hair`, "
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		"`part_acce`, "
-#endif
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		"`inven_stage`, "
-#endif
-		"`gold`, "
-#if defined(__CHEQUE_SYSTEM__)
-		"`cheque`, "
-#endif
-#if defined(__GEM_SYSTEM__)
-		"`gem`, "
-#endif
-		"`playtime`, `skill_level`, `quickslot`) "
-		"VALUES (0, "
-		"%u, "
-		"'%s', " // name
-		"%d, " // level
-		"%d, " // st
-		"%d, " // ht
-		"%d, " // dx
-		"%d, " // iq
-		"%d, " // job
-		"%d, " // voice
-		"%d, " // dir
-		"%d, " // x
-		"%d, " // y
-		"%d, " // z
-		"%d, " // hp
-		"%d, " // sp
-		"%d, " // sRandomHP
-		"%d, " // sRandomSP
-		"%d, " // stat_point
-		"%d, " // stamina
-		"%d, " // part_base
-		"%d, " // part_base
-		"%d, " // part_base(hair)
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		"%d, " // part_base(acce)
-#endif
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		"%d, " // inven_stage
-#endif
-		"%d, " // gold
-#if defined(__CHEQUE_SYSTEM__)
-		"%d, " // cheque
-#endif
-#if defined(__GEM_SYSTEM__)
-		"%d, " // gem
-#endif
-		"0, "
-		, GetTablePostfix()
-		, packet->account_id
-		, packet->player_table.name
-		, packet->player_table.level
-		, packet->player_table.st
-		, packet->player_table.ht
-		, packet->player_table.dx
-		, packet->player_table.iq
-		, packet->player_table.job
-		, packet->player_table.voice
-		, packet->player_table.dir
-		, packet->player_table.x
-		, packet->player_table.y
-		, packet->player_table.z
-		, packet->player_table.hp
-		, packet->player_table.sp
-		, packet->player_table.sRandomHP
-		, packet->player_table.sRandomSP
-		, packet->player_table.stat_point
-		, packet->player_table.stamina
-		, packet->player_table.part_base
-		, packet->player_table.part_base
-		, packet->player_table.adwParts[PART_HAIR]
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		, packet->player_table.adwParts[PART_ACCE]
-#endif
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		, packet->player_table.inven_stage
-#endif
-		, packet->player_table.gold
-#if defined(__CHEQUE_SYSTEM__)
-		, packet->player_table.cheque
-#endif
-#if defined(__GEM_SYSTEM__)
-		, packet->player_table.gem
-#endif
-	);
-
-	sys_log(0, "PlayerCreate accountid %d name %s level %d gold %d"
-#if defined(__CHEQUE_SYSTEM__)
-		" cheque %d"
-#endif
-#if defined(__GEM_SYSTEM__)
-		" gem %d"
-#endif
-		", st %d ht %d job %d"
-		, packet->account_id
-		, packet->player_table.name
-		, packet->player_table.level
-		, packet->player_table.gold
-#if defined(__CHEQUE_SYSTEM__)
-		, packet->player_table.cheque
-#endif
-#if defined(__GEM_SYSTEM__)
-		, packet->player_table.gem
-#endif
-		, packet->player_table.st
-		, packet->player_table.ht
-		, packet->player_table.job
-	);
-
-	static char text[QUERY_MAX_LEN];
-
-	CDBManager::instance().EscapeString(text, packet->player_table.skills, sizeof(packet->player_table.skills));
-	queryLen += snprintf(queryStr + queryLen, sizeof(queryStr) - queryLen, "'%s', ", text);
-	if (g_test_server)
-		sys_log(0, "Create_Player queryLen[%d] TEXT[%s]", queryLen, text);
-
-	CDBManager::instance().EscapeString(text, packet->player_table.quickslot, sizeof(packet->player_table.quickslot));
-	queryLen += snprintf(queryStr + queryLen, sizeof(queryStr) - queryLen, "'%s')", text);
-
-	std::unique_ptr<SQLMsg> pMsg2(CDBManager::instance().DirectQuery(queryStr));
-	if (g_test_server)
-		sys_log(0, "Create_Player queryLen[%d] TEXT[%s]", queryLen, text);
-
-	if (pMsg2->Get()->uiAffectedRows <= 0)
-	{
-		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
-		sys_log(0, "ALREADY EXIST3 query: %s AffectedRows %lu", queryStr, pMsg2->Get()->uiAffectedRows);
-		return;
-	}
-
-	player_id = pMsg2->Get()->uiInsertID;
-
-	snprintf(queryStr, sizeof(queryStr), "UPDATE player_index%s SET `pid%d` = %d WHERE `id` = %d",
-		GetTablePostfix(), packet->account_index + 1, player_id, packet->account_id);
-	std::unique_ptr<SQLMsg> pMsg3(CDBManager::instance().DirectQuery(queryStr));
-
-	if (pMsg3->Get()->uiAffectedRows <= 0)
-	{
-		sys_err("QUERY_ERROR: %s", queryStr);
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM player%s WHERE `id` = %d", GetTablePostfix(), player_id);
-		CDBManager::instance().DirectQuery(queryStr);
-
-		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
-		return;
-	}
-
-	TPacketDGCreateSuccess pack;
-	memset(&pack, 0, sizeof(pack));
-
-	pack.bAccountCharacterIndex = packet->account_index;
-
-	pack.player.dwID = player_id;
-	strlcpy(pack.player.szName, packet->player_table.name, sizeof(pack.player.szName));
-	pack.player.byJob = packet->player_table.job;
-	pack.player.byLevel = 1;
-	pack.player.dwPlayMinutes = 0;
-	pack.player.byST = packet->player_table.st;
-	pack.player.byHT = packet->player_table.ht;
-	pack.player.byDX = packet->player_table.dx;
-	pack.player.byIQ = packet->player_table.iq;
-#if defined(__CONQUEROR_LEVEL__)
-	pack.player.byConquerorLevel = packet->player_table.conqueror_level;
-	pack.player.bySungmaStr = packet->player_table.sungma_str;
-	pack.player.bySungmaHp = packet->player_table.sungma_hp;
-	pack.player.bySungmaMove = packet->player_table.sungma_move;
-	pack.player.bySungmaImmune = packet->player_table.sungma_immune;
-#endif
-	pack.player.dwMainPart = packet->player_table.part_base;
-	pack.player.x = packet->player_table.x;
-	pack.player.y = packet->player_table.y;
-	pack.player.last_play = packet->player_table.last_play;
-
-	peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_SUCCESS, dwHandle, sizeof(TPacketDGCreateSuccess));
-	peer->Encode(&pack, sizeof(TPacketDGCreateSuccess));
-
-	sys_log(0, "7 name %s job %d", pack.player.szName, pack.player.byJob);
-
-	s_createTimeByAccountID[packet->account_id] = time(0);
-}
-
-/*
-* PLAYER DELETE
-*/
-#if defined(__DELETE_FAILURE_TYPE__)
-static char QUERY_CHECK_PLAYER_DELETE(DWORD dwPID, DWORD dwAID, INT* piWaitTime)
-{
-	*piWaitTime = 0;
-
-	SQLMsg* pMsg = NULL;
-	char szQuery[QUERY_MAX_LEN] = {};
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	// Check if the player has any sealed items.
-	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `soulbind` != 0", GetTablePostfix(), dwPID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get()->uiNumRows)
-		return DELETE_FAILURE_HAVE_SEALED_ITEM;
-#endif
-
-	// Check if the player is a member of a guild.
-	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM guild_member%s WHERE `pid` = %d", GetTablePostfix(), dwPID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get()->uiNumRows)
-		return DELETE_FAILURE_GUILD_MEMBER;
-
-	// Check if the player is married.
-	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM marriage%s WHERE `pid1` = %d OR `pid2` = %d", GetTablePostfix(), dwPID, dwPID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get()->uiNumRows)
-		return DELETE_FAILURE_MARRIAGE;
-
-	// Check if the player is the last character on the account and if there are any items in the safebox.
-	snprintf(szQuery, sizeof(szQuery), "SELECT COUNT(*) FROM `player%s` WHERE `account_id` = %u;", GetTablePostfix(), dwAID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get() && pMsg->Get()->uiNumRows)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-
-		BYTE bPlayerCount = 0;
-		str_to_number(bPlayerCount, row[0]);
-
-		if (bPlayerCount == 1)
-		{
-			snprintf(szQuery, sizeof(szQuery), "SELECT * FROM `item%s` WHERE `owner_id` = %u AND `window` = 'SAFEBOX' > 0;", GetTablePostfix(), dwAID);
-			pMsg = CDBManager::Instance().DirectQuery(szQuery);
-			if (pMsg->Get()->uiNumRows)
-				return DELETE_FAILURE_LAST_CHAR_SAFEBOX;
-		}
-	}
-
-#if defined(__ATTR_6TH_7TH__)
-	// Check if the player has any items in the NPC storage.
-	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `window` = 'NPC_STORAGE'", GetTablePostfix(), dwPID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get()->uiNumRows)
-		return DELETE_FAILURE_ATTR67;
-#endif
-
-	// Check if the player has any items in the premium private shop.
-	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `window` = 'PREMIUM_PRIVATE_SHOP'", GetTablePostfix(), dwPID);
-	pMsg = CDBManager::Instance().DirectQuery(szQuery);
-	if (pMsg->Get()->uiNumRows)
-		return DELETE_FAILURE_PREMIUM_PRIVATE_SHOP;
-
-	// Check if the player has at least 10 minutes of playtime.
-	/*
-	CPlayerTableCache* pPlayerTableCache = CClientManager::Instance().GetPlayerCache(dwPID);
-	INT iPlayTime = pPlayerTableCache ? pPlayerTableCache->Get(false)->playtime : 0;
-	if (iPlayTime < 10)
-	{
-		*piWaitTime = 10 - iPlayTime;
-		return DELETE_FAILURE_REMAIN_TIME;
-	}
-	*/
-
-	return -1;
-}
-#endif
-
-void CClientManager::__QUERY_PLAYER_DELETE(CPeer* peer, DWORD dwHandle, TPlayerDeletePacket* packet)
-{
-	if (!packet->login[0] || !packet->player_id || packet->account_index >= PLAYER_PER_ACCOUNT)
-		return;
-
-	CLoginData* ld = GetLoginDataByLogin(packet->login);
-
-	if (!ld)
-	{
-#if defined(__DELETE_FAILURE_TYPE__)
-		TPlayerDeleteFailurePacket DelFailurePacket = {};
-		DelFailurePacket.bType = DELETE_FAILURE_NORMAL;
-		DelFailurePacket.iTime = 0;
-		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
-		peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
-#else
-		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
-		peer->EncodeBYTE(packet->account_index);
-#endif
-		return;
-	}
-
-	TAccountTable& r = ld->GetAccountRef();
-
-	// block for japan
-	if (g_stLocale != "sjis")
-	{
-		if (!IsChinaEventServer())
-		{
-			if (strlen(r.social_id) < 7 || strncmp(packet->private_code, r.social_id + strlen(r.social_id) - 7, 7))
-			{
-				sys_log(0, "PLAYER_DELETE FAILED len(%d)", strlen(r.social_id));
-#if defined(__DELETE_FAILURE_TYPE__)
-				TPlayerDeleteFailurePacket DelFailurePacket;
-				DelFailurePacket.bType = DELETE_FAILURE_PRIVATE_CODE_ERROR;
-				DelFailurePacket.iTime = 0;
-				peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
-				peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
-#else
-				peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
-				peer->EncodeBYTE(packet->account_index);
-#endif
-				return;
-			}
-
-			CPlayerTableCache* pkPlayerCache = GetPlayerCache(packet->player_id);
-			if (pkPlayerCache)
-			{
-				TPlayerTable* pTab = pkPlayerCache->Get();
-
-				if (pTab->level >= m_iPlayerDeleteLevelLimit)
-				{
-					sys_log(0, "PLAYER_DELETE FAILED LEVEL %u >= DELETE LIMIT %d", pTab->level, m_iPlayerDeleteLevelLimit);
-#if defined(__DELETE_FAILURE_TYPE__)
-					TPlayerDeleteFailurePacket DelFailurePacket;
-					DelFailurePacket.bType = DELETE_FAILURE_LIMITE_LEVEL_HIGHER;
-					DelFailurePacket.iTime = 0;
-					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
-					peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
-#else
-					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
-					peer->EncodeBYTE(packet->account_index);
-#endif
-					return;
-				}
-
-				if (pTab->level < m_iPlayerDeleteLevelLimitLower)
-				{
-					sys_log(0, "PLAYER_DELETE FAILED LEVEL %u < DELETE LIMIT %d", pTab->level, m_iPlayerDeleteLevelLimitLower);
-#if defined(__DELETE_FAILURE_TYPE__)
-					TPlayerDeleteFailurePacket DelFailurePacket;
-					DelFailurePacket.bType = DELETE_FAILURE_LIMITE_LEVEL_LOWER;
-					DelFailurePacket.iTime = 0;
-					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
-					peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
-#else
-					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
-					peer->EncodeBYTE(packet->account_index);
-#endif
-					return;
-				}
-			}
-		}
-	}
-
-#if defined(__DELETE_FAILURE_TYPE__)
-	INT iWaitTime;
-	const char bFailureType = QUERY_CHECK_PLAYER_DELETE(packet->player_id, r.id, &iWaitTime);
-	if (bFailureType != -1)
-	{
-		TPlayerDeleteFailurePacket DelFailurePacket;
-		DelFailurePacket.bType = bFailureType;
-		DelFailurePacket.iTime = iWaitTime;
-		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
-		peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
-		return;
-}
-#endif
-
-	char szQuery[128];
-	snprintf(szQuery, sizeof(szQuery), "SELECT p.`id`, p.`level`, p.`name` FROM player_index%s AS i, player%s AS p WHERE `pid%d` = %u AND `pid%d` = p.`id`",
-		GetTablePostfix(), GetTablePostfix(), packet->account_index + 1, packet->player_id, packet->account_index + 1);
-
-	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle, packet->player_id);
-	pi->account_index = packet->account_index;
-
-	sys_log(0, "PLAYER_DELETE TRY: %s %d pid%d", packet->login, packet->player_id, packet->account_index + 1);
-	CDBManager::instance().ReturnQuery(szQuery, QID_PLAYER_DELETE, peer->GetHandle(), pi);
-}
-
-//
-// @version	05/06/10 Bang2ni - 플레이어 삭제시 가격정보 리스트 삭제 추가.
-//
-void CClientManager::__RESULT_PLAYER_DELETE(CPeer* peer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
-
-	if (msg->Get() && msg->Get()->uiNumRows)
-	{
-		MYSQL_ROW row = mysql_fetch_row(msg->Get()->pSQLResult);
-
-		DWORD dwPID = 0;
-		str_to_number(dwPID, row[0]);
-
-		int deletedLevelLimit = 0;
-		str_to_number(deletedLevelLimit, row[1]);
-
-		char szName[64];
-		strlcpy(szName, row[2], sizeof(szName));
-
-		if (deletedLevelLimit >= m_iPlayerDeleteLevelLimit && !IsChinaEventServer())
-		{
-			sys_log(0, "PLAYER_DELETE FAILED LEVEL %u >= DELETE LIMIT %d", deletedLevelLimit, m_iPlayerDeleteLevelLimit);
-			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
-			peer->EncodeBYTE(pi->account_index);
-			return;
-		}
-
-		if (deletedLevelLimit < m_iPlayerDeleteLevelLimitLower)
-		{
-			sys_log(0, "PLAYER_DELETE FAILED LEVEL %u < DELETE LIMIT %d", deletedLevelLimit, m_iPlayerDeleteLevelLimitLower);
-			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
-			peer->EncodeBYTE(pi->account_index);
-			return;
-		}
-
-		char queryStr[QUERY_MAX_LEN];
-
-		snprintf(queryStr, sizeof(queryStr), "INSERT INTO player_deleted%s SELECT * FROM player%s WHERE `id` = %d",
-			GetTablePostfix(), GetTablePostfix(), pi->player_id);
-		std::unique_ptr<SQLMsg> pIns(CDBManager::instance().DirectQuery(queryStr));
-
-		if (pIns->Get()->uiAffectedRows == 0 || pIns->Get()->uiAffectedRows == (uint32_t)-1)
-		{
-			sys_log(0, "PLAYER_DELETE FAILED %u CANNOT INSERT TO player_deleted%s", dwPID, GetTablePostfix());
-
-			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
-			peer->EncodeBYTE(pi->account_index);
-			return;
-		}
-
-		// 삭제 성공
-		sys_log(0, "PLAYER_DELETE SUCCESS %u", dwPID);
-
-		// char account_index_string[16];
-
-		// snprintf(account_index_string, sizeof(account_index_string), "player_id%d", m_iPlayerIDStart + pi->account_index);
-
-		// 플레이어 테이블을 캐쉬에서 삭제한다.
-		CPlayerTableCache* pkPlayerCache = GetPlayerCache(pi->player_id);
-
-		if (pkPlayerCache)
-		{
-			m_map_playerCache.erase(pi->player_id);
-			delete pkPlayerCache;
-		}
-
-		// 아이템들을 캐쉬에서 삭제한다.
-		TItemCacheSet* pSet = GetItemCacheSet(pi->player_id);
-
-		if (pSet)
-		{
-			TItemCacheSet::iterator it = pSet->begin();
-
-			while (it != pSet->end())
-			{
-				CItemCache* pkItemCache = *it++;
-				DeleteItemCache(pkItemCache->Get()->dwID);
-			}
-
-			pSet->clear();
-			delete pSet;
-
-			m_map_pkItemCacheSetPtr.erase(pi->player_id);
-		}
-
-		snprintf(queryStr, sizeof(queryStr), "UPDATE player_index%s SET `pid%d` = 0 WHERE `pid%d` = %d",
-			GetTablePostfix(),
-			pi->account_index + 1,
-			pi->account_index + 1,
-			pi->player_id);
-
-		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(queryStr));
-
-		if (pMsg->Get()->uiAffectedRows == 0 || pMsg->Get()->uiAffectedRows == (uint32_t)-1)
-		{
-			sys_log(0, "PLAYER_DELETE FAIL WHEN UPDATE account table");
-			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
-			peer->EncodeBYTE(pi->account_index);
-			return;
-		}
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `player%s` WHERE `id` = %u", GetTablePostfix(), pi->player_id);
-		delete CDBManager::instance().DirectQuery(queryStr);
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
-			"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
-#if defined(__ATTR_6TH_7TH__)
-			", 'NPC_STORAGE'"
-#endif
-			"))", GetTablePostfix(), pi->player_id);
-		delete CDBManager::instance().DirectQuery(queryStr);
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `quest%s` WHERE `dwPID` = %d", GetTablePostfix(), pi->player_id);
-		CDBManager::instance().AsyncQuery(queryStr);
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `affect%s` WHERE `dwPID` = %d", GetTablePostfix(), pi->player_id);
-		CDBManager::instance().AsyncQuery(queryStr);
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `guild_member%s` WHERE `pid` = %u", GetTablePostfix(), pi->player_id);
-		CDBManager::instance().AsyncQuery(queryStr);
-
-		// MYSHOP_PRICE_LIST
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `myshop_pricelist%s` WHERE `owner_id` = %u", GetTablePostfix(), pi->player_id);
-		CDBManager::instance().AsyncQuery(queryStr);
-		// END_OF_MYSHOP_PRICE_LIST
-
-		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `messenger_list%s` WHERE `account` = '%s' OR `companion` = '%s'", GetTablePostfix(), szName, szName);
-		CDBManager::instance().AsyncQuery(queryStr);
-
-		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_SUCCESS, pi->dwHandle, 1);
-		peer->EncodeBYTE(pi->account_index);
-	}
-	else
-	{
-		// 삭제 실패
-		sys_log(0, "PLAYER_DELETE FAIL NO ROW");
-		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
-		peer->EncodeBYTE(pi->account_index);
-	}
-}
-
-void CClientManager::QUERY_ADD_AFFECT(CPeer* peer, TPacketGDAddAffect* p)
-{
-	char query[QUERY_MAX_LEN];
-#if defined(__AFFECT_RENEWAL__)
-	if (p->elem.bUpdate)
-	{
-		snprintf(query, sizeof(query),
-			"UPDATE `affect%s` SET `lApplyValue` = %ld, `dwFlag` = %u, `lDuration` = %ld, `lSPCost` = %ld, `bRealTime` = %d "
-			"WHERE `dwPID` = %u AND `dwType` = %u AND `wApplyOn` = %u",
-			GetTablePostfix(),
-			p->elem.lApplyValue,
-			p->elem.dwFlag,
-			p->elem.lDuration,
-			p->elem.lSPCost,
-			p->elem.bRealTime ? 1 : 0,
-			p->dwPID,
-			p->elem.dwType,
-			p->elem.wApplyOn);
-	}
-	else
-	{
-		snprintf(query, sizeof(query),
-			"REPLACE INTO `affect%s` (`dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`, `bRealTime`) "
-			"VALUES(%u, %u, %u, %ld, %u, %ld, %ld, %d)",
-			GetTablePostfix(),
-			p->dwPID,
-			p->elem.dwType,
-			p->elem.wApplyOn,
-			p->elem.lApplyValue,
-			p->elem.dwFlag,
-			p->elem.lDuration,
-			p->elem.lSPCost,
-			p->elem.bRealTime ? 1 : 0);
-	}
-#else
-	snprintf(query, sizeof(query),
-		"REPLACE INTO `affect%s` (`dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`) "
-		"VALUES(%u, %u, %u, %ld, %u, %ld, %ld)",
-		GetTablePostfix(),
-		p->dwPID,
-		p->elem.dwType,
-		p->elem.wApplyOn,
-		p->elem.lApplyValue,
-		p->elem.dwFlag,
-		p->elem.lDuration,
-		p->elem.lSPCost
-	);
-#endif
-	CDBManager::instance().AsyncQuery(query);
-}
-
-void CClientManager::QUERY_REMOVE_AFFECT(CPeer* peer, TPacketGDRemoveAffect* p)
-{
-	char query[QUERY_MAX_LEN];
-	snprintf(query, sizeof(query),
-		"DELETE FROM `affect%s` WHERE `dwPID` = %u AND `dwType` = %u AND `wApplyOn` = %u",
-		GetTablePostfix(), p->dwPID, p->dwType, p->wApplyOn);
-	CDBManager::instance().AsyncQuery(query);
-}
-
-void CClientManager::QUERY_HIGHSCORE_REGISTER(CPeer* peer, TPacketGDHighscore* data)
-{
-	char szQuery[128];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `value` FROM highscore%s WHERE `board` = '%s' AND `pid` = %u", GetTablePostfix(), data->szBoard, data->dwPID);
-
-	sys_log(0, "HEADER_GD_HIGHSCORE_REGISTER: PID %u", data->dwPID);
-
-	ClientHandleInfo* pi = new ClientHandleInfo(0);
-	strlcpy(pi->login, data->szBoard, sizeof(pi->login));
-	pi->account_id = (DWORD)data->lValue;
-	pi->player_id = data->dwPID;
-	pi->account_index = (data->cDir > 0);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_HIGHSCORE_REGISTER, peer->GetHandle(), pi);
-}
-
-void CClientManager::RESULT_HIGHSCORE_REGISTER(CPeer* pkPeer, SQLMsg* msg)
-{
-	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
-	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
-	//DWORD dwHandle = pi->dwHandle;
-
-	char szBoard[21];
-	strlcpy(szBoard, pi->login, sizeof(szBoard));
-	int value = (int)pi->account_id;
-
-	SQLResult* res = msg->Get();
-
-	if (res->uiNumRows == 0)
-	{
-		// 새로운 하이스코어를 삽입
-		char buf[256];
-		snprintf(buf, sizeof(buf), "INSERT INTO highscore%s VALUES('%s', %u, %d)", GetTablePostfix(), szBoard, pi->player_id, value);
-		CDBManager::instance().AsyncQuery(buf);
-	}
-	else
-	{
-		if (!res->pSQLResult)
-		{
-			delete pi;
-			return;
-		}
-
-		MYSQL_ROW row = mysql_fetch_row(res->pSQLResult);
-		if (row && row[0])
-		{
-			int current_value = 0; str_to_number(current_value, row[0]);
-			if ((pi->account_index && current_value >= value) || (!pi->account_index && current_value <= value))
-			{
-				value = current_value;
-			}
-			else
-			{
-				char buf[256];
-				snprintf(buf, sizeof(buf), "REPLACE INTO highscore%s VALUES('%s', %u, %d)", GetTablePostfix(), szBoard, pi->player_id, value);
-				CDBManager::instance().AsyncQuery(buf);
-			}
-		}
-		else
-		{
-			char buf[256];
-			snprintf(buf, sizeof(buf), "INSERT INTO highscore%s VALUES('%s', %u, %d)", GetTablePostfix(), szBoard, pi->player_id, value);
-			CDBManager::instance().AsyncQuery(buf);
-		}
-	}
-	// TODO: 이곳에서 하이스코어가 업데이트 되었는지 체크하여 공지를 뿌려야한다.
-	delete pi;
-}
-
-void CClientManager::InsertLogoutPlayer(DWORD pid)
-{
-	TLogoutPlayerMap::iterator it = m_map_logout.find(pid);
-
-	// 존재하지 않을경우 추가
-	if (it != m_map_logout.end())
-	{
-		// 존재할경우 시간만 갱신
-		if (g_log)
-			sys_log(0, "LOGOUT: Update player time pid(%d)", pid);
-
-		it->second->time = time(0);
-		return;
-	}
-
-	TLogoutPlayer* pLogout = new TLogoutPlayer;
-	pLogout->pid = pid;
-	pLogout->time = time(0);
-	m_map_logout.insert(std::make_pair(pid, pLogout));
-
-	if (g_log)
-		sys_log(0, "LOGOUT: Insert player pid(%d)", pid);
-}
-
-void CClientManager::DeleteLogoutPlayer(DWORD pid)
-{
-	TLogoutPlayerMap::iterator it = m_map_logout.find(pid);
-
-	if (it != m_map_logout.end())
-	{
-		delete it->second;
-		m_map_logout.erase(it);
-	}
-}
-
-extern int g_iLogoutSeconds;
-
-void CClientManager::UpdateLogoutPlayer()
-{
-	time_t now = time(0);
-
-	TLogoutPlayerMap::iterator it = m_map_logout.begin();
-
-	while (it != m_map_logout.end())
-	{
-		TLogoutPlayer* pLogout = it->second;
-
-		if (now - g_iLogoutSeconds > pLogout->time)
-		{
-			FlushItemCacheSet(pLogout->pid);
-			FlushPlayerCacheSet(pLogout->pid);
-#ifdef __GROWTH_PET_SYSTEM__
-			FlushGrowthPetCacheSet(pLogout->pid);
-#endif
-			delete pLogout;
-			m_map_logout.erase(it++);
-		}
-		else
-			++it;
-	}
-}
-
-void CClientManager::FlushPlayerCacheSet(DWORD pid)
-{
-	TPlayerTableCacheMap::iterator it = m_map_playerCache.find(pid);
-
-	if (it != m_map_playerCache.end())
-	{
-		CPlayerTableCache* c = it->second;
-		m_map_playerCache.erase(it);
-
-		c->Flush();
-		delete c;
-	}
-}
+#include "stdafx.h"
+
+#include "ClientManager.h"
+#include "Marriage.h"
+
+#include "Main.h"
+#include "QID.h"
+#include "ItemAwardManager.h"
+#include "HB.h"
+#include "Cache.h"
+#include <string.h>
+
+extern bool g_bHotBackup;
+
+extern std::string g_stLocale;
+extern int g_test_server;
+extern int g_log;
+
+//
+// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+// !!!!!!!!!!! IMPORTANT !!!!!!!!!!!!
+// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+//
+// Check all SELECT syntax on item table before change this function!!!
+//
+bool CreateItemTableFromRes(MYSQL_RES* res, std::vector<TPlayerItem>* pVec, DWORD dwPID)
+{
+	if (!res)
+	{
+		pVec->clear();
+		return true;
+	}
+
+	int rows;
+
+	if ((rows = static_cast<int>(mysql_num_rows(res))) <= 0) //  
+	{
+		pVec->clear();
+		return true;
+	}
+
+	pVec->resize(rows);
+
+	for (int i = 0; i < rows; ++i)
+	{
+		MYSQL_ROW row = mysql_fetch_row(res);
+		TPlayerItem& item = pVec->at(i);
+
+		int cur = 0;
+
+		// Check all SELECT syntax on item table before change this function!!!
+		// Check all SELECT syntax on item table before change this function!!!
+		// Check all SELECT syntax on item table before change this function!!!
+		str_to_number(item.dwID, row[cur++]);
+		str_to_number(item.bWindow, row[cur++]);
+		str_to_number(item.wPos, row[cur++]);
+		str_to_number(item.dwVnum, row[cur++]);
+		str_to_number(item.dwCount, row[cur++]);
+
+#if defined(__SOUL_BIND_SYSTEM__)
+		str_to_number(item.lSealDate, row[cur++]);
+#endif
+
+		for (BYTE i = 0; i < ITEM_SOCKET_MAX_NUM; i++)
+			str_to_number(item.alSockets[i], row[cur++]);
+
+		for (int j = 0; j < ITEM_ATTRIBUTE_MAX_NUM; j++)
+		{
+			str_to_number(item.aAttr[j].wType, row[cur++]);
+			str_to_number(item.aAttr[j].lValue, row[cur++]);
+		}
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		str_to_number(item.dwTransmutationVnum, row[cur++]);
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		str_to_number(item.RefineElement.wApplyType, row[cur++]);
+		str_to_number(item.RefineElement.bGrade, row[cur++]);
+		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
+			str_to_number(item.RefineElement.abValue[i], row[cur++]);
+		for (BYTE i = 0; i < REFINE_ELEMENT_MAX; i++)
+			str_to_number(item.RefineElement.abBonusValue[i], row[cur++]);
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+		for (int j = 0; j < ITEM_APPLY_MAX_NUM; j++)
+		{
+			str_to_number(item.aApplyRandom[j].wType, row[cur++]);
+			str_to_number(item.aApplyRandom[j].lValue, row[cur++]);
+			str_to_number(item.aApplyRandom[j].bPath, row[cur++]);
+		}
+#endif
+
+#if defined(__SET_ITEM__)
+		str_to_number(item.bSetValue, row[cur++]);
+#endif
+
+		item.dwOwner = dwPID;
+	}
+
+	return true;
+}
+
+size_t CreatePlayerSaveQuery(char* pszQuery, size_t querySize, TPlayerTable* pkTab)
+{
+	size_t queryLen;
+
+	queryLen = snprintf(pszQuery, querySize,
+		"UPDATE player%s SET "
+		"`job` = %d, "
+		"`voice` = %d, "
+		"`dir` = %d, "
+		"`x` = %d, "
+		"`y` = %d, "
+		"`z` = %d, "
+		"`map_index` = %d, "
+		"`exit_x` = %ld, "
+		"`exit_y` = %ld, "
+		"`exit_map_index` = %ld, "
+		"`hp` = %d, "
+		"`mp` = %d, "
+		"`stamina` = %d, "
+		"`random_hp` = %d, "
+		"`random_sp` = %d, "
+		"`playtime` = %d, "
+		"`level` = %d, "
+		"`level_step` = %d, "
+		"`st` = %d, "
+		"`ht` = %d, "
+		"`dx` = %d, "
+		"`iq` = %d, "
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		"`inven_stage` = %d, "
+#endif
+		"`gold` = %d, "
+#if defined(__CHEQUE_SYSTEM__)
+		"`cheque` = %d, "
+#endif
+#if defined(__GEM_SYSTEM__)
+		"`gem` = %d, "
+#endif
+		"`exp` = %u, "
+		"`stat_point` = %d, "
+		"`skill_point` = %d, "
+		"`sub_skill_point` = %d, "
+		"`stat_reset_count` = %d, "
+		"`ip` = '%s', "
+		"`part_main` = %d, "
+		"`part_hair` = %d, "
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		"`part_acce` = %d, "
+#endif
+		"`last_play` = NOW(), "
+		"`skill_group` = %d, "
+		"`alignment` = %ld, "
+#if defined(__CONQUEROR_LEVEL__)
+		"`conqueror_level` = %d, "
+		"`conqueror_level_step` = %d, "
+		"`sungma_str` = %d, "
+		"`sungma_hp` = %d, "
+		"`sungma_move` = %d, "
+		"`sungma_immune` = %d, "
+		"`conqueror_exp` = %u, "
+		"`conqueror_point` = %d, "
+#endif
+		"`horse_level` = %d, "
+		"`horse_riding` = %d, "
+		"`horse_hp` = %d, "
+		"`horse_hp_droptime` = %u, "
+		"`horse_stamina` = %d, "
+		"`horse_skill_point` = %d, "
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		"`battle_pass_premium_id` = %d, "
+#endif
+		,
+		GetTablePostfix(),
+		pkTab->job,
+		pkTab->voice,
+		pkTab->dir,
+		pkTab->x,
+		pkTab->y,
+		pkTab->z,
+		pkTab->lMapIndex,
+		pkTab->lExitX,
+		pkTab->lExitY,
+		pkTab->lExitMapIndex,
+		pkTab->hp,
+		pkTab->sp,
+		pkTab->stamina,
+		pkTab->sRandomHP,
+		pkTab->sRandomSP,
+		pkTab->playtime,
+		pkTab->level,
+		pkTab->level_step,
+		pkTab->st,
+		pkTab->ht,
+		pkTab->dx,
+		pkTab->iq,
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		pkTab->inven_stage,
+#endif
+		pkTab->gold,
+#if defined(__CHEQUE_SYSTEM__)
+		pkTab->cheque,
+#endif
+#if defined(__GEM_SYSTEM__)
+		pkTab->gem,
+#endif
+		pkTab->exp,
+		pkTab->stat_point,
+		pkTab->skill_point,
+		pkTab->sub_skill_point,
+		pkTab->stat_reset_count,
+		pkTab->ip,
+		pkTab->adwParts[PART_MAIN],
+		pkTab->adwParts[PART_HAIR],
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		pkTab->adwParts[PART_ACCE],
+#endif
+		pkTab->skill_group,
+		pkTab->lAlignment,
+#if defined(__CONQUEROR_LEVEL__)
+		pkTab->conqueror_level,
+		pkTab->conqueror_level_step,
+		pkTab->sungma_str,
+		pkTab->sungma_hp,
+		pkTab->sungma_move,
+		pkTab->sungma_immune,
+		pkTab->conqueror_exp,
+		pkTab->conqueror_point,
+#endif
+		pkTab->horse.bLevel,
+		pkTab->horse.bRiding,
+		pkTab->horse.sHealth,
+		pkTab->horse.dwHorseHealthDropTime,
+		pkTab->horse.sStamina,
+		pkTab->horse_skill_point,
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		pkTab->battle_pass_premium_id
+#endif
+	);
+
+	// Binary  侮袂  擔 
+	static char text[QUERY_MAX_LEN];
+
+	CDBManager::instance().EscapeString(text, pkTab->skills, sizeof(pkTab->skills));
+	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, "`skill_level` = '%s', ", text);
+
+	CDBManager::instance().EscapeString(text, pkTab->quickslot, sizeof(pkTab->quickslot));
+	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, "`quickslot` = '%s' ", text);
+
+	queryLen += snprintf(pszQuery + queryLen, querySize - queryLen, " WHERE `id` = %d", pkTab->id);
+	return queryLen;
+}
+
+CPlayerTableCache* CClientManager::GetPlayerCache(DWORD id)
+{
+	TPlayerTableCacheMap::iterator it = m_map_playerCache.find(id);
+
+	if (it == m_map_playerCache.end())
+		return NULL;
+
+	TPlayerTable* pTable = it->second->Get(false);
+	pTable->logoff_interval = static_cast<DWORD>(GetCurrentTime()) - it->second->GetLastUpdateTime();
+	return it->second;
+}
+
+void CClientManager::PutPlayerCache(TPlayerTable* pNew)
+{
+	CPlayerTableCache* c;
+
+	c = GetPlayerCache(pNew->id);
+
+	if (!c)
+	{
+		c = new CPlayerTableCache;
+		m_map_playerCache.insert(TPlayerTableCacheMap::value_type(pNew->id, c));
+	}
+
+	if (g_bHotBackup)
+		PlayerHB::instance().Put(pNew->id);
+
+	c->Put(pNew);
+}
+
+/*
+* PLAYER LOAD
+*/
+void CClientManager::QUERY_PLAYER_LOAD(CPeer* peer, DWORD dwHandle, TPlayerLoadPacket* packet)
+{
+	CPlayerTableCache* c;
+	TPlayerTable* pTab;
+
+	//
+	//     캐孤 캐처
+	//
+	CLoginData* pLoginData = GetLoginDataByAID(packet->account_id);
+
+	if (pLoginData)
+	{
+		for (int n = 0; n < PLAYER_PER_ACCOUNT; ++n)
+			if (pLoginData->GetAccountRef().players[n].dwID != 0)
+				DeleteLogoutPlayer(pLoginData->GetAccountRef().players[n].dwID);
+	}
+
+	// ---------------------------------------------------------------
+	// 1.  DBCache   : DBCache
+	// 2.  DBCache   : DB
+	// ---------------------------------------------------------------
+
+	// ---------------------------------------------------------------
+	// 1.  DBCache   : DBCache
+	// ---------------------------------------------------------------
+	if ((c = GetPlayerCache(packet->player_id)))
+	{
+		CLoginData* pkLD = GetLoginDataByAID(packet->account_id);
+
+		if (!pkLD || pkLD->IsPlay())
+		{
+			sys_log(0, "PLAYER_LOAD_ERROR: LoginData %p IsPlay %d", pkLD, pkLD ? pkLD->IsPlay() : 0);
+			peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, dwHandle, 0);
+			return;
+		}
+
+		pTab = c->Get();
+
+		pkLD->SetPlay(true);
+		thecore_memcpy(pTab->aiPremiumTimes, pkLD->GetPremiumPtr(), sizeof(pTab->aiPremiumTimes));
+
+		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_SUCCESS, dwHandle, sizeof(TPlayerTable));
+		peer->Encode(pTab, sizeof(TPlayerTable));
+
+		if (packet->player_id != pkLD->GetLastPlayerID())
+		{
+			TPacketNeedLoginLogInfo logInfo;
+			logInfo.dwPlayerID = packet->player_id;
+
+			pkLD->SetLastPlayerID(packet->player_id);
+
+			peer->EncodeHeader(HEADER_DG_NEED_LOGIN_LOG, dwHandle, sizeof(TPacketNeedLoginLogInfo));
+			peer->Encode(&logInfo, sizeof(TPacketNeedLoginLogInfo));
+		}
+
+		char szQuery[1024] = { 0, };
+
+		TItemCacheSet* pSet = GetItemCacheSet(pTab->id);
+
+		sys_log(0, "[PLAYER_LOAD] ID %s pid %d gold %d "
+#if defined(__CHEQUE_SYSTEM__)
+			"cheque %d "
+#endif
+#if defined(__GEM_SYSTEM__)
+			"gem %d "
+#endif
+			, pTab->name
+			, pTab->id
+			, pTab->gold
+#if defined(__CHEQUE_SYSTEM__)
+			, pTab->cheque
+#endif
+#if defined(__GEM_SYSTEM__)
+			, pTab->gem
+#endif
+		);
+
+		// ---------------------------------------------------------------
+		//  & AFFECT & QUEST 琯 :
+		// ---------------------------------------------------------------
+		// 1)  DBCache   : DBCache  
+		// 2)  DBCache   : DB  
+
+		///////////////////////////////////////////////////////////////
+		// 1)  DBCache   : DBCache  
+		///////////////////////////////////////////////////////////////
+		if (pSet)
+		{
+			static std::vector<TPlayerItem> s_items;
+			s_items.resize(pSet->size());
+
+			DWORD dwCount = 0;
+			TItemCacheSet::iterator it = pSet->begin();
+
+			while (it != pSet->end())
+			{
+				CItemCache* c = *it++;
+				TPlayerItem* p = c->Get();
+
+				if (p->dwVnum) // vnum   甄.
+					thecore_memcpy(&s_items[dwCount++], p, sizeof(TPlayerItem));
+			}
+
+			if (g_test_server)
+				sys_log(0, "ITEM_CACHE: HIT! %s count: %u", pTab->name, dwCount);
+
+			peer->EncodeHeader(HEADER_DG_ITEM_LOAD, dwHandle, sizeof(DWORD) + sizeof(TPlayerItem) * dwCount);
+			peer->EncodeDWORD(dwCount);
+
+			if (dwCount)
+				peer->Encode(&s_items[0], sizeof(TPlayerItem) * dwCount);
+
+			// Quest
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d AND `lValue` <> 0",
+				GetTablePostfix(), pTab->id);
+
+			CDBManager::instance().ReturnQuery(szQuery, QID_QUEST, peer->GetHandle(), new ClientHandleInfo(dwHandle, 0, packet->account_id));
+
+			// Affect
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
+#if defined(__AFFECT_RENEWAL__)
+				", `bRealTime`"
+#endif
+				" FROM `affect%s` WHERE `dwPID` = %d",
+				GetTablePostfix(), pTab->id);
+			CDBManager::instance().ReturnQuery(szQuery, QID_AFFECT, peer->GetHandle(), new ClientHandleInfo(dwHandle, pTab->id));
+		}
+		///////////////////////////////////////////////////////////////
+		// 2)  DBCache   : DB  
+		///////////////////////////////////////////////////////////////
+		else
+		{
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
+#if defined(__SOUL_BIND_SYSTEM__)
+				", `soulbind`"
+#endif
+				", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+				", `socket3`, `socket4`, `socket5`"
+#endif
+				", `attrtype0`, `attrvalue0`"
+				", `attrtype1`, `attrvalue1`"
+				", `attrtype2`, `attrvalue2`"
+				", `attrtype3`, `attrvalue3`"
+				", `attrtype4`, `attrvalue4`"
+				", `attrtype5`, `attrvalue5`"
+				", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+				", `transmutation`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				", `refine_element_apply_type`"
+				", `refine_element_grade`"
+				", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+				", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+				", `apply_type0`, `apply_value0`, `apply_path0`"
+				", `apply_type1`, `apply_value1`, `apply_path1`"
+				", `apply_type2`, `apply_value2`, `apply_path2`"
+				", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+				", `set_value`"
+#endif
+				" FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
+				"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
+#if defined(__ATTR_6TH_7TH__)
+				", 'NPC_STORAGE'"
+#endif
+				"))",
+				GetTablePostfix(), pTab->id);
+
+			CDBManager::instance().ReturnQuery(szQuery,
+				QID_ITEM,
+				peer->GetHandle(),
+				new ClientHandleInfo(dwHandle, pTab->id));
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d",
+				GetTablePostfix(), pTab->id);
+
+			CDBManager::instance().ReturnQuery(szQuery,
+				QID_QUEST,
+				peer->GetHandle(),
+				new ClientHandleInfo(dwHandle, pTab->id));
+			snprintf(szQuery, sizeof(szQuery),
+				"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
+#if defined(__AFFECT_RENEWAL__)
+				", `bRealTime`"
+#endif
+				" FROM `affect%s` WHERE `dwPID` = %d",
+				GetTablePostfix(), pTab->id);
+
+			CDBManager::instance().ReturnQuery(szQuery,
+				QID_AFFECT,
+				peer->GetHandle(),
+				new ClientHandleInfo(dwHandle, pTab->id));
+		}
+		// ljw
+		//return;
+	}
+	// ---------------------------------------------------------------
+	// 2.  DBCache   : DB
+	// ---------------------------------------------------------------
+	else
+	{
+		sys_log(0, "[PLAYER_LOAD] Load from PlayerDB pid[%d]", packet->player_id);
+
+		char queryStr[QUERY_MAX_LEN];
+
+		// ---------------------------------------------------------------
+		// 캐   :  DB
+		// ---------------------------------------------------------------
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT "
+			"`id`, `name`, `job`, `voice`, `dir`, `x`, `y`, `z`, `map_index`, "
+			"`exit_x`, `exit_y`, `exit_map_index`, `hp`, `mp`, `stamina`, `random_hp`, `random_sp`, `playtime`, "
+#if defined(__EXTEND_INVEN_SYSTEM__)
+			"`inven_stage`, "
+#endif
+			"`gold`, "
+#if defined(__CHEQUE_SYSTEM__)
+			"`cheque`, "
+#endif
+#if defined(__GEM_SYSTEM__)
+			"`gem`, "
+#endif
+			"`level`, "
+			"`level_step`, "
+			"`st`, `ht`, `dx`, `iq`, `exp`, "
+			"`stat_point`, "
+			"`skill_point`, "
+			"`sub_skill_point`, "
+			"`stat_reset_count`, "
+			"`part_base`, `part_hair`, "
+#if defined(__ACCE_COSTUME_SYSTEM__)
+			"`part_acce`, "
+#endif
+			"`skill_level`, "
+			"`quickslot`, "
+			"`skill_group`, "
+			"`alignment`, "
+#if defined(__CONQUEROR_LEVEL__)
+			"`conqueror_level`, "
+			"`conqueror_level_step`, "
+			"`sungma_str`, "
+			"`sungma_hp`, "
+			"`sungma_move`, "
+			"`sungma_immune`, "
+			"`conqueror_exp`, "
+			"`conqueror_point`, "
+#endif
+			"`horse_level`, "
+			"`horse_riding`, "
+			"`horse_hp`, "
+			"`horse_hp_droptime`, "
+			"`horse_stamina`, "
+			"UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(`last_play`), "
+			"`horse_skill_point`, "
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			"`battle_pass_premium_id` "
+#endif
+			" FROM player%s WHERE `id` = %d",
+			GetTablePostfix(), packet->player_id);
+
+		ClientHandleInfo* pkInfo = new ClientHandleInfo(dwHandle, packet->player_id);
+		pkInfo->account_id = packet->account_id;
+		CDBManager::instance().ReturnQuery(queryStr, QID_PLAYER, peer->GetHandle(), pkInfo);
+
+		// ---------------------------------------------------------------
+		//  
+		// ---------------------------------------------------------------
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT `id`, `window`+0, `pos`, `vnum`, `count`"
+#if defined(__SOUL_BIND_SYSTEM__)
+			", `soulbind`"
+#endif
+			", `socket0`, `socket1`, `socket2`"
+#if defined(__ITEM_SOCKET6__)
+			", `socket3`, `socket4`, `socket5`"
+#endif
+			", `attrtype0`, `attrvalue0`"
+			", `attrtype1`, `attrvalue1`"
+			", `attrtype2`, `attrvalue2`"
+			", `attrtype3`, `attrvalue3`"
+			", `attrtype4`, `attrvalue4`"
+			", `attrtype5`, `attrvalue5`"
+			", `attrtype6`, `attrvalue6`"
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			", `transmutation`"
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			", `refine_element_apply_type`"
+			", `refine_element_grade`"
+			", `refine_element_value0`, `refine_element_value1`, `refine_element_value2`"
+			", `refine_element_bonus_value0`, `refine_element_bonus_value1`, `refine_element_bonus_value2`"
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			", `apply_type0`, `apply_value0`, `apply_path0`"
+			", `apply_type1`, `apply_value1`, `apply_path1`"
+			", `apply_type2`, `apply_value2`, `apply_path2`"
+			", `apply_type3`, `apply_value3`, `apply_path3`"
+#endif
+#if defined(__SET_ITEM__)
+			", `set_value`"
+#endif
+			" FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
+			"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
+#if defined(__ATTR_6TH_7TH__)
+			", 'NPC_STORAGE'"
+#endif
+			"))",
+			GetTablePostfix(), packet->player_id);
+
+		CDBManager::instance().ReturnQuery(queryStr, QID_ITEM, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
+
+		// ---------------------------------------------------------------
+		// QUEST 
+		// ---------------------------------------------------------------
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT `dwPID`, `szName`, `szState`, `lValue` FROM quest%s WHERE `dwPID` = %d",
+			GetTablePostfix(), packet->player_id);
+		CDBManager::instance().ReturnQuery(queryStr, QID_QUEST, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id, packet->account_id));
+		//    item_award遣 login   account id 璣娩
+		// ---------------------------------------------------------------
+		// AFFECT  
+		// ---------------------------------------------------------------
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT `dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`"
+#if defined(__AFFECT_RENEWAL__)
+			", `bRealTime`"
+#endif
+			" FROM `affect%s` WHERE `dwPID` = %d",
+			GetTablePostfix(), packet->player_id);
+		CDBManager::instance().ReturnQuery(queryStr, QID_AFFECT, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
+	}
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	// Load all missions from table
+	char queryStrBP[QUERY_MAX_LEN];
+	snprintf(queryStrBP, sizeof(queryStrBP),
+		"SELECT player_id, battlepass_type+0, mission_index, mission_type+0, battle_pass_id, extra_info, completed FROM battlepass_missions WHERE player_id = %d", packet->player_id);
+	CDBManager::instance().ReturnQuery(queryStrBP, QID_EXT_BATTLE_PASS, peer->GetHandle(), new ClientHandleInfo(dwHandle, packet->player_id));
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	TGrowthPetCacheSet* pSet = GetGrowthPetCacheSet(packet->player_id);
+	if (pSet)
+	{
+		static std::vector<TGrowthPet> s_petVec;
+		s_petVec.resize(pSet->size());
+
+		DWORD dwCount = 0;
+		auto it = pSet->begin();
+
+		while (it != pSet->end())
+		{
+			CGrowthPetCache* c = *it++;
+			TGrowthPet* p = c->Get();
+
+			if (p->dwOwner)
+				thecore_memcpy(&s_petVec[dwCount++], p, sizeof(TGrowthPet));
+		}
+
+		peer->EncodeHeader(HEADER_DG_GROWTH_PET_LOAD, dwHandle, sizeof(DWORD) + sizeof(TGrowthPet) * dwCount);
+		peer->EncodeDWORD(dwCount);
+
+		if (dwCount)
+			peer->Encode(&s_petVec[0], sizeof(TGrowthPet) * dwCount);
+
+	}
+	else
+	{
+		char szQuery[QUERY_MAX_LEN];
+		snprintf(szQuery, sizeof(szQuery),
+			"SELECT id,vnum,state+0,name,size,level,level_step,evolution,type,hp,sp,def,hp_apply,sp_apply,def_apply,"
+			"age_apply,skill_level,exp,item_exp,UNIX_TIMESTAMP(birthday),end_time,max_time "
+			"FROM growth_pet%s WHERE owner_id=%d AND state < %d",
+			GetTablePostfix(), packet->player_id, STATE_SAFEBOX);
+
+		CDBManager::instance().ReturnQuery(szQuery,
+			QID_GROWTH_PET,
+			peer->GetHandle(),
+			new ClientHandleInfo(dwHandle, packet->player_id));
+	}
+#endif
+}
+
+void CClientManager::ItemAward(CPeer* peer, char* login)
+{
+	char login_t[LOGIN_MAX_LEN + 1] = "";
+	strlcpy(login_t, login, LOGIN_MAX_LEN + 1);
+	std::set<TItemAward*>* pSet = ItemAwardManager::instance().GetByLogin(login_t);
+	if (pSet == NULL)
+		return;
+
+	ItemAwardSet::iterator it = pSet->begin(); // taken_time  NULL 寬孤 棘
+	while (it != pSet->end())
+	{
+		TItemAward* pItemAward = *(it++);
+		char* whyStr = pItemAward->szWhy; // why 賦 閨
+		char cmdStr[100] = ""; // why賦肉   擔 悶 巒
+		strlcpy(cmdStr, whyStr, sizeof(cmdStr)); //    큰  큰화 풉 
+		char command[20] = "";
+		GetCommand(cmdStr, command, sizeof(command)); // command 
+		if (!(strcmp(cmdStr, "GIFT"))) // command  GIFT 見
+		{
+			TPacketItemAwardInfromer giftData;
+			strlcpy(giftData.login, pItemAward->szLogin, sizeof(giftData.login)); //慣 絹 
+			strlcpy(giftData.command, command, sizeof(giftData.command)); //  
+			giftData.vnum = pItemAward->dwVnum; //  vnum  
+			ForwardPacket(HEADER_DG_ITEMAWARD_INFORMER, &giftData, sizeof(TPacketItemAwardInfromer));
+		}
+	}
+}
+
+// [REMOVED] Duplicate GetCommand implementation removed to avoid ODR/link errors.
+
+
+bool CreatePlayerTableFromRes(MYSQL_RES* res, TPlayerTable* pkTab)
+{
+	if (mysql_num_rows(res) == 0) //  
+		return false;
+
+	memset(pkTab, 0, sizeof(TPlayerTable));
+
+	MYSQL_ROW row = mysql_fetch_row(res);
+
+	int col = 0;
+
+	str_to_number(pkTab->id, row[col++]);
+	strlcpy(pkTab->name, row[col++], sizeof(pkTab->name));
+	str_to_number(pkTab->job, row[col++]);
+	str_to_number(pkTab->voice, row[col++]);
+	str_to_number(pkTab->dir, row[col++]);
+	str_to_number(pkTab->x, row[col++]);
+	str_to_number(pkTab->y, row[col++]);
+	str_to_number(pkTab->z, row[col++]);
+	str_to_number(pkTab->lMapIndex, row[col++]);
+	str_to_number(pkTab->lExitX, row[col++]);
+	str_to_number(pkTab->lExitY, row[col++]);
+	str_to_number(pkTab->lExitMapIndex, row[col++]);
+	str_to_number(pkTab->hp, row[col++]);
+	str_to_number(pkTab->sp, row[col++]);
+	str_to_number(pkTab->stamina, row[col++]);
+	str_to_number(pkTab->sRandomHP, row[col++]);
+	str_to_number(pkTab->sRandomSP, row[col++]);
+	str_to_number(pkTab->playtime, row[col++]);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	str_to_number(pkTab->inven_stage, row[col++]);
+#endif
+	str_to_number(pkTab->gold, row[col++]);
+#if defined(__CHEQUE_SYSTEM__)
+	str_to_number(pkTab->cheque, row[col++]);
+#endif
+#if defined(__GEM_SYSTEM__)
+	str_to_number(pkTab->gem, row[col++]);
+#endif
+	str_to_number(pkTab->level, row[col++]);
+	str_to_number(pkTab->level_step, row[col++]);
+	str_to_number(pkTab->st, row[col++]);
+	str_to_number(pkTab->ht, row[col++]);
+	str_to_number(pkTab->dx, row[col++]);
+	str_to_number(pkTab->iq, row[col++]);
+	str_to_number(pkTab->exp, row[col++]);
+	str_to_number(pkTab->stat_point, row[col++]);
+	str_to_number(pkTab->skill_point, row[col++]);
+	str_to_number(pkTab->sub_skill_point, row[col++]);
+	str_to_number(pkTab->stat_reset_count, row[col++]);
+	str_to_number(pkTab->part_base, row[col++]);
+	str_to_number(pkTab->adwParts[PART_HAIR], row[col++]);
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	str_to_number(pkTab->adwParts[PART_ACCE], row[col++]);
+#endif
+
+	if (row[col])
+		thecore_memcpy(pkTab->skills, row[col], sizeof(pkTab->skills));
+	else
+		memset(&pkTab->skills, 0, sizeof(pkTab->skills));
+
+	col++;
+
+	if (row[col])
+		thecore_memcpy(pkTab->quickslot, row[col], sizeof(pkTab->quickslot));
+	else
+		memset(pkTab->quickslot, 0, sizeof(pkTab->quickslot));
+
+	col++;
+
+	str_to_number(pkTab->skill_group, row[col++]);
+	str_to_number(pkTab->lAlignment, row[col++]);
+#if defined(__CONQUEROR_LEVEL__)
+	str_to_number(pkTab->conqueror_level, row[col++]);
+	str_to_number(pkTab->conqueror_level_step, row[col++]);
+	str_to_number(pkTab->sungma_str, row[col++]);
+	str_to_number(pkTab->sungma_hp, row[col++]);
+	str_to_number(pkTab->sungma_move, row[col++]);
+	str_to_number(pkTab->sungma_immune, row[col++]);
+	str_to_number(pkTab->conqueror_exp, row[col++]);
+	str_to_number(pkTab->conqueror_point, row[col++]);
+#endif
+	str_to_number(pkTab->horse.bLevel, row[col++]);
+	str_to_number(pkTab->horse.bRiding, row[col++]);
+	str_to_number(pkTab->horse.sHealth, row[col++]);
+	str_to_number(pkTab->horse.dwHorseHealthDropTime, row[col++]);
+	str_to_number(pkTab->horse.sStamina, row[col++]);
+	str_to_number(pkTab->logoff_interval, row[col++]);
+	str_to_number(pkTab->horse_skill_point, row[col++]);
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	str_to_number(pkTab->battle_pass_premium_id, row[col++]);
+#endif
+	// reset sub_skill_point
+	{
+		pkTab->skills[123].bLevel = 0; // SKILL_CREATE
+		if (pkTab->skills[130].bMasterType != 0) // SKILL_HORSE
+			pkTab->skills[130].bMasterType = SKILL_NORMAL;
+
+		if (pkTab->level > 9)
+		{
+			int max_point = pkTab->level - 9;
+
+			int skill_point =
+				MIN(20, pkTab->skills[121].bLevel) + // SKILL_LEADERSHIP 囹
+				MIN(20, pkTab->skills[124].bLevel) + // SKILL_MINING 채
+				MIN(10, pkTab->skills[131].bLevel) + // SKILL_HORSE_SUMMON 환
+				MIN(20, pkTab->skills[141].bLevel) + // SKILL_ADD_HP HP
+				MIN(20, pkTab->skills[142].bLevel) + // SKILL_RESIST_PENETRATE 
+#if defined(__PARTY_PROFICY__)
+				MIN(20, pkTab->skills[133].bLevel) + // SKILL_ROLE_PROFICIENCY
+#endif
+#if defined(__PARTY_INSIGHT__)
+				MIN(20, pkTab->skills[134].bLevel) + // SKILL_INSIGHT
+#endif
+				MIN(20, pkTab->skills[246].bLevel); // SKILL_HIT
+
+			pkTab->sub_skill_point = max_point - skill_point;
+		}
+		else
+			pkTab->sub_skill_point = 0;
+	}
+
+	return true;
+}
+
+void CClientManager::RESULT_COMPOSITE_PLAYER(CPeer* peer, SQLMsg* pMsg, DWORD dwQID)
+{
+	CQueryInfo* qi = (CQueryInfo*)pMsg->pvUserData;
+	std::unique_ptr<ClientHandleInfo> info((ClientHandleInfo*)qi->pvData);
+
+	MYSQL_RES* pSQLResult = pMsg->Get()->pSQLResult;
+	if (!pSQLResult)
+	{
+		sys_err("null MYSQL_RES QID %u", dwQID);
+		return;
+	}
+
+	switch (dwQID)
+	{
+	case QID_PLAYER:
+		sys_log(0, "QID_PLAYER %u %u", info->dwHandle, info->player_id);
+		RESULT_PLAYER_LOAD(peer, pSQLResult, info.get());
+		break;
+
+	case QID_ITEM:
+		sys_log(0, "QID_ITEM %u", info->dwHandle);
+		RESULT_ITEM_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
+		break;
+
+	case QID_QUEST:
+	{
+		sys_log(0, "QID_QUEST %u", info->dwHandle);
+		RESULT_QUEST_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
+
+		// aid
+		ClientHandleInfo* temp1 = info.get();
+		if (temp1 == NULL)
+			break;
+
+		CLoginData* pLoginData1 = GetLoginDataByAID(temp1->account_id);
+		//   
+		//if (pLoginData1->GetAccountRef().login == NULL)
+		//	break;
+
+		if (pLoginData1 == NULL)
+			break;
+
+		sys_log(0, "info of pLoginData1 before call ItemAwardfunction %d", pLoginData1);
+		ItemAward(peer, pLoginData1->GetAccountRef().login);
+	}
+	break;
+
+	case QID_AFFECT:
+		sys_log(0, "QID_AFFECT %u", info->dwHandle);
+		RESULT_AFFECT_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
+		break;
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	case QID_EXT_BATTLE_PASS:
+		sys_log(0, "QID_EXT_BATTLE_PASS %u", info->dwHandle);
+		RESULT_EXT_BATTLE_PASS_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
+		break;
+#endif
+#ifdef __GROWTH_PET_SYSTEM__
+	case QID_GROWTH_PET:
+		sys_log(0, "QID_GROWTH_PET %u", info->dwHandle);
+		RESULT_GROWTH_PET_LOAD(peer, pSQLResult, info->dwHandle, info->player_id);
+		break;
+#endif
+	}
+}
+
+void CClientManager::RESULT_PLAYER_LOAD(CPeer* peer, MYSQL_RES* pRes, ClientHandleInfo* pkInfo)
+{
+	TPlayerTable tab;
+
+	if (!CreatePlayerTableFromRes(pRes, &tab))
+	{
+		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, pkInfo->dwHandle, 0);
+		return;
+	}
+
+	CLoginData* pkLD = GetLoginDataByAID(pkInfo->account_id);
+
+	if (!pkLD || pkLD->IsPlay())
+	{
+		sys_log(0, "PLAYER_LOAD_ERROR: LoginData %p IsPlay %d", pkLD, pkLD ? pkLD->IsPlay() : 0);
+		peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_FAILED, pkInfo->dwHandle, 0);
+		return;
+	}
+
+	pkLD->SetPlay(true);
+	thecore_memcpy(tab.aiPremiumTimes, pkLD->GetPremiumPtr(), sizeof(tab.aiPremiumTimes));
+
+	peer->EncodeHeader(HEADER_DG_PLAYER_LOAD_SUCCESS, pkInfo->dwHandle, sizeof(TPlayerTable));
+	peer->Encode(&tab, sizeof(TPlayerTable));
+
+	if (tab.id != pkLD->GetLastPlayerID())
+	{
+		TPacketNeedLoginLogInfo logInfo;
+		logInfo.dwPlayerID = tab.id;
+
+		pkLD->SetLastPlayerID(tab.id);
+
+		peer->EncodeHeader(HEADER_DG_NEED_LOGIN_LOG, pkInfo->dwHandle, sizeof(TPacketNeedLoginLogInfo));
+		peer->Encode(&logInfo, sizeof(TPacketNeedLoginLogInfo));
+	}
+}
+
+void CClientManager::RESULT_ITEM_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwPID)
+{
+	static std::vector<TPlayerItem> s_items;
+	// DB   棘쨈.
+	CreateItemTableFromRes(pRes, &s_items, dwPID);
+	DWORD dwCount = s_items.size();
+
+	peer->EncodeHeader(HEADER_DG_ITEM_LOAD, dwHandle, sizeof(DWORD) + sizeof(TPlayerItem) * dwCount);
+	peer->EncodeDWORD(dwCount);
+
+	// CacheSet 
+	CreateItemCacheSet(dwPID);
+
+	// ITEM_LOAD_LOG_ATTACH_PID
+	sys_log(0, "ITEM_LOAD: count %u pid %u", dwCount, dwPID);
+	// END_OF_ITEM_LOAD_LOG_ATTACH_PID
+
+	if (dwCount)
+	{
+		peer->Encode(&s_items[0], sizeof(TPlayerItem) * dwCount);
+
+		for (DWORD i = 0; i < dwCount; ++i)
+			PutItemCache(&s_items[i], true); // 琯    却 퓐,  bSkipQuery true 獵쨈.
+	}
+}
+
+void CClientManager::RESULT_AFFECT_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID)
+{
+	int iNumRows;
+
+	if ((iNumRows = static_cast<int>(mysql_num_rows(pRes))) == 0) //  
+	{
+		static DWORD dwPID;
+		static DWORD dwCount = 0; //1;
+		static TPacketAffectElement paeTable = { 0 };
+
+		dwPID = dwRealPID;
+		sys_log(0, "AFFECT_LOAD: count %u PID %u RealPID %u", dwCount, dwPID, dwRealPID);
+
+		peer->EncodeHeader(HEADER_DG_AFFECT_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPacketAffectElement) * dwCount);
+		peer->Encode(&dwPID, sizeof(DWORD));
+		peer->Encode(&dwCount, sizeof(DWORD));
+		peer->Encode(&paeTable, sizeof(TPacketAffectElement) * dwCount);
+		return;
+	}
+
+	static std::vector<TPacketAffectElement> s_elements;
+	s_elements.resize(iNumRows);
+
+	DWORD dwPID = 0;
+
+	MYSQL_ROW row;
+
+	for (int i = 0; i < iNumRows; ++i)
+	{
+		TPacketAffectElement& r = s_elements[i];
+		row = mysql_fetch_row(pRes);
+
+		if (dwPID == 0)
+			str_to_number(dwPID, row[0]);
+
+		// Robustness: if a married character is deleted, force marriage cleanup so the online partner
+		// does not keep stale relationship state/pointers in memory.
+		if (auto* pMarriage = marriage::CManager::instance().Get(dwPID))
+		{
+			marriage::CManager::instance().Remove(pMarriage->pid1, pMarriage->pid2);
+		}
+
+
+		str_to_number(r.dwType, row[1]);
+		str_to_number(r.wApplyOn, row[2]);
+		str_to_number(r.lApplyValue, row[3]);
+		str_to_number(r.dwFlag, row[4]);
+		str_to_number(r.lDuration, row[5]);
+		str_to_number(r.lSPCost, row[6]);
+#if defined(__AFFECT_RENEWAL__)
+		str_to_number(r.bRealTime, row[7]);
+		r.bUpdate = false;
+#endif
+	}
+
+	sys_log(0, "AFFECT_LOAD: count %d PID %u", s_elements.size(), dwPID);
+
+	DWORD dwCount = s_elements.size();
+
+	peer->EncodeHeader(HEADER_DG_AFFECT_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPacketAffectElement) * dwCount);
+	peer->Encode(&dwPID, sizeof(DWORD));
+	peer->Encode(&dwCount, sizeof(DWORD));
+	peer->Encode(&s_elements[0], sizeof(TPacketAffectElement) * dwCount);
+}
+
+void CClientManager::RESULT_QUEST_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD pid)
+{
+	int iNumRows;
+
+	if ((iNumRows = static_cast<int>(mysql_num_rows(pRes))) == 0)
+	{
+		DWORD dwCount = 0;
+		peer->EncodeHeader(HEADER_DG_QUEST_LOAD, dwHandle, sizeof(DWORD));
+		peer->Encode(&dwCount, sizeof(DWORD));
+		return;
+	}
+
+	static std::vector<TQuestTable> s_table;
+	s_table.resize(iNumRows);
+
+	MYSQL_ROW row;
+
+	for (int i = 0; i < iNumRows; ++i)
+	{
+		TQuestTable& r = s_table[i];
+
+		row = mysql_fetch_row(pRes);
+
+		str_to_number(r.dwPID, row[0]);
+		strlcpy(r.szName, row[1], sizeof(r.szName));
+		strlcpy(r.szState, row[2], sizeof(r.szState));
+		str_to_number(r.lValue, row[3]);
+	}
+
+	sys_log(0, "QUEST_LOAD: count %d PID %u", s_table.size(), s_table[0].dwPID);
+
+	DWORD dwCount = s_table.size();
+
+	peer->EncodeHeader(HEADER_DG_QUEST_LOAD, dwHandle, sizeof(DWORD) + sizeof(TQuestTable) * dwCount);
+	peer->Encode(&dwCount, sizeof(DWORD));
+	peer->Encode(&s_table[0], sizeof(TQuestTable) * dwCount);
+}
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+void CClientManager::RESULT_EXT_BATTLE_PASS_LOAD(CPeer* peer, MYSQL_RES* pRes, DWORD dwHandle, DWORD dwRealPID)
+{
+	int iNumRows;
+
+	if ((iNumRows = mysql_num_rows(pRes)) == 0)
+	{
+		DWORD dwCount = 0;
+		TPlayerExtBattlePassMission pbpTable = { 0 };
+
+		sys_log(0, "EXT_BATTLE_PASS_LOAD: count %u PID %u", dwCount, dwRealPID);
+
+		peer->EncodeHeader(HEADER_DG_EXT_BATTLE_PASS_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPlayerExtBattlePassMission) * dwCount);
+		peer->Encode(&dwRealPID, sizeof(DWORD));
+		peer->Encode(&dwCount, sizeof(DWORD));
+		peer->Encode(&pbpTable, sizeof(TPlayerExtBattlePassMission) * dwCount);
+		return;
+	}
+
+	static std::vector<TPlayerExtBattlePassMission> s_mission;
+	s_mission.resize(iNumRows);
+
+	MYSQL_ROW row;
+
+	for (int i = 0; i < iNumRows; ++i)
+	{
+		int col = 0;
+		TPlayerExtBattlePassMission& r = s_mission[i];
+		row = mysql_fetch_row(pRes);
+
+		str_to_number(r.dwPlayerId, row[col++]);
+		str_to_number(r.dwBattlePassType, row[col++]);
+		str_to_number(r.dwMissionIndex, row[col++]);
+		str_to_number(r.dwMissionType, row[col++]);
+		str_to_number(r.dwBattlePassId, row[col++]);
+		str_to_number(r.dwExtraInfo, row[col++]);
+		str_to_number(r.bCompleted, row[col++]);
+
+		r.bIsUpdated = 0;
+	}
+
+	sys_log(0, "EXT_BATTLE_PASS_LOAD: count %d PID %u", s_mission.size(), dwRealPID);
+
+	DWORD dwCount = s_mission.size();
+
+	peer->EncodeHeader(HEADER_DG_EXT_BATTLE_PASS_LOAD, dwHandle, sizeof(DWORD) + sizeof(DWORD) + sizeof(TPlayerExtBattlePassMission) * dwCount);
+	peer->Encode(&dwRealPID, sizeof(DWORD));
+	peer->Encode(&dwCount, sizeof(DWORD));
+	peer->Encode(&s_mission[0], sizeof(TPlayerExtBattlePassMission) * dwCount);
+}
+
+void CClientManager::QUERY_SAVE_EXT_BATTLE_PASS(CPeer* peer, DWORD dwHandle, TPlayerExtBattlePassMission* battlePass)
+{
+	if (g_test_server)
+		sys_log(0, "QUERY_SAVE_EXT_BATTLE_PASS: %lu", battlePass->dwPlayerId);
+
+	char szQuery[QUERY_MAX_LEN];
+	snprintf(szQuery, sizeof(szQuery),
+		"REPLACE INTO battlepass_missions (player_id, battlepass_type, mission_index, mission_type, battle_pass_id, extra_info, completed) VALUES (%lu, %d, %d, %d, %d, %d, %d)",
+		battlePass->dwPlayerId,
+		battlePass->dwBattlePassType,
+		battlePass->dwMissionIndex,
+		battlePass->dwMissionType,
+		battlePass->dwBattlePassId,
+		battlePass->dwExtraInfo,
+		battlePass->bCompleted ? 1 : 0);
+	CDBManager::instance().AsyncQuery(szQuery);
+}
+#endif
+
+/*
+* PLAYER SAVE
+*/
+void CClientManager::QUERY_PLAYER_SAVE(CPeer* peer, DWORD dwHandle, TPlayerTable* pkTab)
+{
+	if (g_test_server)
+		sys_log(0, "PLAYER_SAVE: %s", pkTab->name);
+
+	PutPlayerCache(pkTab);
+}
+
+typedef std::map<DWORD, time_t> time_by_id_map_t;
+static time_by_id_map_t s_createTimeByAccountID;
+
+/*
+* PLAYER CREATE
+*/
+void CClientManager::__QUERY_PLAYER_CREATE(CPeer* peer, DWORD dwHandle, TPlayerCreatePacket* packet)
+{
+	char queryStr[QUERY_MAX_LEN];
+	int queryLen;
+	int player_id;
+
+	//   X  캐    .
+	time_by_id_map_t::iterator it = s_createTimeByAccountID.find(packet->account_id);
+
+	if (m_bDelayedCharacterCreation)
+	{
+		if (it != s_createTimeByAccountID.end())
+		{
+			time_t curtime = time(0);
+
+			if (curtime - it->second < 30)
+			{
+				peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+				return;
+			}
+		}
+	}
+
+	queryLen = snprintf(queryStr, sizeof(queryStr),
+		"SELECT `pid%d` FROM player_index%s WHERE `id` = %d", packet->account_index + 1, GetTablePostfix(), packet->account_id);
+
+	std::unique_ptr<SQLMsg> pMsg0(CDBManager::instance().DirectQuery(queryStr));
+
+	if (pMsg0->Get()->uiNumRows != 0)
+	{
+		if (!pMsg0->Get()->pSQLResult)
+		{
+			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+			return;
+		}
+
+		MYSQL_ROW row = mysql_fetch_row(pMsg0->Get()->pSQLResult);
+
+		DWORD dwPID = 0; str_to_number(dwPID, row[0]);
+		if (row[0] && dwPID > 0)
+		{
+			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
+			sys_log(0, "ALREADY EXIST AccountChrIdx %d ID %d", packet->account_index, dwPID);
+			return;
+		}
+	}
+	else
+	{
+		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+		return;
+	}
+
+	char escPlayerName[sizeof(packet->player_table.name) * 2 + 1];
+	const size_t playerNameLen = strnlen(packet->player_table.name, sizeof(packet->player_table.name));
+	CDBManager::instance().EscapeString(escPlayerName, packet->player_table.name, static_cast<unsigned long>(playerNameLen));
+
+	if (g_stLocale == "sjis")
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT COUNT(*) AS count FROM player%s WHERE `name` = '%s' COLLATE sjis_japanese_ci",
+			GetTablePostfix(), escPlayerName);
+	else
+		snprintf(queryStr, sizeof(queryStr),
+			"SELECT COUNT(*) AS count FROM player%s WHERE `name` = '%s'", GetTablePostfix(), escPlayerName);
+
+	std::unique_ptr<SQLMsg> pMsg1(CDBManager::instance().DirectQuery(queryStr));
+
+	if (pMsg1->Get()->uiNumRows)
+	{
+		if (!pMsg1->Get()->pSQLResult)
+		{
+			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+			return;
+		}
+
+		MYSQL_ROW row = mysql_fetch_row(pMsg1->Get()->pSQLResult);
+
+		if (*row[0] != '0')
+		{
+			sys_log(0, "ALREADY EXIST name %s, row[0] %s query %s", packet->player_table.name, row[0], queryStr);
+			peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
+			return;
+		}
+	}
+	else
+	{
+		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+		return;
+	}
+
+	queryLen = snprintf(queryStr, sizeof(queryStr),
+		"INSERT INTO player%s "
+		"(`id`, `account_id`, `name`, `level`, `st`, `ht`, `dx`, `iq`, "
+		"`job`, `voice`, `dir`, `x`, `y`, `z`, "
+		"`hp`, `mp`, `random_hp`, `random_sp`, `stat_point`, `stamina`, "
+		"`part_base`, `part_main`, `part_hair`, "
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		"`part_acce`, "
+#endif
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		"`inven_stage`, "
+#endif
+		"`gold`, "
+#if defined(__CHEQUE_SYSTEM__)
+		"`cheque`, "
+#endif
+#if defined(__GEM_SYSTEM__)
+		"`gem`, "
+#endif
+		"`playtime`, `skill_level`, `quickslot`) "
+		"VALUES (0, "
+		"%u, "
+		"'%s', " // name (escaped)
+		"%d, " // level
+		"%d, " // st
+		"%d, " // ht
+		"%d, " // dx
+		"%d, " // iq
+		"%d, " // job
+		"%d, " // voice
+		"%d, " // dir
+		"%d, " // x
+		"%d, " // y
+		"%d, " // z
+		"%d, " // hp
+		"%d, " // sp
+		"%d, " // sRandomHP
+		"%d, " // sRandomSP
+		"%d, " // stat_point
+		"%d, " // stamina
+		"%d, " // part_base
+		"%d, " // part_base
+		"%d, " // part_base(hair)
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		"%d, " // part_base(acce)
+#endif
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		"%d, " // inven_stage
+#endif
+		"%d, " // gold
+#if defined(__CHEQUE_SYSTEM__)
+		"%d, " // cheque
+#endif
+#if defined(__GEM_SYSTEM__)
+		"%d, " // gem
+#endif
+		"0, "
+		, GetTablePostfix()
+		, packet->account_id
+		, packet->player_table.name
+		, packet->player_table.level
+		, packet->player_table.st
+		, packet->player_table.ht
+		, packet->player_table.dx
+		, packet->player_table.iq
+		, packet->player_table.job
+		, packet->player_table.voice
+		, packet->player_table.dir
+		, packet->player_table.x
+		, packet->player_table.y
+		, packet->player_table.z
+		, packet->player_table.hp
+		, packet->player_table.sp
+		, packet->player_table.sRandomHP
+		, packet->player_table.sRandomSP
+		, packet->player_table.stat_point
+		, packet->player_table.stamina
+		, packet->player_table.part_base
+		, packet->player_table.part_base
+		, packet->player_table.adwParts[PART_HAIR]
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		, packet->player_table.adwParts[PART_ACCE]
+#endif
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		, packet->player_table.inven_stage
+#endif
+		, packet->player_table.gold
+#if defined(__CHEQUE_SYSTEM__)
+		, packet->player_table.cheque
+#endif
+#if defined(__GEM_SYSTEM__)
+		, packet->player_table.gem
+#endif
+	);
+
+	sys_log(0, "PlayerCreate accountid %d name %s level %d gold %d"
+#if defined(__CHEQUE_SYSTEM__)
+		" cheque %d"
+#endif
+#if defined(__GEM_SYSTEM__)
+		" gem %d"
+#endif
+		", st %d ht %d job %d"
+		, packet->account_id
+		, packet->player_table.name
+		, packet->player_table.level
+		, packet->player_table.gold
+#if defined(__CHEQUE_SYSTEM__)
+		, packet->player_table.cheque
+#endif
+#if defined(__GEM_SYSTEM__)
+		, packet->player_table.gem
+#endif
+		, packet->player_table.st
+		, packet->player_table.ht
+		, packet->player_table.job
+	);
+
+	static char text[QUERY_MAX_LEN];
+
+	CDBManager::instance().EscapeString(text, packet->player_table.skills, sizeof(packet->player_table.skills));
+	queryLen += snprintf(queryStr + queryLen, sizeof(queryStr) - queryLen, "'%s', ", text);
+	if (g_test_server)
+		sys_log(0, "Create_Player queryLen[%d] TEXT[%s]", queryLen, text);
+
+	CDBManager::instance().EscapeString(text, packet->player_table.quickslot, sizeof(packet->player_table.quickslot));
+	queryLen += snprintf(queryStr + queryLen, sizeof(queryStr) - queryLen, "'%s')", text);
+
+	std::unique_ptr<SQLMsg> pMsg2(CDBManager::instance().DirectQuery(queryStr));
+	if (g_test_server)
+		sys_log(0, "Create_Player queryLen[%d] TEXT[%s]", queryLen, text);
+
+	if (pMsg2->Get()->uiAffectedRows <= 0)
+	{
+		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_ALREADY, dwHandle, 0);
+		sys_log(0, "ALREADY EXIST3 query: %s AffectedRows %lu", queryStr, pMsg2->Get()->uiAffectedRows);
+		return;
+	}
+
+	player_id = pMsg2->Get()->uiInsertID;
+
+	snprintf(queryStr, sizeof(queryStr), "UPDATE player_index%s SET `pid%d` = %d WHERE `id` = %d",
+		GetTablePostfix(), packet->account_index + 1, player_id, packet->account_id);
+	std::unique_ptr<SQLMsg> pMsg3(CDBManager::instance().DirectQuery(queryStr));
+
+	if (pMsg3->Get()->uiAffectedRows <= 0)
+	{
+		sys_err("QUERY_ERROR: %s", queryStr);
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM player%s WHERE `id` = %d", GetTablePostfix(), player_id);
+		CDBManager::instance().DirectQuery(queryStr);
+
+		peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_FAILED, dwHandle, 0);
+		return;
+	}
+
+	TPacketDGCreateSuccess pack;
+	memset(&pack, 0, sizeof(pack));
+
+	pack.bAccountCharacterIndex = packet->account_index;
+
+	pack.player.dwID = player_id;
+	strlcpy(pack.player.szName, packet->player_table.name, sizeof(pack.player.szName));
+	pack.player.byJob = packet->player_table.job;
+	pack.player.byLevel = 1;
+	pack.player.dwPlayMinutes = 0;
+	pack.player.byST = packet->player_table.st;
+	pack.player.byHT = packet->player_table.ht;
+	pack.player.byDX = packet->player_table.dx;
+	pack.player.byIQ = packet->player_table.iq;
+#if defined(__CONQUEROR_LEVEL__)
+	pack.player.byConquerorLevel = packet->player_table.conqueror_level;
+	pack.player.bySungmaStr = packet->player_table.sungma_str;
+	pack.player.bySungmaHp = packet->player_table.sungma_hp;
+	pack.player.bySungmaMove = packet->player_table.sungma_move;
+	pack.player.bySungmaImmune = packet->player_table.sungma_immune;
+#endif
+	pack.player.dwMainPart = packet->player_table.part_base;
+	pack.player.x = packet->player_table.x;
+	pack.player.y = packet->player_table.y;
+	pack.player.last_play = packet->player_table.last_play;
+
+	peer->EncodeHeader(HEADER_DG_PLAYER_CREATE_SUCCESS, dwHandle, sizeof(TPacketDGCreateSuccess));
+	peer->Encode(&pack, sizeof(TPacketDGCreateSuccess));
+
+	sys_log(0, "7 name %s job %d", pack.player.szName, pack.player.byJob);
+
+	s_createTimeByAccountID[packet->account_id] = time(0);
+}
+
+/*
+* PLAYER DELETE
+*/
+#if defined(__DELETE_FAILURE_TYPE__)
+static char QUERY_CHECK_PLAYER_DELETE(DWORD dwPID, DWORD dwAID, INT* piWaitTime)
+{
+	*piWaitTime = 0;
+
+	SQLMsg* pMsg = NULL;
+	char szQuery[QUERY_MAX_LEN] = {};
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	// Check if the player has any sealed items.
+	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `soulbind` != 0", GetTablePostfix(), dwPID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get()->uiNumRows)
+		return DELETE_FAILURE_HAVE_SEALED_ITEM;
+#endif
+
+	// Check if the player is a member of a guild.
+	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM guild_member%s WHERE `pid` = %d", GetTablePostfix(), dwPID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get()->uiNumRows)
+		return DELETE_FAILURE_GUILD_MEMBER;
+
+	// Check if the player is married.
+	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM marriage%s WHERE `pid1` = %d OR `pid2` = %d", GetTablePostfix(), dwPID, dwPID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get()->uiNumRows)
+		return DELETE_FAILURE_MARRIAGE;
+
+	// Check if the player is the last character on the account and if there are any items in the safebox.
+	snprintf(szQuery, sizeof(szQuery), "SELECT COUNT(*) FROM `player%s` WHERE `account_id` = %u;", GetTablePostfix(), dwAID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get() && pMsg->Get()->uiNumRows)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+
+		BYTE bPlayerCount = 0;
+		str_to_number(bPlayerCount, row[0]);
+
+		if (bPlayerCount == 1)
+		{
+			snprintf(szQuery, sizeof(szQuery), "SELECT * FROM `item%s` WHERE `owner_id` = %u AND `window` = 'SAFEBOX' > 0;", GetTablePostfix(), dwAID);
+			pMsg = CDBManager::Instance().DirectQuery(szQuery);
+			if (pMsg->Get()->uiNumRows)
+				return DELETE_FAILURE_LAST_CHAR_SAFEBOX;
+		}
+	}
+
+#if defined(__ATTR_6TH_7TH__)
+	// Check if the player has any items in the NPC storage.
+	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `window` = 'NPC_STORAGE'", GetTablePostfix(), dwPID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get()->uiNumRows)
+		return DELETE_FAILURE_ATTR67;
+#endif
+
+	// Check if the player has any items in the premium private shop.
+	snprintf(szQuery, sizeof(szQuery), "SELECT * FROM item%s WHERE `owner_id` = %d AND `window` = 'PREMIUM_PRIVATE_SHOP'", GetTablePostfix(), dwPID);
+	pMsg = CDBManager::Instance().DirectQuery(szQuery);
+	if (pMsg->Get()->uiNumRows)
+		return DELETE_FAILURE_PREMIUM_PRIVATE_SHOP;
+
+	// Check if the player has at least 10 minutes of playtime.
+	/*
+	CPlayerTableCache* pPlayerTableCache = CClientManager::Instance().GetPlayerCache(dwPID);
+	INT iPlayTime = pPlayerTableCache ? pPlayerTableCache->Get(false)->playtime : 0;
+	if (iPlayTime < 10)
+	{
+		*piWaitTime = 10 - iPlayTime;
+		return DELETE_FAILURE_REMAIN_TIME;
+	}
+	*/
+
+	return -1;
+}
+#endif
+
+void CClientManager::__QUERY_PLAYER_DELETE(CPeer* peer, DWORD dwHandle, TPlayerDeletePacket* packet)
+{
+	if (!packet->login[0] || !packet->player_id || packet->account_index >= PLAYER_PER_ACCOUNT)
+		return;
+
+	CLoginData* ld = GetLoginDataByLogin(packet->login);
+
+	if (!ld)
+	{
+#if defined(__DELETE_FAILURE_TYPE__)
+		TPlayerDeleteFailurePacket DelFailurePacket = {};
+		DelFailurePacket.bType = DELETE_FAILURE_NORMAL;
+		DelFailurePacket.iTime = 0;
+		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
+		peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
+#else
+		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
+		peer->EncodeBYTE(packet->account_index);
+#endif
+		return;
+	}
+
+	TAccountTable& r = ld->GetAccountRef();
+
+	// block for japan
+	if (g_stLocale != "sjis")
+	{
+		if (!IsChinaEventServer())
+		{
+			if (strlen(r.social_id) < 7 || strncmp(packet->private_code, r.social_id + strlen(r.social_id) - 7, 7))
+			{
+				sys_log(0, "PLAYER_DELETE FAILED len(%d)", strlen(r.social_id));
+#if defined(__DELETE_FAILURE_TYPE__)
+				TPlayerDeleteFailurePacket DelFailurePacket;
+				DelFailurePacket.bType = DELETE_FAILURE_PRIVATE_CODE_ERROR;
+				DelFailurePacket.iTime = 0;
+				peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
+				peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
+#else
+				peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
+				peer->EncodeBYTE(packet->account_index);
+#endif
+				return;
+			}
+
+			CPlayerTableCache* pkPlayerCache = GetPlayerCache(packet->player_id);
+			if (pkPlayerCache)
+			{
+				TPlayerTable* pTab = pkPlayerCache->Get();
+
+				if (pTab->level >= m_iPlayerDeleteLevelLimit)
+				{
+					sys_log(0, "PLAYER_DELETE FAILED LEVEL %u >= DELETE LIMIT %d", pTab->level, m_iPlayerDeleteLevelLimit);
+#if defined(__DELETE_FAILURE_TYPE__)
+					TPlayerDeleteFailurePacket DelFailurePacket;
+					DelFailurePacket.bType = DELETE_FAILURE_LIMITE_LEVEL_HIGHER;
+					DelFailurePacket.iTime = 0;
+					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
+					peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
+#else
+					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
+					peer->EncodeBYTE(packet->account_index);
+#endif
+					return;
+				}
+
+				if (pTab->level < m_iPlayerDeleteLevelLimitLower)
+				{
+					sys_log(0, "PLAYER_DELETE FAILED LEVEL %u < DELETE LIMIT %d", pTab->level, m_iPlayerDeleteLevelLimitLower);
+#if defined(__DELETE_FAILURE_TYPE__)
+					TPlayerDeleteFailurePacket DelFailurePacket;
+					DelFailurePacket.bType = DELETE_FAILURE_LIMITE_LEVEL_LOWER;
+					DelFailurePacket.iTime = 0;
+					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
+					peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
+#else
+					peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(BYTE));
+					peer->EncodeBYTE(packet->account_index);
+#endif
+					return;
+				}
+			}
+		}
+	}
+
+#if defined(__DELETE_FAILURE_TYPE__)
+	INT iWaitTime;
+	const char bFailureType = QUERY_CHECK_PLAYER_DELETE(packet->player_id, r.id, &iWaitTime);
+	if (bFailureType != -1)
+	{
+		TPlayerDeleteFailurePacket DelFailurePacket;
+		DelFailurePacket.bType = bFailureType;
+		DelFailurePacket.iTime = iWaitTime;
+		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, dwHandle, sizeof(TPlayerDeleteFailurePacket));
+		peer->Encode(&DelFailurePacket, sizeof(TPlayerDeleteFailurePacket));
+		return;
+}
+#endif
+
+	char szQuery[128];
+	snprintf(szQuery, sizeof(szQuery), "SELECT p.`id`, p.`level`, p.`name` FROM player_index%s AS i, player%s AS p WHERE `pid%d` = %u AND `pid%d` = p.`id`",
+		GetTablePostfix(), GetTablePostfix(), packet->account_index + 1, packet->player_id, packet->account_index + 1);
+
+	ClientHandleInfo* pi = new ClientHandleInfo(dwHandle, packet->player_id);
+	pi->account_index = packet->account_index;
+
+	sys_log(0, "PLAYER_DELETE TRY: %s %d pid%d", packet->login, packet->player_id, packet->account_index + 1);
+	CDBManager::instance().ReturnQuery(szQuery, QID_PLAYER_DELETE, peer->GetHandle(), pi);
+}
+
+//
+// @version	05/06/10 Bang2ni - 첨潔   트  煞.
+//
+void CClientManager::__RESULT_PLAYER_DELETE(CPeer* peer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
+
+	if (msg->Get() && msg->Get()->uiNumRows)
+	{
+		MYSQL_ROW row = mysql_fetch_row(msg->Get()->pSQLResult);
+
+		DWORD dwPID = 0;
+		str_to_number(dwPID, row[0]);
+
+		int deletedLevelLimit = 0;
+		str_to_number(deletedLevelLimit, row[1]);
+
+		char szName[64];
+		strlcpy(szName, row[2], sizeof(szName));
+
+		if (deletedLevelLimit >= m_iPlayerDeleteLevelLimit && !IsChinaEventServer())
+		{
+			sys_log(0, "PLAYER_DELETE FAILED LEVEL %u >= DELETE LIMIT %d", deletedLevelLimit, m_iPlayerDeleteLevelLimit);
+			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
+			peer->EncodeBYTE(pi->account_index);
+			return;
+		}
+
+		if (deletedLevelLimit < m_iPlayerDeleteLevelLimitLower)
+		{
+			sys_log(0, "PLAYER_DELETE FAILED LEVEL %u < DELETE LIMIT %d", deletedLevelLimit, m_iPlayerDeleteLevelLimitLower);
+			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
+			peer->EncodeBYTE(pi->account_index);
+			return;
+		}
+
+		char queryStr[QUERY_MAX_LEN];
+
+		snprintf(queryStr, sizeof(queryStr), "INSERT INTO player_deleted%s SELECT * FROM player%s WHERE `id` = %d",
+			GetTablePostfix(), GetTablePostfix(), pi->player_id);
+		std::unique_ptr<SQLMsg> pIns(CDBManager::instance().DirectQuery(queryStr));
+
+		if (pIns->Get()->uiAffectedRows == 0 || pIns->Get()->uiAffectedRows == (uint32_t)-1)
+		{
+			sys_log(0, "PLAYER_DELETE FAILED %u CANNOT INSERT TO player_deleted%s", dwPID, GetTablePostfix());
+
+			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
+			peer->EncodeBYTE(pi->account_index);
+			return;
+		}
+
+		//  
+		sys_log(0, "PLAYER_DELETE SUCCESS %u", dwPID);
+
+		// char account_index_string[16];
+
+		// snprintf(account_index_string, sizeof(account_index_string), "player_id%d", m_iPlayerIDStart + pi->account_index);
+
+		// 첨潔 遣 캐 磯.
+		CPlayerTableCache* pkPlayerCache = GetPlayerCache(pi->player_id);
+
+		if (pkPlayerCache)
+		{
+			m_map_playerCache.erase(pi->player_id);
+			delete pkPlayerCache;
+		}
+
+		// 滂 캐 磯.
+		TItemCacheSet* pSet = GetItemCacheSet(pi->player_id);
+
+		if (pSet)
+		{
+			TItemCacheSet::iterator it = pSet->begin();
+
+			while (it != pSet->end())
+			{
+				CItemCache* pkItemCache = *it++;
+				DeleteItemCache(pkItemCache->Get()->dwID);
+			}
+
+			pSet->clear();
+			delete pSet;
+
+			m_map_pkItemCacheSetPtr.erase(pi->player_id);
+		}
+
+		snprintf(queryStr, sizeof(queryStr), "UPDATE player_index%s SET `pid%d` = 0 WHERE `pid%d` = %d",
+			GetTablePostfix(),
+			pi->account_index + 1,
+			pi->account_index + 1,
+			pi->player_id);
+
+		std::unique_ptr<SQLMsg> pMsg(CDBManager::instance().DirectQuery(queryStr));
+
+		if (pMsg->Get()->uiAffectedRows == 0 || pMsg->Get()->uiAffectedRows == (uint32_t)-1)
+		{
+			sys_log(0, "PLAYER_DELETE FAIL WHEN UPDATE account table");
+			peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
+			peer->EncodeBYTE(pi->account_index);
+			return;
+		}
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `player%s` WHERE `id` = %u", GetTablePostfix(), pi->player_id);
+		delete CDBManager::instance().DirectQuery(queryStr);
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `item%s` WHERE `owner_id` = %u AND (`window` in ("
+			"'INVENTORY', 'EQUIPMENT', 'DRAGON_SOUL_INVENTORY', 'BELT_INVENTORY'"
+#if defined(__ATTR_6TH_7TH__)
+			", 'NPC_STORAGE'"
+#endif
+			"))", GetTablePostfix(), pi->player_id);
+		delete CDBManager::instance().DirectQuery(queryStr);
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `quest%s` WHERE `dwPID` = %d", GetTablePostfix(), pi->player_id);
+		CDBManager::instance().AsyncQuery(queryStr);
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `affect%s` WHERE `dwPID` = %d", GetTablePostfix(), pi->player_id);
+		CDBManager::instance().AsyncQuery(queryStr);
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `guild_member%s` WHERE `pid` = %u", GetTablePostfix(), pi->player_id);
+		CDBManager::instance().AsyncQuery(queryStr);
+
+		// MYSHOP_PRICE_LIST
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `myshop_pricelist%s` WHERE `owner_id` = %u", GetTablePostfix(), pi->player_id);
+		CDBManager::instance().AsyncQuery(queryStr);
+		// END_OF_MYSHOP_PRICE_LIST
+
+		char escName[sizeof(szName) * 2 + 1];
+		const size_t nameLen = strnlen(szName, sizeof(szName));
+		CDBManager::instance().EscapeString(escName, szName, static_cast<unsigned long>(nameLen));
+
+		snprintf(queryStr, sizeof(queryStr), "DELETE FROM `messenger_list%s` WHERE `account` = '%s' OR `companion` = '%s'",
+			GetTablePostfix(), escName, escName);
+		CDBManager::instance().AsyncQuery(queryStr);
+
+		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_SUCCESS, pi->dwHandle, 1);
+		peer->EncodeBYTE(pi->account_index);
+	}
+	else
+	{
+		//  
+		sys_log(0, "PLAYER_DELETE FAIL NO ROW");
+		peer->EncodeHeader(HEADER_DG_PLAYER_DELETE_FAILED, pi->dwHandle, 1);
+		peer->EncodeBYTE(pi->account_index);
+	}
+}
+
+void CClientManager::QUERY_ADD_AFFECT(CPeer* peer, TPacketGDAddAffect* p)
+{
+	char query[QUERY_MAX_LEN];
+#if defined(__AFFECT_RENEWAL__)
+	if (p->elem.bUpdate)
+	{
+		snprintf(query, sizeof(query),
+			"UPDATE `affect%s` SET `lApplyValue` = %ld, `dwFlag` = %u, `lDuration` = %ld, `lSPCost` = %ld, `bRealTime` = %d "
+			"WHERE `dwPID` = %u AND `dwType` = %u AND `wApplyOn` = %u",
+			GetTablePostfix(),
+			p->elem.lApplyValue,
+			p->elem.dwFlag,
+			p->elem.lDuration,
+			p->elem.lSPCost,
+			p->elem.bRealTime ? 1 : 0,
+			p->dwPID,
+			p->elem.dwType,
+			p->elem.wApplyOn);
+	}
+	else
+	{
+		snprintf(query, sizeof(query),
+			"REPLACE INTO `affect%s` (`dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`, `bRealTime`) "
+			"VALUES(%u, %u, %u, %ld, %u, %ld, %ld, %d)",
+			GetTablePostfix(),
+			p->dwPID,
+			p->elem.dwType,
+			p->elem.wApplyOn,
+			p->elem.lApplyValue,
+			p->elem.dwFlag,
+			p->elem.lDuration,
+			p->elem.lSPCost,
+			p->elem.bRealTime ? 1 : 0);
+	}
+#else
+	snprintf(query, sizeof(query),
+		"REPLACE INTO `affect%s` (`dwPID`, `dwType`, `wApplyOn`, `lApplyValue`, `dwFlag`, `lDuration`, `lSPCost`) "
+		"VALUES(%u, %u, %u, %ld, %u, %ld, %ld)",
+		GetTablePostfix(),
+		p->dwPID,
+		p->elem.dwType,
+		p->elem.wApplyOn,
+		p->elem.lApplyValue,
+		p->elem.dwFlag,
+		p->elem.lDuration,
+		p->elem.lSPCost
+	);
+#endif
+	CDBManager::instance().AsyncQuery(query);
+}
+
+void CClientManager::QUERY_REMOVE_AFFECT(CPeer* peer, TPacketGDRemoveAffect* p)
+{
+	char query[QUERY_MAX_LEN];
+	snprintf(query, sizeof(query),
+		"DELETE FROM `affect%s` WHERE `dwPID` = %u AND `dwType` = %u AND `wApplyOn` = %u",
+		GetTablePostfix(), p->dwPID, p->dwType, p->wApplyOn);
+	CDBManager::instance().AsyncQuery(query);
+}
+
+void CClientManager::QUERY_HIGHSCORE_REGISTER(CPeer* peer, TPacketGDHighscore* data)
+{
+	char escBoard[sizeof(data->szBoard) * 2 + 1];
+	const size_t boardLen = strnlen(data->szBoard, sizeof(data->szBoard));
+	CDBManager::instance().EscapeString(escBoard, data->szBoard, static_cast<unsigned long>(boardLen));
+
+	char szQuery[256];
+	snprintf(szQuery, sizeof(szQuery),
+		"SELECT `value` FROM highscore%s WHERE `board` = '%s' AND `pid` = %u",
+		GetTablePostfix(), escBoard, data->dwPID);
+
+	sys_log(0, "HEADER_GD_HIGHSCORE_REGISTER: PID %u", data->dwPID);
+
+	ClientHandleInfo* pi = new ClientHandleInfo(0);
+	strlcpy(pi->login, data->szBoard, sizeof(pi->login));
+	pi->account_id = (DWORD)data->lValue;
+	pi->player_id = data->dwPID;
+	pi->account_index = (data->cDir > 0);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_HIGHSCORE_REGISTER, peer->GetHandle(), pi);
+}
+
+void CClientManager::RESULT_HIGHSCORE_REGISTER(CPeer* pkPeer, SQLMsg* msg)
+{
+	CQueryInfo* qi = (CQueryInfo*)msg->pvUserData;
+	ClientHandleInfo* pi = (ClientHandleInfo*)qi->pvData;
+	//DWORD dwHandle = pi->dwHandle;
+
+	char szBoard[21];
+	strlcpy(szBoard, pi->login, sizeof(szBoard));
+	int value = (int)pi->account_id;
+
+	SQLResult* res = msg->Get();
+
+	if (res->uiNumRows == 0)
+	{
+		// \xbb\xf5\xb7恝\xee \xc7\xcf\xc0決\xba\xc4岷低 \xbb\xf0\xc0\xd4
+		char buf[256];
+		char escBoard[sizeof(szBoard) * 2 + 1];
+		const size_t boardLen = strnlen(szBoard, sizeof(szBoard));
+		CDBManager::instance().EscapeString(escBoard, szBoard, static_cast<unsigned long>(boardLen));
+
+		snprintf(buf, sizeof(buf), "INSERT INTO highscore%s VALUES('%s', %u, %d)",
+			GetTablePostfix(), escBoard, pi->player_id, value);
+		CDBManager::instance().AsyncQuery(buf);
+	}
+	else
+	{
+		if (!res->pSQLResult)
+		{
+			delete pi;
+			return;
+		}
+
+		MYSQL_ROW row = mysql_fetch_row(res->pSQLResult);
+		if (row && row[0])
+		{
+			int current_value = 0; str_to_number(current_value, row[0]);
+			if ((pi->account_index && current_value >= value) || (!pi->account_index && current_value <= value))
+			{
+				value = current_value;
+			}
+			else
+			{
+				char buf[256];
+				snprintf(buf, sizeof(buf), "REPLACE INTO highscore%s VALUES('%s', %u, %d)", GetTablePostfix(), szBoard, pi->player_id, value);
+				CDBManager::instance().AsyncQuery(buf);
+			}
+		}
+		else
+		{
+			char buf[256];
+			snprintf(buf, sizeof(buf), "INSERT INTO highscore%s VALUES('%s', %u, %d)", GetTablePostfix(), szBoard, pi->player_id, value);
+			CDBManager::instance().AsyncQuery(buf);
+		}
+	}
+	// TODO: 隔 決岷載 트 퓸 체크臼  祈磯.
+	delete pi;
+}
+
+void CClientManager::InsertLogoutPlayer(DWORD pid)
+{
+	TLogoutPlayerMap::iterator it = m_map_logout.find(pid);
+
+	//   煞
+	if (it != m_map_logout.end())
+	{
+		// 柰 챨 
+		if (g_log)
+			sys_log(0, "LOGOUT: Update player time pid(%d)", pid);
+
+		it->second->time = time(0);
+		return;
+	}
+
+	TLogoutPlayer* pLogout = new TLogoutPlayer;
+	pLogout->pid = pid;
+	pLogout->time = time(0);
+	m_map_logout.insert(std::make_pair(pid, pLogout));
+
+	if (g_log)
+		sys_log(0, "LOGOUT: Insert player pid(%d)", pid);
+}
+
+void CClientManager::DeleteLogoutPlayer(DWORD pid)
+{
+	TLogoutPlayerMap::iterator it = m_map_logout.find(pid);
+
+	if (it != m_map_logout.end())
+	{
+		delete it->second;
+		m_map_logout.erase(it);
+	}
+}
+
+extern int g_iLogoutSeconds;
+
+void CClientManager::UpdateLogoutPlayer()
+{
+	time_t now = time(0);
+
+	TLogoutPlayerMap::iterator it = m_map_logout.begin();
+
+	while (it != m_map_logout.end())
+	{
+		TLogoutPlayer* pLogout = it->second;
+
+		if (now - g_iLogoutSeconds > pLogout->time)
+		{
+			FlushItemCacheSet(pLogout->pid);
+			FlushPlayerCacheSet(pLogout->pid);
+#ifdef __GROWTH_PET_SYSTEM__
+			FlushGrowthPetCacheSet(pLogout->pid);
+#endif
+			delete pLogout;
+			m_map_logout.erase(it++);
+		}
+		else
+			++it;
+	}
+}
+
+void CClientManager::FlushPlayerCacheSet(DWORD pid)
+{
+	TPlayerTableCacheMap::iterator it = m_map_playerCache.find(pid);
+
+	if (it != m_map_playerCache.end())
+	{
+		CPlayerTableCache* c = it->second;
+		m_map_playerCache.erase(it);
+
+		c->Flush();
+		delete c;
+	}
+}
diff --git a/server/metin2/Source/Server/db/src/GuildManager.cpp b/server/metin2/Source/Server/db/src/GuildManager.cpp
index 596222e..ecd50a0 100644
--- a/server/metin2/Source/Server/db/src/GuildManager.cpp
+++ b/server/metin2/Source/Server/db/src/GuildManager.cpp
@@ -1,1471 +1,1486 @@
-#include "stdafx.h"
-#include "GuildManager.h"
-#include "Main.h"
-#include "ClientManager.h"
-#include "QID.h"
-#include "Config.h"
-#include <math.h>
-
-extern std::string g_stLocale;
-
-const int GUILD_RANK_MAX_NUM = 20;
-
-bool isEurope()
-{
-	do
-	{
-		if (g_stLocale.compare("germany") == 0) break;
-		if (g_stLocale.compare("france") == 0) break;
-		if (g_stLocale.compare("italy") == 0) break;
-		if (g_stLocale.compare("spain") == 0) break;
-		if (g_stLocale.compare("uk") == 0) break;
-		if (g_stLocale.compare("turkey") == 0) break;
-		if (g_stLocale.compare("poland") == 0) break;
-		if (g_stLocale.compare("portugal") == 0) break;
-		if (g_stLocale.compare("greek") == 0) break;
-
-		return false;
-	} while (false);
-
-	return true;
-}
-
-DWORD GetGuildWarWaitStartDuration()
-{
-	// const int GUILD_WAR_WAIT_START_DURATION = 60s;
-	// const int GUILD_WAR_WAIT_START_DURATION = 5; 
-
-	if (isEurope() == true) return 60;
-	else return 5;
-}
-
-DWORD GetGuildWarReserveSeconds()
-{
-	// const int GUILD_WAR_RESERVE_SECONDS = 180;
-	// const int GUILD_WAR_RESERVE_SECONDS = 10;
-
-	if (isEurope() == true) return 180;
-	else return 10;
-}
-
-namespace
-{
-	struct FSendPeerWar
-	{
-		FSendPeerWar(BYTE bType, BYTE bWar, DWORD GID1, DWORD GID2)
-		{
-			if (number(0, 1))
-				std::swap(GID1, GID2);
-
-			memset(&p, 0, sizeof(TPacketGuildWar));
-
-			p.bWar = bWar;
-			p.bType = bType;
-			p.dwGuildFrom = GID1;
-			p.dwGuildTo = GID2;
-		}
-
-		void operator() (CPeer* peer)
-		{
-			if (peer->GetChannel() == 0)
-				return;
-
-			peer->EncodeHeader(HEADER_DG_GUILD_WAR, 0, sizeof(TPacketGuildWar));
-			peer->Encode(&p, sizeof(TPacketGuildWar));
-		}
-
-		TPacketGuildWar p;
-	};
-
-	struct FSendGuildWarScore
-	{
-		FSendGuildWarScore(DWORD guild_gain, DWORD dwOppGID, int iScore, int iBetScore)
-		{
-			pck.dwGuildGainPoint = guild_gain;
-			pck.dwGuildOpponent = dwOppGID;
-			pck.lScore = iScore;
-			pck.lBetScore = iBetScore;
-		}
-
-		void operator() (CPeer* peer)
-		{
-			if (peer->GetChannel() == 0)
-				return;
-
-			peer->EncodeHeader(HEADER_DG_GUILD_WAR_SCORE, 0, sizeof(pck));
-			peer->Encode(&pck, sizeof(pck));
-		}
-
-		TPacketGuildWarScore pck;
-	};
-}
-
-CGuildManager::CGuildManager()
-{
-}
-
-CGuildManager::~CGuildManager()
-{
-	while (!m_pqOnWar.empty())
-	{
-		if (!m_pqOnWar.top().second->bEnd)
-			delete m_pqOnWar.top().second;
-
-		m_pqOnWar.pop();
-	}
-}
-
-TGuild& CGuildManager::TouchGuild(DWORD GID)
-{
-	auto it = m_map_kGuild.find(GID);
-	if (it != m_map_kGuild.end())
-		return it->second;
-
-	TGuild info;
-	m_map_kGuild.insert(std::map<DWORD, TGuild>::value_type(GID, info));
-	return m_map_kGuild[GID];
-}
-
-void CGuildManager::ParseResult(SQLResult* pRes)
-{
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pRes->pSQLResult)))
-	{
-		DWORD GID = strtoul(row[0], NULL, 10);
-
-		TGuild& r_info = TouchGuild(GID);
-
-		strlcpy(r_info.szName, row[1], sizeof(r_info.szName));
-		str_to_number(r_info.ladder_point, row[2]);
-		str_to_number(r_info.win, row[3]);
-		str_to_number(r_info.draw, row[4]);
-		str_to_number(r_info.loss, row[5]);
-		str_to_number(r_info.gold, row[6]);
-		str_to_number(r_info.level, row[7]);
-
-		sys_log(0,
-			"GuildWar: %-24s ladder %-5d win %-3d draw %-3d loss %-3d",
-			r_info.szName,
-			r_info.ladder_point,
-			r_info.win,
-			r_info.draw,
-			r_info.loss);
-	}
-}
-
-void CGuildManager::Initialize()
-{
-	char szQuery[1024];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `id`, `name`, `ladder_point`, `win`, `draw`, `loss`, `gold`, `level` FROM guild%s", GetTablePostfix());
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-	if (pmsg->Get()->uiNumRows)
-		ParseResult(pmsg->Get());
-
-	char str[128 + 1];
-
-	if (!CConfig::instance().GetValue("POLY_POWER", str, sizeof(str)))
-		*str = '\0';
-
-	if (!polyPower.Analyze(str))
-		sys_err("cannot set power poly: %s", str);
-	else
-		sys_log(0, "POWER_POLY: %s", str);
-
-	if (!CConfig::instance().GetValue("POLY_HANDICAP", str, sizeof(str)))
-		*str = '\0';
-
-	if (!polyHandicap.Analyze(str))
-		sys_err("cannot set handicap poly: %s", str);
-	else
-		sys_log(0, "HANDICAP_POLY: %s", str);
-
-	QueryRanking();
-}
-
-void CGuildManager::Load(DWORD dwGuildID)
-{
-	char szQuery[1024];
-
-	snprintf(szQuery, sizeof(szQuery), "SELECT `id`, `name`, `ladder_point`, `win`, `draw`, `loss`, `gold`, `level` FROM guild%s WHERE id=%u", GetTablePostfix(), dwGuildID);
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-	if (pmsg->Get()->uiNumRows)
-		ParseResult(pmsg->Get());
-}
-
-void CGuildManager::QueryRanking()
-{
-	char szQuery[256];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `id`, `name`, `ladder_point` FROM guild%s ORDER BY `ladder_point` DESC LIMIT 20", GetTablePostfix());
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_GUILD_RANKING, 0, 0);
-}
-
-int CGuildManager::GetRanking(DWORD dwGID)
-{
-	auto it = map_kLadderPointRankingByGID.find(dwGID);
-	if (it == map_kLadderPointRankingByGID.end())
-		return GUILD_RANK_MAX_NUM;
-
-	return MINMAX(0, it->second, GUILD_RANK_MAX_NUM);
-}
-
-void CGuildManager::ResultRanking(MYSQL_RES* pRes)
-{
-	if (!pRes)
-		return;
-
-	int iLastLadderPoint = -1;
-	int iRank = 0;
-
-	map_kLadderPointRankingByGID.clear();
-
-	MYSQL_ROW row;
-
-	while ((row = mysql_fetch_row(pRes)))
-	{
-		DWORD dwGID = 0; str_to_number(dwGID, row[0]);
-		int iLadderPoint = 0; str_to_number(iLadderPoint, row[2]);
-
-		if (iLadderPoint != iLastLadderPoint)
-			++iRank;
-
-		sys_log(0, "GUILD_RANK: %-24s %2d %d", row[1], iRank, iLadderPoint);
-
-		map_kLadderPointRankingByGID.insert(std::make_pair(dwGID, iRank));
-	}
-}
-
-void CGuildManager::Update()
-{
-	ProcessReserveWar(); // 예약 전쟁 처리
-
-	time_t now = CClientManager::instance().GetCurrentTime();
-
-	if (!m_pqOnWar.empty())
-	{
-		// UNKNOWN_GUILD_MANAGE_UPDATE_LOG
-		/*
-		sys_log(0, "GuildManager::Update size %d now %d top %d, %s(%u) vs %s(%u)",
-			m_WarMap.size(),
-			now,
-			m_pqOnWar.top().first,
-			m_map_kGuild[m_pqOnWar.top().second->GID[0]].szName,
-			m_pqOnWar.top().second->GID[0],
-			m_map_kGuild[m_pqOnWar.top().second->GID[1]].szName,
-			m_pqOnWar.top().second->GID[1]
-		);
-		*/
-		// END_OF_UNKNOWN_GUILD_MANAGE_UPDATE_LOG
-
-		while (!m_pqOnWar.empty() && (m_pqOnWar.top().first <= now || (m_pqOnWar.top().second && m_pqOnWar.top().second->bEnd)))
-		{
-			TGuildWarPQElement* e = m_pqOnWar.top().second;
-
-			m_pqOnWar.pop();
-
-			if (e)
-			{
-				if (!e->bEnd)
-					WarEnd(e->GID[0], e->GID[1], false);
-
-				delete e;
-			}
-		}
-	}
-
-	// GUILD_SKILL_COOLTIME_BUG_FIX
-	while (!m_pqSkill.empty() && m_pqSkill.top().first <= now)
-	{
-		const TGuildSkillUsed& s = m_pqSkill.top().second;
-		CClientManager::instance().SendGuildSkillUsable(s.GID, s.dwSkillVnum, true);
-		m_pqSkill.pop();
-	}
-	// END_OF_GUILD_SKILL_COOLTIME_BUG_FIX
-
-	while (!m_pqWaitStart.empty() && m_pqWaitStart.top().first <= now)
-	{
-		const TGuildWaitStartInfo& ws = m_pqWaitStart.top().second;
-		m_pqWaitStart.pop();
-
-		StartWar(ws.bType, ws.GID[0], ws.GID[1], ws.pkReserve); // insert new element to m_WarMap and m_pqOnWar
-
-		if (ws.lInitialScore)
-		{
-			UpdateScore(ws.GID[0], ws.GID[1], ws.lInitialScore, 0);
-			UpdateScore(ws.GID[1], ws.GID[0], ws.lInitialScore, 0);
-		}
-
-		TPacketGuildWar p;
-
-		p.bType = ws.bType;
-		p.bWar = GUILD_WAR_ON_WAR;
-		p.dwGuildFrom = ws.GID[0];
-		p.dwGuildTo = ws.GID[1];
-
-		CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR, &p, sizeof(p));
-		sys_log(0, "GuildWar: GUILD sending start of wait start war %d %d", ws.GID[0], ws.GID[1]);
-	}
-}
-
-void CGuildManager::OnSetup(CPeer* peer)
-{
-	for (GuildWarMap::iterator it_cont = m_WarMap.begin(); it_cont != m_WarMap.end(); ++it_cont)
-	{
-		for (GuildWarInfoMap::iterator it = it_cont->second.begin(); it != it_cont->second.end(); ++it)
-		{
-			DWORD g1 = it_cont->first;
-			DWORD g2 = it->first;
-			TGuildWarPQElement* p = it->second.pElement;
-
-			if (!p || p->bEnd)
-				continue;
-
-			FSendPeerWar(p->bType, GUILD_WAR_ON_WAR, g1, g2) (peer);
-			FSendGuildWarScore(p->GID[0], p->GID[1], p->iScore[0], p->iBetScore[0]);
-			FSendGuildWarScore(p->GID[1], p->GID[0], p->iScore[1], p->iBetScore[1]);
-		}
-	}
-
-	for (GuildDeclareInfoSet::iterator it = m_DeclareMap.begin(); it != m_DeclareMap.end(); ++it)
-	{
-		FSendPeerWar(it->bType, GUILD_WAR_SEND_DECLARE, it->dwGuildID[0], it->dwGuildID[1]) (peer);
-	}
-
-	for (WarReserveMap::iterator it = m_map_kWarReserve.begin(); it != m_map_kWarReserve.end(); ++it)
-	{
-		it->second->OnSetup(peer);
-	}
-}
-
-void CGuildManager::GuildWarWin(DWORD GID)
-{
-	auto it = m_map_kGuild.find(GID);
-	if (it == m_map_kGuild.end())
-		return;
-
-	++it->second.win;
-
-	char buf[1024];
-	snprintf(buf, sizeof(buf), "UPDATE guild%s SET `win` = %d WHERE `id` = %u", GetTablePostfix(), it->second.win, GID);
-	CDBManager::instance().AsyncQuery(buf);
-}
-
-void CGuildManager::GuildWarLose(DWORD GID)
-{
-	auto it = m_map_kGuild.find(GID);
-	if (it == m_map_kGuild.end())
-		return;
-
-	++it->second.loss;
-
-	char buf[1024];
-	snprintf(buf, sizeof(buf), "UPDATE guild%s SET `loss` = %d WHERE `id` = %u", GetTablePostfix(), it->second.loss, GID);
-	CDBManager::instance().AsyncQuery(buf);
-}
-
-void CGuildManager::GuildWarDraw(DWORD GID)
-{
-	auto it = m_map_kGuild.find(GID);
-	if (it == m_map_kGuild.end())
-		return;
-
-	++it->second.draw;
-
-	char buf[1024];
-	snprintf(buf, sizeof(buf), "UPDATE guild%s SET `draw` = %d WHERE `id` = %u", GetTablePostfix(), it->second.draw, GID);
-	CDBManager::instance().AsyncQuery(buf);
-}
-
-bool CGuildManager::IsHalfWinLadderPoint(DWORD dwGuildWinner, DWORD dwGuildLoser)
-{
-	DWORD GID1 = dwGuildWinner;
-	DWORD GID2 = dwGuildLoser;
-
-	if (GID1 > GID2)
-		std::swap(GID1, GID2);
-
-	auto it = m_mapGuildWarEndTime[GID1].find(GID2);
-	if (it != m_mapGuildWarEndTime[GID1].end() &&
-		it->second + GUILD_WAR_LADDER_HALF_PENALTY_TIME > CClientManager::instance().GetCurrentTime())
-		return true;
-
-	return false;
-}
-
-void CGuildManager::ProcessDraw(DWORD dwGuildID1, DWORD dwGuildID2)
-{
-	sys_log(0, "GuildWar: \tThe war between %d and %d is ended in draw", dwGuildID1, dwGuildID2);
-
-	GuildWarDraw(dwGuildID1);
-	GuildWarDraw(dwGuildID2);
-	ChangeLadderPoint(dwGuildID1, 0);
-	ChangeLadderPoint(dwGuildID2, 0);
-
-	QueryRanking();
-}
-
-void CGuildManager::ProcessWinLose(DWORD dwGuildWinner, DWORD dwGuildLoser)
-{
-	GuildWarWin(dwGuildWinner);
-	GuildWarLose(dwGuildLoser);
-	sys_log(0, "GuildWar: \tWinner : %d Loser : %d", dwGuildWinner, dwGuildLoser);
-
-	int iPoint = GetLadderPoint(dwGuildLoser);
-	int gain = (int)(iPoint * 0.05);
-	int loss = (int)(iPoint * 0.07);
-
-	if (IsHalfWinLadderPoint(dwGuildWinner, dwGuildLoser))
-		gain /= 2;
-
-	sys_log(0, "GuildWar: \tgain : %d loss : %d", gain, loss);
-
-	ChangeLadderPoint(dwGuildWinner, gain);
-	ChangeLadderPoint(dwGuildLoser, -loss);
-
-	QueryRanking();
-}
-
-void CGuildManager::RemoveWar(DWORD GID1, DWORD GID2)
-{
-	sys_log(0, "GuildWar: RemoveWar(%d, %d)", GID1, GID2);
-
-	if (GID1 > GID2)
-		std::swap(GID2, GID1);
-
-	auto it = m_WarMap[GID1].find(GID2);
-	if (it == m_WarMap[GID1].end())
-	{
-		if (m_WarMap[GID1].empty())
-			m_WarMap.erase(GID1);
-
-		return;
-	}
-
-	if (it->second.pElement)
-		it->second.pElement->bEnd = true;
-
-	m_mapGuildWarEndTime[GID1][GID2] = CClientManager::instance().GetCurrentTime();
-
-	m_WarMap[GID1].erase(it);
-
-	if (m_WarMap[GID1].empty())
-		m_WarMap.erase(GID1);
-}
-
-//
-// 길드전 비정상 종료 및 필드전 종료
-//
-void CGuildManager::WarEnd(DWORD GID1, DWORD GID2, bool bForceDraw)
-{
-	if (GID1 > GID2)
-		std::swap(GID2, GID1);
-
-	sys_log(0, "GuildWar: WarEnd %d %d", GID1, GID2);
-
-	auto itWarMap = m_WarMap[GID1].find(GID2);
-	if (itWarMap == m_WarMap[GID1].end())
-	{
-		sys_err("GuildWar: war not exist or already ended. [1]");
-		return;
-	}
-
-	TGuildWarInfo gwi = itWarMap->second;
-	TGuildWarPQElement* pData = gwi.pElement;
-
-	if (!pData || pData->bEnd)
-	{
-		sys_err("GuildWar: war not exist or already ended. [2]");
-		return;
-	}
-
-	DWORD win_guild = pData->GID[0];
-	DWORD lose_guild = pData->GID[1];
-
-	bool bDraw = false;
-
-	if (!bForceDraw) // 강제 무승부가 아닐 경우에는 점수를 체크한다.
-	{
-		if (pData->iScore[0] > pData->iScore[1])
-		{
-			win_guild = pData->GID[0];
-			lose_guild = pData->GID[1];
-		}
-		else if (pData->iScore[1] > pData->iScore[0])
-		{
-			win_guild = pData->GID[1];
-			lose_guild = pData->GID[0];
-		}
-		else
-			bDraw = true;
-	}
-	else // 강제 무승부일 경우에는 무조건 무승부
-		bDraw = true;
-
-	if (bDraw)
-		ProcessDraw(win_guild, lose_guild);
-	else
-		ProcessWinLose(win_guild, lose_guild);
-
-	// DB 서버에서 자체적으로 끝낼 때도 있기 때문에 따로 패킷을 보내줘야 한다.
-	CClientManager::instance().for_each_peer(FSendPeerWar(0, GUILD_WAR_END, GID1, GID2));
-
-	RemoveWar(GID1, GID2);
-}
-
-//
-// 길드전 정상 종료
-//
-void CGuildManager::RecvWarOver(DWORD dwGuildWinner, DWORD dwGuildLoser, bool bDraw, long lWarPrice)
-{
-	sys_log(0, "GuildWar: RecvWarOver : winner %u vs %u draw? %d war_price %d", dwGuildWinner, dwGuildLoser, bDraw ? 1 : 0, lWarPrice);
-
-	DWORD GID1 = dwGuildWinner;
-	DWORD GID2 = dwGuildLoser;
-
-	if (GID1 > GID2)
-		std::swap(GID1, GID2);
-
-	auto it = m_WarMap[GID1].find(GID2);
-	if (it == m_WarMap[GID1].end())
-		return;
-
-	TGuildWarInfo& gw = it->second;
-
-	// Award
-	if (bDraw)
-	{
-		// give bet money / 2 to both guild
-		DepositMoney(dwGuildWinner, lWarPrice / 2);
-		DepositMoney(dwGuildLoser, lWarPrice / 2);
-		ProcessDraw(dwGuildWinner, dwGuildLoser);
-	}
-	else
-	{
-		// give bet money to winner guild
-		DepositMoney(dwGuildWinner, lWarPrice);
-		ProcessWinLose(dwGuildWinner, dwGuildLoser);
-	}
-
-	if (gw.pkReserve)
-	{
-		if (bDraw || !gw.pElement)
-			gw.pkReserve->Draw();
-		else if (gw.pElement->bType == GUILD_WAR_TYPE_BATTLE)
-			gw.pkReserve->End(gw.pElement->iBetScore[0], gw.pElement->iBetScore[1]);
-	}
-
-	RemoveWar(GID1, GID2);
-}
-
-void CGuildManager::RecvWarEnd(DWORD GID1, DWORD GID2)
-{
-	sys_log(0, "GuildWar: RecvWarEnded : %u vs %u", GID1, GID2);
-	WarEnd(GID1, GID2, true); // 무조건 비정상 종료 시켜야 한다.
-}
-
-void CGuildManager::StartWar(BYTE bType, DWORD GID1, DWORD GID2, CGuildWarReserve* pkReserve)
-{
-	sys_log(0, "GuildWar: StartWar(%d,%d,%d)", bType, GID1, GID2);
-
-	if (GID1 > GID2)
-		std::swap(GID1, GID2);
-
-	TGuildWarInfo& gw = m_WarMap[GID1][GID2]; // map insert
-
-	if (bType == GUILD_WAR_TYPE_FIELD)
-		gw.tEndTime = CClientManager::instance().GetCurrentTime() + GUILD_WAR_DURATION;
-	else
-		gw.tEndTime = CClientManager::instance().GetCurrentTime() + 172800;
-
-	gw.pElement = new TGuildWarPQElement(bType, GID1, GID2);
-	gw.pkReserve = pkReserve;
-
-	m_pqOnWar.push(std::make_pair(gw.tEndTime, gw.pElement));
-}
-
-void CGuildManager::UpdateScore(DWORD dwGainGID, DWORD dwOppGID, int iScoreDelta, int iBetScoreDelta)
-{
-	DWORD GID1 = dwGainGID;
-	DWORD GID2 = dwOppGID;
-
-	if (GID1 > GID2)
-		std::swap(GID1, GID2);
-
-	auto it = m_WarMap[GID1].find(GID2);
-	if (it != m_WarMap[GID1].end())
-	{
-		TGuildWarPQElement* p = it->second.pElement;
-
-		if (!p || p->bEnd)
-		{
-			sys_err("GuildWar: war not exist or already ended.");
-			return;
-		}
-
-		int iNewScore = 0;
-		int iNewBetScore = 0;
-
-		if (p->GID[0] == dwGainGID)
-		{
-			p->iScore[0] += iScoreDelta;
-			p->iBetScore[0] += iBetScoreDelta;
-
-			iNewScore = p->iScore[0];
-			iNewBetScore = p->iBetScore[0];
-		}
-		else
-		{
-			p->iScore[1] += iScoreDelta;
-			p->iBetScore[1] += iBetScoreDelta;
-
-			iNewScore = p->iScore[1];
-			iNewBetScore = p->iBetScore[1];
-		}
-
-		sys_log(0, "GuildWar: SendGuildWarScore guild %u wartype %u score_delta %d betscore_delta %d result %u, %u",
-			dwGainGID, p->bType, iScoreDelta, iBetScoreDelta, iNewScore, iNewBetScore);
-
-		CClientManager::instance().for_each_peer(FSendGuildWarScore(dwGainGID, dwOppGID, iNewScore, iNewBetScore));
-	}
-}
-
-void CGuildManager::AddDeclare(BYTE bType, DWORD guild_from, DWORD guild_to)
-{
-	TGuildDeclareInfo di(bType, guild_from, guild_to);
-
-	if (m_DeclareMap.find(di) == m_DeclareMap.end())
-		m_DeclareMap.insert(di);
-
-	sys_log(0, "GuildWar: AddDeclare(Type:%d,from:%d,to:%d)", bType, guild_from, guild_to);
-}
-
-void CGuildManager::RemoveDeclare(DWORD guild_from, DWORD guild_to)
-{
-	GuildDeclareInfoSet::iterator it = m_DeclareMap.find(TGuildDeclareInfo(0, guild_from, guild_to));
-	if (it != m_DeclareMap.end())
-		m_DeclareMap.erase(it);
-
-	it = m_DeclareMap.find(TGuildDeclareInfo(0, guild_to, guild_from));
-
-	if (it != m_DeclareMap.end())
-		m_DeclareMap.erase(it);
-
-	sys_log(0, "GuildWar: RemoveDeclare(from:%d,to:%d)", guild_from, guild_to);
-}
-
-bool CGuildManager::TakeBetPrice(DWORD dwGuildTo, DWORD dwGuildFrom, long lWarPrice)
-{
-	auto it_from = m_map_kGuild.find(dwGuildFrom);
-	auto it_to = m_map_kGuild.find(dwGuildTo);
-
-	if (it_from == m_map_kGuild.end() || it_to == m_map_kGuild.end())
-	{
-		sys_log(0, "TakeBetPrice: guild not exist %u %u",
-			dwGuildFrom, dwGuildTo);
-		return false;
-	}
-
-	if (it_from->second.gold < lWarPrice || it_to->second.gold < lWarPrice)
-	{
-		sys_log(0, "TakeBetPrice: not enough gold %u %d to %u %d",
-			dwGuildFrom, it_from->second.gold, dwGuildTo, it_to->second.gold);
-		return false;
-	}
-
-	it_from->second.gold -= lWarPrice;
-	it_to->second.gold -= lWarPrice;
-
-	MoneyChange(dwGuildFrom, it_from->second.gold);
-	MoneyChange(dwGuildTo, it_to->second.gold);
-	return true;
-}
-
-bool CGuildManager::WaitStart(TPacketGuildWar* p)
-{
-	if (p->lWarPrice > 0)
-		if (!TakeBetPrice(p->dwGuildFrom, p->dwGuildTo, p->lWarPrice))
-			return false;
-
-	DWORD dwCurTime = CClientManager::instance().GetCurrentTime();
-
-	TGuildWaitStartInfo info(p->bType, p->dwGuildFrom, p->dwGuildTo, p->lWarPrice, p->lInitialScore, NULL);
-	m_pqWaitStart.push(std::make_pair(dwCurTime + GetGuildWarWaitStartDuration(), info));
-
-	sys_log(0,
-		"GuildWar: WaitStart g1 %d g2 %d price %d start at %u",
-		p->dwGuildFrom,
-		p->dwGuildTo,
-		p->lWarPrice,
-		dwCurTime + GetGuildWarWaitStartDuration());
-
-	return true;
-}
-
-int CGuildManager::GetLadderPoint(DWORD GID)
-{
-	auto it = m_map_kGuild.find(GID);
-	if (it == m_map_kGuild.end())
-		return 0;
-
-	return it->second.ladder_point;
-}
-
-void CGuildManager::ChangeLadderPoint(DWORD GID, int change)
-{
-	auto it = m_map_kGuild.find(GID);
-	if (it == m_map_kGuild.end())
-		return;
-
-	TGuild& r = it->second;
-
-	r.ladder_point += change;
-
-	if (r.ladder_point < 0)
-		r.ladder_point = 0;
-
-	char buf[1024];
-	snprintf(buf, sizeof(buf), "UPDATE guild%s SET `ladder_point` = %d WHERE `id` = %u", GetTablePostfix(), r.ladder_point, GID);
-	CDBManager::instance().AsyncQuery(buf);
-
-	sys_log(0, "GuildManager::ChangeLadderPoint %u %d", GID, r.ladder_point);
-	sys_log(0, "%s", buf);
-
-	// Packet 보내기
-	TPacketGuildLadder p;
-
-	p.dwGuild = GID;
-	p.lLadderPoint = r.ladder_point;
-	p.lWin = r.win;
-	p.lDraw = r.draw;
-	p.lLoss = r.loss;
-
-	CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_LADDER, &p, sizeof(TPacketGuildLadder));
-}
-
-void CGuildManager::UseSkill(DWORD GID, DWORD dwSkillVnum, DWORD dwCooltime)
-{
-	// GUILD_SKILL_COOLTIME_BUG_FIX
-	sys_log(0, "UseSkill(gid=%d, skill=%d) CoolTime(%d:%d)", GID, dwSkillVnum, dwCooltime, CClientManager::instance().GetCurrentTime() + dwCooltime);
-	m_pqSkill.push(std::make_pair(CClientManager::instance().GetCurrentTime() + dwCooltime, TGuildSkillUsed(GID, dwSkillVnum)));
-	// END_OF_GUILD_SKILL_COOLTIME_BUG_FIX
-}
-
-void CGuildManager::MoneyChange(DWORD dwGuild, DWORD dwGold)
-{
-	sys_log(0, "GuildManager::MoneyChange %d %d", dwGuild, dwGold);
-
-	TPacketDGGuildMoneyChange p;
-	p.dwGuild = dwGuild;
-	p.iTotalGold = dwGold;
-	CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_MONEY_CHANGE, &p, sizeof(p));
-
-	char buf[1024];
-	snprintf(buf, sizeof(buf), "UPDATE guild%s SET `gold` = %u WHERE `id` = %u", GetTablePostfix(), dwGold, dwGuild);
-	CDBManager::instance().AsyncQuery(buf);
-}
-
-void CGuildManager::DepositMoney(DWORD dwGuild, INT iGold)
-{
-	if (iGold <= 0)
-		return;
-
-	auto it = m_map_kGuild.find(dwGuild);
-	if (it == m_map_kGuild.end())
-	{
-		sys_err("No guild by id %u", dwGuild);
-		return;
-	}
-
-	it->second.gold += iGold;
-	sys_log(0, "GUILD: %u Deposit %u Total %d", dwGuild, iGold, it->second.gold);
-
-	MoneyChange(dwGuild, it->second.gold);
-}
-
-void CGuildManager::WithdrawMoney(CPeer* peer, DWORD dwGuild, INT iGold)
-{
-	auto it = m_map_kGuild.find(dwGuild);
-	if (it == m_map_kGuild.end())
-	{
-		sys_err("No guild by id %u", dwGuild);
-		return;
-	}
-
-	// 돈이있으니 출금하고 올려준다
-	if (it->second.gold >= iGold)
-	{
-		it->second.gold -= iGold;
-		sys_log(0, "GUILD: %u Withdraw %d Total %d", dwGuild, iGold, it->second.gold);
-
-		TPacketDGGuildMoneyWithdraw p;
-		p.dwGuild = dwGuild;
-		p.iChangeGold = iGold;
-
-		peer->EncodeHeader(HEADER_DG_GUILD_WITHDRAW_MONEY_GIVE, 0, sizeof(TPacketDGGuildMoneyWithdraw));
-		peer->Encode(&p, sizeof(TPacketDGGuildMoneyWithdraw));
-	}
-}
-
-void CGuildManager::WithdrawMoneyReply(DWORD dwGuild, BYTE bGiveSuccess, INT iGold)
-{
-	auto it = m_map_kGuild.find(dwGuild);
-	if (it == m_map_kGuild.end())
-		return;
-
-	sys_log(0, "GuildManager::WithdrawMoneyReply : guild %u success %d gold %d", dwGuild, bGiveSuccess, iGold);
-
-	if (!bGiveSuccess)
-		it->second.gold += iGold;
-	else
-		MoneyChange(dwGuild, it->second.gold);
-}
-
-//
-// 예약 길드전(관전자가 배팅할 수 있다)
-//
-const int c_aiScoreByLevel[GUILD_MAX_LEVEL + 1] =
-{
-	500, // level 0 = 500 probably error
-	500, // 1
-	1000,
-	2000,
-	3000,
-	4000,
-	6000,
-	8000,
-	10000,
-	12000,
-	15000, // 10
-	18000,
-	21000,
-	24000,
-	28000,
-	32000,
-	36000,
-	40000,
-	45000,
-	50000,
-	55000,
-};
-
-const int c_aiScoreByRanking[GUILD_RANK_MAX_NUM + 1] =
-{
-	0,
-	55000, // 1위
-	50000,
-	45000,
-	40000,
-	36000,
-	32000,
-	28000,
-	24000,
-	21000,
-	18000, // 10위
-	15000,
-	12000,
-	10000,
-	8000,
-	6000,
-	4000,
-	3000,
-	2000,
-	1000,
-	500 // 20위
-};
-
-void CGuildManager::BootReserveWar()
-{
-	const char* c_apszQuery[2] =
-	{
-		"SELECT id, guild1, guild2, UNIX_TIMESTAMP(time), type, warprice, initscore, bet_from, bet_to, power1, power2, handicap FROM guild_war_reservation WHERE started=1 AND winner=-1",
-		"SELECT id, guild1, guild2, UNIX_TIMESTAMP(time), type, warprice, initscore, bet_from, bet_to, power1, power2, handicap FROM guild_war_reservation WHERE started=0"
-	};
-
-	for (int i = 0; i < 2; ++i)
-	{
-		std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(c_apszQuery[i]));
-
-		if (pmsg->Get()->uiNumRows == 0)
-			continue;
-
-		MYSQL_ROW row;
-
-		while ((row = mysql_fetch_row(pmsg->Get()->pSQLResult)))
-		{
-			int col = 0;
-
-			TGuildWarReserve t;
-
-			str_to_number(t.dwID, row[col++]);
-			str_to_number(t.dwGuildFrom, row[col++]);
-			str_to_number(t.dwGuildTo, row[col++]);
-			str_to_number(t.dwTime, row[col++]);
-			str_to_number(t.bType, row[col++]);
-			str_to_number(t.lWarPrice, row[col++]);
-			str_to_number(t.lInitialScore, row[col++]);
-			str_to_number(t.dwBetFrom, row[col++]);
-			str_to_number(t.dwBetTo, row[col++]);
-			str_to_number(t.lPowerFrom, row[col++]);
-			str_to_number(t.lPowerTo, row[col++]);
-			str_to_number(t.lHandicap, row[col++]);
-			t.bStarted = 0;
-
-			CGuildWarReserve* pkReserve = new CGuildWarReserve(t);
-
-			char buf[512];
-			snprintf(buf, sizeof(buf), "GuildWar: BootReserveWar : step %d id %u GID1 %u GID2 %u", i, t.dwID, t.dwGuildFrom, t.dwGuildTo);
-			// i == 0 이면 길드전 도중 DB가 튕긴 것이므로 무승부 처리한다.
-			// 또는, 5분 이하 남은 예약 길드전도 무승부 처리한다. (각자의 배팅액을 돌려준다)
-			//if (i == 0 || (int) t.dwTime - CClientManager::instance().GetCurrentTime() < 60 * 5)
-			if (i == 0 || (int)t.dwTime - CClientManager::instance().GetCurrentTime() < 0)
-			{
-				if (i == 0)
-					sys_log(0, "%s : DB was shutdowned while war is being.", buf);
-				else
-					sys_log(0, "%s : left time lower than 5 minutes, will be canceled", buf);
-
-				pkReserve->Draw();
-				delete pkReserve;
-			}
-			else
-			{
-				sys_log(0, "%s : OK", buf);
-				m_map_kWarReserve.insert(std::make_pair(t.dwID, pkReserve));
-			}
-		}
-	}
-}
-
-int GetAverageGuildMemberLevel(DWORD dwGID)
-{
-	char szQuery[QUERY_MAX_LEN];
-
-	snprintf(szQuery, sizeof(szQuery),
-		"SELECT AVG(`level`) FROM guild_member%s, player%s AS p WHERE `guild_id` = %u AND guild_member%s.`pid` = p.`id`",
-		GetTablePostfix(), GetTablePostfix(), dwGID, GetTablePostfix());
-
-	std::unique_ptr<SQLMsg> msg(CDBManager::instance().DirectQuery(szQuery));
-
-	MYSQL_ROW row;
-	row = mysql_fetch_row(msg->Get()->pSQLResult);
-
-	int nAverageLevel = 0; str_to_number(nAverageLevel, row[0]);
-	return nAverageLevel;
-}
-
-int GetGuildMemberCount(DWORD dwGID)
-{
-	char szQuery[QUERY_MAX_LEN];
-
-	snprintf(szQuery, sizeof(szQuery), "SELECT COUNT(*) FROM guild_member%s WHERE `guild_id` = %u", GetTablePostfix(), dwGID);
-
-	std::unique_ptr<SQLMsg> msg(CDBManager::instance().DirectQuery(szQuery));
-
-	MYSQL_ROW row;
-	row = mysql_fetch_row(msg->Get()->pSQLResult);
-
-	DWORD dwCount = 0; str_to_number(dwCount, row[0]);
-	return dwCount;
-}
-
-bool CGuildManager::ReserveWar(TPacketGuildWar* p)
-{
-	DWORD GID1 = p->dwGuildFrom;
-	DWORD GID2 = p->dwGuildTo;
-
-	if (GID1 > GID2)
-		std::swap(GID1, GID2);
-
-	if (p->lWarPrice > 0)
-		if (!TakeBetPrice(GID1, GID2, p->lWarPrice))
-			return false;
-
-	TGuildWarReserve t;
-	memset(&t, 0, sizeof(TGuildWarReserve));
-
-	t.dwGuildFrom = GID1;
-	t.dwGuildTo = GID2;
-	t.dwTime = CClientManager::instance().GetCurrentTime() + GetGuildWarReserveSeconds();
-	t.bType = p->bType;
-	t.lWarPrice = p->lWarPrice;
-	t.lInitialScore = p->lInitialScore;
-
-	int lvp, rkp, alv, mc;
-
-	// 파워 계산
-	TGuild& k1 = TouchGuild(GID1);
-
-	lvp = c_aiScoreByLevel[MIN(GUILD_MAX_LEVEL, k1.level)];
-	rkp = c_aiScoreByRanking[GetRanking(GID1)];
-	alv = GetAverageGuildMemberLevel(GID1);
-	mc = GetGuildMemberCount(GID1);
-
-	polyPower.SetVar("lvp", lvp);
-	polyPower.SetVar("rkp", rkp);
-	polyPower.SetVar("alv", alv);
-	polyPower.SetVar("mc", mc);
-
-	t.lPowerFrom = (long)polyPower.Eval();
-	sys_log(0, "GuildWar: %u lvp %d rkp %d alv %d mc %d power %d", GID1, lvp, rkp, alv, mc, t.lPowerFrom);
-
-	// 파워 계산
-	TGuild& k2 = TouchGuild(GID2);
-
-	lvp = c_aiScoreByLevel[MIN(GUILD_MAX_LEVEL, k2.level)];
-	rkp = c_aiScoreByRanking[GetRanking(GID2)];
-	alv = GetAverageGuildMemberLevel(GID2);
-	mc = GetGuildMemberCount(GID2);
-
-	polyPower.SetVar("lvp", lvp);
-	polyPower.SetVar("rkp", rkp);
-	polyPower.SetVar("alv", alv);
-	polyPower.SetVar("mc", mc);
-
-	t.lPowerTo = (long)polyPower.Eval();
-	sys_log(0, "GuildWar: %u lvp %d rkp %d alv %d mc %d power %d", GID2, lvp, rkp, alv, mc, t.lPowerTo);
-
-	// 핸디캡 계산
-	if (t.lPowerTo > t.lPowerFrom)
-	{
-		polyHandicap.SetVar("pA", t.lPowerTo);
-		polyHandicap.SetVar("pB", t.lPowerFrom);
-	}
-	else
-	{
-		polyHandicap.SetVar("pA", t.lPowerFrom);
-		polyHandicap.SetVar("pB", t.lPowerTo);
-	}
-
-	t.lHandicap = (long)polyHandicap.Eval();
-	sys_log(0, "GuildWar: handicap %d", t.lHandicap);
-
-	// 쿼리
-	char szQuery[512];
-
-	snprintf(szQuery, sizeof(szQuery),
-		"INSERT INTO guild_war_reservation%s (`guild1`, `guild2`, `time`, `type`, `warprice`, `initscore`, `power1`, `power2`, `handicap`) "
-		"VALUES(%u, %u, DATE_ADD(NOW(), INTERVAL 180 SECOND), %u, %ld, %ld, %ld, %ld, %ld)",
-		GetTablePostfix(), GID1, GID2, p->bType, p->lWarPrice, p->lInitialScore, t.lPowerFrom, t.lPowerTo, t.lHandicap);
-
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiInsertID == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
-	{
-		sys_err("GuildWar: Cannot insert row");
-		return false;
-	}
-
-	t.dwID = pmsg->Get()->uiInsertID;
-
-	m_map_kWarReserve.insert(std::make_pair(t.dwID, new CGuildWarReserve(t)));
-
-	CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR_RESERVE_ADD, &t, sizeof(TGuildWarReserve));
-	return true;
-}
-
-void CGuildManager::ProcessReserveWar()
-{
-	DWORD dwCurTime = CClientManager::instance().GetCurrentTime();
-
-	auto it = m_map_kWarReserve.begin();
-	while (it != m_map_kWarReserve.end())
-	{
-		auto it2 = it++;
-
-		CGuildWarReserve* pk = it2->second;
-		TGuildWarReserve& r = pk->GetDataRef();
-
-		if (!r.bStarted && r.dwTime - 1800 <= dwCurTime) // 30분 전부터 알린다.
-		{
-			int iMin = (int)ceil((int)(r.dwTime - dwCurTime) / 60.0);
-
-			TGuild& r_1 = m_map_kGuild[r.dwGuildFrom];
-			TGuild& r_2 = m_map_kGuild[r.dwGuildTo];
-
-			sys_log(0, "GuildWar: started GID1 %u GID2 %u %d time %d min %d", r.dwGuildFrom, r.dwGuildTo, r.bStarted, dwCurTime - r.dwTime, iMin);
-
-			if (iMin <= 0)
-			{
-				char szQuery[128];
-				snprintf(szQuery, sizeof(szQuery), "UPDATE guild_war_reservation%s SET `started` = 1 WHERE `id` = %u", GetTablePostfix(), r.dwID);
-				CDBManager::instance().AsyncQuery(szQuery);
-
-				CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR_RESERVE_DEL, &r.dwID, sizeof(DWORD));
-
-				r.bStarted = true;
-
-				TGuildWaitStartInfo info(r.bType, r.dwGuildFrom, r.dwGuildTo, r.lWarPrice, r.lInitialScore, pk);
-				m_pqWaitStart.push(std::make_pair(dwCurTime + GetGuildWarWaitStartDuration(), info));
-
-				TPacketGuildWar pck;
-
-				pck.bType = r.bType;
-				pck.bWar = GUILD_WAR_WAIT_START;
-				pck.dwGuildFrom = r.dwGuildFrom;
-				pck.dwGuildTo = r.dwGuildTo;
-				pck.lWarPrice = r.lWarPrice;
-				pck.lInitialScore = r.lInitialScore;
-
-				CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR, &pck, sizeof(TPacketGuildWar));
-				//m_map_kWarReserve.erase(it2);
-			}
-			else
-			{
-				if (iMin != pk->GetLastNoticeMin())
-				{
-					pk->SetLastNoticeMin(iMin);
-
-					if (!g_stLocale.compare("euckr"))
-						CClientManager::instance().SendNotice("%s 길드와 %s 길드의 전쟁이 약 %d분 후 시작 됩니다!", r_1.szName, r_2.szName, iMin);
-					else if (!g_stLocale.compare("gb2312"))
-						CClientManager::instance().SendNotice("%s 곤삔뵨 %s 곤삔돨곤삔濫轢쉥瞳 %d롸爐빈역迦!", r_1.szName, r_2.szName, iMin);
-				}
-			}
-		}
-	}
-}
-
-bool CGuildManager::Bet(DWORD dwID, const char* c_pszLogin, DWORD dwGold, DWORD dwGuild)
-{
-	char szQuery[1024];
-
-	auto it = m_map_kWarReserve.find(dwID);
-	if (it == m_map_kWarReserve.end())
-	{
-		sys_log(0, "WAR_RESERVE: Bet: cannot find reserve war by id %u", dwID);
-		snprintf(szQuery, sizeof(szQuery), "INSERT INTO item_award%s (`login`, `vnum`, `socket0`, `given_time`) VALUES('%s', %d, %u, NOW())",
-			GetTablePostfix(), c_pszLogin, ITEM_ELK_VNUM, dwGold);
-		CDBManager::instance().AsyncQuery(szQuery);
-		return false;
-	}
-
-	if (!it->second->Bet(c_pszLogin, dwGold, dwGuild))
-	{
-		sys_log(0, "WAR_RESERVE: Bet: cannot bet id %u, login %s, gold %u, guild %u", dwID, c_pszLogin, dwGold, dwGuild);
-		snprintf(szQuery, sizeof(szQuery), "INSERT INTO item_award%s (`login`, `vnum`, `socket0`, `given_time`) VALUES('%s', %d, %u, NOW())",
-			GetTablePostfix(), c_pszLogin, ITEM_ELK_VNUM, dwGold);
-		CDBManager::instance().AsyncQuery(szQuery);
-		return false;
-	}
-
-	return true;
-}
-
-void CGuildManager::CancelWar(DWORD GID1, DWORD GID2)
-{
-	RemoveDeclare(GID1, GID2);
-	RemoveWar(GID1, GID2);
-}
-
-bool CGuildManager::ChangeMaster(DWORD dwGID, DWORD dwFrom, DWORD dwTo)
-{
-	auto iter = m_map_kGuild.find(dwGID);
-	if (iter == m_map_kGuild.end())
-		return false;
-
-	char szQuery[1024];
-
-	snprintf(szQuery, sizeof(szQuery), "UPDATE guild%s SET `master` = %u WHERE `id` = %u", GetTablePostfix(), dwTo, dwGID);
-	delete CDBManager::instance().DirectQuery(szQuery);
-
-	snprintf(szQuery, sizeof(szQuery), "UPDATE guild_member%s SET `grade` = 1 WHERE `pid` = %u", GetTablePostfix(), dwTo);
-	delete CDBManager::instance().DirectQuery(szQuery);
-
-	snprintf(szQuery, sizeof(szQuery), "UPDATE guild_member%s SET `grade` = 15 WHERE `pid` = %u", GetTablePostfix(), dwFrom);
-	delete CDBManager::instance().DirectQuery(szQuery);
-
-	return true;
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////
-// Guild War Reserve Class
-//////////////////////////////////////////////////////////////////////////////////////////
-CGuildWarReserve::CGuildWarReserve(const TGuildWarReserve& rTable)
-{
-	thecore_memcpy(&m_data, &rTable, sizeof(TGuildWarReserve));
-	m_iLastNoticeMin = -1;
-
-	Initialize();
-}
-
-void CGuildWarReserve::Initialize()
-{
-	char szQuery[256];
-	snprintf(szQuery, sizeof(szQuery), "SELECT `login`, `guild`, `gold` FROM guild_war_bet%s WHERE `war_id` = %u", GetTablePostfix(), m_data.dwID);
-
-	std::unique_ptr<SQLMsg> msgbet(CDBManager::instance().DirectQuery(szQuery));
-
-	if (msgbet->Get()->uiNumRows)
-	{
-		MYSQL_RES* res = msgbet->Get()->pSQLResult;
-		MYSQL_ROW row;
-
-		char szLogin[LOGIN_MAX_LEN + 1];
-		DWORD dwGuild;
-		DWORD dwGold;
-
-		while ((row = mysql_fetch_row(res)))
-		{
-			dwGuild = dwGold = 0;
-			strlcpy(szLogin, row[0], sizeof(szLogin));
-			str_to_number(dwGuild, row[1]);
-			str_to_number(dwGold, row[2]);
-
-			mapBet.insert(std::make_pair(szLogin, std::make_pair(dwGuild, dwGold)));
-		}
-	}
-}
-
-void CGuildWarReserve::OnSetup(CPeer* peer)
-{
-	if (m_data.bStarted) // 이미 시작된 것은 보내지 않는다.
-		return;
-
-	FSendPeerWar(m_data.bType, GUILD_WAR_RESERVE, m_data.dwGuildFrom, m_data.dwGuildTo) (peer);
-
-	peer->EncodeHeader(HEADER_DG_GUILD_WAR_RESERVE_ADD, 0, sizeof(TGuildWarReserve));
-	peer->Encode(&m_data, sizeof(TGuildWarReserve));
-
-	TPacketGDGuildWarBet pckBet;
-	pckBet.dwWarID = m_data.dwID;
-
-	auto it = mapBet.begin();
-	while (it != mapBet.end())
-	{
-		strlcpy(pckBet.szLogin, it->first.c_str(), sizeof(pckBet.szLogin));
-		pckBet.dwGuild = it->second.first;
-		pckBet.dwGold = it->second.second;
-
-		peer->EncodeHeader(HEADER_DG_GUILD_WAR_BET, 0, sizeof(TPacketGDGuildWarBet));
-		peer->Encode(&pckBet, sizeof(TPacketGDGuildWarBet));
-
-		++it;
-	}
-}
-
-bool CGuildWarReserve::Bet(const char* pszLogin, DWORD dwGold, DWORD dwGuild)
-{
-	char szQuery[1024];
-
-	if (m_data.dwGuildFrom != dwGuild && m_data.dwGuildTo != dwGuild)
-	{
-		sys_log(0, "GuildWarReserve::Bet: invalid guild id");
-		return false;
-	}
-
-	if (m_data.bStarted)
-	{
-		sys_log(0, "GuildWarReserve::Bet: war is already started");
-		return false;
-	}
-
-	if (mapBet.find(pszLogin) != mapBet.end())
-	{
-		sys_log(0, "GuildWarReserve::Bet: failed. already bet");
-		return false;
-	}
-
-	snprintf(szQuery, sizeof(szQuery),
-		"INSERT INTO guild_war_bet%s (`war_id`, `login`, `gold`, `guild`) VALUES(%u, '%s', %u, %u)",
-		GetTablePostfix(), m_data.dwID, pszLogin, dwGold, dwGuild);
-
-	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
-
-	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
-	{
-		sys_log(0, "GuildWarReserve::Bet: failed. cannot insert row to guild_war_bet table");
-		return false;
-	}
-
-	if (m_data.dwGuildFrom == dwGuild)
-		m_data.dwBetFrom += dwGold;
-	else
-		m_data.dwBetTo += dwGold;
-
-	CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR_RESERVE_ADD, &m_data, sizeof(TGuildWarReserve));
-
-	snprintf(szQuery, sizeof(szQuery), "UPDATE guild_war_reservation%s SET `bet_from` = %u, `bet_to` = %u WHERE `id` = %u",
-		GetTablePostfix(), m_data.dwBetFrom, m_data.dwBetTo, m_data.dwID);
-
-	CDBManager::instance().AsyncQuery(szQuery);
-
-	sys_log(0, "GuildWarReserve::Bet: success. %s %u war_id %u bet %u : %u", pszLogin, dwGuild, m_data.dwID, m_data.dwBetFrom, m_data.dwBetTo);
-	mapBet.insert(std::make_pair(pszLogin, std::make_pair(dwGuild, dwGold)));
-
-	TPacketGDGuildWarBet pckBet;
-	pckBet.dwWarID = m_data.dwID;
-	strlcpy(pckBet.szLogin, pszLogin, sizeof(pckBet.szLogin));
-	pckBet.dwGuild = dwGuild;
-	pckBet.dwGold = dwGold;
-
-	CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR_BET, &pckBet, sizeof(TPacketGDGuildWarBet));
-	return true;
-}
-
-//
-// 무승부 처리: 대부분 승부가 나야 정상이지만, 서버 문제 등 특정 상황일 경우에는
-// 무승부 처리가 있어야 한다.
-//
-void CGuildWarReserve::Draw()
-{
-	char szQuery[1024];
-
-	snprintf(szQuery, sizeof(szQuery), "UPDATE guild_war_reservation%s SET `started` = 1, `winner` = 0 WHERE `id` = %u", GetTablePostfix(), m_data.dwID);
-	CDBManager::instance().AsyncQuery(szQuery);
-
-	if (mapBet.empty())
-		return;
-
-	sys_log(0, "WAR_REWARD: Draw. war_id %u", m_data.dwID);
-
-	auto it = mapBet.begin();
-
-	while (1)
-	{
-		int iLen = 0;
-		int iRow = 0;
-
-		iLen += snprintf(szQuery, sizeof(szQuery) - iLen, "INSERT INTO item_award%s (`login`, `vnum`, `socket0`, `given_time`) VALUES", GetTablePostfix());
-
-		while (it != mapBet.end())
-		{
-			if (iRow == 0)
-				iLen += snprintf(szQuery + iLen, sizeof(szQuery) - iLen, "('%s', %d, %u, NOW())",
-					it->first.c_str(), ITEM_ELK_VNUM, it->second.second);
-			else
-				iLen += snprintf(szQuery + iLen, sizeof(szQuery) - iLen, ",('%s', %d, %u, NOW())",
-					it->first.c_str(), ITEM_ELK_VNUM, it->second.second);
-
-			it++;
-
-			if (iLen > 384)
-				break;
-
-			++iRow;
-		}
-
-		if (iRow > 0)
-		{
-			sys_log(0, "WAR_REWARD: QUERY: %s", szQuery);
-			CDBManager::instance().AsyncQuery(szQuery);
-		}
-
-		if (it == mapBet.end())
-			break;
-	}
-}
-
-void CGuildWarReserve::End(int iScoreFrom, int iScoreTo)
-{
-	DWORD dwWinner;
-
-	sys_log(0, "WAR_REWARD: End: From %u %d To %u %d", m_data.dwGuildFrom, iScoreFrom, m_data.dwGuildTo, iScoreTo);
-
-	if (m_data.lPowerFrom > m_data.lPowerTo)
-	{
-		if (m_data.lHandicap > iScoreFrom - iScoreTo)
-		{
-			sys_log(0, "WAR_REWARD: End: failed to overcome handicap, From is strong but To won");
-			dwWinner = m_data.dwGuildTo;
-		}
-		else
-		{
-			sys_log(0, "WAR_REWARD: End: success to overcome handicap, From win!");
-			dwWinner = m_data.dwGuildFrom;
-		}
-	}
-	else
-	{
-		if (m_data.lHandicap > iScoreTo - iScoreFrom)
-		{
-			sys_log(0, "WAR_REWARD: End: failed to overcome handicap, To is strong but From won");
-			dwWinner = m_data.dwGuildFrom;
-		}
-		else
-		{
-			sys_log(0, "WAR_REWARD: End: success to overcome handicap, To win!");
-			dwWinner = m_data.dwGuildTo;
-		}
-	}
-
-	char szQuery[1024];
-	snprintf(szQuery, sizeof(szQuery), "UPDATE guild_war_reservation%s SET `started` = 1, `winner` = %u, `result1` = %d, `result2` = %d WHERE `id` = %u",
-		GetTablePostfix(), dwWinner, iScoreFrom, iScoreTo, m_data.dwID);
-	CDBManager::instance().AsyncQuery(szQuery);
-
-	if (mapBet.empty())
-		return;
-
-	DWORD dwTotalBet = m_data.dwBetFrom + m_data.dwBetTo;
-	DWORD dwWinnerBet = 0;
-
-	if (dwWinner == m_data.dwGuildFrom)
-		dwWinnerBet = m_data.dwBetFrom;
-	else if (dwWinner == m_data.dwGuildTo)
-		dwWinnerBet = m_data.dwBetTo;
-	else
-	{
-		sys_err("WAR_REWARD: fatal error, winner does not exist!");
-		return;
-	}
-
-	if (dwWinnerBet == 0)
-	{
-		sys_err("WAR_REWARD: total bet money on winner is zero");
-		return;
-	}
-
-	sys_log(0, "WAR_REWARD: End: Total bet: %u, Winner bet: %u", dwTotalBet, dwWinnerBet);
-
-	auto it = mapBet.begin();
-
-	while (1)
-	{
-		int iLen = 0;
-		int iRow = 0;
-
-		iLen += snprintf(szQuery, sizeof(szQuery) - iLen, "INSERT INTO item_award%s (`login`, `vnum`, `socket0`, `given_time`) VALUES", GetTablePostfix());
-
-		while (it != mapBet.end())
-		{
-			if (it->second.first != dwWinner)
-			{
-				++it;
-				continue;
-			}
-
-			double ratio = (double)it->second.second / dwWinnerBet;
-
-			// 10% 세금 공제 후 분배
-			sys_log(0, "WAR_REWARD: %s %u ratio %f", it->first.c_str(), it->second.second, ratio);
-
-			DWORD dwGold = (DWORD)(dwTotalBet * ratio * 0.9);
-
-			if (iRow == 0)
-				iLen += snprintf(szQuery + iLen, sizeof(szQuery) - iLen, "('%s', %d, %u, NOW())",
-					it->first.c_str(), ITEM_ELK_VNUM, dwGold);
-			else
-				iLen += snprintf(szQuery + iLen, sizeof(szQuery) - iLen, ",('%s', %d, %u, NOW())",
-					it->first.c_str(), ITEM_ELK_VNUM, dwGold);
-
-			++it;
-
-			if (iLen > 384)
-				break;
-
-			++iRow;
-		}
-
-		if (iRow > 0)
-		{
-			sys_log(0, "WAR_REWARD: query: %s", szQuery);
-			CDBManager::instance().AsyncQuery(szQuery);
-		}
-
-		if (it == mapBet.end())
-			break;
-	}
-}
+#include "stdafx.h"
+#include "GuildManager.h"
+#include "Main.h"
+#include "ClientManager.h"
+#include "QID.h"
+#include "Config.h"
+#include <math.h>
+#include <climits>
+
+extern std::string g_stLocale;
+
+const int GUILD_RANK_MAX_NUM = 20;
+
+bool isEurope()
+{
+	do
+	{
+		if (g_stLocale.compare("germany") == 0) break;
+		if (g_stLocale.compare("france") == 0) break;
+		if (g_stLocale.compare("italy") == 0) break;
+		if (g_stLocale.compare("spain") == 0) break;
+		if (g_stLocale.compare("uk") == 0) break;
+		if (g_stLocale.compare("turkey") == 0) break;
+		if (g_stLocale.compare("poland") == 0) break;
+		if (g_stLocale.compare("portugal") == 0) break;
+		if (g_stLocale.compare("greek") == 0) break;
+
+		return false;
+	} while (false);
+
+	return true;
+}
+
+DWORD GetGuildWarWaitStartDuration()
+{
+	// const int GUILD_WAR_WAIT_START_DURATION = 60s;
+	// const int GUILD_WAR_WAIT_START_DURATION = 5; 
+
+	if (isEurope() == true) return 60;
+	else return 5;
+}
+
+DWORD GetGuildWarReserveSeconds()
+{
+	// const int GUILD_WAR_RESERVE_SECONDS = 180;
+	// const int GUILD_WAR_RESERVE_SECONDS = 10;
+
+	if (isEurope() == true) return 180;
+	else return 10;
+}
+
+namespace
+{
+	struct FSendPeerWar
+	{
+		FSendPeerWar(BYTE bType, BYTE bWar, DWORD GID1, DWORD GID2)
+		{
+			if (number(0, 1))
+				std::swap(GID1, GID2);
+
+			memset(&p, 0, sizeof(TPacketGuildWar));
+
+			p.bWar = bWar;
+			p.bType = bType;
+			p.dwGuildFrom = GID1;
+			p.dwGuildTo = GID2;
+		}
+
+		void operator() (CPeer* peer)
+		{
+			if (peer->GetChannel() == 0)
+				return;
+
+			peer->EncodeHeader(HEADER_DG_GUILD_WAR, 0, sizeof(TPacketGuildWar));
+			peer->Encode(&p, sizeof(TPacketGuildWar));
+		}
+
+		TPacketGuildWar p;
+	};
+
+	struct FSendGuildWarScore
+	{
+		FSendGuildWarScore(DWORD guild_gain, DWORD dwOppGID, int iScore, int iBetScore)
+		{
+			pck.dwGuildGainPoint = guild_gain;
+			pck.dwGuildOpponent = dwOppGID;
+			pck.lScore = iScore;
+			pck.lBetScore = iBetScore;
+		}
+
+		void operator() (CPeer* peer)
+		{
+			if (peer->GetChannel() == 0)
+				return;
+
+			peer->EncodeHeader(HEADER_DG_GUILD_WAR_SCORE, 0, sizeof(pck));
+			peer->Encode(&pck, sizeof(pck));
+		}
+
+		TPacketGuildWarScore pck;
+	};
+}
+
+CGuildManager::CGuildManager()
+{
+}
+
+CGuildManager::~CGuildManager()
+{
+	while (!m_pqOnWar.empty())
+	{
+		if (!m_pqOnWar.top().second->bEnd)
+			delete m_pqOnWar.top().second;
+
+		m_pqOnWar.pop();
+	}
+}
+
+TGuild& CGuildManager::TouchGuild(DWORD GID)
+{
+	auto it = m_map_kGuild.find(GID);
+	if (it != m_map_kGuild.end())
+		return it->second;
+
+	TGuild info;
+	m_map_kGuild.insert(std::map<DWORD, TGuild>::value_type(GID, info));
+	return m_map_kGuild[GID];
+}
+
+void CGuildManager::ParseResult(SQLResult* pRes)
+{
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pRes->pSQLResult)))
+	{
+		DWORD GID = strtoul(row[0], NULL, 10);
+
+		TGuild& r_info = TouchGuild(GID);
+
+		strlcpy(r_info.szName, row[1], sizeof(r_info.szName));
+		str_to_number(r_info.ladder_point, row[2]);
+		str_to_number(r_info.win, row[3]);
+		str_to_number(r_info.draw, row[4]);
+		str_to_number(r_info.loss, row[5]);
+		str_to_number(r_info.gold, row[6]);
+		str_to_number(r_info.level, row[7]);
+
+		sys_log(0,
+			"GuildWar: %-24s ladder %-5d win %-3d draw %-3d loss %-3d",
+			r_info.szName,
+			r_info.ladder_point,
+			r_info.win,
+			r_info.draw,
+			r_info.loss);
+	}
+}
+
+void CGuildManager::Initialize()
+{
+	char szQuery[1024];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `id`, `name`, `ladder_point`, `win`, `draw`, `loss`, `gold`, `level` FROM guild%s", GetTablePostfix());
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+	if (pmsg->Get()->uiNumRows)
+		ParseResult(pmsg->Get());
+
+	char str[128 + 1];
+
+	if (!CConfig::instance().GetValue("POLY_POWER", str, sizeof(str)))
+		*str = '\0';
+
+	if (!polyPower.Analyze(str))
+		sys_err("cannot set power poly: %s", str);
+	else
+		sys_log(0, "POWER_POLY: %s", str);
+
+	if (!CConfig::instance().GetValue("POLY_HANDICAP", str, sizeof(str)))
+		*str = '\0';
+
+	if (!polyHandicap.Analyze(str))
+		sys_err("cannot set handicap poly: %s", str);
+	else
+		sys_log(0, "HANDICAP_POLY: %s", str);
+
+	QueryRanking();
+}
+
+void CGuildManager::Load(DWORD dwGuildID)
+{
+	char szQuery[1024];
+
+	snprintf(szQuery, sizeof(szQuery), "SELECT `id`, `name`, `ladder_point`, `win`, `draw`, `loss`, `gold`, `level` FROM guild%s WHERE id=%u", GetTablePostfix(), dwGuildID);
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+	if (pmsg->Get()->uiNumRows)
+		ParseResult(pmsg->Get());
+}
+
+void CGuildManager::QueryRanking()
+{
+	char szQuery[256];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `id`, `name`, `ladder_point` FROM guild%s ORDER BY `ladder_point` DESC LIMIT 20", GetTablePostfix());
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_GUILD_RANKING, 0, 0);
+}
+
+int CGuildManager::GetRanking(DWORD dwGID)
+{
+	auto it = map_kLadderPointRankingByGID.find(dwGID);
+	if (it == map_kLadderPointRankingByGID.end())
+		return GUILD_RANK_MAX_NUM;
+
+	return MINMAX(0, it->second, GUILD_RANK_MAX_NUM);
+}
+
+void CGuildManager::ResultRanking(MYSQL_RES* pRes)
+{
+	if (!pRes)
+		return;
+
+	int iLastLadderPoint = -1;
+	int iRank = 0;
+
+	map_kLadderPointRankingByGID.clear();
+
+	MYSQL_ROW row;
+
+	while ((row = mysql_fetch_row(pRes)))
+	{
+		DWORD dwGID = 0; str_to_number(dwGID, row[0]);
+		int iLadderPoint = 0; str_to_number(iLadderPoint, row[2]);
+
+		if (iLadderPoint != iLastLadderPoint)
+			++iRank;
+
+		sys_log(0, "GUILD_RANK: %-24s %2d %d", row[1], iRank, iLadderPoint);
+
+		map_kLadderPointRankingByGID.insert(std::make_pair(dwGID, iRank));
+	}
+}
+
+void CGuildManager::Update()
+{
+	ProcessReserveWar(); //   처
+
+	time_t now = CClientManager::instance().GetCurrentTime();
+
+	if (!m_pqOnWar.empty())
+	{
+		// UNKNOWN_GUILD_MANAGE_UPDATE_LOG
+		/*
+		sys_log(0, "GuildManager::Update size %d now %d top %d, %s(%u) vs %s(%u)",
+			m_WarMap.size(),
+			now,
+			m_pqOnWar.top().first,
+			m_map_kGuild[m_pqOnWar.top().second->GID[0]].szName,
+			m_pqOnWar.top().second->GID[0],
+			m_map_kGuild[m_pqOnWar.top().second->GID[1]].szName,
+			m_pqOnWar.top().second->GID[1]
+		);
+		*/
+		// END_OF_UNKNOWN_GUILD_MANAGE_UPDATE_LOG
+
+		while (!m_pqOnWar.empty() && (m_pqOnWar.top().first <= now || (m_pqOnWar.top().second && m_pqOnWar.top().second->bEnd)))
+		{
+			TGuildWarPQElement* e = m_pqOnWar.top().second;
+
+			m_pqOnWar.pop();
+
+			if (e)
+			{
+				if (!e->bEnd)
+					WarEnd(e->GID[0], e->GID[1], false);
+
+				delete e;
+			}
+		}
+	}
+
+	// GUILD_SKILL_COOLTIME_BUG_FIX
+	while (!m_pqSkill.empty() && m_pqSkill.top().first <= now)
+	{
+		const TGuildSkillUsed& s = m_pqSkill.top().second;
+		CClientManager::instance().SendGuildSkillUsable(s.GID, s.dwSkillVnum, true);
+		m_pqSkill.pop();
+	}
+	// END_OF_GUILD_SKILL_COOLTIME_BUG_FIX
+
+	while (!m_pqWaitStart.empty() && m_pqWaitStart.top().first <= now)
+	{
+		const TGuildWaitStartInfo& ws = m_pqWaitStart.top().second;
+		m_pqWaitStart.pop();
+
+		StartWar(ws.bType, ws.GID[0], ws.GID[1], ws.pkReserve); // insert new element to m_WarMap and m_pqOnWar
+
+		if (ws.lInitialScore)
+		{
+			UpdateScore(ws.GID[0], ws.GID[1], ws.lInitialScore, 0);
+			UpdateScore(ws.GID[1], ws.GID[0], ws.lInitialScore, 0);
+		}
+
+		TPacketGuildWar p;
+
+		p.bType = ws.bType;
+		p.bWar = GUILD_WAR_ON_WAR;
+		p.dwGuildFrom = ws.GID[0];
+		p.dwGuildTo = ws.GID[1];
+
+		CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR, &p, sizeof(p));
+		sys_log(0, "GuildWar: GUILD sending start of wait start war %d %d", ws.GID[0], ws.GID[1]);
+	}
+}
+
+void CGuildManager::OnSetup(CPeer* peer)
+{
+	for (GuildWarMap::iterator it_cont = m_WarMap.begin(); it_cont != m_WarMap.end(); ++it_cont)
+	{
+		for (GuildWarInfoMap::iterator it = it_cont->second.begin(); it != it_cont->second.end(); ++it)
+		{
+			DWORD g1 = it_cont->first;
+			DWORD g2 = it->first;
+			TGuildWarPQElement* p = it->second.pElement;
+
+			if (!p || p->bEnd)
+				continue;
+
+			FSendPeerWar(p->bType, GUILD_WAR_ON_WAR, g1, g2) (peer);
+			FSendGuildWarScore(p->GID[0], p->GID[1], p->iScore[0], p->iBetScore[0]);
+			FSendGuildWarScore(p->GID[1], p->GID[0], p->iScore[1], p->iBetScore[1]);
+		}
+	}
+
+	for (GuildDeclareInfoSet::iterator it = m_DeclareMap.begin(); it != m_DeclareMap.end(); ++it)
+	{
+		FSendPeerWar(it->bType, GUILD_WAR_SEND_DECLARE, it->dwGuildID[0], it->dwGuildID[1]) (peer);
+	}
+
+	for (WarReserveMap::iterator it = m_map_kWarReserve.begin(); it != m_map_kWarReserve.end(); ++it)
+	{
+		it->second->OnSetup(peer);
+	}
+}
+
+void CGuildManager::GuildWarWin(DWORD GID)
+{
+	auto it = m_map_kGuild.find(GID);
+	if (it == m_map_kGuild.end())
+		return;
+
+	++it->second.win;
+
+	char buf[1024];
+	snprintf(buf, sizeof(buf), "UPDATE guild%s SET `win` = %d WHERE `id` = %u", GetTablePostfix(), it->second.win, GID);
+	CDBManager::instance().AsyncQuery(buf);
+}
+
+void CGuildManager::GuildWarLose(DWORD GID)
+{
+	auto it = m_map_kGuild.find(GID);
+	if (it == m_map_kGuild.end())
+		return;
+
+	++it->second.loss;
+
+	char buf[1024];
+	snprintf(buf, sizeof(buf), "UPDATE guild%s SET `loss` = %d WHERE `id` = %u", GetTablePostfix(), it->second.loss, GID);
+	CDBManager::instance().AsyncQuery(buf);
+}
+
+void CGuildManager::GuildWarDraw(DWORD GID)
+{
+	auto it = m_map_kGuild.find(GID);
+	if (it == m_map_kGuild.end())
+		return;
+
+	++it->second.draw;
+
+	char buf[1024];
+	snprintf(buf, sizeof(buf), "UPDATE guild%s SET `draw` = %d WHERE `id` = %u", GetTablePostfix(), it->second.draw, GID);
+	CDBManager::instance().AsyncQuery(buf);
+}
+
+bool CGuildManager::IsHalfWinLadderPoint(DWORD dwGuildWinner, DWORD dwGuildLoser)
+{
+	DWORD GID1 = dwGuildWinner;
+	DWORD GID2 = dwGuildLoser;
+
+	if (GID1 > GID2)
+		std::swap(GID1, GID2);
+
+	auto it = m_mapGuildWarEndTime[GID1].find(GID2);
+	if (it != m_mapGuildWarEndTime[GID1].end() &&
+		it->second + GUILD_WAR_LADDER_HALF_PENALTY_TIME > CClientManager::instance().GetCurrentTime())
+		return true;
+
+	return false;
+}
+
+void CGuildManager::ProcessDraw(DWORD dwGuildID1, DWORD dwGuildID2)
+{
+	sys_log(0, "GuildWar: \tThe war between %d and %d is ended in draw", dwGuildID1, dwGuildID2);
+
+	GuildWarDraw(dwGuildID1);
+	GuildWarDraw(dwGuildID2);
+	ChangeLadderPoint(dwGuildID1, 0);
+	ChangeLadderPoint(dwGuildID2, 0);
+
+	QueryRanking();
+}
+
+void CGuildManager::ProcessWinLose(DWORD dwGuildWinner, DWORD dwGuildLoser)
+{
+	GuildWarWin(dwGuildWinner);
+	GuildWarLose(dwGuildLoser);
+	sys_log(0, "GuildWar: \tWinner : %d Loser : %d", dwGuildWinner, dwGuildLoser);
+
+	int iPoint = GetLadderPoint(dwGuildLoser);
+	int gain = (int)(iPoint * 0.05);
+	int loss = (int)(iPoint * 0.07);
+
+	if (IsHalfWinLadderPoint(dwGuildWinner, dwGuildLoser))
+		gain /= 2;
+
+	sys_log(0, "GuildWar: \tgain : %d loss : %d", gain, loss);
+
+	ChangeLadderPoint(dwGuildWinner, gain);
+	ChangeLadderPoint(dwGuildLoser, -loss);
+
+	QueryRanking();
+}
+
+void CGuildManager::RemoveWar(DWORD GID1, DWORD GID2)
+{
+	sys_log(0, "GuildWar: RemoveWar(%d, %d)", GID1, GID2);
+
+	if (GID1 > GID2)
+		std::swap(GID2, GID1);
+
+	auto it = m_WarMap[GID1].find(GID2);
+	if (it == m_WarMap[GID1].end())
+	{
+		if (m_WarMap[GID1].empty())
+			m_WarMap.erase(GID1);
+
+		return;
+	}
+
+	if (it->second.pElement)
+		it->second.pElement->bEnd = true;
+
+	m_mapGuildWarEndTime[GID1][GID2] = CClientManager::instance().GetCurrentTime();
+
+	m_WarMap[GID1].erase(it);
+
+	if (m_WarMap[GID1].empty())
+		m_WarMap.erase(GID1);
+}
+
+//
+//     茄 
+//
+void CGuildManager::WarEnd(DWORD GID1, DWORD GID2, bool bForceDraw)
+{
+	if (GID1 > GID2)
+		std::swap(GID2, GID1);
+
+	sys_log(0, "GuildWar: WarEnd %d %d", GID1, GID2);
+
+	auto itWarMap = m_WarMap[GID1].find(GID2);
+	if (itWarMap == m_WarMap[GID1].end())
+	{
+		sys_err("GuildWar: war not exist or already ended. [1]");
+		return;
+	}
+
+	TGuildWarInfo gwi = itWarMap->second;
+	TGuildWarPQElement* pData = gwi.pElement;
+
+	if (!pData || pData->bEnd)
+	{
+		sys_err("GuildWar: war not exist or already ended. [2]");
+		return;
+	}
+
+	DWORD win_guild = pData->GID[0];
+	DWORD lose_guild = pData->GID[1];
+
+	bool bDraw = false;
+
+	if (!bForceDraw) //  쨘寬 틈 荑  체크磯.
+	{
+		if (pData->iScore[0] > pData->iScore[1])
+		{
+			win_guild = pData->GID[0];
+			lose_guild = pData->GID[1];
+		}
+		else if (pData->iScore[1] > pData->iScore[0])
+		{
+			win_guild = pData->GID[1];
+			lose_guild = pData->GID[0];
+		}
+		else
+			bDraw = true;
+	}
+	else //  쨘 荑  쨘
+		bDraw = true;
+
+	if (bDraw)
+		ProcessDraw(win_guild, lose_guild);
+	else
+		ProcessWinLose(win_guild, lose_guild);
+
+	// DB  체   殮   킷  磯.
+	CClientManager::instance().for_each_peer(FSendPeerWar(0, GUILD_WAR_END, GID1, GID2));
+
+	RemoveWar(GID1, GID2);
+}
+
+//
+//   
+//
+void CGuildManager::RecvWarOver(DWORD dwGuildWinner, DWORD dwGuildLoser, bool bDraw, long lWarPrice)
+{
+	sys_log(0, "GuildWar: RecvWarOver : winner %u vs %u draw? %d war_price %d", dwGuildWinner, dwGuildLoser, bDraw ? 1 : 0, lWarPrice);
+
+	DWORD GID1 = dwGuildWinner;
+	DWORD GID2 = dwGuildLoser;
+
+	if (GID1 > GID2)
+		std::swap(GID1, GID2);
+
+	auto it = m_WarMap[GID1].find(GID2);
+	if (it == m_WarMap[GID1].end())
+		return;
+
+	TGuildWarInfo& gw = it->second;
+
+	// Award
+	if (bDraw)
+	{
+		// give bet money / 2 to both guild
+		DepositMoney(dwGuildWinner, lWarPrice / 2);
+		DepositMoney(dwGuildLoser, lWarPrice / 2);
+		ProcessDraw(dwGuildWinner, dwGuildLoser);
+	}
+	else
+	{
+		// give bet money to winner guild
+		DepositMoney(dwGuildWinner, lWarPrice);
+		ProcessWinLose(dwGuildWinner, dwGuildLoser);
+	}
+
+	if (gw.pkReserve)
+	{
+		if (bDraw || !gw.pElement)
+			gw.pkReserve->Draw();
+		else if (gw.pElement->bType == GUILD_WAR_TYPE_BATTLE)
+			gw.pkReserve->End(gw.pElement->iBetScore[0], gw.pElement->iBetScore[1]);
+	}
+
+	RemoveWar(GID1, GID2);
+}
+
+void CGuildManager::RecvWarEnd(DWORD GID1, DWORD GID2)
+{
+	sys_log(0, "GuildWar: RecvWarEnded : %u vs %u", GID1, GID2);
+	WarEnd(GID1, GID2, true); //    耭 磯.
+}
+
+void CGuildManager::StartWar(BYTE bType, DWORD GID1, DWORD GID2, CGuildWarReserve* pkReserve)
+{
+	sys_log(0, "GuildWar: StartWar(%d,%d,%d)", bType, GID1, GID2);
+
+	if (GID1 > GID2)
+		std::swap(GID1, GID2);
+
+	TGuildWarInfo& gw = m_WarMap[GID1][GID2]; // map insert
+
+	if (bType == GUILD_WAR_TYPE_FIELD)
+		gw.tEndTime = CClientManager::instance().GetCurrentTime() + GUILD_WAR_DURATION;
+	else
+		gw.tEndTime = CClientManager::instance().GetCurrentTime() + 172800;
+
+	gw.pElement = new TGuildWarPQElement(bType, GID1, GID2);
+	gw.pkReserve = pkReserve;
+
+	m_pqOnWar.push(std::make_pair(gw.tEndTime, gw.pElement));
+}
+
+void CGuildManager::UpdateScore(DWORD dwGainGID, DWORD dwOppGID, int iScoreDelta, int iBetScoreDelta)
+{
+	DWORD GID1 = dwGainGID;
+	DWORD GID2 = dwOppGID;
+
+	if (GID1 > GID2)
+		std::swap(GID1, GID2);
+
+	auto it = m_WarMap[GID1].find(GID2);
+	if (it != m_WarMap[GID1].end())
+	{
+		TGuildWarPQElement* p = it->second.pElement;
+
+		if (!p || p->bEnd)
+		{
+			sys_err("GuildWar: war not exist or already ended.");
+			return;
+		}
+
+		int iNewScore = 0;
+		int iNewBetScore = 0;
+
+		if (p->GID[0] == dwGainGID)
+		{
+			p->iScore[0] += iScoreDelta;
+			p->iBetScore[0] += iBetScoreDelta;
+
+			iNewScore = p->iScore[0];
+			iNewBetScore = p->iBetScore[0];
+		}
+		else
+		{
+			p->iScore[1] += iScoreDelta;
+			p->iBetScore[1] += iBetScoreDelta;
+
+			iNewScore = p->iScore[1];
+			iNewBetScore = p->iBetScore[1];
+		}
+
+		sys_log(0, "GuildWar: SendGuildWarScore guild %u wartype %u score_delta %d betscore_delta %d result %u, %u",
+			dwGainGID, p->bType, iScoreDelta, iBetScoreDelta, iNewScore, iNewBetScore);
+
+		CClientManager::instance().for_each_peer(FSendGuildWarScore(dwGainGID, dwOppGID, iNewScore, iNewBetScore));
+	}
+}
+
+void CGuildManager::AddDeclare(BYTE bType, DWORD guild_from, DWORD guild_to)
+{
+	TGuildDeclareInfo di(bType, guild_from, guild_to);
+
+	if (m_DeclareMap.find(di) == m_DeclareMap.end())
+		m_DeclareMap.insert(di);
+
+	sys_log(0, "GuildWar: AddDeclare(Type:%d,from:%d,to:%d)", bType, guild_from, guild_to);
+}
+
+void CGuildManager::RemoveDeclare(DWORD guild_from, DWORD guild_to)
+{
+	GuildDeclareInfoSet::iterator it = m_DeclareMap.find(TGuildDeclareInfo(0, guild_from, guild_to));
+	if (it != m_DeclareMap.end())
+		m_DeclareMap.erase(it);
+
+	it = m_DeclareMap.find(TGuildDeclareInfo(0, guild_to, guild_from));
+
+	if (it != m_DeclareMap.end())
+		m_DeclareMap.erase(it);
+
+	sys_log(0, "GuildWar: RemoveDeclare(from:%d,to:%d)", guild_from, guild_to);
+}
+
+bool CGuildManager::TakeBetPrice(DWORD dwGuildTo, DWORD dwGuildFrom, long lWarPrice)
+{
+	auto it_from = m_map_kGuild.find(dwGuildFrom);
+	auto it_to = m_map_kGuild.find(dwGuildTo);
+
+	if (it_from == m_map_kGuild.end() || it_to == m_map_kGuild.end())
+	{
+		sys_log(0, "TakeBetPrice: guild not exist %u %u",
+			dwGuildFrom, dwGuildTo);
+		return false;
+	}
+
+	if (it_from->second.gold < lWarPrice || it_to->second.gold < lWarPrice)
+	{
+		sys_log(0, "TakeBetPrice: not enough gold %u %d to %u %d",
+			dwGuildFrom, it_from->second.gold, dwGuildTo, it_to->second.gold);
+		return false;
+	}
+
+	it_from->second.gold -= lWarPrice;
+	it_to->second.gold -= lWarPrice;
+
+	MoneyChange(dwGuildFrom, it_from->second.gold);
+	MoneyChange(dwGuildTo, it_to->second.gold);
+	return true;
+}
+
+bool CGuildManager::WaitStart(TPacketGuildWar* p)
+{
+	if (p->lWarPrice > 0)
+		if (!TakeBetPrice(p->dwGuildFrom, p->dwGuildTo, p->lWarPrice))
+			return false;
+
+	DWORD dwCurTime = CClientManager::instance().GetCurrentTime();
+
+	TGuildWaitStartInfo info(p->bType, p->dwGuildFrom, p->dwGuildTo, p->lWarPrice, p->lInitialScore, NULL);
+	m_pqWaitStart.push(std::make_pair(dwCurTime + GetGuildWarWaitStartDuration(), info));
+
+	sys_log(0,
+		"GuildWar: WaitStart g1 %d g2 %d price %d start at %u",
+		p->dwGuildFrom,
+		p->dwGuildTo,
+		p->lWarPrice,
+		dwCurTime + GetGuildWarWaitStartDuration());
+
+	return true;
+}
+
+int CGuildManager::GetLadderPoint(DWORD GID)
+{
+	auto it = m_map_kGuild.find(GID);
+	if (it == m_map_kGuild.end())
+		return 0;
+
+	return it->second.ladder_point;
+}
+
+void CGuildManager::ChangeLadderPoint(DWORD GID, int change)
+{
+	auto it = m_map_kGuild.find(GID);
+	if (it == m_map_kGuild.end())
+		return;
+
+	TGuild& r = it->second;
+
+	r.ladder_point = [&]()
+	{
+		const int64_t llNewPoint = static_cast<int64_t>(r.ladder_point) + static_cast<int64_t>(change);
+		if (llNewPoint < 0)
+			return 0;
+		if (llNewPoint > INT_MAX)
+			return INT_MAX;
+		return static_cast<int>(llNewPoint);
+	}();
+
+
+	
+	char buf[1024];
+	snprintf(buf, sizeof(buf), "UPDATE guild%s SET `ladder_point` = %d WHERE `id` = %u", GetTablePostfix(), r.ladder_point, GID);
+	CDBManager::instance().AsyncQuery(buf);
+
+	sys_log(0, "GuildManager::ChangeLadderPoint %u %d", GID, r.ladder_point);
+	sys_log(0, "%s", buf);
+
+	// Packet 
+	TPacketGuildLadder p;
+
+	p.dwGuild = GID;
+	p.lLadderPoint = r.ladder_point;
+	p.lWin = r.win;
+	p.lDraw = r.draw;
+	p.lLoss = r.loss;
+
+	CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_LADDER, &p, sizeof(TPacketGuildLadder));
+}
+
+void CGuildManager::UseSkill(DWORD GID, DWORD dwSkillVnum, DWORD dwCooltime)
+{
+	// GUILD_SKILL_COOLTIME_BUG_FIX
+	sys_log(0, "UseSkill(gid=%d, skill=%d) CoolTime(%d:%d)", GID, dwSkillVnum, dwCooltime, CClientManager::instance().GetCurrentTime() + dwCooltime);
+	m_pqSkill.push(std::make_pair(CClientManager::instance().GetCurrentTime() + dwCooltime, TGuildSkillUsed(GID, dwSkillVnum)));
+	// END_OF_GUILD_SKILL_COOLTIME_BUG_FIX
+}
+
+void CGuildManager::MoneyChange(DWORD dwGuild, DWORD dwGold)
+{
+	sys_log(0, "GuildManager::MoneyChange %d %d", dwGuild, dwGold);
+
+	TPacketDGGuildMoneyChange p;
+	p.dwGuild = dwGuild;
+	p.iTotalGold = dwGold;
+	CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_MONEY_CHANGE, &p, sizeof(p));
+
+	char buf[1024];
+	snprintf(buf, sizeof(buf), "UPDATE guild%s SET `gold` = %u WHERE `id` = %u", GetTablePostfix(), dwGold, dwGuild);
+	CDBManager::instance().AsyncQuery(buf);
+}
+
+void CGuildManager::DepositMoney(DWORD dwGuild, INT iGold)
+{
+	if (iGold <= 0)
+		return;
+
+	auto it = m_map_kGuild.find(dwGuild);
+	if (it == m_map_kGuild.end())
+	{
+		sys_err("No guild by id %u", dwGuild);
+		return;
+	}
+
+	it->second.gold += iGold;
+	sys_log(0, "GUILD: %u Deposit %u Total %d", dwGuild, iGold, it->second.gold);
+
+	MoneyChange(dwGuild, it->second.gold);
+}
+
+void CGuildManager::WithdrawMoney(CPeer* peer, DWORD dwGuild, INT iGold)
+{
+	auto it = m_map_kGuild.find(dwGuild);
+	if (it == m_map_kGuild.end())
+	{
+		sys_err("No guild by id %u", dwGuild);
+		return;
+	}
+
+	//  構 첨娩
+	if (it->second.gold >= iGold)
+	{
+		it->second.gold -= iGold;
+		sys_log(0, "GUILD: %u Withdraw %d Total %d", dwGuild, iGold, it->second.gold);
+
+		TPacketDGGuildMoneyWithdraw p;
+		p.dwGuild = dwGuild;
+		p.iChangeGold = iGold;
+
+		peer->EncodeHeader(HEADER_DG_GUILD_WITHDRAW_MONEY_GIVE, 0, sizeof(TPacketDGGuildMoneyWithdraw));
+		peer->Encode(&p, sizeof(TPacketDGGuildMoneyWithdraw));
+	}
+}
+
+void CGuildManager::WithdrawMoneyReply(DWORD dwGuild, BYTE bGiveSuccess, INT iGold)
+{
+	auto it = m_map_kGuild.find(dwGuild);
+	if (it == m_map_kGuild.end())
+		return;
+
+	sys_log(0, "GuildManager::WithdrawMoneyReply : guild %u success %d gold %d", dwGuild, bGiveSuccess, iGold);
+
+	if (!bGiveSuccess)
+		it->second.gold += iGold;
+	else
+		MoneyChange(dwGuild, it->second.gold);
+}
+
+//
+//  (微   獵)
+//
+const int c_aiScoreByLevel[GUILD_MAX_LEVEL + 1] =
+{
+	500, // level 0 = 500 probably error
+	500, // 1
+	1000,
+	2000,
+	3000,
+	4000,
+	6000,
+	8000,
+	10000,
+	12000,
+	15000, // 10
+	18000,
+	21000,
+	24000,
+	28000,
+	32000,
+	36000,
+	40000,
+	45000,
+	50000,
+	55000,
+};
+
+const int c_aiScoreByRanking[GUILD_RANK_MAX_NUM + 1] =
+{
+	0,
+	55000, // 1
+	50000,
+	45000,
+	40000,
+	36000,
+	32000,
+	28000,
+	24000,
+	21000,
+	18000, // 10
+	15000,
+	12000,
+	10000,
+	8000,
+	6000,
+	4000,
+	3000,
+	2000,
+	1000,
+	500 // 20
+};
+
+void CGuildManager::BootReserveWar()
+{
+	const char* c_apszQuery[2] =
+	{
+		"SELECT id, guild1, guild2, UNIX_TIMESTAMP(time), type, warprice, initscore, bet_from, bet_to, power1, power2, handicap FROM guild_war_reservation WHERE started=1 AND winner=-1",
+		"SELECT id, guild1, guild2, UNIX_TIMESTAMP(time), type, warprice, initscore, bet_from, bet_to, power1, power2, handicap FROM guild_war_reservation WHERE started=0"
+	};
+
+	for (int i = 0; i < 2; ++i)
+	{
+		std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(c_apszQuery[i]));
+
+		if (pmsg->Get()->uiNumRows == 0)
+			continue;
+
+		MYSQL_ROW row;
+
+		while ((row = mysql_fetch_row(pmsg->Get()->pSQLResult)))
+		{
+			int col = 0;
+
+			TGuildWarReserve t;
+
+			str_to_number(t.dwID, row[col++]);
+			str_to_number(t.dwGuildFrom, row[col++]);
+			str_to_number(t.dwGuildTo, row[col++]);
+			str_to_number(t.dwTime, row[col++]);
+			str_to_number(t.bType, row[col++]);
+			str_to_number(t.lWarPrice, row[col++]);
+			str_to_number(t.lInitialScore, row[col++]);
+			str_to_number(t.dwBetFrom, row[col++]);
+			str_to_number(t.dwBetTo, row[col++]);
+			str_to_number(t.lPowerFrom, row[col++]);
+			str_to_number(t.lPowerTo, row[col++]);
+			str_to_number(t.lHandicap, row[col++]);
+			t.bStarted = 0;
+
+			CGuildWarReserve* pkReserve = new CGuildWarReserve(t);
+
+			char buf[512];
+			snprintf(buf, sizeof(buf), "GuildWar: BootReserveWar : step %d id %u GID1 %u GID2 %u", i, t.dwID, t.dwGuildFrom, t.dwGuildTo);
+			// i == 0 見   DB 튕 譴퓐 쨘 처磯.
+			// 풔, 5     쨘 처磯. ( 첸 娩)
+			//if (i == 0 || (int) t.dwTime - CClientManager::instance().GetCurrentTime() < 60 * 5)
+			if (i == 0 || (int)t.dwTime - CClientManager::instance().GetCurrentTime() < 0)
+			{
+				if (i == 0)
+					sys_log(0, "%s : DB was shutdowned while war is being.", buf);
+				else
+					sys_log(0, "%s : left time lower than 5 minutes, will be canceled", buf);
+
+				pkReserve->Draw();
+				delete pkReserve;
+			}
+			else
+			{
+				sys_log(0, "%s : OK", buf);
+				m_map_kWarReserve.insert(std::make_pair(t.dwID, pkReserve));
+			}
+		}
+	}
+}
+
+int GetAverageGuildMemberLevel(DWORD dwGID)
+{
+	char szQuery[QUERY_MAX_LEN];
+
+	snprintf(szQuery, sizeof(szQuery),
+		"SELECT AVG(`level`) FROM guild_member%s, player%s AS p WHERE `guild_id` = %u AND guild_member%s.`pid` = p.`id`",
+		GetTablePostfix(), GetTablePostfix(), dwGID, GetTablePostfix());
+
+	std::unique_ptr<SQLMsg> msg(CDBManager::instance().DirectQuery(szQuery));
+
+	MYSQL_ROW row;
+	row = mysql_fetch_row(msg->Get()->pSQLResult);
+
+	int nAverageLevel = 0; str_to_number(nAverageLevel, row[0]);
+	return nAverageLevel;
+}
+
+int GetGuildMemberCount(DWORD dwGID)
+{
+	char szQuery[QUERY_MAX_LEN];
+
+	snprintf(szQuery, sizeof(szQuery), "SELECT COUNT(*) FROM guild_member%s WHERE `guild_id` = %u", GetTablePostfix(), dwGID);
+
+	std::unique_ptr<SQLMsg> msg(CDBManager::instance().DirectQuery(szQuery));
+
+	MYSQL_ROW row;
+	row = mysql_fetch_row(msg->Get()->pSQLResult);
+
+	DWORD dwCount = 0; str_to_number(dwCount, row[0]);
+	return dwCount;
+}
+
+bool CGuildManager::ReserveWar(TPacketGuildWar* p)
+{
+	DWORD GID1 = p->dwGuildFrom;
+	DWORD GID2 = p->dwGuildTo;
+
+	if (GID1 > GID2)
+		std::swap(GID1, GID2);
+
+	if (p->lWarPrice > 0)
+		if (!TakeBetPrice(GID1, GID2, p->lWarPrice))
+			return false;
+
+	TGuildWarReserve t;
+	memset(&t, 0, sizeof(TGuildWarReserve));
+
+	t.dwGuildFrom = GID1;
+	t.dwGuildTo = GID2;
+	t.dwTime = CClientManager::instance().GetCurrentTime() + GetGuildWarReserveSeconds();
+	t.bType = p->bType;
+	t.lWarPrice = p->lWarPrice;
+	t.lInitialScore = p->lInitialScore;
+
+	int lvp, rkp, alv, mc;
+
+	// 커 
+	TGuild& k1 = TouchGuild(GID1);
+
+	lvp = c_aiScoreByLevel[MIN(GUILD_MAX_LEVEL, k1.level)];
+	rkp = c_aiScoreByRanking[GetRanking(GID1)];
+	alv = GetAverageGuildMemberLevel(GID1);
+	mc = GetGuildMemberCount(GID1);
+
+	polyPower.SetVar("lvp", lvp);
+	polyPower.SetVar("rkp", rkp);
+	polyPower.SetVar("alv", alv);
+	polyPower.SetVar("mc", mc);
+
+	t.lPowerFrom = (long)polyPower.Eval();
+	sys_log(0, "GuildWar: %u lvp %d rkp %d alv %d mc %d power %d", GID1, lvp, rkp, alv, mc, t.lPowerFrom);
+
+	// 커 
+	TGuild& k2 = TouchGuild(GID2);
+
+	lvp = c_aiScoreByLevel[MIN(GUILD_MAX_LEVEL, k2.level)];
+	rkp = c_aiScoreByRanking[GetRanking(GID2)];
+	alv = GetAverageGuildMemberLevel(GID2);
+	mc = GetGuildMemberCount(GID2);
+
+	polyPower.SetVar("lvp", lvp);
+	polyPower.SetVar("rkp", rkp);
+	polyPower.SetVar("alv", alv);
+	polyPower.SetVar("mc", mc);
+
+	t.lPowerTo = (long)polyPower.Eval();
+	sys_log(0, "GuildWar: %u lvp %d rkp %d alv %d mc %d power %d", GID2, lvp, rkp, alv, mc, t.lPowerTo);
+
+	// 湄캡 
+	if (t.lPowerTo > t.lPowerFrom)
+	{
+		polyHandicap.SetVar("pA", t.lPowerTo);
+		polyHandicap.SetVar("pB", t.lPowerFrom);
+	}
+	else
+	{
+		polyHandicap.SetVar("pA", t.lPowerFrom);
+		polyHandicap.SetVar("pB", t.lPowerTo);
+	}
+
+	t.lHandicap = (long)polyHandicap.Eval();
+	sys_log(0, "GuildWar: handicap %d", t.lHandicap);
+
+	// 
+	char szQuery[512];
+
+	snprintf(szQuery, sizeof(szQuery),
+		"INSERT INTO guild_war_reservation%s (`guild1`, `guild2`, `time`, `type`, `warprice`, `initscore`, `power1`, `power2`, `handicap`) "
+		"VALUES(%u, %u, DATE_ADD(NOW(), INTERVAL 180 SECOND), %u, %ld, %ld, %ld, %ld, %ld)",
+		GetTablePostfix(), GID1, GID2, p->bType, p->lWarPrice, p->lInitialScore, t.lPowerFrom, t.lPowerTo, t.lHandicap);
+
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiInsertID == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
+	{
+		sys_err("GuildWar: Cannot insert row");
+		return false;
+	}
+
+	t.dwID = pmsg->Get()->uiInsertID;
+
+	m_map_kWarReserve.insert(std::make_pair(t.dwID, new CGuildWarReserve(t)));
+
+	CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR_RESERVE_ADD, &t, sizeof(TGuildWarReserve));
+	return true;
+}
+
+void CGuildManager::ProcessReserveWar()
+{
+	DWORD dwCurTime = CClientManager::instance().GetCurrentTime();
+
+	auto it = m_map_kWarReserve.begin();
+	while (it != m_map_kWarReserve.end())
+	{
+		auto it2 = it++;
+
+		CGuildWarReserve* pk = it2->second;
+		TGuildWarReserve& r = pk->GetDataRef();
+
+		if (!r.bStarted && r.dwTime - 1800 <= dwCurTime) // 30  舡.
+		{
+			int iMin = (int)ceil((int)(r.dwTime - dwCurTime) / 60.0);
+
+			TGuild& r_1 = m_map_kGuild[r.dwGuildFrom];
+			TGuild& r_2 = m_map_kGuild[r.dwGuildTo];
+
+			sys_log(0, "GuildWar: started GID1 %u GID2 %u %d time %d min %d", r.dwGuildFrom, r.dwGuildTo, r.bStarted, dwCurTime - r.dwTime, iMin);
+
+			if (iMin <= 0)
+			{
+				char szQuery[128];
+				snprintf(szQuery, sizeof(szQuery), "UPDATE guild_war_reservation%s SET `started` = 1 WHERE `id` = %u", GetTablePostfix(), r.dwID);
+				CDBManager::instance().AsyncQuery(szQuery);
+
+				CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR_RESERVE_DEL, &r.dwID, sizeof(DWORD));
+
+				r.bStarted = true;
+
+				TGuildWaitStartInfo info(r.bType, r.dwGuildFrom, r.dwGuildTo, r.lWarPrice, r.lInitialScore, pk);
+				m_pqWaitStart.push(std::make_pair(dwCurTime + GetGuildWarWaitStartDuration(), info));
+
+				TPacketGuildWar pck;
+
+				pck.bType = r.bType;
+				pck.bWar = GUILD_WAR_WAIT_START;
+				pck.dwGuildFrom = r.dwGuildFrom;
+				pck.dwGuildTo = r.dwGuildTo;
+				pck.lWarPrice = r.lWarPrice;
+				pck.lInitialScore = r.lInitialScore;
+
+				CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR, &pck, sizeof(TPacketGuildWar));
+				//m_map_kWarReserve.erase(it2);
+			}
+			else
+			{
+				if (iMin != pk->GetLastNoticeMin())
+				{
+					pk->SetLastNoticeMin(iMin);
+
+					if (!g_stLocale.compare("euckr"))
+						CClientManager::instance().SendNotice("%s  %s    %d   絳求!", r_1.szName, r_2.szName, iMin);
+					else if (!g_stLocale.compare("gb2312"))
+						CClientManager::instance().SendNotice("%s  %s 캅濫 %d啖迦!", r_1.szName, r_2.szName, iMin);
+				}
+			}
+		}
+	}
+}
+
+bool CGuildManager::Bet(DWORD dwID, const char* c_pszLogin, DWORD dwGold, DWORD dwGuild)
+{
+	char szQuery[1024];
+
+	auto it = m_map_kWarReserve.find(dwID);
+	if (it == m_map_kWarReserve.end())
+	{
+		sys_log(0, "WAR_RESERVE: Bet: cannot find reserve war by id %u", dwID);
+		snprintf(szQuery, sizeof(szQuery), "INSERT INTO item_award%s (`login`, `vnum`, `socket0`, `given_time`) VALUES('%s', %d, %u, NOW())",
+			GetTablePostfix(), c_pszLogin, ITEM_ELK_VNUM, dwGold);
+		CDBManager::instance().AsyncQuery(szQuery);
+		return false;
+	}
+
+	if (!it->second->Bet(c_pszLogin, dwGold, dwGuild))
+	{
+		sys_log(0, "WAR_RESERVE: Bet: cannot bet id %u, login %s, gold %u, guild %u", dwID, c_pszLogin, dwGold, dwGuild);
+		snprintf(szQuery, sizeof(szQuery), "INSERT INTO item_award%s (`login`, `vnum`, `socket0`, `given_time`) VALUES('%s', %d, %u, NOW())",
+			GetTablePostfix(), c_pszLogin, ITEM_ELK_VNUM, dwGold);
+		CDBManager::instance().AsyncQuery(szQuery);
+		return false;
+	}
+
+	return true;
+}
+
+void CGuildManager::CancelWar(DWORD GID1, DWORD GID2)
+{
+	RemoveDeclare(GID1, GID2);
+	RemoveWar(GID1, GID2);
+}
+
+bool CGuildManager::ChangeMaster(DWORD dwGID, DWORD dwFrom, DWORD dwTo)
+{
+	auto iter = m_map_kGuild.find(dwGID);
+	if (iter == m_map_kGuild.end())
+		return false;
+
+	char szQuery[1024];
+
+	snprintf(szQuery, sizeof(szQuery), "UPDATE guild%s SET `master` = %u WHERE `id` = %u", GetTablePostfix(), dwTo, dwGID);
+	delete CDBManager::instance().DirectQuery(szQuery);
+
+	snprintf(szQuery, sizeof(szQuery), "UPDATE guild_member%s SET `grade` = 1 WHERE `pid` = %u", GetTablePostfix(), dwTo);
+	delete CDBManager::instance().DirectQuery(szQuery);
+
+	snprintf(szQuery, sizeof(szQuery), "UPDATE guild_member%s SET `grade` = 15 WHERE `pid` = %u", GetTablePostfix(), dwFrom);
+	delete CDBManager::instance().DirectQuery(szQuery);
+
+	return true;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////
+// Guild War Reserve Class
+//////////////////////////////////////////////////////////////////////////////////////////
+CGuildWarReserve::CGuildWarReserve(const TGuildWarReserve& rTable)
+{
+	thecore_memcpy(&m_data, &rTable, sizeof(TGuildWarReserve));
+	m_iLastNoticeMin = -1;
+
+	Initialize();
+}
+
+void CGuildWarReserve::Initialize()
+{
+	char szQuery[256];
+	snprintf(szQuery, sizeof(szQuery), "SELECT `login`, `guild`, `gold` FROM guild_war_bet%s WHERE `war_id` = %u", GetTablePostfix(), m_data.dwID);
+
+	std::unique_ptr<SQLMsg> msgbet(CDBManager::instance().DirectQuery(szQuery));
+
+	if (msgbet->Get()->uiNumRows)
+	{
+		MYSQL_RES* res = msgbet->Get()->pSQLResult;
+		MYSQL_ROW row;
+
+		char szLogin[LOGIN_MAX_LEN + 1];
+		DWORD dwGuild;
+		DWORD dwGold;
+
+		while ((row = mysql_fetch_row(res)))
+		{
+			dwGuild = dwGold = 0;
+			strlcpy(szLogin, row[0], sizeof(szLogin));
+			str_to_number(dwGuild, row[1]);
+			str_to_number(dwGold, row[2]);
+
+			mapBet.insert(std::make_pair(szLogin, std::make_pair(dwGuild, dwGold)));
+		}
+	}
+}
+
+void CGuildWarReserve::OnSetup(CPeer* peer)
+{
+	if (m_data.bStarted) // 譴 滂   苛쨈.
+		return;
+
+	FSendPeerWar(m_data.bType, GUILD_WAR_RESERVE, m_data.dwGuildFrom, m_data.dwGuildTo) (peer);
+
+	peer->EncodeHeader(HEADER_DG_GUILD_WAR_RESERVE_ADD, 0, sizeof(TGuildWarReserve));
+	peer->Encode(&m_data, sizeof(TGuildWarReserve));
+
+	TPacketGDGuildWarBet pckBet;
+	pckBet.dwWarID = m_data.dwID;
+
+	auto it = mapBet.begin();
+	while (it != mapBet.end())
+	{
+		strlcpy(pckBet.szLogin, it->first.c_str(), sizeof(pckBet.szLogin));
+		pckBet.dwGuild = it->second.first;
+		pckBet.dwGold = it->second.second;
+
+		peer->EncodeHeader(HEADER_DG_GUILD_WAR_BET, 0, sizeof(TPacketGDGuildWarBet));
+		peer->Encode(&pckBet, sizeof(TPacketGDGuildWarBet));
+
+		++it;
+	}
+}
+
+bool CGuildWarReserve::Bet(const char* pszLogin, DWORD dwGold, DWORD dwGuild)
+{
+	char szQuery[1024];
+
+	// SQLi hardening: login is a string, must be escaped before building SQL
+	char escLogin[LOGIN_MAX_LEN * 2 + 1];
+	{
+		const size_t len = strnlen(pszLogin, LOGIN_MAX_LEN);
+		CDBManager::instance().EscapeString(escLogin, pszLogin, static_cast<unsigned long>(len));
+	}
+
+	if (m_data.dwGuildFrom != dwGuild && m_data.dwGuildTo != dwGuild)
+	{
+		sys_log(0, "GuildWarReserve::Bet: invalid guild id");
+		return false;
+	}
+
+	if (m_data.bStarted)
+	{
+		sys_log(0, "GuildWarReserve::Bet: war is already started");
+		return false;
+	}
+
+	if (mapBet.find(pszLogin) != mapBet.end())
+	{
+		sys_log(0, "GuildWarReserve::Bet: failed. already bet");
+		return false;
+	}
+
+	snprintf(szQuery, sizeof(szQuery),
+		"INSERT INTO guild_war_bet%s (`war_id`, `login`, `gold`, `guild`) VALUES(%u, '%s', %u, %u)",
+		GetTablePostfix(), m_data.dwID, escLogin, dwGold, dwGuild);
+
+	std::unique_ptr<SQLMsg> pmsg(CDBManager::instance().DirectQuery(szQuery));
+
+	if (pmsg->Get()->uiAffectedRows == 0 || pmsg->Get()->uiAffectedRows == (uint32_t)-1)
+	{
+		sys_log(0, "GuildWarReserve::Bet: failed. cannot insert row to guild_war_bet table");
+		return false;
+	}
+
+	if (m_data.dwGuildFrom == dwGuild)
+		m_data.dwBetFrom += dwGold;
+	else
+		m_data.dwBetTo += dwGold;
+
+	CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR_RESERVE_ADD, &m_data, sizeof(TGuildWarReserve));
+
+	snprintf(szQuery, sizeof(szQuery), "UPDATE guild_war_reservation%s SET `bet_from` = %u, `bet_to` = %u WHERE `id` = %u",
+		GetTablePostfix(), m_data.dwBetFrom, m_data.dwBetTo, m_data.dwID);
+
+	CDBManager::instance().AsyncQuery(szQuery);
+
+	sys_log(0, "GuildWarReserve::Bet: success. %s %u war_id %u bet %u : %u", pszLogin, dwGuild, m_data.dwID, m_data.dwBetFrom, m_data.dwBetTo);
+	mapBet.insert(std::make_pair(pszLogin, std::make_pair(dwGuild, dwGold)));
+
+	TPacketGDGuildWarBet pckBet;
+	pckBet.dwWarID = m_data.dwID;
+	strlcpy(pckBet.szLogin, pszLogin, sizeof(pckBet.szLogin));
+	pckBet.dwGuild = dwGuild;
+	pckBet.dwGold = dwGold;
+
+	CClientManager::instance().ForwardPacket(HEADER_DG_GUILD_WAR_BET, &pckBet, sizeof(TPacketGDGuildWarBet));
+	return true;
+}
+
+//
+// 쨘 처: 觀 쨘寬  ,    특 황 荑
+// 쨘 처 羚 磯.
+//
+void CGuildWarReserve::Draw()
+{
+	char szQuery[1024];
+
+	snprintf(szQuery, sizeof(szQuery), "UPDATE guild_war_reservation%s SET `started` = 1, `winner` = 0 WHERE `id` = %u", GetTablePostfix(), m_data.dwID);
+	CDBManager::instance().AsyncQuery(szQuery);
+
+	if (mapBet.empty())
+		return;
+
+	sys_log(0, "WAR_REWARD: Draw. war_id %u", m_data.dwID);
+
+	auto it = mapBet.begin();
+
+	while (1)
+	{
+		int iLen = 0;
+		int iRow = 0;
+
+		iLen += snprintf(szQuery, sizeof(szQuery) - iLen, "INSERT INTO item_award%s (`login`, `vnum`, `socket0`, `given_time`) VALUES", GetTablePostfix());
+
+		while (it != mapBet.end())
+		{
+			if (iRow == 0)
+				iLen += snprintf(szQuery + iLen, sizeof(szQuery) - iLen, "('%s', %d, %u, NOW())",
+					it->first.c_str(), ITEM_ELK_VNUM, it->second.second);
+			else
+				iLen += snprintf(szQuery + iLen, sizeof(szQuery) - iLen, ",('%s', %d, %u, NOW())",
+					it->first.c_str(), ITEM_ELK_VNUM, it->second.second);
+
+			it++;
+
+			if (iLen > 384)
+				break;
+
+			++iRow;
+		}
+
+		if (iRow > 0)
+		{
+			sys_log(0, "WAR_REWARD: QUERY: %s", szQuery);
+			CDBManager::instance().AsyncQuery(szQuery);
+		}
+
+		if (it == mapBet.end())
+			break;
+	}
+}
+
+void CGuildWarReserve::End(int iScoreFrom, int iScoreTo)
+{
+	DWORD dwWinner;
+
+	sys_log(0, "WAR_REWARD: End: From %u %d To %u %d", m_data.dwGuildFrom, iScoreFrom, m_data.dwGuildTo, iScoreTo);
+
+	if (m_data.lPowerFrom > m_data.lPowerTo)
+	{
+		if (m_data.lHandicap > iScoreFrom - iScoreTo)
+		{
+			sys_log(0, "WAR_REWARD: End: failed to overcome handicap, From is strong but To won");
+			dwWinner = m_data.dwGuildTo;
+		}
+		else
+		{
+			sys_log(0, "WAR_REWARD: End: success to overcome handicap, From win!");
+			dwWinner = m_data.dwGuildFrom;
+		}
+	}
+	else
+	{
+		if (m_data.lHandicap > iScoreTo - iScoreFrom)
+		{
+			sys_log(0, "WAR_REWARD: End: failed to overcome handicap, To is strong but From won");
+			dwWinner = m_data.dwGuildFrom;
+		}
+		else
+		{
+			sys_log(0, "WAR_REWARD: End: success to overcome handicap, To win!");
+			dwWinner = m_data.dwGuildTo;
+		}
+	}
+
+	char szQuery[1024];
+	snprintf(szQuery, sizeof(szQuery), "UPDATE guild_war_reservation%s SET `started` = 1, `winner` = %u, `result1` = %d, `result2` = %d WHERE `id` = %u",
+		GetTablePostfix(), dwWinner, iScoreFrom, iScoreTo, m_data.dwID);
+	CDBManager::instance().AsyncQuery(szQuery);
+
+	if (mapBet.empty())
+		return;
+
+	DWORD dwTotalBet = m_data.dwBetFrom + m_data.dwBetTo;
+	DWORD dwWinnerBet = 0;
+
+	if (dwWinner == m_data.dwGuildFrom)
+		dwWinnerBet = m_data.dwBetFrom;
+	else if (dwWinner == m_data.dwGuildTo)
+		dwWinnerBet = m_data.dwBetTo;
+	else
+	{
+		sys_err("WAR_REWARD: fatal error, winner does not exist!");
+		return;
+	}
+
+	if (dwWinnerBet == 0)
+	{
+		sys_err("WAR_REWARD: total bet money on winner is zero");
+		return;
+	}
+
+	sys_log(0, "WAR_REWARD: End: Total bet: %u, Winner bet: %u", dwTotalBet, dwWinnerBet);
+
+	auto it = mapBet.begin();
+
+	while (1)
+	{
+		int iLen = 0;
+		int iRow = 0;
+
+		iLen += snprintf(szQuery, sizeof(szQuery) - iLen, "INSERT INTO item_award%s (`login`, `vnum`, `socket0`, `given_time`) VALUES", GetTablePostfix());
+
+		while (it != mapBet.end())
+		{
+			if (it->second.first != dwWinner)
+			{
+				++it;
+				continue;
+			}
+
+			double ratio = (double)it->second.second / dwWinnerBet;
+
+			// 10%    橘
+			sys_log(0, "WAR_REWARD: %s %u ratio %f", it->first.c_str(), it->second.second, ratio);
+
+			DWORD dwGold = (DWORD)(dwTotalBet * ratio * 0.9);
+
+			if (iRow == 0)
+				iLen += snprintf(szQuery + iLen, sizeof(szQuery) - iLen, "('%s', %d, %u, NOW())",
+					it->first.c_str(), ITEM_ELK_VNUM, dwGold);
+			else
+				iLen += snprintf(szQuery + iLen, sizeof(szQuery) - iLen, ",('%s', %d, %u, NOW())",
+					it->first.c_str(), ITEM_ELK_VNUM, dwGold);
+
+			++it;
+
+			if (iLen > 384)
+				break;
+
+			++iRow;
+		}
+
+		if (iRow > 0)
+		{
+			sys_log(0, "WAR_REWARD: query: %s", szQuery);
+			CDBManager::instance().AsyncQuery(szQuery);
+		}
+
+		if (it == mapBet.end())
+			break;
+	}
+}
diff --git a/server/metin2/Source/Server/db/src/ItemAwardManager.cpp b/server/metin2/Source/Server/db/src/ItemAwardManager.cpp
index bf9e374..4761c83 100644
--- a/server/metin2/Source/Server/db/src/ItemAwardManager.cpp
+++ b/server/metin2/Source/Server/db/src/ItemAwardManager.cpp
@@ -1,396 +1,397 @@
-#include "stdafx.h"
-#include "QID.h"
-#include "DBManager.h"
-#include "ItemAwardManager.h"
-#include "Peer.h"
-
-#include "Main.h"
-#include "ClientManager.h"
-
-#if defined(__EXTENDED_ITEM_AWARD__)
-#include <float.h>
-
-inline double uniform_random(const double a, const double b)
-{
-	return thecore_random() / (RAND_MAX + 1.f) * (b - a) + a;
-}
-
-inline float gauss_random(const float fAverage, const float sigma)
-{
-	static bool bHasNextGaussian = false;
-	static float fNextGaussian = 0.0f;
-
-	if (bHasNextGaussian)
-	{
-		bHasNextGaussian = false;
-		return (fNextGaussian * sigma) + fAverage;
-	}
-	else
-	{
-		double v1(0), v2(0), s(0);
-		do
-		{
-			v1 = uniform_random(-1.f, 1.f);
-			v2 = uniform_random(-1.f, 1.f);
-			s = (v1 * v1) + (v2 * v2);
-		} while (s >= 1.f || fabs(s) < FLT_EPSILON);
-
-		const double multiplier = sqrtf(-2 * logf(s) / s);
-		fNextGaussian = v2 * multiplier;
-		bHasNextGaussian = true;
-		return (v1 * multiplier) * sigma + fAverage;
-	}
-}
-#endif
-
-DWORD g_dwLastCachedItemAwardID = 0;
-ItemAwardManager::ItemAwardManager()
-{
-}
-
-ItemAwardManager::~ItemAwardManager()
-{
-}
-
-void ItemAwardManager::RequestLoad()
-{
-	char szQuery[QUERY_MAX_LEN];
-#if defined(__EXTENDED_ITEM_AWARD__)
-	snprintf(szQuery, sizeof(szQuery), "SELECT `id`, `login`, `vnum`, `count`, `socket0`, `socket1`, `socket2`, "
-#if defined(__ITEM_SOCKET6__)
-		"`socket3`, "
-		"`socket4`, "
-		"`socket5`, "
-#endif
-		"`attrtype0`, `attrvalue0`, "
-		"`attrtype1`, `attrvalue1`, "
-		"`attrtype2`, `attrvalue2`, "
-		"`attrtype3`, `attrvalue3`, "
-		"`attrtype4`, `attrvalue4`, "
-		"`attrtype5`, `attrvalue5`, "
-		"`attrtype6`, `attrvalue6`, "
-		"mall, why "
-		"FROM item_award%s WHERE `taken_time` IS NULL AND `id` > %d", GetTablePostfix(), g_dwLastCachedItemAwardID);
-#else
-	snprintf(szQuery, sizeof(szQuery), "SELECT `id`, `login`, `vnum`, `count`, `socket0`, `socket1`, `socket2`, `mall`, `why` FROM item_award%s WHERE `taken_time` IS NULL AND `id` > %d", GetTablePostfix(), g_dwLastCachedItemAwardID);
-#endif
-	CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_AWARD_LOAD, 0, NULL);
-}
-
-void ItemAwardManager::Load(SQLMsg* pMsg)
-{
-	MYSQL_RES* pRes = pMsg->Get()->pSQLResult;
-
-	for (uint i = 0; i < pMsg->Get()->uiNumRows; ++i)
-	{
-		MYSQL_ROW row = mysql_fetch_row(pRes);
-		int col = 0;
-
-		DWORD dwID = 0;
-		str_to_number(dwID, row[col++]);
-
-		if (m_map_award.find(dwID) != m_map_award.end())
-			continue;
-
-		TItemAward* kData = new TItemAward;
-		memset(kData, 0, sizeof(TItemAward));
-
-		kData->dwID = dwID;
-		trim_and_lower(row[col++], kData->szLogin, sizeof(kData->szLogin));
-		str_to_number(kData->dwVnum, row[col++]);
-		str_to_number(kData->dwCount, row[col++]);
-		str_to_number(kData->dwSocket0, row[col++]);
-		str_to_number(kData->dwSocket1, row[col++]);
-		str_to_number(kData->dwSocket2, row[col++]);
-#if defined(__ITEM_SOCKET6__)
-		str_to_number(kData->dwSocket3, row[col++]);
-		str_to_number(kData->dwSocket4, row[col++]);
-		str_to_number(kData->dwSocket5, row[col++]);
-#endif
-#if defined(__EXTENDED_ITEM_AWARD__)
-		for (size_t j = 0; j < ITEM_ATTRIBUTE_MAX_NUM; j++)
-		{
-			str_to_number(kData->aAttr[j].wType, row[col++]);
-			str_to_number(kData->aAttr[j].lValue, row[col++]);
-		}
-#endif
-		str_to_number(kData->bMall, row[col++]);
-
-		if (row[col])
-		{
-			strlcpy(kData->szWhy, row[col], sizeof(kData->szWhy));
-			// 게임 중에 why콜룸에 변동이 생기면
-			char* whyStr = kData->szWhy; // why 콜룸 읽기
-			char cmdStr[100] = ""; // why콜룸에서 읽은 값을 임시 문자열에 복사해둠
-			strcpy(cmdStr, whyStr); // 명령어 얻는 과정에서 토큰쓰면 원본도 토큰화 되기 때문
-			char command[20] = "";
-			CClientManager::instance().GetCommand(cmdStr, command); // command 얻기
-			//sys_err("%d, %s", pItemAward->dwID, command);
-			if (!(strcmp(cmdStr, "GIFT"))) // command 가 GIFT이면
-			{
-				TPacketItemAwardInfromer giftData;
-				strcpy(giftData.login, kData->szLogin); // 로그인 아이디 복사
-				strcpy(giftData.command, command); // 명령어 복사
-				giftData.vnum = kData->dwVnum; // 아이템 vnum도 복사
-				CClientManager::instance().ForwardPacket(HEADER_DG_ITEMAWARD_INFORMER, &giftData, sizeof(TPacketItemAwardInfromer));
-			}
-		}
-
-		m_map_award.insert(std::make_pair(dwID, kData));
-
-		printf("ITEM_AWARD load id %u bMall %d \n", kData->dwID, kData->bMall);
-		sys_log(0, "ITEM_AWARD: load id %lu login %s vnum %lu count %u socket %lu", kData->dwID, kData->szLogin, kData->dwVnum, kData->dwCount, kData->dwSocket0);
-		ItemAwardSet& kSet = m_map_kSetAwardByLogin[kData->szLogin];
-		kSet.insert(kData);
-
-		if (dwID > g_dwLastCachedItemAwardID)
-			g_dwLastCachedItemAwardID = dwID;
-	}
-}
-
-ItemAwardSet* ItemAwardManager::GetByLogin(const char* c_pszLogin)
-{
-	auto it = m_map_kSetAwardByLogin.find(c_pszLogin);
-	if (it == m_map_kSetAwardByLogin.end())
-		return NULL;
-
-	return &it->second;
-}
-
-void ItemAwardManager::Taken(DWORD dwAwardID, DWORD dwItemID)
-{
-	auto it = m_map_award.find(dwAwardID);
-	if (it == m_map_award.end())
-	{
-		sys_log(0, "ITEM_AWARD: Taken ID not exist %lu", dwAwardID);
-		return;
-	}
-
-	TItemAward* k = it->second;
-	k->bTaken = true;
-
-	//
-	// Update taken_time in database to prevent not to give him again.
-	//
-	char szQuery[QUERY_MAX_LEN];
-
-	snprintf(szQuery, sizeof(szQuery), "UPDATE item_award%s SET `taken_time` = NOW(), `item_id` = %u WHERE `id` = %u AND `taken_time` IS NULL",
-		GetTablePostfix(), dwItemID, dwAwardID);
-
-	CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_AWARD_TAKEN, 0, NULL);
-}
-
-std::map<DWORD, TItemAward*>& ItemAwardManager::GetMapAward()
-{
-	return m_map_award;
-}
-
-std::map<std::string, ItemAwardSet>& ItemAwardManager::GetMapkSetAwardByLogin()
-{
-	return m_map_kSetAwardByLogin;
-}
-
-#if defined(__EXTENDED_ITEM_AWARD__)
-const int8_t ItemAwardManager::GetItemAttributeSetIndex(const uint8_t bItemType, const uint8_t bItemSubType)
-{
-	using TAttributeMapT = std::map<uint8_t, std::map<uint8_t, int8_t>>;
-	static const TAttributeMapT mapAttrSetFields =
-	{
-		{ ITEM_WEAPON,
-			{
-				{ WEAPON_ARROW, ITEM_ATTRIBUTE_NONE },
-#if defined(__QUIVER_SYSTEM__)
-				{ WEAPON_QUIVER, ITEM_ATTRIBUTE_NONE },
-#endif
-			}
-		},
-
-		{ ITEM_ARMOR,
-			{
-				{ ARMOR_BODY, ATTRIBUTE_SET_BODY },
-				{ ARMOR_WRIST, ATTRIBUTE_SET_WRIST },
-				{ ARMOR_FOOTS, ATTRIBUTE_SET_FOOTS },
-				{ ARMOR_NECK, ATTRIBUTE_SET_NECK },
-				{ ARMOR_HEAD, ATTRIBUTE_SET_HEAD },
-				{ ARMOR_SHIELD, ATTRIBUTE_SET_SHIELD },
-				{ ARMOR_EAR, ATTRIBUTE_SET_EAR },
-#if defined(__PENDANT_SYSTEM__)
-				{ ARMOR_PENDANT, ATTRIBUTE_SET_PENDANT },
-#endif
-#if defined(__GLOVE_SYSTEM__)
-				{ ARMOR_GLOVE, ATTRIBUTE_SET_GLOVE },
-#endif
-			}
-		},
-
-		{ ITEM_COSTUME,
-			{
-				{ COSTUME_BODY, ATTRIBUTE_SET_COSTUME_BODY },
-				{ COSTUME_HAIR, ATTRIBUTE_SET_COSTUME_HAIR },
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-				{ COSTUME_MOUNT, ITEM_ATTRIBUTE_NONE },
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-				{ COSTUME_ACCE, ITEM_ATTRIBUTE_NONE },
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-				{ COSTUME_WEAPON, ATTRIBUTE_SET_COSTUME_WEAPON },
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-				{ COSTUME_AURA, ITEM_ATTRIBUTE_NONE },
-#endif
-			}
-		},
-	};
-
-	const auto c_iter_type = mapAttrSetFields.find(bItemType);
-	if (c_iter_type != mapAttrSetFields.end())
-	{
-		const auto c_iter_sub_type = c_iter_type->second.find(bItemSubType);
-		if (c_iter_sub_type != c_iter_type->second.end())
-			return c_iter_sub_type->second;
-		else if (c_iter_type->first == ITEM_WEAPON)
-			return ATTRIBUTE_SET_WEAPON;
-	}
-
-	return ITEM_ATTRIBUTE_NONE;
-}
-
-void ItemAwardManager::CheckItemAttributes(TItemAward& rkItemAward, const TItemTable& rkItemTable, const std::vector<TItemAttrTable> vec_itemAttrTable)
-{
-	const BYTE bItemType = rkItemTable.bType;
-	const BYTE bItemSubType = rkItemTable.bSubType;
-	const int8_t iAttributeSet = GetItemAttributeSetIndex(bItemType, bItemSubType);
-	if (iAttributeSet != ITEM_ATTRIBUTE_NONE)
-	{
-		for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
-		{
-			const POINT_TYPE bApplyType = rkItemAward.aAttr[i].wType;
-			const bool bIsAddonTypeItem = (bApplyType == APPLY_SKILL_DAMAGE_BONUS || bApplyType == APPLY_NORMAL_HIT_DAMAGE_BONUS);
-
-			const TItemAttrTable* pkAttrTable = NULL;
-			for (size_t j = 0; j < vec_itemAttrTable.size(); ++j)
-			{
-				const TItemAttrTable& rkAttrTable = vec_itemAttrTable.at(j);
-				if (rkAttrTable.wApplyIndex == bApplyType && !bIsAddonTypeItem)
-				{
-					const uint8_t bAttrLevel = rkAttrTable.bMaxLevelBySet[iAttributeSet];
-					if (bAttrLevel > 0)
-					{
-						pkAttrTable = &rkAttrTable;
-						break;
-					}
-				}
-			}
-
-			if (pkAttrTable)
-			{
-				const POINT_VALUE llMinValue = pkAttrTable->lValues[0];
-				const POINT_VALUE llMaxValue = pkAttrTable->lValues[(sizeof(pkAttrTable->lValues) / sizeof(pkAttrTable->lValues[0])) - 1];
-				rkItemAward.aAttr[i].lValue = MINMAX(llMinValue, rkItemAward.aAttr[i].lValue, llMaxValue);
-			}
-			else if (!bIsAddonTypeItem)
-			{
-				rkItemAward.aAttr[i].wType = 0;
-				rkItemAward.aAttr[i].lValue = 0;
-			}
-		}
-	}
-}
-
-void ItemAwardManager::CheckItemAddonType(TItemAward& rkItemAward, const TItemTable& rkItemTable)
-{
-	const bool bIsAddonTypeItem = (rkItemTable.sAddonType == -1);
-	if (!bIsAddonTypeItem)
-		return;
-
-	bool bHasBonus = false;
-	for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
-	{
-		const POINT_TYPE dwType = rkItemAward.aAttr[i].wType;
-		const POINT_VALUE llValue = rkItemAward.aAttr[i].lValue;
-
-		if ((dwType == APPLY_SKILL_DAMAGE_BONUS || dwType == APPLY_NORMAL_HIT_DAMAGE_BONUS) && llValue)
-		{
-			bHasBonus = true;
-			break;
-		}
-	}
-
-	if (!bHasBonus)
-	{
-		const POINT_VALUE llApplySkillDamageValue = MINMAX(-30, static_cast<POINT_VALUE>((gauss_random(0, 5) + 0.5f)), 30);
-		const POINT_VALUE llApplyNormalHitValue = std::abs(llApplySkillDamageValue) <= 20 ?
-			(-2 * llApplySkillDamageValue) + std::abs(number(-8, 8) + number(-8, 8)) + number(1, 4) :
-			(-2 * llApplySkillDamageValue) + number(1, 5);
-
-		rkItemAward.aAttr[0].wType = APPLY_NORMAL_HIT_DAMAGE_BONUS;
-		rkItemAward.aAttr[0].lValue = llApplyNormalHitValue;
-		rkItemAward.aAttr[1].wType = APPLY_SKILL_DAMAGE_BONUS;
-		rkItemAward.aAttr[1].lValue = llApplySkillDamageValue;
-	}
-}
-
-void ItemAwardManager::CheckItemSkillBook(TItemAward& rkItemAward, const std::vector<TSkillTable> vec_skillTable)
-{
-	const bool bIsBookItem = (rkItemAward.dwVnum == ITEM_SKILLBOOK_VNUM || rkItemAward.dwVnum == ITEM_SKILLFORGET_VNUM);
-	if (!bIsBookItem)
-		return;
-
-	uint32_t dwSocket0SkillVnum = rkItemAward.dwSocket0;
-	bool bHasSkill = false;
-	for (size_t i = 0; i < vec_skillTable.size(); ++i)
-	{
-		if (vec_skillTable[i].dwVnum == dwSocket0SkillVnum)
-		{
-			bHasSkill = true;
-			break;
-		}
-	}
-
-	if (!bHasSkill)
-	{
-		do
-		{
-			const TSkillTable* pkSkillTable = &vec_skillTable.at(number(0, vec_skillTable.size() - 1));
-			if (!pkSkillTable)
-				continue;
-
-			const uint32_t dwSkillVnum = pkSkillTable->dwVnum;
-			const uint8_t bSkillType = pkSkillTable->bType;
-
-			const bool bIsPCSkill = (JOB_WARRIOR + 1 <= bSkillType && bSkillType <= JOB_SHAMAN + 1) || bSkillType == 7;
-			if (!bIsPCSkill)
-				continue;
-
-			dwSocket0SkillVnum = dwSkillVnum;
-			break;
-		} while (true);
-
-		rkItemAward.dwSocket0 = dwSocket0SkillVnum;
-	}
-}
-
-void ItemAwardManager::CheckItemCount(TItemAward& rkItemAward, const TItemTable& rkItemTable)
-{
-	const bool bIsStackableItem = (rkItemTable.dwFlags & ITEM_FLAG_STACKABLE);
-	if (rkItemAward.dwCount > 1 && !bIsStackableItem)
-		rkItemAward.dwCount = 1;
-	else
-		rkItemAward.dwCount = MINMAX(1, rkItemAward.dwCount, ITEM_MAX_COUNT);
-}
-
-void ItemAwardManager::CheckItemBlend(TItemAward& rkItemAward, const TItemTable& rkItemTable)
-{
-	const bool bIsBlendItem = (rkItemTable.bType == ITEM_BLEND);
-	if (!bIsBlendItem)
-		return;
-
-	const uint32_t bApplyType = rkItemAward.dwSocket0;
-	const uint32_t bApplyValue = rkItemAward.dwSocket1;
-	const uint32_t dwApplyDuration = rkItemAward.dwSocket2;
-
-	if (bApplyType == 0 || bApplyValue == 0 || dwApplyDuration == 0)
-		sys_err("ItemAwardManager: Unknown sockets for ITEM_BLEND.");
-}
-#endif
+#include "stdafx.h"
+#include "QID.h"
+#include "DBManager.h"
+#include "ItemAwardManager.h"
+#include "Peer.h"
+
+#include "Main.h"
+#include "ClientManager.h"
+
+#if defined(__EXTENDED_ITEM_AWARD__)
+#include <float.h>
+#include <string.h>
+
+inline double uniform_random(const double a, const double b)
+{
+	return thecore_random() / (RAND_MAX + 1.f) * (b - a) + a;
+}
+
+inline float gauss_random(const float fAverage, const float sigma)
+{
+	static bool bHasNextGaussian = false;
+	static float fNextGaussian = 0.0f;
+
+	if (bHasNextGaussian)
+	{
+		bHasNextGaussian = false;
+		return (fNextGaussian * sigma) + fAverage;
+	}
+	else
+	{
+		double v1(0), v2(0), s(0);
+		do
+		{
+			v1 = uniform_random(-1.f, 1.f);
+			v2 = uniform_random(-1.f, 1.f);
+			s = (v1 * v1) + (v2 * v2);
+		} while (s >= 1.f || fabs(s) < FLT_EPSILON);
+
+		const double multiplier = sqrtf(-2 * logf(s) / s);
+		fNextGaussian = v2 * multiplier;
+		bHasNextGaussian = true;
+		return (v1 * multiplier) * sigma + fAverage;
+	}
+}
+#endif
+
+DWORD g_dwLastCachedItemAwardID = 0;
+ItemAwardManager::ItemAwardManager()
+{
+}
+
+ItemAwardManager::~ItemAwardManager()
+{
+}
+
+void ItemAwardManager::RequestLoad()
+{
+	char szQuery[QUERY_MAX_LEN];
+#if defined(__EXTENDED_ITEM_AWARD__)
+	snprintf(szQuery, sizeof(szQuery), "SELECT `id`, `login`, `vnum`, `count`, `socket0`, `socket1`, `socket2`, "
+#if defined(__ITEM_SOCKET6__)
+		"`socket3`, "
+		"`socket4`, "
+		"`socket5`, "
+#endif
+		"`attrtype0`, `attrvalue0`, "
+		"`attrtype1`, `attrvalue1`, "
+		"`attrtype2`, `attrvalue2`, "
+		"`attrtype3`, `attrvalue3`, "
+		"`attrtype4`, `attrvalue4`, "
+		"`attrtype5`, `attrvalue5`, "
+		"`attrtype6`, `attrvalue6`, "
+		"mall, why "
+		"FROM item_award%s WHERE `taken_time` IS NULL AND `id` > %d", GetTablePostfix(), g_dwLastCachedItemAwardID);
+#else
+	snprintf(szQuery, sizeof(szQuery), "SELECT `id`, `login`, `vnum`, `count`, `socket0`, `socket1`, `socket2`, `mall`, `why` FROM item_award%s WHERE `taken_time` IS NULL AND `id` > %d", GetTablePostfix(), g_dwLastCachedItemAwardID);
+#endif
+	CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_AWARD_LOAD, 0, NULL);
+}
+
+void ItemAwardManager::Load(SQLMsg* pMsg)
+{
+	MYSQL_RES* pRes = pMsg->Get()->pSQLResult;
+
+	for (uint i = 0; i < pMsg->Get()->uiNumRows; ++i)
+	{
+		MYSQL_ROW row = mysql_fetch_row(pRes);
+		int col = 0;
+
+		DWORD dwID = 0;
+		str_to_number(dwID, row[col++]);
+
+		if (m_map_award.find(dwID) != m_map_award.end())
+			continue;
+
+		TItemAward* kData = new TItemAward;
+		memset(kData, 0, sizeof(TItemAward));
+
+		kData->dwID = dwID;
+		trim_and_lower(row[col++], kData->szLogin, sizeof(kData->szLogin));
+		str_to_number(kData->dwVnum, row[col++]);
+		str_to_number(kData->dwCount, row[col++]);
+		str_to_number(kData->dwSocket0, row[col++]);
+		str_to_number(kData->dwSocket1, row[col++]);
+		str_to_number(kData->dwSocket2, row[col++]);
+#if defined(__ITEM_SOCKET6__)
+		str_to_number(kData->dwSocket3, row[col++]);
+		str_to_number(kData->dwSocket4, row[col++]);
+		str_to_number(kData->dwSocket5, row[col++]);
+#endif
+#if defined(__EXTENDED_ITEM_AWARD__)
+		for (size_t j = 0; j < ITEM_ATTRIBUTE_MAX_NUM; j++)
+		{
+			str_to_number(kData->aAttr[j].wType, row[col++]);
+			str_to_number(kData->aAttr[j].lValue, row[col++]);
+		}
+#endif
+		str_to_number(kData->bMall, row[col++]);
+
+		if (row[col])
+		{
+			strlcpy(kData->szWhy, row[col], sizeof(kData->szWhy));
+			//  傷 why賦肉  
+			char* whyStr = kData->szWhy; // why 賦 閨
+			char cmdStr[100] = ""; // why賦肉   擔 悶 巒
+			strlcpy(cmdStr, whyStr, sizeof(cmdStr)); //    큰  큰화 풉 
+			char command[20] = "";
+			CClientManager::instance().GetCommand(cmdStr, command, sizeof(command)); // command 
+			//sys_err("%d, %s", pItemAward->dwID, command);
+			if (!(strcmp(cmdStr, "GIFT"))) // command  GIFT見
+			{
+				TPacketItemAwardInfromer giftData;
+				strlcpy(giftData.login, kData->szLogin, sizeof(giftData.login)); // 慣 絹 
+				strlcpy(giftData.command, command, sizeof(giftData.command)); //  
+				giftData.vnum = kData->dwVnum; //  vnum 
+				CClientManager::instance().ForwardPacket(HEADER_DG_ITEMAWARD_INFORMER, &giftData, sizeof(TPacketItemAwardInfromer));
+			}
+		}
+
+		m_map_award.insert(std::make_pair(dwID, kData));
+
+		printf("ITEM_AWARD load id %u bMall %d \n", kData->dwID, kData->bMall);
+		sys_log(0, "ITEM_AWARD: load id %lu login %s vnum %lu count %u socket %lu", kData->dwID, kData->szLogin, kData->dwVnum, kData->dwCount, kData->dwSocket0);
+		ItemAwardSet& kSet = m_map_kSetAwardByLogin[kData->szLogin];
+		kSet.insert(kData);
+
+		if (dwID > g_dwLastCachedItemAwardID)
+			g_dwLastCachedItemAwardID = dwID;
+	}
+}
+
+ItemAwardSet* ItemAwardManager::GetByLogin(const char* c_pszLogin)
+{
+	auto it = m_map_kSetAwardByLogin.find(c_pszLogin);
+	if (it == m_map_kSetAwardByLogin.end())
+		return NULL;
+
+	return &it->second;
+}
+
+void ItemAwardManager::Taken(DWORD dwAwardID, DWORD dwItemID)
+{
+	auto it = m_map_award.find(dwAwardID);
+	if (it == m_map_award.end())
+	{
+		sys_log(0, "ITEM_AWARD: Taken ID not exist %lu", dwAwardID);
+		return;
+	}
+
+	TItemAward* k = it->second;
+	k->bTaken = true;
+
+	//
+	// Update taken_time in database to prevent not to give him again.
+	//
+	char szQuery[QUERY_MAX_LEN];
+
+	snprintf(szQuery, sizeof(szQuery), "UPDATE item_award%s SET `taken_time` = NOW(), `item_id` = %u WHERE `id` = %u AND `taken_time` IS NULL",
+		GetTablePostfix(), dwItemID, dwAwardID);
+
+	CDBManager::instance().ReturnQuery(szQuery, QID_ITEM_AWARD_TAKEN, 0, NULL);
+}
+
+std::map<DWORD, TItemAward*>& ItemAwardManager::GetMapAward()
+{
+	return m_map_award;
+}
+
+std::map<std::string, ItemAwardSet>& ItemAwardManager::GetMapkSetAwardByLogin()
+{
+	return m_map_kSetAwardByLogin;
+}
+
+#if defined(__EXTENDED_ITEM_AWARD__)
+const int8_t ItemAwardManager::GetItemAttributeSetIndex(const uint8_t bItemType, const uint8_t bItemSubType)
+{
+	using TAttributeMapT = std::map<uint8_t, std::map<uint8_t, int8_t>>;
+	static const TAttributeMapT mapAttrSetFields =
+	{
+		{ ITEM_WEAPON,
+			{
+				{ WEAPON_ARROW, ITEM_ATTRIBUTE_NONE },
+#if defined(__QUIVER_SYSTEM__)
+				{ WEAPON_QUIVER, ITEM_ATTRIBUTE_NONE },
+#endif
+			}
+		},
+
+		{ ITEM_ARMOR,
+			{
+				{ ARMOR_BODY, ATTRIBUTE_SET_BODY },
+				{ ARMOR_WRIST, ATTRIBUTE_SET_WRIST },
+				{ ARMOR_FOOTS, ATTRIBUTE_SET_FOOTS },
+				{ ARMOR_NECK, ATTRIBUTE_SET_NECK },
+				{ ARMOR_HEAD, ATTRIBUTE_SET_HEAD },
+				{ ARMOR_SHIELD, ATTRIBUTE_SET_SHIELD },
+				{ ARMOR_EAR, ATTRIBUTE_SET_EAR },
+#if defined(__PENDANT_SYSTEM__)
+				{ ARMOR_PENDANT, ATTRIBUTE_SET_PENDANT },
+#endif
+#if defined(__GLOVE_SYSTEM__)
+				{ ARMOR_GLOVE, ATTRIBUTE_SET_GLOVE },
+#endif
+			}
+		},
+
+		{ ITEM_COSTUME,
+			{
+				{ COSTUME_BODY, ATTRIBUTE_SET_COSTUME_BODY },
+				{ COSTUME_HAIR, ATTRIBUTE_SET_COSTUME_HAIR },
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+				{ COSTUME_MOUNT, ITEM_ATTRIBUTE_NONE },
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+				{ COSTUME_ACCE, ITEM_ATTRIBUTE_NONE },
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+				{ COSTUME_WEAPON, ATTRIBUTE_SET_COSTUME_WEAPON },
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+				{ COSTUME_AURA, ITEM_ATTRIBUTE_NONE },
+#endif
+			}
+		},
+	};
+
+	const auto c_iter_type = mapAttrSetFields.find(bItemType);
+	if (c_iter_type != mapAttrSetFields.end())
+	{
+		const auto c_iter_sub_type = c_iter_type->second.find(bItemSubType);
+		if (c_iter_sub_type != c_iter_type->second.end())
+			return c_iter_sub_type->second;
+		else if (c_iter_type->first == ITEM_WEAPON)
+			return ATTRIBUTE_SET_WEAPON;
+	}
+
+	return ITEM_ATTRIBUTE_NONE;
+}
+
+void ItemAwardManager::CheckItemAttributes(TItemAward& rkItemAward, const TItemTable& rkItemTable, const std::vector<TItemAttrTable> vec_itemAttrTable)
+{
+	const BYTE bItemType = rkItemTable.bType;
+	const BYTE bItemSubType = rkItemTable.bSubType;
+	const int8_t iAttributeSet = GetItemAttributeSetIndex(bItemType, bItemSubType);
+	if (iAttributeSet != ITEM_ATTRIBUTE_NONE)
+	{
+		for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
+		{
+			const POINT_TYPE bApplyType = rkItemAward.aAttr[i].wType;
+			const bool bIsAddonTypeItem = (bApplyType == APPLY_SKILL_DAMAGE_BONUS || bApplyType == APPLY_NORMAL_HIT_DAMAGE_BONUS);
+
+			const TItemAttrTable* pkAttrTable = NULL;
+			for (size_t j = 0; j < vec_itemAttrTable.size(); ++j)
+			{
+				const TItemAttrTable& rkAttrTable = vec_itemAttrTable.at(j);
+				if (rkAttrTable.wApplyIndex == bApplyType && !bIsAddonTypeItem)
+				{
+					const uint8_t bAttrLevel = rkAttrTable.bMaxLevelBySet[iAttributeSet];
+					if (bAttrLevel > 0)
+					{
+						pkAttrTable = &rkAttrTable;
+						break;
+					}
+				}
+			}
+
+			if (pkAttrTable)
+			{
+				const POINT_VALUE llMinValue = pkAttrTable->lValues[0];
+				const POINT_VALUE llMaxValue = pkAttrTable->lValues[(sizeof(pkAttrTable->lValues) / sizeof(pkAttrTable->lValues[0])) - 1];
+				rkItemAward.aAttr[i].lValue = MINMAX(llMinValue, rkItemAward.aAttr[i].lValue, llMaxValue);
+			}
+			else if (!bIsAddonTypeItem)
+			{
+				rkItemAward.aAttr[i].wType = 0;
+				rkItemAward.aAttr[i].lValue = 0;
+			}
+		}
+	}
+}
+
+void ItemAwardManager::CheckItemAddonType(TItemAward& rkItemAward, const TItemTable& rkItemTable)
+{
+	const bool bIsAddonTypeItem = (rkItemTable.sAddonType == -1);
+	if (!bIsAddonTypeItem)
+		return;
+
+	bool bHasBonus = false;
+	for (size_t i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
+	{
+		const POINT_TYPE dwType = rkItemAward.aAttr[i].wType;
+		const POINT_VALUE llValue = rkItemAward.aAttr[i].lValue;
+
+		if ((dwType == APPLY_SKILL_DAMAGE_BONUS || dwType == APPLY_NORMAL_HIT_DAMAGE_BONUS) && llValue)
+		{
+			bHasBonus = true;
+			break;
+		}
+	}
+
+	if (!bHasBonus)
+	{
+		const POINT_VALUE llApplySkillDamageValue = MINMAX(-30, static_cast<POINT_VALUE>((gauss_random(0, 5) + 0.5f)), 30);
+		const POINT_VALUE llApplyNormalHitValue = std::abs(llApplySkillDamageValue) <= 20 ?
+			(-2 * llApplySkillDamageValue) + std::abs(number(-8, 8) + number(-8, 8)) + number(1, 4) :
+			(-2 * llApplySkillDamageValue) + number(1, 5);
+
+		rkItemAward.aAttr[0].wType = APPLY_NORMAL_HIT_DAMAGE_BONUS;
+		rkItemAward.aAttr[0].lValue = llApplyNormalHitValue;
+		rkItemAward.aAttr[1].wType = APPLY_SKILL_DAMAGE_BONUS;
+		rkItemAward.aAttr[1].lValue = llApplySkillDamageValue;
+	}
+}
+
+void ItemAwardManager::CheckItemSkillBook(TItemAward& rkItemAward, const std::vector<TSkillTable> vec_skillTable)
+{
+	const bool bIsBookItem = (rkItemAward.dwVnum == ITEM_SKILLBOOK_VNUM || rkItemAward.dwVnum == ITEM_SKILLFORGET_VNUM);
+	if (!bIsBookItem)
+		return;
+
+	uint32_t dwSocket0SkillVnum = rkItemAward.dwSocket0;
+	bool bHasSkill = false;
+	for (size_t i = 0; i < vec_skillTable.size(); ++i)
+	{
+		if (vec_skillTable[i].dwVnum == dwSocket0SkillVnum)
+		{
+			bHasSkill = true;
+			break;
+		}
+	}
+
+	if (!bHasSkill)
+	{
+		do
+		{
+			const TSkillTable* pkSkillTable = &vec_skillTable.at(number(0, vec_skillTable.size() - 1));
+			if (!pkSkillTable)
+				continue;
+
+			const uint32_t dwSkillVnum = pkSkillTable->dwVnum;
+			const uint8_t bSkillType = pkSkillTable->bType;
+
+			const bool bIsPCSkill = (JOB_WARRIOR + 1 <= bSkillType && bSkillType <= JOB_SHAMAN + 1) || bSkillType == 7;
+			if (!bIsPCSkill)
+				continue;
+
+			dwSocket0SkillVnum = dwSkillVnum;
+			break;
+		} while (true);
+
+		rkItemAward.dwSocket0 = dwSocket0SkillVnum;
+	}
+}
+
+void ItemAwardManager::CheckItemCount(TItemAward& rkItemAward, const TItemTable& rkItemTable)
+{
+	const bool bIsStackableItem = (rkItemTable.dwFlags & ITEM_FLAG_STACKABLE);
+	if (rkItemAward.dwCount > 1 && !bIsStackableItem)
+		rkItemAward.dwCount = 1;
+	else
+		rkItemAward.dwCount = MINMAX(1, rkItemAward.dwCount, ITEM_MAX_COUNT);
+}
+
+void ItemAwardManager::CheckItemBlend(TItemAward& rkItemAward, const TItemTable& rkItemTable)
+{
+	const bool bIsBlendItem = (rkItemTable.bType == ITEM_BLEND);
+	if (!bIsBlendItem)
+		return;
+
+	const uint32_t bApplyType = rkItemAward.dwSocket0;
+	const uint32_t bApplyValue = rkItemAward.dwSocket1;
+	const uint32_t dwApplyDuration = rkItemAward.dwSocket2;
+
+	if (bApplyType == 0 || bApplyValue == 0 || dwApplyDuration == 0)
+		sys_err("ItemAwardManager: Unknown sockets for ITEM_BLEND.");
+}
+#endif
diff --git a/server/metin2/Source/Server/db/src/ItemIDRangeManager.cpp b/server/metin2/Source/Server/db/src/ItemIDRangeManager.cpp
index ac5d7ed..4e7e382 100644
--- a/server/metin2/Source/Server/db/src/ItemIDRangeManager.cpp
+++ b/server/metin2/Source/Server/db/src/ItemIDRangeManager.cpp
@@ -1,165 +1,337 @@
-#include "stdafx.h"
-#include "ItemIDRangeManager.h"
-#include "Main.h"
-#include "DBManager.h"
-#include "ClientManager.h"
-#include "Peer.h"
-
-CItemIDRangeManager::CItemIDRangeManager()
-{
-	m_listData.clear();
-}
-
-void CItemIDRangeManager::Build()
-{
-	DWORD dwMin = 0;
-	DWORD dwMax = 0;
-	TItemIDRangeTable range;
-
-	for (int i = 0; ; ++i)
-	{
-		dwMin = cs_dwMinimumRange * (i + 1) + 1;
-		dwMax = cs_dwMinimumRange * (i + 2);
-
-		if (dwMax == cs_dwMaxItemID)
-			break;
-
-		if (CClientManager::instance().GetItemRange().dwMin <= dwMin &&
-			CClientManager::instance().GetItemRange().dwMax >= dwMax)
-		{
-			continue;
-		}
-
-		if (BuildRange(dwMin, dwMax, range) == true)
-		{
-			m_listData.push_back(range);
-		}
-	}
-}
-
-struct FCheckCollision
-{
-	bool hasCollision;
-	TItemIDRangeTable range;
-
-	FCheckCollision(TItemIDRangeTable data)
-	{
-		hasCollision = false;
-		range = data;
-	}
-
-	void operator() (CPeer* peer)
-	{
-		if (hasCollision == false)
-		{
-			hasCollision = peer->CheckItemIDRangeCollision(range);
-		}
-	}
-};
-
-TItemIDRangeTable CItemIDRangeManager::GetRange()
-{
-	TItemIDRangeTable ret;
-	ret.dwMin = 0;
-	ret.dwMax = 0;
-	ret.dwUsableItemIDMin = 0;
-
-	if (m_listData.size() > 0)
-	{
-		while (m_listData.size() > 0)
-		{
-			ret = m_listData.front();
-			m_listData.pop_front();
-
-			FCheckCollision f(ret);
-			CClientManager::instance().for_each_peer(f);
-
-			if (f.hasCollision == false) return ret;
-		}
-	}
-
-	for (int i = 0; i < 10; ++i)
-		sys_err("ItemIDRange: NO MORE ITEM ID RANGE");
-
-	return ret;
-}
-
-bool CItemIDRangeManager::BuildRange(DWORD dwMin, DWORD dwMax, TItemIDRangeTable& range)
-{
-	char szQuery[1024];
-	DWORD dwItemMaxID = 0;
-	SQLMsg* pMsg = NULL;
-	MYSQL_ROW row;
-
-	snprintf(szQuery, sizeof(szQuery), "SELECT MAX(id) FROM item%s WHERE id >= %u and id <= %u", GetTablePostfix(), dwMin, dwMax);
-
-	pMsg = CDBManager::instance().DirectQuery(szQuery);
-
-	if (pMsg != NULL)
-	{
-		if (pMsg->Get()->uiNumRows > 0)
-		{
-			row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-			str_to_number(dwItemMaxID, row[0]);
-		}
-		delete pMsg;
-	}
-
-	if (dwItemMaxID == 0)
-		dwItemMaxID = dwMin;
-	else
-		dwItemMaxID++;
-
-	if ((dwMax < dwItemMaxID) || (dwMax - dwItemMaxID < cs_dwMinimumRemainCount))
-	{
-		sys_log(0, "ItemIDRange: Build %u ~ %u start: %u\tNOT USE remain count is below %u",
-			dwMin, dwMax, dwItemMaxID, cs_dwMinimumRemainCount);
-	}
-	else
-	{
-		range.dwMin = dwMin;
-		range.dwMax = dwMax;
-		range.dwUsableItemIDMin = dwItemMaxID;
-
-		snprintf(szQuery, sizeof(szQuery), "SELECT COUNT(*) FROM item%s WHERE id >= %u AND id <= %u",
-			GetTablePostfix(), range.dwUsableItemIDMin, range.dwMax);
-
-		pMsg = CDBManager::instance().DirectQuery(szQuery);
-
-		if (pMsg != NULL)
-		{
-			if (pMsg->Get()->uiNumRows > 0)
-			{
-				DWORD count = 0;
-				row = mysql_fetch_row(pMsg->Get()->pSQLResult);
-				str_to_number(count, row[0]);
-				delete pMsg;
-
-				if (count > 0)
-				{
-					sys_err("ItemIDRange: Build: %u ~ %u\thave a item", range.dwUsableItemIDMin, range.dwMax);
-					return false;
-				}
-				else
-				{
-					sys_log(0, "ItemIDRange: Build: %u ~ %u start:%u", range.dwMin, range.dwMax, range.dwUsableItemIDMin);
-					return true;
-				}
-			}
-
-			delete pMsg;
-		}
-	}
-
-	return false;
-}
-
-void CItemIDRangeManager::UpdateRange(DWORD dwMin, DWORD dwMax)
-{
-	TItemIDRangeTable range;
-
-	if (BuildRange(dwMin, dwMax, range) == true)
-	{
-		m_listData.push_back(range);
-	}
-}
+#include "stdafx.h"
+#include "ItemIDRangeManager.h"
+#include "Main.h"
+#include "DBManager.h"
+#include "ClientManager.h"
+#include "Peer.h"
+
+namespace
+{
+	// Persistent range allocator (prevents duplicated ITEM ID ranges across simultaneous requests and DB restarts).
+	// Uses an atomic counter in the player DB. If the table cannot be created/used, code falls back to legacy scan-based ranges.
+	static const char* kItemIDRangeAllocatorTable = "item_id_range_allocator";
+	static const DWORD kRangeStep = 10000000UL;       // must match CItemIDRangeManager::cs_dwMinimumRange
+	static const DWORD kMaxItemID = 4290000000UL;     // must match CItemIDRangeManager::cs_dwMaxItemID
+
+	inline bool RangeOverlaps(DWORD aMin, DWORD aMax, DWORD bMin, DWORD bMax)
+	{
+		return (aMin <= bMax) && (bMin <= aMax);
+	}
+
+	DWORD GetCurrentMaxItemID()
+	{
+		char szQuery[256];
+		DWORD dwItemMaxID = 0;
+		SQLMsg* pMsg = NULL;
+		MYSQL_ROW row;
+
+		snprintf(szQuery, sizeof(szQuery), "SELECT MAX(id) FROM item%s", GetTablePostfix());
+		pMsg = CDBManager::instance().DirectQuery(szQuery);
+
+		if (pMsg != NULL)
+		{
+			if (pMsg->Get()->uiNumRows > 0)
+			{
+				row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+				str_to_number(dwItemMaxID, row[0]);
+			}
+			delete pMsg;
+		}
+
+		return dwItemMaxID;
+	}
+
+	DWORD ComputeInitialNextIndex()
+	{
+		// next_index is the next segment index to allocate (0 => first range starts at 10,000,001).
+		const DWORD dwMaxID = GetCurrentMaxItemID();
+		if (dwMaxID == 0)
+			return 0;
+
+		// Ensure next range starts after current max id (round up to the next segment).
+		return (dwMaxID - 1) / kRangeStep;
+	}
+
+	bool EnsureAllocatorTable(DWORD dwInitialNextIndex)
+	{
+		static bool s_bTried = false;
+		static bool s_bOk = false;
+
+		if (s_bTried)
+			return s_bOk;
+
+		s_bTried = true;
+
+		char szQuery[512];
+		SQLMsg* pMsg = NULL;
+
+		// InnoDB + single row counter = atomic increments via LAST_INSERT_ID().
+		snprintf(szQuery, sizeof(szQuery),
+			"CREATE TABLE IF NOT EXISTS `%s` ("
+			"`id` TINYINT UNSIGNED NOT NULL PRIMARY KEY, "
+			"`next_index` INT UNSIGNED NOT NULL"
+			") ENGINE=InnoDB",
+			kItemIDRangeAllocatorTable);
+
+		pMsg = CDBManager::instance().DirectQuery(szQuery);
+		if (!pMsg)
+			return false;
+		delete pMsg;
+
+		snprintf(szQuery, sizeof(szQuery),
+			"INSERT IGNORE INTO `%s` (`id`, `next_index`) VALUES (1, %u)",
+			kItemIDRangeAllocatorTable, dwInitialNextIndex);
+
+		pMsg = CDBManager::instance().DirectQuery(szQuery);
+		if (!pMsg)
+			return false;
+		delete pMsg;
+
+		snprintf(szQuery, sizeof(szQuery),
+			"UPDATE `%s` SET `next_index` = GREATEST(`next_index`, %u) WHERE `id` = 1",
+			kItemIDRangeAllocatorTable, dwInitialNextIndex);
+
+		pMsg = CDBManager::instance().DirectQuery(szQuery);
+		if (!pMsg)
+			return false;
+		delete pMsg;
+
+		s_bOk = true;
+		return true;
+	}
+
+	bool AllocateNextIndex(DWORD& dwOutIndex)
+	{
+		char szQuery[256];
+		SQLMsg* pMsg = NULL;
+		MYSQL_ROW row;
+
+		// Atomically increment and stash new value into LAST_INSERT_ID().
+		snprintf(szQuery, sizeof(szQuery),
+			"UPDATE `%s` SET `next_index` = LAST_INSERT_ID(`next_index` + 1) WHERE `id` = 1",
+			kItemIDRangeAllocatorTable);
+
+		pMsg = CDBManager::instance().DirectQuery(szQuery);
+		if (!pMsg)
+			return false;
+		delete pMsg;
+
+		pMsg = CDBManager::instance().DirectQuery("SELECT LAST_INSERT_ID()");
+		if (!pMsg)
+			return false;
+
+		if (pMsg->Get()->uiNumRows == 0)
+		{
+			delete pMsg;
+			return false;
+		}
+
+		row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+		DWORD dwNext = 0;
+		str_to_number(dwNext, row[0]);
+		delete pMsg;
+
+		if (dwNext == 0)
+			return false;
+
+		// dwNext is the post-increment value; allocated index is the previous value.
+		dwOutIndex = dwNext - 1;
+		return true;
+	}
+}
+
+
+CItemIDRangeManager::CItemIDRangeManager()
+{
+	m_listData.clear();
+}
+
+void CItemIDRangeManager::Build()
+{
+	DWORD dwMin = 0;
+	DWORD dwMax = 0;
+	TItemIDRangeTable range;
+
+	for (int i = 0; ; ++i)
+	{
+		dwMin = cs_dwMinimumRange * (i + 1) + 1;
+		dwMax = cs_dwMinimumRange * (i + 2);
+
+		if (dwMax == cs_dwMaxItemID)
+			break;
+
+		if (CClientManager::instance().GetItemRange().dwMin <= dwMin &&
+			CClientManager::instance().GetItemRange().dwMax >= dwMax)
+		{
+			continue;
+		}
+
+		if (BuildRange(dwMin, dwMax, range) == true)
+		{
+			m_listData.push_back(range);
+		}
+	}
+}
+
+struct FCheckCollision
+{
+	bool hasCollision;
+	TItemIDRangeTable range;
+
+	FCheckCollision(TItemIDRangeTable data)
+	{
+		hasCollision = false;
+		range = data;
+	}
+
+	void operator() (CPeer* peer)
+	{
+		if (hasCollision == false)
+		{
+			hasCollision = peer->CheckItemIDRangeCollision(range);
+		}
+	}
+};
+
+TItemIDRangeTable CItemIDRangeManager::GetRange()
+{
+	TItemIDRangeTable ret;
+	ret.dwMin = 0;
+	ret.dwMax = 0;
+	ret.dwUsableItemIDMin = 0;
+
+	// Prefer a persistent, atomic allocator table to prevent duplicated ranges across concurrent requests and DB restarts.
+	// If unavailable (permissions / older schema), fall back to the legacy scan-based allocator.
+	const DWORD dwInitialNextIndex = ComputeInitialNextIndex();
+	if (EnsureAllocatorTable(dwInitialNextIndex))
+	{
+		const TItemIDRangeTable reserved = CClientManager::instance().GetItemRange();
+
+		for (int iTries = 0; iTries < 10000; ++iTries)
+		{
+			DWORD dwIndex = 0;
+			if (!AllocateNextIndex(dwIndex))
+				break;
+
+			const uint64_t uMin = (uint64_t)kRangeStep * ((uint64_t)dwIndex + 1) + 1;
+			const uint64_t uMax = (uint64_t)kRangeStep * ((uint64_t)dwIndex + 2);
+
+			if (uMax >= (uint64_t)kMaxItemID)
+			{
+				sys_err("ITEM_ID_RANGE allocator exhausted (index=%u)", dwIndex);
+				break;
+			}
+
+			ret.dwMin = (DWORD)uMin;
+			ret.dwMax = (DWORD)uMax;
+			ret.dwUsableItemIDMin = ret.dwMin;
+
+			// Skip the DB reserved range.
+			if (reserved.dwMin != 0 && reserved.dwMax != 0 && RangeOverlaps(ret.dwMin, ret.dwMax, reserved.dwMin, reserved.dwMax))
+				continue;
+
+			return ret;
+		}
+
+		sys_err("ITEM_ID_RANGE allocator table present but allocation failed; falling back to legacy allocator");
+	}
+
+	if (m_listData.size() > 0)
+	{
+		while (m_listData.size() > 0)
+		{
+			ret = m_listData.front();
+			m_listData.pop_front();
+
+			FCheckCollision f(ret);
+			CClientManager::instance().for_each_peer(f);
+
+			if (f.hasCollision == false) return ret;
+		}
+	}
+
+	for (int i = 0; i < 10; ++i)
+		sys_err("ItemIDRange: NO MORE ITEM ID RANGE");
+
+	return ret;
+}
+
+bool CItemIDRangeManager::BuildRange(DWORD dwMin, DWORD dwMax, TItemIDRangeTable& range)
+{
+	char szQuery[1024];
+	DWORD dwItemMaxID = 0;
+	SQLMsg* pMsg = NULL;
+	MYSQL_ROW row;
+
+	snprintf(szQuery, sizeof(szQuery), "SELECT MAX(id) FROM item%s WHERE id >= %u and id <= %u", GetTablePostfix(), dwMin, dwMax);
+
+	pMsg = CDBManager::instance().DirectQuery(szQuery);
+
+	if (pMsg != NULL)
+	{
+		if (pMsg->Get()->uiNumRows > 0)
+		{
+			row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+			str_to_number(dwItemMaxID, row[0]);
+		}
+		delete pMsg;
+	}
+
+	if (dwItemMaxID == 0)
+		dwItemMaxID = dwMin;
+	else
+		dwItemMaxID++;
+
+	if ((dwMax < dwItemMaxID) || (dwMax - dwItemMaxID < cs_dwMinimumRemainCount))
+	{
+		sys_log(0, "ItemIDRange: Build %u ~ %u start: %u\tNOT USE remain count is below %u",
+			dwMin, dwMax, dwItemMaxID, cs_dwMinimumRemainCount);
+	}
+	else
+	{
+		range.dwMin = dwMin;
+		range.dwMax = dwMax;
+		range.dwUsableItemIDMin = dwItemMaxID;
+
+		snprintf(szQuery, sizeof(szQuery), "SELECT COUNT(*) FROM item%s WHERE id >= %u AND id <= %u",
+			GetTablePostfix(), range.dwUsableItemIDMin, range.dwMax);
+
+		pMsg = CDBManager::instance().DirectQuery(szQuery);
+
+		if (pMsg != NULL)
+		{
+			if (pMsg->Get()->uiNumRows > 0)
+			{
+				DWORD count = 0;
+				row = mysql_fetch_row(pMsg->Get()->pSQLResult);
+				str_to_number(count, row[0]);
+				delete pMsg;
+
+				if (count > 0)
+				{
+					sys_err("ItemIDRange: Build: %u ~ %u\thave a item", range.dwUsableItemIDMin, range.dwMax);
+					return false;
+				}
+				else
+				{
+					sys_log(0, "ItemIDRange: Build: %u ~ %u start:%u", range.dwMin, range.dwMax, range.dwUsableItemIDMin);
+					return true;
+				}
+			}
+
+			delete pMsg;
+		}
+	}
+
+	return false;
+}
+
+void CItemIDRangeManager::UpdateRange(DWORD dwMin, DWORD dwMax)
+{
+	TItemIDRangeTable range;
+
+	if (BuildRange(dwMin, dwMax, range) == true)
+	{
+		m_listData.push_back(range);
+	}
+}
diff --git a/server/metin2/Source/Server/db/src/Main.cpp b/server/metin2/Source/Server/db/src/Main.cpp
index fa86347..42fb6ba 100644
--- a/server/metin2/Source/Server/db/src/Main.cpp
+++ b/server/metin2/Source/Server/db/src/Main.cpp
@@ -1,447 +1,474 @@
-#include "stdafx.h"
-#include "Config.h"
-#include "Peer.h"
-#include "DBManager.h"
-#include "ClientManager.h"
-#include "GuildManager.h"
-#include "ItemAwardManager.h"
-#include "HB.h"
-#include "PrivManager.h"
-#include "MoneyLog.h"
-#include "Marriage.h"
-#include "Monarch.h"
-#include "BlockCountry.h"
-#include "ItemIDRangeManager.h"
-
-#include <signal.h>
-#ifdef __SHOP_SEARCH__
-#include "ShopSearchManager.h"
-#endif
-#undef __FreeBSD__
-
-#ifdef __OFFLINE_SHOP__
-uint32_t g_offlineShopCacheFlushSeconds = 60 * 10;// 60 * 10;
-uint32_t g_offlineShopItemCacheFlushSeconds = 60 * 10;// 60 * 10;
-#endif
-
-void SetPlayerDBName(const char* c_pszPlayerDBName);
-void SetTablePostfix(const char* c_pszTablePostfix);
-int Start();
-
-std::string g_stTablePostfix;
-std::string g_stLocaleNameColumn = "name";
-std::string g_stLocale = "latin1"; // euckr
-std::string g_stPlayerDBName = "";
-
-bool g_bHotBackup = false; // true
-BOOL g_test_server = false;
-
-// 단위 초
-int g_iPlayerCacheFlushSeconds = 60 * 7;
-int g_iItemCacheFlushSeconds = 60 * 5;
-
-// g_iLogoutSeconds 수치는 g_iPlayerCacheFlushSeconds 와 g_iItemCacheFlushSeconds 보다 길어야 한다.
-int g_iLogoutSeconds = 60 * 10;
-
-int g_log = 1;
-
-// MYSHOP_PRICE_LIST
-int g_iItemPriceListTableCacheFlushSeconds = 540;
-// END_OF_MYSHOP_PRICE_LIST
-
-#if defined(__FreeBSD__)
-extern "C" char* _malloc_options;
-#endif
-
-void emergency_sig(int sig)
-{
-	if (sig == SIGSEGV)
-		sys_log(0, "SIGNAL: SIGSEGV");
-	else if (sig == SIGUSR1)
-		sys_log(0, "SIGNAL: SIGUSR1");
-
-	if (sig == SIGSEGV)
-		abort();
-}
-
-int main()
-{
-	/**
-	* Fix FreeBSD compile.
-	* Is it really needed ?
-	*/
-#if defined(__FreeBSD__)
-	char* _malloc_options = "A";
-#endif
-
-	CConfig Config;
-	CNetPoller poller;
-	CDBManager DBManager;
-	CClientManager ClientManager;
-	PlayerHB player_hb;
-	CGuildManager GuildManager;
-	CPrivManager PrivManager;
-	CMoneyLog MoneyLog;
-	ItemAwardManager ItemAwardManager;
-	marriage::CManager MarriageManager;
-	CMonarch Monarch;
-	CBlockCountry BlockCountry;
-	CItemIDRangeManager ItemIDRangeManager;
-#ifdef __SHOP_SEARCH__
-	CShopSearchManager ShopSearchManager;
-#endif
-	if (!Start())
-		return 1;
-
-	GuildManager.Initialize();
-	MarriageManager.Initialize();
-	BlockCountry.Load();
-	ItemIDRangeManager.Build();
-#ifdef __SHOP_SEARCH__
-	CClientManager::instance().InitializeNextOfflineShopId();
-	ShopSearchManager.Initialize();
-#endif
-
-	sys_log(0, "Metin2DBCacheServer Start\n");
-
-	CClientManager::instance().MainLoop();
-
-	signal_timer_disable();
-
-	DBManager.Quit();
-	int iCount;
-
-	while (1)
-	{
-		iCount = 0;
-
-		iCount += CDBManager::instance().CountReturnQuery(SQL_PLAYER);
-		iCount += CDBManager::instance().CountAsyncQuery(SQL_PLAYER);
-
-		if (iCount == 0)
-			break;
-
-		usleep(1000);
-		sys_log(0, "WAITING_QUERY_COUNT %d", iCount);
-	}
-
-	return 1;
-}
-
-void emptybeat(LPHEART heart, int pulse)
-{
-	if (!(pulse % heart->passes_per_sec)) // 1초에 한번
-	{
-	}
-}
-
-//
-// @version	05/06/13 Bang2ni - 아이템 가격정보 캐시 flush timeout 설정 추가.
-//
-int Start()
-{
-	if (!CConfig::instance().LoadFile("config.txt"))
-	{
-		fprintf(stderr, "Loading config.txt failed.\n");
-		return false;
-	}
-
-	if (!CConfig::instance().GetValue("TEST_SERVER", &g_test_server))
-	{
-		fprintf(stderr, "Real Server\n");
-	}
-	else
-		fprintf(stderr, "Test Server\n");
-
-	if (!CConfig::instance().GetValue("LOG", &g_log))
-	{
-		fprintf(stderr, "Log Off");
-		g_log = 0;
-	}
-	else
-	{
-		g_log = 1;
-		fprintf(stderr, "Log On");
-	}
-
-	int tmpValue;
-
-	int heart_beat = 50;
-	if (!CConfig::instance().GetValue("CLIENT_HEART_FPS", &heart_beat))
-	{
-		fprintf(stderr, "Cannot find CLIENT_HEART_FPS configuration.\n");
-		return false;
-	}
-
-	log_set_expiration_days(3);
-
-	if (CConfig::instance().GetValue("LOG_KEEP_DAYS", &tmpValue))
-	{
-		tmpValue = MINMAX(3, tmpValue, 30);
-		log_set_expiration_days(tmpValue);
-		fprintf(stderr, "Setting log keeping days to %d\n", tmpValue);
-	}
-
-	thecore_init(heart_beat, emptybeat);
-	signal_timer_enable(60);
-
-	char szBuf[256 + 1];
-
-	if (CConfig::instance().GetValue("LOCALE", szBuf, 256))
-	{
-		g_stLocale = szBuf;
-		sys_log(0, "LOCALE set to %s", g_stLocale.c_str());
-
-		// CHINA_DISABLE_HOTBACKUP
-		if ("gb2312" == g_stLocale)
-		{
-			sys_log(0, "CIBN_LOCALE: DISABLE_HOTBACKUP");
-			g_bHotBackup = false;
-		}
-		// END_OF_CHINA_DISABLE_HOTBACKUP
-	}
-
-	int iDisableHotBackup;
-	if (CConfig::instance().GetValue("DISABLE_HOTBACKUP", &iDisableHotBackup))
-	{
-		if (iDisableHotBackup)
-		{
-			sys_log(0, "CONFIG: DISABLE_HOTBACKUP");
-			g_bHotBackup = false;
-		}
-	}
-
-	if (!CConfig::instance().GetValue("TABLE_POSTFIX", szBuf, 256))
-	{
-		sys_log(0, "TABLE_POSTFIX not configured use default");
-		szBuf[0] = '\0';
-	}
-
-	SetTablePostfix(szBuf);
-
-	if (CConfig::instance().GetValue("PLAYER_CACHE_FLUSH_SECONDS", szBuf, 256))
-	{
-		str_to_number(g_iPlayerCacheFlushSeconds, szBuf);
-		sys_log(0, "PLAYER_CACHE_FLUSH_SECONDS: %d", g_iPlayerCacheFlushSeconds);
-	}
-
-	if (CConfig::instance().GetValue("ITEM_CACHE_FLUSH_SECONDS", szBuf, 256))
-	{
-		str_to_number(g_iItemCacheFlushSeconds, szBuf);
-		sys_log(0, "ITEM_CACHE_FLUSH_SECONDS: %d", g_iItemCacheFlushSeconds);
-	}
-
-	// MYSHOP_PRICE_LIST
-	if (CConfig::instance().GetValue("ITEM_PRICELIST_CACHE_FLUSH_SECONDS", szBuf, 256))
-	{
-		str_to_number(g_iItemPriceListTableCacheFlushSeconds, szBuf);
-		sys_log(0, "ITEM_PRICELIST_CACHE_FLUSH_SECONDS: %d", g_iItemPriceListTableCacheFlushSeconds);
-	}
-	// END_OF_MYSHOP_PRICE_LIST
-
-	if (CConfig::instance().GetValue("CACHE_FLUSH_LIMIT_PER_SECOND", szBuf, 256))
-	{
-		DWORD dwVal = 0; str_to_number(dwVal, szBuf);
-		CClientManager::instance().SetCacheFlushCountLimit(dwVal);
-	}
-
-#ifdef __OFFLINE_SHOP__
-	if (CConfig::instance().GetValue("OFFLINE_SHOP_CACHE_FLUSH_SECONDS", szBuf, 256))
-	{
-		str_to_number(g_offlineShopCacheFlushSeconds, szBuf);
-		sys_log(0, "OFFLINE_SHOP_CACHE_FLUSH_SECONDS: %d", g_offlineShopCacheFlushSeconds);
-	}
-
-	if (CConfig::instance().GetValue("OFFLINE_SHOP_ITEM_CACHE_FLUSH_SECONDS", szBuf, 256))
-	{
-		str_to_number(g_offlineShopItemCacheFlushSeconds, szBuf);
-		sys_log(0, "OFFLINE_SHOP_CACHE_FLUSH_SECONDS: %d", g_offlineShopItemCacheFlushSeconds);
-	}
-#endif
-
-	int iIDStart;
-	if (!CConfig::instance().GetValue("PLAYER_ID_START", &iIDStart))
-	{
-		sys_err("PLAYER_ID_START not configured");
-		return false;
-	}
-
-	CClientManager::instance().SetPlayerIDStart(iIDStart);
-
-	if (CConfig::instance().GetValue("NAME_COLUMN", szBuf, 256))
-	{
-		fprintf(stderr, "%s %s", g_stLocaleNameColumn.c_str(), szBuf);
-		g_stLocaleNameColumn = szBuf;
-	}
-
-	char szAddr[64], szDB[64], szUser[64], szPassword[64];
-	int iPort;
-	char line[256 + 1];
-
-	if (CConfig::instance().GetValue("SQL_PLAYER", line, 256))
-	{
-		sscanf(line, " %s %s %s %s %d ", szAddr, szDB, szUser, szPassword, &iPort);
-		sys_log(0, "connecting to MySQL server (player)");
-
-		int iRetry = 5;
-
-		do
-		{
-			if (CDBManager::instance().Connect(SQL_PLAYER, szAddr, iPort, szDB, szUser, szPassword))
-			{
-				sys_log(0, "   OK");
-				break;
-			}
-
-			sys_log(0, "   failed, retrying in 5 seconds");
-			fprintf(stderr, "   failed, retrying in 5 seconds");
-			sleep(5);
-		} while (iRetry--);
-		fprintf(stderr, "Success PLAYER\n");
-		SetPlayerDBName(szDB);
-	}
-	else
-	{
-		sys_err("SQL_PLAYER not configured");
-		return false;
-	}
-
-	if (CConfig::instance().GetValue("SQL_ACCOUNT", line, 256))
-	{
-		sscanf(line, " %s %s %s %s %d ", szAddr, szDB, szUser, szPassword, &iPort);
-		sys_log(0, "connecting to MySQL server (account)");
-
-		int iRetry = 5;
-
-		do
-		{
-			if (CDBManager::instance().Connect(SQL_ACCOUNT, szAddr, iPort, szDB, szUser, szPassword))
-			{
-				sys_log(0, "   OK");
-				break;
-			}
-
-			sys_log(0, "   failed, retrying in 5 seconds");
-			fprintf(stderr, "   failed, retrying in 5 seconds");
-			sleep(5);
-		} while (iRetry--);
-		fprintf(stderr, "Success ACCOUNT\n");
-	}
-	else
-	{
-		sys_err("SQL_ACCOUNT not configured");
-		return false;
-	}
-
-	if (CConfig::instance().GetValue("SQL_COMMON", line, 256))
-	{
-		sscanf(line, " %s %s %s %s %d ", szAddr, szDB, szUser, szPassword, &iPort);
-		sys_log(0, "connecting to MySQL server (common)");
-
-		int iRetry = 5;
-
-		do
-		{
-			if (CDBManager::instance().Connect(SQL_COMMON, szAddr, iPort, szDB, szUser, szPassword))
-			{
-				sys_log(0, "   OK");
-				break;
-			}
-
-			sys_log(0, "   failed, retrying in 5 seconds");
-			fprintf(stderr, "   failed, retrying in 5 seconds");
-			sleep(5);
-		} while (iRetry--);
-		fprintf(stderr, "Success COMMON\n");
-	}
-	else
-	{
-		sys_err("SQL_COMMON not configured");
-		return false;
-	}
-
-	if (CConfig::instance().GetValue("SQL_HOTBACKUP", line, 256))
-	{
-		sscanf(line, " %s %s %s %s %d ", szAddr, szDB, szUser, szPassword, &iPort);
-		sys_log(0, "connecting to MySQL server (hotbackup)");
-
-		int iRetry = 5;
-
-		do
-		{
-			if (CDBManager::instance().Connect(SQL_HOTBACKUP, szAddr, iPort, szDB, szUser, szPassword))
-			{
-				sys_log(0, "   OK");
-				break;
-			}
-
-			sys_log(0, "   failed, retrying in 5 seconds");
-			fprintf(stderr, "   failed, retrying in 5 seconds");
-			sleep(5);
-		} while (iRetry--);
-
-		fprintf(stderr, "Success HOTBACKUP\n");
-	}
-	else
-	{
-		sys_err("SQL_HOTBACKUP not configured");
-		return false;
-	}
-
-	if (!CNetPoller::instance().Create())
-	{
-		sys_err("Cannot create network poller");
-		return false;
-	}
-
-	sys_log(0, "ClientManager initialization.. ");
-
-	if (!CClientManager::instance().Initialize())
-	{
-		sys_log(0, "   failed");
-		return false;
-	}
-
-	sys_log(0, "   OK");
-
-	if (!PlayerHB::instance().Initialize())
-	{
-		sys_err("cannot initialize player hotbackup");
-		return false;
-	}
-
-#ifndef __WIN32__
-	signal(SIGUSR1, emergency_sig);
-#endif
-	signal(SIGSEGV, emergency_sig);
-	return true;
-}
-
-void SetTablePostfix(const char* c_pszTablePostfix)
-{
-	if (!c_pszTablePostfix || !*c_pszTablePostfix)
-		g_stTablePostfix = "";
-	else
-		g_stTablePostfix = c_pszTablePostfix;
-}
-
-const char* GetTablePostfix()
-{
-	return g_stTablePostfix.c_str();
-}
-
-void SetPlayerDBName(const char* c_pszPlayerDBName)
-{
-	if (!c_pszPlayerDBName || !*c_pszPlayerDBName)
-		g_stPlayerDBName = "";
-	else
-	{
-		g_stPlayerDBName = c_pszPlayerDBName;
-		g_stPlayerDBName += ".";
-	}
-}
-
-const char* GetPlayerDBName()
-{
-	return g_stPlayerDBName.c_str();
-}
+#include "stdafx.h"
+
+#include <cctype>
+#include "Config.h"
+#include "Peer.h"
+#include "DBManager.h"
+#include "ClientManager.h"
+#include "GuildManager.h"
+#include "ItemAwardManager.h"
+#include "HB.h"
+#include "PrivManager.h"
+#include "MoneyLog.h"
+#include "Marriage.h"
+#include "Monarch.h"
+#include "BlockCountry.h"
+#include "ItemIDRangeManager.h"
+
+#include <signal.h>
+#ifdef __SHOP_SEARCH__
+#include "ShopSearchManager.h"
+#endif
+#undef __FreeBSD__
+
+#ifdef __OFFLINE_SHOP__
+uint32_t g_offlineShopCacheFlushSeconds = 60 * 10;// 60 * 10;
+uint32_t g_offlineShopItemCacheFlushSeconds = 60 * 10;// 60 * 10;
+#endif
+
+void SetPlayerDBName(const char* c_pszPlayerDBName);
+void SetTablePostfix(const char* c_pszTablePostfix);
+int Start();
+
+std::string g_stTablePostfix;
+std::string g_stLocaleNameColumn = "name";
+std::string g_stLocale = "latin1"; // euckr
+std::string g_stPlayerDBName = "";
+
+bool g_bHotBackup = false; // true
+BOOL g_test_server = false;
+
+// 占쏙옙占쏙옙 占쏙옙
+int g_iPlayerCacheFlushSeconds = 60 * 7;
+int g_iItemCacheFlushSeconds = 60 * 5;
+
+// g_iLogoutSeconds 占쏙옙치占쏙옙 g_iPlayerCacheFlushSeconds 占쏙옙 g_iItemCacheFlushSeconds 占쏙옙占쏙옙 占쏙옙占쏙옙 占싼댐옙.
+int g_iLogoutSeconds = 60 * 10;
+
+int g_log = 1;
+
+// MYSHOP_PRICE_LIST
+int g_iItemPriceListTableCacheFlushSeconds = 540;
+// END_OF_MYSHOP_PRICE_LIST
+
+#if defined(__FreeBSD__)
+extern "C" char* _malloc_options;
+#endif
+
+void emergency_sig(int sig)
+{
+	if (sig == SIGSEGV)
+		sys_log(0, "SIGNAL: SIGSEGV");
+	else if (sig == SIGUSR1)
+		sys_log(0, "SIGNAL: SIGUSR1");
+
+	if (sig == SIGSEGV)
+		abort();
+}
+
+int main()
+{
+	/**
+	* Fix FreeBSD compile.
+	* Is it really needed ?
+	*/
+#if defined(__FreeBSD__)
+	char* _malloc_options = "A";
+#endif
+
+	CConfig Config;
+	CNetPoller poller;
+	CDBManager DBManager;
+	CClientManager ClientManager;
+	PlayerHB player_hb;
+	CGuildManager GuildManager;
+	CPrivManager PrivManager;
+	CMoneyLog MoneyLog;
+	ItemAwardManager ItemAwardManager;
+	marriage::CManager MarriageManager;
+	CMonarch Monarch;
+	CBlockCountry BlockCountry;
+	CItemIDRangeManager ItemIDRangeManager;
+#ifdef __SHOP_SEARCH__
+	CShopSearchManager ShopSearchManager;
+#endif
+	if (!Start())
+		return 1;
+
+	GuildManager.Initialize();
+	MarriageManager.Initialize();
+	BlockCountry.Load();
+	ItemIDRangeManager.Build();
+#ifdef __SHOP_SEARCH__
+	CClientManager::instance().InitializeNextOfflineShopId();
+	ShopSearchManager.Initialize();
+#endif
+
+	sys_log(0, "Metin2DBCacheServer Start\n");
+
+	CClientManager::instance().MainLoop();
+
+	signal_timer_disable();
+
+	DBManager.Quit();
+	int iCount;
+
+	while (1)
+	{
+		iCount = 0;
+
+		iCount += CDBManager::instance().CountReturnQuery(SQL_PLAYER);
+		iCount += CDBManager::instance().CountAsyncQuery(SQL_PLAYER);
+
+		if (iCount == 0)
+			break;
+
+		usleep(1000);
+		sys_log(0, "WAITING_QUERY_COUNT %d", iCount);
+	}
+
+	return 1;
+}
+
+void emptybeat(LPHEART heart, int pulse)
+{
+	if (!(pulse % heart->passes_per_sec)) // 1占십울옙 占싼뱄옙
+	{
+	}
+}
+
+//
+// @version	05/06/13 Bang2ni - 占쏙옙占쏙옙占쏙옙 占쏙옙占쏙옙占쏙옙占쏙옙 캐占쏙옙 flush timeout 占쏙옙占쏙옙 占쌩곤옙.
+//
+int Start()
+{
+	if (!CConfig::instance().LoadFile("config.txt"))
+	{
+		fprintf(stderr, "Loading config.txt failed.\n");
+		return false;
+	}
+
+	if (!CConfig::instance().GetValue("TEST_SERVER", &g_test_server))
+	{
+		fprintf(stderr, "Real Server\n");
+	}
+	else
+		fprintf(stderr, "Test Server\n");
+
+	if (!CConfig::instance().GetValue("LOG", &g_log))
+	{
+		fprintf(stderr, "Log Off");
+		g_log = 0;
+	}
+	else
+	{
+		g_log = 1;
+		fprintf(stderr, "Log On");
+	}
+
+	int tmpValue;
+
+	int heart_beat = 50;
+	if (!CConfig::instance().GetValue("CLIENT_HEART_FPS", &heart_beat))
+	{
+		fprintf(stderr, "Cannot find CLIENT_HEART_FPS configuration.\n");
+		return false;
+	}
+
+	log_set_expiration_days(3);
+
+	if (CConfig::instance().GetValue("LOG_KEEP_DAYS", &tmpValue))
+	{
+		tmpValue = MINMAX(3, tmpValue, 30);
+		log_set_expiration_days(tmpValue);
+		fprintf(stderr, "Setting log keeping days to %d\n", tmpValue);
+	}
+
+	thecore_init(heart_beat, emptybeat);
+	signal_timer_enable(60);
+
+	char szBuf[256 + 1];
+
+	if (CConfig::instance().GetValue("LOCALE", szBuf, 256))
+	{
+		g_stLocale = szBuf;
+		sys_log(0, "LOCALE set to %s", g_stLocale.c_str());
+
+		// CHINA_DISABLE_HOTBACKUP
+		if ("gb2312" == g_stLocale)
+		{
+			sys_log(0, "CIBN_LOCALE: DISABLE_HOTBACKUP");
+			g_bHotBackup = false;
+		}
+		// END_OF_CHINA_DISABLE_HOTBACKUP
+	}
+
+	int iDisableHotBackup;
+	if (CConfig::instance().GetValue("DISABLE_HOTBACKUP", &iDisableHotBackup))
+	{
+		if (iDisableHotBackup)
+		{
+			sys_log(0, "CONFIG: DISABLE_HOTBACKUP");
+			g_bHotBackup = false;
+		}
+	}
+
+	if (!CConfig::instance().GetValue("TABLE_POSTFIX", szBuf, 256))
+	{
+		sys_log(0, "TABLE_POSTFIX not configured use default");
+		szBuf[0] = '\0';
+	}
+
+	SetTablePostfix(szBuf);
+
+	if (CConfig::instance().GetValue("PLAYER_CACHE_FLUSH_SECONDS", szBuf, 256))
+	{
+		str_to_number(g_iPlayerCacheFlushSeconds, szBuf);
+		sys_log(0, "PLAYER_CACHE_FLUSH_SECONDS: %d", g_iPlayerCacheFlushSeconds);
+	}
+
+	if (CConfig::instance().GetValue("ITEM_CACHE_FLUSH_SECONDS", szBuf, 256))
+	{
+		str_to_number(g_iItemCacheFlushSeconds, szBuf);
+		sys_log(0, "ITEM_CACHE_FLUSH_SECONDS: %d", g_iItemCacheFlushSeconds);
+	}
+
+	// MYSHOP_PRICE_LIST
+	if (CConfig::instance().GetValue("ITEM_PRICELIST_CACHE_FLUSH_SECONDS", szBuf, 256))
+	{
+		str_to_number(g_iItemPriceListTableCacheFlushSeconds, szBuf);
+		sys_log(0, "ITEM_PRICELIST_CACHE_FLUSH_SECONDS: %d", g_iItemPriceListTableCacheFlushSeconds);
+	}
+	// END_OF_MYSHOP_PRICE_LIST
+
+	if (CConfig::instance().GetValue("CACHE_FLUSH_LIMIT_PER_SECOND", szBuf, 256))
+	{
+		DWORD dwVal = 0; str_to_number(dwVal, szBuf);
+		CClientManager::instance().SetCacheFlushCountLimit(dwVal);
+	}
+
+#ifdef __OFFLINE_SHOP__
+	if (CConfig::instance().GetValue("OFFLINE_SHOP_CACHE_FLUSH_SECONDS", szBuf, 256))
+	{
+		str_to_number(g_offlineShopCacheFlushSeconds, szBuf);
+		sys_log(0, "OFFLINE_SHOP_CACHE_FLUSH_SECONDS: %d", g_offlineShopCacheFlushSeconds);
+	}
+
+	if (CConfig::instance().GetValue("OFFLINE_SHOP_ITEM_CACHE_FLUSH_SECONDS", szBuf, 256))
+	{
+		str_to_number(g_offlineShopItemCacheFlushSeconds, szBuf);
+		sys_log(0, "OFFLINE_SHOP_CACHE_FLUSH_SECONDS: %d", g_offlineShopItemCacheFlushSeconds);
+	}
+#endif
+
+	int iIDStart;
+	if (!CConfig::instance().GetValue("PLAYER_ID_START", &iIDStart))
+	{
+		sys_err("PLAYER_ID_START not configured");
+		return false;
+	}
+
+	CClientManager::instance().SetPlayerIDStart(iIDStart);
+
+	if (CConfig::instance().GetValue("NAME_COLUMN", szBuf, 256))
+	{
+		fprintf(stderr, "%s %s", g_stLocaleNameColumn.c_str(), szBuf);
+		g_stLocaleNameColumn = szBuf;
+	}
+
+	char szAddr[64], szDB[64], szUser[64], szPassword[64];
+	int iPort;
+	char line[256 + 1];
+
+	if (CConfig::instance().GetValue("SQL_PLAYER", line, 256))
+	{
+		sscanf(line, " %s %s %s %s %d ", szAddr, szDB, szUser, szPassword, &iPort);
+		sys_log(0, "connecting to MySQL server (player)");
+
+		int iRetry = 5;
+
+		do
+		{
+			if (CDBManager::instance().Connect(SQL_PLAYER, szAddr, iPort, szDB, szUser, szPassword))
+			{
+				sys_log(0, "   OK");
+				break;
+			}
+
+			sys_log(0, "   failed, retrying in 5 seconds");
+			fprintf(stderr, "   failed, retrying in 5 seconds");
+			sleep(5);
+		} while (iRetry--);
+		fprintf(stderr, "Success PLAYER\n");
+		SetPlayerDBName(szDB);
+	}
+	else
+	{
+		sys_err("SQL_PLAYER not configured");
+		return false;
+	}
+
+	if (CConfig::instance().GetValue("SQL_ACCOUNT", line, 256))
+	{
+		sscanf(line, " %s %s %s %s %d ", szAddr, szDB, szUser, szPassword, &iPort);
+		sys_log(0, "connecting to MySQL server (account)");
+
+		int iRetry = 5;
+
+		do
+		{
+			if (CDBManager::instance().Connect(SQL_ACCOUNT, szAddr, iPort, szDB, szUser, szPassword))
+			{
+				sys_log(0, "   OK");
+				break;
+			}
+
+			sys_log(0, "   failed, retrying in 5 seconds");
+			fprintf(stderr, "   failed, retrying in 5 seconds");
+			sleep(5);
+		} while (iRetry--);
+		fprintf(stderr, "Success ACCOUNT\n");
+	}
+	else
+	{
+		sys_err("SQL_ACCOUNT not configured");
+		return false;
+	}
+
+	if (CConfig::instance().GetValue("SQL_COMMON", line, 256))
+	{
+		sscanf(line, " %s %s %s %s %d ", szAddr, szDB, szUser, szPassword, &iPort);
+		sys_log(0, "connecting to MySQL server (common)");
+
+		int iRetry = 5;
+
+		do
+		{
+			if (CDBManager::instance().Connect(SQL_COMMON, szAddr, iPort, szDB, szUser, szPassword))
+			{
+				sys_log(0, "   OK");
+				break;
+			}
+
+			sys_log(0, "   failed, retrying in 5 seconds");
+			fprintf(stderr, "   failed, retrying in 5 seconds");
+			sleep(5);
+		} while (iRetry--);
+		fprintf(stderr, "Success COMMON\n");
+	}
+	else
+	{
+		sys_err("SQL_COMMON not configured");
+		return false;
+	}
+
+	if (CConfig::instance().GetValue("SQL_HOTBACKUP", line, 256))
+	{
+		sscanf(line, " %s %s %s %s %d ", szAddr, szDB, szUser, szPassword, &iPort);
+		sys_log(0, "connecting to MySQL server (hotbackup)");
+
+		int iRetry = 5;
+
+		do
+		{
+			if (CDBManager::instance().Connect(SQL_HOTBACKUP, szAddr, iPort, szDB, szUser, szPassword))
+			{
+				sys_log(0, "   OK");
+				break;
+			}
+
+			sys_log(0, "   failed, retrying in 5 seconds");
+			fprintf(stderr, "   failed, retrying in 5 seconds");
+			sleep(5);
+		} while (iRetry--);
+
+		fprintf(stderr, "Success HOTBACKUP\n");
+	}
+	else
+	{
+		sys_err("SQL_HOTBACKUP not configured");
+		return false;
+	}
+
+	if (!CNetPoller::instance().Create())
+	{
+		sys_err("Cannot create network poller");
+		return false;
+	}
+
+	sys_log(0, "ClientManager initialization.. ");
+
+	if (!CClientManager::instance().Initialize())
+	{
+		sys_log(0, "   failed");
+		return false;
+	}
+
+	sys_log(0, "   OK");
+
+	if (!PlayerHB::instance().Initialize())
+	{
+		sys_err("cannot initialize player hotbackup");
+		return false;
+	}
+
+#ifndef __WIN32__
+	signal(SIGUSR1, emergency_sig);
+#endif
+	signal(SIGSEGV, emergency_sig);
+	return true;
+}
+
+
+void SetTablePostfix(const char* c_pszTablePostfix)
+{
+	if (!c_pszTablePostfix)
+	{
+		g_stTablePostfix = "";
+		return;
+	}
+
+	// Security: table postfix must be short and strictly alnum/underscore to prevent SQL injection via table names.
+	// (Even if you do not expose this value to clients, config tampering should not be able to inject SQL.)
+	const size_t len = strnlen(c_pszTablePostfix, 32);
+	if (len == 0 || len > 10)
+	{
+		sys_err("Table postfix rejected (len=%zu): '%s'", len, c_pszTablePostfix);
+		g_stTablePostfix = "";
+		return;
+	}
+
+	for (size_t i = 0; i < len; ++i)
+	{
+		const unsigned char c = static_cast<unsigned char>(c_pszTablePostfix[i]);
+		if (!(isalnum(c) || c == '_'))
+		{
+			sys_err("Table postfix rejected (bad char 0x%02X): '%s'", c, c_pszTablePostfix);
+			g_stTablePostfix = "";
+			return;
+		}
+	}
+
+	g_stTablePostfix = c_pszTablePostfix;
+}
+
+const char* GetTablePostfix()
+{
+	return g_stTablePostfix.c_str();
+}
+
+void SetPlayerDBName(const char* c_pszPlayerDBName)
+{
+	if (!c_pszPlayerDBName || !*c_pszPlayerDBName)
+		g_stPlayerDBName = "";
+	else
+	{
+		g_stPlayerDBName = c_pszPlayerDBName;
+		g_stPlayerDBName += ".";
+	}
+}
+
+const char* GetPlayerDBName()
+{
+	return g_stPlayerDBName.c_str();
+}
diff --git a/server/metin2/Source/Server/db/src/ProtoReader.cpp b/server/metin2/Source/Server/db/src/ProtoReader.cpp
index d6e5940..ec2c6b8 100644
--- a/server/metin2/Source/Server/db/src/ProtoReader.cpp
+++ b/server/metin2/Source/Server/db/src/ProtoReader.cpp
@@ -1,1591 +1,1588 @@
-#include "stdafx.h"
-
-#include <math.h>
-#include "ProtoReader.h"
-
-#include "CsvReader.h"
-
-#include <sstream>
-
-using namespace std;
-
-inline string trim_left(const string& str)
-{
-	string::size_type n = str.find_first_not_of(" \t\v\n\r");
-	return n == string::npos ? str : str.substr(n, str.length());
-}
-
-inline string trim_right(const string& str)
-{
-	string::size_type n = str.find_last_not_of(" \t\v\n\r");
-	return n == string::npos ? str : str.substr(0, n + 1);
-}
-
-string trim(const string& str) { return trim_left(trim_right(str)); }
-
-static string* StringSplit(string strOrigin, string strTok)
-{
-	int cutAt; // 자르는위치
-	int index = 0; // 문자열인덱스
-	string* strResult = new string[30]; //결과return 할변수
-
-	// strTok을찾을때까지반복
-	while ((cutAt = strOrigin.find_first_of(strTok)) != strOrigin.npos)
-	{
-		if (cutAt > 0) // 자르는위치가0보다크면(성공시)
-		{
-			strResult[index++] = strOrigin.substr(0, cutAt); // 결과배열에추가
-		}
-		strOrigin = strOrigin.substr(cutAt + 1); // 원본은자른부분제외한나머지
-	}
-
-	if (strOrigin.length() > 0) // 원본이아직남았으면
-	{
-		strResult[index++] = strOrigin.substr(0, cutAt); // 나머지를결과배열에추가
-	}
-
-	for (int i = 0; i < index; i++)
-	{
-		strResult[i] = trim(strResult[i]);
-	}
-
-	return strResult; // 결과return
-}
-
-int get_Item_Type_Value(string inputString)
-{
-	string arType[] = {
-		"ITEM_NONE",
-		"ITEM_WEAPON",
-		"ITEM_ARMOR",
-		"ITEM_USE",
-		"ITEM_AUTOUSE",
-		"ITEM_MATERIAL",
-		"ITEM_SPECIAL",
-		"ITEM_TOOL",
-		"ITEM_LOTTERY",
-		"ITEM_ELK",
-		"ITEM_METIN",
-		"ITEM_CONTAINER",
-		"ITEM_FISH",
-		"ITEM_ROD",
-		"ITEM_RESOURCE",
-		"ITEM_CAMPFIRE",
-		"ITEM_UNIQUE",
-		"ITEM_SKILLBOOK",
-		"ITEM_QUEST",
-		"ITEM_POLYMORPH",
-		"ITEM_TREASURE_BOX",
-		"ITEM_TREASURE_KEY",
-		"ITEM_SKILLFORGET",
-		"ITEM_GIFTBOX",
-		"ITEM_PICK",
-		"ITEM_HAIR",
-		"ITEM_TOTEM",
-		"ITEM_BLEND",
-		"ITEM_COSTUME",
-		"ITEM_DS",
-		"ITEM_SPECIAL_DS",
-		"ITEM_EXTRACT",
-		"ITEM_SECONDARY_COIN",
-		"ITEM_RING",
-		"ITEM_BELT",
-		"ITEM_PET",
-#if defined(__MOVE_COSTUME_ATTR__)		
-		"ITEM_MEDIUM",
-#endif									
-#if defined(__GACHA_SYSTEM__)			
-		"ITEM_GACHA",
-#endif									
-		"ITEM_PASSIVE",
-		"ITEM_MERCENARY",
-		"ITEM_ALCHEMY",
-//#if defined(__SOUL_SYSTEM__)			
-		"ITEM_SOUL",
-//#endif
-	};
-
-	int retInt = -1;
-	// cout << "Type : " << typeStr << " -> ";
-	for (int j = 0; j < sizeof(arType) / sizeof(arType[0]); j++)
-	{
-		string tempString = arType[j];
-		if (inputString.find(tempString) != string::npos && tempString.find(inputString) != string::npos)
-		{
-			// cout << j << " ";
-			retInt = j;
-			break;
-		}
-	}
-	// cout << endl;
-
-	return retInt;
-}
-
-int get_Item_SubType_Value(int type_value, string inputString)
-{
-	static string arSub1[] = {
-		"WEAPON_SWORD",
-		"WEAPON_DAGGER",
-		"WEAPON_BOW",
-		"WEAPON_TWO_HANDED",
-		"WEAPON_BELL",
-		"WEAPON_FAN",
-		"WEAPON_ARROW",
-		"WEAPON_MOUNT_SPEAR",
-		"WEAPON_CLAW",
-#if defined(__QUIVER_SYSTEM__)
-		"WEAPON_QUIVER",
-#endif
-		"WEAPON_BOUQUE",
-	};
-
-	static string arSub2[] = {
-		"ARMOR_BODY",
-		"ARMOR_HEAD",
-		"ARMOR_SHIELD",
-		"ARMOR_WRIST",
-		"ARMOR_FOOTS",
-		"ARMOR_NECK",
-		"ARMOR_EAR",
-#if defined(__PENDANT_SYSTEM__)
-		"ARMOR_PENDANT",
-#endif
-#if defined(__GLOVE_SYSTEM__)
-		"ARMOR_GLOVE",
-#endif
-	};
-
-	static string arSub3[] = {
-		"USE_POTION",
-		"USE_TALISMAN",
-		"USE_TUNING",
-		"USE_MOVE",
-		"USE_TREASURE_BOX",
-		"USE_MONEYBAG",
-		"USE_BAIT",
-		"USE_ABILITY_UP",
-		"USE_AFFECT",
-		"USE_CREATE_STONE",
-		"USE_SPECIAL",
-		"USE_POTION_NODELAY",
-		"USE_CLEAR",
-		"USE_INVISIBILITY",
-		"USE_DETACHMENT",
-		"USE_BUCKET",
-		"USE_POTION_CONTINUE",
-		"USE_CLEAN_SOCKET",
-		"USE_CHANGE_ATTRIBUTE",
-		"USE_ADD_ATTRIBUTE",
-		"USE_ADD_ACCESSORY_SOCKET",
-		"USE_PUT_INTO_ACCESSORY_SOCKET",
-		"USE_ADD_ATTRIBUTE2",
-		"USE_RECIPE",
-		"USE_CHANGE_ATTRIBUTE2",
-		"USE_BIND",
-		"USE_UNBIND",
-		"USE_TIME_CHARGE_PER",
-		"USE_TIME_CHARGE_FIX",
-		"USE_PUT_INTO_BELT_SOCKET",
-		"USE_PUT_INTO_RING_SOCKET",
-#if defined(__MOVE_COSTUME_ATTR__)
-		"USE_CHANGE_COSTUME_ATTR",
-		"USE_RESET_COSTUME_ATTR",
-#endif
-		"USE_UNK_33",
-#if defined(__CHANGED_ATTR__)
-		"USE_SELECT_ATTRIBUTE",
-#endif
-		"USE_FLOWER",
-#if defined(__EXPRESSING_EMOTIONS__)
-		"USE_EMOTION_PACK",
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		"USE_ELEMENT_UPGRADE",
-		"USE_ELEMENT_DOWNGRADE",
-		"USE_ELEMENT_CHANGE",
-#endif
-		"USE_CALL",
-		"USE_POTION_TOWER",
-		"USE_POTION_NODELAY_TOWER",
-		"USE_REMOVE_AFFECT",
-		"USE_EMOTION_TOWER",
-		"USE_SECRET_DUNGEON_SCROLL",
-		"USE_OPEN_OFFLINE_SHOP",
-	};
-
-	static string arSub4[] = {
-		"AUTOUSE_POTION",
-		"AUTOUSE_ABILITY_UP",
-		"AUTOUSE_BOMB",
-		"AUTOUSE_GOLD",
-		"AUTOUSE_MONEYBAG",
-		"AUTOUSE_TREASURE_BOX",
-	};
-
-	static string arSub5[] = {
-		"MATERIAL_LEATHER",
-		"MATERIAL_BLOOD",
-		"MATERIAL_ROOT",
-		"MATERIAL_NEEDLE",
-		"MATERIAL_JEWEL",
-		"MATERIAL_DS_REFINE_NORMAL",
-		"MATERIAL_DS_REFINE_BLESSED",
-		"MATERIAL_DS_REFINE_HOLLY",
-#if defined(__DS_CHANGE_ATTR__)
-		"MATERIAL_DS_CHANGE_ATTR",
-#endif
-		"MATERIAL_PASSIVE_WEAPON",
-		"MATERIAL_PASSIVE_ARMOR",
-		"MATERIAL_PASSIVE_ACCE",
-		"MATERIAL_PASSIVE_ELEMENT",
-	};
-
-	static string arSub6[] = {
-		"SPECIAL_MAP",
-		"SPECIAL_KEY",
-		"SPECIAL_DOC",
-		"SPECIAL_SPIRIT",
-	};
-
-	static string arSub7[] = {
-		"TOOL_FISHING_ROD",
-	};
-
-	static string arSub8[] = {
-		"LOTTERY_TICKET",
-		"LOTTERY_INSTANT",
-	};
-
-	static string arSub10[] = {
-		"METIN_NORMAL",
-		"METIN_SUNGMA",
-	};
-
-	static string arSub12[] = {
-		"FISH_ALIVE",
-		"FISH_DEAD",
-	};
-
-	static string arSub14[] = {
-		"RESOURCE_FISHBONE",
-		"RESOURCE_WATERSTONEPIECE",
-		"RESOURCE_WATERSTONE",
-		"RESOURCE_BLOOD_PEARL",
-		"RESOURCE_BLUE_PEARL",
-		"RESOURCE_WHITE_PEARL",
-		"RESOURCE_BUCKET",
-		"RESOURCE_CRYSTAL",
-		"RESOURCE_GEM",
-		"RESOURCE_STONE",
-		"RESOURCE_METIN",
-		"RESOURCE_ORE",
-#if defined(__AURA_COSTUME_SYSTEM__)
-		"RESOURCE_AURA",
-#endif
-	};
-
-	static string arSub16[] = {
-		"UNIQUE_NONE",
-		"UNIQUE_BOOK",
-		"UNIQUE_SPECIAL_RIDE",
-		"UNIQUE_3",
-		"UNIQUE_4",
-		"UNIQUE_5",
-		"UNIQUE_6",
-		"UNIQUE_7",
-		"UNIQUE_8",
-		"UNIQUE_9",
-		"UNIQUE_BUNDLE",
-	};
-
-	static string arSub18[] = {
-		"QUEST_NONE",
-		"QUEST_PET_PAY",
-		"QUEST_WARP",
-		"QUEST_GEM_BAG",
-	};
-
-	static std::string arSub23[]
-	{
-		"GIFTBOX_NONE",
-		"GIFTBOX_NORMAL",
-		"GIFTBOX_SPECIAL",
-	};
-
-	static string arSub28[] = {
-		"COSTUME_BODY",
-		"COSTUME_HAIR",
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-		"COSTUME_MOUNT",
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		"COSTUME_ACCE",
-#endif
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-		"COSTUME_WEAPON",
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-		"COSTUME_AURA",
-#endif
-	};
-
-	static string arSub29[] = {
-		"DS_SLOT1",
-		"DS_SLOT2",
-		"DS_SLOT3",
-		"DS_SLOT4",
-		"DS_SLOT5",
-		"DS_SLOT6",
-#if defined(__DS_7_SLOT__)
-		"DS_SLOT7",
-#endif
-	};
-
-	static string arSub31[] = {
-		"EXTRACT_DRAGON_SOUL",
-		"EXTRACT_DRAGON_HEART",
-	};
-
-//#ifdef __GROWTH_PET_SYSTEM__
-	static string arSub35[] = {
-	"PET_EGG",
-	"PET_UPBRINGING",
-	"PET_BAG",
-	"PET_FEEDSTUFF",
-	"PET_SKILL",
-	"PET_SKILL_DEL_BOOK",
-	"PET_NAME_CHANGE",
-	"PET_EXPFOOD",
-	"PET_SKILL_ALL_DEL_BOOK",
-	"PET_EXPFOOD_PER",
-	"PET_ATTR_DETERMINE",
-	"PET_ATTR_CHANGE",
-	"PET_PAY",
-	"PET_PRIMIUM_FEEDSTUFF",
-	};
-//#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-	static string arSub36[] = {
-		"MEDIUM_MOVE_COSTUME_ATTR",
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		"MEDIUM_MOVE_ACCE_ATTR",
-#endif
-	};
-#endif
-
-#if defined(__GACHA_SYSTEM__)
-	static string arSub37[] = {
-		"USE_GACHA",
-#if defined(__LUCKY_BOX__)
-		"GEM_LUCKY_BOX_GACHA",
-		"SPECIAL_LUCKY_BOX_GACHA",
-#endif
-	};
-#endif
-
-	static std::string arSub38[]
-	{
-		"PASSIVE_JOB",
-	};
-
-	static string arSub39[] = {
-		"MERCENARY_0",
-		"MERCENARY_1",
-		"MERCENARY_2",
-		"MERCENARY_3",
-		"MERCENARY_4",
-		"MERCENARY_5",
-		"MERCENARY_6",
-	};
-
-	static std::string arSub40[]
-	{
-		"ARMOR",
-		"WEAPON",
-		"ACCESSORY",
-		"BELT",
-		"EVENT",
-		"ETC",
-		"JOB",
-		"SETADD_WEAPON",
-		"SETADD_ARMOR_BODY",
-		"SETADD_ARMOR_HELMET",
-		"PET",
-		"SKILL_BOOK",
-		"GLOVE",
-	};
-
-//#if defined(__SOUL_SYSTEM__)
-	static string arSub41[] = {
-		"SOUL_RED",
-		"SOUL_BLUE"
-	};
-//#endif
-
-	static string* arSubType[] = {
-		0,			// ITEM_NONE
-		arSub1,		// ITEM_WEAPON
-		arSub2,		// ITEM_ARMOR
-		arSub3,		// ITEM_USE
-		arSub4,		// ITEM_AUTOUSE
-		arSub5,		// ITEM_MATERIAL
-		arSub6,		// ITEM_SPECIAL
-		arSub7,		// ITEM_TOOL
-		arSub8,		// ITEM_LOTTERY
-		0,			// ITEM_ELK
-		arSub10,	// ITEM_METIN
-		0,			// ITEM_CONTAINER
-		arSub12,	// ITEM_FISH
-		0,			// ITEM_ROD
-		arSub14,	// ITEM_RESOURCE
-		0,			// ITEM_CAMPFIRE
-		arSub16,	// ITEM_UNIQUE
-		0,			// ITEM_SKILLBOOK
-		arSub18,	// ITEM_QUEST
-		0,			// ITEM_POLYMORPH
-		0,			// ITEM_TREASURE_BOX
-		0,			// ITEM_TREASURE_KEY
-		0,			// ITEM_SKILLFORGET
-		arSub23,	// ITEM_GIFTBOX
-		0,			// ITEM_PICK
-		0,			// ITEM_HAIR
-		0,			// ITEM_TOTEM
-		0,			// ITEM_BLEND
-		arSub28,	// ITEM_COSTUME
-		arSub29,	// ITEM_DS
-		arSub29,	// ITEM_SPECIAL_DS
-		arSub31,	// ITEM_EXTRACT
-		0,			// ITEM_SECONDARY_COIN
-		0,			// ITEM_RING
-		0,			// ITEM_BELT
-//#ifdef __GROWTH_PET_SYSTEM__
-		arSub35,	// ITEM_PET
-//#endif
-#if defined(__MOVE_COSTUME_ATTR__)
-		arSub36,	// ITEM_MEDIUM
-#endif
-#if defined(__GACHA_SYSTEM__)
-		arSub37,	// ITEM_GACHA
-#endif
-		arSub38,	// ITEM_PASSIVE
-		arSub39,	// ITEM_MERCENARY
-		arSub40,	// ITEM_ALCHEMY
-//#if defined(__SOUL_SYSTEM__)
-		arSub41,	// ITEM_SOUL
-//#endif
-	};
-
-	static int arNumberOfSubtype[_countof(arSubType)] = {
-		0,										// ITEM_NONE
-		sizeof(arSub1) / sizeof(arSub1[0]),		// ITEM_WEAPON
-		sizeof(arSub2) / sizeof(arSub2[0]),		// ITEM_ARMOR
-		sizeof(arSub3) / sizeof(arSub3[0]),		// ITEM_USE
-		sizeof(arSub4) / sizeof(arSub4[0]),		// ITEM_AUTOUSE
-		sizeof(arSub5) / sizeof(arSub5[0]),		// ITEM_MATERIAL
-		sizeof(arSub6) / sizeof(arSub6[0]),		// ITEM_SPECIAL
-		sizeof(arSub7) / sizeof(arSub7[0]),		// ITEM_TOOL
-		sizeof(arSub8) / sizeof(arSub8[0]),		// ITEM_LOTTERY
-		0,										// ITEM_ELK
-		sizeof(arSub10) / sizeof(arSub10[0]),	// ITEM_METIN
-		0,										// ITEM_CONTAINER
-		sizeof(arSub12) / sizeof(arSub12[0]),	// ITEM_FISH
-		0,										// ITEM_ROD
-		sizeof(arSub14) / sizeof(arSub14[0]),	// ITEM_RESOURCE
-		0,										// ITEM_CAMPFIRE
-		sizeof(arSub16) / sizeof(arSub16[0]),	// ITEM_UNIQUE
-		0,										// ITEM_SKILLBOOK
-		sizeof(arSub18) / sizeof(arSub18[0]),	// ITEM_QUEST
-		0,										// ITEM_POLYMORPH
-		0,										// ITEM_TREASURE_BOX
-		0,										// ITEM_TREASURE_KEY
-		0,										// ITEM_SKILLFORGET
-		sizeof(arSub23) / sizeof(arSub23[0]),	// ITEM_GIFTBOX
-		0,										// ITEM_PICK
-		0,										// ITEM_HAIR
-		0,										// ITEM_TOTEM
-		0,										// ITEM_BLEND
-		sizeof(arSub28) / sizeof(arSub28[0]),	// ITEM_COSTUME
-		sizeof(arSub29) / sizeof(arSub29[0]),	// ITEM_DS
-		sizeof(arSub29) / sizeof(arSub29[0]),	// ITEM_SPECIAL_DS
-		sizeof(arSub31) / sizeof(arSub31[0]),	// ITEM_EXTRACT
-		0,										// ITEM_SECONDARY_COIN
-		0,										// ITEM_RING
-		0,										// ITEM_BELT
-		sizeof(arSub35) / sizeof(arSub35[0]),	// ITEM_PET
-#if defined(__MOVE_COSTUME_ATTR__)
-		sizeof(arSub36) / sizeof(arSub36[0]),	// ITEM_MEDIUM
-#endif
-#if defined(__GACHA_SYSTEM__)
-		sizeof(arSub37) / sizeof(arSub37[0]),	// ITEM_GACHA
-#endif
-		sizeof(arSub38) / sizeof(arSub38[0]),	// ITEM_PASSIVE
-		sizeof(arSub39) / sizeof(arSub39[0]),	// ITEM_MERCENARY
-		sizeof(arSub40) / sizeof(arSub40[0]),	// ITEM_ALCHEMY
-//#if defined(__SOUL_SYSTEM__)
-		sizeof(arSub41) / sizeof(arSub41[0]),	// ITEM_SOUL
-//#endif
-	};
-
-	assert(_countof(arSubType) > type_value && "Subtype rule: Out of range!!");
-
-	// assert 안 먹히는 듯..
-	if (_countof(arSubType) <= type_value)
-	{
-		sys_err("SubType : Out of range!! (type_value: %d, count of registered subtype: %d", type_value, _countof(arSubType));
-		return -1;
-	}
-
-	// 아이템 타입의 서브타입 어레이가 존재하는지 알아보고, 없으면 0 리턴
-	if (arSubType[type_value] == 0)
-		return 0;
-	//
-
-	int retInt = -1;
-	// cout << "SubType : " << subTypeStr << " -> ";
-	for (int j = 0; j < arNumberOfSubtype[type_value]; j++)
-	{
-		string tempString = arSubType[type_value][j];
-		string tempInputString = trim(inputString);
-		if (tempInputString.compare(tempString) == 0)
-		{
-			// cout << j << " ";
-			retInt = j;
-			break;
-		}
-	}
-	// cout << endl;
-
-	return retInt;
-}
-
-int get_Item_AntiFlag_Value(string inputString)
-{
-	string arAntiFlag[] = {
-		"ANTI_FEMALE",
-		"ANTI_MALE",
-		"ANTI_MUSA",
-		"ANTI_ASSASSIN",
-		"ANTI_SURA",
-		"ANTI_MUDANG",
-		"ANTI_GET",
-		"ANTI_DROP",
-		"ANTI_SELL",
-		"ANTI_EMPIRE_A",
-		"ANTI_EMPIRE_B",
-		"ANTI_EMPIRE_C",
-		"ANTI_SAVE",
-		"ANTI_GIVE",
-		"ANTI_PKDROP",
-		"ANTI_STACK",
-		"ANTI_MYSHOP",
-		"ANTI_SAFEBOX",
-		"ANTI_WOLFMAN",
-		"ANTI_RT_REMOVE",
-		"ANTI_QUICKSLOT",
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		"ANTI_CHANGELOOK",
-#endif
-		"ANTI_REINFORCE",
-		"ANTI_ENCHANT",
-		"ANTI_ENERGY",
-//#if defined(__GROWTH_PET_SYSTEM__)
-		"ANTI_PETFEED",
-//#endif
-		"ANTI_APPLY",
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		"ANTI_ACCE",
-#endif
-#if defined(__MAILBOX__)
-		"ANTI_MAIL",
-#endif
-		"ANTI_DESTROY" // Custom
-	};
-
-	int retValue = 0;
-	string* arInputString = StringSplit(inputString, "|"); // 프로토 정보 내용을 단어별로 쪼갠 배열.
-	for (int i = 0; i < sizeof(arAntiFlag) / sizeof(arAntiFlag[0]); i++)
-	{
-		string tempString = arAntiFlag[i];
-		for (int j = 0; j < 30; j++) // 최대 30개 단어까지. (하드코딩)
-		{
-			string tempString2 = arInputString[j];
-			if (tempString2.compare(tempString) == 0) // 일치하는지 확인.
-			{
-				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
-			}
-
-			if (tempString2.compare("") == 0)
-				break;
-		}
-	}
-	delete[]arInputString;
-	// cout << "AntiFlag : " << antiFlagStr << " -> " << retValue << endl;
-
-	return retValue;
-}
-
-int get_Item_Flag_Value(string inputString)
-{
-	string arFlag[] = {
-		"ITEM_TUNABLE",
-		"ITEM_SAVE",
-		"ITEM_STACKABLE",
-		"COUNT_PER_1GOLD",
-		"ITEM_SLOW_QUERY",
-		"ITEM_UNIQUE",
-		"ITEM_MAKECOUNT",
-		"ITEM_IRREMOVABLE",
-		"CONFIRM_WHEN_USE",
-		"QUEST_USE",
-		"QUEST_USE_MULTIPLE",
-		"QUEST_GIVE",
-		"LOG",
-		"ITEM_APPLICABLE",
-	};
-
-	int retValue = 0;
-	string* arInputString = StringSplit(inputString, "|"); // 프로토 정보 내용을 단어별로 쪼갠 배열.
-	for (int i = 0; i < sizeof(arFlag) / sizeof(arFlag[0]); i++)
-	{
-		string tempString = arFlag[i];
-		for (int j = 0; j < 30; j++) // 최대 30개 단어까지. (하드코딩)
-		{
-			string tempString2 = arInputString[j];
-			if (tempString2.compare(tempString) == 0) // 일치하는지 확인.
-			{
-				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
-			}
-
-			if (tempString2.compare("") == 0)
-				break;
-		}
-	}
-	delete[]arInputString;
-	// cout << "Flag : " << flagStr << " -> " << retValue << endl;
-
-	return retValue;
-}
-
-int get_Item_WearFlag_Value(string inputString)
-{
-	// @ EItemWearableFlag
-	string arWearrFlag[] = {
-		"WEAR_BODY",
-		"WEAR_HEAD",
-		"WEAR_FOOTS",
-		"WEAR_WRIST",
-		"WEAR_WEAPON",
-		"WEAR_NECK",
-		"WEAR_EAR",
-		"WEAR_UNIQUE",
-		"WEAR_SHIELD",
-		"WEAR_ARROW",
-		"WEAR_HAIR",
-#if defined(__PENDANT_SYSTEM__)
-		"WEAR_PENDANT",
-#endif
-#if defined(__GLOVE_SYSTEM__)
-		"WEAR_GLOVE",
-#endif
-	};
-
-	int retValue = 0;
-	string* arInputString = StringSplit(inputString, "|"); // 프로토 정보 내용을 단어별로 쪼갠 배열.
-	for (int i = 0; i < sizeof(arWearrFlag) / sizeof(arWearrFlag[0]); i++)
-	{
-		string tempString = arWearrFlag[i];
-		for (int j = 0; j < 30; j++) // 최대 30개 단어까지. (하드코딩)
-		{
-			string tempString2 = arInputString[j];
-			if (tempString2.compare(tempString) == 0) // 일치하는지 확인.
-			{
-				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
-			}
-
-			if (tempString2.compare("") == 0)
-				break;
-		}
-	}
-	delete[]arInputString;
-	// cout << "WearFlag : " << wearFlagStr << " -> " << retValue << endl;
-
-	return retValue;
-}
-
-int get_Item_Immune_Value(string inputString)
-{
-	string arImmune[] = {
-		"PARA",
-		"CURSE",
-		"STUN",
-		"SLEEP",
-		"SLOW",
-		"POISON",
-		"TERROR",
-	};
-
-	int retValue = 0;
-	string* arInputString = StringSplit(inputString, "|"); //프로토 정보 내용을 단어별로 쪼갠 배열.
-	for (int i = 0; i < sizeof(arImmune) / sizeof(arImmune[0]); i++)
-	{
-		string tempString = arImmune[i];
-		for (int j = 0; j < 30; j++) // 최대 30개 단어까지. (하드코딩)
-		{
-			string tempString2 = arInputString[j];
-			if (tempString2.compare(tempString) == 0) // 일치하는지 확인.
-			{
-				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
-			}
-
-			if (tempString2.compare("") == 0)
-				break;
-		}
-	}
-	delete[]arInputString;
-	// cout << "Immune : " << immuneStr << " -> " << retValue << endl;
-
-	return retValue;
-}
-
-int get_Item_LimitType_Value(string inputString)
-{
-	string arLimitType[] = {
-		"LIMIT_NONE",
-		"LEVEL",
-		"STR",
-		"DEX",
-		"INT",
-		"CON",
-		"REAL_TIME",
-		"REAL_TIME_FIRST_USE",
-		"TIMER_BASED_ON_WEAR",
-		"NEWWORLD_LEVEL",
-		"DURATION",
-	};
-
-	int retInt = -1;
-	// cout << "LimitType : " << limitTypeStr << " -> ";
-	for (int j = 0; j < sizeof(arLimitType) / sizeof(arLimitType[0]); j++)
-	{
-		string tempString = arLimitType[j];
-		string tempInputString = trim(inputString);
-		if (tempInputString.compare(tempString) == 0)
-		{
-			// cout << j << " ";
-			retInt = j;
-			break;
-		}
-	}
-	// cout << endl;
-
-	return retInt;
-}
-
-int get_Item_ApplyType_Value(string inputString)
-{
-	string arApplyType[] = {
-		"APPLY_NONE",
-		"APPLY_MAX_HP",
-		"APPLY_MAX_SP",
-		"APPLY_CON",
-		"APPLY_INT",
-		"APPLY_STR",
-		"APPLY_DEX",
-		"APPLY_ATT_SPEED",
-		"APPLY_MOV_SPEED",
-		"APPLY_CAST_SPEED",
-		"APPLY_HP_REGEN",
-		"APPLY_SP_REGEN",
-		"APPLY_POISON_PCT",
-		"APPLY_STUN_PCT",
-		"APPLY_SLOW_PCT",
-		"APPLY_CRITICAL_PCT",
-		"APPLY_PENETRATE_PCT",
-		"APPLY_ATTBONUS_HUMAN",
-		"APPLY_ATTBONUS_ANIMAL",
-		"APPLY_ATTBONUS_ORC",
-		"APPLY_ATTBONUS_MILGYO",
-		"APPLY_ATTBONUS_UNDEAD",
-		"APPLY_ATTBONUS_DEVIL",
-		"APPLY_STEAL_HP",
-		"APPLY_STEAL_SP",
-		"APPLY_MANA_BURN_PCT",
-		"APPLY_DAMAGE_SP_RECOVER",
-		"APPLY_BLOCK",
-		"APPLY_DODGE",
-		"APPLY_RESIST_SWORD",
-		"APPLY_RESIST_TWOHAND",
-		"APPLY_RESIST_DAGGER",
-		"APPLY_RESIST_BELL",
-		"APPLY_RESIST_FAN",
-		"APPLY_RESIST_BOW",
-		"APPLY_RESIST_FIRE",
-		"APPLY_RESIST_ELEC",
-		"APPLY_RESIST_MAGIC",
-		"APPLY_RESIST_WIND",
-		"APPLY_REFLECT_MELEE",
-		"APPLY_REFLECT_CURSE",
-		"APPLY_POISON_REDUCE",
-		"APPLY_KILL_SP_RECOVER",
-		"APPLY_EXP_DOUBLE_BONUS",
-		"APPLY_GOLD_DOUBLE_BONUS",
-		"APPLY_ITEM_DROP_BONUS",
-		"APPLY_POTION_BONUS",
-		"APPLY_KILL_HP_RECOVER",
-		"APPLY_IMMUNE_STUN",
-		"APPLY_IMMUNE_SLOW",
-		"APPLY_IMMUNE_FALL",
-		"APPLY_SKILL",
-		"APPLY_BOW_DISTANCE",
-		"APPLY_ATT_GRADE_BONUS",
-		"APPLY_DEF_GRADE_BONUS",
-		"APPLY_MAGIC_ATT_GRADE",
-		"APPLY_MAGIC_DEF_GRADE",
-		"APPLY_CURSE_PCT",
-		"APPLY_MAX_STAMINA",
-		"APPLY_ATTBONUS_WARRIOR",
-		"APPLY_ATTBONUS_ASSASSIN",
-		"APPLY_ATTBONUS_SURA",
-		"APPLY_ATTBONUS_SHAMAN",
-		"APPLY_ATTBONUS_MONSTER",
-		"APPLY_MALL_ATTBONUS",
-		"APPLY_MALL_DEFBONUS",
-		"APPLY_MALL_EXPBONUS",
-		"APPLY_MALL_ITEMBONUS",
-		"APPLY_MALL_GOLDBONUS",
-		"APPLY_MAX_HP_PCT",
-		"APPLY_MAX_SP_PCT",
-		"APPLY_SKILL_DAMAGE_BONUS",
-		"APPLY_NORMAL_HIT_DAMAGE_BONUS",
-		"APPLY_SKILL_DEFEND_BONUS",
-		"APPLY_NORMAL_HIT_DEFEND_BONUS",
-		"APPLY_PC_BANG_EXP_BONUS",
-		"APPLY_PC_BANG_DROP_BONUS",
-		"APPLY_EXTRACT_HP_PCT",
-		"APPLY_RESIST_WARRIOR",
-		"APPLY_RESIST_ASSASSIN",
-		"APPLY_RESIST_SURA",
-		"APPLY_RESIST_SHAMAN",
-		"APPLY_ENERGY",
-		"APPLY_DEF_GRADE",
-		"APPLY_COSTUME_ATTR_BONUS",
-		"APPLY_MAGIC_ATTBONUS_PER",
-		"APPLY_MELEE_MAGIC_ATTBONUS_PER",
-		"APPLY_RESIST_ICE",
-		"APPLY_RESIST_EARTH",
-		"APPLY_RESIST_DARK",
-		"APPLY_ANTI_CRITICAL_PCT",
-		"APPLY_ANTI_PENETRATE_PCT",
-		"APPLY_BLEEDING_REDUCE",
-		"APPLY_BLEEDING_PCT",
-		"APPLY_ATTBONUS_WOLFMAN",
-		"APPLY_RESIST_WOLFMAN",
-		"APPLY_RESIST_CLAW",
-		"APPLY_ACCEDRAIN_RATE",
-		"APPLY_RESIST_MAGIC_REDUCTION",
-		"APPLY_ENCHANT_ELECT",
-		"APPLY_ENCHANT_FIRE",
-		"APPLY_ENCHANT_ICE",
-		"APPLY_ENCHANT_WIND",
-		"APPLY_ENCHANT_EARTH",
-		"APPLY_ENCHANT_DARK",
-		"APPLY_ATTBONUS_CZ",
-		"APPLY_ATTBONUS_INSECT",
-		"APPLY_ATTBONUS_DESERT",
-		"APPLY_ATTBONUS_SWORD",
-		"APPLY_ATTBONUS_TWOHAND",
-		"APPLY_ATTBONUS_DAGGER",
-		"APPLY_ATTBONUS_BELL",
-		"APPLY_ATTBONUS_FAN",
-		"APPLY_ATTBONUS_BOW",
-		"APPLY_ATTBONUS_CLAW",
-		"APPLY_RESIST_HUMAN",
-		"APPLY_RESIST_MOUNT_FALL",
-		"APPLY_RESIST_FIST",
-		"APPLY_MOUNT",
-		"APPLY_SKILL_DAMAGE_SAMYEON",
-		"APPLY_SKILL_DAMAGE_TANHWAN",
-		"APPLY_SKILL_DAMAGE_PALBANG",
-		"APPLY_SKILL_DAMAGE_GIGONGCHAM",
-		"APPLY_SKILL_DAMAGE_GYOKSAN",
-		"APPLY_SKILL_DAMAGE_GEOMPUNG",
-		"APPLY_SKILL_DAMAGE_AMSEOP",
-		"APPLY_SKILL_DAMAGE_GUNGSIN",
-		"APPLY_SKILL_DAMAGE_CHARYUN",
-		"APPLY_SKILL_DAMAGE_SANGONG",
-		"APPLY_SKILL_DAMAGE_YEONSA",
-		"APPLY_SKILL_DAMAGE_KWANKYEOK",
-		"APPLY_SKILL_DAMAGE_GIGUNG",
-		"APPLY_SKILL_DAMAGE_HWAJO",
-		"APPLY_SKILL_DAMAGE_SWAERYUNG",
-		"APPLY_SKILL_DAMAGE_YONGKWON",
-		"APPLY_SKILL_DAMAGE_PABEOB",
-		"APPLY_SKILL_DAMAGE_MARYUNG",
-		"APPLY_SKILL_DAMAGE_HWAYEOMPOK",
-		"APPLY_SKILL_DAMAGE_MAHWAN",
-		"APPLY_SKILL_DAMAGE_BIPABU",
-		"APPLY_SKILL_DAMAGE_YONGBI",
-		"APPLY_SKILL_DAMAGE_PAERYONG",
-		"APPLY_SKILL_DAMAGE_NOEJEON",
-		"APPLY_SKILL_DAMAGE_BYEURAK",
-		"APPLY_SKILL_DAMAGE_CHAIN",
-		"APPLY_SKILL_DAMAGE_CHAYEOL",
-		"APPLY_SKILL_DAMAGE_SALPOONG",
-		"APPLY_SKILL_DAMAGE_GONGDAB",
-		"APPLY_SKILL_DAMAGE_PASWAE",
-		"APPLY_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE",
-		"APPLY_SKILL_DEFEND_BONUS_BOSS_OR_MORE",
-		"APPLY_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE",
-		"APPLY_SKILL_DAMAGE_BONUS_BOSS_OR_MORE",
-		"APPLY_HIT_BUFF_ENCHANT_FIRE",
-		"APPLY_HIT_BUFF_ENCHANT_ICE",
-		"APPLY_HIT_BUFF_ENCHANT_ELEC",
-		"APPLY_HIT_BUFF_ENCHANT_WIND",
-		"APPLY_HIT_BUFF_ENCHANT_DARK",
-		"APPLY_HIT_BUFF_ENCHANT_EARTH",
-		"APPLY_HIT_BUFF_RESIST_FIRE",
-		"APPLY_HIT_BUFF_RESIST_ICE",
-		"APPLY_HIT_BUFF_RESIST_ELEC",
-		"APPLY_HIT_BUFF_RESIST_WIND",
-		"APPLY_HIT_BUFF_RESIST_DARK",
-		"APPLY_HIT_BUFF_RESIST_EARTH",
-		"APPLY_USE_SKILL_CHEONGRANG_MOV_SPEED",
-		"APPLY_USE_SKILL_CHEONGRANG_CASTING_SPEED",
-		"APPLY_USE_SKILL_CHAYEOL_CRITICAL_PCT",
-		"APPLY_USE_SKILL_SANGONG_ATT_GRADE_BONUS",
-		"APPLY_USE_SKILL_GIGUNG_ATT_GRADE_BONUS",
-		"APPLY_USE_SKILL_JEOKRANG_DEF_BONUS",
-		"APPLY_USE_SKILL_GWIGEOM_DEF_BONUS",
-		"APPLY_USE_SKILL_TERROR_ATT_GRADE_BONUS",
-		"APPLY_USE_SKILL_MUYEONG_ATT_GRADE_BONUS",
-		"APPLY_USE_SKILL_MANASHILED_CASTING_SPEED",
-		"APPLY_USE_SKILL_HOSIN_DEF_BONUS",
-		"APPLY_USE_SKILL_GICHEON_ATT_GRADE_BONUS",
-		"APPLY_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS",
-		"APPLY_USE_SKILL_JEUNGRYEOK_DEF_BONUS",
-		"APPLY_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS",
-		"APPLY_USE_SKILL_CHUNKEON_CASTING_SPEED",
-		"APPLY_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS",
-		"APPLY_SKILL_DURATION_INCREASE_EUNHYUNG",
-		"APPLY_SKILL_DURATION_INCREASE_GYEONGGONG",
-		"APPLY_SKILL_DURATION_INCREASE_GEOMKYUNG",
-		"APPLY_SKILL_DURATION_INCREASE_JEOKRANG",
-		"APPLY_USE_SKILL_PALBANG_HP_ABSORB",
-		"APPLY_USE_SKILL_AMSEOP_HP_ABSORB",
-		"APPLY_USE_SKILL_YEONSA_HP_ABSORB",
-		"APPLY_USE_SKILL_YONGBI_HP_ABSORB",
-		"APPLY_USE_SKILL_CHAIN_HP_ABSORB",
-		"APPLY_USE_SKILL_PASWAE_SP_ABSORB",
-		"APPLY_USE_SKILL_GIGONGCHAM_STUN",
-		"APPLY_USE_SKILL_CHARYUN_STUN",
-		"APPLY_USE_SKILL_PABEOB_STUN",
-		"APPLY_USE_SKILL_MAHWAN_STUN",
-		"APPLY_USE_SKILL_GONGDAB_STUN",
-		"APPLY_USE_SKILL_SAMYEON_STUN",
-		"APPLY_USE_SKILL_GYOKSAN_KNOCKBACK",
-		"APPLY_USE_SKILL_SEOMJEON_KNOCKBACK",
-		"APPLY_USE_SKILL_SWAERYUNG_KNOCKBACK",
-		"APPLY_USE_SKILL_HWAYEOMPOK_KNOCKBACK",
-		"APPLY_USE_SKILL_GONGDAB_KNOCKBACK",
-		"APPLY_USE_SKILL_KWANKYEOK_KNOCKBACK",
-		"APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER",
-		"APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER",
-		"APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER",
-		"APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER",
-		"APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER",
-		"APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER",
-		"APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER",
-		"APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER",
-		"APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER",
-		"APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER",
-		"APPLY_ATTBONUS_STONE",
-		"APPLY_DAMAGE_HP_RECOVERY",
-		"APPLY_DAMAGE_SP_RECOVERY",
-		"APPLY_ALIGNMENT_DAMAGE_BONUS",
-		"APPLY_NORMAL_DAMAGE_GUARD",
-		"APPLY_MORE_THEN_HP90_DAMAGE_REDUCE",
-		"APPLY_USE_SKILL_TUSOK_HP_ABSORB",
-		"APPLY_USE_SKILL_PAERYONG_HP_ABSORB",
-		"APPLY_USE_SKILL_BYEURAK_HP_ABSORB",
-		"APPLY_FIRST_ATTRIBUTE_BONUS",
-		"APPLY_SECOND_ATTRIBUTE_BONUS",
-		"APPLY_THIRD_ATTRIBUTE_BONUS",
-		"APPLY_FOURTH_ATTRIBUTE_BONUS",
-		"APPLY_FIFTH_ATTRIBUTE_BONUS",
-		"APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER",
-		"APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER",
-		"APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER",
-		"APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER",
-		"APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER",
-		"APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER",
-		"APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER",
-		"APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER",
-		"APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER",
-		"APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER",
-		"APPLY_USE_SKILL_CHAYEOL_HP_ABSORB",
-		"APPLY_SUNGMA_STR",
-		"APPLY_SUNGMA_HP",
-		"APPLY_SUNGMA_MOVE",
-		"APPLY_SUNGMA_IMMUNE",
-		"APPLY_HIT_PCT",
-		"APPLY_RANDOM",
-		"APPLY_ATTBONUS_PER_HUMAN",
-		"APPLY_ATTBONUS_PER_ANIMAL",
-		"APPLY_ATTBONUS_PER_ORC",
-		"APPLY_ATTBONUS_PER_MILGYO",
-		"APPLY_ATTBONUS_PER_UNDEAD",
-		"APPLY_ATTBONUS_PER_DEVIL",
-		"APPLY_ENCHANT_PER_ELECT",
-		"APPLY_ENCHANT_PER_FIRE",
-		"APPLY_ENCHANT_PER_ICE",
-		"APPLY_ENCHANT_PER_WIND",
-		"APPLY_ENCHANT_PER_EARTH",
-		"APPLY_ENCHANT_PER_DARK",
-		"APPLY_ATTBONUS_PER_CZ",
-		"APPLY_ATTBONUS_PER_INSECT",
-		"APPLY_ATTBONUS_PER_DESERT",
-		"APPLY_ATTBONUS_PER_STONE",
-		"APPLY_ATTBONUS_PER_MONSTER",
-		"APPLY_RESIST_PER_HUMAN",
-		"APPLY_RESIST_PER_ICE",
-		"APPLY_RESIST_PER_DARK",
-		"APPLY_RESIST_PER_EARTH",
-		"APPLY_RESIST_PER_FIRE",
-		"APPLY_RESIST_PER_ELEC",
-		"APPLY_RESIST_PER_MAGIC",
-		"APPLY_RESIST_PER_WIND",
-		"APPLY_HIT_BUFF_SUNGMA_STR",
-		"APPLY_HIT_BUFF_SUNGMA_MOVE",
-		"APPLY_HIT_BUFF_SUNGMA_HP",
-		"APPLY_HIT_BUFF_SUNGMA_IMMUNE",
-		"APPLY_MOUNT_MELEE_MAGIC_ATTBONUS_PER",
-		"APPLY_DISMOUNT_MOVE_SPEED_BONUS_PER",
-		"APPLY_HIT_AUTO_HP_RECOVERY",
-		"APPLY_HIT_AUTO_SP_RECOVERY",
-		"APPLY_USE_SKILL_COOLTIME_DECREASE_ALL",
-		"APPLY_HIT_STONE_ATTBONUS_STONE",
-		"APPLY_HIT_STONE_DEF_GRADE_BONUS",
-		"APPLY_KILL_BOSS_ITEM_BONUS",
-		"APPLY_MOB_HIT_MOB_AGGRESSIVE",
-		"APPLY_NO_DEATH_AND_HP_RECOVERY30",
-		"APPLY_AUTO_PICKUP",
-		"APPLY_MOUNT_NO_KNOCKBACK",
-		"APPLY_SUNGMA_PER_STR",
-		"APPLY_SUNGMA_PER_HP",
-		"APPLY_SUNGMA_PER_MOVE",
-		"APPLY_SUNGMA_PER_IMMUNE",
-		"APPLY_IMMUNE_POISON100",
-		"APPLY_IMMUNE_BLEEDING100",
-		"APPLY_MONSTER_DEFEND_BONUS",
-	};
-
-	int retInt = -1;
-	// cout << "ApplyType : " << applyTypeStr << " -> ";
-	for (int j = 0; j < sizeof(arApplyType) / sizeof(arApplyType[0]); j++)
-	{
-		string tempString = arApplyType[j];
-		string tempInputString = trim(inputString);
-		if (tempInputString.compare(tempString) == 0)
-		{
-			// cout << j << " ";
-			retInt = j;
-			break;
-		}
-	}
-	// cout << endl;
-
-	return retInt;
-}
-
-//몬스터 프로토도 읽는다.
-int get_Mob_Rank_Value(string inputString)
-{
-	string arRank[] = {
-		"PAWN",
-		"S_PAWN",
-		"KNIGHT",
-		"S_KNIGHT",
-		"BOSS",
-		"KING",
-	};
-
-	int retInt = -1;
-	// cout << "Rank : " << rankStr << " -> ";
-	for (int j = 0; j < sizeof(arRank) / sizeof(arRank[0]); j++)
-	{
-		string tempString = arRank[j];
-		string tempInputString = trim(inputString);
-		if (tempInputString.compare(tempString) == 0)
-		{
-			// cout << j << " ";
-			retInt = j;
-			break;
-		}
-	}
-	// cout << endl;
-
-	return retInt;
-}
-
-int get_Mob_Type_Value(string inputString)
-{
-	string arType[] = {
-		"MONSTER",
-		"NPC",
-		"STONE",
-		"WARP",
-		"DOOR",
-		"BUILDING",
-		"PC",
-		"POLYMORPH_PC",
-		"HORSE",
-		"GOTO",
-		"PET",
-		"PET_PAY",
-		"SHOP",
-		"OBJECT",
-	};
-
-	int retInt = -1;
-	// cout << "Type : " << typeStr << " -> ";
-	for (int j = 0; j < sizeof(arType) / sizeof(arType[0]); j++)
-	{
-		string tempString = arType[j];
-		string tempInputString = trim(inputString);
-		if (tempInputString.compare(tempString) == 0)
-		{
-			// cout << j << " ";
-			retInt = j;
-			break;
-		}
-	}
-	// cout << endl;
-
-	return retInt;
-}
-
-int get_Mob_BattleType_Value(string inputString)
-{
-	string arBattleType[] = {
-		"MELEE",
-		"RANGE",
-		"MAGIC",
-		"SPECIAL",
-		"POWER",
-		"TANKER",
-		"SUPER_POWER",
-		"SUPER_TANKER",
-	};
-
-	int retInt = -1;
-	// cout << "Battle Type : " << battleTypeStr << " -> ";
-	for (int j = 0; j < sizeof(arBattleType) / sizeof(arBattleType[0]); j++)
-	{
-		string tempString = arBattleType[j];
-		string tempInputString = trim(inputString);
-		if (tempInputString.compare(tempString) == 0)
-		{
-			// cout << j << " ";
-			retInt = j;
-			break;
-		}
-	}
-	// cout << endl;
-
-	return retInt;
-}
-
-int get_Mob_Size_Value(string inputString)
-{
-	string arSize[] = {
-		"SMALL",
-		"MEDIUM",
-		"BIG",
-	};
-
-	int retInt = 0;
-	// cout << "Size : " << sizeStr << " -> ";
-	for (int j = 0; j < sizeof(arSize) / sizeof(arSize[0]); j++)
-	{
-		string tempString = arSize[j];
-		string tempInputString = trim(inputString);
-		if (tempInputString.compare(tempString) == 0)
-		{
-			// cout << j << " ";
-			retInt = j + 1;
-			break;
-		}
-	}
-	// cout << endl;
-
-	return retInt;
-}
-
-int get_Mob_AIFlag_Value(string inputString)
-{
-	string arAIFlag[] = {
-		"AGGR",
-		"NOMOVE",
-		"COWARD",
-		"NOATTSHINSU",
-		"NOATTCHUNJO",
-		"NOATTJINNO",
-		"ATTMOB",
-		"BERSERK",
-		"STONESKIN",
-		"GODSPEED",
-		"DEATHBLOW",
-		"REVIVE",
-		"HEALER",
-		"COUNT",
-		"NORECOVERY",
-		"REFLECT",
-		"FALL",
-		"VIT",
-		"RATTSPEED",
-		"RCASTSPEED",
-		"RHP_REGEN",
-		"TIMEVIT",
-	};
-
-	int retValue = 0;
-	string* arInputString = StringSplit(inputString, ","); // 프로토 정보 내용을 단어별로 쪼갠 배열.
-	for (int i = 0; i < sizeof(arAIFlag) / sizeof(arAIFlag[0]); i++)
-	{
-		string tempString = arAIFlag[i];
-		for (int j = 0; j < 30; j++) // 최대 30개 단어까지. (하드코딩)
-		{
-			string tempString2 = arInputString[j];
-			if (tempString2.compare(tempString) == 0) // 일치하는지 확인.
-			{
-				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
-			}
-
-			if (tempString2.compare("") == 0)
-				break;
-		}
-	}
-	delete[]arInputString;
-	// cout << "AIFlag : " << aiFlagStr << " -> " << retValue << endl;
-
-	return retValue;
-}
-
-int get_Mob_RaceFlag_Value(string inputString)
-{
-	string arRaceFlag[] = {
-		"ANIMAL",
-		"UNDEAD",
-		"DEVIL",
-		"HUMAN",
-		"ORC",
-		"MILGYO",
-		"INSECT",
-		"DESERT",
-		"TREE",
-		"DECO",
-		"HIDE",
-		"ATT_CZ",
-		"AWEAKEN",
-		"SUNGMAHEE",
-		"OUTPOST",
-	};
-
-	int retValue = 0;
-	string* arInputString = StringSplit(inputString, ","); // 프로토 정보 내용을 단어별로 쪼갠 배열.
-	for (int i = 0; i < sizeof(arRaceFlag) / sizeof(arRaceFlag[0]); i++)
-	{
-		string tempString = arRaceFlag[i];
-		for (int j = 0; j < 30; j++) // 최대 30개 단어까지. (하드코딩)
-		{
-			string tempString2 = arInputString[j];
-			if (tempString2.compare(tempString) == 0) // 일치하는지 확인.
-			{
-				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
-			}
-
-			if (tempString2.compare("") == 0)
-				break;
-		}
-	}
-	delete[]arInputString;
-	// cout << "Race Flag : " << raceFlagStr << " -> " << retValue << endl;
-
-	return retValue;
-}
-
-int get_Mob_ImmuneFlag_Value(string inputString)
-{
-	string arImmuneFlag[] = {
-		"STUN",
-		"SLOW",
-		"FALL",
-		"CURSE",
-		"POISON",
-		"TERROR",
-		"REFLECT",
-	};
-
-	int retValue = 0;
-	string* arInputString = StringSplit(inputString, ","); // 프로토 정보 내용을 단어별로 쪼갠 배열.
-	for (int i = 0; i < sizeof(arImmuneFlag) / sizeof(arImmuneFlag[0]); i++)
-	{
-		string tempString = arImmuneFlag[i];
-		for (int j = 0; j < 30; j++) // 최대 30개 단어까지. (하드코딩)
-		{
-			string tempString2 = arInputString[j];
-			if (tempString2.compare(tempString) == 0) // 일치하는지 확인.
-			{
-				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
-			}
-
-			if (tempString2.compare("") == 0)
-				break;
-		}
-	}
-	delete[]arInputString;
-	// cout << "Immune Flag : " << immuneFlagStr << " -> " << retValue << endl;
-
-	return retValue;
-}
-
-#ifndef __DUMP_PROTO__
-// 몹 테이블을 셋팅해준다.
-bool Set_Proto_Mob_Table(TMobTable* mobTable, cCsvTable& csvTable, std::map<int, const char*>& nameMap)
-{
-	int col = 0;
-
-	str_to_number(mobTable->dwVnum, csvTable.AsStringByIndex(col++));
-	strlcpy(mobTable->szName, csvTable.AsStringByIndex(col++), sizeof(mobTable->szName));
-
-	// 3. 지역별 이름 넣어주기.
-	map<int, const char*>::iterator it;
-	it = nameMap.find(mobTable->dwVnum);
-	if (it != nameMap.end())
-	{
-		const char* localeName = it->second;
-		strlcpy(mobTable->szLocaleName, localeName, sizeof(mobTable->szLocaleName));
-	}
-	else
-	{
-		strlcpy(mobTable->szLocaleName, mobTable->szName, sizeof(mobTable->szLocaleName));
-	}
-
-	// RANK
-	int rankValue = get_Mob_Rank_Value(csvTable.AsStringByIndex(col++));
-	mobTable->bRank = rankValue;
-
-	// TYPE
-	int typeValue = get_Mob_Type_Value(csvTable.AsStringByIndex(col++));
-	mobTable->bType = typeValue;
-
-	// BATTLE_TYPE
-	int battleTypeValue = get_Mob_BattleType_Value(csvTable.AsStringByIndex(col++));
-	mobTable->bBattleType = battleTypeValue;
-
-	str_to_number(mobTable->bLevel, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bScale, csvTable.AsStringByIndex(col++));
-
-	// SIZE
-	int sizeValue = get_Mob_Size_Value(csvTable.AsStringByIndex(col++));
-	mobTable->bSize = sizeValue;
-
-	// AI_FLAG
-	int aiFlagValue = get_Mob_AIFlag_Value(csvTable.AsStringByIndex(col++));
-	mobTable->dwAIFlag = aiFlagValue;
-
-	// MOUNT_CAPACITY;
-	col++;
-
-	// RACE_FLAG
-	int raceFlagValue = get_Mob_RaceFlag_Value(csvTable.AsStringByIndex(col++));
-	mobTable->dwRaceFlag = raceFlagValue;
-
-	// IMMUNE_FLAG
-	int immuneFlagValue = get_Mob_ImmuneFlag_Value(csvTable.AsStringByIndex(col++));
-	mobTable->dwImmuneFlag = immuneFlagValue;
-
-	str_to_number(mobTable->bEmpire, csvTable.AsStringByIndex(col++)); // col = 11
-
-	strlcpy(mobTable->szFolder, csvTable.AsStringByIndex(col++), sizeof(mobTable->szFolder));
-
-	str_to_number(mobTable->bOnClickType, csvTable.AsStringByIndex(col++));
-
-	str_to_number(mobTable->bStr, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bDex, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bCon, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bInt, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bSungMaStr, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bSungMaDex, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bSungMaCon, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bSungMaInt, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->dwDamageRange[0], csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->dwDamageRange[1], csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->dwMaxHP, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bRegenCycle, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bRegenPercent, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->dwGoldMin, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->dwGoldMax, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->dwExp, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->dwSungMaExp, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->wDef, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->sAttackSpeed, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->sMovingSpeed, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bAggressiveHPPct, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->wAggressiveSight, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->wAttackRange, csvTable.AsStringByIndex(col++));
-
-	str_to_number(mobTable->dwDropItemVnum, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->dwResurrectionVnum, csvTable.AsStringByIndex(col++));
-	for (int i = 0; i < MOB_ENCHANTS_MAX_NUM; ++i)
-		str_to_number(mobTable->cEnchants[i], csvTable.AsStringByIndex(col++));
-
-	for (int i = 0; i < MOB_RESISTS_MAX_NUM; ++i)
-		str_to_number(mobTable->cResists[i], csvTable.AsStringByIndex(col++));
-
-#if defined(__ELEMENT_SYSTEM__)
-	for (int i = 0; i < MOB_ELEMENT_MAX_NUM; ++i)
-		str_to_number(mobTable->cElements[i], csvTable.AsStringByIndex(col++));
-
-	str_to_number(mobTable->cResistDark, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->cResistIce, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->cResistEarth, csvTable.AsStringByIndex(col++));
-#endif
-
-	str_to_number(mobTable->fDamMultiply, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->dwSummonVnum, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->dwDrainSP, csvTable.AsStringByIndex(col++));
-
-	// MOB_COLOR
-	++col;
-
-	str_to_number(mobTable->dwPolymorphItemVnum, csvTable.AsStringByIndex(col++));
-
-	str_to_number(mobTable->Skills[0].bLevel, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->Skills[0].dwVnum, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->Skills[1].bLevel, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->Skills[1].dwVnum, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->Skills[2].bLevel, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->Skills[2].dwVnum, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->Skills[3].bLevel, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->Skills[3].dwVnum, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->Skills[4].bLevel, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->Skills[4].dwVnum, csvTable.AsStringByIndex(col++));
-
-	str_to_number(mobTable->bBerserkPoint, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bStoneSkinPoint, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bGodSpeedPoint, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bDeathBlowPoint, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bRevivePoint, csvTable.AsStringByIndex(col++));
-
-	str_to_number(mobTable->bHealPoint, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bRAttSpeedPoint, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bRCastSpeedPoint, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->bRHPRegenPoint, csvTable.AsStringByIndex(col++));
-	str_to_number(mobTable->fHitRange, csvTable.AsStringByIndex(col++));
-
-	sys_log(0, "MOB #%-5d %-24s level: %-3u rank: %u empire: %d", mobTable->dwVnum, mobTable->szLocaleName, mobTable->bLevel, mobTable->bRank, mobTable->bEmpire);
-
-	return true;
-}
-
-bool Set_Proto_Item_Table(TItemTable* itemTable, cCsvTable& csvTable, std::map<int, const char*>& nameMap)
-{
-	// vnum 및 vnum range 읽기.
-	{
-		std::string s(csvTable.AsStringByIndex(0));
-		int pos = s.find("~");
-		// vnum 필드에 '~'가 없다면 패스
-		if (std::string::npos == pos)
-		{
-			itemTable->dwVnum = atoi(s.c_str());
-			if (0 == itemTable->dwVnum)
-			{
-				printf("INVALID VNUM %s\n", s.c_str());
-				return false;
-			}
-			itemTable->dwVnumRange = 0;
-		}
-		else
-		{
-			std::string s_start_vnum(s.substr(0, pos));
-			std::string s_end_vnum(s.substr(pos + 1));
-
-			int start_vnum = atoi(s_start_vnum.c_str());
-			int end_vnum = atoi(s_end_vnum.c_str());
-			if (0 == start_vnum || (0 != end_vnum && end_vnum < start_vnum))
-			{
-				sys_err("INVALID VNUM %s", s.c_str());
-				return false;
-			}
-			itemTable->dwVnum = start_vnum;
-			itemTable->dwVnumRange = end_vnum - start_vnum;
-		}
-	}
-
-	int col = 1;
-
-	strlcpy(itemTable->szName, csvTable.AsStringByIndex(col++), sizeof(itemTable->szName));
-	// 지역별 이름 넣어주기.
-	std::map<int, const char*>::iterator it;
-	it = nameMap.find(itemTable->dwVnum);
-	if (it != nameMap.end())
-	{
-		const char* localeName = it->second;
-		strlcpy(itemTable->szLocaleName, localeName, sizeof(itemTable->szLocaleName));
-	}
-	else
-	{
-		strlcpy(itemTable->szLocaleName, itemTable->szName, sizeof(itemTable->szLocaleName));
-	}
-
-	itemTable->bType = get_Item_Type_Value(csvTable.AsStringByIndex(col++));
-	itemTable->bSubType = get_Item_SubType_Value(itemTable->bType, csvTable.AsStringByIndex(col++));
-	itemTable->bSize = atoi(csvTable.AsStringByIndex(col++));
-	itemTable->ullAntiFlags = get_Item_AntiFlag_Value(csvTable.AsStringByIndex(col++));
-	itemTable->dwFlags = get_Item_Flag_Value(csvTable.AsStringByIndex(col++));
-	itemTable->dwWearFlags = get_Item_WearFlag_Value(csvTable.AsStringByIndex(col++));
-	itemTable->dwImmuneFlag = get_Item_Immune_Value(csvTable.AsStringByIndex(col++));
-	itemTable->dwShopBuyPrice = atoi(csvTable.AsStringByIndex(col++));
-	itemTable->dwShopSellPrice = atoi(csvTable.AsStringByIndex(col++));
-	itemTable->dwRefinedVnum = atoi(csvTable.AsStringByIndex(col++));
-	itemTable->wRefineSet = atoi(csvTable.AsStringByIndex(col++));
-	itemTable->dw67AttrMaterial = atoi(csvTable.AsStringByIndex(col++));
-	itemTable->bAlterToMagicItemPct = atoi(csvTable.AsStringByIndex(col++));
-	itemTable->cLimitRealTimeFirstUseIndex = -1;
-	itemTable->cLimitTimerBasedOnWearIndex = -1;
-
-	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-	{
-		itemTable->aLimits[i].bType = get_Item_LimitType_Value(csvTable.AsStringByIndex(col++));
-		itemTable->aLimits[i].lValue = atoi(csvTable.AsStringByIndex(col++));
-
-		if (LIMIT_REAL_TIME_START_FIRST_USE == itemTable->aLimits[i].bType)
-			itemTable->cLimitRealTimeFirstUseIndex = (char)i;
-
-		if (LIMIT_TIMER_BASED_ON_WEAR == itemTable->aLimits[i].bType)
-			itemTable->cLimitTimerBasedOnWearIndex = (char)i;
-	}
-
-	for (int i = 0; i < ITEM_APPLY_MAX_NUM; ++i)
-	{
-		itemTable->aApplies[i].wType = get_Item_ApplyType_Value(csvTable.AsStringByIndex(col++));
-		itemTable->aApplies[i].lValue = atoi(csvTable.AsStringByIndex(col++));
-	}
-
-	for (int i = 0; i < ITEM_VALUES_MAX_NUM; ++i)
-		itemTable->alValues[i] = atoi(csvTable.AsStringByIndex(col++));
-
-	itemTable->bSpecular = atoi(csvTable.AsStringByIndex(col++));
-	itemTable->bGainSocketPct = atoi(csvTable.AsStringByIndex(col++));
-	itemTable->sAddonType = atoi(csvTable.AsStringByIndex(col++));
-
-	itemTable->bWeight = 0;
-
-	sys_log(0, "ITEM #%-5d %-24s", itemTable->dwVnum, itemTable->szLocaleName);
-
-	return true;
-}
-#endif
+#include "stdafx.h"
+
+#include <math.h>
+#include "ProtoReader.h"
+
+#include "CsvReader.h"
+
+#include <sstream>
+
+using namespace std;
+
+inline string trim_left(const string& str)
+{
+	string::size_type n = str.find_first_not_of(" \t\v\n\r");
+	return n == string::npos ? str : str.substr(n, str.length());
+}
+
+inline string trim_right(const string& str)
+{
+	string::size_type n = str.find_last_not_of(" \t\v\n\r");
+	return n == string::npos ? str : str.substr(0, n + 1);
+}
+
+string trim(const string& str) { return trim_left(trim_right(str)); }
+
+static string* StringSplit(string strOrigin, string strTok)
+{
+	int cutAt; // 美치
+	int index = 0; // 悶琯
+	string* strResult = new string[30]; //return 捻
+
+	// strTok찾趺
+	while ((cutAt = strOrigin.find_first_of(strTok)) != strOrigin.npos)
+	{
+		if (cutAt > 0) // 美치0크()
+		{
+			strResult[index++] = strOrigin.substr(0, cutAt); // 瓦煞
+		}
+		strOrigin = strOrigin.substr(cutAt + 1); // 美觀碁
+	}
+
+	if (strOrigin.length() > 0) // 潔
+	{
+		strResult[index++] = strOrigin.substr(0, cutAt); // 瓦煞
+	}
+
+	for (int i = 0; i < index; i++)
+	{
+		strResult[i] = trim(strResult[i]);
+	}
+
+	return strResult; // return
+}
+
+int get_Item_Type_Value(string inputString)
+{
+	string arType[] = {
+		"ITEM_NONE",
+		"ITEM_WEAPON",
+		"ITEM_ARMOR",
+		"ITEM_USE",
+		"ITEM_AUTOUSE",
+		"ITEM_MATERIAL",
+		"ITEM_SPECIAL",
+		"ITEM_TOOL",
+		"ITEM_LOTTERY",
+		"ITEM_ELK",
+		"ITEM_METIN",
+		"ITEM_CONTAINER",
+		"ITEM_FISH",
+		"ITEM_ROD",
+		"ITEM_RESOURCE",
+		"ITEM_CAMPFIRE",
+		"ITEM_UNIQUE",
+		"ITEM_SKILLBOOK",
+		"ITEM_QUEST",
+		"ITEM_POLYMORPH",
+		"ITEM_TREASURE_BOX",
+		"ITEM_TREASURE_KEY",
+		"ITEM_SKILLFORGET",
+		"ITEM_GIFTBOX",
+		"ITEM_PICK",
+		"ITEM_HAIR",
+		"ITEM_TOTEM",
+		"ITEM_BLEND",
+		"ITEM_COSTUME",
+		"ITEM_DS",
+		"ITEM_SPECIAL_DS",
+		"ITEM_EXTRACT",
+		"ITEM_SECONDARY_COIN",
+		"ITEM_RING",
+		"ITEM_BELT",
+		"ITEM_PET",
+#if defined(__MOVE_COSTUME_ATTR__)		
+		"ITEM_MEDIUM",
+#endif									
+#if defined(__GACHA_SYSTEM__)			
+		"ITEM_GACHA",
+#endif									
+		"ITEM_PASSIVE",
+		"ITEM_MERCENARY",
+		"ITEM_ALCHEMY",
+//#if defined(__SOUL_SYSTEM__)			
+		"ITEM_SOUL",
+//#endif
+	};
+
+	int retInt = -1;
+	// cout << "Type : " << typeStr << " -> ";
+	for (int j = 0; j < sizeof(arType) / sizeof(arType[0]); j++)
+	{
+		string tempString = arType[j];
+		if (inputString.find(tempString) != string::npos && tempString.find(inputString) != string::npos)
+		{
+			// cout << j << " ";
+			retInt = j;
+			break;
+		}
+	}
+	// cout << endl;
+
+	return retInt;
+}
+
+int get_Item_SubType_Value(int type_value, string inputString)
+{
+	static string arSub1[] = {
+		"WEAPON_SWORD",
+		"WEAPON_DAGGER",
+		"WEAPON_BOW",
+		"WEAPON_TWO_HANDED",
+		"WEAPON_BELL",
+		"WEAPON_FAN",
+		"WEAPON_ARROW",
+		"WEAPON_MOUNT_SPEAR",
+		"WEAPON_CLAW",
+#if defined(__QUIVER_SYSTEM__)
+		"WEAPON_QUIVER",
+#endif
+		"WEAPON_BOUQUE",
+	};
+
+	static string arSub2[] = {
+		"ARMOR_BODY",
+		"ARMOR_HEAD",
+		"ARMOR_SHIELD",
+		"ARMOR_WRIST",
+		"ARMOR_FOOTS",
+		"ARMOR_NECK",
+		"ARMOR_EAR",
+#if defined(__PENDANT_SYSTEM__)
+		"ARMOR_PENDANT",
+#endif
+#if defined(__GLOVE_SYSTEM__)
+		"ARMOR_GLOVE",
+#endif
+	};
+
+	static string arSub3[] = {
+		"USE_POTION",
+		"USE_TALISMAN",
+		"USE_TUNING",
+		"USE_MOVE",
+		"USE_TREASURE_BOX",
+		"USE_MONEYBAG",
+		"USE_BAIT",
+		"USE_ABILITY_UP",
+		"USE_AFFECT",
+		"USE_CREATE_STONE",
+		"USE_SPECIAL",
+		"USE_POTION_NODELAY",
+		"USE_CLEAR",
+		"USE_INVISIBILITY",
+		"USE_DETACHMENT",
+		"USE_BUCKET",
+		"USE_POTION_CONTINUE",
+		"USE_CLEAN_SOCKET",
+		"USE_CHANGE_ATTRIBUTE",
+		"USE_ADD_ATTRIBUTE",
+		"USE_ADD_ACCESSORY_SOCKET",
+		"USE_PUT_INTO_ACCESSORY_SOCKET",
+		"USE_ADD_ATTRIBUTE2",
+		"USE_RECIPE",
+		"USE_CHANGE_ATTRIBUTE2",
+		"USE_BIND",
+		"USE_UNBIND",
+		"USE_TIME_CHARGE_PER",
+		"USE_TIME_CHARGE_FIX",
+		"USE_PUT_INTO_BELT_SOCKET",
+		"USE_PUT_INTO_RING_SOCKET",
+#if defined(__MOVE_COSTUME_ATTR__)
+		"USE_CHANGE_COSTUME_ATTR",
+		"USE_RESET_COSTUME_ATTR",
+#endif
+		"USE_UNK_33",
+#if defined(__CHANGED_ATTR__)
+		"USE_SELECT_ATTRIBUTE",
+#endif
+		"USE_FLOWER",
+#if defined(__EXPRESSING_EMOTIONS__)
+		"USE_EMOTION_PACK",
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		"USE_ELEMENT_UPGRADE",
+		"USE_ELEMENT_DOWNGRADE",
+		"USE_ELEMENT_CHANGE",
+#endif
+		"USE_CALL",
+		"USE_POTION_TOWER",
+		"USE_POTION_NODELAY_TOWER",
+		"USE_REMOVE_AFFECT",
+		"USE_EMOTION_TOWER",
+		"USE_SECRET_DUNGEON_SCROLL",
+		"USE_OPEN_OFFLINE_SHOP",
+	};
+
+	static string arSub4[] = {
+		"AUTOUSE_POTION",
+		"AUTOUSE_ABILITY_UP",
+		"AUTOUSE_BOMB",
+		"AUTOUSE_GOLD",
+		"AUTOUSE_MONEYBAG",
+		"AUTOUSE_TREASURE_BOX",
+	};
+
+	static string arSub5[] = {
+		"MATERIAL_LEATHER",
+		"MATERIAL_BLOOD",
+		"MATERIAL_ROOT",
+		"MATERIAL_NEEDLE",
+		"MATERIAL_JEWEL",
+		"MATERIAL_DS_REFINE_NORMAL",
+		"MATERIAL_DS_REFINE_BLESSED",
+		"MATERIAL_DS_REFINE_HOLLY",
+#if defined(__DS_CHANGE_ATTR__)
+		"MATERIAL_DS_CHANGE_ATTR",
+#endif
+		"MATERIAL_PASSIVE_WEAPON",
+		"MATERIAL_PASSIVE_ARMOR",
+		"MATERIAL_PASSIVE_ACCE",
+		"MATERIAL_PASSIVE_ELEMENT",
+	};
+
+	static string arSub6[] = {
+		"SPECIAL_MAP",
+		"SPECIAL_KEY",
+		"SPECIAL_DOC",
+		"SPECIAL_SPIRIT",
+	};
+
+	static string arSub7[] = {
+		"TOOL_FISHING_ROD",
+	};
+
+	static string arSub8[] = {
+		"LOTTERY_TICKET",
+		"LOTTERY_INSTANT",
+	};
+
+	static string arSub10[] = {
+		"METIN_NORMAL",
+		"METIN_SUNGMA",
+	};
+
+	static string arSub12[] = {
+		"FISH_ALIVE",
+		"FISH_DEAD",
+	};
+
+	static string arSub14[] = {
+		"RESOURCE_FISHBONE",
+		"RESOURCE_WATERSTONEPIECE",
+		"RESOURCE_WATERSTONE",
+		"RESOURCE_BLOOD_PEARL",
+		"RESOURCE_BLUE_PEARL",
+		"RESOURCE_WHITE_PEARL",
+		"RESOURCE_BUCKET",
+		"RESOURCE_CRYSTAL",
+		"RESOURCE_GEM",
+		"RESOURCE_STONE",
+		"RESOURCE_METIN",
+		"RESOURCE_ORE",
+#if defined(__AURA_COSTUME_SYSTEM__)
+		"RESOURCE_AURA",
+#endif
+	};
+
+	static string arSub16[] = {
+		"UNIQUE_NONE",
+		"UNIQUE_BOOK",
+		"UNIQUE_SPECIAL_RIDE",
+		"UNIQUE_3",
+		"UNIQUE_4",
+		"UNIQUE_5",
+		"UNIQUE_6",
+		"UNIQUE_7",
+		"UNIQUE_8",
+		"UNIQUE_9",
+		"UNIQUE_BUNDLE",
+	};
+
+	static string arSub18[] = {
+		"QUEST_NONE",
+		"QUEST_PET_PAY",
+		"QUEST_WARP",
+		"QUEST_GEM_BAG",
+	};
+
+	static std::string arSub23[]
+	{
+		"GIFTBOX_NONE",
+		"GIFTBOX_NORMAL",
+		"GIFTBOX_SPECIAL",
+	};
+
+	static string arSub28[] = {
+		"COSTUME_BODY",
+		"COSTUME_HAIR",
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+		"COSTUME_MOUNT",
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		"COSTUME_ACCE",
+#endif
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+		"COSTUME_WEAPON",
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+		"COSTUME_AURA",
+#endif
+	};
+
+	static string arSub29[] = {
+		"DS_SLOT1",
+		"DS_SLOT2",
+		"DS_SLOT3",
+		"DS_SLOT4",
+		"DS_SLOT5",
+		"DS_SLOT6",
+#if defined(__DS_7_SLOT__)
+		"DS_SLOT7",
+#endif
+	};
+
+	static string arSub31[] = {
+		"EXTRACT_DRAGON_SOUL",
+		"EXTRACT_DRAGON_HEART",
+	};
+
+//#ifdef __GROWTH_PET_SYSTEM__
+	static string arSub35[] = {
+	"PET_EGG",
+	"PET_UPBRINGING",
+	"PET_BAG",
+	"PET_FEEDSTUFF",
+	"PET_SKILL",
+	"PET_SKILL_DEL_BOOK",
+	"PET_NAME_CHANGE",
+	"PET_EXPFOOD",
+	"PET_SKILL_ALL_DEL_BOOK",
+	"PET_EXPFOOD_PER",
+	"PET_ATTR_DETERMINE",
+	"PET_ATTR_CHANGE",
+	"PET_PAY",
+	"PET_PRIMIUM_FEEDSTUFF",
+	};
+//#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+	static string arSub36[] = {
+		"MEDIUM_MOVE_COSTUME_ATTR",
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		"MEDIUM_MOVE_ACCE_ATTR",
+#endif
+	};
+#endif
+
+#if defined(__GACHA_SYSTEM__)
+	static string arSub37[] = {
+		"USE_GACHA",
+#if defined(__LUCKY_BOX__)
+		"GEM_LUCKY_BOX_GACHA",
+		"SPECIAL_LUCKY_BOX_GACHA",
+#endif
+	};
+#endif
+
+	static std::string arSub38[]
+	{
+		"PASSIVE_JOB",
+	};
+
+	static string arSub39[] = {
+		"MERCENARY_0",
+		"MERCENARY_1",
+		"MERCENARY_2",
+		"MERCENARY_3",
+		"MERCENARY_4",
+		"MERCENARY_5",
+		"MERCENARY_6",
+	};
+
+	static std::string arSub40[]
+	{
+		"ARMOR",
+		"WEAPON",
+		"ACCESSORY",
+		"BELT",
+		"EVENT",
+		"ETC",
+		"JOB",
+		"SETADD_WEAPON",
+		"SETADD_ARMOR_BODY",
+		"SETADD_ARMOR_HELMET",
+		"PET",
+		"SKILL_BOOK",
+		"GLOVE",
+	};
+
+//#if defined(__SOUL_SYSTEM__)
+	static string arSub41[] = {
+		"SOUL_RED",
+		"SOUL_BLUE"
+	};
+//#endif
+
+	static string* arSubType[] = {
+		0,			// ITEM_NONE
+		arSub1,		// ITEM_WEAPON
+		arSub2,		// ITEM_ARMOR
+		arSub3,		// ITEM_USE
+		arSub4,		// ITEM_AUTOUSE
+		arSub5,		// ITEM_MATERIAL
+		arSub6,		// ITEM_SPECIAL
+		arSub7,		// ITEM_TOOL
+		arSub8,		// ITEM_LOTTERY
+		0,			// ITEM_ELK
+		arSub10,	// ITEM_METIN
+		0,			// ITEM_CONTAINER
+		arSub12,	// ITEM_FISH
+		0,			// ITEM_ROD
+		arSub14,	// ITEM_RESOURCE
+		0,			// ITEM_CAMPFIRE
+		arSub16,	// ITEM_UNIQUE
+		0,			// ITEM_SKILLBOOK
+		arSub18,	// ITEM_QUEST
+		0,			// ITEM_POLYMORPH
+		0,			// ITEM_TREASURE_BOX
+		0,			// ITEM_TREASURE_KEY
+		0,			// ITEM_SKILLFORGET
+		arSub23,	// ITEM_GIFTBOX
+		0,			// ITEM_PICK
+		0,			// ITEM_HAIR
+		0,			// ITEM_TOTEM
+		0,			// ITEM_BLEND
+		arSub28,	// ITEM_COSTUME
+		arSub29,	// ITEM_DS
+		arSub29,	// ITEM_SPECIAL_DS
+		arSub31,	// ITEM_EXTRACT
+		0,			// ITEM_SECONDARY_COIN
+		0,			// ITEM_RING
+		0,			// ITEM_BELT
+//#ifdef __GROWTH_PET_SYSTEM__
+		arSub35,	// ITEM_PET
+//#endif
+#if defined(__MOVE_COSTUME_ATTR__)
+		arSub36,	// ITEM_MEDIUM
+#endif
+#if defined(__GACHA_SYSTEM__)
+		arSub37,	// ITEM_GACHA
+#endif
+		arSub38,	// ITEM_PASSIVE
+		arSub39,	// ITEM_MERCENARY
+		arSub40,	// ITEM_ALCHEMY
+//#if defined(__SOUL_SYSTEM__)
+		arSub41,	// ITEM_SOUL
+//#endif
+	};
+
+	static int arNumberOfSubtype[_countof(arSubType)] = {
+		0,										// ITEM_NONE
+		sizeof(arSub1) / sizeof(arSub1[0]),		// ITEM_WEAPON
+		sizeof(arSub2) / sizeof(arSub2[0]),		// ITEM_ARMOR
+		sizeof(arSub3) / sizeof(arSub3[0]),		// ITEM_USE
+		sizeof(arSub4) / sizeof(arSub4[0]),		// ITEM_AUTOUSE
+		sizeof(arSub5) / sizeof(arSub5[0]),		// ITEM_MATERIAL
+		sizeof(arSub6) / sizeof(arSub6[0]),		// ITEM_SPECIAL
+		sizeof(arSub7) / sizeof(arSub7[0]),		// ITEM_TOOL
+		sizeof(arSub8) / sizeof(arSub8[0]),		// ITEM_LOTTERY
+		0,										// ITEM_ELK
+		sizeof(arSub10) / sizeof(arSub10[0]),	// ITEM_METIN
+		0,										// ITEM_CONTAINER
+		sizeof(arSub12) / sizeof(arSub12[0]),	// ITEM_FISH
+		0,										// ITEM_ROD
+		sizeof(arSub14) / sizeof(arSub14[0]),	// ITEM_RESOURCE
+		0,										// ITEM_CAMPFIRE
+		sizeof(arSub16) / sizeof(arSub16[0]),	// ITEM_UNIQUE
+		0,										// ITEM_SKILLBOOK
+		sizeof(arSub18) / sizeof(arSub18[0]),	// ITEM_QUEST
+		0,										// ITEM_POLYMORPH
+		0,										// ITEM_TREASURE_BOX
+		0,										// ITEM_TREASURE_KEY
+		0,										// ITEM_SKILLFORGET
+		sizeof(arSub23) / sizeof(arSub23[0]),	// ITEM_GIFTBOX
+		0,										// ITEM_PICK
+		0,										// ITEM_HAIR
+		0,										// ITEM_TOTEM
+		0,										// ITEM_BLEND
+		sizeof(arSub28) / sizeof(arSub28[0]),	// ITEM_COSTUME
+		sizeof(arSub29) / sizeof(arSub29[0]),	// ITEM_DS
+		sizeof(arSub29) / sizeof(arSub29[0]),	// ITEM_SPECIAL_DS
+		sizeof(arSub31) / sizeof(arSub31[0]),	// ITEM_EXTRACT
+		0,										// ITEM_SECONDARY_COIN
+		0,										// ITEM_RING
+		0,										// ITEM_BELT
+		sizeof(arSub35) / sizeof(arSub35[0]),	// ITEM_PET
+#if defined(__MOVE_COSTUME_ATTR__)
+		sizeof(arSub36) / sizeof(arSub36[0]),	// ITEM_MEDIUM
+#endif
+#if defined(__GACHA_SYSTEM__)
+		sizeof(arSub37) / sizeof(arSub37[0]),	// ITEM_GACHA
+#endif
+		sizeof(arSub38) / sizeof(arSub38[0]),	// ITEM_PASSIVE
+		sizeof(arSub39) / sizeof(arSub39[0]),	// ITEM_MERCENARY
+		sizeof(arSub40) / sizeof(arSub40[0]),	// ITEM_ALCHEMY
+//#if defined(__SOUL_SYSTEM__)
+		sizeof(arSub41) / sizeof(arSub41[0]),	// ITEM_SOUL
+//#endif
+	};
+
+	assert(_countof(arSubType) > type_value && "Subtype rule: Out of range!!");
+
+	// assert   ..
+	if (_countof(arSubType) <= type_value)
+	{
+		sys_err("SubType : Out of range!! (type_value: %d, count of registered subtype: %d", type_value, _countof(arSubType));
+		return -1;
+	}
+
+	//  타 타 佇미 求 鱇틤,  0 
+	if (arSubType[type_value] == 0)
+		return 0;
+	//
+
+	int retInt = -1;
+	// cout << "SubType : " << subTypeStr << " -> ";
+	for (int j = 0; j < arNumberOfSubtype[type_value]; j++)
+	{
+		string tempString = arSubType[type_value][j];
+		string tempInputString = trim(inputString);
+		if (tempInputString.compare(tempString) == 0)
+		{
+			// cout << j << " ";
+			retInt = j;
+			break;
+		}
+	}
+	// cout << endl;
+
+	return retInt;
+}
+
+int get_Item_AntiFlag_Value(string inputString)
+{
+	string arAntiFlag[] = {
+		"ANTI_FEMALE",
+		"ANTI_MALE",
+		"ANTI_MUSA",
+		"ANTI_ASSASSIN",
+		"ANTI_SURA",
+		"ANTI_MUDANG",
+		"ANTI_GET",
+		"ANTI_DROP",
+		"ANTI_SELL",
+		"ANTI_EMPIRE_A",
+		"ANTI_EMPIRE_B",
+		"ANTI_EMPIRE_C",
+		"ANTI_SAVE",
+		"ANTI_GIVE",
+		"ANTI_PKDROP",
+		"ANTI_STACK",
+		"ANTI_MYSHOP",
+		"ANTI_SAFEBOX",
+		"ANTI_WOLFMAN",
+		"ANTI_RT_REMOVE",
+		"ANTI_QUICKSLOT",
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		"ANTI_CHANGELOOK",
+#endif
+		"ANTI_REINFORCE",
+		"ANTI_ENCHANT",
+		"ANTI_ENERGY",
+//#if defined(__GROWTH_PET_SYSTEM__)
+		"ANTI_PETFEED",
+//#endif
+		"ANTI_APPLY",
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		"ANTI_ACCE",
+#endif
+#if defined(__MAILBOX__)
+		"ANTI_MAIL",
+#endif
+		"ANTI_DESTROY" // Custom
+	};
+
+	int retValue = 0;
+	const std::vector<std::string> arInputString = StringSplit(inputString, '|');
+	for (int i = 0; i < sizeof(arAntiFlag) / sizeof(arAntiFlag[0]); i++)
+	{
+		string tempString = arAntiFlag[i];
+		for (size_t j = 0; j < arInputString.size(); j++)
+		{
+			const string& tempString2 = arInputString[j];
+			if (tempString2.compare(tempString) == 0)
+			{
+				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
+			}
+		}
+	}
+	delete[]arInputString;
+	// cout << "AntiFlag : " << antiFlagStr << " -> " << retValue << endl;
+
+	return retValue;
+}
+
+int get_Item_Flag_Value(string inputString)
+{
+	string arFlag[] = {
+		"ITEM_TUNABLE",
+		"ITEM_SAVE",
+		"ITEM_STACKABLE",
+		"COUNT_PER_1GOLD",
+		"ITEM_SLOW_QUERY",
+		"ITEM_UNIQUE",
+		"ITEM_MAKECOUNT",
+		"ITEM_IRREMOVABLE",
+		"CONFIRM_WHEN_USE",
+		"QUEST_USE",
+		"QUEST_USE_MULTIPLE",
+		"QUEST_GIVE",
+		"LOG",
+		"ITEM_APPLICABLE",
+	};
+
+	int retValue = 0;
+	string* arInputString = StringSplit(inputString, "|"); //    輧咀  瓦.
+	for (int i = 0; i < sizeof(arFlag) / sizeof(arFlag[0]); i++)
+	{
+		string tempString = arFlag[i];
+		for (int j = 0; j < 30; j++) // 獵 30 輧. (溝湄)
+		{
+			string tempString2 = arInputString[j];
+			if (tempString2.compare(tempString) == 0) // 치求 확.
+			{
+				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
+			}
+
+			if (tempString2.compare("") == 0)
+				break;
+		}
+	}
+	delete[]arInputString;
+	// cout << "Flag : " << flagStr << " -> " << retValue << endl;
+
+	return retValue;
+}
+
+int get_Item_WearFlag_Value(string inputString)
+{
+	// @ EItemWearableFlag
+	string arWearrFlag[] = {
+		"WEAR_BODY",
+		"WEAR_HEAD",
+		"WEAR_FOOTS",
+		"WEAR_WRIST",
+		"WEAR_WEAPON",
+		"WEAR_NECK",
+		"WEAR_EAR",
+		"WEAR_UNIQUE",
+		"WEAR_SHIELD",
+		"WEAR_ARROW",
+		"WEAR_HAIR",
+#if defined(__PENDANT_SYSTEM__)
+		"WEAR_PENDANT",
+#endif
+#if defined(__GLOVE_SYSTEM__)
+		"WEAR_GLOVE",
+#endif
+	};
+
+	int retValue = 0;
+	string* arInputString = StringSplit(inputString, "|"); //    輧咀  瓦.
+	for (int i = 0; i < sizeof(arWearrFlag) / sizeof(arWearrFlag[0]); i++)
+	{
+		string tempString = arWearrFlag[i];
+		for (int j = 0; j < 30; j++) // 獵 30 輧. (溝湄)
+		{
+			string tempString2 = arInputString[j];
+			if (tempString2.compare(tempString) == 0) // 치求 확.
+			{
+				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
+			}
+
+			if (tempString2.compare("") == 0)
+				break;
+		}
+	}
+	delete[]arInputString;
+	// cout << "WearFlag : " << wearFlagStr << " -> " << retValue << endl;
+
+	return retValue;
+}
+
+int get_Item_Immune_Value(string inputString)
+{
+	string arImmune[] = {
+		"PARA",
+		"CURSE",
+		"STUN",
+		"SLEEP",
+		"SLOW",
+		"POISON",
+		"TERROR",
+	};
+
+	int retValue = 0;
+	string* arInputString = StringSplit(inputString, "|"); //   輧咀  瓦.
+	for (int i = 0; i < sizeof(arImmune) / sizeof(arImmune[0]); i++)
+	{
+		string tempString = arImmune[i];
+		for (int j = 0; j < 30; j++) // 獵 30 輧. (溝湄)
+		{
+			string tempString2 = arInputString[j];
+			if (tempString2.compare(tempString) == 0) // 치求 확.
+			{
+				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
+			}
+
+			if (tempString2.compare("") == 0)
+				break;
+		}
+	}
+	delete[]arInputString;
+	// cout << "Immune : " << immuneStr << " -> " << retValue << endl;
+
+	return retValue;
+}
+
+int get_Item_LimitType_Value(string inputString)
+{
+	string arLimitType[] = {
+		"LIMIT_NONE",
+		"LEVEL",
+		"STR",
+		"DEX",
+		"INT",
+		"CON",
+		"REAL_TIME",
+		"REAL_TIME_FIRST_USE",
+		"TIMER_BASED_ON_WEAR",
+		"NEWWORLD_LEVEL",
+		"DURATION",
+	};
+
+	int retInt = -1;
+	// cout << "LimitType : " << limitTypeStr << " -> ";
+	for (int j = 0; j < sizeof(arLimitType) / sizeof(arLimitType[0]); j++)
+	{
+		string tempString = arLimitType[j];
+		string tempInputString = trim(inputString);
+		if (tempInputString.compare(tempString) == 0)
+		{
+			// cout << j << " ";
+			retInt = j;
+			break;
+		}
+	}
+	// cout << endl;
+
+	return retInt;
+}
+
+int get_Item_ApplyType_Value(string inputString)
+{
+	string arApplyType[] = {
+		"APPLY_NONE",
+		"APPLY_MAX_HP",
+		"APPLY_MAX_SP",
+		"APPLY_CON",
+		"APPLY_INT",
+		"APPLY_STR",
+		"APPLY_DEX",
+		"APPLY_ATT_SPEED",
+		"APPLY_MOV_SPEED",
+		"APPLY_CAST_SPEED",
+		"APPLY_HP_REGEN",
+		"APPLY_SP_REGEN",
+		"APPLY_POISON_PCT",
+		"APPLY_STUN_PCT",
+		"APPLY_SLOW_PCT",
+		"APPLY_CRITICAL_PCT",
+		"APPLY_PENETRATE_PCT",
+		"APPLY_ATTBONUS_HUMAN",
+		"APPLY_ATTBONUS_ANIMAL",
+		"APPLY_ATTBONUS_ORC",
+		"APPLY_ATTBONUS_MILGYO",
+		"APPLY_ATTBONUS_UNDEAD",
+		"APPLY_ATTBONUS_DEVIL",
+		"APPLY_STEAL_HP",
+		"APPLY_STEAL_SP",
+		"APPLY_MANA_BURN_PCT",
+		"APPLY_DAMAGE_SP_RECOVER",
+		"APPLY_BLOCK",
+		"APPLY_DODGE",
+		"APPLY_RESIST_SWORD",
+		"APPLY_RESIST_TWOHAND",
+		"APPLY_RESIST_DAGGER",
+		"APPLY_RESIST_BELL",
+		"APPLY_RESIST_FAN",
+		"APPLY_RESIST_BOW",
+		"APPLY_RESIST_FIRE",
+		"APPLY_RESIST_ELEC",
+		"APPLY_RESIST_MAGIC",
+		"APPLY_RESIST_WIND",
+		"APPLY_REFLECT_MELEE",
+		"APPLY_REFLECT_CURSE",
+		"APPLY_POISON_REDUCE",
+		"APPLY_KILL_SP_RECOVER",
+		"APPLY_EXP_DOUBLE_BONUS",
+		"APPLY_GOLD_DOUBLE_BONUS",
+		"APPLY_ITEM_DROP_BONUS",
+		"APPLY_POTION_BONUS",
+		"APPLY_KILL_HP_RECOVER",
+		"APPLY_IMMUNE_STUN",
+		"APPLY_IMMUNE_SLOW",
+		"APPLY_IMMUNE_FALL",
+		"APPLY_SKILL",
+		"APPLY_BOW_DISTANCE",
+		"APPLY_ATT_GRADE_BONUS",
+		"APPLY_DEF_GRADE_BONUS",
+		"APPLY_MAGIC_ATT_GRADE",
+		"APPLY_MAGIC_DEF_GRADE",
+		"APPLY_CURSE_PCT",
+		"APPLY_MAX_STAMINA",
+		"APPLY_ATTBONUS_WARRIOR",
+		"APPLY_ATTBONUS_ASSASSIN",
+		"APPLY_ATTBONUS_SURA",
+		"APPLY_ATTBONUS_SHAMAN",
+		"APPLY_ATTBONUS_MONSTER",
+		"APPLY_MALL_ATTBONUS",
+		"APPLY_MALL_DEFBONUS",
+		"APPLY_MALL_EXPBONUS",
+		"APPLY_MALL_ITEMBONUS",
+		"APPLY_MALL_GOLDBONUS",
+		"APPLY_MAX_HP_PCT",
+		"APPLY_MAX_SP_PCT",
+		"APPLY_SKILL_DAMAGE_BONUS",
+		"APPLY_NORMAL_HIT_DAMAGE_BONUS",
+		"APPLY_SKILL_DEFEND_BONUS",
+		"APPLY_NORMAL_HIT_DEFEND_BONUS",
+		"APPLY_PC_BANG_EXP_BONUS",
+		"APPLY_PC_BANG_DROP_BONUS",
+		"APPLY_EXTRACT_HP_PCT",
+		"APPLY_RESIST_WARRIOR",
+		"APPLY_RESIST_ASSASSIN",
+		"APPLY_RESIST_SURA",
+		"APPLY_RESIST_SHAMAN",
+		"APPLY_ENERGY",
+		"APPLY_DEF_GRADE",
+		"APPLY_COSTUME_ATTR_BONUS",
+		"APPLY_MAGIC_ATTBONUS_PER",
+		"APPLY_MELEE_MAGIC_ATTBONUS_PER",
+		"APPLY_RESIST_ICE",
+		"APPLY_RESIST_EARTH",
+		"APPLY_RESIST_DARK",
+		"APPLY_ANTI_CRITICAL_PCT",
+		"APPLY_ANTI_PENETRATE_PCT",
+		"APPLY_BLEEDING_REDUCE",
+		"APPLY_BLEEDING_PCT",
+		"APPLY_ATTBONUS_WOLFMAN",
+		"APPLY_RESIST_WOLFMAN",
+		"APPLY_RESIST_CLAW",
+		"APPLY_ACCEDRAIN_RATE",
+		"APPLY_RESIST_MAGIC_REDUCTION",
+		"APPLY_ENCHANT_ELECT",
+		"APPLY_ENCHANT_FIRE",
+		"APPLY_ENCHANT_ICE",
+		"APPLY_ENCHANT_WIND",
+		"APPLY_ENCHANT_EARTH",
+		"APPLY_ENCHANT_DARK",
+		"APPLY_ATTBONUS_CZ",
+		"APPLY_ATTBONUS_INSECT",
+		"APPLY_ATTBONUS_DESERT",
+		"APPLY_ATTBONUS_SWORD",
+		"APPLY_ATTBONUS_TWOHAND",
+		"APPLY_ATTBONUS_DAGGER",
+		"APPLY_ATTBONUS_BELL",
+		"APPLY_ATTBONUS_FAN",
+		"APPLY_ATTBONUS_BOW",
+		"APPLY_ATTBONUS_CLAW",
+		"APPLY_RESIST_HUMAN",
+		"APPLY_RESIST_MOUNT_FALL",
+		"APPLY_RESIST_FIST",
+		"APPLY_MOUNT",
+		"APPLY_SKILL_DAMAGE_SAMYEON",
+		"APPLY_SKILL_DAMAGE_TANHWAN",
+		"APPLY_SKILL_DAMAGE_PALBANG",
+		"APPLY_SKILL_DAMAGE_GIGONGCHAM",
+		"APPLY_SKILL_DAMAGE_GYOKSAN",
+		"APPLY_SKILL_DAMAGE_GEOMPUNG",
+		"APPLY_SKILL_DAMAGE_AMSEOP",
+		"APPLY_SKILL_DAMAGE_GUNGSIN",
+		"APPLY_SKILL_DAMAGE_CHARYUN",
+		"APPLY_SKILL_DAMAGE_SANGONG",
+		"APPLY_SKILL_DAMAGE_YEONSA",
+		"APPLY_SKILL_DAMAGE_KWANKYEOK",
+		"APPLY_SKILL_DAMAGE_GIGUNG",
+		"APPLY_SKILL_DAMAGE_HWAJO",
+		"APPLY_SKILL_DAMAGE_SWAERYUNG",
+		"APPLY_SKILL_DAMAGE_YONGKWON",
+		"APPLY_SKILL_DAMAGE_PABEOB",
+		"APPLY_SKILL_DAMAGE_MARYUNG",
+		"APPLY_SKILL_DAMAGE_HWAYEOMPOK",
+		"APPLY_SKILL_DAMAGE_MAHWAN",
+		"APPLY_SKILL_DAMAGE_BIPABU",
+		"APPLY_SKILL_DAMAGE_YONGBI",
+		"APPLY_SKILL_DAMAGE_PAERYONG",
+		"APPLY_SKILL_DAMAGE_NOEJEON",
+		"APPLY_SKILL_DAMAGE_BYEURAK",
+		"APPLY_SKILL_DAMAGE_CHAIN",
+		"APPLY_SKILL_DAMAGE_CHAYEOL",
+		"APPLY_SKILL_DAMAGE_SALPOONG",
+		"APPLY_SKILL_DAMAGE_GONGDAB",
+		"APPLY_SKILL_DAMAGE_PASWAE",
+		"APPLY_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE",
+		"APPLY_SKILL_DEFEND_BONUS_BOSS_OR_MORE",
+		"APPLY_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE",
+		"APPLY_SKILL_DAMAGE_BONUS_BOSS_OR_MORE",
+		"APPLY_HIT_BUFF_ENCHANT_FIRE",
+		"APPLY_HIT_BUFF_ENCHANT_ICE",
+		"APPLY_HIT_BUFF_ENCHANT_ELEC",
+		"APPLY_HIT_BUFF_ENCHANT_WIND",
+		"APPLY_HIT_BUFF_ENCHANT_DARK",
+		"APPLY_HIT_BUFF_ENCHANT_EARTH",
+		"APPLY_HIT_BUFF_RESIST_FIRE",
+		"APPLY_HIT_BUFF_RESIST_ICE",
+		"APPLY_HIT_BUFF_RESIST_ELEC",
+		"APPLY_HIT_BUFF_RESIST_WIND",
+		"APPLY_HIT_BUFF_RESIST_DARK",
+		"APPLY_HIT_BUFF_RESIST_EARTH",
+		"APPLY_USE_SKILL_CHEONGRANG_MOV_SPEED",
+		"APPLY_USE_SKILL_CHEONGRANG_CASTING_SPEED",
+		"APPLY_USE_SKILL_CHAYEOL_CRITICAL_PCT",
+		"APPLY_USE_SKILL_SANGONG_ATT_GRADE_BONUS",
+		"APPLY_USE_SKILL_GIGUNG_ATT_GRADE_BONUS",
+		"APPLY_USE_SKILL_JEOKRANG_DEF_BONUS",
+		"APPLY_USE_SKILL_GWIGEOM_DEF_BONUS",
+		"APPLY_USE_SKILL_TERROR_ATT_GRADE_BONUS",
+		"APPLY_USE_SKILL_MUYEONG_ATT_GRADE_BONUS",
+		"APPLY_USE_SKILL_MANASHILED_CASTING_SPEED",
+		"APPLY_USE_SKILL_HOSIN_DEF_BONUS",
+		"APPLY_USE_SKILL_GICHEON_ATT_GRADE_BONUS",
+		"APPLY_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS",
+		"APPLY_USE_SKILL_JEUNGRYEOK_DEF_BONUS",
+		"APPLY_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS",
+		"APPLY_USE_SKILL_CHUNKEON_CASTING_SPEED",
+		"APPLY_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS",
+		"APPLY_SKILL_DURATION_INCREASE_EUNHYUNG",
+		"APPLY_SKILL_DURATION_INCREASE_GYEONGGONG",
+		"APPLY_SKILL_DURATION_INCREASE_GEOMKYUNG",
+		"APPLY_SKILL_DURATION_INCREASE_JEOKRANG",
+		"APPLY_USE_SKILL_PALBANG_HP_ABSORB",
+		"APPLY_USE_SKILL_AMSEOP_HP_ABSORB",
+		"APPLY_USE_SKILL_YEONSA_HP_ABSORB",
+		"APPLY_USE_SKILL_YONGBI_HP_ABSORB",
+		"APPLY_USE_SKILL_CHAIN_HP_ABSORB",
+		"APPLY_USE_SKILL_PASWAE_SP_ABSORB",
+		"APPLY_USE_SKILL_GIGONGCHAM_STUN",
+		"APPLY_USE_SKILL_CHARYUN_STUN",
+		"APPLY_USE_SKILL_PABEOB_STUN",
+		"APPLY_USE_SKILL_MAHWAN_STUN",
+		"APPLY_USE_SKILL_GONGDAB_STUN",
+		"APPLY_USE_SKILL_SAMYEON_STUN",
+		"APPLY_USE_SKILL_GYOKSAN_KNOCKBACK",
+		"APPLY_USE_SKILL_SEOMJEON_KNOCKBACK",
+		"APPLY_USE_SKILL_SWAERYUNG_KNOCKBACK",
+		"APPLY_USE_SKILL_HWAYEOMPOK_KNOCKBACK",
+		"APPLY_USE_SKILL_GONGDAB_KNOCKBACK",
+		"APPLY_USE_SKILL_KWANKYEOK_KNOCKBACK",
+		"APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER",
+		"APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER",
+		"APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER",
+		"APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER",
+		"APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER",
+		"APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER",
+		"APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER",
+		"APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER",
+		"APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER",
+		"APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER",
+		"APPLY_ATTBONUS_STONE",
+		"APPLY_DAMAGE_HP_RECOVERY",
+		"APPLY_DAMAGE_SP_RECOVERY",
+		"APPLY_ALIGNMENT_DAMAGE_BONUS",
+		"APPLY_NORMAL_DAMAGE_GUARD",
+		"APPLY_MORE_THEN_HP90_DAMAGE_REDUCE",
+		"APPLY_USE_SKILL_TUSOK_HP_ABSORB",
+		"APPLY_USE_SKILL_PAERYONG_HP_ABSORB",
+		"APPLY_USE_SKILL_BYEURAK_HP_ABSORB",
+		"APPLY_FIRST_ATTRIBUTE_BONUS",
+		"APPLY_SECOND_ATTRIBUTE_BONUS",
+		"APPLY_THIRD_ATTRIBUTE_BONUS",
+		"APPLY_FOURTH_ATTRIBUTE_BONUS",
+		"APPLY_FIFTH_ATTRIBUTE_BONUS",
+		"APPLY_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER",
+		"APPLY_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER",
+		"APPLY_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER",
+		"APPLY_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER",
+		"APPLY_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER",
+		"APPLY_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER",
+		"APPLY_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER",
+		"APPLY_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER",
+		"APPLY_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER",
+		"APPLY_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER",
+		"APPLY_USE_SKILL_CHAYEOL_HP_ABSORB",
+		"APPLY_SUNGMA_STR",
+		"APPLY_SUNGMA_HP",
+		"APPLY_SUNGMA_MOVE",
+		"APPLY_SUNGMA_IMMUNE",
+		"APPLY_HIT_PCT",
+		"APPLY_RANDOM",
+		"APPLY_ATTBONUS_PER_HUMAN",
+		"APPLY_ATTBONUS_PER_ANIMAL",
+		"APPLY_ATTBONUS_PER_ORC",
+		"APPLY_ATTBONUS_PER_MILGYO",
+		"APPLY_ATTBONUS_PER_UNDEAD",
+		"APPLY_ATTBONUS_PER_DEVIL",
+		"APPLY_ENCHANT_PER_ELECT",
+		"APPLY_ENCHANT_PER_FIRE",
+		"APPLY_ENCHANT_PER_ICE",
+		"APPLY_ENCHANT_PER_WIND",
+		"APPLY_ENCHANT_PER_EARTH",
+		"APPLY_ENCHANT_PER_DARK",
+		"APPLY_ATTBONUS_PER_CZ",
+		"APPLY_ATTBONUS_PER_INSECT",
+		"APPLY_ATTBONUS_PER_DESERT",
+		"APPLY_ATTBONUS_PER_STONE",
+		"APPLY_ATTBONUS_PER_MONSTER",
+		"APPLY_RESIST_PER_HUMAN",
+		"APPLY_RESIST_PER_ICE",
+		"APPLY_RESIST_PER_DARK",
+		"APPLY_RESIST_PER_EARTH",
+		"APPLY_RESIST_PER_FIRE",
+		"APPLY_RESIST_PER_ELEC",
+		"APPLY_RESIST_PER_MAGIC",
+		"APPLY_RESIST_PER_WIND",
+		"APPLY_HIT_BUFF_SUNGMA_STR",
+		"APPLY_HIT_BUFF_SUNGMA_MOVE",
+		"APPLY_HIT_BUFF_SUNGMA_HP",
+		"APPLY_HIT_BUFF_SUNGMA_IMMUNE",
+		"APPLY_MOUNT_MELEE_MAGIC_ATTBONUS_PER",
+		"APPLY_DISMOUNT_MOVE_SPEED_BONUS_PER",
+		"APPLY_HIT_AUTO_HP_RECOVERY",
+		"APPLY_HIT_AUTO_SP_RECOVERY",
+		"APPLY_USE_SKILL_COOLTIME_DECREASE_ALL",
+		"APPLY_HIT_STONE_ATTBONUS_STONE",
+		"APPLY_HIT_STONE_DEF_GRADE_BONUS",
+		"APPLY_KILL_BOSS_ITEM_BONUS",
+		"APPLY_MOB_HIT_MOB_AGGRESSIVE",
+		"APPLY_NO_DEATH_AND_HP_RECOVERY30",
+		"APPLY_AUTO_PICKUP",
+		"APPLY_MOUNT_NO_KNOCKBACK",
+		"APPLY_SUNGMA_PER_STR",
+		"APPLY_SUNGMA_PER_HP",
+		"APPLY_SUNGMA_PER_MOVE",
+		"APPLY_SUNGMA_PER_IMMUNE",
+		"APPLY_IMMUNE_POISON100",
+		"APPLY_IMMUNE_BLEEDING100",
+		"APPLY_MONSTER_DEFEND_BONUS",
+	};
+
+	int retInt = -1;
+	// cout << "ApplyType : " << applyTypeStr << " -> ";
+	for (int j = 0; j < sizeof(arApplyType) / sizeof(arApplyType[0]); j++)
+	{
+		string tempString = arApplyType[j];
+		string tempInputString = trim(inputString);
+		if (tempInputString.compare(tempString) == 0)
+		{
+			// cout << j << " ";
+			retInt = j;
+			break;
+		}
+	}
+	// cout << endl;
+
+	return retInt;
+}
+
+// 莪 畇쨈.
+int get_Mob_Rank_Value(string inputString)
+{
+	string arRank[] = {
+		"PAWN",
+		"S_PAWN",
+		"KNIGHT",
+		"S_KNIGHT",
+		"BOSS",
+		"KING",
+	};
+
+	int retInt = -1;
+	// cout << "Rank : " << rankStr << " -> ";
+	for (int j = 0; j < sizeof(arRank) / sizeof(arRank[0]); j++)
+	{
+		string tempString = arRank[j];
+		string tempInputString = trim(inputString);
+		if (tempInputString.compare(tempString) == 0)
+		{
+			// cout << j << " ";
+			retInt = j;
+			break;
+		}
+	}
+	// cout << endl;
+
+	return retInt;
+}
+
+int get_Mob_Type_Value(string inputString)
+{
+	string arType[] = {
+		"MONSTER",
+		"NPC",
+		"STONE",
+		"WARP",
+		"DOOR",
+		"BUILDING",
+		"PC",
+		"POLYMORPH_PC",
+		"HORSE",
+		"GOTO",
+		"PET",
+		"PET_PAY",
+		"SHOP",
+		"OBJECT",
+	};
+
+	int retInt = -1;
+	// cout << "Type : " << typeStr << " -> ";
+	for (int j = 0; j < sizeof(arType) / sizeof(arType[0]); j++)
+	{
+		string tempString = arType[j];
+		string tempInputString = trim(inputString);
+		if (tempInputString.compare(tempString) == 0)
+		{
+			// cout << j << " ";
+			retInt = j;
+			break;
+		}
+	}
+	// cout << endl;
+
+	return retInt;
+}
+
+int get_Mob_BattleType_Value(string inputString)
+{
+	string arBattleType[] = {
+		"MELEE",
+		"RANGE",
+		"MAGIC",
+		"SPECIAL",
+		"POWER",
+		"TANKER",
+		"SUPER_POWER",
+		"SUPER_TANKER",
+	};
+
+	int retInt = -1;
+	// cout << "Battle Type : " << battleTypeStr << " -> ";
+	for (int j = 0; j < sizeof(arBattleType) / sizeof(arBattleType[0]); j++)
+	{
+		string tempString = arBattleType[j];
+		string tempInputString = trim(inputString);
+		if (tempInputString.compare(tempString) == 0)
+		{
+			// cout << j << " ";
+			retInt = j;
+			break;
+		}
+	}
+	// cout << endl;
+
+	return retInt;
+}
+
+int get_Mob_Size_Value(string inputString)
+{
+	string arSize[] = {
+		"SMALL",
+		"MEDIUM",
+		"BIG",
+	};
+
+	int retInt = 0;
+	// cout << "Size : " << sizeStr << " -> ";
+	for (int j = 0; j < sizeof(arSize) / sizeof(arSize[0]); j++)
+	{
+		string tempString = arSize[j];
+		string tempInputString = trim(inputString);
+		if (tempInputString.compare(tempString) == 0)
+		{
+			// cout << j << " ";
+			retInt = j + 1;
+			break;
+		}
+	}
+	// cout << endl;
+
+	return retInt;
+}
+
+int get_Mob_AIFlag_Value(string inputString)
+{
+	string arAIFlag[] = {
+		"AGGR",
+		"NOMOVE",
+		"COWARD",
+		"NOATTSHINSU",
+		"NOATTCHUNJO",
+		"NOATTJINNO",
+		"ATTMOB",
+		"BERSERK",
+		"STONESKIN",
+		"GODSPEED",
+		"DEATHBLOW",
+		"REVIVE",
+		"HEALER",
+		"COUNT",
+		"NORECOVERY",
+		"REFLECT",
+		"FALL",
+		"VIT",
+		"RATTSPEED",
+		"RCASTSPEED",
+		"RHP_REGEN",
+		"TIMEVIT",
+	};
+
+	int retValue = 0;
+	string* arInputString = StringSplit(inputString, ","); //    輧咀  瓦.
+	for (int i = 0; i < sizeof(arAIFlag) / sizeof(arAIFlag[0]); i++)
+	{
+		string tempString = arAIFlag[i];
+		for (int j = 0; j < 30; j++) // 獵 30 輧. (溝湄)
+		{
+			string tempString2 = arInputString[j];
+			if (tempString2.compare(tempString) == 0) // 치求 확.
+			{
+				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
+			}
+
+			if (tempString2.compare("") == 0)
+				break;
+		}
+	}
+	delete[]arInputString;
+	// cout << "AIFlag : " << aiFlagStr << " -> " << retValue << endl;
+
+	return retValue;
+}
+
+int get_Mob_RaceFlag_Value(string inputString)
+{
+	string arRaceFlag[] = {
+		"ANIMAL",
+		"UNDEAD",
+		"DEVIL",
+		"HUMAN",
+		"ORC",
+		"MILGYO",
+		"INSECT",
+		"DESERT",
+		"TREE",
+		"DECO",
+		"HIDE",
+		"ATT_CZ",
+		"AWEAKEN",
+		"SUNGMAHEE",
+		"OUTPOST",
+	};
+
+	int retValue = 0;
+	string* arInputString = StringSplit(inputString, ","); //    輧咀  瓦.
+	for (int i = 0; i < sizeof(arRaceFlag) / sizeof(arRaceFlag[0]); i++)
+	{
+		string tempString = arRaceFlag[i];
+		for (int j = 0; j < 30; j++) // 獵 30 輧. (溝湄)
+		{
+			string tempString2 = arInputString[j];
+			if (tempString2.compare(tempString) == 0) // 치求 확.
+			{
+				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
+			}
+
+			if (tempString2.compare("") == 0)
+				break;
+		}
+	}
+	delete[]arInputString;
+	// cout << "Race Flag : " << raceFlagStr << " -> " << retValue << endl;
+
+	return retValue;
+}
+
+int get_Mob_ImmuneFlag_Value(string inputString)
+{
+	string arImmuneFlag[] = {
+		"STUN",
+		"SLOW",
+		"FALL",
+		"CURSE",
+		"POISON",
+		"TERROR",
+		"REFLECT",
+	};
+
+	int retValue = 0;
+	string* arInputString = StringSplit(inputString, ","); //    輧咀  瓦.
+	for (int i = 0; i < sizeof(arImmuneFlag) / sizeof(arImmuneFlag[0]); i++)
+	{
+		string tempString = arImmuneFlag[i];
+		for (int j = 0; j < 30; j++) // 獵 30 輧. (溝湄)
+		{
+			string tempString2 = arInputString[j];
+			if (tempString2.compare(tempString) == 0) // 치求 확.
+			{
+				retValue = retValue + static_cast<int>(pow((float)2, (float)i));
+			}
+
+			if (tempString2.compare("") == 0)
+				break;
+		}
+	}
+	delete[]arInputString;
+	// cout << "Immune Flag : " << immuneFlagStr << " -> " << retValue << endl;
+
+	return retValue;
+}
+
+#ifndef __DUMP_PROTO__
+//  遣 娩.
+bool Set_Proto_Mob_Table(TMobTable* mobTable, cCsvTable& csvTable, std::map<int, const char*>& nameMap)
+{
+	int col = 0;
+
+	str_to_number(mobTable->dwVnum, csvTable.AsStringByIndex(col++));
+	strlcpy(mobTable->szName, csvTable.AsStringByIndex(col++), sizeof(mobTable->szName));
+
+	// 3.  見 羚殮.
+	map<int, const char*>::iterator it;
+	it = nameMap.find(mobTable->dwVnum);
+	if (it != nameMap.end())
+	{
+		const char* localeName = it->second;
+		strlcpy(mobTable->szLocaleName, localeName, sizeof(mobTable->szLocaleName));
+	}
+	else
+	{
+		strlcpy(mobTable->szLocaleName, mobTable->szName, sizeof(mobTable->szLocaleName));
+	}
+
+	// RANK
+	int rankValue = get_Mob_Rank_Value(csvTable.AsStringByIndex(col++));
+	mobTable->bRank = rankValue;
+
+	// TYPE
+	int typeValue = get_Mob_Type_Value(csvTable.AsStringByIndex(col++));
+	mobTable->bType = typeValue;
+
+	// BATTLE_TYPE
+	int battleTypeValue = get_Mob_BattleType_Value(csvTable.AsStringByIndex(col++));
+	mobTable->bBattleType = battleTypeValue;
+
+	str_to_number(mobTable->bLevel, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bScale, csvTable.AsStringByIndex(col++));
+
+	// SIZE
+	int sizeValue = get_Mob_Size_Value(csvTable.AsStringByIndex(col++));
+	mobTable->bSize = sizeValue;
+
+	// AI_FLAG
+	int aiFlagValue = get_Mob_AIFlag_Value(csvTable.AsStringByIndex(col++));
+	mobTable->dwAIFlag = aiFlagValue;
+
+	// MOUNT_CAPACITY;
+	col++;
+
+	// RACE_FLAG
+	int raceFlagValue = get_Mob_RaceFlag_Value(csvTable.AsStringByIndex(col++));
+	mobTable->dwRaceFlag = raceFlagValue;
+
+	// IMMUNE_FLAG
+	int immuneFlagValue = get_Mob_ImmuneFlag_Value(csvTable.AsStringByIndex(col++));
+	mobTable->dwImmuneFlag = immuneFlagValue;
+
+	str_to_number(mobTable->bEmpire, csvTable.AsStringByIndex(col++)); // col = 11
+
+	strlcpy(mobTable->szFolder, csvTable.AsStringByIndex(col++), sizeof(mobTable->szFolder));
+
+	str_to_number(mobTable->bOnClickType, csvTable.AsStringByIndex(col++));
+
+	str_to_number(mobTable->bStr, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bDex, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bCon, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bInt, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bSungMaStr, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bSungMaDex, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bSungMaCon, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bSungMaInt, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->dwDamageRange[0], csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->dwDamageRange[1], csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->dwMaxHP, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bRegenCycle, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bRegenPercent, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->dwGoldMin, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->dwGoldMax, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->dwExp, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->dwSungMaExp, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->wDef, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->sAttackSpeed, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->sMovingSpeed, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bAggressiveHPPct, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->wAggressiveSight, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->wAttackRange, csvTable.AsStringByIndex(col++));
+
+	str_to_number(mobTable->dwDropItemVnum, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->dwResurrectionVnum, csvTable.AsStringByIndex(col++));
+	for (int i = 0; i < MOB_ENCHANTS_MAX_NUM; ++i)
+		str_to_number(mobTable->cEnchants[i], csvTable.AsStringByIndex(col++));
+
+	for (int i = 0; i < MOB_RESISTS_MAX_NUM; ++i)
+		str_to_number(mobTable->cResists[i], csvTable.AsStringByIndex(col++));
+
+#if defined(__ELEMENT_SYSTEM__)
+	for (int i = 0; i < MOB_ELEMENT_MAX_NUM; ++i)
+		str_to_number(mobTable->cElements[i], csvTable.AsStringByIndex(col++));
+
+	str_to_number(mobTable->cResistDark, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->cResistIce, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->cResistEarth, csvTable.AsStringByIndex(col++));
+#endif
+
+	str_to_number(mobTable->fDamMultiply, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->dwSummonVnum, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->dwDrainSP, csvTable.AsStringByIndex(col++));
+
+	// MOB_COLOR
+	++col;
+
+	str_to_number(mobTable->dwPolymorphItemVnum, csvTable.AsStringByIndex(col++));
+
+	str_to_number(mobTable->Skills[0].bLevel, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->Skills[0].dwVnum, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->Skills[1].bLevel, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->Skills[1].dwVnum, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->Skills[2].bLevel, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->Skills[2].dwVnum, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->Skills[3].bLevel, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->Skills[3].dwVnum, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->Skills[4].bLevel, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->Skills[4].dwVnum, csvTable.AsStringByIndex(col++));
+
+	str_to_number(mobTable->bBerserkPoint, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bStoneSkinPoint, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bGodSpeedPoint, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bDeathBlowPoint, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bRevivePoint, csvTable.AsStringByIndex(col++));
+
+	str_to_number(mobTable->bHealPoint, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bRAttSpeedPoint, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bRCastSpeedPoint, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->bRHPRegenPoint, csvTable.AsStringByIndex(col++));
+	str_to_number(mobTable->fHitRange, csvTable.AsStringByIndex(col++));
+
+	sys_log(0, "MOB #%-5d %-24s level: %-3u rank: %u empire: %d", mobTable->dwVnum, mobTable->szLocaleName, mobTable->bLevel, mobTable->bRank, mobTable->bEmpire);
+
+	return true;
+}
+
+bool Set_Proto_Item_Table(TItemTable* itemTable, cCsvTable& csvTable, std::map<int, const char*>& nameMap)
+{
+	// vnum  vnum range 閨.
+	{
+		std::string s(csvTable.AsStringByIndex(0));
+		int pos = s.find("~");
+		// vnum 茄恙 '~' 摸 戟
+		if (std::string::npos == pos)
+		{
+			itemTable->dwVnum = atoi(s.c_str());
+			if (0 == itemTable->dwVnum)
+			{
+				printf("INVALID VNUM %s\n", s.c_str());
+				return false;
+			}
+			itemTable->dwVnumRange = 0;
+		}
+		else
+		{
+			std::string s_start_vnum(s.substr(0, pos));
+			std::string s_end_vnum(s.substr(pos + 1));
+
+			int start_vnum = atoi(s_start_vnum.c_str());
+			int end_vnum = atoi(s_end_vnum.c_str());
+			if (0 == start_vnum || (0 != end_vnum && end_vnum < start_vnum))
+			{
+				sys_err("INVALID VNUM %s", s.c_str());
+				return false;
+			}
+			itemTable->dwVnum = start_vnum;
+			itemTable->dwVnumRange = end_vnum - start_vnum;
+		}
+	}
+
+	int col = 1;
+
+	strlcpy(itemTable->szName, csvTable.AsStringByIndex(col++), sizeof(itemTable->szName));
+	//  見 羚殮.
+	std::map<int, const char*>::iterator it;
+	it = nameMap.find(itemTable->dwVnum);
+	if (it != nameMap.end())
+	{
+		const char* localeName = it->second;
+		strlcpy(itemTable->szLocaleName, localeName, sizeof(itemTable->szLocaleName));
+	}
+	else
+	{
+		strlcpy(itemTable->szLocaleName, itemTable->szName, sizeof(itemTable->szLocaleName));
+	}
+
+	itemTable->bType = get_Item_Type_Value(csvTable.AsStringByIndex(col++));
+	itemTable->bSubType = get_Item_SubType_Value(itemTable->bType, csvTable.AsStringByIndex(col++));
+	itemTable->bSize = atoi(csvTable.AsStringByIndex(col++));
+	itemTable->ullAntiFlags = get_Item_AntiFlag_Value(csvTable.AsStringByIndex(col++));
+	itemTable->dwFlags = get_Item_Flag_Value(csvTable.AsStringByIndex(col++));
+	itemTable->dwWearFlags = get_Item_WearFlag_Value(csvTable.AsStringByIndex(col++));
+	itemTable->dwImmuneFlag = get_Item_Immune_Value(csvTable.AsStringByIndex(col++));
+	itemTable->dwShopBuyPrice = atoi(csvTable.AsStringByIndex(col++));
+	itemTable->dwShopSellPrice = atoi(csvTable.AsStringByIndex(col++));
+	itemTable->dwRefinedVnum = atoi(csvTable.AsStringByIndex(col++));
+	itemTable->wRefineSet = atoi(csvTable.AsStringByIndex(col++));
+	itemTable->dw67AttrMaterial = atoi(csvTable.AsStringByIndex(col++));
+	itemTable->bAlterToMagicItemPct = atoi(csvTable.AsStringByIndex(col++));
+	itemTable->cLimitRealTimeFirstUseIndex = -1;
+	itemTable->cLimitTimerBasedOnWearIndex = -1;
+
+	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+	{
+		itemTable->aLimits[i].bType = get_Item_LimitType_Value(csvTable.AsStringByIndex(col++));
+		itemTable->aLimits[i].lValue = atoi(csvTable.AsStringByIndex(col++));
+
+		if (LIMIT_REAL_TIME_START_FIRST_USE == itemTable->aLimits[i].bType)
+			itemTable->cLimitRealTimeFirstUseIndex = (char)i;
+
+		if (LIMIT_TIMER_BASED_ON_WEAR == itemTable->aLimits[i].bType)
+			itemTable->cLimitTimerBasedOnWearIndex = (char)i;
+	}
+
+	for (int i = 0; i < ITEM_APPLY_MAX_NUM; ++i)
+	{
+		itemTable->aApplies[i].wType = get_Item_ApplyType_Value(csvTable.AsStringByIndex(col++));
+		itemTable->aApplies[i].lValue = atoi(csvTable.AsStringByIndex(col++));
+	}
+
+	for (int i = 0; i < ITEM_VALUES_MAX_NUM; ++i)
+		itemTable->alValues[i] = atoi(csvTable.AsStringByIndex(col++));
+
+	itemTable->bSpecular = atoi(csvTable.AsStringByIndex(col++));
+	itemTable->bGainSocketPct = atoi(csvTable.AsStringByIndex(col++));
+	itemTable->sAddonType = atoi(csvTable.AsStringByIndex(col++));
+
+	itemTable->bWeight = 0;
+
+	sys_log(0, "ITEM #%-5d %-24s", itemTable->dwVnum, itemTable->szLocaleName);
+
+	return true;
+}
+#endif
