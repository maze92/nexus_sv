diff --git a/server/metin2/Source/Server/game/src/battlepass_manager.cpp b/server/metin2/Source/Server/game/src/battlepass_manager.cpp
index f9dfb65..036f58b 100644
--- a/server/metin2/Source/Server/game/src/battlepass_manager.cpp
+++ b/server/metin2/Source/Server/game/src/battlepass_manager.cpp
@@ -1274,10 +1274,11 @@ void CBattlePassManager::BattlePassRequestOpen(LPCHARACTER pkChar, bool bAfterOp
 		return;
 	}
 	
-	if(get_dword_time() < pkChar->GetLastReciveExtBattlePassInfoTime())
+	const DWORD dwNow = get_dword_time();
+	if ((int)(dwNow - pkChar->GetLastReciveExtBattlePassInfoTime()) < 0)
 		return;
 	
-	pkChar->SetLastReciveExtBattlePassInfoTime(get_dword_time() + 1000);
+	pkChar->SetLastReciveExtBattlePassInfoTime(dwNow + 1000);
 	
 	{
 		// --- NORMAL
@@ -1298,7 +1299,7 @@ void CBattlePassManager::BattlePassRequestOpen(LPCHARACTER pkChar, bool bAfterOp
 				TPacketGCExtBattlePassGeneralInfo packet;
 				packet.bHeader = HEADER_GC_EXT_BATTLE_PASS_GENERAL_INFO;
 				packet.bBattlePassType = 1;
-				strcpy(packet.szSeasonName, season_name);
+				strlcpy(packet.szSeasonName, season_name, sizeof(packet.szSeasonName));
 				packet.dwBattlePassID = timeInfo[0].bBattlePassId;
 				packet.dwBattlePassStartTime = timeInfo[0].dwStartTime;
 				packet.dwBattlePassEndTime = timeInfo[0].dwEndTime;
@@ -1325,7 +1326,7 @@ void CBattlePassManager::BattlePassRequestOpen(LPCHARACTER pkChar, bool bAfterOp
 				TPacketGCExtBattlePassGeneralInfo packet;
 				packet.bHeader = HEADER_GC_EXT_BATTLE_PASS_GENERAL_INFO;
 				packet.bBattlePassType = 2;
-				strcpy(packet.szSeasonName, season_name);
+				strlcpy(packet.szSeasonName, season_name, sizeof(packet.szSeasonName));
 				packet.dwBattlePassID = timeInfo[0].bBattlePassId;
 				packet.dwBattlePassStartTime = timeInfo[0].dwStartTime;
 				packet.dwBattlePassEndTime = timeInfo[0].dwEndTime;
@@ -1352,7 +1353,7 @@ void CBattlePassManager::BattlePassRequestOpen(LPCHARACTER pkChar, bool bAfterOp
 				TPacketGCExtBattlePassGeneralInfo packet;
 				packet.bHeader = HEADER_GC_EXT_BATTLE_PASS_GENERAL_INFO;
 				packet.bBattlePassType = 3;
-				strcpy(packet.szSeasonName, season_name);
+				strlcpy(packet.szSeasonName, season_name, sizeof(packet.szSeasonName));
 				packet.dwBattlePassID = timeInfo[0].bBattlePassId;
 				packet.dwBattlePassStartTime = timeInfo[0].dwStartTime;
 				packet.dwBattlePassEndTime = timeInfo[0].dwEndTime;
@@ -1782,4 +1783,4 @@ bool CBattlePassManager::BattlePassMissionGetInfo(BYTE bBattlePassType, BYTE bMi
 		return false;
 	}
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/server/metin2/Source/Server/game/src/char.cpp b/server/metin2/Source/Server/game/src/char.cpp
index 1172fcc..f731b4a 100644
--- a/server/metin2/Source/Server/game/src/char.cpp
+++ b/server/metin2/Source/Server/game/src/char.cpp
@@ -288,6 +288,7 @@ void CHARACTER::Initialize()
 	m_pGuild = NULL;
 
 	m_pkChrTarget = NULL;
+	m_dwTargetVID = 0;
 
 #if defined(__CHANGE_LOOK_SYSTEM__)
 	m_pkChangeLook = nullptr;
@@ -350,6 +351,7 @@ void CHARACTER::Initialize()
 	SetPosition(POS_STANDING);
 
 	m_dwPlayStartTime = m_dwLastMoveTime = get_dword_time();
+	m_dwLastDiceTime = 0;
 #if defined(__LEFT_SEAT__)
 	m_dwLastRequestTime = get_dword_time();
 #endif
@@ -564,6 +566,8 @@ void CHARACTER::Initialize()
 	m_iSyncHackCount = 0;
 
 #ifdef ENABLE_EXTENDED_BATTLE_PASS
+	for (TPlayerExtBattlePassMission* pMission : m_listExtBattlePass)
+		delete pMission;
 	m_listExtBattlePass.clear();
 	m_bIsLoadedExtBattlePass = false;
 	m_dwLastReciveExtBattlePassInfoTime = 0;
@@ -634,6 +638,12 @@ void CHARACTER::Create(const char* c_pszName, DWORD vid, bool isPC)
 void CHARACTER::Destroy()
 {
 	CloseMyShop();
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	for (TPlayerExtBattlePassMission* pMission : m_listExtBattlePass)
+		delete pMission;
+	m_listExtBattlePass.clear();
+	m_bIsLoadedExtBattlePass = false;
+#endif
 #ifdef __OFFLINE_SHOP__
 	RemoveFromViewingOfflineShops();
 #endif
@@ -770,7 +780,7 @@ void CHARACTER::Destroy()
 				party->Quit(GetVID());
 		}
 
-		SetParty(NULL); // ¾ÈÇØµµ µÇÁö¸¸ ¾ÈÀüÇÏ°Ô.
+		SetParty(NULL); // Øµ  Ï°.
 	}
 
 	if (m_pkMobInst)
@@ -885,7 +895,7 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 {
 	if (!CanHandleItem())
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("´Ù¸¥ °Å·¡Áß(Ã¢°í,±³È¯,»óÁ¡)¿¡´Â °³ÀÎ»óÁ¡À» »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ù¸ Å·(Ã¢,È¯,) Î»   Ï´."));
 		return;
 	}
 
@@ -905,20 +915,20 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 
 	if (GetPart(PART_MAIN) > 2)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("°©¿ÊÀ» ¹þ¾î¾ß °³ÀÎ »óÁ¡À» ¿­ ¼ö ÀÖ½À´Ï´Ù."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("      Ö½Ï´."));
 		return;
 	}
 
-	if (GetMyShop()) // ÀÌ¹Ì ¼¥ÀÌ ¿­·Á ÀÖÀ¸¸é ´Ý´Â´Ù.
+	if (GetMyShop()) // Ì¹    Ý´Â´.
 	{
 		CloseMyShop();
 		return;
 	}
 
-	// ÁøÇàÁßÀÎ Äù½ºÆ®°¡ ÀÖÀ¸¸é »óÁ¡À» ¿­ ¼ö ¾ø´Ù.
+	//  Æ®     .
 	quest::PC* pPC = quest::CQuestManager::instance().GetPCForce(GetPlayerID());
 
-	// GetPCForce´Â NULLÀÏ ¼ö ¾øÀ¸¹Ç·Î µû·Î È®ÀÎÇÏÁö ¾ÊÀ½
+	// GetPCForce NULL  Ç·  È® 
 	if (pPC->IsRunning())
 		return;
 
@@ -946,7 +956,7 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 	if (GOLD_MAX <= nTotalMoney)
 	{
 		sys_err("[OVERFLOW_GOLD] Overflow (GOLD_MAX) id %u name %s", GetPlayerID(), GetName());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("20¾ï ³ÉÀ» ÃÊ°úÇÏ¿© »óÁ¡À» ¿­¼ö°¡ ¾ø½À´Ï´Ù"));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("20  Ê°Ï¿   Ï´"));
 		return;
 	}
 
@@ -969,7 +979,7 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 
 	if (CBanwordManager::instance().CheckString(m_stShopSign.c_str(), m_stShopSign.length()))
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ºñ¼Ó¾î³ª Àº¾î°¡ Æ÷ÇÔµÈ »óÁ¡ ÀÌ¸§À¸·Î »óÁ¡À» ¿­ ¼ö ¾ø½À´Ï´Ù."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¾î³ª î°¡ Ôµ  Ì¸    Ï´."));
 		return;
 	}
 
@@ -977,7 +987,7 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 #if defined(__CHEQUE_SYSTEM__)
 	std::map<DWORD, TItemPriceInfo> itemkind;
 #else
-	std::map<DWORD, DWORD> itemkind; // ¾ÆÀÌÅÛ Á¾·ùº° °¡°Ý, first: vnum, second: ´ÜÀÏ ¼ö·® °¡°Ý
+	std::map<DWORD, DWORD> itemkind; //   , first: vnum, second:   
 #endif
 	// END_OF_MYSHOP_PRICE_LIST
 
@@ -999,19 +1009,19 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 
 			if (item_table && (IS_SET(item_table->ullAntiFlags, ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_MYSHOP)))
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("À¯·áÈ­ ¾ÆÀÌÅÛÀº °³ÀÎ»óÁ¡¿¡¼­ ÆÇ¸ÅÇÒ ¼ö ¾ø½À´Ï´Ù."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("È­  Î» Ç¸  Ï´."));
 				return;
 			}
 
 			if (pkItem->IsEquipped() == true)
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀåºñÁßÀÎ ¾ÆÀÌÅÛÀº °³ÀÎ»óÁ¡¿¡¼­ ÆÇ¸ÅÇÒ ¼ö ¾ø½À´Ï´Ù."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Î» Ç¸  Ï´."));
 				return;
 			}
 
 			if (true == pkItem->isLocked())
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ç¿ëÁßÀÎ ¾ÆÀÌÅÛÀº °³ÀÎ»óÁ¡¿¡¼­ ÆÇ¸ÅÇÒ ¼ö ¾ø½À´Ï´Ù."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Î» Ç¸  Ï´."));
 				return;
 			}
 
@@ -1040,11 +1050,11 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 	}
 
 	// MYSHOP_PRICE_LIST
-	// º¸µû¸® °³¼ö¸¦ °¨¼Ò½ÃÅ²´Ù.
-	if (CountSpecifyItem(71049)) // ºñ´Ü º¸µû¸®´Â ¾ø¾ÖÁö ¾Ê°í °¡°ÝÁ¤º¸¸¦ ÀúÀåÇÑ´Ù.
+	//   Ò½Å².
+	if (CountSpecifyItem(71049)) //    Ê°  Ñ´.
 	{
 		//
-		// ¾ÆÀÌÅÛ °¡°ÝÁ¤º¸¸¦ ÀúÀåÇÏ±â À§ÇØ ¾ÆÀÌÅÛ °¡°ÝÁ¤º¸ ÆÐÅ¶À» ¸¸µé¾î DB Ä³½Ã¿¡ º¸³½´Ù.
+		//   Ï±    Å¶  DB Ä³Ã¿ .
 		//
 		TItemPriceListTable header;
 		memset(&header, 0, sizeof(TItemPriceListTable));
@@ -1067,18 +1077,22 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 			idx++;
 		}
 
-		db_clientdesc->DBPacket(HEADER_GD_MYSHOP_PRICELIST_UPDATE, GetDesc()->GetHandle(), &header, sizeof(TItemPriceListTable));
+		LPDESC d = GetDesc();
+		if (!d)
+			return;
+
+		db_clientdesc->DBPacket(HEADER_GD_MYSHOP_PRICELIST_UPDATE, d->GetHandle(), &header, sizeof(TItemPriceListTable));
 	}
 	// END_OF_MYSHOP_PRICE_LIST
 	else if (CountSpecifyItem(50200))
 		RemoveSpecifyItem(50200, 1);
 	else
-		return; // º¸µû¸®°¡ ¾øÀ¸¸é Áß´Ü.
+		return; //   ß´.
 
 	if (m_pkExchange)
 		m_pkExchange->Cancel();
 
-	TPacketGCShopSign p;
+	TPacketGCShopSign p{};
 
 	p.bHeader = HEADER_GC_SHOP_SIGN;
 	p.dwVID = GetVID();
@@ -1100,8 +1114,8 @@ void CHARACTER::OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE b
 	{
 		HorseSummon(false, true);
 	}
-	// new mount ÀÌ¿ë Áß¿¡, °³ÀÎ »óÁ¡ ¿­¸é ÀÚµ¿ unmount
-	// StopRidingÀ¸·Î ´º¸¶¿îÆ®±îÁö Ã³¸®ÇÏ¸é ÁÁÀºµ¥ ¿Ö ±×·¸°Ô ¾ÈÇØ³ù´ÂÁö ¾Ë ¼ö ¾ø´Ù.
+	// new mount Ì¿ ß¿,    Úµ unmount
+	// StopRiding Æ® Ã³Ï¸   ×· Ø³   .
 	else if (GetMountVnum())
 	{
 		RemoveAffect(AFFECT_MOUNT);
@@ -1125,7 +1139,7 @@ void CHARACTER::CloseMyShop()
 		SetMyPrivShopTabCount(1);
 #endif
 
-		TPacketGCShopSign p;
+		TPacketGCShopSign p{};
 
 		p.bHeader = HEADER_GC_SHOP_SIGN;
 		p.dwVID = GetVID();
@@ -1173,41 +1187,41 @@ void CHARACTER::Restart(BYTE bSubCMD)
 		{
 			if (IsHack())
 			{
-				// ¼ºÁö ¸ÊÀÏ°æ¿ì¿¡´Â Ã¼Å© ÇÏÁö ¾Ê´Â´Ù.
+				//  Ï°ì¿¡ Ã¼Å©  Ê´Â´.
 				if (false == CThreeWayWar::instance().IsSungZiMapIndex(GetMapIndex()))
 				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÁ÷ Àç½ÃÀÛ ÇÒ ¼ö ¾ø½À´Ï´Ù. (%dÃÊ ³²À½)", iTimeToDead - (180 - g_nPortalLimitTime)));
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´. (%d )", iTimeToDead - (180 - g_nPortalLimitTime)));
 					return;
 				}
 			}
 
 			if (iTimeToDead > 170)
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÁ÷ Àç½ÃÀÛ ÇÒ ¼ö ¾ø½À´Ï´Ù. (%dÃÊ ³²À½)", iTimeToDead - 170));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´. (%d )", iTimeToDead - 170));
 				return;
 			}
 		}
 	}
 
 	// PREVENT_HACK
-	// DESC : Ã¢°í, ±³È¯ Ã¢ ÈÄ Æ÷Å»À» »ç¿ëÇÏ´Â ¹ö±×¿¡ ÀÌ¿ëµÉ¼ö ÀÖ¾î¼­
-	// ÄðÅ¸ÀÓÀ» Ãß°¡
+	// DESC : Ã¢, È¯ Ã¢  Å» Ï´ ×¿ Ì¿É¼ Ö¾î¼­
+	// Å¸ ß°
 	if (bSubCMD == SCMD_RESTART_TOWN)
 	{
 		if (IsHack())
 		{
-			// ±æµå¸Ê, ¼ºÁö¸Ê¿¡¼­´Â Ã¼Å© ÇÏÁö ¾Ê´Â´Ù.
+			// , Ê¿ Ã¼Å©  Ê´Â´.
 			if ((!GetWarMap() || GetWarMap()->GetType() == GUILD_WAR_TYPE_FLAG) ||
 				false == CThreeWayWar::instance().IsSungZiMapIndex(GetMapIndex()))
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÁ÷ Àç½ÃÀÛ ÇÒ ¼ö ¾ø½À´Ï´Ù. (%dÃÊ ³²À½)", iTimeToDead - (180 - g_nPortalLimitTime)));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´. (%d )", iTimeToDead - (180 - g_nPortalLimitTime)));
 				return;
 			}
 		}
 
 		if (iTimeToDead > 173)
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÁ÷ ¸¶À»¿¡¼­ Àç½ÃÀÛ ÇÒ ¼ö ¾ø½À´Ï´Ù. (%d ÃÊ ³²À½)", iTimeToDead - 173));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("     Ï´. (%d  )", iTimeToDead - 173));
 			return;
 		}
 	}
@@ -1220,7 +1234,7 @@ void CHARACTER::Restart(BYTE bSubCMD)
 	StartRecoveryEvent();
 
 	// FORKED_LOAD
-	// DESC: »ï°Å¸® ÀüÅõ½Ã ºÎÈ°À» ÇÒ°æ¿ì ¸ÊÀÇ ÀÔ±¸°¡ ¾Æ´Ñ »ï°Å¸® ÀüÅõÀÇ ½ÃÀÛÁöÁ¡À¸·Î ÀÌµ¿ÇÏ°Ô µÈ´Ù.
+	// DESC: Å¸  È° Ò°  Ô± Æ´ Å¸   ÌµÏ° È´.
 	if (1 == quest::CQuestManager::instance().GetEventFlag("threeway_war"))
 	{
 		if (bSubCMD == SCMD_RESTART_TOWN || bSubCMD == SCMD_RESTART_HERE)
@@ -1239,12 +1253,12 @@ void CHARACTER::Restart(BYTE bSubCMD)
 				return;
 			}
 
-			// ¼ºÁö
+			// 
 			if (true == CThreeWayWar::instance().IsSungZiMapIndex(GetMapIndex()))
 			{
 				if (CThreeWayWar::instance().GetReviveTokenForPlayer(GetPlayerID()) <= 0)
 				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ºÁö¿¡¼­ ºÎÈ° ±âÈ¸¸¦ ¸ðµÎ ÀÒ¾ú½À´Ï´Ù! ¸¶À»·Î ÀÌµ¿ÇÕ´Ï´Ù!"));
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È° È¸  Ò¾Ï´!  ÌµÕ´Ï´!"));
 					WarpSet(EMPIRE_START_X(GetEmpire()), EMPIRE_START_Y(GetEmpire()));
 				}
 				else
@@ -1332,22 +1346,22 @@ void CHARACTER::Restart(BYTE bSubCMD)
 			sys_log(0, "do_restart: restart town");
 
 #if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-			if (GetGuildDragonLair())
-			{
-				const LPSECTREE_MAP pSectree = SECTREE_MANAGER::instance().GetMap(MAP_N_FLAME_DRAGON);
-				if (pSectree != NULL)
-				{
-					Show(GetMapIndex(),
-						pSectree->m_setting.iBaseX + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "x") * 100,
-						pSectree->m_setting.iBaseY + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "y") * 100, 0);
-					Stop();
-				}
-				else
-					CGuildDragonLairManager::Instance().Exit(this);
-
+			if (GetGuildDragonLair())
+			{
+				const LPSECTREE_MAP pSectree = SECTREE_MANAGER::instance().GetMap(MAP_N_FLAME_DRAGON);
+				if (pSectree != NULL)
+				{
+					Show(GetMapIndex(),
+						pSectree->m_setting.iBaseX + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "x") * 100,
+						pSectree->m_setting.iBaseY + GuildDragonLair_GetFactor(3, "PixelPosition", "InsideWatcher", "y") * 100, 0);
+					Stop();
+				}
+				else
+					CGuildDragonLairManager::Instance().Exit(this);
+
 				PointChange(POINT_HP, 50 - GetHP());
-				DeathPenalty(1);
-				return;
+				DeathPenalty(1);
+				return;
 			}
 #endif
 
@@ -1451,7 +1465,7 @@ void CHARACTER::RestartAtSamePos()
 	}
 }
 
-// Entity¿¡ ³»°¡ ³ªÅ¸³µ´Ù°í ÆÐÅ¶À» º¸³½´Ù.
+// Entity  Å¸Ù° Å¶ .
 void CHARACTER::EncodeInsertPacket(LPENTITY entity)
 {
 	LPDESC d;
@@ -1459,7 +1473,7 @@ void CHARACTER::EncodeInsertPacket(LPENTITY entity)
 	if (!(d = entity->GetDesc()))
 		return;
 
-	// ±æµåÀÌ¸§ ¹ö±× ¼öÁ¤ ÄÚµå
+	// Ì¸   Úµ
 	LPCHARACTER ch = (LPCHARACTER)entity;
 #ifdef __OFFLINE_SHOP__
 	if (IsNPC() && GetRaceNum() == COfflineShop::CLOSED_RACE) {
@@ -1474,7 +1488,7 @@ void CHARACTER::EncodeInsertPacket(LPENTITY entity)
 	}
 #endif
 	ch->SendGuildName(GetGuild());
-	// ±æµåÀÌ¸§ ¹ö±× ¼öÁ¤ ÄÚµå
+	// Ì¸   Úµ
 
 	TPacketGCCharacterAdd pack;
 
@@ -1656,7 +1670,7 @@ void CHARACTER::EncodeInsertPacket(LPENTITY entity)
 
 	if (GetMyShop())
 	{
-		TPacketGCShopSign p;
+		TPacketGCShopSign p{};
 		p.bHeader = HEADER_GC_SHOP_SIGN;
 		p.dwVID = GetVID();
 		strlcpy(p.szSign, m_stShopSign.c_str(), sizeof(p.szSign));
@@ -1776,8 +1790,8 @@ void CHARACTER::UpdatePacket()
 #endif
 	pack.bPKMode = m_bPKMode;
 	pack.dwMountVnum = GetMountVnum();
-#if defined(__LEFT_SEAT__)
-	pack.bLeftSeat = IsPC() ? LeftSeat() : false;
+#if defined(__LEFT_SEAT__)
+	pack.bLeftSeat = IsPC() ? LeftSeat() : false;
 #endif
 
 #if defined(__GUILD_LEADER_GRADE_NAME__)
@@ -1889,14 +1903,14 @@ void CHARACTER::SetPosition(int pos)
 		{
 			case POS_FIGHTING:
 				if (!IsState(m_stateBattle))
-					MonsterLog("[BATTLE] ½Î¿ì´Â »óÅÂ");
+					MonsterLog("[BATTLE] Î¿ ");
 
 				GotoState(m_stateBattle);
 				break;
 
 			default:
 				if (!IsState(m_stateIdle))
-					MonsterLog("[IDLE] ½¬´Â »óÅÂ");
+					MonsterLog("[IDLE]  ");
 
 				GotoState(m_stateIdle);
 				break;
@@ -2083,7 +2097,7 @@ void CHARACTER::FlushDelayedSaveItem()
 {
 	int i = 0;
 
-	// ÀúÀå ¾ÈµÈ ¼ÒÁöÇ°À» ÀüºÎ ÀúÀå½ÃÅ²´Ù.
+	//  Èµ Ç°  Å².
 	LPITEM item = nullptr;
 
 	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
@@ -2119,6 +2133,11 @@ void CHARACTER::Disconnect(const char* c_pszReason)
 
 	sys_log(0, "DISCONNECT: %s (%s)", GetName(), c_pszReason ? c_pszReason : "unset");
 
+	// Definitive PC-shop teardown on owner disconnect.
+	// CloseMyShop() will call CShopManager::DestroyPCShop(this) and null m_pkMyShop.
+	if (GetMyShop())
+		CloseMyShop();
+
 	if (GetShop())
 	{
 		GetShop()->RemoveGuest(this);
@@ -2177,7 +2196,19 @@ void CHARACTER::Disconnect(const char* c_pszReason)
 	}
 
 	if (GetGuild())
-		GetGuild()->LogoutMember(this);
+		GetGuild()->LogoutMember(this);	// Dungeon re-entry hardening: record disconnect inside dungeons and validate on login.
+	if (CDungeonManager::instance().FindByMapIndex(GetMapIndex()))
+	{
+		SetQuestFlag("dungeon_reentry.logout_time", get_global_time());
+		SetQuestFlag("dungeon_reentry.logout_map", GetMapIndex());
+	}
+	else
+	{
+		SetQuestFlag("dungeon_reentry.logout_time", 0);
+		SetQuestFlag("dungeon_reentry.logout_map", 0);
+	}
+
+
 
 	quest::CQuestManager::instance().LogoutPC(this);
 
@@ -2198,7 +2229,7 @@ void CHARACTER::Disconnect(const char* c_pszReason)
 	if (GetParty())
 		GetParty()->Unlink(this);
 
-	// Á×¾úÀ» ¶§ Á¢¼Ó²÷À¸¸é °æÇèÄ¡ ÁÙ°Ô ÇÏ±â
+	// ×¾  Ó² Ä¡ Ù° Ï±
 	if (IsStun() || IsDead())
 	{
 		DeathPenalty(0);
@@ -2215,7 +2246,7 @@ void CHARACTER::Disconnect(const char* c_pszReason)
 	SaveAffect();
 	m_bIsLoadedAffect = false;
 
-	m_bSkipSave = true; // ÀÌ ÀÌÈÄ¿¡´Â ´õÀÌ»ó ÀúÀåÇÏ¸é ¾ÈµÈ´Ù.
+	m_bSkipSave = true; //  Ä¿ Ì» Ï¸ ÈµÈ´.
 
 	quest::CQuestManager::instance().DisconnectPC(this);
 
@@ -2759,7 +2790,7 @@ void CHARACTER::SetPlayerProto(const TPlayerTable* t)
 	SetSP(t->sp);
 	SetStamina(t->stamina);
 
-	// GMÀÏ¶§ º¸È£¸ðµå
+	// GMÏ¶ È£
 	if (GetGMLevel() > GM_LOW_WIZARD)
 		m_afAffectFlag.Set(AFF_YMIR);
 
@@ -2785,7 +2816,7 @@ void CHARACTER::SetPlayerProto(const TPlayerTable* t)
 	}
 
 #if defined(__PET_SYSTEM__)
-	// NOTE: ÀÏ´Ü Ä³¸¯ÅÍ°¡ PCÀÎ °æ¿ì¿¡¸¸ PetSystemÀ» °®µµ·Ï ÇÔ. À¯·´ ¸Ó½Å´ç ¸Þ¸ð¸® »ç¿ë·ü¶§¹®¿¡ NPC±îÁö ÇÏ±ä Á»..
+	// NOTE: Ï´ Ä³Í° PC ì¿¡ PetSystem  .  Ó½Å´ Þ¸  NPC Ï± ..
 	if (m_petSystem)
 	{
 		m_petSystem->Destroy();
@@ -2881,9 +2912,9 @@ void CHARACTER::SetProto(const CMob* pkMob)
 		else
 			SetPoint(POINT_DEF_GRADE_BONUS, 15);
 
-		// »êÅ¸¿ë
+		// Å¸
 		//m_dwPlayStartTime = get_dword_time() + 10 * 60 * 1000;
-		// ½Å¼±ÀÚ ³ëÇØ
+		// Å¼ 
 		m_dwPlayStartTime = get_dword_time() + 30 * 1000;
 		if (test_server)
 			m_dwPlayStartTime = get_dword_time() + 30 * 1000;
@@ -2942,7 +2973,7 @@ const TMobTable& CHARACTER::GetMobTable() const
 BYTE CHARACTER::GetMobRank() const
 {
 	if (!m_pkMobData)
-		return MOB_RANK_KNIGHT; // PCÀÏ °æ¿ì KNIGHT±Þ
+		return MOB_RANK_KNIGHT; // PC  KNIGHT
 
 	return m_pkMobData->m_table.bRank;
 }
@@ -3018,7 +3049,7 @@ float CHARACTER::GetMobDamageMultiply() const
 	float fDamMultiply = GetMobTable().fDamMultiply;
 
 	if (IsBerserk())
-		fDamMultiply = fDamMultiply * 2.0f; // BALANCE: ±¤ÆøÈ­ ½Ã µÎ¹è
+		fDamMultiply = fDamMultiply * 2.0f; // BALANCE: È­  Î¹
 
 	return fDamMultiply;
 }
@@ -3112,7 +3143,7 @@ void CHARACTER::ComputeBattlePoints()
 		SetPoint(POINT_MAGIC_DEF_GRADE, GetPoint(POINT_DEF_GRADE));
 
 		//
-		// ±âº» ATK = 2lev + 2str, Á÷¾÷¿¡ ¸¶´Ù 2strÀº ¹Ù²ð ¼ö ÀÖÀ½
+		// âº» ATK = 2lev + 2str,   2str Ù²  
 		//
 		int iAtk = GetLevel() * 2;
 		int iStatAtk = 0;
@@ -3142,14 +3173,14 @@ void CHARACTER::ComputeBattlePoints()
 				break;
 		}
 
-		// ¸»À» Å¸°í ÀÖ°í, ½ºÅÈÀ¸·Î ÀÎÇÑ °ø°Ý·ÂÀÌ ST*2 º¸´Ù ³·À¸¸é ST*2·Î ÇÑ´Ù.
-		// ½ºÅÈÀ» Àß¸ø ÂïÀº »ç¶÷ °ø°Ý·ÂÀÌ ´õ ³·Áö ¾Ê°Ô ÇÏ±â À§ÇØ¼­´Ù.
+		//  Å¸ Ö°,   Ý· ST*2   ST*2 Ñ´.
+		//  ß¸   Ý·   Ê° Ï± Ø¼.
 		if (GetMountVnum() && iStatAtk < 2 * GetPoint(POINT_ST))
 			iStatAtk = (2 * GetPoint(POINT_ST));
 
 		iAtk += iStatAtk;
 
-		// ½Â¸¶(¸») : °Ë¼ö¶ó µ¥¹ÌÁö °¨¼Ò
+		// Â¸() : Ë¼  
 		if (GetMountVnum())
 		{
 			if (GetJob() == JOB_SURA && GetSkillGroup() == 1)
@@ -3170,7 +3201,7 @@ void CHARACTER::ComputeBattlePoints()
 		PointChange(POINT_ATT_GRADE, iAtk);
 
 		// DEF = LEV + CON + ARMOR
-		int iShowDef = GetLevel() + GetPoint(POINT_HT); // For Ymir(Ãµ¸¶)
+		int iShowDef = GetLevel() + GetPoint(POINT_HT); // For Ymir(Ãµ)
 		int iDef = GetLevel() + static_cast<int>((GetPoint(POINT_HT) / 1.25)); // For Other
 		int iArmor = 0;
 
@@ -3250,7 +3281,7 @@ void CHARACTER::ComputeBattlePoints()
 #endif
 		}
 
-		// ¸» Å¸°í ÀÖÀ» ¶§ ¹æ¾î·ÂÀÌ ¸»ÀÇ ±âÁØ ¹æ¾î·Âº¸´Ù ³·À¸¸é ±âÁØ ¹æ¾î·ÂÀ¸·Î ¼³Á¤
+		//  Å¸      Âº    
 		if (IsHorseRiding())
 		{
 			if (iArmor < GetHorseArmor())
@@ -3371,7 +3402,7 @@ void CHARACTER::ComputePoints()
 
 	if (IsPC())
 	{
-		// ÃÖ´ë »ý¸í·Â/Á¤½Å·Â
+		// Ö´ /Å·
 		iMaxHP = JobInitialPoints[GetJob()].max_hp + m_points.iRandomHP + GetPoint(POINT_HT) * JobInitialPoints[GetJob()].hp_per_ht;
 		iMaxSP = JobInitialPoints[GetJob()].max_sp + m_points.iRandomSP + GetPoint(POINT_IQ) * JobInitialPoints[GetJob()].sp_per_iq;
 		iMaxStamina = JobInitialPoints[GetJob()].max_stamina + GetPoint(POINT_HT) * JobInitialPoints[GetJob()].stamina_per_con;
@@ -3383,7 +3414,7 @@ void CHARACTER::ComputePoints()
 			iMaxHP += static_cast<int>(pkSk->kPointPoly.Eval());
 		}
 
-		// ±âº» °ªµé
+		// âº» 
 		SetPoint(POINT_MOV_SPEED, 100);
 		SetPoint(POINT_ATT_SPEED, 100);
 		PointChange(POINT_ATT_SPEED, GetPoint(POINT_PARTY_HASTE_BONUS));
@@ -3402,9 +3433,9 @@ void CHARACTER::ComputePoints()
 
 	if (IsPC())
 	{
-		// ¸» Å¸°í ÀÖÀ» ¶§´Â ±âº» ½ºÅÈÀÌ ¸»ÀÇ ±âÁØ ½ºÅÈº¸´Ù ³·À¸¸é ³ô°Ô ¸¸µç´Ù.
-		// µû¶ó¼­ ¸»ÀÇ ±âÁØ ½ºÅÈÀÌ ¹«»ç ±âÁØÀÌ¹Ç·Î, ¼ö¶ó/¹«´çÀº ÀüÃ¼ ½ºÅÈ ÇÕÀÌ
-		// ´ëÃ¤ÀûÀ¸·Î ´õ ¿Ã¶ó°¡°Ô µÉ °ÍÀÌ´Ù.
+		//  Å¸   âº»    Èº   .
+		//      Ì¹Ç·, / Ã¼  
+		// Ã¤  Ã¶ó°¡°  Ì´.
 		if (GetMountVnum())
 		{
 			if (GetHorseST() > GetPoint(POINT_ST))
@@ -3423,13 +3454,13 @@ void CHARACTER::ComputePoints()
 
 	ComputeBattlePoints();
 
-	// ±âº» HP/SP ¼³Á¤
+	// âº» HP/SP 
 	if (iMaxHP != GetMaxHP())
-		SetRealPoint(POINT_MAX_HP, iMaxHP); // ±âº»HP¸¦ RealPoint¿¡ ÀúÀåÇØ ³õ´Â´Ù.
+		SetRealPoint(POINT_MAX_HP, iMaxHP); // âº»HP RealPoint  Â´.
 	PointChange(POINT_MAX_HP, 0);
 
 	if (iMaxSP != GetMaxSP())
-		SetRealPoint(POINT_MAX_SP, iMaxSP); // ±âº»SP¸¦ RealPoint¿¡ ÀúÀåÇØ ³õ´Â´Ù.
+		SetRealPoint(POINT_MAX_SP, iMaxSP); // âº»SP RealPoint  Â´.
 	PointChange(POINT_MAX_SP, 0);
 
 	SetMaxStamina(iMaxStamina);
@@ -3446,10 +3477,10 @@ void CHARACTER::ComputePoints()
 		}
 	}
 
-	// ¿ëÈ¥¼® ½Ã½ºÅÛ
-	// ComputePoints¿¡¼­´Â ÄÉ¸¯ÅÍÀÇ ¸ðµç ¼Ó¼º°ªÀ» ÃÊ±âÈ­ÇÏ°í,
-	// ¾ÆÀÌÅÛ, ¹öÇÁ µî¿¡ °ü·ÃµÈ ¸ðµç ¼Ó¼º°ªÀ» Àç°è»êÇÏ±â ¶§¹®¿¡,
-	// ¿ëÈ¥¼® ½Ã½ºÅÛµµ ActiveDeck¿¡ ÀÖ´Â ¸ðµç ¿ëÈ¥¼®ÀÇ ¼Ó¼º°ªÀ» ´Ù½Ã Àû¿ë½ÃÄÑ¾ß ÇÑ´Ù.
+	// È¥ Ã½
+	// ComputePoints É¸  Ó¼ Ê±È­Ï°,
+	// ,  î¿¡ Ãµ  Ó¼ Ï± ,
+	// È¥ Ã½Ûµ ActiveDeck Ö´  È¥ Ó¼ Ù½ Ñ¾ Ñ´.
 #if defined(__DRAGON_SOUL_SYSTEM__)
 	if (DragonSoul_IsDeckActivated())
 	{
@@ -3505,9 +3536,9 @@ void CHARACTER::ComputePoints()
 	UpdatePacket();
 }
 
-// m_dwPlayStartTimeÀÇ ´ÜÀ§´Â milisecond´Ù. µ¥ÀÌÅÍº£ÀÌ½º¿¡´Â ºÐ´ÜÀ§·Î ±â·ÏÇÏ±â
-// ¶§¹®¿¡ ÇÃ·¹ÀÌ½Ã°£À» °è»êÇÒ ¶§ / 60000 À¸·Î ³ª´²¼­ ÇÏ´Âµ¥, ±× ³ª¸ÓÁö °ªÀÌ ³²¾Ò
-// À» ¶§ ¿©±â¿¡ dwTimeRemainÀ¸·Î ³Ö¾î¼­ Á¦´ë·Î °è»êµÇµµ·Ï ÇØÁÖ¾î¾ß ÇÑ´Ù.
+// m_dwPlayStartTime  milisecond. ÍºÌ½ Ð´ Ï±
+//  Ã·Ì½Ã°   / 60000   Ï´Âµ,    
+//   â¿¡ dwTimeRemain Ö¾î¼­  Çµ Ö¾ Ñ´.
 void CHARACTER::ResetPlayTime(DWORD dwTimeRemain)
 {
 	m_dwPlayStartTime = get_dword_time() - dwTimeRemain;
@@ -3532,7 +3563,7 @@ EVENTFUNC(recovery_event)
 	if (!ch->IsPC())
 	{
 		//
-		// ¸ó½ºÅÍ È¸º¹
+		//  È¸
 		//
 		if (ch->IsAffectFlag(AFF_POISON))
 			return PASSES_PER_SEC(MAX(1, ch->GetMobTable().bRegenCycle));
@@ -3613,16 +3644,16 @@ EVENTFUNC(recovery_event)
 	else
 	{
 		//
-		// PC È¸º¹
+		// PC È¸
 		//
 		ch->CheckTarget();
-		//ch->UpdateSectree(); // ¿©±â¼­ ÀÌ°É ¿ÖÇÏÁö?
+		//ch->UpdateSectree(); // â¼­ Ì° ?
 		ch->UpdateKillerMode();
 
 		if (ch->IsAffectFlag(AFF_POISON) == true)
 		{
-			// Áßµ¶ÀÎ °æ¿ì ÀÚµ¿È¸º¹ ±ÝÁö
-			// ÆÄ¹ý¼úÀÎ °æ¿ì ÀÚµ¿È¸º¹ ±ÝÁö
+			// ßµ  ÚµÈ¸ 
+			// Ä¹  ÚµÈ¸ 
 			return 3;
 		}
 
@@ -3631,8 +3662,8 @@ EVENTFUNC(recovery_event)
 
 		int iSec = (get_dword_time() - ch->GetLastMoveTime()) / 3000;
 
-		// SP È¸º¹ ·çÆ¾.
-		// ¿Ö ÀÌ°É·Î ÇØ¼­ ÇÔ¼ö·Î »©³ù´Â°¡ ?!
+		// SP È¸ Æ¾.
+		//  Ì°É· Ø¼ Ô¼ Â° ?!
 		ch->DistributeSP(ch);
 
 		if (ch->GetMaxHP() <= ch->GetHP())
@@ -3663,7 +3694,7 @@ void CHARACTER::StartRecoveryEvent()
 	if (IsDead() || IsStun())
 		return;
 
-	if (IsNPC() && GetHP() >= GetMaxHP()) // ¸ó½ºÅÍ´Â Ã¼·ÂÀÌ ´Ù Â÷ÀÖÀ¸¸é ½ÃÀÛ ¾ÈÇÑ´Ù.
+	if (IsNPC() && GetHP() >= GetMaxHP()) // Í´ Ã¼    Ñ´.
 		return;
 
 	if (IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_NORECOVERY))
@@ -3715,7 +3746,7 @@ void CHARACTER::SetRotation(float fRot)
 	m_pointsInstant.fRot = fRot;
 }
 
-// x, y ¹æÇâÀ¸·Î º¸°í ¼±´Ù.
+// x, y   .
 void CHARACTER::SetRotationToXY(long x, long y)
 {
 	SetRotation(GetDegreeFromPositionXY(GetX(), GetY(), x, y));
@@ -3731,17 +3762,17 @@ bool CHARACTER::CanMove() const
 	if (CannotMoveByAffect())
 		return false;
 
-	if (GetMyShop()) // »óÁ¡ ¿¬ »óÅÂ¿¡¼­´Â ¿òÁ÷ÀÏ ¼ö ¾øÀ½
+	if (GetMyShop()) //   Â¿   
 		return false;
 
-	// 0.2ÃÊ ÀüÀÌ¶ó¸é ¿òÁ÷ÀÏ ¼ö ¾ø´Ù.
+	// 0.2 Ì¶   .
 	//if (get_float_time() - m_fSyncTime < 0.2f)
 	//	return false;
 
 	return true;
 }
 
-// ¹«Á¶°Ç x, y À§Ä¡·Î ÀÌµ¿ ½ÃÅ²´Ù.
+//  x, y Ä¡ Ìµ Å².
 bool CHARACTER::Sync(long x, long y)
 {
 	if (!GetSectree())
@@ -3772,7 +3803,7 @@ bool CHARACTER::Sync(long x, long y)
 
 	if (GetDungeon())
 	{
-		// ´øÁ¯¿ë ÀÌº¥Æ® ¼Ó¼º º¯È­
+		//  ÌºÆ® Ó¼ È­
 		int iLastEventAttr = m_iEventAttr;
 		m_iEventAttr = new_tree->GetEventAttribute(x, y);
 
@@ -3823,7 +3854,7 @@ bool CHARACTER::Sync(long x, long y)
 void CHARACTER::Stop()
 {
 	if (!IsState(m_stateIdle))
-		MonsterLog("[IDLE] Á¤Áö");
+		MonsterLog("[IDLE] ");
 
 	GotoState(m_stateIdle);
 
@@ -3833,8 +3864,8 @@ void CHARACTER::Stop()
 
 bool CHARACTER::Goto(long x, long y)
 {
-	// TODO °Å¸®Ã¼Å© ÇÊ¿ä
-	// °°Àº À§Ä¡¸é ÀÌµ¿ÇÒ ÇÊ¿ä ¾øÀ½ (ÀÚµ¿ ¼º°ø)
+	// TODO Å¸Ã¼Å© Ê¿
+	//  Ä¡ Ìµ Ê¿  (Úµ )
 	if (GetX() == x && GetY() == y)
 		return false;
 
@@ -3967,17 +3998,17 @@ void CHARACTER::CalculateMoveDuration()
 	m_dwMoveStartTime = get_dword_time();
 }
 
-// x y À§Ä¡·Î ÀÌµ¿ ÇÑ´Ù. (ÀÌµ¿ÇÒ ¼ö ÀÖ´Â °¡ ¾ø´Â °¡¸¦ È®ÀÎ ÇÏ°í Sync ¸Þ¼Òµå·Î ½ÇÁ¦ ÀÌµ¿ ÇÑ´Ù)
-// ¼­¹ö´Â charÀÇ x, y °ªÀ» ¹Ù·Î ¹Ù²ÙÁö¸¸,
-// Å¬¶ó¿¡¼­´Â ÀÌÀü À§Ä¡¿¡¼­ ¹Ù²Û x, y±îÁö interpolationÇÑ´Ù.
-// °È°Å³ª ¶Ù´Â °ÍÀº charÀÇ m_bNowWalking¿¡ ´Þ·ÁÀÖ´Ù.
-// Warp¸¦ ÀÇµµÇÑ °ÍÀÌ¶ó¸é Show¸¦ »ç¿ëÇÒ °Í.
+// x y Ä¡ Ìµ Ñ´. (Ìµ  Ö´    È® Ï° Sync Þ¼Òµ  Ìµ Ñ´)
+//  char x, y  Ù· Ù²,
+// Å¬ó¿¡¼  Ä¡ Ù² x, y interpolationÑ´.
+// È°Å³ Ù´  char m_bNowWalking Þ·Ö´.
+// Warp Çµ Ì¶ Show  .
 bool CHARACTER::Move(long x, long y)
 {
 	if (IsPC() && IsDead())
 		return false;
 
-	// °°Àº À§Ä¡¸é ÀÌµ¿ÇÒ ÇÊ¿ä ¾øÀ½ (ÀÚµ¿ ¼º°ø)
+	//  Ä¡ Ìµ Ê¿  (Úµ )
 	if (GetX() == x && GetY() == y)
 		return true;
 
@@ -4171,7 +4202,7 @@ void CHARACTER::SetPoint(POINT_TYPE wPointType, POINT_VALUE lPointValue)
 
 	m_pointsInstant.points[wPointType] = lPointValue;
 
-	// ¾ÆÁ÷ ÀÌµ¿ÀÌ ´Ù ¾È³¡³µ´Ù¸é ÀÌµ¿ ½Ã°£ °è»êÀ» ´Ù½Ã ÇØ¾ß ÇÑ´Ù.
+	//  Ìµ  È³Ù¸ Ìµ Ã°  Ù½ Ø¾ Ñ´.
 	if (wPointType == POINT_MOV_SPEED && get_dword_time() < m_dwMoveStartTime + m_dwMoveDuration)
 	{
 		CalculateMoveDuration();
@@ -4218,7 +4249,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 
 			sys_log(0, "LEVELUP: %s %d NEXT EXP %d", GetName(), GetLevel(), GetNextExp());
 
-			// WOLFMAN ¼öÀÎÁ· Æ¯¼öÃ³¸® (¼öÀÎÁ·Àº Á÷±ºÀÌ ÇÏ³ªÀÌ¹Ç·Î, 5·¹º§ÀÌ µÇ¸é ¹«Á¶°Ç 1¹ø Á÷±ºÀ¸·Î ¼³Á¤ÇÔ. ÇÏµåÄÚµù ¤¸¤µ)
+			// WOLFMAN  Æ¯Ã³ (  Ï³Ì¹Ç·, 5 Ç¸  1  . ÏµÚµ )
 			if (GetJob() == JOB_WOLFMAN)
 			{
 				if ((5 <= val) && (GetSkillGroup() != 1))
@@ -4257,7 +4288,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 		case POINT_NEXT_EXP:
 		{
 			val = GetNextExp();
-			bAmount = false; // ¹«Á¶°Ç bAmount´Â false ¿©¾ß ÇÑ´Ù.
+			bAmount = false; //  bAmount false  Ñ´.
 		} break;
 
 		case POINT_EXP:
@@ -4265,7 +4296,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 			DWORD exp = GetExp();
 			DWORD next_exp = GetNextExp();
 
-			// exp°¡ 0 ÀÌÇÏ·Î °¡Áö ¾Êµµ·Ï ÇÑ´Ù
+			// exp 0 Ï·  Êµ Ñ´
 			if (amount < 0 && exp <= -amount)
 			{
 				sys_log(0, "%s - Reduce EXP by %d, CUR EXP: %d (setting to zero)", GetName(), -amount, exp);
@@ -4286,14 +4317,14 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 #endif
 
 #if defined(__CHATTING_WINDOW_RENEWAL__)
-				ChatPacket(CHAT_TYPE_EXP_INFO, LC_STRING("%dÀÇ °æÇèÄ¡¸¦ È¹µæÇß½À´Ï´Ù.", amount));
+				ChatPacket(CHAT_TYPE_EXP_INFO, LC_STRING("%d Ä¡ È¹ß½Ï´.", amount));
 #else
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("%dÀÇ °æÇèÄ¡¸¦ È¹µæÇß½À´Ï´Ù.", amount));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d Ä¡ È¹ß½Ï´.", amount));
 #endif
 
 				DWORD iExpBalance = 0;
 
-				// ·¹º§ ¾÷!
+				//  !
 				if (exp + amount >= next_exp)
 				{
 					iExpBalance = (exp + amount) - next_exp;
@@ -4326,7 +4357,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 				DWORD q = DWORD(next_exp / 4.0f);
 				int iLevStep = GetRealPoint(POINT_LEVEL_STEP);
 
-				// iLevStepÀÌ 4 ÀÌ»óÀÌ¸é ·¹º§ÀÌ ¿Ã¶ú¾î¾ß ÇÏ¹Ç·Î ¿©±â¿¡ ¿Ã ¼ö ¾ø´Â °ªÀÌ´Ù.
+				// iLevStep 4 Ì»Ì¸  Ã¶ Ï¹Ç· â¿¡    Ì´.
 				if (iLevStep >= 4)
 				{
 					sys_err("%s LEVEL_STEP bigger than 4! (%d)", GetName(), iLevStep);
@@ -4429,15 +4460,37 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 
 		case POINT_HP:
 		{
-			if (IsDead() || IsStun())
+			if (IsDead())
+				return;
+
+			// Allow damage while stunned; only block healing to avoid odd client states.
+			if (amount > 0 && IsStun())
 				return;
 
 			int prev_hp = GetHP();
 
 			amount = MIN(GetMaxHP() - GetHP(), amount);
 			SetHP(GetHP() + amount);
+
+			// [Fix] If HP reaches 0 or below, force death immediately (prevents 0 HP immortality under lag)
+			if (GetHP() <= 0)
+			{
+				SetHP(0);
+				val = 0;
+				Dead();
+				return;
+			}
+			SetHP(GetHP() + amount);
 			val = GetHP();
 
+			// [Fix] 0 HP glitch: force death immediately when HP drops to 0 or below.
+			if (val <= 0)
+			{
+				SetHP(0);
+				Dead();
+				return;
+			}
+
 			BroadcastTargetPacket();
 
 			if (GetParty() && IsPC() && val != prev_hp)
@@ -4468,16 +4521,16 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 
 			if (val == 0)
 			{
-				// Stamina°¡ ¾øÀ¸´Ï °ÈÀÚ!
+				// Stamina  !
 				SetNowWalking(true);
 			}
 			else if (prev_val == 0)
 			{
-				// ¾ø´ø ½ºÅ×¹Ì³ª°¡ »ý°åÀ¸´Ï ÀÌÀü ¸ðµå º¹±Í
+				//  ×¹Ì³    
 				ResetWalking();
 			}
 
-			if (amount < 0 && val != 0) // °¨¼Ò´Â º¸³»Áö¾Ê´Â´Ù.
+			if (amount < 0 && val != 0) // Ò´ Ê´Â´.
 				return;
 		}
 		break;
@@ -4487,7 +4540,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 			SetPoint(type, GetPoint(type) + amount);
 
 			//SetMaxHP(GetMaxHP() + amount);
-			// ÃÖ´ë »ý¸í·Â = (±âº» ÃÖ´ë »ý¸í·Â + Ãß°¡) * ÃÖ´ë»ý¸í·Â%
+			// Ö´  = (âº» Ö´  + ß°) * Ö´%
 			int curMaxHP = GetMaxHP();
 			int hp = GetRealPoint(POINT_MAX_HP);
 			int add_hp = MIN(3500, hp * GetPoint(POINT_MAX_HP_PCT) / 100);
@@ -4517,7 +4570,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 			SetPoint(type, GetPoint(type) + amount);
 
 			//SetMaxSP(GetMaxSP() + amount);
-			// ÃÖ´ë Á¤½Å·Â = (±âº» ÃÖ´ë Á¤½Å·Â + Ãß°¡) * ÃÖ´ëÁ¤½Å·Â%
+			// Ö´ Å· = (âº» Ö´ Å· + ß°) * Ö´Å·%
 			int curMaxSP = GetMaxSP();
 			int sp = GetRealPoint(POINT_MAX_SP);
 			int add_sp = MIN(800, sp * GetPoint(POINT_MAX_SP_PCT) / 100);
@@ -4620,12 +4673,12 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 		case POINT_HP_RECOVERY:
 		case POINT_SP_RECOVERY:
 
-		case POINT_ATTBONUS_HUMAN: // 42 ÀÎ°£¿¡°Ô °­ÇÔ
-		case POINT_ATTBONUS_ANIMAL: // 43 µ¿¹°¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-		case POINT_ATTBONUS_ORC: // 44 ¿õ±Í¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-		case POINT_ATTBONUS_MILGYO: // 45 ¹Ð±³¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-		case POINT_ATTBONUS_UNDEAD: // 46 ½ÃÃ¼¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-		case POINT_ATTBONUS_DEVIL: // 47 ¸¶±Í(¾Ç¸¶)¿¡°Ô µ¥¹ÌÁö % Áõ°¡
+		case POINT_ATTBONUS_HUMAN: // 42 Î° 
+		case POINT_ATTBONUS_ANIMAL: // 43   % 
+		case POINT_ATTBONUS_ORC: // 44 Í¿  % 
+		case POINT_ATTBONUS_MILGYO: // 45 Ð±  % 
+		case POINT_ATTBONUS_UNDEAD: // 46 Ã¼  % 
+		case POINT_ATTBONUS_DEVIL: // 47 (Ç¸)  % 
 		case POINT_ATTBONUS_INSECT:
 		case POINT_ATTBONUS_DESERT:
 
@@ -4651,11 +4704,11 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 		case POINT_RESIST_PENETRATE:
 		case POINT_CURSE_PCT:
 
-		case POINT_STEAL_HP: // 48 »ý¸í·Â Èí¼ö
-		case POINT_STEAL_SP: // 49 Á¤½Å·Â Èí¼ö
+		case POINT_STEAL_HP: // 48  
+		case POINT_STEAL_SP: // 49 Å· 
 
-		case POINT_MANA_BURN_PCT: // 50 ¸¶³ª ¹ø
-		case POINT_DAMAGE_SP_RECOVER: // 51 °ø°Ý´çÇÒ ½Ã Á¤½Å·Â È¸º¹ È®·ü
+		case POINT_MANA_BURN_PCT: // 50  
+		case POINT_DAMAGE_SP_RECOVER: // 51 Ý´  Å· È¸ È®
 		case POINT_RESIST_NORMAL_DAMAGE:
 		case POINT_RESIST_SWORD:
 		case POINT_RESIST_TWOHAND:
@@ -4675,12 +4728,12 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 		case POINT_RESIST_ICE:
 		case POINT_RESIST_EARTH:
 		case POINT_RESIST_DARK:
-		case POINT_REFLECT_MELEE: // 67 °ø°Ý ¹Ý»ç
-		case POINT_REFLECT_CURSE: // 68 ÀúÁÖ ¹Ý»ç
-		case POINT_POISON_REDUCE: // 69 µ¶µ¥¹ÌÁö °¨¼Ò
+		case POINT_REFLECT_MELEE: // 67  Ý»
+		case POINT_REFLECT_CURSE: // 68  Ý»
+		case POINT_POISON_REDUCE: // 69  
 		case POINT_BLEEDING_REDUCE:
 
-		case POINT_KILL_SP_RECOVER: // 70 Àû ¼Ò¸ê½Ã MP È¸º¹
+		case POINT_KILL_SP_RECOVER: // 70  Ò¸ MP È¸
 		case POINT_KILL_HP_RECOVERY: // 75
 		case POINT_HIT_HP_RECOVERY:
 		case POINT_HIT_SP_RECOVERY:
@@ -5181,7 +5234,7 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 
 				DWORD iExpBalance = 0;
 
-				// ·¹º§ ¾÷!
+				//  !
 				if (exp + amount >= next_exp)
 				{
 					iExpBalance = (exp + amount) - next_exp;
@@ -5307,6 +5360,31 @@ void CHARACTER::PointChange(POINT_TYPE type, POINT_VALUE amount, bool bAmount, b
 			sys_err("CHARACTER::PointChange: %s: unknown point change type %d", GetName(), type);
 			return;
 	}
+	// [Security] If base stats drop, force-unequip items that no longer meet requirements.
+	if ((type == POINT_ST || type == POINT_HT || type == POINT_DX || type == POINT_IQ) && amount < 0)
+	{
+		for (int i = 0; i < WEAR_MAX_NUM; ++i)
+		{
+			LPITEM pWear = GetWear(i);
+			if (!pWear)
+				continue;
+
+			if (!CanEquipNow(pWear))
+			{
+				if (!UnequipItem(pWear))
+				{
+					PIXEL_POSITION pos = GetXYZ();
+					pWear->RemoveFromCharacter();
+
+					if (pWear->AddToGround(GetMapIndex(), pos))
+						pWear->SetOwnership(this, 60);
+					else
+						ITEM_MANAGER::instance().RemoveItem(pWear, "FORCE_UNEQUIP_STAT_DROP");
+				}
+			}
+		}
+	}
+
 
 	switch (type)
 	{
@@ -5344,11 +5422,11 @@ void CHARACTER::ApplyPoint(POINT_TYPE wApplyType, POINT_VALUE lApplyValue)
 		case APPLY_NONE:						// 0
 			break;
 
-			// NOTE: ¾ÆÀÌÅÛ¿¡ ÀÇÇÑ ÃÖ´ëHP º¸³Ê½º³ª Äù½ºÆ® º¸»ó º¸³Ê½º°¡ ¶È°°Àº ¹æ½ÄÀ» »ç¿ëÇÏ¹Ç·Î
-			// ±×³É MAX_HP¸¸ °è»êÇÏ¸é Äù½ºÆ® º¸»óÀÇ °æ¿ì ¹®Á¦°¡ »ý±è. »ç½Ç ¿ø·¡ ÀÌÂÊÀÌ ÇÕ¸®ÀûÀÌ±âµµ ÇÏ°í..
-			// ¹Ù²Û °ø½ÄÀº ÇöÀç ÃÖ´ë hp¿Í º¸À¯ hpÀÇ ºñÀ²À» ±¸ÇÑ µÚ ¹Ù²ð ÃÖ´ë hp¸¦ ±âÁØÀ¸·Î hp¸¦ º¸Á¤ÇÑ´Ù.
-			// ¿ø·¡ PointChange¿¡¼­ ÇÏ´Â°Ô ÁÁÀ»°Í °°Àºµ¥ ¼³°è ¹®Á¦·Î ¾î·Á¿ö¼­ skip..
-			// SPµµ ¶È°°ÀÌ °è»êÇÑ´Ù.
+			// NOTE: Û¿  Ö´HP Ê½ Æ®  Ê½ È°  Ï¹Ç·
+			// ×³ MAX_HP Ï¸ Æ®    .    Õ¸Ì±âµµ Ï°..
+			// Ù²   Ö´ hp  hp    Ù² Ö´ hp  hp Ñ´.
+			//  PointChange Ï´Â°      skip..
+			// SP È° Ñ´.
 			// Mantis : 101460 ~ ity ~
 		case APPLY_MAX_HP:						// 1
 		{
@@ -5431,7 +5509,7 @@ void CHARACTER::ApplyPoint(POINT_TYPE wApplyType, POINT_VALUE lApplyValue)
 		case APPLY_SKILL:						// 51
 			// SKILL_DAMAGE_BONUS
 		{
-			// ÃÖ»óÀ§ ºñÆ® ±âÁØÀ¸·Î 8ºñÆ® vnum, 9ºñÆ® add, 15ºñÆ® change
+			// Ö» Æ®  8Æ® vnum, 9Æ® add, 15Æ® change
 			// 00000000 00000000 00000000 00000000
 			// ^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^
 			// vnum		^ add		change
@@ -5499,25 +5577,25 @@ void CHARACTER::ApplyPoint(POINT_TYPE wApplyType, POINT_VALUE lApplyValue)
 		case APPLY_PC_BANG_EXP_BONUS:			// 75
 		case APPLY_PC_BANG_DROP_BONUS:			// 76
 
-			//case APPLY_EXTRACT_HP_PCT:			// 77 »ç¿ë½Ã HP ¼Ò¸ð
+			//case APPLY_EXTRACT_HP_PCT:			// 77  HP Ò¸
 
 		case APPLY_RESIST_WARRIOR:				// 78
 		case APPLY_RESIST_ASSASSIN:				// 79
 		case APPLY_RESIST_SURA:					// 80
 		case APPLY_RESIST_SHAMAN:				// 81
 
-		case APPLY_ENERGY:						// 82 ±â·Â
-		case APPLY_DEF_GRADE:					// 83 ¹æ¾î·Â. DEF_GRADE_BONUS´Â Å¬¶ó¿¡¼­ µÎ¹è·Î º¸¿©Áö´Â ÀÇµµµÈ ¹ö±×(...)°¡ ÀÖ´Ù.
-		case APPLY_COSTUME_ATTR_BONUS:			// 84 ÄÚ½ºÆ¬ ¾ÆÀÌÅÛ¿¡ ºÙÀº ¼Ó¼ºÄ¡ º¸³Ê½º
-		case APPLY_MAGIC_ATTBONUS_PER:			// 85 ¸¶¹ý °ø°Ý·Â +x%
-		case APPLY_MELEE_MAGIC_ATTBONUS_PER:	// 86 ¸¶¹ý + ¹Ð¸® °ø°Ý·Â +x%
+		case APPLY_ENERGY:						// 82 
+		case APPLY_DEF_GRADE:					// 83 . DEF_GRADE_BONUS Å¬ó¿¡¼ Î¹  Çµ (...) Ö´.
+		case APPLY_COSTUME_ATTR_BONUS:			// 84 Ú½Æ¬ Û¿  Ó¼Ä¡ Ê½
+		case APPLY_MAGIC_ATTBONUS_PER:			// 85  Ý· +x%
+		case APPLY_MELEE_MAGIC_ATTBONUS_PER:	// 86  + Ð¸ Ý· +x%
 
-		case APPLY_RESIST_ICE:					// 87 ³Ã±â ÀúÇ×
-		case APPLY_RESIST_EARTH:				// 88 ´ëÁö ÀúÇ×
-		case APPLY_RESIST_DARK:					// 89 ¾îµÒ ÀúÇ×
+		case APPLY_RESIST_ICE:					// 87 Ã± 
+		case APPLY_RESIST_EARTH:				// 88  
+		case APPLY_RESIST_DARK:					// 89  
 
-		case APPLY_ANTI_CRITICAL_PCT:			// 90 Å©¸®Æ¼ÄÃ ÀúÇ×
-		case APPLY_ANTI_PENETRATE_PCT:			// 91 °üÅëÅ¸°Ý ÀúÇ×
+		case APPLY_ANTI_CRITICAL_PCT:			// 90 Å©Æ¼ 
+		case APPLY_ANTI_PENETRATE_PCT:			// 91 Å¸ 
 
 		case APPLY_BLEEDING_REDUCE:				// 92
 		case APPLY_BLEEDING_PCT:				// 93
@@ -5844,7 +5922,7 @@ void CHARACTER::MonsterLog(const char* format, ...)
 	else
 		len += len2;
 
-	// \0 ¹®ÀÚ Æ÷ÇÔ
+	// \0  
 	++len;
 
 	va_end(args);
@@ -5936,7 +6014,7 @@ void CHARACTER::mining_cancel()
 	{
 		sys_log(0, "XXX MINING CANCEL");
 		event_cancel(&m_pkMiningEvent);
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¤±¤À» Áß´ÜÇÏ¿´½À´Ï´Ù."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¤ ß´Ï¿Ï´."));
 	}
 }
 
@@ -5964,13 +6042,13 @@ void CHARACTER::mining(LPCHARACTER chLoad)
 
 	if (!pick || pick->GetType() != ITEM_PICK)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("°î±ªÀÌ¸¦ ÀåÂøÇÏ¼¼¿ä."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("î±ªÌ¸ Ï¼."));
 		return;
 	}
 
-	int count = number(5, 15); // µ¿ÀÛ È½¼ö, ÇÑ µ¿ÀÛ´ç 2ÃÊ
+	int count = number(5, 15); //  È½,  Û´ 2
 
-	// Ã¤±¤ µ¿ÀÛÀ» º¸¿©ÁÜ
+	// Ã¤  
 	TPacketGCDigMotion p;
 	p.header = HEADER_GC_DIG_MOTION;
 	p.vid = GetVID();
@@ -5997,7 +6075,7 @@ void CHARACTER::fishing()
 		return;
 	}
 
-	// ¸ø°¨ ¼Ó¼º¿¡¼­ ³¬½Ã¸¦ ½ÃµµÇÑ´Ù?
+	//  Ó¼ Ã¸ ÃµÑ´?
 	{
 		LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(GetMapIndex());
 
@@ -6009,7 +6087,7 @@ void CHARACTER::fishing()
 
 		if (IS_SET(dwAttr, ATTR_BLOCK))
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("³¬½Ã¸¦ ÇÒ ¼ö ÀÖ´Â °÷ÀÌ ¾Æ´Õ´Ï´Ù"));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¸   Ö´  Æ´Õ´Ï´"));
 			return;
 		}
 	}
@@ -6038,16 +6116,16 @@ void CHARACTER::fishing()
 
 	LPITEM rod = GetWear(WEAR_WEAPON);
 
-	// ³¬½Ã´ë ÀåÂø
+	// Ã´ 
 	if (!rod || rod->GetType() != ITEM_ROD)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("³¬½Ã´ë¸¦ ÀåÂø ÇÏ¼¼¿ä."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã´ë¸¦  Ï¼."));
 		return;
 	}
 
 	if (0 == rod->GetSocket(2))
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("¹Ì³¢¸¦ ³¢°í ´øÁ® ÁÖ¼¼¿ä."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì³   Ö¼."));
 		return;
 	}
 
@@ -6083,7 +6161,7 @@ void CHARACTER::fishing_take()
 	}
 	else
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("³¬½Ã´ë°¡ ¾Æ´Ñ ¹°°ÇÀ¸·Î ³¬½Ã¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù!"));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã´ë°¡ Æ´  Ã¸   Ï´!"));
 	}
 
 	event_cancel(&m_pkFishingEvent);
@@ -6123,10 +6201,10 @@ void CHARACTER::SetNextStatePulse(int iNextPulse)
 	m_dwNextStatePulse = iNextPulse;
 
 	if (iNextPulse < 10)
-		MonsterLog("´ÙÀ½»óÅÂ·Î¾î¼­°¡ÀÚ");
+		MonsterLog("Â·Î¾î¼­");
 }
 
-// Ä³¸¯ÅÍ ÀÎ½ºÅÏ½º ¾÷µ¥ÀÌÆ® ÇÔ¼ö.
+// Ä³ Î½Ï½ Æ® Ô¼.
 void CHARACTER::UpdateCharacter(DWORD dwPulse)
 {
 	CFSM::Update();
@@ -6156,35 +6234,35 @@ void CHARACTER::SetPart(BYTE bPartPos, DWORD dwVal)
 
 DWORD CHARACTER::GetPart(BYTE bPartPos) const
 {
-	assert(bPartPos < PART_MAX_NUM);
-#if defined(__HIDE_COSTUME_SYSTEM__)
-	if (bPartPos == PART_MAIN && GetHiddenCostumeByPart(PART_MAIN))
-	{
-		if (const LPITEM pArmor = GetWear(WEAR_BODY))
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			return pArmor->GetTransmutationVnum() != 0 ? pArmor->GetTransmutationVnum() : pArmor->GetVnum();
-#else
-			return pArmor->GetVnum();
-#endif
-		else
-			return 0;
-	}
-	else if (bPartPos == PART_WEAPON && GetHiddenCostumeByPart(PART_WEAPON))
-	{
-		if (const LPITEM pWeapon = GetWear(WEAR_WEAPON))
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			return pWeapon->GetTransmutationVnum() != 0 ? pWeapon->GetTransmutationVnum() : pWeapon->GetVnum();
-#else
-			return pWeapon->GetVnum();
-#endif
-		else
-			return 0;
-	}
-	else
-	{
-		if (GetHiddenCostumeByPart(bPartPos))
-			return 0;
-	}
+	assert(bPartPos < PART_MAX_NUM);
+#if defined(__HIDE_COSTUME_SYSTEM__)
+	if (bPartPos == PART_MAIN && GetHiddenCostumeByPart(PART_MAIN))
+	{
+		if (const LPITEM pArmor = GetWear(WEAR_BODY))
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			return pArmor->GetTransmutationVnum() != 0 ? pArmor->GetTransmutationVnum() : pArmor->GetVnum();
+#else
+			return pArmor->GetVnum();
+#endif
+		else
+			return 0;
+	}
+	else if (bPartPos == PART_WEAPON && GetHiddenCostumeByPart(PART_WEAPON))
+	{
+		if (const LPITEM pWeapon = GetWear(WEAR_WEAPON))
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			return pWeapon->GetTransmutationVnum() != 0 ? pWeapon->GetTransmutationVnum() : pWeapon->GetVnum();
+#else
+			return pWeapon->GetVnum();
+#endif
+		else
+			return 0;
+	}
+	else
+	{
+		if (GetHiddenCostumeByPart(bPartPos))
+			return 0;
+	}
 #endif
 	return m_pointsInstant.adwParts[bPartPos];
 }
@@ -6194,7 +6272,7 @@ DWORD CHARACTER::GetOriginalPart(BYTE bPartPos) const
 	switch (bPartPos)
 	{
 		case PART_MAIN:
-			if (!IsPC()) // PC°¡ ¾Æ´Ñ °æ¿ì ÇöÀç ÆÄÆ®¸¦ ±×´ë·Î ¸®ÅÏ
+			if (!IsPC()) // PC Æ´   Æ® ×´ 
 				return GetPart(PART_MAIN);
 			else
 				return m_pointsInstant.bBasePart;
@@ -6257,7 +6335,7 @@ bool CHARACTER::SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList)
 		if (m_pkChrSyncOwner)
 			sys_log(1, "SyncRelease %s %p from %s", GetName(), this, m_pkChrSyncOwner->GetName());
 
-		// ¸®½ºÆ®¿¡¼­ Á¦°ÅÇÏÁö ¾Ê´õ¶óµµ Æ÷ÀÎÅÍ´Â NULL·Î ¼ÂÆÃµÇ¾î¾ß ÇÑ´Ù.
+		// Æ®  Ê´ Í´ NULL ÃµÇ¾ Ñ´.
 		m_pkChrSyncOwner = NULL;
 	}
 	else
@@ -6265,12 +6343,12 @@ bool CHARACTER::SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList)
 		if (!IsSyncOwner(ch))
 			return false;
 
-		// °Å¸®°¡ 200 ÀÌ»óÀÌ¸é SyncOwner°¡ µÉ ¼ö ¾ø´Ù.
+		// Å¸ 200 Ì»Ì¸ SyncOwner   .
 		if (DISTANCE_APPROX(GetX() - ch->GetX(), GetY() - ch->GetY()) > 250)
 		{
 			sys_log(1, "SetSyncOwner distance over than 250 %s %s", GetName(), ch->GetName());
 
-			// SyncOwnerÀÏ °æ¿ì Owner·Î Ç¥½ÃÇÑ´Ù.
+			// SyncOwner  Owner Ç¥Ñ´.
 			if (m_pkChrSyncOwner == ch)
 				return true;
 
@@ -6288,7 +6366,7 @@ bool CHARACTER::SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList)
 			m_pkChrSyncOwner = ch;
 			m_pkChrSyncOwner->m_kLst_pkChrSyncOwned.push_back(this);
 
-			// SyncOwner°¡ ¹Ù²î¸é LastSyncTimeÀ» ÃÊ±âÈ­ÇÑ´Ù.
+			// SyncOwner Ù² LastSyncTime Ê±È­Ñ´.
 			static const timeval zero_tv = { 0, 0 };
 			SetLastSyncTime(zero_tv);
 
@@ -6298,9 +6376,9 @@ bool CHARACTER::SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList)
 		m_fSyncTime = get_float_time();
 	}
 
-	// TODO: Sync Owner°¡ °°´õ¶óµµ °è¼Ó ÆÐÅ¶À» º¸³»°í ÀÖÀ¸¹Ç·Î,
-	// µ¿±âÈ­ µÈ ½Ã°£ÀÌ 3ÃÊ ÀÌ»ó Áö³µÀ» ¶§ Ç®¾îÁÖ´Â ÆÐÅ¶À»
-	// º¸³»´Â ¹æ½ÄÀ¸·Î ÇÏ¸é ÆÐÅ¶À» ÁÙÀÏ ¼ö ÀÖ´Ù.
+	// TODO: Sync Owner   Å¶  Ç·,
+	// È­  Ã° 3 Ì»   Ç®Ö´ Å¶
+	//   Ï¸ Å¶   Ö´.
 	TPacketGCOwnership pack;
 
 	pack.bHeader = HEADER_GC_OWNERSHIP;
@@ -6316,7 +6394,7 @@ struct FuncClearSync
 	void operator () (LPCHARACTER ch)
 	{
 		assert(ch != NULL);
-		ch->SetSyncOwner(NULL, false); // false ÇÃ·¡±×·Î ÇØ¾ß for_each °¡ Á¦´ë·Î µ·´Ù.
+		ch->SetSyncOwner(NULL, false); // false Ã·×· Ø¾ for_each   .
 	}
 };
 
@@ -6324,7 +6402,7 @@ void CHARACTER::ClearSync()
 {
 	SetSyncOwner(NULL);
 
-	// ¾Æ·¡ for_each¿¡¼­ ³ª¸¦ m_pkChrSyncOwner·Î °¡Áø ÀÚµéÀÇ Æ÷ÀÎÅÍ¸¦ NULL·Î ÇÑ´Ù.
+	// Æ· for_each  m_pkChrSyncOwner  Úµ Í¸ NULL Ñ´.
 	std::for_each(m_kLst_pkChrSyncOwned.begin(), m_kLst_pkChrSyncOwned.end(), FuncClearSync());
 	m_kLst_pkChrSyncOwned.clear();
 }
@@ -6334,8 +6412,8 @@ bool CHARACTER::IsSyncOwner(LPCHARACTER ch) const
 	if (m_pkChrSyncOwner == ch)
 		return true;
 
-	// ¸¶Áö¸·À¸·Î µ¿±âÈ­ µÈ ½Ã°£ÀÌ 3ÃÊ ÀÌ»ó Áö³µ´Ù¸é ¼ÒÀ¯±ÇÀÌ ¾Æ¹«¿¡°Ôµµ
-	// ¾ø´Ù. µû¶ó¼­ ¾Æ¹«³ª SyncOwnerÀÌ¹Ç·Î true ¸®ÅÏ
+	//  È­  Ã° 3 Ì» Ù¸  Æ¹Ôµ
+	// .  Æ¹ SyncOwnerÌ¹Ç· true 
 	if (get_float_time() - m_fSyncTime >= 3.0f)
 		return true;
 
@@ -6369,11 +6447,11 @@ void CHARACTER::SetParty(LPPARTY pkParty)
 }
 
 // PARTY_JOIN_BUG_FIX
-/// ÆÄÆ¼ °¡ÀÔ event Á¤º¸
+/// Æ¼  event 
 EVENTINFO(TPartyJoinEventInfo)
 {
-	DWORD dwGuestPID; ///< ÆÄÆ¼¿¡ Âü¿©ÇÒ Ä³¸¯ÅÍÀÇ PID
-	DWORD dwLeaderPID; ///< ÆÄÆ¼ ¸®´õÀÇ PID
+	DWORD dwGuestPID; ///< Æ¼  Ä³ PID
+	DWORD dwLeaderPID; ///< Æ¼  PID
 
 	TPartyJoinEventInfo()
 		: dwGuestPID(0)
@@ -6411,7 +6489,7 @@ bool CHARACTER::RequestToParty(LPCHARACTER leader)
 
 	if (!leader)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÆÄÆ¼ÀåÀÌ Á¢¼Ó »óÅÂ°¡ ¾Æ´Ï¶ó¼­ ¿äÃ»À» ÇÒ ¼ö ¾ø½À´Ï´Ù."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Æ¼  Â° Æ´Ï¶ Ã»   Ï´."));
 		return false;
 	}
 
@@ -6432,38 +6510,38 @@ bool CHARACTER::RequestToParty(LPCHARACTER leader)
 			break;
 
 		case PERR_SERVER:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ¼­¹ö ¹®Á¦·Î ÆÄÆ¼ °ü·Ã Ã³¸®¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>   Æ¼  Ã³   Ï´."));
 			return false;
 
 		case PERR_DIFFEMPIRE:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ´Ù¸¥ Á¦±¹°ú ÆÄÆ¼¸¦ ÀÌ·ê ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Ù¸  Æ¼ Ì·  Ï´."));
 			return false;
 
 		case PERR_DUNGEON:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ´øÀü ¾È¿¡¼­´Â ÆÄÆ¼ ÃÊ´ë¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  È¿ Æ¼ Ê´ë¸¦   Ï´."));
 			return false;
 
 		case PERR_OBSERVER:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> °üÀü ¸ðµå¿¡¼± ÆÄÆ¼ ÃÊ´ë¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  å¿¡ Æ¼ Ê´ë¸¦   Ï´."));
 			return false;
 
 		case PERR_LVBOUNDARY:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> -30 ~ +30 ·¹º§ ÀÌ³»ÀÇ »ó´ë¹æ¸¸ ÃÊ´ëÇÒ ¼ö ÀÖ½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> -30 ~ +30  Ì³ æ¸¸ Ê´  Ö½Ï´."));
 			return false;
 
 		case PERR_LOWLEVEL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼³» ÃÖ°í ·¹º§ º¸´Ù 30·¹º§ÀÌ ³·¾Æ ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼ Ö°   30  Ê´  Ï´."));
 			return false;
 
 		case PERR_HILEVEL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼³» ÃÖÀú ·¹º§ º¸´Ù 30·¹º§ÀÌ ³ô¾Æ ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼    30  Ê´  Ï´."));
 			return false;
 
 		case PERR_ALREADYJOIN:
 			return false;
 
 		case PERR_PARTYISFULL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ´õ ÀÌ»ó ÆÄÆ¼¿øÀ» ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  Ì» Æ¼ Ê´  Ï´."));
 			return false;
 
 		default:
@@ -6483,7 +6561,7 @@ bool CHARACTER::RequestToParty(LPCHARACTER leader)
 #else
 	leader->ChatPacket(CHAT_TYPE_COMMAND, "PartyRequest %u", (DWORD)GetVID());
 #endif
-	ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s ´Ô¿¡°Ô ÆÄÆ¼°¡ÀÔ ½ÅÃ»À» Çß½À´Ï´Ù.", leader->GetName()));
+	ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s Ô¿ Æ¼ Ã» ß½Ï´.", leader->GetName()));
 	return true;
 }
 
@@ -6537,7 +6615,7 @@ void CHARACTER::AcceptToParty(LPCHARACTER member)
 	event_cancel(&member->m_pkPartyRequestEvent);
 
 	if (!GetParty())
-		member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ó´ë¹æÀÌ ÆÄÆ¼¿¡ ¼ÓÇØÀÖÁö ¾Ê½À´Ï´Ù."));
+		member->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Æ¼  Ê½Ï´."));
 	else
 	{
 		if (GetPlayerID() != GetParty()->GetLeaderPID())
@@ -6547,16 +6625,16 @@ void CHARACTER::AcceptToParty(LPCHARACTER member)
 		switch (errcode)
 		{
 			case PERR_NONE: member->PartyJoin(this); return;
-			case PERR_SERVER: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ¼­¹ö ¹®Á¦·Î ÆÄÆ¼ °ü·Ã Ã³¸®¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù.")); break;
-			case PERR_DUNGEON: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ´øÀü ¾È¿¡¼­´Â ÆÄÆ¼ ÃÊ´ë¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù.")); break;
-			case PERR_OBSERVER: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> °üÀü ¸ðµå¿¡¼± ÆÄÆ¼ ÃÊ´ë¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù.")); break;
-			case PERR_LVBOUNDARY: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> -30 ~ +30 ·¹º§ ÀÌ³»ÀÇ »ó´ë¹æ¸¸ ÃÊ´ëÇÒ ¼ö ÀÖ½À´Ï´Ù.")); break;
-			case PERR_LOWLEVEL: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼³» ÃÖ°í ·¹º§ º¸´Ù 30·¹º§ÀÌ ³·¾Æ ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù.")); break;
-			case PERR_HILEVEL: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼³» ÃÖÀú ·¹º§ º¸´Ù 30·¹º§ÀÌ ³ô¾Æ ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù.")); break;
+			case PERR_SERVER: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>   Æ¼  Ã³   Ï´.")); break;
+			case PERR_DUNGEON: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  È¿ Æ¼ Ê´ë¸¦   Ï´.")); break;
+			case PERR_OBSERVER: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  å¿¡ Æ¼ Ê´ë¸¦   Ï´.")); break;
+			case PERR_LVBOUNDARY: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> -30 ~ +30  Ì³ æ¸¸ Ê´  Ö½Ï´.")); break;
+			case PERR_LOWLEVEL: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼ Ö°   30  Ê´  Ï´.")); break;
+			case PERR_HILEVEL: member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼    30  Ê´  Ï´.")); break;
 			case PERR_ALREADYJOIN: break;
 			case PERR_PARTYISFULL: {
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ´õ ÀÌ»ó ÆÄÆ¼¿øÀ» ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-				member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼ÀÇ ÀÎ¿øÁ¦ÇÑÀÌ ÃÊ°úÇÏ¿© ÆÄÆ¼¿¡ Âü°¡ÇÒ ¼ö ¾ø½À´Ï´Ù."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  Ì» Æ¼ Ê´  Ï´."));
+				member->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼ Î¿ Ê°Ï¿ Æ¼   Ï´."));
 				break;
 			}
 			default: sys_err("Do not process party join error(%d)", errcode);
@@ -6567,8 +6645,8 @@ void CHARACTER::AcceptToParty(LPCHARACTER member)
 }
 
 /**
-* ÆÄÆ¼ ÃÊ´ë event callback ÇÔ¼ö.
-* event °¡ ¹ßµ¿ÇÏ¸é ÃÊ´ë °ÅÀý·Î Ã³¸®ÇÑ´Ù.
+* Æ¼ Ê´ event callback Ô¼.
+* event  ßµÏ¸ Ê´  Ã³Ñ´.
 **/
 EVENTFUNC(party_invite_event)
 {
@@ -6595,12 +6673,12 @@ void CHARACTER::PartyInvite(LPCHARACTER pchInvitee)
 {
 	if (GetParty() && GetParty()->GetLeaderPID() != GetPlayerID())
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼¿øÀ» ÃÊ´ëÇÒ ¼ö ÀÖ´Â ±ÇÇÑÀÌ ¾ø½À´Ï´Ù."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼ Ê´  Ö´  Ï´."));
 		return;
 	}
 	else if (pchInvitee->IsBlockMode(BLOCK_PARTY_INVITE))
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> %s ´ÔÀÌ ÆÄÆ¼ °ÅºÎ »óÅÂÀÔ´Ï´Ù.", pchInvitee->GetName()));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> %s  Æ¼ Åº Ô´Ï´.", pchInvitee->GetName()));
 		return;
 	}
 
@@ -6612,39 +6690,39 @@ void CHARACTER::PartyInvite(LPCHARACTER pchInvitee)
 			break;
 
 		case PERR_SERVER:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ¼­¹ö ¹®Á¦·Î ÆÄÆ¼ °ü·Ã Ã³¸®¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>   Æ¼  Ã³   Ï´."));
 			return;
 
 		case PERR_DIFFEMPIRE:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ´Ù¸¥ Á¦±¹°ú ÆÄÆ¼¸¦ ÀÌ·ê ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Ù¸  Æ¼ Ì·  Ï´."));
 			return;
 
 		case PERR_DUNGEON:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ´øÀü ¾È¿¡¼­´Â ÆÄÆ¼ ÃÊ´ë¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  È¿ Æ¼ Ê´ë¸¦   Ï´."));
 			return;
 
 		case PERR_OBSERVER:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> °üÀü ¸ðµå¿¡¼± ÆÄÆ¼ ÃÊ´ë¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  å¿¡ Æ¼ Ê´ë¸¦   Ï´."));
 			return;
 
 		case PERR_LVBOUNDARY:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> -30 ~ +30 ·¹º§ ÀÌ³»ÀÇ »ó´ë¹æ¸¸ ÃÊ´ëÇÒ ¼ö ÀÖ½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> -30 ~ +30  Ì³ æ¸¸ Ê´  Ö½Ï´."));
 			return;
 
 		case PERR_LOWLEVEL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼³» ÃÖ°í ·¹º§ º¸´Ù 30·¹º§ÀÌ ³·¾Æ ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼ Ö°   30  Ê´  Ï´."));
 			return;
 
 		case PERR_HILEVEL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼³» ÃÖÀú ·¹º§ º¸´Ù 30·¹º§ÀÌ ³ô¾Æ ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼    30  Ê´  Ï´."));
 			return;
 
 		case PERR_ALREADYJOIN:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÀÌ¹Ì %s´ÔÀº ÆÄÆ¼¿¡ ¼ÓÇØ ÀÖ½À´Ï´Ù.", pchInvitee->GetName()));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Ì¹ %s Æ¼  Ö½Ï´.", pchInvitee->GetName()));
 			return;
 
 		case PERR_PARTYISFULL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ´õ ÀÌ»ó ÆÄÆ¼¿øÀ» ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  Ì» Æ¼ Ê´  Ï´."));
 			return;
 
 		default:
@@ -6656,7 +6734,7 @@ void CHARACTER::PartyInvite(LPCHARACTER pchInvitee)
 		return;
 
 	//
-	// EventMap ¿¡ ÀÌº¥Æ® Ãß°¡
+	// EventMap  ÌºÆ® ß°
 	//
 	TPartyJoinEventInfo* info = AllocEventInfo<TPartyJoinEventInfo>();
 
@@ -6666,7 +6744,7 @@ void CHARACTER::PartyInvite(LPCHARACTER pchInvitee)
 	m_PartyInviteEventMap.insert(EventMap::value_type(pchInvitee->GetPlayerID(), event_create(party_invite_event, info, PASSES_PER_SEC(10))));
 
 	//
-	// ÃÊ´ë ¹Þ´Â character ¿¡°Ô ÃÊ´ë ÆÐÅ¶ Àü¼Û
+	// Ê´ Þ´ character  Ê´ Å¶ 
 	//
 
 	TPacketGCPartyInvite p;
@@ -6690,7 +6768,7 @@ void CHARACTER::PartyInviteAccept(LPCHARACTER pchInvitee)
 
 	if (GetParty() && GetParty()->GetLeaderPID() != GetPlayerID())
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼¿øÀ» ÃÊ´ëÇÒ ¼ö ÀÖ´Â ±ÇÇÑÀÌ ¾ø½À´Ï´Ù."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼ Ê´  Ö´  Ï´."));
 		return;
 	}
 
@@ -6702,36 +6780,36 @@ void CHARACTER::PartyInviteAccept(LPCHARACTER pchInvitee)
 			break;
 
 		case PERR_SERVER:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ¼­¹ö ¹®Á¦·Î ÆÄÆ¼ °ü·Ã Ã³¸®¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>   Æ¼  Ã³   Ï´."));
 			return;
 
 		case PERR_DUNGEON:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ´øÀü ¾È¿¡¼­´Â ÆÄÆ¼ ÃÊ´ë¿¡ ÀÀÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  È¿ Æ¼ Ê´ë¿¡   Ï´."));
 			return;
 
 		case PERR_OBSERVER:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> °üÀü ¸ðµå¿¡¼± ÆÄÆ¼ ÃÊ´ë¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  å¿¡ Æ¼ Ê´ë¸¦   Ï´."));
 			return;
 
 		case PERR_LVBOUNDARY:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> -30 ~ +30 ·¹º§ ÀÌ³»ÀÇ »ó´ë¹æ¸¸ ÃÊ´ëÇÒ ¼ö ÀÖ½À´Ï´Ù."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> -30 ~ +30  Ì³ æ¸¸ Ê´  Ö½Ï´."));
 			return;
 
 		case PERR_LOWLEVEL:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼³» ÃÖ°í ·¹º§ º¸´Ù 30·¹º§ÀÌ ³·¾Æ ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼ Ö°   30  Ê´  Ï´."));
 			return;
 
 		case PERR_HILEVEL:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼³» ÃÖÀú ·¹º§ º¸´Ù 30·¹º§ÀÌ ³ô¾Æ ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼    30  Ê´  Ï´."));
 			return;
 
 		case PERR_ALREADYJOIN:
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼ ÃÊ´ë¿¡ ÀÀÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼ Ê´ë¿¡   Ï´."));
 			return;
 
 		case PERR_PARTYISFULL:
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ´õ ÀÌ»ó ÆÄÆ¼¿øÀ» ÃÊ´ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼ÀÇ ÀÎ¿øÁ¦ÇÑÀÌ ÃÊ°úÇÏ¿© ÆÄÆ¼¿¡ Âü°¡ÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  Ì» Æ¼ Ê´  Ï´."));
+			pchInvitee->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼ Î¿ Ê°Ï¿ Æ¼   Ï´."));
 			return;
 
 		default:
@@ -6740,7 +6818,7 @@ void CHARACTER::PartyInviteAccept(LPCHARACTER pchInvitee)
 	}
 
 	//
-	// ÆÄÆ¼ °¡ÀÔ Ã³¸®
+	// Æ¼  Ã³
 	//
 
 	if (GetParty())
@@ -6770,13 +6848,13 @@ void CHARACTER::PartyInviteDeny(DWORD dwPID)
 
 	LPCHARACTER pchInvitee = CHARACTER_MANAGER::instance().FindByPID(dwPID);
 	if (pchInvitee)
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> %s´ÔÀÌ ÆÄÆ¼ ÃÊ´ë¸¦ °ÅÀýÇÏ¼Ì½À´Ï´Ù.", pchInvitee->GetName()));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> %s Æ¼ Ê´ë¸¦ Ï¼Ì½Ï´.", pchInvitee->GetName()));
 }
 
 void CHARACTER::PartyJoin(LPCHARACTER pLeader)
 {
-	pLeader->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> %s´ÔÀÌ ÆÄÆ¼¿¡ Âü°¡ÇÏ¼Ì½À´Ï´Ù.", GetName()));
-	ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> %s´ÔÀÇ ÆÄÆ¼¿¡ Âü°¡ÇÏ¼Ì½À´Ï´Ù.", pLeader->GetName()));
+	pLeader->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> %s Æ¼ Ï¼Ì½Ï´.", GetName()));
+	ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> %s Æ¼ Ï¼Ì½Ï´.", pLeader->GetName()));
 
 	pLeader->GetParty()->Join(GetPlayerID());
 	pLeader->GetParty()->Link(this);
@@ -6989,7 +7067,7 @@ void CHARACTER::OnClick(LPCHARACTER pkChrCauser)
 		return;
 	}
 
-	// ±³È¯ÁßÀÏ¶§ Äù½ºÆ®¸¦ ÁøÇàÇÒ ¼ö ¾ø´Ù.
+	// È¯Ï¶ Æ®   .
 	{
 		if (pkChrCauser->GetExchange())
 		{
@@ -6999,9 +7077,9 @@ void CHARACTER::OnClick(LPCHARACTER pkChrCauser)
 		}
 	}
 
-	// »óÁ¡À» ¿¬»óÅÂ·Î Äù½ºÆ®¸¦ ÁøÇàÇÒ ¼ö ¾ø´Ù.
+	//  Â· Æ®   .
 	{
-		// ´Ü, ÀÚ½ÅÀº ÀÚ½ÅÀÇ »óÁ¡À» Å¬¸¯ÇÒ ¼ö ÀÖ´Ù.
+		// , Ú½ Ú½  Å¬  Ö´.
 		if (pkChrCauser->GetMyShop() && pkChrCauser != this)
 		{
 			if (test_server)
@@ -7012,10 +7090,10 @@ void CHARACTER::OnClick(LPCHARACTER pkChrCauser)
 
 	if (IsPC())
 	{
-		// Å¸°ÙÀ¸·Î ¼³Á¤µÈ °æ¿ì´Â PC¿¡ ÀÇÇÑ Å¬¸¯µµ Äù½ºÆ®·Î Ã³¸®ÇÏµµ·Ï ÇÕ´Ï´Ù.
+		// Å¸   PC  Å¬ Æ® Ã³Ïµ Õ´Ï´.
 		if (!CTargetManager::instance().GetTargetInfo(pkChrCauser->GetPlayerID(), TARGET_TYPE_VID, GetVID()))
 		{
-			// 20050317.myevan.Å¸°ÙÀÌ ¾Æ´Ñ °æ¿ì´Â °³ÀÎ »óÁ¡ Ã³¸® ±â´ÉÀ» ÀÛµ¿½ÃÅ²´Ù.
+			// 20050317.myevan.Å¸ Æ´    Ã³  ÛµÅ².
 			if (GetMyShop())
 			{
 				if (pkChrCauser->IsDead() == true) return;
@@ -7029,28 +7107,28 @@ void CHARACTER::OnClick(LPCHARACTER pkChrCauser)
 #endif
 
 				// PREVENT_TRADE_WINDOW
-				if (pkChrCauser == this) // ÀÚ±â´Â °¡´É
+				if (pkChrCauser == this) // Ú± 
 				{
 					if (PreventTradeWindow(WND_MYSHOP, true/*except*/))
 					{
-						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("´Ù¸¥ °Å·¡Áß(Ã¢°í,±³È¯,»óÁ¡)¿¡´Â °³ÀÎ»óÁ¡À» »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
+						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ù¸ Å·(Ã¢,È¯,) Î»   Ï´."));
 						return;
 					}
 				}
-				else // ´Ù¸¥ »ç¶÷ÀÌ Å¬¸¯ÇßÀ»¶§
+				else // Ù¸  Å¬
 				{
-					// Å¬¸¯ÇÑ »ç¶÷ÀÌ ±³È¯/Ã¢°í/°³ÀÎ»óÁ¡/»óÁ¡ÀÌ¿ëÁßÀÌ¶ó¸é ºÒ°¡
+					// Å¬  È¯/Ã¢/Î»/Ì¿Ì¶ Ò°
 					if (pkChrCauser->PreventTradeWindow(WND_ALL))
 					{
-						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("´Ù¸¥ °Å·¡Áß(Ã¢°í,±³È¯,»óÁ¡)¿¡´Â °³ÀÎ»óÁ¡À» »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
+						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ù¸ Å·(Ã¢,È¯,) Î»   Ï´."));
 						return;
 					}
 
-					// Å¬¸¯ÇÑ ´ë»óÀÌ ±³È¯/Ã¢°í/»óÁ¡ÀÌ¿ëÁßÀÌ¶ó¸é ºÒ°¡
+					// Å¬  È¯/Ã¢/Ì¿Ì¶ Ò°
 					//if ((GetExchange() || IsOpenSafebox() || GetShopOwner()))
 					if (PreventTradeWindow(WND_MYSHOP | WND_SHOPOWNER, true/*except*/))
 					{
-						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ó´ë¹æÀÌ ´Ù¸¥ °Å·¡¸¦ ÇÏ°í ÀÖ´Â ÁßÀÔ´Ï´Ù."));
+						pkChrCauser->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ù¸ Å· Ï° Ö´ Ô´Ï´."));
 						return;
 					}
 				}
@@ -7101,12 +7179,12 @@ void CHARACTER::OnClick(LPCHARACTER pkChrCauser)
 			return;
 	}
 
-	// NPC Àü¿ë ±â´É ¼öÇà : »óÁ¡ ¿­±â µî
+	// NPC    :   
 	if (!IsPC())
 	{
 		if (!m_triggerOnClick.pFunc)
 		{
-			// NPC Æ®¸®°Å ½Ã½ºÅÛ ·Î±× º¸±â
+			// NPC Æ® Ã½ Î± 
 			/*
 			sys_err("%s.OnClickFailure(%s) : triggerOnClick.pFunc is EMPTY(pid=%d)",
 				pkChrCauser->GetName(),
@@ -7175,7 +7253,7 @@ void CHARACTER::ClearStone()
 {
 	if (!m_set_pkChrSpawnedBy.empty())
 	{
-		// ³»°¡ ½ºÆù½ÃÅ² ¸ó½ºÅÍµéÀ» ¸ðµÎ Á×ÀÎ´Ù.
+		//  Å² Íµ  Î´.
 		FuncDeadSpawnedByStone f;
 		std::for_each(m_set_pkChrSpawnedBy.begin(), m_set_pkChrSpawnedBy.end(), f);
 		m_set_pkChrSpawnedBy.clear();
@@ -7188,6 +7266,27 @@ void CHARACTER::ClearStone()
 	m_pkChrStone = NULL;
 }
 
+
+LPCHARACTER CHARACTER::GetTargetSafe()
+{
+	if (!m_pkChrTarget)
+		return nullptr;
+
+	if (m_dwTargetVID == 0)
+		return m_pkChrTarget;
+
+	LPCHARACTER pkReal = CHARACTER_MANAGER::instance().Find(m_dwTargetVID);
+	if (pkReal != m_pkChrTarget)
+	{
+		// Target disappeared or was replaced; clear locally without dereferencing a stale pointer.
+		m_pkChrTarget = nullptr;
+		m_dwTargetVID = 0;
+		return nullptr;
+	}
+
+	return m_pkChrTarget;
+}
+
 void CHARACTER::ClearTarget()
 {
 	if (m_pkChrTarget)
@@ -7240,9 +7339,14 @@ void CHARACTER::SetTarget(LPCHARACTER pkChrTarget)
 	// CASTLE
 
 	if (m_pkChrTarget)
-		m_pkChrTarget->m_set_pkChrTargetedBy.erase(this);
+	{
+		LPCHARACTER pkReal = (m_dwTargetVID ? CHARACTER_MANAGER::instance().Find(m_dwTargetVID) : nullptr);
+		if (pkReal == m_pkChrTarget)
+			pkReal->m_set_pkChrTargetedBy.erase(this);
+	}
 
 	m_pkChrTarget = pkChrTarget;
+	m_dwTargetVID = m_pkChrTarget ? m_pkChrTarget->GetVID() : 0;
 
 	TPacketGCTarget p;
 
@@ -7480,10 +7584,11 @@ void CHARACTER::BroadcastTargetPacket()
 
 void CHARACTER::CheckTarget()
 {
-	if (!m_pkChrTarget)
+	LPCHARACTER pkTarget = GetTargetSafe();
+	if (!pkTarget)
 		return;
 
-	if (DISTANCE_APPROX(GetX() - m_pkChrTarget->GetX(), GetY() - m_pkChrTarget->GetY()) >= 4800)
+	if (DISTANCE_APPROX(GetX() - pkTarget->GetX(), GetY() - pkTarget->GetY()) >= 4800)
 		SetTarget(NULL);
 }
 
@@ -7510,9 +7615,9 @@ void CHARACTER::ExitToSavedLocation()
 }
 
 // fixme
-// Áö±Ý±îÁø privateMapIndex °¡ ÇöÀç ¸Ê ÀÎµ¦½º¿Í °°ÀºÁö Ã¼Å© ÇÏ´Â °ÍÀ» ¿ÜºÎ¿¡¼­ ÇÏ°í,
-// ´Ù¸£¸é warpsetÀ» ºÒ·¶´Âµ¥
-// ÀÌ¸¦ warpset ¾ÈÀ¸·Î ³ÖÀÚ.
+// Ý± privateMapIndex    Îµ  Ã¼Å© Ï´  ÜºÎ¿ Ï°,
+// Ù¸ warpset Ò·Âµ
+// Ì¸ warpset  .
 bool CHARACTER::WarpSet(long x, long y, long lPrivateMapIndex)
 {
 	if (!IsPC())
@@ -7610,7 +7715,7 @@ void CHARACTER::WarpEnd()
 
 	if (!map_allow_find(index))
 	{
-		// ÀÌ °÷À¸·Î ¿öÇÁÇÒ ¼ö ¾øÀ¸¹Ç·Î ¿öÇÁÇÏ±â Àü ÁÂÇ¥·Î µÇµ¹¸®ÀÚ.
+		//     Ç· Ï±  Ç¥ Çµ.
 		sys_err("location %d %d not allowed to login this server", m_posWarp.x, m_posWarp.y);
 		if (g_bIgnoreDisallowedMap) // 20200807.Owsap : Go home if map index isn't allowed.
 			GoHome();
@@ -7669,7 +7774,7 @@ bool CHARACTER::Return()
 	SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
 
 	if (test_server)
-		sys_log(0, "%s %p Æ÷±âÇÏ°í µ¹¾Æ°¡ÀÚ! %d %d", GetName(), this, x, y);
+		sys_log(0, "%s %p Ï° Æ°! %d %d", GetName(), this, x, y);
 
 	if (GetParty())
 		GetParty()->SendMessage(this, PM_RETURN, x, y);
@@ -7688,14 +7793,14 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 	// TRENT_MONSTER
 	if (IsNoMove())
 	{
-		if (pkChr->IsPC()) // ÂÑ¾Æ°¡´Â »ó´ë°¡ PCÀÏ ¶§
+		if (pkChr->IsPC()) // Ñ¾Æ° ë°¡ PC 
 		{
 			// If i'm in a party. I must obey party leader's AI.
 			if (!GetParty() || !GetParty()->GetLeader() || GetParty()->GetLeader() == this)
 			{
-				if (get_dword_time() - m_pkMobInst->m_dwLastAttackedTime >= 15000) // ¸¶Áö¸·À¸·Î °ø°Ý¹ÞÀºÁö 15ÃÊ°¡ Áö³µ°í
+				if (get_dword_time() - m_pkMobInst->m_dwLastAttackedTime >= 15000) //  Ý¹ 15Ê° 
 				{
-					// ¸¶Áö¸· ¸ÂÀº °÷À¸·Î ºÎÅÍ 50¹ÌÅÍ ÀÌ»ó Â÷ÀÌ³ª¸é Æ÷±âÇÏ°í µ¹¾Æ°£´Ù.
+					//     50 Ì» Ì³ Ï° Æ°.
 					if (m_pkMobData->m_table.wAttackRange < DISTANCE_APPROX(pkChr->GetX() - GetX(), pkChr->GetY() - GetY()))
 						if (Return())
 							return true;
@@ -7709,14 +7814,14 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 	long x = pkChr->GetX();
 	long y = pkChr->GetY();
 
-	if (pkChr->IsPC()) // ÂÑ¾Æ°¡´Â »ó´ë°¡ PCÀÏ ¶§
+	if (pkChr->IsPC()) // Ñ¾Æ° ë°¡ PC 
 	{
 		// If i'm in a party. I must obey party leader's AI.
 		if (!GetParty() || !GetParty()->GetLeader() || GetParty()->GetLeader() == this)
 		{
-			if (get_dword_time() - m_pkMobInst->m_dwLastAttackedTime >= 15000) // ¸¶Áö¸·À¸·Î °ø°Ý¹ÞÀºÁö 15ÃÊ°¡ Áö³µ°í
+			if (get_dword_time() - m_pkMobInst->m_dwLastAttackedTime >= 15000) //  Ý¹ 15Ê° 
 			{
-				// ¸¶Áö¸· ¸ÂÀº °÷À¸·Î ºÎÅÍ 50¹ÌÅÍ ÀÌ»ó Â÷ÀÌ³ª¸é Æ÷±âÇÏ°í µ¹¾Æ°£´Ù.
+				//     50 Ì» Ì³ Ï° Æ°.
 				if (5000 < DISTANCE_APPROX(m_pkMobInst->m_posLastAttacked.x - GetX(), m_pkMobInst->m_posLastAttacked.y - GetY()))
 					if (Return())
 						return true;
@@ -7744,9 +7849,9 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 #endif
 		)
 	{
-		// ´ë»óÀÌ ÀÌµ¿ÁßÀÌ¸é ¿¹Ãø ÀÌµ¿À» ÇÑ´Ù
-		// ³ª¿Í »ó´ë¹æÀÇ ¼ÓµµÂ÷¿Í °Å¸®·ÎºÎÅÍ ¸¸³¯ ½Ã°£À» ¿¹»óÇÑ ÈÄ
-		// »ó´ë¹æÀÌ ±× ½Ã°£±îÁö Á÷¼±À¸·Î ÀÌµ¿ÇÑ´Ù°í °¡Á¤ÇÏ¿© °Å±â·Î ÀÌµ¿ÇÑ´Ù.
+		//  ÌµÌ¸  Ìµ Ñ´
+		//   Óµ Å¸Îº  Ã°  
+		//   Ã°  ÌµÑ´Ù° Ï¿ Å± ÌµÑ´.
 		float rot = pkChr->GetRotation();
 		float rot_delta = GetDegreeDelta(rot, GetDegreeFromPositionXY(GetX(), GetY(), pkChr->GetX(), pkChr->GetY()));
 
@@ -7778,7 +7883,7 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 		}
 	}
 
-	// °¡·Á´Â À§Ä¡¸¦ ¹Ù¶óºÁ¾ß ÇÑ´Ù.
+	//  Ä¡ Ù¶ Ñ´.
 	SetRotationToXY(x, y);
 
 	float fDist = DISTANCE_SQRT(x - GetX(), y - GetY());
@@ -7790,7 +7895,7 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 
 	if (IsChangeAttackPosition(pkChr) && GetMobRank() < MOB_RANK_BOSS)
 	{
-		// »ó´ë¹æ ÁÖº¯ ·£´ýÇÑ °÷À¸·Î ÀÌµ¿
+		//  Öº   Ìµ
 		SetChangeAttackPositionTime();
 
 		int retry = 16;
@@ -7815,23 +7920,23 @@ bool CHARACTER::Follow(LPCHARACTER pkChr, float fMinDistance)
 				break;
 		}
 
-		//sys_log(0, "±ÙÃ³ ¾îµò°¡·Î ÀÌµ¿ %s retry %d", GetName(), retry);
+		//sys_log(0, "Ã³ ò°¡· Ìµ %s retry %d", GetName(), retry);
 		if (!Goto(dx, dy))
 			return false;
 	}
 	else
 	{
-		// Á÷¼± µû¶ó°¡±â
+		//  ó°¡±
 		float fDistToGo = fDist - fMinDistance;
 		GetDeltaByDegree(GetRotation(), fDistToGo, &fx, &fy);
 
-		//sys_log(0, "Á÷¼±À¸·Î ÀÌµ¿ %s", GetName());
+		//sys_log(0, " Ìµ %s", GetName());
 		if (!Goto(GetX() + (int)fx, GetY() + (int)fy))
 			return false;
 	}
 
 	SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
-	//MonsterLog("ÂÑ¾Æ°¡±â; %s", pkChr->GetName());
+	//MonsterLog("Ñ¾Æ°; %s", pkChr->GetName());
 	return true;
 }
 
@@ -7861,24 +7966,24 @@ void CHARACTER::ReqSafeboxLoad(const char* pszPassword)
 #endif
 	if (!*pszPassword || strlen(pszPassword) > SAFEBOX_PASSWORD_MAX_LEN)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Ã¢°í> Àß¸øµÈ ¾ÏÈ£¸¦ ÀÔ·ÂÇÏ¼Ì½À´Ï´Ù."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Ã¢> ß¸ È£ Ô·Ï¼Ì½Ï´."));
 		return;
 	}
 	else if (m_pkSafebox)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Ã¢°í> Ã¢°í°¡ ÀÌ¹Ì ¿­·ÁÀÖ½À´Ï´Ù."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Ã¢> Ã¢ Ì¹ Ö½Ï´."));
 		return;
 	}
 
 	int iPulse = thecore_pulse();
 	if (iPulse - GetSafeboxLoadTime() < PASSES_PER_SEC(10))
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Ã¢°í> Ã¢°í¸¦ ´ÝÀºÁö 10ÃÊ ¾È¿¡´Â ¿­ ¼ö ¾ø½À´Ï´Ù."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Ã¢> Ã¢  10 È¿   Ï´."));
 		return;
 	}
 	else if (GetDistanceFromSafeboxOpen() > 1000)
 	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Ã¢°í> °Å¸®°¡ ¸Ö¾î¼­ Ã¢°í¸¦ ¿­ ¼ö ¾ø½À´Ï´Ù."));
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Ã¢> Å¸ Ö¾î¼­ Ã¢   Ï´."));
 		return;
 	}
 	else if (m_bOpeningSafebox)
@@ -8282,9 +8387,9 @@ void CHARACTER::SetNowWalking(bool bWalkFlag)
 		if (IsNPC())
 		{
 			if (m_bNowWalking)
-				MonsterLog("°È´Â´Ù");
+				MonsterLog("È´Â´");
 			else
-				MonsterLog("¶Ú´Ù");
+				MonsterLog("Ú´");
 		}
 
 		//sys_log(0, "%s is now %s", GetName(), m_bNowWalking ? "walking." : "running.");
@@ -8359,8 +8464,30 @@ void CHARACTER::ResetPoint(int iLv)
 	PointChange(POINT_STAT, (MINMAX(1, iLv, gPlayerMaxLevelStats) * 3) + GetPoint(POINT_LEVEL_STEP) - GetPoint(POINT_STAT));
 
 	ComputePoints();
+	// [Security] After stat reset, force-unequip items that no longer meet requirements.
+	for (int i = 0; i < WEAR_MAX_NUM; ++i)
+	{
+		LPITEM pWear = GetWear(i);
+		if (!pWear)
+			continue;
+
+		if (!CanEquipNow(pWear))
+		{
+			// Try normal unequip (to inventory). If inventory is full, drop to ground to prevent abuse.
+			if (!UnequipItem(pWear))
+			{
+				PIXEL_POSITION pos = GetXYZ();
+				pWear->RemoveFromCharacter();
+
+				if (pWear->AddToGround(GetMapIndex(), pos))
+					pWear->SetOwnership(this, 60);
+				else
+					ITEM_MANAGER::instance().RemoveItem(pWear, "FORCE_UNEQUIP_STAT_RESET");
+			}
+		}
+	}
 
-	// È¸º¹
+	// È¸
 	PointChange(POINT_HP, GetMaxHP() - GetHP());
 	PointChange(POINT_SP, GetMaxSP() - GetSP());
 
@@ -8383,31 +8510,31 @@ void CHARACTER::ResetExp()
 #if defined(__CONQUEROR_LEVEL__)
 void CHARACTER::ResetConquerorPoint(int iLv)
 {
-	PointChange(POINT_CONQUEROR_LEVEL, MINMAX(0, iLv, gPlayerMaxConquerorLevel) - GetConquerorLevel());
-
-	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
-	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
-
-	SetRealPoint(POINT_CONQUEROR_POINT, MINMAX(0, (iLv * 4) - 4, (4 * (gPlayerMaxConquerorLevel - 1))));
-	SetPoint(POINT_CONQUEROR_POINT, GetRealPoint(POINT_CONQUEROR_POINT));
-
-	SetRealPoint(POINT_SUNGMA_STR, 0);
-	SetPoint(POINT_SUNGMA_STR, GetRealPoint(POINT_SUNGMA_STR));
-
-	SetRealPoint(POINT_SUNGMA_HP, 0);
-	SetPoint(POINT_SUNGMA_HP, GetRealPoint(POINT_SUNGMA_HP));
-
-	SetRealPoint(POINT_SUNGMA_MOVE, 0);
-	SetPoint(POINT_SUNGMA_MOVE, GetRealPoint(POINT_SUNGMA_MOVE));
-
-	SetRealPoint(POINT_SUNGMA_IMMUNE, 0);
-	SetPoint(POINT_SUNGMA_IMMUNE, GetRealPoint(POINT_SUNGMA_IMMUNE));
-
-	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
-	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
-
-	ComputePoints();
-	PointsPacket();
+	PointChange(POINT_CONQUEROR_LEVEL, MINMAX(0, iLv, gPlayerMaxConquerorLevel) - GetConquerorLevel());
+
+	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
+	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
+
+	SetRealPoint(POINT_CONQUEROR_POINT, MINMAX(0, (iLv * 4) - 4, (4 * (gPlayerMaxConquerorLevel - 1))));
+	SetPoint(POINT_CONQUEROR_POINT, GetRealPoint(POINT_CONQUEROR_POINT));
+
+	SetRealPoint(POINT_SUNGMA_STR, 0);
+	SetPoint(POINT_SUNGMA_STR, GetRealPoint(POINT_SUNGMA_STR));
+
+	SetRealPoint(POINT_SUNGMA_HP, 0);
+	SetPoint(POINT_SUNGMA_HP, GetRealPoint(POINT_SUNGMA_HP));
+
+	SetRealPoint(POINT_SUNGMA_MOVE, 0);
+	SetPoint(POINT_SUNGMA_MOVE, GetRealPoint(POINT_SUNGMA_MOVE));
+
+	SetRealPoint(POINT_SUNGMA_IMMUNE, 0);
+	SetPoint(POINT_SUNGMA_IMMUNE, GetRealPoint(POINT_SUNGMA_IMMUNE));
+
+	SetRealPoint(POINT_CONQUEROR_LEVEL_STEP, 0);
+	SetPoint(POINT_CONQUEROR_LEVEL_STEP, GetRealPoint(POINT_CONQUEROR_LEVEL_STEP));
+
+	ComputePoints();
+	PointsPacket();
 
 	LogManager::instance().CharLog(this, 0, "RESET_CONQUEROR_POINT", "");
 }
@@ -8579,7 +8706,7 @@ void CHARACTER::MonsterChat(BYTE bMonsterChatType)
 
 	std::string text = quest::ScriptToString(sbuf);
 	if (text.empty())
-		return;
+		return;
 
 	TPacketGCChat pack_chat;
 	pack_chat.header = HEADER_GC_CHAT;
@@ -8743,11 +8870,11 @@ void CHARACTER::SetPolymorph(DWORD dwRaceNum, bool bMaintainStat)
 		PointChange(POINT_HT, 0);
 	}
 
-	// Æú¸®¸ðÇÁ »óÅÂ¿¡¼­ Á×´Â °æ¿ì, Æú¸®¸ðÇÁ°¡ Ç®¸®°Ô µÇ´Âµ¥
-	// Æú¸® ¸ðÇÁ ÀüÈÄ·Î valid combo intervalÀÌ ´Ù¸£±â ¶§¹®¿¡
-	// Combo ÇÙ ¶Ç´Â Hacker·Î ÀÎ½ÄÇÏ´Â °æ¿ì°¡ ÀÖ´Ù.
-	// µû¶ó¼­ Æú¸®¸ðÇÁ¸¦ Ç®°Å³ª Æú¸®¸ðÇÁ ÇÏ°Ô µÇ¸é,
-	// valid combo intervalÀ» resetÇÑ´Ù.
+	//  Â¿ ×´ ,  Ç® Ç´Âµ
+	//   Ä· valid combo interval Ù¸ 
+	// Combo  Ç´ Hacker Î½Ï´ ì°¡ Ö´.
+	//   Ç®Å³  Ï° Ç¸,
+	// valid combo interval resetÑ´.
 	SetValidComboInterval(0);
 	SetComboSequence(0);
 
@@ -8848,7 +8975,7 @@ void CHARACTER::DetermineDropMetinStone()
 				else
 				{
 					iGradePct -= iLevelGradePortion;
-					m_dwDropMetinStone += 100; // µ¹ +a -> +(a+1)ÀÌ µÉ¶§¸¶´Ù 100¾¿ Áõ°¡
+					m_dwDropMetinStone += 100; //  +a -> +(a+1) É¶ 100 
 				}
 			}
 		}
@@ -8872,11 +8999,11 @@ void CHARACTER::SendEquipment(LPCHARACTER pChar)
 #if defined(__CHANGE_LOOK_SYSTEM__)
 			Packet.Equips[bSlotIdx].dwTransmutationVnum = pItem->GetTransmutationVnum();
 #endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			thecore_memcpy(&Packet.Equips[bSlotIdx].RefineElement, pItem->GetRefineElement(), sizeof(Packet.Equips[bSlotIdx].RefineElement));
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			thecore_memcpy(&Packet.Equips[bSlotIdx].RefineElement, pItem->GetRefineElement(), sizeof(Packet.Equips[bSlotIdx].RefineElement));
 #endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			thecore_memcpy(Packet.Equips[bSlotIdx].aApplyRandom, pItem->GetRandomApplies(), sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
+#if defined(__ITEM_APPLY_RANDOM__)
+			thecore_memcpy(Packet.Equips[bSlotIdx].aApplyRandom, pItem->GetRandomApplies(), sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
 #endif
 #if defined(__SET_ITEM__)
 			Packet.Equips[bSlotIdx].bSetValue = pItem->GetItemSetValue();
@@ -8886,16 +9013,16 @@ void CHARACTER::SendEquipment(LPCHARACTER pChar)
 		{
 			Packet.Equips[bSlotIdx].dwVnum = 0;
 			Packet.Equips[bSlotIdx].bCount = 0;
-			memset(&Packet.Equips[bSlotIdx].alSockets, 0, sizeof(Packet.Equips[bSlotIdx].alSockets));
+			memset(&Packet.Equips[bSlotIdx].alSockets, 0, sizeof(Packet.Equips[bSlotIdx].alSockets));
 			memset(&Packet.Equips[bSlotIdx].aAttr, 0, sizeof(Packet.Equips[bSlotIdx].aAttr));
 #if defined(__CHANGE_LOOK_SYSTEM__)
 			Packet.Equips[bSlotIdx].dwTransmutationVnum = 0;
 #endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			memset(&Packet.Equips[bSlotIdx].RefineElement, 0, sizeof(Packet.Equips[bSlotIdx].RefineElement));
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			memset(&Packet.Equips[bSlotIdx].RefineElement, 0, sizeof(Packet.Equips[bSlotIdx].RefineElement));
 #endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			memset(&Packet.Equips[bSlotIdx].aApplyRandom, 0, sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
+#if defined(__ITEM_APPLY_RANDOM__)
+			memset(&Packet.Equips[bSlotIdx].aApplyRandom, 0, sizeof(Packet.Equips[bSlotIdx].aApplyRandom));
 #endif
 #if defined(__SET_ITEM__)
 			Packet.Equips[bSlotIdx].bSetValue = 0;
@@ -8948,9 +9075,9 @@ void CHARACTER::MountVnum(DWORD vnum)
 	m_posDest.x = m_posStart.x = GetX();
 	m_posDest.y = m_posStart.y = GetY();
 
-	// NOTE : MountÇÑ´Ù°í ÇØ¼­ Client SideÀÇ °´Ã¼¸¦ »èÁ¦ÇÏÁø ¾Ê´Â´Ù.
-	// ±×¸®°í ¼­¹öSide¿¡¼­ ÅÀÀ»¶§ À§Ä¡ ÀÌµ¿Àº ÇÏÁö ¾Ê´Â´Ù. ¿Ö³ÄÇÏ¸é Client Side¿¡¼­ Coliision Adjust¸¦ ÇÒ¼ö ÀÖ´Âµ¥
-	// °´Ã¼¸¦ ¼Ò¸ê½ÃÄ×´Ù°¡ ¼­¹öÀ§Ä¡·Î ÀÌµ¿½ÃÅ°¸é ÀÌ¶§ collision check¸¦ ÇÏÁö´Â ¾ÊÀ¸¹Ç·Î ¹è°æ¿¡ ³¢°Å³ª ¶Õ°í ³ª°¡´Â ¹®Á¦°¡ Á¸ÀçÇÑ´Ù.
+	// NOTE : MountÑ´Ù° Ø¼ Client Side Ã¼  Ê´Â´.
+	// ×¸ Side  Ä¡ Ìµ  Ê´Â´. Ö³Ï¸ Client Side Coliision Adjust Ò¼ Ö´Âµ
+	// Ã¼ Ò¸×´Ù° Ä¡ ÌµÅ° Ì¶ collision check  Ç· æ¿¡ Å³ Õ°   Ñ´.
 	m_posDest.x = m_posStart.x = GetX();
 	m_posDest.y = m_posStart.y = GetY();
 #if defined(__MOUNT_ENTITY_REFRESH__)
@@ -8964,7 +9091,7 @@ void CHARACTER::MountVnum(DWORD vnum)
 	{
 		LPENTITY entity = (it++)->first;
 
-		// MountÇÑ´Ù°í ÇØ¼­ Client SideÀÇ °´Ã¼¸¦ »èÁ¦ÇÏÁø ¾Ê´Â´Ù.
+		// MountÑ´Ù° Ø¼ Client Side Ã¼  Ê´Â´.
 #if defined(__MOUNT_ENTITY_REFRESH__)
 		EncodeRemovePacket(entity);
 		if (!m_bIsObserver)
@@ -9208,45 +9335,45 @@ bool CHARACTER::WarpToPID(DWORD dwPID, bool bWarpForce)
 			}
 			else
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ó´ë¹æÀÌ ÀÖ´Â °÷À¸·Î ¿öÇÁÇÒ ¼ö ¾ø½À´Ï´Ù."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ö´    Ï´."));
 				return false;
 			}
 		}
 		else
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ó´ë¹æÀÌ ÀÖ´Â °÷À¸·Î ¿öÇÁÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ö´    Ï´."));
 			return false;
 		}
 	}
 	else
 	{
-		// ´Ù¸¥ ¼­¹ö¿¡ ·Î±×ÀÎµÈ »ç¶÷ÀÌ ÀÖÀ½ -> ¸Þ½ÃÁö º¸³» ÁÂÇ¥¸¦ ¹Þ¾Æ¿ÀÀÚ
-		// 1. A.pid, B.pid ¸¦ »Ñ¸²
-		// 2. B.pid¸¦ °¡Áø ¼­¹ö°¡ »Ñ¸°¼­¹ö¿¡°Ô A.pid, ÁÂÇ¥ ¸¦ º¸³¿
-		// 3. ¿öÇÁ
+		// Ù¸  Î±Îµ   -> Þ½  Ç¥ Þ¾Æ¿
+		// 1. A.pid, B.pid  Ñ¸
+		// 2. B.pid   Ñ¸ A.pid, Ç¥  
+		// 3. 
 		CCI* pcci = P2P_MANAGER::instance().FindByPID(dwPID);
 
 		if (!pcci)
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ó´ë¹æÀÌ ¿Â¶óÀÎ »óÅÂ°¡ ¾Æ´Õ´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Â¶ Â° Æ´Õ´Ï´."));
 			return false;
 		}
 
 		if ((pcci->bChannel != g_bChannel) && !bWarpForce)
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ó´ë¹æÀÌ %d Ã¤³Î¿¡ ÀÖ½À´Ï´Ù. (ÇöÀç Ã¤³Î %d)", pcci->bChannel, g_bChannel));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" %d Ã¤Î¿ Ö½Ï´. ( Ã¤ %d)", pcci->bChannel, g_bChannel));
 			return false;
 		}
 		else if (false == IS_SUMMONABLE_ZONE(pcci->lMapIndex))
 		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ó´ë¹æÀÌ ÀÖ´Â °÷À¸·Î ¿öÇÁÇÒ ¼ö ¾ø½À´Ï´Ù."));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ö´    Ï´."));
 			return false;
 		}
 		else
 		{
 			if (!CAN_ENTER_ZONE(this, pcci->lMapIndex))
 			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ó´ë¹æÀÌ ÀÖ´Â °÷À¸·Î ¿öÇÁÇÒ ¼ö ¾ø½À´Ï´Ù."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ö´    Ï´."));
 				return false;
 			}
 
@@ -9284,7 +9411,7 @@ int CHARACTER::ComputeRefineFee(int iCost, int iMultiply) const
 		if (pGuild == GetGuild())
 			return iCost * iMultiply * 9 / 10;
 
-		// ´Ù¸¥ Á¦±¹ »ç¶÷ÀÌ ½ÃµµÇÏ´Â °æ¿ì Ãß°¡·Î 3¹è ´õ
+		// Ù¸   ÃµÏ´  ß° 3 
 		LPCHARACTER chRefineNPC = CHARACTER_MANAGER::instance().Find(m_dwRefineNPCVID);
 		if (chRefineNPC && chRefineNPC->GetEmpire() != GetEmpire())
 			return iCost * iMultiply * 3;
@@ -9304,7 +9431,7 @@ void CHARACTER::PayRefineFee(int iTotalMoney)
 
 	if (pGuild)
 	{
-		// ÀÚ±â ±æµåÀÌ¸é iTotalMoney¿¡ ÀÌ¹Ì 10%°¡ Á¦¿ÜµÇ¾îÀÖ´Ù
+		// Ú± Ì¸ iTotalMoney Ì¹ 10% ÜµÇ¾Ö´
 		if (pGuild != GetGuild())
 		{
 			pGuild->RequestDepositMoney(this, iFee);
@@ -9421,7 +9548,7 @@ bool CHARACTER::PreventTradeWindow(int flags, bool except) const
 }
 // END_PREVENT_TRADE_WINDOW
 
-// Hack ¹æÁö¸¦ À§ÇÑ Ã¼Å©.
+// Hack   Ã¼Å©.
 bool CHARACTER::IsHack(bool bSendMsg, bool bCheckShopOwner, int limittime)
 {
 	const int iPulse = thecore_pulse();
@@ -9429,24 +9556,24 @@ bool CHARACTER::IsHack(bool bSendMsg, bool bCheckShopOwner, int limittime)
 	if (test_server)
 		bSendMsg = true;
 
-	// Ã¢°í ¿¬ÈÄ Ã¼Å©
+	// Ã¢  Ã¼Å©
 	if (iPulse - GetSafeboxLoadTime() < PASSES_PER_SEC(limittime))
 	{
 		if (bSendMsg)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¢°í¸¦ ¿¬ÈÄ %dÃÊ ÀÌ³»¿¡´Â ´Ù¸¥°÷À¸·Î ÀÌµ¿ÇÒ¼ö ¾ø½À´Ï´Ù.", limittime));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¢  %d Ì³ Ù¸ ÌµÒ¼ Ï´.", limittime));
 
 		if (test_server)
 			ChatPacket(CHAT_TYPE_INFO, "[TestOnly]Pulse %d LoadTime %d PASS %d", iPulse, GetSafeboxLoadTime(), PASSES_PER_SEC(limittime));
 		return true;
 	}
 
-	// °Å·¡°ü·Ã Ã¢ Ã¼Å©
+	// Å· Ã¢ Ã¼Å©
 	if (bCheckShopOwner)
 	{
 		if (PreventTradeWindow(WND_ALL))
 		{
 			if (bSendMsg)
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("°Å·¡Ã¢,Ã¢°í µîÀ» ¿¬ »óÅÂ¿¡¼­´Â ´Ù¸¥°÷À¸·Î ÀÌµ¿,Á¾·á ÇÒ¼ö ¾ø½À´Ï´Ù"));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Å·Ã¢,Ã¢   Â¿ Ù¸ Ìµ, Ò¼ Ï´"));
 
 			return true;
 		}
@@ -9456,18 +9583,18 @@ bool CHARACTER::IsHack(bool bSendMsg, bool bCheckShopOwner, int limittime)
 		if (PreventTradeWindow(WND_SHOPOWNER, true/*except*/))
 		{
 			if (bSendMsg)
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("°Å·¡Ã¢,Ã¢°í µîÀ» ¿¬ »óÅÂ¿¡¼­´Â ´Ù¸¥°÷À¸·Î ÀÌµ¿,Á¾·á ÇÒ¼ö ¾ø½À´Ï´Ù"));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Å·Ã¢,Ã¢   Â¿ Ù¸ Ìµ, Ò¼ Ï´"));
 
 			return true;
 		}
 	}
 
 	// PREVENT_PORTAL_AFTER_EXCHANGE
-	// ±³È¯ ÈÄ ½Ã°£Ã¼Å©
+	// È¯  Ã°Ã¼Å©
 	if (iPulse - GetExchangeTime() < PASSES_PER_SEC(limittime))
 	{
 		if (bSendMsg)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("°Å·¡ ÈÄ %dÃÊ ÀÌ³»¿¡´Â ´Ù¸¥Áö¿ªÀ¸·Î ÀÌµ¿ ÇÒ ¼ö ¾ø½À´Ï´Ù.", limittime));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Å·  %d Ì³ Ù¸ Ìµ   Ï´.", limittime));
 		return true;
 	}
 	// END_PREVENT_PORTAL_AFTER_EXCHANGE
@@ -9476,14 +9603,14 @@ bool CHARACTER::IsHack(bool bSendMsg, bool bCheckShopOwner, int limittime)
 	if (iPulse - GetMyShopTime() < PASSES_PER_SEC(limittime))
 	{
 		if (bSendMsg)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("°Å·¡ ÈÄ %dÃÊ ÀÌ³»¿¡´Â ´Ù¸¥Áö¿ªÀ¸·Î ÀÌµ¿ ÇÒ ¼ö ¾ø½À´Ï´Ù.", limittime));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Å·  %d Ì³ Ù¸ Ìµ   Ï´.", limittime));
 		return true;
 	}
 
 	if (iPulse - GetRefineTime() < PASSES_PER_SEC(limittime))
 	{
 		if (bSendMsg)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ °³·®ÈÄ %dÃÊ ÀÌ³»¿¡´Â ±ÍÈ¯ºÎ,±ÍÈ¯±â¾ïºÎ¸¦ »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù.", limittime));
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d Ì³ È¯,È¯Î¸   Ï´.", limittime));
 		return true;
 	}
 
@@ -9605,7 +9732,7 @@ bool CHARACTER::IsSiegeNPC() const
 //------------------------------------------------
 void CHARACTER::UpdateDepositPulse()
 {
-	m_deposit_pulse = thecore_pulse() + PASSES_PER_SEC(60 * 5); // 5ºÐ
+	m_deposit_pulse = thecore_pulse() + PASSES_PER_SEC(60 * 5); // 5
 }
 
 bool CHARACTER::CanDeposit() const
@@ -9811,7 +9938,7 @@ void CHARACTER::StartCheckSpeedHackEvent()
 
 	info->ch = this;
 
-	m_pkCheckSpeedHackEvent = event_create(check_speedhack_event, info, PASSES_PER_SEC(60)); // 1ºÐ
+	m_pkCheckSpeedHackEvent = event_create(check_speedhack_event, info, PASSES_PER_SEC(60)); // 1
 }
 
 void CHARACTER::GoHome()
@@ -9948,7 +10075,7 @@ DWORD CHARACTER::GetSkipComboAttackByTime() const
 	return m_dwSkipComboAttackByTime;
 }
 
-// ¸»ÀÌ³ª ´Ù¸¥°ÍÀ» Å¸°í ÀÖ³ª?
+// Ì³ Ù¸ Å¸ Ö³?
 bool CHARACTER::IsRiding() const
 {
 	return IsHorseRiding() || GetMountVnum();
@@ -10602,17 +10729,17 @@ EVENTFUNC(hit_buff_event)
 	const long buff_value = 30;
 	std::unordered_map<WORD, WORD> map_buff_point
 	{
-		{ POINT_HIT_BUFF_ENCHANT_FIRE, POINT_ENCHANT_FIRE },
-		{ POINT_HIT_BUFF_ENCHANT_ICE, POINT_ENCHANT_ICE },
-		{ POINT_HIT_BUFF_ENCHANT_ELEC, POINT_ENCHANT_ELECT },
-		{ POINT_HIT_BUFF_ENCHANT_WIND, POINT_ENCHANT_WIND },
-		{ POINT_HIT_BUFF_ENCHANT_DARK, POINT_ENCHANT_DARK },
-		{ POINT_HIT_BUFF_ENCHANT_EARTH, POINT_ENCHANT_EARTH },
-		{ POINT_HIT_BUFF_RESIST_FIRE, POINT_ENCHANT_FIRE },
-		{ POINT_HIT_BUFF_RESIST_ICE, POINT_RESIST_ICE },
-		{ POINT_HIT_BUFF_RESIST_ELEC, POINT_RESIST_ELEC },
-		{ POINT_HIT_BUFF_RESIST_WIND, POINT_RESIST_WIND },
-		{ POINT_HIT_BUFF_RESIST_DARK, POINT_RESIST_DARK },
+		{ POINT_HIT_BUFF_ENCHANT_FIRE, POINT_ENCHANT_FIRE },
+		{ POINT_HIT_BUFF_ENCHANT_ICE, POINT_ENCHANT_ICE },
+		{ POINT_HIT_BUFF_ENCHANT_ELEC, POINT_ENCHANT_ELECT },
+		{ POINT_HIT_BUFF_ENCHANT_WIND, POINT_ENCHANT_WIND },
+		{ POINT_HIT_BUFF_ENCHANT_DARK, POINT_ENCHANT_DARK },
+		{ POINT_HIT_BUFF_ENCHANT_EARTH, POINT_ENCHANT_EARTH },
+		{ POINT_HIT_BUFF_RESIST_FIRE, POINT_ENCHANT_FIRE },
+		{ POINT_HIT_BUFF_RESIST_ICE, POINT_RESIST_ICE },
+		{ POINT_HIT_BUFF_RESIST_ELEC, POINT_RESIST_ELEC },
+		{ POINT_HIT_BUFF_RESIST_WIND, POINT_RESIST_WIND },
+		{ POINT_HIT_BUFF_RESIST_DARK, POINT_RESIST_DARK },
 		{ POINT_HIT_BUFF_RESIST_EARTH, POINT_RESIST_EARTH },
 
 		{ POINT_HIT_BUFF_SUNGMA_STR, POINT_SUNGMA_STR },
@@ -10711,7 +10838,7 @@ void CHARACTER::SetEventRaceNum(DWORD dwRaceNum)
 
 	sys_log(0, "EVENT_RACE: %s race %u ", GetName(), dwRaceNum);
 
-	SET_BIT(m_bAddChrState, ADD_CHARACTER_STATE_SPAWN);
+	SET_BIT(m_bAddChrState, ADD_CHARACTER_STATE_SPAWN);
 	m_afAffectFlag.Set(AFF_SPAWN);
 
 	ViewReencode();
@@ -10722,35 +10849,35 @@ void CHARACTER::SetEventRaceNum(DWORD dwRaceNum)
 }
 #endif
 
-#if defined(__HIDE_COSTUME_SYSTEM__)
-void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bSave)
-{
-	switch (bCostumeSubType)
-	{
-		case COSTUME_BODY:
-		case COSTUME_HAIR:
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case COSTUME_ACCE:
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case COSTUME_WEAPON:
-#endif
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case COSTUME_AURA:
-#endif
-			break;
-
-		default:
-		{
-			sys_err("CHARACTER::SetHiddenCostumePart: %s cannot hide unknown costume sub type %u",
-				GetName(), bCostumeSubType);
-			return;
-		}
-	}
-
+#if defined(__HIDE_COSTUME_SYSTEM__)
+void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bSave)
+{
+	switch (bCostumeSubType)
+	{
+		case COSTUME_BODY:
+		case COSTUME_HAIR:
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case COSTUME_ACCE:
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case COSTUME_WEAPON:
+#endif
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case COSTUME_AURA:
+#endif
+			break;
+
+		default:
+		{
+			sys_err("CHARACTER::SetHiddenCostumePart: %s cannot hide unknown costume sub type %u",
+				GetName(), bCostumeSubType);
+			return;
+		}
+	}
+
 	if (IsDead() || IsWarping())
-		return;
-
+		return;
+
 	bool bAttacking = (get_dword_time() - GetLastAttackTime()) < 1500;
 	bool bMoving = (get_dword_time() - GetLastMoveTime()) < 1500;
 	bool bDelayedCMD = false;
@@ -10759,8 +10886,8 @@ void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bS
 	{
 		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have to stand still to hide your costume."));
 		return;
-	}
-
+	}
+
 	int iPulse = thecore_pulse();
 	if (iPulse - m_dwHideCostumePulse < passes_per_sec * 3)
 	{
@@ -10768,73 +10895,73 @@ void CHARACTER::SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bS
 		return;
 	}
 
-	m_dwHideCostumePulse = thecore_pulse();
+	m_dwHideCostumePulse = thecore_pulse();
 	m_bHiddenCostumePart[bCostumeSubType] = bHidden;
 
 	if (bSave)
 		SetQuestFlag(HiddenCostumePartMap[bCostumeSubType], bHidden ? 1 : 0);
 
-	UpdatePacket();
-
-	ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", bCostumeSubType, bHidden ? 1 : 0);
-}
-
-bool CHARACTER::GetHiddenCostumeByPart(BYTE bPartPos) const
-{
-	switch (bPartPos)
-	{
-		case PART_MAIN:
-			if (m_bHiddenCostumePart[COSTUME_BODY] && GetWear(WEAR_COSTUME_BODY))
-				return true;
-			break;
-
-		case PART_HAIR:
-			if (m_bHiddenCostumePart[COSTUME_HAIR] && GetWear(WEAR_COSTUME_HAIR))
-				return true;
-			break;
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case PART_ACCE:
-			if (m_bHiddenCostumePart[COSTUME_ACCE] && GetWear(WEAR_COSTUME_ACCE))
-				return true;
-			break;
-#endif
-
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-		case PART_WEAPON:
-			if (m_bHiddenCostumePart[COSTUME_WEAPON] && GetWear(WEAR_COSTUME_WEAPON))
-				return true;
-			break;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-		case PART_AURA:
-			if (m_bHiddenCostumePart[COSTUME_AURA] && GetWear(WEAR_COSTUME_AURA))
-				return true;
-			break;
-#endif
-
-		default:
-			return false;
-	}
-
-	return false;
-}
-
-void CHARACTER::SetHiddenCostumeParts()
-{
-	bool bHidden = false;
-	for (const THiddenCostumePartMap::value_type& it : HiddenCostumePartMap)
-	{
-		bHidden = (GetQuestFlag(it.second) != 0 ? 1 : 0);
-		m_bHiddenCostumePart[it.first] = bHidden;
-
-		ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", it.first, static_cast<BYTE>(bHidden));
-	}
-}
-#endif
-
-#if defined(__MYSHOP_DECO__)
+	UpdatePacket();
+
+	ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", bCostumeSubType, bHidden ? 1 : 0);
+}
+
+bool CHARACTER::GetHiddenCostumeByPart(BYTE bPartPos) const
+{
+	switch (bPartPos)
+	{
+		case PART_MAIN:
+			if (m_bHiddenCostumePart[COSTUME_BODY] && GetWear(WEAR_COSTUME_BODY))
+				return true;
+			break;
+
+		case PART_HAIR:
+			if (m_bHiddenCostumePart[COSTUME_HAIR] && GetWear(WEAR_COSTUME_HAIR))
+				return true;
+			break;
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case PART_ACCE:
+			if (m_bHiddenCostumePart[COSTUME_ACCE] && GetWear(WEAR_COSTUME_ACCE))
+				return true;
+			break;
+#endif
+
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+		case PART_WEAPON:
+			if (m_bHiddenCostumePart[COSTUME_WEAPON] && GetWear(WEAR_COSTUME_WEAPON))
+				return true;
+			break;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+		case PART_AURA:
+			if (m_bHiddenCostumePart[COSTUME_AURA] && GetWear(WEAR_COSTUME_AURA))
+				return true;
+			break;
+#endif
+
+		default:
+			return false;
+	}
+
+	return false;
+}
+
+void CHARACTER::SetHiddenCostumeParts()
+{
+	bool bHidden = false;
+	for (const THiddenCostumePartMap::value_type& it : HiddenCostumePartMap)
+	{
+		bHidden = (GetQuestFlag(it.second) != 0 ? 1 : 0);
+		m_bHiddenCostumePart[it.first] = bHidden;
+
+		ChatPacket(CHAT_TYPE_COMMAND, "SetHiddenCostumePart %d %d", it.first, static_cast<BYTE>(bHidden));
+	}
+}
+#endif
+
+#if defined(__MYSHOP_DECO__)
 void CHARACTER::OpenPrivateShop(BYTE bTabCount, bool bIsCashItem)
 {
 	if (bTabCount > MYSHOP_MAX_TABS)
@@ -10864,172 +10991,172 @@ void CHARACTER::OpenPrivateShop(BYTE bTabCount, bool bIsCashItem)
 		GetDesc()->BufferedPacket(&Packet, sizeof(TPacketGCShop));
 		GetDesc()->Packet(&Packet2, sizeof(TPacketGCMyPrivShopOpen));
 	}
-}
-#endif
-
-#if defined(__LEFT_SEAT__)
-EVENTFUNC(left_seat_wait_timer_event)
-{
-	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-	if (info == NULL)
-	{
-		sys_err("left_seat_wait_timer_event> <Factor> Null pointer");
-		return 0;
-	}
-
+}
+#endif
+
+#if defined(__LEFT_SEAT__)
+EVENTFUNC(left_seat_wait_timer_event)
+{
+	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+	if (info == NULL)
+	{
+		sys_err("left_seat_wait_timer_event> <Factor> Null pointer");
+		return 0;
+	}
+
 	LPCHARACTER ch = info->ch;
 	if (ch == NULL) // <Factor>
-		return 0;
-
-	if (ch->GetMyShop())
-		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
-
-	if (ch->IsRunningQuest())
-		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
-
-	if (get_dword_time() - ch->GetLastRequestTime() > 1000 * ch->GetLeftSeatWaitTime())
-	{
-		if (ch->LeftSeat() == false)
-		{
-			ch->SetLeftSeat(true);
-
-			if (ch->GetLeftSeatLogoutTime())
-				ch->RestartLeftSeatLogoutTimer();
-		}
-	}
-
-	return PASSES_PER_SEC(LEFT_SEAT_PULSE);
-}
-
-void CHARACTER::RestartLeftSeatWaitTimer()
-{
-	if (m_pLeftSeatWaitTimerEvent)
-		event_cancel(&m_pLeftSeatWaitTimerEvent);
-
-	char_event_info* info = AllocEventInfo<char_event_info>();
-	info->ch = this;
-	m_pLeftSeatWaitTimerEvent = event_create(left_seat_wait_timer_event, info, PASSES_PER_SEC(LEFT_SEAT_PULSE));
-}
-
-void CHARACTER::SetLeftSeatWaitTime(BYTE bIndex)
-{
-	DWORD dwTime = 0;
-	switch (bIndex)
-	{
-		case LEFT_SEAT_TIME_10_MIN:
-			dwTime = 60 * 10;
-			break;
-		case LEFT_SEAT_TIME_30_MIN:
-			dwTime = 60 * 30;
-			break;
-		case LEFT_SEAT_TIME_90_MIN:
-			dwTime = 60 * 90;
-			break;
-		default:
-			dwTime = 60 * 10;
-			break;
-	}
-
-	//if (test_server)
-	//	dwTime = 10;
-
-	m_dwLeftSeatWaitTime = dwTime;
-	RestartLeftSeatWaitTimer();
-}
-
-EVENTFUNC(left_seat_logout_timer_event)
-{
-	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-	if (info == NULL)
-	{
-		sys_err("left_seat_logout_timer_event> <Factor> Null pointer");
-		return 0;
-	}
-
+		return 0;
+
+	if (ch->GetMyShop())
+		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
+
+	if (ch->IsRunningQuest())
+		return PASSES_PER_SEC(LEFT_SEAT_PULSE);
+
+	if (get_dword_time() - ch->GetLastRequestTime() > 1000 * ch->GetLeftSeatWaitTime())
+	{
+		if (ch->LeftSeat() == false)
+		{
+			ch->SetLeftSeat(true);
+
+			if (ch->GetLeftSeatLogoutTime())
+				ch->RestartLeftSeatLogoutTimer();
+		}
+	}
+
+	return PASSES_PER_SEC(LEFT_SEAT_PULSE);
+}
+
+void CHARACTER::RestartLeftSeatWaitTimer()
+{
+	if (m_pLeftSeatWaitTimerEvent)
+		event_cancel(&m_pLeftSeatWaitTimerEvent);
+
+	char_event_info* info = AllocEventInfo<char_event_info>();
+	info->ch = this;
+	m_pLeftSeatWaitTimerEvent = event_create(left_seat_wait_timer_event, info, PASSES_PER_SEC(LEFT_SEAT_PULSE));
+}
+
+void CHARACTER::SetLeftSeatWaitTime(BYTE bIndex)
+{
+	DWORD dwTime = 0;
+	switch (bIndex)
+	{
+		case LEFT_SEAT_TIME_10_MIN:
+			dwTime = 60 * 10;
+			break;
+		case LEFT_SEAT_TIME_30_MIN:
+			dwTime = 60 * 30;
+			break;
+		case LEFT_SEAT_TIME_90_MIN:
+			dwTime = 60 * 90;
+			break;
+		default:
+			dwTime = 60 * 10;
+			break;
+	}
+
+	//if (test_server)
+	//	dwTime = 10;
+
+	m_dwLeftSeatWaitTime = dwTime;
+	RestartLeftSeatWaitTimer();
+}
+
+EVENTFUNC(left_seat_logout_timer_event)
+{
+	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+	if (info == NULL)
+	{
+		sys_err("left_seat_logout_timer_event> <Factor> Null pointer");
+		return 0;
+	}
+
 	LPCHARACTER ch = info->ch;
 	if (ch == NULL) // <Factor>
-		return 0;
-
-	LPDESC d = ch->GetDesc();
-	if (ch->LeftSeat())
+		return 0;
+
+	LPDESC d = ch->GetDesc();
+	if (ch->LeftSeat())
 	{
 		ch->Disconnect("LEFT_SEAT");
 		if (d)
-			d->SetPhase(PHASE_CLOSE);
-	}
-
-	return 0;
-}
-
-void CHARACTER::RestartLeftSeatLogoutTimer()
-{
-	if (m_pLeftSeatLogoutTimerEvent)
-		event_cancel(&m_pLeftSeatLogoutTimerEvent);
-
-	const DWORD dwTime = GetLeftSeatLogoutTime();
-	if (dwTime == 0)
-		return;
-
-	char_event_info* info = AllocEventInfo<char_event_info>();
-	info->ch = this;
-	m_pLeftSeatLogoutTimerEvent = event_create(left_seat_logout_timer_event, info, PASSES_PER_SEC(dwTime));
-}
-
-void CHARACTER::SetLeftSeatLogoutTime(BYTE bIndex)
-{
-	DWORD dwTime = 0;
-	switch (bIndex)
-	{
-		case LEFT_SEAT_LOGOUT_TIME_30_MIN:
-			dwTime = 60 * 30;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_60_MIN:
-			dwTime = 60 * 60;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_120_MIN:
-			dwTime = 60 * 120;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_180_MIN:
-			dwTime = 60 * 180;
-			break;
-		case LEFT_SEAT_LOGOUT_TIME_OFF:
-			dwTime = 0;
-			break;
-		default:
-			dwTime = 60 * 30;
-			break;
-	}
-
-	//if (test_server)
-	//	dwTime = 10;
-
-	m_dwLeftSeatLogoutTime = dwTime;
-}
-
-void CHARACTER::DisableLeftSeatLogOutState(bool bClosePopup)
-{
-	if (bClosePopup)
-		ChatPacket(CHAT_TYPE_COMMAND, "CloseLeftSeatDialog");
-
-	if (m_pLeftSeatLogoutTimerEvent)
-		event_cancel(&m_pLeftSeatLogoutTimerEvent);
-
-	m_dwLastRequestTime = get_dword_time();
-
-	SetLeftSeat(false);
-	RestartLeftSeatWaitTimer();
-}
-
-void CHARACTER::SetLeftSeat(bool bLeftSeat)
-{
-	if (bLeftSeat)
-		ChatPacket(CHAT_TYPE_COMMAND, "OpenLeftSeatDialog");
-
-	m_bLeftSeat = bLeftSeat;
-	UpdatePacket();
-}
-#endif
-
+			d->SetPhase(PHASE_CLOSE);
+	}
+
+	return 0;
+}
+
+void CHARACTER::RestartLeftSeatLogoutTimer()
+{
+	if (m_pLeftSeatLogoutTimerEvent)
+		event_cancel(&m_pLeftSeatLogoutTimerEvent);
+
+	const DWORD dwTime = GetLeftSeatLogoutTime();
+	if (dwTime == 0)
+		return;
+
+	char_event_info* info = AllocEventInfo<char_event_info>();
+	info->ch = this;
+	m_pLeftSeatLogoutTimerEvent = event_create(left_seat_logout_timer_event, info, PASSES_PER_SEC(dwTime));
+}
+
+void CHARACTER::SetLeftSeatLogoutTime(BYTE bIndex)
+{
+	DWORD dwTime = 0;
+	switch (bIndex)
+	{
+		case LEFT_SEAT_LOGOUT_TIME_30_MIN:
+			dwTime = 60 * 30;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_60_MIN:
+			dwTime = 60 * 60;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_120_MIN:
+			dwTime = 60 * 120;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_180_MIN:
+			dwTime = 60 * 180;
+			break;
+		case LEFT_SEAT_LOGOUT_TIME_OFF:
+			dwTime = 0;
+			break;
+		default:
+			dwTime = 60 * 30;
+			break;
+	}
+
+	//if (test_server)
+	//	dwTime = 10;
+
+	m_dwLeftSeatLogoutTime = dwTime;
+}
+
+void CHARACTER::DisableLeftSeatLogOutState(bool bClosePopup)
+{
+	if (bClosePopup)
+		ChatPacket(CHAT_TYPE_COMMAND, "CloseLeftSeatDialog");
+
+	if (m_pLeftSeatLogoutTimerEvent)
+		event_cancel(&m_pLeftSeatLogoutTimerEvent);
+
+	m_dwLastRequestTime = get_dword_time();
+
+	SetLeftSeat(false);
+	RestartLeftSeatWaitTimer();
+}
+
+void CHARACTER::SetLeftSeat(bool bLeftSeat)
+{
+	if (bLeftSeat)
+		ChatPacket(CHAT_TYPE_COMMAND, "OpenLeftSeatDialog");
+
+	m_bLeftSeat = bLeftSeat;
+	UpdatePacket();
+}
+#endif
+
 #if defined(__ELEMENTAL_DUNGEON__)
 EVENTFUNC(elemental_curse_event)
 {
@@ -11049,7 +11176,7 @@ EVENTFUNC(elemental_curse_event)
 
 	// NOTE : Increase the hp reduction level every 200.000 damage.
 	int iReductionLevel = MINMAX(1, dwAccumulatedDamage / 200000, 10);
-	int iDropHP = static_cast<int>(ch->GetMaxHP() * (fReductionPct[iReductionLevel - 1] / 100.0f));
+	int iDropHP = static_cast<int>(ch->GetMaxHP() * (fReductionPct[iReductionLevel - 1] / 100.0f));
 
 	CAffect* pAffect = ch->FindAffect(AFFECT_CURSE_OF_ELEMENTAL);
 	if (pAffect == NULL || iReductionLevel > pAffect->lApplyValue)
@@ -11705,7 +11832,11 @@ void CHARACTER::UpdateExtBattlePassMissionProgress(DWORD dwMissionType, DWORD dw
 				if (!foundMission)
 				{
 					if (!IsExtBattlePassRegistered(bBattlePassType, bBattlePassID))
-						DBManager::instance().DirectQuery("INSERT INTO player.battlepass_playerindex SET player_id=%d, player_name='%s', battlepass_type=%d, battlepass_id=%d, start_time=NOW()", GetPlayerID(), GetName(), bBattlePassType, bBattlePassID);
+						{
+							char szNameEsc[(CHARACTER_NAME_MAX_LEN + 1) * 2 + 1];
+							DBManager::instance().EscapeString(szNameEsc, sizeof(szNameEsc), GetName(), strlen(GetName()));
+							DBManager::instance().DirectQuery("INSERT INTO player.battlepass_playerindex SET player_id=%d, player_name='%s', battlepass_type=%d, battlepass_id=%d, start_time=NOW()", GetPlayerID(), szNameEsc, bBattlePassType, bBattlePassID);
+						}
 					
 					TPlayerExtBattlePassMission* newMission = new TPlayerExtBattlePassMission;
 					newMission->dwPlayerId = GetPlayerID();
@@ -11847,7 +11978,11 @@ void CHARACTER::SetExtBattlePassMissionProgress(BYTE bBattlePassType, DWORD dwMi
 		if (!foundMission)
 		{
 			if (!IsExtBattlePassRegistered(bBattlePassType, bBattlePassID))
-				DBManager::instance().DirectQuery("INSERT INTO player.battlepass_playerindex SET player_id=%d, player_name='%s', battlepass_type=%d, battlepass_id=%d, start_time=NOW()", GetPlayerID(), GetName(), bBattlePassType, bBattlePassID);
+				{
+					char szNameEsc[(CHARACTER_NAME_MAX_LEN + 1) * 2 + 1];
+					DBManager::instance().EscapeString(szNameEsc, sizeof(szNameEsc), GetName(), strlen(GetName()));
+					DBManager::instance().DirectQuery("INSERT INTO player.battlepass_playerindex SET player_id=%d, player_name='%s', battlepass_type=%d, battlepass_id=%d, start_time=NOW()", GetPlayerID(), szNameEsc, bBattlePassType, bBattlePassID);
+				}
 
 			TPlayerExtBattlePassMission* newMission = new TPlayerExtBattlePassMission;
 			newMission->dwPlayerId = GetPlayerID();
diff --git a/server/metin2/Source/Server/game/src/char.h b/server/metin2/Source/Server/game/src/char.h
index 0e5f8d5..4b5c722 100644
--- a/server/metin2/Source/Server/game/src/char.h
+++ b/server/metin2/Source/Server/game/src/char.h
@@ -1,3290 +1,3305 @@
-#ifndef __INC_CHAR_H__
-#define __INC_CHAR_H__
-
-#include "../../common/stl.h"
-#include "entity.h"
-#include "FSM.h"
-#include "horse_rider.h"
-#include "vid.h"
-#include "constants.h"
-#include "affect.h"
-#include "affect_flag.h"
-#include "cube.h"
-#include "mining.h"
-#include "packet.h"
-
-#if defined(__LUCKY_BOX__)
-#	include "item_manager.h"
-#endif
-#if defined(__CHANGE_LOOK_SYSTEM__)
-#	include "changelook.h"
-#endif
-#if defined(__MAILBOX__)
-#	include "MailBox.h"
-#endif
-#if defined(__GEM_SHOP__)
-#	include "GemShop.h"
-#endif
-#if defined(__RANKING_SYSTEM__)
-#	include "Ranking.h"
-#endif
-#if defined(__MINI_GAME_RUMI__)
-#	include "minigame_rumi.h"
-#endif
-#if defined(__MINI_GAME_YUTNORI__)
-#	include "minigame_yutnori.h"
-#endif
-#if defined(__MINI_GAME_CATCH_KING__)
-#	include "minigame_catchking.h"
-#endif
-#if defined(__FLOWER_EVENT__)
-#	include "flower_event.h"
-#endif
-#if defined(__SUMMER_EVENT_ROULETTE__)
-#	include "minigame_roulette.h"
-#endif
-#if defined(__INGAME_EVENT_MANAGER__)
-#	include "ingame_event_manager.h"
-#endif
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-#	include "guild_dragonlair.h"
-#endif
-
-class CBuffOnAttributes;
-class CPetSystem;
-#if defined(__LOOT_FILTER_SYSTEM__)
-class CLootFilter;
-#endif
-#ifdef __OFFLINE_SHOP__
-class COfflineShop;
-#endif
-
-#define INSTANT_FLAG_DEATH_PENALTY (1 << 0)
-#define INSTANT_FLAG_SHOP (1 << 1)
-#define INSTANT_FLAG_EXCHANGE (1 << 2)
-#define INSTANT_FLAG_STUN (1 << 3)
-#define INSTANT_FLAG_NO_REWARD (1 << 4)
-
-#define AI_FLAG_NPC (1 << 0)
-#define AI_FLAG_AGGRESSIVE (1 << 1)
-#define AI_FLAG_HELPER (1 << 2)
-#define AI_FLAG_STAYZONE (1 << 3)
-
-#define SET_OVER_TIME(ch, time) (ch)->SetOverTime(time)
-
-#ifdef __GROWTH_PET_SYSTEM__
-#include "growth_pet.h"
-#endif
-extern int g_nPortalLimitTime;
-
-extern bool IS_SUMMON_ITEM(LPITEM item, int map_index = 0);
-extern bool IS_SUMMONABLE_ZONE(int map_index);
-
-extern bool IS_MONKEY_DUNGEON(int map_index);
-extern bool IS_MAZE_DUNGEON(int map_index);
-
-#if defined(__SNOW_DUNGEON__)
-extern bool IS_SNOW_DUNGEON(int map_index);
-#endif
-
-#if defined(__ELEMENTAL_DUNGEON__)
-extern bool IS_ELEMENTAL_DUNGEON(int map_index);
-#endif
-
-extern bool CAN_ENTER_ZONE(const LPCHARACTER& ch, int map_index);
-extern bool IS_BLOCKED_PET(int map_index); // char.cpp
-extern bool IS_BLOCKED_PET_DUNGEON_MAP(int map_index);
-
-enum
-{
-	MAIN_RACE_WARRIOR_M,
-	MAIN_RACE_ASSASSIN_W,
-	MAIN_RACE_SURA_M,
-	MAIN_RACE_SHAMAN_W,
-	MAIN_RACE_WARRIOR_W,
-	MAIN_RACE_ASSASSIN_M,
-	MAIN_RACE_SURA_W,
-	MAIN_RACE_SHAMAN_M,
-	MAIN_RACE_WOLFMAN_M,
-	MAIN_RACE_MAX_NUM,
-};
-
-enum
-{
-	POISON_LENGTH = 30,
-	BLEEDING_LENGTH = 30,
-	STAMINA_PER_STEP = 1,
-	SAFEBOX_PAGE_SIZE = 9,
-	AI_CHANGE_ATTACK_POISITION_TIME_NEAR = 10000,
-	AI_CHANGE_ATTACK_POISITION_TIME_FAR = 1000,
-	AI_CHANGE_ATTACK_POISITION_DISTANCE = 100,
-	SUMMON_MONSTER_COUNT = 3,
-};
-
-enum
-{
-	FLY_NONE,
-	FLY_EXP,
-	FLY_HP_MEDIUM,
-	FLY_HP_BIG,
-	FLY_SP_SMALL,
-	FLY_SP_MEDIUM,
-	FLY_SP_BIG,
-	FLY_FIREWORK1,
-	FLY_FIREWORK2,
-	FLY_FIREWORK3,
-	FLY_FIREWORK4,
-	FLY_FIREWORK5,
-	FLY_FIREWORK6,
-	FLY_FIREWORK_CHRISTMAS,
-	FLY_CHAIN_LIGHTNING,
-	FLY_HP_SMALL,
-	FLY_SKILL_MUYEONG,
-#if defined(__QUIVER_SYSTEM__)
-	FLY_QUIVER_ATTACK_NORMAL,
-#endif
-#if defined(__CONQUEROR_LEVEL__)
-	FLY_ILGWANGPYO_NORMAL,
-	FLY_ILGWANGPYO_MASTER,
-	FLY_ILGWANGPYO_GRAND_MASTER,
-	FLY_ILGWANGPYO_PERFECT_MASTER,
-	FLY_CONQUEROR_EXP,
-#endif
-};
-
-enum EDamageType
-{
-	DAMAGE_TYPE_NONE,
-	DAMAGE_TYPE_NORMAL,
-	DAMAGE_TYPE_NORMAL_RANGE,
-	// ½ºÅ³
-	DAMAGE_TYPE_MELEE,
-	DAMAGE_TYPE_RANGE,
-	DAMAGE_TYPE_FIRE,
-	DAMAGE_TYPE_ICE,
-	DAMAGE_TYPE_ELEC,
-	DAMAGE_TYPE_MAGIC,
-	DAMAGE_TYPE_POISON,
-	DAMAGE_TYPE_SPECIAL,
-	DAMAGE_TYPE_BLEEDING,
-};
-
-enum DamageFlag
-{
-	DAMAGE_NORMAL = (1 << 0),
-	DAMAGE_POISON = (1 << 1),
-	DAMAGE_DODGE = (1 << 2),
-	DAMAGE_BLOCK = (1 << 3),
-	DAMAGE_PENETRATE = (1 << 4),
-	DAMAGE_CRITICAL = (1 << 5),
-	DAMAGE_BLEEDING = (1 << 6),
-};
-
-enum EPKModes
-{
-	PK_MODE_PEACE,
-	PK_MODE_REVENGE,
-	PK_MODE_FREE,
-	PK_MODE_PROTECT,
-	PK_MODE_GUILD,
-	PK_MODE_MAX_NUM
-};
-
-enum EPositions
-{
-	POS_DEAD,
-	POS_SLEEPING,
-	POS_RESTING,
-	POS_SITTING,
-	POS_FISHING,
-	POS_FIGHTING,
-	POS_MOUNTING,
-	POS_STANDING
-};
-
-enum EBlockAction
-{
-	BLOCK_EXCHANGE = (1 << 0),
-	BLOCK_PARTY_INVITE = (1 << 1),
-	BLOCK_GUILD_INVITE = (1 << 2),
-	BLOCK_WHISPER = (1 << 3),
-	BLOCK_MESSENGER_INVITE = (1 << 4),
-	BLOCK_PARTY_REQUEST = (1 << 5),
-};
-
-#ifdef __OFFLINE_SHOP__
-enum EUnlockShopSkin
-{
-	UNLOCK_SHOP_SKIN_1 = (1 << 0),
-	UNLOCK_SHOP_SKIN_2 = (1 << 1),
-	UNLOCK_SHOP_SKIN_3 = (1 << 2),
-	UNLOCK_SHOP_SKIN_4 = (1 << 3),
-	UNLOCK_SHOP_SKIN_5 = (1 << 4),
-	UNLOCK_SHOP_SKIN_6 = (1 << 5),
-	UNLOCK_SHOP_SKIN_7 = (1 << 6),
-	UNLOCK_SHOP_SKIN_8 = (1 << 7),
-};
-
-enum EUnlockShopBanner
-{
-	UNLOCK_SHOP_BANNER_1 = (1 << 0),
-	UNLOCK_SHOP_BANNER_2 = (1 << 1),
-	UNLOCK_SHOP_BANNER_3 = (1 << 2),
-	UNLOCK_SHOP_BANNER_4 = (1 << 3),
-	UNLOCK_SHOP_BANNER_5 = (1 << 4),
-};
-#endif
-
-enum EAlignmentGrade
-{
-	ALIGN_GRADE_GOOD_4,
-	ALIGN_GRADE_GOOD_3,
-	ALIGN_GRADE_GOOD_2,
-	ALIGN_GRADE_GOOD_1,
-	ALIGN_GRADE_NORMAL,
-	ALIGN_GRADE_EVIL_1,
-	ALIGN_GRADE_EVIL_2,
-	ALIGN_GRADE_EVIL_3,
-	ALIGN_GRADE_EVIL_4,
-};
-
-enum EPointTypes
-{
-	POINT_NONE,								// 0
-	POINT_LEVEL,							// 1
-	POINT_VOICE,							// 2
-	POINT_EXP,								// 3
-	POINT_NEXT_EXP,							// 4
-	POINT_HP,								// 5
-	POINT_MAX_HP,							// 6
-	POINT_SP,								// 7
-	POINT_MAX_SP,							// 8
-	POINT_STAMINA,							// 9 ½ºÅ×¹Ì³Ê
-	POINT_MAX_STAMINA,						// 10 ÃÖ´ë ½ºÅ×¹Ì³Ê
-
-	POINT_GOLD,								// 11
-	POINT_ST,								// 12 ±Ù·Â
-	POINT_HT,								// 13 Ã¼·Â
-	POINT_DX,								// 14 ¹ÎÃ¸¼º
-	POINT_IQ,								// 15 Á¤½Å·Â
-	POINT_DEF_GRADE,						// 16 ...
-	POINT_ATT_SPEED,						// 17 °ø°Ý¼Óµµ
-	POINT_ATT_GRADE,						// 18 °ø°Ý·Â MAX
-	POINT_MOV_SPEED,						// 19 ÀÌµ¿¼Óµµ
-	POINT_CLIENT_DEF_GRADE,					// 20 ¹æ¾îµî±Þ
-	POINT_CASTING_SPEED,					// 21 ÁÖ¹®¼Óµµ (Äð´Ù¿îÅ¸ÀÓ*100) / (100 + ÀÌ°ª) = ÃÖÁ¾ Äð´Ù¿î Å¸ÀÓ
-	POINT_MAGIC_ATT_GRADE,					// 22 ¸¶¹ý°ø°Ý·Â
-	POINT_MAGIC_DEF_GRADE,					// 23 ¸¶¹ý¹æ¾î·Â
-	POINT_EMPIRE_POINT,						// 24 Á¦±¹Á¡¼ö
-	POINT_LEVEL_STEP,						// 25 ÇÑ ·¹º§¿¡¼­ÀÇ ´Ü°è.. (1 2 3 µÉ ¶§ º¸»ó, 4 µÇ¸é ·¹º§ ¾÷)
-	POINT_STAT,								// 26 ´É·ÂÄ¡ ¿Ã¸± ¼ö ÀÖ´Â °³¼ö
-	POINT_SUB_SKILL,						// 27 º¸Á¶ ½ºÅ³ Æ÷ÀÎÆ®
-	POINT_SKILL,							// 28 ¾×Æ¼ºê ½ºÅ³ Æ÷ÀÎÆ®
-	POINT_WEAPON_MIN,						// 29 ¹«±â ÃÖ¼Ò µ¥¹ÌÁö
-	POINT_WEAPON_MAX,						// 30 ¹«±â ÃÖ´ë µ¥¹ÌÁö
-	POINT_PLAYTIME,							// 31 ÇÃ·¹ÀÌ½Ã°£
-	POINT_HP_REGEN,							// 32 HP È¸º¹·ü
-	POINT_SP_REGEN,							// 33 SP È¸º¹·ü
-
-	POINT_BOW_DISTANCE,						// 34 È° »çÁ¤°Å¸® Áõ°¡Ä¡ (meter)
-
-	POINT_HP_RECOVERY,						// 35 Ã¼·Â È¸º¹ Áõ°¡·®
-	POINT_SP_RECOVERY,						// 36 Á¤½Å·Â È¸º¹ Áõ°¡·®
-
-	POINT_POISON_PCT,						// 37 µ¶ È®·ü
-	POINT_STUN_PCT,							// 38 ±âÀý È®·ü
-	POINT_SLOW_PCT,							// 39 ½½·Î¿ì È®·ü
-	POINT_CRITICAL_PCT,						// 40 Å©¸®Æ¼ÄÃ È®·ü
-	POINT_PENETRATE_PCT,					// 41 °üÅëÅ¸°Ý È®·ü
-	POINT_CURSE_PCT,						// 42 ÀúÁÖ È®·ü
-
-	POINT_ATTBONUS_HUMAN,					// 43 ÀÎ°£¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_ANIMAL,					// 44 µ¿¹°¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-	POINT_ATTBONUS_ORC,						// 45 ¿õ±Í¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-	POINT_ATTBONUS_MILGYO,					// 46 ¹Ð±³¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-	POINT_ATTBONUS_UNDEAD,					// 47 ½ÃÃ¼¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-	POINT_ATTBONUS_DEVIL,					// 48 ¸¶±Í(¾Ç¸¶)¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-	POINT_ATTBONUS_INSECT,					// 49 ¹ú·¹Á·
-	POINT_ATTBONUS_FIRE,					// 50 È­¿°Á·
-	POINT_ATTBONUS_ICE,						// 51 ºù¼³Á·
-	POINT_ATTBONUS_DESERT,					// 52 »ç¸·Á·
-	POINT_ATTBONUS_MONSTER,					// 53 ¸ðµç ¸ó½ºÅÍ¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_WARRIOR,					// 54 ¹«»ç¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_ASSASSIN,				// 55 ÀÚ°´¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_SURA,					// 56 ¼ö¶ó¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_SHAMAN,					// 57 ¹«´ç¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_TREE,					// 58 ³ª¹«¿¡°Ô °­ÇÔ 20050729.myevan UNUSED5
-
-	POINT_RESIST_WARRIOR,					// 59 ¹«»ç¿¡°Ô ÀúÇ×
-	POINT_RESIST_ASSASSIN,					// 60 ÀÚ°´¿¡°Ô ÀúÇ×
-	POINT_RESIST_SURA,						// 61 ¼ö¶ó¿¡°Ô ÀúÇ×
-	POINT_RESIST_SHAMAN,					// 62 ¹«´ç¿¡°Ô ÀúÇ×
-
-	POINT_STEAL_HP,							// 63 »ý¸í·Â Èí¼ö
-	POINT_STEAL_SP,							// 64 Á¤½Å·Â Èí¼ö
-
-	POINT_MANA_BURN_PCT,					// 65 ¸¶³ª ¹ø
-
-	/// ÇÇÇØ½Ã º¸³Ê½º ///
-
-	POINT_DAMAGE_SP_RECOVER,				// 66 °ø°Ý´çÇÒ ½Ã Á¤½Å·Â È¸º¹ È®·ü
-
-	POINT_BLOCK,							// 67 ºí·°À²
-	POINT_DODGE,							// 68 È¸ÇÇÀ²
-
-	POINT_RESIST_SWORD,						// 69
-	POINT_RESIST_TWOHAND,					// 70
-	POINT_RESIST_DAGGER,					// 71
-	POINT_RESIST_BELL,						// 72
-	POINT_RESIST_FAN,						// 73
-	POINT_RESIST_BOW,						// 74 È­»ì ÀúÇ× : ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_FIRE,						// 75 È­¿° ÀúÇ× : È­¿°°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_ELEC,						// 76 Àü±â ÀúÇ× : Àü±â°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_MAGIC,						// 77 ¼ú¹ý ÀúÇ× : ¸ðµç¼ú¹ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_WIND,						// 78 ¹Ù¶÷ ÀúÇ× : ¹Ù¶÷°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-
-	POINT_REFLECT_MELEE,					// 79 °ø°Ý ¹Ý»ç
-
-	/// Æ¯¼ö ÇÇÇØ½Ã ///
-	POINT_REFLECT_CURSE,					// 80 ÀúÁÖ ¹Ý»ç
-	POINT_POISON_REDUCE,					// 81 µ¶µ¥¹ÌÁö °¨¼Ò
-
-	/// Àû ¼Ò¸ê½Ã ///
-	POINT_KILL_SP_RECOVER,					// 82 Àû ¼Ò¸ê½Ã MP È¸º¹
-	POINT_EXP_DOUBLE_BONUS,					// 83
-	POINT_GOLD_DOUBLE_BONUS,				// 84
-	POINT_ITEM_DROP_BONUS,					// 85
-
-	/// È¸º¹ °ü·Ã ///
-	POINT_POTION_BONUS,						// 86
-	POINT_KILL_HP_RECOVERY,					// 87
-
-	POINT_IMMUNE_STUN,						// 88
-	POINT_IMMUNE_SLOW,						// 89
-	POINT_IMMUNE_FALL,						// 90
-	//////////////////
-
-	POINT_PARTY_ATTACKER_BONUS,				// 91
-	POINT_PARTY_TANKER_BONUS,				// 92
-
-	POINT_ATT_BONUS,						// 93
-	POINT_DEF_BONUS,						// 94
-
-	POINT_ATT_GRADE_BONUS,					// 95
-	POINT_DEF_GRADE_BONUS,					// 96
-	POINT_MAGIC_ATT_GRADE_BONUS,			// 97
-	POINT_MAGIC_DEF_GRADE_BONUS,			// 98
-
-	POINT_RESIST_NORMAL_DAMAGE,				// 99
-
-	POINT_HIT_HP_RECOVERY,					// 100
-	POINT_HIT_SP_RECOVERY,					// 101
-	POINT_MANASHIELD,						// 102 Èæ½Å¼öÈ£ ½ºÅ³¿¡ ÀÇÇÑ ¸¶³ª½¯µå È¿°ú Á¤µµ
-
-	POINT_PARTY_BUFFER_BONUS,				// 103
-	POINT_PARTY_SKILL_MASTER_BONUS,			// 104
-
-	POINT_HP_RECOVER_CONTINUE,				// 105
-	POINT_SP_RECOVER_CONTINUE,				// 106
-
-	POINT_STEAL_GOLD,						// 107
-	POINT_POLYMORPH,						// 108 º¯½ÅÇÑ ¸ó½ºÅÍ ¹øÈ£
-	POINT_MOUNT,							// 109 Å¸°íÀÖ´Â ¸ó½ºÅÍ ¹øÈ£
-
-	POINT_PARTY_HASTE_BONUS,				// 110
-	POINT_PARTY_DEFENDER_BONUS,				// 111
-	POINT_STAT_RESET_COUNT,					// 112 ÇÇÀÇ ´Ü¾à »ç¿ëÀ» ÅëÇÑ ½ºÅÝ ¸®¼Â Æ÷ÀÎÆ® (1´ç 1Æ÷ÀÎÆ® ¸®¼Â°¡´É)
-
-	POINT_HORSE_SKILL,						// 113
-
-	POINT_MALL_ATTBONUS,					// 114 °ø°Ý·Â +x%
-	POINT_MALL_DEFBONUS,					// 115 ¹æ¾î·Â +x%
-	POINT_MALL_EXPBONUS,					// 116 °æÇèÄ¡ +x%
-	POINT_MALL_ITEMBONUS,					// 117 ¾ÆÀÌÅÛ µå·ÓÀ² x/10¹è
-	POINT_MALL_GOLDBONUS,					// 118 µ· µå·ÓÀ² x/10¹è
-
-	POINT_MAX_HP_PCT,						// 119 ÃÖ´ë»ý¸í·Â +x%
-	POINT_MAX_SP_PCT,						// 120 ÃÖ´ëÁ¤½Å·Â +x%
-
-	POINT_SKILL_DAMAGE_BONUS,				// 121 ½ºÅ³ µ¥¹ÌÁö *(100+x)%
-	POINT_NORMAL_HIT_DAMAGE_BONUS,			// 122 ÆòÅ¸ µ¥¹ÌÁö *(100+x)%
-
-	// DEFEND_BONUS_ATTRIBUTES
-	POINT_SKILL_DEFEND_BONUS,				// 123 ½ºÅ³ ¹æ¾î µ¥¹ÌÁö
-	POINT_NORMAL_HIT_DEFEND_BONUS,			// 124 ÆòÅ¸ ¹æ¾î µ¥¹ÌÁö
-	// END_OF_DEFEND_BONUS_ATTRIBUTES
-
-	// PC_BANG_ITEM_ADD 
-	POINT_PC_BANG_EXP_BONUS,				// 125 PC¹æ Àü¿ë °æÇèÄ¡ º¸³Ê½º
-	POINT_PC_BANG_DROP_BONUS,				// 126 PC¹æ Àü¿ë µå·Ó·ü º¸³Ê½º
-	// END_PC_BANG_ITEM_ADD
-	POINT_RAMADAN_CANDY_BONUS_EXP,			// 127 ¶ó¸¶´Ü »çÅÁ °æÇèÄ¡ Áõ°¡¿ë
-
-	POINT_ENERGY = 128,						// 128 ±â·Â
-
-	// ±â·Â ui ¿ë.
-	// ¼­¹ö¿¡¼­ ¾²Áö ¾Ê±â¸¸, Å¬¶óÀÌ¾ðÆ®¿¡¼­ ±â·ÂÀÇ ³¡ ½Ã°£À» POINT·Î °ü¸®ÇÏ±â ¶§¹®¿¡ ÀÌ·¸°Ô ÇÑ´Ù.
-	// ¾Æ ºÎ²ô·´´Ù
-	POINT_ENERGY_END_TIME = 129,			// 129 ±â·Â Á¾·á ½Ã°£
-
-	POINT_COSTUME_ATTR_BONUS = 130,			// 130
-	POINT_MAGIC_ATT_BONUS_PER = 131,		// 131
-	POINT_MELEE_MAGIC_ATT_BONUS_PER = 132,	// 132
-
-	// Ãß°¡ ¼Ó¼º ÀúÇ×
-	POINT_RESIST_ICE = 133,					// 133 ³Ã±â ÀúÇ× : ¾óÀ½°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_EARTH = 134,				// 134 ´ëÁö ÀúÇ× : ¾óÀ½°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_DARK = 135,				// 135 ¾îµÒ ÀúÇ× : ¾óÀ½°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-
-	POINT_RESIST_CRITICAL = 136,			// 136 Å©¸®Æ¼ÄÃ ÀúÇ× : »ó´ëÀÇ Å©¸®Æ¼ÄÃ È®·üÀ» °¨¼Ò
-	POINT_RESIST_PENETRATE = 137,			// 137 °üÅëÅ¸°Ý ÀúÇ× : »ó´ëÀÇ °üÅëÅ¸°Ý È®·üÀ» °¨¼Ò
-
-	POINT_BLEEDING_REDUCE = 138,			// 138
-	POINT_BLEEDING_PCT = 139,				// 139
-	POINT_ATTBONUS_WOLFMAN = 140,			// 140
-	POINT_RESIST_WOLFMAN = 141,				// 141
-	POINT_RESIST_CLAW = 142,				// 142
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	POINT_ACCEDRAIN_RATE,
-#endif
-#if defined(__MAGIC_REDUCTION__)
-	POINT_RESIST_MAGIC_REDUCTION,
-#endif
-#if defined(__CHEQUE_SYSTEM__)
-	POINT_CHEQUE,
-#endif
-	POINT_BATTLE_POINT,
-	POINT_RESIST_HUMAN,
-	POINT_ENCHANT_ELECT,
-	POINT_ENCHANT_FIRE,
-	POINT_ENCHANT_ICE,
-	POINT_ENCHANT_WIND,
-	POINT_ENCHANT_EARTH,
-	POINT_ENCHANT_DARK,
-	POINT_ATTBONUS_CZ,
-	POINT_BEAD,
-#if defined(__GEM_SYSTEM__)
-	POINT_GEM,
-#endif
-	POINT_ATTBONUS_SWORD,
-	POINT_ATTBONUS_TWOHAND,
-	POINT_ATTBONUS_DAGGER,
-	POINT_ATTBONUS_BELL,
-	POINT_ATTBONUS_FAN,
-	POINT_ATTBONUS_BOW,
-	POINT_ATTBONUS_CLAW,
-	POINT_RESIST_MOUNT_FALL,
-	POINT_RESIST_FIST,
-	POINT_PREMIUM_EXPBONUS,
-	POINT_PRIVILEGE_EXPBONUS,
-	POINT_MARRIAGE_EXPBONUS,
-	POINT_DEVILTOWER_EXPBONUS,
-	POINT_PREMIUM_ITEMBONUS,
-	POINT_PRIVILEGE_ITEMBONUS,
-	POINT_PREMIUM_GOLDBONUS,
-	POINT_PRIVILEGE_GOLDBONUS,
-	POINT_SKILL_DAMAGE_SAMYEON,
-	POINT_SKILL_DAMAGE_TANHWAN,
-	POINT_SKILL_DAMAGE_PALBANG,
-	POINT_SKILL_DAMAGE_GIGONGCHAM,
-	POINT_SKILL_DAMAGE_GYOKSAN,
-	POINT_SKILL_DAMAGE_GEOMPUNG,
-	POINT_SKILL_DAMAGE_AMSEOP,
-	POINT_SKILL_DAMAGE_GUNGSIN,
-	POINT_SKILL_DAMAGE_CHARYUN,
-	POINT_SKILL_DAMAGE_SANGONG,
-	POINT_SKILL_DAMAGE_YEONSA,
-	POINT_SKILL_DAMAGE_KWANKYEOK,
-	POINT_SKILL_DAMAGE_GIGUNG,
-	POINT_SKILL_DAMAGE_HWAJO,
-	POINT_SKILL_DAMAGE_SWAERYUNG,
-	POINT_SKILL_DAMAGE_YONGKWON,
-	POINT_SKILL_DAMAGE_PABEOB,
-	POINT_SKILL_DAMAGE_MARYUNG,
-	POINT_SKILL_DAMAGE_HWAYEOMPOK,
-	POINT_SKILL_DAMAGE_MAHWAN,
-	POINT_SKILL_DAMAGE_BIPABU,
-	POINT_SKILL_DAMAGE_YONGBI,
-	POINT_SKILL_DAMAGE_PAERYONG,
-	POINT_SKILL_DAMAGE_NOEJEON,
-	POINT_SKILL_DAMAGE_BYEURAK,
-	POINT_SKILL_DAMAGE_CHAIN,
-	POINT_SKILL_DAMAGE_CHAYEOL,
-	POINT_SKILL_DAMAGE_SALPOONG,
-	POINT_SKILL_DAMAGE_GONGDAB,
-	POINT_SKILL_DAMAGE_PASWAE,
-	POINT_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE,
-	POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE,
-	POINT_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE,
-	POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE,
-	POINT_HIT_BUFF_ENCHANT_FIRE,
-	POINT_HIT_BUFF_ENCHANT_ICE,
-	POINT_HIT_BUFF_ENCHANT_ELEC,
-	POINT_HIT_BUFF_ENCHANT_WIND,
-	POINT_HIT_BUFF_ENCHANT_DARK,
-	POINT_HIT_BUFF_ENCHANT_EARTH,
-	POINT_HIT_BUFF_RESIST_FIRE,
-	POINT_HIT_BUFF_RESIST_ICE,
-	POINT_HIT_BUFF_RESIST_ELEC,
-	POINT_HIT_BUFF_RESIST_WIND,
-	POINT_HIT_BUFF_RESIST_DARK,
-	POINT_HIT_BUFF_RESIST_EARTH,
-	POINT_USE_SKILL_CHEONGRANG_MOV_SPEED,
-	POINT_USE_SKILL_CHEONGRANG_CASTING_SPEED,
-	POINT_USE_SKILL_CHAYEOL_CRITICAL_PCT,
-	POINT_USE_SKILL_SANGONG_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_GIGUNG_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_JEOKRANG_DEF_BONUS,
-	POINT_USE_SKILL_GWIGEOM_DEF_BONUS,
-	POINT_USE_SKILL_TERROR_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_MUYEONG_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_MANASHILED_CASTING_SPEED,
-	POINT_USE_SKILL_HOSIN_DEF_BONUS,
-	POINT_USE_SKILL_GICHEON_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_JEUNGRYEOK_DEF_BONUS,
-	POINT_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_CHUNKEON_CASTING_SPEED,
-	POINT_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS,
-	POINT_SKILL_DURATION_INCREASE_EUNHYUNG,
-	POINT_SKILL_DURATION_INCREASE_GYEONGGONG,
-	POINT_SKILL_DURATION_INCREASE_GEOMKYUNG,
-	POINT_SKILL_DURATION_INCREASE_JEOKRANG,
-	POINT_USE_SKILL_PALBANG_HP_ABSORB,
-	POINT_USE_SKILL_AMSEOP_HP_ABSORB,
-	POINT_USE_SKILL_YEONSA_HP_ABSORB,
-	POINT_USE_SKILL_YONGBI_HP_ABSORB,
-	POINT_USE_SKILL_CHAIN_HP_ABSORB,
-	POINT_USE_SKILL_PASWAE_SP_ABSORB,
-	POINT_USE_SKILL_GIGONGCHAM_STUN,
-	POINT_USE_SKILL_CHARYUN_STUN,
-	POINT_USE_SKILL_PABEOB_STUN,
-	POINT_USE_SKILL_MAHWAN_STUN,
-	POINT_USE_SKILL_GONGDAB_STUN,
-	POINT_USE_SKILL_SAMYEON_STUN,
-	POINT_USE_SKILL_GYOKSAN_KNOCKBACK,
-	POINT_USE_SKILL_SEOMJEON_KNOCKBACK,
-	POINT_USE_SKILL_SWAERYUNG_KNOCKBACK,
-	POINT_USE_SKILL_HWAYEOMPOK_KNOCKBACK,
-	POINT_USE_SKILL_GONGDAB_KNOCKBACK,
-	POINT_USE_SKILL_KWANKYEOK_KNOCKBACK,
-	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_ATTBONUS_STONE,
-	POINT_DAMAGE_HP_RECOVERY,
-	POINT_DAMAGE_SP_RECOVERY,
-	POINT_ALIGNMENT_DAMAGE_BONUS,
-	POINT_NORMAL_DAMAGE_GUARD,
-	POINT_MORE_THEN_HP90_DAMAGE_REDUCE,
-	POINT_USE_SKILL_TUSOK_HP_ABSORB,
-	POINT_USE_SKILL_PAERYONG_HP_ABSORB,
-	POINT_USE_SKILL_BYEURAK_HP_ABSORB,
-	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_CHAYEOL_HP_ABSORB,
-	POINT_MEDAL_OF_HONOR,
-	POINT_ALL_STAT_BONUS,
-	POINT_SUNGMA_STR,
-	POINT_SUNGMA_HP,
-	POINT_SUNGMA_MOVE,
-	POINT_SUNGMA_IMMUNE,
-	POINT_CONQUEROR_LEVEL,
-	POINT_CONQUEROR_LEVEL_STEP,
-	POINT_CONQUEROR_EXP,
-	POINT_CONQUEROR_NEXT_EXP,
-	POINT_CONQUEROR_POINT,
-	POINT_HIT_PCT,
-	POINT_ATTBONUS_PER_HUMAN,
-	POINT_ATTBONUS_PER_ANIMAL,
-	POINT_ATTBONUS_PER_ORC,
-	POINT_ATTBONUS_PER_MILGYO,
-	POINT_ATTBONUS_PER_UNDEAD,
-	POINT_ATTBONUS_PER_DEVIL,
-	POINT_ENCHANT_PER_ELECT,
-	POINT_ENCHANT_PER_FIRE,
-	POINT_ENCHANT_PER_ICE,
-	POINT_ENCHANT_PER_WIND,
-	POINT_ENCHANT_PER_EARTH,
-	POINT_ENCHANT_PER_DARK,
-	POINT_ATTBONUS_PER_CZ,
-	POINT_ATTBONUS_PER_INSECT,
-	POINT_ATTBONUS_PER_DESERT,
-	POINT_ATTBONUS_PER_STONE,
-	POINT_ATTBONUS_PER_MONSTER,
-	POINT_RESIST_PER_HUMAN,
-	POINT_RESIST_PER_ICE,
-	POINT_RESIST_PER_DARK,
-	POINT_RESIST_PER_EARTH,
-	POINT_RESIST_PER_FIRE,
-	POINT_RESIST_PER_ELEC,
-	POINT_RESIST_PER_MAGIC,
-	POINT_RESIST_PER_WIND,
-	POINT_HIT_BUFF_SUNGMA_STR,
-	POINT_HIT_BUFF_SUNGMA_MOVE,
-	POINT_HIT_BUFF_SUNGMA_HP,
-	POINT_HIT_BUFF_SUNGMA_IMMUNE,
-	POINT_MOUNT_MELEE_MAGIC_ATTBONUS_PER,
-	POINT_DISMOUNT_MOVE_SPEED_BONUS_PER,
-	POINT_HIT_AUTO_HP_RECOVERY,
-	POINT_HIT_AUTO_SP_RECOVERY,
-	POINT_USE_SKILL_COOLTIME_DECREASE_ALL,
-	POINT_HIT_STONE_ATTBONUS_STONE,
-	POINT_HIT_STONE_DEF_GRADE_BONUS,
-	POINT_KILL_BOSS_ITEM_BONUS,
-	POINT_MOB_HIT_MOB_AGGRESSIVE,
-	POINT_NO_DEATH_AND_HP_RECOVERY30,
-	POINT_AUTO_PICKUP,
-	POINT_MOUNT_NO_KNOCKBACK,
-	POINT_SUNGMA_PER_STR,
-	POINT_SUNGMA_PER_HP,
-	POINT_SUNGMA_PER_MOVE,
-	POINT_SUNGMA_PER_IMMUNE,
-	POINT_IMMUNE_POISON100,
-	POINT_IMMUNE_BLEEDING100,
-	POINT_MONSTER_DEFEND_BONUS,
-
-	// Å¬¶óÀÌ¾ðÆ® Æ÷ÀÎÆ®
-	POINT_MIN_WEP,
-	POINT_MAX_WEP,
-	POINT_MIN_MAGIC_WEP,
-	POINT_MAX_MAGIC_WEP,
-	POINT_HIT_RATE,
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	POINT_BATTLE_PASS_PREMIUM_ID
-#endif
-};
-
-// <Factor> Dynamically evaluated CHARACTER* equivalent.
-// Referring to SCharDeadEventInfo.
-struct DynamicCharacterPtr
-{
-	DynamicCharacterPtr() : is_pc(false), id(0) {}
-	DynamicCharacterPtr(const DynamicCharacterPtr& o)
-		: is_pc(o.is_pc), id(o.id) {}
-
-	// Returns the LPCHARACTER found in CHARACTER_MANAGER.
-	LPCHARACTER Get() const;
-	// Clears the current settings.
-	void Reset()
-	{
-		is_pc = false;
-		id = 0;
-	}
-
-	// Basic assignment operator.
-	DynamicCharacterPtr& operator=(const DynamicCharacterPtr& rhs)
-	{
-		is_pc = rhs.is_pc;
-		id = rhs.id;
-		return *this;
-	}
-	// Supports assignment with LPCHARACTER type.
-	DynamicCharacterPtr& operator=(LPCHARACTER character);
-	// Supports type casting to LPCHARACTER.
-	operator LPCHARACTER() const
-	{
-		return Get();
-	}
-
-	bool is_pc;
-	uint32_t id;
-};
-
-/* ÀúÀåÇÏ´Â µ¥ÀÌÅÍ */
-typedef struct character_point
-{
-	POINT_VALUE lPoints[POINT_MAX_NUM];
-
-	BYTE bJob;
-	BYTE bVoice;
-
-	BYTE bLevel;
-	DWORD dwExp;
-
-#if defined(__CONQUEROR_LEVEL__)
-	BYTE bConquerorLevel;
-	DWORD dwConquerorExp;
-#endif
-
-	int iGold;
-#if defined(__CHEQUE_SYSTEM__)
-	int iCheque;
-#endif
-#if defined(__GEM_SYSTEM__)
-	int iGem;
-#endif
-
-	int iHP, iSP;
-	int iRandomHP, iRandomSP;
-	int iStamina;
-
-	BYTE bSkillGroup;
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	int battle_pass_premium_id;
-#endif
-} CHARACTER_POINT;
-
-/* ÀúÀåµÇÁö ¾Ê´Â Ä³¸¯ÅÍ µ¥ÀÌÅÍ */
-typedef struct character_point_instant
-{
-	POINT_VALUE points[POINT_MAX_NUM];
-
-	float fRot;
-
-	int iMaxHP;
-	int iMaxSP;
-
-	long position;
-
-	long instant_flag;
-	DWORD dwAIFlag;
-	DWORD dwImmuneFlag;
-	DWORD dwLastShoutPulse;
-
-	DWORD adwParts[PART_MAX_NUM];
-
-	LPITEM pInventoryItems[INVENTORY_MAX_NUM];
-	WORD wInventoryItemGrid[INVENTORY_MAX_NUM];
-
-	LPITEM pEquipmentItems[EQUIPMENT_MAX_NUM];
-	BYTE bEquipmentItemGrid[EQUIPMENT_MAX_NUM];
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	// ¿ëÈ¥¼® ÀÎº¥Åä¸®.
-	LPITEM pDragonSoulInventoryItems[DRAGON_SOUL_INVENTORY_MAX_NUM];
-	WORD wDragonSoulInventoryItemGrid[DRAGON_SOUL_INVENTORY_MAX_NUM];
-#endif
-
-	LPITEM pBeltInventoryItems[BELT_INVENTORY_MAX_NUM];
-	BYTE bBeltInventoryItemGrid[BELT_INVENTORY_MAX_NUM];
-
-#if !defined(__CUBE_RENEWAL__)
-	// by mhh
-	LPITEM pCubeItems[CUBE_MAX_NUM];
-#endif
-	LPCHARACTER pCubeNpc;
-#if defined(__MOVE_COSTUME_ATTR__)
-	LPCHARACTER pItemCombNpc;
-#endif
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	LPCHARACTER pRouletteNPC;
-#endif
-#if defined(__ATTR_6TH_7TH__)
-	LPITEM pNPCStorageItems;
-#endif
-
-	BYTE gm_level;
-
-	BYTE bBasePart; // Æò»óº¹ ¹øÈ£
-
-	int iMaxStamina;
-
-	BYTE bBlockMode;
-#ifdef __OFFLINE_SHOP__
-	BYTE bUnlockedShopSkin;
-	BYTE bUnlockedShopBanner;
-#endif
-	int iDragonSoulActiveDeck;
-	LPENTITY m_pDragonSoulRefineWindowOpener;
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	LPENTITY m_pAcceRefineWindowOpener;
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	LPENTITY m_pAuraRefineWindowOpener;
-#endif
-} CHARACTER_POINT_INSTANT;
-
-#define TRIGGERPARAM LPCHARACTER ch, LPCHARACTER causer
-
-typedef struct trigger
-{
-	BYTE type;
-	int (*func) (TRIGGERPARAM);
-	long value;
-} TRIGGER;
-
-class CTrigger
-{
-public:
-	CTrigger() : bType(0), pFunc(NULL)
-	{
-	}
-
-	BYTE bType;
-	int (*pFunc) (TRIGGERPARAM);
-};
-
-EVENTINFO(char_event_info)
-{
-	DynamicCharacterPtr ch;
-};
-
-struct TSkillUseInfo
-{
-	int iHitCount;
-	int iMaxHitCount;
-	int iSplashCount;
-	DWORD dwNextSkillUsableTime;
-	int iRange;
-	bool bUsed;
-	DWORD dwVID;
-	bool isGrandMaster;
-
-	std::unordered_map<DWORD, std::size_t> TargetVIDMap;
-
-	TSkillUseInfo()
-		: iHitCount(0), iMaxHitCount(0), iSplashCount(0), dwNextSkillUsableTime(0), iRange(0), bUsed(false),
-		dwVID(0), isGrandMaster(false)
-	{}
-
-	bool HitOnce(DWORD dwVnum = 0);
-
-	bool UseSkill(bool isGrandMaster, DWORD vid, DWORD dwCooltime, int splashcount = 1, int hitcount = -1, int range = -1);
-	DWORD GetMainTargetVID() const { return dwVID; }
-	void SetMainTargetVID(DWORD vid) { dwVID = vid; }
-	void ResetHitCount() { if (iSplashCount) { iHitCount = iMaxHitCount; iSplashCount--; } }
-};
-
-typedef struct packet_party_update TPacketGCPartyUpdate;
-class CExchange;
-class CSkillProto;
-class CParty;
-class CDungeon;
-#if defined(__DEFENSE_WAVE__)
-class CDefenseWave;
-#endif
-class CWarMap;
-class CAffect;
-class CGuild;
-class CSafebox;
-class CArena;
-
-class CShop;
-typedef class CShop* LPSHOP;
-
-class CMob;
-class CMobInstance;
-typedef struct SMobSkillInfo TMobSkillInfo;
-
-// SKILL_POWER_BY_LEVEL
-extern int GetSkillPowerByLevelFromType(int job, int skillgroup, int skilllevel);
-// END_SKILL_POWER_BY_LEVEL
-
-namespace marriage
-{
-	class WeddingMap;
-}
-enum e_overtime
-{
-	OT_NONE,
-	OT_3HOUR,
-	OT_5HOUR,
-};
-
-typedef std::list<CAffect*> AffectContainerList;
-typedef std::unordered_map<DWORD, BYTE> AffectStackMap;
-typedef std::map<int, LPEVENT> MobSkillEventMap;
-
-class CHARACTER : public CEntity, public CFSM, public CHorseRider
-{
-protected:
-	//////////////////////////////////////////////////////////////////////////////////
-	// Entity °ü·Ã
-	virtual void EncodeInsertPacket(LPENTITY entity);
-	virtual void EncodeRemovePacket(LPENTITY entity);
-	//////////////////////////////////////////////////////////////////////////////////
-
-public:
-	LPCHARACTER FindCharacterInView(const char* name, bool bFindPCOnly);
-	void UpdatePacket();
-
-	//////////////////////////////////////////////////////////////////////////////////
-	// FSM (Finite State Machine) °ü·Ã
-protected:
-	CStateTemplate<CHARACTER> m_stateMove;
-	CStateTemplate<CHARACTER> m_stateBattle;
-	CStateTemplate<CHARACTER> m_stateIdle;
-
-public:
-	virtual void StateMove();
-	virtual void StateBattle();
-	virtual void StateIdle();
-	virtual void StateFlag();
-	virtual void StateFlagBase();
-	void StateHorse();
-
-protected:
-	// STATE_IDLE_REFACTORING
-	void __StateIdle_Monster();
-	void __StateIdle_Stone();
-	void __StateIdle_NPC();
-	// END_OF_STATE_IDLE_REFACTORING
-
-public:
-	DWORD GetAIFlag() const { return m_pointsInstant.dwAIFlag; }
-
-	void SetAggressive(bool bSet = true);
-	bool IsAggressive() const;
-
-	void SetCoward();
-	bool IsCoward() const;
-	void CowardEscape();
-
-	void SetNoAttackShinsu();
-	bool IsNoAttackShinsu() const;
-
-	void SetNoAttackChunjo();
-	bool IsNoAttackChunjo() const;
-
-	void SetNoAttackJinno();
-	bool IsNoAttackJinno() const;
-
-	void SetAttackMob();
-	bool IsAttackMob() const;
-
-	void SetNoMove();
-	bool IsNoMove() const;
-
-	virtual void BeginStateEmpty();
-	virtual void EndStateEmpty() {}
-
-	void Restart(BYTE bSubCMD);
-	void RestartAtSamePos();
-
-protected:
-	DWORD m_dwStateDuration;
-	//////////////////////////////////////////////////////////////////////////////////
-
-public:
-	CHARACTER();
-	virtual ~CHARACTER();
-
-	void Create(const char* c_pszName, DWORD vid, bool isPC);
-	void Destroy();
-
-	void Disconnect(const char* c_pszReason);
-
-protected:
-	void Initialize();
-
-	//////////////////////////////////////////////////////////////////////////////////
-	// Basic Points
-
-public:
-	DWORD GetPlayerID() const { return m_dwPlayerID; }
-
-	void SetPlayerProto(const TPlayerTable* table);
-	void CreatePlayerProto(TPlayerTable& tab); // ÀúÀå ½Ã »ç¿ë
-
-	void SetProto(const CMob* c_pkMob);
-	WORD GetRaceNum() const;
-
-	void Save(); // DelayedSave
-	void SaveReal(); // ½ÇÁ¦ ÀúÀå
-	void FlushDelayedSaveItem();
-
-	const char* GetName() const;
-	const VID& GetVID() const { return m_vid; }
-
-	void SetName(const std::string& name) { m_stName = name; }
-
-	void SetRace(BYTE race);
-	bool ChangeSex();
-
-	bool IsFemale() const;
-	bool IsMale() const;
-
-	DWORD GetAID() const;
-	int GetChangeEmpireCount() const;
-	void SetChangeEmpireCount();
-	int ChangeEmpire(BYTE empire);
-
-	BYTE GetJob() const;
-	BYTE GetCharType() const;
-
-	bool IsPC() const { return GetDesc() ? true : false; }
-	bool IsNPC() const { return m_bCharType != CHAR_TYPE_PC; }
-	bool IsMonster() const { return m_bCharType == CHAR_TYPE_MONSTER; }
-	bool IsStone() const { return m_bCharType == CHAR_TYPE_STONE; }
-	bool IsDoor() const { return m_bCharType == CHAR_TYPE_DOOR; }
-	bool IsBuilding() const { return m_bCharType == CHAR_TYPE_BUILDING; }
-	bool IsWarp() const { return m_bCharType == CHAR_TYPE_WARP; }
-	bool IsGoto() const { return m_bCharType == CHAR_TYPE_GOTO; }
-	bool IsHorse() const { return m_bCharType == CHAR_TYPE_HORSE; }
-	bool IsPetPay() const { return m_bCharType == CHAR_TYPE_PET_PAY; }
-	//bool IsPet() const { return m_bCharType == CHAR_TYPE_PET; }
-
-	DWORD GetLastShoutPulse() const { return m_pointsInstant.dwLastShoutPulse; }
-	void SetLastShoutPulse(DWORD pulse) { m_pointsInstant.dwLastShoutPulse = pulse; }
-
-	BYTE GetGMLevel() const;
-	BOOL IsGM() const;
-	void SetGMLevel();
-
-	void SetLevel(BYTE bValue);
-	BYTE GetLevel() const { return m_points.bLevel; }
-
-	void SetExp(DWORD dwValue) { m_points.dwExp = dwValue; }
-	DWORD GetExp() const { return m_points.dwExp; }
-	DWORD GetNextExp() const;
-
-#if defined(__CONQUEROR_LEVEL__)
-	void SetConqueror(bool bSet = true);
-
-	void SetConquerorLevel(BYTE bValue) { m_points.bConquerorLevel = bValue; }
-	BYTE GetConquerorLevel() const { return m_points.bConquerorLevel; }
-
-	void SetConquerorExp(DWORD dwValue) { m_points.dwConquerorExp = dwValue; }
-	DWORD GetConquerorExp() const { return m_points.dwConquerorExp; }
-	DWORD GetNextConquerorExp() const;
-#endif
-
-	LPCHARACTER DistributeExp(); // Á¦ÀÏ ¸¹ÀÌ ¶§¸° »ç¶÷À» ¸®ÅÏÇÑ´Ù.
-
-	void DistributeHP(LPCHARACTER pkKiller);
-	void DistributeSP(LPCHARACTER pkKiller, int iMethod = 0);
-
-	void SetPosition(int pos);
-	bool IsPosition(int pos) const { return m_pointsInstant.position == pos ? true : false; }
-	int GetPosition() const { return m_pointsInstant.position; }
-
-	void SetPart(BYTE bPartPos, DWORD dwVal);
-	DWORD GetPart(BYTE bPartPos) const;
-	DWORD GetOriginalPart(BYTE bPartPos) const;
-
-	void SetHP(int val) { m_points.iHP = val; }
-	int GetHP() const { return m_points.iHP; }
-
-	void SetSP(int val) { m_points.iSP = val; }
-	int GetSP() const { return m_points.iSP; }
-
-	void SetMaxHP(int val) { m_pointsInstant.iMaxHP = val; }
-	int GetMaxHP() const { return m_pointsInstant.iMaxHP; }
-
-	void SetMaxSP(int val) { m_pointsInstant.iMaxSP = val; }
-	int GetMaxSP() const { return m_pointsInstant.iMaxSP; }
-
-	void SetStamina(int iValue) { m_points.iStamina = iValue; }
-	int GetStamina() const { return m_points.iStamina; }
-
-	void SetMaxStamina(int iValue) { m_pointsInstant.iMaxStamina = iValue; }
-	int GetMaxStamina() const { return m_pointsInstant.iMaxStamina; }
-
-	void SetRandomHP(int iValue) { m_points.iRandomHP = iValue; }
-	int GetRandomHP() const { return m_points.iRandomHP; }
-
-	void SetRandomSP(int iValue) { m_points.iRandomSP = iValue; }
-	int GetRandomSP() const { return m_points.iRandomSP; }
-
-	int GetHPPct() const;
-
-	void SetRealPoint(POINT_TYPE wPointType, POINT_VALUE lPointValue);
-	POINT_VALUE GetRealPoint(POINT_TYPE wPointType) const;
-
-	void SetPoint(POINT_TYPE wPointType, POINT_VALUE lPointValue);
-	POINT_VALUE GetPoint(POINT_TYPE wPointType) const;
-
-	POINT_VALUE GetLimitPoint(POINT_TYPE wPointType) const;
-	POINT_VALUE GetPolymorphPoint(POINT_TYPE wPointType) const;
-
-	const TMobTable& GetMobTable() const;
-	BYTE GetMobRank() const;
-	BYTE GetMobType() const;
-	BYTE GetMobBattleType() const;
-	BYTE GetMobSize() const;
-	DWORD GetMobDamageMin() const;
-	DWORD GetMobDamageMax() const;
-	WORD GetMobAttackRange() const;
-	DWORD GetMobDropItemVnum() const;
-	float GetMobDamageMultiply() const;
-#if defined(__ELEMENT_SYSTEM__)
-	int GetMobElement(BYTE bElement) const;
-#endif
-	float GetMonsterHitRange() const;
-
-	// NEWAI
-	bool IsBerserker() const;
-	bool IsBerserk() const;
-	void SetBerserk(bool mode);
-
-	bool IsStoneSkinner() const;
-
-	bool IsGodSpeeder() const;
-	bool IsGodSpeed() const;
-	void SetGodSpeed(bool mode);
-
-	bool IsDeathBlower() const;
-	bool IsDeathBlow() const;
-
-	bool IsHealer() const;
-	bool IsFaller() const;
-
-	bool IsReviver() const;
-	bool HasReviverInParty() const;
-	bool IsRevive() const;
-	void SetRevive(bool mode);
-	// NEWAI END
-
-	bool IsRaceFlag(DWORD dwBit) const;
-	bool IsSummonMonster() const;
-	DWORD GetSummonVnum() const;
-
-	int m_newSummonInterval;
-	int m_lastSummonTime;
-
-	bool CanSummonMonster() const;
-	void MarkSummonedMonster();
-
-	DWORD GetPolymorphItemVnum() const;
-	DWORD GetMonsterDrainSPPoint() const;
-
-	void MainCharacterPacket(); // ³»°¡ ¸ÞÀÎÄ³¸¯ÅÍ¶ó°í º¸³»ÁØ´Ù.
-
-	void ComputePoints();
-	void ComputeBattlePoints();
-
-	void PointChange(POINT_TYPE wPointType, POINT_VALUE lPointAmount, bool bAmount = false, bool bBroadcast = false);
-	void PointsPacket();
-	void UpdatePointsPacket(POINT_TYPE wPointType, POINT_VALUE lPointValue, POINT_VALUE lPointAmount = 0, bool bAmount = false, bool bBroadcast = false);
-
-	void ApplyPoint(POINT_TYPE wApplyType, POINT_VALUE lApplyValue);
-	void CheckMaximumPoints(); // HP, SP µîÀÇ ÇöÀç °ªÀÌ ÃÖ´ë°ª º¸´Ù ³ôÀºÁö °Ë»çÇÏ°í ³ô´Ù¸é ³·Ãá´Ù.
-
-
-	bool Show(long lMapIndex, long x, long y, long z = LONG_MAX, bool bShowSpawnMotion = false
-#if defined(__WJ_SHOW_MOB_INFO__)
-		, bool bAggressive = false
-#endif
-	);
-
-	void Sitdown(int is_ground);
-	void Standup();
-
-	void SetRotation(float fRot);
-	void SetRotationToXY(long x, long y);
-	float GetRotation() const { return m_pointsInstant.fRot; }
-
-	void MotionPacketEncode(BYTE motion, LPCHARACTER victim, struct packet_motion* packet);
-	void Motion(BYTE motion, LPCHARACTER victim = NULL);
-
-	void ChatPacket(BYTE type, const char* format, ...);
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	void ChatPacket(packet_chat pack_chat, const char* format, ...);
-#endif
-	void MonsterChat(BYTE bMonsterChatType);
-	void SendGreetMessage();
-
-	void ResetPoint(int iLv);
-	void ResetExp();
-
-#if defined(__CONQUEROR_LEVEL__)
-	void ResetConquerorPoint(int iLv);
-	void ResetConquerorExp();
-#endif
-
-	void SetBlockMode(BYTE bFlag);
-	void SetBlockModeForce(BYTE bFlag);
-	bool IsBlockMode(BYTE bFlag) const { return (m_pointsInstant.bBlockMode & bFlag) ? true : false; }
-#ifdef __OFFLINE_SHOP__
-	void SendUnlockedShopDeco();
-	void SetUnlockShopSkin(BYTE bFlag);
-	void SetUnlockShopBanner(BYTE bFlag);
-	bool IsUnlockedShopSkin(BYTE bFlag) const { return (m_pointsInstant.bUnlockedShopSkin & bFlag) ? true : false; }
-	bool IsUnlockedShopBanner(BYTE bFlag) const { return (m_pointsInstant.bUnlockedShopBanner & bFlag) ? true : false; }
-#endif
-	bool IsPolymorphed() const { return m_dwPolymorphRace > 0; }
-	bool IsPolyMaintainStat() const { return m_bPolyMaintainStat; } // ÀÌÀü ½ºÅÝÀ» À¯ÁöÇÏ´Â Æú¸®¸ðÇÁ.
-	void SetPolymorph(DWORD dwRaceNum, bool bMaintainStat = false);
-	DWORD GetPolymorphVnum() const { return m_dwPolymorphRace; }
-	int GetPolymorphPower() const;
-
-	// FISING
-	void fishing();
-	void fishing_take();
-	bool IsFishing() const { return m_pkFishingEvent ? true : false; }
-	// END_OF_FISHING
-
-	// MINING
-	void mining(LPCHARACTER chLoad);
-	void mining_cancel();
-	void mining_take();
-	bool IsMining() const { return m_pkMiningEvent ? true : false; }
-	// END_OF_MINING
-
-	void ResetPlayTime(DWORD dwTimeRemain = 0);
-
-	void CreateFly(BYTE bType, LPCHARACTER pkVictim);
-
-	void ResetChatCounter() { m_bChatCounter = 0; }
-	void IncreaseChatCounter() { ++m_bChatCounter; }
-	BYTE GetChatCounter() const { return m_bChatCounter; }
-
-	void ResetWhisperCounter() { m_bWhisperCounter = 0; }
-	bool IncreaseWhisperCounter() { ++m_bWhisperCounter; return m_bWhisperCounter; }
-	BYTE GetWhisperCounter() const { return m_bWhisperCounter; }
-
-protected:
-	DWORD m_dwPolymorphRace;
-	bool m_bPolyMaintainStat;
-	DWORD m_dwLoginPlayTime;
-	DWORD m_dwPlayerID;
-	VID m_vid;
-	std::string m_stName;
-	BYTE m_bCharType;
-
-	CHARACTER_POINT m_points;
-	CHARACTER_POINT_INSTANT m_pointsInstant;
-
-	int m_iMoveCount;
-	DWORD m_dwPlayStartTime;
-	BYTE m_bAddChrState;
-	bool m_bSkipSave;
-	BYTE m_bChatCounter;
-	BYTE m_bWhisperCounter;
-
-	// End of Basic Points
-
-	//////////////////////////////////////////////////////////////////////////////////
-	// Move & Synchronize Positions
-	//////////////////////////////////////////////////////////////////////////////////
-public:
-	bool IsStateMove() const { return IsState((CState&)m_stateMove); }
-	bool IsStateIdle() const { return IsState((CState&)m_stateIdle); }
-	bool IsWalking() const { return m_bNowWalking || GetStamina() <= 0; }
-	void SetWalking(bool bWalkFlag) { m_bWalking = bWalkFlag; }
-	void SetNowWalking(bool bWalkFlag);
-	void ResetWalking() { SetNowWalking(m_bWalking); }
-
-	bool Goto(long x, long y); // ¹Ù·Î ÀÌµ¿ ½ÃÅ°Áö ¾Ê°í ¸ñÇ¥ À§Ä¡·Î BLENDING ½ÃÅ²´Ù.
-	void Stop();
-
-	bool CanMove() const; // ÀÌµ¿ÇÒ ¼ö ÀÖ´Â°¡?
-
-	void SyncPacket();
-	bool Sync(long x, long y); // ½ÇÁ¦ ÀÌ ¸Þ¼Òµå·Î ÀÌµ¿ ÇÑ´Ù (°¢ Á¾ Á¶°Ç¿¡ ÀÇÇÑ ÀÌµ¿ ºÒ°¡°¡ ¾øÀ½)
-	bool Move(long x, long y); // Á¶°ÇÀ» °Ë»çÇÏ°í Sync ¸Þ¼Òµå¸¦ ÅëÇØ ÀÌµ¿ ÇÑ´Ù.
-	void OnMove(bool bIsAttack = false); // ¿òÁ÷ÀÏ¶§ ºÒ¸°´Ù. Move() ¸Þ¼Òµå ÀÌ¿Ü¿¡¼­µµ ºÒ¸± ¼ö ÀÖ´Ù.
-	DWORD GetMotionMode() const;
-	float GetMoveMotionSpeed() const;
-	float GetMoveSpeed() const;
-	void CalculateMoveDuration();
-	void SendMovePacket(BYTE bFunc, BYTE bArg, DWORD x, DWORD y, DWORD dwDuration, DWORD dwTime = 0, int iRot = -1);
-
-	DWORD GetCurrentMoveDuration() const { return m_dwMoveDuration; }
-	DWORD GetWalkStartTime() const { return m_dwWalkStartTime; }
-	DWORD GetLastMoveTime() const { return m_dwLastMoveTime; }
-	DWORD GetLastAttackTime() const { return m_dwLastAttackTime; }
-
-	void SetLastAttacked(DWORD time); // ¸¶Áö¸·À¸·Î °ø°Ý¹ÞÀº ½Ã°£ ¹× À§Ä¡¸¦ ÀúÀåÇÔ
-
-	bool SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList = true);
-	bool IsSyncOwner(LPCHARACTER ch) const;
-
-	bool WarpSet(long x, long y, long lRealMapIndex = 0);
-	void SetWarpLocation(long lMapIndex, long x, long y);
-	void WarpEnd();
-	const PIXEL_POSITION& GetWarpPosition() const { return m_posWarp; }
-	bool WarpToPID(DWORD dwPID, bool bWarpForce = false);
-
-	void SaveExitLocation();
-	void ExitToSavedLocation();
-
-	void StartStaminaConsume();
-	void StopStaminaConsume();
-	bool IsStaminaConsume() const;
-	bool IsStaminaHalfConsume() const;
-
-	void ResetStopTime();
-	DWORD GetStopTime() const;
-
-#if defined(__MOVE_CHANNEL__)
-	bool MoveChannel(long lNewAddr, WORD wNewPort);
-	bool StartMoveChannel(long lNewAddr, WORD wNewPort);
-#endif
-
-protected:
-	void ClearSync();
-
-	float m_fSyncTime;
-	LPCHARACTER m_pkChrSyncOwner;
-	CHARACTER_LIST m_kLst_pkChrSyncOwned; // ³»°¡ SyncOwnerÀÎ ÀÚµé
-
-	PIXEL_POSITION m_posDest;
-	PIXEL_POSITION m_posStart;
-	PIXEL_POSITION m_posWarp;
-	long m_lWarpMapIndex;
-
-	PIXEL_POSITION m_posExit;
-	long m_lExitMapIndex;
-
-	DWORD m_dwMoveStartTime;
-	DWORD m_dwMoveDuration;
-
-	DWORD m_dwLastMoveTime;
-	DWORD m_dwLastAttackTime;
-	DWORD m_dwWalkStartTime;
-	DWORD m_dwStopTime;
-
-	bool m_bWalking;
-	bool m_bNowWalking;
-	bool m_bStaminaConsume;
-
-	// End
-
-	// Quickslot °ü·Ã
-public:
-	void SyncQuickslot(BYTE bType, WORD wOldPos, WORD wNewPos);
-	bool GetQuickslot(BYTE pos, TQuickslot** ppSlot);
-	bool SetQuickslot(BYTE pos, TQuickslot& rSlot);
-	bool DelQuickslot(BYTE pos);
-	bool SwapQuickslot(BYTE a, BYTE b);
-	void ChainQuickslotItem(LPITEM pItem, BYTE bType, WORD wOldPos);
-	void MoveQuickSlotItem(BYTE bOldType, WORD wOldPos, BYTE bNewType, WORD wNewPos);
-
-	void CheckQuickSlotItems();
-	bool CanAddToQuickSlot(LPITEM pItem);
-
-protected:
-	TQuickslot m_quickslot[QUICKSLOT_MAX_NUM];
-
-#if defined(__LUCKY_BOX__)
-public:
-	void SetLuckyBoxSrcItem(LPITEM lpItem);
-	void SendLuckyBoxInfo();
-	void LuckyBoxRetry();
-	void LuckyBoxReceive();
-	int GetLuckyBoxPrice() const;
-	bool IsLuckyBoxOpen() const;
-	void ResetLuckyBoxData();
-
-private:
-	struct
-	{
-		DWORD dwSrcItemVNum;
-		DWORD dwSrcItemID;
-		WORD wSrcSlotIndex;
-		BYTE bTryCount;
-		DWORD dwItemVNum;
-		BYTE bItemCount;
-	} m_sLuckyBox;
-#endif
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Affect
-public:
-	void StartAffectEvent();
-	void ClearAffect(bool bSave = false);
-	void ComputeAffect(const CAffect* pkAff, bool bAdd);
-	bool AddAffect(DWORD dwType, POINT_TYPE wApplyOn, POINT_VALUE lApplyValue, DWORD dwFlag, long lDuration, long lSPCost, bool bOverride, bool IsCube = false
-#if defined(__AFFECT_RENEWAL__)
-		, bool bRealTime = false
-#endif
-#if defined(__9TH_SKILL__)
-		, long lValue = 0 /* Skill iAmount2 */
-#endif
-	);
-#if defined(__AFFECT_RENEWAL__)
-	bool AddRealTimeAffect(DWORD dwType, POINT_TYPE wApplyOn, POINT_VALUE lApplyValue, DWORD dwFlag, long lDuration, long lSPCost, bool bOverride, bool IsCube = false, bool bRealTime = true);
-#endif
-	void RefreshAffect();
-	bool RemoveAffect(DWORD dwType);
-#if defined(__SOUL_SYSTEM__)
-	void RemoveAffect(DWORD dwType, POINT_TYPE wApplyType);
-#endif
-	bool IsAffectFlag(DWORD dwAff) const;
-
-	bool UpdateAffect(); // called from EVENT
-	int ProcessAffect();
-
-	void LoadAffect(DWORD dwCount, TPacketAffectElement* pElements);
-	void SaveAffect();
-
-public:
-	// Affect loadingÀÌ ³¡³­ »óÅÂÀÎ°¡?
-	bool IsLoadedAffect() const { return m_bIsLoadedAffect; }
-
-	bool IsGoodAffect(BYTE bAffectType) const;
-
-	void RemoveGoodAffect();
-	void RemoveBadAffect();
-
-	CAffect* FindAffect(DWORD dwType, POINT_TYPE wApplyType = APPLY_NONE) const;
-	const AffectContainerList& GetAffectContainer() const { return m_list_pkAffect; }
-	bool RemoveAffect(CAffect* pkAff);
-
-	//void SetAffectStack(CAffect* pkAff, BYTE value);
-	//BYTE GetAffectStack(CAffect* pkAff);
-	//void ClearAffectStack(CAffect* pkAff);
-	//
-	//AffectStackMap m_map_affectStack;
-
-protected:
-	bool m_bIsLoadedAffect;
-	TAffectFlag m_afAffectFlag;
-	AffectContainerList m_list_pkAffect;
-
-public:
-	// PARTY_JOIN_BUG_FIX
-	void SetParty(LPPARTY pkParty);
-	LPPARTY GetParty() const { return m_pkParty; }
-
-	bool RequestToParty(LPCHARACTER leader);
-	void DenyToParty(LPCHARACTER member);
-	void AcceptToParty(LPCHARACTER member);
-
-	/// ÀÚ½ÅÀÇ ÆÄÆ¼¿¡ ´Ù¸¥ character ¸¦ ÃÊ´ëÇÑ´Ù.
-	/**
-	* @param pchInvitee ÃÊ´ëÇÒ ´ë»ó character. ÆÄÆ¼¿¡ Âü¿© °¡´ÉÇÑ »óÅÂÀÌ¾î¾ß ÇÑ´Ù.
-	*
-	* ¾çÃø character ÀÇ »óÅÂ°¡ ÆÄÆ¼¿¡ ÃÊ´ëÇÏ°í ÃÊ´ë¹ÞÀ» ¼ö ÀÖ´Â »óÅÂ°¡ ¾Æ´Ï¶ó¸é ÃÊ´ëÇÏ´Â Ä³¸¯ÅÍ¿¡°Ô ÇØ´çÇÏ´Â Ã¤ÆÃ ¸Þ¼¼Áö¸¦ Àü¼ÛÇÑ´Ù.
-	**/
-	void PartyInvite(LPCHARACTER pchInvitee);
-
-	/// ÃÊ´ëÇß´ø character ÀÇ ¼ö¶ôÀ» Ã³¸®ÇÑ´Ù.
-	/**
-	* @param pchInvitee ÆÄÆ¼¿¡ Âü¿©ÇÒ character. ÆÄÆ¼¿¡ Âü¿©°¡´ÉÇÑ »óÅÂÀÌ¾î¾ß ÇÑ´Ù.
-	*
-	* pchInvitee °¡ ÆÄÆ¼¿¡ °¡ÀÔÇÒ ¼ö ÀÖ´Â »óÈ²ÀÌ ¾Æ´Ï¶ó¸é ÇØ´çÇÏ´Â Ã¤ÆÃ ¸Þ¼¼Áö¸¦ Àü¼ÛÇÑ´Ù.
-	**/
-	void PartyInviteAccept(LPCHARACTER pchInvitee);
-
-	/// ÃÊ´ëÇß´ø character ÀÇ ÃÊ´ë °ÅºÎ¸¦ Ã³¸®ÇÑ´Ù.
-	/**
-	* @param [in] dwPID ÃÊ´ë Çß´ø character ÀÇ PID
-	**/
-	void PartyInviteDeny(DWORD dwPID);
-
-	bool BuildUpdatePartyPacket(TPacketGCPartyUpdate& out);
-	int GetLeadershipSkillLevel() const;
-#if defined(__PARTY_PROFICY__)
-	int GetRoleProficiencySkillLevel() const;
-#endif
-#if defined(__PARTY_INSIGHT__)
-	int GetInSightSkillLevel() const;
-#endif
-
-	bool CanSummon(int iLeaderShip);
-
-	void SetPartyRequestEvent(LPEVENT pkEvent) { m_pkPartyRequestEvent = pkEvent; }
-
-protected:
-
-	/// ÆÄÆ¼¿¡ °¡ÀÔÇÑ´Ù.
-	/**
-	* @param pkLeader °¡ÀÔÇÒ ÆÄÆ¼ÀÇ ¸®´õ
-	**/
-	void PartyJoin(LPCHARACTER pkLeader);
-
-	/**
-	* ÆÄÆ¼ °¡ÀÔÀ» ÇÒ ¼ö ¾øÀ» °æ¿ìÀÇ ¿¡·¯ÄÚµå.
-	* Error code ´Â ½Ã°£¿¡ ÀÇÁ¸ÀûÀÎ°¡¿¡ µû¶ó º¯°æ°¡´ÉÇÑ(mutable) type °ú Á¤Àû(static) type À¸·Î ³ª´¶´Ù.
-	* Error code ÀÇ °ªÀÌ PERR_SEPARATOR º¸´Ù ³·À¸¸é º¯°æ°¡´ÉÇÑ type ÀÌ°í ³ôÀ¸¸é Á¤Àû type ÀÌ´Ù.
-	**/
-	enum PartyJoinErrCode
-	{
-		PERR_NONE = 0, ///< Ã³¸®¼º°ø
-		PERR_SERVER, ///< ¼­¹ö¹®Á¦·Î ÆÄÆ¼°ü·Ã Ã³¸® ºÒ°¡
-		PERR_DUNGEON, ///< Ä³¸¯ÅÍ°¡ ´øÀü¿¡ ÀÖÀ½
-		PERR_OBSERVER, ///< °üÀü¸ðµåÀÓ
-		PERR_LVBOUNDARY, ///< »ó´ë Ä³¸¯ÅÍ¿Í ·¹º§Â÷ÀÌ°¡ ³²
-		PERR_LOWLEVEL, ///< »ó´ëÆÄÆ¼ÀÇ ÃÖ°í·¹º§º¸´Ù 30·¹º§ ³·À½
-		PERR_HILEVEL, ///< »ó´ëÆÄÆ¼ÀÇ ÃÖÀú·¹º§º¸´Ù 30·¹º§ ³ôÀ½
-		PERR_ALREADYJOIN, ///< ÆÄÆ¼°¡ÀÔ ´ë»ó Ä³¸¯ÅÍ°¡ ÀÌ¹Ì ÆÄÆ¼Áß
-		PERR_PARTYISFULL, ///< ÆÄÆ¼ÀÎ¿ø Á¦ÇÑ ÃÊ°ú
-		PERR_SEPARATOR, ///< Error type separator.
-		PERR_DIFFEMPIRE, ///< »ó´ë Ä³¸¯ÅÍ¿Í ´Ù¸¥ Á¦±¹ÀÓ
-		PERR_MAX ///< Error code ÃÖ°íÄ¡. ÀÌ ¾Õ¿¡ Error code ¸¦ Ãß°¡ÇÑ´Ù.
-	};
-
-	/// ÆÄÆ¼ °¡ÀÔÀÌ³ª °á¼º °¡´ÉÇÑ Á¶°ÇÀ» °Ë»çÇÑ´Ù.
-	/**
-	* @param pchLeader ÆÄÆ¼ÀÇ leader ÀÌ°Å³ª ÃÊ´ëÇÑ character
-	* @param pchGuest ÃÊ´ë¹Þ´Â character
-	* @return ¸ðµç PartyJoinErrCode °¡ ¹ÝÈ¯µÉ ¼ö ÀÖ´Ù.
-	**/
-	static PartyJoinErrCode IsPartyJoinableCondition(const LPCHARACTER pchLeader, const LPCHARACTER pchGuest);
-
-	/// ÆÄÆ¼ °¡ÀÔÀÌ³ª °á¼º °¡´ÉÇÑ µ¿ÀûÀÎ Á¶°ÇÀ» °Ë»çÇÑ´Ù.
-	/**
-	* @param pchLeader ÆÄÆ¼ÀÇ leader ÀÌ°Å³ª ÃÊ´ëÇÑ character
-	* @param pchGuest ÃÊ´ë¹Þ´Â character
-	* @return mutable type ÀÇ code ¸¸ ¹ÝÈ¯ÇÑ´Ù.
-	**/
-	static PartyJoinErrCode IsPartyJoinableMutableCondition(const LPCHARACTER pchLeader, const LPCHARACTER pchGuest);
-
-	LPPARTY m_pkParty;
-	DWORD m_dwLastDeadTime;
-	LPEVENT m_pkPartyRequestEvent;
-
-	/**
-	* ÆÄÆ¼ÃÊÃ» Event map.
-	* key: ÃÊ´ë¹ÞÀº Ä³¸¯ÅÍÀÇ PID
-	* value: eventÀÇ pointer
-	*
-	* ÃÊ´ëÇÑ Ä³¸¯ÅÍµé¿¡ ´ëÇÑ event map.
-	**/
-	typedef std::map<DWORD, LPEVENT> EventMap;
-	EventMap m_PartyInviteEventMap;
-
-	// END_OF_PARTY_JOIN_BUG_FIX
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Dungeon
-public:
-	void SetDungeon(LPDUNGEON pkDungeon);
-	LPDUNGEON GetDungeon() const { return m_pkDungeon; }
-	LPDUNGEON GetDungeonForce() const;
-protected:
-	LPDUNGEON m_pkDungeon;
-	int m_iEventAttr;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Guild
-public:
-	void SetGuild(CGuild* pGuild);
-	CGuild* GetGuild() const { return m_pGuild; }
-
-	void SetWarMap(CWarMap* pWarMap);
-	CWarMap* GetWarMap() const { return m_pWarMap; }
-
-protected:
-	CGuild* m_pGuild;
-	DWORD m_dwUnderGuildWarInfoMessageTime;
-	CWarMap* m_pWarMap;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Item related
-public:
-	bool CanHandleItem(bool bSkipRefineCheck = false, bool bSkipObserver = false); // ¾ÆÀÌÅÛ °ü·Ã ÇàÀ§¸¦ ÇÒ ¼ö ÀÖ´Â°¡?
-
-	bool IsItemLoaded() const { return m_bItemLoaded; }
-	void SetItemLoaded() { m_bItemLoaded = true; }
-
-	void ClearItem();
-
-	LPITEM GetInventoryItem(WORD wCell) const;
-	LPITEM GetEquipmentItem(WORD wCell) const;
-	LPITEM GetDragonSoulInventoryItem(WORD wCell) const;
-	LPITEM GetBeltInventoryItem(WORD wCell) const;
-
-	void SetItem(TItemPos Cell, LPITEM item
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		, bool isHighLight = false
-#endif
-	);
-
-	LPITEM GetItem(TItemPos Cell) const;
-
-	bool IsEmptyItemGrid(TItemPos Cell, BYTE size, int iExceptionCell = -1) const;
-
-	void SetWear(WORD wCell, LPITEM item);
-	LPITEM GetWear(WORD wCell) const;
-
-	// MYSHOP_PRICE_LIST
-	void UseSilkBotary(void); /// ºñ´Ü º¸µû¸® ¾ÆÀÌÅÛÀÇ »ç¿ë
-
-	/// DB Ä³½Ã·Î ºÎÅÍ ¹Þ¾Æ¿Â °¡°ÝÁ¤º¸ ¸®½ºÆ®¸¦ À¯Àú¿¡°Ô Àü¼ÛÇÏ°í º¸µû¸® ¾ÆÀÌÅÛ »ç¿ëÀ» Ã³¸®ÇÑ´Ù.
-	/**
-	* @param [in] p °¡°ÝÁ¤º¸ ¸®½ºÆ® ÆÐÅ¶
-	*
-	* Á¢¼ÓÇÑ ÈÄ Ã³À½ ºñ´Ü º¸µû¸® ¾ÆÀÌÅÛ »ç¿ë ½Ã UseSilkBotary ¿¡¼­ DB Ä³½Ã·Î °¡°ÝÁ¤º¸ ¸®½ºÆ®¸¦ ¿äÃ»ÇÏ°í
-	* ÀÀ´ä¹ÞÀº ½ÃÁ¡¿¡ ÀÌ ÇÔ¼ö¿¡¼­ ½ÇÁ¦ ºñ´Üº¸µû¸® »ç¿ëÀ» Ã³¸®ÇÑ´Ù.
-	**/
-	void UseSilkBotaryReal(const TPacketMyshopPricelistHeader* p);
-	// END_OF_MYSHOP_PRICE_LIST
-
-	bool UseItemEx(LPITEM item, TItemPos DestCell);
-	bool UseItem(TItemPos Cell, TItemPos DestCell = NPOS);
-
-	// ADD_REFINE_BUILDING
-	bool IsRefineThroughGuild() const;
-	CGuild* GetRefineGuild() const;
-	int ComputeRefineFee(int iCost, int iMultiply = 5) const;
-	void PayRefineFee(int iTotalMoney);
-	void SetRefineNPC(LPCHARACTER ch);
-	// END_OF_ADD_REFINE_BUILDING
-
-	bool RefineItem(LPITEM pkItem, LPITEM pkTarget);
-	bool DropItem(TItemPos Cell, WORD wCount = 0);
-#if defined(__NEW_DROP_DIALOG__)
-	bool DestroyItem(TItemPos Cell);
-#endif
-	bool GiveRecallItem(LPITEM item);
-	void ProcessRecallItem(LPITEM item);
-
-	// void PotionPacket(int iPotionType);
-	void EffectPacket(BYTE bEffectNum, BYTE bEffectType = SE_TYPE_NORMAL, const PIXEL_POSITION& rEffectPos = { 0, 0, 0 });
-	void SpecificEffectPacket(const char filename[128]);
-
-	// ADD_MONSTER_REFINE
-	bool DoRefine(LPITEM item, bool bMoneyOnly = false);
-	// END_OF_ADD_MONSTER_REFINE
-
-	bool DoRefineWithScroll(LPITEM item);
-	bool RefineInformation(WORD wCell, BYTE bType, int iAdditionalCell = -1);
-
-	struct SRefineScrollData
-	{
-		BYTE bSuccessProb;
-		bool bKeepGrade;
-	};
-	SRefineScrollData GetScrollRefinePct(BYTE bProb, BYTE bRefineLevel, BYTE bScrollType);
-
-	void SetRefineMode(int iAdditionalCell = -1);
-	void ClearRefineMode();
-
-	bool GiveItem(LPCHARACTER victim, TItemPos Cell);
-	bool CanReceiveItem(LPCHARACTER from, LPITEM item) const;
-	void ReceiveItem(LPCHARACTER from, LPITEM item);
-	//bool GiveItemFromSpecialItemGroup(DWORD dwGroupNum, std::vector<DWORD>& dwItemVnums,
-	//	std::vector<DWORD>& dwItemCounts, std::vector<LPITEM>& item_gets, int& count);
-	bool GiveItemFromSpecialItemGroup(DWORD dwGroupNum);
-
-	bool MoveItem(TItemPos pos, TItemPos change_pos, WORD num);
-	bool PickupItem(DWORD vid
-#if defined(__PET_LOOT_AI__)
-		, bool PetLoot = false
-#endif
-	);
-	bool EquipItem(LPITEM item, int iCandidateCell = -1);
-	bool UnequipItem(LPITEM item);
-
-	// ÇöÀç itemÀ» Âø¿ëÇÒ ¼ö ÀÖ´Â Áö È®ÀÎÇÏ°í, ºÒ°¡´É ÇÏ´Ù¸é Ä³¸¯ÅÍ¿¡°Ô ÀÌÀ¯¸¦ ¾Ë·ÁÁÖ´Â ÇÔ¼ö
-	bool CanEquipNow(const LPITEM item, const TItemPos& srcCell = NPOS, const TItemPos& destCell = NPOS);
-	// Âø¿ëÁßÀÎ itemÀ» ¹þÀ» ¼ö ÀÖ´Â Áö È®ÀÎÇÏ°í, ºÒ°¡´É ÇÏ´Ù¸é Ä³¸¯ÅÍ¿¡°Ô ÀÌÀ¯¸¦ ¾Ë·ÁÁÖ´Â ÇÔ¼ö
-	bool CanUnequipNow(const LPITEM item, const TItemPos& srcCell = NPOS, const TItemPos& destCell = NPOS);
-
-	bool SwapItem(WORD wCell, WORD wDestCell);
-
-	LPITEM AutoGiveItem(DWORD dwItemVnum, WORD wCount = 1, int iRarePct = -1, bool bMsg = true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		, bool isHighLight = false
-#endif
-#if defined(__NEW_USER_CARE__)
-		, bool bSystemDrop = true
-#endif
-	);
-
-	void AutoGiveItem(LPITEM item, bool longOwnerShip = false, bool bMsg = true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		, bool isHighLight = false
-#endif
-	);
-
-	int GetEmptyInventory(BYTE size) const;
-	int GetEmptyInventoryCount(BYTE size) const;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	int GetEmptyDragonSoulInventory(LPITEM pItem) const;
-	void CopyDragonSoulItemGrid(std::vector<WORD>& vDragonSoulItemGrid) const;
-#endif
-
-	int CountEmptyInventory() const;
-	bool HasEnoughInventorySpace(std::vector<TItemData>& vItems) const;
-
-	int CountSpecifyItem(DWORD vnum, int iExceptionCell = -1
-#if defined(__SOUL_BIND_SYSTEM__)
-		, bool bIgnoreSealedItem = false
-#endif
-#if defined(__SET_ITEM__)
-		, bool bIgnoreSetValue = false
-#endif
-	) const;
-	void RemoveSpecifyItem(DWORD vnum, DWORD count = 1, int iExceptionCell = -1
-#if defined(__SOUL_BIND_SYSTEM__)
-		, bool bIgnoreSealedItem = false
-#endif
-#if defined(__SET_ITEM__)
-		, bool bIgnoreSetValue = false
-#endif
-	);
-	LPITEM FindSpecifyItem(DWORD dwVnum
-#if defined(__SOUL_BIND_SYSTEM__)
-		, bool bIgnoreSealedItem = false
-#endif
-#if defined(__SET_ITEM__)
-		, bool bIgnoreSetValue = false
-#endif
-	) const;
-	LPITEM FindItemByID(DWORD id) const;
-
-	int CountSpecifyTypeItem(BYTE type) const;
-	void RemoveSpecifyTypeItem(BYTE type, DWORD count = 1);
-
-	bool IsEquipUniqueItem(DWORD dwItemVnum) const;
-
-	// CHECK_UNIQUE_GROUP
-	bool IsEquipUniqueGroup(DWORD dwGroupVnum) const;
-	// END_OF_CHECK_UNIQUE_GROUP
-
-	void SendEquipment(LPCHARACTER pChar);
-	// End of Item
-
-protected:
-	/// ÇÑ ¾ÆÀÌÅÛ¿¡ ´ëÇÑ °¡°ÝÁ¤º¸¸¦ Àü¼ÛÇÑ´Ù.
-	/**
-	* @param [in] dwItemVnum ¾ÆÀÌÅÛ vnum
-	* @param [in] dwItemPrice ¾ÆÀÌÅÛ °¡°Ý
-	**/
-	void SendMyShopPriceListCmd(DWORD dwItemVnum, DWORD dwItemPrice
-#if defined(__CHEQUE_SYSTEM__)
-		, DWORD dwItemCheque
-#endif
-	);
-
-	bool m_bNoOpenedShop; ///< ÀÌ¹ø Á¢¼Ó ÈÄ °³ÀÎ»óÁ¡À» ¿¬ ÀûÀÌ ÀÖ´ÂÁöÀÇ ¿©ºÎ(¿­¾ú´ø ÀûÀÌ ¾ø´Ù¸é true)
-
-	bool m_bItemLoaded;
-	int m_iRefineAdditionalCell;
-
-public:
-	bool IsUnderRefine() const { return m_bUnderRefine; }
-	void SetUnderRefine(bool bState) { m_bUnderRefine = bState; }
-protected:
-	bool m_bUnderRefine;
-	DWORD m_dwRefineNPCVID;
-
-public:
-	int GetGold() const { return m_points.iGold; }
-	void SetGold(int iValue) { m_points.iGold = iValue; }
-
-	bool DropGold(int iAmount);
-	void GiveGold(int iAmount); // ÆÄÆ¼°¡ ÀÖÀ¸¸é ÆÄÆ¼ ºÐ¹è, ·Î±× µîÀÇ Ã³¸®
-
-	int GetAllowedGold() const;
-
-#if defined(__CHEQUE_SYSTEM__)
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Cheque related
-	int GetCheque() const { return m_points.iCheque; }
-	void SetCheque(int iValue) { m_points.iCheque = iValue; }
-	bool DropCheque(int iAmount);
-	void GiveCheque(int iAmount);
-	// End of Cheque
-#endif
-
-#if defined(__GEM_SYSTEM__)
-	////////////////////////////////////////////////////////////////////////////////////////
-	int GetGem() const { return m_points.iGem; }
-	void SetGem(int iValue) { m_points.iGem = iValue; }
-	void GiveGem(int iAmount);
-#endif
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Shop related
-public:
-	void SetShop(LPSHOP pkShop);
-	LPSHOP GetShop() const { return m_pkShop; }
-	void ShopPacket(BYTE bSubHeader);
-
-	void SetShopOwner(LPCHARACTER ch) { m_pkChrShopOwner = ch; }
-	LPCHARACTER GetShopOwner() const { return m_pkChrShopOwner; }
-
-#ifdef __OFFLINE_SHOP__
-	void SetShowOfflineShop(DWORD option) { dwIsShowShops = option; UpdateSectree();}
-	DWORD GetShowOfflineShop()  const { return dwIsShowShops;}
-#endif
-
-	void OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE bItemCount);
-	LPSHOP GetMyShop() const { return m_pkMyShop; }
-	void CloseMyShop();
-
-protected:
-	LPSHOP m_pkShop;
-	LPSHOP m_pkMyShop;
-	std::string m_stShopSign;
-	LPCHARACTER m_pkChrShopOwner;
-	// End of shop
-
-#ifdef __OFFLINE_SHOP__
-	DWORD dwIsShowShops;
-#endif
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Exchange related
-public:
-	bool ExchangeStart(LPCHARACTER victim);
-	void SetExchange(CExchange* pkExchange);
-	CExchange* GetExchange() const { return m_pkExchange; }
-
-protected:
-	CExchange* m_pkExchange;
-	// End of Exchange
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Battle
-public:
-	struct TBattleInfo
-	{
-		int iTotalDamage;
-		int iAggro;
-
-		TBattleInfo(int iTot, int iAggr)
-			: iTotalDamage(iTot), iAggro(iAggr)
-		{}
-	};
-	typedef std::map<VID, TBattleInfo> TDamageMap;
-
-	typedef struct SAttackLog
-	{
-		DWORD dwVID;
-		DWORD dwTime;
-	} AttackLog;
-
-	bool Damage(LPCHARACTER pAttacker, int dam, EDamageType type = DAMAGE_TYPE_NORMAL);
-	bool __Profile__Damage(LPCHARACTER pAttacker, int dam, EDamageType type = DAMAGE_TYPE_NORMAL);
-	void DeathPenalty(BYTE bExpLossPercent);
-	void ReviveInvisible(int iDur);
-
-	bool Attack(LPCHARACTER pkVictim, BYTE bType = 0);
-	bool IsAlive() const { return m_pointsInstant.position == POS_DEAD ? false : true; }
-	bool CanFight() const;
-
-	bool CanBeginFight() const;
-	void BeginFight(LPCHARACTER pkVictim); // pkVictimr°ú ½Î¿ì±â ½ÃÀÛÇÑ´Ù. (°­Á¦ÀûÀÓ, ½ÃÀÛÇÒ ¼ö ÀÖ³ª Ã¼Å©ÇÏ·Á¸é CanBeginFightÀ» »ç¿ë)
-
-	bool CounterAttack(LPCHARACTER pkChr); // ¹Ý°ÝÇÏ±â (¸ó½ºÅÍ¸¸ »ç¿ë)
-
-	bool IsStun() const;
-	void Stun(bool bImmediate = false);
-	bool IsDead() const;
-	void Dead(LPCHARACTER pkKiller = NULL, bool bImmediateDead = false);
-
-	void Reward(bool bItemDrop);
-	void RewardGold(LPCHARACTER pkAttacker);
-
-	bool Shoot(BYTE bType);
-	void FlyTarget(DWORD dwTargetVID, long x, long y, BYTE bHeader);
-
-	void ForgetMyAttacker(bool bRevive = true);
-	void AggregateMonster();
-	void AttractRanger();
-	void PullMonster();
-
-	int GetArrowAndBow(LPITEM* ppkBow, LPITEM* ppkArrow, int iArrowCount = 1);
-	void UseArrow(LPITEM pkArrow, DWORD dwArrowCount);
-
-	void AttackedByPoison(LPCHARACTER pkAttacker);
-	void RemovePoison();
-
-	void AttackedByBleeding(LPCHARACTER pkAttacker);
-	void RemoveBleeding();
-
-	void AttackedByFire(LPCHARACTER pkAttacker, int amount, int count);
-	void RemoveFire();
-
-	void UpdateAlignment(int iAmount);
-	int GetAlignment() const;
-
-	// ¼±¾ÇÄ¡ ¾ò±â 
-	int GetRealAlignment() const;
-	void ShowAlignment(bool bShow);
-
-	UINT GetAlignmentGrade() const;
-
-	void SetKillerMode(bool bOn);
-	bool IsKillerMode() const;
-	void UpdateKillerMode();
-
-	BYTE GetPKMode() const;
-	void SetPKMode(BYTE bPKMode);
-
-	void ItemDropPenalty(LPCHARACTER pkKiller);
-
-	void UpdateAggrPoint(LPCHARACTER ch, EDamageType type, int dam);
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// HACK
-public:
-	void SetComboSequence(BYTE seq);
-	BYTE GetComboSequence() const;
-
-	void SetLastComboTime(DWORD time);
-	DWORD GetLastComboTime() const;
-
-	int GetValidComboInterval() const;
-	void SetValidComboInterval(int interval);
-
-	BYTE GetComboIndex() const;
-
-	void IncreaseComboHackCount(int k = 1);
-	void ResetComboHackCount();
-	void SkipComboAttackByTime(int interval);
-	DWORD GetSkipComboAttackByTime() const;
-
-protected:
-	BYTE m_bComboSequence;
-	DWORD m_dwLastComboTime;
-	int m_iValidComboInterval;
-	BYTE m_bComboIndex;
-	int m_iComboHackCount;
-	DWORD m_dwSkipComboAttackByTime;
-
-protected:
-	void UpdateAggrPointEx(LPCHARACTER ch, EDamageType type, int dam, TBattleInfo& info);
-	void ChangeVictimByAggro(int iNewAggro, LPCHARACTER pNewVictim);
-
-	DWORD m_dwFlyTargetID;
-	std::vector<DWORD> m_vec_dwFlyTargets;
-	TDamageMap m_map_kDamage; // ¾î¶² Ä³¸¯ÅÍ°¡ ³ª¿¡°Ô ¾ó¸¶¸¸Å­ÀÇ µ¥¹ÌÁö¸¦ ÁÖ¾ú´Â°¡?
-	//AttackLog m_kAttackLog;
-	DWORD m_dwKillerPID;
-
-	int m_iAlignment; // Lawful / Chaotic value -200000 ~ 200000
-	int m_iRealAlignment;
-	int m_iKillerModePulse;
-	BYTE m_bPKMode;
-
-	// Aggro
-	DWORD m_dwLastVictimSetTime;
-	int m_iMaxAggro;
-	// End of Battle
-
-	// Stone
-public:
-	void SetStone(LPCHARACTER pkChrStone);
-	void ClearStone();
-	void DetermineDropMetinStone();
-	DWORD GetDropMetinStoneVnum() const { return m_dwDropMetinStone; }
-	BYTE GetDropMetinStonePct() const { return m_bDropMetinStonePct; }
-
-protected:
-	LPCHARACTER m_pkChrStone; // ³ª¸¦ ½ºÆùÇÑ µ¹
-	CHARACTER_SET m_set_pkChrSpawnedBy; // ³»°¡ ½ºÆùÇÑ ³ðµé
-	DWORD m_dwDropMetinStone;
-	BYTE m_bDropMetinStonePct;
-	// End of Stone
-
-public:
-	enum
-	{
-		SKILL_UP_BY_POINT,
-		SKILL_UP_BY_BOOK,
-		SKILL_UP_BY_TRAIN,
-
-		// ADD_GRANDMASTER_SKILL
-		SKILL_UP_BY_QUEST,
-		// END_OF_ADD_GRANDMASTER_SKILL
-	};
-
-	void SkillLevelPacket();
-	void SkillLevelUp(DWORD dwVnum, BYTE bMethod = SKILL_UP_BY_POINT);
-	bool SkillLevelDown(DWORD dwVnum);
-	// ADD_GRANDMASTER_SKILL
-	bool UseSkill(DWORD dwVnum, LPCHARACTER pkVictim, bool bUseGrandMaster = true);
-	void ResetSkill();
-#if defined(__SKILL_COOLTIME_UPDATE__)
-	void ResetSkillCoolTimes();
-#endif
-	void SetSkillLevel(DWORD dwVnum, BYTE bLev);
-	int GetUsedSkillMasterType(DWORD dwVnum);
-
-	bool IsLearnableSkill(DWORD dwSkillVnum) const;
-	// END_OF_ADD_GRANDMASTER_SKILL
-
-	bool CheckSkillHitCount(const BYTE SkillID, const VID dwTargetVID);
-	bool CanUseSkill(DWORD dwSkillVnum) const;
-	bool IsUsableSkillMotion(DWORD dwMotionIndex) const;
-	int GetSkillLevel(DWORD dwVnum) const;
-	int GetSkillMasterType(DWORD dwVnum) const;
-	int GetSkillPower(DWORD dwVnum, BYTE bLevel = 0) const;
-
-	time_t GetSkillNextReadTime(DWORD dwVnum) const;
-	void SetSkillNextReadTime(DWORD dwVnum, time_t time);
-	void SkillLearnWaitMoreTimeMessage(DWORD dwVnum);
-
-	void ComputePassiveSkill(DWORD dwVnum);
-#ifdef ENABLE_QUEEN_NETHIS
-	int ComputeSnakeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel);
-#endif
-	int ComputeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
-	int ComputeSkillParty(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
-	int ComputeSkillAtPosition(DWORD dwVnum, const PIXEL_POSITION& posTarget, BYTE bSkillLevel = 0);
-#if defined(__PVP_BALANCE_IMPROVING__)
-	int ComputeGyeongGongSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
-#endif
-	void ComputeSkillPoints();
-
-	void SetSkillGroup(BYTE bSkillGroup);
-	BYTE GetSkillGroup() const { return m_points.bSkillGroup; }
-
-	int ComputeCooltime(int time);
-
-	void GiveRandomSkillBook();
-	void GiveSkillBook(DWORD dwSkillVnum, WORD wCount);
-
-	void DisableCooltime();
-	bool LearnSkillByBook(DWORD dwSkillVnum, BYTE bProb = 0);
-	bool LearnGrandMasterSkill(DWORD dwSkillVnum);
-
-#if defined(__CONQUEROR_LEVEL__)
-	bool IsConquerorSkill(DWORD dwVnum) const;
-#endif
-
-private:
-	bool m_bDisableCooltime;
-	DWORD m_dwLastSkillTime; ///< ¸¶Áö¸·À¸·Î skill À» ¾´ ½Ã°£(millisecond).
-	// End of Skill
-
-	// MOB_SKILL
-public:
-	bool HasMobSkill() const;
-	size_t CountMobSkill() const;
-	const TMobSkillInfo* GetMobSkill(unsigned int idx) const;
-	bool CanUseMobSkill(unsigned int idx) const;
-	bool UseMobSkill(unsigned int idx);
-	void ResetMobSkillCooltime();
-protected:
-	DWORD m_adwMobSkillCooltime[MOB_SKILL_MAX_NUM];
-	// END_OF_MOB_SKILL
-
-	// for SKILL_MUYEONG
-public:
-	void StartMuyeongEvent();
-	void StopMuyeongEvent();
-
-#if defined(__PVP_BALANCE_IMPROVING__)
-	void StartGyeongGongEvent();
-	void StopGyeongGongEvent();
-#endif
-
-#if defined(__9TH_SKILL__)
-	void StartCheonunEvent(BYTE bChance, BYTE bDuration);
-	void StopCheonunEvent();
-#endif
-
-private:
-	LPEVENT m_pkMuyeongEvent;
-#ifdef ENABLE_QUEEN_NETHIS
-	LPEVENT m_pkSnakeSkillEvent;
-#endif
-#if defined(__PVP_BALANCE_IMPROVING__)
-	LPEVENT m_pkGyeongGongEvent;
-#endif
-#if defined(__9TH_SKILL__)
-	LPEVENT m_pkCheonunEvent;
-#endif
-
-	// for SKILL_CHAIN lighting
-public:
-	int GetChainLightningIndex() const { return m_iChainLightingIndex; }
-	void IncChainLightningIndex() { ++m_iChainLightingIndex; }
-	void AddChainLightningExcept(LPCHARACTER ch) { m_setExceptChainLighting.insert(ch); }
-	void ResetChainLightningIndex() { m_iChainLightingIndex = 0; m_setExceptChainLighting.clear(); }
-	int GetChainLightningMaxCount() const;
-	const CHARACTER_SET& GetChainLightingExcept() const { return m_setExceptChainLighting; }
-
-private:
-	int m_iChainLightingIndex;
-	CHARACTER_SET m_setExceptChainLighting;
-
-	// for SKILL_EUNHYUNG
-public:
-	void SetAffectedEunhyung();
-	void ClearAffectedEunhyung() { m_dwAffectedEunhyungLevel = 0; }
-	bool GetAffectedEunhyung() const { return m_dwAffectedEunhyungLevel; }
-
-private:
-	DWORD m_dwAffectedEunhyungLevel;
-
-	//
-	// Skill levels
-	//
-protected:
-	TPlayerSkill* m_pSkillLevels;
-	std::unordered_map<BYTE, int> m_SkillDamageBonus;
-	std::map<int, TSkillUseInfo> m_SkillUseInfo;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// AI related
-public:
-	void AssignTriggers(const TMobTable* table);
-	LPCHARACTER GetVictim() const; // °ø°ÝÇÒ ´ë»ó ¸®ÅÏ
-	void SetVictim(LPCHARACTER pkVictim);
-	LPCHARACTER GetNearestVictim(LPCHARACTER pkChr);
-	LPCHARACTER GetProtege() const; // º¸È£ÇØ¾ß ÇÒ ´ë»ó ¸®ÅÏ
-
-	bool Follow(LPCHARACTER pkChr, float fMinimumDistance = 150.0f);
-	bool Return();
-	bool IsGuardNPC() const;
-	bool IsChangeAttackPosition(LPCHARACTER target) const;
-	void ResetChangeAttackPositionTime() { m_dwLastChangeAttackPositionTime = get_dword_time() - AI_CHANGE_ATTACK_POISITION_TIME_NEAR; }
-	void SetChangeAttackPositionTime() { m_dwLastChangeAttackPositionTime = get_dword_time(); }
-
-	bool OnIdle();
-
-	void OnAttack(LPCHARACTER pkChrAttacker);
-	void OnClick(LPCHARACTER pkChrCauser);
-
-	VID m_kVIDVictim;
-
-protected:
-	DWORD m_dwLastChangeAttackPositionTime;
-	CTrigger m_triggerOnClick;
-	// End of AI
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Target
-protected:
-	LPCHARACTER m_pkChrTarget; // ³» Å¸°Ù
-	CHARACTER_SET m_set_pkChrTargetedBy; // ³ª¸¦ Å¸°ÙÀ¸·Î °¡Áö°í ÀÖ´Â »ç¶÷µé
-
-public:
-	void SetTarget(LPCHARACTER pkChrTarget);
-	void BroadcastTargetPacket();
-	void ClearTarget();
-	void CheckTarget();
-	LPCHARACTER GetTarget() const { return m_pkChrTarget; }
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Safebox
-public:
-	int GetSafeboxSize() const;
-	void QuerySafeboxSize();
-	void SetSafeboxSize(int size);
-
-	CSafebox* GetSafebox() const;
-	void LoadSafebox(int iSize, DWORD dwGold, int iItemCount, TPlayerItem* pItems);
-	void ChangeSafeboxSize(BYTE bSize);
-	void CloseSafebox();
-
-	/// Ã¢°í ¿­±â ¿äÃ»
-	/**
-	* @param [in] pszPassword 1ÀÚ ÀÌ»ó 6ÀÚ ÀÌÇÏÀÇ Ã¢°í ºñ¹Ð¹øÈ£
-	*
-	* DB ¿¡ Ã¢°í¿­±â¸¦ ¿äÃ»ÇÑ´Ù.
-	* Ã¢°í´Â Áßº¹À¸·Î ¿­Áö ¸øÇÏ¸ç, ÃÖ±Ù Ã¢°í¸¦ ´ÝÀº ½Ã°£À¸·Î ºÎÅÍ 10ÃÊ ÀÌ³»¿¡´Â ¿­ Áö ¸øÇÑ´Ù.
-	**/
-	void ReqSafeboxLoad(const char* pszPassword);
-
-	/// Ã¢°í ¿­±â ¿äÃ»ÀÇ Ãë¼Ò
-	/**
-	* ReqSafeboxLoad ¸¦ È£ÃâÇÏ°í CloseSafebox ÇÏÁö ¾Ê¾ÒÀ» ¶§ ÀÌ ÇÔ¼ö¸¦ È£ÃâÇÏ¸é Ã¢°í¸¦ ¿­ ¼ö ÀÖ´Ù.
-	* Ã¢°í¿­±âÀÇ ¿äÃ»ÀÌ DB ¼­¹ö¿¡¼­ ½ÇÆÐÀÀ´äÀ» ¹Þ¾ÒÀ» °æ¿ì ÀÌ ÇÔ¼ö¸¦ »ç¿ëÇØ¼­ ¿äÃ»À» ÇÒ ¼ö ÀÖ°Ô ÇØÁØ´Ù.
-	**/
-	void CancelSafeboxLoad(void) { m_bOpeningSafebox = false; }
-
-	void SetMallLoadTime(int t) { m_iMallLoadTime = t; }
-	int GetMallLoadTime() const { return m_iMallLoadTime; }
-
-	CSafebox* GetMall() const;
-	void LoadMall(int iItemCount, TPlayerItem* pItems);
-	void CloseMall();
-
-	void SetSafeboxOpenPosition();
-	float GetDistanceFromSafeboxOpen() const;
-
-	void LoadSafeboxBuff();
-	void SetSafeboxBuff();
-
-protected:
-	CSafebox* m_pkSafebox;
-	int m_iSafeboxSize;
-	int m_iSafeboxLoadTime;
-	bool m_bOpeningSafebox; ///< Ã¢°í°¡ ¿­±â ¿äÃ» ÁßÀÌ°Å³ª ¿­·ÁÀÖ´Â°¡ ¿©ºÎ, true ÀÏ °æ¿ì ¿­±â¿äÃ»ÀÌ°Å³ª ¿­·ÁÀÖÀ½.
-
-	CSafebox* m_pkMall;
-	int m_iMallLoadTime;
-
-	PIXEL_POSITION m_posSafeboxOpen;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Mounting
-public:
-	void UnMount(bool bUnequipItem = false);
-	void MountVnum(DWORD vnum);
-	DWORD GetMountVnum() const { return m_dwMountVnum; }
-	DWORD GetLastMountTime() const { return m_dwMountTime; }
-
-	bool CanUseHorseSkill();
-
-	// Horse
-	virtual void SetHorseLevel(int iLevel);
-
-	virtual bool StartRiding();
-	virtual bool StopRiding();
-
-	virtual DWORD GetMyHorseVnum() const;
-
-	virtual void HorseDie();
-	virtual bool ReviveHorse();
-
-	virtual void SendHorseInfo();
-	virtual void ClearHorseInfo();
-
-	void HorseSummon(bool bSummon, bool bFromFar = false, DWORD dwVnum = 0, const char* pHorseName = 0);
-
-	LPCHARACTER GetHorse() const { return m_chHorse; } // ÇöÀç ¼ÒÈ¯ÁßÀÎ ¸»
-	LPCHARACTER GetRider() const; // rider on horse
-	void SetRider(LPCHARACTER ch);
-
-	bool IsRiding() const;
-
-#if defined(__PET_SYSTEM__)
-public:
-	CPetSystem* GetPetSystem() { return m_petSystem; }
-
-protected:
-	CPetSystem* m_petSystem;
-
-public:
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-public:
-	bool	IsPet() const { return m_bCharType == CHAR_TYPE_PET_PAY; }
-	bool	IsGrowthPet() { return m_bCharType == CHAR_TYPE_PET; };
-	void	SetInvincible(bool bInvincible) { m_bInvincible = bInvincible; }
-	bool	IsInvincible() { return m_bInvincible; }
-
-	void	SetPetHatchWindow(bool bState) { m_bIsPetHatchOpen = bState; }
-	bool	IsPetHatchWindowOpen() { return m_bIsPetHatchOpen; }
-	void	SetPetChangeNameWindow(bool bState) { m_bIsPetChangeNameOpen = bState; }
-	bool	IsPetChangeNameWindowOpen() { return m_bIsPetChangeNameOpen; }
-
-	void	SetPetWindowType(BYTE bType) { m_bPetWindowType = bType; }
-	BYTE	GetPetWindowType() const { return m_bPetWindowType; }
-
-	void	SetGrowthPetLoaded(bool bState) { m_bIsGrowthPetLoaded = bState; }
-	bool	IsGrowthPetLoaded() { return m_bIsGrowthPetLoaded; }
-
-	void	SetCharacterSize(BYTE bSize) { m_bCharacterSize = bSize; }
-	BYTE	GetCharacterSize() { return m_bCharacterSize; }
-
-	bool			SetGrowthPet(LPGROWTH_PET pkPet);
-	bool			DeleteGrowthPet(DWORD dwID);
-	LPGROWTH_PET	GetGrowthPet(DWORD dwID);
-	void			ClearGrowthPet();
-
-	void			SetActiveGrowthPet(LPGROWTH_PET pkPet) { m_activeGrowthPet = pkPet;  }
-	LPGROWTH_PET	GetActiveGrowthPet() { return m_activeGrowthPet; }
-
-private:
-	DWORD	m_bInvincible;
-	bool	m_bIsPetHatchOpen;
-	bool	m_bIsPetChangeNameOpen;
-	BYTE	m_bPetWindowType;
-
-	bool	m_bIsGrowthPetLoaded;
-
-	CGrowthPetManager::TGrowthPetMap m_growthPetMap;
-	LPGROWTH_PET m_activeGrowthPet;
-
-	BYTE m_bCharacterSize;
-#endif
-
-protected:
-	LPCHARACTER m_chHorse;
-	LPCHARACTER m_chRider;
-
-	DWORD m_dwMountVnum;
-	DWORD m_dwMountTime;
-
-	BYTE m_bSendHorseLevel;
-	BYTE m_bSendHorseHealthGrade;
-	BYTE m_bSendHorseStaminaGrade;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Detailed Log
-public:
-	void DetailLog() { m_bDetailLog = !m_bDetailLog; }
-	void ToggleMonsterLog();
-	void MonsterLog(const char* format, ...);
-
-private:
-	bool m_bDetailLog;
-	bool m_bMonsterLog;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Empire
-public:
-	void SetEmpire(BYTE bEmpire);
-	BYTE GetEmpire() const { return m_bEmpire; }
-
-protected:
-	BYTE m_bEmpire;
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Regen
-public:
-	void SetRegen(LPREGEN pkRegen);
-
-protected:
-	PIXEL_POSITION m_posRegen;
-	float m_fRegenAngle;
-	LPREGEN m_pkRegen;
-	size_t regen_id_; // to help dungeon regen identification
-	// End of Regen
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// Resists & Proofs
-public:
-	bool CannotMoveByAffect() const; // Æ¯Á¤ È¿°ú¿¡ ÀÇÇØ ¿òÁ÷ÀÏ ¼ö ¾ø´Â »óÅÂÀÎ°¡?
-	bool IsImmune(DWORD dwImmuneFlag);
-	void SetImmuneFlag(DWORD dw) { m_pointsInstant.dwImmuneFlag = dw; }
-
-protected:
-	void ApplyMobAttribute(const TMobTable* table);
-	// End of Resists & Proofs
-
-	////////////////////////////////////////////////////////////////////////////////////////
-	// QUEST
-public:
-	void SetQuestNPCID(DWORD vid);
-	DWORD GetQuestNPCID() const { return m_dwQuestNPCVID; }
-	LPCHARACTER GetQuestNPC() const;
-
-	void SetQuestItemPtr(LPITEM item);
-	void ClearQuestItemPtr();
-	LPITEM GetQuestItemPtr() const;
-
-	void SetQuestBy(DWORD dwQuestVnum) { m_dwQuestByVnum = dwQuestVnum; }
-	DWORD GetQuestBy() const { return m_dwQuestByVnum; }
-
-	int GetQuestFlag(const std::string& flag) const;
-	void SetQuestFlag(const std::string& flag, int value);
-
-	void ConfirmWithMsg(const char* szMsg, int iTimeout, DWORD dwRequestPID);
-	bool IsRunningQuest() const;
-
-private:
-	DWORD m_dwQuestNPCVID;
-	DWORD m_dwQuestByVnum;
-	LPITEM m_pQuestItem;
-
-	// Events
-public:
-	bool StartStateMachine(int iPulse = 1);
-	void StopStateMachine();
-	void UpdateStateMachine(DWORD dwPulse);
-	void SetNextStatePulse(int iPulseNext);
-
-	// Ä³¸¯ÅÍ ÀÎ½ºÅÏ½º ¾÷µ¥ÀÌÆ® ÇÔ¼ö. ±âÁ¸¿£ ÀÌ»óÇÑ »ó¼Ó±¸Á¶·Î CFSM::Update ÇÔ¼ö¸¦ È£ÃâÇÏ°Å³ª UpdateStateMachine ÇÔ¼ö¸¦ »ç¿ëÇß´Âµ¥, º°°³ÀÇ ¾÷µ¥ÀÌÆ® ÇÔ¼ö Ãß°¡ÇÔ.
-	void UpdateCharacter(DWORD dwPulse);
-
-protected:
-	DWORD m_dwNextStatePulse;
-
-	// Marriage
-public:
-	LPCHARACTER GetMarryPartner() const;
-	void SetMarryPartner(LPCHARACTER ch);
-	int GetMarriageBonus(DWORD dwItemVnum, bool bSum = true);
-
-	bool IsWearingDress() const;
-
-	void SetWeddingMap(marriage::WeddingMap* pMap);
-	marriage::WeddingMap* GetWeddingMap() const { return m_pWeddingMap; }
-
-private:
-	marriage::WeddingMap* m_pWeddingMap;
-	LPCHARACTER m_pkChrMarried;
-
-	// Warp Character
-public:
-	void StartWarpNPCEvent();
-
-public:
-	void StartSaveEvent();
-	void StartRecoveryEvent();
-	void StartCheckSpeedHackEvent();
-	void StartDestroyWhenIdleEvent();
-
-	LPEVENT m_pkDeadEvent;
-	LPEVENT m_pkStunEvent;
-	LPEVENT m_pkSaveEvent;
-	LPEVENT m_pkRecoveryEvent;
-	LPEVENT m_pkTimedEvent;
-	LPEVENT m_pkFishingEvent;
-	LPEVENT m_pkAffectEvent;
-	LPEVENT m_pkPoisonEvent;
-	LPEVENT m_pkBleedingEvent;
-	LPEVENT m_pkFireEvent;
-#if defined(__DAWNMIST_DUNGEON__)
-	LPEVENT m_pkHealEvent;
-#endif
-	LPEVENT m_pkWarpNPCEvent;
-	// DELAYED_WARP
-	// END_DELAYED_WARP
-
-	// MINING
-	LPEVENT m_pkMiningEvent;
-	// END_OF_MINING
-	LPEVENT m_pkWarpEvent;
-	LPEVENT m_pkCheckSpeedHackEvent;
-	LPEVENT m_pkDestroyWhenIdleEvent;
-	LPEVENT m_pkPetSystemUpdateEvent;
-
-	bool IsWarping() const { return m_pkWarpEvent ? true : false; }
-
-	bool m_bHasPoisoned;
-	bool m_bHasBled;
-
-	const CMob* m_pkMobData;
-	CMobInstance* m_pkMobInst;
-
-	MobSkillEventMap m_mapMobSkillEvent;
-
-	friend struct FuncSplashDamage;
-	friend struct FuncSplashAffect;
-	friend class CFuncShoot;
-
-public:
-	int GetPremiumRemainSeconds(BYTE bType) const;
-
-private:
-	int m_aiPremiumTimes[PREMIUM_MAX_NUM];
-
-	// CHANGE_ITEM_ATTRIBUTES
-	static const DWORD msc_dwDefaultChangeItemAttrCycle; ///< µðÆúÆ® ¾ÆÀÌÅÛ ¼Ó¼ºº¯°æ °¡´É ÁÖ±â
-	static const char msc_szLastChangeItemAttrFlag[]; ///< ÃÖ±Ù ¾ÆÀÌÅÛ ¼Ó¼ºÀ» º¯°æÇÑ ½Ã°£ÀÇ Quest Flag ÀÌ¸§
-	static const char msc_szChangeItemAttrCycleFlag[]; ///< ¾ÆÀÌÅÛ ¼Ó¼ºº´°æ °¡´É ÁÖ±âÀÇ Quest Flag ÀÌ¸§
-	// END_OF_CHANGE_ITEM_ATTRIBUTES
-
-	// PC_BANG_ITEM_ADD
-private:
-	bool m_isinPCBang;
-
-public:
-	bool SetPCBang(bool flag) { m_isinPCBang = flag; return m_isinPCBang; }
-	bool IsPCBang() const { return m_isinPCBang; }
-	// END_PC_BANG_ITEM_ADD
-
-	// NEW_HAIR_STYLE_ADD
-public:
-	bool ItemProcess_Hair(LPITEM item, int iDestCell);
-	// END_NEW_HAIR_STYLE_ADD
-
-public:
-	void ClearSkill();
-	void ClearSubSkill();
-
-	// RESET_ONE_SKILL
-	bool ResetOneSkill(DWORD dwVnum);
-	// END_RESET_ONE_SKILL
-
-private:
-	void SendDamagePacket(LPCHARACTER pAttacker, int Damage, BYTE DamageFlag);
-
-	// ARENA
-private:
-	CArena* m_pArena;
-	bool m_ArenaObserver;
-	int m_nPotionLimit;
-
-public:
-	void SetArena(CArena* pArena) { m_pArena = pArena; }
-	void SetArenaObserverMode(bool flag) { m_ArenaObserver = flag; }
-
-	CArena* GetArena() const { return m_pArena; }
-	bool GetArenaObserverMode() const { return m_ArenaObserver; }
-
-	void SetPotionLimit(int count) { m_nPotionLimit = count; }
-	int GetPotionLimit() const { return m_nPotionLimit; }
-	// END_ARENA
-
-	// PREVENT_TRADE_WINDOW
-public:
-	bool IsOpenSafebox() const { return m_isOpenSafebox ? true : false; }
-	void SetOpenSafebox(bool b) { m_isOpenSafebox = b; }
-
-	int GetSafeboxLoadTime() const { return m_iSafeboxLoadTime; }
-	void SetSafeboxLoadTime() { m_iSafeboxLoadTime = thecore_pulse(); }
-
-private:
-	bool m_isOpenSafebox;
-	// END_PREVENT_TRADE_WINDOW
-
-public:
-	int GetSkillPowerByLevel(int iLevel, bool bMob = false) const;
-
-	// PREVENT_REFINE_HACK
-	int GetRefineTime() const { return m_iRefineTime; }
-	void SetRefineTime() { m_iRefineTime = thecore_pulse(); }
-	int m_iRefineTime;
-	// END_PREVENT_REFINE_HACK
-
-	// RESTRICT_USE_SEED_OR_MOONBOTTLE
-	int GetUseSeedOrMoonBottleTime() const { return m_iSeedTime; }
-	void SetUseSeedOrMoonBottleTime() { m_iSeedTime = thecore_pulse(); }
-	int m_iSeedTime;
-	// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
-
-	// PREVENT_PORTAL_AFTER_EXCHANGE
-	int GetExchangeTime() const { return m_iExchangeTime; }
-	void SetExchangeTime() { m_iExchangeTime = thecore_pulse(); }
-	int m_iExchangeTime;
-	// END_PREVENT_PORTAL_AFTER_EXCHANGE
-
-	int m_iMyShopTime;
-	int GetMyShopTime() const { return m_iMyShopTime; }
-	void SetMyShopTime() { m_iMyShopTime = thecore_pulse(); }
-
-	// PREVENT_TRADE_WINDOW
-	bool PreventTradeWindow(int flags, bool except = false) const;
-	// END_PREVENT_TRADE_WINDOW
-
-	// Hack ¹æÁö¸¦ À§ÇÑ Ã¼Å©.
-	bool IsHack(bool bSendMsg = true, bool bCheckShopOwner = true, int limittime = g_nPortalLimitTime);
-
-	// MONARCH
-	BOOL IsMonarch() const;
-	// END_MONARCH
-	void Say(const std::string& s);
-
-	enum MONARCH_COOLTIME
-	{
-		MC_HEAL = 10,
-		MC_WARP = 60,
-		MC_TRANSFER = 60,
-		MC_TAX = (60 * 60 * 24 * 7),
-		MC_SUMMON = (60 * 60),
-	};
-
-	enum MONARCH_INDEX
-	{
-		MI_HEAL = 0,
-		MI_WARP,
-		MI_TRANSFER,
-		MI_TAX,
-		MI_SUMMON,
-		MI_MAX
-	};
-
-	DWORD m_dwMonarchCooltime[MI_MAX];
-	DWORD m_dwMonarchCooltimelimit[MI_MAX];
-
-	void InitMC();
-	DWORD GetMC(enum MONARCH_INDEX e) const;
-	void SetMC(enum MONARCH_INDEX e);
-	bool IsMCOK(enum MONARCH_INDEX e) const;
-	DWORD GetMCL(enum MONARCH_INDEX e) const;
-	DWORD GetMCLTime(enum MONARCH_INDEX e) const;
-
-public:
-	bool ItemProcess_Polymorph(LPITEM item);
-
-#if !defined(__CUBE_RENEWAL__)
-	// by mhh
-	LPITEM* GetCubeItem() { return m_pointsInstant.pCubeItems; }
-#endif
-	bool IsCubeOpen() const { return (m_pointsInstant.pCubeNpc ? true : false); }
-	void SetCubeNpc(LPCHARACTER npc) { m_pointsInstant.pCubeNpc = npc; }
-	bool CanDoCube() const;
-
-public:
-	bool IsSiegeNPC() const;
-
-private:
-	// Áß±¹ Àü¿ë
-	// 18¼¼ ¹Ì¸¸ Àü¿ë
-	// 3½Ã°£ : 50 % 5 ½Ã°£ 0%
-	e_overtime m_eOverTime;
-
-public:
-	bool IsOverTime(e_overtime e) const { return (e == m_eOverTime); }
-	void SetOverTime(e_overtime e) { m_eOverTime = e; }
-
-private:
-	int m_deposit_pulse;
-
-public:
-	void UpdateDepositPulse();
-	bool CanDeposit() const;
-
-private:
-	void __OpenPrivateShop();
-
-public:
-	struct AttackedLog
-	{
-		DWORD dwPID;
-		DWORD dwAttackedTime;
-
-		AttackedLog() : dwPID(0), dwAttackedTime(0)
-		{
-		}
-	};
-
-	AttackLog m_kAttackLog;
-	AttackedLog m_AttackedLog;
-	int m_speed_hack_count;
-
-private:
-	std::string m_strNewName;
-
-public:
-	const std::string GetNewName() const { return this->m_strNewName; }
-	void SetNewName(const std::string name) { this->m_strNewName = name; }
-
-public:
-	void GoHome();
-
-private:
-	std::set<DWORD> m_known_guild;
-
-public:
-	void SendGuildName(CGuild* pGuild);
-	void SendGuildName(DWORD dwGuildID);
-
-private:
-	DWORD m_dwLogOffInterval;
-	DWORD m_dwLastPlay;
-
-public:
-	DWORD GetLogOffInterval() const { return m_dwLogOffInterval; }
-	DWORD GetLastPlay() const { return m_dwLastPlay; }
-
-public:
-	bool UnEquipSpecialRideUniqueItem();
-
-	bool CanWarp() const;
-	bool IsInSafezone() const;
-	bool IsInBlockedArea(long x = 0, long y = 0) const;
-
-private:
-	DWORD m_dwLastGoldDropTime;
-#if defined(__CHEQUE_SYSTEM__)
-	DWORD m_dwLastChequeDropTime;
-#endif
-
-public:
-	void AutoRecoveryItemProcess(const EAffectTypes);
-
-public:
-	void BuffOnAttr_AddBuffsFromItem(LPITEM pItem);
-	void BuffOnAttr_RemoveBuffsFromItem(LPITEM pItem);
-
-private:
-	void BuffOnAttr_ValueChange(POINT_TYPE wPointType, POINT_VALUE lOldValue, POINT_VALUE lNewValue);
-	void BuffOnAttr_ClearAll();
-
-	typedef std::map<DWORD, CBuffOnAttributes*> TMapBuffOnAttrs;
-	TMapBuffOnAttrs m_map_buff_on_attrs;
-	// ¹«Àû : ¿øÈ°ÇÑ Å×½ºÆ®¸¦ À§ÇÏ¿©.
-
-public:
-	void SetArmada() { cannot_dead = true; }
-	void ResetArmada() { cannot_dead = false; }
-
-private:
-	bool cannot_dead;
-
-#if defined(__PET_SYSTEM__)
-private:
-	bool m_bIsPet;
-
-public:
-	void SetPet() { m_bIsPet = true; }
-	bool IsPet() { return m_bIsPet; }
-#endif
-
-	// ÃÖÁ¾ µ¥¹ÌÁö º¸Á¤.
-private:
-	float m_fAttMul;
-	float m_fDamMul;
-
-public:
-	float GetAttMul() { return this->m_fAttMul; }
-	void SetAttMul(float newAttMul) { this->m_fAttMul = newAttMul; }
-	float GetDamMul() { return this->m_fDamMul; }
-	void SetDamMul(float newDamMul) { this->m_fDamMul = newDamMul; }
-
-private:
-	bool IsValidItemPosition(TItemPos Pos) const;
-
-	// µ¶ÀÏ ¼±¹° ±â´É ÆÐÅ¶ ÀÓ½Ã ÀúÀå
-private:
-	unsigned int itemAward_vnum;
-	char itemAward_cmd[20];
-	//bool itemAward_flag;
-public:
-	unsigned int GetItemAward_vnum() { return itemAward_vnum; }
-	char* GetItemAward_cmd() { return itemAward_cmd; }
-	//bool GetItemAward_flag() { return itemAward_flag; }
-	void SetItemAward_vnum(unsigned int vnum) { itemAward_vnum = vnum; }
-	void SetItemAward_cmd(char* cmd) { strcpy(itemAward_cmd, cmd); }
-	//void SetItemAward_flag(bool flag) { itemAward_flag = flag; }
-
-#if defined(__MOVE_COSTUME_ATTR__)
-public:
-	void ItemCombination(const short MediumIndex, const short BaseIndex, const short MaterialIndex);
-	void OpenItemComb();
-
-	bool IsItemComb() const { return m_pointsInstant.pItemCombNpc != NULL; }
-	void SetItemCombNpc(const LPCHARACTER npc) { m_pointsInstant.pItemCombNpc = npc; }
-#endif
-
-#if defined(__CHANGED_ATTR__)
-public:
-	void SelectAttr(LPITEM material, LPITEM item);
-	void SelectAttrResult(const bool bNew, const TItemPos& pos);
-	bool IsSelectAttr() const;
-private:
-	struct SItemSelectAttr
-	{
-		DWORD dwItemID;
-		TPlayerItemAttribute Attr[ITEM_ATTRIBUTE_MAX_NUM];
-	} m_ItemSelectAttr;
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__)
-public:
-	void MiniGameCatchKingSetFieldCards(std::vector<TCatchKingCard> vec) { m_vecCatchKingFieldCards = vec; }
-
-	DWORD MiniGameCatchKingGetScore() const { return dwCatchKingTotalScore; }
-	void MiniGameCatchKingSetScore(DWORD dwScore) { dwCatchKingTotalScore = dwScore; }
-
-	DWORD MiniGameCatchKingGetBetNumber() const { return bCatchKingBetSetNumber; }
-	void MiniGameCatchKingSetBetNumber(BYTE bSetNr) { bCatchKingBetSetNumber = bSetNr; }
-
-	BYTE MiniGameCatchKingGetHandCard() const { return bCatchKingHandCard; }
-	void MiniGameCatchKingSetHandCard(BYTE bKingCard) { bCatchKingHandCard = bKingCard; }
-
-	BYTE MiniGameCatchKingGetHandCardLeft() const { return bCatchKingHandCardLeft; }
-	void MiniGameCatchKingSetHandCardLeft(BYTE bHandCard) { bCatchKingHandCardLeft = bHandCard; }
-
-	bool MiniGameCatchKingGetGameStatus() const { return dwCatchKingGameStatus; }
-	void MiniGameCatchKingSetGameStatus(bool bStatus) { dwCatchKingGameStatus = bStatus; }
-
-	std::vector<TCatchKingCard> m_vecCatchKingFieldCards;
-
-protected:
-	BYTE bCatchKingHandCard;
-	BYTE bCatchKingHandCardLeft;
-	bool dwCatchKingGameStatus;
-
-	BYTE bCatchKingBetSetNumber;
-	DWORD dwCatchKingTotalScore;
-#endif
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-public:
-	// ¿ëÈ¥¼®
-
-	// Ä³¸¯ÅÍÀÇ affect, quest°¡ load µÇ±â Àü¿¡ DragonSoul_Initialize¸¦ È£ÃâÇÏ¸é ¾ÈµÈ´Ù.
-	// affect°¡ °¡Àå ¸¶Áö¸·¿¡ ·ÎµåµÇ¾î LoadAffect¿¡¼­ È£ÃâÇÔ.
-	void DragonSoul_Initialize();
-
-	bool DragonSoul_IsQualified() const;
-	void DragonSoul_GiveQualification();
-
-	int DragonSoul_GetActiveDeck() const;
-	bool DragonSoul_IsDeckActivated() const;
-	bool DragonSoul_ActivateDeck(int iDeckIdx);
-
-	void DragonSoul_DeactivateAll();
-	// ¹Ýµå½Ã ClearItem Àü¿¡ ºÒ·¯¾ß ÇÑ´Ù.
-	// ¿Ö³ÄÇÏ¸é....
-	// ¿ëÈ¥¼® ÇÏ³ª ÇÏ³ª¸¦ deactivateÇÒ ¶§¸¶´Ù µ¦¿¡ activeÀÎ ¿ëÈ¥¼®ÀÌ ÀÖ´ÂÁö È®ÀÎÇÏ°í,
-	// activeÀÎ ¿ëÈ¥¼®ÀÌ ÇÏ³ªµµ ¾ø´Ù¸é, Ä³¸¯ÅÍÀÇ ¿ëÈ¥¼® affect¿Í, È°¼º »óÅÂ¸¦ Á¦°ÅÇÑ´Ù.
-	// 
-	// ÇÏÁö¸¸ ClearItem ½Ã, Ä³¸¯ÅÍ°¡ Âø¿ëÇÏ°í ÀÖ´Â ¸ðµç ¾ÆÀÌÅÛÀ» unequipÇÏ´Â ¹Ù¶÷¿¡,
-	// ¿ëÈ¥¼® Affect°¡ Á¦°ÅµÇ°í, °á±¹ ·Î±×ÀÎ ½Ã, ¿ëÈ¥¼®ÀÌ È°¼ºÈ­µÇÁö ¾Ê´Â´Ù.
-	// (UnequipÇÒ ¶§¿¡´Â ·Î±×¾Æ¿ô »óÅÂÀÎÁö, ¾Æ´ÑÁö ¾Ë ¼ö ¾ø´Ù.)
-	// ¿ëÈ¥¼®¸¸ deactivate½ÃÅ°°í Ä³¸¯ÅÍÀÇ ¿ëÈ¥¼® µ¦ È°¼º »óÅÂ´Â °Çµå¸®Áö ¾Ê´Â´Ù.
-	void DragonSoul_CleanUp();
-
-#if defined(__DS_SET__)
-	// Dragon Soul Set Bonus
-public:
-	void DragonSoul_SetBonus();
-	void DragonSoul_ActivateAll();
-#endif
-
-	// ¿ëÈ¥¼® °­È­Ã¢
-public:
-	bool DragonSoul_RefineWindow_Open(LPENTITY pEntity);
-#if defined(__DS_CHANGE_ATTR__)
-	bool DragonSoul_RefineWindow_ChangeAttr_Open(LPENTITY pEntity);
-#endif
-	bool DragonSoul_RefineWindow_Close();
-	LPENTITY DragonSoul_RefineWindow_GetOpener() { return m_pointsInstant.m_pDragonSoulRefineWindowOpener; }
-	bool DragonSoul_RefineWindow_CanRefine();
-#endif
-
-private:
-	// SyncPositionÀ» ¾Ç¿ëÇÏ¿© Å¸À¯Àú¸¦ ÀÌ»óÇÑ °÷À¸·Î º¸³»´Â ÇÙ ¹æ¾îÇÏ±â À§ÇÏ¿©,
-	// SyncPositionÀÌ ÀÏ¾î³¯ ¶§¸¦ ±â·Ï.
-	timeval m_tvLastSyncTime;
-	int m_iSyncHackCount;
-public:
-	void SetLastSyncTime(const timeval& tv) { memcpy(&m_tvLastSyncTime, &tv, sizeof(timeval)); }
-	const timeval& GetLastSyncTime() { return m_tvLastSyncTime; }
-	void SetSyncHackCount(int iCount) { m_iSyncHackCount = iCount; }
-	int GetSyncHackCount() { return m_iSyncHackCount; }
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-public:
-	void SetChangeLook(CChangeLook* c);
-	CChangeLook* GetChangeLook() const;
-protected:
-	CChangeLook* m_pkChangeLook;
-#endif
-
-#if defined(__MAILBOX__)
-public:
-	int GetMyMailBoxTime() const { return m_iMyMailBoxTime; }
-	void SetMyMailBoxTime() { m_iMyMailBoxTime = thecore_pulse(); }
-
-	void SetMailBox(CMailBox* m);
-
-	void SetMailBoxLoading(const bool b) { bMailBoxLoading = b; }
-	bool IsMailBoxLoading() const { return bMailBoxLoading; }
-
-	CMailBox* GetMailBox() const { return m_pkMailBox; }
-
-private:
-	CMailBox* m_pkMailBox;
-	bool bMailBoxLoading;
-	int m_iMyMailBoxTime;
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-public:
-	void SetMiniGameRumi(CMiniGameRumi* pClass);
-	CMiniGameRumi* GetMiniGameRumi() const { return m_pkMiniGameRumi; }
-private:
-	CMiniGameRumi* m_pkMiniGameRumi;
-#endif
-
-#if defined(__CONQUEROR_LEVEL__)
-public:
-	bool IsNewWorldMapIndex() const;
-	long GetNewWorldSungMa(POINT_TYPE wPointType, bool bPremium = true) const;
-	bool IsSungMaCursed(POINT_TYPE wPointType) const;
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-public:
-	CLootFilter* GetLootFilter();
-	void SetLootFilter();
-	void ClearLootFilter();
-private:
-	CLootFilter* m_pLootFilter;
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-public:
-	bool IsOpenAttr67Add() const { return m_bIsOpenAttr67Add ? true : false; }
-	void SetOpenAttr67Add(bool bOpen) { m_bIsOpenAttr67Add = bOpen; }
-
-	LPITEM GetNPCStorageItem(BYTE bCell = 0) const;
-	bool Attr67Add(const TAttr67AddData kAttr67AddData);
-
-private:
-	bool m_bIsOpenAttr67Add;
-#endif
-
-#if defined(__FISHING_GAME__)
-public:
-	void SetFishingGameGoals(BYTE bCount) { m_bFishingGameGoals = bCount; }
-	BYTE GetFishingGameGoals() { return m_bFishingGameGoals; }
-private:
-	BYTE m_bFishingGameGoals;
-#endif
-
-#if defined(__GEM_SYSTEM__)
-public:
-	void SelectItemEx(DWORD dwInventoryPos, BYTE bType);
-	bool GemRefine(LPITEM lpMetinStoneItem);
-
-#	if defined(__GEM_SHOP__)
-public:
-	void SetGemShop(CGemShop* pGemShop);
-	CGemShop* GetGemShop() const { return m_pGemShop; }
-
-	void SetGemShopLoading(const bool c_bLoading) { m_bGemShopLoading = c_bLoading; }
-	bool IsGemShopLoading() const { return m_bGemShopLoading; }
-
-private:
-	CGemShop* m_pGemShop;
-	bool m_bGemShopLoading;
-#	endif
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	//////////////////////////////////////////////////////////////////////////////////
-	// Acce Costume System
-public:
-	void AcceRefineWindowOpen(const LPENTITY pEntity, BYTE bType);
-	void AcceRefineWindowClose(bool bServerClose = false);
-	bool IsAcceRefineWindowOpen() const { return m_bAcceRefineWindowOpen; }
-	bool GetAcceRefineWindowType() const { return m_bAcceRefineWindowType; }
-
-	bool IsAcceRefineWindowCanRefine();
-	LPENTITY GetAcceRefineWindowOpener() const { return m_pointsInstant.m_pAcceRefineWindowOpener; }
-
-	void AcceRefineWindowCheckIn(BYTE bType, TItemPos SelectedPos, TItemPos AttachedPos);
-	void AcceRefineWindowCheckOut(BYTE bType, TItemPos SelectedPos);
-	void AcceRefineWindowAccept(BYTE bType);
-
-	int GetAcceWeaponAttack() const;
-	int GetAcceWeaponMagicAttack() const;
-
-	void ModifyAccePoints(const LPITEM& rAcceItem, bool bAdd);
-
-protected:
-	int __CalculateAcceDrainValues(BYTE bWeaponAttackType) const;
-	int __CheckAcceRefineItem(const LPITEM& rLeftItem, const LPITEM& rRightItem) const;
-	BYTE __GetNextDrainRate(const LPITEM& rAcceItem, BYTE bMinDrainRate) const;
-
-private:
-	bool m_bAcceRefineWindowOpen;
-	BYTE m_bAcceRefineWindowType;
-	TItemPos m_pAcceRefineWindowItemSlot[ACCE_SLOT_MAX];
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-	//////////////////////////////////////////////////////////////////////////////////
-	// Aura Costume System
-public:
-	void OpenAuraRefineWindow(const LPENTITY pEntity, BYTE bType);
-	void AuraRefineWindowClose(bool bServerClose = false);
-	bool IsAuraRefineWindowOpen() const { return m_bAuraRefineWindowOpen; }
-	BYTE GetAuraRefineWindowType() const { return m_bAuraRefineWindowType; }
-
-	bool IsAuraRefineWindowCanRefine();
-	LPENTITY GetAuraRefineWindowOpener() const { return m_pointsInstant.m_pAuraRefineWindowOpener; }
-
-	void AuraRefineWindowCheckIn(BYTE bType, TItemPos SelectedPos, TItemPos AttachedPos);
-	void AuraRefineWindowCheckOut(BYTE bType, TItemPos SelectedPos);
-	void AuraRefineWindowAccept(BYTE bType);
-
-	void ModifyAuraPoints(const LPITEM& rAuraItem, bool bAdd);
-
-private:
-	BYTE m_bAuraRefineWindowType;
-	bool m_bAuraRefineWindowOpen;
-	TItemPos m_pAuraRefineWindowItemSlot[AURA_SLOT_MAX];
-	TAuraRefineInfo m_bAuraRefineInfo[AURA_REFINE_INFO_SLOT_MAX];
-
-protected:
-	TAuraRefineInfo __GetAuraRefineInfo(TItemPos Cell);
-	TAuraRefineInfo __CalcAuraRefineInfo(TItemPos Cell, TItemPos MaterialCell);
-	TAuraRefineInfo __GetAuraEvolvedRefineInfo(TItemPos Cell);
-#endif
-
-#if defined(__SOUL_SYSTEM__)
-public:
-	void SoulItemProcess(ESoulSubTypes eSubType);
-
-	int GetSoulDamage(ESoulSubTypes eSubType) const;
-	bool DoRefineSoul(LPITEM item);
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-public:
-	void SetExtendInvenStage(BYTE bStage) { m_bExtendInvenStage = bStage; }
-	BYTE GetExtendInvenStage() const { return m_bExtendInvenStage; }
-
-	WORD GetExtendInvenMax() const;
-
-	void ExtendInvenRequest();
-	void ExtendInvenUpgrade();
-
-	void SendExtendInvenPacket();
-
-private:
-	BYTE m_bExtendInvenStage;
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-public:
-	void StartHitBuffEvent();
-	void StopHitBuffEvent();
-private:
-	LPEVENT m_pHitBuffEvent;
-#endif
-
-#if defined(__CLIENT_TIMER__)
-public:
-	void SendClientTimer(BYTE bSubHeader, DWORD dwEndTime = 0, DWORD dwAlarmSec = 0);
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-public:
-	void AddEmote(const INT iEmoteIndex = -1);
-	void SetEmotes(const TPacketGDEmote* pTable, const WORD c_wSize);
-#endif
-
-#if defined(__SET_ITEM__)
-public:
-	using SetItemCountMap = std::map<BYTE, BYTE>;
-	SetItemCountMap GetItemSetCountMap() const;
-
-	void RefreshItemSetBonus();
-	void RefreshItemSetBonusByValue();
-#endif
-
-#if defined(__RACE_SWAP__)
-public:
-	void SetEventRaceNum(DWORD dwRaceNum);
-	DWORD GetEventRaceNum() const { return m_dwEventRaceNum; }
-private:
-	DWORD m_dwEventRaceNum;
-#endif
-
-#if defined(__GAME_OPTION_ESCAPE__)
-public:
-	void SetEscapeCooltime(const DWORD dwTime) { m_dwEscapeCooltime = dwTime; }
-	DWORD GetEscapeCooltime() const { return m_dwEscapeCooltime; }
-private:
-	DWORD m_dwEscapeCooltime;
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-public:
-	void RefineElementInformation(const LPITEM& rSrcItem, const TItemPos& kItemDestCell);
-	void RefineElement(WORD wElementType);
-
-	bool IsUnderRefineElement() const { return m_bUnderRefineElement; }
-	void SetUnderRefineElement(bool bState, BYTE bRefineType = 0, const TItemPos& rkSrcPos = NPOS, const TItemPos& rkDestPos = NPOS);
-
-	WORD GetRefineElementEffect() const;
-
-private:
-	struct SRefineElementItemPos
-	{
-		SRefineElementItemPos() : RefineType(0), SrcPos(NPOS), DestPos(NPOS) {}
-		BYTE RefineType;
-		TItemPos SrcPos, DestPos;
-	} m_kRefineElementItemPos;
-	bool m_bUnderRefineElement;
-#endif
-
-#if defined(__HIDE_COSTUME_SYSTEM__)
-public:
-	void SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bSave = true);
-	bool GetHiddenCostumeByPart(BYTE bPartPos) const;
-
-	void SetHiddenCostumeParts();
-private:
-	DWORD m_dwHideCostumePulse;
-	bool m_bHiddenCostumePart[COSTUME_NUM_TYPES];
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__)
-public:
-	void SetMiniGameYutnori(CMiniGameYutnori* pClass);
-	CMiniGameYutnori* GetMiniGameYutnori() const { return m_pkMiniGameYutnori; }
-private:
-	CMiniGameYutnori* m_pkMiniGameYutnori;
-#endif
-
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-public:
-	void SetCountry(const std::string& country) { m_stCountry = country; }
-	const char* GetCountry() const { return m_stCountry.c_str(); }
-
-protected:
-	std::string m_stCountry;
-#endif
-
-#if defined(__MYSHOP_DECO__)
-public:
-	void SetMyShopDecoState(BYTE bState) { m_bMyShopDecoState = bState; };
-	BYTE GetMyShopDecoState() const { return m_bMyShopDecoState; };
-
-	void SetMyShopDecoType(BYTE bShopType) { m_bMyShopDecoType = bShopType; };
-	BYTE GetMyShopDecoType() const { return m_bMyShopDecoType; };
-
-	void SetMyShopDecoPolyVnum(DWORD dwPolyVnum) { m_bMyShopDecoPolyVnum = dwPolyVnum; };
-	DWORD GetMyShopDecoPolyVnum() const { return m_bMyShopDecoPolyVnum; };
-
-	void SetMyPrivShopTabCount(BYTE bTabCount) { m_bMyPrivShopTabCount = bTabCount; };
-	BYTE GetMyPrivShopTabCount() const { return m_bMyPrivShopTabCount; };
-
-	void SetMyPrivShopIsCashItem(bool bIsCashItem) { m_bMyPrivShopIsCashItem = bIsCashItem; };
-	bool GetMyPrivShopIsCashItem() const { return m_bMyPrivShopIsCashItem; };
-
-	void OpenPrivateShop(BYTE bTabCount = 1, bool bIsCashItem = false);
-
-private:
-	BYTE m_bMyShopDecoState;
-	BYTE m_bMyShopDecoType;
-	DWORD m_bMyShopDecoPolyVnum;
-
-	BYTE m_bMyPrivShopTabCount;
-	bool m_bMyPrivShopIsCashItem;
-#endif
-
-#if defined(__LEFT_SEAT__)
-public:
-	void SetLeftSeat(bool bLeftSeat);
-	bool LeftSeat() const { return m_bLeftSeat; }
-
-	void SetLeftSeatWaitTime(BYTE bIndex);
-	DWORD GetLeftSeatWaitTime() const { return m_dwLeftSeatWaitTime; }
-
-	void SetLeftSeatLogoutTime(BYTE bIndex);
-	DWORD GetLeftSeatLogoutTime() const { return m_dwLeftSeatLogoutTime; }
-
-	void DisableLeftSeatLogOutState(bool bClosePopup = false);
-
-	void RestartLeftSeatWaitTimer();
-	void RestartLeftSeatLogoutTimer();
-
-	void SetLastRequestTime(DWORD dwRequestTime) { m_dwLastRequestTime = dwRequestTime; }
-	DWORD GetLastRequestTime() const { return m_dwLastRequestTime; }
-
-public:
-	LPEVENT m_pLeftSeatWaitTimerEvent;
-	LPEVENT m_pLeftSeatLogoutTimerEvent;
-
-private:
-	BOOL m_bLeftSeat;
-	DWORD m_dwLeftSeatWaitTime;
-	DWORD m_dwLeftSeatLogoutTime;
-	DWORD m_dwLastRequestTime;
-#endif
-
-#if defined(__ELEMENTAL_DUNGEON__)
-public:
-	void StartElementalCurseEvent();
-	void StopElementalCurseEvent();
-
-	void SetAccumulatedDamage(DWORD dwDamage);
-	DWORD GetAccumulatedDamage() const { return m_dwAccumulatedDamage; }
-
-private:
-	LPEVENT m_pElementalCurseEvent;
-	DWORD m_dwAccumulatedDamage;
-#endif
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-public:
-	void SetGuildDragonLair(CGuildDragonLair* pGuildDragonLair);
-	CGuildDragonLair* GetGuildDragonLair() const { return m_pGuildDragonLair; }
-private:
-	CGuildDragonLair* m_pGuildDragonLair;
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-public:
-	void SetMiniGameRoulette(CMiniGameRoulette* pMiniGameRoulette);
-	CMiniGameRoulette* GetMiniGameRoulette() const { return m_pMiniGameRoulette; }
-
-	void SetMiniGameRoulette_RewardMapperNum(BYTE bMapNum) { m_bMiniGameRoulette_RewardMapperNum = bMapNum; }
-	BYTE GetMiniGameRoulette_RewardMapperNum() const { return m_bMiniGameRoulette_RewardMapperNum; }
-
-private:
-	CMiniGameRoulette* m_pMiniGameRoulette;
-	BYTE m_bMiniGameRoulette_RewardMapperNum;
-#endif
-
-#if defined(__FLOWER_EVENT__)
-public:
-	void SetLastFlowerEventExchangePulse(DWORD dwPulse) { m_dwLastFlowerEventExchangePulse = dwPulse; }
-	DWORD GetLastFlowerEventExchangePulse() const { return m_dwLastFlowerEventExchangePulse; }
-private:
-	DWORD m_dwLastFlowerEventExchangePulse;
-#endif
-
-#if defined(__DEFENSE_WAVE__)
-public:
-	void SetDefenseWave(LPDEFENSE_WAVE pDefenseWave);
-	LPDEFENSE_WAVE GetDefenseWave() const;
-private:
-	LPDEFENSE_WAVE m_pDefenseWave;
-#endif
-
-#ifdef ENABLE_QUEEN_NETHIS
-public:
-	bool IsSnakeMap();
-#endif
-#ifdef __OFFLINE_SHOP__
-private:
-	uint32_t keepingOfflineShop_;
-
-	std::set<uint32_t> viewingOfflineShops_;
-
-	bool isOpeningOfflineShop_;
-	CItem* offlineShopOpeningItem_;
-
-public:
-	void SetKeepingOfflineShop(uint32_t keepingOfflineShop);
-	uint32_t GetKeepingOfflineShop() const;
-
-	void AddViewingOfflineShop(uint32_t id);
-	bool IsViewingOfflineShop();
-	void RemoveViewingOfflineShop(uint32_t id);
-	void RemoveFromViewingOfflineShops();
-
-	bool UseItemOpenOfflineShop(CItem* item);
-	void SetOpeningOfflineShopState(bool isOpeningOfflineShop);
-	bool IsOpeningOfflineShop() const;
-	void SetOfflineShopOpeningItem(CItem* item);
-	CItem* GetOfflineShopOpeningItem() const;
-	bool IsAffectOfflineShopDecoration();
-	void WarpToShop(long x, long y, long mapIndex, BYTE channel);
-
-private:
-	std::map<std::string, int> m_protection_Time;
-
-public:
-	int GetProtectTime(const std::string& flagname) const;
-	void SetProtectTime(const std::string& flagname, int time);
-
-public:
-	void	AddToSellHistory(TMySellHistory newItem);
-	void	SaveSellHistory();
-	void	RequestSellHistory(BYTE bPage);
-	void	SetSellHistoryLoaded(BYTE bStatus) {  m_bSellHistoryLoaded = bStatus; }
-	BYTE	GetSellHistoryLoaded() { return m_bSellHistoryLoaded; }
-protected:
-	BYTE	m_bSellHistoryLoaded;
-	std::vector<TMySellHistory> m_vecSellHistory;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-typedef std::list<TPlayerExtBattlePassMission*> ListExtBattlePassMap;
-public:
-	void LoadExtBattlePass(DWORD dwCount, TPlayerExtBattlePassMission* data);
-	DWORD GetExtBattlePassMissionProgress(DWORD dwBattlePassType, BYTE bMissionIndex, BYTE bMissionType);
-	bool IsExtBattlePassCompletedMission(DWORD dwBattlePassType, BYTE bMissionIndex, BYTE bMissionType);
-	bool IsExtBattlePassRegistered(BYTE bBattlePassType, DWORD dwBattlePassID);
-	void UpdateExtBattlePassMissionProgress(DWORD dwMissionID, DWORD dwUpdateValue, DWORD dwCondition, bool isOverride = false);
-	void SetExtBattlePassMissionProgress(BYTE bBattlePassType, DWORD dwMissionIndex, DWORD dwMissionType, DWORD dwUpdateValue);
-	
-	bool		IsLoadedExtBattlePass()		const	{ return m_bIsLoadedExtBattlePass; }
-	int			GetExtBattlePassPremiumID()	const	{ return m_points.battle_pass_premium_id;	}
-	void		SetExtBattlePassPremiumID(int battle_pass_premium_id)	{ m_points.battle_pass_premium_id = battle_pass_premium_id;}
-
-	void				SetLastReciveExtBattlePassInfoTime(DWORD time);
-	DWORD			GetLastReciveExtBattlePassInfoTime() const	{ return m_dwLastReciveExtBattlePassInfoTime; }
-	void				SetLastReciveExtBattlePassOpenRanking(DWORD time);
-	DWORD			GetLastReciveExtBattlePassOpenRanking() const	{ return m_dwLastExtBattlePassOpenRankingTime; }
-protected:
-	DWORD	m_dwLastReciveExtBattlePassInfoTime;
-	DWORD	m_dwLastExtBattlePassOpenRankingTime;
-	
-private:
-	bool m_bIsLoadedExtBattlePass;
-	ListExtBattlePassMap m_listExtBattlePass;
-#endif
-};
-
-ESex GET_SEX(LPCHARACTER ch);
-
-#endif // __INC_CHAR_H__
+#ifndef __INC_CHAR_H__
+#define __INC_CHAR_H__
+
+#include "../../common/stl.h"
+#include "entity.h"
+#include "FSM.h"
+#include "horse_rider.h"
+#include "vid.h"
+#include "constants.h"
+#include "affect.h"
+#include "affect_flag.h"
+#include "cube.h"
+#include "mining.h"
+#include "packet.h"
+
+#if defined(__LUCKY_BOX__)
+#	include "item_manager.h"
+#endif
+#if defined(__CHANGE_LOOK_SYSTEM__)
+#	include "changelook.h"
+#endif
+#if defined(__MAILBOX__)
+#	include "MailBox.h"
+#endif
+#if defined(__GEM_SHOP__)
+#	include "GemShop.h"
+#endif
+#if defined(__RANKING_SYSTEM__)
+#	include "Ranking.h"
+#endif
+#if defined(__MINI_GAME_RUMI__)
+#	include "minigame_rumi.h"
+#endif
+#if defined(__MINI_GAME_YUTNORI__)
+#	include "minigame_yutnori.h"
+#endif
+#if defined(__MINI_GAME_CATCH_KING__)
+#	include "minigame_catchking.h"
+#endif
+#if defined(__FLOWER_EVENT__)
+#	include "flower_event.h"
+#endif
+#if defined(__SUMMER_EVENT_ROULETTE__)
+#	include "minigame_roulette.h"
+#endif
+#if defined(__INGAME_EVENT_MANAGER__)
+#	include "ingame_event_manager.h"
+#endif
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+#	include "guild_dragonlair.h"
+#endif
+
+class CBuffOnAttributes;
+class CPetSystem;
+#if defined(__LOOT_FILTER_SYSTEM__)
+class CLootFilter;
+#endif
+#ifdef __OFFLINE_SHOP__
+class COfflineShop;
+#endif
+
+#define INSTANT_FLAG_DEATH_PENALTY (1 << 0)
+#define INSTANT_FLAG_SHOP (1 << 1)
+#define INSTANT_FLAG_EXCHANGE (1 << 2)
+#define INSTANT_FLAG_STUN (1 << 3)
+#define INSTANT_FLAG_NO_REWARD (1 << 4)
+
+#define AI_FLAG_NPC (1 << 0)
+#define AI_FLAG_AGGRESSIVE (1 << 1)
+#define AI_FLAG_HELPER (1 << 2)
+#define AI_FLAG_STAYZONE (1 << 3)
+
+#define SET_OVER_TIME(ch, time) (ch)->SetOverTime(time)
+
+#ifdef __GROWTH_PET_SYSTEM__
+#include "growth_pet.h"
+#endif
+extern int g_nPortalLimitTime;
+
+extern bool IS_SUMMON_ITEM(LPITEM item, int map_index = 0);
+extern bool IS_SUMMONABLE_ZONE(int map_index);
+
+extern bool IS_MONKEY_DUNGEON(int map_index);
+extern bool IS_MAZE_DUNGEON(int map_index);
+
+#if defined(__SNOW_DUNGEON__)
+extern bool IS_SNOW_DUNGEON(int map_index);
+#endif
+
+#if defined(__ELEMENTAL_DUNGEON__)
+extern bool IS_ELEMENTAL_DUNGEON(int map_index);
+#endif
+
+extern bool CAN_ENTER_ZONE(const LPCHARACTER& ch, int map_index);
+extern bool IS_BLOCKED_PET(int map_index); // char.cpp
+extern bool IS_BLOCKED_PET_DUNGEON_MAP(int map_index);
+
+enum
+{
+	MAIN_RACE_WARRIOR_M,
+	MAIN_RACE_ASSASSIN_W,
+	MAIN_RACE_SURA_M,
+	MAIN_RACE_SHAMAN_W,
+	MAIN_RACE_WARRIOR_W,
+	MAIN_RACE_ASSASSIN_M,
+	MAIN_RACE_SURA_W,
+	MAIN_RACE_SHAMAN_M,
+	MAIN_RACE_WOLFMAN_M,
+	MAIN_RACE_MAX_NUM,
+};
+
+enum
+{
+	POISON_LENGTH = 30,
+	BLEEDING_LENGTH = 30,
+	STAMINA_PER_STEP = 1,
+	SAFEBOX_PAGE_SIZE = 9,
+	AI_CHANGE_ATTACK_POISITION_TIME_NEAR = 10000,
+	AI_CHANGE_ATTACK_POISITION_TIME_FAR = 1000,
+	AI_CHANGE_ATTACK_POISITION_DISTANCE = 100,
+	SUMMON_MONSTER_COUNT = 3,
+};
+
+enum
+{
+	FLY_NONE,
+	FLY_EXP,
+	FLY_HP_MEDIUM,
+	FLY_HP_BIG,
+	FLY_SP_SMALL,
+	FLY_SP_MEDIUM,
+	FLY_SP_BIG,
+	FLY_FIREWORK1,
+	FLY_FIREWORK2,
+	FLY_FIREWORK3,
+	FLY_FIREWORK4,
+	FLY_FIREWORK5,
+	FLY_FIREWORK6,
+	FLY_FIREWORK_CHRISTMAS,
+	FLY_CHAIN_LIGHTNING,
+	FLY_HP_SMALL,
+	FLY_SKILL_MUYEONG,
+#if defined(__QUIVER_SYSTEM__)
+	FLY_QUIVER_ATTACK_NORMAL,
+#endif
+#if defined(__CONQUEROR_LEVEL__)
+	FLY_ILGWANGPYO_NORMAL,
+	FLY_ILGWANGPYO_MASTER,
+	FLY_ILGWANGPYO_GRAND_MASTER,
+	FLY_ILGWANGPYO_PERFECT_MASTER,
+	FLY_CONQUEROR_EXP,
+#endif
+};
+
+enum EDamageType
+{
+	DAMAGE_TYPE_NONE,
+	DAMAGE_TYPE_NORMAL,
+	DAMAGE_TYPE_NORMAL_RANGE,
+	// Å³
+	DAMAGE_TYPE_MELEE,
+	DAMAGE_TYPE_RANGE,
+	DAMAGE_TYPE_FIRE,
+	DAMAGE_TYPE_ICE,
+	DAMAGE_TYPE_ELEC,
+	DAMAGE_TYPE_MAGIC,
+	DAMAGE_TYPE_POISON,
+	DAMAGE_TYPE_SPECIAL,
+	DAMAGE_TYPE_BLEEDING,
+};
+
+enum DamageFlag
+{
+	DAMAGE_NORMAL = (1 << 0),
+	DAMAGE_POISON = (1 << 1),
+	DAMAGE_DODGE = (1 << 2),
+	DAMAGE_BLOCK = (1 << 3),
+	DAMAGE_PENETRATE = (1 << 4),
+	DAMAGE_CRITICAL = (1 << 5),
+	DAMAGE_BLEEDING = (1 << 6),
+};
+
+enum EPKModes
+{
+	PK_MODE_PEACE,
+	PK_MODE_REVENGE,
+	PK_MODE_FREE,
+	PK_MODE_PROTECT,
+	PK_MODE_GUILD,
+	PK_MODE_MAX_NUM
+};
+
+enum EPositions
+{
+	POS_DEAD,
+	POS_SLEEPING,
+	POS_RESTING,
+	POS_SITTING,
+	POS_FISHING,
+	POS_FIGHTING,
+	POS_MOUNTING,
+	POS_STANDING
+};
+
+enum EBlockAction
+{
+	BLOCK_EXCHANGE = (1 << 0),
+	BLOCK_PARTY_INVITE = (1 << 1),
+	BLOCK_GUILD_INVITE = (1 << 2),
+	BLOCK_WHISPER = (1 << 3),
+	BLOCK_MESSENGER_INVITE = (1 << 4),
+	BLOCK_PARTY_REQUEST = (1 << 5),
+};
+
+#ifdef __OFFLINE_SHOP__
+enum EUnlockShopSkin
+{
+	UNLOCK_SHOP_SKIN_1 = (1 << 0),
+	UNLOCK_SHOP_SKIN_2 = (1 << 1),
+	UNLOCK_SHOP_SKIN_3 = (1 << 2),
+	UNLOCK_SHOP_SKIN_4 = (1 << 3),
+	UNLOCK_SHOP_SKIN_5 = (1 << 4),
+	UNLOCK_SHOP_SKIN_6 = (1 << 5),
+	UNLOCK_SHOP_SKIN_7 = (1 << 6),
+	UNLOCK_SHOP_SKIN_8 = (1 << 7),
+};
+
+enum EUnlockShopBanner
+{
+	UNLOCK_SHOP_BANNER_1 = (1 << 0),
+	UNLOCK_SHOP_BANNER_2 = (1 << 1),
+	UNLOCK_SHOP_BANNER_3 = (1 << 2),
+	UNLOCK_SHOP_BANNER_4 = (1 << 3),
+	UNLOCK_SHOP_BANNER_5 = (1 << 4),
+};
+#endif
+
+enum EAlignmentGrade
+{
+	ALIGN_GRADE_GOOD_4,
+	ALIGN_GRADE_GOOD_3,
+	ALIGN_GRADE_GOOD_2,
+	ALIGN_GRADE_GOOD_1,
+	ALIGN_GRADE_NORMAL,
+	ALIGN_GRADE_EVIL_1,
+	ALIGN_GRADE_EVIL_2,
+	ALIGN_GRADE_EVIL_3,
+	ALIGN_GRADE_EVIL_4,
+};
+
+enum EPointTypes
+{
+	POINT_NONE,								// 0
+	POINT_LEVEL,							// 1
+	POINT_VOICE,							// 2
+	POINT_EXP,								// 3
+	POINT_NEXT_EXP,							// 4
+	POINT_HP,								// 5
+	POINT_MAX_HP,							// 6
+	POINT_SP,								// 7
+	POINT_MAX_SP,							// 8
+	POINT_STAMINA,							// 9 ×¹Ì³
+	POINT_MAX_STAMINA,						// 10 Ö´ ×¹Ì³
+
+	POINT_GOLD,								// 11
+	POINT_ST,								// 12 Ù·
+	POINT_HT,								// 13 Ã¼
+	POINT_DX,								// 14 Ã¸
+	POINT_IQ,								// 15 Å·
+	POINT_DEF_GRADE,						// 16 ...
+	POINT_ATT_SPEED,						// 17 Ý¼Óµ
+	POINT_ATT_GRADE,						// 18 Ý· MAX
+	POINT_MOV_SPEED,						// 19 ÌµÓµ
+	POINT_CLIENT_DEF_GRADE,					// 20 
+	POINT_CASTING_SPEED,					// 21 Ö¹Óµ (Ù¿Å¸*100) / (100 + Ì°) =  Ù¿ Å¸
+	POINT_MAGIC_ATT_GRADE,					// 22 Ý·
+	POINT_MAGIC_DEF_GRADE,					// 23 
+	POINT_EMPIRE_POINT,						// 24 
+	POINT_LEVEL_STEP,						// 25   Ü°.. (1 2 3   , 4 Ç¸  )
+	POINT_STAT,								// 26 É·Ä¡ Ã¸  Ö´ 
+	POINT_SUB_SKILL,						// 27  Å³ Æ®
+	POINT_SKILL,							// 28 Æ¼ Å³ Æ®
+	POINT_WEAPON_MIN,						// 29  Ö¼ 
+	POINT_WEAPON_MAX,						// 30  Ö´ 
+	POINT_PLAYTIME,							// 31 Ã·Ì½Ã°
+	POINT_HP_REGEN,							// 32 HP È¸
+	POINT_SP_REGEN,							// 33 SP È¸
+
+	POINT_BOW_DISTANCE,						// 34 È° Å¸ Ä¡ (meter)
+
+	POINT_HP_RECOVERY,						// 35 Ã¼ È¸ 
+	POINT_SP_RECOVERY,						// 36 Å· È¸ 
+
+	POINT_POISON_PCT,						// 37  È®
+	POINT_STUN_PCT,							// 38  È®
+	POINT_SLOW_PCT,							// 39 Î¿ È®
+	POINT_CRITICAL_PCT,						// 40 Å©Æ¼ È®
+	POINT_PENETRATE_PCT,					// 41 Å¸ È®
+	POINT_CURSE_PCT,						// 42  È®
+
+	POINT_ATTBONUS_HUMAN,					// 43 Î° 
+	POINT_ATTBONUS_ANIMAL,					// 44   % 
+	POINT_ATTBONUS_ORC,						// 45 Í¿  % 
+	POINT_ATTBONUS_MILGYO,					// 46 Ð±  % 
+	POINT_ATTBONUS_UNDEAD,					// 47 Ã¼  % 
+	POINT_ATTBONUS_DEVIL,					// 48 (Ç¸)  % 
+	POINT_ATTBONUS_INSECT,					// 49 
+	POINT_ATTBONUS_FIRE,					// 50 È­
+	POINT_ATTBONUS_ICE,						// 51 
+	POINT_ATTBONUS_DESERT,					// 52 ç¸·
+	POINT_ATTBONUS_MONSTER,					// 53  Í¿ 
+	POINT_ATTBONUS_WARRIOR,					// 54 ç¿¡ 
+	POINT_ATTBONUS_ASSASSIN,				// 55 Ú° 
+	POINT_ATTBONUS_SURA,					// 56 ó¿¡° 
+	POINT_ATTBONUS_SHAMAN,					// 57 ç¿¡ 
+	POINT_ATTBONUS_TREE,					// 58   20050729.myevan UNUSED5
+
+	POINT_RESIST_WARRIOR,					// 59 ç¿¡ 
+	POINT_RESIST_ASSASSIN,					// 60 Ú° 
+	POINT_RESIST_SURA,						// 61 ó¿¡° 
+	POINT_RESIST_SHAMAN,					// 62 ç¿¡ 
+
+	POINT_STEAL_HP,							// 63  
+	POINT_STEAL_SP,							// 64 Å· 
+
+	POINT_MANA_BURN_PCT,					// 65  
+
+	/// Ø½ Ê½ ///
+
+	POINT_DAMAGE_SP_RECOVER,				// 66 Ý´  Å· È¸ È®
+
+	POINT_BLOCK,							// 67 
+	POINT_DODGE,							// 68 È¸
+
+	POINT_RESIST_SWORD,						// 69
+	POINT_RESIST_TWOHAND,					// 70
+	POINT_RESIST_DAGGER,					// 71
+	POINT_RESIST_BELL,						// 72
+	POINT_RESIST_FAN,						// 73
+	POINT_RESIST_BOW,						// 74 È­  :  
+	POINT_RESIST_FIRE,						// 75 È­  : È­Ý¿   
+	POINT_RESIST_ELEC,						// 76   : Ý¿   
+	POINT_RESIST_MAGIC,						// 77   :    
+	POINT_RESIST_WIND,						// 78 Ù¶  : Ù¶Ý¿   
+
+	POINT_REFLECT_MELEE,					// 79  Ý»
+
+	/// Æ¯ Ø½ ///
+	POINT_REFLECT_CURSE,					// 80  Ý»
+	POINT_POISON_REDUCE,					// 81  
+
+	///  Ò¸ ///
+	POINT_KILL_SP_RECOVER,					// 82  Ò¸ MP È¸
+	POINT_EXP_DOUBLE_BONUS,					// 83
+	POINT_GOLD_DOUBLE_BONUS,				// 84
+	POINT_ITEM_DROP_BONUS,					// 85
+
+	/// È¸  ///
+	POINT_POTION_BONUS,						// 86
+	POINT_KILL_HP_RECOVERY,					// 87
+
+	POINT_IMMUNE_STUN,						// 88
+	POINT_IMMUNE_SLOW,						// 89
+	POINT_IMMUNE_FALL,						// 90
+	//////////////////
+
+	POINT_PARTY_ATTACKER_BONUS,				// 91
+	POINT_PARTY_TANKER_BONUS,				// 92
+
+	POINT_ATT_BONUS,						// 93
+	POINT_DEF_BONUS,						// 94
+
+	POINT_ATT_GRADE_BONUS,					// 95
+	POINT_DEF_GRADE_BONUS,					// 96
+	POINT_MAGIC_ATT_GRADE_BONUS,			// 97
+	POINT_MAGIC_DEF_GRADE_BONUS,			// 98
+
+	POINT_RESIST_NORMAL_DAMAGE,				// 99
+
+	POINT_HIT_HP_RECOVERY,					// 100
+	POINT_HIT_SP_RECOVERY,					// 101
+	POINT_MANASHIELD,						// 102 Å¼È£ Å³   È¿ 
+
+	POINT_PARTY_BUFFER_BONUS,				// 103
+	POINT_PARTY_SKILL_MASTER_BONUS,			// 104
+
+	POINT_HP_RECOVER_CONTINUE,				// 105
+	POINT_SP_RECOVER_CONTINUE,				// 106
+
+	POINT_STEAL_GOLD,						// 107
+	POINT_POLYMORPH,						// 108   È£
+	POINT_MOUNT,							// 109 Å¸Ö´  È£
+
+	POINT_PARTY_HASTE_BONUS,				// 110
+	POINT_PARTY_DEFENDER_BONUS,				// 111
+	POINT_STAT_RESET_COUNT,					// 112  Ü¾     Æ® (1 1Æ® Â°)
+
+	POINT_HORSE_SKILL,						// 113
+
+	POINT_MALL_ATTBONUS,					// 114 Ý· +x%
+	POINT_MALL_DEFBONUS,					// 115  +x%
+	POINT_MALL_EXPBONUS,					// 116 Ä¡ +x%
+	POINT_MALL_ITEMBONUS,					// 117   x/10
+	POINT_MALL_GOLDBONUS,					// 118   x/10
+
+	POINT_MAX_HP_PCT,						// 119 Ö´ +x%
+	POINT_MAX_SP_PCT,						// 120 Ö´Å· +x%
+
+	POINT_SKILL_DAMAGE_BONUS,				// 121 Å³  *(100+x)%
+	POINT_NORMAL_HIT_DAMAGE_BONUS,			// 122 Å¸  *(100+x)%
+
+	// DEFEND_BONUS_ATTRIBUTES
+	POINT_SKILL_DEFEND_BONUS,				// 123 Å³  
+	POINT_NORMAL_HIT_DEFEND_BONUS,			// 124 Å¸  
+	// END_OF_DEFEND_BONUS_ATTRIBUTES
+
+	// PC_BANG_ITEM_ADD 
+	POINT_PC_BANG_EXP_BONUS,				// 125 PC  Ä¡ Ê½
+	POINT_PC_BANG_DROP_BONUS,				// 126 PC  Ó· Ê½
+	// END_PC_BANG_ITEM_ADD
+	POINT_RAMADAN_CANDY_BONUS_EXP,			// 127 ó¸¶´  Ä¡ 
+
+	POINT_ENERGY = 128,						// 128 
+
+	//  ui .
+	//   Ê±â¸¸, Å¬Ì¾Æ®   Ã° POINT Ï±  Ì· Ñ´.
+	//  Î²
+	POINT_ENERGY_END_TIME = 129,			// 129   Ã°
+
+	POINT_COSTUME_ATTR_BONUS = 130,			// 130
+	POINT_MAGIC_ATT_BONUS_PER = 131,		// 131
+	POINT_MELEE_MAGIC_ATT_BONUS_PER = 132,	// 132
+
+	// ß° Ó¼ 
+	POINT_RESIST_ICE = 133,					// 133 Ã±  : Ý¿   
+	POINT_RESIST_EARTH = 134,				// 134   : Ý¿   
+	POINT_RESIST_DARK = 135,				// 135   : Ý¿   
+
+	POINT_RESIST_CRITICAL = 136,			// 136 Å©Æ¼  :  Å©Æ¼ È® 
+	POINT_RESIST_PENETRATE = 137,			// 137 Å¸  :  Å¸ È® 
+
+	POINT_BLEEDING_REDUCE = 138,			// 138
+	POINT_BLEEDING_PCT = 139,				// 139
+	POINT_ATTBONUS_WOLFMAN = 140,			// 140
+	POINT_RESIST_WOLFMAN = 141,				// 141
+	POINT_RESIST_CLAW = 142,				// 142
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	POINT_ACCEDRAIN_RATE,
+#endif
+#if defined(__MAGIC_REDUCTION__)
+	POINT_RESIST_MAGIC_REDUCTION,
+#endif
+#if defined(__CHEQUE_SYSTEM__)
+	POINT_CHEQUE,
+#endif
+	POINT_BATTLE_POINT,
+	POINT_RESIST_HUMAN,
+	POINT_ENCHANT_ELECT,
+	POINT_ENCHANT_FIRE,
+	POINT_ENCHANT_ICE,
+	POINT_ENCHANT_WIND,
+	POINT_ENCHANT_EARTH,
+	POINT_ENCHANT_DARK,
+	POINT_ATTBONUS_CZ,
+	POINT_BEAD,
+#if defined(__GEM_SYSTEM__)
+	POINT_GEM,
+#endif
+	POINT_ATTBONUS_SWORD,
+	POINT_ATTBONUS_TWOHAND,
+	POINT_ATTBONUS_DAGGER,
+	POINT_ATTBONUS_BELL,
+	POINT_ATTBONUS_FAN,
+	POINT_ATTBONUS_BOW,
+	POINT_ATTBONUS_CLAW,
+	POINT_RESIST_MOUNT_FALL,
+	POINT_RESIST_FIST,
+	POINT_PREMIUM_EXPBONUS,
+	POINT_PRIVILEGE_EXPBONUS,
+	POINT_MARRIAGE_EXPBONUS,
+	POINT_DEVILTOWER_EXPBONUS,
+	POINT_PREMIUM_ITEMBONUS,
+	POINT_PRIVILEGE_ITEMBONUS,
+	POINT_PREMIUM_GOLDBONUS,
+	POINT_PRIVILEGE_GOLDBONUS,
+	POINT_SKILL_DAMAGE_SAMYEON,
+	POINT_SKILL_DAMAGE_TANHWAN,
+	POINT_SKILL_DAMAGE_PALBANG,
+	POINT_SKILL_DAMAGE_GIGONGCHAM,
+	POINT_SKILL_DAMAGE_GYOKSAN,
+	POINT_SKILL_DAMAGE_GEOMPUNG,
+	POINT_SKILL_DAMAGE_AMSEOP,
+	POINT_SKILL_DAMAGE_GUNGSIN,
+	POINT_SKILL_DAMAGE_CHARYUN,
+	POINT_SKILL_DAMAGE_SANGONG,
+	POINT_SKILL_DAMAGE_YEONSA,
+	POINT_SKILL_DAMAGE_KWANKYEOK,
+	POINT_SKILL_DAMAGE_GIGUNG,
+	POINT_SKILL_DAMAGE_HWAJO,
+	POINT_SKILL_DAMAGE_SWAERYUNG,
+	POINT_SKILL_DAMAGE_YONGKWON,
+	POINT_SKILL_DAMAGE_PABEOB,
+	POINT_SKILL_DAMAGE_MARYUNG,
+	POINT_SKILL_DAMAGE_HWAYEOMPOK,
+	POINT_SKILL_DAMAGE_MAHWAN,
+	POINT_SKILL_DAMAGE_BIPABU,
+	POINT_SKILL_DAMAGE_YONGBI,
+	POINT_SKILL_DAMAGE_PAERYONG,
+	POINT_SKILL_DAMAGE_NOEJEON,
+	POINT_SKILL_DAMAGE_BYEURAK,
+	POINT_SKILL_DAMAGE_CHAIN,
+	POINT_SKILL_DAMAGE_CHAYEOL,
+	POINT_SKILL_DAMAGE_SALPOONG,
+	POINT_SKILL_DAMAGE_GONGDAB,
+	POINT_SKILL_DAMAGE_PASWAE,
+	POINT_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE,
+	POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE,
+	POINT_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE,
+	POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE,
+	POINT_HIT_BUFF_ENCHANT_FIRE,
+	POINT_HIT_BUFF_ENCHANT_ICE,
+	POINT_HIT_BUFF_ENCHANT_ELEC,
+	POINT_HIT_BUFF_ENCHANT_WIND,
+	POINT_HIT_BUFF_ENCHANT_DARK,
+	POINT_HIT_BUFF_ENCHANT_EARTH,
+	POINT_HIT_BUFF_RESIST_FIRE,
+	POINT_HIT_BUFF_RESIST_ICE,
+	POINT_HIT_BUFF_RESIST_ELEC,
+	POINT_HIT_BUFF_RESIST_WIND,
+	POINT_HIT_BUFF_RESIST_DARK,
+	POINT_HIT_BUFF_RESIST_EARTH,
+	POINT_USE_SKILL_CHEONGRANG_MOV_SPEED,
+	POINT_USE_SKILL_CHEONGRANG_CASTING_SPEED,
+	POINT_USE_SKILL_CHAYEOL_CRITICAL_PCT,
+	POINT_USE_SKILL_SANGONG_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_GIGUNG_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_JEOKRANG_DEF_BONUS,
+	POINT_USE_SKILL_GWIGEOM_DEF_BONUS,
+	POINT_USE_SKILL_TERROR_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_MUYEONG_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_MANASHILED_CASTING_SPEED,
+	POINT_USE_SKILL_HOSIN_DEF_BONUS,
+	POINT_USE_SKILL_GICHEON_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_JEUNGRYEOK_DEF_BONUS,
+	POINT_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_CHUNKEON_CASTING_SPEED,
+	POINT_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS,
+	POINT_SKILL_DURATION_INCREASE_EUNHYUNG,
+	POINT_SKILL_DURATION_INCREASE_GYEONGGONG,
+	POINT_SKILL_DURATION_INCREASE_GEOMKYUNG,
+	POINT_SKILL_DURATION_INCREASE_JEOKRANG,
+	POINT_USE_SKILL_PALBANG_HP_ABSORB,
+	POINT_USE_SKILL_AMSEOP_HP_ABSORB,
+	POINT_USE_SKILL_YEONSA_HP_ABSORB,
+	POINT_USE_SKILL_YONGBI_HP_ABSORB,
+	POINT_USE_SKILL_CHAIN_HP_ABSORB,
+	POINT_USE_SKILL_PASWAE_SP_ABSORB,
+	POINT_USE_SKILL_GIGONGCHAM_STUN,
+	POINT_USE_SKILL_CHARYUN_STUN,
+	POINT_USE_SKILL_PABEOB_STUN,
+	POINT_USE_SKILL_MAHWAN_STUN,
+	POINT_USE_SKILL_GONGDAB_STUN,
+	POINT_USE_SKILL_SAMYEON_STUN,
+	POINT_USE_SKILL_GYOKSAN_KNOCKBACK,
+	POINT_USE_SKILL_SEOMJEON_KNOCKBACK,
+	POINT_USE_SKILL_SWAERYUNG_KNOCKBACK,
+	POINT_USE_SKILL_HWAYEOMPOK_KNOCKBACK,
+	POINT_USE_SKILL_GONGDAB_KNOCKBACK,
+	POINT_USE_SKILL_KWANKYEOK_KNOCKBACK,
+	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_ATTBONUS_STONE,
+	POINT_DAMAGE_HP_RECOVERY,
+	POINT_DAMAGE_SP_RECOVERY,
+	POINT_ALIGNMENT_DAMAGE_BONUS,
+	POINT_NORMAL_DAMAGE_GUARD,
+	POINT_MORE_THEN_HP90_DAMAGE_REDUCE,
+	POINT_USE_SKILL_TUSOK_HP_ABSORB,
+	POINT_USE_SKILL_PAERYONG_HP_ABSORB,
+	POINT_USE_SKILL_BYEURAK_HP_ABSORB,
+	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_CHAYEOL_HP_ABSORB,
+	POINT_MEDAL_OF_HONOR,
+	POINT_ALL_STAT_BONUS,
+	POINT_SUNGMA_STR,
+	POINT_SUNGMA_HP,
+	POINT_SUNGMA_MOVE,
+	POINT_SUNGMA_IMMUNE,
+	POINT_CONQUEROR_LEVEL,
+	POINT_CONQUEROR_LEVEL_STEP,
+	POINT_CONQUEROR_EXP,
+	POINT_CONQUEROR_NEXT_EXP,
+	POINT_CONQUEROR_POINT,
+	POINT_HIT_PCT,
+	POINT_ATTBONUS_PER_HUMAN,
+	POINT_ATTBONUS_PER_ANIMAL,
+	POINT_ATTBONUS_PER_ORC,
+	POINT_ATTBONUS_PER_MILGYO,
+	POINT_ATTBONUS_PER_UNDEAD,
+	POINT_ATTBONUS_PER_DEVIL,
+	POINT_ENCHANT_PER_ELECT,
+	POINT_ENCHANT_PER_FIRE,
+	POINT_ENCHANT_PER_ICE,
+	POINT_ENCHANT_PER_WIND,
+	POINT_ENCHANT_PER_EARTH,
+	POINT_ENCHANT_PER_DARK,
+	POINT_ATTBONUS_PER_CZ,
+	POINT_ATTBONUS_PER_INSECT,
+	POINT_ATTBONUS_PER_DESERT,
+	POINT_ATTBONUS_PER_STONE,
+	POINT_ATTBONUS_PER_MONSTER,
+	POINT_RESIST_PER_HUMAN,
+	POINT_RESIST_PER_ICE,
+	POINT_RESIST_PER_DARK,
+	POINT_RESIST_PER_EARTH,
+	POINT_RESIST_PER_FIRE,
+	POINT_RESIST_PER_ELEC,
+	POINT_RESIST_PER_MAGIC,
+	POINT_RESIST_PER_WIND,
+	POINT_HIT_BUFF_SUNGMA_STR,
+	POINT_HIT_BUFF_SUNGMA_MOVE,
+	POINT_HIT_BUFF_SUNGMA_HP,
+	POINT_HIT_BUFF_SUNGMA_IMMUNE,
+	POINT_MOUNT_MELEE_MAGIC_ATTBONUS_PER,
+	POINT_DISMOUNT_MOVE_SPEED_BONUS_PER,
+	POINT_HIT_AUTO_HP_RECOVERY,
+	POINT_HIT_AUTO_SP_RECOVERY,
+	POINT_USE_SKILL_COOLTIME_DECREASE_ALL,
+	POINT_HIT_STONE_ATTBONUS_STONE,
+	POINT_HIT_STONE_DEF_GRADE_BONUS,
+	POINT_KILL_BOSS_ITEM_BONUS,
+	POINT_MOB_HIT_MOB_AGGRESSIVE,
+	POINT_NO_DEATH_AND_HP_RECOVERY30,
+	POINT_AUTO_PICKUP,
+	POINT_MOUNT_NO_KNOCKBACK,
+	POINT_SUNGMA_PER_STR,
+	POINT_SUNGMA_PER_HP,
+	POINT_SUNGMA_PER_MOVE,
+	POINT_SUNGMA_PER_IMMUNE,
+	POINT_IMMUNE_POISON100,
+	POINT_IMMUNE_BLEEDING100,
+	POINT_MONSTER_DEFEND_BONUS,
+
+	// Å¬Ì¾Æ® Æ®
+	POINT_MIN_WEP,
+	POINT_MAX_WEP,
+	POINT_MIN_MAGIC_WEP,
+	POINT_MAX_MAGIC_WEP,
+	POINT_HIT_RATE,
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	POINT_BATTLE_PASS_PREMIUM_ID
+#endif
+};
+
+// <Factor> Dynamically evaluated CHARACTER* equivalent.
+// Referring to SCharDeadEventInfo.
+struct DynamicCharacterPtr
+{
+	DynamicCharacterPtr() : is_pc(false), id(0) {}
+	DynamicCharacterPtr(const DynamicCharacterPtr& o)
+		: is_pc(o.is_pc), id(o.id) {}
+
+	// Returns the LPCHARACTER found in CHARACTER_MANAGER.
+	LPCHARACTER Get() const;
+	// Clears the current settings.
+	void Reset()
+	{
+		is_pc = false;
+		id = 0;
+	}
+
+	// Basic assignment operator.
+	DynamicCharacterPtr& operator=(const DynamicCharacterPtr& rhs)
+	{
+		is_pc = rhs.is_pc;
+		id = rhs.id;
+		return *this;
+	}
+	// Supports assignment with LPCHARACTER type.
+	DynamicCharacterPtr& operator=(LPCHARACTER character);
+	// Supports type casting to LPCHARACTER.
+	operator LPCHARACTER() const
+	{
+		return Get();
+	}
+
+	bool is_pc;
+	uint32_t id;
+};
+
+/* Ï´  */
+typedef struct character_point
+{
+	POINT_VALUE lPoints[POINT_MAX_NUM];
+
+	BYTE bJob;
+	BYTE bVoice;
+
+	BYTE bLevel;
+	DWORD dwExp;
+
+#if defined(__CONQUEROR_LEVEL__)
+	BYTE bConquerorLevel;
+	DWORD dwConquerorExp;
+#endif
+
+	int iGold;
+#if defined(__CHEQUE_SYSTEM__)
+	int iCheque;
+#endif
+#if defined(__GEM_SYSTEM__)
+	int iGem;
+#endif
+
+	int iHP, iSP;
+	int iRandomHP, iRandomSP;
+	int iStamina;
+
+	BYTE bSkillGroup;
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	int battle_pass_premium_id;
+#endif
+} CHARACTER_POINT;
+
+/*  Ê´ Ä³  */
+typedef struct character_point_instant
+{
+	POINT_VALUE points[POINT_MAX_NUM];
+
+	float fRot;
+
+	int iMaxHP;
+	int iMaxSP;
+
+	long position;
+
+	long instant_flag;
+	DWORD dwAIFlag;
+	DWORD dwImmuneFlag;
+	DWORD dwLastShoutPulse;
+
+	DWORD adwParts[PART_MAX_NUM];
+
+	LPITEM pInventoryItems[INVENTORY_MAX_NUM];
+	WORD wInventoryItemGrid[INVENTORY_MAX_NUM];
+
+	LPITEM pEquipmentItems[EQUIPMENT_MAX_NUM];
+	BYTE bEquipmentItemGrid[EQUIPMENT_MAX_NUM];
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	// È¥ Îºä¸®.
+	LPITEM pDragonSoulInventoryItems[DRAGON_SOUL_INVENTORY_MAX_NUM];
+	WORD wDragonSoulInventoryItemGrid[DRAGON_SOUL_INVENTORY_MAX_NUM];
+#endif
+
+	LPITEM pBeltInventoryItems[BELT_INVENTORY_MAX_NUM];
+	BYTE bBeltInventoryItemGrid[BELT_INVENTORY_MAX_NUM];
+
+#if !defined(__CUBE_RENEWAL__)
+	// by mhh
+	LPITEM pCubeItems[CUBE_MAX_NUM];
+#endif
+	LPCHARACTER pCubeNpc;
+#if defined(__MOVE_COSTUME_ATTR__)
+	LPCHARACTER pItemCombNpc;
+#endif
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	LPCHARACTER pRouletteNPC;
+#endif
+#if defined(__ATTR_6TH_7TH__)
+	LPITEM pNPCStorageItems;
+#endif
+
+	BYTE gm_level;
+
+	BYTE bBasePart; //  È£
+
+	int iMaxStamina;
+
+	BYTE bBlockMode;
+#ifdef __OFFLINE_SHOP__
+	BYTE bUnlockedShopSkin;
+	BYTE bUnlockedShopBanner;
+#endif
+	int iDragonSoulActiveDeck;
+	LPENTITY m_pDragonSoulRefineWindowOpener;
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	LPENTITY m_pAcceRefineWindowOpener;
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	LPENTITY m_pAuraRefineWindowOpener;
+#endif
+} CHARACTER_POINT_INSTANT;
+
+#define TRIGGERPARAM LPCHARACTER ch, LPCHARACTER causer
+
+typedef struct trigger
+{
+	BYTE type;
+	int (*func) (TRIGGERPARAM);
+	long value;
+} TRIGGER;
+
+class CTrigger
+{
+public:
+	CTrigger() : bType(0), pFunc(NULL)
+	{
+	}
+
+	BYTE bType;
+	int (*pFunc) (TRIGGERPARAM);
+};
+
+EVENTINFO(char_event_info)
+{
+	DynamicCharacterPtr ch;
+};
+
+struct TSkillUseInfo
+{
+	int iHitCount;
+	int iMaxHitCount;
+	int iSplashCount;
+	DWORD dwNextSkillUsableTime;
+	int iRange;
+	bool bUsed;
+	DWORD dwVID;
+	bool isGrandMaster;
+
+	std::unordered_map<DWORD, std::size_t> TargetVIDMap;
+
+	TSkillUseInfo()
+		: iHitCount(0), iMaxHitCount(0), iSplashCount(0), dwNextSkillUsableTime(0), iRange(0), bUsed(false),
+		dwVID(0), isGrandMaster(false)
+	{}
+
+	bool HitOnce(DWORD dwVnum = 0);
+
+	bool UseSkill(bool isGrandMaster, DWORD vid, DWORD dwCooltime, int splashcount = 1, int hitcount = -1, int range = -1);
+	DWORD GetMainTargetVID() const { return dwVID; }
+	void SetMainTargetVID(DWORD vid) { dwVID = vid; }
+	void ResetHitCount() { if (iSplashCount) { iHitCount = iMaxHitCount; iSplashCount--; } }
+};
+
+typedef struct packet_party_update TPacketGCPartyUpdate;
+class CExchange;
+class CSkillProto;
+class CParty;
+class CDungeon;
+#if defined(__DEFENSE_WAVE__)
+class CDefenseWave;
+#endif
+class CWarMap;
+class CAffect;
+class CGuild;
+class CSafebox;
+class CArena;
+
+class CShop;
+typedef class CShop* LPSHOP;
+
+class CMob;
+class CMobInstance;
+typedef struct SMobSkillInfo TMobSkillInfo;
+
+// SKILL_POWER_BY_LEVEL
+extern int GetSkillPowerByLevelFromType(int job, int skillgroup, int skilllevel);
+// END_SKILL_POWER_BY_LEVEL
+
+namespace marriage
+{
+	class WeddingMap;
+}
+enum e_overtime
+{
+	OT_NONE,
+	OT_3HOUR,
+	OT_5HOUR,
+};
+
+typedef std::list<CAffect*> AffectContainerList;
+typedef std::unordered_map<DWORD, BYTE> AffectStackMap;
+typedef std::map<int, LPEVENT> MobSkillEventMap;
+
+class CHARACTER : public CEntity, public CFSM, public CHorseRider
+{
+protected:
+	//////////////////////////////////////////////////////////////////////////////////
+	// Entity 
+	virtual void EncodeInsertPacket(LPENTITY entity);
+	virtual void EncodeRemovePacket(LPENTITY entity);
+	//////////////////////////////////////////////////////////////////////////////////
+
+public:
+	LPCHARACTER FindCharacterInView(const char* name, bool bFindPCOnly);
+	void UpdatePacket();
+
+	//////////////////////////////////////////////////////////////////////////////////
+	// FSM (Finite State Machine) 
+protected:
+	CStateTemplate<CHARACTER> m_stateMove;
+	CStateTemplate<CHARACTER> m_stateBattle;
+	CStateTemplate<CHARACTER> m_stateIdle;
+
+public:
+	virtual void StateMove();
+	virtual void StateBattle();
+	virtual void StateIdle();
+	virtual void StateFlag();
+	virtual void StateFlagBase();
+	void StateHorse();
+
+protected:
+	// STATE_IDLE_REFACTORING
+	void __StateIdle_Monster();
+	void __StateIdle_Stone();
+	void __StateIdle_NPC();
+	// END_OF_STATE_IDLE_REFACTORING
+
+public:
+	DWORD GetAIFlag() const { return m_pointsInstant.dwAIFlag; }
+
+	void SetAggressive(bool bSet = true);
+	bool IsAggressive() const;
+
+	void SetCoward();
+	bool IsCoward() const;
+	void CowardEscape();
+
+	void SetNoAttackShinsu();
+	bool IsNoAttackShinsu() const;
+
+	void SetNoAttackChunjo();
+	bool IsNoAttackChunjo() const;
+
+	void SetNoAttackJinno();
+	bool IsNoAttackJinno() const;
+
+	void SetAttackMob();
+	bool IsAttackMob() const;
+
+	void SetNoMove();
+	bool IsNoMove() const;
+
+	virtual void BeginStateEmpty();
+	virtual void EndStateEmpty() {}
+
+	void Restart(BYTE bSubCMD);
+	void RestartAtSamePos();
+
+protected:
+	DWORD m_dwStateDuration;
+	//////////////////////////////////////////////////////////////////////////////////
+
+public:
+	CHARACTER();
+	virtual ~CHARACTER();
+
+	void Create(const char* c_pszName, DWORD vid, bool isPC);
+	void Destroy();
+
+	void Disconnect(const char* c_pszReason);
+
+protected:
+	void Initialize();
+
+	//////////////////////////////////////////////////////////////////////////////////
+	// Basic Points
+
+public:
+	DWORD GetPlayerID() const { return m_dwPlayerID; }
+
+	void SetPlayerProto(const TPlayerTable* table);
+	void CreatePlayerProto(TPlayerTable& tab); //   
+
+	void SetProto(const CMob* c_pkMob);
+	WORD GetRaceNum() const;
+
+	void Save(); // DelayedSave
+	void SaveReal(); //  
+	void FlushDelayedSaveItem();
+
+	const char* GetName() const;
+	const VID& GetVID() const { return m_vid; }
+
+	void SetName(const std::string& name) { m_stName = name; }
+
+	void SetRace(BYTE race);
+	bool ChangeSex();
+
+	bool IsFemale() const;
+	bool IsMale() const;
+
+	DWORD GetAID() const;
+	int GetChangeEmpireCount() const;
+	void SetChangeEmpireCount();
+	int ChangeEmpire(BYTE empire);
+
+	BYTE GetJob() const;
+	BYTE GetCharType() const;
+
+	bool IsPC() const { return GetDesc() ? true : false; }
+	bool IsNPC() const { return m_bCharType != CHAR_TYPE_PC; }
+	bool IsMonster() const { return m_bCharType == CHAR_TYPE_MONSTER; }
+	bool IsStone() const { return m_bCharType == CHAR_TYPE_STONE; }
+	bool IsDoor() const { return m_bCharType == CHAR_TYPE_DOOR; }
+	bool IsBuilding() const { return m_bCharType == CHAR_TYPE_BUILDING; }
+	bool IsWarp() const { return m_bCharType == CHAR_TYPE_WARP; }
+	bool IsGoto() const { return m_bCharType == CHAR_TYPE_GOTO; }
+	bool IsHorse() const { return m_bCharType == CHAR_TYPE_HORSE; }
+	bool IsPetPay() const { return m_bCharType == CHAR_TYPE_PET_PAY; }
+	//bool IsPet() const { return m_bCharType == CHAR_TYPE_PET; }
+
+	DWORD GetLastShoutPulse() const { return m_pointsInstant.dwLastShoutPulse; }
+	void SetLastShoutPulse(DWORD pulse) { m_pointsInstant.dwLastShoutPulse = pulse; }
+
+	BYTE GetGMLevel() const;
+	BOOL IsGM() const;
+	void SetGMLevel();
+
+	void SetLevel(BYTE bValue);
+	BYTE GetLevel() const { return m_points.bLevel; }
+
+	void SetExp(DWORD dwValue) { m_points.dwExp = dwValue; }
+	DWORD GetExp() const { return m_points.dwExp; }
+	DWORD GetNextExp() const;
+
+#if defined(__CONQUEROR_LEVEL__)
+	void SetConqueror(bool bSet = true);
+
+	void SetConquerorLevel(BYTE bValue) { m_points.bConquerorLevel = bValue; }
+	BYTE GetConquerorLevel() const { return m_points.bConquerorLevel; }
+
+	void SetConquerorExp(DWORD dwValue) { m_points.dwConquerorExp = dwValue; }
+	DWORD GetConquerorExp() const { return m_points.dwConquerorExp; }
+	DWORD GetNextConquerorExp() const;
+#endif
+
+	LPCHARACTER DistributeExp(); //     Ñ´.
+
+	void DistributeHP(LPCHARACTER pkKiller);
+	void DistributeSP(LPCHARACTER pkKiller, int iMethod = 0);
+
+	void SetPosition(int pos);
+	bool IsPosition(int pos) const { return m_pointsInstant.position == pos ? true : false; }
+	int GetPosition() const { return m_pointsInstant.position; }
+
+	void SetPart(BYTE bPartPos, DWORD dwVal);
+	DWORD GetPart(BYTE bPartPos) const;
+	DWORD GetOriginalPart(BYTE bPartPos) const;
+
+	void SetHP(int val) { m_points.iHP = val; }
+	int GetHP() const { return m_points.iHP; }
+
+	void SetSP(int val) { m_points.iSP = val; }
+	int GetSP() const { return m_points.iSP; }
+
+	void SetMaxHP(int val) { m_pointsInstant.iMaxHP = val; }
+	int GetMaxHP() const { return m_pointsInstant.iMaxHP; }
+
+	void SetMaxSP(int val) { m_pointsInstant.iMaxSP = val; }
+	int GetMaxSP() const { return m_pointsInstant.iMaxSP; }
+
+	void SetStamina(int iValue) { m_points.iStamina = iValue; }
+	int GetStamina() const { return m_points.iStamina; }
+
+	void SetMaxStamina(int iValue) { m_pointsInstant.iMaxStamina = iValue; }
+	int GetMaxStamina() const { return m_pointsInstant.iMaxStamina; }
+
+	void SetRandomHP(int iValue) { m_points.iRandomHP = iValue; }
+	int GetRandomHP() const { return m_points.iRandomHP; }
+
+	void SetRandomSP(int iValue) { m_points.iRandomSP = iValue; }
+	int GetRandomSP() const { return m_points.iRandomSP; }
+
+	int GetHPPct() const;
+
+	void SetRealPoint(POINT_TYPE wPointType, POINT_VALUE lPointValue);
+	POINT_VALUE GetRealPoint(POINT_TYPE wPointType) const;
+
+	void SetPoint(POINT_TYPE wPointType, POINT_VALUE lPointValue);
+	POINT_VALUE GetPoint(POINT_TYPE wPointType) const;
+
+	POINT_VALUE GetLimitPoint(POINT_TYPE wPointType) const;
+	POINT_VALUE GetPolymorphPoint(POINT_TYPE wPointType) const;
+
+	const TMobTable& GetMobTable() const;
+	BYTE GetMobRank() const;
+	BYTE GetMobType() const;
+	BYTE GetMobBattleType() const;
+	BYTE GetMobSize() const;
+	DWORD GetMobDamageMin() const;
+	DWORD GetMobDamageMax() const;
+	WORD GetMobAttackRange() const;
+	DWORD GetMobDropItemVnum() const;
+	float GetMobDamageMultiply() const;
+#if defined(__ELEMENT_SYSTEM__)
+	int GetMobElement(BYTE bElement) const;
+#endif
+	float GetMonsterHitRange() const;
+
+	// NEWAI
+	bool IsBerserker() const;
+	bool IsBerserk() const;
+	void SetBerserk(bool mode);
+
+	bool IsStoneSkinner() const;
+
+	bool IsGodSpeeder() const;
+	bool IsGodSpeed() const;
+	void SetGodSpeed(bool mode);
+
+	bool IsDeathBlower() const;
+	bool IsDeathBlow() const;
+
+	bool IsHealer() const;
+	bool IsFaller() const;
+
+	bool IsReviver() const;
+	bool HasReviverInParty() const;
+	bool IsRevive() const;
+	void SetRevive(bool mode);
+	// NEWAI END
+
+	bool IsRaceFlag(DWORD dwBit) const;
+	bool IsSummonMonster() const;
+	DWORD GetSummonVnum() const;
+
+	int m_newSummonInterval;
+	int m_lastSummonTime;
+
+	bool CanSummonMonster() const;
+	void MarkSummonedMonster();
+
+	DWORD GetPolymorphItemVnum() const;
+	DWORD GetMonsterDrainSPPoint() const;
+
+	void MainCharacterPacket(); //  Ä³Í¶ Ø´.
+
+	void ComputePoints();
+	void ComputeBattlePoints();
+
+	void PointChange(POINT_TYPE wPointType, POINT_VALUE lPointAmount, bool bAmount = false, bool bBroadcast = false);
+	void PointsPacket();
+	void UpdatePointsPacket(POINT_TYPE wPointType, POINT_VALUE lPointValue, POINT_VALUE lPointAmount = 0, bool bAmount = false, bool bBroadcast = false);
+
+	void ApplyPoint(POINT_TYPE wApplyType, POINT_VALUE lApplyValue);
+	void CheckMaximumPoints(); // HP, SP    Ö´ë°ª   Ë»Ï° Ù¸ .
+
+
+	bool Show(long lMapIndex, long x, long y, long z = LONG_MAX, bool bShowSpawnMotion = false
+#if defined(__WJ_SHOW_MOB_INFO__)
+		, bool bAggressive = false
+#endif
+	);
+
+	void Sitdown(int is_ground);
+	void Standup();
+
+	void SetRotation(float fRot);
+	void SetRotationToXY(long x, long y);
+	float GetRotation() const { return m_pointsInstant.fRot; }
+
+	void MotionPacketEncode(BYTE motion, LPCHARACTER victim, struct packet_motion* packet);
+	void Motion(BYTE motion, LPCHARACTER victim = NULL);
+
+	void ChatPacket(BYTE type, const char* format, ...);
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	void ChatPacket(packet_chat pack_chat, const char* format, ...);
+#endif
+	void MonsterChat(BYTE bMonsterChatType);
+	void SendGreetMessage();
+
+	void ResetPoint(int iLv);
+	void ResetExp();
+
+#if defined(__CONQUEROR_LEVEL__)
+	void ResetConquerorPoint(int iLv);
+	void ResetConquerorExp();
+#endif
+
+	void SetBlockMode(BYTE bFlag);
+	void SetBlockModeForce(BYTE bFlag);
+	bool IsBlockMode(BYTE bFlag) const { return (m_pointsInstant.bBlockMode & bFlag) ? true : false; }
+#ifdef __OFFLINE_SHOP__
+	void SendUnlockedShopDeco();
+	void SetUnlockShopSkin(BYTE bFlag);
+	void SetUnlockShopBanner(BYTE bFlag);
+	bool IsUnlockedShopSkin(BYTE bFlag) const { return (m_pointsInstant.bUnlockedShopSkin & bFlag) ? true : false; }
+	bool IsUnlockedShopBanner(BYTE bFlag) const { return (m_pointsInstant.bUnlockedShopBanner & bFlag) ? true : false; }
+#endif
+	bool IsPolymorphed() const { return m_dwPolymorphRace > 0; }
+	bool IsPolyMaintainStat() const { return m_bPolyMaintainStat; } //   Ï´ .
+	void SetPolymorph(DWORD dwRaceNum, bool bMaintainStat = false);
+	DWORD GetPolymorphVnum() const { return m_dwPolymorphRace; }
+	int GetPolymorphPower() const;
+
+	// FISING
+	void fishing();
+	void fishing_take();
+	bool IsFishing() const { return m_pkFishingEvent ? true : false; }
+	// END_OF_FISHING
+
+	// MINING
+	void mining(LPCHARACTER chLoad);
+	void mining_cancel();
+	void mining_take();
+	bool IsMining() const { return m_pkMiningEvent ? true : false; }
+	// END_OF_MINING
+
+	void ResetPlayTime(DWORD dwTimeRemain = 0);
+
+	void CreateFly(BYTE bType, LPCHARACTER pkVictim);
+
+	void ResetChatCounter() { m_bChatCounter = 0; }
+	void IncreaseChatCounter() { ++m_bChatCounter; }
+	BYTE GetChatCounter() const { return m_bChatCounter; }
+
+	void ResetWhisperCounter() { m_bWhisperCounter = 0; }
+	bool IncreaseWhisperCounter() { ++m_bWhisperCounter; return m_bWhisperCounter; }
+	BYTE GetWhisperCounter() const { return m_bWhisperCounter; }
+
+protected:
+	DWORD m_dwPolymorphRace;
+	bool m_bPolyMaintainStat;
+	DWORD m_dwLoginPlayTime;
+	DWORD m_dwPlayerID;
+	VID m_vid;
+	std::string m_stName;
+	BYTE m_bCharType;
+
+	CHARACTER_POINT m_points;
+	CHARACTER_POINT_INSTANT m_pointsInstant;
+
+	int m_iMoveCount;
+	DWORD m_dwPlayStartTime;
+	BYTE m_bAddChrState;
+	bool m_bSkipSave;
+	BYTE m_bChatCounter;
+	BYTE m_bWhisperCounter;
+
+	// End of Basic Points
+
+	//////////////////////////////////////////////////////////////////////////////////
+	// Move & Synchronize Positions
+	//////////////////////////////////////////////////////////////////////////////////
+public:
+	bool IsStateMove() const { return IsState((CState&)m_stateMove); }
+	bool IsStateIdle() const { return IsState((CState&)m_stateIdle); }
+	bool IsWalking() const { return m_bNowWalking || GetStamina() <= 0; }
+	void SetWalking(bool bWalkFlag) { m_bWalking = bWalkFlag; }
+	void SetNowWalking(bool bWalkFlag);
+	void ResetWalking() { SetNowWalking(m_bWalking); }
+
+	bool Goto(long x, long y); // Ù· Ìµ Å° Ê° Ç¥ Ä¡ BLENDING Å².
+	void Stop();
+
+	bool CanMove() const; // Ìµ  Ö´Â°?
+
+	void SyncPacket();
+	bool Sync(long x, long y); //   Þ¼Òµ Ìµ Ñ´ (  Ç¿  Ìµ Ò° )
+	bool Move(long x, long y); //  Ë»Ï° Sync Þ¼Òµå¸¦  Ìµ Ñ´.
+	void OnMove(bool bIsAttack = false); // Ï¶ Ò¸. Move() Þ¼Òµ Ì¿Ü¿ Ò¸  Ö´.
+	DWORD GetMotionMode() const;
+	float GetMoveMotionSpeed() const;
+	float GetMoveSpeed() const;
+	void CalculateMoveDuration();
+	void SendMovePacket(BYTE bFunc, BYTE bArg, DWORD x, DWORD y, DWORD dwDuration, DWORD dwTime = 0, int iRot = -1);
+
+	DWORD GetCurrentMoveDuration() const { return m_dwMoveDuration; }
+	DWORD GetWalkStartTime() const { return m_dwWalkStartTime; }
+	DWORD GetLastMoveTime() const { return m_dwLastMoveTime; }
+	DWORD GetLastAttackTime() const { return m_dwLastAttackTime; }
+
+	DWORD GetLastDiceTime() const { return m_dwLastDiceTime; }
+	void SetLastDiceTime(DWORD dwTime) { m_dwLastDiceTime = dwTime; }
+
+	void SetLastAttacked(DWORD time); //  Ý¹ Ã°  Ä¡ 
+
+	bool SetSyncOwner(LPCHARACTER ch, bool bRemoveFromList = true);
+	bool IsSyncOwner(LPCHARACTER ch) const;
+
+	bool WarpSet(long x, long y, long lRealMapIndex = 0);
+	void SetWarpLocation(long lMapIndex, long x, long y);
+	void WarpEnd();
+	const PIXEL_POSITION& GetWarpPosition() const { return m_posWarp; }
+	bool WarpToPID(DWORD dwPID, bool bWarpForce = false);
+
+	void SaveExitLocation();
+	void ExitToSavedLocation();
+
+	void StartStaminaConsume();
+	void StopStaminaConsume();
+	bool IsStaminaConsume() const;
+	bool IsStaminaHalfConsume() const;
+
+	void ResetStopTime();
+	DWORD GetStopTime() const;
+
+#if defined(__MOVE_CHANNEL__)
+	bool MoveChannel(long lNewAddr, WORD wNewPort);
+	bool StartMoveChannel(long lNewAddr, WORD wNewPort);
+#endif
+
+protected:
+	void ClearSync();
+
+	float m_fSyncTime;
+	LPCHARACTER m_pkChrSyncOwner;
+	CHARACTER_LIST m_kLst_pkChrSyncOwned; //  SyncOwner Úµ
+
+	PIXEL_POSITION m_posDest;
+	PIXEL_POSITION m_posStart;
+	PIXEL_POSITION m_posWarp;
+	long m_lWarpMapIndex;
+
+	PIXEL_POSITION m_posExit;
+	long m_lExitMapIndex;
+
+	DWORD m_dwMoveStartTime;
+	DWORD m_dwMoveDuration;
+
+	DWORD m_dwLastMoveTime;
+	DWORD m_dwLastAttackTime;
+	DWORD m_dwLastDiceTime;
+	DWORD m_dwWalkStartTime;
+	DWORD m_dwStopTime;
+
+	bool m_bWalking;
+	bool m_bNowWalking;
+	bool m_bStaminaConsume;
+
+	// End
+
+	// Quickslot 
+public:
+	void SyncQuickslot(BYTE bType, WORD wOldPos, WORD wNewPos);
+	bool GetQuickslot(BYTE pos, TQuickslot** ppSlot);
+	bool SetQuickslot(BYTE pos, TQuickslot& rSlot);
+	bool DelQuickslot(BYTE pos);
+	bool SwapQuickslot(BYTE a, BYTE b);
+	void ChainQuickslotItem(LPITEM pItem, BYTE bType, WORD wOldPos);
+	void MoveQuickSlotItem(BYTE bOldType, WORD wOldPos, BYTE bNewType, WORD wNewPos);
+
+	void CheckQuickSlotItems();
+	bool CanAddToQuickSlot(LPITEM pItem);
+
+protected:
+	TQuickslot m_quickslot[QUICKSLOT_MAX_NUM];
+
+#if defined(__LUCKY_BOX__)
+public:
+	void SetLuckyBoxSrcItem(LPITEM lpItem);
+	void SendLuckyBoxInfo();
+	void LuckyBoxRetry();
+	void LuckyBoxReceive();
+	int GetLuckyBoxPrice() const;
+	bool IsLuckyBoxOpen() const;
+	void ResetLuckyBoxData();
+
+private:
+	struct
+	{
+		DWORD dwSrcItemVNum;
+		DWORD dwSrcItemID;
+		WORD wSrcSlotIndex;
+		BYTE bTryCount;
+		DWORD dwItemVNum;
+		BYTE bItemCount;
+	} m_sLuckyBox;
+#endif
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Affect
+public:
+	void StartAffectEvent();
+	void ClearAffect(bool bSave = false);
+	void ComputeAffect(const CAffect* pkAff, bool bAdd);
+	bool AddAffect(DWORD dwType, POINT_TYPE wApplyOn, POINT_VALUE lApplyValue, DWORD dwFlag, long lDuration, long lSPCost, bool bOverride, bool IsCube = false
+#if defined(__AFFECT_RENEWAL__)
+		, bool bRealTime = false
+#endif
+#if defined(__9TH_SKILL__)
+		, long lValue = 0 /* Skill iAmount2 */
+#endif
+	);
+#if defined(__AFFECT_RENEWAL__)
+	bool AddRealTimeAffect(DWORD dwType, POINT_TYPE wApplyOn, POINT_VALUE lApplyValue, DWORD dwFlag, long lDuration, long lSPCost, bool bOverride, bool IsCube = false, bool bRealTime = true);
+#endif
+	void RefreshAffect();
+	bool RemoveAffect(DWORD dwType);
+#if defined(__SOUL_SYSTEM__)
+	void RemoveAffect(DWORD dwType, POINT_TYPE wApplyType);
+#endif
+	bool IsAffectFlag(DWORD dwAff) const;
+
+	bool UpdateAffect(); // called from EVENT
+	int ProcessAffect();
+
+	void LoadAffect(DWORD dwCount, TPacketAffectElement* pElements);
+	void SaveAffect();
+
+public:
+	// Affect loading  Î°?
+	bool IsLoadedAffect() const { return m_bIsLoadedAffect; }
+
+	bool IsGoodAffect(BYTE bAffectType) const;
+
+	void RemoveGoodAffect();
+	void RemoveBadAffect();
+
+	CAffect* FindAffect(DWORD dwType, POINT_TYPE wApplyType = APPLY_NONE) const;
+	const AffectContainerList& GetAffectContainer() const { return m_list_pkAffect; }
+	bool RemoveAffect(CAffect* pkAff);
+
+	//void SetAffectStack(CAffect* pkAff, BYTE value);
+	//BYTE GetAffectStack(CAffect* pkAff);
+	//void ClearAffectStack(CAffect* pkAff);
+	//
+	//AffectStackMap m_map_affectStack;
+
+protected:
+	bool m_bIsLoadedAffect;
+	TAffectFlag m_afAffectFlag;
+	AffectContainerList m_list_pkAffect;
+
+public:
+	// PARTY_JOIN_BUG_FIX
+	void SetParty(LPPARTY pkParty);
+	LPPARTY GetParty() const { return m_pkParty; }
+
+	bool RequestToParty(LPCHARACTER leader);
+	void DenyToParty(LPCHARACTER member);
+	void AcceptToParty(LPCHARACTER member);
+
+	/// Ú½ Æ¼ Ù¸ character  Ê´Ñ´.
+	/**
+	* @param pchInvitee Ê´  character. Æ¼   Ì¾ Ñ´.
+	*
+	*  character  Â° Æ¼ Ê´Ï° Ê´  Ö´ Â° Æ´Ï¶ Ê´Ï´ Ä³Í¿ Ø´Ï´ Ã¤ Þ¼ Ñ´.
+	**/
+	void PartyInvite(LPCHARACTER pchInvitee);
+
+	/// Ê´ß´ character   Ã³Ñ´.
+	/**
+	* @param pchInvitee Æ¼  character. Æ¼  Ì¾ Ñ´.
+	*
+	* pchInvitee  Æ¼   Ö´ È² Æ´Ï¶ Ø´Ï´ Ã¤ Þ¼ Ñ´.
+	**/
+	void PartyInviteAccept(LPCHARACTER pchInvitee);
+
+	/// Ê´ß´ character  Ê´ ÅºÎ¸ Ã³Ñ´.
+	/**
+	* @param [in] dwPID Ê´ ß´ character  PID
+	**/
+	void PartyInviteDeny(DWORD dwPID);
+
+	bool BuildUpdatePartyPacket(TPacketGCPartyUpdate& out);
+	int GetLeadershipSkillLevel() const;
+#if defined(__PARTY_PROFICY__)
+	int GetRoleProficiencySkillLevel() const;
+#endif
+#if defined(__PARTY_INSIGHT__)
+	int GetInSightSkillLevel() const;
+#endif
+
+	bool CanSummon(int iLeaderShip);
+
+	void SetPartyRequestEvent(LPEVENT pkEvent) { m_pkPartyRequestEvent = pkEvent; }
+
+protected:
+
+	/// Æ¼ Ñ´.
+	/**
+	* @param pkLeader  Æ¼ 
+	**/
+	void PartyJoin(LPCHARACTER pkLeader);
+
+	/**
+	* Æ¼      Úµ.
+	* Error code  Ã° Î°  æ°¡(mutable) type  (static) type  .
+	* Error code   PERR_SEPARATOR   æ°¡ type Ì°   type Ì´.
+	**/
+	enum PartyJoinErrCode
+	{
+		PERR_NONE = 0, ///< Ã³
+		PERR_SERVER, ///<  Æ¼ Ã³ Ò°
+		PERR_DUNGEON, ///< Ä³Í°  
+		PERR_OBSERVER, ///< 
+		PERR_LVBOUNDARY, ///<  Ä³Í¿ Ì° 
+		PERR_LOWLEVEL, ///< Æ¼ Ö° 30 
+		PERR_HILEVEL, ///< Æ¼  30 
+		PERR_ALREADYJOIN, ///< Æ¼  Ä³Í° Ì¹ Æ¼
+		PERR_PARTYISFULL, ///< Æ¼Î¿  Ê°
+		PERR_SEPARATOR, ///< Error type separator.
+		PERR_DIFFEMPIRE, ///<  Ä³Í¿ Ù¸ 
+		PERR_MAX ///< Error code Ö°Ä¡.  Õ¿ Error code  ß°Ñ´.
+	};
+
+	/// Æ¼ Ì³ á¼º   Ë»Ñ´.
+	/**
+	* @param pchLeader Æ¼ leader Ì°Å³ Ê´ character
+	* @param pchGuest Ê´Þ´ character
+	* @return  PartyJoinErrCode  È¯  Ö´.
+	**/
+	static PartyJoinErrCode IsPartyJoinableCondition(const LPCHARACTER pchLeader, const LPCHARACTER pchGuest);
+
+	/// Æ¼ Ì³ á¼º    Ë»Ñ´.
+	/**
+	* @param pchLeader Æ¼ leader Ì°Å³ Ê´ character
+	* @param pchGuest Ê´Þ´ character
+	* @return mutable type  code  È¯Ñ´.
+	**/
+	static PartyJoinErrCode IsPartyJoinableMutableCondition(const LPCHARACTER pchLeader, const LPCHARACTER pchGuest);
+
+	LPPARTY m_pkParty;
+	DWORD m_dwLastDeadTime;
+	LPEVENT m_pkPartyRequestEvent;
+
+	/**
+	* Æ¼Ã» Event map.
+	* key: Ê´ Ä³ PID
+	* value: event pointer
+	*
+	* Ê´ Ä³Íµé¿¡  event map.
+	**/
+	typedef std::map<DWORD, LPEVENT> EventMap;
+	EventMap m_PartyInviteEventMap;
+
+	// END_OF_PARTY_JOIN_BUG_FIX
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Dungeon
+public:
+	void SetDungeon(LPDUNGEON pkDungeon);
+	LPDUNGEON GetDungeon() const { return m_pkDungeon; }
+	LPDUNGEON GetDungeonForce() const;
+protected:
+	LPDUNGEON m_pkDungeon;
+	int m_iEventAttr;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Guild
+public:
+	void SetGuild(CGuild* pGuild);
+	CGuild* GetGuild() const { return m_pGuild; }
+
+	void SetWarMap(CWarMap* pWarMap);
+	CWarMap* GetWarMap() const { return m_pWarMap; }
+
+protected:
+	CGuild* m_pGuild;
+	DWORD m_dwUnderGuildWarInfoMessageTime;
+	CWarMap* m_pWarMap;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Item related
+public:
+	bool CanHandleItem(bool bSkipRefineCheck = false, bool bSkipObserver = false); //      Ö´Â°?
+
+	bool IsItemLoaded() const { return m_bItemLoaded; }
+	void SetItemLoaded() { m_bItemLoaded = true; }
+
+	void ClearItem();
+
+	LPITEM GetInventoryItem(WORD wCell) const;
+	LPITEM GetEquipmentItem(WORD wCell) const;
+	LPITEM GetDragonSoulInventoryItem(WORD wCell) const;
+	LPITEM GetBeltInventoryItem(WORD wCell) const;
+
+	void SetItem(TItemPos Cell, LPITEM item
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		, bool isHighLight = false
+#endif
+	);
+
+	LPITEM GetItem(TItemPos Cell) const;
+
+	bool IsEmptyItemGrid(TItemPos Cell, BYTE size, int iExceptionCell = -1) const;
+
+	void SetWear(WORD wCell, LPITEM item);
+	LPITEM GetWear(WORD wCell) const;
+
+	// MYSHOP_PRICE_LIST
+	void UseSilkBotary(void); ///    
+
+	/// DB Ä³Ã·  Þ¾Æ¿  Æ®  Ï°    Ã³Ñ´.
+	/**
+	* @param [in] p  Æ® Å¶
+	*
+	*   Ã³      UseSilkBotary  DB Ä³Ã·  Æ® Ã»Ï°
+	*    Ô¼  Üº  Ã³Ñ´.
+	**/
+	void UseSilkBotaryReal(const TPacketMyshopPricelistHeader* p);
+	// END_OF_MYSHOP_PRICE_LIST
+
+	bool UseItemEx(LPITEM item, TItemPos DestCell);
+	bool UseItem(TItemPos Cell, TItemPos DestCell = NPOS);
+
+	// ADD_REFINE_BUILDING
+	bool IsRefineThroughGuild() const;
+	CGuild* GetRefineGuild() const;
+	int ComputeRefineFee(int iCost, int iMultiply = 5) const;
+	void PayRefineFee(int iTotalMoney);
+	void SetRefineNPC(LPCHARACTER ch);
+	// END_OF_ADD_REFINE_BUILDING
+
+	bool RefineItem(LPITEM pkItem, LPITEM pkTarget);
+	bool DropItem(TItemPos Cell, WORD wCount = 0);
+#if defined(__NEW_DROP_DIALOG__)
+	bool DestroyItem(TItemPos Cell);
+#endif
+	bool GiveRecallItem(LPITEM item);
+	void ProcessRecallItem(LPITEM item);
+
+	// void PotionPacket(int iPotionType);
+	void EffectPacket(BYTE bEffectNum, BYTE bEffectType = SE_TYPE_NORMAL, const PIXEL_POSITION& rEffectPos = { 0, 0, 0 });
+	void SpecificEffectPacket(const char filename[128]);
+
+	// ADD_MONSTER_REFINE
+	bool DoRefine(LPITEM item, bool bMoneyOnly = false);
+	// END_OF_ADD_MONSTER_REFINE
+
+	bool DoRefineWithScroll(LPITEM item);
+	bool RefineInformation(WORD wCell, BYTE bType, int iAdditionalCell = -1);
+
+	struct SRefineScrollData
+	{
+		BYTE bSuccessProb;
+		bool bKeepGrade;
+	};
+	SRefineScrollData GetScrollRefinePct(BYTE bProb, BYTE bRefineLevel, BYTE bScrollType);
+
+	void SetRefineMode(int iAdditionalCell = -1);
+	void ClearRefineMode();
+
+	bool GiveItem(LPCHARACTER victim, TItemPos Cell);
+	bool CanReceiveItem(LPCHARACTER from, LPITEM item) const;
+	void ReceiveItem(LPCHARACTER from, LPITEM item);
+	//bool GiveItemFromSpecialItemGroup(DWORD dwGroupNum, std::vector<DWORD>& dwItemVnums,
+	//	std::vector<DWORD>& dwItemCounts, std::vector<LPITEM>& item_gets, int& count);
+	bool GiveItemFromSpecialItemGroup(DWORD dwGroupNum);
+
+	bool MoveItem(TItemPos pos, TItemPos change_pos, WORD num);
+	bool PickupItem(DWORD vid
+#if defined(__PET_LOOT_AI__)
+		, bool PetLoot = false
+#endif
+	);
+	bool EquipItem(LPITEM item, int iCandidateCell = -1);
+	bool UnequipItem(LPITEM item);
+
+	//  item   Ö´  È®Ï°, Ò° Ï´Ù¸ Ä³Í¿  Ë·Ö´ Ô¼
+	bool CanEquipNow(const LPITEM item, const TItemPos& srcCell = NPOS, const TItemPos& destCell = NPOS);
+	//  item   Ö´  È®Ï°, Ò° Ï´Ù¸ Ä³Í¿  Ë·Ö´ Ô¼
+	bool CanUnequipNow(const LPITEM item, const TItemPos& srcCell = NPOS, const TItemPos& destCell = NPOS);
+
+	bool SwapItem(WORD wCell, WORD wDestCell);
+
+	LPITEM AutoGiveItem(DWORD dwItemVnum, WORD wCount = 1, int iRarePct = -1, bool bMsg = true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		, bool isHighLight = false
+#endif
+#if defined(__NEW_USER_CARE__)
+		, bool bSystemDrop = true
+#endif
+	);
+
+	void AutoGiveItem(LPITEM item, bool longOwnerShip = false, bool bMsg = true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		, bool isHighLight = false
+#endif
+	);
+
+	int GetEmptyInventory(BYTE size) const;
+	int GetEmptyInventoryCount(BYTE size) const;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	int GetEmptyDragonSoulInventory(LPITEM pItem) const;
+	void CopyDragonSoulItemGrid(std::vector<WORD>& vDragonSoulItemGrid) const;
+#endif
+
+	int CountEmptyInventory() const;
+	bool HasEnoughInventorySpace(std::vector<TItemData>& vItems) const;
+
+	int CountSpecifyItem(DWORD vnum, int iExceptionCell = -1
+#if defined(__SOUL_BIND_SYSTEM__)
+		, bool bIgnoreSealedItem = false
+#endif
+#if defined(__SET_ITEM__)
+		, bool bIgnoreSetValue = false
+#endif
+	) const;
+	void RemoveSpecifyItem(DWORD vnum, DWORD count = 1, int iExceptionCell = -1
+#if defined(__SOUL_BIND_SYSTEM__)
+		, bool bIgnoreSealedItem = false
+#endif
+#if defined(__SET_ITEM__)
+		, bool bIgnoreSetValue = false
+#endif
+	);
+	LPITEM FindSpecifyItem(DWORD dwVnum
+#if defined(__SOUL_BIND_SYSTEM__)
+		, bool bIgnoreSealedItem = false
+#endif
+#if defined(__SET_ITEM__)
+		, bool bIgnoreSetValue = false
+#endif
+	) const;
+	LPITEM FindItemByID(DWORD id) const;
+
+	int CountSpecifyTypeItem(BYTE type) const;
+	void RemoveSpecifyTypeItem(BYTE type, DWORD count = 1);
+
+	bool IsEquipUniqueItem(DWORD dwItemVnum) const;
+
+	// CHECK_UNIQUE_GROUP
+	bool IsEquipUniqueGroup(DWORD dwGroupVnum) const;
+	// END_OF_CHECK_UNIQUE_GROUP
+
+	void SendEquipment(LPCHARACTER pChar);
+	// End of Item
+
+protected:
+	///  Û¿   Ñ´.
+	/**
+	* @param [in] dwItemVnum  vnum
+	* @param [in] dwItemPrice  
+	**/
+	void SendMyShopPriceListCmd(DWORD dwItemVnum, DWORD dwItemPrice
+#if defined(__CHEQUE_SYSTEM__)
+		, DWORD dwItemCheque
+#endif
+	);
+
+	bool m_bNoOpenedShop; ///< Ì¹   Î»   Ö´ (  Ù¸ true)
+
+	bool m_bItemLoaded;
+	int m_iRefineAdditionalCell;
+
+public:
+	bool IsUnderRefine() const { return m_bUnderRefine; }
+	void SetUnderRefine(bool bState) { m_bUnderRefine = bState; }
+protected:
+	bool m_bUnderRefine;
+	DWORD m_dwRefineNPCVID;
+
+public:
+	int GetGold() const { return m_points.iGold; }
+	void SetGold(int iValue) { m_points.iGold = iValue; }
+
+	bool DropGold(int iAmount);
+	void GiveGold(int iAmount); // Æ¼  Æ¼ Ð¹, Î±  Ã³
+
+	int GetAllowedGold() const;
+
+#if defined(__CHEQUE_SYSTEM__)
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Cheque related
+	int GetCheque() const { return m_points.iCheque; }
+	void SetCheque(int iValue) { m_points.iCheque = iValue; }
+	bool DropCheque(int iAmount);
+	void GiveCheque(int iAmount);
+	// End of Cheque
+#endif
+
+#if defined(__GEM_SYSTEM__)
+	////////////////////////////////////////////////////////////////////////////////////////
+	int GetGem() const { return m_points.iGem; }
+	void SetGem(int iValue) { m_points.iGem = iValue; }
+	void GiveGem(int iAmount);
+#endif
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Shop related
+public:
+	void SetShop(LPSHOP pkShop);
+	LPSHOP GetShop() const { return m_pkShop; }
+	void ShopPacket(BYTE bSubHeader);
+
+	void SetShopOwner(LPCHARACTER ch) { m_pkChrShopOwner = ch; }
+	LPCHARACTER GetShopOwner() const { return m_pkChrShopOwner; }
+
+#ifdef __OFFLINE_SHOP__
+	void SetShowOfflineShop(DWORD option) { dwIsShowShops = option; UpdateSectree();}
+	DWORD GetShowOfflineShop()  const { return dwIsShowShops;}
+#endif
+
+	void OpenMyShop(const char* c_pszSign, TShopItemTable* pTable, BYTE bItemCount);
+	LPSHOP GetMyShop() const { return m_pkMyShop; }
+	void CloseMyShop();
+
+protected:
+	LPSHOP m_pkShop;
+	LPSHOP m_pkMyShop;
+	std::string m_stShopSign;
+	LPCHARACTER m_pkChrShopOwner;
+	// End of shop
+
+#ifdef __OFFLINE_SHOP__
+	DWORD dwIsShowShops;
+#endif
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Exchange related
+public:
+	bool ExchangeStart(LPCHARACTER victim);
+	void SetExchange(CExchange* pkExchange);
+	CExchange* GetExchange() const { return m_pkExchange; }
+
+protected:
+	CExchange* m_pkExchange;
+	// End of Exchange
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Battle
+public:
+	struct TBattleInfo
+	{
+		int iTotalDamage;
+		int iAggro;
+
+		TBattleInfo(int iTot, int iAggr)
+			: iTotalDamage(iTot), iAggro(iAggr)
+		{}
+	};
+	typedef std::map<VID, TBattleInfo> TDamageMap;
+
+	typedef struct SAttackLog
+	{
+		DWORD dwVID;
+		DWORD dwTime;
+	} AttackLog;
+
+	bool Damage(LPCHARACTER pAttacker, int dam, EDamageType type = DAMAGE_TYPE_NORMAL);
+	bool __Profile__Damage(LPCHARACTER pAttacker, int dam, EDamageType type = DAMAGE_TYPE_NORMAL);
+	void DeathPenalty(BYTE bExpLossPercent);
+	void ReviveInvisible(int iDur);
+
+	bool Attack(LPCHARACTER pkVictim, BYTE bType = 0);
+	bool IsAlive() const { return m_pointsInstant.position == POS_DEAD ? false : true; }
+	bool CanFight() const;
+
+	bool CanBeginFight() const;
+	void BeginFight(LPCHARACTER pkVictim); // pkVictimr Î¿ Ñ´. (,   Ö³ Ã¼Å©Ï· CanBeginFight )
+
+	bool CounterAttack(LPCHARACTER pkChr); // Ý°Ï± (Í¸ )
+
+	bool IsStun() const;
+	void Stun(bool bImmediate = false);
+	bool IsDead() const;
+	void Dead(LPCHARACTER pkKiller = NULL, bool bImmediateDead = false);
+
+	void Reward(bool bItemDrop);
+	void RewardGold(LPCHARACTER pkAttacker);
+
+	bool Shoot(BYTE bType);
+	void FlyTarget(DWORD dwTargetVID, long x, long y, BYTE bHeader);
+
+	void ForgetMyAttacker(bool bRevive = true);
+	void AggregateMonster();
+	void AttractRanger();
+	void PullMonster();
+
+	int GetArrowAndBow(LPITEM* ppkBow, LPITEM* ppkArrow, int iArrowCount = 1);
+	void UseArrow(LPITEM pkArrow, DWORD dwArrowCount);
+
+	void AttackedByPoison(LPCHARACTER pkAttacker);
+	void RemovePoison();
+
+	void AttackedByBleeding(LPCHARACTER pkAttacker);
+	void RemoveBleeding();
+
+	void AttackedByFire(LPCHARACTER pkAttacker, int amount, int count);
+	void RemoveFire();
+
+	void UpdateAlignment(int iAmount);
+	int GetAlignment() const;
+
+	// Ä¡  
+	int GetRealAlignment() const;
+	void ShowAlignment(bool bShow);
+
+	UINT GetAlignmentGrade() const;
+
+	void SetKillerMode(bool bOn);
+	bool IsKillerMode() const;
+	void UpdateKillerMode();
+
+	BYTE GetPKMode() const;
+	void SetPKMode(BYTE bPKMode);
+
+	void ItemDropPenalty(LPCHARACTER pkKiller);
+
+	void UpdateAggrPoint(LPCHARACTER ch, EDamageType type, int dam);
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// HACK
+public:
+	void SetComboSequence(BYTE seq);
+	BYTE GetComboSequence() const;
+
+	void SetLastComboTime(DWORD time);
+	DWORD GetLastComboTime() const;
+
+	int GetValidComboInterval() const;
+	void SetValidComboInterval(int interval);
+
+	BYTE GetComboIndex() const;
+
+	void IncreaseComboHackCount(int k = 1);
+	void ResetComboHackCount();
+	void SkipComboAttackByTime(int interval);
+	DWORD GetSkipComboAttackByTime() const;
+
+protected:
+	BYTE m_bComboSequence;
+	DWORD m_dwLastComboTime;
+	int m_iValidComboInterval;
+	BYTE m_bComboIndex;
+	int m_iComboHackCount;
+	DWORD m_dwSkipComboAttackByTime;
+
+protected:
+	void UpdateAggrPointEx(LPCHARACTER ch, EDamageType type, int dam, TBattleInfo& info);
+	void ChangeVictimByAggro(int iNewAggro, LPCHARACTER pNewVictim);
+
+	DWORD m_dwFlyTargetID;
+	std::vector<DWORD> m_vec_dwFlyTargets;
+	TDamageMap m_map_kDamage; // î¶² Ä³Í°  ó¸¶¸Å­  Ö¾Â°?
+	//AttackLog m_kAttackLog;
+	DWORD m_dwKillerPID;
+
+	int m_iAlignment; // Lawful / Chaotic value -200000 ~ 200000
+	int m_iRealAlignment;
+	int m_iKillerModePulse;
+	BYTE m_bPKMode;
+
+	// Aggro
+	DWORD m_dwLastVictimSetTime;
+	int m_iMaxAggro;
+	// End of Battle
+
+	// Stone
+public:
+	void SetStone(LPCHARACTER pkChrStone);
+	void ClearStone();
+	void DetermineDropMetinStone();
+	DWORD GetDropMetinStoneVnum() const { return m_dwDropMetinStone; }
+	BYTE GetDropMetinStonePct() const { return m_bDropMetinStonePct; }
+
+protected:
+	LPCHARACTER m_pkChrStone; //   
+	CHARACTER_SET m_set_pkChrSpawnedBy; //   
+	DWORD m_dwDropMetinStone;
+	BYTE m_bDropMetinStonePct;
+	// End of Stone
+
+public:
+	enum
+	{
+		SKILL_UP_BY_POINT,
+		SKILL_UP_BY_BOOK,
+		SKILL_UP_BY_TRAIN,
+
+		// ADD_GRANDMASTER_SKILL
+		SKILL_UP_BY_QUEST,
+		// END_OF_ADD_GRANDMASTER_SKILL
+	};
+
+	void SkillLevelPacket();
+	void SkillLevelUp(DWORD dwVnum, BYTE bMethod = SKILL_UP_BY_POINT);
+	bool SkillLevelDown(DWORD dwVnum);
+	// ADD_GRANDMASTER_SKILL
+	bool UseSkill(DWORD dwVnum, LPCHARACTER pkVictim, bool bUseGrandMaster = true);
+	void ResetSkill();
+#if defined(__SKILL_COOLTIME_UPDATE__)
+	void ResetSkillCoolTimes();
+#endif
+	void SetSkillLevel(DWORD dwVnum, BYTE bLev);
+	int GetUsedSkillMasterType(DWORD dwVnum);
+
+	bool IsLearnableSkill(DWORD dwSkillVnum) const;
+	// END_OF_ADD_GRANDMASTER_SKILL
+
+	bool CheckSkillHitCount(const BYTE SkillID, const VID dwTargetVID);
+	bool CanUseSkill(DWORD dwSkillVnum) const;
+	bool IsUsableSkillMotion(DWORD dwMotionIndex) const;
+	int GetSkillLevel(DWORD dwVnum) const;
+	int GetSkillMasterType(DWORD dwVnum) const;
+	int GetSkillPower(DWORD dwVnum, BYTE bLevel = 0) const;
+
+	time_t GetSkillNextReadTime(DWORD dwVnum) const;
+	void SetSkillNextReadTime(DWORD dwVnum, time_t time);
+	void SkillLearnWaitMoreTimeMessage(DWORD dwVnum);
+
+	void ComputePassiveSkill(DWORD dwVnum);
+#ifdef ENABLE_QUEEN_NETHIS
+	int ComputeSnakeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel);
+#endif
+	int ComputeSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
+	int ComputeSkillParty(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
+	int ComputeSkillAtPosition(DWORD dwVnum, const PIXEL_POSITION& posTarget, BYTE bSkillLevel = 0);
+#if defined(__PVP_BALANCE_IMPROVING__)
+	int ComputeGyeongGongSkill(DWORD dwVnum, LPCHARACTER pkVictim, BYTE bSkillLevel = 0);
+#endif
+	void ComputeSkillPoints();
+
+	void SetSkillGroup(BYTE bSkillGroup);
+	BYTE GetSkillGroup() const { return m_points.bSkillGroup; }
+
+	int ComputeCooltime(int time);
+
+	void GiveRandomSkillBook();
+	void GiveSkillBook(DWORD dwSkillVnum, WORD wCount);
+
+	void DisableCooltime();
+	bool LearnSkillByBook(DWORD dwSkillVnum, BYTE bProb = 0);
+	bool LearnGrandMasterSkill(DWORD dwSkillVnum);
+
+#if defined(__CONQUEROR_LEVEL__)
+	bool IsConquerorSkill(DWORD dwVnum) const;
+#endif
+
+private:
+	bool m_bDisableCooltime;
+	DWORD m_dwLastSkillTime; ///<  skill   Ã°(millisecond).
+	// End of Skill
+
+	// MOB_SKILL
+public:
+	bool HasMobSkill() const;
+	size_t CountMobSkill() const;
+	const TMobSkillInfo* GetMobSkill(unsigned int idx) const;
+	bool CanUseMobSkill(unsigned int idx) const;
+	bool UseMobSkill(unsigned int idx);
+	void ResetMobSkillCooltime();
+protected:
+	DWORD m_adwMobSkillCooltime[MOB_SKILL_MAX_NUM];
+	// END_OF_MOB_SKILL
+
+	// for SKILL_MUYEONG
+public:
+	void StartMuyeongEvent();
+	void StopMuyeongEvent();
+
+#if defined(__PVP_BALANCE_IMPROVING__)
+	void StartGyeongGongEvent();
+	void StopGyeongGongEvent();
+#endif
+
+#if defined(__9TH_SKILL__)
+	void StartCheonunEvent(BYTE bChance, BYTE bDuration);
+	void StopCheonunEvent();
+#endif
+
+private:
+	LPEVENT m_pkMuyeongEvent;
+#ifdef ENABLE_QUEEN_NETHIS
+	LPEVENT m_pkSnakeSkillEvent;
+#endif
+#if defined(__PVP_BALANCE_IMPROVING__)
+	LPEVENT m_pkGyeongGongEvent;
+#endif
+#if defined(__9TH_SKILL__)
+	LPEVENT m_pkCheonunEvent;
+#endif
+
+	// for SKILL_CHAIN lighting
+public:
+	int GetChainLightningIndex() const { return m_iChainLightingIndex; }
+	void IncChainLightningIndex() { ++m_iChainLightingIndex; }
+	void AddChainLightningExcept(LPCHARACTER ch) { m_setExceptChainLighting.insert(ch); }
+	void ResetChainLightningIndex() { m_iChainLightingIndex = 0; m_setExceptChainLighting.clear(); }
+	int GetChainLightningMaxCount() const;
+	const CHARACTER_SET& GetChainLightingExcept() const { return m_setExceptChainLighting; }
+
+private:
+	int m_iChainLightingIndex;
+	CHARACTER_SET m_setExceptChainLighting;
+
+	// for SKILL_EUNHYUNG
+public:
+	void SetAffectedEunhyung();
+	void ClearAffectedEunhyung() { m_dwAffectedEunhyungLevel = 0; }
+	bool GetAffectedEunhyung() const { return m_dwAffectedEunhyungLevel; }
+
+private:
+	DWORD m_dwAffectedEunhyungLevel;
+
+	//
+	// Skill levels
+	//
+protected:
+	TPlayerSkill* m_pSkillLevels;
+	std::unordered_map<BYTE, int> m_SkillDamageBonus;
+	std::map<int, TSkillUseInfo> m_SkillUseInfo;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// AI related
+public:
+	void AssignTriggers(const TMobTable* table);
+	LPCHARACTER GetVictim() const; //   
+	void SetVictim(LPCHARACTER pkVictim);
+	LPCHARACTER GetNearestVictim(LPCHARACTER pkChr);
+	LPCHARACTER GetProtege() const; // È£Ø¾   
+
+	bool Follow(LPCHARACTER pkChr, float fMinimumDistance = 150.0f);
+	bool Return();
+	bool IsGuardNPC() const;
+	bool IsChangeAttackPosition(LPCHARACTER target) const;
+	void ResetChangeAttackPositionTime() { m_dwLastChangeAttackPositionTime = get_dword_time() - AI_CHANGE_ATTACK_POISITION_TIME_NEAR; }
+	void SetChangeAttackPositionTime() { m_dwLastChangeAttackPositionTime = get_dword_time(); }
+
+	bool OnIdle();
+
+	void OnAttack(LPCHARACTER pkChrAttacker);
+	void OnClick(LPCHARACTER pkChrCauser);
+
+	VID m_kVIDVictim;
+
+protected:
+	DWORD m_dwLastChangeAttackPositionTime;
+	CTrigger m_triggerOnClick;
+	// End of AI
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Target
+protected:
+	LPCHARACTER m_pkChrTarget; //  Å¸
+	DWORD m_dwTargetVID; // Safe target resolution (VID snapshot)
+	CHARACTER_SET m_set_pkChrTargetedBy; //  Å¸  Ö´ 
+
+public:
+	void SetTarget(LPCHARACTER pkChrTarget);
+	void BroadcastTargetPacket();
+	void ClearTarget();
+	void CheckTarget();
+	LPCHARACTER GetTarget() const { return m_pkChrTarget; }
+	LPCHARACTER GetTargetSafe();
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Safebox
+public:
+	int GetSafeboxSize() const;
+	void QuerySafeboxSize();
+	void SetSafeboxSize(int size);
+
+	CSafebox* GetSafebox() const;
+	void LoadSafebox(int iSize, DWORD dwGold, int iItemCount, TPlayerItem* pItems);
+	void ChangeSafeboxSize(BYTE bSize);
+	void CloseSafebox();
+
+	/// Ã¢  Ã»
+	/**
+	* @param [in] pszPassword 1 Ì» 6  Ã¢ Ð¹È£
+	*
+	* DB  Ã¢â¸¦ Ã»Ñ´.
+	* Ã¢ ßº  Ï¸, Ö± Ã¢  Ã°  10 Ì³   Ñ´.
+	**/
+	void ReqSafeboxLoad(const char* pszPassword);
+
+	/// Ã¢  Ã» 
+	/**
+	* ReqSafeboxLoad  È£Ï° CloseSafebox  Ê¾   Ô¼ È£Ï¸ Ã¢   Ö´.
+	* Ã¢ Ã» DB   Þ¾   Ô¼ Ø¼ Ã»   Ö° Ø´.
+	**/
+	void CancelSafeboxLoad(void) { m_bOpeningSafebox = false; }
+
+	void SetMallLoadTime(int t) { m_iMallLoadTime = t; }
+	int GetMallLoadTime() const { return m_iMallLoadTime; }
+
+	CSafebox* GetMall() const;
+	void LoadMall(int iItemCount, TPlayerItem* pItems);
+	void CloseMall();
+
+	void SetSafeboxOpenPosition();
+	float GetDistanceFromSafeboxOpen() const;
+
+	void LoadSafeboxBuff();
+	void SetSafeboxBuff();
+
+protected:
+	CSafebox* m_pkSafebox;
+	int m_iSafeboxSize;
+	int m_iSafeboxLoadTime;
+	bool m_bOpeningSafebox; ///< Ã¢  Ã» Ì°Å³ Ö´Â° , true   Ã»Ì°Å³ .
+
+	CSafebox* m_pkMall;
+	int m_iMallLoadTime;
+
+	PIXEL_POSITION m_posSafeboxOpen;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Mounting
+public:
+	void UnMount(bool bUnequipItem = false);
+	void MountVnum(DWORD vnum);
+	DWORD GetMountVnum() const { return m_dwMountVnum; }
+	DWORD GetLastMountTime() const { return m_dwMountTime; }
+
+	bool CanUseHorseSkill();
+
+	// Horse
+	virtual void SetHorseLevel(int iLevel);
+
+	virtual bool StartRiding();
+	virtual bool StopRiding();
+
+	virtual DWORD GetMyHorseVnum() const;
+
+	virtual void HorseDie();
+	virtual bool ReviveHorse();
+
+	virtual void SendHorseInfo();
+	virtual void ClearHorseInfo();
+
+	void HorseSummon(bool bSummon, bool bFromFar = false, DWORD dwVnum = 0, const char* pHorseName = 0);
+
+	LPCHARACTER GetHorse() const { return m_chHorse; } //  È¯ 
+	LPCHARACTER GetRider() const; // rider on horse
+	void SetRider(LPCHARACTER ch);
+
+	bool IsRiding() const;
+
+#if defined(__PET_SYSTEM__)
+public:
+	CPetSystem* GetPetSystem() { return m_petSystem; }
+
+protected:
+	CPetSystem* m_petSystem;
+
+public:
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+public:
+	bool	IsPet() const { return m_bCharType == CHAR_TYPE_PET_PAY; }
+	bool	IsGrowthPet() { return m_bCharType == CHAR_TYPE_PET; };
+	void	SetInvincible(bool bInvincible) { m_bInvincible = bInvincible; }
+	bool	IsInvincible() { return m_bInvincible; }
+
+	void	SetPetHatchWindow(bool bState) { m_bIsPetHatchOpen = bState; }
+	bool	IsPetHatchWindowOpen() { return m_bIsPetHatchOpen; }
+	void	SetPetChangeNameWindow(bool bState) { m_bIsPetChangeNameOpen = bState; }
+	bool	IsPetChangeNameWindowOpen() { return m_bIsPetChangeNameOpen; }
+
+	void	SetPetWindowType(BYTE bType) { m_bPetWindowType = bType; }
+	BYTE	GetPetWindowType() const { return m_bPetWindowType; }
+
+	void	SetGrowthPetLoaded(bool bState) { m_bIsGrowthPetLoaded = bState; }
+	bool	IsGrowthPetLoaded() { return m_bIsGrowthPetLoaded; }
+
+	void	SetCharacterSize(BYTE bSize) { m_bCharacterSize = bSize; }
+	BYTE	GetCharacterSize() { return m_bCharacterSize; }
+
+	bool			SetGrowthPet(LPGROWTH_PET pkPet);
+	bool			DeleteGrowthPet(DWORD dwID);
+	LPGROWTH_PET	GetGrowthPet(DWORD dwID);
+	void			ClearGrowthPet();
+
+	void			SetActiveGrowthPet(LPGROWTH_PET pkPet) { m_activeGrowthPet = pkPet;  }
+	LPGROWTH_PET	GetActiveGrowthPet() { return m_activeGrowthPet; }
+
+private:
+	DWORD	m_bInvincible;
+	bool	m_bIsPetHatchOpen;
+	bool	m_bIsPetChangeNameOpen;
+	BYTE	m_bPetWindowType;
+
+	bool	m_bIsGrowthPetLoaded;
+
+	CGrowthPetManager::TGrowthPetMap m_growthPetMap;
+	LPGROWTH_PET m_activeGrowthPet;
+
+	BYTE m_bCharacterSize;
+#endif
+
+protected:
+	LPCHARACTER m_chHorse;
+	LPCHARACTER m_chRider;
+
+	DWORD m_dwMountVnum;
+	DWORD m_dwMountTime;
+
+	BYTE m_bSendHorseLevel;
+	BYTE m_bSendHorseHealthGrade;
+	BYTE m_bSendHorseStaminaGrade;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Detailed Log
+public:
+	void DetailLog() { m_bDetailLog = !m_bDetailLog; }
+	void ToggleMonsterLog();
+	void MonsterLog(const char* format, ...);
+
+private:
+	bool m_bDetailLog;
+	bool m_bMonsterLog;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Empire
+public:
+	void SetEmpire(BYTE bEmpire);
+	BYTE GetEmpire() const { return m_bEmpire; }
+
+protected:
+	BYTE m_bEmpire;
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Regen
+public:
+	void SetRegen(LPREGEN pkRegen);
+
+protected:
+	PIXEL_POSITION m_posRegen;
+	float m_fRegenAngle;
+	LPREGEN m_pkRegen;
+	size_t regen_id_; // to help dungeon regen identification
+	// End of Regen
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// Resists & Proofs
+public:
+	bool CannotMoveByAffect() const; // Æ¯ È¿     Î°?
+	bool IsImmune(DWORD dwImmuneFlag);
+	void SetImmuneFlag(DWORD dw) { m_pointsInstant.dwImmuneFlag = dw; }
+
+protected:
+	void ApplyMobAttribute(const TMobTable* table);
+	// End of Resists & Proofs
+
+	////////////////////////////////////////////////////////////////////////////////////////
+	// QUEST
+public:
+	void SetQuestNPCID(DWORD vid);
+	DWORD GetQuestNPCID() const { return m_dwQuestNPCVID; }
+	LPCHARACTER GetQuestNPC() const;
+
+	void SetQuestItemPtr(LPITEM item);
+	void ClearQuestItemPtr();
+	LPITEM GetQuestItemPtr() const;
+
+	void SetQuestBy(DWORD dwQuestVnum) { m_dwQuestByVnum = dwQuestVnum; }
+	DWORD GetQuestBy() const { return m_dwQuestByVnum; }
+
+	int GetQuestFlag(const std::string& flag) const;
+	void SetQuestFlag(const std::string& flag, int value);
+
+	void ConfirmWithMsg(const char* szMsg, int iTimeout, DWORD dwRequestPID);
+	bool IsRunningQuest() const;
+
+private:
+	DWORD m_dwQuestNPCVID;
+	DWORD m_dwQuestByVnum;
+	LPITEM m_pQuestItem;
+
+	// Events
+public:
+	bool StartStateMachine(int iPulse = 1);
+	void StopStateMachine();
+	void UpdateStateMachine(DWORD dwPulse);
+	void SetNextStatePulse(int iPulseNext);
+
+	// Ä³ Î½Ï½ Æ® Ô¼.  Ì» Ó± CFSM::Update Ô¼ È£Ï°Å³ UpdateStateMachine Ô¼ ß´Âµ,  Æ® Ô¼ ß°.
+	void UpdateCharacter(DWORD dwPulse);
+
+protected:
+	DWORD m_dwNextStatePulse;
+
+	// Marriage
+public:
+	LPCHARACTER GetMarryPartner() const;
+	void SetMarryPartner(LPCHARACTER ch);
+	int GetMarriageBonus(DWORD dwItemVnum, bool bSum = true);
+
+	bool IsWearingDress() const;
+
+	void SetWeddingMap(marriage::WeddingMap* pMap);
+	marriage::WeddingMap* GetWeddingMap() const { return m_pWeddingMap; }
+
+private:
+	marriage::WeddingMap* m_pWeddingMap;
+	LPCHARACTER m_pkChrMarried;
+
+	// Warp Character
+public:
+	void StartWarpNPCEvent();
+
+public:
+	void StartSaveEvent();
+	void StartRecoveryEvent();
+	void StartCheckSpeedHackEvent();
+	void StartDestroyWhenIdleEvent();
+
+	LPEVENT m_pkDeadEvent;
+	LPEVENT m_pkStunEvent;
+	LPEVENT m_pkSaveEvent;
+	LPEVENT m_pkRecoveryEvent;
+	LPEVENT m_pkTimedEvent;
+	LPEVENT m_pkFishingEvent;
+	LPEVENT m_pkAffectEvent;
+	LPEVENT m_pkPoisonEvent;
+	LPEVENT m_pkBleedingEvent;
+	LPEVENT m_pkFireEvent;
+#if defined(__DAWNMIST_DUNGEON__)
+	LPEVENT m_pkHealEvent;
+#endif
+	LPEVENT m_pkWarpNPCEvent;
+	// DELAYED_WARP
+	// END_DELAYED_WARP
+
+	// MINING
+	LPEVENT m_pkMiningEvent;
+	// END_OF_MINING
+	LPEVENT m_pkWarpEvent;
+	LPEVENT m_pkCheckSpeedHackEvent;
+	LPEVENT m_pkDestroyWhenIdleEvent;
+	LPEVENT m_pkPetSystemUpdateEvent;
+
+	bool IsWarping() const { return m_pkWarpEvent ? true : false; }
+
+	bool m_bHasPoisoned;
+	bool m_bHasBled;
+
+	const CMob* m_pkMobData;
+	CMobInstance* m_pkMobInst;
+
+	MobSkillEventMap m_mapMobSkillEvent;
+
+	friend struct FuncSplashDamage;
+	friend struct FuncSplashAffect;
+	friend class CFuncShoot;
+
+public:
+	int GetPremiumRemainSeconds(BYTE bType) const;
+
+private:
+	int m_aiPremiumTimes[PREMIUM_MAX_NUM];
+
+	// CHANGE_ITEM_ATTRIBUTES
+	static const DWORD msc_dwDefaultChangeItemAttrCycle; ///< Æ®  Ó¼  Ö±
+	static const char msc_szLastChangeItemAttrFlag[]; ///< Ö±  Ó¼  Ã° Quest Flag Ì¸
+	static const char msc_szChangeItemAttrCycleFlag[]; ///<  Ó¼  Ö± Quest Flag Ì¸
+	// END_OF_CHANGE_ITEM_ATTRIBUTES
+
+	// PC_BANG_ITEM_ADD
+private:
+	bool m_isinPCBang;
+
+public:
+	bool SetPCBang(bool flag) { m_isinPCBang = flag; return m_isinPCBang; }
+	bool IsPCBang() const { return m_isinPCBang; }
+	// END_PC_BANG_ITEM_ADD
+
+	// NEW_HAIR_STYLE_ADD
+public:
+	bool ItemProcess_Hair(LPITEM item, int iDestCell);
+	// END_NEW_HAIR_STYLE_ADD
+
+public:
+	void ClearSkill();
+	void ClearSubSkill();
+
+	// RESET_ONE_SKILL
+	bool ResetOneSkill(DWORD dwVnum);
+	// END_RESET_ONE_SKILL
+
+private:
+	void SendDamagePacket(LPCHARACTER pAttacker, int Damage, BYTE DamageFlag);
+
+	// ARENA
+private:
+	CArena* m_pArena;
+	bool m_ArenaObserver;
+	int m_nPotionLimit;
+
+public:
+	void SetArena(CArena* pArena) { m_pArena = pArena; }
+	void SetArenaObserverMode(bool flag) { m_ArenaObserver = flag; }
+
+	CArena* GetArena() const { return m_pArena; }
+	bool GetArenaObserverMode() const { return m_ArenaObserver; }
+
+	void SetPotionLimit(int count) { m_nPotionLimit = count; }
+	int GetPotionLimit() const { return m_nPotionLimit; }
+	// END_ARENA
+
+	// PREVENT_TRADE_WINDOW
+public:
+	bool IsOpenSafebox() const { return m_isOpenSafebox ? true : false; }
+	void SetOpenSafebox(bool b) { m_isOpenSafebox = b; }
+
+	int GetSafeboxLoadTime() const { return m_iSafeboxLoadTime; }
+	void SetSafeboxLoadTime() { m_iSafeboxLoadTime = thecore_pulse(); }
+
+private:
+	bool m_isOpenSafebox;
+	// END_PREVENT_TRADE_WINDOW
+
+public:
+	int GetSkillPowerByLevel(int iLevel, bool bMob = false) const;
+
+	// PREVENT_REFINE_HACK
+	int GetRefineTime() const { return m_iRefineTime; }
+	void SetRefineTime() { m_iRefineTime = thecore_pulse(); }
+	int m_iRefineTime;
+	// END_PREVENT_REFINE_HACK
+
+	// RESTRICT_USE_SEED_OR_MOONBOTTLE
+	int GetUseSeedOrMoonBottleTime() const { return m_iSeedTime; }
+	void SetUseSeedOrMoonBottleTime() { m_iSeedTime = thecore_pulse(); }
+	int m_iSeedTime;
+	// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
+
+	// PREVENT_PORTAL_AFTER_EXCHANGE
+	int GetExchangeTime() const { return m_iExchangeTime; }
+	void SetExchangeTime() { m_iExchangeTime = thecore_pulse(); }
+	int m_iExchangeTime;
+	// END_PREVENT_PORTAL_AFTER_EXCHANGE
+
+	int m_iMyShopTime;
+	int GetMyShopTime() const { return m_iMyShopTime; }
+	void SetMyShopTime() { m_iMyShopTime = thecore_pulse(); }
+
+	// PREVENT_TRADE_WINDOW
+	bool PreventTradeWindow(int flags, bool except = false) const;
+	// END_PREVENT_TRADE_WINDOW
+
+	// Hack   Ã¼Å©.
+	bool IsHack(bool bSendMsg = true, bool bCheckShopOwner = true, int limittime = g_nPortalLimitTime);
+
+	// MONARCH
+	BOOL IsMonarch() const;
+	// END_MONARCH
+	void Say(const std::string& s);
+
+	enum MONARCH_COOLTIME
+	{
+		MC_HEAL = 10,
+		MC_WARP = 60,
+		MC_TRANSFER = 60,
+		MC_TAX = (60 * 60 * 24 * 7),
+		MC_SUMMON = (60 * 60),
+	};
+
+	enum MONARCH_INDEX
+	{
+		MI_HEAL = 0,
+		MI_WARP,
+		MI_TRANSFER,
+		MI_TAX,
+		MI_SUMMON,
+		MI_MAX
+	};
+
+	DWORD m_dwMonarchCooltime[MI_MAX];
+	DWORD m_dwMonarchCooltimelimit[MI_MAX];
+
+	void InitMC();
+	DWORD GetMC(enum MONARCH_INDEX e) const;
+	void SetMC(enum MONARCH_INDEX e);
+	bool IsMCOK(enum MONARCH_INDEX e) const;
+	DWORD GetMCL(enum MONARCH_INDEX e) const;
+	DWORD GetMCLTime(enum MONARCH_INDEX e) const;
+
+public:
+	bool ItemProcess_Polymorph(LPITEM item);
+
+#if !defined(__CUBE_RENEWAL__)
+	// by mhh
+	LPITEM* GetCubeItem() { return m_pointsInstant.pCubeItems; }
+#endif
+#endif
+	bool IsCubeOpen() const { return (m_pointsInstant.pCubeNpc ? true : false); }
+	void SetCubeNpc(LPCHARACTER npc) { m_pointsInstant.pCubeNpc = npc; }
+	LPCHARACTER GetCubeNpc() const { return m_pointsInstant.pCubeNpc; }
+	bool CanDoCube() const;
+
+public:
+	bool IsSiegeNPC() const;
+
+private:
+	// ß± 
+	// 18 Ì¸ 
+	// 3Ã° : 50 % 5 Ã° 0%
+	e_overtime m_eOverTime;
+
+public:
+	bool IsOverTime(e_overtime e) const { return (e == m_eOverTime); }
+	void SetOverTime(e_overtime e) { m_eOverTime = e; }
+
+private:
+	int m_deposit_pulse;
+
+public:
+	void UpdateDepositPulse();
+	bool CanDeposit() const;
+
+private:
+	void __OpenPrivateShop();
+
+public:
+	struct AttackedLog
+	{
+		DWORD dwPID;
+		DWORD dwAttackedTime;
+
+		AttackedLog() : dwPID(0), dwAttackedTime(0)
+		{
+		}
+	};
+
+	AttackLog m_kAttackLog;
+	AttackedLog m_AttackedLog;
+	int m_speed_hack_count;
+
+private:
+	std::string m_strNewName;
+
+public:
+	const std::string GetNewName() const { return this->m_strNewName; }
+	void SetNewName(const std::string name) { this->m_strNewName = name; }
+
+public:
+	void GoHome();
+
+private:
+	std::set<DWORD> m_known_guild;
+
+public:
+	void SendGuildName(CGuild* pGuild);
+	void SendGuildName(DWORD dwGuildID);
+
+private:
+	DWORD m_dwLogOffInterval;
+	DWORD m_dwLastPlay;
+
+public:
+	DWORD GetLogOffInterval() const { return m_dwLogOffInterval; }
+	DWORD GetLastPlay() const { return m_dwLastPlay; }
+
+public:
+	bool UnEquipSpecialRideUniqueItem();
+
+	bool CanWarp() const;
+	bool IsInSafezone() const;
+	bool IsInBlockedArea(long x = 0, long y = 0) const;
+
+private:
+	DWORD m_dwLastGoldDropTime;
+#if defined(__CHEQUE_SYSTEM__)
+	DWORD m_dwLastChequeDropTime;
+#endif
+
+public:
+	void AutoRecoveryItemProcess(const EAffectTypes);
+
+public:
+	void BuffOnAttr_AddBuffsFromItem(LPITEM pItem);
+	void BuffOnAttr_RemoveBuffsFromItem(LPITEM pItem);
+
+private:
+	void BuffOnAttr_ValueChange(POINT_TYPE wPointType, POINT_VALUE lOldValue, POINT_VALUE lNewValue);
+	void BuffOnAttr_ClearAll();
+
+	typedef std::map<DWORD, CBuffOnAttributes*> TMapBuffOnAttrs;
+	TMapBuffOnAttrs m_map_buff_on_attrs;
+	//  : È° ×½Æ® Ï¿.
+
+public:
+	void SetArmada() { cannot_dead = true; }
+	void ResetArmada() { cannot_dead = false; }
+
+private:
+	bool cannot_dead;
+
+#if defined(__PET_SYSTEM__)
+private:
+	bool m_bIsPet;
+
+public:
+	void SetPet() { m_bIsPet = true; }
+	bool IsPet() { return m_bIsPet; }
+#endif
+
+	//   .
+private:
+	float m_fAttMul;
+	float m_fDamMul;
+
+public:
+	float GetAttMul() { return this->m_fAttMul; }
+	void SetAttMul(float newAttMul) { this->m_fAttMul = newAttMul; }
+	float GetDamMul() { return this->m_fDamMul; }
+	void SetDamMul(float newDamMul) { this->m_fDamMul = newDamMul; }
+
+private:
+	bool IsValidItemPosition(TItemPos Pos) const;
+
+	//    Å¶ Ó½ 
+private:
+	unsigned int itemAward_vnum;
+	char itemAward_cmd[20];
+	//bool itemAward_flag;
+public:
+	unsigned int GetItemAward_vnum() { return itemAward_vnum; }
+	char* GetItemAward_cmd() { return itemAward_cmd; }
+	//bool GetItemAward_flag() { return itemAward_flag; }
+	void SetItemAward_vnum(unsigned int vnum) { itemAward_vnum = vnum; }
+	void SetItemAward_cmd(char* cmd) { strlcpy(itemAward_cmd, cmd ? cmd : "", sizeof(itemAward_cmd)); }
+	//void SetItemAward_flag(bool flag) { itemAward_flag = flag; }
+
+#if defined(__MOVE_COSTUME_ATTR__)
+public:
+	void ItemCombination(const short MediumIndex, const short BaseIndex, const short MaterialIndex);
+	void OpenItemComb();
+
+	bool IsItemComb() const { return m_pointsInstant.pItemCombNpc != NULL; }
+	void SetItemCombNpc(const LPCHARACTER npc) { m_pointsInstant.pItemCombNpc = npc; }
+#endif
+
+#if defined(__CHANGED_ATTR__)
+public:
+	void SelectAttr(LPITEM material, LPITEM item);
+	void SelectAttrResult(const bool bNew, const TItemPos& pos);
+	bool IsSelectAttr() const;
+private:
+	struct SItemSelectAttr
+	{
+		DWORD dwItemID;
+		TPlayerItemAttribute Attr[ITEM_ATTRIBUTE_MAX_NUM];
+	} m_ItemSelectAttr;
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__)
+public:
+	void MiniGameCatchKingSetFieldCards(std::vector<TCatchKingCard> vec) { m_vecCatchKingFieldCards = vec; }
+
+	DWORD MiniGameCatchKingGetScore() const { return dwCatchKingTotalScore; }
+	void MiniGameCatchKingSetScore(DWORD dwScore) { dwCatchKingTotalScore = dwScore; }
+
+	DWORD MiniGameCatchKingGetBetNumber() const { return bCatchKingBetSetNumber; }
+	void MiniGameCatchKingSetBetNumber(BYTE bSetNr) { bCatchKingBetSetNumber = bSetNr; }
+
+	BYTE MiniGameCatchKingGetHandCard() const { return bCatchKingHandCard; }
+	void MiniGameCatchKingSetHandCard(BYTE bKingCard) { bCatchKingHandCard = bKingCard; }
+
+	BYTE MiniGameCatchKingGetHandCardLeft() const { return bCatchKingHandCardLeft; }
+	void MiniGameCatchKingSetHandCardLeft(BYTE bHandCard) { bCatchKingHandCardLeft = bHandCard; }
+
+	bool MiniGameCatchKingGetGameStatus() const { return dwCatchKingGameStatus; }
+	void MiniGameCatchKingSetGameStatus(bool bStatus) { dwCatchKingGameStatus = bStatus; }
+
+	std::vector<TCatchKingCard> m_vecCatchKingFieldCards;
+
+protected:
+	BYTE bCatchKingHandCard;
+	BYTE bCatchKingHandCardLeft;
+	bool dwCatchKingGameStatus;
+
+	BYTE bCatchKingBetSetNumber;
+	DWORD dwCatchKingTotalScore;
+#endif
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+public:
+	// È¥
+
+	// Ä³ affect, quest load Ç±  DragonSoul_Initialize È£Ï¸ ÈµÈ´.
+	// affect   ÎµÇ¾ LoadAffect È£.
+	void DragonSoul_Initialize();
+
+	bool DragonSoul_IsQualified() const;
+	void DragonSoul_GiveQualification();
+
+	int DragonSoul_GetActiveDeck() const;
+	bool DragonSoul_IsDeckActivated() const;
+	bool DragonSoul_ActivateDeck(int iDeckIdx);
+
+	void DragonSoul_DeactivateAll();
+	// Ýµ ClearItem  Ò· Ñ´.
+	// Ö³Ï¸....
+	// È¥ Ï³ Ï³ deactivate   active È¥ Ö´ È®Ï°,
+	// active È¥ Ï³ Ù¸, Ä³ È¥ affect, È° Â¸ Ñ´.
+	// 
+	//  ClearItem , Ä³Í° Ï° Ö´   unequipÏ´ Ù¶,
+	// È¥ Affect ÅµÇ°, á±¹ Î± , È¥ È°È­ Ê´Â´.
+	// (Unequip  Î±×¾Æ¿ , Æ´   .)
+	// È¥ deactivateÅ° Ä³ È¥  È° Â´ Çµå¸® Ê´Â´.
+	void DragonSoul_CleanUp();
+
+#if defined(__DS_SET__)
+	// Dragon Soul Set Bonus
+public:
+	void DragonSoul_SetBonus();
+	void DragonSoul_ActivateAll();
+#endif
+
+	// È¥ È­Ã¢
+public:
+	bool DragonSoul_RefineWindow_Open(LPENTITY pEntity);
+#if defined(__DS_CHANGE_ATTR__)
+	bool DragonSoul_RefineWindow_ChangeAttr_Open(LPENTITY pEntity);
+#endif
+	bool DragonSoul_RefineWindow_Close();
+	LPENTITY DragonSoul_RefineWindow_GetOpener() { return m_pointsInstant.m_pDragonSoulRefineWindowOpener; }
+	bool DragonSoul_RefineWindow_CanRefine();
+#endif
+
+private:
+	// SyncPosition Ç¿Ï¿ Å¸ Ì»    Ï± Ï¿,
+	// SyncPosition Ï¾î³¯  .
+	timeval m_tvLastSyncTime;
+	int m_iSyncHackCount;
+
+	// [Anti-Abuse] SyncPosition packet spam tracking (CPU burner mitigation)
+	DWORD m_dwSyncPosWindowStart;
+	int m_iSyncPosPacketCount;
+	int m_iSyncPosSpamStrikes;
+	long m_lSyncPosLastX;
+	long m_lSyncPosLastY;
+public:
+	void SetLastSyncTime(const timeval& tv) { memcpy(&m_tvLastSyncTime, &tv, sizeof(timeval)); }
+	const timeval& GetLastSyncTime() { return m_tvLastSyncTime; }
+	void SetSyncHackCount(int iCount) { m_iSyncHackCount = iCount; }
+	int GetSyncHackCount() { return m_iSyncHackCount; }
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+public:
+	void SetChangeLook(CChangeLook* c);
+	CChangeLook* GetChangeLook() const;
+protected:
+	CChangeLook* m_pkChangeLook;
+#endif
+
+#if defined(__MAILBOX__)
+public:
+	int GetMyMailBoxTime() const { return m_iMyMailBoxTime; }
+	void SetMyMailBoxTime() { m_iMyMailBoxTime = thecore_pulse(); }
+
+	void SetMailBox(CMailBox* m);
+
+	void SetMailBoxLoading(const bool b) { bMailBoxLoading = b; }
+	bool IsMailBoxLoading() const { return bMailBoxLoading; }
+
+	CMailBox* GetMailBox() const { return m_pkMailBox; }
+
+private:
+	CMailBox* m_pkMailBox;
+	bool bMailBoxLoading;
+	int m_iMyMailBoxTime;
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+public:
+	void SetMiniGameRumi(CMiniGameRumi* pClass);
+	CMiniGameRumi* GetMiniGameRumi() const { return m_pkMiniGameRumi; }
+private:
+	CMiniGameRumi* m_pkMiniGameRumi;
+#endif
+
+#if defined(__CONQUEROR_LEVEL__)
+public:
+	bool IsNewWorldMapIndex() const;
+	long GetNewWorldSungMa(POINT_TYPE wPointType, bool bPremium = true) const;
+	bool IsSungMaCursed(POINT_TYPE wPointType) const;
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+public:
+	CLootFilter* GetLootFilter();
+	void SetLootFilter();
+	void ClearLootFilter();
+private:
+	CLootFilter* m_pLootFilter;
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+public:
+	bool IsOpenAttr67Add() const { return m_bIsOpenAttr67Add ? true : false; }
+	void SetOpenAttr67Add(bool bOpen) { m_bIsOpenAttr67Add = bOpen; }
+
+	LPITEM GetNPCStorageItem(BYTE bCell = 0) const;
+	bool Attr67Add(const TAttr67AddData kAttr67AddData);
+
+private:
+	bool m_bIsOpenAttr67Add;
+#endif
+
+#if defined(__FISHING_GAME__)
+public:
+	void SetFishingGameGoals(BYTE bCount) { m_bFishingGameGoals = bCount; }
+	BYTE GetFishingGameGoals() { return m_bFishingGameGoals; }
+private:
+	BYTE m_bFishingGameGoals;
+#endif
+
+#if defined(__GEM_SYSTEM__)
+public:
+	void SelectItemEx(DWORD dwInventoryPos, BYTE bType);
+	bool GemRefine(LPITEM lpMetinStoneItem);
+
+#	if defined(__GEM_SHOP__)
+public:
+	void SetGemShop(CGemShop* pGemShop);
+	CGemShop* GetGemShop() const { return m_pGemShop; }
+
+	void SetGemShopLoading(const bool c_bLoading) { m_bGemShopLoading = c_bLoading; }
+	bool IsGemShopLoading() const { return m_bGemShopLoading; }
+
+private:
+	CGemShop* m_pGemShop;
+	bool m_bGemShopLoading;
+#	endif
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	//////////////////////////////////////////////////////////////////////////////////
+	// Acce Costume System
+public:
+	void AcceRefineWindowOpen(const LPENTITY pEntity, BYTE bType);
+	void AcceRefineWindowClose(bool bServerClose = false);
+	bool IsAcceRefineWindowOpen() const { return m_bAcceRefineWindowOpen; }
+	bool GetAcceRefineWindowType() const { return m_bAcceRefineWindowType; }
+
+	bool IsAcceRefineWindowCanRefine();
+	LPENTITY GetAcceRefineWindowOpener() const { return m_pointsInstant.m_pAcceRefineWindowOpener; }
+
+	void AcceRefineWindowCheckIn(BYTE bType, TItemPos SelectedPos, TItemPos AttachedPos);
+	void AcceRefineWindowCheckOut(BYTE bType, TItemPos SelectedPos);
+	void AcceRefineWindowAccept(BYTE bType);
+
+	int GetAcceWeaponAttack() const;
+	int GetAcceWeaponMagicAttack() const;
+
+	void ModifyAccePoints(const LPITEM& rAcceItem, bool bAdd);
+
+protected:
+	int __CalculateAcceDrainValues(BYTE bWeaponAttackType) const;
+	int __CheckAcceRefineItem(const LPITEM& rLeftItem, const LPITEM& rRightItem) const;
+	BYTE __GetNextDrainRate(const LPITEM& rAcceItem, BYTE bMinDrainRate) const;
+
+private:
+	bool m_bAcceRefineWindowOpen;
+	BYTE m_bAcceRefineWindowType;
+	TItemPos m_pAcceRefineWindowItemSlot[ACCE_SLOT_MAX];
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+	//////////////////////////////////////////////////////////////////////////////////
+	// Aura Costume System
+public:
+	void OpenAuraRefineWindow(const LPENTITY pEntity, BYTE bType);
+	void AuraRefineWindowClose(bool bServerClose = false);
+	bool IsAuraRefineWindowOpen() const { return m_bAuraRefineWindowOpen; }
+	BYTE GetAuraRefineWindowType() const { return m_bAuraRefineWindowType; }
+
+	bool IsAuraRefineWindowCanRefine();
+	LPENTITY GetAuraRefineWindowOpener() const { return m_pointsInstant.m_pAuraRefineWindowOpener; }
+
+	void AuraRefineWindowCheckIn(BYTE bType, TItemPos SelectedPos, TItemPos AttachedPos);
+	void AuraRefineWindowCheckOut(BYTE bType, TItemPos SelectedPos);
+	void AuraRefineWindowAccept(BYTE bType);
+
+	void ModifyAuraPoints(const LPITEM& rAuraItem, bool bAdd);
+
+private:
+	BYTE m_bAuraRefineWindowType;
+	bool m_bAuraRefineWindowOpen;
+	TItemPos m_pAuraRefineWindowItemSlot[AURA_SLOT_MAX];
+	TAuraRefineInfo m_bAuraRefineInfo[AURA_REFINE_INFO_SLOT_MAX];
+
+protected:
+	TAuraRefineInfo __GetAuraRefineInfo(TItemPos Cell);
+	TAuraRefineInfo __CalcAuraRefineInfo(TItemPos Cell, TItemPos MaterialCell);
+	TAuraRefineInfo __GetAuraEvolvedRefineInfo(TItemPos Cell);
+#endif
+
+#if defined(__SOUL_SYSTEM__)
+public:
+	void SoulItemProcess(ESoulSubTypes eSubType);
+
+	int GetSoulDamage(ESoulSubTypes eSubType) const;
+	bool DoRefineSoul(LPITEM item);
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+public:
+	void SetExtendInvenStage(BYTE bStage) { m_bExtendInvenStage = bStage; }
+	BYTE GetExtendInvenStage() const { return m_bExtendInvenStage; }
+
+	WORD GetExtendInvenMax() const;
+
+	void ExtendInvenRequest();
+	void ExtendInvenUpgrade();
+
+	void SendExtendInvenPacket();
+
+private:
+	BYTE m_bExtendInvenStage;
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+public:
+	void StartHitBuffEvent();
+	void StopHitBuffEvent();
+private:
+	LPEVENT m_pHitBuffEvent;
+#endif
+
+#if defined(__CLIENT_TIMER__)
+public:
+	void SendClientTimer(BYTE bSubHeader, DWORD dwEndTime = 0, DWORD dwAlarmSec = 0);
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+public:
+	void AddEmote(const INT iEmoteIndex = -1);
+	void SetEmotes(const TPacketGDEmote* pTable, const WORD c_wSize);
+#endif
+
+#if defined(__SET_ITEM__)
+public:
+	using SetItemCountMap = std::map<BYTE, BYTE>;
+	SetItemCountMap GetItemSetCountMap() const;
+
+	void RefreshItemSetBonus();
+	void RefreshItemSetBonusByValue();
+#endif
+
+#if defined(__RACE_SWAP__)
+public:
+	void SetEventRaceNum(DWORD dwRaceNum);
+	DWORD GetEventRaceNum() const { return m_dwEventRaceNum; }
+private:
+	DWORD m_dwEventRaceNum;
+#endif
+
+#if defined(__GAME_OPTION_ESCAPE__)
+public:
+	void SetEscapeCooltime(const DWORD dwTime) { m_dwEscapeCooltime = dwTime; }
+	DWORD GetEscapeCooltime() const { return m_dwEscapeCooltime; }
+private:
+	DWORD m_dwEscapeCooltime;
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+public:
+	void RefineElementInformation(const LPITEM& rSrcItem, const TItemPos& kItemDestCell);
+	void RefineElement(WORD wElementType);
+
+	bool IsUnderRefineElement() const { return m_bUnderRefineElement; }
+	void SetUnderRefineElement(bool bState, BYTE bRefineType = 0, const TItemPos& rkSrcPos = NPOS, const TItemPos& rkDestPos = NPOS);
+
+	WORD GetRefineElementEffect() const;
+
+private:
+	struct SRefineElementItemPos
+	{
+		SRefineElementItemPos() : RefineType(0), SrcPos(NPOS), DestPos(NPOS) {}
+		BYTE RefineType;
+		TItemPos SrcPos, DestPos;
+	} m_kRefineElementItemPos;
+	bool m_bUnderRefineElement;
+#endif
+
+#if defined(__HIDE_COSTUME_SYSTEM__)
+public:
+	void SetHiddenCostumePart(BYTE bCostumeSubType, bool bHidden, bool bSave = true);
+	bool GetHiddenCostumeByPart(BYTE bPartPos) const;
+
+	void SetHiddenCostumeParts();
+private:
+	DWORD m_dwHideCostumePulse;
+	bool m_bHiddenCostumePart[COSTUME_NUM_TYPES];
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__)
+public:
+	void SetMiniGameYutnori(CMiniGameYutnori* pClass);
+	CMiniGameYutnori* GetMiniGameYutnori() const { return m_pkMiniGameYutnori; }
+private:
+	CMiniGameYutnori* m_pkMiniGameYutnori;
+#endif
+
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+public:
+	void SetCountry(const std::string& country) { m_stCountry = country; }
+	const char* GetCountry() const { return m_stCountry.c_str(); }
+
+protected:
+	std::string m_stCountry;
+#endif
+
+#if defined(__MYSHOP_DECO__)
+public:
+	void SetMyShopDecoState(BYTE bState) { m_bMyShopDecoState = bState; };
+	BYTE GetMyShopDecoState() const { return m_bMyShopDecoState; };
+
+	void SetMyShopDecoType(BYTE bShopType) { m_bMyShopDecoType = bShopType; };
+	BYTE GetMyShopDecoType() const { return m_bMyShopDecoType; };
+
+	void SetMyShopDecoPolyVnum(DWORD dwPolyVnum) { m_bMyShopDecoPolyVnum = dwPolyVnum; };
+	DWORD GetMyShopDecoPolyVnum() const { return m_bMyShopDecoPolyVnum; };
+
+	void SetMyPrivShopTabCount(BYTE bTabCount) { m_bMyPrivShopTabCount = bTabCount; };
+	BYTE GetMyPrivShopTabCount() const { return m_bMyPrivShopTabCount; };
+
+	void SetMyPrivShopIsCashItem(bool bIsCashItem) { m_bMyPrivShopIsCashItem = bIsCashItem; };
+	bool GetMyPrivShopIsCashItem() const { return m_bMyPrivShopIsCashItem; };
+
+	void OpenPrivateShop(BYTE bTabCount = 1, bool bIsCashItem = false);
+
+private:
+	BYTE m_bMyShopDecoState;
+	BYTE m_bMyShopDecoType;
+	DWORD m_bMyShopDecoPolyVnum;
+
+	BYTE m_bMyPrivShopTabCount;
+	bool m_bMyPrivShopIsCashItem;
+#endif
+
+#if defined(__LEFT_SEAT__)
+public:
+	void SetLeftSeat(bool bLeftSeat);
+	bool LeftSeat() const { return m_bLeftSeat; }
+
+	void SetLeftSeatWaitTime(BYTE bIndex);
+	DWORD GetLeftSeatWaitTime() const { return m_dwLeftSeatWaitTime; }
+
+	void SetLeftSeatLogoutTime(BYTE bIndex);
+	DWORD GetLeftSeatLogoutTime() const { return m_dwLeftSeatLogoutTime; }
+
+	void DisableLeftSeatLogOutState(bool bClosePopup = false);
+
+	void RestartLeftSeatWaitTimer();
+	void RestartLeftSeatLogoutTimer();
+
+	void SetLastRequestTime(DWORD dwRequestTime) { m_dwLastRequestTime = dwRequestTime; }
+	DWORD GetLastRequestTime() const { return m_dwLastRequestTime; }
+
+public:
+	LPEVENT m_pLeftSeatWaitTimerEvent;
+	LPEVENT m_pLeftSeatLogoutTimerEvent;
+
+private:
+	BOOL m_bLeftSeat;
+	DWORD m_dwLeftSeatWaitTime;
+	DWORD m_dwLeftSeatLogoutTime;
+	DWORD m_dwLastRequestTime;
+#endif
+
+#if defined(__ELEMENTAL_DUNGEON__)
+public:
+	void StartElementalCurseEvent();
+	void StopElementalCurseEvent();
+
+	void SetAccumulatedDamage(DWORD dwDamage);
+	DWORD GetAccumulatedDamage() const { return m_dwAccumulatedDamage; }
+
+private:
+	LPEVENT m_pElementalCurseEvent;
+	DWORD m_dwAccumulatedDamage;
+#endif
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+public:
+	void SetGuildDragonLair(CGuildDragonLair* pGuildDragonLair);
+	CGuildDragonLair* GetGuildDragonLair() const { return m_pGuildDragonLair; }
+private:
+	CGuildDragonLair* m_pGuildDragonLair;
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+public:
+	void SetMiniGameRoulette(CMiniGameRoulette* pMiniGameRoulette);
+	CMiniGameRoulette* GetMiniGameRoulette() const { return m_pMiniGameRoulette; }
+
+	void SetMiniGameRoulette_RewardMapperNum(BYTE bMapNum) { m_bMiniGameRoulette_RewardMapperNum = bMapNum; }
+	BYTE GetMiniGameRoulette_RewardMapperNum() const { return m_bMiniGameRoulette_RewardMapperNum; }
+
+private:
+	CMiniGameRoulette* m_pMiniGameRoulette;
+	BYTE m_bMiniGameRoulette_RewardMapperNum;
+#endif
+
+#if defined(__FLOWER_EVENT__)
+public:
+	void SetLastFlowerEventExchangePulse(DWORD dwPulse) { m_dwLastFlowerEventExchangePulse = dwPulse; }
+	DWORD GetLastFlowerEventExchangePulse() const { return m_dwLastFlowerEventExchangePulse; }
+private:
+	DWORD m_dwLastFlowerEventExchangePulse;
+#endif
+
+#if defined(__DEFENSE_WAVE__)
+public:
+	void SetDefenseWave(LPDEFENSE_WAVE pDefenseWave);
+	LPDEFENSE_WAVE GetDefenseWave() const;
+private:
+	LPDEFENSE_WAVE m_pDefenseWave;
+#endif
+
+#ifdef ENABLE_QUEEN_NETHIS
+public:
+	bool IsSnakeMap();
+#endif
+#ifdef __OFFLINE_SHOP__
+private:
+	uint32_t keepingOfflineShop_;
+
+	std::set<uint32_t> viewingOfflineShops_;
+
+	bool isOpeningOfflineShop_;
+	CItem* offlineShopOpeningItem_;
+
+public:
+	void SetKeepingOfflineShop(uint32_t keepingOfflineShop);
+	uint32_t GetKeepingOfflineShop() const;
+
+	void AddViewingOfflineShop(uint32_t id);
+	bool IsViewingOfflineShop();
+	void RemoveViewingOfflineShop(uint32_t id);
+	void RemoveFromViewingOfflineShops();
+
+	bool UseItemOpenOfflineShop(CItem* item);
+	void SetOpeningOfflineShopState(bool isOpeningOfflineShop);
+	bool IsOpeningOfflineShop() const;
+	void SetOfflineShopOpeningItem(CItem* item);
+	CItem* GetOfflineShopOpeningItem() const;
+	bool IsAffectOfflineShopDecoration();
+	void WarpToShop(long x, long y, long mapIndex, BYTE channel);
+
+private:
+	std::map<std::string, int> m_protection_Time;
+
+public:
+	int GetProtectTime(const std::string& flagname) const;
+	void SetProtectTime(const std::string& flagname, int time);
+
+public:
+	void	AddToSellHistory(TMySellHistory newItem);
+	void	SaveSellHistory();
+	void	RequestSellHistory(BYTE bPage);
+	void	SetSellHistoryLoaded(BYTE bStatus) {  m_bSellHistoryLoaded = bStatus; }
+	BYTE	GetSellHistoryLoaded() { return m_bSellHistoryLoaded; }
+protected:
+	BYTE	m_bSellHistoryLoaded;
+	std::vector<TMySellHistory> m_vecSellHistory;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+typedef std::list<TPlayerExtBattlePassMission*> ListExtBattlePassMap;
+public:
+	void LoadExtBattlePass(DWORD dwCount, TPlayerExtBattlePassMission* data);
+	DWORD GetExtBattlePassMissionProgress(DWORD dwBattlePassType, BYTE bMissionIndex, BYTE bMissionType);
+	bool IsExtBattlePassCompletedMission(DWORD dwBattlePassType, BYTE bMissionIndex, BYTE bMissionType);
+	bool IsExtBattlePassRegistered(BYTE bBattlePassType, DWORD dwBattlePassID);
+	void UpdateExtBattlePassMissionProgress(DWORD dwMissionID, DWORD dwUpdateValue, DWORD dwCondition, bool isOverride = false);
+	void SetExtBattlePassMissionProgress(BYTE bBattlePassType, DWORD dwMissionIndex, DWORD dwMissionType, DWORD dwUpdateValue);
+	
+	bool		IsLoadedExtBattlePass()		const	{ return m_bIsLoadedExtBattlePass; }
+	int			GetExtBattlePassPremiumID()	const	{ return m_points.battle_pass_premium_id;	}
+	void		SetExtBattlePassPremiumID(int battle_pass_premium_id)	{ m_points.battle_pass_premium_id = battle_pass_premium_id;}
+
+	void				SetLastReciveExtBattlePassInfoTime(DWORD time);
+	DWORD			GetLastReciveExtBattlePassInfoTime() const	{ return m_dwLastReciveExtBattlePassInfoTime; }
+	void				SetLastReciveExtBattlePassOpenRanking(DWORD time);
+	DWORD			GetLastReciveExtBattlePassOpenRanking() const	{ return m_dwLastExtBattlePassOpenRankingTime; }
+protected:
+	DWORD	m_dwLastReciveExtBattlePassInfoTime;
+	DWORD	m_dwLastExtBattlePassOpenRankingTime;
+	
+private:
+	bool m_bIsLoadedExtBattlePass;
+	ListExtBattlePassMap m_listExtBattlePass;
+#endif
+};
+
+ESex GET_SEX(LPCHARACTER ch);
+
+#endif // __INC_CHAR_H__
diff --git a/server/metin2/Source/Server/game/src/char_item.cpp b/server/metin2/Source/Server/game/src/char_item.cpp
index d8c94f4..9641f2b 100644
--- a/server/metin2/Source/Server/game/src/char_item.cpp
+++ b/server/metin2/Source/Server/game/src/char_item.cpp
@@ -1,12274 +1,12365 @@
-#include "stdafx.h"
-
-#include <stack>
-
-#include "utils.h"
-#include "config.h"
-#include "char.h"
-#include "char_manager.h"
-#include "item_manager.h"
-#include "desc.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "packet.h"
-#include "affect.h"
-#include "skill.h"
-#include "start_position.h"
-#include "mob_manager.h"
-#include "db.h"
-#include "log.h"
-#include "vector.h"
-#include "buffer_manager.h"
-#include "questmanager.h"
-#include "fishing.h"
-#include "party.h"
-#include "dungeon.h"
-#include "refine.h"
-#include "unique_item.h"
-#include "war_map.h"
-#include "xmas_event.h"
-#include "marriage.h"
-#include "monarch.h"
-#include "polymorph.h"
-#include "blend_item.h"
-#include "castle.h"
-#include "BattleArena.h"
-#include "arena.h"
-#include "dev_log.h"
-#include "pcbang.h"
-#include "threeway_war.h"
-
-#include "safebox.h"
-#include "shop.h"
-#include "pvp.h"
-
-#include "../../common/VnumHelper.h"
-#include "DragonSoul.h"
-#ifdef ENABLE_QUEEN_NETHIS
-#include "SnakeLair.h"
-#endif
-#include "buff_on_attributes.h"
-#include "belt_inventory_helper.h"
-#if defined(__LOOT_FILTER_SYSTEM__)
-#	include "LootFilter.h"
-#endif
-
-#if defined(__MT_THUNDER_DUNGEON__)
-#	include "mt_thunder_dungeon.h"
-#endif
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-#	include "guild_dragonlair.h"
-#endif
-
-#ifdef __OFFLINE_SHOP__
-#include "OfflineShop.h"
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-#include "growth_pet.h"
-#endif
-
-#include "../../libgame/include/grid.h"
-
-#include <optional>
-
-const int ITEM_BROKEN_METIN_VNUM = 28960;
-
-// CHANGE_ITEM_ATTRIBUTES
-const DWORD CHARACTER::msc_dwDefaultChangeItemAttrCycle = 10;
-const char CHARACTER::msc_szLastChangeItemAttrFlag[] = "Item.LastChangeItemAttr";
-const char CHARACTER::msc_szChangeItemAttrCycleFlag[] = "change_itemattr_cycle";
-// END_OF_CHANGE_ITEM_ATTRIBUTES
-const POINT_TYPE g_aBuffOnAttrPoints[] = { POINT_ENERGY, POINT_COSTUME_ATTR_BONUS };
-
-struct FFindStone
-{
-	std::map<DWORD, LPCHARACTER> m_mapStone;
-
-	void operator()(LPENTITY pEnt)
-	{
-		if (pEnt->IsType(ENTITY_CHARACTER) == true)
-		{
-			LPCHARACTER pChar = (LPCHARACTER)pEnt;
-
-			if (pChar->IsStone() == true)
-			{
-				m_mapStone[(DWORD)pChar->GetVID()] = pChar;
-			}
-		}
-	}
-};
-
-#if defined(__MT_THUNDER_DUNGEON__)
-struct FFindMobVnum
-{
-	DWORD dwMobVnum;
-	FFindMobVnum(DWORD dwMobVnum) : dwMobVnum(dwMobVnum) {}
-
-	std::map<DWORD, LPCHARACTER> m_mapVID;
-	void operator()(LPENTITY pEnt)
-	{
-		if (pEnt && pEnt->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER pChar = dynamic_cast<LPCHARACTER>(pEnt);
-
-			if (pChar && pChar->GetRaceNum() == dwMobVnum)
-			{
-				m_mapVID[(DWORD)pChar->GetVID()] = pChar;
-			}
-		}
-	}
-};
-#endif
-
-// ±ÍÈ¯ºÎ, ±ÍÈ¯±â¾ïºÎ, °áÈ¥¹ÝÁö
-bool IS_SUMMON_ITEM(LPITEM item, int map_index)
-{
-	if (item->GetVnum() == ITEM_MARRIAGE_RING)
-		return true;
-
-	switch (item->GetType())
-	{
-		case ITEM_QUEST:
-		{
-			if (item->GetSubType() == QUEST_WARP)
-			{
-				// NOTE : Force allow warp ring in certain maps indexes.
-				if (item->GetSpecialGroup() == UNIQUE_GROUP_WARP_RING)
-				{
-					switch (map_index)
-					{
-						case MAP_SKIPIA_DUNGEON_01:
-							return false;
-						default:
-							return true;
-					}
-				}
-				return true;
-			}
-		}
-		break;
-		case ITEM_USE:
-		{
-			if (item->GetSubType() == USE_TALISMAN)
-				return true;
-		}
-		break;
-	}
-
-	return false;
-}
-
-bool IS_MONKEY_DUNGEON(int map_index)
-{
-	switch (map_index)
-	{
-		case MAP_MONKEY_DUNGEON_11:
-		case MAP_MONKEY_DUNGEON_12:
-		case MAP_MONKEY_DUNGEON_13:
-		case MAP_MONKEY_DUNGEON:
-		case MAP_MONKEY_DUNGEON2:
-		case MAP_MONKEY_DUNGEON3:
-			return true;
-	}
-
-	return false;
-}
-
-bool IS_MAZE_DUNGEON(int map_index)
-{
-	switch (map_index)
-	{
-		case MAP_MAZE_DUNGEON1:
-		case MAP_MAZE_DUNGEON2:
-		case MAP_MAZE_DUNGEON3:
-			return true;
-	}
-
-	return false;
-}
-
-#if defined(__SNOW_DUNGEON__)
-bool IS_SNOW_DUNGEON(int map_index)
-{
-	if (map_index >= MAP_N_SNOW_DUNGEON_01 * 10000 && map_index < (MAP_N_SNOW_DUNGEON_01 + 1) * 10000)
-		return true;
-#if defined(__LABYRINTH_DUNGEON__)
-	else if (map_index >= MAP_BOSS_CRACK_SNOW * 10000 && map_index < (MAP_BOSS_CRACK_SNOW + 1) * 10000)
-		return true;
-	else if (map_index >= MAP_BOSS_AWAKEN_SNOW * 10000 && map_index < (MAP_BOSS_AWAKEN_SNOW + 1) * 10000)
-		return true;
-#endif
-
-	return false;
-}
-#endif
-
-#if defined(__ELEMENTAL_DUNGEON__)
-bool IS_ELEMENTAL_DUNGEON(int map_index)
-{
-	switch (map_index)
-	{
-		case MAP_ELEMENTAL_01:
-		case MAP_ELEMENTAL_02:
-		case MAP_ELEMENTAL_03:
-		case MAP_ELEMENTAL_04:
-			return true;
-	}
-
-	return false;
-}
-#endif
-
-bool IS_SUMMONABLE_ZONE(int map_index)
-{
-	// ¸ùÅ°´øÀü
-	if (IS_MONKEY_DUNGEON(map_index))
-		return false;
-
-	if (IS_MAZE_DUNGEON(map_index))
-		return false;
-
-	// ¼º
-	if (IS_CASTLE_MAP(map_index))
-		return false;
-
-	switch (map_index)
-	{
-		case MAP_DEVILTOWER1: // »ç±ÍÅ¸¿ö
-		case MAP_SPIDERDUNGEON_02: // °Å¹Ì ´øÀü 2Ãþ
-		case MAP_SKIPIA_DUNGEON_01: // ÃµÀÇ µ¿±¼
-		case MAP_SKIPIA_DUNGEON_02: // ÃµÀÇ µ¿±¼ 2Ãþ
-#if 0
-		case 193: // °Å¹Ì ´øÀü 2-1Ãþ
-		case 184: // ÃµÀÇ µ¿±¼(½Å¼ö)
-		case 185: // ÃµÀÇ µ¿±¼ 2Ãþ(½Å¼ö)
-		case 186: // ÃµÀÇ µ¿±¼(ÃµÁ¶)
-		case 187: // ÃµÀÇ µ¿±¼ 2Ãþ(ÃµÁ¶)
-		case 188: // ÃµÀÇ µ¿±¼(Áø³ë)
-		case 189: // ÃµÀÇ µ¿±¼ 2Ãþ(Áø³ë)
-#endif
-			//case 206: // ¾Æ±Íµ¿±¼
-		case MAP_DEVILSCATACOMB: // ¾Æ±Íµ¿±¼
-		case MAP_SPIDERDUNGEON_03: // °Å¹Ì ´øÀü 3Ãþ
-		case MAP_SKIPIA_DUNGEON_BOSS: // ÃµÀÇ µ¿±¼ (¿ë¹æ)
-		case MAP_OXEVENT: // OX Event ¸Ê
-		case MAP_12ZI_STAGE: // 12ZI
-		case MAP_BATTLEFIED: // Battlefield
-			return false;
-	}
-
-	if (CBattleArena::IsBattleArenaMap(map_index))
-		return false;
-
-	// ¸ðµç private ¸ÊÀ¸·Ð ¿öÇÁ ºÒ°¡´É
-	if (map_index > 10000)
-		return false;
-
-	return true;
-}
-
-bool IS_BOTARYABLE_ZONE(int nMapIndex)
-{
-	if (LC_IsYMIR() == false && LC_IsKorea() == false) return true;
-
-	switch (nMapIndex)
-	{
-		case MAP_A1:
-		case MAP_A3:
-		case MAP_B1:
-		case MAP_B3:
-		case MAP_C1:
-		case MAP_C3:
-		case MAP_PRIVATESHOP:
-			return true;
-	}
-
-	return false;
-}
-
-// item socket ÀÌ ÇÁ·ÎÅäÅ¸ÀÔ°ú °°ÀºÁö Ã¼Å© -- by mhh
-static bool FN_check_item_socket(LPITEM item)
-{
-	switch (item->GetVnum())
-	{
-		case ITEM_AUTO_HP_RECOVERY_S:
-		case ITEM_AUTO_HP_RECOVERY_M:
-		case ITEM_AUTO_HP_RECOVERY_L:
-		case ITEM_AUTO_HP_RECOVERY_X:
-		case ITEM_AUTO_SP_RECOVERY_S:
-		case ITEM_AUTO_SP_RECOVERY_M:
-		case ITEM_AUTO_SP_RECOVERY_L:
-		case ITEM_AUTO_SP_RECOVERY_X:
-		case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
-		case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
-		case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
-		case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
-		{
-			if (item->GetSocket(0) == 0 && item->GetSocket(1) == 0 && item->GetSocket(2) == item->GetProto()->alValues[0])
-				return true;
-		}
-		break;
-	}
-
-	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-	{
-		if (item->GetSocket(i) != item->GetProto()->alSockets[i])
-			return false;
-	}
-
-	return true;
-}
-
-// item socket º¹»ç -- by mhh
-static void FN_copy_item_socket(LPITEM dest, LPITEM src)
-{
-	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-	{
-		dest->SetSocket(i, src->GetSocket(i));
-	}
-}
-
-static bool FN_check_item_sex(LPCHARACTER ch, LPITEM item)
-{
-	// ³²ÀÚ ±ÝÁö
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_MALE))
-	{
-		if (SEX_MALE == GET_SEX(ch))
-			return false;
-	}
-
-	// ¿©ÀÚ±ÝÁö
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_FEMALE))
-	{
-		if (SEX_FEMALE == GET_SEX(ch))
-			return false;
-	}
-
-	return true;
-}
-
-#define VERIFY_POTION(affect, afftype) \
-	if (FindAffect(affect, afftype)) \
-	{ \
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù.")); \
-		return false; \
-	}
-
-/////////////////////////////////////////////////////////////////////////////
-// ITEM HANDLING
-/////////////////////////////////////////////////////////////////////////////
-bool CHARACTER::CanHandleItem(bool bSkipCheckRefine, bool bSkipObserver)
-{
-	if (!bSkipObserver)
-		if (m_bIsObserver)
-			return false;
-
-	if (GetMyShop())
-		return false;
-
-	if (!bSkipCheckRefine)
-	{
-		if (IsUnderRefine())
-			return false;
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		if (IsUnderRefineElement())
-			return false;
-#endif
-	}
-
-	if (IsWarping())
-		return false;
-
-	if (IsCubeOpen())
-		return false;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (NULL != DragonSoul_RefineWindow_GetOpener())
-		return false;
-#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-	if (IsItemComb())
-		return false;
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	if (GetChangeLook())
-		return false;
-#endif
-
-#if defined(__MAILBOX__)
-	if (GetMailBox())
-		return false;
-#endif
-
-#if defined(__GEM_SHOP__)
-	if (GetGemShop())
-		return false;
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	if (IsAcceRefineWindowOpen())
-		return false;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-	if (IsAuraRefineWindowOpen() || NULL != GetAuraRefineWindowOpener())
-		return false;
-#endif
-
-#if defined(__CHANGED_ATTR__)
-	if (IsSelectAttr())
-		return false;
-#endif
-
-#if defined(__LUCKY_BOX__)
-	if (IsLuckyBoxOpen())
-		return false;
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-	if (GetMiniGameRoulette())
-		return false;
-#endif
-
-	return true;
-}
-
-LPITEM CHARACTER::GetInventoryItem(WORD wCell) const
-{
-	return GetItem(TItemPos(INVENTORY, wCell));
-}
-
-LPITEM CHARACTER::GetEquipmentItem(WORD wCell) const
-{
-	return GetItem(TItemPos(EQUIPMENT, wCell));
-}
-
-LPITEM CHARACTER::GetDragonSoulInventoryItem(WORD wCell) const
-{
-	return GetItem(TItemPos(DRAGON_SOUL_INVENTORY, wCell));
-}
-
-LPITEM CHARACTER::GetBeltInventoryItem(WORD wCell) const
-{
-	return GetItem(TItemPos(BELT_INVENTORY, wCell));
-}
-
-LPITEM CHARACTER::GetItem(TItemPos Cell) const
-{
-	if (!IsValidItemPosition(Cell))
-		return nullptr;
-
-	WORD wCell = Cell.cell;
-	BYTE window_type = Cell.window_type;
-
-	switch (window_type)
-	{
-		case INVENTORY:
-		{
-			if (wCell >= INVENTORY_MAX_NUM)
-			{
-				sys_err("CHARACTER::GetItem: Invalid Inventory item! Window %d Cell %d", window_type, wCell);
-				return nullptr;
-			}
-			return m_pointsInstant.pInventoryItems[wCell];
-		}
-		break;
-
-		case EQUIPMENT:
-		{
-			if (wCell >= EQUIPMENT_MAX_NUM)
-			{
-				sys_err("CHARACTER::GetItem: Invalid Equipment item! Window %d Cell %d", window_type, wCell);
-				return nullptr;
-			}
-			return m_pointsInstant.pEquipmentItems[wCell];
-		}
-		break;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case DRAGON_SOUL_INVENTORY:
-		{
-			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-			{
-				sys_err("CHARACTER::GetItem: Invalid Dragon Soul item! window %d cell %d", window_type, wCell);
-				return nullptr;
-			}
-			return m_pointsInstant.pDragonSoulInventoryItems[wCell];
-		}
-		break;
-#endif
-
-		case BELT_INVENTORY:
-		{
-			if (wCell >= BELT_INVENTORY_SLOT_COUNT)
-			{
-				sys_err("CHARACTER::GetItem: Invalid Belt item! window %d cell %d", window_type, wCell);
-				return nullptr;
-			}
-			return m_pointsInstant.pBeltInventoryItems[wCell];
-		}
-		break;
-
-#if defined(__ATTR_6TH_7TH__)
-		case NPC_STORAGE:
-		{
-			if (wCell >= NPC_STORAGE_SLOT_MAX)
-			{
-				sys_err("CHARACTER::GetItem: invalid NPC_STORAGE item cell %d", wCell);
-				return nullptr;
-			}
-			return m_pointsInstant.pNPCStorageItems;
-		}
-#endif
-
-		default:
-			return nullptr;
-	}
-
-	return nullptr;
-}
-
-void CHARACTER::SetItem(TItemPos Cell, LPITEM pItem
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-	, bool isHighLight
-#endif
-)
-{
-	BYTE bWindowType = Cell.window_type;
-	WORD wCell = Cell.cell;
-
-	if ((unsigned long)((CItem*)pItem) == 0xff || (unsigned long)((CItem*)pItem) == 0xffffffff)
-	{
-		sys_err("!!! FATAL ERROR !!! item == 0xff (char: %s cell: %u)", GetName(), wCell);
-		core_dump();
-		return;
-	}
-
-	if (pItem && pItem->GetOwner())
-	{
-		assert(!"GetOwner exist");
-		return;
-	}
-
-	// ±âº» ÀÎº¥Åä¸®
-	switch (bWindowType)
-	{
-		case INVENTORY:
-		{
-			if (wCell >= INVENTORY_MAX_NUM)
-			{
-				sys_err("CHARACTER::SetItem: Invalid Inventory item! Window %d Cell %d", bWindowType, wCell);
-				return;
-			}
-
-			LPITEM pOldItem = m_pointsInstant.pInventoryItems[wCell];
-			if (pOldItem)
-			{
-				if (wCell < INVENTORY_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * INVENTORY_WIDTH);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-						if (wSlot >= GetExtendInvenMax())
-							continue;
-#else
-						if (wSlot >= INVENTORY_MAX_NUM)
-							continue;
-#endif
-
-						if (m_pointsInstant.pInventoryItems[wSlot] && m_pointsInstant.pInventoryItems[wSlot] != pOldItem)
-							continue;
-
-						m_pointsInstant.wInventoryItemGrid[wSlot] = 0;
-					}
-				}
-				else
-					m_pointsInstant.wInventoryItemGrid[wCell] = 0;
-			}
-
-			if (pItem)
-			{
-				if (wCell < INVENTORY_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * INVENTORY_WIDTH);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-						if (wSlot >= GetExtendInvenMax())
-							continue;
-#else
-						if (wSlot >= INVENTORY_MAX_NUM)
-							continue;
-#endif
-
-						// wCell + 1 ·Î ÇÏ´Â °ÍÀº ºó°÷À» Ã¼Å©ÇÒ ¶§ °°Àº
-						// ¾ÆÀÌÅÛÀº ¿¹¿ÜÃ³¸®ÇÏ±â À§ÇÔ
-						m_pointsInstant.wInventoryItemGrid[wSlot] = wCell + 1;
-					}
-				}
-				else
-					m_pointsInstant.wInventoryItemGrid[wCell] = wCell + 1;
-			}
-
-			m_pointsInstant.pInventoryItems[wCell] = pItem;
-		}
-		break;
-
-		case EQUIPMENT:
-		{
-			if (wCell >= EQUIPMENT_MAX_NUM)
-			{
-				sys_err("CHARACTER::SetItem: Invalid Equipment item! Window %d Cell %d", bWindowType, wCell);
-				return;
-			}
-
-			LPITEM pOldItem = m_pointsInstant.pEquipmentItems[wCell];
-			if (pOldItem)
-			{
-				if (wCell < EQUIPMENT_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
-					{
-						BYTE bSlot = wCell + bSize;
-						if (bSlot >= EQUIPMENT_MAX_NUM)
-							continue;
-
-						if (m_pointsInstant.pEquipmentItems[bSlot] && m_pointsInstant.pEquipmentItems[bSlot] != pOldItem)
-							continue;
-
-						m_pointsInstant.bEquipmentItemGrid[bSlot] = 0;
-					}
-				}
-				else
-					m_pointsInstant.bEquipmentItemGrid[wCell] = 0;
-			}
-
-			if (pItem)
-			{
-				if (wCell < EQUIPMENT_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
-					{
-						BYTE bSlot = wCell + bSize;
-						if (bSlot >= EQUIPMENT_MAX_NUM)
-							continue;
-
-						m_pointsInstant.bEquipmentItemGrid[bSlot] = wCell + 1;
-					}
-				}
-				else
-					m_pointsInstant.bEquipmentItemGrid[wCell] = wCell + 1;
-			}
-
-			m_pointsInstant.pEquipmentItems[wCell] = pItem;
-		}
-		break;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case DRAGON_SOUL_INVENTORY:
-		{
-			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-			{
-				sys_err("CHARACTER::SetItem: Invalid Dragon Soul item! Window %d Cell %d", bWindowType, wCell);
-				return;
-			}
-
-			LPITEM pOldItem = m_pointsInstant.pDragonSoulInventoryItems[wCell];
-			if (pOldItem)
-			{
-				if (wCell < DRAGON_SOUL_INVENTORY_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * DRAGON_SOUL_BOX_COLUMN_NUM);
-						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-							continue;
-
-						if (m_pointsInstant.pDragonSoulInventoryItems[wSlot] && m_pointsInstant.pDragonSoulInventoryItems[wSlot] != pOldItem)
-							continue;
-
-						m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] = 0;
-					}
-				}
-				else
-					m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] = 0;
-			}
-
-			if (pItem)
-			{
-				if (wCell < DRAGON_SOUL_INVENTORY_MAX_NUM)
-				{
-					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * DRAGON_SOUL_BOX_COLUMN_NUM);
-						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-							continue;
-
-						m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] = wCell + 1;
-					}
-				}
-				else
-					m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] = wCell + 1;
-			}
-
-			m_pointsInstant.pDragonSoulInventoryItems[wCell] = pItem;
-		}
-		break;
-#endif
-
-		case BELT_INVENTORY:
-		{
-			if (wCell >= BELT_INVENTORY_SLOT_COUNT)
-			{
-				sys_err("CHARACTER::SetItem: Invalid Belt item! Window %d Cell %d", bWindowType, wCell);
-				return;
-			}
-
-			LPITEM pOldItem = m_pointsInstant.pBeltInventoryItems[wCell];
-			if (pOldItem)
-			{
-				if (wCell < BELT_INVENTORY_SLOT_COUNT)
-				{
-					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * BELT_INVENTORY_SLOT_WIDTH);
-						if (wSlot >= BELT_INVENTORY_SLOT_COUNT)
-							continue;
-
-						if (m_pointsInstant.pBeltInventoryItems[wSlot] && m_pointsInstant.pBeltInventoryItems[wSlot] != pOldItem)
-							continue;
-
-						m_pointsInstant.bBeltInventoryItemGrid[wSlot] = 0;
-					}
-				}
-				else
-					m_pointsInstant.bBeltInventoryItemGrid[wCell] = 0;
-			}
-
-			if (pItem)
-			{
-				if (wCell < BELT_INVENTORY_SLOT_COUNT)
-				{
-					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
-					{
-						WORD wSlot = wCell + (bSize * BELT_INVENTORY_SLOT_WIDTH);
-						if (wSlot >= BELT_INVENTORY_SLOT_COUNT)
-							continue;
-
-						m_pointsInstant.bBeltInventoryItemGrid[wSlot] = wCell + 1;
-					}
-				}
-				else
-					m_pointsInstant.bBeltInventoryItemGrid[wCell] = wCell + 1;
-			}
-
-			m_pointsInstant.pBeltInventoryItems[wCell] = pItem;
-		}
-		break;
-
-#if defined(__ATTR_6TH_7TH__)
-		case NPC_STORAGE:
-		{
-			if (wCell >= NPC_STORAGE_SLOT_MAX)
-			{
-				sys_err("CHARACTER::SetItem: invalid ATTR67_ADD item cell %d", wCell);
-				return;
-			}
-			m_pointsInstant.pNPCStorageItems = pItem;
-		}
-		break;
-#endif
-
-		default:
-			sys_err("Invalid Inventory type %d", bWindowType);
-			return;
-	}
-
-	if (GetDesc())
-	{
-		// È®Àå ¾ÆÀÌÅÛ: ¼­¹ö¿¡¼­ ¾ÆÀÌÅÛ ÇÃ·¡±× Á¤º¸¸¦ º¸³½´Ù
-		if (pItem)
-		{
-			TPacketGCItemSet pack;
-			pack.bHeader = HEADER_GC_ITEM_SET;
-			pack.Cell = Cell;
-			pack.dwVnum = pItem->GetVnum();
-			pack.dwCount = pItem->GetCount();
-			pack.dwFlags = pItem->GetFlag();
-			pack.dwAntiFlags = pItem->GetAntiFlag();
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			if (isHighLight)
-				pack.bHighLight = true;
-			else
-				pack.bHighLight = (Cell.window_type == DRAGON_SOUL_INVENTORY);
-#else
-			pack.bHighLight = (Cell.window_type == DRAGON_SOUL_INVENTORY);
-#endif
-#if defined(__SOUL_BIND_SYSTEM__)
-			pack.lSealDate = pItem->GetSealDate();
-#endif
-			thecore_memcpy(pack.alSockets, pItem->GetSockets(), sizeof(pack.alSockets));
-			thecore_memcpy(pack.aAttr, pItem->GetAttributes(), sizeof(pack.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			pack.dwTransmutationVnum = pItem->GetTransmutationVnum();
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			thecore_memcpy(&pack.RefineElement, pItem->GetRefineElement(), sizeof(pack.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			thecore_memcpy(pack.aApplyRandom, pItem->GetRandomApplies(), sizeof(pack.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-			pack.bSetValue = pItem->GetItemSetValue();
-#endif
-
-			GetDesc()->Packet(&pack, sizeof(TPacketGCItemSet));
-		}
-		else
-		{
-			TPacketGCItemSetEmpty pack;
-			pack.bHeader = HEADER_GC_ITEM_DEL;
-			pack.Cell = Cell;
-			pack.dwVnum = 0;
-			pack.dwCount = 0;
-			memset(pack.alSockets, 0, sizeof(pack.alSockets));
-			memset(pack.aAttr, 0, sizeof(pack.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-			pack.dwTransmutationVnum = 0;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-			memset(&pack.RefineElement, 0, sizeof(pack.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-			memset(pack.aApplyRandom, 0, sizeof(pack.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-			pack.bSetValue = 0;
-#endif
-
-			GetDesc()->Packet(&pack, sizeof(TPacketGCItemSetEmpty));
-		}
-	}
-
-	if (pItem)
-	{
-		pItem->SetCell(this, wCell);
-		switch (bWindowType)
-		{
-			case INVENTORY:
-				pItem->SetWindow(INVENTORY);
-				break;
-
-			case EQUIPMENT:
-				pItem->SetWindow(EQUIPMENT);
-				break;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			case DRAGON_SOUL_INVENTORY:
-				pItem->SetWindow(DRAGON_SOUL_INVENTORY);
-				break;
-#endif
-
-			case BELT_INVENTORY:
-				pItem->SetWindow(BELT_INVENTORY);
-				break;
-
-#if defined(__ATTR_6TH_7TH__)
-			case NPC_STORAGE:
-				pItem->SetWindow(NPC_STORAGE);
-				break;
-#endif
-
-			default:
-				sys_err("Trying to set window %d, non determined behaviour!", bWindowType);
-		}
-	}
-}
-
-LPITEM CHARACTER::GetWear(WORD wCell) const
-{
-	if (wCell >= EQUIPMENT_MAX_NUM)
-	{
-		sys_err("CHARACTER::GetWear: invalid wear cell %d", wCell);
-		return nullptr;
-	}
-
-	return m_pointsInstant.pEquipmentItems[wCell];
-}
-
-void CHARACTER::SetWear(WORD wCell, LPITEM item)
-{
-	if (wCell >= EQUIPMENT_MAX_NUM)
-	{
-		sys_err("CHARACTER::SetItem: invalid item cell %d", wCell);
-		return;
-	}
-
-	SetItem(TItemPos(EQUIPMENT, wCell), item);
-
-	if (!item && wCell == WEAR_WEAPON)
-	{
-		// ±Í°Ë »ç¿ë ½Ã ¹þ´Â °ÍÀÌ¶ó¸é È¿°ú¸¦ ¾ø¾Ö¾ß ÇÑ´Ù.
-		if (IsAffectFlag(AFF_GWIGUM))
-			RemoveAffect(SKILL_GWIGEOM);
-
-		if (IsAffectFlag(AFF_GEOMGYEONG))
-			RemoveAffect(SKILL_GEOMKYUNG);
-	}
-}
-
-void CHARACTER::ClearItem()
-{
-	int i;
-	LPITEM item;
-
-	for (i = 0; i < INVENTORY_MAX_NUM; ++i)
-	{
-		if ((item = GetInventoryItem(i)))
-		{
-			item->SetSkipSave(true);
-			ITEM_MANAGER::Instance().FlushDelayedSave(item);
-
-			item->RemoveFromCharacter();
-			M2_DESTROY_ITEM(item);
-
-			SyncQuickslot(SLOT_TYPE_INVENTORY, i, WORD_MAX);
-		}
-	}
-
-	for (i = 0; i < EQUIPMENT_MAX_NUM; ++i)
-	{
-		if ((item = GetEquipmentItem(i)))
-		{
-			item->SetSkipSave(true);
-			ITEM_MANAGER::Instance().FlushDelayedSave(item);
-
-			item->RemoveFromCharacter();
-			M2_DESTROY_ITEM(item);
-		}
-	}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	for (i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
-	{
-		if ((item = GetDragonSoulInventoryItem(i)))
-		{
-			item->SetSkipSave(true);
-			ITEM_MANAGER::Instance().FlushDelayedSave(item);
-
-			item->RemoveFromCharacter();
-			M2_DESTROY_ITEM(item);
-		}
-	}
-#endif
-
-	for (i = 0; i < BELT_INVENTORY_SLOT_COUNT; ++i)
-	{
-		if ((item = GetBeltInventoryItem(i)))
-		{
-			item->SetSkipSave(true);
-			ITEM_MANAGER::Instance().FlushDelayedSave(item);
-
-			item->RemoveFromCharacter();
-			M2_DESTROY_ITEM(item);
-
-			SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, i, WORD_MAX);
-		}
-	}
-
-#if defined(__ATTR_6TH_7TH__)
-	if ((item = GetNPCStorageItem()))
-	{
-		item->SetSkipSave(true);
-		ITEM_MANAGER::Instance().FlushDelayedSave(item);
-
-		item->RemoveFromCharacter();
-		M2_DESTROY_ITEM(item);
-	}
-#endif
-}
-
-bool CHARACTER::IsEmptyItemGrid(TItemPos Cell, BYTE bSize, int iExceptionCell) const
-{
-	switch (Cell.window_type)
-	{
-		case INVENTORY:
-		{
-			const WORD wCell = Cell.cell;
-#if defined(__EXTEND_INVEN_SYSTEM__)
-			if (wCell >= GetExtendInvenMax())
-#else
-			if (wCell >= INVENTORY_MAX_NUM)
-#endif
-				return false;
-
-			// bItemCellÀº 0ÀÌ falseÀÓÀ» ³ªÅ¸³»±â À§ÇØ + 1 ÇØ¼­ Ã³¸®ÇÑ´Ù.
-			// µû¶ó¼­ iExceptionCell¿¡ 1À» ´õÇØ ºñ±³ÇÑ´Ù.
-			++iExceptionCell;
-
-			if (m_pointsInstant.wInventoryItemGrid[wCell])
-			{
-				if (m_pointsInstant.wInventoryItemGrid[wCell] == iExceptionCell)
-				{
-					if (bSize == 1)
-						return true;
-
-					int iOffset = 1;
-#if defined(__EXTEND_INVEN_SYSTEM__)
-					const WORD wPage = wCell / INVENTORY_PAGE_SIZE;
-#else
-					const WORD wPage = wCell / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT);
-#endif
-					do
-					{
-						const WORD wSlot = wCell + (INVENTORY_WIDTH * iOffset);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-						if (wSlot >= GetExtendInvenMax())
-							return false;
-
-						if (wSlot / INVENTORY_PAGE_SIZE != wPage)
-							return false;
-#else
-						if (wSlot >= INVENTORY_MAX_NUM)
-							return false;
-
-						if (wSlot / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT) != wPage)
-							return false;
-#endif
-
-						if (m_pointsInstant.wInventoryItemGrid[wSlot])
-						{
-							if (m_pointsInstant.wInventoryItemGrid[wSlot] != iExceptionCell)
-								return false;
-						}
-					} while (++iOffset < bSize);
-
-					return true;
-				}
-				else
-					return false;
-			}
-
-			// Å©±â°¡ 1ÀÌ¸é ÇÑÄ­À» Â÷ÁöÇÏ´Â °ÍÀÌ¹Ç·Î ±×³É ¸®ÅÏ
-			if (1 == bSize)
-				return true;
-			else
-			{
-				int iOffset = 1;
-#if defined(__EXTEND_INVEN_SYSTEM__)
-				const WORD wPage = wCell / INVENTORY_PAGE_SIZE;
-#else
-				const WORD wPage = wCell / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT);
-#endif
-
-				do
-				{
-					const WORD wSlot = wCell + (INVENTORY_WIDTH * iOffset);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-					if (wSlot >= GetExtendInvenMax())
-						return false;
-
-					if (wSlot / INVENTORY_PAGE_SIZE != wPage)
-						return false;
-#else
-					if (wSlot >= INVENTORY_MAX_NUM)
-						return false;
-
-					if (wSlot / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT) != wPage)
-						return false;
-#endif
-
-					if (m_pointsInstant.wInventoryItemGrid[wSlot])
-					{
-						if (m_pointsInstant.wInventoryItemGrid[wSlot] != iExceptionCell)
-							return false;
-					}
-				} while (++iOffset < bSize);
-
-				return true;
-			}
-		}
-		break;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case DRAGON_SOUL_INVENTORY:
-		{
-			const WORD wCell = Cell.cell;
-			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-				return false;
-
-			++iExceptionCell;
-
-			if (m_pointsInstant.wDragonSoulInventoryItemGrid[wCell])
-			{
-				if (m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] == iExceptionCell)
-				{
-					if (bSize == 1)
-						return true;
-
-					int iOffset = 1;
-
-					do
-					{
-						const WORD wSlot = wCell + (DRAGON_SOUL_BOX_COLUMN_NUM * iOffset);
-						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-							return false;
-
-						if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot])
-						{
-							if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] != iExceptionCell)
-								return false;
-						}
-					} while (++iOffset < bSize);
-
-					return true;
-				}
-				else
-					return false;
-			}
-
-			if (1 == bSize)
-				return true;
-			else
-			{
-				int iOffset = 1;
-
-				do
-				{
-					const WORD wSlot = wCell + (DRAGON_SOUL_BOX_COLUMN_NUM * iOffset);
-					if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-						return false;
-
-					if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot])
-					{
-						if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] != iExceptionCell)
-							return false;
-					}
-				} while (++iOffset < bSize);
-
-				return true;
-			}
-		}
-		break;
-#endif
-
-		case BELT_INVENTORY:
-		{
-			const WORD wCell = Cell.cell;
-			if (wCell >= BELT_INVENTORY_MAX_NUM)
-				return false;
-
-			++iExceptionCell;
-
-			const LPITEM pBeltItem = GetWear(WEAR_BELT);
-			if (pBeltItem == nullptr)
-				return false;
-
-			if (!CBeltInventoryHelper::IsAvailableCell(wCell - BELT_INVENTORY_SLOT_START, pBeltItem->GetValue(0)))
-				return false;
-
-			if (m_pointsInstant.bBeltInventoryItemGrid[wCell])
-			{
-				if (m_pointsInstant.bBeltInventoryItemGrid[wCell] == iExceptionCell)
-				{
-					if (bSize == 1)
-						return true;
-
-					int iOffset = 1;
-
-					do
-					{
-						const WORD wSlot = wCell + (BELT_INVENTORY_SLOT_WIDTH * iOffset);
-						if (wSlot >= BELT_INVENTORY_MAX_NUM)
-							return false;
-
-						if (m_pointsInstant.bBeltInventoryItemGrid[wSlot])
-						{
-							if (m_pointsInstant.bBeltInventoryItemGrid[wSlot] != iExceptionCell)
-								return false;
-						}
-					} while (++iOffset < bSize);
-
-					return true;
-				}
-				else
-					return false;
-			}
-
-			if (1 == bSize)
-				return true;
-			else
-			{
-				int iOffset = 1;
-
-				do
-				{
-					const WORD wSlot = wCell + (BELT_INVENTORY_SLOT_WIDTH * iOffset);
-					if (wSlot >= BELT_INVENTORY_MAX_NUM)
-						return false;
-
-					if (m_pointsInstant.bBeltInventoryItemGrid[wSlot])
-					{
-						if (m_pointsInstant.bBeltInventoryItemGrid[wSlot] != iExceptionCell)
-							return false;
-					}
-				} while (++iOffset < bSize);
-
-				return true;
-			}
-		}
-		break;
-	}
-
-	return false;
-}
-
-int CHARACTER::GetEmptyInventory(BYTE size) const
-{
-	// NOTE : ÇöÀç ÀÌ ÇÔ¼ö´Â ¾ÆÀÌÅÛ Áö±Þ, È¹µæ µîÀÇ ÇàÀ§¸¦ ÇÒ ¶§ ÀÎº¥Åä¸®ÀÇ ºó Ä­À» Ã£±â À§ÇØ »ç¿ëµÇ°í ÀÖ´Âµ¥,
-	// º§Æ® ÀÎº¥Åä¸®´Â Æ¯¼ö ÀÎº¥Åä¸®ÀÌ¹Ç·Î °Ë»çÇÏÁö ¾Êµµ·Ï ÇÑ´Ù. (±âº» ÀÎº¥Åä¸®: INVENTORY_MAX_NUM ±îÁö¸¸ °Ë»ç)
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (int i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-		if (IsEmptyItemGrid(TItemPos(INVENTORY, i), size))
-			return i;
-	return -1;
-}
-
-int CHARACTER::GetEmptyInventoryCount(BYTE size) const
-{
-	// NOTE : ÇöÀç ÀÌ ÇÔ¼ö´Â ¾ÆÀÌÅÛ Áö±Þ, È¹µæ µîÀÇ ÇàÀ§¸¦ ÇÒ ¶§ ÀÎº¥Åä¸®ÀÇ ºó Ä­À» Ã£±â À§ÇØ »ç¿ëµÇ°í ÀÖ´Âµ¥,
-	// º§Æ® ÀÎº¥Åä¸®´Â Æ¯¼ö ÀÎº¥Åä¸®ÀÌ¹Ç·Î °Ë»çÇÏÁö ¾Êµµ·Ï ÇÑ´Ù. (±âº» ÀÎº¥Åä¸®: INVENTORY_MAX_NUM ±îÁö¸¸ °Ë»ç)
-	int emptyCount = 0;
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (int i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-	{
-		if (IsEmptyItemGrid(TItemPos(INVENTORY, i), size))
-			++emptyCount;
-	}
-
-	return emptyCount;
-}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-int CHARACTER::GetEmptyDragonSoulInventory(LPITEM pItem) const
-{
-	if (NULL == pItem || !pItem->IsDragonSoul())
-		return -1;
-
-	if (!DragonSoul_IsQualified())
-		return -1;
-
-	BYTE bSize = pItem->GetSize();
-	WORD wBaseCell = DSManager::instance().GetBasePosition(pItem);
-
-	if (WORD_MAX == wBaseCell)
-		return -1;
-
-	for (int i = 0; i < DRAGON_SOUL_BOX_SIZE; ++i)
-		if (IsEmptyItemGrid(TItemPos(DRAGON_SOUL_INVENTORY, i + wBaseCell), bSize))
-			return i + wBaseCell;
-
-	return -1;
-}
-
-void CHARACTER::CopyDragonSoulItemGrid(std::vector<WORD>& vDragonSoulItemGrid) const
-{
-	vDragonSoulItemGrid.resize(DRAGON_SOUL_INVENTORY_MAX_NUM);
-	std::copy(m_pointsInstant.wDragonSoulInventoryItemGrid, m_pointsInstant.wDragonSoulInventoryItemGrid + DRAGON_SOUL_INVENTORY_MAX_NUM, vDragonSoulItemGrid.begin());
-}
-#endif
-
-int CHARACTER::CountEmptyInventory() const
-{
-	int count = 0;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (int i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-		if (GetInventoryItem(i))
-			count += GetInventoryItem(i)->GetSize();
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	return (GetExtendInvenMax() - count);
-#else
-	return (INVENTORY_MAX_NUM - count);
-#endif
-}
-
-bool CHARACTER::HasEnoughInventorySpace(std::vector<TItemData>& vItems) const
-{
-	if (vItems.empty())
-		return true;
-
-	static std::array<CGrid, 4> aGrids = {
-		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
-		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
-		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
-		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT)
-	};
-	for (auto& kGrid : aGrids)
-		kGrid.Clear();
-
-	LPITEM pItem = nullptr;
-	for (int i = 0; i < INVENTORY_PAGE_SIZE * 4; ++i)
-	{
-		if ((pItem = GetInventoryItem(i)))
-		{
-			aGrids[i / INVENTORY_PAGE_SIZE].Put(i % INVENTORY_PAGE_SIZE, 1, pItem->GetSize());
-		}
-	}
-
-	for (const TItemData& kItem : vItems)
-	{
-		const TItemTable* pItemTable = ITEM_MANAGER::Instance().GetTable(kItem.dwVnum);
-		if (!pItemTable)
-			return true;
-
-		int iPos = -1;
-		for (int j = 0; j < aGrids.size(); ++j)
-		{
-			iPos = aGrids[j].FindBlank(1, pItemTable->bSize);
-			if (iPos >= 0)
-			{
-#if defined(__EXTEND_INVEN_SYSTEM__)
-				if (j >= 2)
-				{
-					int iExtendMaxPos = (INVENTORY_WIDTH * (GetExtendInvenStage() - (j - 1))) - 1;
-					if (iPos > iExtendMaxPos)
-						return false;
-
-					if (pItemTable->bSize > 1)
-					{
-						iExtendMaxPos -= (INVENTORY_WIDTH * (pItemTable->bSize - 1));
-						if (iPos > iExtendMaxPos)
-							return false;
-					}
-				}
-#endif
-				aGrids[j].Put(iPos, 1, pItemTable->bSize);
-				break;
-			}
-		}
-
-		if (iPos == -1)
-			return false;
-	}
-
-	return true;
-}
-
-void TransformRefineItem(LPITEM pkOldItem, LPITEM pkNewItem)
-{
-	// ACCESSORY_REFINE
-	if (pkOldItem->IsAccessoryForSocket())
-	{
-		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-		{
-			pkNewItem->SetSocket(i, pkOldItem->GetSocket(i));
-		}
-		//pkNewItem->StartAccessorySocketExpireEvent();
-	}
-	// END_OF_ACCESSORY_REFINE
-	else
-	{
-		// ¿©±â¼­ ±úÁø¼®ÀÌ ÀÚµ¿ÀûÀ¸·Î Ã»¼Ò µÊ
-		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-		{
-			if (!pkOldItem->GetSocket(i))
-				break;
-			else
-				pkNewItem->SetSocket(i, 1);
-		}
-
-		// ¼ÒÄÏ ¼³Á¤
-		int slot = 0;
-
-		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-		{
-			long socket = pkOldItem->GetSocket(i);
-
-			if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
-				pkNewItem->SetSocket(slot++, socket);
-		}
-
-	}
-
-#if defined(__ITEM_SOCKET6__)
-	for (int i = METIN_SOCKET_MAX_NUM; i < ITEM_SOCKET_MAX_NUM; ++i)
-		pkNewItem->SetSocket(i, pkOldItem->GetSocket(i));
-#endif
-
-	// ¸ÅÁ÷ ¾ÆÀÌÅÛ ¼³Á¤
-	pkOldItem->CopyAttributeTo(pkNewItem);
-}
-
-void NotifyRefineSuccess(LPCHARACTER ch, LPITEM item, const char* way)
-{
-	if (NULL != ch && item != NULL)
-	{
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineSuceeded");
-
-		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), 1, way);
-	}
-}
-
-void NotifyRefineFail(LPCHARACTER ch, LPITEM item, const char* way, int success = 0)
-{
-	if (NULL != ch && NULL != item)
-	{
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineFailed");
-
-		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), success, way);
-	}
-}
-
-#if defined(__REFINE_MSG_ADD__)
-void NotifyRefineFailType(const LPCHARACTER ch, const LPITEM item, const BYTE type, const char* way, const BYTE success = 0)
-{
-	if (ch && item)
-	{
-		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineFailedType %d", type);
-		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), success, way);
-	}
-}
-#endif
-
-void CHARACTER::SetRefineNPC(LPCHARACTER ch)
-{
-	if (ch != NULL)
-	{
-		m_dwRefineNPCVID = ch->GetVID();
-	}
-	else
-	{
-		m_dwRefineNPCVID = 0;
-	}
-}
-
-bool CHARACTER::DoRefine(LPITEM item, bool bMoneyOnly)
-{
-	if (!CanHandleItem(true))
-	{
-		ClearRefineMode();
-		return false;
-	}
-
-	//°³·® ½Ã°£Á¦ÇÑ : upgrade_refine_scroll.quest ¿¡¼­ °³·®ÈÄ 5ºÐÀÌ³»¿¡ ÀÏ¹Ý °³·®À»
-	//ÁøÇàÇÒ¼ö ¾øÀ½
-	if (quest::CQuestManager::instance().GetEventFlag("update_refine_time") != 0)
-	{
-		if (get_global_time() < quest::CQuestManager::instance().GetEventFlag("update_refine_time") + (60 * 5))
-		{
-			sys_log(0, "can't refine %d %s", GetPlayerID(), GetName());
-			return false;
-		}
-	}
-
-	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
-	if (!prt)
-		return false;
-
-	DWORD result_vnum = item->GetRefinedVnum();
-
-	// REFINE_COST
-	int cost = ComputeRefineFee(prt->cost);
-
-	int RefineChance = GetQuestFlag("main_quest_lv7.refine_chance");
-
-	if (RefineChance > 0)
-	{
-		if (!item->CheckItemUseLevel(20) || item->GetType() != ITEM_WEAPON)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¹«·á °³·® ±âÈ¸´Â 20 ÀÌÇÏÀÇ ¹«±â¸¸ °¡´ÉÇÕ´Ï´Ù"));
-			return false;
-		}
-		cost = 0;
-		SetQuestFlag("main_quest_lv7.refine_chance", RefineChance - 1);
-	}
-	// END_OF_REFINE_COST
-
-	if (result_vnum == 0)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("´õ ÀÌ»ó °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TUNING)
-		return false;
-
-	TItemTable* pProto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
-
-	if (!pProto)
-	{
-		sys_err("DoRefine NOT GET ITEM PROTO %d", item->GetRefinedVnum());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀº °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	// Check level limit in korea only
-	if (!g_iUseLocale)
-	{
-		for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-		{
-			long limit = pProto->aLimits[i].lValue;
-
-			switch (pProto->aLimits[i].bType)
-			{
-				case LIMIT_LEVEL:
-				{
-					if (GetLevel() < limit)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("°³·®µÈ ÈÄ ¾ÆÀÌÅÛÀÇ ·¹º§ Á¦ÇÑº¸´Ù ·¹º§ÀÌ ³·½À´Ï´Ù."));
-						return false;
-					}
-				}
-				break;
-
-#if defined(__CONQUEROR_LEVEL__)
-				case LIMIT_NEWWORLD_LEVEL:
-				{
-					if (GetConquerorLevel() < limit)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("°³·®µÈ ÈÄ ¾ÆÀÌÅÛÀÇ ·¹º§ Á¦ÇÑº¸´Ù ·¹º§ÀÌ ³·½À´Ï´Ù."));
-						return false;
-					}
-				}
-				break;
-#endif
-			}
-		}
-	}
-
-	// REFINE_COST
-	if (GetGold() < (long long)cost)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("°³·®À» ÇÏ±â À§ÇÑ µ·ÀÌ ºÎÁ·ÇÕ´Ï´Ù."));
-		return false;
-	}
-
-#if defined(__REFINE_STACK_FIX__)
-	int iEmptyPos = GetEmptyInventory(item->GetSize());
-	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-	{
-		if (-1 == iEmptyPos)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ÒÁöÇ°¿¡ ºó °ø°£ÀÌ ¾ø½À´Ï´Ù."));
-			return false;
-		}
-	}
-#endif
-
-	if (!bMoneyOnly && !RefineChance)
-	{
-		for (int i = 0; i < prt->material_count; ++i)
-		{
-			if (CountSpecifyItem(prt->materials[i].vnum, item->GetCell()) < prt->materials[i].count)
-			{
-				if (test_server)
-				{
-					ChatPacket(CHAT_TYPE_INFO, "Find %d, count %d, require %d", prt->materials[i].vnum, CountSpecifyItem(prt->materials[i].vnum), prt->materials[i].count);
-				}
-
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("°³·®À» ÇÏ±â À§ÇÑ Àç·á°¡ ºÎÁ·ÇÕ´Ï´Ù."));
-				return false;
-			}
-		}
-
-		for (int i = 0; i < prt->material_count; ++i)
-			RemoveSpecifyItem(prt->materials[i].vnum, prt->materials[i].count, item->GetCell());
-	}
-
-	int prob = number(1, 100);
-
-	if (IsRefineThroughGuild() || bMoneyOnly)
-		prob -= 10;
-
-	// END_OF_REFINE_COST
-
-	if (prob <= prt->prob)
-	{
-		// ¼º°ø! ¸ðµç ¾ÆÀÌÅÛÀÌ »ç¶óÁö°í, °°Àº ¼Ó¼ºÀÇ ´Ù¸¥ ¾ÆÀÌÅÛ È¹µæ
-		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
-
-		if (pkNewItem)
-		{
-			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
-			if (aApplyRandom)
-				pkNewItem->SetRandomApplies(aApplyRandom);
-#endif
-
-			LogManager::instance().ItemLog(this, pkNewItem, "REFINE SUCCESS", pkNewItem->GetName());
-
-			UINT bCell = item->GetCell();
-
-			// DETAIL_REFINE_LOG
-			NotifyRefineSuccess(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
-			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -cost);
-			// END_OF_DETAIL_REFINE_LOG
-
-#if defined(__REFINE_STACK_FIX__)
-			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-			{
-				item->SetCount(item->GetCount() - 1);
-				AutoGiveItem(pkNewItem, true, true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-					, true
-#endif
-				);
-			}
-			else
-			{
-				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
-				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-			}
-#else
-			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
-			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-#endif
-
-			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
-			pkNewItem->AttrLog();
-
-			sys_log(0, "Refine Success %d", cost);
-			//PointChange(POINT_GOLD, -cost);
-			sys_log(0, "PayPee %d", cost);
-			PayRefineFee(cost);
-			sys_log(0, "PayPee End %d", cost);
-		}
-		else
-		{
-			// DETAIL_REFINE_LOG
-			// ¾ÆÀÌÅÛ »ý¼º¿¡ ½ÇÆÐ -> °³·® ½ÇÆÐ·Î °£ÁÖ
-			sys_err("cannot create item %u", result_vnum);
-#if defined(__REFINE_MSG_ADD__)
-			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, IsRefineThroughGuild() ? "GUILD" : "POWER");
-#else
-			NotifyRefineFail(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
-#endif
-			// END_OF_DETAIL_REFINE_LOG
-		}
-	}
-	else
-	{
-		// ½ÇÆÐ! ¸ðµç ¾ÆÀÌÅÛÀÌ »ç¶óÁü.
-		DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -cost);
-#if defined(__REFINE_MSG_ADD__)
-		NotifyRefineFailType(this, item, REFINE_FAIL_DEL_ITEM, IsRefineThroughGuild() ? "GUILD" : "POWER");
-#else
-		NotifyRefineFail(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
-#endif
-		item->AttrLog();
-
-#if defined(__REFINE_STACK_FIX__)
-		if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-		{
-			item->SetCount(item->GetCount() - 1);
-		}
-		else
-		{
-			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
-		}
-#else
-		ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
-#endif
-
-		//PointChange(POINT_GOLD, -cost);
-		PayRefineFee(cost);
-	}
-
-	return true;
-}
-
-enum ERefineScroll
-{
-	CHUKBOK_SCROLL = 0,
-	HYUNIRON_STONE = 1,
-	YONGSIN_SCROLL = 2,
-	MUSIN_SCROLL = 3,
-	YAGONG_SCROLL = 4,
-	MEMO_SCROLL = 5,
-	BDRAGON_SCROLL = 6,
-#if defined(__STONE_OF_BLESS__)
-	BLESSING_STONE = 7,
-#endif
-#if defined(__SOUL_SYSTEM__)
-	SOUL_AWAKE_SCROLL = 8,
-	SOUL_EVOLVE_SCROLL = 9,
-#endif
-#if defined(__STONE_OF_BLESS__)
-	MALL_BLESSING_STONE = 10,
-#endif
-};
-
-#if defined(__SOUL_SYSTEM__)
-bool CHARACTER::DoRefineSoul(LPITEM item)
-{
-	if (!CanHandleItem(true))
-	{
-		ClearRefineMode();
-		return false;
-	}
-
-	ClearRefineMode();
-
-	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
-	if (!prt)
-		return false;
-
-	if (m_iRefineAdditionalCell < 0)
-		return false;
-
-	LPITEM item_scroll = GetInventoryItem(m_iRefineAdditionalCell);
-	if (item_scroll == nullptr)
-		return false;
-
-	if (!(item_scroll->GetType() == ITEM_USE && item_scroll->GetSubType() == USE_TUNING))
-		return false;
-
-	if (item_scroll->GetVnum() == item->GetVnum())
-		return false;
-
-	DWORD result_vnum = item->GetRefinedVnum();
-	if (result_vnum == 0)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("´õ ÀÌ»ó °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	TItemTable* proto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
-	if (!proto)
-	{
-		sys_err("DoRefineSoul NOT GET ITEM PROTO %d", item->GetRefinedVnum());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀº °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	int prob = number(1, 100);
-	int success_prob = prt->prob;
-
-	switch (item_scroll->GetValue(0))
-	{
-		case SOUL_AWAKE_SCROLL:
-			success_prob = 100;
-			break;
-
-		case SOUL_EVOLVE_SCROLL:
-			success_prob = soul_refine_prob[MINMAX(0, item->GetValue(1), SOUL_GRADE_MAX)];
-			break;
-	}
-
-	item_scroll->SetCount(item_scroll->GetCount() - 1);
-
-	if (prob <= success_prob)
-	{
-		LPITEM new_item = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
-		if (new_item)
-		{
-			WORD wCell = item->GetCell();
-
-			LogManager::instance().ItemLog(this, new_item, "SOUL REFINE FAIL", new_item->GetName());
-			ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulSuceeded");
-
-			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (SOUL REFINE FAIL)");
-
-			new_item->AddToCharacter(this, TItemPos(INVENTORY, wCell));
-			ITEM_MANAGER::instance().FlushDelayedSave(new_item);
-		}
-		else
-		{
-			sys_err("cannot create item %u", result_vnum);
-			ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulFailed");
-		}
-	}
-	else
-	{
-		ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulFailed");
-	}
-
-	return true;
-}
-#endif
-
-bool CHARACTER::DoRefineWithScroll(LPITEM item)
-{
-	if (!CanHandleItem(true))
-	{
-		ClearRefineMode();
-		return false;
-	}
-
-	ClearRefineMode();
-
-	// °³·® ½Ã°£Á¦ÇÑ : upgrade_refine_scroll.quest ¿¡¼­ °³·®ÈÄ 5ºÐÀÌ³»¿¡ ÀÏ¹Ý °³·®À»
-	// ÁøÇàÇÒ¼ö ¾øÀ½
-	if (quest::CQuestManager::instance().GetEventFlag("update_refine_time") != 0)
-	{
-		if (get_global_time() < quest::CQuestManager::instance().GetEventFlag("update_refine_time") + (60 * 5))
-		{
-			sys_log(0, "can't refine %d %s", GetPlayerID(), GetName());
-			return false;
-		}
-	}
-
-	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
-	if (!prt)
-		return false;
-
-	LPITEM pkItemScroll;
-
-	// °³·®¼­ Ã¼Å©
-	if (m_iRefineAdditionalCell < 0)
-		return false;
-
-	pkItemScroll = GetInventoryItem(m_iRefineAdditionalCell);
-
-	if (!pkItemScroll)
-		return false;
-
-	if (!(pkItemScroll->GetType() == ITEM_USE && pkItemScroll->GetSubType() == USE_TUNING))
-		return false;
-
-	if (pkItemScroll->GetVnum() == item->GetVnum())
-		return false;
-
-	DWORD result_vnum = item->GetRefinedVnum();
-	DWORD result_fail_vnum = item->GetRefineFromVnum();
-
-	if (result_vnum == 0)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("´õ ÀÌ»ó °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	TItemTable* pProto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
-	if (!pProto)
-	{
-		sys_err("DoRefineWithScroll NOT GET ITEM PROTO %d", item->GetRefinedVnum());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀº °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	if (GetGold() < prt->cost)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("°³·®À» ÇÏ±â À§ÇÑ µ·ÀÌ ºÎÁ·ÇÕ´Ï´Ù."));
-		return false;
-	}
-
-#if defined(__REFINE_STACK_FIX__)
-	int iEmptyPos = GetEmptyInventory(item->GetSize());
-	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-	{
-		if (-1 == iEmptyPos)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ÒÁöÇ°¿¡ ºó °ø°£ÀÌ ¾ø½À´Ï´Ù."));
-			return false;
-		}
-	}
-#endif
-
-	for (int i = 0; i < prt->material_count; ++i)
-	{
-		if (CountSpecifyItem(prt->materials[i].vnum, item->GetCell()) < prt->materials[i].count)
-		{
-			if (test_server)
-			{
-				ChatPacket(CHAT_TYPE_INFO, "Find %d, count %d, require %d", prt->materials[i].vnum, CountSpecifyItem(prt->materials[i].vnum), prt->materials[i].count);
-			}
-
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("°³·®À» ÇÏ±â À§ÇÑ Àç·á°¡ ºÎÁ·ÇÕ´Ï´Ù."));
-			return false;
-		}
-	}
-
-	for (int i = 0; i < prt->material_count; ++i)
-		RemoveSpecifyItem(prt->materials[i].vnum, prt->materials[i].count, item->GetCell());
-
-	int prob = number(1, 100);
-	const SRefineScrollData& kScroll = GetScrollRefinePct(prt->prob, item->GetRefinedVnum(), pkItemScroll->GetValue(0));
-	const char* szRefineType = "SCROLL";
-
-	switch (pkItemScroll->GetValue(0))
-	{
-		case HYUNIRON_STONE:
-			szRefineType = "HYUNIRON_STONE";
-			break;
-
-		case YONGSIN_SCROLL:
-			szRefineType = "GOD_SCROLL";
-			break;
-
-		case MUSIN_SCROLL:
-			szRefineType = "MUSIN_SCROLL";
-			break;
-
-		case YAGONG_SCROLL:
-			szRefineType = "YAGONG_SCROLL";
-			break;
-
-		case MEMO_SCROLL:
-			szRefineType = "MEMO_SCROLL";
-			break;
-
-		case BDRAGON_SCROLL:
-			szRefineType = "BDRAGON_SCROLL";
-			break;
-
-#if defined(__STONE_OF_BLESS__)
-		case BLESSING_STONE:
-			szRefineType = "BLESSING_STONE";
-			break;
-
-		case MALL_BLESSING_STONE:
-			szRefineType = "MALL_BLESSING_STONE";
-			break;
-#endif
-
-		default:
-			sys_err("REFINE : Unknown refine scroll item. Value0: %d", pkItemScroll->GetValue(0));
-			break;
-	}
-
-	if (test_server)
-		ChatPacket(CHAT_TYPE_INFO, "[Only Test] SuccessProb %d, RefineLevel %d ", kScroll.bSuccessProb, item->GetRefineLevel());
-
-	pkItemScroll->SetCount(pkItemScroll->GetCount() - 1);
-
-	if (prob <= kScroll.bSuccessProb)
-	{
-		// ¼º°ø! ¸ðµç ¾ÆÀÌÅÛÀÌ »ç¶óÁö°í, °°Àº ¼Ó¼ºÀÇ ´Ù¸¥ ¾ÆÀÌÅÛ È¹µæ
-		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
-
-		if (pkNewItem)
-		{
-			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
-			if (aApplyRandom)
-				pkNewItem->SetRandomApplies(aApplyRandom);
-#endif
-
-			LogManager::instance().ItemLog(this, pkNewItem, "REFINE SUCCESS", pkNewItem->GetName());
-
-			UINT bCell = item->GetCell();
-
-			NotifyRefineSuccess(this, item, szRefineType);
-			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -prt->cost);
-
-#if defined(__REFINE_STACK_FIX__)
-			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-			{
-				item->SetCount(item->GetCount() - 1);
-				AutoGiveItem(pkNewItem, true, true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-					, true
-#endif
-				);
-			}
-			else
-			{
-				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
-				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-			}
-#else
-			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
-			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-#endif
-
-			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
-			pkNewItem->AttrLog();
-
-			//PointChange(POINT_GOLD, -prt->cost);
-			PayRefineFee(prt->cost);
-		}
-		else
-		{
-			// ¾ÆÀÌÅÛ »ý¼º¿¡ ½ÇÆÐ -> °³·® ½ÇÆÐ·Î °£ÁÖ
-			sys_err("cannot create item %u", result_vnum);
-#if defined(__REFINE_MSG_ADD__)
-			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
-#else
-			NotifyRefineFail(this, item, szRefineType);
-#endif
-		}
-	}
-	else if (!kScroll.bKeepGrade && result_fail_vnum)
-	{
-		// ½ÇÆÐ! ¸ðµç ¾ÆÀÌÅÛÀÌ »ç¶óÁö°í, °°Àº ¼Ó¼ºÀÇ ³·Àº µî±ÞÀÇ ¾ÆÀÌÅÛ È¹µæ
-		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_fail_vnum, 1, 0, false);
-
-		if (pkNewItem)
-		{
-			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_PREVIOUS);
-			if (aApplyRandom)
-				pkNewItem->SetRandomApplies(aApplyRandom);
-#endif
-
-			LogManager::instance().ItemLog(this, pkNewItem, "REFINE FAIL", pkNewItem->GetName());
-
-			UINT bCell = item->GetCell();
-
-			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -prt->cost);
-#if defined(__REFINE_MSG_ADD__)
-			NotifyRefineFailType(this, item, REFINE_FAIL_GRADE_DOWN, szRefineType, -1);
-#else
-			NotifyRefineFail(this, item, szRefineType, -1);
-
-#endif
-
-#if defined(__REFINE_STACK_FIX__)
-			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-			{
-				item->SetCount(item->GetCount() - 1);
-				AutoGiveItem(pkNewItem, true, true
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-					, true
-#endif
-				);
-			}
-			else
-			{
-				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
-				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-			}
-#else
-			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
-			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
-#endif
-
-			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
-			pkNewItem->AttrLog();
-
-			//PointChange(POINT_GOLD, -prt->cost);
-			PayRefineFee(prt->cost);
-		}
-		else
-		{
-			// ¾ÆÀÌÅÛ »ý¼º¿¡ ½ÇÆÐ -> °³·® ½ÇÆÐ·Î °£ÁÖ
-			sys_err("cannot create item %u", result_fail_vnum);
-#if defined(__REFINE_MSG_ADD__)
-			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
-#else
-			NotifyRefineFail(this, item, szRefineType);
-#endif
-		}
-	}
-	else
-	{
-#if defined(__REFINE_MSG_ADD__)
-		NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
-#else
-		NotifyRefineFail(this, item, szRefineType); // °³·®½Ã ¾ÆÀÌÅÛ »ç¶óÁöÁö ¾ÊÀ½
-#endif
-		PayRefineFee(prt->cost);
-	}
-
-	return true;
-}
-
-CHARACTER::SRefineScrollData CHARACTER::GetScrollRefinePct(BYTE bProb, BYTE bRefineLevel, BYTE bScrollType)
-{
-	SRefineScrollData Scroll{};
-	Scroll.bSuccessProb = bProb;
-	Scroll.bKeepGrade = false;
-
-	// ÇöÃ¶, ¿ë½ÅÀÇ Ãàº¹¼­, ¾ß°øÀÇ ºñÀü¼­ Ã³¸®
-	switch (bScrollType)
-	{
-		case CHUKBOK_SCROLL:
-			break;
-
-		case HYUNIRON_STONE:
-			Scroll.bSuccessProb = MINMAX(1, bProb + 10, 100);
-			Scroll.bKeepGrade = true;
-			break;
-
-		case YONGSIN_SCROLL:
-			Scroll.bSuccessProb = MINMAX(1, bProb + 10, 100);
-			break;
-
-		case MUSIN_SCROLL: // ¹«½ÅÀÇ Ãàº¹¼­´Â 100% ¼º°ø (+4±îÁö¸¸)
-			Scroll.bSuccessProb = 100;
-			break;
-
-		case YAGONG_SCROLL:
-			Scroll.bSuccessProb = MINMAX(1, bProb + 15, 100);
-			break;
-
-		case MEMO_SCROLL:
-			Scroll.bSuccessProb = 100;
-			break;
-
-		case BDRAGON_SCROLL:
-			Scroll.bSuccessProb = 80;
-			break;
-
-#if defined(__STONE_OF_BLESS__)
-		case BLESSING_STONE:
-			Scroll.bSuccessProb = MINMAX(1, bProb + 15, 100);
-			Scroll.bKeepGrade = true;
-			break;
-
-		case MALL_BLESSING_STONE:
-			Scroll.bSuccessProb = MINMAX(1, bProb + 20, 100);
-			Scroll.bKeepGrade = true;
-			break;
-#endif
-	}
-
-	return Scroll;
-}
-
-bool CHARACTER::RefineInformation(WORD wCell, BYTE bType, int iAdditionalCell)
-{
-	if (wCell > INVENTORY_MAX_NUM)
-		return false;
-
-	const LPITEM item = GetInventoryItem(wCell);
-	if (!item)
-		return false;
-
-	// REFINE_COST
-	if (bType == REFINE_TYPE_MONEY_ONLY && !GetQuestFlag("deviltower_zone.can_refine"))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ç±Í Å¸¿ö ¿Ï·á º¸»óÀº ÇÑ¹ø±îÁö »ç¿ë°¡´ÉÇÕ´Ï´Ù."));
-		return false;
-	}
-	// END_OF_REFINE_COST
-
-	TPacketGCRefineInformation p;
-	p.header = HEADER_GC_REFINE_INFORMATION;
-	p.pos = wCell;
-	p.src_vnum = item->GetVnum();
-	p.result_vnum = item->GetRefinedVnum();
-	p.type = bType;
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	thecore_memcpy(&p.RefineElement, item->GetRefineElement(), sizeof(p.RefineElement));
-#endif
-
-#if defined(__ITEM_APPLY_RANDOM__)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
-	item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
-	thecore_memcpy(&p.aApplyRandom, aApplyRandom, sizeof(p.aApplyRandom));
-#endif
-
-	if (p.result_vnum == 0)
-	{
-		sys_err("RefineInformation p.result_vnum == 0");
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀº °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TUNING)
-	{
-		if (bType == 0)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀº ÀÌ ¹æ½ÄÀ¸·Î´Â °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-			return false;
-		}
-		else
-		{
-			const LPITEM& item_scroll = GetInventoryItem(iAdditionalCell);
-			if (!item_scroll || item->GetVnum() == item_scroll->GetVnum())
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("°°Àº °³·®¼­¸¦ ÇÕÄ¥ ¼ö´Â ¾ø½À´Ï´Ù."));
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ãàº¹ÀÇ ¼­¿Í ÇöÃ¶À» ÇÕÄ¥ ¼ö ÀÖ½À´Ï´Ù."));
-				return false;
-			}
-		}
-	}
-
-#if defined(__SOUL_SYSTEM__)
-	if (item->GetType() == ITEM_SOUL)
-	{
-		if (bType == REFINE_TYPE_SOUL_AWAKE || bType == REFINE_TYPE_SOUL_EVOLVE)
-		{
-			p.cost = 0;
-			p.prob = bType == REFINE_TYPE_SOUL_AWAKE ? 100 : soul_refine_prob[MINMAX(0, item->GetValue(1), SOUL_GRADE_MAX)];
-			p.material_count = 0;
-			std::memset(p.materials, 0, sizeof(p.materials));
-
-			GetDesc()->Packet(&p, sizeof(TPacketGCRefineInformation));
-
-			SetRefineMode(iAdditionalCell);
-			return true;
-		}
-	}
-#endif
-
-	CRefineManager& rm = CRefineManager::instance();
-	const TRefineTable* prt = rm.GetRefineRecipe(item->GetRefineSet());
-	if (!prt)
-	{
-		sys_err("RefineInformation NOT GET REFINE SET %d", item->GetRefineSet());
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀº °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	// REFINE_COST
-
-	// MAIN_QUEST_LV7
-	if (GetQuestFlag("main_quest_lv7.refine_chance") > 0)
-	{
-		// ÀÏº»Àº Á¦¿Ü
-		if (!item->CheckItemUseLevel(20) || item->GetType() != ITEM_WEAPON)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¹«·á °³·® ±âÈ¸´Â 20 ÀÌÇÏÀÇ ¹«±â¸¸ °¡´ÉÇÕ´Ï´Ù"));
-			return false;
-		}
-		p.cost = 0;
-	}
-	else
-		p.cost = ComputeRefineFee(prt->cost);
-	// END_MAIN_QUEST_LV7
-
-	const LPITEM& item_scroll = GetInventoryItem(iAdditionalCell);
-	if (item_scroll)
-	{
-		const SRefineScrollData& kScroll = GetScrollRefinePct(prt->prob, item->GetRefinedVnum(), item_scroll->GetValue(0));
-		p.prob = kScroll.bSuccessProb;
-	}
-	else
-	{
-		p.prob = prt->prob;
-
-		if (IsRefineThroughGuild())
-			p.prob += 10;
-	}
-
-	if (p.prob > 100)
-		p.prob = 100;
-
-	if (bType == REFINE_TYPE_MONEY_ONLY)
-	{
-		p.material_count = 0;
-		memset(p.materials, 0, sizeof(p.materials));
-	}
-	else
-	{
-		p.material_count = prt->material_count;
-		thecore_memcpy(&p.materials, prt->materials, sizeof(prt->materials));
-	}
-	// END_OF_REFINE_COST
-
-	GetDesc()->Packet(&p, sizeof(TPacketGCRefineInformation));
-
-	SetRefineMode(iAdditionalCell);
-	return true;
-}
-
-bool CHARACTER::RefineItem(LPITEM pkItem, LPITEM pkTarget)
-{
-	if (!CanHandleItem())
-		return false;
-
-	if (pkItem->GetSubType() == USE_TUNING)
-	{
-		// XXX ¼º´É, ¼ÒÄÏ °³·®¼­´Â »ç¶óÁ³½À´Ï´Ù...
-		// XXX ¼º´É°³·®¼­´Â Ãàº¹ÀÇ ¼­°¡ µÇ¾ú´Ù!
-
-		BYTE bRefineType = REFINE_TYPE_NORMAL;
-		switch (pkItem->GetValue(0))
-		{
-			case HYUNIRON_STONE:
-				bRefineType = REFINE_TYPE_HYUNIRON;
-				break;
-
-			case MUSIN_SCROLL:
-			{
-				if (pkTarget->GetRefineLevel() >= 4)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ °³·®¼­·Î ´õ ÀÌ»ó °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-
-				bRefineType = REFINE_TYPE_MUSIN;
-			}
-			break;
-
-			case MEMO_SCROLL:
-			{
-				if (pkTarget->GetRefineLevel() != pkItem->GetValue(1))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ °³·®¼­·Î °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-
-				bRefineType = REFINE_TYPE_NOT_USED1;
-			}
-			break;
-
-			case BDRAGON_SCROLL:
-			{
-				if (pkTarget->GetType() != ITEM_METIN || pkTarget->GetRefineLevel() != 4)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀ¸·Î °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-
-				if (pkTarget->GetRefineSet() != 702)
-					return false;
-			}
-			break;
-
-#if defined(__STONE_OF_BLESS__)
-			case BLESSING_STONE:
-			{
-				if (pkTarget->GetLevelLimit() <= 80)
-					return false;
-
-				bRefineType = REFINE_TYPE_BLESSING_STONE;
-			}
-			break;
-
-			case MALL_BLESSING_STONE:
-				bRefineType = REFINE_TYPE_BLESSING_STONE;
-				break;
-#endif
-
-#if defined(__SOUL_SYSTEM__)
-			case SOUL_AWAKE_SCROLL:
-			case SOUL_EVOLVE_SCROLL:
-			{
-				if (pkTarget->GetType() != ITEM_SOUL)
-					return false;
-
-				if (pkTarget->GetValue(0) >= SOUL_GRADE_ILUMINED)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Soul System] %s is already at the highest level.", LC_ITEM(pkTarget->GetVnum())));
-					return false;
-				}
-
-				if (pkItem->GetValue(0) == SOUL_AWAKE_SCROLL)
-					bRefineType = REFINE_TYPE_SOUL_AWAKE;
-				else if (pkItem->GetValue(0) == SOUL_EVOLVE_SCROLL)
-					bRefineType = REFINE_TYPE_SOUL_EVOLVE;
-			}
-			break;
-#endif
-
-			default:
-			{
-				if (pkTarget->GetRefineSet() == 501)
-					return false;
-
-				if (pkTarget->GetVnum() >= 28330 && pkTarget->GetVnum() <= 28343) // ¿µ¼®+3
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("+3 ¿µ¼®Àº ÀÌ ¾ÆÀÌÅÛÀ¸·Î °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù"));
-					return false;
-				}
-
-				if (pkTarget->GetVnum() >= 28430 && pkTarget->GetVnum() <= 28443) // ¿µ¼®+4
-				{
-					if (pkItem->GetVnum() != 71056) // Ã»·æÀÇ¼û°á
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("¿µ¼®Àº ÀÌ ¾ÆÀÌÅÛÀ¸·Î °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù"));
-						return false;
-					}
-				}
-
-				bRefineType = REFINE_TYPE_SCROLL;
-			}
-			break;
-		}
-
-		RefineInformation(pkTarget->GetCell(), bRefineType, pkItem->GetCell());
-	}
-	else if (pkItem->GetSubType() == USE_DETACHMENT && IS_SET(pkTarget->GetFlag(), ITEM_FLAG_REFINEABLE) && pkTarget->IsRemovableSocket())
-	{
-		LogManager::instance().ItemLog(this, pkTarget, "USE_DETACHMENT", pkTarget->GetName());
-
-		bool bHasMetinStone = false;
-
-		for (int i = 0; i < METIN_SOCKET_MAX_NUM; i++)
-		{
-			long socket = pkTarget->GetSocket(i);
-			if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
-			{
-				bHasMetinStone = true;
-				break;
-			}
-		}
-
-		if (bHasMetinStone)
-		{
-			for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-			{
-				long socket = pkTarget->GetSocket(i);
-				if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
-				{
-#if defined(__GLOVE_SYSTEM__)
-					if (pkTarget->IsGlove() && socket >= 1000000)
-					{
-						DWORD dwBaseIndex = 28046;
-						dwBaseIndex += (((socket / 1000) % 10) * 100);
-						dwBaseIndex += ((socket / 100) % 10) - 1;
-
-						const TItemTable* pItemData = ITEM_MANAGER::instance().GetTable(dwBaseIndex);
-						if (pItemData == nullptr)
-							continue;
-
-						socket = dwBaseIndex;
-					}
-#endif
-					AutoGiveItem(socket);
-					//TItemTable* pTable = ITEM_MANAGER::instance().GetTable(pkTarget->GetSocket(i));
-					//pkTarget->SetSocket(i, pTable->alValues[2]);
-					// ±úÁøµ¹·Î ´ëÃ¼ÇØÁØ´Ù
-					pkTarget->SetSocket(i, ITEM_BROKEN_METIN_VNUM);
-				}
-			}
-			pkItem->SetCount(pkItem->GetCount() - 1);
-			return true;
-		}
-		else
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("»©³¾ ¼ö ÀÖ´Â ¸ÞÆ¾¼®ÀÌ ¾ø½À´Ï´Ù."));
-			return false;
-		}
-	}
-
-	return false;
-}
-
-EVENTFUNC(kill_campfire_event)
-{
-	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("kill_campfire_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPCHARACTER ch = info->ch;
-
-	if (ch == NULL) // <Factor>
-		return 0;
-
-	ch->m_pkMiningEvent = NULL;
-	M2_DESTROY_CHARACTER(ch);
-	return 0;
-}
-
-bool CHARACTER::GiveRecallItem(LPITEM item)
-{
-	int idx = GetMapIndex();
-	int iEmpireByMapIndex = -1;
-
-	if (idx < 20)
-		iEmpireByMapIndex = 1;
-	else if (idx < 40)
-		iEmpireByMapIndex = 2;
-	else if (idx < 60)
-		iEmpireByMapIndex = 3;
-	else if (idx < 10000)
-		iEmpireByMapIndex = 0;
-
-	switch (idx)
-	{
-		case 66:
-		case 216:
-		case 301:
-		case 302:
-		case 303:
-		case 304:
-			iEmpireByMapIndex = -1;
-			break;
-	}
-
-	if (iEmpireByMapIndex && GetEmpire() != iEmpireByMapIndex)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("±â¾ïÇØ µÑ ¼ö ¾ø´Â À§Ä¡ ÀÔ´Ï´Ù."));
-		return false;
-	}
-
-	int pos;
-
-	if (item->GetCount() == 1) // ¾ÆÀÌÅÛÀÌ ÇÏ³ª¶ó¸é ±×³É ¼ÂÆÃ.
-	{
-		item->SetSocket(0, GetX());
-		item->SetSocket(1, GetY());
-	}
-	else if ((pos = GetEmptyInventory(item->GetSize())) != -1) // ±×·¸Áö ¾Ê´Ù¸é ´Ù¸¥ ÀÎº¥Åä¸® ½½·ÔÀ» Ã£´Â´Ù.
-	{
-		LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), 1);
-		if (item2 != nullptr)
-		{
-			item2->SetSocket(0, GetX());
-			item2->SetSocket(1, GetY());
-			item2->AddToCharacter(this, TItemPos(INVENTORY, pos));
-
-			item->SetCount(item->GetCount() - 1);
-		}
-	}
-	else
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ÒÁöÇ°¿¡ ºó °ø°£ÀÌ ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	return true;
-}
-
-void CHARACTER::ProcessRecallItem(LPITEM item)
-{
-	int idx;
-
-	if ((idx = SECTREE_MANAGER::instance().GetMapIndex(item->GetSocket(0), item->GetSocket(1))) == 0)
-		return;
-
-	int iEmpireByMapIndex = -1;
-
-	if (idx < 20)
-		iEmpireByMapIndex = 1;
-	else if (idx < 40)
-		iEmpireByMapIndex = 2;
-	else if (idx < 60)
-		iEmpireByMapIndex = 3;
-	else if (idx < 10000)
-		iEmpireByMapIndex = 0;
-
-	switch (idx)
-	{
-		case 66:
-		case 216:
-			iEmpireByMapIndex = -1;
-			break;
-			// ¾Ç·æ±ºµµ ÀÏ¶§
-		case 301:
-		case 302:
-		case 303:
-		case 304:
-			if (GetLevel() < 90)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛÀÇ ·¹º§ Á¦ÇÑº¸´Ù ·¹º§ÀÌ ³·½À´Ï´Ù."));
-				return;
-			}
-			else
-				break;
-	}
-
-	if (iEmpireByMapIndex && GetEmpire() != iEmpireByMapIndex)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("±â¾ïµÈ À§Ä¡°¡ Å¸Á¦±¹¿¡ ¼ÓÇØ ÀÖ¾î¼­ ±ÍÈ¯ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		item->SetSocket(0, 0);
-		item->SetSocket(1, 0);
-	}
-	else
-	{
-		sys_log(1, "Recall: %s %d %d -> %d %d", GetName(), GetX(), GetY(), item->GetSocket(0), item->GetSocket(1));
-		WarpSet(item->GetSocket(0), item->GetSocket(1));
-		item->SetCount(item->GetCount() - 1);
-	}
-}
-
-void CHARACTER::__OpenPrivateShop()
-{
-	unsigned bodyPart = GetPart(PART_MAIN);
-	switch (bodyPart)
-	{
-	case 0:
-	case 1:
-	case 2:
-		ChatPacket(CHAT_TYPE_COMMAND, "OpenPrivateShop");
-		break;
-	default:
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("°©¿ÊÀ» ¹þ¾î¾ß °³ÀÎ »óÁ¡À» ¿­ ¼ö ÀÖ½À´Ï´Ù."));
-		break;
-	}
-}
-
-// MYSHOP_PRICE_LIST
-
-void CHARACTER::SendMyShopPriceListCmd(DWORD dwItemVnum, DWORD dwItemPrice
-#if defined(__CHEQUE_SYSTEM__)
-	, DWORD dwItemCheque
-#endif
-)
-{
-	char szLine[256];
-#if defined(__CHEQUE_SYSTEM__)
-	snprintf(szLine, sizeof(szLine), "MyShopPriceList %u %u %u", dwItemVnum, dwItemPrice, dwItemCheque);
-#else
-	snprintf(szLine, sizeof(szLine), "MyShopPriceList %u %u", dwItemVnum, dwItemPrice);
-#endif
-	ChatPacket(CHAT_TYPE_COMMAND, szLine);
-	sys_log(0, szLine);
-}
-
-//
-// DB Ä³½Ã·Î ºÎÅÍ ¹ÞÀº ¸®½ºÆ®¸¦ User ¿¡°Ô Àü¼ÛÇÏ°í »óÁ¡À» ¿­¶ó´Â Ä¿¸Çµå¸¦ º¸³½´Ù.
-//
-void CHARACTER::UseSilkBotaryReal(const TPacketMyshopPricelistHeader* p)
-{
-	const TItemPriceInfo* pInfo = (const TItemPriceInfo*)(p + 1);
-
-#if defined(__CHEQUE_SYSTEM__)
-	if (!p->byCount)
-		SendMyShopPriceListCmd(1, 0, 0);
-	else
-	{
-		for (int idx = 0; idx < p->byCount; idx++)
-			SendMyShopPriceListCmd(pInfo[idx].dwVnum, pInfo[idx].dwPrice, pInfo[idx].dwCheque);
-	}
-#else
-	if (!p->byCount)
-		// °¡°Ý ¸®½ºÆ®°¡ ¾ø´Ù. dummy µ¥ÀÌÅÍ¸¦ ³ÖÀº Ä¿¸Çµå¸¦ º¸³»ÁØ´Ù.
-		SendMyShopPriceListCmd(1, 0);
-	else {
-		for (int idx = 0; idx < p->byCount; idx++)
-			SendMyShopPriceListCmd(pInfo[idx].dwVnum, pInfo[idx].dwPrice);
-	}
-#endif
-
-	__OpenPrivateShop();
-}
-
-//
-// ÀÌ¹ø Á¢¼Ó ÈÄ Ã³À½ »óÁ¡À» Open ÇÏ´Â °æ¿ì ¸®½ºÆ®¸¦ Load ÇÏ±â À§ÇØ DB Ä³½Ã¿¡ °¡°ÝÁ¤º¸ ¸®½ºÆ® ¿äÃ» ÆÐÅ¶À» º¸³½´Ù.
-// ÀÌÈÄºÎÅÍ´Â ¹Ù·Î »óÁ¡À» ¿­¶ó´Â ÀÀ´äÀ» º¸³½´Ù.
-//
-void CHARACTER::UseSilkBotary(void)
-{
-	if (m_bNoOpenedShop)
-	{
-		DWORD dwPlayerID = GetPlayerID();
-		db_clientdesc->DBPacket(HEADER_GD_MYSHOP_PRICELIST_REQ, GetDesc()->GetHandle(), &dwPlayerID, sizeof(DWORD));
-		m_bNoOpenedShop = false;
-	}
-	else
-	{
-		__OpenPrivateShop();
-	}
-}
-// END_OF_MYSHOP_PRICE_LIST
-
-int CalculateConsume(LPCHARACTER ch)
-{
-	static const int WARP_NEED_LIFE_PERCENT = 30;
-	static const int WARP_MIN_LIFE_PERCENT = 10;
-	// CONSUME_LIFE_WHEN_USE_WARP_ITEM
-	int consumeLife = 0;
-	{
-		// CheckNeedLifeForWarp
-		const int curLife = ch->GetHP();
-		const int needPercent = WARP_NEED_LIFE_PERCENT;
-		const int needLife = ch->GetMaxHP() * needPercent / 100;
-		if (curLife < needLife)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("³²Àº »ý¸í·Â ¾çÀÌ ¸ðÀÚ¶ó »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-			return -1;
-		}
-
-		consumeLife = needLife;
-
-		// CheckMinLifeForWarp: µ¶¿¡ ÀÇÇØ¼­ Á×À¸¸é ¾ÈµÇ¹Ç·Î »ý¸í·Â ÃÖ¼Ò·®´Â ³²°ÜÁØ´Ù
-		const int minPercent = WARP_MIN_LIFE_PERCENT;
-		const int minLife = ch->GetMaxHP() * minPercent / 100;
-		if (curLife - needLife < minLife)
-			consumeLife = curLife - minLife;
-
-		if (consumeLife < 0)
-			consumeLife = 0;
-	}
-	// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
-	return consumeLife;
-}
-
-int CalculateConsumeSP(LPCHARACTER lpChar)
-{
-	static const int NEED_WARP_SP_PERCENT = 30;
-
-	const int curSP = lpChar->GetSP();
-	const int needSP = lpChar->GetMaxSP() * NEED_WARP_SP_PERCENT / 100;
-
-	if (curSP < needSP)
-	{
-		lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("³²Àº Á¤½Å·Â ¾çÀÌ ¸ðÀÚ¶ó »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return -1;
-	}
-
-	return needSP;
-}
-
-bool CHARACTER::UseItemEx(LPITEM item, TItemPos DestCell)
-{
-	int iLimitRealtimeStartFirstUseFlagIndex = -1;
-	int iLimitTimerBasedOnWearFlagIndex = -1;
-
-	WORD wDestCell = DestCell.cell;
-	BYTE bDestInven = DestCell.window_type;
-
-	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-	{
-		long limitValue = item->GetProto()->aLimits[i].lValue;
-
-		switch (item->GetProto()->aLimits[i].bType)
-		{
-			case LIMIT_LEVEL:
-			{
-				if (GetLevel() < limitValue)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛÀÇ ·¹º§ Á¦ÇÑº¸´Ù ·¹º§ÀÌ ³·½À´Ï´Ù."));
-					return false;
-				}
-			}
-			break;
-
-#if defined(__CONQUEROR_LEVEL__)
-			case LIMIT_NEWWORLD_LEVEL:
-			{
-				if (GetConquerorLevel() < limitValue)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛÀÇ ·¹º§ Á¦ÇÑº¸´Ù ·¹º§ÀÌ ³·½À´Ï´Ù."));
-					return false;
-				}
-			}
-			break;
-#endif
-
-			case LIMIT_REAL_TIME_START_FIRST_USE:
-				iLimitRealtimeStartFirstUseFlagIndex = i;
-				break;
-
-			case LIMIT_TIMER_BASED_ON_WEAR:
-				iLimitTimerBasedOnWearFlagIndex = i;
-				break;
-		}
-	}
-
-	if (test_server)
-	{
-		sys_log(0, "USE_ITEM %s, Inven %d, Cell %d, ItemType %d, SubType %d", item->GetName(), bDestInven, wDestCell, item->GetType(), item->GetSubType());
-	}
-
-	if (CArenaManager::instance().IsLimitedItem(GetMapIndex(), item->GetVnum()))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·Ã Áß¿¡´Â ÀÌ¿ëÇÒ ¼ö ¾ø´Â ¹°Ç°ÀÔ´Ï´Ù."));
-		return false;
-	}
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
-		iLimitRealtimeStartFirstUseFlagIndex = -1;
-#endif
-
-	// ¾ÆÀÌÅÛ ÃÖÃÊ »ç¿ë ÀÌÈÄºÎÅÍ´Â »ç¿ëÇÏÁö ¾Ê¾Æµµ ½Ã°£ÀÌ Â÷°¨µÇ´Â ¹æ½Ä Ã³¸®.
-	if (-1 != iLimitRealtimeStartFirstUseFlagIndex)
-	{
-		// ÇÑ ¹øÀÌ¶óµµ »ç¿ëÇÑ ¾ÆÀÌÅÛÀÎÁö ¿©ºÎ´Â Socket1À» º¸°í ÆÇ´ÜÇÑ´Ù. (Socket1¿¡ »ç¿ëÈ½¼ö ±â·Ï)
-		if (0 == item->GetSocket(1))
-		{
-			// »ç¿ë°¡´É½Ã°£Àº Default °ªÀ¸·Î Limit Value °ªÀ» »ç¿ëÇÏµÇ, Socket0¿¡ °ªÀÌ ÀÖÀ¸¸é ±× °ªÀ» »ç¿ëÇÏµµ·Ï ÇÑ´Ù. (´ÜÀ§´Â ÃÊ)
-			long duration = (0 != item->GetSocket(0)) ? item->GetSocket(0) : item->GetProto()->aLimits[iLimitRealtimeStartFirstUseFlagIndex].lValue;
-
-			if (0 == duration)
-				duration = 60 * 60 * 24 * 7;
-
-			item->SetSocket(0, time(0) + duration);
-			item->StartRealTimeExpireEvent();
-		}
-
-		if (false == item->IsEquipped())
-			item->SetSocket(1, item->GetSocket(1) + 1);
-	}
-
-#if defined(__MAILBOX__)
-	if (item->GetVnum() == ITEM_MOBILE_MAILBOX)
-	{
-		CMailBox::Open(this);
-		return true;
-	}
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	if (item->GetVnum() == ITEM_EXTEND_INVEN_TICKET ||
-		item->GetVnum() == ITEM_EXTEND_INVEN_TICKET_MALL)
-	{
-		ExtendInvenRequest();
-		return true;
-	}
-#endif
-
-	switch (item->GetType())
-	{
-#ifdef __GROWTH_PET_SYSTEM__
-		case ITEM_PET:
-			{
-				switch (item->GetSubType())
-				{
-					case PET_PAY:
-					{
-						if (GetArena() != NULL || IsObserverMode() == true)
-						{
-							if (item->GetVnum() == 50051 || item->GetVnum() == 50052 || item->GetVnum() == 50053)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·Ã Áß¿¡´Â ÀÌ¿ëÇÒ ¼ö ¾ø´Â ¹°Ç°ÀÔ´Ï´Ù."));
-								return false;
-							}
-						}
-
-						if (!IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE) || item->GetSubType() == PET_PAY)
-						{
-							if (item->GetSIGVnum() == 0)
-							{
-								quest::CQuestManager::instance().UseItem(GetPlayerID(), item, false);
-							}
-							else
-							{
-								quest::CQuestManager::instance().SIGUse(GetPlayerID(), item->GetSIGVnum(), item, false);
-							}
-						}
-						break;
-					}
-					
-					case PET_UPBRINGING:
-					{
-						LPGROWTH_PET pPet = GetGrowthPet(item->GetSocket(2));
-						if (pPet)
-						{
-							if (m_activeGrowthPet && m_activeGrowthPet->GetPetID() == pPet->GetPetID())
-							{
-								m_activeGrowthPet->Unsummon();
-								m_activeGrowthPet = nullptr;
-								return true;
-							}
-							else if (m_activeGrowthPet)
-								m_activeGrowthPet->Unsummon();
-
-							m_activeGrowthPet = pPet->Summon(item);
-						}
-					} break;
-
-					case PET_FEEDSTUFF:
-					{
-						LPITEM item2;
-
-						if (!GetItem(DestCell) || !(item2 = GetItem(DestCell)))
-							return false;
-
-						if (item2->GetType() != ITEM_PET && item2->GetSubType() != PET_UPBRINGING)
-							return false;
-
-						LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
-						if (!pPet)
-							return false;
-
-						if (item2->GetSocket(0) < get_global_time())
-						{
-							pPet->Revive(item2, PET_REVIVE_TYPE_NORMAL);
-							ITEM_MANAGER::instance().RemoveItem(item);
-						}
-						else
-						{
-							pPet->RewardFood(item, PET_FEED_TYPE_FULL);
-						}
-
-					} break;
-
-					case PET_BAG:
-					{
-						LPITEM item2 = GetItem(DestCell);
-						
-						if (item2)
-						{
-							if (item2->GetType() != ITEM_PET)
-								return false;
-
-							if (item2->GetSubType() != PET_UPBRINGING && item2->GetSubType() != PET_BAG)
-								return false;
-
-							switch (item2->GetSubType())
-							{
-								case PET_UPBRINGING:
-								{
-									LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
-									if (!pPet)
-										return false;
-
-									pPet->SetState(STATE_BAG);
-									pPet->SetSummonItem(nullptr);
-									pPet->Save();
-
-									time_t currentTime = time(0);
-									item->SetSocket(0, currentTime + item->GetLimitValue(0));
-									item->SetSocket(1, time(0));
-									item->SetSocket(2, pPet->GetPetID());
-									item->SetSocket(3, pPet->GetPetType());
-									item->StartRealTimeExpireEvent();
-
-									ITEM_MANAGER::instance().RemoveItem(item2, "REMOVE (UPBRINGING-BAG TRANSFER)");
-								} break;
-
-								case PET_BAG:
-								{
-									LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
-									if (!pPet)
-										return false;
-
-									/* Pet age equals to difference between birthday and current time minus time spent in bag */
-
-									// Time spent in bag: current time - the time pet was put into the bag
-									time_t currentTime = time(0);
-									DWORD dwBagTime = currentTime - (item2->GetSocket(0) - item2->GetLimitValue(0));
-									DWORD dwPetAge = currentTime - pPet->GetPetPoint(POINT_UPBRINGING_BIRTHDAY) - dwBagTime;
-
-									// Shift back pet's birthday from current time & update real time event
-									pPet->ChangePetPoint(POINT_UPBRINGING_BIRTHDAY, currentTime - dwPetAge, true);
-									pPet->Save();
-
-									item2->SetSocket(0, currentTime + item2->GetLimitValue(0));
-									item2->StartRealTimeExpireEvent();
-									item->SetSocket(3, pPet->GetPetType());
-
-									ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (BAG-BAG TRANSFER)");
-								} break;
-							}
-						}
-						else
-						{
-							if (!item->GetSocket(2))
-								return false;
-
-							LPGROWTH_PET pPet = GetGrowthPet(item->GetSocket(2));
-							if (!pPet)
-								return false;
-
-							time_t currentTime = time(0);
-							DWORD dwBagTime = item->GetSocket(0) - item->GetLimitValue(0);
-							DWORD dwPetAge = currentTime - pPet->GetPetPoint(POINT_UPBRINGING_BIRTHDAY) - (currentTime - dwBagTime);
-							DWORD dwPetDuration = currentTime + pPet->GetPetPoint(POINT_UPBRINGING_MAX_DURATION);
-							LPITEM pUpBringingItem = AutoGiveItem(pPet->GetSummonItemVnum());
-
-							// Copy stats from old pet to a new table
-							TGrowthPet petTable;
-							pPet->CreateGrowthPetProto(&petTable);
-							petTable.dwID = pUpBringingItem->GetID();
-							petTable.lBirthday = currentTime - dwPetAge;
-							petTable.lEndTime = dwPetDuration;
-							petTable.bState = STATE_UPBRINGING;
-
-							// Create a new pet and copy stats from table to it
-							LPGROWTH_PET pNewPet = CGrowthPetManager::Instance().CreateGrowthPet(this, pUpBringingItem->GetID());
-							pNewPet->SetGrowthPetProto(&petTable);
-
-							// Sync upbringing sockets with the new pet
-							pUpBringingItem->SetSocket(0, dwPetDuration);
-							pUpBringingItem->SetSocket(1, petTable.lMaxTime);
-							pUpBringingItem->SetSocket(2, pUpBringingItem->GetID());
-							pUpBringingItem->SetSocket(3, item->GetSocket(3));
-
-							pPet->SetSummonItem(pUpBringingItem);
-							pPet->Save();
-
-							SetGrowthPet(pNewPet);
-
-							CGrowthPetManager::Instance().DeleteGrowthPet(item->GetSocket(2), true);
-							ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (BAG-UPBRINGING TRANSFER)");
-						}
-					} break;
-				}
-
-			} break;
-#endif
-		case ITEM_HAIR:
-			return ItemProcess_Hair(item, wDestCell);
-
-		case ITEM_POLYMORPH:
-			return ItemProcess_Polymorph(item);
-
-		case ITEM_QUEST:
-		{
-			if (GetArena() != NULL || IsObserverMode() == true)
-			{
-				if (item->GetVnum() == ITEM_VNUM_HORSE_PICTURE || item->GetVnum() == ITEM_VNUM_ARMED_HORSE_BOOK || item->GetVnum() == ITEM_VNUM_MILITARY_HORSE_BOOK)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·Ã Áß¿¡´Â ÀÌ¿ëÇÒ ¼ö ¾ø´Â ¹°Ç°ÀÔ´Ï´Ù."));
-					return false;
-				}
-			}
-
-			if (!IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE))
-			{
-				if (item->GetSIGVnum() == 0)
-				{
-					quest::CQuestManager::instance().UseItem(GetPlayerID(), item, false);
-				}
-				else
-				{
-					quest::CQuestManager::instance().SIGUse(GetPlayerID(), item->GetSIGVnum(), item, false);
-				}
-			}
-		}
-		break;
-
-		case ITEM_CAMPFIRE:
-		{
-			float fx, fy;
-			GetDeltaByDegree(GetRotation(), 100.0f, &fx, &fy);
-
-			LPSECTREE tree = SECTREE_MANAGER::instance().Get(GetMapIndex(), (long)(GetX() + fx), (long)(GetY() + fy));
-
-			if (!tree)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¸ð´ÚºÒÀ» ÇÇ¿ï ¼ö ¾ø´Â ÁöÁ¡ÀÔ´Ï´Ù."));
-				return false;
-			}
-
-			if (tree->IsAttr((long)(GetX() + fx), (long)(GetY() + fy), ATTR_WATER))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¹° ¼Ó¿¡ ¸ð´ÚºÒÀ» ÇÇ¿ï ¼ö ¾ø½À´Ï´Ù."));
-				return false;
-			}
-
-			LPCHARACTER campfire = CHARACTER_MANAGER::instance().SpawnMob(fishing::CAMPFIRE_MOB, GetMapIndex(), (long)(GetX() + fx), (long)(GetY() + fy), 0, false, number(0, 359));
-
-			char_event_info* info = AllocEventInfo<char_event_info>();
-
-			info->ch = campfire;
-
-			campfire->m_pkMiningEvent = event_create(kill_campfire_event, info, PASSES_PER_SEC(40));
-
-			item->SetCount(item->GetCount() - 1);
-		}
-		break;
-
-		case ITEM_UNIQUE:
-		{
-			switch (item->GetSubType())
-			{
-				case USE_ABILITY_UP:
-				{
-					if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-						return false;
-					}
-
-					switch (item->GetValue(0))
-					{
-						case APPLY_MOV_SPEED:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MOV_SPEED,
-								item->GetValue(2), AFF_MOV_SPEED_POTION, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_ATT_SPEED:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATT_SPEED,
-								item->GetValue(2), AFF_ATT_SPEED_POTION, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_STR:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ST,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_DEX:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_DX,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_CON:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_HT,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_INT:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_IQ,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_CAST_SPEED:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_CASTING_SPEED,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_RESIST_MAGIC:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_MAGIC,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_ATT_GRADE_BONUS:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATT_GRADE_BONUS,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-
-						case APPLY_DEF_GRADE_BONUS:
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_DEF_GRADE_BONUS,
-								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-							break;
-					}
-
-					if (GetDungeon())
-						GetDungeon()->UsePotion(this);
-
-					if (GetWarMap())
-						GetWarMap()->UsePotion(this, item);
-
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case UNIQUE_BUNDLE:
-				{
-					if (IsRiding())
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this bundle whilst riding."));
-						return false;
-					}
-
-					if (GetWear(ARMOR_BODY))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("°©¿ÊÀ» ¹þ¾î¾ß °³ÀÎ »óÁ¡À» ¿­ ¼ö ÀÖ½À´Ï´Ù."));
-						return false;
-					}
-
-					switch (item->GetVnum())
-					{
-						case 71049: // ºñ´Üº¸µû¸®
-						{
-							if (LC_IsYMIR() == true || LC_IsKorea() == true)
-							{
-								if (IS_BOTARYABLE_ZONE(GetMapIndex()) == true)
-								{
-									UseSilkBotary();
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("°³ÀÎ »óÁ¡À» ¿­ ¼ö ¾ø´Â Áö¿ªÀÔ´Ï´Ù"));
-								}
-							}
-							else
-							{
-								UseSilkBotary();
-							}
-						}
-						break;
-
-#if defined(__MYSHOP_DECO__)
-						case ITEM_KASHMIR_BUNDLE:
-							ChatPacket(CHAT_TYPE_COMMAND, "OpenMyShopDecoWnd");
-							break;
-#endif
-					}
-				}
-				break;
-
-				default:
-				{
-					if (!item->IsEquipped())
-						EquipItem(item);
-					else
-						UnequipItem(item);
-				}
-				break;
-			}
-		}
-		break;
-
-		case ITEM_COSTUME:
-		case ITEM_WEAPON:
-		case ITEM_ARMOR:
-		case ITEM_ROD:
-		case ITEM_RING: // ½Å±Ô ¹ÝÁö ¾ÆÀÌÅÛ
-		case ITEM_BELT: // ½Å±Ô º§Æ® ¾ÆÀÌÅÛ
-		case ITEM_PICK: // MINING
-		{
-			if (!item->IsEquipped())
-				EquipItem(item);
-			else
-				UnequipItem(item);
-		}
-		break;
-
-		// Âø¿ëÇÏÁö ¾ÊÀº ¿ëÈ¥¼®Àº »ç¿ëÇÒ ¼ö ¾ø´Ù.
-		// Á¤»óÀûÀÎ Å¬¶ó¶ó¸é, ¿ëÈ¥¼®¿¡ °üÇÏ¿© item use ÆÐÅ¶À» º¸³¾ ¼ö ¾ø´Ù.
-		// ¿ëÈ¥¼® Âø¿ëÀº item move ÆÐÅ¶À¸·Î ÇÑ´Ù.
-		// Âø¿ëÇÑ ¿ëÈ¥¼®Àº ÃßÃâÇÑ´Ù.
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case ITEM_DS:
-		{
-			if (!item->IsEquipped())
-				return false;
-
-			return DSManager::instance().PullOut(this, NPOS, item);
-		}
-
-		case ITEM_SPECIAL_DS:
-		{
-			if (!item->IsEquipped())
-				EquipItem(item);
-			else
-				UnequipItem(item);
-		}
-		break;
-#endif
-
-		case ITEM_FISH:
-		{
-			if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·Ã Áß¿¡´Â ÀÌ¿ëÇÒ ¼ö ¾ø´Â ¹°Ç°ÀÔ´Ï´Ù."));
-				return false;
-			}
-
-			if (item->GetSubType() == FISH_ALIVE)
-				fishing::UseFish(this, item);
-		}
-		break;
-
-		case ITEM_TREASURE_BOX:
-		{
-			return false;
-			//ChatPacket(CHAT_TYPE_TALKING, LC_STRING("¿­¼è·Î Àá°Ü ÀÖ¾î¼­ ¿­¸®Áö ¾Ê´Â°Í °°´Ù. ¿­¼è¸¦ ±¸ÇØº¸ÀÚ."));
-		}
-		break;
-
-		case ITEM_TREASURE_KEY:
-		{
-			LPITEM item2;
-
-			if (!GetItem(DestCell) || !(item2 = GetItem(DestCell)))
-				return false;
-
-			if (item2->IsExchanging())
-				return false;
-
-			if (item2->GetType() != ITEM_TREASURE_BOX)
-			{
-				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("¿­¼è·Î ¿©´Â ¹°°ÇÀÌ ¾Æ´Ñ°Í °°´Ù."));
-				return false;
-			}
-
-			if (item->GetValue(0) == item2->GetValue(0))
-			{
-				//ChatPacket(CHAT_TYPE_TALKING, LC_STRING("¿­¼è´Â ¸ÂÀ¸³ª ¾ÆÀÌÅÛ ÁÖ´Â ºÎºÐ ±¸ÇöÀÌ ¾ÈµÇ¾ú½À´Ï´Ù."));
-
-				if (GiveItemFromSpecialItemGroup(item2->GetVnum()))
-				{
-					item->SetCount(item->GetCount() - 1);
-					item2->SetCount(item2->GetCount() - 1);
-				}
-				else
-				{
-					ChatPacket(CHAT_TYPE_TALKING, LC_STRING("¿­¼è°¡ ¸ÂÁö ¾Ê´Â °Í °°´Ù."));
-					return false;
-				}
-			}
-			else
-			{
-				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("¿­¼è°¡ ¸ÂÁö ¾Ê´Â °Í °°´Ù."));
-				return false;
-			}
-		}
-		break;
-
-		case ITEM_GIFTBOX:
-		{
-			DWORD dwBoxVnum = item->GetVnum();
-
-			if (dwBoxVnum == 50033 && LC_IsYMIR()) // ¾Ë¼ö¾ø´Â »óÀÚ
-			{
-				if (GetLevel() < 15)
-				{
-					ChatPacket(CHAT_TYPE_INFO, "15·¹º§ ÀÌÇÏ¿¡¼­´Â »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù.");
-					return false;
-				}
-			}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			if ((dwBoxVnum > 51500 && dwBoxVnum < 52000) || (dwBoxVnum >= 50255 && dwBoxVnum <= 50260)) // ¿ëÈ¥¿ø¼®µé
-			{
-				if (!(this->DragonSoul_IsQualified()))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("¸ÕÀú ¿ëÈ¥¼® Äù½ºÆ®¸¦ ¿Ï·áÇÏ¼Å¾ß ÇÕ´Ï´Ù."));
-					return false;
-				}
-			}
-#endif
-
-			if (!GiveItemFromSpecialItemGroup(dwBoxVnum))
-			{
-				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("¾Æ¹«°Íµµ ¾òÀ» ¼ö ¾ø¾ú½À´Ï´Ù."));
-				return false;
-			}
-
-			item->SetCount(item->GetCount() - 1);
-		}
-		break;
-
-		case ITEM_SKILLFORGET:
-		{
-			if (!item->GetSocket(0))
-			{
-				ITEM_MANAGER::instance().RemoveItem(item);
-				return false;
-			}
-
-			DWORD dwVnum = item->GetSocket(0);
-
-			if (SkillLevelDown(dwVnum))
-			{
-				ITEM_MANAGER::instance().RemoveItem(item);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("½ºÅ³ ·¹º§À» ³»¸®´Âµ¥ ¼º°øÇÏ¿´½À´Ï´Ù."));
-			}
-			else
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("½ºÅ³ ·¹º§À» ³»¸± ¼ö ¾ø½À´Ï´Ù."));
-		}
-		break;
-
-		case ITEM_SKILLBOOK:
-		{
-			if (IsPolymorphed())
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("º¯½ÅÁß¿¡´Â Ã¥À» ÀÐÀ»¼ö ¾ø½À´Ï´Ù."));
-				return false;
-			}
-
-			DWORD dwVnum = 0;
-
-			if (item->GetVnum() == ITEM_SKILLBOOK_VNUM)
-			{
-				dwVnum = item->GetSocket(0);
-			}
-			else
-			{
-				// »õ·Î¿î ¼ö·Ã¼­´Â value 0 ¿¡ ½ºÅ³ ¹øÈ£°¡ ÀÖÀ¸¹Ç·Î ±×°ÍÀ» »ç¿ë.
-				dwVnum = item->GetValue(0);
-			}
-
-			if (0 == dwVnum)
-			{
-				ITEM_MANAGER::instance().RemoveItem(item);
-				return false;
-			}
-
-			if (true == LearnSkillByBook(dwVnum))
-			{
-				item->SetCount(item->GetCount() - 1);
-
-				int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-
-				if (distribution_test_server)
-					iReadDelay /= 3;
-
-				// ÇÑ±¹ º»¼·ÀÇ °æ¿ì¿¡´Â ½Ã°£À» 24½Ã°£ °íÁ¤
-				if (LC_IsKorea())
-					iReadDelay = 86400;
-
-				SetSkillNextReadTime(dwVnum, get_global_time() + iReadDelay);
-			}
-		}
-		break;
-
-		case ITEM_USE:
-		{
-			if (item->GetVnum() > 50800 && item->GetVnum() <= 50820)
-			{
-				if (test_server)
-					sys_log(0, "ADD addtional effect : vnum(%d) subtype(%d)", item->GetOriginalVnum(), item->GetSubType());
-
-				int affect_type = AFFECT_EXP_BONUS_EURO_FREE;
-				int apply_type = aApplyInfo[item->GetValue(0)].wPointType;
-				int apply_value = item->GetValue(2);
-				int apply_duration = item->GetValue(1);
-
-				switch (item->GetSubType())
-				{
-					case USE_ABILITY_UP:
-					{
-						if (FindAffect(affect_type, apply_type))
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-							return false;
-						}
-
-						if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-							return false;
-						}
-
-						switch (item->GetValue(0))
-						{
-							case APPLY_MOV_SPEED:
-							{
-								AddAffect(affect_type, apply_type, apply_value, AFF_MOV_SPEED_POTION, apply_duration, 0, true, true);
-								break;
-							}
-
-							case APPLY_ATT_SPEED:
-							{
-								AddAffect(affect_type, apply_type, apply_value, AFF_ATT_SPEED_POTION, apply_duration, 0, true, true);
-								break;
-							}
-
-							case APPLY_STR:
-							case APPLY_DEX:
-							case APPLY_CON:
-							case APPLY_INT:
-							case APPLY_CAST_SPEED:
-							case APPLY_CRITICAL_PCT:
-							case APPLY_PENETRATE_PCT:
-							case APPLY_RESIST_MAGIC:
-							case APPLY_ATT_GRADE_BONUS:
-							case APPLY_DEF_GRADE_BONUS:
-#if defined(__CONQUEROR_LEVEL__)
-							case APPLY_SUNGMA_STR:
-							case APPLY_SUNGMA_HP:
-							case APPLY_SUNGMA_MOVE:
-							case APPLY_SUNGMA_IMMUNE:
-#endif
-							{
-								AddAffect(affect_type, apply_type, apply_value, 0, apply_duration, 0, true, true);
-								break;
-							}
-
-						}
-
-						if (GetDungeon())
-							GetDungeon()->UsePotion(this);
-
-						if (GetWarMap())
-							GetWarMap()->UsePotion(this, item);
-
-						item->SetCount(item->GetCount() - 1);
-					}
-					break;
-
-					case USE_AFFECT:
-					{
-						if (FindAffect(AFFECT_EXP_BONUS_EURO_FREE, aApplyInfo[item->GetValue(1)].wPointType))
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-						}
-						else
-						{
-							AddAffect(AFFECT_EXP_BONUS_EURO_FREE, aApplyInfo[item->GetValue(1)].wPointType, item->GetValue(2), 0, item->GetValue(3), 0, false, true);
-							item->SetCount(item->GetCount() - 1);
-						}
-					}
-					break;
-
-					case USE_POTION_NODELAY:
-					{
-						if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-						{
-							if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·ÃÀå¿¡¼­ »ç¿ëÇÏ½Ç ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							switch (item->GetVnum())
-							{
-								case 70020: // Peach Flower Wine
-								case 71018: // Blessing of Life
-								case 71019: // Blessing of Magic
-								case 71020: // Blessing of the Dragon
-								{
-									if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
-									{
-										if (m_nPotionLimit <= 0)
-										{
-											ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ç¿ë Á¦ÇÑ·®À» ÃÊ°úÇÏ¿´½À´Ï´Ù."));
-											return false;
-										}
-									}
-								}
-								break;
-
-								default:
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·ÃÀå¿¡¼­ »ç¿ëÇÏ½Ç ¼ö ¾ø½À´Ï´Ù."));
-									return false;
-								}
-							}
-						}
-
-						bool bUsed = false;
-
-						if (item->GetValue(0) != 0) // HP Àý´ë°ª È¸º¹
-						{
-							if (GetHP() < GetMaxHP())
-							{
-								PointChange(POINT_HP, item->GetValue(0) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
-								EffectPacket(SE_HPUP_RED);
-								bUsed = true;
-							}
-						}
-
-						if (item->GetValue(1) != 0) // SP Àý´ë°ª È¸º¹
-						{
-							if (GetSP() < GetMaxSP())
-							{
-								PointChange(POINT_SP, item->GetValue(1) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
-								EffectPacket(SE_SPUP_BLUE);
-								bUsed = true;
-							}
-						}
-
-						if (item->GetValue(3) != 0) // HP % È¸º¹
-						{
-							if (GetHP() < GetMaxHP())
-							{
-								PointChange(POINT_HP, item->GetValue(3) * GetMaxHP() / 100);
-								EffectPacket(SE_HPUP_RED);
-								bUsed = true;
-							}
-						}
-
-						if (item->GetValue(4) != 0) // SP % È¸º¹
-						{
-							if (GetSP() < GetMaxSP())
-							{
-								PointChange(POINT_SP, item->GetValue(4) * GetMaxSP() / 100);
-								EffectPacket(SE_SPUP_BLUE);
-								bUsed = true;
-							}
-						}
-
-						if (bUsed)
-						{
-							if (item->GetVnum() == 50085 || item->GetVnum() == 50086)
-							{
-								if (test_server)
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("¿ùº´ ¶Ç´Â Á¾ÀÚ ¸¦ »ç¿ëÇÏ¿´½À´Ï´Ù"));
-
-								SetUseSeedOrMoonBottleTime();
-							}
-
-							if (GetDungeon())
-								GetDungeon()->UsePotion(this);
-
-							if (GetWarMap())
-								GetWarMap()->UsePotion(this, item);
-
-							m_nPotionLimit--;
-
-							// RESTRICT_USE_SEED_OR_MOONBOTTLE
-							item->SetCount(item->GetCount() - 1);
-							// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
-						}
-					}
-					break;
-				}
-
-				return true;
-			}
-
-			if (item->GetVnum() >= 27863 && item->GetVnum() <= 27883)
-			{
-				if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·Ã Áß¿¡´Â ÀÌ¿ëÇÒ ¼ö ¾ø´Â ¹°Ç°ÀÔ´Ï´Ù."));
-					return false;
-				}
-			}
-
-			if (test_server)
-			{
-				sys_log(0, "USE_ITEM %s Type %d SubType %d vnum %d", item->GetName(), item->GetType(), item->GetSubType(), item->GetOriginalVnum());
-			}
-
-			switch (item->GetSubType())
-			{
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				case USE_ELEMENT_UPGRADE:
-				case USE_ELEMENT_DOWNGRADE:
-				case USE_ELEMENT_CHANGE:
-					RefineElementInformation(item, DestCell);
-					break;
-#endif
-
-#if defined(__EXPRESSING_EMOTIONS__)
-				case USE_EMOTION_PACK:
-				{
-					AddEmote();
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-#endif
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-				case USE_TIME_CHARGE_PER:
-				{
-					LPITEM pDestItem = GetItem(DestCell);
-					if (NULL == pDestItem)
-						return false;
-
-					// ¿ì¼± ¿ëÈ¥¼®¿¡ °üÇØ¼­¸¸ ÇÏµµ·Ï ÇÑ´Ù.
-					if (pDestItem->IsDragonSoul())
-					{
-						int ret;
-						char buf[128];
-						if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
-						{
-							ret = pDestItem->GiveMoreTime_Per((float)item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
-						}
-						else
-						{
-							ret = pDestItem->GiveMoreTime_Per((float)item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-						}
-
-						if (ret > 0)
-						{
-#if defined(__DS_SET__)
-							DragonSoul_SetBonus();
-#endif
-
-							if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
-							{
-								sprintf(buf, "Inc %ds by item{VN:%d SOC%d:%d}", ret, item->GetVnum(), ITEM_SOCKET_CHARGING_AMOUNT_IDX, item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
-							}
-							else
-							{
-								sprintf(buf, "Inc %ds by item{VN:%d VAL%d:%d}", ret, item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-							}
-
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("%dÃÊ ¸¸Å­ ÃæÀüµÇ¾ú½À´Ï´Ù.", ret));
-							item->SetCount(item->GetCount() - 1);
-							LogManager::instance().ItemLog(this, item, "DS_CHARGING_SUCCESS", buf);
-
-							return true;
-						}
-						else
-						{
-							if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
-							{
-								sprintf(buf, "No change by item{VN:%d SOC%d:%d}", item->GetVnum(), ITEM_SOCKET_CHARGING_AMOUNT_IDX, item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
-							}
-							else
-							{
-								sprintf(buf, "No change by item{VN:%d VAL%d:%d}", item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-							}
-
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÃæÀüÇÒ ¼ö ¾ø½À´Ï´Ù."));
-							LogManager::instance().ItemLog(this, item, "DS_CHARGING_FAILED", buf);
-							return false;
-						}
-					}
-					else
-						return false;
-				}
-				break;
-
-				case USE_TIME_CHARGE_FIX:
-				{
-					LPITEM pDestItem = GetItem(DestCell);
-					if (NULL == pDestItem)
-						return false;
-
-					// ¿ì¼± ¿ëÈ¥¼®¿¡ °üÇØ¼­¸¸ ÇÏµµ·Ï ÇÑ´Ù.
-					if (pDestItem->IsDragonSoul())
-					{
-						int ret = pDestItem->GiveMoreTime_Fix(item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-						char buf[128];
-						if (ret)
-						{
-#if defined(__DS_SET__)
-							DragonSoul_SetBonus();
-#endif
-
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("%dÃÊ ¸¸Å­ ÃæÀüµÇ¾ú½À´Ï´Ù.", ret));
-
-							sprintf(buf, "Increase %ds by item{VN:%d VAL%d:%d}", ret, item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-							LogManager::instance().ItemLog(this, item, "DS_CHARGING_SUCCESS", buf);
-							item->SetCount(item->GetCount() - 1);
-
-							return true;
-						}
-						else
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÃæÀüÇÒ ¼ö ¾ø½À´Ï´Ù."));
-							sprintf(buf, "No change by item{VN:%d VAL%d:%d}", item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
-							LogManager::instance().ItemLog(this, item, "DS_CHARGING_FAILED", buf);
-							return false;
-						}
-					}
-					else
-						return false;
-				}
-				break;
-#endif
-
-				case USE_SPECIAL:
-				{
-					switch (item->GetVnum())
-					{
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-						case ITEM_GUILD_DRAGONLAIR_POTION:
-						{
-							if (GetGuildDragonLair() == NULL)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
-								return false;
-							}
-
-							if (FindAffect(AFFECT_RED_DRAGONLAIR_BUFF))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-								return false;
-							}
-							else
-							{
-								const long duration = item->GetValue(1);
-
-								AddAffect(AFFECT_RED_DRAGONLAIR_BUFF, POINT_SKILL_DEFEND_BONUS, 15, AFF_NONE, duration, 0, true, true);
-								AddAffect(AFFECT_RED_DRAGONLAIR_BUFF, POINT_NORMAL_HIT_DEFEND_BONUS, 15, AFF_NONE, duration, 0, true, true);
-
-								item->SetCount(item->GetCount() - 1);
-							}
-						}
-						break;
-#endif
-
-#if defined(__ELEMENTAL_DUNGEON__)
-						case ITEM_PRIMAL_FORCE_MEDAL:
-						{
-							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
-								return false;
-							}
-
-							CAffect* pAffect = FindAffect(AFFECT_PROTECTION_OF_ELEMENTAL);
-							if (pAffect)
-							{
-								// NOTE : Check if adding another 600 seconds (10 minutes) would exceed 3600 seconds (60 minutes).
-								const long lDuration = pAffect->lDuration;
-								if (lDuration + 600 > 3600)
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that any more."));
-									return false;
-								}
-
-								AddAffect(AFFECT_PROTECTION_OF_ELEMENTAL, APPLY_NONE, 0, AFF_NONE, lDuration + 600, 0, true);
-							}
-							else
-								AddAffect(AFFECT_PROTECTION_OF_ELEMENTAL, APPLY_NONE, 0, AFF_NONE, 600, 0, true);
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_ELEMENTAL_DEFENSE_POTION:
-						{
-							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
-								return false;
-							}
-
-							const long duration = item->GetValue(1);
-							static const std::unordered_map<POINT_TYPE, POINT_VALUE> map_affect = {
-								{ APPLY_MELEE_MAGIC_ATTBONUS_PER, 5 },
-								{ APPLY_RESIST_FIRE, 10 },
-								{ APPLY_RESIST_ELEC, 10 },
-								{ APPLY_RESIST_ICE, 10 },
-								{ APPLY_RESIST_EARTH, 10 },
-								{ APPLY_RESIST_DARK, 10 },
-							};
-							for (const auto& it : map_affect)
-								AddAffect(AFFECT_POTION_OF_ELEMENTAL, it.first, it.second, AFF_NONE, duration, 0, true, true);
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_PRIMAL_FORCE_RING:
-						case ITEM_PRIMAL_FORCE_RING_MALL:
-						{
-							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
-								return false;
-							}
-
-							if (number(0, 100) < item->GetValue(0))
-							{
-								PIXEL_POSITION WarpPos;
-								if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(MAP_ELEMENTAL_04, GetEmpire(), WarpPos))
-									WarpSet(WarpPos.x, WarpPos.y);
-								else
-									sys_err("CHARACTER::UseItem : cannot find spawn position (name %s, %d x %d)", GetName(), GetX(), GetY());
-							}
-							else
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Teleportation to the Plateau of Primal Forces has failed."));
-							
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-#if defined(__MINI_GAME_RUMI__) && defined(__OKEY_EVENT_FLAG_RENEWAL__)
-						case ITEM_VNUM_RUMI_CARD_PIECE:
-						{
-							if (CMiniGameRumi::UpdateQuestFlag(this))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_VNUM_RUMI_CARD_PACK:
-						{
-							const WORD wCardCount = GetQuestFlag("minigame_rumi.card_count");
-							if (wCardCount < CMiniGameRumi::RUMI_CARD_COUNT_MAX)
-							{
-								SetQuestFlag("minigame_rumi.card_count", wCardCount + 1);
-								CMiniGameRumi::RequestQuestFlag(this, RUMI_GC_SUBHEADER_SET_CARD_FLAG);
-
-								item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								CMiniGameRumi::RequestQuestFlag(this, RUMI_GC_SUBHEADER_NO_MORE_GAIN);
-							}
-						}
-						break;
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__) && defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-						case ITEM_VNUM_YUT_PIECE:
-						{
-							if (CMiniGameYutnori::UpdateQuestFlag(this))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_VNUM_YUT_BOARD:
-						{
-							const WORD wYutBoardCount = GetQuestFlag("minigame_yutnori.board_count");
-							if (wYutBoardCount < CMiniGameYutnori::YUTNORI_BOARD_COUNT_MAX)
-							{
-								SetQuestFlag("minigame_yutnori.board_count", wYutBoardCount + 1);
-								CMiniGameYutnori::RequestQuestFlag(this, YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG);
-
-								item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								CMiniGameYutnori::RequestQuestFlag(this, YUTNORI_GC_SUBHEADER_NO_MORE_GAIN);
-							}
-						}
-						break;
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__) && defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
-						case ITEM_VNUM_CATCH_KING_PIECE:
-						{
-							if (CMiniGameCatchKing::UpdateQuestFlag(this))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_VNUM_CATCH_KING_PACK:
-						{
-							const WORD wPackCount = GetQuestFlag("minigame_catchking.pack_count");
-							if (wPackCount < CMiniGameCatchKing::CATCH_KING_PACK_COUNT_MAX)
-							{
-								SetQuestFlag("minigame_catchking.pack_count", wPackCount + 1);
-								CMiniGameCatchKing::RequestQuestFlag(this, CATCHKING_GC_SET_CARD_FLAG);
-
-								item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								CMiniGameCatchKing::RequestQuestFlag(this, CATCHKING_GC_NO_MORE_GAIN);
-							}
-						}
-						break;
-#endif
-
-#if defined(__EASTER_EVENT__)
-						case ITEM_MAGIC_EASTER_EGG:
-						{
-							int nMaxUse = 3;
-							int nNextUseTime = 1800;
-
-							int nUseTime = get_global_time() - item->GetSocket(1);
-							int nUseCount = item->GetSocket(0);
-
-							if (nUseTime >= nNextUseTime)
-							{
-								if (GiveItemFromSpecialItemGroup(ITEM_MAGIC_EASTER_EGG))
-								{
-									item->SetSocket(1, get_global_time());
-									if (nUseCount >= (nMaxUse - 1))
-										item->SetCount(item->GetCount() - 1);
-									else
-										item->SetSocket(0, nUseCount + 1);
-
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Total %d: You can still unpack %d.", nMaxUse, (nMaxUse - 1) - nUseCount));
-								}
-								else
-									ChatPacket(CHAT_TYPE_TALKING, LC_STRING("¾Æ¹«°Íµµ ¾òÀ» ¼ö ¾ø¾ú½À´Ï´Ù."));
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unpack the next gift in %d minutes.", 31 - nUseTime / 60));
-							}
-						}
-						break;
-#endif
-
-#if defined(__GEM_CONVERTER__)
-						case ITEM_VNUM_GEM_CONVERTER:
-						{
-							LPITEM pTargetItem;
-							if (!IsValidItemPosition(DestCell) || !(pTargetItem = GetItem(DestCell)))
-								return false;
-
-							if (pTargetItem->GetVnum() != ITEM_VNUM_GEM_STONE)
-								return false;
-
-							if (item->IsExchanging() || pTargetItem->IsExchanging())
-								return false;
-
-							if (item->isLocked() || pTargetItem->isLocked())
-								return false;
-
-							int iNeedGemStoneCount = item->GetCount() * item->GetValue(0);
-							int iConvertToGem = iNeedGemStoneCount / item->GetValue(0);
-							int iConvertCost = item->GetCount() * item->GetValue(1);
-
-							if (pTargetItem->GetCount() < iNeedGemStoneCount)
-								return false;
-
-							if (GetGold() < iConvertCost)
-								return false;
-
-							if (GetGem() + iConvertToGem >= GEM_MAX)
-								return false;
-
-							item->SetCount(item->GetCount() - 1);
-							pTargetItem->SetCount(pTargetItem->GetCount() - iNeedGemStoneCount);
-
-							PointChange(POINT_GOLD, -iConvertCost);
-							PointChange(POINT_GEM, iConvertToGem);
-						}
-						break;
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-						case ITEM_VNUM_SNOWFLAKE_STICK:
-						{
-							if (CSnowflakeStickEvent::UseStick(this))
-							{
-								EffectPacket(SE_USE_SNOWFLAKE_STICK);
-								item->SetCount(item->GetCount() - 1);
-							}
-						}
-						break;
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-						case ITEM_ACCE_REVERSAL:
-						case ITEM_ACCE_REVERSAL_MALL:
-						{
-							LPITEM lpTargetItem;
-							if (!IsValidItemPosition(DestCell) || !(lpTargetItem = GetItem(DestCell)))
-								return false;
-
-							if (lpTargetItem->IsExchanging())
-								return false;
-
-							if (lpTargetItem->isLocked())
-								return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (lpTargetItem->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
-								return false;
-							}
-#endif
-
-							if (IsAcceRefineWindowOpen())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item while the windows for absorption and combination are open."));
-								return false;
-							}
-
-							lpTargetItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_ITEM_VNUM, 0);
-							lpTargetItem->ClearAllAttribute();
-							lpTargetItem->UpdatePacket();
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-						case ITEM_CHANGE_LOOK_REVERSAL:
-						case ITEM_CHANGE_LOOK_MOUNT_REVERSAL:
-						{
-							LPITEM item2;
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item2->IsExchanging())
-								return false;
-
-							if (item2->isLocked())
-								return false;
-
-							if (item2->GetTransmutationVnum() == 0)
-								return false;
-
-							if (item->GetVnum() == ITEM_CHANGE_LOOK_MOUNT_REVERSAL && !item2->IsCostumeMount())
-								return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
-								return false;
-							}
-#endif
-
-							item2->SetTransmutationVnum(0);
-							item2->UpdatePacket();
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-						case ITEM_VNUM_AURA_CLEAR:
-						{
-							LPITEM lpTargetItem;
-							if (!IsValidItemPosition(DestCell) || !(lpTargetItem = GetItem(DestCell)))
-								return false;
-
-							if (lpTargetItem->IsExchanging())
-								return false;
-
-							if (lpTargetItem->isLocked())
-								return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (lpTargetItem->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
-								return false;
-							}
-#endif
-
-							if (IsAuraRefineWindowOpen())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item while the windows for absorption and combination are open."));
-								return false;
-							}
-
-							lpTargetItem->SetSocket(ITEM_SOCKET_AURA_DRAIN_ITEM_VNUM, 0);
-							lpTargetItem->ClearAllAttribute();
-							lpTargetItem->UpdatePacket();
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-#if defined(__SET_ITEM__)
-						case ITEM_SET_CLEAR_SCROLL:
-						{
-							LPITEM item2;
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item->IsExchanging() || item2->IsExchanging() || item2->IsEquipped())
-								return false;
-
-							if (item->isLocked() || item2->isLocked())
-								return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
-								return false;
-							}
-#endif
-
-							item2->SetItemSetValue(0);
-							item2->UpdatePacket();
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-						// RESEARCHER_ELIXIR
-						case ITEM_RESEARCHERS_ELIXIR:
-						case ITEM_RESEARCHERS_ELIXIR_GIFT:
-						case ITEM_RESEARCHERS_ELIXIR_MALL:
-						{
-							if (FindAffect(AFFECT_RESEARCHER_ELIXIR))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-							}
-							else
-							{
-								AddAffect(AFFECT_RESEARCHER_ELIXIR, APPLY_NONE, 1, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
-								item->SetCount(item->GetCount() - 1);
-							}
-						}
-						break;
-						// END_RESEARCHER_ELIXIR
-
-#if defined(__SOUL_BIND_SYSTEM__)
-						case ITEM_SCROLL_BINDING:
-						{
-							if (!g_bSoulBind)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot soulbind items on this server."));
-								return false;
-							}
-
-							LPITEM item2;
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item2->IsExchanging())
-								return false;
-
-							if (!item2->CanSealItem())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot bind this item to your soul."));
-								return false;
-							}
-
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("This item is already soulbound."));
-								return false;
-							}
-
-							item2->SealItem();
-
-							char buf[256 + 1];
-							snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
-								item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
-							LogManager::instance().ItemLog(this, item, "SEAL_SCROLL_USE_SUCCESS", buf);
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_SCROLL_UNBINDING:
-#if defined(__UN_SEAL_SCROLL_PLUS__)
-						case ITEM_SCROLL_UNBINDING_MALL:
-#endif
-						{
-							LPITEM item2;
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item2->isLocked() || item2->IsExchanging())
-								return false;
-
-							if (!item2->IsSealed())
-								return false;
-
-							if (item2->GetSealDate() > E_SEAL_DATE_DEFAULT_TIMESTAMP)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("The soulbind on this item is already in the process of being removed."));
-								return false;
-							}
-
-#if defined(__UN_SEAL_SCROLL_PLUS__)
-							if (item->GetVnum() == ITEM_SCROLL_UNBINDING_MALL)
-							{
-								item2->SealItem(E_SEAL_DATE_DEFAULT_TIMESTAMP);
-
-								char buf[256 + 1];
-								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
-									item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
-								LogManager::instance().ItemLog(this, item, "UN_SEAL_SCROLL_PLUS_USE_SUCCESS", buf);
-							}
-							else
-#endif
-							{
-								long lSealDate = time(0);
-
-								if (test_server)
-									lSealDate += 60;
-								else
-									lSealDate += (60 * 60 * SEAL_DATE_MAX);
-
-								item2->SealItem(lSealDate);
-								item2->StartSealDateExpireTimerEvent();
-
-								char buf[256 + 1];
-								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
-									item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
-								LogManager::instance().ItemLog(this, item, "UN_SEAL_SCROLL_USE_SUCCESS", buf);
-							}
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-						// Å©¸®½º¸¶½º ¶õÁÖ
-						case ITEM_NOG_POCKET:
-						{
-							/*
-							¶õÁÖ´É·ÂÄ¡ : item_proto value ÀÇ¹Ì
-								ÀÌµ¿¼Óµµ value 1
-								°ø°Ý·Â value 2
-								°æÇèÄ¡ value 3
-								Áö¼Ó½Ã°£ value 0 (´ÜÀ§ ÃÊ)
-							*/
-							if (FindAffect(AFFECT_NOG_ABILITY))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-								return false;
-							}
-							long time = item->GetValue(0);
-							long moveSpeedPer = item->GetValue(1);
-							long attPer = item->GetValue(2);
-							long expPer = item->GetValue(3);
-							AddAffect(AFFECT_NOG_ABILITY, POINT_MOV_SPEED, moveSpeedPer, AFF_MOV_SPEED_POTION, time, 0, true, true);
-							AddAffect(AFFECT_NOG_ABILITY, POINT_MALL_ATTBONUS, attPer, AFF_NONE, time, 0, true, true);
-							AddAffect(AFFECT_NOG_ABILITY, POINT_MALL_EXPBONUS, expPer, AFF_NONE, time, 0, true, true);
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						// ¶ó¸¶´Ü¿ë »çÅÁ
-						case ITEM_RAMADAN_CANDY:
-						{
-							/*
-							»çÅÁ´É·ÂÄ¡ : item_proto value ÀÇ¹Ì
-								ÀÌµ¿¼Óµµ value 1
-								°ø°Ý·Â value 2
-								°æÇèÄ¡ value 3
-								Áö¼Ó½Ã°£ value 0 (´ÜÀ§ ÃÊ)
-							*/
-							if (FindAffect(AFFECT_RAMADAN_ABILITY))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-								return false;
-							}
-
-							long time = item->GetValue(0);
-							long moveSpeedPer = item->GetValue(1);
-							long attPer = item->GetValue(2);
-							long expPer = item->GetValue(3);
-							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MOV_SPEED, moveSpeedPer, AFF_MOV_SPEED_POTION, time, 0, true, true);
-							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MALL_ATTBONUS, attPer, AFF_NONE, time, 0, true, true);
-							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MALL_EXPBONUS, expPer, AFF_NONE, time, 0, true, true);
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_MARRIAGE_RING:
-						{
-							marriage::TMarriage* pMarriage = marriage::CManager::instance().Get(GetPlayerID());
-							if (pMarriage)
-							{
-								if (pMarriage->ch1 != NULL)
-								{
-									if (CArenaManager::instance().IsArenaMap(pMarriage->ch1->GetMapIndex()))
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·Ã Áß¿¡´Â ÀÌ¿ëÇÒ ¼ö ¾ø´Â ¹°Ç°ÀÔ´Ï´Ù."));
-										break;
-									}
-								}
-
-								if (pMarriage->ch2 != NULL)
-								{
-									if (CArenaManager::instance().IsArenaMap(pMarriage->ch2->GetMapIndex()))
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·Ã Áß¿¡´Â ÀÌ¿ëÇÒ ¼ö ¾ø´Â ¹°Ç°ÀÔ´Ï´Ù."));
-										break;
-									}
-								}
-
-								int consumeSP = CalculateConsumeSP(this);
-
-								if (consumeSP < 0)
-									return false;
-
-								PointChange(POINT_SP, -consumeSP, false);
-
-								WarpToPID(pMarriage->GetOther(GetPlayerID()));
-							}
-							else
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("°áÈ¥ »óÅÂ°¡ ¾Æ´Ï¸é °áÈ¥¹ÝÁö¸¦ »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-						}
-						break;
-
-						case ITEM_WHITE_FLAG:
-							ForgetMyAttacker();
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case 30093:
-						case 30094:
-						case 30095:
-						case 30096:
-							// º¹ÁÖ¸Ó´Ï
-						{
-							const int MAX_BAG_INFO = 26;
-							static struct LuckyBagInfo
-							{
-								DWORD count;
-								int prob;
-								DWORD vnum;
-							} b1[MAX_BAG_INFO] =
-							{
-								{ 1000, 302, 1 },
-								{ 10, 150, 27002 },
-								{ 10, 75, 27003 },
-								{ 10, 100, 27005 },
-								{ 10, 50, 27006 },
-								{ 10, 80, 27001 },
-								{ 10, 50, 27002 },
-								{ 10, 80, 27004 },
-								{ 10, 50, 27005 },
-								{ 1, 10, ITEM_SKILLBOOK_VNUM },
-								{ 1, 6, 92 },
-								{ 1, 2, 132 },
-								{ 1, 6, 1052 },
-								{ 1, 2, 1092 },
-								{ 1, 6, 2082 },
-								{ 1, 2, 2122 },
-								{ 1, 6, 3082 },
-								{ 1, 2, 3122 },
-								{ 1, 6, 5052 },
-								{ 1, 2, 5082 },
-								{ 1, 6, 7082 },
-								{ 1, 2, 7122 },
-								{ 1, 1, 11282 },
-								{ 1, 1, 11482 },
-								{ 1, 1, 11682 },
-								{ 1, 1, 11882 },
-							};
-
-							struct LuckyBagInfo b2[MAX_BAG_INFO] =
-							{
-								{ 1000, 302, 1 },
-								{ 10, 150, 27002 },
-								{ 10, 75, 27002 },
-								{ 10, 100, 27005 },
-								{ 10, 50, 27005 },
-								{ 10, 80, 27001 },
-								{ 10, 50, 27002 },
-								{ 10, 80, 27004 },
-								{ 10, 50, 27005 },
-								{ 1, 10, ITEM_SKILLBOOK_VNUM },
-								{ 1, 6, 92 },
-								{ 1, 2, 132 },
-								{ 1, 6, 1052 },
-								{ 1, 2, 1092 },
-								{ 1, 6, 2082 },
-								{ 1, 2, 2122 },
-								{ 1, 6, 3082 },
-								{ 1, 2, 3122 },
-								{ 1, 6, 5052 },
-								{ 1, 2, 5082 },
-								{ 1, 6, 7082 },
-								{ 1, 2, 7122 },
-								{ 1, 1, 11282 },
-								{ 1, 1, 11482 },
-								{ 1, 1, 11682 },
-								{ 1, 1, 11882 },
-							};
-
-							LuckyBagInfo* bi = NULL;
-							if (LC_IsHongKong())
-								bi = b2;
-							else
-								bi = b1;
-
-							int pct = number(1, 1000);
-
-							int i;
-							for (i = 0; i < MAX_BAG_INFO; i++)
-							{
-								if (pct <= bi[i].prob)
-									break;
-								pct -= bi[i].prob;
-							}
-							if (i >= MAX_BAG_INFO)
-								return false;
-
-							if (bi[i].vnum == ITEM_SKILLBOOK_VNUM)
-							{
-								// ½ºÅ³¼ö·Ã¼­´Â Æ¯¼öÇÏ°Ô ÁØ´Ù.
-								GiveRandomSkillBook();
-							}
-							else if (bi[i].vnum == 1)
-							{
-								PointChange(POINT_GOLD, 1000, true);
-							}
-							else
-							{
-								AutoGiveItem(bi[i].vnum, bi[i].count);
-							}
-							ITEM_MANAGER::instance().RemoveItem(item);
-						}
-						break;
-
-						case 50004: // ÀÌº¥Æ®¿ë °¨Áö±â
-						{
-							if (item->GetSocket(0))
-							{
-								item->SetSocket(0, item->GetSocket(0) + 1);
-							}
-							else
-							{
-								// Ã³À½ »ç¿ë½Ã
-								int iMapIndex = GetMapIndex();
-
-								PIXEL_POSITION pos;
-
-								if (SECTREE_MANAGER::instance().GetRandomLocation(iMapIndex, pos, 700))
-								{
-									item->SetSocket(0, 1);
-									item->SetSocket(1, pos.x);
-									item->SetSocket(2, pos.y);
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ °÷¿¡¼± ÀÌº¥Æ®¿ë °¨Áö±â°¡ µ¿ÀÛÇÏÁö ¾Ê´Â°Í °°½À´Ï´Ù."));
-									return false;
-								}
-							}
-
-							int dist = 0;
-							float distance = (DISTANCE_SQRT(GetX() - item->GetSocket(1), GetY() - item->GetSocket(2)));
-
-							if (distance < 1000.0f)
-							{
-								// ¹ß°ß!
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌº¥Æ®¿ë °¨Áö±â°¡ ½Åºñ·Î¿î ºûÀ» ³»¸ç »ç¶óÁý´Ï´Ù."));
-
-								// »ç¿ëÈ½¼ö¿¡ µû¶ó ÁÖ´Â ¾ÆÀÌÅÛÀ» ´Ù¸£°Ô ÇÑ´Ù.
-								struct TEventStoneInfo
-								{
-									DWORD dwVnum;
-									int count;
-									int prob;
-								};
-								const int EVENT_STONE_MAX_INFO = 15;
-								TEventStoneInfo info_10[EVENT_STONE_MAX_INFO] =
-								{
-									{ 27001, 10, 8 },
-									{ 27004, 10, 6 },
-									{ 27002, 10, 12 },
-									{ 27005, 10, 12 },
-									{ 27100, 1, 9 },
-									{ 27103, 1, 9 },
-									{ 27101, 1, 10 },
-									{ 27104, 1, 10 },
-									{ 27999, 1, 12 },
-
-									{ 25040, 1, 4 },
-
-									{ 27410, 1, 0 },
-									{ 27600, 1, 0 },
-									{ 25100, 1, 0 },
-
-									{ 50001, 1, 0 },
-									{ 50003, 1, 1 },
-								};
-								TEventStoneInfo info_7[EVENT_STONE_MAX_INFO] =
-								{
-									{ 27001, 10, 1 },
-									{ 27004, 10, 1 },
-									{ 27004, 10, 9 },
-									{ 27005, 10, 9 },
-									{ 27100, 1, 5 },
-									{ 27103, 1, 5 },
-									{ 27101, 1, 10 },
-									{ 27104, 1, 10 },
-									{ 27999, 1, 14 },
-
-									{ 25040, 1, 5 },
-
-									{ 27410, 1, 5 },
-									{ 27600, 1, 5 },
-									{ 25100, 1, 5 },
-
-									{ 50001, 1, 0 },
-									{ 50003, 1, 5 },
-
-								};
-								TEventStoneInfo info_4[EVENT_STONE_MAX_INFO] =
-								{
-									{ 27001, 10, 0 },
-									{ 27004, 10, 0 },
-									{ 27002, 10, 0 },
-									{ 27005, 10, 0 },
-									{ 27100, 1, 0 },
-									{ 27103, 1, 0 },
-									{ 27101, 1, 0 },
-									{ 27104, 1, 0 },
-									{ 27999, 1, 25 },
-
-									{ 25040, 1, 0 },
-
-									{ 27410, 1, 0 },
-									{ 27600, 1, 0 },
-									{ 25100, 1, 15 },
-
-									{ 50001, 1, 10 },
-									{ 50003, 1, 50 },
-
-								};
-
-								{
-									TEventStoneInfo* info;
-									if (item->GetSocket(0) <= 4)
-										info = info_4;
-									else if (item->GetSocket(0) <= 7)
-										info = info_7;
-									else
-										info = info_10;
-
-									int prob = number(1, 100);
-
-									for (int i = 0; i < EVENT_STONE_MAX_INFO; ++i)
-									{
-										if (!info[i].prob)
-											continue;
-
-										if (prob <= info[i].prob)
-										{
-											if (info[i].dwVnum == 50001)
-											{
-												DWORD* pdw = M2_NEW DWORD[2];
-
-												pdw[0] = info[i].dwVnum;
-												pdw[1] = info[i].count;
-
-												// ÃßÃ·¼­´Â ¼ÒÄÏÀ» ¼³Á¤ÇÑ´Ù
-												DBManager::instance().ReturnQuery(QID_LOTTO, GetPlayerID(), pdw,
-													"INSERT INTO lotto_list VALUES(0, 'server%s', %u, NOW())",
-													get_table_postfix(), GetPlayerID());
-											}
-											else
-												AutoGiveItem(info[i].dwVnum, info[i].count);
-
-											break;
-										}
-										prob -= info[i].prob;
-									}
-								}
-
-								char chatbuf[CHAT_MAX_LEN + 1];
-								int len = snprintf(chatbuf, sizeof(chatbuf), "StoneDetect %u 0 0", (DWORD)GetVID());
-
-								if (len < 0 || len >= (int)sizeof(chatbuf))
-									len = sizeof(chatbuf) - 1;
-
-								++len; // \0 ¹®ÀÚ±îÁö º¸³»±â
-
-								TPacketGCChat pack_chat;
-								pack_chat.header = HEADER_GC_CHAT;
-								pack_chat.size = sizeof(TPacketGCChat) + len;
-								pack_chat.type = CHAT_TYPE_COMMAND;
-								pack_chat.id = 0;
-								pack_chat.bEmpire = GetDesc()->GetEmpire();
-								//pack_chat.id = vid;
-
-								TEMP_BUFFER buf;
-								buf.write(&pack_chat, sizeof(TPacketGCChat));
-								buf.write(chatbuf, len);
-
-								PacketAround(buf.read_peek(), buf.size());
-
-								ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (DETECT_EVENT_STONE) 1");
-								return true;
-							}
-							else if (distance < 20000)
-								dist = 1;
-							else if (distance < 70000)
-								dist = 2;
-							else
-								dist = 3;
-
-							// ¸¹ÀÌ »ç¿ëÇßÀ¸¸é »ç¶óÁø´Ù.
-							const int STONE_DETECT_MAX_TRY = 10;
-							if (item->GetSocket(0) >= STONE_DETECT_MAX_TRY)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌº¥Æ®¿ë °¨Áö±â°¡ ÈçÀûµµ ¾øÀÌ »ç¶óÁý´Ï´Ù."));
-								ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (DETECT_EVENT_STONE) 0");
-								AutoGiveItem(27002);
-								return true;
-							}
-
-							if (dist)
-							{
-								char chatbuf[CHAT_MAX_LEN + 1];
-								int len = snprintf(chatbuf, sizeof(chatbuf),
-									"StoneDetect %u %d %d",
-									(DWORD)GetVID(), dist, (int)GetDegreeFromPositionXY(GetX(), item->GetSocket(2), item->GetSocket(1), GetY()));
-
-								if (len < 0 || len >= (int)sizeof(chatbuf))
-									len = sizeof(chatbuf) - 1;
-
-								++len; // \0 ¹®ÀÚ±îÁö º¸³»±â
-
-								TPacketGCChat pack_chat;
-								pack_chat.header = HEADER_GC_CHAT;
-								pack_chat.size = sizeof(TPacketGCChat) + len;
-								pack_chat.type = CHAT_TYPE_COMMAND;
-								pack_chat.id = 0;
-								pack_chat.bEmpire = GetDesc()->GetEmpire();
-								//pack_chat.id = vid;
-
-								TEMP_BUFFER buf;
-								buf.write(&pack_chat, sizeof(TPacketGCChat));
-								buf.write(chatbuf, len);
-
-								PacketAround(buf.read_peek(), buf.size());
-							}
-						}
-						break;
-
-						case 27989: // ¿µ¼®°¨Áö±â
-						case 76006: // ¼±¹°¿ë ¿µ¼®°¨Áö±â
-						{
-							LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(GetMapIndex());
-
-							if (pMap != NULL)
-							{
-								item->SetSocket(0, item->GetSocket(0) + 1);
-
-								FFindStone f;
-
-								// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
-								pMap->for_each(f);
-
-								if (f.m_mapStone.size() > 0)
-								{
-									std::map<DWORD, LPCHARACTER>::iterator stone = f.m_mapStone.begin();
-
-									DWORD max = UINT_MAX;
-									LPCHARACTER pTarget = stone->second;
-
-									while (stone != f.m_mapStone.end())
-									{
-										DWORD dist = (DWORD)DISTANCE_SQRT(GetX() - stone->second->GetX(), GetY() - stone->second->GetY());
-
-										if (dist != 0 && max > dist)
-										{
-											max = dist;
-											pTarget = stone->second;
-										}
-										stone++;
-									}
-
-									if (pTarget != NULL)
-									{
-										int val = 3;
-
-										if (max < 10000) val = 2;
-										else if (max < 70000) val = 1;
-
-										ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u %d %d", (DWORD)GetVID(), val,
-											(int)GetDegreeFromPositionXY(GetX(), pTarget->GetY(), pTarget->GetX(), GetY()));
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("°¨Áö±â¸¦ ÀÛ¿ëÇÏ¿´À¸³ª °¨ÁöµÇ´Â ¿µ¼®ÀÌ ¾ø½À´Ï´Ù."));
-									}
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("°¨Áö±â¸¦ ÀÛ¿ëÇÏ¿´À¸³ª °¨ÁöµÇ´Â ¿µ¼®ÀÌ ¾ø½À´Ï´Ù."));
-								}
-
-								if (item->GetSocket(0) >= 6)
-								{
-									ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u 0 0", (DWORD)GetVID());
-									ITEM_MANAGER::instance().RemoveItem(item);
-								}
-							}
-							break;
-						}
-						break;
-
-#if defined(__MT_THUNDER_DUNGEON__)
-						case 79602:
-						{
-							if (GetMapIndex() != CMTThunderDungeon::MAP_INDEX)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("This action is not possible on this map."));
-								return false;
-							}
-
-							LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(GetMapIndex());
-
-							if (pMap != NULL)
-							{
-								item->SetSocket(0, item->GetSocket(0) + 1);
-
-								FFindMobVnum f(6405);
-
-								// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
-								pMap->for_each(f);
-
-								if (f.m_mapVID.size() > 0)
-								{
-									std::map<DWORD, LPCHARACTER>::iterator it = f.m_mapVID.begin();
-
-									DWORD max = UINT_MAX;
-									LPCHARACTER pTarget = it->second;
-
-									while (it != f.m_mapVID.end())
-									{
-										DWORD dist = (DWORD)DISTANCE_SQRT(GetX() - it->second->GetX(), GetY() - it->second->GetY());
-
-										if (dist != 0 && max > dist)
-										{
-											max = dist;
-											pTarget = it->second;
-										}
-										it++;
-									}
-
-									if (pTarget != NULL)
-									{
-										int val = 3;
-
-										if (max < 10000) val = 2;
-										else if (max < 70000) val = 1;
-
-										ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u %d %d", (DWORD)GetVID(), val,
-											(int)GetDegreeFromPositionXY(GetX(), pTarget->GetY(), pTarget->GetX(), GetY()));
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Compass was used, but the Guard wasnt found."));
-									}
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Compass was used, but the Guard wasnt found."));
-								}
-
-								if (item->GetSocket(0) >= 6)
-								{
-									ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u 0 0", (DWORD)GetVID());
-									ITEM_MANAGER::instance().RemoveItem(item);
-								}
-							}
-						}
-						break;
-#endif
-
-						case 27996: // µ¶º´
-							item->SetCount(item->GetCount() - 1);
-							/*
-							if (GetSkillLevel(SKILL_CREATE_POISON))
-								AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE, 3, AFF_DRINK_POISON, 15 * 60, 0, true);
-							else
-							{
-								// µ¶´Ù·ç±â°¡ ¾øÀ¸¸é 50% Áï»ç 50% °ø°Ý·Â +2
-								if (number(0, 1))
-								{
-									if (GetHP() > 100)
-										PointChange(POINT_HP, -(GetHP() - 1));
-									else
-										Dead();
-								}
-								else
-									AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE, 2, AFF_DRINK_POISON, 15 * 60, 0, true);
-							}
-							*/
-							break;
-
-						case fishing::SHELLFISH_VNUM: // Á¶°³
-							// 50 µ¹Á¶°¢ 47990
-							// 30 ²Î
-							// 10 ¹éÁøÁÖ 47992
-							// 7 Ã»ÁøÁÖ 47993
-							// 3 ÇÇÁøÁÖ 47994
-						{
-							item->SetCount(item->GetCount() - 1);
-
-							int r = number(1, 100);
-
-							if (r <= 50)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Á¶°³¿¡¼­ µ¹Á¶°¢ÀÌ ³ª¿Ô½À´Ï´Ù."));
-								AutoGiveItem(fishing::STONEPIECE_VNUM);
-							}
-							else
-							{
-								const int prob_table_euckr[] =
-								{
-									80, 90, 97
-								};
-
-								const int prob_table_gb2312[] =
-								{
-									95, 97, 99
-								};
-
-								const int* prob_table = !g_iUseLocale ? prob_table_euckr : prob_table_gb2312;
-
-								if (r <= prob_table[0])
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Á¶°³°¡ ÈçÀûµµ ¾øÀÌ »ç¶óÁý´Ï´Ù."));
-								}
-								else if (r <= prob_table[1])
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Á¶°³¿¡¼­ ¹éÁøÁÖ°¡ ³ª¿Ô½À´Ï´Ù."));
-									AutoGiveItem(fishing::WHITE_PEARL_VNUM);
-								}
-								else if (r <= prob_table[2])
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Á¶°³¿¡¼­ Ã»ÁøÁÖ°¡ ³ª¿Ô½À´Ï´Ù."));
-									AutoGiveItem(fishing::BLUE_PEARL_VNUM);
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Á¶°³¿¡¼­ ÇÇÁøÁÖ°¡ ³ª¿Ô½À´Ï´Ù."));
-									AutoGiveItem(fishing::RED_PEARL_VNUM);
-								}
-							}
-						}
-						break;
-
-						case 71013: // ÃàÁ¦¿ëÆøÁ×
-							CreateFly(number(FLY_FIREWORK1, FLY_FIREWORK6), this);
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case 50100: // ÆøÁ×
-						case 50101:
-						case 50102:
-						case 50103:
-						case 50104:
-						case 50105:
-						case 50106:
-							CreateFly(item->GetVnum() - 50100 + FLY_FIREWORK1, this);
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case 50200: // º¸µû¸®
-						{
-							if (LC_IsYMIR() == true || LC_IsKorea() == true)
-							{
-								if (IS_BOTARYABLE_ZONE(GetMapIndex()) == true)
-								{
-									__OpenPrivateShop();
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("°³ÀÎ »óÁ¡À» ¿­ ¼ö ¾ø´Â Áö¿ªÀÔ´Ï´Ù"));
-								}
-							}
-							else
-							{
-								__OpenPrivateShop();
-							}
-						}
-						break;
-
-						case fishing::FISH_MIND_PILL_VNUM:
-							AddAffect(AFFECT_FISH_MIND_PILL, POINT_NONE, 0, AFF_FISH_MIND, 20 * 60, 0, true);
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case 50301: // Åë¼Ö·Â ¼ö·Ã¼­
-						case 50302:
-						case 50303:
-						{
-							if (IsPolymorphed() == true)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("µÐ°© Áß¿¡´Â ´É·ÂÀ» ¿Ã¸± ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							int lv = GetSkillLevel(SKILL_LEADERSHIP);
-
-							if (lv < item->GetValue(0))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ Ã¥Àº ³Ê¹« ¾î·Á¿ö ÀÌÇØÇÏ±â°¡ Èûµì´Ï´Ù."));
-								return false;
-							}
-
-							if (lv >= item->GetValue(1))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ Ã¥Àº ¾Æ¹«¸® ºÁµµ µµ¿òÀÌ µÉ °Í °°Áö ¾Ê½À´Ï´Ù."));
-								return false;
-							}
-
-							if (LearnSkillByBook(SKILL_LEADERSHIP))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(SKILL_LEADERSHIP, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-
-						case 50304: // ¿¬°è±â ¼ö·Ã¼­
-						case 50305:
-						case 50306:
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("º¯½ÅÁß¿¡´Â Ã¥À» ÀÐÀ»¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (GetSkillLevel(SKILL_COMBO) == 0 && GetLevel() < 30)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("·¹º§ 30ÀÌ µÇ±â Àü¿¡´Â ½ÀµæÇÒ ¼ö ÀÖÀ» °Í °°Áö ¾Ê½À´Ï´Ù."));
-								return false;
-							}
-
-							if (GetSkillLevel(SKILL_COMBO) == 1 && GetLevel() < 50)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("·¹º§ 50ÀÌ µÇ±â Àü¿¡´Â ½ÀµæÇÒ ¼ö ÀÖÀ» °Í °°Áö ¾Ê½À´Ï´Ù."));
-								return false;
-							}
-
-							if (GetSkillLevel(SKILL_COMBO) >= 2)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¿¬°è±â´Â ´õÀÌ»ó ¼ö·ÃÇÒ ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							int iPct = item->GetValue(0);
-
-							if (LearnSkillByBook(SKILL_COMBO, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(SKILL_COMBO, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-
-						case 50311: // ¾ð¾î ¼ö·Ã¼­
-						case 50312:
-						case 50313:
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("º¯½ÅÁß¿¡´Â Ã¥À» ÀÐÀ»¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							DWORD dwSkillVnum = item->GetValue(0);
-							int iPct = MINMAX(0, item->GetValue(1), 100);
-							if (GetSkillLevel(dwSkillVnum) >= 20 || dwSkillVnum - SKILL_LANGUAGE1 + 1 == GetEmpire())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì ¿Ïº®ÇÏ°Ô ¾Ë¾ÆµéÀ» ¼ö ÀÖ´Â ¾ð¾îÀÌ´Ù."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-
-						case 50061: // ÀÏº» ¸» ¼ÒÈ¯ ½ºÅ³ ¼ö·Ã¼­
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("º¯½ÅÁß¿¡´Â Ã¥À» ÀÐÀ»¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							DWORD dwSkillVnum = item->GetValue(0);
-							int iPct = MINMAX(0, item->GetValue(1), 100);
-
-							if (GetSkillLevel(dwSkillVnum) >= 10)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´õ ÀÌ»ó ¼ö·ÃÇÒ ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-
-						// LEARNABLE_SKILL_BOOKS_BY_LEVEL
-						case 50314: case 50315: case 50316: // º¯½Å ¼ö·Ã¼­
-						case 50325: // Book of Precision
-						{
-							if (IsPolymorphed() == true)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("µÐ°© Áß¿¡´Â ´É·ÂÀ» ¿Ã¸± ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							int iSkillLevelLowLimit = item->GetValue(0);
-							int iSkillLevelHighLimit = item->GetValue(1);
-							int iPct = MINMAX(0, item->GetValue(2), 100);
-							int iLevelLimit = item->GetValue(3);
-							DWORD dwSkillVnum = 0;
-
-							switch (item->GetVnum())
-							{
-								case 50314: case 50315: case 50316:
-									dwSkillVnum = SKILL_POLYMORPH;
-									break;
-
-#if defined(__CONQUEROR_LEVEL__)
-								case 50325: // Book of Precision
-									dwSkillVnum = SKILL_HIT;
-									break;
-#endif
-
-								default:
-									return false;
-							}
-
-							if (0 == dwSkillVnum)
-								return false;
-
-#if defined(__CONQUEROR_LEVEL__)
-							if (dwSkillVnum == SKILL_HIT && GetConquerorLevel() < iSkillLevelLowLimit)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ Ã¥À» ÀÐÀ¸·Á¸é ·¹º§À» ´õ ¿Ã·Á¾ß ÇÕ´Ï´Ù."));
-								return false;
-							}
-							else
-#endif
-							{
-								if (GetLevel() < iLevelLimit)
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ Ã¥À» ÀÐÀ¸·Á¸é ·¹º§À» ´õ ¿Ã·Á¾ß ÇÕ´Ï´Ù."));
-									return false;
-								}
-							}
-
-							if (GetSkillLevel(dwSkillVnum) >= 40)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´õ ÀÌ»ó ¼ö·ÃÇÒ ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (GetSkillLevel(dwSkillVnum) < iSkillLevelLowLimit
-#if defined(__CONQUEROR_LEVEL__)
-								&& dwSkillVnum != SKILL_HIT
-#endif
-								)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ Ã¥Àº ³Ê¹« ¾î·Á¿ö ÀÌÇØÇÏ±â°¡ Èûµì´Ï´Ù."));
-								return false;
-							}
-
-							if (GetSkillLevel(dwSkillVnum) >= iSkillLevelHighLimit)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ Ã¥À¸·Î´Â ´õ ÀÌ»ó ¼ö·ÃÇÒ ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-						// END_LEARNABLE_SKILL_BOOKS_BY_LEVEL
-
-						// LEARNABLE_SKILL_BOOKS_BY_EXP
-#if defined(__PARTY_PROFICY__)
-						case 50338:	// Charisma of a Rookie
-						case 50339:	// Charisma of an Adept
-						case 50340:	// Charisma of an Expert
-#endif
-#if defined(__PARTY_INSIGHT__)
-						case 50341:	// Inspiration of a Rookie
-						case 50342:	// Inspiration of an Adept
-						case 50343:	// Inspiration of an Expert
-#endif
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("µÐ°© Áß¿¡´Â ´É·ÂÀ» ¿Ã¸± ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							int iSkillLevelLowLimit = item->GetValue(0);
-							int iSkillLevelHighLimit = item->GetValue(1);
-							int iPct = MINMAX(0, item->GetValue(2), 100);
-							int iNeedExp = item->GetValue(3);
-							DWORD dwSkillVnum = 0;
-
-							switch (item->GetVnum())
-							{
-#if defined(__PARTY_PROFICY__)
-								case 50338:	// Charisma of a Rookie
-								case 50339:	// Charisma of an Adept
-								case 50340:	// Charisma of an Expert
-									dwSkillVnum = SKILL_ROLE_PROFICIENCY;
-									break;
-#endif
-
-#if defined(__PARTY_INSIGHT__)
-								case 50341:	// Inspiration of a Rookie
-								case 50342:	// Inspiration of an Adept
-								case 50343:	// Inspiration of an Expert
-									dwSkillVnum = SKILL_INSIGHT;
-									break;
-#endif
-
-								default:
-									return false;
-							}
-
-							if (0 == dwSkillVnum)
-								return false;
-
-							if (GetExp() < static_cast<DWORD>(iNeedExp))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("°æÇèÄ¡°¡ ºÎÁ·ÇÏ¿© Ã¥À» ÀÐÀ» ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (GetSkillLevel(dwSkillVnum) >= 40)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ö·ÃÇÒ ¼ö ¾ø´Â ½ºÅ³ÀÔ´Ï´Ù."));
-								return false;
-							}
-
-							if (GetSkillLevel(dwSkillVnum) < iSkillLevelLowLimit)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ Ã¥Àº ³Ê¹« ¾î·Á¿ö ÀÌÇØÇÏ±â°¡ Èûµì´Ï´Ù."));
-								return false;
-							}
-
-							if (GetSkillLevel(dwSkillVnum) >= iSkillLevelHighLimit)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ Ã¥À¸·Î´Â ´õ ÀÌ»ó ¼ö·ÃÇÒ ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								if (dwSkillVnum != SKILL_HIT)
-									PointChange(POINT_EXP, -iNeedExp);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server)
-									iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-						// END_LEARNABLE_SKILL_BOOKS_BY_EXP
-
-						case 50902:
-						case 50903:
-						case 50904:
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("º¯½ÅÁß¿¡´Â Ã¥À» ÀÐÀ»¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							DWORD dwSkillVnum = SKILL_CREATE;
-							int iPct = MINMAX(0, item->GetValue(1), 100);
-
-							if (GetSkillLevel(dwSkillVnum) >= 40)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´õ ÀÌ»ó ¼ö·ÃÇÒ ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-
-								if (test_server)
-								{
-									ChatPacket(CHAT_TYPE_INFO, "[TEST_SERVER] Success to learn skill ");
-								}
-							}
-							else
-							{
-								if (test_server)
-								{
-									ChatPacket(CHAT_TYPE_INFO, "[TEST_SERVER] Failed to learn skill ");
-								}
-							}
-						}
-						break;
-
-						// MINING
-						case ITEM_MINING_SKILL_TRAIN_BOOK:
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("º¯½ÅÁß¿¡´Â Ã¥À» ÀÐÀ»¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							DWORD dwSkillVnum = SKILL_MINING;
-							int iPct = MINMAX(0, item->GetValue(1), 100);
-
-							if (GetSkillLevel(dwSkillVnum) >= 40)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´õ ÀÌ»ó ¼ö·ÃÇÒ ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (LearnSkillByBook(dwSkillVnum, iPct))
-							{
-								item->SetCount(item->GetCount() - 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-						}
-						break;
-						// END_OF_MINING
-
-						case ITEM_HORSE_SKILL_TRAIN_BOOK:
-						{
-							if (IsPolymorphed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("º¯½ÅÁß¿¡´Â Ã¥À» ÀÐÀ»¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							DWORD dwSkillVnum = SKILL_HORSE;
-							int iPct = MINMAX(0, item->GetValue(1), 100);
-
-							if (GetLevel() < 50)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÁ÷ ½Â¸¶ ½ºÅ³À» ¼ö·ÃÇÒ ¼ö ÀÖ´Â ·¹º§ÀÌ ¾Æ´Õ´Ï´Ù."));
-								return false;
-							}
-
-							if (!test_server && get_global_time() < GetSkillNextReadTime(dwSkillVnum))
-							{
-								if (FindAffect(AFFECT_SKILL_NO_BOOK_DELAY))
-								{
-									// ÁÖ¾È¼ú¼­ »ç¿ëÁß¿¡´Â ½Ã°£ Á¦ÇÑ ¹«½Ã
-									RemoveAffect(AFFECT_SKILL_NO_BOOK_DELAY);
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÁÖ¾È¼ú¼­¸¦ ÅëÇØ ÁÖÈ­ÀÔ¸¶¿¡¼­ ºüÁ®³ª¿Ô½À´Ï´Ù."));
-								}
-								else
-								{
-									SkillLearnWaitMoreTimeMessage(GetSkillNextReadTime(dwSkillVnum) - get_global_time());
-									return false;
-								}
-							}
-
-							if (GetPoint(POINT_HORSE_SKILL) >= 20 ||
-								GetSkillLevel(SKILL_HORSE_WILDATTACK) + GetSkillLevel(SKILL_HORSE_CHARGE) + GetSkillLevel(SKILL_HORSE_ESCAPE) >= 60 ||
-								GetSkillLevel(SKILL_HORSE_WILDATTACK_RANGE) + GetSkillLevel(SKILL_HORSE_CHARGE) + GetSkillLevel(SKILL_HORSE_ESCAPE) >= 60)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´õ ÀÌ»ó ½Â¸¶ ¼ö·Ã¼­¸¦ ÀÐÀ» ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (number(1, 100) <= iPct)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("½Â¸¶ ¼ö·Ã¼­¸¦ ÀÐ¾î ½Â¸¶ ½ºÅ³ Æ÷ÀÎÆ®¸¦ ¾ò¾ú½À´Ï´Ù."));
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾òÀº Æ÷ÀÎÆ®·Î´Â ½Â¸¶ ½ºÅ³ÀÇ ·¹º§À» ¿Ã¸± ¼ö ÀÖ½À´Ï´Ù."));
-								PointChange(POINT_HORSE_SKILL, 1);
-
-								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
-								if (distribution_test_server) iReadDelay /= 3;
-
-								if (!test_server)
-									SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("½Â¸¶ ¼ö·Ã¼­ ÀÌÇØ¿¡ ½ÇÆÐÇÏ¿´½À´Ï´Ù."));
-							}
-
-							ITEM_MANAGER::instance().RemoveItem(item);
-						}
-						break;
-
-						case 70102: // ¼±µÎ
-						case 70103: // ¼±µÎ
-						{
-							if (GetAlignment() >= 0)
-								return false;
-
-							int delta = MIN(-GetAlignment(), item->GetValue(0));
-
-							sys_log(0, "%s ALIGNMENT ITEM %d", GetName(), delta);
-
-							UpdateAlignment(delta);
-							item->SetCount(item->GetCount() - 1);
-
-							if (delta / 10 > 0)
-							{
-								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("¸¶À½ÀÌ ¸¼¾ÆÁö´Â±º. °¡½¿À» Áþ´©¸£´ø ¹«¾ð°¡°¡ Á» °¡º­¿öÁø ´À³¦ÀÌ¾ß."));
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼±¾ÇÄ¡°¡ %d Áõ°¡ÇÏ¿´½À´Ï´Ù.", delta / 10));
-							}
-						}
-						break;
-
-						case 71107: // Ãµµµº¹¼þ¾Æ
-						case 39032:
-						{
-							quest::CQuestManager& q = quest::CQuestManager::Instance();
-							quest::PC* pPC = q.GetPC(GetPlayerID());
-							if (pPC)
-							{
-								int val = item->GetValue(0);
-								int interval = item->GetValue(1);
-								int last_use_time = pPC->GetFlag("mythical_peach.last_use_time");
-								if (get_global_time() - last_use_time < interval * 60 * 60)
-								{
-									if (test_server == false)
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÁ÷ »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-										return false;
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("Å×½ºÆ® ¼­¹ö ½Ã°£Á¦ÇÑ Åë°ú"));
-									}
-								}
-
-								if (GetAlignment() == 200000)
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼±¾ÇÄ¡¸¦ ´õ ÀÌ»ó ¿Ã¸± ¼ö ¾ø½À´Ï´Ù."));
-									return false;
-								}
-
-								if (200000 - GetAlignment() < val * 10)
-								{
-									val = (200000 - GetAlignment()) / 10;
-								}
-
-								int old_alignment = GetAlignment() / 10;
-
-								UpdateAlignment(val * 10);
-
-								item->SetCount(item->GetCount() - 1);
-								pPC->SetFlag("mythical_peach.last_use_time", get_global_time());
-
-								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("¸¶À½ÀÌ ¸¼¾ÆÁö´Â±º. °¡½¿À» Áþ´©¸£´ø ¹«¾ð°¡°¡ Á» °¡º­¿öÁø ´À³¦ÀÌ¾ß."));
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼±¾ÇÄ¡°¡ %d Áõ°¡ÇÏ¿´½À´Ï´Ù.", val));
-
-								char buf[256 + 1];
-								snprintf(buf, sizeof(buf), "%d %d", old_alignment, GetAlignment() / 10);
-								LogManager::instance().CharLog(this, val, "MYTHICAL_PEACH", buf);
-							}
-						}
-						break;
-
-						case 71109: // Å»¼®¼­
-						case 39033:
-						{
-							LPITEM item2;
-
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item2->IsExchanging() || item2->IsEquipped())
-								return false;
-
-							if (item2->GetSocketCount() == 0)
-								return false;
-
-							switch (item2->GetType())
-							{
-								case ITEM_WEAPON:
-									break;
-
-								case ITEM_ARMOR:
-									switch (item2->GetSubType())
-									{
-										case ARMOR_EAR:
-										case ARMOR_WRIST:
-										case ARMOR_NECK:
-											ChatPacket(CHAT_TYPE_INFO, LC_STRING("»©³¾ ¿µ¼®ÀÌ ¾ø½À´Ï´Ù"));
-											return false;
-									}
-									break;
-
-								default:
-									return false;
-							}
-
-							std::stack<long> socket;
-
-							for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-							{
-#if defined(__GLOVE_SYSTEM__)
-								DWORD dwSocketData = item2->GetSocket(i);
-								if (item2->IsGlove() && dwSocketData >= 1000000 && dwSocketData != ITEM_BROKEN_METIN_VNUM)
-								{
-									DWORD dwBaseIndex = 28046;
-									dwBaseIndex += (((dwSocketData / 1000) % 10) * 100);
-									dwBaseIndex += ((dwSocketData / 100) % 10) - 1;
-
-									const TItemTable* pItemData = ITEM_MANAGER::instance().GetTable(dwBaseIndex);
-									if (pItemData == nullptr)
-										continue;
-
-									dwSocketData = dwBaseIndex;
-								}
-								socket.push(dwSocketData);
-#else
-								socket.push(item2->GetSocket(i));
-#endif
-							}
-
-							int idx = METIN_SOCKET_MAX_NUM - 1;
-
-							while (socket.size() > 0)
-							{
-								if (socket.top() > 2 && socket.top() != ITEM_BROKEN_METIN_VNUM)
-									break;
-
-								idx--;
-								socket.pop();
-							}
-
-							if (socket.size() == 0)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("»©³¾ ¿µ¼®ÀÌ ¾ø½À´Ï´Ù"));
-								return false;
-							}
-
-							LPITEM pItemReward = AutoGiveItem(socket.top());
-							if (pItemReward != NULL)
-							{
-								item2->SetSocket(idx, 1);
-
-								char buf[256 + 1];
-								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
-									item2->GetName(), item2->GetID(), pItemReward->GetName(), pItemReward->GetID());
-								LogManager::instance().ItemLog(this, item, "USE_DETACHMENT_ONE", buf);
-
-								item->SetCount(item->GetCount() - 1);
-							}
-						}
-						break;
-
-						case 70201: // Å»»öÁ¦
-						case 70202: // ¿°»ö¾à(Èò»ö)
-						case 70203: // ¿°»ö¾à(±Ý»ö)
-						case 70204: // ¿°»ö¾à(»¡°£»ö)
-						case 70205: // ¿°»ö¾à(°¥»ö)
-						case 70206: // ¿°»ö¾à(°ËÀº»ö)
-						{
-							// NEW_HAIR_STYLE_ADD
-							if (GetPart(PART_HAIR) >= 1001)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÇöÀç Çì¾î½ºÅ¸ÀÏ¿¡¼­´Â ¿°»ö°ú Å»»öÀÌ ºÒ°¡´ÉÇÕ´Ï´Ù."));
-							}
-							// END_NEW_HAIR_STYLE_ADD
-							else
-							{
-								quest::CQuestManager& q = quest::CQuestManager::instance();
-								quest::PC* pPC = q.GetPC(GetPlayerID());
-								if (pPC)
-								{
-									int last_dye_level = pPC->GetFlag("dyeing_hair.last_dye_level");
-
-									if (last_dye_level == 0 ||
-										last_dye_level + 3 <= GetLevel() ||
-										item->GetVnum() == 70201)
-									{
-										SetPart(PART_HAIR, item->GetVnum() - 70201);
-
-										if (item->GetVnum() == 70201)
-											pPC->SetFlag("dyeing_hair.last_dye_level", 0);
-										else
-											pPC->SetFlag("dyeing_hair.last_dye_level", GetLevel());
-
-										item->SetCount(item->GetCount() - 1);
-										UpdatePacket();
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d ·¹º§ÀÌ µÇ¾î¾ß ´Ù½Ã ¿°»öÇÏ½Ç ¼ö ÀÖ½À´Ï´Ù.", last_dye_level + 3));
-									}
-								}
-							}
-						}
-						break;
-
-						case ITEM_NEW_YEAR_GREETING_VNUM:
-						{
-							if (GiveItemFromSpecialItemGroup(ITEM_NEW_YEAR_GREETING_VNUM))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_VALENTINE_ROSE:
-						case ITEM_VALENTINE_CHOCOLATE:
-						{
-							if (item->GetVnum() == ITEM_VALENTINE_ROSE && SEX_MALE == GET_SEX(this) ||
-								item->GetVnum() == ITEM_VALENTINE_CHOCOLATE && SEX_FEMALE == GET_SEX(this))
-							{
-								// ¼ºº°ÀÌ ¸ÂÁö¾Ê¾Æ ¾µ ¼ö ¾ø´Ù.
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ºº°ÀÌ ¸ÂÁö¾Ê¾Æ ÀÌ ¾ÆÀÌÅÛÀ» ¿­ ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (GiveItemFromSpecialItemGroup(item->GetVnum()))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_WHITEDAY_CANDY:
-						case ITEM_WHITEDAY_ROSE:
-						{
-							if (item->GetVnum() == ITEM_WHITEDAY_CANDY && SEX_MALE == GET_SEX(this) ||
-								item->GetVnum() == ITEM_WHITEDAY_ROSE && SEX_FEMALE == GET_SEX(this))
-							{
-								// ¼ºº°ÀÌ ¸ÂÁö¾Ê¾Æ ¾µ ¼ö ¾ø´Ù.
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ºº°ÀÌ ¸ÂÁö¾Ê¾Æ ÀÌ ¾ÆÀÌÅÛÀ» ¿­ ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (GiveItemFromSpecialItemGroup(item->GetVnum()))
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case 50011: // ¿ù±¤º¸ÇÕ
-						{
-							if (!GiveItemFromSpecialItemGroup(50011))
-							{
-								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("¾Æ¹«°Íµµ ¾òÀ» ¼ö ¾ø¾ú½À´Ï´Ù."));
-								return false;
-							}
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_GIVE_STAT_RESET_COUNT_VNUM:
-						{
-							//PointChange(POINT_GOLD, -iCost);
-							PointChange(POINT_STAT_RESET_COUNT, 1);
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case 50107:
-						{
-							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·Ã Áß¿¡´Â ÀÌ¿ëÇÒ ¼ö ¾ø´Â ¹°Ç°ÀÔ´Ï´Ù."));
-								return false;
-							}
-
-							EffectPacket(SE_CHINA_FIREWORK);
-							// ½ºÅÏ °ø°ÝÀ» ¿Ã·ÁÁØ´Ù
-							AddAffect(AFFECT_CHINA_FIREWORK, POINT_STUN_PCT, 30, AFF_CHINA_FIREWORK, 5 * 60, 0, true);
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case 50108:
-						{
-							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·Ã Áß¿¡´Â ÀÌ¿ëÇÒ ¼ö ¾ø´Â ¹°Ç°ÀÔ´Ï´Ù."));
-								return false;
-							}
-
-							EffectPacket(SE_SPIN_TOP);
-							// ½ºÅÏ °ø°ÝÀ» ¿Ã·ÁÁØ´Ù
-							AddAffect(AFFECT_CHINA_FIREWORK, POINT_STUN_PCT, 30, AFF_CHINA_FIREWORK, 5 * 60, 0, true);
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case ITEM_WONSO_BEAN_VNUM:
-							PointChange(POINT_HP, GetMaxHP() - GetHP());
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case ITEM_WONSO_SUGAR_VNUM:
-							PointChange(POINT_SP, GetMaxSP() - GetSP());
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case ITEM_WONSO_FRUIT_VNUM:
-							PointChange(POINT_STAMINA, GetMaxStamina() - GetStamina());
-							item->SetCount(item->GetCount() - 1);
-							break;
-
-						case ITEM_ELK_VNUM: // µ·²Ù·¯¹Ì
-						{
-							int iGold = item->GetSocket(0);
-							ITEM_MANAGER::instance().RemoveItem(item);
-							PointChange(POINT_GOLD, iGold);
-						}
-						break;
-
-						// ±ºÁÖÀÇ ÁõÇ¥
-						case 70021:
-						{
-							int HealPrice = quest::CQuestManager::instance().GetEventFlag("MonarchHealGold");
-							if (HealPrice == 0)
-								HealPrice = 2000000;
-
-							if (CMonarch::instance().HealMyEmpire(this, HealPrice))
-							{
-								char szNotice[256];
-								snprintf(szNotice, sizeof(szNotice), LC_STRING("±ºÁÖÀÇ Ãàº¹À¸·Î ÀÌÁö¿ª %s À¯Àú´Â HP,SP°¡ ¸ðµÎ Ã¤¿öÁý´Ï´Ù.", EMPIRE_NAME(GetEmpire())));
-								SendNoticeMap(szNotice, GetMapIndex(), false);
-
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("±ºÁÖÀÇ Ãàº¹À» »ç¿ëÇÏ¿´½À´Ï´Ù."));
-							}
-						}
-						break;
-
-						case 27995:
-						{
-						}
-						break;
-
-						case 71092: // º¯½Å ÇØÃ¼ºÎ ÀÓ½Ã
-						{
-							if (m_pkChrTarget != NULL)
-							{
-								if (m_pkChrTarget->IsPolymorphed())
-								{
-									m_pkChrTarget->SetPolymorph(0);
-									m_pkChrTarget->RemoveAffect(AFFECT_POLYMORPH);
-								}
-							}
-							else
-							{
-								if (IsPolymorphed())
-								{
-									SetPolymorph(0);
-									RemoveAffect(AFFECT_POLYMORPH);
-								}
-							}
-						}
-						break;
-
-						case 71051: // ÁøÀç°¡
-						{
-							LPITEM item2;
-
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetInventoryItem(wDestCell)))
-								return false;
-
-							if (item2->IsExchanging())
-								return false;
-
-							if (item2->IsEquipped())
-								return false;
-
-							if (item2->GetType() == ITEM_COSTUME)
-								return false;
-
-							//if (item2->GetAttributeCount() < 5)
-							//	return false;
-
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-								return false;
-							}
-
-							if (item2->AddRareAttribute() == true)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼º Ãß°¡¿¡ ¼º°øÇÏ¿´½À´Ï´Ù."));
-
-								int iAddedIdx = item2->GetRareAttrCount() + 4;
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-
-								LogManager::instance().ItemLog(
-									GetPlayerID(),
-									item2->GetAttributeType(iAddedIdx),
-									item2->GetAttributeValue(iAddedIdx),
-									item->GetID(),
-									"ADD_RARE_ATTR",
-									buf,
-									GetDesc()->GetHostName(),
-									item->GetOriginalVnum());
-
-								if (!g_bUnlimitedAddRareAttributes)
-									item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼º Ãß°¡¿¡ ½ÇÆÐÇÏ¿´½À´Ï´Ù."));
-							}
-						}
-						break;
-
-						case 71052: // ÁøÀç°æ
-						{
-							LPITEM item2;
-
-							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-								return false;
-
-							if (item2->IsEquipped())
-								return false;
-
-							if (item2->GetType() == ITEM_COSTUME)
-								return false;
-
-							if (item2->IsExchanging() == true)
-								return false;
-
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-								return false;
-							}
-
-							if (item2->ChangeRareAttribute() == true)
-							{
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-								LogManager::instance().ItemLog(this, item, "CHANGE_RARE_ATTR", buf);
-
-								if (!g_bUnlimitedChangeRareAttributes)
-									item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÏ¿´½À´Ï´Ù."));
-							}
-						}
-						break;
-
-						case ITEM_AUTO_HP_RECOVERY_S:
-						case ITEM_AUTO_HP_RECOVERY_M:
-						case ITEM_AUTO_HP_RECOVERY_L:
-						case ITEM_AUTO_HP_RECOVERY_X:
-						case ITEM_AUTO_SP_RECOVERY_S:
-						case ITEM_AUTO_SP_RECOVERY_M:
-						case ITEM_AUTO_SP_RECOVERY_L:
-						case ITEM_AUTO_SP_RECOVERY_X:
-							// ¹«½Ã¹«½ÃÇÏÁö¸¸ ÀÌÀü¿¡ ÇÏ´ø °É °íÄ¡±â´Â ¹«¼·°í...
-							// ±×·¡¼­ ±×³É ÇÏµå ÄÚµù. ¼±¹° »óÀÚ¿ë ÀÚµ¿¹°¾à ¾ÆÀÌÅÛµé.
-						case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
-						case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
-						case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
-						case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
-						{
-							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·ÃÀå¿¡¼­ »ç¿ëÇÏ½Ç ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							EAffectTypes type = AFFECT_NONE;
-							bool isSpecialPotion = false;
-
-							switch (item->GetVnum())
-							{
-								case ITEM_AUTO_HP_RECOVERY_X:
-									isSpecialPotion = true;
-
-								case ITEM_AUTO_HP_RECOVERY_S:
-								case ITEM_AUTO_HP_RECOVERY_M:
-								case ITEM_AUTO_HP_RECOVERY_L:
-								case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
-								case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
-									type = AFFECT_AUTO_HP_RECOVERY;
-									break;
-
-								case ITEM_AUTO_SP_RECOVERY_X:
-									isSpecialPotion = true;
-
-								case ITEM_AUTO_SP_RECOVERY_S:
-								case ITEM_AUTO_SP_RECOVERY_M:
-								case ITEM_AUTO_SP_RECOVERY_L:
-								case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
-								case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
-									type = AFFECT_AUTO_SP_RECOVERY;
-									break;
-							}
-
-							if (AFFECT_NONE == type)
-								break;
-
-							if (item->GetCount() > 1)
-							{
-								int pos = GetEmptyInventory(item->GetSize());
-
-								if (-1 == pos)
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ÒÁöÇ°¿¡ ºó °ø°£ÀÌ ¾ø½À´Ï´Ù."));
-									break;
-								}
-
-								item->SetCount(item->GetCount() - 1);
-
-								LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), 1);
-								item2->AddToCharacter(this, TItemPos(INVENTORY, pos));
-
-								if (item->GetSocket(1) != 0)
-								{
-									item2->SetSocket(1, item->GetSocket(1));
-								}
-
-								item = item2;
-							}
-
-							CAffect* pAffect = FindAffect(type);
-
-							if (NULL == pAffect)
-							{
-								EPointTypes bonus = POINT_NONE;
-
-								if (true == isSpecialPotion)
-								{
-									if (type == AFFECT_AUTO_HP_RECOVERY)
-									{
-										bonus = POINT_MAX_HP_PCT;
-									}
-									else if (type == AFFECT_AUTO_SP_RECOVERY)
-									{
-										bonus = POINT_MAX_SP_PCT;
-									}
-								}
-
-								AddAffect(type, bonus, 4, item->GetID(), INFINITE_AFFECT_DURATION, 0, true, false);
-
-								item->Lock(true);
-								item->SetSocket(0, true);
-
-								AutoRecoveryItemProcess(type);
-							}
-							else
-							{
-								if (item->GetID() == pAffect->dwFlag)
-								{
-									RemoveAffect(pAffect);
-
-									item->Lock(false);
-									item->SetSocket(0, false);
-								}
-								else
-								{
-									LPITEM old = FindItemByID(pAffect->dwFlag);
-
-									if (NULL != old)
-									{
-										old->Lock(false);
-										old->SetSocket(0, false);
-									}
-
-									RemoveAffect(pAffect);
-
-									EPointTypes bonus = POINT_NONE;
-
-									if (true == isSpecialPotion)
-									{
-										if (type == AFFECT_AUTO_HP_RECOVERY)
-										{
-											bonus = POINT_MAX_HP_PCT;
-										}
-										else if (type == AFFECT_AUTO_SP_RECOVERY)
-										{
-											bonus = POINT_MAX_SP_PCT;
-										}
-									}
-
-									AddAffect(type, bonus, 4, item->GetID(), INFINITE_AFFECT_DURATION, 0, true, false);
-
-									item->Lock(true);
-									item->SetSocket(0, true);
-
-									AutoRecoveryItemProcess(type);
-								}
-							}
-						}
-						break;
-					}
-				}
-				break;
-
-				case USE_CLEAR:
-				{
-					switch (item->GetVnum())
-					{
-						case 27124: // Bandage
-							RemoveBleeding();
-							break;
-
-						case 27874: // Grilled Perch
-							RemoveBadAffect();
-							break;
-					}
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case USE_INVISIBILITY:
-				{
-					if (item->GetVnum() == 70026)
-					{
-						quest::CQuestManager& q = quest::CQuestManager::instance();
-						quest::PC* pPC = q.GetPC(GetPlayerID());
-
-						if (pPC != NULL)
-						{
-							int last_use_time = pPC->GetFlag("mirror_of_disapper.last_use_time");
-
-							if (get_global_time() - last_use_time < 10 * 60)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÁ÷ »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							pPC->SetFlag("mirror_of_disapper.last_use_time", get_global_time());
-						}
-					}
-
-					AddAffect(AFFECT_INVISIBILITY, POINT_NONE, 0, AFF_INVISIBILITY, 300, 0, true);
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case USE_POTION_NODELAY:
-				{
-					if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-					{
-						if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·ÃÀå¿¡¼­ »ç¿ëÇÏ½Ç ¼ö ¾ø½À´Ï´Ù."));
-							return false;
-						}
-
-						switch (item->GetVnum())
-						{
-							case 70020:
-							case 71018:
-							case 71019:
-							case 71020:
-							{
-								if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
-								{
-									if (m_nPotionLimit <= 0)
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ç¿ë Á¦ÇÑ·®À» ÃÊ°úÇÏ¿´½À´Ï´Ù."));
-										return false;
-									}
-								}
-							}
-							break;
-
-							default:
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·ÃÀå¿¡¼­ »ç¿ëÇÏ½Ç ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-						}
-					}
-
-					bool bUsed = false;
-
-					if (item->GetValue(0) != 0) // HP Àý´ë°ª È¸º¹
-					{
-						if (GetHP() < GetMaxHP())
-						{
-							PointChange(POINT_HP, item->GetValue(0) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
-							EffectPacket(SE_HPUP_RED);
-							bUsed = true;
-						}
-					}
-
-					if (item->GetValue(1) != 0) // SP Àý´ë°ª È¸º¹
-					{
-						if (GetSP() < GetMaxSP())
-						{
-							PointChange(POINT_SP, item->GetValue(1) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
-							EffectPacket(SE_SPUP_BLUE);
-							bUsed = true;
-						}
-					}
-
-					if (item->GetValue(3) != 0) // HP % È¸º¹
-					{
-						if (GetHP() < GetMaxHP())
-						{
-							PointChange(POINT_HP, item->GetValue(3) * GetMaxHP() / 100);
-							EffectPacket(SE_HPUP_RED);
-							bUsed = true;
-						}
-					}
-
-					if (item->GetValue(4) != 0) // SP % È¸º¹
-					{
-						if (GetSP() < GetMaxSP())
-						{
-							PointChange(POINT_SP, item->GetValue(4) * GetMaxSP() / 100);
-							EffectPacket(SE_SPUP_BLUE);
-							bUsed = true;
-						}
-					}
-
-					if (bUsed)
-					{
-						if (item->GetVnum() == 50085 || item->GetVnum() == 50086)
-						{
-							if (test_server)
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¿ùº´ ¶Ç´Â Á¾ÀÚ ¸¦ »ç¿ëÇÏ¿´½À´Ï´Ù"));
-
-							SetUseSeedOrMoonBottleTime();
-						}
-
-						if (GetDungeon())
-							GetDungeon()->UsePotion(this);
-
-						if (GetWarMap())
-							GetWarMap()->UsePotion(this, item);
-
-						m_nPotionLimit--;
-
-						// RESTRICT_USE_SEED_OR_MOONBOTTLE
-						item->SetCount(item->GetCount() - 1);
-						// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
-					}
-				}
-				break;
-
-				case USE_POTION:
-				{
-					if (CArenaManager::instance().IsArenaMap(GetMapIndex()) == true)
-					{
-						if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·ÃÀå¿¡¼­ »ç¿ëÇÏ½Ç ¼ö ¾ø½À´Ï´Ù."));
-							return false;
-						}
-
-						switch (item->GetVnum())
-						{
-							case 27001: // Red Potion (S)
-							case 27002: // Red Potion (M)
-							case 27003: // Red Potion (L)
-							case 27007: // Red Potion (XXL)
-							case 27004: // Blue Potion (S)
-							case 27005: // Blue Potion (M)
-							case 27006: // Blue Potion (L)
-							case 27008: // Red Potion (XXL)
-							{
-								if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
-								{
-									if (m_nPotionLimit <= 0)
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ç¿ë Á¦ÇÑ·®À» ÃÊ°úÇÏ¿´½À´Ï´Ù."));
-										return false;
-									}
-								}
-							}
-							break;
-
-							default:
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·ÃÀå¿¡¼­ »ç¿ëÇÏ½Ç ¼ö ¾ø½À´Ï´Ù."));
-								return false;
-						}
-					}
-
-					if (item->GetValue(1) != 0)
-					{
-						if (GetPoint(POINT_SP_RECOVERY) + GetSP() >= GetMaxSP())
-							return false;
-
-						PointChange(POINT_SP_RECOVERY, item->GetValue(1) * MIN(200, (100 + GetPoint(POINT_POTION_BONUS))) / 100);
-						StartAffectEvent();
-						EffectPacket(SE_SPUP_BLUE);
-					}
-
-					if (item->GetValue(0) != 0)
-					{
-						if (GetPoint(POINT_HP_RECOVERY) + GetHP() >= GetMaxHP())
-							return false;
-
-						PointChange(POINT_HP_RECOVERY, item->GetValue(0) * MIN(200, (100 + GetPoint(POINT_POTION_BONUS))) / 100);
-						StartAffectEvent();
-						EffectPacket(SE_HPUP_RED);
-					}
-
-					if (GetDungeon())
-						GetDungeon()->UsePotion(this);
-
-					if (GetWarMap())
-						GetWarMap()->UsePotion(this, item);
-
-					item->SetCount(item->GetCount() - 1);
-					m_nPotionLimit--;
-				}
-				break;
-
-				case USE_POTION_CONTINUE:
-				{
-					if (item->GetValue(0) != 0)
-						AddAffect(AFFECT_HP_RECOVER_CONTINUE, POINT_HP_RECOVER_CONTINUE, item->GetValue(0), 0, item->GetValue(2), 0, true);
-					else if (item->GetValue(1) != 0)
-						AddAffect(AFFECT_SP_RECOVER_CONTINUE, POINT_SP_RECOVER_CONTINUE, item->GetValue(1), 0, item->GetValue(2), 0, true);
-					else
-						return false;
-
-					if (GetDungeon())
-						GetDungeon()->UsePotion(this);
-
-					if (GetWarMap())
-						GetWarMap()->UsePotion(this, item);
-
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case USE_ABILITY_UP:
-				{
-					if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-						return false;
-					}
-
-					switch (item->GetValue(0))
-					{
-						case APPLY_MOV_SPEED:
-						{
-							VERIFY_POTION(AFFECT_MOV_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_MOV_SPEED, POINT_MOV_SPEED, item->GetValue(2), AFF_MOV_SPEED_POTION, item->GetValue(1), 0, true);
-							EffectPacket(SE_DXUP_PURPLE);
-						}
-						break;
-
-						case APPLY_ATT_SPEED:
-						{
-							VERIFY_POTION(AFFECT_ATT_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_ATT_SPEED, POINT_ATT_SPEED, item->GetValue(2), AFF_ATT_SPEED_POTION, item->GetValue(1), 0, true);
-							EffectPacket(SE_SPEEDUP_GREEN);
-						}
-						break;
-
-						case APPLY_STR:
-						{
-							VERIFY_POTION(AFFECT_STR, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_STR, POINT_ST, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_DEX:
-						{
-							VERIFY_POTION(AFFECT_DEX, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_DEX, POINT_DX, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_CON:
-						{
-							VERIFY_POTION(AFFECT_CON, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_CON, POINT_HT, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_INT:
-						{
-							VERIFY_POTION(AFFECT_INT, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_INT, POINT_IQ, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_CAST_SPEED:
-						{
-							VERIFY_POTION(AFFECT_CAST_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_CAST_SPEED, POINT_CASTING_SPEED, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_ATT_GRADE_BONUS:
-						{
-							VERIFY_POTION(AFFECT_ATT_GRADE, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE_BONUS, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_DEF_GRADE_BONUS:
-						{
-							VERIFY_POTION(AFFECT_DEF_GRADE, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_DEF_GRADE, POINT_DEF_GRADE_BONUS, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_RESIST_MAGIC:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_MAGIC, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-#if defined(__CONQUEROR_LEVEL__)
-						case APPLY_SUNGMA_STR:
-						{
-							VERIFY_POTION(AFFECT_SUNGMA_STR, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_SUNGMA_STR, POINT_SUNGMA_STR, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_SUNGMA_HP:
-						{
-							VERIFY_POTION(AFFECT_SUNGMA_HP, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_SUNGMA_HP, POINT_SUNGMA_HP, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_SUNGMA_MOVE:
-						{
-							VERIFY_POTION(AFFECT_SUNGMA_MOVE, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_SUNGMA_MOVE, POINT_SUNGMA_MOVE, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-
-						case APPLY_SUNGMA_IMMUNE:
-						{
-							VERIFY_POTION(AFFECT_SUNGMA_IMMUNE, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_SUNGMA_IMMUNE, POINT_SUNGMA_IMMUNE, item->GetValue(2), 0, item->GetValue(1), 0, true);
-						}
-						break;
-#endif
-
-						case APPLY_ATTBONUS_MONSTER:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATTBONUS_MONSTER, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-						case APPLY_MALL_EXPBONUS:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MALL_EXPBONUS, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-						case APPLY_MELEE_MAGIC_ATTBONUS_PER:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MELEE_MAGIC_ATT_BONUS_PER, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-						case APPLY_RESIST_ICE:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_ICE, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-						case APPLY_RESIST_EARTH:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_EARTH, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-
-						case APPLY_RESIST_DARK:
-						{
-							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
-							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_DARK, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
-						}
-						break;
-					}
-
-					if (GetDungeon())
-						GetDungeon()->UsePotion(this);
-
-					if (GetWarMap())
-						GetWarMap()->UsePotion(this, item);
-
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case USE_TALISMAN:
-				{
-					const int TOWN_PORTAL = 1;
-					const int MEMORY_PORTAL = 2;
-
-					// gm_guild_build, oxevent ¸Ê¿¡¼­ ±ÍÈ¯ºÎ ±ÍÈ¯±â¾ïºÎ ¸¦ »ç¿ë¸øÇÏ°Ô ¸·À½
-					if (GetMapIndex() == 200 || GetMapIndex() == 113)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÇöÀç À§Ä¡¿¡¼­ »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-						return false;
-					}
-
-					if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ë·Ã Áß¿¡´Â ÀÌ¿ëÇÒ ¼ö ¾ø´Â ¹°Ç°ÀÔ´Ï´Ù."));
-						return false;
-					}
-
-					if (m_pkWarpEvent)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌµ¿ÇÒ ÁØºñ°¡ µÇ¾îÀÖÀ½À¸·Î ±ÍÈ¯ºÎ¸¦ »ç¿ëÇÒ¼ö ¾ø½À´Ï´Ù"));
-						return false;
-					}
-
-					// CONSUME_LIFE_WHEN_USE_WARP_ITEM
-					int consumeLife = CalculateConsume(this);
-
-					if (consumeLife < 0)
-						return false;
-					// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
-
-					if (item->GetValue(0) == TOWN_PORTAL) // ±ÍÈ¯ºÎ
-					{
-						if (item->GetSocket(0) == 0)
-						{
-							if (!GetDungeon())
-								if (!GiveRecallItem(item))
-									return false;
-
-							PIXEL_POSITION posWarp;
-
-							if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(GetMapIndex(), GetEmpire(), posWarp))
-							{
-								// CONSUME_LIFE_WHEN_USE_WARP_ITEM
-								PointChange(POINT_HP, -consumeLife, false);
-								// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
-
-								WarpSet(posWarp.x, posWarp.y);
-							}
-							else
-							{
-								sys_err("CHARACTER::UseItem : cannot find spawn position (name %s, %d x %d)", GetName(), GetX(), GetY());
-							}
-						}
-						else
-						{
-							if (test_server)
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¿ø·¡ À§Ä¡·Î º¹±Í"));
-
-							ProcessRecallItem(item);
-						}
-					}
-					else if (item->GetValue(0) == MEMORY_PORTAL) // ±ÍÈ¯±â¾ïºÎ
-					{
-						if (item->GetSocket(0) == 0)
-						{
-							if (GetDungeon())
-							{
-								const char* c_szConv = (g_iUseLocale ? "" : (under_han(item->GetName()) ? LC_STRING("À»") : LC_STRING("¸¦")));
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´øÀü ¾È¿¡¼­´Â %s%s »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù.", LC_ITEM(item->GetVnum()), c_szConv));
-								return false;
-							}
-
-							if (!GiveRecallItem(item))
-								return false;
-						}
-						else
-						{
-							// CONSUME_LIFE_WHEN_USE_WARP_ITEM
-							PointChange(POINT_HP, -consumeLife, false);
-							// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
-
-							ProcessRecallItem(item);
-						}
-					}
-				}
-				break;
-
-				case USE_TUNING:
-				case USE_DETACHMENT:
-				{
-					LPITEM item2;
-
-					if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-						return false;
-
-					if (item2->IsEquipped())
-						return false;
-
-					if (item2->IsExchanging())
-						return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-					if (item2->IsSealed())
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot improve a soulbound item."));
-						return false;
-					}
-#endif
-
-					if (PreventTradeWindow(WND_ALL))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¢°í,°Å·¡Ã¢µîÀÌ ¿­¸° »óÅÂ¿¡¼­´Â °³·®À» ÇÒ¼ö°¡ ¾ø½À´Ï´Ù"));
-						return false;
-					}
-
-					RefineItem(item, item2);
-				}
-				break;
-
-				// ACCESSORY_REFINE & ADD/CHANGE_ATTRIBUTES
-				case USE_PUT_INTO_BELT_SOCKET:
-				case USE_PUT_INTO_RING_SOCKET:
-				case USE_PUT_INTO_ACCESSORY_SOCKET:
-				case USE_ADD_ACCESSORY_SOCKET:
-				case USE_CLEAN_SOCKET:
-				case USE_CHANGE_ATTRIBUTE:
-#if defined(__ATTR_6TH_7TH__)
-				case USE_CHANGE_ATTRIBUTE2:
-#endif
-				case USE_ADD_ATTRIBUTE:
-				case USE_ADD_ATTRIBUTE2:
-#if defined(__MOVE_COSTUME_ATTR__)
-				case USE_RESET_COSTUME_ATTR:
-				case USE_CHANGE_COSTUME_ATTR:
-#endif
-#if defined(__CHANGED_ATTR__)
-				case USE_SELECT_ATTRIBUTE:
-#endif
-				{
-					LPITEM item2;
-					if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-						return false;
-
-					if (item2->IsEquipped())
-					{
-						BuffOnAttr_RemoveBuffsFromItem(item2);
-					}
-
-					// [NOTE] ÄÚ½ºÆ¬ ¾ÆÀÌÅÛ¿¡´Â ¾ÆÀÌÅÛ ÃÖÃÊ »ý¼º½Ã ·£´ý ¼Ó¼ºÀ» ºÎ¿©ÇÏµÇ, Àç°æÀç°¡ µîµîÀº ¸·¾Æ´Þ¶ó´Â ¿äÃ»ÀÌ ÀÖ¾úÀ½.
-					// ¿ø·¡ ANTI_CHANGE_ATTRIBUTE °°Àº ¾ÆÀÌÅÛ Flag¸¦ Ãß°¡ÇÏ¿© ±âÈ¹ ·¹º§¿¡¼­ À¯¿¬ÇÏ°Ô ÄÁÆ®·Ñ ÇÒ ¼ö ÀÖµµ·Ï ÇÒ ¿¹Á¤ÀÌ¾úÀ¸³ª
-					// ±×µý°Å ÇÊ¿ä¾øÀ¸´Ï ´ÚÄ¡°í »¡¸® ÇØ´Þ·¡¼­ ±×³É ¿©±â¼­ ¸·À½... -_-
-					/*
-					if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_CHANGE_ATTRIBUTE) && !item->IsSocketModifyingItem())
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the upgrade of this item."));
-						return false;
-					}
-					*/
-
-					if (ITEM_COSTUME == item2->GetType()
-#if defined(__MOVE_COSTUME_ATTR__)	
-						&& item->GetSubType() != USE_RESET_COSTUME_ATTR && item->GetSubType() != USE_CHANGE_COSTUME_ATTR
-#endif
-#if defined(__CHANGED_ATTR__)
-						&& item->GetSubType() != USE_SELECT_ATTRIBUTE
-#endif
-						)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-						return false;
-					}
-
-					if (item2->IsExchanging() || item2->IsEquipped())
-						return false;
-
-					switch (item->GetSubType())
-					{
-						case USE_CLEAN_SOCKET:
-						{
-							int i;
-							for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-							{
-								if (item2->GetSocket(i) == ITEM_BROKEN_METIN_VNUM)
-									break;
-							}
-
-							if (i == METIN_SOCKET_MAX_NUM)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã»¼ÒÇÒ ¼®ÀÌ ¹ÚÇôÀÖÁö ¾Ê½À´Ï´Ù."));
-								return false;
-							}
-
-							int j = 0;
-
-							for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-							{
-								if (item2->GetSocket(i) != ITEM_BROKEN_METIN_VNUM && item2->GetSocket(i) != 0)
-									item2->SetSocket(j++, item2->GetSocket(i));
-							}
-
-							for (; j < METIN_SOCKET_MAX_NUM; ++j)
-							{
-								if (item2->GetSocket(j) > 0)
-									item2->SetSocket(j, 1);
-							}
-
-							{
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-								LogManager::instance().ItemLog(this, item, "CLEAN_SOCKET", buf);
-							}
-
-							if (!g_bUnlimitedCleanSocket)
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case USE_CHANGE_ATTRIBUTE:
-						{
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
-								return false;
-							}
-#endif
-
-							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_ENCHANT))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Enchant Item cannot be used on this item."));
-								return false;
-							}
-
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-								return false;
-							}
-
-							if (item2->GetAttributeCount() == 0)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("º¯°æÇÒ ¼Ó¼ºÀÌ ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (g_bChangeItemAttrCycle)
-							{
-								if (GM_PLAYER == GetGMLevel() && false == test_server)
-								{
-									//
-									// Event Flag ¸¦ ÅëÇØ ÀÌÀü¿¡ ¾ÆÀÌÅÛ ¼Ó¼º º¯°æÀ» ÇÑ ½Ã°£À¸·Î ºÎÅÍ ÃæºÐÇÑ ½Ã°£ÀÌ Èê·¶´ÂÁö °Ë»çÇÏ°í
-									// ½Ã°£ÀÌ ÃæºÐÈ÷ Èê·¶´Ù¸é ÇöÀç ¼Ó¼ºº¯°æ¿¡ ´ëÇÑ ½Ã°£À» ¼³Á¤ÇØ ÁØ´Ù.
-									//
-
-									DWORD dwChangeItemAttrCycle = quest::CQuestManager::instance().GetEventFlag(msc_szChangeItemAttrCycleFlag);
-									if (dwChangeItemAttrCycle < msc_dwDefaultChangeItemAttrCycle)
-										dwChangeItemAttrCycle = msc_dwDefaultChangeItemAttrCycle;
-
-									quest::PC* pPC = quest::CQuestManager::instance().GetPC(GetPlayerID());
-
-									if (pPC)
-									{
-										DWORD dwNowMin = get_global_time() / 60;
-
-										DWORD dwLastChangeItemAttrMin = pPC->GetFlag(msc_szLastChangeItemAttrFlag);
-
-										if (dwLastChangeItemAttrMin + dwChangeItemAttrCycle > dwNowMin)
-										{
-											ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» ¹Ù²ÛÁö %dºÐ ÀÌ³»¿¡´Â ´Ù½Ã º¯°æÇÒ ¼ö ¾ø½À´Ï´Ù.(%d ºÐ ³²À½)",
-												dwChangeItemAttrCycle, dwChangeItemAttrCycle - (dwNowMin - dwLastChangeItemAttrMin)));
-											return false;
-										}
-
-										pPC->SetFlag(msc_szLastChangeItemAttrFlag, dwNowMin);
-									}
-								}
-							}
-
-							if (item->GetVnum() == 76014)
-							{
-								int aiChangeProb[ITEM_ATTRIBUTE_MAX_LEVEL] =
-								{
-									0, 10, 50, 39, 1
-								};
-
-								item2->ChangeAttribute(aiChangeProb);
-							}
-							else
-							{
-								// ¿¬Àç°æ Æ¯¼öÃ³¸®
-								// Àý´ë·Î ¿¬Àç°¡ Ãß°¡ ¾ÈµÉ°Å¶ó ÇÏ¿© ÇÏµå ÄÚµùÇÔ.
-								if (item->GetVnum() == 71151 || item->GetVnum() == 76023)
-								{
-									if ((item2->GetType() == ITEM_WEAPON) || (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY))
-									{
-										bool bCanUse = true;
-										for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-										{
-											if (item2->GetLimitType(i) == LIMIT_LEVEL && item2->GetLimitValue(i) > 40)
-											{
-												bCanUse = false;
-												break;
-											}
-										}
-										if (false == bCanUse)
-										{
-											ChatPacket(CHAT_TYPE_INFO, LC_STRING("Àû¿ë ·¹º§º¸´Ù ³ô¾Æ »ç¿ëÀÌ ºÒ°¡´ÉÇÕ´Ï´Ù."));
-											break;
-										}
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("¹«±â¿Í °©¿Ê¿¡¸¸ »ç¿ë °¡´ÉÇÕ´Ï´Ù."));
-										break;
-									}
-								}
-								item2->ChangeAttribute();
-							}
-
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÏ¿´½À´Ï´Ù."));
-							{
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-								LogManager::instance().ItemLog(this, item, "CHANGE_ATTRIBUTE", buf);
-							}
-
-							if (!g_bUnlimitedChangeAttributes)
-								item->SetCount(item->GetCount() - 1);
-						}
-						break;
-
-						case USE_ADD_ATTRIBUTE:
-						{
-							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_REINFORCE))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Reinforce Item cannot be used on this item."));
-								return false;
-							}
-
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-								return false;
-							}
-
-							if (item2->GetAttributeCount() < 4)
-							{
-								// ¿¬Àç°¡ Æ¯¼öÃ³¸®
-								// Àý´ë·Î ¿¬Àç°¡ Ãß°¡ ¾ÈµÉ°Å¶ó ÇÏ¿© ÇÏµå ÄÚµùÇÔ.
-								if (item->GetVnum() == 71152 || item->GetVnum() == 76024)
-								{
-									if ((item2->GetType() == ITEM_WEAPON) || (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY))
-									{
-										bool bCanUse = true;
-										for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-										{
-											if (item2->GetLimitType(i) == LIMIT_LEVEL && item2->GetLimitValue(i) > 40)
-											{
-												bCanUse = false;
-												break;
-											}
-										}
-										if (false == bCanUse)
-										{
-											ChatPacket(CHAT_TYPE_INFO, LC_STRING("Àû¿ë ·¹º§º¸´Ù ³ô¾Æ »ç¿ëÀÌ ºÒ°¡´ÉÇÕ´Ï´Ù."));
-											break;
-										}
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("¹«±â¿Í °©¿Ê¿¡¸¸ »ç¿ë °¡´ÉÇÕ´Ï´Ù."));
-										break;
-									}
-								}
-
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-
-								if (number(1, 100) <= aiItemAttributeAddPercent[item2->GetAttributeCount()] || g_bNeverFailAddAttributes == true)
-								{
-									item2->AddAttribute();
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼º Ãß°¡¿¡ ¼º°øÇÏ¿´½À´Ï´Ù."));
-
-									int iAddedIdx = item2->GetAttributeCount() - 1;
-									LogManager::instance().ItemLog(
-										GetPlayerID(),
-										item2->GetAttributeType(iAddedIdx),
-										item2->GetAttributeValue(iAddedIdx),
-										item->GetID(),
-										"ADD_ATTRIBUTE_SUCCESS",
-										buf,
-										GetDesc()->GetHostName(),
-										item->GetOriginalVnum()
-									);
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼º Ãß°¡¿¡ ½ÇÆÐÇÏ¿´½À´Ï´Ù."));
-									LogManager::instance().ItemLog(this, item, "ADD_ATTRIBUTE_FAIL", buf);
-								}
-
-								if (!g_bUnlimitedAddAttributes)
-									item->SetCount(item->GetCount() - 1);
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´õÀÌ»ó ÀÌ ¾ÆÀÌÅÛÀ» ÀÌ¿ëÇÏ¿© ¼Ó¼ºÀ» Ãß°¡ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-							}
-						}
-						break;
-
-						case USE_ADD_ATTRIBUTE2:
-						{
-							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_REINFORCE))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Reinforce Item cannot be used on this item."));
-								return false;
-							}
-
-							// Ãàº¹ÀÇ ±¸½½
-							// Àç°¡ºñ¼­¸¦ ÅëÇØ ¼Ó¼ºÀ» 4°³ Ãß°¡ ½ÃÅ² ¾ÆÀÌÅÛ¿¡ ´ëÇØ¼­ ÇÏ³ªÀÇ ¼Ó¼ºÀ» ´õ ºÙ¿©ÁØ´Ù.
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-								return false;
-							}
-
-							// ¼Ó¼ºÀÌ ÀÌ¹Ì 4°³ Ãß°¡ µÇ¾úÀ» ¶§¸¸ ¼Ó¼ºÀ» Ãß°¡ °¡´ÉÇÏ´Ù.
-							if (item2->GetAttributeCount() == 4)
-							{
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-
-								if (number(1, 100) <= aiItemAttributeAddPercent[item2->GetAttributeCount()] || g_bNeverFailAddAttributes == true)
-								{
-									item2->AddAttribute();
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼º Ãß°¡¿¡ ¼º°øÇÏ¿´½À´Ï´Ù."));
-
-									int iAddedIdx = item2->GetAttributeCount() - 1;
-									LogManager::instance().ItemLog(
-										GetPlayerID(),
-										item2->GetAttributeType(iAddedIdx),
-										item2->GetAttributeValue(iAddedIdx),
-										item->GetID(),
-										"ADD_ATTRIBUTE2_SUCCESS",
-										buf,
-										GetDesc()->GetHostName(),
-										item->GetOriginalVnum()
-									);
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼º Ãß°¡¿¡ ½ÇÆÐÇÏ¿´½À´Ï´Ù."));
-									LogManager::instance().ItemLog(this, item, "ADD_ATTRIBUTE2_FAIL", buf);
-								}
-
-								if (!g_bUnlimitedAddAttributes)
-									item->SetCount(item->GetCount() - 1);
-							}
-							else if (item2->GetAttributeCount() == 5)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("´õ ÀÌ»ó ÀÌ ¾ÆÀÌÅÛÀ» ÀÌ¿ëÇÏ¿© ¼Ó¼ºÀ» Ãß°¡ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-							}
-							else if (item2->GetAttributeCount() < 4)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¸ÕÀú Àç°¡ºñ¼­¸¦ ÀÌ¿ëÇÏ¿© ¼Ó¼ºÀ» Ãß°¡½ÃÄÑ ÁÖ¼¼¿ä."));
-							}
-							else
-							{
-								// wtf ?!
-								sys_err("ADD_ATTRIBUTE2 : Item has wrong AttributeCount(%d)", item2->GetAttributeCount());
-							}
-						}
-						break;
-
-#if defined(__ATTR_6TH_7TH__)
-						case USE_CHANGE_ATTRIBUTE2:
-						{
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
-								return false;
-							}
-#endif
-
-							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_ENCHANT))
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Enchant Item cannot be used on this item."));
-								return false;
-							}
-
-							if (item2->GetAttributeSetIndex() == -1)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-								return false;
-							}
-
-							if (item2->GetRareAttrCount() == 0)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("º¯°æÇÒ ¼Ó¼ºÀÌ ¾ø½À´Ï´Ù."));
-								return false;
-							}
-
-							if (number(1, 100) <= item->GetValue(0))
-							{
-								if (item2->ChangeRareAttribute())
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÏ¿´½À´Ï´Ù."));
-									{
-										char szBuff[21];
-										snprintf(szBuff, sizeof(szBuff), "%u", item2->GetID());
-										LogManager::instance().ItemLog(this, item, "CHANGE_ATTRIBUTE2", szBuff);
-									}
-								}
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Upgrade change failed."));
-							}
-
-							item->SetCount(item->GetCount() - 1);
-						}
-						break;
-#endif
-
-						case USE_ADD_ACCESSORY_SOCKET:
-						{
-							char buf[21];
-							snprintf(buf, sizeof(buf), "%u", item2->GetID());
-
-							if (item2->IsAccessoryForSocket())
-							{
-								if (item2->GetAccessorySocketMaxGrade() < ITEM_ACCESSORY_SOCKET_MAX_NUM)
-								{
-									if (number(1, 100) <= 50 || g_bNeverFailAccessorySocket == true)
-									{
-										item2->SetAccessorySocketMaxGrade(item2->GetAccessorySocketMaxGrade() + 1);
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ÒÄÏÀÌ ¼º°øÀûÀ¸·Î Ãß°¡µÇ¾ú½À´Ï´Ù."));
-										LogManager::instance().ItemLog(this, item, "ADD_SOCKET_SUCCESS", buf);
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ÒÄÏ Ãß°¡¿¡ ½ÇÆÐÇÏ¿´½À´Ï´Ù."));
-										LogManager::instance().ItemLog(this, item, "ADD_SOCKET_FAIL", buf);
-									}
-
-									if (!g_bUnlimitedAddAccessorySocket)
-										item->SetCount(item->GetCount() - 1);
-								}
-								else
-								{
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾×¼¼¼­¸®¿¡´Â ´õÀÌ»ó ¼ÒÄÏÀ» Ãß°¡ÇÒ °ø°£ÀÌ ¾ø½À´Ï´Ù."));
-								}
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀ¸·Î ¼ÒÄÏÀ» Ãß°¡ÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-							}
-						}
-						break;
-
-						case USE_PUT_INTO_BELT_SOCKET:
-						case USE_PUT_INTO_ACCESSORY_SOCKET:
-						{
-							if (item2->IsAccessoryForSocket() && item->CanPutInto(item2))
-							{
-								char buf[21];
-								snprintf(buf, sizeof(buf), "%u", item2->GetID());
-
-								if (item2->GetAccessorySocketGrade() < item2->GetAccessorySocketMaxGrade())
-								{
-									if (number(1, 100) <= aiAccessorySocketPutPct[item2->GetAccessorySocketGrade()] || g_bNeverFailAccessory == true)
-									{
-										item2->SetAccessorySocketGrade(item2->GetAccessorySocketGrade() + 1);
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀåÂø¿¡ ¼º°øÇÏ¿´½À´Ï´Ù."));
-										LogManager::instance().ItemLog(this, item, "PUT_SOCKET_SUCCESS", buf);
-									}
-									else
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀåÂø¿¡ ½ÇÆÐÇÏ¿´½À´Ï´Ù."));
-										LogManager::instance().ItemLog(this, item, "PUT_SOCKET_FAIL", buf);
-									}
-
-									if (!g_bUnlimitedAddAccessory)
-										item->SetCount(item->GetCount() - 1);
-								}
-								else
-								{
-									if (item2->GetAccessorySocketMaxGrade() == 0)
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("¸ÕÀú ´ÙÀÌ¾Æ¸óµå·Î ¾Ç¼¼¼­¸®¿¡ ¼ÒÄÏÀ» Ãß°¡ÇØ¾ßÇÕ´Ï´Ù."));
-									else if (item2->GetAccessorySocketMaxGrade() < ITEM_ACCESSORY_SOCKET_MAX_NUM)
-									{
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾×¼¼¼­¸®¿¡´Â ´õÀÌ»ó ÀåÂøÇÒ ¼ÒÄÏÀÌ ¾ø½À´Ï´Ù."));
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("´ÙÀÌ¾Æ¸óµå·Î ¼ÒÄÏÀ» Ãß°¡ÇØ¾ßÇÕ´Ï´Ù."));
-									}
-									else
-										ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾×¼¼¼­¸®¿¡´Â ´õÀÌ»ó º¸¼®À» ÀåÂøÇÒ ¼ö ¾ø½À´Ï´Ù."));
-								}
-							}
-							else
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀ» ÀåÂøÇÒ ¼ö ¾ø½À´Ï´Ù."));
-							}
-						}
-						break;
-
-#if defined(__MOVE_COSTUME_ATTR__)
-						case USE_RESET_COSTUME_ATTR:
-						case USE_CHANGE_COSTUME_ATTR:
-						{
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
-								return false;
-							}
-#endif
-
-							if (!item2->CanChangeCostumeAttr())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-								return false;
-							}
-
-							// NOTE: Prevent changing costumes without bonus.
-							if (item2->GetAttributeCount() == 0)
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-								return false;
-							}
-
-							switch (item->GetSubType())
-							{
-								case USE_RESET_COSTUME_ATTR:
-								{
-									item2->ClearAttribute();
-									item2->AlterToMagicItem();
-
-									char buf[21];
-									snprintf(buf, sizeof(buf), "%u", item2->GetID());
-									LogManager::instance().ItemLog(this, item, "RESET_COSTUME_ATTR", buf);
-
-									if (!g_bUnlimitedResetCostumeAttributes)
-										item->SetCount(item->GetCount() - 1);
-
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÏ¿´½À´Ï´Ù."));
-								}
-								break;
-
-								case USE_CHANGE_COSTUME_ATTR:
-								{
-									item2->ChangeAttribute();
-
-									char buf[21];
-									snprintf(buf, sizeof(buf), "%u", item2->GetID());
-									LogManager::instance().ItemLog(this, item, "CHANGE_COSTUME_ATTR", buf);
-
-									if (!g_bUnlimitedChangeCostumeAttributes)
-										item->SetCount(item->GetCount() - 1);
-
-									ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÏ¿´½À´Ï´Ù."));
-								}
-								break;
-							}
-						}
-						break;
-#endif
-
-#if defined(__CHANGED_ATTR__)
-						case USE_SELECT_ATTRIBUTE:
-						{
-#if defined(__SOUL_BIND_SYSTEM__)
-							if (item2->IsSealed())
-							{
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
-								return false;
-							}
-#endif
-							SelectAttr(item, item2);
-						}
-						break;
-#endif
-					}
-
-					if (item2->IsEquipped())
-					{
-						BuffOnAttr_AddBuffsFromItem(item2);
-					}
-				}
-				break;
-				// END_OF_ACCESSORY_REFINE & END_OF_ADD_ATTRIBUTES & END_OF_CHANGE_ATTRIBUTES
-
-				case USE_CALL:
-					AggregateMonster();
-					if (!g_bUnlimitedCapeOfCourage)
-						item->SetCount(item->GetCount() - 1);
-					break;
-
-				case USE_BAIT:
-				{
-					if (m_pkFishingEvent)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("³¬½Ã Áß¿¡ ¹Ì³¢¸¦ °¥¾Æ³¢¿ï ¼ö ¾ø½À´Ï´Ù."));
-						return false;
-					}
-
-					LPITEM weapon = GetWear(WEAR_WEAPON);
-
-					if (!weapon || weapon->GetType() != ITEM_ROD)
-						return false;
-
-					if (weapon->GetSocket(2))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì ²ÈÇôÀÖ´ø ¹Ì³¢¸¦ »©°í %s¸¦ ³¢¿ó´Ï´Ù.", LC_ITEM(item->GetVnum())));
-					}
-					else
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("³¬½Ã´ë¿¡ %s¸¦ ¹Ì³¢·Î ³¢¿ó´Ï´Ù.", LC_ITEM(item->GetVnum())));
-					}
-
-					weapon->SetSocket(2, item->GetValue(0));
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				case USE_MOVE:
-				case USE_TREASURE_BOX:
-				case USE_MONEYBAG:
-					break;
-
-				case USE_AFFECT:
-				{
-#if defined(__FLOWER_EVENT__)
-					if (item->GetValue(0) == AFFECT_FLOWER_EVENT)
-						return CFlowerEvent::UseFlower(this, item);
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-					if (item->GetValue(0) == AFFECT_LATE_SUMMER_EVENT_BUFF)
-					{
-						if (FindAffect(item->GetValue(0)) || FindAffect(AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF))
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("This effect is already activated."));
-							return false;
-						}
-
-						AddAffect(item->GetValue(0), POINT_NONE, 0, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
-						item->SetCount(item->GetCount() - 1);
-						return true;
-					}
-					else if (item->GetValue(0) == AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF)
-					{
-						if (FindAffect(item->GetValue(0)) || FindAffect(AFFECT_LATE_SUMMER_EVENT_BUFF))
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("This effect is already activated."));
-							return false;
-						}
-
-						AddAffect(item->GetValue(0), POINT_NONE, 0, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
-						item->SetCount(item->GetCount() - 1);
-						return true;
-					}
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__) && defined(__PREMIUM_LOOT_FILTER__)
-					if (item->GetValue(0) == AFFECT_LOOTING_SYSTEM)
-					{
-						CAffect* pAffect = FindAffect(AFFECT_LOOTING_SYSTEM);
-						long lDuration = item->GetValue(3);
-
-						if (pAffect)
-						{
-							if (lDuration > 0)
-							{
-								if (pAffect->lDuration > LONG_MAX - lDuration)
-								{
-									sys_err("LOOT_FILTER_SYSTEM: Duration overflow, affect duration (%ld), item value3 (%ld)",
-										pAffect->lDuration, lDuration);
-									return false;
-								}
-							}
-							else
-							{
-								sys_err("LOOT_FILTER_SYSTEM: Item duration value3 (%ld) is not positive.", lDuration);
-								return false;
-							}
-
-							pAffect->bUpdate = true;
-							pAffect->lApplyValue += lDuration;
-
-							ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("Loot filter duration extended."));
-						}
-						else
-						{
-#if defined(__AFFECT_RENEWAL__)
-							AddRealTimeAffect(AFFECT_LOOTING_SYSTEM, POINT_NONE, 0, AFF_NONE, lDuration, 0, false, false);
-#else
-							AddAffect(AFFECT_LOOTING_SYSTEM, POINT_NONE, 0, AFF_NONE, lDuration, 0, false, false);
-#endif
-							ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("Loot filter activated."));
-						}
-
-						item->SetCount(item->GetCount() - 1);
-						return true;
-					}
-#endif
-
-					if (FindAffect(item->GetValue(0), aApplyInfo[item->GetValue(1)].wPointType))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-					}
-					else
-					{
-						AddAffect(item->GetValue(0), aApplyInfo[item->GetValue(1)].wPointType, item->GetValue(2), 0, item->GetValue(3), 0, false);
-						item->SetCount(item->GetCount() - 1);
-					}
-				}
-				break;
-
-				case USE_CREATE_STONE:
-				{
-					AutoGiveItem(number(28000, 28012));
-					item->SetCount(item->GetCount() - 1);
-				}
-				break;
-
-				// ¹°¾à Á¦Á¶ ½ºÅ³¿ë ·¹½ÃÇÇ Ã³¸®
-				case USE_RECIPE:
-				{
-					LPITEM pSource1 = FindSpecifyItem(item->GetValue(1));
-					DWORD dwSourceCount1 = item->GetValue(2);
-
-					LPITEM pSource2 = FindSpecifyItem(item->GetValue(3));
-					DWORD dwSourceCount2 = item->GetValue(4);
-
-					if (dwSourceCount1 != 0)
-					{
-						if (pSource1 == NULL)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("¹°¾à Á¶ÇÕÀ» À§ÇÑ Àç·á°¡ ºÎÁ·ÇÕ´Ï´Ù."));
-							return false;
-						}
-					}
-
-					if (dwSourceCount2 != 0)
-					{
-						if (pSource2 == NULL)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("¹°¾à Á¶ÇÕÀ» À§ÇÑ Àç·á°¡ ºÎÁ·ÇÕ´Ï´Ù."));
-							return false;
-						}
-					}
-
-					if (pSource1 != NULL)
-					{
-						if (pSource1->GetCount() < dwSourceCount1)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("Àç·á(%s)°¡ ºÎÁ·ÇÕ´Ï´Ù.", LC_ITEM(pSource1->GetVnum())));
-							return false;
-						}
-
-						pSource1->SetCount(pSource1->GetCount() - dwSourceCount1);
-					}
-
-					if (pSource2 != NULL)
-					{
-						if (pSource2->GetCount() < dwSourceCount2)
-						{
-							ChatPacket(CHAT_TYPE_INFO, LC_STRING("Àç·á(%s)°¡ ºÎÁ·ÇÕ´Ï´Ù.", LC_ITEM(pSource2->GetVnum())));
-							return false;
-						}
-
-						pSource2->SetCount(pSource2->GetCount() - dwSourceCount2);
-					}
-
-					LPITEM pBottle = FindSpecifyItem(50901);
-
-					if (!pBottle || pBottle->GetCount() < 1)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("ºó º´ÀÌ ¸ðÀÚ¸¨´Ï´Ù."));
-						return false;
-					}
-
-					pBottle->SetCount(pBottle->GetCount() - 1);
-
-					if (number(1, 100) > item->GetValue(5))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("¹°¾à Á¦Á¶¿¡ ½ÇÆÐÇß½À´Ï´Ù."));
-						return false;
-					}
-
-					AutoGiveItem(item->GetValue(0));
-				}
-				break;
-			}
-		}
-		break;
-
-		case ITEM_METIN:
-		{
-			LPITEM item2;
-
-			if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
-				return false;
-
-			if (item2->IsExchanging())
-				return false;
-
-			if (item2->IsEquipped())
-				return false;
-
-			if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_APPLY))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("This Spirit Stone cannot be attached to this type of item."));
-				return false;
-			}
-
-			if (item2->GetType() == ITEM_PICK)
-				return false;
-
-			if (item2->GetType() == ITEM_ROD)
-				return false;
-
-			int i;
-
-			for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-			{
-				DWORD dwVnum;
-
-				if ((dwVnum = item2->GetSocket(i)) <= 2)
-					continue;
-
-				const TItemTable* p = ITEM_MANAGER::instance().GetTable(dwVnum);
-
-				if (!p)
-					continue;
-
-				if (item->GetValue(5) == p->alValues[5]
-#if defined(__GLOVE_SYSTEM__)
-					&& item->GetSubType() != METIN_SUNGMA
-#endif
-					)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("°°Àº Á¾·ùÀÇ ¸ÞÆ¾¼®Àº ¿©·¯°³ ºÎÂøÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-			}
-
-			if (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY)
-			{
-				if (!IS_SET(item->GetWearFlag(), WEARABLE_BODY) || !IS_SET(item2->GetWearFlag(), WEARABLE_BODY))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¸ÞÆ¾¼®Àº Àåºñ¿¡ ºÎÂøÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-			}
-#if defined(__GLOVE_SYSTEM__)
-			else if (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_GLOVE)
-			{
-				if (!IS_SET(item->GetWearFlag(), WEARABLE_GLOVE) || !IS_SET(item2->GetWearFlag(), WEARABLE_GLOVE))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¸ÞÆ¾¼®Àº Àåºñ¿¡ ºÎÂøÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-			}
-#endif
-			else if (item2->GetType() == ITEM_WEAPON)
-			{
-				if (!IS_SET(item->GetWearFlag(), WEARABLE_WEAPON))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¸ÞÆ¾¼®Àº ¹«±â¿¡ ºÎÂøÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-			}
-			else
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("ºÎÂøÇÒ ¼ö ÀÖ´Â ½½·ÔÀÌ ¾ø½À´Ï´Ù."));
-				return false;
-			}
-
-			for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
-			{
-				if (item2->GetSocket(i) >= 1 && item2->GetSocket(i) <= 2 && item2->GetSocket(i) >= item->GetValue(2))
-				{
-					// ¼® È®·ü
-					if (number(1, 100) <= 30 || g_bNeverFailMetin == true)
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("¸ÞÆ¾¼® ºÎÂø¿¡ ¼º°øÇÏ¿´½À´Ï´Ù."));
-
-#if defined(__GLOVE_SYSTEM__)
-						DWORD dwValue = item->GetVnum();
-						if (item->GetSubType() == METIN_SUNGMA)
-						{
-							bool bMultiplier = false;
-							if (item->GetValue(5) == 2 && number(1, 100) <= 30)
-							{
-								bMultiplier = true;
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Perfect! You have attached the Spirit Stone successfully and you even receive a double stat bonus."));
-							}
-							dwValue = item2->GetRandomSungMaSocketValue(item->GetValue(5), item->GetRefineLevel(), bMultiplier);
-						}
-						item2->SetSocket(i, dwValue);
-#else
-						item2->SetSocket(i, item->GetVnum());
-#endif
-					}
-					else
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("¸ÞÆ¾¼® ºÎÂø¿¡ ½ÇÆÐÇÏ¿´½À´Ï´Ù."));
-						item2->SetSocket(i, ITEM_BROKEN_METIN_VNUM);
-					}
-
-					LogManager::instance().ItemLog(this, item2, "SOCKET", item->GetName());
-					item->SetCount(item->GetCount() - 1);
-					break;
-				}
-			}
-
-			if (i == METIN_SOCKET_MAX_NUM)
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("ºÎÂøÇÒ ¼ö ÀÖ´Â ½½·ÔÀÌ ¾ø½À´Ï´Ù."));
-		}
-		break;
-
-		case ITEM_AUTOUSE:
-		case ITEM_MATERIAL:
-		case ITEM_SPECIAL:
-		case ITEM_TOOL:
-		case ITEM_LOTTERY:
-			break;
-
-		case ITEM_TOTEM:
-		{
-			if (!item->IsEquipped())
-				EquipItem(item);
-		}
-		break;
-
-		case ITEM_BLEND:
-		{
-			// »õ·Î¿î ¾àÃÊµé
-			sys_log(0, "ITEM_BLEND!!");
-
-			if (Blend_Item_find(item->GetVnum()))
-			{
-				int affect_type = AFFECT_BLEND;
-				int apply_type = aApplyInfo[item->GetSocket(0)].wPointType;
-				int apply_value = item->GetSocket(1);
-				int apply_duration = item->GetSocket(2);
-
-				if (FindAffect(affect_type, apply_type))
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-				}
-				else
-				{
-					if (FindAffect(AFFECT_EXP_BONUS_EURO_FREE, POINT_RESIST_MAGIC))
-					{
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì È¿°ú°¡ °É·Á ÀÖ½À´Ï´Ù."));
-					}
-					else
-					{
-						AddAffect(affect_type, apply_type, apply_value, 0, apply_duration, 0, false);
-						item->SetCount(item->GetCount() - 1);
-					}
-				}
-			}
-		}
-		break;
-
-		case ITEM_EXTRACT:
-		{
-			LPITEM pDestItem = GetItem(DestCell);
-			if (NULL == pDestItem)
-				return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-			if (item->IsSealed())
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
-				return false;
-			}
-#endif
-
-			switch (item->GetSubType())
-			{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-				case EXTRACT_DRAGON_SOUL:
-				{
-					if (pDestItem->IsDragonSoul())
-						return DSManager::instance().PullOut(this, NPOS, pDestItem, item);
-					return false;
-				}
-				case EXTRACT_DRAGON_HEART:
-				{
-					if (pDestItem->IsDragonSoul())
-						return DSManager::instance().ExtractDragonHeart(this, pDestItem, item);
-					return false;
-				}
-#endif
-				default:
-					return false;
-			}
-		}
-		break;
-
-#if defined(__GACHA_SYSTEM__)
-		case ITEM_GACHA:
-		{
-			switch (item->GetSubType())
-			{
-				case USE_GACHA:
-				{
-					if (GiveItemFromSpecialItemGroup(item->GetVnum()))
-					{
-						if (item->GetSocket(0) > 1)
-							item->SetSocket(0, item->GetSocket(0) - 1);
-						else
-							ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (ITEM_GACHA)");
-					}
-				}
-				break;
-
-#if defined(__LUCKY_BOX__)
-				case GEM_LUCKY_BOX_GACHA:
-				case SPECIAL_LUCKY_BOX_GACHA:
-					SetLuckyBoxSrcItem(item);
-					break;
-#endif
-			}
-		}
-		break;
-#endif
-
-#if defined(__SOUL_SYSTEM__)
-		case ITEM_SOUL:
-		{
-			struct SoulData
-			{
-				WORD point_type;
-				DWORD affect_flag;
-			};
-			std::unordered_map<BYTE, SoulData> soul_map
-			{
-				{ RED_SOUL, { AFF_SOUL_RED, AFF_SOUL_RED }, },
-				{ BLUE_SOUL, { AFF_SOUL_BLUE, AFF_SOUL_BLUE }, },
-			};
-
-			const auto& it = soul_map.find(item->GetSubType());
-			if (it == soul_map.end())
-			{
-				sys_err("ITEM_SOUL: Unknown SubType");
-				return false;
-			}
-
-			const auto& soul = it->second;
-
-			CAffect* affect = nullptr;
-			for (auto const& it : GetAffectContainer())
-			{
-				if (it != nullptr && it->dwType == AFFECT_SOUL)
-				{
-					if (it->wApplyOn == soul.point_type)
-					{
-						if (item->GetSocket(1) != TRUE)
-						{
-							ChatPacket(CHAT_TYPE_INFO, "The soul color is already beeing used.");
-							return false;
-						}
-					}
-
-					affect = it;
-					continue;
-				}
-			}
-
-			if (item->GetSocket(1) != TRUE)
-			{
-				AddAffect(AFFECT_SOUL, soul.point_type, item->GetID(), affect ? AFF_NONE : soul.affect_flag, item->GetSocket(0), 0, false/*override*/);
-
-				if (affect)
-				{
-					std::vector<CAffect> tmp_affects;
-					std::vector<CAffect*> to_remove;
-					for (const auto& [k, v] : soul_map)
-					{
-						CAffect* affect = FindAffect(AFFECT_SOUL, v.point_type);
-						if (affect)
-						{
-							tmp_affects.emplace_back(*affect);
-							to_remove.emplace_back(affect);
-						}
-					}
-
-					if (!to_remove.empty())
-					{
-						for (const auto& it : to_remove)
-							RemoveAffect(it);
-					}
-
-					if (!tmp_affects.empty())
-					{
-						for (const auto& it : tmp_affects)
-							AddAffect(it.dwType, it.wApplyOn, it.lApplyValue, AFF_NONE, it.lDuration, 0, false/*override*/);
-					}
-
-					AddAffect(AFFECT_SOUL, AFF_SOUL_MIX, 0, AFF_SOUL_MIX, item->GetSocket(0), 0, false/*override*/);
-				}
-
-				item->SetSocket(1, TRUE);
-				item->Lock(true);
-			}
-			else
-			{
-				RemoveAffect(AFFECT_SOUL, soul.point_type);
-				RemoveAffect(AFFECT_SOUL, AFF_SOUL_MIX); // AFF_SOUL_MIX
-
-				std::vector<CAffect> tmp_affects;
-				std::vector<CAffect*> to_remove;
-				for (const auto& affect : GetAffectContainer())
-				{
-					if (affect != nullptr && affect->dwType == AFFECT_SOUL)
-					{
-						tmp_affects.emplace_back(*affect);
-						to_remove.emplace_back(affect);
-					}
-				}
-
-				for (const auto& affect : to_remove)
-					RemoveAffect(affect);
-
-				if (!tmp_affects.empty())
-				{
-					for (const auto& affect : tmp_affects)
-					{
-						auto it = std::find_if(soul_map.begin(), soul_map.end(), [&](const auto& kv_pair) {
-							return kv_pair.second.point_type == affect.wApplyOn;
-							});
-
-						if (it != soul_map.end())
-							AddAffect(affect.dwType, affect.wApplyOn, affect.lApplyValue, it->second.affect_flag, affect.lDuration, 0, false/*override*/);
-					}
-				}
-
-				item->SetSocket(1, FALSE);
-				item->Lock(false);
-			}
-		}
-		break;
-#endif
-
-		case ITEM_NONE:
-			sys_err("Item type NONE %s", item->GetName());
-			break;
-
-		default:
-			sys_log(0, "UseItemEx: Unknown type %s %d", item->GetName(), item->GetType());
-			return false;
-	}
-
-	return true;
-}
-
-int g_nPortalLimitTime = 10;
-
-bool CHARACTER::UseItem(TItemPos Cell, TItemPos DestCell)
-{
-	WORD wCell = Cell.cell;
-	BYTE window_type = Cell.window_type;
-
-	//WORD wDestCell = DestCell.cell;
-	//BYTE bDestInven = DestCell.window_type;
-
-	LPITEM item;
-
-	if (!CanHandleItem())
-		return false;
-
-	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
-		return false;
-
-	// We don't want to use it if we are dragging it over another item of the same type...
-	LPITEM destItem = GetItem(DestCell);
-	if (destItem && item != destItem && destItem->IsStackable() && !IS_SET(destItem->GetAntiFlag(), ITEM_ANTIFLAG_STACK) && destItem->GetVnum() == item->GetVnum())
-	{
-		if (MoveItem(Cell, DestCell, 0))
-			return false;
-	}
-
-	sys_log(0, "%s: USE_ITEM %s (inven %d, cell: %d)", GetName(), item->GetName(), window_type, wCell);
-
-	if (item->IsExchanging())
-		return false;
-
-	if (!item->CanUsedBy(this))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("±ºÁ÷ÀÌ ¸ÂÁö¾Ê¾Æ ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	if (IsStun())
-		return false;
-
-	if (false == FN_check_item_sex(this, item))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ºº°ÀÌ ¸ÂÁö¾Ê¾Æ ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use items while modifying your pet's stats."));
-		return false;
-	}
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum = item->GetTransmutationVnum();
-	if (dwTransmutationVnum != 0)
-	{
-		TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwTransmutationVnum);
-
-		if (!pItemTable->CanUseByJob(GetJob()))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your class."));
-			return false;
-		}
-
-#	if defined(__COSTUME_SYSTEM__)
-		if (pItemTable && pItemTable->IsCostume())
-		{
-			if ((IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_MALE) && SEX_MALE == GET_SEX(this)) ||
-				(IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_FEMALE) && SEX_FEMALE == GET_SEX(this)))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your gender."));
-				return false;
-			}
-		}
-	}
-#	endif
-#endif
-
-	// PREVENT_TRADE_WINDOW
-	if (IS_SUMMON_ITEM(item, GetMapIndex()))
-	{
-		if (false == IS_SUMMONABLE_ZONE(GetMapIndex()))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item here."));
-			return false;
-		}
-
-		// °æÈ¥¹ÝÁö »ç¿ëÁö »ó´ë¹æÀÌ SUMMONABLE_ZONE¿¡ ÀÖ´Â°¡´Â WarpToPC()¿¡¼­ Ã¼Å©
-
-		// »ï°Å¸® °ü·Á ¸Ê¿¡¼­´Â ±ÍÈ¯ºÎ¸¦ ¸·¾Æ¹ö¸°´Ù.
-		if (CThreeWayWar::instance().IsThreeWayWarMapIndex(GetMapIndex()))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("»ï°Å¸® ÀüÅõ Âü°¡Áß¿¡´Â ±ÍÈ¯ºÎ,±ÍÈ¯±â¾ïºÎ¸¦ »ç¿ëÇÒ¼ö ¾ø½À´Ï´Ù."));
-			return false;
-		}
-
-		int iPulse = thecore_pulse();
-
-		// Ã¢°í ¿¬ÈÄ Ã¼Å©
-		if (iPulse - GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¢°í¸¦ ¿¬ÈÄ %dÃÊ ÀÌ³»¿¡´Â ±ÍÈ¯ºÎ,±ÍÈ¯±â¾ïºÎ¸¦ »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù.", g_nPortalLimitTime));
-
-			if (test_server)
-				ChatPacket(CHAT_TYPE_INFO, "[TestOnly]Pulse %d LoadTime %d PASS %d", iPulse, GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
-			return false;
-		}
-
-		// °Å·¡°ü·Ã Ã¢ Ã¼Å©
-		if (PreventTradeWindow(WND_ALL))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("°Å·¡Ã¢,Ã¢°í µîÀ» ¿¬ »óÅÂ¿¡¼­´Â ±ÍÈ¯ºÎ,±ÍÈ¯±â¾ïºÎ ¸¦ »ç¿ëÇÒ¼ö ¾ø½À´Ï´Ù."));
-			return false;
-		}
-
-		// PREVENT_REFINE_HACK
-		// °³·®ÈÄ ½Ã°£Ã¼Å©
-		{
-			if (iPulse - GetRefineTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ °³·®ÈÄ %dÃÊ ÀÌ³»¿¡´Â ±ÍÈ¯ºÎ,±ÍÈ¯±â¾ïºÎ¸¦ »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù.", g_nPortalLimitTime));
-				return false;
-			}
-		}
-		// END_PREVENT_REFINE_HACK
-
-		// PREVENT_ITEM_COPY
-		{
-			if (iPulse - GetMyShopTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("°³ÀÎ»óÁ¡ »ç¿ëÈÄ %dÃÊ ÀÌ³»¿¡´Â ±ÍÈ¯ºÎ,±ÍÈ¯±â¾ïºÎ¸¦ »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù.", g_nPortalLimitTime));
-				return false;
-			}
-
-#if defined(__MAILBOX__)
-			if (iPulse - GetMyMailBoxTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-			{
-				ChatPacket(CHAT_TYPE_INFO, "You cannot use a Return Scroll %d seconds after opening a mailbox.", g_nPortalLimitTime);
-				return false;
-			}
-#endif
-		}
-		// END_PREVENT_ITEM_COPY
-
-		// ±ÍÈ¯ºÎ °Å¸®Ã¼Å©
-		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TALISMAN)
-		{
-			PIXEL_POSITION posWarp;
-
-			int x = 0;
-			int y = 0;
-
-			double nDist = 0;
-			const double nDistant = 5000.0;
-
-			// ±ÍÈ¯±â¾ïºÎ
-			if (item->GetVnum() == 22010)
-			{
-				x = item->GetSocket(0) - GetX();
-				y = item->GetSocket(1) - GetY();
-			}
-			// ±ÍÈ¯ºÎ
-			else if (item->GetVnum() == 22000)
-			{
-				SECTREE_MANAGER::instance().GetRecallPositionByEmpire(GetMapIndex(), GetEmpire(), posWarp);
-
-				if (item->GetSocket(0) == 0)
-				{
-					x = posWarp.x - GetX();
-					y = posWarp.y - GetY();
-				}
-				else
-				{
-					x = item->GetSocket(0) - GetX();
-					y = item->GetSocket(1) - GetY();
-				}
-			}
-
-			nDist = sqrt(pow((float)x, 2) + pow((float)y, 2));
-
-			if (nDistant > nDist)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌµ¿ µÇ¾îÁú À§Ä¡¿Í ³Ê¹« °¡±î¿ö ±ÍÈ¯ºÎ¸¦ »ç¿ëÇÒ¼ö ¾ø½À´Ï´Ù."));
-				if (test_server)
-					ChatPacket(CHAT_TYPE_INFO, "PossibleDistant %f nNowDist %f", nDistant, nDist);
-				return false;
-			}
-		}
-
-		// PREVENT_PORTAL_AFTER_EXCHANGE
-		// ±³È¯ ÈÄ ½Ã°£Ã¼Å©
-		if (iPulse - GetExchangeTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("°Å·¡ ÈÄ %dÃÊ ÀÌ³»¿¡´Â ±ÍÈ¯ºÎ,±ÍÈ¯±â¾ïºÎµîÀ» »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù.", g_nPortalLimitTime));
-			return false;
-		}
-		// END_PREVENT_PORTAL_AFTER_EXCHANGE
-	}
-
-	// º¸µû¸® ºñ´Ü »ç¿ë½Ã °Å·¡Ã¢ Á¦ÇÑ Ã¼Å©
-	if ((item->GetVnum() == 50200) || (item->GetVnum() == 71049))
-	{
-		if (PreventTradeWindow(WND_ALL))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("°Å·¡Ã¢,Ã¢°í µîÀ» ¿¬ »óÅÂ¿¡¼­´Â º¸µû¸®,ºñ´Üº¸µû¸®¸¦ »ç¿ëÇÒ¼ö ¾ø½À´Ï´Ù."));
-			return false;
-		}
-	}
-	// END_PREVENT_TRADE_WINDOW
-
-	if (IsRunningQuest())
-		return false;
-
-	if (IS_SET(item->GetFlag(), ITEM_FLAG_LOG)) // »ç¿ë ·Î±×¸¦ ³²±â´Â ¾ÆÀÌÅÛ Ã³¸®
-	{
-		DWORD vid = item->GetVID();
-		DWORD oldCount = item->GetCount();
-		DWORD vnum = item->GetVnum();
-
-		char hint[ITEM_NAME_MAX_LEN + 32 + 1];
-		int len = snprintf(hint, sizeof(hint) - 32, "%s", item->GetName());
-
-		if (len < 0 || len >= (int)sizeof(hint) - 32)
-			len = (sizeof(hint) - 32) - 1;
-
-		bool ret = UseItemEx(item, DestCell);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		if (ret and item->GetType() == ITEM_USE or ret and item->GetType() == ITEM_SKILLBOOK or ret and item->GetType() == ITEM_GIFTBOX)
-			UpdateExtBattlePassMissionProgress(BP_ITEM_USE, 1, item->GetVnum());
-#endif
-
-		if (NULL == ITEM_MANAGER::instance().FindByVID(vid)) // UseItemEx¿¡¼­ ¾ÆÀÌÅÛÀÌ »èÁ¦ µÇ¾ú´Ù. »èÁ¦ ·Î±×¸¦ ³²±è
-		{
-			LogManager::instance().ItemLog(this, vid, vnum, "REMOVE", hint);
-		}
-		else if (oldCount != item->GetCount())
-		{
-			snprintf(hint + len, sizeof(hint) - len, " %u", oldCount - 1);
-			LogManager::instance().ItemLog(this, vid, vnum, "USE_ITEM", hint);
-		}
-		return (ret);
-	}
-	else
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	{
-		bool ret = UseItemEx(item, DestCell);
-
-		if (ret and item->GetType() == ITEM_USE or ret and item->GetType() == ITEM_SKILLBOOK or ret and item->GetType() == ITEM_GIFTBOX)
-			UpdateExtBattlePassMissionProgress(BP_ITEM_USE, 1, item->GetVnum());
-		
-		return (ret);
-	}
-#else
-		return UseItemEx(item, DestCell);
-#endif
-}
-
-bool CHARACTER::DropItem(TItemPos Cell, WORD wCount)
-{
-	LPITEM item = NULL;
-
-	if (!CanHandleItem())
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (NULL != DragonSoul_RefineWindow_GetOpener())
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("°­È­Ã¢À» ¿¬ »óÅÂ¿¡¼­´Â ¾ÆÀÌÅÛÀ» ¿Å±æ ¼ö ¾ø½À´Ï´Ù."));
-#endif
-		return false;
-	}
-
-	if (IsDead())
-		return false;
-
-	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
-		return false;
-
-	if (item->IsExchanging())
-		return false;
-
-	if (true == item->isLocked())
-		return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (item->IsSealed())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot drop a soulbound item."));
-		return false;
-	}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot drop items while modifying your pet's stats."));
-		return false;
-	}
-#endif
-
-	if (IsRunningQuest())
-		return false;
-
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DROP | ITEM_ANTIFLAG_GIVE))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("¹ö¸± ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-		return false;
-	}
-
-	if (wCount == 0 || wCount > item->GetCount())
-		wCount = item->GetCount();
-
-	// Quickslot ¿¡¼­ Áö¿ò
-	if (INVENTORY == Cell.window_type)
-		SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, WORD_MAX);
-	else if (BELT_INVENTORY == Cell.window_type)
-		SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, WORD_MAX);
-
-	LPITEM pkItemToDrop;
-
-	if (wCount == item->GetCount())
-	{
-		item->RemoveFromCharacter();
-		pkItemToDrop = item;
-	}
-	else
-	{
-		if (wCount == 0)
-		{
-			if (test_server)
-				sys_log(0, "[DROP_ITEM] drop item count == 0");
-			return false;
-		}
-
-		item->SetCount(item->GetCount() - wCount);
-		ITEM_MANAGER::instance().FlushDelayedSave(item);
-
-		pkItemToDrop = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), wCount);
-
-		// Copy item socket -- by mhh
-		FN_copy_item_socket(pkItemToDrop, item);
-
-		char szBuf[51 + 1];
-		snprintf(szBuf, sizeof(szBuf), "%u %u", pkItemToDrop->GetID(), pkItemToDrop->GetCount());
-		LogManager::instance().ItemLog(this, item, "ITEM_SPLIT", szBuf);
-	}
-
-	PIXEL_POSITION pxPos = GetXYZ();
-
-	if (pkItemToDrop->AddToGround(GetMapIndex(), pxPos))
-	{
-		// ÇÑ±¹¿¡´Â ¾ÆÀÌÅÛÀ» ¹ö¸®°í º¹±¸ÇØ´Þ¶ó´Â Áø»óÀ¯ÀúµéÀÌ ¸¹¾Æ¼­
-		// ¾ÆÀÌÅÛÀ» ¹Ù´Ú¿¡ ¹ö¸± ½Ã ¼Ó¼º·Î±×¸¦ ³²±ä´Ù.
-		if (LC_IsYMIR())
-			item->AttrLog();
-
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("¶³¾îÁø ¾ÆÀÌÅÛÀº 3ºÐ ÈÄ »ç¶óÁý´Ï´Ù."));
-		pkItemToDrop->StartDestroyEvent();
-
-		ITEM_MANAGER::instance().FlushDelayedSave(pkItemToDrop);
-
-		char szHint[32 + 1];
-		snprintf(szHint, sizeof(szHint), "%s %u %u", pkItemToDrop->GetName(), pkItemToDrop->GetCount(), pkItemToDrop->GetOriginalVnum());
-		LogManager::instance().ItemLog(this, pkItemToDrop, "DROP", szHint);
-		//Motion(MOTION_PICKUP);
-	}
-
-	return true;
-}
-
-#if defined(__NEW_DROP_DIALOG__)
-bool CHARACTER::DestroyItem(TItemPos Cell)
-{
-	LPITEM item = NULL;
-
-	if (!CanHandleItem())
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (NULL != DragonSoul_RefineWindow_GetOpener())
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("°­È­Ã¢À» ¿¬ »óÅÂ¿¡¼­´Â ¾ÆÀÌÅÛÀ» ¿Å±æ ¼ö ¾ø½À´Ï´Ù."));
-#endif
-		return false;
-	}
-
-	if (IsDead())
-		return false;
-
-	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
-		return false;
-
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DESTROY))
-		return false;
-
-	if (item->IsExchanging())
-		return false;
-
-	if (true == item->isLocked())
-		return false;
-
-	if (IsRunningQuest())
-		return false;
-
-	if (item->GetCount() <= 0)
-		return false;
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	UpdateExtBattlePassMissionProgress(BP_ITEM_DESTROY, 1, item->GetVnum());
-#endif
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (item->IsSealed())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot destroy a soulbound item."));
-		return false;
-	}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (item->IsPet())
-		return false;
-#endif
-
-	if (INVENTORY == Cell.window_type)
-		SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, WORD_MAX);
-	else if (BELT_INVENTORY == Cell.window_type)
-		SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, WORD_MAX);
-
-	ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have deleted %s.", LC_ITEM(item->GetVnum())));
-	ITEM_MANAGER::instance().RemoveItem(item, "DESTROYED BY PLAYER");
-
-	return true;
-}
-#endif
-
-bool CHARACTER::DropGold(int iAmount)
-{
-	if (iAmount <= 0 || iAmount > GetGold())
-		return false;
-
-	if (!CanHandleItem())
-		return false;
-
-	if (0 != g_GoldDropTimeLimitValue)
-	{
-		if (get_dword_time() < m_dwLastGoldDropTime + g_GoldDropTimeLimitValue)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÁ÷ °ñµå¸¦ ¹ö¸± ¼ö ¾ø½À´Ï´Ù."));
-			return false;
-		}
-	}
-
-	m_dwLastGoldDropTime = get_dword_time();
-
-	LPITEM item = ITEM_MANAGER::instance().CreateItem(1, iAmount);
-
-	if (item)
-	{
-		PIXEL_POSITION pos = GetXYZ();
-
-		if (item->AddToGround(GetMapIndex(), pos))
-		{
-			//Motion(MOTION_PICKUP);
-			PointChange(POINT_GOLD, -iAmount, true);
-
-			// ºê¶óÁú¿¡ µ·ÀÌ ¾ø¾îÁø´Ù´Â ¹ö±×°¡ ÀÖ´Âµ¥,
-			// °¡´ÉÇÑ ½Ã³ª¸®¿À Áß¿¡ ÇÏ³ª´Â,
-			// ¸ÞÅ©·Î³ª, ÇÙÀ» ½á¼­ 1000¿ø ÀÌÇÏÀÇ µ·À» °è¼Ó ¹ö·Á °ñµå¸¦ 0À¸·Î ¸¸µé°í,
-			// µ·ÀÌ ¾ø¾îÁ³´Ù°í º¹±¸ ½ÅÃ»ÇÏ´Â °ÍÀÏ ¼öµµ ÀÖ´Ù.
-			// µû¶ó¼­ ±×·± °æ¿ì¸¦ Àâ±â À§ÇØ ³·Àº ¼öÄ¡ÀÇ °ñµå¿¡ ´ëÇØ¼­µµ ·Î±×¸¦ ³²±è.
-			if (LC_IsBrazil() == true)
-			{
-				if (iAmount >= 213)
-					LogManager::instance().CharLog(this, iAmount, "DROP_GOLD", "");
-			}
-			else
-			{
-				if (iAmount > 1000) // Ãµ¿ø ÀÌ»ó¸¸ ±â·ÏÇÑ´Ù.
-					LogManager::instance().CharLog(this, iAmount, "DROP_GOLD", "");
-			}
-
-			if (false == LC_IsBrazil())
-			{
-				item->StartDestroyEvent(150);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¶³¾îÁø ¾ÆÀÌÅÛÀº %dºÐ ÈÄ »ç¶óÁý´Ï´Ù.", 150 / 60));
-			}
-			else
-			{
-				item->StartDestroyEvent(60);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¶³¾îÁø ¾ÆÀÌÅÛÀº %dºÐ ÈÄ »ç¶óÁý´Ï´Ù.", 1));
-			}
-		}
-
-		Save();
-		return true;
-	}
-
-	return false;
-}
-
-#if defined(__CHEQUE_SYSTEM__)
-bool CHARACTER::DropCheque(int cheque)
-{
-	if (cheque <= 0 || (long long)cheque > GetCheque())
-		return false;
-
-	if (!CanHandleItem())
-		return false;
-
-	if (0 != g_ChequeDropTimeLimitValue)
-	{
-		if (get_dword_time() < m_dwLastChequeDropTime + g_ChequeDropTimeLimitValue)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÁ÷ °ñµå¸¦ ¹ö¸± ¼ö ¾ø½À´Ï´Ù."));
-			return false;
-		}
-	}
-
-	m_dwLastChequeDropTime = get_dword_time();
-
-	LPITEM item = ITEM_MANAGER::instance().CreateItem(80020, cheque);
-
-	if (item)
-	{
-		PIXEL_POSITION pos = GetXYZ();
-
-		if (item->AddToGround(GetMapIndex(), pos))
-		{
-			PointChange(POINT_CHEQUE, -cheque, true);
-
-			if (cheque > 1000)
-				LogManager::instance().CharLog(this, cheque, "DROP_CHEQUE", "");
-
-			if (false == LC_IsBrazil())
-			{
-				item->StartDestroyEvent(150);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¶³¾îÁø ¾ÆÀÌÅÛÀº %dºÐ ÈÄ »ç¶óÁý´Ï´Ù.", 150 / 60));
-			}
-			else
-			{
-				item->StartDestroyEvent(60);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¶³¾îÁø ¾ÆÀÌÅÛÀº %dºÐ ÈÄ »ç¶óÁý´Ï´Ù.", 1));
-			}
-		}
-
-		Save();
-		return true;
-	}
-
-	return false;
-}
-#endif
-
-bool CHARACTER::MoveItem(TItemPos Cell, TItemPos DestCell, WORD count)
-{
-	LPITEM item = nullptr;
-
-	if (Cell.IsSameItemPosition(DestCell))
-		return false;
-
-	if (!IsValidItemPosition(Cell))
-		return false;
-
-	if (!(item = GetItem(Cell)))
-		return false;
-
-	if (item->IsExchanging())
-		return false;
-
-	if (item->GetCount() < count)
-		return false;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	if (INVENTORY == Cell.window_type && Cell.cell >= GetExtendInvenMax() && IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-		return false;
-#else
-	if (INVENTORY == Cell.window_type && Cell.cell >= INVENTORY_MAX_NUM && IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-		return false;
-#endif
-
-	if (true == item->isLocked())
-		return false;
-
-	if (!IsValidItemPosition(DestCell))
-		return false;
-
-	if (!CanHandleItem())
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (DragonSoul_RefineWindow_GetOpener())
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("°­È­Ã¢À» ¿¬ »óÅÂ¿¡¼­´Â ¾ÆÀÌÅÛÀ» ¿Å±æ ¼ö ¾ø½À´Ï´Ù."));
-#endif
-		return false;
-	}
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot move items while modifying your pet's stats."));
-		return false;
-	}
-#endif
-
-	if (DestCell.IsBeltInventoryPosition())
-	{
-		// At the request of the planner, only certain types of items can be placed in the belt inventory.
-		if (!CBeltInventoryHelper::CanMoveIntoBeltInventory(item))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀº º§Æ® ÀÎº¥Åä¸®·Î ¿Å±æ ¼ö ¾ø½À´Ï´Ù."));
-			return false;
-		}
-	}
-
-	// ÀÌ¹Ì Âø¿ëÁßÀÎ ¾ÆÀÌÅÛÀ» ´Ù¸¥ °÷À¸·Î ¿Å±â´Â °æ¿ì, 'ÀåÃ¥ ÇØÁ¦' °¡´ÉÇÑ Áö È®ÀÎÇÏ°í ¿Å±è
-	if (Cell.IsEquipPosition())
-	{
-		if (!CanUnequipNow(item))
-			return false;
-
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-		const int iWearCell = item->FindEquipCell(this);
-		if (iWearCell == WEAR_WEAPON)
-		{
-			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
-			if (pkCostumeWeapon)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
-				return false;
-			}
-		}
-#endif
-	}
-
-	if (DestCell.IsEquipPosition())
-	{
-		if (GetItem(DestCell)
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			&& DestCell.IsDragonSoulEquipPosition()
-#endif
-			) // ÀåºñÀÏ °æ¿ì ÇÑ °÷¸¸ °Ë»çÇØµµ µÈ´Ù.
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì Àåºñ¸¦ Âø¿ëÇÏ°í ÀÖ½À´Ï´Ù."));
-			return false;
-		}
-
-		EquipItem(item, DestCell.cell);
-	}
-	else
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-		{
-			if (item->IsEquipped())
-			{
-				return DSManager::instance().PullOut(this, DestCell, item);
-			}
-			else
-			{
-				if (DestCell.window_type != DRAGON_SOUL_INVENTORY)
-				{
-					return false;
-				}
-
-				if (!DSManager::instance().IsValidCellForThisItem(item, DestCell))
-					return false;
-			}
-		}
-		// ¿ëÈ¥¼®ÀÌ ¾Æ´Ñ ¾ÆÀÌÅÛÀº ¿ëÈ¥¼® ÀÎº¥¿¡ µé¾î°¥ ¼ö ¾ø´Ù.
-		else if (DRAGON_SOUL_INVENTORY == DestCell.window_type)
-			return false;
-#endif
-
-		LPITEM item2;
-
-		if ((item2 = GetItem(DestCell)) && item != item2 && item2->IsStackable() &&
-			!IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_STACK) &&
-			item2->GetVnum() == item->GetVnum() && !item2->IsExchanging()) // ÇÕÄ¥ ¼ö ÀÖ´Â ¾ÆÀÌÅÛÀÇ °æ¿ì
-		{
-			for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
-				if (item2->GetSocket(i) != item->GetSocket(i))
-					return false;
-
-			if (count == 0)
-				count = item->GetCount();
-
-			sys_log(0, "%s: ITEM_STACK %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell,
-				DestCell.window_type, DestCell.cell, count);
-
-			count = MIN(ITEM_MAX_COUNT - item2->GetCount(), count);
-
-			item->SetCount(item->GetCount() - count);
-			item2->SetCount(item2->GetCount() + count);
-
-			return true;
-		}
-
-		if (!IsEmptyItemGrid(DestCell, item->GetSize(), Cell.cell))
-		{
-			return false;
-		}
-
-		if (count == 0 || count >= item->GetCount() || !item->IsStackable() || IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-		{
-			sys_log(0, "%s: ITEM_MOVE %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell,
-				DestCell.window_type, DestCell.cell, count);
-
-			item->RemoveFromCharacter();
-			SetItem(DestCell, item);
-
-			if (INVENTORY == Cell.window_type && INVENTORY == DestCell.window_type)
-				SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, DestCell.cell);
-			else if (BELT_INVENTORY == Cell.window_type && BELT_INVENTORY == DestCell.window_type)
-				SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, DestCell.cell);
-
-			else if (INVENTORY == Cell.window_type && BELT_INVENTORY == DestCell.window_type)
-				MoveQuickSlotItem(SLOT_TYPE_INVENTORY, Cell.cell, SLOT_TYPE_BELT_INVENTORY, DestCell.cell);
-			else if (BELT_INVENTORY == Cell.window_type && INVENTORY == DestCell.window_type)
-				MoveQuickSlotItem(SLOT_TYPE_BELT_INVENTORY, Cell.cell, SLOT_TYPE_INVENTORY, DestCell.cell);
-		}
-		else if (count < item->GetCount())
-		{
-			sys_log(0, "%s: ITEM_SPLIT %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell, DestCell.window_type, DestCell.cell, count);
-
-			item->SetCount(item->GetCount() - count);
-			LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), count);
-
-			// Copy socket -- by mhh
-			FN_copy_item_socket(item2, item);
-
-			item2->AddToCharacter(this, DestCell);
-
-			char szBuf[51 + 1];
-			snprintf(szBuf, sizeof(szBuf), "%u %u %u %u ", item2->GetID(), item2->GetCount(), item->GetCount(), item->GetCount() + item2->GetCount());
-			LogManager::instance().ItemLog(this, item, "ITEM_SPLIT", szBuf);
-		}
-	}
-
-	return true;
-}
-
-namespace NPartyPickupDistribute
-{
-	struct FFindOwnership
-	{
-		LPITEM item;
-		LPCHARACTER owner;
-
-		FFindOwnership(LPITEM item)
-			: item(item), owner(NULL)
-		{
-		}
-
-		void operator () (LPCHARACTER ch)
-		{
-			if (item->IsOwnership(ch))
-				owner = ch;
-		}
-	};
-
-	struct FCountNearMember
-	{
-		int total;
-		int x, y;
-
-		FCountNearMember(LPCHARACTER center)
-			: total(0), x(center->GetX()), y(center->GetY())
-		{
-		}
-
-		void operator () (LPCHARACTER ch)
-		{
-			if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
-				total += 1;
-		}
-	};
-
-	struct FMoneyDistributor
-	{
-		int total;
-		LPCHARACTER c;
-		int x, y;
-		int iMoney;
-
-		FMoneyDistributor(LPCHARACTER center, int iMoney)
-			: total(0), c(center), x(center->GetX()), y(center->GetY()), iMoney(iMoney)
-		{
-		}
-
-		void operator ()(LPCHARACTER ch)
-		{
-			if (ch != c)
-				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
-				{
-					ch->PointChange(POINT_GOLD, iMoney, true);
-
-					if (iMoney > 1000) // Ãµ¿ø ÀÌ»ó¸¸ ±â·ÏÇÑ´Ù.
-						LogManager::instance().CharLog(ch, iMoney, "GET_GOLD", "");
-				}
-		}
-	};
-
-#if defined(__CHEQUE_SYSTEM__)
-	struct FChequeDistributor
-	{
-		int total;
-		LPCHARACTER c;
-		int x, y;
-		int iCheque;
-
-		FChequeDistributor(LPCHARACTER center, int iCheque)
-			: total(0), c(center), x(center->GetX()), y(center->GetY()), iCheque(iCheque)
-		{
-		}
-
-		void operator ()(LPCHARACTER ch)
-		{
-			if (ch != c)
-				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
-				{
-					ch->PointChange(POINT_CHEQUE, iCheque, true);
-
-					if (iCheque > 1000)
-						LogManager::instance().CharLog(ch, iCheque, "GET_CHEQUE", "");
-				}
-		}
-	};
-#endif
-
-#if defined(__GEM_SYSTEM__)
-	struct FGemDistributor
-	{
-		int total;
-		LPCHARACTER c;
-		int x, y;
-		int iGem;
-
-		FGemDistributor(LPCHARACTER center, int iGem)
-			: total(0), c(center), x(center->GetX()), y(center->GetY()), iGem(iGem)
-		{
-		}
-
-		void operator ()(LPCHARACTER ch)
-		{
-			if (ch != c)
-				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
-				{
-					ch->PointChange(POINT_GEM, iGem, true);
-
-					if (iGem > 1000)
-						LogManager::instance().CharLog(ch, iGem, "GET_GEM", "");
-				}
-		}
-	};
-#endif
-}
-
-void CHARACTER::GiveGold(int iAmount)
-{
-	if (iAmount <= 0)
-		return;
-
-	sys_log(0, "GIVE_GOLD: %s %d", GetName(), iAmount);
-
-	if (GetParty())
-	{
-		LPPARTY pParty = GetParty();
-
-		// ÆÄÆ¼°¡ ÀÖ´Â °æ¿ì ³ª´©¾î °¡Áø´Ù.
-		DWORD dwTotal = iAmount;
-		DWORD dwMyAmount = dwTotal;
-
-		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
-		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
-
-		if (funcCountNearMember.total > 1)
-		{
-			DWORD dwShare = dwTotal / funcCountNearMember.total;
-			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
-
-			NPartyPickupDistribute::FMoneyDistributor funcMoneyDist(this, dwShare);
-			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
-		}
-
-		PointChange(POINT_GOLD, dwMyAmount, true);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		UpdateExtBattlePassMissionProgress(YANG_COLLECT, dwMyAmount, GetMapIndex());
-#endif
-
-		if (dwMyAmount > 1000) // Ãµ¿ø ÀÌ»ó¸¸ ±â·ÏÇÑ´Ù.
-			LogManager::instance().CharLog(this, dwMyAmount, "GET_GOLD", "");
-	}
-	else
-	{
-		PointChange(POINT_GOLD, iAmount, true);
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		UpdateExtBattlePassMissionProgress(YANG_COLLECT, iAmount, GetMapIndex());
-#endif
-
-		// ºê¶óÁú¿¡ µ·ÀÌ ¾ø¾îÁø´Ù´Â ¹ö±×°¡ ÀÖ´Âµ¥,
-		// °¡´ÉÇÑ ½Ã³ª¸®¿À Áß¿¡ ÇÏ³ª´Â,
-		// ¸ÞÅ©·Î³ª, ÇÙÀ» ½á¼­ 1000¿ø ÀÌÇÏÀÇ µ·À» °è¼Ó ¹ö·Á °ñµå¸¦ 0À¸·Î ¸¸µé°í,
-		// µ·ÀÌ ¾ø¾îÁ³´Ù°í º¹±¸ ½ÅÃ»ÇÏ´Â °ÍÀÏ ¼öµµ ÀÖ´Ù.
-		// µû¶ó¼­ ±×·± °æ¿ì¸¦ Àâ±â À§ÇØ ³·Àº ¼öÄ¡ÀÇ °ñµå¿¡ ´ëÇØ¼­µµ ·Î±×¸¦ ³²±è.
-		if (LC_IsBrazil() == true)
-		{
-			if (iAmount >= 213)
-				LogManager::instance().CharLog(this, iAmount, "GET_GOLD", "");
-		}
-		else
-		{
-			if (iAmount > 1000) // Ãµ¿ø ÀÌ»ó¸¸ ±â·ÏÇÑ´Ù.
-				LogManager::instance().CharLog(this, iAmount, "GET_GOLD", "");
-		}
-	}
-}
-
-#if defined(__CHEQUE_SYSTEM__)
-void CHARACTER::GiveCheque(int iAmount)
-{
-	if (iAmount <= 0)
-		return;
-
-	sys_log(0, "GIVE_CHEQUE: %s %lld", GetName(), iAmount);
-
-	if (GetParty())
-	{
-		LPPARTY pParty = GetParty();
-
-		DWORD dwTotal = iAmount;
-		DWORD dwMyAmount = dwTotal;
-
-		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
-		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
-
-		if (funcCountNearMember.total > 1)
-		{
-			DWORD dwShare = dwTotal / funcCountNearMember.total;
-			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
-
-			NPartyPickupDistribute::FChequeDistributor funcMoneyDist(this, dwShare);
-			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
-		}
-
-		PointChange(POINT_CHEQUE, dwMyAmount, true);
-
-		if (dwMyAmount > 1000)
-			LogManager::instance().CharLog(this, dwMyAmount, "GET_CHEQUE", "");
-	}
-	else
-	{
-		PointChange(POINT_CHEQUE, iAmount, true);
-
-		if (LC_IsBrazil() == true)
-		{
-			if (iAmount >= 213)
-				LogManager::instance().CharLog(this, iAmount, "GET_CHEQUE", "");
-		}
-		else
-		{
-			if (iAmount > 1000)
-				LogManager::instance().CharLog(this, iAmount, "GET_CHEQUE", "");
-		}
-	}
-}
-#endif
-
-#if defined(__GEM_SYSTEM__)
-void CHARACTER::GiveGem(int iAmount)
-{
-	if (iAmount <= 0)
-		return;
-
-	sys_log(0, "GIVE_GEM: %s %lld", GetName(), iAmount);
-
-	if (GetParty())
-	{
-		LPPARTY pParty = GetParty();
-
-		DWORD dwTotal = iAmount;
-		DWORD dwMyAmount = dwTotal;
-
-		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
-		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
-
-		if (funcCountNearMember.total > 1)
-		{
-			DWORD dwShare = dwTotal / funcCountNearMember.total;
-			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
-
-			NPartyPickupDistribute::FGemDistributor funcMoneyDist(this, dwShare);
-			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
-		}
-
-		PointChange(POINT_GEM, dwMyAmount, true);
-
-		if (dwMyAmount > 1000)
-			LogManager::instance().CharLog(this, dwMyAmount, "GET_GEM", "");
-	}
-	else
-	{
-		PointChange(POINT_GEM, iAmount, true);
-
-		if (LC_IsBrazil() == true)
-		{
-			if (iAmount >= 213)
-				LogManager::instance().CharLog(this, iAmount, "GET_GEM", "");
-		}
-		else
-		{
-			if (iAmount > 1000)
-				LogManager::instance().CharLog(this, iAmount, "GET_GEM", "");
-		}
-	}
-}
-#endif
-
-bool CHARACTER::PickupItem(DWORD dwVID
-#if defined(__PET_LOOT_AI__)
-	, bool bPetLoot
-#endif
-)
-{
-	if (IsDead())
-		return false;
-
-	LPITEM item = ITEM_MANAGER::instance().FindByVID(dwVID);
-
-	if (IsObserverMode())
-		return false;
-
-	if (!item || !item->GetSectree())
-		return false;
-
-	if (item->DistanceValid(this)
-#if defined(__PET_LOOT_AI__)
-		|| bPetLoot
-#endif
-		)
-	{
-		if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
-			|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
-		{
-			if (IsRunningQuest())
-				return false;
-		}
-
-		if (item->IsOwnership(this))
-		{
-#if defined(__LOOT_FILTER_SYSTEM__)
-			if (GetLootFilter() && !GetLootFilter()->CanPickUpItem(item))
-			{
-				if (!GetLootFilter()->IsLootFilteredItem(dwVID))
-				{
-					GetLootFilter()->InsertLootFilteredItem(dwVID);
-
-					if (GetDesc())
-					{
-						TPacketGCLootFilter p;
-						p.header = HEADER_GC_LOOT_FILTER;
-						p.enable = false;
-						p.vid = dwVID;
-						GetDesc()->Packet(&p, sizeof(p));
-					}
-				}
-
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as the loot filter is deactivated."));
-				return false;
-			}
-#endif
-
-			// ¸¸¾à ÁÖÀ¸·Á ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¿¤Å©¶ó¸é
-			if (item->GetType() == ITEM_ELK)
-			{
-				GiveGold(item->GetCount());
-				item->RemoveFromGround();
-
-				M2_DESTROY_ITEM(item);
-
-				Save();
-			}
-			// Æò¹üÇÑ ¾ÆÀÌÅÛÀÌ¶ó¸é
-			else
-			{
-				if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-				{
-					WORD wCount = item->GetCount();
-
-					for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-					{
-						LPITEM item2 = GetInventoryItem(i);
-
-						if (!item2)
-							continue;
-
-						if (item2->GetVnum() == item->GetVnum())
-						{
-							int j;
-
-							for (j = 0; j < ITEM_SOCKET_MAX_NUM; ++j)
-							{
-								if (item2->GetSocket(j) != item->GetSocket(j))
-									break;
-							}
-
-							if (j != ITEM_SOCKET_MAX_NUM)
-								continue;
-
-							WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
-
-							wCount -= wCount2;
-
-							item2->SetCount(item2->GetCount() + wCount2);
-
-							if (wCount == 0)
-							{
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-								ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
-#else
-								ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item2->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
-#else
-								ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item2->GetVnum())));
-#endif
-#endif
-								M2_DESTROY_ITEM(item);
-
-								if (item2->GetType() == ITEM_QUEST)
-									quest::CQuestManager::instance().PickupItem(GetPlayerID(), item2);
-
-								return true;
-							}
-						}
-					}
-
-					item->SetCount(wCount);
-				}
-
-				int iEmptyCell;
-#if defined(__DRAGON_SOUL_SYSTEM__)
-				if (item->IsDragonSoul())
-				{
-					if ((iEmptyCell = GetEmptyDragonSoulInventory(item)) == -1)
-					{
-						sys_log(0, "No empty ds inventory pid %u size %ud itemid %u", GetPlayerID(), item->GetSize(), item->GetID());
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛÀÌ ³Ê¹« ¸¹½À´Ï´Ù."));
-						return false;
-					}
-				}
-				else
-#endif
-				{
-					if ((iEmptyCell = GetEmptyInventory(item->GetSize())) == -1)
-					{
-						sys_log(0, "No empty inventory pid %u size %ud itemid %u", GetPlayerID(), item->GetSize(), item->GetID());
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛÀÌ ³Ê¹« ¸¹½À´Ï´Ù."));
-						return false;
-					}
-				}
-
-				item->RemoveFromGround();
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-				if (item->IsDragonSoul())
-					item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
-				else
-#endif
-					item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell));
-
-				char szHint[32 + 1];
-				snprintf(szHint, sizeof(szHint), "%s %u %u", item->GetName(), item->GetCount(), item->GetOriginalVnum());
-				LogManager::instance().ItemLog(this, item, "GET", szHint);
-
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#endif
-#endif
-
-				if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
-					|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
-				{
-					quest::CQuestManager::instance().PickupItem(GetPlayerID(), item);
-				}
-			}
-
-			//Motion(MOTION_PICKUP);
-			return true;
-		}
-		else if (!IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_DROP) && GetParty())
-		{
-			// ´Ù¸¥ ÆÄÆ¼¿ø ¼ÒÀ¯±Ç ¾ÆÀÌÅÛÀ» ÁÖÀ¸·Á°í ÇÑ´Ù¸é
-			NPartyPickupDistribute::FFindOwnership funcFindOwnership(item);
-			GetParty()->ForEachOnMapMember(funcFindOwnership, GetMapIndex());
-
-			LPCHARACTER owner = funcFindOwnership.owner;
-			if (!owner)
-				return false;
-
-			int iEmptyCell;
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			if (item->IsDragonSoul())
-			{
-				if (!(owner && (iEmptyCell = owner->GetEmptyDragonSoulInventory(item)) != -1))
-				{
-					owner = this;
-
-					if ((iEmptyCell = GetEmptyDragonSoulInventory(item)) == -1)
-					{
-						owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛÀÌ ³Ê¹« ¸¹½À´Ï´Ù."));
-						return false;
-					}
-				}
-			}
-			else
-#endif
-			{
-				if (!(owner && (iEmptyCell = owner->GetEmptyInventory(item->GetSize())) != -1))
-				{
-					owner = this;
-
-					if ((iEmptyCell = GetEmptyInventory(item->GetSize())) == -1)
-					{
-						owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛÀÌ ³Ê¹« ¸¹½À´Ï´Ù."));
-						return false;
-					}
-				}
-			}
-
-			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-			{
-				WORD wCount = item->GetCount();
-
-				for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-				{
-					LPITEM item2 = owner->GetInventoryItem(i);
-
-					if (!item2)
-						continue;
-
-					if (item2->GetVnum() == item->GetVnum())
-					{
-						int j;
-
-						for (j = 0; j < ITEM_SOCKET_MAX_NUM; ++j)
-						{
-							if (item2->GetSocket(j) != item->GetSocket(j))
-								break;
-						}
-
-						if (j != ITEM_SOCKET_MAX_NUM)
-							continue;
-
-						WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
-
-						wCount -= wCount2;
-
-						item2->SetCount(item2->GetCount() + wCount2);
-
-						if (wCount == 0)
-						{
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-							owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
-#else
-							owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item2->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-							owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
-#else
-							owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item2->GetVnum())));
-#endif
-#endif
-							M2_DESTROY_ITEM(item);
-
-							if (item2->GetType() == ITEM_QUEST)
-								quest::CQuestManager::instance().PickupItem(owner->GetPlayerID(), item2);
-
-							return true;
-						}
-					}
-				}
-
-				item->SetCount(wCount);
-			}
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-			if (owner->GetLootFilter() && !owner->GetLootFilter()->CanPickUpItem(item))
-			{
-				if (owner == this)
-				{
-					if (!owner->GetLootFilter()->IsLootFilteredItem(dwVID))
-					{
-						owner->GetLootFilter()->InsertLootFilteredItem(dwVID);
-
-						if (owner->GetDesc())
-						{
-							TPacketGCLootFilter p;
-							p.header = HEADER_GC_LOOT_FILTER;
-							p.enable = false;
-							p.vid = dwVID;
-							owner->GetDesc()->Packet(&p, sizeof(p));
-						}
-					}
-
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as the loot filter is deactivated."));
-				}
-				else
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as a party member's loot filter is deactivated."));
-				}
-
-				return false;
-			}
-#endif
-
-			item->RemoveFromGround();
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-			if (item->IsDragonSoul())
-				item->AddToCharacter(owner, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
-			else
-#endif
-				item->AddToCharacter(owner, TItemPos(INVENTORY, iEmptyCell));
-
-			char szHint[32 + 1];
-			snprintf(szHint, sizeof(szHint), "%s %u %u", item->GetName(), item->GetCount(), item->GetOriginalVnum());
-			LogManager::instance().ItemLog(owner, item, "GET", szHint);
-
-			if (owner == this)
-			{
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#endif
-#endif
-			}
-			else
-			{
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-				owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s ´ÔÀ¸·ÎºÎÅÍ %s", GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ Àü´Þ: %s ´Ô¿¡°Ô %s", owner->GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s ´ÔÀ¸·ÎºÎÅÍ %s", GetName(), LC_ITEM(item->GetVnum())));
-				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ Àü´Þ: %s ´Ô¿¡°Ô %s", owner->GetName(), LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-				owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s ´ÔÀ¸·ÎºÎÅÍ %s", GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ Àü´Þ: %s ´Ô¿¡°Ô %s", owner->GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-				owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s ´ÔÀ¸·ÎºÎÅÍ %s", GetName(), LC_ITEM(item->GetVnum())));
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ Àü´Þ: %s ´Ô¿¡°Ô %s", owner->GetName(), LC_ITEM(item->GetVnum())));
-#endif
-#endif
-			}
-
-			if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
-				|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
-			{
-				quest::CQuestManager::instance().PickupItem(owner->GetPlayerID(), item);
-			}
-
-			return true;
-		}
-	}
-
-	return false;
-}
-
-// ±ÍÂú¾Æ¼­ ¸¸µç ¸ÅÅ©·Î.. exp°¡ true¸é msg¸¦ Ãâ·ÂÇÏ°í return false ÇÏ´Â ¸ÅÅ©·Î (ÀÏ¹ÝÀûÀÎ verify ¿ëµµ¶ûÀº return ¶§¹®¿¡ ¾à°£ ¹Ý´ë¶ó ÀÌ¸§¶§¹®¿¡ Çò°¥¸± ¼öµµ ÀÖ°Ú´Ù..)
-#define VERIFY_MSG(exp, msg) \
-	if (true == (exp)) \
-	{ \
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING(msg)); \
-		return false; \
-	}
-
-bool CHARACTER::SwapItem(WORD wCell, WORD wDestCell)
-{
-	if (!CanHandleItem())
-		return false;
-
-	const TItemPos srcCell(INVENTORY, wCell), destCell(EQUIPMENT, wDestCell);
-
-	// ¿Ã¹Ù¸¥ Cell ÀÎÁö °Ë»ç
-	// ¿ëÈ¥¼®Àº SwapÇÒ ¼ö ¾øÀ¸¹Ç·Î, ¿©±â¼­ °É¸².
-	//if (bCell >= INVENTORY_MAX_NUM + WEAR_MAX_NUM || bDestCell >= INVENTORY_MAX_NUM + WEAR_MAX_NUM)
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (srcCell.IsDragonSoulEquipPosition() || destCell.IsDragonSoulEquipPosition())
-		return false;
-#endif
-
-	// µÑ ´Ù ÀåºñÃ¢ À§Ä¡¸é Swap ÇÒ ¼ö ¾ø´Ù.
-	if (srcCell.IsEquipPosition() && destCell.IsEquipPosition())
-		return false;
-
-	LPITEM item1 = nullptr, item2 = nullptr;
-
-	// item2°¡ ÀåºñÃ¢¿¡ ÀÖ´Â °ÍÀÌ µÇµµ·Ï.
-	if (srcCell.IsEquipPosition())
-	{
-		item1 = GetEquipmentItem(wDestCell);
-		item2 = GetInventoryItem(wCell);
-	}
-	else
-	{
-		item1 = GetInventoryItem(wCell);
-		item2 = GetEquipmentItem(wDestCell);
-	}
-
-	if (!item1 || !item2)
-		return false;
-
-	if (item1 == item2)
-	{
-		sys_log(0, "[WARNING][WARNING][HACK USER!] : %s %d %d", m_stName.c_str(), wCell, wDestCell);
-		return false;
-	}
-
-	// item2°¡ bCellÀ§Ä¡¿¡ µé¾î°¥ ¼ö ÀÖ´ÂÁö È®ÀÎÇÑ´Ù.
-	if (!IsEmptyItemGrid(TItemPos(INVENTORY, item1->GetCell()), item2->GetSize(), item1->GetCell()))
-		return false;
-
-	// ¹Ù²Ü ¾ÆÀÌÅÛÀÌ ÀåºñÃ¢¿¡ ÀÖÀ¸¸é
-	if (TItemPos(EQUIPMENT, item2->GetCell()).IsEquipPosition())
-	{
-		const WORD wEquipCell = item2->GetCell();
-		const WORD wInvenCell = item1->GetCell();
-
-		// The item currently being worn can be removed, and the item planned to be worn
-		// must be in a wearable state in order to proceed.
-		if (!CanUnequipNow(item2, TItemPos(INVENTORY, wEquipCell)) || !CanEquipNow(item1))
-			return false;
-
-		if (wEquipCell != item1->FindEquipCell(this)) // When in the same location, it is only allowed
-			return false;
-
-		item2->RemoveFromCharacter();
-
-		if (item1->EquipTo(this, wEquipCell))
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			item2->AddToCharacter(this, TItemPos(INVENTORY, wInvenCell), false);
-#else
-			item2->AddToCharacter(this, TItemPos(INVENTORY, wInvenCell));
-#endif
-		else
-			sys_err("SwapItem cannot equip %s! item1 %s", item2->GetName(), item1->GetName());
-	}
-	else
-	{
-		const WORD wCell1 = item1->GetCell();
-		const WORD wCell2 = item2->GetCell();
-
-		item1->RemoveFromCharacter();
-		item2->RemoveFromCharacter();
-
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		item1->AddToCharacter(this, TItemPos(EQUIPMENT, wCell2), false);
-		item2->AddToCharacter(this, TItemPos(INVENTORY, wCell1), false);
-#else
-		item1->AddToCharacter(this, TItemPos(INVENTORY, wCell2));
-		item2->AddToCharacter(this, TItemPos(INVENTORY, wCell1));
-#endif
-	}
-
-	return true;
-}
-
-bool CHARACTER::UnequipItem(LPITEM item)
-{
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-	if (item->FindEquipCell(this) == WEAR_WEAPON)
-	{
-		LPITEM pCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
-		if (pCostumeWeapon)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
-			return false;
-		}
-	}
-#endif
-
-	if (false == CanUnequipNow(item))
-		return false;
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	if (item->IsCostumeMount() && item->IsEquipped())
-		UnMount();
-#endif
-
-	int pos;
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (item->IsDragonSoul())
-		pos = GetEmptyDragonSoulInventory(item);
-	else
-#endif
-		pos = GetEmptyInventory(item->GetSize());
-
-	// HARD CODING
-	if (item->GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
-		ShowAlignment(true);
-
-	item->RemoveFromCharacter();
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (item->IsDragonSoul())
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, pos), false);
-#else
-		item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, pos));
-#endif
-	else
-#endif
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-		item->AddToCharacter(this, TItemPos(INVENTORY, pos), false);
-#else
-		item->AddToCharacter(this, TItemPos(INVENTORY, pos));
-#endif
-
-	CheckMaximumPoints();
-
-	return true;
-}
-
-//
-// @version 05/07/05 Bang2ni - Skill »ç¿ëÈÄ 1.5 ÃÊ ÀÌ³»¿¡ Àåºñ Âø¿ë ±ÝÁö
-//
-bool CHARACTER::EquipItem(LPITEM item, int iCandidateCell)
-{
-	if (item->IsExchanging())
-		return false;
-
-	if (false == item->IsEquipable())
-		return false;
-
-	if (false == CanEquipNow(item))
-		return false;
-
-	int iWearCell = item->FindEquipCell(this, iCandidateCell);
-
-	if (iWearCell < 0)
-		return false;
-
-	// ¹«¾ð°¡¸¦ Åº »óÅÂ¿¡¼­ ÅÎ½Ãµµ ÀÔ±â ±ÝÁö
-	if (iWearCell == WEAR_BODY && IsRiding() && (item->GetVnum() >= 11901 && item->GetVnum() <= 11904))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("¸»À» Åº »óÅÂ¿¡¼­ ¿¹º¹À» ÀÔÀ» ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	if (iWearCell != WEAR_ARROW && IsPolymorphed())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("µÐ°© Áß¿¡´Â Âø¿ëÁßÀÎ Àåºñ¸¦ º¯°æÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-	if (FN_check_item_sex(this, item) == false)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ºº°ÀÌ ¸ÂÁö¾Ê¾Æ ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return false;
-	}
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-	DWORD dwTransmutationVnum = item->GetTransmutationVnum();
-	if (dwTransmutationVnum != 0)
-	{
-		TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwTransmutationVnum);
-
-		if (!pItemTable->CanUseByJob(GetJob()))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your class."));
-			return false;
-		}
-
-#	if defined(__COSTUME_SYSTEM__)
-		if (pItemTable && pItemTable->IsCostume())
-		{
-			if ((IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_MALE) && SEX_MALE == GET_SEX(this)) ||
-				(IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_FEMALE) && SEX_FEMALE == GET_SEX(this)))
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your gender."));
-				return false;
-			}
-		}
-	}
-#	endif
-#endif
-
-	// ½Å±Ô Å»°Í »ç¿ë½Ã ±âÁ¸ ¸» »ç¿ë¿©ºÎ Ã¼Å©
-	if (item->IsRideItem())
-	{
-		if (IsRiding())
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì Å»°ÍÀ» ÀÌ¿ëÁßÀÔ´Ï´Ù."));
-			return false;
-		}
-
-		if (IsPolymorphed())
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("º¯½Å »óÅÂ¿¡¼­´Â ¸»¿¡ Å» ¼ö ¾ø½À´Ï´Ù."));
-			return false;
-		}
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-		if (item->IsRideItem())
-		{
-			DWORD dwMountVnum = item->GetMountVnum();
-			if (dwMountVnum > 0 && FindAffect(AFFECT_MOUNT_FALL) == NULL)
-				MountVnum(dwMountVnum);
-		}
-#endif
-	}
-
-	// È­»ì ÀÌ¿Ü¿¡´Â ¸¶Áö¸· °ø°Ý ½Ã°£ ¶Ç´Â ½ºÅ³ »ç¿ë 1.5 ÈÄ¿¡ Àåºñ ±³Ã¼°¡ °¡´É
-	DWORD dwCurTime = get_dword_time();
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	if (iWearCell != WEAR_ARROW && iWearCell != WEAR_COSTUME_MOUNT
-		&& (dwCurTime - GetLastAttackTime() <= 1500 || dwCurTime - m_dwLastSkillTime <= 1500))
-#else
-	if (iWearCell != WEAR_ARROW
-		&& (dwCurTime - GetLastAttackTime() <= 1500 || dwCurTime - m_dwLastSkillTime <= 1500))
-#endif
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("°¡¸¸È÷ ÀÖÀ» ¶§¸¸ Âø¿ëÇÒ ¼ö ÀÖ½À´Ï´Ù."));
-		return false;
-	}
-
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-	if (iWearCell == WEAR_WEAPON)
-	{
-		if (item->GetType() == ITEM_WEAPON)
-		{
-			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
-			if (pkCostumeWeapon && pkCostumeWeapon->GetValue(3) != item->GetSubType())
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
-				return false;
-			}
-		}
-		else
-		{
-			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
-			if (pkCostumeWeapon)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
-				return false;
-			}
-		}
-	}
-	else if (iWearCell == WEAR_COSTUME_WEAPON)
-	{
-		if (item->GetType() == ITEM_COSTUME && item->GetSubType() == COSTUME_WEAPON)
-		{
-			LPITEM pkWeapon = GetWear(WEAR_WEAPON);
-			if (!pkWeapon)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You need to equip a weapon first."));
-				return false;
-			}
-			else if (pkWeapon->GetType() != ITEM_WEAPON || item->GetValue(3) != pkWeapon->GetSubType())
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this costume for this weapon."));
-				return false;
-			}
-		}
-	}
-#endif
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	// ¿ëÈ¥¼® Æ¯¼ö Ã³¸®
-	if (item->IsDragonSoul())
-	{
-		// °°Àº Å¸ÀÔÀÇ ¿ëÈ¥¼®ÀÌ ÀÌ¹Ì µé¾î°¡ ÀÖ´Ù¸é Âø¿ëÇÒ ¼ö ¾ø´Ù.
-		// ¿ëÈ¥¼®Àº swapÀ» Áö¿øÇÏ¸é ¾ÈµÊ.
-		if (GetEquipmentItem(iWearCell))
-		{
-			ChatPacket(CHAT_TYPE_INFO, "ÀÌ¹Ì °°Àº Á¾·ùÀÇ ¿ëÈ¥¼®À» Âø¿ëÇÏ°í ÀÖ½À´Ï´Ù.");
-			return false;
-		}
-
-		if (!item->EquipTo(this, iWearCell))
-		{
-			return false;
-		}
-	}
-	// ¿ëÈ¥¼®ÀÌ ¾Æ´Ô.
-	else
-#endif
-	{
-		// Âø¿ëÇÒ °÷¿¡ ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é,
-		if (GetWear(iWearCell) && !IS_SET(GetWear(iWearCell)->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-		{
-			// ÀÌ ¾ÆÀÌÅÛÀº ÇÑ¹ø ¹ÚÈ÷¸é º¯°æ ºÒ°¡. swap ¿ª½Ã ¿ÏÀü ºÒ°¡
-			//if (item->GetWearFlag() == WEARABLE_ABILITY)
-			//	return false;
-
-			if (!SwapItem(item->GetCell(), iWearCell))
-				return false;
-		}
-		else
-		{
-			BYTE bOldCell = item->GetCell();
-
-			if (item->EquipTo(this, iWearCell))
-				SyncQuickslot(SLOT_TYPE_INVENTORY, bOldCell, iWearCell);
-		}
-	}
-
-	if (true == item->IsEquipped())
-	{
-		// ¾ÆÀÌÅÛ ÃÖÃÊ »ç¿ë ÀÌÈÄºÎÅÍ´Â »ç¿ëÇÏÁö ¾Ê¾Æµµ ½Ã°£ÀÌ Â÷°¨µÇ´Â ¹æ½Ä Ã³¸®.
-		if (-1 != item->GetProto()->cLimitRealTimeFirstUseIndex)
-		{
-			// ÇÑ ¹øÀÌ¶óµµ »ç¿ëÇÑ ¾ÆÀÌÅÛÀÎÁö ¿©ºÎ´Â Socket1À» º¸°í ÆÇ´ÜÇÑ´Ù. (Socket1¿¡ »ç¿ëÈ½¼ö ±â·Ï)
-			if (0 == item->GetSocket(1))
-			{
-				// »ç¿ë°¡´É½Ã°£Àº Default °ªÀ¸·Î Limit Value °ªÀ» »ç¿ëÇÏµÇ, Socket0¿¡ °ªÀÌ ÀÖÀ¸¸é ±× °ªÀ» »ç¿ëÇÏµµ·Ï ÇÑ´Ù. (´ÜÀ§´Â ÃÊ)
-				long duration = (0 != item->GetSocket(0)) ? item->GetSocket(0) : item->GetProto()->aLimits[(BYTE)item->GetProto()->cLimitRealTimeFirstUseIndex].lValue;
-
-				if (0 == duration)
-					duration = 60 * 60 * 24 * 7;
-
-				item->SetSocket(0, time(0) + duration);
-				item->StartRealTimeExpireEvent();
-			}
-
-			item->SetSocket(1, item->GetSocket(1) + 1);
-		}
-
-		if (item->GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
-			ShowAlignment(false);
-
-		if (item->IsRing() || item->IsCostume()
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-			&& !item->IsCostumeMount()
-#endif
-			)
-			ChatPacket(CHAT_TYPE_COMMAND, "OpenCostumeWindow");
-
-		const DWORD& dwVnum = item->GetVnum();
-
-		// ¶ó¸¶´Ü ÀÌº¥Æ® ÃÊ½Â´ÞÀÇ ¹ÝÁö(71135) Âø¿ë½Ã ÀÌÆåÆ® ¹ßµ¿
-		if (true == CItemVnumHelper::IsRamadanMoonRing(dwVnum))
-		{
-			this->EffectPacket(SE_EQUIP_RAMADAN_RING);
-		}
-		// ÇÒ·ÎÀ© »çÅÁ(71136) Âø¿ë½Ã ÀÌÆåÆ® ¹ßµ¿
-		else if (true == CItemVnumHelper::IsHalloweenCandy(dwVnum))
-		{
-			this->EffectPacket(SE_EQUIP_HALLOWEEN_CANDY);
-		}
-		// Çàº¹ÀÇ ¹ÝÁö(71143) Âø¿ë½Ã ÀÌÆåÆ® ¹ßµ¿
-		else if (true == CItemVnumHelper::IsHappinessRing(dwVnum))
-		{
-			this->EffectPacket(SE_EQUIP_HAPPINESS_RING);
-		}
-		// »ç¶ûÀÇ ÆÒ´øÆ®(71145) Âø¿ë½Ã ÀÌÆåÆ® ¹ßµ¿
-		else if (true == CItemVnumHelper::IsLovePendant(dwVnum))
-		{
-			this->EffectPacket(SE_EQUIP_LOVE_PENDANT);
-		}
-		// ITEM_UNIQUEÀÇ °æ¿ì, SpecialItemGroup¿¡ Á¤ÀÇµÇ¾î ÀÖ°í, (item->GetSIGVnum() != NULL)
-		//
-		else if ((ITEM_UNIQUE == item->GetType() || ITEM_RING == item->GetType()) && 0 != item->GetSIGVnum())
-		{
-			const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(item->GetSIGVnum());
-			if (NULL != pGroup)
-			{
-				const CSpecialAttrGroup* pAttrGroup = ITEM_MANAGER::instance().GetSpecialAttrGroup(pGroup->GetAttrVnum(item->GetVnum()));
-				if (NULL != pAttrGroup)
-				{
-					const std::string& std = pAttrGroup->m_stEffectFileName;
-					SpecificEffectPacket(std.c_str());
-				}
-			}
-		}
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		if ((item->GetType() == ITEM_COSTUME) && (item->GetSubType() == COSTUME_ACCE
-#if defined(__AURA_COSTUME_SYSTEM__)
-			|| item->GetSubType() == COSTUME_AURA
-#endif
-			))
-		{
-			if (item->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) > 18)
-				this->EffectPacket(SE_ACCE_BACK);
-			this->EffectPacket(SE_ACCE_EQUIP);
-		}
-#endif
-
-		if ((ITEM_UNIQUE == item->GetType() && UNIQUE_SPECIAL_RIDE == item->GetSubType() && IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE))
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-			|| (ITEM_COSTUME == item->GetType() && COSTUME_MOUNT == item->GetSubType())
-#endif
-			)
-		{
-			quest::CQuestManager::instance().UseItem(GetPlayerID(), item, false);
-		}
-	}
-
-	return true;
-}
-
-void CHARACTER::BuffOnAttr_AddBuffsFromItem(LPITEM pItem)
-{
-	for (int i = 0; i < sizeof(g_aBuffOnAttrPoints) / sizeof(g_aBuffOnAttrPoints[0]); i++)
-	{
-		TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(g_aBuffOnAttrPoints[i]);
-		if (it != m_map_buff_on_attrs.end())
-		{
-			it->second->AddBuffFromItem(pItem);
-		}
-	}
-}
-
-void CHARACTER::BuffOnAttr_RemoveBuffsFromItem(LPITEM pItem)
-{
-	for (int i = 0; i < sizeof(g_aBuffOnAttrPoints) / sizeof(g_aBuffOnAttrPoints[0]); i++)
-	{
-		TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(g_aBuffOnAttrPoints[i]);
-		if (it != m_map_buff_on_attrs.end())
-		{
-			it->second->RemoveBuffFromItem(pItem);
-		}
-	}
-}
-
-void CHARACTER::BuffOnAttr_ClearAll()
-{
-	for (TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.begin(); it != m_map_buff_on_attrs.end(); ++it)
-	{
-		CBuffOnAttributes* pBuff = it->second;
-		if (pBuff)
-		{
-			pBuff->Initialize();
-		}
-	}
-}
-
-void CHARACTER::BuffOnAttr_ValueChange(POINT_TYPE wPointType, POINT_VALUE llOldValue, POINT_VALUE lNewValue)
-{
-	TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(wPointType);
-
-	if (0 == lNewValue)
-	{
-		if (m_map_buff_on_attrs.end() == it)
-			return;
-		else
-			it->second->Off();
-	}
-	else if (0 == llOldValue)
-	{
-		CBuffOnAttributes* pBuff;
-		if (m_map_buff_on_attrs.end() == it)
-		{
-			switch (wPointType)
-			{
-				case POINT_ENERGY:
-				{
-					static BYTE s_abSlot[] = {
-						WEAR_BODY,
-						WEAR_HEAD,
-						WEAR_FOOTS,
-						WEAR_WRIST,
-						WEAR_WEAPON,
-						WEAR_NECK,
-						WEAR_EAR,
-						WEAR_SHIELD,
-#if defined(__PENDANT_SYSTEM__)
-						WEAR_PENDANT,
-#endif
-#if defined(__GLOVE_SYSTEM__)
-						WEAR_GLOVE,
-#endif
-					};
-					static std::vector<POINT_TYPE> s_vSlots(s_abSlot, s_abSlot + _countof(s_abSlot));
-					pBuff = M2_NEW CBuffOnAttributes(this, wPointType, &s_vSlots);
-				}
-				break;
-
-				case POINT_COSTUME_ATTR_BONUS:
-				{
-					static BYTE s_abSlot[] = {
-						WEAR_COSTUME_BODY,
-						WEAR_COSTUME_HAIR,
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-						WEAR_COSTUME_WEAPON,
-#endif
-					};
-					static std::vector<POINT_TYPE> s_vSlots(s_abSlot, s_abSlot + _countof(s_abSlot));
-					pBuff = M2_NEW CBuffOnAttributes(this, wPointType, &s_vSlots);
-				}
-				break;
-
-				default:
-					break;
-
-			}
-			m_map_buff_on_attrs.insert(TMapBuffOnAttrs::value_type(wPointType, pBuff));
-
-		}
-		else
-			pBuff = it->second;
-
-		pBuff->On(lNewValue);
-	}
-	else
-	{
-		if (m_map_buff_on_attrs.end() == it)
-			return;
-		else
-			it->second->ChangeBuffValue(lNewValue);
-	}
-}
-
-LPITEM CHARACTER::FindSpecifyItem(DWORD dwVnum
-#if defined(__SOUL_BIND_SYSTEM__)
-	, bool bIgnoreSoulBound
-#endif
-#if defined(__SET_ITEM__)
-	, bool bIgnoreSetValue
-#endif
-) const
-{
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-	{
-		if (GetInventoryItem(i) && GetInventoryItem(i)->GetVnum() == dwVnum)
-		{
-#if defined(__SOUL_BIND_SYSTEM__)
-			if (bIgnoreSoulBound && GetInventoryItem(i)->IsSealed())
-				continue;
-#endif
-
-#if defined(__SET_ITEM__)
-			if (bIgnoreSetValue && GetInventoryItem(i)->GetItemSetValue())
-				continue;
-#endif
-			return GetInventoryItem(i);
-		}
-	}
-	return NULL;
-}
-
-LPITEM CHARACTER::FindItemByID(DWORD id) const
-{
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (WORD wCell = 0; wCell < GetExtendInvenMax(); ++wCell)
-#else
-	for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
-#endif
-		if (GetInventoryItem(wCell) && GetInventoryItem(wCell)->GetID() == id)
-			return GetInventoryItem(wCell);
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	for (WORD wCell = 0; wCell < DRAGON_SOUL_INVENTORY_MAX_NUM; ++wCell)
-		if (GetDragonSoulInventoryItem(wCell) && GetDragonSoulInventoryItem(wCell)->GetID() == id)
-			return GetDragonSoulInventoryItem(wCell);
-#endif
-
-	for (WORD wCell = 0; wCell < BELT_INVENTORY_MAX_NUM; ++wCell)
-		if (GetBeltInventoryItem(wCell) && GetBeltInventoryItem(wCell)->GetID() == id)
-			return GetBeltInventoryItem(wCell);
-
-	return NULL;
-}
-
-int CHARACTER::CountSpecifyItem(DWORD vnum, int iExceptionCell
-#if defined(__SOUL_BIND_SYSTEM__)
-	, bool bIgnoreSealedItem
-#endif
-#if defined(__SET_ITEM__)
-	, bool bIgnoreSetValue
-#endif
-) const
-{
-	int iCount = 0;
-	LPITEM pItem = nullptr;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (WORD wCell = 0; wCell < GetExtendInvenMax(); ++wCell)
-#else
-	for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
-#endif
-	{
-		if (wCell == iExceptionCell)
-			continue;
-
-		pItem = GetInventoryItem(wCell);
-		if (pItem && pItem->GetVnum() == vnum)
-		{
-			// °³ÀÎ »óÁ¡¿¡ µî·ÏµÈ ¹°°ÇÀÌ¸é ³Ñ¾î°£´Ù.
-			if (m_pkMyShop && m_pkMyShop->IsSellingItem(pItem->GetID()))
-				continue;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-			if (bIgnoreSealedItem && pItem->IsSealed())
-				continue;
-#endif
-
-#if defined(__SET_ITEM__)
-			if (bIgnoreSetValue && pItem->GetItemSetValue())
-				continue;
-#endif
-
-			iCount += pItem->GetCount();
-		}
-	}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	for (WORD wCell = 0; wCell < DRAGON_SOUL_INVENTORY_MAX_NUM; ++wCell)
-	{
-		pItem = GetDragonSoulInventoryItem(wCell);
-		if (pItem && pItem->GetVnum() == vnum)
-		{
-#if defined(__SOUL_BIND_SYSTEM__)
-			if (bIgnoreSealedItem && pItem->IsSealed())
-				continue;
-#endif
-
-			iCount += pItem->GetCount();
-		}
-	}
-#endif
-
-	return iCount;
-}
-
-void CHARACTER::RemoveSpecifyItem(DWORD vnum, DWORD count, int iExceptionCell
-#if defined(__SOUL_BIND_SYSTEM__)
-	, bool bIgnoreSealedItem
-#endif
-#if defined(__SET_ITEM__)
-	, bool bIgnoreSetValue
-#endif
-)
-{
-	if (0 == count)
-		return;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (UINT i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (UINT i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-	{
-		if (i == iExceptionCell)
-			continue;
-
-		if (NULL == GetInventoryItem(i))
-			continue;
-
-		if (GetInventoryItem(i)->GetVnum() != vnum)
-			continue;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-		if (bIgnoreSealedItem && GetInventoryItem(i)->IsSealed())
-			continue;
-#endif
-
-#if defined(__SET_ITEM__)
-		if (bIgnoreSetValue && GetInventoryItem(i)->GetItemSetValue())
-			continue;
-#endif
-
-		//°³ÀÎ »óÁ¡¿¡ µî·ÏµÈ ¹°°ÇÀÌ¸é ³Ñ¾î°£´Ù. (°³ÀÎ »óÁ¡¿¡¼­ ÆÇ¸ÅµÉ¶§ ÀÌ ºÎºÐÀ¸·Î µé¾î¿Ã °æ¿ì ¹®Á¦!)
-		if (m_pkMyShop)
-		{
-			bool isItemSelling = m_pkMyShop->IsSellingItem(GetInventoryItem(i)->GetID());
-			if (isItemSelling)
-				continue;
-		}
-
-		if (vnum >= 80003 && vnum <= 80007)
-			LogManager::instance().GoldBarLog(GetPlayerID(), GetInventoryItem(i)->GetID(), QUEST, "RemoveSpecifyItem");
-
-		if (count >= GetInventoryItem(i)->GetCount())
-		{
-			count -= GetInventoryItem(i)->GetCount();
-			GetInventoryItem(i)->SetCount(0);
-
-			if (0 == count)
-				return;
-		}
-		else
-		{
-			GetInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
-			return;
-		}
-	}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	for (UINT i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
-	{
-		if (NULL == GetDragonSoulInventoryItem(i))
-			continue;
-
-		if (GetDragonSoulInventoryItem(i)->GetVnum() != vnum)
-			continue;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-		if (bIgnoreSealedItem && GetDragonSoulInventoryItem(i)->IsSealed())
-			continue;
-#endif
-
-#if defined(__SET_ITEM__)
-		if (bIgnoreSetValue && GetDragonSoulInventoryItem(i)->GetItemSetValue())
-			continue;
-#endif
-
-		if (count >= GetDragonSoulInventoryItem(i)->GetCount())
-		{
-			count -= GetDragonSoulInventoryItem(i)->GetCount();
-			GetDragonSoulInventoryItem(i)->SetCount(0);
-
-			if (0 == count)
-				return;
-		}
-		else
-		{
-			GetDragonSoulInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
-			return;
-		}
-	}
-#endif
-
-	// ¿¹¿ÜÃ³¸®°¡ ¾àÇÏ´Ù.
-	if (count)
-		sys_log(0, "CHARACTER::RemoveSpecifyItem cannot remove enough item vnum %u, still remain %d", vnum, count);
-}
-
-int CHARACTER::CountSpecifyTypeItem(BYTE type) const
-{
-	int count = 0;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (int i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-	{
-		LPITEM pItem = GetInventoryItem(i);
-		if (pItem != NULL && pItem->GetType() == type)
-		{
-			count += pItem->GetCount();
-		}
-	}
-
-	return count;
-}
-
-void CHARACTER::RemoveSpecifyTypeItem(BYTE type, DWORD count)
-{
-	if (0 == count)
-		return;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (UINT i = 0; i < GetExtendInvenMax(); ++i)
-#else
-	for (UINT i = 0; i < INVENTORY_MAX_NUM; ++i)
-#endif
-	{
-		if (NULL == GetInventoryItem(i))
-			continue;
-
-		if (GetInventoryItem(i)->GetType() != type)
-			continue;
-
-		//°³ÀÎ »óÁ¡¿¡ µî·ÏµÈ ¹°°ÇÀÌ¸é ³Ñ¾î°£´Ù. (°³ÀÎ »óÁ¡¿¡¼­ ÆÇ¸ÅµÉ¶§ ÀÌ ºÎºÐÀ¸·Î µé¾î¿Ã °æ¿ì ¹®Á¦!)
-		if (m_pkMyShop)
-		{
-			bool isItemSelling = m_pkMyShop->IsSellingItem(GetInventoryItem(i)->GetID());
-			if (isItemSelling)
-				continue;
-		}
-
-		if (count >= GetInventoryItem(i)->GetCount())
-		{
-			count -= GetInventoryItem(i)->GetCount();
-			GetInventoryItem(i)->SetCount(0);
-
-			if (0 == count)
-				return;
-		}
-		else
-		{
-			GetInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
-			return;
-		}
-	}
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	for (UINT i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
-	{
-		if (NULL == GetDragonSoulInventoryItem(i))
-			continue;
-
-		if (GetDragonSoulInventoryItem(i)->GetType() != type)
-			continue;
-
-		if (count >= GetDragonSoulInventoryItem(i)->GetCount())
-		{
-			count -= GetDragonSoulInventoryItem(i)->GetCount();
-			GetDragonSoulInventoryItem(i)->SetCount(0);
-
-			if (0 == count)
-				return;
-		}
-		else
-		{
-			GetDragonSoulInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
-			return;
-		}
-	}
-#endif
-}
-
-// 20200808.Owsap : Fix book stacking while sorting.
-void CHARACTER::GiveSkillBook(DWORD dwSkillVnum, WORD wCount)
-{
-	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-	{
-		LPITEM pkItem = GetInventoryItem(i);
-
-		if (!pkItem)
-			continue;
-
-		if ((pkItem->GetType() == ITEM_SKILLBOOK || pkItem->GetType() == ITEM_SKILLFORGET) && pkItem->GetSocket(0) == dwSkillVnum)
-		{
-			WORD wCount2 = MIN(ITEM_MAX_COUNT - pkItem->GetCount(), wCount);
-			wCount -= wCount2;
-
-			pkItem->SetCount(pkItem->GetCount() + wCount2);
-			if (wCount == 0)
-				return;
-		}
-	}
-
-	LPITEM pkBookItem = AutoGiveItem(ITEM_SKILLBOOK_VNUM, wCount, false, false);
-	if (NULL != pkBookItem)
-		pkBookItem->SetSocket(0, dwSkillVnum);
-}
-//>
-
-LPITEM CHARACTER::AutoGiveItem(DWORD dwItemVnum, WORD wCount, int iRarePct, bool bMsg
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-	, bool isHighLight
-#endif
-#if defined(__NEW_USER_CARE__)
-	, bool bSystemDrop
-#endif
-)
-{
-	TItemTable* p = ITEM_MANAGER::instance().GetTable(dwItemVnum);
-	if (!p)
-		return NULL;
-
-	DBManager::instance().SendMoneyLog(MONEY_LOG_DROP, dwItemVnum, wCount);
-
-	if (p->dwFlags & ITEM_FLAG_STACKABLE/* && p->bType != ITEM_BLEND*/)
-	{
-		for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
-		{
-			LPITEM item = GetInventoryItem(i);
-
-			if (!item)
-				continue;
-
-			if (item->GetVnum() == dwItemVnum && FN_check_item_socket(item))
-			{
-				if (IS_SET(p->dwFlags, ITEM_FLAG_MAKECOUNT))
-				{
-					if (wCount < p->alValues[1])
-						wCount = p->alValues[1];
-				}
-
-				WORD wCount2 = MIN(ITEM_MAX_COUNT - item->GetCount(), wCount);
-				wCount -= wCount2;
-
-				item->SetCount(item->GetCount() + wCount2);
-
-				if (wCount == 0)
-				{
-					if (bMsg)
-					{
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#	if defined(__SET_ITEM__)
-						ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#	else
-						ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#	endif
-#else
-#	if defined(__SET_ITEM__)
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#	else
-						ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#	endif
-#endif
-					}
-
-					return item;
-				}
-			}
-		}
-	}
-
-	LPITEM item = ITEM_MANAGER::instance().CreateItem(dwItemVnum, wCount, 0, true);
-
-	if (!item)
-	{
-		sys_err("cannot create item by vnum %u (name: %s)", dwItemVnum, GetName());
-		return NULL;
-	}
-
-	if (item->GetType() == ITEM_BLEND)
-	{
-		for (int i = 0; i < INVENTORY_MAX_NUM; i++)
-		{
-			LPITEM inv_item = GetInventoryItem(i);
-
-			if (inv_item == NULL)
-				continue;
-
-			if (inv_item->GetType() == ITEM_BLEND)
-			{
-				if (inv_item->GetVnum() == item->GetVnum())
-				{
-					if (inv_item->GetSocket(0) == item->GetSocket(0) &&
-						inv_item->GetSocket(1) == item->GetSocket(1) &&
-						inv_item->GetSocket(2) == item->GetSocket(2) &&
-						inv_item->GetCount() + item->GetCount() <= ITEM_MAX_COUNT)
-					{
-						inv_item->SetCount(inv_item->GetCount() + item->GetCount());
-						M2_DESTROY_ITEM(item);
-						return inv_item;
-					}
-				}
-			}
-		}
-	}
-
-	int iEmptyCell;
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (item->IsDragonSoul())
-		iEmptyCell = GetEmptyDragonSoulInventory(item);
-	else
-#endif
-		iEmptyCell = GetEmptyInventory(item->GetSize());
-
-	if (iEmptyCell != -1)
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-			item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
-		else
-#endif
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell), isHighLight);
-#else
-			item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell));
-#endif
-
-		if (bMsg)
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#endif
-#endif
-
-		LogManager::instance().ItemLog(this, item, "SYSTEM", item->GetName());
-
-		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_POTION)
-		{
-			TQuickslot* pSlot;
-
-			if (GetQuickslot(0, &pSlot) && pSlot->type == SLOT_TYPE_NONE)
-			{
-				TQuickslot slot;
-				slot.type = SLOT_TYPE_INVENTORY;
-				slot.pos = iEmptyCell;
-				SetQuickslot(0, slot);
-			}
-		}
-	}
-	else
-	{
-#if defined(__NEW_USER_CARE__)
-		if (!bSystemDrop)
-		{
-			sys_log(0, "AutoGiveItem: No inventory space, SystemDrop disabled!");
-
-			M2_DESTROY_ITEM(item);
-			return NULL;
-		}
-#endif
-
-		item->AddToGround(GetMapIndex(), GetXYZ());
-		item->StartDestroyEvent();
-		// ¾ÈÆ¼ µå¶ø flag°¡ °É·ÁÀÖ´Â ¾ÆÀÌÅÛÀÇ °æ¿ì,
-		// ÀÎº¥¿¡ ºó °ø°£ÀÌ ¾ø¾î¼­ ¾îÂ¿ ¼ö ¾øÀÌ ¶³¾îÆ®¸®°Ô µÇ¸é,
-		// ownershipÀ» ¾ÆÀÌÅÛÀÌ »ç¶óÁú ¶§±îÁö(300ÃÊ) À¯ÁöÇÑ´Ù.
-		if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DROP))
-			item->SetOwnership(this, 300);
-		else
-			item->SetOwnership(this, 60);
-
-		LogManager::instance().ItemLog(this, item, "SYSTEM_DROP", item->GetName());
-	}
-
-	sys_log(0, "7: %d %d", dwItemVnum, wCount);
-	return item;
-}
-
-#define __AUTO_GIVE_ITEM_STACK__
-void CHARACTER::AutoGiveItem(LPITEM item, bool longOwnerShip, bool bMsg
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-	, bool isHighLight
-#endif
-)
-{
-	if (NULL == item)
-	{
-		sys_err("NULL point.");
-		return;
-	}
-
-	if (item->GetOwner())
-	{
-		sys_err("item %d 's owner exists!", item->GetID());
-		return;
-	}
-
-#if defined(__AUTO_GIVE_ITEM_STACK__)
-	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
-	{
-		for (WORD i = 0; i < INVENTORY_MAX_NUM; ++i)
-		{
-			LPITEM item2 = GetInventoryItem(i);
-			if (!item2)
-				continue;
-
-			if (item2->GetVnum() != item->GetVnum())
-				continue;
-
-			BYTE j = 0;
-			for (; j < ITEM_SOCKET_MAX_NUM; ++j)
-				if (item2->GetSocket(j) != item->GetSocket(j))
-					break;
-
-			if (j != ITEM_SOCKET_MAX_NUM)
-				continue;
-
-			if (item2->GetCount() >= ITEM_MAX_COUNT)
-				continue;
-
-			WORD wCount = item->GetCount();
-			if (IS_SET(item->GetFlag(), ITEM_FLAG_MAKECOUNT))
-			{
-				if (wCount < item->GetValue(1))
-					wCount = item->GetValue(1);
-			}
-
-			WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
-			wCount -= wCount2;
-			item2->SetCount(item2->GetCount() + wCount2);
-
-			if (wCount == 0)
-			{
-				if (bMsg)
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-					ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-					ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#endif
-#endif
-
-				M2_DESTROY_ITEM(item);
-
-				return;
-			}
-
-			item->SetCount(wCount);
-		}
-	}
-#endif
-
-	int cell;
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (item->IsDragonSoul())
-	{
-		cell = GetEmptyDragonSoulInventory(item);
-	}
-	else
-#endif
-	{
-		cell = GetEmptyInventory(item->GetSize());
-	}
-
-	if (cell != -1)
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-			item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, cell));
-		else
-#endif
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			item->AddToCharacter(this, TItemPos(INVENTORY, cell), isHighLight);
-#else
-			item->AddToCharacter(this, TItemPos(INVENTORY, cell));
-#endif
-
-		if (bMsg)
-#if defined(__CHATTING_WINDOW_RENEWAL__)
-#if defined(__SET_ITEM__)
-			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#endif
-#else
-#if defined(__SET_ITEM__)
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
-#else
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÀÌÅÛ È¹µæ: %s", LC_ITEM(item->GetVnum())));
-#endif
-#endif
-
-		LogManager::instance().ItemLog(this, item, "SYSTEM", item->GetName());
-
-		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_POTION)
-		{
-			TQuickslot* pSlot;
-
-			if (GetQuickslot(0, &pSlot) && pSlot->type == SLOT_TYPE_NONE)
-			{
-				TQuickslot slot;
-				slot.type = SLOT_TYPE_INVENTORY;
-				slot.pos = cell;
-				SetQuickslot(0, slot);
-			}
-		}
-	}
-	else
-	{
-		item->AddToGround(GetMapIndex(), GetXYZ());
-		item->StartDestroyEvent();
-
-		if (longOwnerShip)
-			item->SetOwnership(this, 300);
-		else
-			item->SetOwnership(this, 60);
-
-		LogManager::instance().ItemLog(this, item, "SYSTEM_DROP", item->GetName());
-	}
-}
-
-bool CHARACTER::GiveItem(LPCHARACTER victim, TItemPos Cell)
-{
-	if (!CanHandleItem())
-		return false;
-
-	if (IsRunningQuest())
-		return false;
-
-	LPITEM item = GetItem(Cell);
-	if (item && !item->IsExchanging())
-	{
-		if (victim->CanReceiveItem(this, item))
-		{
-			victim->ReceiveItem(this, item);
-			return true;
-		}
-	}
-
-	return false;
-}
-
-bool CHARACTER::CanReceiveItem(LPCHARACTER from, LPITEM item) const
-{
-	if (IsPC())
-		return false;
-
-	// TOO_LONG_DISTANCE_EXCHANGE_BUG_FIX
-	if (DISTANCE_APPROX(GetX() - from->GetX(), GetY() - from->GetY()) > 2000)
-		return false;
-	// END_OF_TOO_LONG_DISTANCE_EXCHANGE_BUG_FIX
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (item->IsSealed())
-	{
-		from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot improve a soulbound item."));
-		return false;
-	}
-#endif
-
-	switch (GetRaceNum())
-	{
-		case fishing::CAMPFIRE_MOB:
-		{
-			if (item->GetType() == ITEM_FISH &&
-				(item->GetSubType() == FISH_ALIVE || item->GetSubType() == FISH_DEAD))
-				return true;
-		}
-		break;
-
-		case fishing::FISHER_MOB:
-		{
-			if (item->GetType() == ITEM_ROD)
-				return true;
-		}
-		break;
-
-		// BUILDING_NPC
-		case BLACKSMITH_WEAPON_MOB:
-		case DEVILTOWER_BLACKSMITH_WEAPON_MOB:
-		{
-			if (item->GetType() == ITEM_WEAPON &&
-				item->GetRefinedVnum())
-				return true;
-			else
-				return false;
-		}
-		break;
-
-		case BLACKSMITH_ARMOR_MOB:
-		case DEVILTOWER_BLACKSMITH_ARMOR_MOB:
-		{
-			if (item->GetType() == ITEM_ARMOR &&
-				(item->GetSubType() == ARMOR_BODY || item->GetSubType() == ARMOR_SHIELD || item->GetSubType() == ARMOR_HEAD) &&
-				item->GetRefinedVnum())
-				return true;
-			else
-				return false;
-		}
-		break;
-
-		case BLACKSMITH_ACCESSORY_MOB:
-		case DEVILTOWER_BLACKSMITH_ACCESSORY_MOB:
-		{
-			if (item->GetType() == ITEM_ARMOR &&
-				!(item->GetSubType() == ARMOR_BODY || item->GetSubType() == ARMOR_SHIELD || item->GetSubType() == ARMOR_HEAD) &&
-				item->GetRefinedVnum())
-				return true;
-			else
-				return false;
-		}
-		break;
-		// END_OF_BUILDING_NPC
-
-		case BLACKSMITH_MOB:
-		{
-			if (item->GetRefinedVnum() && item->GetRefineSet() < 500)
-				return true;
-			else
-				return false;
-		}
-		break;
-
-		case BLACKSMITH2_MOB:
-		{
-			if (item->GetRefineSet() >= 500)
-				return true;
-			else
-				return false;
-		}
-		break;
-
-		case ALCHEMIST_MOB:
-		{
-			if (item->GetRefinedVnum())
-				return true;
-		}
-		break;
-
-		case 20101:
-		case 20102:
-		case 20103:
-		{
-			// ÃÊ±Þ ¸»
-			if (item->GetVnum() == ITEM_REVIVE_HORSE_1)
-			{
-				if (!IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Á×Áö ¾ÊÀº ¸»¿¡°Ô ¼±ÃÊ¸¦ ¸ÔÀÏ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_1)
-			{
-				if (IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Á×Àº ¸»¿¡°Ô »ç·á¸¦ ¸ÔÀÏ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_2 || item->GetVnum() == ITEM_HORSE_FOOD_3)
-			{
-				return false;
-			}
-		}
-		break;
-
-		case 20104:
-		case 20105:
-		case 20106:
-		{
-			// Áß±Þ ¸»
-			if (item->GetVnum() == ITEM_REVIVE_HORSE_2)
-			{
-				if (!IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Á×Áö ¾ÊÀº ¸»¿¡°Ô ¼±ÃÊ¸¦ ¸ÔÀÏ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_2)
-			{
-				if (IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Á×Àº ¸»¿¡°Ô »ç·á¸¦ ¸ÔÀÏ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 || item->GetVnum() == ITEM_HORSE_FOOD_3)
-			{
-				return false;
-			}
-		}
-		break;
-
-		case 20107:
-		case 20108:
-		case 20109:
-		{
-			// °í±Þ ¸»
-			if (item->GetVnum() == ITEM_REVIVE_HORSE_3)
-			{
-				if (!IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Á×Áö ¾ÊÀº ¸»¿¡°Ô ¼±ÃÊ¸¦ ¸ÔÀÏ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_3)
-			{
-				if (IsDead())
-				{
-					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Á×Àº ¸»¿¡°Ô »ç·á¸¦ ¸ÔÀÏ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-				return true;
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 || item->GetVnum() == ITEM_HORSE_FOOD_2)
-			{
-				return false;
-			}
-		}
-		break;
-
-		default:
-			break;
-	}
-
-	//if (IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_GIVE))
-	{
-		return true;
-	}
-
-	return false;
-}
-
-void CHARACTER::ReceiveItem(LPCHARACTER from, LPITEM item)
-{
-	if (IsPC())
-		return;
-
-	switch (GetRaceNum())
-	{
-		case fishing::CAMPFIRE_MOB:
-		{
-			if (item->GetType() == ITEM_FISH && (item->GetSubType() == FISH_ALIVE || item->GetSubType() == FISH_DEAD))
-				fishing::Grill(from, item);
-			else
-			{
-				// TAKE_ITEM_BUG_FIX
-				from->SetQuestNPCID(GetVID());
-				// END_OF_TAKE_ITEM_BUG_FIX
-				quest::CQuestManager::instance().TakeItem(from->GetPlayerID(), GetRaceNum(), item);
-			}
-		}
-		break;
-
-#ifdef ENABLE_QUEEN_NETHIS
-		case SnakeLair::PILAR_STEP_4:
-			{
-				if(from->IsPC())
-				{
-					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
-						SnakeLair::CSnk::instance().OnKillPilar(item, from, this);
-				}
-			}
-			break;
-		case SnakeLair::BLACKSMITH_5:
-			{
-				if(from->IsPC())
-				{
-					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
-						SnakeLair::CSnk::instance().OnKillBlackSmith(item, from, this);
-				}
-			}
-			break;
-
-		case SnakeLair::SNAKE_STATUE1:
-		case SnakeLair::SNAKE_STATUE2:
-		case SnakeLair::SNAKE_STATUE3:
-		case SnakeLair::SNAKE_STATUE4:
-			{
-				if(from->IsPC())
-				{
-					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
-						SnakeLair::CSnk::instance().OnStatueSetRotation(item, from, this);
-				}
-			}
-			break;
-#endif
-
-		// DEVILTOWER_NPC
-		case DEVILTOWER_BLACKSMITH_WEAPON_MOB:
-		case DEVILTOWER_BLACKSMITH_ARMOR_MOB:
-		case DEVILTOWER_BLACKSMITH_ACCESSORY_MOB:
-		{
-			if (item->GetRefinedVnum() != 0 && item->GetRefineSet() != 0 && item->GetRefineSet() < 500)
-			{
-				from->SetRefineNPC(this);
-				from->RefineInformation(item->GetCell(), REFINE_TYPE_MONEY_ONLY);
-			}
-			else
-			{
-				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀº °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-			}
-		}
-		break;
-		// END_OF_DEVILTOWER_NPC
-
-		case BLACKSMITH_MOB:
-		case BLACKSMITH2_MOB:
-		case BLACKSMITH_WEAPON_MOB:
-		case BLACKSMITH_ARMOR_MOB:
-		case BLACKSMITH_ACCESSORY_MOB:
-		{
-			if (item->GetRefinedVnum())
-			{
-				from->SetRefineNPC(this);
-				from->RefineInformation(item->GetCell(), REFINE_TYPE_NORMAL);
-			}
-			else
-			{
-				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ ¾ÆÀÌÅÛÀº °³·®ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-			}
-		}
-		break;
-
-		case 20101:
-		case 20102:
-		case 20103:
-		case 20104:
-		case 20105:
-		case 20106:
-		case 20107:
-		case 20108:
-		case 20109:
-		{
-			if (item->GetVnum() == ITEM_REVIVE_HORSE_1 ||
-				item->GetVnum() == ITEM_REVIVE_HORSE_2 ||
-				item->GetVnum() == ITEM_REVIVE_HORSE_3)
-			{
-				from->ReviveHorse();
-				item->SetCount(item->GetCount() - 1);
-				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¸»¿¡°Ô ¼±ÃÊ¸¦ ÁÖ¾ú½À´Ï´Ù."));
-			}
-			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 ||
-				item->GetVnum() == ITEM_HORSE_FOOD_2 ||
-				item->GetVnum() == ITEM_HORSE_FOOD_3)
-			{
-				from->FeedHorse();
-				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¸»¿¡°Ô »ç·á¸¦ ÁÖ¾ú½À´Ï´Ù."));
-				item->SetCount(item->GetCount() - 1);
-				EffectPacket(SE_HPUP_RED);
-			}
-		}
-		break;
-
-		default:
-		{
-			sys_log(0, "TakeItem %s %d %s", from->GetName(), GetRaceNum(), item->GetName());
-			from->SetQuestNPCID(GetVID());
-			quest::CQuestManager::instance().TakeItem(from->GetPlayerID(), GetRaceNum(), item);
-		}
-		break;
-	}
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-	if (CGuildDragonLairManager::Instance().IsRedDragonLair(from->GetMapIndex())
-		&& CGuildDragonLairManager::Instance().IsStone(GetRaceNum()))
-	{
-		if (item->GetVnum() == ITEM_GUILD_DRAGONLAIR_RING)
-		{
-			sys_log(0, "GuildDragonLair TakeItem %s %d %s", from->GetName(), GetRaceNum(), item->GetName());
-
-			if (from->GetGuildDragonLair())
-				from->GetGuildDragonLair()->TakeItem(from, this, item);
-		}
-	}
-#endif
-}
-
-bool CHARACTER::IsEquipUniqueItem(DWORD dwItemVnum) const
-{
-	{
-		LPITEM u = GetWear(WEAR_UNIQUE1);
-
-		if (u && u->GetVnum() == dwItemVnum)
-			return true;
-	}
-
-	{
-		LPITEM u = GetWear(WEAR_UNIQUE2);
-
-		if (u && u->GetVnum() == dwItemVnum)
-			return true;
-	}
-
-	return false;
-}
-
-// CHECK_UNIQUE_GROUP
-bool CHARACTER::IsEquipUniqueGroup(DWORD dwGroupVnum) const
-{
-	{
-		LPITEM u = GetWear(WEAR_UNIQUE1);
-
-		if (u && u->GetSpecialGroup() == (int)dwGroupVnum)
-			return true;
-	}
-
-	{
-		LPITEM u = GetWear(WEAR_UNIQUE2);
-
-		if (u && u->GetSpecialGroup() == (int)dwGroupVnum)
-			return true;
-	}
-
-	return false;
-}
-// END_OF_CHECK_UNIQUE_GROUP
-
-void CHARACTER::SetRefineMode(int iAdditionalCell)
-{
-	m_iRefineAdditionalCell = iAdditionalCell;
-	SetUnderRefine(true);
-}
-
-void CHARACTER::ClearRefineMode()
-{
-	SetUnderRefine(false);
-	SetRefineNPC(NULL);
-}
-
-//bool CHARACTER::GiveItemFromSpecialItemGroup(DWORD dwGroupNum, std::vector<DWORD>& dwItemVnums,
-//	std::vector<DWORD>& dwItemCounts, std::vector <LPITEM>& item_gets, int& count)
-bool CHARACTER::GiveItemFromSpecialItemGroup(DWORD dwGroupNum)
-{
-	const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(dwGroupNum);
-
-	if (!pGroup)
-	{
-		sys_err("cannot find special item group %d", dwGroupNum);
-		return false;
-	}
-
-	std::vector<int> idxes;
-	int n = pGroup->GetMultiIndex(idxes);
-
-	bool bSuccess = false;
-
-	for (int i = 0; i < n; i++)
-	{
-		bSuccess = false;
-		int idx = idxes[i];
-		DWORD dwVnum = pGroup->GetVnum(idx);
-		DWORD dwCount = pGroup->GetCount(idx);
-		int iRarePct = pGroup->GetRarePct(idx);
-		LPITEM item_get = NULL;
-		switch (dwVnum)
-		{
-			case CSpecialItemGroup::GOLD:
-			{
-				PointChange(POINT_GOLD, dwCount, true);
-				LogManager::instance().CharLog(this, dwCount, "TREASURE_GOLD", "");
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::EXP:
-			{
-				PointChange(POINT_EXP, dwCount);
-				LogManager::instance().CharLog(this, dwCount, "TREASURE_EXP", "");
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::MOB:
-			{
-				sys_log(0, "CSpecialItemGroup::MOB %d", dwCount);
-				int x = GetX() + number(-500, 500);
-				int y = GetY() + number(-500, 500);
-
-				LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(dwCount, GetMapIndex(), x, y, 0, true, -1);
-				if (ch)
-					ch->SetAggressive();
-				else
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("This doesn't seem to work here."));
-					return false;
-				}
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("»óÀÚ¿¡¼­ ¸ó½ºÅÍ°¡ ³ªÅ¸³µ½À´Ï´Ù!"));
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::SLOW:
-			{
-				sys_log(0, "CSpecialItemGroup::SLOW %d", -(int)dwCount);
-				AddAffect(AFFECT_SLOW, POINT_MOV_SPEED, -(int)dwCount, AFF_SLOW, 300, 0, true);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("»óÀÚ¿¡¼­ ³ª¿Â »¡°£ ¿¬±â¸¦ µéÀÌ¸¶½ÃÀÚ ¿òÁ÷ÀÌ´Â ¼Óµµ°¡ ´À·ÁÁ³½À´Ï´Ù!"));
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::DRAIN_HP:
-			{
-				int iDropHP = GetMaxHP() * dwCount / 100;
-				sys_log(0, "CSpecialItemGroup::DRAIN_HP %d", -iDropHP);
-				iDropHP = MIN(iDropHP, GetHP() - 1);
-				sys_log(0, "CSpecialItemGroup::DRAIN_HP %d", -iDropHP);
-				PointChange(POINT_HP, -iDropHP);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("»óÀÚ°¡ °©ÀÚ±â Æø¹ßÇÏ¿´½À´Ï´Ù! »ý¸í·ÂÀÌ °¨¼ÒÇß½À´Ï´Ù."));
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::POISON:
-			{
-				AttackedByPoison(NULL);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("»óÀÚ¿¡¼­ ³ª¿Â ³ì»ö ¿¬±â¸¦ µéÀÌ¸¶½ÃÀÚ µ¶ÀÌ ¿Â¸öÀ¸·Î ÆÛÁý´Ï´Ù!"));
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::BLEEDING:
-			{
-				AttackedByBleeding(NULL);
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("»óÀÚ¿¡¼­ ³ª¿Â »¡°£ ¿¬±â¸¦ µéÀÌ¸¶½ÃÀÚ ¿òÁ÷ÀÌ´Â ¼Óµµ°¡ ´À·ÁÁ³½À´Ï´Ù!"));
-				bSuccess = true;
-			}
-			break;
-
-			case CSpecialItemGroup::MOB_GROUP:
-			{
-				int sx = GetX() - number(300, 500);
-				int sy = GetY() - number(300, 500);
-				int ex = GetX() + number(300, 500);
-				int ey = GetY() + number(300, 500);
-				LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnGroup(dwCount, GetMapIndex(), sx, sy, ex, ey, NULL, true);
-				if (!ch)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("This doesn't seem to work here."));
-					return false;
-				}
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("»óÀÚ¿¡¼­ ¸ó½ºÅÍ°¡ ³ªÅ¸³µ½À´Ï´Ù!"));
-				bSuccess = true;
-			}
-			break;
-
-			default:
-			{
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-				item_get = AutoGiveItem(dwVnum, dwCount, iRarePct, true, true);
-#else
-				item_get = AutoGiveItem(dwVnum, dwCount, iRarePct);
-#endif
-				if (item_get)
-					bSuccess = true;
-			}
-			break;
-		}
-
-		if (!bSuccess)
-		{
-			ChatPacket(CHAT_TYPE_TALKING, LC_STRING("¾Æ¹«°Íµµ ¾òÀ» ¼ö ¾ø¾ú½À´Ï´Ù."));
-			return false;
-		}
-	}
-	return bSuccess;
-}
-
-// NEW_HAIR_STYLE_ADD
-bool CHARACTER::ItemProcess_Hair(LPITEM item, int iDestCell)
-{
-	if (item->CheckItemUseLevel(GetLevel()) == false)
-	{
-		// ·¹º§ Á¦ÇÑ¿¡ °É¸²
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("¾ÆÁ÷ ÀÌ ¸Ó¸®¸¦ »ç¿ëÇÒ ¼ö ¾ø´Â ·¹º§ÀÔ´Ï´Ù."));
-		return false;
-	}
-
-	DWORD hair = item->GetVnum();
-
-	switch (GetJob())
-	{
-		case JOB_WARRIOR:
-			hair -= 72000; // 73001 - 72000 = 1001 ºÎÅÍ Çì¾î ¹øÈ£ ½ÃÀÛ
-			break;
-
-		case JOB_ASSASSIN:
-			hair -= 71250;
-			break;
-
-		case JOB_SURA:
-			hair -= 70500;
-			break;
-
-		case JOB_SHAMAN:
-			hair -= 69750;
-			break;
-
-		case JOB_WOLFMAN:
-			break;
-
-		default:
-			return false;
-			break;
-	}
-
-	if (hair == GetPart(PART_HAIR))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("µ¿ÀÏÇÑ ¸Ó¸® ½ºÅ¸ÀÏ·Î´Â ±³Ã¼ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return true;
-	}
-
-	item->SetCount(item->GetCount() - 1);
-
-	SetPart(PART_HAIR, hair);
-	UpdatePacket();
-
-	return true;
-}
-// END_NEW_HAIR_STYLE_ADD
-
-bool CHARACTER::ItemProcess_Polymorph(LPITEM item)
-{
-	if (IsPolymorphed())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÀÌ¹Ì µÐ°©ÁßÀÎ »óÅÂÀÔ´Ï´Ù."));
-		return false;
-	}
-
-	if (true == IsRiding())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("µÐ°©ÇÒ ¼ö ¾ø´Â »óÅÂÀÔ´Ï´Ù."));
-		return false;
-	}
-
-	DWORD dwVnum = item->GetSocket(0);
-
-	if (dwVnum == 0)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Àß¸øµÈ µÐ°© ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-		item->SetCount(item->GetCount() - 1);
-		return false;
-	}
-
-	const CMob* pMob = CMobManager::instance().Get(dwVnum);
-
-	if (pMob == NULL)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Àß¸øµÈ µÐ°© ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-		item->SetCount(item->GetCount() - 1);
-		return false;
-	}
-
-	switch (item->GetVnum())
-	{
-		case 70104: // Polymorph Marble
-		case 70105: // Polymorph Marble
-		case 70106: // Polymorph Marble
-		case 70107: // Polymorph Marble
-		case 71093: // Polymorph Marble
-		{
-			// µÐ°©±¸ Ã³¸®
-			sys_log(0, "USE_POLYMORPH_BALL PID(%d) vnum(%d)", GetPlayerID(), dwVnum);
-
-			// ·¹º§ Á¦ÇÑ Ã¼Å©
-			int iPolymorphLevelLimit = MAX(0, 20 - GetLevel() * 3 / 10);
-			if (pMob->m_table.bLevel >= GetLevel() + iPolymorphLevelLimit)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("³ªº¸´Ù ³Ê¹« ³ôÀº ·¹º§ÀÇ ¸ó½ºÅÍ·Î´Â º¯½Å ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-				return false;
-			}
-
-			int iDuration = GetSkillLevel(POLYMORPH_SKILL_ID) == 0 ? 5 : (5 + (5 + GetSkillLevel(POLYMORPH_SKILL_ID) / 40 * 25));
-			iDuration *= 60;
-
-			DWORD dwBonus = 0;
-
-			if (true == LC_IsYMIR() || true == LC_IsKorea())
-			{
-				dwBonus = GetSkillLevel(POLYMORPH_SKILL_ID) + 60;
-			}
-			else
-			{
-				dwBonus = (2 + GetSkillLevel(POLYMORPH_SKILL_ID) / 40) * 100;
-			}
-
-			AddAffect(AFFECT_POLYMORPH, POINT_POLYMORPH, dwVnum, AFF_POLYMORPH, iDuration, 0, true);
-			AddAffect(AFFECT_POLYMORPH, POINT_ATT_BONUS, dwBonus, AFF_POLYMORPH, iDuration, 0, false);
-
-			item->SetCount(item->GetCount() - 1);
-		}
-		break;
-
-		case 50322: // Transformation Role
-		{
-			// º¸·ù
-
-			// µÐ°©¼­ Ã³¸®
-			// ¼ÒÄÏ0 ¼ÒÄÏ1 ¼ÒÄÏ2
-			// µÐ°©ÇÒ ¸ó½ºÅÍ ¹øÈ£ ¼ö·ÃÁ¤µµ µÐ°©¼­ ·¹º§
-			sys_log(0, "USE_POLYMORPH_BOOK: %s(%u) vnum(%u)", GetName(), GetPlayerID(), dwVnum);
-
-			if (CPolymorphUtils::instance().PolymorphCharacter(this, item, pMob) == true)
-			{
-				CPolymorphUtils::instance().UpdateBookPracticeGrade(this, item);
-			}
-			else
-			{
-			}
-		}
-		break;
-
-		default:
-			sys_err("POLYMORPH invalid item passed PID(%d) vnum(%d)", GetPlayerID(), item->GetOriginalVnum());
-			return false;
-	}
-
-	return true;
-}
-
-bool CHARACTER::CanDoCube() const
-{
-	if (m_bIsObserver) return false;
-	if (GetShop()) return false;
-	if (GetMyShop()) return false;
-	if (IsUnderRefine()) return false;
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-	if (IsUnderRefineElement()) return false;
-#endif
-	if (IsWarping()) return false;
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	if (IsAcceRefineWindowOpen()) return false;
-#endif
-#if defined(__AURA_COSTUME_SYSTEM__)
-	if (IsAuraRefineWindowOpen()) return false;
-#endif
-
-	return true;
-}
-
-bool CHARACTER::UnEquipSpecialRideUniqueItem()
-{
-	LPITEM Unique1 = GetWear(WEAR_UNIQUE1);
-	LPITEM Unique2 = GetWear(WEAR_UNIQUE2);
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	LPITEM MountCostume = GetWear(WEAR_COSTUME_MOUNT);
-#endif
-
-	if (NULL != Unique1)
-	{
-		if (UNIQUE_GROUP_SPECIAL_RIDE == Unique1->GetSpecialGroup())
-		{
-			return UnequipItem(Unique1);
-		}
-	}
-
-	if (NULL != Unique2)
-	{
-		if (UNIQUE_GROUP_SPECIAL_RIDE == Unique2->GetSpecialGroup())
-		{
-			return UnequipItem(Unique2);
-		}
-	}
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	if (MountCostume)
-		return UnequipItem(MountCostume);
-#endif
-
-	return true;
-}
-
-void CHARACTER::AutoRecoveryItemProcess(const EAffectTypes type)
-{
-	if (true == IsDead() || true == IsStun())
-		return;
-
-	if (false == IsPC())
-		return;
-
-	if (AFFECT_AUTO_HP_RECOVERY != type && AFFECT_AUTO_SP_RECOVERY != type)
-		return;
-
-	if (NULL != FindAffect(AFFECT_STUN))
-		return;
-
-	{
-		const DWORD stunSkills[] = { SKILL_TANHWAN, SKILL_GEOMPUNG, SKILL_BYEURAK, SKILL_GIGUNG };
-
-		for (size_t i = 0; i < sizeof(stunSkills) / sizeof(DWORD); ++i)
-		{
-			const CAffect* p = FindAffect(stunSkills[i]);
-
-			if (NULL != p && AFF_STUN == p->dwFlag)
-				return;
-		}
-	}
-
-	const CAffect* pAffect = FindAffect(type);
-	const size_t idx_of_amount_of_used = 1;
-	const size_t idx_of_amount_of_full = 2;
-
-	if (NULL != pAffect)
-	{
-		LPITEM pItem = FindItemByID(pAffect->dwFlag);
-
-		if ((NULL != pItem) && (pItem->GetSocket(0) > 0))
-		{
-			if (false == CArenaManager::instance().IsArenaMap(GetMapIndex()))
-			{
-				const long amount_of_used = pItem->GetSocket(idx_of_amount_of_used);
-				const long amount_of_full = pItem->GetSocket(idx_of_amount_of_full);
-
-				const int32_t avail = amount_of_full - amount_of_used;
-
-				int32_t amount = 0;
-
-				if (AFFECT_AUTO_HP_RECOVERY == type)
-				{
-					amount = GetMaxHP() - (GetHP() + GetPoint(POINT_HP_RECOVERY));
-				}
-				else if (AFFECT_AUTO_SP_RECOVERY == type)
-				{
-					amount = GetMaxSP() - (GetSP() + GetPoint(POINT_SP_RECOVERY));
-				}
-
-				if (amount > 0)
-				{
-					if (avail > amount)
-					{
-						const int pct_of_used = amount_of_used * 100 / amount_of_full;
-						const int pct_of_will_used = (amount_of_used + amount) * 100 / amount_of_full;
-
-						bool bLog = false;
-						// »ç¿ë·®ÀÇ 10% ´ÜÀ§·Î ·Î±×¸¦ ³²±è
-						// (»ç¿ë·®ÀÇ %¿¡¼­, ½ÊÀÇ ÀÚ¸®°¡ ¹Ù²ð ¶§¸¶´Ù ·Î±×¸¦ ³²±è.)
-						if ((pct_of_will_used / 10) - (pct_of_used / 10) >= 1)
-							bLog = true;
-						pItem->SetSocket(idx_of_amount_of_used, amount_of_used + amount, bLog);
-					}
-					else
-					{
-						amount = avail;
-
-#if defined(__USE_NEXT_AUTO_POTION__)
-						for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
-						{
-							LPITEM pkNextItem = GetInventoryItem(wCell);
-							if (NULL == pkNextItem)
-								continue;
-
-							if (pItem->GetWindow() == pkNextItem->GetWindow() && pItem->GetCell() != pkNextItem->GetCell())
-							{
-								UseItemEx(pkNextItem, TItemPos(INVENTORY, wCell));
-								break;
-							}
-						}
-#endif
-
-						ITEM_MANAGER::instance().RemoveItem(pItem);
-					}
-
-					if (AFFECT_AUTO_HP_RECOVERY == type)
-					{
-						PointChange(POINT_HP_RECOVERY, amount);
-						EffectPacket(SE_AUTO_HPUP);
-					}
-					else if (AFFECT_AUTO_SP_RECOVERY == type)
-					{
-						PointChange(POINT_SP_RECOVERY, amount);
-						EffectPacket(SE_AUTO_SPUP);
-					}
-				}
-			}
-			else
-			{
-				pItem->Lock(false);
-				pItem->SetSocket(0, false);
-				RemoveAffect(const_cast<CAffect*>(pAffect));
-			}
-		}
-		else
-		{
-			RemoveAffect(const_cast<CAffect*>(pAffect));
-		}
-	}
-}
-
-bool CHARACTER::IsValidItemPosition(TItemPos Pos) const
-{
-	BYTE window_type = Pos.window_type;
-	WORD cell = Pos.cell;
-
-	switch (window_type)
-	{
-		case INVENTORY:
-			return cell < INVENTORY_MAX_NUM;
-
-		case EQUIPMENT:
-			return cell < EQUIPMENT_MAX_NUM;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case DRAGON_SOUL_INVENTORY:
-			return cell < DRAGON_SOUL_INVENTORY_MAX_NUM;
-#endif
-
-		case BELT_INVENTORY:
-			return cell < BELT_INVENTORY_MAX_NUM;
-
-		case SAFEBOX:
-			if (NULL != m_pkSafebox)
-				return m_pkSafebox->IsValidPosition(cell);
-			else
-				return false;
-
-		case MALL:
-			if (NULL != m_pkMall)
-				return m_pkMall->IsValidPosition(cell);
-			else
-				return false;
-
-#if defined(__ATTR_6TH_7TH__)
-		case NPC_STORAGE:
-			return cell < NPC_STORAGE_SLOT_MAX;
-#endif
-
-		default:
-			return false;
-	}
-}
-
-/// ÇöÀç Ä³¸¯ÅÍÀÇ »óÅÂ¸¦ ¹ÙÅÁÀ¸·Î ÁÖ¾îÁø itemÀ» Âø¿ëÇÒ ¼ö ÀÖ´Â Áö È®ÀÎÇÏ°í, ºÒ°¡´É ÇÏ´Ù¸é Ä³¸¯ÅÍ¿¡°Ô ÀÌÀ¯¸¦ ¾Ë·ÁÁÖ´Â ÇÔ¼ö
-bool CHARACTER::CanEquipNow(const LPITEM item, const TItemPos& srcCell, const TItemPos& destCell) /*const*/
-{
-	if (IsFishing())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
-		return false;
-	}
-
-	const TItemTable* itemTable = item->GetProto();
-	//BYTE itemType = item->GetType();
-	//BYTE itemSubType = item->GetSubType();
-
-	switch (GetJob())
-	{
-		case JOB_WARRIOR:
-			if (item->GetAntiFlag() & ITEM_ANTIFLAG_WARRIOR)
-				return false;
-			break;
-
-		case JOB_ASSASSIN:
-			if (item->GetAntiFlag() & ITEM_ANTIFLAG_ASSASSIN)
-				return false;
-			break;
-
-		case JOB_SHAMAN:
-			if (item->GetAntiFlag() & ITEM_ANTIFLAG_SHAMAN)
-				return false;
-			break;
-
-		case JOB_SURA:
-			if (item->GetAntiFlag() & ITEM_ANTIFLAG_SURA)
-				return false;
-			break;
-
-		case JOB_WOLFMAN:
-			if (item->GetAntiFlag() & ITEM_ANTIFLAG_WOLFMAN)
-				return false;
-			break;
-
-	}
-
-	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
-	{
-		long limit = itemTable->aLimits[i].lValue;
-		switch (itemTable->aLimits[i].bType)
-		{
-			case LIMIT_LEVEL:
-			{
-				if (GetLevel() < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("·¹º§ÀÌ ³·¾Æ Âø¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-			}
-			break;
-
-#if defined(__CONQUEROR_LEVEL__)
-			case LIMIT_NEWWORLD_LEVEL:
-			{
-				if (GetConquerorLevel() < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("·¹º§ÀÌ ³·¾Æ Âø¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-			}
-			break;
-#endif
-
-			case LIMIT_STR:
-			{
-				if (GetPoint(POINT_ST) < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("±Ù·ÂÀÌ ³·¾Æ Âø¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-			}
-			break;
-
-			case LIMIT_INT:
-			{
-				if (GetPoint(POINT_IQ) < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("Áö´ÉÀÌ ³·¾Æ Âø¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-			}
-			break;
-
-			case LIMIT_DEX:
-			{
-				if (GetPoint(POINT_DX) < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("¹ÎÃ¸ÀÌ ³·¾Æ Âø¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-			}
-			break;
-
-			case LIMIT_CON:
-			{
-				if (GetPoint(POINT_HT) < limit)
-				{
-					ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¼·ÂÀÌ ³·¾Æ Âø¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-					return false;
-				}
-			}
-			break;
-		}
-	}
-
-	if (item->GetWearFlag() & WEARABLE_UNIQUE)
-	{
-		if ((GetWear(WEAR_UNIQUE1) && GetWear(WEAR_UNIQUE1)->IsSameSpecialGroup(item)) ||
-			(GetWear(WEAR_UNIQUE2) && GetWear(WEAR_UNIQUE2)->IsSameSpecialGroup(item)))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("°°Àº Á¾·ùÀÇ À¯´ÏÅ© ¾ÆÀÌÅÛ µÎ °³¸¦ µ¿½Ã¿¡ ÀåÂøÇÒ ¼ö ¾ø½À´Ï´Ù."));
-			return false;
-		}
-
-		if (marriage::CManager::instance().IsMarriageUniqueItem(item->GetVnum()) &&
-			!marriage::CManager::instance().IsMarried(GetPlayerID()))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("°áÈ¥ÇÏÁö ¾ÊÀº »óÅÂ¿¡¼­ ¿¹¹°À» Âø¿ëÇÒ ¼ö ¾ø½À´Ï´Ù."));
-			return false;
-		}
-	}
-
-#if defined(__PET_SYSTEM__)
-	if (item->IsPet() && SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::PET_BLOCK_MAP_INDEX, GetMapIndex()))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
-		return false;
-	}
-#endif
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-	if (item->IsCostumeMount() && SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX, GetMapIndex()))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
-		return false;
-	}
-#endif
-
-	return true;
-}
-
-/// ÇöÀç Ä³¸¯ÅÍÀÇ »óÅÂ¸¦ ¹ÙÅÁÀ¸·Î Âø¿ë ÁßÀÎ itemÀ» ¹þÀ» ¼ö ÀÖ´Â Áö È®ÀÎÇÏ°í, ºÒ°¡´É ÇÏ´Ù¸é Ä³¸¯ÅÍ¿¡°Ô ÀÌÀ¯¸¦ ¾Ë·ÁÁÖ´Â ÇÔ¼ö
-bool CHARACTER::CanUnequipNow(const LPITEM item, const TItemPos& srcCell, const TItemPos& destCell) /*const*/
-//bool CHARACTER::CanUnequipNow(const LPITEM item, const TItemPos& swapCell) /*const*/
-{
-	if (item->IsBelt())
-	{
-		if (CBeltInventoryHelper::IsExistItemInBeltInventory(this))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can only discard the belt when there are no longer any items in its inventory."));
-			return false;
-		}
-	}
-
-	// ¿µ¿øÈ÷ ÇØÁ¦ÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛ
-	if (IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-		return false;
-
-	if (IsFishing())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
-		return false;
-	}
-
-	// ¾ÆÀÌÅÛ unequip½Ã ÀÎº¥Åä¸®·Î ¿Å±æ ¶§ ºó ÀÚ¸®°¡ ÀÖ´Â Áö È®ÀÎ
-	{
-		int pos = -1;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-			pos = GetEmptyDragonSoulInventory(item);
-		else
-#endif
-			pos = GetEmptyInventory(item->GetSize());
-
-		if (-1 == pos)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼ÒÁöÇ°¿¡ ºó °ø°£ÀÌ ¾ø½À´Ï´Ù."));
-			return false;
-		}
-	}
-
-	return true;
-}
-
-#ifdef __OFFLINE_SHOP__
-bool CHARACTER::UseItemOpenOfflineShop(CItem* item)
-{
-	if (!item) {
-		return false;
-	}
-
-	if (IsOpeningOfflineShop()) {
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ZATEN_PAZAR_ACIYORSUN"));
-		return false;
-	}
-
-	item->Lock(true);
-	SetOpeningOfflineShopState(true);
-	SetOfflineShopOpeningItem(item);
-
-	ChatPacket(CHAT_TYPE_COMMAND, "StartOpeningOfflineShop %d %lld",
-		item->GetValue(COfflineShop::ITEM_TIME_IDX), item->GetValue(COfflineShop::ITEM_GOLD_IDX));
-
-	return true;
-}
-#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-void CHARACTER::OpenItemComb()
-{
-	if (PreventTradeWindow(WND_ALL))
-	{
-		ChatPacket(CHAT_TYPE_INFO, "You have to close other windows.");
-		return;
-	}
-
-	const LPCHARACTER npc = GetQuestNPC();
-	if (npc == NULL)
-	{
-		sys_err("Item Combination NPC is NULL (ch: %s)", GetName());
-		return;
-	}
-
-	SetItemCombNpc(npc);
-	ChatPacket(CHAT_TYPE_COMMAND, "ShowItemCombinationDialog");
-}
-
-void CHARACTER::ItemCombination(const short MediumIndex, const short BaseIndex, const short MaterialIndex)
-{
-	if (IsItemComb() == false)
-		return;
-
-	const LPITEM MediumItem = GetItem(TItemPos(INVENTORY, MediumIndex));
-	const LPITEM BaseItem = GetItem(TItemPos(INVENTORY, BaseIndex));
-	const LPITEM MaterialItem = GetItem(TItemPos(INVENTORY, MaterialIndex));
-
-	if (MediumItem == NULL || BaseItem == NULL || MaterialItem == NULL)
-		return;
-
-	if (MediumItem->GetType() != ITEM_MEDIUM)
-		return;
-
-	if (BaseItem->GetType() != MaterialItem->GetType())
-		return;
-
-	if (BaseItem->GetSubType() != MaterialItem->GetSubType())
-		return;
-
-	if (BaseItem->GetType() != EItemTypes::ITEM_COSTUME || MaterialItem->GetType() != EItemTypes::ITEM_COSTUME)
-		return;
-
-	if (BaseItem->IsEquipped() || MaterialItem->IsEquipped())
-		return;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (BaseItem->IsSealed() || MaterialItem->IsSealed())
-		return;
-#endif
-
-	if (MediumItem->GetSubType() == MEDIUM_MOVE_COSTUME_ATTR)
-	{
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-		if (BaseItem->GetSubType() == COSTUME_MOUNT || MaterialItem->GetSubType() == COSTUME_MOUNT)
-			return;
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		if (BaseItem->GetSubType() == COSTUME_ACCE || MaterialItem->GetSubType() == COSTUME_ACCE)
-			return;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-		if (BaseItem->GetSubType() == COSTUME_AURA || MaterialItem->GetSubType() == COSTUME_AURA)
-			return;
-#endif
-
-		BaseItem->SetAttributes(MaterialItem->GetAttributes());
-		BaseItem->UpdatePacket();
-
-		ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
-		MediumItem->SetCount(MediumItem->GetCount() - 1);
-	}
-#if defined(__ACCE_COSTUME_SYSTEM__)
-	else if (MediumItem->GetSubType() == MEDIUM_MOVE_ACCE_ATTR)
-	{
-		if (MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_ITEM_VNUM) == 0)
-		{
-			if (MaterialItem->GetAttributeCount() == 0)
-			{
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use a sash without a bonus as the source."));
-				return;
-			}
-		}
-
-		if (BaseItem->GetAttributeCount() > 0)
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use a sash with a bonus for the target."));
-			return;
-		}
-
-		if (BaseItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) != MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot transfer the bonus as the sashes have different absorption rates."));
-			return;
-		}
-
-		if (BaseItem->FindApplyValue(APPLY_ACCEDRAIN_RATE) != MaterialItem->FindApplyValue(APPLY_ACCEDRAIN_RATE))
-		{
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot transfer the bonus as the sashes have different grades."));
-			return;
-		}
-
-		int iRandom = number(0, EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_MAX - 1);
-		switch (iRandom)
-		{
-			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_FAIL:
-			{
-				MaterialItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE, MAX(MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) - 1, 11));
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Failure! The absorption rate was reduced by 1%."));
-			}
-			break;
-
-			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_PARTIAL:
-			{
-				BaseItem->SetSockets(MaterialItem->GetSockets());
-				BaseItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE, MAX(MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) - 1, 11));
-				BaseItem->SetAttributes(MaterialItem->GetAttributes());
-#if defined(__ITEM_APPLY_RANDOM__)
-				MaterialItem->CopyRandomAppliesTo(BaseItem);
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				MaterialItem->CopyElementTo(BaseItem);
-#endif
-				BaseItem->UpdatePacket();
-
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Partial success! The absorption rate was reduced by 1%."));
-				ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
-			}
-			break;
-
-			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_SUCCESS:
-			{
-				BaseItem->SetSockets(MaterialItem->GetSockets());
-				BaseItem->SetAttributes(MaterialItem->GetAttributes());
-#if defined(__ITEM_APPLY_RANDOM__)
-				MaterialItem->CopyRandomAppliesTo(BaseItem);
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-				MaterialItem->CopyElementTo(BaseItem);
-#endif
-				BaseItem->UpdatePacket();
-
-				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Success! The bonus was transferred successfully."));
-				ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
-			}
-			break;
-		}
-
-		MediumItem->SetCount(MediumItem->GetCount() - 1);
-	}
-#endif
-}
-#endif
-
-#if defined(__CHANGED_ATTR__)
-void CHARACTER::SelectAttr(LPITEM material, LPITEM item)
-{
-	const LPDESC d = GetDesc();
-	if (d == nullptr)
-		return;
-
-	if (PreventTradeWindow(WND_ALL))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot upgrade anything while another window is open."));
-		return;
-	}
-
-	if (item->GetAttributeSetIndex() == -1)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("¼Ó¼ºÀ» º¯°æÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù."));
-		return;
-	}
-
-	if (item->GetAttributeCount() < 1)
-		return;
-
-	const TItemPos pos(item->GetWindow(), item->GetCell());
-	if (pos.IsInventoryPosition() == false)
-		return;
-
-	m_ItemSelectAttr.dwItemID = item->GetID();
-	item->GetSelectAttr(m_ItemSelectAttr.Attr);
-
-	TPacketGCItemSelectAttr p;
-	p.bHeader = HEADER_GC_ITEM_SELECT_ATTR;
-	p.pItemPos = pos;
-	std::copy(std::begin(m_ItemSelectAttr.Attr), std::end(m_ItemSelectAttr.Attr), std::begin(p.aAttr));
-	d->Packet(&p, sizeof p);
-
-	material->SetCount(material->GetCount() - 1);
-}
-
-void CHARACTER::SelectAttrResult(const bool bNew, const TItemPos& pos)
-{
-	if (IsSelectAttr() == false)
-		return;
-
-	if (bNew)
-	{
-		const LPITEM item = GetItem(pos);
-		if (item && item->GetID() == m_ItemSelectAttr.dwItemID)
-		{
-			item->SetAttributes(m_ItemSelectAttr.Attr);
-			item->UpdatePacket();
-			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have changed the upgrade."));
-		}
-	}
-
-	memset(&m_ItemSelectAttr, 0, sizeof m_ItemSelectAttr);
-}
-
-bool CHARACTER::IsSelectAttr() const
-{
-	return m_ItemSelectAttr.dwItemID != 0;
-}
-#endif
-
-#if defined(__LUCKY_BOX__)
-void CHARACTER::SetLuckyBoxSrcItem(const LPITEM c_lpItem)
-{
-	if (c_lpItem == nullptr)
-		return;
-
-	if (PreventTradeWindow(WND_ALL))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have to close other windows."));
-		return;
-	}
-
-	ResetLuckyBoxData();
-
-	m_sLuckyBox.dwSrcItemVNum = c_lpItem->GetVnum();
-	m_sLuckyBox.dwSrcItemID = c_lpItem->GetID();
-	m_sLuckyBox.wSrcSlotIndex = c_lpItem->GetCell();
-
-	SendLuckyBoxInfo();
-}
-
-void CHARACTER::SendLuckyBoxInfo()
-{
-	if (!IsLuckyBoxOpen())
-		return;
-
-	if (!GetDesc())
-		return;
-
-	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
-	if (!pLuckyBox)
-		return;
-
-	if (!pLuckyBox->ContainsItems(m_sLuckyBox.dwSrcItemVNum))
-	{
-		ResetLuckyBoxData();
-		return;
-	}
-
-	m_sLuckyBox.bTryCount++;
-
-	while (true)
-	{
-		const CLuckyBoxGroup::SLuckyBoxItemInfo& item = pLuckyBox->GetRandomItem(m_sLuckyBox.dwSrcItemVNum);
-		if (pLuckyBox->GetItemCount(m_sLuckyBox.dwSrcItemVNum) > 1 && item.dwVNum == m_sLuckyBox.dwItemVNum)
-			continue;
-
-		m_sLuckyBox.dwItemVNum = item.dwVNum;
-		m_sLuckyBox.bItemCount = item.bCount;
-		break;
-	}
-
-	TPacketGCLuckyBox Packet;
-	Packet.bHeader = HEADER_GC_LUCKY_BOX;
-	Packet.dwVNum = m_sLuckyBox.dwItemVNum;
-	Packet.bCount = m_sLuckyBox.bItemCount;
-	Packet.iNeedMoney = GetLuckyBoxPrice();
-	Packet.wSlotIndex = m_sLuckyBox.wSrcSlotIndex;
-	GetDesc()->Packet(&Packet, sizeof(Packet));
-}
-
-void CHARACTER::LuckyBoxRetry()
-{
-	if (!IsLuckyBoxOpen())
-		return;
-
-	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
-	if (!pLuckyBox)
-		return;
-
-	if (m_sLuckyBox.bTryCount >= pLuckyBox->GetMaxTryCount())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can't do this anymore."));
-		return;
-	}
-
-	const int c_iPrice = GetLuckyBoxPrice();
-	if (c_iPrice > GetGold())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough money."));
-		return;
-	}
-
-	PointChange(POINT_GOLD, -c_iPrice);
-	ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d Yang has been deducted.", c_iPrice));
-	SendLuckyBoxInfo();
-}
-
-void CHARACTER::LuckyBoxReceive()
-{
-	if (!IsLuckyBoxOpen())
-		return;
-
-	const LPITEM c_lpSrcItem = ITEM_MANAGER::Instance().Find(m_sLuckyBox.dwSrcItemID);
-	if (c_lpSrcItem)
-	{
-		ITEM_MANAGER::Instance().RemoveItem(c_lpSrcItem);
-		AutoGiveItem(m_sLuckyBox.dwItemVNum, m_sLuckyBox.bItemCount);
-	}
-
-	ResetLuckyBoxData();
-}
-
-int CHARACTER::GetLuckyBoxPrice() const
-{
-	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
-	if (!pLuckyBox)
-		return 0;
-
-	int iRet = pLuckyBox->GetPrice();
-	for (int i = 1; i < m_sLuckyBox.bTryCount; i++)
-		iRet *= 2;
-
-	return iRet;
-}
-
-bool CHARACTER::IsLuckyBoxOpen() const
-{
-	return m_sLuckyBox.dwSrcItemID != 0;
-}
-
-void CHARACTER::ResetLuckyBoxData()
-{
-	memset(&m_sLuckyBox, 0, sizeof(m_sLuckyBox));
-}
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-LPITEM CHARACTER::GetNPCStorageItem(BYTE bCell) const
-{
-	return GetItem(TItemPos(NPC_STORAGE, bCell));
-}
-
-bool CHARACTER::Attr67Add(const TAttr67AddData kAttr67AddData)
-{
-	if (!IsPC())
-		return false;
-
-	if (PreventTradeWindow(WND_ATTR67ADD, true/*except*/))
-		return false;
-
-	if (GetNPCStorageItem())
-		return false;
-
-	const LPITEM pkRegistItem = GetInventoryItem(kAttr67AddData.wRegistItemPos);
-	if (pkRegistItem == nullptr)
-		return false;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (pkRegistItem->IsSealed())
-		return false;
-#endif
-
-	if (pkRegistItem->isLocked())
-		return false;
-
-	if (pkRegistItem->IsEquipped())
-		return false;
-
-	if (pkRegistItem->GetType() != ITEM_ARMOR && pkRegistItem->GetType() != ITEM_WEAPON)
-		return false;
-
-	if (pkRegistItem->GetAttributeCount() < ITEM_MANAGER::MAX_NORM_ATTR_NUM)
-		return false;
-
-	DWORD dwItemMaterialVnum = pkRegistItem->Get67AttrMaterial();
-	if (CountSpecifyItem(dwItemMaterialVnum) < kAttr67AddData.byMaterialCount)
-		return false;
-
-	RemoveSpecifyItem(dwItemMaterialVnum, kAttr67AddData.byMaterialCount);
-
-	long lSupportIncreasePct = 0;
-	LPITEM pSupportItem = nullptr;
-	{
-		pSupportItem = GetInventoryItem(kAttr67AddData.wSupportItemPos);
-		if (pSupportItem)
-			lSupportIncreasePct = pSupportItem->GetValue(1);
-	}
-
-	// Total success percent.
-	float fMaterialPct = kAttr67AddData.byMaterialCount * ATTR67_SUCCESS_PER_MATERIAL;
-	float fSupportPct = 0.0f;
-	if (kAttr67AddData.bySupportItemCount != 0)
-	{
-		fSupportPct = static_cast<float>(lSupportIncreasePct) / (ATTR67_MATERIAL_MAX_COUNT * ATTR67_SUPPORT_MAX_COUNT);
-		fSupportPct *= kAttr67AddData.bySupportItemCount * kAttr67AddData.byMaterialCount;
-
-	}
-	float fTotalSuccessPct = fMaterialPct + fSupportPct;
-
-	if (test_server)
-	{
-		ChatPacket(CHAT_TYPE_INFO, "<Add67> Success Percentage: %.2f", fTotalSuccessPct);
-	}
-
-	if (pSupportItem)
-	{
-		if (CountSpecifyItem(pSupportItem->GetVnum()) < kAttr67AddData.bySupportItemCount)
-			return false;
-
-		RemoveSpecifyItem(pSupportItem->GetVnum(), kAttr67AddData.bySupportItemCount);
-	}
-
-	pkRegistItem->RemoveFromCharacter();
-	SetItem(TItemPos(NPC_STORAGE, 0), pkRegistItem);
-	{
-		const LPITEM pkAttr67Add = GetNPCStorageItem();
-		if (!pkAttr67Add)
-		{
-			// TODO: Make a backup of the item in case something goes bad.
-			sys_err("CHARACTER::Attr67Add: failed to get regist item from ATTR67_ADD (window).");
-			return false;
-		}
-
-		SetQuestFlag("add_attr67.success", (number(1, 100) <= fTotalSuccessPct ? 1 : 0));
-		SetQuestFlag("add_attr67.wait_time", get_global_time() + ATTR67_ADD_WAIT_TIME);
-		SetQuestFlag("add_attr67.add", 0);
-		// @ attr67add_collect (handling)
-	}
-
-	return true;
-}
-#endif
-
-#if defined(__SOUL_SYSTEM__)
-void CHARACTER::SoulItemProcess(ESoulSubTypes eSubType)
-{
-	LPITEM item = nullptr;
-	for (const auto& it : GetAffectContainer())
-	{
-		if (it == nullptr || it->dwType != AFFECT_SOUL)
-			continue;
-
-		switch (eSubType)
-		{
-			case ESoulSubTypes::RED_SOUL:
-			{
-				if (it->wApplyOn == AFF_SOUL_RED)
-					item = FindItemByID(it->lApplyValue);
-			}
-			break;
-
-			case ESoulSubTypes::BLUE_SOUL:
-			{
-				if (it->wApplyOn == AFF_SOUL_BLUE)
-					item = FindItemByID(it->lApplyValue);
-			}
-			break;
-		}
-	}
-
-	if (item == nullptr)
-		return;
-
-	if (!item->isLocked() || item->GetSocket(1) != TRUE)
-		return;
-
-	long data = item->GetSocket(2);
-	long keep_time = data / 10000;
-	//auto max_time = item->GetLimitValue(1);
-	long min_time = 60;
-
-	// Minimum use time.
-	if (keep_time < min_time)
-		return;
-
-	/*
-	* Since the `remain_count` is added after the `keep_time`
-	* we can decrease `data` directly because the count
-	* stays at the end of `data`.
-	*/
-	//if (test_server)
-	//	data -= 5;
-	//else
-	--data; /* remain_count */;
-
-	/*
-	* If the remaining count is equal or below to zero
-	* then set decrease the socket data.
-	*/
-	long new_data = ((keep_time - min_time) * 10000) + item->GetValue(2);
-	long remain_count = data % 10000;
-	if (remain_count <= 0)
-	{
-		item->SetSocket(2, new_data);
-		item->ResetSoulTimerUseEvent();
-		return;
-	}
-
-	// Update the item with the new data (decreased count)
-	item->SetSocket(2, data, false /* log */);
-}
-
-int CHARACTER::GetSoulDamage(ESoulSubTypes eSubType) const
-{
-	LPITEM item = nullptr;
-	for (const auto& it : GetAffectContainer())
-	{
-		if (it == nullptr || it->dwType != AFFECT_SOUL)
-			continue;
-
-		switch (eSubType)
-		{
-			case ESoulSubTypes::RED_SOUL:
-			{
-				if (it->wApplyOn == AFF_SOUL_RED)
-					item = FindItemByID(it->lApplyValue);
-			}
-			break;
-
-			case ESoulSubTypes::BLUE_SOUL:
-			{
-				if (it->wApplyOn == AFF_SOUL_BLUE)
-					item = FindItemByID(it->lApplyValue);
-			}
-			break;
-		}
-	}
-
-	if (item == nullptr)
-		return 0;
-
-	if (item->GetSocket(1) != TRUE)
-		return 0;
-
-	int value = 0;
-	long data = item->GetSocket(2);
-	long keep_time = data / 10000;
-
-	long max_time = item->GetLimitValue(1);
-	long min_time = 60;
-
-	// Minimum use time.
-	if (keep_time < min_time)
-		return 0;
-
-	if (keep_time >= max_time)
-		return item->GetValue(5);
-
-	// Damage values in value field (3, 4, 5)
-	int value_field = 3 + std::floor(keep_time / (max_time - min_time));
-	if (value_field < ITEM_VALUES_MAX_NUM)
-		value = item->GetValue(value_field);
-
-	return value;
-}
-#endif
-
-#if defined(__SET_ITEM__)
-void CHARACTER::RefreshItemSetBonus()
-{
-	RemoveAffect(AFFECT_SET_ITEM);
-
-	bool bSetBonus = false;
-	for (const auto& [bSetValue, vItems] : ITEM_MANAGER::Instance().GetItemSetItemMap())
-	{
-		BYTE bWearCount = 0;
-
-		const auto& rkItemSetValueMap = ITEM_MANAGER::Instance().GetItemSetValueMap();
-		if (rkItemSetValueMap.empty())
-			break;
-
-		const auto& ItemSetValueMap = rkItemSetValueMap.find(bSetValue);
-		if (ItemSetValueMap == rkItemSetValueMap.end())
-			continue;
-
-		for (const auto& [bSetType, kItemTuple] : vItems)
-		{
-			LPITEM pItem = nullptr;
-			LPITEM pUnique1 = nullptr;
-			LPITEM pUnique2 = nullptr;
-			CPetSystem* pPetSystem = nullptr;
-
-			switch (bSetType)
-			{
-				case SET_ITEM_COSTUME_BODY:
-					pItem = GetWear(WEAR_COSTUME_BODY);
-					break;
-
-				case SET_ITEM_COSTUME_HAIR:
-					pItem = GetWear(WEAR_COSTUME_HAIR);
-					break;
-
-#if defined(__MOUNT_COSTUME_SYSTEM__)
-				case SET_ITEM_COSTUME_MOUNT:
-					pItem = GetWear(WEAR_COSTUME_MOUNT);
-					break;
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-				case SET_ITEM_COSTUME_ACCE:
-					pItem = GetWear(WEAR_COSTUME_ACCE);
-					break;
-#endif
-
-#if defined(__WEAPON_COSTUME_SYSTEM__)
-				case SET_ITEM_COSTUME_WEAPON:
-					pItem = GetWear(WEAR_COSTUME_WEAPON);
-					break;
-#endif
-
-				case SET_ITEM_UNIQUE:
-					pUnique1 = GetWear(WEAR_UNIQUE1);
-					pUnique2 = GetWear(WEAR_UNIQUE2);
-					break;
-
-#if defined(__PET_SYSTEM__)
-				case SET_ITEM_PET:
-					pPetSystem = GetPetSystem();
-					break;
-#endif
-			}
-
-			const auto& [dwMinVnum, dwMaxVnum, bRange] = kItemTuple;
-
-#if defined(__PET_SYSTEM__)
-			if (pPetSystem && CHECK_VNUM_RANGE(pPetSystem->GetSummonItemVnum(), dwMinVnum, dwMaxVnum, bRange))
-				++bWearCount;
-#endif
-
-			if (pUnique1 && CHECK_VNUM_RANGE(pUnique1->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
-				++bWearCount;
-
-			if (pUnique2 && CHECK_VNUM_RANGE(pUnique2->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
-				++bWearCount;
-
-			if (pItem && CHECK_VNUM_RANGE(pItem->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
-				++bWearCount;
-
-			for (const auto& [bCount, vSetBonus] : ItemSetValueMap->second)
-			{
-				if (bWearCount != bCount)
-				{
-					bSetBonus = false;
-					continue;
-				}
-
-				for (const auto& [wApplyType, lApplyValue] : vSetBonus)
-				{
-					AddAffect(AFFECT_SET_ITEM, aApplyInfo[wApplyType].wPointType, lApplyValue, 0, INFINITE_AFFECT_DURATION, 0, true, true);
-					bSetBonus = true;
-				}
-			}
-		}
-
-		if (bSetBonus)
-			break;
-	}
-}
-
-CHARACTER::SetItemCountMap CHARACTER::GetItemSetCountMap() const
-{
-	std::vector<LPITEM> vItems = { GetWear(WEAR_BODY), GetWear(WEAR_HEAD), GetWear(WEAR_WEAPON) };
-	std::map<BYTE, BYTE> mSetCount = {
-		{ SET_ITEM_SET_VALUE_1, 0 },
-		{ SET_ITEM_SET_VALUE_2, 0 },
-		{ SET_ITEM_SET_VALUE_3, 0 },
-		{ SET_ITEM_SET_VALUE_4, 0 },
-		{ SET_ITEM_SET_VALUE_5, 0 },
-	};
-
-	for (const LPITEM& pkItem : vItems)
-	{
-		if (pkItem == nullptr)
-			continue;
-
-		const BYTE bSetValue = pkItem->GetItemSetValue();
-		if (bSetValue != SET_ITEM_SET_VALUE_NONE)
-			++mSetCount[bSetValue];
-	}
-
-	return mSetCount;
-}
-
-void CHARACTER::RefreshItemSetBonusByValue()
-{
-	for (DWORD dwType = AFFECT_SET_ITEM_SET_VALUE_1; dwType <= AFFECT_SET_ITEM_SET_VALUE_5; ++dwType)
-		RemoveAffect(dwType);
-
-	const auto& rkItemSetValueMap = ITEM_MANAGER::Instance().GetItemSetValueMap();
-	if (rkItemSetValueMap.empty())
-		return;
-
-	for (const auto& rkItemSetPair : GetItemSetCountMap())
-	{
-		BYTE bSetValue = rkItemSetPair.first;
-		BYTE bWearCount = rkItemSetPair.second;
-
-		const auto& rkSetItemMap = rkItemSetValueMap.find(bSetValue);
-		if (rkSetItemMap == rkItemSetValueMap.end())
-			continue;
-
-		for (const auto& kSetItem : rkSetItemMap->second)
-		{
-			const auto& vSetBonus = kSetItem.second;
-			if (bWearCount != kSetItem.first)
-				continue;
-
-			for (const auto& kSetBonus : vSetBonus)
-				AddAffect((AFFECT_SET_ITEM_SET_VALUE_1 - 1) + bSetValue, aApplyInfo[kSetBonus.first].wPointType, kSetBonus.second, 0, INFINITE_AFFECT_DURATION, 0, true, true);
-		}
-	}
-}
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-void CHARACTER::RefineElementInformation(const LPITEM& rSrcItem, const TItemPos& kItemDestCell)
-{
-	if (!CanHandleItem())
-		return;
-
-	LPITEM pDestItem;
-	if (!IsValidItemPosition(kItemDestCell) || !(pDestItem = GetItem(kItemDestCell)))
-		return;
-
-	if (rSrcItem->IsEquipped() || pDestItem->IsEquipped())
-		return;
-
-	if (rSrcItem->IsExchanging() || pDestItem->IsExchanging())
-		return;
-
-	if (rSrcItem->isLocked() || pDestItem->isLocked())
-		return;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (pDestItem->IsSealed())
-		return;
-#endif
-
-	if (pDestItem->GetType() != ITEM_WEAPON)
-		return;
-
-	if (pDestItem->GetRefineLevel() < REFINE_ELEMENT_MIN_REFINE_LEVEL)
-		return;
-
-	TPacketGCRefineElement kPacket;
-	kPacket.bHeader = HEADER_GC_REFINE_ELEMENT;
-	kPacket.bSubHeader = REFINE_ELEMENT_GC_OPEN;
-	switch (rSrcItem->GetSubType())
-	{
-		case USE_ELEMENT_UPGRADE:
-			kPacket.bRefineType = REFINE_ELEMENT_UPGRADE;
-			break;
-		case USE_ELEMENT_DOWNGRADE:
-			kPacket.bRefineType = REFINE_ELEMENT_DOWNGRADE;
-			break;
-		case USE_ELEMENT_CHANGE:
-			kPacket.bRefineType = REFINE_ELEMENT_CHANGE;
-			break;
-		default:
-		{
-			sys_err("CHARACTER::RefineElementInformation: %s cannot receive information with unsupported material sub type.", GetName());
-			return;
-		}
-	}
-	kPacket.bResult = false;
-	kPacket.SrcPos = TItemPos(rSrcItem->GetWindow(), rSrcItem->GetCell());
-	kPacket.DestPos = kItemDestCell;
-	GetDesc()->Packet(&kPacket, sizeof(kPacket));
-
-	SetUnderRefineElement(true, kPacket.bRefineType, kPacket.SrcPos, kPacket.DestPos);
-}
-
-void CHARACTER::SetUnderRefineElement(bool bState, BYTE bRefineType, const TItemPos& rkSrcPos, const TItemPos& rkDestPos)
-{
-	m_kRefineElementItemPos.RefineType = bRefineType;
-	m_kRefineElementItemPos.SrcPos = rkSrcPos;
-	m_kRefineElementItemPos.DestPos = rkDestPos;
-	m_bUnderRefineElement = bState;
-}
-
-void CHARACTER::RefineElement(WORD wChangeElement)
-{
-	if (!IsUnderRefineElement())
-		return;
-
-	LPITEM pSrcItem;
-	if (!IsValidItemPosition(m_kRefineElementItemPos.SrcPos) || !(pSrcItem = GetItem(m_kRefineElementItemPos.SrcPos)))
-		return;
-
-	LPITEM pDestItem;
-	if (!IsValidItemPosition(m_kRefineElementItemPos.DestPos) || !(pDestItem = GetItem(m_kRefineElementItemPos.DestPos)))
-		return;
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (pDestItem->IsSealed())
-		return;
-#endif
-
-	if (pDestItem->GetType() != ITEM_WEAPON)
-		return;
-
-	if (pDestItem->GetRefineLevel() < REFINE_ELEMENT_MIN_REFINE_LEVEL)
-		return;
-
-	TPacketGCRefineElement kPacket;
-	kPacket.bHeader = HEADER_GC_REFINE_ELEMENT;
-	kPacket.bSubHeader = REFINE_ELEMENT_GC_RESULT;
-	kPacket.bRefineType = m_kRefineElementItemPos.RefineType;
-	switch (kPacket.bRefineType)
-	{
-		case REFINE_ELEMENT_UPGRADE:
-		{
-			if (GetGold() < REFINE_ELEMENT_UPGRADE_YANG)
-				return;
-
-			//const TRefineTable* pRefineTable = CRefineManager::instance().GetRefineRecipe(11);
-			//if (number(1, 100) <= (pRefineTable ? pRefineTable->prob : 30))
-			if (number(1, 100) <= (test_server ? 80 : 30))
-			{
-				const WORD wMaterialApplyType = static_cast<WORD>(pSrcItem->GetValue(0));
-				const WORD wRefineElementApplyType = pDestItem->GetRefineElementApplyType();
-				if ((wRefineElementApplyType != 0) && (wRefineElementApplyType != wMaterialApplyType))
-				{
-					sys_err("CHARACTER::RefineElement: %s cannot upgrade with wrong material.", GetName());
-					return;
-				}
-
-				const BYTE bRandomValue = number_even(REFINE_ELEMENT_RANDOM_VALUE_MIN, REFINE_ELEMENT_RANDOM_VALUE_MAX);
-				const BYTE bRandomBonusValue = number_even(REFINE_ELEMENT_RANDOM_BONUS_VALUE_MIN, REFINE_ELEMENT_RANDOM_BONUS_VALUE_MAX);
-
-				pDestItem->UpgradeRefineElement(wMaterialApplyType, bRandomValue, bRandomBonusValue);
-
-				kPacket.bResult = true;
-			}
-			else
-			{
-				kPacket.bResult = false;
-			}
-
-			PointChange(POINT_GOLD, -REFINE_ELEMENT_UPGRADE_YANG);
-		}
-		break;
-
-		case REFINE_ELEMENT_DOWNGRADE:
-		{
-			if (GetGold() < REFINE_ELEMENT_DOWNGRADE_YANG)
-				return;
-
-			pDestItem->DowngradeRefineElement();
-			kPacket.bResult = true;
-
-			PointChange(POINT_GOLD, -REFINE_ELEMENT_DOWNGRADE_YANG);
-		}
-		break;
-
-		case REFINE_ELEMENT_CHANGE:
-		{
-			if (GetGold() < REFINE_ELEMENT_CHANGE_YANG)
-				return;
-
-			switch (wChangeElement)
-			{
-				case APPLY_ENCHANT_ELECT:
-				case APPLY_ENCHANT_FIRE:
-				case APPLY_ENCHANT_ICE:
-				case APPLY_ENCHANT_WIND:
-				case APPLY_ENCHANT_EARTH:
-				case APPLY_ENCHANT_DARK:
-					break;
-
-				default:
-				{
-					sys_err("CHARACTER::RefineElement: %s cannot change element with unsupported apply type.", GetName());
-					return;
-				}
-			}
-
-			const WORD wRefineElementApplyType = pDestItem->GetRefineElementApplyType();
-			if (wRefineElementApplyType == wChangeElement)
-			{
-				sys_err("CHARACTER::RefineElement: %s cannot change element with the current apply type.", GetName());
-				return;
-			}
-
-			pDestItem->ChangeRefineElement(wChangeElement);
-			kPacket.bResult = true;
-
-			PointChange(POINT_GOLD, -REFINE_ELEMENT_CHANGE_YANG);
-		}
-		break;
-
-		default:
-		{
-			sys_err("CHARACTER::RefineElement: %s cannot refine with unknown type.", GetName());
-			return;
-		}
-	}
-	kPacket.SrcPos = NPOS;
-	kPacket.DestPos = NPOS;
-	GetDesc()->Packet(&kPacket, sizeof(kPacket));
-
-	pSrcItem->SetCount(pSrcItem->GetCount() - 1);
-
-	SetUnderRefineElement(false);
-}
-
-WORD CHARACTER::GetRefineElementEffect() const
-{
-	const LPITEM pItemWeapon = GetWear(WEAR_WEAPON);
-	if ((pItemWeapon) && (pItemWeapon->GetRefineElementGrade() >= REFINE_ELEMENT_MAX))
-		return pItemWeapon->GetRefineElementApplyType();
-	return 0;
-}
-#endif
+#include "stdafx.h"
+
+#include <stack>
+
+#include "utils.h"
+#include "config.h"
+#include "char.h"
+#include "char_manager.h"
+#include "item_manager.h"
+#include "desc.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "packet.h"
+#include "affect.h"
+#include "skill.h"
+#include "start_position.h"
+#include "mob_manager.h"
+#include "db.h"
+#include "log.h"
+#include "vector.h"
+#include "buffer_manager.h"
+#include "questmanager.h"
+#include "fishing.h"
+#include "party.h"
+#include "dungeon.h"
+#include "refine.h"
+#include "unique_item.h"
+#include "war_map.h"
+#include "xmas_event.h"
+#include "marriage.h"
+#include "monarch.h"
+#include "polymorph.h"
+#include "blend_item.h"
+#include "castle.h"
+#include "BattleArena.h"
+#include "arena.h"
+#include "dev_log.h"
+#include "pcbang.h"
+#include "threeway_war.h"
+
+#include "safebox.h"
+#include "shop.h"
+#include "pvp.h"
+
+#include "../../common/VnumHelper.h"
+#include "DragonSoul.h"
+#ifdef ENABLE_QUEEN_NETHIS
+#include "SnakeLair.h"
+#endif
+#include "buff_on_attributes.h"
+#include "belt_inventory_helper.h"
+#if defined(__LOOT_FILTER_SYSTEM__)
+#	include "LootFilter.h"
+#endif
+
+#if defined(__MT_THUNDER_DUNGEON__)
+#	include "mt_thunder_dungeon.h"
+#endif
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+#	include "guild_dragonlair.h"
+#endif
+
+#ifdef __OFFLINE_SHOP__
+#include "OfflineShop.h"
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+#include "growth_pet.h"
+#endif
+
+#include "../../libgame/include/grid.h"
+
+#include <optional>
+
+const int ITEM_BROKEN_METIN_VNUM = 28960;
+
+// CHANGE_ITEM_ATTRIBUTES
+const DWORD CHARACTER::msc_dwDefaultChangeItemAttrCycle = 10;
+const char CHARACTER::msc_szLastChangeItemAttrFlag[] = "Item.LastChangeItemAttr";
+const char CHARACTER::msc_szChangeItemAttrCycleFlag[] = "change_itemattr_cycle";
+// END_OF_CHANGE_ITEM_ATTRIBUTES
+const POINT_TYPE g_aBuffOnAttrPoints[] = { POINT_ENERGY, POINT_COSTUME_ATTR_BONUS };
+
+struct FFindStone
+{
+	std::map<DWORD, LPCHARACTER> m_mapStone;
+
+	void operator()(LPENTITY pEnt)
+	{
+		if (pEnt->IsType(ENTITY_CHARACTER) == true)
+		{
+			LPCHARACTER pChar = (LPCHARACTER)pEnt;
+
+			if (pChar->IsStone() == true)
+			{
+				m_mapStone[(DWORD)pChar->GetVID()] = pChar;
+			}
+		}
+	}
+};
+
+#if defined(__MT_THUNDER_DUNGEON__)
+struct FFindMobVnum
+{
+	DWORD dwMobVnum;
+	FFindMobVnum(DWORD dwMobVnum) : dwMobVnum(dwMobVnum) {}
+
+	std::map<DWORD, LPCHARACTER> m_mapVID;
+	void operator()(LPENTITY pEnt)
+	{
+		if (pEnt && pEnt->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER pChar = dynamic_cast<LPCHARACTER>(pEnt);
+
+			if (pChar && pChar->GetRaceNum() == dwMobVnum)
+			{
+				m_mapVID[(DWORD)pChar->GetVID()] = pChar;
+			}
+		}
+	}
+};
+#endif
+
+// È¯, È¯, È¥
+bool IS_SUMMON_ITEM(LPITEM item, int map_index)
+{
+	if (item->GetVnum() == ITEM_MARRIAGE_RING)
+		return true;
+
+	switch (item->GetType())
+	{
+		case ITEM_QUEST:
+		{
+			if (item->GetSubType() == QUEST_WARP)
+			{
+				// NOTE : Force allow warp ring in certain maps indexes.
+				if (item->GetSpecialGroup() == UNIQUE_GROUP_WARP_RING)
+				{
+					switch (map_index)
+					{
+						case MAP_SKIPIA_DUNGEON_01:
+							return false;
+						default:
+							return true;
+					}
+				}
+				return true;
+			}
+		}
+		break;
+		case ITEM_USE:
+		{
+			if (item->GetSubType() == USE_TALISMAN)
+				return true;
+		}
+		break;
+	}
+
+	return false;
+}
+
+bool IS_MONKEY_DUNGEON(int map_index)
+{
+	switch (map_index)
+	{
+		case MAP_MONKEY_DUNGEON_11:
+		case MAP_MONKEY_DUNGEON_12:
+		case MAP_MONKEY_DUNGEON_13:
+		case MAP_MONKEY_DUNGEON:
+		case MAP_MONKEY_DUNGEON2:
+		case MAP_MONKEY_DUNGEON3:
+			return true;
+	}
+
+	return false;
+}
+
+bool IS_MAZE_DUNGEON(int map_index)
+{
+	switch (map_index)
+	{
+		case MAP_MAZE_DUNGEON1:
+		case MAP_MAZE_DUNGEON2:
+		case MAP_MAZE_DUNGEON3:
+			return true;
+	}
+
+	return false;
+}
+
+#if defined(__SNOW_DUNGEON__)
+bool IS_SNOW_DUNGEON(int map_index)
+{
+	if (map_index >= MAP_N_SNOW_DUNGEON_01 * 10000 && map_index < (MAP_N_SNOW_DUNGEON_01 + 1) * 10000)
+		return true;
+#if defined(__LABYRINTH_DUNGEON__)
+	else if (map_index >= MAP_BOSS_CRACK_SNOW * 10000 && map_index < (MAP_BOSS_CRACK_SNOW + 1) * 10000)
+		return true;
+	else if (map_index >= MAP_BOSS_AWAKEN_SNOW * 10000 && map_index < (MAP_BOSS_AWAKEN_SNOW + 1) * 10000)
+		return true;
+#endif
+
+	return false;
+}
+#endif
+
+#if defined(__ELEMENTAL_DUNGEON__)
+bool IS_ELEMENTAL_DUNGEON(int map_index)
+{
+	switch (map_index)
+	{
+		case MAP_ELEMENTAL_01:
+		case MAP_ELEMENTAL_02:
+		case MAP_ELEMENTAL_03:
+		case MAP_ELEMENTAL_04:
+			return true;
+	}
+
+	return false;
+}
+#endif
+
+bool IS_SUMMONABLE_ZONE(int map_index)
+{
+	// Å°
+	if (IS_MONKEY_DUNGEON(map_index))
+		return false;
+
+	if (IS_MAZE_DUNGEON(map_index))
+		return false;
+
+	// 
+	if (IS_CASTLE_MAP(map_index))
+		return false;
+
+	switch (map_index)
+	{
+		case MAP_DEVILTOWER1: // Å¸
+		case MAP_SPIDERDUNGEON_02: // Å¹  2
+		case MAP_SKIPIA_DUNGEON_01: // Ãµ 
+		case MAP_SKIPIA_DUNGEON_02: // Ãµ  2
+#if 0
+		case 193: // Å¹  2-1
+		case 184: // Ãµ (Å¼)
+		case 185: // Ãµ  2(Å¼)
+		case 186: // Ãµ (Ãµ)
+		case 187: // Ãµ  2(Ãµ)
+		case 188: // Ãµ ()
+		case 189: // Ãµ  2()
+#endif
+			//case 206: // Æ±Íµ
+		case MAP_DEVILSCATACOMB: // Æ±Íµ
+		case MAP_SPIDERDUNGEON_03: // Å¹  3
+		case MAP_SKIPIA_DUNGEON_BOSS: // Ãµ  ()
+		case MAP_OXEVENT: // OX Event 
+		case MAP_12ZI_STAGE: // 12ZI
+		case MAP_BATTLEFIED: // Battlefield
+			return false;
+	}
+
+	if (CBattleArena::IsBattleArenaMap(map_index))
+		return false;
+
+	//  private   Ò°
+	if (map_index > 10000)
+		return false;
+
+	return true;
+}
+
+bool IS_BOTARYABLE_ZONE(int nMapIndex)
+{
+	if (LC_IsYMIR() == false && LC_IsKorea() == false) return true;
+
+	switch (nMapIndex)
+	{
+		case MAP_A1:
+		case MAP_A3:
+		case MAP_B1:
+		case MAP_B3:
+		case MAP_C1:
+		case MAP_C3:
+		case MAP_PRIVATESHOP:
+			return true;
+	}
+
+	return false;
+}
+
+// item socket  Å¸Ô°  Ã¼Å© -- by mhh
+static bool FN_check_item_socket(LPITEM item)
+{
+	switch (item->GetVnum())
+	{
+		case ITEM_AUTO_HP_RECOVERY_S:
+		case ITEM_AUTO_HP_RECOVERY_M:
+		case ITEM_AUTO_HP_RECOVERY_L:
+		case ITEM_AUTO_HP_RECOVERY_X:
+		case ITEM_AUTO_SP_RECOVERY_S:
+		case ITEM_AUTO_SP_RECOVERY_M:
+		case ITEM_AUTO_SP_RECOVERY_L:
+		case ITEM_AUTO_SP_RECOVERY_X:
+		case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
+		case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
+		case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
+		case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
+		{
+			if (item->GetSocket(0) == 0 && item->GetSocket(1) == 0 && item->GetSocket(2) == item->GetProto()->alValues[0])
+				return true;
+		}
+		break;
+	}
+
+	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+	{
+		if (item->GetSocket(i) != item->GetProto()->alSockets[i])
+			return false;
+	}
+
+	return true;
+}
+
+// item socket  -- by mhh
+static void FN_copy_item_socket(LPITEM dest, LPITEM src)
+{
+	for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+	{
+		dest->SetSocket(i, src->GetSocket(i));
+	}
+}
+
+static bool FN_check_item_sex(LPCHARACTER ch, LPITEM item)
+{
+	//  
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_MALE))
+	{
+		if (SEX_MALE == GET_SEX(ch))
+			return false;
+	}
+
+	// Ú±
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_FEMALE))
+	{
+		if (SEX_FEMALE == GET_SEX(ch))
+			return false;
+	}
+
+	return true;
+}
+
+#define VERIFY_POTION(affect, afftype) \
+	if (FindAffect(affect, afftype)) \
+	{ \
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´.")); \
+		return false; \
+	}
+
+/////////////////////////////////////////////////////////////////////////////
+// ITEM HANDLING
+/////////////////////////////////////////////////////////////////////////////
+bool CHARACTER::CanHandleItem(bool bSkipCheckRefine, bool bSkipObserver)
+{
+	if (!bSkipObserver)
+		if (m_bIsObserver)
+			return false;
+
+	if (GetMyShop())
+		return false;
+
+	if (!bSkipCheckRefine)
+	{
+		if (IsUnderRefine())
+			return false;
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		if (IsUnderRefineElement())
+			return false;
+#endif
+	}
+
+	if (IsWarping())
+		return false;
+
+	if (IsCubeOpen())
+		return false;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (NULL != DragonSoul_RefineWindow_GetOpener())
+		return false;
+#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+	if (IsItemComb())
+		return false;
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	if (GetChangeLook())
+		return false;
+#endif
+
+#if defined(__MAILBOX__)
+	if (GetMailBox())
+		return false;
+#endif
+
+#if defined(__GEM_SHOP__)
+	if (GetGemShop())
+		return false;
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	if (IsAcceRefineWindowOpen())
+		return false;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+	if (IsAuraRefineWindowOpen() || NULL != GetAuraRefineWindowOpener())
+		return false;
+#endif
+
+#if defined(__CHANGED_ATTR__)
+	if (IsSelectAttr())
+		return false;
+#endif
+
+#if defined(__LUCKY_BOX__)
+	if (IsLuckyBoxOpen())
+		return false;
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+	if (GetMiniGameRoulette())
+		return false;
+#endif
+
+	return true;
+}
+
+LPITEM CHARACTER::GetInventoryItem(WORD wCell) const
+{
+	return GetItem(TItemPos(INVENTORY, wCell));
+}
+
+LPITEM CHARACTER::GetEquipmentItem(WORD wCell) const
+{
+	return GetItem(TItemPos(EQUIPMENT, wCell));
+}
+
+LPITEM CHARACTER::GetDragonSoulInventoryItem(WORD wCell) const
+{
+	return GetItem(TItemPos(DRAGON_SOUL_INVENTORY, wCell));
+}
+
+LPITEM CHARACTER::GetBeltInventoryItem(WORD wCell) const
+{
+	return GetItem(TItemPos(BELT_INVENTORY, wCell));
+}
+
+LPITEM CHARACTER::GetItem(TItemPos Cell) const
+{
+	if (!IsValidItemPosition(Cell))
+		return nullptr;
+
+	WORD wCell = Cell.cell;
+	BYTE window_type = Cell.window_type;
+
+	switch (window_type)
+	{
+		case INVENTORY:
+		{
+			if (wCell >= INVENTORY_MAX_NUM)
+			{
+				sys_err("CHARACTER::GetItem: Invalid Inventory item! Window %d Cell %d", window_type, wCell);
+				return nullptr;
+			}
+			return m_pointsInstant.pInventoryItems[wCell];
+		}
+		break;
+
+		case EQUIPMENT:
+		{
+			if (wCell >= EQUIPMENT_MAX_NUM)
+			{
+				sys_err("CHARACTER::GetItem: Invalid Equipment item! Window %d Cell %d", window_type, wCell);
+				return nullptr;
+			}
+			return m_pointsInstant.pEquipmentItems[wCell];
+		}
+		break;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case DRAGON_SOUL_INVENTORY:
+		{
+			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+			{
+				sys_err("CHARACTER::GetItem: Invalid Dragon Soul item! window %d cell %d", window_type, wCell);
+				return nullptr;
+			}
+			return m_pointsInstant.pDragonSoulInventoryItems[wCell];
+		}
+		break;
+#endif
+
+		case BELT_INVENTORY:
+		{
+			if (wCell >= BELT_INVENTORY_SLOT_COUNT)
+			{
+				sys_err("CHARACTER::GetItem: Invalid Belt item! window %d cell %d", window_type, wCell);
+				return nullptr;
+			}
+			return m_pointsInstant.pBeltInventoryItems[wCell];
+		}
+		break;
+
+#if defined(__ATTR_6TH_7TH__)
+		case NPC_STORAGE:
+		{
+			if (wCell >= NPC_STORAGE_SLOT_MAX)
+			{
+				sys_err("CHARACTER::GetItem: invalid NPC_STORAGE item cell %d", wCell);
+				return nullptr;
+			}
+			return m_pointsInstant.pNPCStorageItems;
+		}
+#endif
+
+		default:
+			return nullptr;
+	}
+
+	return nullptr;
+}
+
+void CHARACTER::SetItem(TItemPos Cell, LPITEM pItem
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+	, bool isHighLight
+#endif
+)
+{
+	BYTE bWindowType = Cell.window_type;
+	WORD wCell = Cell.cell;
+
+	if ((unsigned long)((CItem*)pItem) == 0xff || (unsigned long)((CItem*)pItem) == 0xffffffff)
+	{
+		sys_err("!!! FATAL ERROR !!! item == 0xff (char: %s cell: %u)", GetName(), wCell);
+		core_dump();
+		return;
+	}
+
+	if (pItem && pItem->GetOwner())
+	{
+		assert(!"GetOwner exist");
+		return;
+	}
+
+	// âº» Îºä¸®
+	switch (bWindowType)
+	{
+		case INVENTORY:
+		{
+			if (wCell >= INVENTORY_MAX_NUM)
+			{
+				sys_err("CHARACTER::SetItem: Invalid Inventory item! Window %d Cell %d", bWindowType, wCell);
+				return;
+			}
+
+			LPITEM pOldItem = m_pointsInstant.pInventoryItems[wCell];
+			if (pOldItem)
+			{
+				if (wCell < INVENTORY_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * INVENTORY_WIDTH);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+						if (wSlot >= GetExtendInvenMax())
+							continue;
+#else
+						if (wSlot >= INVENTORY_MAX_NUM)
+							continue;
+#endif
+
+						if (m_pointsInstant.pInventoryItems[wSlot] && m_pointsInstant.pInventoryItems[wSlot] != pOldItem)
+							continue;
+
+						m_pointsInstant.wInventoryItemGrid[wSlot] = 0;
+					}
+				}
+				else
+					m_pointsInstant.wInventoryItemGrid[wCell] = 0;
+			}
+
+			if (pItem)
+			{
+				if (wCell < INVENTORY_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * INVENTORY_WIDTH);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+						if (wSlot >= GetExtendInvenMax())
+							continue;
+#else
+						if (wSlot >= INVENTORY_MAX_NUM)
+							continue;
+#endif
+
+						// wCell + 1  Ï´   Ã¼Å©  
+						//  Ã³Ï± 
+						m_pointsInstant.wInventoryItemGrid[wSlot] = wCell + 1;
+					}
+				}
+				else
+					m_pointsInstant.wInventoryItemGrid[wCell] = wCell + 1;
+			}
+
+			m_pointsInstant.pInventoryItems[wCell] = pItem;
+		}
+		break;
+
+		case EQUIPMENT:
+		{
+			if (wCell >= EQUIPMENT_MAX_NUM)
+			{
+				sys_err("CHARACTER::SetItem: Invalid Equipment item! Window %d Cell %d", bWindowType, wCell);
+				return;
+			}
+
+			LPITEM pOldItem = m_pointsInstant.pEquipmentItems[wCell];
+			if (pOldItem)
+			{
+				if (wCell < EQUIPMENT_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
+					{
+						BYTE bSlot = wCell + bSize;
+						if (bSlot >= EQUIPMENT_MAX_NUM)
+							continue;
+
+						if (m_pointsInstant.pEquipmentItems[bSlot] && m_pointsInstant.pEquipmentItems[bSlot] != pOldItem)
+							continue;
+
+						m_pointsInstant.bEquipmentItemGrid[bSlot] = 0;
+					}
+				}
+				else
+					m_pointsInstant.bEquipmentItemGrid[wCell] = 0;
+			}
+
+			if (pItem)
+			{
+				if (wCell < EQUIPMENT_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
+					{
+						BYTE bSlot = wCell + bSize;
+						if (bSlot >= EQUIPMENT_MAX_NUM)
+							continue;
+
+						m_pointsInstant.bEquipmentItemGrid[bSlot] = wCell + 1;
+					}
+				}
+				else
+					m_pointsInstant.bEquipmentItemGrid[wCell] = wCell + 1;
+			}
+
+			m_pointsInstant.pEquipmentItems[wCell] = pItem;
+		}
+		break;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case DRAGON_SOUL_INVENTORY:
+		{
+			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+			{
+				sys_err("CHARACTER::SetItem: Invalid Dragon Soul item! Window %d Cell %d", bWindowType, wCell);
+				return;
+			}
+
+			LPITEM pOldItem = m_pointsInstant.pDragonSoulInventoryItems[wCell];
+			if (pOldItem)
+			{
+				if (wCell < DRAGON_SOUL_INVENTORY_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * DRAGON_SOUL_BOX_COLUMN_NUM);
+						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+							continue;
+
+						if (m_pointsInstant.pDragonSoulInventoryItems[wSlot] && m_pointsInstant.pDragonSoulInventoryItems[wSlot] != pOldItem)
+							continue;
+
+						m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] = 0;
+					}
+				}
+				else
+					m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] = 0;
+			}
+
+			if (pItem)
+			{
+				if (wCell < DRAGON_SOUL_INVENTORY_MAX_NUM)
+				{
+					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * DRAGON_SOUL_BOX_COLUMN_NUM);
+						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+							continue;
+
+						m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] = wCell + 1;
+					}
+				}
+				else
+					m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] = wCell + 1;
+			}
+
+			m_pointsInstant.pDragonSoulInventoryItems[wCell] = pItem;
+		}
+		break;
+#endif
+
+		case BELT_INVENTORY:
+		{
+			if (wCell >= BELT_INVENTORY_SLOT_COUNT)
+			{
+				sys_err("CHARACTER::SetItem: Invalid Belt item! Window %d Cell %d", bWindowType, wCell);
+				return;
+			}
+
+			LPITEM pOldItem = m_pointsInstant.pBeltInventoryItems[wCell];
+			if (pOldItem)
+			{
+				if (wCell < BELT_INVENTORY_SLOT_COUNT)
+				{
+					for (BYTE bSize = 0; bSize < pOldItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * BELT_INVENTORY_SLOT_WIDTH);
+						if (wSlot >= BELT_INVENTORY_SLOT_COUNT)
+							continue;
+
+						if (m_pointsInstant.pBeltInventoryItems[wSlot] && m_pointsInstant.pBeltInventoryItems[wSlot] != pOldItem)
+							continue;
+
+						m_pointsInstant.bBeltInventoryItemGrid[wSlot] = 0;
+					}
+				}
+				else
+					m_pointsInstant.bBeltInventoryItemGrid[wCell] = 0;
+			}
+
+			if (pItem)
+			{
+				if (wCell < BELT_INVENTORY_SLOT_COUNT)
+				{
+					for (BYTE bSize = 0; bSize < pItem->GetSize(); ++bSize)
+					{
+						WORD wSlot = wCell + (bSize * BELT_INVENTORY_SLOT_WIDTH);
+						if (wSlot >= BELT_INVENTORY_SLOT_COUNT)
+							continue;
+
+						m_pointsInstant.bBeltInventoryItemGrid[wSlot] = wCell + 1;
+					}
+				}
+				else
+					m_pointsInstant.bBeltInventoryItemGrid[wCell] = wCell + 1;
+			}
+
+			m_pointsInstant.pBeltInventoryItems[wCell] = pItem;
+		}
+		break;
+
+#if defined(__ATTR_6TH_7TH__)
+		case NPC_STORAGE:
+		{
+			if (wCell >= NPC_STORAGE_SLOT_MAX)
+			{
+				sys_err("CHARACTER::SetItem: invalid ATTR67_ADD item cell %d", wCell);
+				return;
+			}
+			m_pointsInstant.pNPCStorageItems = pItem;
+		}
+		break;
+#endif
+
+		default:
+			sys_err("Invalid Inventory type %d", bWindowType);
+			return;
+	}
+
+	if (GetDesc())
+	{
+		// È® :   Ã·  
+		if (pItem)
+		{
+			TPacketGCItemSet pack;
+			pack.bHeader = HEADER_GC_ITEM_SET;
+			pack.Cell = Cell;
+			pack.dwVnum = pItem->GetVnum();
+			pack.dwCount = pItem->GetCount();
+			pack.dwFlags = pItem->GetFlag();
+			pack.dwAntiFlags = pItem->GetAntiFlag();
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			if (isHighLight)
+				pack.bHighLight = true;
+			else
+				pack.bHighLight = (Cell.window_type == DRAGON_SOUL_INVENTORY);
+#else
+			pack.bHighLight = (Cell.window_type == DRAGON_SOUL_INVENTORY);
+#endif
+#if defined(__SOUL_BIND_SYSTEM__)
+			pack.lSealDate = pItem->GetSealDate();
+#endif
+			thecore_memcpy(pack.alSockets, pItem->GetSockets(), sizeof(pack.alSockets));
+			thecore_memcpy(pack.aAttr, pItem->GetAttributes(), sizeof(pack.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			pack.dwTransmutationVnum = pItem->GetTransmutationVnum();
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			thecore_memcpy(&pack.RefineElement, pItem->GetRefineElement(), sizeof(pack.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			thecore_memcpy(pack.aApplyRandom, pItem->GetRandomApplies(), sizeof(pack.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+			pack.bSetValue = pItem->GetItemSetValue();
+#endif
+
+			GetDesc()->Packet(&pack, sizeof(TPacketGCItemSet));
+		}
+		else
+		{
+			TPacketGCItemSetEmpty pack;
+			pack.bHeader = HEADER_GC_ITEM_DEL;
+			pack.Cell = Cell;
+			pack.dwVnum = 0;
+			pack.dwCount = 0;
+			memset(pack.alSockets, 0, sizeof(pack.alSockets));
+			memset(pack.aAttr, 0, sizeof(pack.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+			pack.dwTransmutationVnum = 0;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+			memset(&pack.RefineElement, 0, sizeof(pack.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+			memset(pack.aApplyRandom, 0, sizeof(pack.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+			pack.bSetValue = 0;
+#endif
+
+			GetDesc()->Packet(&pack, sizeof(TPacketGCItemSetEmpty));
+		}
+	}
+
+	if (pItem)
+	{
+		pItem->SetCell(this, wCell);
+		switch (bWindowType)
+		{
+			case INVENTORY:
+				pItem->SetWindow(INVENTORY);
+				break;
+
+			case EQUIPMENT:
+				pItem->SetWindow(EQUIPMENT);
+				break;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			case DRAGON_SOUL_INVENTORY:
+				pItem->SetWindow(DRAGON_SOUL_INVENTORY);
+				break;
+#endif
+
+			case BELT_INVENTORY:
+				pItem->SetWindow(BELT_INVENTORY);
+				break;
+
+#if defined(__ATTR_6TH_7TH__)
+			case NPC_STORAGE:
+				pItem->SetWindow(NPC_STORAGE);
+				break;
+#endif
+
+			default:
+				sys_err("Trying to set window %d, non determined behaviour!", bWindowType);
+		}
+	}
+}
+
+LPITEM CHARACTER::GetWear(WORD wCell) const
+{
+	if (wCell >= EQUIPMENT_MAX_NUM)
+	{
+		sys_err("CHARACTER::GetWear: invalid wear cell %d", wCell);
+		return nullptr;
+	}
+
+	return m_pointsInstant.pEquipmentItems[wCell];
+}
+
+void CHARACTER::SetWear(WORD wCell, LPITEM item)
+{
+	if (wCell >= EQUIPMENT_MAX_NUM)
+	{
+		sys_err("CHARACTER::SetItem: invalid item cell %d", wCell);
+		return;
+	}
+
+	SetItem(TItemPos(EQUIPMENT, wCell), item);
+
+	if (!item && wCell == WEAR_WEAPON)
+	{
+		// Í°    Ì¶ È¿ Ö¾ Ñ´.
+		if (IsAffectFlag(AFF_GWIGUM))
+			RemoveAffect(SKILL_GWIGEOM);
+
+		if (IsAffectFlag(AFF_GEOMGYEONG))
+			RemoveAffect(SKILL_GEOMKYUNG);
+	}
+}
+
+void CHARACTER::ClearItem()
+{
+	int i;
+	LPITEM item;
+
+	for (i = 0; i < INVENTORY_MAX_NUM; ++i)
+	{
+		if ((item = GetInventoryItem(i)))
+		{
+			item->SetSkipSave(true);
+			ITEM_MANAGER::Instance().FlushDelayedSave(item);
+
+			item->RemoveFromCharacter();
+			M2_DESTROY_ITEM(item);
+
+			SyncQuickslot(SLOT_TYPE_INVENTORY, i, WORD_MAX);
+		}
+	}
+
+	for (i = 0; i < EQUIPMENT_MAX_NUM; ++i)
+	{
+		if ((item = GetEquipmentItem(i)))
+		{
+			item->SetSkipSave(true);
+			ITEM_MANAGER::Instance().FlushDelayedSave(item);
+
+			item->RemoveFromCharacter();
+			M2_DESTROY_ITEM(item);
+		}
+	}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	for (i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
+	{
+		if ((item = GetDragonSoulInventoryItem(i)))
+		{
+			item->SetSkipSave(true);
+			ITEM_MANAGER::Instance().FlushDelayedSave(item);
+
+			item->RemoveFromCharacter();
+			M2_DESTROY_ITEM(item);
+		}
+	}
+#endif
+
+	for (i = 0; i < BELT_INVENTORY_SLOT_COUNT; ++i)
+	{
+		if ((item = GetBeltInventoryItem(i)))
+		{
+			item->SetSkipSave(true);
+			ITEM_MANAGER::Instance().FlushDelayedSave(item);
+
+			item->RemoveFromCharacter();
+			M2_DESTROY_ITEM(item);
+
+			SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, i, WORD_MAX);
+		}
+	}
+
+#if defined(__ATTR_6TH_7TH__)
+	if ((item = GetNPCStorageItem()))
+	{
+		item->SetSkipSave(true);
+		ITEM_MANAGER::Instance().FlushDelayedSave(item);
+
+		item->RemoveFromCharacter();
+		M2_DESTROY_ITEM(item);
+	}
+#endif
+}
+
+bool CHARACTER::IsEmptyItemGrid(TItemPos Cell, BYTE bSize, int iExceptionCell) const
+{
+	switch (Cell.window_type)
+	{
+		case INVENTORY:
+		{
+			const WORD wCell = Cell.cell;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+			if (wCell >= GetExtendInvenMax())
+#else
+			if (wCell >= INVENTORY_MAX_NUM)
+#endif
+				return false;
+
+			// bItemCell 0 false Å¸  + 1 Ø¼ Ã³Ñ´.
+			//  iExceptionCell 1  Ñ´.
+			++iExceptionCell;
+
+			if (m_pointsInstant.wInventoryItemGrid[wCell])
+			{
+				if (m_pointsInstant.wInventoryItemGrid[wCell] == iExceptionCell)
+				{
+					if (bSize == 1)
+						return true;
+
+					int iOffset = 1;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+					const WORD wPage = wCell / INVENTORY_PAGE_SIZE;
+#else
+					const WORD wPage = wCell / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT);
+#endif
+					do
+					{
+						const WORD wSlot = wCell + (INVENTORY_WIDTH * iOffset);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+						if (wSlot >= GetExtendInvenMax())
+							return false;
+
+						if (wSlot / INVENTORY_PAGE_SIZE != wPage)
+							return false;
+#else
+						if (wSlot >= INVENTORY_MAX_NUM)
+							return false;
+
+						if (wSlot / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT) != wPage)
+							return false;
+#endif
+
+						if (m_pointsInstant.wInventoryItemGrid[wSlot])
+						{
+							if (m_pointsInstant.wInventoryItemGrid[wSlot] != iExceptionCell)
+								return false;
+						}
+					} while (++iOffset < bSize);
+
+					return true;
+				}
+				else
+					return false;
+			}
+
+			// Å©â°¡ 1Ì¸ Ä­ Ï´ Ì¹Ç· ×³ 
+			if (1 == bSize)
+				return true;
+			else
+			{
+				int iOffset = 1;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+				const WORD wPage = wCell / INVENTORY_PAGE_SIZE;
+#else
+				const WORD wPage = wCell / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT);
+#endif
+
+				do
+				{
+					const WORD wSlot = wCell + (INVENTORY_WIDTH * iOffset);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+					if (wSlot >= GetExtendInvenMax())
+						return false;
+
+					if (wSlot / INVENTORY_PAGE_SIZE != wPage)
+						return false;
+#else
+					if (wSlot >= INVENTORY_MAX_NUM)
+						return false;
+
+					if (wSlot / (INVENTORY_MAX_NUM / INVENTORY_PAGE_COUNT) != wPage)
+						return false;
+#endif
+
+					if (m_pointsInstant.wInventoryItemGrid[wSlot])
+					{
+						if (m_pointsInstant.wInventoryItemGrid[wSlot] != iExceptionCell)
+							return false;
+					}
+				} while (++iOffset < bSize);
+
+				return true;
+			}
+		}
+		break;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case DRAGON_SOUL_INVENTORY:
+		{
+			const WORD wCell = Cell.cell;
+			if (wCell >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+				return false;
+
+			++iExceptionCell;
+
+			if (m_pointsInstant.wDragonSoulInventoryItemGrid[wCell])
+			{
+				if (m_pointsInstant.wDragonSoulInventoryItemGrid[wCell] == iExceptionCell)
+				{
+					if (bSize == 1)
+						return true;
+
+					int iOffset = 1;
+
+					do
+					{
+						const WORD wSlot = wCell + (DRAGON_SOUL_BOX_COLUMN_NUM * iOffset);
+						if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+							return false;
+
+						if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot])
+						{
+							if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] != iExceptionCell)
+								return false;
+						}
+					} while (++iOffset < bSize);
+
+					return true;
+				}
+				else
+					return false;
+			}
+
+			if (1 == bSize)
+				return true;
+			else
+			{
+				int iOffset = 1;
+
+				do
+				{
+					const WORD wSlot = wCell + (DRAGON_SOUL_BOX_COLUMN_NUM * iOffset);
+					if (wSlot >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+						return false;
+
+					if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot])
+					{
+						if (m_pointsInstant.wDragonSoulInventoryItemGrid[wSlot] != iExceptionCell)
+							return false;
+					}
+				} while (++iOffset < bSize);
+
+				return true;
+			}
+		}
+		break;
+#endif
+
+		case BELT_INVENTORY:
+		{
+			const WORD wCell = Cell.cell;
+			if (wCell >= BELT_INVENTORY_MAX_NUM)
+				return false;
+
+			++iExceptionCell;
+
+			const LPITEM pBeltItem = GetWear(WEAR_BELT);
+			if (pBeltItem == nullptr)
+				return false;
+
+			if (!CBeltInventoryHelper::IsAvailableCell(wCell - BELT_INVENTORY_SLOT_START, pBeltItem->GetValue(0)))
+				return false;
+
+			if (m_pointsInstant.bBeltInventoryItemGrid[wCell])
+			{
+				if (m_pointsInstant.bBeltInventoryItemGrid[wCell] == iExceptionCell)
+				{
+					if (bSize == 1)
+						return true;
+
+					int iOffset = 1;
+
+					do
+					{
+						const WORD wSlot = wCell + (BELT_INVENTORY_SLOT_WIDTH * iOffset);
+						if (wSlot >= BELT_INVENTORY_MAX_NUM)
+							return false;
+
+						if (m_pointsInstant.bBeltInventoryItemGrid[wSlot])
+						{
+							if (m_pointsInstant.bBeltInventoryItemGrid[wSlot] != iExceptionCell)
+								return false;
+						}
+					} while (++iOffset < bSize);
+
+					return true;
+				}
+				else
+					return false;
+			}
+
+			if (1 == bSize)
+				return true;
+			else
+			{
+				int iOffset = 1;
+
+				do
+				{
+					const WORD wSlot = wCell + (BELT_INVENTORY_SLOT_WIDTH * iOffset);
+					if (wSlot >= BELT_INVENTORY_MAX_NUM)
+						return false;
+
+					if (m_pointsInstant.bBeltInventoryItemGrid[wSlot])
+					{
+						if (m_pointsInstant.bBeltInventoryItemGrid[wSlot] != iExceptionCell)
+							return false;
+					}
+				} while (++iOffset < bSize);
+
+				return true;
+			}
+		}
+		break;
+	}
+
+	return false;
+}
+
+int CHARACTER::GetEmptyInventory(BYTE size) const
+{
+	// NOTE :   Ô¼  , È¹     Îºä¸®  Ä­ Ã£  Ç° Ö´Âµ,
+	// Æ® Îºä¸® Æ¯ Îºä¸®Ì¹Ç· Ë» Êµ Ñ´. (âº» Îºä¸®: INVENTORY_MAX_NUM  Ë»)
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (int i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+		if (IsEmptyItemGrid(TItemPos(INVENTORY, i), size))
+			return i;
+	return -1;
+}
+
+int CHARACTER::GetEmptyInventoryCount(BYTE size) const
+{
+	// NOTE :   Ô¼  , È¹     Îºä¸®  Ä­ Ã£  Ç° Ö´Âµ,
+	// Æ® Îºä¸® Æ¯ Îºä¸®Ì¹Ç· Ë» Êµ Ñ´. (âº» Îºä¸®: INVENTORY_MAX_NUM  Ë»)
+	int emptyCount = 0;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (int i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+	{
+		if (IsEmptyItemGrid(TItemPos(INVENTORY, i), size))
+			++emptyCount;
+	}
+
+	return emptyCount;
+}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+int CHARACTER::GetEmptyDragonSoulInventory(LPITEM pItem) const
+{
+	if (NULL == pItem || !pItem->IsDragonSoul())
+		return -1;
+
+	if (!DragonSoul_IsQualified())
+		return -1;
+
+	BYTE bSize = pItem->GetSize();
+	WORD wBaseCell = DSManager::instance().GetBasePosition(pItem);
+
+	if (WORD_MAX == wBaseCell)
+		return -1;
+
+	for (int i = 0; i < DRAGON_SOUL_BOX_SIZE; ++i)
+		if (IsEmptyItemGrid(TItemPos(DRAGON_SOUL_INVENTORY, i + wBaseCell), bSize))
+			return i + wBaseCell;
+
+	return -1;
+}
+
+void CHARACTER::CopyDragonSoulItemGrid(std::vector<WORD>& vDragonSoulItemGrid) const
+{
+	vDragonSoulItemGrid.resize(DRAGON_SOUL_INVENTORY_MAX_NUM);
+	std::copy(m_pointsInstant.wDragonSoulInventoryItemGrid, m_pointsInstant.wDragonSoulInventoryItemGrid + DRAGON_SOUL_INVENTORY_MAX_NUM, vDragonSoulItemGrid.begin());
+}
+#endif
+
+int CHARACTER::CountEmptyInventory() const
+{
+	int count = 0;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (int i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+		if (GetInventoryItem(i))
+			count += GetInventoryItem(i)->GetSize();
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	return (GetExtendInvenMax() - count);
+#else
+	return (INVENTORY_MAX_NUM - count);
+#endif
+}
+
+bool CHARACTER::HasEnoughInventorySpace(std::vector<TItemData>& vItems) const
+{
+	if (vItems.empty())
+		return true;
+
+	static std::array<CGrid, 4> aGrids = {
+		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
+		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
+		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT),
+		CGrid(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT)
+	};
+	for (auto& kGrid : aGrids)
+		kGrid.Clear();
+
+	LPITEM pItem = nullptr;
+	for (int i = 0; i < INVENTORY_PAGE_SIZE * 4; ++i)
+	{
+		if ((pItem = GetInventoryItem(i)))
+		{
+			aGrids[i / INVENTORY_PAGE_SIZE].Put(i % INVENTORY_PAGE_SIZE, 1, pItem->GetSize());
+		}
+	}
+
+	for (const TItemData& kItem : vItems)
+	{
+		const TItemTable* pItemTable = ITEM_MANAGER::Instance().GetTable(kItem.dwVnum);
+		if (!pItemTable)
+			return true;
+
+		int iPos = -1;
+		for (int j = 0; j < aGrids.size(); ++j)
+		{
+			iPos = aGrids[j].FindBlank(1, pItemTable->bSize);
+			if (iPos >= 0)
+			{
+#if defined(__EXTEND_INVEN_SYSTEM__)
+				if (j >= 2)
+				{
+					int iExtendMaxPos = (INVENTORY_WIDTH * (GetExtendInvenStage() - (j - 1))) - 1;
+					if (iPos > iExtendMaxPos)
+						return false;
+
+					if (pItemTable->bSize > 1)
+					{
+						iExtendMaxPos -= (INVENTORY_WIDTH * (pItemTable->bSize - 1));
+						if (iPos > iExtendMaxPos)
+							return false;
+					}
+				}
+#endif
+				aGrids[j].Put(iPos, 1, pItemTable->bSize);
+				break;
+			}
+		}
+
+		if (iPos == -1)
+			return false;
+	}
+
+	return true;
+}
+
+void TransformRefineItem(LPITEM pkOldItem, LPITEM pkNewItem)
+{
+	// ACCESSORY_REFINE
+	if (pkOldItem->IsAccessoryForSocket())
+	{
+		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+		{
+			pkNewItem->SetSocket(i, pkOldItem->GetSocket(i));
+		}
+		//pkNewItem->StartAccessorySocketExpireEvent();
+	}
+	// END_OF_ACCESSORY_REFINE
+	else
+	{
+		// â¼­  Úµ Ã» 
+		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+		{
+			if (!pkOldItem->GetSocket(i))
+				break;
+			else
+				pkNewItem->SetSocket(i, 1);
+		}
+
+		//  
+		int slot = 0;
+
+		for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+		{
+			long socket = pkOldItem->GetSocket(i);
+
+			if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
+				pkNewItem->SetSocket(slot++, socket);
+		}
+
+	}
+
+#if defined(__ITEM_SOCKET6__)
+	for (int i = METIN_SOCKET_MAX_NUM; i < ITEM_SOCKET_MAX_NUM; ++i)
+		pkNewItem->SetSocket(i, pkOldItem->GetSocket(i));
+#endif
+
+	//   
+	pkOldItem->CopyAttributeTo(pkNewItem);
+}
+
+void NotifyRefineSuccess(LPCHARACTER ch, LPITEM item, const char* way)
+{
+	if (NULL != ch && item != NULL)
+	{
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineSuceeded");
+
+		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), 1, way);
+	}
+}
+
+void NotifyRefineFail(LPCHARACTER ch, LPITEM item, const char* way, int success = 0)
+{
+	if (NULL != ch && NULL != item)
+	{
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineFailed");
+
+		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), success, way);
+	}
+}
+
+#if defined(__REFINE_MSG_ADD__)
+void NotifyRefineFailType(const LPCHARACTER ch, const LPITEM item, const BYTE type, const char* way, const BYTE success = 0)
+{
+	if (ch && item)
+	{
+		ch->ChatPacket(CHAT_TYPE_COMMAND, "RefineFailedType %d", type);
+		LogManager::instance().RefineLog(ch->GetPlayerID(), item->GetName(), item->GetID(), item->GetRefineLevel(), success, way);
+	}
+}
+#endif
+
+void CHARACTER::SetRefineNPC(LPCHARACTER ch)
+{
+	if (ch != NULL)
+	{
+		m_dwRefineNPCVID = ch->GetVID();
+	}
+	else
+	{
+		m_dwRefineNPCVID = 0;
+	}
+}
+
+bool CHARACTER::DoRefine(LPITEM item, bool bMoneyOnly)
+{
+	if (!CanHandleItem(true))
+	{
+		ClearRefineMode();
+		return false;
+	}
+
+	// Ã° : upgrade_refine_scroll.quest   5Ì³ Ï¹ 
+	//Ò¼ 
+	if (quest::CQuestManager::instance().GetEventFlag("update_refine_time") != 0)
+	{
+		if (get_global_time() < quest::CQuestManager::instance().GetEventFlag("update_refine_time") + (60 * 5))
+		{
+			sys_log(0, "can't refine %d %s", GetPlayerID(), GetName());
+			return false;
+		}
+	}
+
+	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
+	if (!prt)
+		return false;
+
+	DWORD result_vnum = item->GetRefinedVnum();
+
+	// REFINE_COST
+	int cost = ComputeRefineFee(prt->cost);
+
+	int RefineChance = GetQuestFlag("main_quest_lv7.refine_chance");
+
+	if (RefineChance > 0)
+	{
+		if (!item->CheckItemUseLevel(20) || item->GetType() != ITEM_WEAPON)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  È¸ 20  â¸¸ Õ´Ï´"));
+			return false;
+		}
+		cost = 0;
+		SetQuestFlag("main_quest_lv7.refine_chance", RefineChance - 1);
+	}
+	// END_OF_REFINE_COST
+
+	if (result_vnum == 0)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ì»   Ï´."));
+		return false;
+	}
+
+	if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TUNING)
+		return false;
+
+	TItemTable* pProto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
+
+	if (!pProto)
+	{
+		sys_err("DoRefine NOT GET ITEM PROTO %d", item->GetRefinedVnum());
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+		return false;
+	}
+
+	// Check level limit in korea only
+	if (!g_iUseLocale)
+	{
+		for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+		{
+			long limit = pProto->aLimits[i].lValue;
+
+			switch (pProto->aLimits[i].bType)
+			{
+				case LIMIT_LEVEL:
+				{
+					if (GetLevel() < limit)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ñº  Ï´."));
+						return false;
+					}
+				}
+				break;
+
+#if defined(__CONQUEROR_LEVEL__)
+				case LIMIT_NEWWORLD_LEVEL:
+				{
+					if (GetConquerorLevel() < limit)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ñº  Ï´."));
+						return false;
+					}
+				}
+				break;
+#endif
+			}
+		}
+	}
+
+	// REFINE_COST
+	if (GetGold() < (long long)cost)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ï±   Õ´Ï´."));
+		return false;
+	}
+
+#if defined(__REFINE_STACK_FIX__)
+	int iEmptyPos = GetEmptyInventory(item->GetSize());
+	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+	{
+		if (-1 == iEmptyPos)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ç°   Ï´."));
+			return false;
+		}
+	}
+#endif
+
+	if (!bMoneyOnly && !RefineChance)
+	{
+		for (int i = 0; i < prt->material_count; ++i)
+		{
+			if (CountSpecifyItem(prt->materials[i].vnum, item->GetCell()) < prt->materials[i].count)
+			{
+				if (test_server)
+				{
+					ChatPacket(CHAT_TYPE_INFO, "Find %d, count %d, require %d", prt->materials[i].vnum, CountSpecifyItem(prt->materials[i].vnum), prt->materials[i].count);
+				}
+
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ï±  á°¡ Õ´Ï´."));
+				return false;
+			}
+		}
+
+		for (int i = 0; i < prt->material_count; ++i)
+			RemoveSpecifyItem(prt->materials[i].vnum, prt->materials[i].count, item->GetCell());
+	}
+
+	int prob = number(1, 100);
+
+	if (IsRefineThroughGuild() || bMoneyOnly)
+		prob -= 10;
+
+	// END_OF_REFINE_COST
+
+	if (prob <= prt->prob)
+	{
+		// !   ,  Ó¼ Ù¸  È¹
+		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
+
+		if (pkNewItem)
+		{
+			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
+			if (aApplyRandom)
+				pkNewItem->SetRandomApplies(aApplyRandom);
+#endif
+
+			LogManager::instance().ItemLog(this, pkNewItem, "REFINE SUCCESS", pkNewItem->GetName());
+
+			UINT bCell = item->GetCell();
+
+			// DETAIL_REFINE_LOG
+			NotifyRefineSuccess(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
+			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -cost);
+			// END_OF_DETAIL_REFINE_LOG
+
+#if defined(__REFINE_STACK_FIX__)
+			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+			{
+				item->SetCount(item->GetCount() - 1);
+				AutoGiveItem(pkNewItem, true, true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+					, true
+#endif
+				);
+			}
+			else
+			{
+				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
+				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+			}
+#else
+			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
+			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+#endif
+
+			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
+			pkNewItem->AttrLog();
+
+			sys_log(0, "Refine Success %d", cost);
+			//PointChange(POINT_GOLD, -cost);
+			sys_log(0, "PayPee %d", cost);
+			PayRefineFee(cost);
+			sys_log(0, "PayPee End %d", cost);
+		}
+		else
+		{
+			// DETAIL_REFINE_LOG
+			//    ->  Ð· 
+			sys_err("cannot create item %u", result_vnum);
+#if defined(__REFINE_MSG_ADD__)
+			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, IsRefineThroughGuild() ? "GUILD" : "POWER");
+#else
+			NotifyRefineFail(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
+#endif
+			// END_OF_DETAIL_REFINE_LOG
+		}
+	}
+	else
+	{
+		// !   .
+		DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -cost);
+#if defined(__REFINE_MSG_ADD__)
+		NotifyRefineFailType(this, item, REFINE_FAIL_DEL_ITEM, IsRefineThroughGuild() ? "GUILD" : "POWER");
+#else
+		NotifyRefineFail(this, item, IsRefineThroughGuild() ? "GUILD" : "POWER");
+#endif
+		item->AttrLog();
+
+#if defined(__REFINE_STACK_FIX__)
+		if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+		{
+			item->SetCount(item->GetCount() - 1);
+		}
+		else
+		{
+			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
+		}
+#else
+		ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
+#endif
+
+		//PointChange(POINT_GOLD, -cost);
+		PayRefineFee(cost);
+	}
+
+	return true;
+}
+
+enum ERefineScroll
+{
+	CHUKBOK_SCROLL = 0,
+	HYUNIRON_STONE = 1,
+	YONGSIN_SCROLL = 2,
+	MUSIN_SCROLL = 3,
+	YAGONG_SCROLL = 4,
+	MEMO_SCROLL = 5,
+	BDRAGON_SCROLL = 6,
+#if defined(__STONE_OF_BLESS__)
+	BLESSING_STONE = 7,
+#endif
+#if defined(__SOUL_SYSTEM__)
+	SOUL_AWAKE_SCROLL = 8,
+	SOUL_EVOLVE_SCROLL = 9,
+#endif
+#if defined(__STONE_OF_BLESS__)
+	MALL_BLESSING_STONE = 10,
+#endif
+};
+
+#if defined(__SOUL_SYSTEM__)
+bool CHARACTER::DoRefineSoul(LPITEM item)
+{
+	if (!CanHandleItem(true))
+	{
+		ClearRefineMode();
+		return false;
+	}
+
+	ClearRefineMode();
+
+	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
+	if (!prt)
+		return false;
+
+	if (m_iRefineAdditionalCell < 0)
+		return false;
+
+	LPITEM item_scroll = GetInventoryItem(m_iRefineAdditionalCell);
+	if (item_scroll == nullptr)
+		return false;
+
+	if (!(item_scroll->GetType() == ITEM_USE && item_scroll->GetSubType() == USE_TUNING))
+		return false;
+
+	if (item_scroll->GetVnum() == item->GetVnum())
+		return false;
+
+	DWORD result_vnum = item->GetRefinedVnum();
+	if (result_vnum == 0)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ì»   Ï´."));
+		return false;
+	}
+
+	TItemTable* proto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
+	if (!proto)
+	{
+		sys_err("DoRefineSoul NOT GET ITEM PROTO %d", item->GetRefinedVnum());
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+		return false;
+	}
+
+	int prob = number(1, 100);
+	int success_prob = prt->prob;
+
+	switch (item_scroll->GetValue(0))
+	{
+		case SOUL_AWAKE_SCROLL:
+			success_prob = 100;
+			break;
+
+		case SOUL_EVOLVE_SCROLL:
+			success_prob = soul_refine_prob[MINMAX(0, item->GetValue(1), SOUL_GRADE_MAX)];
+			break;
+	}
+
+	item_scroll->SetCount(item_scroll->GetCount() - 1);
+
+	if (prob <= success_prob)
+	{
+		LPITEM new_item = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
+		if (new_item)
+		{
+			WORD wCell = item->GetCell();
+
+			LogManager::instance().ItemLog(this, new_item, "SOUL REFINE FAIL", new_item->GetName());
+			ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulSuceeded");
+
+			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (SOUL REFINE FAIL)");
+
+			new_item->AddToCharacter(this, TItemPos(INVENTORY, wCell));
+			ITEM_MANAGER::instance().FlushDelayedSave(new_item);
+		}
+		else
+		{
+			sys_err("cannot create item %u", result_vnum);
+			ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulFailed");
+		}
+	}
+	else
+	{
+		ChatPacket(CHAT_TYPE_COMMAND, "RefineSoulFailed");
+	}
+
+	return true;
+}
+#endif
+
+bool CHARACTER::DoRefineWithScroll(LPITEM item)
+{
+	if (!CanHandleItem(true))
+	{
+		ClearRefineMode();
+		return false;
+	}
+
+	ClearRefineMode();
+
+	//  Ã° : upgrade_refine_scroll.quest   5Ì³ Ï¹ 
+	// Ò¼ 
+	if (quest::CQuestManager::instance().GetEventFlag("update_refine_time") != 0)
+	{
+		if (get_global_time() < quest::CQuestManager::instance().GetEventFlag("update_refine_time") + (60 * 5))
+		{
+			sys_log(0, "can't refine %d %s", GetPlayerID(), GetName());
+			return false;
+		}
+	}
+
+	const TRefineTable* prt = CRefineManager::instance().GetRefineRecipe(item->GetRefineSet());
+	if (!prt)
+		return false;
+
+	LPITEM pkItemScroll;
+
+	//  Ã¼Å©
+	if (m_iRefineAdditionalCell < 0)
+		return false;
+
+	pkItemScroll = GetInventoryItem(m_iRefineAdditionalCell);
+
+	if (!pkItemScroll)
+		return false;
+
+	if (!(pkItemScroll->GetType() == ITEM_USE && pkItemScroll->GetSubType() == USE_TUNING))
+		return false;
+
+	if (pkItemScroll->GetVnum() == item->GetVnum())
+		return false;
+
+	DWORD result_vnum = item->GetRefinedVnum();
+	DWORD result_fail_vnum = item->GetRefineFromVnum();
+
+	if (result_vnum == 0)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ì»   Ï´."));
+		return false;
+	}
+
+	TItemTable* pProto = ITEM_MANAGER::instance().GetTable(item->GetRefinedVnum());
+	if (!pProto)
+	{
+		sys_err("DoRefineWithScroll NOT GET ITEM PROTO %d", item->GetRefinedVnum());
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+		return false;
+	}
+
+	if (GetGold() < prt->cost)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ï±   Õ´Ï´."));
+		return false;
+	}
+
+#if defined(__REFINE_STACK_FIX__)
+	int iEmptyPos = GetEmptyInventory(item->GetSize());
+	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+	{
+		if (-1 == iEmptyPos)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ç°   Ï´."));
+			return false;
+		}
+	}
+#endif
+
+	for (int i = 0; i < prt->material_count; ++i)
+	{
+		if (CountSpecifyItem(prt->materials[i].vnum, item->GetCell()) < prt->materials[i].count)
+		{
+			if (test_server)
+			{
+				ChatPacket(CHAT_TYPE_INFO, "Find %d, count %d, require %d", prt->materials[i].vnum, CountSpecifyItem(prt->materials[i].vnum), prt->materials[i].count);
+			}
+
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ï±  á°¡ Õ´Ï´."));
+			return false;
+		}
+	}
+
+	for (int i = 0; i < prt->material_count; ++i)
+		RemoveSpecifyItem(prt->materials[i].vnum, prt->materials[i].count, item->GetCell());
+
+	int prob = number(1, 100);
+	const SRefineScrollData& kScroll = GetScrollRefinePct(prt->prob, item->GetRefinedVnum(), pkItemScroll->GetValue(0));
+	const char* szRefineType = "SCROLL";
+
+	switch (pkItemScroll->GetValue(0))
+	{
+		case HYUNIRON_STONE:
+			szRefineType = "HYUNIRON_STONE";
+			break;
+
+		case YONGSIN_SCROLL:
+			szRefineType = "GOD_SCROLL";
+			break;
+
+		case MUSIN_SCROLL:
+			szRefineType = "MUSIN_SCROLL";
+			break;
+
+		case YAGONG_SCROLL:
+			szRefineType = "YAGONG_SCROLL";
+			break;
+
+		case MEMO_SCROLL:
+			szRefineType = "MEMO_SCROLL";
+			break;
+
+		case BDRAGON_SCROLL:
+			szRefineType = "BDRAGON_SCROLL";
+			break;
+
+#if defined(__STONE_OF_BLESS__)
+		case BLESSING_STONE:
+			szRefineType = "BLESSING_STONE";
+			break;
+
+		case MALL_BLESSING_STONE:
+			szRefineType = "MALL_BLESSING_STONE";
+			break;
+#endif
+
+		default:
+			sys_err("REFINE : Unknown refine scroll item. Value0: %d", pkItemScroll->GetValue(0));
+			break;
+	}
+
+	if (test_server)
+		ChatPacket(CHAT_TYPE_INFO, "[Only Test] SuccessProb %d, RefineLevel %d ", kScroll.bSuccessProb, item->GetRefineLevel());
+
+	pkItemScroll->SetCount(pkItemScroll->GetCount() - 1);
+
+	if (prob <= kScroll.bSuccessProb)
+	{
+		// !   ,  Ó¼ Ù¸  È¹
+		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_vnum, 1, 0, false);
+
+		if (pkNewItem)
+		{
+			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
+			if (aApplyRandom)
+				pkNewItem->SetRandomApplies(aApplyRandom);
+#endif
+
+			LogManager::instance().ItemLog(this, pkNewItem, "REFINE SUCCESS", pkNewItem->GetName());
+
+			UINT bCell = item->GetCell();
+
+			NotifyRefineSuccess(this, item, szRefineType);
+			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -prt->cost);
+
+#if defined(__REFINE_STACK_FIX__)
+			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+			{
+				item->SetCount(item->GetCount() - 1);
+				AutoGiveItem(pkNewItem, true, true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+					, true
+#endif
+				);
+			}
+			else
+			{
+				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
+				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+			}
+#else
+			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE SUCCESS)");
+			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+#endif
+
+			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
+			pkNewItem->AttrLog();
+
+			//PointChange(POINT_GOLD, -prt->cost);
+			PayRefineFee(prt->cost);
+		}
+		else
+		{
+			//    ->  Ð· 
+			sys_err("cannot create item %u", result_vnum);
+#if defined(__REFINE_MSG_ADD__)
+			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
+#else
+			NotifyRefineFail(this, item, szRefineType);
+#endif
+		}
+	}
+	else if (!kScroll.bKeepGrade && result_fail_vnum)
+	{
+		// !   ,  Ó¼    È¹
+		LPITEM pkNewItem = ITEM_MANAGER::instance().CreateItem(result_fail_vnum, 1, 0, false);
+
+		if (pkNewItem)
+		{
+			ITEM_MANAGER::CopyAllAttrTo(item, pkNewItem);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			UpdateExtBattlePassMissionProgress(BP_ITEM_REFINE, 1, item->GetVnum());
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+			TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+			item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_PREVIOUS);
+			if (aApplyRandom)
+				pkNewItem->SetRandomApplies(aApplyRandom);
+#endif
+
+			LogManager::instance().ItemLog(this, pkNewItem, "REFINE FAIL", pkNewItem->GetName());
+
+			UINT bCell = item->GetCell();
+
+			DBManager::instance().SendMoneyLog(MONEY_LOG_REFINE, item->GetVnum(), -prt->cost);
+#if defined(__REFINE_MSG_ADD__)
+			NotifyRefineFailType(this, item, REFINE_FAIL_GRADE_DOWN, szRefineType, -1);
+#else
+			NotifyRefineFail(this, item, szRefineType, -1);
+
+#endif
+
+#if defined(__REFINE_STACK_FIX__)
+			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+			{
+				item->SetCount(item->GetCount() - 1);
+				AutoGiveItem(pkNewItem, true, true
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+					, true
+#endif
+				);
+			}
+			else
+			{
+				ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
+				pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+			}
+#else
+			ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (REFINE FAIL)");
+			pkNewItem->AddToCharacter(this, TItemPos(INVENTORY, bCell));
+#endif
+
+			ITEM_MANAGER::instance().FlushDelayedSave(pkNewItem);
+			pkNewItem->AttrLog();
+
+			//PointChange(POINT_GOLD, -prt->cost);
+			PayRefineFee(prt->cost);
+		}
+		else
+		{
+			//    ->  Ð· 
+			sys_err("cannot create item %u", result_fail_vnum);
+#if defined(__REFINE_MSG_ADD__)
+			NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
+#else
+			NotifyRefineFail(this, item, szRefineType);
+#endif
+		}
+	}
+	else
+	{
+#if defined(__REFINE_MSG_ADD__)
+		NotifyRefineFailType(this, item, REFINE_FAIL_KEEP_GRADE, szRefineType);
+#else
+		NotifyRefineFail(this, item, szRefineType); //    
+#endif
+		PayRefineFee(prt->cost);
+	}
+
+	return true;
+}
+
+CHARACTER::SRefineScrollData CHARACTER::GetScrollRefinePct(BYTE bProb, BYTE bRefineLevel, BYTE bScrollType)
+{
+	SRefineScrollData Scroll{};
+	Scroll.bSuccessProb = bProb;
+	Scroll.bKeepGrade = false;
+
+	// Ã¶,  àº¹, ß°  Ã³
+	switch (bScrollType)
+	{
+		case CHUKBOK_SCROLL:
+			break;
+
+		case HYUNIRON_STONE:
+			Scroll.bSuccessProb = MINMAX(1, bProb + 10, 100);
+			Scroll.bKeepGrade = true;
+			break;
+
+		case YONGSIN_SCROLL:
+			Scroll.bSuccessProb = MINMAX(1, bProb + 10, 100);
+			break;
+
+		case MUSIN_SCROLL: //  àº¹ 100%  (+4)
+			Scroll.bSuccessProb = 100;
+			break;
+
+		case YAGONG_SCROLL:
+			Scroll.bSuccessProb = MINMAX(1, bProb + 15, 100);
+			break;
+
+		case MEMO_SCROLL:
+			Scroll.bSuccessProb = 100;
+			break;
+
+		case BDRAGON_SCROLL:
+			Scroll.bSuccessProb = 80;
+			break;
+
+#if defined(__STONE_OF_BLESS__)
+		case BLESSING_STONE:
+			Scroll.bSuccessProb = MINMAX(1, bProb + 15, 100);
+			Scroll.bKeepGrade = true;
+			break;
+
+		case MALL_BLESSING_STONE:
+			Scroll.bSuccessProb = MINMAX(1, bProb + 20, 100);
+			Scroll.bKeepGrade = true;
+			break;
+#endif
+	}
+
+	return Scroll;
+}
+
+bool CHARACTER::RefineInformation(WORD wCell, BYTE bType, int iAdditionalCell)
+{
+	if (wCell > INVENTORY_MAX_NUM)
+		return false;
+
+	const LPITEM item = GetInventoryItem(wCell);
+	if (!item)
+		return false;
+
+	// REFINE_COST
+	if (bType == REFINE_TYPE_MONEY_ONLY && !GetQuestFlag("deviltower_zone.can_refine"))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Å¸ Ï·  Ñ¹ ë°¡Õ´Ï´."));
+		return false;
+	}
+	// END_OF_REFINE_COST
+
+	TPacketGCRefineInformation p;
+	p.header = HEADER_GC_REFINE_INFORMATION;
+	p.pos = wCell;
+	p.src_vnum = item->GetVnum();
+	p.result_vnum = item->GetRefinedVnum();
+	p.type = bType;
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	thecore_memcpy(&p.RefineElement, item->GetRefineElement(), sizeof(p.RefineElement));
+#endif
+
+#if defined(__ITEM_APPLY_RANDOM__)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_MAX_NUM];
+	item->GetRandomApplyTable(aApplyRandom, CApplyRandomTable::GET_NEXT);
+	thecore_memcpy(&p.aApplyRandom, aApplyRandom, sizeof(p.aApplyRandom));
+#endif
+
+	if (p.result_vnum == 0)
+	{
+		sys_err("RefineInformation p.result_vnum == 0");
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+		return false;
+	}
+
+	if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TUNING)
+	{
+		if (bType == 0)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Î´   Ï´."));
+			return false;
+		}
+		else
+		{
+			const LPITEM& item_scroll = GetInventoryItem(iAdditionalCell);
+			if (!item_scroll || item->GetVnum() == item_scroll->GetVnum())
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ä¥  Ï´."));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("àº¹  Ã¶ Ä¥  Ö½Ï´."));
+				return false;
+			}
+		}
+	}
+
+#if defined(__SOUL_SYSTEM__)
+	if (item->GetType() == ITEM_SOUL)
+	{
+		if (bType == REFINE_TYPE_SOUL_AWAKE || bType == REFINE_TYPE_SOUL_EVOLVE)
+		{
+			p.cost = 0;
+			p.prob = bType == REFINE_TYPE_SOUL_AWAKE ? 100 : soul_refine_prob[MINMAX(0, item->GetValue(1), SOUL_GRADE_MAX)];
+			p.material_count = 0;
+			std::memset(p.materials, 0, sizeof(p.materials));
+
+			GetDesc()->Packet(&p, sizeof(TPacketGCRefineInformation));
+
+			SetRefineMode(iAdditionalCell);
+			return true;
+		}
+	}
+#endif
+
+	CRefineManager& rm = CRefineManager::instance();
+	const TRefineTable* prt = rm.GetRefineRecipe(item->GetRefineSet());
+	if (!prt)
+	{
+		sys_err("RefineInformation NOT GET REFINE SET %d", item->GetRefineSet());
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+		return false;
+	}
+
+	// REFINE_COST
+
+	// MAIN_QUEST_LV7
+	if (GetQuestFlag("main_quest_lv7.refine_chance") > 0)
+	{
+		// Ïº 
+		if (!item->CheckItemUseLevel(20) || item->GetType() != ITEM_WEAPON)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  È¸ 20  â¸¸ Õ´Ï´"));
+			return false;
+		}
+		p.cost = 0;
+	}
+	else
+		p.cost = ComputeRefineFee(prt->cost);
+	// END_MAIN_QUEST_LV7
+
+	const LPITEM& item_scroll = GetInventoryItem(iAdditionalCell);
+	if (item_scroll)
+	{
+		const SRefineScrollData& kScroll = GetScrollRefinePct(prt->prob, item->GetRefinedVnum(), item_scroll->GetValue(0));
+		p.prob = kScroll.bSuccessProb;
+	}
+	else
+	{
+		p.prob = prt->prob;
+
+		if (IsRefineThroughGuild())
+			p.prob += 10;
+	}
+
+	if (p.prob > 100)
+		p.prob = 100;
+
+	if (bType == REFINE_TYPE_MONEY_ONLY)
+	{
+		p.material_count = 0;
+		memset(p.materials, 0, sizeof(p.materials));
+	}
+	else
+	{
+		p.material_count = prt->material_count;
+		thecore_memcpy(&p.materials, prt->materials, sizeof(prt->materials));
+	}
+	// END_OF_REFINE_COST
+
+	GetDesc()->Packet(&p, sizeof(TPacketGCRefineInformation));
+
+	SetRefineMode(iAdditionalCell);
+	return true;
+}
+
+bool CHARACTER::RefineItem(LPITEM pkItem, LPITEM pkTarget)
+{
+	if (!CanHandleItem())
+		return false;
+
+	if (pkItem->GetSubType() == USE_TUNING)
+	{
+		// XXX ,   Ï´...
+		// XXX É° àº¹  Ç¾!
+
+		BYTE bRefineType = REFINE_TYPE_NORMAL;
+		switch (pkItem->GetValue(0))
+		{
+			case HYUNIRON_STONE:
+				bRefineType = REFINE_TYPE_HYUNIRON;
+				break;
+
+			case MUSIN_SCROLL:
+			{
+				if (pkTarget->GetRefineLevel() >= 4)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Ì»   Ï´."));
+					return false;
+				}
+
+				bRefineType = REFINE_TYPE_MUSIN;
+			}
+			break;
+
+			case MEMO_SCROLL:
+			{
+				if (pkTarget->GetRefineLevel() != pkItem->GetValue(1))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+					return false;
+				}
+
+				bRefineType = REFINE_TYPE_NOT_USED1;
+			}
+			break;
+
+			case BDRAGON_SCROLL:
+			{
+				if (pkTarget->GetType() != ITEM_METIN || pkTarget->GetRefineLevel() != 4)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+					return false;
+				}
+
+				if (pkTarget->GetRefineSet() != 702)
+					return false;
+			}
+			break;
+
+#if defined(__STONE_OF_BLESS__)
+			case BLESSING_STONE:
+			{
+				if (pkTarget->GetLevelLimit() <= 80)
+					return false;
+
+				bRefineType = REFINE_TYPE_BLESSING_STONE;
+			}
+			break;
+
+			case MALL_BLESSING_STONE:
+				bRefineType = REFINE_TYPE_BLESSING_STONE;
+				break;
+#endif
+
+#if defined(__SOUL_SYSTEM__)
+			case SOUL_AWAKE_SCROLL:
+			case SOUL_EVOLVE_SCROLL:
+			{
+				if (pkTarget->GetType() != ITEM_SOUL)
+					return false;
+
+				if (pkTarget->GetValue(0) >= SOUL_GRADE_ILUMINED)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Soul System] %s is already at the highest level.", LC_ITEM(pkTarget->GetVnum())));
+					return false;
+				}
+
+				if (pkItem->GetValue(0) == SOUL_AWAKE_SCROLL)
+					bRefineType = REFINE_TYPE_SOUL_AWAKE;
+				else if (pkItem->GetValue(0) == SOUL_EVOLVE_SCROLL)
+					bRefineType = REFINE_TYPE_SOUL_EVOLVE;
+			}
+			break;
+#endif
+
+			default:
+			{
+				if (pkTarget->GetRefineSet() == 501)
+					return false;
+
+				if (pkTarget->GetVnum() >= 28330 && pkTarget->GetVnum() <= 28343) // +3
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("+3      Ï´"));
+					return false;
+				}
+
+				if (pkTarget->GetVnum() >= 28430 && pkTarget->GetVnum() <= 28443) // +4
+				{
+					if (pkItem->GetVnum() != 71056) // Ã»Ç¼
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("     Ï´"));
+						return false;
+					}
+				}
+
+				bRefineType = REFINE_TYPE_SCROLL;
+			}
+			break;
+		}
+
+		RefineInformation(pkTarget->GetCell(), bRefineType, pkItem->GetCell());
+	}
+	else if (pkItem->GetSubType() == USE_DETACHMENT && IS_SET(pkTarget->GetFlag(), ITEM_FLAG_REFINEABLE) && pkTarget->IsRemovableSocket())
+	{
+		LogManager::instance().ItemLog(this, pkTarget, "USE_DETACHMENT", pkTarget->GetName());
+
+		bool bHasMetinStone = false;
+
+		for (int i = 0; i < METIN_SOCKET_MAX_NUM; i++)
+		{
+			long socket = pkTarget->GetSocket(i);
+			if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
+			{
+				bHasMetinStone = true;
+				break;
+			}
+		}
+
+		if (bHasMetinStone)
+		{
+			for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+			{
+				long socket = pkTarget->GetSocket(i);
+				if (socket > 2 && socket != ITEM_BROKEN_METIN_VNUM)
+				{
+#if defined(__GLOVE_SYSTEM__)
+					if (pkTarget->IsGlove() && socket >= 1000000)
+					{
+						DWORD dwBaseIndex = 28046;
+						dwBaseIndex += (((socket / 1000) % 10) * 100);
+						dwBaseIndex += ((socket / 100) % 10) - 1;
+
+						const TItemTable* pItemData = ITEM_MANAGER::instance().GetTable(dwBaseIndex);
+						if (pItemData == nullptr)
+							continue;
+
+						socket = dwBaseIndex;
+					}
+#endif
+					AutoGiveItem(socket);
+					//TItemTable* pTable = ITEM_MANAGER::instance().GetTable(pkTarget->GetSocket(i));
+					//pkTarget->SetSocket(i, pTable->alValues[2]);
+					//  Ã¼Ø´
+					pkTarget->SetSocket(i, ITEM_BROKEN_METIN_VNUM);
+				}
+			}
+			pkItem->SetCount(pkItem->GetCount() - 1);
+			return true;
+		}
+		else
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ö´ Æ¾ Ï´."));
+			return false;
+		}
+	}
+
+	return false;
+}
+
+EVENTFUNC(kill_campfire_event)
+{
+	char_event_info* info = dynamic_cast<char_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("kill_campfire_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPCHARACTER ch = info->ch;
+
+	if (ch == NULL) // <Factor>
+		return 0;
+
+	ch->m_pkMiningEvent = NULL;
+	M2_DESTROY_CHARACTER(ch);
+	return 0;
+}
+
+bool CHARACTER::GiveRecallItem(LPITEM item)
+{
+	int idx = GetMapIndex();
+	int iEmpireByMapIndex = -1;
+
+	if (idx < 20)
+		iEmpireByMapIndex = 1;
+	else if (idx < 40)
+		iEmpireByMapIndex = 2;
+	else if (idx < 60)
+		iEmpireByMapIndex = 3;
+	else if (idx < 10000)
+		iEmpireByMapIndex = 0;
+
+	switch (idx)
+	{
+		case 66:
+		case 216:
+		case 301:
+		case 302:
+		case 303:
+		case 304:
+			iEmpireByMapIndex = -1;
+			break;
+	}
+
+	if (iEmpireByMapIndex && GetEmpire() != iEmpireByMapIndex)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ä¡ Ô´Ï´."));
+		return false;
+	}
+
+	int pos;
+
+	if (item->GetCount() == 1) //  Ï³ ×³ .
+	{
+		item->SetSocket(0, GetX());
+		item->SetSocket(1, GetY());
+	}
+	else if ((pos = GetEmptyInventory(item->GetSize())) != -1) // ×· Ê´Ù¸ Ù¸ Îºä¸®  Ã£Â´.
+	{
+		LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), 1);
+		if (item2 != nullptr)
+		{
+			item2->SetSocket(0, GetX());
+			item2->SetSocket(1, GetY());
+			item2->AddToCharacter(this, TItemPos(INVENTORY, pos));
+
+			item->SetCount(item->GetCount() - 1);
+		}
+	}
+	else
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ç°   Ï´."));
+		return false;
+	}
+
+	return true;
+}
+
+void CHARACTER::ProcessRecallItem(LPITEM item)
+{
+	int idx;
+
+	if ((idx = SECTREE_MANAGER::instance().GetMapIndex(item->GetSocket(0), item->GetSocket(1))) == 0)
+		return;
+
+	int iEmpireByMapIndex = -1;
+
+	if (idx < 20)
+		iEmpireByMapIndex = 1;
+	else if (idx < 40)
+		iEmpireByMapIndex = 2;
+	else if (idx < 60)
+		iEmpireByMapIndex = 3;
+	else if (idx < 10000)
+		iEmpireByMapIndex = 0;
+
+	switch (idx)
+	{
+		case 66:
+		case 216:
+			iEmpireByMapIndex = -1;
+			break;
+			// Ç·æ±º Ï¶
+		case 301:
+		case 302:
+		case 303:
+		case 304:
+			if (GetLevel() < 90)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ñº  Ï´."));
+				return;
+			}
+			else
+				break;
+	}
+
+	if (iEmpireByMapIndex && GetEmpire() != iEmpireByMapIndex)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ä¡ Å¸  Ö¾î¼­ È¯  Ï´."));
+		item->SetSocket(0, 0);
+		item->SetSocket(1, 0);
+	}
+	else
+	{
+		sys_log(1, "Recall: %s %d %d -> %d %d", GetName(), GetX(), GetY(), item->GetSocket(0), item->GetSocket(1));
+		WarpSet(item->GetSocket(0), item->GetSocket(1));
+		item->SetCount(item->GetCount() - 1);
+	}
+}
+
+void CHARACTER::__OpenPrivateShop()
+{
+	unsigned bodyPart = GetPart(PART_MAIN);
+	switch (bodyPart)
+	{
+	case 0:
+	case 1:
+	case 2:
+		ChatPacket(CHAT_TYPE_COMMAND, "OpenPrivateShop");
+		break;
+	default:
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("      Ö½Ï´."));
+		break;
+	}
+}
+
+// MYSHOP_PRICE_LIST
+
+void CHARACTER::SendMyShopPriceListCmd(DWORD dwItemVnum, DWORD dwItemPrice
+#if defined(__CHEQUE_SYSTEM__)
+	, DWORD dwItemCheque
+#endif
+)
+{
+	char szLine[256];
+#if defined(__CHEQUE_SYSTEM__)
+	snprintf(szLine, sizeof(szLine), "MyShopPriceList %u %u %u", dwItemVnum, dwItemPrice, dwItemCheque);
+#else
+	snprintf(szLine, sizeof(szLine), "MyShopPriceList %u %u", dwItemVnum, dwItemPrice);
+#endif
+	ChatPacket(CHAT_TYPE_COMMAND, szLine);
+	sys_log(0, szLine);
+}
+
+//
+// DB Ä³Ã·   Æ® User  Ï°   Ä¿Çµå¸¦ .
+//
+void CHARACTER::UseSilkBotaryReal(const TPacketMyshopPricelistHeader* p)
+{
+	const TItemPriceInfo* pInfo = (const TItemPriceInfo*)(p + 1);
+
+#if defined(__CHEQUE_SYSTEM__)
+	if (!p->byCount)
+		SendMyShopPriceListCmd(1, 0, 0);
+	else
+	{
+		for (int idx = 0; idx < p->byCount; idx++)
+			SendMyShopPriceListCmd(pInfo[idx].dwVnum, pInfo[idx].dwPrice, pInfo[idx].dwCheque);
+	}
+#else
+	if (!p->byCount)
+		//  Æ® . dummy Í¸  Ä¿Çµå¸¦ Ø´.
+		SendMyShopPriceListCmd(1, 0);
+	else {
+		for (int idx = 0; idx < p->byCount; idx++)
+			SendMyShopPriceListCmd(pInfo[idx].dwVnum, pInfo[idx].dwPrice);
+	}
+#endif
+
+	__OpenPrivateShop();
+}
+
+//
+// Ì¹   Ã³  Open Ï´  Æ® Load Ï±  DB Ä³Ã¿  Æ® Ã» Å¶ .
+// ÄºÍ´ Ù·    .
+//
+void CHARACTER::UseSilkBotary(void)
+{
+	if (m_bNoOpenedShop)
+	{
+		DWORD dwPlayerID = GetPlayerID();
+		db_clientdesc->DBPacket(HEADER_GD_MYSHOP_PRICELIST_REQ, GetDesc()->GetHandle(), &dwPlayerID, sizeof(DWORD));
+		m_bNoOpenedShop = false;
+	}
+	else
+	{
+		__OpenPrivateShop();
+	}
+}
+// END_OF_MYSHOP_PRICE_LIST
+
+int CalculateConsume(LPCHARACTER ch)
+{
+	static const int WARP_NEED_LIFE_PERCENT = 30;
+	static const int WARP_MIN_LIFE_PERCENT = 10;
+	// CONSUME_LIFE_WHEN_USE_WARP_ITEM
+	int consumeLife = 0;
+	{
+		// CheckNeedLifeForWarp
+		const int curLife = ch->GetHP();
+		const int needPercent = WARP_NEED_LIFE_PERCENT;
+		const int needLife = ch->GetMaxHP() * needPercent / 100;
+		if (curLife < needLife)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Ú¶   Ï´."));
+			return -1;
+		}
+
+		consumeLife = needLife;
+
+		// CheckMinLifeForWarp:  Ø¼  ÈµÇ¹Ç·  Ö¼Ò· Ø´
+		const int minPercent = WARP_MIN_LIFE_PERCENT;
+		const int minLife = ch->GetMaxHP() * minPercent / 100;
+		if (curLife - needLife < minLife)
+			consumeLife = curLife - minLife;
+
+		if (consumeLife < 0)
+			consumeLife = 0;
+	}
+	// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
+	return consumeLife;
+}
+
+int CalculateConsumeSP(LPCHARACTER lpChar)
+{
+	static const int NEED_WARP_SP_PERCENT = 30;
+
+	const int curSP = lpChar->GetSP();
+	const int needSP = lpChar->GetMaxSP() * NEED_WARP_SP_PERCENT / 100;
+
+	if (curSP < needSP)
+	{
+		lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Å·  Ú¶   Ï´."));
+		return -1;
+	}
+
+	return needSP;
+}
+
+bool CHARACTER::UseItemEx(LPITEM item, TItemPos DestCell)
+{
+	int iLimitRealtimeStartFirstUseFlagIndex = -1;
+	int iLimitTimerBasedOnWearFlagIndex = -1;
+
+	WORD wDestCell = DestCell.cell;
+	BYTE bDestInven = DestCell.window_type;
+
+	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+	{
+		long limitValue = item->GetProto()->aLimits[i].lValue;
+
+		switch (item->GetProto()->aLimits[i].bType)
+		{
+			case LIMIT_LEVEL:
+			{
+				if (GetLevel() < limitValue)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ñº  Ï´."));
+					return false;
+				}
+			}
+			break;
+
+#if defined(__CONQUEROR_LEVEL__)
+			case LIMIT_NEWWORLD_LEVEL:
+			{
+				if (GetConquerorLevel() < limitValue)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ñº  Ï´."));
+					return false;
+				}
+			}
+			break;
+#endif
+
+			case LIMIT_REAL_TIME_START_FIRST_USE:
+				iLimitRealtimeStartFirstUseFlagIndex = i;
+				break;
+
+			case LIMIT_TIMER_BASED_ON_WEAR:
+				iLimitTimerBasedOnWearFlagIndex = i;
+				break;
+		}
+	}
+
+	if (test_server)
+	{
+		sys_log(0, "USE_ITEM %s, Inven %d, Cell %d, ItemType %d, SubType %d", item->GetName(), bDestInven, wDestCell, item->GetType(), item->GetSubType());
+	}
+
+	if (CArenaManager::instance().IsLimitedItem(GetMapIndex(), item->GetVnum()))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß¿ Ì¿   Ç°Ô´Ï´."));
+		return false;
+	}
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
+		iLimitRealtimeStartFirstUseFlagIndex = -1;
+#endif
+
+	//    ÄºÍ´  Ê¾Æµ Ã° Ç´  Ã³.
+	if (-1 != iLimitRealtimeStartFirstUseFlagIndex)
+	{
+		//  Ì¶   Î´ Socket1  Ç´Ñ´. (Socket1 È½ )
+		if (0 == item->GetSocket(1))
+		{
+			// ë°¡É½Ã° Default  Limit Value  Ïµ, Socket0     Ïµ Ñ´. ( )
+			long duration = (0 != item->GetSocket(0)) ? item->GetSocket(0) : item->GetProto()->aLimits[iLimitRealtimeStartFirstUseFlagIndex].lValue;
+
+			if (0 == duration)
+				duration = 60 * 60 * 24 * 7;
+
+			item->SetSocket(0, time(0) + duration);
+			item->StartRealTimeExpireEvent();
+		}
+
+		if (false == item->IsEquipped())
+			item->SetSocket(1, item->GetSocket(1) + 1);
+	}
+
+#if defined(__MAILBOX__)
+	if (item->GetVnum() == ITEM_MOBILE_MAILBOX)
+	{
+		CMailBox::Open(this);
+		return true;
+	}
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	if (item->GetVnum() == ITEM_EXTEND_INVEN_TICKET ||
+		item->GetVnum() == ITEM_EXTEND_INVEN_TICKET_MALL)
+	{
+		ExtendInvenRequest();
+		return true;
+	}
+#endif
+
+	switch (item->GetType())
+	{
+#ifdef __GROWTH_PET_SYSTEM__
+		case ITEM_PET:
+			{
+				switch (item->GetSubType())
+				{
+					case PET_PAY:
+					{
+						if (GetArena() != NULL || IsObserverMode() == true)
+						{
+							if (item->GetVnum() == 50051 || item->GetVnum() == 50052 || item->GetVnum() == 50053)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß¿ Ì¿   Ç°Ô´Ï´."));
+								return false;
+							}
+						}
+
+						if (!IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE) || item->GetSubType() == PET_PAY)
+						{
+							if (item->GetSIGVnum() == 0)
+							{
+								quest::CQuestManager::instance().UseItem(GetPlayerID(), item, false);
+							}
+							else
+							{
+								quest::CQuestManager::instance().SIGUse(GetPlayerID(), item->GetSIGVnum(), item, false);
+							}
+						}
+						break;
+					}
+					
+					case PET_UPBRINGING:
+					{
+						LPGROWTH_PET pPet = GetGrowthPet(item->GetSocket(2));
+						if (pPet)
+						{
+							if (m_activeGrowthPet && m_activeGrowthPet->GetPetID() == pPet->GetPetID())
+							{
+								m_activeGrowthPet->Unsummon();
+								m_activeGrowthPet = nullptr;
+								return true;
+							}
+							else if (m_activeGrowthPet)
+								m_activeGrowthPet->Unsummon();
+
+							m_activeGrowthPet = pPet->Summon(item);
+						}
+					} break;
+
+					case PET_FEEDSTUFF:
+					{
+						LPITEM item2;
+
+						if (!GetItem(DestCell) || !(item2 = GetItem(DestCell)))
+							return false;
+
+						if (item2->GetType() != ITEM_PET && item2->GetSubType() != PET_UPBRINGING)
+							return false;
+
+						LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
+						if (!pPet)
+							return false;
+
+						if (item2->GetSocket(0) < get_global_time())
+						{
+							pPet->Revive(item2, PET_REVIVE_TYPE_NORMAL);
+							ITEM_MANAGER::instance().RemoveItem(item);
+						}
+						else
+						{
+							pPet->RewardFood(item, PET_FEED_TYPE_FULL);
+						}
+
+					} break;
+
+					case PET_BAG:
+					{
+						LPITEM item2 = GetItem(DestCell);
+						
+						if (item2)
+						{
+							if (item2->GetType() != ITEM_PET)
+								return false;
+
+							if (item2->GetSubType() != PET_UPBRINGING && item2->GetSubType() != PET_BAG)
+								return false;
+
+							switch (item2->GetSubType())
+							{
+								case PET_UPBRINGING:
+								{
+									LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
+									if (!pPet)
+										return false;
+
+									pPet->SetState(STATE_BAG);
+									pPet->SetSummonItem(nullptr);
+									pPet->Save();
+
+									time_t currentTime = time(0);
+									item->SetSocket(0, currentTime + item->GetLimitValue(0));
+									item->SetSocket(1, time(0));
+									item->SetSocket(2, pPet->GetPetID());
+									item->SetSocket(3, pPet->GetPetType());
+									item->StartRealTimeExpireEvent();
+
+									ITEM_MANAGER::instance().RemoveItem(item2, "REMOVE (UPBRINGING-BAG TRANSFER)");
+								} break;
+
+								case PET_BAG:
+								{
+									LPGROWTH_PET pPet = GetGrowthPet(item2->GetSocket(2));
+									if (!pPet)
+										return false;
+
+									/* Pet age equals to difference between birthday and current time minus time spent in bag */
+
+									// Time spent in bag: current time - the time pet was put into the bag
+									time_t currentTime = time(0);
+									DWORD dwBagTime = currentTime - (item2->GetSocket(0) - item2->GetLimitValue(0));
+									DWORD dwPetAge = currentTime - pPet->GetPetPoint(POINT_UPBRINGING_BIRTHDAY) - dwBagTime;
+
+									// Shift back pet's birthday from current time & update real time event
+									pPet->ChangePetPoint(POINT_UPBRINGING_BIRTHDAY, currentTime - dwPetAge, true);
+									pPet->Save();
+
+									item2->SetSocket(0, currentTime + item2->GetLimitValue(0));
+									item2->StartRealTimeExpireEvent();
+									item->SetSocket(3, pPet->GetPetType());
+
+									ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (BAG-BAG TRANSFER)");
+								} break;
+							}
+						}
+						else
+						{
+							if (!item->GetSocket(2))
+								return false;
+
+							LPGROWTH_PET pPet = GetGrowthPet(item->GetSocket(2));
+							if (!pPet)
+								return false;
+
+							time_t currentTime = time(0);
+							DWORD dwBagTime = item->GetSocket(0) - item->GetLimitValue(0);
+							DWORD dwPetAge = currentTime - pPet->GetPetPoint(POINT_UPBRINGING_BIRTHDAY) - (currentTime - dwBagTime);
+							DWORD dwPetDuration = currentTime + pPet->GetPetPoint(POINT_UPBRINGING_MAX_DURATION);
+							LPITEM pUpBringingItem = AutoGiveItem(pPet->GetSummonItemVnum());
+
+							// Copy stats from old pet to a new table
+							TGrowthPet petTable;
+							pPet->CreateGrowthPetProto(&petTable);
+							petTable.dwID = pUpBringingItem->GetID();
+							petTable.lBirthday = currentTime - dwPetAge;
+							petTable.lEndTime = dwPetDuration;
+							petTable.bState = STATE_UPBRINGING;
+
+							// Create a new pet and copy stats from table to it
+							LPGROWTH_PET pNewPet = CGrowthPetManager::Instance().CreateGrowthPet(this, pUpBringingItem->GetID());
+							pNewPet->SetGrowthPetProto(&petTable);
+
+							// Sync upbringing sockets with the new pet
+							pUpBringingItem->SetSocket(0, dwPetDuration);
+							pUpBringingItem->SetSocket(1, petTable.lMaxTime);
+							pUpBringingItem->SetSocket(2, pUpBringingItem->GetID());
+							pUpBringingItem->SetSocket(3, item->GetSocket(3));
+
+							pPet->SetSummonItem(pUpBringingItem);
+							pPet->Save();
+
+							SetGrowthPet(pNewPet);
+
+							CGrowthPetManager::Instance().DeleteGrowthPet(item->GetSocket(2), true);
+							ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (BAG-UPBRINGING TRANSFER)");
+						}
+					} break;
+				}
+
+			} break;
+#endif
+		case ITEM_HAIR:
+			return ItemProcess_Hair(item, wDestCell);
+
+		case ITEM_POLYMORPH:
+			return ItemProcess_Polymorph(item);
+
+		case ITEM_QUEST:
+		{
+			if (GetArena() != NULL || IsObserverMode() == true)
+			{
+				if (item->GetVnum() == ITEM_VNUM_HORSE_PICTURE || item->GetVnum() == ITEM_VNUM_ARMED_HORSE_BOOK || item->GetVnum() == ITEM_VNUM_MILITARY_HORSE_BOOK)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß¿ Ì¿   Ç°Ô´Ï´."));
+					return false;
+				}
+			}
+
+			if (!IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE))
+			{
+				if (item->GetSIGVnum() == 0)
+				{
+					quest::CQuestManager::instance().UseItem(GetPlayerID(), item, false);
+				}
+				else
+				{
+					quest::CQuestManager::instance().SIGUse(GetPlayerID(), item->GetSIGVnum(), item, false);
+				}
+			}
+		}
+		break;
+
+		case ITEM_CAMPFIRE:
+		{
+			float fx, fy;
+			GetDeltaByDegree(GetRotation(), 100.0f, &fx, &fy);
+
+			LPSECTREE tree = SECTREE_MANAGER::instance().Get(GetMapIndex(), (long)(GetX() + fx), (long)(GetY() + fy));
+
+			if (!tree)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Úº Ç¿   Ô´Ï´."));
+				return false;
+			}
+
+			if (tree->IsAttr((long)(GetX() + fx), (long)(GetY() + fy), ATTR_WATER))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ó¿ Úº Ç¿  Ï´."));
+				return false;
+			}
+
+			// [Anti-Grief] Prevent stacking campfires to block NPCs/bridges (limit 1 campfire within ~5m)
+			struct FCampfireNear
+			{
+				long x, y;
+				bool found;
+				FCampfireNear(long _x, long _y) : x(_x), y(_y), found(false) {}
+				void operator()(LPENTITY ent)
+				{
+					if (found || !ent || !ent->IsType(ENTITY_CHARACTER))
+						return;
+
+					LPCHARACTER pkChr = (LPCHARACTER)ent;
+					if (!pkChr || !pkChr->IsNPC())
+						return;
+
+					if (pkChr->GetRaceNum() != fishing::CAMPFIRE_MOB)
+						return;
+
+					int dist = DISTANCE_APPROX(pkChr->GetX() - x, pkChr->GetY() - y);
+					if (dist < 500)
+						found = true;
+				}
+			};
+
+			const long lCampX = (long)(GetX() + fx);
+			const long lCampY = (long)(GetY() + fy);
+			FCampfireNear fCamp(lCampX, lCampY);
+			tree->ForEachAround(fCamp);
+
+			if (fCamp.found)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot place another campfire so close to an existing one."));
+				return false;
+			}
+
+			LPCHARACTER campfire = CHARACTER_MANAGER::instance().SpawnMob(fishing::CAMPFIRE_MOB, GetMapIndex(), (long)(GetX() + fx), (long)(GetY() + fy), 0, false, number(0, 359));
+
+			char_event_info* info = AllocEventInfo<char_event_info>();
+
+			info->ch = campfire;
+
+			campfire->m_pkMiningEvent = event_create(kill_campfire_event, info, PASSES_PER_SEC(40));
+
+			item->SetCount(item->GetCount() - 1);
+		}
+		break;
+
+		case ITEM_UNIQUE:
+		{
+			switch (item->GetSubType())
+			{
+				case USE_ABILITY_UP:
+				{
+					if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+						return false;
+					}
+
+					switch (item->GetValue(0))
+					{
+						case APPLY_MOV_SPEED:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MOV_SPEED,
+								item->GetValue(2), AFF_MOV_SPEED_POTION, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_ATT_SPEED:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATT_SPEED,
+								item->GetValue(2), AFF_ATT_SPEED_POTION, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_STR:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ST,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_DEX:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_DX,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_CON:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_HT,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_INT:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_IQ,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_CAST_SPEED:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_CASTING_SPEED,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_RESIST_MAGIC:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_MAGIC,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_ATT_GRADE_BONUS:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATT_GRADE_BONUS,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+
+						case APPLY_DEF_GRADE_BONUS:
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_DEF_GRADE_BONUS,
+								item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+							break;
+					}
+
+					if (GetDungeon())
+						GetDungeon()->UsePotion(this);
+
+					if (GetWarMap())
+						GetWarMap()->UsePotion(this, item);
+
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case UNIQUE_BUNDLE:
+				{
+					if (IsRiding())
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this bundle whilst riding."));
+						return false;
+					}
+
+					if (GetWear(ARMOR_BODY))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("      Ö½Ï´."));
+						return false;
+					}
+
+					switch (item->GetVnum())
+					{
+						case 71049: // Üº
+						{
+							if (LC_IsYMIR() == true || LC_IsKorea() == true)
+							{
+								if (IS_BOTARYABLE_ZONE(GetMapIndex()) == true)
+								{
+									UseSilkBotary();
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("     Ô´Ï´"));
+								}
+							}
+							else
+							{
+								UseSilkBotary();
+							}
+						}
+						break;
+
+#if defined(__MYSHOP_DECO__)
+						case ITEM_KASHMIR_BUNDLE:
+							ChatPacket(CHAT_TYPE_COMMAND, "OpenMyShopDecoWnd");
+							break;
+#endif
+					}
+				}
+				break;
+
+				default:
+				{
+					if (!item->IsEquipped())
+						EquipItem(item);
+					else
+						UnequipItem(item);
+				}
+				break;
+			}
+		}
+		break;
+
+		case ITEM_COSTUME:
+		case ITEM_WEAPON:
+		case ITEM_ARMOR:
+		case ITEM_ROD:
+		case ITEM_RING: // Å±  
+		case ITEM_BELT: // Å± Æ® 
+		case ITEM_PICK: // MINING
+		{
+			if (!item->IsEquipped())
+				EquipItem(item);
+			else
+				UnequipItem(item);
+		}
+		break;
+
+		//   È¥   .
+		//  Å¬, È¥ Ï¿ item use Å¶   .
+		// È¥  item move Å¶ Ñ´.
+		//  È¥ Ñ´.
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case ITEM_DS:
+		{
+			if (!item->IsEquipped())
+				return false;
+
+			return DSManager::instance().PullOut(this, NPOS, item);
+		}
+
+		case ITEM_SPECIAL_DS:
+		{
+			if (!item->IsEquipped())
+				EquipItem(item);
+			else
+				UnequipItem(item);
+		}
+		break;
+#endif
+
+		case ITEM_FISH:
+		{
+			if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß¿ Ì¿   Ç°Ô´Ï´."));
+				return false;
+			}
+
+			if (item->GetSubType() == FISH_ALIVE)
+				fishing::UseFish(this, item);
+		}
+		break;
+
+		case ITEM_TREASURE_BOX:
+		{
+			return false;
+			//ChatPacket(CHAT_TYPE_TALKING, LC_STRING("  Ö¾î¼­  Ê´Â° . è¸¦ Øº."));
+		}
+		break;
+
+		case ITEM_TREASURE_KEY:
+		{
+			LPITEM item2;
+
+			if (!GetItem(DestCell) || !(item2 = GetItem(DestCell)))
+				return false;
+
+			if (item2->IsExchanging())
+				return false;
+
+			if (item2->GetType() != ITEM_TREASURE_BOX)
+			{
+				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("   Æ´Ñ° ."));
+				return false;
+			}
+
+			if (item->GetValue(0) == item2->GetValue(0))
+			{
+				//ChatPacket(CHAT_TYPE_TALKING, LC_STRING("   Ö´ Îº  ÈµÇ¾Ï´."));
+
+				if (GiveItemFromSpecialItemGroup(item2->GetVnum()))
+				{
+					item->SetCount(item->GetCount() - 1);
+					item2->SetCount(item2->GetCount() - 1);
+				}
+				else
+				{
+					ChatPacket(CHAT_TYPE_TALKING, LC_STRING("è°¡  Ê´  ."));
+					return false;
+				}
+			}
+			else
+			{
+				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("è°¡  Ê´  ."));
+				return false;
+			}
+		}
+		break;
+
+		case ITEM_GIFTBOX:
+		{
+			DWORD dwBoxVnum = item->GetVnum();
+
+			if (dwBoxVnum == 50033 && LC_IsYMIR()) // Ë¼ 
+			{
+				if (GetLevel() < 15)
+				{
+					ChatPacket(CHAT_TYPE_INFO, "15 Ï¿   Ï´.");
+					return false;
+				}
+			}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			if ((dwBoxVnum > 51500 && dwBoxVnum < 52000) || (dwBoxVnum >= 50255 && dwBoxVnum <= 50260)) // È¥
+			{
+				if (!(this->DragonSoul_IsQualified()))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¥ Æ® Ï·Ï¼Å¾ Õ´Ï´."));
+					return false;
+				}
+			}
+#endif
+
+			if (!GiveItemFromSpecialItemGroup(dwBoxVnum))
+			{
+				ChatPacket(CHAT_TYPE_TALKING, LC_STRING("Æ¹Íµ   Ï´."));
+				return false;
+			}
+
+			item->SetCount(item->GetCount() - 1);
+		}
+		break;
+
+		case ITEM_SKILLFORGET:
+		{
+			if (!item->GetSocket(0))
+			{
+				ITEM_MANAGER::instance().RemoveItem(item);
+				return false;
+			}
+
+			DWORD dwVnum = item->GetSocket(0);
+
+			if (SkillLevelDown(dwVnum))
+			{
+				ITEM_MANAGER::instance().RemoveItem(item);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Å³  Âµ Ï¿Ï´."));
+			}
+			else
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Å³    Ï´."));
+		}
+		break;
+
+		case ITEM_SKILLBOOK:
+		{
+			if (IsPolymorphed())
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("ß¿ Ã¥  Ï´."));
+				return false;
+			}
+
+			DWORD dwVnum = 0;
+
+			if (item->GetVnum() == ITEM_SKILLBOOK_VNUM)
+			{
+				dwVnum = item->GetSocket(0);
+			}
+			else
+			{
+				// Î¿ Ã¼ value 0  Å³ È£ Ç· ×° .
+				dwVnum = item->GetValue(0);
+			}
+
+			if (0 == dwVnum)
+			{
+				ITEM_MANAGER::instance().RemoveItem(item);
+				return false;
+			}
+
+			if (true == LearnSkillByBook(dwVnum))
+			{
+				item->SetCount(item->GetCount() - 1);
+
+				int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+
+				if (distribution_test_server)
+					iReadDelay /= 3;
+
+				// Ñ±  ì¿¡ Ã° 24Ã° 
+				if (LC_IsKorea())
+					iReadDelay = 86400;
+
+				SetSkillNextReadTime(dwVnum, get_global_time() + iReadDelay);
+			}
+		}
+		break;
+
+		case ITEM_USE:
+		{
+			if (item->GetVnum() > 50800 && item->GetVnum() <= 50820)
+			{
+				if (test_server)
+					sys_log(0, "ADD addtional effect : vnum(%d) subtype(%d)", item->GetOriginalVnum(), item->GetSubType());
+
+				int affect_type = AFFECT_EXP_BONUS_EURO_FREE;
+				int apply_type = aApplyInfo[item->GetValue(0)].wPointType;
+				int apply_value = item->GetValue(2);
+				int apply_duration = item->GetValue(1);
+
+				switch (item->GetSubType())
+				{
+					case USE_ABILITY_UP:
+					{
+						if (FindAffect(affect_type, apply_type))
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+							return false;
+						}
+
+						if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+							return false;
+						}
+
+						switch (item->GetValue(0))
+						{
+							case APPLY_MOV_SPEED:
+							{
+								AddAffect(affect_type, apply_type, apply_value, AFF_MOV_SPEED_POTION, apply_duration, 0, true, true);
+								break;
+							}
+
+							case APPLY_ATT_SPEED:
+							{
+								AddAffect(affect_type, apply_type, apply_value, AFF_ATT_SPEED_POTION, apply_duration, 0, true, true);
+								break;
+							}
+
+							case APPLY_STR:
+							case APPLY_DEX:
+							case APPLY_CON:
+							case APPLY_INT:
+							case APPLY_CAST_SPEED:
+							case APPLY_CRITICAL_PCT:
+							case APPLY_PENETRATE_PCT:
+							case APPLY_RESIST_MAGIC:
+							case APPLY_ATT_GRADE_BONUS:
+							case APPLY_DEF_GRADE_BONUS:
+#if defined(__CONQUEROR_LEVEL__)
+							case APPLY_SUNGMA_STR:
+							case APPLY_SUNGMA_HP:
+							case APPLY_SUNGMA_MOVE:
+							case APPLY_SUNGMA_IMMUNE:
+#endif
+							{
+								AddAffect(affect_type, apply_type, apply_value, 0, apply_duration, 0, true, true);
+								break;
+							}
+
+						}
+
+						if (GetDungeon())
+							GetDungeon()->UsePotion(this);
+
+						if (GetWarMap())
+							GetWarMap()->UsePotion(this, item);
+
+						item->SetCount(item->GetCount() - 1);
+					}
+					break;
+
+					case USE_AFFECT:
+					{
+						if (FindAffect(AFFECT_EXP_BONUS_EURO_FREE, aApplyInfo[item->GetValue(1)].wPointType))
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+						}
+						else
+						{
+							AddAffect(AFFECT_EXP_BONUS_EURO_FREE, aApplyInfo[item->GetValue(1)].wPointType, item->GetValue(2), 0, item->GetValue(3), 0, false, true);
+							item->SetCount(item->GetCount() - 1);
+						}
+					}
+					break;
+
+					case USE_POTION_NODELAY:
+					{
+						if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+						{
+							if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("å¿¡ Ï½  Ï´."));
+								return false;
+							}
+
+							switch (item->GetVnum())
+							{
+								case 70020: // Peach Flower Wine
+								case 71018: // Blessing of Life
+								case 71019: // Blessing of Magic
+								case 71020: // Blessing of the Dragon
+								{
+									if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
+									{
+										if (m_nPotionLimit <= 0)
+										{
+											ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ñ· Ê°Ï¿Ï´."));
+											return false;
+										}
+									}
+								}
+								break;
+
+								default:
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("å¿¡ Ï½  Ï´."));
+									return false;
+								}
+							}
+						}
+
+						bool bUsed = false;
+
+						if (item->GetValue(0) != 0) // HP ë°ª È¸
+						{
+							if (GetHP() < GetMaxHP())
+							{
+								PointChange(POINT_HP, item->GetValue(0) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
+								EffectPacket(SE_HPUP_RED);
+								bUsed = true;
+							}
+						}
+
+						if (item->GetValue(1) != 0) // SP ë°ª È¸
+						{
+							if (GetSP() < GetMaxSP())
+							{
+								PointChange(POINT_SP, item->GetValue(1) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
+								EffectPacket(SE_SPUP_BLUE);
+								bUsed = true;
+							}
+						}
+
+						if (item->GetValue(3) != 0) // HP % È¸
+						{
+							if (GetHP() < GetMaxHP())
+							{
+								PointChange(POINT_HP, item->GetValue(3) * GetMaxHP() / 100);
+								EffectPacket(SE_HPUP_RED);
+								bUsed = true;
+							}
+						}
+
+						if (item->GetValue(4) != 0) // SP % È¸
+						{
+							if (GetSP() < GetMaxSP())
+							{
+								PointChange(POINT_SP, item->GetValue(4) * GetMaxSP() / 100);
+								EffectPacket(SE_SPUP_BLUE);
+								bUsed = true;
+							}
+						}
+
+						if (bUsed)
+						{
+							if (item->GetVnum() == 50085 || item->GetVnum() == 50086)
+							{
+								if (test_server)
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ç´   Ï¿Ï´"));
+
+								SetUseSeedOrMoonBottleTime();
+							}
+
+							if (GetDungeon())
+								GetDungeon()->UsePotion(this);
+
+							if (GetWarMap())
+								GetWarMap()->UsePotion(this, item);
+
+							m_nPotionLimit--;
+
+							// RESTRICT_USE_SEED_OR_MOONBOTTLE
+							item->SetCount(item->GetCount() - 1);
+							// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
+						}
+					}
+					break;
+				}
+
+				return true;
+			}
+
+			if (item->GetVnum() >= 27863 && item->GetVnum() <= 27883)
+			{
+				if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß¿ Ì¿   Ç°Ô´Ï´."));
+					return false;
+				}
+			}
+
+			if (test_server)
+			{
+				sys_log(0, "USE_ITEM %s Type %d SubType %d vnum %d", item->GetName(), item->GetType(), item->GetSubType(), item->GetOriginalVnum());
+			}
+
+			switch (item->GetSubType())
+			{
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				case USE_ELEMENT_UPGRADE:
+				case USE_ELEMENT_DOWNGRADE:
+				case USE_ELEMENT_CHANGE:
+					RefineElementInformation(item, DestCell);
+					break;
+#endif
+
+#if defined(__EXPRESSING_EMOTIONS__)
+				case USE_EMOTION_PACK:
+				{
+					AddEmote();
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+#endif
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+				case USE_TIME_CHARGE_PER:
+				{
+					LPITEM pDestItem = GetItem(DestCell);
+					if (NULL == pDestItem)
+						return false;
+
+					// ì¼± È¥ Ø¼ Ïµ Ñ´.
+					if (pDestItem->IsDragonSoul())
+					{
+						int ret;
+						char buf[128];
+						if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
+						{
+							ret = pDestItem->GiveMoreTime_Per((float)item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
+						}
+						else
+						{
+							ret = pDestItem->GiveMoreTime_Per((float)item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+						}
+
+						if (ret > 0)
+						{
+#if defined(__DS_SET__)
+							DragonSoul_SetBonus();
+#endif
+
+							if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
+							{
+								snprintf(buf, sizeof(buf), "Inc %ds by item{VN:%d SOC%d:%d}", ret, item->GetVnum(), ITEM_SOCKET_CHARGING_AMOUNT_IDX, item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
+							}
+							else
+							{
+								snprintf(buf, sizeof(buf), "Inc %ds by item{VN:%d VAL%d:%d}", ret, item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+							}
+
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d Å­ Ç¾Ï´.", ret));
+							item->SetCount(item->GetCount() - 1);
+							LogManager::instance().ItemLog(this, item, "DS_CHARGING_SUCCESS", buf);
+
+							return true;
+						}
+						else
+						{
+							if (item->GetVnum() == ITEM_DRAGON_HEART_VNUM)
+							{
+								snprintf(buf, sizeof(buf), "No change by item{VN:%d SOC%d:%d}", item->GetVnum(), ITEM_SOCKET_CHARGING_AMOUNT_IDX, item->GetSocket(ITEM_SOCKET_CHARGING_AMOUNT_IDX));
+							}
+							else
+							{
+								snprintf(buf, sizeof(buf), "No change by item{VN:%d VAL%d:%d}", item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+							}
+
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ï´."));
+							LogManager::instance().ItemLog(this, item, "DS_CHARGING_FAILED", buf);
+							return false;
+						}
+					}
+					else
+						return false;
+				}
+				break;
+
+				case USE_TIME_CHARGE_FIX:
+				{
+					LPITEM pDestItem = GetItem(DestCell);
+					if (NULL == pDestItem)
+						return false;
+
+					// ì¼± È¥ Ø¼ Ïµ Ñ´.
+					if (pDestItem->IsDragonSoul())
+					{
+						int ret = pDestItem->GiveMoreTime_Fix(item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+						char buf[128];
+						if (ret)
+						{
+#if defined(__DS_SET__)
+							DragonSoul_SetBonus();
+#endif
+
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d Å­ Ç¾Ï´.", ret));
+
+							snprintf(buf, sizeof(buf), "Increase %ds by item{VN:%d VAL%d:%d}", ret, item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+							LogManager::instance().ItemLog(this, item, "DS_CHARGING_SUCCESS", buf);
+							item->SetCount(item->GetCount() - 1);
+
+							return true;
+						}
+						else
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ï´."));
+							snprintf(buf, sizeof(buf), "No change by item{VN:%d VAL%d:%d}", item->GetVnum(), ITEM_VALUE_CHARGING_AMOUNT_IDX, item->GetValue(ITEM_VALUE_CHARGING_AMOUNT_IDX));
+							LogManager::instance().ItemLog(this, item, "DS_CHARGING_FAILED", buf);
+							return false;
+						}
+					}
+					else
+						return false;
+				}
+				break;
+#endif
+
+				case USE_SPECIAL:
+				{
+					switch (item->GetVnum())
+					{
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+						case ITEM_GUILD_DRAGONLAIR_POTION:
+						{
+							if (GetGuildDragonLair() == NULL)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
+								return false;
+							}
+
+							if (FindAffect(AFFECT_RED_DRAGONLAIR_BUFF))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+								return false;
+							}
+							else
+							{
+								const long duration = item->GetValue(1);
+
+								AddAffect(AFFECT_RED_DRAGONLAIR_BUFF, POINT_SKILL_DEFEND_BONUS, 15, AFF_NONE, duration, 0, true, true);
+								AddAffect(AFFECT_RED_DRAGONLAIR_BUFF, POINT_NORMAL_HIT_DEFEND_BONUS, 15, AFF_NONE, duration, 0, true, true);
+
+								item->SetCount(item->GetCount() - 1);
+							}
+						}
+						break;
+#endif
+
+#if defined(__ELEMENTAL_DUNGEON__)
+						case ITEM_PRIMAL_FORCE_MEDAL:
+						{
+							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
+								return false;
+							}
+
+							CAffect* pAffect = FindAffect(AFFECT_PROTECTION_OF_ELEMENTAL);
+							if (pAffect)
+							{
+								// NOTE : Check if adding another 600 seconds (10 minutes) would exceed 3600 seconds (60 minutes).
+								const long lDuration = pAffect->lDuration;
+								if (lDuration + 600 > 3600)
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that any more."));
+									return false;
+								}
+
+								AddAffect(AFFECT_PROTECTION_OF_ELEMENTAL, APPLY_NONE, 0, AFF_NONE, lDuration + 600, 0, true);
+							}
+							else
+								AddAffect(AFFECT_PROTECTION_OF_ELEMENTAL, APPLY_NONE, 0, AFF_NONE, 600, 0, true);
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_ELEMENTAL_DEFENSE_POTION:
+						{
+							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
+								return false;
+							}
+
+							const long duration = item->GetValue(1);
+							static const std::unordered_map<POINT_TYPE, POINT_VALUE> map_affect = {
+								{ APPLY_MELEE_MAGIC_ATTBONUS_PER, 5 },
+								{ APPLY_RESIST_FIRE, 10 },
+								{ APPLY_RESIST_ELEC, 10 },
+								{ APPLY_RESIST_ICE, 10 },
+								{ APPLY_RESIST_EARTH, 10 },
+								{ APPLY_RESIST_DARK, 10 },
+							};
+							for (const auto& it : map_affect)
+								AddAffect(AFFECT_POTION_OF_ELEMENTAL, it.first, it.second, AFF_NONE, duration, 0, true, true);
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_PRIMAL_FORCE_RING:
+						case ITEM_PRIMAL_FORCE_RING_MALL:
+						{
+							if (IS_ELEMENTAL_DUNGEON(GetMapIndex()) == false)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use that here."));
+								return false;
+							}
+
+							if (number(0, 100) < item->GetValue(0))
+							{
+								PIXEL_POSITION WarpPos;
+								if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(MAP_ELEMENTAL_04, GetEmpire(), WarpPos))
+									WarpSet(WarpPos.x, WarpPos.y);
+								else
+									sys_err("CHARACTER::UseItem : cannot find spawn position (name %s, %d x %d)", GetName(), GetX(), GetY());
+							}
+							else
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Teleportation to the Plateau of Primal Forces has failed."));
+							
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+#if defined(__MINI_GAME_RUMI__) && defined(__OKEY_EVENT_FLAG_RENEWAL__)
+						case ITEM_VNUM_RUMI_CARD_PIECE:
+						{
+							if (CMiniGameRumi::UpdateQuestFlag(this))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_VNUM_RUMI_CARD_PACK:
+						{
+							const WORD wCardCount = GetQuestFlag("minigame_rumi.card_count");
+							if (wCardCount < CMiniGameRumi::RUMI_CARD_COUNT_MAX)
+							{
+								SetQuestFlag("minigame_rumi.card_count", wCardCount + 1);
+								CMiniGameRumi::RequestQuestFlag(this, RUMI_GC_SUBHEADER_SET_CARD_FLAG);
+
+								item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								CMiniGameRumi::RequestQuestFlag(this, RUMI_GC_SUBHEADER_NO_MORE_GAIN);
+							}
+						}
+						break;
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__) && defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+						case ITEM_VNUM_YUT_PIECE:
+						{
+							if (CMiniGameYutnori::UpdateQuestFlag(this))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_VNUM_YUT_BOARD:
+						{
+							const WORD wYutBoardCount = GetQuestFlag("minigame_yutnori.board_count");
+							if (wYutBoardCount < CMiniGameYutnori::YUTNORI_BOARD_COUNT_MAX)
+							{
+								SetQuestFlag("minigame_yutnori.board_count", wYutBoardCount + 1);
+								CMiniGameYutnori::RequestQuestFlag(this, YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG);
+
+								item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								CMiniGameYutnori::RequestQuestFlag(this, YUTNORI_GC_SUBHEADER_NO_MORE_GAIN);
+							}
+						}
+						break;
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__) && defined(__CATCH_KING_EVENT_FLAG_RENEWAL__)
+						case ITEM_VNUM_CATCH_KING_PIECE:
+						{
+							if (CMiniGameCatchKing::UpdateQuestFlag(this))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_VNUM_CATCH_KING_PACK:
+						{
+							const WORD wPackCount = GetQuestFlag("minigame_catchking.pack_count");
+							if (wPackCount < CMiniGameCatchKing::CATCH_KING_PACK_COUNT_MAX)
+							{
+								SetQuestFlag("minigame_catchking.pack_count", wPackCount + 1);
+								CMiniGameCatchKing::RequestQuestFlag(this, CATCHKING_GC_SET_CARD_FLAG);
+
+								item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								CMiniGameCatchKing::RequestQuestFlag(this, CATCHKING_GC_NO_MORE_GAIN);
+							}
+						}
+						break;
+#endif
+
+#if defined(__EASTER_EVENT__)
+						case ITEM_MAGIC_EASTER_EGG:
+						{
+							int nMaxUse = 3;
+							int nNextUseTime = 1800;
+
+							int nUseTime = get_global_time() - item->GetSocket(1);
+							int nUseCount = item->GetSocket(0);
+
+							if (nUseTime >= nNextUseTime)
+							{
+								if (GiveItemFromSpecialItemGroup(ITEM_MAGIC_EASTER_EGG))
+								{
+									item->SetSocket(1, get_global_time());
+									if (nUseCount >= (nMaxUse - 1))
+										item->SetCount(item->GetCount() - 1);
+									else
+										item->SetSocket(0, nUseCount + 1);
+
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Total %d: You can still unpack %d.", nMaxUse, (nMaxUse - 1) - nUseCount));
+								}
+								else
+									ChatPacket(CHAT_TYPE_TALKING, LC_STRING("Æ¹Íµ   Ï´."));
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unpack the next gift in %d minutes.", 31 - nUseTime / 60));
+							}
+						}
+						break;
+#endif
+
+#if defined(__GEM_CONVERTER__)
+						case ITEM_VNUM_GEM_CONVERTER:
+						{
+							LPITEM pTargetItem;
+							if (!IsValidItemPosition(DestCell) || !(pTargetItem = GetItem(DestCell)))
+								return false;
+
+							if (pTargetItem->GetVnum() != ITEM_VNUM_GEM_STONE)
+								return false;
+
+							if (item->IsExchanging() || pTargetItem->IsExchanging())
+								return false;
+
+							if (item->isLocked() || pTargetItem->isLocked())
+								return false;
+
+							int iNeedGemStoneCount = item->GetCount() * item->GetValue(0);
+							int iConvertToGem = iNeedGemStoneCount / item->GetValue(0);
+							int iConvertCost = item->GetCount() * item->GetValue(1);
+
+							if (pTargetItem->GetCount() < iNeedGemStoneCount)
+								return false;
+
+							if (GetGold() < iConvertCost)
+								return false;
+
+							if (GetGem() + iConvertToGem >= GEM_MAX)
+								return false;
+
+							item->SetCount(item->GetCount() - 1);
+							pTargetItem->SetCount(pTargetItem->GetCount() - iNeedGemStoneCount);
+
+							PointChange(POINT_GOLD, -iConvertCost);
+							PointChange(POINT_GEM, iConvertToGem);
+						}
+						break;
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+						case ITEM_VNUM_SNOWFLAKE_STICK:
+						{
+							if (CSnowflakeStickEvent::UseStick(this))
+							{
+								EffectPacket(SE_USE_SNOWFLAKE_STICK);
+								item->SetCount(item->GetCount() - 1);
+							}
+						}
+						break;
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+						case ITEM_ACCE_REVERSAL:
+						case ITEM_ACCE_REVERSAL_MALL:
+						{
+							LPITEM lpTargetItem;
+							if (!IsValidItemPosition(DestCell) || !(lpTargetItem = GetItem(DestCell)))
+								return false;
+
+							if (lpTargetItem->IsExchanging())
+								return false;
+
+							if (lpTargetItem->isLocked())
+								return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (lpTargetItem->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
+								return false;
+							}
+#endif
+
+							if (IsAcceRefineWindowOpen())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item while the windows for absorption and combination are open."));
+								return false;
+							}
+
+							lpTargetItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_ITEM_VNUM, 0);
+							lpTargetItem->ClearAllAttribute();
+							lpTargetItem->UpdatePacket();
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+						case ITEM_CHANGE_LOOK_REVERSAL:
+						case ITEM_CHANGE_LOOK_MOUNT_REVERSAL:
+						{
+							LPITEM item2;
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item2->IsExchanging())
+								return false;
+
+							if (item2->isLocked())
+								return false;
+
+							if (item2->GetTransmutationVnum() == 0)
+								return false;
+
+							if (item->GetVnum() == ITEM_CHANGE_LOOK_MOUNT_REVERSAL && !item2->IsCostumeMount())
+								return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
+								return false;
+							}
+#endif
+
+							item2->SetTransmutationVnum(0);
+							item2->UpdatePacket();
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+						case ITEM_VNUM_AURA_CLEAR:
+						{
+							LPITEM lpTargetItem;
+							if (!IsValidItemPosition(DestCell) || !(lpTargetItem = GetItem(DestCell)))
+								return false;
+
+							if (lpTargetItem->IsExchanging())
+								return false;
+
+							if (lpTargetItem->isLocked())
+								return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (lpTargetItem->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
+								return false;
+							}
+#endif
+
+							if (IsAuraRefineWindowOpen())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item while the windows for absorption and combination are open."));
+								return false;
+							}
+
+							lpTargetItem->SetSocket(ITEM_SOCKET_AURA_DRAIN_ITEM_VNUM, 0);
+							lpTargetItem->ClearAllAttribute();
+							lpTargetItem->UpdatePacket();
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+#if defined(__SET_ITEM__)
+						case ITEM_SET_CLEAR_SCROLL:
+						{
+							LPITEM item2;
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item->IsExchanging() || item2->IsExchanging() || item2->IsEquipped())
+								return false;
+
+							if (item->isLocked() || item2->isLocked())
+								return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
+								return false;
+							}
+#endif
+
+							item2->SetItemSetValue(0);
+							item2->UpdatePacket();
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+						// RESEARCHER_ELIXIR
+						case ITEM_RESEARCHERS_ELIXIR:
+						case ITEM_RESEARCHERS_ELIXIR_GIFT:
+						case ITEM_RESEARCHERS_ELIXIR_MALL:
+						{
+							if (FindAffect(AFFECT_RESEARCHER_ELIXIR))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+							}
+							else
+							{
+								AddAffect(AFFECT_RESEARCHER_ELIXIR, APPLY_NONE, 1, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
+								item->SetCount(item->GetCount() - 1);
+							}
+						}
+						break;
+						// END_RESEARCHER_ELIXIR
+
+#if defined(__SOUL_BIND_SYSTEM__)
+						case ITEM_SCROLL_BINDING:
+						{
+							if (!g_bSoulBind)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot soulbind items on this server."));
+								return false;
+							}
+
+							LPITEM item2;
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item2->IsExchanging())
+								return false;
+
+							if (!item2->CanSealItem())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot bind this item to your soul."));
+								return false;
+							}
+
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("This item is already soulbound."));
+								return false;
+							}
+
+							item2->SealItem();
+
+							char buf[256 + 1];
+							snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
+								item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
+							LogManager::instance().ItemLog(this, item, "SEAL_SCROLL_USE_SUCCESS", buf);
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_SCROLL_UNBINDING:
+#if defined(__UN_SEAL_SCROLL_PLUS__)
+						case ITEM_SCROLL_UNBINDING_MALL:
+#endif
+						{
+							LPITEM item2;
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item2->isLocked() || item2->IsExchanging())
+								return false;
+
+							if (!item2->IsSealed())
+								return false;
+
+							if (item2->GetSealDate() > E_SEAL_DATE_DEFAULT_TIMESTAMP)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("The soulbind on this item is already in the process of being removed."));
+								return false;
+							}
+
+#if defined(__UN_SEAL_SCROLL_PLUS__)
+							if (item->GetVnum() == ITEM_SCROLL_UNBINDING_MALL)
+							{
+								item2->SealItem(E_SEAL_DATE_DEFAULT_TIMESTAMP);
+
+								char buf[256 + 1];
+								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
+									item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
+								LogManager::instance().ItemLog(this, item, "UN_SEAL_SCROLL_PLUS_USE_SUCCESS", buf);
+							}
+							else
+#endif
+							{
+								long lSealDate = time(0);
+
+								if (test_server)
+									lSealDate += 60;
+								else
+									lSealDate += (60 * 60 * SEAL_DATE_MAX);
+
+								item2->SealItem(lSealDate);
+								item2->StartSealDateExpireTimerEvent();
+
+								char buf[256 + 1];
+								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
+									item->GetName(), item->GetID(), item2->GetName(), item2->GetID());
+								LogManager::instance().ItemLog(this, item, "UN_SEAL_SCROLL_USE_SUCCESS", buf);
+							}
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+						// Å© 
+						case ITEM_NOG_POCKET:
+						{
+							/*
+							Ö´É·Ä¡ : item_proto value Ç¹
+								ÌµÓµ value 1
+								Ý· value 2
+								Ä¡ value 3
+								Ó½Ã° value 0 ( )
+							*/
+							if (FindAffect(AFFECT_NOG_ABILITY))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+								return false;
+							}
+							long time = item->GetValue(0);
+							long moveSpeedPer = item->GetValue(1);
+							long attPer = item->GetValue(2);
+							long expPer = item->GetValue(3);
+							AddAffect(AFFECT_NOG_ABILITY, POINT_MOV_SPEED, moveSpeedPer, AFF_MOV_SPEED_POTION, time, 0, true, true);
+							AddAffect(AFFECT_NOG_ABILITY, POINT_MALL_ATTBONUS, attPer, AFF_NONE, time, 0, true, true);
+							AddAffect(AFFECT_NOG_ABILITY, POINT_MALL_EXPBONUS, expPer, AFF_NONE, time, 0, true, true);
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						// ó¸¶´Ü¿ 
+						case ITEM_RAMADAN_CANDY:
+						{
+							/*
+							É·Ä¡ : item_proto value Ç¹
+								ÌµÓµ value 1
+								Ý· value 2
+								Ä¡ value 3
+								Ó½Ã° value 0 ( )
+							*/
+							if (FindAffect(AFFECT_RAMADAN_ABILITY))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+								return false;
+							}
+
+							long time = item->GetValue(0);
+							long moveSpeedPer = item->GetValue(1);
+							long attPer = item->GetValue(2);
+							long expPer = item->GetValue(3);
+							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MOV_SPEED, moveSpeedPer, AFF_MOV_SPEED_POTION, time, 0, true, true);
+							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MALL_ATTBONUS, attPer, AFF_NONE, time, 0, true, true);
+							AddAffect(AFFECT_RAMADAN_ABILITY, POINT_MALL_EXPBONUS, expPer, AFF_NONE, time, 0, true, true);
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_MARRIAGE_RING:
+						{
+							marriage::TMarriage* pMarriage = marriage::CManager::instance().Get(GetPlayerID());
+							if (pMarriage)
+							{
+								if (pMarriage->ch1 != NULL)
+								{
+									if (CArenaManager::instance().IsArenaMap(pMarriage->ch1->GetMapIndex()))
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß¿ Ì¿   Ç°Ô´Ï´."));
+										break;
+									}
+								}
+
+								if (pMarriage->ch2 != NULL)
+								{
+									if (CArenaManager::instance().IsArenaMap(pMarriage->ch2->GetMapIndex()))
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß¿ Ì¿   Ç°Ô´Ï´."));
+										break;
+									}
+								}
+
+								LPCHARACTER pkOther = NULL;
+								if (pMarriage->m_pid1 == GetPlayerID())
+									pkOther = pMarriage->ch2;
+								else if (pMarriage->m_pid2 == GetPlayerID())
+									pkOther = pMarriage->ch1;
+
+								if (pkOther)
+								{
+									const long lOtherMapIndex = pkOther->GetMapIndex();
+
+									// [Security] Prevent wedding-ring dungeon/war/event/GM-map taxi
+									if (pkOther->GetDungeon() != NULL)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot teleport to your partner inside a dungeon."));
+										break;
+									}
+
+									if (CWarMapManager::instance().IsWarMap(lOtherMapIndex))
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot teleport to your partner on a war map."));
+										break;
+									}
+
+									if (!IS_SUMMONABLE_ZONE(lOtherMapIndex))
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot teleport to your partner in this area."));
+										break;
+									}
+
+									if (!IsGM() && pkOther->GetGMLevel() > GM_PLAYER)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot teleport to your partner in this area."));
+										break;
+									}
+								}
+
+								int consumeSP = CalculateConsumeSP(this);
+
+								if (consumeSP < 0)
+									return false;
+
+								PointChange(POINT_SP, -consumeSP, false);
+
+								WarpToPID(pMarriage->GetOther(GetPlayerID()));
+							}
+							else
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("È¥ Â° Æ´Ï¸ È¥   Ï´."));
+						}
+						break;
+
+						case ITEM_WHITE_FLAG:
+							ForgetMyAttacker();
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case 30093:
+						case 30094:
+						case 30095:
+						case 30096:
+							// Ö¸Ó´
+						{
+							const int MAX_BAG_INFO = 26;
+							static struct LuckyBagInfo
+							{
+								DWORD count;
+								int prob;
+								DWORD vnum;
+							} b1[MAX_BAG_INFO] =
+							{
+								{ 1000, 302, 1 },
+								{ 10, 150, 27002 },
+								{ 10, 75, 27003 },
+								{ 10, 100, 27005 },
+								{ 10, 50, 27006 },
+								{ 10, 80, 27001 },
+								{ 10, 50, 27002 },
+								{ 10, 80, 27004 },
+								{ 10, 50, 27005 },
+								{ 1, 10, ITEM_SKILLBOOK_VNUM },
+								{ 1, 6, 92 },
+								{ 1, 2, 132 },
+								{ 1, 6, 1052 },
+								{ 1, 2, 1092 },
+								{ 1, 6, 2082 },
+								{ 1, 2, 2122 },
+								{ 1, 6, 3082 },
+								{ 1, 2, 3122 },
+								{ 1, 6, 5052 },
+								{ 1, 2, 5082 },
+								{ 1, 6, 7082 },
+								{ 1, 2, 7122 },
+								{ 1, 1, 11282 },
+								{ 1, 1, 11482 },
+								{ 1, 1, 11682 },
+								{ 1, 1, 11882 },
+							};
+
+							struct LuckyBagInfo b2[MAX_BAG_INFO] =
+							{
+								{ 1000, 302, 1 },
+								{ 10, 150, 27002 },
+								{ 10, 75, 27002 },
+								{ 10, 100, 27005 },
+								{ 10, 50, 27005 },
+								{ 10, 80, 27001 },
+								{ 10, 50, 27002 },
+								{ 10, 80, 27004 },
+								{ 10, 50, 27005 },
+								{ 1, 10, ITEM_SKILLBOOK_VNUM },
+								{ 1, 6, 92 },
+								{ 1, 2, 132 },
+								{ 1, 6, 1052 },
+								{ 1, 2, 1092 },
+								{ 1, 6, 2082 },
+								{ 1, 2, 2122 },
+								{ 1, 6, 3082 },
+								{ 1, 2, 3122 },
+								{ 1, 6, 5052 },
+								{ 1, 2, 5082 },
+								{ 1, 6, 7082 },
+								{ 1, 2, 7122 },
+								{ 1, 1, 11282 },
+								{ 1, 1, 11482 },
+								{ 1, 1, 11682 },
+								{ 1, 1, 11882 },
+							};
+
+							LuckyBagInfo* bi = NULL;
+							if (LC_IsHongKong())
+								bi = b2;
+							else
+								bi = b1;
+
+							int pct = number(1, 1000);
+
+							int i;
+							for (i = 0; i < MAX_BAG_INFO; i++)
+							{
+								if (pct <= bi[i].prob)
+									break;
+								pct -= bi[i].prob;
+							}
+							if (i >= MAX_BAG_INFO)
+								return false;
+
+							if (bi[i].vnum == ITEM_SKILLBOOK_VNUM)
+							{
+								// Å³Ã¼ Æ¯Ï° Ø´.
+								GiveRandomSkillBook();
+							}
+							else if (bi[i].vnum == 1)
+							{
+								PointChange(POINT_GOLD, 1000, true);
+							}
+							else
+							{
+								AutoGiveItem(bi[i].vnum, bi[i].count);
+							}
+							ITEM_MANAGER::instance().RemoveItem(item);
+						}
+						break;
+
+						case 50004: // ÌºÆ® 
+						{
+							if (item->GetSocket(0))
+							{
+								item->SetSocket(0, item->GetSocket(0) + 1);
+							}
+							else
+							{
+								// Ã³ 
+								int iMapIndex = GetMapIndex();
+
+								PIXEL_POSITION pos;
+
+								if (SECTREE_MANAGER::instance().GetRandomLocation(iMapIndex, pos, 700))
+								{
+									item->SetSocket(0, 1);
+									item->SetSocket(1, pos.x);
+									item->SetSocket(2, pos.y);
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("  ÌºÆ® â°¡  Ê´Â° Ï´."));
+									return false;
+								}
+							}
+
+							int dist = 0;
+							float distance = (DISTANCE_SQRT(GetX() - item->GetSocket(1), GetY() - item->GetSocket(2)));
+
+							if (distance < 1000.0f)
+							{
+								// ß°!
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÌºÆ® â°¡ ÅºÎ¿   Ï´."));
+
+								// È½  Ö´  Ù¸ Ñ´.
+								struct TEventStoneInfo
+								{
+									DWORD dwVnum;
+									int count;
+									int prob;
+								};
+								const int EVENT_STONE_MAX_INFO = 15;
+								TEventStoneInfo info_10[EVENT_STONE_MAX_INFO] =
+								{
+									{ 27001, 10, 8 },
+									{ 27004, 10, 6 },
+									{ 27002, 10, 12 },
+									{ 27005, 10, 12 },
+									{ 27100, 1, 9 },
+									{ 27103, 1, 9 },
+									{ 27101, 1, 10 },
+									{ 27104, 1, 10 },
+									{ 27999, 1, 12 },
+
+									{ 25040, 1, 4 },
+
+									{ 27410, 1, 0 },
+									{ 27600, 1, 0 },
+									{ 25100, 1, 0 },
+
+									{ 50001, 1, 0 },
+									{ 50003, 1, 1 },
+								};
+								TEventStoneInfo info_7[EVENT_STONE_MAX_INFO] =
+								{
+									{ 27001, 10, 1 },
+									{ 27004, 10, 1 },
+									{ 27004, 10, 9 },
+									{ 27005, 10, 9 },
+									{ 27100, 1, 5 },
+									{ 27103, 1, 5 },
+									{ 27101, 1, 10 },
+									{ 27104, 1, 10 },
+									{ 27999, 1, 14 },
+
+									{ 25040, 1, 5 },
+
+									{ 27410, 1, 5 },
+									{ 27600, 1, 5 },
+									{ 25100, 1, 5 },
+
+									{ 50001, 1, 0 },
+									{ 50003, 1, 5 },
+
+								};
+								TEventStoneInfo info_4[EVENT_STONE_MAX_INFO] =
+								{
+									{ 27001, 10, 0 },
+									{ 27004, 10, 0 },
+									{ 27002, 10, 0 },
+									{ 27005, 10, 0 },
+									{ 27100, 1, 0 },
+									{ 27103, 1, 0 },
+									{ 27101, 1, 0 },
+									{ 27104, 1, 0 },
+									{ 27999, 1, 25 },
+
+									{ 25040, 1, 0 },
+
+									{ 27410, 1, 0 },
+									{ 27600, 1, 0 },
+									{ 25100, 1, 15 },
+
+									{ 50001, 1, 10 },
+									{ 50003, 1, 50 },
+
+								};
+
+								{
+									TEventStoneInfo* info;
+									if (item->GetSocket(0) <= 4)
+										info = info_4;
+									else if (item->GetSocket(0) <= 7)
+										info = info_7;
+									else
+										info = info_10;
+
+									int prob = number(1, 100);
+
+									for (int i = 0; i < EVENT_STONE_MAX_INFO; ++i)
+									{
+										if (!info[i].prob)
+											continue;
+
+										if (prob <= info[i].prob)
+										{
+											if (info[i].dwVnum == 50001)
+											{
+												DWORD* pdw = M2_NEW DWORD[2];
+
+												pdw[0] = info[i].dwVnum;
+												pdw[1] = info[i].count;
+
+												// Ã·  Ñ´
+												DBManager::instance().ReturnQuery(QID_LOTTO, GetPlayerID(), pdw,
+													"INSERT INTO lotto_list VALUES(0, 'server%s', %u, NOW())",
+													get_table_postfix(), GetPlayerID());
+											}
+											else
+												AutoGiveItem(info[i].dwVnum, info[i].count);
+
+											break;
+										}
+										prob -= info[i].prob;
+									}
+								}
+
+								char chatbuf[CHAT_MAX_LEN + 1];
+								int len = snprintf(chatbuf, sizeof(chatbuf), "StoneDetect %u 0 0", (DWORD)GetVID());
+
+								if (len < 0 || len >= (int)sizeof(chatbuf))
+									len = sizeof(chatbuf) - 1;
+
+								++len; // \0 Ú± 
+
+								TPacketGCChat pack_chat;
+								pack_chat.header = HEADER_GC_CHAT;
+								pack_chat.size = sizeof(TPacketGCChat) + len;
+								pack_chat.type = CHAT_TYPE_COMMAND;
+								pack_chat.id = 0;
+								pack_chat.bEmpire = GetDesc()->GetEmpire();
+								//pack_chat.id = vid;
+
+								TEMP_BUFFER buf;
+								buf.write(&pack_chat, sizeof(TPacketGCChat));
+								buf.write(chatbuf, len);
+
+								PacketAround(buf.read_peek(), buf.size());
+
+								ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (DETECT_EVENT_STONE) 1");
+								return true;
+							}
+							else if (distance < 20000)
+								dist = 1;
+							else if (distance < 70000)
+								dist = 2;
+							else
+								dist = 3;
+
+							//   .
+							const int STONE_DETECT_MAX_TRY = 10;
+							if (item->GetSocket(0) >= STONE_DETECT_MAX_TRY)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÌºÆ® â°¡   Ï´."));
+								ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (DETECT_EVENT_STONE) 0");
+								AutoGiveItem(27002);
+								return true;
+							}
+
+							if (dist)
+							{
+								char chatbuf[CHAT_MAX_LEN + 1];
+								int len = snprintf(chatbuf, sizeof(chatbuf),
+									"StoneDetect %u %d %d",
+									(DWORD)GetVID(), dist, (int)GetDegreeFromPositionXY(GetX(), item->GetSocket(2), item->GetSocket(1), GetY()));
+
+								if (len < 0 || len >= (int)sizeof(chatbuf))
+									len = sizeof(chatbuf) - 1;
+
+								++len; // \0 Ú± 
+
+								TPacketGCChat pack_chat;
+								pack_chat.header = HEADER_GC_CHAT;
+								pack_chat.size = sizeof(TPacketGCChat) + len;
+								pack_chat.type = CHAT_TYPE_COMMAND;
+								pack_chat.id = 0;
+								pack_chat.bEmpire = GetDesc()->GetEmpire();
+								//pack_chat.id = vid;
+
+								TEMP_BUFFER buf;
+								buf.write(&pack_chat, sizeof(TPacketGCChat));
+								buf.write(chatbuf, len);
+
+								PacketAround(buf.read_peek(), buf.size());
+							}
+						}
+						break;
+
+						case 27989: // 
+						case 76006: //  
+						{
+							LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(GetMapIndex());
+
+							if (pMap != NULL)
+							{
+								item->SetSocket(0, item->GetSocket(0) + 1);
+
+								FFindStone f;
+
+								// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
+								pMap->for_each(f);
+
+								if (f.m_mapStone.size() > 0)
+								{
+									std::map<DWORD, LPCHARACTER>::iterator stone = f.m_mapStone.begin();
+
+									DWORD max = UINT_MAX;
+									LPCHARACTER pTarget = stone->second;
+
+									while (stone != f.m_mapStone.end())
+									{
+										DWORD dist = (DWORD)DISTANCE_SQRT(GetX() - stone->second->GetX(), GetY() - stone->second->GetY());
+
+										if (dist != 0 && max > dist)
+										{
+											max = dist;
+											pTarget = stone->second;
+										}
+										stone++;
+									}
+
+									if (pTarget != NULL)
+									{
+										int val = 3;
+
+										if (max < 10000) val = 2;
+										else if (max < 70000) val = 1;
+
+										ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u %d %d", (DWORD)GetVID(), val,
+											(int)GetDegreeFromPositionXY(GetX(), pTarget->GetY(), pTarget->GetX(), GetY()));
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("â¸¦ Û¿Ï¿ Ç´  Ï´."));
+									}
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("â¸¦ Û¿Ï¿ Ç´  Ï´."));
+								}
+
+								if (item->GetSocket(0) >= 6)
+								{
+									ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u 0 0", (DWORD)GetVID());
+									ITEM_MANAGER::instance().RemoveItem(item);
+								}
+							}
+							break;
+						}
+						break;
+
+#if defined(__MT_THUNDER_DUNGEON__)
+						case 79602:
+						{
+							if (GetMapIndex() != CMTThunderDungeon::MAP_INDEX)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("This action is not possible on this map."));
+								return false;
+							}
+
+							LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(GetMapIndex());
+
+							if (pMap != NULL)
+							{
+								item->SetSocket(0, item->GetSocket(0) + 1);
+
+								FFindMobVnum f(6405);
+
+								// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
+								pMap->for_each(f);
+
+								if (f.m_mapVID.size() > 0)
+								{
+									std::map<DWORD, LPCHARACTER>::iterator it = f.m_mapVID.begin();
+
+									DWORD max = UINT_MAX;
+									LPCHARACTER pTarget = it->second;
+
+									while (it != f.m_mapVID.end())
+									{
+										DWORD dist = (DWORD)DISTANCE_SQRT(GetX() - it->second->GetX(), GetY() - it->second->GetY());
+
+										if (dist != 0 && max > dist)
+										{
+											max = dist;
+											pTarget = it->second;
+										}
+										it++;
+									}
+
+									if (pTarget != NULL)
+									{
+										int val = 3;
+
+										if (max < 10000) val = 2;
+										else if (max < 70000) val = 1;
+
+										ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u %d %d", (DWORD)GetVID(), val,
+											(int)GetDegreeFromPositionXY(GetX(), pTarget->GetY(), pTarget->GetX(), GetY()));
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Compass was used, but the Guard wasnt found."));
+									}
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("The Compass was used, but the Guard wasnt found."));
+								}
+
+								if (item->GetSocket(0) >= 6)
+								{
+									ChatPacket(CHAT_TYPE_COMMAND, "StoneDetect %u 0 0", (DWORD)GetVID());
+									ITEM_MANAGER::instance().RemoveItem(item);
+								}
+							}
+						}
+						break;
+#endif
+
+						case 27996: // 
+							item->SetCount(item->GetCount() - 1);
+							/*
+							if (GetSkillLevel(SKILL_CREATE_POISON))
+								AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE, 3, AFF_DRINK_POISON, 15 * 60, 0, true);
+							else
+							{
+								// Ù·â°¡  50%  50% Ý· +2
+								if (number(0, 1))
+								{
+									if (GetHP() > 100)
+										PointChange(POINT_HP, -(GetHP() - 1));
+									else
+										Dead();
+								}
+								else
+									AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE, 2, AFF_DRINK_POISON, 15 * 60, 0, true);
+							}
+							*/
+							break;
+
+						case fishing::SHELLFISH_VNUM: // 
+							// 50  47990
+							// 30 
+							// 10  47992
+							// 7 Ã» 47993
+							// 3  47994
+						{
+							item->SetCount(item->GetCount() - 1);
+
+							int r = number(1, 100);
+
+							if (r <= 50)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ô½Ï´."));
+								AutoGiveItem(fishing::STONEPIECE_VNUM);
+							}
+							else
+							{
+								const int prob_table_euckr[] =
+								{
+									80, 90, 97
+								};
+
+								const int prob_table_gb2312[] =
+								{
+									95, 97, 99
+								};
+
+								const int* prob_table = !g_iUseLocale ? prob_table_euckr : prob_table_gb2312;
+
+								if (r <= prob_table[0])
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Ï´."));
+								}
+								else if (r <= prob_table[1])
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ö° Ô½Ï´."));
+									AutoGiveItem(fishing::WHITE_PEARL_VNUM);
+								}
+								else if (r <= prob_table[2])
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ã»Ö° Ô½Ï´."));
+									AutoGiveItem(fishing::BLUE_PEARL_VNUM);
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ö° Ô½Ï´."));
+									AutoGiveItem(fishing::RED_PEARL_VNUM);
+								}
+							}
+						}
+						break;
+
+						case 71013: // 
+							CreateFly(number(FLY_FIREWORK1, FLY_FIREWORK6), this);
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case 50100: // 
+						case 50101:
+						case 50102:
+						case 50103:
+						case 50104:
+						case 50105:
+						case 50106:
+							CreateFly(item->GetVnum() - 50100 + FLY_FIREWORK1, this);
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case 50200: // 
+						{
+							if (LC_IsYMIR() == true || LC_IsKorea() == true)
+							{
+								if (IS_BOTARYABLE_ZONE(GetMapIndex()) == true)
+								{
+									__OpenPrivateShop();
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("     Ô´Ï´"));
+								}
+							}
+							else
+							{
+								__OpenPrivateShop();
+							}
+						}
+						break;
+
+						case fishing::FISH_MIND_PILL_VNUM:
+							AddAffect(AFFECT_FISH_MIND_PILL, POINT_NONE, 0, AFF_FISH_MIND, 20 * 60, 0, true);
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case 50301: // Ö· Ã¼
+						case 50302:
+						case 50303:
+						{
+							if (IsPolymorphed() == true)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ð° ß¿ É· Ã¸  Ï´."));
+								return false;
+							}
+
+							int lv = GetSkillLevel(SKILL_LEADERSHIP);
+
+							if (lv < item->GetValue(0))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ã¥ Ê¹  Ï±â°¡ Ï´."));
+								return false;
+							}
+
+							if (lv >= item->GetValue(1))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ã¥ Æ¹      Ê½Ï´."));
+								return false;
+							}
+
+							if (LearnSkillByBook(SKILL_LEADERSHIP))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(SKILL_LEADERSHIP, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+
+						case 50304: //  Ã¼
+						case 50305:
+						case 50306:
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ß¿ Ã¥  Ï´."));
+								return false;
+							}
+
+							if (GetSkillLevel(SKILL_COMBO) == 0 && GetLevel() < 30)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 30 Ç±       Ê½Ï´."));
+								return false;
+							}
+
+							if (GetSkillLevel(SKILL_COMBO) == 1 && GetLevel() < 50)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" 50 Ç±       Ê½Ï´."));
+								return false;
+							}
+
+							if (GetSkillLevel(SKILL_COMBO) >= 2)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ì»   Ï´."));
+								return false;
+							}
+
+							int iPct = item->GetValue(0);
+
+							if (LearnSkillByBook(SKILL_COMBO, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(SKILL_COMBO, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+
+						case 50311: //  Ã¼
+						case 50312:
+						case 50313:
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ß¿ Ã¥  Ï´."));
+								return false;
+							}
+
+							DWORD dwSkillVnum = item->GetValue(0);
+							int iPct = MINMAX(0, item->GetValue(1), 100);
+							if (GetSkillLevel(dwSkillVnum) >= 20 || dwSkillVnum - SKILL_LANGUAGE1 + 1 == GetEmpire())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ ÏºÏ° Ë¾Æµ  Ö´ Ì´."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+
+						case 50061: // Ïº  È¯ Å³ Ã¼
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ß¿ Ã¥  Ï´."));
+								return false;
+							}
+
+							DWORD dwSkillVnum = item->GetValue(0);
+							int iPct = MINMAX(0, item->GetValue(1), 100);
+
+							if (GetSkillLevel(dwSkillVnum) >= 10)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ì»   Ï´."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+
+						// LEARNABLE_SKILL_BOOKS_BY_LEVEL
+						case 50314: case 50315: case 50316: //  Ã¼
+						case 50325: // Book of Precision
+						{
+							if (IsPolymorphed() == true)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ð° ß¿ É· Ã¸  Ï´."));
+								return false;
+							}
+
+							int iSkillLevelLowLimit = item->GetValue(0);
+							int iSkillLevelHighLimit = item->GetValue(1);
+							int iPct = MINMAX(0, item->GetValue(2), 100);
+							int iLevelLimit = item->GetValue(3);
+							DWORD dwSkillVnum = 0;
+
+							switch (item->GetVnum())
+							{
+								case 50314: case 50315: case 50316:
+									dwSkillVnum = SKILL_POLYMORPH;
+									break;
+
+#if defined(__CONQUEROR_LEVEL__)
+								case 50325: // Book of Precision
+									dwSkillVnum = SKILL_HIT;
+									break;
+#endif
+
+								default:
+									return false;
+							}
+
+							if (0 == dwSkillVnum)
+								return false;
+
+#if defined(__CONQUEROR_LEVEL__)
+							if (dwSkillVnum == SKILL_HIT && GetConquerorLevel() < iSkillLevelLowLimit)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ã¥    Ã· Õ´Ï´."));
+								return false;
+							}
+							else
+#endif
+							{
+								if (GetLevel() < iLevelLimit)
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ã¥    Ã· Õ´Ï´."));
+									return false;
+								}
+							}
+
+							if (GetSkillLevel(dwSkillVnum) >= 40)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ì»   Ï´."));
+								return false;
+							}
+
+							if (GetSkillLevel(dwSkillVnum) < iSkillLevelLowLimit
+#if defined(__CONQUEROR_LEVEL__)
+								&& dwSkillVnum != SKILL_HIT
+#endif
+								)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ã¥ Ê¹  Ï±â°¡ Ï´."));
+								return false;
+							}
+
+							if (GetSkillLevel(dwSkillVnum) >= iSkillLevelHighLimit)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ã¥Î´  Ì»   Ï´."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+						// END_LEARNABLE_SKILL_BOOKS_BY_LEVEL
+
+						// LEARNABLE_SKILL_BOOKS_BY_EXP
+#if defined(__PARTY_PROFICY__)
+						case 50338:	// Charisma of a Rookie
+						case 50339:	// Charisma of an Adept
+						case 50340:	// Charisma of an Expert
+#endif
+#if defined(__PARTY_INSIGHT__)
+						case 50341:	// Inspiration of a Rookie
+						case 50342:	// Inspiration of an Adept
+						case 50343:	// Inspiration of an Expert
+#endif
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ð° ß¿ É· Ã¸  Ï´."));
+								return false;
+							}
+
+							int iSkillLevelLowLimit = item->GetValue(0);
+							int iSkillLevelHighLimit = item->GetValue(1);
+							int iPct = MINMAX(0, item->GetValue(2), 100);
+							int iNeedExp = item->GetValue(3);
+							DWORD dwSkillVnum = 0;
+
+							switch (item->GetVnum())
+							{
+#if defined(__PARTY_PROFICY__)
+								case 50338:	// Charisma of a Rookie
+								case 50339:	// Charisma of an Adept
+								case 50340:	// Charisma of an Expert
+									dwSkillVnum = SKILL_ROLE_PROFICIENCY;
+									break;
+#endif
+
+#if defined(__PARTY_INSIGHT__)
+								case 50341:	// Inspiration of a Rookie
+								case 50342:	// Inspiration of an Adept
+								case 50343:	// Inspiration of an Expert
+									dwSkillVnum = SKILL_INSIGHT;
+									break;
+#endif
+
+								default:
+									return false;
+							}
+
+							if (0 == dwSkillVnum)
+								return false;
+
+							if (GetExp() < static_cast<DWORD>(iNeedExp))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ä¡ Ï¿ Ã¥   Ï´."));
+								return false;
+							}
+
+							if (GetSkillLevel(dwSkillVnum) >= 40)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Å³Ô´Ï´."));
+								return false;
+							}
+
+							if (GetSkillLevel(dwSkillVnum) < iSkillLevelLowLimit)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ã¥ Ê¹  Ï±â°¡ Ï´."));
+								return false;
+							}
+
+							if (GetSkillLevel(dwSkillVnum) >= iSkillLevelHighLimit)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ã¥Î´  Ì»   Ï´."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								if (dwSkillVnum != SKILL_HIT)
+									PointChange(POINT_EXP, -iNeedExp);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server)
+									iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+						// END_LEARNABLE_SKILL_BOOKS_BY_EXP
+
+						case 50902:
+						case 50903:
+						case 50904:
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ß¿ Ã¥  Ï´."));
+								return false;
+							}
+
+							DWORD dwSkillVnum = SKILL_CREATE;
+							int iPct = MINMAX(0, item->GetValue(1), 100);
+
+							if (GetSkillLevel(dwSkillVnum) >= 40)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ì»   Ï´."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+
+								if (test_server)
+								{
+									ChatPacket(CHAT_TYPE_INFO, "[TEST_SERVER] Success to learn skill ");
+								}
+							}
+							else
+							{
+								if (test_server)
+								{
+									ChatPacket(CHAT_TYPE_INFO, "[TEST_SERVER] Failed to learn skill ");
+								}
+							}
+						}
+						break;
+
+						// MINING
+						case ITEM_MINING_SKILL_TRAIN_BOOK:
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ß¿ Ã¥  Ï´."));
+								return false;
+							}
+
+							DWORD dwSkillVnum = SKILL_MINING;
+							int iPct = MINMAX(0, item->GetValue(1), 100);
+
+							if (GetSkillLevel(dwSkillVnum) >= 40)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ì»   Ï´."));
+								return false;
+							}
+
+							if (LearnSkillByBook(dwSkillVnum, iPct))
+							{
+								item->SetCount(item->GetCount() - 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+						}
+						break;
+						// END_OF_MINING
+
+						case ITEM_HORSE_SKILL_TRAIN_BOOK:
+						{
+							if (IsPolymorphed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("ß¿ Ã¥  Ï´."));
+								return false;
+							}
+
+							DWORD dwSkillVnum = SKILL_HORSE;
+							int iPct = MINMAX(0, item->GetValue(1), 100);
+
+							if (GetLevel() < 50)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Â¸ Å³   Ö´  Æ´Õ´Ï´."));
+								return false;
+							}
+
+							if (!test_server && get_global_time() < GetSkillNextReadTime(dwSkillVnum))
+							{
+								if (FindAffect(AFFECT_SKILL_NO_BOOK_DELAY))
+								{
+									// Ö¾È¼ ß¿ Ã°  
+									RemoveAffect(AFFECT_SKILL_NO_BOOK_DELAY);
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ö¾È¼  È­Ô¸ Ô½Ï´."));
+								}
+								else
+								{
+									SkillLearnWaitMoreTimeMessage(GetSkillNextReadTime(dwSkillVnum) - get_global_time());
+									return false;
+								}
+							}
+
+							if (GetPoint(POINT_HORSE_SKILL) >= 20 ||
+								GetSkillLevel(SKILL_HORSE_WILDATTACK) + GetSkillLevel(SKILL_HORSE_CHARGE) + GetSkillLevel(SKILL_HORSE_ESCAPE) >= 60 ||
+								GetSkillLevel(SKILL_HORSE_WILDATTACK_RANGE) + GetSkillLevel(SKILL_HORSE_CHARGE) + GetSkillLevel(SKILL_HORSE_ESCAPE) >= 60)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ì» Â¸ Ã¼   Ï´."));
+								return false;
+							}
+
+							if (number(1, 100) <= iPct)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Â¸ Ã¼ Ð¾ Â¸ Å³ Æ® Ï´."));
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Æ®Î´ Â¸ Å³  Ã¸  Ö½Ï´."));
+								PointChange(POINT_HORSE_SKILL, 1);
+
+								int iReadDelay = number(SKILLBOOK_DELAY_MIN, SKILLBOOK_DELAY_MAX);
+								if (distribution_test_server) iReadDelay /= 3;
+
+								if (!test_server)
+									SetSkillNextReadTime(dwSkillVnum, get_global_time() + iReadDelay);
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Â¸ Ã¼ Ø¿ Ï¿Ï´."));
+							}
+
+							ITEM_MANAGER::instance().RemoveItem(item);
+						}
+						break;
+
+						case 70102: // 
+						case 70103: // 
+						{
+							if (GetAlignment() >= 0)
+								return false;
+
+							int delta = MIN(-GetAlignment(), item->GetValue(0));
+
+							sys_log(0, "%s ALIGNMENT ITEM %d", GetName(), delta);
+
+							UpdateAlignment(delta);
+							item->SetCount(item->GetCount() - 1);
+
+							if (delta / 10 > 0)
+							{
+								ChatPacket(CHAT_TYPE_TALKING, LC_STRING(" Â±.   ð°¡°   Ì¾."));
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ä¡ %d Ï¿Ï´.", delta / 10));
+							}
+						}
+						break;
+
+						case 71107: // Ãµ
+						case 39032:
+						{
+							quest::CQuestManager& q = quest::CQuestManager::Instance();
+							quest::PC* pPC = q.GetPC(GetPlayerID());
+							if (pPC)
+							{
+								int val = item->GetValue(0);
+								int interval = item->GetValue(1);
+								int last_use_time = pPC->GetFlag("mythical_peach.last_use_time");
+								if (get_global_time() - last_use_time < interval * 60 * 60)
+								{
+									if (test_server == false)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Ï´."));
+										return false;
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("×½Æ®  Ã° "));
+									}
+								}
+
+								if (GetAlignment() == 200000)
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ä¡  Ì» Ã¸  Ï´."));
+									return false;
+								}
+
+								if (200000 - GetAlignment() < val * 10)
+								{
+									val = (200000 - GetAlignment()) / 10;
+								}
+
+								int old_alignment = GetAlignment() / 10;
+
+								UpdateAlignment(val * 10);
+
+								item->SetCount(item->GetCount() - 1);
+								pPC->SetFlag("mythical_peach.last_use_time", get_global_time());
+
+								ChatPacket(CHAT_TYPE_TALKING, LC_STRING(" Â±.   ð°¡°   Ì¾."));
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ä¡ %d Ï¿Ï´.", val));
+
+								char buf[256 + 1];
+								snprintf(buf, sizeof(buf), "%d %d", old_alignment, GetAlignment() / 10);
+								LogManager::instance().CharLog(this, val, "MYTHICAL_PEACH", buf);
+							}
+						}
+						break;
+
+						case 71109: // Å»
+						case 39033:
+						{
+							LPITEM item2;
+
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item2->IsExchanging() || item2->IsEquipped())
+								return false;
+
+							if (item2->GetSocketCount() == 0)
+								return false;
+
+							switch (item2->GetType())
+							{
+								case ITEM_WEAPON:
+									break;
+
+								case ITEM_ARMOR:
+									switch (item2->GetSubType())
+									{
+										case ARMOR_EAR:
+										case ARMOR_WRIST:
+										case ARMOR_NECK:
+											ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ï´"));
+											return false;
+									}
+									break;
+
+								default:
+									return false;
+							}
+
+							std::stack<long> socket;
+
+							for (int i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+							{
+#if defined(__GLOVE_SYSTEM__)
+								DWORD dwSocketData = item2->GetSocket(i);
+								if (item2->IsGlove() && dwSocketData >= 1000000 && dwSocketData != ITEM_BROKEN_METIN_VNUM)
+								{
+									DWORD dwBaseIndex = 28046;
+									dwBaseIndex += (((dwSocketData / 1000) % 10) * 100);
+									dwBaseIndex += ((dwSocketData / 100) % 10) - 1;
+
+									const TItemTable* pItemData = ITEM_MANAGER::instance().GetTable(dwBaseIndex);
+									if (pItemData == nullptr)
+										continue;
+
+									dwSocketData = dwBaseIndex;
+								}
+								socket.push(dwSocketData);
+#else
+								socket.push(item2->GetSocket(i));
+#endif
+							}
+
+							int idx = METIN_SOCKET_MAX_NUM - 1;
+
+							while (socket.size() > 0)
+							{
+								if (socket.top() > 2 && socket.top() != ITEM_BROKEN_METIN_VNUM)
+									break;
+
+								idx--;
+								socket.pop();
+							}
+
+							if (socket.size() == 0)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ï´"));
+								return false;
+							}
+
+							LPITEM pItemReward = AutoGiveItem(socket.top());
+							if (pItemReward != NULL)
+							{
+								item2->SetSocket(idx, 1);
+
+								char buf[256 + 1];
+								snprintf(buf, sizeof(buf), "%s(%u) %s(%u)",
+									item2->GetName(), item2->GetID(), pItemReward->GetName(), pItemReward->GetID());
+								LogManager::instance().ItemLog(this, item, "USE_DETACHMENT_ONE", buf);
+
+								item->SetCount(item->GetCount() - 1);
+							}
+						}
+						break;
+
+						case 70201: // Å»
+						case 70202: // ()
+						case 70203: // (Ý»)
+						case 70204: // ()
+						case 70205: // ()
+						case 70206: // ()
+						{
+							// NEW_HAIR_STYLE_ADD
+							if (GetPart(PART_HAIR) >= 1001)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" î½ºÅ¸Ï¿  Å» Ò°Õ´Ï´."));
+							}
+							// END_NEW_HAIR_STYLE_ADD
+							else
+							{
+								quest::CQuestManager& q = quest::CQuestManager::instance();
+								quest::PC* pPC = q.GetPC(GetPlayerID());
+								if (pPC)
+								{
+									int last_dye_level = pPC->GetFlag("dyeing_hair.last_dye_level");
+
+									if (last_dye_level == 0 ||
+										last_dye_level + 3 <= GetLevel() ||
+										item->GetVnum() == 70201)
+									{
+										SetPart(PART_HAIR, item->GetVnum() - 70201);
+
+										if (item->GetVnum() == 70201)
+											pPC->SetFlag("dyeing_hair.last_dye_level", 0);
+										else
+											pPC->SetFlag("dyeing_hair.last_dye_level", GetLevel());
+
+										item->SetCount(item->GetCount() - 1);
+										UpdatePacket();
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d  Ç¾ Ù½ Ï½  Ö½Ï´.", last_dye_level + 3));
+									}
+								}
+							}
+						}
+						break;
+
+						case ITEM_NEW_YEAR_GREETING_VNUM:
+						{
+							if (GiveItemFromSpecialItemGroup(ITEM_NEW_YEAR_GREETING_VNUM))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_VALENTINE_ROSE:
+						case ITEM_VALENTINE_CHOCOLATE:
+						{
+							if (item->GetVnum() == ITEM_VALENTINE_ROSE && SEX_MALE == GET_SEX(this) ||
+								item->GetVnum() == ITEM_VALENTINE_CHOCOLATE && SEX_FEMALE == GET_SEX(this))
+							{
+								//  Ê¾   .
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ê¾     Ï´."));
+								return false;
+							}
+
+							if (GiveItemFromSpecialItemGroup(item->GetVnum()))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_WHITEDAY_CANDY:
+						case ITEM_WHITEDAY_ROSE:
+						{
+							if (item->GetVnum() == ITEM_WHITEDAY_CANDY && SEX_MALE == GET_SEX(this) ||
+								item->GetVnum() == ITEM_WHITEDAY_ROSE && SEX_FEMALE == GET_SEX(this))
+							{
+								//  Ê¾   .
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ê¾     Ï´."));
+								return false;
+							}
+
+							if (GiveItemFromSpecialItemGroup(item->GetVnum()))
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case 50011: // 
+						{
+							if (!GiveItemFromSpecialItemGroup(50011))
+							{
+								ChatPacket(CHAT_TYPE_TALKING, LC_STRING("Æ¹Íµ   Ï´."));
+								return false;
+							}
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_GIVE_STAT_RESET_COUNT_VNUM:
+						{
+							//PointChange(POINT_GOLD, -iCost);
+							PointChange(POINT_STAT_RESET_COUNT, 1);
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case 50107:
+						{
+							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß¿ Ì¿   Ç°Ô´Ï´."));
+								return false;
+							}
+
+							EffectPacket(SE_CHINA_FIREWORK);
+							//   Ã·Ø´
+							AddAffect(AFFECT_CHINA_FIREWORK, POINT_STUN_PCT, 30, AFF_CHINA_FIREWORK, 5 * 60, 0, true);
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case 50108:
+						{
+							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß¿ Ì¿   Ç°Ô´Ï´."));
+								return false;
+							}
+
+							EffectPacket(SE_SPIN_TOP);
+							//   Ã·Ø´
+							AddAffect(AFFECT_CHINA_FIREWORK, POINT_STUN_PCT, 30, AFF_CHINA_FIREWORK, 5 * 60, 0, true);
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case ITEM_WONSO_BEAN_VNUM:
+							PointChange(POINT_HP, GetMaxHP() - GetHP());
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case ITEM_WONSO_SUGAR_VNUM:
+							PointChange(POINT_SP, GetMaxSP() - GetSP());
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case ITEM_WONSO_FRUIT_VNUM:
+							PointChange(POINT_STAMINA, GetMaxStamina() - GetStamina());
+							item->SetCount(item->GetCount() - 1);
+							break;
+
+						case ITEM_ELK_VNUM: // Ù·
+						{
+							int iGold = item->GetSocket(0);
+							ITEM_MANAGER::instance().RemoveItem(item);
+							PointChange(POINT_GOLD, iGold);
+						}
+						break;
+
+						//  Ç¥
+						case 70021:
+						{
+							int HealPrice = quest::CQuestManager::instance().GetEventFlag("MonarchHealGold");
+							if (HealPrice == 0)
+								HealPrice = 2000000;
+
+							if (CMonarch::instance().HealMyEmpire(this, HealPrice))
+							{
+								char szNotice[256];
+								snprintf(szNotice, sizeof(szNotice), LC_STRING(" àº¹  %s  HP,SP  Ã¤Ï´.", EMPIRE_NAME(GetEmpire())));
+								SendNoticeMap(szNotice, GetMapIndex(), false);
+
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" àº¹ Ï¿Ï´."));
+							}
+						}
+						break;
+
+						case 27995:
+						{
+						}
+						break;
+
+						case 71092: //  Ã¼ Ó½
+						{
+							if (m_pkChrTarget != NULL)
+							{
+								if (m_pkChrTarget->IsPolymorphed())
+								{
+									m_pkChrTarget->SetPolymorph(0);
+									m_pkChrTarget->RemoveAffect(AFFECT_POLYMORPH);
+								}
+							}
+							else
+							{
+								if (IsPolymorphed())
+								{
+									SetPolymorph(0);
+									RemoveAffect(AFFECT_POLYMORPH);
+								}
+							}
+						}
+						break;
+
+						case 71051: // ç°¡
+						{
+							LPITEM item2;
+
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetInventoryItem(wDestCell)))
+								return false;
+
+							if (item2->IsExchanging())
+								return false;
+
+							if (item2->IsEquipped())
+								return false;
+
+							if (item2->GetType() == ITEM_COSTUME)
+								return false;
+
+							//if (item2->GetAttributeCount() < 5)
+							//	return false;
+
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼    Ô´Ï´."));
+								return false;
+							}
+
+							if (item2->AddRareAttribute() == true)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ ß° Ï¿Ï´."));
+
+								int iAddedIdx = item2->GetRareAttrCount() + 4;
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+
+								LogManager::instance().ItemLog(
+									GetPlayerID(),
+									item2->GetAttributeType(iAddedIdx),
+									item2->GetAttributeValue(iAddedIdx),
+									item->GetID(),
+									"ADD_RARE_ATTR",
+									buf,
+									GetDesc()->GetHostName(),
+									item->GetOriginalVnum());
+
+								if (!g_bUnlimitedAddRareAttributes)
+									item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ ß° Ï¿Ï´."));
+							}
+						}
+						break;
+
+						case 71052: // 
+						{
+							LPITEM item2;
+
+							if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+								return false;
+
+							if (item2->IsEquipped())
+								return false;
+
+							if (item2->GetType() == ITEM_COSTUME)
+								return false;
+
+							if (item2->IsExchanging() == true)
+								return false;
+
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼    Ô´Ï´."));
+								return false;
+							}
+
+							if (item2->ChangeRareAttribute() == true)
+							{
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+								LogManager::instance().ItemLog(this, item, "CHANGE_RARE_ATTR", buf);
+
+								if (!g_bUnlimitedChangeRareAttributes)
+									item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ Ï¿Ï´."));
+							}
+						}
+						break;
+
+						case ITEM_AUTO_HP_RECOVERY_S:
+						case ITEM_AUTO_HP_RECOVERY_M:
+						case ITEM_AUTO_HP_RECOVERY_L:
+						case ITEM_AUTO_HP_RECOVERY_X:
+						case ITEM_AUTO_SP_RECOVERY_S:
+						case ITEM_AUTO_SP_RECOVERY_M:
+						case ITEM_AUTO_SP_RECOVERY_L:
+						case ITEM_AUTO_SP_RECOVERY_X:
+							// Ã¹  Ï´  Ä¡ ...
+							// ×· ×³ Ïµ Úµ.  Ú¿ Úµ Ûµ.
+						case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
+						case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
+						case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
+						case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
+						{
+							if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("å¿¡ Ï½  Ï´."));
+								return false;
+							}
+
+							EAffectTypes type = AFFECT_NONE;
+							bool isSpecialPotion = false;
+
+							switch (item->GetVnum())
+							{
+								case ITEM_AUTO_HP_RECOVERY_X:
+									isSpecialPotion = true;
+
+								case ITEM_AUTO_HP_RECOVERY_S:
+								case ITEM_AUTO_HP_RECOVERY_M:
+								case ITEM_AUTO_HP_RECOVERY_L:
+								case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_XS:
+								case REWARD_BOX_ITEM_AUTO_HP_RECOVERY_S:
+									type = AFFECT_AUTO_HP_RECOVERY;
+									break;
+
+								case ITEM_AUTO_SP_RECOVERY_X:
+									isSpecialPotion = true;
+
+								case ITEM_AUTO_SP_RECOVERY_S:
+								case ITEM_AUTO_SP_RECOVERY_M:
+								case ITEM_AUTO_SP_RECOVERY_L:
+								case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_XS:
+								case REWARD_BOX_ITEM_AUTO_SP_RECOVERY_S:
+									type = AFFECT_AUTO_SP_RECOVERY;
+									break;
+							}
+
+							if (AFFECT_NONE == type)
+								break;
+
+							if (item->GetCount() > 1)
+							{
+								int pos = GetEmptyInventory(item->GetSize());
+
+								if (-1 == pos)
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ç°   Ï´."));
+									break;
+								}
+
+								item->SetCount(item->GetCount() - 1);
+
+								LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), 1);
+								item2->AddToCharacter(this, TItemPos(INVENTORY, pos));
+
+								if (item->GetSocket(1) != 0)
+								{
+									item2->SetSocket(1, item->GetSocket(1));
+								}
+
+								item = item2;
+							}
+
+							CAffect* pAffect = FindAffect(type);
+
+							if (NULL == pAffect)
+							{
+								EPointTypes bonus = POINT_NONE;
+
+								if (true == isSpecialPotion)
+								{
+									if (type == AFFECT_AUTO_HP_RECOVERY)
+									{
+										bonus = POINT_MAX_HP_PCT;
+									}
+									else if (type == AFFECT_AUTO_SP_RECOVERY)
+									{
+										bonus = POINT_MAX_SP_PCT;
+									}
+								}
+
+								AddAffect(type, bonus, 4, item->GetID(), INFINITE_AFFECT_DURATION, 0, true, false);
+
+								item->Lock(true);
+								item->SetSocket(0, true);
+
+								AutoRecoveryItemProcess(type);
+							}
+							else
+							{
+								if (item->GetID() == pAffect->dwFlag)
+								{
+									RemoveAffect(pAffect);
+
+									item->Lock(false);
+									item->SetSocket(0, false);
+								}
+								else
+								{
+									LPITEM old = FindItemByID(pAffect->dwFlag);
+
+									if (NULL != old)
+									{
+										old->Lock(false);
+										old->SetSocket(0, false);
+									}
+
+									RemoveAffect(pAffect);
+
+									EPointTypes bonus = POINT_NONE;
+
+									if (true == isSpecialPotion)
+									{
+										if (type == AFFECT_AUTO_HP_RECOVERY)
+										{
+											bonus = POINT_MAX_HP_PCT;
+										}
+										else if (type == AFFECT_AUTO_SP_RECOVERY)
+										{
+											bonus = POINT_MAX_SP_PCT;
+										}
+									}
+
+									AddAffect(type, bonus, 4, item->GetID(), INFINITE_AFFECT_DURATION, 0, true, false);
+
+									item->Lock(true);
+									item->SetSocket(0, true);
+
+									AutoRecoveryItemProcess(type);
+								}
+							}
+						}
+						break;
+					}
+				}
+				break;
+
+				case USE_CLEAR:
+				{
+					switch (item->GetVnum())
+					{
+						case 27124: // Bandage
+							RemoveBleeding();
+							break;
+
+						case 27874: // Grilled Perch
+							RemoveBadAffect();
+							break;
+					}
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case USE_INVISIBILITY:
+				{
+					if (item->GetVnum() == 70026)
+					{
+						quest::CQuestManager& q = quest::CQuestManager::instance();
+						quest::PC* pPC = q.GetPC(GetPlayerID());
+
+						if (pPC != NULL)
+						{
+							int last_use_time = pPC->GetFlag("mirror_of_disapper.last_use_time");
+
+							if (get_global_time() - last_use_time < 10 * 60)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Ï´."));
+								return false;
+							}
+
+							pPC->SetFlag("mirror_of_disapper.last_use_time", get_global_time());
+						}
+					}
+
+					AddAffect(AFFECT_INVISIBILITY, POINT_NONE, 0, AFF_INVISIBILITY, 300, 0, true);
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case USE_POTION_NODELAY:
+				{
+					if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+					{
+						if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("å¿¡ Ï½  Ï´."));
+							return false;
+						}
+
+						switch (item->GetVnum())
+						{
+							case 70020:
+							case 71018:
+							case 71019:
+							case 71020:
+							{
+								if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
+								{
+									if (m_nPotionLimit <= 0)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ñ· Ê°Ï¿Ï´."));
+										return false;
+									}
+								}
+							}
+							break;
+
+							default:
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("å¿¡ Ï½  Ï´."));
+								return false;
+						}
+					}
+
+					bool bUsed = false;
+
+					if (item->GetValue(0) != 0) // HP ë°ª È¸
+					{
+						if (GetHP() < GetMaxHP())
+						{
+							PointChange(POINT_HP, item->GetValue(0) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
+							EffectPacket(SE_HPUP_RED);
+							bUsed = true;
+						}
+					}
+
+					if (item->GetValue(1) != 0) // SP ë°ª È¸
+					{
+						if (GetSP() < GetMaxSP())
+						{
+							PointChange(POINT_SP, item->GetValue(1) * (100 + GetPoint(POINT_POTION_BONUS)) / 100);
+							EffectPacket(SE_SPUP_BLUE);
+							bUsed = true;
+						}
+					}
+
+					if (item->GetValue(3) != 0) // HP % È¸
+					{
+						if (GetHP() < GetMaxHP())
+						{
+							PointChange(POINT_HP, item->GetValue(3) * GetMaxHP() / 100);
+							EffectPacket(SE_HPUP_RED);
+							bUsed = true;
+						}
+					}
+
+					if (item->GetValue(4) != 0) // SP % È¸
+					{
+						if (GetSP() < GetMaxSP())
+						{
+							PointChange(POINT_SP, item->GetValue(4) * GetMaxSP() / 100);
+							EffectPacket(SE_SPUP_BLUE);
+							bUsed = true;
+						}
+					}
+
+					if (bUsed)
+					{
+						if (item->GetVnum() == 50085 || item->GetVnum() == 50086)
+						{
+							if (test_server)
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ç´   Ï¿Ï´"));
+
+							SetUseSeedOrMoonBottleTime();
+						}
+
+						if (GetDungeon())
+							GetDungeon()->UsePotion(this);
+
+						if (GetWarMap())
+							GetWarMap()->UsePotion(this, item);
+
+						m_nPotionLimit--;
+
+						// RESTRICT_USE_SEED_OR_MOONBOTTLE
+						item->SetCount(item->GetCount() - 1);
+						// END_RESTRICT_USE_SEED_OR_MOONBOTTLE
+					}
+				}
+				break;
+
+				case USE_POTION:
+				{
+					if (CArenaManager::instance().IsArenaMap(GetMapIndex()) == true)
+					{
+						if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit") > 0)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("å¿¡ Ï½  Ï´."));
+							return false;
+						}
+
+						switch (item->GetVnum())
+						{
+							case 27001: // Red Potion (S)
+							case 27002: // Red Potion (M)
+							case 27003: // Red Potion (L)
+							case 27007: // Red Potion (XXL)
+							case 27004: // Blue Potion (S)
+							case 27005: // Blue Potion (M)
+							case 27006: // Blue Potion (L)
+							case 27008: // Red Potion (XXL)
+							{
+								if (quest::CQuestManager::instance().GetEventFlag("arena_potion_limit_count") < 10000)
+								{
+									if (m_nPotionLimit <= 0)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ñ· Ê°Ï¿Ï´."));
+										return false;
+									}
+								}
+							}
+							break;
+
+							default:
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("å¿¡ Ï½  Ï´."));
+								return false;
+						}
+					}
+
+					if (item->GetValue(1) != 0)
+					{
+						if (GetPoint(POINT_SP_RECOVERY) + GetSP() >= GetMaxSP())
+							return false;
+
+						PointChange(POINT_SP_RECOVERY, item->GetValue(1) * MIN(200, (100 + GetPoint(POINT_POTION_BONUS))) / 100);
+						StartAffectEvent();
+						EffectPacket(SE_SPUP_BLUE);
+					}
+
+					if (item->GetValue(0) != 0)
+					{
+						if (GetPoint(POINT_HP_RECOVERY) + GetHP() >= GetMaxHP())
+							return false;
+
+						PointChange(POINT_HP_RECOVERY, item->GetValue(0) * MIN(200, (100 + GetPoint(POINT_POTION_BONUS))) / 100);
+						StartAffectEvent();
+						EffectPacket(SE_HPUP_RED);
+					}
+
+					if (GetDungeon())
+						GetDungeon()->UsePotion(this);
+
+					if (GetWarMap())
+						GetWarMap()->UsePotion(this, item);
+
+					item->SetCount(item->GetCount() - 1);
+					m_nPotionLimit--;
+				}
+				break;
+
+				case USE_POTION_CONTINUE:
+				{
+					if (item->GetValue(0) != 0)
+						AddAffect(AFFECT_HP_RECOVER_CONTINUE, POINT_HP_RECOVER_CONTINUE, item->GetValue(0), 0, item->GetValue(2), 0, true);
+					else if (item->GetValue(1) != 0)
+						AddAffect(AFFECT_SP_RECOVER_CONTINUE, POINT_SP_RECOVER_CONTINUE, item->GetValue(1), 0, item->GetValue(2), 0, true);
+					else
+						return false;
+
+					if (GetDungeon())
+						GetDungeon()->UsePotion(this);
+
+					if (GetWarMap())
+						GetWarMap()->UsePotion(this, item);
+
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case USE_ABILITY_UP:
+				{
+					if (FindAffect(AFFECT_BLEND, item->GetValue(0)))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+						return false;
+					}
+
+					switch (item->GetValue(0))
+					{
+						case APPLY_MOV_SPEED:
+						{
+							VERIFY_POTION(AFFECT_MOV_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_MOV_SPEED, POINT_MOV_SPEED, item->GetValue(2), AFF_MOV_SPEED_POTION, item->GetValue(1), 0, true);
+							EffectPacket(SE_DXUP_PURPLE);
+						}
+						break;
+
+						case APPLY_ATT_SPEED:
+						{
+							VERIFY_POTION(AFFECT_ATT_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_ATT_SPEED, POINT_ATT_SPEED, item->GetValue(2), AFF_ATT_SPEED_POTION, item->GetValue(1), 0, true);
+							EffectPacket(SE_SPEEDUP_GREEN);
+						}
+						break;
+
+						case APPLY_STR:
+						{
+							VERIFY_POTION(AFFECT_STR, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_STR, POINT_ST, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_DEX:
+						{
+							VERIFY_POTION(AFFECT_DEX, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_DEX, POINT_DX, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_CON:
+						{
+							VERIFY_POTION(AFFECT_CON, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_CON, POINT_HT, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_INT:
+						{
+							VERIFY_POTION(AFFECT_INT, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_INT, POINT_IQ, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_CAST_SPEED:
+						{
+							VERIFY_POTION(AFFECT_CAST_SPEED, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_CAST_SPEED, POINT_CASTING_SPEED, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_ATT_GRADE_BONUS:
+						{
+							VERIFY_POTION(AFFECT_ATT_GRADE, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_ATT_GRADE, POINT_ATT_GRADE_BONUS, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_DEF_GRADE_BONUS:
+						{
+							VERIFY_POTION(AFFECT_DEF_GRADE, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_DEF_GRADE, POINT_DEF_GRADE_BONUS, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_RESIST_MAGIC:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_MAGIC, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+#if defined(__CONQUEROR_LEVEL__)
+						case APPLY_SUNGMA_STR:
+						{
+							VERIFY_POTION(AFFECT_SUNGMA_STR, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_SUNGMA_STR, POINT_SUNGMA_STR, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_SUNGMA_HP:
+						{
+							VERIFY_POTION(AFFECT_SUNGMA_HP, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_SUNGMA_HP, POINT_SUNGMA_HP, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_SUNGMA_MOVE:
+						{
+							VERIFY_POTION(AFFECT_SUNGMA_MOVE, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_SUNGMA_MOVE, POINT_SUNGMA_MOVE, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+
+						case APPLY_SUNGMA_IMMUNE:
+						{
+							VERIFY_POTION(AFFECT_SUNGMA_IMMUNE, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_SUNGMA_IMMUNE, POINT_SUNGMA_IMMUNE, item->GetValue(2), 0, item->GetValue(1), 0, true);
+						}
+						break;
+#endif
+
+						case APPLY_ATTBONUS_MONSTER:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_ATTBONUS_MONSTER, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+						case APPLY_MALL_EXPBONUS:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MALL_EXPBONUS, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+						case APPLY_MELEE_MAGIC_ATTBONUS_PER:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_MELEE_MAGIC_ATT_BONUS_PER, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+						case APPLY_RESIST_ICE:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_ICE, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+						case APPLY_RESIST_EARTH:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_EARTH, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+
+						case APPLY_RESIST_DARK:
+						{
+							VERIFY_POTION(AFFECT_UNIQUE_ABILITY, aApplyInfo[item->GetValue(0)].wPointType);
+							AddAffect(AFFECT_UNIQUE_ABILITY, POINT_RESIST_DARK, item->GetValue(2), 0, item->GetValue(1), 0, true, true);
+						}
+						break;
+					}
+
+					if (GetDungeon())
+						GetDungeon()->UsePotion(this);
+
+					if (GetWarMap())
+						GetWarMap()->UsePotion(this, item);
+
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case USE_TALISMAN:
+				{
+					const int TOWN_PORTAL = 1;
+					const int MEMORY_PORTAL = 2;
+
+					// gm_guild_build, oxevent Ê¿ È¯ È¯  Ï° 
+					if (GetMapIndex() == 200 || GetMapIndex() == 113)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ä¡   Ï´."));
+						return false;
+					}
+
+					if (CArenaManager::instance().IsArenaMap(GetMapIndex()))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß¿ Ì¿   Ç°Ô´Ï´."));
+						return false;
+					}
+
+					if (m_pkWarpEvent)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ìµ Øº Ç¾ È¯Î¸ Ò¼ Ï´"));
+						return false;
+					}
+
+					// CONSUME_LIFE_WHEN_USE_WARP_ITEM
+					int consumeLife = CalculateConsume(this);
+
+					if (consumeLife < 0)
+						return false;
+					// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
+
+					if (item->GetValue(0) == TOWN_PORTAL) // È¯
+					{
+						if (item->GetSocket(0) == 0)
+						{
+							if (!GetDungeon())
+								if (!GiveRecallItem(item))
+									return false;
+
+							PIXEL_POSITION posWarp;
+
+							if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(GetMapIndex(), GetEmpire(), posWarp))
+							{
+								// CONSUME_LIFE_WHEN_USE_WARP_ITEM
+								PointChange(POINT_HP, -consumeLife, false);
+								// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
+
+								WarpSet(posWarp.x, posWarp.y);
+							}
+							else
+							{
+								sys_err("CHARACTER::UseItem : cannot find spawn position (name %s, %d x %d)", GetName(), GetX(), GetY());
+							}
+						}
+						else
+						{
+							if (test_server)
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ä¡ "));
+
+							ProcessRecallItem(item);
+						}
+					}
+					else if (item->GetValue(0) == MEMORY_PORTAL) // È¯
+					{
+						if (item->GetSocket(0) == 0)
+						{
+							if (GetDungeon())
+							{
+								const char* c_szConv = (g_iUseLocale ? "" : (under_han(item->GetName()) ? LC_STRING("") : LC_STRING("")));
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¿ %s%s   Ï´.", LC_ITEM(item->GetVnum()), c_szConv));
+								return false;
+							}
+
+							if (!GiveRecallItem(item))
+								return false;
+						}
+						else
+						{
+							// CONSUME_LIFE_WHEN_USE_WARP_ITEM
+							PointChange(POINT_HP, -consumeLife, false);
+							// END_OF_CONSUME_LIFE_WHEN_USE_WARP_ITEM
+
+							ProcessRecallItem(item);
+						}
+					}
+				}
+				break;
+
+				case USE_TUNING:
+				case USE_DETACHMENT:
+				{
+					LPITEM item2;
+
+					if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+						return false;
+
+					if (item2->IsEquipped())
+						return false;
+
+					if (item2->IsExchanging())
+						return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+					if (item2->IsSealed())
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot improve a soulbound item."));
+						return false;
+					}
+#endif
+
+					if (PreventTradeWindow(WND_ALL))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¢,Å·Ã¢  Â¿  Ò¼ Ï´"));
+						return false;
+					}
+
+					RefineItem(item, item2);
+				}
+				break;
+
+				// ACCESSORY_REFINE & ADD/CHANGE_ATTRIBUTES
+				case USE_PUT_INTO_BELT_SOCKET:
+				case USE_PUT_INTO_RING_SOCKET:
+				case USE_PUT_INTO_ACCESSORY_SOCKET:
+				case USE_ADD_ACCESSORY_SOCKET:
+				case USE_CLEAN_SOCKET:
+				case USE_CHANGE_ATTRIBUTE:
+#if defined(__ATTR_6TH_7TH__)
+				case USE_CHANGE_ATTRIBUTE2:
+#endif
+				case USE_ADD_ATTRIBUTE:
+				case USE_ADD_ATTRIBUTE2:
+#if defined(__MOVE_COSTUME_ATTR__)
+				case USE_RESET_COSTUME_ATTR:
+				case USE_CHANGE_COSTUME_ATTR:
+#endif
+#if defined(__CHANGED_ATTR__)
+				case USE_SELECT_ATTRIBUTE:
+#endif
+				{
+					LPITEM item2;
+					if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+						return false;
+
+
+					// [NOTE] Ú½Æ¬ Û¿     Ó¼ Î¿Ïµ, ç°¡  Æ´Þ¶ Ã» Ö¾.
+					//  ANTI_CHANGE_ATTRIBUTE   Flag ß°Ï¿ È¹  Ï° Æ®   Öµ  Ì¾
+					// ×µ Ê¿ Ä¡  Ø´Þ· ×³ â¼­ ... -_-
+					/*
+					if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_CHANGE_ATTRIBUTE) && !item->IsSocketModifyingItem())
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the upgrade of this item."));
+						return false;
+					}
+					*/
+
+					if (ITEM_COSTUME == item2->GetType()
+#if defined(__MOVE_COSTUME_ATTR__)	
+						&& item->GetSubType() != USE_RESET_COSTUME_ATTR && item->GetSubType() != USE_CHANGE_COSTUME_ATTR
+#endif
+#if defined(__CHANGED_ATTR__)
+						&& item->GetSubType() != USE_SELECT_ATTRIBUTE
+#endif
+						)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼    Ô´Ï´."));
+						return false;
+					}
+
+					if (item2->IsExchanging() || item2->IsEquipped())
+						return false;
+
+					switch (item->GetSubType())
+					{
+						case USE_CLEAN_SOCKET:
+						{
+							int i;
+							for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+							{
+								if (item2->GetSocket(i) == ITEM_BROKEN_METIN_VNUM)
+									break;
+							}
+
+							if (i == METIN_SOCKET_MAX_NUM)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã»   Ê½Ï´."));
+								return false;
+							}
+
+							int j = 0;
+
+							for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+							{
+								if (item2->GetSocket(i) != ITEM_BROKEN_METIN_VNUM && item2->GetSocket(i) != 0)
+									item2->SetSocket(j++, item2->GetSocket(i));
+							}
+
+							for (; j < METIN_SOCKET_MAX_NUM; ++j)
+							{
+								if (item2->GetSocket(j) > 0)
+									item2->SetSocket(j, 1);
+							}
+
+							{
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+								LogManager::instance().ItemLog(this, item, "CLEAN_SOCKET", buf);
+							}
+
+							if (!g_bUnlimitedCleanSocket)
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case USE_CHANGE_ATTRIBUTE:
+						{
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
+								return false;
+							}
+#endif
+
+							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_ENCHANT))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Enchant Item cannot be used on this item."));
+								return false;
+							}
+
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼    Ô´Ï´."));
+								return false;
+							}
+
+							if (item2->GetAttributeCount() == 0)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ó¼ Ï´."));
+								return false;
+							}
+
+							if (g_bChangeItemAttrCycle)
+							{
+								if (GM_PLAYER == GetGMLevel() && false == test_server)
+								{
+									//
+									// Event Flag     Ó¼   Ã°   Ã° ê·¶ Ë»Ï°
+									// Ã°  ê·¶Ù¸  Ó¼æ¿¡  Ã°  Ø´.
+									//
+
+									DWORD dwChangeItemAttrCycle = quest::CQuestManager::instance().GetEventFlag(msc_szChangeItemAttrCycleFlag);
+									if (dwChangeItemAttrCycle < msc_dwDefaultChangeItemAttrCycle)
+										dwChangeItemAttrCycle = msc_dwDefaultChangeItemAttrCycle;
+
+									quest::PC* pPC = quest::CQuestManager::instance().GetPC(GetPlayerID());
+
+									if (pPC)
+									{
+										DWORD dwNowMin = get_global_time() / 60;
+
+										DWORD dwLastChangeItemAttrMin = pPC->GetFlag(msc_szLastChangeItemAttrFlag);
+
+										if (dwLastChangeItemAttrMin + dwChangeItemAttrCycle > dwNowMin)
+										{
+											ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ Ù² %d Ì³ Ù½   Ï´.(%d  )",
+												dwChangeItemAttrCycle, dwChangeItemAttrCycle - (dwNowMin - dwLastChangeItemAttrMin)));
+											return false;
+										}
+
+										pPC->SetFlag(msc_szLastChangeItemAttrFlag, dwNowMin);
+									}
+								}
+							}
+
+							if (item->GetVnum() == 76014)
+							{
+								int aiChangeProb[ITEM_ATTRIBUTE_MAX_LEVEL] =
+								{
+									0, 10, 50, 39, 1
+								};
+
+								item2->ChangeAttribute(aiChangeProb);
+							}
+							else
+							{
+								//  Æ¯Ã³
+								//  ç°¡ ß° ÈµÉ°Å¶ Ï¿ Ïµ Úµ.
+								if (item->GetVnum() == 71151 || item->GetVnum() == 76023)
+								{
+									if ((item2->GetType() == ITEM_WEAPON) || (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY))
+									{
+										bool bCanUse = true;
+										for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+										{
+											if (item2->GetLimitType(i) == LIMIT_LEVEL && item2->GetLimitValue(i) > 40)
+											{
+												bCanUse = false;
+												break;
+											}
+										}
+										if (false == bCanUse)
+										{
+											ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ò°Õ´Ï´."));
+											break;
+										}
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ê¿  Õ´Ï´."));
+										break;
+									}
+								}
+								item2->ChangeAttribute();
+							}
+
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ Ï¿Ï´."));
+							{
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+								LogManager::instance().ItemLog(this, item, "CHANGE_ATTRIBUTE", buf);
+							}
+
+							if (!g_bUnlimitedChangeAttributes)
+								item->SetCount(item->GetCount() - 1);
+						}
+						break;
+
+						case USE_ADD_ATTRIBUTE:
+						{
+							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_REINFORCE))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Reinforce Item cannot be used on this item."));
+								return false;
+							}
+
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼    Ô´Ï´."));
+								return false;
+							}
+
+							if (item2->GetAttributeCount() < 4)
+							{
+								// ç°¡ Æ¯Ã³
+								//  ç°¡ ß° ÈµÉ°Å¶ Ï¿ Ïµ Úµ.
+								if (item->GetVnum() == 71152 || item->GetVnum() == 76024)
+								{
+									if ((item2->GetType() == ITEM_WEAPON) || (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY))
+									{
+										bool bCanUse = true;
+										for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+										{
+											if (item2->GetLimitType(i) == LIMIT_LEVEL && item2->GetLimitValue(i) > 40)
+											{
+												bCanUse = false;
+												break;
+											}
+										}
+										if (false == bCanUse)
+										{
+											ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ò°Õ´Ï´."));
+											break;
+										}
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ê¿  Õ´Ï´."));
+										break;
+									}
+								}
+
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+
+								if (number(1, 100) <= aiItemAttributeAddPercent[item2->GetAttributeCount()] || g_bNeverFailAddAttributes == true)
+								{
+									item2->AddAttribute();
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ ß° Ï¿Ï´."));
+
+									int iAddedIdx = item2->GetAttributeCount() - 1;
+									LogManager::instance().ItemLog(
+										GetPlayerID(),
+										item2->GetAttributeType(iAddedIdx),
+										item2->GetAttributeValue(iAddedIdx),
+										item->GetID(),
+										"ADD_ATTRIBUTE_SUCCESS",
+										buf,
+										GetDesc()->GetHostName(),
+										item->GetOriginalVnum()
+									);
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ ß° Ï¿Ï´."));
+									LogManager::instance().ItemLog(this, item, "ADD_ATTRIBUTE_FAIL", buf);
+								}
+
+								if (!g_bUnlimitedAddAttributes)
+									item->SetCount(item->GetCount() - 1);
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì»   Ì¿Ï¿ Ó¼ ß°  Ï´."));
+							}
+						}
+						break;
+
+						case USE_ADD_ATTRIBUTE2:
+						{
+							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_REINFORCE))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Reinforce Item cannot be used on this item."));
+								return false;
+							}
+
+							// àº¹ 
+							// ç°¡ñ¼­¸  Ó¼ 4 ß° Å² Û¿ Ø¼ Ï³ Ó¼  Ù¿Ø´.
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼    Ô´Ï´."));
+								return false;
+							}
+
+							// Ó¼ Ì¹ 4 ß° Ç¾  Ó¼ ß° Ï´.
+							if (item2->GetAttributeCount() == 4)
+							{
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+
+								if (number(1, 100) <= aiItemAttributeAddPercent[item2->GetAttributeCount()] || g_bNeverFailAddAttributes == true)
+								{
+									item2->AddAttribute();
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ ß° Ï¿Ï´."));
+
+									int iAddedIdx = item2->GetAttributeCount() - 1;
+									LogManager::instance().ItemLog(
+										GetPlayerID(),
+										item2->GetAttributeType(iAddedIdx),
+										item2->GetAttributeValue(iAddedIdx),
+										item->GetID(),
+										"ADD_ATTRIBUTE2_SUCCESS",
+										buf,
+										GetDesc()->GetHostName(),
+										item->GetOriginalVnum()
+									);
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ ß° Ï¿Ï´."));
+									LogManager::instance().ItemLog(this, item, "ADD_ATTRIBUTE2_FAIL", buf);
+								}
+
+								if (!g_bUnlimitedAddAttributes)
+									item->SetCount(item->GetCount() - 1);
+							}
+							else if (item2->GetAttributeCount() == 5)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ì»   Ì¿Ï¿ Ó¼ ß°  Ï´."));
+							}
+							else if (item2->GetAttributeCount() < 4)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ç°¡ñ¼­¸ Ì¿Ï¿ Ó¼ ß° Ö¼."));
+							}
+							else
+							{
+								// wtf ?!
+								sys_err("ADD_ATTRIBUTE2 : Item has wrong AttributeCount(%d)", item2->GetAttributeCount());
+							}
+						}
+						break;
+
+#if defined(__ATTR_6TH_7TH__)
+						case USE_CHANGE_ATTRIBUTE2:
+						{
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
+								return false;
+							}
+#endif
+
+							if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_ENCHANT))
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Enchant Item cannot be used on this item."));
+								return false;
+							}
+
+							if (item2->GetAttributeSetIndex() == -1)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼    Ô´Ï´."));
+								return false;
+							}
+
+							if (item2->GetRareAttrCount() == 0)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ó¼ Ï´."));
+								return false;
+							}
+
+							if (number(1, 100) <= item->GetValue(0))
+							{
+								if (item2->ChangeRareAttribute())
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ Ï¿Ï´."));
+									{
+										char szBuff[21];
+										snprintf(szBuff, sizeof(szBuff), "%u", item2->GetID());
+										LogManager::instance().ItemLog(this, item, "CHANGE_ATTRIBUTE2", szBuff);
+									}
+								}
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Upgrade change failed."));
+							}
+
+							item->SetCount(item->GetCount() - 1);
+						}
+						break;
+#endif
+
+						case USE_ADD_ACCESSORY_SOCKET:
+						{
+							char buf[21];
+							snprintf(buf, sizeof(buf), "%u", item2->GetID());
+
+							if (item2->IsAccessoryForSocket())
+							{
+								if (item2->GetAccessorySocketMaxGrade() < ITEM_ACCESSORY_SOCKET_MAX_NUM)
+								{
+									if (number(1, 100) <= 50 || g_bNeverFailAccessorySocket == true)
+									{
+										item2->SetAccessorySocketMaxGrade(item2->GetAccessorySocketMaxGrade() + 1);
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("  ß°Ç¾Ï´."));
+										LogManager::instance().ItemLog(this, item, "ADD_SOCKET_SUCCESS", buf);
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß° Ï¿Ï´."));
+										LogManager::instance().ItemLog(this, item, "ADD_SOCKET_FAIL", buf);
+									}
+
+									if (!g_bUnlimitedAddAccessorySocket)
+										item->SetCount(item->GetCount() - 1);
+								}
+								else
+								{
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ×¼ Ì»  ß°  Ï´."));
+								}
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("   ß°   Ô´Ï´."));
+							}
+						}
+						break;
+
+						case USE_PUT_INTO_BELT_SOCKET:
+						case USE_PUT_INTO_ACCESSORY_SOCKET:
+						{
+							if (item2->IsAccessoryForSocket() && item->CanPutInto(item2))
+							{
+								char buf[21];
+								snprintf(buf, sizeof(buf), "%u", item2->GetID());
+
+								if (item2->GetAccessorySocketGrade() < item2->GetAccessorySocketMaxGrade())
+								{
+									if (number(1, 100) <= aiAccessorySocketPutPct[item2->GetAccessorySocketGrade()] || g_bNeverFailAccessory == true)
+									{
+										item2->SetAccessorySocketGrade(item2->GetAccessorySocketGrade() + 1);
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ï¿Ï´."));
+										LogManager::instance().ItemLog(this, item, "PUT_SOCKET_SUCCESS", buf);
+									}
+									else
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ï¿Ï´."));
+										LogManager::instance().ItemLog(this, item, "PUT_SOCKET_FAIL", buf);
+									}
+
+									if (!g_bUnlimitedAddAccessory)
+										item->SetCount(item->GetCount() - 1);
+								}
+								else
+								{
+									if (item2->GetAccessorySocketMaxGrade() == 0)
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ì¾Æ¸ Ç¼  ß°Ø¾Õ´Ï´."));
+									else if (item2->GetAccessorySocketMaxGrade() < ITEM_ACCESSORY_SOCKET_MAX_NUM)
+									{
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ×¼ Ì»   Ï´."));
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¾Æ¸  ß°Ø¾Õ´Ï´."));
+									}
+									else
+										ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ×¼ Ì»    Ï´."));
+								}
+							}
+							else
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+							}
+						}
+						break;
+
+#if defined(__MOVE_COSTUME_ATTR__)
+						case USE_RESET_COSTUME_ATTR:
+						case USE_CHANGE_COSTUME_ATTR:
+						{
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
+								return false;
+							}
+#endif
+
+							if (!item2->CanChangeCostumeAttr())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼    Ô´Ï´."));
+								return false;
+							}
+
+							// NOTE: Prevent changing costumes without bonus.
+							if (item2->GetAttributeCount() == 0)
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼    Ô´Ï´."));
+								return false;
+							}
+
+							switch (item->GetSubType())
+							{
+								case USE_RESET_COSTUME_ATTR:
+								{
+									item2->ClearAttribute();
+									item2->AlterToMagicItem();
+
+									char buf[21];
+									snprintf(buf, sizeof(buf), "%u", item2->GetID());
+									LogManager::instance().ItemLog(this, item, "RESET_COSTUME_ATTR", buf);
+
+									if (!g_bUnlimitedResetCostumeAttributes)
+										item->SetCount(item->GetCount() - 1);
+
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ Ï¿Ï´."));
+								}
+								break;
+
+								case USE_CHANGE_COSTUME_ATTR:
+								{
+									item2->ChangeAttribute();
+
+									char buf[21];
+									snprintf(buf, sizeof(buf), "%u", item2->GetID());
+									LogManager::instance().ItemLog(this, item, "CHANGE_COSTUME_ATTR", buf);
+
+									if (!g_bUnlimitedChangeCostumeAttributes)
+										item->SetCount(item->GetCount() - 1);
+
+									ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼ Ï¿Ï´."));
+								}
+								break;
+							}
+						}
+						break;
+#endif
+
+#if defined(__CHANGED_ATTR__)
+						case USE_SELECT_ATTRIBUTE:
+						{
+#if defined(__SOUL_BIND_SYSTEM__)
+							if (item2->IsSealed())
+							{
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot change the attributes of a soulbound item."));
+								return false;
+							}
+#endif
+							SelectAttr(item, item2);
+						}
+						break;
+#endif
+					}
+
+					if (item2->IsEquipped())
+					{
+						BuffOnAttr_AddBuffsFromItem(item2);
+					}
+				}
+				break;
+				// END_OF_ACCESSORY_REFINE & END_OF_ADD_ATTRIBUTES & END_OF_CHANGE_ATTRIBUTES
+
+				case USE_CALL:
+					AggregateMonster();
+					if (!g_bUnlimitedCapeOfCourage)
+						item->SetCount(item->GetCount() - 1);
+					break;
+
+				case USE_BAIT:
+				{
+					if (m_pkFishingEvent)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ß¿ Ì³ Æ³  Ï´."));
+						return false;
+					}
+
+					LPITEM weapon = GetWear(WEAR_WEAPON);
+
+					if (!weapon || weapon->GetType() != ITEM_ROD)
+						return false;
+
+					if (weapon->GetSocket(2))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ Ö´ Ì³  %s Ï´.", LC_ITEM(item->GetVnum())));
+					}
+					else
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã´ë¿¡ %s Ì³ Ï´.", LC_ITEM(item->GetVnum())));
+					}
+
+					weapon->SetSocket(2, item->GetValue(0));
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				case USE_MOVE:
+				case USE_TREASURE_BOX:
+				case USE_MONEYBAG:
+					break;
+
+				case USE_AFFECT:
+				{
+#if defined(__FLOWER_EVENT__)
+					if (item->GetValue(0) == AFFECT_FLOWER_EVENT)
+						return CFlowerEvent::UseFlower(this, item);
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+					if (item->GetValue(0) == AFFECT_LATE_SUMMER_EVENT_BUFF)
+					{
+						if (FindAffect(item->GetValue(0)) || FindAffect(AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF))
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("This effect is already activated."));
+							return false;
+						}
+
+						AddAffect(item->GetValue(0), POINT_NONE, 0, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
+						item->SetCount(item->GetCount() - 1);
+						return true;
+					}
+					else if (item->GetValue(0) == AFFECT_LATE_SUMMER_EVENT_PRIMIUM_BUFF)
+					{
+						if (FindAffect(item->GetValue(0)) || FindAffect(AFFECT_LATE_SUMMER_EVENT_BUFF))
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("This effect is already activated."));
+							return false;
+						}
+
+						AddAffect(item->GetValue(0), POINT_NONE, 0, AFF_NONE, INFINITE_AFFECT_DURATION, 0, true);
+						item->SetCount(item->GetCount() - 1);
+						return true;
+					}
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__) && defined(__PREMIUM_LOOT_FILTER__)
+					if (item->GetValue(0) == AFFECT_LOOTING_SYSTEM)
+					{
+						CAffect* pAffect = FindAffect(AFFECT_LOOTING_SYSTEM);
+						long lDuration = item->GetValue(3);
+
+						if (pAffect)
+						{
+							if (lDuration > 0)
+							{
+								if (pAffect->lDuration > LONG_MAX - lDuration)
+								{
+									sys_err("LOOT_FILTER_SYSTEM: Duration overflow, affect duration (%ld), item value3 (%ld)",
+										pAffect->lDuration, lDuration);
+									return false;
+								}
+							}
+							else
+							{
+								sys_err("LOOT_FILTER_SYSTEM: Item duration value3 (%ld) is not positive.", lDuration);
+								return false;
+							}
+
+							pAffect->bUpdate = true;
+							pAffect->lApplyValue += lDuration;
+
+							ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("Loot filter duration extended."));
+						}
+						else
+						{
+#if defined(__AFFECT_RENEWAL__)
+							AddRealTimeAffect(AFFECT_LOOTING_SYSTEM, POINT_NONE, 0, AFF_NONE, lDuration, 0, false, false);
+#else
+							AddAffect(AFFECT_LOOTING_SYSTEM, POINT_NONE, 0, AFF_NONE, lDuration, 0, false, false);
+#endif
+							ChatPacket(CHAT_TYPE_NOTICE, LC_STRING("Loot filter activated."));
+						}
+
+						item->SetCount(item->GetCount() - 1);
+						return true;
+					}
+#endif
+
+					if (FindAffect(item->GetValue(0), aApplyInfo[item->GetValue(1)].wPointType))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+					}
+					else
+					{
+						AddAffect(item->GetValue(0), aApplyInfo[item->GetValue(1)].wPointType, item->GetValue(2), 0, item->GetValue(3), 0, false);
+						item->SetCount(item->GetCount() - 1);
+					}
+				}
+				break;
+
+				case USE_CREATE_STONE:
+				{
+					AutoGiveItem(number(28000, 28012));
+					item->SetCount(item->GetCount() - 1);
+				}
+				break;
+
+				//   Å³  Ã³
+				case USE_RECIPE:
+				{
+					LPITEM pSource1 = FindSpecifyItem(item->GetValue(1));
+					DWORD dwSourceCount1 = item->GetValue(2);
+
+					LPITEM pSource2 = FindSpecifyItem(item->GetValue(3));
+					DWORD dwSourceCount2 = item->GetValue(4);
+
+					if (dwSourceCount1 != 0)
+					{
+						if (pSource1 == NULL)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("   á°¡ Õ´Ï´."));
+							return false;
+						}
+					}
+
+					if (dwSourceCount2 != 0)
+					{
+						if (pSource2 == NULL)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("   á°¡ Õ´Ï´."));
+							return false;
+						}
+					}
+
+					if (pSource1 != NULL)
+					{
+						if (pSource1->GetCount() < dwSourceCount1)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("(%s) Õ´Ï´.", LC_ITEM(pSource1->GetVnum())));
+							return false;
+						}
+
+						pSource1->SetCount(pSource1->GetCount() - dwSourceCount1);
+					}
+
+					if (pSource2 != NULL)
+					{
+						if (pSource2->GetCount() < dwSourceCount2)
+						{
+							ChatPacket(CHAT_TYPE_INFO, LC_STRING("(%s) Õ´Ï´.", LC_ITEM(pSource2->GetVnum())));
+							return false;
+						}
+
+						pSource2->SetCount(pSource2->GetCount() - dwSourceCount2);
+					}
+
+					LPITEM pBottle = FindSpecifyItem(50901);
+
+					if (!pBottle || pBottle->GetCount() < 1)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ú¸Ï´."));
+						return false;
+					}
+
+					pBottle->SetCount(pBottle->GetCount() - 1);
+
+					if (number(1, 100) > item->GetValue(5))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("  ß½Ï´."));
+						return false;
+					}
+
+					AutoGiveItem(item->GetValue(0));
+				}
+				break;
+			}
+		}
+		break;
+
+		case ITEM_METIN:
+		{
+			LPITEM item2;
+
+			if (!IsValidItemPosition(DestCell) || !(item2 = GetItem(DestCell)))
+				return false;
+
+			if (item2->IsExchanging())
+				return false;
+
+			if (item2->IsEquipped())
+				return false;
+
+			if (IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_APPLY))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("This Spirit Stone cannot be attached to this type of item."));
+				return false;
+			}
+
+			if (item2->GetType() == ITEM_PICK)
+				return false;
+
+			if (item2->GetType() == ITEM_ROD)
+				return false;
+
+			int i;
+
+			for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+			{
+				DWORD dwVnum;
+
+				if ((dwVnum = item2->GetSocket(i)) <= 2)
+					continue;
+
+				const TItemTable* p = ITEM_MANAGER::instance().GetTable(dwVnum);
+
+				if (!p)
+					continue;
+
+				if (item->GetValue(5) == p->alValues[5]
+#if defined(__GLOVE_SYSTEM__)
+					&& item->GetSubType() != METIN_SUNGMA
+#endif
+					)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Æ¾    Ï´."));
+					return false;
+				}
+			}
+
+			if (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_BODY)
+			{
+				if (!IS_SET(item->GetWearFlag(), WEARABLE_BODY) || !IS_SET(item2->GetWearFlag(), WEARABLE_BODY))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Æ¾    Ï´."));
+					return false;
+				}
+			}
+#if defined(__GLOVE_SYSTEM__)
+			else if (item2->GetType() == ITEM_ARMOR && item2->GetSubType() == ARMOR_GLOVE)
+			{
+				if (!IS_SET(item->GetWearFlag(), WEARABLE_GLOVE) || !IS_SET(item2->GetWearFlag(), WEARABLE_GLOVE))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Æ¾    Ï´."));
+					return false;
+				}
+			}
+#endif
+			else if (item2->GetType() == ITEM_WEAPON)
+			{
+				if (!IS_SET(item->GetWearFlag(), WEARABLE_WEAPON))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Æ¾ â¿¡   Ï´."));
+					return false;
+				}
+			}
+			else
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ö´  Ï´."));
+				return false;
+			}
+
+			for (i = 0; i < METIN_SOCKET_MAX_NUM; ++i)
+			{
+				if (item2->GetSocket(i) >= 1 && item2->GetSocket(i) <= 2 && item2->GetSocket(i) >= item->GetValue(2))
+				{
+					//  È®
+					if (number(1, 100) <= 30 || g_bNeverFailMetin == true)
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Æ¾  Ï¿Ï´."));
+
+#if defined(__GLOVE_SYSTEM__)
+						DWORD dwValue = item->GetVnum();
+						if (item->GetSubType() == METIN_SUNGMA)
+						{
+							bool bMultiplier = false;
+							if (item->GetValue(5) == 2 && number(1, 100) <= 30)
+							{
+								bMultiplier = true;
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING("Perfect! You have attached the Spirit Stone successfully and you even receive a double stat bonus."));
+							}
+							dwValue = item2->GetRandomSungMaSocketValue(item->GetValue(5), item->GetRefineLevel(), bMultiplier);
+						}
+						item2->SetSocket(i, dwValue);
+#else
+						item2->SetSocket(i, item->GetVnum());
+#endif
+					}
+					else
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Æ¾  Ï¿Ï´."));
+						item2->SetSocket(i, ITEM_BROKEN_METIN_VNUM);
+					}
+
+					LogManager::instance().ItemLog(this, item2, "SOCKET", item->GetName());
+					item->SetCount(item->GetCount() - 1);
+					break;
+				}
+			}
+
+			if (i == METIN_SOCKET_MAX_NUM)
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ö´  Ï´."));
+		}
+		break;
+
+		case ITEM_AUTOUSE:
+		case ITEM_MATERIAL:
+		case ITEM_SPECIAL:
+		case ITEM_TOOL:
+		case ITEM_LOTTERY:
+			break;
+
+		case ITEM_TOTEM:
+		{
+			if (!item->IsEquipped())
+				EquipItem(item);
+		}
+		break;
+
+		case ITEM_BLEND:
+		{
+			// Î¿ Êµ
+			sys_log(0, "ITEM_BLEND!!");
+
+			if (Blend_Item_find(item->GetVnum()))
+			{
+				int affect_type = AFFECT_BLEND;
+				int apply_type = aApplyInfo[item->GetSocket(0)].wPointType;
+				int apply_value = item->GetSocket(1);
+				int apply_duration = item->GetSocket(2);
+
+				if (FindAffect(affect_type, apply_type))
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+				}
+				else
+				{
+					if (FindAffect(AFFECT_EXP_BONUS_EURO_FREE, POINT_RESIST_MAGIC))
+					{
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ È¿ É· Ö½Ï´."));
+					}
+					else
+					{
+						AddAffect(affect_type, apply_type, apply_value, 0, apply_duration, 0, false);
+						item->SetCount(item->GetCount() - 1);
+					}
+				}
+			}
+		}
+		break;
+
+		case ITEM_EXTRACT:
+		{
+			LPITEM pDestItem = GetItem(DestCell);
+			if (NULL == pDestItem)
+				return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+			if (item->IsSealed())
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item on soulbound items."));
+				return false;
+			}
+#endif
+
+			switch (item->GetSubType())
+			{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+				case EXTRACT_DRAGON_SOUL:
+				{
+					if (pDestItem->IsDragonSoul())
+						return DSManager::instance().PullOut(this, NPOS, pDestItem, item);
+					return false;
+				}
+				case EXTRACT_DRAGON_HEART:
+				{
+					if (pDestItem->IsDragonSoul())
+						return DSManager::instance().ExtractDragonHeart(this, pDestItem, item);
+					return false;
+				}
+#endif
+				default:
+					return false;
+			}
+		}
+		break;
+
+#if defined(__GACHA_SYSTEM__)
+		case ITEM_GACHA:
+		{
+			switch (item->GetSubType())
+			{
+				case USE_GACHA:
+				{
+					if (GiveItemFromSpecialItemGroup(item->GetVnum()))
+					{
+						if (item->GetSocket(0) > 1)
+							item->SetSocket(0, item->GetSocket(0) - 1);
+						else
+							ITEM_MANAGER::instance().RemoveItem(item, "REMOVE (ITEM_GACHA)");
+					}
+				}
+				break;
+
+#if defined(__LUCKY_BOX__)
+				case GEM_LUCKY_BOX_GACHA:
+				case SPECIAL_LUCKY_BOX_GACHA:
+					SetLuckyBoxSrcItem(item);
+					break;
+#endif
+			}
+		}
+		break;
+#endif
+
+#if defined(__SOUL_SYSTEM__)
+		case ITEM_SOUL:
+		{
+			struct SoulData
+			{
+				WORD point_type;
+				DWORD affect_flag;
+			};
+			std::unordered_map<BYTE, SoulData> soul_map
+			{
+				{ RED_SOUL, { AFF_SOUL_RED, AFF_SOUL_RED }, },
+				{ BLUE_SOUL, { AFF_SOUL_BLUE, AFF_SOUL_BLUE }, },
+			};
+
+			const auto& it = soul_map.find(item->GetSubType());
+			if (it == soul_map.end())
+			{
+				sys_err("ITEM_SOUL: Unknown SubType");
+				return false;
+			}
+
+			const auto& soul = it->second;
+
+			CAffect* affect = nullptr;
+			for (auto const& it : GetAffectContainer())
+			{
+				if (it != nullptr && it->dwType == AFFECT_SOUL)
+				{
+					if (it->wApplyOn == soul.point_type)
+					{
+						if (item->GetSocket(1) != TRUE)
+						{
+							ChatPacket(CHAT_TYPE_INFO, "The soul color is already beeing used.");
+							return false;
+						}
+					}
+
+					affect = it;
+					continue;
+				}
+			}
+
+			if (item->GetSocket(1) != TRUE)
+			{
+				AddAffect(AFFECT_SOUL, soul.point_type, item->GetID(), affect ? AFF_NONE : soul.affect_flag, item->GetSocket(0), 0, false/*override*/);
+
+				if (affect)
+				{
+					std::vector<CAffect> tmp_affects;
+					std::vector<CAffect*> to_remove;
+					for (const auto& [k, v] : soul_map)
+					{
+						CAffect* affect = FindAffect(AFFECT_SOUL, v.point_type);
+						if (affect)
+						{
+							tmp_affects.emplace_back(*affect);
+							to_remove.emplace_back(affect);
+						}
+					}
+
+					if (!to_remove.empty())
+					{
+						for (const auto& it : to_remove)
+							RemoveAffect(it);
+					}
+
+					if (!tmp_affects.empty())
+					{
+						for (const auto& it : tmp_affects)
+							AddAffect(it.dwType, it.wApplyOn, it.lApplyValue, AFF_NONE, it.lDuration, 0, false/*override*/);
+					}
+
+					AddAffect(AFFECT_SOUL, AFF_SOUL_MIX, 0, AFF_SOUL_MIX, item->GetSocket(0), 0, false/*override*/);
+				}
+
+				item->SetSocket(1, TRUE);
+				item->Lock(true);
+			}
+			else
+			{
+				RemoveAffect(AFFECT_SOUL, soul.point_type);
+				RemoveAffect(AFFECT_SOUL, AFF_SOUL_MIX); // AFF_SOUL_MIX
+
+				std::vector<CAffect> tmp_affects;
+				std::vector<CAffect*> to_remove;
+				for (const auto& affect : GetAffectContainer())
+				{
+					if (affect != nullptr && affect->dwType == AFFECT_SOUL)
+					{
+						tmp_affects.emplace_back(*affect);
+						to_remove.emplace_back(affect);
+					}
+				}
+
+				for (const auto& affect : to_remove)
+					RemoveAffect(affect);
+
+				if (!tmp_affects.empty())
+				{
+					for (const auto& affect : tmp_affects)
+					{
+						auto it = std::find_if(soul_map.begin(), soul_map.end(), [&](const auto& kv_pair) {
+							return kv_pair.second.point_type == affect.wApplyOn;
+							});
+
+						if (it != soul_map.end())
+							AddAffect(affect.dwType, affect.wApplyOn, affect.lApplyValue, it->second.affect_flag, affect.lDuration, 0, false/*override*/);
+					}
+				}
+
+				item->SetSocket(1, FALSE);
+				item->Lock(false);
+			}
+		}
+		break;
+#endif
+
+		case ITEM_NONE:
+			sys_err("Item type NONE %s", item->GetName());
+			break;
+
+		default:
+			sys_log(0, "UseItemEx: Unknown type %s %d", item->GetName(), item->GetType());
+			return false;
+	}
+
+	return true;
+}
+
+int g_nPortalLimitTime = 10;
+
+bool CHARACTER::UseItem(TItemPos Cell, TItemPos DestCell)
+{
+	WORD wCell = Cell.cell;
+	BYTE window_type = Cell.window_type;
+
+	//WORD wDestCell = DestCell.cell;
+	//BYTE bDestInven = DestCell.window_type;
+
+	LPITEM item;
+
+	if (!CanHandleItem())
+		return false;
+
+	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
+		return false;
+
+	// We don't want to use it if we are dragging it over another item of the same type...
+	LPITEM destItem = GetItem(DestCell);
+	if (destItem && item != destItem && destItem->IsStackable() && !IS_SET(destItem->GetAntiFlag(), ITEM_ANTIFLAG_STACK) && destItem->GetVnum() == item->GetVnum())
+	{
+		if (MoveItem(Cell, DestCell, 0))
+			return false;
+	}
+
+	sys_log(0, "%s: USE_ITEM %s (inven %d, cell: %d)", GetName(), item->GetName(), window_type, wCell);
+
+	if (item->IsExchanging())
+		return false;
+
+	if (!item->CanUsedBy(this))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ê¾     Ï´."));
+		return false;
+	}
+
+	if (IsStun())
+		return false;
+
+	if (false == FN_check_item_sex(this, item))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ê¾     Ï´."));
+		return false;
+	}
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use items while modifying your pet's stats."));
+		return false;
+	}
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum = item->GetTransmutationVnum();
+	if (dwTransmutationVnum != 0)
+	{
+		TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwTransmutationVnum);
+
+		if (!pItemTable->CanUseByJob(GetJob()))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your class."));
+			return false;
+		}
+
+#	if defined(__COSTUME_SYSTEM__)
+		if (pItemTable && pItemTable->IsCostume())
+		{
+			if ((IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_MALE) && SEX_MALE == GET_SEX(this)) ||
+				(IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_FEMALE) && SEX_FEMALE == GET_SEX(this)))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your gender."));
+				return false;
+			}
+		}
+	}
+#	endif
+#endif
+
+	// PREVENT_TRADE_WINDOW
+	if (IS_SUMMON_ITEM(item, GetMapIndex()))
+	{
+		if (false == IS_SUMMONABLE_ZONE(GetMapIndex()))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this item here."));
+			return false;
+		}
+
+		// È¥   SUMMONABLE_ZONE Ö´Â° WarpToPC() Ã¼Å©
+
+		// Å¸  Ê¿ È¯Î¸ Æ¹.
+		if (CThreeWayWar::instance().IsThreeWayWarMapIndex(GetMapIndex()))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Å¸  ß¿ È¯,È¯Î¸ Ò¼ Ï´."));
+			return false;
+		}
+
+		int iPulse = thecore_pulse();
+
+		// Ã¢  Ã¼Å©
+		if (iPulse - GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¢  %d Ì³ È¯,È¯Î¸   Ï´.", g_nPortalLimitTime));
+
+			if (test_server)
+				ChatPacket(CHAT_TYPE_INFO, "[TestOnly]Pulse %d LoadTime %d PASS %d", iPulse, GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
+			return false;
+		}
+
+		// Å· Ã¢ Ã¼Å©
+		if (PreventTradeWindow(WND_ALL))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Å·Ã¢,Ã¢   Â¿ È¯,È¯  Ò¼ Ï´."));
+			return false;
+		}
+
+		// PREVENT_REFINE_HACK
+		//  Ã°Ã¼Å©
+		{
+			if (iPulse - GetRefineTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d Ì³ È¯,È¯Î¸   Ï´.", g_nPortalLimitTime));
+				return false;
+			}
+		}
+		// END_PREVENT_REFINE_HACK
+
+		// PREVENT_ITEM_COPY
+		{
+			if (iPulse - GetMyShopTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Î»  %d Ì³ È¯,È¯Î¸   Ï´.", g_nPortalLimitTime));
+				return false;
+			}
+
+#if defined(__MAILBOX__)
+			if (iPulse - GetMyMailBoxTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+			{
+				ChatPacket(CHAT_TYPE_INFO, "You cannot use a Return Scroll %d seconds after opening a mailbox.", g_nPortalLimitTime);
+				return false;
+			}
+#endif
+		}
+		// END_PREVENT_ITEM_COPY
+
+		// È¯ Å¸Ã¼Å©
+		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_TALISMAN)
+		{
+			PIXEL_POSITION posWarp;
+
+			int x = 0;
+			int y = 0;
+
+			double nDist = 0;
+			const double nDistant = 5000.0;
+
+			// È¯
+			if (item->GetVnum() == 22010)
+			{
+				x = item->GetSocket(0) - GetX();
+				y = item->GetSocket(1) - GetY();
+			}
+			// È¯
+			else if (item->GetVnum() == 22000)
+			{
+				SECTREE_MANAGER::instance().GetRecallPositionByEmpire(GetMapIndex(), GetEmpire(), posWarp);
+
+				if (item->GetSocket(0) == 0)
+				{
+					x = posWarp.x - GetX();
+					y = posWarp.y - GetY();
+				}
+				else
+				{
+					x = item->GetSocket(0) - GetX();
+					y = item->GetSocket(1) - GetY();
+				}
+			}
+
+			nDist = sqrt(pow((float)x, 2) + pow((float)y, 2));
+
+			if (nDistant > nDist)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ìµ Ç¾ Ä¡ Ê¹  È¯Î¸ Ò¼ Ï´."));
+				if (test_server)
+					ChatPacket(CHAT_TYPE_INFO, "PossibleDistant %f nNowDist %f", nDistant, nDist);
+				return false;
+			}
+		}
+
+		// PREVENT_PORTAL_AFTER_EXCHANGE
+		// È¯  Ã°Ã¼Å©
+		if (iPulse - GetExchangeTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Å·  %d Ì³ È¯,È¯Îµ   Ï´.", g_nPortalLimitTime));
+			return false;
+		}
+		// END_PREVENT_PORTAL_AFTER_EXCHANGE
+	}
+
+	//    Å·Ã¢  Ã¼Å©
+	if ((item->GetVnum() == 50200) || (item->GetVnum() == 71049))
+	{
+		if (PreventTradeWindow(WND_ALL))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Å·Ã¢,Ã¢   Â¿ ,Üº Ò¼ Ï´."));
+			return false;
+		}
+	}
+	// END_PREVENT_TRADE_WINDOW
+
+	if (IsRunningQuest())
+		return false;
+
+	if (IS_SET(item->GetFlag(), ITEM_FLAG_LOG)) //  Î±×¸   Ã³
+	{
+		DWORD vid = item->GetVID();
+		DWORD oldCount = item->GetCount();
+		DWORD vnum = item->GetVnum();
+
+		char hint[ITEM_NAME_MAX_LEN + 32 + 1];
+		int len = snprintf(hint, sizeof(hint) - 32, "%s", item->GetName());
+
+		if (len < 0 || len >= (int)sizeof(hint) - 32)
+			len = (sizeof(hint) - 32) - 1;
+
+		bool ret = UseItemEx(item, DestCell);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		if (ret and item->GetType() == ITEM_USE or ret and item->GetType() == ITEM_SKILLBOOK or ret and item->GetType() == ITEM_GIFTBOX)
+			UpdateExtBattlePassMissionProgress(BP_ITEM_USE, 1, item->GetVnum());
+#endif
+
+		if (NULL == ITEM_MANAGER::instance().FindByVID(vid)) // UseItemEx   Ç¾.  Î±×¸ 
+		{
+			LogManager::instance().ItemLog(this, vid, vnum, "REMOVE", hint);
+		}
+		else if (oldCount != item->GetCount())
+		{
+			snprintf(hint + len, sizeof(hint) - len, " %u", oldCount - 1);
+			LogManager::instance().ItemLog(this, vid, vnum, "USE_ITEM", hint);
+		}
+		return (ret);
+	}
+	else
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	{
+		bool ret = UseItemEx(item, DestCell);
+
+		if (ret and item->GetType() == ITEM_USE or ret and item->GetType() == ITEM_SKILLBOOK or ret and item->GetType() == ITEM_GIFTBOX)
+			UpdateExtBattlePassMissionProgress(BP_ITEM_USE, 1, item->GetVnum());
+		
+		return (ret);
+	}
+#else
+		return UseItemEx(item, DestCell);
+#endif
+}
+
+bool CHARACTER::DropItem(TItemPos Cell, WORD wCount)
+{
+	LPITEM item = NULL;
+
+	if (!CanHandleItem())
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (NULL != DragonSoul_RefineWindow_GetOpener())
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("È­Ã¢  Â¿  Å±  Ï´."));
+#endif
+		return false;
+	}
+
+	if (IsDead())
+		return false;
+
+	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
+		return false;
+
+	if (item->IsExchanging())
+		return false;
+
+	if (true == item->isLocked())
+		return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (item->IsSealed())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot drop a soulbound item."));
+		return false;
+	}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot drop items while modifying your pet's stats."));
+		return false;
+	}
+#endif
+
+	if (IsRunningQuest())
+		return false;
+
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DROP | ITEM_ANTIFLAG_GIVE))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Ô´Ï´."));
+		return false;
+	}
+
+	if (wCount == 0 || wCount > item->GetCount())
+		wCount = item->GetCount();
+
+	// Quickslot  
+	if (INVENTORY == Cell.window_type)
+		SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, WORD_MAX);
+	else if (BELT_INVENTORY == Cell.window_type)
+		SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, WORD_MAX);
+
+	LPITEM pkItemToDrop;
+
+	if (wCount == item->GetCount())
+	{
+		item->RemoveFromCharacter();
+		pkItemToDrop = item;
+	}
+	else
+	{
+		if (wCount == 0)
+		{
+			if (test_server)
+				sys_log(0, "[DROP_ITEM] drop item count == 0");
+			return false;
+		}
+
+		item->SetCount(item->GetCount() - wCount);
+		ITEM_MANAGER::instance().FlushDelayedSave(item);
+
+		pkItemToDrop = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), wCount);
+
+		// Copy item socket -- by mhh
+		FN_copy_item_socket(pkItemToDrop, item);
+
+		char szBuf[51 + 1];
+		snprintf(szBuf, sizeof(szBuf), "%u %u", pkItemToDrop->GetID(), pkItemToDrop->GetCount());
+		LogManager::instance().ItemLog(this, item, "ITEM_SPLIT", szBuf);
+	}
+
+	PIXEL_POSITION pxPos = GetXYZ();
+
+	if (pkItemToDrop->AddToGround(GetMapIndex(), pxPos))
+	{
+		// Ñ±   Ø´Þ¶  Æ¼
+		//  Ù´Ú¿   Ó¼Î±×¸ .
+		if (LC_IsYMIR())
+			item->AttrLog();
+
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("  3  Ï´."));
+		pkItemToDrop->StartDestroyEvent();
+
+		ITEM_MANAGER::instance().FlushDelayedSave(pkItemToDrop);
+
+		char szHint[32 + 1];
+		snprintf(szHint, sizeof(szHint), "%s %u %u", pkItemToDrop->GetName(), pkItemToDrop->GetCount(), pkItemToDrop->GetOriginalVnum());
+		LogManager::instance().ItemLog(this, pkItemToDrop, "DROP", szHint);
+		//Motion(MOTION_PICKUP);
+	}
+
+	return true;
+}
+
+#if defined(__NEW_DROP_DIALOG__)
+bool CHARACTER::DestroyItem(TItemPos Cell)
+{
+	LPITEM item = NULL;
+
+	if (!CanHandleItem())
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (NULL != DragonSoul_RefineWindow_GetOpener())
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("È­Ã¢  Â¿  Å±  Ï´."));
+#endif
+		return false;
+	}
+
+	if (IsDead())
+		return false;
+
+	if (!IsValidItemPosition(Cell) || !(item = GetItem(Cell)))
+		return false;
+
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DESTROY))
+		return false;
+
+	if (item->IsExchanging())
+		return false;
+
+	if (true == item->isLocked())
+		return false;
+
+	if (IsRunningQuest())
+		return false;
+
+	if (item->GetCount() <= 0)
+		return false;
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	UpdateExtBattlePassMissionProgress(BP_ITEM_DESTROY, 1, item->GetVnum());
+#endif
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (item->IsSealed())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot destroy a soulbound item."));
+		return false;
+	}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (item->IsPet())
+		return false;
+#endif
+
+	if (INVENTORY == Cell.window_type)
+		SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, WORD_MAX);
+	else if (BELT_INVENTORY == Cell.window_type)
+		SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, WORD_MAX);
+
+	ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have deleted %s.", LC_ITEM(item->GetVnum())));
+	ITEM_MANAGER::instance().RemoveItem(item, "DESTROYED BY PLAYER");
+
+	return true;
+}
+#endif
+
+bool CHARACTER::DropGold(int iAmount)
+{
+	if (iAmount <= 0 || iAmount > GetGold())
+		return false;
+
+	if (!CanHandleItem())
+		return false;
+
+	if (0 != g_GoldDropTimeLimitValue)
+	{
+		if ((int)(get_dword_time() - (m_dwLastGoldDropTime + g_GoldDropTimeLimitValue)) < 0)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" å¸¦   Ï´."));
+			return false;
+		}
+	}
+
+	m_dwLastGoldDropTime = get_dword_time();
+
+	LPITEM item = ITEM_MANAGER::instance().CreateItem(1, iAmount);
+
+	if (item)
+	{
+		PIXEL_POSITION pos = GetXYZ();
+
+		if (item->AddToGround(GetMapIndex(), pos))
+		{
+			//Motion(MOTION_PICKUP);
+			PointChange(POINT_GOLD, -iAmount, true);
+
+			//   Ù´ ×° Ö´Âµ,
+			//  Ã³ ß¿ Ï³,
+			// Å©Î³,  á¼­ 1000     å¸¦ 0 ,
+			//  Ù°  Ã»Ï´   Ö´.
+			//  ×· ì¸¦    Ä¡ å¿¡ Ø¼ Î±×¸ .
+			if (LC_IsBrazil() == true)
+			{
+				if (iAmount >= 213)
+					LogManager::instance().CharLog(this, iAmount, "DROP_GOLD", "");
+			}
+			else
+			{
+				if (iAmount > 1000) // Ãµ Ì» Ñ´.
+					LogManager::instance().CharLog(this, iAmount, "DROP_GOLD", "");
+			}
+
+			if (false == LC_IsBrazil())
+			{
+				item->StartDestroyEvent(150);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d  Ï´.", 150 / 60));
+			}
+			else
+			{
+				item->StartDestroyEvent(60);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d  Ï´.", 1));
+			}
+		}
+
+		Save();
+		return true;
+	}
+
+	return false;
+}
+
+#if defined(__CHEQUE_SYSTEM__)
+bool CHARACTER::DropCheque(int cheque)
+{
+	if (cheque <= 0 || (long long)cheque > GetCheque())
+		return false;
+
+	if (!CanHandleItem())
+		return false;
+
+	if (0 != g_ChequeDropTimeLimitValue)
+	{
+		if ((int)(get_dword_time() - (m_dwLastChequeDropTime + g_ChequeDropTimeLimitValue)) < 0)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" å¸¦   Ï´."));
+			return false;
+		}
+	}
+
+	m_dwLastChequeDropTime = get_dword_time();
+
+	LPITEM item = ITEM_MANAGER::instance().CreateItem(80020, cheque);
+
+	if (item)
+	{
+		PIXEL_POSITION pos = GetXYZ();
+
+		if (item->AddToGround(GetMapIndex(), pos))
+		{
+			PointChange(POINT_CHEQUE, -cheque, true);
+
+			if (cheque > 1000)
+				LogManager::instance().CharLog(this, cheque, "DROP_CHEQUE", "");
+
+			if (false == LC_IsBrazil())
+			{
+				item->StartDestroyEvent(150);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d  Ï´.", 150 / 60));
+			}
+			else
+			{
+				item->StartDestroyEvent(60);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("  %d  Ï´.", 1));
+			}
+		}
+
+		Save();
+		return true;
+	}
+
+	return false;
+}
+#endif
+
+bool CHARACTER::MoveItem(TItemPos Cell, TItemPos DestCell, WORD count)
+{
+	LPITEM item = nullptr;
+
+	if (Cell.IsSameItemPosition(DestCell))
+		return false;
+
+	if (!IsValidItemPosition(Cell))
+		return false;
+
+	if (!(item = GetItem(Cell)))
+		return false;
+
+	if (item->IsExchanging())
+		return false;
+
+	if (item->GetCount() < count)
+		return false;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	if (INVENTORY == Cell.window_type && Cell.cell >= GetExtendInvenMax() && IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+		return false;
+#else
+	if (INVENTORY == Cell.window_type && Cell.cell >= INVENTORY_MAX_NUM && IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+		return false;
+#endif
+
+	if (true == item->isLocked())
+		return false;
+
+	if (!IsValidItemPosition(DestCell))
+		return false;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	// Prevent moving items into locked extended inventory slots (client/UI desync or packet injection)
+	if (DestCell.window_type == INVENTORY && !DestCell.IsBeltInventoryPosition() && DestCell.cell >= GetExtendInvenMax())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot move items to a locked inventory slot."));
+		return false;
+	}
+#endif
+
+	if (!CanHandleItem())
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (DragonSoul_RefineWindow_GetOpener())
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("È­Ã¢  Â¿  Å±  Ï´."));
+#endif
+		return false;
+	}
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot move items while modifying your pet's stats."));
+		return false;
+	}
+#endif
+
+	if (DestCell.IsBeltInventoryPosition())
+	{
+		// At the request of the planner, only certain types of items can be placed in the belt inventory.
+		if (!CBeltInventoryHelper::CanMoveIntoBeltInventory(item))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Æ® Îºä¸® Å±  Ï´."));
+			return false;
+		}
+	}
+
+	// Ì¹   Ù¸  Å± , 'Ã¥ '   È®Ï° Å±
+	if (Cell.IsEquipPosition())
+	{
+		if (!CanUnequipNow(item))
+			return false;
+
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+		const int iWearCell = item->FindEquipCell(this);
+		if (iWearCell == WEAR_WEAPON)
+		{
+			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
+			if (pkCostumeWeapon)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
+				return false;
+			}
+		}
+#endif
+	}
+
+	if (DestCell.IsEquipPosition())
+	{
+		if (GetItem(DestCell)
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			&& DestCell.IsDragonSoulEquipPosition()
+#endif
+			) //     Ë»Øµ È´.
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹  Ï° Ö½Ï´."));
+			return false;
+		}
+
+		EquipItem(item, DestCell.cell);
+	}
+	else
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+		{
+			if (item->IsEquipped())
+			{
+				return DSManager::instance().PullOut(this, DestCell, item);
+			}
+			else
+			{
+				if (DestCell.window_type != DRAGON_SOUL_INVENTORY)
+				{
+					return false;
+				}
+
+				if (!DSManager::instance().IsValidCellForThisItem(item, DestCell))
+					return false;
+			}
+		}
+		// È¥ Æ´  È¥ Îº î°¥  .
+		else if (DRAGON_SOUL_INVENTORY == DestCell.window_type)
+			return false;
+#endif
+
+		LPITEM item2;
+
+		if ((item2 = GetItem(DestCell)) && item != item2 && item2->IsStackable() &&
+			!IS_SET(item2->GetAntiFlag(), ITEM_ANTIFLAG_STACK) &&
+			item2->GetVnum() == item->GetVnum() && !item2->IsExchanging()) // Ä¥  Ö´  
+		{
+			for (int i = 0; i < ITEM_SOCKET_MAX_NUM; ++i)
+				if (item2->GetSocket(i) != item->GetSocket(i))
+					return false;
+
+			if (count == 0)
+				count = item->GetCount();
+
+			sys_log(0, "%s: ITEM_STACK %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell,
+				DestCell.window_type, DestCell.cell, count);
+
+			count = MIN(ITEM_MAX_COUNT - item2->GetCount(), count);
+
+			if (count == 0)
+				return false;
+
+			item->SetCount(item->GetCount() - count);
+			item2->SetCount(item2->GetCount() + count);
+
+			return true;
+		}
+
+		if (!IsEmptyItemGrid(DestCell, item->GetSize(), Cell.cell))
+		{
+			return false;
+		}
+
+		if (count == 0 || count >= item->GetCount() || !item->IsStackable() || IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+		{
+			sys_log(0, "%s: ITEM_MOVE %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell,
+				DestCell.window_type, DestCell.cell, count);
+
+			item->RemoveFromCharacter();
+			SetItem(DestCell, item);
+
+			if (INVENTORY == Cell.window_type && INVENTORY == DestCell.window_type)
+				SyncQuickslot(SLOT_TYPE_INVENTORY, Cell.cell, DestCell.cell);
+			else if (BELT_INVENTORY == Cell.window_type && BELT_INVENTORY == DestCell.window_type)
+				SyncQuickslot(SLOT_TYPE_BELT_INVENTORY, Cell.cell, DestCell.cell);
+
+			else if (INVENTORY == Cell.window_type && BELT_INVENTORY == DestCell.window_type)
+				MoveQuickSlotItem(SLOT_TYPE_INVENTORY, Cell.cell, SLOT_TYPE_BELT_INVENTORY, DestCell.cell);
+			else if (BELT_INVENTORY == Cell.window_type && INVENTORY == DestCell.window_type)
+				MoveQuickSlotItem(SLOT_TYPE_BELT_INVENTORY, Cell.cell, SLOT_TYPE_INVENTORY, DestCell.cell);
+		}
+		else if (count < item->GetCount())
+		{
+			sys_log(0, "%s: ITEM_SPLIT %s (window: %d, cell : %d) -> (window:%d, cell %d) count %d", GetName(), item->GetName(), Cell.window_type, Cell.cell, DestCell.window_type, DestCell.cell, count);
+
+			LPITEM item2 = ITEM_MANAGER::instance().CreateItem(item->GetVnum(), count);
+			if (!item2)
+				return false;
+
+			// Copy socket -- by mhh
+			FN_copy_item_socket(item2, item);
+
+			if (!item2->AddToCharacter(this, DestCell))
+			{
+				M2_DESTROY_ITEM(item2);
+				return false;
+			}
+
+			item->SetCount(item->GetCount() - count);
+
+			char szBuf[51 + 1];
+			snprintf(szBuf, sizeof(szBuf), "%u %u %u %u ", item2->GetID(), item2->GetCount(), item->GetCount(), item->GetCount() + item2->GetCount());
+			LogManager::instance().ItemLog(this, item, "ITEM_SPLIT", szBuf);
+		}
+	}
+
+	return true;
+}
+
+namespace NPartyPickupDistribute
+{
+	struct FFindOwnership
+	{
+		LPITEM item;
+		LPCHARACTER owner;
+
+		FFindOwnership(LPITEM item)
+			: item(item), owner(NULL)
+		{
+		}
+
+		void operator () (LPCHARACTER ch)
+		{
+			if (item->IsOwnership(ch))
+				owner = ch;
+		}
+	};
+
+	struct FCountNearMember
+	{
+		int total;
+		int x, y;
+
+		FCountNearMember(LPCHARACTER center)
+			: total(0), x(center->GetX()), y(center->GetY())
+		{
+		}
+
+		void operator () (LPCHARACTER ch)
+		{
+			if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
+				total += 1;
+		}
+	};
+
+	struct FMoneyDistributor
+	{
+		int total;
+		LPCHARACTER c;
+		int x, y;
+		int iMoney;
+
+		FMoneyDistributor(LPCHARACTER center, int iMoney)
+			: total(0), c(center), x(center->GetX()), y(center->GetY()), iMoney(iMoney)
+		{
+		}
+
+		void operator ()(LPCHARACTER ch)
+		{
+			if (ch != c)
+				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
+				{
+					ch->PointChange(POINT_GOLD, iMoney, true);
+
+					if (iMoney > 1000) // Ãµ Ì» Ñ´.
+						LogManager::instance().CharLog(ch, iMoney, "GET_GOLD", "");
+				}
+		}
+	};
+
+#if defined(__CHEQUE_SYSTEM__)
+	struct FChequeDistributor
+	{
+		int total;
+		LPCHARACTER c;
+		int x, y;
+		int iCheque;
+
+		FChequeDistributor(LPCHARACTER center, int iCheque)
+			: total(0), c(center), x(center->GetX()), y(center->GetY()), iCheque(iCheque)
+		{
+		}
+
+		void operator ()(LPCHARACTER ch)
+		{
+			if (ch != c)
+				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
+				{
+					ch->PointChange(POINT_CHEQUE, iCheque, true);
+
+					if (iCheque > 1000)
+						LogManager::instance().CharLog(ch, iCheque, "GET_CHEQUE", "");
+				}
+		}
+	};
+#endif
+
+#if defined(__GEM_SYSTEM__)
+	struct FGemDistributor
+	{
+		int total;
+		LPCHARACTER c;
+		int x, y;
+		int iGem;
+
+		FGemDistributor(LPCHARACTER center, int iGem)
+			: total(0), c(center), x(center->GetX()), y(center->GetY()), iGem(iGem)
+		{
+		}
+
+		void operator ()(LPCHARACTER ch)
+		{
+			if (ch != c)
+				if (DISTANCE_APPROX(ch->GetX() - x, ch->GetY() - y) <= PARTY_DEFAULT_RANGE)
+				{
+					ch->PointChange(POINT_GEM, iGem, true);
+
+					if (iGem > 1000)
+						LogManager::instance().CharLog(ch, iGem, "GET_GEM", "");
+				}
+		}
+	};
+#endif
+}
+
+void CHARACTER::GiveGold(int iAmount)
+{
+	if (iAmount <= 0)
+		return;
+
+	sys_log(0, "GIVE_GOLD: %s %d", GetName(), iAmount);
+
+	if (GetParty())
+	{
+		LPPARTY pParty = GetParty();
+
+		// Æ¼ Ö´   .
+		DWORD dwTotal = iAmount;
+		DWORD dwMyAmount = dwTotal;
+
+		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
+		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
+
+		if (funcCountNearMember.total > 1)
+		{
+			DWORD dwShare = dwTotal / funcCountNearMember.total;
+			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
+
+			NPartyPickupDistribute::FMoneyDistributor funcMoneyDist(this, dwShare);
+			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
+		}
+
+		PointChange(POINT_GOLD, dwMyAmount, true);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		UpdateExtBattlePassMissionProgress(YANG_COLLECT, dwMyAmount, GetMapIndex());
+#endif
+
+		if (dwMyAmount > 1000) // Ãµ Ì» Ñ´.
+			LogManager::instance().CharLog(this, dwMyAmount, "GET_GOLD", "");
+	}
+	else
+	{
+		PointChange(POINT_GOLD, iAmount, true);
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		UpdateExtBattlePassMissionProgress(YANG_COLLECT, iAmount, GetMapIndex());
+#endif
+
+		//   Ù´ ×° Ö´Âµ,
+		//  Ã³ ß¿ Ï³,
+		// Å©Î³,  á¼­ 1000     å¸¦ 0 ,
+		//  Ù°  Ã»Ï´   Ö´.
+		//  ×· ì¸¦    Ä¡ å¿¡ Ø¼ Î±×¸ .
+		if (LC_IsBrazil() == true)
+		{
+			if (iAmount >= 213)
+				LogManager::instance().CharLog(this, iAmount, "GET_GOLD", "");
+		}
+		else
+		{
+			if (iAmount > 1000) // Ãµ Ì» Ñ´.
+				LogManager::instance().CharLog(this, iAmount, "GET_GOLD", "");
+		}
+	}
+}
+
+#if defined(__CHEQUE_SYSTEM__)
+void CHARACTER::GiveCheque(int iAmount)
+{
+	if (iAmount <= 0)
+		return;
+
+	sys_log(0, "GIVE_CHEQUE: %s %lld", GetName(), iAmount);
+
+	if (GetParty())
+	{
+		LPPARTY pParty = GetParty();
+
+		DWORD dwTotal = iAmount;
+		DWORD dwMyAmount = dwTotal;
+
+		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
+		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
+
+		if (funcCountNearMember.total > 1)
+		{
+			DWORD dwShare = dwTotal / funcCountNearMember.total;
+			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
+
+			NPartyPickupDistribute::FChequeDistributor funcMoneyDist(this, dwShare);
+			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
+		}
+
+		PointChange(POINT_CHEQUE, dwMyAmount, true);
+
+		if (dwMyAmount > 1000)
+			LogManager::instance().CharLog(this, dwMyAmount, "GET_CHEQUE", "");
+	}
+	else
+	{
+		PointChange(POINT_CHEQUE, iAmount, true);
+
+		if (LC_IsBrazil() == true)
+		{
+			if (iAmount >= 213)
+				LogManager::instance().CharLog(this, iAmount, "GET_CHEQUE", "");
+		}
+		else
+		{
+			if (iAmount > 1000)
+				LogManager::instance().CharLog(this, iAmount, "GET_CHEQUE", "");
+		}
+	}
+}
+#endif
+
+#if defined(__GEM_SYSTEM__)
+void CHARACTER::GiveGem(int iAmount)
+{
+	if (iAmount <= 0)
+		return;
+
+	sys_log(0, "GIVE_GEM: %s %lld", GetName(), iAmount);
+
+	if (GetParty())
+	{
+		LPPARTY pParty = GetParty();
+
+		DWORD dwTotal = iAmount;
+		DWORD dwMyAmount = dwTotal;
+
+		NPartyPickupDistribute::FCountNearMember funcCountNearMember(this);
+		pParty->ForEachOnMapMember(funcCountNearMember, GetMapIndex());
+
+		if (funcCountNearMember.total > 1)
+		{
+			DWORD dwShare = dwTotal / funcCountNearMember.total;
+			dwMyAmount -= dwShare * (funcCountNearMember.total - 1);
+
+			NPartyPickupDistribute::FGemDistributor funcMoneyDist(this, dwShare);
+			pParty->ForEachOnMapMember(funcMoneyDist, GetMapIndex());
+		}
+
+		PointChange(POINT_GEM, dwMyAmount, true);
+
+		if (dwMyAmount > 1000)
+			LogManager::instance().CharLog(this, dwMyAmount, "GET_GEM", "");
+	}
+	else
+	{
+		PointChange(POINT_GEM, iAmount, true);
+
+		if (LC_IsBrazil() == true)
+		{
+			if (iAmount >= 213)
+				LogManager::instance().CharLog(this, iAmount, "GET_GEM", "");
+		}
+		else
+		{
+			if (iAmount > 1000)
+				LogManager::instance().CharLog(this, iAmount, "GET_GEM", "");
+		}
+	}
+}
+#endif
+
+bool CHARACTER::PickupItem(DWORD dwVID
+#if defined(__PET_LOOT_AI__)
+	, bool bPetLoot
+#endif
+)
+{
+	if (IsDead())
+		return false;
+
+	LPITEM item = ITEM_MANAGER::instance().FindByVID(dwVID);
+
+	if (IsObserverMode())
+		return false;
+
+	if (!item || !item->GetSectree())
+		return false;
+
+	if (item->DistanceValid(this)
+#if defined(__PET_LOOT_AI__)
+		|| bPetLoot
+#endif
+		)
+	{
+		if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
+			|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
+		{
+			if (IsRunningQuest())
+				return false;
+		}
+
+		if (item->IsOwnership(this))
+		{
+#if defined(__LOOT_FILTER_SYSTEM__)
+			if (GetLootFilter() && !GetLootFilter()->CanPickUpItem(item))
+			{
+				if (!GetLootFilter()->IsLootFilteredItem(dwVID))
+				{
+					GetLootFilter()->InsertLootFilteredItem(dwVID);
+
+					if (GetDesc())
+					{
+						TPacketGCLootFilter p;
+						p.header = HEADER_GC_LOOT_FILTER;
+						p.enable = false;
+						p.vid = dwVID;
+						GetDesc()->Packet(&p, sizeof(p));
+					}
+				}
+
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as the loot filter is deactivated."));
+				return false;
+			}
+#endif
+
+			//   Ï´  Å©
+			if (item->GetType() == ITEM_ELK)
+			{
+				GiveGold(item->GetCount());
+				item->RemoveFromGround();
+
+				M2_DESTROY_ITEM(item);
+
+				Save();
+			}
+			//  Ì¶
+			else
+			{
+				if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+				{
+					WORD wCount = item->GetCount();
+
+					for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+					{
+						LPITEM item2 = GetInventoryItem(i);
+
+						if (!item2)
+							continue;
+
+						if (item2->GetVnum() == item->GetVnum())
+						{
+							int j;
+
+							for (j = 0; j < ITEM_SOCKET_MAX_NUM; ++j)
+							{
+								if (item2->GetSocket(j) != item->GetSocket(j))
+									break;
+							}
+
+							if (j != ITEM_SOCKET_MAX_NUM)
+								continue;
+
+							WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
+
+							wCount -= wCount2;
+
+							item2->SetCount(item2->GetCount() + wCount2);
+
+							if (wCount == 0)
+							{
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+								ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
+#else
+								ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_ITEM(item2->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
+#else
+								ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_ITEM(item2->GetVnum())));
+#endif
+#endif
+								M2_DESTROY_ITEM(item);
+
+								if (item2->GetType() == ITEM_QUEST)
+									quest::CQuestManager::instance().PickupItem(GetPlayerID(), item2);
+
+								return true;
+							}
+						}
+					}
+
+					item->SetCount(wCount);
+				}
+
+				int iEmptyCell;
+#if defined(__DRAGON_SOUL_SYSTEM__)
+				if (item->IsDragonSoul())
+				{
+					if ((iEmptyCell = GetEmptyDragonSoulInventory(item)) == -1)
+					{
+						sys_log(0, "No empty ds inventory pid %u size %ud itemid %u", GetPlayerID(), item->GetSize(), item->GetID());
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ï° Ö´  Ê¹ Ï´."));
+						return false;
+					}
+				}
+				else
+#endif
+				{
+					if ((iEmptyCell = GetEmptyInventory(item->GetSize())) == -1)
+					{
+						sys_log(0, "No empty inventory pid %u size %ud itemid %u", GetPlayerID(), item->GetSize(), item->GetID());
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ï° Ö´  Ê¹ Ï´."));
+						return false;
+					}
+				}
+
+				item->RemoveFromGround();
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+				if (item->IsDragonSoul())
+					item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
+				else
+#endif
+					item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell));
+
+				char szHint[32 + 1];
+				snprintf(szHint, sizeof(szHint), "%s %u %u", item->GetName(), item->GetCount(), item->GetOriginalVnum());
+				LogManager::instance().ItemLog(this, item, "GET", szHint);
+
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#endif
+#endif
+
+				if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
+					|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
+				{
+					quest::CQuestManager::instance().PickupItem(GetPlayerID(), item);
+				}
+			}
+
+			//Motion(MOTION_PICKUP);
+			return true;
+		}
+		else if (!IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_GIVE | ITEM_ANTIFLAG_DROP) && GetParty())
+		{
+			// Ù¸ Æ¼    Ñ´Ù¸
+			NPartyPickupDistribute::FFindOwnership funcFindOwnership(item);
+			GetParty()->ForEachOnMapMember(funcFindOwnership, GetMapIndex());
+
+			LPCHARACTER owner = funcFindOwnership.owner;
+			if (!owner)
+				return false;
+
+			int iEmptyCell;
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			if (item->IsDragonSoul())
+			{
+				if (!(owner && (iEmptyCell = owner->GetEmptyDragonSoulInventory(item)) != -1))
+				{
+					owner = this;
+
+					if ((iEmptyCell = GetEmptyDragonSoulInventory(item)) == -1)
+					{
+						owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ï° Ö´  Ê¹ Ï´."));
+						return false;
+					}
+				}
+			}
+			else
+#endif
+			{
+				if (!(owner && (iEmptyCell = owner->GetEmptyInventory(item->GetSize())) != -1))
+				{
+					owner = this;
+
+					if ((iEmptyCell = GetEmptyInventory(item->GetSize())) == -1)
+					{
+						owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ï° Ö´  Ê¹ Ï´."));
+						return false;
+					}
+				}
+			}
+
+			if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+			{
+				WORD wCount = item->GetCount();
+
+				for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+				{
+					LPITEM item2 = owner->GetInventoryItem(i);
+
+					if (!item2)
+						continue;
+
+					if (item2->GetVnum() == item->GetVnum())
+					{
+						int j;
+
+						for (j = 0; j < ITEM_SOCKET_MAX_NUM; ++j)
+						{
+							if (item2->GetSocket(j) != item->GetSocket(j))
+								break;
+						}
+
+						if (j != ITEM_SOCKET_MAX_NUM)
+							continue;
+
+						WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
+
+						wCount -= wCount2;
+
+						item2->SetCount(item2->GetCount() + wCount2);
+
+						if (wCount == 0)
+						{
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+							owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
+#else
+							owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_ITEM(item2->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+							owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item2->GetItemSetValue(), item2->GetVnum())));
+#else
+							owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_ITEM(item2->GetVnum())));
+#endif
+#endif
+							M2_DESTROY_ITEM(item);
+
+							if (item2->GetType() == ITEM_QUEST)
+								quest::CQuestManager::instance().PickupItem(owner->GetPlayerID(), item2);
+
+							return true;
+						}
+					}
+				}
+
+				item->SetCount(wCount);
+			}
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+			if (owner->GetLootFilter() && !owner->GetLootFilter()->CanPickUpItem(item))
+			{
+				if (owner == this)
+				{
+					if (!owner->GetLootFilter()->IsLootFilteredItem(dwVID))
+					{
+						owner->GetLootFilter()->InsertLootFilteredItem(dwVID);
+
+						if (owner->GetDesc())
+						{
+							TPacketGCLootFilter p;
+							p.header = HEADER_GC_LOOT_FILTER;
+							p.enable = false;
+							p.vid = dwVID;
+							owner->GetDesc()->Packet(&p, sizeof(p));
+						}
+					}
+
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as the loot filter is deactivated."));
+				}
+				else
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("No loot will be collected as a party member's loot filter is deactivated."));
+				}
+
+				return false;
+			}
+#endif
+
+			item->RemoveFromGround();
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+			if (item->IsDragonSoul())
+				item->AddToCharacter(owner, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
+			else
+#endif
+				item->AddToCharacter(owner, TItemPos(INVENTORY, iEmptyCell));
+
+			char szHint[32 + 1];
+			snprintf(szHint, sizeof(szHint), "%s %u %u", item->GetName(), item->GetCount(), item->GetOriginalVnum());
+			LogManager::instance().ItemLog(owner, item, "GET", szHint);
+
+			if (owner == this)
+			{
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#endif
+#endif
+			}
+			else
+			{
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+				owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s Îº %s", GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" : %s Ô¿ %s", owner->GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				owner->ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s Îº %s", GetName(), LC_ITEM(item->GetVnum())));
+				ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" : %s Ô¿ %s", owner->GetName(), LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+				owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s Îº %s", GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" : %s Ô¿ %s", owner->GetName(), LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+				owner->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s Îº %s", GetName(), LC_ITEM(item->GetVnum())));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" : %s Ô¿ %s", owner->GetName(), LC_ITEM(item->GetVnum())));
+#endif
+#endif
+			}
+
+			if (item->GetType() == ITEM_QUEST || IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE | ITEM_FLAG_QUEST_USE_MULTIPLE)
+				|| (item->GetType() == ITEM_PET && item->GetSubType() == PET_PAY))
+			{
+				quest::CQuestManager::instance().PickupItem(owner->GetPlayerID(), item);
+			}
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
+// Æ¼  Å©.. exp true msg Ï° return false Ï´ Å© (Ï¹ verify ëµµ return  à°£ Ý´ Ì¸ ò°¥¸  Ö°Ú´..)
+#define VERIFY_MSG(exp, msg) \
+	if (true == (exp)) \
+	{ \
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(msg)); \
+		return false; \
+	}
+
+bool CHARACTER::SwapItem(WORD wCell, WORD wDestCell)
+{
+	if (!CanHandleItem())
+		return false;
+
+	const TItemPos srcCell(INVENTORY, wCell), destCell(EQUIPMENT, wDestCell);
+
+	// Ã¹Ù¸ Cell  Ë»
+	// È¥ Swap  Ç·, â¼­ É¸.
+	//if (bCell >= INVENTORY_MAX_NUM + WEAR_MAX_NUM || bDestCell >= INVENTORY_MAX_NUM + WEAR_MAX_NUM)
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (srcCell.IsDragonSoulEquipPosition() || destCell.IsDragonSoulEquipPosition())
+		return false;
+#endif
+
+	//   Ã¢ Ä¡ Swap   .
+	if (srcCell.IsEquipPosition() && destCell.IsEquipPosition())
+		return false;
+
+	LPITEM item1 = nullptr, item2 = nullptr;
+
+	// item2 Ã¢ Ö´  Çµ.
+	if (srcCell.IsEquipPosition())
+	{
+		item1 = GetEquipmentItem(wDestCell);
+		item2 = GetInventoryItem(wCell);
+	}
+	else
+	{
+		item1 = GetInventoryItem(wCell);
+		item2 = GetEquipmentItem(wDestCell);
+	}
+
+	if (!item1 || !item2)
+		return false;
+
+	if (item1 == item2)
+	{
+		sys_log(0, "[WARNING][WARNING][HACK USER!] : %s %d %d", m_stName.c_str(), wCell, wDestCell);
+		return false;
+	}
+
+	// item2 bCellÄ¡ î°¥  Ö´ È®Ñ´.
+	if (!IsEmptyItemGrid(TItemPos(INVENTORY, item1->GetCell()), item2->GetSize(), item1->GetCell()))
+		return false;
+
+	// Ù²  Ã¢ 
+	if (TItemPos(EQUIPMENT, item2->GetCell()).IsEquipPosition())
+	{
+		const WORD wEquipCell = item2->GetCell();
+		const WORD wInvenCell = item1->GetCell();
+
+		// The item currently being worn can be removed, and the item planned to be worn
+		// must be in a wearable state in order to proceed.
+		if (!CanUnequipNow(item2, TItemPos(INVENTORY, wEquipCell)) || !CanEquipNow(item1))
+			return false;
+
+		if (wEquipCell != item1->FindEquipCell(this)) // When in the same location, it is only allowed
+			return false;
+
+		item2->RemoveFromCharacter();
+
+		if (item1->EquipTo(this, wEquipCell))
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			item2->AddToCharacter(this, TItemPos(INVENTORY, wInvenCell), false);
+#else
+			item2->AddToCharacter(this, TItemPos(INVENTORY, wInvenCell));
+#endif
+		else
+			sys_err("SwapItem cannot equip %s! item1 %s", item2->GetName(), item1->GetName());
+	}
+	else
+	{
+		const WORD wCell1 = item1->GetCell();
+		const WORD wCell2 = item2->GetCell();
+
+		item1->RemoveFromCharacter();
+		item2->RemoveFromCharacter();
+
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		item1->AddToCharacter(this, TItemPos(EQUIPMENT, wCell2), false);
+		item2->AddToCharacter(this, TItemPos(INVENTORY, wCell1), false);
+#else
+		item1->AddToCharacter(this, TItemPos(INVENTORY, wCell2));
+		item2->AddToCharacter(this, TItemPos(INVENTORY, wCell1));
+#endif
+	}
+
+	return true;
+}
+
+bool CHARACTER::UnequipItem(LPITEM item)
+{
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+	if (item->FindEquipCell(this) == WEAR_WEAPON)
+	{
+		LPITEM pCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
+		if (pCostumeWeapon)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
+			return false;
+		}
+	}
+#endif
+
+	if (false == CanUnequipNow(item))
+		return false;
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	if (item->IsCostumeMount() && item->IsEquipped())
+		UnMount();
+#endif
+
+	int pos;
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (item->IsDragonSoul())
+		pos = GetEmptyDragonSoulInventory(item);
+	else
+#endif
+		pos = GetEmptyInventory(item->GetSize());
+
+	// HARD CODING
+	if (item->GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
+		ShowAlignment(true);
+
+	item->RemoveFromCharacter();
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (item->IsDragonSoul())
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, pos), false);
+#else
+		item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, pos));
+#endif
+	else
+#endif
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+		item->AddToCharacter(this, TItemPos(INVENTORY, pos), false);
+#else
+		item->AddToCharacter(this, TItemPos(INVENTORY, pos));
+#endif
+
+	CheckMaximumPoints();
+
+	return true;
+}
+
+//
+// @version 05/07/05 Bang2ni - Skill  1.5  Ì³   
+//
+bool CHARACTER::EquipItem(LPITEM item, int iCandidateCell)
+{
+	if (item->IsExchanging())
+		return false;
+
+	if (false == item->IsEquipable())
+		return false;
+
+	if (false == CanEquipNow(item))
+		return false;
+
+	int iWearCell = item->FindEquipCell(this, iCandidateCell);
+
+	if (iWearCell < 0)
+		return false;
+
+	// ð°¡¸ Åº Â¿ Î½Ãµ Ô± 
+	if (iWearCell == WEAR_BODY && IsRiding() && (item->GetVnum() >= 11901 && item->GetVnum() <= 11904))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Åº Â¿    Ï´."));
+		return false;
+	}
+
+	if (iWearCell != WEAR_ARROW && IsPolymorphed())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ð° ß¿     Ï´."));
+		return false;
+	}
+
+	if (FN_check_item_sex(this, item) == false)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ê¾     Ï´."));
+		return false;
+	}
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+	DWORD dwTransmutationVnum = item->GetTransmutationVnum();
+	if (dwTransmutationVnum != 0)
+	{
+		TItemTable* pItemTable = ITEM_MANAGER::instance().GetTable(dwTransmutationVnum);
+
+		if (!pItemTable->CanUseByJob(GetJob()))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your class."));
+			return false;
+		}
+
+#	if defined(__COSTUME_SYSTEM__)
+		if (pItemTable && pItemTable->IsCostume())
+		{
+			if ((IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_MALE) && SEX_MALE == GET_SEX(this)) ||
+				(IS_SET(pItemTable->GetAntiFlags(), ITEM_ANTIFLAG_FEMALE) && SEX_FEMALE == GET_SEX(this)))
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Transmutation] You cannot equip the transmuted item as it does not match your gender."));
+				return false;
+			}
+		}
+	}
+#	endif
+#endif
+
+	// Å± Å»    ë¿© Ã¼Å©
+	if (item->IsRideItem())
+	{
+		if (IsRiding())
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ Å» Ì¿Ô´Ï´."));
+			return false;
+		}
+
+		if (IsPolymorphed())
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Â¿  Å»  Ï´."));
+			return false;
+		}
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+		if (item->IsRideItem())
+		{
+			DWORD dwMountVnum = item->GetMountVnum();
+			if (dwMountVnum > 0 && FindAffect(AFFECT_MOUNT_FALL) == NULL)
+				MountVnum(dwMountVnum);
+		}
+#endif
+	}
+
+	// È­ Ì¿Ü¿   Ã° Ç´ Å³  1.5 Ä¿  Ã¼ 
+	DWORD dwCurTime = get_dword_time();
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	if (iWearCell != WEAR_ARROW && iWearCell != WEAR_COSTUME_MOUNT
+		&& (dwCurTime - GetLastAttackTime() <= 1500 || dwCurTime - m_dwLastSkillTime <= 1500))
+#else
+	if (iWearCell != WEAR_ARROW
+		&& (dwCurTime - GetLastAttackTime() <= 1500 || dwCurTime - m_dwLastSkillTime <= 1500))
+#endif
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("     Ö½Ï´."));
+		return false;
+	}
+
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+	if (iWearCell == WEAR_WEAPON)
+	{
+		if (item->GetType() == ITEM_WEAPON)
+		{
+			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
+			if (pkCostumeWeapon && pkCostumeWeapon->GetValue(3) != item->GetSubType())
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
+				return false;
+			}
+		}
+		else
+		{
+			LPITEM pkCostumeWeapon = GetWear(WEAR_COSTUME_WEAPON);
+			if (pkCostumeWeapon)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("If you want to change weapons, you must remove the weapon skin first."));
+				return false;
+			}
+		}
+	}
+	else if (iWearCell == WEAR_COSTUME_WEAPON)
+	{
+		if (item->GetType() == ITEM_COSTUME && item->GetSubType() == COSTUME_WEAPON)
+		{
+			LPITEM pkWeapon = GetWear(WEAR_WEAPON);
+			if (!pkWeapon)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You need to equip a weapon first."));
+				return false;
+			}
+			else if (pkWeapon->GetType() != ITEM_WEAPON || item->GetValue(3) != pkWeapon->GetSubType())
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use this costume for this weapon."));
+				return false;
+			}
+		}
+	}
+#endif
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	// È¥ Æ¯ Ã³
+	if (item->IsDragonSoul())
+	{
+		//  Å¸ È¥ Ì¹ î°¡ Ö´Ù¸   .
+		// È¥ swap Ï¸ Èµ.
+		if (GetEquipmentItem(iWearCell))
+		{
+			ChatPacket(CHAT_TYPE_INFO, "Ì¹   È¥ Ï° Ö½Ï´.");
+			return false;
+		}
+
+		if (!item->EquipTo(this, iWearCell))
+		{
+			return false;
+		}
+	}
+	// È¥ Æ´.
+	else
+#endif
+	{
+		//    Ö´Ù¸,
+		if (GetWear(iWearCell) && !IS_SET(GetWear(iWearCell)->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+		{
+			//   Ñ¹   Ò°. swap   Ò°
+			//if (item->GetWearFlag() == WEARABLE_ABILITY)
+			//	return false;
+
+			if (!SwapItem(item->GetCell(), iWearCell))
+				return false;
+		}
+		else
+		{
+			BYTE bOldCell = item->GetCell();
+
+			if (item->EquipTo(this, iWearCell))
+				SyncQuickslot(SLOT_TYPE_INVENTORY, bOldCell, iWearCell);
+		}
+	}
+
+	if (true == item->IsEquipped())
+	{
+		//    ÄºÍ´  Ê¾Æµ Ã° Ç´  Ã³.
+		if (-1 != item->GetProto()->cLimitRealTimeFirstUseIndex)
+		{
+			//  Ì¶   Î´ Socket1  Ç´Ñ´. (Socket1 È½ )
+			if (0 == item->GetSocket(1))
+			{
+				// ë°¡É½Ã° Default  Limit Value  Ïµ, Socket0     Ïµ Ñ´. ( )
+				long duration = (0 != item->GetSocket(0)) ? item->GetSocket(0) : item->GetProto()->aLimits[(BYTE)item->GetProto()->cLimitRealTimeFirstUseIndex].lValue;
+
+				if (0 == duration)
+					duration = 60 * 60 * 24 * 7;
+
+				item->SetSocket(0, time(0) + duration);
+				item->StartRealTimeExpireEvent();
+			}
+
+			item->SetSocket(1, item->GetSocket(1) + 1);
+		}
+
+		if (item->GetVnum() == UNIQUE_ITEM_HIDE_ALIGNMENT_TITLE)
+			ShowAlignment(false);
+
+		if (item->IsRing() || item->IsCostume()
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+			&& !item->IsCostumeMount()
+#endif
+			)
+			ChatPacket(CHAT_TYPE_COMMAND, "OpenCostumeWindow");
+
+		const DWORD& dwVnum = item->GetVnum();
+
+		// ó¸¶´ ÌºÆ® Ê½Â´ (71135)  Æ® ßµ
+		if (true == CItemVnumHelper::IsRamadanMoonRing(dwVnum))
+		{
+			this->EffectPacket(SE_EQUIP_RAMADAN_RING);
+		}
+		// Ò· (71136)  Æ® ßµ
+		else if (true == CItemVnumHelper::IsHalloweenCandy(dwVnum))
+		{
+			this->EffectPacket(SE_EQUIP_HALLOWEEN_CANDY);
+		}
+		// àº¹ (71143)  Æ® ßµ
+		else if (true == CItemVnumHelper::IsHappinessRing(dwVnum))
+		{
+			this->EffectPacket(SE_EQUIP_HAPPINESS_RING);
+		}
+		//  Ò´Æ®(71145)  Æ® ßµ
+		else if (true == CItemVnumHelper::IsLovePendant(dwVnum))
+		{
+			this->EffectPacket(SE_EQUIP_LOVE_PENDANT);
+		}
+		// ITEM_UNIQUE , SpecialItemGroup ÇµÇ¾ Ö°, (item->GetSIGVnum() != NULL)
+		//
+		else if ((ITEM_UNIQUE == item->GetType() || ITEM_RING == item->GetType()) && 0 != item->GetSIGVnum())
+		{
+			const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(item->GetSIGVnum());
+			if (NULL != pGroup)
+			{
+				const CSpecialAttrGroup* pAttrGroup = ITEM_MANAGER::instance().GetSpecialAttrGroup(pGroup->GetAttrVnum(item->GetVnum()));
+				if (NULL != pAttrGroup)
+				{
+					const std::string& std = pAttrGroup->m_stEffectFileName;
+					SpecificEffectPacket(std.c_str());
+				}
+			}
+		}
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		if ((item->GetType() == ITEM_COSTUME) && (item->GetSubType() == COSTUME_ACCE
+#if defined(__AURA_COSTUME_SYSTEM__)
+			|| item->GetSubType() == COSTUME_AURA
+#endif
+			))
+		{
+			if (item->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) > 18)
+				this->EffectPacket(SE_ACCE_BACK);
+			this->EffectPacket(SE_ACCE_EQUIP);
+		}
+#endif
+
+		if ((ITEM_UNIQUE == item->GetType() && UNIQUE_SPECIAL_RIDE == item->GetSubType() && IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_USE))
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+			|| (ITEM_COSTUME == item->GetType() && COSTUME_MOUNT == item->GetSubType())
+#endif
+			)
+		{
+			quest::CQuestManager::instance().UseItem(GetPlayerID(), item, false);
+		}
+	}
+
+	return true;
+}
+
+void CHARACTER::BuffOnAttr_AddBuffsFromItem(LPITEM pItem)
+{
+	for (int i = 0; i < sizeof(g_aBuffOnAttrPoints) / sizeof(g_aBuffOnAttrPoints[0]); i++)
+	{
+		TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(g_aBuffOnAttrPoints[i]);
+		if (it != m_map_buff_on_attrs.end())
+		{
+			it->second->AddBuffFromItem(pItem);
+		}
+	}
+}
+
+void CHARACTER::BuffOnAttr_RemoveBuffsFromItem(LPITEM pItem)
+{
+	for (int i = 0; i < sizeof(g_aBuffOnAttrPoints) / sizeof(g_aBuffOnAttrPoints[0]); i++)
+	{
+		TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(g_aBuffOnAttrPoints[i]);
+		if (it != m_map_buff_on_attrs.end())
+		{
+			it->second->RemoveBuffFromItem(pItem);
+		}
+	}
+}
+
+void CHARACTER::BuffOnAttr_ClearAll()
+{
+	for (TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.begin(); it != m_map_buff_on_attrs.end(); ++it)
+	{
+		CBuffOnAttributes* pBuff = it->second;
+		if (pBuff)
+		{
+			pBuff->Initialize();
+		}
+	}
+}
+
+void CHARACTER::BuffOnAttr_ValueChange(POINT_TYPE wPointType, POINT_VALUE llOldValue, POINT_VALUE lNewValue)
+{
+	TMapBuffOnAttrs::iterator it = m_map_buff_on_attrs.find(wPointType);
+
+	if (0 == lNewValue)
+	{
+		if (m_map_buff_on_attrs.end() == it)
+			return;
+		else
+			it->second->Off();
+	}
+	else if (0 == llOldValue)
+	{
+		CBuffOnAttributes* pBuff;
+		if (m_map_buff_on_attrs.end() == it)
+		{
+			switch (wPointType)
+			{
+				case POINT_ENERGY:
+				{
+					static BYTE s_abSlot[] = {
+						WEAR_BODY,
+						WEAR_HEAD,
+						WEAR_FOOTS,
+						WEAR_WRIST,
+						WEAR_WEAPON,
+						WEAR_NECK,
+						WEAR_EAR,
+						WEAR_SHIELD,
+#if defined(__PENDANT_SYSTEM__)
+						WEAR_PENDANT,
+#endif
+#if defined(__GLOVE_SYSTEM__)
+						WEAR_GLOVE,
+#endif
+					};
+					static std::vector<POINT_TYPE> s_vSlots(s_abSlot, s_abSlot + _countof(s_abSlot));
+					pBuff = M2_NEW CBuffOnAttributes(this, wPointType, &s_vSlots);
+				}
+				break;
+
+				case POINT_COSTUME_ATTR_BONUS:
+				{
+					static BYTE s_abSlot[] = {
+						WEAR_COSTUME_BODY,
+						WEAR_COSTUME_HAIR,
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+						WEAR_COSTUME_WEAPON,
+#endif
+					};
+					static std::vector<POINT_TYPE> s_vSlots(s_abSlot, s_abSlot + _countof(s_abSlot));
+					pBuff = M2_NEW CBuffOnAttributes(this, wPointType, &s_vSlots);
+				}
+				break;
+
+				default:
+					break;
+
+			}
+			m_map_buff_on_attrs.insert(TMapBuffOnAttrs::value_type(wPointType, pBuff));
+
+		}
+		else
+			pBuff = it->second;
+
+		pBuff->On(lNewValue);
+	}
+	else
+	{
+		if (m_map_buff_on_attrs.end() == it)
+			return;
+		else
+			it->second->ChangeBuffValue(lNewValue);
+	}
+}
+
+LPITEM CHARACTER::FindSpecifyItem(DWORD dwVnum
+#if defined(__SOUL_BIND_SYSTEM__)
+	, bool bIgnoreSoulBound
+#endif
+#if defined(__SET_ITEM__)
+	, bool bIgnoreSetValue
+#endif
+) const
+{
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+	{
+		if (GetInventoryItem(i) && GetInventoryItem(i)->GetVnum() == dwVnum)
+		{
+#if defined(__SOUL_BIND_SYSTEM__)
+			if (bIgnoreSoulBound && GetInventoryItem(i)->IsSealed())
+				continue;
+#endif
+
+#if defined(__SET_ITEM__)
+			if (bIgnoreSetValue && GetInventoryItem(i)->GetItemSetValue())
+				continue;
+#endif
+			return GetInventoryItem(i);
+		}
+	}
+	return NULL;
+}
+
+LPITEM CHARACTER::FindItemByID(DWORD id) const
+{
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (WORD wCell = 0; wCell < GetExtendInvenMax(); ++wCell)
+#else
+	for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
+#endif
+		if (GetInventoryItem(wCell) && GetInventoryItem(wCell)->GetID() == id)
+			return GetInventoryItem(wCell);
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	for (WORD wCell = 0; wCell < DRAGON_SOUL_INVENTORY_MAX_NUM; ++wCell)
+		if (GetDragonSoulInventoryItem(wCell) && GetDragonSoulInventoryItem(wCell)->GetID() == id)
+			return GetDragonSoulInventoryItem(wCell);
+#endif
+
+	for (WORD wCell = 0; wCell < BELT_INVENTORY_MAX_NUM; ++wCell)
+		if (GetBeltInventoryItem(wCell) && GetBeltInventoryItem(wCell)->GetID() == id)
+			return GetBeltInventoryItem(wCell);
+
+	return NULL;
+}
+
+int CHARACTER::CountSpecifyItem(DWORD vnum, int iExceptionCell
+#if defined(__SOUL_BIND_SYSTEM__)
+	, bool bIgnoreSealedItem
+#endif
+#if defined(__SET_ITEM__)
+	, bool bIgnoreSetValue
+#endif
+) const
+{
+	int iCount = 0;
+	LPITEM pItem = nullptr;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (WORD wCell = 0; wCell < GetExtendInvenMax(); ++wCell)
+#else
+	for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
+#endif
+	{
+		if (wCell == iExceptionCell)
+			continue;
+
+		pItem = GetInventoryItem(wCell);
+		if (pItem && pItem->GetVnum() == vnum)
+		{
+			//   Ïµ Ì¸ Ñ¾î°£.
+			if (m_pkMyShop && m_pkMyShop->IsSellingItem(pItem->GetID()))
+				continue;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+			if (bIgnoreSealedItem && pItem->IsSealed())
+				continue;
+#endif
+
+#if defined(__SET_ITEM__)
+			if (bIgnoreSetValue && pItem->GetItemSetValue())
+				continue;
+#endif
+
+			iCount += pItem->GetCount();
+		}
+	}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	for (WORD wCell = 0; wCell < DRAGON_SOUL_INVENTORY_MAX_NUM; ++wCell)
+	{
+		pItem = GetDragonSoulInventoryItem(wCell);
+		if (pItem && pItem->GetVnum() == vnum)
+		{
+#if defined(__SOUL_BIND_SYSTEM__)
+			if (bIgnoreSealedItem && pItem->IsSealed())
+				continue;
+#endif
+
+			iCount += pItem->GetCount();
+		}
+	}
+#endif
+
+	return iCount;
+}
+
+void CHARACTER::RemoveSpecifyItem(DWORD vnum, DWORD count, int iExceptionCell
+#if defined(__SOUL_BIND_SYSTEM__)
+	, bool bIgnoreSealedItem
+#endif
+#if defined(__SET_ITEM__)
+	, bool bIgnoreSetValue
+#endif
+)
+{
+	if (0 == count)
+		return;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (UINT i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (UINT i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+	{
+		if (i == iExceptionCell)
+			continue;
+
+		if (NULL == GetInventoryItem(i))
+			continue;
+
+		if (GetInventoryItem(i)->GetVnum() != vnum)
+			continue;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+		if (bIgnoreSealedItem && GetInventoryItem(i)->IsSealed())
+			continue;
+#endif
+
+#if defined(__SET_ITEM__)
+		if (bIgnoreSetValue && GetInventoryItem(i)->GetItemSetValue())
+			continue;
+#endif
+
+		//  Ïµ Ì¸ Ñ¾î°£. (  Ç¸ÅµÉ¶  Îº   !)
+		if (m_pkMyShop)
+		{
+			bool isItemSelling = m_pkMyShop->IsSellingItem(GetInventoryItem(i)->GetID());
+			if (isItemSelling)
+				continue;
+		}
+
+		if (vnum >= 80003 && vnum <= 80007)
+			LogManager::instance().GoldBarLog(GetPlayerID(), GetInventoryItem(i)->GetID(), QUEST, "RemoveSpecifyItem");
+
+		if (count >= GetInventoryItem(i)->GetCount())
+		{
+			count -= GetInventoryItem(i)->GetCount();
+			GetInventoryItem(i)->SetCount(0);
+
+			if (0 == count)
+				return;
+		}
+		else
+		{
+			GetInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
+			return;
+		}
+	}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	for (UINT i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
+	{
+		if (NULL == GetDragonSoulInventoryItem(i))
+			continue;
+
+		if (GetDragonSoulInventoryItem(i)->GetVnum() != vnum)
+			continue;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+		if (bIgnoreSealedItem && GetDragonSoulInventoryItem(i)->IsSealed())
+			continue;
+#endif
+
+#if defined(__SET_ITEM__)
+		if (bIgnoreSetValue && GetDragonSoulInventoryItem(i)->GetItemSetValue())
+			continue;
+#endif
+
+		if (count >= GetDragonSoulInventoryItem(i)->GetCount())
+		{
+			count -= GetDragonSoulInventoryItem(i)->GetCount();
+			GetDragonSoulInventoryItem(i)->SetCount(0);
+
+			if (0 == count)
+				return;
+		}
+		else
+		{
+			GetDragonSoulInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
+			return;
+		}
+	}
+#endif
+
+	// Ã³ Ï´.
+	if (count)
+		sys_log(0, "CHARACTER::RemoveSpecifyItem cannot remove enough item vnum %u, still remain %d", vnum, count);
+}
+
+int CHARACTER::CountSpecifyTypeItem(BYTE type) const
+{
+	int count = 0;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (int i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+	{
+		LPITEM pItem = GetInventoryItem(i);
+		if (pItem != NULL && pItem->GetType() == type)
+		{
+			count += pItem->GetCount();
+		}
+	}
+
+	return count;
+}
+
+void CHARACTER::RemoveSpecifyTypeItem(BYTE type, DWORD count)
+{
+	if (0 == count)
+		return;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (UINT i = 0; i < GetExtendInvenMax(); ++i)
+#else
+	for (UINT i = 0; i < INVENTORY_MAX_NUM; ++i)
+#endif
+	{
+		if (NULL == GetInventoryItem(i))
+			continue;
+
+		if (GetInventoryItem(i)->GetType() != type)
+			continue;
+
+		//  Ïµ Ì¸ Ñ¾î°£. (  Ç¸ÅµÉ¶  Îº   !)
+		if (m_pkMyShop)
+		{
+			bool isItemSelling = m_pkMyShop->IsSellingItem(GetInventoryItem(i)->GetID());
+			if (isItemSelling)
+				continue;
+		}
+
+		if (count >= GetInventoryItem(i)->GetCount())
+		{
+			count -= GetInventoryItem(i)->GetCount();
+			GetInventoryItem(i)->SetCount(0);
+
+			if (0 == count)
+				return;
+		}
+		else
+		{
+			GetInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
+			return;
+		}
+	}
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	for (UINT i = 0; i < DRAGON_SOUL_INVENTORY_MAX_NUM; ++i)
+	{
+		if (NULL == GetDragonSoulInventoryItem(i))
+			continue;
+
+		if (GetDragonSoulInventoryItem(i)->GetType() != type)
+			continue;
+
+		if (count >= GetDragonSoulInventoryItem(i)->GetCount())
+		{
+			count -= GetDragonSoulInventoryItem(i)->GetCount();
+			GetDragonSoulInventoryItem(i)->SetCount(0);
+
+			if (0 == count)
+				return;
+		}
+		else
+		{
+			GetDragonSoulInventoryItem(i)->SetCount(GetInventoryItem(i)->GetCount() - count);
+			return;
+		}
+	}
+#endif
+}
+
+// 20200808.Owsap : Fix book stacking while sorting.
+void CHARACTER::GiveSkillBook(DWORD dwSkillVnum, WORD wCount)
+{
+	for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+	{
+		LPITEM pkItem = GetInventoryItem(i);
+
+		if (!pkItem)
+			continue;
+
+		if ((pkItem->GetType() == ITEM_SKILLBOOK || pkItem->GetType() == ITEM_SKILLFORGET) && pkItem->GetSocket(0) == dwSkillVnum)
+		{
+			WORD wCount2 = MIN(ITEM_MAX_COUNT - pkItem->GetCount(), wCount);
+			wCount -= wCount2;
+
+			pkItem->SetCount(pkItem->GetCount() + wCount2);
+			if (wCount == 0)
+				return;
+		}
+	}
+
+	LPITEM pkBookItem = AutoGiveItem(ITEM_SKILLBOOK_VNUM, wCount, false, false);
+	if (NULL != pkBookItem)
+		pkBookItem->SetSocket(0, dwSkillVnum);
+}
+//>
+
+LPITEM CHARACTER::AutoGiveItem(DWORD dwItemVnum, WORD wCount, int iRarePct, bool bMsg
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+	, bool isHighLight
+#endif
+#if defined(__NEW_USER_CARE__)
+	, bool bSystemDrop
+#endif
+)
+{
+	TItemTable* p = ITEM_MANAGER::instance().GetTable(dwItemVnum);
+	if (!p)
+		return NULL;
+
+	DBManager::instance().SendMoneyLog(MONEY_LOG_DROP, dwItemVnum, wCount);
+
+	if (p->dwFlags & ITEM_FLAG_STACKABLE/* && p->bType != ITEM_BLEND*/)
+	{
+		for (int i = 0; i < INVENTORY_MAX_NUM; ++i)
+		{
+			LPITEM item = GetInventoryItem(i);
+
+			if (!item)
+				continue;
+
+			if (item->GetVnum() == dwItemVnum && FN_check_item_socket(item))
+			{
+				if (IS_SET(p->dwFlags, ITEM_FLAG_MAKECOUNT))
+				{
+					if (wCount < p->alValues[1])
+						wCount = p->alValues[1];
+				}
+
+				WORD wCount2 = MIN(ITEM_MAX_COUNT - item->GetCount(), wCount);
+				wCount -= wCount2;
+
+				item->SetCount(item->GetCount() + wCount2);
+
+				if (wCount == 0)
+				{
+					if (bMsg)
+					{
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#	if defined(__SET_ITEM__)
+						ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#	else
+						ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#	endif
+#else
+#	if defined(__SET_ITEM__)
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#	else
+						ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#	endif
+#endif
+					}
+
+					return item;
+				}
+			}
+		}
+	}
+
+	LPITEM item = ITEM_MANAGER::instance().CreateItem(dwItemVnum, wCount, 0, true);
+
+	if (!item)
+	{
+		sys_err("cannot create item by vnum %u (name: %s)", dwItemVnum, GetName());
+		return NULL;
+	}
+
+	if (item->GetType() == ITEM_BLEND)
+	{
+		for (int i = 0; i < INVENTORY_MAX_NUM; i++)
+		{
+			LPITEM inv_item = GetInventoryItem(i);
+
+			if (inv_item == NULL)
+				continue;
+
+			if (inv_item->GetType() == ITEM_BLEND)
+			{
+				if (inv_item->GetVnum() == item->GetVnum())
+				{
+					if (inv_item->GetSocket(0) == item->GetSocket(0) &&
+						inv_item->GetSocket(1) == item->GetSocket(1) &&
+						inv_item->GetSocket(2) == item->GetSocket(2) &&
+						inv_item->GetCount() + item->GetCount() <= ITEM_MAX_COUNT)
+					{
+						inv_item->SetCount(inv_item->GetCount() + item->GetCount());
+						M2_DESTROY_ITEM(item);
+						return inv_item;
+					}
+				}
+			}
+		}
+	}
+
+	int iEmptyCell;
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (item->IsDragonSoul())
+		iEmptyCell = GetEmptyDragonSoulInventory(item);
+	else
+#endif
+		iEmptyCell = GetEmptyInventory(item->GetSize());
+
+	if (iEmptyCell != -1)
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+			item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, iEmptyCell));
+		else
+#endif
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell), isHighLight);
+#else
+			item->AddToCharacter(this, TItemPos(INVENTORY, iEmptyCell));
+#endif
+
+		if (bMsg)
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#endif
+#endif
+
+		LogManager::instance().ItemLog(this, item, "SYSTEM", item->GetName());
+
+		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_POTION)
+		{
+			TQuickslot* pSlot;
+
+			if (GetQuickslot(0, &pSlot) && pSlot->type == SLOT_TYPE_NONE)
+			{
+				TQuickslot slot;
+				slot.type = SLOT_TYPE_INVENTORY;
+				slot.pos = iEmptyCell;
+				SetQuickslot(0, slot);
+			}
+		}
+	}
+	else
+	{
+#if defined(__NEW_USER_CARE__)
+		if (!bSystemDrop)
+		{
+			sys_log(0, "AutoGiveItem: No inventory space, SystemDrop disabled!");
+
+			M2_DESTROY_ITEM(item);
+			return NULL;
+		}
+#endif
+
+		item->AddToGround(GetMapIndex(), GetXYZ());
+		item->StartDestroyEvent();
+		// Æ¼  flag É·Ö´  ,
+		// Îº   î¼­ Â¿   Æ® Ç¸,
+		// ownership   (300) Ñ´.
+		if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_DROP))
+			item->SetOwnership(this, 300);
+		else
+			item->SetOwnership(this, 60);
+
+		LogManager::instance().ItemLog(this, item, "SYSTEM_DROP", item->GetName());
+	}
+
+	sys_log(0, "7: %d %d", dwItemVnum, wCount);
+	return item;
+}
+
+#define __AUTO_GIVE_ITEM_STACK__
+void CHARACTER::AutoGiveItem(LPITEM item, bool longOwnerShip, bool bMsg
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+	, bool isHighLight
+#endif
+)
+{
+	if (NULL == item)
+	{
+		sys_err("NULL point.");
+		return;
+	}
+
+	if (item->GetOwner())
+	{
+		sys_err("item %d 's owner exists!", item->GetID());
+		return;
+	}
+
+#if defined(__AUTO_GIVE_ITEM_STACK__)
+	if (item->IsStackable() && !IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_STACK))
+	{
+		for (WORD i = 0; i < INVENTORY_MAX_NUM; ++i)
+		{
+			LPITEM item2 = GetInventoryItem(i);
+			if (!item2)
+				continue;
+
+			if (item2->GetVnum() != item->GetVnum())
+				continue;
+
+			BYTE j = 0;
+			for (; j < ITEM_SOCKET_MAX_NUM; ++j)
+				if (item2->GetSocket(j) != item->GetSocket(j))
+					break;
+
+			if (j != ITEM_SOCKET_MAX_NUM)
+				continue;
+
+			if (item2->GetCount() >= ITEM_MAX_COUNT)
+				continue;
+
+			WORD wCount = item->GetCount();
+			if (IS_SET(item->GetFlag(), ITEM_FLAG_MAKECOUNT))
+			{
+				if (wCount < item->GetValue(1))
+					wCount = item->GetValue(1);
+			}
+
+			WORD wCount2 = MIN(ITEM_MAX_COUNT - item2->GetCount(), wCount);
+			wCount -= wCount2;
+			item2->SetCount(item2->GetCount() + wCount2);
+
+			if (wCount == 0)
+			{
+				if (bMsg)
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+					ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+					ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#endif
+#endif
+
+				M2_DESTROY_ITEM(item);
+
+				return;
+			}
+
+			item->SetCount(wCount);
+		}
+	}
+#endif
+
+	int cell;
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (item->IsDragonSoul())
+	{
+		cell = GetEmptyDragonSoulInventory(item);
+	}
+	else
+#endif
+	{
+		cell = GetEmptyInventory(item->GetSize());
+	}
+
+	if (cell != -1)
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+			item->AddToCharacter(this, TItemPos(DRAGON_SOUL_INVENTORY, cell));
+		else
+#endif
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			item->AddToCharacter(this, TItemPos(INVENTORY, cell), isHighLight);
+#else
+			item->AddToCharacter(this, TItemPos(INVENTORY, cell));
+#endif
+
+		if (bMsg)
+#if defined(__CHATTING_WINDOW_RENEWAL__)
+#if defined(__SET_ITEM__)
+			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+			ChatPacket(CHAT_TYPE_ITEM_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#endif
+#else
+#if defined(__SET_ITEM__)
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_PRE_ITEM(item->GetItemSetValue(), item->GetVnum())));
+#else
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING(" È¹: %s", LC_ITEM(item->GetVnum())));
+#endif
+#endif
+
+		LogManager::instance().ItemLog(this, item, "SYSTEM", item->GetName());
+
+		if (item->GetType() == ITEM_USE && item->GetSubType() == USE_POTION)
+		{
+			TQuickslot* pSlot;
+
+			if (GetQuickslot(0, &pSlot) && pSlot->type == SLOT_TYPE_NONE)
+			{
+				TQuickslot slot;
+				slot.type = SLOT_TYPE_INVENTORY;
+				slot.pos = cell;
+				SetQuickslot(0, slot);
+			}
+		}
+	}
+	else
+	{
+		item->AddToGround(GetMapIndex(), GetXYZ());
+		item->StartDestroyEvent();
+
+		if (longOwnerShip)
+			item->SetOwnership(this, 300);
+		else
+			item->SetOwnership(this, 60);
+
+		LogManager::instance().ItemLog(this, item, "SYSTEM_DROP", item->GetName());
+	}
+}
+
+bool CHARACTER::GiveItem(LPCHARACTER victim, TItemPos Cell)
+{
+	if (!CanHandleItem())
+		return false;
+
+	if (IsRunningQuest())
+		return false;
+
+	LPITEM item = GetItem(Cell);
+	if (item && !item->IsExchanging())
+	{
+		if (victim->CanReceiveItem(this, item))
+		{
+			victim->ReceiveItem(this, item);
+			return true;
+		}
+	}
+
+	return false;
+}
+
+bool CHARACTER::CanReceiveItem(LPCHARACTER from, LPITEM item) const
+{
+	if (IsPC())
+		return false;
+
+	// TOO_LONG_DISTANCE_EXCHANGE_BUG_FIX
+	if (DISTANCE_APPROX(GetX() - from->GetX(), GetY() - from->GetY()) > 2000)
+		return false;
+	// END_OF_TOO_LONG_DISTANCE_EXCHANGE_BUG_FIX
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (item->IsSealed())
+	{
+		from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot improve a soulbound item."));
+		return false;
+	}
+#endif
+
+	switch (GetRaceNum())
+	{
+		case fishing::CAMPFIRE_MOB:
+		{
+			if (item->GetType() == ITEM_FISH &&
+				(item->GetSubType() == FISH_ALIVE || item->GetSubType() == FISH_DEAD))
+				return true;
+		}
+		break;
+
+		case fishing::FISHER_MOB:
+		{
+			if (item->GetType() == ITEM_ROD)
+				return true;
+		}
+		break;
+
+		// BUILDING_NPC
+		case BLACKSMITH_WEAPON_MOB:
+		case DEVILTOWER_BLACKSMITH_WEAPON_MOB:
+		{
+			if (item->GetType() == ITEM_WEAPON &&
+				item->GetRefinedVnum())
+				return true;
+			else
+				return false;
+		}
+		break;
+
+		case BLACKSMITH_ARMOR_MOB:
+		case DEVILTOWER_BLACKSMITH_ARMOR_MOB:
+		{
+			if (item->GetType() == ITEM_ARMOR &&
+				(item->GetSubType() == ARMOR_BODY || item->GetSubType() == ARMOR_SHIELD || item->GetSubType() == ARMOR_HEAD) &&
+				item->GetRefinedVnum())
+				return true;
+			else
+				return false;
+		}
+		break;
+
+		case BLACKSMITH_ACCESSORY_MOB:
+		case DEVILTOWER_BLACKSMITH_ACCESSORY_MOB:
+		{
+			if (item->GetType() == ITEM_ARMOR &&
+				!(item->GetSubType() == ARMOR_BODY || item->GetSubType() == ARMOR_SHIELD || item->GetSubType() == ARMOR_HEAD) &&
+				item->GetRefinedVnum())
+				return true;
+			else
+				return false;
+		}
+		break;
+		// END_OF_BUILDING_NPC
+
+		case BLACKSMITH_MOB:
+		{
+			if (item->GetRefinedVnum() && item->GetRefineSet() < 500)
+				return true;
+			else
+				return false;
+		}
+		break;
+
+		case BLACKSMITH2_MOB:
+		{
+			if (item->GetRefineSet() >= 500)
+				return true;
+			else
+				return false;
+		}
+		break;
+
+		case ALCHEMIST_MOB:
+		{
+			if (item->GetRefinedVnum())
+				return true;
+		}
+		break;
+
+		case 20101:
+		case 20102:
+		case 20103:
+		{
+			// Ê± 
+			if (item->GetVnum() == ITEM_REVIVE_HORSE_1)
+			{
+				if (!IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Ê¸   Ï´."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_1)
+			{
+				if (IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  á¸¦   Ï´."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_2 || item->GetVnum() == ITEM_HORSE_FOOD_3)
+			{
+				return false;
+			}
+		}
+		break;
+
+		case 20104:
+		case 20105:
+		case 20106:
+		{
+			// ß± 
+			if (item->GetVnum() == ITEM_REVIVE_HORSE_2)
+			{
+				if (!IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Ê¸   Ï´."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_2)
+			{
+				if (IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  á¸¦   Ï´."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 || item->GetVnum() == ITEM_HORSE_FOOD_3)
+			{
+				return false;
+			}
+		}
+		break;
+
+		case 20107:
+		case 20108:
+		case 20109:
+		{
+			//  
+			if (item->GetVnum() == ITEM_REVIVE_HORSE_3)
+			{
+				if (!IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Ê¸   Ï´."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_3)
+			{
+				if (IsDead())
+				{
+					from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  á¸¦   Ï´."));
+					return false;
+				}
+				return true;
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 || item->GetVnum() == ITEM_HORSE_FOOD_2)
+			{
+				return false;
+			}
+		}
+		break;
+
+		default:
+			break;
+	}
+
+	//if (IS_SET(item->GetFlag(), ITEM_FLAG_QUEST_GIVE))
+	{
+		return true;
+	}
+
+	return false;
+}
+
+void CHARACTER::ReceiveItem(LPCHARACTER from, LPITEM item)
+{
+	if (IsPC())
+		return;
+
+	switch (GetRaceNum())
+	{
+		case fishing::CAMPFIRE_MOB:
+		{
+			if (item->GetType() == ITEM_FISH && (item->GetSubType() == FISH_ALIVE || item->GetSubType() == FISH_DEAD))
+				fishing::Grill(from, item);
+			else
+			{
+				// TAKE_ITEM_BUG_FIX
+				from->SetQuestNPCID(GetVID());
+				// END_OF_TAKE_ITEM_BUG_FIX
+				quest::CQuestManager::instance().TakeItem(from->GetPlayerID(), GetRaceNum(), item);
+			}
+		}
+		break;
+
+#ifdef ENABLE_QUEEN_NETHIS
+		case SnakeLair::PILAR_STEP_4:
+			{
+				if(from->IsPC())
+				{
+					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
+						SnakeLair::CSnk::instance().OnKillPilar(item, from, this);
+				}
+			}
+			break;
+		case SnakeLair::BLACKSMITH_5:
+			{
+				if(from->IsPC())
+				{
+					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
+						SnakeLair::CSnk::instance().OnKillBlackSmith(item, from, this);
+				}
+			}
+			break;
+
+		case SnakeLair::SNAKE_STATUE1:
+		case SnakeLair::SNAKE_STATUE2:
+		case SnakeLair::SNAKE_STATUE3:
+		case SnakeLair::SNAKE_STATUE4:
+			{
+				if(from->IsPC())
+				{
+					if (SnakeLair::CSnk::instance().IsSnakeMap(from->GetMapIndex()))
+						SnakeLair::CSnk::instance().OnStatueSetRotation(item, from, this);
+				}
+			}
+			break;
+#endif
+
+		// DEVILTOWER_NPC
+		case DEVILTOWER_BLACKSMITH_WEAPON_MOB:
+		case DEVILTOWER_BLACKSMITH_ARMOR_MOB:
+		case DEVILTOWER_BLACKSMITH_ACCESSORY_MOB:
+		{
+			if (item->GetRefinedVnum() != 0 && item->GetRefineSet() != 0 && item->GetRefineSet() < 500)
+			{
+				from->SetRefineNPC(this);
+				from->RefineInformation(item->GetCell(), REFINE_TYPE_MONEY_ONLY);
+			}
+			else
+			{
+				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+			}
+		}
+		break;
+		// END_OF_DEVILTOWER_NPC
+
+		case BLACKSMITH_MOB:
+		case BLACKSMITH2_MOB:
+		case BLACKSMITH_WEAPON_MOB:
+		case BLACKSMITH_ARMOR_MOB:
+		case BLACKSMITH_ACCESSORY_MOB:
+		{
+			if (item->GetRefinedVnum())
+			{
+				from->SetRefineNPC(this);
+				from->RefineInformation(item->GetCell(), REFINE_TYPE_NORMAL);
+			}
+			else
+			{
+				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+			}
+		}
+		break;
+
+		case 20101:
+		case 20102:
+		case 20103:
+		case 20104:
+		case 20105:
+		case 20106:
+		case 20107:
+		case 20108:
+		case 20109:
+		{
+			if (item->GetVnum() == ITEM_REVIVE_HORSE_1 ||
+				item->GetVnum() == ITEM_REVIVE_HORSE_2 ||
+				item->GetVnum() == ITEM_REVIVE_HORSE_3)
+			{
+				from->ReviveHorse();
+				item->SetCount(item->GetCount() - 1);
+				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ê¸ Ö¾Ï´."));
+			}
+			else if (item->GetVnum() == ITEM_HORSE_FOOD_1 ||
+				item->GetVnum() == ITEM_HORSE_FOOD_2 ||
+				item->GetVnum() == ITEM_HORSE_FOOD_3)
+			{
+				from->FeedHorse();
+				from->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" á¸¦ Ö¾Ï´."));
+				item->SetCount(item->GetCount() - 1);
+				EffectPacket(SE_HPUP_RED);
+			}
+		}
+		break;
+
+		default:
+		{
+			sys_log(0, "TakeItem %s %d %s", from->GetName(), GetRaceNum(), item->GetName());
+			from->SetQuestNPCID(GetVID());
+			quest::CQuestManager::instance().TakeItem(from->GetPlayerID(), GetRaceNum(), item);
+		}
+		break;
+	}
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+	if (CGuildDragonLairManager::Instance().IsRedDragonLair(from->GetMapIndex())
+		&& CGuildDragonLairManager::Instance().IsStone(GetRaceNum()))
+	{
+		if (item->GetVnum() == ITEM_GUILD_DRAGONLAIR_RING)
+		{
+			sys_log(0, "GuildDragonLair TakeItem %s %d %s", from->GetName(), GetRaceNum(), item->GetName());
+
+			if (from->GetGuildDragonLair())
+				from->GetGuildDragonLair()->TakeItem(from, this, item);
+		}
+	}
+#endif
+}
+
+bool CHARACTER::IsEquipUniqueItem(DWORD dwItemVnum) const
+{
+	{
+		LPITEM u = GetWear(WEAR_UNIQUE1);
+
+		if (u && u->GetVnum() == dwItemVnum)
+			return true;
+	}
+
+	{
+		LPITEM u = GetWear(WEAR_UNIQUE2);
+
+		if (u && u->GetVnum() == dwItemVnum)
+			return true;
+	}
+
+	return false;
+}
+
+// CHECK_UNIQUE_GROUP
+bool CHARACTER::IsEquipUniqueGroup(DWORD dwGroupVnum) const
+{
+	{
+		LPITEM u = GetWear(WEAR_UNIQUE1);
+
+		if (u && u->GetSpecialGroup() == (int)dwGroupVnum)
+			return true;
+	}
+
+	{
+		LPITEM u = GetWear(WEAR_UNIQUE2);
+
+		if (u && u->GetSpecialGroup() == (int)dwGroupVnum)
+			return true;
+	}
+
+	return false;
+}
+// END_OF_CHECK_UNIQUE_GROUP
+
+void CHARACTER::SetRefineMode(int iAdditionalCell)
+{
+	m_iRefineAdditionalCell = iAdditionalCell;
+	SetUnderRefine(true);
+}
+
+void CHARACTER::ClearRefineMode()
+{
+	SetUnderRefine(false);
+	SetRefineNPC(NULL);
+}
+
+//bool CHARACTER::GiveItemFromSpecialItemGroup(DWORD dwGroupNum, std::vector<DWORD>& dwItemVnums,
+//	std::vector<DWORD>& dwItemCounts, std::vector <LPITEM>& item_gets, int& count)
+bool CHARACTER::GiveItemFromSpecialItemGroup(DWORD dwGroupNum)
+{
+	const CSpecialItemGroup* pGroup = ITEM_MANAGER::instance().GetSpecialItemGroup(dwGroupNum);
+
+	if (!pGroup)
+	{
+		sys_err("cannot find special item group %d", dwGroupNum);
+		return false;
+	}
+
+	std::vector<int> idxes;
+	int n = pGroup->GetMultiIndex(idxes);
+
+	bool bSuccess = false;
+
+	for (int i = 0; i < n; i++)
+	{
+		bSuccess = false;
+		int idx = idxes[i];
+		DWORD dwVnum = pGroup->GetVnum(idx);
+		DWORD dwCount = pGroup->GetCount(idx);
+		int iRarePct = pGroup->GetRarePct(idx);
+		LPITEM item_get = NULL;
+		switch (dwVnum)
+		{
+			case CSpecialItemGroup::GOLD:
+			{
+				PointChange(POINT_GOLD, dwCount, true);
+				LogManager::instance().CharLog(this, dwCount, "TREASURE_GOLD", "");
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::EXP:
+			{
+				PointChange(POINT_EXP, dwCount);
+				LogManager::instance().CharLog(this, dwCount, "TREASURE_EXP", "");
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::MOB:
+			{
+				sys_log(0, "CSpecialItemGroup::MOB %d", dwCount);
+				int x = GetX() + number(-500, 500);
+				int y = GetY() + number(-500, 500);
+
+				LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(dwCount, GetMapIndex(), x, y, 0, true, -1);
+				if (ch)
+					ch->SetAggressive();
+				else
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("This doesn't seem to work here."));
+					return false;
+				}
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ú¿ Í° Å¸Ï´!"));
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::SLOW:
+			{
+				sys_log(0, "CSpecialItemGroup::SLOW %d", -(int)dwCount);
+				AddAffect(AFFECT_SLOW, POINT_MOV_SPEED, -(int)dwCount, AFF_SLOW, 300, 0, true);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ú¿   â¸¦ Ì¸ Ì´ Óµ Ï´!"));
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::DRAIN_HP:
+			{
+				int iDropHP = GetMaxHP() * dwCount / 100;
+				sys_log(0, "CSpecialItemGroup::DRAIN_HP %d", -iDropHP);
+				iDropHP = MIN(iDropHP, GetHP() - 1);
+				sys_log(0, "CSpecialItemGroup::DRAIN_HP %d", -iDropHP);
+				PointChange(POINT_HP, -iDropHP);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ú° Ú± Ï¿Ï´!  ß½Ï´."));
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::POISON:
+			{
+				AttackedByPoison(NULL);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ú¿   â¸¦ Ì¸  Â¸ Ï´!"));
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::BLEEDING:
+			{
+				AttackedByBleeding(NULL);
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ú¿   â¸¦ Ì¸ Ì´ Óµ Ï´!"));
+				bSuccess = true;
+			}
+			break;
+
+			case CSpecialItemGroup::MOB_GROUP:
+			{
+				int sx = GetX() - number(300, 500);
+				int sy = GetY() - number(300, 500);
+				int ex = GetX() + number(300, 500);
+				int ey = GetY() + number(300, 500);
+				LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnGroup(dwCount, GetMapIndex(), sx, sy, ex, ey, NULL, true);
+				if (!ch)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("This doesn't seem to work here."));
+					return false;
+				}
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ú¿ Í° Å¸Ï´!"));
+				bSuccess = true;
+			}
+			break;
+
+			default:
+			{
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+				item_get = AutoGiveItem(dwVnum, dwCount, iRarePct, true, true);
+#else
+				item_get = AutoGiveItem(dwVnum, dwCount, iRarePct);
+#endif
+				if (item_get)
+					bSuccess = true;
+			}
+			break;
+		}
+
+		if (!bSuccess)
+		{
+			ChatPacket(CHAT_TYPE_TALKING, LC_STRING("Æ¹Íµ   Ï´."));
+			return false;
+		}
+	}
+	return bSuccess;
+}
+
+// NEW_HAIR_STYLE_ADD
+bool CHARACTER::ItemProcess_Hair(LPITEM item, int iDestCell)
+{
+	if (item->CheckItemUseLevel(GetLevel()) == false)
+	{
+		//  Ñ¿ É¸
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Ó¸    Ô´Ï´."));
+		return false;
+	}
+
+	DWORD hair = item->GetVnum();
+
+	switch (GetJob())
+	{
+		case JOB_WARRIOR:
+			hair -= 72000; // 73001 - 72000 = 1001   È£ 
+			break;
+
+		case JOB_ASSASSIN:
+			hair -= 71250;
+			break;
+
+		case JOB_SURA:
+			hair -= 70500;
+			break;
+
+		case JOB_SHAMAN:
+			hair -= 69750;
+			break;
+
+		case JOB_WOLFMAN:
+			break;
+
+		default:
+			return false;
+			break;
+	}
+
+	if (hair == GetPart(PART_HAIR))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ó¸ Å¸Ï·Î´ Ã¼  Ï´."));
+		return true;
+	}
+
+	item->SetCount(item->GetCount() - 1);
+
+	SetPart(PART_HAIR, hair);
+	UpdatePacket();
+
+	return true;
+}
+// END_NEW_HAIR_STYLE_ADD
+
+bool CHARACTER::ItemProcess_Polymorph(LPITEM item)
+{
+	if (IsPolymorphed())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ì¹ Ð° Ô´Ï´."));
+		return false;
+	}
+
+	if (true == IsRiding())
+	{
+		// [BUNDLE_15][Fix] Prevent mount bonus/stat stacking with polymorph by forcing dismount
+		StopRiding();
+		if (true == IsRiding())
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ð°   Ô´Ï´."));
+			return false;
+		}
+	}
+
+	DWORD dwVnum = item->GetSocket(0);
+
+	if (dwVnum == 0)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ß¸ Ð° Ô´Ï´."));
+		item->SetCount(item->GetCount() - 1);
+		return false;
+	}
+
+	const CMob* pMob = CMobManager::instance().Get(dwVnum);
+
+	if (pMob == NULL)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ß¸ Ð° Ô´Ï´."));
+		item->SetCount(item->GetCount() - 1);
+		return false;
+	}
+
+	switch (item->GetVnum())
+	{
+		case 70104: // Polymorph Marble
+		case 70105: // Polymorph Marble
+		case 70106: // Polymorph Marble
+		case 70107: // Polymorph Marble
+		case 71093: // Polymorph Marble
+		{
+			// Ð° Ã³
+			sys_log(0, "USE_POLYMORPH_BALL PID(%d) vnum(%d)", GetPlayerID(), dwVnum);
+
+			//   Ã¼Å©
+			int iPolymorphLevelLimit = MAX(0, 20 - GetLevel() * 3 / 10);
+			if (pMob->m_table.bLevel >= GetLevel() + iPolymorphLevelLimit)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ê¹   Í·Î´    Ï´."));
+				return false;
+			}
+
+			int iDuration = GetSkillLevel(POLYMORPH_SKILL_ID) == 0 ? 5 : (5 + (5 + GetSkillLevel(POLYMORPH_SKILL_ID) / 40 * 25));
+			iDuration *= 60;
+
+			DWORD dwBonus = 0;
+
+			if (true == LC_IsYMIR() || true == LC_IsKorea())
+			{
+				dwBonus = GetSkillLevel(POLYMORPH_SKILL_ID) + 60;
+			}
+			else
+			{
+				dwBonus = (2 + GetSkillLevel(POLYMORPH_SKILL_ID) / 40) * 100;
+			}
+
+			AddAffect(AFFECT_POLYMORPH, POINT_POLYMORPH, dwVnum, AFF_POLYMORPH, iDuration, 0, true);
+			AddAffect(AFFECT_POLYMORPH, POINT_ATT_BONUS, dwBonus, AFF_POLYMORPH, iDuration, 0, false);
+
+			item->SetCount(item->GetCount() - 1);
+		}
+		break;
+
+		case 50322: // Transformation Role
+		{
+			// 
+
+			// Ð° Ã³
+			// 0 1 2
+			// Ð°  È£  Ð° 
+			sys_log(0, "USE_POLYMORPH_BOOK: %s(%u) vnum(%u)", GetName(), GetPlayerID(), dwVnum);
+
+			if (CPolymorphUtils::instance().PolymorphCharacter(this, item, pMob) == true)
+			{
+				CPolymorphUtils::instance().UpdateBookPracticeGrade(this, item);
+			}
+			else
+			{
+			}
+		}
+		break;
+
+		default:
+			sys_err("POLYMORPH invalid item passed PID(%d) vnum(%d)", GetPlayerID(), item->GetOriginalVnum());
+			return false;
+	}
+
+	return true;
+}
+
+bool CHARACTER::CanDoCube() const
+{
+	if (m_bIsObserver) return false;
+	if (GetShop()) return false;
+	if (GetMyShop()) return false;
+	if (IsUnderRefine()) return false;
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+	if (IsUnderRefineElement()) return false;
+#endif
+	if (IsWarping()) return false;
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	if (IsAcceRefineWindowOpen()) return false;
+#endif
+#if defined(__AURA_COSTUME_SYSTEM__)
+	if (IsAuraRefineWindowOpen()) return false;
+#endif
+
+	return true;
+}
+
+bool CHARACTER::UnEquipSpecialRideUniqueItem()
+{
+	LPITEM Unique1 = GetWear(WEAR_UNIQUE1);
+	LPITEM Unique2 = GetWear(WEAR_UNIQUE2);
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	LPITEM MountCostume = GetWear(WEAR_COSTUME_MOUNT);
+#endif
+
+	if (NULL != Unique1)
+	{
+		if (UNIQUE_GROUP_SPECIAL_RIDE == Unique1->GetSpecialGroup())
+		{
+			return UnequipItem(Unique1);
+		}
+	}
+
+	if (NULL != Unique2)
+	{
+		if (UNIQUE_GROUP_SPECIAL_RIDE == Unique2->GetSpecialGroup())
+		{
+			return UnequipItem(Unique2);
+		}
+	}
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	if (MountCostume)
+		return UnequipItem(MountCostume);
+#endif
+
+	return true;
+}
+
+void CHARACTER::AutoRecoveryItemProcess(const EAffectTypes type)
+{
+	if (true == IsDead() || true == IsStun())
+		return;
+
+	if (false == IsPC())
+		return;
+
+	if (AFFECT_AUTO_HP_RECOVERY != type && AFFECT_AUTO_SP_RECOVERY != type)
+		return;
+
+	if (NULL != FindAffect(AFFECT_STUN))
+		return;
+
+	{
+		const DWORD stunSkills[] = { SKILL_TANHWAN, SKILL_GEOMPUNG, SKILL_BYEURAK, SKILL_GIGUNG };
+
+		for (size_t i = 0; i < sizeof(stunSkills) / sizeof(DWORD); ++i)
+		{
+			const CAffect* p = FindAffect(stunSkills[i]);
+
+			if (NULL != p && AFF_STUN == p->dwFlag)
+				return;
+		}
+	}
+
+	const CAffect* pAffect = FindAffect(type);
+	const size_t idx_of_amount_of_used = 1;
+	const size_t idx_of_amount_of_full = 2;
+
+	if (NULL != pAffect)
+	{
+		LPITEM pItem = FindItemByID(pAffect->dwFlag);
+
+		if ((NULL != pItem) && (pItem->GetSocket(0) > 0))
+		{
+			if (false == CArenaManager::instance().IsArenaMap(GetMapIndex()))
+			{
+				const long amount_of_used = pItem->GetSocket(idx_of_amount_of_used);
+				const long amount_of_full = pItem->GetSocket(idx_of_amount_of_full);
+
+				const int32_t avail = amount_of_full - amount_of_used;
+
+				int32_t amount = 0;
+
+				if (AFFECT_AUTO_HP_RECOVERY == type)
+				{
+					amount = GetMaxHP() - (GetHP() + GetPoint(POINT_HP_RECOVERY));
+				}
+				else if (AFFECT_AUTO_SP_RECOVERY == type)
+				{
+					amount = GetMaxSP() - (GetSP() + GetPoint(POINT_SP_RECOVERY));
+				}
+
+				if (amount > 0)
+				{
+					if (avail > amount)
+					{
+						const int pct_of_used = amount_of_used * 100 / amount_of_full;
+						const int pct_of_will_used = (amount_of_used + amount) * 100 / amount_of_full;
+
+						bool bLog = false;
+						// ë·® 10%  Î±×¸ 
+						// (ë·® %,  Ú¸ Ù²  Î±×¸ .)
+						if ((pct_of_will_used / 10) - (pct_of_used / 10) >= 1)
+							bLog = true;
+						pItem->SetSocket(idx_of_amount_of_used, amount_of_used + amount, bLog);
+					}
+					else
+					{
+						amount = avail;
+
+#if defined(__USE_NEXT_AUTO_POTION__)
+						for (WORD wCell = 0; wCell < INVENTORY_MAX_NUM; ++wCell)
+						{
+							LPITEM pkNextItem = GetInventoryItem(wCell);
+							if (NULL == pkNextItem)
+								continue;
+
+							if (pItem->GetWindow() == pkNextItem->GetWindow() && pItem->GetCell() != pkNextItem->GetCell())
+							{
+								UseItemEx(pkNextItem, TItemPos(INVENTORY, wCell));
+								break;
+							}
+						}
+#endif
+
+						ITEM_MANAGER::instance().RemoveItem(pItem);
+					}
+
+					if (AFFECT_AUTO_HP_RECOVERY == type)
+					{
+						PointChange(POINT_HP_RECOVERY, amount);
+						EffectPacket(SE_AUTO_HPUP);
+					}
+					else if (AFFECT_AUTO_SP_RECOVERY == type)
+					{
+						PointChange(POINT_SP_RECOVERY, amount);
+						EffectPacket(SE_AUTO_SPUP);
+					}
+				}
+			}
+			else
+			{
+				pItem->Lock(false);
+				pItem->SetSocket(0, false);
+				RemoveAffect(const_cast<CAffect*>(pAffect));
+			}
+		}
+		else
+		{
+			RemoveAffect(const_cast<CAffect*>(pAffect));
+		}
+	}
+}
+
+bool CHARACTER::IsValidItemPosition(TItemPos Pos) const
+{
+	BYTE window_type = Pos.window_type;
+	WORD cell = Pos.cell;
+
+	switch (window_type)
+	{
+		case INVENTORY:
+			return cell < INVENTORY_MAX_NUM;
+
+		case EQUIPMENT:
+			return cell < EQUIPMENT_MAX_NUM;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case DRAGON_SOUL_INVENTORY:
+			return cell < DRAGON_SOUL_INVENTORY_MAX_NUM;
+#endif
+
+		case BELT_INVENTORY:
+			return cell < BELT_INVENTORY_MAX_NUM;
+
+		case SAFEBOX:
+			if (NULL != m_pkSafebox)
+				return m_pkSafebox->IsValidPosition(cell);
+			else
+				return false;
+
+		case MALL:
+			if (NULL != m_pkMall)
+				return m_pkMall->IsValidPosition(cell);
+			else
+				return false;
+
+#if defined(__ATTR_6TH_7TH__)
+		case NPC_STORAGE:
+			return cell < NPC_STORAGE_SLOT_MAX;
+#endif
+
+		default:
+			return false;
+	}
+}
+
+///  Ä³ Â¸  Ö¾ item   Ö´  È®Ï°, Ò° Ï´Ù¸ Ä³Í¿  Ë·Ö´ Ô¼
+bool CHARACTER::CanEquipNow(const LPITEM item, const TItemPos& srcCell, const TItemPos& destCell) /*const*/
+{
+	if (IsFishing())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
+		return false;
+	}
+
+	const TItemTable* itemTable = item->GetProto();
+	//BYTE itemType = item->GetType();
+	//BYTE itemSubType = item->GetSubType();
+
+	switch (GetJob())
+	{
+		case JOB_WARRIOR:
+			if (item->GetAntiFlag() & ITEM_ANTIFLAG_WARRIOR)
+				return false;
+			break;
+
+		case JOB_ASSASSIN:
+			if (item->GetAntiFlag() & ITEM_ANTIFLAG_ASSASSIN)
+				return false;
+			break;
+
+		case JOB_SHAMAN:
+			if (item->GetAntiFlag() & ITEM_ANTIFLAG_SHAMAN)
+				return false;
+			break;
+
+		case JOB_SURA:
+			if (item->GetAntiFlag() & ITEM_ANTIFLAG_SURA)
+				return false;
+			break;
+
+		case JOB_WOLFMAN:
+			if (item->GetAntiFlag() & ITEM_ANTIFLAG_WOLFMAN)
+				return false;
+			break;
+
+	}
+
+	for (int i = 0; i < ITEM_LIMIT_MAX_NUM; ++i)
+	{
+		long limit = itemTable->aLimits[i].lValue;
+		switch (itemTable->aLimits[i].bType)
+		{
+			case LIMIT_LEVEL:
+			{
+				if (GetLevel() < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+					return false;
+				}
+			}
+			break;
+
+#if defined(__CONQUEROR_LEVEL__)
+			case LIMIT_NEWWORLD_LEVEL:
+			{
+				if (GetConquerorLevel() < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+					return false;
+				}
+			}
+			break;
+#endif
+
+			case LIMIT_STR:
+			{
+				if (GetPoint(POINT_ST) < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ù·    Ï´."));
+					return false;
+				}
+			}
+			break;
+
+			case LIMIT_INT:
+			{
+				if (GetPoint(POINT_IQ) < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("    Ï´."));
+					return false;
+				}
+			}
+			break;
+
+			case LIMIT_DEX:
+			{
+				if (GetPoint(POINT_DX) < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¸    Ï´."));
+					return false;
+				}
+			}
+			break;
+
+			case LIMIT_CON:
+			{
+				if (GetPoint(POINT_HT) < limit)
+				{
+					ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ã¼    Ï´."));
+					return false;
+				}
+			}
+			break;
+		}
+	}
+
+	if (item->GetWearFlag() & WEARABLE_UNIQUE)
+	{
+		if ((GetWear(WEAR_UNIQUE1) && GetWear(WEAR_UNIQUE1)->IsSameSpecialGroup(item)) ||
+			(GetWear(WEAR_UNIQUE2) && GetWear(WEAR_UNIQUE2)->IsSameSpecialGroup(item)))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("  Å©    Ã¿   Ï´."));
+			return false;
+		}
+
+		if (marriage::CManager::instance().IsMarriageUniqueItem(item->GetVnum()) &&
+			!marriage::CManager::instance().IsMarried(GetPlayerID()))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("È¥  Â¿    Ï´."));
+			return false;
+		}
+	}
+
+#if defined(__PET_SYSTEM__)
+	if (item->IsPet() && SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::PET_BLOCK_MAP_INDEX, GetMapIndex()))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
+		return false;
+	}
+#endif
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+	if (item->IsCostumeMount() && SECTREE_MANAGER::Instance().IsBlockFilterMapIndex(SECTREE_MANAGER::MOUNT_BLOCK_MAP_INDEX, GetMapIndex()))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot summon your mount/pet right now."));
+		return false;
+	}
+#endif
+
+	return true;
+}
+
+///  Ä³ Â¸    item   Ö´  È®Ï°, Ò° Ï´Ù¸ Ä³Í¿  Ë·Ö´ Ô¼
+bool CHARACTER::CanUnequipNow(const LPITEM item, const TItemPos& srcCell, const TItemPos& destCell) /*const*/
+//bool CHARACTER::CanUnequipNow(const LPITEM item, const TItemPos& swapCell) /*const*/
+{
+	if (item->IsBelt())
+	{
+		if (CBeltInventoryHelper::IsExistItemInBeltInventory(this))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can only discard the belt when there are no longer any items in its inventory."));
+			return false;
+		}
+	}
+
+	//     
+	if (IS_SET(item->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+		return false;
+
+	if (IsFishing())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot carry out this action while fishing."));
+		return false;
+	}
+
+	//  unequip Îºä¸® Å±   Ú¸ Ö´  È®
+	{
+		int pos = -1;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+			pos = GetEmptyDragonSoulInventory(item);
+		else
+#endif
+			pos = GetEmptyInventory(item->GetSize());
+
+		if (-1 == pos)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ç°   Ï´."));
+			return false;
+		}
+	}
+
+	return true;
+}
+
+#ifdef __OFFLINE_SHOP__
+bool CHARACTER::UseItemOpenOfflineShop(CItem* item)
+{
+	if (!item) {
+		return false;
+	}
+
+	if (IsOpeningOfflineShop()) {
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ZATEN_PAZAR_ACIYORSUN"));
+		return false;
+	}
+
+	item->Lock(true);
+	SetOpeningOfflineShopState(true);
+	SetOfflineShopOpeningItem(item);
+
+	ChatPacket(CHAT_TYPE_COMMAND, "StartOpeningOfflineShop %d %lld",
+		item->GetValue(COfflineShop::ITEM_TIME_IDX), item->GetValue(COfflineShop::ITEM_GOLD_IDX));
+
+	return true;
+}
+#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+void CHARACTER::OpenItemComb()
+{
+	if (PreventTradeWindow(WND_ALL))
+	{
+		ChatPacket(CHAT_TYPE_INFO, "You have to close other windows.");
+		return;
+	}
+
+	const LPCHARACTER npc = GetQuestNPC();
+	if (npc == NULL)
+	{
+		sys_err("Item Combination NPC is NULL (ch: %s)", GetName());
+		return;
+	}
+
+	SetItemCombNpc(npc);
+	ChatPacket(CHAT_TYPE_COMMAND, "ShowItemCombinationDialog");
+}
+
+void CHARACTER::ItemCombination(const short MediumIndex, const short BaseIndex, const short MaterialIndex)
+{
+	if (IsItemComb() == false)
+		return;
+
+	const LPITEM MediumItem = GetItem(TItemPos(INVENTORY, MediumIndex));
+	const LPITEM BaseItem = GetItem(TItemPos(INVENTORY, BaseIndex));
+	const LPITEM MaterialItem = GetItem(TItemPos(INVENTORY, MaterialIndex));
+
+	if (MediumItem == NULL || BaseItem == NULL || MaterialItem == NULL)
+		return;
+
+	if (MediumItem->GetType() != ITEM_MEDIUM)
+		return;
+
+	if (BaseItem->GetType() != MaterialItem->GetType())
+		return;
+
+	if (BaseItem->GetSubType() != MaterialItem->GetSubType())
+		return;
+
+	if (BaseItem->GetType() != EItemTypes::ITEM_COSTUME || MaterialItem->GetType() != EItemTypes::ITEM_COSTUME)
+		return;
+
+	if (BaseItem->IsEquipped() || MaterialItem->IsEquipped())
+		return;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (BaseItem->IsSealed() || MaterialItem->IsSealed())
+		return;
+#endif
+
+	if (MediumItem->GetSubType() == MEDIUM_MOVE_COSTUME_ATTR)
+	{
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+		if (BaseItem->GetSubType() == COSTUME_MOUNT || MaterialItem->GetSubType() == COSTUME_MOUNT)
+			return;
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		if (BaseItem->GetSubType() == COSTUME_ACCE || MaterialItem->GetSubType() == COSTUME_ACCE)
+			return;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+		if (BaseItem->GetSubType() == COSTUME_AURA || MaterialItem->GetSubType() == COSTUME_AURA)
+			return;
+#endif
+
+		BaseItem->SetAttributes(MaterialItem->GetAttributes());
+		BaseItem->UpdatePacket();
+
+		ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
+		MediumItem->SetCount(MediumItem->GetCount() - 1);
+	}
+#if defined(__ACCE_COSTUME_SYSTEM__)
+	else if (MediumItem->GetSubType() == MEDIUM_MOVE_ACCE_ATTR)
+	{
+		if (MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_ITEM_VNUM) == 0)
+		{
+			if (MaterialItem->GetAttributeCount() == 0)
+			{
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use a sash without a bonus as the source."));
+				return;
+			}
+		}
+
+		if (BaseItem->GetAttributeCount() > 0)
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot use a sash with a bonus for the target."));
+			return;
+		}
+
+		if (BaseItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) != MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot transfer the bonus as the sashes have different absorption rates."));
+			return;
+		}
+
+		if (BaseItem->FindApplyValue(APPLY_ACCEDRAIN_RATE) != MaterialItem->FindApplyValue(APPLY_ACCEDRAIN_RATE))
+		{
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot transfer the bonus as the sashes have different grades."));
+			return;
+		}
+
+		int iRandom = number(0, EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_MAX - 1);
+		switch (iRandom)
+		{
+			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_FAIL:
+			{
+				MaterialItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE, MAX(MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) - 1, 11));
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Failure! The absorption rate was reduced by 1%."));
+			}
+			break;
+
+			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_PARTIAL:
+			{
+				BaseItem->SetSockets(MaterialItem->GetSockets());
+				BaseItem->SetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE, MAX(MaterialItem->GetSocket(ITEM_SOCKET_ACCE_DRAIN_VALUE) - 1, 11));
+				BaseItem->SetAttributes(MaterialItem->GetAttributes());
+#if defined(__ITEM_APPLY_RANDOM__)
+				MaterialItem->CopyRandomAppliesTo(BaseItem);
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				MaterialItem->CopyElementTo(BaseItem);
+#endif
+				BaseItem->UpdatePacket();
+
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Partial success! The absorption rate was reduced by 1%."));
+				ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
+			}
+			break;
+
+			case EMediumMoveAcceResult::MEDIUM_MOVE_ACCE_SUCCESS:
+			{
+				BaseItem->SetSockets(MaterialItem->GetSockets());
+				BaseItem->SetAttributes(MaterialItem->GetAttributes());
+#if defined(__ITEM_APPLY_RANDOM__)
+				MaterialItem->CopyRandomAppliesTo(BaseItem);
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+				MaterialItem->CopyElementTo(BaseItem);
+#endif
+				BaseItem->UpdatePacket();
+
+				ChatPacket(CHAT_TYPE_INFO, LC_STRING("Success! The bonus was transferred successfully."));
+				ITEM_MANAGER::instance().RemoveItem(MaterialItem, "REMOVE (Item Combination)");
+			}
+			break;
+		}
+
+		MediumItem->SetCount(MediumItem->GetCount() - 1);
+	}
+#endif
+}
+#endif
+
+#if defined(__CHANGED_ATTR__)
+void CHARACTER::SelectAttr(LPITEM material, LPITEM item)
+{
+	const LPDESC d = GetDesc();
+	if (d == nullptr)
+		return;
+
+	if (PreventTradeWindow(WND_ALL))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot upgrade anything while another window is open."));
+		return;
+	}
+
+	if (item->GetAttributeSetIndex() == -1)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ó¼    Ô´Ï´."));
+		return;
+	}
+
+	if (item->GetAttributeCount() < 1)
+		return;
+
+	const TItemPos pos(item->GetWindow(), item->GetCell());
+	if (pos.IsInventoryPosition() == false)
+		return;
+
+	m_ItemSelectAttr.dwItemID = item->GetID();
+	item->GetSelectAttr(m_ItemSelectAttr.Attr);
+
+	TPacketGCItemSelectAttr p;
+	p.bHeader = HEADER_GC_ITEM_SELECT_ATTR;
+	p.pItemPos = pos;
+	std::copy(std::begin(m_ItemSelectAttr.Attr), std::end(m_ItemSelectAttr.Attr), std::begin(p.aAttr));
+	d->Packet(&p, sizeof p);
+
+	material->SetCount(material->GetCount() - 1);
+}
+
+void CHARACTER::SelectAttrResult(const bool bNew, const TItemPos& pos)
+{
+	if (IsSelectAttr() == false)
+		return;
+
+	if (bNew)
+	{
+		const LPITEM item = GetItem(pos);
+		if (item && item->GetID() == m_ItemSelectAttr.dwItemID)
+		{
+			item->SetAttributes(m_ItemSelectAttr.Attr);
+			item->UpdatePacket();
+			ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have changed the upgrade."));
+		}
+	}
+
+	memset(&m_ItemSelectAttr, 0, sizeof m_ItemSelectAttr);
+}
+
+bool CHARACTER::IsSelectAttr() const
+{
+	return m_ItemSelectAttr.dwItemID != 0;
+}
+#endif
+
+#if defined(__LUCKY_BOX__)
+void CHARACTER::SetLuckyBoxSrcItem(const LPITEM c_lpItem)
+{
+	if (c_lpItem == nullptr)
+		return;
+
+	if (PreventTradeWindow(WND_ALL))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have to close other windows."));
+		return;
+	}
+
+	ResetLuckyBoxData();
+
+	m_sLuckyBox.dwSrcItemVNum = c_lpItem->GetVnum();
+	m_sLuckyBox.dwSrcItemID = c_lpItem->GetID();
+	m_sLuckyBox.wSrcSlotIndex = c_lpItem->GetCell();
+
+	SendLuckyBoxInfo();
+}
+
+void CHARACTER::SendLuckyBoxInfo()
+{
+	if (!IsLuckyBoxOpen())
+		return;
+
+	if (!GetDesc())
+		return;
+
+	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
+	if (!pLuckyBox)
+		return;
+
+	if (!pLuckyBox->ContainsItems(m_sLuckyBox.dwSrcItemVNum))
+	{
+		ResetLuckyBoxData();
+		return;
+	}
+
+	m_sLuckyBox.bTryCount++;
+
+	while (true)
+	{
+		const CLuckyBoxGroup::SLuckyBoxItemInfo& item = pLuckyBox->GetRandomItem(m_sLuckyBox.dwSrcItemVNum);
+		if (pLuckyBox->GetItemCount(m_sLuckyBox.dwSrcItemVNum) > 1 && item.dwVNum == m_sLuckyBox.dwItemVNum)
+			continue;
+
+		m_sLuckyBox.dwItemVNum = item.dwVNum;
+		m_sLuckyBox.bItemCount = item.bCount;
+		break;
+	}
+
+	TPacketGCLuckyBox Packet;
+	Packet.bHeader = HEADER_GC_LUCKY_BOX;
+	Packet.dwVNum = m_sLuckyBox.dwItemVNum;
+	Packet.bCount = m_sLuckyBox.bItemCount;
+	Packet.iNeedMoney = GetLuckyBoxPrice();
+	Packet.wSlotIndex = m_sLuckyBox.wSrcSlotIndex;
+	GetDesc()->Packet(&Packet, sizeof(Packet));
+}
+
+void CHARACTER::LuckyBoxRetry()
+{
+	if (!IsLuckyBoxOpen())
+		return;
+
+	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
+	if (!pLuckyBox)
+		return;
+
+	if (m_sLuckyBox.bTryCount >= pLuckyBox->GetMaxTryCount())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can't do this anymore."));
+		return;
+	}
+
+	const int c_iPrice = GetLuckyBoxPrice();
+	if (c_iPrice > GetGold())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough money."));
+		return;
+	}
+
+	PointChange(POINT_GOLD, -c_iPrice);
+	ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d Yang has been deducted.", c_iPrice));
+	SendLuckyBoxInfo();
+}
+
+void CHARACTER::LuckyBoxReceive()
+{
+	if (!IsLuckyBoxOpen())
+		return;
+
+	const LPITEM c_lpSrcItem = ITEM_MANAGER::Instance().Find(m_sLuckyBox.dwSrcItemID);
+	if (c_lpSrcItem)
+	{
+		ITEM_MANAGER::Instance().RemoveItem(c_lpSrcItem);
+		AutoGiveItem(m_sLuckyBox.dwItemVNum, m_sLuckyBox.bItemCount);
+	}
+
+	ResetLuckyBoxData();
+}
+
+int CHARACTER::GetLuckyBoxPrice() const
+{
+	CLuckyBoxGroup* pLuckyBox = ITEM_MANAGER::Instance().GetLuckyBoxGroup();
+	if (!pLuckyBox)
+		return 0;
+
+	int iRet = pLuckyBox->GetPrice();
+	for (int i = 1; i < m_sLuckyBox.bTryCount; i++)
+		iRet *= 2;
+
+	return iRet;
+}
+
+bool CHARACTER::IsLuckyBoxOpen() const
+{
+	return m_sLuckyBox.dwSrcItemID != 0;
+}
+
+void CHARACTER::ResetLuckyBoxData()
+{
+	memset(&m_sLuckyBox, 0, sizeof(m_sLuckyBox));
+}
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+LPITEM CHARACTER::GetNPCStorageItem(BYTE bCell) const
+{
+	return GetItem(TItemPos(NPC_STORAGE, bCell));
+}
+
+bool CHARACTER::Attr67Add(const TAttr67AddData kAttr67AddData)
+{
+	if (!IsPC())
+		return false;
+
+	if (PreventTradeWindow(WND_ATTR67ADD, true/*except*/))
+		return false;
+
+	if (GetNPCStorageItem())
+		return false;
+
+	const LPITEM pkRegistItem = GetInventoryItem(kAttr67AddData.wRegistItemPos);
+	if (pkRegistItem == nullptr)
+		return false;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (pkRegistItem->IsSealed())
+		return false;
+#endif
+
+	if (pkRegistItem->isLocked())
+		return false;
+
+	if (pkRegistItem->IsEquipped())
+		return false;
+
+	if (pkRegistItem->GetType() != ITEM_ARMOR && pkRegistItem->GetType() != ITEM_WEAPON)
+		return false;
+
+	if (pkRegistItem->GetAttributeCount() < ITEM_MANAGER::MAX_NORM_ATTR_NUM)
+		return false;
+
+	DWORD dwItemMaterialVnum = pkRegistItem->Get67AttrMaterial();
+	if (CountSpecifyItem(dwItemMaterialVnum) < kAttr67AddData.byMaterialCount)
+		return false;
+
+	RemoveSpecifyItem(dwItemMaterialVnum, kAttr67AddData.byMaterialCount);
+
+	long lSupportIncreasePct = 0;
+	LPITEM pSupportItem = nullptr;
+	{
+		pSupportItem = GetInventoryItem(kAttr67AddData.wSupportItemPos);
+		if (pSupportItem)
+			lSupportIncreasePct = pSupportItem->GetValue(1);
+	}
+
+	// Total success percent.
+	float fMaterialPct = kAttr67AddData.byMaterialCount * ATTR67_SUCCESS_PER_MATERIAL;
+	float fSupportPct = 0.0f;
+	if (kAttr67AddData.bySupportItemCount != 0)
+	{
+		fSupportPct = static_cast<float>(lSupportIncreasePct) / (ATTR67_MATERIAL_MAX_COUNT * ATTR67_SUPPORT_MAX_COUNT);
+		fSupportPct *= kAttr67AddData.bySupportItemCount * kAttr67AddData.byMaterialCount;
+
+	}
+	float fTotalSuccessPct = fMaterialPct + fSupportPct;
+
+	if (test_server)
+	{
+		ChatPacket(CHAT_TYPE_INFO, "<Add67> Success Percentage: %.2f", fTotalSuccessPct);
+	}
+
+	if (pSupportItem)
+	{
+		if (CountSpecifyItem(pSupportItem->GetVnum()) < kAttr67AddData.bySupportItemCount)
+			return false;
+
+		RemoveSpecifyItem(pSupportItem->GetVnum(), kAttr67AddData.bySupportItemCount);
+	}
+
+	pkRegistItem->RemoveFromCharacter();
+	SetItem(TItemPos(NPC_STORAGE, 0), pkRegistItem);
+	{
+		const LPITEM pkAttr67Add = GetNPCStorageItem();
+		if (!pkAttr67Add)
+		{
+			// TODO: Make a backup of the item in case something goes bad.
+			sys_err("CHARACTER::Attr67Add: failed to get regist item from ATTR67_ADD (window).");
+			return false;
+		}
+
+		SetQuestFlag("add_attr67.success", (number(1, 100) <= fTotalSuccessPct ? 1 : 0));
+		SetQuestFlag("add_attr67.wait_time", get_global_time() + ATTR67_ADD_WAIT_TIME);
+		SetQuestFlag("add_attr67.add", 0);
+		// @ attr67add_collect (handling)
+	}
+
+	return true;
+}
+#endif
+
+#if defined(__SOUL_SYSTEM__)
+void CHARACTER::SoulItemProcess(ESoulSubTypes eSubType)
+{
+	LPITEM item = nullptr;
+	for (const auto& it : GetAffectContainer())
+	{
+		if (it == nullptr || it->dwType != AFFECT_SOUL)
+			continue;
+
+		switch (eSubType)
+		{
+			case ESoulSubTypes::RED_SOUL:
+			{
+				if (it->wApplyOn == AFF_SOUL_RED)
+					item = FindItemByID(it->lApplyValue);
+			}
+			break;
+
+			case ESoulSubTypes::BLUE_SOUL:
+			{
+				if (it->wApplyOn == AFF_SOUL_BLUE)
+					item = FindItemByID(it->lApplyValue);
+			}
+			break;
+		}
+	}
+
+	if (item == nullptr)
+		return;
+
+	if (!item->isLocked() || item->GetSocket(1) != TRUE)
+		return;
+
+	long data = item->GetSocket(2);
+	long keep_time = data / 10000;
+	//auto max_time = item->GetLimitValue(1);
+	long min_time = 60;
+
+	// Minimum use time.
+	if (keep_time < min_time)
+		return;
+
+	/*
+	* Since the `remain_count` is added after the `keep_time`
+	* we can decrease `data` directly because the count
+	* stays at the end of `data`.
+	*/
+	//if (test_server)
+	//	data -= 5;
+	//else
+	--data; /* remain_count */;
+
+	/*
+	* If the remaining count is equal or below to zero
+	* then set decrease the socket data.
+	*/
+	long new_data = ((keep_time - min_time) * 10000) + item->GetValue(2);
+	long remain_count = data % 10000;
+	if (remain_count <= 0)
+	{
+		item->SetSocket(2, new_data);
+		item->ResetSoulTimerUseEvent();
+		return;
+	}
+
+	// Update the item with the new data (decreased count)
+	item->SetSocket(2, data, false /* log */);
+}
+
+int CHARACTER::GetSoulDamage(ESoulSubTypes eSubType) const
+{
+	LPITEM item = nullptr;
+	for (const auto& it : GetAffectContainer())
+	{
+		if (it == nullptr || it->dwType != AFFECT_SOUL)
+			continue;
+
+		switch (eSubType)
+		{
+			case ESoulSubTypes::RED_SOUL:
+			{
+				if (it->wApplyOn == AFF_SOUL_RED)
+					item = FindItemByID(it->lApplyValue);
+			}
+			break;
+
+			case ESoulSubTypes::BLUE_SOUL:
+			{
+				if (it->wApplyOn == AFF_SOUL_BLUE)
+					item = FindItemByID(it->lApplyValue);
+			}
+			break;
+		}
+	}
+
+	if (item == nullptr)
+		return 0;
+
+	if (item->GetSocket(1) != TRUE)
+		return 0;
+
+	int value = 0;
+	long data = item->GetSocket(2);
+	long keep_time = data / 10000;
+
+	long max_time = item->GetLimitValue(1);
+	long min_time = 60;
+
+	// Minimum use time.
+	if (keep_time < min_time)
+		return 0;
+
+	if (keep_time >= max_time)
+		return item->GetValue(5);
+
+	// Damage values in value field (3, 4, 5)
+	int value_field = 3 + std::floor(keep_time / (max_time - min_time));
+	if (value_field < ITEM_VALUES_MAX_NUM)
+		value = item->GetValue(value_field);
+
+	return value;
+}
+#endif
+
+#if defined(__SET_ITEM__)
+void CHARACTER::RefreshItemSetBonus()
+{
+	RemoveAffect(AFFECT_SET_ITEM);
+
+	bool bSetBonus = false;
+	for (const auto& [bSetValue, vItems] : ITEM_MANAGER::Instance().GetItemSetItemMap())
+	{
+		BYTE bWearCount = 0;
+
+		const auto& rkItemSetValueMap = ITEM_MANAGER::Instance().GetItemSetValueMap();
+		if (rkItemSetValueMap.empty())
+			break;
+
+		const auto& ItemSetValueMap = rkItemSetValueMap.find(bSetValue);
+		if (ItemSetValueMap == rkItemSetValueMap.end())
+			continue;
+
+		for (const auto& [bSetType, kItemTuple] : vItems)
+		{
+			LPITEM pItem = nullptr;
+			LPITEM pUnique1 = nullptr;
+			LPITEM pUnique2 = nullptr;
+			CPetSystem* pPetSystem = nullptr;
+
+			switch (bSetType)
+			{
+				case SET_ITEM_COSTUME_BODY:
+					pItem = GetWear(WEAR_COSTUME_BODY);
+					break;
+
+				case SET_ITEM_COSTUME_HAIR:
+					pItem = GetWear(WEAR_COSTUME_HAIR);
+					break;
+
+#if defined(__MOUNT_COSTUME_SYSTEM__)
+				case SET_ITEM_COSTUME_MOUNT:
+					pItem = GetWear(WEAR_COSTUME_MOUNT);
+					break;
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+				case SET_ITEM_COSTUME_ACCE:
+					pItem = GetWear(WEAR_COSTUME_ACCE);
+					break;
+#endif
+
+#if defined(__WEAPON_COSTUME_SYSTEM__)
+				case SET_ITEM_COSTUME_WEAPON:
+					pItem = GetWear(WEAR_COSTUME_WEAPON);
+					break;
+#endif
+
+				case SET_ITEM_UNIQUE:
+					pUnique1 = GetWear(WEAR_UNIQUE1);
+					pUnique2 = GetWear(WEAR_UNIQUE2);
+					break;
+
+#if defined(__PET_SYSTEM__)
+				case SET_ITEM_PET:
+					pPetSystem = GetPetSystem();
+					break;
+#endif
+			}
+
+			const auto& [dwMinVnum, dwMaxVnum, bRange] = kItemTuple;
+
+#if defined(__PET_SYSTEM__)
+			if (pPetSystem && CHECK_VNUM_RANGE(pPetSystem->GetSummonItemVnum(), dwMinVnum, dwMaxVnum, bRange))
+				++bWearCount;
+#endif
+
+			if (pUnique1 && CHECK_VNUM_RANGE(pUnique1->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
+				++bWearCount;
+
+			if (pUnique2 && CHECK_VNUM_RANGE(pUnique2->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
+				++bWearCount;
+
+			if (pItem && CHECK_VNUM_RANGE(pItem->GetVnum(), dwMinVnum, dwMaxVnum, bRange))
+				++bWearCount;
+
+			for (const auto& [bCount, vSetBonus] : ItemSetValueMap->second)
+			{
+				if (bWearCount != bCount)
+				{
+					bSetBonus = false;
+					continue;
+				}
+
+				for (const auto& [wApplyType, lApplyValue] : vSetBonus)
+				{
+					AddAffect(AFFECT_SET_ITEM, aApplyInfo[wApplyType].wPointType, lApplyValue, 0, INFINITE_AFFECT_DURATION, 0, true, true);
+					bSetBonus = true;
+				}
+			}
+		}
+
+		if (bSetBonus)
+			break;
+	}
+}
+
+CHARACTER::SetItemCountMap CHARACTER::GetItemSetCountMap() const
+{
+	std::vector<LPITEM> vItems = { GetWear(WEAR_BODY), GetWear(WEAR_HEAD), GetWear(WEAR_WEAPON) };
+	std::map<BYTE, BYTE> mSetCount = {
+		{ SET_ITEM_SET_VALUE_1, 0 },
+		{ SET_ITEM_SET_VALUE_2, 0 },
+		{ SET_ITEM_SET_VALUE_3, 0 },
+		{ SET_ITEM_SET_VALUE_4, 0 },
+		{ SET_ITEM_SET_VALUE_5, 0 },
+	};
+
+	for (const LPITEM& pkItem : vItems)
+	{
+		if (pkItem == nullptr)
+			continue;
+
+		const BYTE bSetValue = pkItem->GetItemSetValue();
+		if (bSetValue != SET_ITEM_SET_VALUE_NONE)
+			++mSetCount[bSetValue];
+	}
+
+	return mSetCount;
+}
+
+void CHARACTER::RefreshItemSetBonusByValue()
+{
+	for (DWORD dwType = AFFECT_SET_ITEM_SET_VALUE_1; dwType <= AFFECT_SET_ITEM_SET_VALUE_5; ++dwType)
+		RemoveAffect(dwType);
+
+	const auto& rkItemSetValueMap = ITEM_MANAGER::Instance().GetItemSetValueMap();
+	if (rkItemSetValueMap.empty())
+		return;
+
+	for (const auto& rkItemSetPair : GetItemSetCountMap())
+	{
+		BYTE bSetValue = rkItemSetPair.first;
+		BYTE bWearCount = rkItemSetPair.second;
+
+		const auto& rkSetItemMap = rkItemSetValueMap.find(bSetValue);
+		if (rkSetItemMap == rkItemSetValueMap.end())
+			continue;
+
+		for (const auto& kSetItem : rkSetItemMap->second)
+		{
+			const auto& vSetBonus = kSetItem.second;
+			if (bWearCount != kSetItem.first)
+				continue;
+
+			for (const auto& kSetBonus : vSetBonus)
+				AddAffect((AFFECT_SET_ITEM_SET_VALUE_1 - 1) + bSetValue, aApplyInfo[kSetBonus.first].wPointType, kSetBonus.second, 0, INFINITE_AFFECT_DURATION, 0, true, true);
+		}
+	}
+}
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+void CHARACTER::RefineElementInformation(const LPITEM& rSrcItem, const TItemPos& kItemDestCell)
+{
+	if (!CanHandleItem())
+		return;
+
+	LPITEM pDestItem;
+	if (!IsValidItemPosition(kItemDestCell) || !(pDestItem = GetItem(kItemDestCell)))
+		return;
+
+	if (rSrcItem->IsEquipped() || pDestItem->IsEquipped())
+		return;
+
+	if (rSrcItem->IsExchanging() || pDestItem->IsExchanging())
+		return;
+
+	if (rSrcItem->isLocked() || pDestItem->isLocked())
+		return;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (pDestItem->IsSealed())
+		return;
+#endif
+
+	if (pDestItem->GetType() != ITEM_WEAPON)
+		return;
+
+	if (pDestItem->GetRefineLevel() < REFINE_ELEMENT_MIN_REFINE_LEVEL)
+		return;
+
+	TPacketGCRefineElement kPacket;
+	kPacket.bHeader = HEADER_GC_REFINE_ELEMENT;
+	kPacket.bSubHeader = REFINE_ELEMENT_GC_OPEN;
+	switch (rSrcItem->GetSubType())
+	{
+		case USE_ELEMENT_UPGRADE:
+			kPacket.bRefineType = REFINE_ELEMENT_UPGRADE;
+			break;
+		case USE_ELEMENT_DOWNGRADE:
+			kPacket.bRefineType = REFINE_ELEMENT_DOWNGRADE;
+			break;
+		case USE_ELEMENT_CHANGE:
+			kPacket.bRefineType = REFINE_ELEMENT_CHANGE;
+			break;
+		default:
+		{
+			sys_err("CHARACTER::RefineElementInformation: %s cannot receive information with unsupported material sub type.", GetName());
+			return;
+		}
+	}
+	kPacket.bResult = false;
+	kPacket.SrcPos = TItemPos(rSrcItem->GetWindow(), rSrcItem->GetCell());
+	kPacket.DestPos = kItemDestCell;
+	GetDesc()->Packet(&kPacket, sizeof(kPacket));
+
+	SetUnderRefineElement(true, kPacket.bRefineType, kPacket.SrcPos, kPacket.DestPos);
+}
+
+void CHARACTER::SetUnderRefineElement(bool bState, BYTE bRefineType, const TItemPos& rkSrcPos, const TItemPos& rkDestPos)
+{
+	m_kRefineElementItemPos.RefineType = bRefineType;
+	m_kRefineElementItemPos.SrcPos = rkSrcPos;
+	m_kRefineElementItemPos.DestPos = rkDestPos;
+	m_bUnderRefineElement = bState;
+}
+
+void CHARACTER::RefineElement(WORD wChangeElement)
+{
+	if (!IsUnderRefineElement())
+		return;
+
+	LPITEM pSrcItem;
+	if (!IsValidItemPosition(m_kRefineElementItemPos.SrcPos) || !(pSrcItem = GetItem(m_kRefineElementItemPos.SrcPos)))
+		return;
+
+	LPITEM pDestItem;
+	if (!IsValidItemPosition(m_kRefineElementItemPos.DestPos) || !(pDestItem = GetItem(m_kRefineElementItemPos.DestPos)))
+		return;
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (pDestItem->IsSealed())
+		return;
+#endif
+
+	if (pDestItem->GetType() != ITEM_WEAPON)
+		return;
+
+	if (pDestItem->GetRefineLevel() < REFINE_ELEMENT_MIN_REFINE_LEVEL)
+		return;
+
+	TPacketGCRefineElement kPacket;
+	kPacket.bHeader = HEADER_GC_REFINE_ELEMENT;
+	kPacket.bSubHeader = REFINE_ELEMENT_GC_RESULT;
+	kPacket.bRefineType = m_kRefineElementItemPos.RefineType;
+	switch (kPacket.bRefineType)
+	{
+		case REFINE_ELEMENT_UPGRADE:
+		{
+			if (GetGold() < REFINE_ELEMENT_UPGRADE_YANG)
+				return;
+
+			//const TRefineTable* pRefineTable = CRefineManager::instance().GetRefineRecipe(11);
+			//if (number(1, 100) <= (pRefineTable ? pRefineTable->prob : 30))
+			if (number(1, 100) <= (test_server ? 80 : 30))
+			{
+				const WORD wMaterialApplyType = static_cast<WORD>(pSrcItem->GetValue(0));
+				const WORD wRefineElementApplyType = pDestItem->GetRefineElementApplyType();
+				if ((wRefineElementApplyType != 0) && (wRefineElementApplyType != wMaterialApplyType))
+				{
+					sys_err("CHARACTER::RefineElement: %s cannot upgrade with wrong material.", GetName());
+					return;
+				}
+
+				const BYTE bRandomValue = number_even(REFINE_ELEMENT_RANDOM_VALUE_MIN, REFINE_ELEMENT_RANDOM_VALUE_MAX);
+				const BYTE bRandomBonusValue = number_even(REFINE_ELEMENT_RANDOM_BONUS_VALUE_MIN, REFINE_ELEMENT_RANDOM_BONUS_VALUE_MAX);
+
+				pDestItem->UpgradeRefineElement(wMaterialApplyType, bRandomValue, bRandomBonusValue);
+
+				kPacket.bResult = true;
+			}
+			else
+			{
+				kPacket.bResult = false;
+			}
+
+			PointChange(POINT_GOLD, -REFINE_ELEMENT_UPGRADE_YANG);
+		}
+		break;
+
+		case REFINE_ELEMENT_DOWNGRADE:
+		{
+			if (GetGold() < REFINE_ELEMENT_DOWNGRADE_YANG)
+				return;
+
+			pDestItem->DowngradeRefineElement();
+			kPacket.bResult = true;
+
+			PointChange(POINT_GOLD, -REFINE_ELEMENT_DOWNGRADE_YANG);
+		}
+		break;
+
+		case REFINE_ELEMENT_CHANGE:
+		{
+			if (GetGold() < REFINE_ELEMENT_CHANGE_YANG)
+				return;
+
+			switch (wChangeElement)
+			{
+				case APPLY_ENCHANT_ELECT:
+				case APPLY_ENCHANT_FIRE:
+				case APPLY_ENCHANT_ICE:
+				case APPLY_ENCHANT_WIND:
+				case APPLY_ENCHANT_EARTH:
+				case APPLY_ENCHANT_DARK:
+					break;
+
+				default:
+				{
+					sys_err("CHARACTER::RefineElement: %s cannot change element with unsupported apply type.", GetName());
+					return;
+				}
+			}
+
+			const WORD wRefineElementApplyType = pDestItem->GetRefineElementApplyType();
+			if (wRefineElementApplyType == wChangeElement)
+			{
+				sys_err("CHARACTER::RefineElement: %s cannot change element with the current apply type.", GetName());
+				return;
+			}
+
+			pDestItem->ChangeRefineElement(wChangeElement);
+			kPacket.bResult = true;
+
+			PointChange(POINT_GOLD, -REFINE_ELEMENT_CHANGE_YANG);
+		}
+		break;
+
+		default:
+		{
+			sys_err("CHARACTER::RefineElement: %s cannot refine with unknown type.", GetName());
+			return;
+		}
+	}
+	kPacket.SrcPos = NPOS;
+	kPacket.DestPos = NPOS;
+	GetDesc()->Packet(&kPacket, sizeof(kPacket));
+
+	pSrcItem->SetCount(pSrcItem->GetCount() - 1);
+
+	SetUnderRefineElement(false);
+}
+
+WORD CHARACTER::GetRefineElementEffect() const
+{
+	const LPITEM pItemWeapon = GetWear(WEAR_WEAPON);
+	if ((pItemWeapon) && (pItemWeapon->GetRefineElementGrade() >= REFINE_ELEMENT_MAX))
+		return pItemWeapon->GetRefineElementApplyType();
+	return 0;
+}
+#endif
diff --git a/server/metin2/Source/Server/game/src/char_state.cpp b/server/metin2/Source/Server/game/src/char_state.cpp
index 0c344a8..061406a 100644
--- a/server/metin2/Source/Server/game/src/char_state.cpp
+++ b/server/metin2/Source/Server/game/src/char_state.cpp
@@ -1,1335 +1,1335 @@
-#include "stdafx.h"
-#include "config.h"
-#include "utils.h"
-#include "vector.h"
-#include "char.h"
-#include "battle.h"
-#include "char_manager.h"
-#include "packet.h"
-#include "motion.h"
-#include "party.h"
-#include "affect.h"
-#include "buffer_manager.h"
-#include "questmanager.h"
-#include "p2p.h"
-#include "item_manager.h"
-#include "mob_manager.h"
-#include "exchange.h"
-#include "sectree_manager.h"
-#include "xmas_event.h"
-#include "guild_manager.h"
-#include "war_map.h"
-#include "locale_service.h"
-#include "BlueDragon.h"
-#if defined(__DAWNMIST_DUNGEON__)
-#	include "dawnmist_dungeon.h"
-#endif
-#if defined(__DEFENSE_WAVE__)
-#	include "defense_wave.h"
-#endif
-
-#include "unique_mob.h"
-
-#include "../../common/VnumHelper.h"
-
-BOOL g_test_server;
-extern LPCHARACTER FindVictim(LPCHARACTER pkChr, int iMaxDistance);
-
-namespace
-{
-	class FuncFindChrForFlag
-	{
-	public:
-		FuncFindChrForFlag(LPCHARACTER pkChr) :
-			m_pkChr(pkChr), m_pkChrFind(NULL), m_iMinDistance(INT_MAX)
-		{
-		}
-
-		void operator () (LPENTITY ent)
-		{
-			if (!ent->IsType(ENTITY_CHARACTER))
-				return;
-
-			if (ent->IsObserverMode())
-				return;
-
-			LPCHARACTER pkChr = (LPCHARACTER)ent;
-
-			if (!pkChr->IsPC())
-				return;
-
-			if (!pkChr->GetGuild())
-				return;
-
-			if (pkChr->IsDead())
-				return;
-
-			int iDist = DISTANCE_APPROX(pkChr->GetX() - m_pkChr->GetX(), pkChr->GetY() - m_pkChr->GetY());
-
-			if (iDist <= 500 && m_iMinDistance > iDist &&
-				!pkChr->IsAffectFlag(AFF_WAR_FLAG1) &&
-				!pkChr->IsAffectFlag(AFF_WAR_FLAG2) &&
-				!pkChr->IsAffectFlag(AFF_WAR_FLAG3))
-			{
-				// ¿ì¸®Æí ±ê¹ßÀÏ °æ¿ì
-				if ((DWORD)m_pkChr->GetPoint(POINT_STAT) == pkChr->GetGuild()->GetID())
-				{
-					CWarMap* pMap = pkChr->GetWarMap();
-					BYTE idx;
-
-					if (!pMap || !pMap->GetTeamIndex(pkChr->GetGuild()->GetID(), idx))
-						return;
-
-					// ¿ì¸®Æí ±âÁö¿¡ ±ê¹ßÀÌ ¾øÀ» ¶§¸¸ ±ê¹ßÀ» »Ì´Â´Ù. ¾È±×·¯¸é ±âÁö¿¡ ÀÖ´Â ±ê¹ßÀ»
-					// °¡¸¸È÷ µÎ°í ½ÍÀºµ¥µµ »ÌÈú¼ö°¡ ÀÖÀ¸¹Ç·Î..
-					if (!pMap->IsFlagOnBase(idx))
-					{
-						m_pkChrFind = pkChr;
-						m_iMinDistance = iDist;
-					}
-				}
-				else
-				{
-					// »ó´ëÆí ±ê¹ßÀÎ °æ¿ì ¹«Á¶°Ç »Ì´Â´Ù.
-					m_pkChrFind = pkChr;
-					m_iMinDistance = iDist;
-				}
-			}
-		}
-
-		LPCHARACTER m_pkChr;
-		LPCHARACTER m_pkChrFind;
-		int m_iMinDistance;
-	};
-
-	class FuncFindChrForFlagBase
-	{
-	public:
-		FuncFindChrForFlagBase(LPCHARACTER pkChr) : m_pkChr(pkChr)
-		{
-		}
-
-		void operator () (LPENTITY ent)
-		{
-			if (!ent->IsType(ENTITY_CHARACTER))
-				return;
-
-			if (ent->IsObserverMode())
-				return;
-
-			LPCHARACTER pkChr = (LPCHARACTER)ent;
-
-			if (!pkChr->IsPC())
-				return;
-
-			CGuild* pkGuild = pkChr->GetGuild();
-
-			if (!pkGuild)
-				return;
-
-			int iDist = DISTANCE_APPROX(pkChr->GetX() - m_pkChr->GetX(), pkChr->GetY() - m_pkChr->GetY());
-
-			if (iDist <= 500 &&
-				(pkChr->IsAffectFlag(AFF_WAR_FLAG1) ||
-					pkChr->IsAffectFlag(AFF_WAR_FLAG2) ||
-					pkChr->IsAffectFlag(AFF_WAR_FLAG3)))
-			{
-				CAffect* pkAff = pkChr->FindAffect(AFFECT_WAR_FLAG);
-
-				sys_log(0, "FlagBase %s dist %d aff %p flag gid %d chr gid %u",
-					pkChr->GetName(), iDist, pkAff, m_pkChr->GetPoint(POINT_STAT),
-					pkChr->GetGuild()->GetID());
-
-				if (pkAff)
-				{
-					if ((DWORD)m_pkChr->GetPoint(POINT_STAT) == pkGuild->GetID() &&
-						m_pkChr->GetPoint(POINT_STAT) != pkAff->lApplyValue)
-					{
-						CWarMap* pMap = pkChr->GetWarMap();
-						BYTE idx;
-
-						if (!pMap || !pMap->GetTeamIndex(pkGuild->GetID(), idx))
-							return;
-
-						//if (pMap->IsFlagOnBase(idx))
-						{
-							BYTE idx_opp = idx == 0 ? 1 : 0;
-
-							SendGuildWarScore(m_pkChr->GetPoint(POINT_STAT), pkAff->lApplyValue, 1);
-							//SendGuildWarScore(pkAff->lApplyValue, m_pkChr->GetPoint(POINT_STAT), -1);
-
-							pMap->ResetFlag();
-							//pMap->AddFlag(idx_opp);
-							//pkChr->RemoveAffect(AFFECT_WAR_FLAG);
-
-							char buf[256];
-							snprintf(buf, sizeof(buf), LC_STRING("%s ±æµå°¡ %s ±æµåÀÇ ±ê¹ßÀ» »©¾Ñ¾Ò½À´Ï´Ù!", pMap->GetGuild(idx)->GetName(), pMap->GetGuild(idx_opp)->GetName()));
-							pMap->Notice(buf);
-						}
-					}
-				}
-			}
-		}
-
-		LPCHARACTER m_pkChr;
-	};
-
-	class FuncFindGuardVictim
-	{
-	public:
-		FuncFindGuardVictim(LPCHARACTER pkChr, int iMaxDistance) :
-			m_pkChr(pkChr),
-			m_iMinDistance(INT_MAX),
-			m_iMaxDistance(iMaxDistance),
-			m_lx(pkChr->GetX()),
-			m_ly(pkChr->GetY()),
-			m_pkChrVictim(NULL)
-		{
-		};
-
-		void operator () (LPENTITY ent)
-		{
-			if (!ent->IsType(ENTITY_CHARACTER))
-				return;
-
-			LPCHARACTER pkChr = (LPCHARACTER)ent;
-
-			// ÀÏ´Ü PC °ø°Ý¾ÈÇÔ
-			if (pkChr->IsPC())
-				return;
-
-			if (pkChr->IsNPC() && !pkChr->IsMonster())
-				return;
-
-			if (pkChr->IsDead())
-				return;
-
-			if (pkChr->IsAffectFlag(AFF_EUNHYUNG) ||
-				pkChr->IsAffectFlag(AFF_INVISIBILITY) ||
-				pkChr->IsAffectFlag(AFF_REVIVE_INVISIBLE))
-				return;
-
-			// ¿Ö±¸´Â ÆÐ½º
-			if (pkChr->GetRaceNum() == 5001)
-				return;
-
-			int iDistance = DISTANCE_APPROX(m_lx - pkChr->GetX(), m_ly - pkChr->GetY());
-
-			if (iDistance < m_iMinDistance && iDistance <= m_iMaxDistance)
-			{
-				m_pkChrVictim = pkChr;
-				m_iMinDistance = iDistance;
-			}
-		}
-
-		LPCHARACTER GetVictim()
-		{
-			return (m_pkChrVictim);
-		}
-
-	private:
-		LPCHARACTER m_pkChr;
-
-		int m_iMinDistance;
-		int m_iMaxDistance;
-		long m_lx;
-		long m_ly;
-
-		LPCHARACTER m_pkChrVictim;
-	};
-}
-
-bool CHARACTER::IsAggressive() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_AGGRESSIVE);
-}
-
-void CHARACTER::SetAggressive(bool bSet)
-{
-	if (bSet)
-		SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_AGGRESSIVE);
-	else
-		REMOVE_BIT(m_pointsInstant.dwAIFlag, AIFLAG_AGGRESSIVE);
-}
-
-bool CHARACTER::IsCoward() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_COWARD);
-}
-
-void CHARACTER::SetCoward()
-{
-	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_COWARD);
-}
-
-bool CHARACTER::IsBerserker() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_BERSERK);
-}
-
-bool CHARACTER::IsStoneSkinner() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_STONESKIN);
-}
-
-bool CHARACTER::IsGodSpeeder() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_GODSPEED);
-}
-
-bool CHARACTER::IsDeathBlower() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_DEATHBLOW);
-}
-
-bool CHARACTER::IsReviver() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_REVIVE);
-}
-
-bool CHARACTER::IsHealer() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_HEALER);
-}
-
-bool CHARACTER::IsFaller() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_FALL);
-}
-
-void CHARACTER::CowardEscape()
-{
-	int iDist[4] = { 500, 1000, 3000, 5000 };
-
-	for (int iDistIdx = 2; iDistIdx >= 0; --iDistIdx)
-		for (int iTryCount = 0; iTryCount < 8; ++iTryCount)
-		{
-			SetRotation(number(0, 359)); // ¹æÇâÀº ·£´ýÀ¸·Î ¼³Á¤
-
-			float fx, fy;
-			float fDist = number(iDist[iDistIdx], iDist[iDistIdx + 1]);
-
-			GetDeltaByDegree(GetRotation(), fDist, &fx, &fy);
-
-			bool bIsWayBlocked = false;
-			for (int j = 1; j <= 100; ++j)
-			{
-				if (!SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx * j / 100, GetY() + (int)fy * j / 100))
-				{
-					bIsWayBlocked = true;
-					break;
-				}
-			}
-
-			if (bIsWayBlocked)
-				continue;
-
-			m_dwStateDuration = PASSES_PER_SEC(1);
-
-			int iDestX = GetX() + (int)fx;
-			int iDestY = GetY() + (int)fy;
-
-			if (Goto(iDestX, iDestY))
-				SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
-
-			sys_log(0, "WAEGU move to %d %d (far)", iDestX, iDestY);
-			return;
-		}
-}
-
-void CHARACTER::SetNoAttackShinsu()
-{
-	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKSHINSU);
-}
-bool CHARACTER::IsNoAttackShinsu() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKSHINSU);
-}
-
-void CHARACTER::SetNoAttackChunjo()
-{
-	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKCHUNJO);
-}
-
-bool CHARACTER::IsNoAttackChunjo() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKCHUNJO);
-}
-
-void CHARACTER::SetNoAttackJinno()
-{
-	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKJINNO);
-}
-
-bool CHARACTER::IsNoAttackJinno() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKJINNO);
-}
-
-void CHARACTER::SetAttackMob()
-{
-	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_ATTACKMOB);
-}
-
-bool CHARACTER::IsAttackMob() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_ATTACKMOB);
-}
-
-void CHARACTER::SetNoMove()
-{
-	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_NOMOVE);
-}
-
-bool CHARACTER::IsNoMove() const
-{
-	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_NOMOVE);
-}
-
-// STATE_IDLE_REFACTORING
-void CHARACTER::StateIdle()
-{
-	if (IsStone())
-	{
-		__StateIdle_Stone();
-		return;
-	}
-	else if (IsWarp() || IsGoto())
-	{
-		// ¿öÇÁ´Â ÀÌº¥Æ®·Î Ã³¸®
-		m_dwStateDuration = 60 * passes_per_sec;
-		return;
-	}
-
-	if (IsPC())
-		return;
-
-	// NPC Ã³¸®
-	if (!IsMonster())
-	{
-		__StateIdle_NPC();
-		return;
-	}
-
-	__StateIdle_Monster();
-}
-
-void CHARACTER::__StateIdle_Stone()
-{
-	m_dwStateDuration = PASSES_PER_SEC(1);
-
-	int iPercent = 0;
-	if (GetMaxHP() >= 0)
-		iPercent = (GetHP() * 100) / GetMaxHP();
-
-	const DWORD dwVnum = number(MIN(GetMobTable().sAttackSpeed, GetMobTable().sMovingSpeed), MAX(GetMobTable().sAttackSpeed, GetMobTable().sMovingSpeed));
-	if (dwVnum == 0)
-		return;
-
-	if (iPercent <= 10 && GetMaxSP() < 10)
-	{
-		SetMaxSP(10);
-		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
-
-		CHARACTER_MANAGER::instance().SelectStone(this);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1500, GetY() - 1500, GetX() + 1500, GetY() + 1500);
-		CHARACTER_MANAGER::instance().SelectStone(NULL);
-	}
-	else if (iPercent <= 20 && GetMaxSP() < 9)
-	{
-		SetMaxSP(9);
-		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
-
-		CHARACTER_MANAGER::instance().SelectStone(this);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1500, GetY() - 1500, GetX() + 1500, GetY() + 1500);
-		CHARACTER_MANAGER::instance().SelectStone(NULL);
-	}
-	else if (iPercent <= 30 && GetMaxSP() < 8)
-	{
-		SetMaxSP(8);
-		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
-
-		CHARACTER_MANAGER::instance().SelectStone(this);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SelectStone(NULL);
-	}
-	else if (iPercent <= 40 && GetMaxSP() < 7)
-	{
-		SetMaxSP(7);
-		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
-
-		CHARACTER_MANAGER::instance().SelectStone(this);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SelectStone(NULL);
-	}
-	else if (iPercent <= 50 && GetMaxSP() < 6)
-	{
-		SetMaxSP(6);
-		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
-
-		CHARACTER_MANAGER::instance().SelectStone(this);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SelectStone(NULL);
-	}
-	else if (iPercent <= 60 && GetMaxSP() < 5)
-	{
-		SetMaxSP(5);
-		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
-
-		CHARACTER_MANAGER::instance().SelectStone(this);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
-		CHARACTER_MANAGER::instance().SelectStone(NULL);
-	}
-	else if (iPercent <= 70 && GetMaxSP() < 4)
-	{
-		SetMaxSP(4);
-		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
-
-		CHARACTER_MANAGER::instance().SelectStone(this);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SelectStone(NULL);
-	}
-	else if (iPercent <= 80 && GetMaxSP() < 3)
-	{
-		SetMaxSP(3);
-		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
-
-		CHARACTER_MANAGER::instance().SelectStone(this);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SelectStone(NULL);
-	}
-	else if (iPercent <= 90 && GetMaxSP() < 2)
-	{
-		SetMaxSP(2);
-		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
-
-		CHARACTER_MANAGER::instance().SelectStone(this);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
-		CHARACTER_MANAGER::instance().SelectStone(NULL);
-	}
-	else if (iPercent <= 99 && GetMaxSP() < 1)
-	{
-		SetMaxSP(1);
-		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
-
-		CHARACTER_MANAGER::instance().SelectStone(this);
-		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
-		CHARACTER_MANAGER::instance().SelectStone(NULL);
-	}
-	else
-		return;
-
-	UpdatePacket();
-	return;
-}
-
-void CHARACTER::__StateIdle_NPC()
-{
-	MonsterChat(MONSTER_CHAT_WAIT);
-	m_dwStateDuration = PASSES_PER_SEC(5);
-
-#if defined(__PET_SYSTEM__)
-	// Æê ½Ã½ºÅÛÀÇ Idle Ã³¸®´Â ±âÁ¸ °ÅÀÇ ¸ðµç Á¾·ùÀÇ Ä³¸¯ÅÍµéÀÌ °øÀ¯ÇØ¼­ »ç¿ëÇÏ´Â »óÅÂ¸Ó½ÅÀÌ ¾Æ´Ñ CPetActor::Update¿¡¼­ Ã³¸®ÇÔ.
-	if (IsPet())
-		return;
-#endif
-
-#if defined(__GROWTH_PET_SYSTEM__)
-	if (IsGrowthPet())
-		return;
-#endif
-
-	if (IsGuardNPC())
-	{
-		if (!quest::CQuestManager::instance().GetEventFlag("noguard"))
-		{
-			FuncFindGuardVictim f(this, 50000);
-
-			if (GetSectree())
-				GetSectree()->ForEachAround(f);
-
-			LPCHARACTER victim = f.GetVictim();
-
-			if (victim)
-			{
-				m_dwStateDuration = passes_per_sec / 2;
-
-				if (CanBeginFight())
-					BeginFight(victim);
-			}
-		}
-	}
-	else
-	{
-#if defined(__XMAS_EVENT_2008__)
-		if (GetRaceNum() == xmas::MOB_XMAS_SANTA_VNUM) // »êÅ¸
-		{
-			if (get_dword_time() > m_dwPlayStartTime)
-			{
-				int next_warp_time = 2 * 1000; // 2ÃÊ
-
-				m_dwPlayStartTime = get_dword_time() + next_warp_time;
-
-				// ½Ã°£ÀÌ ³Ñ¾úÀ¸´Ï ¿öÇÁÇÕ½Ã´Ù.
-				// »êÅ¸¿ë
-				/*
-				const int WARP_MAP_INDEX_NUM = 4;
-				static const long c_lWarpMapIndexs[WARP_MAP_INDEX_NUM] = { 61, 62, 63, 64 };
-				*/
-				// ½Å¼±ÀÚ ³ëÇØ¿ë
-				const int WARP_MAP_INDEX_NUM = 7;
-				static const long c_lWarpMapIndexs[WARP_MAP_INDEX_NUM] = { MAP_N_SNOWM_01, MAP_N_FLAME_01, MAP_N_DESERT_01, MAP_N_THREEWAY, MAP_A3, MAP_B3, MAP_C3 };
-				long lNextMapIndex = c_lWarpMapIndexs[number(1, WARP_MAP_INDEX_NUM) - 1];
-
-				if (map_allow_find(lNextMapIndex))
-				{
-					// ÀÌ°÷ÀÔ´Ï´Ù.
-					M2_DESTROY_CHARACTER(this);
-
-					int iNextSpawnDelay = 1;
-					if (LC_IsYMIR())
-						iNextSpawnDelay = 20 * 60;
-					else
-						iNextSpawnDelay = 50 * 60;
-
-					xmas::SpawnSanta(lNextMapIndex, iNextSpawnDelay);
-				}
-				else
-				{
-					// ´Ù¸¥ ¼­¹ö ÀÔ´Ï´Ù.
-					TPacketGGXmasWarpSanta p;
-					p.bHeader = HEADER_GG_XMAS_WARP_SANTA;
-					p.bChannel = g_bChannel;
-					p.lMapIndex = lNextMapIndex;
-					P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGXmasWarpSanta));
-				}
-				return;
-			}
-		}
-#endif
-
-		if (!IsNoMove())
-		{
-			//
-			// ÀÌ °÷ Àú °÷ ÀÌµ¿ÇÑ´Ù.
-			//
-			LPCHARACTER pkChrProtege = GetProtege();
-
-			if (pkChrProtege)
-			{
-				if (DISTANCE_APPROX(GetX() - pkChrProtege->GetX(), GetY() - pkChrProtege->GetY()) > 500)
-				{
-					if (Follow(pkChrProtege, number(100, 300)))
-						return;
-				}
-			}
-
-			if (!number(0, 6))
-			{
-				SetRotation(number(0, 359)); // ¹æÇâÀº ·£´ýÀ¸·Î ¼³Á¤
-
-				float fx, fy;
-				float fDist = number(200, 400);
-
-				GetDeltaByDegree(GetRotation(), fDist, &fx, &fy);
-
-				// ´À½¼ÇÑ ¸ø°¨ ¼Ó¼º Ã¼Å©; ÃÖÁ¾ À§Ä¡¿Í Áß°£ À§Ä¡°¡ °¥¼ö¾ø´Ù¸é °¡Áö ¾Ê´Â´Ù.
-				if (!(SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx, GetY() + (int)fy)
-					&& SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx / 2, GetY() + (int)fy / 2)))
-					return;
-
-				SetNowWalking(true);
-
-				if (Goto(GetX() + (int)fx, GetY() + (int)fy))
-					SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
-
-				return;
-			}
-		}
-	}
-}
-
-void CHARACTER::__StateIdle_Monster()
-{
-	if (IsStun())
-		return;
-
-	if (!CanMove())
-		return;
-
-	if (IsCoward())
-	{
-		// °ÌÀïÀÌ ¸ó½ºÅÍ´Â µµ¸Á¸¸ ´Ù´Õ´Ï´Ù.
-		if (!IsDead())
-			CowardEscape();
-
-		return;
-	}
-
-	if (IsBerserker())
-		if (IsBerserk())
-			SetBerserk(false);
-
-	if (IsGodSpeeder())
-		if (IsGodSpeed())
-			SetGodSpeed(false);
-
-	LPCHARACTER victim = GetVictim();
-
-	if (!victim || victim->IsDead())
-	{
-		SetVictim(NULL);
-		victim = NULL;
-		m_dwStateDuration = PASSES_PER_SEC(1);
-	}
-
-	if (!victim || victim->IsBuilding())
-	{
-		// µ¹ º¸È£ Ã³¸®
-		if (m_pkChrStone)
-		{
-			victim = m_pkChrStone->GetNearestVictim(m_pkChrStone);
-		}
-		else if (!no_wander && IsAggressive())
-		{
-#if defined(__XMAS_EVENT_2008__)
-			if (GetMapIndex() == MAP_N_SNOWM_01 && quest::CQuestManager::instance().GetEventFlag("xmas_tree"));
-			// ¼­ÇÑ»ê¿¡¼­ ³ª¹«°¡ ÀÖÀ¸¸é ¼±°øÇÏÁö¾Ê´Â´Ù.
-			else
-#endif
-			{
-				victim = FindVictim(this, m_pkMobData->m_table.wAggressiveSight);
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-				if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()))
-					victim = FindVictim(this, 40000);
-#endif
-			}
-		}
-	}
-
-	if (victim && !victim->IsDead())
-	{
-		if (CanBeginFight())
-			BeginFight(victim);
-
-		return;
-	}
-
-	if (IsAggressive() && !victim)
-		m_dwStateDuration = PASSES_PER_SEC(number(1, 3));
-	else
-		m_dwStateDuration = PASSES_PER_SEC(number(3, 5));
-
-	LPCHARACTER pkChrProtege = GetProtege();
-
-	// º¸È£ÇÒ °Í(µ¹, ÆÄÆ¼Àå)¿¡°Ô·Î ºÎÅÍ ¸Ö´Ù¸é µû¶ó°£´Ù.
-	if (pkChrProtege)
-	{
-		if (DISTANCE_APPROX(GetX() - pkChrProtege->GetX(), GetY() - pkChrProtege->GetY()) > 1000)
-		{
-			if (Follow(pkChrProtege, number(150, 400)))
-			{
-				MonsterLog("[IDLE] ¸®´õ·ÎºÎÅÍ ³Ê¹« ¸Ö¸® ¶³¾îÁ³´Ù! º¹±ÍÇÑ´Ù.");
-				return;
-			}
-		}
-	}
-
-	//
-	// ±×³É ¿Ô´Ù¸® °¬´Ù¸® ÇÑ´Ù.
-	//
-	if (!no_wander && !IsNoMove())
-	{
-		if (!number(0, 6))
-		{
-			SetRotation(number(0, 359)); // ¹æÇâÀº ·£´ýÀ¸·Î ¼³Á¤
-
-			float fx, fy;
-			float fDist = number(300, 700);
-
-			GetDeltaByDegree(GetRotation(), fDist, &fx, &fy);
-
-			// ´À½¼ÇÑ ¸ø°¨ ¼Ó¼º Ã¼Å©; ÃÖÁ¾ À§Ä¡¿Í Áß°£ À§Ä¡°¡ °¥¼ö¾ø´Ù¸é °¡Áö ¾Ê´Â´Ù.
-			if (!(SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx, GetY() + (int)fy)
-				&& SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx / 2, GetY() + (int)fy / 2)))
-				return;
-
-			// NOTE: When a monster wanders around in IDLE state, it currently runs unconditionally. (Never walk)
-			// The graphics team wants to see the monsters walking, so they temporarily walk or run with a certain probability.
-			{
-				// Aggressive monsters will always run.
-				if (IsAggressive())
-					SetNowWalking(false);
-				else
-				{
-					// Given the probability, monsters will walk or run depending on their fight state.
-					if ((number(0, 100) < 60) || CanFight())
-						SetNowWalking(false);
-					else
-						SetNowWalking(true);
-				}
-			}
-
-			if (Goto(GetX() + (int)fx, GetY() + (int)fy))
-				SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
-
-			return;
-		}
-	}
-
-	MonsterChat(MONSTER_CHAT_WAIT);
-}
-// END_OF_STATE_IDLE_REFACTORING
-
-bool __CHARACTER_GotoNearTarget(LPCHARACTER self, LPCHARACTER victim)
-{
-	if (self->IsNoMove())
-		return false;
-
-	switch (self->GetMobBattleType())
-	{
-		case BATTLE_TYPE_RANGE:
-		case BATTLE_TYPE_MAGIC:
-			// ¸¶¹ý»ç³ª ±Ã¼ö´Â °ø°Ý °Å¸®ÀÇ 80%±îÁö °¡¼­ °ø°ÝÀ» ½ÃÀÛÇÑ´Ù.
-			if (self->Follow(victim, self->GetMobAttackRange() * 8 / 10))
-				return true;
-			break;
-
-		default:
-			// ³ª¸ÓÁö´Â 90%?
-			if (self->Follow(victim, self->GetMobAttackRange() * 9 / 10))
-				return true;
-	}
-
-	return false;
-}
-
-void CHARACTER::StateMove()
-{
-	float fRate = 1.0f;
-	
-	const DWORD dwElapsedTime = get_dword_time() - m_dwMoveStartTime;
-	if (dwElapsedTime != 0 && m_dwMoveStartTime != 0)
-		fRate = static_cast<float>(dwElapsedTime) / static_cast<float>(m_dwMoveDuration);
-
-	if (fRate > 1.0f)
-		fRate = 1.0f;
-
-	const int x = static_cast<int>(static_cast<float>(m_posDest.x - m_posStart.x) * fRate + m_posStart.x);
-	const int y = static_cast<int>(static_cast<float>(m_posDest.y - m_posStart.y) * fRate + m_posStart.y);
-
-	Move(x, y);
-
-	if (IsPC() && (thecore_pulse() & 15) == 0)
-	{
-		UpdateSectree();
-
-		if (GetExchange())
-		{
-			const LPCHARACTER& victim = GetExchange()->GetCompany()->GetOwner();
-			const int iDist = DISTANCE_APPROX(GetX() - victim->GetX(), GetY() - victim->GetY());
-
-			// °Å¸® Ã¼Å©
-			if (iDist >= EXCHANGE_MAX_DISTANCE)
-			{
-				GetExchange()->Cancel();
-			}
-		}
-	}
-
-	// ½ºÅ×¹Ì³ª°¡ 0 ÀÌ»óÀÌ¾î¾ß ÇÑ´Ù.
-	if (IsPC())
-	{
-		if (IsWalking() && GetStamina() < GetMaxStamina())
-		{
-			// 5ÃÊ ÈÄ ºÎÅÍ ½ºÅ×¹Ì³Ê Áõ°¡
-			if (get_dword_time() - GetWalkStartTime() > 5000)
-				PointChange(POINT_STAMINA, GetMaxStamina() / 1);
-		}
-
-		// ÀüÅõ ÁßÀÌ¸é¼­ ¶Ù´Â ÁßÀÌ¸é
-		if (!IsWalking() && !IsRiding())
-		{
-			if ((get_dword_time() - GetLastAttackTime()) < 20000)
-			{
-				StartAffectEvent();
-
-				PointChange(POINT_STAMINA, -STAMINA_PER_STEP);
-
-				StartStaminaConsume();
-
-				if (GetStamina() <= 0)
-				{
-					// ½ºÅ×¹Ì³ª°¡ ¸ðÀÚ¶ó °É¾î¾ßÇÔ
-					SetStamina(0);
-					SetNowWalking(true);
-					StopStaminaConsume();
-				}
-			}
-			else if (IsStaminaConsume())
-			{
-				StopStaminaConsume();
-			}
-		}
-	}
-	else
-	{
-		// XXX AGGRO
-		if (IsMonster() && GetVictim())
-		{
-			LPCHARACTER victim = GetVictim();
-			if (victim && !victim->IsInSafezone())
-				UpdateAggrPoint(victim, DAMAGE_TYPE_NORMAL, -(victim->GetLevel() / 3 + 1));
-
-			if (g_test_server)
-			{
-				// ¸ó½ºÅÍ°¡ ÀûÀ» ÂÑ¾Æ°¡´Â °ÍÀÌ¸é ¹«Á¶°Ç ¶Ù¾î°£´Ù.
-				SetNowWalking(false);
-			}
-		}
-
-		if (IsMonster() && GetMobRank() >= MOB_RANK_BOSS && GetVictim())
-		{
-			LPCHARACTER victim = GetVictim();
-
-			// °Å´ë °ÅºÏ
-			if ((GetRaceNum() == 2191 || GetRaceNum() == 2192) && number(1, 20) == 1 && get_dword_time() - m_pkMobInst->m_dwLastWarpTime > 1000)
-			{
-				// ¿öÇÁ Å×½ºÆ®
-				float fx, fy;
-				GetDeltaByDegree(victim->GetRotation(), 400, &fx, &fy);
-				long new_x = victim->GetX() + (long)fx;
-				long new_y = victim->GetY() + (long)fy;
-				if (!IsInSafezone())
-				{
-					SetRotation(GetDegreeFromPositionXY(new_x, new_y, victim->GetX(), victim->GetY()));
-					Show(victim->GetMapIndex(), new_x, new_y, 0, true);
-					GotoState(m_stateBattle);
-					m_dwStateDuration = 1;
-					ResetMobSkillCooltime();
-					m_pkMobInst->m_dwLastWarpTime = get_dword_time();
-					return;
-				}
-			}
-
-			// TODO ¹æÇâÀüÈ¯À» ÇØ¼­ ´ú ¹Ùº¸°¡ µÇÀÚ!
-			if (number(0, 3) == 0 && (victim && !victim->IsInSafezone()))
-			{
-				if (__CHARACTER_GotoNearTarget(this, victim))
-					return;
-			}
-		}
-	}
-
-	if (1.0f == fRate)
-	{
-		if (IsPC())
-		{
-			sys_log(1, "µµÂø %s %d %d", GetName(), x, y);
-			GotoState(m_stateIdle);
-			StopStaminaConsume();
-		}
-		else
-		{
-			if (GetVictim() && !IsCoward())
-			{
-				if (!IsState(m_stateBattle))
-					MonsterLog("[BATTLE] ±ÙÃ³¿¡ ¿ÔÀ¸´Ï °ø°Ý½ÃÀÛ %s", GetVictim()->GetName());
-
-				GotoState(m_stateBattle);
-				m_dwStateDuration = 1;
-			}
-			else
-			{
-				if (!IsState(m_stateIdle))
-					MonsterLog("[IDLE] ´ë»óÀÌ ¾øÀ¸´Ï ½¬ÀÚ");
-
-				GotoState(m_stateIdle);
-
-				//LPCHARACTER rider = GetRider();
-
-				m_dwStateDuration = PASSES_PER_SEC(number(1, 3));
-			}
-		}
-	}
-}
-
-void CHARACTER::StateBattle()
-{
-	if (IsStone())
-	{
-		sys_err("Stone must not use battle state (name %s)", GetName());
-		return;
-	}
-
-	if (IsPC())
-		return;
-
-	if (!CanMove())
-		return;
-
-	if (IsStun())
-		return;
-
-	LPCHARACTER victim = GetVictim();
-
-	if (IsCoward())
-	{
-		if (IsDead())
-			return;
-
-		SetVictim(NULL);
-
-		if (number(1, 50) != 1)
-		{
-			GotoState(m_stateIdle);
-			m_dwStateDuration = 1;
-		}
-		else
-			CowardEscape();
-
-		return;
-	}
-
-	if (!victim || (victim->IsStun() && IsGuardNPC()) || victim->IsDead())
-	{
-		if (victim && victim->IsDead() &&
-			!no_wander && IsAggressive() && (!GetParty() || GetParty()->GetLeader() == this))
-		{
-			LPCHARACTER new_victim = FindVictim(this, m_pkMobData->m_table.wAggressiveSight);
-
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-			if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()))
-				new_victim = FindVictim(this, 40000);
-#endif
-
-			SetVictim(new_victim);
-			m_dwStateDuration = PASSES_PER_SEC(1);
-
-			if (!new_victim)
-			{
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-				if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()))
-					return;
-#endif
-
-				switch (GetMobBattleType())
-				{
-					case BATTLE_TYPE_MELEE:
-					case BATTLE_TYPE_SUPER_POWER:
-					case BATTLE_TYPE_SUPER_TANKER:
-					case BATTLE_TYPE_POWER:
-					case BATTLE_TYPE_TANKER:
-					{
-						float fx, fy;
-						float fDist = number(400, 1500);
-
-						GetDeltaByDegree(number(0, 359), fDist, &fx, &fy);
-
-						if (SECTREE_MANAGER::instance().IsMovablePosition(victim->GetMapIndex(),
-							victim->GetX() + (int)fx,
-							victim->GetY() + (int)fy) &&
-							SECTREE_MANAGER::instance().IsMovablePosition(victim->GetMapIndex(),
-								victim->GetX() + (int)fx / 2,
-								victim->GetY() + (int)fy / 2))
-						{
-							float dx = victim->GetX() + fx;
-							float dy = victim->GetY() + fy;
-
-							SetRotation(GetDegreeFromPosition(dx, dy));
-
-							if (Goto((long)dx, (long)dy))
-							{
-								sys_log(0, "KILL_AND_GO: %s distance %.1f", GetName(), fDist);
-								SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
-							}
-						}
-					}
-				}
-			}
-			return;
-		}
-
-		SetVictim(NULL);
-
-		if (IsGuardNPC())
-			Return();
-
-		m_dwStateDuration = PASSES_PER_SEC(1);
-		return;
-	}
-
-	if (CanSummonMonster() && !IsDead() && !IsStun())
-	{
-		if (!GetParty())
-		{
-			// ¼­¸óÇØ¼­ Ã¤¿öµÑ ÆÄÆ¼¸¦ ¸¸µé¾î µÓ´Ï´Ù.
-			CPartyManager::instance().CreateParty(this);
-		}
-
-		LPPARTY pParty = GetParty();
-		bool bPct = !number(0, 3);
-
-		if (bPct)
-		{
-			if (pParty->CountMemberByVnum(GetSummonVnum()) < SUMMON_MONSTER_COUNT)
-			{
-				MonsterLog("ºÎÇÏ ¸ó½ºÅÍ ¼ÒÈ¯!");
-				// ¸ðÀÚ¶ó´Â ³à¼®À» ºÒ·¯³» Ã¤¿ó½Ã´Ù.
-				int sx = GetX() - 300;
-				int sy = GetY() - 300;
-				int ex = GetX() + 300;
-				int ey = GetY() + 300;
-
-				LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRange(GetSummonVnum(), GetMapIndex(), sx, sy, ex, ey, true, true);
-
-				if (tch)
-				{
-					pParty->Join(tch->GetVID());
-					pParty->Link(tch);
-				}
-			}
-			else
-				MarkSummonedMonster();
-		}
-	}
-
-#if defined(__DAWNMIST_DUNGEON__)
-	if (CDawnMistDungeon::Instance().IsBoss(this))
-		if (!IsDead() && CDawnMistDungeon::Instance().CanSpawnHealerGroup(this))
-			CDawnMistDungeon::Instance().SpawnHealerGroup(this);
-#endif
-
-	LPCHARACTER pkChrProtege = GetProtege();
-
-	float fDist = DISTANCE_APPROX(GetX() - victim->GetX(), GetY() - victim->GetY());
-	if (fDist >= 4000.0f) // 40¹ÌÅÍ ÀÌ»ó ¸Ö¾îÁö¸é Æ÷±â
-	{
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-		if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()) && fDist < 16000.0f) { /* continue */ }
-		else
-#else
-		if (bPass)
-#endif
-		{
-			MonsterLog("Å¸°ÙÀÌ ¸Ö¾î¼­ Æ÷±â");
-			SetVictim(NULL);
-
-			// º¸È£ÇÒ °Í(µ¹, ÆÄÆ¼Àå) ÁÖº¯À¸·Î °£´Ù.
-			if (pkChrProtege && !pkChrProtege->IsInSafezone())
-				if (DISTANCE_APPROX(GetX() - pkChrProtege->GetX(), GetY() - pkChrProtege->GetY()) > 1000)
-					Follow(pkChrProtege, (float)number(150, 400));
-
-			return;
-		}
-	}
-
-	if (fDist >= (GetMobAttackRange() * 1.15) && !victim->IsInSafezone())
-	{
-		__CHARACTER_GotoNearTarget(this, victim);
-		return;
-	}
-
-	if (m_pkParty)
-		m_pkParty->SendMessage(this, PM_ATTACKED_BY, 0, 0);
-
-#if defined(__BLUE_DRAGON_RENEWAL__)
-	if (BlueDragon_IsBoss(m_pkMobData->m_table.dwVnum))
-#else
-	if (BlueDragon::BossVnum == m_pkMobData->m_table.dwVnum)
-#endif
-	{
-		// ¼ö·æ(2493) Æ¯¼ö Ã³¸®
-		m_dwStateDuration = BlueDragon_StateBattle(this);
-		return;
-	}
-
-	DWORD dwCurTime = get_dword_time();
-	DWORD dwDuration = CalculateDuration(GetLimitPoint(POINT_ATT_SPEED), 2000);
-
-	if ((dwCurTime - m_dwLastAttackTime) < dwDuration) // 2ÃÊ ¸¶´Ù °ø°ÝÇØ¾ß ÇÑ´Ù.
-	{
-		m_dwStateDuration = MAX(1, (passes_per_sec * (dwDuration - (dwCurTime - m_dwLastAttackTime)) / 1000));
-		return;
-	}
-
-	if (IsBerserker() == true)
-		if (GetHPPct() < m_pkMobData->m_table.bBerserkPoint)
-			if (IsBerserk() != true)
-				SetBerserk(true);
-
-	if (IsGodSpeeder() == true)
-		if (GetHPPct() < m_pkMobData->m_table.bGodSpeedPoint)
-			if (IsGodSpeed() != true)
-				SetGodSpeed(true);
-
-	//
-	// ¸÷ ½ºÅ³ Ã³¸®
-	//
-	if (HasMobSkill())
-	{
-		if (!victim || (victim && !victim->IsInSafezone()) || (pkChrProtege && !pkChrProtege->IsInSafezone()))
-		{
-			for (unsigned int iSkillIdx = 0; iSkillIdx < MOB_SKILL_MAX_NUM; ++iSkillIdx)
-			{
-				if (CanUseMobSkill(iSkillIdx))
-				{
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-					if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()) && GetGuildDragonLair())
-						SetRotationToXY(GetGuildDragonLair()->GetCenterX(), GetGuildDragonLair()->GetCenterY());
-					else
-						SetRotationToXY(victim->GetX(), victim->GetY());
-#else
-					SetRotationToXY(victim->GetX(), victim->GetY());
-#endif
-
-					if (UseMobSkill(iSkillIdx))
-					{
-						SendMovePacket(FUNC_MOB_SKILL, iSkillIdx, GetX(), GetY(), 0, dwCurTime);
-
-						float fDuration = CMotionManager::instance().GetMotionDuration(GetRaceNum(), MAKE_MOTION_KEY(MOTION_MODE_GENERAL, MOTION_SPECIAL_1 + iSkillIdx));
-						m_dwStateDuration = (DWORD)(fDuration == 0.0f ? PASSES_PER_SEC(2) : PASSES_PER_SEC(fDuration));
-
-						if (test_server)
-							sys_log(0, "USE_MOB_SKILL: %s idx %u motion %u duration %.0f", GetName(), iSkillIdx, MOTION_SPECIAL_1 + iSkillIdx, fDuration);
-
-						return;
-					}
-				}
-			}
-		}
-	}
-
-	if (!victim->IsInSafezone() && !Attack(victim)) // °ø°Ý ½ÇÆÐ¶ó¸é? ¿Ö ½ÇÆÐÇßÁö? TODO
-		m_dwStateDuration = passes_per_sec / 2;
-	else
-	{
-		if (!victim->IsInSafezone())
-		{
-			// ÀûÀ» ¹Ù¶óº¸°Ô ¸¸µç´Ù.
-			SetRotationToXY(victim->GetX(), victim->GetY());
-
-			SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0, dwCurTime);
-
-			float fDuration = CMotionManager::instance().GetMotionDuration(GetRaceNum(), MAKE_MOTION_KEY(MOTION_MODE_GENERAL, MOTION_NORMAL_ATTACK));
-			m_dwStateDuration = (DWORD)(fDuration == 0.0f ? PASSES_PER_SEC(2) : PASSES_PER_SEC(fDuration));
-		}
-	}
-}
-
-void CHARACTER::StateFlag()
-{
-	m_dwStateDuration = (DWORD)PASSES_PER_SEC(0.5);
-
-	CWarMap* pMap = GetWarMap();
-
-	if (!pMap)
-		return;
-
-	FuncFindChrForFlag f(this);
-	GetSectree()->ForEachAround(f);
-
-	if (!f.m_pkChrFind)
-		return;
-
-	if (NULL == f.m_pkChrFind->GetGuild())
-		return;
-
-	char buf[256];
-	BYTE idx;
-
-	if (!pMap->GetTeamIndex(GetPoint(POINT_STAT), idx))
-		return;
-
-	f.m_pkChrFind->AddAffect(AFFECT_WAR_FLAG, POINT_NONE, GetPoint(POINT_STAT), idx == 0 ? AFF_WAR_FLAG1 : AFF_WAR_FLAG2, INFINITE_AFFECT_DURATION, 0, false);
-	f.m_pkChrFind->AddAffect(AFFECT_WAR_FLAG, POINT_MOV_SPEED, 50 - f.m_pkChrFind->GetPoint(POINT_MOV_SPEED), 0, INFINITE_AFFECT_DURATION, 0, false);
-
-	pMap->RemoveFlag(idx);
-
-	snprintf(buf, sizeof(buf), LC_STRING("%s ±æµåÀÇ ±ê¹ßÀ» %s ´ÔÀÌ È¹µæÇÏ¿´½À´Ï´Ù.", pMap->GetGuild(idx)->GetName(), f.m_pkChrFind->GetName()));
-	pMap->Notice(buf);
-}
-
-void CHARACTER::StateFlagBase()
-{
-	m_dwStateDuration = (DWORD)PASSES_PER_SEC(0.5);
-
-	FuncFindChrForFlagBase f(this);
-	GetSectree()->ForEachAround(f);
-}
-
-void CHARACTER::StateHorse()
-{
-	float START_FOLLOW_DISTANCE = 400.0f; // ÀÌ °Å¸® ÀÌ»ó ¶³¾îÁö¸é ÂÑ¾Æ°¡±â ½ÃÀÛÇÔ
-	float START_RUN_DISTANCE = 700.0f; // ÀÌ °Å¸® ÀÌ»ó ¶³¾îÁö¸é ¶Ù¾î¼­ ÂÑ¾Æ°¨.
-	int MIN_APPROACH = 150; // ÃÖ¼Ò Á¢±Ù °Å¸®
-	int MAX_APPROACH = 300; // ÃÖ´ë Á¢±Ù °Å¸®
-
-	DWORD STATE_DURATION = (DWORD)PASSES_PER_SEC(0.5); // »óÅÂ Áö¼Ó ½Ã°£
-
-	bool bDoMoveAlone = true; // Ä³¸¯ÅÍ¿Í °¡±îÀÌ ÀÖÀ» ¶§ È¥ÀÚ ¿©±âÀú±â ¿òÁ÷ÀÏ°ÇÁö ¿©ºÎ -_-;
-	bool bRun = true; // ¶Ù¾î¾ß ÇÏ³ª?
-
-	if (IsDead())
-		return;
-
-	m_dwStateDuration = STATE_DURATION;
-
-	LPCHARACTER victim = GetRider();
-
-	// ! ¾Æ´Ô // ´ë»óÀÌ ¾ø´Â °æ¿ì ¼ÒÈ¯ÀÚ°¡ Á÷Á¢ ³ª¸¦ Å¬¸®¾îÇÒ °ÍÀÓ
-	if (!victim)
-	{
-		M2_DESTROY_CHARACTER(this);
-		return;
-	}
-
-	m_pkMobInst->m_posLastAttacked = GetXYZ();
-
-	float fDist = DISTANCE_APPROX(GetX() - victim->GetX(), GetY() - victim->GetY());
-
-	if (fDist >= START_FOLLOW_DISTANCE)
-	{
-		if (fDist > START_RUN_DISTANCE)
-			SetNowWalking(!bRun); // NOTE : ÇÔ¼ö ÀÌ¸§º¸°í ¸ØÃß´Â°ÇÁÙ ¾Ë¾Ò´Âµ¥ SetNowWalking(false) ÇÏ¸é ¶Ù´Â°ÅÀÓ.. -_-;
-
-		Follow(victim, number(MIN_APPROACH, MAX_APPROACH));
-
-		m_dwStateDuration = STATE_DURATION;
-	}
-	else if (bDoMoveAlone && (get_dword_time() > m_dwLastAttackTime))
-	{
-		// wondering -.-
-		m_dwLastAttackTime = get_dword_time() + number(5000, 12000);
-
-		SetRotation(number(0, 359)); // ¹æÇâÀº ·£´ýÀ¸·Î ¼³Á¤
-
-		float fx, fy;
-		float fDist = number(200, 400);
-
-		GetDeltaByDegree(GetRotation(), fDist, &fx, &fy);
-
-		// ´À½¼ÇÑ ¸ø°¨ ¼Ó¼º Ã¼Å©; ÃÖÁ¾ À§Ä¡¿Í Áß°£ À§Ä¡°¡ °¥¼ö¾ø´Ù¸é °¡Áö ¾Ê´Â´Ù.
-		if (!(SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx, GetY() + (int)fy)
-			&& SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx / 2, GetY() + (int)fy / 2)))
-			return;
-
-		SetNowWalking(true);
-
-		if (Goto(GetX() + (int)fx, GetY() + (int)fy))
-			SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
-	}
-}
+#include "stdafx.h"
+#include "config.h"
+#include "utils.h"
+#include "vector.h"
+#include "char.h"
+#include "battle.h"
+#include "char_manager.h"
+#include "packet.h"
+#include "motion.h"
+#include "party.h"
+#include "affect.h"
+#include "buffer_manager.h"
+#include "questmanager.h"
+#include "p2p.h"
+#include "item_manager.h"
+#include "mob_manager.h"
+#include "exchange.h"
+#include "sectree_manager.h"
+#include "xmas_event.h"
+#include "guild_manager.h"
+#include "war_map.h"
+#include "locale_service.h"
+#include "BlueDragon.h"
+#if defined(__DAWNMIST_DUNGEON__)
+#	include "dawnmist_dungeon.h"
+#endif
+#if defined(__DEFENSE_WAVE__)
+#	include "defense_wave.h"
+#endif
+
+#include "unique_mob.h"
+
+#include "../../common/VnumHelper.h"
+
+BOOL g_test_server;
+extern LPCHARACTER FindVictim(LPCHARACTER pkChr, int iMaxDistance);
+
+namespace
+{
+	class FuncFindChrForFlag
+	{
+	public:
+		FuncFindChrForFlag(LPCHARACTER pkChr) :
+			m_pkChr(pkChr), m_pkChrFind(NULL), m_iMinDistance(INT_MAX)
+		{
+		}
+
+		void operator () (LPENTITY ent)
+		{
+			if (!ent->IsType(ENTITY_CHARACTER))
+				return;
+
+			if (ent->IsObserverMode())
+				return;
+
+			LPCHARACTER pkChr = (LPCHARACTER)ent;
+
+			if (!pkChr->IsPC())
+				return;
+
+			if (!pkChr->GetGuild())
+				return;
+
+			if (pkChr->IsDead())
+				return;
+
+			int iDist = DISTANCE_APPROX(pkChr->GetX() - m_pkChr->GetX(), pkChr->GetY() - m_pkChr->GetY());
+
+			if (iDist <= 500 && m_iMinDistance > iDist &&
+				!pkChr->IsAffectFlag(AFF_WAR_FLAG1) &&
+				!pkChr->IsAffectFlag(AFF_WAR_FLAG2) &&
+				!pkChr->IsAffectFlag(AFF_WAR_FLAG3))
+			{
+				// ï¿½ì¸®ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½
+				if ((DWORD)m_pkChr->GetPoint(POINT_STAT) == pkChr->GetGuild()->GetID())
+				{
+					CWarMap* pMap = pkChr->GetWarMap();
+					BYTE idx;
+
+					if (!pMap || !pMap->GetTeamIndex(pkChr->GetGuild()->GetID(), idx))
+						return;
+
+					// ï¿½ì¸®ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ì´Â´ï¿½. ï¿½È±×·ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ö´ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½
+					// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Î°ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ç·ï¿½..
+					if (!pMap->IsFlagOnBase(idx))
+					{
+						m_pkChrFind = pkChr;
+						m_iMinDistance = iDist;
+					}
+				}
+				else
+				{
+					// ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ì´Â´ï¿½.
+					m_pkChrFind = pkChr;
+					m_iMinDistance = iDist;
+				}
+			}
+		}
+
+		LPCHARACTER m_pkChr;
+		LPCHARACTER m_pkChrFind;
+		int m_iMinDistance;
+	};
+
+	class FuncFindChrForFlagBase
+	{
+	public:
+		FuncFindChrForFlagBase(LPCHARACTER pkChr) : m_pkChr(pkChr)
+		{
+		}
+
+		void operator () (LPENTITY ent)
+		{
+			if (!ent->IsType(ENTITY_CHARACTER))
+				return;
+
+			if (ent->IsObserverMode())
+				return;
+
+			LPCHARACTER pkChr = (LPCHARACTER)ent;
+
+			if (!pkChr->IsPC())
+				return;
+
+			CGuild* pkGuild = pkChr->GetGuild();
+
+			if (!pkGuild)
+				return;
+
+			int iDist = DISTANCE_APPROX(pkChr->GetX() - m_pkChr->GetX(), pkChr->GetY() - m_pkChr->GetY());
+
+			if (iDist <= 500 &&
+				(pkChr->IsAffectFlag(AFF_WAR_FLAG1) ||
+					pkChr->IsAffectFlag(AFF_WAR_FLAG2) ||
+					pkChr->IsAffectFlag(AFF_WAR_FLAG3)))
+			{
+				CAffect* pkAff = pkChr->FindAffect(AFFECT_WAR_FLAG);
+
+				sys_log(0, "FlagBase %s dist %d aff %p flag gid %d chr gid %u",
+					pkChr->GetName(), iDist, pkAff, m_pkChr->GetPoint(POINT_STAT),
+					pkChr->GetGuild()->GetID());
+
+				if (pkAff)
+				{
+					if ((DWORD)m_pkChr->GetPoint(POINT_STAT) == pkGuild->GetID() &&
+						m_pkChr->GetPoint(POINT_STAT) != pkAff->lApplyValue)
+					{
+						CWarMap* pMap = pkChr->GetWarMap();
+						BYTE idx;
+
+						if (!pMap || !pMap->GetTeamIndex(pkGuild->GetID(), idx))
+							return;
+
+						//if (pMap->IsFlagOnBase(idx))
+						{
+							BYTE idx_opp = idx == 0 ? 1 : 0;
+
+							SendGuildWarScore(m_pkChr->GetPoint(POINT_STAT), pkAff->lApplyValue, 1);
+							//SendGuildWarScore(pkAff->lApplyValue, m_pkChr->GetPoint(POINT_STAT), -1);
+
+							pMap->ResetFlag();
+							//pMap->AddFlag(idx_opp);
+							//pkChr->RemoveAffect(AFFECT_WAR_FLAG);
+
+							char buf[256];
+							snprintf(buf, sizeof(buf), LC_STRING("%s ï¿½ï¿½å°¡ %s ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Ñ¾Ò½ï¿½ï¿½Ï´ï¿½!", pMap->GetGuild(idx)->GetName(), pMap->GetGuild(idx_opp)->GetName()));
+							pMap->Notice(buf);
+						}
+					}
+				}
+			}
+		}
+
+		LPCHARACTER m_pkChr;
+	};
+
+	class FuncFindGuardVictim
+	{
+	public:
+		FuncFindGuardVictim(LPCHARACTER pkChr, int iMaxDistance) :
+			m_pkChr(pkChr),
+			m_iMinDistance(INT_MAX),
+			m_iMaxDistance(iMaxDistance),
+			m_lx(pkChr->GetX()),
+			m_ly(pkChr->GetY()),
+			m_pkChrVictim(NULL)
+		{
+		};
+
+		void operator () (LPENTITY ent)
+		{
+			if (!ent->IsType(ENTITY_CHARACTER))
+				return;
+
+			LPCHARACTER pkChr = (LPCHARACTER)ent;
+
+			// ï¿½Ï´ï¿½ PC ï¿½ï¿½ï¿½Ý¾ï¿½ï¿½ï¿½
+			if (pkChr->IsPC())
+				return;
+
+			if (pkChr->IsNPC() && !pkChr->IsMonster())
+				return;
+
+			if (pkChr->IsDead())
+				return;
+
+			if (pkChr->IsAffectFlag(AFF_EUNHYUNG) ||
+				pkChr->IsAffectFlag(AFF_INVISIBILITY) ||
+				pkChr->IsAffectFlag(AFF_REVIVE_INVISIBLE))
+				return;
+
+			// ï¿½Ö±ï¿½ï¿½ï¿½ ï¿½Ð½ï¿½
+			if (pkChr->GetRaceNum() == 5001)
+				return;
+
+			int iDistance = DISTANCE_APPROX(m_lx - pkChr->GetX(), m_ly - pkChr->GetY());
+
+			if (iDistance < m_iMinDistance && iDistance <= m_iMaxDistance)
+			{
+				m_pkChrVictim = pkChr;
+				m_iMinDistance = iDistance;
+			}
+		}
+
+		LPCHARACTER GetVictim()
+		{
+			return (m_pkChrVictim);
+		}
+
+	private:
+		LPCHARACTER m_pkChr;
+
+		int m_iMinDistance;
+		int m_iMaxDistance;
+		long m_lx;
+		long m_ly;
+
+		LPCHARACTER m_pkChrVictim;
+	};
+}
+
+bool CHARACTER::IsAggressive() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_AGGRESSIVE);
+}
+
+void CHARACTER::SetAggressive(bool bSet)
+{
+	if (bSet)
+		SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_AGGRESSIVE);
+	else
+		REMOVE_BIT(m_pointsInstant.dwAIFlag, AIFLAG_AGGRESSIVE);
+}
+
+bool CHARACTER::IsCoward() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_COWARD);
+}
+
+void CHARACTER::SetCoward()
+{
+	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_COWARD);
+}
+
+bool CHARACTER::IsBerserker() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_BERSERK);
+}
+
+bool CHARACTER::IsStoneSkinner() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_STONESKIN);
+}
+
+bool CHARACTER::IsGodSpeeder() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_GODSPEED);
+}
+
+bool CHARACTER::IsDeathBlower() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_DEATHBLOW);
+}
+
+bool CHARACTER::IsReviver() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_REVIVE);
+}
+
+bool CHARACTER::IsHealer() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_HEALER);
+}
+
+bool CHARACTER::IsFaller() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_FALL);
+}
+
+void CHARACTER::CowardEscape()
+{
+	int iDist[4] = { 500, 1000, 3000, 5000 };
+
+	for (int iDistIdx = 2; iDistIdx >= 0; --iDistIdx)
+		for (int iTryCount = 0; iTryCount < 8; ++iTryCount)
+		{
+			SetRotation(number(0, 359)); // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
+
+			float fx, fy;
+			float fDist = number(iDist[iDistIdx], iDist[iDistIdx + 1]);
+
+			GetDeltaByDegree(GetRotation(), fDist, &fx, &fy);
+
+			bool bIsWayBlocked = false;
+			for (int j = 1; j <= 100; ++j)
+			{
+				if (!SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx * j / 100, GetY() + (int)fy * j / 100))
+				{
+					bIsWayBlocked = true;
+					break;
+				}
+			}
+
+			if (bIsWayBlocked)
+				continue;
+
+			m_dwStateDuration = PASSES_PER_SEC(1);
+
+			int iDestX = GetX() + (int)fx;
+			int iDestY = GetY() + (int)fy;
+
+			if (Goto(iDestX, iDestY))
+				SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
+
+			sys_log(0, "WAEGU move to %d %d (far)", iDestX, iDestY);
+			return;
+		}
+}
+
+void CHARACTER::SetNoAttackShinsu()
+{
+	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKSHINSU);
+}
+bool CHARACTER::IsNoAttackShinsu() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKSHINSU);
+}
+
+void CHARACTER::SetNoAttackChunjo()
+{
+	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKCHUNJO);
+}
+
+bool CHARACTER::IsNoAttackChunjo() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKCHUNJO);
+}
+
+void CHARACTER::SetNoAttackJinno()
+{
+	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKJINNO);
+}
+
+bool CHARACTER::IsNoAttackJinno() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_NOATTACKJINNO);
+}
+
+void CHARACTER::SetAttackMob()
+{
+	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_ATTACKMOB);
+}
+
+bool CHARACTER::IsAttackMob() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_ATTACKMOB);
+}
+
+void CHARACTER::SetNoMove()
+{
+	SET_BIT(m_pointsInstant.dwAIFlag, AIFLAG_NOMOVE);
+}
+
+bool CHARACTER::IsNoMove() const
+{
+	return IS_SET(m_pointsInstant.dwAIFlag, AIFLAG_NOMOVE);
+}
+
+// STATE_IDLE_REFACTORING
+void CHARACTER::StateIdle()
+{
+	if (IsStone())
+	{
+		__StateIdle_Stone();
+		return;
+	}
+	else if (IsWarp() || IsGoto())
+	{
+		// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ìºï¿½Æ®ï¿½ï¿½ Ã³ï¿½ï¿½
+		m_dwStateDuration = 60 * passes_per_sec;
+		return;
+	}
+
+	if (IsPC())
+		return;
+
+	// NPC Ã³ï¿½ï¿½
+	if (!IsMonster())
+	{
+		__StateIdle_NPC();
+		return;
+	}
+
+	__StateIdle_Monster();
+}
+
+void CHARACTER::__StateIdle_Stone()
+{
+	m_dwStateDuration = PASSES_PER_SEC(1);
+
+	int iPercent = 0;
+	if (GetMaxHP() >= 0)
+		iPercent = (GetHP() * 100) / GetMaxHP();
+
+	const DWORD dwVnum = number(MIN(GetMobTable().sAttackSpeed, GetMobTable().sMovingSpeed), MAX(GetMobTable().sAttackSpeed, GetMobTable().sMovingSpeed));
+	if (dwVnum == 0)
+		return;
+
+	if (iPercent <= 10 && GetMaxSP() < 10)
+	{
+		SetMaxSP(10);
+		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
+
+		CHARACTER_MANAGER::instance().SelectStone(this);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1500, GetY() - 1500, GetX() + 1500, GetY() + 1500);
+		CHARACTER_MANAGER::instance().SelectStone(NULL);
+	}
+	else if (iPercent <= 20 && GetMaxSP() < 9)
+	{
+		SetMaxSP(9);
+		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
+
+		CHARACTER_MANAGER::instance().SelectStone(this);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1500, GetY() - 1500, GetX() + 1500, GetY() + 1500);
+		CHARACTER_MANAGER::instance().SelectStone(NULL);
+	}
+	else if (iPercent <= 30 && GetMaxSP() < 8)
+	{
+		SetMaxSP(8);
+		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
+
+		CHARACTER_MANAGER::instance().SelectStone(this);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SelectStone(NULL);
+	}
+	else if (iPercent <= 40 && GetMaxSP() < 7)
+	{
+		SetMaxSP(7);
+		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
+
+		CHARACTER_MANAGER::instance().SelectStone(this);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SelectStone(NULL);
+	}
+	else if (iPercent <= 50 && GetMaxSP() < 6)
+	{
+		SetMaxSP(6);
+		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
+
+		CHARACTER_MANAGER::instance().SelectStone(this);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SelectStone(NULL);
+	}
+	else if (iPercent <= 60 && GetMaxSP() < 5)
+	{
+		SetMaxSP(5);
+		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
+
+		CHARACTER_MANAGER::instance().SelectStone(this);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
+		CHARACTER_MANAGER::instance().SelectStone(NULL);
+	}
+	else if (iPercent <= 70 && GetMaxSP() < 4)
+	{
+		SetMaxSP(4);
+		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
+
+		CHARACTER_MANAGER::instance().SelectStone(this);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SelectStone(NULL);
+	}
+	else if (iPercent <= 80 && GetMaxSP() < 3)
+	{
+		SetMaxSP(3);
+		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
+
+		CHARACTER_MANAGER::instance().SelectStone(this);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SelectStone(NULL);
+	}
+	else if (iPercent <= 90 && GetMaxSP() < 2)
+	{
+		SetMaxSP(2);
+		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
+
+		CHARACTER_MANAGER::instance().SelectStone(this);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 500, GetY() - 500, GetX() + 500, GetY() + 500);
+		CHARACTER_MANAGER::instance().SelectStone(NULL);
+	}
+	else if (iPercent <= 99 && GetMaxSP() < 1)
+	{
+		SetMaxSP(1);
+		SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0);
+
+		CHARACTER_MANAGER::instance().SelectStone(this);
+		CHARACTER_MANAGER::instance().SpawnGroup(dwVnum, GetMapIndex(), GetX() - 1000, GetY() - 1000, GetX() + 1000, GetY() + 1000);
+		CHARACTER_MANAGER::instance().SelectStone(NULL);
+	}
+	else
+		return;
+
+	UpdatePacket();
+	return;
+}
+
+void CHARACTER::__StateIdle_NPC()
+{
+	MonsterChat(MONSTER_CHAT_WAIT);
+	m_dwStateDuration = PASSES_PER_SEC(5);
+
+#if defined(__PET_SYSTEM__)
+	// ï¿½ï¿½ ï¿½Ã½ï¿½ï¿½ï¿½ï¿½ï¿½ Idle Ã³ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ Ä³ï¿½ï¿½ï¿½Íµï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ø¼ï¿½ ï¿½ï¿½ï¿½ï¿½Ï´ï¿½ ï¿½ï¿½ï¿½Â¸Ó½ï¿½ï¿½ï¿½ ï¿½Æ´ï¿½ CPetActor::Updateï¿½ï¿½ï¿½ï¿½ Ã³ï¿½ï¿½ï¿½ï¿½.
+	if (IsPet())
+		return;
+#endif
+
+#if defined(__GROWTH_PET_SYSTEM__)
+	if (IsGrowthPet())
+		return;
+#endif
+
+	if (IsGuardNPC())
+	{
+		if (!quest::CQuestManager::instance().GetEventFlag("noguard"))
+		{
+			FuncFindGuardVictim f(this, 50000);
+
+			if (GetSectree())
+				GetSectree()->ForEachAround(f);
+
+			LPCHARACTER victim = f.GetVictim();
+
+			if (victim)
+			{
+				m_dwStateDuration = passes_per_sec / 2;
+
+				if (CanBeginFight())
+					BeginFight(victim);
+			}
+		}
+	}
+	else
+	{
+#if defined(__XMAS_EVENT_2008__)
+		if (GetRaceNum() == xmas::MOB_XMAS_SANTA_VNUM) // ï¿½ï¿½Å¸
+		{
+			if ((int)(get_dword_time() - m_dwPlayStartTime) > 0)
+			{
+				int next_warp_time = 2 * 1000; // 2ï¿½ï¿½
+
+				m_dwPlayStartTime = get_dword_time() + next_warp_time;
+
+				// ï¿½Ã°ï¿½ï¿½ï¿½ ï¿½Ñ¾ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Õ½Ã´ï¿½.
+				// ï¿½ï¿½Å¸ï¿½ï¿½
+				/*
+				const int WARP_MAP_INDEX_NUM = 4;
+				static const long c_lWarpMapIndexs[WARP_MAP_INDEX_NUM] = { 61, 62, 63, 64 };
+				*/
+				// ï¿½Å¼ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Ø¿ï¿½
+				const int WARP_MAP_INDEX_NUM = 7;
+				static const long c_lWarpMapIndexs[WARP_MAP_INDEX_NUM] = { MAP_N_SNOWM_01, MAP_N_FLAME_01, MAP_N_DESERT_01, MAP_N_THREEWAY, MAP_A3, MAP_B3, MAP_C3 };
+				long lNextMapIndex = c_lWarpMapIndexs[number(1, WARP_MAP_INDEX_NUM) - 1];
+
+				if (map_allow_find(lNextMapIndex))
+				{
+					// ï¿½Ì°ï¿½ï¿½Ô´Ï´ï¿½.
+					M2_DESTROY_CHARACTER(this);
+
+					int iNextSpawnDelay = 1;
+					if (LC_IsYMIR())
+						iNextSpawnDelay = 20 * 60;
+					else
+						iNextSpawnDelay = 50 * 60;
+
+					xmas::SpawnSanta(lNextMapIndex, iNextSpawnDelay);
+				}
+				else
+				{
+					// ï¿½Ù¸ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ô´Ï´ï¿½.
+					TPacketGGXmasWarpSanta p;
+					p.bHeader = HEADER_GG_XMAS_WARP_SANTA;
+					p.bChannel = g_bChannel;
+					p.lMapIndex = lNextMapIndex;
+					P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGXmasWarpSanta));
+				}
+				return;
+			}
+		}
+#endif
+
+		if (!IsNoMove())
+		{
+			//
+			// ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ ï¿½Ìµï¿½ï¿½Ñ´ï¿½.
+			//
+			LPCHARACTER pkChrProtege = GetProtege();
+
+			if (pkChrProtege)
+			{
+				if (DISTANCE_APPROX(GetX() - pkChrProtege->GetX(), GetY() - pkChrProtege->GetY()) > 500)
+				{
+					if (Follow(pkChrProtege, number(100, 300)))
+						return;
+				}
+			}
+
+			if (!number(0, 6))
+			{
+				SetRotation(number(0, 359)); // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
+
+				float fx, fy;
+				float fDist = number(200, 400);
+
+				GetDeltaByDegree(GetRotation(), fDist, &fx, &fy);
+
+				// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ó¼ï¿½ Ã¼Å©; ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½Ä¡ï¿½ï¿½ ï¿½ß°ï¿½ ï¿½ï¿½Ä¡ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ù¸ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ê´Â´ï¿½.
+				if (!(SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx, GetY() + (int)fy)
+					&& SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx / 2, GetY() + (int)fy / 2)))
+					return;
+
+				SetNowWalking(true);
+
+				if (Goto(GetX() + (int)fx, GetY() + (int)fy))
+					SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
+
+				return;
+			}
+		}
+	}
+}
+
+void CHARACTER::__StateIdle_Monster()
+{
+	if (IsStun())
+		return;
+
+	if (!CanMove())
+		return;
+
+	if (IsCoward())
+	{
+		// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Í´ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ù´Õ´Ï´ï¿½.
+		if (!IsDead())
+			CowardEscape();
+
+		return;
+	}
+
+	if (IsBerserker())
+		if (IsBerserk())
+			SetBerserk(false);
+
+	if (IsGodSpeeder())
+		if (IsGodSpeed())
+			SetGodSpeed(false);
+
+	LPCHARACTER victim = GetVictim();
+
+	if (!victim || victim->IsDead())
+	{
+		SetVictim(NULL);
+		victim = NULL;
+		m_dwStateDuration = PASSES_PER_SEC(1);
+	}
+
+	if (!victim || victim->IsBuilding())
+	{
+		// ï¿½ï¿½ ï¿½ï¿½È£ Ã³ï¿½ï¿½
+		if (m_pkChrStone)
+		{
+			victim = m_pkChrStone->GetNearestVictim(m_pkChrStone);
+		}
+		else if (!no_wander && IsAggressive())
+		{
+#if defined(__XMAS_EVENT_2008__)
+			if (GetMapIndex() == MAP_N_SNOWM_01 && quest::CQuestManager::instance().GetEventFlag("xmas_tree"));
+			// ï¿½ï¿½ï¿½Ñ»ê¿¡ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ê´Â´ï¿½.
+			else
+#endif
+			{
+				victim = FindVictim(this, m_pkMobData->m_table.wAggressiveSight);
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+				if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()))
+					victim = FindVictim(this, 40000);
+#endif
+			}
+		}
+	}
+
+	if (victim && !victim->IsDead())
+	{
+		if (CanBeginFight())
+			BeginFight(victim);
+
+		return;
+	}
+
+	if (IsAggressive() && !victim)
+		m_dwStateDuration = PASSES_PER_SEC(number(1, 3));
+	else
+		m_dwStateDuration = PASSES_PER_SEC(number(3, 5));
+
+	LPCHARACTER pkChrProtege = GetProtege();
+
+	// ï¿½ï¿½È£ï¿½ï¿½ ï¿½ï¿½(ï¿½ï¿½, ï¿½ï¿½Æ¼ï¿½ï¿½)ï¿½ï¿½ï¿½Ô·ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ö´Ù¸ï¿½ ï¿½ï¿½ï¿½ó°£´ï¿½.
+	if (pkChrProtege)
+	{
+		if (DISTANCE_APPROX(GetX() - pkChrProtege->GetX(), GetY() - pkChrProtege->GetY()) > 1000)
+		{
+			if (Follow(pkChrProtege, number(150, 400)))
+			{
+				MonsterLog("[IDLE] ï¿½ï¿½ï¿½ï¿½ï¿½Îºï¿½ï¿½ï¿½ ï¿½Ê¹ï¿½ ï¿½Ö¸ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½! ï¿½ï¿½ï¿½ï¿½ï¿½Ñ´ï¿½.");
+				return;
+			}
+		}
+	}
+
+	//
+	// ï¿½×³ï¿½ ï¿½Ô´Ù¸ï¿½ ï¿½ï¿½ï¿½Ù¸ï¿½ ï¿½Ñ´ï¿½.
+	//
+	if (!no_wander && !IsNoMove())
+	{
+		if (!number(0, 6))
+		{
+			SetRotation(number(0, 359)); // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
+
+			float fx, fy;
+			float fDist = number(300, 700);
+
+			GetDeltaByDegree(GetRotation(), fDist, &fx, &fy);
+
+			// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ó¼ï¿½ Ã¼Å©; ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½Ä¡ï¿½ï¿½ ï¿½ß°ï¿½ ï¿½ï¿½Ä¡ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ù¸ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ê´Â´ï¿½.
+			if (!(SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx, GetY() + (int)fy)
+				&& SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx / 2, GetY() + (int)fy / 2)))
+				return;
+
+			// NOTE: When a monster wanders around in IDLE state, it currently runs unconditionally. (Never walk)
+			// The graphics team wants to see the monsters walking, so they temporarily walk or run with a certain probability.
+			{
+				// Aggressive monsters will always run.
+				if (IsAggressive())
+					SetNowWalking(false);
+				else
+				{
+					// Given the probability, monsters will walk or run depending on their fight state.
+					if ((number(0, 100) < 60) || CanFight())
+						SetNowWalking(false);
+					else
+						SetNowWalking(true);
+				}
+			}
+
+			if (Goto(GetX() + (int)fx, GetY() + (int)fy))
+				SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
+
+			return;
+		}
+	}
+
+	MonsterChat(MONSTER_CHAT_WAIT);
+}
+// END_OF_STATE_IDLE_REFACTORING
+
+bool __CHARACTER_GotoNearTarget(LPCHARACTER self, LPCHARACTER victim)
+{
+	if (self->IsNoMove())
+		return false;
+
+	switch (self->GetMobBattleType())
+	{
+		case BATTLE_TYPE_RANGE:
+		case BATTLE_TYPE_MAGIC:
+			// ï¿½ï¿½ï¿½ï¿½ï¿½ç³ª ï¿½Ã¼ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Å¸ï¿½ï¿½ï¿½ 80%ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ñ´ï¿½.
+			if (self->Follow(victim, self->GetMobAttackRange() * 8 / 10))
+				return true;
+			break;
+
+		default:
+			// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ 90%?
+			if (self->Follow(victim, self->GetMobAttackRange() * 9 / 10))
+				return true;
+	}
+
+	return false;
+}
+
+void CHARACTER::StateMove()
+{
+	float fRate = 1.0f;
+	
+	const DWORD dwElapsedTime = get_dword_time() - m_dwMoveStartTime;
+	if (dwElapsedTime != 0 && m_dwMoveStartTime != 0)
+		fRate = static_cast<float>(dwElapsedTime) / static_cast<float>(m_dwMoveDuration);
+
+	if (fRate > 1.0f)
+		fRate = 1.0f;
+
+	const int x = static_cast<int>(static_cast<float>(m_posDest.x - m_posStart.x) * fRate + m_posStart.x);
+	const int y = static_cast<int>(static_cast<float>(m_posDest.y - m_posStart.y) * fRate + m_posStart.y);
+
+	Move(x, y);
+
+	if (IsPC() && (thecore_pulse() & 15) == 0)
+	{
+		UpdateSectree();
+
+		if (GetExchange())
+		{
+			const LPCHARACTER& victim = GetExchange()->GetCompany()->GetOwner();
+			const int iDist = DISTANCE_APPROX(GetX() - victim->GetX(), GetY() - victim->GetY());
+
+			// ï¿½Å¸ï¿½ Ã¼Å©
+			if (iDist >= EXCHANGE_MAX_DISTANCE)
+			{
+				GetExchange()->Cancel();
+			}
+		}
+	}
+
+	// ï¿½ï¿½ï¿½×¹Ì³ï¿½ï¿½ï¿½ 0 ï¿½Ì»ï¿½ï¿½Ì¾ï¿½ï¿½ ï¿½Ñ´ï¿½.
+	if (IsPC())
+	{
+		if (IsWalking() && GetStamina() < GetMaxStamina())
+		{
+			// 5ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½×¹Ì³ï¿½ ï¿½ï¿½ï¿½ï¿½
+			if (get_dword_time() - GetWalkStartTime() > 5000)
+				PointChange(POINT_STAMINA, GetMaxStamina() / 1);
+		}
+
+		// ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Ì¸é¼­ ï¿½Ù´ï¿½ ï¿½ï¿½ï¿½Ì¸ï¿½
+		if (!IsWalking() && !IsRiding())
+		{
+			if ((get_dword_time() - GetLastAttackTime()) < 20000)
+			{
+				StartAffectEvent();
+
+				PointChange(POINT_STAMINA, -STAMINA_PER_STEP);
+
+				StartStaminaConsume();
+
+				if (GetStamina() <= 0)
+				{
+					// ï¿½ï¿½ï¿½×¹Ì³ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Ú¶ï¿½ ï¿½É¾ï¿½ï¿½ï¿½ï¿½
+					SetStamina(0);
+					SetNowWalking(true);
+					StopStaminaConsume();
+				}
+			}
+			else if (IsStaminaConsume())
+			{
+				StopStaminaConsume();
+			}
+		}
+	}
+	else
+	{
+		// XXX AGGRO
+		if (IsMonster() && GetVictim())
+		{
+			LPCHARACTER victim = GetVictim();
+			if (victim && !victim->IsInSafezone())
+				UpdateAggrPoint(victim, DAMAGE_TYPE_NORMAL, -(victim->GetLevel() / 3 + 1));
+
+			if (g_test_server)
+			{
+				// ï¿½ï¿½ï¿½Í°ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ñ¾Æ°ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Ì¸ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ù¾î°£ï¿½ï¿½.
+				SetNowWalking(false);
+			}
+		}
+
+		if (IsMonster() && GetMobRank() >= MOB_RANK_BOSS && GetVictim())
+		{
+			LPCHARACTER victim = GetVictim();
+
+			// ï¿½Å´ï¿½ ï¿½Åºï¿½
+			if ((GetRaceNum() == 2191 || GetRaceNum() == 2192) && number(1, 20) == 1 && get_dword_time() - m_pkMobInst->m_dwLastWarpTime > 1000)
+			{
+				// ï¿½ï¿½ï¿½ï¿½ ï¿½×½ï¿½Æ®
+				float fx, fy;
+				GetDeltaByDegree(victim->GetRotation(), 400, &fx, &fy);
+				long new_x = victim->GetX() + (long)fx;
+				long new_y = victim->GetY() + (long)fy;
+				if (!IsInSafezone())
+				{
+					SetRotation(GetDegreeFromPositionXY(new_x, new_y, victim->GetX(), victim->GetY()));
+					Show(victim->GetMapIndex(), new_x, new_y, 0, true);
+					GotoState(m_stateBattle);
+					m_dwStateDuration = 1;
+					ResetMobSkillCooltime();
+					m_pkMobInst->m_dwLastWarpTime = get_dword_time();
+					return;
+				}
+			}
+
+			// TODO ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½È¯ï¿½ï¿½ ï¿½Ø¼ï¿½ ï¿½ï¿½ ï¿½Ùºï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½!
+			if (number(0, 3) == 0 && (victim && !victim->IsInSafezone()))
+			{
+				if (__CHARACTER_GotoNearTarget(this, victim))
+					return;
+			}
+		}
+	}
+
+	if (1.0f == fRate)
+	{
+		if (IsPC())
+		{
+			sys_log(1, "ï¿½ï¿½ï¿½ï¿½ %s %d %d", GetName(), x, y);
+			GotoState(m_stateIdle);
+			StopStaminaConsume();
+		}
+		else
+		{
+			if (GetVictim() && !IsCoward())
+			{
+				if (!IsState(m_stateBattle))
+					MonsterLog("[BATTLE] ï¿½ï¿½Ã³ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Ý½ï¿½ï¿½ï¿½ %s", GetVictim()->GetName());
+
+				GotoState(m_stateBattle);
+				m_dwStateDuration = 1;
+			}
+			else
+			{
+				if (!IsState(m_stateIdle))
+					MonsterLog("[IDLE] ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½");
+
+				GotoState(m_stateIdle);
+
+				//LPCHARACTER rider = GetRider();
+
+				m_dwStateDuration = PASSES_PER_SEC(number(1, 3));
+			}
+		}
+	}
+}
+
+void CHARACTER::StateBattle()
+{
+	if (IsStone())
+	{
+		sys_err("Stone must not use battle state (name %s)", GetName());
+		return;
+	}
+
+	if (IsPC())
+		return;
+
+	if (!CanMove())
+		return;
+
+	if (IsStun())
+		return;
+
+	LPCHARACTER victim = GetVictim();
+
+	if (IsCoward())
+	{
+		if (IsDead())
+			return;
+
+		SetVictim(NULL);
+
+		if (number(1, 50) != 1)
+		{
+			GotoState(m_stateIdle);
+			m_dwStateDuration = 1;
+		}
+		else
+			CowardEscape();
+
+		return;
+	}
+
+	if (!victim || (victim->IsStun() && IsGuardNPC()) || victim->IsDead())
+	{
+		if (victim && victim->IsDead() &&
+			!no_wander && IsAggressive() && (!GetParty() || GetParty()->GetLeader() == this))
+		{
+			LPCHARACTER new_victim = FindVictim(this, m_pkMobData->m_table.wAggressiveSight);
+
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+			if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()))
+				new_victim = FindVictim(this, 40000);
+#endif
+
+			SetVictim(new_victim);
+			m_dwStateDuration = PASSES_PER_SEC(1);
+
+			if (!new_victim)
+			{
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+				if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()))
+					return;
+#endif
+
+				switch (GetMobBattleType())
+				{
+					case BATTLE_TYPE_MELEE:
+					case BATTLE_TYPE_SUPER_POWER:
+					case BATTLE_TYPE_SUPER_TANKER:
+					case BATTLE_TYPE_POWER:
+					case BATTLE_TYPE_TANKER:
+					{
+						float fx, fy;
+						float fDist = number(400, 1500);
+
+						GetDeltaByDegree(number(0, 359), fDist, &fx, &fy);
+
+						if (SECTREE_MANAGER::instance().IsMovablePosition(victim->GetMapIndex(),
+							victim->GetX() + (int)fx,
+							victim->GetY() + (int)fy) &&
+							SECTREE_MANAGER::instance().IsMovablePosition(victim->GetMapIndex(),
+								victim->GetX() + (int)fx / 2,
+								victim->GetY() + (int)fy / 2))
+						{
+							float dx = victim->GetX() + fx;
+							float dy = victim->GetY() + fy;
+
+							SetRotation(GetDegreeFromPosition(dx, dy));
+
+							if (Goto((long)dx, (long)dy))
+							{
+								sys_log(0, "KILL_AND_GO: %s distance %.1f", GetName(), fDist);
+								SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
+							}
+						}
+					}
+				}
+			}
+			return;
+		}
+
+		SetVictim(NULL);
+
+		if (IsGuardNPC())
+			Return();
+
+		m_dwStateDuration = PASSES_PER_SEC(1);
+		return;
+	}
+
+	if (CanSummonMonster() && !IsDead() && !IsStun())
+	{
+		if (!GetParty())
+		{
+			// ï¿½ï¿½ï¿½ï¿½ï¿½Ø¼ï¿½ Ã¤ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½Æ¼ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ó´Ï´ï¿½.
+			CPartyManager::instance().CreateParty(this);
+		}
+
+		LPPARTY pParty = GetParty();
+		bool bPct = !number(0, 3);
+
+		if (bPct)
+		{
+			if (pParty->CountMemberByVnum(GetSummonVnum()) < SUMMON_MONSTER_COUNT)
+			{
+				MonsterLog("ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½È¯!");
+				// ï¿½ï¿½ï¿½Ú¶ï¿½ï¿½ ï¿½à¼®ï¿½ï¿½ ï¿½Ò·ï¿½ï¿½ï¿½ Ã¤ï¿½ï¿½Ã´ï¿½.
+				int sx = GetX() - 300;
+				int sy = GetY() - 300;
+				int ex = GetX() + 300;
+				int ey = GetY() + 300;
+
+				LPCHARACTER tch = CHARACTER_MANAGER::instance().SpawnMobRange(GetSummonVnum(), GetMapIndex(), sx, sy, ex, ey, true, true);
+
+				if (tch)
+				{
+					pParty->Join(tch->GetVID());
+					pParty->Link(tch);
+				}
+			}
+			else
+				MarkSummonedMonster();
+		}
+	}
+
+#if defined(__DAWNMIST_DUNGEON__)
+	if (CDawnMistDungeon::Instance().IsBoss(this))
+		if (!IsDead() && CDawnMistDungeon::Instance().CanSpawnHealerGroup(this))
+			CDawnMistDungeon::Instance().SpawnHealerGroup(this);
+#endif
+
+	LPCHARACTER pkChrProtege = GetProtege();
+
+	float fDist = DISTANCE_APPROX(GetX() - victim->GetX(), GetY() - victim->GetY());
+	if (fDist >= 4000.0f) // 40ï¿½ï¿½ï¿½ï¿½ ï¿½Ì»ï¿½ ï¿½Ö¾ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
+	{
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+		if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()) && fDist < 16000.0f) { /* continue */ }
+		else
+#else
+		if (bPass)
+#endif
+		{
+			MonsterLog("Å¸ï¿½ï¿½ï¿½ï¿½ ï¿½Ö¾î¼­ ï¿½ï¿½ï¿½ï¿½");
+			SetVictim(NULL);
+
+			// ï¿½ï¿½È£ï¿½ï¿½ ï¿½ï¿½(ï¿½ï¿½, ï¿½ï¿½Æ¼ï¿½ï¿½) ï¿½Öºï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½.
+			if (pkChrProtege && !pkChrProtege->IsInSafezone())
+				if (DISTANCE_APPROX(GetX() - pkChrProtege->GetX(), GetY() - pkChrProtege->GetY()) > 1000)
+					Follow(pkChrProtege, (float)number(150, 400));
+
+			return;
+		}
+	}
+
+	if (fDist >= (GetMobAttackRange() * 1.15) && !victim->IsInSafezone())
+	{
+		__CHARACTER_GotoNearTarget(this, victim);
+		return;
+	}
+
+	if (m_pkParty)
+		m_pkParty->SendMessage(this, PM_ATTACKED_BY, 0, 0);
+
+#if defined(__BLUE_DRAGON_RENEWAL__)
+	if (BlueDragon_IsBoss(m_pkMobData->m_table.dwVnum))
+#else
+	if (BlueDragon::BossVnum == m_pkMobData->m_table.dwVnum)
+#endif
+	{
+		// ï¿½ï¿½ï¿½ï¿½(2493) Æ¯ï¿½ï¿½ Ã³ï¿½ï¿½
+		m_dwStateDuration = BlueDragon_StateBattle(this);
+		return;
+	}
+
+	DWORD dwCurTime = get_dword_time();
+	DWORD dwDuration = CalculateDuration(GetLimitPoint(POINT_ATT_SPEED), 2000);
+
+	if ((dwCurTime - m_dwLastAttackTime) < dwDuration) // 2ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ø¾ï¿½ ï¿½Ñ´ï¿½.
+	{
+		m_dwStateDuration = MAX(1, (passes_per_sec * (dwDuration - (dwCurTime - m_dwLastAttackTime)) / 1000));
+		return;
+	}
+
+	if (IsBerserker() == true)
+		if (GetHPPct() < m_pkMobData->m_table.bBerserkPoint)
+			if (IsBerserk() != true)
+				SetBerserk(true);
+
+	if (IsGodSpeeder() == true)
+		if (GetHPPct() < m_pkMobData->m_table.bGodSpeedPoint)
+			if (IsGodSpeed() != true)
+				SetGodSpeed(true);
+
+	//
+	// ï¿½ï¿½ ï¿½ï¿½Å³ Ã³ï¿½ï¿½
+	//
+	if (HasMobSkill())
+	{
+		if (!victim || (victim && !victim->IsInSafezone()) || (pkChrProtege && !pkChrProtege->IsInSafezone()))
+		{
+			for (unsigned int iSkillIdx = 0; iSkillIdx < MOB_SKILL_MAX_NUM; ++iSkillIdx)
+			{
+				if (CanUseMobSkill(iSkillIdx))
+				{
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+					if (CGuildDragonLairManager::Instance().IsKing(GetRaceNum()) && GetGuildDragonLair())
+						SetRotationToXY(GetGuildDragonLair()->GetCenterX(), GetGuildDragonLair()->GetCenterY());
+					else
+						SetRotationToXY(victim->GetX(), victim->GetY());
+#else
+					SetRotationToXY(victim->GetX(), victim->GetY());
+#endif
+
+					if (UseMobSkill(iSkillIdx))
+					{
+						SendMovePacket(FUNC_MOB_SKILL, iSkillIdx, GetX(), GetY(), 0, dwCurTime);
+
+						float fDuration = CMotionManager::instance().GetMotionDuration(GetRaceNum(), MAKE_MOTION_KEY(MOTION_MODE_GENERAL, MOTION_SPECIAL_1 + iSkillIdx));
+						m_dwStateDuration = (DWORD)(fDuration == 0.0f ? PASSES_PER_SEC(2) : PASSES_PER_SEC(fDuration));
+
+						if (test_server)
+							sys_log(0, "USE_MOB_SKILL: %s idx %u motion %u duration %.0f", GetName(), iSkillIdx, MOTION_SPECIAL_1 + iSkillIdx, fDuration);
+
+						return;
+					}
+				}
+			}
+		}
+	}
+
+	if (!victim->IsInSafezone() && !Attack(victim)) // ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Ð¶ï¿½ï¿½? ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? TODO
+		m_dwStateDuration = passes_per_sec / 2;
+	else
+	{
+		if (!victim->IsInSafezone())
+		{
+			// ï¿½ï¿½ï¿½ï¿½ ï¿½Ù¶óº¸°ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½.
+			SetRotationToXY(victim->GetX(), victim->GetY());
+
+			SendMovePacket(FUNC_ATTACK, 0, GetX(), GetY(), 0, dwCurTime);
+
+			float fDuration = CMotionManager::instance().GetMotionDuration(GetRaceNum(), MAKE_MOTION_KEY(MOTION_MODE_GENERAL, MOTION_NORMAL_ATTACK));
+			m_dwStateDuration = (DWORD)(fDuration == 0.0f ? PASSES_PER_SEC(2) : PASSES_PER_SEC(fDuration));
+		}
+	}
+}
+
+void CHARACTER::StateFlag()
+{
+	m_dwStateDuration = (DWORD)PASSES_PER_SEC(0.5);
+
+	CWarMap* pMap = GetWarMap();
+
+	if (!pMap)
+		return;
+
+	FuncFindChrForFlag f(this);
+	GetSectree()->ForEachAround(f);
+
+	if (!f.m_pkChrFind)
+		return;
+
+	if (NULL == f.m_pkChrFind->GetGuild())
+		return;
+
+	char buf[256];
+	BYTE idx;
+
+	if (!pMap->GetTeamIndex(GetPoint(POINT_STAT), idx))
+		return;
+
+	f.m_pkChrFind->AddAffect(AFFECT_WAR_FLAG, POINT_NONE, GetPoint(POINT_STAT), idx == 0 ? AFF_WAR_FLAG1 : AFF_WAR_FLAG2, INFINITE_AFFECT_DURATION, 0, false);
+	f.m_pkChrFind->AddAffect(AFFECT_WAR_FLAG, POINT_MOV_SPEED, 50 - f.m_pkChrFind->GetPoint(POINT_MOV_SPEED), 0, INFINITE_AFFECT_DURATION, 0, false);
+
+	pMap->RemoveFlag(idx);
+
+	snprintf(buf, sizeof(buf), LC_STRING("%s ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ %s ï¿½ï¿½ï¿½ï¿½ È¹ï¿½ï¿½ï¿½Ï¿ï¿½ï¿½ï¿½ï¿½Ï´ï¿½.", pMap->GetGuild(idx)->GetName(), f.m_pkChrFind->GetName()));
+	pMap->Notice(buf);
+}
+
+void CHARACTER::StateFlagBase()
+{
+	m_dwStateDuration = (DWORD)PASSES_PER_SEC(0.5);
+
+	FuncFindChrForFlagBase f(this);
+	GetSectree()->ForEachAround(f);
+}
+
+void CHARACTER::StateHorse()
+{
+	float START_FOLLOW_DISTANCE = 400.0f; // ï¿½ï¿½ ï¿½Å¸ï¿½ ï¿½Ì»ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ñ¾Æ°ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
+	float START_RUN_DISTANCE = 700.0f; // ï¿½ï¿½ ï¿½Å¸ï¿½ ï¿½Ì»ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ù¾î¼­ ï¿½Ñ¾Æ°ï¿½.
+	int MIN_APPROACH = 150; // ï¿½Ö¼ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Å¸ï¿½
+	int MAX_APPROACH = 300; // ï¿½Ö´ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Å¸ï¿½
+
+	DWORD STATE_DURATION = (DWORD)PASSES_PER_SEC(0.5); // ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ã°ï¿½
+
+	bool bDoMoveAlone = true; // Ä³ï¿½ï¿½ï¿½Í¿ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ È¥ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ï°ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ -_-;
+	bool bRun = true; // ï¿½Ù¾ï¿½ï¿½ ï¿½Ï³ï¿½?
+
+	if (IsDead())
+		return;
+
+	m_dwStateDuration = STATE_DURATION;
+
+	LPCHARACTER victim = GetRider();
+
+	// ! ï¿½Æ´ï¿½ // ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½ï¿½È¯ï¿½Ú°ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ Å¬ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
+	if (!victim)
+	{
+		M2_DESTROY_CHARACTER(this);
+		return;
+	}
+
+	m_pkMobInst->m_posLastAttacked = GetXYZ();
+
+	float fDist = DISTANCE_APPROX(GetX() - victim->GetX(), GetY() - victim->GetY());
+
+	if (fDist >= START_FOLLOW_DISTANCE)
+	{
+		if (fDist > START_RUN_DISTANCE)
+			SetNowWalking(!bRun); // NOTE : ï¿½Ô¼ï¿½ ï¿½Ì¸ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ß´Â°ï¿½ï¿½ï¿½ ï¿½Ë¾Ò´Âµï¿½ SetNowWalking(false) ï¿½Ï¸ï¿½ ï¿½Ù´Â°ï¿½ï¿½ï¿½.. -_-;
+
+		Follow(victim, number(MIN_APPROACH, MAX_APPROACH));
+
+		m_dwStateDuration = STATE_DURATION;
+	}
+	else if (bDoMoveAlone && ((int)(get_dword_time() - m_dwLastAttackTime) > 0))
+	{
+		// wondering -.-
+		m_dwLastAttackTime = get_dword_time() + number(5000, 12000);
+
+		SetRotation(number(0, 359)); // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
+
+		float fx, fy;
+		float fDist = number(200, 400);
+
+		GetDeltaByDegree(GetRotation(), fDist, &fx, &fy);
+
+		// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ó¼ï¿½ Ã¼Å©; ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½Ä¡ï¿½ï¿½ ï¿½ß°ï¿½ ï¿½ï¿½Ä¡ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ù¸ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ê´Â´ï¿½.
+		if (!(SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx, GetY() + (int)fy)
+			&& SECTREE_MANAGER::instance().IsMovablePosition(GetMapIndex(), GetX() + (int)fx / 2, GetY() + (int)fy / 2)))
+			return;
+
+		SetNowWalking(true);
+
+		if (Goto(GetX() + (int)fx, GetY() + (int)fy))
+			SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
+	}
+}
diff --git a/server/metin2/Source/Server/game/src/dungeon.cpp b/server/metin2/Source/Server/game/src/dungeon.cpp
index 9f7f386..5398181 100644
--- a/server/metin2/Source/Server/game/src/dungeon.cpp
+++ b/server/metin2/Source/Server/game/src/dungeon.cpp
@@ -1,1563 +1,1571 @@
-#include "stdafx.h"
-#include "dungeon.h"
-#include "char.h"
-#include "char_manager.h"
-#include "party.h"
-#include "affect.h"
-#include "packet.h"
-#include "desc.h"
-#include "config.h"
-#include "regen.h"
-#include "start_position.h"
-#include "item.h"
-#include "item_manager.h"
-#include "utils.h"
-#include "questmanager.h"
-#include "desc_manager.h"
-
-#if defined(__DEFENSE_WAVE__)
-#	include "defense_wave.h"
-#endif
-
-CDungeon::CDungeon(IdType id, long lOriginalMapIndex, long lMapIndex)
-	: m_id(id),
-	m_lOrigMapIndex(lOriginalMapIndex),
-	m_lMapIndex(lMapIndex),
-	m_map_Area(SECTREE_MANAGER::instance().GetDungeonArea(lOriginalMapIndex))
-{
-	Initialize();
-	// sys_log(0,"DUNGEON create orig %d real %d", lOriginalMapIndex, lMapIndex);
-}
-
-CDungeon::~CDungeon()
-{
-	if (m_pParty != NULL)
-	{
-		m_pParty->SetDungeon_for_Only_party(NULL);
-	}
-	// sys_log(0,"DUNGEON destroy orig %d real %d", m_lOrigMapIndex, m_lMapIndex	);
-	ClearRegen();
-	event_cancel(&deadEvent);
-	// <Factor>
-	event_cancel(&exit_all_event_);
-	event_cancel(&jump_to_event_);
-}
-
-void CDungeon::Initialize()
-{
-	deadEvent = NULL;
-	// <Factor>
-	exit_all_event_ = NULL;
-	jump_to_event_ = NULL;
-	regen_id_ = 0;
-
-	m_iMobKill = 0;
-	m_iStoneKill = 0;
-	m_bUsePotion = false;
-	m_bUseRevive = false;
-
-	m_iMonsterCount = 0;
-
-	m_bExitAllAtEliminate = false;
-	m_bWarpAtEliminate = false;
-#ifdef _EXE_
-	m_bCheckEliminate = false;
-#endif
-
-	m_iWarpDelay = 0;
-	m_lWarpMapIndex = 0;
-	m_lWarpX = 0;
-	m_lWarpY = 0;
-
-	m_stRegenFile = "";
-
-	m_pParty = NULL;
-}
-
-void CDungeon::SetFlag(std::string name, int value)
-{
-	auto it =  m_map_Flag.find(name);
-	if (it != m_map_Flag.end())
-		it->second = value;
-	else
-		m_map_Flag.insert(make_pair(name, value));
-}
-
-int CDungeon::GetFlag(std::string name)
-{
-	auto it =  m_map_Flag.find(name);
-	if (it != m_map_Flag.end())
-		return it->second;
-	else
-		return 0;
-}
-
-struct FSendDestPosition
-{
-	FSendDestPosition(long x, long y)
-	{
-		p1.bHeader = HEADER_GC_DUNGEON;
-		p1.subheader = DUNGEON_SUBHEADER_GC_DESTINATION_POSITION;
-		p2.x = x;
-		p2.y = y;
-		p1.size = sizeof(p1) + sizeof(p2);
-	}
-
-	void operator()(LPCHARACTER ch)
-	{
-		ch->GetDesc()->BufferedPacket(&p1, sizeof(TPacketGCDungeon));
-		ch->GetDesc()->Packet(&p2, sizeof(TPacketGCDungeonDestPosition));
-	}
-
-	TPacketGCDungeon p1;
-	TPacketGCDungeonDestPosition p2;
-};
-
-void CDungeon::SendDestPositionToParty(LPPARTY pParty, long x, long y)
-{
-	if (m_map_pkParty.find(pParty) == m_map_pkParty.end())
-	{
-		sys_err("PARTY %u not in DUNGEON %d", pParty->GetLeaderPID(), m_lMapIndex);
-		return;
-	}
-
-	FSendDestPosition f(x, y);
-	pParty->ForEachNearMember(f);
-}
-
-struct FWarpToDungeon
-{
-	FWarpToDungeon(long lMapIndex, LPDUNGEON d)
-		: m_lMapIndex(lMapIndex), m_pkDungeon(d)
-	{
-		LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(lMapIndex);
-		m_x = pkSectreeMap->m_setting.posSpawn.x;
-		m_y = pkSectreeMap->m_setting.posSpawn.y;
-	}
-
-	void operator () (LPCHARACTER ch)
-	{
-		ch->SaveExitLocation();
-		ch->WarpSet(m_x, m_y, m_lMapIndex);
-		//m_pkDungeon->IncPartyMember(ch->GetParty());
-	}
-
-	long m_lMapIndex;
-	long m_x;
-	long m_y;
-	LPDUNGEON m_pkDungeon;
-};
-
-void CDungeon::Join(LPCHARACTER ch)
-{
-	if (SECTREE_MANAGER::instance().GetMap(m_lMapIndex) == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return;
-	}
-	FWarpToDungeon(m_lMapIndex, this) (ch);
-}
-
-void CDungeon::JoinParty(LPPARTY pParty)
-{
-	pParty->SetDungeon(this);
-	m_map_pkParty.insert(std::make_pair(pParty, 0));
-
-	if (SECTREE_MANAGER::instance().GetMap(m_lMapIndex) == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return;
-	}
-	FWarpToDungeon f(m_lMapIndex, this);
-	pParty->ForEachOnlineMember(f);
-	//sys_log(0, "DUNGEON-PARTY join %p %p", this, pParty);
-}
-
-void CDungeon::QuitParty(LPPARTY pParty)
-{
-	pParty->SetDungeon(NULL);
-	//sys_log(0, "DUNGEON-PARTY quit %p %p", this, pParty);
-
-	TPartyMap::iterator it = m_map_pkParty.find(pParty);
-	if (it != m_map_pkParty.end())
-		m_map_pkParty.erase(it);
-}
-
-EVENTINFO(dungeon_id_info)
-{
-	CDungeon::IdType dungeon_id;
-
-	dungeon_id_info()
-		: dungeon_id(0)
-	{
-	}
-};
-
-EVENTFUNC(dungeon_dead_event)
-{
-	dungeon_id_info* info = dynamic_cast<dungeon_id_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("dungeon_dead_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPDUNGEON pDungeon = CDungeonManager::instance().Find(info->dungeon_id);
-	if (pDungeon == NULL)
-		return 0;
-
-	pDungeon->deadEvent = NULL;
-
-	CDungeonManager::instance().Destroy(info->dungeon_id);
-	return 0;
-}
-
-#if defined(__DUNGEON_RENEWAL__)
-void CDungeon::Destroy()
-{
-	m_set_pkCharacter.clear();
-
-	dungeon_id_info* info = AllocEventInfo<dungeon_id_info>();
-	info->dungeon_id = m_id;
-
-	event_cancel(&deadEvent);
-	deadEvent = event_create(dungeon_dead_event, info, PASSES_PER_SEC(10));
-}
-#endif
-
-void CDungeon::IncMember(LPCHARACTER ch)
-{
-	if (m_set_pkCharacter.find(ch) == m_set_pkCharacter.end())
-		m_set_pkCharacter.insert(ch);
-
-	event_cancel(&deadEvent);
-}
-
-void CDungeon::DecMember(LPCHARACTER ch)
-{
-	auto it = m_set_pkCharacter.find(ch);
-	if (it == m_set_pkCharacter.end())
-		return;
-
-	m_set_pkCharacter.erase(it);
-
-	if (m_set_pkCharacter.empty())
-	{
-		dungeon_id_info* info = AllocEventInfo<dungeon_id_info>();
-		info->dungeon_id = m_id;
-
-		event_cancel(&deadEvent);
-		deadEvent = event_create(dungeon_dead_event, info, PASSES_PER_SEC(10));
-	}
-}
-
-void CDungeon::IncPartyMember(LPPARTY pParty, LPCHARACTER ch)
-{
-	//sys_log(0, "DUNGEON-PARTY inc %p %p", this, pParty);
-	TPartyMap::iterator it = m_map_pkParty.find(pParty);
-
-	if (it != m_map_pkParty.end())
-		it->second++;
-	else
-		m_map_pkParty.insert(std::make_pair(pParty, 1));
-
-	IncMember(ch);
-}
-
-void CDungeon::DecPartyMember(LPPARTY pParty, LPCHARACTER ch)
-{
-	//sys_log(0, "DUNGEON-PARTY dec %p %p", this, pParty);
-	TPartyMap::iterator it = m_map_pkParty.find(pParty);
-
-	if (it == m_map_pkParty.end())
-		sys_err("cannot find party");
-	else
-	{
-		it->second--;
-
-		if (it->second == 0)
-			QuitParty(pParty);
-	}
-
-	DecMember(ch);
-}
-
-struct FWarpToPosition
-{
-	long lMapIndex;
-	long x;
-	long y;
-	FWarpToPosition(long lMapIndex, long x, long y)
-		: lMapIndex(lMapIndex), x(x), y(y)
-	{}
-
-	void operator()(LPENTITY ent)
-	{
-		if (!ent->IsType(ENTITY_CHARACTER))
-			return;
-
-		LPCHARACTER ch = (LPCHARACTER)ent;
-		if (!ch->IsPC())
-			return;
-
-		if (ch->GetMapIndex() == lMapIndex)
-		{
-			ch->Show(lMapIndex, x, y, 0);
-			ch->Stop();
-		}
-		else
-		{
-			ch->WarpSet(x, y, lMapIndex);
-		}
-	}
-};
-
-struct FWarpToPositionForce
-{
-	long lMapIndex;
-	long x;
-	long y;
-	FWarpToPositionForce(long lMapIndex, long x, long y)
-		: lMapIndex(lMapIndex), x(x), y(y)
-	{}
-
-	void operator()(LPENTITY ent)
-	{
-		if (!ent->IsType(ENTITY_CHARACTER))
-			return;
-
-		LPCHARACTER ch = (LPCHARACTER)ent;
-		if (!ch->IsPC())
-			return;
-
-		ch->WarpSet(x, y, lMapIndex);
-	}
-};
-
-void CDungeon::JumpAll(long lFromMapIndex, int x, int y)
-{
-	x *= 100;
-	y *= 100;
-
-	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(lFromMapIndex);
-
-	if (!pMap)
-	{
-		sys_err("cannot find map by index %d", lFromMapIndex);
-		return;
-	}
-
-	FWarpToPosition f(m_lMapIndex, x, y);
-
-	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
-	pMap->for_each(f);
-}
-
-void CDungeon::WarpAll(long lFromMapIndex, int x, int y)
-{
-	x *= 100;
-	y *= 100;
-
-	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(lFromMapIndex);
-
-	if (!pMap)
-	{
-		sys_err("cannot find map by index %d", lFromMapIndex);
-		return;
-	}
-
-	FWarpToPositionForce f(m_lMapIndex, x, y);
-
-	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
-	pMap->for_each(f);
-}
-
-#if defined(__DUNGEON_RENEWAL__)
-void CDungeon::SetParty(LPPARTY pParty)
-{
-	if (pParty->GetDungeon_for_Only_party() == NULL)
-	{
-		if (m_pParty == NULL)
-		{
-			m_pParty = pParty;
-		}
-		else if (m_pParty != pParty)
-		{
-			sys_err("Dungeon already has party : index %d", GetMapIndex());
-			return;
-		}
-		pParty->SetDungeon_for_Only_party(this);
-	}
-}
-#endif
-
-void CDungeon::JumpParty(LPPARTY pParty, long lFromMapIndex, int x, int y)
-{
-	x *= 100;
-	y *= 100;
-
-	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(lFromMapIndex);
-
-	if (!pMap)
-	{
-		sys_err("cannot find map by index %d", lFromMapIndex);
-		return;
-	}
-
-	if (pParty->GetDungeon_for_Only_party() == NULL)
-	{
-		if (m_pParty == NULL)
-		{
-			m_pParty = pParty;
-		}
-		else if (m_pParty != pParty)
-		{
-			sys_err("Dungeon already has party. Another party cannot jump in dungeon : index %d", GetMapIndex());
-			return;
-		}
-		pParty->SetDungeon_for_Only_party(this);
-	}
-
-	FWarpToPosition f(m_lMapIndex, x, y);
-
-	pParty->ForEachOnMapMember(f, lFromMapIndex);
-}
-
-void CDungeon::SetPartyNull()
-{
-	m_pParty = NULL;
-}
-
-void CDungeonManager::Destroy(CDungeon::IdType dungeon_id)
-{
-	sys_log(0, "DUNGEON destroy : map index %u", dungeon_id);
-	LPDUNGEON pDungeon = Find(dungeon_id);
-	if (pDungeon == NULL)
-		return;
-
-	m_map_pkDungeon.erase(dungeon_id);
-
-	long lMapIndex = pDungeon->m_lMapIndex;
-	m_map_pkMapDungeon.erase(lMapIndex);
-
-	DWORD server_timer_arg = lMapIndex;
-	quest::CQuestManager::instance().CancelServerTimers(server_timer_arg);
-
-#if defined(__DUNGEON_RENEWAL__)
-	pDungeon->ExitAll();
-#endif
-
-	SECTREE_MANAGER::instance().DestroyPrivateMap(lMapIndex);
-	M2_DELETE(pDungeon);
-}
-
-LPDUNGEON CDungeonManager::Find(CDungeon::IdType dungeon_id)
-{
-	auto it = m_map_pkDungeon.find(dungeon_id);
-	if (it != m_map_pkDungeon.end())
-		return it->second;
-	return NULL;
-}
-
-LPDUNGEON CDungeonManager::FindByMapIndex(long lMapIndex)
-{
-	auto it = m_map_pkMapDungeon.find(lMapIndex);
-	if (it != m_map_pkMapDungeon.end())
-		return it->second;
-	return NULL;
-}
-
-LPDUNGEON CDungeonManager::Create(long lOriginalMapIndex, EDungeonType eType)
-{
-	DWORD lPrivateMapIndex = SECTREE_MANAGER::instance().CreatePrivateMap(lOriginalMapIndex);
-	if (lPrivateMapIndex == 0)
-	{
-		sys_log(0, "Failed to Create Dungeon : OriginalMapIndex %d PrivateMapIndex %d", lOriginalMapIndex, lPrivateMapIndex);
-		return NULL;
-	}
-
-	// <Factor> TODO: Change id assignment, or drop it
-	CDungeon::IdType id = next_id_++;
-	while (Find(id) != NULL)
-	{
-		id = next_id_++;
-	}
-
-	LPDUNGEON pDungeon = NULL;
-	if (eType == DUNGEON_TYPE_DEFAULT)
-	{
-		pDungeon = M2_NEW CDungeon(id, lOriginalMapIndex, lPrivateMapIndex);
-	}
-#if defined(__DEFENSE_WAVE__)
-	else if (eType == DUNGEON_TYPE_DEFENSE_WAVE)
-	{
-		pDungeon = M2_NEW CDefenseWave(id, lOriginalMapIndex, lPrivateMapIndex);
-	}
-#endif
-
-	if (!pDungeon)
-	{
-		sys_err("Failed to create dungeon instance");
-		return NULL;
-	}
-
-	m_map_pkDungeon.emplace(id, pDungeon);
-	m_map_pkMapDungeon.emplace(lPrivateMapIndex, pDungeon);
-
-	return pDungeon;
-}
-
-CDungeonManager::CDungeonManager()
-	: next_id_(0)
-{
-}
-
-CDungeonManager::~CDungeonManager()
-{
-}
-
-void CDungeon::UniqueSetMaxHP(const std::string& key, DWORD dwMaxHP)
-{
-	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
-	if (it == m_map_UniqueMob.end())
-	{
-		sys_err("Unknown Key : %s", key.c_str());
-		return;
-	}
-	it->second->SetMaxHP(dwMaxHP);
-}
-
-void CDungeon::UniqueSetHP(const std::string& key, int iHP)
-{
-	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
-	if (it == m_map_UniqueMob.end())
-	{
-		sys_err("Unknown Key : %s", key.c_str());
-		return;
-	}
-	it->second->SetHP(iHP);
-}
-
-void CDungeon::UniqueSetDefGrade(const std::string& key, int iGrade)
-{
-	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
-	if (it == m_map_UniqueMob.end())
-	{
-		sys_err("Unknown Key : %s", key.c_str());
-		return;
-	}
-	it->second->PointChange(POINT_DEF_GRADE, iGrade - it->second->GetPoint(POINT_DEF_GRADE));
-}
-
-void CDungeon::SpawnMoveUnique(const char* key, DWORD vnum, const char* pos_from, const char* pos_to)
-{
-	TAreaMap::iterator it_to = m_map_Area.find(pos_to);
-	if (it_to == m_map_Area.end())
-	{
-		sys_err("Wrong position string : %s", pos_to);
-		return;
-	}
-
-	TAreaMap::iterator it_from = m_map_Area.find(pos_from);
-	if (it_from == m_map_Area.end())
-	{
-		sys_err("Wrong position string : %s", pos_from);
-		return;
-	}
-
-	TAreaInfo& ai = it_from->second;
-	TAreaInfo& ai_to = it_to->second;
-	int dir = ai.dir;
-	if (dir == -1)
-		dir = number(0, 359);
-
-	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (pkSectreeMap == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return;
-	}
-	for (int i = 0; i < 100; i++)
-	{
-		int dx = number(ai.sx, ai.ex);
-		int dy = number(ai.sy, ai.ey);
-		int tx = number(ai_to.sx, ai_to.ex);
-		int ty = number(ai_to.sy, ai_to.ey);
-
-		LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + dx, pkSectreeMap->m_setting.iBaseY + dy, 0, false, dir);
-
-		if (ch)
-		{
-			m_map_UniqueMob.insert(make_pair(std::string(key), ch));
-			ch->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-			ch->SetDungeon(this);
-
-			if (ch->Goto(pkSectreeMap->m_setting.iBaseX + tx, pkSectreeMap->m_setting.iBaseY + ty))
-				ch->SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
-		}
-		else
-		{
-			sys_err("Cannot spawn at %d %d", pkSectreeMap->m_setting.iBaseX + ((ai.sx + ai.ex) >> 1), pkSectreeMap->m_setting.iBaseY + ((ai.sy + ai.ey) >> 1));
-		}
-	}
-
-}
-
-void CDungeon::SpawnUnique(const char* key, DWORD vnum, const char* pos)
-{
-	TAreaMap::iterator it = m_map_Area.find(pos);
-	if (it == m_map_Area.end())
-	{
-		sys_err("Wrong position string : %s", pos);
-		return;
-	}
-
-	TAreaInfo& ai = it->second;
-	int dir = ai.dir;
-	if (dir == -1)
-		dir = number(0, 359);
-
-	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (pkSectreeMap == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return;
-	}
-	for (int i = 0; i < 100; i++)
-	{
-		int dx = number(ai.sx, ai.ex);
-		int dy = number(ai.sy, ai.ey);
-
-		LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + dx, pkSectreeMap->m_setting.iBaseY + dy, 0, false, dir);
-
-		if (ch)
-		{
-			m_map_UniqueMob.insert(make_pair(std::string(key), ch));
-			ch->SetDungeon(this);
-			ch->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-			break;
-		}
-		else
-		{
-			sys_err("Cannot spawn at %d %d", pkSectreeMap->m_setting.iBaseX + ((ai.sx + ai.ex) >> 1), pkSectreeMap->m_setting.iBaseY + ((ai.sy + ai.ey) >> 1));
-		}
-	}
-}
-
-void CDungeon::SetUnique(const char* key, DWORD vid)
-{
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().Find(vid);
-	if (ch)
-	{
-		m_map_UniqueMob.insert(make_pair(std::string(key), ch));
-		ch->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
-	}
-}
-
-void CDungeon::SpawnStoneDoor(const char* key, const char* pos)
-{
-	SpawnUnique(key, 13001, pos);
-}
-
-void CDungeon::SpawnWoodenDoor(const char* key, const char* pos)
-{
-	SpawnUnique(key, 13000, pos);
-	UniqueSetMaxHP(key, 10000);
-	UniqueSetHP(key, 10000);
-	UniqueSetDefGrade(key, 300);
-}
-
-void CDungeon::PurgeUnique(const std::string& key)
-{
-	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
-	if (it == m_map_UniqueMob.end())
-	{
-		sys_err("Unknown Key or Dead: %s", key.c_str());
-		return;
-	}
-	LPCHARACTER ch = it->second;
-	m_map_UniqueMob.erase(it);
-	M2_DESTROY_CHARACTER(ch);
-}
-
-void CDungeon::KillUnique(const std::string& key)
-{
-	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
-	if (it == m_map_UniqueMob.end())
-	{
-		sys_err("Unknown Key or Dead: %s", key.c_str());
-		return;
-	}
-	LPCHARACTER ch = it->second;
-	m_map_UniqueMob.erase(it);
-	ch->Dead();
-}
-
-DWORD CDungeon::GetUniqueVID(const std::string& key)
-{
-	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
-	if (it == m_map_UniqueMob.end())
-	{
-		sys_err("Unknown Key or Dead: %s", key.c_str());
-		return 0;
-	}
-	return it->second->GetVID();
-}
-
-bool CDungeon::IsUnique(LPCHARACTER pChar)
-{
-	TUniqueMobMap::iterator it = m_map_UniqueMob.begin();
-	for (; it != m_map_UniqueMob.end(); ++it)
-	{
-		if (it->second == pChar)
-			return true;
-	}
-	return false;
-}
-
-LPCHARACTER CDungeon::GetUnique(const std::string& key)
-{
-	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
-	if (it == m_map_UniqueMob.end())
-	{
-		sys_err("Unknown Key or Dead: %s", key.c_str());
-		return NULL;
-	}
-	return it->second;
-}
-
-float CDungeon::GetUniqueHpPerc(const std::string& key)
-{
-	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
-	if (it == m_map_UniqueMob.end())
-	{
-		sys_err("Unknown Key : %s", key.c_str());
-		return 0.0f;
-	}
-	return (100.f * it->second->GetHP()) / it->second->GetMaxHP();
-}
-
-void CDungeon::DeadCharacter(LPCHARACTER ch)
-{
-	if (!ch->IsPC())
-	{
-		TUniqueMobMap::iterator it = m_map_UniqueMob.begin();
-		while (it != m_map_UniqueMob.end())
-		{
-			if (it->second == ch)
-			{
-				//sys_log(0,"Dead unique %s", it->first.c_str());
-				m_map_UniqueMob.erase(it);
-				break;
-			}
-			++it;
-		}
-	}
-}
-
-bool CDungeon::IsUniqueDead(const std::string& key)
-{
-	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
-	if (it == m_map_UniqueMob.end())
-	{
-		sys_err("Unknown Key or Dead : %s", key.c_str());
-		return true;
-	}
-	return it->second->IsDead();
-}
-
-void CDungeon::Spawn(DWORD vnum, const char* pos)
-{
-	//sys_log(0,"DUNGEON Spawn %u %s", vnum, pos);
-	TAreaMap::iterator it = m_map_Area.find(pos);
-
-	if (it == m_map_Area.end())
-	{
-		sys_err("Wrong position string : %s", pos);
-		return;
-	}
-
-	TAreaInfo& ai = it->second;
-	int dir = ai.dir;
-	if (dir == -1)
-		dir = number(0, 359);
-
-	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (pkSectreeMap == NULL)
-	{
-		sys_err("cannot find map by index %d", m_lMapIndex);
-		return;
-	}
-	int dx = number(ai.sx, ai.ex);
-	int dy = number(ai.sy, ai.ey);
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + dx, pkSectreeMap->m_setting.iBaseY + dy, 0, false, dir);
-	if (ch)
-		ch->SetDungeon(this);
-}
-
-LPCHARACTER CDungeon::SpawnMob(DWORD vnum, int x, int y, int dir)
-{
-	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (pkSectreeMap == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return NULL;
-	}
-	sys_log(0, "CDungeon::SpawnMob %u %d %d", vnum, x, y);
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + x * 100, pkSectreeMap->m_setting.iBaseY + y * 100, 0, false, dir == 0 ? -1 : (dir - 1) * 45);
-
-	if (ch)
-	{
-		ch->SetDungeon(this);
-		sys_log(0, "CDungeon::SpawnMob name %s", ch->GetName());
-	}
-
-	return ch;
-}
-
-LPCHARACTER CDungeon::SpawnMob_ac_dir(DWORD vnum, int x, int y, int dir)
-{
-	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (pkSectreeMap == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return NULL;
-	}
-	sys_log(0, "CDungeon::SpawnMob %u %d %d", vnum, x, y);
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + x * 100, pkSectreeMap->m_setting.iBaseY + y * 100, 0, false, dir);
-
-	if (ch)
-	{
-		ch->SetDungeon(this);
-		sys_log(0, "CDungeon::SpawnMob name %s", ch->GetName());
-	}
-
-	return ch;
-}
-
-void CDungeon::SpawnNameMob(DWORD vnum, int x, int y, const char* name)
-{
-	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (pkSectreeMap == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return;
-	}
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + x, pkSectreeMap->m_setting.iBaseY + y, 0, false, -1);
-	if (ch)
-	{
-		ch->SetName(name);
-		ch->SetDungeon(this);
-	}
-}
-
-void CDungeon::SpawnGotoMob(long lFromX, long lFromY, long lToX, long lToY)
-{
-	const int MOB_GOTO_VNUM = 20039;
-
-	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (pkSectreeMap == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return;
-	}
-
-	sys_log(0, "SpawnGotoMob %d %d to %d %d", lFromX, lFromY, lToX, lToY);
-
-	lFromX = pkSectreeMap->m_setting.iBaseX + lFromX * 100;
-	lFromY = pkSectreeMap->m_setting.iBaseY + lFromY * 100;
-
-	LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(MOB_GOTO_VNUM, m_lMapIndex, lFromX, lFromY, 0, false, -1);
-
-	if (ch)
-	{
-		char buf[30 + 1];
-		snprintf(buf, sizeof(buf), ". %ld %ld", lToX, lToY);
-
-		ch->SetName(buf);
-		ch->SetDungeon(this);
-	}
-}
-
-LPCHARACTER CDungeon::SpawnGroup(DWORD vnum, long x, long y, float radius, bool bAggressive, int count)
-{
-	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (pkSectreeMap == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return NULL;
-	}
-
-	int iRadius = (int)radius;
-
-	int sx = pkSectreeMap->m_setting.iBaseX + x - iRadius;
-	int sy = pkSectreeMap->m_setting.iBaseY + y - iRadius;
-	int ex = sx + iRadius;
-	int ey = sy + iRadius;
-
-	LPCHARACTER ch = NULL;
-
-	while (count--)
-	{
-		LPCHARACTER chLeader = CHARACTER_MANAGER::instance().SpawnGroup(vnum, m_lMapIndex, sx, sy, ex, ey, NULL, bAggressive, this);
-		if (chLeader && !ch)
-			ch = chLeader;
-	}
-
-	return ch;
-}
-
-void CDungeon::SpawnRegen(const char* filename, bool bOnce)
-{
-	if (!filename)
-	{
-		sys_err("CDungeon::SpawnRegen(filename=NULL, bOnce=%d) - m_lMapIndex[%d]", bOnce, m_lMapIndex);
-		return;
-	}
-
-	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (!pkSectreeMap)
-	{
-		sys_err("CDungeon::SpawnRegen(filename=%s, bOnce=%d) - m_lMapIndex[%d]", filename, bOnce, m_lMapIndex);
-		return;
-	}
-
-	regen_do(filename, m_lMapIndex, pkSectreeMap->m_setting.iBaseX, pkSectreeMap->m_setting.iBaseY, this, bOnce);
-}
-
-void CDungeon::AddRegen(LPREGEN regen)
-{
-	regen->id = regen_id_++;
-	m_regen.push_back(regen);
-}
-
-void CDungeon::ClearRegen()
-{
-	for (auto it = m_regen.begin(); it != m_regen.end(); ++it)
-	{
-		LPREGEN regen = *it;
-
-		event_cancel(&regen->event);
-		M2_DELETE(regen);
-	}
-	m_regen.clear();
-}
-
-bool CDungeon::IsValidRegen(LPREGEN regen, size_t regen_id)
-{
-	auto it = std::find(m_regen.begin(), m_regen.end(), regen);
-	if (it == m_regen.end())
-		return false;
-	LPREGEN found = *it;
-	return (found->id == regen_id);
-}
-
-void CDungeon::SpawnMoveGroup(DWORD vnum, const char* pos_from, const char* pos_to, int count)
-{
-	TAreaMap::iterator it_to = m_map_Area.find(pos_to);
-
-	if (it_to == m_map_Area.end())
-	{
-		sys_err("Wrong position string : %s", pos_to);
-		return;
-	}
-
-	TAreaMap::iterator it_from = m_map_Area.find(pos_from);
-
-	if (it_from == m_map_Area.end())
-	{
-		sys_err("Wrong position string : %s", pos_from);
-		return;
-	}
-
-	TAreaInfo& ai = it_from->second;
-	TAreaInfo& ai_to = it_to->second;
-	int dir = ai.dir;
-
-	if (dir == -1)
-		dir = number(0, 359);
-
-	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (pkSectreeMap == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return;
-	}
-
-	while (count--)
-	{
-		int tx = number(ai_to.sx, ai_to.ex) + pkSectreeMap->m_setting.iBaseX;
-		int ty = number(ai_to.sy, ai_to.ey) + pkSectreeMap->m_setting.iBaseY;
-		CHARACTER_MANAGER::instance().SpawnMoveGroup(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + ai.sx, pkSectreeMap->m_setting.iBaseY + ai.sy, pkSectreeMap->m_setting.iBaseX + ai.ex, pkSectreeMap->m_setting.iBaseY + ai.ey, tx, ty, NULL, true);
-	}
-}
-
-namespace
-{
-	// DUNGEON_KILL_ALL_BUG_FIX
-	struct FKillSectree
-	{
-		void operator () (LPENTITY ent)
-		{
-			if (ent->IsType(ENTITY_CHARACTER))
-			{
-				LPCHARACTER ch = (LPCHARACTER)ent;
-
-				if (!ch->IsPC()
-#if defined(__PET_SYSTEM__)
-					&& !ch->IsPet()
-#endif
-					)
-					ch->Dead();
-			}
-		}
-	};
-	// END_OF_DUNGEON_KILL_ALL_BUG_FIX
-
-	struct FPurgeSectree
-	{
-		void operator () (LPENTITY ent)
-		{
-			if (ent->IsType(ENTITY_CHARACTER))
-			{
-				LPCHARACTER ch = (LPCHARACTER)ent;
-
-				if (!ch->IsPC()
-#if defined(__PET_SYSTEM__)
-					&& !ch->IsPet()
-#endif
-					)
-				{
-					M2_DESTROY_CHARACTER(ch);
-				}
-			}
-			else if (ent->IsType(ENTITY_ITEM))
-			{
-				LPITEM item = (LPITEM)ent;
-				M2_DESTROY_ITEM(item);
-			}
-			else
-				sys_err("unknown entity type %d is in dungeon", ent->GetType());
-		}
-	};
-}
-
-// DUNGEON_KILL_ALL_BUG_FIX
-void CDungeon::KillAll()
-{
-	LPSECTREE_MAP pkMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (pkMap == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return;
-	}
-	FKillSectree f;
-	pkMap->for_each(f);
-}
-// END_OF_DUNGEON_KILL_ALL_BUG_FIX
-
-void CDungeon::Purge()
-{
-	LPSECTREE_MAP pkMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-	if (pkMap == NULL)
-	{
-		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
-		return;
-	}
-	FPurgeSectree f;
-	pkMap->for_each(f);
-}
-
-void CDungeon::IncKillCount(LPCHARACTER pkKiller, LPCHARACTER pkVictim)
-{
-	if (pkVictim->IsStone())
-		m_iStoneKill++;
-	else
-		m_iMobKill++;
-}
-
-void CDungeon::UsePotion(LPCHARACTER ch)
-{
-	m_bUsePotion = true;
-}
-
-void CDungeon::UseRevive(LPCHARACTER ch)
-{
-	m_bUseRevive = true;
-}
-
-bool CDungeon::IsUsePotion()
-{
-	return m_bUsePotion;
-}
-
-bool CDungeon::IsUseRevive()
-{
-	return m_bUseRevive;
-}
-
-int CDungeon::GetKillMobCount()
-{
-	return m_iMobKill;
-}
-int CDungeon::GetKillStoneCount()
-{
-	return m_iStoneKill;
-}
-
-struct FCountMonster
-{
-	int n;
-	FCountMonster() : n(0) {};
-	void operator()(LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-			if (ch->IsMonster() || ch->IsStone())
-				n++;
-		}
-	}
-};
-
-int CDungeon::CountRealMonster()
-{
-	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lOrigMapIndex);
-
-	if (!pMap)
-	{
-		sys_err("cannot find map by index %d", m_lOrigMapIndex);
-		return 0;
-	}
-
-	FCountMonster f;
-
-	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
-	pMap->for_each(f);
-	return f.n;
-}
-
-struct FExitDungeon
-{
-	void operator()(LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-
-			if (ch->IsPC())
-				ch->ExitToSavedLocation();
-		}
-	}
-};
-
-void CDungeon::ExitAll()
-{
-	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-
-	if (!pMap)
-	{
-		sys_err("cannot find map by index %d", m_lMapIndex);
-		return;
-	}
-
-	FExitDungeon f;
-
-	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
-	pMap->for_each(f);
-}
-
-// DUNGEON_NOTICE
-namespace
-{
-	struct FNotice
-	{
-		FNotice(const char* psz) : m_psz(psz) {}
-		void operator() (LPENTITY ent)
-		{
-			if (ent->IsType(ENTITY_CHARACTER))
-			{
-				LPCHARACTER ch = (LPCHARACTER)ent;
-				if (ch->IsPC())
-				{
-					ch->ChatPacket(CHAT_TYPE_NOTICE, "%s", m_psz);
-				}
-			}
-		}
-		const char* m_psz;
-	};
-
-	struct FMissionMessage
-	{
-		FMissionMessage(const char* psz) : m_psz(psz) {}
-		void operator() (LPENTITY ent)
-		{
-			if (ent->IsType(ENTITY_CHARACTER))
-			{
-				LPCHARACTER ch = (LPCHARACTER)ent;
-				if (ch->IsPC())
-				{
-					ch->ChatPacket(CHAT_TYPE_MISSION, "%s", m_psz);
-				}
-			}
-		}
-		const char* m_psz;
-	};
-
-	struct FSubMissionMessage
-	{
-		FSubMissionMessage(const char* psz) : m_psz(psz) {}
-		void operator() (LPENTITY ent)
-		{
-			if (ent->IsType(ENTITY_CHARACTER))
-			{
-				LPCHARACTER ch = (LPCHARACTER)ent;
-				if (ch->IsPC())
-				{
-					ch->ChatPacket(CHAT_TYPE_SUB_MISSION, "%s", m_psz);
-				}
-			}
-		}
-		const char* m_psz;
-	};
-}
-
-void CDungeon::Notice(const char* msg)
-{
-	sys_log(0, "XXX Dungeon Notice %p %s", this, msg);
-	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-
-	if (!pMap)
-	{
-		sys_err("cannot find map by index %d", m_lMapIndex);
-		return;
-	}
-
-	FNotice f(msg);
-	pMap->for_each(f);
-}
-
-void CDungeon::MissionMessage(const char* msg)
-{
-	sys_log(0, "XXX Dungeon Mission Message %p %s", this, msg);
-	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-
-	if (!pMap)
-	{
-		sys_err("cannot find map by index %d", m_lMapIndex);
-		return;
-	}
-
-	FMissionMessage f(msg);
-	pMap->for_each(f);
-}
-
-void CDungeon::SubMissionMessage(const char* msg)
-{
-	sys_log(0, "XXX Dungeon SubMission Message %p %s", this, msg);
-	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-
-	if (!pMap)
-	{
-		sys_err("cannot find map by index %d", m_lMapIndex);
-		return;
-	}
-
-	FSubMissionMessage f(msg);
-	pMap->for_each(f);
-}
-// END_OF_DUNGEON_NOTICE
-
-struct FExitDungeonToStartPosition
-{
-	void operator () (LPENTITY ent)
-	{
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-
-			if (ch->IsPC())
-			{
-				PIXEL_POSITION posWarp;
-
-				// ÇöÀç ¸Ê ÀÎµ¦½º¸¦ ³Ö´Â °ÍÀÌ ¾Æ´Ï¶ó ½ÃÀÛÇÏ´Â ¸Ê ÀÎµ¦½º¸¦ ³Ö´Â´Ù.
-				if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(g_start_map[ch->GetEmpire()], ch->GetEmpire(), posWarp))
-					ch->WarpSet(posWarp.x, posWarp.y);
-				else
-					ch->ExitToSavedLocation();
-			}
-		}
-	}
-};
-
-void CDungeon::ExitAllToStartPosition()
-{
-	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-
-	if (!pMap)
-	{
-		sys_err("cannot find map by index %d", m_lMapIndex);
-		return;
-	}
-
-	FExitDungeonToStartPosition f;
-
-	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
-	pMap->for_each(f);
-}
-
-EVENTFUNC(dungeon_jump_to_event)
-{
-	dungeon_id_info* info = dynamic_cast<dungeon_id_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("dungeon_jump_to_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPDUNGEON pDungeon = CDungeonManager::instance().Find(info->dungeon_id);
-	pDungeon->jump_to_event_ = NULL;
-
-	if (pDungeon)
-		pDungeon->JumpToEliminateLocation();
-	else
-		sys_err("cannot find dungeon with map index %u", info->dungeon_id);
-
-	return 0;
-}
-
-EVENTFUNC(dungeon_exit_all_event)
-{
-	dungeon_id_info* info = dynamic_cast<dungeon_id_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("dungeon_exit_all_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	LPDUNGEON pDungeon = CDungeonManager::instance().Find(info->dungeon_id);
-	pDungeon->exit_all_event_ = NULL;
-
-	if (pDungeon)
-		pDungeon->ExitAll();
-
-	return 0;
-}
-
-void CDungeon::CheckEliminated()
-{
-	if (m_iMonsterCount > 0)
-		return;
-
-	if (m_bExitAllAtEliminate)
-	{
-		sys_log(0, "CheckEliminated: exit");
-		m_bExitAllAtEliminate = false;
-
-		if (m_iWarpDelay)
-		{
-			dungeon_id_info* info = AllocEventInfo<dungeon_id_info>();
-			info->dungeon_id = m_id;
-
-			event_cancel(&exit_all_event_);
-			exit_all_event_ = event_create(dungeon_exit_all_event, info, PASSES_PER_SEC(m_iWarpDelay));
-		}
-		else
-		{
-			ExitAll();
-		}
-	}
-	else if (m_bWarpAtEliminate)
-	{
-		sys_log(0, "CheckEliminated: warp");
-		m_bWarpAtEliminate = false;
-
-		if (m_iWarpDelay)
-		{
-			dungeon_id_info* info = AllocEventInfo<dungeon_id_info>();
-			info->dungeon_id = m_id;
-
-			event_cancel(&jump_to_event_);
-			jump_to_event_ = event_create(dungeon_jump_to_event, info, PASSES_PER_SEC(m_iWarpDelay));
-		}
-		else
-		{
-			JumpToEliminateLocation();
-		}
-	}
-#ifdef _EXE_
-	else if (m_bCheckEliminate)
-	{
-		sys_log(0, "CheckEliminated: check");
-		m_bCheckEliminate = false;
-
-		CheckEliminateLocation();
-	}
-#endif
-	else
-		sys_log(0, "CheckEliminated: none");
-}
-
-void CDungeon::SetExitAllAtEliminate(long time)
-{
-	sys_log(0, "SetExitAllAtEliminate: time %d", time);
-	m_bExitAllAtEliminate = true;
-	m_iWarpDelay = time;
-}
-
-void CDungeon::SetWarpAtEliminate(long time, long lMapIndex, int x, int y, const char* regen_file)
-{
-	m_bWarpAtEliminate = true;
-	m_iWarpDelay = time;
-	m_lWarpMapIndex = lMapIndex;
-	m_lWarpX = x;
-	m_lWarpY = y;
-
-	if (!regen_file || !*regen_file)
-		m_stRegenFile.clear();
-	else
-		m_stRegenFile = regen_file;
-
-	sys_log(0, "SetWarpAtEliminate: time %d map %d %dx%d regenfile %s", time, lMapIndex, x, y, m_stRegenFile.c_str());
-}
-
-void CDungeon::JumpToEliminateLocation()
-{
-	LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(m_lWarpMapIndex);
-
-	if (pDungeon)
-	{
-		pDungeon->JumpAll(m_lMapIndex, m_lWarpX, m_lWarpY);
-
-		if (!m_stRegenFile.empty())
-		{
-			pDungeon->SpawnRegen(m_stRegenFile.c_str());
-			m_stRegenFile.clear();
-		}
-	}
-	else
-	{
-		// ÀÏ¹Ý ¸ÊÀ¸·Î ¿öÇÁ
-		LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-
-		if (!pMap)
-		{
-			sys_err("no map by index %d", m_lMapIndex);
-			return;
-		}
-
-		FWarpToPosition f(m_lWarpMapIndex, m_lWarpX * 100, m_lWarpY * 100);
-
-		// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
-		pMap->for_each(f);
-	}
-}
-
-#ifdef _EXE_
-void CDungeon::SetEliminate(long lMapIndex, const char* regen_file)
-{
-	m_bCheckEliminate = true;
-	m_lWarpMapIndex = lMapIndex;
-
-	if (!regen_file || !*regen_file)
-		m_stRegenFile.clear();
-	else
-		m_stRegenFile = regen_file;
-
-	sys_log(0, "SetEliminate: regenfile %s", m_stRegenFile.c_str());
-}
-
-bool CDungeon::CheckAllEliminated()
-{
-	if (m_iMonsterCount > 0)
-		return false;
-
-	if (m_bCheckEliminate)
-		return true;
-
-	return false;
-}
-
-void CDungeon::CheckEliminateLocation()
-{
-	LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(m_lWarpMapIndex);
-
-	if (pDungeon)
-	{
-		if (!m_stRegenFile.empty())
-		{
-			pDungeon->SpawnRegen(m_stRegenFile.c_str());
-			m_stRegenFile.clear();
-		}
-	}
-}
-#endif
-
-struct FNearPosition
-{
-	long x;
-	long y;
-	int dist;
-	bool ret;
-
-	FNearPosition(long x, long y, int d) :
-		x(x), y(y), dist(d), ret(true)
-	{
-	}
-
-	void operator()(LPENTITY ent)
-	{
-		if (ret == false)
-			return;
-
-		if (ent->IsType(ENTITY_CHARACTER))
-		{
-			LPCHARACTER ch = (LPCHARACTER)ent;
-
-			if (ch->IsPC())
-			{
-				if (DISTANCE_APPROX(ch->GetX() - x * 100, ch->GetY() - y * 100) > dist * 100)
-					ret = false;
-			}
-		}
-	}
-};
-
-bool CDungeon::IsAllPCNearTo(int x, int y, int dist)
-{
-	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
-
-	if (!pMap)
-	{
-		sys_err("cannot find map by index %d", m_lMapIndex);
-		return false;
-	}
-
-	FNearPosition f(x, y, dist);
-
-	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
-	pMap->for_each(f);
-
-	return f.ret;
-}
-
-void CDungeon::CreateItemGroup(std::string& group_name, ItemGroup& item_group)
-{
-	m_map_ItemGroup.insert(ItemGroupMap::value_type(group_name, item_group));
-}
-
-const CDungeon::ItemGroup* CDungeon::GetItemGroup(std::string& group_name)
-{
-	ItemGroupMap::iterator it = m_map_ItemGroup.find(group_name);
-	if (it != m_map_ItemGroup.end())
-		return &(it->second);
-	else
-		return NULL;
-}
+#include "stdafx.h"
+#include "dungeon.h"
+#include "char.h"
+#include "char_manager.h"
+#include "party.h"
+#include "affect.h"
+#include "packet.h"
+#include "desc.h"
+#include "config.h"
+#include "regen.h"
+#include "start_position.h"
+#include "item.h"
+#include "item_manager.h"
+#include "utils.h"
+#include "questmanager.h"
+#include "desc_manager.h"
+
+#if defined(__DEFENSE_WAVE__)
+#	include "defense_wave.h"
+#endif
+
+CDungeon::CDungeon(IdType id, long lOriginalMapIndex, long lMapIndex)
+	: m_id(id),
+	m_lOrigMapIndex(lOriginalMapIndex),
+	m_lMapIndex(lMapIndex),
+	m_map_Area(SECTREE_MANAGER::instance().GetDungeonArea(lOriginalMapIndex))
+{
+	Initialize();
+	// sys_log(0,"DUNGEON create orig %d real %d", lOriginalMapIndex, lMapIndex);
+}
+
+CDungeon::~CDungeon()
+{
+	if (m_pParty != NULL)
+	{
+		m_pParty->SetDungeon_for_Only_party(NULL);
+	}
+	// sys_log(0,"DUNGEON destroy orig %d real %d", m_lOrigMapIndex, m_lMapIndex	);
+	ClearRegen();
+	event_cancel(&deadEvent);
+	// <Factor>
+	event_cancel(&exit_all_event_);
+	event_cancel(&jump_to_event_);
+}
+
+void CDungeon::Initialize()
+{
+	deadEvent = NULL;
+	// <Factor>
+	exit_all_event_ = NULL;
+	jump_to_event_ = NULL;
+	regen_id_ = 0;
+
+	m_iMobKill = 0;
+	m_iStoneKill = 0;
+	m_bUsePotion = false;
+	m_bUseRevive = false;
+
+	m_iMonsterCount = 0;
+
+	m_bExitAllAtEliminate = false;
+	m_bWarpAtEliminate = false;
+#ifdef _EXE_
+	m_bCheckEliminate = false;
+#endif
+
+	m_iWarpDelay = 0;
+	m_lWarpMapIndex = 0;
+	m_lWarpX = 0;
+	m_lWarpY = 0;
+
+	m_stRegenFile = "";
+
+	m_pParty = NULL;
+}
+
+void CDungeon::SetFlag(std::string name, int value)
+{
+	auto it =  m_map_Flag.find(name);
+	if (it != m_map_Flag.end())
+		it->second = value;
+	else
+		m_map_Flag.insert(make_pair(name, value));
+}
+
+int CDungeon::GetFlag(std::string name)
+{
+	auto it =  m_map_Flag.find(name);
+	if (it != m_map_Flag.end())
+		return it->second;
+	else
+		return 0;
+}
+
+struct FSendDestPosition
+{
+	FSendDestPosition(long x, long y)
+	{
+		p1.bHeader = HEADER_GC_DUNGEON;
+		p1.subheader = DUNGEON_SUBHEADER_GC_DESTINATION_POSITION;
+		p2.x = x;
+		p2.y = y;
+		p1.size = sizeof(p1) + sizeof(p2);
+	}
+
+	void operator()(LPCHARACTER ch)
+	{
+		if (!ch)
+			return;
+
+		LPDESC d = ch->GetDesc();
+		if (!d)
+			return;
+
+		d->BufferedPacket(&p1, sizeof(TPacketGCDungeon));
+		d->Packet(&p2, sizeof(TPacketGCDungeonDestPosition));
+	}
+
+	TPacketGCDungeon p1;
+	TPacketGCDungeonDestPosition p2;
+};
+
+void CDungeon::SendDestPositionToParty(LPPARTY pParty, long x, long y)
+{
+	if (m_map_pkParty.find(pParty) == m_map_pkParty.end())
+	{
+		sys_err("PARTY %u not in DUNGEON %d", pParty->GetLeaderPID(), m_lMapIndex);
+		return;
+	}
+
+	FSendDestPosition f(x, y);
+	pParty->ForEachNearMember(f);
+}
+
+struct FWarpToDungeon
+{
+	FWarpToDungeon(long lMapIndex, LPDUNGEON d)
+		: m_lMapIndex(lMapIndex), m_pkDungeon(d)
+	{
+		LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(lMapIndex);
+		m_x = pkSectreeMap->m_setting.posSpawn.x;
+		m_y = pkSectreeMap->m_setting.posSpawn.y;
+	}
+
+	void operator () (LPCHARACTER ch)
+	{
+		ch->SaveExitLocation();
+		ch->WarpSet(m_x, m_y, m_lMapIndex);
+		//m_pkDungeon->IncPartyMember(ch->GetParty());
+	}
+
+	long m_lMapIndex;
+	long m_x;
+	long m_y;
+	LPDUNGEON m_pkDungeon;
+};
+
+void CDungeon::Join(LPCHARACTER ch)
+{
+	if (SECTREE_MANAGER::instance().GetMap(m_lMapIndex) == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return;
+	}
+	FWarpToDungeon(m_lMapIndex, this) (ch);
+}
+
+void CDungeon::JoinParty(LPPARTY pParty)
+{
+	pParty->SetDungeon(this);
+	m_map_pkParty.insert(std::make_pair(pParty, 0));
+
+	if (SECTREE_MANAGER::instance().GetMap(m_lMapIndex) == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return;
+	}
+	FWarpToDungeon f(m_lMapIndex, this);
+	pParty->ForEachOnlineMember(f);
+	//sys_log(0, "DUNGEON-PARTY join %p %p", this, pParty);
+}
+
+void CDungeon::QuitParty(LPPARTY pParty)
+{
+	pParty->SetDungeon(NULL);
+	//sys_log(0, "DUNGEON-PARTY quit %p %p", this, pParty);
+
+	TPartyMap::iterator it = m_map_pkParty.find(pParty);
+	if (it != m_map_pkParty.end())
+		m_map_pkParty.erase(it);
+}
+
+EVENTINFO(dungeon_id_info)
+{
+	CDungeon::IdType dungeon_id;
+
+	dungeon_id_info()
+		: dungeon_id(0)
+	{
+	}
+};
+
+EVENTFUNC(dungeon_dead_event)
+{
+	dungeon_id_info* info = dynamic_cast<dungeon_id_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("dungeon_dead_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPDUNGEON pDungeon = CDungeonManager::instance().Find(info->dungeon_id);
+	if (pDungeon == NULL)
+		return 0;
+
+	pDungeon->deadEvent = NULL;
+
+	CDungeonManager::instance().Destroy(info->dungeon_id);
+	return 0;
+}
+
+#if defined(__DUNGEON_RENEWAL__)
+void CDungeon::Destroy()
+{
+	m_set_pkCharacter.clear();
+
+	dungeon_id_info* info = AllocEventInfo<dungeon_id_info>();
+	info->dungeon_id = m_id;
+
+	event_cancel(&deadEvent);
+	deadEvent = event_create(dungeon_dead_event, info, PASSES_PER_SEC(10));
+}
+#endif
+
+void CDungeon::IncMember(LPCHARACTER ch)
+{
+	if (m_set_pkCharacter.find(ch) == m_set_pkCharacter.end())
+		m_set_pkCharacter.insert(ch);
+
+	event_cancel(&deadEvent);
+}
+
+void CDungeon::DecMember(LPCHARACTER ch)
+{
+	auto it = m_set_pkCharacter.find(ch);
+	if (it == m_set_pkCharacter.end())
+		return;
+
+	m_set_pkCharacter.erase(it);
+
+	if (m_set_pkCharacter.empty())
+	{
+		dungeon_id_info* info = AllocEventInfo<dungeon_id_info>();
+		info->dungeon_id = m_id;
+
+		event_cancel(&deadEvent);
+		deadEvent = event_create(dungeon_dead_event, info, PASSES_PER_SEC(10));
+	}
+}
+
+void CDungeon::IncPartyMember(LPPARTY pParty, LPCHARACTER ch)
+{
+	//sys_log(0, "DUNGEON-PARTY inc %p %p", this, pParty);
+	TPartyMap::iterator it = m_map_pkParty.find(pParty);
+
+	if (it != m_map_pkParty.end())
+		it->second++;
+	else
+		m_map_pkParty.insert(std::make_pair(pParty, 1));
+
+	IncMember(ch);
+}
+
+void CDungeon::DecPartyMember(LPPARTY pParty, LPCHARACTER ch)
+{
+	//sys_log(0, "DUNGEON-PARTY dec %p %p", this, pParty);
+	TPartyMap::iterator it = m_map_pkParty.find(pParty);
+
+	if (it == m_map_pkParty.end())
+		sys_err("cannot find party");
+	else
+	{
+		it->second--;
+
+		if (it->second == 0)
+			QuitParty(pParty);
+	}
+
+	DecMember(ch);
+}
+
+struct FWarpToPosition
+{
+	long lMapIndex;
+	long x;
+	long y;
+	FWarpToPosition(long lMapIndex, long x, long y)
+		: lMapIndex(lMapIndex), x(x), y(y)
+	{}
+
+	void operator()(LPENTITY ent)
+	{
+		if (!ent->IsType(ENTITY_CHARACTER))
+			return;
+
+		LPCHARACTER ch = (LPCHARACTER)ent;
+		if (!ch->IsPC())
+			return;
+
+		if (ch->GetMapIndex() == lMapIndex)
+		{
+			ch->Show(lMapIndex, x, y, 0);
+			ch->Stop();
+		}
+		else
+		{
+			ch->WarpSet(x, y, lMapIndex);
+		}
+	}
+};
+
+struct FWarpToPositionForce
+{
+	long lMapIndex;
+	long x;
+	long y;
+	FWarpToPositionForce(long lMapIndex, long x, long y)
+		: lMapIndex(lMapIndex), x(x), y(y)
+	{}
+
+	void operator()(LPENTITY ent)
+	{
+		if (!ent->IsType(ENTITY_CHARACTER))
+			return;
+
+		LPCHARACTER ch = (LPCHARACTER)ent;
+		if (!ch->IsPC())
+			return;
+
+		ch->WarpSet(x, y, lMapIndex);
+	}
+};
+
+void CDungeon::JumpAll(long lFromMapIndex, int x, int y)
+{
+	x *= 100;
+	y *= 100;
+
+	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(lFromMapIndex);
+
+	if (!pMap)
+	{
+		sys_err("cannot find map by index %d", lFromMapIndex);
+		return;
+	}
+
+	FWarpToPosition f(m_lMapIndex, x, y);
+
+	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
+	pMap->for_each(f);
+}
+
+void CDungeon::WarpAll(long lFromMapIndex, int x, int y)
+{
+	x *= 100;
+	y *= 100;
+
+	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(lFromMapIndex);
+
+	if (!pMap)
+	{
+		sys_err("cannot find map by index %d", lFromMapIndex);
+		return;
+	}
+
+	FWarpToPositionForce f(m_lMapIndex, x, y);
+
+	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
+	pMap->for_each(f);
+}
+
+#if defined(__DUNGEON_RENEWAL__)
+void CDungeon::SetParty(LPPARTY pParty)
+{
+	if (pParty->GetDungeon_for_Only_party() == NULL)
+	{
+		if (m_pParty == NULL)
+		{
+			m_pParty = pParty;
+		}
+		else if (m_pParty != pParty)
+		{
+			sys_err("Dungeon already has party : index %d", GetMapIndex());
+			return;
+		}
+		pParty->SetDungeon_for_Only_party(this);
+	}
+}
+#endif
+
+void CDungeon::JumpParty(LPPARTY pParty, long lFromMapIndex, int x, int y)
+{
+	x *= 100;
+	y *= 100;
+
+	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(lFromMapIndex);
+
+	if (!pMap)
+	{
+		sys_err("cannot find map by index %d", lFromMapIndex);
+		return;
+	}
+
+	if (pParty->GetDungeon_for_Only_party() == NULL)
+	{
+		if (m_pParty == NULL)
+		{
+			m_pParty = pParty;
+		}
+		else if (m_pParty != pParty)
+		{
+			sys_err("Dungeon already has party. Another party cannot jump in dungeon : index %d", GetMapIndex());
+			return;
+		}
+		pParty->SetDungeon_for_Only_party(this);
+	}
+
+	FWarpToPosition f(m_lMapIndex, x, y);
+
+	pParty->ForEachOnMapMember(f, lFromMapIndex);
+}
+
+void CDungeon::SetPartyNull()
+{
+	m_pParty = NULL;
+}
+
+void CDungeonManager::Destroy(CDungeon::IdType dungeon_id)
+{
+	sys_log(0, "DUNGEON destroy : map index %u", dungeon_id);
+	LPDUNGEON pDungeon = Find(dungeon_id);
+	if (pDungeon == NULL)
+		return;
+
+	m_map_pkDungeon.erase(dungeon_id);
+
+	long lMapIndex = pDungeon->m_lMapIndex;
+	m_map_pkMapDungeon.erase(lMapIndex);
+
+	DWORD server_timer_arg = lMapIndex;
+	quest::CQuestManager::instance().CancelServerTimers(server_timer_arg);
+
+#if defined(__DUNGEON_RENEWAL__)
+	pDungeon->ExitAll();
+#endif
+
+	SECTREE_MANAGER::instance().DestroyPrivateMap(lMapIndex);
+	M2_DELETE(pDungeon);
+}
+
+LPDUNGEON CDungeonManager::Find(CDungeon::IdType dungeon_id)
+{
+	auto it = m_map_pkDungeon.find(dungeon_id);
+	if (it != m_map_pkDungeon.end())
+		return it->second;
+	return NULL;
+}
+
+LPDUNGEON CDungeonManager::FindByMapIndex(long lMapIndex)
+{
+	auto it = m_map_pkMapDungeon.find(lMapIndex);
+	if (it != m_map_pkMapDungeon.end())
+		return it->second;
+	return NULL;
+}
+
+LPDUNGEON CDungeonManager::Create(long lOriginalMapIndex, EDungeonType eType)
+{
+	DWORD lPrivateMapIndex = SECTREE_MANAGER::instance().CreatePrivateMap(lOriginalMapIndex);
+	if (lPrivateMapIndex == 0)
+	{
+		sys_log(0, "Failed to Create Dungeon : OriginalMapIndex %d PrivateMapIndex %d", lOriginalMapIndex, lPrivateMapIndex);
+		return NULL;
+	}
+
+	// <Factor> TODO: Change id assignment, or drop it
+	CDungeon::IdType id = next_id_++;
+	while (Find(id) != NULL)
+	{
+		id = next_id_++;
+	}
+
+	LPDUNGEON pDungeon = NULL;
+	if (eType == DUNGEON_TYPE_DEFAULT)
+	{
+		pDungeon = M2_NEW CDungeon(id, lOriginalMapIndex, lPrivateMapIndex);
+	}
+#if defined(__DEFENSE_WAVE__)
+	else if (eType == DUNGEON_TYPE_DEFENSE_WAVE)
+	{
+		pDungeon = M2_NEW CDefenseWave(id, lOriginalMapIndex, lPrivateMapIndex);
+	}
+#endif
+
+	if (!pDungeon)
+	{
+		sys_err("Failed to create dungeon instance");
+		return NULL;
+	}
+
+	m_map_pkDungeon.emplace(id, pDungeon);
+	m_map_pkMapDungeon.emplace(lPrivateMapIndex, pDungeon);
+
+	return pDungeon;
+}
+
+CDungeonManager::CDungeonManager()
+	: next_id_(0)
+{
+}
+
+CDungeonManager::~CDungeonManager()
+{
+}
+
+void CDungeon::UniqueSetMaxHP(const std::string& key, DWORD dwMaxHP)
+{
+	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
+	if (it == m_map_UniqueMob.end())
+	{
+		sys_err("Unknown Key : %s", key.c_str());
+		return;
+	}
+	it->second->SetMaxHP(dwMaxHP);
+}
+
+void CDungeon::UniqueSetHP(const std::string& key, int iHP)
+{
+	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
+	if (it == m_map_UniqueMob.end())
+	{
+		sys_err("Unknown Key : %s", key.c_str());
+		return;
+	}
+	it->second->SetHP(iHP);
+}
+
+void CDungeon::UniqueSetDefGrade(const std::string& key, int iGrade)
+{
+	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
+	if (it == m_map_UniqueMob.end())
+	{
+		sys_err("Unknown Key : %s", key.c_str());
+		return;
+	}
+	it->second->PointChange(POINT_DEF_GRADE, iGrade - it->second->GetPoint(POINT_DEF_GRADE));
+}
+
+void CDungeon::SpawnMoveUnique(const char* key, DWORD vnum, const char* pos_from, const char* pos_to)
+{
+	TAreaMap::iterator it_to = m_map_Area.find(pos_to);
+	if (it_to == m_map_Area.end())
+	{
+		sys_err("Wrong position string : %s", pos_to);
+		return;
+	}
+
+	TAreaMap::iterator it_from = m_map_Area.find(pos_from);
+	if (it_from == m_map_Area.end())
+	{
+		sys_err("Wrong position string : %s", pos_from);
+		return;
+	}
+
+	TAreaInfo& ai = it_from->second;
+	TAreaInfo& ai_to = it_to->second;
+	int dir = ai.dir;
+	if (dir == -1)
+		dir = number(0, 359);
+
+	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (pkSectreeMap == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return;
+	}
+	for (int i = 0; i < 100; i++)
+	{
+		int dx = number(ai.sx, ai.ex);
+		int dy = number(ai.sy, ai.ey);
+		int tx = number(ai_to.sx, ai_to.ex);
+		int ty = number(ai_to.sy, ai_to.ey);
+
+		LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + dx, pkSectreeMap->m_setting.iBaseY + dy, 0, false, dir);
+
+		if (ch)
+		{
+			m_map_UniqueMob.insert(make_pair(std::string(key), ch));
+			ch->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+			ch->SetDungeon(this);
+
+			if (ch->Goto(pkSectreeMap->m_setting.iBaseX + tx, pkSectreeMap->m_setting.iBaseY + ty))
+				ch->SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
+		}
+		else
+		{
+			sys_err("Cannot spawn at %d %d", pkSectreeMap->m_setting.iBaseX + ((ai.sx + ai.ex) >> 1), pkSectreeMap->m_setting.iBaseY + ((ai.sy + ai.ey) >> 1));
+		}
+	}
+
+}
+
+void CDungeon::SpawnUnique(const char* key, DWORD vnum, const char* pos)
+{
+	TAreaMap::iterator it = m_map_Area.find(pos);
+	if (it == m_map_Area.end())
+	{
+		sys_err("Wrong position string : %s", pos);
+		return;
+	}
+
+	TAreaInfo& ai = it->second;
+	int dir = ai.dir;
+	if (dir == -1)
+		dir = number(0, 359);
+
+	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (pkSectreeMap == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return;
+	}
+	for (int i = 0; i < 100; i++)
+	{
+		int dx = number(ai.sx, ai.ex);
+		int dy = number(ai.sy, ai.ey);
+
+		LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + dx, pkSectreeMap->m_setting.iBaseY + dy, 0, false, dir);
+
+		if (ch)
+		{
+			m_map_UniqueMob.insert(make_pair(std::string(key), ch));
+			ch->SetDungeon(this);
+			ch->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+			break;
+		}
+		else
+		{
+			sys_err("Cannot spawn at %d %d", pkSectreeMap->m_setting.iBaseX + ((ai.sx + ai.ex) >> 1), pkSectreeMap->m_setting.iBaseY + ((ai.sy + ai.ey) >> 1));
+		}
+	}
+}
+
+void CDungeon::SetUnique(const char* key, DWORD vid)
+{
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().Find(vid);
+	if (ch)
+	{
+		m_map_UniqueMob.insert(make_pair(std::string(key), ch));
+		ch->AddAffect(AFFECT_DUNGEON_UNIQUE, POINT_NONE, 0, AFF_DUNGEON_UNIQUE, 65535, 0, true);
+	}
+}
+
+void CDungeon::SpawnStoneDoor(const char* key, const char* pos)
+{
+	SpawnUnique(key, 13001, pos);
+}
+
+void CDungeon::SpawnWoodenDoor(const char* key, const char* pos)
+{
+	SpawnUnique(key, 13000, pos);
+	UniqueSetMaxHP(key, 10000);
+	UniqueSetHP(key, 10000);
+	UniqueSetDefGrade(key, 300);
+}
+
+void CDungeon::PurgeUnique(const std::string& key)
+{
+	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
+	if (it == m_map_UniqueMob.end())
+	{
+		sys_err("Unknown Key or Dead: %s", key.c_str());
+		return;
+	}
+	LPCHARACTER ch = it->second;
+	m_map_UniqueMob.erase(it);
+	M2_DESTROY_CHARACTER(ch);
+}
+
+void CDungeon::KillUnique(const std::string& key)
+{
+	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
+	if (it == m_map_UniqueMob.end())
+	{
+		sys_err("Unknown Key or Dead: %s", key.c_str());
+		return;
+	}
+	LPCHARACTER ch = it->second;
+	m_map_UniqueMob.erase(it);
+	ch->Dead();
+}
+
+DWORD CDungeon::GetUniqueVID(const std::string& key)
+{
+	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
+	if (it == m_map_UniqueMob.end())
+	{
+		sys_err("Unknown Key or Dead: %s", key.c_str());
+		return 0;
+	}
+	return it->second->GetVID();
+}
+
+bool CDungeon::IsUnique(LPCHARACTER pChar)
+{
+	TUniqueMobMap::iterator it = m_map_UniqueMob.begin();
+	for (; it != m_map_UniqueMob.end(); ++it)
+	{
+		if (it->second == pChar)
+			return true;
+	}
+	return false;
+}
+
+LPCHARACTER CDungeon::GetUnique(const std::string& key)
+{
+	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
+	if (it == m_map_UniqueMob.end())
+	{
+		sys_err("Unknown Key or Dead: %s", key.c_str());
+		return NULL;
+	}
+	return it->second;
+}
+
+float CDungeon::GetUniqueHpPerc(const std::string& key)
+{
+	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
+	if (it == m_map_UniqueMob.end())
+	{
+		sys_err("Unknown Key : %s", key.c_str());
+		return 0.0f;
+	}
+	return (100.f * it->second->GetHP()) / it->second->GetMaxHP();
+}
+
+void CDungeon::DeadCharacter(LPCHARACTER ch)
+{
+	if (!ch->IsPC())
+	{
+		TUniqueMobMap::iterator it = m_map_UniqueMob.begin();
+		while (it != m_map_UniqueMob.end())
+		{
+			if (it->second == ch)
+			{
+				//sys_log(0,"Dead unique %s", it->first.c_str());
+				m_map_UniqueMob.erase(it);
+				break;
+			}
+			++it;
+		}
+	}
+}
+
+bool CDungeon::IsUniqueDead(const std::string& key)
+{
+	TUniqueMobMap::iterator it = m_map_UniqueMob.find(key);
+	if (it == m_map_UniqueMob.end())
+	{
+		sys_err("Unknown Key or Dead : %s", key.c_str());
+		return true;
+	}
+	return it->second->IsDead();
+}
+
+void CDungeon::Spawn(DWORD vnum, const char* pos)
+{
+	//sys_log(0,"DUNGEON Spawn %u %s", vnum, pos);
+	TAreaMap::iterator it = m_map_Area.find(pos);
+
+	if (it == m_map_Area.end())
+	{
+		sys_err("Wrong position string : %s", pos);
+		return;
+	}
+
+	TAreaInfo& ai = it->second;
+	int dir = ai.dir;
+	if (dir == -1)
+		dir = number(0, 359);
+
+	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (pkSectreeMap == NULL)
+	{
+		sys_err("cannot find map by index %d", m_lMapIndex);
+		return;
+	}
+	int dx = number(ai.sx, ai.ex);
+	int dy = number(ai.sy, ai.ey);
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + dx, pkSectreeMap->m_setting.iBaseY + dy, 0, false, dir);
+	if (ch)
+		ch->SetDungeon(this);
+}
+
+LPCHARACTER CDungeon::SpawnMob(DWORD vnum, int x, int y, int dir)
+{
+	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (pkSectreeMap == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return NULL;
+	}
+	sys_log(0, "CDungeon::SpawnMob %u %d %d", vnum, x, y);
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + x * 100, pkSectreeMap->m_setting.iBaseY + y * 100, 0, false, dir == 0 ? -1 : (dir - 1) * 45);
+
+	if (ch)
+	{
+		ch->SetDungeon(this);
+		sys_log(0, "CDungeon::SpawnMob name %s", ch->GetName());
+	}
+
+	return ch;
+}
+
+LPCHARACTER CDungeon::SpawnMob_ac_dir(DWORD vnum, int x, int y, int dir)
+{
+	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (pkSectreeMap == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return NULL;
+	}
+	sys_log(0, "CDungeon::SpawnMob %u %d %d", vnum, x, y);
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + x * 100, pkSectreeMap->m_setting.iBaseY + y * 100, 0, false, dir);
+
+	if (ch)
+	{
+		ch->SetDungeon(this);
+		sys_log(0, "CDungeon::SpawnMob name %s", ch->GetName());
+	}
+
+	return ch;
+}
+
+void CDungeon::SpawnNameMob(DWORD vnum, int x, int y, const char* name)
+{
+	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (pkSectreeMap == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return;
+	}
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + x, pkSectreeMap->m_setting.iBaseY + y, 0, false, -1);
+	if (ch)
+	{
+		ch->SetName(name);
+		ch->SetDungeon(this);
+	}
+}
+
+void CDungeon::SpawnGotoMob(long lFromX, long lFromY, long lToX, long lToY)
+{
+	const int MOB_GOTO_VNUM = 20039;
+
+	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (pkSectreeMap == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return;
+	}
+
+	sys_log(0, "SpawnGotoMob %d %d to %d %d", lFromX, lFromY, lToX, lToY);
+
+	lFromX = pkSectreeMap->m_setting.iBaseX + lFromX * 100;
+	lFromY = pkSectreeMap->m_setting.iBaseY + lFromY * 100;
+
+	LPCHARACTER ch = CHARACTER_MANAGER::instance().SpawnMob(MOB_GOTO_VNUM, m_lMapIndex, lFromX, lFromY, 0, false, -1);
+
+	if (ch)
+	{
+		char buf[30 + 1];
+		snprintf(buf, sizeof(buf), ". %ld %ld", lToX, lToY);
+
+		ch->SetName(buf);
+		ch->SetDungeon(this);
+	}
+}
+
+LPCHARACTER CDungeon::SpawnGroup(DWORD vnum, long x, long y, float radius, bool bAggressive, int count)
+{
+	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (pkSectreeMap == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return NULL;
+	}
+
+	int iRadius = (int)radius;
+
+	int sx = pkSectreeMap->m_setting.iBaseX + x - iRadius;
+	int sy = pkSectreeMap->m_setting.iBaseY + y - iRadius;
+	int ex = sx + iRadius;
+	int ey = sy + iRadius;
+
+	LPCHARACTER ch = NULL;
+
+	while (count--)
+	{
+		LPCHARACTER chLeader = CHARACTER_MANAGER::instance().SpawnGroup(vnum, m_lMapIndex, sx, sy, ex, ey, NULL, bAggressive, this);
+		if (chLeader && !ch)
+			ch = chLeader;
+	}
+
+	return ch;
+}
+
+void CDungeon::SpawnRegen(const char* filename, bool bOnce)
+{
+	if (!filename)
+	{
+		sys_err("CDungeon::SpawnRegen(filename=NULL, bOnce=%d) - m_lMapIndex[%d]", bOnce, m_lMapIndex);
+		return;
+	}
+
+	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (!pkSectreeMap)
+	{
+		sys_err("CDungeon::SpawnRegen(filename=%s, bOnce=%d) - m_lMapIndex[%d]", filename, bOnce, m_lMapIndex);
+		return;
+	}
+
+	regen_do(filename, m_lMapIndex, pkSectreeMap->m_setting.iBaseX, pkSectreeMap->m_setting.iBaseY, this, bOnce);
+}
+
+void CDungeon::AddRegen(LPREGEN regen)
+{
+	regen->id = regen_id_++;
+	m_regen.push_back(regen);
+}
+
+void CDungeon::ClearRegen()
+{
+	for (auto it = m_regen.begin(); it != m_regen.end(); ++it)
+	{
+		LPREGEN regen = *it;
+
+		event_cancel(&regen->event);
+		M2_DELETE(regen);
+	}
+	m_regen.clear();
+}
+
+bool CDungeon::IsValidRegen(LPREGEN regen, size_t regen_id)
+{
+	auto it = std::find(m_regen.begin(), m_regen.end(), regen);
+	if (it == m_regen.end())
+		return false;
+	LPREGEN found = *it;
+	return (found->id == regen_id);
+}
+
+void CDungeon::SpawnMoveGroup(DWORD vnum, const char* pos_from, const char* pos_to, int count)
+{
+	TAreaMap::iterator it_to = m_map_Area.find(pos_to);
+
+	if (it_to == m_map_Area.end())
+	{
+		sys_err("Wrong position string : %s", pos_to);
+		return;
+	}
+
+	TAreaMap::iterator it_from = m_map_Area.find(pos_from);
+
+	if (it_from == m_map_Area.end())
+	{
+		sys_err("Wrong position string : %s", pos_from);
+		return;
+	}
+
+	TAreaInfo& ai = it_from->second;
+	TAreaInfo& ai_to = it_to->second;
+	int dir = ai.dir;
+
+	if (dir == -1)
+		dir = number(0, 359);
+
+	LPSECTREE_MAP pkSectreeMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (pkSectreeMap == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return;
+	}
+
+	while (count--)
+	{
+		int tx = number(ai_to.sx, ai_to.ex) + pkSectreeMap->m_setting.iBaseX;
+		int ty = number(ai_to.sy, ai_to.ey) + pkSectreeMap->m_setting.iBaseY;
+		CHARACTER_MANAGER::instance().SpawnMoveGroup(vnum, m_lMapIndex, pkSectreeMap->m_setting.iBaseX + ai.sx, pkSectreeMap->m_setting.iBaseY + ai.sy, pkSectreeMap->m_setting.iBaseX + ai.ex, pkSectreeMap->m_setting.iBaseY + ai.ey, tx, ty, NULL, true);
+	}
+}
+
+namespace
+{
+	// DUNGEON_KILL_ALL_BUG_FIX
+	struct FKillSectree
+	{
+		void operator () (LPENTITY ent)
+		{
+			if (ent->IsType(ENTITY_CHARACTER))
+			{
+				LPCHARACTER ch = (LPCHARACTER)ent;
+
+				if (!ch->IsPC()
+#if defined(__PET_SYSTEM__)
+					&& !ch->IsPet()
+#endif
+					)
+					ch->Dead();
+			}
+		}
+	};
+	// END_OF_DUNGEON_KILL_ALL_BUG_FIX
+
+	struct FPurgeSectree
+	{
+		void operator () (LPENTITY ent)
+		{
+			if (ent->IsType(ENTITY_CHARACTER))
+			{
+				LPCHARACTER ch = (LPCHARACTER)ent;
+
+				if (!ch->IsPC()
+#if defined(__PET_SYSTEM__)
+					&& !ch->IsPet()
+#endif
+					)
+				{
+					M2_DESTROY_CHARACTER(ch);
+				}
+			}
+			else if (ent->IsType(ENTITY_ITEM))
+			{
+				LPITEM item = (LPITEM)ent;
+				M2_DESTROY_ITEM(item);
+			}
+			else
+				sys_err("unknown entity type %d is in dungeon", ent->GetType());
+		}
+	};
+}
+
+// DUNGEON_KILL_ALL_BUG_FIX
+void CDungeon::KillAll()
+{
+	LPSECTREE_MAP pkMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (pkMap == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return;
+	}
+	FKillSectree f;
+	pkMap->for_each(f);
+}
+// END_OF_DUNGEON_KILL_ALL_BUG_FIX
+
+void CDungeon::Purge()
+{
+	LPSECTREE_MAP pkMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+	if (pkMap == NULL)
+	{
+		sys_err("CDungeon: SECTREE_MAP not found for #%ld", m_lMapIndex);
+		return;
+	}
+	FPurgeSectree f;
+	pkMap->for_each(f);
+}
+
+void CDungeon::IncKillCount(LPCHARACTER pkKiller, LPCHARACTER pkVictim)
+{
+	if (pkVictim->IsStone())
+		m_iStoneKill++;
+	else
+		m_iMobKill++;
+}
+
+void CDungeon::UsePotion(LPCHARACTER ch)
+{
+	m_bUsePotion = true;
+}
+
+void CDungeon::UseRevive(LPCHARACTER ch)
+{
+	m_bUseRevive = true;
+}
+
+bool CDungeon::IsUsePotion()
+{
+	return m_bUsePotion;
+}
+
+bool CDungeon::IsUseRevive()
+{
+	return m_bUseRevive;
+}
+
+int CDungeon::GetKillMobCount()
+{
+	return m_iMobKill;
+}
+int CDungeon::GetKillStoneCount()
+{
+	return m_iStoneKill;
+}
+
+struct FCountMonster
+{
+	int n;
+	FCountMonster() : n(0) {};
+	void operator()(LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+			if (ch->IsMonster() || ch->IsStone())
+				n++;
+		}
+	}
+};
+
+int CDungeon::CountRealMonster()
+{
+	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lOrigMapIndex);
+
+	if (!pMap)
+	{
+		sys_err("cannot find map by index %d", m_lOrigMapIndex);
+		return 0;
+	}
+
+	FCountMonster f;
+
+	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
+	pMap->for_each(f);
+	return f.n;
+}
+
+struct FExitDungeon
+{
+	void operator()(LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+
+			if (ch->IsPC())
+				ch->ExitToSavedLocation();
+		}
+	}
+};
+
+void CDungeon::ExitAll()
+{
+	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+
+	if (!pMap)
+	{
+		sys_err("cannot find map by index %d", m_lMapIndex);
+		return;
+	}
+
+	FExitDungeon f;
+
+	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
+	pMap->for_each(f);
+}
+
+// DUNGEON_NOTICE
+namespace
+{
+	struct FNotice
+	{
+		FNotice(const char* psz) : m_psz(psz) {}
+		void operator() (LPENTITY ent)
+		{
+			if (ent->IsType(ENTITY_CHARACTER))
+			{
+				LPCHARACTER ch = (LPCHARACTER)ent;
+				if (ch->IsPC())
+				{
+					ch->ChatPacket(CHAT_TYPE_NOTICE, "%s", m_psz);
+				}
+			}
+		}
+		const char* m_psz;
+	};
+
+	struct FMissionMessage
+	{
+		FMissionMessage(const char* psz) : m_psz(psz) {}
+		void operator() (LPENTITY ent)
+		{
+			if (ent->IsType(ENTITY_CHARACTER))
+			{
+				LPCHARACTER ch = (LPCHARACTER)ent;
+				if (ch->IsPC())
+				{
+					ch->ChatPacket(CHAT_TYPE_MISSION, "%s", m_psz);
+				}
+			}
+		}
+		const char* m_psz;
+	};
+
+	struct FSubMissionMessage
+	{
+		FSubMissionMessage(const char* psz) : m_psz(psz) {}
+		void operator() (LPENTITY ent)
+		{
+			if (ent->IsType(ENTITY_CHARACTER))
+			{
+				LPCHARACTER ch = (LPCHARACTER)ent;
+				if (ch->IsPC())
+				{
+					ch->ChatPacket(CHAT_TYPE_SUB_MISSION, "%s", m_psz);
+				}
+			}
+		}
+		const char* m_psz;
+	};
+}
+
+void CDungeon::Notice(const char* msg)
+{
+	sys_log(0, "XXX Dungeon Notice %p %s", this, msg);
+	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+
+	if (!pMap)
+	{
+		sys_err("cannot find map by index %d", m_lMapIndex);
+		return;
+	}
+
+	FNotice f(msg);
+	pMap->for_each(f);
+}
+
+void CDungeon::MissionMessage(const char* msg)
+{
+	sys_log(0, "XXX Dungeon Mission Message %p %s", this, msg);
+	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+
+	if (!pMap)
+	{
+		sys_err("cannot find map by index %d", m_lMapIndex);
+		return;
+	}
+
+	FMissionMessage f(msg);
+	pMap->for_each(f);
+}
+
+void CDungeon::SubMissionMessage(const char* msg)
+{
+	sys_log(0, "XXX Dungeon SubMission Message %p %s", this, msg);
+	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+
+	if (!pMap)
+	{
+		sys_err("cannot find map by index %d", m_lMapIndex);
+		return;
+	}
+
+	FSubMissionMessage f(msg);
+	pMap->for_each(f);
+}
+// END_OF_DUNGEON_NOTICE
+
+struct FExitDungeonToStartPosition
+{
+	void operator () (LPENTITY ent)
+	{
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+
+			if (ch->IsPC())
+			{
+				PIXEL_POSITION posWarp;
+
+				//   Îµ Ö´  Æ´Ï¶ Ï´  Îµ Ö´Â´.
+				if (SECTREE_MANAGER::instance().GetRecallPositionByEmpire(g_start_map[ch->GetEmpire()], ch->GetEmpire(), posWarp))
+					ch->WarpSet(posWarp.x, posWarp.y);
+				else
+					ch->ExitToSavedLocation();
+			}
+		}
+	}
+};
+
+void CDungeon::ExitAllToStartPosition()
+{
+	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+
+	if (!pMap)
+	{
+		sys_err("cannot find map by index %d", m_lMapIndex);
+		return;
+	}
+
+	FExitDungeonToStartPosition f;
+
+	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
+	pMap->for_each(f);
+}
+
+EVENTFUNC(dungeon_jump_to_event)
+{
+	dungeon_id_info* info = dynamic_cast<dungeon_id_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("dungeon_jump_to_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPDUNGEON pDungeon = CDungeonManager::instance().Find(info->dungeon_id);
+	if (pDungeon)
+	{
+		pDungeon->jump_to_event_ = NULL;
+		pDungeon->JumpToEliminateLocation();
+	}
+	else
+		sys_err("cannot find dungeon with map index %u", info->dungeon_id);
+
+	return 0;
+}
+
+EVENTFUNC(dungeon_exit_all_event)
+{
+	dungeon_id_info* info = dynamic_cast<dungeon_id_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("dungeon_exit_all_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	LPDUNGEON pDungeon = CDungeonManager::instance().Find(info->dungeon_id);
+	pDungeon->exit_all_event_ = NULL;
+
+	if (pDungeon)
+		pDungeon->ExitAll();
+
+	return 0;
+}
+
+void CDungeon::CheckEliminated()
+{
+	if (m_iMonsterCount > 0)
+		return;
+
+	if (m_bExitAllAtEliminate)
+	{
+		sys_log(0, "CheckEliminated: exit");
+		m_bExitAllAtEliminate = false;
+
+		if (m_iWarpDelay)
+		{
+			dungeon_id_info* info = AllocEventInfo<dungeon_id_info>();
+			info->dungeon_id = m_id;
+
+			event_cancel(&exit_all_event_);
+			exit_all_event_ = event_create(dungeon_exit_all_event, info, PASSES_PER_SEC(m_iWarpDelay));
+		}
+		else
+		{
+			ExitAll();
+		}
+	}
+	else if (m_bWarpAtEliminate)
+	{
+		sys_log(0, "CheckEliminated: warp");
+		m_bWarpAtEliminate = false;
+
+		if (m_iWarpDelay)
+		{
+			dungeon_id_info* info = AllocEventInfo<dungeon_id_info>();
+			info->dungeon_id = m_id;
+
+			event_cancel(&jump_to_event_);
+			jump_to_event_ = event_create(dungeon_jump_to_event, info, PASSES_PER_SEC(m_iWarpDelay));
+		}
+		else
+		{
+			JumpToEliminateLocation();
+		}
+	}
+#ifdef _EXE_
+	else if (m_bCheckEliminate)
+	{
+		sys_log(0, "CheckEliminated: check");
+		m_bCheckEliminate = false;
+
+		CheckEliminateLocation();
+	}
+#endif
+	else
+		sys_log(0, "CheckEliminated: none");
+}
+
+void CDungeon::SetExitAllAtEliminate(long time)
+{
+	sys_log(0, "SetExitAllAtEliminate: time %d", time);
+	m_bExitAllAtEliminate = true;
+	m_iWarpDelay = time;
+}
+
+void CDungeon::SetWarpAtEliminate(long time, long lMapIndex, int x, int y, const char* regen_file)
+{
+	m_bWarpAtEliminate = true;
+	m_iWarpDelay = time;
+	m_lWarpMapIndex = lMapIndex;
+	m_lWarpX = x;
+	m_lWarpY = y;
+
+	if (!regen_file || !*regen_file)
+		m_stRegenFile.clear();
+	else
+		m_stRegenFile = regen_file;
+
+	sys_log(0, "SetWarpAtEliminate: time %d map %d %dx%d regenfile %s", time, lMapIndex, x, y, m_stRegenFile.c_str());
+}
+
+void CDungeon::JumpToEliminateLocation()
+{
+	LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(m_lWarpMapIndex);
+
+	if (pDungeon)
+	{
+		pDungeon->JumpAll(m_lMapIndex, m_lWarpX, m_lWarpY);
+
+		if (!m_stRegenFile.empty())
+		{
+			pDungeon->SpawnRegen(m_stRegenFile.c_str());
+			m_stRegenFile.clear();
+		}
+	}
+	else
+	{
+		// Ï¹  
+		LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+
+		if (!pMap)
+		{
+			sys_err("no map by index %d", m_lMapIndex);
+			return;
+		}
+
+		FWarpToPosition f(m_lWarpMapIndex, m_lWarpX * 100, m_lWarpY * 100);
+
+		// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
+		pMap->for_each(f);
+	}
+}
+
+#ifdef _EXE_
+void CDungeon::SetEliminate(long lMapIndex, const char* regen_file)
+{
+	m_bCheckEliminate = true;
+	m_lWarpMapIndex = lMapIndex;
+
+	if (!regen_file || !*regen_file)
+		m_stRegenFile.clear();
+	else
+		m_stRegenFile = regen_file;
+
+	sys_log(0, "SetEliminate: regenfile %s", m_stRegenFile.c_str());
+}
+
+bool CDungeon::CheckAllEliminated()
+{
+	if (m_iMonsterCount > 0)
+		return false;
+
+	if (m_bCheckEliminate)
+		return true;
+
+	return false;
+}
+
+void CDungeon::CheckEliminateLocation()
+{
+	LPDUNGEON pDungeon = CDungeonManager::instance().FindByMapIndex(m_lWarpMapIndex);
+
+	if (pDungeon)
+	{
+		if (!m_stRegenFile.empty())
+		{
+			pDungeon->SpawnRegen(m_stRegenFile.c_str());
+			m_stRegenFile.clear();
+		}
+	}
+}
+#endif
+
+struct FNearPosition
+{
+	long x;
+	long y;
+	int dist;
+	bool ret;
+
+	FNearPosition(long x, long y, int d) :
+		x(x), y(y), dist(d), ret(true)
+	{
+	}
+
+	void operator()(LPENTITY ent)
+	{
+		if (ret == false)
+			return;
+
+		if (ent->IsType(ENTITY_CHARACTER))
+		{
+			LPCHARACTER ch = (LPCHARACTER)ent;
+
+			if (ch->IsPC())
+			{
+				if (DISTANCE_APPROX(ch->GetX() - x * 100, ch->GetY() - y * 100) > dist * 100)
+					ret = false;
+			}
+		}
+	}
+};
+
+bool CDungeon::IsAllPCNearTo(int x, int y, int dist)
+{
+	LPSECTREE_MAP pMap = SECTREE_MANAGER::instance().GetMap(m_lMapIndex);
+
+	if (!pMap)
+	{
+		sys_err("cannot find map by index %d", m_lMapIndex);
+		return false;
+	}
+
+	FNearPosition f(x, y, dist);
+
+	// <Factor> SECTREE::for_each -> SECTREE::for_each_entity
+	pMap->for_each(f);
+
+	return f.ret;
+}
+
+void CDungeon::CreateItemGroup(std::string& group_name, ItemGroup& item_group)
+{
+	m_map_ItemGroup.insert(ItemGroupMap::value_type(group_name, item_group));
+}
+
+const CDungeon::ItemGroup* CDungeon::GetItemGroup(std::string& group_name)
+{
+	ItemGroupMap::iterator it = m_map_ItemGroup.find(group_name);
+	if (it != m_map_ItemGroup.end())
+		return &(it->second);
+	else
+		return NULL;
+}
diff --git a/server/metin2/Source/Server/game/src/party.cpp b/server/metin2/Source/Server/game/src/party.cpp
index 8d82d26..8862ac6 100644
--- a/server/metin2/Source/Server/game/src/party.cpp
+++ b/server/metin2/Source/Server/game/src/party.cpp
@@ -1,2126 +1,2132 @@
-#include "stdafx.h"
-#include "utils.h"
-#include "char.h"
-#include "party.h"
-#include "char_manager.h"
-#include "config.h"
-#include "p2p.h"
-#include "desc_client.h"
-#include "dungeon.h"
-#include "unique_item.h"
-#ifdef ENABLE_QUEEN_NETHIS
-#include "SnakeLair.h"
-#endif
-#include "buffer_manager.h"
-
-#if defined(__PARTY_PROFICY__) || defined(__PARTY_INSIGHT__)
-#	include "skill.h"
-#endif
-
-#if defined(__PARTY_KILL_RENEWAL__)
-#include "utils.h"
-#include "questmanager.h"
-
-void FPartyKill::operator()(LPCHARACTER pMember)
-{
-	if (m_pAttacker == NULL || m_pVictim == NULL)
-		return;
-
-	if (m_pAttacker == pMember)
-		return;
-
-	if (DISTANCE_APPROX(m_pAttacker->GetX() - pMember->GetX(),
-		m_pAttacker->GetY() - pMember->GetY()) > PARTY_DEFAULT_RANGE)
-		return;
-
-	pMember->SetQuestNPCID(m_pVictim->GetVID());
-	quest::CQuestManager::Instance().PartyKill(pMember->GetPlayerID(), m_pVictim->GetRaceNum());
-}
-#endif
-
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-EVENTINFO(party_position_event_info)
-{
-	LPPARTY pParty;
-	party_position_event_info() :
-		pParty(NULL)
-	{}
-};
-
-EVENTFUNC(party_position_event)
-{
-	const party_position_event_info* info = dynamic_cast<party_position_event_info*>(event->info);
-
-	if (info == NULL || info->pParty == NULL)
-	{
-		sys_err("party_position_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	info->pParty->UpdatePosition();
-	return PASSES_PER_SEC(3);
-}
-#endif
-
-CPartyManager::CPartyManager()
-{
-	Initialize();
-}
-
-CPartyManager::~CPartyManager()
-{
-}
-
-void CPartyManager::Initialize()
-{
-	m_bEnablePCParty = false;
-}
-
-void CPartyManager::DeleteAllParty()
-{
-	TPCPartySet::iterator it = m_set_pkPCParty.begin();
-
-	while (it != m_set_pkPCParty.end())
-	{
-		DeleteParty(*it);
-		it = m_set_pkPCParty.begin();
-	}
-}
-
-bool CPartyManager::SetParty(LPCHARACTER ch) // PC¸¸ »ç¿ëÇØ¾ß ÇÑ´Ù!!
-{
-	TPartyMap::iterator it = m_map_pkParty.find(ch->GetPlayerID());
-
-	if (it == m_map_pkParty.end())
-		return false;
-
-	LPPARTY pParty = it->second;
-	if (!pParty)
-		return false;
-
-	pParty->Link(ch);
-	return true;
-}
-
-void CPartyManager::P2PLogin(DWORD pid, const char* name
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	, long mapIdx
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-	, BYTE channel
-#endif
-)
-{
-	TPartyMap::iterator it = m_map_pkParty.find(pid);
-	if (it == m_map_pkParty.end())
-		return;
-
-	it->second->UpdateOnlineState(pid, name
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-		, mapIdx
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-		, channel
-#endif
-	);
-}
-
-void CPartyManager::P2PLogout(DWORD pid)
-{
-	TPartyMap::iterator it = m_map_pkParty.find(pid);
-
-	if (it == m_map_pkParty.end())
-		return;
-
-	it->second->UpdateOfflineState(pid);
-}
-
-void CPartyManager::P2PJoinParty(DWORD leader, DWORD pid, BYTE role)
-{
-	TPartyMap::iterator it = m_map_pkParty.find(leader);
-
-	if (it != m_map_pkParty.end())
-	{
-		it->second->P2PJoin(pid);
-
-		if (role >= PARTY_ROLE_MAX_NUM)
-			role = PARTY_ROLE_NORMAL;
-
-		it->second->SetRole(pid, role, true);
-	}
-	else
-	{
-		sys_err("No such party with leader [%d]", leader);
-	}
-}
-
-void CPartyManager::P2PQuitParty(DWORD pid)
-{
-	TPartyMap::iterator it = m_map_pkParty.find(pid);
-
-	if (it != m_map_pkParty.end())
-	{
-		it->second->P2PQuit(pid);
-	}
-	else
-	{
-		sys_err("No such party with member [%d]", pid);
-	}
-}
-
-LPPARTY CPartyManager::P2PCreateParty(DWORD pid)
-{
-	TPartyMap::iterator it = m_map_pkParty.find(pid);
-	if (it != m_map_pkParty.end())
-		return it->second;
-
-	LPPARTY pParty = M2_NEW CParty;
-
-	m_set_pkPCParty.insert(pParty);
-
-	SetPartyMember(pid, pParty);
-	pParty->SetPCParty(true);
-	pParty->P2PJoin(pid);
-
-	return pParty;
-}
-
-void CPartyManager::P2PDeleteParty(DWORD pid)
-{
-	TPartyMap::iterator it = m_map_pkParty.find(pid);
-
-	if (it != m_map_pkParty.end())
-	{
-		m_set_pkPCParty.erase(it->second);
-		M2_DELETE(it->second);
-	}
-	else
-		sys_err("PARTY P2PDeleteParty Cannot find party [%u]", pid);
-}
-
-LPPARTY CPartyManager::FindParty(DWORD dwPID)
-{
-	TPartyMap::iterator it = m_map_pkParty.find(dwPID);
-	if (it == m_map_pkParty.end())
-	{
-		return NULL;
-	}
-	return it->second;
-}
-
-LPPARTY CPartyManager::CreateParty(LPCHARACTER pLeader)
-{
-	if (pLeader->GetParty())
-		return pLeader->GetParty();
-
-	LPPARTY pParty = M2_NEW CParty;
-
-	if (pLeader->IsPC())
-	{
-		//TPacketGGParty p;
-		//p.header = HEADER_GG_PARTY;
-		//p.subheader = PARTY_SUBHEADER_GG_CREATE;
-		//p.pid = pLeader->GetPlayerID();
-		//P2P_MANAGER::instance().Send(&p, sizeof(p));
-		TPacketPartyCreate p;
-		p.dwLeaderPID = pLeader->GetPlayerID();
-
-		db_clientdesc->DBPacket(HEADER_GD_PARTY_CREATE, 0, &p, sizeof(TPacketPartyCreate));
-
-		sys_log(0, "PARTY: Create %s pid %u", pLeader->GetName(), pLeader->GetPlayerID());
-		pParty->SetPCParty(true);
-		pParty->Join(pLeader->GetPlayerID());
-
-		m_set_pkPCParty.insert(pParty);
-	}
-	else
-	{
-		pParty->SetPCParty(false);
-		pParty->Join(pLeader->GetVID());
-	}
-
-	pParty->Link(pLeader);
-	return (pParty);
-}
-
-void CPartyManager::DeleteParty(LPPARTY pParty)
-{
-	//TPacketGGParty p;
-	//p.header = HEADER_GG_PARTY;
-	//p.subheader = PARTY_SUBHEADER_GG_DESTROY;
-	//p.pid = pParty->GetLeaderPID();
-	//P2P_MANAGER::instance().Send(&p, sizeof(p));
-	TPacketPartyDelete p;
-	p.dwLeaderPID = pParty->GetLeaderPID();
-
-	db_clientdesc->DBPacket(HEADER_GD_PARTY_DELETE, 0, &p, sizeof(TPacketPartyDelete));
-
-	m_set_pkPCParty.erase(pParty);
-	M2_DELETE(pParty);
-}
-
-void CPartyManager::SetPartyMember(DWORD dwPID, LPPARTY pParty)
-{
-	TPartyMap::iterator it = m_map_pkParty.find(dwPID);
-
-	if (pParty == NULL)
-	{
-		if (it != m_map_pkParty.end())
-			m_map_pkParty.erase(it);
-	}
-	else
-	{
-		if (it != m_map_pkParty.end())
-		{
-			if (it->second != pParty)
-			{
-				it->second->Quit(dwPID);
-				it->second = pParty;
-			}
-		}
-		else
-			m_map_pkParty.insert(TPartyMap::value_type(dwPID, pParty));
-	}
-}
-
-EVENTINFO(party_update_event_info)
-{
-	DWORD pid;
-
-	party_update_event_info()
-		: pid(0)
-	{
-	}
-};
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// CParty begin!
-//
-/////////////////////////////////////////////////////////////////////////////
-EVENTFUNC(party_update_event)
-{
-	party_update_event_info* info = dynamic_cast<party_update_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("party_update_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	DWORD pid = info->pid;
-	LPCHARACTER leader = CHARACTER_MANAGER::instance().FindByPID(pid);
-
-	if (leader && leader->GetDesc())
-	{
-		LPPARTY pParty = leader->GetParty();
-
-		if (pParty)
-			pParty->Update();
-	}
-
-	return PASSES_PER_SEC(3);
-}
-
-CParty::CParty()
-{
-	Initialize();
-}
-
-CParty::~CParty()
-{
-	Destroy();
-}
-
-void CParty::Initialize()
-{
-	sys_log(2, "Party::Initialize");
-
-	m_iExpDistributionMode = PARTY_EXP_DISTRIBUTION_NON_PARITY;
-	m_pkChrExpCentralize = NULL;
-
-	m_dwLeaderPID = 0;
-
-	m_eventUpdate = NULL;
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	m_eventUpdatePosition = NULL;
-#endif
-
-	memset(&m_anRoleCount, 0, sizeof(m_anRoleCount));
-	memset(&m_anMaxRole, 0, sizeof(m_anMaxRole));
-	m_anMaxRole[PARTY_ROLE_LEADER] = 1;
-	m_anMaxRole[PARTY_ROLE_NORMAL] = 32;
-
-	m_dwPartyStartTime = get_dword_time();
-	m_iLongTimeExpBonus = 0;
-
-	m_dwPartyHealTime = get_dword_time();
-	m_bPartyHealReady = false;
-	m_bCanUsePartyHeal = false;
-
-	m_iLeadership = 0;
-	m_iExpBonus = 0;
-	m_iAttBonus = 0;
-	m_iDefBonus = 0;
-
-	m_itNextOwner = m_memberMap.begin();
-
-	m_iCountNearPartyMember = 0;
-
-	m_pkChrLeader = NULL;
-	m_bPCParty = false;
-	m_pkDungeon = NULL;
-	m_pkDungeon_for_Only_party = NULL;
-}
-
-void CParty::Destroy()
-{
-	sys_log(2, "Party::Destroy");
-
-	// PC°¡ ¸¸µç ÆÄÆ¼¸é ÆÄÆ¼¸Å´ÏÀú¿¡ ¸Ê¿¡¼­ PID¸¦ »èÁ¦ÇØ¾ß ÇÑ´Ù.
-	if (m_bPCParty)
-	{
-		for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-			CPartyManager::instance().SetPartyMember(it->first, NULL);
-	}
-
-	if (m_eventUpdate)
-		event_cancel(&m_eventUpdate);
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	if (m_eventUpdatePosition)
-		event_cancel(&m_eventUpdatePosition);
-#endif
-
-	RemoveBonus();
-
-	TMemberMap::iterator it = m_memberMap.begin();
-
-	DWORD dwTime = get_dword_time();
-
-	while (it != m_memberMap.end())
-	{
-		TMember& rMember = it->second;
-		++it;
-
-		if (rMember.pCharacter)
-		{
-			if (rMember.pCharacter->GetDesc())
-			{
-				TPacketGCPartyRemove p;
-				p.header = HEADER_GC_PARTY_REMOVE;
-				p.pid = rMember.pCharacter->GetPlayerID();
-				rMember.pCharacter->GetDesc()->Packet(&p, sizeof(p));
-				rMember.pCharacter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼°¡ ÇØ»ê µÇ¾ú½À´Ï´Ù."));
-#ifdef ENABLE_QUEEN_NETHIS
-				if (SnakeLair::CSnk::instance().IsSnakeMap(rMember.pCharacter->GetMapIndex()))
-				{
-					SnakeLair::CSnk::instance().LeaveParty(rMember.pCharacter->GetMapIndex());
-					SnakeLair::CSnk::instance().Leave(rMember.pCharacter);
-				}
-#endif
-			}
-			else
-			{
-				// NPCÀÏ °æ¿ì ÀÏÁ¤ ½Ã°£ ÈÄ ÀüÅõ ÁßÀÌ ¾Æ´Ò ¶§ »ç¶óÁö°Ô ÇÏ´Â ÀÌº¥Æ®¸¦ ½ÃÀÛ½ÃÅ²´Ù.
-				rMember.pCharacter->SetLastAttacked(dwTime);
-				rMember.pCharacter->StartDestroyWhenIdleEvent();
-			}
-
-			rMember.pCharacter->SetParty(NULL);
-		}
-	}
-
-	m_memberMap.clear();
-	m_itNextOwner = m_memberMap.begin();
-
-	if (m_pkDungeon_for_Only_party != NULL)
-	{
-		m_pkDungeon_for_Only_party->SetPartyNull();
-		m_pkDungeon_for_Only_party = NULL;
-	}
-}
-
-void CParty::ChatPacketToAllMember(BYTE type, const char* format, ...)
-{
-	char chatbuf[CHAT_MAX_LEN + 1];
-	va_list args;
-
-	va_start(args, format);
-	vsnprintf(chatbuf, sizeof(chatbuf), format, args);
-	va_end(args);
-
-	TMemberMap::iterator it;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		TMember& rMember = it->second;
-
-		if (rMember.pCharacter)
-		{
-			if (rMember.pCharacter->GetDesc())
-			{
-				rMember.pCharacter->ChatPacket(type, "%s", chatbuf);
-			}
-		}
-	}
-}
-
-DWORD CParty::GetLeaderPID()
-{
-	return m_dwLeaderPID;
-}
-
-DWORD CParty::GetMemberCount()
-{
-	return m_memberMap.size();
-}
-
-void CParty::P2PJoin(DWORD dwPID)
-{
-	TMemberMap::iterator it = m_memberMap.find(dwPID);
-
-	if (it == m_memberMap.end())
-	{
-		TMember Member;
-
-		Member.pCharacter = NULL;
-		Member.bNear = false;
-
-		if (m_memberMap.empty())
-		{
-			Member.bRole = PARTY_ROLE_LEADER;
-			m_dwLeaderPID = dwPID;
-		}
-		else
-			Member.bRole = PARTY_ROLE_NORMAL;
-
-		if (m_bPCParty)
-		{
-			LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(dwPID);
-
-			if (ch)
-			{
-				sys_log(0, "PARTY: Join %s pid %u leader %u", ch->GetName(), dwPID, m_dwLeaderPID);
-				Member.strName = ch->GetName();
-
-				if (Member.bRole == PARTY_ROLE_LEADER)
-					m_iLeadership = ch->GetLeadershipSkillLevel();
-
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-				Member.lMapIndex = ch->GetMapIndex();
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-				Member.bChannel = g_bChannel;
-#endif
-			}
-			else
-			{
-				CCI* pcci = P2P_MANAGER::instance().FindByPID(dwPID);
-
-				if (!pcci);
-				else if (pcci->bChannel == g_bChannel)
-				{
-					Member.strName = pcci->szName;
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-					Member.lMapIndex = pcci->lMapIndex;
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-					Member.bChannel = pcci->bChannel;
-#endif
-				}
-				else
-					sys_err("member is not in same channel PID: %u channel %d, this channel %d", dwPID, pcci->bChannel, g_bChannel);
-			}
-		}
-
-		sys_log(2, "PARTY[%d] MemberCountChange %d -> %d", GetLeaderPID(), GetMemberCount(), GetMemberCount() + 1);
-
-		m_memberMap.insert(TMemberMap::value_type(dwPID, Member));
-
-		if (m_memberMap.size() == 1)
-			m_itNextOwner = m_memberMap.begin();
-
-		if (m_bPCParty)
-		{
-			CPartyManager::instance().SetPartyMember(dwPID, this);
-			SendPartyJoinOneToAll(dwPID);
-
-			LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(dwPID);
-
-			if (ch)
-				SendParameter(ch);
-		}
-	}
-
-	if (m_pkDungeon)
-		m_pkDungeon->QuitParty(this);
-}
-
-void CParty::Join(DWORD dwPID)
-{
-	P2PJoin(dwPID);
-
-	if (m_bPCParty)
-	{
-		TPacketPartyAdd p;
-		p.dwLeaderPID = GetLeaderPID();
-		p.dwPID = dwPID;
-		p.bState = PARTY_ROLE_NORMAL; // #0000790: [M2EU] CZ Å©·¡½¬ Áõ°¡: ÃÊ±âÈ­ Áß¿ä!
-		db_clientdesc->DBPacket(HEADER_GD_PARTY_ADD, 0, &p, sizeof(p));
-	}
-}
-
-void CParty::P2PQuit(DWORD dwPID)
-{
-	TMemberMap::iterator it = m_memberMap.find(dwPID);
-
-	if (it == m_memberMap.end())
-		return;
-
-	if (m_bPCParty)
-		SendPartyRemoveOneToAll(dwPID);
-
-	if (it == m_itNextOwner)
-		IncreaseOwnership();
-
-	if (m_bPCParty)
-		RemoveBonusForOne(dwPID);
-
-	LPCHARACTER ch = it->second.pCharacter;
-	BYTE bRole = it->second.bRole;
-
-	m_memberMap.erase(it);
-
-	sys_log(2, "PARTY[%d] MemberCountChange %d -> %d", GetLeaderPID(), GetMemberCount(), GetMemberCount() - 1);
-
-	if (bRole < PARTY_ROLE_MAX_NUM)
-	{
-		--m_anRoleCount[bRole];
-	}
-	else
-	{
-		sys_err("ROLE_COUNT_QUIT_ERROR: INDEX(%d) > MAX(%d)", bRole, PARTY_ROLE_MAX_NUM);
-	}
-
-	if (ch)
-	{
-		ch->SetParty(NULL);
-		ComputeRolePoint(ch, bRole, false);
-	}
-
-	if (m_bPCParty)
-		CPartyManager::instance().SetPartyMember(dwPID, NULL);
-
-	// ¸®´õ°¡ ³ª°¡¸é ÆÄÆ¼´Â ÇØ»êµÇ¾î¾ß ÇÑ´Ù.
-	if (bRole == PARTY_ROLE_LEADER)
-		CPartyManager::instance().DeleteParty(this);
-
-	// ÀÌ ¾Æ·¡´Â ÄÚµå¸¦ Ãß°¡ÇÏÁö ¸» °Í!!! À§ DeleteParty ÇÏ¸é this´Â ¾ø´Ù.
-}
-
-void CParty::Quit(DWORD dwPID)
-{
-	// Always PC
-	P2PQuit(dwPID);
-
-	if (m_bPCParty && dwPID != GetLeaderPID())
-	{
-		//TPacketGGParty p;
-		//p.header = HEADER_GG_PARTY;
-		//p.subheader = PARTY_SUBHEADER_GG_QUIT;
-		//p.pid = dwPID;
-		//p.leaderpid = GetLeaderPID();
-		//P2P_MANAGER::instance().Send(&p, sizeof(p));
-		TPacketPartyRemove p;
-		p.dwPID = dwPID;
-		p.dwLeaderPID = GetLeaderPID();
-		db_clientdesc->DBPacket(HEADER_GD_PARTY_REMOVE, 0, &p, sizeof(p));
-	}
-}
-
-void CParty::Link(LPCHARACTER pkChr)
-{
-	TMemberMap::iterator it;
-
-	if (pkChr->IsPC())
-		it = m_memberMap.find(pkChr->GetPlayerID());
-	else
-		it = m_memberMap.find(pkChr->GetVID());
-
-	if (it == m_memberMap.end())
-	{
-		sys_err("%s is not member of this party", pkChr->GetName());
-		return;
-	}
-
-	// ÇÃ·¹ÀÌ¾î ÆÄÆ¼ÀÏ °æ¿ì ¾÷µ¥ÀÌÆ® ÀÌº¥Æ® »ý¼º
-	if (m_bPCParty && !m_eventUpdate)
-	{
-		party_update_event_info* info = AllocEventInfo<party_update_event_info>();
-		info->pid = m_dwLeaderPID;
-		m_eventUpdate = event_create(party_update_event, info, PASSES_PER_SEC(3));
-	}
-
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	if (m_bPCParty && !m_eventUpdatePosition)
-	{
-		party_position_event_info* info = AllocEventInfo<party_position_event_info>();
-		info->pParty = this;
-		m_eventUpdatePosition = event_create(party_position_event, info, PASSES_PER_SEC(3));
-	}
-#endif
-
-	if (it->second.bRole == PARTY_ROLE_LEADER)
-		m_pkChrLeader = pkChr;
-
-	sys_log(2, "PARTY[%d] %s linked to party", GetLeaderPID(), pkChr->GetName());
-
-	it->second.pCharacter = pkChr;
-	pkChr->SetParty(this);
-
-	if (pkChr->IsPC())
-	{
-		if (it->second.strName.empty())
-		{
-			it->second.strName = pkChr->GetName();
-		}
-
-		SendPartyJoinOneToAll(pkChr->GetPlayerID());
-
-		SendPartyJoinAllToOne(pkChr);
-		SendPartyLinkOneToAll(pkChr);
-		SendPartyLinkAllToOne(pkChr);
-		SendPartyInfoAllToOne(pkChr);
-		SendPartyInfoOneToAll(pkChr);
-
-		SendParameter(pkChr);
-
-		//sys_log(0, "PARTY-DUNGEON connect %p %p", this, GetDungeon());
-		if (GetDungeon() && GetDungeon()->GetMapIndex() == pkChr->GetMapIndex())
-		{
-			pkChr->SetDungeon(GetDungeon());
-		}
-
-		RequestSetMemberLevel(pkChr->GetPlayerID(), pkChr->GetLevel());
-	}
-}
-
-void CParty::RequestSetMemberLevel(DWORD pid, BYTE level)
-{
-	TPacketPartySetMemberLevel p;
-	p.dwLeaderPID = GetLeaderPID();
-	p.dwPID = pid;
-	p.bLevel = level;
-	db_clientdesc->DBPacket(HEADER_GD_PARTY_SET_MEMBER_LEVEL, 0, &p, sizeof(TPacketPartySetMemberLevel));
-}
-
-void CParty::P2PSetMemberLevel(DWORD pid, BYTE level)
-{
-	if (!m_bPCParty)
-		return;
-
-	TMemberMap::iterator it;
-
-	sys_log(0, "PARTY P2PSetMemberLevel leader %d pid %d level %d", GetLeaderPID(), pid, level);
-
-	it = m_memberMap.find(pid);
-	if (it != m_memberMap.end())
-	{
-		it->second.bLevel = level;
-	}
-}
-
-namespace
-{
-	struct FExitDungeon
-	{
-		void operator()(LPCHARACTER ch)
-		{
-			ch->ExitToSavedLocation();
-		}
-	};
-}
-
-void CParty::Unlink(LPCHARACTER pkChr)
-{
-	TMemberMap::iterator it;
-
-	if (pkChr->IsPC())
-		it = m_memberMap.find(pkChr->GetPlayerID());
-	else
-		it = m_memberMap.find(pkChr->GetVID());
-
-	if (it == m_memberMap.end())
-	{
-		sys_err("%s is not member of this party", pkChr->GetName());
-		return;
-	}
-
-	if (pkChr->IsPC())
-	{
-		SendPartyUnlinkOneToAll(pkChr);
-		//SendPartyUnlinkAllToOne(pkChr); // ²÷±â´Â °ÍÀÌ¹Ç·Î ±¸Áö Unlink ÆÐÅ¶À» º¸³¾ ÇÊ¿ä ¾ø´Ù.
-
-		if (it->second.bRole == PARTY_ROLE_LEADER)
-		{
-			RemoveBonus();
-
-			if (it->second.pCharacter->GetDungeon())
-			{
-				// TODO: ´øÁ¯¿¡ ÀÖÀ¸¸é ³ª¸ÓÁöµµ ³ª°£´Ù
-				FExitDungeon f;
-				ForEachNearMember(f);
-			}
-		}
-	}
-
-	if (it->second.bRole == PARTY_ROLE_LEADER)
-		m_pkChrLeader = NULL;
-
-	it->second.pCharacter = NULL;
-	pkChr->SetParty(NULL);
-}
-
-void CParty::SendPartyRemoveOneToAll(DWORD pid)
-{
-	TMemberMap::iterator it;
-
-	TPacketGCPartyRemove p;
-	p.header = HEADER_GC_PARTY_REMOVE;
-	p.pid = pid;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
-			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
-	}
-}
-
-void CParty::SendPartyJoinOneToAll(DWORD pid)
-{
-	const TMember& r = m_memberMap[pid];
-
-	TPacketGCPartyAdd p;
-
-	p.header = HEADER_GC_PARTY_ADD;
-	p.pid = pid;
-	strlcpy(p.name, r.strName.c_str(), sizeof(p.name));
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	p.mapIdx = r.lMapIndex;
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-	p.channel = r.bChannel;
-#endif
-
-	for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
-			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
-	}
-}
-
-void CParty::SendPartyJoinAllToOne(LPCHARACTER ch)
-{
-	if (!ch->GetDesc())
-		return;
-
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__) && defined(__PARTY_CHANNEL_FIX__)
-	for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		const CCI* pCCI = P2P_MANAGER::Instance().Find(it->second.strName.c_str());
-		if (it->second.pCharacter || pCCI)
-			UpdateOnlineState(it->first, it->second.strName.c_str(), it->second.lMapIndex, it->second.bChannel);
-		else
-			UpdateOfflineState(it->first);
-	}
-#else
-	TPacketGCPartyAdd p;
-
-	p.header = HEADER_GC_PARTY_ADD;
-	p.name[CHARACTER_NAME_MAX_LEN] = '\0';
-
-	for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		p.pid = it->first;
-		strlcpy(p.name, it->second.strName.c_str(), sizeof(p.name));
-		ch->GetDesc()->Packet(&p, sizeof(p));
-	}
-#endif
-}
-
-void CParty::SendPartyUnlinkOneToAll(LPCHARACTER ch)
-{
-	if (!ch->GetDesc())
-		return;
-
-	TMemberMap::iterator it;
-
-	TPacketGCPartyLink p;
-	p.header = HEADER_GC_PARTY_UNLINK;
-	p.pid = ch->GetPlayerID();
-	p.vid = (DWORD)ch->GetVID();
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	p.mapIdx = 0;
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-	p.channel = 0;
-#endif
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
-			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
-	}
-}
-
-void CParty::SendPartyLinkOneToAll(LPCHARACTER ch)
-{
-	if (!ch->GetDesc())
-		return;
-
-	TMemberMap::iterator it;
-
-	TPacketGCPartyLink p;
-	p.header = HEADER_GC_PARTY_LINK;
-	p.vid = ch->GetVID();
-	p.pid = ch->GetPlayerID();
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	p.mapIdx = ch->GetMapIndex();
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-	p.channel = g_bChannel;
-#endif
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
-			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
-	}
-}
-
-void CParty::SendPartyLinkAllToOne(LPCHARACTER ch)
-{
-	if (!ch->GetDesc())
-		return;
-
-	TMemberMap::iterator it;
-
-	TPacketGCPartyLink p;
-	p.header = HEADER_GC_PARTY_LINK;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if (it->second.pCharacter)
-		{
-			p.vid = it->second.pCharacter->GetVID();
-			p.pid = it->second.pCharacter->GetPlayerID();
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-			p.mapIdx = it->second.pCharacter->GetMapIndex();
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-			p.channel = g_bChannel;
-#endif
-			ch->GetDesc()->Packet(&p, sizeof(p));
-		}
-	}
-}
-
-void CParty::SendPartyInfoOneToAll(DWORD pid)
-{
-	TMemberMap::iterator it = m_memberMap.find(pid);
-
-	if (it == m_memberMap.end())
-		return;
-
-	if (it->second.pCharacter)
-	{
-		SendPartyInfoOneToAll(it->second.pCharacter);
-		return;
-	}
-
-	// Data Building
-	TPacketGCPartyUpdate p;
-	memset(&p, 0, sizeof(p));
-	p.header = HEADER_GC_PARTY_UPDATE;
-	p.pid = pid;
-	p.percent_hp = 255;
-	p.role = it->second.bRole;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if ((it->second.pCharacter) && (it->second.pCharacter->GetDesc()))
-		{
-			//sys_log(2, "PARTY send info %s[%d] to %s[%d]", ch->GetName(), (DWORD)ch->GetVID(), it->second.pCharacter->GetName(), (DWORD)it->second.pCharacter->GetVID());
-			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
-		}
-	}
-}
-
-void CParty::SendPartyInfoOneToAll(LPCHARACTER ch)
-{
-	if (!ch->GetDesc())
-		return;
-
-	TMemberMap::iterator it;
-
-	// Data Building
-	TPacketGCPartyUpdate p;
-	ch->BuildUpdatePartyPacket(p);
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if ((it->second.pCharacter) && (it->second.pCharacter->GetDesc()))
-		{
-			sys_log(2, "PARTY send info %s[%d] to %s[%d]", ch->GetName(), (DWORD)ch->GetVID(), it->second.pCharacter->GetName(), (DWORD)it->second.pCharacter->GetVID());
-			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
-		}
-	}
-}
-
-void CParty::SendPartyInfoAllToOne(LPCHARACTER ch)
-{
-	TMemberMap::iterator it;
-
-	TPacketGCPartyUpdate p;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if (!it->second.pCharacter)
-		{
-			DWORD pid = it->first;
-			memset(&p, 0, sizeof(p));
-			p.header = HEADER_GC_PARTY_UPDATE;
-			p.pid = pid;
-			p.percent_hp = 255;
-			p.role = it->second.bRole;
-			ch->GetDesc()->Packet(&p, sizeof(p));
-			continue;
-		}
-
-		it->second.pCharacter->BuildUpdatePartyPacket(p);
-		sys_log(2, "PARTY send info %s[%d] to %s[%d]", it->second.pCharacter->GetName(), (DWORD)it->second.pCharacter->GetVID(), ch->GetName(), (DWORD)ch->GetVID());
-		ch->GetDesc()->Packet(&p, sizeof(p));
-	}
-}
-
-void CParty::SendMessage(LPCHARACTER ch, BYTE bMsg, DWORD dwArg1, DWORD dwArg2)
-{
-	if (ch->GetParty() != this)
-	{
-		sys_err("%s is not member of this party %p", ch->GetName(), this);
-		return;
-	}
-
-	switch (bMsg)
-	{
-		case PM_ATTACK:
-			break;
-
-		case PM_RETURN:
-		{
-			TMemberMap::iterator it = m_memberMap.begin();
-
-			while (it != m_memberMap.end())
-			{
-				TMember& rMember = it->second;
-				++it;
-
-				LPCHARACTER pkChr;
-
-				if ((pkChr = rMember.pCharacter) && ch != pkChr)
-				{
-					DWORD x = dwArg1 + number(-500, 500);
-					DWORD y = dwArg2 + number(-500, 500);
-
-					pkChr->SetVictim(NULL);
-					pkChr->SetRotationToXY(x, y);
-
-					if (pkChr->Goto(x, y))
-					{
-						LPCHARACTER victim = pkChr->GetVictim();
-						sys_log(0, "%s %p RETURN victim %p", pkChr->GetName(), get_pointer(pkChr), get_pointer(victim));
-						pkChr->SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
-					}
-				}
-			}
-		}
-		break;
-
-		case PM_ATTACKED_BY: // °ø°Ý ¹Þ¾ÒÀ½, ¸®´õ¿¡°Ô µµ¿òÀ» ¿äÃ»
-		{
-			// ¸®´õ°¡ ¾øÀ» ¶§
-			LPCHARACTER pkChrVictim = ch->GetVictim();
-
-			if (!pkChrVictim)
-				return;
-
-			TMemberMap::iterator it = m_memberMap.begin();
-
-			while (it != m_memberMap.end())
-			{
-				TMember& rMember = it->second;
-				++it;
-
-				LPCHARACTER pkChr;
-
-				if ((pkChr = rMember.pCharacter) && ch != pkChr)
-				{
-					if (pkChr->CanBeginFight())
-						pkChr->BeginFight(pkChrVictim);
-				}
-			}
-		}
-		break;
-
-		case PM_AGGRO_INCREASE:
-		{
-			LPCHARACTER victim = CHARACTER_MANAGER::instance().Find(dwArg2);
-
-			if (!victim)
-				return;
-
-			TMemberMap::iterator it = m_memberMap.begin();
-
-			while (it != m_memberMap.end())
-			{
-				TMember& rMember = it->second;
-				++it;
-
-				LPCHARACTER pkChr;
-
-				if ((pkChr = rMember.pCharacter) && ch != pkChr)
-				{
-					pkChr->UpdateAggrPoint(victim, DAMAGE_TYPE_SPECIAL, dwArg1);
-				}
-			}
-		}
-		break;
-	}
-}
-
-LPCHARACTER CParty::GetLeaderCharacter()
-{
-	return m_memberMap[GetLeaderPID()].pCharacter;
-}
-
-bool CParty::SetRole(DWORD dwPID, BYTE bRole, bool bSet)
-{
-	TMemberMap::iterator it = m_memberMap.find(dwPID);
-
-	if (it == m_memberMap.end())
-	{
-		return false;
-	}
-
-	LPCHARACTER ch = it->second.pCharacter;
-
-	if (bSet)
-	{
-		if (m_anRoleCount[bRole] >= m_anMaxRole[bRole])
-			return false;
-
-		if (it->second.bRole != PARTY_ROLE_NORMAL)
-			return false;
-
-		it->second.bRole = bRole;
-
-		if (ch && GetLeader())
-			ComputeRolePoint(ch, bRole, true);
-
-		if (bRole < PARTY_ROLE_MAX_NUM)
-		{
-			++m_anRoleCount[bRole];
-		}
-		else
-		{
-			sys_err("ROLE_COUNT_INC_ERROR: INDEX(%d) > MAX(%d)", bRole, PARTY_ROLE_MAX_NUM);
-		}
-	}
-	else
-	{
-		if (it->second.bRole == PARTY_ROLE_LEADER)
-			return false;
-
-		if (it->second.bRole == PARTY_ROLE_NORMAL)
-			return false;
-
-		it->second.bRole = PARTY_ROLE_NORMAL;
-
-		if (ch && GetLeader())
-			ComputeRolePoint(ch, PARTY_ROLE_NORMAL, false);
-
-		if (bRole < PARTY_ROLE_MAX_NUM)
-		{
-			--m_anRoleCount[bRole];
-		}
-		else
-		{
-			sys_err("ROLE_COUNT_DEC_ERROR: INDEX(%d) > MAX(%d)", bRole, PARTY_ROLE_MAX_NUM);
-		}
-	}
-
-	SendPartyInfoOneToAll(dwPID);
-	return true;
-}
-
-BYTE CParty::GetRole(DWORD pid)
-{
-	TMemberMap::iterator it = m_memberMap.find(pid);
-
-	if (it == m_memberMap.end())
-		return PARTY_ROLE_NORMAL;
-	else
-		return it->second.bRole;
-}
-
-bool CParty::IsRole(DWORD pid, BYTE bRole)
-{
-	TMemberMap::iterator it = m_memberMap.find(pid);
-
-	if (it == m_memberMap.end())
-		return false;
-
-	return it->second.bRole == bRole;
-}
-
-void CParty::RemoveBonus()
-{
-	TMemberMap::iterator it;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		LPCHARACTER ch;
-
-		if ((ch = it->second.pCharacter))
-		{
-			ComputeRolePoint(ch, it->second.bRole, false);
-		}
-
-		it->second.bNear = false;
-	}
-}
-
-void CParty::RemoveBonusForOne(DWORD pid)
-{
-	TMemberMap::iterator it = m_memberMap.find(pid);
-
-	if (it == m_memberMap.end())
-		return;
-
-	LPCHARACTER ch;
-
-	if ((ch = it->second.pCharacter))
-		ComputeRolePoint(ch, it->second.bRole, false);
-}
-
-void CParty::HealParty()
-{
-	// XXX DELETEME Å¬¶óÀÌ¾ðÆ® ¿Ï·áµÉ¶§±îÁö
-	{
-		return;
-	}
-	if (!m_bPartyHealReady)
-		return;
-
-	TMemberMap::iterator it;
-	LPCHARACTER l = GetLeaderCharacter();
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if (!it->second.pCharacter)
-			continue;
-
-		LPCHARACTER ch = it->second.pCharacter;
-
-		if (DISTANCE_APPROX(l->GetX() - ch->GetX(), l->GetY() - ch->GetY()) < PARTY_DEFAULT_RANGE)
-		{
-			ch->PointChange(POINT_HP, ch->GetMaxHP() - ch->GetHP());
-			ch->PointChange(POINT_SP, ch->GetMaxSP() - ch->GetSP());
-		}
-	}
-
-	m_bPartyHealReady = false;
-	m_dwPartyHealTime = get_dword_time();
-}
-
-void CParty::SummonToLeader(DWORD pid)
-{
-	int xy[12][2] =
-	{
-		{ 250, 0 },
-		{ 216, 125 },
-		{ 125, 216 },
-		{ 0, 250 },
-		{ -125, 216 },
-		{ -216, 125 },
-		{ -250, 0 },
-		{ -216, -125 },
-		{ -125, -216 },
-		{ 0, -250 },
-		{ 125, -216 },
-		{ 216, -125 },
-	};
-
-	int n = 0;
-	int x[12], y[12];
-
-	SECTREE_MANAGER& s = SECTREE_MANAGER::instance();
-	LPCHARACTER l = GetLeaderCharacter();
-
-	if (m_memberMap.find(pid) == m_memberMap.end())
-	{
-		l->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ¼ÒÈ¯ÇÏ·Á´Â ´ë»óÀ» Ã£À» ¼ö ¾ø½À´Ï´Ù."));
-		return;
-	}
-
-	LPCHARACTER ch = m_memberMap[pid].pCharacter;
-
-	if (!ch)
-	{
-		l->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ¼ÒÈ¯ÇÏ·Á´Â ´ë»óÀ» Ã£À» ¼ö ¾ø½À´Ï´Ù."));
-		return;
-	}
-
-	if (!ch->CanSummon(m_iLeadership))
-	{
-		l->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ´ë»óÀ» ¼ÒÈ¯ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-		return;
-	}
-
-	for (int i = 0; i < 12; ++i)
-	{
-		PIXEL_POSITION p;
-
-		if (s.GetMovablePosition(l->GetMapIndex(), l->GetX() + xy[i][0], l->GetY() + xy[i][1], p))
-		{
-			x[n] = p.x;
-			y[n] = p.y;
-			n++;
-		}
-	}
-
-	if (n == 0)
-		l->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ÆÄÆ¼> ÆÄÆ¼¿øÀ» ÇöÀç À§Ä¡·Î ¼ÒÈ¯ÇÒ ¼ö ¾ø½À´Ï´Ù."));
-	else
-	{
-		int i = number(0, n - 1);
-		ch->Show(l->GetMapIndex(), x[i], y[i]);
-		ch->Stop();
-	}
-}
-
-void CParty::IncreaseOwnership()
-{
-	if (m_memberMap.empty())
-	{
-		m_itNextOwner = m_memberMap.begin();
-		return;
-	}
-
-	if (m_itNextOwner == m_memberMap.end())
-		m_itNextOwner = m_memberMap.begin();
-	else
-	{
-		++m_itNextOwner;
-
-		if (m_itNextOwner == m_memberMap.end())
-			m_itNextOwner = m_memberMap.begin();
-	}
-}
-
-LPCHARACTER CParty::GetNextOwnership(LPCHARACTER ch, long x, long y)
-{
-	if (m_itNextOwner == m_memberMap.end())
-		return ch;
-
-	int size = m_memberMap.size();
-
-	while (size-- > 0)
-	{
-		LPCHARACTER pkMember = m_itNextOwner->second.pCharacter;
-
-		if (pkMember && DISTANCE_APPROX(pkMember->GetX() - x, pkMember->GetY() - y) < 3000)
-		{
-			IncreaseOwnership();
-			return pkMember;
-		}
-
-		IncreaseOwnership();
-	}
-
-	return ch;
-}
-
-#define __PARTY_REMOVE_ROLE_BONUS_FIX__
-void CParty::ComputeRolePoint(LPCHARACTER ch, BYTE bRole, bool bAdd)
-{
-#if defined(__PARTY_PROFICY__)
-	LPCHARACTER leader = GetLeaderCharacter();
-#endif
-
-	if (!bAdd)
-	{
-#if defined(__PARTY_REMOVE_ROLE_BONUS_FIX__)
-		const BYTE bMaxRoleNum = PARTY_ROLE_MAX_NUM - PARTY_ROLE_ATTACKER;
-		std::array<POINT_VALUE, bMaxRoleNum> alPartyPoints = {
-			ch->GetPoint(POINT_PARTY_ATTACKER_BONUS),
-			ch->GetPoint(POINT_PARTY_TANKER_BONUS),
-			ch->GetPoint(POINT_PARTY_BUFFER_BONUS),
-			ch->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS),
-			ch->GetPoint(POINT_PARTY_HASTE_BONUS),
-			ch->GetPoint(POINT_PARTY_DEFENDER_BONUS)
-		};
-
-		bool bComputePoints = false;
-		for (BYTE bIndex = 0; bIndex < bMaxRoleNum; ++bIndex)
-		{
-			if (alPartyPoints[bIndex] != 0)
-			{
-				BYTE bRole = PARTY_ROLE_ATTACKER + bIndex;
-				WORD wPointType = POINT_NONE;
-				switch (bRole)
-				{
-					case PARTY_ROLE_ATTACKER: wPointType = POINT_PARTY_ATTACKER_BONUS; break;
-					case PARTY_ROLE_TANKER: wPointType = POINT_PARTY_TANKER_BONUS; break;
-					case PARTY_ROLE_BUFFER: wPointType = POINT_PARTY_BUFFER_BONUS; break;
-					case PARTY_ROLE_SKILL_MASTER: wPointType = POINT_PARTY_SKILL_MASTER_BONUS; break;
-					case PARTY_ROLE_HASTE: wPointType = POINT_PARTY_HASTE_BONUS; break;
-					case PARTY_ROLE_DEFENDER: wPointType = POINT_PARTY_DEFENDER_BONUS; break;
-					default:
-						continue;
-				}
-				ch->PointChange(wPointType, -alPartyPoints[bIndex]);
-				bComputePoints = true;
-			}
-		}
-
-		if (bComputePoints)
-			ch->ComputePoints();
-#else
-		ch->PointChange(POINT_PARTY_ATTACKER_BONUS, -ch->GetPoint(POINT_PARTY_ATTACKER_BONUS));
-		ch->PointChange(POINT_PARTY_TANKER_BONUS, -ch->GetPoint(POINT_PARTY_TANKER_BONUS));
-		ch->PointChange(POINT_PARTY_BUFFER_BONUS, -ch->GetPoint(POINT_PARTY_BUFFER_BONUS));
-		ch->PointChange(POINT_PARTY_SKILL_MASTER_BONUS, -ch->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS));
-		ch->PointChange(POINT_PARTY_DEFENDER_BONUS, -ch->GetPoint(POINT_PARTY_DEFENDER_BONUS));
-		ch->PointChange(POINT_PARTY_HASTE_BONUS, -ch->GetPoint(POINT_PARTY_HASTE_BONUS));
-		ch->ComputeBattlePoints();
-#endif
-
-#if defined(__PARTY_PROFICY__)
-		if (leader)
-		{
-#if defined(__PARTY_REMOVE_ROLE_BONUS_FIX__)
-			std::array<POINT_VALUE, bMaxRoleNum> alPartyPoints = {
-				leader->GetPoint(POINT_PARTY_ATTACKER_BONUS),
-				leader->GetPoint(POINT_PARTY_TANKER_BONUS),
-				leader->GetPoint(POINT_PARTY_BUFFER_BONUS),
-				leader->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS),
-				leader->GetPoint(POINT_PARTY_HASTE_BONUS),
-				leader->GetPoint(POINT_PARTY_DEFENDER_BONUS)
-			};
-
-			bool bComputePoints = false;
-			for (BYTE bIndex = 0; bIndex < bMaxRoleNum; ++bIndex)
-			{
-				if (alPartyPoints[bIndex] != 0)
-				{
-					BYTE bRole = PARTY_ROLE_ATTACKER + bIndex;
-					WORD wPointType = POINT_NONE;
-					switch (bRole)
-					{
-						case PARTY_ROLE_ATTACKER: wPointType = POINT_PARTY_ATTACKER_BONUS; break;
-						case PARTY_ROLE_TANKER: wPointType = POINT_PARTY_TANKER_BONUS; break;
-						case PARTY_ROLE_BUFFER: wPointType = POINT_PARTY_BUFFER_BONUS; break;
-						case PARTY_ROLE_SKILL_MASTER: wPointType = POINT_PARTY_SKILL_MASTER_BONUS; break;
-						case PARTY_ROLE_HASTE: wPointType = POINT_PARTY_HASTE_BONUS; break;
-						case PARTY_ROLE_DEFENDER: wPointType = POINT_PARTY_DEFENDER_BONUS; break;
-						default:
-							continue;
-					}
-					leader->PointChange(wPointType, -alPartyPoints[bIndex]);
-					bComputePoints = true;
-				}
-			}
-
-			if (bComputePoints)
-				leader->ComputePoints();
-#else
-			leader->PointChange(POINT_PARTY_ATTACKER_BONUS, -leader->GetPoint(POINT_PARTY_ATTACKER_BONUS));
-			leader->PointChange(POINT_PARTY_TANKER_BONUS, -leader->GetPoint(POINT_PARTY_TANKER_BONUS));
-			leader->PointChange(POINT_PARTY_BUFFER_BONUS, -leader->GetPoint(POINT_PARTY_BUFFER_BONUS));
-			leader->PointChange(POINT_PARTY_SKILL_MASTER_BONUS, -leader->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS));
-			leader->PointChange(POINT_PARTY_DEFENDER_BONUS, -leader->GetPoint(POINT_PARTY_DEFENDER_BONUS));
-			leader->PointChange(POINT_PARTY_HASTE_BONUS, -leader->GetPoint(POINT_PARTY_HASTE_BONUS));
-			leader->ComputeBattlePoints();
-#endif
-		}
-#endif
-
-		return;
-	}
-
-	// SKILL_POWER_BY_LEVEL
-	float fSkillPowerByLevel = static_cast<float>(ch->GetSkillPowerByLevel(MIN(SKILL_MAX_LEVEL, m_iLeadership)) / 100.0f);
-	//sys_log(0, "ComputeRolePoint %fi %d, %d ", fSkillPowerByLevel, SKILL_MAX_LEVEL, m_iLeadership);
-	// END_SKILL_POWER_BY_LEVEL
-
-#if defined(__PARTY_PROFICY__)
-	int iProficiencyPowerByLevel = aiProficiencyPowerByLevel[MINMAX(0, leader->GetSkillLevel(SKILL_ROLE_PROFICIENCY), SKILL_MAX_LEVEL)];
-	int iLeaderShipBonus = 0;
-	if (m_iLeadership > 30)
-		iLeaderShipBonus = 15;
-	else if (m_iLeadership > 20)
-		iLeaderShipBonus = 10;
-	else if (m_iLeadership > 10)
-		iLeaderShipBonus = 5;
-#endif
-
-#if defined(__PARTY_INSIGHT__)
-	int iInSightLevel = ch->GetSkillLevel(SKILL_INSIGHT);
-	float fInSightPowerByLevel = static_cast<float>(ch->GetSkillPowerByLevel(MIN(SKILL_MAX_LEVEL, iInSightLevel)) / 100.0f);
-#endif
-
-	switch (bRole)
-	{
-		case PARTY_ROLE_ATTACKER:
-		{
-			int iBonus = static_cast<int>(LEADERSHIP_ATTACKER_BASE_VALUE + LEADERSHIP_ATTACKER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
-
-#if defined(__PARTY_INSIGHT__)
-			if (iInSightLevel != 0)
-				iBonus += static_cast<int>(INSIGHT_ATTACKER_BASE_VALUE + INSIGHT_ATTACKER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
-#endif
-
-			if (ch->GetPoint(POINT_PARTY_ATTACKER_BONUS) != iBonus)
-			{
-				ch->PointChange(POINT_PARTY_ATTACKER_BONUS, iBonus - ch->GetPoint(POINT_PARTY_ATTACKER_BONUS));
-				ch->ComputePoints();
-			}
-
-#if defined(__PARTY_PROFICY__)
-			if (leader)
-			{
-				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
-				if (leader->GetPoint(POINT_PARTY_ATTACKER_BONUS) != iLeaderBonus)
-				{
-					leader->PointChange(POINT_PARTY_ATTACKER_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_ATTACKER_BONUS));
-					leader->ComputePoints();
-				}
-			}
-#endif
-		}
-		break;
-
-		case PARTY_ROLE_TANKER:
-		{
-			int iBonus = static_cast<int>(LEADERSHIP_TANKER_BASE_VALUE + LEADERSHIP_TANKER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
-
-#if defined(__PARTY_INSIGHT__)
-			if (iInSightLevel != 0)
-				iBonus += static_cast<int>(INSIGHT_TANKER_BASE_VALUE + INSIGHT_TANKER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
-#endif
-
-			if (ch->GetPoint(POINT_PARTY_TANKER_BONUS) != iBonus)
-			{
-				ch->PointChange(POINT_PARTY_TANKER_BONUS, iBonus - ch->GetPoint(POINT_PARTY_TANKER_BONUS));
-				ch->ComputePoints();
-			}
-
-#if defined(__PARTY_PROFICY__)
-			if (leader)
-			{
-				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
-				if (leader->GetPoint(POINT_PARTY_TANKER_BONUS) != iLeaderBonus)
-				{
-					leader->PointChange(POINT_PARTY_TANKER_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_TANKER_BONUS));
-					leader->ComputePoints();
-				}
-			}
-#endif
-		}
-		break;
-
-		case PARTY_ROLE_BUFFER:
-		{
-			int iBonus = static_cast<int>(LEADERSHIP_BUFFER_BASE_VALUE + LEADERSHIP_BUFFER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
-
-#if defined(__PARTY_INSIGHT__)
-			if (iInSightLevel != 0)
-				iBonus += static_cast<int>(INSIGHT_BUFFER_BASE_VALUE + INSIGHT_BUFFER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
-#endif
-
-			if (ch->GetPoint(POINT_PARTY_BUFFER_BONUS) != iBonus)
-			{
-				ch->PointChange(POINT_PARTY_BUFFER_BONUS, iBonus - ch->GetPoint(POINT_PARTY_BUFFER_BONUS));
-			}
-
-#if defined(__PARTY_PROFICY__)
-			if (leader)
-			{
-				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
-				if (leader->GetPoint(POINT_PARTY_BUFFER_BONUS) != iLeaderBonus)
-				{
-					leader->PointChange(POINT_PARTY_BUFFER_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_BUFFER_BONUS));
-					leader->ComputePoints();
-				}
-			}
-#endif
-		}
-		break;
-
-		case PARTY_ROLE_SKILL_MASTER:
-		{
-			int iBonus = static_cast<int>(LEADERSHIP_SKILL_MASTER_BASE_VALUE + LEADERSHIP_SKILL_MASTER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
-
-#if defined(__PARTY_INSIGHT__)
-			if (iInSightLevel != 0)
-				iBonus += static_cast<int>(INSIGHT_SKILL_MASTER_BASE_VALUE + INSIGHT_SKILL_MASTER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
-#endif
-
-			if (ch->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS) != iBonus)
-			{
-				ch->PointChange(POINT_PARTY_SKILL_MASTER_BONUS, iBonus - ch->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS));
-				ch->ComputePoints();
-			}
-
-#if defined(__PARTY_PROFICY__)
-			if (leader)
-			{
-				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
-				if (leader->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS) != iLeaderBonus)
-				{
-					leader->PointChange(POINT_PARTY_SKILL_MASTER_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS));
-					leader->ComputePoints();
-				}
-			}
-#endif
-		}
-		break;
-
-		case PARTY_ROLE_HASTE:
-		{
-			int iBonus = static_cast<int>(LEADERSHIP_BERSERKER_BASE_VALUE + LEADERSHIP_BERSERKER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
-
-#if defined(__PARTY_INSIGHT__)
-			if (iInSightLevel != 0)
-				iBonus += static_cast<int>(INSIGHT_BERSERKER_BASE_VALUE + INSIGHT_BERSERKER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
-#endif
-
-			if (ch->GetPoint(POINT_PARTY_HASTE_BONUS) != iBonus)
-			{
-				ch->PointChange(POINT_PARTY_HASTE_BONUS, iBonus - ch->GetPoint(POINT_PARTY_HASTE_BONUS));
-				ch->ComputePoints();
-			}
-
-#if defined(__PARTY_PROFICY__)
-			if (leader)
-			{
-				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
-				if (leader->GetPoint(POINT_PARTY_HASTE_BONUS) != iLeaderBonus)
-				{
-					leader->PointChange(POINT_PARTY_HASTE_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_HASTE_BONUS));
-					leader->ComputePoints();
-				}
-			}
-#endif
-		}
-		break;
-
-		case PARTY_ROLE_DEFENDER:
-		{
-			int iBonus = static_cast<int>(LEADERSHIP_DEFENDER_BASE_VALUE + LEADERSHIP_DEFENDER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
-
-#if defined(__PARTY_INSIGHT__)
-			if (iInSightLevel != 0)
-				iBonus += static_cast<int>(INSIGHT_DEFENDER_BASE_VALUE + INSIGHT_DEFENDER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
-#endif
-
-			if (ch->GetPoint(POINT_PARTY_DEFENDER_BONUS) != iBonus)
-			{
-				ch->PointChange(POINT_PARTY_DEFENDER_BONUS, iBonus - ch->GetPoint(POINT_PARTY_DEFENDER_BONUS));
-				ch->ComputePoints();
-			}
-
-#if defined(__PARTY_PROFICY__)
-			if (leader)
-			{
-				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
-				if (leader->GetPoint(POINT_PARTY_DEFENDER_BONUS) != iLeaderBonus)
-				{
-					leader->PointChange(POINT_PARTY_DEFENDER_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_DEFENDER_BONUS));
-					leader->ComputePoints();
-				}
-			}
-#endif
-		}
-		break;
-
-		default:
-			break;
-	}
-}
-
-void CParty::Update()
-{
-	sys_log(1, "PARTY::Update");
-
-	LPCHARACTER l = GetLeaderCharacter();
-
-	if (!l)
-		return;
-
-	TMemberMap::iterator it;
-
-	int iNearMember = 0;
-	bool bResendAll = false;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		LPCHARACTER ch = it->second.pCharacter;
-
-		it->second.bNear = false;
-
-		if (!ch)
-			continue;
-
-		if (l->GetDungeon())
-			it->second.bNear = l->GetDungeon() == ch->GetDungeon();
-		else
-			it->second.bNear = (DISTANCE_APPROX(l->GetX() - ch->GetX(), l->GetY() - ch->GetY()) < PARTY_DEFAULT_RANGE);
-
-		if (it->second.bNear)
-		{
-			++iNearMember;
-			//sys_log(0, "NEAR %s", ch->GetName());
-		}
-	}
-
-	if (iNearMember <= 1 && !l->GetDungeon())
-	{
-		for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-			it->second.bNear = false;
-
-		iNearMember = 0;
-	}
-
-	if (iNearMember != m_iCountNearPartyMember)
-	{
-		m_iCountNearPartyMember = iNearMember;
-		bResendAll = true;
-	}
-
-	m_iLeadership = l->GetLeadershipSkillLevel();
-	int iNewExpBonus = ComputePartyBonusExpPercent();
-	m_iAttBonus = ComputePartyBonusAttackGrade();
-	m_iDefBonus = ComputePartyBonusDefenseGrade();
-
-	if (m_iExpBonus != iNewExpBonus)
-	{
-		bResendAll = true;
-		m_iExpBonus = iNewExpBonus;
-	}
-
-	bool bLongTimeExpBonusChanged = false;
-
-	// ÆÄÆ¼ °á¼º ÈÄ ÃæºÐÇÑ ½Ã°£ÀÌ Áö³ª¸é °æÇèÄ¡ º¸³Ê½º¸¦ ¹Þ´Â´Ù.
-	if (!m_iLongTimeExpBonus && (get_dword_time() - m_dwPartyStartTime > PARTY_ENOUGH_MINUTE_FOR_EXP_BONUS * 60 * 1000 / (g_iUseLocale ? 1 : 2)))
-	{
-		bLongTimeExpBonusChanged = true;
-		m_iLongTimeExpBonus = 5;
-		bResendAll = true;
-	}
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		LPCHARACTER ch = it->second.pCharacter;
-
-		if (!ch)
-			continue;
-
-		if (bLongTimeExpBonusChanged && ch->GetDesc())
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ÆÄÆ¼ÀÇ Çùµ¿·ÂÀÌ ³ô¾ÆÁ® Áö±ÝºÎÅÍ Ãß°¡ °æÇèÄ¡ º¸³Ê½º¸¦ ¹Þ½À´Ï´Ù."));
-
-		bool bNear = it->second.bNear;
-
-		ComputeRolePoint(ch, it->second.bRole, bNear);
-
-		if (bNear)
-		{
-			if (!bResendAll)
-				SendPartyInfoOneToAll(ch);
-		}
-	}
-
-	// PARTY_ROLE_LIMIT_LEVEL_BUG_FIX
-	m_anMaxRole[PARTY_ROLE_ATTACKER] = m_iLeadership >= 10 ? 1 : 0;
-	m_anMaxRole[PARTY_ROLE_HASTE] = m_iLeadership >= 20 ? 1 : 0;
-	m_anMaxRole[PARTY_ROLE_TANKER] = m_iLeadership >= 20 ? 1 : 0;
-	m_anMaxRole[PARTY_ROLE_BUFFER] = m_iLeadership >= 25 ? 1 : 0;
-	m_anMaxRole[PARTY_ROLE_SKILL_MASTER] = m_iLeadership >= 35 ? 1 : 0;
-	m_anMaxRole[PARTY_ROLE_DEFENDER] = m_iLeadership >= 40 ? 1 : 0;
-#if defined(__PARTY_PROFICY__) || defined(__PARTY_INSIGHT__)
-	m_anMaxRole[PARTY_ROLE_ATTACKER] += m_iLeadership >= 40 ? 2 : 0;
-#else
-	m_anMaxRole[PARTY_ROLE_ATTACKER] += m_iLeadership >= 40 ? 1 : 0;
-#endif
-	// END_OF_PARTY_ROLE_LIMIT_LEVEL_BUG_FIX
-
-	// Party Heal Update
-	if (!m_bPartyHealReady)
-	{
-		if (!m_bCanUsePartyHeal && m_iLeadership >= 18)
-			m_dwPartyHealTime = get_dword_time();
-
-		m_bCanUsePartyHeal = m_iLeadership >= 18; // Åë¼Ö·Â 18 ÀÌ»óÀº ÈúÀ» »ç¿ëÇÒ ¼ö ÀÖÀ½.
-
-		// Åë¼Ö·Â 40ÀÌ»óÀº ÆÄÆ¼ Èú ÄðÅ¸ÀÓÀÌ Àû´Ù.
-		DWORD PartyHealCoolTime = (m_iLeadership >= 40) ? PARTY_HEAL_COOLTIME_SHORT * 60 * 1000 : PARTY_HEAL_COOLTIME_LONG * 60 * 1000;
-
-		if (m_bCanUsePartyHeal)
-		{
-			if (get_dword_time() > m_dwPartyHealTime + PartyHealCoolTime)
-			{
-				m_bPartyHealReady = true;
-
-				// send heal ready
-				if (0) // XXX DELETEME Å¬¶óÀÌ¾ðÆ® ¿Ï·áµÉ¶§±îÁö
-					if (GetLeaderCharacter())
-						GetLeaderCharacter()->ChatPacket(CHAT_TYPE_COMMAND, "PartyHealReady");
-			}
-		}
-	}
-
-	if (bResendAll)
-	{
-		for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-			if (it->second.pCharacter)
-				SendPartyInfoOneToAll(it->second.pCharacter);
-	}
-}
-
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-void CParty::UpdatePosition() const
-{
-	if (!m_bPCParty)
-		return;
-
-	for (TMemberMap::const_iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it) {
-		const LPCHARACTER ch = it->second.pCharacter;
-		if (ch == NULL || ch->GetDesc() == NULL)
-			continue;
-
-		for (TMemberMap::const_iterator it2 = m_memberMap.begin(); it2 != m_memberMap.end(); ++it2) {
-			if (it == it2)
-				continue;
-
-			const LPCHARACTER ch2 = it2->second.pCharacter;
-			if (ch2 == NULL || ch2->GetDesc() == NULL)
-				continue;
-
-			if (ch->GetMapIndex() != ch2->GetMapIndex())
-				continue;
-
-			if (DISTANCE_APPROX(ch->GetX() - ch2->GetX(), ch->GetY() - ch2->GetY()) < 3000)
-				continue;
-
-			TPacketGCPartyUpdate p;
-			ch2->BuildUpdatePartyPacket(p);
-			ch->GetDesc()->Packet(&p, sizeof(p));
-		}
-	}
-}
-#endif
-
-void CParty::UpdateOnlineState(DWORD dwPID, const char* name
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	, long mapIdx
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-	, BYTE channel
-#endif
-)
-{
-	TMember& r = m_memberMap[dwPID];
-
-	TPacketGCPartyAdd p;
-
-	p.header = HEADER_GC_PARTY_ADD;
-	p.pid = dwPID;
-	r.strName = name;
-	strlcpy(p.name, name, sizeof(p.name));
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	p.mapIdx = mapIdx;
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-	p.channel = channel;
-#endif
-
-	for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
-			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
-	}
-}
-void CParty::UpdateOfflineState(DWORD dwPID)
-{
-	//const TMember& r = m_memberMap[dwPID];
-
-	TPacketGCPartyAdd p;
-	p.header = HEADER_GC_PARTY_ADD;
-	p.pid = dwPID;
-	memset(p.name, 0, CHARACTER_NAME_MAX_LEN + 1);
-#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
-	p.mapIdx = 0;
-#endif
-#if defined(__PARTY_CHANNEL_FIX__)
-	p.channel = 0;
-#endif
-
-	for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
-			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
-	}
-}
-
-int CParty::GetFlag(const std::string& name)
-{
-	TFlagMap::iterator it = m_map_iFlag.find(name);
-
-	if (it != m_map_iFlag.end())
-	{
-		//sys_log(0, "PARTY GetFlag %s %d", name.c_str(), it->second);
-		return it->second;
-	}
-
-	//sys_log(0, "PARTY GetFlag %s 0", name.c_str());
-	return 0;
-}
-
-void CParty::SetFlag(const std::string& name, int value)
-{
-	TFlagMap::iterator it = m_map_iFlag.find(name);
-
-	//sys_log(0, "PARTY SetFlag %s %d", name.c_str(), value);
-	if (it == m_map_iFlag.end())
-	{
-		m_map_iFlag.insert(make_pair(name, value));
-	}
-	else if (it->second != value)
-	{
-		it->second = value;
-	}
-}
-
-void CParty::SetDungeon(LPDUNGEON pDungeon)
-{
-	m_pkDungeon = pDungeon;
-	m_map_iFlag.clear();
-}
-
-LPDUNGEON CParty::GetDungeon()
-{
-	return m_pkDungeon;
-}
-
-void CParty::SetDungeon_for_Only_party(LPDUNGEON pDungeon)
-{
-	m_pkDungeon_for_Only_party = pDungeon;
-}
-
-LPDUNGEON CParty::GetDungeon_for_Only_party()
-{
-	return m_pkDungeon_for_Only_party;
-}
-
-bool CParty::IsPositionNearLeader(LPCHARACTER ch)
-{
-	if (!m_pkChrLeader)
-		return false;
-
-	if (DISTANCE_APPROX(ch->GetX() - m_pkChrLeader->GetX(), ch->GetY() - m_pkChrLeader->GetY()) >= PARTY_DEFAULT_RANGE)
-		return false;
-
-	return true;
-}
-
-int CParty::GetExpBonusPercent()
-{
-	if (GetNearMemberCount() <= 1)
-		return 0;
-
-	return m_iExpBonus + m_iLongTimeExpBonus;
-}
-
-bool CParty::IsNearLeader(DWORD pid)
-{
-	TMemberMap::iterator it = m_memberMap.find(pid);
-
-	if (it == m_memberMap.end())
-		return false;
-
-	return it->second.bNear;
-}
-
-BYTE CParty::CountMemberByVnum(DWORD dwVnum)
-{
-	if (m_bPCParty)
-		return 0;
-
-	LPCHARACTER tch;
-	BYTE bCount = 0;
-
-	TMemberMap::iterator it;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-	{
-		if (!(tch = it->second.pCharacter))
-			continue;
-
-		if (tch->IsPC())
-			continue;
-
-		if (tch->GetMobTable().dwVnum == dwVnum)
-			++bCount;
-	}
-
-	return bCount;
-}
-
-void CParty::SendParameter(LPCHARACTER ch)
-{
-	TPacketGCPartyParameter p;
-
-	p.bHeader = HEADER_GC_PARTY_PARAMETER;
-	p.bDistributeMode = m_iExpDistributionMode;
-
-	LPDESC d = ch->GetDesc();
-
-	if (d)
-	{
-		d->Packet(&p, sizeof(TPacketGCPartyParameter));
-	}
-}
-
-void CParty::SendParameterToAll()
-{
-	if (!m_bPCParty)
-		return;
-
-	TMemberMap::iterator it;
-
-	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
-		if (it->second.pCharacter)
-			SendParameter(it->second.pCharacter);
-}
-
-void CParty::SetParameter(int iMode)
-{
-	if (iMode >= PARTY_EXP_DISTRIBUTION_MAX_NUM)
-	{
-		sys_err("Invalid exp distribution mode %d", iMode);
-		return;
-	}
-
-	m_iExpDistributionMode = iMode;
-	SendParameterToAll();
-}
-
-int CParty::GetExpDistributionMode()
-{
-	return m_iExpDistributionMode;
-}
-
-void CParty::SetExpCentralizeCharacter(DWORD dwPID)
-{
-	TMemberMap::iterator it = m_memberMap.find(dwPID);
-
-	if (it == m_memberMap.end())
-		return;
-
-	m_pkChrExpCentralize = it->second.pCharacter;
-}
-
-LPCHARACTER CParty::GetExpCentralizeCharacter()
-{
-	return m_pkChrExpCentralize;
-}
-
-BYTE CParty::GetMemberMaxLevel()
-{
-	BYTE bMax = 0;
-
-	auto it = m_memberMap.begin();
-	while (it != m_memberMap.end())
-	{
-		if (!it->second.bLevel)
-		{
-			++it;
-			continue;
-		}
-
-		if (!bMax)
-			bMax = it->second.bLevel;
-		else if (it->second.bLevel)
-			bMax = MAX(bMax, it->second.bLevel);
-		++it;
-	}
-	return bMax;
-}
-
-BYTE CParty::GetMemberMinLevel()
-{
-	BYTE bMin = PLAYER_MAX_LEVEL_CONST;
-
-	auto it = m_memberMap.begin();
-	while (it != m_memberMap.end())
-	{
-		if (!it->second.bLevel)
-		{
-			++it;
-			continue;
-		}
-
-		if (!bMin)
-			bMin = it->second.bLevel;
-		else if (it->second.bLevel)
-			bMin = MIN(bMin, it->second.bLevel);
-		++it;
-	}
-	return bMin;
-}
-
-int CParty::ComputePartyBonusExpPercent()
-{
-	if (GetNearMemberCount() <= 1)
-		return 0;
-
-	LPCHARACTER leader = GetLeaderCharacter();
-
-	int iBonusPartyExpFromItem = 0;
-
-	// UPGRADE_PARTY_BONUS
-	int iMemberCount = MIN(8, GetNearMemberCount());
-
-	if (leader && (leader->IsEquipUniqueGroup(UNIQUE_GROUP_PARTY_BONUS_EXP)))
-	{
-		// Áß±¹Ãø À°µµ Àû¿ëÀ» È®ÀÎÇØ¾ßÇÑ´Ù.
-		if (g_iUseLocale)
-		{
-			iBonusPartyExpFromItem = 30;
-		}
-		else
-		{
-			iBonusPartyExpFromItem = KOR_aiUniqueItemPartyBonusExpPercentByMemberCount[iMemberCount];
-		}
-	}
-
-	if (leader && (leader->IsEquipUniqueGroup(UNIQUE_GROUP_PARTY_BONUS_EXP_100)))
-		iBonusPartyExpFromItem = 100;
-
-	if (g_iUseLocale)
-		return iBonusPartyExpFromItem + CHN_aiPartyBonusExpPercentByMemberCount[iMemberCount];
-	else
-		return iBonusPartyExpFromItem + KOR_aiPartyBonusExpPercentByMemberCount[iMemberCount];
-	// END_OF_UPGRADE_PARTY_BONUS
-}
+#include "stdafx.h"
+#include "utils.h"
+#include "char.h"
+#include "party.h"
+#include "char_manager.h"
+#include "config.h"
+#include "p2p.h"
+#include "desc_client.h"
+#include "dungeon.h"
+#include "unique_item.h"
+#ifdef ENABLE_QUEEN_NETHIS
+#include "SnakeLair.h"
+#endif
+#include "buffer_manager.h"
+
+#if defined(__PARTY_PROFICY__) || defined(__PARTY_INSIGHT__)
+#	include "skill.h"
+#endif
+
+#if defined(__PARTY_KILL_RENEWAL__)
+#include "utils.h"
+#include "questmanager.h"
+
+void FPartyKill::operator()(LPCHARACTER pMember)
+{
+	if (m_pAttacker == NULL || m_pVictim == NULL)
+		return;
+
+	if (m_pAttacker == pMember)
+		return;
+
+	if (DISTANCE_APPROX(m_pAttacker->GetX() - pMember->GetX(),
+		m_pAttacker->GetY() - pMember->GetY()) > PARTY_DEFAULT_RANGE)
+		return;
+
+	pMember->SetQuestNPCID(m_pVictim->GetVID());
+	quest::CQuestManager::Instance().PartyKill(pMember->GetPlayerID(), m_pVictim->GetRaceNum());
+}
+#endif
+
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+EVENTINFO(party_position_event_info)
+{
+	LPPARTY pParty;
+	party_position_event_info() :
+		pParty(NULL)
+	{}
+};
+
+EVENTFUNC(party_position_event)
+{
+	const party_position_event_info* info = dynamic_cast<party_position_event_info*>(event->info);
+
+	if (info == NULL || info->pParty == NULL)
+	{
+		sys_err("party_position_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	info->pParty->UpdatePosition();
+	return PASSES_PER_SEC(3);
+}
+#endif
+
+CPartyManager::CPartyManager()
+{
+	Initialize();
+}
+
+CPartyManager::~CPartyManager()
+{
+}
+
+void CPartyManager::Initialize()
+{
+	m_bEnablePCParty = false;
+}
+
+void CPartyManager::DeleteAllParty()
+{
+	TPCPartySet::iterator it = m_set_pkPCParty.begin();
+
+	while (it != m_set_pkPCParty.end())
+	{
+		DeleteParty(*it);
+		it = m_set_pkPCParty.begin();
+	}
+}
+
+bool CPartyManager::SetParty(LPCHARACTER ch) // PC Ø¾ Ñ´!!
+{
+	TPartyMap::iterator it = m_map_pkParty.find(ch->GetPlayerID());
+
+	if (it == m_map_pkParty.end())
+		return false;
+
+	LPPARTY pParty = it->second;
+	if (!pParty)
+		return false;
+
+	pParty->Link(ch);
+	return true;
+}
+
+void CPartyManager::P2PLogin(DWORD pid, const char* name
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	, long mapIdx
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+	, BYTE channel
+#endif
+)
+{
+	TPartyMap::iterator it = m_map_pkParty.find(pid);
+	if (it == m_map_pkParty.end())
+		return;
+
+	it->second->UpdateOnlineState(pid, name
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+		, mapIdx
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+		, channel
+#endif
+	);
+}
+
+void CPartyManager::P2PLogout(DWORD pid)
+{
+	TPartyMap::iterator it = m_map_pkParty.find(pid);
+
+	if (it == m_map_pkParty.end())
+		return;
+
+	it->second->UpdateOfflineState(pid);
+}
+
+void CPartyManager::P2PJoinParty(DWORD leader, DWORD pid, BYTE role)
+{
+	TPartyMap::iterator it = m_map_pkParty.find(leader);
+
+	if (it != m_map_pkParty.end())
+	{
+		it->second->P2PJoin(pid);
+
+		if (role >= PARTY_ROLE_MAX_NUM)
+			role = PARTY_ROLE_NORMAL;
+
+		it->second->SetRole(pid, role, true);
+	}
+	else
+	{
+		sys_err("No such party with leader [%d]", leader);
+	}
+}
+
+void CPartyManager::P2PQuitParty(DWORD pid)
+{
+	TPartyMap::iterator it = m_map_pkParty.find(pid);
+
+	if (it != m_map_pkParty.end())
+	{
+		it->second->P2PQuit(pid);
+	}
+	else
+	{
+		sys_err("No such party with member [%d]", pid);
+	}
+}
+
+LPPARTY CPartyManager::P2PCreateParty(DWORD pid)
+{
+	TPartyMap::iterator it = m_map_pkParty.find(pid);
+	if (it != m_map_pkParty.end())
+		return it->second;
+
+	LPPARTY pParty = M2_NEW CParty;
+
+	m_set_pkPCParty.insert(pParty);
+
+	SetPartyMember(pid, pParty);
+	pParty->SetPCParty(true);
+	pParty->P2PJoin(pid);
+
+	return pParty;
+}
+
+void CPartyManager::P2PDeleteParty(DWORD pid)
+{
+	TPartyMap::iterator it = m_map_pkParty.find(pid);
+
+	if (it != m_map_pkParty.end())
+	{
+		m_set_pkPCParty.erase(it->second);
+		M2_DELETE(it->second);
+	}
+	else
+		sys_err("PARTY P2PDeleteParty Cannot find party [%u]", pid);
+}
+
+LPPARTY CPartyManager::FindParty(DWORD dwPID)
+{
+	TPartyMap::iterator it = m_map_pkParty.find(dwPID);
+	if (it == m_map_pkParty.end())
+	{
+		return NULL;
+	}
+	return it->second;
+}
+
+LPPARTY CPartyManager::CreateParty(LPCHARACTER pLeader)
+{
+	if (pLeader->GetParty())
+		return pLeader->GetParty();
+
+	LPPARTY pParty = M2_NEW CParty;
+
+	if (pLeader->IsPC())
+	{
+		//TPacketGGParty p;
+		//p.header = HEADER_GG_PARTY;
+		//p.subheader = PARTY_SUBHEADER_GG_CREATE;
+		//p.pid = pLeader->GetPlayerID();
+		//P2P_MANAGER::instance().Send(&p, sizeof(p));
+		TPacketPartyCreate p;
+		p.dwLeaderPID = pLeader->GetPlayerID();
+
+		db_clientdesc->DBPacket(HEADER_GD_PARTY_CREATE, 0, &p, sizeof(TPacketPartyCreate));
+
+		sys_log(0, "PARTY: Create %s pid %u", pLeader->GetName(), pLeader->GetPlayerID());
+		pParty->SetPCParty(true);
+		pParty->Join(pLeader->GetPlayerID());
+
+		m_set_pkPCParty.insert(pParty);
+	}
+	else
+	{
+		pParty->SetPCParty(false);
+		pParty->Join(pLeader->GetVID());
+	}
+
+	pParty->Link(pLeader);
+	return (pParty);
+}
+
+void CPartyManager::DeleteParty(LPPARTY pParty)
+{
+	//TPacketGGParty p;
+	//p.header = HEADER_GG_PARTY;
+	//p.subheader = PARTY_SUBHEADER_GG_DESTROY;
+	//p.pid = pParty->GetLeaderPID();
+	//P2P_MANAGER::instance().Send(&p, sizeof(p));
+	TPacketPartyDelete p;
+	p.dwLeaderPID = pParty->GetLeaderPID();
+
+	db_clientdesc->DBPacket(HEADER_GD_PARTY_DELETE, 0, &p, sizeof(TPacketPartyDelete));
+
+	m_set_pkPCParty.erase(pParty);
+	M2_DELETE(pParty);
+}
+
+void CPartyManager::SetPartyMember(DWORD dwPID, LPPARTY pParty)
+{
+	TPartyMap::iterator it = m_map_pkParty.find(dwPID);
+
+	if (pParty == NULL)
+	{
+		if (it != m_map_pkParty.end())
+			m_map_pkParty.erase(it);
+	}
+	else
+	{
+		if (it != m_map_pkParty.end())
+		{
+			if (it->second != pParty)
+			{
+				it->second->Quit(dwPID);
+				it->second = pParty;
+			}
+		}
+		else
+			m_map_pkParty.insert(TPartyMap::value_type(dwPID, pParty));
+	}
+}
+
+EVENTINFO(party_update_event_info)
+{
+	DWORD pid;
+
+	party_update_event_info()
+		: pid(0)
+	{
+	}
+};
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// CParty begin!
+//
+/////////////////////////////////////////////////////////////////////////////
+EVENTFUNC(party_update_event)
+{
+	party_update_event_info* info = dynamic_cast<party_update_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("party_update_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	DWORD pid = info->pid;
+	LPCHARACTER leader = CHARACTER_MANAGER::instance().FindByPID(pid);
+
+	if (leader && leader->GetDesc())
+	{
+		LPPARTY pParty = leader->GetParty();
+
+		if (pParty)
+			pParty->Update();
+	}
+
+	return PASSES_PER_SEC(3);
+}
+
+CParty::CParty()
+{
+	Initialize();
+}
+
+CParty::~CParty()
+{
+	Destroy();
+}
+
+void CParty::Initialize()
+{
+	sys_log(2, "Party::Initialize");
+
+	m_iExpDistributionMode = PARTY_EXP_DISTRIBUTION_NON_PARITY;
+	m_pkChrExpCentralize = NULL;
+
+	m_dwLeaderPID = 0;
+
+	m_eventUpdate = NULL;
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	m_eventUpdatePosition = NULL;
+#endif
+
+	memset(&m_anRoleCount, 0, sizeof(m_anRoleCount));
+	memset(&m_anMaxRole, 0, sizeof(m_anMaxRole));
+	m_anMaxRole[PARTY_ROLE_LEADER] = 1;
+	m_anMaxRole[PARTY_ROLE_NORMAL] = 32;
+
+	m_dwPartyStartTime = get_dword_time();
+	m_iLongTimeExpBonus = 0;
+
+	m_dwPartyHealTime = get_dword_time();
+	m_bPartyHealReady = false;
+	m_bCanUsePartyHeal = false;
+
+	m_iLeadership = 0;
+	m_iExpBonus = 0;
+	m_iAttBonus = 0;
+	m_iDefBonus = 0;
+
+	m_itNextOwner = m_memberMap.begin();
+
+	m_iCountNearPartyMember = 0;
+
+	m_pkChrLeader = NULL;
+	m_bPCParty = false;
+	m_pkDungeon = NULL;
+	m_pkDungeon_for_Only_party = NULL;
+}
+
+void CParty::Destroy()
+{
+	sys_log(2, "Party::Destroy");
+
+	// PC  Æ¼ Æ¼Å´ Ê¿ PID Ø¾ Ñ´.
+	if (m_bPCParty)
+	{
+		for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+			CPartyManager::instance().SetPartyMember(it->first, NULL);
+	}
+
+	if (m_eventUpdate)
+		event_cancel(&m_eventUpdate);
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	if (m_eventUpdatePosition)
+		event_cancel(&m_eventUpdatePosition);
+#endif
+
+	RemoveBonus();
+
+	TMemberMap::iterator it = m_memberMap.begin();
+
+	DWORD dwTime = get_dword_time();
+
+	while (it != m_memberMap.end())
+	{
+		TMember& rMember = it->second;
+		++it;
+
+		if (rMember.pCharacter)
+		{
+			if (rMember.pCharacter->GetDesc())
+			{
+				TPacketGCPartyRemove p;
+				p.header = HEADER_GC_PARTY_REMOVE;
+				p.pid = rMember.pCharacter->GetPlayerID();
+				rMember.pCharacter->GetDesc()->Packet(&p, sizeof(p));
+				rMember.pCharacter->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼ Ø» Ç¾Ï´."));
+#ifdef ENABLE_QUEEN_NETHIS
+				if (SnakeLair::CSnk::instance().IsSnakeMap(rMember.pCharacter->GetMapIndex()))
+				{
+					SnakeLair::CSnk::instance().LeaveParty(rMember.pCharacter->GetMapIndex());
+					SnakeLair::CSnk::instance().Leave(rMember.pCharacter);
+				}
+#endif
+			}
+			else
+			{
+				// NPC   Ã°    Æ´   Ï´ ÌºÆ® Û½Å².
+				rMember.pCharacter->SetLastAttacked(dwTime);
+				rMember.pCharacter->StartDestroyWhenIdleEvent();
+			}
+
+			rMember.pCharacter->SetParty(NULL);
+		}
+	}
+
+	m_memberMap.clear();
+	m_itNextOwner = m_memberMap.begin();
+
+	if (m_pkDungeon_for_Only_party != NULL)
+	{
+		m_pkDungeon_for_Only_party->SetPartyNull();
+		m_pkDungeon_for_Only_party = NULL;
+	}
+}
+
+void CParty::ChatPacketToAllMember(BYTE type, const char* format, ...)
+{
+	char chatbuf[CHAT_MAX_LEN + 1];
+	va_list args;
+
+	va_start(args, format);
+	vsnprintf(chatbuf, sizeof(chatbuf), format, args);
+	va_end(args);
+
+	TMemberMap::iterator it;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		TMember& rMember = it->second;
+
+		if (rMember.pCharacter)
+		{
+			if (rMember.pCharacter->GetDesc())
+			{
+				rMember.pCharacter->ChatPacket(type, "%s", chatbuf);
+			}
+		}
+	}
+}
+
+DWORD CParty::GetLeaderPID()
+{
+	return m_dwLeaderPID;
+}
+
+DWORD CParty::GetMemberCount()
+{
+	return m_memberMap.size();
+}
+
+void CParty::P2PJoin(DWORD dwPID)
+{
+	TMemberMap::iterator it = m_memberMap.find(dwPID);
+
+	if (it == m_memberMap.end())
+	{
+		TMember Member;
+
+		Member.pCharacter = NULL;
+		Member.bNear = false;
+
+		if (m_memberMap.empty())
+		{
+			Member.bRole = PARTY_ROLE_LEADER;
+			m_dwLeaderPID = dwPID;
+		}
+		else
+			Member.bRole = PARTY_ROLE_NORMAL;
+
+		if (m_bPCParty)
+		{
+			LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(dwPID);
+
+			if (ch)
+			{
+				sys_log(0, "PARTY: Join %s pid %u leader %u", ch->GetName(), dwPID, m_dwLeaderPID);
+				Member.strName = ch->GetName();
+
+				if (Member.bRole == PARTY_ROLE_LEADER)
+					m_iLeadership = ch->GetLeadershipSkillLevel();
+
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+				Member.lMapIndex = ch->GetMapIndex();
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+				Member.bChannel = g_bChannel;
+#endif
+			}
+			else
+			{
+				CCI* pcci = P2P_MANAGER::instance().FindByPID(dwPID);
+
+				if (!pcci);
+				else if (pcci->bChannel == g_bChannel)
+				{
+					Member.strName = pcci->szName;
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+					Member.lMapIndex = pcci->lMapIndex;
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+					Member.bChannel = pcci->bChannel;
+#endif
+				}
+				else
+					sys_err("member is not in same channel PID: %u channel %d, this channel %d", dwPID, pcci->bChannel, g_bChannel);
+			}
+		}
+
+		sys_log(2, "PARTY[%d] MemberCountChange %d -> %d", GetLeaderPID(), GetMemberCount(), GetMemberCount() + 1);
+
+		m_memberMap.insert(TMemberMap::value_type(dwPID, Member));
+
+		if (m_memberMap.size() == 1)
+			m_itNextOwner = m_memberMap.begin();
+
+		if (m_bPCParty)
+		{
+			CPartyManager::instance().SetPartyMember(dwPID, this);
+			SendPartyJoinOneToAll(dwPID);
+
+			LPCHARACTER ch = CHARACTER_MANAGER::instance().FindByPID(dwPID);
+
+			if (ch)
+				SendParameter(ch);
+		}
+	}
+
+	if (m_pkDungeon)
+		m_pkDungeon->QuitParty(this);
+}
+
+void CParty::Join(DWORD dwPID)
+{
+	P2PJoin(dwPID);
+
+	if (m_bPCParty)
+	{
+		TPacketPartyAdd p;
+		p.dwLeaderPID = GetLeaderPID();
+		p.dwPID = dwPID;
+		p.bState = PARTY_ROLE_NORMAL; // #0000790: [M2EU] CZ Å© : Ê±È­ ß¿!
+		db_clientdesc->DBPacket(HEADER_GD_PARTY_ADD, 0, &p, sizeof(p));
+	}
+}
+
+void CParty::P2PQuit(DWORD dwPID)
+{
+	TMemberMap::iterator it = m_memberMap.find(dwPID);
+
+	if (it == m_memberMap.end())
+		return;
+
+	if (m_bPCParty)
+		SendPartyRemoveOneToAll(dwPID);
+
+	if (it == m_itNextOwner)
+		IncreaseOwnership();
+
+	if (m_bPCParty)
+		RemoveBonusForOne(dwPID);
+
+	LPCHARACTER ch = it->second.pCharacter;
+	BYTE bRole = it->second.bRole;
+
+	m_memberMap.erase(it);
+
+	sys_log(2, "PARTY[%d] MemberCountChange %d -> %d", GetLeaderPID(), GetMemberCount(), GetMemberCount() - 1);
+
+	if (bRole < PARTY_ROLE_MAX_NUM)
+	{
+		--m_anRoleCount[bRole];
+	}
+	else
+	{
+		sys_err("ROLE_COUNT_QUIT_ERROR: INDEX(%d) > MAX(%d)", bRole, PARTY_ROLE_MAX_NUM);
+	}
+
+	if (ch)
+	{
+		ch->SetParty(NULL);
+		ComputeRolePoint(ch, bRole, false);
+	}
+
+	if (m_bPCParty)
+		CPartyManager::instance().SetPartyMember(dwPID, NULL);
+
+	//   Æ¼ Ø»Ç¾ Ñ´.
+	if (bRole == PARTY_ROLE_LEADER)
+		CPartyManager::instance().DeleteParty(this);
+
+	//  Æ· Úµå¸¦ ß°  !!!  DeleteParty Ï¸ this .
+}
+
+void CParty::Quit(DWORD dwPID)
+{
+	// Always PC
+	P2PQuit(dwPID);
+
+	if (m_bPCParty && dwPID != GetLeaderPID())
+	{
+		//TPacketGGParty p;
+		//p.header = HEADER_GG_PARTY;
+		//p.subheader = PARTY_SUBHEADER_GG_QUIT;
+		//p.pid = dwPID;
+		//p.leaderpid = GetLeaderPID();
+		//P2P_MANAGER::instance().Send(&p, sizeof(p));
+		TPacketPartyRemove p;
+		p.dwPID = dwPID;
+		p.dwLeaderPID = GetLeaderPID();
+		db_clientdesc->DBPacket(HEADER_GD_PARTY_REMOVE, 0, &p, sizeof(p));
+	}
+}
+
+void CParty::Link(LPCHARACTER pkChr)
+{
+	TMemberMap::iterator it;
+
+	if (pkChr->IsPC())
+		it = m_memberMap.find(pkChr->GetPlayerID());
+	else
+		it = m_memberMap.find(pkChr->GetVID());
+
+	if (it == m_memberMap.end())
+	{
+		sys_err("%s is not member of this party", pkChr->GetName());
+		return;
+	}
+
+	// Ã·Ì¾ Æ¼  Æ® ÌºÆ® 
+	if (m_bPCParty && !m_eventUpdate)
+	{
+		party_update_event_info* info = AllocEventInfo<party_update_event_info>();
+		info->pid = m_dwLeaderPID;
+		m_eventUpdate = event_create(party_update_event, info, PASSES_PER_SEC(3));
+	}
+
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	if (m_bPCParty && !m_eventUpdatePosition)
+	{
+		party_position_event_info* info = AllocEventInfo<party_position_event_info>();
+		info->pParty = this;
+		m_eventUpdatePosition = event_create(party_position_event, info, PASSES_PER_SEC(3));
+	}
+#endif
+
+	if (it->second.bRole == PARTY_ROLE_LEADER)
+		m_pkChrLeader = pkChr;
+
+	sys_log(2, "PARTY[%d] %s linked to party", GetLeaderPID(), pkChr->GetName());
+
+	it->second.pCharacter = pkChr;
+	pkChr->SetParty(this);
+
+	if (pkChr->IsPC())
+	{
+		if (it->second.strName.empty())
+		{
+			it->second.strName = pkChr->GetName();
+		}
+
+		SendPartyJoinOneToAll(pkChr->GetPlayerID());
+
+		SendPartyJoinAllToOne(pkChr);
+		SendPartyLinkOneToAll(pkChr);
+		SendPartyLinkAllToOne(pkChr);
+		SendPartyInfoAllToOne(pkChr);
+		SendPartyInfoOneToAll(pkChr);
+
+		SendParameter(pkChr);
+
+		//sys_log(0, "PARTY-DUNGEON connect %p %p", this, GetDungeon());
+		if (GetDungeon() && GetDungeon()->GetMapIndex() == pkChr->GetMapIndex())
+		{
+			pkChr->SetDungeon(GetDungeon());
+		}
+
+		RequestSetMemberLevel(pkChr->GetPlayerID(), pkChr->GetLevel());
+	}
+}
+
+void CParty::RequestSetMemberLevel(DWORD pid, BYTE level)
+{
+	TPacketPartySetMemberLevel p;
+	p.dwLeaderPID = GetLeaderPID();
+	p.dwPID = pid;
+	p.bLevel = level;
+	db_clientdesc->DBPacket(HEADER_GD_PARTY_SET_MEMBER_LEVEL, 0, &p, sizeof(TPacketPartySetMemberLevel));
+}
+
+void CParty::P2PSetMemberLevel(DWORD pid, BYTE level)
+{
+	if (!m_bPCParty)
+		return;
+
+	TMemberMap::iterator it;
+
+	sys_log(0, "PARTY P2PSetMemberLevel leader %d pid %d level %d", GetLeaderPID(), pid, level);
+
+	it = m_memberMap.find(pid);
+	if (it != m_memberMap.end())
+	{
+		it->second.bLevel = level;
+	}
+}
+
+namespace
+{
+	struct FExitDungeon
+	{
+		void operator()(LPCHARACTER ch)
+		{
+			ch->ExitToSavedLocation();
+		}
+	};
+}
+
+void CParty::Unlink(LPCHARACTER pkChr)
+{
+	TMemberMap::iterator it;
+
+	if (pkChr->IsPC())
+		it = m_memberMap.find(pkChr->GetPlayerID());
+	else
+		it = m_memberMap.find(pkChr->GetVID());
+
+	if (it == m_memberMap.end())
+	{
+		sys_err("%s is not member of this party", pkChr->GetName());
+		return;
+	}
+
+	if (pkChr->IsPC())
+	{
+		SendPartyUnlinkOneToAll(pkChr);
+		//SendPartyUnlinkAllToOne(pkChr); //  Ì¹Ç·  Unlink Å¶  Ê¿ .
+
+		if (it->second.bRole == PARTY_ROLE_LEADER)
+		{
+			RemoveBonus();
+
+			if (it->second.pCharacter->GetDungeon())
+			{
+				// TODO:    
+				FExitDungeon f;
+				ForEachNearMember(f);
+			}
+		}
+	}
+
+	if (it->second.bRole == PARTY_ROLE_LEADER)
+		m_pkChrLeader = NULL;
+
+	// [BUNDLE_15][Fix] Ensure role bonuses are cleared when a member disconnects/changes map
+	ComputeRolePoint(pkChr, it->second.bRole, false);
+	it->second.pCharacter = NULL;
+	pkChr->SetParty(NULL);
+}
+
+void CParty::SendPartyRemoveOneToAll(DWORD pid)
+{
+	TMemberMap::iterator it;
+
+	TPacketGCPartyRemove p;
+	p.header = HEADER_GC_PARTY_REMOVE;
+	p.pid = pid;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
+			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
+	}
+}
+
+void CParty::SendPartyJoinOneToAll(DWORD pid)
+{
+	const TMember& r = m_memberMap[pid];
+
+	TPacketGCPartyAdd p;
+
+	p.header = HEADER_GC_PARTY_ADD;
+	p.pid = pid;
+	strlcpy(p.name, r.strName.c_str(), sizeof(p.name));
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	p.mapIdx = r.lMapIndex;
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+	p.channel = r.bChannel;
+#endif
+
+	for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
+			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
+	}
+}
+
+void CParty::SendPartyJoinAllToOne(LPCHARACTER ch)
+{
+	if (!ch->GetDesc())
+		return;
+
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__) && defined(__PARTY_CHANNEL_FIX__)
+	for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		const CCI* pCCI = P2P_MANAGER::Instance().Find(it->second.strName.c_str());
+		if (it->second.pCharacter || pCCI)
+			UpdateOnlineState(it->first, it->second.strName.c_str(), it->second.lMapIndex, it->second.bChannel);
+		else
+			UpdateOfflineState(it->first);
+	}
+#else
+	TPacketGCPartyAdd p;
+
+	p.header = HEADER_GC_PARTY_ADD;
+	p.name[CHARACTER_NAME_MAX_LEN] = '\0';
+
+	for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		p.pid = it->first;
+		strlcpy(p.name, it->second.strName.c_str(), sizeof(p.name));
+		ch->GetDesc()->Packet(&p, sizeof(p));
+	}
+#endif
+}
+
+void CParty::SendPartyUnlinkOneToAll(LPCHARACTER ch)
+{
+	if (!ch->GetDesc())
+		return;
+
+	TMemberMap::iterator it;
+
+	TPacketGCPartyLink p;
+	p.header = HEADER_GC_PARTY_UNLINK;
+	p.pid = ch->GetPlayerID();
+	p.vid = (DWORD)ch->GetVID();
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	p.mapIdx = 0;
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+	p.channel = 0;
+#endif
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
+			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
+	}
+}
+
+void CParty::SendPartyLinkOneToAll(LPCHARACTER ch)
+{
+	if (!ch->GetDesc())
+		return;
+
+	TMemberMap::iterator it;
+
+	TPacketGCPartyLink p;
+	p.header = HEADER_GC_PARTY_LINK;
+	p.vid = ch->GetVID();
+	p.pid = ch->GetPlayerID();
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	p.mapIdx = ch->GetMapIndex();
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+	p.channel = g_bChannel;
+#endif
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
+			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
+	}
+}
+
+void CParty::SendPartyLinkAllToOne(LPCHARACTER ch)
+{
+	if (!ch->GetDesc())
+		return;
+
+	TMemberMap::iterator it;
+
+	TPacketGCPartyLink p;
+	p.header = HEADER_GC_PARTY_LINK;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if (it->second.pCharacter)
+		{
+			p.vid = it->second.pCharacter->GetVID();
+			p.pid = it->second.pCharacter->GetPlayerID();
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+			p.mapIdx = it->second.pCharacter->GetMapIndex();
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+			p.channel = g_bChannel;
+#endif
+			ch->GetDesc()->Packet(&p, sizeof(p));
+		}
+	}
+}
+
+void CParty::SendPartyInfoOneToAll(DWORD pid)
+{
+	TMemberMap::iterator it = m_memberMap.find(pid);
+
+	if (it == m_memberMap.end())
+		return;
+
+	if (it->second.pCharacter)
+	{
+		SendPartyInfoOneToAll(it->second.pCharacter);
+		return;
+	}
+
+	// Data Building
+	TPacketGCPartyUpdate p;
+	memset(&p, 0, sizeof(p));
+	p.header = HEADER_GC_PARTY_UPDATE;
+	p.pid = pid;
+	p.percent_hp = 255;
+	p.role = it->second.bRole;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if ((it->second.pCharacter) && (it->second.pCharacter->GetDesc()))
+		{
+			//sys_log(2, "PARTY send info %s[%d] to %s[%d]", ch->GetName(), (DWORD)ch->GetVID(), it->second.pCharacter->GetName(), (DWORD)it->second.pCharacter->GetVID());
+			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
+		}
+	}
+}
+
+void CParty::SendPartyInfoOneToAll(LPCHARACTER ch)
+{
+	if (!ch->GetDesc())
+		return;
+
+	TMemberMap::iterator it;
+
+	// Data Building
+	TPacketGCPartyUpdate p;
+	ch->BuildUpdatePartyPacket(p);
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if ((it->second.pCharacter) && (it->second.pCharacter->GetDesc()))
+		{
+			sys_log(2, "PARTY send info %s[%d] to %s[%d]", ch->GetName(), (DWORD)ch->GetVID(), it->second.pCharacter->GetName(), (DWORD)it->second.pCharacter->GetVID());
+			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
+		}
+	}
+}
+
+void CParty::SendPartyInfoAllToOne(LPCHARACTER ch)
+{
+	TMemberMap::iterator it;
+
+	TPacketGCPartyUpdate p;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if (!it->second.pCharacter)
+		{
+			DWORD pid = it->first;
+			memset(&p, 0, sizeof(p));
+			p.header = HEADER_GC_PARTY_UPDATE;
+			p.pid = pid;
+			p.percent_hp = 255;
+			p.role = it->second.bRole;
+			ch->GetDesc()->Packet(&p, sizeof(p));
+			continue;
+		}
+
+		it->second.pCharacter->BuildUpdatePartyPacket(p);
+		sys_log(2, "PARTY send info %s[%d] to %s[%d]", it->second.pCharacter->GetName(), (DWORD)it->second.pCharacter->GetVID(), ch->GetName(), (DWORD)ch->GetVID());
+		ch->GetDesc()->Packet(&p, sizeof(p));
+	}
+}
+
+void CParty::SendMessage(LPCHARACTER ch, BYTE bMsg, DWORD dwArg1, DWORD dwArg2)
+{
+	if (ch->GetParty() != this)
+	{
+		sys_err("%s is not member of this party %p", ch->GetName(), this);
+		return;
+	}
+
+	switch (bMsg)
+	{
+		case PM_ATTACK:
+			break;
+
+		case PM_RETURN:
+		{
+			TMemberMap::iterator it = m_memberMap.begin();
+
+			while (it != m_memberMap.end())
+			{
+				TMember& rMember = it->second;
+				++it;
+
+				LPCHARACTER pkChr;
+
+				if ((pkChr = rMember.pCharacter) && ch != pkChr)
+				{
+					DWORD x = dwArg1 + number(-500, 500);
+					DWORD y = dwArg2 + number(-500, 500);
+
+					pkChr->SetVictim(NULL);
+					pkChr->SetRotationToXY(x, y);
+
+					if (pkChr->Goto(x, y))
+					{
+						LPCHARACTER victim = pkChr->GetVictim();
+						sys_log(0, "%s %p RETURN victim %p", pkChr->GetName(), get_pointer(pkChr), get_pointer(victim));
+						pkChr->SendMovePacket(FUNC_WAIT, 0, 0, 0, 0);
+					}
+				}
+			}
+		}
+		break;
+
+		case PM_ATTACKED_BY: //  Þ¾,   Ã»
+		{
+			//   
+			LPCHARACTER pkChrVictim = ch->GetVictim();
+
+			if (!pkChrVictim)
+				return;
+
+			TMemberMap::iterator it = m_memberMap.begin();
+
+			while (it != m_memberMap.end())
+			{
+				TMember& rMember = it->second;
+				++it;
+
+				LPCHARACTER pkChr;
+
+				if ((pkChr = rMember.pCharacter) && ch != pkChr)
+				{
+					if (pkChr->CanBeginFight())
+						pkChr->BeginFight(pkChrVictim);
+				}
+			}
+		}
+		break;
+
+		case PM_AGGRO_INCREASE:
+		{
+			LPCHARACTER victim = CHARACTER_MANAGER::instance().Find(dwArg2);
+
+			if (!victim)
+				return;
+
+			TMemberMap::iterator it = m_memberMap.begin();
+
+			while (it != m_memberMap.end())
+			{
+				TMember& rMember = it->second;
+				++it;
+
+				LPCHARACTER pkChr;
+
+				if ((pkChr = rMember.pCharacter) && ch != pkChr)
+				{
+					pkChr->UpdateAggrPoint(victim, DAMAGE_TYPE_SPECIAL, dwArg1);
+				}
+			}
+		}
+		break;
+	}
+}
+
+LPCHARACTER CParty::GetLeaderCharacter()
+{
+	TMemberMap::iterator it = m_memberMap.find(GetLeaderPID());
+	if (it == m_memberMap.end())
+		return NULL;
+
+	return it->second.pCharacter;
+}
+
+bool CParty::SetRole(DWORD dwPID, BYTE bRole, bool bSet)
+{
+	TMemberMap::iterator it = m_memberMap.find(dwPID);
+
+	if (it == m_memberMap.end())
+	{
+		return false;
+	}
+
+	LPCHARACTER ch = it->second.pCharacter;
+
+	if (bSet)
+	{
+		if (m_anRoleCount[bRole] >= m_anMaxRole[bRole])
+			return false;
+
+		if (it->second.bRole != PARTY_ROLE_NORMAL)
+			return false;
+
+		it->second.bRole = bRole;
+
+		if (ch && GetLeader())
+			ComputeRolePoint(ch, bRole, true);
+
+		if (bRole < PARTY_ROLE_MAX_NUM)
+		{
+			++m_anRoleCount[bRole];
+		}
+		else
+		{
+			sys_err("ROLE_COUNT_INC_ERROR: INDEX(%d) > MAX(%d)", bRole, PARTY_ROLE_MAX_NUM);
+		}
+	}
+	else
+	{
+		if (it->second.bRole == PARTY_ROLE_LEADER)
+			return false;
+
+		if (it->second.bRole == PARTY_ROLE_NORMAL)
+			return false;
+
+		it->second.bRole = PARTY_ROLE_NORMAL;
+
+		if (ch && GetLeader())
+			ComputeRolePoint(ch, PARTY_ROLE_NORMAL, false);
+
+		if (bRole < PARTY_ROLE_MAX_NUM)
+		{
+			--m_anRoleCount[bRole];
+		}
+		else
+		{
+			sys_err("ROLE_COUNT_DEC_ERROR: INDEX(%d) > MAX(%d)", bRole, PARTY_ROLE_MAX_NUM);
+		}
+	}
+
+	SendPartyInfoOneToAll(dwPID);
+	return true;
+}
+
+BYTE CParty::GetRole(DWORD pid)
+{
+	TMemberMap::iterator it = m_memberMap.find(pid);
+
+	if (it == m_memberMap.end())
+		return PARTY_ROLE_NORMAL;
+	else
+		return it->second.bRole;
+}
+
+bool CParty::IsRole(DWORD pid, BYTE bRole)
+{
+	TMemberMap::iterator it = m_memberMap.find(pid);
+
+	if (it == m_memberMap.end())
+		return false;
+
+	return it->second.bRole == bRole;
+}
+
+void CParty::RemoveBonus()
+{
+	TMemberMap::iterator it;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		LPCHARACTER ch;
+
+		if ((ch = it->second.pCharacter))
+		{
+			ComputeRolePoint(ch, it->second.bRole, false);
+		}
+
+		it->second.bNear = false;
+	}
+}
+
+void CParty::RemoveBonusForOne(DWORD pid)
+{
+	TMemberMap::iterator it = m_memberMap.find(pid);
+
+	if (it == m_memberMap.end())
+		return;
+
+	LPCHARACTER ch;
+
+	if ((ch = it->second.pCharacter))
+		ComputeRolePoint(ch, it->second.bRole, false);
+}
+
+void CParty::HealParty()
+{
+	// XXX DELETEME Å¬Ì¾Æ® Ï·É¶
+	{
+		return;
+	}
+	if (!m_bPartyHealReady)
+		return;
+
+	TMemberMap::iterator it;
+	LPCHARACTER l = GetLeaderCharacter();
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if (!it->second.pCharacter)
+			continue;
+
+		LPCHARACTER ch = it->second.pCharacter;
+
+		if (DISTANCE_APPROX(l->GetX() - ch->GetX(), l->GetY() - ch->GetY()) < PARTY_DEFAULT_RANGE)
+		{
+			ch->PointChange(POINT_HP, ch->GetMaxHP() - ch->GetHP());
+			ch->PointChange(POINT_SP, ch->GetMaxSP() - ch->GetSP());
+		}
+	}
+
+	m_bPartyHealReady = false;
+	m_dwPartyHealTime = get_dword_time();
+}
+
+void CParty::SummonToLeader(DWORD pid)
+{
+	int xy[12][2] =
+	{
+		{ 250, 0 },
+		{ 216, 125 },
+		{ 125, 216 },
+		{ 0, 250 },
+		{ -125, 216 },
+		{ -216, 125 },
+		{ -250, 0 },
+		{ -216, -125 },
+		{ -125, -216 },
+		{ 0, -250 },
+		{ 125, -216 },
+		{ 216, -125 },
+	};
+
+	int n = 0;
+	int x[12], y[12];
+
+	SECTREE_MANAGER& s = SECTREE_MANAGER::instance();
+	LPCHARACTER l = GetLeaderCharacter();
+
+	if (m_memberMap.find(pid) == m_memberMap.end())
+	{
+		l->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> È¯Ï·  Ã£  Ï´."));
+		return;
+	}
+
+	LPCHARACTER ch = m_memberMap[pid].pCharacter;
+
+	if (!ch)
+	{
+		l->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> È¯Ï·  Ã£  Ï´."));
+		return;
+	}
+
+	if (!ch->CanSummon(m_iLeadership))
+	{
+		l->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼>  È¯  Ï´."));
+		return;
+	}
+
+	for (int i = 0; i < 12; ++i)
+	{
+		PIXEL_POSITION p;
+
+		if (s.GetMovablePosition(l->GetMapIndex(), l->GetX() + xy[i][0], l->GetY() + xy[i][1], p))
+		{
+			x[n] = p.x;
+			y[n] = p.y;
+			n++;
+		}
+	}
+
+	if (n == 0)
+		l->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<Æ¼> Æ¼  Ä¡ È¯  Ï´."));
+	else
+	{
+		int i = number(0, n - 1);
+		ch->Show(l->GetMapIndex(), x[i], y[i]);
+		ch->Stop();
+	}
+}
+
+void CParty::IncreaseOwnership()
+{
+	if (m_memberMap.empty())
+	{
+		m_itNextOwner = m_memberMap.begin();
+		return;
+	}
+
+	if (m_itNextOwner == m_memberMap.end())
+		m_itNextOwner = m_memberMap.begin();
+	else
+	{
+		++m_itNextOwner;
+
+		if (m_itNextOwner == m_memberMap.end())
+			m_itNextOwner = m_memberMap.begin();
+	}
+}
+
+LPCHARACTER CParty::GetNextOwnership(LPCHARACTER ch, long x, long y)
+{
+	if (m_itNextOwner == m_memberMap.end())
+		return ch;
+
+	int size = m_memberMap.size();
+
+	while (size-- > 0)
+	{
+		LPCHARACTER pkMember = m_itNextOwner->second.pCharacter;
+
+		if (pkMember && DISTANCE_APPROX(pkMember->GetX() - x, pkMember->GetY() - y) < 3000)
+		{
+			IncreaseOwnership();
+			return pkMember;
+		}
+
+		IncreaseOwnership();
+	}
+
+	return ch;
+}
+
+#define __PARTY_REMOVE_ROLE_BONUS_FIX__
+void CParty::ComputeRolePoint(LPCHARACTER ch, BYTE bRole, bool bAdd)
+{
+#if defined(__PARTY_PROFICY__)
+	LPCHARACTER leader = GetLeaderCharacter();
+#endif
+
+	if (!bAdd)
+	{
+#if defined(__PARTY_REMOVE_ROLE_BONUS_FIX__)
+		const BYTE bMaxRoleNum = PARTY_ROLE_MAX_NUM - PARTY_ROLE_ATTACKER;
+		std::array<POINT_VALUE, bMaxRoleNum> alPartyPoints = {
+			ch->GetPoint(POINT_PARTY_ATTACKER_BONUS),
+			ch->GetPoint(POINT_PARTY_TANKER_BONUS),
+			ch->GetPoint(POINT_PARTY_BUFFER_BONUS),
+			ch->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS),
+			ch->GetPoint(POINT_PARTY_HASTE_BONUS),
+			ch->GetPoint(POINT_PARTY_DEFENDER_BONUS)
+		};
+
+		bool bComputePoints = false;
+		for (BYTE bIndex = 0; bIndex < bMaxRoleNum; ++bIndex)
+		{
+			if (alPartyPoints[bIndex] != 0)
+			{
+				BYTE bRole = PARTY_ROLE_ATTACKER + bIndex;
+				WORD wPointType = POINT_NONE;
+				switch (bRole)
+				{
+					case PARTY_ROLE_ATTACKER: wPointType = POINT_PARTY_ATTACKER_BONUS; break;
+					case PARTY_ROLE_TANKER: wPointType = POINT_PARTY_TANKER_BONUS; break;
+					case PARTY_ROLE_BUFFER: wPointType = POINT_PARTY_BUFFER_BONUS; break;
+					case PARTY_ROLE_SKILL_MASTER: wPointType = POINT_PARTY_SKILL_MASTER_BONUS; break;
+					case PARTY_ROLE_HASTE: wPointType = POINT_PARTY_HASTE_BONUS; break;
+					case PARTY_ROLE_DEFENDER: wPointType = POINT_PARTY_DEFENDER_BONUS; break;
+					default:
+						continue;
+				}
+				ch->PointChange(wPointType, -alPartyPoints[bIndex]);
+				bComputePoints = true;
+			}
+		}
+
+		if (bComputePoints)
+			ch->ComputePoints();
+#else
+		ch->PointChange(POINT_PARTY_ATTACKER_BONUS, -ch->GetPoint(POINT_PARTY_ATTACKER_BONUS));
+		ch->PointChange(POINT_PARTY_TANKER_BONUS, -ch->GetPoint(POINT_PARTY_TANKER_BONUS));
+		ch->PointChange(POINT_PARTY_BUFFER_BONUS, -ch->GetPoint(POINT_PARTY_BUFFER_BONUS));
+		ch->PointChange(POINT_PARTY_SKILL_MASTER_BONUS, -ch->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS));
+		ch->PointChange(POINT_PARTY_DEFENDER_BONUS, -ch->GetPoint(POINT_PARTY_DEFENDER_BONUS));
+		ch->PointChange(POINT_PARTY_HASTE_BONUS, -ch->GetPoint(POINT_PARTY_HASTE_BONUS));
+		ch->ComputeBattlePoints();
+#endif
+
+#if defined(__PARTY_PROFICY__)
+		if (leader)
+		{
+#if defined(__PARTY_REMOVE_ROLE_BONUS_FIX__)
+			std::array<POINT_VALUE, bMaxRoleNum> alPartyPoints = {
+				leader->GetPoint(POINT_PARTY_ATTACKER_BONUS),
+				leader->GetPoint(POINT_PARTY_TANKER_BONUS),
+				leader->GetPoint(POINT_PARTY_BUFFER_BONUS),
+				leader->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS),
+				leader->GetPoint(POINT_PARTY_HASTE_BONUS),
+				leader->GetPoint(POINT_PARTY_DEFENDER_BONUS)
+			};
+
+			bool bComputePoints = false;
+			for (BYTE bIndex = 0; bIndex < bMaxRoleNum; ++bIndex)
+			{
+				if (alPartyPoints[bIndex] != 0)
+				{
+					BYTE bRole = PARTY_ROLE_ATTACKER + bIndex;
+					WORD wPointType = POINT_NONE;
+					switch (bRole)
+					{
+						case PARTY_ROLE_ATTACKER: wPointType = POINT_PARTY_ATTACKER_BONUS; break;
+						case PARTY_ROLE_TANKER: wPointType = POINT_PARTY_TANKER_BONUS; break;
+						case PARTY_ROLE_BUFFER: wPointType = POINT_PARTY_BUFFER_BONUS; break;
+						case PARTY_ROLE_SKILL_MASTER: wPointType = POINT_PARTY_SKILL_MASTER_BONUS; break;
+						case PARTY_ROLE_HASTE: wPointType = POINT_PARTY_HASTE_BONUS; break;
+						case PARTY_ROLE_DEFENDER: wPointType = POINT_PARTY_DEFENDER_BONUS; break;
+						default:
+							continue;
+					}
+					leader->PointChange(wPointType, -alPartyPoints[bIndex]);
+					bComputePoints = true;
+				}
+			}
+
+			if (bComputePoints)
+				leader->ComputePoints();
+#else
+			leader->PointChange(POINT_PARTY_ATTACKER_BONUS, -leader->GetPoint(POINT_PARTY_ATTACKER_BONUS));
+			leader->PointChange(POINT_PARTY_TANKER_BONUS, -leader->GetPoint(POINT_PARTY_TANKER_BONUS));
+			leader->PointChange(POINT_PARTY_BUFFER_BONUS, -leader->GetPoint(POINT_PARTY_BUFFER_BONUS));
+			leader->PointChange(POINT_PARTY_SKILL_MASTER_BONUS, -leader->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS));
+			leader->PointChange(POINT_PARTY_DEFENDER_BONUS, -leader->GetPoint(POINT_PARTY_DEFENDER_BONUS));
+			leader->PointChange(POINT_PARTY_HASTE_BONUS, -leader->GetPoint(POINT_PARTY_HASTE_BONUS));
+			leader->ComputeBattlePoints();
+#endif
+		}
+#endif
+
+		return;
+	}
+
+	// SKILL_POWER_BY_LEVEL
+	float fSkillPowerByLevel = static_cast<float>(ch->GetSkillPowerByLevel(MIN(SKILL_MAX_LEVEL, m_iLeadership)) / 100.0f);
+	//sys_log(0, "ComputeRolePoint %fi %d, %d ", fSkillPowerByLevel, SKILL_MAX_LEVEL, m_iLeadership);
+	// END_SKILL_POWER_BY_LEVEL
+
+#if defined(__PARTY_PROFICY__)
+	int iProficiencyPowerByLevel = aiProficiencyPowerByLevel[MINMAX(0, leader->GetSkillLevel(SKILL_ROLE_PROFICIENCY), SKILL_MAX_LEVEL)];
+	int iLeaderShipBonus = 0;
+	if (m_iLeadership > 30)
+		iLeaderShipBonus = 15;
+	else if (m_iLeadership > 20)
+		iLeaderShipBonus = 10;
+	else if (m_iLeadership > 10)
+		iLeaderShipBonus = 5;
+#endif
+
+#if defined(__PARTY_INSIGHT__)
+	int iInSightLevel = ch->GetSkillLevel(SKILL_INSIGHT);
+	float fInSightPowerByLevel = static_cast<float>(ch->GetSkillPowerByLevel(MIN(SKILL_MAX_LEVEL, iInSightLevel)) / 100.0f);
+#endif
+
+	switch (bRole)
+	{
+		case PARTY_ROLE_ATTACKER:
+		{
+			int iBonus = static_cast<int>(LEADERSHIP_ATTACKER_BASE_VALUE + LEADERSHIP_ATTACKER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
+
+#if defined(__PARTY_INSIGHT__)
+			if (iInSightLevel != 0)
+				iBonus += static_cast<int>(INSIGHT_ATTACKER_BASE_VALUE + INSIGHT_ATTACKER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
+#endif
+
+			if (ch->GetPoint(POINT_PARTY_ATTACKER_BONUS) != iBonus)
+			{
+				ch->PointChange(POINT_PARTY_ATTACKER_BONUS, iBonus - ch->GetPoint(POINT_PARTY_ATTACKER_BONUS));
+				ch->ComputePoints();
+			}
+
+#if defined(__PARTY_PROFICY__)
+			if (leader)
+			{
+				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
+				if (leader->GetPoint(POINT_PARTY_ATTACKER_BONUS) != iLeaderBonus)
+				{
+					leader->PointChange(POINT_PARTY_ATTACKER_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_ATTACKER_BONUS));
+					leader->ComputePoints();
+				}
+			}
+#endif
+		}
+		break;
+
+		case PARTY_ROLE_TANKER:
+		{
+			int iBonus = static_cast<int>(LEADERSHIP_TANKER_BASE_VALUE + LEADERSHIP_TANKER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
+
+#if defined(__PARTY_INSIGHT__)
+			if (iInSightLevel != 0)
+				iBonus += static_cast<int>(INSIGHT_TANKER_BASE_VALUE + INSIGHT_TANKER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
+#endif
+
+			if (ch->GetPoint(POINT_PARTY_TANKER_BONUS) != iBonus)
+			{
+				ch->PointChange(POINT_PARTY_TANKER_BONUS, iBonus - ch->GetPoint(POINT_PARTY_TANKER_BONUS));
+				ch->ComputePoints();
+			}
+
+#if defined(__PARTY_PROFICY__)
+			if (leader)
+			{
+				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
+				if (leader->GetPoint(POINT_PARTY_TANKER_BONUS) != iLeaderBonus)
+				{
+					leader->PointChange(POINT_PARTY_TANKER_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_TANKER_BONUS));
+					leader->ComputePoints();
+				}
+			}
+#endif
+		}
+		break;
+
+		case PARTY_ROLE_BUFFER:
+		{
+			int iBonus = static_cast<int>(LEADERSHIP_BUFFER_BASE_VALUE + LEADERSHIP_BUFFER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
+
+#if defined(__PARTY_INSIGHT__)
+			if (iInSightLevel != 0)
+				iBonus += static_cast<int>(INSIGHT_BUFFER_BASE_VALUE + INSIGHT_BUFFER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
+#endif
+
+			if (ch->GetPoint(POINT_PARTY_BUFFER_BONUS) != iBonus)
+			{
+				ch->PointChange(POINT_PARTY_BUFFER_BONUS, iBonus - ch->GetPoint(POINT_PARTY_BUFFER_BONUS));
+			}
+
+#if defined(__PARTY_PROFICY__)
+			if (leader)
+			{
+				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
+				if (leader->GetPoint(POINT_PARTY_BUFFER_BONUS) != iLeaderBonus)
+				{
+					leader->PointChange(POINT_PARTY_BUFFER_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_BUFFER_BONUS));
+					leader->ComputePoints();
+				}
+			}
+#endif
+		}
+		break;
+
+		case PARTY_ROLE_SKILL_MASTER:
+		{
+			int iBonus = static_cast<int>(LEADERSHIP_SKILL_MASTER_BASE_VALUE + LEADERSHIP_SKILL_MASTER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
+
+#if defined(__PARTY_INSIGHT__)
+			if (iInSightLevel != 0)
+				iBonus += static_cast<int>(INSIGHT_SKILL_MASTER_BASE_VALUE + INSIGHT_SKILL_MASTER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
+#endif
+
+			if (ch->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS) != iBonus)
+			{
+				ch->PointChange(POINT_PARTY_SKILL_MASTER_BONUS, iBonus - ch->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS));
+				ch->ComputePoints();
+			}
+
+#if defined(__PARTY_PROFICY__)
+			if (leader)
+			{
+				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
+				if (leader->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS) != iLeaderBonus)
+				{
+					leader->PointChange(POINT_PARTY_SKILL_MASTER_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_SKILL_MASTER_BONUS));
+					leader->ComputePoints();
+				}
+			}
+#endif
+		}
+		break;
+
+		case PARTY_ROLE_HASTE:
+		{
+			int iBonus = static_cast<int>(LEADERSHIP_BERSERKER_BASE_VALUE + LEADERSHIP_BERSERKER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
+
+#if defined(__PARTY_INSIGHT__)
+			if (iInSightLevel != 0)
+				iBonus += static_cast<int>(INSIGHT_BERSERKER_BASE_VALUE + INSIGHT_BERSERKER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
+#endif
+
+			if (ch->GetPoint(POINT_PARTY_HASTE_BONUS) != iBonus)
+			{
+				ch->PointChange(POINT_PARTY_HASTE_BONUS, iBonus - ch->GetPoint(POINT_PARTY_HASTE_BONUS));
+				ch->ComputePoints();
+			}
+
+#if defined(__PARTY_PROFICY__)
+			if (leader)
+			{
+				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
+				if (leader->GetPoint(POINT_PARTY_HASTE_BONUS) != iLeaderBonus)
+				{
+					leader->PointChange(POINT_PARTY_HASTE_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_HASTE_BONUS));
+					leader->ComputePoints();
+				}
+			}
+#endif
+		}
+		break;
+
+		case PARTY_ROLE_DEFENDER:
+		{
+			int iBonus = static_cast<int>(LEADERSHIP_DEFENDER_BASE_VALUE + LEADERSHIP_DEFENDER_ADJUSTMENT_VALUE * fSkillPowerByLevel);
+
+#if defined(__PARTY_INSIGHT__)
+			if (iInSightLevel != 0)
+				iBonus += static_cast<int>(INSIGHT_DEFENDER_BASE_VALUE + INSIGHT_DEFENDER_ADJUSTMENT_VALUE * fInSightPowerByLevel);
+#endif
+
+			if (ch->GetPoint(POINT_PARTY_DEFENDER_BONUS) != iBonus)
+			{
+				ch->PointChange(POINT_PARTY_DEFENDER_BONUS, iBonus - ch->GetPoint(POINT_PARTY_DEFENDER_BONUS));
+				ch->ComputePoints();
+			}
+
+#if defined(__PARTY_PROFICY__)
+			if (leader)
+			{
+				int iLeaderBonus = MAX(1, (iBonus / 100.0f) * (iLeaderShipBonus + iProficiencyPowerByLevel));
+				if (leader->GetPoint(POINT_PARTY_DEFENDER_BONUS) != iLeaderBonus)
+				{
+					leader->PointChange(POINT_PARTY_DEFENDER_BONUS, iLeaderBonus - leader->GetPoint(POINT_PARTY_DEFENDER_BONUS));
+					leader->ComputePoints();
+				}
+			}
+#endif
+		}
+		break;
+
+		default:
+			break;
+	}
+}
+
+void CParty::Update()
+{
+	sys_log(1, "PARTY::Update");
+
+	LPCHARACTER l = GetLeaderCharacter();
+
+	if (!l)
+		return;
+
+	TMemberMap::iterator it;
+
+	int iNearMember = 0;
+	bool bResendAll = false;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		LPCHARACTER ch = it->second.pCharacter;
+
+		it->second.bNear = false;
+
+		if (!ch)
+			continue;
+
+		if (l->GetDungeon())
+			it->second.bNear = l->GetDungeon() == ch->GetDungeon();
+		else
+			it->second.bNear = (DISTANCE_APPROX(l->GetX() - ch->GetX(), l->GetY() - ch->GetY()) < PARTY_DEFAULT_RANGE);
+
+		if (it->second.bNear)
+		{
+			++iNearMember;
+			//sys_log(0, "NEAR %s", ch->GetName());
+		}
+	}
+
+	if (iNearMember <= 1 && !l->GetDungeon())
+	{
+		for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+			it->second.bNear = false;
+
+		iNearMember = 0;
+	}
+
+	if (iNearMember != m_iCountNearPartyMember)
+	{
+		m_iCountNearPartyMember = iNearMember;
+		bResendAll = true;
+	}
+
+	m_iLeadership = l->GetLeadershipSkillLevel();
+	int iNewExpBonus = ComputePartyBonusExpPercent();
+	m_iAttBonus = ComputePartyBonusAttackGrade();
+	m_iDefBonus = ComputePartyBonusDefenseGrade();
+
+	if (m_iExpBonus != iNewExpBonus)
+	{
+		bResendAll = true;
+		m_iExpBonus = iNewExpBonus;
+	}
+
+	bool bLongTimeExpBonusChanged = false;
+
+	// Æ¼ á¼º   Ã°  Ä¡ Ê½ Þ´Â´.
+	if (!m_iLongTimeExpBonus && (get_dword_time() - m_dwPartyStartTime > PARTY_ENOUGH_MINUTE_FOR_EXP_BONUS * 60 * 1000 / (g_iUseLocale ? 1 : 2)))
+	{
+		bLongTimeExpBonusChanged = true;
+		m_iLongTimeExpBonus = 5;
+		bResendAll = true;
+	}
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		LPCHARACTER ch = it->second.pCharacter;
+
+		if (!ch)
+			continue;
+
+		if (bLongTimeExpBonusChanged && ch->GetDesc())
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Æ¼   Ýº ß° Ä¡ Ê½ Þ½Ï´."));
+
+		bool bNear = it->second.bNear;
+
+		ComputeRolePoint(ch, it->second.bRole, bNear);
+
+		if (bNear)
+		{
+			if (!bResendAll)
+				SendPartyInfoOneToAll(ch);
+		}
+	}
+
+	// PARTY_ROLE_LIMIT_LEVEL_BUG_FIX
+	m_anMaxRole[PARTY_ROLE_ATTACKER] = m_iLeadership >= 10 ? 1 : 0;
+	m_anMaxRole[PARTY_ROLE_HASTE] = m_iLeadership >= 20 ? 1 : 0;
+	m_anMaxRole[PARTY_ROLE_TANKER] = m_iLeadership >= 20 ? 1 : 0;
+	m_anMaxRole[PARTY_ROLE_BUFFER] = m_iLeadership >= 25 ? 1 : 0;
+	m_anMaxRole[PARTY_ROLE_SKILL_MASTER] = m_iLeadership >= 35 ? 1 : 0;
+	m_anMaxRole[PARTY_ROLE_DEFENDER] = m_iLeadership >= 40 ? 1 : 0;
+#if defined(__PARTY_PROFICY__) || defined(__PARTY_INSIGHT__)
+	m_anMaxRole[PARTY_ROLE_ATTACKER] += m_iLeadership >= 40 ? 2 : 0;
+#else
+	m_anMaxRole[PARTY_ROLE_ATTACKER] += m_iLeadership >= 40 ? 1 : 0;
+#endif
+	// END_OF_PARTY_ROLE_LIMIT_LEVEL_BUG_FIX
+
+	// Party Heal Update
+	if (!m_bPartyHealReady)
+	{
+		if (!m_bCanUsePartyHeal && m_iLeadership >= 18)
+			m_dwPartyHealTime = get_dword_time();
+
+		m_bCanUsePartyHeal = m_iLeadership >= 18; // Ö· 18 Ì»    .
+
+		// Ö· 40Ì» Æ¼  Å¸ .
+		DWORD PartyHealCoolTime = (m_iLeadership >= 40) ? PARTY_HEAL_COOLTIME_SHORT * 60 * 1000 : PARTY_HEAL_COOLTIME_LONG * 60 * 1000;
+
+		if (m_bCanUsePartyHeal)
+		{
+			if ((int)(get_dword_time() - (m_dwPartyHealTime + PartyHealCoolTime)) > 0)
+			{
+				m_bPartyHealReady = true;
+
+				// send heal ready
+				if (0) // XXX DELETEME Å¬Ì¾Æ® Ï·É¶
+					if (GetLeaderCharacter())
+						GetLeaderCharacter()->ChatPacket(CHAT_TYPE_COMMAND, "PartyHealReady");
+			}
+		}
+	}
+
+	if (bResendAll)
+	{
+		for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+			if (it->second.pCharacter)
+				SendPartyInfoOneToAll(it->second.pCharacter);
+	}
+}
+
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+void CParty::UpdatePosition() const
+{
+	if (!m_bPCParty)
+		return;
+
+	for (TMemberMap::const_iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it) {
+		const LPCHARACTER ch = it->second.pCharacter;
+		if (ch == NULL || ch->GetDesc() == NULL)
+			continue;
+
+		for (TMemberMap::const_iterator it2 = m_memberMap.begin(); it2 != m_memberMap.end(); ++it2) {
+			if (it == it2)
+				continue;
+
+			const LPCHARACTER ch2 = it2->second.pCharacter;
+			if (ch2 == NULL || ch2->GetDesc() == NULL)
+				continue;
+
+			if (ch->GetMapIndex() != ch2->GetMapIndex())
+				continue;
+
+			if (DISTANCE_APPROX(ch->GetX() - ch2->GetX(), ch->GetY() - ch2->GetY()) < 3000)
+				continue;
+
+			TPacketGCPartyUpdate p;
+			ch2->BuildUpdatePartyPacket(p);
+			ch->GetDesc()->Packet(&p, sizeof(p));
+		}
+	}
+}
+#endif
+
+void CParty::UpdateOnlineState(DWORD dwPID, const char* name
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	, long mapIdx
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+	, BYTE channel
+#endif
+)
+{
+	TMember& r = m_memberMap[dwPID];
+
+	TPacketGCPartyAdd p;
+
+	p.header = HEADER_GC_PARTY_ADD;
+	p.pid = dwPID;
+	r.strName = name;
+	strlcpy(p.name, name, sizeof(p.name));
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	p.mapIdx = mapIdx;
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+	p.channel = channel;
+#endif
+
+	for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
+			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
+	}
+}
+void CParty::UpdateOfflineState(DWORD dwPID)
+{
+	//const TMember& r = m_memberMap[dwPID];
+
+	TPacketGCPartyAdd p;
+	p.header = HEADER_GC_PARTY_ADD;
+	p.pid = dwPID;
+	memset(p.name, 0, CHARACTER_NAME_MAX_LEN + 1);
+#if defined(__WJ_SHOW_PARTY_ON_MINIMAP__)
+	p.mapIdx = 0;
+#endif
+#if defined(__PARTY_CHANNEL_FIX__)
+	p.channel = 0;
+#endif
+
+	for (TMemberMap::iterator it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if (it->second.pCharacter && it->second.pCharacter->GetDesc())
+			it->second.pCharacter->GetDesc()->Packet(&p, sizeof(p));
+	}
+}
+
+int CParty::GetFlag(const std::string& name)
+{
+	TFlagMap::iterator it = m_map_iFlag.find(name);
+
+	if (it != m_map_iFlag.end())
+	{
+		//sys_log(0, "PARTY GetFlag %s %d", name.c_str(), it->second);
+		return it->second;
+	}
+
+	//sys_log(0, "PARTY GetFlag %s 0", name.c_str());
+	return 0;
+}
+
+void CParty::SetFlag(const std::string& name, int value)
+{
+	TFlagMap::iterator it = m_map_iFlag.find(name);
+
+	//sys_log(0, "PARTY SetFlag %s %d", name.c_str(), value);
+	if (it == m_map_iFlag.end())
+	{
+		m_map_iFlag.insert(make_pair(name, value));
+	}
+	else if (it->second != value)
+	{
+		it->second = value;
+	}
+}
+
+void CParty::SetDungeon(LPDUNGEON pDungeon)
+{
+	m_pkDungeon = pDungeon;
+	m_map_iFlag.clear();
+}
+
+LPDUNGEON CParty::GetDungeon()
+{
+	return m_pkDungeon;
+}
+
+void CParty::SetDungeon_for_Only_party(LPDUNGEON pDungeon)
+{
+	m_pkDungeon_for_Only_party = pDungeon;
+}
+
+LPDUNGEON CParty::GetDungeon_for_Only_party()
+{
+	return m_pkDungeon_for_Only_party;
+}
+
+bool CParty::IsPositionNearLeader(LPCHARACTER ch)
+{
+	if (!m_pkChrLeader)
+		return false;
+
+	if (DISTANCE_APPROX(ch->GetX() - m_pkChrLeader->GetX(), ch->GetY() - m_pkChrLeader->GetY()) >= PARTY_DEFAULT_RANGE)
+		return false;
+
+	return true;
+}
+
+int CParty::GetExpBonusPercent()
+{
+	if (GetNearMemberCount() <= 1)
+		return 0;
+
+	return m_iExpBonus + m_iLongTimeExpBonus;
+}
+
+bool CParty::IsNearLeader(DWORD pid)
+{
+	TMemberMap::iterator it = m_memberMap.find(pid);
+
+	if (it == m_memberMap.end())
+		return false;
+
+	return it->second.bNear;
+}
+
+BYTE CParty::CountMemberByVnum(DWORD dwVnum)
+{
+	if (m_bPCParty)
+		return 0;
+
+	LPCHARACTER tch;
+	BYTE bCount = 0;
+
+	TMemberMap::iterator it;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+	{
+		if (!(tch = it->second.pCharacter))
+			continue;
+
+		if (tch->IsPC())
+			continue;
+
+		if (tch->GetMobTable().dwVnum == dwVnum)
+			++bCount;
+	}
+
+	return bCount;
+}
+
+void CParty::SendParameter(LPCHARACTER ch)
+{
+	TPacketGCPartyParameter p;
+
+	p.bHeader = HEADER_GC_PARTY_PARAMETER;
+	p.bDistributeMode = m_iExpDistributionMode;
+
+	LPDESC d = ch->GetDesc();
+
+	if (d)
+	{
+		d->Packet(&p, sizeof(TPacketGCPartyParameter));
+	}
+}
+
+void CParty::SendParameterToAll()
+{
+	if (!m_bPCParty)
+		return;
+
+	TMemberMap::iterator it;
+
+	for (it = m_memberMap.begin(); it != m_memberMap.end(); ++it)
+		if (it->second.pCharacter)
+			SendParameter(it->second.pCharacter);
+}
+
+void CParty::SetParameter(int iMode)
+{
+	if (iMode >= PARTY_EXP_DISTRIBUTION_MAX_NUM)
+	{
+		sys_err("Invalid exp distribution mode %d", iMode);
+		return;
+	}
+
+	m_iExpDistributionMode = iMode;
+	SendParameterToAll();
+}
+
+int CParty::GetExpDistributionMode()
+{
+	return m_iExpDistributionMode;
+}
+
+void CParty::SetExpCentralizeCharacter(DWORD dwPID)
+{
+	TMemberMap::iterator it = m_memberMap.find(dwPID);
+
+	if (it == m_memberMap.end())
+		return;
+
+	m_pkChrExpCentralize = it->second.pCharacter;
+}
+
+LPCHARACTER CParty::GetExpCentralizeCharacter()
+{
+	return m_pkChrExpCentralize;
+}
+
+BYTE CParty::GetMemberMaxLevel()
+{
+	BYTE bMax = 0;
+
+	auto it = m_memberMap.begin();
+	while (it != m_memberMap.end())
+	{
+		if (!it->second.bLevel)
+		{
+			++it;
+			continue;
+		}
+
+		if (!bMax)
+			bMax = it->second.bLevel;
+		else if (it->second.bLevel)
+			bMax = MAX(bMax, it->second.bLevel);
+		++it;
+	}
+	return bMax;
+}
+
+BYTE CParty::GetMemberMinLevel()
+{
+	BYTE bMin = PLAYER_MAX_LEVEL_CONST;
+
+	auto it = m_memberMap.begin();
+	while (it != m_memberMap.end())
+	{
+		if (!it->second.bLevel)
+		{
+			++it;
+			continue;
+		}
+
+		if (!bMin)
+			bMin = it->second.bLevel;
+		else if (it->second.bLevel)
+			bMin = MIN(bMin, it->second.bLevel);
+		++it;
+	}
+	return bMin;
+}
+
+int CParty::ComputePartyBonusExpPercent()
+{
+	if (GetNearMemberCount() <= 1)
+		return 0;
+
+	LPCHARACTER leader = GetLeaderCharacter();
+
+	int iBonusPartyExpFromItem = 0;
+
+	// UPGRADE_PARTY_BONUS
+	int iMemberCount = MIN(8, GetNearMemberCount());
+
+	if (leader && (leader->IsEquipUniqueGroup(UNIQUE_GROUP_PARTY_BONUS_EXP)))
+	{
+		// ß±   È®Ø¾Ñ´.
+		if (g_iUseLocale)
+		{
+			iBonusPartyExpFromItem = 30;
+		}
+		else
+		{
+			iBonusPartyExpFromItem = KOR_aiUniqueItemPartyBonusExpPercentByMemberCount[iMemberCount];
+		}
+	}
+
+	if (leader && (leader->IsEquipUniqueGroup(UNIQUE_GROUP_PARTY_BONUS_EXP_100)))
+		iBonusPartyExpFromItem = 100;
+
+	if (g_iUseLocale)
+		return iBonusPartyExpFromItem + CHN_aiPartyBonusExpPercentByMemberCount[iMemberCount];
+	else
+		return iBonusPartyExpFromItem + KOR_aiPartyBonusExpPercentByMemberCount[iMemberCount];
+	// END_OF_UPGRADE_PARTY_BONUS
+}
