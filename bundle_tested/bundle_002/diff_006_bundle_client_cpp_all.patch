diff --git a/src-client/Client/EffectLib/EffectData.cpp b/src-client/Client/EffectLib/EffectData.cpp
index bc26ce4..052f556 100644
--- a/src-client/Client/EffectLib/EffectData.cpp
+++ b/src-client/Client/EffectLib/EffectData.cpp
@@ -1,4 +1,5 @@
 #include "StdAfx.h"
+#include "../EterPack/EterPackManager.h"
 #include "EffectData.h"
 
 CDynamicPool<CEffectData> CEffectData::ms_kPool;
@@ -98,14 +99,16 @@ bool CEffectData::LoadScript(const char* c_szFileName)
 
 bool CEffectData::LoadSoundScriptData(const char* c_szFileName)
 {
+	// [Perf] Avoid repeated I/O for missing sound scripts
+	if (!CEterPackManager::Instance().isExist(c_szFileName))
+		return true;
+
 	NSound::TSoundDataVector SoundDataVector;
 
-	if (NSound::LoadSoundInformationPiece(c_szFileName, SoundDataVector))
-	{
-		NSound::DataToInstance(SoundDataVector, &m_SoundInstanceVector);
+	if (!NSound::LoadSoundInformationPiece(c_szFileName, SoundDataVector))
 		return false;
-	}
 
+	NSound::DataToInstance(SoundDataVector, &m_SoundInstanceVector);
 	return true;
 }
 
diff --git a/src-client/Client/EterBase/ServiceDefs.h b/src-client/Client/EterBase/ServiceDefs.h
index e3670f8..550b43e 100644
--- a/src-client/Client/EterBase/ServiceDefs.h
+++ b/src-client/Client/EterBase/ServiceDefs.h
@@ -1,73 +1,73 @@
-#ifndef __INC_SERVICE_DEFS_H__
-#define __INC_SERVICE_DEFS_H__
-
-//#define __IMPROVED_PACKET_ENCRYPTION__ // Improved Packet Encryption
-//#define __SEND_SEQUENCE__ // Sequence Matching
-#define __DOUBLE_RECV_BUFFER__ // Increase Recvieve Buffer Size
-#define __VERTEX_BUFFER_PERFORMANCE__ // TextTail Vertex Buffer Performance
-#define __ANI_IMAGE_PERFORMANCE__ // Image Animation Performance
-#define __STATE_MANAGER_DEVICE_FIX__ // State Manager (Lost Device) Fix
-#define __EXTENDED_ERROR_LOG__ // Extended Error Logs
-
-// #if !defined(_DEBUG)
-// #	define __ENABLE_CRASH_RPT__ // CrashRPT (Send Crash Reports)
-// #endif
-
-//#define __MOVIE_MODE__ // Movie Mode
-#define __HIT_RANGE_RENEWAL__ // Hit Range Renewal
-#define __RENDER_TARGET_VIEW_PORT_FIX__ // Render Target ViewPort Fix
-#define __DISABLE_BOSS_PUSHBACK__ // Disable Boss Pushback
-#define __FRAME_UPDATE_OPTIMIZATION__ // Frame Update Optimization
-#define __PY_SECURE_EXEC_MEM_FILE__ // Securely execute a Python file.
-#define __FONT_TEXTURE_FIX__ // Adds padding to prevent random dots in font textures.
-
-#if !defined(_CYTHON)
-//#	define __IMGUI__ // Immediate Mode GUI
-#endif
-
-enum EEterPackKeySet
-{
-	ETERPACK_NONE,
-	ETERPACK_KEY,
-	ETERPACK_SECURITY_KEY,
-	ETERPACK_ITEM_PROTOCOL,
-	ETERPACK_MOB_PROTOCOL,
-
-	COMPRESS_BRICK_SIZE = 4,
-	COMPRESS_BIRCK_LEN = 10,
-
-	COMPRESS_KEY_SIZE = COMPRESS_BIRCK_LEN + COMPRESS_BRICK_SIZE + 2,
-};
-
-static const char* s_strEIX = ".eix"; // EterPack Index
-static const char* s_strEPK = ".epk"; // EterPack
-
-static std::string s_strEterPackSecurityKey[COMPRESS_BRICK_SIZE] = {
-	std::string(AY_OBFUSCATE("599220564")),
-	std::string(AY_OBFUSCATE("715591183")),
-	std::string(AY_OBFUSCATE("1382647704")),
-	std::string(AY_OBFUSCATE("1053692977"))
-};
-
-static std::string s_strEterPackKey[COMPRESS_BRICK_SIZE] = {
-	std::string(AY_OBFUSCATE("843707904")),
-	std::string(AY_OBFUSCATE("1176167288")),
-	std::string(AY_OBFUSCATE("992328100")),
-	std::string(AY_OBFUSCATE("1705708525"))
-};
-
-static std::string s_strItemProtoKey[COMPRESS_BRICK_SIZE] = {
-	std::string(AY_OBFUSCATE("173217")),
-	std::string(AY_OBFUSCATE("72619434")),
-	std::string(AY_OBFUSCATE("408587239")),
-	std::string(AY_OBFUSCATE("27973291"))
-};
-
-static std::string s_strMobProtoKey[COMPRESS_BRICK_SIZE] = {
-	std::string(AY_OBFUSCATE("4813894")),
-	std::string(AY_OBFUSCATE("18955")),
-	std::string(AY_OBFUSCATE("552631")),
-	std::string(AY_OBFUSCATE("6822045"))
-};
-
-#endif // __INC_SERVICE_DEFS_H__
+#ifndef __INC_SERVICE_DEFS_H__
+#define __INC_SERVICE_DEFS_H__
+
+//#define __IMPROVED_PACKET_ENCRYPTION__ // Improved Packet Encryption
+//#define __SEND_SEQUENCE__ // Sequence Matching
+#define __DOUBLE_RECV_BUFFER__ // Increase Recvieve Buffer Size
+#define __VERTEX_BUFFER_PERFORMANCE__ // TextTail Vertex Buffer Performance
+#define __ANI_IMAGE_PERFORMANCE__ // Image Animation Performance
+#define __STATE_MANAGER_DEVICE_FIX__ // State Manager (Lost Device) Fix
+#define __EXTENDED_ERROR_LOG__ // Extended Error Logs
+
+// #if !defined(_DEBUG)
+// #	define __ENABLE_CRASH_RPT__ // CrashRPT (Send Crash Reports)
+// #endif
+
+//#define __MOVIE_MODE__ // Movie Mode
+#define __HIT_RANGE_RENEWAL__ // Hit Range Renewal
+#define __RENDER_TARGET_VIEW_PORT_FIX__ // Render Target ViewPort Fix
+#define __DISABLE_BOSS_PUSHBACK__ // Disable Boss Pushback
+#define __FRAME_UPDATE_OPTIMIZATION__ // Frame Update Optimization
+#define __PY_SECURE_EXEC_MEM_FILE__ // Securely execute a Python file.
+#define __FONT_TEXTURE_FIX__ // Adds padding to prevent random dots in font textures.
+
+#if !defined(_CYTHON)
+//#	define __IMGUI__ // Immediate Mode GUI
+#endif
+
+enum EEterPackKeySet
+{
+	ETERPACK_NONE,
+	ETERPACK_KEY,
+	ETERPACK_SECURITY_KEY,
+	ETERPACK_ITEM_PROTOCOL,
+	ETERPACK_MOB_PROTOCOL,
+
+	COMPRESS_BRICK_SIZE = 4,
+	COMPRESS_BIRCK_LEN = 10,
+
+	COMPRESS_KEY_SIZE = COMPRESS_BIRCK_LEN + COMPRESS_BRICK_SIZE + 2,
+};
+
+static const char* s_strEIX = ".nex"; // EterPack Index
+static const char* s_strEPK = ".npk"; // EterPack
+
+static std::string s_strEterPackSecurityKey[COMPRESS_BRICK_SIZE] = {
+	std::string(AY_OBFUSCATE("599220564")),
+	std::string(AY_OBFUSCATE("715591183")),
+	std::string(AY_OBFUSCATE("1382647704")),
+	std::string(AY_OBFUSCATE("1053692977"))
+};
+
+static std::string s_strEterPackKey[COMPRESS_BRICK_SIZE] = {
+	std::string(AY_OBFUSCATE("843707904")),
+	std::string(AY_OBFUSCATE("1176167288")),
+	std::string(AY_OBFUSCATE("992328100")),
+	std::string(AY_OBFUSCATE("1705708525"))
+};
+
+static std::string s_strItemProtoKey[COMPRESS_BRICK_SIZE] = {
+	std::string(AY_OBFUSCATE("173217")),
+	std::string(AY_OBFUSCATE("72619434")),
+	std::string(AY_OBFUSCATE("408587239")),
+	std::string(AY_OBFUSCATE("27973291"))
+};
+
+static std::string s_strMobProtoKey[COMPRESS_BRICK_SIZE] = {
+	std::string(AY_OBFUSCATE("4813894")),
+	std::string(AY_OBFUSCATE("18955")),
+	std::string(AY_OBFUSCATE("552631")),
+	std::string(AY_OBFUSCATE("6822045"))
+};
+
+#endif // __INC_SERVICE_DEFS_H__
diff --git a/src-client/Client/EterBase/lzo.cpp b/src-client/Client/EterBase/lzo.cpp
index e572e8b..4f819b2 100644
--- a/src-client/Client/EterBase/lzo.cpp
+++ b/src-client/Client/EterBase/lzo.cpp
@@ -1,417 +1,417 @@
-#include "StdAfx.h"
-#include <stdlib.h>
-#include <lzo/lzoLibLink.h>
-
-#include "debug.h"
-#include "lzo.h"
-
-#include "tea.h"
-
-#define dbg_printf
-
-static class LZOFreeMemoryMgr
-{
-public:
-	enum
-	{
-		REUSING_CAPACITY = 64 * 1024,
-	};
-
-public:
-	~LZOFreeMemoryMgr()
-	{
-		std::vector<BYTE*>::iterator i;
-		for (i = m_freeVector.begin(); i != m_freeVector.end(); ++i)
-			delete* i;
-
-		m_freeVector.clear();
-	}
-
-	BYTE* Alloc(unsigned capacity)
-	{
-		assert(capacity > 0);
-		if (capacity < REUSING_CAPACITY)
-		{
-			if (!m_freeVector.empty())
-			{
-				BYTE* freeMem = m_freeVector.back();
-				m_freeVector.pop_back();
-
-				dbg_printf("lzo.reuse_alloc\t%p(%d) free\n", freeMem, capacity);
-				return freeMem;
-			}
-			BYTE* newMem = new BYTE[REUSING_CAPACITY];
-			dbg_printf("lzo.reuse_alloc\t%p(%d) real\n", newMem, capacity);
-			return newMem;
-		}
-		BYTE* newMem = new BYTE[capacity];
-		dbg_printf("lzo.real_alloc\t%p(%d)\n", newMem, capacity);
-		return newMem;
-	}
-
-	void Free(BYTE* ptr, unsigned capacity)
-	{
-		assert(ptr != NULL);
-		assert(capacity > 0);
-		if (capacity < REUSING_CAPACITY)
-		{
-			dbg_printf("lzo.reuse_free\t%p(%d)\n", ptr, capacity);
-			m_freeVector.push_back(ptr);
-			return;
-		}
-
-		dbg_printf("lzo.real_free\t%p(%d)\n", ptr, capacity);
-		delete[] ptr;
-	}
-
-private:
-	std::vector<BYTE*> m_freeVector;
-
-} gs_freeMemMgr;
-
-DWORD CLZObject::ms_dwFourCC = MAKEFOURCC('M', 'C', 'O', 'Z');
-
-CLZObject::CLZObject()
-{
-	Initialize();
-}
-
-void CLZObject::Initialize()
-{
-	m_bInBuffer = false;
-	m_pbBuffer = NULL;
-	m_dwBufferSize = 0;
-
-	m_pHeader = NULL;
-	m_pbIn = NULL;
-	m_bCompressed = false;
-}
-
-void CLZObject::Clear()
-{
-	if (m_pbBuffer && !m_bInBuffer)
-		gs_freeMemMgr.Free(m_pbBuffer, m_dwBufferSize);
-
-	if (m_dwBufferSize > 0)
-	{
-		dbg_printf("lzo.free %d\n", m_dwBufferSize);
-	}
-
-	Initialize();
-}
-
-CLZObject::~CLZObject()
-{
-	Clear();
-}
-
-DWORD CLZObject::GetSize()
-{
-	assert(m_pHeader);
-
-	if (m_bCompressed)
-	{
-		if (m_pHeader->dwEncryptSize)
-			return sizeof(THeader) + sizeof(DWORD) + m_pHeader->dwEncryptSize;
-		else
-			return sizeof(THeader) + sizeof(DWORD) + m_pHeader->dwCompressedSize;
-	}
-	else
-		return m_pHeader->dwRealSize;
-}
-
-void CLZObject::BeginCompress(const void* pvIn, UINT uiInLen)
-{
-	m_pbIn = (const BYTE*)pvIn;
-
-	// sizeof(SHeader) +
-	// ¾ÏÈ£È­¸¦ À§ÇÑ fourCC 4¹ÙÀÌÆ®
-	// ¾ÐÃàµÈ ÈÄ ¸¸µé¾îÁú ¼ö ÀÖ´Â ÃÖ´ë ¿ë·® +
-	// ¾ÏÈ£È­¸¦ À§ÇÑ 8 ¹ÙÀÌÆ®
-	m_dwBufferSize = sizeof(THeader) + sizeof(DWORD) + (uiInLen + uiInLen / 64 + 16 + 3) + 8;
-
-	m_pbBuffer = gs_freeMemMgr.Alloc(m_dwBufferSize);
-	memset(m_pbBuffer, 0, m_dwBufferSize);
-
-	m_pHeader = (THeader*)m_pbBuffer;
-	m_pHeader->dwFourCC = ms_dwFourCC;
-	m_pHeader->dwEncryptSize = m_pHeader->dwCompressedSize = m_pHeader->dwRealSize = 0;
-	m_pHeader->dwRealSize = uiInLen;
-}
-
-void CLZObject::BeginCompressInBuffer(const void* pvIn, UINT uiInLen, void* /*pvOut*/)
-{
-	m_pbIn = (const BYTE*)pvIn;
-
-	// sizeof(SHeader) +
-	// ¾ÏÈ£È­¸¦ À§ÇÑ fourCC 4¹ÙÀÌÆ®
-	// ¾ÐÃàµÈ ÈÄ ¸¸µé¾îÁú ¼ö ÀÖ´Â ÃÖ´ë ¿ë·® +
-	// ¾ÏÈ£È­¸¦ À§ÇÑ 8 ¹ÙÀÌÆ®
-	m_dwBufferSize = sizeof(THeader) + sizeof(DWORD) + (uiInLen + uiInLen / 64 + 16 + 3) + 8;
-
-	m_pbBuffer = gs_freeMemMgr.Alloc(m_dwBufferSize);
-	memset(m_pbBuffer, 0, m_dwBufferSize);
-
-	m_pHeader = (THeader*)m_pbBuffer;
-	m_pHeader->dwFourCC = ms_dwFourCC;
-	m_pHeader->dwEncryptSize = m_pHeader->dwCompressedSize = m_pHeader->dwRealSize = 0;
-	m_pHeader->dwRealSize = uiInLen;
-	m_bInBuffer = true;
-}
-
-bool CLZObject::Compress()
-{
-	UINT iOutLen;
-	BYTE* pbBuffer;
-
-	pbBuffer = m_pbBuffer + sizeof(THeader);
-	*(DWORD*)pbBuffer = ms_dwFourCC;
-	pbBuffer += sizeof(DWORD);
-
-#if defined(LZO1X_999_MEM_COMPRESS)
-	int r = lzo1x_999_compress((BYTE*)m_pbIn, m_pHeader->dwRealSize, pbBuffer, (lzo_uint*)&iOutLen, CLZO::Instance().GetWorkMemory());
-#else
-	int r = lzo1x_1_compress((BYTE*)m_pbIn, m_pHeader->dwRealSize, pbBuffer, (lzo_uint*)&iOutLen, CLZO::Instance().GetWorkMemory());
-#endif
-
-	if (LZO_E_OK != r)
-	{
-		TraceError("LZO: lzo1x_999_compress failed");
-		return false;
-	}
-
-	m_pHeader->dwCompressedSize = iOutLen;
-	m_bCompressed = true;
-	return true;
-}
-
-bool CLZObject::BeginDecompress(const void* pvIn)
-{
-	THeader* pHeader = (THeader*)pvIn;
-
-	if (pHeader->dwFourCC != ms_dwFourCC)
-	{
-		TraceError("LZObject: not a valid data");
-		return false;
-	}
-
-	m_pHeader = pHeader;
-	m_pbIn = (const BYTE*)pvIn + (sizeof(THeader) + sizeof(DWORD));
-
-	/*
-	static unsigned sum = 0;
-	static unsigned count = 0;
-	sum += pHeader->dwRealSize;
-	count++;
-	printf("decompress cur: %d, ave: %d\n", pHeader->dwRealSize, sum / count);
-	*/
-	m_dwBufferSize = pHeader->dwRealSize;
-	m_pbBuffer = gs_freeMemMgr.Alloc(m_dwBufferSize);
-	memset(m_pbBuffer, 0, pHeader->dwRealSize);
-	return true;
-}
-
-class DecryptBuffer
-{
-public:
-	enum
-	{
-		LOCAL_BUF_SIZE = 8 * 1024,
-	};
-
-public:
-	DecryptBuffer(unsigned size)
-	{
-		static unsigned count = 0;
-		static unsigned sum = 0;
-		static unsigned maxSize = 0;
-
-		sum += size;
-		count++;
-
-		maxSize = max(size, maxSize);
-		if (size >= LOCAL_BUF_SIZE)
-		{
-			m_buf = new char[size];
-			dbg_printf("DecryptBuffer - AllocHeap %d max(%d) ave(%d)\n", size, maxSize / 1024, sum / count);
-		}
-		else
-		{
-			dbg_printf("DecryptBuffer - AllocStack %d max(%d) ave(%d)\n", size, maxSize / 1024, sum / count);
-			m_buf = m_local_buf;
-		}
-	}
-
-	~DecryptBuffer()
-	{
-		if (m_local_buf != m_buf)
-		{
-			dbg_printf("DecruptBuffer - FreeHeap\n");
-			delete[] m_buf;
-		}
-		else
-		{
-			dbg_printf("DecruptBuffer - FreeStack\n");
-		}
-	}
-
-	void* GetBufferPtr()
-	{
-		return m_buf;
-	}
-
-private:
-	char* m_buf;
-	char m_local_buf[LOCAL_BUF_SIZE];
-};
-
-bool CLZObject::Decompress(unsigned char key_type)
-{
-	UINT uiSize;
-	int r;
-
-	if (m_pHeader->dwEncryptSize)
-	{
-		DecryptBuffer buf(m_pHeader->dwEncryptSize);
-
-		BYTE* pbDecryptedBuffer = (BYTE*)buf.GetBufferPtr();
-
-		__Decrypt(key_type, pbDecryptedBuffer);
-
-		if (*(DWORD*)pbDecryptedBuffer != ms_dwFourCC)
-		{
-			TraceError("LZObject: key incorrect");
-			return false;
-		}
-
-		if (LZO_E_OK != (r = lzo1x_decompress(pbDecryptedBuffer + sizeof(DWORD), m_pHeader->dwCompressedSize, m_pbBuffer, (lzo_uint*)&uiSize, NULL)))
-		{
-			TraceError("LZObject: Decompress failed(decrypt) ret %d\n", r);
-			return false;
-		}
-	}
-	else
-	{
-		uiSize = m_pHeader->dwRealSize;
-
-		//if (LZO_E_OK != (r = lzo1x_decompress_safe(m_pbIn, m_pHeader->dwCompressedSize, m_pbBuffer, (lzo_uint*)&uiSize, NULL)))
-		if (LZO_E_OK != (r = lzo1x_decompress(m_pbIn, m_pHeader->dwCompressedSize, m_pbBuffer, (lzo_uint*)&uiSize, NULL)))
-		{
-			TraceError("LZObject: Decompress failed : ret %d, CompressedSize %d\n", r, m_pHeader->dwCompressedSize);
-			return false;
-		}
-	}
-
-	if (uiSize != m_pHeader->dwRealSize)
-	{
-		TraceError("LZObject: Size differs");
-		return false;
-	}
-
-	return true;
-}
-
-bool CLZObject::Encrypt(unsigned char key_type)
-{
-	if (!m_bCompressed)
-	{
-		assert(!"not compressed yet");
-		return false;
-	}
-
-	BYTE* pbBuffer = m_pbBuffer + sizeof(THeader);
-	m_pHeader->dwEncryptSize = tea_encrypt((DWORD*)pbBuffer, (const DWORD*)pbBuffer, key_type, m_pHeader->dwCompressedSize + 19);
-	return true;
-}
-
-bool CLZObject::__Decrypt(unsigned char key_type, BYTE* pbData)
-{
-	assert(m_pbBuffer);
-
-	tea_decrypt((DWORD*)pbData, (const DWORD*)(m_pbIn - sizeof(DWORD)), key_type, m_pHeader->dwEncryptSize);
-	return true;
-}
-
-void CLZObject::AllocBuffer(DWORD dwSrcSize)
-{
-	if (m_pbBuffer && !m_bInBuffer)
-		gs_freeMemMgr.Free(m_pbBuffer, m_dwBufferSize);
-
-	m_pbBuffer = gs_freeMemMgr.Alloc(dwSrcSize);
-	m_dwBufferSize = dwSrcSize;
-}
-
-/*
-void CLZObject::CopyBuffer(const char* pbSrc, DWORD dwSrcSize)
-{
-	AllocBuffer(dwSrcSize);
-	memcpy(m_pbBuffer, pbSrc, dwSrcSize);
-}
-*/
-
-CLZO::CLZO() : m_pWorkMem(NULL)
-{
-	if (lzo_init() != LZO_E_OK)
-	{
-		TraceError("LZO: cannot initialize");
-		return;
-	}
-
-#if defined(LZO1X_999_MEM_COMPRESS)
-	m_pWorkMem = (BYTE*)malloc(LZO1X_999_MEM_COMPRESS);
-#else
-	m_pWorkMem = (BYTE*)malloc(LZO1X_1_MEM_COMPRESS);
-#endif
-
-	if (NULL == m_pWorkMem)
-	{
-		TraceError("LZO: cannot alloc memory");
-		return;
-	}
-}
-
-CLZO::~CLZO()
-{
-	if (m_pWorkMem)
-	{
-		free(m_pWorkMem);
-		m_pWorkMem = NULL;
-	}
-}
-
-bool CLZO::CompressMemory(CLZObject& rObj, const void* pIn, UINT uiInLen)
-{
-	rObj.BeginCompress(pIn, uiInLen);
-	return rObj.Compress();
-}
-
-bool CLZO::CompressEncryptedMemory(CLZObject& rObj, const void* pIn, UINT uiInLen, unsigned char key_type)
-{
-	rObj.BeginCompress(pIn, uiInLen);
-
-	if (rObj.Compress())
-	{
-		if (rObj.Encrypt(key_type))
-			return true;
-
-		return false;
-	}
-
-	return false;
-}
-
-bool CLZO::Decompress(CLZObject& rObj, const BYTE* pbBuf, unsigned char key_type)
-{
-	if (!rObj.BeginDecompress(pbBuf))
-		return false;
-
-	if (!rObj.Decompress(key_type))
-		return false;
-
-	return true;
-}
-
-BYTE* CLZO::GetWorkMemory()
-{
-	return m_pWorkMem;
-}
+#include "StdAfx.h"
+#include <stdlib.h>
+#include <lzo/lzoLibLink.h>
+
+#include "debug.h"
+#include "lzo.h"
+
+#include "tea.h"
+
+#define dbg_printf
+
+static class LZOFreeMemoryMgr
+{
+public:
+	enum
+	{
+		REUSING_CAPACITY = 64 * 1024,
+	};
+
+public:
+	~LZOFreeMemoryMgr()
+	{
+		std::vector<BYTE*>::iterator i;
+		for (i = m_freeVector.begin(); i != m_freeVector.end(); ++i)
+			delete* i;
+
+		m_freeVector.clear();
+	}
+
+	BYTE* Alloc(unsigned capacity)
+	{
+		assert(capacity > 0);
+		if (capacity < REUSING_CAPACITY)
+		{
+			if (!m_freeVector.empty())
+			{
+				BYTE* freeMem = m_freeVector.back();
+				m_freeVector.pop_back();
+
+				dbg_printf("lzo.reuse_alloc\t%p(%d) free\n", freeMem, capacity);
+				return freeMem;
+			}
+			BYTE* newMem = new BYTE[REUSING_CAPACITY];
+			dbg_printf("lzo.reuse_alloc\t%p(%d) real\n", newMem, capacity);
+			return newMem;
+		}
+		BYTE* newMem = new BYTE[capacity];
+		dbg_printf("lzo.real_alloc\t%p(%d)\n", newMem, capacity);
+		return newMem;
+	}
+
+	void Free(BYTE* ptr, unsigned capacity)
+	{
+		assert(ptr != NULL);
+		assert(capacity > 0);
+		if (capacity < REUSING_CAPACITY)
+		{
+			dbg_printf("lzo.reuse_free\t%p(%d)\n", ptr, capacity);
+			m_freeVector.push_back(ptr);
+			return;
+		}
+
+		dbg_printf("lzo.real_free\t%p(%d)\n", ptr, capacity);
+		delete[] ptr;
+	}
+
+private:
+	std::vector<BYTE*> m_freeVector;
+
+} gs_freeMemMgr;
+
+DWORD CLZObject::ms_dwFourCC = MAKEFOURCC('N', 'C', 'O', 'Z');
+
+CLZObject::CLZObject()
+{
+	Initialize();
+}
+
+void CLZObject::Initialize()
+{
+	m_bInBuffer = false;
+	m_pbBuffer = NULL;
+	m_dwBufferSize = 0;
+
+	m_pHeader = NULL;
+	m_pbIn = NULL;
+	m_bCompressed = false;
+}
+
+void CLZObject::Clear()
+{
+	if (m_pbBuffer && !m_bInBuffer)
+		gs_freeMemMgr.Free(m_pbBuffer, m_dwBufferSize);
+
+	if (m_dwBufferSize > 0)
+	{
+		dbg_printf("lzo.free %d\n", m_dwBufferSize);
+	}
+
+	Initialize();
+}
+
+CLZObject::~CLZObject()
+{
+	Clear();
+}
+
+DWORD CLZObject::GetSize()
+{
+	assert(m_pHeader);
+
+	if (m_bCompressed)
+	{
+		if (m_pHeader->dwEncryptSize)
+			return sizeof(THeader) + sizeof(DWORD) + m_pHeader->dwEncryptSize;
+		else
+			return sizeof(THeader) + sizeof(DWORD) + m_pHeader->dwCompressedSize;
+	}
+	else
+		return m_pHeader->dwRealSize;
+}
+
+void CLZObject::BeginCompress(const void* pvIn, UINT uiInLen)
+{
+	m_pbIn = (const BYTE*)pvIn;
+
+	// sizeof(SHeader) +
+	// È£È­  fourCC 4Æ®
+	//     Ö´ Ö´ ë·® +
+	// È£È­  8 Æ®
+	m_dwBufferSize = sizeof(THeader) + sizeof(DWORD) + (uiInLen + uiInLen / 64 + 16 + 3) + 8;
+
+	m_pbBuffer = gs_freeMemMgr.Alloc(m_dwBufferSize);
+	memset(m_pbBuffer, 0, m_dwBufferSize);
+
+	m_pHeader = (THeader*)m_pbBuffer;
+	m_pHeader->dwFourCC = ms_dwFourCC;
+	m_pHeader->dwEncryptSize = m_pHeader->dwCompressedSize = m_pHeader->dwRealSize = 0;
+	m_pHeader->dwRealSize = uiInLen;
+}
+
+void CLZObject::BeginCompressInBuffer(const void* pvIn, UINT uiInLen, void* /*pvOut*/)
+{
+	m_pbIn = (const BYTE*)pvIn;
+
+	// sizeof(SHeader) +
+	// È£È­  fourCC 4Æ®
+	//     Ö´ Ö´ ë·® +
+	// È£È­  8 Æ®
+	m_dwBufferSize = sizeof(THeader) + sizeof(DWORD) + (uiInLen + uiInLen / 64 + 16 + 3) + 8;
+
+	m_pbBuffer = gs_freeMemMgr.Alloc(m_dwBufferSize);
+	memset(m_pbBuffer, 0, m_dwBufferSize);
+
+	m_pHeader = (THeader*)m_pbBuffer;
+	m_pHeader->dwFourCC = ms_dwFourCC;
+	m_pHeader->dwEncryptSize = m_pHeader->dwCompressedSize = m_pHeader->dwRealSize = 0;
+	m_pHeader->dwRealSize = uiInLen;
+	m_bInBuffer = true;
+}
+
+bool CLZObject::Compress()
+{
+	UINT iOutLen;
+	BYTE* pbBuffer;
+
+	pbBuffer = m_pbBuffer + sizeof(THeader);
+	*(DWORD*)pbBuffer = ms_dwFourCC;
+	pbBuffer += sizeof(DWORD);
+
+#if defined(LZO1X_999_MEM_COMPRESS)
+	int r = lzo1x_999_compress((BYTE*)m_pbIn, m_pHeader->dwRealSize, pbBuffer, (lzo_uint*)&iOutLen, CLZO::Instance().GetWorkMemory());
+#else
+	int r = lzo1x_1_compress((BYTE*)m_pbIn, m_pHeader->dwRealSize, pbBuffer, (lzo_uint*)&iOutLen, CLZO::Instance().GetWorkMemory());
+#endif
+
+	if (LZO_E_OK != r)
+	{
+		TraceError("LZO: lzo1x_999_compress failed");
+		return false;
+	}
+
+	m_pHeader->dwCompressedSize = iOutLen;
+	m_bCompressed = true;
+	return true;
+}
+
+bool CLZObject::BeginDecompress(const void* pvIn)
+{
+	THeader* pHeader = (THeader*)pvIn;
+
+	if (pHeader->dwFourCC != ms_dwFourCC)
+	{
+		TraceError("LZObject: not a valid data");
+		return false;
+	}
+
+	m_pHeader = pHeader;
+	m_pbIn = (const BYTE*)pvIn + (sizeof(THeader) + sizeof(DWORD));
+
+	/*
+	static unsigned sum = 0;
+	static unsigned count = 0;
+	sum += pHeader->dwRealSize;
+	count++;
+	printf("decompress cur: %d, ave: %d\n", pHeader->dwRealSize, sum / count);
+	*/
+	m_dwBufferSize = pHeader->dwRealSize;
+	m_pbBuffer = gs_freeMemMgr.Alloc(m_dwBufferSize);
+	memset(m_pbBuffer, 0, pHeader->dwRealSize);
+	return true;
+}
+
+class DecryptBuffer
+{
+public:
+	enum
+	{
+		LOCAL_BUF_SIZE = 8 * 1024,
+	};
+
+public:
+	DecryptBuffer(unsigned size)
+	{
+		static unsigned count = 0;
+		static unsigned sum = 0;
+		static unsigned maxSize = 0;
+
+		sum += size;
+		count++;
+
+		maxSize = max(size, maxSize);
+		if (size >= LOCAL_BUF_SIZE)
+		{
+			m_buf = new char[size];
+			dbg_printf("DecryptBuffer - AllocHeap %d max(%d) ave(%d)\n", size, maxSize / 1024, sum / count);
+		}
+		else
+		{
+			dbg_printf("DecryptBuffer - AllocStack %d max(%d) ave(%d)\n", size, maxSize / 1024, sum / count);
+			m_buf = m_local_buf;
+		}
+	}
+
+	~DecryptBuffer()
+	{
+		if (m_local_buf != m_buf)
+		{
+			dbg_printf("DecruptBuffer - FreeHeap\n");
+			delete[] m_buf;
+		}
+		else
+		{
+			dbg_printf("DecruptBuffer - FreeStack\n");
+		}
+	}
+
+	void* GetBufferPtr()
+	{
+		return m_buf;
+	}
+
+private:
+	char* m_buf;
+	char m_local_buf[LOCAL_BUF_SIZE];
+};
+
+bool CLZObject::Decompress(unsigned char key_type)
+{
+	UINT uiSize;
+	int r;
+
+	if (m_pHeader->dwEncryptSize)
+	{
+		DecryptBuffer buf(m_pHeader->dwEncryptSize);
+
+		BYTE* pbDecryptedBuffer = (BYTE*)buf.GetBufferPtr();
+
+		__Decrypt(key_type, pbDecryptedBuffer);
+
+		if (*(DWORD*)pbDecryptedBuffer != ms_dwFourCC)
+		{
+			TraceError("LZObject: key incorrect");
+			return false;
+		}
+
+		if (LZO_E_OK != (r = lzo1x_decompress(pbDecryptedBuffer + sizeof(DWORD), m_pHeader->dwCompressedSize, m_pbBuffer, (lzo_uint*)&uiSize, NULL)))
+		{
+			TraceError("LZObject: Decompress failed(decrypt) ret %d\n", r);
+			return false;
+		}
+	}
+	else
+	{
+		uiSize = m_pHeader->dwRealSize;
+
+		//if (LZO_E_OK != (r = lzo1x_decompress_safe(m_pbIn, m_pHeader->dwCompressedSize, m_pbBuffer, (lzo_uint*)&uiSize, NULL)))
+		if (LZO_E_OK != (r = lzo1x_decompress(m_pbIn, m_pHeader->dwCompressedSize, m_pbBuffer, (lzo_uint*)&uiSize, NULL)))
+		{
+			TraceError("LZObject: Decompress failed : ret %d, CompressedSize %d\n", r, m_pHeader->dwCompressedSize);
+			return false;
+		}
+	}
+
+	if (uiSize != m_pHeader->dwRealSize)
+	{
+		TraceError("LZObject: Size differs");
+		return false;
+	}
+
+	return true;
+}
+
+bool CLZObject::Encrypt(unsigned char key_type)
+{
+	if (!m_bCompressed)
+	{
+		assert(!"not compressed yet");
+		return false;
+	}
+
+	BYTE* pbBuffer = m_pbBuffer + sizeof(THeader);
+	m_pHeader->dwEncryptSize = tea_encrypt((DWORD*)pbBuffer, (const DWORD*)pbBuffer, key_type, m_pHeader->dwCompressedSize + 19);
+	return true;
+}
+
+bool CLZObject::__Decrypt(unsigned char key_type, BYTE* pbData)
+{
+	assert(m_pbBuffer);
+
+	tea_decrypt((DWORD*)pbData, (const DWORD*)(m_pbIn - sizeof(DWORD)), key_type, m_pHeader->dwEncryptSize);
+	return true;
+}
+
+void CLZObject::AllocBuffer(DWORD dwSrcSize)
+{
+	if (m_pbBuffer && !m_bInBuffer)
+		gs_freeMemMgr.Free(m_pbBuffer, m_dwBufferSize);
+
+	m_pbBuffer = gs_freeMemMgr.Alloc(dwSrcSize);
+	m_dwBufferSize = dwSrcSize;
+}
+
+/*
+void CLZObject::CopyBuffer(const char* pbSrc, DWORD dwSrcSize)
+{
+	AllocBuffer(dwSrcSize);
+	memcpy(m_pbBuffer, pbSrc, dwSrcSize);
+}
+*/
+
+CLZO::CLZO() : m_pWorkMem(NULL)
+{
+	if (lzo_init() != LZO_E_OK)
+	{
+		TraceError("LZO: cannot initialize");
+		return;
+	}
+
+#if defined(LZO1X_999_MEM_COMPRESS)
+	m_pWorkMem = (BYTE*)malloc(LZO1X_999_MEM_COMPRESS);
+#else
+	m_pWorkMem = (BYTE*)malloc(LZO1X_1_MEM_COMPRESS);
+#endif
+
+	if (NULL == m_pWorkMem)
+	{
+		TraceError("LZO: cannot alloc memory");
+		return;
+	}
+}
+
+CLZO::~CLZO()
+{
+	if (m_pWorkMem)
+	{
+		free(m_pWorkMem);
+		m_pWorkMem = NULL;
+	}
+}
+
+bool CLZO::CompressMemory(CLZObject& rObj, const void* pIn, UINT uiInLen)
+{
+	rObj.BeginCompress(pIn, uiInLen);
+	return rObj.Compress();
+}
+
+bool CLZO::CompressEncryptedMemory(CLZObject& rObj, const void* pIn, UINT uiInLen, unsigned char key_type)
+{
+	rObj.BeginCompress(pIn, uiInLen);
+
+	if (rObj.Compress())
+	{
+		if (rObj.Encrypt(key_type))
+			return true;
+
+		return false;
+	}
+
+	return false;
+}
+
+bool CLZO::Decompress(CLZObject& rObj, const BYTE* pbBuf, unsigned char key_type)
+{
+	if (!rObj.BeginDecompress(pbBuf))
+		return false;
+
+	if (!rObj.Decompress(key_type))
+		return false;
+
+	return true;
+}
+
+BYTE* CLZO::GetWorkMemory()
+{
+	return m_pWorkMem;
+}
diff --git a/src-client/Client/EterGrnLib/ThingInstance.cpp b/src-client/Client/EterGrnLib/ThingInstance.cpp
index 83fced5..97468c6 100644
--- a/src-client/Client/EterGrnLib/ThingInstance.cpp
+++ b/src-client/Client/EterGrnLib/ThingInstance.cpp
@@ -1,1101 +1,1105 @@
-#include "StdAfx.h"
-
-#include "../EterBase/Debug.h"
-
-#include "../EterLib/Camera.h"
-#include "../EterBase/Timer.h"
-
-#include "../GameLib/GameType.h"
-#include "../GameLib/RaceData.h"
-
-#include "ThingInstance.h"
-#include "Thing.h"
-#include "ModelInstance.h"
-
-CDynamicPool<CGraphicThingInstance> CGraphicThingInstance::ms_kPool;
-
-CGraphicThing* CGraphicThingInstance::GetBaseThingPtr()
-{
-	if (m_modelThingSetVector.empty())
-		return nullptr;
-
-	TModelThingSet& rkModelThingSet = m_modelThingSetVector[0];
-	if (rkModelThingSet.m_pLODThingRefVector.empty())
-		return nullptr;
-
-	std::unique_ptr<CGraphicThing::TRef>& proThing = rkModelThingSet.m_pLODThingRefVector[0];
-	if (!proThing)
-		return nullptr;
-
-	CGraphicThing::TRef roThing = *proThing;
-	return roThing.GetPointer();
-}
-
-bool CGraphicThingInstance::LessRenderOrder(CGraphicThingInstance* pkThingInst)
-{
-	return (GetBaseThingPtr() < pkThingInst->GetBaseThingPtr());
-}
-
-void CGraphicThingInstance::CreateSystem(UINT uCapacity)
-{
-	ms_kPool.Create(uCapacity);
-}
-
-void CGraphicThingInstance::DestroySystem()
-{
-	ms_kPool.Destroy();
-}
-
-CGraphicThingInstance* CGraphicThingInstance::New()
-{
-	return ms_kPool.Alloc();
-}
-
-void CGraphicThingInstance::Delete(CGraphicThingInstance* pkThingInst)
-{
-	pkThingInst->Clear();
-	ms_kPool.Free(pkThingInst);
-}
-
-void CGraphicThingInstance::SetMotionAtEnd()
-{
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->SetMotionAtEnd();
-		}
-	);
-}
-
-bool CGraphicThingInstance::Picking(const D3DXVECTOR3& v, const D3DXVECTOR3& dir, float& out_x, float& out_y)
-{
-	if (!m_pHeightAttributeInstance)
-		return false;
-	return m_pHeightAttributeInstance->Picking(v, dir, out_x, out_y);
-}
-
-void CGraphicThingInstance::OnUpdateCollisionData(const CStaticCollisionDataVector* pscdVector)
-{
-	assert(pscdVector);
-	for (const CStaticCollisionData& it : *pscdVector)
-		AddCollision(&it, &GetTransform());
-}
-
-void CGraphicThingInstance::OnUpdateHeighInstance(CAttributeInstance* pAttributeInstance)
-{
-	assert(pAttributeInstance);
-	SetHeightInstance(pAttributeInstance);
-}
-
-bool CGraphicThingInstance::OnGetObjectHeight(float fX, float fY, float* pfHeight)
-{
-	return m_pHeightAttributeInstance && m_pHeightAttributeInstance->GetHeight(fX, fY, pfHeight);
-}
-
-void CGraphicThingInstance::BuildBoundingSphere()
-{
-	D3DXVECTOR3 v3Min, v3Max;
-	GetBoundBox(0, &v3Min, &v3Max);
-	m_v3Center = (v3Min + v3Max) * 0.5f;
-	D3DXVECTOR3 vDelta = (v3Max - v3Min);
-
-	m_fRadius = D3DXVec3Length(&vDelta) * 0.5f + 50.0f; // extra length for attached objects
-}
-
-bool CGraphicThingInstance::GetBoundingSphere(D3DXVECTOR3& v3Center, float& fRadius)
-{
-	if (m_fRadius <= 0)
-	{
-		BuildBoundingSphere();
-
-		fRadius = m_fRadius;
-		v3Center = m_v3Center;
-	}
-	else
-	{
-		fRadius = m_fRadius;
-		v3Center = m_v3Center;
-	}
-
-	D3DXVec3TransformCoord(&v3Center, &v3Center, &GetTransform());
-	return true;
-}
-
-void CGraphicThingInstance::BuildBoundingAABB()
-{
-	D3DXVECTOR3 v3Min, v3Max;
-	GetBoundBox(0, &v3Min, &v3Max);
-	m_v3Center = (v3Min + v3Max) * 0.5f;
-	m_v3Min = v3Min;
-	m_v3Max = v3Max;
-}
-
-bool CGraphicThingInstance::GetBoundingAABB(D3DXVECTOR3& v3Min, D3DXVECTOR3& v3Max)
-{
-	BuildBoundingAABB();
-
-	v3Min = m_v3Min;
-	v3Max = m_v3Max;
-
-	D3DXVec3TransformCoord(&m_v3Center, &m_v3Center, &GetTransform());
-	return true;
-}
-
-void CGraphicThingInstance::CalculateBBox()
-{
-	GetBoundBox(&m_v3BBoxMin, &m_v3BBoxMax);
-
-	m_v4TBBox[0] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMin.y, m_v3BBoxMin.z, 1.0f);
-	m_v4TBBox[1] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMax.y, m_v3BBoxMin.z, 1.0f);
-	m_v4TBBox[2] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMin.y, m_v3BBoxMin.z, 1.0f);
-	m_v4TBBox[3] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMax.y, m_v3BBoxMin.z, 1.0f);
-	m_v4TBBox[4] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMin.y, m_v3BBoxMax.z, 1.0f);
-	m_v4TBBox[5] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMax.y, m_v3BBoxMax.z, 1.0f);
-	m_v4TBBox[6] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMin.y, m_v3BBoxMax.z, 1.0f);
-	m_v4TBBox[7] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMax.y, m_v3BBoxMax.z, 1.0f);
-
-	const D3DXMATRIX& c_rmatTransform = GetTransform();
-
-	for (DWORD i = 0; i < 8; ++i)
-	{
-		D3DXVec4Transform(&m_v4TBBox[i], &m_v4TBBox[i], &c_rmatTransform);
-		if (0 == i)
-		{
-			m_v3TBBoxMin.x = m_v4TBBox[i].x;
-			m_v3TBBoxMin.y = m_v4TBBox[i].y;
-			m_v3TBBoxMin.z = m_v4TBBox[i].z;
-			m_v3TBBoxMax.x = m_v4TBBox[i].x;
-			m_v3TBBoxMax.y = m_v4TBBox[i].y;
-			m_v3TBBoxMax.z = m_v4TBBox[i].z;
-		}
-		else
-		{
-			if (m_v3TBBoxMin.x > m_v4TBBox[i].x)
-				m_v3TBBoxMin.x = m_v4TBBox[i].x;
-			if (m_v3TBBoxMax.x < m_v4TBBox[i].x)
-				m_v3TBBoxMax.x = m_v4TBBox[i].x;
-			if (m_v3TBBoxMin.y > m_v4TBBox[i].y)
-				m_v3TBBoxMin.y = m_v4TBBox[i].y;
-			if (m_v3TBBoxMax.y < m_v4TBBox[i].y)
-				m_v3TBBoxMax.y = m_v4TBBox[i].y;
-			if (m_v3TBBoxMin.z > m_v4TBBox[i].z)
-				m_v3TBBoxMin.z = m_v4TBBox[i].z;
-			if (m_v3TBBoxMax.z < m_v4TBBox[i].z)
-				m_v3TBBoxMax.z = m_v4TBBox[i].z;
-		}
-	}
-}
-
-bool CGraphicThingInstance::CreateDeviceObjects()
-{
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->CreateDeviceObjects();
-		});
-	return true;
-}
-
-void CGraphicThingInstance::DestroyDeviceObjects()
-{
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->DestroyDeviceObjects();
-		});
-}
-
-bool CGraphicThingInstance::CheckModelInstanceIndex(int iModelInstance)
-{
-	if (iModelInstance < 0)
-		return false;
-
-	return iModelInstance < m_LODControllerVector.size();
-}
-
-bool CGraphicThingInstance::CheckModelThingIndex(int iModelThing)
-{
-	if (iModelThing < 0)
-		return false;
-
-	return iModelThing < m_modelThingSetVector.size();
-}
-
-bool CGraphicThingInstance::CheckMotionThingIndex(DWORD dwMotionKey)
-{
-	MotionThingMap::iterator itor = m_roMotionThingMap.find(dwMotionKey);
-	return m_roMotionThingMap.end() != itor;
-}
-
-bool CGraphicThingInstance::GetMotionThingPointer(DWORD dwKey, CGraphicThing** ppMotion)
-{
-	if (!CheckMotionThingIndex(dwKey))
-		return false;
-
-	*ppMotion = m_roMotionThingMap[dwKey]->GetPointer();
-	return true;
-}
-
-bool CGraphicThingInstance::IsMotionThing()
-{
-	return !m_roMotionThingMap.empty();
-}
-
-void CGraphicThingInstance::ReserveModelInstance(int iCount)
-{
-	m_LODControllerVector.clear();
-	m_LODControllerVector.resize(iCount);
-	for (std::unique_ptr<CGrannyLODController>& rkController : m_LODControllerVector)
-		rkController = std::make_unique<CGrannyLODController>();
-}
-
-void CGraphicThingInstance::ReserveModelThing(int iCount)
-{
-	m_modelThingSetVector.resize(iCount);
-}
-
-bool CGraphicThingInstance::FindBoneIndex(int iModelInstance, const char* c_szBoneName, int* iRetBone)
-{
-	assert(CheckModelInstanceIndex(iModelInstance));
-
-	CGrannyModelInstance* pModelInstance = m_LODControllerVector[iModelInstance]->GetModelInstance();
-
-	if (!pModelInstance)
-		return false;
-
-	return pModelInstance->GetBoneIndexByName(c_szBoneName, iRetBone);
-}
-
-void CGraphicThingInstance::AttachModelInstance(int iDstModelInstance, const char* c_szBoneName, int iSrcModelInstance)
-{
-	if (!CheckModelInstanceIndex(iSrcModelInstance))
-	{
-		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, c_szBoneName=%s, iSrcModelInstance=%d)", iDstModelInstance, c_szBoneName, iSrcModelInstance);
-		return;
-	}
-	if (!CheckModelInstanceIndex(iDstModelInstance))
-	{
-		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, c_szBoneName=%s, iSrcModelInstance=%d)", iDstModelInstance, c_szBoneName, iSrcModelInstance);
-		return;
-	}
-
-	CGrannyLODController* pSrcLODController = m_LODControllerVector[iSrcModelInstance].get();
-	CGrannyLODController* pDstLODController = m_LODControllerVector[iDstModelInstance].get();
-	pDstLODController->AttachModelInstance(pSrcLODController, c_szBoneName);
-}
-
-void CGraphicThingInstance::AttachModelInstance(int iDstModelInstance, const char* c_szBoneName, CGraphicThingInstance& rSrcInstance, int iSrcModelInstance)
-{
-	if (!CheckModelInstanceIndex(iDstModelInstance))
-	{
-		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, c_szBoneName=%s, iSrcModelInstance=%d)", iDstModelInstance, c_szBoneName, iSrcModelInstance);
-		return;
-	}
-	if (!rSrcInstance.CheckModelInstanceIndex(iSrcModelInstance))
-	{
-		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, c_szBoneName=%s, iSrcModelInstance=%d)", iDstModelInstance, c_szBoneName, iSrcModelInstance);
-		return;
-	}
-
-	CGrannyLODController* pDstLODController = m_LODControllerVector[iDstModelInstance].get();
-	CGrannyLODController* pSrcLODController = rSrcInstance.m_LODControllerVector[iSrcModelInstance].get();
-	pDstLODController->AttachModelInstance(pSrcLODController, c_szBoneName);
-}
-
-void CGraphicThingInstance::DetachModelInstance(int iDstModelInstance, CGraphicThingInstance& rSrcInstance, int iSrcModelInstance)
-{
-	if (!CheckModelInstanceIndex(iDstModelInstance))
-	{
-		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, iSrcModelInstance=%d)", iDstModelInstance, iSrcModelInstance);
-		return;
-	}
-	if (!rSrcInstance.CheckModelInstanceIndex(iSrcModelInstance))
-	{
-		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, iSrcModelInstance=%d)", iDstModelInstance, iSrcModelInstance);
-		return;
-	}
-
-	CGrannyLODController* pDstLODController = m_LODControllerVector[iDstModelInstance].get();
-	CGrannyLODController* pSrcLODController = rSrcInstance.m_LODControllerVector[iSrcModelInstance].get();
-	pDstLODController->DetachModelInstance(pSrcLODController);
-}
-
-bool CGraphicThingInstance::GetBonePosition(int iModelIndex, int iBoneIndex, float* pfx, float* pfy, float* pfz)
-{
-	assert(CheckModelInstanceIndex(iModelIndex));
-
-	CGrannyModelInstance* pModelInstance = m_LODControllerVector[iModelIndex]->GetModelInstance();
-
-	if (!pModelInstance)
-		return false;
-
-	const float* pfMatrix = pModelInstance->GetBoneMatrixPointer(iBoneIndex);
-
-	*pfx = pfMatrix[12];
-	*pfy = pfMatrix[13];
-	*pfz = pfMatrix[14];
-	return true;
-}
-
-// iSkelInstance °¡ ÀÖÀ¸¸é ±âº» º»¿¡ Link(º»ÀÌ ºÙ´Â°Í)½ÃÅ°°í,
-// ¾øÀ¸¸é ±âº» º»¿¡ attach(ÁÂÇ¥¸¸ °¡Á®´Ù ¾²´Â°Í) µË´Ï´Ù.
-bool CGraphicThingInstance::SetModelInstance(int iDstModelInstance, int iSrcModelThing, int iSrcModel, int iSkelInstance)
-{
-	if (!CheckModelInstanceIndex(iDstModelInstance))
-	{
-		TraceError("CGraphicThingInstance::SetModelInstance(iDstModelInstance=%d, pModelThing=%d, iSrcModel=%d)\n", iDstModelInstance, iSrcModelThing, iSrcModel);
-		return false;
-	}
-	if (!CheckModelThingIndex(iSrcModelThing))
-	{
-		TraceError("CGraphicThingInstance::SetModelInstance(iDstModelInstance=%d, pModelThing=%d, iSrcModel=%d)\n", iDstModelInstance, iSrcModelThing, iSrcModel);
-		return false;
-	}
-
-	CGrannyLODController* pController = m_LODControllerVector[iDstModelInstance].get();
-	if (!pController)
-		return false;
-
-	// HAIR_LINK
-	CGrannyLODController* pSkelController = nullptr;
-	if (iSkelInstance != DONTUSEVALUE)
-	{
-		if (!CheckModelInstanceIndex(iSkelInstance))
-		{
-			TraceError("CGraphicThingInstance::SetModelInstanceByOtherSkeletonInstance(iSkelInstance=%d, iDstModelInstance=%d, pModelThing=%d, iSrcModel=%d)\n", iSkelInstance, iDstModelInstance, iSrcModelThing, iSrcModel);
-			return false;
-		}
-		pSkelController = m_LODControllerVector[iSkelInstance].get();
-		if (!pSkelController)
-			return false;
-	}
-	// END_OF_HAIR_LINK
-
-	TModelThingSet& rModelThingSet = m_modelThingSetVector[iSrcModelThing];
-
-	pController->Clear();
-
-	for (std::unique_ptr<CGraphicThing::TRef>& it : rModelThingSet.m_pLODThingRefVector)
-	{
-		if (it->IsNull())
-			return false;
-
-		pController->AddModel(it->GetPointer(), iSrcModel, pSkelController);
-	}
-	return true;
-}
-
-void CGraphicThingInstance::SetMaterialImagePointer(UINT ePart, const char* c_szImageName, CGraphicImage* pImage)
-{
-	if (ePart >= m_LODControllerVector.size())
-	{
-		TraceError("CGraphicThingInstance::SetMaterialImagePointer(ePart(%d)<uPartCount(%d), c_szImageName=%s, pImage=%s) - ePart OUT OF RANGE",
-			ePart, m_LODControllerVector.size(), c_szImageName, pImage->GetFileName());
-		return;
-	}
-
-	if (!m_LODControllerVector[ePart])
-	{
-		TraceError("CGraphicThingInstance::SetMaterialImagePointer(ePart(%d), c_szImageName=%s, pImage=%s) - ePart Data is nullptr",
-			ePart, m_LODControllerVector.size(), c_szImageName, pImage->GetFileName());
-		return;
-	}
-
-	m_LODControllerVector[ePart]->SetMaterialImagePointer(c_szImageName, pImage);
-}
-
-void CGraphicThingInstance::SetMaterialData(UINT ePart, const char* c_szImageName, SMaterialData kMaterialData)
-{
-	if (ePart >= m_LODControllerVector.size())
-	{
-		TraceError("CGraphicThingInstance::SetMaterialData(ePart(%d)<uPartCount(%d)) - ePart OUT OF RANGE",
-			ePart, m_LODControllerVector.size());
-		return;
-	}
-
-	if (!m_LODControllerVector[ePart])
-	{
-		TraceError("CGraphicThingInstance::SetMaterialData(ePart(%d)) - ePart Data is nullptr",
-			ePart, m_LODControllerVector.size());
-		return;
-	}
-
-	m_LODControllerVector[ePart]->SetMaterialData(c_szImageName, kMaterialData);
-}
-
-void CGraphicThingInstance::SetSpecularInfo(UINT ePart, const char* c_szMtrlName, BOOL bEnable, float fPower)
-{
-	if (ePart >= m_LODControllerVector.size())
-	{
-		TraceError("CGraphicThingInstance::SetSpecularInfo(ePart(%d)<uPartCount(%d)) - ePart OUT OF RANGE",
-			ePart, m_LODControllerVector.size());
-		return;
-	}
-
-	if (!m_LODControllerVector[ePart])
-	{
-		TraceError("CGraphicThingInstance::SetSpecularInfo(ePart(%d)) - ePart Data is nullptr",
-			ePart, m_LODControllerVector.size());
-		return;
-	}
-
-	m_LODControllerVector[ePart]->SetSpecularInfo(c_szMtrlName, bEnable, fPower);
-}
-
-bool CGraphicThingInstance::SetMotion(DWORD dwMotionKey, float blendTime, int loopCount, float speedRatio)
-{
-	if (!CheckMotionThingIndex(dwMotionKey))
-		return false;
-
-	MotionThingMap::iterator itor = m_roMotionThingMap.find(dwMotionKey);
-	std::unique_ptr<CGraphicThing::TRef>& proMotionThing = itor->second;
-	CGraphicThing* pMotionThing = proMotionThing->GetPointer();
-
-	if (!pMotionThing)
-		return false;
-
-	if (!pMotionThing->CheckMotionIndex(0))
-		return false;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->SetMotionPointer(pMotionThing->GetMotionPointer(0), blendTime, loopCount, speedRatio);
-		});
-	return true;
-}
-
-bool CGraphicThingInstance::ChangeMotion(DWORD dwMotionKey, int loopCount, float speedRatio)
-{
-	if (!CheckMotionThingIndex(dwMotionKey))
-		return false;
-
-	MotionThingMap::iterator itor = m_roMotionThingMap.find(dwMotionKey);
-	std::unique_ptr<CGraphicThing::TRef>& proMotionThing = itor->second;
-	CGraphicThing* pMotionThing = proMotionThing->GetPointer();
-
-	if (!pMotionThing)
-		return false;
-
-	if (!pMotionThing->CheckMotionIndex(0))
-		return false;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->ChangeMotionPointer(pMotionThing->GetMotionPointer(0), loopCount, speedRatio);
-		});
-	return true;
-}
-
-void CGraphicThingInstance::SetEndStopMotion()
-{
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->SetMotionAtEnd();
-		}
-	);
-}
-
-void CGraphicThingInstance::RegisterModelThing(int iModelThing, CGraphicThing* pModelThing)
-{
-	if (!CheckModelThingIndex(iModelThing))
-	{
-		TraceError("CGraphicThingInstance::RegisterModelThing(iModelThing=%d, pModelThing=%s)\n", iModelThing, pModelThing->GetFileName());
-		return;
-	}
-
-	m_modelThingSetVector[iModelThing].Clear();
-
-	if (pModelThing)
-		RegisterLODThing(iModelThing, pModelThing);
-}
-
-void CGraphicThingInstance::RegisterLODThing(int iModelThing, CGraphicThing* pModelThing)
-{
-	assert(CheckModelThingIndex(iModelThing));
-	std::unique_ptr<CGraphicThing::TRef> pModelRef = std::make_unique<CGraphicThing::TRef>();
-	pModelRef->SetPointer(pModelThing);
-	m_modelThingSetVector[iModelThing].m_pLODThingRefVector.emplace_back(std::move(pModelRef));
-}
-
-void CGraphicThingInstance::RegisterMotionThing(DWORD dwMotionKey, CGraphicThing* pMotionThing)
-{
-	std::unique_ptr<CGraphicThing::TRef> pMotionRef = std::make_unique<CGraphicThing::TRef>();
-	pMotionRef->SetPointer(pMotionThing);
-	m_roMotionThingMap.emplace(dwMotionKey, std::move(pMotionRef));
-}
-
-void CGraphicThingInstance::ResetLocalTime()
-{
-	m_fLastLocalTime = 0.0f;
-	m_fLocalTime = 0.0f;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->ResetLocalTime();
-		});
-}
-
-/*
-void CGraphicThingInstance::SetMotionSpeed(float fRate)
-{
-	m_fMotionTimeSpeed = fRate;
-}
-*/
-
-void CGraphicThingInstance::InsertDelay(float fDelay)
-{
-	m_fDelay = fDelay;
-}
-
-float CGraphicThingInstance::GetLastLocalTime()
-{
-	return m_fLastLocalTime;
-}
-
-float CGraphicThingInstance::GetLocalTime()
-{
-	return m_fLocalTime;
-}
-
-float CGraphicThingInstance::GetSecondElapsed()
-{
-	return m_fSecondElapsed;
-}
-
-float CGraphicThingInstance::GetAverageSecondElapsed()
-{
-	return m_fAverageSecondElapsed;
-}
-
-bool CGraphicThingInstance::Intersect(float* pu, float* pv, float* pt)
-{
-	if (!CGraphicObjectInstance::isShow())
-		return false;
-
-	if (!m_bUpdated)
-		return false;
-
-	if (m_LODControllerVector.empty())
-	{
-		//TraceError("CGraphicThingInstance::Intersect - m_LODControllerVector is empty");
-		return false;
-	}
-
-	return m_LODControllerVector[0]->Intersect(&GetTransform(), pu, pv, pt);
-}
-
-void CGraphicThingInstance::GetBoundBox(D3DXVECTOR3* vtMin, D3DXVECTOR3* vtMax)
-{
-	vtMin->x = vtMin->y = vtMin->z = 100000.0f;
-	vtMax->x = vtMax->y = vtMax->z = -100000.0f;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->GetBoundBox(vtMin, vtMax);
-		});
-}
-
-BOOL CGraphicThingInstance::GetBoundBox(DWORD dwModelInstanceIndex, D3DXVECTOR3* vtMin, D3DXVECTOR3* vtMax)
-{
-	if (!CheckModelInstanceIndex(dwModelInstanceIndex))
-		return FALSE;
-
-	vtMin->x = vtMin->y = vtMin->z = 100000.0f;
-	vtMax->x = vtMax->y = vtMax->z = -100000.0f;
-
-	CGrannyLODController* pController = m_LODControllerVector[dwModelInstanceIndex].get();
-	if (!pController->isModelInstance())
-		return FALSE;
-
-	CGrannyModelInstance* pModelInstance = pController->GetModelInstance();
-	pModelInstance->GetBoundBox(vtMin, vtMax);
-	return TRUE;
-}
-
-BOOL CGraphicThingInstance::GetBoneMatrix(DWORD dwModelInstanceIndex, DWORD dwBoneIndex, D3DXMATRIX** ppMatrix)
-{
-	if (!CheckModelInstanceIndex(dwModelInstanceIndex))
-		return FALSE;
-
-	CGrannyModelInstance* pModelInstance = m_LODControllerVector[dwModelInstanceIndex]->GetModelInstance();
-	if (!pModelInstance)
-		return FALSE;
-
-	*ppMatrix = reinterpret_cast<D3DXMATRIX*>(pModelInstance->GetBoneMatrixPointer(dwBoneIndex));
-	if (!*ppMatrix)
-		return FALSE;
-
-	return TRUE;
-}
-
-BOOL CGraphicThingInstance::GetCompositeBoneMatrix(DWORD dwModelInstanceIndex, DWORD dwBoneIndex, D3DXMATRIX** ppMatrix)
-{
-	if (!CheckModelInstanceIndex(dwModelInstanceIndex))
-		return FALSE;
-
-	CGrannyModelInstance* pModelInstance = m_LODControllerVector[dwModelInstanceIndex]->GetModelInstance();
-	if (!pModelInstance)
-	{
-		//TraceError("CGraphicThingInstance::GetCompositeBoneMatrix(dwModelInstanceIndex=%d, dwBoneIndex=%d, D3DXMATRIX ** ppMatrix)", dwModelInstanceIndex, dwBoneIndex);
-		return FALSE;
-	}
-
-	*ppMatrix = reinterpret_cast<D3DXMATRIX*>(pModelInstance->GetCompositeBoneMatrixPointer(dwBoneIndex));
-
-	return TRUE;
-}
-
-void CGraphicThingInstance::UpdateTransform(D3DXMATRIX* pMatrix, float fSecondsElapsed, int iModelInstanceIndex)
-{
-	//TraceError("%s", GetBaseThingPtr()->GetFileName());
-	int nLODCount = m_LODControllerVector.size();
-	if (iModelInstanceIndex >= nLODCount)
-	{
-		/*
-		TraceError("void CGraphicThingInstance::UpdateTransform(pMatrix, fSecondsElapsed=%f, iModelInstanceIndex=%d/nLODCount=%d)",
-			fSecondsElapsed, iModelInstanceIndex, nLODCount);
-		*/
-		return;
-	}
-
-	CGrannyLODController* pkLODCtrl = m_LODControllerVector[iModelInstanceIndex].get();
-	if (!pkLODCtrl)
-	{
-		/*
-		TraceError("void CGraphicThingInstance::UpdateTransform(pMatrix, fSecondsElapsed=%f, iModelInstanceIndex=%d/nLODCount=%d) - m_LODControllerVector[iModelInstanceIndex] == nullptr",
-			fSecondsElapsed, iModelInstanceIndex, nLODCount);
-		*/
-		return;
-	}
-
-	CGrannyModelInstance* pModelInstance = pkLODCtrl->GetModelInstance();
-	if (!pModelInstance)
-	{
-		/*
-		TraceError("void CGraphicThingInstance::UpdateTransform(pMatrix, fSecondsElapsed=%f, iModelInstanceIndex=%d/nLODCount=%d) - pkLODCtrl->GetModelInstance() == nullptr",
-			fSecondsElapsed, iModelInstanceIndex, nLODCount);
-		*/
-		return;
-	}
-
-	pModelInstance->UpdateTransform(pMatrix, fSecondsElapsed);
-}
-
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-void CGraphicThingInstance::RecalcAccePositionMatrixFromBoneMatrix()
-{
-	if (m_LODControllerVector.empty())
-		return;
-
-	CGrannyModelInstance* pModelInstance = m_LODControllerVector[0]->GetModelInstance();
-	if (!pModelInstance)
-		return;
-
-	int iBoneIndex = 0;
-	pModelInstance->GetBoneIndexByName("Bip01 Spine2", &iBoneIndex);
-	const D3DXMATRIX* c_matBoneMatrix = (D3DXMATRIX*)pModelInstance->GetBoneMatrixPointer(iBoneIndex);
-	if (c_matBoneMatrix)
-	{
-		D3DXVECTOR3 v3ScaleCenter = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
-		float fAccePosX = c_matBoneMatrix->_41;
-		float fAccePosY = c_matBoneMatrix->_42;
-		float fAccePosZ = c_matBoneMatrix->_43;
-		D3DXMatrixIdentity(&m_matScale);
-		if (m_bAttachedAcceRace)
-		{
-			v3ScaleCenter.x = fAccePosX;
-			v3ScaleCenter.y = fAccePosY;
-		}
-		else
-		{
-			v3ScaleCenter.x = fAccePosX - 18.0f;
-			v3ScaleCenter.y = -40.0f;
-		}
-		v3ScaleCenter.z = fAccePosZ;
-		D3DXQUATERNION qRot = D3DXQUATERNION(0.0f, 0.0f, 0.0f, 0.0f);
-		D3DXMatrixTransformation(&m_matScale, &v3ScaleCenter, &qRot, &m_v3ScaleAcce, NULL, NULL, NULL);
-	}
-
-	D3DXMATRIX matTemp;
-	D3DXMatrixMultiply(&matTemp, &m_matScaleWorld, &m_matScale);
-	m_matAbsoluteTrans = matTemp * m_mRotation;
-	m_matAbsoluteTrans._41 += m_v3Position.x;
-	m_matAbsoluteTrans._42 += m_v3Position.y;
-	m_matAbsoluteTrans._43 += m_v3Position.z;
-}
-#endif
-
-void CGraphicThingInstance::DeformAll()
-{
-	m_bUpdated = true;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->DeformAll(&m_worldMatrix);
-		});
-}
-
-void CGraphicThingInstance::DeformNoSkin()
-{
-	m_bUpdated = true;
-
-	for (std::size_t i = 0; i != m_LODControllerVector.size(); i++)
-	{
-		CGrannyLODController* pkLOD = m_LODControllerVector[i].get();
-		if (pkLOD && pkLOD->isModelInstance())
-		{
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-			if (i == CRaceData::PART_ACCE)
-			{
-				RecalcAccePositionMatrixFromBoneMatrix();
-				pkLOD->DeformNoSkin(&m_matAbsoluteTrans);
-			}
-			else
-#endif
-				pkLOD->DeformNoSkin(&m_worldMatrix);
-		}
-	}
-}
-
-void CGraphicThingInstance::OnDeform()
-{
-	m_bUpdated = true;
-
-	for (std::size_t i = 0; i != m_LODControllerVector.size(); i++)
-	{
-		CGrannyLODController* pkLOD = m_LODControllerVector[i].get();
-		if (pkLOD && pkLOD->isModelInstance())
-		{
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-			if (i == CRaceData::PART_ACCE)
-			{
-				RecalcAccePositionMatrixFromBoneMatrix();
-				pkLOD->Deform(&m_matAbsoluteTrans);
-			}
-			else
-#endif
-				pkLOD->Deform(&m_worldMatrix);
-		}
-	}
-}
-
-void CGraphicThingInstance::__SetLocalTime(float fLocalTime)
-{
-	m_fLastLocalTime = m_fLocalTime;
-	m_fLocalTime = fLocalTime;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD)
-				pkLOD->SetLocalTime(fLocalTime);
-		});
-}
-
-void CGraphicThingInstance::UpdateLODLevel()
-{
-	CCamera* pCurCamera = CCameraManager::Instance().GetCurrentCamera();
-	if (!pCurCamera)
-	{
-		TraceError("CGraphicThingInstance::UpdateLODLevel - GetCurrentCamera() == nullptr");
-		return;
-	}
-
-	const D3DXVECTOR3& c_rv3TargetPosition = pCurCamera->GetTarget();
-	const D3DXVECTOR3& c_rv3CameraPosition = pCurCamera->GetEye();
-	const D3DXVECTOR3& c_v3Position = GetPosition();
-
-	// NOTE : Áß½ÉÀ¸·ÎºÎÅÍÀÇ °Å¸® °è»ê¿¡ z°ª Â÷ÀÌ´Â »ç¿ëÇÏÁö ¾Ê´Â´Ù. - [levites]
-	float fDistanceFromCenter = sqrtf((c_rv3TargetPosition.x - c_v3Position.x) * (c_rv3TargetPosition.x - c_v3Position.x) +
-		(c_rv3TargetPosition.y - c_v3Position.y) * (c_rv3TargetPosition.y - c_v3Position.y));
-	float fDistanceFromCamera = sqrtf((c_rv3CameraPosition.x - c_v3Position.x) * (c_rv3CameraPosition.x - c_v3Position.x) +
-		(c_rv3CameraPosition.y - c_v3Position.y) * (c_rv3CameraPosition.y - c_v3Position.y) +
-		(c_rv3CameraPosition.z - c_v3Position.z) * (c_rv3CameraPosition.z - c_v3Position.z));
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->UpdateLODLevel(fDistanceFromCenter, fDistanceFromCamera);
-		});
-}
-
-void CGraphicThingInstance::UpdateTime()
-{
-	m_fSecondElapsed = CTimer::Instance().GetElapsedSecond();
-
-	if (m_fDelay > m_fSecondElapsed)
-	{
-		m_fDelay -= m_fSecondElapsed;
-		m_fSecondElapsed = 0.0f;
-	}
-	else
-	{
-		m_fSecondElapsed -= m_fDelay;
-		m_fDelay = 0.0f;
-	}
-
-	m_fLastLocalTime = m_fLocalTime;
-	m_fLocalTime += m_fSecondElapsed;
-	m_fAverageSecondElapsed = m_fAverageSecondElapsed + (m_fSecondElapsed - m_fAverageSecondElapsed) / 4.0f;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->UpdateTime(m_fSecondElapsed);
-		});
-}
-
-void CGraphicThingInstance::OnUpdate()
-{
-#if defined(__PERFORMANCE_CHECKER__)
-	DWORD dwTime1 = timeGetTime();
-#endif
-	UpdateLODLevel();
-#if defined(__PERFORMANCE_CHECKER__)
-	DWORD dwTime2 = timeGetTime();
-#endif
-	UpdateTime();
-#if defined(__PERFORMANCE_CHECKER__)
-	DWORD dwLastTime = timeGetTime();
-	{
-		static FILE* pFile = fopen("perf_thing_onupdate.txt", "w");
-		if (dwLastTime - dwTime1 > 3)
-		{
-			fprintf(pFile, "GTU.Total %d (Time %f)\n", dwLastTime - dwTime1, ELTimer_GetMSec() / 1000.0f);
-			fprintf(pFile, "GTU.CAL %d\n", dwTime2 - dwTime1);
-			fprintf(pFile, "GTU.UP %d\n", dwLastTime - dwTime2);
-			fprintf(pFile, "-------------------------------- \n");
-			fflush(pFile);
-		}
-		fflush(pFile);
-	}
-#endif
-}
-
-void CGraphicThingInstance::OnRender()
-{
-	RenderWithOneTexture();
-}
-
-void CGraphicThingInstance::OnBlendRender()
-{
-	BlendRenderWithOneTexture();
-}
-
-void CGraphicThingInstance::RenderWithOneTexture()
-{
-	if (!m_bUpdated)
-		return;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->RenderWithOneTexture();
-		});
-}
-
-void CGraphicThingInstance::BlendRenderWithOneTexture()
-{
-	if (!m_bUpdated)
-		return;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->BlendRenderWithOneTexture();
-		});
-}
-
-void CGraphicThingInstance::RenderWithTwoTexture()
-{
-	if (!m_bUpdated)
-		return;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->RenderWithTwoTexture();
-		});
-}
-
-void CGraphicThingInstance::BlendRenderWithTwoTexture()
-{
-	if (!m_bUpdated)
-		return;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->BlendRenderWithTwoTexture();
-		});
-}
-
-void CGraphicThingInstance::OnRenderToShadowMap()
-{
-	if (!m_bUpdated)
-		return;
-
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->RenderToShadowMap();
-		});
-}
-
-void CGraphicThingInstance::OnRenderShadow()
-{
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->RenderShadow();
-		});
-}
-
-void CGraphicThingInstance::OnRenderPCBlocker()
-{
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->RenderWithOneTexture();
-		});
-}
-
-DWORD CGraphicThingInstance::GetLODControllerCount() const
-{
-	return m_LODControllerVector.size();
-}
-
-CGrannyLODController* CGraphicThingInstance::GetLODControllerPointer(DWORD dwModelIndex) const
-{
-	assert(dwModelIndex < m_LODControllerVector.size());
-	return m_LODControllerVector[dwModelIndex].get();
-}
-
-CGrannyLODController* CGraphicThingInstance::GetLODControllerPointer(DWORD dwModelIndex)
-{
-	assert(dwModelIndex < m_LODControllerVector.size());
-	return m_LODControllerVector[dwModelIndex].get();
-}
-
-BYTE CGraphicThingInstance::GetLODLevel(DWORD dwModelInstance)
-{
-	assert(dwModelInstance < m_LODControllerVector.size());
-	return (m_LODControllerVector[dwModelInstance]->GetLODLevel());
-}
-
-float CGraphicThingInstance::GetHeight(bool bScaleX)
-{
-	if (m_LODControllerVector.empty())
-		return 0.0f;
-
-	CGrannyModelInstance* pModelInstance = m_LODControllerVector[0]->GetModelInstance();
-	if (!pModelInstance)
-		return 0.0f;
-
-	D3DXVECTOR3 vtMin, vtMax, vtScale = GetScale();
-	pModelInstance->GetBoundBox(&vtMin, &vtMax);
-	if (bScaleX)
-		return vtScale.x * (vtMax.x - vtMin.x);
-
-	return vtScale.z * (vtMax.z - vtMin.z);
-}
-
-void CGraphicThingInstance::ReloadTexture()
-{
-	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
-		[&](std::unique_ptr<CGrannyLODController>& rkController)
-		{
-			CGrannyLODController* pkLOD = rkController.get();
-			if (pkLOD && pkLOD->isModelInstance())
-				pkLOD->ReloadTexture();
-		});
-}
-
-bool CGraphicThingInstance::HaveBlendThing()
-{
-	for (std::unique_ptr<CGrannyLODController>& it : m_LODControllerVector)
-	{
-		if (it->HaveBlendThing())
-			return true;
-	}
-	return false;
-}
-
-void CGraphicThingInstance::OnClear()
-{
-	m_LODControllerVector.clear();
-	m_roMotionThingMap.clear();
-
-	for (TModelThingSet& rkModelThing : m_modelThingSetVector)
-		rkModelThing.Clear();
-}
-
-void CGraphicThingInstance::OnInitialize()
-{
-	m_bUpdated = false;
-	m_fLastLocalTime = 0.0f;
-	m_fLocalTime = 0.0f;
-	m_fDelay = 0.0f;
-	m_fSecondElapsed = 0.0f;
-	m_fAverageSecondElapsed = 0.03f;
-	m_fRadius = -1.0f;
-	m_v3Center = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
-
-	ResetLocalTime();
-}
-
-CGraphicThingInstance::CGraphicThingInstance() :
-	m_bUpdated(false),
-	m_fLastLocalTime(0.0f),
-	m_fLocalTime(0.0f),
-	m_fDelay(0.0f),
-	m_fSecondElapsed(0.0f),
-	m_fAverageSecondElapsed(0.3f),
-	m_fRadius(-1.0f)
-{
-	Initialize();
-}
-CGraphicThingInstance::~CGraphicThingInstance() = default;
+#include "StdAfx.h"
+
+#include "../EterBase/Debug.h"
+
+#include "../EterLib/Camera.h"
+#include "../EterBase/Timer.h"
+
+#include "../GameLib/GameType.h"
+#include "../GameLib/RaceData.h"
+
+#include "ThingInstance.h"
+#include "Thing.h"
+#include "ModelInstance.h"
+
+CDynamicPool<CGraphicThingInstance> CGraphicThingInstance::ms_kPool;
+
+CGraphicThing* CGraphicThingInstance::GetBaseThingPtr()
+{
+	if (m_modelThingSetVector.empty())
+		return nullptr;
+
+	TModelThingSet& rkModelThingSet = m_modelThingSetVector[0];
+	if (rkModelThingSet.m_pLODThingRefVector.empty())
+		return nullptr;
+
+	std::unique_ptr<CGraphicThing::TRef>& proThing = rkModelThingSet.m_pLODThingRefVector[0];
+	if (!proThing)
+		return nullptr;
+
+	CGraphicThing::TRef roThing = *proThing;
+	return roThing.GetPointer();
+}
+
+bool CGraphicThingInstance::LessRenderOrder(CGraphicThingInstance* pkThingInst)
+{
+	return (GetBaseThingPtr() < pkThingInst->GetBaseThingPtr());
+}
+
+void CGraphicThingInstance::CreateSystem(UINT uCapacity)
+{
+	ms_kPool.Create(uCapacity);
+}
+
+void CGraphicThingInstance::DestroySystem()
+{
+	ms_kPool.Destroy();
+}
+
+CGraphicThingInstance* CGraphicThingInstance::New()
+{
+	return ms_kPool.Alloc();
+}
+
+void CGraphicThingInstance::Delete(CGraphicThingInstance* pkThingInst)
+{
+	pkThingInst->Clear();
+	ms_kPool.Free(pkThingInst);
+}
+
+void CGraphicThingInstance::SetMotionAtEnd()
+{
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->SetMotionAtEnd();
+		}
+	);
+}
+
+bool CGraphicThingInstance::Picking(const D3DXVECTOR3& v, const D3DXVECTOR3& dir, float& out_x, float& out_y)
+{
+	if (!m_pHeightAttributeInstance)
+		return false;
+	return m_pHeightAttributeInstance->Picking(v, dir, out_x, out_y);
+}
+
+void CGraphicThingInstance::OnUpdateCollisionData(const CStaticCollisionDataVector* pscdVector)
+{
+	assert(pscdVector);
+	for (const CStaticCollisionData& it : *pscdVector)
+		AddCollision(&it, &GetTransform());
+}
+
+void CGraphicThingInstance::OnUpdateHeighInstance(CAttributeInstance* pAttributeInstance)
+{
+	assert(pAttributeInstance);
+	SetHeightInstance(pAttributeInstance);
+}
+
+bool CGraphicThingInstance::OnGetObjectHeight(float fX, float fY, float* pfHeight)
+{
+	return m_pHeightAttributeInstance && m_pHeightAttributeInstance->GetHeight(fX, fY, pfHeight);
+}
+
+void CGraphicThingInstance::BuildBoundingSphere()
+{
+	D3DXVECTOR3 v3Min, v3Max;
+	GetBoundBox(0, &v3Min, &v3Max);
+	m_v3Center = (v3Min + v3Max) * 0.5f;
+	D3DXVECTOR3 vDelta = (v3Max - v3Min);
+
+	m_fRadius = D3DXVec3Length(&vDelta) * 0.5f + 50.0f; // extra length for attached objects
+}
+
+bool CGraphicThingInstance::GetBoundingSphere(D3DXVECTOR3& v3Center, float& fRadius)
+{
+	if (m_fRadius <= 0)
+	{
+		BuildBoundingSphere();
+
+		fRadius = m_fRadius;
+		v3Center = m_v3Center;
+	}
+	else
+	{
+		fRadius = m_fRadius;
+		v3Center = m_v3Center;
+	}
+
+	D3DXVec3TransformCoord(&v3Center, &v3Center, &GetTransform());
+	return true;
+}
+
+void CGraphicThingInstance::BuildBoundingAABB()
+{
+	D3DXVECTOR3 v3Min, v3Max;
+	GetBoundBox(0, &v3Min, &v3Max);
+	m_v3Center = (v3Min + v3Max) * 0.5f;
+	m_v3Min = v3Min;
+	m_v3Max = v3Max;
+}
+
+bool CGraphicThingInstance::GetBoundingAABB(D3DXVECTOR3& v3Min, D3DXVECTOR3& v3Max)
+{
+	BuildBoundingAABB();
+
+	v3Min = m_v3Min;
+	v3Max = m_v3Max;
+
+	D3DXVec3TransformCoord(&m_v3Center, &m_v3Center, &GetTransform());
+	return true;
+}
+
+void CGraphicThingInstance::CalculateBBox()
+{
+	GetBoundBox(&m_v3BBoxMin, &m_v3BBoxMax);
+
+	m_v4TBBox[0] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMin.y, m_v3BBoxMin.z, 1.0f);
+	m_v4TBBox[1] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMax.y, m_v3BBoxMin.z, 1.0f);
+	m_v4TBBox[2] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMin.y, m_v3BBoxMin.z, 1.0f);
+	m_v4TBBox[3] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMax.y, m_v3BBoxMin.z, 1.0f);
+	m_v4TBBox[4] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMin.y, m_v3BBoxMax.z, 1.0f);
+	m_v4TBBox[5] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMax.y, m_v3BBoxMax.z, 1.0f);
+	m_v4TBBox[6] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMin.y, m_v3BBoxMax.z, 1.0f);
+	m_v4TBBox[7] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMax.y, m_v3BBoxMax.z, 1.0f);
+
+	const D3DXMATRIX& c_rmatTransform = GetTransform();
+
+	for (DWORD i = 0; i < 8; ++i)
+	{
+		D3DXVec4Transform(&m_v4TBBox[i], &m_v4TBBox[i], &c_rmatTransform);
+		if (0 == i)
+		{
+			m_v3TBBoxMin.x = m_v4TBBox[i].x;
+			m_v3TBBoxMin.y = m_v4TBBox[i].y;
+			m_v3TBBoxMin.z = m_v4TBBox[i].z;
+			m_v3TBBoxMax.x = m_v4TBBox[i].x;
+			m_v3TBBoxMax.y = m_v4TBBox[i].y;
+			m_v3TBBoxMax.z = m_v4TBBox[i].z;
+		}
+		else
+		{
+			if (m_v3TBBoxMin.x > m_v4TBBox[i].x)
+				m_v3TBBoxMin.x = m_v4TBBox[i].x;
+			if (m_v3TBBoxMax.x < m_v4TBBox[i].x)
+				m_v3TBBoxMax.x = m_v4TBBox[i].x;
+			if (m_v3TBBoxMin.y > m_v4TBBox[i].y)
+				m_v3TBBoxMin.y = m_v4TBBox[i].y;
+			if (m_v3TBBoxMax.y < m_v4TBBox[i].y)
+				m_v3TBBoxMax.y = m_v4TBBox[i].y;
+			if (m_v3TBBoxMin.z > m_v4TBBox[i].z)
+				m_v3TBBoxMin.z = m_v4TBBox[i].z;
+			if (m_v3TBBoxMax.z < m_v4TBBox[i].z)
+				m_v3TBBoxMax.z = m_v4TBBox[i].z;
+		}
+	}
+}
+
+bool CGraphicThingInstance::CreateDeviceObjects()
+{
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->CreateDeviceObjects();
+		});
+	return true;
+}
+
+void CGraphicThingInstance::DestroyDeviceObjects()
+{
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->DestroyDeviceObjects();
+		});
+}
+
+bool CGraphicThingInstance::CheckModelInstanceIndex(int iModelInstance)
+{
+	if (iModelInstance < 0)
+		return false;
+
+	return iModelInstance < m_LODControllerVector.size();
+}
+
+bool CGraphicThingInstance::CheckModelThingIndex(int iModelThing)
+{
+	if (iModelThing < 0)
+		return false;
+
+	return iModelThing < m_modelThingSetVector.size();
+}
+
+bool CGraphicThingInstance::CheckMotionThingIndex(DWORD dwMotionKey)
+{
+	MotionThingMap::iterator itor = m_roMotionThingMap.find(dwMotionKey);
+	return m_roMotionThingMap.end() != itor;
+}
+
+bool CGraphicThingInstance::GetMotionThingPointer(DWORD dwKey, CGraphicThing** ppMotion)
+{
+	if (!CheckMotionThingIndex(dwKey))
+		return false;
+
+	*ppMotion = m_roMotionThingMap[dwKey]->GetPointer();
+	return true;
+}
+
+bool CGraphicThingInstance::IsMotionThing()
+{
+	return !m_roMotionThingMap.empty();
+}
+
+void CGraphicThingInstance::ReserveModelInstance(int iCount)
+{
+	m_LODControllerVector.clear();
+	m_LODControllerVector.resize(iCount);
+	for (std::unique_ptr<CGrannyLODController>& rkController : m_LODControllerVector)
+		rkController = std::make_unique<CGrannyLODController>();
+}
+
+void CGraphicThingInstance::ReserveModelThing(int iCount)
+{
+	m_modelThingSetVector.resize(iCount);
+}
+
+bool CGraphicThingInstance::FindBoneIndex(int iModelInstance, const char* c_szBoneName, int* iRetBone)
+{
+	assert(CheckModelInstanceIndex(iModelInstance));
+
+	CGrannyModelInstance* pModelInstance = m_LODControllerVector[iModelInstance]->GetModelInstance();
+
+	if (!pModelInstance)
+		return false;
+
+	return pModelInstance->GetBoneIndexByName(c_szBoneName, iRetBone);
+}
+
+void CGraphicThingInstance::AttachModelInstance(int iDstModelInstance, const char* c_szBoneName, int iSrcModelInstance)
+{
+	if (!CheckModelInstanceIndex(iSrcModelInstance))
+	{
+		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, c_szBoneName=%s, iSrcModelInstance=%d)", iDstModelInstance, c_szBoneName, iSrcModelInstance);
+		return;
+	}
+	if (!CheckModelInstanceIndex(iDstModelInstance))
+	{
+		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, c_szBoneName=%s, iSrcModelInstance=%d)", iDstModelInstance, c_szBoneName, iSrcModelInstance);
+		return;
+	}
+
+	CGrannyLODController* pSrcLODController = m_LODControllerVector[iSrcModelInstance].get();
+	CGrannyLODController* pDstLODController = m_LODControllerVector[iDstModelInstance].get();
+	pDstLODController->AttachModelInstance(pSrcLODController, c_szBoneName);
+}
+
+void CGraphicThingInstance::AttachModelInstance(int iDstModelInstance, const char* c_szBoneName, CGraphicThingInstance& rSrcInstance, int iSrcModelInstance)
+{
+	if (!CheckModelInstanceIndex(iDstModelInstance))
+	{
+		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, c_szBoneName=%s, iSrcModelInstance=%d)", iDstModelInstance, c_szBoneName, iSrcModelInstance);
+		return;
+	}
+	if (!rSrcInstance.CheckModelInstanceIndex(iSrcModelInstance))
+	{
+		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, c_szBoneName=%s, iSrcModelInstance=%d)", iDstModelInstance, c_szBoneName, iSrcModelInstance);
+		return;
+	}
+
+	CGrannyLODController* pDstLODController = m_LODControllerVector[iDstModelInstance].get();
+	CGrannyLODController* pSrcLODController = rSrcInstance.m_LODControllerVector[iSrcModelInstance].get();
+	pDstLODController->AttachModelInstance(pSrcLODController, c_szBoneName);
+}
+
+void CGraphicThingInstance::DetachModelInstance(int iDstModelInstance, CGraphicThingInstance& rSrcInstance, int iSrcModelInstance)
+{
+	if (!CheckModelInstanceIndex(iDstModelInstance))
+	{
+		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, iSrcModelInstance=%d)", iDstModelInstance, iSrcModelInstance);
+		return;
+	}
+	if (!rSrcInstance.CheckModelInstanceIndex(iSrcModelInstance))
+	{
+		TraceError("CGraphicThingInstance::AttachModelInstance(iDstModelInstance=%d, iSrcModelInstance=%d)", iDstModelInstance, iSrcModelInstance);
+		return;
+	}
+
+	CGrannyLODController* pDstLODController = m_LODControllerVector[iDstModelInstance].get();
+	CGrannyLODController* pSrcLODController = rSrcInstance.m_LODControllerVector[iSrcModelInstance].get();
+	pDstLODController->DetachModelInstance(pSrcLODController);
+}
+
+bool CGraphicThingInstance::GetBonePosition(int iModelIndex, int iBoneIndex, float* pfx, float* pfy, float* pfz)
+{
+	assert(CheckModelInstanceIndex(iModelIndex));
+
+	CGrannyModelInstance* pModelInstance = m_LODControllerVector[iModelIndex]->GetModelInstance();
+
+	if (!pModelInstance)
+		return false;
+
+	const float* pfMatrix = pModelInstance->GetBoneMatrixPointer(iBoneIndex);
+
+	*pfx = pfMatrix[12];
+	*pfy = pfMatrix[13];
+	*pfz = pfMatrix[14];
+	return true;
+}
+
+// iSkelInstance   âº»  Link( Ù´Â°)Å°,
+//  âº»  attach(Ç¥  Â°) Ë´Ï´.
+bool CGraphicThingInstance::SetModelInstance(int iDstModelInstance, int iSrcModelThing, int iSrcModel, int iSkelInstance)
+{
+	if (!CheckModelInstanceIndex(iDstModelInstance))
+	{
+		TraceError("CGraphicThingInstance::SetModelInstance(iDstModelInstance=%d, pModelThing=%d, iSrcModel=%d)\n", iDstModelInstance, iSrcModelThing, iSrcModel);
+		return false;
+	}
+	if (!CheckModelThingIndex(iSrcModelThing))
+	{
+		TraceError("CGraphicThingInstance::SetModelInstance(iDstModelInstance=%d, pModelThing=%d, iSrcModel=%d)\n", iDstModelInstance, iSrcModelThing, iSrcModel);
+		return false;
+	}
+
+	CGrannyLODController* pController = m_LODControllerVector[iDstModelInstance].get();
+	if (!pController)
+		return false;
+
+	// HAIR_LINK
+	CGrannyLODController* pSkelController = nullptr;
+	if (iSkelInstance != DONTUSEVALUE)
+	{
+		if (!CheckModelInstanceIndex(iSkelInstance))
+		{
+			TraceError("CGraphicThingInstance::SetModelInstanceByOtherSkeletonInstance(iSkelInstance=%d, iDstModelInstance=%d, pModelThing=%d, iSrcModel=%d)\n", iSkelInstance, iDstModelInstance, iSrcModelThing, iSrcModel);
+			return false;
+		}
+		pSkelController = m_LODControllerVector[iSkelInstance].get();
+		if (!pSkelController)
+			return false;
+	}
+	// END_OF_HAIR_LINK
+
+	TModelThingSet& rModelThingSet = m_modelThingSetVector[iSrcModelThing];
+
+	pController->Clear();
+
+	for (std::unique_ptr<CGraphicThing::TRef>& it : rModelThingSet.m_pLODThingRefVector)
+	{
+		if (it->IsNull())
+			return false;
+
+		pController->AddModel(it->GetPointer(), iSrcModel, pSkelController);
+	}
+	return true;
+}
+
+void CGraphicThingInstance::SetMaterialImagePointer(UINT ePart, const char* c_szImageName, CGraphicImage* pImage)
+{
+	if (ePart >= m_LODControllerVector.size())
+	{
+		TraceError("CGraphicThingInstance::SetMaterialImagePointer(ePart(%d)<uPartCount(%d), c_szImageName=%s, pImage=%s) - ePart OUT OF RANGE",
+			ePart, m_LODControllerVector.size(), c_szImageName, pImage->GetFileName());
+		return;
+	}
+
+	if (!m_LODControllerVector[ePart])
+	{
+		TraceError("CGraphicThingInstance::SetMaterialImagePointer(ePart(%d), c_szImageName=%s, pImage=%s) - ePart Data is nullptr",
+			ePart, m_LODControllerVector.size(), c_szImageName, pImage->GetFileName());
+		return;
+	}
+
+	m_LODControllerVector[ePart]->SetMaterialImagePointer(c_szImageName, pImage);
+}
+
+void CGraphicThingInstance::SetMaterialData(UINT ePart, const char* c_szImageName, SMaterialData kMaterialData)
+{
+	if (ePart >= m_LODControllerVector.size())
+	{
+		TraceError("CGraphicThingInstance::SetMaterialData(ePart(%d)<uPartCount(%d)) - ePart OUT OF RANGE",
+			ePart, m_LODControllerVector.size());
+		return;
+	}
+
+	if (!m_LODControllerVector[ePart])
+	{
+		TraceError("CGraphicThingInstance::SetMaterialData(ePart(%d)) - ePart Data is nullptr",
+			ePart, m_LODControllerVector.size());
+		return;
+	}
+
+	m_LODControllerVector[ePart]->SetMaterialData(c_szImageName, kMaterialData);
+}
+
+void CGraphicThingInstance::SetSpecularInfo(UINT ePart, const char* c_szMtrlName, BOOL bEnable, float fPower)
+{
+	if (ePart >= m_LODControllerVector.size())
+	{
+		TraceError("CGraphicThingInstance::SetSpecularInfo(ePart(%d)<uPartCount(%d)) - ePart OUT OF RANGE",
+			ePart, m_LODControllerVector.size());
+		return;
+	}
+
+	if (!m_LODControllerVector[ePart])
+	{
+		TraceError("CGraphicThingInstance::SetSpecularInfo(ePart(%d)) - ePart Data is nullptr",
+			ePart, m_LODControllerVector.size());
+		return;
+	}
+
+	m_LODControllerVector[ePart]->SetSpecularInfo(c_szMtrlName, bEnable, fPower);
+}
+
+bool CGraphicThingInstance::SetMotion(DWORD dwMotionKey, float blendTime, int loopCount, float speedRatio)
+{
+	if (!CheckMotionThingIndex(dwMotionKey))
+		return false;
+
+	MotionThingMap::iterator itor = m_roMotionThingMap.find(dwMotionKey);
+	std::unique_ptr<CGraphicThing::TRef>& proMotionThing = itor->second;
+	CGraphicThing* pMotionThing = proMotionThing->GetPointer();
+
+	if (!pMotionThing)
+		return false;
+
+	if (!pMotionThing->CheckMotionIndex(0))
+		return false;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->SetMotionPointer(pMotionThing->GetMotionPointer(0), blendTime, loopCount, speedRatio);
+		});
+	return true;
+}
+
+bool CGraphicThingInstance::ChangeMotion(DWORD dwMotionKey, int loopCount, float speedRatio)
+{
+	if (!CheckMotionThingIndex(dwMotionKey))
+		return false;
+
+	MotionThingMap::iterator itor = m_roMotionThingMap.find(dwMotionKey);
+	std::unique_ptr<CGraphicThing::TRef>& proMotionThing = itor->second;
+	CGraphicThing* pMotionThing = proMotionThing->GetPointer();
+
+	if (!pMotionThing)
+		return false;
+
+	if (!pMotionThing->CheckMotionIndex(0))
+		return false;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->ChangeMotionPointer(pMotionThing->GetMotionPointer(0), loopCount, speedRatio);
+		});
+	return true;
+}
+
+void CGraphicThingInstance::SetEndStopMotion()
+{
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->SetMotionAtEnd();
+		}
+	);
+}
+
+void CGraphicThingInstance::RegisterModelThing(int iModelThing, CGraphicThing* pModelThing)
+{
+	if (!CheckModelThingIndex(iModelThing))
+	{
+		TraceError("CGraphicThingInstance::RegisterModelThing(iModelThing=%d, pModelThing=%s)\n", iModelThing, pModelThing->GetFileName());
+		return;
+	}
+
+	m_modelThingSetVector[iModelThing].Clear();
+
+	// [Safety Fix] Null pointer guard to prevent crashes during warp/load
+	if (!pModelThing)
+		return;
+
+	if (pModelThing)
+		RegisterLODThing(iModelThing, pModelThing);
+}
+
+void CGraphicThingInstance::RegisterLODThing(int iModelThing, CGraphicThing* pModelThing)
+{
+	assert(CheckModelThingIndex(iModelThing));
+	std::unique_ptr<CGraphicThing::TRef> pModelRef = std::make_unique<CGraphicThing::TRef>();
+	pModelRef->SetPointer(pModelThing);
+	m_modelThingSetVector[iModelThing].m_pLODThingRefVector.emplace_back(std::move(pModelRef));
+}
+
+void CGraphicThingInstance::RegisterMotionThing(DWORD dwMotionKey, CGraphicThing* pMotionThing)
+{
+	std::unique_ptr<CGraphicThing::TRef> pMotionRef = std::make_unique<CGraphicThing::TRef>();
+	pMotionRef->SetPointer(pMotionThing);
+	m_roMotionThingMap.emplace(dwMotionKey, std::move(pMotionRef));
+}
+
+void CGraphicThingInstance::ResetLocalTime()
+{
+	m_fLastLocalTime = 0.0f;
+	m_fLocalTime = 0.0f;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->ResetLocalTime();
+		});
+}
+
+/*
+void CGraphicThingInstance::SetMotionSpeed(float fRate)
+{
+	m_fMotionTimeSpeed = fRate;
+}
+*/
+
+void CGraphicThingInstance::InsertDelay(float fDelay)
+{
+	m_fDelay = fDelay;
+}
+
+float CGraphicThingInstance::GetLastLocalTime()
+{
+	return m_fLastLocalTime;
+}
+
+float CGraphicThingInstance::GetLocalTime()
+{
+	return m_fLocalTime;
+}
+
+float CGraphicThingInstance::GetSecondElapsed()
+{
+	return m_fSecondElapsed;
+}
+
+float CGraphicThingInstance::GetAverageSecondElapsed()
+{
+	return m_fAverageSecondElapsed;
+}
+
+bool CGraphicThingInstance::Intersect(float* pu, float* pv, float* pt)
+{
+	if (!CGraphicObjectInstance::isShow())
+		return false;
+
+	if (!m_bUpdated)
+		return false;
+
+	if (m_LODControllerVector.empty())
+	{
+		//TraceError("CGraphicThingInstance::Intersect - m_LODControllerVector is empty");
+		return false;
+	}
+
+	return m_LODControllerVector[0]->Intersect(&GetTransform(), pu, pv, pt);
+}
+
+void CGraphicThingInstance::GetBoundBox(D3DXVECTOR3* vtMin, D3DXVECTOR3* vtMax)
+{
+	vtMin->x = vtMin->y = vtMin->z = 100000.0f;
+	vtMax->x = vtMax->y = vtMax->z = -100000.0f;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->GetBoundBox(vtMin, vtMax);
+		});
+}
+
+BOOL CGraphicThingInstance::GetBoundBox(DWORD dwModelInstanceIndex, D3DXVECTOR3* vtMin, D3DXVECTOR3* vtMax)
+{
+	if (!CheckModelInstanceIndex(dwModelInstanceIndex))
+		return FALSE;
+
+	vtMin->x = vtMin->y = vtMin->z = 100000.0f;
+	vtMax->x = vtMax->y = vtMax->z = -100000.0f;
+
+	CGrannyLODController* pController = m_LODControllerVector[dwModelInstanceIndex].get();
+	if (!pController->isModelInstance())
+		return FALSE;
+
+	CGrannyModelInstance* pModelInstance = pController->GetModelInstance();
+	pModelInstance->GetBoundBox(vtMin, vtMax);
+	return TRUE;
+}
+
+BOOL CGraphicThingInstance::GetBoneMatrix(DWORD dwModelInstanceIndex, DWORD dwBoneIndex, D3DXMATRIX** ppMatrix)
+{
+	if (!CheckModelInstanceIndex(dwModelInstanceIndex))
+		return FALSE;
+
+	CGrannyModelInstance* pModelInstance = m_LODControllerVector[dwModelInstanceIndex]->GetModelInstance();
+	if (!pModelInstance)
+		return FALSE;
+
+	*ppMatrix = reinterpret_cast<D3DXMATRIX*>(pModelInstance->GetBoneMatrixPointer(dwBoneIndex));
+	if (!*ppMatrix)
+		return FALSE;
+
+	return TRUE;
+}
+
+BOOL CGraphicThingInstance::GetCompositeBoneMatrix(DWORD dwModelInstanceIndex, DWORD dwBoneIndex, D3DXMATRIX** ppMatrix)
+{
+	if (!CheckModelInstanceIndex(dwModelInstanceIndex))
+		return FALSE;
+
+	CGrannyModelInstance* pModelInstance = m_LODControllerVector[dwModelInstanceIndex]->GetModelInstance();
+	if (!pModelInstance)
+	{
+		//TraceError("CGraphicThingInstance::GetCompositeBoneMatrix(dwModelInstanceIndex=%d, dwBoneIndex=%d, D3DXMATRIX ** ppMatrix)", dwModelInstanceIndex, dwBoneIndex);
+		return FALSE;
+	}
+
+	*ppMatrix = reinterpret_cast<D3DXMATRIX*>(pModelInstance->GetCompositeBoneMatrixPointer(dwBoneIndex));
+
+	return TRUE;
+}
+
+void CGraphicThingInstance::UpdateTransform(D3DXMATRIX* pMatrix, float fSecondsElapsed, int iModelInstanceIndex)
+{
+	//TraceError("%s", GetBaseThingPtr()->GetFileName());
+	int nLODCount = m_LODControllerVector.size();
+	if (iModelInstanceIndex >= nLODCount)
+	{
+		/*
+		TraceError("void CGraphicThingInstance::UpdateTransform(pMatrix, fSecondsElapsed=%f, iModelInstanceIndex=%d/nLODCount=%d)",
+			fSecondsElapsed, iModelInstanceIndex, nLODCount);
+		*/
+		return;
+	}
+
+	CGrannyLODController* pkLODCtrl = m_LODControllerVector[iModelInstanceIndex].get();
+	if (!pkLODCtrl)
+	{
+		/*
+		TraceError("void CGraphicThingInstance::UpdateTransform(pMatrix, fSecondsElapsed=%f, iModelInstanceIndex=%d/nLODCount=%d) - m_LODControllerVector[iModelInstanceIndex] == nullptr",
+			fSecondsElapsed, iModelInstanceIndex, nLODCount);
+		*/
+		return;
+	}
+
+	CGrannyModelInstance* pModelInstance = pkLODCtrl->GetModelInstance();
+	if (!pModelInstance)
+	{
+		/*
+		TraceError("void CGraphicThingInstance::UpdateTransform(pMatrix, fSecondsElapsed=%f, iModelInstanceIndex=%d/nLODCount=%d) - pkLODCtrl->GetModelInstance() == nullptr",
+			fSecondsElapsed, iModelInstanceIndex, nLODCount);
+		*/
+		return;
+	}
+
+	pModelInstance->UpdateTransform(pMatrix, fSecondsElapsed);
+}
+
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+void CGraphicThingInstance::RecalcAccePositionMatrixFromBoneMatrix()
+{
+	if (m_LODControllerVector.empty())
+		return;
+
+	CGrannyModelInstance* pModelInstance = m_LODControllerVector[0]->GetModelInstance();
+	if (!pModelInstance)
+		return;
+
+	int iBoneIndex = 0;
+	pModelInstance->GetBoneIndexByName("Bip01 Spine2", &iBoneIndex);
+	const D3DXMATRIX* c_matBoneMatrix = (D3DXMATRIX*)pModelInstance->GetBoneMatrixPointer(iBoneIndex);
+	if (c_matBoneMatrix)
+	{
+		D3DXVECTOR3 v3ScaleCenter = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
+		float fAccePosX = c_matBoneMatrix->_41;
+		float fAccePosY = c_matBoneMatrix->_42;
+		float fAccePosZ = c_matBoneMatrix->_43;
+		D3DXMatrixIdentity(&m_matScale);
+		if (m_bAttachedAcceRace)
+		{
+			v3ScaleCenter.x = fAccePosX;
+			v3ScaleCenter.y = fAccePosY;
+		}
+		else
+		{
+			v3ScaleCenter.x = fAccePosX - 18.0f;
+			v3ScaleCenter.y = -40.0f;
+		}
+		v3ScaleCenter.z = fAccePosZ;
+		D3DXQUATERNION qRot = D3DXQUATERNION(0.0f, 0.0f, 0.0f, 0.0f);
+		D3DXMatrixTransformation(&m_matScale, &v3ScaleCenter, &qRot, &m_v3ScaleAcce, NULL, NULL, NULL);
+	}
+
+	D3DXMATRIX matTemp;
+	D3DXMatrixMultiply(&matTemp, &m_matScaleWorld, &m_matScale);
+	m_matAbsoluteTrans = matTemp * m_mRotation;
+	m_matAbsoluteTrans._41 += m_v3Position.x;
+	m_matAbsoluteTrans._42 += m_v3Position.y;
+	m_matAbsoluteTrans._43 += m_v3Position.z;
+}
+#endif
+
+void CGraphicThingInstance::DeformAll()
+{
+	m_bUpdated = true;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->DeformAll(&m_worldMatrix);
+		});
+}
+
+void CGraphicThingInstance::DeformNoSkin()
+{
+	m_bUpdated = true;
+
+	for (std::size_t i = 0; i != m_LODControllerVector.size(); i++)
+	{
+		CGrannyLODController* pkLOD = m_LODControllerVector[i].get();
+		if (pkLOD && pkLOD->isModelInstance())
+		{
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+			if (i == CRaceData::PART_ACCE)
+			{
+				RecalcAccePositionMatrixFromBoneMatrix();
+				pkLOD->DeformNoSkin(&m_matAbsoluteTrans);
+			}
+			else
+#endif
+				pkLOD->DeformNoSkin(&m_worldMatrix);
+		}
+	}
+}
+
+void CGraphicThingInstance::OnDeform()
+{
+	m_bUpdated = true;
+
+	for (std::size_t i = 0; i != m_LODControllerVector.size(); i++)
+	{
+		CGrannyLODController* pkLOD = m_LODControllerVector[i].get();
+		if (pkLOD && pkLOD->isModelInstance())
+		{
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+			if (i == CRaceData::PART_ACCE)
+			{
+				RecalcAccePositionMatrixFromBoneMatrix();
+				pkLOD->Deform(&m_matAbsoluteTrans);
+			}
+			else
+#endif
+				pkLOD->Deform(&m_worldMatrix);
+		}
+	}
+}
+
+void CGraphicThingInstance::__SetLocalTime(float fLocalTime)
+{
+	m_fLastLocalTime = m_fLocalTime;
+	m_fLocalTime = fLocalTime;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD)
+				pkLOD->SetLocalTime(fLocalTime);
+		});
+}
+
+void CGraphicThingInstance::UpdateLODLevel()
+{
+	CCamera* pCurCamera = CCameraManager::Instance().GetCurrentCamera();
+	if (!pCurCamera)
+	{
+		TraceError("CGraphicThingInstance::UpdateLODLevel - GetCurrentCamera() == nullptr");
+		return;
+	}
+
+	const D3DXVECTOR3& c_rv3TargetPosition = pCurCamera->GetTarget();
+	const D3DXVECTOR3& c_rv3CameraPosition = pCurCamera->GetEye();
+	const D3DXVECTOR3& c_v3Position = GetPosition();
+
+	// NOTE : ß½Îº Å¸ ê¿¡ z Ì´  Ê´Â´. - [levites]
+	float fDistanceFromCenter = sqrtf((c_rv3TargetPosition.x - c_v3Position.x) * (c_rv3TargetPosition.x - c_v3Position.x) +
+		(c_rv3TargetPosition.y - c_v3Position.y) * (c_rv3TargetPosition.y - c_v3Position.y));
+	float fDistanceFromCamera = sqrtf((c_rv3CameraPosition.x - c_v3Position.x) * (c_rv3CameraPosition.x - c_v3Position.x) +
+		(c_rv3CameraPosition.y - c_v3Position.y) * (c_rv3CameraPosition.y - c_v3Position.y) +
+		(c_rv3CameraPosition.z - c_v3Position.z) * (c_rv3CameraPosition.z - c_v3Position.z));
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->UpdateLODLevel(fDistanceFromCenter, fDistanceFromCamera);
+		});
+}
+
+void CGraphicThingInstance::UpdateTime()
+{
+	m_fSecondElapsed = CTimer::Instance().GetElapsedSecond();
+
+	if (m_fDelay > m_fSecondElapsed)
+	{
+		m_fDelay -= m_fSecondElapsed;
+		m_fSecondElapsed = 0.0f;
+	}
+	else
+	{
+		m_fSecondElapsed -= m_fDelay;
+		m_fDelay = 0.0f;
+	}
+
+	m_fLastLocalTime = m_fLocalTime;
+	m_fLocalTime += m_fSecondElapsed;
+	m_fAverageSecondElapsed = m_fAverageSecondElapsed + (m_fSecondElapsed - m_fAverageSecondElapsed) / 4.0f;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->UpdateTime(m_fSecondElapsed);
+		});
+}
+
+void CGraphicThingInstance::OnUpdate()
+{
+#if defined(__PERFORMANCE_CHECKER__)
+	DWORD dwTime1 = timeGetTime();
+#endif
+	UpdateLODLevel();
+#if defined(__PERFORMANCE_CHECKER__)
+	DWORD dwTime2 = timeGetTime();
+#endif
+	UpdateTime();
+#if defined(__PERFORMANCE_CHECKER__)
+	DWORD dwLastTime = timeGetTime();
+	{
+		static FILE* pFile = fopen("perf_thing_onupdate.txt", "w");
+		if (dwLastTime - dwTime1 > 3)
+		{
+			fprintf(pFile, "GTU.Total %d (Time %f)\n", dwLastTime - dwTime1, ELTimer_GetMSec() / 1000.0f);
+			fprintf(pFile, "GTU.CAL %d\n", dwTime2 - dwTime1);
+			fprintf(pFile, "GTU.UP %d\n", dwLastTime - dwTime2);
+			fprintf(pFile, "-------------------------------- \n");
+			fflush(pFile);
+		}
+		fflush(pFile);
+	}
+#endif
+}
+
+void CGraphicThingInstance::OnRender()
+{
+	RenderWithOneTexture();
+}
+
+void CGraphicThingInstance::OnBlendRender()
+{
+	BlendRenderWithOneTexture();
+}
+
+void CGraphicThingInstance::RenderWithOneTexture()
+{
+	if (!m_bUpdated)
+		return;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->RenderWithOneTexture();
+		});
+}
+
+void CGraphicThingInstance::BlendRenderWithOneTexture()
+{
+	if (!m_bUpdated)
+		return;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->BlendRenderWithOneTexture();
+		});
+}
+
+void CGraphicThingInstance::RenderWithTwoTexture()
+{
+	if (!m_bUpdated)
+		return;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->RenderWithTwoTexture();
+		});
+}
+
+void CGraphicThingInstance::BlendRenderWithTwoTexture()
+{
+	if (!m_bUpdated)
+		return;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->BlendRenderWithTwoTexture();
+		});
+}
+
+void CGraphicThingInstance::OnRenderToShadowMap()
+{
+	if (!m_bUpdated)
+		return;
+
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->RenderToShadowMap();
+		});
+}
+
+void CGraphicThingInstance::OnRenderShadow()
+{
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->RenderShadow();
+		});
+}
+
+void CGraphicThingInstance::OnRenderPCBlocker()
+{
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->RenderWithOneTexture();
+		});
+}
+
+DWORD CGraphicThingInstance::GetLODControllerCount() const
+{
+	return m_LODControllerVector.size();
+}
+
+CGrannyLODController* CGraphicThingInstance::GetLODControllerPointer(DWORD dwModelIndex) const
+{
+	assert(dwModelIndex < m_LODControllerVector.size());
+	return m_LODControllerVector[dwModelIndex].get();
+}
+
+CGrannyLODController* CGraphicThingInstance::GetLODControllerPointer(DWORD dwModelIndex)
+{
+	assert(dwModelIndex < m_LODControllerVector.size());
+	return m_LODControllerVector[dwModelIndex].get();
+}
+
+BYTE CGraphicThingInstance::GetLODLevel(DWORD dwModelInstance)
+{
+	assert(dwModelInstance < m_LODControllerVector.size());
+	return (m_LODControllerVector[dwModelInstance]->GetLODLevel());
+}
+
+float CGraphicThingInstance::GetHeight(bool bScaleX)
+{
+	if (m_LODControllerVector.empty())
+		return 0.0f;
+
+	CGrannyModelInstance* pModelInstance = m_LODControllerVector[0]->GetModelInstance();
+	if (!pModelInstance)
+		return 0.0f;
+
+	D3DXVECTOR3 vtMin, vtMax, vtScale = GetScale();
+	pModelInstance->GetBoundBox(&vtMin, &vtMax);
+	if (bScaleX)
+		return vtScale.x * (vtMax.x - vtMin.x);
+
+	return vtScale.z * (vtMax.z - vtMin.z);
+}
+
+void CGraphicThingInstance::ReloadTexture()
+{
+	std::for_each(m_LODControllerVector.begin(), m_LODControllerVector.end(),
+		[&](std::unique_ptr<CGrannyLODController>& rkController)
+		{
+			CGrannyLODController* pkLOD = rkController.get();
+			if (pkLOD && pkLOD->isModelInstance())
+				pkLOD->ReloadTexture();
+		});
+}
+
+bool CGraphicThingInstance::HaveBlendThing()
+{
+	for (std::unique_ptr<CGrannyLODController>& it : m_LODControllerVector)
+	{
+		if (it->HaveBlendThing())
+			return true;
+	}
+	return false;
+}
+
+void CGraphicThingInstance::OnClear()
+{
+	m_LODControllerVector.clear();
+	m_roMotionThingMap.clear();
+
+	for (TModelThingSet& rkModelThing : m_modelThingSetVector)
+		rkModelThing.Clear();
+}
+
+void CGraphicThingInstance::OnInitialize()
+{
+	m_bUpdated = false;
+	m_fLastLocalTime = 0.0f;
+	m_fLocalTime = 0.0f;
+	m_fDelay = 0.0f;
+	m_fSecondElapsed = 0.0f;
+	m_fAverageSecondElapsed = 0.03f;
+	m_fRadius = -1.0f;
+	m_v3Center = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
+
+	ResetLocalTime();
+}
+
+CGraphicThingInstance::CGraphicThingInstance() :
+	m_bUpdated(false),
+	m_fLastLocalTime(0.0f),
+	m_fLocalTime(0.0f),
+	m_fDelay(0.0f),
+	m_fSecondElapsed(0.0f),
+	m_fAverageSecondElapsed(0.3f),
+	m_fRadius(-1.0f)
+{
+	Initialize();
+}
+CGraphicThingInstance::~CGraphicThingInstance() = default;
diff --git a/src-client/Client/GameLib/ActorInstanceAttach.cpp b/src-client/Client/GameLib/ActorInstanceAttach.cpp
index 56aa406..d03548a 100644
--- a/src-client/Client/GameLib/ActorInstanceAttach.cpp
+++ b/src-client/Client/GameLib/ActorInstanceAttach.cpp
@@ -1,750 +1,763 @@
-#include "StdAfx.h"
-#include "../EffectLib/EffectManager.h"
-
-#include "ActorInstance.h"
-#include "ItemData.h"
-#include "ItemManager.h"
-#include "RaceData.h"
-#include "WeaponTrace.h"
-
-BOOL USE_WEAPON_SPECULAR = TRUE;
-
-BOOL USE_VIETNAM_CONVERT_WEAPON_VNUM = FALSE;
-
-DWORD Vietnam_ConvertWeaponVnum(DWORD vnum)
-{
-	DWORD base = vnum / 10 * 10;
-	DWORD rest = vnum % 10;
-	switch (base)
-	{
-		case 10:base = 5000; break;
-		case 20:base = 5010; break;
-		case 30:base = 5020; break;
-		case 40:base = 5030; break;
-		case 50:base = 5030; break;
-		case 60:base = 5040; break;
-		case 70:base = 5040; break;
-		case 80:base = 5050; break;
-		case 90:base = 5050; break;
-		case 100:base = 5060; break;
-		case 110:base = 5060; break;
-		case 120:base = 5070; break;
-		case 130:base = 5070; break;
-		case 140:base = 5080; break;
-		case 150:base = 5080; break;
-		case 160:base = 5090; break;
-		case 170:base = 5090; break;
-		case 180:base = 5100; break;
-		case 190:base = 5100; break;
-		case 200:base = 5110; break;
-		case 210:base = 5110; break;
-		case 220:base = 5120; break;
-		case 230:base = 5120; break;
-		case 240:base = 5130; break;
-		case 250:base = 5130; break;
-		case 260:base = 5140; break;
-		case 270:base = 5140; break;
-		case 280:base = 5150; break;
-		case 290:base = 5150; break;
-		case 1000:base = 5000; break;
-		case 1010:base = 5010; break;
-		case 1020:base = 5020; break;
-		case 1030:base = 5030; break;
-		case 1040:base = 5040; break;
-		case 1050:base = 5050; break;
-		case 1060:base = 5060; break;
-		case 1070:base = 5070; break;
-		case 1080:base = 5080; break;
-		case 1090:base = 5090; break;
-		case 1100:base = 5100; break;
-		case 1110:base = 5110; break;
-		case 1120:base = 5120; break;
-		case 1130:base = 5130; break;
-		case 1140:base = 5140; break;
-		case 1150:base = 5150; break;
-		case 1160:base = 5150; break;
-		case 1170:base = 5150; break;
-		case 3000:base = 5000; break;
-		case 3010:base = 5010; break;
-		case 3020:base = 5020; break;
-		case 3030:base = 5030; break;
-		case 3040:base = 5040; break;
-		case 3050:base = 5050; break;
-		case 3060:base = 5060; break;
-		case 3070:base = 5070; break;
-		case 3080:base = 5080; break;
-		case 3090:base = 5090; break;
-		case 3100:base = 5100; break;
-		case 3110:base = 5100; break;
-		case 3120:base = 5110; break;
-		case 3130:base = 5110; break;
-		case 3140:base = 5120; break;
-		case 3150:base = 5120; break;
-		case 3160:base = 5130; break;
-		case 3170:base = 5130; break;
-		case 3180:base = 5140; break;
-		case 3190:base = 5140; break;
-		case 3200:base = 5150; break;
-		case 3210:base = 5150; break;
-	}
-	return base + rest;
-}
-
-
-DWORD CActorInstance::AttachSmokeEffect(DWORD eSmoke)
-{
-	if (!m_pkCurRaceData)
-		return 0;
-
-	DWORD dwSmokeEffectID = m_pkCurRaceData->GetSmokeEffectID(eSmoke);
-
-#if defined(ENABLE_METINSTONE_SWAP)
-	if (m_pkCurRaceDataStoneShapeEvent)
-		dwSmokeEffectID = m_pkCurRaceDataStoneShapeEvent->GetSmokeEffectID(eSmoke);
-#endif
-
-	return AttachEffectByID(0, m_pkCurRaceData->GetSmokeBone().c_str(), dwSmokeEffectID);
-}
-
-bool CActorInstance::__IsLeftHandWeapon(DWORD type)
-{
-#ifdef SORF_TAHTASI
-	if (CItemData::WEAPON_DAGGER == type || (CItemData::WEAPON_FAN == type && __IsMountingHorse() && m_pkHorse->GetRace() != SURFBOARD))
-#else
-	if (CItemData::WEAPON_DAGGER == type || (CItemData::WEAPON_FAN == type && __IsMountingHorse()))
-#endif
-		return true;
-	else if (CItemData::WEAPON_BOW == type)
-		return true;
-	else if (CItemData::WEAPON_CLAW == type)
-		return true;
-	else
-		return false;
-}
-
-bool CActorInstance::__IsRightHandWeapon(DWORD type)
-{
-#ifdef SORF_TAHTASI
-	if (CItemData::WEAPON_DAGGER == type || (CItemData::WEAPON_FAN == type && __IsMountingHorse() && m_pkHorse->GetRace() != SURFBOARD))
-#else
-	if (CItemData::WEAPON_DAGGER == type || (CItemData::WEAPON_FAN == type && __IsMountingHorse()))
-#endif
-		return true;
-	else if (CItemData::WEAPON_BOW == type)
-		return false;
-	else if (CItemData::WEAPON_CLAW == type)
-		return true;
-	else
-		return true;
-}
-
-bool CActorInstance::__IsWeaponTrace(DWORD weaponType)
-{
-	switch (weaponType)
-	{
-		case CItemData::WEAPON_BELL:
-		case CItemData::WEAPON_FAN:
-		case CItemData::WEAPON_BOW:
-			return false;
-		default:
-			return true;
-
-	}
-}
-
-void CActorInstance::AttachWeapon(DWORD dwItemIndex, DWORD dwParentPartIndex, DWORD dwPartIndex)
-{
-	if (dwPartIndex >= CRaceData::PART_MAX_NUM)
-		return;
-
-	m_adwPartItemID[dwPartIndex] = dwItemIndex;
-
-	if (USE_VIETNAM_CONVERT_WEAPON_VNUM)
-		dwItemIndex = Vietnam_ConvertWeaponVnum(dwItemIndex);
-
-	CItemData* pItemData;
-	if (!CItemManager::Instance().GetItemDataPointer(dwItemIndex, &pItemData))
-	{
-		RegisterModelThing(dwPartIndex, NULL);
-		SetModelInstance(dwPartIndex, dwPartIndex, 0);
-
-		RegisterModelThing(CRaceData::PART_WEAPON_LEFT, NULL);
-		SetModelInstance(CRaceData::PART_WEAPON_LEFT, CRaceData::PART_WEAPON_LEFT, 0);
-
-		RefreshActorInstance();
-		return;
-	}
-
-	__DestroyWeaponTrace();
-	// ¾ç¼Õ¹«±â(ÀÚ°´ ÀÌµµ·ù) ¿Þ¼Õ,¿À¸¥¼Õ ¸ðµÎ¿¡ ÀåÂø.
-	DWORD dwWeaponType = pItemData->GetWeaponType();
-#if defined(ENABLE_WEAPON_COSTUME_SYSTEM)
-	if (pItemData->GetType() == CItemData::ITEM_TYPE_COSTUME)
-	{
-		DWORD dwType = pItemData->GetValue(3);
-		if (__IsRightHandWeapon(dwType))
-			AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON, pItemData);
-		if (__IsLeftHandWeapon(dwType))
-			AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON_LEFT, pItemData);
-	}
-	else
-	{
-		if (m_eRace == CRaceData::RACE_WOLFMAN_M)
-		{
-			const char* szAttachingBoneName = "equip_right_weapon";
-			if (dwWeaponType != CItemData::WEAPON_CLAW)
-				szAttachingBoneName = "equip_right";
-			m_pkCurRaceData->ChangeAttachingBoneName(CRaceData::PART_WEAPON, szAttachingBoneName);
-		}
-
-		if (__IsRightHandWeapon(dwWeaponType))
-			AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON, pItemData);
-		if (__IsLeftHandWeapon(dwWeaponType))
-			AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON_LEFT, pItemData);
-	}
-#else
-	if (__IsRightHandWeapon(dwWeaponType))
-		AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON, pItemData);
-	if (__IsLeftHandWeapon(dwWeaponType))
-		AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON_LEFT, pItemData);
-#endif
-}
-
-BOOL CActorInstance::GetAttachingBoneName(DWORD dwPartIndex, const char** c_pszBoneName)
-{
-	return m_pkCurRaceData->GetAttachingBoneName(dwPartIndex, c_pszBoneName);
-}
-
-void CActorInstance::AttachWeapon(DWORD dwParentPartIndex, DWORD dwPartIndex, CItemData* pItemData)
-{
-	//assert(m_pkCurRaceData);
-	if (!pItemData)
-		return;
-
-	const char* szBoneName;
-	if (!GetAttachingBoneName(dwPartIndex, &szBoneName))
-		return;
-
-	// NOTE : (ÀÌµµ·ùÃ³¸®)´ÜµµÀÏ °æ¿ì ÇüÅÂ°¡ ´Ù¸¥ °ÍÀ¸·Î ¾ò´Â´Ù. ¾øÀ» °æ¿ì µðÆúÆ®¸¦ ¸®ÅÏ
-	if (CRaceData::PART_WEAPON_LEFT == dwPartIndex)
-		RegisterModelThing(dwPartIndex, pItemData->GetSubModelThing());
-	else
-		RegisterModelThing(dwPartIndex, pItemData->GetModelThing());
-
-	for (DWORD i = 0; i < pItemData->GetLODModelThingCount(); ++i)
-	{
-		CGraphicThing* pThing;
-
-		if (!pItemData->GetLODModelThingPointer(i, &pThing))
-			continue;
-
-		RegisterLODThing(dwPartIndex, pThing);
-	}
-
-	SetModelInstance(dwPartIndex, dwPartIndex, 0);
-	AttachModelInstance(dwParentPartIndex, szBoneName, dwPartIndex);
-
-	// 20041208.myevan.¹«±â½ºÆåÅ§·¯(°ª¿ÊÀº SetShape¿¡¼­ Á÷Á¢ ÇØÁØ´Ù.)
-	if (USE_WEAPON_SPECULAR)
-	{
-		SMaterialData kMaterialData;
-		kMaterialData.pImage = NULL;
-		kMaterialData.isSpecularEnable = TRUE;
-		kMaterialData.fSpecularPower = pItemData->GetSpecularPowerf();
-		kMaterialData.bSphereMapIndex = 1;
-		SetMaterialData(dwPartIndex, NULL, kMaterialData);
-	}
-
-	// Weapon Trace
-#if defined(ENABLE_WEAPON_COSTUME_SYSTEM)
-	if (pItemData->GetType() == CItemData::ITEM_TYPE_COSTUME)
-	{
-		DWORD dwType = pItemData->GetValue(3);
-		if (__IsWeaponTrace(dwType))
-		{
-			CWeaponTrace* pWeaponTrace = CWeaponTrace::New();
-			pWeaponTrace->SetWeaponInstance(this, dwPartIndex, szBoneName);
-			m_WeaponTraceVector.push_back(pWeaponTrace);
-		}
-	}
-	else
-	{
-		if (__IsWeaponTrace(pItemData->GetWeaponType()))
-		{
-			CWeaponTrace* pWeaponTrace = CWeaponTrace::New();
-			pWeaponTrace->SetWeaponInstance(this, dwPartIndex, szBoneName);
-			m_WeaponTraceVector.push_back(pWeaponTrace);
-		}
-	}
-#else
-	if (__IsWeaponTrace(pItemData->GetWeaponType()))
-	{
-		CWeaponTrace* pWeaponTrace = CWeaponTrace::New();
-		pWeaponTrace->SetWeaponInstance(this, dwPartIndex, szBoneName);
-		m_WeaponTraceVector.push_back(pWeaponTrace);
-	}
-#endif
-}
-
-void  CActorInstance::DettachEffect(DWORD dwEID)
-{
-	std::list<TAttachingEffect>::iterator i = m_AttachingEffectList.begin();
-
-	while (i != m_AttachingEffectList.end())
-	{
-		TAttachingEffect& rkAttEft = (*i);
-
-		if (rkAttEft.dwEffectIndex == dwEID)
-		{
-			i = m_AttachingEffectList.erase(i);
-			CEffectManager::Instance().DestroyEffectInstance(dwEID);
-		}
-		else
-		{
-			++i;
-		}
-	}
-}
-
-DWORD CActorInstance::AttachEffectByName(DWORD dwParentPartIndex, const char* c_pszBoneName, const char* c_pszEffectName)
-{
-	std::string str;
-	DWORD dwCRC;
-	StringPath(c_pszEffectName, str);
-	dwCRC = GetCaseCRC32(str.c_str(), str.length());
-
-	return AttachEffectByID(dwParentPartIndex, c_pszBoneName, dwCRC);
-}
-
-DWORD CActorInstance::AttachEffectByID(DWORD dwParentPartIndex, const char* c_pszBoneName, DWORD dwEffectID, const D3DXVECTOR3* c_pv3Position, float fParticleScale, const D3DXVECTOR3* c_pv3MeshScale)
-{
-	TAttachingEffect ae;
-	ae.iLifeType = EFFECT_LIFE_INFINITE;
-	ae.dwEndTime = 0;
-	ae.dwModelIndex = dwParentPartIndex;
-	ae.dwEffectIndex = CEffectManager::Instance().GetEmptyIndex();
-	ae.isAttaching = TRUE;
-
-	if (c_pv3Position)
-		D3DXMatrixTranslation(&ae.matTranslation, c_pv3Position->x, c_pv3Position->y, c_pv3Position->z);
-	else
-		D3DXMatrixIdentity(&ae.matTranslation);
-
-	CEffectManager& rkEftMgr = CEffectManager::Instance();
-	if (c_pv3MeshScale)
-		rkEftMgr.CreateEffectInstance(ae.dwEffectIndex, dwEffectID, fParticleScale, c_pv3MeshScale);
-	else
-		rkEftMgr.CreateEffectInstance(ae.dwEffectIndex, dwEffectID, fParticleScale);
-
-#if defined(ENABLE_GRAPHIC_ON_OFF)
-	if (!m_bRenderEffect)
-	{
-		rkEftMgr.SelectEffectInstance(ae.dwEffectIndex);
-		rkEftMgr.HideEffect();
-	}
-#endif
-
-	if (c_pszBoneName)
-	{
-		int iBoneIndex;
-		if (!FindBoneIndex(dwParentPartIndex, c_pszBoneName, &iBoneIndex))
-		{
-			ae.iBoneIndex = -1;
-			//Tracef("Cannot get Bone Index\n");
-			//assert(false && "Cannot get Bone Index");
-		}
-		else
-		{
-			ae.iBoneIndex = iBoneIndex;
-		}
-	}
-	else
-	{
-		ae.iBoneIndex = -1;
-	}
-
-	m_AttachingEffectList.push_back(ae);
-
-	return ae.dwEffectIndex;
-}
-
-void CActorInstance::RefreshActorInstance()
-{
-	if (!m_pkCurRaceData)
-	{
-		TraceError("void CActorInstance::RefreshActorInstance() - m_pkCurRaceData=NULL");
-		return;
-	}
-
-	// This is Temporary place before making the weapon detection system
-	// Setup Collison Detection Data
-	m_BodyPointInstanceList.clear();
-	//m_AttackingPointInstanceList.clear();
-	m_DefendingPointInstanceList.clear();
-
-	// Base
-	for (DWORD i = 0; i < m_pkCurRaceData->GetAttachingDataCount(); ++i)
-	{
-		const NRaceData::TAttachingData* c_pAttachingData;
-
-		if (!m_pkCurRaceData->GetAttachingDataPointer(i, &c_pAttachingData))
-			continue;
-
-		switch (c_pAttachingData->dwType)
-		{
-			case NRaceData::ATTACHING_DATA_TYPE_COLLISION_DATA:
-			{
-				const NRaceData::TCollisionData* c_pCollisionData = c_pAttachingData->pCollisionData;
-
-				TCollisionPointInstance PointInstance;
-				if (NRaceData::COLLISION_TYPE_ATTACKING == c_pCollisionData->iCollisionType)
-					continue;
-
-				if (!CreateCollisionInstancePiece(CRaceData::PART_MAIN, c_pAttachingData, &PointInstance))
-					continue;
-
-				switch (c_pCollisionData->iCollisionType)
-				{
-					case NRaceData::COLLISION_TYPE_ATTACKING:
-						//m_AttackingPointInstanceList.push_back(PointInstance);
-						break;
-					case NRaceData::COLLISION_TYPE_DEFENDING:
-						m_DefendingPointInstanceList.push_back(PointInstance);
-						break;
-					case NRaceData::COLLISION_TYPE_BODY:
-						m_BodyPointInstanceList.push_back(PointInstance);
-						break;
-				}
-			}
-			break;
-
-			case NRaceData::ATTACHING_DATA_TYPE_EFFECT:
-				//if (!m_bEffectInitialized)
-				//{
-				//	DWORD dwCRC;
-				//	StringPath(c_pAttachingData->pEffectData->strFileName);
-				//	dwCRC = GetCaseCRC32(c_pAttachingData->pEffectData->strFileName.c_str(), c_pAttachingData->pEffectData->strFileName.length());
-				//
-				//	TAttachingEffect ae;
-				//	ae.iLifeType = EFFECT_LIFE_INFINITE;
-				//	ae.dwEndTime = 0;
-				//	ae.dwModelIndex = 0;
-				//	ae.dwEffectIndex = CEffectManager::Instance().GetEmptyIndex();
-				//	ae.isAttaching = TRUE;
-				//	CEffectManager::Instance().CreateEffectInstance(ae.dwEffectIndex, dwCRC);
-				//
-				//	if (c_pAttachingData->isAttaching)
-				//	{
-				//		int iBoneIndex;
-				//		if (!FindBoneIndex(0, c_pAttachingData->strAttachingBoneName.c_str(), &iBoneIndex))
-				//		{
-				//			Tracef("Cannot get Bone Index\n");
-				//			assert(false/*Cannot get Bone Index*/);
-				//		}
-				//
-				//		ae.iBoneIndex = iBoneIndex;
-				//	}
-				//	else
-				//	{
-				//		ae.iBoneIndex = -1;
-				//	}
-				//
-				//	m_AttachingEffectList.push_back(ae);
-				//}
-
-				if (c_pAttachingData->isAttaching)
-				{
-					AttachEffectByName(0, c_pAttachingData->strAttachingBoneName.c_str(), c_pAttachingData->pEffectData->strFileName.c_str());
-				}
-				else
-				{
-					AttachEffectByName(0, 0, c_pAttachingData->pEffectData->strFileName.c_str());
-				}
-				break;
-
-			case NRaceData::ATTACHING_DATA_TYPE_OBJECT:
-				break;
-
-			default:
-				assert(false/* NOT_IMPLEMENTED */);
-				break;
-		}
-	}
-
-	for (DWORD j = 0; j < CRaceData::PART_MAX_NUM; ++j)
-	{
-		if (0 == m_adwPartItemID[j])
-			continue;
-
-		CItemData* pItemData;
-		if (!CItemManager::Instance().GetItemDataPointer(m_adwPartItemID[j], &pItemData))
-			return;
-
-		for (DWORD k = 0; k < pItemData->GetAttachingDataCount(); ++k)
-		{
-			const NRaceData::TAttachingData* c_pAttachingData;
-
-			if (!pItemData->GetAttachingDataPointer(k, &c_pAttachingData))
-				continue;
-
-			switch (c_pAttachingData->dwType)
-			{
-				case NRaceData::ATTACHING_DATA_TYPE_COLLISION_DATA:
-				{
-					const NRaceData::TCollisionData* c_pCollisionData = c_pAttachingData->pCollisionData;
-
-					// FIXME : Ã¹¹øÂ° ÀÎÀÚ´Â PartÀÇ ¹øÈ£´Ù.
-					// Base´Â ¹«Á¶°Ç 0ÀÎ°¡? - [levites]
-					TCollisionPointInstance PointInstance;
-					if (NRaceData::COLLISION_TYPE_ATTACKING == c_pCollisionData->iCollisionType)
-						continue;
-					if (!CreateCollisionInstancePiece(j, c_pAttachingData, &PointInstance))
-						continue;
-
-					switch (c_pCollisionData->iCollisionType)
-					{
-						case NRaceData::COLLISION_TYPE_ATTACKING:
-							//m_AttackingPointInstanceList.push_back(PointInstance);
-							break;
-						case NRaceData::COLLISION_TYPE_DEFENDING:
-							m_DefendingPointInstanceList.push_back(PointInstance);
-							break;
-						case NRaceData::COLLISION_TYPE_BODY:
-							m_BodyPointInstanceList.push_back(PointInstance);
-							break;
-					}
-				}
-				break;
-
-				case NRaceData::ATTACHING_DATA_TYPE_EFFECT:
-					if (!m_bEffectInitialized)
-					{
-						DWORD dwCRC;
-						StringPath(c_pAttachingData->pEffectData->strFileName);
-						dwCRC = GetCaseCRC32(c_pAttachingData->pEffectData->strFileName.c_str(), c_pAttachingData->pEffectData->strFileName.length());
-
-						TAttachingEffect ae;
-						ae.iLifeType = EFFECT_LIFE_INFINITE;
-						ae.dwEndTime = 0;
-						ae.dwModelIndex = j;
-						ae.dwEffectIndex = CEffectManager::Instance().GetEmptyIndex();
-						ae.isAttaching = TRUE;
-						CEffectManager::Instance().CreateEffectInstance(ae.dwEffectIndex, dwCRC);
-
-						int iBoneIndex;
-						if (!FindBoneIndex(j, c_pAttachingData->strAttachingBoneName.c_str(), &iBoneIndex))
-						{
-							Tracef("Cannot get Bone Index\n");
-							assert(false/* Cannot get Bone Index */);
-						}
-						Tracef("Creating %p %d %d\n", this, j, k);
-
-						ae.iBoneIndex = iBoneIndex;
-
-						m_AttachingEffectList.push_back(ae);
-					}
-					break;
-
-				case NRaceData::ATTACHING_DATA_TYPE_OBJECT:
-					break;
-
-				default:
-					assert(false/* NOT_IMPLEMENTED */);
-					break;
-			}
-		}
-	}
-
-	m_bEffectInitialized = true;
-#if defined(ENABLE_GRAPHIC_ON_OFF)
-	m_bRenderEffect = true;
-#endif
-}
-
-void CActorInstance::SetWeaponTraceTexture(const char* szTextureName)
-{
-	std::vector<CWeaponTrace*>::iterator it;
-	for (it = m_WeaponTraceVector.begin(); it != m_WeaponTraceVector.end(); ++it)
-	{
-		(*it)->SetTexture(szTextureName);
-	}
-}
-
-void CActorInstance::UseTextureWeaponTrace()
-{
-	for_each(
-		m_WeaponTraceVector.begin(),
-		m_WeaponTraceVector.end(),
-		std::mem_fn(&CWeaponTrace::UseTexture)
-	);
-}
-
-void CActorInstance::UseAlphaWeaponTrace()
-{
-	for_each(
-		m_WeaponTraceVector.begin(),
-		m_WeaponTraceVector.end(),
-		std::mem_fn(&CWeaponTrace::UseAlpha)
-	);
-}
-
-void CActorInstance::UpdateAttachingInstances()
-{
-	CEffectManager& rkEftMgr = CEffectManager::Instance();
-
-	std::list<TAttachingEffect>::iterator it;
-	DWORD dwCurrentTime = CTimer::Instance().GetCurrentMillisecond();
-	for (it = m_AttachingEffectList.begin(); it != m_AttachingEffectList.end();)
-	{
-		if (EFFECT_LIFE_WITH_MOTION == it->iLifeType)
-		{
-			++it;
-			continue;
-		}
-
-		if ((EFFECT_LIFE_NORMAL == it->iLifeType && it->dwEndTime < dwCurrentTime) ||
-			!rkEftMgr.IsAliveEffect(it->dwEffectIndex))
-		{
-			rkEftMgr.DestroyEffectInstance(it->dwEffectIndex);
-			it = m_AttachingEffectList.erase(it);
-		}
-		else
-		{
-			if (it->isAttaching)
-			{
-				rkEftMgr.SelectEffectInstance(it->dwEffectIndex);
-
-				if (it->iBoneIndex == -1)
-				{
-					D3DXMATRIX matTransform;
-					matTransform = it->matTranslation;
-					matTransform *= m_worldMatrix;
-					rkEftMgr.SetEffectInstanceGlobalMatrix(matTransform);
-				}
-				else
-				{
-					D3DXMATRIX* pBoneMat;
-					if (GetBoneMatrix(it->dwModelIndex, it->iBoneIndex, &pBoneMat))
-					{
-						D3DXMATRIX matTransform;
-						matTransform = *pBoneMat;
-						matTransform *= it->matTranslation;
-						matTransform *= m_worldMatrix;
-						rkEftMgr.SetEffectInstanceGlobalMatrix(matTransform);
-					}
-					else
-					{
-						//TraceError("GetBoneMatrix(modelIndex(%d), boneIndex(%d)).NOT_FOUND_BONE", 
-						//	it->dwModelIndex, it->iBoneIndex);
-					}
-				}
-			}
-
-			++it;
-		}
-	}
-}
-
-void CActorInstance::ShowAllAttachingEffect()
-{
-	std::list<TAttachingEffect>::iterator it;
-	for (it = m_AttachingEffectList.begin(); it != m_AttachingEffectList.end(); ++it)
-	{
-		CEffectManager::Instance().SelectEffectInstance(it->dwEffectIndex);
-		CEffectManager::Instance().ShowEffect();
-	}
-}
-
-void CActorInstance::HideAllAttachingEffect()
-{
-	std::list<TAttachingEffect>::iterator it;
-	for (it = m_AttachingEffectList.begin(); it != m_AttachingEffectList.end(); ++it)
-	{
-		CEffectManager::Instance().SelectEffectInstance(it->dwEffectIndex);
-		CEffectManager::Instance().HideEffect();
-	}
-}
-
-void CActorInstance::__ClearAttachingEffect()
-{
-	m_bEffectInitialized = false;
-
-	std::list<TAttachingEffect>::iterator it;
-	for (it = m_AttachingEffectList.begin(); it != m_AttachingEffectList.end(); ++it)
-	{
-		CEffectManager::Instance().DestroyEffectInstance(it->dwEffectIndex);
-	}
-	m_AttachingEffectList.clear();
-}
-
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-void CActorInstance::AttachAcce(DWORD dwItemIndex, DWORD dwParentPartIndex, DWORD dwPartIndex)
-{
-	if (dwPartIndex >= CRaceData::PART_MAX_NUM)
-		return;
-
-	m_adwPartItemID[dwPartIndex] = dwItemIndex;
-
-	CItemData* pItemData;
-	if (!CItemManager::Instance().GetItemDataPointer(dwItemIndex, &pItemData))
-	{
-		RegisterModelThing(dwPartIndex, NULL);
-		SetModelInstance(dwPartIndex, dwPartIndex, 0);
-
-		RegisterModelThing(CRaceData::PART_ACCE, NULL);
-		SetModelInstance(CRaceData::PART_ACCE, CRaceData::PART_ACCE, 0);
-
-		RefreshActorInstance();
-		return;
-	}
-
-	AttachAcce(dwParentPartIndex, CRaceData::PART_ACCE, pItemData);
-}
-
-void CActorInstance::AttachAcce(DWORD dwParentPartIndex, DWORD dwPartIndex, CItemData* pItemData)
-{
-	if (!pItemData)
-		return;
-
-	if (CRaceData::PART_ACCE == dwPartIndex)
-		RegisterModelThing(CRaceData::PART_ACCE, pItemData->GetSubModelThing());
-	else
-		RegisterModelThing(dwPartIndex, pItemData->GetModelThing());
-
-	for (DWORD i = 0; i < pItemData->GetLODModelThingCount(); ++i)
-	{
-		CGraphicThing* pThing;
-		if (!pItemData->GetLODModelThingPointer(i, &pThing))
-			continue;
-
-		RegisterLODThing(dwPartIndex, pThing);
-	}
-
-	SetModelInstance(dwPartIndex, dwPartIndex, 0);
-	AttachModelInstance(dwParentPartIndex, "Bip01 Spine2", dwPartIndex);
-
-	SMaterialData kMaterialData;
-	kMaterialData.pImage = NULL;
-	kMaterialData.isSpecularEnable = TRUE;
-	kMaterialData.fSpecularPower = pItemData->GetSpecularPowerf();
-	kMaterialData.bSphereMapIndex = 1;
-	SetMaterialData(dwPartIndex, NULL, kMaterialData);
-}
-#endif
-
-#if defined(ENABLE_QUIVER_SYSTEM)
-void CActorInstance::SetQuiverEquipped(bool bEquipped)
-{
-	m_bIsQuiverEquipped = bEquipped;
-}
-
-void CActorInstance::SetQuiverEffectID(DWORD dwEffectID)
-{
-	m_dwQuiverEffectID = dwEffectID;
-}
-#endif
-
-void CActorInstance::ChangePart(DWORD dwPartIndex, DWORD dwItemIndex)
-{
-	m_adwPartItemID[dwPartIndex] = dwItemIndex;
-}
+#include "StdAfx.h"
+#include "../EffectLib/EffectManager.h"
+
+#include "ActorInstance.h"
+#include "ItemData.h"
+#include "ItemManager.h"
+#include "RaceData.h"
+#include "WeaponTrace.h"
+
+BOOL USE_WEAPON_SPECULAR = TRUE;
+
+BOOL USE_VIETNAM_CONVERT_WEAPON_VNUM = FALSE;
+
+DWORD Vietnam_ConvertWeaponVnum(DWORD vnum)
+{
+	DWORD base = vnum / 10 * 10;
+	DWORD rest = vnum % 10;
+	switch (base)
+	{
+		case 10:base = 5000; break;
+		case 20:base = 5010; break;
+		case 30:base = 5020; break;
+		case 40:base = 5030; break;
+		case 50:base = 5030; break;
+		case 60:base = 5040; break;
+		case 70:base = 5040; break;
+		case 80:base = 5050; break;
+		case 90:base = 5050; break;
+		case 100:base = 5060; break;
+		case 110:base = 5060; break;
+		case 120:base = 5070; break;
+		case 130:base = 5070; break;
+		case 140:base = 5080; break;
+		case 150:base = 5080; break;
+		case 160:base = 5090; break;
+		case 170:base = 5090; break;
+		case 180:base = 5100; break;
+		case 190:base = 5100; break;
+		case 200:base = 5110; break;
+		case 210:base = 5110; break;
+		case 220:base = 5120; break;
+		case 230:base = 5120; break;
+		case 240:base = 5130; break;
+		case 250:base = 5130; break;
+		case 260:base = 5140; break;
+		case 270:base = 5140; break;
+		case 280:base = 5150; break;
+		case 290:base = 5150; break;
+		case 1000:base = 5000; break;
+		case 1010:base = 5010; break;
+		case 1020:base = 5020; break;
+		case 1030:base = 5030; break;
+		case 1040:base = 5040; break;
+		case 1050:base = 5050; break;
+		case 1060:base = 5060; break;
+		case 1070:base = 5070; break;
+		case 1080:base = 5080; break;
+		case 1090:base = 5090; break;
+		case 1100:base = 5100; break;
+		case 1110:base = 5110; break;
+		case 1120:base = 5120; break;
+		case 1130:base = 5130; break;
+		case 1140:base = 5140; break;
+		case 1150:base = 5150; break;
+		case 1160:base = 5150; break;
+		case 1170:base = 5150; break;
+		case 3000:base = 5000; break;
+		case 3010:base = 5010; break;
+		case 3020:base = 5020; break;
+		case 3030:base = 5030; break;
+		case 3040:base = 5040; break;
+		case 3050:base = 5050; break;
+		case 3060:base = 5060; break;
+		case 3070:base = 5070; break;
+		case 3080:base = 5080; break;
+		case 3090:base = 5090; break;
+		case 3100:base = 5100; break;
+		case 3110:base = 5100; break;
+		case 3120:base = 5110; break;
+		case 3130:base = 5110; break;
+		case 3140:base = 5120; break;
+		case 3150:base = 5120; break;
+		case 3160:base = 5130; break;
+		case 3170:base = 5130; break;
+		case 3180:base = 5140; break;
+		case 3190:base = 5140; break;
+		case 3200:base = 5150; break;
+		case 3210:base = 5150; break;
+	}
+	return base + rest;
+}
+
+
+DWORD CActorInstance::AttachSmokeEffect(DWORD eSmoke)
+{
+	if (!m_pkCurRaceData)
+		return 0;
+
+	DWORD dwSmokeEffectID = m_pkCurRaceData->GetSmokeEffectID(eSmoke);
+
+#if defined(ENABLE_METINSTONE_SWAP)
+	if (m_pkCurRaceDataStoneShapeEvent)
+		dwSmokeEffectID = m_pkCurRaceDataStoneShapeEvent->GetSmokeEffectID(eSmoke);
+#endif
+
+	return AttachEffectByID(0, m_pkCurRaceData->GetSmokeBone().c_str(), dwSmokeEffectID);
+}
+
+bool CActorInstance::__IsLeftHandWeapon(DWORD type)
+{
+#ifdef SORF_TAHTASI
+	if (CItemData::WEAPON_DAGGER == type || (CItemData::WEAPON_FAN == type && __IsMountingHorse() && m_pkHorse->GetRace() != SURFBOARD))
+#else
+	if (CItemData::WEAPON_DAGGER == type || (CItemData::WEAPON_FAN == type && __IsMountingHorse()))
+#endif
+		return true;
+	else if (CItemData::WEAPON_BOW == type)
+		return true;
+	else if (CItemData::WEAPON_CLAW == type)
+		return true;
+	else
+		return false;
+}
+
+bool CActorInstance::__IsRightHandWeapon(DWORD type)
+{
+#ifdef SORF_TAHTASI
+	if (CItemData::WEAPON_DAGGER == type || (CItemData::WEAPON_FAN == type && __IsMountingHorse() && m_pkHorse->GetRace() != SURFBOARD))
+#else
+	if (CItemData::WEAPON_DAGGER == type || (CItemData::WEAPON_FAN == type && __IsMountingHorse()))
+#endif
+		return true;
+	else if (CItemData::WEAPON_BOW == type)
+		return false;
+	else if (CItemData::WEAPON_CLAW == type)
+		return true;
+	else
+		return true;
+}
+
+bool CActorInstance::__IsWeaponTrace(DWORD weaponType)
+{
+	switch (weaponType)
+	{
+		case CItemData::WEAPON_BELL:
+		case CItemData::WEAPON_FAN:
+		case CItemData::WEAPON_BOW:
+			return false;
+		default:
+			return true;
+
+	}
+}
+
+void CActorInstance::AttachWeapon(DWORD dwItemIndex, DWORD dwParentPartIndex, DWORD dwPartIndex)
+{
+	if (dwPartIndex >= CRaceData::PART_MAX_NUM)
+		return;
+
+	m_adwPartItemID[dwPartIndex] = dwItemIndex;
+
+	if (USE_VIETNAM_CONVERT_WEAPON_VNUM)
+		dwItemIndex = Vietnam_ConvertWeaponVnum(dwItemIndex);
+
+	CItemData* pItemData;
+	if (!CItemManager::Instance().GetItemDataPointer(dwItemIndex, &pItemData))
+	{
+		RegisterModelThing(dwPartIndex, NULL);
+		SetModelInstance(dwPartIndex, dwPartIndex, 0);
+
+		RegisterModelThing(CRaceData::PART_WEAPON_LEFT, NULL);
+		SetModelInstance(CRaceData::PART_WEAPON_LEFT, CRaceData::PART_WEAPON_LEFT, 0);
+
+		RefreshActorInstance();
+		return;
+	}
+
+	__DestroyWeaponTrace();
+	// Õ¹(Ú° Ìµ) Þ¼, Î¿ .
+	DWORD dwWeaponType = pItemData->GetWeaponType();
+#if defined(ENABLE_WEAPON_COSTUME_SYSTEM)
+	if (pItemData->GetType() == CItemData::ITEM_TYPE_COSTUME)
+	{
+		DWORD dwType = pItemData->GetValue(3);
+		if (__IsRightHandWeapon(dwType))
+			AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON, pItemData);
+		if (__IsLeftHandWeapon(dwType))
+			AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON_LEFT, pItemData);
+	}
+	else
+	{
+		if (m_eRace == CRaceData::RACE_WOLFMAN_M)
+		{
+			const char* szAttachingBoneName = "equip_right_weapon";
+			if (dwWeaponType != CItemData::WEAPON_CLAW)
+				szAttachingBoneName = "equip_right";
+			m_pkCurRaceData->ChangeAttachingBoneName(CRaceData::PART_WEAPON, szAttachingBoneName);
+		}
+
+		if (__IsRightHandWeapon(dwWeaponType))
+		{
+			m_adwPartItemID[CRaceData::PART_WEAPON] = dwItemIndex;
+			AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON, pItemData);
+		}
+		if (__IsLeftHandWeapon(dwWeaponType))
+		{
+			m_adwPartItemID[CRaceData::PART_WEAPON_LEFT] = dwItemIndex;
+			AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON_LEFT, pItemData);
+		}
+	}
+#else
+	if (__IsRightHandWeapon(dwWeaponType))
+		AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON, pItemData);
+	if (__IsLeftHandWeapon(dwWeaponType))
+		AttachWeapon(dwParentPartIndex, CRaceData::PART_WEAPON_LEFT, pItemData);
+#endif
+}
+
+BOOL CActorInstance::GetAttachingBoneName(DWORD dwPartIndex, const char** c_pszBoneName)
+{
+	return m_pkCurRaceData->GetAttachingBoneName(dwPartIndex, c_pszBoneName);
+}
+
+void CActorInstance::AttachWeapon(DWORD dwParentPartIndex, DWORD dwPartIndex, CItemData* pItemData)
+{
+	//assert(m_pkCurRaceData);
+	if (!pItemData)
+		return;
+
+	const char* szBoneName;
+	if (!GetAttachingBoneName(dwPartIndex, &szBoneName))
+		return;
+
+	// NOTE : (ÌµÃ³)Üµ  Â° Ù¸  Â´.   Æ® 
+	if (CRaceData::PART_WEAPON_LEFT == dwPartIndex)
+		RegisterModelThing(dwPartIndex, pItemData->GetSubModelThing());
+	else
+		RegisterModelThing(dwPartIndex, pItemData->GetModelThing());
+
+	for (DWORD i = 0; i < pItemData->GetLODModelThingCount(); ++i)
+	{
+		CGraphicThing* pThing;
+
+		if (!pItemData->GetLODModelThingPointer(i, &pThing))
+			continue;
+
+		RegisterLODThing(dwPartIndex, pThing);
+	}
+
+	// [Safety Fix] Ensure SetModelInstance succeeds
+	if (!SetModelInstance(dwPartIndex, dwPartIndex, 0))
+	{
+		DWORD vnum = m_adwPartItemID[dwPartIndex];
+		if (vnum) QueuePendingWeaponAttach(vnum, dwParentPartIndex, dwPartIndex);
+		return;
+	}
+
+	AttachModelInstance(dwParentPartIndex, szBoneName, dwPartIndex);
+
+	// 20041208.myevan.Ã«Â¬Â´ÃªÂ¸?Ã¬Å Â¤Ã­Å½â¢Ã­?Ã«Å¸?(ÃªÂ°âÃ¬ËÂ·Ã¬? SetShapeÃ¬â?Ã¬âÅ Ã¬Â§?Ã¬â? Ã­â¢Â´Ã¬Â¤â¬Ã«â¹Â¤.)
+	if (USE_WEAPON_SPECULAR)
+	{
+		SMaterialData kMaterialData;
+		kMaterialData.pImage = NULL;
+		kMaterialData.isSpecularEnable = TRUE;
+		kMaterialData.fSpecularPower = pItemData->GetSpecularPowerf();
+		kMaterialData.bSphereMapIndex = 1;
+		SetMaterialData(dwPartIndex, NULL, kMaterialData);
+	}
+
+	// Weapon Trace
+#if defined(ENABLE_WEAPON_COSTUME_SYSTEM)
+	if (pItemData->GetType() == CItemData::ITEM_TYPE_COSTUME)
+	{
+		DWORD dwType = pItemData->GetValue(3);
+		if (__IsWeaponTrace(dwType))
+		{
+			CWeaponTrace* pWeaponTrace = CWeaponTrace::New();
+			pWeaponTrace->SetWeaponInstance(this, dwPartIndex, szBoneName);
+			m_WeaponTraceVector.push_back(pWeaponTrace);
+		}
+	}
+	else
+	{
+		if (__IsWeaponTrace(pItemData->GetWeaponType()))
+		{
+			CWeaponTrace* pWeaponTrace = CWeaponTrace::New();
+			pWeaponTrace->SetWeaponInstance(this, dwPartIndex, szBoneName);
+			m_WeaponTraceVector.push_back(pWeaponTrace);
+		}
+	}
+#else
+	if (__IsWeaponTrace(pItemData->GetWeaponType()))
+	{
+		CWeaponTrace* pWeaponTrace = CWeaponTrace::New();
+		pWeaponTrace->SetWeaponInstance(this, dwPartIndex, szBoneName);
+		m_WeaponTraceVector.push_back(pWeaponTrace);
+	}
+#endif
+}
+
+void  CActorInstance::DettachEffect(DWORD dwEID)
+{
+	std::list<TAttachingEffect>::iterator i = m_AttachingEffectList.begin();
+
+	while (i != m_AttachingEffectList.end())
+	{
+		TAttachingEffect& rkAttEft = (*i);
+
+		if (rkAttEft.dwEffectIndex == dwEID)
+		{
+			i = m_AttachingEffectList.erase(i);
+			CEffectManager::Instance().DestroyEffectInstance(dwEID);
+		}
+		else
+		{
+			++i;
+		}
+	}
+}
+
+DWORD CActorInstance::AttachEffectByName(DWORD dwParentPartIndex, const char* c_pszBoneName, const char* c_pszEffectName)
+{
+	std::string str;
+	DWORD dwCRC;
+	StringPath(c_pszEffectName, str);
+	dwCRC = GetCaseCRC32(str.c_str(), str.length());
+
+	return AttachEffectByID(dwParentPartIndex, c_pszBoneName, dwCRC);
+}
+
+DWORD CActorInstance::AttachEffectByID(DWORD dwParentPartIndex, const char* c_pszBoneName, DWORD dwEffectID, const D3DXVECTOR3* c_pv3Position, float fParticleScale, const D3DXVECTOR3* c_pv3MeshScale)
+{
+	TAttachingEffect ae;
+	ae.iLifeType = EFFECT_LIFE_INFINITE;
+	ae.dwEndTime = 0;
+	ae.dwModelIndex = dwParentPartIndex;
+	ae.dwEffectIndex = CEffectManager::Instance().GetEmptyIndex();
+	ae.isAttaching = TRUE;
+
+	if (c_pv3Position)
+		D3DXMatrixTranslation(&ae.matTranslation, c_pv3Position->x, c_pv3Position->y, c_pv3Position->z);
+	else
+		D3DXMatrixIdentity(&ae.matTranslation);
+
+	CEffectManager& rkEftMgr = CEffectManager::Instance();
+	if (c_pv3MeshScale)
+		rkEftMgr.CreateEffectInstance(ae.dwEffectIndex, dwEffectID, fParticleScale, c_pv3MeshScale);
+	else
+		rkEftMgr.CreateEffectInstance(ae.dwEffectIndex, dwEffectID, fParticleScale);
+
+#if defined(ENABLE_GRAPHIC_ON_OFF)
+	if (!m_bRenderEffect)
+	{
+		rkEftMgr.SelectEffectInstance(ae.dwEffectIndex);
+		rkEftMgr.HideEffect();
+	}
+#endif
+
+	if (c_pszBoneName)
+	{
+		int iBoneIndex;
+		if (!FindBoneIndex(dwParentPartIndex, c_pszBoneName, &iBoneIndex))
+		{
+			ae.iBoneIndex = -1;
+			//Tracef("Cannot get Bone Index\n");
+			//assert(false && "Cannot get Bone Index");
+		}
+		else
+		{
+			ae.iBoneIndex = iBoneIndex;
+		}
+	}
+	else
+	{
+		ae.iBoneIndex = -1;
+	}
+
+	m_AttachingEffectList.push_back(ae);
+
+	return ae.dwEffectIndex;
+}
+
+void CActorInstance::RefreshActorInstance()
+{
+	if (!m_pkCurRaceData)
+	{
+		TraceError("void CActorInstance::RefreshActorInstance() - m_pkCurRaceData=NULL");
+		return;
+	}
+
+	// This is Temporary place before making the weapon detection system
+	// Setup Collison Detection Data
+	m_BodyPointInstanceList.clear();
+	//m_AttackingPointInstanceList.clear();
+	m_DefendingPointInstanceList.clear();
+
+	// Base
+	for (DWORD i = 0; i < m_pkCurRaceData->GetAttachingDataCount(); ++i)
+	{
+		const NRaceData::TAttachingData* c_pAttachingData;
+
+		if (!m_pkCurRaceData->GetAttachingDataPointer(i, &c_pAttachingData))
+			continue;
+
+		switch (c_pAttachingData->dwType)
+		{
+			case NRaceData::ATTACHING_DATA_TYPE_COLLISION_DATA:
+			{
+				const NRaceData::TCollisionData* c_pCollisionData = c_pAttachingData->pCollisionData;
+
+				TCollisionPointInstance PointInstance;
+				if (NRaceData::COLLISION_TYPE_ATTACKING == c_pCollisionData->iCollisionType)
+					continue;
+
+				if (!CreateCollisionInstancePiece(CRaceData::PART_MAIN, c_pAttachingData, &PointInstance))
+					continue;
+
+				switch (c_pCollisionData->iCollisionType)
+				{
+					case NRaceData::COLLISION_TYPE_ATTACKING:
+						//m_AttackingPointInstanceList.push_back(PointInstance);
+						break;
+					case NRaceData::COLLISION_TYPE_DEFENDING:
+						m_DefendingPointInstanceList.push_back(PointInstance);
+						break;
+					case NRaceData::COLLISION_TYPE_BODY:
+						m_BodyPointInstanceList.push_back(PointInstance);
+						break;
+				}
+			}
+			break;
+
+			case NRaceData::ATTACHING_DATA_TYPE_EFFECT:
+				//if (!m_bEffectInitialized)
+				//{
+				//	DWORD dwCRC;
+				//	StringPath(c_pAttachingData->pEffectData->strFileName);
+				//	dwCRC = GetCaseCRC32(c_pAttachingData->pEffectData->strFileName.c_str(), c_pAttachingData->pEffectData->strFileName.length());
+				//
+				//	TAttachingEffect ae;
+				//	ae.iLifeType = EFFECT_LIFE_INFINITE;
+				//	ae.dwEndTime = 0;
+				//	ae.dwModelIndex = 0;
+				//	ae.dwEffectIndex = CEffectManager::Instance().GetEmptyIndex();
+				//	ae.isAttaching = TRUE;
+				//	CEffectManager::Instance().CreateEffectInstance(ae.dwEffectIndex, dwCRC);
+				//
+				//	if (c_pAttachingData->isAttaching)
+				//	{
+				//		int iBoneIndex;
+				//		if (!FindBoneIndex(0, c_pAttachingData->strAttachingBoneName.c_str(), &iBoneIndex))
+				//		{
+				//			Tracef("Cannot get Bone Index\n");
+				//			assert(false/*Cannot get Bone Index*/);
+				//		}
+				//
+				//		ae.iBoneIndex = iBoneIndex;
+				//	}
+				//	else
+				//	{
+				//		ae.iBoneIndex = -1;
+				//	}
+				//
+				//	m_AttachingEffectList.push_back(ae);
+				//}
+
+				if (c_pAttachingData->isAttaching)
+				{
+					AttachEffectByName(0, c_pAttachingData->strAttachingBoneName.c_str(), c_pAttachingData->pEffectData->strFileName.c_str());
+				}
+				else
+				{
+					AttachEffectByName(0, 0, c_pAttachingData->pEffectData->strFileName.c_str());
+				}
+				break;
+
+			case NRaceData::ATTACHING_DATA_TYPE_OBJECT:
+				break;
+
+			default:
+				assert(false/* NOT_IMPLEMENTED */);
+				break;
+		}
+	}
+
+	for (DWORD j = 0; j < CRaceData::PART_MAX_NUM; ++j)
+	{
+		if (0 == m_adwPartItemID[j])
+			continue;
+
+		CItemData* pItemData;
+		if (!CItemManager::Instance().GetItemDataPointer(m_adwPartItemID[j], &pItemData))
+			return;
+
+		for (DWORD k = 0; k < pItemData->GetAttachingDataCount(); ++k)
+		{
+			const NRaceData::TAttachingData* c_pAttachingData;
+
+			if (!pItemData->GetAttachingDataPointer(k, &c_pAttachingData))
+				continue;
+
+			switch (c_pAttachingData->dwType)
+			{
+				case NRaceData::ATTACHING_DATA_TYPE_COLLISION_DATA:
+				{
+					const NRaceData::TCollisionData* c_pCollisionData = c_pAttachingData->pCollisionData;
+
+					// FIXME : Ã¹Â° Ú´ Part È£.
+					// Base  0Î°? - [levites]
+					TCollisionPointInstance PointInstance;
+					if (NRaceData::COLLISION_TYPE_ATTACKING == c_pCollisionData->iCollisionType)
+						continue;
+					if (!CreateCollisionInstancePiece(j, c_pAttachingData, &PointInstance))
+						continue;
+
+					switch (c_pCollisionData->iCollisionType)
+					{
+						case NRaceData::COLLISION_TYPE_ATTACKING:
+							//m_AttackingPointInstanceList.push_back(PointInstance);
+							break;
+						case NRaceData::COLLISION_TYPE_DEFENDING:
+							m_DefendingPointInstanceList.push_back(PointInstance);
+							break;
+						case NRaceData::COLLISION_TYPE_BODY:
+							m_BodyPointInstanceList.push_back(PointInstance);
+							break;
+					}
+				}
+				break;
+
+				case NRaceData::ATTACHING_DATA_TYPE_EFFECT:
+					if (!m_bEffectInitialized)
+					{
+						DWORD dwCRC;
+						StringPath(c_pAttachingData->pEffectData->strFileName);
+						dwCRC = GetCaseCRC32(c_pAttachingData->pEffectData->strFileName.c_str(), c_pAttachingData->pEffectData->strFileName.length());
+
+						TAttachingEffect ae;
+						ae.iLifeType = EFFECT_LIFE_INFINITE;
+						ae.dwEndTime = 0;
+						ae.dwModelIndex = j;
+						ae.dwEffectIndex = CEffectManager::Instance().GetEmptyIndex();
+						ae.isAttaching = TRUE;
+						CEffectManager::Instance().CreateEffectInstance(ae.dwEffectIndex, dwCRC);
+
+						int iBoneIndex;
+						if (!FindBoneIndex(j, c_pAttachingData->strAttachingBoneName.c_str(), &iBoneIndex))
+						{
+							Tracef("Cannot get Bone Index\n");
+							assert(false/* Cannot get Bone Index */);
+						}
+						Tracef("Creating %p %d %d\n", this, j, k);
+
+						ae.iBoneIndex = iBoneIndex;
+
+						m_AttachingEffectList.push_back(ae);
+					}
+					break;
+
+				case NRaceData::ATTACHING_DATA_TYPE_OBJECT:
+					break;
+
+				default:
+					assert(false/* NOT_IMPLEMENTED */);
+					break;
+			}
+		}
+	}
+
+	m_bEffectInitialized = true;
+#if defined(ENABLE_GRAPHIC_ON_OFF)
+	m_bRenderEffect = true;
+#endif
+}
+
+void CActorInstance::SetWeaponTraceTexture(const char* szTextureName)
+{
+	std::vector<CWeaponTrace*>::iterator it;
+	for (it = m_WeaponTraceVector.begin(); it != m_WeaponTraceVector.end(); ++it)
+	{
+		(*it)->SetTexture(szTextureName);
+	}
+}
+
+void CActorInstance::UseTextureWeaponTrace()
+{
+	for_each(
+		m_WeaponTraceVector.begin(),
+		m_WeaponTraceVector.end(),
+		std::mem_fn(&CWeaponTrace::UseTexture)
+	);
+}
+
+void CActorInstance::UseAlphaWeaponTrace()
+{
+	for_each(
+		m_WeaponTraceVector.begin(),
+		m_WeaponTraceVector.end(),
+		std::mem_fn(&CWeaponTrace::UseAlpha)
+	);
+}
+
+void CActorInstance::UpdateAttachingInstances()
+{
+	CEffectManager& rkEftMgr = CEffectManager::Instance();
+
+	std::list<TAttachingEffect>::iterator it;
+	DWORD dwCurrentTime = CTimer::Instance().GetCurrentMillisecond();
+	for (it = m_AttachingEffectList.begin(); it != m_AttachingEffectList.end();)
+	{
+		if (EFFECT_LIFE_WITH_MOTION == it->iLifeType)
+		{
+			++it;
+			continue;
+		}
+
+		if ((EFFECT_LIFE_NORMAL == it->iLifeType && it->dwEndTime < dwCurrentTime) ||
+			!rkEftMgr.IsAliveEffect(it->dwEffectIndex))
+		{
+			rkEftMgr.DestroyEffectInstance(it->dwEffectIndex);
+			it = m_AttachingEffectList.erase(it);
+		}
+		else
+		{
+			if (it->isAttaching)
+			{
+				rkEftMgr.SelectEffectInstance(it->dwEffectIndex);
+
+				if (it->iBoneIndex == -1)
+				{
+					D3DXMATRIX matTransform;
+					matTransform = it->matTranslation;
+					matTransform *= m_worldMatrix;
+					rkEftMgr.SetEffectInstanceGlobalMatrix(matTransform);
+				}
+				else
+				{
+					D3DXMATRIX* pBoneMat;
+					if (GetBoneMatrix(it->dwModelIndex, it->iBoneIndex, &pBoneMat))
+					{
+						D3DXMATRIX matTransform;
+						matTransform = *pBoneMat;
+						matTransform *= it->matTranslation;
+						matTransform *= m_worldMatrix;
+						rkEftMgr.SetEffectInstanceGlobalMatrix(matTransform);
+					}
+					else
+					{
+						//TraceError("GetBoneMatrix(modelIndex(%d), boneIndex(%d)).NOT_FOUND_BONE", 
+						//	it->dwModelIndex, it->iBoneIndex);
+					}
+				}
+			}
+
+			++it;
+		}
+	}
+}
+
+void CActorInstance::ShowAllAttachingEffect()
+{
+	std::list<TAttachingEffect>::iterator it;
+	for (it = m_AttachingEffectList.begin(); it != m_AttachingEffectList.end(); ++it)
+	{
+		CEffectManager::Instance().SelectEffectInstance(it->dwEffectIndex);
+		CEffectManager::Instance().ShowEffect();
+	}
+}
+
+void CActorInstance::HideAllAttachingEffect()
+{
+	std::list<TAttachingEffect>::iterator it;
+	for (it = m_AttachingEffectList.begin(); it != m_AttachingEffectList.end(); ++it)
+	{
+		CEffectManager::Instance().SelectEffectInstance(it->dwEffectIndex);
+		CEffectManager::Instance().HideEffect();
+	}
+}
+
+void CActorInstance::__ClearAttachingEffect()
+{
+	m_bEffectInitialized = false;
+
+	std::list<TAttachingEffect>::iterator it;
+	for (it = m_AttachingEffectList.begin(); it != m_AttachingEffectList.end(); ++it)
+	{
+		CEffectManager::Instance().DestroyEffectInstance(it->dwEffectIndex);
+	}
+	m_AttachingEffectList.clear();
+}
+
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+void CActorInstance::AttachAcce(DWORD dwItemIndex, DWORD dwParentPartIndex, DWORD dwPartIndex)
+{
+	if (dwPartIndex >= CRaceData::PART_MAX_NUM)
+		return;
+
+	m_adwPartItemID[dwPartIndex] = dwItemIndex;
+
+	CItemData* pItemData;
+	if (!CItemManager::Instance().GetItemDataPointer(dwItemIndex, &pItemData))
+	{
+		RegisterModelThing(dwPartIndex, NULL);
+		SetModelInstance(dwPartIndex, dwPartIndex, 0);
+
+		RegisterModelThing(CRaceData::PART_ACCE, NULL);
+		SetModelInstance(CRaceData::PART_ACCE, CRaceData::PART_ACCE, 0);
+
+		RefreshActorInstance();
+		return;
+	}
+
+	AttachAcce(dwParentPartIndex, CRaceData::PART_ACCE, pItemData);
+}
+
+void CActorInstance::AttachAcce(DWORD dwParentPartIndex, DWORD dwPartIndex, CItemData* pItemData)
+{
+	if (!pItemData)
+		return;
+
+	if (CRaceData::PART_ACCE == dwPartIndex)
+		RegisterModelThing(CRaceData::PART_ACCE, pItemData->GetSubModelThing());
+	else
+		RegisterModelThing(dwPartIndex, pItemData->GetModelThing());
+
+	for (DWORD i = 0; i < pItemData->GetLODModelThingCount(); ++i)
+	{
+		CGraphicThing* pThing;
+		if (!pItemData->GetLODModelThingPointer(i, &pThing))
+			continue;
+
+		RegisterLODThing(dwPartIndex, pThing);
+	}
+
+	SetModelInstance(dwPartIndex, dwPartIndex, 0);
+	AttachModelInstance(dwParentPartIndex, "Bip01 Spine2", dwPartIndex);
+
+	SMaterialData kMaterialData;
+	kMaterialData.pImage = NULL;
+	kMaterialData.isSpecularEnable = TRUE;
+	kMaterialData.fSpecularPower = pItemData->GetSpecularPowerf();
+	kMaterialData.bSphereMapIndex = 1;
+	SetMaterialData(dwPartIndex, NULL, kMaterialData);
+}
+#endif
+
+#if defined(ENABLE_QUIVER_SYSTEM)
+void CActorInstance::SetQuiverEquipped(bool bEquipped)
+{
+	m_bIsQuiverEquipped = bEquipped;
+}
+
+void CActorInstance::SetQuiverEffectID(DWORD dwEffectID)
+{
+	m_dwQuiverEffectID = dwEffectID;
+}
+#endif
+
+void CActorInstance::ChangePart(DWORD dwPartIndex, DWORD dwItemIndex)
+{
+	m_adwPartItemID[dwPartIndex] = dwItemIndex;
+}
diff --git a/src-client/Client/GameLib/RaceMotionData.cpp b/src-client/Client/GameLib/RaceMotionData.cpp
index ed04e16..d404b27 100644
--- a/src-client/Client/GameLib/RaceMotionData.cpp
+++ b/src-client/Client/GameLib/RaceMotionData.cpp
@@ -1,4 +1,5 @@
 #include "StdAfx.h"
+#include "../EterPack/EterPackManager.h"
 #include "../EffectLib/EffectManager.h"
 #include "FlyingObjectManager.h"
 #include "RaceMotionData.h"
@@ -504,6 +505,10 @@ bool CRaceMotionData::LoadMotionData(const char* c_szFileName)
 
 bool CRaceMotionData::LoadSoundScriptData(const char* c_szFileName)
 {
+	// [Perf] Avoid repeated I/O and parser work for missing sound scripts
+	if (!CEterPackManager::Instance().isExist(c_szFileName))
+		return true;
+
 	NSound::TSoundDataVector SoundDataVector;
 	if (!NSound::LoadSoundInformationPiece(c_szFileName, SoundDataVector))
 	{
diff --git a/src-client/Client/ScriptLib/PythonLauncher.cpp b/src-client/Client/ScriptLib/PythonLauncher.cpp
index 88b16b6..5a984d2 100644
--- a/src-client/Client/ScriptLib/PythonLauncher.cpp
+++ b/src-client/Client/ScriptLib/PythonLauncher.cpp
@@ -1,308 +1,409 @@
-#include "StdAfx.h"
-#include <Python-2.7/frameobject.h>
-#include "../EterPack/EterPackManager.h"
-
-#include "PythonLauncher.h"
-
-CPythonLauncher::CPythonLauncher()
-{
-	Py_Initialize();
-}
-
-CPythonLauncher::~CPythonLauncher()
-{
-	Clear();
-}
-
-void CPythonLauncher::Clear()
-{
-	Py_Finalize();
-}
-
-std::string g_stTraceBuffer[512];
-int	g_nCurTraceN = 0;
-
-void Traceback()
-{
-	std::string str;
-
-	for (int i = 0; i < g_nCurTraceN; ++i)
-	{
-		str.append(g_stTraceBuffer[i]);
-		str.append("\n");
-	}
-
-	PyObject* exc;
-	PyObject* v;
-	PyObject* tb;
-	const char* errStr;
-
-	PyErr_Fetch(&exc, &v, &tb);
-
-	if (PyString_Check(v))
-	{
-		errStr = PyString_AS_STRING(v);
-		str.append("Error: ");
-		str.append(errStr);
-
-		Tracef("%s\n", errStr);
-	}
-	Py_DECREF(exc);
-	Py_DECREF(v);
-	Py_DECREF(tb);
-	LogBoxf("Traceback:\n\n%s\n", str.c_str());
-}
-
-int TraceFunc(PyObject* obj, PyFrameObject* f, int what, PyObject* arg)
-{
-	const char* funcname;
-	char szTraceBuffer[128];
-
-	switch (what)
-	{
-		case PyTrace_CALL:
-			if (g_nCurTraceN >= 512)
-				return 0;
-
-			if (Py_OptimizeFlag)
-				f->f_lineno = PyCode_Addr2Line(f->f_code, f->f_lasti);
-
-			funcname = PyString_AsString(f->f_code->co_name);
-
-			_snprintf(szTraceBuffer, sizeof(szTraceBuffer), "Call: File \"%s\", line %d, in %s",
-				PyString_AsString(f->f_code->co_filename),
-				f->f_lineno,
-				funcname);
-
-			g_stTraceBuffer[g_nCurTraceN++] = szTraceBuffer;
-			break;
-
-		case PyTrace_RETURN:
-			if (g_nCurTraceN > 0)
-				--g_nCurTraceN;
-			break;
-
-		case PyTrace_EXCEPTION:
-			if (g_nCurTraceN >= 512)
-				return 0;
-
-			PyObject* exc_type, * exc_value, * exc_traceback;
-
-			PyTuple_GetObject(arg, 0, &exc_type);
-			PyTuple_GetObject(arg, 1, &exc_value);
-			PyTuple_GetObject(arg, 2, &exc_traceback);
-
-			int len;
-			const char* exc_str;
-			PyObject_AsCharBuffer(exc_type, &exc_str, &len);
-
-			_snprintf(szTraceBuffer, sizeof(szTraceBuffer), "Exception: File \"%s\", line %d, in %s",
-				PyString_AS_STRING(f->f_code->co_filename),
-				f->f_lineno,
-				PyString_AS_STRING(f->f_code->co_name));
-
-			g_stTraceBuffer[g_nCurTraceN++] = szTraceBuffer;
-
-			break;
-	}
-	return 0;
-}
-
-void CPythonLauncher::SetTraceFunc(int (*pFunc)(PyObject* obj, PyFrameObject* f, int what, PyObject* arg))
-{
-	PyEval_SetTrace(pFunc, NULL);
-}
-
-bool CPythonLauncher::Create(const char* c_szProgramName)
-{
-	NANOBEGIN
-		Py_SetProgramName((char*)c_szProgramName);
-#ifdef _DEBUG
-	PyEval_SetTrace(TraceFunc, NULL);
-#endif
-	m_poModule = PyImport_AddModule((char*)"__main__");
-
-	if (!m_poModule)
-		return false;
-
-	m_poDic = PyModule_GetDict(m_poModule);
-
-	PyObject* builtins = PyImport_ImportModule("__builtin__");
-	PyModule_AddIntConstant(builtins, "TRUE", 1);
-	PyModule_AddIntConstant(builtins, "FALSE", 0);
-	PyDict_SetItemString(m_poDic, "__builtins__", builtins);
-	Py_DECREF(builtins);
-
-	if (!RunLine("import __main__"))
-		return false;
-
-	if (!RunLine("import sys"))
-		return false;
-
-	NANOEND
-		return true;
-}
-
-bool CPythonLauncher::RunCompiledFile(const char* c_szFileName)
-{
-	NANOBEGIN
-		FILE* fp = fopen(c_szFileName, "rb");
-
-	if (!fp)
-		return false;
-
-	PyCodeObject* co;
-	PyObject* v;
-	long magic;
-	long PyImport_GetMagicNumber(void);
-
-	magic = _PyMarshal_ReadLongFromFile(fp);
-
-	if (magic != PyImport_GetMagicNumber())
-	{
-		PyErr_SetString(PyExc_RuntimeError, "Bad magic number in .pyc file");
-		fclose(fp);
-		return false;
-	}
-
-	_PyMarshal_ReadLongFromFile(fp);
-	v = _PyMarshal_ReadLastObjectFromFile(fp);
-
-	fclose(fp);
-
-	if (!v || !PyCode_Check(v))
-	{
-		Py_XDECREF(v);
-		PyErr_SetString(PyExc_RuntimeError, "Bad code object in .pyc file");
-		return false;
-	}
-
-	co = (PyCodeObject*)v;
-	v = PyEval_EvalCode(co, m_poDic, m_poDic);
-	//if (v && flags)
-	//	flags->cf_flags |= (co->co_flags & PyCF_MASK);
-	Py_DECREF(co);
-	if (!v)
-	{
-		Traceback();
-		return false;
-	}
-
-	Py_DECREF(v);
-	if (Py_FlushLine())
-		PyErr_Clear();
-
-	NANOEND
-		return true;
-}
-
-bool CPythonLauncher::RunMemoryTextFile(const char* c_szFileName, UINT uFileSize, const VOID* c_pvFileData)
-{
-	NANOBEGIN
-		const CHAR* c_pcFileData = (const CHAR*)c_pvFileData;
-
-	std::string stConvFileData;
-	stConvFileData.reserve(uFileSize);
-#if !defined(__PY_SECURE_EXEC_MEM_FILE__)
-	stConvFileData += "exec(compile('''";
-#endif
-
-	// ConvertPythonTextFormat
-	for (UINT i = 0; i < uFileSize; ++i)
-	{
-		if (c_pcFileData[i] != 13)
-			stConvFileData += c_pcFileData[i];
-	}
-
-#if !defined(__PY_SECURE_EXEC_MEM_FILE__)
-	stConvFileData += "''', ";
-	stConvFileData += "'";
-	stConvFileData += c_szFileName;
-	stConvFileData += "', ";
-	stConvFileData += "'exec'))";
-#endif
-
-	const CHAR* c_pcConvFileData = stConvFileData.c_str();
-#if defined(__PY_SECURE_EXEC_MEM_FILE__)
-	PyObject* pObj = Py_CompileString(c_pcConvFileData, c_szFileName, Py_file_input);
-	if (pObj == nullptr)
-	{
-		NANOEND
-			return false;
-	}
-
-	PyObject* pResult = PyEval_EvalCode((PyCodeObject*)pObj, m_poDic, m_poDic);
-	Py_DECREF(pObj);
-	if (pResult == nullptr)
-	{
-		NANOEND
-			return false;
-	}
-
-	Py_DECREF(pResult);
-
-	if (Py_FlushLine())
-		PyErr_Clear();
-
-	NANOEND
-		return true;
-#else
-	NANOEND
-		return RunLine(c_pcConvFileData);
-#endif
-}
-
-bool CPythonLauncher::RunFile(const char* c_szFileName)
-{
-	char* acBufData = NULL;
-	DWORD dwBufSize = 0;
-
-	{
-		CMappedFile file;
-		const VOID* pvData;
-		CEterPackManager::Instance().Get(file, c_szFileName, &pvData);
-
-		dwBufSize = file.Size();
-		if (dwBufSize == 0)
-			return false;
-
-		acBufData = new char[dwBufSize];
-		memcpy(acBufData, pvData, dwBufSize);
-	}
-
-	bool ret = false;
-
-	ret = RunMemoryTextFile(c_szFileName, dwBufSize, acBufData);
-
-	delete[] acBufData;
-
-	return ret;
-}
-
-bool CPythonLauncher::RunLine(const char* c_szSrc)
-{
-	PyObject* v = PyRun_String((char*)c_szSrc, Py_file_input, m_poDic, m_poDic);
-
-	if (!v)
-	{
-		Traceback();
-		return false;
-	}
-
-	Py_DECREF(v);
-	return true;
-}
-
-const char* CPythonLauncher::GetError()
-{
-	PyObject* exc;
-	PyObject* v;
-	PyObject* tb;
-
-	PyErr_Fetch(&exc, &v, &tb);
-
-	if (PyString_Check(v))
-		return PyString_AS_STRING(v);
-
-	return "";
-}
+#include "StdAfx.h"
+#include <Python-2.7/frameobject.h>
+#include "../EterPack/EterPackManager.h"
+
+#include "PythonLauncher.h"
+
+// ---------------------------------------------------------------------------
+// Python import hardening (anti-injection)
+// Blocks importing dangerous stdlib modules that allow filesystem/process/net.
+// ---------------------------------------------------------------------------
+static PyObject* g_poOriginalImport = nullptr;
+
+static bool IsBlockedPythonModule(const char* name)
+{
+	if (!name || !*name)
+		return true;
+
+	std::string mod(name);
+	const size_t dot = mod.find('.');
+	if (dot != std::string::npos)
+		mod.resize(dot);
+
+	static const char* kBlocked[] = {
+		"os", "posix", "nt", "_winreg", "winreg", "msvcrt",
+		"subprocess", "popen2", "commands",
+		"socket", "ssl", "select",
+		"ctypes",
+		"urllib", "urllib2", "httplib", "ftplib", "telnetlib",
+		"shutil", "glob",
+		"pickle", "cPickle", "marshal", "imp",
+		"multiprocessing", "thread", "threading",
+		"resource", "signal"
+	};
+
+	for (size_t i = 0; i < sizeof(kBlocked) / sizeof(kBlocked[0]); ++i)
+	{
+		if (mod == kBlocked[i])
+			return true;
+	}
+	return false;
+}
+
+static PyObject* RestrictedImport(PyObject*, PyObject* args, PyObject* kwargs)
+{
+	const char* name = nullptr;
+	PyObject* globals = Py_None;
+	PyObject* locals  = Py_None;
+	PyObject* fromlist = Py_None;
+	int level = -1;
+
+	static char* kwlist[] = { (char*)"name", (char*)"globals", (char*)"locals", (char*)"fromlist", (char*)"level", nullptr };
+	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|OOOi:__import__", kwlist, &name, &globals, &locals, &fromlist, &level))
+		return nullptr;
+
+	if (IsBlockedPythonModule(name))
+	{
+		PyErr_Format(PyExc_ImportError, "Blocked python module: %s", name);
+		return nullptr;
+	}
+
+	if (!g_poOriginalImport)
+	{
+		PyErr_SetString(PyExc_ImportError, "Original __import__ not available");
+		return nullptr;
+	}
+
+	return PyObject_Call(g_poOriginalImport, args, kwargs);
+}
+
+static void InstallRestrictedImport()
+{
+	PyObject* builtins = PyImport_ImportModule("__builtin__");
+	if (!builtins)
+	{
+		PyErr_Clear();
+		return;
+	}
+
+	PyObject* dict = PyModule_GetDict(builtins);
+	if (!dict)
+	{
+		Py_DECREF(builtins);
+		return;
+	}
+
+	PyObject* original = PyDict_GetItemString(dict, "__import__");
+	if (original)
+	{
+		g_poOriginalImport = original;
+		Py_INCREF(g_poOriginalImport);
+	}
+
+	static PyMethodDef sImportDef = {
+		"__import__",
+		(PyCFunction)RestrictedImport,
+		METH_VARARGS | METH_KEYWORDS,
+		"Restricted __import__ (blocks dangerous stdlib modules)"
+	};
+
+	PyObject* importFunc = PyCFunction_New(&sImportDef, nullptr);
+	if (importFunc)
+		PyDict_SetItemString(dict, "__import__", importFunc);
+	Py_XDECREF(importFunc);
+	Py_DECREF(builtins);
+}
+
+CPythonLauncher::CPythonLauncher()
+{
+	Py_Initialize();
+	InstallRestrictedImport();
+}
+
+CPythonLauncher::~CPythonLauncher()
+{
+	Clear();
+}
+
+void CPythonLauncher::Clear()
+{
+	Py_Finalize();
+}
+
+std::string g_stTraceBuffer[512];
+int	g_nCurTraceN = 0;
+
+void Traceback()
+{
+	std::string str;
+
+	for (int i = 0; i < g_nCurTraceN; ++i)
+	{
+		str.append(g_stTraceBuffer[i]);
+		str.append("\n");
+	}
+
+	PyObject* exc;
+	PyObject* v;
+	PyObject* tb;
+	const char* errStr;
+
+	PyErr_Fetch(&exc, &v, &tb);
+
+	if (PyString_Check(v))
+	{
+		errStr = PyString_AS_STRING(v);
+		str.append("Error: ");
+		str.append(errStr);
+
+		Tracef("%s\n", errStr);
+	}
+	Py_DECREF(exc);
+	Py_DECREF(v);
+	Py_DECREF(tb);
+	LogBoxf("Traceback:\n\n%s\n", str.c_str());
+}
+
+int TraceFunc(PyObject* obj, PyFrameObject* f, int what, PyObject* arg)
+{
+	const char* funcname;
+	char szTraceBuffer[128];
+
+	switch (what)
+	{
+		case PyTrace_CALL:
+			if (g_nCurTraceN >= 512)
+				return 0;
+
+			if (Py_OptimizeFlag)
+				f->f_lineno = PyCode_Addr2Line(f->f_code, f->f_lasti);
+
+			funcname = PyString_AsString(f->f_code->co_name);
+
+			_snprintf(szTraceBuffer, sizeof(szTraceBuffer), "Call: File \"%s\", line %d, in %s",
+				PyString_AsString(f->f_code->co_filename),
+				f->f_lineno,
+				funcname);
+
+			g_stTraceBuffer[g_nCurTraceN++] = szTraceBuffer;
+			break;
+
+		case PyTrace_RETURN:
+			if (g_nCurTraceN > 0)
+				--g_nCurTraceN;
+			break;
+
+		case PyTrace_EXCEPTION:
+			if (g_nCurTraceN >= 512)
+				return 0;
+
+			PyObject* exc_type, * exc_value, * exc_traceback;
+
+			PyTuple_GetObject(arg, 0, &exc_type);
+			PyTuple_GetObject(arg, 1, &exc_value);
+			PyTuple_GetObject(arg, 2, &exc_traceback);
+
+			int len;
+			const char* exc_str;
+			PyObject_AsCharBuffer(exc_type, &exc_str, &len);
+
+			_snprintf(szTraceBuffer, sizeof(szTraceBuffer), "Exception: File \"%s\", line %d, in %s",
+				PyString_AS_STRING(f->f_code->co_filename),
+				f->f_lineno,
+				PyString_AS_STRING(f->f_code->co_name));
+
+			g_stTraceBuffer[g_nCurTraceN++] = szTraceBuffer;
+
+			break;
+	}
+	return 0;
+}
+
+void CPythonLauncher::SetTraceFunc(int (*pFunc)(PyObject* obj, PyFrameObject* f, int what, PyObject* arg))
+{
+	PyEval_SetTrace(pFunc, NULL);
+}
+
+bool CPythonLauncher::Create(const char* c_szProgramName)
+{
+	NANOBEGIN
+		Py_SetProgramName((char*)c_szProgramName);
+#ifdef _DEBUG
+	PyEval_SetTrace(TraceFunc, NULL);
+#endif
+	m_poModule = PyImport_AddModule((char*)"__main__");
+
+	if (!m_poModule)
+		return false;
+
+	m_poDic = PyModule_GetDict(m_poModule);
+
+	PyObject* builtins = PyImport_ImportModule("__builtin__");
+	PyModule_AddIntConstant(builtins, "TRUE", 1);
+	PyModule_AddIntConstant(builtins, "FALSE", 0);
+	PyDict_SetItemString(m_poDic, "__builtins__", builtins);
+	Py_DECREF(builtins);
+
+	if (!RunLine("import __main__"))
+		return false;
+
+	if (!RunLine("import sys"))
+		return false;
+
+	NANOEND
+		return true;
+}
+
+bool CPythonLauncher::RunCompiledFile(const char* c_szFileName)
+{
+	NANOBEGIN
+		FILE* fp = fopen(c_szFileName, "rb");
+
+	if (!fp)
+		return false;
+
+	PyCodeObject* co;
+	PyObject* v;
+	long magic;
+	long PyImport_GetMagicNumber(void);
+
+	magic = _PyMarshal_ReadLongFromFile(fp);
+
+	if (magic != PyImport_GetMagicNumber())
+	{
+		PyErr_SetString(PyExc_RuntimeError, "Bad magic number in .pyc file");
+		fclose(fp);
+		return false;
+	}
+
+	_PyMarshal_ReadLongFromFile(fp);
+	v = _PyMarshal_ReadLastObjectFromFile(fp);
+
+	fclose(fp);
+
+	if (!v || !PyCode_Check(v))
+	{
+		Py_XDECREF(v);
+		PyErr_SetString(PyExc_RuntimeError, "Bad code object in .pyc file");
+		return false;
+	}
+
+	co = (PyCodeObject*)v;
+	v = PyEval_EvalCode(co, m_poDic, m_poDic);
+	//if (v && flags)
+	//	flags->cf_flags |= (co->co_flags & PyCF_MASK);
+	Py_DECREF(co);
+	if (!v)
+	{
+		Traceback();
+		return false;
+	}
+
+	Py_DECREF(v);
+	if (Py_FlushLine())
+		PyErr_Clear();
+
+	NANOEND
+		return true;
+}
+
+bool CPythonLauncher::RunMemoryTextFile(const char* c_szFileName, UINT uFileSize, const VOID* c_pvFileData)
+{
+	NANOBEGIN
+		const CHAR* c_pcFileData = (const CHAR*)c_pvFileData;
+
+	std::string stConvFileData;
+	stConvFileData.reserve(uFileSize);
+#if !defined(__PY_SECURE_EXEC_MEM_FILE__)
+	stConvFileData += "exec(compile('''";
+#endif
+
+	// ConvertPythonTextFormat
+	for (UINT i = 0; i < uFileSize; ++i)
+	{
+		if (c_pcFileData[i] != 13)
+			stConvFileData += c_pcFileData[i];
+	}
+
+#if !defined(__PY_SECURE_EXEC_MEM_FILE__)
+	stConvFileData += "''', ";
+	stConvFileData += "'";
+	stConvFileData += c_szFileName;
+	stConvFileData += "', ";
+	stConvFileData += "'exec'))";
+#endif
+
+	const CHAR* c_pcConvFileData = stConvFileData.c_str();
+#if defined(__PY_SECURE_EXEC_MEM_FILE__)
+	PyObject* pObj = Py_CompileString(c_pcConvFileData, c_szFileName, Py_file_input);
+	if (pObj == nullptr)
+	{
+		NANOEND
+			return false;
+	}
+
+	PyObject* pResult = PyEval_EvalCode((PyCodeObject*)pObj, m_poDic, m_poDic);
+	Py_DECREF(pObj);
+	if (pResult == nullptr)
+	{
+		NANOEND
+			return false;
+	}
+
+	Py_DECREF(pResult);
+
+	if (Py_FlushLine())
+		PyErr_Clear();
+
+	NANOEND
+		return true;
+#else
+	NANOEND
+		return RunLine(c_pcConvFileData);
+#endif
+}
+
+bool CPythonLauncher::RunFile(const char* c_szFileName)
+{
+	char* acBufData = NULL;
+	DWORD dwBufSize = 0;
+
+	{
+		CMappedFile file;
+		const VOID* pvData;
+		CEterPackManager::Instance().Get(file, c_szFileName, &pvData);
+
+		dwBufSize = file.Size();
+		if (dwBufSize == 0)
+			return false;
+
+		acBufData = new char[dwBufSize];
+		memcpy(acBufData, pvData, dwBufSize);
+	}
+
+	bool ret = false;
+
+	ret = RunMemoryTextFile(c_szFileName, dwBufSize, acBufData);
+
+	delete[] acBufData;
+
+	return ret;
+}
+
+bool CPythonLauncher::RunLine(const char* c_szSrc)
+{
+	PyObject* v = PyRun_String((char*)c_szSrc, Py_file_input, m_poDic, m_poDic);
+
+	if (!v)
+	{
+		Traceback();
+		return false;
+	}
+
+	Py_DECREF(v);
+	return true;
+}
+
+const char* CPythonLauncher::GetError()
+{
+	PyObject* exc;
+	PyObject* v;
+	PyObject* tb;
+
+	PyErr_Fetch(&exc, &v, &tb);
+
+	if (PyString_Check(v))
+		return PyString_AS_STRING(v);
+
+	return "";
+}
diff --git a/src-client/Client/UserInterface/GuildMarkDownloader.cpp b/src-client/Client/UserInterface/GuildMarkDownloader.cpp
index 4bf3591..3582271 100644
--- a/src-client/Client/UserInterface/GuildMarkDownloader.cpp
+++ b/src-client/Client/UserInterface/GuildMarkDownloader.cpp
@@ -1,545 +1,559 @@
-#include "StdAfx.h"
-
-#include "PythonNetworkStream.h"
-#include "GuildMarkDownloader.h"
-#include "PythonCharacterManager.h"
-#include "Packet.h"
-#include "Test.h"
-
-// MARK_BUG_FIX
-struct SMarkIndex
-{
-	WORD guild_id;
-	WORD mark_id;
-};
-// END_OFMARK_BUG_FIX
-
-CGuildMarkDownloader::CGuildMarkDownloader()
-{
-	SetRecvBufferSize(640 * 1024);
-	SetSendBufferSize(1024);
-	__Initialize();
-}
-
-CGuildMarkDownloader::~CGuildMarkDownloader()
-{
-	__OfflineState_Set();
-}
-
-bool CGuildMarkDownloader::Connect(const CNetworkAddress& c_rkNetAddr, DWORD dwHandle, DWORD dwRandomKey)
-{
-	__OfflineState_Set();
-
-	m_dwHandle = dwHandle;
-	m_dwRandomKey = dwRandomKey;
-	m_dwTodo = TODO_RECV_MARK;
-	return CNetworkStream::Connect(c_rkNetAddr);
-}
-
-bool CGuildMarkDownloader::ConnectToRecvSymbol(const CNetworkAddress& c_rkNetAddr, DWORD dwHandle, DWORD dwRandomKey, const std::vector<DWORD>& c_rkVec_dwGuildID)
-{
-	__OfflineState_Set();
-
-	m_dwHandle = dwHandle;
-	m_dwRandomKey = dwRandomKey;
-	m_dwTodo = TODO_RECV_SYMBOL;
-	m_kVec_dwGuildID = c_rkVec_dwGuildID;
-	return CNetworkStream::Connect(c_rkNetAddr);
-}
-
-void CGuildMarkDownloader::Process()
-{
-	CNetworkStream::Process();
-
-	if (!__StateProcess())
-	{
-		__OfflineState_Set();
-		Disconnect();
-	}
-}
-
-void CGuildMarkDownloader::OnConnectFailure()
-{
-	__OfflineState_Set();
-}
-
-void CGuildMarkDownloader::OnConnectSuccess()
-{
-	__LoginState_Set();
-}
-
-void CGuildMarkDownloader::OnRemoteDisconnect()
-{
-	__OfflineState_Set();
-}
-
-void CGuildMarkDownloader::OnDisconnect()
-{
-	__OfflineState_Set();
-}
-
-void CGuildMarkDownloader::__Initialize()
-{
-	m_eState = STATE_OFFLINE;
-	m_pkMarkMgr = NULL;
-	m_currentRequestingImageIndex = 0;
-	m_dwBlockIndex = 0;
-	m_dwBlockDataPos = 0;
-	m_dwBlockDataSize = 0;
-
-	m_dwHandle = 0;
-	m_dwRandomKey = 0;
-	m_dwTodo = TODO_RECV_NONE;
-	m_kVec_dwGuildID.clear();
-}
-
-bool CGuildMarkDownloader::__StateProcess()
-{
-	switch (m_eState)
-	{
-	case STATE_LOGIN:
-		return __LoginState_Process();
-		break;
-	case STATE_COMPLETE:
-		return false;
-	}
-
-	return true;
-}
-
-void CGuildMarkDownloader::__OfflineState_Set()
-{
-	__Initialize();
-}
-
-void CGuildMarkDownloader::__CompleteState_Set()
-{
-	m_eState = STATE_COMPLETE;
-	CPythonCharacterManager::Instance().RefreshAllGuildMark();
-}
-
-void CGuildMarkDownloader::__LoginState_Set()
-{
-	m_eState = STATE_LOGIN;
-}
-
-bool CGuildMarkDownloader::__LoginState_Process()
-{
-	BYTE header;
-
-	if (!Peek(sizeof(BYTE), &header))
-		return true;
-
-	if (IsSecurityMode())
-	{
-		if (0 == header)
-		{
-			if (!Recv(sizeof(header), &header))
-				return false;
-
-			return true;
-		}
-	}
-
-	UINT needPacketSize = __GetPacketSize(header);
-
-	if (!needPacketSize)
-		return false;
-
-	if (!Peek(needPacketSize))
-		return true;
-
-	__DispatchPacket(header);
-	return true;
-}
-
-// MARK_BUG_FIX
-UINT CGuildMarkDownloader::__GetPacketSize(UINT header)
-{
-	switch (header)
-	{
-	case HEADER_GC_PHASE:
-		return sizeof(TPacketGCPhase);
-	case HEADER_GC_HANDSHAKE:
-		return sizeof(TPacketGCHandshake);
-	case HEADER_GC_PING:
-		return sizeof(TPacketGCPing);
-	case HEADER_GC_MARK_IDXLIST:
-		return sizeof(TPacketGCMarkIDXList);
-	case HEADER_GC_MARK_BLOCK:
-		return sizeof(TPacketGCMarkBlock);
-	case HEADER_GC_GUILD_SYMBOL_DATA:
-		return sizeof(TPacketGCGuildSymbolData);
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	case HEADER_GC_KEY_AGREEMENT:
-		return sizeof(TPacketKeyAgreement);
-	case HEADER_GC_KEY_AGREEMENT_COMPLETED:
-		return sizeof(TPacketKeyAgreementCompleted);
-#endif
-	}
-	return 0;
-}
-
-bool CGuildMarkDownloader::__DispatchPacket(UINT header)
-{
-	switch (header)
-	{
-	case HEADER_GC_PHASE:
-		return __LoginState_RecvPhase();
-	case HEADER_GC_HANDSHAKE:
-		return __LoginState_RecvHandshake();
-	case HEADER_GC_PING:
-		return __LoginState_RecvPing();
-	case HEADER_GC_MARK_IDXLIST:
-		return __LoginState_RecvMarkIndex();
-	case HEADER_GC_MARK_BLOCK:
-		return __LoginState_RecvMarkBlock();
-	case HEADER_GC_GUILD_SYMBOL_DATA:
-		return __LoginState_RecvSymbolData();
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	case HEADER_GC_KEY_AGREEMENT:
-		return __LoginState_RecvKeyAgreement();
-	case HEADER_GC_KEY_AGREEMENT_COMPLETED:
-		return __LoginState_RecvKeyAgreementCompleted();
-#endif
-	}
-	return false;
-}
-// END_OF_MARK_BUG_FIX
-
-bool CGuildMarkDownloader::__LoginState_RecvHandshake()
-{
-	TPacketGCHandshake kPacketHandshake;
-	if (!Recv(sizeof(kPacketHandshake), &kPacketHandshake))
-		return false;
-
-	TPacketCGMarkLogin kPacketMarkLogin;
-
-	kPacketMarkLogin.header = HEADER_CG_MARK_LOGIN;
-	kPacketMarkLogin.handle = m_dwHandle;
-	kPacketMarkLogin.random_key = m_dwRandomKey;
-
-	if (!Send(sizeof(kPacketMarkLogin), &kPacketMarkLogin))
-		return false;
-
-	return true;
-}
-
-bool CGuildMarkDownloader::__LoginState_RecvPing()
-{
-	TPacketGCPing kPacketPing;
-
-	if (!Recv(sizeof(kPacketPing), &kPacketPing))
-		return false;
-
-	TPacketCGPong kPacketPong;
-	kPacketPong.bHeader = HEADER_CG_PONG;
-
-	if (!Send(sizeof(TPacketCGPong), &kPacketPong))
-		return false;
-
-	if (IsSecurityMode())
-		return SendSequence();
-	else
-		return true;
-}
-
-bool CGuildMarkDownloader::__LoginState_RecvPhase()
-{
-	TPacketGCPhase kPacketPhase;
-
-	if (!Recv(sizeof(kPacketPhase), &kPacketPhase))
-		return false;
-
-	if (kPacketPhase.phase == PHASE_LOGIN)
-	{
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-		const char* key = LocaleService_GetSecurityKey();
-		SetSecurityMode(true, key);
-#endif
-
-		switch (m_dwTodo)
-		{
-		case TODO_RECV_NONE:
-		{
-			assert(!"CGuildMarkDownloader::__LoginState_RecvPhase - Todo type is none");
-			break;
-		}
-		case TODO_RECV_MARK:
-		{
-			// MARK_BUG_FIX
-			if (!__SendMarkIDXList())
-				return false;
-			// END_OF_MARK_BUG_FIX
-			break;
-		}
-		case TODO_RECV_SYMBOL:
-		{
-			if (!__SendSymbolCRCList())
-				return false;
-			break;
-		}
-		}
-	}
-
-	return true;
-}
-
-// MARK_BUG_FIX
-bool CGuildMarkDownloader::__SendMarkIDXList()
-{
-	TPacketCGMarkIDXList kPacketMarkIDXList;
-	kPacketMarkIDXList.header = HEADER_CG_MARK_IDXLIST;
-	if (!Send(sizeof(kPacketMarkIDXList), &kPacketMarkIDXList))
-		return false;
-
-	return true;
-}
-
-bool CGuildMarkDownloader::__LoginState_RecvMarkIndex()
-{
-	TPacketGCMarkIDXList kPacketMarkIndex;
-
-	if (!Peek(sizeof(kPacketMarkIndex), &kPacketMarkIndex))
-		return false;
-
-	//DWORD bufSize = sizeof(WORD) * 2 * kPacketMarkIndex.count;
-
-	if (!Peek(kPacketMarkIndex.bufSize))
-		return false;
-
-	Recv(sizeof(kPacketMarkIndex));
-
-	WORD guildID, markID;
-
-	for (DWORD i = 0; i < kPacketMarkIndex.count; ++i)
-	{
-		Recv(sizeof(WORD), &guildID);
-		Recv(sizeof(WORD), &markID);
-
-		// ±æµåID -> ¸¶Å©ID ÀÎµ¦½º µî·Ï
-		CGuildMarkManager::Instance().AddMarkIDByGuildID(guildID, markID);
-	}
-
-	// ¸ðµç ¸¶Å© ÀÌ¹ÌÁö ÆÄÀÏÀ» ·ÎµåÇÑ´Ù. (ÆÄÀÏÀÌ ¾øÀ¸¸é ¸¸µé¾îÁü)
-	CGuildMarkManager::Instance().LoadMarkImages();
-
-	// MARK_BUG_FIX
-	CPythonNetworkStream& rkNetStream = CPythonNetworkStream::Instance();
-	rkNetStream.RefreshGuildMark();
-	// END_OF_MARK_BUG_FIX
-
-	m_currentRequestingImageIndex = 0;
-	__SendMarkCRCList();
-	return true;
-}
-
-bool CGuildMarkDownloader::__SendMarkCRCList()
-{
-	TPacketCGMarkCRCList kPacketMarkCRCList;
-
-	if (!CGuildMarkManager::Instance().GetBlockCRCList(m_currentRequestingImageIndex, kPacketMarkCRCList.crclist))
-		__CompleteState_Set();
-	else
-	{
-		kPacketMarkCRCList.header = HEADER_CG_MARK_CRCLIST;
-		kPacketMarkCRCList.imgIdx = m_currentRequestingImageIndex;
-		++m_currentRequestingImageIndex;
-
-		if (!Send(sizeof(kPacketMarkCRCList), &kPacketMarkCRCList))
-			return false;
-	}
-	return true;
-}
-
-bool CGuildMarkDownloader::__LoginState_RecvMarkBlock()
-{
-	TPacketGCMarkBlock kPacket;
-
-	if (!Peek(sizeof(kPacket), &kPacket))
-		return false;
-
-	if (!Peek(kPacket.bufSize))
-		return false;
-
-	Recv(sizeof(kPacket));
-
-	BYTE posBlock;
-	DWORD compSize;
-	char compBuf[SGuildMarkBlock::MAX_COMP_SIZE];
-
-	for (DWORD i = 0; i < kPacket.count; ++i)
-	{
-		Recv(sizeof(BYTE), &posBlock);
-		Recv(sizeof(DWORD), &compSize);
-
-		if (compSize > SGuildMarkBlock::MAX_COMP_SIZE)
-		{
-			TraceError("RecvMarkBlock: data corrupted");
-			Recv(compSize);
-		}
-		else
-		{
-			Recv(compSize, compBuf);
-			// ¾ÐÃàµÈ ÀÌ¹ÌÁö¸¦ ½ÇÁ¦·Î ÀúÀåÇÑ´Ù. CRCµî ¿©·¯°¡Áö Á¤º¸°¡ ÇÔ²² ºôµåµÈ´Ù.
-			CGuildMarkManager::Instance().SaveBlockFromCompressedData(kPacket.imgIdx, posBlock, (const BYTE*)compBuf, compSize);
-		}
-	}
-
-	if (kPacket.count > 0)
-	{
-		// ¸¶Å© ÀÌ¹ÌÁö ÀúÀå
-		CGuildMarkManager::Instance().SaveMarkImage(kPacket.imgIdx);
-
-		// ¸®¼Ò½º ¸®·Îµù (ÀçÁ¢¼ÓÀ» ¾ÈÇØµµ º»ÀÎ°ÍÀº Àß º¸ÀÌ°Ô ÇÔ)
-		std::string imagePath;
-
-		if (CGuildMarkManager::Instance().GetMarkImageFilename(kPacket.imgIdx, imagePath))
-		{
-			CResource* pResource = CResourceManager::Instance().GetResourcePointer(imagePath.c_str());
-			if (pResource->IsType(CGraphicImage::Type()))
-			{
-				CGraphicImage* pkGrpImg = static_cast<CGraphicImage*>(pResource);
-				pkGrpImg->Reload();
-			}
-		}
-	}
-
-	// ´õ ¿äÃ»ÇÒ °ÍÀÌ ÀÖÀ¸¸é ¿äÃ»ÇÏ°í ¾Æ´Ï¸é ÀÌ¹ÌÁö¸¦ ÀúÀåÇÏ°í Á¾·á
-	if (m_currentRequestingImageIndex < CGuildMarkManager::Instance().GetMarkImageCount())
-		__SendMarkCRCList();
-	else
-		__CompleteState_Set();
-
-	return true;
-}
-// END_OF_MARK_BUG_FIX
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-bool CGuildMarkDownloader::__LoginState_RecvKeyAgreement()
-{
-	TPacketKeyAgreement packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		return false;
-	}
-
-	Tracenf("KEY_AGREEMENT RECV %u", packet.wDataLength);
-
-	TPacketKeyAgreement packetToSend;
-	size_t dataLength = TPacketKeyAgreement::MAX_DATA_LEN;
-	size_t agreedLength = Prepare(packetToSend.data, &dataLength);
-	if (agreedLength == 0)
-	{
-		// ÃÊ±âÈ­ ½ÇÆÐ
-		Disconnect();
-		return false;
-	}
-	assert(dataLength <= TPacketKeyAgreement::MAX_DATA_LEN);
-
-	if (Activate(packet.wAgreedLength, packet.data, packet.wDataLength))
-	{
-		// Key agreement ¼º°ø, ÀÀ´ä Àü¼Û
-		packetToSend.bHeader = HEADER_CG_KEY_AGREEMENT;
-		packetToSend.wAgreedLength = (WORD)agreedLength;
-		packetToSend.wDataLength = (WORD)dataLength;
-
-		if (!Send(sizeof(packetToSend), &packetToSend))
-		{
-			Tracen(" CAccountConnector::__AuthState_RecvKeyAgreement - SendKeyAgreement Error");
-			return false;
-		}
-		Tracenf("KEY_AGREEMENT SEND %u", packetToSend.wDataLength);
-	}
-	else
-	{
-		// Å° Çù»ó ½ÇÆÐ
-		Disconnect();
-		return false;
-	}
-	return true;
-}
-
-bool CGuildMarkDownloader::__LoginState_RecvKeyAgreementCompleted()
-{
-	TPacketKeyAgreementCompleted packet;
-	if (!Recv(sizeof(packet), &packet))
-		return false;
-
-	Tracenf("KEY_AGREEMENT_COMPLETED RECV");
-
-	ActivateCipher();
-
-	return true;
-}
-#endif
-
-bool CGuildMarkDownloader::__SendSymbolCRCList()
-{
-	for (DWORD i = 0; i < m_kVec_dwGuildID.size(); ++i)
-	{
-		TPacketCGSymbolCRC kSymbolCRCPacket;
-		kSymbolCRCPacket.header = HEADER_CG_GUILD_SYMBOL_CRC;
-		kSymbolCRCPacket.dwGuildID = m_kVec_dwGuildID[i];
-
-		std::string strFileName = GetGuildSymbolFileName(m_kVec_dwGuildID[i]);
-		kSymbolCRCPacket.dwCRC = GetFileCRC32(strFileName.c_str());
-		kSymbolCRCPacket.dwSize = GetFileSize(strFileName.c_str());
-#ifdef _DEBUG
-		printf("__SendSymbolCRCList [GuildID:%d / CRC:%u]\n", m_kVec_dwGuildID[i], kSymbolCRCPacket.dwCRC);
-#endif
-		if (!Send(sizeof(kSymbolCRCPacket), &kSymbolCRCPacket))
-			return false;
-	}
-
-	return true;
-}
-
-bool CGuildMarkDownloader::__LoginState_RecvSymbolData()
-{
-	TPacketGCBlankDynamic packet;
-	if (!Peek(sizeof(TPacketGCBlankDynamic), &packet))
-		return true;
-
-#ifdef _DEBUG
-	printf("__LoginState_RecvSymbolData [%d/%d]\n", GetRecvBufferSize(), packet.size);
-#endif
-	if (packet.size > GetRecvBufferSize())
-		return true;
-
-	//////////////////////////////////////////////////////////////
-
-	TPacketGCGuildSymbolData kPacketSymbolData;
-	if (!Recv(sizeof(kPacketSymbolData), &kPacketSymbolData))
-		return false;
-
-	WORD wDataSize = kPacketSymbolData.size - sizeof(kPacketSymbolData);
-	DWORD dwGuildID = kPacketSymbolData.guild_id;
-	BYTE* pbyBuf = new BYTE[wDataSize];
-
-	if (!Recv(wDataSize, pbyBuf))
-	{
-		delete[] pbyBuf;
-		return false;
-	}
-
-	MyCreateDirectory(g_strGuildSymbolPathName.c_str());
-
-	std::string strFileName = GetGuildSymbolFileName(dwGuildID);
-
-	FILE* File = fopen(strFileName.c_str(), "wb");
-	if (!File)
-	{
-		delete[] pbyBuf;
-		return false;
-	}
-	fwrite(pbyBuf, wDataSize, 1, File);
-	fclose(File);
-
-#ifdef _DEBUG
-	printf("__LoginState_RecvSymbolData(filename:%s, datasize:%d, guildid:%d)\n", strFileName.c_str(), wDataSize, dwGuildID);
-#endif
-
-	delete[] pbyBuf;
-	return true;
-}
+#include "StdAfx.h"
+
+#include "PythonNetworkStream.h"
+#include "GuildMarkDownloader.h"
+#include "PythonCharacterManager.h"
+#include "Packet.h"
+#include "Test.h"
+
+// MARK_BUG_FIX
+struct SMarkIndex
+{
+	WORD guild_id;
+	WORD mark_id;
+};
+// END_OFMARK_BUG_FIX
+
+CGuildMarkDownloader::CGuildMarkDownloader()
+{
+	SetRecvBufferSize(640 * 1024);
+	SetSendBufferSize(1024);
+	__Initialize();
+}
+
+CGuildMarkDownloader::~CGuildMarkDownloader()
+{
+	__OfflineState_Set();
+}
+
+bool CGuildMarkDownloader::Connect(const CNetworkAddress& c_rkNetAddr, DWORD dwHandle, DWORD dwRandomKey)
+{
+	__OfflineState_Set();
+
+	m_dwHandle = dwHandle;
+	m_dwRandomKey = dwRandomKey;
+	m_dwTodo = TODO_RECV_MARK;
+	return CNetworkStream::Connect(c_rkNetAddr);
+}
+
+bool CGuildMarkDownloader::ConnectToRecvSymbol(const CNetworkAddress& c_rkNetAddr, DWORD dwHandle, DWORD dwRandomKey, const std::vector<DWORD>& c_rkVec_dwGuildID)
+{
+	__OfflineState_Set();
+
+	m_dwHandle = dwHandle;
+	m_dwRandomKey = dwRandomKey;
+	m_dwTodo = TODO_RECV_SYMBOL;
+	m_kVec_dwGuildID = c_rkVec_dwGuildID;
+	return CNetworkStream::Connect(c_rkNetAddr);
+}
+
+void CGuildMarkDownloader::Process()
+{
+	CNetworkStream::Process();
+
+	if (!__StateProcess())
+	{
+		__OfflineState_Set();
+		Disconnect();
+	}
+}
+
+void CGuildMarkDownloader::OnConnectFailure()
+{
+	__OfflineState_Set();
+}
+
+void CGuildMarkDownloader::OnConnectSuccess()
+{
+	__LoginState_Set();
+}
+
+void CGuildMarkDownloader::OnRemoteDisconnect()
+{
+	__OfflineState_Set();
+}
+
+void CGuildMarkDownloader::OnDisconnect()
+{
+	__OfflineState_Set();
+}
+
+void CGuildMarkDownloader::__Initialize()
+{
+	m_eState = STATE_OFFLINE;
+	m_pkMarkMgr = NULL;
+	m_currentRequestingImageIndex = 0;
+	m_dwBlockIndex = 0;
+	m_dwBlockDataPos = 0;
+	m_dwBlockDataSize = 0;
+
+	m_dwHandle = 0;
+	m_dwRandomKey = 0;
+	m_dwTodo = TODO_RECV_NONE;
+	m_kVec_dwGuildID.clear();
+}
+
+bool CGuildMarkDownloader::__StateProcess()
+{
+	switch (m_eState)
+	{
+	case STATE_LOGIN:
+		return __LoginState_Process();
+		break;
+	case STATE_COMPLETE:
+		return false;
+	}
+
+	return true;
+}
+
+void CGuildMarkDownloader::__OfflineState_Set()
+{
+	__Initialize();
+}
+
+void CGuildMarkDownloader::__CompleteState_Set()
+{
+	m_eState = STATE_COMPLETE;
+	CPythonCharacterManager::Instance().RefreshAllGuildMark();
+}
+
+void CGuildMarkDownloader::__LoginState_Set()
+{
+	m_eState = STATE_LOGIN;
+}
+
+bool CGuildMarkDownloader::__LoginState_Process()
+{
+	BYTE header;
+
+	if (!Peek(sizeof(BYTE), &header))
+		return true;
+
+	if (IsSecurityMode())
+	{
+		if (0 == header)
+		{
+			if (!Recv(sizeof(header), &header))
+				return false;
+
+			return true;
+		}
+	}
+
+	UINT needPacketSize = __GetPacketSize(header);
+
+	if (!needPacketSize)
+		return false;
+
+	if (!Peek(needPacketSize))
+		return true;
+
+	__DispatchPacket(header);
+	return true;
+}
+
+// MARK_BUG_FIX
+UINT CGuildMarkDownloader::__GetPacketSize(UINT header)
+{
+	switch (header)
+	{
+	case HEADER_GC_PHASE:
+		return sizeof(TPacketGCPhase);
+	case HEADER_GC_HANDSHAKE:
+		return sizeof(TPacketGCHandshake);
+	case HEADER_GC_PING:
+		return sizeof(TPacketGCPing);
+	case HEADER_GC_MARK_IDXLIST:
+		return sizeof(TPacketGCMarkIDXList);
+	case HEADER_GC_MARK_BLOCK:
+		return sizeof(TPacketGCMarkBlock);
+	case HEADER_GC_GUILD_SYMBOL_DATA:
+		return sizeof(TPacketGCGuildSymbolData);
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	case HEADER_GC_KEY_AGREEMENT:
+		return sizeof(TPacketKeyAgreement);
+	case HEADER_GC_KEY_AGREEMENT_COMPLETED:
+		return sizeof(TPacketKeyAgreementCompleted);
+#endif
+	}
+	return 0;
+}
+
+bool CGuildMarkDownloader::__DispatchPacket(UINT header)
+{
+	switch (header)
+	{
+	case HEADER_GC_PHASE:
+		return __LoginState_RecvPhase();
+	case HEADER_GC_HANDSHAKE:
+		return __LoginState_RecvHandshake();
+	case HEADER_GC_PING:
+		return __LoginState_RecvPing();
+	case HEADER_GC_MARK_IDXLIST:
+		return __LoginState_RecvMarkIndex();
+	case HEADER_GC_MARK_BLOCK:
+		return __LoginState_RecvMarkBlock();
+	case HEADER_GC_GUILD_SYMBOL_DATA:
+		return __LoginState_RecvSymbolData();
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	case HEADER_GC_KEY_AGREEMENT:
+		return __LoginState_RecvKeyAgreement();
+	case HEADER_GC_KEY_AGREEMENT_COMPLETED:
+		return __LoginState_RecvKeyAgreementCompleted();
+#endif
+	}
+	return false;
+}
+// END_OF_MARK_BUG_FIX
+
+bool CGuildMarkDownloader::__LoginState_RecvHandshake()
+{
+	TPacketGCHandshake kPacketHandshake;
+	if (!Recv(sizeof(kPacketHandshake), &kPacketHandshake))
+		return false;
+
+	TPacketCGMarkLogin kPacketMarkLogin;
+
+	kPacketMarkLogin.header = HEADER_CG_MARK_LOGIN;
+	kPacketMarkLogin.handle = m_dwHandle;
+	kPacketMarkLogin.random_key = m_dwRandomKey;
+
+	if (!Send(sizeof(kPacketMarkLogin), &kPacketMarkLogin))
+		return false;
+
+	return true;
+}
+
+bool CGuildMarkDownloader::__LoginState_RecvPing()
+{
+	TPacketGCPing kPacketPing;
+
+	if (!Recv(sizeof(kPacketPing), &kPacketPing))
+		return false;
+
+	TPacketCGPong kPacketPong;
+	kPacketPong.bHeader = HEADER_CG_PONG;
+
+	if (!Send(sizeof(TPacketCGPong), &kPacketPong))
+		return false;
+
+	if (IsSecurityMode())
+		return SendSequence();
+	else
+		return true;
+}
+
+bool CGuildMarkDownloader::__LoginState_RecvPhase()
+{
+	TPacketGCPhase kPacketPhase;
+
+	if (!Recv(sizeof(kPacketPhase), &kPacketPhase))
+		return false;
+
+	if (kPacketPhase.phase == PHASE_LOGIN)
+	{
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+		const char* key = LocaleService_GetSecurityKey();
+		SetSecurityMode(true, key);
+#endif
+
+		switch (m_dwTodo)
+		{
+		case TODO_RECV_NONE:
+		{
+			assert(!"CGuildMarkDownloader::__LoginState_RecvPhase - Todo type is none");
+			break;
+		}
+		case TODO_RECV_MARK:
+		{
+			// MARK_BUG_FIX
+			if (!__SendMarkIDXList())
+				return false;
+			// END_OF_MARK_BUG_FIX
+			break;
+		}
+		case TODO_RECV_SYMBOL:
+		{
+			if (!__SendSymbolCRCList())
+				return false;
+			break;
+		}
+		}
+	}
+
+	return true;
+}
+
+// MARK_BUG_FIX
+bool CGuildMarkDownloader::__SendMarkIDXList()
+{
+	TPacketCGMarkIDXList kPacketMarkIDXList;
+	kPacketMarkIDXList.header = HEADER_CG_MARK_IDXLIST;
+	if (!Send(sizeof(kPacketMarkIDXList), &kPacketMarkIDXList))
+		return false;
+
+	return true;
+}
+
+bool CGuildMarkDownloader::__LoginState_RecvMarkIndex()
+{
+	TPacketGCMarkIDXList kPacketMarkIndex;
+
+	if (!Peek(sizeof(kPacketMarkIndex), &kPacketMarkIndex))
+		return false;
+
+	//DWORD bufSize = sizeof(WORD) * 2 * kPacketMarkIndex.count;
+
+	if (!Peek(kPacketMarkIndex.bufSize))
+		return false;
+
+	Recv(sizeof(kPacketMarkIndex));
+
+	WORD guildID, markID;
+
+	for (DWORD i = 0; i < kPacketMarkIndex.count; ++i)
+	{
+		Recv(sizeof(WORD), &guildID);
+		Recv(sizeof(WORD), &markID);
+
+		// ID -> Å©ID Îµ 
+		CGuildMarkManager::Instance().AddMarkIDByGuildID(guildID, markID);
+	}
+
+	//  Å© Ì¹  ÎµÑ´. (  )
+	CGuildMarkManager::Instance().LoadMarkImages();
+
+	// MARK_BUG_FIX
+	CPythonNetworkStream& rkNetStream = CPythonNetworkStream::Instance();
+	rkNetStream.RefreshGuildMark();
+	// END_OF_MARK_BUG_FIX
+
+	m_currentRequestingImageIndex = 0;
+	__SendMarkCRCList();
+	return true;
+}
+
+bool CGuildMarkDownloader::__SendMarkCRCList()
+{
+	TPacketCGMarkCRCList kPacketMarkCRCList;
+
+	if (!CGuildMarkManager::Instance().GetBlockCRCList(m_currentRequestingImageIndex, kPacketMarkCRCList.crclist))
+		__CompleteState_Set();
+	else
+	{
+		kPacketMarkCRCList.header = HEADER_CG_MARK_CRCLIST;
+		kPacketMarkCRCList.imgIdx = m_currentRequestingImageIndex;
+		++m_currentRequestingImageIndex;
+
+		if (!Send(sizeof(kPacketMarkCRCList), &kPacketMarkCRCList))
+			return false;
+	}
+	return true;
+}
+
+bool CGuildMarkDownloader::__LoginState_RecvMarkBlock()
+{
+	TPacketGCMarkBlock kPacket;
+
+	if (!Peek(sizeof(kPacket), &kPacket))
+		return false;
+
+	if (!Peek(kPacket.bufSize))
+		return false;
+
+	Recv(sizeof(kPacket));
+
+	BYTE posBlock;
+	DWORD compSize;
+	char compBuf[SGuildMarkBlock::MAX_COMP_SIZE];
+
+	for (DWORD i = 0; i < kPacket.count; ++i)
+	{
+		Recv(sizeof(BYTE), &posBlock);
+		Recv(sizeof(DWORD), &compSize);
+
+		if (compSize > SGuildMarkBlock::MAX_COMP_SIZE)
+		{
+			TraceError("RecvMarkBlock: data corrupted");
+			Recv(compSize);
+		}
+		else
+		{
+			Recv(compSize, compBuf);
+			//  Ì¹  Ñ´. CRC   Ô² È´.
+			CGuildMarkManager::Instance().SaveBlockFromCompressedData(kPacket.imgIdx, posBlock, (const BYTE*)compBuf, compSize);
+		}
+	}
+
+	if (kPacket.count > 0)
+	{
+		// Å© Ì¹ 
+		CGuildMarkManager::Instance().SaveMarkImage(kPacket.imgIdx);
+
+		// Ò½ Îµ ( Øµ Î°  Ì° )
+		std::string imagePath;
+
+		if (CGuildMarkManager::Instance().GetMarkImageFilename(kPacket.imgIdx, imagePath))
+		{
+			CResource* pResource = CResourceManager::Instance().GetResourcePointer(imagePath.c_str());
+			if (pResource->IsType(CGraphicImage::Type()))
+			{
+				CGraphicImage* pkGrpImg = static_cast<CGraphicImage*>(pResource);
+				pkGrpImg->Reload();
+			}
+		}
+	}
+
+	//  Ã»   Ã»Ï° Æ´Ï¸ Ì¹ Ï° 
+	if (m_currentRequestingImageIndex < CGuildMarkManager::Instance().GetMarkImageCount())
+		__SendMarkCRCList();
+	else
+		__CompleteState_Set();
+
+	return true;
+}
+// END_OF_MARK_BUG_FIX
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+bool CGuildMarkDownloader::__LoginState_RecvKeyAgreement()
+{
+	TPacketKeyAgreement packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		return false;
+	}
+
+	Tracenf("KEY_AGREEMENT RECV %u", packet.wDataLength);
+
+	TPacketKeyAgreement packetToSend;
+	size_t dataLength = TPacketKeyAgreement::MAX_DATA_LEN;
+	size_t agreedLength = Prepare(packetToSend.data, &dataLength);
+	if (agreedLength == 0)
+	{
+		// Ê±È­ 
+		Disconnect();
+		return false;
+	}
+	assert(dataLength <= TPacketKeyAgreement::MAX_DATA_LEN);
+
+	if (Activate(packet.wAgreedLength, packet.data, packet.wDataLength))
+	{
+		// Key agreement ,  
+		packetToSend.bHeader = HEADER_CG_KEY_AGREEMENT;
+		packetToSend.wAgreedLength = (WORD)agreedLength;
+		packetToSend.wDataLength = (WORD)dataLength;
+
+		if (!Send(sizeof(packetToSend), &packetToSend))
+		{
+			Tracen(" CAccountConnector::__AuthState_RecvKeyAgreement - SendKeyAgreement Error");
+			return false;
+		}
+		Tracenf("KEY_AGREEMENT SEND %u", packetToSend.wDataLength);
+	}
+	else
+	{
+		// Å°  
+		Disconnect();
+		return false;
+	}
+	return true;
+}
+
+bool CGuildMarkDownloader::__LoginState_RecvKeyAgreementCompleted()
+{
+	TPacketKeyAgreementCompleted packet;
+	if (!Recv(sizeof(packet), &packet))
+		return false;
+
+	Tracenf("KEY_AGREEMENT_COMPLETED RECV");
+
+	ActivateCipher();
+
+	return true;
+}
+#endif
+
+bool CGuildMarkDownloader::__SendSymbolCRCList()
+{
+	for (DWORD i = 0; i < m_kVec_dwGuildID.size(); ++i)
+	{
+		TPacketCGSymbolCRC kSymbolCRCPacket;
+		kSymbolCRCPacket.header = HEADER_CG_GUILD_SYMBOL_CRC;
+		kSymbolCRCPacket.dwGuildID = m_kVec_dwGuildID[i];
+
+		std::string strFileName = GetGuildSymbolFileName(m_kVec_dwGuildID[i]);
+		kSymbolCRCPacket.dwCRC = GetFileCRC32(strFileName.c_str());
+		kSymbolCRCPacket.dwSize = GetFileSize(strFileName.c_str());
+#ifdef _DEBUG
+		printf("__SendSymbolCRCList [GuildID:%d / CRC:%u]\n", m_kVec_dwGuildID[i], kSymbolCRCPacket.dwCRC);
+#endif
+		if (!Send(sizeof(kSymbolCRCPacket), &kSymbolCRCPacket))
+			return false;
+	}
+
+	return true;
+}
+
+bool CGuildMarkDownloader::__LoginState_RecvSymbolData()
+{
+	TPacketGCBlankDynamic packet;
+	if (!Peek(sizeof(TPacketGCBlankDynamic), &packet))
+		return true;
+
+#ifdef _DEBUG
+	printf("__LoginState_RecvSymbolData [%d/%d]\n", GetRecvBufferSize(), packet.size);
+#endif
+	// Validate dynamic packet size: must at least contain the header struct.
+	if (packet.size < sizeof(TPacketGCGuildSymbolData))
+		return false;
+
+	// Cap to prevent abuse/oom (WORD max is 65535 anyway).
+	const WORD kMaxPacket = 64 * 1024; // 64KB cap for symbol packets
+	if (packet.size > kMaxPacket)
+		return false;
+
+	// Wait until the full dynamic packet is available.
+	if (!Peek(packet.size))
+		return true;
+
+	//////////////////////////////////////////////////////////////
+
+	TPacketGCGuildSymbolData kPacketSymbolData;
+	if (!Recv(sizeof(kPacketSymbolData), &kPacketSymbolData))
+		return false;
+
+	if (kPacketSymbolData.size < sizeof(kPacketSymbolData))
+		return false;
+	if (kPacketSymbolData.size != packet.size)
+		return false;
+
+	WORD wDataSize = kPacketSymbolData.size - static_cast<WORD>(sizeof(kPacketSymbolData));
+	DWORD dwGuildID = kPacketSymbolData.guild_id;
+	if (wDataSize == 0)
+		return false;
+
+	std::vector<BYTE> buf;
+	buf.resize(wDataSize);
+
+	if (!Recv(wDataSize, buf.data()))
+		return false;
+
+	MyCreateDirectory(g_strGuildSymbolPathName.c_str());
+
+	std::string strFileName = GetGuildSymbolFileName(dwGuildID);
+
+	FILE* File = fopen(strFileName.c_str(), "wb");
+	if (!File)
+	{
+		return false;
+	}
+	fwrite(buf.data(), wDataSize, 1, File);
+	fclose(File);
+
+#ifdef _DEBUG
+	printf("__LoginState_RecvSymbolData(filename:%s, datasize:%d, guildid:%d)\n", strFileName.c_str(), wDataSize, dwGuildID);
+#endif
+
+	return true;
+}
diff --git a/src-client/Client/UserInterface/GuildMarkUploader.cpp b/src-client/Client/UserInterface/GuildMarkUploader.cpp
index 24e9226..88db1d7 100644
--- a/src-client/Client/UserInterface/GuildMarkUploader.cpp
+++ b/src-client/Client/UserInterface/GuildMarkUploader.cpp
@@ -1,479 +1,508 @@
-#include "StdAfx.h"
-#include "GuildMarkUploader.h"
-#include "Packet.h"
-#include "Test.h"
-
-CGuildMarkUploader::CGuildMarkUploader()
-	: m_pbySymbolBuf(NULL)
-{
-	SetRecvBufferSize(1024);
-	SetSendBufferSize(1024);
-	__Inialize();
-}
-
-CGuildMarkUploader::~CGuildMarkUploader()
-{
-	__OfflineState_Set();
-}
-
-void CGuildMarkUploader::Disconnect()
-{
-	__OfflineState_Set();
-}
-
-bool CGuildMarkUploader::IsCompleteUploading()
-{
-	return STATE_OFFLINE == m_eState;
-}
-
-bool CGuildMarkUploader::__Save(const char* c_szFileName)
-{
-	// ¾÷·Î´õ¿¡¼­ ÀúÀåÇÏÁö ¾Ê¾Æ¾ß ÇÔ;
-	/*
-	ILuint uImg;
-	ilGenImages(1, &uImg);
-	ilBindImage(uImg);
-	ilEnable(IL_FILE_OVERWRITE);
-	ilEnable(IL_ORIGIN_SET);
-	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);
-
-	if (!ilLoad(IL_TYPE_UNKNOWN, (const ILstring)c_szFileName))
-	{
-		return false;
-	}
-
-	if (ilGetInteger(IL_IMAGE_WIDTH) != CGuildMarkImage::WIDTH)
-	{
-		return false;
-	}
-
-	if (ilGetInteger(IL_IMAGE_HEIGHT) != CGuildMarkImage::HEIGHT)
-	{
-		return false;
-	}
-
-	ilConvertImage(IL_BGRA, IL_BYTE);
-
-	UINT uColCount = CGuildMarkImage::MARK_COL_COUNT;
-	UINT uCol = m_dwGuildID % uColCount;
-	UINT uRow = m_dwGuildID / uColCount;
-
-	ilSetPixels(uCol * SGuildMark::WIDTH, uRow * SGuildMark::HEIGHT, 0, SGuildMark::WIDTH, SGuildMark::HEIGHT, 1, IL_BGRA, IL_BYTE, (ILvoid*)m_kMark.m_apxBuf);
-
-	ilSave(IL_TGA, (ILstring)c_szFileName);
-
-	ilDeleteImages(1, &uImg);
-	*/
-	
-	return true;
-}
-
-bool CGuildMarkUploader::__Load(const char* c_szFileName, UINT* peError)
-{
-	ILuint uImg;
-	ilGenImages(1, &uImg);
-	ilBindImage(uImg);
-	ilEnable(IL_ORIGIN_SET);
-	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);
-
-	if (!ilLoad(IL_TYPE_UNKNOWN, (const ILstring)c_szFileName))
-	{
-		*peError = ERROR_LOAD;
-		return false;
-	}
-
-	if (ilGetInteger(IL_IMAGE_WIDTH) != SGuildMark::WIDTH)
-	{
-		*peError = ERROR_WIDTH;
-		return false;
-	}
-
-	if (ilGetInteger(IL_IMAGE_HEIGHT) != SGuildMark::HEIGHT)
-	{
-		*peError = ERROR_HEIGHT;
-		return false;
-	}
-
-	ilConvertImage(IL_BGRA, IL_BYTE);
-
-	ilCopyPixels(0, 0, 0, SGuildMark::WIDTH, SGuildMark::HEIGHT, 1, IL_BGRA, IL_BYTE, m_kMark.m_apxBuf);
-
-	ilDeleteImages(1, &uImg);
-	return true;
-}
-
-bool CGuildMarkUploader::__LoadSymbol(const char* c_szFileName, UINT* peError)
-{
-	// For Check Image
-	ILuint uImg;
-	ilGenImages(1, &uImg);
-	ilBindImage(uImg);
-	ilEnable(IL_ORIGIN_SET);
-	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);
-	if (!ilLoad(IL_TYPE_UNKNOWN, (const ILstring)c_szFileName))
-	{
-		*peError = ERROR_LOAD;
-		return false;
-	}
-	if (ilGetInteger(IL_IMAGE_WIDTH) != 64)
-	{
-		*peError = ERROR_WIDTH;
-		return false;
-	}
-	if (ilGetInteger(IL_IMAGE_HEIGHT) != 128)
-	{
-		*peError = ERROR_HEIGHT;
-		return false;
-	}
-	ilDeleteImages(1, &uImg);
-	ilShutDown();
-
-	/////
-
-	FILE* file = fopen(c_szFileName, "rb");
-	if (!file)
-	{
-		*peError = ERROR_LOAD;
-	}
-
-	fseek(file, 0, SEEK_END);
-	m_dwSymbolBufSize = ftell(file);
-	fseek(file, 0, SEEK_SET);
-
-	m_pbySymbolBuf = new BYTE[m_dwSymbolBufSize];
-	fread(m_pbySymbolBuf, m_dwSymbolBufSize, 1, file);
-
-	fclose(file);
-
-	/////
-
-	m_dwSymbolCRC32 = GetFileCRC32(c_szFileName);
-	return true;
-}
-
-bool CGuildMarkUploader::Connect(const CNetworkAddress& c_rkNetAddr, DWORD dwHandle, DWORD dwRandomKey, DWORD dwGuildID, const char* c_szFileName, UINT* peError)
-{
-	__OfflineState_Set();
-	SetRecvBufferSize(1024);
-	SetSendBufferSize(1024);
-
-	if (!CNetworkStream::Connect(c_rkNetAddr))
-	{
-		*peError = ERROR_CONNECT;
-		return false;
-	}
-
-	m_dwSendType = SEND_TYPE_MARK;
-	m_dwHandle = dwHandle;
-	m_dwRandomKey = dwRandomKey;
-	m_dwGuildID = dwGuildID;
-
-	if (!__Load(c_szFileName, peError))
-		return false;
-
-	//if (!__Save(CGraphicMarkInstance::GetImageFileName().c_str()))
-	//	return false;
-	//CGraphicMarkInstance::ReloadImageFile();
-	return true;
-}
-
-bool CGuildMarkUploader::ConnectToSendSymbol(const CNetworkAddress& c_rkNetAddr, DWORD dwHandle, DWORD dwRandomKey, DWORD dwGuildID, const char* c_szFileName, UINT* peError)
-{
-	__OfflineState_Set();
-	SetRecvBufferSize(1024);
-	SetSendBufferSize(64 * 1024);
-
-	if (!CNetworkStream::Connect(c_rkNetAddr))
-	{
-		*peError = ERROR_CONNECT;
-		return false;
-	}
-
-	m_dwSendType = SEND_TYPE_SYMBOL;
-	m_dwHandle = dwHandle;
-	m_dwRandomKey = dwRandomKey;
-	m_dwGuildID = dwGuildID;
-
-	if (!__LoadSymbol(c_szFileName, peError))
-		return false;
-
-	return true;
-}
-
-void CGuildMarkUploader::Process()
-{
-	CNetworkStream::Process();
-
-	if (!__StateProcess())
-	{
-		__OfflineState_Set();
-		Disconnect();
-	}
-}
-
-void CGuildMarkUploader::OnConnectFailure()
-{
-	__OfflineState_Set();
-}
-
-void CGuildMarkUploader::OnConnectSuccess()
-{
-	__LoginState_Set();
-}
-
-void CGuildMarkUploader::OnRemoteDisconnect()
-{
-	__OfflineState_Set();
-}
-
-void CGuildMarkUploader::OnDisconnect()
-{
-	__OfflineState_Set();
-}
-
-void CGuildMarkUploader::__Inialize()
-{
-	m_eState = STATE_OFFLINE;
-
-	m_dwGuildID = 0;
-	m_dwHandle = 0;
-	m_dwRandomKey = 0;
-
-	if (m_pbySymbolBuf)
-	{
-		delete m_pbySymbolBuf;
-	}
-
-	m_dwSymbolBufSize = 0;
-	m_pbySymbolBuf = NULL;
-}
-
-bool CGuildMarkUploader::__StateProcess()
-{
-	switch (m_eState)
-	{
-	case STATE_LOGIN:
-		return __LoginState_Process();
-		break;
-	}
-
-	return true;
-}
-
-void CGuildMarkUploader::__OfflineState_Set()
-{
-	__Inialize();
-}
-
-void CGuildMarkUploader::__CompleteState_Set()
-{
-	m_eState = STATE_COMPLETE;
-
-	__OfflineState_Set();
-}
-
-void CGuildMarkUploader::__LoginState_Set()
-{
-	m_eState = STATE_LOGIN;
-}
-
-bool CGuildMarkUploader::__LoginState_Process()
-{
-	if (!__AnalyzePacket(HEADER_GC_PHASE, sizeof(TPacketGCPhase), &CGuildMarkUploader::__LoginState_RecvPhase))
-		return false;
-
-	if (!__AnalyzePacket(HEADER_GC_HANDSHAKE, sizeof(TPacketGCHandshake), &CGuildMarkUploader::__LoginState_RecvHandshake))
-		return false;
-
-	if (!__AnalyzePacket(HEADER_GC_PING, sizeof(TPacketGCPing), &CGuildMarkUploader::__LoginState_RecvPing))
-		return false;
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT, sizeof(TPacketKeyAgreement), &CGuildMarkUploader::__LoginState_RecvKeyAgreement))
-		return false;
-
-	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT_COMPLETED, sizeof(TPacketKeyAgreementCompleted), &CGuildMarkUploader::__LoginState_RecvKeyAgreementCompleted))
-		return false;
-#endif
-
-	return true;
-}
-
-bool CGuildMarkUploader::__SendMarkPacket()
-{
-	TPacketCGMarkUpload kPacketMarkUpload;
-	kPacketMarkUpload.header = HEADER_CG_MARK_UPLOAD;
-	kPacketMarkUpload.gid = m_dwGuildID;
-
-	assert(sizeof(kPacketMarkUpload.image) == sizeof(m_kMark.m_apxBuf));
-	memcpy(kPacketMarkUpload.image, m_kMark.m_apxBuf, sizeof(kPacketMarkUpload.image));
-
-	if (!Send(sizeof(kPacketMarkUpload), &kPacketMarkUpload))
-		return false;
-
-	return true;
-}
-bool CGuildMarkUploader::__SendSymbolPacket()
-{
-	if (!m_pbySymbolBuf)
-		return false;
-
-	TPacketCGSymbolUpload kPacketSymbolUpload;
-	kPacketSymbolUpload.header = HEADER_CG_GUILD_SYMBOL_UPLOAD;
-	kPacketSymbolUpload.handle = m_dwGuildID;
-	kPacketSymbolUpload.size = sizeof(TPacketCGSymbolUpload) + m_dwSymbolBufSize;
-
-	if (!Send(sizeof(TPacketCGSymbolUpload), &kPacketSymbolUpload))
-		return false;
-	if (!Send(m_dwSymbolBufSize, m_pbySymbolBuf))
-		return false;
-
-#ifdef _DEBUG
-	printf("__SendSymbolPacket : [GuildID:%d/PacketSize:%d/BufSize:%d/CRC:%d]\n", m_dwGuildID, kPacketSymbolUpload.size, m_dwSymbolBufSize, m_dwSymbolCRC32);
-#endif
-
-	CNetworkStream::__SendInternalBuffer();
-	__CompleteState_Set();
-
-	return true;
-}
-
-bool CGuildMarkUploader::__LoginState_RecvPhase()
-{
-	TPacketGCPhase kPacketPhase;
-	if (!Recv(sizeof(kPacketPhase), &kPacketPhase))
-		return false;
-
-	if (kPacketPhase.phase == PHASE_LOGIN)
-	{
-#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
-		const char* key = LocaleService_GetSecurityKey();
-		SetSecurityMode(true, key);
-#endif
-
-		if (SEND_TYPE_MARK == m_dwSendType)
-		{
-			if (!__SendMarkPacket())
-				return false;
-		}
-		else if (SEND_TYPE_SYMBOL == m_dwSendType)
-		{
-			if (!__SendSymbolPacket())
-				return false;
-		}
-	}
-
-	return true;
-}
-
-bool CGuildMarkUploader::__LoginState_RecvHandshake()
-{
-	TPacketGCHandshake kPacketHandshake;
-	if (!Recv(sizeof(kPacketHandshake), &kPacketHandshake))
-		return false;
-
-	{
-		TPacketCGMarkLogin kPacketMarkLogin;
-		kPacketMarkLogin.header = HEADER_CG_MARK_LOGIN;
-		kPacketMarkLogin.handle = m_dwHandle;
-		kPacketMarkLogin.random_key = m_dwRandomKey;
-		if (!Send(sizeof(kPacketMarkLogin), &kPacketMarkLogin))
-			return false;
-	}
-
-	return true;
-}
-
-bool CGuildMarkUploader::__LoginState_RecvPing()
-{
-	TPacketGCPing kPacketPing;
-	if (!Recv(sizeof(kPacketPing), &kPacketPing))
-		return false;
-
-	TPacketCGPong kPacketPong;
-	kPacketPong.bHeader = HEADER_CG_PONG;
-
-	if (!Send(sizeof(TPacketCGPong), &kPacketPong))
-		return false;
-
-	if (IsSecurityMode())
-		return SendSequence();
-	else
-		return true;
-}
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-bool CGuildMarkUploader::__LoginState_RecvKeyAgreement()
-{
-	TPacketKeyAgreement packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		return false;
-	}
-
-	Tracenf("KEY_AGREEMENT RECV %u", packet.wDataLength);
-
-	TPacketKeyAgreement packetToSend;
-	size_t dataLength = TPacketKeyAgreement::MAX_DATA_LEN;
-	size_t agreedLength = Prepare(packetToSend.data, &dataLength);
-	if (agreedLength == 0)
-	{
-		// ÃÊ±âÈ­ ½ÇÆÐ
-		Disconnect();
-		return false;
-	}
-	assert(dataLength <= TPacketKeyAgreement::MAX_DATA_LEN);
-
-	if (Activate(packet.wAgreedLength, packet.data, packet.wDataLength))
-	{
-		// Key agreement ¼º°ø, ÀÀ´ä Àü¼Û
-		packetToSend.bHeader = HEADER_CG_KEY_AGREEMENT;
-		packetToSend.wAgreedLength = (WORD)agreedLength;
-		packetToSend.wDataLength = (WORD)dataLength;
-
-		if (!Send(sizeof(packetToSend), &packetToSend))
-		{
-			Tracen(" CAccountConnector::__AuthState_RecvKeyAgreement - SendKeyAgreement Error");
-			return false;
-		}
-		Tracenf("KEY_AGREEMENT SEND %u", packetToSend.wDataLength);
-	}
-	else
-	{
-		// Å° Çù»ó ½ÇÆÐ
-		Disconnect();
-		return false;
-	}
-	return true;
-}
-
-bool CGuildMarkUploader::__LoginState_RecvKeyAgreementCompleted()
-{
-	TPacketKeyAgreementCompleted packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		return false;
-	}
-
-	Tracenf("KEY_AGREEMENT_COMPLETED RECV");
-
-	ActivateCipher();
-
-	return true;
-}
-#endif // __IMPROVED_PACKET_ENCRYPTION__
-
-bool CGuildMarkUploader::__AnalyzePacket(UINT uHeader, UINT uPacketSize, bool (CGuildMarkUploader::* pfnDispatchPacket)())
-{
-	BYTE bHeader;
-	if (!Peek(sizeof(bHeader), &bHeader))
-		return true;
-
-	if (bHeader != uHeader)
-		return true;
-
-	if (!Peek(uPacketSize))
-		return true;
-
-	return (this->*pfnDispatchPacket)();
-}
+#include "StdAfx.h"
+#include "GuildMarkUploader.h"
+#include "Packet.h"
+#include "Test.h"
+
+CGuildMarkUploader::CGuildMarkUploader()
+	: m_pbySymbolBuf(NULL)
+{
+	SetRecvBufferSize(1024);
+	SetSendBufferSize(1024);
+	__Inialize();
+}
+
+CGuildMarkUploader::~CGuildMarkUploader()
+{
+	__OfflineState_Set();
+}
+
+void CGuildMarkUploader::Disconnect()
+{
+	__OfflineState_Set();
+}
+
+bool CGuildMarkUploader::IsCompleteUploading()
+{
+	return STATE_OFFLINE == m_eState;
+}
+
+bool CGuildMarkUploader::__Save(const char* c_szFileName)
+{
+	// Î´  Ê¾Æ¾ ;
+	/*
+	ILuint uImg;
+	ilGenImages(1, &uImg);
+	ilBindImage(uImg);
+	ilEnable(IL_FILE_OVERWRITE);
+	ilEnable(IL_ORIGIN_SET);
+	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);
+
+	if (!ilLoad(IL_TYPE_UNKNOWN, (const ILstring)c_szFileName))
+	{
+		return false;
+	}
+
+	if (ilGetInteger(IL_IMAGE_WIDTH) != CGuildMarkImage::WIDTH)
+	{
+		return false;
+	}
+
+	if (ilGetInteger(IL_IMAGE_HEIGHT) != CGuildMarkImage::HEIGHT)
+	{
+		return false;
+	}
+
+	ilConvertImage(IL_BGRA, IL_BYTE);
+
+	UINT uColCount = CGuildMarkImage::MARK_COL_COUNT;
+	UINT uCol = m_dwGuildID % uColCount;
+	UINT uRow = m_dwGuildID / uColCount;
+
+	ilSetPixels(uCol * SGuildMark::WIDTH, uRow * SGuildMark::HEIGHT, 0, SGuildMark::WIDTH, SGuildMark::HEIGHT, 1, IL_BGRA, IL_BYTE, (ILvoid*)m_kMark.m_apxBuf);
+
+	ilSave(IL_TGA, (ILstring)c_szFileName);
+
+	ilDeleteImages(1, &uImg);
+	*/
+	
+	return true;
+}
+
+bool CGuildMarkUploader::__Load(const char* c_szFileName, UINT* peError)
+{
+	ILuint uImg;
+	ilGenImages(1, &uImg);
+	ilBindImage(uImg);
+	ilEnable(IL_ORIGIN_SET);
+	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);
+
+	if (!ilLoad(IL_TYPE_UNKNOWN, (const ILstring)c_szFileName))
+	{
+		*peError = ERROR_LOAD;
+		ilDeleteImages(1, &uImg);
+		return false;
+	}
+
+	if (ilGetInteger(IL_IMAGE_WIDTH) != SGuildMark::WIDTH)
+	{
+		*peError = ERROR_WIDTH;
+		ilDeleteImages(1, &uImg);
+		return false;
+	}
+
+	if (ilGetInteger(IL_IMAGE_HEIGHT) != SGuildMark::HEIGHT)
+	{
+		*peError = ERROR_HEIGHT;
+		ilDeleteImages(1, &uImg);
+		return false;
+	}
+
+	ilConvertImage(IL_BGRA, IL_BYTE);
+
+	ilCopyPixels(0, 0, 0, SGuildMark::WIDTH, SGuildMark::HEIGHT, 1, IL_BGRA, IL_BYTE, m_kMark.m_apxBuf);
+
+	ilDeleteImages(1, &uImg);
+	return true;
+}
+
+bool CGuildMarkUploader::__LoadSymbol(const char* c_szFileName, UINT* peError)
+{
+	// For Check Image
+	ILuint uImg;
+	ilGenImages(1, &uImg);
+	ilBindImage(uImg);
+	ilEnable(IL_ORIGIN_SET);
+	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);
+	if (!ilLoad(IL_TYPE_UNKNOWN, (const ILstring)c_szFileName))
+	{
+		*peError = ERROR_LOAD;
+		ilDeleteImages(1, &uImg);
+		return false;
+	}
+	if (ilGetInteger(IL_IMAGE_WIDTH) != 64)
+	{
+		*peError = ERROR_WIDTH;
+		ilDeleteImages(1, &uImg);
+		return false;
+	}
+	if (ilGetInteger(IL_IMAGE_HEIGHT) != 128)
+	{
+		*peError = ERROR_HEIGHT;
+		ilDeleteImages(1, &uImg);
+		return false;
+	}
+	ilDeleteImages(1, &uImg);
+
+	/////
+
+	FILE* file = fopen(c_szFileName, "rb");
+	if (!file)
+	{
+		*peError = ERROR_LOAD;
+		return false;
+	}
+
+	fseek(file, 0, SEEK_END);
+	m_dwSymbolBufSize = ftell(file);
+	fseek(file, 0, SEEK_SET);
+
+	// Symbol upload packet uses WORD size; prevent overflow / mismatch and huge allocations.
+	const DWORD kMaxPayload = 65535u - static_cast<DWORD>(sizeof(TPacketCGSymbolUpload));
+	if (m_dwSymbolBufSize == 0 || m_dwSymbolBufSize > kMaxPayload)
+	{
+		fclose(file);
+		*peError = ERROR_LOAD;
+		return false;
+	}
+
+	if (m_pbySymbolBuf)
+	{
+		delete[] m_pbySymbolBuf;
+		m_pbySymbolBuf = NULL;
+	}
+
+	m_pbySymbolBuf = new BYTE[m_dwSymbolBufSize];
+	if (fread(m_pbySymbolBuf, m_dwSymbolBufSize, 1, file) != 1)
+	{
+		fclose(file);
+		delete[] m_pbySymbolBuf;
+		m_pbySymbolBuf = NULL;
+		m_dwSymbolBufSize = 0;
+		*peError = ERROR_LOAD;
+		return false;
+	}
+
+	fclose(file);
+
+	/////
+
+	m_dwSymbolCRC32 = GetFileCRC32(c_szFileName);
+	return true;
+}
+
+bool CGuildMarkUploader::Connect(const CNetworkAddress& c_rkNetAddr, DWORD dwHandle, DWORD dwRandomKey, DWORD dwGuildID, const char* c_szFileName, UINT* peError)
+{
+	__OfflineState_Set();
+	SetRecvBufferSize(1024);
+	SetSendBufferSize(1024);
+
+	if (!CNetworkStream::Connect(c_rkNetAddr))
+	{
+		*peError = ERROR_CONNECT;
+		return false;
+	}
+
+	m_dwSendType = SEND_TYPE_MARK;
+	m_dwHandle = dwHandle;
+	m_dwRandomKey = dwRandomKey;
+	m_dwGuildID = dwGuildID;
+
+	if (!__Load(c_szFileName, peError))
+		return false;
+
+	//if (!__Save(CGraphicMarkInstance::GetImageFileName().c_str()))
+	//	return false;
+	//CGraphicMarkInstance::ReloadImageFile();
+	return true;
+}
+
+bool CGuildMarkUploader::ConnectToSendSymbol(const CNetworkAddress& c_rkNetAddr, DWORD dwHandle, DWORD dwRandomKey, DWORD dwGuildID, const char* c_szFileName, UINT* peError)
+{
+	__OfflineState_Set();
+	SetRecvBufferSize(1024);
+	SetSendBufferSize(64 * 1024);
+
+	if (!CNetworkStream::Connect(c_rkNetAddr))
+	{
+		*peError = ERROR_CONNECT;
+		return false;
+	}
+
+	m_dwSendType = SEND_TYPE_SYMBOL;
+	m_dwHandle = dwHandle;
+	m_dwRandomKey = dwRandomKey;
+	m_dwGuildID = dwGuildID;
+
+	if (!__LoadSymbol(c_szFileName, peError))
+		return false;
+
+	return true;
+}
+
+void CGuildMarkUploader::Process()
+{
+	CNetworkStream::Process();
+
+	if (!__StateProcess())
+	{
+		__OfflineState_Set();
+		Disconnect();
+	}
+}
+
+void CGuildMarkUploader::OnConnectFailure()
+{
+	__OfflineState_Set();
+}
+
+void CGuildMarkUploader::OnConnectSuccess()
+{
+	__LoginState_Set();
+}
+
+void CGuildMarkUploader::OnRemoteDisconnect()
+{
+	__OfflineState_Set();
+}
+
+void CGuildMarkUploader::OnDisconnect()
+{
+	__OfflineState_Set();
+}
+
+void CGuildMarkUploader::__Inialize()
+{
+	m_eState = STATE_OFFLINE;
+
+	m_dwGuildID = 0;
+	m_dwHandle = 0;
+	m_dwRandomKey = 0;
+
+	if (m_pbySymbolBuf)
+	{
+		delete[] m_pbySymbolBuf;
+	}
+
+	m_dwSymbolBufSize = 0;
+	m_pbySymbolBuf = NULL;
+}
+
+bool CGuildMarkUploader::__StateProcess()
+{
+	switch (m_eState)
+	{
+	case STATE_LOGIN:
+		return __LoginState_Process();
+		break;
+	}
+
+	return true;
+}
+
+void CGuildMarkUploader::__OfflineState_Set()
+{
+	__Inialize();
+}
+
+void CGuildMarkUploader::__CompleteState_Set()
+{
+	m_eState = STATE_COMPLETE;
+
+	__OfflineState_Set();
+}
+
+void CGuildMarkUploader::__LoginState_Set()
+{
+	m_eState = STATE_LOGIN;
+}
+
+bool CGuildMarkUploader::__LoginState_Process()
+{
+	if (!__AnalyzePacket(HEADER_GC_PHASE, sizeof(TPacketGCPhase), &CGuildMarkUploader::__LoginState_RecvPhase))
+		return false;
+
+	if (!__AnalyzePacket(HEADER_GC_HANDSHAKE, sizeof(TPacketGCHandshake), &CGuildMarkUploader::__LoginState_RecvHandshake))
+		return false;
+
+	if (!__AnalyzePacket(HEADER_GC_PING, sizeof(TPacketGCPing), &CGuildMarkUploader::__LoginState_RecvPing))
+		return false;
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT, sizeof(TPacketKeyAgreement), &CGuildMarkUploader::__LoginState_RecvKeyAgreement))
+		return false;
+
+	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT_COMPLETED, sizeof(TPacketKeyAgreementCompleted), &CGuildMarkUploader::__LoginState_RecvKeyAgreementCompleted))
+		return false;
+#endif
+
+	return true;
+}
+
+bool CGuildMarkUploader::__SendMarkPacket()
+{
+	TPacketCGMarkUpload kPacketMarkUpload;
+	kPacketMarkUpload.header = HEADER_CG_MARK_UPLOAD;
+	kPacketMarkUpload.gid = m_dwGuildID;
+
+	assert(sizeof(kPacketMarkUpload.image) == sizeof(m_kMark.m_apxBuf));
+	memcpy(kPacketMarkUpload.image, m_kMark.m_apxBuf, sizeof(kPacketMarkUpload.image));
+
+	if (!Send(sizeof(kPacketMarkUpload), &kPacketMarkUpload))
+		return false;
+
+	return true;
+}
+bool CGuildMarkUploader::__SendSymbolPacket()
+{
+	if (!m_pbySymbolBuf)
+		return false;
+
+	TPacketCGSymbolUpload kPacketSymbolUpload;
+	kPacketSymbolUpload.header = HEADER_CG_GUILD_SYMBOL_UPLOAD;
+	kPacketSymbolUpload.handle = m_dwGuildID;
+	kPacketSymbolUpload.size = sizeof(TPacketCGSymbolUpload) + m_dwSymbolBufSize;
+
+	if (!Send(sizeof(TPacketCGSymbolUpload), &kPacketSymbolUpload))
+		return false;
+	if (!Send(m_dwSymbolBufSize, m_pbySymbolBuf))
+		return false;
+
+#ifdef _DEBUG
+	printf("__SendSymbolPacket : [GuildID:%d/PacketSize:%d/BufSize:%d/CRC:%d]\n", m_dwGuildID, kPacketSymbolUpload.size, m_dwSymbolBufSize, m_dwSymbolCRC32);
+#endif
+
+	CNetworkStream::__SendInternalBuffer();
+	__CompleteState_Set();
+
+	return true;
+}
+
+bool CGuildMarkUploader::__LoginState_RecvPhase()
+{
+	TPacketGCPhase kPacketPhase;
+	if (!Recv(sizeof(kPacketPhase), &kPacketPhase))
+		return false;
+
+	if (kPacketPhase.phase == PHASE_LOGIN)
+	{
+#if !defined(__IMPROVED_PACKET_ENCRYPTION__)
+		const char* key = LocaleService_GetSecurityKey();
+		SetSecurityMode(true, key);
+#endif
+
+		if (SEND_TYPE_MARK == m_dwSendType)
+		{
+			if (!__SendMarkPacket())
+				return false;
+		}
+		else if (SEND_TYPE_SYMBOL == m_dwSendType)
+		{
+			if (!__SendSymbolPacket())
+				return false;
+		}
+	}
+
+	return true;
+}
+
+bool CGuildMarkUploader::__LoginState_RecvHandshake()
+{
+	TPacketGCHandshake kPacketHandshake;
+	if (!Recv(sizeof(kPacketHandshake), &kPacketHandshake))
+		return false;
+
+	{
+		TPacketCGMarkLogin kPacketMarkLogin;
+		kPacketMarkLogin.header = HEADER_CG_MARK_LOGIN;
+		kPacketMarkLogin.handle = m_dwHandle;
+		kPacketMarkLogin.random_key = m_dwRandomKey;
+		if (!Send(sizeof(kPacketMarkLogin), &kPacketMarkLogin))
+			return false;
+	}
+
+	return true;
+}
+
+bool CGuildMarkUploader::__LoginState_RecvPing()
+{
+	TPacketGCPing kPacketPing;
+	if (!Recv(sizeof(kPacketPing), &kPacketPing))
+		return false;
+
+	TPacketCGPong kPacketPong;
+	kPacketPong.bHeader = HEADER_CG_PONG;
+
+	if (!Send(sizeof(TPacketCGPong), &kPacketPong))
+		return false;
+
+	if (IsSecurityMode())
+		return SendSequence();
+	else
+		return true;
+}
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+bool CGuildMarkUploader::__LoginState_RecvKeyAgreement()
+{
+	TPacketKeyAgreement packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		return false;
+	}
+
+	Tracenf("KEY_AGREEMENT RECV %u", packet.wDataLength);
+
+	TPacketKeyAgreement packetToSend;
+	size_t dataLength = TPacketKeyAgreement::MAX_DATA_LEN;
+	size_t agreedLength = Prepare(packetToSend.data, &dataLength);
+	if (agreedLength == 0)
+	{
+		// Ê±È­ 
+		Disconnect();
+		return false;
+	}
+	assert(dataLength <= TPacketKeyAgreement::MAX_DATA_LEN);
+
+	if (Activate(packet.wAgreedLength, packet.data, packet.wDataLength))
+	{
+		// Key agreement ,  
+		packetToSend.bHeader = HEADER_CG_KEY_AGREEMENT;
+		packetToSend.wAgreedLength = (WORD)agreedLength;
+		packetToSend.wDataLength = (WORD)dataLength;
+
+		if (!Send(sizeof(packetToSend), &packetToSend))
+		{
+			Tracen(" CAccountConnector::__AuthState_RecvKeyAgreement - SendKeyAgreement Error");
+			return false;
+		}
+		Tracenf("KEY_AGREEMENT SEND %u", packetToSend.wDataLength);
+	}
+	else
+	{
+		// Å°  
+		Disconnect();
+		return false;
+	}
+	return true;
+}
+
+bool CGuildMarkUploader::__LoginState_RecvKeyAgreementCompleted()
+{
+	TPacketKeyAgreementCompleted packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		return false;
+	}
+
+	Tracenf("KEY_AGREEMENT_COMPLETED RECV");
+
+	ActivateCipher();
+
+	return true;
+}
+#endif // __IMPROVED_PACKET_ENCRYPTION__
+
+bool CGuildMarkUploader::__AnalyzePacket(UINT uHeader, UINT uPacketSize, bool (CGuildMarkUploader::* pfnDispatchPacket)())
+{
+	BYTE bHeader;
+	if (!Peek(sizeof(bHeader), &bHeader))
+		return true;
+
+	if (bHeader != uHeader)
+		return true;
+
+	if (!Peek(uPacketSize))
+		return true;
+
+	return (this->*pfnDispatchPacket)();
+}
diff --git a/src-client/Client/UserInterface/Packet.h b/src-client/Client/UserInterface/Packet.h
index 465858d..8e20812 100644
--- a/src-client/Client/UserInterface/Packet.h
+++ b/src-client/Client/UserInterface/Packet.h
@@ -1,5125 +1,5132 @@
-#pragma once
-
-#include "../GameLib/RaceData.h"
-#include "PythonNonPlayer.h"
-#include "Locale_inc.h"
-
-typedef BYTE TPacketHeader;
-
-enum CG_HEADERS
-{
-	HEADER_CG_LOGIN = 1,
-	HEADER_CG_ATTACK = 2,
-	HEADER_CG_CHAT = 3,
-	HEADER_CG_PLAYER_CREATE = 4, // »õ·Î¿î ÇÃ·¡ÀÌ¾î¸¦ »ý¼º
-	HEADER_CG_PLAYER_DESTROY = 5, // ÇÃ·¡ÀÌ¾î¸¦ »èÁ¦.
-	HEADER_CG_PLAYER_SELECT = 6,
-	HEADER_CG_CHARACTER_MOVE = 7,
-	HEADER_CG_SYNC_POSITION = 8,
-	//HEADER_CG_DIRECT_ENTER = 9,
-	HEADER_CG_ENTERGAME = 10,
-
-	HEADER_CG_ITEM_USE = 11,
-	HEADER_CG_ITEM_DROP = 12,
-	HEADER_CG_ITEM_MOVE = 13,
-	//HEADER_CG_UNUSED = 14,
-	HEADER_CG_ITEM_PICKUP = 15,
-
-	HEADER_CG_QUICKSLOT_ADD = 16,
-	HEADER_CG_QUICKSLOT_DEL = 17,
-	HEADER_CG_QUICKSLOT_SWAP = 18,
-	HEADER_CG_WHISPER = 19,
-	HEADER_CG_ITEM_DROP2 = 20,
-#if defined(ENABLE_NEW_DROP_DIALOG)
-	HEADER_CG_ITEM_DESTROY = 21,
-#endif
-
-	//HEADER_CG_UNUSED = 22,
-	//HEADER_CG_UNUSED = 23,
-	//HEADER_CG_UNUSED = 24,
-	//HEADER_CG_UNUSED = 25,
-
-	HEADER_CG_ON_CLICK = 26,
-	HEADER_CG_EXCHANGE = 27,
-	HEADER_CG_CHARACTER_POSITION = 28,
-	HEADER_CG_SCRIPT_ANSWER = 29,
-	HEADER_CG_QUEST_INPUT_STRING = 30,
-	HEADER_CG_QUEST_CONFIRM = 31,
-#if defined(ENABLE_OX_RENEWAL)
-	HEADER_CG_QUEST_INPUT_LONG_STRING = 32,
-#endif
-#ifdef ENABLE_OFFLINE_SHOP
-	HEADER_CG_OFFLINE_SHOP = 33,
-#endif
-
-	//HEADER_CG_UNUSED = 34,
-
-#ifdef ENABLE_GROWTH_PET_SYSTEM
-	HEADER_CG_PET_HATCH = 35,
-	HEADER_CG_PET_WINDOW_TYPE = 36,
-	HEADER_CG_PET_WINDOW = 37,
-	HEADER_CG_PET_NAME_CHANGE = 38,
-	HEADER_CG_PET_FEED = 39,
-	HEADER_CG_PET_DETERMINE = 40,
-	HEADER_CG_PET_ATTR_CHANGE = 41,
-	HEADER_CG_PET_REVIVE = 42,
-	HEADER_CG_PET_LEARN_SKILL = 43,
-	HEADER_CG_PET_SKILL_UPGRADE = 44,
-	HEADER_CG_PET_DELETE_SKILL = 45,
-	HEADER_CG_PET_DELETE_ALL_SKILL = 46,
-#endif
-
-#if defined(ENABLE_EXTEND_INVEN_SYSTEM)
-	HEADER_CG_EXTEND_INVEN = 47,
-#endif
-	//HEADER_CG_UNUSED = 48,
-	//HEADER_CG_UNUSED = 49,
-
-	HEADER_CG_SHOP = 50,
-	HEADER_CG_FLY_TARGETING = 51,
-	HEADER_CG_USE_SKILL = 52,
-	HEADER_CG_ADD_FLY_TARGETING = 53,
-	HEADER_CG_SHOOT = 54,
-	HEADER_CG_MYSHOP = 55,
-#if defined(ENABLE_MYSHOP_DECO)
-	HEADER_CG_MYSHOP_DECO = 56,
-	HEADER_CG_MYSHOP_DECO_ADD = 57,
-#endif
-	//HEADER_CG_UNUSED = 58,
-
-#if defined(ENABLE_SEND_TARGET_INFO)
-	HEADER_CG_TARGET_INFO = 59,
-#endif
-	HEADER_CG_ITEM_USE_TO_ITEM = 60,
-	HEADER_CG_TARGET = 61,
-
-	//HEADER_CG_UNUSED = 62,
-	//HEADER_CG_UNUSED = 63,
-	HEADER_CG_TEXT = 64, // @ ·Î ½ÃÀÛµÇ¸é ÅØ½ºÆ®¸¦ ÆÄ½ÌÇÑ´Ù.
-	HEADER_CG_WARP = 65,
-	HEADER_CG_SCRIPT_BUTTON = 66,
-	HEADER_CG_MESSENGER = 67,
-	//HEADER_CG_UNUSED = 68,
-
-	HEADER_CG_MALL_CHECKOUT = 69,
-	HEADER_CG_SAFEBOX_CHECKIN = 70, // ¾ÆÀÌÅÛÀ» Ã¢°í¿¡ ³Ö´Â´Ù.
-	HEADER_CG_SAFEBOX_CHECKOUT = 71, // ¾ÆÀÌÅÛÀ» Ã¢°í·Î ºÎÅÍ »©¿Â´Ù.
-
-	HEADER_CG_PARTY_INVITE = 72,
-	HEADER_CG_PARTY_INVITE_ANSWER = 73,
-	HEADER_CG_PARTY_REMOVE = 74,
-	HEADER_CG_PARTY_SET_STATE = 75,
-	HEADER_CG_PARTY_USE_SKILL = 76,
-	HEADER_CG_SAFEBOX_ITEM_MOVE = 77,
-	HEADER_CG_PARTY_PARAMETER = 78,
-	//HEADER_CG_UNUSED = 79,
-
-	HEADER_CG_GUILD = 80,
-	HEADER_CG_ANSWER_MAKE_GUILD = 81,
-	HEADER_CG_FISHING = 82,
-	HEADER_CG_GIVE_ITEM = 83,
-#ifdef ENABLE_SHOP_SEARCH
-	HEADER_CG_SHOP_SEARCH_BY_NAME = 84,
-	HEADER_CG_SHOP_SEARCH_BY_OPTION = 85,
-	HEADER_CG_SHOP_SEARCH_BUY = 86,
-	HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE = 87,
-	HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO = 88,
-#endif
-	//HEADER_CG_UNUSED = 89,
-
-	HEADER_CG_EMPIRE = 90,
-	//HEADER_CG_UNUSED = 91,
-	//HEADER_CG_UNUSED = 92,
-	//HEADER_CG_UNUSED = 93,
-	//HEADER_CG_UNUSED = 94,
-	//HEADER_CG_UNUSED = 95,
-
-	HEADER_CG_REFINE = 96,
-#if defined(ENABLE_CUBE_RENEWAL)
-	HEADER_CG_CUBE = 97,
-#endif
-	//HEADER_CG_UNUSED = 98,
-	//HEADER_CG_UNUSED = 99,
-
-	HEADER_CG_MARK_LOGIN = 100,
-	HEADER_CG_MARK_CRCLIST = 101,
-	HEADER_CG_MARK_UPLOAD = 102,
-	//HEADER_CG_CRC_REPORT = 103,
-	HEADER_CG_MARK_IDXLIST = 104,
-
-	HEADER_CG_HACK = 105,
-	HEADER_CG_CHANGE_NAME = 106,
-	//HEADER_CG_UNUSED = 107,
-	//HEADER_CG_UNUSED = 108,
-	HEADER_CG_LOGIN2 = 109,
-	HEADER_CG_DUNGEON = 110,
-	HEADER_CG_LOGIN3 = 111,
-
-	HEADER_CG_GUILD_SYMBOL_UPLOAD = 112,
-	HEADER_CG_GUILD_SYMBOL_CRC = 113,
-
-	// SCRIPT_SELECT_ITEM
-	HEADER_CG_SCRIPT_SELECT_ITEM = 114,
-	// END_OF_SCRIPT_SELECT_ITEM
-
-#if defined(ENABLE_GEM_SYSTEM)
-	HEADER_CG_SELECT_ITEM_EX = 115,
-#endif
-
-	//HEADER_CG_UNUSED = 116,
-	//HEADER_CG_UNUSED = 117,
-	//HEADER_CG_UNUSED = 118,
-	//HEADER_CG_UNUSED = 119,
-#if defined(ENABLE_QUEST_REQUEST_EVENT)
-	HEADER_CG_REQUEST_EVENT_QUEST = 120,
-#endif
-#if defined(ENABLE_LEFT_SEAT)
-	HEADER_CG_LEFT_SEAT = 121,
-#endif
-	//HEADER_CG_UNUSED = 122,
-	//HEADER_CG_UNUSED = 123,
-	//HEADER_CG_UNUSED = 124,
-	//HEADER_CG_UNUSED = 125,
-	//HEADER_CG_UNUSED = 126,
-	//HEADER_CG_UNUSED = 127,
-	//HEADER_CG_UNUSED = 128,
-	//HEADER_CG_UNUSED = 129,
-	//HEADER_CG_UNUSED = 130,
-	//HEADER_CG_UNUSED = 131,
-	//HEADER_CG_UNUSED = 132,
-	//HEADER_CG_UNUSED = 133,
-	//HEADER_CG_UNUSED = 134,
-	//HEADER_CG_UNUSED = 135,
-	//HEADER_CG_UNUSED = 136,
-	//HEADER_CG_UNUSED = 137,
-	//HEADER_CG_UNUSED = 138,
-	//HEADER_CG_UNUSED = 139,
-	//HEADER_CG_UNUSED = 140,
-	//HEADER_CG_UNUSED = 141,
-	//HEADER_CG_UNUSED = 142,
-	//HEADER_CG_UNUSED = 143,
-	//HEADER_CG_UNUSED = 144,
-#if defined(ENABLE_FISHING_GAME)
-	HEADER_CG_FISHING_GAME = 145,
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-	HEADER_CG_REFINE_ELEMENT = 146,
-#endif
-	//HEADER_CG_UNUSED = 147,
-	//HEADER_CG_UNUSED = 148,
-	//HEADER_CG_UNUSED = 149,
-	//HEADER_CG_UNUSED = 150,
-#if defined(ENABLE_SKILLBOOK_COMB_SYSTEM)
-	HEADER_CG_SKILLBOOK_COMB = 151,
-#endif
-	//HEADER_CG_UNUSED = 152,
-	//HEADER_CG_UNUSED = 153,
-	//HEADER_CG_UNUSED = 154,
-	//HEADER_CG_UNUSED = 155,
-	//HEADER_CG_UNUSED = 156,
-	//HEADER_CG_UNUSED = 157,
-	//HEADER_CG_UNUSED = 158,
-	//HEADER_CG_UNUSED = 159,
-	//HEADER_CG_UNUSED = 160,
-	//HEADER_CG_UNUSED = 161,
-	//HEADER_CG_UNUSED = 162,
-	//HEADER_CG_UNUSED = 163,
-	//HEADER_CG_UNUSED = 164,
-	//HEADER_CG_UNUSED = 165,
-	//HEADER_CG_UNUSED = 166,
-	//HEADER_CG_UNUSED = 167,
-	//HEADER_CG_UNUSED = 168,
-#if defined(ENABLE_ATTR_6TH_7TH)
-	HEADER_CG_ATTR67_ADD = 169,
-#endif
-#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
-	HEADER_CG_SNOWFLAKE_STICK_EVENT = 170,
-#endif
-	//HEADER_CG_UNUSED = 171,
-	//HEADER_CG_UNUSED = 172,
-	//HEADER_CG_UNUSED = 173,
-	//HEADER_CG_UNUSED = 174,
-	//HEADER_CG_UNUSED = 175,
-	//HEADER_CG_UNUSED = 176,
-	//HEADER_CG_UNUSED = 177,
-	//HEADER_CG_UNUSED = 178,
-	//HEADER_CG_UNUSED = 179,
-	//HEADER_CG_UNUSED = 180,
-#if defined(ENABLE_MINI_GAME_RUMI)
-	HEADER_CG_MINI_GAME_RUMI = 181,
-#endif
-#if defined(ENABLE_MINI_GAME_YUTNORI)
-	HEADER_CG_MINI_GAME_YUTNORI = 182,
-#endif
-#if defined(ENABLE_GEM_SYSTEM)
-	HEADER_CG_GEM_SHOP = 183,
-#endif
-	//HEADER_CG_UNUSED = 184,
-	//HEADER_CG_UNUSED = 185,
-#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
-	HEADER_CG_MINI_GAME_ROULETTE = 186,
-#endif
-#if defined(ENABLE_FLOWER_EVENT)
-	HEADER_CG_FLOWER_EVENT = 187,
-#endif
-	//HEADER_CG_UNUSED = 188,
-	//HEADER_CG_UNUSED = 189,
-	//HEADER_CG_UNUSED = 190,
-	//HEADER_CG_UNUSED = 191,
-	//HEADER_CG_UNUSED = 192,
-	//HEADER_CG_UNUSED = 193,
-	//HEADER_CG_UNUSED = 194,
-	//HEADER_CG_UNUSED = 195,
-	//HEADER_CG_UNUSED = 196,
-	//HEADER_CG_UNUSED = 197,
-	//HEADER_CG_UNUSED = 198,
-	//HEADER_CG_UNUSED = 199,
-	//HEADER_CG_UNUSED = 200,
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	HEADER_CG_EXT_BATTLE_PASS_ACTION = 201,
-	HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM = 202,
-#endif
-
-	// NOTE : ÀÌ·± °³XXX Á¤¸» ÀÌ°Å Packet¼³°èÇÑ »ç¶÷Àº ´©±¸³Ä. ÀÌ·¸°Ô ÄÚµùÇÏ°í ¹äÀÌ ³Ñ¾î°¡³ª.
-	// enumÀ» º°µµ·Î ±¸º°À» ÇÏ´ø°¡. ¾Æ´Ô namepsace·Î ±¸º°À» ÇÏ´ø°¡..
-	// Á¤¸» packet generator±îÁö´Â ¹Ù¶óÁöµµ ¾Ê´Â´Ù. ÀÌ·± ¾¾XX
-	// ÀÌ·¯´Ù°¡ ¼ýÀÚ °ãÄ¡¸é ´©°¡ Ã¥ÀÓÁö´Âµ¥???
-	//HEADER_CG_HS_ACK = 203,
-	//HEADER_CG_XTRAP_ACK = 204,
-
-	HEADER_CG_DRAGON_SOUL_REFINE = 205,
-	HEADER_CG_STATE_CHECKER = 206,
-
-	HEADER_CG_PHASE = 207,
-#if defined(ENABLE_LUCKY_BOX)
-	HEADER_CG_LUCKY_BOX = 208,
-#endif
-	//HEADER_CG_UNUSED = 210,
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-	HEADER_CG_ACCE_REFINE = 211,
-#endif
-#if defined(ENABLE_AURA_COSTUME_SYSTEM)
-	HEADER_CG_AURA_REFINE = 212,
-#endif
-	//HEADER_CG_UNUSED = 213,
-	//HEADER_CG_UNUSED = 214,
-#if defined(ENABLE_MAILBOX)
-	HEADER_CG_MAILBOX_WRITE = 215,
-	HEADER_CG_MAILBOX_WRITE_CONFIRM = 216,
-	HEADER_CG_MAILBOX_PROCESS = 217,
-#endif
-#if defined(ENABLE_MOVE_COSTUME_ATTR)
-	HEADER_CG_ITEM_COMBINATION = 218,
-	HEADER_CG_ITEM_COMBINATION_CANCEL = 219,
-#endif
-	//HEADER_CG_UNUSED = 223,
-	//HEADER_CG_UNUSED = 224,
-	//HEADER_CG_UNUSED = 225,
-#if defined(ENABLE_MINI_GAME_CATCH_KING)
-	HEADER_CG_MINI_GAME_CATCH_KING = 226,
-#endif
-#if defined(ENABLE_CHANGED_ATTR)
-	HEADER_CG_ITEM_SELECT_ATTR = 227,
-#endif
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-	HEADER_CG_CHANGE_LOOK = 228,
-#endif
-	//HEADER_CG_UNUSED = 229,
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-	HEADER_CG_CHANGE_LANGUAGE = 230,
-#endif
-	//HEADER_CG_UNUSED = 231,
-	//HEADER_CG_UNUSED = 232,
-	//HEADER_CG_UNUSED = 233,
-	//HEADER_CG_UNUSED = 234,
-#if defined(ENABLE_LOOTING_SYSTEM)
-	HEADER_CG_LOOT_FILTER = 235,
-#endif
-	//HEADER_CG_UNUSED = 236,
-	//HEADER_CG_UNUSED = 237,
-	//HEADER_CG_UNUSED = 238,
-	//HEADER_CG_UNUSED = 239,
-	//HEADER_CG_UNUSED = 240,
-	HEADER_CG_CLIENT_VERSION2 = 0xf1, // 241
-	//HEADER_CG_UNUSED = 242,
-	//HEADER_CG_UNUSED = 243,
-	//HEADER_CG_UNUSED = 244,
-	//HEADER_CG_UNUSED = 245,
-	//HEADER_CG_UNUSED = 246,
-	//HEADER_CG_UNUSED = 247,
-	//HEADER_CG_UNUSED = 248,
-	//HEADER_CG_UNUSED = 249,
-	//HEADER_CG_UNUSED = 250,
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	HEADER_CG_KEY_AGREEMENT = 0xfb, // __IMPROVED_PACKET_ENCRYPTION__ // 251
-#endif
-	HEADER_CG_TIME_SYNC = 0xfc, // 252
-	HEADER_CG_CLIENT_VERSION = 0xfd, // 253
-	HEADER_CG_PONG = 0xfe, // 254
-	HEADER_CG_HANDSHAKE = 0xff, // 255
-};
-
-enum GC_HEADERS
-{
-	HEADER_GC_CHARACTER_ADD = 1,
-	HEADER_GC_CHARACTER_DEL = 2,
-	HEADER_GC_CHARACTER_MOVE = 3,
-	HEADER_GC_CHAT = 4,
-	HEADER_GC_SYNC_POSITION = 5,
-
-	HEADER_GC_LOGIN_SUCCESS3 = 6,
-	HEADER_GC_LOGIN_FAILURE = 7,
-
-	HEADER_GC_PLAYER_CREATE_SUCCESS = 8,
-	HEADER_GC_PLAYER_CREATE_FAILURE = 9,
-	HEADER_GC_PLAYER_DELETE_SUCCESS = 10,
-	HEADER_GC_PLAYER_DELETE_WRONG_SOCIAL_ID = 11,
-
-	//HEADER_GC_UNUSED = 24,
-	HEADER_GC_STUN = 13,
-	HEADER_GC_DEAD = 14,
-
-	HEADER_GC_MAIN_CHARACTER = 15,
-	HEADER_GC_PLAYER_POINTS = 16,
-	HEADER_GC_PLAYER_POINT_CHANGE = 17,
-	HEADER_GC_CHANGE_SPEED = 18,
-	HEADER_GC_CHARACTER_UPDATE = 19,
-
-	HEADER_GC_ITEM_SET_EMPTY = 20, // ¾ÆÀÌÅÛ Ã¢¿¡ Ãß°¡
-	HEADER_GC_ITEM_SET = 21, // ¾ÆÀÌÅÛ Ã¢¿¡ Ãß°¡
-	HEADER_GC_ITEM_USE = 22, // ¾ÆÀÌÅÛ »ç¿ë (ÁÖÀ§ »ç¶÷µé¿¡°Ô º¸¿©ÁÖ±â À§ÇØ)
-	HEADER_GC_ITEM_DROP = 23, // ¾ÆÀÌÅÛ ¹ö¸®±â
-
-	//HEADER_GC_UNUSED = 24,
-	HEADER_GC_ITEM_UPDATE = 25, // ¾ÆÀÌÅÛ ¼öÄ¡ ¾÷µ¥ÀÌÆ®
-	HEADER_GC_ITEM_GROUND_ADD = 26, // ¹Ù´Ú¿¡ ¾ÆÀÌÅÛ Ãß°¡
-	HEADER_GC_ITEM_GROUND_DEL = 27, // ¹Ù´Ú¿¡¼­ ¾ÆÀÌÅÛ »èÁ¦
-
-	HEADER_GC_QUICKSLOT_ADD = 28,
-	HEADER_GC_QUICKSLOT_DEL = 29,
-	HEADER_GC_QUICKSLOT_SWAP = 30,
-
-	HEADER_GC_ITEM_OWNERSHIP = 31,
-
-	HEADER_GC_LOGIN_SUCCESS4 = 32,
-
-	//HEADER_GC_UNUSED = 33,
-	HEADER_GC_WHISPER = 34,
-	//HEADER_GC_UNUSED = 35,
-
-	HEADER_GC_MOTION = 36,
-	HEADER_GC_EMOTE = 37,
-
-	HEADER_GC_SHOP = 38,
-	HEADER_GC_SHOP_SIGN = 39,
-
-	HEADER_GC_DUEL_START = 40,
-	HEADER_GC_PVP = 41,
-	HEADER_GC_EXCHANGE = 42,
-	HEADER_GC_CHARACTER_POSITION = 43,
-
-	HEADER_GC_PING = 44,
-	HEADER_GC_SCRIPT = 45,
-	HEADER_GC_QUEST_CONFIRM = 46,
-
-#if defined(ENABLE_EXTEND_INVEN_SYSTEM)
-	HEADER_GC_EXTEND_INVEN = 47,
-	HEADER_GC_EXTEND_INVEN_ITEM_USE = 48,
-#endif
-#if defined(ENABLE_GUILD_DRAGONLAIR_SYSTEM)
-	HEADER_GC_GUILD_DRAGONLAIR = 49,
-#endif
-#if defined(ENABLE_CLIENT_TIMER)
-	HEADER_GC_CLIENT_TIMER = 50,
-#endif
-#ifdef ENABLE_OFFLINE_SHOP
-	HEADER_GC_OFFLINE_SHOP = 51,
-#endif
-	//HEADER_GC_UNUSED = 52,
-	//HEADER_GC_UNUSED = 53,
-	//HEADER_GC_UNUSED = 54,
-	//HEADER_GC_UNUSED = 55,
-	//HEADER_GC_UNUSED = 56,
-	//HEADER_GC_UNUSED = 57,
-#if defined(ENABLE_SEND_TARGET_INFO)
-	HEADER_GC_TARGET_INFO = 58,
-#endif
-	//HEADER_GC_UNUSED = 59,
-	//HEADER_GC_UNUSED = 60,
-	HEADER_GC_MOUNT = 61,
-	HEADER_GC_OWNERSHIP = 62,
-	HEADER_GC_TARGET = 63,
-	//HEADER_GC_UNUSED = 64,
-	HEADER_GC_WARP = 65,
-	//HEADER_GC_UNUSED = 66,
-	//HEADER_GC_UNUSED = 67,
-	//HEADER_GC_UNUSED = 68,
-	HEADER_GC_ADD_FLY_TARGETING = 69,
-
-	HEADER_GC_CREATE_FLY = 70,
-	HEADER_GC_FLY_TARGETING = 71,
-	HEADER_GC_SKILL_LEVEL = 72,
-	//HEADER_GC_UNUSED = 73,
-	HEADER_GC_MESSENGER = 74,
-	HEADER_GC_GUILD = 75,
-	HEADER_GC_SKILL_LEVEL_NEW = 76,
-
-	HEADER_GC_PARTY_INVITE = 77,
-	HEADER_GC_PARTY_ADD = 78,
-	HEADER_GC_PARTY_UPDATE = 79,
-	HEADER_GC_PARTY_REMOVE = 80,
-
-	HEADER_GC_QUEST_INFO = 81,
-	HEADER_GC_REQUEST_MAKE_GUILD = 82,
-	HEADER_GC_PARTY_PARAMETER = 83,
-	//HEADER_GC_UNUSED = 84,
-
-	HEADER_GC_SAFEBOX_MONEY_CHANGE = 84,
-	HEADER_GC_SAFEBOX_SET = 85,
-	HEADER_GC_SAFEBOX_DEL = 86,
-	HEADER_GC_SAFEBOX_WRONG_PASSWORD = 87,
-	HEADER_GC_SAFEBOX_SIZE = 88,
-
-	HEADER_GC_FISHING = 89,
-
-	HEADER_GC_EMPIRE = 90,
-
-	HEADER_GC_PARTY_LINK = 91,
-	HEADER_GC_PARTY_UNLINK = 92,
-	//HEADER_GC_UNUSED = 93,
-	//HEADER_GC_UNUSED = 94,
-	HEADER_GC_REFINE_INFORMATION = 95,
-	//HEADER_GC_UNUSED = 96,
-#if defined(ENABLE_CUBE_RENEWAL)
-	HEADER_GC_CUBE = 97,
-#endif
-	//HEADER_GC_UNUSED = 98,
-	HEADER_GC_VIEW_EQUIP = 99,
-
-	HEADER_GC_MARK_BLOCK = 100,
-	//HEADER_GC_MARK_DIFF_DATA = 101,
-	HEADER_GC_MARK_IDXLIST = 102,
-	//HEADER_GC_UNUSED = 103,
-	//HEADER_GC_UNUSED = 104,
-	//HEADER_GC_SLOW_TIMER = 105,
-	HEADER_GC_TIME = 106,
-	HEADER_GC_CHANGE_NAME = 107,
-	//HEADER_GC_UNUSED = 108,
-	//HEADER_GC_UNUSED = 109,
-
-	HEADER_GC_DUNGEON = 110,
-
-	HEADER_GC_WALK_MODE = 111,
-	HEADER_GC_CHANGE_SKILL_GROUP = 112,
-	HEADER_GC_MAIN_CHARACTER2_EMPIRE = 113,
-
-	HEADER_GC_SEPCIAL_EFFECT = 114,
-	HEADER_GC_NPC_POSITION = 115,
-
-	//HEADER_CG_UNUSED = 116,
-	//HEADER_GC_UNUSED = 117,
-	HEADER_GC_LOGIN_KEY = 118,
-
-	HEADER_GC_REFINE_INFORMATION_NEW = 119,
-	//HEADER_GC_UNUSED = 120,
-	HEADER_GC_CHANNEL = 121,
-
-	HEADER_GC_MALL_OPEN = 122,
-
-	HEADER_GC_TARGET_UPDATE = 123,
-	HEADER_GC_TARGET_DELETE = 124,
-	HEADER_GC_TARGET_CREATE_NEW = 125,
-
-	HEADER_GC_AFFECT_ADD = 126,
-	HEADER_GC_AFFECT_REMOVE = 127,
-
-	HEADER_GC_MALL_SET = 128,
-	HEADER_GC_MALL_DEL = 129,
-
-	HEADER_GC_LAND_LIST = 130,
-	HEADER_GC_LOVER_INFO = 131,
-	HEADER_GC_LOVE_POINT_UPDATE = 132,
-
-	HEADER_GC_GUILD_SYMBOL_DATA = 133,
-
-	// MINING
-	HEADER_GC_DIG_MOTION = 134,
-	// END_OF_MINING
-
-	HEADER_GC_DAMAGE_INFO = 135,
-	HEADER_GC_CHAR_ADDITIONAL_INFO = 136,
-
-	// SUPPORT_BGM
-	HEADER_GC_MAIN_CHARACTER3_BGM = 137,
-	HEADER_GC_MAIN_CHARACTER4_BGM_VOL = 138,
-	// END_OF_SUPPORT_BGM
-
-	//HEADER_GC_UNUSED = 140,
-	//HEADER_GC_UNUSED = 141,
-	//HEADER_GC_UNUSED = 142,
-	//HEADER_GC_UNUSED = 143,
-	//HEADER_GC_UNUSED = 144,
-#if defined(ENABLE_FISHING_GAME)
-	HEADER_GC_FISHING_GAME = 145,
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-	HEADER_GC_REFINE_ELEMENT = 146,
-#endif
-	//HEADER_GC_UNUSED = 147,
-	//HEADER_GC_UNUSED = 148,
-	//HEADER_GC_UNUSED = 149,
-
-	HEADER_GC_AUTH_SUCCESS = 150,
-	HEADER_GC_PANAMA_PACK = 151,
-
-	// HYBRID CRYPT
-	HEADER_GC_HYBRIDCRYPT_KEYS = 152,
-	HEADER_GC_HYBRIDCRYPT_SDB = 153, // SDB means Supplmentary Data Blocks
-	// HYBRID CRYPT
-
-	//HEADER_GC_UNUSED = 154,
-	//HEADER_GC_UNUSED = 155,
-	//HEADER_GC_UNUSED = 158,
-	//HEADER_GC_UNUSED = 159,
-	//HEADER_GC_UNUSED = 160,
-	//HEADER_GC_UNUSED = 161,
-	//HEADER_GC_UNUSED = 162,
-	//HEADER_GC_UNUSED = 163,
-#ifdef ENABLE_SHOP_SEARCH
-	HEADER_GC_SHOP_SEARCH_RESULT = 164,
-	HEADER_GC_SHOP_SEARCH_BUY_RESULT = 165,
-	HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE = 166,
-	HEADER_GC_SHOP_SEARCH_SOLD_INFO = 167,
-#endif
-	//HEADER_GC_UNUSED = 168,
-	//HEADER_GC_UNUSED = 169,
-#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
-	HEADER_GC_SNOWFLAKE_STICK_EVENT = 170,
-#endif
-	//HEADER_GC_UNUSED = 171,
-	//HEADER_GC_UNUSED = 172,
-	//HEADER_GC_UNUSED = 173,
-	//HEADER_GC_UNUSED = 174,
-	//HEADER_GC_UNUSED = 175,
-	//HEADER_GC_UNUSED = 176,
-	//HEADER_GC_UNUSED = 177,
-	//HEADER_GC_UNUSED = 178,
-	//HEADER_GC_UNUSED = 179,
-	//HEADER_GC_UNUSED = 180,
-#if defined(ENABLE_MINI_GAME_RUMI)
-	HEADER_GC_MINI_GAME_RUMI = 181,
-#endif
-#if defined(ENABLE_MINI_GAME_YUTNORI)
-	HEADER_GC_MINI_GAME_YUTNORI = 182,
-#endif
-	//HEADER_GC_UNUSED = 183,
-	//HEADER_GC_UNUSED = 184,
-	//HEADER_GC_UNUSED = 185,
-#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
-	HEADER_GC_MINI_GAME_ROULETTE = 186,
-#endif
-#if defined(ENABLE_FLOWER_EVENT)
-	HEADER_GC_FLOWER_EVENT = 187,
-#endif
-
-#ifdef ENABLE_GROWTH_PET_SYSTEM
-	HEADER_GC_PET = 188,
-	HEADER_GC_PET_SET = 189,
-	HEADER_GC_PET_SET_EXCHANGE = 190,
-	HEADER_GC_PET_DEL = 191,
-	HEADER_GC_PET_SUMMON = 192,
-	HEADER_GC_PET_POINT_CHANGE = 193,
-	HEADER_GC_PET_NAME_CHANGE_RESULT = 194,
-	HEADER_GC_PET_DETERMINE_RESULT = 195,
-	HEADER_GC_PET_ATTR_CHANGE_RESULT = 196,
-	HEADER_GC_PET_SKILL_UPDATE = 197,
-	HEADER_GC_PET_SKILL_COOLTIME = 198,
-#endif
-
-	//HEADER_GC_UNUSED = 199,
-	//HEADER_GC_UNUSED = 200,
-
-#if defined(ENABLE_GEM_SYSTEM)
-	HEADER_GC_GEM_SHOP = 201,
-	HEADER_GC_GEM_SHOP_PROCESS = 202,
-#endif
-	//HEADER_GC_UNUSED = 203,
-	//HEADER_GC_UNUSED = 204,
-	//HEADER_GC_UNUSED = 205,
-	//HEADER_GC_UNUSED = 206,
-	//HEADER_GC_UNUSED = 207,
-
-	HEADER_GC_SPECIFIC_EFFECT = 208,
-
-#if defined(ENABLE_DRAGON_SOUL_SYSTEM)
-	HEADER_GC_DRAGON_SOUL_REFINE = 209,
-#endif
-	HEADER_GC_RESPOND_CHANNELSTATUS = 210,
-
-	//HEADER_GC_UNUSED = 212,
-	//HEADER_GC_UNUSED = 213,
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-	HEADER_GC_ACCE_REFINE = 214,
-#endif
-#if defined(ENABLE_AURA_COSTUME_SYSTEM)
-	HEADER_GC_AURA_REFINE = 215,
-#endif
-	//HEADER_GC_UNUSED = 216,
-#if defined(ENABLE_LUCKY_BOX)
-	HEADER_GC_LUCKY_BOX = 217,
-#endif
-	//HEADER_GC_UNUSED = 218,
-	//HEADER_GC_UNUSED = 219,
-	//HEADER_GC_UNUSED = 220,
-#if defined(ENABLE_MAILBOX)
-	HEADER_GC_MAILBOX_PROCESS = 221,
-	HEADER_GC_MAILBOX = 222,
-	HEADER_GC_MAILBOX_ADD_DATA = 223,
-	HEADER_GC_MAILBOX_ALL = 224,
-	HEADER_GC_MAILBOX_UNREAD = 225,
-#endif
-	//HEADER_GC_UNUSED = 226,
-#if defined(ENABLE_CHANGED_ATTR)
-	HEADER_GC_ITEM_SELECT_ATTR = 227,
-#endif
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-	HEADER_GC_CHANGE_LOOK_SET = 228,
-	HEADER_GC_CHANGE_LOOK_DEL = 229,
-	HEADER_GC_CHANGE_LOOK_FREE_SET = 230,
-	HEADER_GC_CHANGE_LOOK_FREE_DEL = 231,
-#endif
-	//HEADER_GC_UNUSED = 232,
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	HEADER_GC_EXT_BATTLE_PASS_OPEN = 233,
-	HEADER_GC_EXT_BATTLE_PASS_GENERAL_INFO = 234,
-	HEADER_GC_EXT_BATTLE_PASS_MISSION_INFO = 235,
-	HEADER_GC_EXT_BATTLE_PASS_MISSION_UPDATE = 236,
-	HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING = 237,
-#endif
-
-#if defined(ENABLE_MINI_GAME_CATCH_KING)
-	HEADER_GC_MINI_GAME_CATCH_KING = 238,
-#endif
-	//HEADER_GC_UNUSED = 239,
-#if defined(ENABLE_RANKING_SYSTEM)
-	HEADER_GC_RANKING = 240,
-#endif
-	//HEADER_GC_UNUSED = 241,
-	//HEADER_GC_UNUSED = 242,
-	//HEADER_GC_UNUSED = 243,
-	//HEADER_GC_UNUSED = 244,
-#if defined(ENABLE_LOOTING_SYSTEM)
-	HEADER_GC_LOOT_FILTER = 245,
-#endif
-	//HEADER_GC_UNUSED = 246,
-	//HEADER_GC_UNUSED = 247,
-	//HEADER_GC_UNUSED = 248,
-	//HEADER_GC_UNUSED = 249,
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	HEADER_GC_KEY_AGREEMENT_COMPLETED = 0xfa, // __IMPROVED_PACKET_ENCRYPTION__ // 250
-	HEADER_GC_KEY_AGREEMENT = 0xfb, // __IMPROVED_PACKET_ENCRYPTION__ // 251
-#endif
-	HEADER_GC_HANDSHAKE_OK = 0xfc, // 252
-	HEADER_GC_PHASE = 0xfd, // 253
-	HEADER_GC_BINDUDP = 0xfe, // 254
-	HEADER_GC_HANDSHAKE = 0xff, // 255
-};
-
-enum
-{
-	ID_MAX_NUM = 30,
-	PASS_MAX_NUM = 16,
-	CHAT_MAX_NUM = 128,
-	PATH_NODE_MAX_NUM = 64,
-	SHOP_SIGN_MAX_LEN = 32,
-
-	PLAYER_PER_ACCOUNT3 = 3,
-#ifndef ENABLE_PLAYER_PER_ACCOUNT5
-	PLAYER_PER_ACCOUNT4 = 4,
-#else
-	PLAYER_PER_ACCOUNT4 = 5,
-	PLAYER_PER_ACCOUNT5 = 5,
-#endif
-
-	PLAYER_ITEM_SLOT_MAX_NUM = 20, // ÇÃ·¡ÀÌ¾îÀÇ ½½·Ô´ç µé¾î°¡´Â °¹¼ö.
-
-	QUICKSLOT_MAX_LINE = 4,
-	QUICKSLOT_MAX_COUNT_PER_LINE = 8, // Å¬¶óÀÌ¾ðÆ® ÀÓÀÇ °áÁ¤°ª
-	QUICKSLOT_MAX_COUNT = QUICKSLOT_MAX_LINE * QUICKSLOT_MAX_COUNT_PER_LINE,
-
-	QUICKSLOT_MAX_NUM = 36, // ¼­¹ö¿Í ¸ÂÃçÁ® ÀÖ´Â °ª
-
-#if defined(ENABLE_MYSHOP_EXPANSION)
-	SHOP_HOST_ITEM_MAX = 80,
-#endif
-	SHOP_HOST_ITEM_MAX_NUM = 40,
-
-	METIN_SOCKET_COUNT = 6,
-
-	PARTY_AFFECT_SLOT_MAX_NUM = 7,
-
-	GUILD_GRADE_NAME_MAX_LEN = 8,
-	GUILD_NAME_MAX_LEN = 12,
-	GUILD_GRADE_COUNT = 15,
-	GULID_COMMENT_MAX_LEN = 50,
-
-	MARK_CRC_NUM = 8 * 8,
-	MARK_DATA_SIZE = 16 * 12,
-	SYMBOL_DATA_SIZE = 128 * 256,
-	QUEST_INPUT_STRING_MAX_NUM = 64,
-#if defined(ENABLE_OX_RENEWAL)
-	QUEST_INPUT_LONG_STRING_MAX_NUM = 128,
-#endif
-
-	PRIVATE_CODE_LENGTH = 8,
-
-	REFINE_MATERIAL_MAX_NUM = 5,
-
-	//CHINA_MATRIX_ANSWER_MAX_LEN = 8,
-
-	//RUNUP_MATRIX_QUIZ_MAX_LEN = 8,
-	//RUNUP_MATRIX_ANSWER_MAX_LEN = 4,
-	//NEWCIBN_PASSPOD_ANSWER_MAX_LEN = 8,
-	//NEWCIBN_PASSPOD_FAILURE_MAX_LEN = 128,
-
-	WEAR_MAX_NUM = 32,
-
-	SHOP_TAB_NAME_MAX = 32,
-#if defined(ENABLE_SHOPEX_TAB4)
-	SHOP_TAB_COUNT_MAX = 4,
-#else
-	SHOP_TAB_COUNT_MAX = 3,
-#endif
-};
-
-#pragma pack(push)
-#pragma pack(1)
-
-/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// Mark
-typedef struct command_mark_login
-{
-	BYTE header;
-	DWORD handle;
-	DWORD random_key;
-} TPacketCGMarkLogin;
-
-typedef struct command_mark_upload
-{
-	BYTE header;
-	DWORD gid;
-	BYTE image[16 * 12 * 4];
-} TPacketCGMarkUpload;
-
-typedef struct command_mark_idxlist
-{
-	BYTE header;
-} TPacketCGMarkIDXList;
-
-typedef struct command_mark_crclist
-{
-	BYTE header;
-	BYTE imgIdx;
-	DWORD crclist[80];
-} TPacketCGMarkCRCList;
-
-typedef struct packet_mark_idxlist
-{
-	BYTE header;
-	DWORD bufSize;
-	WORD count;
-	//µÚ¿¡ size * (WORD + WORD)¸¸Å­ µ¥ÀÌÅÍ ºÙÀ½
-} TPacketGCMarkIDXList;
-
-typedef struct packet_mark_block
-{
-	BYTE header;
-	DWORD bufSize;
-	BYTE imgIdx;
-	DWORD count;
-	// µÚ¿¡ 64 x 48 x ÇÈ¼¿Å©±â(4¹ÙÀÌÆ®) = 12288¸¸Å­ µ¥ÀÌÅÍ ºÙÀ½
-} TPacketGCMarkBlock;
-
-typedef struct command_symbol_upload
-{
-	BYTE header;
-	WORD size;
-	DWORD handle;
-} TPacketCGSymbolUpload;
-
-typedef struct command_symbol_crc
-{
-	BYTE header;
-	DWORD dwGuildID;
-	DWORD dwCRC;
-	DWORD dwSize;
-} TPacketCGSymbolCRC;
-
-typedef struct packet_symbol_data
-{
-	BYTE header;
-	WORD size;
-	DWORD guild_id;
-} TPacketGCGuildSymbolData;
-
-//
-//
-//
-
-typedef struct packet_observer_add
-{
-	BYTE header;
-	DWORD vid;
-	WORD x;
-	WORD y;
-} TPacketGCObserverAdd;
-
-typedef struct packet_observer_move
-{
-	BYTE header;
-	DWORD vid;
-	WORD x;
-	WORD y;
-} TPacketGCObserverMove;
-
-typedef struct packet_observer_remove
-{
-	BYTE header;
-	DWORD vid;
-} TPacketGCObserverRemove;
-
-/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// To Server
-
-typedef struct command_checkin
-{
-	BYTE header;
-	char name[ID_MAX_NUM + 1];
-	char pwd[PASS_MAX_NUM + 1];
-} TPacketCGCheckin;
-
-typedef struct command_login
-{
-	BYTE header;
-	char name[ID_MAX_NUM + 1];
-	char pwd[PASS_MAX_NUM + 1];
-} TPacketCGLogin;
-
-// start - ±ÇÇÑ ¼­¹ö Á¢¼ÓÀ» À§ÇÑ ÆÐÅ¶µé
-typedef struct command_login2
-{
-	BYTE header;
-	char name[ID_MAX_NUM + 1];
-	DWORD login_key;
-	DWORD adwClientKey[4];
-} TPacketCGLogin2;
-
-typedef struct command_login3
-{
-	BYTE header;
-	char name[ID_MAX_NUM + 1];
-	char pwd[PASS_MAX_NUM + 1];
-	DWORD adwClientKey[4];
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-	char country[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketCGLogin3;
-// end - ±ÇÇÑ ¼­¹ö Á¢¼ÓÀ» À§ÇÑ ÆÐÅ¶µé
-
-typedef struct command_direct_enter
-{
-	BYTE bHeader;
-	char login[ID_MAX_NUM + 1];
-	char passwd[PASS_MAX_NUM + 1];
-	BYTE index;
-} TPacketCGDirectEnter;
-
-typedef struct command_player_select
-{
-	BYTE header;
-	BYTE index;
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-	char country[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketCGSelectCharacter;
-
-typedef struct command_attack
-{
-	BYTE header;
-	BYTE bType; // °ø°Ý À¯Çü
-	DWORD dwVictimVID; // Àû VID
-	BYTE bCRCMagicCubeProcPiece;
-	BYTE bCRCMagicCubeFilePiece;
-} TPacketCGAttack;
-
-typedef struct command_chat
-{
-	BYTE header;
-	WORD length;
-	BYTE type;
-} TPacketCGChat;
-
-typedef struct command_whisper
-{
-	BYTE bHeader;
-	WORD wSize;
-	char szNameTo[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketCGWhisper;
-
-enum EBattleMode
-{
-	BATTLEMODE_ATTACK = 0,
-	BATTLEMODE_DEFENSE = 1,
-};
-
-typedef struct command_EnterFrontGame
-{
-	BYTE header;
-} TPacketCGEnterFrontGame;
-
-typedef struct command_item_use
-{
-	BYTE header;
-	TItemPos pos;
-} TPacketCGItemUse;
-
-typedef struct command_item_use_to_item
-{
-	BYTE header;
-	TItemPos source_pos;
-	TItemPos target_pos;
-} TPacketCGItemUseToItem;
-
-typedef struct command_item_drop
-{
-	BYTE header;
-	TItemPos pos;
-	DWORD elk;
-#if defined(ENABLE_CHEQUE_SYSTEM)
-	DWORD cheque;
-#endif
-} TPacketCGItemDrop;
-
-typedef struct command_item_drop2
-{
-	BYTE header;
-	TItemPos pos;
-	DWORD gold;
-#if defined(ENABLE_CHEQUE_SYSTEM)
-	DWORD cheque;
-#endif
-	WORD count;
-} TPacketCGItemDrop2;
-
-#if defined(ENABLE_NEW_DROP_DIALOG)
-typedef struct command_item_destroy
-{
-	BYTE header;
-	TItemPos pos;
-} TPacketCGItemDestroy;
-#endif
-
-typedef struct command_item_move
-{
-	BYTE header;
-	TItemPos pos;
-	TItemPos change_pos;
-	WORD num;
-} TPacketCGItemMove;
-
-typedef struct command_item_pickup
-{
-	BYTE header;
-	DWORD vid;
-} TPacketCGItemPickUp;
-
-typedef struct command_quickslot_add
-{
-	BYTE header;
-	BYTE pos;
-	TQuickSlot slot;
-}TPacketCGQuickSlotAdd;
-
-typedef struct command_quickslot_del
-{
-	BYTE header;
-	BYTE pos;
-}TPacketCGQuickSlotDel;
-
-typedef struct command_quickslot_swap
-{
-	BYTE header;
-	BYTE pos;
-	BYTE change_pos;
-}TPacketCGQuickSlotSwap;
-
-typedef struct command_on_click
-{
-	BYTE header;
-	DWORD vid;
-} TPacketCGOnClick;
-
-enum
-{
-	SHOP_SUBHEADER_CG_END,
-	SHOP_SUBHEADER_CG_BUY,
-	SHOP_SUBHEADER_CG_SELL,
-	SHOP_SUBHEADER_CG_SELL2,
-};
-
-typedef struct command_shop
-{
-	BYTE header;
-	WORD subheader;
-} TPacketCGShop;
-
-typedef struct command_shop_sell
-{
-	WORD wPos;
-	WORD wCount;
-	BYTE bType;
-} TPacketCGShopSell;
-
-enum
-{
-	EXCHANGE_SUBHEADER_CG_START, // arg1 == vid of target character
-	EXCHANGE_SUBHEADER_CG_ITEM_ADD, // arg1 == position of item
-	EXCHANGE_SUBHEADER_CG_ITEM_DEL, // arg1 == position of item
-	EXCHANGE_SUBHEADER_CG_ELK_ADD, // arg1 == amount of elk
-#if defined(ENABLE_CHEQUE_SYSTEM)
-	EXCHANGE_SUBHEADER_CG_CHEQUE_ADD, // arg1 == amount of cheque
-#endif
-	EXCHANGE_SUBHEADER_CG_ACCEPT, // arg1 == not used
-	EXCHANGE_SUBHEADER_CG_CANCEL, // arg1 == not used
-};
-
-typedef struct command_exchange
-{
-	BYTE header;
-	BYTE subheader;
-	DWORD arg1;
-	BYTE arg2;
-	TItemPos Pos;
-} TPacketCGExchange;
-
-typedef struct command_position
-{
-	BYTE header;
-	BYTE position;
-} TPacketCGPosition;
-
-typedef struct command_script_answer
-{
-	BYTE header;
-	BYTE answer;
-} TPacketCGScriptAnswer;
-
-typedef struct command_script_button
-{
-	BYTE header;
-	unsigned int idx;
-} TPacketCGScriptButton;
-
-typedef struct command_target
-{
-	BYTE header;
-	DWORD dwVID;
-} TPacketCGTarget;
-
-typedef struct command_move
-{
-	BYTE bHeader;
-	BYTE bFunc;
-	BYTE bArg;
-	BYTE bRot;
-	LONG lX;
-	LONG lY;
-	DWORD dwTime;
-} TPacketCGMove;
-
-typedef struct command_sync_position_element
-{
-	DWORD dwVID;
-	long lX;
-	long lY;
-} TPacketCGSyncPositionElement;
-
-typedef struct command_sync_position
-{
-	BYTE bHeader;
-	WORD wSize;
-} TPacketCGSyncPosition;
-
-typedef struct command_fly_targeting
-{
-	BYTE bHeader;
-	DWORD dwTargetVID;
-	long lX;
-	long lY;
-} TPacketCGFlyTargeting;
-
-typedef struct packet_fly_targeting
-{
-	BYTE bHeader;
-	DWORD dwShooterVID;
-	DWORD dwTargetVID;
-	long lX;
-	long lY;
-} TPacketGCFlyTargeting;
-
-typedef struct packet_shoot
-{
-	BYTE bHeader;
-	BYTE bType;
-} TPacketCGShoot;
-
-typedef struct command_warp
-{
-	BYTE bHeader;
-} TPacketCGWarp;
-
-enum
-{
-	SAFEBOX_MONEY_STATE_SAVE,
-	SAFEBOX_MONEY_STATE_WITHDRAW,
-};
-
-typedef struct command_safebox_money
-{
-	BYTE bHeader;
-	BYTE bState;
-	DWORD dwMoney;
-} TPacketCGSafeboxMoney;
-
-typedef struct command_safebox_checkout
-{
-	BYTE bHeader;
-	BYTE bSafePos;
-	TItemPos ItemPos;
-} TPacketCGSafeboxCheckout;
-
-typedef struct command_safebox_checkin
-{
-	BYTE bHeader;
-	BYTE bSafePos;
-	TItemPos ItemPos;
-} TPacketCGSafeboxCheckin;
-
-typedef struct command_mall_checkout
-{
-	BYTE bHeader;
-	BYTE bMallPos;
-	TItemPos ItemPos;
-} TPacketCGMallCheckout;
-
-///////////////////////////////////////////////////////////////////////////////////
-// Messenger
-
-enum EMessengerConnectedState
-{
-	MESSENGER_CONNECTED_STATE_OFFLINE,
-	MESSENGER_CONNECTED_STATE_ONLINE
-};
-
-enum EGCMessengerSubHeader
-{
-	MESSENGER_SUBHEADER_GC_LIST,
-	MESSENGER_SUBHEADER_GC_LOGIN,
-	MESSENGER_SUBHEADER_GC_LOGOUT,
-	MESSENGER_SUBHEADER_GC_INVITE,
-#if defined(ENABLE_MESSENGER_BLOCK)
-	MESSENGER_SUBHEADER_GC_BLOCK_LIST,
-	MESSENGER_SUBHEADER_GC_BLOCK_LOGIN,
-	MESSENGER_SUBHEADER_GC_BLOCK_LOGOUT,
-#endif
-#if defined(ENABLE_MESSENGER_GM)
-	MESSENGER_SUBHEADER_GC_GM_LIST,
-	MESSENGER_SUBHEADER_GC_GM_LOGIN,
-	MESSENGER_SUBHEADER_GC_GM_LOGOUT,
-#endif
-};
-
-typedef struct packet_messenger
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMessenger;
-
-typedef struct packet_messenger_list
-{
-	BYTE bConnected;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-#if defined(ENABLE_MESSENGER_DETAILS)
-	DWORD dwLastPlayTime;
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-#endif
-} TPacketGCMessengerList;
-
-enum ECGMessengerSubHeader
-{
-	MESSENGER_SUBHEADER_CG_ADD_BY_VID,
-	MESSENGER_SUBHEADER_CG_ADD_BY_NAME,
-	MESSENGER_SUBHEADER_CG_REMOVE,
-#if defined(ENABLE_MESSENGER_BLOCK)
-	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID,
-	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME,
-	MESSENGER_SUBHEADER_CG_BLOCK_REMOVE,
-#endif
-};
-
-typedef struct command_messenger
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-} TPacketCGMessenger;
-
-///////////////////////////////////////////////////////////////////////////////////
-// Party
-
-typedef struct command_use_skill
-{
-	BYTE bHeader;
-	DWORD dwVnum;
-	DWORD dwTargetVID;
-} TPacketCGUseSkill;
-
-typedef struct command_party_invite
-{
-	BYTE header;
-	DWORD vid;
-} TPacketCGPartyInvite;
-
-typedef struct command_party_invite_answer
-{
-	BYTE header;
-	DWORD leader_pid;
-	BYTE accept;
-} TPacketCGPartyInviteAnswer;
-
-typedef struct command_party_remove
-{
-	BYTE header;
-	DWORD pid;
-} TPacketCGPartyRemove;
-
-typedef struct command_party_set_state
-{
-	BYTE byHeader;
-	DWORD dwVID;
-	BYTE byState;
-	BYTE byFlag;
-} TPacketCGPartySetState;
-
-typedef struct packet_party_link
-{
-	BYTE header;
-	DWORD pid;
-	DWORD vid;
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-	long mapIdx;
-#endif
-#if defined(ENABLE_PARTY_CHANNEL_FIX)
-	BYTE channel;
-#endif
-} TPacketGCPartyLink;
-
-typedef struct command_party_use_skill
-{
-	BYTE byHeader;
-	BYTE bySkillIndex;
-	DWORD dwTargetVID;
-} TPacketCGPartyUseSkill;
-
-enum
-{
-	GUILD_SUBHEADER_CG_ADD_MEMBER,
-	GUILD_SUBHEADER_CG_REMOVE_MEMBER,
-	GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME,
-	GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY,
-	GUILD_SUBHEADER_CG_OFFER,
-	GUILD_SUBHEADER_CG_POST_COMMENT,
-	GUILD_SUBHEADER_CG_DELETE_COMMENT,
-	GUILD_SUBHEADER_CG_REFRESH_COMMENT,
-	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE,
-	GUILD_SUBHEADER_CG_USE_SKILL,
-	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL,
-	GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER,
-	GUILD_SUBHEADER_CG_CHARGE_GSP,
-	GUILD_SUBHEADER_CG_DEPOSIT_MONEY,
-	GUILD_SUBHEADER_CG_WITHDRAW_MONEY,
-};
-
-typedef struct command_guild
-{
-	BYTE byHeader;
-	BYTE bySubHeader;
-} TPacketCGGuild;
-
-typedef struct command_guild_answer_make_guild
-{
-	BYTE header;
-	char guild_name[GUILD_NAME_MAX_LEN + 1];
-} TPacketCGAnswerMakeGuild;
-
-typedef struct command_give_item
-{
-	BYTE byHeader;
-	DWORD dwTargetVID;
-	TItemPos ItemPos;
-	WORD byItemCount;
-} TPacketCGGiveItem;
-
-typedef struct SPacketCGHack
-{
-	BYTE bHeader;
-	char szBuf[255 + 1];
-} TPacketCGHack;
-
-typedef struct command_dungeon
-{
-	BYTE bHeader;
-	WORD size;
-} TPacketCGDungeon;
-
-// Private Shop
-typedef struct SShopItemTable
-{
-	DWORD vnum;
-	DWORD count;
-
-	TItemPos pos; // PC »óÁ¡¿¡¸¸ ÀÌ¿ë
-	DWORD price; // PC »óÁ¡¿¡¸¸ ÀÌ¿ë
-#if defined(ENABLE_CHEQUE_SYSTEM)
-	DWORD cheque;
-#endif
-	BYTE display_pos; // PC »óÁ¡¿¡¸¸ ÀÌ¿ë, º¸ÀÏ À§Ä¡.
-#if defined(ENABLE_SHOPEX_RENEWAL)
-	BYTE bPriceType;
-	DWORD dwPriceVnum;
-	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
-#endif
-} TShopItemTable;
-
-typedef struct SPacketCGMyShop
-{
-	BYTE bHeader;
-	char szSign[SHOP_SIGN_MAX_LEN + 1];
-	BYTE bCount; // count of TShopItemTable, max 39
-} TPacketCGMyShop;
-
-#if defined(ENABLE_MYSHOP_DECO)
-typedef struct SPacketGCMyPrivShopOpen
-{
-	BYTE bHeader;
-	bool bCashItem;
-	BYTE bTabCount;
-} TPacketGCMyPrivShopOpen;
-
-typedef struct STPacketCGMyShopDec
-{
-	BYTE bHeader;
-	BYTE bState;
-} TPacketCGMyShopDeco;
-
-typedef struct SPacketCGMyShopDecoAdd
-{
-	BYTE bHeader;
-	BYTE bType;
-	DWORD dwPolyVnum;
-} TPacketCGMyShopDecoAdd;
-#endif
-
-typedef struct SPacketCGRefine
-{
-	BYTE header;
-	BYTE pos;
-	BYTE type;
-} TPacketCGRefine;
-
-typedef struct SPacketCGChangeName
-{
-	BYTE header;
-	BYTE index;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketCGChangeName;
-
-typedef struct command_client_version
-{
-	BYTE header;
-	char filename[32 + 1];
-	char timestamp[32 + 1];
-} TPacketCGClientVersion;
-
-typedef struct command_client_version2
-{
-	BYTE header;
-	char filename[32 + 1];
-	char timestamp[32 + 1];
-} TPacketCGClientVersion2;
-
-typedef struct command_crc_report
-{
-	BYTE header;
-	BYTE byPackMode;
-	DWORD dwBinaryCRC32;
-	DWORD dwProcessCRC32;
-	DWORD dwRootPackCRC32;
-} TPacketCGCRCReport;
-
-enum EPartyExpDistributionType
-{
-	PARTY_EXP_DISTRIBUTION_NON_PARITY,
-	PARTY_EXP_DISTRIBUTION_PARITY,
-};
-
-typedef struct command_party_parameter
-{
-	BYTE bHeader;
-	BYTE bDistributeMode;
-} TPacketCGPartyParameter;
-
-typedef struct command_quest_input_string
-{
-	BYTE bHeader;
-	char szString[QUEST_INPUT_STRING_MAX_NUM + 1];
-} TPacketCGQuestInputString;
-
-#if defined(ENABLE_OX_RENEWAL)
-typedef struct command_quest_input_long_string
-{
-	BYTE bHeader;
-	char szString[QUEST_INPUT_LONG_STRING_MAX_NUM + 1];
-} TPacketCGQuestInputLongString;
-#endif
-
-typedef struct command_quest_confirm
-{
-	BYTE header;
-	BYTE answer;
-	DWORD requestPID;
-} TPacketCGQuestConfirm;
-
-typedef struct command_script_select_item
-{
-	BYTE header;
-	DWORD selection;
-} TPacketCGScriptSelectItem;
-
-#if defined(ENABLE_GEM_SYSTEM)
-typedef struct command_select_item_ex
-{
-	BYTE bHeader;
-	DWORD dwItemPos;
-	BYTE bType;
-	command_select_item_ex(const DWORD c_dwItemPos, const BYTE c_bType = 0) :
-		bHeader(HEADER_CG_SELECT_ITEM_EX),
-		dwItemPos(c_dwItemPos),
-		bType(c_bType)
-	{}
-} TPacketCGSelectItemEx;
-#endif
-
-/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// From Server
-enum EPhase
-{
-	PHASE_CLOSE, // ²÷±â´Â »óÅÂ (¶Ç´Â ²÷±â Àü »óÅÂ)
-	PHASE_HANDSHAKE, // ¾Ç¼ö..;;
-	PHASE_LOGIN, // ·Î±×ÀÎ Áß
-	PHASE_SELECT, // Ä³¸¯ÅÍ ¼±ÅÃ È­¸é
-	PHASE_LOADING, // ¼±ÅÃ ÈÄ ·Îµù È­¸é
-	PHASE_GAME, // °ÔÀÓ È­¸é
-	PHASE_DEAD, // Á×¾úÀ» ¶§.. (°ÔÀÓ ¾È¿¡ ÀÖ´Â °ÍÀÏ ¼öµµ..)
-
-	PHASE_DBCLIENT_CONNECTING, // ¼­¹ö¿ë
-	PHASE_DBCLIENT, // ¼­¹ö¿ë
-	PHASE_P2P, // ¼­¹ö¿ë
-	PHASE_AUTH, // ·Î±×ÀÎ ÀÎÁõ ¿ë
-};
-
-typedef struct packet_phase
-{
-	BYTE header;
-	BYTE phase;
-} TPacketGCPhase;
-
-typedef struct packet_blank // °ø¹éÆÐÅ¶.
-{
-	BYTE header;
-} TPacketGCBlank;
-
-typedef struct packet_blank_dynamic
-{
-	BYTE header;
-	WORD size;
-} TPacketGCBlankDynamic;
-
-typedef struct packet_header_handshake
-{
-	BYTE header;
-	DWORD dwHandshake;
-	DWORD dwTime;
-	LONG lDelta;
-} TPacketGCHandshake;
-
-typedef struct packet_header_bindudp
-{
-	BYTE header;
-	DWORD addr;
-	WORD port;
-} TPacketGCBindUDP;
-
-typedef struct packet_header_dynamic_size
-{
-	BYTE header;
-	WORD size;
-} TDynamicSizePacketHeader;
-
-typedef struct SSimplePlayerInformation
-{
-	DWORD dwID;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	BYTE byJob;
-	BYTE byLevel;
-	DWORD dwPlayMinutes;
-	BYTE byST, byHT, byDX, byIQ;
-	//DWORD adwParts[CRaceData::PART_MAX_NUM];
-	DWORD dwMainPart;
-	BYTE bChangeName;
-	DWORD dwHairPart;
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-	DWORD dwAccePart;
-#endif
-	BYTE bDummy[4];
-	long x, y;
-	LONG lAddr;
-	WORD wPort;
-	BYTE bySkillGroup;
-	DWORD dwLastPlay;
-#if defined(ENABLE_CONQUEROR_LEVEL)
-	BYTE byConquerorLevel;
-	BYTE bySungmaStr, bySungmaHp, bySungmaMove, bySungmaImmune;
-#endif
-} TSimplePlayerInformation;
-
-typedef struct packet_login_success3
-{
-	BYTE header;
-	TSimplePlayerInformation akSimplePlayerInformation[PLAYER_PER_ACCOUNT3];
-	DWORD guild_id[PLAYER_PER_ACCOUNT3];
-	char guild_name[PLAYER_PER_ACCOUNT3][GUILD_NAME_MAX_LEN + 1];
-	DWORD handle;
-	DWORD random_key;
-} TPacketGCLoginSuccess3;
-
-typedef struct packet_login_success4
-{
-	BYTE header;
-	TSimplePlayerInformation akSimplePlayerInformation[PLAYER_PER_ACCOUNT4];
-	DWORD guild_id[PLAYER_PER_ACCOUNT4];
-	char guild_name[PLAYER_PER_ACCOUNT4][GUILD_NAME_MAX_LEN + 1];
-	DWORD handle;
-	DWORD random_key;
-} TPacketGCLoginSuccess4;
-
-#if defined(ENABLE_PLAYER_PER_ACCOUNT5)
-typedef struct packet_login_success5
-{
-	BYTE header;
-	TSimplePlayerInformation akSimplePlayerInformation[PLAYER_PER_ACCOUNT5];
-	DWORD guild_id[PLAYER_PER_ACCOUNT5];
-	char guild_name[PLAYER_PER_ACCOUNT5][GUILD_NAME_MAX_LEN + 1];
-	DWORD handle;
-	DWORD random_key;
-} TPacketGCLoginSuccess5;
-#endif
-
-enum ELoginFailure
-{
-	LOGIN_FAILURE_NONE,
-	LOGIN_FAILURE_ALREADY,
-	LOGIN_FAILURE_NOID,
-	LOGIN_FAILURE_WRONGPWD,
-	LOGIN_FAILURE_FULL,
-	LOGIN_FAILURE_SHUTDOWN,
-	LOGIN_FAILURE_REPAIR,
-	LOGIN_FAILURE_BLOCK,
-	LOGIN_FAILURE_WRONGMAT,
-	LOGIN_FAILURE_QUIT,
-	LOGIN_FAILURE_BESAMEKEY,
-	LOGIN_FAILURE_NOTAVAIL,
-	LOGIN_FAILURE_BLKLOGIN,
-	LOGIN_FAILURE_WEBBLK,
-	LOGIN_FAILURE_BADSCLID,
-	LOGIN_FAILURE_AGELIMIT,
-	LOGIN_FAILURE_CONFIRM,
-	LOGIN_FAILURE_INACTIVE,
-	LOGIN_FAILURE_UNMIGRATION,
-	LOGIN_FAILURE_MPROCESSING,
-	LOGIN_FAILURE_LOCKED,
-	LOGIN_FAILURE_BACKENDERR,
-	LOGIN_FAILURE_INTEGRTING,
-	LOGIN_FAILURE_COUNTRYERR,
-	LOGIN_FAILURE_IOVATION,
-	LOGIN_FAILURE_TNTERR,
-	LOGIN_FAILURE_SERVER_CLOSED,
-	LOGIN_FAILURE_SERVER_GRADE,
-};
-
-enum { LOGIN_STATUS_MAX_LEN = 8 };
-typedef struct packet_login_failure
-{
-	BYTE header;
-	char szStatus[LOGIN_STATUS_MAX_LEN + 1];
-} TPacketGCLoginFailure;
-
-typedef struct command_player_create
-{
-	BYTE header;
-	BYTE index;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	WORD job;
-	BYTE shape;
-	BYTE CON;
-	BYTE INT;
-	BYTE STR;
-	BYTE DEX;
-} TPacketCGCreateCharacter;
-
-typedef struct command_player_create_success
-{
-	BYTE header;
-	BYTE bAccountCharacterSlot;
-	TSimplePlayerInformation kSimplePlayerInfomation;
-} TPacketGCPlayerCreateSuccess;
-
-typedef struct command_create_failure
-{
-	BYTE header;
-	BYTE bType;
-} TPacketGCCreateFailure;
-
-typedef struct command_player_delete
-{
-	BYTE header;
-	BYTE index;
-	char szPrivateCode[PRIVATE_CODE_LENGTH];
-} TPacketCGDestroyCharacter;
-
-#if defined(ENABLE_DELETE_FAILURE_TYPE)
-typedef struct SPacketGCDestroyCharacterFailure
-{
-	BYTE header;
-	BYTE type;
-	INT time;
-} TPacketGCDestroyCharacterFailure;
-#endif
-
-typedef struct packet_player_delete_success
-{
-	BYTE header;
-	BYTE account_index;
-} TPacketGCDestroyCharacterSuccess;
-
-enum
-{
-	ADD_CHARACTER_STATE_DEAD = (1 << 0),
-	ADD_CHARACTER_STATE_SPAWN = (1 << 1),
-	ADD_CHARACTER_STATE_GUNGON = (1 << 2),
-	ADD_CHARACTER_STATE_KILLER = (1 << 3),
-	ADD_CHARACTER_STATE_PARTY = (1 << 4),
-};
-
-enum EPKModes
-{
-	PK_MODE_PEACE,
-	PK_MODE_REVENGE,
-	PK_MODE_FREE,
-	PK_MODE_PROTECT,
-	PK_MODE_GUILD,
-	PK_MODE_MAX_NUM,
-};
-
-// 2004.11.20.myevan.CRaceData::PART_MAX_NUM »ç¿ë¾ÈÇÏ°Ô ¼öÁ¤ - ¼­¹ö¿¡¼­ »ç¿ëÇÏ´Â°Í°ú ÀÏÄ¡ÇÏÁö ¾ÊÀ½
-enum ECharacterEquipmentPart
-{
-	CHR_EQUIPPART_ARMOR,
-	CHR_EQUIPPART_WEAPON,
-	CHR_EQUIPPART_HEAD,
-	CHR_EQUIPPART_HAIR,
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-	CHR_EQUIPPART_ACCE,
-#endif
-#if defined(ENABLE_AURA_COSTUME_SYSTEM)
-	CHR_EQUIPPART_AURA,
-#endif
-
-	CHR_EQUIPPART_NUM,
-};
-
-typedef struct packet_add_char
-{
-	BYTE header;
-	DWORD dwVID;
-
-#ifdef WJ_SHOW_MOB_INFO
-	DWORD dwLevel;
-	DWORD dwAIFlag;
-#endif
-
-	float angle;
-	long x;
-	long y;
-	long z;
-
-	BYTE bType;
-	WORD wRaceNum;
-#if defined(ENABLE_RACE_SWAP)
-	DWORD dwEventRaceNum;
-#endif
-
-	BYTE bMovingSpeed;
-	BYTE bAttackSpeed;
-
-	BYTE bStateFlag;
-	DWORD dwAffectFlag[3];
-} TPacketGCCharacterAdd;
-
-typedef struct packet_char_additional_info
-{
-	BYTE header;
-	DWORD dwVID;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	DWORD adwPart[CHR_EQUIPPART_NUM];
-	BYTE bEmpire;
-	DWORD dwGuildID;
-	DWORD dwLevel;
-#if defined(ENABLE_CONQUEROR_LEVEL)
-	DWORD dwConquerorLevel;
-#endif
-	short sAlignment; // ¼±¾ÇÄ¡
-	BYTE bPKMode;
-	DWORD dwMountVnum;
-#if defined(ENABLE_QUIVER_SYSTEM)
-	DWORD dwArrow;
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-	WORD wRefineElementAffectType;
-#endif
-#if defined(ENABLE_GUILD_LEADER_GRADE_NAME)
-	BYTE bGuildLeaderGrade;
-#endif
-#ifdef ENABLE_GROWTH_PET_SYSTEM
-	BYTE bCharacterSize;
-#endif
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketGCCharacterAdditionalInfo;
-
-typedef struct packet_update_char
-{
-	BYTE header;
-	DWORD dwVID;
-
-	DWORD adwPart[CHR_EQUIPPART_NUM];
-	BYTE bMovingSpeed;
-	BYTE bAttackSpeed;
-
-	BYTE bStateFlag;
-	DWORD dwAffectFlag[3];
-
-	DWORD dwGuildID;
-	short sAlignment;
-	DWORD dwLevel;
-#if defined(ENABLE_CONQUEROR_LEVEL)
-	DWORD dwConquerorLevel;
-#endif
-	BYTE bPKMode;
-	DWORD dwMountVnum;
-#if defined(ENABLE_QUIVER_SYSTEM)
-	DWORD dwArrow;
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-	WORD wRefineElementAffectType;
-#endif
-#if defined(ENABLE_GUILD_LEADER_GRADE_NAME)
-	BYTE bGuildLeaderGrade;
-#endif
-#if defined(ENABLE_LEFT_SEAT)
-	bool bLeftSeat;
-#endif
-} TPacketGCCharacterUpdate;
-
-typedef struct packet_del_char
-{
-	BYTE header;
-	DWORD dwVID;
-} TPacketGCCharacterDelete;
-
-typedef struct packet_GlobalTime
-{
-	BYTE header;
-	float GlobalTime;
-} TPacketGCGlobalTime;
-
-enum EChatType
-{
-	CHAT_TYPE_TALKING, /* ±×³É Ã¤ÆÃ */
-	CHAT_TYPE_INFO, /* Á¤º¸ (¾ÆÀÌÅÛÀ» Áý¾ú´Ù, °æÇèÄ¡¸¦ ¾ò¾ú´Ù. µî) */
-	CHAT_TYPE_NOTICE, /* °øÁö»çÇ× */
-	CHAT_TYPE_PARTY, /* ÆÄÆ¼¸» */
-	CHAT_TYPE_GUILD, /* ±æµå¸» */
-	CHAT_TYPE_COMMAND, /* ¸í·É */
-	CHAT_TYPE_SHOUT, /* ¿ÜÄ¡±â */
-	CHAT_TYPE_WHISPER, // ¼­¹ö¿Í´Â ¿¬µ¿µÇÁö ¾Ê´Â Only Client Enum
-	CHAT_TYPE_BIG_NOTICE,
-	CHAT_TYPE_MONARCH_NOTICE,
-#if defined(ENABLE_OX_RENEWAL)
-	CHAT_TYPE_BIG_CONTROL_NOTICE,
-#endif
-#if defined(ENABLE_DICE_SYSTEM)
-	CHAT_TYPE_DICE_INFO,
-#endif
-	CHAT_TYPE_MISSION,
-	CHAT_TYPE_SUB_MISSION,
-#if defined(ENABLE_CHATTING_WINDOW_RENEWAL)
-	CHAT_TYPE_EXP_INFO,
-	CHAT_TYPE_ITEM_INFO,
-	CHAT_TYPE_MONEY_INFO,
-#endif
-	CHAT_TYPE_MAX_NUM,
-};
-
-typedef struct packet_chatting
-{
-	BYTE header;
-	WORD size;
-	BYTE type;
-	DWORD dwVID;
-	BYTE bEmpire;
-#if defined(ENABLE_LOCALE_CLIENT)
-	bool bCanFormat;
-#endif
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketGCChat;
-
-typedef struct packet_whisper // °¡º¯ ÆÐÅ¶
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bType;
-	char szNameFrom[CHARACTER_NAME_MAX_LEN + 1];
-#if defined(ENABLE_LOCALE_CLIENT)
-	bool bCanFormat;
-#endif
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
-#endif
-} TPacketGCWhisper;
-
-typedef struct packet_stun
-{
-	BYTE header;
-	DWORD vid;
-} TPacketGCStun;
-
-typedef struct packet_dead
-{
-	BYTE header;
-	DWORD vid;
-	BYTE dialog_type;
-	long map_index;
-} TPacketGCDead;
-
-typedef struct packet_main_character
-{
-	BYTE header;
-	DWORD dwVID;
-	WORD wRaceNum;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	long lX, lY, lZ;
-	BYTE bySkillGroup;
-} TPacketGCMainCharacter;
-
-// SUPPORT_BGM
-typedef struct packet_main_character2_empire
-{
-	BYTE header;
-	DWORD dwVID;
-	WORD wRaceNum;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	long lX, lY, lZ;
-	BYTE byEmpire;
-	BYTE bySkillGroup;
-} TPacketGCMainCharacter2_EMPIRE;
-
-typedef struct packet_main_character3_bgm
-{
-	enum
-	{
-		MUSIC_NAME_MAX_LEN = 24,
-	};
-	BYTE header;
-	DWORD dwVID;
-	WORD wRaceNum;
-	char szUserName[CHARACTER_NAME_MAX_LEN + 1];
-	char szBGMName[MUSIC_NAME_MAX_LEN + 1];
-	long lX, lY, lZ;
-	BYTE byEmpire;
-	BYTE bySkillGroup;
-} TPacketGCMainCharacter3_BGM;
-
-typedef struct packet_main_character4_bgm_vol
-{
-	enum
-	{
-		MUSIC_NAME_MAX_LEN = 24,
-	};
-	BYTE header;
-	DWORD dwVID;
-	WORD wRaceNum;
-	char szUserName[CHARACTER_NAME_MAX_LEN + 1];
-	char szBGMName[MUSIC_NAME_MAX_LEN + 1];
-	float fBGMVol;
-	long lX, lY, lZ;
-	BYTE byEmpire;
-	BYTE bySkillGroup;
-} TPacketGCMainCharacter4_BGM_VOL;
-// END_OF_SUPPORT_BGM
-
-enum EPointTypes
-{
-	POINT_NONE,						// 0
-	POINT_LEVEL,					// 1
-	POINT_VOICE,					// 2
-	POINT_EXP,						// 3
-	POINT_NEXT_EXP,					// 4
-	POINT_HP,						// 5
-	POINT_MAX_HP,					// 6
-	POINT_SP,						// 7
-	POINT_MAX_SP,					// 8
-	POINT_STAMINA,					// 9 ½ºÅ×¹Ì³Ê
-	POINT_MAX_STAMINA,				// 10 ÃÖ´ë ½ºÅ×¹Ì³Ê
-
-	POINT_GOLD,						// 11
-	POINT_ST,						// 12 ±Ù·Â
-	POINT_HT,						// 13 Ã¼·Â
-	POINT_DX,						// 14 ¹ÎÃ¸¼º
-	POINT_IQ,						// 15 Á¤½Å·Â
-	POINT_ATT_POWER,				// 16 °ø°Ý·Â
-	POINT_ATT_SPEED,				// 17 °ø°Ý¼Óµµ
-	POINT_EVADE_RATE,				// 18 È¸ÇÇÀ²
-	POINT_MOV_SPEED,				// 19 ÀÌµ¿¼Óµµ
-	POINT_DEF_GRADE,				// 20 ¹æ¾îµî±Þ
-	POINT_CASTING_SPEED,			// 21 ÁÖ¹®¼Óµµ (Äð´Ù¿îÅ¸ÀÓ*100) / (100 + ÀÌ°ª) = ÃÖÁ¾ Äð´Ù¿î Å¸ÀÓ
-	POINT_MAGIC_ATT_GRADE,			// 22 ¸¶¹ý°ø°Ý·Â
-	POINT_MAGIC_DEF_GRADE,			// 23 ¸¶¹ý¹æ¾î·Â
-	POINT_EMPIRE_POINT,				// 24 Á¦±¹Á¡¼ö
-	POINT_LEVEL_STEP,				// 25 ÇÑ ·¹º§¿¡¼­ÀÇ ´Ü°è.. (1 2 3 µÉ ¶§ º¸»ó, 4 µÇ¸é ·¹º§ ¾÷)
-	POINT_STAT,						// 26 ´É·ÂÄ¡ ¿Ã¸± ¼ö ÀÖ´Â °³¼ö
-	POINT_SUB_SKILL,				// 27 º¸Á¶ ½ºÅ³ Æ÷ÀÎÆ®
-	POINT_SKILL,					// 28 ¾×Æ¼ºê ½ºÅ³ Æ÷ÀÎÆ®
-	//POINT_SKILL_PASV,				// 27 ÆÐ½Ãºê ±â¼ú ¿Ã¸± ¼ö ÀÖ´Â °³¼ö
-	//POINT_SKILL_ACTIVE,			// 28 ¾×Æ¼ºê ½ºÅ³ Æ÷ÀÎÆ®
-	POINT_MIN_ATK,					// 29 ÃÖ¼Ò ÆÄ±«·Â
-	POINT_MAX_ATK,					// 30 ÃÖ´ë ÆÄ±«·Â
-	POINT_PLAYTIME,					// 31 ÇÃ·¹ÀÌ½Ã°£
-	POINT_HP_REGEN,					// 32 HP È¸º¹·ü
-	POINT_SP_REGEN,					// 33 SP È¸º¹·ü
-
-	POINT_BOW_DISTANCE,				// 34 È° »çÁ¤°Å¸® Áõ°¡Ä¡ (meter)
-
-	POINT_HP_RECOVERY,				// 35 Ã¼·Â È¸º¹ Áõ°¡·®
-	POINT_SP_RECOVERY,				// 36 Á¤½Å·Â È¸º¹ Áõ°¡·®
-
-	POINT_POISON_PCT,				// 37 µ¶ È®·ü
-	POINT_STUN_PCT,					// 38 ±âÀý È®·ü
-	POINT_SLOW_PCT,					// 39 ½½·Î¿ì È®·ü
-	POINT_CRITICAL_PCT,				// 40 Å©¸®Æ¼ÄÃ È®·ü
-	POINT_PENETRATE_PCT,			// 41 °üÅëÅ¸°Ý È®·ü
-	POINT_CURSE_PCT,				// 42 ÀúÁÖ È®·ü
-
-	POINT_ATTBONUS_HUMAN,			// 43 ÀÎ°£¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_ANIMAL,			// 44 µ¿¹°¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-	POINT_ATTBONUS_ORC,				// 45 ¿õ±Í¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-	POINT_ATTBONUS_MILGYO,			// 46 ¹Ð±³¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-	POINT_ATTBONUS_UNDEAD,			// 47 ½ÃÃ¼¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-	POINT_ATTBONUS_DEVIL,			// 48 ¸¶±Í(¾Ç¸¶)¿¡°Ô µ¥¹ÌÁö % Áõ°¡
-	POINT_ATTBONUS_INSECT,			// 49 ¹ú·¹Á·
-	POINT_ATTBONUS_FIRE,			// 50 È­¿°Á·
-	POINT_ATTBONUS_ICE,				// 51 ºù¼³Á·
-	POINT_ATTBONUS_DESERT,			// 52 »ç¸·Á·
-	POINT_ATTBONUS_MONSTER,			// 53 ¸ðµç ¸ó½ºÅÍ¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_WARRIOR,			// 54 ¹«»ç¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_ASSASSIN,		// 55 ÀÚ°´¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_SURA,			// 56 ¼ö¶ó¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_SHAMAN,			// 57 ¹«´ç¿¡°Ô °­ÇÔ
-	POINT_ATTBONUS_TREE,			// 58 ³ª¹«¿¡°Ô °­ÇÔ 20050729.myevan UNUSED5
-	POINT_RESIST_WARRIOR,			// 59 ¹«»ç¿¡°Ô ÀúÇ×
-	POINT_RESIST_ASSASSIN,			// 60 ÀÚ°´¿¡°Ô ÀúÇ×
-	POINT_RESIST_SURA,				// 61 ¼ö¶ó¿¡°Ô ÀúÇ×
-	POINT_RESIST_SHAMAN,			// 62 ¹«´ç¿¡°Ô ÀúÇ×
-
-	POINT_STEAL_HP,					// 63 »ý¸í·Â Èí¼ö
-	POINT_STEAL_SP,					// 64 Á¤½Å·Â Èí¼ö
-
-	POINT_MANA_BURN_PCT,			// 65 ¸¶³ª ¹ø
-
-	/// ÇÇÇØ½Ã º¸³Ê½º ///
-
-	POINT_DAMAGE_SP_RECOVER,		// 66 °ø°Ý´çÇÒ ½Ã Á¤½Å·Â È¸º¹ È®·ü
-
-	POINT_BLOCK,					// 67 ºí·°À²
-	POINT_DODGE,					// 68 È¸ÇÇÀ²
-
-	POINT_RESIST_SWORD,				// 69
-	POINT_RESIST_TWOHAND,			// 70
-	POINT_RESIST_DAGGER,			// 71
-	POINT_RESIST_BELL,				// 72
-	POINT_RESIST_FAN,				// 73
-	POINT_RESIST_BOW,				// 74 È­»ì ÀúÇ× : ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_FIRE,				// 75 È­¿° ÀúÇ× : È­¿°°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_ELEC,				// 76 Àü±â ÀúÇ× : Àü±â°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_MAGIC,				// 77 ¼ú¹ý ÀúÇ× : ¸ðµç¼ú¹ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_WIND,				// 78 ¹Ù¶÷ ÀúÇ× : ¹Ù¶÷°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-
-	POINT_REFLECT_MELEE,			// 79 °ø°Ý ¹Ý»ç
-
-	/// Æ¯¼ö ÇÇÇØ½Ã ///
-	POINT_REFLECT_CURSE,			// 80 ÀúÁÖ ¹Ý»ç
-	POINT_POISON_REDUCE,			// 81 µ¶µ¥¹ÌÁö °¨¼Ò
-
-	/// Àû ¼Ò¸ê½Ã ///
-	POINT_KILL_SP_RECOVER,			// 82 Àû ¼Ò¸ê½Ã MP È¸º¹
-	POINT_EXP_DOUBLE_BONUS,			// 83
-	POINT_GOLD_DOUBLE_BONUS,		// 84
-	POINT_ITEM_DROP_BONUS,			// 85
-
-	/// È¸º¹ °ü·Ã ///
-	POINT_POTION_BONUS,				// 86
-	POINT_KILL_HP_RECOVERY,			// 87
-
-	POINT_IMMUNE_STUN,				// 88
-	POINT_IMMUNE_SLOW,				// 89
-	POINT_IMMUNE_FALL,				// 90
-	//////////////////
-
-	POINT_PARTY_ATT_GRADE,			// 91
-	POINT_PARTY_DEF_GRADE,			// 92
-
-	POINT_ATT_BONUS,				// 93
-	POINT_DEF_BONUS,				// 94
-
-	POINT_ATT_GRADE_BONUS,			// 95
-	POINT_DEF_GRADE_BONUS,			// 96
-	POINT_MAGIC_ATT_GRADE_BONUS,	// 97
-	POINT_MAGIC_DEF_GRADE_BONUS,	// 98
-
-	POINT_RESIST_NORMAL_DAMAGE,		// 99
-
-#if defined(ENABLE_MOUNT_COSTUME_SYSTEM)
-	POINT_MOUNT = 109,				// 109
-#endif
-
-	POINT_STAT_RESET_COUNT = 112,	// 112
-	POINT_HORSE_SKILL = 113,		// 113
-
-	POINT_MALL_ATTBONUS,			// 114 °ø°Ý·Â +x%
-	POINT_MALL_DEFBONUS,			// 115 ¹æ¾î·Â +x%
-	POINT_MALL_EXPBONUS,			// 116 °æÇèÄ¡ +x%
-	POINT_MALL_ITEMBONUS,			// 117 ¾ÆÀÌÅÛ µå·ÓÀ² x/10¹è
-	POINT_MALL_GOLDBONUS,			// 118 µ· µå·ÓÀ² x/10¹è
-	POINT_MAX_HP_PCT,				// 119 ÃÖ´ë»ý¸í·Â +x%
-	POINT_MAX_SP_PCT,				// 120 ÃÖ´ëÁ¤½Å·Â +x%
-
-	POINT_SKILL_DAMAGE_BONUS,		// 121 ½ºÅ³ µ¥¹ÌÁö *(100+x)%
-	POINT_NORMAL_HIT_DAMAGE_BONUS,	// 122 ÆòÅ¸ µ¥¹ÌÁö *(100+x)%
-
-	POINT_SKILL_DEFEND_BONUS,		// 123 ½ºÅ³ ¹æ¾î µ¥¹ÌÁö
-	POINT_NORMAL_HIT_DEFEND_BONUS,	// 124 ÆòÅ¸ ¹æ¾î µ¥¹ÌÁö
-	POINT_PC_BANG_EXP_BONUS,		// 125
-	POINT_PC_BANG_DROP_BONUS,		// 126 PC¹æ Àü¿ë µå·Ó·ü º¸³Ê½º
-
-	POINT_ENERGY = 128,				// 128 ±â·Â
-
-	// ±â·Â ui ¿ë.
-	// ÀÌ·¸°Ô ÇÏ°í ½ÍÁö ¾Ê¾ÒÁö¸¸, 
-	// uiTaskBar¿¡¼­´Â affect¿¡ Á¢±ÙÇÒ ¼ö ¾ø°í,
-	// ´õ±¸³ª Å¬¶ó¸®¾ðÆ®¿¡¼­´Â blend_affect´Â °ü¸®ÇÏÁö ¾Ê¾Æ,
-	// ÀÓ½Ã·Î ÀÌ·¸°Ô µÐ´Ù.
-	POINT_ENERGY_END_TIME = 129,	// 129 ±â·Â Á¾·á ½Ã°£
-
-	POINT_COSTUME_ATTR_BONUS = 130,			// 130
-	POINT_MAGIC_ATT_BONUS_PER = 131,		// 131
-	POINT_MELEE_MAGIC_ATT_BONUS_PER = 132,	// 132
-
-	POINT_RESIST_ICE = 133,				// 133 ³Ã±â ÀúÇ× : ¾óÀ½°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_EARTH = 134,			// 134 ´ëÁö ÀúÇ× : ¾óÀ½°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-	POINT_RESIST_DARK = 135,			// 135 ¾îµÒ ÀúÇ× : ¾óÀ½°ø°Ý¿¡ ´ëÇÑ ´ë¹ÌÁö °¨¼Ò
-
-	POINT_RESIST_CRITICAL = 136,		// 136 Å©¸®Æ¼ÄÃ ÀúÇ× : »ó´ëÀÇ Å©¸®Æ¼ÄÃ È®·üÀ» °¨¼Ò
-	POINT_RESIST_PENETRATE = 137,		// 137 °üÅëÅ¸°Ý ÀúÇ× : »ó´ëÀÇ °üÅëÅ¸°Ý È®·üÀ» °¨¼Ò
-
-	POINT_BLEEDING_REDUCE = 138,		// 138
-	POINT_BLEEDING_PCT = 139,			// 139
-	POINT_ATTBONUS_WOLFMAN = 140,		// 140
-	POINT_RESIST_WOLFMAN = 141,			// 141
-	POINT_RESIST_CLAW = 142,			// 142
-
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-	POINT_ACCEDRAIN_RATE,
-#endif
-#if defined(ENABLE_MAGIC_REDUCTION)
-	POINT_RESIST_MAGIC_REDUCTION,
-#endif
-#if defined(ENABLE_CHEQUE_SYSTEM)
-	POINT_CHEQUE,
-#endif
-	POINT_BATTLE_POINT,
-	POINT_RESIST_HUMAN,
-	POINT_ENCHANT_ELECT,
-	POINT_ENCHANT_FIRE,
-	POINT_ENCHANT_ICE,
-	POINT_ENCHANT_WIND,
-	POINT_ENCHANT_EARTH,
-	POINT_ENCHANT_DARK,
-	POINT_ATTBONUS_CZ,
-	POINT_BEAD,
-#if defined(ENABLE_GEM_SYSTEM)
-	POINT_GEM,
-#endif
-	POINT_ATTBONUS_SWORD,
-	POINT_ATTBONUS_TWOHAND,
-	POINT_ATTBONUS_DAGGER,
-	POINT_ATTBONUS_BELL,
-	POINT_ATTBONUS_FAN,
-	POINT_ATTBONUS_BOW,
-	POINT_ATTBONUS_CLAW,
-	POINT_RESIST_MOUNT_FALL,
-	POINT_RESIST_FIST,
-	POINT_PREMIUM_EXPBONUS,
-	POINT_PRIVILEGE_EXPBONUS,
-	POINT_MARRIAGE_EXPBONUS,
-	POINT_DEVILTOWER_EXPBONUS,
-	POINT_PREMIUM_ITEMBONUS,
-	POINT_PRIVILEGE_ITEMBONUS,
-	POINT_PREMIUM_GOLDBONUS,
-	POINT_PRIVILEGE_GOLDBONUS,
-	POINT_SKILL_DAMAGE_SAMYEON,
-	POINT_SKILL_DAMAGE_TANHWAN,
-	POINT_SKILL_DAMAGE_PALBANG,
-	POINT_SKILL_DAMAGE_GIGONGCHAM,
-	POINT_SKILL_DAMAGE_GYOKSAN,
-	POINT_SKILL_DAMAGE_GEOMPUNG,
-	POINT_SKILL_DAMAGE_AMSEOP,
-	POINT_SKILL_DAMAGE_GUNGSIN,
-	POINT_SKILL_DAMAGE_CHARYUN,
-	POINT_SKILL_DAMAGE_SANGONG,
-	POINT_SKILL_DAMAGE_YEONSA,
-	POINT_SKILL_DAMAGE_KWANKYEOK,
-	POINT_SKILL_DAMAGE_GIGUNG,
-	POINT_SKILL_DAMAGE_HWAJO,
-	POINT_SKILL_DAMAGE_SWAERYUNG,
-	POINT_SKILL_DAMAGE_YONGKWON,
-	POINT_SKILL_DAMAGE_PABEOB,
-	POINT_SKILL_DAMAGE_MARYUNG,
-	POINT_SKILL_DAMAGE_HWAYEOMPOK,
-	POINT_SKILL_DAMAGE_MAHWAN,
-	POINT_SKILL_DAMAGE_BIPABU,
-	POINT_SKILL_DAMAGE_YONGBI,
-	POINT_SKILL_DAMAGE_PAERYONG,
-	POINT_SKILL_DAMAGE_NOEJEON,
-	POINT_SKILL_DAMAGE_BYEURAK,
-	POINT_SKILL_DAMAGE_CHAIN,
-	POINT_SKILL_DAMAGE_CHAYEOL,
-	POINT_SKILL_DAMAGE_SALPOONG,
-	POINT_SKILL_DAMAGE_GONGDAB,
-	POINT_SKILL_DAMAGE_PASWAE,
-	POINT_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE,
-	POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE,
-	POINT_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE,
-	POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE,
-	POINT_HIT_BUFF_ENCHANT_FIRE,
-	POINT_HIT_BUFF_ENCHANT_ICE,
-	POINT_HIT_BUFF_ENCHANT_ELEC,
-	POINT_HIT_BUFF_ENCHANT_WIND,
-	POINT_HIT_BUFF_ENCHANT_DARK,
-	POINT_HIT_BUFF_ENCHANT_EARTH,
-	POINT_HIT_BUFF_RESIST_FIRE,
-	POINT_HIT_BUFF_RESIST_ICE,
-	POINT_HIT_BUFF_RESIST_ELEC,
-	POINT_HIT_BUFF_RESIST_WIND,
-	POINT_HIT_BUFF_RESIST_DARK,
-	POINT_HIT_BUFF_RESIST_EARTH,
-	POINT_USE_SKILL_CHEONGRANG_MOV_SPEED,
-	POINT_USE_SKILL_CHEONGRANG_CASTING_SPEED,
-	POINT_USE_SKILL_CHAYEOL_CRITICAL_PCT,
-	POINT_USE_SKILL_SANGONG_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_GIGUNG_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_JEOKRANG_DEF_BONUS,
-	POINT_USE_SKILL_GWIGEOM_DEF_BONUS,
-	POINT_USE_SKILL_TERROR_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_MUYEONG_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_MANASHILED_CASTING_SPEED,
-	POINT_USE_SKILL_HOSIN_DEF_BONUS,
-	POINT_USE_SKILL_GICHEON_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_JEUNGRYEOK_DEF_BONUS,
-	POINT_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS,
-	POINT_USE_SKILL_CHUNKEON_CASTING_SPEED,
-	POINT_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS,
-	POINT_SKILL_DURATION_INCREASE_EUNHYUNG,
-	POINT_SKILL_DURATION_INCREASE_GYEONGGONG,
-	POINT_SKILL_DURATION_INCREASE_GEOMKYUNG,
-	POINT_SKILL_DURATION_INCREASE_JEOKRANG,
-	POINT_USE_SKILL_PALBANG_HP_ABSORB,
-	POINT_USE_SKILL_AMSEOP_HP_ABSORB,
-	POINT_USE_SKILL_YEONSA_HP_ABSORB,
-	POINT_USE_SKILL_YONGBI_HP_ABSORB,
-	POINT_USE_SKILL_CHAIN_HP_ABSORB,
-	POINT_USE_SKILL_PASWAE_SP_ABSORB,
-	POINT_USE_SKILL_GIGONGCHAM_STUN,
-	POINT_USE_SKILL_CHARYUN_STUN,
-	POINT_USE_SKILL_PABEOB_STUN,
-	POINT_USE_SKILL_MAHWAN_STUN,
-	POINT_USE_SKILL_GONGDAB_STUN,
-	POINT_USE_SKILL_SAMYEON_STUN,
-	POINT_USE_SKILL_GYOKSAN_KNOCKBACK,
-	POINT_USE_SKILL_SEOMJEON_KNOCKBACK,
-	POINT_USE_SKILL_SWAERYUNG_KNOCKBACK,
-	POINT_USE_SKILL_HWAYEOMPOK_KNOCKBACK,
-	POINT_USE_SKILL_GONGDAB_KNOCKBACK,
-	POINT_USE_SKILL_KWANKYEOK_KNOCKBACK,
-	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER,
-	POINT_ATTBONUS_STONE,
-	POINT_DAMAGE_HP_RECOVERY,
-	POINT_DAMAGE_SP_RECOVERY,
-	POINT_ALIGNMENT_DAMAGE_BONUS,
-	POINT_NORMAL_DAMAGE_GUARD,
-	POINT_MORE_THEN_HP90_DAMAGE_REDUCE,
-	POINT_USE_SKILL_TUSOK_HP_ABSORB,
-	POINT_USE_SKILL_PAERYONG_HP_ABSORB,
-	POINT_USE_SKILL_BYEURAK_HP_ABSORB,
-	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER,
-	POINT_USE_SKILL_CHAYEOL_HP_ABSORB,
-	POINT_MEDAL_OF_HONOR,
-	POINT_ALL_STAT_BONUS,
-	POINT_SUNGMA_STR,
-	POINT_SUNGMA_HP,
-	POINT_SUNGMA_MOVE,
-	POINT_SUNGMA_IMMUNE,
-	POINT_CONQUEROR_LEVEL,
-	POINT_CONQUEROR_LEVEL_STEP,
-	POINT_CONQUEROR_EXP,
-	POINT_CONQUEROR_NEXT_EXP,
-	POINT_CONQUEROR_POINT,
-	POINT_HIT_PCT,
-	POINT_ATTBONUS_PER_HUMAN,
-	POINT_ATTBONUS_PER_ANIMAL,
-	POINT_ATTBONUS_PER_ORC,
-	POINT_ATTBONUS_PER_MILGYO,
-	POINT_ATTBONUS_PER_UNDEAD,
-	POINT_ATTBONUS_PER_DEVIL,
-	POINT_ENCHANT_PER_ELECT,
-	POINT_ENCHANT_PER_FIRE,
-	POINT_ENCHANT_PER_ICE,
-	POINT_ENCHANT_PER_WIND,
-	POINT_ENCHANT_PER_EARTH,
-	POINT_ENCHANT_PER_DARK,
-	POINT_ATTBONUS_PER_CZ,
-	POINT_ATTBONUS_PER_INSECT,
-	POINT_ATTBONUS_PER_DESERT,
-	POINT_ATTBONUS_PER_STONE,
-	POINT_ATTBONUS_PER_MONSTER,
-	POINT_RESIST_PER_HUMAN,
-	POINT_RESIST_PER_ICE,
-	POINT_RESIST_PER_DARK,
-	POINT_RESIST_PER_EARTH,
-	POINT_RESIST_PER_FIRE,
-	POINT_RESIST_PER_ELEC,
-	POINT_RESIST_PER_MAGIC,
-	POINT_RESIST_PER_WIND,
-	POINT_HIT_BUFF_SUNGMA_STR,
-	POINT_HIT_BUFF_SUNGMA_MOVE,
-	POINT_HIT_BUFF_SUNGMA_HP,
-	POINT_HIT_BUFF_SUNGMA_IMMUNE,
-	POINT_MOUNT_MELEE_MAGIC_ATTBONUS_PER,
-	POINT_DISMOUNT_MOVE_SPEED_BONUS_PER,
-	POINT_HIT_AUTO_HP_RECOVERY,
-	POINT_HIT_AUTO_SP_RECOVERY,
-	POINT_USE_SKILL_COOLTIME_DECREASE_ALL,
-	POINT_HIT_STONE_ATTBONUS_STONE,
-	POINT_HIT_STONE_DEF_GRADE_BONUS,
-	POINT_KILL_BOSS_ITEM_BONUS,
-	POINT_MOB_HIT_MOB_AGGRESSIVE,
-	POINT_NO_DEATH_AND_HP_RECOVERY30,
-	POINT_AUTO_PICKUP,
-	POINT_MOUNT_NO_KNOCKBACK,
-	POINT_SUNGMA_PER_STR,
-	POINT_SUNGMA_PER_HP,
-	POINT_SUNGMA_PER_MOVE,
-	POINT_SUNGMA_PER_IMMUNE,
-	POINT_IMMUNE_POISON100,
-	POINT_IMMUNE_BLEEDING100,
-	POINT_MONSTER_DEFEND_BONUS,
-
-	// Å¬¶óÀÌ¾ðÆ® Æ÷ÀÎÆ®
-	POINT_MIN_WEP,
-	POINT_MAX_WEP,
-	POINT_MIN_MAGIC_WEP,
-	POINT_MAX_MAGIC_WEP,
-	POINT_HIT_RATE,
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	POINT_BATTLE_PASS_PREMIUM_ID
-#endif
-};
-
-typedef struct SPacketGCPoints
-{
-	BYTE bHeader;
-	POINT_VALUE lPoints[POINT_MAX_NUM];
-} TPacketGCPoints;
-
-typedef struct SPacketGCPointChange
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	POINT_TYPE wType;
-	POINT_VALUE lAmount;
-	POINT_VALUE lValue;
-} TPacketGCPointChange;
-
-typedef struct packet_motion
-{
-	BYTE header;
-	DWORD vid;
-	DWORD victim_vid;
-	WORD motion;
-} TPacketGCMotion;
-
-typedef struct packet_set_empty_item
-{
-	BYTE bHeader;
-	TItemPos Cell;
-	DWORD dwVnum;
-	DWORD dwCount;
-	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
-#endif
-#if defined(ENABLE_SET_ITEM)
-	BYTE bSetValue;
-#endif
-} TPacketGCItemSetEmpty;
-
-typedef struct packet_set_item
-{
-	BYTE bHeader;
-	TItemPos Cell;
-	DWORD dwVnum;
-	DWORD dwCount;
-	DWORD dwFlags; // ÇÃ·¡±× Ãß°¡
-	DWORD dwAntiFlags; // ÇÃ·¡±× Ãß°¡
-	bool bHighLight;
-#if defined(ENABLE_SOULBIND_SYSTEM)
-	long lSealDate;
-#endif
-	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
-#endif
-#if defined(ENABLE_SET_ITEM)
-	BYTE bSetValue;
-#endif
-} TPacketGCItemSet;
-
-typedef struct packet_del_item
-{
-	BYTE header;
-	BYTE pos;
-} TPacketGCItemDel;
-
-typedef struct packet_use_item
-{
-	BYTE header;
-	TItemPos Cell;
-	DWORD ch_vid;
-	DWORD victim_vid;
-
-	DWORD vnum;
-} TPacketGCItemUse;
-
-typedef struct packet_update_item
-{
-	BYTE bHeader;
-	TItemPos Cell;
-	DWORD dwCount;
-#if defined(ENABLE_SOULBIND_SYSTEM)
-	long lSealDate;
-#endif
-	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
-#endif
-#if defined(ENABLE_SET_ITEM)
-	BYTE bSetValue;
-#endif
-} TPacketGCItemUpdate;
-
-typedef struct packet_ground_add_item
-{
-#if defined(ENABLE_ITEM_DROP_RENEWAL)
-	packet_ground_add_item()
-	{
-		memset(&alSockets, 0, sizeof(alSockets));
-		memset(&aAttrs, 0, sizeof(aAttrs));
-	}
-#endif
-
-	BYTE bHeader;
-	long lX, lY, lZ;
-	DWORD dwVID;
-	DWORD dwVnum;
-#if defined(ENABLE_SET_ITEM)
-	BYTE bSetValue;
-#endif
-
-#if defined(ENABLE_ITEM_DROP_RENEWAL)
-	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
-	TPlayerItemAttribute aAttrs[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
-#endif
-} TPacketGCItemGroundAdd;
-
-typedef struct packet_ground_del_item
-{
-	BYTE header;
-	DWORD vid;
-} TPacketGCItemGroundDel;
-
-typedef struct packet_item_ownership
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGCItemOwnership;
-
-typedef struct packet_quickslot_add
-{
-	BYTE header;
-	BYTE pos;
-	TQuickSlot slot;
-} TPacketGCQuickSlotAdd;
-
-typedef struct packet_quickslot_del
-{
-	BYTE header;
-	BYTE pos; // quick slot pos
-} TPacketGCQuickSlotDel;
-
-typedef struct packet_quickslot_swap
-{
-	BYTE header;
-	BYTE pos;
-	BYTE change_pos;
-} TPacketGCQuickSlotSwap;
-
-typedef struct packet_shop_start
-{
-#if defined(ENABLE_MYSHOP_DECO)
-	BYTE shop_tab_count;
-#endif
-#if defined(ENABLE_MYSHOP_EXPANSION)
-	struct packet_shop_item items[SHOP_HOST_ITEM_MAX];
-#else
-	struct packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
-#endif
-} TPacketGCShopStart;
-
-typedef struct packet_shop_start_ex // ´ÙÀ½¿¡ TSubPacketShopTab* shop_tabs ÀÌ µû¶ó¿È.
-{
-	typedef struct sub_packet_shop_tab
-	{
-		char name[SHOP_TAB_NAME_MAX];
-		BYTE coin_type;
-		packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
-	} TSubPacketShopTab;
-	DWORD owner_vid;
-	BYTE shop_tab_count;
-} TPacketGCShopStartEx;
-
-typedef struct packet_shop_update_item
-{
-	BYTE pos;
-	struct packet_shop_item item;
-} TPacketGCShopUpdateItem;
-
-typedef struct packet_shop_update_price
-{
-	int iElkAmount;
-#if defined(ENABLE_CHEQUE_SYSTEM)
-	int iChequeAmount;
-#endif
-} TPacketGCShopUpdatePrice;
-
-enum EPacketShopSubHeaders
-{
-	SHOP_SUBHEADER_GC_NONE,
-	SHOP_SUBHEADER_GC_START,
-	SHOP_SUBHEADER_GC_END,
-	SHOP_SUBHEADER_GC_UPDATE_ITEM,
-	SHOP_SUBHEADER_GC_UPDATE_PRICE,
-	SHOP_SUBHEADER_GC_OK,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY,
-	SHOP_SUBHEADER_GC_SOLDOUT,
-	SHOP_SUBHEADER_GC_INVENTORY_FULL,
-	SHOP_SUBHEADER_GC_INVALID_POS,
-	SHOP_SUBHEADER_GC_SOLD_OUT,
-	SHOP_SUBHEADER_GC_START_EX,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY_EX,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_BP,
-	SHOP_SUBHEADER_GC_EXCEED_LIMIT_TODAY,
-#if defined(ENABLE_MYSHOP_DECO)
-	SHOP_SUBHEADER_GC_MYPRIV_SHOP_OPEN,
-#endif
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_10TH_COIN,
-	SHOP_SUBHEADER_GC_LIMITED_PURCHASE_OVER,
-	SHOP_SUBHEADER_GC_LIMITED_DATA_LOADING,
-	SHOP_SUBHEADER_GC_UNK_19,
-	SHOP_SUBHEADER_GC_UNK_20,
-	SHOP_SUBHEADER_GC_UNK_21,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_MEDAL_OF_HONOR,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_GUILD_LEVEL,
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_BNW,
-#if defined(ENABLE_SHOPEX_RENEWAL)
-	SHOP_SUBHEADER_GC_NOT_ENOUGH_ITEM,
-#endif
-};
-
-typedef struct packet_shop
-{
-	BYTE header;
-	WORD size;
-	BYTE subheader;
-} TPacketGCShop;
-
-typedef struct packet_exchange
-{
-	BYTE header;
-	BYTE subheader;
-	BYTE is_me;
-	DWORD arg1;
-	TItemPos arg2;
-	DWORD arg3;
-	TItemPos arg4;
-	long alValues[ITEM_SOCKET_SLOT_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
-#endif
-#if defined(ENABLE_SET_ITEM)
-	BYTE bSetValue;
-#endif
-} TPacketGCExchange;
-
-enum
-{
-	EXCHANGE_SUBHEADER_GC_START, // arg1 == vid
-	EXCHANGE_SUBHEADER_GC_ITEM_ADD, // arg1 == vnum  arg2 == pos  arg3 == count
-	EXCHANGE_SUBHEADER_GC_ITEM_DEL, // arg1 == pos
-	EXCHANGE_SUBHEADER_GC_ELK_ADD, // arg1 == elk
-#if defined(ENABLE_CHEQUE_SYSTEM)
-	EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, // arg1 == cheque
-#endif
-	EXCHANGE_SUBHEADER_GC_ACCEPT, // arg1 == accept
-	EXCHANGE_SUBHEADER_GC_END, // arg1 == not used
-	EXCHANGE_SUBHEADER_GC_ALREADY, // arg1 == not used
-	EXCHANGE_SUBHEADER_GC_LESS_ELK, // arg1 == not used
-#if defined(ENABLE_CHEQUE_SYSTEM)
-	EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, // arg1 == not used
-#endif
-};
-
-typedef struct packet_position
-{
-	BYTE header;
-	DWORD vid;
-	BYTE position;
-} TPacketGCPosition;
-
-typedef struct packet_ping
-{
-	BYTE header;
-} TPacketGCPing;
-
-typedef struct packet_pong
-{
-	BYTE bHeader;
-} TPacketCGPong;
-
-typedef struct packet_script
-{
-	BYTE header;
-	WORD size;
-	BYTE skin;
-	WORD src_size;
-} TPacketGCScript;
-
-typedef struct packet_target
-{
-	BYTE header;
-	DWORD dwVID;
-	BYTE bHPPercent;
-#if defined(ENABLE_VIEW_TARGET_DECIMAL_HP) || defined(ENABLE_DEFENSE_WAVE)
-	int iMinHP;
-	int iMaxHP;
-#if defined(ENABLE_DEFENSE_WAVE)
-	bool bAlliance;
-#endif
-#endif
-#if defined(ENABLE_ELEMENT_ADD)
-	BYTE bElement[CPythonNonPlayer::MOB_ELEMENT_MAX_NUM];
-#endif
-} TPacketGCTarget;
-
-#if defined(ENABLE_SEND_TARGET_INFO)
-typedef struct SPacketGCTargetDropInfo
-{
-	DWORD dwVnum;
-	BYTE bCount;
-} TPacketGCTargetDropInfo;
-
-typedef struct SPacketGCTargetInfo
-{
-	BYTE bHeader;
-	WORD wSize;
-	DWORD dwRaceVnum;
-	DWORD dwVID;
-	bool bDropMetinStone;
-} TPacketGCTargetInfo;
-
-typedef struct SPacketCGTargetInfo
-{
-	BYTE bHeader;
-	DWORD dwVID;
-} TPacketCGTargetInfo;
-#endif
-
-typedef struct packet_damage_info
-{
-	BYTE header;
-	DWORD dwVID;
-	BYTE flag;
-	int  damage;
-} TPacketGCDamageInfo;
-
-typedef struct packet_mount
-{
-	BYTE header;
-	DWORD vid;
-	DWORD mount_vid;
-	BYTE pos;
-	DWORD _x, _y;
-} TPacketGCMount;
-
-typedef struct packet_change_speed
-{
-	BYTE header;
-	DWORD vid;
-	WORD moving_speed;
-} TPacketGCChangeSpeed;
-
-typedef struct packet_move
-{
-	BYTE bHeader;
-	BYTE bFunc;
-	BYTE bArg;
-	BYTE bRot;
-	DWORD dwVID;
-	LONG lX;
-	LONG lY;
-	DWORD dwTime;
-	DWORD dwDuration;
-} TPacketGCMove;
-
-enum
-{
-	QUEST_SEND_IS_BEGIN = 1 << 0,
-	QUEST_SEND_TITLE = 1 << 1, // 28ÀÚ ±îÁö
-	QUEST_SEND_CLOCK_NAME = 1 << 2, // 16ÀÚ ±îÁö
-	QUEST_SEND_CLOCK_VALUE = 1 << 3,
-	QUEST_SEND_COUNTER_NAME = 1 << 4, // 16ÀÚ ±îÁö
-	QUEST_SEND_COUNTER_VALUE = 1 << 5,
-	QUEST_SEND_ICON_FILE = 1 << 6, // 24ÀÚ ±îÁö 
-};
-
-typedef struct packet_quest_info
-{
-	BYTE header;
-	WORD size;
-	WORD index;
-#if defined(ENABLE_QUEST_RENEWAL)
-	BYTE type;
-	bool is_confirmed;
-#endif
-	BYTE flag;
-} TPacketGCQuestInfo;
-
-typedef struct packet_quest_confirm
-{
-	BYTE header;
-	char msg[128 + 1];
-	long timeout;
-	DWORD requestPID;
-} TPacketGCQuestConfirm;
-
-typedef struct packet_attack
-{
-	BYTE header;
-	DWORD dwVID;
-	DWORD dwVictimVID; // Àû VID
-	BYTE bType; // °ø°Ý À¯Çü
-} TPacketGCAttack;
-
-typedef struct packet_c2c
-{
-	BYTE header;
-	WORD wSize;
-} TPacketGCC2C;
-
-typedef struct packetd_sync_position_element
-{
-	DWORD dwVID;
-	long lX;
-	long lY;
-} TPacketGCSyncPositionElement;
-
-typedef struct packetd_sync_position
-{
-	BYTE bHeader;
-	WORD wSize;
-} TPacketGCSyncPosition;
-
-typedef struct packet_ownership
-{
-	BYTE bHeader;
-	DWORD dwOwnerVID;
-	DWORD dwVictimVID;
-} TPacketGCOwnership;
-
-#define	SKILL_MAX_NUM 255
-
-typedef struct packet_skill_level
-{
-	BYTE bHeader;
-	BYTE abSkillLevels[SKILL_MAX_NUM];
-} TPacketGCSkillLevel;
-
-typedef struct SPlayerSkill
-{
-	BYTE bMasterType;
-	BYTE bLevel;
-	time_t tNextRead;
-} TPlayerSkill;
-
-typedef struct packet_skill_level_new
-{
-	BYTE bHeader;
-	TPlayerSkill skills[SKILL_MAX_NUM];
-} TPacketGCSkillLevelNew;
-
-// fly
-typedef struct packet_fly
-{
-	BYTE bHeader;
-	BYTE bType;
-	DWORD dwStartVID;
-	DWORD dwEndVID;
-} TPacketGCCreateFly;
-
-enum EPVPModes
-{
-	PVP_MODE_NONE,
-	PVP_MODE_AGREE,
-	PVP_MODE_FIGHT,
-	PVP_MODE_REVENGE,
-};
-
-typedef struct packet_duel_start
-{
-	BYTE header;
-	WORD wSize; // DWORD°¡ ¸î°³? °³¼ö = (wSize - sizeof(TPacketGCPVPList)) / 4
-} TPacketGCDuelStart;
-
-typedef struct packet_pvp
-{
-	BYTE header;
-	DWORD dwVIDSrc;
-	DWORD dwVIDDst;
-	BYTE bMode;
-} TPacketGCPVP;
-
-typedef struct packet_warp
-{
-	BYTE bHeader;
-	LONG lX;
-	LONG lY;
-	LONG lAddr;
-	WORD wPort;
-} TPacketGCWarp;
-
-typedef struct packet_party_invite
-{
-	BYTE header;
-	DWORD leader_pid;
-} TPacketGCPartyInvite;
-
-typedef struct packet_party_add
-{
-	BYTE header;
-	DWORD pid;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-	long mapIdx;
-#endif
-#if defined(ENABLE_PARTY_CHANNEL_FIX)
-	BYTE channel;
-#endif
-} TPacketGCPartyAdd;
-
-typedef struct packet_party_update
-{
-	BYTE header;
-	DWORD pid;
-	BYTE state;
-	BYTE percent_hp;
-	short affects[PARTY_AFFECT_SLOT_MAX_NUM];
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-	long x;
-	long y;
-#endif
-} TPacketGCPartyUpdate;
-
-typedef struct packet_party_remove
-{
-	BYTE header;
-	DWORD pid;
-} TPacketGCPartyRemove;
-
-typedef TPacketCGSafeboxCheckout TPacketGCSafeboxCheckout;
-typedef TPacketCGSafeboxCheckin TPacketGCSafeboxCheckin;
-
-typedef struct packet_safebox_wrong_password
-{
-	BYTE bHeader;
-} TPacketGCSafeboxWrongPassword;
-
-typedef struct packet_safebox_size
-{
-	BYTE bHeader;
-	BYTE bSize;
-} TPacketGCSafeboxSize;
-
-typedef struct packet_safebox_money_change
-{
-	BYTE bHeader;
-	DWORD dwMoney;
-} TPacketGCSafeboxMoneyChange;
-
-typedef struct command_empire
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-} TPacketCGEmpire;
-
-typedef struct packet_empire
-{
-	BYTE bHeader;
-	BYTE bEmpire;
-} TPacketGCEmpire;
-
-enum
-{
-	FISHING_SUBHEADER_GC_START,
-	FISHING_SUBHEADER_GC_STOP,
-	FISHING_SUBHEADER_GC_REACT,
-	FISHING_SUBHEADER_GC_SUCCESS,
-	FISHING_SUBHEADER_GC_FAIL,
-	FISHING_SUBHEADER_GC_FISH,
-};
-
-typedef struct packet_fishing
-{
-	BYTE header;
-	BYTE subheader;
-	DWORD info;
-	BYTE dir;
-} TPacketGCFishing;
-
-typedef struct paryt_parameter
-{
-	BYTE bHeader;
-	BYTE bDistributeMode;
-} TPacketGCPartyParameter;
-
-//////////////////////////////////////////////////////////////////////////
-// Guild
-
-enum
-{
-	GUILD_SUBHEADER_GC_LOGIN,
-	GUILD_SUBHEADER_GC_LOGOUT,
-	GUILD_SUBHEADER_GC_LIST,
-	GUILD_SUBHEADER_GC_GRADE,
-	GUILD_SUBHEADER_GC_ADD,
-	GUILD_SUBHEADER_GC_REMOVE,
-	GUILD_SUBHEADER_GC_GRADE_NAME,
-	GUILD_SUBHEADER_GC_GRADE_AUTH,
-	GUILD_SUBHEADER_GC_INFO,
-	GUILD_SUBHEADER_GC_COMMENTS,
-	GUILD_SUBHEADER_GC_CHANGE_EXP,
-	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GRADE,
-	GUILD_SUBHEADER_GC_SKILL_INFO,
-	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GENERAL,
-	GUILD_SUBHEADER_GC_GUILD_INVITE,
-	GUILD_SUBHEADER_GC_WAR,
-	GUILD_SUBHEADER_GC_GUILD_NAME,
-	GUILD_SUBHEADER_GC_GUILD_WAR_LIST,
-	GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST,
-	GUILD_SUBHEADER_GC_WAR_POINT,
-	GUILD_SUBHEADER_GC_MONEY_CHANGE,
-};
-
-typedef struct packet_guild
-{
-	BYTE header;
-	WORD size;
-	BYTE subheader;
-} TPacketGCGuild;
-
-// SubHeader - Grade
-enum
-{
-	GUILD_AUTH_ADD_MEMBER = (1 << 0),
-	GUILD_AUTH_REMOVE_MEMBER = (1 << 1),
-	GUILD_AUTH_NOTICE = (1 << 2),
-	GUILD_AUTH_SKILL = (1 << 3),
-};
-
-typedef struct packet_guild_sub_grade
-{
-	char grade_name[GUILD_GRADE_NAME_MAX_LEN + 1]; // 8+1 ±æµåÀå, ±æµå¿ø µîÀÇ ÀÌ¸§
-	BYTE auth_flag;
-} TPacketGCGuildSubGrade;
-
-typedef struct packet_guild_sub_member
-{
-	DWORD pid;
-	BYTE byGrade;
-	BYTE byIsGeneral;
-	BYTE byJob;
-	BYTE byLevel;
-	DWORD dwOffer;
-	BYTE byNameFlag;
-	//if NameFlag is TRUE, name is sent from server.
-	//	char szName[CHARACTER_ME_MAX_LEN + 1];
-} TPacketGCGuildSubMember;
-
-typedef struct packet_guild_sub_info
-{
-	WORD member_count;
-	WORD max_member_count;
-	DWORD guild_id;
-	DWORD master_pid;
-	DWORD exp;
-	BYTE level;
-	char name[GUILD_NAME_MAX_LEN + 1];
-	DWORD gold;
-	BYTE hasLand;
-} TPacketGCGuildInfo;
-
-enum EGuildWarState
-{
-	GUILD_WAR_NONE,
-	GUILD_WAR_SEND_DECLARE,
-	GUILD_WAR_REFUSE,
-	GUILD_WAR_RECV_DECLARE,
-	GUILD_WAR_WAIT_START,
-	GUILD_WAR_CANCEL,
-	GUILD_WAR_ON_WAR,
-	GUILD_WAR_END,
-
-	GUILD_WAR_DURATION = 2 * 60 * 60, // 2½Ã°£
-};
-
-typedef struct packet_guild_war
-{
-	DWORD dwGuildSelf;
-	DWORD dwGuildOpp;
-	BYTE bType;
-	BYTE bWarState;
-} TPacketGCGuildWar;
-
-typedef struct SPacketGuildWarPoint
-{
-	DWORD dwGainGuildID;
-	DWORD dwOpponentGuildID;
-	long lPoint;
-} TPacketGuildWarPoint;
-
-// SubHeader - Dungeon
-enum
-{
-	DUNGEON_SUBHEADER_GC_TIME_ATTACK_START = 0,
-	DUNGEON_SUBHEADER_GC_DESTINATION_POSITION = 1,
-};
-
-typedef struct packet_dungeon
-{
-	BYTE bHeader;
-	WORD size;
-	BYTE subheader;
-} TPacketGCDungeon;
-
-// Private Shop
-typedef struct SPacketGCShopSign
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	char szSign[SHOP_SIGN_MAX_LEN + 1];
-#if defined(ENABLE_MYSHOP_DECO)
-	BYTE bType;
-#endif
-} TPacketGCShopSign;
-
-typedef struct SPacketGCTime
-{
-	BYTE bHeader;
-	time_t time;
-} TPacketGCTime;
-
-enum
-{
-	WALKMODE_RUN,
-	WALKMODE_WALK,
-};
-
-typedef struct SPacketGCWalkMode
-{
-	BYTE header;
-	DWORD vid;
-	BYTE mode;
-} TPacketGCWalkMode;
-
-typedef struct SPacketGCChangeSkillGroup
-{
-	BYTE header;
-	BYTE skill_group;
-} TPacketGCChangeSkillGroup;
-
-struct TMaterial
-{
-	DWORD vnum;
-	DWORD count;
-};
-
-typedef struct SRefineTable
-{
-	DWORD src_vnum;
-	DWORD result_vnum;
-	WORD material_count;
-	int cost; // ¼Ò¿ä ºñ¿ë
-	int prob; // È®·ü
-	TMaterial materials[REFINE_MATERIAL_MAX_NUM];
-} TRefineTable;
-
-typedef struct SPacketGCRefineInformation
-{
-	BYTE header;
-	BYTE pos;
-	TRefineTable refine_table;
-} TPacketGCRefineInformation;
-
-typedef struct SPacketGCRefineInformationNew
-{
-	BYTE header;
-	BYTE type;
-	BYTE pos;
-	TRefineTable refine_table;
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
-#endif
-} TPacketGCRefineInformationNew;
-
-enum SPECIAL_EFFECT
-{
-	SE_NONE,
-
-	SE_HPUP_RED,
-	SE_SPUP_BLUE,
-	SE_SPEEDUP_GREEN,
-	SE_DXUP_PURPLE,
-	SE_CRITICAL,
-	SE_PENETRATE,
-	SE_BLOCK,
-	SE_DODGE,
-	SE_CHINA_FIREWORK,
-	SE_SPIN_TOP,
-	SE_SUCCESS,
-	SE_FAIL,
-	SE_FR_SUCCESS,
-	SE_LEVELUP_ON_14_FOR_GERMANY, //·¹º§¾÷ 14ÀÏ¶§ ( µ¶ÀÏÀü¿ë )
-	SE_LEVELUP_UNDER_15_FOR_GERMANY, //·¹º§¾÷ 15ÀÏ¶§ ( µ¶ÀÏÀü¿ë )
-	SE_PERCENT_DAMAGE1,
-	SE_PERCENT_DAMAGE2,
-	SE_PERCENT_DAMAGE3,
-
-	SE_AUTO_HPUP,
-	SE_AUTO_SPUP,
-
-	SE_EQUIP_RAMADAN_RING, // ÃÊ½Â´ÞÀÇ ¹ÝÁö¸¦ Âø¿ëÇÏ´Â ¼ø°£¿¡ ¹ßµ¿ÇÏ´Â ÀÌÆåÆ®
-	SE_EQUIP_HALLOWEEN_CANDY, // ÇÒ·ÎÀ© »çÅÁÀ» Âø¿ë(-_-;)ÇÑ ¼ø°£¿¡ ¹ßµ¿ÇÏ´Â ÀÌÆåÆ®
-	SE_EQUIP_HAPPINESS_RING, // Å©¸®½º¸¶½º Çàº¹ÀÇ ¹ÝÁö¸¦ Âø¿ëÇÏ´Â ¼ø°£¿¡ ¹ßµ¿ÇÏ´Â ÀÌÆåÆ®
-	SE_EQUIP_LOVE_PENDANT, // ¹ß·»Å¸ÀÎ »ç¶ûÀÇ ÆÒ´øÆ®(71145) Âø¿ëÇÒ ¶§ ÀÌÆåÆ® (¹ßµ¿ÀÌÆåÆ®ÀÓ, Áö¼ÓÀÌÆåÆ® ¾Æ´Ô)
-
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-	SE_ACCE_SUCESS_ABSORB,
-	SE_ACCE_EQUIP,
-	SE_ACCE_BACK,
-#endif
-
-	SE_EQUIP_EASTER_CANDY,
-
-	SE_THUNDER_AREA,
-	SE_THUNDER,
-	SE_HEAL,
-
-	SE_CAPE_OF_COURAGE,
-	SE_EQUIP_CHOCOLATE_PENDANT,
-#if defined(ENABLE_BALANCE_IMPROVING)
-	SE_FEATHER_WALK,
-#endif
-	SE_PEPSI_EVENT,
-
-#if defined(ENABLE_GUILD_DRAGONLAIR_SYSTEM)
-	SE_DRAGONLAIR_STONE_UNBEATABLE_1,
-	SE_DRAGONLAIR_STONE_UNBEATABLE_2,
-	SE_DRAGONLAIR_STONE_UNBEATABLE_3,
-#endif
-
-	SE_BATTLE_POTION, // Battle Field
-	SE_REFLECT, // AI_FLAG_REFLECT
-
-	SE_SKILL_DAMAGE_ZONE,
-	SE_SKILL_SAFE_ZONE,
-	SE_METEOR,
-	SE_BEAD_RAIN,
-	SE_ARROW_RAIN,
-	SE_FALL_ROCK,
-	SE_HORSE_DROP,
-	SE_EGG_DROP,
-	SE_DEAPO_BOOM,
-
-#if defined(ENABLE_FLOWER_EVENT)
-	SE_FLOWER_EVENT,
-#endif
-#if defined(ENABLE_GEM_SYSTEM)
-	SE_GEM_PENDANT,
-#endif
-#if defined(ENABLE_DEFENSE_WAVE)
-	SE_DEFENSE_WAVE_LASER,
-#endif
-	SE_PET_ATTR_CHANGE_NEW_TYPE,
-	SE_PET_PAY_SUMMON1,
-#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
-	SE_SPECIAL_ROULETTE,
-#endif
-	SE_MISTS_ISLAND_0,
-	SE_MISTS_ISLAND_1,
-	SE_MISTS_ISLAND_2,
-	SE_MISTS_ISLAND_3,
-	SE_PASSIVE_ATTR_SKILL,
-	SE_SUICIDE_BOMB_SMALL,
-	SE_SUICIDE_BOMB_LARGE,
-	SE_GROUND_THORN,
-	SE_GROUND_SNAKE,
-	SE_WHITE_DRAGON_BERSERK,
-	SE_WHITE_DRAGON_COOLING,
-	SE_USE_METINSTONE_RAIN_SPAWN_TICKET,
-	SE_FAKE_METINSTONE_SPLASH_DAMAGE,
-	SE_MOUNT_UPGRADE_SKILL,
-	SE_SOUTH_REAPER_SKILL_2,
-	SE_YEOMWANG_SKILL_2,
-	SE_BUFF_ITEM_5,
-	SE_BUFF_ITEM_13,
-	SE_BUFF_ITEM_14,
-	SE_BUFF_SYMBOL1,
-	SE_BUFF_ITEM_8_ELEMENT_1,
-	SE_BUFF_ITEM_8_ELEMENT_2,
-	SE_BUFF_FLOWER_OF_GALE,
-	SE_BUFF_FLOWER_OF_DESTRUCTION,
-	SE_SUNGMAHEE_GATE_FLOWER_BLOW_RANGE,
-	SE_SUNGMAHEE_GATE_INVINCIBLE_GATE,
-	SE_SUNGMAHEE_GATE_NORMAL_GATE,
-	SE_MOUNT_UPGRADE_GYEONGGONG,
-#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
-	SE_USE_SNOWFLAKE_STICK,
-#endif
-	SE_SPORTS_MATCH_BUFF_EMBLEM,
-	SE_POINT_AREA_ELECT_ATTACK,
-#ifdef ENABLE_QUEEN_NETHIS
-	SE_EFFECT_SNAKE_REGEN,
-#endif
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-	SE_EFFECT_BP_NORMAL_MISSION_COMPLETED,
-	SE_EFFECT_BP_PREMIUM_MISSION_COMPLETED,
-	SE_EFFECT_BP_EVENT_MISSION_COMPLETED,
-	SE_EFFECT_BP_NORMAL_BATTLEPASS_COMPLETED,
-	SE_EFFECT_BP_PREMIUM_BATTLEPASS_COMPLETED,
-	SE_EFFECT_BP_EVENT_BATTLEPASS_COMPLETED,
-#endif
-#ifdef ENABLE_GROWTH_PET_SYSTEM
-	SE_GYEONGGONG_BOOM,
-#endif
-};
-
-enum ESpecialEffectType
-{
-	SE_TYPE_NORMAL,
-	SE_TYPE_POSITION,
-};
-
-typedef struct SPacketGCSpecialEffect
-{
-	BYTE bHeader;
-	BYTE bEffectNum;
-	DWORD dwVID;
-	BYTE bEffectType;
-	long xEffectPos, yEffectPos;
-} TPacketGCSpecialEffect;
-
-typedef struct SPacketGCNPCPosition
-{
-	BYTE header;
-	WORD size;
-	WORD count;
-} TPacketGCNPCPosition;
-
-struct TNPCPosition
-{
-	BYTE bType;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-	long x;
-	long y;
-};
-
-typedef struct SPacketGCChangeName
-{
-	BYTE header;
-	DWORD pid;
-	char name[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGCChangeName;
-
-enum EBlockAction
-{
-	BLOCK_EXCHANGE = (1 << 0),
-	BLOCK_PARTY_INVITE = (1 << 1),
-	BLOCK_GUILD_INVITE = (1 << 2),
-	BLOCK_WHISPER = (1 << 3),
-	BLOCK_MESSENGER_INVITE = (1 << 4),
-	BLOCK_PARTY_REQUEST = (1 << 5),
-};
-
-typedef struct packet_login_key
-{
-	BYTE bHeader;
-	DWORD dwLoginKey;
-} TPacketGCLoginKey;
-
-typedef struct packet_auth_success
-{
-	BYTE bHeader;
-	DWORD dwLoginKey;
-	BYTE bResult;
-} TPacketGCAuthSuccess;
-
-typedef struct packet_channel
-{
-	BYTE header;
-	BYTE channel;
-} TPacketGCChannel;
-
-typedef struct SEquipmentItemSet
-{
-	DWORD dwVnum;
-	BYTE bCount;
-	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-	DWORD dwTransmutationVnum;
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
-#endif
-#if defined(ENABLE_SET_ITEM)
-	BYTE bSetValue;
-#endif
-} TEquipmentItemSet;
-
-typedef struct pakcet_view_equip
-{
-	BYTE bHeader;
-	DWORD dwVID;
-	TEquipmentItemSet Equips[WEAR_MAX_NUM];
-} TPacketGCViewEquip;
-
-typedef struct
-{
-	DWORD dwID;
-	long x, y;
-	long width, height;
-	DWORD dwGuildID;
-} TLandPacketElement;
-
-typedef struct packet_land_list
-{
-	BYTE header;
-	WORD size;
-} TPacketGCLandList;
-
-typedef struct
-{
-	BYTE bHeader;
-	long lID;
-	char szTargetName[32 + 1];
-} TPacketGCTargetCreate;
-
-enum
-{
-	CREATE_TARGET_TYPE_NONE,
-	CREATE_TARGET_TYPE_LOCATION,
-	CREATE_TARGET_TYPE_CHARACTER,
-};
-
-typedef struct
-{
-	BYTE bHeader;
-	long lID;
-	char szTargetName[32 + 1];
-	DWORD dwVID;
-	BYTE byType;
-} TPacketGCTargetCreateNew;
-
-typedef struct
-{
-	BYTE bHeader;
-	long lID;
-	long lX, lY;
-} TPacketGCTargetUpdate;
-
-typedef struct
-{
-	BYTE bHeader;
-	long lID;
-} TPacketGCTargetDelete;
-
-typedef struct
-{
-	DWORD dwType;
-	POINT_TYPE wApplyOn;
-	POINT_VALUE lApplyValue;
-	DWORD dwFlag;
-	long lDuration;
-	long lSPCost;
-#if defined(ENABLE_AFFECT_RENEWAL)
-	bool bRealTime;
-	bool bUpdate;
-#endif
-} TPacketAffectElement;
-
-typedef struct
-{
-	BYTE bHeader;
-	TPacketAffectElement elem;
-} TPacketGCAffectAdd;
-
-typedef struct
-{
-	BYTE bHeader;
-	DWORD dwType;
-	POINT_TYPE wApplyOn;
-} TPacketGCAffectRemove;
-
-typedef struct packet_mall_open
-{
-	BYTE bHeader;
-	BYTE bSize;
-} TPacketGCMallOpen;
-
-typedef struct packet_lover_info
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	BYTE byLovePoint;
-} TPacketGCLoverInfo;
-
-typedef struct packet_love_point_update
-{
-	BYTE bHeader;
-	BYTE byLovePoint;
-} TPacketGCLovePointUpdate;
-
-typedef struct packet_dig_motion
-{
-	BYTE header;
-	DWORD vid;
-	DWORD target_vid;
-	BYTE count;
-} TPacketGCDigMotion;
-
-typedef struct SPacketGCOnTime
-{
-	BYTE header;
-	int ontime; // sec
-} TPacketGCOnTime;
-
-typedef struct SPacketGCResetOnTime
-{
-	BYTE header;
-} TPacketGCResetOnTime;
-
-typedef struct SPacketGCPanamaPack
-{
-	BYTE bHeader;
-	char szPackName[256];
-	BYTE abIV[32];
-} TPacketGCPanamaPack;
-
-typedef struct SPacketGCHybridCryptKeys
-{
-private:
-	SPacketGCHybridCryptKeys() : m_pStream(NULL) {}
-
-public:
-	SPacketGCHybridCryptKeys(int iStreamSize) : iKeyStreamLen(iStreamSize)
-	{
-		m_pStream = new BYTE[iStreamSize];
-	}
-	~SPacketGCHybridCryptKeys()
-	{
-		if (m_pStream)
-		{
-			delete[] m_pStream;
-			m_pStream = NULL;
-		}
-	}
-	static int GetFixedHeaderSize()
-	{
-		return sizeof(BYTE) + sizeof(WORD) + sizeof(int);
-	}
-
-	BYTE bHeader;
-	WORD wDynamicPacketSize;
-	int iKeyStreamLen;
-	BYTE* m_pStream;
-
-} TPacketGCHybridCryptKeys;
-
-typedef struct SPacketGCHybridSDB
-{
-private:
-	SPacketGCHybridSDB() : m_pStream(NULL) {}
-
-public:
-	SPacketGCHybridSDB(int iStreamSize) : iSDBStreamLen(iStreamSize)
-	{
-		m_pStream = new BYTE[iStreamSize];
-	}
-	~SPacketGCHybridSDB()
-	{
-		delete[] m_pStream;
-		m_pStream = NULL;
-	}
-	static int GetFixedHeaderSize()
-	{
-		return sizeof(BYTE) + sizeof(WORD) + sizeof(int);
-	}
-
-	BYTE bHeader;
-	WORD wDynamicPacketSize;
-	int iSDBStreamLen;
-	BYTE* m_pStream;
-
-} TPacketGCHybridSDB;
-
-/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// Client To Client
-
-typedef struct packet_state
-{
-	BYTE bHeader;
-	BYTE bFunc;
-	BYTE bArg;
-	BYTE bRot;
-	DWORD dwVID;
-	DWORD dwTime;
-	TPixelPosition kPPos;
-} TPacketCCState;
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-struct TPacketKeyAgreement
-{
-	static const int MAX_DATA_LEN = 256;
-	BYTE bHeader;
-	WORD wAgreedLength;
-	WORD wDataLength;
-	BYTE data[MAX_DATA_LEN];
-};
-
-struct TPacketKeyAgreementCompleted
-{
-	BYTE bHeader;
-	BYTE data[3]; // dummy (not used)
-};
-#endif
-
-typedef struct SPacketGCSpecificEffect
-{
-	BYTE header;
-	DWORD vid;
-	char effect_file[128];
-} TPacketGCSpecificEffect;
-
-#if defined(ENABLE_DRAGON_SOUL_SYSTEM)
-// ¿ëÈ¥¼®
-enum EDragonSoulRefineWindowRefineType
-{
-	DragonSoulRefineWindow_UPGRADE,
-	DragonSoulRefineWindow_IMPROVEMENT,
-	DragonSoulRefineWindow_REFINE,
-};
-
-enum EPacketCGDragonSoulSubHeaderType
-{
-	DS_SUB_HEADER_OPEN,
-	DS_SUB_HEADER_CLOSE,
-	DS_SUB_HEADER_DO_UPGRADE,
-	DS_SUB_HEADER_DO_IMPROVEMENT,
-	DS_SUB_HEADER_DO_REFINE,
-	DS_SUB_HEADER_REFINE_FAIL,
-	DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE,
-	DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL,
-	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY,
-	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL,
-	DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL,
-	DS_SUB_HEADER_REFINE_SUCCEED,
-#if defined(ENABLE_DS_CHANGE_ATTR)
-	DS_SUB_HEADER_OPEN_CHANGE_ATTR,
-	DS_SUB_HEADER_DO_CHANGE_ATTR,
-#endif
-};
-
-typedef struct SPacketCGDragonSoulRefine
-{
-	SPacketCGDragonSoulRefine() : header(HEADER_CG_DRAGON_SOUL_REFINE) {}
-	BYTE header;
-	BYTE bSubType;
-	TItemPos ItemGrid[DS_REFINE_WINDOW_MAX_NUM];
-} TPacketCGDragonSoulRefine;
-
-typedef struct SPacketGCDragonSoulRefine
-{
-	SPacketGCDragonSoulRefine() : header(HEADER_GC_DRAGON_SOUL_REFINE) {}
-	BYTE header;
-	BYTE bSubType;
-	TItemPos Pos;
-} TPacketGCDragonSoulRefine;
-#endif
-
-typedef struct SChannelStatus
-{
-	short nPort;
-	BYTE bStatus;
-} TChannelStatus;
-
-#if defined(ENABLE_MINI_GAME_CATCH_KING)
-enum EMiniGameCatchKingCGSubHeader
-{
-	CATCHKING_CG_START,
-	CATCHKING_CG_CLICK_HAND,
-	CATCHKING_CG_CLICK_CARD,
-	CATCHKING_CG_REWARD,
-#if defined(ENABLE_CATCH_KING_EVENT_FLAG_RENEWAL)
-	CATCHKING_CG_REQUEST_QUEST_FLAG,
-#endif
-};
-
-enum EMiniGameCatchKingGCSubHeader
-{
-	CATCHKING_GC_START,
-	CATCHKING_GC_SET_CARD,
-	CATCHKING_GC_RESULT_FIELD,
-	CATCHKING_GC_SET_END_CARD,
-	CATCHKING_GC_REWARD,
-#if defined(ENABLE_CATCH_KING_EVENT_FLAG_RENEWAL)
-	CATCHKING_GC_SET_CARD_PIECE_FLAG,
-	CATCHKING_GC_SET_CARD_FLAG,
-	CATCHKING_GC_SET_QUEST_FLAG,
-	CATCHKING_GC_NO_MORE_GAIN,
-#endif
-};
-
-typedef struct SPacketCGMiniGameCatchKing
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSubArgument;
-} TPacketCGMiniGameCatchKing;
-
-typedef struct SPacketGCMiniGameCatchKing
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMiniGameCatchKing;
-
-typedef struct SPacketGCCatchKingEventInfo
-{
-	BYTE bHeader;
-	bool bIsEnable;
-} TPacketGCCatchKingEventInfo;
-
-typedef struct SPacketGCMiniGameCatchKingResult
-{
-	DWORD dwPoints;
-	BYTE bRowType;
-	BYTE bCardPos;
-	BYTE bCardValue;
-	bool bKeepFieldCard;
-	bool bDestroyHandCard;
-	bool bGetReward;
-	bool bIsFiveNearBy;
-} TPacketGCMiniGameCatchKingResult;
-
-typedef struct SPacketGCMiniGameCatchKingSetEndCard
-{
-	BYTE bCardPos;
-	BYTE bCardValue;
-} TPacketGCMiniGameCatchKingSetEndCard;
-
-#if defined(ENABLE_CATCH_KING_EVENT_FLAG_RENEWAL)
-typedef struct SPacketGCMiniGameCatchKingQuestFlag
-{
-	WORD wPieceCount, wPackCount;
-} TPacketGCMiniGameCatchKingQuestFlag;
-#endif
-#endif
-
-#if defined(ENABLE_SKILLBOOK_COMB_SYSTEM)
-typedef struct SPacketCGSkillBookCombination
-{
-	BYTE bHeader;
-	BYTE bAction;
-	TItemPos CombItemGrid[SKILLBOOK_COMB_SLOT_MAX];
-} TPacketCGSkillBookCombination;
-#endif
-
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-enum ESubHeaderGCAcceRefine
-{
-	ACCE_REFINE_SUBHEADER_GC_CLOSE,
-	ACCE_REFINE_SUBHEADER_GC_OPEN,
-	ACCE_REFINE_SUBHEADER_GC_SET_ITEM,
-	ACCE_REFINE_SUBHEADER_GC_CLEAR_SLOT,
-	ACCE_REFINE_SUBHEADER_GC_CLEAR_ALL,
-	ACCE_REFINE_SUBHEADER_GC_CLEAR_RIGHT,
-};
-
-typedef struct SSubPacketGCAcceRefineOpenClose
-{
-	BYTE bType;
-	bool bServerClose;
-} TSubPacketGCAcceRefineOpenClose;
-
-typedef struct SSubPacketGCAcceRefineSetItem
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	TItemData Item;
-} TSubPacketGCAcceRefineSetItem;
-
-typedef struct SSubPacketGCAcceRefineClearSlot
-{
-	BYTE bSlotIndex;
-} TSubPacketGCAcceRefineClearSlot;
-
-enum ESubHeaderCGAcceRefine
-{
-	ACCE_REFINE_SUBHEADER_CG_CHECKIN,
-	ACCE_REFINE_SUBHEADER_CG_CHECKOUT,
-	ACCE_REFINE_SUBHEADER_CG_ACCEPT,
-	ACCE_REFINE_SUBHEADER_CG_CANCEL,
-};
-
-typedef struct SSubPacketCGAcceRefineCheckIn
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAcceRefineCheckIn;
-
-typedef struct SSubPacketCGAcceRefineCheckOut
-{
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAcceRefineCheckOut;
-
-typedef struct SSubPacketCGAcceRefineAccept
-{
-	BYTE bType;
-} TSubPacketCGAcceRefineAccept;
-
-typedef struct SPacketGCAcceRefine
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCAcceRefine;
-
-typedef struct SPacketCGAcceRefine
-{
-	SPacketCGAcceRefine() : bHeader(HEADER_CG_ACCE_REFINE) {}
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketCGAcceRefine;
-#endif
-
-#if defined(ENABLE_AURA_COSTUME_SYSTEM)
-enum ESubHeaderGCAuraRefine
-{
-	AURA_REFINE_SUBHEADER_GC_CLOSE,
-	AURA_REFINE_SUBHEADER_GC_OPEN,
-	AURA_REFINE_SUBHEADER_GC_SET_ITEM,
-	AURA_REFINE_SUBHEADER_GC_CLEAR_SLOT,
-	AURA_REFINE_SUBHEADER_GC_CLEAR_ALL,
-	AURA_REFINE_SUBHEADER_GC_INFO
-};
-
-typedef struct SSubPacketGCAuraRefineOpenClose
-{
-	BYTE bType;
-	bool bServerClose;
-} TSubPacketGCAuraRefineOpenClose;
-
-typedef struct SSubPacketGCAuraRefineSetItem
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	TItemData Item;
-} TSubPacketGCAuraRefineSetItem;
-
-typedef struct SSubPacketGCAuraRefineClearSlot
-{
-	BYTE bSlotIndex;
-} TSubPacketGCAuraRefineClearSlot;
-
-typedef struct SSubPacketGCAuraRefineInfo
-{
-	BYTE bInfoType;
-	BYTE bInfoLevel;
-	BYTE bInfoExpPercent;
-} TSubPacketGCAuraRefineInfo;
-
-enum ESubHeaderCGAuraRefine
-{
-	AURA_REFINE_SUBHEADER_CG_CHECKIN,
-	AURA_REFINE_SUBHEADER_CG_CHECKOUT,
-	AURA_REFINE_SUBHEADER_CG_ACCEPT,
-	AURA_REFINE_SUBHEADER_CG_CANCEL
-};
-
-typedef struct SSubPacketCGAuraRefineCheckIn
-{
-	TItemPos AttachedPos;
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAuraRefineCheckIn;
-
-typedef struct SSubPacketCGAuraRefineCheckOut
-{
-	TItemPos SelectedPos;
-	BYTE bType;
-} TSubPacketCGAuraRefineCheckOut;
-
-typedef struct SSubPacketCGAuraRefineAccept
-{
-	BYTE bType;
-} TSubPacketCGAuraRefineAccept;
-
-typedef struct SPacketGCAuraRefine
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCAuraRefine;
-
-typedef struct SPacketCGAuraRefine
-{
-	SPacketCGAuraRefine() : bHeader(HEADER_CG_AURA_REFINE) {}
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketCGAuraRefine;
-#endif
-
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-enum class EPacketCGChangeLookSubHeader : BYTE
-{
-	ITEM_CHECK_IN,
-	ITEM_CHECK_OUT,
-	FREE_ITEM_CHECK_IN,
-	FREE_ITEM_CHECK_OUT,
-	ACCEPT,
-	CANCEL
-};
-
-typedef struct packet_changelook_set
-{
-	BYTE bHeader;
-	WORD wCell;
-	BYTE bSlotIndex;
-} TPacketGCChangeLookSet;
-
-typedef struct packet_changelook_del
-{
-	BYTE bHeader;
-	WORD wCell;
-	BYTE bSlotIndex;
-} TPacketGCChangeLookDel;
-
-typedef struct command_changelook
-{
-	command_changelook(const BYTE c_bSubHeader) :
-		bHeader(HEADER_CG_CHANGE_LOOK),
-		bSubHeader(c_bSubHeader),
-		bSlotIndex(255)
-	{}
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSlotIndex;
-	TItemPos ItemPos;
-} TPacketCGChangeLook;
-#endif
-
-#if defined(ENABLE_MAILBOX)
-typedef struct packet_mailbox_process
-{
-	packet_mailbox_process() : bArg1(0), bArg2(0) {}
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bArg1;
-	BYTE bArg2;
-} TPacketMailboxProcess;
-
-typedef struct SMailBoxRespondUnreadData
-{
-	BYTE bHeader;
-	BYTE bItemMessageCount;
-	BYTE bCommonMessageCount;
-	bool bGMVisible;
-} TMailBoxRespondUnreadData;
-
-typedef struct packet_mailbox_process_all
-{
-	BYTE Index;
-} TPacketGCMailboxProcessAll;
-
-typedef struct packet_mailbox_add_data
-{
-	BYTE bHeader;
-	BYTE Index;
-	char szFrom[CHARACTER_NAME_MAX_LEN + 1];
-	char szMessage[100 + 1];
-	int iYang;
-	int iWon;
-	DWORD dwItemVnum;
-	DWORD dwItemCount;
-	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-	DWORD dwChangeLookVnum;
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-	TPlayerItemRefineElement RefineElement;
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
-#endif
-#if defined(ENABLE_SET_ITEM)
-	BYTE bSetValue;
-#endif
-} TPacketGCMailBoxAddData;
-
-typedef struct packet_mailbox_message
-{
-	time_t SendTime;
-	time_t DeleteTime;
-	char szTitle[25 + 1];
-	bool bIsGMPost;
-	bool bIsItemExist;
-	bool bIsConfirm;
-} TPacketGCMailBoxMessage;
-
-typedef struct packet_mailbox
-{
-	BYTE bHeader;
-	WORD wSize;
-} TPacketGCMailBox;
-
-typedef struct packet_mailbox_write
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-	char szTitle[25 + 1];
-	char szMessage[100 + 1];
-	TItemPos pos;
-	int iYang;
-	int iWon;
-} TPacketCGMailboxWrite;
-
-typedef struct packet_mailbox_write_confirm
-{
-	BYTE bHeader;
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketCGMailboxWriteConfirm;
-#endif
-
-#if defined(ENABLE_RANKING_SYSTEM)
-typedef struct SPartyMemberName
-{
-	char szName[CHARACTER_NAME_MAX_LEN + 1];
-} TPartyMember;
-
-typedef struct SRankingData
-{
-	char szGuildName[GUILD_NAME_MAX_LEN + 1];
-	SPartyMemberName Member[PARTY_MAX_MEMBER];
-	DWORD dwRecord0, dwRecord1;
-	DWORD dwStartTime;
-	BYTE bEmpire;
-} TRankingData;
-
-typedef struct SPacketGCRanking
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bType;
-	BYTE bCategory;
-} TPacketGCRanking;
-#endif
-
-#if defined(ENABLE_MOVE_COSTUME_ATTR)
-typedef struct packet_cg_item_combination
-{
-	BYTE Header;
-	short MediumIndex;
-	short BaseIndex;
-	short MaterialIndex;
-} TPacketCGItemCombination;
-
-typedef struct packet_cg_item_combination_cancel
-{
-	BYTE Header;
-} TPacketCGItemCombinationCancel;
-#endif
-
-#if defined(ENABLE_CHANGED_ATTR)
-typedef struct packet_gc_item_select_attr
-{
-	BYTE bHeader;
-	TItemPos pItemPos;
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
-} TPacketGCItemSelectAttr;
-
-typedef struct packet_cg_item_select_attr
-{
-	BYTE bHeader;
-	bool bNew;
-	TItemPos pItemPos;
-} TPacketCGItemSelectAttr;
-#endif
-
-#if defined(ENABLE_LOOTING_SYSTEM)
-typedef struct SPacketCGLootFilter
-{
-	BYTE header;
-	BYTE settings[ELootFilter::LOOT_FILTER_SETTINGS_MAX];
-} TPacketCGLootFilter;
-
-typedef struct SPacketGCLootFilter
-{
-	BYTE header;
-	bool enable;
-	DWORD vid;
-} TPacketGCLootFilter;
-#endif
-
-#if defined(ENABLE_MINI_GAME_RUMI)
-enum EMiniGameRumiCGSubHeader
-{
-	RUMI_CG_SUBHEADER_END,
-	RUMI_CG_SUBHEADER_START,
-	RUMI_CG_SUBHEADER_DECK_CARD_CLICK,
-	RUMI_CG_SUBHEADER_HAND_CARD_CLICK,
-	RUMI_CG_SUBHEADER_FIELD_CARD_CLICK,
-#if defined(ENABLE_OKEY_EVENT_FLAG_RENEWAL)
-	RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
-#endif
-};
-
-enum EMiniGameRumiGCSubHeader
-{
-	RUMI_GC_SUBHEADER_END,
-	RUMI_GC_SUBHEADER_START,
-	RUMI_GC_SUBHEADER_SET_DECK,
-	RUMI_GC_SUBHEADER_SET_SCORE,
-	RUMI_GC_SUBHEADER_MOVE_CARD,
-#if defined(ENABLE_OKEY_EVENT_FLAG_RENEWAL)
-	RUMI_GC_SUBHEADER_SET_CARD_PIECE_FLAG,
-	RUMI_GC_SUBHEADER_SET_CARD_FLAG,
-	RUMI_GC_SUBHEADER_SET_QUEST_FLAG,
-	RUMI_GC_SUBHEADER_NO_MORE_GAIN,
-#endif
-};
-
-typedef struct SPacketCGMiniGameRumi
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BOOL bUseCard;
-	BYTE bIndex;
-	SPacketCGMiniGameRumi() :
-		bHeader(HEADER_CG_MINI_GAME_RUMI),
-		bSubHeader(RUMI_CG_SUBHEADER_END),
-		bUseCard(FALSE),
-		bIndex(0)
-	{}
-} TPacketCGMiniGameRumi;
-
-typedef struct SPacketGCMiniGameRumiSetDeck
-{
-	BYTE bDeckCount;
-} TPacketGCMiniGameRumiSetDeck;
-
-typedef struct SPacketGCMiniGameRumiMoveCard
-{
-	BYTE bSrcPos, bSrcIndex, bSrcColor, bSrcNumber;
-	BYTE bDstPos, bDstIndex, bDstColor, bDstNumber;
-} TPacketGCMiniGameRumiMoveCard;
-
-typedef struct SPacketGCMiniGameRumiSetScore
-{
-	WORD wScore, wTotalScore;
-} TPacketGCMiniGameRumiSetScore;
-
-#if defined(ENABLE_OKEY_EVENT_FLAG_RENEWAL)
-typedef struct SPacketGCMiniGameRumiQuestFlag
-{
-	WORD wCardPieceCount, wCardCount;
-} TPacketGCMiniGameRumiQuestFlag;
-#endif
-
-typedef struct SPacketGCMiniGameRumi
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMiniGameRumi;
-#endif
-
-#if defined(ENABLE_LUCKY_BOX)
-enum ELUCKY_BOX_ACTION
-{
-	LUCKY_BOX_ACTION_RETRY,
-	LUCKY_BOX_ACTION_RECEIVE,
-};
-
-typedef struct SPacketCGLuckyBox
-{
-	BYTE bHeader;
-	BYTE bAction;
-} TPacketCGLuckyBox;
-
-typedef struct SPacketGCLuckyBox
-{
-	BYTE bHeader;
-	DWORD dwVNum;
-	BYTE bCount;
-	int iNeedMoney;
-	WORD wSlotIndex;
-} TPacketGCLuckyBox;
-#endif
-
-#if defined(ENABLE_ATTR_6TH_7TH)
-enum EAttr67AddSubHeader
-{
-	SUBHEADER_CG_ATTR67_ADD_CLOSE,
-	SUBHEADER_CG_ATTR67_ADD_OPEN,
-	SUBHEADER_CG_ATTR67_ADD_REGIST,
-};
-
-typedef struct SPacketCGAttr67Add
-{
-	BYTE byHeader;
-	BYTE bySubHeader;
-	TAttr67AddData Attr67AddData;
-} TPacketCGAttr67Add;
-#endif
-
-#if defined(ENABLE_FISHING_GAME)
-enum EFishingGameSubHeader
-{
-	FISHING_GAME_SUBHEADER_OPEN,
-	FISHING_GAME_SUBHEADER_GOAL,
-	FISHING_GAME_SUBHEADER_QUIT,
-};
-
-typedef struct SPacketGCFishingGame
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bLevel;
-} TPacketGCFishingGame;
-
-typedef struct SPacketCGFishingGame
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bGoals;
-} TPacketCGFishingGame;
-#endif
-
-#if defined(ENABLE_GEM_SYSTEM)
-enum EGemShopSubHeader : BYTE
-{
-	SUBHEADER_GEM_SHOP_CLOSE,
-	SUBHEADER_GEM_SHOP_OPEN,
-	SUBHEADER_GEM_SHOP_BUY,
-	SUBHEADER_GEM_SHOP_SLOT_ADD,
-	SUBHEADER_GEM_SHOP_REFRESH,
-	SUBHEADER_GEM_SHOP_MAX,
-};
-
-typedef struct SPacketGCGemShop
-{
-	BYTE bHeader;
-	WORD wSize;
-} TPacketGCGemShop;
-
-typedef struct SPacketGCGemShopProcess
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSlotIndex;
-	bool bEnable;
-} TPacketGCGemShopProcess;
-
-typedef struct command_gem_shop
-{
-	command_gem_shop(const BYTE c_bSubHeader, const BYTE c_bSlotIndex)
-		: bHeader(HEADER_CG_GEM_SHOP), bSubHeader(c_bSubHeader), bSlotIndex(c_bSlotIndex)
-	{}
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bSlotIndex;
-} TPacketCGGemShop;
-#endif
-
-#if defined(ENABLE_EXTEND_INVEN_SYSTEM)
-typedef struct SPacketCGExtendInven
-{
-	BYTE bHeader;
-	bool bUpgrade;
-	BYTE bIndex;
-} TPacketCGExtendInven;
-
-typedef struct SPacketGCExtendInven
-{
-	BYTE bHeader;
-	BYTE bStage;
-	WORD wMaxNum;
-} TPacketGCExtendInven;
-
-typedef struct SPacketGCExtendInvenItemUse
-{
-	BYTE bHeader;
-	BYTE bMsgResult;
-	BYTE bEnoughCount;
-} TPacketGCExtendInvenItemUse;
-#endif
-
-#if defined(ENABLE_CLIENT_TIMER)
-enum EClientTimerSubHeader
-{
-	CLIENT_TIMER_SUBHEADER_GC_SET,
-	CLIENT_TIMER_SUBHEADER_GC_DELETE
-};
-
-enum EClientTimer
-{
-	ECLIENT_TIMER_END_TIME,
-	ECLIENT_TIMER_ALARM_SECOND,
-	ECLIENT_TIMER_MAX
-};
-
-typedef struct SPacketGCClientTimer
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwData[ECLIENT_TIMER_MAX];
-} TPacketGCClientTimer;
-#endif
-
-enum EEmoteSubHeader
-{
-	SUBHEADER_EMOTE_ADD,
-	SUBHEADER_EMOTE_CLEAR,
-	SUBHEADER_EMOTE_MOTION,
-	SUBHEADER_EMOTE_ICON,
-};
-
-typedef struct SPacketGCEmote
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwEmoteVnum;
-	DWORD dwDuration;
-	DWORD dwMainVID, dwTargetVID;
-} TPacketGCEmote;
-
-#if defined(ENABLE_CUBE_RENEWAL)
-enum ECubeSubHeader
-{
-	SUBHEADER_GC_CUBE_OPEN = 0,
-	SUBHEADER_GC_CUBE_CLOSE,
-	SUBHEADER_GC_CUBE_RESULT,
-
-	SUBHEADER_CG_CUBE_CLOSE = 0,
-	SUBHEADER_CG_CUBE_MAKE,
-};
-
-typedef struct SPacketGCCube
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwNPCVnum;
-	BOOL bSuccess;
-	DWORD dwFileCrc;
-} TPacketGCCube;
-
-typedef struct SPacketCGCube
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	UINT iCubeIndex;
-	UINT iQuantity;
-	INT iImproveItemPos;
-	DWORD dwFileCrc;
-} TPacketCGCube;
-#endif
-
-#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
-enum ESubPacketGCSnowflakeStickEvent
-{
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_SNOW_BALL,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_TREE_BRANCH,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_SNOW_BALL_MAX,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_TREE_BRANCH_MAX,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_STICK_SUCCESS,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_PET_SUCCESS,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_MOUNT_SUCCESS,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_USE_STICK_FAILED,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_RANK_BUFF,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_SNOWFLAKE_BUFF,
-	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ENABLE,
-};
-
-enum ESnowflakeStickEventQuestFlagType
-{
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_SNOW_BALL,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_TREE_BRANCH,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK_COOLDOWN,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_PET,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_MOUNT,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_USE_STICK_COOLDOWN,
-	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM,
-};
-
-typedef struct SPacketGCSnowflakeStickEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	DWORD dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM];
-} TPacketGCSnowflakeStickEvent;
-
-enum ESubPacketCGSnowflakeStickEvent
-{
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_REQUEST_INFO,
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_STICK,
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_PET,
-	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_MOUNT
-};
-
-typedef struct SPacketCGSnowflakeStickEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	SPacketCGSnowflakeStickEvent(const BYTE c_bSubHeader)
-		: bHeader(HEADER_CG_SNOWFLAKE_STICK_EVENT), bSubHeader(c_bSubHeader) {}
-} TPacketCGSnowflakeStickEvent;
-#endif
-
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-enum ERefineElementSubHeader
-{
-	REFINE_ELEMENT_GC_OPEN,
-	REFINE_ELEMENT_GC_RESULT
-};
-
-enum EPacketCGRefineElement
-{
-	REFINE_ELEMENT_CG_CLOSE,
-	REFINE_ELEMENT_CG_REFINE,
-};
-
-typedef struct SPacketGCRefineElement
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bRefineType;
-	BYTE bResult;
-	TItemPos SrcPos;
-	TItemPos DestPos;
-} TPacketGCRefineElement;
-
-typedef struct SPacketCGRefineElement
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	WORD wChangeElement;
-	SPacketCGRefineElement(BYTE bSubHeader, WORD wChangeElement)
-		: bHeader(HEADER_CG_REFINE_ELEMENT), bSubHeader(bSubHeader), wChangeElement(wChangeElement) {}
-} TPacketCGRefineElement;
-#endif
-
-#if defined(ENABLE_MINI_GAME_YUTNORI)
-enum EMiniGameYutnoriGCSubHeader
-{
-	YUTNORI_GC_SUBHEADER_START,
-	YUTNORI_GC_SUBHEADER_STOP,
-	YUTNORI_GC_SUBHEADER_SET_PROB,
-	YUTNORI_GC_SUBHEADER_THROW,
-	YUTNORI_GC_SUBHEADER_MOVE,
-	YUTNORI_GC_SUBHEADER_AVAILABLE_AREA,
-	YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT,
-	YUTNORI_GC_SUBHEADER_SET_SCORE,
-	YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT,
-	YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN,
-#if defined(ENABLE_YUTNORI_EVENT_FLAG_RENEWAL)
-	YUTNORI_GC_SUBHEADER_SET_YUT_PIECE_FLAG,
-	YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG,
-	YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG,
-	YUTNORI_GC_SUBHEADER_NO_MORE_GAIN,
-#endif
-};
-
-enum EMiniGameYutnoriCGSubHeader
-{
-	YUTNORI_CG_SUBHEADER_START,
-	YUTNORI_CG_SUBHEADER_GIVEUP,
-	YUTNORI_CG_SUBHEADER_SET_PROB,
-	YUTNORI_CG_SUBHEADER_CLICK_CHAR,
-	YUTNORI_CG_SUBHEADER_THROW,
-	YUTNORI_CG_SUBHEADER_MOVE,
-	YUTNORI_CG_SUBHEADER_REQUEST_COM_ACTION,
-	YUTNORI_CG_SUBHEADER_REWARD,
-#if defined(ENABLE_YUTNORI_EVENT_FLAG_RENEWAL)
-	YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
-#endif
-};
-
-typedef struct SPacketCGMiniGameYutnori
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bArgument;
-} TPacketCGMiniGameYutnori;
-
-typedef struct SPacketGCMiniGameYutnori
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-} TPacketGCMiniGameYutnori;
-
-typedef struct SPacketGCMiniGameYutnoriSetProb
-{
-	BYTE bProbIndex;
-} TPacketGCMiniGameYutnoriSetProb;
-
-typedef struct SPacketGCMiniGameYutnoriThrowYut
-{
-	bool bPC;
-	BYTE bYut;
-} TPacketGCMiniGameYutnoriThrowYut;
-
-typedef struct SPacketGCMiniGameYutnoriMoveYut
-{
-	bool bPC;
-	BYTE bUnitIndex;
-	bool bIsCatch;
-	BYTE bStartIndex;
-	BYTE bDestIndex;
-} TPacketGCMiniGameYutnoriMoveYut;
-
-typedef struct SPacketGCMiniGameYutnoriAvailableArea
-{
-	BYTE bPlayerIndex;
-	BYTE bAvailableIndex;
-} TPacketGCMiniGameYutnoriAvailableArea;
-
-typedef struct SPacketGCMiniGameYutnoriPushCatchYut
-{
-	bool bPC;
-	BYTE bUnitIndex;
-} TPacketGCMiniGameYutnoriPushCatchYut;
-
-typedef struct SPacketGCMiniGameYutnoriSetScore
-{
-	WORD wScore;
-} TPacketGCMiniGameYutnoriSetScore;
-
-typedef struct SPacketGCMiniGameYutnoriSetRemainCount
-{
-	BYTE bRemainCount;
-} TPacketGCMiniGameYutnoriSetRemainCount;
-
-typedef struct SPacketGCMiniGameYutnoriPushNextTurn
-{
-	bool bPC;
-	BYTE bState;
-} TPacketGCMiniGameYutnoriPushNextTurn;
-
-#if defined(ENABLE_YUTNORI_EVENT_FLAG_RENEWAL)
-typedef struct SPacketGCMiniGameYutnoriQuestFlag
-{
-	WORD wYutPieceCount;
-	WORD wYutBoardCount;
-} TPacketGCMiniGameYutnoriQuestFlag;
-#endif
-#endif
-
-#if defined(ENABLE_QUEST_REQUEST_EVENT)
-typedef struct SPacketCGRequestEventQuest
-{
-	BYTE bHeader;
-	char szEventQuest[64 + 1];
-} TPacketCGRequestEventQuest;
-#endif
-
-#if defined(ENABLE_LEFT_SEAT)
-enum ELeftSeatCGSubHeader
-{
-	LEFT_SEAT_SET_WAIT_TIME_INDEX,
-	LEFT_SEAT_SET_LOGOUT_TIME_INDEX,
-	LEFT_SEAT_DISABLE_LOGOUT_STATE,
-};
-
-typedef struct SPacketCGLeftSeat
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bIndex;
-} TPacketCGLeftSeat;
-#endif
-
-#if defined(ENABLE_GUILD_DRAGONLAIR_SYSTEM)
-enum EGuildDragonLairType
-{
-	GUILD_DRAGONLAIR_TYPE_RED,
-	GUILD_DRAGONLAIR_TYPE_BLUE,
-	GUILD_DRAGONLAIR_TYPE_GREEN,
-	GUILD_DRAGONLAIR_TYPE_MAX_NUM
-};
-
-enum EGuildDragonLairSubHeader
-{
-	GUILD_DRAGONLAIR_GC_SUBHEADER_RANKING,
-#if defined(ENABLE_GUILD_DRAGONLAIR_PARTY_SYSTEM)
-	GUILD_DRAGONLAIR_GC_SUBHEADER_1ST_GUILD_TEXT,
-	GUILD_DRAGONLAIR_GC_SUBHEADER_START,
-	GUILD_DRAGONLAIR_GC_SUBHEADER_SUCCESS,
-#endif
-};
-
-typedef struct SPacketGCGuildDragonLair
-{
-	BYTE bHeader;
-	WORD wSize;
-	BYTE bSubHeader;
-	BYTE bType;
-#if defined(ENABLE_GUILD_DRAGONLAIR_PARTY_SYSTEM)
-	DWORD dwSeconds;
-#endif
-} TPacketGCGuildDragonLair;
-
-typedef struct SPacketGCGuildDragonLairRanking
-{
-	BYTE bType;
-	DWORD dwGuildID;
-	char szGuildName[GUILD_NAME_MAX_LEN + 1];
-	BYTE bMemberCount;
-	DWORD dwTime;
-} TPacketGCGuildDragonLairRanking;
-#endif
-
-#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
-enum EPacketGCMiniGameRouletteSubHeader
-{
-	ROULETTE_GC_OPEN,
-	ROULETTE_GC_START,
-	ROULETTE_GC_REQUEST,
-	ROULETTE_GC_END,
-	ROULETTE_GC_CLOSE
-};
-
-enum EPacketCGMiniGameRouletteSubHeader
-{
-	ROULETTE_CG_START,
-	ROULETTE_CG_REQUEST,
-	ROULETTE_CG_END,
-	ROULETTE_CG_CLOSE
-};
-
-typedef struct SPacketGCMiniGameRoulette
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bResult;
-	DWORD dwExpireTime;
-	struct
-	{
-		DWORD dwVnum;
-		BYTE bCount;
-	} ItemData[ROULETTE_ITEM_MAX];
-} TPacketGCMiniGameRoulette;
-
-typedef struct SPacketCGMiniGameRoulette
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-} TPacketCGMiniGameRoulette;
-#endif
-
-#if defined(ENABLE_FLOWER_EVENT)
-enum EPacketGCFlowerEvent
-{
-	FLOWER_EVENT_SUBHEADER_GC_INFO_ALL,
-	FLOWER_EVENT_SUBHEADER_GC_GET_INFO,
-	FLOWER_EVENT_SUBHEADER_GC_UPDATE_INFO
-};
-
-typedef struct SPacketGCFlowerEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bChatType;
-	BYTE bShootType;
-	int aiShootCount[SHOOT_TYPE_MAX + 1];
-} TPacketGCFlowerEvent;
-
-enum EPacketCGFlowerEvent
-{
-	FLOWER_EVENT_SUBHEADER_CG_INFO_ALL,
-	FLOWER_EVENT_SUBHEADER_CG_EXCHANGE
-};
-
-typedef struct SPacketCGFlowerEvent
-{
-	BYTE bHeader;
-	BYTE bSubHeader;
-	BYTE bShootType;
-	BYTE bExchangeKey;
-	SPacketCGFlowerEvent()
-		: bHeader(HEADER_CG_FLOWER_EVENT)
-		, bSubHeader(FLOWER_EVENT_SUBHEADER_CG_INFO_ALL)
-		, bShootType(SHOOT_TYPE_MAX)
-		, bExchangeKey(0)
-	{}
-} TPacketCGFlowerEvent;
-#endif
-
-#ifdef ENABLE_SHOP_SEARCH
-typedef std::pair<uint32_t, uint16_t> TShopSearchItemID;
-
-enum EShopSearchData {
-	SHOPSEARCH_ITEM_SUBTYPE_MAX_VALUE = 13,
-	SHOPSEARCH_SOLD_ITEM_INFO_COUNT = 30,
-
-	SHOPSEARCH_BUY_SUCCESS = 0,
-	SHOPSEARCH_BUY_NOT_EXIST,
-	SHOPSEARCH_BUY_PRICE_CHANGE,
-	SHOPSEARCH_BUY_TIMEOUT,
-	SHOPSEARCH_BUY_NO_PEER,
-	SHOPSEARCH_BUY_UNKNOWN_ERROR,
-
-	SHOPSEARCH_SORT_RANDOM = 0,
-	SHOPSEARCH_SORT_ASC,
-	SHOPSEARCH_SORT_DESC,
-	SHOPSEARCH_SORT_MAX_NUM,
-};
-
-enum EShopSearchAveragePriceLevels {
-	SHOPSEARCH_AVG_PRICE_GOOD,
-	SHOPSEARCH_AVG_PRICE_NORMAL,
-	SHOPSEARCH_AVG_PRICE_BAD,
-	SHOPSEARCH_AVG_PRICE_WORST,
-};
-
-typedef struct SShopSearchClientItem
-{
-	DWORD	id;
-	BYTE	window;
-	WORD	pos;
-	DWORD	count;
-
-	DWORD	vnum;
-	long	alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
-
-	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
-#if defined(ENABLE_APPLY_RANDOM)
-	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
-#endif
-	DWORD	owner;
-
-#ifdef ENABLE_SOUL_BIND_SYSTEM
-	long soulbind;
-#endif
-
-	DWORD	transmutate_id;
-
-	TShopSearchItemID offlineID;
-	int64_t price;
-	DWORD endTime;
-
-	BYTE	avgPriceLevel;
-} TShopSearchClientItem;
-
-typedef struct SShopSearchOptions
-{
-	BYTE		typeFlagCount;
-	BYTE		specificVnumCount;
-} TShopSearchOptions;
-
-typedef std::pair<DWORD, DWORD> TShopSearchItemType;
-
-typedef struct SPacketGCShopSearchResult {
-	BYTE	header;
-	WORD	size;
-	WORD	itemCount;
-	WORD	maxPageNum;
-} TPacketGCShopSearchResult;
-
-typedef struct SPacketCGShopSearchByName {
-	BYTE	header;
-	char	itemName[CItemData::ITEM_NAME_MAX_LEN + 1];
-	WORD	page;
-	BYTE	entryCountIdx;
-	BYTE	sortType;
-} TPacketCGShopSearchByName;
-
-typedef struct SPacketCGShopSearchByOptions {
-	BYTE	header;
-	TShopSearchOptions	options;
-	WORD	page;
-	BYTE	entryCountIdx;
-	BYTE	sortType;
-} TPacketCGShopSearchByOptions;
-
-typedef struct SPacketCGShopSearchBuy {
-	BYTE	header;
-	TShopSearchItemID	itemID;
-	DWORD	itemVnum;
-	int64_t	itemPrice;
-} TPacketCGShopSearchBuy;
-
-typedef struct SPacketGCShopSearchBuyResult {
-	BYTE	header;
-	BYTE	result;
-} TPacketGCShopSearchBuyResult;
-
-typedef struct SPacketCGShopSearchOwnerMessage {
-	BYTE	header;
-	DWORD	ownerID;
-} TPacketCGShopSearchOwnerMessage;
-
-typedef struct SPacketGCShopSearchOwnerMessage {
-	BYTE	header;
-	char	ownerName[CHARACTER_NAME_MAX_LEN + 1];
-} TPacketGCShopSearchOwnerMessage;
-
-typedef struct SShopSearchSoldItemInfo {
-	SShopSearchSoldItemInfo() : count(0), averagePrice(0) { }
-
-	uint64_t	count;
-	double		averagePrice;
-} TShopSearchSoldItemInfo;
-
-typedef struct SPacketCGShopSearchRequestSoldInfo {
-	BYTE	header;
-	DWORD	itemVnum;
-} TPacketCGShopSearchRequestSoldInfo;
-
-typedef struct SPacketGCShopSearchSoldInfo {
-	BYTE	header;
-	WORD	size;
-	bool	results;
-} TPacketGCShopSearchSoldInfo;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-typedef struct SPacketCGExtBattlePassAction
-{
-	BYTE bHeader;
-	BYTE bAction;
-} TPacketCGExtBattlePassAction;
-
-typedef struct SPacketCGExtBattlePassSendPremiumItem
-{
-	BYTE bHeader;
-	int iSlotIndex;
-} TPacketCGExtBattlePassSendPremiumItem;
-
-typedef struct SPacketGCExtBattlePassOpen
-{
-	BYTE bHeader;
-} TPacketGCExtBattlePassOpen;
-
-typedef struct SPacketGCExtBattlePassGeneralInfo
-{
-	BYTE bHeader;
-	BYTE bBattlePassType;
-	char	szSeasonName[64+1];
-	DWORD dwBattlePassID;
-	DWORD dwBattlePassStartTime;
-	DWORD dwBattlePassEndTime;
-} TPacketGCExtBattlePassGeneralInfo;
-
-typedef struct SPacketGCExtBattlePassMissionInfo
-{
-	BYTE bHeader;
-	WORD wSize;
-	WORD wRewardSize;
-	BYTE bBattlePassType;
-	DWORD dwBattlePassID;
-} TPacketGCExtBattlePassMissionInfo;
-
-typedef struct SPacketGCExtBattlePassMissionUpdate
-{
-	BYTE bHeader;
-	BYTE bBattlePassType;
-	BYTE bMissionIndex;
-	BYTE bMissionType;
-	DWORD dwNewProgress;
-} TPacketGCExtBattlePassMissionUpdate;
-
-typedef struct SPacketGCExtBattlePassRanking
-{
-	BYTE bHeader;
-	char	szPlayerName[CHARACTER_NAME_MAX_LEN + 1];
-	BYTE bBattlePassType;
-	BYTE	bBattlePassID;
-	DWORD	dwStartTime;
-	DWORD	dwEndTime;
-} TPacketGCExtBattlePassRanking;
-#endif
-
-#ifdef ENABLE_GROWTH_PET_SYSTEM
-enum EGrowthPetPoints
-{
-	POINT_UPBRINGING_PET_LEVEL,
-	POINT_UPBRINGING_PET_EXP,
-	POINT_UPBRINGING_PET_ITEM_EXP,
-	POINT_UPBRINGING_PET_NEXT_EXP,
-	POINT_UPBRINGING_PET_EVOL_LEVEL,
-	POINT_UPBRINGING_PET_HP,
-	POINT_UPBRINGING_PET_DEF_GRADE,
-	POINT_UPBRINGING_PET_SP,
-	POINT_UPBRINGING_DURATION,
-	POINT_UPBRINGING_MAX_DURATION,
-	POINT_UPBRINGING_BIRTHDAY,
-
-	POINT_UPBRINGING_MAX_NUM
-};
-
-enum EGrowthPetSubheader
-{
-	SUBHEADER_PET_EGG_USE_SUCCESS,
-	SUBHEADER_PET_EGG_USE_FAILED_BECAUSE_NAME,
-	SUBHEADER_PET_EGG_USE_FAILED_TIMEOVER,
-	SUBHEADER_PET_UNSUMMON,
-	SUBHEADER_PET_FEED_FAILED,
-	SUBHEADER_PET_FEED_SUCCESS,
-	SUBHEADER_PET_REVIVE_FAILED,
-	SUBHEADER_PET_REVIVE_SUCCESS,
-	SUBHEADER_PET_NAME_CHANGE_FAILED,
-	SUBHEADER_PET_NAME_CHANGE_SUCCESS,
-	SUBHEADER_PET_WINDOW_TYPE_INFO,
-	SUBHEADER_PET_WINDOW_TYPE_ATTR_CHANGE,
-	SUBHEADER_PET_WINDOW_TYPE_PREMIUM_FEED,
-};
-
-enum EGrowthPetWindow
-{
-	PET_WINDOW_HATCH,
-	PET_WINDOW_NAME_CHANGE,
-};
-
-typedef struct SPacketGCPet
-{
-	BYTE	header;
-	BYTE	subheader;
-} TPacketGCPet;
-
-typedef struct SPetSkillPacket
-{
-	bool    bLocked;
-	BYTE    bSkill;
-	BYTE    bLevel;
-	DWORD    dwCooltime;
-} TPetSkillPacket;
-
-typedef struct SPacketGCPetSet
-{
-	BYTE		header;
-	DWORD		dwID;
-	DWORD		dwSummonItemVnum;
-	char		szName[CItemData::PET_NAME_MAX_SIZE + 1];
-	TPetSkillPacket	aSkill[PET_SKILL_COUNT_MAX];
-	DWORD		dwPoints[POINT_UPBRINGING_MAX_NUM];
-} TPacketGCPetSet;
-
-typedef struct SPacketGCPetDelete
-{
-	BYTE		header;
-	DWORD		dwID;
-} TPacketGCPetDelete;
-
-typedef struct SPacketGCPetPointUpdate
-{
-	BYTE	header;
-	DWORD	dwID;
-	BYTE	bPoint;
-	DWORD	dwValue;
-} TPacketGCPetPointUpdate;
-
-typedef struct SPacketGCPetSummon
-{
-	BYTE		header;
-	DWORD		dwID;
-} TPacketGCPetSummon;
-
-typedef struct SPacketGCPetDetermineResult
-{
-	BYTE		header;
-	BYTE		type;
-} TPacketGCPetDetermineResult;
-
-typedef struct SPacketGCPetAttrChangeResult
-{
-	BYTE		header;
-	BYTE		type;
-	TItemPos	pos;
-} TPacketGCPetAttrChangeResult;
-
-typedef struct SPetSkillUpdatePacket
-{
-	bool	bLocked;
-	BYTE	bSkill;
-	BYTE	bLevel;
-	DWORD	dwCooltime;
-	BYTE	bSkillFormula1[PET_GROWTH_SKILL_LEVEL_MAX];
-	WORD	wSkillFormula2[PET_GROWTH_SKILL_LEVEL_MAX];
-	BYTE	bSkillFormula3[PET_GROWTH_SKILL_LEVEL_MAX];
-} TPetSkillUpdatePacket;
-
-typedef struct SPacketGCPetSkillCooltime
-{
-	BYTE		header;
-	DWORD		dwID;
-	BYTE		bSlot;
-	DWORD		dwCooltime;
-} TPacketGCPetSkillCooltime;
-
-typedef struct SPacketGCPetSkillUpdate
-{
-	BYTE		header;
-	DWORD		dwID;
-	TPetSkillUpdatePacket	aSkill[PET_SKILL_COUNT_MAX];
-} TPacketGCPetSkillUpdate;
-
-typedef struct SPacketGCPetNameChangeResult
-{
-	BYTE		header;
-	BYTE		subheader;
-	DWORD		dwID;
-	char		szName[CItemData::PET_NAME_MAX_SIZE + 1];
-} TPacketGCPetNameChangeResult;
-
-typedef struct SPacketCGPetHatch
-{
-	BYTE		header;
-	char		name[CItemData::PET_NAME_MAX_SIZE + 1];
-	TItemPos	eggPos;
-} TPacketCGPetHatch;
-
-typedef struct SPacketCGPetWindow
-{
-	BYTE	header;
-	BYTE	window;
-	bool	state;
-} TPacketCGPetWindow;
-
-typedef struct SPacketCGPetWindowType
-{
-	BYTE	header;
-	BYTE	type;
-} TPacketCGPetWindowType;
-
-typedef struct SPacketCGPeFeed
-{
-	BYTE		header;
-	BYTE		index;
-	WORD		pos[PET_FEED_SLOT_MAX];
-	WORD		count[PET_FEED_SLOT_MAX];
-} TPacketCGPetFeed;
-
-typedef struct SPacketCGPetDetermine
-{
-	BYTE		header;
-	TItemPos	determinePos;
-} TPacketCGPetDetermine;
-
-typedef struct SPacketCGPetAttrChange
-{
-	BYTE		header;
-	TItemPos	upBringingPos;
-	TItemPos	attrChangePos;
-} TPacketCGPetAttrChange;
-
-typedef struct SPacketCGPetRevive
-{
-	BYTE		header;
-	TItemPos	upBringingPos;
-	WORD		pos[PET_REVIVE_MATERIAL_SLOT_MAX];
-	WORD		count[PET_REVIVE_MATERIAL_SLOT_MAX];
-} TPacketCGPetRevive;
-
-typedef struct SPacketCGPetLearnSkill
-{
-	BYTE		header;
-	BYTE		slotIndex;
-	TItemPos	learnSkillPos;
-} TPacketCGPetLearnSkill;
-
-typedef struct SPacketCGPetUpgradeSkill
-{
-	BYTE		header;
-	BYTE		slotIndex;
-} TPacketCGPetSkillUpgrade;
-
-typedef struct SPacketCGPetDeleteSkill
-{
-	BYTE		header;
-	BYTE		slotIndex;
-	TItemPos	deleteSkillPos;
-} TPacketCGPetDeleteSkill;
-
-typedef struct SPacketCGPetAllDeleteSkill
-{
-	BYTE		header;
-	TItemPos	deleteAllSkillPos;
-} TPacketCGPetDeleteAllSkill;
-
-typedef struct SPacketCGPetNameChange
-{
-	BYTE		header;
-	char		name[CItemData::PET_NAME_MAX_SIZE + 1];
-	TItemPos	changeNamePos;
-	TItemPos	upBringingPos;
-} TPacketCGPetNameChange;
-#endif
-
-#pragma pack(pop)
+#pragma once
+
+#include "../GameLib/RaceData.h"
+#include "PythonNonPlayer.h"
+#include "Locale_inc.h"
+
+typedef BYTE TPacketHeader;
+
+enum CG_HEADERS
+{
+	HEADER_CG_LOGIN = 1,
+	HEADER_CG_ATTACK = 2,
+	HEADER_CG_CHAT = 3,
+	HEADER_CG_PLAYER_CREATE = 4, // Î¿ Ã·Ì¾î¸¦ 
+	HEADER_CG_PLAYER_DESTROY = 5, // Ã·Ì¾î¸¦ .
+	HEADER_CG_PLAYER_SELECT = 6,
+	HEADER_CG_CHARACTER_MOVE = 7,
+	HEADER_CG_SYNC_POSITION = 8,
+	//HEADER_CG_DIRECT_ENTER = 9,
+	HEADER_CG_ENTERGAME = 10,
+
+	HEADER_CG_ITEM_USE = 11,
+	HEADER_CG_ITEM_DROP = 12,
+	HEADER_CG_ITEM_MOVE = 13,
+	//HEADER_CG_UNUSED = 14,
+	HEADER_CG_ITEM_PICKUP = 15,
+
+	HEADER_CG_QUICKSLOT_ADD = 16,
+	HEADER_CG_QUICKSLOT_DEL = 17,
+	HEADER_CG_QUICKSLOT_SWAP = 18,
+	HEADER_CG_WHISPER = 19,
+	HEADER_CG_ITEM_DROP2 = 20,
+#if defined(ENABLE_NEW_DROP_DIALOG)
+	HEADER_CG_ITEM_DESTROY = 21,
+#endif
+
+	//HEADER_CG_UNUSED = 22,
+	//HEADER_CG_UNUSED = 23,
+	//HEADER_CG_UNUSED = 24,
+	//HEADER_CG_UNUSED = 25,
+
+	HEADER_CG_ON_CLICK = 26,
+	HEADER_CG_EXCHANGE = 27,
+	HEADER_CG_CHARACTER_POSITION = 28,
+	HEADER_CG_SCRIPT_ANSWER = 29,
+	HEADER_CG_QUEST_INPUT_STRING = 30,
+	HEADER_CG_QUEST_CONFIRM = 31,
+#if defined(ENABLE_OX_RENEWAL)
+	HEADER_CG_QUEST_INPUT_LONG_STRING = 32,
+#endif
+#ifdef ENABLE_OFFLINE_SHOP
+	HEADER_CG_OFFLINE_SHOP = 33,
+#endif
+
+	//HEADER_CG_UNUSED = 34,
+
+#ifdef ENABLE_GROWTH_PET_SYSTEM
+	HEADER_CG_PET_HATCH = 35,
+	HEADER_CG_PET_WINDOW_TYPE = 36,
+	HEADER_CG_PET_WINDOW = 37,
+	HEADER_CG_PET_NAME_CHANGE = 38,
+	HEADER_CG_PET_FEED = 39,
+	HEADER_CG_PET_DETERMINE = 40,
+	HEADER_CG_PET_ATTR_CHANGE = 41,
+	HEADER_CG_PET_REVIVE = 42,
+	HEADER_CG_PET_LEARN_SKILL = 43,
+	HEADER_CG_PET_SKILL_UPGRADE = 44,
+	HEADER_CG_PET_DELETE_SKILL = 45,
+	HEADER_CG_PET_DELETE_ALL_SKILL = 46,
+#endif
+
+#if defined(ENABLE_EXTEND_INVEN_SYSTEM)
+	HEADER_CG_EXTEND_INVEN = 47,
+#endif
+	//HEADER_CG_UNUSED = 48,
+	//HEADER_CG_UNUSED = 49,
+
+	HEADER_CG_SHOP = 50,
+	HEADER_CG_FLY_TARGETING = 51,
+	HEADER_CG_USE_SKILL = 52,
+	HEADER_CG_ADD_FLY_TARGETING = 53,
+	HEADER_CG_SHOOT = 54,
+	HEADER_CG_MYSHOP = 55,
+#if defined(ENABLE_MYSHOP_DECO)
+	HEADER_CG_MYSHOP_DECO = 56,
+	HEADER_CG_MYSHOP_DECO_ADD = 57,
+#endif
+	//HEADER_CG_UNUSED = 58,
+
+#if defined(ENABLE_SEND_TARGET_INFO)
+	HEADER_CG_TARGET_INFO = 59,
+#endif
+	HEADER_CG_ITEM_USE_TO_ITEM = 60,
+	HEADER_CG_TARGET = 61,
+
+	//HEADER_CG_UNUSED = 62,
+	//HEADER_CG_UNUSED = 63,
+	HEADER_CG_TEXT = 64, // @  ÛµÇ¸ Ø½Æ® Ä½Ñ´.
+	HEADER_CG_WARP = 65,
+	HEADER_CG_SCRIPT_BUTTON = 66,
+	HEADER_CG_MESSENGER = 67,
+	//HEADER_CG_UNUSED = 68,
+
+	HEADER_CG_MALL_CHECKOUT = 69,
+	HEADER_CG_SAFEBOX_CHECKIN = 70, //  Ã¢ Ö´Â´.
+	HEADER_CG_SAFEBOX_CHECKOUT = 71, //  Ã¢  Â´.
+
+	HEADER_CG_PARTY_INVITE = 72,
+	HEADER_CG_PARTY_INVITE_ANSWER = 73,
+	HEADER_CG_PARTY_REMOVE = 74,
+	HEADER_CG_PARTY_SET_STATE = 75,
+	HEADER_CG_PARTY_USE_SKILL = 76,
+	HEADER_CG_SAFEBOX_ITEM_MOVE = 77,
+	HEADER_CG_PARTY_PARAMETER = 78,
+	//HEADER_CG_UNUSED = 79,
+
+	HEADER_CG_GUILD = 80,
+	HEADER_CG_ANSWER_MAKE_GUILD = 81,
+	HEADER_CG_FISHING = 82,
+	HEADER_CG_GIVE_ITEM = 83,
+#ifdef ENABLE_SHOP_SEARCH
+	HEADER_CG_SHOP_SEARCH_BY_NAME = 84,
+	HEADER_CG_SHOP_SEARCH_BY_OPTION = 85,
+	HEADER_CG_SHOP_SEARCH_BUY = 86,
+	HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE = 87,
+	HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO = 88,
+#endif
+	//HEADER_CG_UNUSED = 89,
+
+	HEADER_CG_EMPIRE = 90,
+	//HEADER_CG_UNUSED = 91,
+	//HEADER_CG_UNUSED = 92,
+	//HEADER_CG_UNUSED = 93,
+	//HEADER_CG_UNUSED = 94,
+	//HEADER_CG_UNUSED = 95,
+
+	HEADER_CG_REFINE = 96,
+#if defined(ENABLE_CUBE_RENEWAL)
+	HEADER_CG_CUBE = 97,
+#endif
+	//HEADER_CG_UNUSED = 98,
+	//HEADER_CG_UNUSED = 99,
+
+	HEADER_CG_MARK_LOGIN = 100,
+	HEADER_CG_MARK_CRCLIST = 101,
+	HEADER_CG_MARK_UPLOAD = 102,
+	//HEADER_CG_CRC_REPORT = 103,
+	HEADER_CG_MARK_IDXLIST = 104,
+
+	HEADER_CG_HACK = 105,
+	HEADER_CG_CHANGE_NAME = 106,
+	//HEADER_CG_UNUSED = 107,
+	//HEADER_CG_UNUSED = 108,
+	HEADER_CG_LOGIN2 = 109,
+	HEADER_CG_DUNGEON = 110,
+	HEADER_CG_LOGIN3 = 111,
+
+	HEADER_CG_GUILD_SYMBOL_UPLOAD = 112,
+	HEADER_CG_GUILD_SYMBOL_CRC = 113,
+
+	// SCRIPT_SELECT_ITEM
+	HEADER_CG_SCRIPT_SELECT_ITEM = 114,
+	// END_OF_SCRIPT_SELECT_ITEM
+
+#if defined(ENABLE_GEM_SYSTEM)
+	HEADER_CG_SELECT_ITEM_EX = 115,
+#endif
+
+	//HEADER_CG_UNUSED = 116,
+	//HEADER_CG_UNUSED = 117,
+	//HEADER_CG_UNUSED = 118,
+	//HEADER_CG_UNUSED = 119,
+#if defined(ENABLE_QUEST_REQUEST_EVENT)
+	HEADER_CG_REQUEST_EVENT_QUEST = 120,
+#endif
+#if defined(ENABLE_LEFT_SEAT)
+	HEADER_CG_LEFT_SEAT = 121,
+#endif
+	//HEADER_CG_UNUSED = 122,
+	//HEADER_CG_UNUSED = 123,
+	//HEADER_CG_UNUSED = 124,
+	//HEADER_CG_UNUSED = 125,
+	//HEADER_CG_UNUSED = 126,
+	//HEADER_CG_UNUSED = 127,
+	//HEADER_CG_UNUSED = 128,
+	//HEADER_CG_UNUSED = 129,
+	//HEADER_CG_UNUSED = 130,
+	//HEADER_CG_UNUSED = 131,
+	//HEADER_CG_UNUSED = 132,
+	//HEADER_CG_UNUSED = 133,
+	//HEADER_CG_UNUSED = 134,
+	//HEADER_CG_UNUSED = 135,
+	//HEADER_CG_UNUSED = 136,
+	//HEADER_CG_UNUSED = 137,
+	//HEADER_CG_UNUSED = 138,
+	//HEADER_CG_UNUSED = 139,
+	//HEADER_CG_UNUSED = 140,
+	//HEADER_CG_UNUSED = 141,
+	//HEADER_CG_UNUSED = 142,
+	//HEADER_CG_UNUSED = 143,
+	//HEADER_CG_UNUSED = 144,
+#if defined(ENABLE_FISHING_GAME)
+	HEADER_CG_FISHING_GAME = 145,
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+	HEADER_CG_REFINE_ELEMENT = 146,
+#endif
+	//HEADER_CG_UNUSED = 147,
+	//HEADER_CG_UNUSED = 148,
+	//HEADER_CG_UNUSED = 149,
+	//HEADER_CG_UNUSED = 150,
+#if defined(ENABLE_SKILLBOOK_COMB_SYSTEM)
+	HEADER_CG_SKILLBOOK_COMB = 151,
+#endif
+	//HEADER_CG_UNUSED = 152,
+	//HEADER_CG_UNUSED = 153,
+	//HEADER_CG_UNUSED = 154,
+	//HEADER_CG_UNUSED = 155,
+	//HEADER_CG_UNUSED = 156,
+	//HEADER_CG_UNUSED = 157,
+	//HEADER_CG_UNUSED = 158,
+	//HEADER_CG_UNUSED = 159,
+	//HEADER_CG_UNUSED = 160,
+	//HEADER_CG_UNUSED = 161,
+	//HEADER_CG_UNUSED = 162,
+	//HEADER_CG_UNUSED = 163,
+	//HEADER_CG_UNUSED = 164,
+	//HEADER_CG_UNUSED = 165,
+	//HEADER_CG_UNUSED = 166,
+	//HEADER_CG_UNUSED = 167,
+	//HEADER_CG_UNUSED = 168,
+#if defined(ENABLE_ATTR_6TH_7TH)
+	HEADER_CG_ATTR67_ADD = 169,
+#endif
+#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
+	HEADER_CG_SNOWFLAKE_STICK_EVENT = 170,
+#endif
+	//HEADER_CG_UNUSED = 171,
+	//HEADER_CG_UNUSED = 172,
+	//HEADER_CG_UNUSED = 173,
+	//HEADER_CG_UNUSED = 174,
+	//HEADER_CG_UNUSED = 175,
+	//HEADER_CG_UNUSED = 176,
+	//HEADER_CG_UNUSED = 177,
+	//HEADER_CG_UNUSED = 178,
+	//HEADER_CG_UNUSED = 179,
+	//HEADER_CG_UNUSED = 180,
+#if defined(ENABLE_MINI_GAME_RUMI)
+	HEADER_CG_MINI_GAME_RUMI = 181,
+#endif
+#if defined(ENABLE_MINI_GAME_YUTNORI)
+	HEADER_CG_MINI_GAME_YUTNORI = 182,
+#endif
+#if defined(ENABLE_GEM_SYSTEM)
+	HEADER_CG_GEM_SHOP = 183,
+#endif
+	//HEADER_CG_UNUSED = 184,
+	//HEADER_CG_UNUSED = 185,
+#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
+	HEADER_CG_MINI_GAME_ROULETTE = 186,
+#endif
+#if defined(ENABLE_FLOWER_EVENT)
+	HEADER_CG_FLOWER_EVENT = 187,
+#endif
+	//HEADER_CG_UNUSED = 188,
+	//HEADER_CG_UNUSED = 189,
+	//HEADER_CG_UNUSED = 190,
+	//HEADER_CG_UNUSED = 191,
+	//HEADER_CG_UNUSED = 192,
+	//HEADER_CG_UNUSED = 193,
+	//HEADER_CG_UNUSED = 194,
+	//HEADER_CG_UNUSED = 195,
+	//HEADER_CG_UNUSED = 196,
+	//HEADER_CG_UNUSED = 197,
+	//HEADER_CG_UNUSED = 198,
+	//HEADER_CG_UNUSED = 199,
+	//HEADER_CG_UNUSED = 200,
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	HEADER_CG_EXT_BATTLE_PASS_ACTION = 201,
+	HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM = 202,
+#endif
+
+	// NOTE : Ì· XXX  Ì° Packet  . Ì· ÚµÏ°  Ñ¾î°¡.
+	// enum   Ï´. Æ´ namepsace  Ï´..
+	//  packet generator Ù¶ Ê´Â´. Ì· XX
+	// Ì·Ù°  Ä¡  Ã¥Âµ???
+	//HEADER_CG_HS_ACK = 203,
+	//HEADER_CG_XTRAP_ACK = 204,
+
+	HEADER_CG_DRAGON_SOUL_REFINE = 205,
+	HEADER_CG_STATE_CHECKER = 206,
+
+	HEADER_CG_PHASE = 207,
+#if defined(ENABLE_LUCKY_BOX)
+	HEADER_CG_LUCKY_BOX = 208,
+#endif
+	//HEADER_CG_UNUSED = 210,
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+	HEADER_CG_ACCE_REFINE = 211,
+#endif
+#if defined(ENABLE_AURA_COSTUME_SYSTEM)
+	HEADER_CG_AURA_REFINE = 212,
+#endif
+	//HEADER_CG_UNUSED = 213,
+	//HEADER_CG_UNUSED = 214,
+#if defined(ENABLE_MAILBOX)
+	HEADER_CG_MAILBOX_WRITE = 215,
+	HEADER_CG_MAILBOX_WRITE_CONFIRM = 216,
+	HEADER_CG_MAILBOX_PROCESS = 217,
+#endif
+#if defined(ENABLE_MOVE_COSTUME_ATTR)
+	HEADER_CG_ITEM_COMBINATION = 218,
+	HEADER_CG_ITEM_COMBINATION_CANCEL = 219,
+#endif
+	//HEADER_CG_UNUSED = 223,
+	//HEADER_CG_UNUSED = 224,
+	//HEADER_CG_UNUSED = 225,
+#if defined(ENABLE_MINI_GAME_CATCH_KING)
+	HEADER_CG_MINI_GAME_CATCH_KING = 226,
+#endif
+#if defined(ENABLE_CHANGED_ATTR)
+	HEADER_CG_ITEM_SELECT_ATTR = 227,
+#endif
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+	HEADER_CG_CHANGE_LOOK = 228,
+#endif
+	//HEADER_CG_UNUSED = 229,
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+	HEADER_CG_CHANGE_LANGUAGE = 230,
+#endif
+	//HEADER_CG_UNUSED = 231,
+	//HEADER_CG_UNUSED = 232,
+	//HEADER_CG_UNUSED = 233,
+	//HEADER_CG_UNUSED = 234,
+#if defined(ENABLE_LOOTING_SYSTEM)
+	HEADER_CG_LOOT_FILTER = 235,
+#endif
+	//HEADER_CG_UNUSED = 236,
+	//HEADER_CG_UNUSED = 237,
+	//HEADER_CG_UNUSED = 238,
+	//HEADER_CG_UNUSED = 239,
+	//HEADER_CG_UNUSED = 240,
+	HEADER_CG_CLIENT_VERSION2 = 0xf1, // 241
+	//HEADER_CG_UNUSED = 242,
+	//HEADER_CG_UNUSED = 243,
+	//HEADER_CG_UNUSED = 244,
+	//HEADER_CG_UNUSED = 245,
+	//HEADER_CG_UNUSED = 246,
+	//HEADER_CG_UNUSED = 247,
+	//HEADER_CG_UNUSED = 248,
+	//HEADER_CG_UNUSED = 249,
+	//HEADER_CG_UNUSED = 250,
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	HEADER_CG_KEY_AGREEMENT = 0xfb, // __IMPROVED_PACKET_ENCRYPTION__ // 251
+#endif
+	HEADER_CG_TIME_SYNC = 0xfc, // 252
+	HEADER_CG_CLIENT_VERSION = 0xfd, // 253
+	HEADER_CG_PONG = 0xfe, // 254
+	HEADER_CG_HANDSHAKE = 0xff, // 255
+};
+
+enum GC_HEADERS
+{
+	HEADER_GC_CHARACTER_ADD = 1,
+	HEADER_GC_CHARACTER_DEL = 2,
+	HEADER_GC_CHARACTER_MOVE = 3,
+	HEADER_GC_CHAT = 4,
+	HEADER_GC_SYNC_POSITION = 5,
+
+	HEADER_GC_LOGIN_SUCCESS3 = 6,
+	HEADER_GC_LOGIN_FAILURE = 7,
+
+	HEADER_GC_PLAYER_CREATE_SUCCESS = 8,
+	HEADER_GC_PLAYER_CREATE_FAILURE = 9,
+	HEADER_GC_PLAYER_DELETE_SUCCESS = 10,
+	HEADER_GC_PLAYER_DELETE_WRONG_SOCIAL_ID = 11,
+
+	//HEADER_GC_UNUSED = 24,
+	HEADER_GC_STUN = 13,
+	HEADER_GC_DEAD = 14,
+
+	HEADER_GC_MAIN_CHARACTER = 113,
+	HEADER_GC_PLAYER_POINTS = 16,
+	HEADER_GC_PLAYER_POINT_CHANGE = 17,
+	HEADER_GC_CHANGE_SPEED = 18,
+	HEADER_GC_CHARACTER_UPDATE = 19,
+
+	HEADER_GC_ITEM_SET_EMPTY = 20, //  Ã¢ ß°
+	HEADER_GC_ITEM_SET = 21, //  Ã¢ ß°
+	HEADER_GC_ITEM_USE = 22, //   ( é¿¡ Ö± )
+	HEADER_GC_ITEM_DROP = 23, //  
+
+	//HEADER_GC_UNUSED = 24,
+	HEADER_GC_ITEM_UPDATE = 25, //  Ä¡ Æ®
+	HEADER_GC_ITEM_GROUND_ADD = 26, // Ù´Ú¿  ß°
+	HEADER_GC_ITEM_GROUND_DEL = 27, // Ù´Ú¿  
+
+	HEADER_GC_QUICKSLOT_ADD = 28,
+	HEADER_GC_QUICKSLOT_DEL = 29,
+	HEADER_GC_QUICKSLOT_SWAP = 30,
+
+	HEADER_GC_ITEM_OWNERSHIP = 31,
+
+	HEADER_GC_LOGIN_SUCCESS4 = 32,
+
+	//HEADER_GC_UNUSED = 33,
+	HEADER_GC_WHISPER = 34,
+	//HEADER_GC_UNUSED = 35,
+
+	HEADER_GC_MOTION = 36,
+	HEADER_GC_EMOTE = 37,
+
+	HEADER_GC_SHOP = 38,
+	HEADER_GC_SHOP_SIGN = 39,
+
+	HEADER_GC_DUEL_START = 40,
+	HEADER_GC_PVP = 41,
+	HEADER_GC_EXCHANGE = 42,
+	HEADER_GC_CHARACTER_POSITION = 43,
+
+	HEADER_GC_PING = 44,
+	HEADER_GC_SCRIPT = 45,
+	HEADER_GC_QUEST_CONFIRM = 46,
+
+#if defined(ENABLE_EXTEND_INVEN_SYSTEM)
+	HEADER_GC_EXTEND_INVEN = 47,
+	HEADER_GC_EXTEND_INVEN_ITEM_USE = 48,
+#endif
+#if defined(ENABLE_GUILD_DRAGONLAIR_SYSTEM)
+	HEADER_GC_GUILD_DRAGONLAIR = 49,
+#endif
+#if defined(ENABLE_CLIENT_TIMER)
+	HEADER_GC_CLIENT_TIMER = 50,
+#endif
+#ifdef ENABLE_OFFLINE_SHOP
+	HEADER_GC_OFFLINE_SHOP = 51,
+#endif
+	//HEADER_GC_UNUSED = 52,
+	//HEADER_GC_UNUSED = 53,
+	//HEADER_GC_UNUSED = 54,
+	//HEADER_GC_UNUSED = 55,
+	//HEADER_GC_UNUSED = 56,
+	//HEADER_GC_UNUSED = 57,
+#if defined(ENABLE_SEND_TARGET_INFO)
+	HEADER_GC_TARGET_INFO = 58,
+#endif
+	//HEADER_GC_UNUSED = 59,
+	//HEADER_GC_UNUSED = 60,
+	HEADER_GC_MOUNT = 61,
+	HEADER_GC_OWNERSHIP = 62,
+	HEADER_GC_TARGET = 63,
+	//HEADER_GC_UNUSED = 64,
+	HEADER_GC_WARP = 65,
+	//HEADER_GC_UNUSED = 66,
+	//HEADER_GC_UNUSED = 67,
+	//HEADER_GC_UNUSED = 68,
+	HEADER_GC_ADD_FLY_TARGETING = 69,
+
+	HEADER_GC_CREATE_FLY = 70,
+	HEADER_GC_FLY_TARGETING = 71,
+	HEADER_GC_SKILL_LEVEL = 76,
+	//HEADER_GC_UNUSED = 73,
+	HEADER_GC_MESSENGER = 74,
+	HEADER_GC_GUILD = 75,
+	HEADER_GC_SKILL_LEVEL_NEW = 76,
+
+	HEADER_GC_PARTY_INVITE = 77,
+	HEADER_GC_PARTY_ADD = 78,
+	HEADER_GC_PARTY_UPDATE = 79,
+	HEADER_GC_PARTY_REMOVE = 80,
+
+	HEADER_GC_QUEST_INFO = 81,
+	HEADER_GC_REQUEST_MAKE_GUILD = 82,
+	HEADER_GC_PARTY_PARAMETER = 83,
+	//HEADER_GC_UNUSED = 84,
+
+	HEADER_GC_SAFEBOX_MONEY_CHANGE = 84,
+	HEADER_GC_SAFEBOX_SET = 85,
+	HEADER_GC_SAFEBOX_DEL = 86,
+	HEADER_GC_SAFEBOX_WRONG_PASSWORD = 87,
+	HEADER_GC_SAFEBOX_SIZE = 88,
+
+	HEADER_GC_FISHING = 89,
+
+	HEADER_GC_EMPIRE = 90,
+
+	HEADER_GC_PARTY_LINK = 91,
+	HEADER_GC_PARTY_UNLINK = 92,
+	//HEADER_GC_UNUSED = 93,
+	//HEADER_GC_UNUSED = 94,
+	HEADER_GC_REFINE_INFORMATION = 119,
+	//HEADER_GC_UNUSED = 96,
+#if defined(ENABLE_CUBE_RENEWAL)
+	HEADER_GC_CUBE = 97,
+#endif
+	//HEADER_GC_UNUSED = 98,
+	HEADER_GC_VIEW_EQUIP = 99,
+
+	HEADER_GC_MARK_BLOCK = 100,
+	//HEADER_GC_MARK_DIFF_DATA = 101,
+	HEADER_GC_MARK_IDXLIST = 102,
+	//HEADER_GC_UNUSED = 103,
+	//HEADER_GC_UNUSED = 104,
+	//HEADER_GC_SLOW_TIMER = 105,
+	HEADER_GC_TIME = 106,
+	HEADER_GC_CHANGE_NAME = 107,
+	//HEADER_GC_UNUSED = 108,
+	//HEADER_GC_UNUSED = 109,
+
+	HEADER_GC_DUNGEON = 110,
+
+	HEADER_GC_WALK_MODE = 111,
+	HEADER_GC_CHANGE_SKILL_GROUP = 112,
+	HEADER_GC_MAIN_CHARACTER2_EMPIRE = 113,
+
+	HEADER_GC_SEPCIAL_EFFECT = 114,
+	HEADER_GC_NPC_POSITION = 115,
+
+	//HEADER_CG_UNUSED = 116,
+	//HEADER_GC_UNUSED = 117,
+	HEADER_GC_LOGIN_KEY = 118,
+
+	HEADER_GC_REFINE_INFORMATION_NEW = 119,
+	//HEADER_GC_UNUSED = 120,
+	HEADER_GC_CHANNEL = 121,
+
+	HEADER_GC_MALL_OPEN = 122,
+
+	HEADER_GC_TARGET_UPDATE = 123,
+	HEADER_GC_TARGET_DELETE = 124,
+	HEADER_GC_TARGET_CREATE_NEW = 125,
+
+	HEADER_GC_AFFECT_ADD = 126,
+	HEADER_GC_AFFECT_REMOVE = 127,
+
+	HEADER_GC_MALL_SET = 128,
+	HEADER_GC_MALL_DEL = 129,
+
+	HEADER_GC_LAND_LIST = 130,
+	HEADER_GC_LOVER_INFO = 131,
+	HEADER_GC_LOVE_POINT_UPDATE = 132,
+
+	HEADER_GC_GUILD_SYMBOL_DATA = 133,
+
+	// MINING
+	HEADER_GC_DIG_MOTION = 134,
+	// END_OF_MINING
+
+	HEADER_GC_DAMAGE_INFO = 135,
+	HEADER_GC_CHAR_ADDITIONAL_INFO = 136,
+
+	// SUPPORT_BGM
+	HEADER_GC_MAIN_CHARACTER3_BGM = 137,
+	HEADER_GC_MAIN_CHARACTER4_BGM_VOL = 138,
+	// END_OF_SUPPORT_BGM
+
+	//HEADER_GC_UNUSED = 140,
+	//HEADER_GC_UNUSED = 141,
+	//HEADER_GC_UNUSED = 142,
+	//HEADER_GC_UNUSED = 143,
+	//HEADER_GC_UNUSED = 144,
+#if defined(ENABLE_FISHING_GAME)
+	HEADER_GC_FISHING_GAME = 145,
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+	HEADER_GC_REFINE_ELEMENT = 146,
+#endif
+	//HEADER_GC_UNUSED = 147,
+	//HEADER_GC_UNUSED = 148,
+	//HEADER_GC_UNUSED = 149,
+
+	HEADER_GC_AUTH_SUCCESS = 150,
+	HEADER_GC_PANAMA_PACK = 151,
+
+	// HYBRID CRYPT
+	HEADER_GC_HYBRIDCRYPT_KEYS = 152,
+	HEADER_GC_HYBRIDCRYPT_SDB = 153, // SDB means Supplmentary Data Blocks
+	// HYBRID CRYPT
+
+	//HEADER_GC_UNUSED = 154,
+	//HEADER_GC_UNUSED = 155,
+	//HEADER_GC_UNUSED = 158,
+	//HEADER_GC_UNUSED = 159,
+	//HEADER_GC_UNUSED = 160,
+	//HEADER_GC_UNUSED = 161,
+	//HEADER_GC_UNUSED = 162,
+	//HEADER_GC_UNUSED = 163,
+#ifdef ENABLE_SHOP_SEARCH
+	HEADER_GC_SHOP_SEARCH_RESULT = 164,
+	HEADER_GC_SHOP_SEARCH_BUY_RESULT = 165,
+	HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE = 166,
+	HEADER_GC_SHOP_SEARCH_SOLD_INFO = 167,
+#endif
+	//HEADER_GC_UNUSED = 168,
+	//HEADER_GC_UNUSED = 169,
+#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
+	HEADER_GC_SNOWFLAKE_STICK_EVENT = 170,
+#endif
+	//HEADER_GC_UNUSED = 171,
+	//HEADER_GC_UNUSED = 172,
+	//HEADER_GC_UNUSED = 173,
+	//HEADER_GC_UNUSED = 174,
+	//HEADER_GC_UNUSED = 175,
+	//HEADER_GC_UNUSED = 176,
+	//HEADER_GC_UNUSED = 177,
+	//HEADER_GC_UNUSED = 178,
+	//HEADER_GC_UNUSED = 179,
+	//HEADER_GC_UNUSED = 180,
+#if defined(ENABLE_MINI_GAME_RUMI)
+	HEADER_GC_MINI_GAME_RUMI = 181,
+#endif
+#if defined(ENABLE_MINI_GAME_YUTNORI)
+	HEADER_GC_MINI_GAME_YUTNORI = 182,
+#endif
+	//HEADER_GC_UNUSED = 183,
+	//HEADER_GC_UNUSED = 184,
+	//HEADER_GC_UNUSED = 185,
+#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
+	HEADER_GC_MINI_GAME_ROULETTE = 186,
+#endif
+#if defined(ENABLE_FLOWER_EVENT)
+	HEADER_GC_FLOWER_EVENT = 187,
+#endif
+
+#ifdef ENABLE_GROWTH_PET_SYSTEM
+	HEADER_GC_PET = 188,
+	HEADER_GC_PET_SET = 189,
+	HEADER_GC_PET_SET_EXCHANGE = 190,
+	HEADER_GC_PET_DEL = 191,
+	HEADER_GC_PET_SUMMON = 192,
+	HEADER_GC_PET_POINT_CHANGE = 193,
+	HEADER_GC_PET_NAME_CHANGE_RESULT = 194,
+	HEADER_GC_PET_DETERMINE_RESULT = 195,
+	HEADER_GC_PET_ATTR_CHANGE_RESULT = 196,
+	HEADER_GC_PET_SKILL_UPDATE = 197,
+	HEADER_GC_PET_SKILL_COOLTIME = 198,
+#endif
+
+	//HEADER_GC_UNUSED = 199,
+	//HEADER_GC_UNUSED = 200,
+
+#if defined(ENABLE_GEM_SYSTEM)
+	HEADER_GC_GEM_SHOP = 201,
+	HEADER_GC_GEM_SHOP_PROCESS = 202,
+#endif
+	//HEADER_GC_UNUSED = 203,
+	//HEADER_GC_UNUSED = 204,
+	//HEADER_GC_UNUSED = 205,
+	//HEADER_GC_UNUSED = 206,
+	//HEADER_GC_UNUSED = 207,
+
+	HEADER_GC_SPECIFIC_EFFECT = 208,
+
+#if defined(ENABLE_DRAGON_SOUL_SYSTEM)
+	HEADER_GC_DRAGON_SOUL_REFINE = 209,
+#endif
+	HEADER_GC_RESPOND_CHANNELSTATUS = 210,
+
+	//HEADER_GC_UNUSED = 212,
+	//HEADER_GC_UNUSED = 213,
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+	HEADER_GC_ACCE_REFINE = 214,
+#endif
+#if defined(ENABLE_AURA_COSTUME_SYSTEM)
+	HEADER_GC_AURA_REFINE = 215,
+#endif
+	//HEADER_GC_UNUSED = 216,
+#if defined(ENABLE_LUCKY_BOX)
+	HEADER_GC_LUCKY_BOX = 217,
+#endif
+	//HEADER_GC_UNUSED = 218,
+	//HEADER_GC_UNUSED = 219,
+	//HEADER_GC_UNUSED = 220,
+#if defined(ENABLE_MAILBOX)
+	HEADER_GC_MAILBOX_PROCESS = 221,
+	HEADER_GC_MAILBOX = 222,
+	HEADER_GC_MAILBOX_ADD_DATA = 223,
+	HEADER_GC_MAILBOX_ALL = 224,
+	HEADER_GC_MAILBOX_UNREAD = 225,
+#endif
+	//HEADER_GC_UNUSED = 226,
+#if defined(ENABLE_CHANGED_ATTR)
+	HEADER_GC_ITEM_SELECT_ATTR = 227,
+#endif
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+	HEADER_GC_CHANGE_LOOK_SET = 228,
+	HEADER_GC_CHANGE_LOOK_DEL = 229,
+	HEADER_GC_CHANGE_LOOK_FREE_SET = 230,
+	HEADER_GC_CHANGE_LOOK_FREE_DEL = 231,
+#endif
+	//HEADER_GC_UNUSED = 232,
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	HEADER_GC_EXT_BATTLE_PASS_OPEN = 233,
+	HEADER_GC_EXT_BATTLE_PASS_GENERAL_INFO = 234,
+	HEADER_GC_EXT_BATTLE_PASS_MISSION_INFO = 235,
+	HEADER_GC_EXT_BATTLE_PASS_MISSION_UPDATE = 236,
+	HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING = 237,
+#endif
+
+#if defined(ENABLE_MINI_GAME_CATCH_KING)
+	HEADER_GC_MINI_GAME_CATCH_KING = 238,
+#endif
+	//HEADER_GC_UNUSED = 239,
+#if defined(ENABLE_RANKING_SYSTEM)
+	HEADER_GC_RANKING = 240,
+#endif
+	//HEADER_GC_UNUSED = 241,
+	//HEADER_GC_UNUSED = 242,
+	//HEADER_GC_UNUSED = 243,
+	//HEADER_GC_UNUSED = 244,
+#if defined(ENABLE_LOOTING_SYSTEM)
+	HEADER_GC_LOOT_FILTER = 245,
+#endif
+	//HEADER_GC_UNUSED = 246,
+	//HEADER_GC_UNUSED = 247,
+	//HEADER_GC_UNUSED = 248,
+	//HEADER_GC_UNUSED = 249,
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	HEADER_GC_KEY_AGREEMENT_COMPLETED = 0xfa, // __IMPROVED_PACKET_ENCRYPTION__ // 250
+	HEADER_GC_KEY_AGREEMENT = 0xfb, // __IMPROVED_PACKET_ENCRYPTION__ // 251
+#endif
+	HEADER_GC_HANDSHAKE_OK = 0xfc, // 252
+	HEADER_GC_PHASE = 0xfd, // 253
+	HEADER_GC_BINDUDP = 0xfe, // 254
+	HEADER_GC_HANDSHAKE = 0xff, // 255
+};
+
+enum
+{
+	ID_MAX_NUM = 30,
+	PASS_MAX_NUM = 16,
+	CHAT_MAX_NUM = 128,
+	PATH_NODE_MAX_NUM = 64,
+	SHOP_SIGN_MAX_LEN = 32,
+
+	PLAYER_PER_ACCOUNT3 = 3,
+#ifndef ENABLE_PLAYER_PER_ACCOUNT5
+	PLAYER_PER_ACCOUNT4 = 4,
+#else
+	PLAYER_PER_ACCOUNT4 = 5,
+	PLAYER_PER_ACCOUNT5 = 5,
+#endif
+
+	PLAYER_ITEM_SLOT_MAX_NUM = 20, // Ã·Ì¾ Ô´ î°¡ .
+
+	QUICKSLOT_MAX_LINE = 4,
+	QUICKSLOT_MAX_COUNT_PER_LINE = 8, // Å¬Ì¾Æ®  
+	QUICKSLOT_MAX_COUNT = QUICKSLOT_MAX_LINE * QUICKSLOT_MAX_COUNT_PER_LINE,
+
+	QUICKSLOT_MAX_NUM = 36, //   Ö´ 
+
+#if defined(ENABLE_MYSHOP_EXPANSION)
+	SHOP_HOST_ITEM_MAX = 80,
+#endif
+	SHOP_HOST_ITEM_MAX_NUM = 40,
+
+	METIN_SOCKET_COUNT = 6,
+
+	PARTY_AFFECT_SLOT_MAX_NUM = 7,
+
+	GUILD_GRADE_NAME_MAX_LEN = 8,
+	GUILD_NAME_MAX_LEN = 12,
+	GUILD_GRADE_COUNT = 15,
+	GULID_COMMENT_MAX_LEN = 50,
+
+	MARK_CRC_NUM = 8 * 8,
+	MARK_DATA_SIZE = 16 * 12,
+	SYMBOL_DATA_SIZE = 128 * 256,
+	QUEST_INPUT_STRING_MAX_NUM = 64,
+#if defined(ENABLE_OX_RENEWAL)
+	QUEST_INPUT_LONG_STRING_MAX_NUM = 128,
+#endif
+
+	PRIVATE_CODE_LENGTH = 8,
+
+	REFINE_MATERIAL_MAX_NUM = 5,
+
+	//CHINA_MATRIX_ANSWER_MAX_LEN = 8,
+
+	//RUNUP_MATRIX_QUIZ_MAX_LEN = 8,
+	//RUNUP_MATRIX_ANSWER_MAX_LEN = 4,
+	//NEWCIBN_PASSPOD_ANSWER_MAX_LEN = 8,
+	//NEWCIBN_PASSPOD_FAILURE_MAX_LEN = 128,
+
+	WEAR_MAX_NUM = 32,
+
+	SHOP_TAB_NAME_MAX = 32,
+#if defined(ENABLE_SHOPEX_TAB4)
+	SHOP_TAB_COUNT_MAX = 4,
+#else
+	SHOP_TAB_COUNT_MAX = 3,
+#endif
+};
+
+#pragma pack(push)
+#pragma pack(1)
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+// Mark
+typedef struct command_mark_login
+{
+	BYTE header;
+	DWORD handle;
+	DWORD random_key;
+} TPacketCGMarkLogin;
+
+typedef struct command_mark_upload
+{
+	BYTE header;
+	DWORD gid;
+	BYTE image[16 * 12 * 4];
+} TPacketCGMarkUpload;
+
+typedef struct command_mark_idxlist
+{
+	BYTE header;
+} TPacketCGMarkIDXList;
+
+typedef struct command_mark_crclist
+{
+	BYTE header;
+	BYTE imgIdx;
+	DWORD crclist[80];
+} TPacketCGMarkCRCList;
+
+typedef struct packet_mark_idxlist
+{
+	BYTE header;
+	DWORD bufSize;
+	WORD count;
+	//Ú¿ size * (WORD + WORD)Å­  
+} TPacketGCMarkIDXList;
+
+typedef struct packet_mark_block
+{
+	BYTE header;
+	DWORD bufSize;
+	BYTE imgIdx;
+	DWORD count;
+	// Ú¿ 64 x 48 x È¼Å©(4Æ®) = 12288Å­  
+} TPacketGCMarkBlock;
+
+typedef struct command_symbol_upload
+{
+	BYTE header;
+	WORD size;
+	DWORD handle;
+} TPacketCGSymbolUpload;
+
+typedef struct command_symbol_crc
+{
+	BYTE header;
+	DWORD dwGuildID;
+	DWORD dwCRC;
+	DWORD dwSize;
+} TPacketCGSymbolCRC;
+
+typedef struct packet_symbol_data
+{
+	BYTE header;
+	WORD size;
+	DWORD guild_id;
+} TPacketGCGuildSymbolData;
+
+// Packet layout safety (must match server-side expectations exactly)
+static_assert(sizeof(TPacketCGMarkLogin)   == 1 + 4 + 4, "TPacketCGMarkLogin size mismatch");
+static_assert(sizeof(TPacketCGMarkUpload)  == 1 + 4 + (16 * 12 * 4), "TPacketCGMarkUpload size mismatch");
+static_assert(sizeof(TPacketCGSymbolUpload)== 1 + 2 + 4, "TPacketCGSymbolUpload size mismatch");
+static_assert(sizeof(TPacketGCGuildSymbolData) == 1 + 2 + 4, "TPacketGCGuildSymbolData size mismatch");
+static_assert(sizeof(TChannelStatus) == 2 + 1, "TChannelStatus size mismatch");
+
+//
+//
+//
+
+typedef struct packet_observer_add
+{
+	BYTE header;
+	DWORD vid;
+	WORD x;
+	WORD y;
+} TPacketGCObserverAdd;
+
+typedef struct packet_observer_move
+{
+	BYTE header;
+	DWORD vid;
+	WORD x;
+	WORD y;
+} TPacketGCObserverMove;
+
+typedef struct packet_observer_remove
+{
+	BYTE header;
+	DWORD vid;
+} TPacketGCObserverRemove;
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+// To Server
+
+typedef struct command_checkin
+{
+	BYTE header;
+	char name[ID_MAX_NUM + 1];
+	char pwd[PASS_MAX_NUM + 1];
+} TPacketCGCheckin;
+
+typedef struct command_login
+{
+	BYTE header;
+	char name[ID_MAX_NUM + 1];
+	char pwd[PASS_MAX_NUM + 1];
+} TPacketCGLogin;
+
+// start -     Å¶
+typedef struct command_login2
+{
+	BYTE header;
+	char name[ID_MAX_NUM + 1];
+	DWORD login_key;
+	DWORD adwClientKey[4];
+} TPacketCGLogin2;
+
+typedef struct command_login3
+{
+	BYTE header;
+	char name[ID_MAX_NUM + 1];
+	char pwd[PASS_MAX_NUM + 1];
+	DWORD adwClientKey[4];
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+	char country[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketCGLogin3;
+// end -     Å¶
+
+typedef struct command_direct_enter
+{
+	BYTE bHeader;
+	char login[ID_MAX_NUM + 1];
+	char passwd[PASS_MAX_NUM + 1];
+	BYTE index;
+} TPacketCGDirectEnter;
+
+typedef struct command_player_select
+{
+	BYTE header;
+	BYTE index;
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+	char country[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketCGSelectCharacter;
+
+typedef struct command_attack
+{
+	BYTE header;
+	BYTE bType; //  
+	DWORD dwVictimVID; //  VID
+	BYTE bCRCMagicCubeProcPiece;
+	BYTE bCRCMagicCubeFilePiece;
+} TPacketCGAttack;
+
+typedef struct command_chat
+{
+	BYTE header;
+	WORD length;
+	BYTE type;
+} TPacketCGChat;
+
+typedef struct command_whisper
+{
+	BYTE bHeader;
+	WORD wSize;
+	char szNameTo[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketCGWhisper;
+
+enum EBattleMode
+{
+	BATTLEMODE_ATTACK = 0,
+	BATTLEMODE_DEFENSE = 1,
+};
+
+typedef struct command_EnterFrontGame
+{
+	BYTE header;
+} TPacketCGEnterFrontGame;
+
+typedef struct command_item_use
+{
+	BYTE header;
+	TItemPos pos;
+} TPacketCGItemUse;
+
+typedef struct command_item_use_to_item
+{
+	BYTE header;
+	TItemPos source_pos;
+	TItemPos target_pos;
+} TPacketCGItemUseToItem;
+
+typedef struct command_item_drop
+{
+	BYTE header;
+	TItemPos pos;
+	DWORD elk;
+#if defined(ENABLE_CHEQUE_SYSTEM)
+	DWORD cheque;
+#endif
+} TPacketCGItemDrop;
+
+typedef struct command_item_drop2
+{
+	BYTE header;
+	TItemPos pos;
+	DWORD gold;
+#if defined(ENABLE_CHEQUE_SYSTEM)
+	DWORD cheque;
+#endif
+	WORD count;
+} TPacketCGItemDrop2;
+
+#if defined(ENABLE_NEW_DROP_DIALOG)
+typedef struct command_item_destroy
+{
+	BYTE header;
+	TItemPos pos;
+} TPacketCGItemDestroy;
+#endif
+
+typedef struct command_item_move
+{
+	BYTE header;
+	TItemPos pos;
+	TItemPos change_pos;
+	WORD num;
+} TPacketCGItemMove;
+
+typedef struct command_item_pickup
+{
+	BYTE header;
+	DWORD vid;
+} TPacketCGItemPickUp;
+
+typedef struct command_quickslot_add
+{
+	BYTE header;
+	BYTE pos;
+	TQuickSlot slot;
+}TPacketCGQuickSlotAdd;
+
+typedef struct command_quickslot_del
+{
+	BYTE header;
+	BYTE pos;
+}TPacketCGQuickSlotDel;
+
+typedef struct command_quickslot_swap
+{
+	BYTE header;
+	BYTE pos;
+	BYTE change_pos;
+}TPacketCGQuickSlotSwap;
+
+typedef struct command_on_click
+{
+	BYTE header;
+	DWORD vid;
+} TPacketCGOnClick;
+
+enum
+{
+	SHOP_SUBHEADER_CG_END,
+	SHOP_SUBHEADER_CG_BUY,
+	SHOP_SUBHEADER_CG_SELL,
+	SHOP_SUBHEADER_CG_SELL2,
+};
+
+typedef struct command_shop
+{
+	BYTE header;
+	WORD subheader;
+} TPacketCGShop;
+
+typedef struct command_shop_sell
+{
+	WORD wPos;
+	WORD wCount;
+	BYTE bType;
+} TPacketCGShopSell;
+
+enum
+{
+	EXCHANGE_SUBHEADER_CG_START, // arg1 == vid of target character
+	EXCHANGE_SUBHEADER_CG_ITEM_ADD, // arg1 == position of item
+	EXCHANGE_SUBHEADER_CG_ITEM_DEL, // arg1 == position of item
+	EXCHANGE_SUBHEADER_CG_ELK_ADD, // arg1 == amount of elk
+#if defined(ENABLE_CHEQUE_SYSTEM)
+	EXCHANGE_SUBHEADER_CG_CHEQUE_ADD, // arg1 == amount of cheque
+#endif
+	EXCHANGE_SUBHEADER_CG_ACCEPT, // arg1 == not used
+	EXCHANGE_SUBHEADER_CG_CANCEL, // arg1 == not used
+};
+
+typedef struct command_exchange
+{
+	BYTE header;
+	BYTE subheader;
+	DWORD arg1;
+	BYTE arg2;
+	TItemPos Pos;
+} TPacketCGExchange;
+
+typedef struct command_position
+{
+	BYTE header;
+	BYTE position;
+} TPacketCGPosition;
+
+typedef struct command_script_answer
+{
+	BYTE header;
+	BYTE answer;
+} TPacketCGScriptAnswer;
+
+typedef struct command_script_button
+{
+	BYTE header;
+	unsigned int idx;
+} TPacketCGScriptButton;
+
+typedef struct command_target
+{
+	BYTE header;
+	DWORD dwVID;
+} TPacketCGTarget;
+
+typedef struct command_move
+{
+	BYTE bHeader;
+	BYTE bFunc;
+	BYTE bArg;
+	BYTE bRot;
+	LONG lX;
+	LONG lY;
+	DWORD dwTime;
+} TPacketCGMove;
+
+typedef struct command_sync_position_element
+{
+	DWORD dwVID;
+	long lX;
+	long lY;
+} TPacketCGSyncPositionElement;
+
+typedef struct command_sync_position
+{
+	BYTE bHeader;
+	WORD wSize;
+} TPacketCGSyncPosition;
+
+typedef struct command_fly_targeting
+{
+	BYTE bHeader;
+	DWORD dwTargetVID;
+	long lX;
+	long lY;
+} TPacketCGFlyTargeting;
+
+typedef struct packet_fly_targeting
+{
+	BYTE bHeader;
+	DWORD dwShooterVID;
+	DWORD dwTargetVID;
+	long lX;
+	long lY;
+} TPacketGCFlyTargeting;
+
+typedef struct packet_shoot
+{
+	BYTE bHeader;
+	BYTE bType;
+} TPacketCGShoot;
+
+typedef struct command_warp
+{
+	BYTE bHeader;
+} TPacketCGWarp;
+
+enum
+{
+	SAFEBOX_MONEY_STATE_SAVE,
+	SAFEBOX_MONEY_STATE_WITHDRAW,
+};
+
+typedef struct command_safebox_money
+{
+	BYTE bHeader;
+	BYTE bState;
+	DWORD dwMoney;
+} TPacketCGSafeboxMoney;
+
+typedef struct command_safebox_checkout
+{
+	BYTE bHeader;
+	BYTE bSafePos;
+	TItemPos ItemPos;
+} TPacketCGSafeboxCheckout;
+
+typedef struct command_safebox_checkin
+{
+	BYTE bHeader;
+	BYTE bSafePos;
+	TItemPos ItemPos;
+} TPacketCGSafeboxCheckin;
+
+typedef struct command_mall_checkout
+{
+	BYTE bHeader;
+	BYTE bMallPos;
+	TItemPos ItemPos;
+} TPacketCGMallCheckout;
+
+///////////////////////////////////////////////////////////////////////////////////
+// Messenger
+
+enum EMessengerConnectedState
+{
+	MESSENGER_CONNECTED_STATE_OFFLINE,
+	MESSENGER_CONNECTED_STATE_ONLINE
+};
+
+enum EGCMessengerSubHeader
+{
+	MESSENGER_SUBHEADER_GC_LIST,
+	MESSENGER_SUBHEADER_GC_LOGIN,
+	MESSENGER_SUBHEADER_GC_LOGOUT,
+	MESSENGER_SUBHEADER_GC_INVITE,
+#if defined(ENABLE_MESSENGER_BLOCK)
+	MESSENGER_SUBHEADER_GC_BLOCK_LIST,
+	MESSENGER_SUBHEADER_GC_BLOCK_LOGIN,
+	MESSENGER_SUBHEADER_GC_BLOCK_LOGOUT,
+#endif
+#if defined(ENABLE_MESSENGER_GM)
+	MESSENGER_SUBHEADER_GC_GM_LIST,
+	MESSENGER_SUBHEADER_GC_GM_LOGIN,
+	MESSENGER_SUBHEADER_GC_GM_LOGOUT,
+#endif
+};
+
+typedef struct packet_messenger
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMessenger;
+
+typedef struct packet_messenger_list
+{
+	BYTE bConnected;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+#if defined(ENABLE_MESSENGER_DETAILS)
+	DWORD dwLastPlayTime;
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+#endif
+} TPacketGCMessengerList;
+
+enum ECGMessengerSubHeader
+{
+	MESSENGER_SUBHEADER_CG_ADD_BY_VID,
+	MESSENGER_SUBHEADER_CG_ADD_BY_NAME,
+	MESSENGER_SUBHEADER_CG_REMOVE,
+#if defined(ENABLE_MESSENGER_BLOCK)
+	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID,
+	MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME,
+	MESSENGER_SUBHEADER_CG_BLOCK_REMOVE,
+#endif
+};
+
+typedef struct command_messenger
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+} TPacketCGMessenger;
+
+///////////////////////////////////////////////////////////////////////////////////
+// Party
+
+typedef struct command_use_skill
+{
+	BYTE bHeader;
+	DWORD dwVnum;
+	DWORD dwTargetVID;
+} TPacketCGUseSkill;
+
+typedef struct command_party_invite
+{
+	BYTE header;
+	DWORD vid;
+} TPacketCGPartyInvite;
+
+typedef struct command_party_invite_answer
+{
+	BYTE header;
+	DWORD leader_pid;
+	BYTE accept;
+} TPacketCGPartyInviteAnswer;
+
+typedef struct command_party_remove
+{
+	BYTE header;
+	DWORD pid;
+} TPacketCGPartyRemove;
+
+typedef struct command_party_set_state
+{
+	BYTE byHeader;
+	DWORD dwVID;
+	BYTE byState;
+	BYTE byFlag;
+} TPacketCGPartySetState;
+
+typedef struct packet_party_link
+{
+	BYTE header;
+	DWORD pid;
+	DWORD vid;
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+	long mapIdx;
+#endif
+#if defined(ENABLE_PARTY_CHANNEL_FIX)
+	BYTE channel;
+#endif
+} TPacketGCPartyLink;
+
+typedef struct command_party_use_skill
+{
+	BYTE byHeader;
+	BYTE bySkillIndex;
+	DWORD dwTargetVID;
+} TPacketCGPartyUseSkill;
+
+enum
+{
+	GUILD_SUBHEADER_CG_ADD_MEMBER,
+	GUILD_SUBHEADER_CG_REMOVE_MEMBER,
+	GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME,
+	GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY,
+	GUILD_SUBHEADER_CG_OFFER,
+	GUILD_SUBHEADER_CG_POST_COMMENT,
+	GUILD_SUBHEADER_CG_DELETE_COMMENT,
+	GUILD_SUBHEADER_CG_REFRESH_COMMENT,
+	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE,
+	GUILD_SUBHEADER_CG_USE_SKILL,
+	GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL,
+	GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER,
+	GUILD_SUBHEADER_CG_CHARGE_GSP,
+	GUILD_SUBHEADER_CG_DEPOSIT_MONEY,
+	GUILD_SUBHEADER_CG_WITHDRAW_MONEY,
+};
+
+typedef struct command_guild
+{
+	BYTE byHeader;
+	BYTE bySubHeader;
+} TPacketCGGuild;
+
+typedef struct command_guild_answer_make_guild
+{
+	BYTE header;
+	char guild_name[GUILD_NAME_MAX_LEN + 1];
+} TPacketCGAnswerMakeGuild;
+
+typedef struct command_give_item
+{
+	BYTE byHeader;
+	DWORD dwTargetVID;
+	TItemPos ItemPos;
+	WORD byItemCount;
+} TPacketCGGiveItem;
+
+typedef struct SPacketCGHack
+{
+	BYTE bHeader;
+	char szBuf[255 + 1];
+} TPacketCGHack;
+
+typedef struct command_dungeon
+{
+	BYTE bHeader;
+	WORD size;
+} TPacketCGDungeon;
+
+// Private Shop
+typedef struct SShopItemTable
+{
+	DWORD vnum;
+	DWORD count;
+
+	TItemPos pos; // PC  Ì¿
+	DWORD price; // PC  Ì¿
+#if defined(ENABLE_CHEQUE_SYSTEM)
+	DWORD cheque;
+#endif
+	BYTE display_pos; // PC  Ì¿,  Ä¡.
+#if defined(ENABLE_SHOPEX_RENEWAL)
+	BYTE bPriceType;
+	DWORD dwPriceVnum;
+	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
+#endif
+} TShopItemTable;
+
+typedef struct SPacketCGMyShop
+{
+	BYTE bHeader;
+	char szSign[SHOP_SIGN_MAX_LEN + 1];
+	BYTE bCount; // count of TShopItemTable, max 39
+} TPacketCGMyShop;
+
+#if defined(ENABLE_MYSHOP_DECO)
+typedef struct SPacketGCMyPrivShopOpen
+{
+	BYTE bHeader;
+	bool bCashItem;
+	BYTE bTabCount;
+} TPacketGCMyPrivShopOpen;
+
+typedef struct STPacketCGMyShopDec
+{
+	BYTE bHeader;
+	BYTE bState;
+} TPacketCGMyShopDeco;
+
+typedef struct SPacketCGMyShopDecoAdd
+{
+	BYTE bHeader;
+	BYTE bType;
+	DWORD dwPolyVnum;
+} TPacketCGMyShopDecoAdd;
+#endif
+
+typedef struct SPacketCGRefine
+{
+	BYTE header;
+	BYTE pos;
+	BYTE type;
+} TPacketCGRefine;
+
+typedef struct SPacketCGChangeName
+{
+	BYTE header;
+	BYTE index;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketCGChangeName;
+
+typedef struct command_client_version
+{
+	BYTE header;
+	char filename[32 + 1];
+	char timestamp[32 + 1];
+} TPacketCGClientVersion;
+
+typedef struct command_client_version2
+{
+	BYTE header;
+	char filename[32 + 1];
+	char timestamp[32 + 1];
+} TPacketCGClientVersion2;
+
+typedef struct command_crc_report
+{
+	BYTE header;
+	BYTE byPackMode;
+	DWORD dwBinaryCRC32;
+	DWORD dwProcessCRC32;
+	DWORD dwRootPackCRC32;
+} TPacketCGCRCReport;
+
+enum EPartyExpDistributionType
+{
+	PARTY_EXP_DISTRIBUTION_NON_PARITY,
+	PARTY_EXP_DISTRIBUTION_PARITY,
+};
+
+typedef struct command_party_parameter
+{
+	BYTE bHeader;
+	BYTE bDistributeMode;
+} TPacketCGPartyParameter;
+
+typedef struct command_quest_input_string
+{
+	BYTE bHeader;
+	char szString[QUEST_INPUT_STRING_MAX_NUM + 1];
+} TPacketCGQuestInputString;
+
+#if defined(ENABLE_OX_RENEWAL)
+typedef struct command_quest_input_long_string
+{
+	BYTE bHeader;
+	char szString[QUEST_INPUT_LONG_STRING_MAX_NUM + 1];
+} TPacketCGQuestInputLongString;
+#endif
+
+typedef struct command_quest_confirm
+{
+	BYTE header;
+	BYTE answer;
+	DWORD requestPID;
+} TPacketCGQuestConfirm;
+
+typedef struct command_script_select_item
+{
+	BYTE header;
+	DWORD selection;
+} TPacketCGScriptSelectItem;
+
+#if defined(ENABLE_GEM_SYSTEM)
+typedef struct command_select_item_ex
+{
+	BYTE bHeader;
+	DWORD dwItemPos;
+	BYTE bType;
+	command_select_item_ex(const DWORD c_dwItemPos, const BYTE c_bType = 0) :
+		bHeader(HEADER_CG_SELECT_ITEM_EX),
+		dwItemPos(c_dwItemPos),
+		bType(c_bType)
+	{}
+} TPacketCGSelectItemEx;
+#endif
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+// From Server
+enum EPhase
+{
+	PHASE_CLOSE, //   (Ç´   )
+	PHASE_HANDSHAKE, // Ç¼..;;
+	PHASE_LOGIN, // Î± 
+	PHASE_SELECT, // Ä³  È­
+	PHASE_LOADING, //   Îµ È­
+	PHASE_GAME, //  È­
+	PHASE_DEAD, // ×¾ .. ( È¿ Ö´  ..)
+
+	PHASE_DBCLIENT_CONNECTING, // 
+	PHASE_DBCLIENT, // 
+	PHASE_P2P, // 
+	PHASE_AUTH, // Î±  
+};
+
+typedef struct packet_phase
+{
+	BYTE header;
+	BYTE phase;
+} TPacketGCPhase;
+
+typedef struct packet_blank // Å¶.
+{
+	BYTE header;
+} TPacketGCBlank;
+
+typedef struct packet_blank_dynamic
+{
+	BYTE header;
+	WORD size;
+} TPacketGCBlankDynamic;
+
+typedef struct packet_header_handshake
+{
+	BYTE header;
+	DWORD dwHandshake;
+	DWORD dwTime;
+	LONG lDelta;
+} TPacketGCHandshake;
+
+typedef struct packet_header_bindudp
+{
+	BYTE header;
+	DWORD addr;
+	WORD port;
+} TPacketGCBindUDP;
+
+typedef struct packet_header_dynamic_size
+{
+	BYTE header;
+	WORD size;
+} TDynamicSizePacketHeader;
+
+typedef struct SSimplePlayerInformation
+{
+	DWORD dwID;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	BYTE byJob;
+	BYTE byLevel;
+	DWORD dwPlayMinutes;
+	BYTE byST, byHT, byDX, byIQ;
+	//DWORD adwParts[CRaceData::PART_MAX_NUM];
+	DWORD dwMainPart;
+	BYTE bChangeName;
+	DWORD dwHairPart;
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+	DWORD dwAccePart;
+#endif
+	BYTE bDummy[4];
+	long x, y;
+	LONG lAddr;
+	WORD wPort;
+	BYTE bySkillGroup;
+	DWORD dwLastPlay;
+#if defined(ENABLE_CONQUEROR_LEVEL)
+	BYTE byConquerorLevel;
+	BYTE bySungmaStr, bySungmaHp, bySungmaMove, bySungmaImmune;
+#endif
+} TSimplePlayerInformation;
+
+typedef struct packet_login_success3
+{
+	BYTE header;
+	TSimplePlayerInformation akSimplePlayerInformation[PLAYER_PER_ACCOUNT3];
+	DWORD guild_id[PLAYER_PER_ACCOUNT3];
+	char guild_name[PLAYER_PER_ACCOUNT3][GUILD_NAME_MAX_LEN + 1];
+	DWORD handle;
+	DWORD random_key;
+} TPacketGCLoginSuccess3;
+
+typedef struct packet_login_success4
+{
+	BYTE header;
+	TSimplePlayerInformation akSimplePlayerInformation[PLAYER_PER_ACCOUNT4];
+	DWORD guild_id[PLAYER_PER_ACCOUNT4];
+	char guild_name[PLAYER_PER_ACCOUNT4][GUILD_NAME_MAX_LEN + 1];
+	DWORD handle;
+	DWORD random_key;
+} TPacketGCLoginSuccess4;
+
+#if defined(ENABLE_PLAYER_PER_ACCOUNT5)
+typedef struct packet_login_success5
+{
+	BYTE header;
+	TSimplePlayerInformation akSimplePlayerInformation[PLAYER_PER_ACCOUNT5];
+	DWORD guild_id[PLAYER_PER_ACCOUNT5];
+	char guild_name[PLAYER_PER_ACCOUNT5][GUILD_NAME_MAX_LEN + 1];
+	DWORD handle;
+	DWORD random_key;
+} TPacketGCLoginSuccess5;
+#endif
+
+enum ELoginFailure
+{
+	LOGIN_FAILURE_NONE,
+	LOGIN_FAILURE_ALREADY,
+	LOGIN_FAILURE_NOID,
+	LOGIN_FAILURE_WRONGPWD,
+	LOGIN_FAILURE_FULL,
+	LOGIN_FAILURE_SHUTDOWN,
+	LOGIN_FAILURE_REPAIR,
+	LOGIN_FAILURE_BLOCK,
+	LOGIN_FAILURE_WRONGMAT,
+	LOGIN_FAILURE_QUIT,
+	LOGIN_FAILURE_BESAMEKEY,
+	LOGIN_FAILURE_NOTAVAIL,
+	LOGIN_FAILURE_BLKLOGIN,
+	LOGIN_FAILURE_WEBBLK,
+	LOGIN_FAILURE_BADSCLID,
+	LOGIN_FAILURE_AGELIMIT,
+	LOGIN_FAILURE_CONFIRM,
+	LOGIN_FAILURE_INACTIVE,
+	LOGIN_FAILURE_UNMIGRATION,
+	LOGIN_FAILURE_MPROCESSING,
+	LOGIN_FAILURE_LOCKED,
+	LOGIN_FAILURE_BACKENDERR,
+	LOGIN_FAILURE_INTEGRTING,
+	LOGIN_FAILURE_COUNTRYERR,
+	LOGIN_FAILURE_IOVATION,
+	LOGIN_FAILURE_TNTERR,
+	LOGIN_FAILURE_SERVER_CLOSED,
+	LOGIN_FAILURE_SERVER_GRADE,
+};
+
+enum { LOGIN_STATUS_MAX_LEN = 8 };
+typedef struct packet_login_failure
+{
+	BYTE header;
+	char szStatus[LOGIN_STATUS_MAX_LEN + 1];
+} TPacketGCLoginFailure;
+
+typedef struct command_player_create
+{
+	BYTE header;
+	BYTE index;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	WORD job;
+	BYTE shape;
+	BYTE CON;
+	BYTE INT;
+	BYTE STR;
+	BYTE DEX;
+} TPacketCGCreateCharacter;
+
+typedef struct command_player_create_success
+{
+	BYTE header;
+	BYTE bAccountCharacterSlot;
+	TSimplePlayerInformation kSimplePlayerInfomation;
+} TPacketGCPlayerCreateSuccess;
+
+typedef struct command_create_failure
+{
+	BYTE header;
+	BYTE bType;
+} TPacketGCCreateFailure;
+
+typedef struct command_player_delete
+{
+	BYTE header;
+	BYTE index;
+	char szPrivateCode[PRIVATE_CODE_LENGTH];
+} TPacketCGDestroyCharacter;
+
+#if defined(ENABLE_DELETE_FAILURE_TYPE)
+typedef struct SPacketGCDestroyCharacterFailure
+{
+	BYTE header;
+	BYTE type;
+	INT time;
+} TPacketGCDestroyCharacterFailure;
+#endif
+
+typedef struct packet_player_delete_success
+{
+	BYTE header;
+	BYTE account_index;
+} TPacketGCDestroyCharacterSuccess;
+
+enum
+{
+	ADD_CHARACTER_STATE_DEAD = (1 << 0),
+	ADD_CHARACTER_STATE_SPAWN = (1 << 1),
+	ADD_CHARACTER_STATE_GUNGON = (1 << 2),
+	ADD_CHARACTER_STATE_KILLER = (1 << 3),
+	ADD_CHARACTER_STATE_PARTY = (1 << 4),
+};
+
+enum EPKModes
+{
+	PK_MODE_PEACE,
+	PK_MODE_REVENGE,
+	PK_MODE_FREE,
+	PK_MODE_PROTECT,
+	PK_MODE_GUILD,
+	PK_MODE_MAX_NUM,
+};
+
+// 2004.11.20.myevan.CRaceData::PART_MAX_NUM Ï°  -  Ï´Â°Í° Ä¡ 
+enum ECharacterEquipmentPart
+{
+	CHR_EQUIPPART_ARMOR,
+	CHR_EQUIPPART_WEAPON,
+	CHR_EQUIPPART_HEAD,
+	CHR_EQUIPPART_HAIR,
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+	CHR_EQUIPPART_ACCE,
+#endif
+#if defined(ENABLE_AURA_COSTUME_SYSTEM)
+	CHR_EQUIPPART_AURA,
+#endif
+
+	CHR_EQUIPPART_NUM,
+};
+
+typedef struct packet_add_char
+{
+	BYTE header;
+	DWORD dwVID;
+
+#ifdef WJ_SHOW_MOB_INFO
+	DWORD dwLevel;
+	DWORD dwAIFlag;
+#endif
+
+	float angle;
+	long x;
+	long y;
+	long z;
+
+	BYTE bType;
+	WORD wRaceNum;
+#if defined(ENABLE_RACE_SWAP)
+	DWORD dwEventRaceNum;
+#endif
+
+	BYTE bMovingSpeed;
+	BYTE bAttackSpeed;
+
+	BYTE bStateFlag;
+	DWORD dwAffectFlag[3];
+} TPacketGCCharacterAdd;
+
+typedef struct packet_char_additional_info
+{
+	BYTE header;
+	DWORD dwVID;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	DWORD adwPart[CHR_EQUIPPART_NUM];
+	BYTE bEmpire;
+	DWORD dwGuildID;
+	DWORD dwLevel;
+#if defined(ENABLE_CONQUEROR_LEVEL)
+	DWORD dwConquerorLevel;
+#endif
+	short sAlignment; // Ä¡
+	BYTE bPKMode;
+	DWORD dwMountVnum;
+#if defined(ENABLE_QUIVER_SYSTEM)
+	DWORD dwArrow;
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+	WORD wRefineElementAffectType;
+#endif
+#if defined(ENABLE_GUILD_LEADER_GRADE_NAME)
+	BYTE bGuildLeaderGrade;
+#endif
+#ifdef ENABLE_GROWTH_PET_SYSTEM
+	BYTE bCharacterSize;
+#endif
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketGCCharacterAdditionalInfo;
+
+typedef struct packet_update_char
+{
+	BYTE header;
+	DWORD dwVID;
+
+	DWORD adwPart[CHR_EQUIPPART_NUM];
+	BYTE bMovingSpeed;
+	BYTE bAttackSpeed;
+
+	BYTE bStateFlag;
+	DWORD dwAffectFlag[3];
+
+	DWORD dwGuildID;
+	short sAlignment;
+	DWORD dwLevel;
+#if defined(ENABLE_CONQUEROR_LEVEL)
+	DWORD dwConquerorLevel;
+#endif
+	BYTE bPKMode;
+	DWORD dwMountVnum;
+#if defined(ENABLE_QUIVER_SYSTEM)
+	DWORD dwArrow;
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+	WORD wRefineElementAffectType;
+#endif
+#if defined(ENABLE_GUILD_LEADER_GRADE_NAME)
+	BYTE bGuildLeaderGrade;
+#endif
+#if defined(ENABLE_LEFT_SEAT)
+	bool bLeftSeat;
+#endif
+} TPacketGCCharacterUpdate;
+
+typedef struct packet_del_char
+{
+	BYTE header;
+	DWORD dwVID;
+} TPacketGCCharacterDelete;
+
+typedef struct packet_GlobalTime
+{
+	BYTE header;
+	float GlobalTime;
+} TPacketGCGlobalTime;
+
+enum EChatType
+{
+	CHAT_TYPE_TALKING, /* ×³ Ã¤ */
+	CHAT_TYPE_INFO, /*  ( , Ä¡ . ) */
+	CHAT_TYPE_NOTICE, /*  */
+	CHAT_TYPE_PARTY, /* Æ¼ */
+	CHAT_TYPE_GUILD, /* å¸» */
+	CHAT_TYPE_COMMAND, /*  */
+	CHAT_TYPE_SHOUT, /* Ä¡ */
+	CHAT_TYPE_WHISPER, // Í´  Ê´ Only Client Enum
+	CHAT_TYPE_BIG_NOTICE,
+	CHAT_TYPE_MONARCH_NOTICE,
+#if defined(ENABLE_OX_RENEWAL)
+	CHAT_TYPE_BIG_CONTROL_NOTICE,
+#endif
+#if defined(ENABLE_DICE_SYSTEM)
+	CHAT_TYPE_DICE_INFO,
+#endif
+	CHAT_TYPE_MISSION,
+	CHAT_TYPE_SUB_MISSION,
+#if defined(ENABLE_CHATTING_WINDOW_RENEWAL)
+	CHAT_TYPE_EXP_INFO,
+	CHAT_TYPE_ITEM_INFO,
+	CHAT_TYPE_MONEY_INFO,
+#endif
+	CHAT_TYPE_MAX_NUM,
+};
+
+typedef struct packet_chatting
+{
+	BYTE header;
+	WORD size;
+	BYTE type;
+	DWORD dwVID;
+	BYTE bEmpire;
+#if defined(ENABLE_LOCALE_CLIENT)
+	bool bCanFormat;
+#endif
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketGCChat;
+
+typedef struct packet_whisper //  Å¶
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bType;
+	char szNameFrom[CHARACTER_NAME_MAX_LEN + 1];
+#if defined(ENABLE_LOCALE_CLIENT)
+	bool bCanFormat;
+#endif
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+	char szCountry[COUNTRY_NAME_MAX_LEN + 1];
+#endif
+} TPacketGCWhisper;
+
+typedef struct packet_stun
+{
+	BYTE header;
+	DWORD vid;
+} TPacketGCStun;
+
+typedef struct packet_dead
+{
+	BYTE header;
+	DWORD vid;
+	BYTE dialog_type;
+	long map_index;
+} TPacketGCDead;
+
+typedef struct packet_main_character
+{
+	BYTE header;
+	DWORD dwVID;
+	WORD wRaceNum;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	long lX, lY, lZ;
+	BYTE bySkillGroup;
+} TPacketGCMainCharacter;
+
+// SUPPORT_BGM
+typedef struct packet_main_character2_empire
+{
+	BYTE header;
+	DWORD dwVID;
+	WORD wRaceNum;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	long lX, lY, lZ;
+	BYTE byEmpire;
+	BYTE bySkillGroup;
+} TPacketGCMainCharacter2_EMPIRE;
+
+typedef struct packet_main_character3_bgm
+{
+	enum
+	{
+		MUSIC_NAME_MAX_LEN = 24,
+	};
+	BYTE header;
+	DWORD dwVID;
+	WORD wRaceNum;
+	char szUserName[CHARACTER_NAME_MAX_LEN + 1];
+	char szBGMName[MUSIC_NAME_MAX_LEN + 1];
+	long lX, lY, lZ;
+	BYTE byEmpire;
+	BYTE bySkillGroup;
+} TPacketGCMainCharacter3_BGM;
+
+typedef struct packet_main_character4_bgm_vol
+{
+	enum
+	{
+		MUSIC_NAME_MAX_LEN = 24,
+	};
+	BYTE header;
+	DWORD dwVID;
+	WORD wRaceNum;
+	char szUserName[CHARACTER_NAME_MAX_LEN + 1];
+	char szBGMName[MUSIC_NAME_MAX_LEN + 1];
+	float fBGMVol;
+	long lX, lY, lZ;
+	BYTE byEmpire;
+	BYTE bySkillGroup;
+} TPacketGCMainCharacter4_BGM_VOL;
+// END_OF_SUPPORT_BGM
+
+enum EPointTypes
+{
+	POINT_NONE,						// 0
+	POINT_LEVEL,					// 1
+	POINT_VOICE,					// 2
+	POINT_EXP,						// 3
+	POINT_NEXT_EXP,					// 4
+	POINT_HP,						// 5
+	POINT_MAX_HP,					// 6
+	POINT_SP,						// 7
+	POINT_MAX_SP,					// 8
+	POINT_STAMINA,					// 9 ×¹Ì³
+	POINT_MAX_STAMINA,				// 10 Ö´ ×¹Ì³
+
+	POINT_GOLD,						// 11
+	POINT_ST,						// 12 Ù·
+	POINT_HT,						// 13 Ã¼
+	POINT_DX,						// 14 Ã¸
+	POINT_IQ,						// 15 Å·
+	POINT_ATT_POWER,				// 16 Ý·
+	POINT_ATT_SPEED,				// 17 Ý¼Óµ
+	POINT_EVADE_RATE,				// 18 È¸
+	POINT_MOV_SPEED,				// 19 ÌµÓµ
+	POINT_DEF_GRADE,				// 20 
+	POINT_CASTING_SPEED,			// 21 Ö¹Óµ (Ù¿Å¸*100) / (100 + Ì°) =  Ù¿ Å¸
+	POINT_MAGIC_ATT_GRADE,			// 22 Ý·
+	POINT_MAGIC_DEF_GRADE,			// 23 
+	POINT_EMPIRE_POINT,				// 24 
+	POINT_LEVEL_STEP,				// 25   Ü°.. (1 2 3   , 4 Ç¸  )
+	POINT_STAT,						// 26 É·Ä¡ Ã¸  Ö´ 
+	POINT_SUB_SKILL,				// 27  Å³ Æ®
+	POINT_SKILL,					// 28 Æ¼ Å³ Æ®
+	//POINT_SKILL_PASV,				// 27 Ð½Ãº  Ã¸  Ö´ 
+	//POINT_SKILL_ACTIVE,			// 28 Æ¼ Å³ Æ®
+	POINT_MIN_ATK,					// 29 Ö¼ Ä±
+	POINT_MAX_ATK,					// 30 Ö´ Ä±
+	POINT_PLAYTIME,					// 31 Ã·Ì½Ã°
+	POINT_HP_REGEN,					// 32 HP È¸
+	POINT_SP_REGEN,					// 33 SP È¸
+
+	POINT_BOW_DISTANCE,				// 34 È° Å¸ Ä¡ (meter)
+
+	POINT_HP_RECOVERY,				// 35 Ã¼ È¸ 
+	POINT_SP_RECOVERY,				// 36 Å· È¸ 
+
+	POINT_POISON_PCT,				// 37  È®
+	POINT_STUN_PCT,					// 38  È®
+	POINT_SLOW_PCT,					// 39 Î¿ È®
+	POINT_CRITICAL_PCT,				// 40 Å©Æ¼ È®
+	POINT_PENETRATE_PCT,			// 41 Å¸ È®
+	POINT_CURSE_PCT,				// 42  È®
+
+	POINT_ATTBONUS_HUMAN,			// 43 Î° 
+	POINT_ATTBONUS_ANIMAL,			// 44   % 
+	POINT_ATTBONUS_ORC,				// 45 Í¿  % 
+	POINT_ATTBONUS_MILGYO,			// 46 Ð±  % 
+	POINT_ATTBONUS_UNDEAD,			// 47 Ã¼  % 
+	POINT_ATTBONUS_DEVIL,			// 48 (Ç¸)  % 
+	POINT_ATTBONUS_INSECT,			// 49 
+	POINT_ATTBONUS_FIRE,			// 50 È­
+	POINT_ATTBONUS_ICE,				// 51 
+	POINT_ATTBONUS_DESERT,			// 52 ç¸·
+	POINT_ATTBONUS_MONSTER,			// 53  Í¿ 
+	POINT_ATTBONUS_WARRIOR,			// 54 ç¿¡ 
+	POINT_ATTBONUS_ASSASSIN,		// 55 Ú° 
+	POINT_ATTBONUS_SURA,			// 56 ó¿¡° 
+	POINT_ATTBONUS_SHAMAN,			// 57 ç¿¡ 
+	POINT_ATTBONUS_TREE,			// 58   20050729.myevan UNUSED5
+	POINT_RESIST_WARRIOR,			// 59 ç¿¡ 
+	POINT_RESIST_ASSASSIN,			// 60 Ú° 
+	POINT_RESIST_SURA,				// 61 ó¿¡° 
+	POINT_RESIST_SHAMAN,			// 62 ç¿¡ 
+
+	POINT_STEAL_HP,					// 63  
+	POINT_STEAL_SP,					// 64 Å· 
+
+	POINT_MANA_BURN_PCT,			// 65  
+
+	/// Ø½ Ê½ ///
+
+	POINT_DAMAGE_SP_RECOVER,		// 66 Ý´  Å· È¸ È®
+
+	POINT_BLOCK,					// 67 
+	POINT_DODGE,					// 68 È¸
+
+	POINT_RESIST_SWORD,				// 69
+	POINT_RESIST_TWOHAND,			// 70
+	POINT_RESIST_DAGGER,			// 71
+	POINT_RESIST_BELL,				// 72
+	POINT_RESIST_FAN,				// 73
+	POINT_RESIST_BOW,				// 74 È­  :  
+	POINT_RESIST_FIRE,				// 75 È­  : È­Ý¿   
+	POINT_RESIST_ELEC,				// 76   : Ý¿   
+	POINT_RESIST_MAGIC,				// 77   :    
+	POINT_RESIST_WIND,				// 78 Ù¶  : Ù¶Ý¿   
+
+	POINT_REFLECT_MELEE,			// 79  Ý»
+
+	/// Æ¯ Ø½ ///
+	POINT_REFLECT_CURSE,			// 80  Ý»
+	POINT_POISON_REDUCE,			// 81  
+
+	///  Ò¸ ///
+	POINT_KILL_SP_RECOVER,			// 82  Ò¸ MP È¸
+	POINT_EXP_DOUBLE_BONUS,			// 83
+	POINT_GOLD_DOUBLE_BONUS,		// 84
+	POINT_ITEM_DROP_BONUS,			// 85
+
+	/// È¸  ///
+	POINT_POTION_BONUS,				// 86
+	POINT_KILL_HP_RECOVERY,			// 87
+
+	POINT_IMMUNE_STUN,				// 88
+	POINT_IMMUNE_SLOW,				// 89
+	POINT_IMMUNE_FALL,				// 90
+	//////////////////
+
+	POINT_PARTY_ATT_GRADE,			// 91
+	POINT_PARTY_DEF_GRADE,			// 92
+
+	POINT_ATT_BONUS,				// 93
+	POINT_DEF_BONUS,				// 94
+
+	POINT_ATT_GRADE_BONUS,			// 95
+	POINT_DEF_GRADE_BONUS,			// 96
+	POINT_MAGIC_ATT_GRADE_BONUS,	// 97
+	POINT_MAGIC_DEF_GRADE_BONUS,	// 98
+
+	POINT_RESIST_NORMAL_DAMAGE,		// 99
+
+#if defined(ENABLE_MOUNT_COSTUME_SYSTEM)
+	POINT_MOUNT = 109,				// 109
+#endif
+
+	POINT_STAT_RESET_COUNT = 112,	// 112
+	POINT_HORSE_SKILL = 113,		// 113
+
+	POINT_MALL_ATTBONUS,			// 114 Ý· +x%
+	POINT_MALL_DEFBONUS,			// 115  +x%
+	POINT_MALL_EXPBONUS,			// 116 Ä¡ +x%
+	POINT_MALL_ITEMBONUS,			// 117   x/10
+	POINT_MALL_GOLDBONUS,			// 118   x/10
+	POINT_MAX_HP_PCT,				// 119 Ö´ +x%
+	POINT_MAX_SP_PCT,				// 120 Ö´Å· +x%
+
+	POINT_SKILL_DAMAGE_BONUS,		// 121 Å³  *(100+x)%
+	POINT_NORMAL_HIT_DAMAGE_BONUS,	// 122 Å¸  *(100+x)%
+
+	POINT_SKILL_DEFEND_BONUS,		// 123 Å³  
+	POINT_NORMAL_HIT_DEFEND_BONUS,	// 124 Å¸  
+	POINT_PC_BANG_EXP_BONUS,		// 125
+	POINT_PC_BANG_DROP_BONUS,		// 126 PC  Ó· Ê½
+
+	POINT_ENERGY = 128,				// 128 
+
+	//  ui .
+	// Ì· Ï°  Ê¾, 
+	// uiTaskBar affect   ,
+	//  Å¬ó¸®¾Æ® blend_affect  Ê¾,
+	// Ó½Ã· Ì· Ð´.
+	POINT_ENERGY_END_TIME = 129,	// 129   Ã°
+
+	POINT_COSTUME_ATTR_BONUS = 130,			// 130
+	POINT_MAGIC_ATT_BONUS_PER = 131,		// 131
+	POINT_MELEE_MAGIC_ATT_BONUS_PER = 132,	// 132
+
+	POINT_RESIST_ICE = 133,				// 133 Ã±  : Ý¿   
+	POINT_RESIST_EARTH = 134,			// 134   : Ý¿   
+	POINT_RESIST_DARK = 135,			// 135   : Ý¿   
+
+	POINT_RESIST_CRITICAL = 136,		// 136 Å©Æ¼  :  Å©Æ¼ È® 
+	POINT_RESIST_PENETRATE = 137,		// 137 Å¸  :  Å¸ È® 
+
+	POINT_BLEEDING_REDUCE = 138,		// 138
+	POINT_BLEEDING_PCT = 139,			// 139
+	POINT_ATTBONUS_WOLFMAN = 140,		// 140
+	POINT_RESIST_WOLFMAN = 141,			// 141
+	POINT_RESIST_CLAW = 142,			// 142
+
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+	POINT_ACCEDRAIN_RATE,
+#endif
+#if defined(ENABLE_MAGIC_REDUCTION)
+	POINT_RESIST_MAGIC_REDUCTION,
+#endif
+#if defined(ENABLE_CHEQUE_SYSTEM)
+	POINT_CHEQUE,
+#endif
+	POINT_BATTLE_POINT,
+	POINT_RESIST_HUMAN,
+	POINT_ENCHANT_ELECT,
+	POINT_ENCHANT_FIRE,
+	POINT_ENCHANT_ICE,
+	POINT_ENCHANT_WIND,
+	POINT_ENCHANT_EARTH,
+	POINT_ENCHANT_DARK,
+	POINT_ATTBONUS_CZ,
+	POINT_BEAD,
+#if defined(ENABLE_GEM_SYSTEM)
+	POINT_GEM,
+#endif
+	POINT_ATTBONUS_SWORD,
+	POINT_ATTBONUS_TWOHAND,
+	POINT_ATTBONUS_DAGGER,
+	POINT_ATTBONUS_BELL,
+	POINT_ATTBONUS_FAN,
+	POINT_ATTBONUS_BOW,
+	POINT_ATTBONUS_CLAW,
+	POINT_RESIST_MOUNT_FALL,
+	POINT_RESIST_FIST,
+	POINT_PREMIUM_EXPBONUS,
+	POINT_PRIVILEGE_EXPBONUS,
+	POINT_MARRIAGE_EXPBONUS,
+	POINT_DEVILTOWER_EXPBONUS,
+	POINT_PREMIUM_ITEMBONUS,
+	POINT_PRIVILEGE_ITEMBONUS,
+	POINT_PREMIUM_GOLDBONUS,
+	POINT_PRIVILEGE_GOLDBONUS,
+	POINT_SKILL_DAMAGE_SAMYEON,
+	POINT_SKILL_DAMAGE_TANHWAN,
+	POINT_SKILL_DAMAGE_PALBANG,
+	POINT_SKILL_DAMAGE_GIGONGCHAM,
+	POINT_SKILL_DAMAGE_GYOKSAN,
+	POINT_SKILL_DAMAGE_GEOMPUNG,
+	POINT_SKILL_DAMAGE_AMSEOP,
+	POINT_SKILL_DAMAGE_GUNGSIN,
+	POINT_SKILL_DAMAGE_CHARYUN,
+	POINT_SKILL_DAMAGE_SANGONG,
+	POINT_SKILL_DAMAGE_YEONSA,
+	POINT_SKILL_DAMAGE_KWANKYEOK,
+	POINT_SKILL_DAMAGE_GIGUNG,
+	POINT_SKILL_DAMAGE_HWAJO,
+	POINT_SKILL_DAMAGE_SWAERYUNG,
+	POINT_SKILL_DAMAGE_YONGKWON,
+	POINT_SKILL_DAMAGE_PABEOB,
+	POINT_SKILL_DAMAGE_MARYUNG,
+	POINT_SKILL_DAMAGE_HWAYEOMPOK,
+	POINT_SKILL_DAMAGE_MAHWAN,
+	POINT_SKILL_DAMAGE_BIPABU,
+	POINT_SKILL_DAMAGE_YONGBI,
+	POINT_SKILL_DAMAGE_PAERYONG,
+	POINT_SKILL_DAMAGE_NOEJEON,
+	POINT_SKILL_DAMAGE_BYEURAK,
+	POINT_SKILL_DAMAGE_CHAIN,
+	POINT_SKILL_DAMAGE_CHAYEOL,
+	POINT_SKILL_DAMAGE_SALPOONG,
+	POINT_SKILL_DAMAGE_GONGDAB,
+	POINT_SKILL_DAMAGE_PASWAE,
+	POINT_NORMAL_HIT_DEFEND_BONUS_BOSS_OR_MORE,
+	POINT_SKILL_DEFEND_BONUS_BOSS_OR_MORE,
+	POINT_NORMAL_HIT_DAMAGE_BONUS_BOSS_OR_MORE,
+	POINT_SKILL_DAMAGE_BONUS_BOSS_OR_MORE,
+	POINT_HIT_BUFF_ENCHANT_FIRE,
+	POINT_HIT_BUFF_ENCHANT_ICE,
+	POINT_HIT_BUFF_ENCHANT_ELEC,
+	POINT_HIT_BUFF_ENCHANT_WIND,
+	POINT_HIT_BUFF_ENCHANT_DARK,
+	POINT_HIT_BUFF_ENCHANT_EARTH,
+	POINT_HIT_BUFF_RESIST_FIRE,
+	POINT_HIT_BUFF_RESIST_ICE,
+	POINT_HIT_BUFF_RESIST_ELEC,
+	POINT_HIT_BUFF_RESIST_WIND,
+	POINT_HIT_BUFF_RESIST_DARK,
+	POINT_HIT_BUFF_RESIST_EARTH,
+	POINT_USE_SKILL_CHEONGRANG_MOV_SPEED,
+	POINT_USE_SKILL_CHEONGRANG_CASTING_SPEED,
+	POINT_USE_SKILL_CHAYEOL_CRITICAL_PCT,
+	POINT_USE_SKILL_SANGONG_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_GIGUNG_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_JEOKRANG_DEF_BONUS,
+	POINT_USE_SKILL_GWIGEOM_DEF_BONUS,
+	POINT_USE_SKILL_TERROR_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_MUYEONG_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_MANASHILED_CASTING_SPEED,
+	POINT_USE_SKILL_HOSIN_DEF_BONUS,
+	POINT_USE_SKILL_GICHEON_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_JEONGEOP_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_JEUNGRYEOK_DEF_BONUS,
+	POINT_USE_SKILL_GIHYEOL_ATT_GRADE_BONUS,
+	POINT_USE_SKILL_CHUNKEON_CASTING_SPEED,
+	POINT_USE_SKILL_NOEGEOM_ATT_GRADE_BONUS,
+	POINT_SKILL_DURATION_INCREASE_EUNHYUNG,
+	POINT_SKILL_DURATION_INCREASE_GYEONGGONG,
+	POINT_SKILL_DURATION_INCREASE_GEOMKYUNG,
+	POINT_SKILL_DURATION_INCREASE_JEOKRANG,
+	POINT_USE_SKILL_PALBANG_HP_ABSORB,
+	POINT_USE_SKILL_AMSEOP_HP_ABSORB,
+	POINT_USE_SKILL_YEONSA_HP_ABSORB,
+	POINT_USE_SKILL_YONGBI_HP_ABSORB,
+	POINT_USE_SKILL_CHAIN_HP_ABSORB,
+	POINT_USE_SKILL_PASWAE_SP_ABSORB,
+	POINT_USE_SKILL_GIGONGCHAM_STUN,
+	POINT_USE_SKILL_CHARYUN_STUN,
+	POINT_USE_SKILL_PABEOB_STUN,
+	POINT_USE_SKILL_MAHWAN_STUN,
+	POINT_USE_SKILL_GONGDAB_STUN,
+	POINT_USE_SKILL_SAMYEON_STUN,
+	POINT_USE_SKILL_GYOKSAN_KNOCKBACK,
+	POINT_USE_SKILL_SEOMJEON_KNOCKBACK,
+	POINT_USE_SKILL_SWAERYUNG_KNOCKBACK,
+	POINT_USE_SKILL_HWAYEOMPOK_KNOCKBACK,
+	POINT_USE_SKILL_GONGDAB_KNOCKBACK,
+	POINT_USE_SKILL_KWANKYEOK_KNOCKBACK,
+	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_10PER,
+	POINT_ATTBONUS_STONE,
+	POINT_DAMAGE_HP_RECOVERY,
+	POINT_DAMAGE_SP_RECOVERY,
+	POINT_ALIGNMENT_DAMAGE_BONUS,
+	POINT_NORMAL_DAMAGE_GUARD,
+	POINT_MORE_THEN_HP90_DAMAGE_REDUCE,
+	POINT_USE_SKILL_TUSOK_HP_ABSORB,
+	POINT_USE_SKILL_PAERYONG_HP_ABSORB,
+	POINT_USE_SKILL_BYEURAK_HP_ABSORB,
+	POINT_USE_SKILL_SAMYEON_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_GEOMPUNG_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_GUNGSIN_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_KWANKYEOK_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_YONGKWON_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_MARYUNG_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_BIPABU_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_NOEJEON_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_SALPOONG_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_PASWAE_NEXT_COOLTIME_DECREASE_20PER,
+	POINT_USE_SKILL_CHAYEOL_HP_ABSORB,
+	POINT_MEDAL_OF_HONOR,
+	POINT_ALL_STAT_BONUS,
+	POINT_SUNGMA_STR,
+	POINT_SUNGMA_HP,
+	POINT_SUNGMA_MOVE,
+	POINT_SUNGMA_IMMUNE,
+	POINT_CONQUEROR_LEVEL,
+	POINT_CONQUEROR_LEVEL_STEP,
+	POINT_CONQUEROR_EXP,
+	POINT_CONQUEROR_NEXT_EXP,
+	POINT_CONQUEROR_POINT,
+	POINT_HIT_PCT,
+	POINT_ATTBONUS_PER_HUMAN,
+	POINT_ATTBONUS_PER_ANIMAL,
+	POINT_ATTBONUS_PER_ORC,
+	POINT_ATTBONUS_PER_MILGYO,
+	POINT_ATTBONUS_PER_UNDEAD,
+	POINT_ATTBONUS_PER_DEVIL,
+	POINT_ENCHANT_PER_ELECT,
+	POINT_ENCHANT_PER_FIRE,
+	POINT_ENCHANT_PER_ICE,
+	POINT_ENCHANT_PER_WIND,
+	POINT_ENCHANT_PER_EARTH,
+	POINT_ENCHANT_PER_DARK,
+	POINT_ATTBONUS_PER_CZ,
+	POINT_ATTBONUS_PER_INSECT,
+	POINT_ATTBONUS_PER_DESERT,
+	POINT_ATTBONUS_PER_STONE,
+	POINT_ATTBONUS_PER_MONSTER,
+	POINT_RESIST_PER_HUMAN,
+	POINT_RESIST_PER_ICE,
+	POINT_RESIST_PER_DARK,
+	POINT_RESIST_PER_EARTH,
+	POINT_RESIST_PER_FIRE,
+	POINT_RESIST_PER_ELEC,
+	POINT_RESIST_PER_MAGIC,
+	POINT_RESIST_PER_WIND,
+	POINT_HIT_BUFF_SUNGMA_STR,
+	POINT_HIT_BUFF_SUNGMA_MOVE,
+	POINT_HIT_BUFF_SUNGMA_HP,
+	POINT_HIT_BUFF_SUNGMA_IMMUNE,
+	POINT_MOUNT_MELEE_MAGIC_ATTBONUS_PER,
+	POINT_DISMOUNT_MOVE_SPEED_BONUS_PER,
+	POINT_HIT_AUTO_HP_RECOVERY,
+	POINT_HIT_AUTO_SP_RECOVERY,
+	POINT_USE_SKILL_COOLTIME_DECREASE_ALL,
+	POINT_HIT_STONE_ATTBONUS_STONE,
+	POINT_HIT_STONE_DEF_GRADE_BONUS,
+	POINT_KILL_BOSS_ITEM_BONUS,
+	POINT_MOB_HIT_MOB_AGGRESSIVE,
+	POINT_NO_DEATH_AND_HP_RECOVERY30,
+	POINT_AUTO_PICKUP,
+	POINT_MOUNT_NO_KNOCKBACK,
+	POINT_SUNGMA_PER_STR,
+	POINT_SUNGMA_PER_HP,
+	POINT_SUNGMA_PER_MOVE,
+	POINT_SUNGMA_PER_IMMUNE,
+	POINT_IMMUNE_POISON100,
+	POINT_IMMUNE_BLEEDING100,
+	POINT_MONSTER_DEFEND_BONUS,
+
+	// Å¬Ì¾Æ® Æ®
+	POINT_MIN_WEP,
+	POINT_MAX_WEP,
+	POINT_MIN_MAGIC_WEP,
+	POINT_MAX_MAGIC_WEP,
+	POINT_HIT_RATE,
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	POINT_BATTLE_PASS_PREMIUM_ID
+#endif
+};
+
+typedef struct SPacketGCPoints
+{
+	BYTE bHeader;
+	POINT_VALUE lPoints[POINT_MAX_NUM];
+} TPacketGCPoints;
+
+typedef struct SPacketGCPointChange
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	POINT_TYPE wType;
+	POINT_VALUE lAmount;
+	POINT_VALUE lValue;
+} TPacketGCPointChange;
+
+typedef struct packet_motion
+{
+	BYTE header;
+	DWORD vid;
+	DWORD victim_vid;
+	WORD motion;
+} TPacketGCMotion;
+
+typedef struct packet_set_empty_item
+{
+	BYTE bHeader;
+	TItemPos Cell;
+	DWORD dwVnum;
+	DWORD dwCount;
+	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
+#endif
+#if defined(ENABLE_SET_ITEM)
+	BYTE bSetValue;
+#endif
+} TPacketGCItemSetEmpty;
+
+typedef struct packet_set_item
+{
+	BYTE bHeader;
+	TItemPos Cell;
+	DWORD dwVnum;
+	DWORD dwCount;
+	DWORD dwFlags; // Ã· ß°
+	DWORD dwAntiFlags; // Ã· ß°
+	bool bHighLight;
+#if defined(ENABLE_SOULBIND_SYSTEM)
+	long lSealDate;
+#endif
+	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
+#endif
+#if defined(ENABLE_SET_ITEM)
+	BYTE bSetValue;
+#endif
+} TPacketGCItemSet;
+
+typedef struct packet_del_item
+{
+	BYTE header;
+	BYTE pos;
+} TPacketGCItemDel;
+
+typedef struct packet_use_item
+{
+	BYTE header;
+	TItemPos Cell;
+	DWORD ch_vid;
+	DWORD victim_vid;
+
+	DWORD vnum;
+} TPacketGCItemUse;
+
+typedef struct packet_update_item
+{
+	BYTE bHeader;
+	TItemPos Cell;
+	DWORD dwCount;
+#if defined(ENABLE_SOULBIND_SYSTEM)
+	long lSealDate;
+#endif
+	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
+#endif
+#if defined(ENABLE_SET_ITEM)
+	BYTE bSetValue;
+#endif
+} TPacketGCItemUpdate;
+
+typedef struct packet_ground_add_item
+{
+#if defined(ENABLE_ITEM_DROP_RENEWAL)
+	packet_ground_add_item()
+	{
+		memset(&alSockets, 0, sizeof(alSockets));
+		memset(&aAttrs, 0, sizeof(aAttrs));
+	}
+#endif
+
+	BYTE bHeader;
+	long lX, lY, lZ;
+	DWORD dwVID;
+	DWORD dwVnum;
+#if defined(ENABLE_SET_ITEM)
+	BYTE bSetValue;
+#endif
+
+#if defined(ENABLE_ITEM_DROP_RENEWAL)
+	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
+	TPlayerItemAttribute aAttrs[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
+#endif
+} TPacketGCItemGroundAdd;
+
+typedef struct packet_ground_del_item
+{
+	BYTE header;
+	DWORD vid;
+} TPacketGCItemGroundDel;
+
+typedef struct packet_item_ownership
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGCItemOwnership;
+
+typedef struct packet_quickslot_add
+{
+	BYTE header;
+	BYTE pos;
+	TQuickSlot slot;
+} TPacketGCQuickSlotAdd;
+
+typedef struct packet_quickslot_del
+{
+	BYTE header;
+	BYTE pos; // quick slot pos
+} TPacketGCQuickSlotDel;
+
+typedef struct packet_quickslot_swap
+{
+	BYTE header;
+	BYTE pos;
+	BYTE change_pos;
+} TPacketGCQuickSlotSwap;
+
+typedef struct packet_shop_start
+{
+#if defined(ENABLE_MYSHOP_DECO)
+	BYTE shop_tab_count;
+#endif
+#if defined(ENABLE_MYSHOP_EXPANSION)
+	struct packet_shop_item items[SHOP_HOST_ITEM_MAX];
+#else
+	struct packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
+#endif
+} TPacketGCShopStart;
+
+typedef struct packet_shop_start_ex //  TSubPacketShopTab* shop_tabs  .
+{
+	typedef struct sub_packet_shop_tab
+	{
+		char name[SHOP_TAB_NAME_MAX];
+		BYTE coin_type;
+		packet_shop_item items[SHOP_HOST_ITEM_MAX_NUM];
+	} TSubPacketShopTab;
+	DWORD owner_vid;
+	BYTE shop_tab_count;
+} TPacketGCShopStartEx;
+
+typedef struct packet_shop_update_item
+{
+	BYTE pos;
+	struct packet_shop_item item;
+} TPacketGCShopUpdateItem;
+
+typedef struct packet_shop_update_price
+{
+	int iElkAmount;
+#if defined(ENABLE_CHEQUE_SYSTEM)
+	int iChequeAmount;
+#endif
+} TPacketGCShopUpdatePrice;
+
+enum EPacketShopSubHeaders
+{
+	SHOP_SUBHEADER_GC_NONE,
+	SHOP_SUBHEADER_GC_START,
+	SHOP_SUBHEADER_GC_END,
+	SHOP_SUBHEADER_GC_UPDATE_ITEM,
+	SHOP_SUBHEADER_GC_UPDATE_PRICE,
+	SHOP_SUBHEADER_GC_OK,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY,
+	SHOP_SUBHEADER_GC_SOLDOUT,
+	SHOP_SUBHEADER_GC_INVENTORY_FULL,
+	SHOP_SUBHEADER_GC_INVALID_POS,
+	SHOP_SUBHEADER_GC_SOLD_OUT,
+	SHOP_SUBHEADER_GC_START_EX,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY_EX,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_BP,
+	SHOP_SUBHEADER_GC_EXCEED_LIMIT_TODAY,
+#if defined(ENABLE_MYSHOP_DECO)
+	SHOP_SUBHEADER_GC_MYPRIV_SHOP_OPEN,
+#endif
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_10TH_COIN,
+	SHOP_SUBHEADER_GC_LIMITED_PURCHASE_OVER,
+	SHOP_SUBHEADER_GC_LIMITED_DATA_LOADING,
+	SHOP_SUBHEADER_GC_UNK_19,
+	SHOP_SUBHEADER_GC_UNK_20,
+	SHOP_SUBHEADER_GC_UNK_21,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_MEDAL_OF_HONOR,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_GUILD_LEVEL,
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_BNW,
+#if defined(ENABLE_SHOPEX_RENEWAL)
+	SHOP_SUBHEADER_GC_NOT_ENOUGH_ITEM,
+#endif
+};
+
+typedef struct packet_shop
+{
+	BYTE header;
+	WORD size;
+	BYTE subheader;
+} TPacketGCShop;
+
+typedef struct packet_exchange
+{
+	BYTE header;
+	BYTE subheader;
+	BYTE is_me;
+	DWORD arg1;
+	TItemPos arg2;
+	DWORD arg3;
+	TItemPos arg4;
+	long alValues[ITEM_SOCKET_SLOT_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
+#endif
+#if defined(ENABLE_SET_ITEM)
+	BYTE bSetValue;
+#endif
+} TPacketGCExchange;
+
+enum
+{
+	EXCHANGE_SUBHEADER_GC_START, // arg1 == vid
+	EXCHANGE_SUBHEADER_GC_ITEM_ADD, // arg1 == vnum  arg2 == pos  arg3 == count
+	EXCHANGE_SUBHEADER_GC_ITEM_DEL, // arg1 == pos
+	EXCHANGE_SUBHEADER_GC_ELK_ADD, // arg1 == elk
+#if defined(ENABLE_CHEQUE_SYSTEM)
+	EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, // arg1 == cheque
+#endif
+	EXCHANGE_SUBHEADER_GC_ACCEPT, // arg1 == accept
+	EXCHANGE_SUBHEADER_GC_END, // arg1 == not used
+	EXCHANGE_SUBHEADER_GC_ALREADY, // arg1 == not used
+	EXCHANGE_SUBHEADER_GC_LESS_ELK, // arg1 == not used
+#if defined(ENABLE_CHEQUE_SYSTEM)
+	EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, // arg1 == not used
+#endif
+};
+
+typedef struct packet_position
+{
+	BYTE header;
+	DWORD vid;
+	BYTE position;
+} TPacketGCPosition;
+
+typedef struct packet_ping
+{
+	BYTE header;
+} TPacketGCPing;
+
+typedef struct packet_pong
+{
+	BYTE bHeader;
+} TPacketCGPong;
+
+typedef struct packet_script
+{
+	BYTE header;
+	WORD size;
+	BYTE skin;
+	WORD src_size;
+} TPacketGCScript;
+
+typedef struct packet_target
+{
+	BYTE header;
+	DWORD dwVID;
+	BYTE bHPPercent;
+#if defined(ENABLE_VIEW_TARGET_DECIMAL_HP) || defined(ENABLE_DEFENSE_WAVE)
+	int iMinHP;
+	int iMaxHP;
+#if defined(ENABLE_DEFENSE_WAVE)
+	bool bAlliance;
+#endif
+#endif
+#if defined(ENABLE_ELEMENT_ADD)
+	BYTE bElement[CPythonNonPlayer::MOB_ELEMENT_MAX_NUM];
+#endif
+} TPacketGCTarget;
+
+#if defined(ENABLE_SEND_TARGET_INFO)
+typedef struct SPacketGCTargetDropInfo
+{
+	DWORD dwVnum;
+	BYTE bCount;
+} TPacketGCTargetDropInfo;
+
+typedef struct SPacketGCTargetInfo
+{
+	BYTE bHeader;
+	WORD wSize;
+	DWORD dwRaceVnum;
+	DWORD dwVID;
+	bool bDropMetinStone;
+} TPacketGCTargetInfo;
+
+typedef struct SPacketCGTargetInfo
+{
+	BYTE bHeader;
+	DWORD dwVID;
+} TPacketCGTargetInfo;
+#endif
+
+typedef struct packet_damage_info
+{
+	BYTE header;
+	DWORD dwVID;
+	BYTE flag;
+	int  damage;
+} TPacketGCDamageInfo;
+
+typedef struct packet_mount
+{
+	BYTE header;
+	DWORD vid;
+	DWORD mount_vid;
+	BYTE pos;
+	DWORD _x, _y;
+} TPacketGCMount;
+
+typedef struct packet_change_speed
+{
+	BYTE header;
+	DWORD vid;
+	WORD moving_speed;
+} TPacketGCChangeSpeed;
+
+typedef struct packet_move
+{
+	BYTE bHeader;
+	BYTE bFunc;
+	BYTE bArg;
+	BYTE bRot;
+	DWORD dwVID;
+	LONG lX;
+	LONG lY;
+	DWORD dwTime;
+	DWORD dwDuration;
+} TPacketGCMove;
+
+enum
+{
+	QUEST_SEND_IS_BEGIN = 1 << 0,
+	QUEST_SEND_TITLE = 1 << 1, // 28 
+	QUEST_SEND_CLOCK_NAME = 1 << 2, // 16 
+	QUEST_SEND_CLOCK_VALUE = 1 << 3,
+	QUEST_SEND_COUNTER_NAME = 1 << 4, // 16 
+	QUEST_SEND_COUNTER_VALUE = 1 << 5,
+	QUEST_SEND_ICON_FILE = 1 << 6, // 24  
+};
+
+typedef struct packet_quest_info
+{
+	BYTE header;
+	WORD size;
+	WORD index;
+#if defined(ENABLE_QUEST_RENEWAL)
+	BYTE type;
+	bool is_confirmed;
+#endif
+	BYTE flag;
+} TPacketGCQuestInfo;
+
+typedef struct packet_quest_confirm
+{
+	BYTE header;
+	char msg[128 + 1];
+	long timeout;
+	DWORD requestPID;
+} TPacketGCQuestConfirm;
+
+typedef struct packet_attack
+{
+	BYTE header;
+	DWORD dwVID;
+	DWORD dwVictimVID; //  VID
+	BYTE bType; //  
+} TPacketGCAttack;
+
+typedef struct packet_c2c
+{
+	BYTE header;
+	WORD wSize;
+} TPacketGCC2C;
+
+typedef struct packetd_sync_position_element
+{
+	DWORD dwVID;
+	long lX;
+	long lY;
+} TPacketGCSyncPositionElement;
+
+typedef struct packetd_sync_position
+{
+	BYTE bHeader;
+	WORD wSize;
+} TPacketGCSyncPosition;
+
+typedef struct packet_ownership
+{
+	BYTE bHeader;
+	DWORD dwOwnerVID;
+	DWORD dwVictimVID;
+} TPacketGCOwnership;
+
+#define	SKILL_MAX_NUM 255
+
+typedef struct packet_skill_level
+{
+	BYTE bHeader;
+	BYTE abSkillLevels[SKILL_MAX_NUM];
+} TPacketGCSkillLevel;
+
+typedef struct SPlayerSkill
+{
+	BYTE bMasterType;
+	BYTE bLevel;
+	time_t tNextRead;
+} TPlayerSkill;
+
+typedef struct packet_skill_level_new
+{
+	BYTE bHeader;
+	TPlayerSkill skills[SKILL_MAX_NUM];
+} TPacketGCSkillLevelNew;
+
+// fly
+typedef struct packet_fly
+{
+	BYTE bHeader;
+	BYTE bType;
+	DWORD dwStartVID;
+	DWORD dwEndVID;
+} TPacketGCCreateFly;
+
+enum EPVPModes
+{
+	PVP_MODE_NONE,
+	PVP_MODE_AGREE,
+	PVP_MODE_FIGHT,
+	PVP_MODE_REVENGE,
+};
+
+typedef struct packet_duel_start
+{
+	BYTE header;
+	WORD wSize; // DWORD î°³?  = (wSize - sizeof(TPacketGCPVPList)) / 4
+} TPacketGCDuelStart;
+
+typedef struct packet_pvp
+{
+	BYTE header;
+	DWORD dwVIDSrc;
+	DWORD dwVIDDst;
+	BYTE bMode;
+} TPacketGCPVP;
+
+typedef struct packet_warp
+{
+	BYTE bHeader;
+	LONG lX;
+	LONG lY;
+	LONG lAddr;
+	WORD wPort;
+} TPacketGCWarp;
+
+typedef struct packet_party_invite
+{
+	BYTE header;
+	DWORD leader_pid;
+} TPacketGCPartyInvite;
+
+typedef struct packet_party_add
+{
+	BYTE header;
+	DWORD pid;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+	long mapIdx;
+#endif
+#if defined(ENABLE_PARTY_CHANNEL_FIX)
+	BYTE channel;
+#endif
+} TPacketGCPartyAdd;
+
+typedef struct packet_party_update
+{
+	BYTE header;
+	DWORD pid;
+	BYTE state;
+	BYTE percent_hp;
+	short affects[PARTY_AFFECT_SLOT_MAX_NUM];
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+	long x;
+	long y;
+#endif
+} TPacketGCPartyUpdate;
+
+typedef struct packet_party_remove
+{
+	BYTE header;
+	DWORD pid;
+} TPacketGCPartyRemove;
+
+typedef TPacketCGSafeboxCheckout TPacketGCSafeboxCheckout;
+typedef TPacketCGSafeboxCheckin TPacketGCSafeboxCheckin;
+
+typedef struct packet_safebox_wrong_password
+{
+	BYTE bHeader;
+} TPacketGCSafeboxWrongPassword;
+
+typedef struct packet_safebox_size
+{
+	BYTE bHeader;
+	BYTE bSize;
+} TPacketGCSafeboxSize;
+
+typedef struct packet_safebox_money_change
+{
+	BYTE bHeader;
+	DWORD dwMoney;
+} TPacketGCSafeboxMoneyChange;
+
+typedef struct command_empire
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+} TPacketCGEmpire;
+
+typedef struct packet_empire
+{
+	BYTE bHeader;
+	BYTE bEmpire;
+} TPacketGCEmpire;
+
+enum
+{
+	FISHING_SUBHEADER_GC_START,
+	FISHING_SUBHEADER_GC_STOP,
+	FISHING_SUBHEADER_GC_REACT,
+	FISHING_SUBHEADER_GC_SUCCESS,
+	FISHING_SUBHEADER_GC_FAIL,
+	FISHING_SUBHEADER_GC_FISH,
+};
+
+typedef struct packet_fishing
+{
+	BYTE header;
+	BYTE subheader;
+	DWORD info;
+	BYTE dir;
+} TPacketGCFishing;
+
+typedef struct paryt_parameter
+{
+	BYTE bHeader;
+	BYTE bDistributeMode;
+} TPacketGCPartyParameter;
+
+//////////////////////////////////////////////////////////////////////////
+// Guild
+
+enum
+{
+	GUILD_SUBHEADER_GC_LOGIN,
+	GUILD_SUBHEADER_GC_LOGOUT,
+	GUILD_SUBHEADER_GC_LIST,
+	GUILD_SUBHEADER_GC_GRADE,
+	GUILD_SUBHEADER_GC_ADD,
+	GUILD_SUBHEADER_GC_REMOVE,
+	GUILD_SUBHEADER_GC_GRADE_NAME,
+	GUILD_SUBHEADER_GC_GRADE_AUTH,
+	GUILD_SUBHEADER_GC_INFO,
+	GUILD_SUBHEADER_GC_COMMENTS,
+	GUILD_SUBHEADER_GC_CHANGE_EXP,
+	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GRADE,
+	GUILD_SUBHEADER_GC_SKILL_INFO,
+	GUILD_SUBHEADER_GC_CHANGE_MEMBER_GENERAL,
+	GUILD_SUBHEADER_GC_GUILD_INVITE,
+	GUILD_SUBHEADER_GC_WAR,
+	GUILD_SUBHEADER_GC_GUILD_NAME,
+	GUILD_SUBHEADER_GC_GUILD_WAR_LIST,
+	GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST,
+	GUILD_SUBHEADER_GC_WAR_POINT,
+	GUILD_SUBHEADER_GC_MONEY_CHANGE,
+};
+
+typedef struct packet_guild
+{
+	BYTE header;
+	WORD size;
+	BYTE subheader;
+} TPacketGCGuild;
+
+// SubHeader - Grade
+enum
+{
+	GUILD_AUTH_ADD_MEMBER = (1 << 0),
+	GUILD_AUTH_REMOVE_MEMBER = (1 << 1),
+	GUILD_AUTH_NOTICE = (1 << 2),
+	GUILD_AUTH_SKILL = (1 << 3),
+};
+
+typedef struct packet_guild_sub_grade
+{
+	char grade_name[GUILD_GRADE_NAME_MAX_LEN + 1]; // 8+1 ,   Ì¸
+	BYTE auth_flag;
+} TPacketGCGuildSubGrade;
+
+typedef struct packet_guild_sub_member
+{
+	DWORD pid;
+	BYTE byGrade;
+	BYTE byIsGeneral;
+	BYTE byJob;
+	BYTE byLevel;
+	DWORD dwOffer;
+	BYTE byNameFlag;
+	//if NameFlag is TRUE, name is sent from server.
+	//	char szName[CHARACTER_ME_MAX_LEN + 1];
+} TPacketGCGuildSubMember;
+
+typedef struct packet_guild_sub_info
+{
+	WORD member_count;
+	WORD max_member_count;
+	DWORD guild_id;
+	DWORD master_pid;
+	DWORD exp;
+	BYTE level;
+	char name[GUILD_NAME_MAX_LEN + 1];
+	DWORD gold;
+	BYTE hasLand;
+} TPacketGCGuildInfo;
+
+enum EGuildWarState
+{
+	GUILD_WAR_NONE,
+	GUILD_WAR_SEND_DECLARE,
+	GUILD_WAR_REFUSE,
+	GUILD_WAR_RECV_DECLARE,
+	GUILD_WAR_WAIT_START,
+	GUILD_WAR_CANCEL,
+	GUILD_WAR_ON_WAR,
+	GUILD_WAR_END,
+
+	GUILD_WAR_DURATION = 2 * 60 * 60, // 2Ã°
+};
+
+typedef struct packet_guild_war
+{
+	DWORD dwGuildSelf;
+	DWORD dwGuildOpp;
+	BYTE bType;
+	BYTE bWarState;
+} TPacketGCGuildWar;
+
+typedef struct SPacketGuildWarPoint
+{
+	DWORD dwGainGuildID;
+	DWORD dwOpponentGuildID;
+	long lPoint;
+} TPacketGuildWarPoint;
+
+// SubHeader - Dungeon
+enum
+{
+	DUNGEON_SUBHEADER_GC_TIME_ATTACK_START = 0,
+	DUNGEON_SUBHEADER_GC_DESTINATION_POSITION = 1,
+};
+
+typedef struct packet_dungeon
+{
+	BYTE bHeader;
+	WORD size;
+	BYTE subheader;
+} TPacketGCDungeon;
+
+// Private Shop
+typedef struct SPacketGCShopSign
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	char szSign[SHOP_SIGN_MAX_LEN + 1];
+#if defined(ENABLE_MYSHOP_DECO)
+	BYTE bType;
+#endif
+} TPacketGCShopSign;
+
+typedef struct SPacketGCTime
+{
+	BYTE bHeader;
+	time_t time;
+} TPacketGCTime;
+
+enum
+{
+	WALKMODE_RUN,
+	WALKMODE_WALK,
+};
+
+typedef struct SPacketGCWalkMode
+{
+	BYTE header;
+	DWORD vid;
+	BYTE mode;
+} TPacketGCWalkMode;
+
+typedef struct SPacketGCChangeSkillGroup
+{
+	BYTE header;
+	BYTE skill_group;
+} TPacketGCChangeSkillGroup;
+
+struct TMaterial
+{
+	DWORD vnum;
+	DWORD count;
+};
+
+typedef struct SRefineTable
+{
+	DWORD src_vnum;
+	DWORD result_vnum;
+	WORD material_count;
+	int cost; // Ò¿ 
+	int prob; // È®
+	TMaterial materials[REFINE_MATERIAL_MAX_NUM];
+} TRefineTable;
+
+typedef struct SPacketGCRefineInformation
+{
+	BYTE header;
+	BYTE pos;
+	TRefineTable refine_table;
+} TPacketGCRefineInformation;
+
+typedef struct SPacketGCRefineInformationNew
+{
+	BYTE header;
+	BYTE type;
+	BYTE pos;
+	TRefineTable refine_table;
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
+#endif
+} TPacketGCRefineInformationNew;
+
+enum SPECIAL_EFFECT
+{
+	SE_NONE,
+
+	SE_HPUP_RED,
+	SE_SPUP_BLUE,
+	SE_SPEEDUP_GREEN,
+	SE_DXUP_PURPLE,
+	SE_CRITICAL,
+	SE_PENETRATE,
+	SE_BLOCK,
+	SE_DODGE,
+	SE_CHINA_FIREWORK,
+	SE_SPIN_TOP,
+	SE_SUCCESS,
+	SE_FAIL,
+	SE_FR_SUCCESS,
+	SE_LEVELUP_ON_14_FOR_GERMANY, // 14Ï¶ (  )
+	SE_LEVELUP_UNDER_15_FOR_GERMANY, // 15Ï¶ (  )
+	SE_PERCENT_DAMAGE1,
+	SE_PERCENT_DAMAGE2,
+	SE_PERCENT_DAMAGE3,
+
+	SE_AUTO_HPUP,
+	SE_AUTO_SPUP,
+
+	SE_EQUIP_RAMADAN_RING, // Ê½Â´  Ï´  ßµÏ´ Æ®
+	SE_EQUIP_HALLOWEEN_CANDY, // Ò·  (-_-;)  ßµÏ´ Æ®
+	SE_EQUIP_HAPPINESS_RING, // Å© àº¹  Ï´  ßµÏ´ Æ®
+	SE_EQUIP_LOVE_PENDANT, // ß·Å¸  Ò´Æ®(71145)   Æ® (ßµÆ®, Æ® Æ´)
+
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+	SE_ACCE_SUCESS_ABSORB,
+	SE_ACCE_EQUIP,
+	SE_ACCE_BACK,
+#endif
+
+	SE_EQUIP_EASTER_CANDY,
+
+	SE_THUNDER_AREA,
+	SE_THUNDER,
+	SE_HEAL,
+
+	SE_CAPE_OF_COURAGE,
+	SE_EQUIP_CHOCOLATE_PENDANT,
+#if defined(ENABLE_BALANCE_IMPROVING)
+	SE_FEATHER_WALK,
+#endif
+	SE_PEPSI_EVENT,
+
+#if defined(ENABLE_GUILD_DRAGONLAIR_SYSTEM)
+	SE_DRAGONLAIR_STONE_UNBEATABLE_1,
+	SE_DRAGONLAIR_STONE_UNBEATABLE_2,
+	SE_DRAGONLAIR_STONE_UNBEATABLE_3,
+#endif
+
+	SE_BATTLE_POTION, // Battle Field
+	SE_REFLECT, // AI_FLAG_REFLECT
+
+	SE_SKILL_DAMAGE_ZONE,
+	SE_SKILL_SAFE_ZONE,
+	SE_METEOR,
+	SE_BEAD_RAIN,
+	SE_ARROW_RAIN,
+	SE_FALL_ROCK,
+	SE_HORSE_DROP,
+	SE_EGG_DROP,
+	SE_DEAPO_BOOM,
+
+#if defined(ENABLE_FLOWER_EVENT)
+	SE_FLOWER_EVENT,
+#endif
+#if defined(ENABLE_GEM_SYSTEM)
+	SE_GEM_PENDANT,
+#endif
+#if defined(ENABLE_DEFENSE_WAVE)
+	SE_DEFENSE_WAVE_LASER,
+#endif
+	SE_PET_ATTR_CHANGE_NEW_TYPE,
+	SE_PET_PAY_SUMMON1,
+#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
+	SE_SPECIAL_ROULETTE,
+#endif
+	SE_MISTS_ISLAND_0,
+	SE_MISTS_ISLAND_1,
+	SE_MISTS_ISLAND_2,
+	SE_MISTS_ISLAND_3,
+	SE_PASSIVE_ATTR_SKILL,
+	SE_SUICIDE_BOMB_SMALL,
+	SE_SUICIDE_BOMB_LARGE,
+	SE_GROUND_THORN,
+	SE_GROUND_SNAKE,
+	SE_WHITE_DRAGON_BERSERK,
+	SE_WHITE_DRAGON_COOLING,
+	SE_USE_METINSTONE_RAIN_SPAWN_TICKET,
+	SE_FAKE_METINSTONE_SPLASH_DAMAGE,
+	SE_MOUNT_UPGRADE_SKILL,
+	SE_SOUTH_REAPER_SKILL_2,
+	SE_YEOMWANG_SKILL_2,
+	SE_BUFF_ITEM_5,
+	SE_BUFF_ITEM_13,
+	SE_BUFF_ITEM_14,
+	SE_BUFF_SYMBOL1,
+	SE_BUFF_ITEM_8_ELEMENT_1,
+	SE_BUFF_ITEM_8_ELEMENT_2,
+	SE_BUFF_FLOWER_OF_GALE,
+	SE_BUFF_FLOWER_OF_DESTRUCTION,
+	SE_SUNGMAHEE_GATE_FLOWER_BLOW_RANGE,
+	SE_SUNGMAHEE_GATE_INVINCIBLE_GATE,
+	SE_SUNGMAHEE_GATE_NORMAL_GATE,
+	SE_MOUNT_UPGRADE_GYEONGGONG,
+#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
+	SE_USE_SNOWFLAKE_STICK,
+#endif
+	SE_SPORTS_MATCH_BUFF_EMBLEM,
+	SE_POINT_AREA_ELECT_ATTACK,
+#ifdef ENABLE_QUEEN_NETHIS
+	SE_EFFECT_SNAKE_REGEN,
+#endif
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+	SE_EFFECT_BP_NORMAL_MISSION_COMPLETED,
+	SE_EFFECT_BP_PREMIUM_MISSION_COMPLETED,
+	SE_EFFECT_BP_EVENT_MISSION_COMPLETED,
+	SE_EFFECT_BP_NORMAL_BATTLEPASS_COMPLETED,
+	SE_EFFECT_BP_PREMIUM_BATTLEPASS_COMPLETED,
+	SE_EFFECT_BP_EVENT_BATTLEPASS_COMPLETED,
+#endif
+#ifdef ENABLE_GROWTH_PET_SYSTEM
+	SE_GYEONGGONG_BOOM,
+#endif
+};
+
+enum ESpecialEffectType
+{
+	SE_TYPE_NORMAL,
+	SE_TYPE_POSITION,
+};
+
+typedef struct SPacketGCSpecialEffect
+{
+	BYTE bHeader;
+	BYTE bEffectNum;
+	DWORD dwVID;
+	BYTE bEffectType;
+	long xEffectPos, yEffectPos;
+} TPacketGCSpecialEffect;
+
+typedef struct SPacketGCNPCPosition
+{
+	BYTE header;
+	WORD size;
+	WORD count;
+} TPacketGCNPCPosition;
+
+struct TNPCPosition
+{
+	BYTE bType;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+	long x;
+	long y;
+};
+
+typedef struct SPacketGCChangeName
+{
+	BYTE header;
+	DWORD pid;
+	char name[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGCChangeName;
+
+enum EBlockAction
+{
+	BLOCK_EXCHANGE = (1 << 0),
+	BLOCK_PARTY_INVITE = (1 << 1),
+	BLOCK_GUILD_INVITE = (1 << 2),
+	BLOCK_WHISPER = (1 << 3),
+	BLOCK_MESSENGER_INVITE = (1 << 4),
+	BLOCK_PARTY_REQUEST = (1 << 5),
+};
+
+typedef struct packet_login_key
+{
+	BYTE bHeader;
+	DWORD dwLoginKey;
+} TPacketGCLoginKey;
+
+typedef struct packet_auth_success
+{
+	BYTE bHeader;
+	DWORD dwLoginKey;
+	BYTE bResult;
+} TPacketGCAuthSuccess;
+
+typedef struct packet_channel
+{
+	BYTE header;
+	BYTE channel;
+} TPacketGCChannel;
+
+typedef struct SEquipmentItemSet
+{
+	DWORD dwVnum;
+	BYTE bCount;
+	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+	DWORD dwTransmutationVnum;
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
+#endif
+#if defined(ENABLE_SET_ITEM)
+	BYTE bSetValue;
+#endif
+} TEquipmentItemSet;
+
+typedef struct pakcet_view_equip
+{
+	BYTE bHeader;
+	DWORD dwVID;
+	TEquipmentItemSet Equips[WEAR_MAX_NUM];
+} TPacketGCViewEquip;
+
+typedef struct
+{
+	DWORD dwID;
+	long x, y;
+	long width, height;
+	DWORD dwGuildID;
+} TLandPacketElement;
+
+typedef struct packet_land_list
+{
+	BYTE header;
+	WORD size;
+} TPacketGCLandList;
+
+typedef struct
+{
+	BYTE bHeader;
+	long lID;
+	char szTargetName[32 + 1];
+} TPacketGCTargetCreate;
+
+enum
+{
+	CREATE_TARGET_TYPE_NONE,
+	CREATE_TARGET_TYPE_LOCATION,
+	CREATE_TARGET_TYPE_CHARACTER,
+};
+
+typedef struct
+{
+	BYTE bHeader;
+	long lID;
+	char szTargetName[32 + 1];
+	DWORD dwVID;
+	BYTE byType;
+} TPacketGCTargetCreateNew;
+
+typedef struct
+{
+	BYTE bHeader;
+	long lID;
+	long lX, lY;
+} TPacketGCTargetUpdate;
+
+typedef struct
+{
+	BYTE bHeader;
+	long lID;
+} TPacketGCTargetDelete;
+
+typedef struct
+{
+	DWORD dwType;
+	POINT_TYPE wApplyOn;
+	POINT_VALUE lApplyValue;
+	DWORD dwFlag;
+	long lDuration;
+	long lSPCost;
+#if defined(ENABLE_AFFECT_RENEWAL)
+	bool bRealTime;
+	bool bUpdate;
+#endif
+} TPacketAffectElement;
+
+typedef struct
+{
+	BYTE bHeader;
+	TPacketAffectElement elem;
+} TPacketGCAffectAdd;
+
+typedef struct
+{
+	BYTE bHeader;
+	DWORD dwType;
+	POINT_TYPE wApplyOn;
+} TPacketGCAffectRemove;
+
+typedef struct packet_mall_open
+{
+	BYTE bHeader;
+	BYTE bSize;
+} TPacketGCMallOpen;
+
+typedef struct packet_lover_info
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	BYTE byLovePoint;
+} TPacketGCLoverInfo;
+
+typedef struct packet_love_point_update
+{
+	BYTE bHeader;
+	BYTE byLovePoint;
+} TPacketGCLovePointUpdate;
+
+typedef struct packet_dig_motion
+{
+	BYTE header;
+	DWORD vid;
+	DWORD target_vid;
+	BYTE count;
+} TPacketGCDigMotion;
+
+typedef struct SPacketGCOnTime
+{
+	BYTE header;
+	int ontime; // sec
+} TPacketGCOnTime;
+
+typedef struct SPacketGCResetOnTime
+{
+	BYTE header;
+} TPacketGCResetOnTime;
+
+typedef struct SPacketGCPanamaPack
+{
+	BYTE bHeader;
+	char szPackName[256];
+	BYTE abIV[32];
+} TPacketGCPanamaPack;
+
+typedef struct SPacketGCHybridCryptKeys
+{
+private:
+	SPacketGCHybridCryptKeys() : m_pStream(NULL) {}
+
+public:
+	SPacketGCHybridCryptKeys(int iStreamSize) : iKeyStreamLen(iStreamSize)
+	{
+		m_pStream = new BYTE[iStreamSize];
+	}
+	~SPacketGCHybridCryptKeys()
+	{
+		if (m_pStream)
+		{
+			delete[] m_pStream;
+			m_pStream = NULL;
+		}
+	}
+	static int GetFixedHeaderSize()
+	{
+		return sizeof(BYTE) + sizeof(WORD) + sizeof(int);
+	}
+
+	BYTE bHeader;
+	WORD wDynamicPacketSize;
+	int iKeyStreamLen;
+	BYTE* m_pStream;
+
+} TPacketGCHybridCryptKeys;
+
+typedef struct SPacketGCHybridSDB
+{
+private:
+	SPacketGCHybridSDB() : m_pStream(NULL) {}
+
+public:
+	SPacketGCHybridSDB(int iStreamSize) : iSDBStreamLen(iStreamSize)
+	{
+		m_pStream = new BYTE[iStreamSize];
+	}
+	~SPacketGCHybridSDB()
+	{
+		delete[] m_pStream;
+		m_pStream = NULL;
+	}
+	static int GetFixedHeaderSize()
+	{
+		return sizeof(BYTE) + sizeof(WORD) + sizeof(int);
+	}
+
+	BYTE bHeader;
+	WORD wDynamicPacketSize;
+	int iSDBStreamLen;
+	BYTE* m_pStream;
+
+} TPacketGCHybridSDB;
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+// Client To Client
+
+typedef struct packet_state
+{
+	BYTE bHeader;
+	BYTE bFunc;
+	BYTE bArg;
+	BYTE bRot;
+	DWORD dwVID;
+	DWORD dwTime;
+	TPixelPosition kPPos;
+} TPacketCCState;
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+struct TPacketKeyAgreement
+{
+	static const int MAX_DATA_LEN = 256;
+	BYTE bHeader;
+	WORD wAgreedLength;
+	WORD wDataLength;
+	BYTE data[MAX_DATA_LEN];
+};
+
+struct TPacketKeyAgreementCompleted
+{
+	BYTE bHeader;
+	BYTE data[3]; // dummy (not used)
+};
+#endif
+
+typedef struct SPacketGCSpecificEffect
+{
+	BYTE header;
+	DWORD vid;
+	char effect_file[128];
+} TPacketGCSpecificEffect;
+
+#if defined(ENABLE_DRAGON_SOUL_SYSTEM)
+// È¥
+enum EDragonSoulRefineWindowRefineType
+{
+	DragonSoulRefineWindow_UPGRADE,
+	DragonSoulRefineWindow_IMPROVEMENT,
+	DragonSoulRefineWindow_REFINE,
+};
+
+enum EPacketCGDragonSoulSubHeaderType
+{
+	DS_SUB_HEADER_OPEN,
+	DS_SUB_HEADER_CLOSE,
+	DS_SUB_HEADER_DO_UPGRADE,
+	DS_SUB_HEADER_DO_IMPROVEMENT,
+	DS_SUB_HEADER_DO_REFINE,
+	DS_SUB_HEADER_REFINE_FAIL,
+	DS_SUB_HEADER_REFINE_FAIL_MAX_REFINE,
+	DS_SUB_HEADER_REFINE_FAIL_INVALID_MATERIAL,
+	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MONEY,
+	DS_SUB_HEADER_REFINE_FAIL_NOT_ENOUGH_MATERIAL,
+	DS_SUB_HEADER_REFINE_FAIL_TOO_MUCH_MATERIAL,
+	DS_SUB_HEADER_REFINE_SUCCEED,
+#if defined(ENABLE_DS_CHANGE_ATTR)
+	DS_SUB_HEADER_OPEN_CHANGE_ATTR,
+	DS_SUB_HEADER_DO_CHANGE_ATTR,
+#endif
+};
+
+typedef struct SPacketCGDragonSoulRefine
+{
+	SPacketCGDragonSoulRefine() : header(HEADER_CG_DRAGON_SOUL_REFINE) {}
+	BYTE header;
+	BYTE bSubType;
+	TItemPos ItemGrid[DS_REFINE_WINDOW_MAX_NUM];
+} TPacketCGDragonSoulRefine;
+
+typedef struct SPacketGCDragonSoulRefine
+{
+	SPacketGCDragonSoulRefine() : header(HEADER_GC_DRAGON_SOUL_REFINE) {}
+	BYTE header;
+	BYTE bSubType;
+	TItemPos Pos;
+} TPacketGCDragonSoulRefine;
+#endif
+
+typedef struct SChannelStatus
+{
+	short nPort;
+	BYTE bStatus;
+} TChannelStatus;
+
+#if defined(ENABLE_MINI_GAME_CATCH_KING)
+enum EMiniGameCatchKingCGSubHeader
+{
+	CATCHKING_CG_START,
+	CATCHKING_CG_CLICK_HAND,
+	CATCHKING_CG_CLICK_CARD,
+	CATCHKING_CG_REWARD,
+#if defined(ENABLE_CATCH_KING_EVENT_FLAG_RENEWAL)
+	CATCHKING_CG_REQUEST_QUEST_FLAG,
+#endif
+};
+
+enum EMiniGameCatchKingGCSubHeader
+{
+	CATCHKING_GC_START,
+	CATCHKING_GC_SET_CARD,
+	CATCHKING_GC_RESULT_FIELD,
+	CATCHKING_GC_SET_END_CARD,
+	CATCHKING_GC_REWARD,
+#if defined(ENABLE_CATCH_KING_EVENT_FLAG_RENEWAL)
+	CATCHKING_GC_SET_CARD_PIECE_FLAG,
+	CATCHKING_GC_SET_CARD_FLAG,
+	CATCHKING_GC_SET_QUEST_FLAG,
+	CATCHKING_GC_NO_MORE_GAIN,
+#endif
+};
+
+typedef struct SPacketCGMiniGameCatchKing
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSubArgument;
+} TPacketCGMiniGameCatchKing;
+
+typedef struct SPacketGCMiniGameCatchKing
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMiniGameCatchKing;
+
+typedef struct SPacketGCCatchKingEventInfo
+{
+	BYTE bHeader;
+	bool bIsEnable;
+} TPacketGCCatchKingEventInfo;
+
+typedef struct SPacketGCMiniGameCatchKingResult
+{
+	DWORD dwPoints;
+	BYTE bRowType;
+	BYTE bCardPos;
+	BYTE bCardValue;
+	bool bKeepFieldCard;
+	bool bDestroyHandCard;
+	bool bGetReward;
+	bool bIsFiveNearBy;
+} TPacketGCMiniGameCatchKingResult;
+
+typedef struct SPacketGCMiniGameCatchKingSetEndCard
+{
+	BYTE bCardPos;
+	BYTE bCardValue;
+} TPacketGCMiniGameCatchKingSetEndCard;
+
+#if defined(ENABLE_CATCH_KING_EVENT_FLAG_RENEWAL)
+typedef struct SPacketGCMiniGameCatchKingQuestFlag
+{
+	WORD wPieceCount, wPackCount;
+} TPacketGCMiniGameCatchKingQuestFlag;
+#endif
+#endif
+
+#if defined(ENABLE_SKILLBOOK_COMB_SYSTEM)
+typedef struct SPacketCGSkillBookCombination
+{
+	BYTE bHeader;
+	BYTE bAction;
+	TItemPos CombItemGrid[SKILLBOOK_COMB_SLOT_MAX];
+} TPacketCGSkillBookCombination;
+#endif
+
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+enum ESubHeaderGCAcceRefine
+{
+	ACCE_REFINE_SUBHEADER_GC_CLOSE,
+	ACCE_REFINE_SUBHEADER_GC_OPEN,
+	ACCE_REFINE_SUBHEADER_GC_SET_ITEM,
+	ACCE_REFINE_SUBHEADER_GC_CLEAR_SLOT,
+	ACCE_REFINE_SUBHEADER_GC_CLEAR_ALL,
+	ACCE_REFINE_SUBHEADER_GC_CLEAR_RIGHT,
+};
+
+typedef struct SSubPacketGCAcceRefineOpenClose
+{
+	BYTE bType;
+	bool bServerClose;
+} TSubPacketGCAcceRefineOpenClose;
+
+typedef struct SSubPacketGCAcceRefineSetItem
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	TItemData Item;
+} TSubPacketGCAcceRefineSetItem;
+
+typedef struct SSubPacketGCAcceRefineClearSlot
+{
+	BYTE bSlotIndex;
+} TSubPacketGCAcceRefineClearSlot;
+
+enum ESubHeaderCGAcceRefine
+{
+	ACCE_REFINE_SUBHEADER_CG_CHECKIN,
+	ACCE_REFINE_SUBHEADER_CG_CHECKOUT,
+	ACCE_REFINE_SUBHEADER_CG_ACCEPT,
+	ACCE_REFINE_SUBHEADER_CG_CANCEL,
+};
+
+typedef struct SSubPacketCGAcceRefineCheckIn
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAcceRefineCheckIn;
+
+typedef struct SSubPacketCGAcceRefineCheckOut
+{
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAcceRefineCheckOut;
+
+typedef struct SSubPacketCGAcceRefineAccept
+{
+	BYTE bType;
+} TSubPacketCGAcceRefineAccept;
+
+typedef struct SPacketGCAcceRefine
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCAcceRefine;
+
+typedef struct SPacketCGAcceRefine
+{
+	SPacketCGAcceRefine() : bHeader(HEADER_CG_ACCE_REFINE) {}
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketCGAcceRefine;
+#endif
+
+#if defined(ENABLE_AURA_COSTUME_SYSTEM)
+enum ESubHeaderGCAuraRefine
+{
+	AURA_REFINE_SUBHEADER_GC_CLOSE,
+	AURA_REFINE_SUBHEADER_GC_OPEN,
+	AURA_REFINE_SUBHEADER_GC_SET_ITEM,
+	AURA_REFINE_SUBHEADER_GC_CLEAR_SLOT,
+	AURA_REFINE_SUBHEADER_GC_CLEAR_ALL,
+	AURA_REFINE_SUBHEADER_GC_INFO
+};
+
+typedef struct SSubPacketGCAuraRefineOpenClose
+{
+	BYTE bType;
+	bool bServerClose;
+} TSubPacketGCAuraRefineOpenClose;
+
+typedef struct SSubPacketGCAuraRefineSetItem
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	TItemData Item;
+} TSubPacketGCAuraRefineSetItem;
+
+typedef struct SSubPacketGCAuraRefineClearSlot
+{
+	BYTE bSlotIndex;
+} TSubPacketGCAuraRefineClearSlot;
+
+typedef struct SSubPacketGCAuraRefineInfo
+{
+	BYTE bInfoType;
+	BYTE bInfoLevel;
+	BYTE bInfoExpPercent;
+} TSubPacketGCAuraRefineInfo;
+
+enum ESubHeaderCGAuraRefine
+{
+	AURA_REFINE_SUBHEADER_CG_CHECKIN,
+	AURA_REFINE_SUBHEADER_CG_CHECKOUT,
+	AURA_REFINE_SUBHEADER_CG_ACCEPT,
+	AURA_REFINE_SUBHEADER_CG_CANCEL
+};
+
+typedef struct SSubPacketCGAuraRefineCheckIn
+{
+	TItemPos AttachedPos;
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAuraRefineCheckIn;
+
+typedef struct SSubPacketCGAuraRefineCheckOut
+{
+	TItemPos SelectedPos;
+	BYTE bType;
+} TSubPacketCGAuraRefineCheckOut;
+
+typedef struct SSubPacketCGAuraRefineAccept
+{
+	BYTE bType;
+} TSubPacketCGAuraRefineAccept;
+
+typedef struct SPacketGCAuraRefine
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCAuraRefine;
+
+typedef struct SPacketCGAuraRefine
+{
+	SPacketCGAuraRefine() : bHeader(HEADER_CG_AURA_REFINE) {}
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketCGAuraRefine;
+#endif
+
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+enum class EPacketCGChangeLookSubHeader : BYTE
+{
+	ITEM_CHECK_IN,
+	ITEM_CHECK_OUT,
+	FREE_ITEM_CHECK_IN,
+	FREE_ITEM_CHECK_OUT,
+	ACCEPT,
+	CANCEL
+};
+
+typedef struct packet_changelook_set
+{
+	BYTE bHeader;
+	WORD wCell;
+	BYTE bSlotIndex;
+} TPacketGCChangeLookSet;
+
+typedef struct packet_changelook_del
+{
+	BYTE bHeader;
+	WORD wCell;
+	BYTE bSlotIndex;
+} TPacketGCChangeLookDel;
+
+typedef struct command_changelook
+{
+	command_changelook(const BYTE c_bSubHeader) :
+		bHeader(HEADER_CG_CHANGE_LOOK),
+		bSubHeader(c_bSubHeader),
+		bSlotIndex(255)
+	{}
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSlotIndex;
+	TItemPos ItemPos;
+} TPacketCGChangeLook;
+#endif
+
+#if defined(ENABLE_MAILBOX)
+typedef struct packet_mailbox_process
+{
+	packet_mailbox_process() : bArg1(0), bArg2(0) {}
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bArg1;
+	BYTE bArg2;
+} TPacketMailboxProcess;
+
+typedef struct SMailBoxRespondUnreadData
+{
+	BYTE bHeader;
+	BYTE bItemMessageCount;
+	BYTE bCommonMessageCount;
+	bool bGMVisible;
+} TMailBoxRespondUnreadData;
+
+typedef struct packet_mailbox_process_all
+{
+	BYTE Index;
+} TPacketGCMailboxProcessAll;
+
+typedef struct packet_mailbox_add_data
+{
+	BYTE bHeader;
+	BYTE Index;
+	char szFrom[CHARACTER_NAME_MAX_LEN + 1];
+	char szMessage[100 + 1];
+	int iYang;
+	int iWon;
+	DWORD dwItemVnum;
+	DWORD dwItemCount;
+	long alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+	DWORD dwChangeLookVnum;
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+	TPlayerItemRefineElement RefineElement;
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
+#endif
+#if defined(ENABLE_SET_ITEM)
+	BYTE bSetValue;
+#endif
+} TPacketGCMailBoxAddData;
+
+typedef struct packet_mailbox_message
+{
+	time_t SendTime;
+	time_t DeleteTime;
+	char szTitle[25 + 1];
+	bool bIsGMPost;
+	bool bIsItemExist;
+	bool bIsConfirm;
+} TPacketGCMailBoxMessage;
+
+typedef struct packet_mailbox
+{
+	BYTE bHeader;
+	WORD wSize;
+} TPacketGCMailBox;
+
+typedef struct packet_mailbox_write
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+	char szTitle[25 + 1];
+	char szMessage[100 + 1];
+	TItemPos pos;
+	int iYang;
+	int iWon;
+} TPacketCGMailboxWrite;
+
+typedef struct packet_mailbox_write_confirm
+{
+	BYTE bHeader;
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketCGMailboxWriteConfirm;
+#endif
+
+#if defined(ENABLE_RANKING_SYSTEM)
+typedef struct SPartyMemberName
+{
+	char szName[CHARACTER_NAME_MAX_LEN + 1];
+} TPartyMember;
+
+typedef struct SRankingData
+{
+	char szGuildName[GUILD_NAME_MAX_LEN + 1];
+	SPartyMemberName Member[PARTY_MAX_MEMBER];
+	DWORD dwRecord0, dwRecord1;
+	DWORD dwStartTime;
+	BYTE bEmpire;
+} TRankingData;
+
+typedef struct SPacketGCRanking
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bType;
+	BYTE bCategory;
+} TPacketGCRanking;
+#endif
+
+#if defined(ENABLE_MOVE_COSTUME_ATTR)
+typedef struct packet_cg_item_combination
+{
+	BYTE Header;
+	short MediumIndex;
+	short BaseIndex;
+	short MaterialIndex;
+} TPacketCGItemCombination;
+
+typedef struct packet_cg_item_combination_cancel
+{
+	BYTE Header;
+} TPacketCGItemCombinationCancel;
+#endif
+
+#if defined(ENABLE_CHANGED_ATTR)
+typedef struct packet_gc_item_select_attr
+{
+	BYTE bHeader;
+	TItemPos pItemPos;
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
+} TPacketGCItemSelectAttr;
+
+typedef struct packet_cg_item_select_attr
+{
+	BYTE bHeader;
+	bool bNew;
+	TItemPos pItemPos;
+} TPacketCGItemSelectAttr;
+#endif
+
+#if defined(ENABLE_LOOTING_SYSTEM)
+typedef struct SPacketCGLootFilter
+{
+	BYTE header;
+	BYTE settings[ELootFilter::LOOT_FILTER_SETTINGS_MAX];
+} TPacketCGLootFilter;
+
+typedef struct SPacketGCLootFilter
+{
+	BYTE header;
+	bool enable;
+	DWORD vid;
+} TPacketGCLootFilter;
+#endif
+
+#if defined(ENABLE_MINI_GAME_RUMI)
+enum EMiniGameRumiCGSubHeader
+{
+	RUMI_CG_SUBHEADER_END,
+	RUMI_CG_SUBHEADER_START,
+	RUMI_CG_SUBHEADER_DECK_CARD_CLICK,
+	RUMI_CG_SUBHEADER_HAND_CARD_CLICK,
+	RUMI_CG_SUBHEADER_FIELD_CARD_CLICK,
+#if defined(ENABLE_OKEY_EVENT_FLAG_RENEWAL)
+	RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
+#endif
+};
+
+enum EMiniGameRumiGCSubHeader
+{
+	RUMI_GC_SUBHEADER_END,
+	RUMI_GC_SUBHEADER_START,
+	RUMI_GC_SUBHEADER_SET_DECK,
+	RUMI_GC_SUBHEADER_SET_SCORE,
+	RUMI_GC_SUBHEADER_MOVE_CARD,
+#if defined(ENABLE_OKEY_EVENT_FLAG_RENEWAL)
+	RUMI_GC_SUBHEADER_SET_CARD_PIECE_FLAG,
+	RUMI_GC_SUBHEADER_SET_CARD_FLAG,
+	RUMI_GC_SUBHEADER_SET_QUEST_FLAG,
+	RUMI_GC_SUBHEADER_NO_MORE_GAIN,
+#endif
+};
+
+typedef struct SPacketCGMiniGameRumi
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BOOL bUseCard;
+	BYTE bIndex;
+	SPacketCGMiniGameRumi() :
+		bHeader(HEADER_CG_MINI_GAME_RUMI),
+		bSubHeader(RUMI_CG_SUBHEADER_END),
+		bUseCard(FALSE),
+		bIndex(0)
+	{}
+} TPacketCGMiniGameRumi;
+
+typedef struct SPacketGCMiniGameRumiSetDeck
+{
+	BYTE bDeckCount;
+} TPacketGCMiniGameRumiSetDeck;
+
+typedef struct SPacketGCMiniGameRumiMoveCard
+{
+	BYTE bSrcPos, bSrcIndex, bSrcColor, bSrcNumber;
+	BYTE bDstPos, bDstIndex, bDstColor, bDstNumber;
+} TPacketGCMiniGameRumiMoveCard;
+
+typedef struct SPacketGCMiniGameRumiSetScore
+{
+	WORD wScore, wTotalScore;
+} TPacketGCMiniGameRumiSetScore;
+
+#if defined(ENABLE_OKEY_EVENT_FLAG_RENEWAL)
+typedef struct SPacketGCMiniGameRumiQuestFlag
+{
+	WORD wCardPieceCount, wCardCount;
+} TPacketGCMiniGameRumiQuestFlag;
+#endif
+
+typedef struct SPacketGCMiniGameRumi
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMiniGameRumi;
+#endif
+
+#if defined(ENABLE_LUCKY_BOX)
+enum ELUCKY_BOX_ACTION
+{
+	LUCKY_BOX_ACTION_RETRY,
+	LUCKY_BOX_ACTION_RECEIVE,
+};
+
+typedef struct SPacketCGLuckyBox
+{
+	BYTE bHeader;
+	BYTE bAction;
+} TPacketCGLuckyBox;
+
+typedef struct SPacketGCLuckyBox
+{
+	BYTE bHeader;
+	DWORD dwVNum;
+	BYTE bCount;
+	int iNeedMoney;
+	WORD wSlotIndex;
+} TPacketGCLuckyBox;
+#endif
+
+#if defined(ENABLE_ATTR_6TH_7TH)
+enum EAttr67AddSubHeader
+{
+	SUBHEADER_CG_ATTR67_ADD_CLOSE,
+	SUBHEADER_CG_ATTR67_ADD_OPEN,
+	SUBHEADER_CG_ATTR67_ADD_REGIST,
+};
+
+typedef struct SPacketCGAttr67Add
+{
+	BYTE byHeader;
+	BYTE bySubHeader;
+	TAttr67AddData Attr67AddData;
+} TPacketCGAttr67Add;
+#endif
+
+#if defined(ENABLE_FISHING_GAME)
+enum EFishingGameSubHeader
+{
+	FISHING_GAME_SUBHEADER_OPEN,
+	FISHING_GAME_SUBHEADER_GOAL,
+	FISHING_GAME_SUBHEADER_QUIT,
+};
+
+typedef struct SPacketGCFishingGame
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bLevel;
+} TPacketGCFishingGame;
+
+typedef struct SPacketCGFishingGame
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bGoals;
+} TPacketCGFishingGame;
+#endif
+
+#if defined(ENABLE_GEM_SYSTEM)
+enum EGemShopSubHeader : BYTE
+{
+	SUBHEADER_GEM_SHOP_CLOSE,
+	SUBHEADER_GEM_SHOP_OPEN,
+	SUBHEADER_GEM_SHOP_BUY,
+	SUBHEADER_GEM_SHOP_SLOT_ADD,
+	SUBHEADER_GEM_SHOP_REFRESH,
+	SUBHEADER_GEM_SHOP_MAX,
+};
+
+typedef struct SPacketGCGemShop
+{
+	BYTE bHeader;
+	WORD wSize;
+} TPacketGCGemShop;
+
+typedef struct SPacketGCGemShopProcess
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSlotIndex;
+	bool bEnable;
+} TPacketGCGemShopProcess;
+
+typedef struct command_gem_shop
+{
+	command_gem_shop(const BYTE c_bSubHeader, const BYTE c_bSlotIndex)
+		: bHeader(HEADER_CG_GEM_SHOP), bSubHeader(c_bSubHeader), bSlotIndex(c_bSlotIndex)
+	{}
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bSlotIndex;
+} TPacketCGGemShop;
+#endif
+
+#if defined(ENABLE_EXTEND_INVEN_SYSTEM)
+typedef struct SPacketCGExtendInven
+{
+	BYTE bHeader;
+	bool bUpgrade;
+	BYTE bIndex;
+} TPacketCGExtendInven;
+
+typedef struct SPacketGCExtendInven
+{
+	BYTE bHeader;
+	BYTE bStage;
+	WORD wMaxNum;
+} TPacketGCExtendInven;
+
+typedef struct SPacketGCExtendInvenItemUse
+{
+	BYTE bHeader;
+	BYTE bMsgResult;
+	BYTE bEnoughCount;
+} TPacketGCExtendInvenItemUse;
+#endif
+
+#if defined(ENABLE_CLIENT_TIMER)
+enum EClientTimerSubHeader
+{
+	CLIENT_TIMER_SUBHEADER_GC_SET,
+	CLIENT_TIMER_SUBHEADER_GC_DELETE
+};
+
+enum EClientTimer
+{
+	ECLIENT_TIMER_END_TIME,
+	ECLIENT_TIMER_ALARM_SECOND,
+	ECLIENT_TIMER_MAX
+};
+
+typedef struct SPacketGCClientTimer
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwData[ECLIENT_TIMER_MAX];
+} TPacketGCClientTimer;
+#endif
+
+enum EEmoteSubHeader
+{
+	SUBHEADER_EMOTE_ADD,
+	SUBHEADER_EMOTE_CLEAR,
+	SUBHEADER_EMOTE_MOTION,
+	SUBHEADER_EMOTE_ICON,
+};
+
+typedef struct SPacketGCEmote
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwEmoteVnum;
+	DWORD dwDuration;
+	DWORD dwMainVID, dwTargetVID;
+} TPacketGCEmote;
+
+#if defined(ENABLE_CUBE_RENEWAL)
+enum ECubeSubHeader
+{
+	SUBHEADER_GC_CUBE_OPEN = 0,
+	SUBHEADER_GC_CUBE_CLOSE,
+	SUBHEADER_GC_CUBE_RESULT,
+
+	SUBHEADER_CG_CUBE_CLOSE = 0,
+	SUBHEADER_CG_CUBE_MAKE,
+};
+
+typedef struct SPacketGCCube
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwNPCVnum;
+	BOOL bSuccess;
+	DWORD dwFileCrc;
+} TPacketGCCube;
+
+typedef struct SPacketCGCube
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	UINT iCubeIndex;
+	UINT iQuantity;
+	INT iImproveItemPos;
+	DWORD dwFileCrc;
+} TPacketCGCube;
+#endif
+
+#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
+enum ESubPacketGCSnowflakeStickEvent
+{
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_SNOW_BALL,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ADD_TREE_BRANCH,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_SNOW_BALL_MAX,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_TREE_BRANCH_MAX,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_STICK_SUCCESS,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_PET_SUCCESS,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EXCHANGE_MOUNT_SUCCESS,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_USE_STICK_FAILED,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_RANK_BUFF,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_GET_SNOWFLAKE_BUFF,
+	SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ENABLE,
+};
+
+enum ESnowflakeStickEventQuestFlagType
+{
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_SNOW_BALL,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_TREE_BRANCH,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK_COOLDOWN,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_PET,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_MOUNT,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_USE_STICK_COOLDOWN,
+	SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM,
+};
+
+typedef struct SPacketGCSnowflakeStickEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	DWORD dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_MAX_NUM];
+} TPacketGCSnowflakeStickEvent;
+
+enum ESubPacketCGSnowflakeStickEvent
+{
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_REQUEST_INFO,
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_STICK,
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_PET,
+	SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_MOUNT
+};
+
+typedef struct SPacketCGSnowflakeStickEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	SPacketCGSnowflakeStickEvent(const BYTE c_bSubHeader)
+		: bHeader(HEADER_CG_SNOWFLAKE_STICK_EVENT), bSubHeader(c_bSubHeader) {}
+} TPacketCGSnowflakeStickEvent;
+#endif
+
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+enum ERefineElementSubHeader
+{
+	REFINE_ELEMENT_GC_OPEN,
+	REFINE_ELEMENT_GC_RESULT
+};
+
+enum EPacketCGRefineElement
+{
+	REFINE_ELEMENT_CG_CLOSE,
+	REFINE_ELEMENT_CG_REFINE,
+};
+
+typedef struct SPacketGCRefineElement
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bRefineType;
+	BYTE bResult;
+	TItemPos SrcPos;
+	TItemPos DestPos;
+} TPacketGCRefineElement;
+
+typedef struct SPacketCGRefineElement
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	WORD wChangeElement;
+	SPacketCGRefineElement(BYTE bSubHeader, WORD wChangeElement)
+		: bHeader(HEADER_CG_REFINE_ELEMENT), bSubHeader(bSubHeader), wChangeElement(wChangeElement) {}
+} TPacketCGRefineElement;
+#endif
+
+#if defined(ENABLE_MINI_GAME_YUTNORI)
+enum EMiniGameYutnoriGCSubHeader
+{
+	YUTNORI_GC_SUBHEADER_START,
+	YUTNORI_GC_SUBHEADER_STOP,
+	YUTNORI_GC_SUBHEADER_SET_PROB,
+	YUTNORI_GC_SUBHEADER_THROW,
+	YUTNORI_GC_SUBHEADER_MOVE,
+	YUTNORI_GC_SUBHEADER_AVAILABLE_AREA,
+	YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT,
+	YUTNORI_GC_SUBHEADER_SET_SCORE,
+	YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT,
+	YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN,
+#if defined(ENABLE_YUTNORI_EVENT_FLAG_RENEWAL)
+	YUTNORI_GC_SUBHEADER_SET_YUT_PIECE_FLAG,
+	YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG,
+	YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG,
+	YUTNORI_GC_SUBHEADER_NO_MORE_GAIN,
+#endif
+};
+
+enum EMiniGameYutnoriCGSubHeader
+{
+	YUTNORI_CG_SUBHEADER_START,
+	YUTNORI_CG_SUBHEADER_GIVEUP,
+	YUTNORI_CG_SUBHEADER_SET_PROB,
+	YUTNORI_CG_SUBHEADER_CLICK_CHAR,
+	YUTNORI_CG_SUBHEADER_THROW,
+	YUTNORI_CG_SUBHEADER_MOVE,
+	YUTNORI_CG_SUBHEADER_REQUEST_COM_ACTION,
+	YUTNORI_CG_SUBHEADER_REWARD,
+#if defined(ENABLE_YUTNORI_EVENT_FLAG_RENEWAL)
+	YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG,
+#endif
+};
+
+typedef struct SPacketCGMiniGameYutnori
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bArgument;
+} TPacketCGMiniGameYutnori;
+
+typedef struct SPacketGCMiniGameYutnori
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+} TPacketGCMiniGameYutnori;
+
+typedef struct SPacketGCMiniGameYutnoriSetProb
+{
+	BYTE bProbIndex;
+} TPacketGCMiniGameYutnoriSetProb;
+
+typedef struct SPacketGCMiniGameYutnoriThrowYut
+{
+	bool bPC;
+	BYTE bYut;
+} TPacketGCMiniGameYutnoriThrowYut;
+
+typedef struct SPacketGCMiniGameYutnoriMoveYut
+{
+	bool bPC;
+	BYTE bUnitIndex;
+	bool bIsCatch;
+	BYTE bStartIndex;
+	BYTE bDestIndex;
+} TPacketGCMiniGameYutnoriMoveYut;
+
+typedef struct SPacketGCMiniGameYutnoriAvailableArea
+{
+	BYTE bPlayerIndex;
+	BYTE bAvailableIndex;
+} TPacketGCMiniGameYutnoriAvailableArea;
+
+typedef struct SPacketGCMiniGameYutnoriPushCatchYut
+{
+	bool bPC;
+	BYTE bUnitIndex;
+} TPacketGCMiniGameYutnoriPushCatchYut;
+
+typedef struct SPacketGCMiniGameYutnoriSetScore
+{
+	WORD wScore;
+} TPacketGCMiniGameYutnoriSetScore;
+
+typedef struct SPacketGCMiniGameYutnoriSetRemainCount
+{
+	BYTE bRemainCount;
+} TPacketGCMiniGameYutnoriSetRemainCount;
+
+typedef struct SPacketGCMiniGameYutnoriPushNextTurn
+{
+	bool bPC;
+	BYTE bState;
+} TPacketGCMiniGameYutnoriPushNextTurn;
+
+#if defined(ENABLE_YUTNORI_EVENT_FLAG_RENEWAL)
+typedef struct SPacketGCMiniGameYutnoriQuestFlag
+{
+	WORD wYutPieceCount;
+	WORD wYutBoardCount;
+} TPacketGCMiniGameYutnoriQuestFlag;
+#endif
+#endif
+
+#if defined(ENABLE_QUEST_REQUEST_EVENT)
+typedef struct SPacketCGRequestEventQuest
+{
+	BYTE bHeader;
+	char szEventQuest[64 + 1];
+} TPacketCGRequestEventQuest;
+#endif
+
+#if defined(ENABLE_LEFT_SEAT)
+enum ELeftSeatCGSubHeader
+{
+	LEFT_SEAT_SET_WAIT_TIME_INDEX,
+	LEFT_SEAT_SET_LOGOUT_TIME_INDEX,
+	LEFT_SEAT_DISABLE_LOGOUT_STATE,
+};
+
+typedef struct SPacketCGLeftSeat
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bIndex;
+} TPacketCGLeftSeat;
+#endif
+
+#if defined(ENABLE_GUILD_DRAGONLAIR_SYSTEM)
+enum EGuildDragonLairType
+{
+	GUILD_DRAGONLAIR_TYPE_RED,
+	GUILD_DRAGONLAIR_TYPE_BLUE,
+	GUILD_DRAGONLAIR_TYPE_GREEN,
+	GUILD_DRAGONLAIR_TYPE_MAX_NUM
+};
+
+enum EGuildDragonLairSubHeader
+{
+	GUILD_DRAGONLAIR_GC_SUBHEADER_RANKING,
+#if defined(ENABLE_GUILD_DRAGONLAIR_PARTY_SYSTEM)
+	GUILD_DRAGONLAIR_GC_SUBHEADER_1ST_GUILD_TEXT,
+	GUILD_DRAGONLAIR_GC_SUBHEADER_START,
+	GUILD_DRAGONLAIR_GC_SUBHEADER_SUCCESS,
+#endif
+};
+
+typedef struct SPacketGCGuildDragonLair
+{
+	BYTE bHeader;
+	WORD wSize;
+	BYTE bSubHeader;
+	BYTE bType;
+#if defined(ENABLE_GUILD_DRAGONLAIR_PARTY_SYSTEM)
+	DWORD dwSeconds;
+#endif
+} TPacketGCGuildDragonLair;
+
+typedef struct SPacketGCGuildDragonLairRanking
+{
+	BYTE bType;
+	DWORD dwGuildID;
+	char szGuildName[GUILD_NAME_MAX_LEN + 1];
+	BYTE bMemberCount;
+	DWORD dwTime;
+} TPacketGCGuildDragonLairRanking;
+#endif
+
+#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
+enum EPacketGCMiniGameRouletteSubHeader
+{
+	ROULETTE_GC_OPEN,
+	ROULETTE_GC_START,
+	ROULETTE_GC_REQUEST,
+	ROULETTE_GC_END,
+	ROULETTE_GC_CLOSE
+};
+
+enum EPacketCGMiniGameRouletteSubHeader
+{
+	ROULETTE_CG_START,
+	ROULETTE_CG_REQUEST,
+	ROULETTE_CG_END,
+	ROULETTE_CG_CLOSE
+};
+
+typedef struct SPacketGCMiniGameRoulette
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bResult;
+	DWORD dwExpireTime;
+	struct
+	{
+		DWORD dwVnum;
+		BYTE bCount;
+	} ItemData[ROULETTE_ITEM_MAX];
+} TPacketGCMiniGameRoulette;
+
+typedef struct SPacketCGMiniGameRoulette
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+} TPacketCGMiniGameRoulette;
+#endif
+
+#if defined(ENABLE_FLOWER_EVENT)
+enum EPacketGCFlowerEvent
+{
+	FLOWER_EVENT_SUBHEADER_GC_INFO_ALL,
+	FLOWER_EVENT_SUBHEADER_GC_GET_INFO,
+	FLOWER_EVENT_SUBHEADER_GC_UPDATE_INFO
+};
+
+typedef struct SPacketGCFlowerEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bChatType;
+	BYTE bShootType;
+	int aiShootCount[SHOOT_TYPE_MAX + 1];
+} TPacketGCFlowerEvent;
+
+enum EPacketCGFlowerEvent
+{
+	FLOWER_EVENT_SUBHEADER_CG_INFO_ALL,
+	FLOWER_EVENT_SUBHEADER_CG_EXCHANGE
+};
+
+typedef struct SPacketCGFlowerEvent
+{
+	BYTE bHeader;
+	BYTE bSubHeader;
+	BYTE bShootType;
+	BYTE bExchangeKey;
+	SPacketCGFlowerEvent()
+		: bHeader(HEADER_CG_FLOWER_EVENT)
+		, bSubHeader(FLOWER_EVENT_SUBHEADER_CG_INFO_ALL)
+		, bShootType(SHOOT_TYPE_MAX)
+		, bExchangeKey(0)
+	{}
+} TPacketCGFlowerEvent;
+#endif
+
+#ifdef ENABLE_SHOP_SEARCH
+typedef std::pair<uint32_t, uint16_t> TShopSearchItemID;
+
+enum EShopSearchData {
+	SHOPSEARCH_ITEM_SUBTYPE_MAX_VALUE = 13,
+	SHOPSEARCH_SOLD_ITEM_INFO_COUNT = 30,
+
+	SHOPSEARCH_BUY_SUCCESS = 0,
+	SHOPSEARCH_BUY_NOT_EXIST,
+	SHOPSEARCH_BUY_PRICE_CHANGE,
+	SHOPSEARCH_BUY_TIMEOUT,
+	SHOPSEARCH_BUY_NO_PEER,
+	SHOPSEARCH_BUY_UNKNOWN_ERROR,
+
+	SHOPSEARCH_SORT_RANDOM = 0,
+	SHOPSEARCH_SORT_ASC,
+	SHOPSEARCH_SORT_DESC,
+	SHOPSEARCH_SORT_MAX_NUM,
+};
+
+enum EShopSearchAveragePriceLevels {
+	SHOPSEARCH_AVG_PRICE_GOOD,
+	SHOPSEARCH_AVG_PRICE_NORMAL,
+	SHOPSEARCH_AVG_PRICE_BAD,
+	SHOPSEARCH_AVG_PRICE_WORST,
+};
+
+typedef struct SShopSearchClientItem
+{
+	DWORD	id;
+	BYTE	window;
+	WORD	pos;
+	DWORD	count;
+
+	DWORD	vnum;
+	long	alSockets[ITEM_SOCKET_SLOT_MAX_NUM];
+
+	TPlayerItemAttribute aAttr[ITEM_ATTRIBUTE_SLOT_MAX_NUM];
+#if defined(ENABLE_APPLY_RANDOM)
+	TPlayerItemAttribute aApplyRandom[ITEM_APPLY_RANDOM_SLOT_MAX_NUM];
+#endif
+	DWORD	owner;
+
+#ifdef ENABLE_SOUL_BIND_SYSTEM
+	long soulbind;
+#endif
+
+	DWORD	transmutate_id;
+
+	TShopSearchItemID offlineID;
+	int64_t price;
+	DWORD endTime;
+
+	BYTE	avgPriceLevel;
+} TShopSearchClientItem;
+
+typedef struct SShopSearchOptions
+{
+	BYTE		typeFlagCount;
+	BYTE		specificVnumCount;
+} TShopSearchOptions;
+
+typedef std::pair<DWORD, DWORD> TShopSearchItemType;
+
+typedef struct SPacketGCShopSearchResult {
+	BYTE	header;
+	WORD	size;
+	WORD	itemCount;
+	WORD	maxPageNum;
+} TPacketGCShopSearchResult;
+
+typedef struct SPacketCGShopSearchByName {
+	BYTE	header;
+	char	itemName[CItemData::ITEM_NAME_MAX_LEN + 1];
+	WORD	page;
+	BYTE	entryCountIdx;
+	BYTE	sortType;
+} TPacketCGShopSearchByName;
+
+typedef struct SPacketCGShopSearchByOptions {
+	BYTE	header;
+	TShopSearchOptions	options;
+	WORD	page;
+	BYTE	entryCountIdx;
+	BYTE	sortType;
+} TPacketCGShopSearchByOptions;
+
+typedef struct SPacketCGShopSearchBuy {
+	BYTE	header;
+	TShopSearchItemID	itemID;
+	DWORD	itemVnum;
+	int64_t	itemPrice;
+} TPacketCGShopSearchBuy;
+
+typedef struct SPacketGCShopSearchBuyResult {
+	BYTE	header;
+	BYTE	result;
+} TPacketGCShopSearchBuyResult;
+
+typedef struct SPacketCGShopSearchOwnerMessage {
+	BYTE	header;
+	DWORD	ownerID;
+} TPacketCGShopSearchOwnerMessage;
+
+typedef struct SPacketGCShopSearchOwnerMessage {
+	BYTE	header;
+	char	ownerName[CHARACTER_NAME_MAX_LEN + 1];
+} TPacketGCShopSearchOwnerMessage;
+
+typedef struct SShopSearchSoldItemInfo {
+	SShopSearchSoldItemInfo() : count(0), averagePrice(0) { }
+
+	uint64_t	count;
+	double		averagePrice;
+} TShopSearchSoldItemInfo;
+
+typedef struct SPacketCGShopSearchRequestSoldInfo {
+	BYTE	header;
+	DWORD	itemVnum;
+} TPacketCGShopSearchRequestSoldInfo;
+
+typedef struct SPacketGCShopSearchSoldInfo {
+	BYTE	header;
+	WORD	size;
+	bool	results;
+} TPacketGCShopSearchSoldInfo;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+typedef struct SPacketCGExtBattlePassAction
+{
+	BYTE bHeader;
+	BYTE bAction;
+} TPacketCGExtBattlePassAction;
+
+typedef struct SPacketCGExtBattlePassSendPremiumItem
+{
+	BYTE bHeader;
+	int iSlotIndex;
+} TPacketCGExtBattlePassSendPremiumItem;
+
+typedef struct SPacketGCExtBattlePassOpen
+{
+	BYTE bHeader;
+} TPacketGCExtBattlePassOpen;
+
+typedef struct SPacketGCExtBattlePassGeneralInfo
+{
+	BYTE bHeader;
+	BYTE bBattlePassType;
+	char	szSeasonName[64+1];
+	DWORD dwBattlePassID;
+	DWORD dwBattlePassStartTime;
+	DWORD dwBattlePassEndTime;
+} TPacketGCExtBattlePassGeneralInfo;
+
+typedef struct SPacketGCExtBattlePassMissionInfo
+{
+	BYTE bHeader;
+	WORD wSize;
+	WORD wRewardSize;
+	BYTE bBattlePassType;
+	DWORD dwBattlePassID;
+} TPacketGCExtBattlePassMissionInfo;
+
+typedef struct SPacketGCExtBattlePassMissionUpdate
+{
+	BYTE bHeader;
+	BYTE bBattlePassType;
+	BYTE bMissionIndex;
+	BYTE bMissionType;
+	DWORD dwNewProgress;
+} TPacketGCExtBattlePassMissionUpdate;
+
+typedef struct SPacketGCExtBattlePassRanking
+{
+	BYTE bHeader;
+	char	szPlayerName[CHARACTER_NAME_MAX_LEN + 1];
+	BYTE bBattlePassType;
+	BYTE	bBattlePassID;
+	DWORD	dwStartTime;
+	DWORD	dwEndTime;
+} TPacketGCExtBattlePassRanking;
+#endif
+
+#ifdef ENABLE_GROWTH_PET_SYSTEM
+enum EGrowthPetPoints
+{
+	POINT_UPBRINGING_PET_LEVEL,
+	POINT_UPBRINGING_PET_EXP,
+	POINT_UPBRINGING_PET_ITEM_EXP,
+	POINT_UPBRINGING_PET_NEXT_EXP,
+	POINT_UPBRINGING_PET_EVOL_LEVEL,
+	POINT_UPBRINGING_PET_HP,
+	POINT_UPBRINGING_PET_DEF_GRADE,
+	POINT_UPBRINGING_PET_SP,
+	POINT_UPBRINGING_DURATION,
+	POINT_UPBRINGING_MAX_DURATION,
+	POINT_UPBRINGING_BIRTHDAY,
+
+	POINT_UPBRINGING_MAX_NUM
+};
+
+enum EGrowthPetSubheader
+{
+	SUBHEADER_PET_EGG_USE_SUCCESS,
+	SUBHEADER_PET_EGG_USE_FAILED_BECAUSE_NAME,
+	SUBHEADER_PET_EGG_USE_FAILED_TIMEOVER,
+	SUBHEADER_PET_UNSUMMON,
+	SUBHEADER_PET_FEED_FAILED,
+	SUBHEADER_PET_FEED_SUCCESS,
+	SUBHEADER_PET_REVIVE_FAILED,
+	SUBHEADER_PET_REVIVE_SUCCESS,
+	SUBHEADER_PET_NAME_CHANGE_FAILED,
+	SUBHEADER_PET_NAME_CHANGE_SUCCESS,
+	SUBHEADER_PET_WINDOW_TYPE_INFO,
+	SUBHEADER_PET_WINDOW_TYPE_ATTR_CHANGE,
+	SUBHEADER_PET_WINDOW_TYPE_PREMIUM_FEED,
+};
+
+enum EGrowthPetWindow
+{
+	PET_WINDOW_HATCH,
+	PET_WINDOW_NAME_CHANGE,
+};
+
+typedef struct SPacketGCPet
+{
+	BYTE	header;
+	BYTE	subheader;
+} TPacketGCPet;
+
+typedef struct SPetSkillPacket
+{
+	bool    bLocked;
+	BYTE    bSkill;
+	BYTE    bLevel;
+	DWORD    dwCooltime;
+} TPetSkillPacket;
+
+typedef struct SPacketGCPetSet
+{
+	BYTE		header;
+	DWORD		dwID;
+	DWORD		dwSummonItemVnum;
+	char		szName[CItemData::PET_NAME_MAX_SIZE + 1];
+	TPetSkillPacket	aSkill[PET_SKILL_COUNT_MAX];
+	DWORD		dwPoints[POINT_UPBRINGING_MAX_NUM];
+} TPacketGCPetSet;
+
+typedef struct SPacketGCPetDelete
+{
+	BYTE		header;
+	DWORD		dwID;
+} TPacketGCPetDelete;
+
+typedef struct SPacketGCPetPointUpdate
+{
+	BYTE	header;
+	DWORD	dwID;
+	BYTE	bPoint;
+	DWORD	dwValue;
+} TPacketGCPetPointUpdate;
+
+typedef struct SPacketGCPetSummon
+{
+	BYTE		header;
+	DWORD		dwID;
+} TPacketGCPetSummon;
+
+typedef struct SPacketGCPetDetermineResult
+{
+	BYTE		header;
+	BYTE		type;
+} TPacketGCPetDetermineResult;
+
+typedef struct SPacketGCPetAttrChangeResult
+{
+	BYTE		header;
+	BYTE		type;
+	TItemPos	pos;
+} TPacketGCPetAttrChangeResult;
+
+typedef struct SPetSkillUpdatePacket
+{
+	bool	bLocked;
+	BYTE	bSkill;
+	BYTE	bLevel;
+	DWORD	dwCooltime;
+	BYTE	bSkillFormula1[PET_GROWTH_SKILL_LEVEL_MAX];
+	WORD	wSkillFormula2[PET_GROWTH_SKILL_LEVEL_MAX];
+	BYTE	bSkillFormula3[PET_GROWTH_SKILL_LEVEL_MAX];
+} TPetSkillUpdatePacket;
+
+typedef struct SPacketGCPetSkillCooltime
+{
+	BYTE		header;
+	DWORD		dwID;
+	BYTE		bSlot;
+	DWORD		dwCooltime;
+} TPacketGCPetSkillCooltime;
+
+typedef struct SPacketGCPetSkillUpdate
+{
+	BYTE		header;
+	DWORD		dwID;
+	TPetSkillUpdatePacket	aSkill[PET_SKILL_COUNT_MAX];
+} TPacketGCPetSkillUpdate;
+
+typedef struct SPacketGCPetNameChangeResult
+{
+	BYTE		header;
+	BYTE		subheader;
+	DWORD		dwID;
+	char		szName[CItemData::PET_NAME_MAX_SIZE + 1];
+} TPacketGCPetNameChangeResult;
+
+typedef struct SPacketCGPetHatch
+{
+	BYTE		header;
+	char		name[CItemData::PET_NAME_MAX_SIZE + 1];
+	TItemPos	eggPos;
+} TPacketCGPetHatch;
+
+typedef struct SPacketCGPetWindow
+{
+	BYTE	header;
+	BYTE	window;
+	bool	state;
+} TPacketCGPetWindow;
+
+typedef struct SPacketCGPetWindowType
+{
+	BYTE	header;
+	BYTE	type;
+} TPacketCGPetWindowType;
+
+typedef struct SPacketCGPeFeed
+{
+	BYTE		header;
+	BYTE		index;
+	WORD		pos[PET_FEED_SLOT_MAX];
+	WORD		count[PET_FEED_SLOT_MAX];
+} TPacketCGPetFeed;
+
+typedef struct SPacketCGPetDetermine
+{
+	BYTE		header;
+	TItemPos	determinePos;
+} TPacketCGPetDetermine;
+
+typedef struct SPacketCGPetAttrChange
+{
+	BYTE		header;
+	TItemPos	upBringingPos;
+	TItemPos	attrChangePos;
+} TPacketCGPetAttrChange;
+
+typedef struct SPacketCGPetRevive
+{
+	BYTE		header;
+	TItemPos	upBringingPos;
+	WORD		pos[PET_REVIVE_MATERIAL_SLOT_MAX];
+	WORD		count[PET_REVIVE_MATERIAL_SLOT_MAX];
+} TPacketCGPetRevive;
+
+typedef struct SPacketCGPetLearnSkill
+{
+	BYTE		header;
+	BYTE		slotIndex;
+	TItemPos	learnSkillPos;
+} TPacketCGPetLearnSkill;
+
+typedef struct SPacketCGPetUpgradeSkill
+{
+	BYTE		header;
+	BYTE		slotIndex;
+} TPacketCGPetSkillUpgrade;
+
+typedef struct SPacketCGPetDeleteSkill
+{
+	BYTE		header;
+	BYTE		slotIndex;
+	TItemPos	deleteSkillPos;
+} TPacketCGPetDeleteSkill;
+
+typedef struct SPacketCGPetAllDeleteSkill
+{
+	BYTE		header;
+	TItemPos	deleteAllSkillPos;
+} TPacketCGPetDeleteAllSkill;
+
+typedef struct SPacketCGPetNameChange
+{
+	BYTE		header;
+	char		name[CItemData::PET_NAME_MAX_SIZE + 1];
+	TItemPos	changeNamePos;
+	TItemPos	upBringingPos;
+} TPacketCGPetNameChange;
+#endif
+
+#pragma pack(pop)
diff --git a/src-client/Client/UserInterface/PythonNetworkStreamPhaseGame.cpp b/src-client/Client/UserInterface/PythonNetworkStreamPhaseGame.cpp
index 7a9fd37..3f7559f 100644
--- a/src-client/Client/UserInterface/PythonNetworkStreamPhaseGame.cpp
+++ b/src-client/Client/UserInterface/PythonNetworkStreamPhaseGame.cpp
@@ -1,8626 +1,8660 @@
-#include "StdAfx.h"
-#include "PythonNetworkStream.h"
-#include "Packet.h"
-
-#include "PythonGuild.h"
-#include "PythonCharacterManager.h"
-#include "PythonPlayer.h"
-#include "PythonBackground.h"
-#include "PythonMiniMap.h"
-#include "PythonTextTail.h"
-#include "PythonItem.h"
-#include "PythonChat.h"
-#include "PythonShop.h"
-#include "PythonExchange.h"
-#include "PythonQuest.h"
-#include "PythonEventManager.h"
-#include "PythonMessenger.h"
-#include "PythonApplication.h"
-#if defined(ENABLE_MAILBOX)
-#	include "PythonMailBox.h"
-#endif
-
-#include "../EterPack/EterPackManager.h"
-#include "../GameLib/ItemManager.h"
-
-#include "AbstractApplication.h"
-#include "AbstractCharacterManager.h"
-#include "InstanceBase.h"
-#if defined(ENABLE_BADGE_NOTIFICATION_MANAGER)
-	#include "BadgeNotificationManager.h"
-#endif
-
-#include "ProcessCRC.h"
-#include "../GameLib/ItemData.h"
-
-#if defined(ENABLE_DISCORD_RPC)
-#include "discord_rpc.h"
-#endif
-
-#ifdef ENABLE_OFFLINE_SHOP
-#include "PythonOfflineShop.h"
-#endif
-
-BOOL gs_bEmpireLanuageEnable = TRUE;
-
-static int64_t StartTime;
-static constexpr auto DiscordClientID = "732229869118685217"; // Change
-
-#if defined(ENABLE_DISCORD_RPC)
-void CPythonNetworkStream::Discord_Start()
-{
-	StartTime = time(0);
-	DiscordEventHandlers handlers;
-	memset(&handlers, 0, sizeof(handlers));
-	Discord_Initialize(DiscordClientID, &handlers, 1, nullptr);
-	Discord_Update(false /* bGameState */);
-}
-
-void CPythonNetworkStream::Discord_Update(const bool bGameState)
-{
-	DiscordRichPresence discordPresence;
-	memset(&discordPresence, 0, sizeof(discordPresence));
-	if (bGameState)
-	{
-		discordPresence.details = CPythonPlayer::Instance().GetName();
-		discordPresence.state = CPythonBackground::Instance().GetWarpMapName();
-
-		discordPresence.startTimestamp = StartTime;
-
-		discordPresence.largeImageKey = "logo";
-		discordPresence.largeImageText = "Farques Development";
-
-		switch (CPythonPlayer::Instance().GetRace())
-		{
-			case MAIN_RACE_WARRIOR_M:
-				discordPresence.smallImageKey = "warrior_m";
-				discordPresence.smallImageText = "Savasci Erkek";
-				break;
-
-			case MAIN_RACE_WARRIOR_W:
-				discordPresence.smallImageKey = "warrior_w";
-				discordPresence.smallImageText = "Savasci Kadin";
-				break;
-
-			case MAIN_RACE_ASSASSIN_M:
-				discordPresence.smallImageKey = "assassin_m";
-				discordPresence.smallImageText = "Ninja Erkek";
-				break;
-
-			case MAIN_RACE_ASSASSIN_W:
-				discordPresence.smallImageKey = "assassin_w";
-				discordPresence.smallImageText = "Ninja Kadin";
-				break;
-
-			case MAIN_RACE_SURA_M:
-				discordPresence.smallImageKey = "sura_m";
-				discordPresence.smallImageText = "Sura Erkek";
-				break;
-
-			case MAIN_RACE_SURA_W:
-				discordPresence.smallImageKey = "sura_w";
-				discordPresence.smallImageText = "Sura Kadin";
-				break;
-
-			case MAIN_RACE_SHAMAN_M:
-				discordPresence.smallImageKey = "shaman_m";
-				discordPresence.smallImageText = "Saman Erkek";
-				break;
-
-			case MAIN_RACE_SHAMAN_W:
-				discordPresence.smallImageKey = "shaman_w";
-				discordPresence.smallImageText = "Saman Kadin";
-				break;
-
-			case MAIN_RACE_WOLFMAN_M:
-				discordPresence.smallImageKey = "wolfman_w";
-				discordPresence.smallImageText = "Wolfman";
-				break;
-
-		}
-	}
-	discordPresence.buttonLabel = "Farques Discord";
-	discordPresence.buttonURL = "https://discord.com/invite/v36Ru9zpJ3";
-	Discord_UpdatePresence(&discordPresence);
-}
-
-void CPythonNetworkStream::Discord_Close()
-{
-	Discord_Shutdown();
-}
-#endif
-
-void CPythonNetworkStream::__RefreshAlignmentWindow()
-{
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshAlignment", Py_BuildValue("()"));
-}
-
-void CPythonNetworkStream::__RefreshTargetBoardByVID(DWORD dwVID)
-{
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshTargetBoardByVID", Py_BuildValue("(i)", dwVID));
-}
-
-void CPythonNetworkStream::__RefreshTargetBoardByName(const char* c_szName)
-{
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshTargetBoardByName", Py_BuildValue("(s)", c_szName));
-}
-
-void CPythonNetworkStream::__RefreshTargetBoard()
-{
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshTargetBoard", Py_BuildValue("()"));
-}
-
-void CPythonNetworkStream::__RefreshGuildWindowGradePage()
-{
-	m_isRefreshGuildWndGradePage = true;
-}
-
-void CPythonNetworkStream::__RefreshGuildWindowSkillPage()
-{
-	m_isRefreshGuildWndSkillPage = true;
-}
-
-void CPythonNetworkStream::__RefreshGuildWindowMemberPageGradeComboBox()
-{
-	m_isRefreshGuildWndMemberPageGradeComboBox = true;
-}
-
-void CPythonNetworkStream::__RefreshGuildWindowMemberPage()
-{
-	m_isRefreshGuildWndMemberPage = true;
-}
-
-void CPythonNetworkStream::__RefreshGuildWindowBoardPage()
-{
-	m_isRefreshGuildWndBoardPage = true;
-}
-
-void CPythonNetworkStream::__RefreshGuildWindowInfoPage()
-{
-	m_isRefreshGuildWndInfoPage = true;
-}
-
-void CPythonNetworkStream::__RefreshMessengerWindow()
-{
-	m_isRefreshMessengerWnd = true;
-}
-
-void CPythonNetworkStream::__RefreshSafeboxWindow()
-{
-	m_isRefreshSafeboxWnd = true;
-}
-
-void CPythonNetworkStream::__RefreshMallWindow()
-{
-	m_isRefreshMallWnd = true;
-}
-
-void CPythonNetworkStream::__RefreshSkillWindow()
-{
-	m_isRefreshSkillWnd = true;
-}
-
-void CPythonNetworkStream::__RefreshExchangeWindow()
-{
-	m_isRefreshExchangeWnd = true;
-}
-
-void CPythonNetworkStream::__RefreshStatus()
-{
-	m_isRefreshStatus = true;
-}
-
-void CPythonNetworkStream::__RefreshCharacterWindow()
-{
-	m_isRefreshCharacterWnd = true;
-}
-
-void CPythonNetworkStream::__RefreshInventoryWindow()
-{
-	m_isRefreshInventoryWnd = true;
-}
-
-void CPythonNetworkStream::__RefreshEquipmentWindow()
-{
-	m_isRefreshEquipmentWnd = true;
-}
-
-void CPythonNetworkStream::__SetGuildID(DWORD id)
-{
-	if (m_dwGuildID != id)
-	{
-		m_dwGuildID = id;
-		IAbstractPlayer& rkPlayer = IAbstractPlayer::GetSingleton();
-
-		for (int i = 0; i < PLAYER_PER_ACCOUNT4; ++i)
-		{
-			if (!strncmp(m_akSimplePlayerInfo[i].szName, rkPlayer.GetName(), CHARACTER_NAME_MAX_LEN))
-			{
-				m_adwGuildID[i] = id;
-
-				std::string guildName;
-				if (CPythonGuild::Instance().GetGuildName(id, &guildName))
-				{
-					m_astrGuildName[i] = guildName;
-				}
-				else
-				{
-					m_astrGuildName[i] = "";
-				}
-			}
-		}
-	}
-}
-
-struct PERF_PacketInfo
-{
-	DWORD dwCount;
-	DWORD dwTime;
-
-	PERF_PacketInfo()
-	{
-		dwCount = 0;
-		dwTime = 0;
-	}
-};
-
-#ifdef __PERFORMANCE_CHECK__
-
-class PERF_PacketTimeAnalyzer
-{
-public:
-	~PERF_PacketTimeAnalyzer()
-	{
-		FILE* fp = fopen("perf_dispatch_packet_result.txt", "w");
-
-		for (std::map<DWORD, PERF_PacketInfo>::iterator i = m_kMap_kPacketInfo.begin(); i != m_kMap_kPacketInfo.end(); ++i)
-		{
-			if (i->second.dwTime > 0)
-				fprintf(fp, "header %d: count %d, time %d, tpc %d\n", i->first, i->second.dwCount, i->second.dwTime, i->second.dwTime / i->second.dwCount);
-		}
-		fclose(fp);
-	}
-
-public:
-	std::map<DWORD, PERF_PacketInfo> m_kMap_kPacketInfo;
-};
-
-PERF_PacketTimeAnalyzer gs_kPacketTimeAnalyzer;
-
-#endif
-
-// Game Phase ---------------------------------------------------------------------------
-void CPythonNetworkStream::GamePhase()
-{
-	if (!m_kQue_stHack.empty())
-	{
-		__SendHack(m_kQue_stHack.front().c_str());
-		m_kQue_stHack.pop_front();
-	}
-
-	TPacketHeader header = 0;
-	bool ret = true;
-
-#ifdef __PERFORMANCE_CHECK__
-	DWORD timeBeginDispatch = timeGetTime();
-
-	static std::map<DWORD, PERF_PacketInfo> kMap_kPacketInfo;
-	kMap_kPacketInfo.clear();
-#endif
-
-#ifdef __DOUBLE_RECV_BUFFER__
-	const DWORD MAX_RECV_COUNT = 4 * 2;
-	const DWORD SAFE_RECV_BUFSIZE = 8192 * 2;
-#else
-	const DWORD MAX_RECV_COUNT = 4;
-	const DWORD SAFE_RECV_BUFSIZE = 8192;
-#endif
-	DWORD dwRecvCount = 0;
-
-	while (ret)
-	{
-		if (dwRecvCount++ >= MAX_RECV_COUNT - 1 && GetRecvBufferSize() < SAFE_RECV_BUFSIZE
-			&& m_strPhase == "Game") // phase_game ÀÌ ¾Æ´Ï¾îµµ ¿©±â·Î µé¾î¿À´Â °æ¿ì°¡ ÀÖ´Ù.
-			break;
-
-		if (!CheckPacket(&header))
-			break;
-
-#ifdef __PERFORMANCE_CHECK__
-		DWORD timeBeginPacket = timeGetTime();
-#endif
-
-		switch (header)
-		{
-			case HEADER_GC_WARP:
-				ret = RecvWarpPacket();
-				break;
-
-			case HEADER_GC_PHASE:
-				ret = RecvPhasePacket();
-				return; // µµÁß¿¡ Phase °¡ ¹Ù²î¸é ÀÏ´Ü ¹«Á¶°Ç GamePhase Å»Ãâ - [levites]
-
-			case HEADER_GC_PVP:
-				ret = RecvPVPPacket();
-				break;
-
-			case HEADER_GC_DUEL_START:
-				ret = RecvDuelStartPacket();
-				break;
-
-			case HEADER_GC_CHARACTER_ADD:
-				ret = RecvCharacterAppendPacket();
-				break;
-
-			case HEADER_GC_CHAR_ADDITIONAL_INFO:
-				ret = RecvCharacterAdditionalInfo();
-				break;
-
-			case HEADER_GC_CHARACTER_UPDATE:
-				ret = RecvCharacterUpdatePacket();
-				break;
-
-			case HEADER_GC_CHARACTER_DEL:
-				ret = RecvCharacterDeletePacket();
-				break;
-
-			case HEADER_GC_CHAT:
-				ret = RecvChatPacket();
-				break;
-
-			case HEADER_GC_SYNC_POSITION:
-				ret = RecvSyncPositionPacket();
-				break;
-
-			case HEADER_GC_OWNERSHIP:
-				ret = RecvOwnerShipPacket();
-				break;
-
-			case HEADER_GC_WHISPER:
-				ret = RecvWhisperPacket();
-				break;
-
-			case HEADER_GC_CHARACTER_MOVE:
-				ret = RecvCharacterMovePacket();
-				break;
-
-				// Position
-			case HEADER_GC_CHARACTER_POSITION:
-				ret = RecvCharacterPositionPacket();
-				break;
-
-				// Battle Packet
-			case HEADER_GC_STUN:
-				ret = RecvStunPacket();
-				break;
-
-			case HEADER_GC_DEAD:
-				ret = RecvDeadPacket();
-				break;
-
-			case HEADER_GC_PLAYER_POINT_CHANGE:
-				ret = RecvPointChange();
-				break;
-
-				// Item packet
-			case HEADER_GC_ITEM_SET_EMPTY:
-				ret = RecvItemSetEmptyPacket();
-				break;
-
-			case HEADER_GC_ITEM_SET:
-				ret = RecvItemSetPacket();
-				break;
-
-			case HEADER_GC_ITEM_USE:
-				ret = RecvItemUsePacket();
-				break;
-
-			case HEADER_GC_ITEM_UPDATE:
-				ret = RecvItemUpdatePacket();
-				break;
-
-			case HEADER_GC_ITEM_GROUND_ADD:
-				ret = RecvItemGroundAddPacket();
-				break;
-
-			case HEADER_GC_ITEM_GROUND_DEL:
-				ret = RecvItemGroundDelPacket();
-				break;
-
-			case HEADER_GC_ITEM_OWNERSHIP:
-				ret = RecvItemOwnership();
-				break;
-
-			case HEADER_GC_QUICKSLOT_ADD:
-				ret = RecvQuickSlotAddPacket();
-				break;
-
-			case HEADER_GC_QUICKSLOT_DEL:
-				ret = RecvQuickSlotDelPacket();
-				break;
-
-			case HEADER_GC_QUICKSLOT_SWAP:
-				ret = RecvQuickSlotMovePacket();
-				break;
-
-			case HEADER_GC_MOTION:
-				ret = RecvMotionPacket();
-				break;
-
-			case HEADER_GC_EMOTE:
-				ret = RecvEmote();
-				break;
-
-			case HEADER_GC_SHOP:
-				ret = RecvShopPacket();
-				break;
-
-			case HEADER_GC_SHOP_SIGN:
-				ret = RecvShopSignPacket();
-				break;
-
-			case HEADER_GC_EXCHANGE:
-				ret = RecvExchangePacket();
-				break;
-
-			case HEADER_GC_QUEST_INFO:
-				ret = RecvQuestInfoPacket();
-				break;
-
-			case HEADER_GC_REQUEST_MAKE_GUILD:
-				ret = RecvRequestMakeGuild();
-				break;
-
-			case HEADER_GC_PING:
-				ret = RecvPingPacket();
-				break;
-
-			case HEADER_GC_SCRIPT:
-				ret = RecvScriptPacket();
-				break;
-
-			case HEADER_GC_QUEST_CONFIRM:
-				ret = RecvQuestConfirmPacket();
-				break;
-
-			case HEADER_GC_TARGET:
-				ret = RecvTargetPacket();
-				break;
-
-			case HEADER_GC_DAMAGE_INFO:
-				ret = RecvDamageInfoPacket();
-				break;
-
-			case HEADER_GC_MOUNT:
-				ret = RecvMountPacket();
-				break;
-
-			case HEADER_GC_CHANGE_SPEED:
-				ret = RecvChangeSpeedPacket();
-				break;
-
-			case HEADER_GC_PLAYER_POINTS:
-				ret = __RecvPlayerPoints();
-				break;
-
-			case HEADER_GC_CREATE_FLY:
-				ret = RecvCreateFlyPacket();
-				break;
-
-			case HEADER_GC_FLY_TARGETING:
-				ret = RecvFlyTargetingPacket();
-				break;
-
-			case HEADER_GC_ADD_FLY_TARGETING:
-				ret = RecvAddFlyTargetingPacket();
-				break;
-
-			case HEADER_GC_SKILL_LEVEL:
-				ret = RecvSkillLevel();
-				break;
-
-			case HEADER_GC_SKILL_LEVEL_NEW:
-				ret = RecvSkillLevelNew();
-				break;
-
-			case HEADER_GC_MESSENGER:
-				ret = RecvMessenger();
-				break;
-
-			case HEADER_GC_GUILD:
-				ret = RecvGuild();
-				break;
-
-			case HEADER_GC_PARTY_INVITE:
-				ret = RecvPartyInvite();
-				break;
-
-			case HEADER_GC_PARTY_ADD:
-				ret = RecvPartyAdd();
-				break;
-
-			case HEADER_GC_PARTY_UPDATE:
-				ret = RecvPartyUpdate();
-				break;
-
-			case HEADER_GC_PARTY_REMOVE:
-				ret = RecvPartyRemove();
-				break;
-
-			case HEADER_GC_PARTY_LINK:
-				ret = RecvPartyLink();
-				break;
-
-			case HEADER_GC_PARTY_UNLINK:
-				ret = RecvPartyUnlink();
-				break;
-
-			case HEADER_GC_PARTY_PARAMETER:
-				ret = RecvPartyParameter();
-				break;
-
-			case HEADER_GC_SAFEBOX_SET:
-				ret = RecvSafeBoxSetPacket();
-				break;
-
-			case HEADER_GC_SAFEBOX_DEL:
-				ret = RecvSafeBoxDelPacket();
-				break;
-
-			case HEADER_GC_SAFEBOX_WRONG_PASSWORD:
-				ret = RecvSafeBoxWrongPasswordPacket();
-				break;
-
-			case HEADER_GC_SAFEBOX_SIZE:
-				ret = RecvSafeBoxSizePacket();
-				break;
-
-			case HEADER_GC_FISHING:
-				ret = RecvFishing();
-				break;
-
-			case HEADER_GC_DUNGEON:
-				ret = RecvDungeon();
-				break;
-
-			case HEADER_GC_TIME:
-				ret = RecvTimePacket();
-				break;
-
-			case HEADER_GC_WALK_MODE:
-				ret = RecvWalkModePacket();
-				break;
-
-			case HEADER_GC_CHANGE_SKILL_GROUP:
-				ret = RecvChangeSkillGroupPacket();
-				break;
-
-			case HEADER_GC_REFINE_INFORMATION:
-				ret = RecvRefineInformationPacket();
-				break;
-
-			case HEADER_GC_REFINE_INFORMATION_NEW:
-				ret = RecvRefineInformationPacketNew();
-				break;
-
-			case HEADER_GC_SEPCIAL_EFFECT:
-				ret = RecvSpecialEffect();
-				break;
-
-			case HEADER_GC_NPC_POSITION:
-				ret = RecvNPCList();
-				break;
-
-			case HEADER_GC_CHANNEL:
-				ret = RecvChannelPacket();
-				break;
-
-			case HEADER_GC_VIEW_EQUIP:
-				ret = RecvViewEquipPacket();
-				break;
-
-			case HEADER_GC_LAND_LIST:
-				ret = RecvLandPacket();
-				break;
-
-				//case HEADER_GC_TARGET_CREATE:
-				//	ret = RecvTargetCreatePacket();
-				//	break;
-
-			case HEADER_GC_TARGET_CREATE_NEW:
-				ret = RecvTargetCreatePacketNew();
-				break;
-
-			case HEADER_GC_TARGET_UPDATE:
-				ret = RecvTargetUpdatePacket();
-				break;
-
-			case HEADER_GC_TARGET_DELETE:
-				ret = RecvTargetDeletePacket();
-				break;
-
-			case HEADER_GC_AFFECT_ADD:
-				ret = RecvAffectAddPacket();
-				break;
-
-			case HEADER_GC_AFFECT_REMOVE:
-				ret = RecvAffectRemovePacket();
-				break;
-
-			case HEADER_GC_MALL_OPEN:
-				ret = RecvMallOpenPacket();
-				break;
-
-			case HEADER_GC_MALL_SET:
-				ret = RecvMallItemSetPacket();
-				break;
-
-			case HEADER_GC_MALL_DEL:
-				ret = RecvMallItemDelPacket();
-				break;
-
-			case HEADER_GC_LOVER_INFO:
-				ret = RecvLoverInfoPacket();
-				break;
-
-			case HEADER_GC_LOVE_POINT_UPDATE:
-				ret = RecvLovePointUpdatePacket();
-				break;
-
-			case HEADER_GC_DIG_MOTION:
-				ret = RecvDigMotionPacket();
-				break;
-
-			case HEADER_GC_HANDSHAKE:
-				RecvHandshakePacket();
-				return;
-
-			case HEADER_GC_HANDSHAKE_OK:
-				RecvHandshakeOKPacket();
-				return;
-
-			case HEADER_GC_HYBRIDCRYPT_KEYS:
-				RecvHybridCryptKeyPacket();
-				return;
-
-			case HEADER_GC_HYBRIDCRYPT_SDB:
-				RecvHybridCryptSDBPacket();
-				return;
-
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-			case HEADER_GC_KEY_AGREEMENT:
-				RecvKeyAgreementPacket();
-				return;
-
-			case HEADER_GC_KEY_AGREEMENT_COMPLETED:
-				RecvKeyAgreementCompletedPacket();
-				return;
-#endif
-
-			case HEADER_GC_SPECIFIC_EFFECT:
-				ret = RecvSpecificEffect();
-				break;
-
-#if defined(ENABLE_DRAGON_SOUL_SYSTEM)
-			case HEADER_GC_DRAGON_SOUL_REFINE:
-				ret = RecvDragonSoulRefine();
-				break;
-#endif
-
-#if defined(ENABLE_SEND_TARGET_INFO)
-			case HEADER_GC_TARGET_INFO:
-				ret = RecvTargetInfoPacket();
-				break;
-#endif
-
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-			case HEADER_GC_ACCE_REFINE:
-				ret = RecvAcceRefinePacket();
-				break;
-#endif
-
-#if defined(ENABLE_AURA_COSTUME_SYSTEM)
-			case HEADER_GC_AURA_REFINE:
-				ret = RecvAuraRefinePacket();
-				break;
-#endif
-
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-			case HEADER_GC_CHANGE_LOOK_SET:
-				ret = RecvChangeLookItemSetPacket();
-				break;
-
-			case HEADER_GC_CHANGE_LOOK_DEL:
-				ret = RecvChangeLookItemDelPacket();
-				break;
-
-			case HEADER_GC_CHANGE_LOOK_FREE_SET:
-				ret = RecvChangeLookFreeItemSetPacket();
-				break;
-
-			case HEADER_GC_CHANGE_LOOK_FREE_DEL:
-				ret = RecvChangeLookFreeItemDelPacket();
-				break;
-#endif
-
-#if defined(ENABLE_MINI_GAME_CATCH_KING)
-			case HEADER_GC_MINI_GAME_CATCH_KING:
-				ret = RecvMiniGameCatchKingPacket();
-				break;
-#endif
-
-#if defined(ENABLE_MAILBOX)
-			case HEADER_GC_MAILBOX_PROCESS:
-				ret = RecvMailboxProcess();
-				break;
-
-			case HEADER_GC_MAILBOX:
-				ret = RecvMailbox();
-				break;
-
-			case HEADER_GC_MAILBOX_ADD_DATA:
-				ret = RecvMailboxAddData();
-				break;
-
-			case HEADER_GC_MAILBOX_ALL:
-				ret = RecvMailboxAll();
-				break;
-
-			case HEADER_GC_MAILBOX_UNREAD:
-				ret = RecvMailboxUnread();
-				break;
-#endif
-
-#ifdef ENABLE_OFFLINE_SHOP
-			case HEADER_GC_OFFLINE_SHOP:
-				ret = CPythonOfflineShop::ReceivePacket();
-				break;
-#endif
-
-#ifdef ENABLE_SHOP_SEARCH
-			case HEADER_GC_SHOP_SEARCH_RESULT:
-				ret = RecvShopSearchResult();
-				break;
-
-			case HEADER_GC_SHOP_SEARCH_BUY_RESULT:
-				ret = RecvShopSearchBuyResult();
-				break;
-
-			case HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE:
-				ret = RecvShopSearchOwnerMessage();
-				break;
-
-			case HEADER_GC_SHOP_SEARCH_SOLD_INFO:
-				ret = RecvShopSearchSoldInfo();
-				break;
-#endif
-
-#ifdef ENABLE_GROWTH_PET_SYSTEM
-			case HEADER_GC_PET:
-				ret = RecvPet();
-				break;
-
-			case HEADER_GC_PET_SET:
-				ret = RecvPetSet();
-				break;
-
-			case HEADER_GC_PET_SET_EXCHANGE:
-				ret = RecvPetSetExchange();
-				break;
-
-			case HEADER_GC_PET_DEL:
-				ret = RecvPetDelete();
-				break;
-
-			case HEADER_GC_PET_SUMMON:
-				ret = RecvPetSummon();
-				break;
-
-			case HEADER_GC_PET_POINT_CHANGE:
-				ret = RecvPetPointChange();
-				break;
-
-			case HEADER_GC_PET_NAME_CHANGE_RESULT:
-				ret = RecvPetNameChangeResult();
-				break;
-
-			case HEADER_GC_PET_SKILL_UPDATE:
-				ret = RecvPetSkillUpdate();
-				break;
-
-			case HEADER_GC_PET_SKILL_COOLTIME:
-				ret = RecvPetSkillCooltime();
-				break;
-
-			case HEADER_GC_PET_DETERMINE_RESULT:
-				ret = RecvPetDetermineResult();
-				break;
-
-			case HEADER_GC_PET_ATTR_CHANGE_RESULT:
-				ret = RecvPetAttrChangeResult();
-				break;
-#endif
-
-#if defined(ENABLE_RANKING_SYSTEM)
-			case HEADER_GC_RANKING:
-				ret = RecvRanking();
-				break;
-#endif
-
-#if defined(ENABLE_CHANGED_ATTR)
-			case HEADER_GC_ITEM_SELECT_ATTR:
-				ret = RecvSelectAttr();
-				break;
-#endif
-
-#if defined(ENABLE_LOOTING_SYSTEM)
-			case HEADER_GC_LOOT_FILTER:
-				ret = RecvLootFilterPacket();
-				break;
-#endif
-
-#if defined(ENABLE_MINI_GAME_RUMI)
-			case HEADER_GC_MINI_GAME_RUMI:
-				ret = RecvMiniGameRumi();
-				break;
-#endif
-
-#if defined(ENABLE_MINI_GAME_YUTNORI)
-			case HEADER_GC_MINI_GAME_YUTNORI:
-				ret = RecvMiniGameYutnori();
-				break;
-#endif
-
-#if defined(ENABLE_LUCKY_BOX)
-			case HEADER_GC_LUCKY_BOX:
-				ret = RecvLuckyBoxPacket();
-				break;
-#endif
-
-#if defined(ENABLE_FISHING_GAME)
-			case HEADER_GC_FISHING_GAME:
-				ret = RecvFishingGamePacket();
-				break;
-#endif
-
-#if defined(ENABLE_GEM_SYSTEM)
-			case HEADER_GC_GEM_SHOP:
-				ret = RecvGemShop();
-				break;
-
-			case HEADER_GC_GEM_SHOP_PROCESS:
-				ret = RecvGemShopProcess();
-				break;
-#endif
-
-#if defined(ENABLE_EXTEND_INVEN_SYSTEM)
-			case HEADER_GC_EXTEND_INVEN:
-				ret = RecvExtendInven();
-				break;
-
-			case HEADER_GC_EXTEND_INVEN_ITEM_USE:
-				ret = RecvExtendInvenItemUse();
-				break;
-#endif
-
-#if defined(ENABLE_CLIENT_TIMER)
-			case HEADER_GC_CLIENT_TIMER:
-				ret = RecvClientTimer();
-				break;
-#endif
-
-#if defined(ENABLE_CUBE_RENEWAL)
-			case HEADER_GC_CUBE:
-				ret = RecvCubePacket();
-				break;
-#endif
-
-#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
-			case HEADER_GC_SNOWFLAKE_STICK_EVENT:
-				ret = RecvSnowflakeStickEventPacket();
-				break;
-#endif
-
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-			case HEADER_GC_REFINE_ELEMENT:
-				ret = RecvRefineElementPacket();
-				break;
-#endif
-
-#if defined(ENABLE_GUILD_DRAGONLAIR_SYSTEM)
-			case HEADER_GC_GUILD_DRAGONLAIR:
-				ret = RecvGuildDragonLairPacket();
-				break;
-#endif
-
-#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
-			case HEADER_GC_MINI_GAME_ROULETTE:
-				ret = RecvMiniGameRoulettePacket();
-				break;
-#endif
-
-#if defined(ENABLE_FLOWER_EVENT)
-			case HEADER_GC_FLOWER_EVENT:
-				ret = RecvFlowerEventPacket();
-				break;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-			case HEADER_GC_EXT_BATTLE_PASS_OPEN:
-				ret = RecvExtBattlePassOpenPacket();
-				break;
-
-			case HEADER_GC_EXT_BATTLE_PASS_GENERAL_INFO:
-				ret = RecvExtBattlePassGeneralInfoPacket();
-				break;
-
-			case HEADER_GC_EXT_BATTLE_PASS_MISSION_INFO:
-				ret = RecvExtBattlePassMissionInfoPacket();
-				break;
-
-			case HEADER_GC_EXT_BATTLE_PASS_MISSION_UPDATE:
-				ret = RecvExtBattlePassMissionUpdatePacket();
-				break;
-
-			case HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING:
-				ret = RecvExtBattlePassRankingPacket();
-				break;
-#endif
-
-			default:
-				ret = RecvDefaultPacket(header);
-				break;
-		}
-
-#ifdef __PERFORMANCE_CHECK__
-		DWORD timeEndPacket = timeGetTime();
-
-		{
-			PERF_PacketInfo& rkPacketInfo = kMap_kPacketInfo[header];
-			rkPacketInfo.dwCount++;
-			rkPacketInfo.dwTime += timeEndPacket - timeBeginPacket;
-		}
-
-		{
-			PERF_PacketInfo& rkPacketInfo = gs_kPacketTimeAnalyzer.m_kMap_kPacketInfo[header];
-			rkPacketInfo.dwCount++;
-			rkPacketInfo.dwTime += timeEndPacket - timeBeginPacket;
-		}
-#endif
-	}
-
-#ifdef __PERFORMANCE_CHECK__
-	DWORD timeEndDispatch = timeGetTime();
-
-	if (timeEndDispatch - timeBeginDispatch > 2)
-	{
-		static FILE* fp = fopen("perf_dispatch_packet.txt", "w");
-
-		fprintf(fp, "delay %d\n", timeEndDispatch - timeBeginDispatch);
-		for (std::map<DWORD, PERF_PacketInfo>::iterator i = kMap_kPacketInfo.begin(); i != kMap_kPacketInfo.end(); ++i)
-		{
-			if (i->second.dwTime > 0)
-				fprintf(fp, "header %d: count %d, time %d\n", i->first, i->second.dwCount, i->second.dwTime);
-		}
-		fputs("=====================================================\n", fp);
-		fflush(fp);
-	}
-#endif
-
-	if (!ret)
-		RecvErrorPacket(header);
-
-	static DWORD s_nextRefreshTime = ELTimer_GetMSec();
-
-	DWORD curTime = ELTimer_GetMSec();
-	if (s_nextRefreshTime > curTime)
-		return;
-
-	if (m_isRefreshCharacterWnd)
-	{
-		m_isRefreshCharacterWnd = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshCharacter", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshEquipmentWnd)
-	{
-		m_isRefreshEquipmentWnd = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshEquipment", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshInventoryWnd)
-	{
-		m_isRefreshInventoryWnd = false;
-
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshInventory", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshExchangeWnd)
-	{
-		m_isRefreshExchangeWnd = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshExchange", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshSkillWnd)
-	{
-		m_isRefreshSkillWnd = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshSkill", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshSafeboxWnd)
-	{
-		m_isRefreshSafeboxWnd = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshSafebox", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshMallWnd)
-	{
-		m_isRefreshMallWnd = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshMall", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshStatus)
-	{
-		m_isRefreshStatus = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshStatus", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshMessengerWnd)
-	{
-		m_isRefreshMessengerWnd = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshMessenger", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshGuildWndInfoPage)
-	{
-		m_isRefreshGuildWndInfoPage = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildInfoPage", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshGuildWndBoardPage)
-	{
-		m_isRefreshGuildWndBoardPage = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildBoardPage", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshGuildWndMemberPage)
-	{
-		m_isRefreshGuildWndMemberPage = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildMemberPage", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshGuildWndMemberPageGradeComboBox)
-	{
-		m_isRefreshGuildWndMemberPageGradeComboBox = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildMemberPageGradeComboBox", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshGuildWndSkillPage)
-	{
-		m_isRefreshGuildWndSkillPage = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildSkillPage", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-
-	if (m_isRefreshGuildWndGradePage)
-	{
-		m_isRefreshGuildWndGradePage = false;
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildGradePage", Py_BuildValue("()"));
-		s_nextRefreshTime = curTime + 300;
-	}
-}
-
-void CPythonNetworkStream::__InitializeGamePhase()
-{
-	__ServerTimeSync_Initialize();
-
-	m_isRefreshStatus = false;
-	m_isRefreshCharacterWnd = false;
-	m_isRefreshEquipmentWnd = false;
-	m_isRefreshInventoryWnd = false;
-	m_isRefreshExchangeWnd = false;
-	m_isRefreshSkillWnd = false;
-	m_isRefreshSafeboxWnd = false;
-	m_isRefreshMallWnd = false;
-	m_isRefreshMessengerWnd = false;
-	m_isRefreshGuildWndInfoPage = false;
-	m_isRefreshGuildWndBoardPage = false;
-	m_isRefreshGuildWndMemberPage = false;
-	m_isRefreshGuildWndMemberPageGradeComboBox = false;
-	m_isRefreshGuildWndSkillPage = false;
-	m_isRefreshGuildWndGradePage = false;
-
-	m_EmoticonTypeVector.clear();
-
-	m_pInstTarget = NULL;
-}
-
-void CPythonNetworkStream::Warp(LONG lGlobalX, LONG lGlobalY)
-{
-	CPythonBackground& rkBgMgr = CPythonBackground::Instance();
-	rkBgMgr.SetShadowLevel(CPythonBackground::SHADOW_NONE);
-	rkBgMgr.Destroy();
-
-	rkBgMgr.Create();
-	rkBgMgr.Warp(lGlobalX, lGlobalY);
-	rkBgMgr.RefreshShadowLevel();
-
-	// NOTE : Warp ÇßÀ»¶§ CenterPositionÀÇ Height°¡ 0ÀÌ±â ¶§¹®¿¡ Ä«¸Þ¶ó°¡ ¶¥¹Ù´Ú¿¡ ¹ÚÇôÀÖ°Ô µÊ
-	// ¿òÁ÷ÀÏ¶§¸¶´Ù Height°¡ °»½Å µÇ±â ¶§¹®ÀÌ¹Ç·Î ¸ÊÀ» ÀÌµ¿ÇÏ¸é PositionÀ» °­Á¦·Î ÇÑ¹ø
-	// ¼ÂÆÃÇØÁØ´Ù - [levites]
-	LONG lLocalX = lGlobalX;
-	LONG lLocalY = lGlobalY;
-	__GlobalPositionToLocalPosition(lLocalX, lLocalY);
-	float fHeight = CPythonBackground::Instance().GetHeight(float(lLocalX), float(lLocalY));
-
-	IAbstractApplication& rkApp = IAbstractApplication::GetSingleton();
-	rkApp.SetCenterPosition(float(lLocalX), float(lLocalY), fHeight);
-
-	__ShowMapName(lLocalX, lLocalY);
-}
-
-void CPythonNetworkStream::__ShowMapName(LONG lLocalX, LONG lLocalY)
-{
-	const std::string& c_rstrMapFileName = CPythonBackground::Instance().GetWarpMapName();
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ShowMapName", Py_BuildValue("(sii)", c_rstrMapFileName.c_str(), lLocalX, lLocalY));
-}
-
-void CPythonNetworkStream::__LeaveGamePhase()
-{
-	CInstanceBase::ClearPVPKeySystem();
-
-	__ClearNetworkActorManager();
-
-	m_bComboSkillFlag = FALSE;
-
-	IAbstractCharacterManager& rkChrMgr = IAbstractCharacterManager::GetSingleton();
-	rkChrMgr.Destroy();
-
-	CPythonItem& rkItemMgr = CPythonItem::Instance();
-	rkItemMgr.Destroy();
-}
-
-void CPythonNetworkStream::SetGamePhase()
-{
-	if ("Game" != m_strPhase)
-		m_phaseLeaveFunc.Run();
-
-	Tracen("");
-	Tracen("## Network - Game Phase ##");
-	Tracen("");
-
-	m_strPhase = "Game";
-
-	m_dwChangingPhaseTime = ELTimer_GetMSec();
-	m_phaseProcessFunc.Set(this, &CPythonNetworkStream::GamePhase);
-	m_phaseLeaveFunc.Set(this, &CPythonNetworkStream::__LeaveGamePhase);
-
-	// Main Character µî·ÏO
-
-	IAbstractPlayer& rkPlayer = IAbstractPlayer::GetSingleton();
-	rkPlayer.SetMainCharacterIndex(GetMainActorVID());
-
-	__RefreshStatus();
-}
-
-#if defined(ENABLE_SEND_TARGET_INFO)
-bool CPythonNetworkStream::SendTargetInfoPacket(DWORD dwVID)
-{
-	TPacketCGTargetInfo TargetInfoPacket;
-	TargetInfoPacket.bHeader = HEADER_CG_TARGET_INFO;
-	TargetInfoPacket.dwVID = dwVID;
-
-	if (!Send(sizeof(TargetInfoPacket), &TargetInfoPacket))
-		return false;
-
-	return SendSequence();
-}
-#endif
-
-bool CPythonNetworkStream::RecvWarpPacket()
-{
-	TPacketGCWarp kWarpPacket;
-
-	if (!Recv(sizeof(kWarpPacket), &kWarpPacket))
-		return false;
-
-	__DirectEnterMode_Set(m_dwSelectedCharacterIndex);
-	CNetworkStream::Connect((DWORD)kWarpPacket.lAddr, kWarpPacket.wPort);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvDuelStartPacket()
-{
-	TPacketGCDuelStart kDuelStartPacket;
-	if (!Recv(sizeof(kDuelStartPacket), &kDuelStartPacket))
-		return false;
-
-	DWORD count = (kDuelStartPacket.wSize - sizeof(kDuelStartPacket)) / sizeof(DWORD);
-
-	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
-
-	CInstanceBase* pkInstMain = rkChrMgr.GetMainInstancePtr();
-	if (!pkInstMain)
-	{
-		TraceError("CPythonNetworkStream::RecvDuelStartPacket - MainCharacter is NULL");
-		return false;
-	}
-	DWORD dwVIDSrc = pkInstMain->GetVirtualID();
-	DWORD dwVIDDest;
-
-	for (DWORD i = 0; i < count; i++)
-	{
-		Recv(sizeof(dwVIDDest), &dwVIDDest);
-		CInstanceBase::InsertDUELKey(dwVIDSrc, dwVIDDest);
-	}
-
-	if (count == 0)
-		pkInstMain->SetDuelMode(CInstanceBase::DUEL_CANNOTATTACK);
-	else
-		pkInstMain->SetDuelMode(CInstanceBase::DUEL_START);
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoard", Py_BuildValue("()"));
-
-	rkChrMgr.RefreshAllPCTextTail();
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPVPPacket()
-{
-	TPacketGCPVP kPVPPacket;
-	if (!Recv(sizeof(kPVPPacket), &kPVPPacket))
-		return false;
-
-	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
-	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
-
-	switch (kPVPPacket.bMode)
-	{
-		case PVP_MODE_AGREE:
-			rkChrMgr.RemovePVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);
-
-			// »ó´ë°¡ ³ª(Dst)¿¡°Ô µ¿ÀÇ¸¦ ±¸ÇßÀ»¶§
-			if (rkPlayer.IsMainCharacterIndex(kPVPPacket.dwVIDDst))
-				rkPlayer.RememberChallengeInstance(kPVPPacket.dwVIDSrc);
-
-			// »ó´ë¿¡°Ô µ¿ÀÇ¸¦ ±¸ÇÑ µ¿¾È¿¡´Â ´ë°á ºÒ´É
-			if (rkPlayer.IsMainCharacterIndex(kPVPPacket.dwVIDSrc))
-				rkPlayer.RememberCantFightInstance(kPVPPacket.dwVIDDst);
-			break;
-		case PVP_MODE_REVENGE:
-		{
-			rkChrMgr.RemovePVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);
-
-			DWORD dwKiller = kPVPPacket.dwVIDSrc;
-			DWORD dwVictim = kPVPPacket.dwVIDDst;
-
-			// ³»(victim)°¡ »ó´ë¿¡°Ô º¹¼öÇÒ ¼ö ÀÖÀ»¶§
-			if (rkPlayer.IsMainCharacterIndex(dwVictim))
-				rkPlayer.RememberRevengeInstance(dwKiller);
-
-			// »ó´ë(victim)°¡ ³ª¿¡°Ô º¹¼öÇÏ´Â µ¿¾È¿¡´Â ´ë°á ºÒ´É
-			if (rkPlayer.IsMainCharacterIndex(dwKiller))
-				rkPlayer.RememberCantFightInstance(dwVictim);
-			break;
-		}
-
-		case PVP_MODE_FIGHT:
-			rkChrMgr.InsertPVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);
-			rkPlayer.ForgetInstance(kPVPPacket.dwVIDSrc);
-			rkPlayer.ForgetInstance(kPVPPacket.dwVIDDst);
-			break;
-		case PVP_MODE_NONE:
-			rkChrMgr.RemovePVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);
-			rkPlayer.ForgetInstance(kPVPPacket.dwVIDSrc);
-			rkPlayer.ForgetInstance(kPVPPacket.dwVIDDst);
-			break;
-	}
-
-	// NOTE : PVP Åä±Û½Ã TargetBoard ¸¦ ¾÷µ¥ÀÌÆ® ÇÕ´Ï´Ù.
-	__RefreshTargetBoardByVID(kPVPPacket.dwVIDSrc);
-	__RefreshTargetBoardByVID(kPVPPacket.dwVIDDst);
-
-	return true;
-}
-
-// DELETEME
-/*
-void CPythonNetworkStream::__SendWarpPacket()
-{
-	TPacketCGWarp kWarpPacket;
-	kWarpPacket.bHeader=HEADER_GC_WARP;
-	if (!Send(sizeof(kWarpPacket), &kWarpPacket))
-	{
-		return;
-	}
-}
-*/
-void CPythonNetworkStream::NotifyHack(const char* c_szMsg)
-{
-	if (!m_kQue_stHack.empty())
-		if (c_szMsg == m_kQue_stHack.back())
-			return;
-
-	m_kQue_stHack.push_back(c_szMsg);
-}
-
-bool CPythonNetworkStream::__SendHack(const char* c_szMsg)
-{
-	Tracen(c_szMsg);
-
-	TPacketCGHack kPacketHack;
-	kPacketHack.bHeader = HEADER_CG_HACK;
-	strncpy(kPacketHack.szBuf, c_szMsg, sizeof(kPacketHack.szBuf) - 1);
-
-	if (!Send(sizeof(kPacketHack), &kPacketHack))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendCharacterStatePacket(const TPixelPosition& c_rkPPosDst, float fDstRot, UINT eFunc, UINT uArg)
-{
-	NANOBEGIN
-		if (!__CanActMainInstance())
-			return true;
-
-	if (fDstRot < 0.0f)
-		fDstRot = 360 + fDstRot;
-	else if (fDstRot > 360.0f)
-		fDstRot = fmodf(fDstRot, 360.0f);
-
-	// TODO: ³ªÁß¿¡ ÆÐÅ¶ÀÌ¸§À» ¹Ù²ÙÀÚ
-	TPacketCGMove kStatePacket;
-	kStatePacket.bHeader = HEADER_CG_CHARACTER_MOVE;
-	kStatePacket.bFunc = eFunc;
-	kStatePacket.bArg = uArg;
-	kStatePacket.bRot = fDstRot / 5.0f;
-	kStatePacket.lX = long(c_rkPPosDst.x);
-	kStatePacket.lY = long(c_rkPPosDst.y);
-	kStatePacket.dwTime = ELTimer_GetServerMSec();
-
-	assert(kStatePacket.lX >= 0 && kStatePacket.lX < 204800);
-
-	__LocalPositionToGlobalPosition(kStatePacket.lX, kStatePacket.lY);
-
-	if (!Send(sizeof(kStatePacket), &kStatePacket))
-	{
-		Tracenf("CPythonNetworkStream::SendCharacterStatePacket(dwCmdTime=%u, fDstPos=(%f, %f), fDstRot=%f, eFunc=%d uArg=%d) - PACKET SEND ERROR",
-			kStatePacket.dwTime,
-			float(kStatePacket.lX),
-			float(kStatePacket.lY),
-			fDstRot,
-			kStatePacket.bFunc,
-			kStatePacket.bArg);
-		return false;
-	}
-	NANOEND
-		return SendSequence();
-}
-
-// NOTE : SlotIndex´Â ÀÓ½Ã
-bool CPythonNetworkStream::SendUseSkillPacket(DWORD dwSkillIndex, DWORD dwTargetVID)
-{
-	TPacketCGUseSkill UseSkillPacket;
-	UseSkillPacket.bHeader = HEADER_CG_USE_SKILL;
-	UseSkillPacket.dwVnum = dwSkillIndex;
-	UseSkillPacket.dwTargetVID = dwTargetVID;
-
-	if (!Send(sizeof(TPacketCGUseSkill), &UseSkillPacket))
-	{
-		Tracen("CPythonNetworkStream::SendUseSkillPacket - SEND PACKET ERROR");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendChatPacket(const char* c_szChat, BYTE byType)
-{
-	if (m_strPhase != "Game")
-		return true;
-
-	if (strlen(c_szChat) == 0)
-		return true;
-
-	if (strlen(c_szChat) >= 512)
-		return true;
-
-	if (c_szChat[0] == '/')
-	{
-		if (1 == strlen(c_szChat))
-		{
-			if (!m_strLastCommand.empty())
-				c_szChat = m_strLastCommand.c_str();
-		}
-		else
-		{
-			m_strLastCommand = c_szChat;
-		}
-	}
-
-	if (ClientCommand(c_szChat))
-		return true;
-
-	int iTextLen = strlen(c_szChat) + 1;
-	TPacketCGChat ChatPacket;
-	ChatPacket.header = HEADER_CG_CHAT;
-	ChatPacket.length = sizeof(ChatPacket) + iTextLen;
-	ChatPacket.type = byType;
-
-	if (!Send(sizeof(ChatPacket), &ChatPacket))
-		return false;
-
-	if (!Send(iTextLen, c_szChat))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendCommandPacket(const char* c_szChat)
-{
-	return SendChatPacket(c_szChat, CHAT_TYPE_COMMAND);
-}
-
-//////////////////////////////////////////////////////////////////////////
-// Emoticon
-void CPythonNetworkStream::RegisterEmoticonType(const BYTE bEmoticonType)
-{
-	if (m_EmoticonTypeVector.size() >= CInstanceBase::EMOTICON_NUM)
-	{
-		TraceError("Can't register emoticon string... vector is full (size:%d)", m_EmoticonTypeVector.size());
-		return;
-	}
-	m_EmoticonTypeVector.push_back(bEmoticonType);
-}
-
-bool CPythonNetworkStream::ParseEmoticon(const BYTE bEmoticonType, DWORD* pdwEmoticon)
-{
-	for (DWORD dwEmoticonIndex = 0; dwEmoticonIndex < m_EmoticonTypeVector.size(); ++dwEmoticonIndex)
-	{
-		if (m_EmoticonTypeVector[dwEmoticonIndex] == bEmoticonType)
-		{
-			*pdwEmoticon = dwEmoticonIndex;
-			return true;
-		}
-	}
-
-	return false;
-}
-// Emoticon
-//////////////////////////////////////////////////////////////////////////
-
-void CPythonNetworkStream::__ConvertEmpireText(DWORD dwEmpireID, char* szText)
-{
-	if (dwEmpireID < 1 || dwEmpireID>3)
-		return;
-
-	UINT uHanPos;
-
-	STextConvertTable& rkTextConvTable = m_aTextConvTable[dwEmpireID - 1];
-
-	BYTE* pbText = (BYTE*)szText;
-	while (*pbText)
-	{
-		if (*pbText & 0x80)
-		{
-			if (pbText[0] >= 0xb0 && pbText[0] <= 0xc8 && pbText[1] >= 0xa1 && pbText[1] <= 0xfe)
-			{
-				uHanPos = (pbText[0] - 0xb0) * (0xfe - 0xa1 + 1) + (pbText[1] - 0xa1);
-				pbText[0] = rkTextConvTable.aacHan[uHanPos][0];
-				pbText[1] = rkTextConvTable.aacHan[uHanPos][1];
-			}
-			pbText += 2;
-		}
-		else
-		{
-			if (*pbText >= 'a' && *pbText <= 'z')
-			{
-				*pbText = rkTextConvTable.acLower[*pbText - 'a'];
-			}
-			else if (*pbText >= 'A' && *pbText <= 'Z')
-			{
-				*pbText = rkTextConvTable.acUpper[*pbText - 'A'];
-			}
-			pbText++;
-		}
-	}
-}
-
-bool CPythonNetworkStream::RecvChatPacket()
-{
-	TPacketGCChat kChat;
-	char buf[1024 + 1];
-	char line[1024 + 1];
-
-	if (!Recv(sizeof(kChat), &kChat))
-		return false;
-
-	UINT uChatSize = kChat.size - sizeof(kChat);
-
-	if (!Recv(uChatSize, buf))
-		return false;
-
-	buf[uChatSize] = '\0';
-
-#if defined(ENABLE_LOCALE_CLIENT)
-	TTokenVector vecMultiLine;
-	std::string sFormat = { buf };
-	if (kChat.bCanFormat && CHAT_TYPE_SHOUT != kChat.type)
-	{
-		CPythonLocale::Instance().FormatString(sFormat);
-		CPythonLocale::Instance().MultiLineSplit(sFormat, vecMultiLine);
-	}
-	else
-	{
-		CPythonLocale::Instance().FilterHyperlinkName(sFormat);
-	}
-
-	strncpy(buf, sFormat.c_str(), sizeof(buf));
-	buf[sizeof(buf) - 1] = '\0';
-#endif
-
-	// À¯·´ ¾Æ¶ø ¹öÀü Ã³¸®
-	// "ÀÌ¸§: ³»¿ë" ÀÔ·ÂÀ» "³»¿ë: ÀÌ¸§" ¼ø¼­·Î Ãâ·ÂÇÏ±â À§ÇØ ÅÇ(0x08)À» ³ÖÀ½
-	// ÅÇÀ» ¾Æ¶ø¾î ±âÈ£·Î Ã³¸®ÇØ (¿µ¾î1) : (¿µ¾î2) ·Î ÀÔ·ÂµÇ¾îµµ (¿µ¾î2) : (¿µ¾î1) ·Î Ãâ·ÂÇÏ°Ô ¸¸µç´Ù
-	if (LocaleService_IsEUROPE() && GetDefaultCodePage() == 1256)
-	{
-		char* p = strchr(buf, ':');
-		if (p && p[1] == ' ')
-			p[1] = 0x08;
-	}
-
-	if (kChat.type >= CHAT_TYPE_MAX_NUM)
-		return true;
-
-	if (CHAT_TYPE_COMMAND == kChat.type)
-	{
-		ServerCommand(buf);
-		return true;
-	}
-	else if (CHAT_TYPE_MISSION == kChat.type)
-	{
-		if (uChatSize)
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetMissionMessage", Py_BuildValue("(s)", buf));
-		else
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_CleanMissionMessage", Py_BuildValue("()"));
-
-		return true;
-	}
-	else if (CHAT_TYPE_SUB_MISSION == kChat.type)
-	{
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetSubMissionMessage", Py_BuildValue("(s)", buf));
-		return true;
-	}
-
-	if (kChat.dwVID != 0)
-	{
-		CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
-		CInstanceBase* pkInstChatter = rkChrMgr.GetInstancePtr(kChat.dwVID);
-		if (NULL == pkInstChatter)
-			return true;
-
-		switch (kChat.type)
-		{
-			case CHAT_TYPE_TALKING: /* ±×³É Ã¤ÆÃ */
-			case CHAT_TYPE_PARTY: /* ÆÄÆ¼¸» */
-			case CHAT_TYPE_GUILD: /* ±æµå¸» */
-			case CHAT_TYPE_SHOUT: /* ¿ÜÄ¡±â */
-			case CHAT_TYPE_WHISPER: // ¼­¹ö¿Í´Â ¿¬µ¿µÇÁö ¾Ê´Â Only Client Enum
-			{
-				char* p = strchr(buf, ':');
-
-				if (p)
-					p += 2;
-				else
-					p = buf;
-
-				if (gs_bEmpireLanuageEnable)
-				{
-					CInstanceBase* pkInstMain = rkChrMgr.GetMainInstancePtr();
-					if (pkInstMain)
-						if (!pkInstMain->IsSameEmpire(*pkInstChatter))
-							__ConvertEmpireText(pkInstChatter->GetEmpireID(), p);
-				}
-
-				if (m_isEnableChatInsultFilter)
-				{
-					if (false == pkInstChatter->IsNPC() && false == pkInstChatter->IsEnemy())
-					{
-						__FilterInsult(p, strlen(p));
-					}
-				}
-
-				_snprintf(line, sizeof(line), "%s", p);
-			}
-			break;
-
-			case CHAT_TYPE_COMMAND: /* ¸í·É */
-			case CHAT_TYPE_INFO: /* Á¤º¸ (¾ÆÀÌÅÛÀ» Áý¾ú´Ù, °æÇèÄ¡¸¦ ¾ò¾ú´Ù. µî) */
-			case CHAT_TYPE_NOTICE: /* °øÁö»çÇ× */
-			case CHAT_TYPE_BIG_NOTICE:
-#if defined(ENABLE_OX_RENEWAL)
-			case CHAT_TYPE_BIG_CONTROL_NOTICE:
-#endif
-#if defined(ENABLE_DICE_SYSTEM)
-			case CHAT_TYPE_DICE_INFO:
-#endif
-#if defined(ENABLE_CHATTING_WINDOW_RENEWAL)
-			case CHAT_TYPE_EXP_INFO:
-			case CHAT_TYPE_ITEM_INFO:
-			case CHAT_TYPE_MONEY_INFO:
-#endif
-			case CHAT_TYPE_MAX_NUM:
-			default:
-				_snprintf(line, sizeof(line), "%s", buf);
-				break;
-		}
-
-		if (CHAT_TYPE_SHOUT != kChat.type)
-		{
-			CPythonTextTail::Instance().RegisterChatTail(kChat.dwVID, line);
-		}
-
-		if (pkInstChatter->IsPC())
-		{
-#if defined(ENABLE_MESSENGER_BLOCK)
-			if (CPythonMessenger::Instance().IsBlockFriendByName(pkInstChatter->GetNameString()))
-				return true;
-#endif
-
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-			CPythonChat::Instance().AppendChat(kChat.type, buf, IAbstractChat::ESpecialColorType::CHAT_SPECIAL_COLOR_NORMAL, kChat.szCountry);
-#else
-			CPythonChat::Instance().AppendChat(kChat.type, buf);
-#endif
-		}
-	}
-	else
-	{
-		if (CHAT_TYPE_NOTICE == kChat.type)
-		{
-#if defined(ENABLE_LOCALE_CLIENT)
-			if (!vecMultiLine.empty())
-			{
-				for (std::string& sMessage : vecMultiLine)
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetTipMessage", Py_BuildValue("(s)", sMessage.c_str()));
-			}
-			else
-			{
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetTipMessage", Py_BuildValue("(s)", buf));
-			}
-#else
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetTipMessage", Py_BuildValue("(s)", buf));
-#endif
-		}
-		else if (CHAT_TYPE_BIG_NOTICE == kChat.type)
-		{
-#if defined(ENABLE_LOCALE_CLIENT)
-			if (!vecMultiLine.empty())
-			{
-				for (const std::string& sMessage : vecMultiLine)
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigMessage", Py_BuildValue("(s)", sMessage.c_str()));
-			}
-			else
-			{
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigMessage", Py_BuildValue("(s)", buf));
-			}
-#else
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigMessage", Py_BuildValue("(s)", buf));
-#endif
-		}
-#if defined(ENABLE_OX_RENEWAL)
-		else if (CHAT_TYPE_BIG_CONTROL_NOTICE == kChat.type)
-		{
-#if defined(ENABLE_LOCALE_CLIENT)
-			if (strstr(buf, "#start") || strstr(buf, "#send") || strstr(buf, "#end"))
-			{
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigControlMessage", Py_BuildValue("(s)", buf));
-			}
-			else
-			{
-				if (!vecMultiLine.empty())
-				{
-					for (const std::string& sMessage : vecMultiLine)
-						PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigControlMessage", Py_BuildValue("(s)", sMessage.c_str()));
-				}
-				else
-				{
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigControlMessage", Py_BuildValue("(s)", buf));
-				}
-			}
-#else
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigControlMessage", Py_BuildValue("(s)", buf));
-#endif
-		}
-#endif
-		else if (CHAT_TYPE_SHOUT == kChat.type)
-		{
-			char* p = strchr(buf, ':');
-
-			if (p)
-			{
-				if (m_isEnableChatInsultFilter)
-					__FilterInsult(p, strlen(p));
-			}
-		}
-
-#if defined(ENABLE_LOCALE_CLIENT)
-		if (!vecMultiLine.empty())
-		{
-			for (const std::string& sMessage : vecMultiLine)
-				CPythonChat::Instance().AppendChat(kChat.type, sMessage.c_str());
-		}
-		else
-		{
-			if (buf[0] == '@')
-				CPythonChat::Instance().AppendChat(kChat.type, &buf[1], IAbstractChat::ESpecialColorType::CHAT_SPECIAL_COLOR_DICE_0);
-			else if (buf[0] == '$')
-				CPythonChat::Instance().AppendChat(kChat.type, &buf[1], IAbstractChat::ESpecialColorType::CHAT_SPECIAL_COLOR_DICE_1);
-			else
-			{
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-				CPythonChat::Instance().AppendChat(kChat.type, buf, IAbstractChat::ESpecialColorType::CHAT_SPECIAL_COLOR_NORMAL, kChat.szCountry);
-#else
-				CPythonChat::Instance().AppendChat(kChat.type, buf);
-#endif
-			}
-		}
-#else
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-		CPythonChat::Instance().AppendChat(kChat.type, buf, kChat.szCountry);
-#else
-		CPythonChat::Instance().AppendChat(kChat.type, buf);
-#endif
-#endif
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvWhisperPacket()
-{
-	TPacketGCWhisper whisperPacket;
-	char buf[512 + 1];
-
-	if (!Recv(sizeof(whisperPacket), &whisperPacket))
-		return false;
-
-	assert(whisperPacket.wSize - sizeof(whisperPacket) < 512);
-
-	if (!Recv(whisperPacket.wSize - sizeof(whisperPacket), &buf))
-		return false;
-
-	buf[whisperPacket.wSize - sizeof(whisperPacket)] = '\0';
-
-#if defined(ENABLE_LOCALE_CLIENT)
-	TTokenVector vecMultiLine;
-	if (whisperPacket.bCanFormat)
-	{
-		CPythonLocale::Instance().FormatString(buf, sizeof(buf));
-		CPythonLocale::Instance().FormatString(whisperPacket.szNameFrom, sizeof(whisperPacket.szNameFrom));
-	}
-#endif
-
-	static char line[256];
-	if (CPythonChat::WHISPER_TYPE_CHAT == whisperPacket.bType || CPythonChat::WHISPER_TYPE_GM == whisperPacket.bType)
-	{
-		if (GetDefaultCodePage() == CP_ARABIC)
-			_snprintf(line, sizeof(line), "%s", buf);
-		else
-			_snprintf(line, sizeof(line), "%s : %s", whisperPacket.szNameFrom, buf);
-
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnRecvWhisper", Py_BuildValue("(isss)", (int)whisperPacket.bType, whisperPacket.szNameFrom, line, whisperPacket.szCountry));
-#else
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnRecvWhisper", Py_BuildValue("(iss)", (int)whisperPacket.bType, whisperPacket.szNameFrom, line));
-#endif
-#if defined(ENABLE_BADGE_NOTIFICATION_MANAGER)
-		static auto& badge_notification_manager = CBadgeNotificationManager::Instance();
-		badge_notification_manager.ReceiveWhisper(whisperPacket.szNameFrom);
-#endif
-	}
-	else if (CPythonChat::WHISPER_TYPE_SYSTEM == whisperPacket.bType || CPythonChat::WHISPER_TYPE_ERROR == whisperPacket.bType)
-	{
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnRecvWhisperSystemMessage", Py_BuildValue("(iss)", (int)whisperPacket.bType, whisperPacket.szNameFrom, buf));
-	}
-	else
-	{
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnRecvWhisperError", Py_BuildValue("(iss)", (int)whisperPacket.bType, whisperPacket.szNameFrom, buf));
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendWhisperPacket(const char* name, const char* c_szChat)
-{
-	if (strlen(c_szChat) >= 255)
-		return true;
-
-	int iTextLen = strlen(c_szChat) + 1;
-	TPacketCGWhisper WhisperPacket;
-	WhisperPacket.bHeader = HEADER_CG_WHISPER;
-	WhisperPacket.wSize = sizeof(WhisperPacket) + iTextLen;
-
-	strncpy(WhisperPacket.szNameTo, name, sizeof(WhisperPacket.szNameTo) - 1);
-
-	if (!Send(sizeof(WhisperPacket), &WhisperPacket))
-		return false;
-
-	if (!Send(iTextLen, c_szChat))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvPointChange()
-{
-	TPacketGCPointChange PointChange;
-
-	if (!Recv(sizeof(TPacketGCPointChange), &PointChange))
-	{
-		Tracen("Recv Point Change Packet Error");
-		return false;
-	}
-
-	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
-	rkChrMgr.ShowPointEffect(PointChange.wType, PointChange.dwVID);
-
-	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetMainInstancePtr();
-
-	// ÀÚ½ÅÀÇ Point°¡ º¯°æµÇ¾úÀ» °æ¿ì..
-	if (pInstance)
-	{
-		if (PointChange.dwVID == pInstance->GetVirtualID())
-		{
-			CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
-			rkPlayer.SetStatus(PointChange.wType, PointChange.lValue);
-
-			switch (PointChange.wType)
-			{
-				case POINT_STAT_RESET_COUNT:
-					__RefreshStatus();
-					break;
-
-#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
-				case POINT_PLAYTIME:
-					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].dwPlayMinutes = PointChange.lValue;
-					break;
-#endif
-
-				case POINT_LEVEL:
-#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
-				{
-					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byLevel = PointChange.lValue;
-					__RefreshStatus();
-					__RefreshSkillWindow();
-				}
-				break;
-#endif
-
-				case POINT_ST:
-#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
-				{
-					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byST = PointChange.lValue;
-					__RefreshStatus();
-					__RefreshSkillWindow();
-				}
-				break;
-#endif
-
-				case POINT_DX:
-#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
-				{
-					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byDX = PointChange.lValue;
-					__RefreshStatus();
-					__RefreshSkillWindow();
-				}
-				break;
-#endif
-
-				case POINT_HT:
-#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
-				{
-					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byHT = PointChange.lValue;
-					__RefreshStatus();
-					__RefreshSkillWindow();
-				}
-				break;
-#endif
-
-				case POINT_IQ:
-#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
-				{
-					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byIQ = PointChange.lValue;
-					__RefreshStatus();
-					__RefreshSkillWindow();
-				}
-				break;
-#endif
-
-#if defined(ENABLE_CONQUEROR_LEVEL)
-				case POINT_CONQUEROR_LEVEL:
-				{
-					pInstance->UpdateTextTailConquerorLevel(PointChange.lValue);
-#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
-					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byConquerorLevel = PointChange.lValue;
-					__RefreshStatus();
-					__RefreshSkillWindow();
-#endif
-				}
-				break;
-
-				case POINT_SUNGMA_STR:
-#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
-				{
-					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].bySungmaStr = PointChange.lValue;
-					__RefreshStatus();
-					__RefreshSkillWindow();
-				}
-				break;
-#endif
-
-				case POINT_SUNGMA_HP:
-#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
-				{
-					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].bySungmaHp = PointChange.lValue;
-					__RefreshStatus();
-					__RefreshSkillWindow();
-				}
-				break;
-#endif
-
-				case POINT_SUNGMA_MOVE:
-#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
-				{
-					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].bySungmaMove = PointChange.lValue;
-					__RefreshStatus();
-					__RefreshSkillWindow();
-				}
-				break;
-#endif
-
-				case POINT_SUNGMA_IMMUNE:
-#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
-				{
-					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].bySungmaImmune = PointChange.lValue;
-					__RefreshStatus();
-					__RefreshSkillWindow();
-				}
-				break;
-#endif
-#endif
-
-				case POINT_SKILL:
-				case POINT_SUB_SKILL:
-				case POINT_HORSE_SKILL:
-					__RefreshSkillWindow();
-					break;
-
-				case POINT_ENERGY:
-				{
-					if (PointChange.lValue == 0)
-					{
-						rkPlayer.SetStatus(POINT_ENERGY_END_TIME, 0);
-					}
-					__RefreshStatus();
-				}
-				break;
-
-				default:
-					__RefreshStatus();
-					break;
-			}
-
-			if (POINT_GOLD == PointChange.wType)
-			{
-				if (PointChange.lAmount > 0)
-				{
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnPickMoney", Py_BuildValue("(i)", PointChange.lAmount));
-				}
-			}
-
-#if defined(ENABLE_CHEQUE_SYSTEM)
-			if (POINT_CHEQUE == PointChange.wType)
-			{
-				if (PointChange.lAmount > 0)
-				{
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnPickCheque", Py_BuildValue("(i)", PointChange.lAmount));
-				}
-			}
-#endif
-
-#if defined(ENABLE_GEM_SYSTEM)
-			if (POINT_GEM == PointChange.wType)
-			{
-				if (PointChange.lAmount > 0)
-				{
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnPickGem", Py_BuildValue("(i)", PointChange.lAmount));
-				}
-			}
-#endif
-		}
-		else if (POINT_LEVEL == PointChange.wType)
-		{
-			CInstanceBase* pOtherInstance = CPythonCharacterManager::Instance().GetInstancePtr(PointChange.dwVID);
-			if (pOtherInstance)
-				pOtherInstance->UpdateTextTailLevel(PointChange.lValue);
-#ifdef ENABLE_GROWTH_PET_SYSTEM
-				if (pInstance->IsGrowthPet())
-					pInstance->SetPetLevel(PointChange.lValue);
-#endif
-		}
-#if defined(ENABLE_CONQUEROR_LEVEL)
-		else if (POINT_CONQUEROR_LEVEL == PointChange.wType)
-		{
-			CInstanceBase* pOtherInstance = CPythonCharacterManager::Instance().GetInstancePtr(PointChange.dwVID);
-			if (pOtherInstance)
-				pOtherInstance->UpdateTextTailConquerorLevel(PointChange.lValue);
-		}
-#endif
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvStunPacket()
-{
-	TPacketGCStun StunPacket;
-
-	if (!Recv(sizeof(StunPacket), &StunPacket))
-	{
-		Tracen("CPythonNetworkStream::RecvStunPacket Error");
-		return false;
-	}
-
-	//Tracef("RecvStunPacket %d\n", StunPacket.vid);
-
-	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
-	CInstanceBase* pkInstSel = rkChrMgr.GetInstancePtr(StunPacket.vid);
-
-	if (pkInstSel)
-	{
-		if (CPythonCharacterManager::Instance().GetMainInstancePtr() == pkInstSel)
-			pkInstSel->Die();
-		else
-			pkInstSel->Stun();
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvDeadPacket()
-{
-	TPacketGCDead DeadPacket;
-	if (!Recv(sizeof(DeadPacket), &DeadPacket))
-	{
-		Tracen("CPythonNetworkStream::RecvDeadPacket Error");
-		return false;
-	}
-
-	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
-	CInstanceBase* pkChrInstSel = rkChrMgr.GetInstancePtr(DeadPacket.vid);
-	if (pkChrInstSel)
-	{
-		CInstanceBase* pkInstMain = rkChrMgr.GetMainInstancePtr();
-		if (pkInstMain == pkChrInstSel)
-		{
-			Tracenf("ÁÖÀÎ°ø »ç¸Á");
-
-			if (false == pkInstMain->GetDuelMode())
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnGameOver", Py_BuildValue("(ii)", DeadPacket.map_index, DeadPacket.dialog_type));
-
-			CPythonPlayer::Instance().NotifyDeadMainCharacter();
-#if defined(ENABLE_SKILL_COOLTIME_UPDATE)
-			CPythonPlayer::Instance().ResetSkillCoolTimes();
-#endif
-		}
-
-		pkChrInstSel->Die();
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendCharacterPositionPacket(BYTE iPosition)
-{
-	TPacketCGPosition PositionPacket;
-
-	PositionPacket.header = HEADER_CG_CHARACTER_POSITION;
-	PositionPacket.position = iPosition;
-
-	if (!Send(sizeof(TPacketCGPosition), &PositionPacket))
-	{
-		Tracen("Send Character Position Packet Error");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendOnClickPacket(DWORD vid)
-{
-	TPacketCGOnClick OnClickPacket;
-	OnClickPacket.header = HEADER_CG_ON_CLICK;
-	OnClickPacket.vid = vid;
-
-	if (!Send(sizeof(OnClickPacket), &OnClickPacket))
-	{
-		Tracen("Send On_Click Packet Error");
-		return false;
-	}
-
-	Tracef("SendOnClickPacket\n");
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvCharacterPositionPacket()
-{
-	TPacketGCPosition PositionPacket;
-
-	if (!Recv(sizeof(TPacketGCPosition), &PositionPacket))
-		return false;
-
-	CInstanceBase* pChrInstance = CPythonCharacterManager::Instance().GetInstancePtr(PositionPacket.vid);
-
-	if (!pChrInstance)
-		return true;
-
-	//pChrInstance->UpdatePosition(PositionPacket.position);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvMotionPacket()
-{
-	TPacketGCMotion MotionPacket;
-
-	if (!Recv(sizeof(TPacketGCMotion), &MotionPacket))
-		return false;
-
-	CInstanceBase* pMainInstance = CPythonCharacterManager::Instance().GetInstancePtr(MotionPacket.vid);
-	CInstanceBase* pVictimInstance = NULL;
-
-	if (0 != MotionPacket.victim_vid)
-		pVictimInstance = CPythonCharacterManager::Instance().GetInstancePtr(MotionPacket.victim_vid);
-
-	if (!pMainInstance)
-		return false;
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvShopPacket()
-{
-	std::vector<char> vecBuffer;
-	vecBuffer.clear();
-
-	TPacketGCShop packet_shop;
-	if (!Recv(sizeof(packet_shop), &packet_shop))
-		return false;
-
-	int iSize = packet_shop.size - sizeof(packet_shop);
-	if (iSize > 0)
-	{
-		vecBuffer.resize(iSize);
-		if (!Recv(iSize, &vecBuffer[0]))
-			return false;
-	}
-
-	switch (packet_shop.subheader)
-	{
-		case SHOP_SUBHEADER_GC_START:
-		{
-			CPythonShop::Instance().Clear();
-
-			DWORD dwVID = *(DWORD*)&vecBuffer[0];
-
-			TPacketGCShopStart* pShopStartPacket = (TPacketGCShopStart*)&vecBuffer[4];
-#if defined(ENABLE_MYSHOP_DECO)
-			BYTE shop_tab_count = pShopStartPacket->shop_tab_count;
-			CPythonShop::Instance().SetTabCount(shop_tab_count);
-#endif
-
-#if defined(ENABLE_MYSHOP_EXPANSION)
-			for (BYTE iItemIndex = 0; iItemIndex < 80; ++iItemIndex)
-#else
-			for (BYTE iItemIndex = 0; iItemIndex < SHOP_HOST_ITEM_MAX_NUM; ++iItemIndex)
-#endif
-				CPythonShop::Instance().SetItemData(iItemIndex, pShopStartPacket->items[iItemIndex]);
-
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartShop", Py_BuildValue("(i)", dwVID));
-		}
-		break;
-
-		case SHOP_SUBHEADER_GC_END:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "EndShop", Py_BuildValue("()"));
-			break;
-
-		case SHOP_SUBHEADER_GC_UPDATE_ITEM:
-		{
-			TPacketGCShopUpdateItem* pShopUpdateItemPacket = (TPacketGCShopUpdateItem*)&vecBuffer[0];
-			CPythonShop::Instance().SetItemData(pShopUpdateItemPacket->pos, pShopUpdateItemPacket->item);
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshShop", Py_BuildValue("()"));
-		}
-		break;
-
-		case SHOP_SUBHEADER_GC_UPDATE_PRICE:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetShopSellingPrice", Py_BuildValue("(i)", *(int*)&vecBuffer[0]));
-			break;
-
-		case SHOP_SUBHEADER_GC_OK:
-			break;
-
-		case SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_MONEY"));
-			break;
-
-		case SHOP_SUBHEADER_GC_SOLDOUT:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "SOLDOUT"));
-			break;
-
-		case SHOP_SUBHEADER_GC_INVENTORY_FULL:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "INVENTORY_FULL"));
-			break;
-
-		case SHOP_SUBHEADER_GC_INVALID_POS:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "INVALID_POS"));
-			break;
-
-		case SHOP_SUBHEADER_GC_SOLD_OUT:
-			break;
-
-
-		case SHOP_SUBHEADER_GC_START_EX:
-		{
-			CPythonShop::Instance().Clear();
-
-			TPacketGCShopStartEx* pShopStartPacket = (TPacketGCShopStartEx*)&vecBuffer[0];
-			size_t read_point = sizeof(TPacketGCShopStartEx);
-
-			DWORD dwVID = pShopStartPacket->owner_vid;
-			BYTE shop_tab_count = pShopStartPacket->shop_tab_count;
-
-			CPythonShop::Instance().SetTabCount(shop_tab_count);
-
-			for (BYTE i = 0; i < shop_tab_count; i++)
-			{
-				TPacketGCShopStartEx::TSubPacketShopTab* pPackTab = (TPacketGCShopStartEx::TSubPacketShopTab*)&vecBuffer[read_point];
-				read_point += sizeof(TPacketGCShopStartEx::TSubPacketShopTab);
-
-				CPythonShop::Instance().SetTabCoinType(i, pPackTab->coin_type);
-				CPythonShop::Instance().SetTabName(i, pPackTab->name);
-
-				struct packet_shop_item* item = &pPackTab->items[0];
-
-				for (BYTE j = 0; j < SHOP_HOST_ITEM_MAX_NUM; j++)
-				{
-					TShopItemData* itemData = (item + j);
-					if (itemData)
-						CPythonShop::Instance().SetItemData(i, j, *itemData);
-				}
-			}
-
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartShop", Py_BuildValue("(i)", dwVID));
-		}
-		break;
-
-		case SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY_EX:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_MONEY_EX"));
-			break;
-
-		case SHOP_SUBHEADER_GC_NOT_ENOUGH_BP:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_BP"));
-			break;
-
-		case SHOP_SUBHEADER_GC_EXCEED_LIMIT_TODAY:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "EXCEED_LIMIT_TODAY"));
-			break;
-
-#if defined(ENABLE_MYSHOP_DECO)
-		case SHOP_SUBHEADER_GC_MYPRIV_SHOP_OPEN:
-		{
-			const TPacketGCMyPrivShopOpen* pMyPrivShopOpenPacket = (TPacketGCMyPrivShopOpen*)&vecBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MyPrivShopOpen", Py_BuildValue("(bi)", pMyPrivShopOpenPacket->bCashItem, pMyPrivShopOpenPacket->bTabCount));
-		}
-		break;
-#endif
-
-		case SHOP_SUBHEADER_GC_NOT_ENOUGH_10TH_COIN:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_10TH_COIN"));
-			break;
-
-		case SHOP_SUBHEADER_GC_LIMITED_PURCHASE_OVER:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "LIMITED_PURCHASE_OVER"));
-			break;
-
-		case SHOP_SUBHEADER_GC_LIMITED_DATA_LOADING:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "LIMITED_DATA_LOADING"));
-			break;
-
-			// 12ZI RELATED
-		case SHOP_SUBHEADER_GC_UNK_19:
-			break;
-		case SHOP_SUBHEADER_GC_UNK_20:
-			break;
-		case SHOP_SUBHEADER_GC_UNK_21:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshShopItemToolTip", Py_BuildValue("()"));
-			break;
-			// END_OF_12ZI_RELATED
-
-		case SHOP_SUBHEADER_GC_NOT_ENOUGH_GUILD_LEVEL:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_GUILD_LEVEL"));
-			break;
-
-		case SHOP_SUBHEADER_GC_NOT_ENOUGH_MEDAL_OF_HONOR:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_MEDAL_OF_HONOR"));
-			break;
-
-		case SHOP_SUBHEADER_GC_NOT_ENOUGH_BNW:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_BNW"));
-			break;
-
-#if defined(ENABLE_SHOPEX_RENEWAL)
-		case SHOP_SUBHEADER_GC_NOT_ENOUGH_ITEM:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_ITEM"));
-			break;
-#endif
-
-		default:
-			TraceError("CPythonNetworkStream::RecvShopPacket: Unknown subheader\n");
-			break;
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvExchangePacket()
-{
-	TPacketGCExchange exchange_packet;
-
-	if (!Recv(sizeof(exchange_packet), &exchange_packet))
-		return false;
-
-	switch (exchange_packet.subheader)
-	{
-		case EXCHANGE_SUBHEADER_GC_START:
-		{
-			CPythonExchange::Instance().Clear();
-			CPythonExchange::Instance().Start();
-			CPythonExchange::Instance().SetSelfName(CPythonPlayer::Instance().GetName());
-
-			{
-				CInstanceBase* pCharacterInstance = CPythonCharacterManager::Instance().GetInstancePtr(exchange_packet.arg1);
-
-				if (pCharacterInstance)
-				{
-					CPythonExchange::Instance().SetTargetName(pCharacterInstance->GetNameString());
-					CPythonExchange::Instance().SetLevelToTarget(pCharacterInstance->GetLevel());
-				}
-			}
-
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartExchange", Py_BuildValue("()"));
-		}
-		break;
-
-		case EXCHANGE_SUBHEADER_GC_ITEM_ADD:
-		{
-			if (exchange_packet.is_me)
-			{
-				int iSlotIndex = exchange_packet.arg2.cell;
-				CPythonExchange::Instance().SetItemToSelf(iSlotIndex, exchange_packet.arg1, (WORD)exchange_packet.arg3);
-
-				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_SOCKET_SLOT_MAX_NUM; ++bSlotIdx)
-					CPythonExchange::Instance().SetItemMetinSocketToSelf(iSlotIndex, bSlotIdx, exchange_packet.alValues[bSlotIdx]);
-
-				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++bSlotIdx)
-					CPythonExchange::Instance().SetItemAttributeToSelf(iSlotIndex, bSlotIdx,
-						exchange_packet.aAttr[bSlotIdx].wType, exchange_packet.aAttr[bSlotIdx].lValue);
-
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-				CPythonExchange::Instance().SetItemChangeLookVnumToSelf(iSlotIndex, exchange_packet.dwTransmutationVnum);
-#endif
-
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-				CPythonExchange::Instance().SetItemRefineElementToSelf(iSlotIndex, exchange_packet.RefineElement);
-#endif
-
-#if defined(ENABLE_APPLY_RANDOM)
-				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_APPLY_RANDOM_SLOT_MAX_NUM; ++bSlotIdx)
-					CPythonExchange::Instance().SetItemApplyRandomToSelf(iSlotIndex, bSlotIdx,
-						exchange_packet.aApplyRandom[bSlotIdx].wType, exchange_packet.aApplyRandom[bSlotIdx].lValue);
-#endif
-
-#if defined(ENABLE_SET_ITEM)
-				CPythonExchange::Instance().SetItemSetValueToSelf(iSlotIndex, exchange_packet.bSetValue);
-#endif
-
-#if defined(WJ_ENABLE_TRADABLE_ICON)
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AddExchangeItemSlotIndex", Py_BuildValue("(i)", exchange_packet.arg4.cell));
-#endif
-			}
-			else
-			{
-				int iSlotIndex = exchange_packet.arg2.cell;
-				CPythonExchange::Instance().SetItemToTarget(iSlotIndex, exchange_packet.arg1, (WORD)exchange_packet.arg3);
-
-				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_SOCKET_SLOT_MAX_NUM; ++bSlotIdx)
-					CPythonExchange::Instance().SetItemMetinSocketToTarget(iSlotIndex, bSlotIdx, exchange_packet.alValues[bSlotIdx]);
-
-				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++bSlotIdx)
-					CPythonExchange::Instance().SetItemAttributeToTarget(iSlotIndex, bSlotIdx,
-						exchange_packet.aAttr[bSlotIdx].wType, exchange_packet.aAttr[bSlotIdx].lValue);
-
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-				CPythonExchange::Instance().SetItemChangeLookVnumToTarget(iSlotIndex, exchange_packet.dwTransmutationVnum);
-#endif
-
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-				CPythonExchange::Instance().SetItemRefineElementToTarget(iSlotIndex, exchange_packet.RefineElement);
-#endif
-
-#if defined(ENABLE_APPLY_RANDOM)
-				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_APPLY_RANDOM_SLOT_MAX_NUM; ++bSlotIdx)
-					CPythonExchange::Instance().SetItemApplyRandomToTarget(iSlotIndex, bSlotIdx,
-						exchange_packet.aApplyRandom[bSlotIdx].wType, exchange_packet.aApplyRandom[bSlotIdx].lValue);
-#endif
-
-#if defined(ENABLE_SET_ITEM)
-				CPythonExchange::Instance().SetItemSetValueToTarget(iSlotIndex, exchange_packet.bSetValue);
-#endif
-			}
-
-			__RefreshExchangeWindow();
-			__RefreshInventoryWindow();
-		}
-		break;
-
-		case EXCHANGE_SUBHEADER_GC_ITEM_DEL:
-		{
-			if (exchange_packet.is_me)
-			{
-				CPythonExchange::Instance().DelItemOfSelf((WORD)exchange_packet.arg1);
-			}
-			else
-			{
-				CPythonExchange::Instance().DelItemOfTarget((WORD)exchange_packet.arg1);
-			}
-			__RefreshExchangeWindow();
-			__RefreshInventoryWindow();
-		}
-		break;
-
-		case EXCHANGE_SUBHEADER_GC_ELK_ADD:
-		{
-			if (exchange_packet.is_me)
-				CPythonExchange::Instance().SetElkToSelf(exchange_packet.arg1);
-			else
-				CPythonExchange::Instance().SetElkToTarget(exchange_packet.arg1);
-
-			__RefreshExchangeWindow();
-		}
-		break;
-
-#if defined(ENABLE_CHEQUE_SYSTEM)
-		case EXCHANGE_SUBHEADER_GC_CHEQUE_ADD:
-		{
-			if (exchange_packet.is_me)
-				CPythonExchange::Instance().SetChequeToSelf(exchange_packet.arg1);
-			else
-				CPythonExchange::Instance().SetChequeToTarget(exchange_packet.arg1);
-
-			__RefreshExchangeWindow();
-		}
-		break;
-#endif
-
-		case EXCHANGE_SUBHEADER_GC_ACCEPT:
-		{
-			if (exchange_packet.is_me)
-			{
-				CPythonExchange::Instance().SetAcceptToSelf((BYTE)exchange_packet.arg1);
-			}
-			else
-			{
-				CPythonExchange::Instance().SetAcceptToTarget((BYTE)exchange_packet.arg1);
-			}
-			__RefreshExchangeWindow();
-		}
-		break;
-
-		case EXCHANGE_SUBHEADER_GC_END:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "EndExchange", Py_BuildValue("()"));
-			__RefreshInventoryWindow();
-			CPythonExchange::Instance().End();
-#ifdef ENABLE_GROWTH_PET_SYSTEM
-			CPythonPlayer::Instance().ClearPetExchangeData();
-#endif
-		}
-		break;
-
-		case EXCHANGE_SUBHEADER_GC_ALREADY:
-			Tracef("trade_already");
-			break;
-
-		case EXCHANGE_SUBHEADER_GC_LESS_ELK:
-			Tracef("trade_less_elk");
-			break;
-	};
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvQuestInfoPacket()
-{
-	TPacketGCQuestInfo QuestInfo;
-
-	if (!Peek(sizeof(TPacketGCQuestInfo), &QuestInfo))
-	{
-		Tracen("Recv Quest Info Packet Error #1");
-		return false;
-	}
-
-	if (!Peek(QuestInfo.size))
-	{
-		Tracen("Recv Quest Info Packet Error #2");
-		return false;
-	}
-
-	Recv(sizeof(TPacketGCQuestInfo));
-
-	const BYTE& c_rFlag = QuestInfo.flag;
-
-	enum
-	{
-		QUEST_PACKET_TYPE_NONE,
-		QUEST_PACKET_TYPE_BEGIN,
-		QUEST_PACKET_TYPE_UPDATE,
-		QUEST_PACKET_TYPE_END,
-	};
-
-	enum EQuestLen
-	{
-#if defined(ENABLE_QUEST_RENEWAL)
-		QUEST_TITLE_NAME_LEN = 50,
-#else
-		QUEST_TITLE_NAME_LEN = 30,
-#endif
-		QUEST_CLOCK_NAME_LEN = 16,
-		QUEST_COUNTER_NAME_LEN = 16,
-		QUEST_ICON_FILE_NAME_LEN = 24,
-	};
-
-	BYTE byQuestPacketType = QUEST_PACKET_TYPE_NONE;
-
-	if (0 != (c_rFlag & QUEST_SEND_IS_BEGIN))
-	{
-		BYTE isBegin;
-		if (!Recv(sizeof(isBegin), &isBegin))
-			return false;
-
-		if (isBegin)
-			byQuestPacketType = QUEST_PACKET_TYPE_BEGIN;
-		else
-			byQuestPacketType = QUEST_PACKET_TYPE_END;
-	}
-	else
-	{
-		byQuestPacketType = QUEST_PACKET_TYPE_UPDATE;
-	}
-
-	// Recv Data Start
-	char szTitle[QUEST_TITLE_NAME_LEN + 1] = "";
-	char szClockName[QUEST_CLOCK_NAME_LEN + 1] = "";
-	int iClockValue = 0;
-	char szCounterName[QUEST_COUNTER_NAME_LEN + 1] = "";
-	int iCounterValue = 0;
-	char szIconFileName[QUEST_ICON_FILE_NAME_LEN + 1] = "";
-
-	if (0 != (c_rFlag & QUEST_SEND_TITLE))
-	{
-		if (!Recv(sizeof(szTitle), &szTitle))
-			return false;
-
-		szTitle[QUEST_TITLE_NAME_LEN] = '\0';
-#if defined(ENABLE_LOCALE_CLIENT)
-		CPythonLocale::Instance().FormatString(szTitle, sizeof(szTitle));
-#endif
-	}
-
-	if (0 != (c_rFlag & QUEST_SEND_CLOCK_NAME))
-	{
-		if (!Recv(sizeof(szClockName), &szClockName))
-			return false;
-
-		szClockName[QUEST_CLOCK_NAME_LEN] = '\0';
-#if defined(ENABLE_LOCALE_CLIENT)
-		CPythonLocale::Instance().FormatString(szClockName, sizeof(szClockName));
-#endif
-	}
-
-	if (0 != (c_rFlag & QUEST_SEND_CLOCK_VALUE))
-	{
-		if (!Recv(sizeof(iClockValue), &iClockValue))
-			return false;
-	}
-
-	if (0 != (c_rFlag & QUEST_SEND_COUNTER_NAME))
-	{
-		if (!Recv(sizeof(szCounterName), &szCounterName))
-			return false;
-
-		szCounterName[QUEST_COUNTER_NAME_LEN] = '\0';
-#if defined(ENABLE_LOCALE_CLIENT)
-		CPythonLocale::Instance().FormatString(szCounterName, sizeof(szCounterName));
-#endif
-	}
-
-	if (0 != (c_rFlag & QUEST_SEND_COUNTER_VALUE))
-	{
-		if (!Recv(sizeof(iCounterValue), &iCounterValue))
-			return false;
-	}
-
-	if (0 != (c_rFlag & QUEST_SEND_ICON_FILE))
-	{
-		if (!Recv(sizeof(szIconFileName), &szIconFileName))
-			return false;
-
-		szIconFileName[QUEST_ICON_FILE_NAME_LEN] = '\0';
-	}
-	// Recv Data End
-
-	CPythonQuest& rkQuest = CPythonQuest::Instance();
-
-	// Process Start
-	if (QUEST_PACKET_TYPE_END == byQuestPacketType)
-	{
-		rkQuest.DeleteQuestInstance(QuestInfo.index);
-#if defined(ENABLE_QUEST_RENEWAL)
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "DeleteQuest", Py_BuildValue("(ii)", QuestInfo.type, QuestInfo.index));
-#endif
-	}
-	else if (QUEST_PACKET_TYPE_UPDATE == byQuestPacketType)
-	{
-		if (!rkQuest.IsQuest(QuestInfo.index))
-		{
-#if defined(ENABLE_QUEST_RENEWAL)
-			rkQuest.MakeQuest(QuestInfo.index, QuestInfo.type, QuestInfo.is_confirmed);
-#else
-			rkQuest.MakeQuest(QuestInfo.index);
-#endif
-		}
-
-		if (strlen(szTitle) > 0)
-			rkQuest.SetQuestTitle(QuestInfo.index, szTitle);
-		if (strlen(szClockName) > 0)
-			rkQuest.SetQuestClockName(QuestInfo.index, szClockName);
-		if (strlen(szCounterName) > 0)
-			rkQuest.SetQuestCounterName(QuestInfo.index, szCounterName);
-		if (strlen(szIconFileName) > 0)
-			rkQuest.SetQuestIconFileName(QuestInfo.index, szIconFileName);
-
-		if (c_rFlag & QUEST_SEND_CLOCK_VALUE)
-			rkQuest.SetQuestClockValue(QuestInfo.index, iClockValue);
-		if (c_rFlag & QUEST_SEND_COUNTER_VALUE)
-			rkQuest.SetQuestCounterValue(QuestInfo.index, iCounterValue);
-
-#if defined(ENABLE_QUEST_RENEWAL)
-		rkQuest.SetQuestIsConfirmed(QuestInfo.index, QuestInfo.is_confirmed);
-#endif
-	}
-	else if (QUEST_PACKET_TYPE_BEGIN == byQuestPacketType)
-	{
-		CPythonQuest::SQuestInstance QuestInstance;
-		QuestInstance.dwIndex = QuestInfo.index;
-		QuestInstance.strTitle = szTitle;
-		QuestInstance.strClockName = szClockName;
-		QuestInstance.iClockValue = iClockValue;
-		QuestInstance.strCounterName = szCounterName;
-		QuestInstance.iCounterValue = iCounterValue;
-		QuestInstance.strIconFileName = szIconFileName;
-		//CPythonQuest::Instance().RegisterQuestInstance(QuestInstance);
-		rkQuest.RegisterQuestInstance(QuestInstance);
-	}
-	// Process Start End
-
-#if defined(ENABLE_QUEST_RENEWAL)
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshQuest", Py_BuildValue("(ii)", QuestInfo.type, QuestInfo.index));
-#else
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshQuest", Py_BuildValue("()"));
-#endif
-	return true;
-}
-
-bool CPythonNetworkStream::RecvQuestConfirmPacket()
-{
-	TPacketGCQuestConfirm kQuestConfirmPacket;
-	if (!Recv(sizeof(kQuestConfirmPacket), &kQuestConfirmPacket))
-	{
-		Tracen("RecvQuestConfirmPacket Error");
-		return false;
-	}
-
-#if defined(ENABLE_LOCALE_CLIENT)
-	CPythonLocale::Instance().FormatString(kQuestConfirmPacket.msg, sizeof(kQuestConfirmPacket.msg));
-#endif
-
-	PyObject* poArg = Py_BuildValue("(sii)", kQuestConfirmPacket.msg, kQuestConfirmPacket.timeout, kQuestConfirmPacket.requestPID);
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_OnQuestConfirm", poArg);
-	return true;
-}
-
-bool CPythonNetworkStream::RecvRequestMakeGuild()
-{
-	TPacketGCBlank blank;
-	if (!Recv(sizeof(blank), &blank))
-	{
-		Tracen("RecvRequestMakeGuild Packet Error");
-		return false;
-	}
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AskGuildName", Py_BuildValue("()"));
-
-	return true;
-}
-
-void CPythonNetworkStream::ToggleGameDebugInfo()
-{
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ToggleDebugInfo", Py_BuildValue("()"));
-}
-
-bool CPythonNetworkStream::SendExchangeStartPacket(DWORD vid)
-{
-	if (!__CanActMainInstance())
-		return true;
-
-	TPacketCGExchange	packet;
-
-	packet.header = HEADER_CG_EXCHANGE;
-	packet.subheader = EXCHANGE_SUBHEADER_CG_START;
-	packet.arg1 = vid;
-
-	if (!Send(sizeof(packet), &packet))
-	{
-		Tracef("send_trade_start_packet Error\n");
-		return false;
-	}
-
-	Tracef("send_trade_start_packet vid %d \n", vid);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendExchangeElkAddPacket(DWORD elk)
-{
-	if (!__CanActMainInstance())
-		return true;
-
-	TPacketCGExchange	packet;
-
-	packet.header = HEADER_CG_EXCHANGE;
-	packet.subheader = EXCHANGE_SUBHEADER_CG_ELK_ADD;
-	packet.arg1 = elk;
-
-	if (!Send(sizeof(packet), &packet))
-	{
-		Tracef("send_trade_elk_add_packet Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-#if defined(ENABLE_CHEQUE_SYSTEM)
-bool CPythonNetworkStream::SendExchangeChequeAddPacket(DWORD cheque)
-{
-	if (!__CanActMainInstance())
-		return true;
-
-	TPacketCGExchange	packet;
-
-	packet.header = HEADER_CG_EXCHANGE;
-	packet.subheader = EXCHANGE_SUBHEADER_CG_CHEQUE_ADD;
-	packet.arg1 = cheque;
-
-	if (!Send(sizeof(packet), &packet))
-	{
-		Tracef("send_trade_cheque_add_packet Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-#endif
-
-bool CPythonNetworkStream::SendExchangeItemAddPacket(TItemPos ItemPos, BYTE byDisplayPos)
-{
-	if (!__CanActMainInstance())
-		return true;
-
-	TPacketCGExchange	packet;
-
-	packet.header = HEADER_CG_EXCHANGE;
-	packet.subheader = EXCHANGE_SUBHEADER_CG_ITEM_ADD;
-	packet.Pos = ItemPos;
-	packet.arg2 = byDisplayPos;
-
-	if (!Send(sizeof(packet), &packet))
-	{
-		Tracef("send_trade_item_add_packet Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendExchangeItemDelPacket(BYTE pos)
-{
-	assert(!"Can't be called function - CPythonNetworkStream::SendExchangeItemDelPacket");
-	return true;
-
-	if (!__CanActMainInstance())
-		return true;
-
-	TPacketCGExchange	packet;
-
-	packet.header = HEADER_CG_EXCHANGE;
-	packet.subheader = EXCHANGE_SUBHEADER_CG_ITEM_DEL;
-	packet.arg1 = pos;
-
-	if (!Send(sizeof(packet), &packet))
-	{
-		Tracef("send_trade_item_del_packet Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendExchangeAcceptPacket()
-{
-	if (!__CanActMainInstance())
-		return true;
-
-	TPacketCGExchange	packet;
-
-	packet.header = HEADER_CG_EXCHANGE;
-	packet.subheader = EXCHANGE_SUBHEADER_CG_ACCEPT;
-
-	if (!Send(sizeof(packet), &packet))
-	{
-		Tracef("send_trade_accept_packet Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendExchangeExitPacket()
-{
-	if (!__CanActMainInstance())
-		return true;
-
-	TPacketCGExchange	packet;
-
-	packet.header = HEADER_CG_EXCHANGE;
-	packet.subheader = EXCHANGE_SUBHEADER_CG_CANCEL;
-
-	if (!Send(sizeof(packet), &packet))
-	{
-		Tracef("send_trade_exit_packet Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-// PointReset °³ÀÓ½Ã
-bool CPythonNetworkStream::SendPointResetPacket()
-{
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartPointReset", Py_BuildValue("()"));
-	return true;
-}
-
-bool CPythonNetworkStream::__IsPlayerAttacking()
-{
-	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
-	CInstanceBase* pkInstMain = rkChrMgr.GetMainInstancePtr();
-
-	if (!pkInstMain)
-		return false;
-
-	if (!pkInstMain->IsAttacking())
-		return false;
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvScriptPacket()
-{
-	TPacketGCScript ScriptPacket;
-
-	if (!Recv(sizeof(TPacketGCScript), &ScriptPacket))
-	{
-		TraceError("RecvScriptPacket_RecvError");
-		return false;
-	}
-
-	if (ScriptPacket.size < sizeof(TPacketGCScript))
-	{
-		TraceError("RecvScriptPacket_SizeError");
-		return false;
-	}
-
-	ScriptPacket.size -= sizeof(TPacketGCScript);
-
-	static std::string str;
-	str = "";
-	str.resize(ScriptPacket.size + 1);
-
-	if (!Recv(ScriptPacket.size, &str[0]))
-		return false;
-
-	str[str.size() - 1] = '\0';
-#if defined(ENABLE_LOCALE_CLIENT)
-	CPythonLocale::Instance().FormatString(str);
-#endif
-
-	int iIndex = CPythonEventManager::Instance().RegisterEventSetFromString(str);
-
-	if (-1 != iIndex)
-	{
-		CPythonEventManager::Instance().SetVisibleLineCount(iIndex, CPythonEventManager::QUEST_VISIBLE_LINE_COUNT);
-		CPythonNetworkStream::Instance().OnScriptEventStart(ScriptPacket.skin, iIndex);
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendScriptAnswerPacket(int iAnswer)
-{
-	TPacketCGScriptAnswer ScriptAnswer;
-
-	ScriptAnswer.header = HEADER_CG_SCRIPT_ANSWER;
-	ScriptAnswer.answer = (BYTE)iAnswer;
-	if (!Send(sizeof(TPacketCGScriptAnswer), &ScriptAnswer))
-	{
-		Tracen("Send Script Answer Packet Error");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendScriptButtonPacket(unsigned int iIndex)
-{
-	TPacketCGScriptButton ScriptButton;
-
-	ScriptButton.header = HEADER_CG_SCRIPT_BUTTON;
-	ScriptButton.idx = iIndex;
-	if (!Send(sizeof(TPacketCGScriptButton), &ScriptButton))
-	{
-		Tracen("Send Script Button Packet Error");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendAnswerMakeGuildPacket(const char* c_szName)
-{
-	TPacketCGAnswerMakeGuild Packet;
-
-	Packet.header = HEADER_CG_ANSWER_MAKE_GUILD;
-	strncpy(Packet.guild_name, c_szName, GUILD_NAME_MAX_LEN);
-	Packet.guild_name[GUILD_NAME_MAX_LEN] = '\0';
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracen("SendAnswerMakeGuild Packet Error");
-		return false;
-	}
-
-	//Tracef("SendAnswerMakeGuildPacket : %s", c_szName);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendQuestInputStringPacket(const char* c_szString)
-{
-	TPacketCGQuestInputString Packet;
-	Packet.bHeader = HEADER_CG_QUEST_INPUT_STRING;
-	strncpy(Packet.szString, c_szString, QUEST_INPUT_STRING_MAX_NUM);
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracen("SendQuestInputStringPacket Error");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-#if defined(ENABLE_OX_RENEWAL)
-bool CPythonNetworkStream::SendQuestInputStringLongPacket(const char* c_szString)
-{
-	TPacketCGQuestInputLongString Packet;
-	Packet.bHeader = HEADER_CG_QUEST_INPUT_LONG_STRING;
-	strncpy(Packet.szString, c_szString, QUEST_INPUT_LONG_STRING_MAX_NUM);
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracen("SendQuestInputLongStringPacket Error");
-		return false;
-	}
-
-	return SendSequence();
-}
-#endif
-
-bool CPythonNetworkStream::SendQuestConfirmPacket(BYTE byAnswer, DWORD dwPID)
-{
-	TPacketCGQuestConfirm kPacket;
-	kPacket.header = HEADER_CG_QUEST_CONFIRM;
-	kPacket.answer = byAnswer;
-	kPacket.requestPID = dwPID;
-
-	if (!Send(sizeof(kPacket), &kPacket))
-	{
-		Tracen("SendQuestConfirmPacket Error");
-		return false;
-	}
-
-	Tracenf("SendQuestConfirmPacket : %d, %d", byAnswer, dwPID);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvSkillLevel()
-{
-	assert(!"CPythonNetworkStream::RecvSkillLevel - »ç¿ëÇÏÁö ¾Ê´Â ÇÔ¼ö");
-	TPacketGCSkillLevel packet;
-	if (!Recv(sizeof(TPacketGCSkillLevel), &packet))
-	{
-		Tracen("CPythonNetworkStream::RecvSkillLevel - RecvError");
-		return false;
-	}
-
-	DWORD dwSlotIndex;
-
-	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
-	for (int i = 0; i < SKILL_MAX_NUM; ++i)
-	{
-		if (rkPlayer.GetSkillSlotIndex(i, &dwSlotIndex))
-			rkPlayer.SetSkillLevel(dwSlotIndex, packet.abSkillLevels[i]);
-	}
-
-	__RefreshSkillWindow();
-	__RefreshStatus();
-	Tracef(" >> RecvSkillLevel\n");
-	return true;
-}
-
-bool CPythonNetworkStream::RecvSkillLevelNew()
-{
-	TPacketGCSkillLevelNew packet;
-
-	if (!Recv(sizeof(TPacketGCSkillLevelNew), &packet))
-	{
-		Tracen("CPythonNetworkStream::RecvSkillLevelNew - RecvError");
-		return false;
-	}
-
-	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
-
-	rkPlayer.SetSkill(7, 0);
-	rkPlayer.SetSkill(8, 0);
-#if defined(ENABLE_CONQUEROR_LEVEL)
-	if (!rkPlayer.GetStatus(POINT_CONQUEROR_LEVEL))
-		rkPlayer.SetSkill(9, 0);
-#endif
-
-	for (int i = 0; i < SKILL_MAX_NUM; ++i)
-	{
-		const TPlayerSkill& rPlayerSkill = packet.skills[i];
-
-		if (i >= 112 && i <= 115 && rPlayerSkill.bLevel)
-			rkPlayer.SetSkill(7, i);
-
-		if (i >= 116 && i <= 119 && rPlayerSkill.bLevel)
-			rkPlayer.SetSkill(8, i);
-
-#if defined(ENABLE_678TH_SKILL)
-		if (i >= 221 && i <= 229 && rPlayerSkill.bLevel)
-			rkPlayer.SetSkill(7, i);
-
-		if (i >= 236 && i <= 244 && rPlayerSkill.bLevel)
-			rkPlayer.SetSkill(8, i);
-#endif
-
-		rkPlayer.SetSkillLevel_(i, rPlayerSkill.bMasterType, rPlayerSkill.bLevel);
-	}
-
-	__RefreshSkillWindow();
-	__RefreshStatus();
-	//Tracef(" >> RecvSkillLevelNew\n");
-	return true;
-}
-
-bool CPythonNetworkStream::RecvDamageInfoPacket()
-{
-	TPacketGCDamageInfo DamageInfoPacket;
-
-	if (!Recv(sizeof(TPacketGCDamageInfo), &DamageInfoPacket))
-	{
-		Tracen("Recv Target Packet Error");
-		return false;
-	}
-
-	CInstanceBase* pInstTarget = CPythonCharacterManager::Instance().GetInstancePtr(DamageInfoPacket.dwVID);
-	bool bSelf = (pInstTarget == CPythonCharacterManager::Instance().GetMainInstancePtr());
-	bool bTarget = (pInstTarget == m_pInstTarget);
-	if (pInstTarget)
-	{
-		if (DamageInfoPacket.damage >= 0)
-			pInstTarget->AddDamageEffect(DamageInfoPacket.damage, DamageInfoPacket.flag, bSelf, bTarget);
-		else
-			TraceError("Damage is equal or below 0.");
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvTargetPacket()
-{
-	TPacketGCTarget TargetPacket;
-
-	if (!Recv(sizeof(TPacketGCTarget), &TargetPacket))
-	{
-		Tracen("Recv Target Packet Error");
-		return false;
-	}
-
-#if defined(ENABLE_DEFENSE_WAVE)
-	if (TargetPacket.bAlliance)
-	{
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetHPAllianceTargetBoard",
-			Py_BuildValue("(iii)", TargetPacket.dwVID, TargetPacket.iMinHP, TargetPacket.iMaxHP));
-		return true;
-	}
-#endif
-
-	CInstanceBase* pInstPlayer = CPythonCharacterManager::Instance().GetMainInstancePtr();
-	CInstanceBase* pInstTarget = CPythonCharacterManager::Instance().GetInstancePtr(TargetPacket.dwVID);
-	if (pInstPlayer && pInstTarget)
-	{
-		if (!pInstTarget->IsDead())
-		{
-#if defined(ENABLE_VIEW_TARGET_PLAYER_HP)
-			if (pInstTarget->IsBuilding())
-#else
-			if (pInstTarget->IsPC() || pInstTarget->IsBuilding())
-#endif
-			{
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoardIfDifferent", Py_BuildValue("(i)", TargetPacket.dwVID));
-			}
-			else if (pInstPlayer->CanViewTargetHP(*pInstTarget))
-			{
-#if defined(ENABLE_VIEW_TARGET_DECIMAL_HP)
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetHPTargetBoard", Py_BuildValue("(iiii)", TargetPacket.dwVID, TargetPacket.bHPPercent, TargetPacket.iMinHP, TargetPacket.iMaxHP));
-#else
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetHPTargetBoard", Py_BuildValue("(ii)", TargetPacket.dwVID, TargetPacket.bHPPercent));
-#endif
-
-#if defined(ENABLE_ELEMENT_ADD)
-				PyObject* poDict = PyDict_New();
-				for (BYTE bElementIndex = 0; bElementIndex < CPythonNonPlayer::MOB_ELEMENT_MAX_NUM; ++bElementIndex)
-				{
-					PyDict_SetItem(poDict,
-						Py_BuildValue("i", bElementIndex),
-						Py_BuildValue("i", TargetPacket.bElement[bElementIndex]));
-				}
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ShowTargetElementEnchant", Py_BuildValue("(O)", poDict));
-				Py_DECREF(poDict);
-#endif
-			}
-			else
-			{
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoard", Py_BuildValue("()"));
-			}
-
-			m_pInstTarget = pInstTarget;
-		}
-	}
-	else
-	{
-		CPythonPlayer::Instance().SetTarget(0);
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoard", Py_BuildValue("()"));
-	}
-
-	return true;
-}
-
-#if defined(ENABLE_SEND_TARGET_INFO)
-bool CPythonNetworkStream::RecvTargetInfoPacket()
-{
-	TPacketGCTargetInfo TargetInfoPacket;
-	if (!Recv(sizeof(TPacketGCTargetInfo), &TargetInfoPacket))
-	{
-		Tracen("Recv TargetInfo Packet Error");
-		return false;
-	}
-
-	CPythonNonPlayer::Instance().ClearItemDrop();
-
-	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(TargetInfoPacket.dwVID);
-	if (pInstance && (pInstance->IsEnemy() || pInstance->IsStone() && !pInstance->IsDead()))
-	{
-		UINT uiPacketSize = (TargetInfoPacket.wSize - sizeof(TPacketGCTargetInfo));
-		for (; uiPacketSize > 0; uiPacketSize -= sizeof(TPacketGCTargetDropInfo))
-		{
-			TPacketGCTargetDropInfo TargetDropInfoPacket;
-			if (!Recv(sizeof(TargetDropInfoPacket), &TargetDropInfoPacket))
-				return false;
-
-			CPythonNonPlayer::Instance().AddItemDrop(
-				TargetInfoPacket.dwRaceVnum,
-				TargetDropInfoPacket.dwVnum,
-				TargetDropInfoPacket.bCount
-			);
-		}
-
-		CPythonNonPlayer::Instance().SetDropMetinStone(TargetInfoPacket.bDropMetinStone);
-	}
-	else
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoard", Py_BuildValue("()"));
-
-	return true;
-}
-#endif
-
-bool CPythonNetworkStream::RecvMountPacket()
-{
-	TPacketGCMount MountPacket;
-
-	if (!Recv(sizeof(TPacketGCMount), &MountPacket))
-	{
-		Tracen("Recv Mount Packet Error");
-		return false;
-	}
-
-	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(MountPacket.vid);
-
-	if (pInstance)
-	{
-		// Mount
-		if (0 != MountPacket.mount_vid)
-		{
-			//pInstance->Ride(MountPacket.pos, MountPacket.mount_vid);
-		}
-		// Unmount
-		else
-		{
-			//pInstance->Unride(MountPacket.pos, MountPacket.x, MountPacket.y);
-		}
-	}
-
-	if (CPythonPlayer::Instance().IsMainCharacterIndex(MountPacket.vid))
-	{
-		//CPythonPlayer::Instance().SetRidingVehicleIndex(MountPacket.mount_vid);
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvChangeSpeedPacket()
-{
-	TPacketGCChangeSpeed SpeedPacket;
-
-	if (!Recv(sizeof(TPacketGCChangeSpeed), &SpeedPacket))
-	{
-		Tracen("Recv Speed Packet Error");
-		return false;
-	}
-
-	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(SpeedPacket.vid);
-
-	if (!pInstance)
-		return true;
-
-	//pInstance->SetWalkSpeed(SpeedPacket.walking_speed);
-	//pInstance->SetRunSpeed(SpeedPacket.running_speed);
-	return true;
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////////////
-// Recv
-bool CPythonNetworkStream::SendAttackPacket(UINT uMotAttack, DWORD dwVIDVictim)
-{
-	if (!__CanActMainInstance())
-		return true;
-
-#ifdef ATTACK_TIME_LOG
-	static DWORD prevTime = timeGetTime();
-	DWORD curTime = timeGetTime();
-	TraceError("TIME: %.4f(%.4f) ATTACK_PACKET: %d TARGET: %d", curTime / 1000.0f, (curTime - prevTime) / 1000.0f, uMotAttack, dwVIDVictim);
-	prevTime = curTime;
-#endif
-
-	TPacketCGAttack kPacketAtk;
-	kPacketAtk.header = HEADER_CG_ATTACK;
-	kPacketAtk.bType = uMotAttack;
-	kPacketAtk.dwVictimVID = dwVIDVictim;
-
-	if (!SendSpecial(sizeof(kPacketAtk), &kPacketAtk))
-	{
-		Tracen("Send Battle Attack Packet Error");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendSpecial(int nLen, void* pvBuf)
-{
-	BYTE bHeader = *(BYTE*)pvBuf;
-
-	switch (bHeader)
-	{
-		case HEADER_CG_ATTACK:
-		{
-			TPacketCGAttack* pkPacketAtk = (TPacketCGAttack*)pvBuf;
-			pkPacketAtk->bCRCMagicCubeProcPiece = GetProcessCRCMagicCubePiece();
-			pkPacketAtk->bCRCMagicCubeFilePiece = GetProcessCRCMagicCubePiece();
-			return Send(nLen, pvBuf);
-		}
-		break;
-	}
-
-	return Send(nLen, pvBuf);
-}
-
-bool CPythonNetworkStream::RecvAddFlyTargetingPacket()
-{
-	TPacketGCFlyTargeting kPacket;
-	if (!Recv(sizeof(kPacket), &kPacket))
-		return false;
-
-	__GlobalPositionToLocalPosition(kPacket.lX, kPacket.lY);
-
-	Tracef("VID [%d]°¡ Å¸°ÙÀ» Ãß°¡ ¼³Á¤\n", kPacket.dwShooterVID);
-
-	CPythonCharacterManager& rpcm = CPythonCharacterManager::Instance();
-
-	CInstanceBase* pShooter = rpcm.GetInstancePtr(kPacket.dwShooterVID);
-
-	if (!pShooter)
-	{
-#ifndef _DEBUG
-		TraceError("CPythonNetworkStream::RecvFlyTargetingPacket() - dwShooterVID[%d] NOT EXIST", kPacket.dwShooterVID);
-#endif
-		return true;
-	}
-
-	CInstanceBase* pTarget = rpcm.GetInstancePtr(kPacket.dwTargetVID);
-
-	if (kPacket.dwTargetVID && pTarget)
-	{
-		pShooter->GetGraphicThingInstancePtr()->AddFlyTarget(pTarget->GetGraphicThingInstancePtr());
-	}
-	else
-	{
-		float h = CPythonBackground::Instance().GetHeight(kPacket.lX, kPacket.lY) + 60.0f; // TEMPORARY HEIGHT
-		pShooter->GetGraphicThingInstancePtr()->AddFlyTarget(D3DXVECTOR3(kPacket.lX, kPacket.lY, h));
-		//pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(kPacket.kPPosTarget.x,kPacket.kPPosTarget.y,);
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvFlyTargetingPacket()
-{
-	TPacketGCFlyTargeting kPacket;
-	if (!Recv(sizeof(kPacket), &kPacket))
-		return false;
-
-	__GlobalPositionToLocalPosition(kPacket.lX, kPacket.lY);
-
-	//Tracef("CPythonNetworkStream::RecvFlyTargetingPacket - VID [%d]\n",kPacket.dwShooterVID);
-
-	CPythonCharacterManager& rpcm = CPythonCharacterManager::Instance();
-
-	CInstanceBase* pShooter = rpcm.GetInstancePtr(kPacket.dwShooterVID);
-
-	if (!pShooter)
-	{
-#ifdef _DEBUG
-		TraceError("CPythonNetworkStream::RecvFlyTargetingPacket() - dwShooterVID[%d] NOT EXIST", kPacket.dwShooterVID);
-#endif
-		return true;
-	}
-
-	CInstanceBase* pTarget = rpcm.GetInstancePtr(kPacket.dwTargetVID);
-
-	if (kPacket.dwTargetVID && pTarget)
-	{
-		pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(pTarget->GetGraphicThingInstancePtr());
-	}
-	else
-	{
-		float h = CPythonBackground::Instance().GetHeight(kPacket.lX, kPacket.lY) + 60.0f; // TEMPORARY HEIGHT
-		pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(D3DXVECTOR3(kPacket.lX, kPacket.lY, h));
-		//pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(kPacket.kPPosTarget.x,kPacket.kPPosTarget.y,);
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendShootPacket(UINT uSkill)
-{
-	TPacketCGShoot kPacketShoot;
-	kPacketShoot.bHeader = HEADER_CG_SHOOT;
-	kPacketShoot.bType = uSkill;
-
-	if (!Send(sizeof(kPacketShoot), &kPacketShoot))
-	{
-		Tracen("SendShootPacket Error");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendAddFlyTargetingPacket(DWORD dwTargetVID, const TPixelPosition& kPPosTarget)
-{
-	TPacketCGFlyTargeting packet;
-
-	//CPythonCharacterManager & rpcm = CPythonCharacterManager::Instance();
-
-	packet.bHeader = HEADER_CG_ADD_FLY_TARGETING;
-	packet.dwTargetVID = dwTargetVID;
-	packet.lX = kPPosTarget.x;
-	packet.lY = kPPosTarget.y;
-
-	__LocalPositionToGlobalPosition(packet.lX, packet.lY);
-
-	if (!Send(sizeof(packet), &packet))
-	{
-		Tracen("Send FlyTargeting Packet Error");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendFlyTargetingPacket(DWORD dwTargetVID, const TPixelPosition& kPPosTarget)
-{
-	TPacketCGFlyTargeting packet;
-
-	//CPythonCharacterManager & rpcm = CPythonCharacterManager::Instance();
-
-	packet.bHeader = HEADER_CG_FLY_TARGETING;
-	packet.dwTargetVID = dwTargetVID;
-	packet.lX = kPPosTarget.x;
-	packet.lY = kPPosTarget.y;
-
-	__LocalPositionToGlobalPosition(packet.lX, packet.lY);
-
-	if (!Send(sizeof(packet), &packet))
-	{
-		Tracen("Send FlyTargeting Packet Error");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvCreateFlyPacket()
-{
-	TPacketGCCreateFly kPacket;
-	if (!Recv(sizeof(TPacketGCCreateFly), &kPacket))
-		return false;
-
-	CFlyingManager& rkFlyMgr = CFlyingManager::Instance();
-	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
-
-	CInstanceBase* pkStartInst = rkChrMgr.GetInstancePtr(kPacket.dwStartVID);
-	CInstanceBase* pkEndInst = rkChrMgr.GetInstancePtr(kPacket.dwEndVID);
-	if (!pkStartInst || !pkEndInst)
-		return true;
-
-	rkFlyMgr.CreateIndexedFly(kPacket.bType, pkStartInst->GetGraphicThingInstancePtr(), pkEndInst->GetGraphicThingInstancePtr());
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendTargetPacket(DWORD dwVID)
-{
-	TPacketCGTarget packet;
-	packet.header = HEADER_CG_TARGET;
-	packet.dwVID = dwVID;
-
-	if (!Send(sizeof(packet), &packet))
-	{
-		Tracen("Send Target Packet Error");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendSyncPositionElementPacket(DWORD dwVictimVID, DWORD dwVictimX, DWORD dwVictimY)
-{
-	TPacketCGSyncPositionElement kSyncPos;
-	kSyncPos.dwVID = dwVictimVID;
-	kSyncPos.lX = dwVictimX;
-	kSyncPos.lY = dwVictimY;
-
-	__LocalPositionToGlobalPosition(kSyncPos.lX, kSyncPos.lY);
-
-	if (!Send(sizeof(kSyncPos), &kSyncPos))
-	{
-		Tracen("CPythonNetworkStream::SendSyncPositionElementPacket - ERROR");
-		return false;
-	}
-
-	return true;
-}
-
-//////////////////////////////////////////////////////////////////////////
-// Messenger
-
-bool CPythonNetworkStream::SendMessengerAddByVIDPacket(const DWORD c_dwVID)
-{
-	TPacketCGMessenger Packet;
-	Packet.bHeader = HEADER_CG_MESSENGER;
-	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_ADD_BY_VID;
-	if (!Send(sizeof(Packet), &Packet))
-		return false;
-
-	if (!Send(sizeof(c_dwVID), &c_dwVID))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMessengerAddByNamePacket(const char* c_szName)
-{
-	TPacketCGMessenger Packet;
-	Packet.bHeader = HEADER_CG_MESSENGER;
-	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_ADD_BY_NAME;
-	if (!Send(sizeof(Packet), &Packet))
-		return false;
-
-	char szName[CHARACTER_NAME_MAX_LEN] = {};
-	strncpy(szName, c_szName, CHARACTER_NAME_MAX_LEN - 1);
-	szName[CHARACTER_NAME_MAX_LEN - 1] = '\0'; // #720: ¸Þ½ÅÀú ÀÌ¸§ °ü·Ã ¹öÆÛ ¿À¹öÇÃ·Î¿ì ¹ö±× ¼öÁ¤
-
-	if (!Send(sizeof(szName), &szName))
-		return false;
-
-	Tracef(" SendMessengerAddByNamePacket : %s\n", c_szName);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMessengerRemovePacket(const char* c_szKey, const char* c_szName)
-{
-	TPacketCGMessenger Packet;
-	Packet.bHeader = HEADER_CG_MESSENGER;
-	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_REMOVE;
-	if (!Send(sizeof(Packet), &Packet))
-		return false;
-
-	char szKey[CHARACTER_NAME_MAX_LEN] = {};
-	strncpy(szKey, c_szKey, CHARACTER_NAME_MAX_LEN - 1);
-	if (!Send(sizeof(szKey), &szKey))
-		return false;
-
-	__RefreshTargetBoardByName(c_szName);
-	return SendSequence();
-}
-
-#if defined(ENABLE_MESSENGER_BLOCK)
-bool CPythonNetworkStream::SendMessengerBlockAddByVIDPacket(const DWORD c_dwVID)
-{
-	TPacketCGMessenger Packet;
-	Packet.bHeader = HEADER_CG_MESSENGER;
-	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID;
-	if (!Send(sizeof(Packet), &Packet))
-		return false;
-
-	if (!Send(sizeof(c_dwVID), &c_dwVID))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMessengerBlockAddByNamePacket(const char* c_szName)
-{
-	TPacketCGMessenger Packet;
-	Packet.bHeader = HEADER_CG_MESSENGER;
-	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME;
-	if (!Send(sizeof(Packet), &Packet))
-		return false;
-
-	char szName[CHARACTER_NAME_MAX_LEN] = {};
-	strncpy(szName, c_szName, CHARACTER_NAME_MAX_LEN - 1);
-	szName[CHARACTER_NAME_MAX_LEN - 1] = '\0';
-
-	if (!Send(sizeof(szName), &szName))
-		return false;
-
-	Tracef(" SendMessengerBlockAddByNamePacket : %s\n", c_szName);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMessengerBlockRemovePacket(const char* c_szKey, const char* c_szName)
-{
-	TPacketCGMessenger Packet;
-	Packet.bHeader = HEADER_CG_MESSENGER;
-	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_BLOCK_REMOVE;
-	if (!Send(sizeof(Packet), &Packet))
-		return false;
-
-	char szKey[CHARACTER_NAME_MAX_LEN];
-	strncpy(szKey, c_szKey, CHARACTER_NAME_MAX_LEN - 1);
-	if (!Send(sizeof(szKey), &szKey))
-		return false;
-
-	CPythonMessenger::Instance().RemoveBlock(szKey);
-	__RefreshTargetBoardByName(c_szName);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMessengerBlockRemoveByVIDPacket(DWORD c_dwVID)
-{
-	TPacketCGMessenger Packet;
-	Packet.bHeader = HEADER_CG_MESSENGER;
-	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_BLOCK_REMOVE;
-	if (!Send(sizeof(Packet), &Packet))
-		return false;
-
-	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(c_dwVID);
-
-	char szKey[CHARACTER_NAME_MAX_LEN];
-	strncpy(szKey, pInstance->GetNameString(), CHARACTER_NAME_MAX_LEN - 1);
-	if (!Send(sizeof(szKey), &szKey))
-		return false;
-
-	CPythonMessenger::Instance().RemoveBlock(szKey);
-	__RefreshTargetBoardByName(pInstance->GetNameString());
-	return SendSequence();
-}
-#endif
-
-bool CPythonNetworkStream::RecvMessenger()
-{
-	TPacketGCMessenger Packet;
-	if (!Recv(sizeof(Packet), &Packet))
-		return false;
-
-	UINT uiPacketSize = (Packet.wSize - sizeof(TPacketGCMessenger));
-	for (; uiPacketSize > 0; uiPacketSize -= sizeof(TPacketGCMessengerList))
-	{
-		TPacketGCMessengerList ListPacket;
-		if (!Recv(sizeof(ListPacket), &ListPacket))
-			return false;
-
-		switch (Packet.bSubHeader)
-		{
-			case MESSENGER_SUBHEADER_GC_LIST:
-			{
-				if (ListPacket.bConnected & MESSENGER_CONNECTED_STATE_ONLINE)
-				{
-#if defined(ENABLE_MESSENGER_DETAILS)
-					CPythonMessenger::Instance().OnFriendLogin(ListPacket.szName
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-						, ListPacket.szCountry
-#endif
-					);
-#else
-					CPythonMessenger::Instance().OnFriendLogin(ListPacket.szName);
-#endif
-				}
-				else
-				{
-#if defined(ENABLE_MESSENGER_DETAILS)
-					CPythonMessenger::Instance().OnFriendLogout(ListPacket.szName, ListPacket.dwLastPlayTime
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-						, ListPacket.szCountry
-#endif
-					);
-#else
-					CPythonMessenger::Instance().OnFriendLogout(ListPacket.szName);
-#endif
-				}
-			}
-			break;
-
-			case MESSENGER_SUBHEADER_GC_LOGIN:
-			{
-#if defined(ENABLE_MESSENGER_DETAILS)
-				CPythonMessenger::Instance().OnFriendLogin(ListPacket.szName
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-					, ListPacket.szCountry
-#endif
-				);
-#else
-				CPythonMessenger::Instance().OnFriendLogin(ListPacket.szName);
-#endif
-				__RefreshTargetBoardByName(ListPacket.szName);
-			}
-			break;
-
-			case MESSENGER_SUBHEADER_GC_LOGOUT:
-#if defined(ENABLE_MESSENGER_DETAILS)
-				CPythonMessenger::Instance().OnFriendLogout(ListPacket.szName, ListPacket.dwLastPlayTime
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-					, ListPacket.szCountry
-#endif
-				);
-#else
-				CPythonMessenger::Instance().OnFriendLogout(ListPacket.szName);
-#endif
-				break;
-
-#if defined(ENABLE_MESSENGER_GM)
-			case MESSENGER_SUBHEADER_GC_GM_LIST:
-			{
-				if (ListPacket.bConnected & MESSENGER_CONNECTED_STATE_ONLINE)
-					CPythonMessenger::Instance().OnGMLogin(ListPacket.szName
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-						, ListPacket.szCountry
-#endif
-					);
-				else
-					CPythonMessenger::Instance().OnGMLogout(ListPacket.szName, ListPacket.dwLastPlayTime
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-						, ListPacket.szCountry
-#endif
-					);
-			}
-			break;
-
-			case MESSENGER_SUBHEADER_GC_GM_LOGIN:
-			{
-				CPythonMessenger::Instance().OnGMLogin(ListPacket.szName
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-					, ListPacket.szCountry
-#endif
-				);
-				__RefreshTargetBoardByName(ListPacket.szName);
-			}
-			break;
-
-			case MESSENGER_SUBHEADER_GC_GM_LOGOUT:
-				CPythonMessenger::Instance().OnGMLogout(ListPacket.szName, ListPacket.dwLastPlayTime
-#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
-					, ListPacket.szCountry
-#endif
-				);
-				break;
-#endif
-
-#if defined(ENABLE_MESSENGER_BLOCK)
-			case MESSENGER_SUBHEADER_GC_BLOCK_LIST:
-			{
-				if (ListPacket.bConnected & MESSENGER_CONNECTED_STATE_ONLINE)
-					CPythonMessenger::Instance().OnBlockLogin(ListPacket.szName);
-				else
-					CPythonMessenger::Instance().OnBlockLogout(ListPacket.szName);
-			}
-			break;
-
-			case MESSENGER_SUBHEADER_GC_BLOCK_LOGIN:
-			{
-				CPythonMessenger::Instance().OnBlockLogin(ListPacket.szName);
-				__RefreshTargetBoardByName(ListPacket.szName);
-			}
-			break;
-
-			case MESSENGER_SUBHEADER_GC_BLOCK_LOGOUT:
-				CPythonMessenger::Instance().OnBlockLogout(ListPacket.szName);
-				break;
-#endif
-		}
-	}
-
-	return true;
-}
-
-//////////////////////////////////////////////////////////////////////////
-// Party
-
-bool CPythonNetworkStream::SendPartyInvitePacket(DWORD dwVID)
-{
-	TPacketCGPartyInvite kPartyInvitePacket;
-	kPartyInvitePacket.header = HEADER_CG_PARTY_INVITE;
-	kPartyInvitePacket.vid = dwVID;
-
-	if (!Send(sizeof(kPartyInvitePacket), &kPartyInvitePacket))
-	{
-		Tracenf("CPythonNetworkStream::SendPartyInvitePacket [%ud] - PACKET SEND ERROR", dwVID);
-		return false;
-	}
-
-	Tracef(" << SendPartyInvitePacket : %d\n", dwVID);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPartyInviteAnswerPacket(DWORD dwLeaderVID, BYTE byAnswer)
-{
-	TPacketCGPartyInviteAnswer kPartyInviteAnswerPacket;
-	kPartyInviteAnswerPacket.header = HEADER_CG_PARTY_INVITE_ANSWER;
-	kPartyInviteAnswerPacket.leader_pid = dwLeaderVID;
-	kPartyInviteAnswerPacket.accept = byAnswer;
-
-	if (!Send(sizeof(kPartyInviteAnswerPacket), &kPartyInviteAnswerPacket))
-	{
-		Tracenf("CPythonNetworkStream::SendPartyInviteAnswerPacket [%ud %ud] - PACKET SEND ERROR", dwLeaderVID, byAnswer);
-		return false;
-	}
-
-	Tracef(" << SendPartyInviteAnswerPacket : %d, %d\n", dwLeaderVID, byAnswer);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPartyRemovePacket(DWORD dwPID)
-{
-	TPacketCGPartyRemove kPartyInviteRemove;
-	kPartyInviteRemove.header = HEADER_CG_PARTY_REMOVE;
-	kPartyInviteRemove.pid = dwPID;
-
-	if (!Send(sizeof(kPartyInviteRemove), &kPartyInviteRemove))
-	{
-		Tracenf("CPythonNetworkStream::SendPartyRemovePacket [%ud] - PACKET SEND ERROR", dwPID);
-		return false;
-	}
-
-	Tracef(" << SendPartyRemovePacket : %d\n", dwPID);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPartySetStatePacket(DWORD dwVID, BYTE byState, BYTE byFlag)
-{
-	TPacketCGPartySetState kPartySetState;
-	kPartySetState.byHeader = HEADER_CG_PARTY_SET_STATE;
-	kPartySetState.dwVID = dwVID;
-	kPartySetState.byState = byState;
-	kPartySetState.byFlag = byFlag;
-
-	if (!Send(sizeof(kPartySetState), &kPartySetState))
-	{
-		Tracenf("CPythonNetworkStream::SendPartySetStatePacket(%ud, %ud) - PACKET SEND ERROR", dwVID, byState);
-		return false;
-	}
-
-	Tracef(" << SendPartySetStatePacket : %d, %d, %d\n", dwVID, byState, byFlag);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPartyUseSkillPacket(BYTE bySkillIndex, DWORD dwVID)
-{
-	TPacketCGPartyUseSkill kPartyUseSkill;
-	kPartyUseSkill.byHeader = HEADER_CG_PARTY_USE_SKILL;
-	kPartyUseSkill.bySkillIndex = bySkillIndex;
-	kPartyUseSkill.dwTargetVID = dwVID;
-
-	if (!Send(sizeof(kPartyUseSkill), &kPartyUseSkill))
-	{
-		Tracenf("CPythonNetworkStream::SendPartyUseSkillPacket(%ud, %ud) - PACKET SEND ERROR", bySkillIndex, dwVID);
-		return false;
-	}
-
-	Tracef(" << SendPartyUseSkillPacket : %d, %d\n", bySkillIndex, dwVID);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPartyParameterPacket(BYTE byDistributeMode)
-{
-	TPacketCGPartyParameter kPartyParameter;
-	kPartyParameter.bHeader = HEADER_CG_PARTY_PARAMETER;
-	kPartyParameter.bDistributeMode = byDistributeMode;
-
-	if (!Send(sizeof(kPartyParameter), &kPartyParameter))
-	{
-		Tracenf("CPythonNetworkStream::SendPartyParameterPacket(%d) - PACKET SEND ERROR", byDistributeMode);
-		return false;
-	}
-
-	Tracef(" << SendPartyParameterPacket : %d\n", byDistributeMode);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvPartyInvite()
-{
-	TPacketGCPartyInvite kPartyInvitePacket;
-	if (!Recv(sizeof(kPartyInvitePacket), &kPartyInvitePacket))
-		return false;
-
-	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(kPartyInvitePacket.leader_pid);
-	if (!pInstance)
-	{
-		TraceError(" CPythonNetworkStream::RecvPartyInvite - Failed to find leader instance [%d]\n", kPartyInvitePacket.leader_pid);
-		return true;
-	}
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RecvPartyInviteQuestion", Py_BuildValue("(is)", kPartyInvitePacket.leader_pid, pInstance->GetNameString()));
-	Tracef(" >> RecvPartyInvite : %d, %s\n", kPartyInvitePacket.leader_pid, pInstance->GetNameString());
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPartyAdd()
-{
-	TPacketGCPartyAdd kPartyAddPacket;
-	if (!Recv(sizeof(kPartyAddPacket), &kPartyAddPacket))
-		return false;
-
-	CPythonPlayer::Instance().AppendPartyMember(kPartyAddPacket.pid, kPartyAddPacket.name);
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AddPartyMember",
-		Py_BuildValue("(is"
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-			"i"
-#endif
-#if defined(ENABLE_PARTY_CHANNEL_FIX)
-			"i"
-#endif
-			")",
-			kPartyAddPacket.pid, kPartyAddPacket.name
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-			, kPartyAddPacket.mapIdx
-#endif
-#if defined(ENABLE_PARTY_CHANNEL_FIX)
-			, kPartyAddPacket.channel
-#endif
-		));
-
-	Tracef(" >> RecvPartyAdd : %d, %s"
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-		", %d"
-#endif
-#if defined(ENABLE_PARTY_CHANNEL_FIX)
-		", %d"
-#endif
-		"\n", kPartyAddPacket.pid, kPartyAddPacket.name
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-		, kPartyAddPacket.mapIdx
-#endif
-#if defined(ENABLE_PARTY_CHANNEL_FIX)
-		, kPartyAddPacket.channel
-#endif
-	);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPartyUpdate()
-{
-	TPacketGCPartyUpdate kPartyUpdatePacket;
-	if (!Recv(sizeof(kPartyUpdatePacket), &kPartyUpdatePacket))
-		return false;
-
-	CPythonPlayer::TPartyMemberInfo* pPartyMemberInfo;
-	if (!CPythonPlayer::Instance().GetPartyMemberPtr(kPartyUpdatePacket.pid, &pPartyMemberInfo))
-		return true;
-
-	BYTE byOldState = pPartyMemberInfo->byState;
-
-	CPythonPlayer::Instance().UpdatePartyMemberInfo(kPartyUpdatePacket.pid, kPartyUpdatePacket.state, kPartyUpdatePacket.percent_hp);
-	for (int i = 0; i < PARTY_AFFECT_SLOT_MAX_NUM; ++i)
-	{
-		CPythonPlayer::Instance().UpdatePartyMemberAffect(kPartyUpdatePacket.pid, i, kPartyUpdatePacket.affects[i]);
-	}
-
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-	if (kPartyUpdatePacket.x || kPartyUpdatePacket.y)
-		__GlobalPositionToLocalPosition(kPartyUpdatePacket.x, kPartyUpdatePacket.y);
-
-	CPythonPlayer::Instance().UpdatePartyMemberPosition(kPartyUpdatePacket.pid, kPartyUpdatePacket.x, kPartyUpdatePacket.y);
-#endif
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "UpdatePartyMemberInfo", Py_BuildValue("(i)", kPartyUpdatePacket.pid));
-
-	// ¸¸¾à ¸®´õ°¡ ¹Ù²î¾ú´Ù¸é, TargetBoard ÀÇ ¹öÆ°À» ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
-	DWORD dwVID;
-	if (CPythonPlayer::Instance().PartyMemberPIDToVID(kPartyUpdatePacket.pid, &dwVID))
-		if (byOldState != kPartyUpdatePacket.state)
-		{
-			__RefreshTargetBoardByVID(dwVID);
-		}
-
-	//Tracef(" >> RecvPartyUpdate : %d, %d, %d\n", kPartyUpdatePacket.pid, kPartyUpdatePacket.state, kPartyUpdatePacket.percent_hp);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPartyRemove()
-{
-	TPacketGCPartyRemove kPartyRemovePacket;
-	if (!Recv(sizeof(kPartyRemovePacket), &kPartyRemovePacket))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RemovePartyMember", Py_BuildValue("(i)", kPartyRemovePacket.pid));
-	Tracef(" >> RecvPartyRemove : %d\n", kPartyRemovePacket.pid);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPartyLink()
-{
-	TPacketGCPartyLink kPartyLinkPacket;
-	if (!Recv(sizeof(kPartyLinkPacket), &kPartyLinkPacket))
-		return false;
-
-	CPythonPlayer::Instance().LinkPartyMember(kPartyLinkPacket.pid, kPartyLinkPacket.vid);
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "LinkPartyMember",
-		Py_BuildValue("(ii"
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-			"i"
-#endif
-#if defined(ENABLE_PARTY_CHANNEL_FIX)
-			"i"
-#endif
-			")",
-			kPartyLinkPacket.pid, kPartyLinkPacket.vid
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-			, kPartyLinkPacket.mapIdx
-#endif
-#if defined(ENABLE_PARTY_CHANNEL_FIX)
-			, kPartyLinkPacket.channel
-#endif
-		));
-
-	Tracef(" >> RecvPartyLink : %d, %d"
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-		", %d"
-#endif
-#if defined(ENABLE_PARTY_CHANNEL_FIX)
-		", %d"
-#endif
-		"\n", kPartyLinkPacket.pid, kPartyLinkPacket.vid
-#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
-		, kPartyLinkPacket.mapIdx
-#endif
-#if defined(ENABLE_PARTY_CHANNEL_FIX)
-		, kPartyLinkPacket.channel
-#endif
-	);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPartyUnlink()
-{
-	TPacketGCPartyLink kPartyUnlinkPacket;
-	if (!Recv(sizeof(kPartyUnlinkPacket), &kPartyUnlinkPacket))
-		return false;
-
-	CPythonPlayer::Instance().UnlinkPartyMember(kPartyUnlinkPacket.pid);
-
-	if (CPythonPlayer::Instance().IsMainCharacterIndex(kPartyUnlinkPacket.vid))
-	{
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "UnlinkAllPartyMember", Py_BuildValue("()"));
-	}
-	else
-	{
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "UnlinkPartyMember", Py_BuildValue("(i)", kPartyUnlinkPacket.pid));
-	}
-
-	Tracef(" >> RecvPartyUnlink : %d, %d\n", kPartyUnlinkPacket.pid, kPartyUnlinkPacket.vid);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPartyParameter()
-{
-	TPacketGCPartyParameter kPartyParameterPacket;
-	if (!Recv(sizeof(kPartyParameterPacket), &kPartyParameterPacket))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ChangePartyParameter", Py_BuildValue("(i)", kPartyParameterPacket.bDistributeMode));
-	Tracef(" >> RecvPartyParameter : %d\n", kPartyParameterPacket.bDistributeMode);
-
-	return true;
-}
-// Party
-//////////////////////////////////////////////////////////////////////////
-
-//////////////////////////////////////////////////////////////////////////
-// Guild
-bool CPythonNetworkStream::SendGuildAddMemberPacket(DWORD dwVID)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_ADD_MEMBER;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-	if (!Send(sizeof(dwVID), &dwVID))
-		return false;
-
-	Tracef(" SendGuildAddMemberPacket\n", dwVID);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildRemoveMemberPacket(DWORD dwPID)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_REMOVE_MEMBER;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-	if (!Send(sizeof(dwPID), &dwPID))
-		return false;
-
-	Tracef(" SendGuildRemoveMemberPacket %d\n", dwPID);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildChangeGradeNamePacket(BYTE byGradeNumber, const char* c_szName)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-	if (!Send(sizeof(byGradeNumber), &byGradeNumber))
-		return false;
-
-	char szName[GUILD_GRADE_NAME_MAX_LEN + 1];
-	strncpy(szName, c_szName, GUILD_GRADE_NAME_MAX_LEN);
-	szName[GUILD_GRADE_NAME_MAX_LEN] = '\0';
-
-	if (!Send(sizeof(szName), &szName))
-		return false;
-
-	Tracef(" SendGuildChangeGradeNamePacket %d, %s\n", byGradeNumber, c_szName);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildChangeGradeAuthorityPacket(BYTE byGradeNumber, BYTE byAuthority)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-	if (!Send(sizeof(byGradeNumber), &byGradeNumber))
-		return false;
-	if (!Send(sizeof(byAuthority), &byAuthority))
-		return false;
-
-	Tracef(" SendGuildChangeGradeAuthorityPacket %d, %d\n", byGradeNumber, byAuthority);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildOfferPacket(DWORD dwExperience)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_OFFER;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-	if (!Send(sizeof(dwExperience), &dwExperience))
-		return false;
-
-	Tracef(" SendGuildOfferPacket %d\n", dwExperience);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildPostCommentPacket(const char* c_szMessage)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_POST_COMMENT;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-
-	BYTE bySize = BYTE(strlen(c_szMessage)) + 1;
-	if (!Send(sizeof(bySize), &bySize))
-		return false;
-	if (!Send(bySize, c_szMessage))
-		return false;
-
-	Tracef(" SendGuildPostCommentPacket %d, %s\n", bySize, c_szMessage);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildDeleteCommentPacket(DWORD dwIndex)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_DELETE_COMMENT;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-
-	if (!Send(sizeof(dwIndex), &dwIndex))
-		return false;
-
-	Tracef(" SendGuildDeleteCommentPacket %d\n", dwIndex);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildRefreshCommentsPacket(DWORD dwHighestIndex)
-{
-	static DWORD s_LastTime = timeGetTime() - 1001;
-
-	if (timeGetTime() - s_LastTime < 1000)
-		return true;
-	s_LastTime = timeGetTime();
-
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_REFRESH_COMMENT;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-
-	Tracef(" SendGuildRefreshCommentPacket %d\n", dwHighestIndex);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildChangeMemberGradePacket(DWORD dwPID, BYTE byGrade)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-
-	if (!Send(sizeof(dwPID), &dwPID))
-		return false;
-	if (!Send(sizeof(byGrade), &byGrade))
-		return false;
-
-	Tracef(" SendGuildChangeMemberGradePacket %d, %d\n", dwPID, byGrade);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildUseSkillPacket(DWORD dwSkillID, DWORD dwTargetVID)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_USE_SKILL;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-
-	if (!Send(sizeof(dwSkillID), &dwSkillID))
-		return false;
-	if (!Send(sizeof(dwTargetVID), &dwTargetVID))
-		return false;
-
-	Tracef(" SendGuildUseSkillPacket %d, %d\n", dwSkillID, dwTargetVID);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildChangeMemberGeneralPacket(DWORD dwPID, BYTE byFlag)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-
-	if (!Send(sizeof(dwPID), &dwPID))
-		return false;
-	if (!Send(sizeof(byFlag), &byFlag))
-		return false;
-
-	Tracef(" SendGuildChangeMemberGeneralFlagPacket %d, %d\n", dwPID, byFlag);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildInviteAnswerPacket(DWORD dwGuildID, BYTE byAnswer)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-
-	if (!Send(sizeof(dwGuildID), &dwGuildID))
-		return false;
-	if (!Send(sizeof(byAnswer), &byAnswer))
-		return false;
-
-	Tracef(" SendGuildInviteAnswerPacket %d, %d\n", dwGuildID, byAnswer);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildChargeGSPPacket(DWORD dwMoney)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHARGE_GSP;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-
-	if (!Send(sizeof(dwMoney), &dwMoney))
-		return false;
-
-	Tracef(" SendGuildChargeGSPPacket %d\n", dwMoney);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildDepositMoneyPacket(DWORD dwMoney)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_DEPOSIT_MONEY;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-	if (!Send(sizeof(dwMoney), &dwMoney))
-		return false;
-
-	Tracef(" SendGuildDepositMoneyPacket %d\n", dwMoney);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGuildWithdrawMoneyPacket(DWORD dwMoney)
-{
-	TPacketCGGuild GuildPacket;
-	GuildPacket.byHeader = HEADER_CG_GUILD;
-	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_WITHDRAW_MONEY;
-	if (!Send(sizeof(GuildPacket), &GuildPacket))
-		return false;
-	if (!Send(sizeof(dwMoney), &dwMoney))
-		return false;
-
-	Tracef(" SendGuildWithdrawMoneyPacket %d\n", dwMoney);
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvGuild()
-{
-	TPacketGCGuild GuildPacket;
-	if (!Recv(sizeof(GuildPacket), &GuildPacket))
-		return false;
-
-	switch (GuildPacket.subheader)
-	{
-		case GUILD_SUBHEADER_GC_LOGIN:
-		{
-			DWORD dwPID;
-			if (!Recv(sizeof(DWORD), &dwPID))
-				return false;
-
-			// Messenger
-			CPythonGuild::TGuildMemberData* pGuildMemberData;
-			if (CPythonGuild::Instance().GetMemberDataPtrByPID(dwPID, &pGuildMemberData))
-				if (0 != pGuildMemberData->strName.compare(CPythonPlayer::Instance().GetName()))
-					CPythonMessenger::Instance().LoginGuildMember(pGuildMemberData->strName.c_str());
-
-			//Tracef(" <Login> %d\n", dwPID);
-			break;
-		}
-		case GUILD_SUBHEADER_GC_LOGOUT:
-		{
-			DWORD dwPID;
-			if (!Recv(sizeof(DWORD), &dwPID))
-				return false;
-
-			// Messenger
-			CPythonGuild::TGuildMemberData* pGuildMemberData;
-			if (CPythonGuild::Instance().GetMemberDataPtrByPID(dwPID, &pGuildMemberData))
-				if (0 != pGuildMemberData->strName.compare(CPythonPlayer::Instance().GetName()))
-					CPythonMessenger::Instance().LogoutGuildMember(pGuildMemberData->strName.c_str());
-
-			//Tracef(" <Logout> %d\n", dwPID);
-			break;
-		}
-		case GUILD_SUBHEADER_GC_REMOVE:
-		{
-			DWORD dwPID;
-			if (!Recv(sizeof(dwPID), &dwPID))
-				return false;
-
-			// Main Player ÀÏ °æ¿ì DeleteGuild
-			if (CPythonGuild::Instance().IsMainPlayer(dwPID))
-			{
-				CPythonGuild::Instance().Destroy();
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "DeleteGuild", Py_BuildValue("()"));
-				CPythonMessenger::Instance().RemoveAllGuildMember();
-				__SetGuildID(0);
-				__RefreshMessengerWindow();
-				__RefreshTargetBoard();
-				__RefreshCharacterWindow();
-			}
-			else
-			{
-				// Get Member Name
-				std::string strMemberName = "";
-				CPythonGuild::TGuildMemberData* pData;
-				if (CPythonGuild::Instance().GetMemberDataPtrByPID(dwPID, &pData))
-				{
-					strMemberName = pData->strName;
-					CPythonMessenger::Instance().RemoveGuildMember(pData->strName.c_str());
-				}
-
-				CPythonGuild::Instance().RemoveMember(dwPID);
-
-				// Refresh
-				__RefreshTargetBoardByName(strMemberName.c_str());
-				__RefreshGuildWindowMemberPage();
-			}
-
-			Tracef(" <Remove> %d\n", dwPID);
-			break;
-		}
-		case GUILD_SUBHEADER_GC_LIST:
-		{
-			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);
-
-			for (; iPacketSize > 0;)
-			{
-				TPacketGCGuildSubMember memberPacket;
-				if (!Recv(sizeof(memberPacket), &memberPacket))
-					return false;
-
-				char szName[CHARACTER_NAME_MAX_LEN + 1] = "";
-				if (memberPacket.byNameFlag)
-				{
-					if (!Recv(sizeof(szName), &szName))
-						return false;
-
-					iPacketSize -= CHARACTER_NAME_MAX_LEN + 1;
-				}
-				else
-				{
-					CPythonGuild::TGuildMemberData* pMemberData;
-					if (CPythonGuild::Instance().GetMemberDataPtrByPID(memberPacket.pid, &pMemberData))
-					{
-						strncpy(szName, pMemberData->strName.c_str(), CHARACTER_NAME_MAX_LEN);
-					}
-				}
-
-				//Tracef(" <List> %d : %s, %d (%d, %d, %d)\n", memberPacket.pid, szName, memberPacket.byGrade, memberPacket.byJob, memberPacket.byLevel, memberPacket.dwOffer);
-
-				CPythonGuild::SGuildMemberData GuildMemberData;
-				GuildMemberData.dwPID = memberPacket.pid;
-				GuildMemberData.byGrade = memberPacket.byGrade;
-				GuildMemberData.strName = szName;
-				GuildMemberData.byJob = memberPacket.byJob;
-				GuildMemberData.byLevel = memberPacket.byLevel;
-				GuildMemberData.dwOffer = memberPacket.dwOffer;
-				GuildMemberData.byGeneralFlag = memberPacket.byIsGeneral;
-				CPythonGuild::Instance().RegisterMember(GuildMemberData);
-
-				// Messenger
-				if (strcmp(szName, CPythonPlayer::Instance().GetName()))
-					CPythonMessenger::Instance().AppendGuildMember(szName);
-
-				__RefreshTargetBoardByName(szName);
-
-				iPacketSize -= sizeof(memberPacket);
-			}
-
-			__RefreshGuildWindowInfoPage();
-			__RefreshGuildWindowMemberPage();
-			__RefreshMessengerWindow();
-			__RefreshCharacterWindow();
-			break;
-		}
-		case GUILD_SUBHEADER_GC_GRADE:
-		{
-			BYTE byCount;
-			if (!Recv(sizeof(byCount), &byCount))
-				return false;
-
-			for (BYTE i = 0; i < byCount; ++i)
-			{
-				BYTE byIndex;
-				if (!Recv(sizeof(byCount), &byIndex))
-					return false;
-
-				TPacketGCGuildSubGrade GradePacket;
-				if (!Recv(sizeof(GradePacket), &GradePacket))
-					return false;
-
-#if defined(ENABLE_LOCALE_CLIENT)
-				CPythonLocale::Instance().FormatString(GradePacket.grade_name, sizeof(GradePacket.grade_name));
-#endif
-
-				auto aGradeData = CPythonGuild::SGuildGradeData(GradePacket.auth_flag, GradePacket.grade_name);
-				CPythonGuild::Instance().SetGradeData(byIndex, aGradeData);
-				//Tracef(" <Grade> [%d/%d] : %s, %d\n", byIndex, byCount, GradePacket.grade_name, GradePacket.auth_flag);
-			}
-			__RefreshGuildWindowGradePage();
-			__RefreshGuildWindowMemberPageGradeComboBox();
-			break;
-		}
-		case GUILD_SUBHEADER_GC_GRADE_NAME:
-		{
-			BYTE byGradeNumber;
-			if (!Recv(sizeof(byGradeNumber), &byGradeNumber))
-				return false;
-
-			char szGradeName[GUILD_GRADE_NAME_MAX_LEN + 1] = "";
-			if (!Recv(sizeof(szGradeName), &szGradeName))
-				return false;
-
-#if defined(ENABLE_LOCALE_CLIENT)
-			CPythonLocale::Instance().FormatString(szGradeName, sizeof(szGradeName));
-#endif
-
-			CPythonGuild::Instance().SetGradeName(byGradeNumber, szGradeName);
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildGrade", Py_BuildValue("()"));
-
-			Tracef(" <Change Grade Name> %d, %s\n", byGradeNumber, szGradeName);
-			__RefreshGuildWindowGradePage();
-			__RefreshGuildWindowMemberPageGradeComboBox();
-			break;
-		}
-		case GUILD_SUBHEADER_GC_GRADE_AUTH:
-		{
-			BYTE byGradeNumber;
-			if (!Recv(sizeof(byGradeNumber), &byGradeNumber))
-				return false;
-			BYTE byAuthorityFlag;
-			if (!Recv(sizeof(byAuthorityFlag), &byAuthorityFlag))
-				return false;
-
-			CPythonGuild::Instance().SetGradeAuthority(byGradeNumber, byAuthorityFlag);
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildGrade", Py_BuildValue("()"));
-
-			Tracef(" <Change Grade Authority> %d, %d\n", byGradeNumber, byAuthorityFlag);
-			__RefreshGuildWindowGradePage();
-			break;
-		}
-		case GUILD_SUBHEADER_GC_INFO:
-		{
-			TPacketGCGuildInfo GuildInfo;
-			if (!Recv(sizeof(GuildInfo), &GuildInfo))
-				return false;
-
-			CPythonGuild::Instance().EnableGuild();
-			CPythonGuild::TGuildInfo& rGuildInfo = CPythonGuild::Instance().GetGuildInfoRef();
-			strncpy(rGuildInfo.szGuildName, GuildInfo.name, GUILD_NAME_MAX_LEN);
-			rGuildInfo.szGuildName[GUILD_NAME_MAX_LEN] = '\0';
-
-			rGuildInfo.dwGuildID = GuildInfo.guild_id;
-			rGuildInfo.dwMasterPID = GuildInfo.master_pid;
-			rGuildInfo.dwGuildLevel = GuildInfo.level;
-			rGuildInfo.dwCurrentExperience = GuildInfo.exp;
-			rGuildInfo.dwCurrentMemberCount = GuildInfo.member_count;
-			rGuildInfo.dwMaxMemberCount = GuildInfo.max_member_count;
-			rGuildInfo.dwGuildMoney = GuildInfo.gold;
-			rGuildInfo.bHasLand = GuildInfo.hasLand;
-
-			//Tracef(" <Info> %s, %d, %d : %d\n", GuildInfo.name, GuildInfo.master_pid, GuildInfo.level, rGuildInfo.bHasLand);
-			__RefreshGuildWindowInfoPage();
-			break;
-		}
-		case GUILD_SUBHEADER_GC_COMMENTS:
-		{
-			BYTE byCount;
-			if (!Recv(sizeof(byCount), &byCount))
-				return false;
-
-			CPythonGuild::Instance().ClearComment();
-			//Tracef(" >>> Comments Count : %d\n", byCount);
-
-			for (BYTE i = 0; i < byCount; ++i)
-			{
-				DWORD dwCommentID;
-				if (!Recv(sizeof(dwCommentID), &dwCommentID))
-					return false;
-
-				char szName[CHARACTER_NAME_MAX_LEN + 1] = "";
-				if (!Recv(sizeof(szName), &szName))
-					return false;
-
-				char szComment[GULID_COMMENT_MAX_LEN + 1] = "";
-				if (!Recv(sizeof(szComment), &szComment))
-					return false;
-
-				//Tracef(" [Comment-%d] : %s, %s\n", dwCommentID, szName, szComment);
-				CPythonGuild::Instance().RegisterComment(dwCommentID, szName, szComment);
-			}
-
-			__RefreshGuildWindowBoardPage();
-			break;
-		}
-		case GUILD_SUBHEADER_GC_CHANGE_EXP:
-		{
-			BYTE byLevel;
-			if (!Recv(sizeof(byLevel), &byLevel))
-				return false;
-			DWORD dwEXP;
-			if (!Recv(sizeof(dwEXP), &dwEXP))
-				return false;
-			CPythonGuild::Instance().SetGuildEXP(byLevel, dwEXP);
-			Tracef(" <ChangeEXP> %d, %d\n", byLevel, dwEXP);
-			__RefreshGuildWindowInfoPage();
-			break;
-		}
-		case GUILD_SUBHEADER_GC_CHANGE_MEMBER_GRADE:
-		{
-			DWORD dwPID;
-			if (!Recv(sizeof(dwPID), &dwPID))
-				return false;
-			BYTE byGrade;
-			if (!Recv(sizeof(byGrade), &byGrade))
-				return false;
-			CPythonGuild::Instance().ChangeGuildMemberGrade(dwPID, byGrade);
-			Tracef(" <ChangeMemberGrade> %d, %d\n", dwPID, byGrade);
-			__RefreshGuildWindowMemberPage();
-			break;
-		}
-		case GUILD_SUBHEADER_GC_SKILL_INFO:
-		{
-			CPythonGuild::TGuildSkillData& rSkillData = CPythonGuild::Instance().GetGuildSkillDataRef();
-			if (!Recv(sizeof(rSkillData.bySkillPoint), &rSkillData.bySkillPoint))
-				return false;
-			if (!Recv(sizeof(rSkillData.bySkillLevel), rSkillData.bySkillLevel))
-				return false;
-			if (!Recv(sizeof(rSkillData.wGuildPoint), &rSkillData.wGuildPoint))
-				return false;
-			if (!Recv(sizeof(rSkillData.wMaxGuildPoint), &rSkillData.wMaxGuildPoint))
-				return false;
-
-			Tracef(" <SkillInfo> %d / %d, %d\n", rSkillData.bySkillPoint, rSkillData.wGuildPoint, rSkillData.wMaxGuildPoint);
-			__RefreshGuildWindowSkillPage();
-			break;
-		}
-		case GUILD_SUBHEADER_GC_CHANGE_MEMBER_GENERAL:
-		{
-			DWORD dwPID;
-			if (!Recv(sizeof(dwPID), &dwPID))
-				return false;
-			BYTE byFlag;
-			if (!Recv(sizeof(byFlag), &byFlag))
-				return false;
-
-			CPythonGuild::Instance().ChangeGuildMemberGeneralFlag(dwPID, byFlag);
-			Tracef(" <ChangeMemberGeneralFlag> %d, %d\n", dwPID, byFlag);
-			__RefreshGuildWindowMemberPage();
-			break;
-		}
-		case GUILD_SUBHEADER_GC_GUILD_INVITE:
-		{
-			DWORD dwGuildID;
-			if (!Recv(sizeof(dwGuildID), &dwGuildID))
-				return false;
-			char szGuildName[GUILD_NAME_MAX_LEN + 1];
-			if (!Recv(GUILD_NAME_MAX_LEN, &szGuildName))
-				return false;
-
-			szGuildName[GUILD_NAME_MAX_LEN] = 0;
-
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RecvGuildInviteQuestion", Py_BuildValue("(is)", dwGuildID, szGuildName));
-			Tracef(" <Guild Invite> %d, %s\n", dwGuildID, szGuildName);
-			break;
-		}
-		case GUILD_SUBHEADER_GC_WAR:
-		{
-			TPacketGCGuildWar kGuildWar;
-			if (!Recv(sizeof(kGuildWar), &kGuildWar))
-				return false;
-
-			switch (kGuildWar.bWarState)
-			{
-				case GUILD_WAR_SEND_DECLARE:
-					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_SEND_DECLARE\n");
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
-						"BINARY_GuildWar_OnSendDeclare",
-						Py_BuildValue("(i)", kGuildWar.dwGuildOpp)
-					);
-					break;
-				case GUILD_WAR_RECV_DECLARE:
-					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_RECV_DECLARE\n");
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
-						"BINARY_GuildWar_OnRecvDeclare",
-						Py_BuildValue("(ii)", kGuildWar.dwGuildOpp, kGuildWar.bType)
-					);
-					break;
-				case GUILD_WAR_ON_WAR:
-					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_ON_WAR : %d, %d\n", kGuildWar.dwGuildSelf, kGuildWar.dwGuildOpp);
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
-						"BINARY_GuildWar_OnStart",
-						Py_BuildValue("(ii)", kGuildWar.dwGuildSelf, kGuildWar.dwGuildOpp)
-					);
-					CPythonGuild::Instance().StartGuildWar(kGuildWar.dwGuildOpp);
-					break;
-				case GUILD_WAR_END:
-					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_END\n");
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
-						"BINARY_GuildWar_OnEnd",
-						Py_BuildValue("(ii)", kGuildWar.dwGuildSelf, kGuildWar.dwGuildOpp)
-					);
-					CPythonGuild::Instance().EndGuildWar(kGuildWar.dwGuildOpp);
-					break;
-			}
-			break;
-		}
-		case GUILD_SUBHEADER_GC_GUILD_NAME:
-		{
-			DWORD dwID;
-			char szGuildName[GUILD_NAME_MAX_LEN + 1];
-
-			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);
-
-			int nItemSize = sizeof(dwID) + GUILD_NAME_MAX_LEN;
-
-			assert(iPacketSize % nItemSize == 0 && "GUILD_SUBHEADER_GC_GUILD_NAME");
-
-			for (; iPacketSize > 0;)
-			{
-				if (!Recv(sizeof(dwID), &dwID))
-					return false;
-
-				if (!Recv(GUILD_NAME_MAX_LEN, &szGuildName))
-					return false;
-
-				szGuildName[GUILD_NAME_MAX_LEN] = 0;
-
-				//Tracef(" >> GulidName [%d : %s]\n", dwID, szGuildName);
-				CPythonGuild::Instance().RegisterGuildName(dwID, szGuildName);
-				iPacketSize -= nItemSize;
-			}
-			break;
-		}
-		case GUILD_SUBHEADER_GC_GUILD_WAR_LIST:
-		{
-			DWORD dwSrcGuildID;
-			DWORD dwDstGuildID;
-
-			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);
-			int nItemSize = sizeof(dwSrcGuildID) + sizeof(dwDstGuildID);
-
-			assert(iPacketSize % nItemSize == 0 && "GUILD_SUBHEADER_GC_GUILD_WAR_LIST");
-
-			for (; iPacketSize > 0;)
-			{
-				if (!Recv(sizeof(dwSrcGuildID), &dwSrcGuildID))
-					return false;
-
-				if (!Recv(sizeof(dwDstGuildID), &dwDstGuildID))
-					return false;
-
-				Tracef(" >> GulidWarList [%d vs %d]\n", dwSrcGuildID, dwDstGuildID);
-				CInstanceBase::InsertGVGKey(dwSrcGuildID, dwDstGuildID);
-				CPythonCharacterManager::Instance().ChangeGVG(dwSrcGuildID, dwDstGuildID);
-				iPacketSize -= nItemSize;
-			}
-			break;
-		}
-		case GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST:
-		{
-			DWORD dwSrcGuildID;
-			DWORD dwDstGuildID;
-
-			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);
-			int nItemSize = sizeof(dwSrcGuildID) + sizeof(dwDstGuildID);
-
-			assert(iPacketSize % nItemSize == 0 && "GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST");
-
-			for (; iPacketSize > 0;)
-			{
-				if (!Recv(sizeof(dwSrcGuildID), &dwSrcGuildID))
-					return false;
-
-				if (!Recv(sizeof(dwDstGuildID), &dwDstGuildID))
-					return false;
-
-				Tracef(" >> GulidWarEndList [%d vs %d]\n", dwSrcGuildID, dwDstGuildID);
-				CInstanceBase::RemoveGVGKey(dwSrcGuildID, dwDstGuildID);
-				CPythonCharacterManager::Instance().ChangeGVG(dwSrcGuildID, dwDstGuildID);
-				iPacketSize -= nItemSize;
-			}
-			break;
-		}
-		case GUILD_SUBHEADER_GC_WAR_POINT:
-		{
-			TPacketGuildWarPoint GuildWarPoint;
-			if (!Recv(sizeof(GuildWarPoint), &GuildWarPoint))
-				return false;
-
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
-				"BINARY_GuildWar_OnRecvPoint",
-				Py_BuildValue("(iii)", GuildWarPoint.dwGainGuildID, GuildWarPoint.dwOpponentGuildID, GuildWarPoint.lPoint)
-			);
-			break;
-		}
-		case GUILD_SUBHEADER_GC_MONEY_CHANGE:
-		{
-			DWORD dwMoney;
-			if (!Recv(sizeof(dwMoney), &dwMoney))
-				return false;
-
-			CPythonGuild::Instance().SetGuildMoney(dwMoney);
-
-			__RefreshGuildWindowInfoPage();
-			Tracef(" >> Guild Money Change : %d\n", dwMoney);
-			break;
-		}
-	}
-
-	return true;
-}
-// Guild
-//////////////////////////////////////////////////////////////////////////
-
-/////////////////////////////////////////////////////////////////////////
-// Fishing
-bool CPythonNetworkStream::SendFishingPacket(int iRotation)
-{
-	BYTE byHeader = HEADER_CG_FISHING;
-	if (!Send(sizeof(byHeader), &byHeader))
-		return false;
-	BYTE byPacketRotation = iRotation / 5;
-	if (!Send(sizeof(BYTE), &byPacketRotation))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendGiveItemPacket(DWORD dwTargetVID, TItemPos ItemPos, int iItemCount)
-{
-	TPacketCGGiveItem GiveItemPacket;
-	GiveItemPacket.byHeader = HEADER_CG_GIVE_ITEM;
-	GiveItemPacket.dwTargetVID = dwTargetVID;
-	GiveItemPacket.ItemPos = ItemPos;
-	GiveItemPacket.byItemCount = iItemCount;
-
-	if (!Send(sizeof(GiveItemPacket), &GiveItemPacket))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvFishing()
-{
-	TPacketGCFishing FishingPacket;
-	if (!Recv(sizeof(FishingPacket), &FishingPacket))
-		return false;
-
-	CInstanceBase* pFishingInstance = NULL;
-	if (FISHING_SUBHEADER_GC_FISH != FishingPacket.subheader)
-	{
-		pFishingInstance = CPythonCharacterManager::Instance().GetInstancePtr(FishingPacket.info);
-		if (!pFishingInstance)
-			return true;
-	}
-
-	switch (FishingPacket.subheader)
-	{
-		case FISHING_SUBHEADER_GC_START:
-			pFishingInstance->StartFishing(float(FishingPacket.dir) * 5.0f);
-			break;
-
-		case FISHING_SUBHEADER_GC_STOP:
-			if (pFishingInstance->IsFishing())
-				pFishingInstance->StopFishing();
-			break;
-
-		case FISHING_SUBHEADER_GC_REACT:
-			if (pFishingInstance->IsFishing())
-			{
-#if !defined(ENABLE_FISHING_GAME)
-				pFishingInstance->SetFishEmoticon(); // Fish Emoticon
-#endif
-				pFishingInstance->ReactFishing();
-			}
-			break;
-
-		case FISHING_SUBHEADER_GC_SUCCESS:
-			pFishingInstance->CatchSuccess();
-#if defined(ENABLE_FISHING_GAME)
-			pFishingInstance->SetFishEmoticon();
-#endif
-			break;
-
-		case FISHING_SUBHEADER_GC_FAIL:
-			pFishingInstance->CatchFail();
-			if (pFishingInstance == CPythonCharacterManager::Instance().GetMainInstancePtr())
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingFailure", Py_BuildValue("()"));
-#if defined(ENABLE_FISHING_GAME)
-			pFishingInstance->SetEmoticon(CInstanceBase::EMOTICON_NO_FISH);
-#endif
-			break;
-
-		case FISHING_SUBHEADER_GC_FISH:
-		{
-			DWORD dwFishID = FishingPacket.info;
-
-			if (0 == FishingPacket.info)
-			{
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingNotifyUnknown", Py_BuildValue("()"));
-				return true;
-			}
-
-			CItemData* pItemData;
-			if (!CItemManager::Instance().GetItemDataPointer(dwFishID, &pItemData))
-				return true;
-
-			CInstanceBase* pMainInstance = CPythonCharacterManager::Instance().GetMainInstancePtr();
-			if (!pMainInstance)
-				return true;
-
-			if (pMainInstance->IsFishing())
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingNotify", Py_BuildValue("(is)", CItemData::ITEM_TYPE_FISH == pItemData->GetType(), pItemData->GetName()));
-			else
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingSuccess", Py_BuildValue("(is)", CItemData::ITEM_TYPE_FISH == pItemData->GetType(), pItemData->GetName()));
-			break;
-		}
-	}
-
-	return true;
-}
-
-#if defined(ENABLE_FISHING_GAME)
-bool CPythonNetworkStream::RecvFishingGamePacket()
-{
-	TPacketGCFishingGame Packet;
-	if (!Recv(sizeof(Packet), &Packet))
-		return false;
-
-	CPythonPlayer& rkPlayer = CPythonPlayer::instance();
-	switch (Packet.bSubHeader)
-	{
-		case FISHING_GAME_SUBHEADER_OPEN:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingGameStart", Py_BuildValue("(i)", Packet.bLevel));
-			rkPlayer.SetFishingGameWindowOpen(true);
-			break;
-
-		case FISHING_GAME_SUBHEADER_QUIT:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingStopGame", Py_BuildValue("()"));
-			rkPlayer.SetFishingGameWindowOpen(false);
-			break;
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendFishingGamePacket(BYTE bSubHeader, BYTE bGoals)
-{
-	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
-	if (!rkPlayer.GetFishingGameWindowOpen())
-		return false;
-
-	TPacketCGFishingGame Packet;
-	Packet.bHeader = HEADER_CG_FISHING_GAME;
-	Packet.bSubHeader = bSubHeader;
-	Packet.bGoals = bGoals;
-	if (!Send(sizeof(Packet), &Packet))
-		return false;
-
-	return SendSequence();
-}
-#endif
-// Fishing
-/////////////////////////////////////////////////////////////////////////
-
-/////////////////////////////////////////////////////////////////////////
-// Dungeon
-bool CPythonNetworkStream::RecvDungeon()
-{
-	TPacketGCDungeon DungeonPacket;
-	if (!Recv(sizeof(DungeonPacket), &DungeonPacket))
-		return false;
-
-	switch (DungeonPacket.subheader)
-	{
-		case DUNGEON_SUBHEADER_GC_TIME_ATTACK_START:
-		{
-			break;
-		}
-		case DUNGEON_SUBHEADER_GC_DESTINATION_POSITION:
-		{
-			unsigned long ulx, uly;
-			if (!Recv(sizeof(ulx), &ulx))
-				return false;
-			if (!Recv(sizeof(uly), &uly))
-				return false;
-
-			CPythonPlayer::Instance().SetDungeonDestinationPosition(ulx, uly);
-			break;
-		}
-	}
-
-	return true;
-}
-// Dungeon
-/////////////////////////////////////////////////////////////////////////
-
-/////////////////////////////////////////////////////////////////////////
-// MyShop
-bool CPythonNetworkStream::SendBuildPrivateShopPacket(const char* c_szName, const std::vector<TShopItemTable>& c_rSellingItemStock)
-{
-	TPacketCGMyShop packet;
-	packet.bHeader = HEADER_CG_MYSHOP;
-	strncpy(packet.szSign, c_szName, SHOP_SIGN_MAX_LEN);
-	packet.bCount = static_cast<BYTE>(c_rSellingItemStock.size());
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	for (std::vector<TShopItemTable>::const_iterator itor = c_rSellingItemStock.begin(); itor < c_rSellingItemStock.end(); ++itor)
-	{
-		const TShopItemTable& c_rItem = *itor;
-		if (!Send(sizeof(c_rItem), &c_rItem))
-			return false;
-	}
-
-	return SendSequence();
-}
-
-#if defined(ENABLE_MYSHOP_DECO)
-bool CPythonNetworkStream::SendMyShopDecoState(BYTE bState)
-{
-	TPacketCGMyShopDeco Packet;
-	Packet.bHeader = HEADER_CG_MYSHOP_DECO;
-	Packet.bState = bState;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("TPacketCGMyShopDeco Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMyShopDecoSet(BYTE bType, DWORD dwPolyVnum)
-{
-	TPacketCGMyShopDecoAdd Packet;
-	Packet.bHeader = HEADER_CG_MYSHOP_DECO_ADD;
-	Packet.bType = bType;
-	Packet.dwPolyVnum = dwPolyVnum;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("TPacketCGMyShopDecoAdd Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-#endif
-
-bool CPythonNetworkStream::RecvShopSignPacket()
-{
-	TPacketGCShopSign p;
-	if (!Recv(sizeof(TPacketGCShopSign), &p))
-		return false;
-
-	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
-
-#if defined(ENABLE_GRAPHIC_ON_OFF)
-	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(p.dwVID);
-	if (!pInstance)
-		return true;
-#endif
-
-	if (0 == strlen(p.szSign))
-	{
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_PrivateShop_Disappear", Py_BuildValue("(i)", p.dwVID));
-
-		if (rkPlayer.IsMainCharacterIndex(p.dwVID))
-			rkPlayer.ClosePrivateShop();
-
-#if defined(ENABLE_GRAPHIC_ON_OFF)
-		pInstance->GetGraphicThingInstancePtr()->RemovePrivateShopSign();
-#endif
-	}
-	else
-	{
-#if defined(ENABLE_MYSHOP_DECO)
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_PrivateShop_Appear", Py_BuildValue("(isi)", p.dwVID, p.szSign, p.bType));
-#else
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_PrivateShop_Appear", Py_BuildValue("(is)", p.dwVID, p.szSign));
-#endif
-
-		if (rkPlayer.IsMainCharacterIndex(p.dwVID))
-			rkPlayer.OpenPrivateShop();
-
-#if defined(ENABLE_GRAPHIC_ON_OFF)
-		pInstance->GetGraphicThingInstancePtr()->AddPrivateShopSign();
-#endif
-	}
-
-	return true;
-}
-/////////////////////////////////////////////////////////////////////////
-
-bool CPythonNetworkStream::RecvTimePacket()
-{
-	TPacketGCTime TimePacket;
-	if (!Recv(sizeof(TimePacket), &TimePacket))
-		return false;
-
-	IAbstractApplication& rkApp = IAbstractApplication::GetSingleton();
-	rkApp.SetServerTime(TimePacket.time);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvWalkModePacket()
-{
-	TPacketGCWalkMode WalkModePacket;
-	if (!Recv(sizeof(WalkModePacket), &WalkModePacket))
-		return false;
-
-	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(WalkModePacket.vid);
-	if (pInstance)
-	{
-		if (WALKMODE_RUN == WalkModePacket.mode)
-		{
-			pInstance->SetRunMode();
-		}
-		else
-		{
-			pInstance->SetWalkMode();
-		}
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvChangeSkillGroupPacket()
-{
-	TPacketGCChangeSkillGroup ChangeSkillGroup;
-	if (!Recv(sizeof(ChangeSkillGroup), &ChangeSkillGroup))
-		return false;
-
-	m_dwMainActorSkillGroup = ChangeSkillGroup.skill_group;
-
-	CPythonPlayer::Instance().NEW_ClearSkillData();
-	__RefreshCharacterWindow();
-	return true;
-}
-
-void CPythonNetworkStream::__TEST_SetSkillGroupFake(int iIndex)
-{
-	m_dwMainActorSkillGroup = DWORD(iIndex);
-
-	CPythonPlayer::Instance().NEW_ClearSkillData();
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshCharacter", Py_BuildValue("()"));
-}
-
-bool CPythonNetworkStream::SendRefinePacket(BYTE byPos, BYTE byType)
-{
-	TPacketCGRefine kRefinePacket;
-	kRefinePacket.header = HEADER_CG_REFINE;
-	kRefinePacket.pos = byPos;
-	kRefinePacket.type = byType;
-
-	if (!Send(sizeof(kRefinePacket), &kRefinePacket))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendSelectItemPacket(DWORD dwItemPos)
-{
-	TPacketCGScriptSelectItem kScriptSelectItem;
-	kScriptSelectItem.header = HEADER_CG_SCRIPT_SELECT_ITEM;
-	kScriptSelectItem.selection = dwItemPos;
-
-	if (!Send(sizeof(kScriptSelectItem), &kScriptSelectItem))
-		return false;
-
-	return SendSequence();
-}
-
-#if defined(ENABLE_GEM_SYSTEM)
-bool CPythonNetworkStream::SendSelectMetinStone(DWORD dwItemPos)
-{
-	TPacketCGSelectItemEx command_select_item_ex(dwItemPos);
-	if (!Send(sizeof(command_select_item_ex), &command_select_item_ex))
-		return false;
-	return SendSequence();
-}
-#endif
-
-bool CPythonNetworkStream::RecvRefineInformationPacket()
-{
-	TPacketGCRefineInformation kRefineInfoPacket;
-	if (!Recv(sizeof(kRefineInfoPacket), &kRefineInfoPacket))
-		return false;
-
-	TRefineTable& rkRefineTable = kRefineInfoPacket.refine_table;
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
-		"OpenRefineDialog",
-		Py_BuildValue("(iiii)",
-			kRefineInfoPacket.pos,
-			kRefineInfoPacket.refine_table.result_vnum,
-			rkRefineTable.cost,
-			rkRefineTable.prob));
-
-	for (int i = 0; i < rkRefineTable.material_count; ++i)
-	{
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AppendMaterialToRefineDialog", Py_BuildValue("(ii)", rkRefineTable.materials[i].vnum, rkRefineTable.materials[i].count));
-	}
-
-#ifdef _DEBUG
-	Tracef(" >> RecvRefineInformationPacket(pos=%d, result_vnum=%d, cost=%d, prob=%d)\n",
-		kRefineInfoPacket.pos,
-		kRefineInfoPacket.refine_table.result_vnum,
-		rkRefineTable.cost,
-		rkRefineTable.prob);
-#endif
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvRefineInformationPacketNew()
-{
-	TPacketGCRefineInformationNew kRefineInfoPacket;
-	if (!Recv(sizeof(kRefineInfoPacket), &kRefineInfoPacket))
-		return false;
-
-	TRefineTable& rkRefineTable = kRefineInfoPacket.refine_table;
-
-#if defined(ENABLE_APPLY_RANDOM)
-	PyObject* poList = PyList_New(0);
-	if (!poList)
-		return false;
-
-	for (BYTE bApplySlot = 0; bApplySlot < ITEM_APPLY_RANDOM_SLOT_MAX_NUM; ++bApplySlot)
-	{
-		PyObject* poItem = Py_BuildValue("(ii)", kRefineInfoPacket.aApplyRandom[bApplySlot].wType, kRefineInfoPacket.aApplyRandom[bApplySlot].lValue);
-		if (!poItem)
-		{
-			Py_DECREF(poList);
-			return false;
-		}
-
-		PyList_Append(poList, poItem);
-		Py_DECREF(poItem);
-	}
-#endif
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
-		"OpenRefineDialog",
-#if defined(ENABLE_APPLY_RANDOM)
-		Py_BuildValue("(iiiiiOi)",
-			kRefineInfoPacket.pos,
-			kRefineInfoPacket.refine_table.result_vnum,
-			rkRefineTable.cost,
-			rkRefineTable.prob,
-			kRefineInfoPacket.type,
-			poList,
-			rkRefineTable.src_vnum)
-#else
-		Py_BuildValue("(iiiii)",
-			kRefineInfoPacket.pos,
-			kRefineInfoPacket.refine_table.result_vnum,
-			rkRefineTable.cost,
-			rkRefineTable.prob,
-			kRefineInfoPacket.type)
-#endif
-	);
-
-#if defined(ENABLE_APPLY_RANDOM)
-	Py_DECREF(poList);
-#endif
-
-	for (int i = 0; i < rkRefineTable.material_count; ++i)
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AppendMaterialToRefineDialog", Py_BuildValue("(ii)", rkRefineTable.materials[i].vnum, rkRefineTable.materials[i].count));
-
-#ifdef _DEBUG
-	Tracef(" >> RecvRefineInformationPacketNew(pos=%d, result_vnum=%d, cost=%d, prob=%d, type=%d, src_vnum=%d)\n",
-		kRefineInfoPacket.pos,
-		kRefineInfoPacket.refine_table.result_vnum,
-		rkRefineTable.cost,
-		rkRefineTable.prob,
-		kRefineInfoPacket.type
-	);
-#endif
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvNPCList()
-{
-	TPacketGCNPCPosition kNPCPosition;
-	if (!Recv(sizeof(kNPCPosition), &kNPCPosition))
-		return false;
-
-	assert(int(kNPCPosition.size) - sizeof(kNPCPosition) == kNPCPosition.count * sizeof(TNPCPosition) && "HEADER_GC_NPC_POSITION");
-
-	CPythonMiniMap::Instance().ClearAtlasMarkInfo();
-
-	for (int i = 0; i < kNPCPosition.count; ++i)
-	{
-		TNPCPosition NPCPosition;
-		if (!Recv(sizeof(TNPCPosition), &NPCPosition))
-			return false;
-
-		CPythonMiniMap::Instance().RegisterAtlasMark(NPCPosition.bType, NPCPosition.name, NPCPosition.x, NPCPosition.y);
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::__SendCRCReportPacket()
-{
-	/*
-	DWORD dwProcessCRC = 0;
-	DWORD dwFileCRC = 0;
-	CFilename exeFileName;
-	//LPCVOID c_pvBaseAddress = NULL;
-
-	GetExeCRC(dwProcessCRC, dwFileCRC);
-
-	CFilename strRootPackFileName = CEterPackManager::Instance().GetRootPacketFileName();
-	strRootPackFileName.ChangeDosPath();
-
-	TPacketCGCRCReport kReportPacket;
-
-	kReportPacket.header = HEADER_CG_CRC_REPORT;
-	kReportPacket.byPackMode = CEterPackManager::Instance().GetSearchMode();
-	kReportPacket.dwBinaryCRC32 = dwFileCRC;
-	kReportPacket.dwProcessCRC32 = dwProcessCRC;
-	kReportPacket.dwRootPackCRC32 = GetFileCRC32(strRootPackFileName.c_str());
-
-	if (!Send(sizeof(kReportPacket), &kReportPacket))
-		Tracef("SendClientReportPacket Error");
-
-	return SendSequence();
-	*/
-	return true;
-}
-
-bool CPythonNetworkStream::SendClientVersionPacket()
-{
-	std::string filename;
-
-	GetExcutedFileName(filename);
-
-	filename = CFileNameHelper::NoPath(filename);
-	CFileNameHelper::ChangeDosPath(filename);
-
-	if (LocaleService_IsEUROPE() && false == LocaleService_IsYMIR())
-	{
-		TPacketCGClientVersion2 kVersionPacket;
-		kVersionPacket.header = HEADER_CG_CLIENT_VERSION2;
-		strncpy(kVersionPacket.filename, filename.c_str(), sizeof(kVersionPacket.filename) - 1);
-		strncpy(kVersionPacket.timestamp, "1689090990", sizeof(kVersionPacket.timestamp) - 1);
-
-		if (!Send(sizeof(kVersionPacket), &kVersionPacket))
-			Tracef("SendClientReportPacket Error");
-	}
-	else
-	{
-		TPacketCGClientVersion kVersionPacket;
-		kVersionPacket.header = HEADER_CG_CLIENT_VERSION;
-		strncpy(kVersionPacket.filename, filename.c_str(), sizeof(kVersionPacket.filename) - 1);
-		strncpy(kVersionPacket.timestamp, __TIMESTAMP__, sizeof(kVersionPacket.timestamp) - 1);
-
-		if (!Send(sizeof(kVersionPacket), &kVersionPacket))
-			Tracef("SendClientReportPacket Error");
-	}
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvAffectAddPacket()
-{
-	TPacketGCAffectAdd kAffectAdd;
-	if (!Recv(sizeof(kAffectAdd), &kAffectAdd))
-		return false;
-
-	TPacketAffectElement& rkElement = kAffectAdd.elem;
-	if (rkElement.wApplyOn == POINT_ENERGY)
-	{
-		CPythonPlayer::Instance().SetStatus(POINT_ENERGY_END_TIME, CPythonApplication::Instance().GetServerTimeStamp() + rkElement.lDuration);
-		__RefreshStatus();
-	}
-
-	CPythonPlayer::Instance().AddAffect(rkElement.dwType, kAffectAdd.elem);
-#if defined(ENABLE_AFFECT_RENEWAL)
-	if (rkElement.bUpdate)
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_NEW_UpdateAffect", Py_BuildValue("(iiii)", rkElement.dwType, rkElement.wApplyOn, rkElement.lApplyValue, rkElement.lDuration));
-	else
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_NEW_AddAffect", Py_BuildValue("(iiii)", rkElement.dwType, rkElement.wApplyOn, rkElement.lApplyValue, rkElement.lDuration));
-#else
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_NEW_AddAffect", Py_BuildValue("(iiii)", rkElement.dwType, rkElement.wApplyOn, rkElement.lApplyValue, rkElement.lDuration));
-#endif
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvAffectRemovePacket()
-{
-	TPacketGCAffectRemove kAffectRemove;
-	if (!Recv(sizeof(kAffectRemove), &kAffectRemove))
-		return false;
-
-	CPythonPlayer::Instance().RemoveAffect(kAffectRemove.dwType, kAffectRemove.wApplyOn);
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_NEW_RemoveAffect", Py_BuildValue("(ii)", kAffectRemove.dwType, kAffectRemove.wApplyOn));
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvChannelPacket()
-{
-	TPacketGCChannel kChannelPacket;
-	if (!Recv(sizeof(kChannelPacket), &kChannelPacket))
-		return false;
-
-	// Tracef(" >> CPythonNetworkStream::RecvChannelPacket(channel=%d)\n", kChannelPacket.channel);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvViewEquipPacket()
-{
-	TPacketGCViewEquip kViewEquipPacket;
-	if (!Recv(sizeof(kViewEquipPacket), &kViewEquipPacket))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenEquipmentDialog", Py_BuildValue("(i)", kViewEquipPacket.dwVID));
-
-	for (BYTE bSlotIdx = 0; bSlotIdx < WEAR_MAX_NUM; ++bSlotIdx)
-	{
-		TEquipmentItemSet& rItemSet = kViewEquipPacket.Equips[bSlotIdx];
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetEquipmentDialogItem", Py_BuildValue(
-			"("
-			"i" // window
-			"i" // vid
-			"i" // slot_index
-			"i" // vnum
-			"i" // count
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-			"i" // change_look_vnum
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-			"(iiOO)" // refine_element
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-			"(OOOO)" // apply_random_list
-#endif
-#if defined(ENABLE_SET_ITEM)
-			"i" // set_value
-#endif
-			")"
-			, EQUIPMENT
-			, kViewEquipPacket.dwVID
-			, bSlotIdx
-			, rItemSet.dwVnum
-			, rItemSet.bCount
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-			, rItemSet.dwTransmutationVnum
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-			, rItemSet.RefineElement.wApplyType
-			, rItemSet.RefineElement.bGrade
-			, Py_BuildValue("iii",
-				rItemSet.RefineElement.abValue[0],
-				rItemSet.RefineElement.abValue[1],
-				rItemSet.RefineElement.abValue[2])
-			, Py_BuildValue("iii",
-				rItemSet.RefineElement.abBonusValue[0],
-				rItemSet.RefineElement.abBonusValue[1],
-				rItemSet.RefineElement.abBonusValue[2])
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-			, Py_BuildValue("ii", rItemSet.aApplyRandom[0].wType, rItemSet.aApplyRandom[0].lValue)
-			, Py_BuildValue("ii", rItemSet.aApplyRandom[1].wType, rItemSet.aApplyRandom[1].lValue)
-			, Py_BuildValue("ii", rItemSet.aApplyRandom[2].wType, rItemSet.aApplyRandom[2].lValue)
-			, Py_BuildValue("ii", rItemSet.aApplyRandom[3].wType, rItemSet.aApplyRandom[3].lValue)
-#endif
-#if defined(ENABLE_SET_ITEM)
-			, rItemSet.bSetValue
-#endif
-		));
-
-		for (BYTE bSocketIdx = 0; bSocketIdx < ITEM_SOCKET_SLOT_MAX_NUM; ++bSocketIdx)
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetEquipmentDialogSocket", Py_BuildValue("(iiiii)",
-				EQUIPMENT, kViewEquipPacket.dwVID, bSlotIdx, bSocketIdx, rItemSet.alSockets[bSocketIdx]));
-
-		for (BYTE bAttrIdx = 0; bAttrIdx < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++bAttrIdx)
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetEquipmentDialogAttr", Py_BuildValue("(iiiiii)",
-				EQUIPMENT, kViewEquipPacket.dwVID, bSlotIdx, bAttrIdx, rItemSet.aAttr[bAttrIdx].wType, rItemSet.aAttr[bAttrIdx].lValue));
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvLandPacket()
-{
-	TPacketGCLandList kLandList;
-	if (!Recv(sizeof(kLandList), &kLandList))
-		return false;
-
-	std::vector<DWORD> kVec_dwGuildID;
-
-	CPythonMiniMap& rkMiniMap = CPythonMiniMap::Instance();
-	CPythonBackground& rkBG = CPythonBackground::Instance();
-	CInstanceBase* pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();
-
-	rkMiniMap.ClearGuildArea();
-	rkBG.ClearGuildArea();
-
-	int iPacketSize = (kLandList.size - sizeof(TPacketGCLandList));
-	for (; iPacketSize > 0; iPacketSize -= sizeof(TLandPacketElement))
-	{
-		TLandPacketElement kElement;
-		if (!Recv(sizeof(TLandPacketElement), &kElement))
-			return false;
-
-		rkMiniMap.RegisterGuildArea(kElement.dwID,
-			kElement.dwGuildID,
-			kElement.x,
-			kElement.y,
-			kElement.width,
-			kElement.height);
-
-		if (pMainInstance)
-			if (kElement.dwGuildID == pMainInstance->GetGuildID())
-			{
-				rkBG.RegisterGuildArea(kElement.x,
-					kElement.y,
-					kElement.x + kElement.width,
-					kElement.y + kElement.height);
-			}
-
-		if (0 != kElement.dwGuildID)
-			kVec_dwGuildID.push_back(kElement.dwGuildID);
-	}
-
-	if (kVec_dwGuildID.size() > 0)
-		__DownloadSymbol(kVec_dwGuildID);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvTargetCreatePacket()
-{
-	TPacketGCTargetCreate kTargetCreate;
-	if (!Recv(sizeof(kTargetCreate), &kTargetCreate))
-		return false;
-
-#if defined(ENABLE_LOCALE_CLIENT)
-	CPythonLocale::Instance().FormatString(kTargetCreate.szTargetName, sizeof(kTargetCreate.szTargetName));
-#endif
-
-	CPythonMiniMap& rkpyMiniMap = CPythonMiniMap::Instance();
-	rkpyMiniMap.CreateTarget(kTargetCreate.lID, kTargetCreate.szTargetName);
-
-	//#ifdef _DEBUG
-	//	char szBuf[256+1];
-	//	_snprintf(szBuf, sizeof(szBuf), "Å¸°ÙÀÌ »ý¼º µÇ¾ú½À´Ï´Ù [%d:%s]", kTargetCreate.lID, kTargetCreate.szTargetName);
-	//	CPythonChat::Instance().AppendChat(CHAT_TYPE_NOTICE, szBuf);
-	//	Tracef(" >> RecvTargetCreatePacket %d : %s\n", kTargetCreate.lID, kTargetCreate.szTargetName);
-	//#endif
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_OpenAtlasWindow", Py_BuildValue("()"));
-	return true;
-}
-
-bool CPythonNetworkStream::RecvTargetCreatePacketNew()
-{
-	TPacketGCTargetCreateNew kTargetCreate;
-	if (!Recv(sizeof(kTargetCreate), &kTargetCreate))
-		return false;
-
-#if defined(ENABLE_LOCALE_CLIENT)
-	CPythonLocale::Instance().FormatString(kTargetCreate.szTargetName, sizeof(kTargetCreate.szTargetName));
-#endif
-
-	CPythonMiniMap& rkpyMiniMap = CPythonMiniMap::Instance();
-	CPythonBackground& rkpyBG = CPythonBackground::Instance();
-	if (CREATE_TARGET_TYPE_LOCATION == kTargetCreate.byType)
-	{
-		rkpyMiniMap.CreateTarget(kTargetCreate.lID, kTargetCreate.szTargetName);
-	}
-	else
-	{
-		rkpyMiniMap.CreateTarget(kTargetCreate.lID, kTargetCreate.szTargetName, kTargetCreate.dwVID);
-		rkpyBG.CreateTargetEffect(kTargetCreate.lID, kTargetCreate.dwVID);
-	}
-
-	//#ifdef _DEBUG
-	//	char szBuf[256+1];
-	//	_snprintf(szBuf, sizeof(szBuf), "Ä³¸¯ÅÍ Å¸°ÙÀÌ »ý¼º µÇ¾ú½À´Ï´Ù [%d:%s:%d]", kTargetCreate.lID, kTargetCreate.szTargetName, kTargetCreate.dwVID);
-	//	CPythonChat::Instance().AppendChat(CHAT_TYPE_NOTICE, szBuf);
-	//	Tracef(" >> RecvTargetCreatePacketNew %d : %d/%d\n", kTargetCreate.lID, kTargetCreate.byType, kTargetCreate.dwVID);
-	//#endif
-
-	//PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_OpenAtlasWindow", Py_BuildValue("()"));
-	return true;
-}
-
-bool CPythonNetworkStream::RecvTargetUpdatePacket()
-{
-	TPacketGCTargetUpdate kTargetUpdate;
-	if (!Recv(sizeof(kTargetUpdate), &kTargetUpdate))
-		return false;
-
-	CPythonMiniMap& rkpyMiniMap = CPythonMiniMap::Instance();
-	rkpyMiniMap.UpdateTarget(kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
-
-	CPythonBackground& rkpyBG = CPythonBackground::Instance();
-
-	rkpyBG.CreateTargetEffect(kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
-
-	//#ifdef _DEBUG
-	//	char szBuf[256+1];
-	//	_snprintf(szBuf, sizeof(szBuf), "Å¸°ÙÀÇ À§Ä¡°¡ °»½Å µÇ¾ú½À´Ï´Ù [%d:%d/%d]", kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
-	//	CPythonChat::Instance().AppendChat(CHAT_TYPE_NOTICE, szBuf);
-	//	Tracef(" >> RecvTargetUpdatePacket %d : %d, %d\n", kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
-	//#endif
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvTargetDeletePacket()
-{
-	TPacketGCTargetDelete kTargetDelete;
-	if (!Recv(sizeof(kTargetDelete), &kTargetDelete))
-		return false;
-
-	CPythonMiniMap& rkpyMiniMap = CPythonMiniMap::Instance();
-	rkpyMiniMap.DeleteTarget(kTargetDelete.lID);
-
-	CPythonBackground& rkpyBG = CPythonBackground::Instance();
-	rkpyBG.DeleteTargetEffect(kTargetDelete.lID);
-
-	//#ifdef _DEBUG
-	//	Tracef(" >> RecvTargetDeletePacket %d\n", kTargetDelete.lID);
-	//#endif
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvLoverInfoPacket()
-{
-	TPacketGCLoverInfo kLoverInfo;
-	if (!Recv(sizeof(kLoverInfo), &kLoverInfo))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_LoverInfo", Py_BuildValue("(si)", kLoverInfo.szName, kLoverInfo.byLovePoint));
-#ifdef _DEBUG
-	Tracef("RECV LOVER INFO : %s, %d\n", kLoverInfo.szName, kLoverInfo.byLovePoint);
-#endif
-	return true;
-}
-
-bool CPythonNetworkStream::RecvLovePointUpdatePacket()
-{
-	TPacketGCLovePointUpdate kLovePointUpdate;
-	if (!Recv(sizeof(kLovePointUpdate), &kLovePointUpdate))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_UpdateLovePoint", Py_BuildValue("(i)", kLovePointUpdate.byLovePoint));
-#ifdef _DEBUG
-	Tracef("RECV LOVE POINT UPDATE : %d\n", kLovePointUpdate.byLovePoint);
-#endif
-	return true;
-}
-
-bool CPythonNetworkStream::RecvDigMotionPacket()
-{
-	TPacketGCDigMotion kDigMotion;
-	if (!Recv(sizeof(kDigMotion), &kDigMotion))
-		return false;
-
-#ifdef _DEBUG
-	Tracef(" Dig Motion [%d/%d]\n", kDigMotion.vid, kDigMotion.count);
-#endif
-
-	IAbstractCharacterManager& rkChrMgr = IAbstractCharacterManager::GetSingleton();
-	CInstanceBase* pkInstMain = rkChrMgr.GetInstancePtr(kDigMotion.vid);
-	CInstanceBase* pkInstTarget = rkChrMgr.GetInstancePtr(kDigMotion.target_vid);
-	if (NULL == pkInstMain)
-		return true;
-
-	if (pkInstTarget)
-		pkInstMain->NEW_LookAtDestInstance(*pkInstTarget);
-
-	for (int i = 0; i < kDigMotion.count; ++i)
-		pkInstMain->PushOnceMotion(CRaceMotionData::NAME_DIG);
-
-	return true;
-}
-
-#if defined(ENABLE_DRAGON_SOUL_SYSTEM)
-// ¿ëÈ¥¼® °­È­
-bool CPythonNetworkStream::SendDragonSoulRefinePacket(BYTE bRefineType, TItemPos* pos)
-{
-	TPacketCGDragonSoulRefine pk;
-	pk.header = HEADER_CG_DRAGON_SOUL_REFINE;
-	pk.bSubType = bRefineType;
-	memcpy(pk.ItemGrid, pos, sizeof(TItemPos) * DS_REFINE_WINDOW_MAX_NUM);
-	if (!Send(sizeof(pk), &pk))
-	{
-		return false;
-	}
-	return true;
-}
-#endif
-
-#if defined(ENABLE_SKILLBOOK_COMB_SYSTEM)
-bool CPythonNetworkStream::SendSkillBookCombinationPacket(TItemPos* pPos, BYTE bAction)
-{
-	TPacketCGSkillBookCombination SkillBookCombCGPacket;
-	SkillBookCombCGPacket.bHeader = HEADER_CG_SKILLBOOK_COMB;
-	SkillBookCombCGPacket.bAction = bAction;
-	memcpy(SkillBookCombCGPacket.CombItemGrid, pPos, sizeof(TItemPos) * SKILLBOOK_COMB_SLOT_MAX);
-
-	if (!Send(sizeof(SkillBookCombCGPacket), &SkillBookCombCGPacket))
-		return false;
-
-	return true;
-}
-#endif
-
-#if defined(ENABLE_MINI_GAME_CATCH_KING)
-bool CPythonNetworkStream::SendMiniGameCatchKing(BYTE bSubHeader, BYTE bSubArgument)
-{
-	if (!__CanActMainInstance())
-		return true;
-
-	TPacketCGMiniGameCatchKing packet;
-	packet.bHeader = HEADER_CG_MINI_GAME_CATCH_KING;
-	packet.bSubHeader = bSubHeader;
-	packet.bSubArgument = bSubArgument;
-
-	if (!Send(sizeof(TPacketCGMiniGameCatchKing), &packet))
-	{
-		Tracef("SendMiniGameCatchKing Send Packet Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvMiniGameCatchKingPacket()
-{
-	std::vector<char> vPacketBuffer;
-	vPacketBuffer.clear();
-
-	TPacketGCMiniGameCatchKing Packet;
-	if (!Recv(sizeof(Packet), &Packet))
-		return false;
-
-	unsigned int uiPacketSize = Packet.wSize - sizeof(Packet);
-	if (uiPacketSize > 0)
-	{
-		vPacketBuffer.resize(uiPacketSize);
-		if (!Recv(uiPacketSize, &vPacketBuffer[0]))
-			return false;
-	}
-
-	switch (Packet.bSubHeader)
-	{
-		case CATCHKING_GC_START:
-		{
-			DWORD dwBigScore = *(DWORD*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameCatchKingEventStart", Py_BuildValue("(i)", dwBigScore));
-		}
-		break;
-
-		case CATCHKING_GC_SET_CARD:
-		{
-			BYTE bCardNumber = *(BYTE*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameCatchKingSetHandCard", Py_BuildValue("(i)", bCardNumber));
-		}
-		break;
-
-		case CATCHKING_GC_RESULT_FIELD:
-		{
-			TPacketGCMiniGameCatchKingResult* pkData = (TPacketGCMiniGameCatchKingResult*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameCatchKingResultField", Py_BuildValue("(iiiibbbb)",
-				pkData->dwPoints, pkData->bRowType, pkData->bCardPos, pkData->bCardValue,
-				pkData->bKeepFieldCard, pkData->bDestroyHandCard, pkData->bGetReward, pkData->bIsFiveNearBy));
-		}
-		break;
-
-		case CATCHKING_GC_SET_END_CARD:
-		{
-			TPacketGCMiniGameCatchKingSetEndCard* pkData = (TPacketGCMiniGameCatchKingSetEndCard*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameCatchKingSetEndCard", Py_BuildValue("(ii)",
-				pkData->bCardPos, pkData->bCardValue));
-		}
-		break;
-
-		case CATCHKING_GC_REWARD:
-		{
-			BYTE bReturnCode = *(BYTE*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameCatchKingReward", Py_BuildValue("(i)", bReturnCode));
-		}
-		break;
-
-#if defined(ENABLE_CATCH_KING_EVENT_FLAG_RENEWAL)
-		case CATCHKING_GC_SET_CARD_PIECE_FLAG:
-		case CATCHKING_GC_SET_CARD_FLAG:
-		case CATCHKING_GC_SET_QUEST_FLAG:
-		case CATCHKING_GC_NO_MORE_GAIN:
-		{
-			TPacketGCMiniGameCatchKingQuestFlag* pkData = (TPacketGCMiniGameCatchKingQuestFlag*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CatchKingFlagProcess", Py_BuildValue("(i(ii))",
-				Packet.bSubHeader, pkData->wPieceCount, pkData->wPackCount));
-		}
-		break;
-#endif
-
-		default:
-			TraceError("CPythonNetworkStream::RecvMiniGameCatchKingPacket: Unknown SubHeader %d\n", Packet.bSubHeader);
-			break;
-	}
-
-	return true;
-}
-
-#if defined(ENABLE_CATCH_KING_EVENT_FLAG_RENEWAL)
-bool CPythonNetworkStream::SendMiniGameCatchKingRequestQuestFlag()
-{
-	TPacketCGMiniGameCatchKing Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_CATCH_KING;
-	Packet.bSubHeader = CATCHKING_CG_REQUEST_QUEST_FLAG;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameCatchKingRequestQuestFlag Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-#endif
-#endif
-
-#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
-bool CPythonNetworkStream::RecvAcceRefinePacket()
-{
-	TPacketGCAcceRefine Packet;
-	if (!Recv(sizeof(TPacketGCAcceRefine), &Packet))
-	{
-		Tracef("CPythonNetworkStream::RecvAcceRefinePacket Error\n");
-		return false;
-	}
-
-	UINT uiPacketSize = (Packet.wSize - sizeof(TPacketGCAcceRefine));
-	switch (Packet.bSubHeader)
-	{
-		case ACCE_REFINE_SUBHEADER_GC_CLOSE:
-		case ACCE_REFINE_SUBHEADER_GC_OPEN:
-		{
-			if (uiPacketSize > 0)
-			{
-				TSubPacketGCAcceRefineOpenClose SubPacket;
-				assert(uiPacketSize % sizeof(TSubPacketGCAcceRefineOpenClose) == 0 && "ACCE_REFINE_SUBHEADER_GC_CLOSE | ACCE_REFINE_SUBHEADER_GC_OPEN");
-				if (!Recv(sizeof(TSubPacketGCAcceRefineOpenClose), &SubPacket))
-					return false;
-
-				if (Packet.bSubHeader == ACCE_REFINE_SUBHEADER_GC_CLOSE)
-				{
-					if (SubPacket.bServerClose)
-						PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseAcceWindow", Py_BuildValue("()"));
-
-					for (BYTE bSlotIndex = ACCE_SLOT_LEFT; bSlotIndex < ACCE_SLOT_MAX; ++bSlotIndex)
-						CPythonPlayer::Instance().DelAcceItemData(bSlotIndex);
-				}
-				else if (Packet.bSubHeader == ACCE_REFINE_SUBHEADER_GC_OPEN)
-				{
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenAcceWindow", Py_BuildValue("(i)", SubPacket.bType));
-				}
-
-				CPythonPlayer::Instance().SetAcceRefineWindowType(SubPacket.bType);
-			}
-			else
-				TraceError("CPythonNetworkStream::RecvAcceRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
-		}
-		break;
-
-		case ACCE_REFINE_SUBHEADER_GC_SET_ITEM:
-		{
-			if (uiPacketSize > 0)
-			{
-				TSubPacketGCAcceRefineSetItem SubPacket;
-				assert(uiPacketSize % sizeof(TSubPacketGCAcceRefineSetItem) == 0 && "ACCE_REFINE_SUBHEADER_GC_SET_ITEM");
-				if (!Recv(sizeof(TSubPacketGCAcceRefineSetItem), &SubPacket))
-					return false;
-
-				TItemData ItemData = {};
-				ItemData.dwVnum = SubPacket.Item.dwVnum;
-				ItemData.dwCount = SubPacket.Item.dwCount;
-				for (BYTE bSocketIndex = 0; bSocketIndex < ITEM_SOCKET_SLOT_MAX_NUM; ++bSocketIndex)
-					ItemData.alSockets[bSocketIndex] = SubPacket.Item.alSockets[bSocketIndex];
-				for (BYTE bAttrIndex = 0; bAttrIndex < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++bAttrIndex)
-					ItemData.aAttr[bAttrIndex] = SubPacket.Item.aAttr[bAttrIndex];
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-				ItemData.dwTransmutationVnum = SubPacket.Item.dwTransmutationVnum;
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-				ItemData.RefineElement = SubPacket.Item.RefineElement;
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-				for (BYTE bApplyIndex = 0; bApplyIndex < ITEM_APPLY_RANDOM_SLOT_MAX_NUM; ++bApplyIndex)
-					ItemData.aApplyRandom[bApplyIndex] = SubPacket.Item.aApplyRandom[bApplyIndex];
-#endif
-#if defined(ENABLE_SET_ITEM)
-				ItemData.bSetValue = SubPacket.Item.bSetValue;
-#endif
-
-				if (SubPacket.AttachedPos.IsValidCell() && !SubPacket.AttachedPos.IsEquipCell())
-					CPythonPlayer::Instance().SetActivatedAcceSlot(static_cast<BYTE>(SubPacket.SelectedPos.cell), SubPacket.AttachedPos);
-
-				CPythonPlayer::Instance().SetAcceItemData(static_cast<BYTE>(SubPacket.SelectedPos.cell), ItemData);
-			}
-			else
-				TraceError("CPythonNetworkStream::RecvAcceRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
-		}
-		break;
-
-		case ACCE_REFINE_SUBHEADER_GC_CLEAR_SLOT:
-		{
-			if (uiPacketSize > 0)
-			{
-				TSubPacketGCAcceRefineClearSlot SubPacket;
-				assert(uiPacketSize % sizeof(TSubPacketGCAcceRefineClearSlot) == 0 && "ACCE_REFINE_SUBHEADER_GC_CLEAR_SLOT");
-				if (!Recv(sizeof(TSubPacketGCAcceRefineClearSlot), &SubPacket))
-					return false;
-
-				CPythonPlayer::Instance().DelAcceItemData(SubPacket.bSlotIndex);
-			}
-			else
-				TraceError("CPythonNetworkStream::RecvAcceRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
-		}
-		break;
-
-		case ACCE_REFINE_SUBHEADER_GC_CLEAR_ALL:
-		{
-			for (BYTE bSlotIndex = ACCE_SLOT_LEFT; bSlotIndex < ACCE_SLOT_MAX; ++bSlotIndex)
-				CPythonPlayer::Instance().DelAcceItemData(bSlotIndex);
-		}
-		break;
-	}
-
-	__RefreshInventoryWindow();
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendAcceRefineCheckIn(TItemPos AttachedPos, TItemPos SelectedPos, BYTE bType)
-{
-	__PlayInventoryItemDropSound(AttachedPos);
-
-	TPacketCGAcceRefine Packet;
-	Packet.wSize = sizeof(TPacketCGAcceRefine) + sizeof(TSubPacketCGAcceRefineCheckIn);
-	Packet.bSubHeader = ACCE_REFINE_SUBHEADER_CG_CHECKIN;
-
-	TSubPacketCGAcceRefineCheckIn SubPacket;
-	SubPacket.AttachedPos = AttachedPos;
-	SubPacket.SelectedPos = SelectedPos;
-	SubPacket.bType = bType;
-
-	if (!Send(sizeof(TPacketCGAcceRefine), &Packet))
-		return false;
-
-	if (!Send(sizeof(TSubPacketCGAcceRefineCheckIn), &SubPacket))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendAcceRefineCheckOut(TItemPos SelectedPos, BYTE bType)
-{
-	TPacketCGAcceRefine Packet;
-	Packet.wSize = sizeof(TPacketCGAcceRefine) + sizeof(TSubPacketCGAcceRefineCheckOut);
-	Packet.bSubHeader = ACCE_REFINE_SUBHEADER_CG_CHECKOUT;
-
-	TSubPacketCGAcceRefineCheckOut SubPacket;
-	SubPacket.SelectedPos = SelectedPos;
-	SubPacket.bType = bType;
-
-	if (!Send(sizeof(TPacketCGAcceRefine), &Packet))
-		return false;
-
-	if (!Send(sizeof(TSubPacketCGAcceRefineCheckOut), &SubPacket))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendAcceRefineAccept(BYTE bType)
-{
-	TPacketCGAcceRefine Packet;
-	Packet.wSize = sizeof(TPacketCGAcceRefine) + sizeof(TSubPacketCGAcceRefineAccept);
-	Packet.bSubHeader = ACCE_REFINE_SUBHEADER_CG_ACCEPT;
-
-	TSubPacketCGAcceRefineAccept SubPacket;
-	SubPacket.bType = bType;
-
-	if (!Send(sizeof(TPacketCGAcceRefine), &Packet))
-		return false;
-
-	if (!Send(sizeof(TSubPacketCGAcceRefineAccept), &SubPacket))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendAcceRefineCancel()
-{
-	TPacketCGAcceRefine Packet;
-	Packet.wSize = sizeof(TPacketCGAcceRefine);
-	Packet.bSubHeader = ACCE_REFINE_SUBHEADER_CG_CANCEL;
-
-	if (!Send(sizeof(TPacketCGAcceRefine), &Packet))
-		return false;
-
-	return SendSequence();
-}
-#endif
-
-#if defined(ENABLE_AURA_COSTUME_SYSTEM)
-bool CPythonNetworkStream::RecvAuraRefinePacket()
-{
-	TPacketGCAuraRefine Packet;
-	if (!Recv(sizeof(TPacketGCAuraRefine), &Packet))
-	{
-		Tracef("CPythonNetworkStream::RecvAuraRefinePacket Error\n");
-		return false;
-	}
-
-	UINT uiPacketSize = (Packet.wSize - sizeof(TPacketGCAuraRefine));
-	switch (Packet.bSubHeader)
-	{
-		case AURA_REFINE_SUBHEADER_GC_CLOSE:
-		case AURA_REFINE_SUBHEADER_GC_OPEN:
-		{
-			if (uiPacketSize > 0)
-			{
-				TSubPacketGCAuraRefineOpenClose SubPacket;
-				assert(uiPacketSize % sizeof(TSubPacketGCAuraRefineOpenClose) == 0 && "AURA_REFINE_SUBHEADER_CG_CLOSE | AURA_REFINE_SUBHEADER_CG_OPEN");
-				if (!Recv(sizeof(TSubPacketGCAuraRefineOpenClose), &SubPacket))
-					return false;
-
-				if (Packet.bSubHeader == AURA_REFINE_SUBHEADER_GC_CLOSE)
-				{
-					if (SubPacket.bServerClose)
-						PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseAuraWindow", Py_BuildValue("()"));
-
-					for (BYTE bSlotIndex = AURA_SLOT_MAIN; bSlotIndex < AURA_SLOT_MAX; ++bSlotIndex)
-						CPythonPlayer::Instance().DelAuraItemData(bSlotIndex);
-				}
-				else if (Packet.bSubHeader == AURA_REFINE_SUBHEADER_GC_OPEN)
-				{
-					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenAuraWindow", Py_BuildValue("(i)", SubPacket.bType));
-				}
-
-				CPythonPlayer::Instance().SetAuraWindowType(SubPacket.bType);
-			}
-			else
-				TraceError("CPythonNetworkStream::RecvAuraRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
-		}
-		break;
-
-		case AURA_REFINE_SUBHEADER_GC_SET_ITEM:
-		{
-			if (uiPacketSize > 0)
-			{
-				TSubPacketGCAuraRefineSetItem SubPacket;
-				assert(uiPacketSize % sizeof(TSubPacketGCAuraRefineSetItem) == 0 && "AURA_REFINE_SUBHEADER_GC_SET_ITEM");
-				if (!Recv(sizeof(TSubPacketGCAuraRefineSetItem), &SubPacket))
-					return false;
-
-				TItemData ItemData = {};
-				ItemData.dwVnum = SubPacket.Item.dwVnum;
-				ItemData.dwCount = SubPacket.Item.dwCount;
-				for (BYTE bSocketIndex = 0; bSocketIndex < ITEM_SOCKET_SLOT_MAX_NUM; ++bSocketIndex)
-					ItemData.alSockets[bSocketIndex] = SubPacket.Item.alSockets[bSocketIndex];
-				for (BYTE bAttrIndex = 0; bAttrIndex < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++bAttrIndex)
-					ItemData.aAttr[bAttrIndex] = SubPacket.Item.aAttr[bAttrIndex];
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-				ItemData.dwTransmutationVnum = SubPacket.Item.dwTransmutationVnum;
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-				for (BYTE bApplyIndex = 0; bApplyIndex < ITEM_APPLY_RANDOM_SLOT_MAX_NUM; ++bApplyIndex)
-					ItemData.aApplyRandom[bApplyIndex] = SubPacket.Item.aApplyRandom[bApplyIndex];
-#endif
-#if defined(ENABLE_SET_ITEM)
-				ItemData.bSetValue = SubPacket.Item.bSetValue;
-#endif
-
-				if (SubPacket.AttachedPos.IsValidCell() && !SubPacket.AttachedPos.IsEquipCell())
-					CPythonPlayer::Instance().SetActivatedAuraSlot(static_cast<BYTE>(SubPacket.SelectedPos.cell), SubPacket.AttachedPos);
-
-				CPythonPlayer::Instance().SetAuraItemData(static_cast<BYTE>(SubPacket.SelectedPos.cell), ItemData);
-			}
-			else
-				TraceError("CPythonNetworkStream::RecvAuraRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
-		}
-		break;
-
-		case AURA_REFINE_SUBHEADER_GC_CLEAR_SLOT:
-		{
-			if (uiPacketSize > 0)
-			{
-				TSubPacketGCAuraRefineClearSlot SubPacket;
-				assert(uiPacketSize % sizeof(TSubPacketGCAuraRefineClearSlot) == 0 && "AURA_REFINE_SUBHEADER_GC_CLEAR_SLOT");
-				if (!Recv(sizeof(TSubPacketGCAuraRefineClearSlot), &SubPacket))
-					return false;
-
-				CPythonPlayer::Instance().DelAuraItemData(SubPacket.bSlotIndex);
-			}
-			else
-				TraceError("CPythonNetworkStream::RecvAuraRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
-		}
-		break;
-
-		case AURA_REFINE_SUBHEADER_GC_CLEAR_ALL:
-		{
-			for (BYTE bSlotIndex = AURA_SLOT_MAIN; bSlotIndex < AURA_SLOT_MAX; ++bSlotIndex)
-				CPythonPlayer::Instance().DelAuraItemData(bSlotIndex);
-		}
-		break;
-
-		case AURA_REFINE_SUBHEADER_GC_INFO:
-		{
-			if (uiPacketSize > 0)
-			{
-				for (UINT uiPacketOffset = 0; uiPacketSize > 0; ++uiPacketOffset)
-				{
-					assert(uiPacketSize % sizeof(TSubPacketGCAuraRefineInfo) == 0 && "AURA_REFINE_SUBHEADER_GC_INFO");
-					TSubPacketGCAuraRefineInfo SubPacket;
-					if (!Recv(sizeof(TSubPacketGCAuraRefineInfo), &SubPacket))
-						return false;
-
-					CPythonPlayer::Instance().SetAuraRefineInfo(SubPacket.bInfoType, SubPacket.bInfoLevel, SubPacket.bInfoExpPercent);
-					uiPacketSize -= sizeof(TSubPacketGCAuraRefineInfo);
-				}
-			}
-			else
-				TraceError("CPythonNetworkStream::RecvAuraRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
-		}
-		break;
-	}
-
-	__RefreshInventoryWindow();
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendAuraRefineCheckIn(TItemPos AttachedPos, TItemPos SelectedPos, BYTE bType)
-{
-	__PlayInventoryItemDropSound(AttachedPos);
-
-	TPacketCGAuraRefine Packet;
-	Packet.wSize = sizeof(TPacketCGAuraRefine) + sizeof(TSubPacketCGAuraRefineCheckIn);
-	Packet.bSubHeader = AURA_REFINE_SUBHEADER_CG_CHECKIN;
-
-	TSubPacketCGAuraRefineCheckIn SubPacket;
-	SubPacket.AttachedPos = AttachedPos;
-	SubPacket.SelectedPos = SelectedPos;
-	SubPacket.bType = bType;
-
-	if (!Send(sizeof(TPacketCGAuraRefine), &Packet))
-		return false;
-
-	if (!Send(sizeof(TSubPacketCGAuraRefineCheckIn), &SubPacket))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendAuraRefineCheckOut(TItemPos SelectedPos, BYTE bType)
-{
-	TPacketCGAuraRefine Packet;
-	Packet.wSize = sizeof(TPacketCGAuraRefine) + sizeof(TSubPacketCGAuraRefineCheckOut);
-	Packet.bSubHeader = AURA_REFINE_SUBHEADER_CG_CHECKOUT;
-
-	TSubPacketCGAuraRefineCheckOut SubPacket;
-	SubPacket.SelectedPos = SelectedPos;
-	SubPacket.bType = bType;
-
-	if (!Send(sizeof(TPacketCGAuraRefine), &Packet))
-		return false;
-
-	if (!Send(sizeof(TSubPacketCGAuraRefineCheckOut), &SubPacket))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendAuraRefineAccept(BYTE bType)
-{
-	TPacketCGAuraRefine Packet;
-	Packet.wSize = sizeof(TPacketCGAuraRefine) + sizeof(TSubPacketCGAuraRefineAccept);
-	Packet.bSubHeader = AURA_REFINE_SUBHEADER_CG_ACCEPT;
-
-	TSubPacketCGAuraRefineAccept SubPacket;
-	SubPacket.bType = bType;
-
-	if (!Send(sizeof(TPacketCGAuraRefine), &Packet))
-		return false;
-
-	if (!Send(sizeof(TSubPacketCGAuraRefineAccept), &SubPacket))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendAuraRefineCancel()
-{
-	TPacketCGAuraRefine Packet;
-	Packet.wSize = sizeof(TPacketCGAuraRefine);
-	Packet.bSubHeader = AURA_REFINE_SUBHEADER_CG_CANCEL;
-
-	if (!Send(sizeof(TPacketCGAuraRefine), &Packet))
-		return false;
-
-	return SendSequence();
-}
-#endif
-
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-#define ChangeLookPacket(x) TPacketCGChangeLook Packet(static_cast<std::underlying_type_t<EPacketCGChangeLookSubHeader>>(EPacketCGChangeLookSubHeader::x))
-
-bool CPythonNetworkStream::SendChangeLookCheckInPacket(const TItemPos& c_rItemPos, const BYTE c_bSlotIndex)
-{
-	ChangeLookPacket(ITEM_CHECK_IN);
-	Packet.bSlotIndex = c_bSlotIndex;
-	Packet.ItemPos = c_rItemPos;
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("CPythonNetworkStream::SendChangeLookCheckInPacket Error\n");
-		return false;
-	}
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendChangeLookCheckOutPacket(const BYTE c_bSlotIndex)
-{
-	ChangeLookPacket(ITEM_CHECK_OUT);
-	Packet.bSlotIndex = c_bSlotIndex;
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("CPythonNetworkStream::SendChangeLookCheckOutPacket Error\n");
-		return false;
-	}
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendChangeLookCheckInFreeYangItemPacket(const TItemPos& c_rItemPos)
-{
-	ChangeLookPacket(FREE_ITEM_CHECK_IN);
-	Packet.ItemPos = c_rItemPos;
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("CPythonNetworkStream::SendChangeLookCheckInFreeYangItemPacket Error\n");
-		return false;
-	}
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendChangeLookCheckOutFreeYangItemPacket()
-{
-	ChangeLookPacket(FREE_ITEM_CHECK_OUT);
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("CPythonNetworkStream::SendChangeLookCheckOutFreeYangItemPacket Error\n");
-		return false;
-	}
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendChangeLookAcceptPacket()
-{
-	ChangeLookPacket(ACCEPT);
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("CPythonNetworkStream::SendChangeLookAcceptPacket Error\n");
-		return false;
-	}
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendChangeLookCancelPacket()
-{
-	ChangeLookPacket(CANCEL);
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("CPythonNetworkStream::SendChangeLookCancelPacket Error\n");
-		return false;
-	}
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvChangeLookItemSetPacket()
-{
-	TPacketGCChangeLookSet kItemSet;
-	if (!Recv(sizeof(kItemSet), &kItemSet))
-		return false;
-
-	if (kItemSet.bSlotIndex >= static_cast<BYTE>(EChangeLookSlots::CHANGE_LOOK_SLOT_MAX))
-		return true;
-
-	CPythonPlayer::Instance().SetChangeLookItemData(kItemSet);
-	__RefreshInventoryWindow();
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvChangeLookItemDelPacket()
-{
-	TPacketGCChangeLookDel kItemDel;
-	if (!Recv(sizeof(kItemDel), &kItemDel))
-		return false;
-
-	CPythonPlayer::Instance().DelChangeLookItemData(kItemDel.bSlotIndex, true);
-	__RefreshInventoryWindow();
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvChangeLookFreeItemSetPacket()
-{
-	TPacketGCChangeLookSet kItemSet;
-	if (!Recv(sizeof(kItemSet), &kItemSet))
-		return false;
-
-	CPythonPlayer::Instance().SetChangeLookFreeItemData(kItemSet);
-	__RefreshInventoryWindow();
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvChangeLookFreeItemDelPacket()
-{
-	TPacketGCChangeLookDel kItemDel;
-	if (!Recv(sizeof(kItemDel), &kItemDel))
-		return false;
-
-	CPythonPlayer::Instance().DelChangeLookFreeItemData(true);
-	__RefreshInventoryWindow();
-
-	return true;
-}
-#endif
-
-#if defined(ENABLE_MAILBOX)
-bool CPythonNetworkStream::RecvMailboxProcess()
-{
-	TPacketMailboxProcess p;
-
-	if (!Recv(sizeof(p), &p))
-		return false;
-
-	switch (p.bSubHeader)
-	{
-		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_CLOSE:
-			CPythonMailBox::Instance().Destroy();
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("(ii)", p.bSubHeader, p.bArg1));
-			break;
-		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_OPEN:
-		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_WRITE_CONFIRM:
-		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_WRITE:
-		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_ALL_DELETE:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("(ii)", p.bSubHeader, p.bArg1));
-			break;
-		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_ADD_DATA:
-		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_DELETE:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("(i(ii))", p.bSubHeader, p.bArg1, p.bArg2));
-			break;
-		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_GET_ITEMS:
-			CPythonMailBox::Instance().ResetAddData(p.bArg1);
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("(i(ii))", p.bSubHeader, p.bArg1, p.bArg2));
-			break;
-		default:
-			TraceError("CPythonNetworkStream::RecvMailboxProcess: Unknown subheader: %d\n", p.bSubHeader);
-			break;
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvMailbox()
-{
-	TPacketGCMailBox p;
-	if (!Recv(sizeof(p), &p))
-		return false;
-
-	CPythonMailBox::Instance().Destroy();
-
-	unsigned int iPacketSize = (p.wSize - sizeof(TPacketGCMailBox));
-	for (; iPacketSize > 0; iPacketSize -= sizeof(TPacketGCMailBoxMessage))
-	{
-		TPacketGCMailBoxMessage Message;
-		if (!Recv(sizeof(Message), &Message))
-			return false;
-
-#if defined(ENABLE_LOCALE_CLIENT)
-		if (Message.bIsGMPost)
-			CPythonLocale::Instance().FormatString(Message.szTitle, sizeof(Message.szTitle));
-#endif
-
-		CPythonMailBox::Instance().AddMail(new CPythonMailBox::SMailBox(Message.SendTime, Message.DeleteTime, Message.szTitle, Message.bIsGMPost, Message.bIsItemExist, Message.bIsConfirm));
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvMailboxAddData()
-{
-	TPacketGCMailBoxAddData p;
-
-	if (!Recv(sizeof(p), &p))
-		return false;
-
-	CPythonMailBox::SMailBox* _Data = CPythonMailBox::Instance().GetMail(p.Index);
-	if (_Data == nullptr)
-	{
-		Tracef("RecvMailboxAddData Error: SMailBox is null.\n");
-		return true;
-	}
-
-	CPythonMailBox::SMailBoxAddData*& _AddData = _Data->AddData;
-	if (_AddData != nullptr)
-	{
-		Tracef("RecvMailboxAddData Error: SMailBoxAddData is not null.\n");
-		return true;
-	}
-
-	_Data->bIsConfirm = true;
-	_AddData = new CPythonMailBox::SMailBoxAddData(p.szFrom, p.szMessage, p.iYang, p.iWon, p.dwItemVnum, p.dwItemCount, p.alSockets, p.aAttr
-#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
-		, p.dwChangeLookVnum
-#endif
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-		, &p.RefineElement
-#endif
-#if defined(ENABLE_APPLY_RANDOM)
-		, p.aApplyRandom
-#endif
-#if defined(ENABLE_SET_ITEM)
-		, p.bSetValue
-#endif
-	);
-	return true;
-}
-
-bool CPythonNetworkStream::RecvMailboxAll()
-{
-	TPacketGCMailBox p;
-	if (!Recv(sizeof(p), &p))
-		return false;
-
-	PyObject* list = PyList_New(0);
-
-	unsigned int iPacketSize = (p.wSize - sizeof(TPacketGCMailBox));
-	for (; iPacketSize > 0; iPacketSize -= sizeof(TPacketGCMailboxProcessAll))
-	{
-		TPacketGCMailboxProcessAll Index;
-		if (!Recv(sizeof(Index), &Index))
-			return false;
-
-		CPythonMailBox::Instance().ResetAddData(Index.Index);
-		PyList_Append(list, Py_BuildValue("i", Index.Index));
-	}
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("i(iO)",
-		CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_ALL_GET_ITEMS, CPythonMailBox::EMAILBOX_POST_ALL_GET_ITEMS::POST_ALL_GET_ITEMS_OK, list));
-
-	Py_DECREF(list);
-	return true;
-}
-
-bool CPythonNetworkStream::RecvMailboxUnread()
-{
-	TMailBoxRespondUnreadData p;
-
-	if (!Recv(sizeof(p), &p))
-		return false;
-
-	const bool bFlash = p.bItemMessageCount > 0;
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("i(iiiii)", CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_UNREAD_DATA,
-		bFlash, (p.bItemMessageCount + p.bCommonMessageCount), p.bItemMessageCount, p.bCommonMessageCount, p.bGMVisible));
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendPostWriteConfirm(const char* szName)
-{
-	TPacketCGMailboxWriteConfirm p;
-	p.bHeader = HEADER_CG_MAILBOX_WRITE_CONFIRM;
-	std::strcpy(p.szName, szName);
-
-	if (!Send(sizeof(p), &p))
-	{
-		Tracef("SendPostWriteConfirm Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMailBoxClose()
-{
-	TPacketMailboxProcess p;
-	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
-	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_CLOSE;
-
-	if (!Send(sizeof(p), &p))
-	{
-		Tracef("SendMailBoxClose Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPostDelete(const BYTE Index)
-{
-	TPacketMailboxProcess p;
-	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
-	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_DELETE;
-	p.bArg1 = Index;
-
-	if (!Send(sizeof(p), &p))
-	{
-		Tracef("SendPostDelete Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPostAllDelete()
-{
-	TPacketMailboxProcess p;
-	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
-	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_DELETE;
-
-	if (!Send(sizeof(p), &p))
-	{
-		Tracef("SendPostAllDelete Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPostGetItems(const BYTE Index)
-{
-	TPacketMailboxProcess p;
-	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
-	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_GET_ITEMS;
-	p.bArg1 = Index;
-
-	if (!Send(sizeof(p), &p))
-	{
-		Tracef("SendPostGetItems Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPostAllGetItems()
-{
-	TPacketMailboxProcess p;
-	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
-	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_GET_ITEMS;
-
-	if (!Send(sizeof(p), &p))
-	{
-		Tracef("SendPostAllGetItems Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RequestPostAddData(const BYTE ButtonIndex, const BYTE DataIndex)
-{
-	TPacketMailboxProcess p;
-	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
-	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_ADD_DATA;
-	p.bArg1 = ButtonIndex;
-	p.bArg2 = DataIndex;
-
-	if (!Send(sizeof(p), &p))
-	{
-		Tracef("RequestPostAddData Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPostWrite(const char* szName, const char* szTitle, const char* szMessage, const TItemPos& pos, const int iYang, const int iWon)
-{
-	TPacketCGMailboxWrite p;
-	p.bHeader = HEADER_CG_MAILBOX_WRITE;
-	std::strcpy(p.szName, szName);
-	std::strcpy(p.szTitle, szTitle);
-	std::strcpy(p.szMessage, szMessage);
-	p.pos = pos;
-	p.iYang = iYang;
-	p.iWon = iWon;
-
-	if (!Send(sizeof(p), &p))
-	{
-		Tracef("SendPostWrite Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-#endif
-
-#ifdef ENABLE_GROWTH_PET_SYSTEM
-bool CPythonNetworkStream::SendPetHatchingPacket(const char* c_szName, TItemPos eggPos)
-{
-	TPacketCGPetHatch packet;
-	packet.header = HEADER_CG_PET_HATCH;
-	strncpy(packet.name, c_szName, sizeof(packet.name));
-	packet.eggPos = eggPos;
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetWindowType(BYTE bType)
-{
-	TPacketCGPetWindowType packet;
-	packet.header = HEADER_CG_PET_WINDOW_TYPE;
-	packet.type = bType;
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetHatchingWindowPacket(bool bState)
-{
-	TPacketCGPetWindow packet;
-	packet.header = HEADER_CG_PET_WINDOW;
-	packet.window = PET_WINDOW_HATCH;
-	packet.state = bState;
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetNameChangeWindowPacket(bool bState)
-{
-	TPacketCGPetWindow packet;
-	packet.header = HEADER_CG_PET_WINDOW;
-	packet.window = PET_WINDOW_NAME_CHANGE;
-	packet.state = bState;
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetNameChangePacket(const char* c_szName, TItemPos changeNamePos, TItemPos upBringingPos)
-{
-	TPacketCGPetNameChange packet;
-	packet.header = HEADER_CG_PET_NAME_CHANGE;
-	strncpy(packet.name, c_szName, sizeof(packet.name));
-	packet.changeNamePos = changeNamePos;
-	packet.upBringingPos = upBringingPos;
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetFeedPacket(int iFeedIndex, const std::vector<std::pair<WORD, WORD>>& itemVec)
-{
-	TPacketCGPetFeed packet;
-	packet.header = HEADER_CG_PET_FEED;
-	packet.index = iFeedIndex;
-	memset(packet.pos, 0, sizeof(packet.pos));
-	memset(packet.count, 0, sizeof(packet.count));
-
-	for (int i = 0; i < itemVec.size(); i++)
-	{
-		packet.pos[i] = itemVec.at(i).first;
-		packet.count[i] = itemVec.at(i).second;
-	}
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetAttrDetermine(TItemPos determinePos)
-{
-	TPacketCGPetDetermine packet;
-	packet.header = HEADER_CG_PET_DETERMINE;
-	packet.determinePos = determinePos;
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetAttrChange(TItemPos upBringingPos, TItemPos attrChangePos)
-{
-	TPacketCGPetAttrChange packet;
-	packet.header = HEADER_CG_PET_ATTR_CHANGE;
-	packet.upBringingPos = upBringingPos;
-	packet.attrChangePos = attrChangePos;
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetRevive(TItemPos upBringingPos, const std::vector<std::pair<WORD, WORD>>& itemVec)
-{
-	TPacketCGPetRevive packet;
-	packet.header = HEADER_CG_PET_REVIVE;
-	packet.upBringingPos = upBringingPos;
-	memset(packet.pos, 0, sizeof(packet.pos));
-	memset(packet.count, 0, sizeof(packet.count));
-
-	for (int i = 0; i < itemVec.size(); i++)
-	{
-		packet.pos[i] = itemVec.at(i).first;
-		packet.count[i] = itemVec.at(i).second;
-	}
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetLearnSkill(BYTE bSlot, TItemPos learnSkillPos)
-{
-	TPacketCGPetLearnSkill packet;
-	packet.header = HEADER_CG_PET_LEARN_SKILL;
-	packet.slotIndex = bSlot;
-	packet.learnSkillPos = learnSkillPos;
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetSkillUpgradeRequest(BYTE bSlot)
-{
-	TPacketCGPetSkillUpgrade packet;
-	packet.header = HEADER_CG_PET_SKILL_UPGRADE;
-	packet.slotIndex = bSlot;
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetDeleteSkill(BYTE bSlot, TItemPos deleteSkillPos)
-{
-	TPacketCGPetDeleteSkill packet;
-	packet.header = HEADER_CG_PET_DELETE_SKILL;
-	packet.slotIndex = bSlot;
-	packet.deleteSkillPos = deleteSkillPos;
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendPetDeleteAllSkill(TItemPos deleteAllSkillPos)
-{
-	TPacketCGPetDeleteAllSkill packet;
-	packet.header = HEADER_CG_PET_DELETE_ALL_SKILL;
-	packet.deleteAllSkillPos = deleteAllSkillPos;
-
-	if (!Send(sizeof(packet), &packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvPet()
-{
-	TPacketGCPet packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		TraceError("TPacketGCPet Error");
-		return false;
-	}
-
-	switch (packet.subheader)
-	{
-	case SUBHEADER_PET_EGG_USE_SUCCESS:
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetHatchingWindowCommand", Py_BuildValue("(i)", CItemData::EGG_USE_SUCCESS));
-		break;
-	case SUBHEADER_PET_EGG_USE_FAILED_BECAUSE_NAME:
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetHatchingWindowCommand", Py_BuildValue("(i)", CItemData::EGG_USE_FAILED_BECAUSE_NAME));
-		break;
-	case SUBHEADER_PET_EGG_USE_FAILED_TIMEOVER:
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetHatchingWindowCommand", Py_BuildValue("(i)", CItemData::EGG_USE_FAILED_TIMEOVER));
-		break;
-	case SUBHEADER_PET_UNSUMMON:
-		CPythonPlayer::Instance().SetActivePet(NULL);
-		break;
-	case SUBHEADER_PET_FEED_FAILED:
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetFeedReuslt", Py_BuildValue("(i)", FALSE));
-		break;
-	case SUBHEADER_PET_FEED_SUCCESS:
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetFeedReuslt", Py_BuildValue("(i)", TRUE));
-		break;
-	case SUBHEADER_PET_REVIVE_FAILED:
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetReviveResult", Py_BuildValue("(i)", FALSE));
-		break;
-	case SUBHEADER_PET_REVIVE_SUCCESS:
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetReviveResult", Py_BuildValue("(i)", TRUE));
-		break;
-	case SUBHEADER_PET_WINDOW_TYPE_INFO:
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetWindowTypeResult", Py_BuildValue("(i)", PET_WINDOW_INFO));
-		break;
-	case SUBHEADER_PET_WINDOW_TYPE_ATTR_CHANGE:
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetWindowTypeResult", Py_BuildValue("(i)", PET_WINDOW_ATTR_CHANGE));
-		break;
-	case SUBHEADER_PET_WINDOW_TYPE_PREMIUM_FEED:
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetWindowTypeResult", Py_BuildValue("(i)", PET_WINDOW_PRIMIUM_FEEDSTUFF));
-		break;
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPetSet()
-{
-	TPacketGCPetSet packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		TraceError("TPacketGCPetSet Error");
-		return false;
-	}
-
-	CPythonPlayer::TPetData pet;
-	pet.dwID = packet.dwID;
-	pet.strName = packet.szName;
-	pet.dwSummonItemVnum = packet.dwSummonItemVnum;
-
-	for (DWORD i = 0; i < POINT_UPBRINGING_MAX_NUM; ++i)
-		pet.dwPoints[i] = packet.dwPoints[i];
-
-	for (int i = 0; i < PET_SKILL_COUNT_MAX; ++i)
-	{
-		pet.skillData.aSkillInfo[i].bSkill = packet.aSkill[i].bSkill;
-		pet.skillData.aSkillInfo[i].bLevel = packet.aSkill[i].bLevel;
-		pet.skillData.aSkillInfo[i].dwCooltime = packet.aSkill[i].dwCooltime;
-
-		if (!packet.aSkill[i].bLocked)
-			++pet.skillData.bSkillCount;
-	}
-
-	CPythonPlayer::Instance().SetPetData(&pet);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPetSetExchange()
-{
-	TPacketGCPetSet packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		TraceError("TPacketGCPetSet-Exchange Error");
-		return false;
-	}
-
-	CPythonPlayer::TPetData pet;
-	pet.dwID = packet.dwID;
-	pet.strName = packet.szName;
-	pet.dwSummonItemVnum = packet.dwSummonItemVnum;
-
-	for (DWORD i = 0; i < POINT_UPBRINGING_MAX_NUM; ++i)
-		pet.dwPoints[i] = packet.dwPoints[i];
-
-	for (int i = 0; i < PET_SKILL_COUNT_MAX; ++i)
-	{
-		pet.skillData.aSkillInfo[i].bSkill = packet.aSkill[i].bSkill;
-		pet.skillData.aSkillInfo[i].bLevel = packet.aSkill[i].bLevel;
-		pet.skillData.aSkillInfo[i].dwCooltime = packet.aSkill[i].dwCooltime;
-
-		if (!packet.aSkill[i].bLocked)
-			++pet.skillData.bSkillCount;
-	}
-
-	pet.bIsExchange = true;
-
-	CPythonPlayer::Instance().SetPetData(&pet);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPetDelete()
-{
-	TPacketGCPetDelete packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		TraceError("TPacketGCPetDelete Error");
-		return false;
-	}
-
-	CPythonPlayer::Instance().DeletePetData(packet.dwID);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPetSummon()
-{
-	TPacketGCPetSummon packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		TraceError("TPacketGCPetSummon Error");
-		return false;
-	}
-
-	CPythonPlayer::Instance().SetActivePet(packet.dwID);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPetPointChange()
-{
-	TPacketGCPetPointUpdate packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		TraceError("TPacketGCPetPointUpdate Error");
-		return false;
-	}
-
-	CPythonPlayer::Instance().SetPetStatus(packet.dwID, packet.bPoint, packet.dwValue);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPetNameChangeResult()
-{
-	TPacketGCPetNameChangeResult packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		TraceError("TPacketGCPetNameChangeResult Error");
-		return false;
-	}
-
-	switch (packet.subheader)
-	{
-	case SUBHEADER_PET_NAME_CHANGE_FAILED:
-	{
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetNameChangeWindowCommand", Py_BuildValue("(i)", CItemData::NAME_CHANGE_USE_FAILED_BECAUSE_NAME));
-	}	break;
-
-	case SUBHEADER_PET_NAME_CHANGE_SUCCESS:
-	{
-		CPythonPlayer::TPetData* pPet = nullptr;
-		CPythonPlayer::Instance().GetPetInfo(packet.dwID, &pPet);
-
-		if (pPet)
-			pPet->strName = packet.szName;
-
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetNameChangeWindowCommand", Py_BuildValue("(i)", CItemData::NAME_CHANGE_USE_SUCCESS));
-	}	break;
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPetSkillUpdate()
-{
-	TPacketGCPetSkillUpdate packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		TraceError("TPacketGCPetSkillUpdate Error");
-		return false;
-	}
-
-	CPythonPlayer::Instance().SetPetSkillData(packet.dwID, packet.aSkill);
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetAffectShowerRefresh", Py_BuildValue("()"));
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPetSkillCooltime()
-{
-	TPacketGCPetSkillCooltime packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		TraceError("TPacketGCPetSkillCooltime Error");
-		return false;
-	}
-
-	CPythonPlayer::Instance().SetPetSkillCooltime(packet.dwID, packet.bSlot, packet.dwCooltime);
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPetDetermineResult()
-{
-	TPacketGCPetDetermineResult packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		TraceError("TPacketGCPetDetermineResult Error");
-		return false;
-	}
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetAttrDetermineResult", Py_BuildValue("(i)", packet.type));
-	return true;
-}
-
-bool CPythonNetworkStream::RecvPetAttrChangeResult()
-{
-	TPacketGCPetAttrChangeResult packet;
-	if (!Recv(sizeof(packet), &packet))
-	{
-		TraceError("TPacketGCPetAttrChangeResult Error");
-		return false;
-	}
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetAttrChangeResult", Py_BuildValue("(ii)", packet.pos.cell, packet.type));
-
-	return true;
-}
-#endif
-
-#ifdef ENABLE_SHOP_SEARCH
-bool CPythonNetworkStream::RecvShopSearchResult()
-{
-	TPacketGCShopSearchResult pack;
-	if (!Recv(sizeof(pack), &pack))
-		return false;
-
-	CPythonShopSearch::Instance().SetResultMaxPage(pack.maxPageNum);
-
-	CPythonShopSearch::Instance().ClearResultItems();
-	for (int i = 0; i < pack.itemCount; ++i)
-	{
-		TShopSearchClientItem itemData;
-		if (!Recv(sizeof(itemData), &itemData))
-		{
-			TraceError("Bad size of packet");
-			return false;
-		}
-
-		CPythonShopSearch::Instance().AppendResultItem(itemData);
-	}
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ShopSearch_RecvResult", Py_BuildValue("()"));
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvShopSearchBuyResult()
-{
-	TPacketGCShopSearchBuyResult pack;
-	if (!Recv(sizeof(pack), &pack))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ShopSearch_RecvBuyDone", Py_BuildValue("(i)", pack.result));
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvShopSearchOwnerMessage()
-{
-	TPacketGCShopSearchOwnerMessage pack;
-	if (!Recv(sizeof(pack), &pack))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ShopSearch_RecvOwnerMessage", Py_BuildValue("(s)", pack.ownerName));
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvShopSearchSoldInfo()
-{
-	TPacketGCShopSearchSoldInfo pack;
-	if (!Recv(sizeof(pack), &pack))
-		return false;
-
-	CPythonShopSearch::Instance().ClearSoldItemInfo();
-
-	if (pack.results)
-	{
-		for (int i = 0; i < SHOPSEARCH_SOLD_ITEM_INFO_COUNT; ++i)
-		{
-			TShopSearchSoldItemInfo info;
-			if (!Recv(sizeof(info), &info))
-				return false;
-
-			CPythonShopSearch::Instance().SetSoldItemInfo(i, info);
-		}
-	}
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ShopSearch_RecvSoldInfo", Py_BuildValue("(b)", pack.results));
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendShopSearchByName(const std::string& itemName, WORD page, BYTE entryCountIdx, BYTE sortType)
-{
-	TPacketCGShopSearchByName pack;
-	pack.header = HEADER_CG_SHOP_SEARCH_BY_NAME;
-	strncpy(pack.itemName, itemName.c_str(), sizeof(pack.itemName));
-	pack.itemName[CItemData::ITEM_NAME_MAX_LEN] = '\0'; // strncpy is not automatically 0-terminated
-	pack.page = page;
-	pack.entryCountIdx = entryCountIdx;
-	pack.sortType = sortType;
-
-	if (!Send(sizeof(pack), &pack))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendShopSearchByOptions(const TShopSearchOptions& options, const TShopSearchItemType* itemTypeFlags, const DWORD* vnumList, WORD page, BYTE entryCountIdx, BYTE sortType)
-{
-	TPacketCGShopSearchByOptions pack;
-	pack.header = HEADER_CG_SHOP_SEARCH_BY_OPTION;
-	pack.options = options;
-	pack.page = page;
-	pack.entryCountIdx = entryCountIdx;
-	pack.sortType = sortType;
-
-	if (!Send(sizeof(pack), &pack))
-		return false;
-
-	if (options.typeFlagCount && !Send(options.typeFlagCount * sizeof(TShopSearchItemType), itemTypeFlags))
-		return false;
-
-	if (options.specificVnumCount && !Send(options.specificVnumCount * sizeof(DWORD), vnumList))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendShopSearchBuy(TShopSearchItemID itemID, DWORD itemVnum, int64_t itemPrice)
-{
-	TPacketCGShopSearchBuy pack;
-	pack.header = HEADER_CG_SHOP_SEARCH_BUY;
-	pack.itemID = itemID;
-	pack.itemVnum = itemVnum;
-	pack.itemPrice = itemPrice;
-
-	if (!Send(sizeof(pack), &pack))
-		return false;
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendShopSearchOwnerMessage(DWORD ownerID)
-{
-	TPacketCGShopSearchOwnerMessage pack;
-	pack.header = HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE;
-	pack.ownerID = ownerID;
-
-	if (!Send(sizeof(pack), &pack))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendShopSearchRequestSoldInfo(DWORD itemVnum)
-{
-	TPacketCGShopSearchRequestSoldInfo pack;
-	pack.header = HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO;
-	pack.itemVnum = itemVnum;
-
-	if (!Send(sizeof(pack), &pack))
-		return false;
-
-	return SendSequence();
-}
-#endif
-
-#if defined(ENABLE_RANKING_SYSTEM)
-#include "PythonRanking.h"
-bool CPythonNetworkStream::RecvRanking()
-{
-	TPacketGCRanking Packet;
-	if (!Recv(sizeof(Packet), &Packet))
-		return false;
-
-	CPythonRanking::Instance().Clear();
-
-	for (unsigned int iPacketSize = Packet.wSize - sizeof(Packet); iPacketSize > 0; iPacketSize -= sizeof(SRankingData))
-	{
-		SRankingData RKData;
-		if (Recv(sizeof(RKData), &RKData))
-			CPythonRanking::Instance().Add(Packet.bType, Packet.bCategory, RKData);
-	}
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenRankingBoard", Py_BuildValue("(ii)", Packet.bType, Packet.bCategory));
-
-	return true;
-}
-#endif
-
-#if defined(ENABLE_MOVE_COSTUME_ATTR)
-bool CPythonNetworkStream::SendItemCombinationPacket(const int iMediumIndex, const int iBaseIndex, const int iMaterialIndex)
-{
-	TPacketCGItemCombination p;
-	p.Header = HEADER_CG_ITEM_COMBINATION;
-	p.MediumIndex = iMediumIndex;
-	p.BaseIndex = iBaseIndex;
-	p.MaterialIndex = iMaterialIndex;
-
-	if (!Send(sizeof(p), &p))
-	{
-		Tracef("SendItemCombinationPacket Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendItemCombinationPacketCancel()
-{
-	TPacketCGItemCombinationCancel p;
-	p.Header = HEADER_CG_ITEM_COMBINATION_CANCEL;
-
-	if (!Send(sizeof(p), &p))
-	{
-		Tracef("SendItemCombinationPacketCancel Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-#endif
-
-#if defined(ENABLE_CHANGED_ATTR)
-bool CPythonNetworkStream::RecvSelectAttr()
-{
-	TPacketGCItemSelectAttr p;
-
-	if (!Recv(sizeof(p), &p))
-		return false;
-
-	CPythonPlayer::Instance().SetSelectAttr(p.aAttr);
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenSelectAttrDialog", Py_BuildValue("(ii)", p.pItemPos.window_type, p.pItemPos.cell));
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendChagedItemAttributePacket(const bool bNew, const TItemPos& pos)
-{
-	TPacketCGItemSelectAttr p;
-	p.bHeader = HEADER_CG_ITEM_SELECT_ATTR;
-	p.bNew = bNew;
-	p.pItemPos = pos;
-
-	if (!Send(sizeof(p), &p))
-	{
-		Tracef("SendChagedItemAttributePacket Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-#endif
-
-#if defined(ENABLE_LOOTING_SYSTEM)
-bool CPythonNetworkStream::SendLootFilterPacket(BYTE(&settings)[ELootFilter::LOOT_FILTER_SETTINGS_MAX])
-{
-	TPacketCGLootFilter p;
-	p.header = HEADER_CG_LOOT_FILTER;
-	memcpy(p.settings, settings, sizeof(p.settings));
-
-	if (!Send(sizeof(p), &p))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvLootFilterPacket()
-{
-	TPacketGCLootFilter p;
-	if (!Recv(sizeof(p), &p))
-		return false;
-
-	if (p.enable)
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "LootingSystemProcess", Py_BuildValue("()"));
-	else
-		CPythonItem::Instance().InsertLootFilteredItem(p.vid);
-
-	return true;
-}
-#endif
-
-// MARK_BUG_FIX
-void CPythonNetworkStream::RefreshGuildMark()
-{
-	__RefreshGuildWindowInfoPage();
-}
-// END_OF_MARK_BUG_FIX
-
-#if defined(ENABLE_MINI_GAME_RUMI)
-bool CPythonNetworkStream::RecvMiniGameRumi()
-{
-	std::vector<char> vPacketBuffer;
-	vPacketBuffer.clear();
-
-	TPacketGCMiniGameRumi Packet;
-	if (!Recv(sizeof(Packet), &Packet))
-		return false;
-
-	unsigned int uiPacketSize = Packet.wSize - sizeof(Packet);
-	if (uiPacketSize > 0)
-	{
-		vPacketBuffer.resize(uiPacketSize);
-		if (!Recv(uiPacketSize, &vPacketBuffer[0]))
-			return false;
-	}
-
-	switch (Packet.bSubHeader)
-	{
-		case RUMI_GC_SUBHEADER_END:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiEnd", Py_BuildValue("()"));
-			break;
-
-		case RUMI_GC_SUBHEADER_START:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiStart", Py_BuildValue("()"));
-			break;
-
-		case RUMI_GC_SUBHEADER_SET_DECK:
-		{
-			TPacketGCMiniGameRumiSetDeck* pkData = (TPacketGCMiniGameRumiSetDeck*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiSetDeckCount", Py_BuildValue("(i)", pkData->bDeckCount));
-		}
-		break;
-
-		case RUMI_GC_SUBHEADER_SET_SCORE:
-		{
-			TPacketGCMiniGameRumiSetScore* pkData = (TPacketGCMiniGameRumiSetScore*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiIncreaseScore", Py_BuildValue("(ii)",
-				pkData->wScore, pkData->wTotalScore));
-		}
-		break;
-
-		case RUMI_GC_SUBHEADER_MOVE_CARD:
-		{
-			TPacketGCMiniGameRumiMoveCard* pkData = (TPacketGCMiniGameRumiMoveCard*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiMoveCard", Py_BuildValue("(iiiiiiii)",
-				pkData->bSrcPos, pkData->bSrcIndex, pkData->bSrcColor, pkData->bSrcNumber,
-				pkData->bDstPos, pkData->bDstIndex, pkData->bDstColor, pkData->bDstNumber));
-		}
-		break;
-
-#if defined(ENABLE_OKEY_EVENT_FLAG_RENEWAL)
-		case RUMI_GC_SUBHEADER_SET_CARD_PIECE_FLAG:
-		case RUMI_GC_SUBHEADER_SET_CARD_FLAG:
-		case RUMI_GC_SUBHEADER_SET_QUEST_FLAG:
-		case RUMI_GC_SUBHEADER_NO_MORE_GAIN:
-		{
-			TPacketGCMiniGameRumiQuestFlag* pkData = (TPacketGCMiniGameRumiQuestFlag*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiFlagProcess", Py_BuildValue("(i(ii))",
-				Packet.bSubHeader, pkData->wCardPieceCount, pkData->wCardCount));
-		}
-		break;
-#endif
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendMiniGameRumiExit()
-{
-	TPacketCGMiniGameRumi Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
-	Packet.bSubHeader = RUMI_CG_SUBHEADER_END;
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameRumiExit Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMiniGameRumiStart()
-{
-	TPacketCGMiniGameRumi Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
-	Packet.bSubHeader = RUMI_CG_SUBHEADER_START;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameRumiStart Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMiniGameRumiDeckCardClick()
-{
-	TPacketCGMiniGameRumi Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
-	Packet.bSubHeader = RUMI_CG_SUBHEADER_DECK_CARD_CLICK;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameRumiDeckCardClick Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMiniGameRumiHandCardClick(bool bUse, BYTE bIndex)
-{
-	TPacketCGMiniGameRumi Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
-	Packet.bSubHeader = RUMI_CG_SUBHEADER_HAND_CARD_CLICK;
-	Packet.bUseCard = bUse;
-	Packet.bIndex = bIndex;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameRumiHandCardClick Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMiniGameRumiFieldCardClick(const BYTE c_bIndex)
-{
-	TPacketCGMiniGameRumi Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
-	Packet.bSubHeader = RUMI_CG_SUBHEADER_FIELD_CARD_CLICK;
-	Packet.bIndex = c_bIndex;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameRumiFieldCardClick Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-#if defined(ENABLE_OKEY_EVENT_FLAG_RENEWAL)
-bool CPythonNetworkStream::SendMiniGameRumiRequestQuestFlag()
-{
-	TPacketCGMiniGameRumi Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
-	Packet.bSubHeader = RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameRumiRequestQuestFlag Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-#endif
-#endif
-
-#if defined(ENABLE_GEM_SYSTEM)
-bool CPythonNetworkStream::RecvGemShop()
-{
-	TPacketGCGemShop Packet;
-	if (!Recv(sizeof(Packet), &Packet))
-		return false;
-
-	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
-	rkPlayer.ClearGemShop();
-
-	unsigned int uiPacketSize = (Packet.wSize - sizeof(TPacketGCGemShop));
-	for (; uiPacketSize > 0; uiPacketSize -= sizeof(TGemShopTable))
-	{
-		TGemShopTable GemShopTable;
-		if (!Recv(sizeof(GemShopTable), &GemShopTable))
-			return false;
-
-		rkPlayer.GemShop(GemShopTable);
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvGemShopProcess()
-{
-	TPacketGCGemShopProcess Packet;
-	if (!Recv(sizeof(Packet), &Packet))
-		return false;
-
-	switch (Packet.bSubHeader)
-	{
-		case SUBHEADER_GEM_SHOP_CLOSE:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseGemShop", Py_BuildValue("()"));
-			break;
-		case SUBHEADER_GEM_SHOP_OPEN:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenGemShop", Py_BuildValue("()"));
-			break;
-		case SUBHEADER_GEM_SHOP_BUY:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "GemShopSlotBuy", Py_BuildValue("(ib)", Packet.bSlotIndex, Packet.bEnable));
-			break;
-		case SUBHEADER_GEM_SHOP_SLOT_ADD:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "GemShopSlotAdd", Py_BuildValue("(ib)", Packet.bSlotIndex, Packet.bEnable));
-			break;
-		case SUBHEADER_GEM_SHOP_REFRESH:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGemShopWindow", Py_BuildValue("()"));
-			break;
-		default:
-			TraceError("CPythonNetworkStream::RecvGemShopProcess: Unknown SubHeader: %d\n", Packet.bSubHeader);
-			break;
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendGemShopCommand(const BYTE c_bSubHeader, const BYTE c_bSlotIndex)
-{
-	if (c_bSubHeader > SUBHEADER_GEM_SHOP_MAX)
-		return false;
-
-	if (c_bSlotIndex > GEM_SHOP_SLOT_COUNT)
-		return false;
-
-	TPacketCGGemShop Packet(c_bSubHeader, c_bSlotIndex);
-	if (!Send(sizeof(Packet), &Packet))
-		return false;
-
-	return SendSequence();
-}
-#endif
-
-#if defined(ENABLE_CONQUEROR_LEVEL)
-void CPythonNetworkStream::__SungMaAttrInfoProcess() const
-{
-	CPythonBackground& rkBg = CPythonBackground::Instance();
-	if (!rkBg.HasSungMaAttr())
-		return;
-
-	const CMapBase::SSungmaAttr& data = rkBg.GetSungMaAttrData();
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SungMaAttr", Py_BuildValue("(iiii)", data.str, data.hp, data.move, data.immune));
-}
-#endif
-
-#if defined(ENABLE_EXTEND_INVEN_SYSTEM)
-bool CPythonNetworkStream::SendExtendInven(bool bUpgrade, BYTE bIndex)
-{
-	TPacketCGExtendInven Packet;
-	Packet.bHeader = HEADER_CG_EXTEND_INVEN;
-	Packet.bUpgrade = bUpgrade;
-	Packet.bIndex = bIndex;
-	if (!Send(sizeof(TPacketCGExtendInven), &Packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvExtendInven()
-{
-	TPacketGCExtendInven Packet;
-	if (!Recv(sizeof(Packet), &Packet))
-		return false;
-
-	CPythonPlayer::Instance().SetExtendInvenStage(Packet.bStage);
-	CPythonPlayer::Instance().SetExtendInvenMax(Packet.wMaxNum);
-
-	__RefreshInventoryWindow();
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvExtendInvenItemUse()
-{
-	TPacketGCExtendInvenItemUse Packet;
-	if (!Recv(sizeof(Packet), &Packet))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ExInvenItemUseMsg",
-		Py_BuildValue("(iii)", 0 /* unused item vnum */, Packet.bMsgResult, Packet.bEnoughCount));
-
-	__RefreshStatus();
-	__RefreshInventoryWindow();
-
-	return true;
-}
-#endif
-
-#if defined(ENABLE_CLIENT_TIMER)
-bool CPythonNetworkStream::RecvClientTimer()
-{
-	TPacketGCClientTimer Packet;
-	if (!Recv(sizeof(TPacketGCClientTimer), &Packet))
-		return false;
-
-	switch (Packet.bSubHeader)
-	{
-		case CLIENT_TIMER_SUBHEADER_GC_SET:
-		{
-			PyObject* poDict = PyDict_New();
-			if (poDict == nullptr)
-				return false;
-
-			for (BYTE bDataIndex = 0; bDataIndex < ECLIENT_TIMER_MAX; ++bDataIndex)
-				PyDict_SetItem(poDict, Py_BuildValue("i", bDataIndex), Py_BuildValue("i", Packet.dwData[bDataIndex]));
-
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ClientTimerProcess",
-				Py_BuildValue("iO", CLIENT_TIMER_SUBHEADER_GC_SET, poDict));
-
-			Py_DECREF(poDict);
-		}
-		break;
-
-		case CLIENT_TIMER_SUBHEADER_GC_DELETE:
-		default:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ClientTimerProcess",
-				Py_BuildValue("ii", CLIENT_TIMER_SUBHEADER_GC_DELETE, 0));
-		}
-		break;
-	}
-
-	return true;
-}
-#endif
-
-bool CPythonNetworkStream::RecvEmote()
-{
-	TPacketGCEmote Packet;
-	if (!Recv(sizeof(TPacketGCEmote), &Packet))
-		return false;
-
-	switch (Packet.bSubHeader)
-	{
-		case SUBHEADER_EMOTE_ADD:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AddSpecialActionSlot",
-				Py_BuildValue("ii", Packet.dwEmoteVnum, Packet.dwDuration));
-		}
-		break;
-
-#if defined(ENABLE_EXPRESSING_EMOTION)
-		case SUBHEADER_EMOTE_CLEAR:
-		{
-			for (int iIndex = SPECIAL_ACTION_START_INDEX; iIndex < EMOTION_NUM; ++iIndex)
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RemoveSpecialActionSlot", Py_BuildValue("(i)", iIndex));
-		}
-		break;
-#endif
-
-		case SUBHEADER_EMOTE_MOTION:
-		{
-			IAbstractCharacterManager& rkChrMgr = IAbstractCharacterManager::GetSingleton();
-			CInstanceBase* pkInstMain = rkChrMgr.GetInstancePtr(Packet.dwMainVID);
-			CInstanceBase* pkInstTarget = rkChrMgr.GetInstancePtr(Packet.dwTargetVID);
-			if (pkInstMain == nullptr)
-				return false;
-
-			switch (Packet.dwEmoteVnum)
-			{
-				case EMOTION_CLAP:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_CLAP);
-					break;
-				case EMOTION_CONGRATULATION:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_CONGRATULATION);
-					break;
-				case EMOTION_FORGIVE:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_FORGIVE);
-					break;
-				case EMOTION_ANGRY:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_ANGRY);
-					break;
-				case EMOTION_ATTRACTIVE:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_ATTRACTIVE);
-					break;
-				case EMOTION_SAD:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_SAD);
-					break;
-				case EMOTION_SHY:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_SHY);
-					break;
-				case EMOTION_CHEERUP:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_CHEERUP);
-					break;
-				case EMOTION_BANTER:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_BANTER);
-					break;
-				case EMOTION_JOY:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_JOY);
-					break;
-				case EMOTION_CHEERS_1:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_CHEERS_1);
-					break;
-				case EMOTION_CHEERS_2:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_CHEERS_2);
-					break;
-				case EMOTION_DANCE_1:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_1);
-					break;
-				case EMOTION_DANCE_2:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_2);
-					break;
-				case EMOTION_DANCE_3:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_3);
-					break;
-				case EMOTION_DANCE_4:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_4);
-					break;
-				case EMOTION_DANCE_5:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_5);
-					break;
-				case EMOTION_DANCE_6:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_6);
-					break;
-
-				case EMOTION_KISS:
-					if (pkInstTarget)
-						pkInstMain->ActDualEmotion(*pkInstTarget, CRaceMotionData::NAME_KISS_START, CRaceMotionData::NAME_KISS_START);
-					break;
-				case EMOTION_FRENCH_KISS:
-					if (pkInstTarget)
-						pkInstMain->ActDualEmotion(*pkInstTarget, CRaceMotionData::NAME_FRENCH_KISS_START, CRaceMotionData::NAME_FRENCH_KISS_START);
-					break;
-				case EMOTION_SLAP:
-					if (pkInstTarget)
-						pkInstMain->ActDualEmotion(*pkInstTarget, CRaceMotionData::NAME_SLAP_HURT_START, CRaceMotionData::NAME_SLAP_HIT_START);
-					break;
-
-#if defined(ENABLE_EXPRESSING_EMOTION)
-				case EMOTION_PUSH_UP:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_PUSH_UP);
-					break;
-				case EMOTION_DANCE_7:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_7);
-					break;
-				case EMOTION_EXERCISE:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_EXERCISE);
-					break;
-				case EMOTION_DOZE:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_DOZE);
-					break;
-				case EMOTION_SELFIE:
-					pkInstMain->ActEmotion(CRaceMotionData::NAME_SELFIE);
-					break;
-
-				case EMOTION_CHARGING:
-				case EMOTION_NOSAY:
-				case EMOTION_WEATHER_1:
-				case EMOTION_WEATHER_2:
-				case EMOTION_WEATHER_3:
-				case EMOTION_HUNGRY:
-				case EMOTION_SIREN:
-				case EMOTION_LETTER:
-				case EMOTION_CALL:
-				case EMOTION_CELEBRATION:
-				case EMOTION_ALCOHOL:
-				case EMOTION_BUSY:
-				case EMOTION_WHIRL:
-				{
-					DWORD dwEmoticon;
-					if (ParseEmoticon(Packet.dwEmoteVnum, &dwEmoticon))
-						pkInstMain->SetEmoticon(dwEmoticon);
-				}
-				break;
-#endif
-			}
-		}
-		break;
-
-		case SUBHEADER_EMOTE_ICON:
-		{
-			IAbstractCharacterManager& rkChrMgr = IAbstractCharacterManager::GetSingleton();
-			CInstanceBase* pkInstMain = rkChrMgr.GetInstancePtr(Packet.dwMainVID);
-			CInstanceBase* pkInstTarget = rkChrMgr.GetInstancePtr(Packet.dwTargetVID);
-			if (pkInstMain == nullptr)
-				return false;
-
-			DWORD dwEmoticon;
-			if (ParseEmoticon(Packet.dwEmoteVnum, &dwEmoticon))
-				pkInstMain->SetEmoticon(dwEmoticon);
-		}
-		break;
-	}
-
-	return true;
-}
-
-#if defined(ENABLE_CUBE_RENEWAL)
-bool CPythonNetworkStream::SendCubeClosePacket()
-{
-	TPacketCGCube Packet;
-	Packet.bHeader = HEADER_CG_CUBE;
-	Packet.bSubHeader = SUBHEADER_CG_CUBE_CLOSE;
-	Packet.dwFileCrc = CPythonCubeManager::Instance().GetFileCrc();
-	if (!Send(sizeof(TPacketCGCube), &Packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendCubeMakePacket(const UINT iCubeIndex, const UINT iQuantity, const INT iImproveItemPos)
-{
-	TPacketCGCube Packet;
-	Packet.bHeader = HEADER_CG_CUBE;
-	Packet.bSubHeader = SUBHEADER_CG_CUBE_MAKE;
-	Packet.iCubeIndex = iCubeIndex;
-	Packet.iQuantity = iQuantity;
-	Packet.iImproveItemPos = iImproveItemPos;
-	Packet.dwFileCrc = CPythonCubeManager::Instance().GetFileCrc();
-	if (!Send(sizeof(TPacketCGCube), &Packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvCubePacket()
-{
-	TPacketGCCube Packet;
-	if (!Recv(sizeof(TPacketGCCube), &Packet))
-		return false;
-
-	if (Packet.bSubHeader != SUBHEADER_GC_CUBE_CLOSE && Packet.dwFileCrc != CPythonCubeManager::Instance().GetFileCrc())
-	{
-		Tracef("CPythonNetworkStream::RecvCubePacket() - File Mismatch");
-		return false;
-	}
-
-	switch (Packet.bSubHeader)
-	{
-		case SUBHEADER_GC_CUBE_OPEN:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_Open", Py_BuildValue("(i)", Packet.dwNPCVnum));
-			break;
-		case SUBHEADER_GC_CUBE_CLOSE:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_Close", Py_BuildValue("()"));
-			break;
-		case SUBHEADER_GC_CUBE_RESULT:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_Result", Py_BuildValue("(b)", Packet.bSuccess));
-			break;
-	}
-
-	return true;
-}
-#endif
-
-#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
-bool CPythonNetworkStream::SendSnowflakeStickEventPacket(BYTE bSubHeader)
-{
-	TPacketCGSnowflakeStickEvent Packet(bSubHeader);
-	if (!Send(sizeof(TPacketCGSnowflakeStickEvent), &Packet))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvSnowflakeStickEventPacket()
-{
-	TPacketGCSnowflakeStickEvent Packet;
-	if (!Recv(sizeof(TPacketGCSnowflakeStickEvent), &Packet))
-		return false;
-
-	switch (Packet.bSubHeader)
-	{
-		case SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SnowflakeStickEventProcess",
-				Py_BuildValue("(i(iiiiii))", Packet.bSubHeader,
-					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_SNOW_BALL],
-					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_TREE_BRANCH],
-					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK],
-					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK_COOLDOWN],
-					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_PET],
-					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_MOUNT]));
-		}
-		break;
-
-		case SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ENABLE:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SnowflakeStickEventProcess",
-				Py_BuildValue("(ii)", Packet.bSubHeader, Packet.dwValue[0]));
-		}
-		break;
-
-		case SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_USE_STICK_FAILED:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SnowflakeStickEventProcess",
-				Py_BuildValue("(ii)", Packet.bSubHeader, Packet.dwValue[0]));
-		}
-		break;
-
-		default:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SnowflakeStickEventProcess",
-				Py_BuildValue("(i())", Packet.bSubHeader));
-		}
-		break;
-	}
-
-	return true;
-}
-#endif
-
-#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
-bool CPythonNetworkStream::SendRefineElementPacket(BYTE bSubHeader, WORD wElementType)
-{
-	TPacketCGRefineElement kPacket(bSubHeader, wElementType);
-	if (!Send(sizeof(TPacketCGRefineElement), &kPacket))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvRefineElementPacket()
-{
-	TPacketGCRefineElement kPacket;
-	if (!Recv(sizeof(TPacketGCRefineElement), &kPacket))
-		return false;
-
-	switch (kPacket.bSubHeader)
-	{
-		case REFINE_ELEMENT_GC_OPEN:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefineElementProcess",
-				Py_BuildValue("(ii(ii))", kPacket.bSubHeader, kPacket.bRefineType,
-					kPacket.SrcPos.cell, kPacket.DestPos.cell
-				));
-		}
-		break;
-		case REFINE_ELEMENT_GC_RESULT:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefineElementProcess",
-				Py_BuildValue("(iib)", kPacket.bSubHeader, kPacket.bRefineType, kPacket.bResult));
-		}
-		break;
-	}
-
-	return true;
-}
-#endif
-
-#if defined(ENABLE_MINI_GAME_YUTNORI)
-bool CPythonNetworkStream::RecvMiniGameYutnori()
-{
-	std::vector<char> vPacketBuffer;
-	vPacketBuffer.clear();
-
-	TPacketGCMiniGameYutnori Packet;
-	if (!Recv(sizeof(Packet), &Packet))
-		return false;
-
-	unsigned int uiPacketSize = Packet.wSize - sizeof(Packet);
-	if (uiPacketSize > 0)
-	{
-		vPacketBuffer.resize(uiPacketSize);
-		if (!Recv(uiPacketSize, &vPacketBuffer[0]))
-			return false;
-	}
-
-	switch (Packet.bSubHeader)
-	{
-		case YUTNORI_GC_SUBHEADER_START:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(ii)",
-				Packet.bSubHeader, 0));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_STOP:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(ii)",
-				Packet.bSubHeader, 0));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_SET_PROB:
-		{
-			TPacketGCMiniGameYutnoriSetProb* pPacket = (TPacketGCMiniGameYutnoriSetProb*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(ii)",
-				Packet.bSubHeader, pPacket->bProbIndex));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_THROW:
-		{
-			TPacketGCMiniGameYutnoriThrowYut* pPacket = (TPacketGCMiniGameYutnoriThrowYut*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(i(ii))",
-				Packet.bSubHeader, pPacket->bPC, pPacket->bYut));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_MOVE:
-		{
-			TPacketGCMiniGameYutnoriMoveYut* pPacket = (TPacketGCMiniGameYutnoriMoveYut*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(i(iiiii))",
-				Packet.bSubHeader, pPacket->bPC, pPacket->bUnitIndex, pPacket->bIsCatch, pPacket->bStartIndex, pPacket->bDestIndex));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_AVAILABLE_AREA:
-		{
-			TPacketGCMiniGameYutnoriAvailableArea* pPacket = (TPacketGCMiniGameYutnoriAvailableArea*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(i(ii))",
-				Packet.bSubHeader, pPacket->bPlayerIndex, pPacket->bAvailableIndex));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT:
-		{
-			TPacketGCMiniGameYutnoriPushCatchYut* pPacket = (TPacketGCMiniGameYutnoriPushCatchYut*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(i(ii))",
-				Packet.bSubHeader, pPacket->bPC, pPacket->bUnitIndex));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_SET_SCORE:
-		{
-			TPacketGCMiniGameYutnoriSetScore* pPacket = (TPacketGCMiniGameYutnoriSetScore*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(ii)",
-				Packet.bSubHeader, pPacket->wScore));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT:
-		{
-			TPacketGCMiniGameYutnoriSetRemainCount* pPacket = (TPacketGCMiniGameYutnoriSetRemainCount*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(ii)",
-				Packet.bSubHeader, pPacket->bRemainCount));
-		}
-		break;
-
-		case YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN:
-		{
-			TPacketGCMiniGameYutnoriPushNextTurn* pPacket = (TPacketGCMiniGameYutnoriPushNextTurn*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(i(ii))",
-				Packet.bSubHeader, pPacket->bPC, pPacket->bState));
-		}
-		break;
-
-#if defined(ENABLE_YUTNORI_EVENT_FLAG_RENEWAL)
-		case YUTNORI_GC_SUBHEADER_SET_YUT_PIECE_FLAG:
-		case YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG:
-		case YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG:
-		case YUTNORI_GC_SUBHEADER_NO_MORE_GAIN:
-		{
-			TPacketGCMiniGameYutnoriQuestFlag* pPacket = (TPacketGCMiniGameYutnoriQuestFlag*)&vPacketBuffer[0];
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriFlagProcess", Py_BuildValue("(i(ii))",
-				Packet.bSubHeader, pPacket->wYutPieceCount, pPacket->wYutBoardCount));
-		}
-		break;
-#endif
-	}
-
-	return true;
-}
-
-bool CPythonNetworkStream::SendMiniGameYutnoriStart()
-{
-	TPacketCGMiniGameYutnori Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
-	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_START;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameYutnoriStart Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMiniGameYutnoriGiveup()
-{
-	TPacketCGMiniGameYutnori Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
-	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_GIVEUP;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameYutnoriGiveup Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMiniGameYutnoriProb(BYTE bProbIndex)
-{
-	TPacketCGMiniGameYutnori Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
-	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_SET_PROB;
-	Packet.bArgument = bProbIndex;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameYutnoriProb Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMiniGameYutnoriCharClick(BYTE bPlayerIndex)
-{
-	TPacketCGMiniGameYutnori Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
-	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_CLICK_CHAR;
-	Packet.bArgument = bPlayerIndex;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameYutnoriCharClick Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMiniGameYutnoriThrow(BYTE bPC)
-{
-	TPacketCGMiniGameYutnori Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
-	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_THROW;
-	Packet.bArgument = bPC;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameYutnoriThrow Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMiniGameYutnoriMove(BYTE bPlayerIndex)
-{
-	TPacketCGMiniGameYutnori Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
-	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_MOVE;
-	Packet.bArgument = bPlayerIndex;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameYutnoriMove Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMiniGameYutnoriReward()
-{
-	TPacketCGMiniGameYutnori Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
-	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_REWARD;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameYutnoriReward Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendMiniGameYutnoriRequestComAction()
-{
-	TPacketCGMiniGameYutnori Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
-	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_REQUEST_COM_ACTION;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameYutnoriRequestComAction Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-#if defined(ENABLE_YUTNORI_EVENT_FLAG_RENEWAL)
-bool CPythonNetworkStream::SendMiniGameYutnoriRequestQuestFlag()
-{
-	TPacketCGMiniGameYutnori Packet;
-	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
-	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendMiniGameYutnoriRequestQuestFlag Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-#endif
-#endif
-
-#if defined(ENABLE_QUEST_REQUEST_EVENT)
-bool CPythonNetworkStream::SendRequestEventQuest(const char* pszEventQuest)
-{
-	TPacketCGRequestEventQuest Packet;
-	Packet.bHeader = HEADER_CG_REQUEST_EVENT_QUEST;
-	std::strcpy(Packet.szEventQuest, pszEventQuest);
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendRequestEventQuest Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-#endif
-
-#if defined(ENABLE_LEFT_SEAT)
-bool CPythonNetworkStream::SendLeftSeatWaitTimeIndexPacket(BYTE bIndex)
-{
-	TPacketCGLeftSeat Packet;
-	Packet.bHeader = HEADER_CG_LEFT_SEAT;
-	Packet.bSubHeader = LEFT_SEAT_SET_WAIT_TIME_INDEX;
-	Packet.bIndex = bIndex;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendLeftSeatWaitTimeIndexPacket Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendLeftSeatOffPacket(BYTE bIndex)
-{
-	TPacketCGLeftSeat Packet;
-	Packet.bHeader = HEADER_CG_LEFT_SEAT;
-	Packet.bSubHeader = LEFT_SEAT_SET_LOGOUT_TIME_INDEX;
-	Packet.bIndex = bIndex;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("SendLeftSeatOffPacket Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::DisableLeftSeatLogOutState()
-{
-	TPacketCGLeftSeat Packet;
-	Packet.bHeader = HEADER_CG_LEFT_SEAT;
-	Packet.bSubHeader = LEFT_SEAT_DISABLE_LOGOUT_STATE;
-	Packet.bIndex = 0;
-
-	if (!Send(sizeof(Packet), &Packet))
-	{
-		Tracef("DisableLeftSeatLogOutState Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-#endif
-
-#if defined(ENABLE_GUILD_DRAGONLAIR_SYSTEM)
-bool CPythonNetworkStream::RecvGuildDragonLairPacket()
-{
-	TPacketGCGuildDragonLair GuildDragonLairPacket;
-	if (!Recv(sizeof(TPacketGCGuildDragonLair), &GuildDragonLairPacket))
-		return false;
-
-	switch (GuildDragonLairPacket.bSubHeader)
-	{
-		case GUILD_DRAGONLAIR_GC_SUBHEADER_RANKING:
-		{
-			CPythonGuild::Instance().ClearDragonLairRanking(GuildDragonLairPacket.bType);
-
-			unsigned int iPacketSize = (GuildDragonLairPacket.wSize - sizeof(TPacketGCGuildDragonLair));
-			for (; iPacketSize > 0; iPacketSize -= sizeof(TPacketGCGuildDragonLairRanking))
-			{
-				TPacketGCGuildDragonLairRanking GuildDragonLairRankingPacket;
-				if (!Recv(sizeof(TPacketGCGuildDragonLairRanking), &GuildDragonLairRankingPacket))
-					return false;
-
-				CPythonGuild::Instance().RegisterDragonLairRanking(
-					GuildDragonLairRankingPacket.bType,
-					GuildDragonLairRankingPacket.dwGuildID,
-					GuildDragonLairRankingPacket.szGuildName,
-					GuildDragonLairRankingPacket.bMemberCount,
-					GuildDragonLairRankingPacket.dwTime
-				);
-			}
-
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenGuildDragonLairRanking", Py_BuildValue("(i)", GuildDragonLairPacket.bType));
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildDragonLairRanking", Py_BuildValue("(i)", GuildDragonLairPacket.bType));
-		}
-		break;
-
-#if defined(ENABLE_GUILD_DRAGONLAIR_PARTY_SYSTEM)
-		case GUILD_DRAGONLAIR_GC_SUBHEADER_1ST_GUILD_TEXT:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetGuildDragonLairFistGuildText", Py_BuildValue("(i)", GuildDragonLairPacket.dwSeconds));
-			break;
-
-		case GUILD_DRAGONLAIR_GC_SUBHEADER_START:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetGuildDragonLairStart", Py_BuildValue("()"));
-			break;
-
-		case GUILD_DRAGONLAIR_GC_SUBHEADER_SUCCESS:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetGuildDragonLairSuccess", Py_BuildValue("()"));
-			break;
-#endif
-	}
-
-	return true;
-}
-#endif
-
-#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
-bool CPythonNetworkStream::SendMiniGameRoulettePacket(BYTE bSubHeader)
-{
-	TPacketCGMiniGameRoulette MiniGameRoulettePacket;
-	MiniGameRoulettePacket.bHeader = HEADER_CG_MINI_GAME_ROULETTE;
-	MiniGameRoulettePacket.bSubHeader = bSubHeader;
-
-	if (!Send(sizeof(MiniGameRoulettePacket), &MiniGameRoulettePacket))
-	{
-		Tracef("SendMiniGameRoulettePacket Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvMiniGameRoulettePacket()
-{
-	TPacketGCMiniGameRoulette MiniGameRoulettePacket;
-	if (!Recv(sizeof(TPacketGCMiniGameRoulette), &MiniGameRoulettePacket))
-		return false;
-
-	switch (MiniGameRoulettePacket.bSubHeader)
-	{
-		case ROULETTE_GC_OPEN:
-		{
-			PyObject* poTuple = PyTuple_New(ROULETTE_ITEM_MAX);
-			if (poTuple == NULL)
-				return false;
-
-			for (BYTE bSlotIdx = 0; bSlotIdx < ROULETTE_ITEM_MAX; bSlotIdx++)
-			{
-				PyObject* poItemTuple = PyTuple_New(2);
-				if (poItemTuple == NULL)
-					break;
-
-				PyTuple_SetItem(poItemTuple, 0, PyInt_FromLong(MiniGameRoulettePacket.ItemData[bSlotIdx].dwVnum));
-				PyTuple_SetItem(poItemTuple, 1, PyInt_FromLong(MiniGameRoulettePacket.ItemData[bSlotIdx].bCount));
-				PyTuple_SetItem(poTuple, bSlotIdx, poItemTuple);
-			}
-
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RouletteProcess",
-				Py_BuildValue("(i(iO))", ROULETTE_GC_OPEN, MiniGameRoulettePacket.dwExpireTime, poTuple));
-		}
-		break;
-
-		case ROULETTE_GC_START:
-		case ROULETTE_GC_END:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RouletteProcess",
-				Py_BuildValue("(ii)", MiniGameRoulettePacket.bSubHeader, MiniGameRoulettePacket.bResult));
-			break;
-
-		case ROULETTE_GC_CLOSE:
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RouletteProcess",
-				Py_BuildValue("(i)", ROULETTE_GC_CLOSE));
-			break;
-	}
-
-	return true;
-}
-#endif
-
-#if defined(ENABLE_FLOWER_EVENT)
-bool CPythonNetworkStream::SendFlowerEventPacket(BYTE bSubHeader, BYTE bShootType, BYTE bExchangeKey)
-{
-	if (CPythonPlayer::Instance().GetFlowerEventEnable() == 0)
-		return false;
-
-	TPacketCGFlowerEvent FlowerEventPacket;
-	FlowerEventPacket.bHeader = HEADER_CG_FLOWER_EVENT;
-	FlowerEventPacket.bSubHeader = bSubHeader;
-	FlowerEventPacket.bShootType = bShootType;
-	FlowerEventPacket.bExchangeKey = bExchangeKey;
-
-	if (!Send(sizeof(FlowerEventPacket), &FlowerEventPacket))
-		return false;
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvFlowerEventPacket()
-{
-	TPacketGCFlowerEvent FlowerEventPacket;
-	if (!Recv(sizeof(TPacketGCFlowerEvent), &FlowerEventPacket))
-		return false;
-
-	switch (FlowerEventPacket.bSubHeader)
-	{
-		case FLOWER_EVENT_SUBHEADER_GC_INFO_ALL:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "FlowerEventProcess",
-				Py_BuildValue("(i(iiiiii))", FLOWER_EVENT_SUBHEADER_GC_INFO_ALL
-					, FlowerEventPacket.aiShootCount[SHOOT_ENVELOPE]
-					, FlowerEventPacket.aiShootCount[SHOOT_CHRYSANTHEMUM]
-					, FlowerEventPacket.aiShootCount[SHOOT_MAY_BELL]
-					, FlowerEventPacket.aiShootCount[SHOOT_DAFFODIL]
-					, FlowerEventPacket.aiShootCount[SHOOT_LILY]
-					, FlowerEventPacket.aiShootCount[SHOOT_SUNFLOWER]
-				));
-		}
-		break;
-
-		case FLOWER_EVENT_SUBHEADER_GC_GET_INFO:
-		{
-			if (FlowerEventPacket.bShootType == SHOOT_TYPE_MAX)
-			{
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "FlowerEventProcess",
-					Py_BuildValue("ii", FLOWER_EVENT_SUBHEADER_GC_GET_INFO, FlowerEventPacket.bChatType));
-			}
-			else
-			{
-				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "FlowerEventProcess",
-					Py_BuildValue("i(ii)", FLOWER_EVENT_SUBHEADER_GC_GET_INFO,
-						FlowerEventPacket.bShootType, FlowerEventPacket.aiShootCount[FlowerEventPacket.bShootType]));
-			}
-		}
-		break;
-
-		case FLOWER_EVENT_SUBHEADER_GC_UPDATE_INFO:
-		{
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "FlowerEventProcess",
-				Py_BuildValue("i(ii)", FLOWER_EVENT_SUBHEADER_GC_UPDATE_INFO,
-					FlowerEventPacket.bShootType, FlowerEventPacket.aiShootCount[FlowerEventPacket.bShootType]));
-		}
-		break;
-	}
-
-	return true;
-}
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-bool CPythonNetworkStream::SendExtBattlePassAction(BYTE bAction)
-{
-	if (!__CanActMainInstance())
-		return true;
-
-	TPacketCGExtBattlePassAction packet;
-	packet.bHeader = HEADER_CG_EXT_BATTLE_PASS_ACTION;
-	packet.bAction = bAction;
-
-	if (!Send(sizeof(TPacketCGExtBattlePassAction), &packet))
-	{
-		Tracef("SendExtBattlePassAction Send Packet Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::SendExtBattlePassPremiumItem(int slotindex)
-{
-	if (!__CanActMainInstance())
-		return true;
-
-	TPacketCGExtBattlePassSendPremiumItem packet;
-	packet.bHeader = HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM;
-	packet.iSlotIndex = slotindex;
-
-	if (!Send(sizeof(TPacketCGExtBattlePassSendPremiumItem), &packet))
-	{
-		Tracef("SendExtBattlePassPremiumItem Send Packet Error\n");
-		return false;
-	}
-
-	return SendSequence();
-}
-
-bool CPythonNetworkStream::RecvExtBattlePassOpenPacket()
-{
-	SPacketGCExtBattlePassOpen packet;
-	if (!Recv(sizeof(packet), &packet))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtOpenBattlePass", Py_BuildValue("()"));
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvExtBattlePassGeneralInfoPacket()
-{
-	TPacketGCExtBattlePassGeneralInfo packet;
-	if (!Recv(sizeof(packet), &packet))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassAddGeneralInfo", Py_BuildValue("(isiii)", packet.bBattlePassType, packet.szSeasonName, packet.dwBattlePassID, packet.dwBattlePassStartTime, packet.dwBattlePassEndTime));
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvExtBattlePassMissionInfoPacket()
-{
-	TPacketGCExtBattlePassMissionInfo packet;
-	if (!Recv(sizeof(packet), &packet))
-		return false;
-
-	packet.wSize -= sizeof(packet);
-
-	while (packet.wSize > 0)
-	{
-		TExtBattlePassMissionInfo missionInfo;
-		if (!Recv(sizeof(missionInfo), &missionInfo))
-			return false;
-
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassAddMission", Py_BuildValue("(iiiiiii)",
-			packet.bBattlePassType, packet.dwBattlePassID, missionInfo.bMissionIndex, missionInfo.bMissionType, missionInfo.dwMissionInfo[0], missionInfo.dwMissionInfo[1], missionInfo.dwMissionInfo[2]));
-
-		for (int i = 0; i < 3; ++i)
-			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassAddMissionReward", Py_BuildValue("(iiiiii)",
-				packet.bBattlePassType, packet.dwBattlePassID, missionInfo.bMissionIndex, missionInfo.bMissionType, missionInfo.aRewardList[i].dwVnum, missionInfo.aRewardList[i].bCount));
-
-		packet.wSize -= sizeof(missionInfo);
-	}
-
-	while (packet.wRewardSize > 0)
-	{
-		TExtBattlePassRewardItem rewardInfo;
-		if (!Recv(sizeof(rewardInfo), &rewardInfo))
-			return false;
-
-		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassAddReward", Py_BuildValue("(iiii)", packet.bBattlePassType, packet.dwBattlePassID, rewardInfo.dwVnum, rewardInfo.bCount));
-
-		packet.wRewardSize -= sizeof(rewardInfo);
-	}
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtOpenBattlePass", Py_BuildValue("()"));
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvExtBattlePassMissionUpdatePacket()
-{
-	TPacketGCExtBattlePassMissionUpdate packet;
-	if (!Recv(sizeof(packet), &packet))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassUpdate", Py_BuildValue("(iiii)", packet.bBattlePassType, packet.bMissionIndex, packet.bMissionType, packet.dwNewProgress));
-
-	return true;
-}
-
-bool CPythonNetworkStream::RecvExtBattlePassRankingPacket()
-{
-	TPacketGCExtBattlePassRanking packet;
-	if (!Recv(sizeof(packet), &packet))
-		return false;
-
-	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassAddRanklistEntry", Py_BuildValue("(siiii)",
-		packet.szPlayerName, packet.bBattlePassType, packet.bBattlePassID, packet.dwStartTime, packet.dwEndTime
-	));
-
-	return true;
-}
-#endif
+#include "StdAfx.h"
+#include "PythonNetworkStream.h"
+#include "Packet.h"
+
+#include "PythonGuild.h"
+#include "PythonCharacterManager.h"
+#include "PythonPlayer.h"
+#include "PythonBackground.h"
+#include "PythonMiniMap.h"
+#include "PythonTextTail.h"
+#include "PythonItem.h"
+#include "PythonChat.h"
+#include "PythonShop.h"
+#include "PythonExchange.h"
+#include "PythonQuest.h"
+#include "PythonEventManager.h"
+#include "PythonMessenger.h"
+#include "PythonApplication.h"
+#if defined(ENABLE_MAILBOX)
+#	include "PythonMailBox.h"
+#endif
+
+#include "../EterPack/EterPackManager.h"
+#include "../GameLib/ItemManager.h"
+
+#include "AbstractApplication.h"
+#include "AbstractCharacterManager.h"
+#include "InstanceBase.h"
+#if defined(ENABLE_BADGE_NOTIFICATION_MANAGER)
+	#include "BadgeNotificationManager.h"
+#endif
+
+#include "ProcessCRC.h"
+#include "../GameLib/ItemData.h"
+
+#if defined(ENABLE_DISCORD_RPC)
+#include "discord_rpc.h"
+#endif
+
+#ifdef ENABLE_OFFLINE_SHOP
+#include "PythonOfflineShop.h"
+#endif
+
+BOOL gs_bEmpireLanuageEnable = TRUE;
+
+static int64_t StartTime;
+static constexpr auto DiscordClientID = "732229869118685217"; // Change
+
+#if defined(ENABLE_DISCORD_RPC)
+void CPythonNetworkStream::Discord_Start()
+{
+	StartTime = time(0);
+	DiscordEventHandlers handlers;
+	memset(&handlers, 0, sizeof(handlers));
+	Discord_Initialize(DiscordClientID, &handlers, 1, nullptr);
+	Discord_Update(false /* bGameState */);
+}
+
+void CPythonNetworkStream::Discord_Update(const bool bGameState)
+{
+	DiscordRichPresence discordPresence;
+	memset(&discordPresence, 0, sizeof(discordPresence));
+	if (bGameState)
+	{
+		discordPresence.details = CPythonPlayer::Instance().GetName();
+		discordPresence.state = CPythonBackground::Instance().GetWarpMapName();
+
+		discordPresence.startTimestamp = StartTime;
+
+		discordPresence.largeImageKey = "logo";
+		discordPresence.largeImageText = "Farques Development";
+
+		switch (CPythonPlayer::Instance().GetRace())
+		{
+			case MAIN_RACE_WARRIOR_M:
+				discordPresence.smallImageKey = "warrior_m";
+				discordPresence.smallImageText = "Savasci Erkek";
+				break;
+
+			case MAIN_RACE_WARRIOR_W:
+				discordPresence.smallImageKey = "warrior_w";
+				discordPresence.smallImageText = "Savasci Kadin";
+				break;
+
+			case MAIN_RACE_ASSASSIN_M:
+				discordPresence.smallImageKey = "assassin_m";
+				discordPresence.smallImageText = "Ninja Erkek";
+				break;
+
+			case MAIN_RACE_ASSASSIN_W:
+				discordPresence.smallImageKey = "assassin_w";
+				discordPresence.smallImageText = "Ninja Kadin";
+				break;
+
+			case MAIN_RACE_SURA_M:
+				discordPresence.smallImageKey = "sura_m";
+				discordPresence.smallImageText = "Sura Erkek";
+				break;
+
+			case MAIN_RACE_SURA_W:
+				discordPresence.smallImageKey = "sura_w";
+				discordPresence.smallImageText = "Sura Kadin";
+				break;
+
+			case MAIN_RACE_SHAMAN_M:
+				discordPresence.smallImageKey = "shaman_m";
+				discordPresence.smallImageText = "Saman Erkek";
+				break;
+
+			case MAIN_RACE_SHAMAN_W:
+				discordPresence.smallImageKey = "shaman_w";
+				discordPresence.smallImageText = "Saman Kadin";
+				break;
+
+			case MAIN_RACE_WOLFMAN_M:
+				discordPresence.smallImageKey = "wolfman_w";
+				discordPresence.smallImageText = "Wolfman";
+				break;
+
+		}
+	}
+	discordPresence.buttonLabel = "Farques Discord";
+	discordPresence.buttonURL = "https://discord.com/invite/v36Ru9zpJ3";
+	Discord_UpdatePresence(&discordPresence);
+}
+
+void CPythonNetworkStream::Discord_Close()
+{
+	Discord_Shutdown();
+}
+#endif
+
+void CPythonNetworkStream::__RefreshAlignmentWindow()
+{
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshAlignment", Py_BuildValue("()"));
+}
+
+void CPythonNetworkStream::__RefreshTargetBoardByVID(DWORD dwVID)
+{
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshTargetBoardByVID", Py_BuildValue("(i)", dwVID));
+}
+
+void CPythonNetworkStream::__RefreshTargetBoardByName(const char* c_szName)
+{
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshTargetBoardByName", Py_BuildValue("(s)", c_szName));
+}
+
+void CPythonNetworkStream::__RefreshTargetBoard()
+{
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshTargetBoard", Py_BuildValue("()"));
+}
+
+void CPythonNetworkStream::__RefreshGuildWindowGradePage()
+{
+	m_isRefreshGuildWndGradePage = true;
+}
+
+void CPythonNetworkStream::__RefreshGuildWindowSkillPage()
+{
+	m_isRefreshGuildWndSkillPage = true;
+}
+
+void CPythonNetworkStream::__RefreshGuildWindowMemberPageGradeComboBox()
+{
+	m_isRefreshGuildWndMemberPageGradeComboBox = true;
+}
+
+void CPythonNetworkStream::__RefreshGuildWindowMemberPage()
+{
+	m_isRefreshGuildWndMemberPage = true;
+}
+
+void CPythonNetworkStream::__RefreshGuildWindowBoardPage()
+{
+	m_isRefreshGuildWndBoardPage = true;
+}
+
+void CPythonNetworkStream::__RefreshGuildWindowInfoPage()
+{
+	m_isRefreshGuildWndInfoPage = true;
+}
+
+void CPythonNetworkStream::__RefreshMessengerWindow()
+{
+	m_isRefreshMessengerWnd = true;
+}
+
+void CPythonNetworkStream::__RefreshSafeboxWindow()
+{
+	m_isRefreshSafeboxWnd = true;
+}
+
+void CPythonNetworkStream::__RefreshMallWindow()
+{
+	m_isRefreshMallWnd = true;
+}
+
+void CPythonNetworkStream::__RefreshSkillWindow()
+{
+	m_isRefreshSkillWnd = true;
+}
+
+void CPythonNetworkStream::__RefreshExchangeWindow()
+{
+	m_isRefreshExchangeWnd = true;
+}
+
+void CPythonNetworkStream::__RefreshStatus()
+{
+	m_isRefreshStatus = true;
+}
+
+void CPythonNetworkStream::__RefreshCharacterWindow()
+{
+	m_isRefreshCharacterWnd = true;
+}
+
+void CPythonNetworkStream::__RefreshInventoryWindow()
+{
+	m_isRefreshInventoryWnd = true;
+}
+
+void CPythonNetworkStream::__RefreshEquipmentWindow()
+{
+	m_isRefreshEquipmentWnd = true;
+}
+
+void CPythonNetworkStream::__SetGuildID(DWORD id)
+{
+	if (m_dwGuildID != id)
+	{
+		m_dwGuildID = id;
+		IAbstractPlayer& rkPlayer = IAbstractPlayer::GetSingleton();
+
+		for (int i = 0; i < PLAYER_PER_ACCOUNT4; ++i)
+		{
+			if (!strncmp(m_akSimplePlayerInfo[i].szName, rkPlayer.GetName(), CHARACTER_NAME_MAX_LEN))
+			{
+				m_adwGuildID[i] = id;
+
+				std::string guildName;
+				if (CPythonGuild::Instance().GetGuildName(id, &guildName))
+				{
+					m_astrGuildName[i] = guildName;
+				}
+				else
+				{
+					m_astrGuildName[i] = "";
+				}
+			}
+		}
+	}
+}
+
+struct PERF_PacketInfo
+{
+	DWORD dwCount;
+	DWORD dwTime;
+
+	PERF_PacketInfo()
+	{
+		dwCount = 0;
+		dwTime = 0;
+	}
+};
+
+#ifdef __PERFORMANCE_CHECK__
+
+class PERF_PacketTimeAnalyzer
+{
+public:
+	~PERF_PacketTimeAnalyzer()
+	{
+		FILE* fp = fopen("perf_dispatch_packet_result.txt", "w");
+
+		for (std::map<DWORD, PERF_PacketInfo>::iterator i = m_kMap_kPacketInfo.begin(); i != m_kMap_kPacketInfo.end(); ++i)
+		{
+			if (i->second.dwTime > 0)
+				fprintf(fp, "header %d: count %d, time %d, tpc %d\n", i->first, i->second.dwCount, i->second.dwTime, i->second.dwTime / i->second.dwCount);
+		}
+		fclose(fp);
+	}
+
+public:
+	std::map<DWORD, PERF_PacketInfo> m_kMap_kPacketInfo;
+};
+
+PERF_PacketTimeAnalyzer gs_kPacketTimeAnalyzer;
+
+#endif
+
+// Game Phase ---------------------------------------------------------------------------
+void CPythonNetworkStream::GamePhase()
+{
+	if (!m_kQue_stHack.empty())
+	{
+		__SendHack(m_kQue_stHack.front().c_str());
+		m_kQue_stHack.pop_front();
+	}
+
+	TPacketHeader header = 0;
+	bool ret = true;
+
+#ifdef __PERFORMANCE_CHECK__
+	DWORD timeBeginDispatch = timeGetTime();
+
+	static std::map<DWORD, PERF_PacketInfo> kMap_kPacketInfo;
+	kMap_kPacketInfo.clear();
+#endif
+
+#ifdef __DOUBLE_RECV_BUFFER__
+	const DWORD MAX_RECV_COUNT = 4 * 2;
+	const DWORD SAFE_RECV_BUFSIZE = 8192 * 2;
+#else
+	const DWORD MAX_RECV_COUNT = 4;
+	const DWORD SAFE_RECV_BUFSIZE = 8192;
+#endif
+	DWORD dwRecvCount = 0;
+
+	while (ret)
+	{
+		if (dwRecvCount++ >= MAX_RECV_COUNT - 1 && GetRecvBufferSize() < SAFE_RECV_BUFSIZE
+			&& m_strPhase == "Game") // phase_game  Æ´Ï¾îµµ   ì°¡ Ö´.
+			break;
+
+		if (!CheckPacket(&header))
+			break;
+
+#ifdef __PERFORMANCE_CHECK__
+		DWORD timeBeginPacket = timeGetTime();
+#endif
+
+		switch (header)
+		{
+			case HEADER_GC_WARP:
+				ret = RecvWarpPacket();
+				break;
+
+			case HEADER_GC_PHASE:
+				ret = RecvPhasePacket();
+				return; // ß¿ Phase  Ù² Ï´  GamePhase Å» - [levites]
+
+			case HEADER_GC_PVP:
+				ret = RecvPVPPacket();
+				break;
+
+			case HEADER_GC_DUEL_START:
+				ret = RecvDuelStartPacket();
+				break;
+
+			case HEADER_GC_CHARACTER_ADD:
+				ret = RecvCharacterAppendPacket();
+				break;
+
+			case HEADER_GC_CHAR_ADDITIONAL_INFO:
+				ret = RecvCharacterAdditionalInfo();
+				break;
+
+			case HEADER_GC_CHARACTER_UPDATE:
+				ret = RecvCharacterUpdatePacket();
+				break;
+
+			case HEADER_GC_CHARACTER_DEL:
+				ret = RecvCharacterDeletePacket();
+				break;
+
+			case HEADER_GC_CHAT:
+				ret = RecvChatPacket();
+				break;
+
+			case HEADER_GC_SYNC_POSITION:
+				ret = RecvSyncPositionPacket();
+				break;
+
+			case HEADER_GC_OWNERSHIP:
+				ret = RecvOwnerShipPacket();
+				break;
+
+			case HEADER_GC_WHISPER:
+				ret = RecvWhisperPacket();
+				break;
+
+			case HEADER_GC_CHARACTER_MOVE:
+				ret = RecvCharacterMovePacket();
+				break;
+
+				// Position
+			case HEADER_GC_CHARACTER_POSITION:
+				ret = RecvCharacterPositionPacket();
+				break;
+
+				// Battle Packet
+			case HEADER_GC_STUN:
+				ret = RecvStunPacket();
+				break;
+
+			case HEADER_GC_DEAD:
+				ret = RecvDeadPacket();
+				break;
+
+			case HEADER_GC_PLAYER_POINT_CHANGE:
+				ret = RecvPointChange();
+				break;
+
+				// Item packet
+			case HEADER_GC_ITEM_SET_EMPTY:
+				ret = RecvItemSetEmptyPacket();
+				break;
+
+			case HEADER_GC_ITEM_SET:
+				ret = RecvItemSetPacket();
+				break;
+
+			case HEADER_GC_ITEM_USE:
+				ret = RecvItemUsePacket();
+				break;
+
+			case HEADER_GC_ITEM_UPDATE:
+				ret = RecvItemUpdatePacket();
+				break;
+
+			case HEADER_GC_ITEM_GROUND_ADD:
+				ret = RecvItemGroundAddPacket();
+				break;
+
+			case HEADER_GC_ITEM_GROUND_DEL:
+				ret = RecvItemGroundDelPacket();
+				break;
+
+			case HEADER_GC_ITEM_OWNERSHIP:
+				ret = RecvItemOwnership();
+				break;
+
+			case HEADER_GC_QUICKSLOT_ADD:
+				ret = RecvQuickSlotAddPacket();
+				break;
+
+			case HEADER_GC_QUICKSLOT_DEL:
+				ret = RecvQuickSlotDelPacket();
+				break;
+
+			case HEADER_GC_QUICKSLOT_SWAP:
+				ret = RecvQuickSlotMovePacket();
+				break;
+
+			case HEADER_GC_MOTION:
+				ret = RecvMotionPacket();
+				break;
+
+			case HEADER_GC_EMOTE:
+				ret = RecvEmote();
+				break;
+
+			case HEADER_GC_SHOP:
+				ret = RecvShopPacket();
+				break;
+
+			case HEADER_GC_SHOP_SIGN:
+				ret = RecvShopSignPacket();
+				break;
+
+			case HEADER_GC_EXCHANGE:
+				ret = RecvExchangePacket();
+				break;
+
+			case HEADER_GC_QUEST_INFO:
+				ret = RecvQuestInfoPacket();
+				break;
+
+			case HEADER_GC_REQUEST_MAKE_GUILD:
+				ret = RecvRequestMakeGuild();
+				break;
+
+			case HEADER_GC_PING:
+				ret = RecvPingPacket();
+				break;
+
+			case HEADER_GC_SCRIPT:
+				ret = RecvScriptPacket();
+				break;
+
+			case HEADER_GC_QUEST_CONFIRM:
+				ret = RecvQuestConfirmPacket();
+				break;
+
+			case HEADER_GC_TARGET:
+				ret = RecvTargetPacket();
+				break;
+
+			case HEADER_GC_DAMAGE_INFO:
+				ret = RecvDamageInfoPacket();
+				break;
+
+			case HEADER_GC_MOUNT:
+				ret = RecvMountPacket();
+				break;
+
+			case HEADER_GC_CHANGE_SPEED:
+				ret = RecvChangeSpeedPacket();
+				break;
+
+			case HEADER_GC_PLAYER_POINTS:
+				ret = __RecvPlayerPoints();
+				break;
+
+			case HEADER_GC_CREATE_FLY:
+				ret = RecvCreateFlyPacket();
+				break;
+
+			case HEADER_GC_FLY_TARGETING:
+				ret = RecvFlyTargetingPacket();
+				break;
+
+			case HEADER_GC_ADD_FLY_TARGETING:
+				ret = RecvAddFlyTargetingPacket();
+				break;
+
+			case HEADER_GC_SKILL_LEVEL:
+				ret = RecvSkillLevel();
+				break;
+
+			case HEADER_GC_SKILL_LEVEL_NEW:
+				ret = RecvSkillLevelNew();
+				break;
+
+			case HEADER_GC_MESSENGER:
+				ret = RecvMessenger();
+				break;
+
+			case HEADER_GC_GUILD:
+				ret = RecvGuild();
+				break;
+
+			case HEADER_GC_PARTY_INVITE:
+				ret = RecvPartyInvite();
+				break;
+
+			case HEADER_GC_PARTY_ADD:
+				ret = RecvPartyAdd();
+				break;
+
+			case HEADER_GC_PARTY_UPDATE:
+				ret = RecvPartyUpdate();
+				break;
+
+			case HEADER_GC_PARTY_REMOVE:
+				ret = RecvPartyRemove();
+				break;
+
+			case HEADER_GC_PARTY_LINK:
+				ret = RecvPartyLink();
+				break;
+
+			case HEADER_GC_PARTY_UNLINK:
+				ret = RecvPartyUnlink();
+				break;
+
+			case HEADER_GC_PARTY_PARAMETER:
+				ret = RecvPartyParameter();
+				break;
+
+			case HEADER_GC_SAFEBOX_SET:
+				ret = RecvSafeBoxSetPacket();
+				break;
+
+			case HEADER_GC_SAFEBOX_DEL:
+				ret = RecvSafeBoxDelPacket();
+				break;
+
+			case HEADER_GC_SAFEBOX_WRONG_PASSWORD:
+				ret = RecvSafeBoxWrongPasswordPacket();
+				break;
+
+			case HEADER_GC_SAFEBOX_SIZE:
+				ret = RecvSafeBoxSizePacket();
+				break;
+
+			case HEADER_GC_FISHING:
+				ret = RecvFishing();
+				break;
+
+			case HEADER_GC_DUNGEON:
+				ret = RecvDungeon();
+				break;
+
+			case HEADER_GC_TIME:
+				ret = RecvTimePacket();
+				break;
+
+			case HEADER_GC_WALK_MODE:
+				ret = RecvWalkModePacket();
+				break;
+
+			case HEADER_GC_CHANGE_SKILL_GROUP:
+				ret = RecvChangeSkillGroupPacket();
+				break;
+
+			case HEADER_GC_REFINE_INFORMATION:
+				ret = RecvRefineInformationPacket();
+				break;
+
+			case HEADER_GC_REFINE_INFORMATION_NEW:
+				ret = RecvRefineInformationPacketNew();
+				break;
+
+			case HEADER_GC_SEPCIAL_EFFECT:
+				ret = RecvSpecialEffect();
+				break;
+
+			case HEADER_GC_NPC_POSITION:
+				ret = RecvNPCList();
+				break;
+
+			case HEADER_GC_CHANNEL:
+				ret = RecvChannelPacket();
+				break;
+
+			case HEADER_GC_VIEW_EQUIP:
+				ret = RecvViewEquipPacket();
+				break;
+
+			case HEADER_GC_LAND_LIST:
+				ret = RecvLandPacket();
+				break;
+
+				//case HEADER_GC_TARGET_CREATE:
+				//	ret = RecvTargetCreatePacket();
+				//	break;
+
+			case HEADER_GC_TARGET_CREATE_NEW:
+				ret = RecvTargetCreatePacketNew();
+				break;
+
+			case HEADER_GC_TARGET_UPDATE:
+				ret = RecvTargetUpdatePacket();
+				break;
+
+			case HEADER_GC_TARGET_DELETE:
+				ret = RecvTargetDeletePacket();
+				break;
+
+			case HEADER_GC_AFFECT_ADD:
+				ret = RecvAffectAddPacket();
+				break;
+
+			case HEADER_GC_AFFECT_REMOVE:
+				ret = RecvAffectRemovePacket();
+				break;
+
+			case HEADER_GC_MALL_OPEN:
+				ret = RecvMallOpenPacket();
+				break;
+
+			case HEADER_GC_MALL_SET:
+				ret = RecvMallItemSetPacket();
+				break;
+
+			case HEADER_GC_MALL_DEL:
+				ret = RecvMallItemDelPacket();
+				break;
+
+			case HEADER_GC_LOVER_INFO:
+				ret = RecvLoverInfoPacket();
+				break;
+
+			case HEADER_GC_LOVE_POINT_UPDATE:
+				ret = RecvLovePointUpdatePacket();
+				break;
+
+			case HEADER_GC_DIG_MOTION:
+				ret = RecvDigMotionPacket();
+				break;
+
+			case HEADER_GC_HANDSHAKE:
+				RecvHandshakePacket();
+				return;
+
+			case HEADER_GC_HANDSHAKE_OK:
+				RecvHandshakeOKPacket();
+				return;
+
+			case HEADER_GC_HYBRIDCRYPT_KEYS:
+				RecvHybridCryptKeyPacket();
+				return;
+
+			case HEADER_GC_HYBRIDCRYPT_SDB:
+				RecvHybridCryptSDBPacket();
+				return;
+
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+			case HEADER_GC_KEY_AGREEMENT:
+				RecvKeyAgreementPacket();
+				return;
+
+			case HEADER_GC_KEY_AGREEMENT_COMPLETED:
+				RecvKeyAgreementCompletedPacket();
+				return;
+#endif
+
+			case HEADER_GC_SPECIFIC_EFFECT:
+				ret = RecvSpecificEffect();
+				break;
+
+#if defined(ENABLE_DRAGON_SOUL_SYSTEM)
+			case HEADER_GC_DRAGON_SOUL_REFINE:
+				ret = RecvDragonSoulRefine();
+				break;
+#endif
+
+#if defined(ENABLE_SEND_TARGET_INFO)
+			case HEADER_GC_TARGET_INFO:
+				ret = RecvTargetInfoPacket();
+				break;
+#endif
+
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+			case HEADER_GC_ACCE_REFINE:
+				ret = RecvAcceRefinePacket();
+				break;
+#endif
+
+#if defined(ENABLE_AURA_COSTUME_SYSTEM)
+			case HEADER_GC_AURA_REFINE:
+				ret = RecvAuraRefinePacket();
+				break;
+#endif
+
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+			case HEADER_GC_CHANGE_LOOK_SET:
+				ret = RecvChangeLookItemSetPacket();
+				break;
+
+			case HEADER_GC_CHANGE_LOOK_DEL:
+				ret = RecvChangeLookItemDelPacket();
+				break;
+
+			case HEADER_GC_CHANGE_LOOK_FREE_SET:
+				ret = RecvChangeLookFreeItemSetPacket();
+				break;
+
+			case HEADER_GC_CHANGE_LOOK_FREE_DEL:
+				ret = RecvChangeLookFreeItemDelPacket();
+				break;
+#endif
+
+#if defined(ENABLE_MINI_GAME_CATCH_KING)
+			case HEADER_GC_MINI_GAME_CATCH_KING:
+				ret = RecvMiniGameCatchKingPacket();
+				break;
+#endif
+
+#if defined(ENABLE_MAILBOX)
+			case HEADER_GC_MAILBOX_PROCESS:
+				ret = RecvMailboxProcess();
+				break;
+
+			case HEADER_GC_MAILBOX:
+				ret = RecvMailbox();
+				break;
+
+			case HEADER_GC_MAILBOX_ADD_DATA:
+				ret = RecvMailboxAddData();
+				break;
+
+			case HEADER_GC_MAILBOX_ALL:
+				ret = RecvMailboxAll();
+				break;
+
+			case HEADER_GC_MAILBOX_UNREAD:
+				ret = RecvMailboxUnread();
+				break;
+#endif
+
+#ifdef ENABLE_OFFLINE_SHOP
+			case HEADER_GC_OFFLINE_SHOP:
+				ret = CPythonOfflineShop::ReceivePacket();
+				break;
+#endif
+
+#ifdef ENABLE_SHOP_SEARCH
+			case HEADER_GC_SHOP_SEARCH_RESULT:
+				ret = RecvShopSearchResult();
+				break;
+
+			case HEADER_GC_SHOP_SEARCH_BUY_RESULT:
+				ret = RecvShopSearchBuyResult();
+				break;
+
+			case HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE:
+				ret = RecvShopSearchOwnerMessage();
+				break;
+
+			case HEADER_GC_SHOP_SEARCH_SOLD_INFO:
+				ret = RecvShopSearchSoldInfo();
+				break;
+#endif
+
+#ifdef ENABLE_GROWTH_PET_SYSTEM
+			case HEADER_GC_PET:
+				ret = RecvPet();
+				break;
+
+			case HEADER_GC_PET_SET:
+				ret = RecvPetSet();
+				break;
+
+			case HEADER_GC_PET_SET_EXCHANGE:
+				ret = RecvPetSetExchange();
+				break;
+
+			case HEADER_GC_PET_DEL:
+				ret = RecvPetDelete();
+				break;
+
+			case HEADER_GC_PET_SUMMON:
+				ret = RecvPetSummon();
+				break;
+
+			case HEADER_GC_PET_POINT_CHANGE:
+				ret = RecvPetPointChange();
+				break;
+
+			case HEADER_GC_PET_NAME_CHANGE_RESULT:
+				ret = RecvPetNameChangeResult();
+				break;
+
+			case HEADER_GC_PET_SKILL_UPDATE:
+				ret = RecvPetSkillUpdate();
+				break;
+
+			case HEADER_GC_PET_SKILL_COOLTIME:
+				ret = RecvPetSkillCooltime();
+				break;
+
+			case HEADER_GC_PET_DETERMINE_RESULT:
+				ret = RecvPetDetermineResult();
+				break;
+
+			case HEADER_GC_PET_ATTR_CHANGE_RESULT:
+				ret = RecvPetAttrChangeResult();
+				break;
+#endif
+
+#if defined(ENABLE_RANKING_SYSTEM)
+			case HEADER_GC_RANKING:
+				ret = RecvRanking();
+				break;
+#endif
+
+#if defined(ENABLE_CHANGED_ATTR)
+			case HEADER_GC_ITEM_SELECT_ATTR:
+				ret = RecvSelectAttr();
+				break;
+#endif
+
+#if defined(ENABLE_LOOTING_SYSTEM)
+			case HEADER_GC_LOOT_FILTER:
+				ret = RecvLootFilterPacket();
+				break;
+#endif
+
+#if defined(ENABLE_MINI_GAME_RUMI)
+			case HEADER_GC_MINI_GAME_RUMI:
+				ret = RecvMiniGameRumi();
+				break;
+#endif
+
+#if defined(ENABLE_MINI_GAME_YUTNORI)
+			case HEADER_GC_MINI_GAME_YUTNORI:
+				ret = RecvMiniGameYutnori();
+				break;
+#endif
+
+#if defined(ENABLE_LUCKY_BOX)
+			case HEADER_GC_LUCKY_BOX:
+				ret = RecvLuckyBoxPacket();
+				break;
+#endif
+
+#if defined(ENABLE_FISHING_GAME)
+			case HEADER_GC_FISHING_GAME:
+				ret = RecvFishingGamePacket();
+				break;
+#endif
+
+#if defined(ENABLE_GEM_SYSTEM)
+			case HEADER_GC_GEM_SHOP:
+				ret = RecvGemShop();
+				break;
+
+			case HEADER_GC_GEM_SHOP_PROCESS:
+				ret = RecvGemShopProcess();
+				break;
+#endif
+
+#if defined(ENABLE_EXTEND_INVEN_SYSTEM)
+			case HEADER_GC_EXTEND_INVEN:
+				ret = RecvExtendInven();
+				break;
+
+			case HEADER_GC_EXTEND_INVEN_ITEM_USE:
+				ret = RecvExtendInvenItemUse();
+				break;
+#endif
+
+#if defined(ENABLE_CLIENT_TIMER)
+			case HEADER_GC_CLIENT_TIMER:
+				ret = RecvClientTimer();
+				break;
+#endif
+
+#if defined(ENABLE_CUBE_RENEWAL)
+			case HEADER_GC_CUBE:
+				ret = RecvCubePacket();
+				break;
+#endif
+
+#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
+			case HEADER_GC_SNOWFLAKE_STICK_EVENT:
+				ret = RecvSnowflakeStickEventPacket();
+				break;
+#endif
+
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+			case HEADER_GC_REFINE_ELEMENT:
+				ret = RecvRefineElementPacket();
+				break;
+#endif
+
+#if defined(ENABLE_GUILD_DRAGONLAIR_SYSTEM)
+			case HEADER_GC_GUILD_DRAGONLAIR:
+				ret = RecvGuildDragonLairPacket();
+				break;
+#endif
+
+#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
+			case HEADER_GC_MINI_GAME_ROULETTE:
+				ret = RecvMiniGameRoulettePacket();
+				break;
+#endif
+
+#if defined(ENABLE_FLOWER_EVENT)
+			case HEADER_GC_FLOWER_EVENT:
+				ret = RecvFlowerEventPacket();
+				break;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+			case HEADER_GC_EXT_BATTLE_PASS_OPEN:
+				ret = RecvExtBattlePassOpenPacket();
+				break;
+
+			case HEADER_GC_EXT_BATTLE_PASS_GENERAL_INFO:
+				ret = RecvExtBattlePassGeneralInfoPacket();
+				break;
+
+			case HEADER_GC_EXT_BATTLE_PASS_MISSION_INFO:
+				ret = RecvExtBattlePassMissionInfoPacket();
+				break;
+
+			case HEADER_GC_EXT_BATTLE_PASS_MISSION_UPDATE:
+				ret = RecvExtBattlePassMissionUpdatePacket();
+				break;
+
+			case HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING:
+				ret = RecvExtBattlePassRankingPacket();
+				break;
+#endif
+
+			default:
+				ret = RecvDefaultPacket(header);
+				break;
+		}
+
+#ifdef __PERFORMANCE_CHECK__
+		DWORD timeEndPacket = timeGetTime();
+
+		{
+			PERF_PacketInfo& rkPacketInfo = kMap_kPacketInfo[header];
+			rkPacketInfo.dwCount++;
+			rkPacketInfo.dwTime += timeEndPacket - timeBeginPacket;
+		}
+
+		{
+			PERF_PacketInfo& rkPacketInfo = gs_kPacketTimeAnalyzer.m_kMap_kPacketInfo[header];
+			rkPacketInfo.dwCount++;
+			rkPacketInfo.dwTime += timeEndPacket - timeBeginPacket;
+		}
+#endif
+	}
+
+#ifdef __PERFORMANCE_CHECK__
+	DWORD timeEndDispatch = timeGetTime();
+
+	if (timeEndDispatch - timeBeginDispatch > 2)
+	{
+		static FILE* fp = fopen("perf_dispatch_packet.txt", "w");
+
+		fprintf(fp, "delay %d\n", timeEndDispatch - timeBeginDispatch);
+		for (std::map<DWORD, PERF_PacketInfo>::iterator i = kMap_kPacketInfo.begin(); i != kMap_kPacketInfo.end(); ++i)
+		{
+			if (i->second.dwTime > 0)
+				fprintf(fp, "header %d: count %d, time %d\n", i->first, i->second.dwCount, i->second.dwTime);
+		}
+		fputs("=====================================================\n", fp);
+		fflush(fp);
+	}
+#endif
+
+	if (!ret)
+		RecvErrorPacket(header);
+
+	static DWORD s_nextRefreshTime = ELTimer_GetMSec();
+
+	DWORD curTime = ELTimer_GetMSec();
+	if (s_nextRefreshTime > curTime)
+		return;
+
+	if (m_isRefreshCharacterWnd)
+	{
+		m_isRefreshCharacterWnd = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshCharacter", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshEquipmentWnd)
+	{
+		m_isRefreshEquipmentWnd = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshEquipment", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshInventoryWnd)
+	{
+		m_isRefreshInventoryWnd = false;
+
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshInventory", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshExchangeWnd)
+	{
+		m_isRefreshExchangeWnd = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshExchange", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshSkillWnd)
+	{
+		m_isRefreshSkillWnd = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshSkill", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshSafeboxWnd)
+	{
+		m_isRefreshSafeboxWnd = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshSafebox", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshMallWnd)
+	{
+		m_isRefreshMallWnd = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshMall", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshStatus)
+	{
+		m_isRefreshStatus = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshStatus", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshMessengerWnd)
+	{
+		m_isRefreshMessengerWnd = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshMessenger", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshGuildWndInfoPage)
+	{
+		m_isRefreshGuildWndInfoPage = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildInfoPage", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshGuildWndBoardPage)
+	{
+		m_isRefreshGuildWndBoardPage = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildBoardPage", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshGuildWndMemberPage)
+	{
+		m_isRefreshGuildWndMemberPage = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildMemberPage", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshGuildWndMemberPageGradeComboBox)
+	{
+		m_isRefreshGuildWndMemberPageGradeComboBox = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildMemberPageGradeComboBox", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshGuildWndSkillPage)
+	{
+		m_isRefreshGuildWndSkillPage = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildSkillPage", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+
+	if (m_isRefreshGuildWndGradePage)
+	{
+		m_isRefreshGuildWndGradePage = false;
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildGradePage", Py_BuildValue("()"));
+		s_nextRefreshTime = curTime + 300;
+	}
+}
+
+void CPythonNetworkStream::__InitializeGamePhase()
+{
+	__ServerTimeSync_Initialize();
+
+	m_isRefreshStatus = false;
+	m_isRefreshCharacterWnd = false;
+	m_isRefreshEquipmentWnd = false;
+	m_isRefreshInventoryWnd = false;
+	m_isRefreshExchangeWnd = false;
+	m_isRefreshSkillWnd = false;
+	m_isRefreshSafeboxWnd = false;
+	m_isRefreshMallWnd = false;
+	m_isRefreshMessengerWnd = false;
+	m_isRefreshGuildWndInfoPage = false;
+	m_isRefreshGuildWndBoardPage = false;
+	m_isRefreshGuildWndMemberPage = false;
+	m_isRefreshGuildWndMemberPageGradeComboBox = false;
+	m_isRefreshGuildWndSkillPage = false;
+	m_isRefreshGuildWndGradePage = false;
+
+	m_EmoticonTypeVector.clear();
+
+	m_pInstTarget = NULL;
+}
+
+void CPythonNetworkStream::Warp(LONG lGlobalX, LONG lGlobalY)
+{
+	CPythonBackground& rkBgMgr = CPythonBackground::Instance();
+	rkBgMgr.SetShadowLevel(CPythonBackground::SHADOW_NONE);
+	rkBgMgr.Destroy();
+
+	rkBgMgr.Create();
+	rkBgMgr.Warp(lGlobalX, lGlobalY);
+	rkBgMgr.RefreshShadowLevel();
+
+	// NOTE : Warp  CenterPosition Height 0Ì±  Ä«Þ¶ Ù´Ú¿ Ö° 
+	// Ï¶ Height  Ç± Ì¹Ç·  ÌµÏ¸ Position  Ñ¹
+	// Ø´ - [levites]
+	LONG lLocalX = lGlobalX;
+	LONG lLocalY = lGlobalY;
+	__GlobalPositionToLocalPosition(lLocalX, lLocalY);
+	float fHeight = CPythonBackground::Instance().GetHeight(float(lLocalX), float(lLocalY));
+
+	IAbstractApplication& rkApp = IAbstractApplication::GetSingleton();
+	rkApp.SetCenterPosition(float(lLocalX), float(lLocalY), fHeight);
+
+	__ShowMapName(lLocalX, lLocalY);
+}
+
+void CPythonNetworkStream::__ShowMapName(LONG lLocalX, LONG lLocalY)
+{
+	const std::string& c_rstrMapFileName = CPythonBackground::Instance().GetWarpMapName();
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ShowMapName", Py_BuildValue("(sii)", c_rstrMapFileName.c_str(), lLocalX, lLocalY));
+}
+
+void CPythonNetworkStream::__LeaveGamePhase()
+{
+	CInstanceBase::ClearPVPKeySystem();
+
+	__ClearNetworkActorManager();
+
+	m_bComboSkillFlag = FALSE;
+
+	IAbstractCharacterManager& rkChrMgr = IAbstractCharacterManager::GetSingleton();
+	rkChrMgr.Destroy();
+
+	CPythonItem& rkItemMgr = CPythonItem::Instance();
+	rkItemMgr.Destroy();
+}
+
+void CPythonNetworkStream::SetGamePhase()
+{
+	if ("Game" != m_strPhase)
+		m_phaseLeaveFunc.Run();
+
+	Tracen("");
+	Tracen("## Network - Game Phase ##");
+	Tracen("");
+
+	m_strPhase = "Game";
+
+	m_dwChangingPhaseTime = ELTimer_GetMSec();
+	m_phaseProcessFunc.Set(this, &CPythonNetworkStream::GamePhase);
+	m_phaseLeaveFunc.Set(this, &CPythonNetworkStream::__LeaveGamePhase);
+
+	// Main Character O
+
+	IAbstractPlayer& rkPlayer = IAbstractPlayer::GetSingleton();
+	rkPlayer.SetMainCharacterIndex(GetMainActorVID());
+
+	__RefreshStatus();
+}
+
+#if defined(ENABLE_SEND_TARGET_INFO)
+bool CPythonNetworkStream::SendTargetInfoPacket(DWORD dwVID)
+{
+	TPacketCGTargetInfo TargetInfoPacket;
+	TargetInfoPacket.bHeader = HEADER_CG_TARGET_INFO;
+	TargetInfoPacket.dwVID = dwVID;
+
+	if (!Send(sizeof(TargetInfoPacket), &TargetInfoPacket))
+		return false;
+
+	return SendSequence();
+}
+#endif
+
+bool CPythonNetworkStream::RecvWarpPacket()
+{
+	TPacketGCWarp kWarpPacket;
+
+	if (!Recv(sizeof(kWarpPacket), &kWarpPacket))
+		return false;
+
+	__DirectEnterMode_Set(m_dwSelectedCharacterIndex);
+	CNetworkStream::Connect((DWORD)kWarpPacket.lAddr, kWarpPacket.wPort);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvDuelStartPacket()
+{
+	TPacketGCDuelStart kDuelStartPacket;
+	if (!Recv(sizeof(kDuelStartPacket), &kDuelStartPacket))
+		return false;
+
+	DWORD count = (kDuelStartPacket.wSize - sizeof(kDuelStartPacket)) / sizeof(DWORD);
+
+	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
+
+	CInstanceBase* pkInstMain = rkChrMgr.GetMainInstancePtr();
+	if (!pkInstMain)
+	{
+		TraceError("CPythonNetworkStream::RecvDuelStartPacket - MainCharacter is NULL");
+		return false;
+	}
+	DWORD dwVIDSrc = pkInstMain->GetVirtualID();
+	DWORD dwVIDDest;
+
+	for (DWORD i = 0; i < count; i++)
+	{
+		Recv(sizeof(dwVIDDest), &dwVIDDest);
+		CInstanceBase::InsertDUELKey(dwVIDSrc, dwVIDDest);
+	}
+
+	if (count == 0)
+		pkInstMain->SetDuelMode(CInstanceBase::DUEL_CANNOTATTACK);
+	else
+		pkInstMain->SetDuelMode(CInstanceBase::DUEL_START);
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoard", Py_BuildValue("()"));
+
+	rkChrMgr.RefreshAllPCTextTail();
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPVPPacket()
+{
+	TPacketGCPVP kPVPPacket;
+	if (!Recv(sizeof(kPVPPacket), &kPVPPacket))
+		return false;
+
+	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
+	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
+
+	switch (kPVPPacket.bMode)
+	{
+		case PVP_MODE_AGREE:
+			rkChrMgr.RemovePVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);
+
+			// ë°¡ (Dst) Ç¸ 
+			if (rkPlayer.IsMainCharacterIndex(kPVPPacket.dwVIDDst))
+				rkPlayer.RememberChallengeInstance(kPVPPacket.dwVIDSrc);
+
+			// ë¿¡ Ç¸  È¿  Ò´
+			if (rkPlayer.IsMainCharacterIndex(kPVPPacket.dwVIDSrc))
+				rkPlayer.RememberCantFightInstance(kPVPPacket.dwVIDDst);
+			break;
+		case PVP_MODE_REVENGE:
+		{
+			rkChrMgr.RemovePVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);
+
+			DWORD dwKiller = kPVPPacket.dwVIDSrc;
+			DWORD dwVictim = kPVPPacket.dwVIDDst;
+
+			// (victim) ë¿¡   
+			if (rkPlayer.IsMainCharacterIndex(dwVictim))
+				rkPlayer.RememberRevengeInstance(dwKiller);
+
+			// (victim)  Ï´ È¿  Ò´
+			if (rkPlayer.IsMainCharacterIndex(dwKiller))
+				rkPlayer.RememberCantFightInstance(dwVictim);
+			break;
+		}
+
+		case PVP_MODE_FIGHT:
+			rkChrMgr.InsertPVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);
+			rkPlayer.ForgetInstance(kPVPPacket.dwVIDSrc);
+			rkPlayer.ForgetInstance(kPVPPacket.dwVIDDst);
+			break;
+		case PVP_MODE_NONE:
+			rkChrMgr.RemovePVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);
+			rkPlayer.ForgetInstance(kPVPPacket.dwVIDSrc);
+			rkPlayer.ForgetInstance(kPVPPacket.dwVIDDst);
+			break;
+	}
+
+	// NOTE : PVP Û½ TargetBoard  Æ® Õ´Ï´.
+	__RefreshTargetBoardByVID(kPVPPacket.dwVIDSrc);
+	__RefreshTargetBoardByVID(kPVPPacket.dwVIDDst);
+
+	return true;
+}
+
+// DELETEME
+/*
+void CPythonNetworkStream::__SendWarpPacket()
+{
+	TPacketCGWarp kWarpPacket;
+	kWarpPacket.bHeader=HEADER_GC_WARP;
+	if (!Send(sizeof(kWarpPacket), &kWarpPacket))
+	{
+		return;
+	}
+}
+*/
+void CPythonNetworkStream::NotifyHack(const char* c_szMsg)
+{
+	if (!m_kQue_stHack.empty())
+		if (c_szMsg == m_kQue_stHack.back())
+			return;
+
+	m_kQue_stHack.push_back(c_szMsg);
+}
+
+bool CPythonNetworkStream::__SendHack(const char* c_szMsg)
+{
+	Tracen(c_szMsg);
+
+	TPacketCGHack kPacketHack;
+	kPacketHack.bHeader = HEADER_CG_HACK;
+	strncpy(kPacketHack.szBuf, c_szMsg, sizeof(kPacketHack.szBuf) - 1);
+
+	if (!Send(sizeof(kPacketHack), &kPacketHack))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendCharacterStatePacket(const TPixelPosition& c_rkPPosDst, float fDstRot, UINT eFunc, UINT uArg)
+{
+	NANOBEGIN
+		if (!__CanActMainInstance())
+			return true;
+
+	if (fDstRot < 0.0f)
+		fDstRot = 360 + fDstRot;
+	else if (fDstRot > 360.0f)
+		fDstRot = fmodf(fDstRot, 360.0f);
+
+	// TODO: ß¿ Å¶Ì¸ Ù²
+	TPacketCGMove kStatePacket;
+	kStatePacket.bHeader = HEADER_CG_CHARACTER_MOVE;
+	kStatePacket.bFunc = eFunc;
+	kStatePacket.bArg = uArg;
+	kStatePacket.bRot = fDstRot / 5.0f;
+	kStatePacket.lX = long(c_rkPPosDst.x);
+	kStatePacket.lY = long(c_rkPPosDst.y);
+	kStatePacket.dwTime = ELTimer_GetServerMSec();
+
+	assert(kStatePacket.lX >= 0 && kStatePacket.lX < 204800);
+
+	__LocalPositionToGlobalPosition(kStatePacket.lX, kStatePacket.lY);
+
+	if (!Send(sizeof(kStatePacket), &kStatePacket))
+	{
+		Tracenf("CPythonNetworkStream::SendCharacterStatePacket(dwCmdTime=%u, fDstPos=(%f, %f), fDstRot=%f, eFunc=%d uArg=%d) - PACKET SEND ERROR",
+			kStatePacket.dwTime,
+			float(kStatePacket.lX),
+			float(kStatePacket.lY),
+			fDstRot,
+			kStatePacket.bFunc,
+			kStatePacket.bArg);
+		return false;
+	}
+	NANOEND
+		return SendSequence();
+}
+
+// NOTE : SlotIndex Ó½
+bool CPythonNetworkStream::SendUseSkillPacket(DWORD dwSkillIndex, DWORD dwTargetVID)
+{
+	TPacketCGUseSkill UseSkillPacket;
+	UseSkillPacket.bHeader = HEADER_CG_USE_SKILL;
+	UseSkillPacket.dwVnum = dwSkillIndex;
+	UseSkillPacket.dwTargetVID = dwTargetVID;
+
+	if (!Send(sizeof(TPacketCGUseSkill), &UseSkillPacket))
+	{
+		Tracen("CPythonNetworkStream::SendUseSkillPacket - SEND PACKET ERROR");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendChatPacket(const char* c_szChat, BYTE byType)
+{
+	if (m_strPhase != "Game")
+		return true;
+
+	if (strlen(c_szChat) == 0)
+		return true;
+
+	if (strlen(c_szChat) >= 512)
+		return true;
+
+	if (c_szChat[0] == '/')
+	{
+		if (1 == strlen(c_szChat))
+		{
+			if (!m_strLastCommand.empty())
+				c_szChat = m_strLastCommand.c_str();
+		}
+		else
+		{
+			m_strLastCommand = c_szChat;
+		}
+	}
+
+	if (ClientCommand(c_szChat))
+		return true;
+
+	int iTextLen = strlen(c_szChat) + 1;
+	TPacketCGChat ChatPacket;
+	ChatPacket.header = HEADER_CG_CHAT;
+	ChatPacket.length = sizeof(ChatPacket) + iTextLen;
+	ChatPacket.type = byType;
+
+	if (!Send(sizeof(ChatPacket), &ChatPacket))
+		return false;
+
+	if (!Send(iTextLen, c_szChat))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendCommandPacket(const char* c_szChat)
+{
+	return SendChatPacket(c_szChat, CHAT_TYPE_COMMAND);
+}
+
+//////////////////////////////////////////////////////////////////////////
+// Emoticon
+void CPythonNetworkStream::RegisterEmoticonType(const BYTE bEmoticonType)
+{
+	if (m_EmoticonTypeVector.size() >= CInstanceBase::EMOTICON_NUM)
+	{
+		TraceError("Can't register emoticon string... vector is full (size:%d)", m_EmoticonTypeVector.size());
+		return;
+	}
+	m_EmoticonTypeVector.push_back(bEmoticonType);
+}
+
+bool CPythonNetworkStream::ParseEmoticon(const BYTE bEmoticonType, DWORD* pdwEmoticon)
+{
+	for (DWORD dwEmoticonIndex = 0; dwEmoticonIndex < m_EmoticonTypeVector.size(); ++dwEmoticonIndex)
+	{
+		if (m_EmoticonTypeVector[dwEmoticonIndex] == bEmoticonType)
+		{
+			*pdwEmoticon = dwEmoticonIndex;
+			return true;
+		}
+	}
+
+	return false;
+}
+// Emoticon
+//////////////////////////////////////////////////////////////////////////
+
+void CPythonNetworkStream::__ConvertEmpireText(DWORD dwEmpireID, char* szText)
+{
+	if (dwEmpireID < 1 || dwEmpireID>3)
+		return;
+
+	UINT uHanPos;
+
+	STextConvertTable& rkTextConvTable = m_aTextConvTable[dwEmpireID - 1];
+
+	BYTE* pbText = (BYTE*)szText;
+	while (*pbText)
+	{
+		if (*pbText & 0x80)
+		{
+			if (pbText[0] >= 0xb0 && pbText[0] <= 0xc8 && pbText[1] >= 0xa1 && pbText[1] <= 0xfe)
+			{
+				uHanPos = (pbText[0] - 0xb0) * (0xfe - 0xa1 + 1) + (pbText[1] - 0xa1);
+				pbText[0] = rkTextConvTable.aacHan[uHanPos][0];
+				pbText[1] = rkTextConvTable.aacHan[uHanPos][1];
+			}
+			pbText += 2;
+		}
+		else
+		{
+			if (*pbText >= 'a' && *pbText <= 'z')
+			{
+				*pbText = rkTextConvTable.acLower[*pbText - 'a'];
+			}
+			else if (*pbText >= 'A' && *pbText <= 'Z')
+			{
+				*pbText = rkTextConvTable.acUpper[*pbText - 'A'];
+			}
+			pbText++;
+		}
+	}
+}
+
+bool CPythonNetworkStream::RecvChatPacket()
+{
+	TPacketGCChat kChat;
+	char buf[1024 + 1];
+	char line[1024 + 1];
+
+	if (!Recv(sizeof(kChat), &kChat))
+		return false;
+
+	UINT uChatSize = kChat.size - sizeof(kChat);
+
+	if (!Recv(uChatSize, buf))
+		return false;
+
+	buf[uChatSize] = '\0';
+
+#if defined(ENABLE_LOCALE_CLIENT)
+	TTokenVector vecMultiLine;
+	std::string sFormat = { buf };
+	if (kChat.bCanFormat && CHAT_TYPE_SHOUT != kChat.type)
+	{
+		CPythonLocale::Instance().FormatString(sFormat);
+		CPythonLocale::Instance().MultiLineSplit(sFormat, vecMultiLine);
+	}
+	else
+	{
+		CPythonLocale::Instance().FilterHyperlinkName(sFormat);
+	}
+
+	strncpy(buf, sFormat.c_str(), sizeof(buf));
+	buf[sizeof(buf) - 1] = '\0';
+#endif
+
+	//  Æ¶  Ã³
+	// "Ì¸: " Ô· ": Ì¸"  Ï±  (0x08) 
+	//  Æ¶ È£ Ã³ (1) : (2)  Ô·ÂµÇ¾îµµ (2) : (1)  Ï° 
+	if (LocaleService_IsEUROPE() && GetDefaultCodePage() == 1256)
+	{
+		char* p = strchr(buf, ':');
+		if (p && p[1] == ' ')
+			p[1] = 0x08;
+	}
+
+	if (kChat.type >= CHAT_TYPE_MAX_NUM)
+		return true;
+
+	if (CHAT_TYPE_COMMAND == kChat.type)
+	{
+		ServerCommand(buf);
+		return true;
+	}
+	else if (CHAT_TYPE_MISSION == kChat.type)
+	{
+		if (uChatSize)
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetMissionMessage", Py_BuildValue("(s)", buf));
+		else
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_CleanMissionMessage", Py_BuildValue("()"));
+
+		return true;
+	}
+	else if (CHAT_TYPE_SUB_MISSION == kChat.type)
+	{
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetSubMissionMessage", Py_BuildValue("(s)", buf));
+		return true;
+	}
+
+	if (kChat.dwVID != 0)
+	{
+		CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
+		CInstanceBase* pkInstChatter = rkChrMgr.GetInstancePtr(kChat.dwVID);
+		if (NULL == pkInstChatter)
+			return true;
+
+		switch (kChat.type)
+		{
+			case CHAT_TYPE_TALKING: /* ×³ Ã¤ */
+			case CHAT_TYPE_PARTY: /* Æ¼ */
+			case CHAT_TYPE_GUILD: /* å¸» */
+			case CHAT_TYPE_SHOUT: /* Ä¡ */
+			case CHAT_TYPE_WHISPER: // Í´  Ê´ Only Client Enum
+			{
+				char* p = strchr(buf, ':');
+
+				if (p)
+					p += 2;
+				else
+					p = buf;
+
+				if (gs_bEmpireLanuageEnable)
+				{
+					CInstanceBase* pkInstMain = rkChrMgr.GetMainInstancePtr();
+					if (pkInstMain)
+						if (!pkInstMain->IsSameEmpire(*pkInstChatter))
+							__ConvertEmpireText(pkInstChatter->GetEmpireID(), p);
+				}
+
+				if (m_isEnableChatInsultFilter)
+				{
+					if (false == pkInstChatter->IsNPC() && false == pkInstChatter->IsEnemy())
+					{
+						__FilterInsult(p, strlen(p));
+					}
+				}
+
+				_snprintf(line, sizeof(line), "%s", p);
+			}
+			break;
+
+			case CHAT_TYPE_COMMAND: /*  */
+			case CHAT_TYPE_INFO: /*  ( , Ä¡ . ) */
+			case CHAT_TYPE_NOTICE: /*  */
+			case CHAT_TYPE_BIG_NOTICE:
+#if defined(ENABLE_OX_RENEWAL)
+			case CHAT_TYPE_BIG_CONTROL_NOTICE:
+#endif
+#if defined(ENABLE_DICE_SYSTEM)
+			case CHAT_TYPE_DICE_INFO:
+#endif
+#if defined(ENABLE_CHATTING_WINDOW_RENEWAL)
+			case CHAT_TYPE_EXP_INFO:
+			case CHAT_TYPE_ITEM_INFO:
+			case CHAT_TYPE_MONEY_INFO:
+#endif
+			case CHAT_TYPE_MAX_NUM:
+			default:
+				_snprintf(line, sizeof(line), "%s", buf);
+				break;
+		}
+
+		if (CHAT_TYPE_SHOUT != kChat.type)
+		{
+			CPythonTextTail::Instance().RegisterChatTail(kChat.dwVID, line);
+		}
+
+		if (pkInstChatter->IsPC())
+		{
+#if defined(ENABLE_MESSENGER_BLOCK)
+			if (CPythonMessenger::Instance().IsBlockFriendByName(pkInstChatter->GetNameString()))
+				return true;
+#endif
+
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+			CPythonChat::Instance().AppendChat(kChat.type, buf, IAbstractChat::ESpecialColorType::CHAT_SPECIAL_COLOR_NORMAL, kChat.szCountry);
+#else
+			CPythonChat::Instance().AppendChat(kChat.type, buf);
+#endif
+		}
+	}
+	else
+	{
+		if (CHAT_TYPE_NOTICE == kChat.type)
+		{
+#if defined(ENABLE_LOCALE_CLIENT)
+			if (!vecMultiLine.empty())
+			{
+				for (std::string& sMessage : vecMultiLine)
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetTipMessage", Py_BuildValue("(s)", sMessage.c_str()));
+			}
+			else
+			{
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetTipMessage", Py_BuildValue("(s)", buf));
+			}
+#else
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetTipMessage", Py_BuildValue("(s)", buf));
+#endif
+		}
+		else if (CHAT_TYPE_BIG_NOTICE == kChat.type)
+		{
+#if defined(ENABLE_LOCALE_CLIENT)
+			if (!vecMultiLine.empty())
+			{
+				for (const std::string& sMessage : vecMultiLine)
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigMessage", Py_BuildValue("(s)", sMessage.c_str()));
+			}
+			else
+			{
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigMessage", Py_BuildValue("(s)", buf));
+			}
+#else
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigMessage", Py_BuildValue("(s)", buf));
+#endif
+		}
+#if defined(ENABLE_OX_RENEWAL)
+		else if (CHAT_TYPE_BIG_CONTROL_NOTICE == kChat.type)
+		{
+#if defined(ENABLE_LOCALE_CLIENT)
+			if (strstr(buf, "#start") || strstr(buf, "#send") || strstr(buf, "#end"))
+			{
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigControlMessage", Py_BuildValue("(s)", buf));
+			}
+			else
+			{
+				if (!vecMultiLine.empty())
+				{
+					for (const std::string& sMessage : vecMultiLine)
+						PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigControlMessage", Py_BuildValue("(s)", sMessage.c_str()));
+				}
+				else
+				{
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigControlMessage", Py_BuildValue("(s)", buf));
+				}
+			}
+#else
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigControlMessage", Py_BuildValue("(s)", buf));
+#endif
+		}
+#endif
+		else if (CHAT_TYPE_SHOUT == kChat.type)
+		{
+			char* p = strchr(buf, ':');
+
+			if (p)
+			{
+				if (m_isEnableChatInsultFilter)
+					__FilterInsult(p, strlen(p));
+			}
+		}
+
+#if defined(ENABLE_LOCALE_CLIENT)
+		if (!vecMultiLine.empty())
+		{
+			for (const std::string& sMessage : vecMultiLine)
+				CPythonChat::Instance().AppendChat(kChat.type, sMessage.c_str());
+		}
+		else
+		{
+			if (buf[0] == '@')
+				CPythonChat::Instance().AppendChat(kChat.type, &buf[1], IAbstractChat::ESpecialColorType::CHAT_SPECIAL_COLOR_DICE_0);
+			else if (buf[0] == '$')
+				CPythonChat::Instance().AppendChat(kChat.type, &buf[1], IAbstractChat::ESpecialColorType::CHAT_SPECIAL_COLOR_DICE_1);
+			else
+			{
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+				CPythonChat::Instance().AppendChat(kChat.type, buf, IAbstractChat::ESpecialColorType::CHAT_SPECIAL_COLOR_NORMAL, kChat.szCountry);
+#else
+				CPythonChat::Instance().AppendChat(kChat.type, buf);
+#endif
+			}
+		}
+#else
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+		CPythonChat::Instance().AppendChat(kChat.type, buf, kChat.szCountry);
+#else
+		CPythonChat::Instance().AppendChat(kChat.type, buf);
+#endif
+#endif
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvWhisperPacket()
+{
+	TPacketGCWhisper whisperPacket;
+	char buf[512 + 1];
+
+	if (!Recv(sizeof(whisperPacket), &whisperPacket))
+		return false;
+
+	assert(whisperPacket.wSize - sizeof(whisperPacket) < 512);
+
+	if (!Recv(whisperPacket.wSize - sizeof(whisperPacket), &buf))
+		return false;
+
+	buf[whisperPacket.wSize - sizeof(whisperPacket)] = '\0';
+
+#if defined(ENABLE_LOCALE_CLIENT)
+	TTokenVector vecMultiLine;
+	if (whisperPacket.bCanFormat)
+	{
+		CPythonLocale::Instance().FormatString(buf, sizeof(buf));
+		CPythonLocale::Instance().FormatString(whisperPacket.szNameFrom, sizeof(whisperPacket.szNameFrom));
+	}
+#endif
+
+	static char line[256];
+	if (CPythonChat::WHISPER_TYPE_CHAT == whisperPacket.bType || CPythonChat::WHISPER_TYPE_GM == whisperPacket.bType)
+	{
+		if (GetDefaultCodePage() == CP_ARABIC)
+			_snprintf(line, sizeof(line), "%s", buf);
+		else
+			_snprintf(line, sizeof(line), "%s : %s", whisperPacket.szNameFrom, buf);
+
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnRecvWhisper", Py_BuildValue("(isss)", (int)whisperPacket.bType, whisperPacket.szNameFrom, line, whisperPacket.szCountry));
+#else
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnRecvWhisper", Py_BuildValue("(iss)", (int)whisperPacket.bType, whisperPacket.szNameFrom, line));
+#endif
+#if defined(ENABLE_BADGE_NOTIFICATION_MANAGER)
+		static auto& badge_notification_manager = CBadgeNotificationManager::Instance();
+		badge_notification_manager.ReceiveWhisper(whisperPacket.szNameFrom);
+#endif
+	}
+	else if (CPythonChat::WHISPER_TYPE_SYSTEM == whisperPacket.bType || CPythonChat::WHISPER_TYPE_ERROR == whisperPacket.bType)
+	{
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnRecvWhisperSystemMessage", Py_BuildValue("(iss)", (int)whisperPacket.bType, whisperPacket.szNameFrom, buf));
+	}
+	else
+	{
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnRecvWhisperError", Py_BuildValue("(iss)", (int)whisperPacket.bType, whisperPacket.szNameFrom, buf));
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendWhisperPacket(const char* name, const char* c_szChat)
+{
+	if (strlen(c_szChat) >= 255)
+		return true;
+
+	int iTextLen = strlen(c_szChat) + 1;
+	TPacketCGWhisper WhisperPacket;
+	WhisperPacket.bHeader = HEADER_CG_WHISPER;
+	WhisperPacket.wSize = sizeof(WhisperPacket) + iTextLen;
+
+	strncpy(WhisperPacket.szNameTo, name, sizeof(WhisperPacket.szNameTo) - 1);
+
+	if (!Send(sizeof(WhisperPacket), &WhisperPacket))
+		return false;
+
+	if (!Send(iTextLen, c_szChat))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvPointChange()
+{
+	TPacketGCPointChange PointChange;
+
+	if (!Recv(sizeof(TPacketGCPointChange), &PointChange))
+	{
+		Tracen("Recv Point Change Packet Error");
+		return false;
+	}
+
+	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
+	rkChrMgr.ShowPointEffect(PointChange.wType, PointChange.dwVID);
+
+	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetMainInstancePtr();
+
+	// Ú½ Point Ç¾ ..
+	if (pInstance)
+	{
+		if (PointChange.dwVID == pInstance->GetVirtualID())
+		{
+			CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
+			rkPlayer.SetStatus(PointChange.wType, PointChange.lValue);
+
+			switch (PointChange.wType)
+			{
+				case POINT_STAT_RESET_COUNT:
+					__RefreshStatus();
+					break;
+
+#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
+				case POINT_PLAYTIME:
+					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].dwPlayMinutes = PointChange.lValue;
+					break;
+#endif
+
+				case POINT_LEVEL:
+#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
+				{
+					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byLevel = PointChange.lValue;
+					__RefreshStatus();
+					__RefreshSkillWindow();
+				}
+				break;
+#endif
+
+				case POINT_ST:
+#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
+				{
+					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byST = PointChange.lValue;
+					__RefreshStatus();
+					__RefreshSkillWindow();
+				}
+				break;
+#endif
+
+				case POINT_DX:
+#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
+				{
+					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byDX = PointChange.lValue;
+					__RefreshStatus();
+					__RefreshSkillWindow();
+				}
+				break;
+#endif
+
+				case POINT_HT:
+#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
+				{
+					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byHT = PointChange.lValue;
+					__RefreshStatus();
+					__RefreshSkillWindow();
+				}
+				break;
+#endif
+
+				case POINT_IQ:
+#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
+				{
+					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byIQ = PointChange.lValue;
+					__RefreshStatus();
+					__RefreshSkillWindow();
+				}
+				break;
+#endif
+
+#if defined(ENABLE_CONQUEROR_LEVEL)
+				case POINT_CONQUEROR_LEVEL:
+				{
+					pInstance->UpdateTextTailConquerorLevel(PointChange.lValue);
+#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
+					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].byConquerorLevel = PointChange.lValue;
+					__RefreshStatus();
+					__RefreshSkillWindow();
+#endif
+				}
+				break;
+
+				case POINT_SUNGMA_STR:
+#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
+				{
+					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].bySungmaStr = PointChange.lValue;
+					__RefreshStatus();
+					__RefreshSkillWindow();
+				}
+				break;
+#endif
+
+				case POINT_SUNGMA_HP:
+#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
+				{
+					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].bySungmaHp = PointChange.lValue;
+					__RefreshStatus();
+					__RefreshSkillWindow();
+				}
+				break;
+#endif
+
+				case POINT_SUNGMA_MOVE:
+#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
+				{
+					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].bySungmaMove = PointChange.lValue;
+					__RefreshStatus();
+					__RefreshSkillWindow();
+				}
+				break;
+#endif
+
+				case POINT_SUNGMA_IMMUNE:
+#if defined(ENABLE_IMPROVED_LOGOUT_POINTS)
+				{
+					m_akSimplePlayerInfo[m_dwSelectedCharacterIndex].bySungmaImmune = PointChange.lValue;
+					__RefreshStatus();
+					__RefreshSkillWindow();
+				}
+				break;
+#endif
+#endif
+
+				case POINT_SKILL:
+				case POINT_SUB_SKILL:
+				case POINT_HORSE_SKILL:
+					__RefreshSkillWindow();
+					break;
+
+				case POINT_ENERGY:
+				{
+					if (PointChange.lValue == 0)
+					{
+						rkPlayer.SetStatus(POINT_ENERGY_END_TIME, 0);
+					}
+					__RefreshStatus();
+				}
+				break;
+
+				default:
+					__RefreshStatus();
+					break;
+			}
+
+			if (POINT_GOLD == PointChange.wType)
+			{
+				if (PointChange.lAmount > 0)
+				{
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnPickMoney", Py_BuildValue("(i)", PointChange.lAmount));
+				}
+			}
+
+#if defined(ENABLE_CHEQUE_SYSTEM)
+			if (POINT_CHEQUE == PointChange.wType)
+			{
+				if (PointChange.lAmount > 0)
+				{
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnPickCheque", Py_BuildValue("(i)", PointChange.lAmount));
+				}
+			}
+#endif
+
+#if defined(ENABLE_GEM_SYSTEM)
+			if (POINT_GEM == PointChange.wType)
+			{
+				if (PointChange.lAmount > 0)
+				{
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnPickGem", Py_BuildValue("(i)", PointChange.lAmount));
+				}
+			}
+#endif
+		}
+		else if (POINT_LEVEL == PointChange.wType)
+		{
+			CInstanceBase* pOtherInstance = CPythonCharacterManager::Instance().GetInstancePtr(PointChange.dwVID);
+			if (pOtherInstance)
+				pOtherInstance->UpdateTextTailLevel(PointChange.lValue);
+#ifdef ENABLE_GROWTH_PET_SYSTEM
+				if (pInstance->IsGrowthPet())
+					pInstance->SetPetLevel(PointChange.lValue);
+#endif
+		}
+#if defined(ENABLE_CONQUEROR_LEVEL)
+		else if (POINT_CONQUEROR_LEVEL == PointChange.wType)
+		{
+			CInstanceBase* pOtherInstance = CPythonCharacterManager::Instance().GetInstancePtr(PointChange.dwVID);
+			if (pOtherInstance)
+				pOtherInstance->UpdateTextTailConquerorLevel(PointChange.lValue);
+		}
+#endif
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvStunPacket()
+{
+	TPacketGCStun StunPacket;
+
+	if (!Recv(sizeof(StunPacket), &StunPacket))
+	{
+		Tracen("CPythonNetworkStream::RecvStunPacket Error");
+		return false;
+	}
+
+	//Tracef("RecvStunPacket %d\n", StunPacket.vid);
+
+	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
+	CInstanceBase* pkInstSel = rkChrMgr.GetInstancePtr(StunPacket.vid);
+
+	if (pkInstSel)
+	{
+		if (CPythonCharacterManager::Instance().GetMainInstancePtr() == pkInstSel)
+			pkInstSel->Die();
+		else
+			pkInstSel->Stun();
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvDeadPacket()
+{
+	TPacketGCDead DeadPacket;
+	if (!Recv(sizeof(DeadPacket), &DeadPacket))
+	{
+		Tracen("CPythonNetworkStream::RecvDeadPacket Error");
+		return false;
+	}
+
+	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
+	CInstanceBase* pkChrInstSel = rkChrMgr.GetInstancePtr(DeadPacket.vid);
+	if (pkChrInstSel)
+	{
+		CInstanceBase* pkInstMain = rkChrMgr.GetMainInstancePtr();
+		if (pkInstMain == pkChrInstSel)
+		{
+			Tracenf("Î° ");
+
+			if (false == pkInstMain->GetDuelMode())
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnGameOver", Py_BuildValue("(ii)", DeadPacket.map_index, DeadPacket.dialog_type));
+
+			CPythonPlayer::Instance().NotifyDeadMainCharacter();
+#if defined(ENABLE_SKILL_COOLTIME_UPDATE)
+			CPythonPlayer::Instance().ResetSkillCoolTimes();
+#endif
+		}
+
+		pkChrInstSel->Die();
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendCharacterPositionPacket(BYTE iPosition)
+{
+	TPacketCGPosition PositionPacket{};
+
+	PositionPacket.header = HEADER_CG_CHARACTER_POSITION;
+	PositionPacket.position = iPosition;
+
+	if (!Send(sizeof(TPacketCGPosition), &PositionPacket))
+	{
+		Tracen("Send Character Position Packet Error");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendOnClickPacket(DWORD vid)
+{
+	TPacketCGOnClick OnClickPacket{};
+	OnClickPacket.header = HEADER_CG_ON_CLICK;
+	OnClickPacket.vid = vid;
+
+	if (!Send(sizeof(OnClickPacket), &OnClickPacket))
+	{
+		Tracen("Send On_Click Packet Error");
+		return false;
+	}
+
+	Tracef("SendOnClickPacket\n");
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvCharacterPositionPacket()
+{
+	TPacketGCPosition PositionPacket;
+
+	if (!Recv(sizeof(TPacketGCPosition), &PositionPacket))
+		return false;
+
+	CInstanceBase* pChrInstance = CPythonCharacterManager::Instance().GetInstancePtr(PositionPacket.vid);
+
+	if (!pChrInstance)
+		return true;
+
+	//pChrInstance->UpdatePosition(PositionPacket.position);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvMotionPacket()
+{
+	TPacketGCMotion MotionPacket;
+
+	if (!Recv(sizeof(TPacketGCMotion), &MotionPacket))
+		return false;
+
+	CInstanceBase* pMainInstance = CPythonCharacterManager::Instance().GetInstancePtr(MotionPacket.vid);
+	CInstanceBase* pVictimInstance = NULL;
+
+	if (0 != MotionPacket.victim_vid)
+		pVictimInstance = CPythonCharacterManager::Instance().GetInstancePtr(MotionPacket.victim_vid);
+
+	if (!pMainInstance)
+		return false;
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvShopPacket()
+{
+	std::vector<char> vecBuffer;
+	vecBuffer.clear();
+
+	TPacketGCShop packet_shop;
+	if (!Recv(sizeof(packet_shop), &packet_shop))
+		return false;
+
+	if (packet_shop.size < sizeof(packet_shop))
+		return false;
+
+	int iSize = packet_shop.size - sizeof(packet_shop);
+	if (iSize > 0)
+	{
+		vecBuffer.resize(iSize);
+		if (!Recv(iSize, &vecBuffer[0]))
+			return false;
+	}
+
+	switch (packet_shop.subheader)
+	{
+		case SHOP_SUBHEADER_GC_START:
+		{
+			const int kMin = (int)(sizeof(DWORD) + sizeof(TPacketGCShopStart));
+			if (iSize < kMin)
+				return false;
+
+			CPythonShop::Instance().Clear();
+
+			DWORD dwVID = *(DWORD*)&vecBuffer[0];
+
+			TPacketGCShopStart* pShopStartPacket = (TPacketGCShopStart*)&vecBuffer[4];
+#if defined(ENABLE_MYSHOP_DECO)
+			BYTE shop_tab_count = pShopStartPacket->shop_tab_count;
+			CPythonShop::Instance().SetTabCount(shop_tab_count);
+#endif
+
+#if defined(ENABLE_MYSHOP_EXPANSION)
+			for (BYTE iItemIndex = 0; iItemIndex < 80; ++iItemIndex)
+#else
+			for (BYTE iItemIndex = 0; iItemIndex < SHOP_HOST_ITEM_MAX_NUM; ++iItemIndex)
+#endif
+				CPythonShop::Instance().SetItemData(iItemIndex, pShopStartPacket->items[iItemIndex]);
+
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartShop", Py_BuildValue("(i)", dwVID));
+		}
+		break;
+
+		case SHOP_SUBHEADER_GC_END:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "EndShop", Py_BuildValue("()"));
+			break;
+
+		case SHOP_SUBHEADER_GC_UPDATE_ITEM:
+		{
+			if (iSize < (int)sizeof(TPacketGCShopUpdateItem))
+				return false;
+
+			TPacketGCShopUpdateItem* pShopUpdateItemPacket = (TPacketGCShopUpdateItem*)&vecBuffer[0];
+			CPythonShop::Instance().SetItemData(pShopUpdateItemPacket->pos, pShopUpdateItemPacket->item);
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshShop", Py_BuildValue("()"));
+		}
+		break;
+
+		case SHOP_SUBHEADER_GC_UPDATE_PRICE:
+			if (iSize < (int)sizeof(int))
+				return false;
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetShopSellingPrice", Py_BuildValue("(i)", *(int*)&vecBuffer[0]));
+			break;
+
+		case SHOP_SUBHEADER_GC_OK:
+			break;
+
+		case SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_MONEY"));
+			break;
+
+		case SHOP_SUBHEADER_GC_SOLDOUT:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "SOLDOUT"));
+			break;
+
+		case SHOP_SUBHEADER_GC_INVENTORY_FULL:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "INVENTORY_FULL"));
+			break;
+
+		case SHOP_SUBHEADER_GC_INVALID_POS:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "INVALID_POS"));
+			break;
+
+		case SHOP_SUBHEADER_GC_SOLD_OUT:
+			break;
+
+
+		case SHOP_SUBHEADER_GC_START_EX:
+		{
+			CPythonShop::Instance().Clear();
+
+			TPacketGCShopStartEx* pShopStartPacket = (TPacketGCShopStartEx*)&vecBuffer[0];
+			size_t read_point = sizeof(TPacketGCShopStartEx);
+
+			DWORD dwVID = pShopStartPacket->owner_vid;
+			BYTE shop_tab_count = pShopStartPacket->shop_tab_count;
+
+			CPythonShop::Instance().SetTabCount(shop_tab_count);
+
+			for (BYTE i = 0; i < shop_tab_count; i++)
+			{
+				TPacketGCShopStartEx::TSubPacketShopTab* pPackTab = (TPacketGCShopStartEx::TSubPacketShopTab*)&vecBuffer[read_point];
+				read_point += sizeof(TPacketGCShopStartEx::TSubPacketShopTab);
+
+				CPythonShop::Instance().SetTabCoinType(i, pPackTab->coin_type);
+				CPythonShop::Instance().SetTabName(i, pPackTab->name);
+
+				struct packet_shop_item* item = &pPackTab->items[0];
+
+				for (BYTE j = 0; j < SHOP_HOST_ITEM_MAX_NUM; j++)
+				{
+					TShopItemData* itemData = (item + j);
+					if (itemData)
+						CPythonShop::Instance().SetItemData(i, j, *itemData);
+				}
+			}
+
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartShop", Py_BuildValue("(i)", dwVID));
+		}
+		break;
+
+		case SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY_EX:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_MONEY_EX"));
+			break;
+
+		case SHOP_SUBHEADER_GC_NOT_ENOUGH_BP:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_BP"));
+			break;
+
+		case SHOP_SUBHEADER_GC_EXCEED_LIMIT_TODAY:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "EXCEED_LIMIT_TODAY"));
+			break;
+
+#if defined(ENABLE_MYSHOP_DECO)
+		case SHOP_SUBHEADER_GC_MYPRIV_SHOP_OPEN:
+		{
+			const TPacketGCMyPrivShopOpen* pMyPrivShopOpenPacket = (TPacketGCMyPrivShopOpen*)&vecBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MyPrivShopOpen", Py_BuildValue("(bi)", pMyPrivShopOpenPacket->bCashItem, pMyPrivShopOpenPacket->bTabCount));
+		}
+		break;
+#endif
+
+		case SHOP_SUBHEADER_GC_NOT_ENOUGH_10TH_COIN:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_10TH_COIN"));
+			break;
+
+		case SHOP_SUBHEADER_GC_LIMITED_PURCHASE_OVER:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "LIMITED_PURCHASE_OVER"));
+			break;
+
+		case SHOP_SUBHEADER_GC_LIMITED_DATA_LOADING:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "LIMITED_DATA_LOADING"));
+			break;
+
+			// 12ZI RELATED
+		case SHOP_SUBHEADER_GC_UNK_19:
+			break;
+		case SHOP_SUBHEADER_GC_UNK_20:
+			break;
+		case SHOP_SUBHEADER_GC_UNK_21:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshShopItemToolTip", Py_BuildValue("()"));
+			break;
+			// END_OF_12ZI_RELATED
+
+		case SHOP_SUBHEADER_GC_NOT_ENOUGH_GUILD_LEVEL:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_GUILD_LEVEL"));
+			break;
+
+		case SHOP_SUBHEADER_GC_NOT_ENOUGH_MEDAL_OF_HONOR:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_MEDAL_OF_HONOR"));
+			break;
+
+		case SHOP_SUBHEADER_GC_NOT_ENOUGH_BNW:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_BNW"));
+			break;
+
+#if defined(ENABLE_SHOPEX_RENEWAL)
+		case SHOP_SUBHEADER_GC_NOT_ENOUGH_ITEM:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_ITEM"));
+			break;
+#endif
+
+		default:
+			TraceError("CPythonNetworkStream::RecvShopPacket: Unknown subheader\n");
+			break;
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvExchangePacket()
+{
+	TPacketGCExchange exchange_packet;
+
+	if (!Recv(sizeof(exchange_packet), &exchange_packet))
+		return false;
+
+	switch (exchange_packet.subheader)
+	{
+		case EXCHANGE_SUBHEADER_GC_START:
+		{
+			CPythonExchange::Instance().Clear();
+			CPythonExchange::Instance().Start();
+			CPythonExchange::Instance().SetSelfName(CPythonPlayer::Instance().GetName());
+
+			{
+				CInstanceBase* pCharacterInstance = CPythonCharacterManager::Instance().GetInstancePtr(exchange_packet.arg1);
+
+				if (pCharacterInstance)
+				{
+					CPythonExchange::Instance().SetTargetName(pCharacterInstance->GetNameString());
+					CPythonExchange::Instance().SetLevelToTarget(pCharacterInstance->GetLevel());
+				}
+			}
+
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartExchange", Py_BuildValue("()"));
+		}
+		break;
+
+		case EXCHANGE_SUBHEADER_GC_ITEM_ADD:
+		{
+			if (exchange_packet.is_me)
+			{
+				int iSlotIndex = exchange_packet.arg2.cell;
+				CPythonExchange::Instance().SetItemToSelf(iSlotIndex, exchange_packet.arg1, (WORD)exchange_packet.arg3);
+
+				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_SOCKET_SLOT_MAX_NUM; ++bSlotIdx)
+					CPythonExchange::Instance().SetItemMetinSocketToSelf(iSlotIndex, bSlotIdx, exchange_packet.alValues[bSlotIdx]);
+
+				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++bSlotIdx)
+					CPythonExchange::Instance().SetItemAttributeToSelf(iSlotIndex, bSlotIdx,
+						exchange_packet.aAttr[bSlotIdx].wType, exchange_packet.aAttr[bSlotIdx].lValue);
+
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+				CPythonExchange::Instance().SetItemChangeLookVnumToSelf(iSlotIndex, exchange_packet.dwTransmutationVnum);
+#endif
+
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+				CPythonExchange::Instance().SetItemRefineElementToSelf(iSlotIndex, exchange_packet.RefineElement);
+#endif
+
+#if defined(ENABLE_APPLY_RANDOM)
+				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_APPLY_RANDOM_SLOT_MAX_NUM; ++bSlotIdx)
+					CPythonExchange::Instance().SetItemApplyRandomToSelf(iSlotIndex, bSlotIdx,
+						exchange_packet.aApplyRandom[bSlotIdx].wType, exchange_packet.aApplyRandom[bSlotIdx].lValue);
+#endif
+
+#if defined(ENABLE_SET_ITEM)
+				CPythonExchange::Instance().SetItemSetValueToSelf(iSlotIndex, exchange_packet.bSetValue);
+#endif
+
+#if defined(WJ_ENABLE_TRADABLE_ICON)
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AddExchangeItemSlotIndex", Py_BuildValue("(i)", exchange_packet.arg4.cell));
+#endif
+			}
+			else
+			{
+				int iSlotIndex = exchange_packet.arg2.cell;
+				CPythonExchange::Instance().SetItemToTarget(iSlotIndex, exchange_packet.arg1, (WORD)exchange_packet.arg3);
+
+				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_SOCKET_SLOT_MAX_NUM; ++bSlotIdx)
+					CPythonExchange::Instance().SetItemMetinSocketToTarget(iSlotIndex, bSlotIdx, exchange_packet.alValues[bSlotIdx]);
+
+				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++bSlotIdx)
+					CPythonExchange::Instance().SetItemAttributeToTarget(iSlotIndex, bSlotIdx,
+						exchange_packet.aAttr[bSlotIdx].wType, exchange_packet.aAttr[bSlotIdx].lValue);
+
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+				CPythonExchange::Instance().SetItemChangeLookVnumToTarget(iSlotIndex, exchange_packet.dwTransmutationVnum);
+#endif
+
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+				CPythonExchange::Instance().SetItemRefineElementToTarget(iSlotIndex, exchange_packet.RefineElement);
+#endif
+
+#if defined(ENABLE_APPLY_RANDOM)
+				for (BYTE bSlotIdx = 0; bSlotIdx < ITEM_APPLY_RANDOM_SLOT_MAX_NUM; ++bSlotIdx)
+					CPythonExchange::Instance().SetItemApplyRandomToTarget(iSlotIndex, bSlotIdx,
+						exchange_packet.aApplyRandom[bSlotIdx].wType, exchange_packet.aApplyRandom[bSlotIdx].lValue);
+#endif
+
+#if defined(ENABLE_SET_ITEM)
+				CPythonExchange::Instance().SetItemSetValueToTarget(iSlotIndex, exchange_packet.bSetValue);
+#endif
+			}
+
+			__RefreshExchangeWindow();
+			__RefreshInventoryWindow();
+		}
+		break;
+
+		case EXCHANGE_SUBHEADER_GC_ITEM_DEL:
+		{
+			if (exchange_packet.is_me)
+			{
+				CPythonExchange::Instance().DelItemOfSelf((WORD)exchange_packet.arg1);
+			}
+			else
+			{
+				CPythonExchange::Instance().DelItemOfTarget((WORD)exchange_packet.arg1);
+			}
+			__RefreshExchangeWindow();
+			__RefreshInventoryWindow();
+		}
+		break;
+
+		case EXCHANGE_SUBHEADER_GC_ELK_ADD:
+		{
+			if (exchange_packet.is_me)
+				CPythonExchange::Instance().SetElkToSelf(exchange_packet.arg1);
+			else
+				CPythonExchange::Instance().SetElkToTarget(exchange_packet.arg1);
+
+			__RefreshExchangeWindow();
+		}
+		break;
+
+#if defined(ENABLE_CHEQUE_SYSTEM)
+		case EXCHANGE_SUBHEADER_GC_CHEQUE_ADD:
+		{
+			if (exchange_packet.is_me)
+				CPythonExchange::Instance().SetChequeToSelf(exchange_packet.arg1);
+			else
+				CPythonExchange::Instance().SetChequeToTarget(exchange_packet.arg1);
+
+			__RefreshExchangeWindow();
+		}
+		break;
+#endif
+
+		case EXCHANGE_SUBHEADER_GC_ACCEPT:
+		{
+			if (exchange_packet.is_me)
+			{
+				CPythonExchange::Instance().SetAcceptToSelf((BYTE)exchange_packet.arg1);
+			}
+			else
+			{
+				CPythonExchange::Instance().SetAcceptToTarget((BYTE)exchange_packet.arg1);
+			}
+			__RefreshExchangeWindow();
+		}
+		break;
+
+		case EXCHANGE_SUBHEADER_GC_END:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "EndExchange", Py_BuildValue("()"));
+			__RefreshInventoryWindow();
+			CPythonExchange::Instance().End();
+#ifdef ENABLE_GROWTH_PET_SYSTEM
+			CPythonPlayer::Instance().ClearPetExchangeData();
+#endif
+		}
+		break;
+
+		case EXCHANGE_SUBHEADER_GC_ALREADY:
+			Tracef("trade_already");
+			break;
+
+		case EXCHANGE_SUBHEADER_GC_LESS_ELK:
+			Tracef("trade_less_elk");
+			break;
+	};
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvQuestInfoPacket()
+{
+	TPacketGCQuestInfo QuestInfo;
+
+	if (!Peek(sizeof(TPacketGCQuestInfo), &QuestInfo))
+	{
+		Tracen("Recv Quest Info Packet Error #1");
+		return false;
+	}
+
+	if (!Peek(QuestInfo.size))
+	{
+		Tracen("Recv Quest Info Packet Error #2");
+		return false;
+	}
+
+	Recv(sizeof(TPacketGCQuestInfo));
+
+	const BYTE& c_rFlag = QuestInfo.flag;
+
+	enum
+	{
+		QUEST_PACKET_TYPE_NONE,
+		QUEST_PACKET_TYPE_BEGIN,
+		QUEST_PACKET_TYPE_UPDATE,
+		QUEST_PACKET_TYPE_END,
+	};
+
+	enum EQuestLen
+	{
+#if defined(ENABLE_QUEST_RENEWAL)
+		QUEST_TITLE_NAME_LEN = 50,
+#else
+		QUEST_TITLE_NAME_LEN = 30,
+#endif
+		QUEST_CLOCK_NAME_LEN = 16,
+		QUEST_COUNTER_NAME_LEN = 16,
+		QUEST_ICON_FILE_NAME_LEN = 24,
+	};
+
+	BYTE byQuestPacketType = QUEST_PACKET_TYPE_NONE;
+
+	if (0 != (c_rFlag & QUEST_SEND_IS_BEGIN))
+	{
+		BYTE isBegin;
+		if (!Recv(sizeof(isBegin), &isBegin))
+			return false;
+
+		if (isBegin)
+			byQuestPacketType = QUEST_PACKET_TYPE_BEGIN;
+		else
+			byQuestPacketType = QUEST_PACKET_TYPE_END;
+	}
+	else
+	{
+		byQuestPacketType = QUEST_PACKET_TYPE_UPDATE;
+	}
+
+	// Recv Data Start
+	char szTitle[QUEST_TITLE_NAME_LEN + 1] = "";
+	char szClockName[QUEST_CLOCK_NAME_LEN + 1] = "";
+	int iClockValue = 0;
+	char szCounterName[QUEST_COUNTER_NAME_LEN + 1] = "";
+	int iCounterValue = 0;
+	char szIconFileName[QUEST_ICON_FILE_NAME_LEN + 1] = "";
+
+	if (0 != (c_rFlag & QUEST_SEND_TITLE))
+	{
+		if (!Recv(sizeof(szTitle), &szTitle))
+			return false;
+
+		szTitle[QUEST_TITLE_NAME_LEN] = '\0';
+#if defined(ENABLE_LOCALE_CLIENT)
+		CPythonLocale::Instance().FormatString(szTitle, sizeof(szTitle));
+#endif
+	}
+
+	if (0 != (c_rFlag & QUEST_SEND_CLOCK_NAME))
+	{
+		if (!Recv(sizeof(szClockName), &szClockName))
+			return false;
+
+		szClockName[QUEST_CLOCK_NAME_LEN] = '\0';
+#if defined(ENABLE_LOCALE_CLIENT)
+		CPythonLocale::Instance().FormatString(szClockName, sizeof(szClockName));
+#endif
+	}
+
+	if (0 != (c_rFlag & QUEST_SEND_CLOCK_VALUE))
+	{
+		if (!Recv(sizeof(iClockValue), &iClockValue))
+			return false;
+	}
+
+	if (0 != (c_rFlag & QUEST_SEND_COUNTER_NAME))
+	{
+		if (!Recv(sizeof(szCounterName), &szCounterName))
+			return false;
+
+		szCounterName[QUEST_COUNTER_NAME_LEN] = '\0';
+#if defined(ENABLE_LOCALE_CLIENT)
+		CPythonLocale::Instance().FormatString(szCounterName, sizeof(szCounterName));
+#endif
+	}
+
+	if (0 != (c_rFlag & QUEST_SEND_COUNTER_VALUE))
+	{
+		if (!Recv(sizeof(iCounterValue), &iCounterValue))
+			return false;
+	}
+
+	if (0 != (c_rFlag & QUEST_SEND_ICON_FILE))
+	{
+		if (!Recv(sizeof(szIconFileName), &szIconFileName))
+			return false;
+
+		szIconFileName[QUEST_ICON_FILE_NAME_LEN] = '\0';
+	}
+	// Recv Data End
+
+	CPythonQuest& rkQuest = CPythonQuest::Instance();
+
+	// Process Start
+	if (QUEST_PACKET_TYPE_END == byQuestPacketType)
+	{
+		rkQuest.DeleteQuestInstance(QuestInfo.index);
+#if defined(ENABLE_QUEST_RENEWAL)
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "DeleteQuest", Py_BuildValue("(ii)", QuestInfo.type, QuestInfo.index));
+#endif
+	}
+	else if (QUEST_PACKET_TYPE_UPDATE == byQuestPacketType)
+	{
+		if (!rkQuest.IsQuest(QuestInfo.index))
+		{
+#if defined(ENABLE_QUEST_RENEWAL)
+			rkQuest.MakeQuest(QuestInfo.index, QuestInfo.type, QuestInfo.is_confirmed);
+#else
+			rkQuest.MakeQuest(QuestInfo.index);
+#endif
+		}
+
+		if (strlen(szTitle) > 0)
+			rkQuest.SetQuestTitle(QuestInfo.index, szTitle);
+		if (strlen(szClockName) > 0)
+			rkQuest.SetQuestClockName(QuestInfo.index, szClockName);
+		if (strlen(szCounterName) > 0)
+			rkQuest.SetQuestCounterName(QuestInfo.index, szCounterName);
+		if (strlen(szIconFileName) > 0)
+			rkQuest.SetQuestIconFileName(QuestInfo.index, szIconFileName);
+
+		if (c_rFlag & QUEST_SEND_CLOCK_VALUE)
+			rkQuest.SetQuestClockValue(QuestInfo.index, iClockValue);
+		if (c_rFlag & QUEST_SEND_COUNTER_VALUE)
+			rkQuest.SetQuestCounterValue(QuestInfo.index, iCounterValue);
+
+#if defined(ENABLE_QUEST_RENEWAL)
+		rkQuest.SetQuestIsConfirmed(QuestInfo.index, QuestInfo.is_confirmed);
+#endif
+	}
+	else if (QUEST_PACKET_TYPE_BEGIN == byQuestPacketType)
+	{
+		CPythonQuest::SQuestInstance QuestInstance;
+		QuestInstance.dwIndex = QuestInfo.index;
+		QuestInstance.strTitle = szTitle;
+		QuestInstance.strClockName = szClockName;
+		QuestInstance.iClockValue = iClockValue;
+		QuestInstance.strCounterName = szCounterName;
+		QuestInstance.iCounterValue = iCounterValue;
+		QuestInstance.strIconFileName = szIconFileName;
+		//CPythonQuest::Instance().RegisterQuestInstance(QuestInstance);
+		rkQuest.RegisterQuestInstance(QuestInstance);
+	}
+	// Process Start End
+
+#if defined(ENABLE_QUEST_RENEWAL)
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshQuest", Py_BuildValue("(ii)", QuestInfo.type, QuestInfo.index));
+#else
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshQuest", Py_BuildValue("()"));
+#endif
+	return true;
+}
+
+bool CPythonNetworkStream::RecvQuestConfirmPacket()
+{
+	TPacketGCQuestConfirm kQuestConfirmPacket;
+	if (!Recv(sizeof(kQuestConfirmPacket), &kQuestConfirmPacket))
+	{
+		Tracen("RecvQuestConfirmPacket Error");
+		return false;
+	}
+
+#if defined(ENABLE_LOCALE_CLIENT)
+	CPythonLocale::Instance().FormatString(kQuestConfirmPacket.msg, sizeof(kQuestConfirmPacket.msg));
+#endif
+
+	PyObject* poArg = Py_BuildValue("(sii)", kQuestConfirmPacket.msg, kQuestConfirmPacket.timeout, kQuestConfirmPacket.requestPID);
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_OnQuestConfirm", poArg);
+	return true;
+}
+
+bool CPythonNetworkStream::RecvRequestMakeGuild()
+{
+	TPacketGCBlank blank;
+	if (!Recv(sizeof(blank), &blank))
+	{
+		Tracen("RecvRequestMakeGuild Packet Error");
+		return false;
+	}
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AskGuildName", Py_BuildValue("()"));
+
+	return true;
+}
+
+void CPythonNetworkStream::ToggleGameDebugInfo()
+{
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ToggleDebugInfo", Py_BuildValue("()"));
+}
+
+bool CPythonNetworkStream::SendExchangeStartPacket(DWORD vid)
+{
+	if (!__CanActMainInstance())
+		return true;
+
+	TPacketCGExchange	packet;
+
+	packet.header = HEADER_CG_EXCHANGE;
+	packet.subheader = EXCHANGE_SUBHEADER_CG_START;
+	packet.arg1 = vid;
+
+	if (!Send(sizeof(packet), &packet))
+	{
+		Tracef("send_trade_start_packet Error\n");
+		return false;
+	}
+
+	Tracef("send_trade_start_packet vid %d \n", vid);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendExchangeElkAddPacket(DWORD elk)
+{
+	if (!__CanActMainInstance())
+		return true;
+
+	TPacketCGExchange	packet;
+
+	packet.header = HEADER_CG_EXCHANGE;
+	packet.subheader = EXCHANGE_SUBHEADER_CG_ELK_ADD;
+	packet.arg1 = elk;
+
+	if (!Send(sizeof(packet), &packet))
+	{
+		Tracef("send_trade_elk_add_packet Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+#if defined(ENABLE_CHEQUE_SYSTEM)
+bool CPythonNetworkStream::SendExchangeChequeAddPacket(DWORD cheque)
+{
+	if (!__CanActMainInstance())
+		return true;
+
+	TPacketCGExchange	packet;
+
+	packet.header = HEADER_CG_EXCHANGE;
+	packet.subheader = EXCHANGE_SUBHEADER_CG_CHEQUE_ADD;
+	packet.arg1 = cheque;
+
+	if (!Send(sizeof(packet), &packet))
+	{
+		Tracef("send_trade_cheque_add_packet Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+#endif
+
+bool CPythonNetworkStream::SendExchangeItemAddPacket(TItemPos ItemPos, BYTE byDisplayPos)
+{
+	if (!__CanActMainInstance())
+		return true;
+
+	TPacketCGExchange	packet;
+
+	packet.header = HEADER_CG_EXCHANGE;
+	packet.subheader = EXCHANGE_SUBHEADER_CG_ITEM_ADD;
+	packet.Pos = ItemPos;
+	packet.arg2 = byDisplayPos;
+
+	if (!Send(sizeof(packet), &packet))
+	{
+		Tracef("send_trade_item_add_packet Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendExchangeItemDelPacket(BYTE pos)
+{
+	assert(!"Can't be called function - CPythonNetworkStream::SendExchangeItemDelPacket");
+	return true;
+
+	if (!__CanActMainInstance())
+		return true;
+
+	TPacketCGExchange	packet;
+
+	packet.header = HEADER_CG_EXCHANGE;
+	packet.subheader = EXCHANGE_SUBHEADER_CG_ITEM_DEL;
+	packet.arg1 = pos;
+
+	if (!Send(sizeof(packet), &packet))
+	{
+		Tracef("send_trade_item_del_packet Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendExchangeAcceptPacket()
+{
+	if (!__CanActMainInstance())
+		return true;
+
+	TPacketCGExchange	packet;
+
+	packet.header = HEADER_CG_EXCHANGE;
+	packet.subheader = EXCHANGE_SUBHEADER_CG_ACCEPT;
+
+	if (!Send(sizeof(packet), &packet))
+	{
+		Tracef("send_trade_accept_packet Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendExchangeExitPacket()
+{
+	if (!__CanActMainInstance())
+		return true;
+
+	TPacketCGExchange	packet;
+
+	packet.header = HEADER_CG_EXCHANGE;
+	packet.subheader = EXCHANGE_SUBHEADER_CG_CANCEL;
+
+	if (!Send(sizeof(packet), &packet))
+	{
+		Tracef("send_trade_exit_packet Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+// PointReset Ó½
+bool CPythonNetworkStream::SendPointResetPacket()
+{
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartPointReset", Py_BuildValue("()"));
+	return true;
+}
+
+bool CPythonNetworkStream::__IsPlayerAttacking()
+{
+	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
+	CInstanceBase* pkInstMain = rkChrMgr.GetMainInstancePtr();
+
+	if (!pkInstMain)
+		return false;
+
+	if (!pkInstMain->IsAttacking())
+		return false;
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvScriptPacket()
+{
+	TPacketGCScript ScriptPacket;
+
+	if (!Recv(sizeof(TPacketGCScript), &ScriptPacket))
+	{
+		TraceError("RecvScriptPacket_RecvError");
+		return false;
+	}
+
+	if (ScriptPacket.size < sizeof(TPacketGCScript))
+	{
+		TraceError("RecvScriptPacket_SizeError");
+		return false;
+	}
+
+	ScriptPacket.size -= sizeof(TPacketGCScript);
+
+	static std::string str;
+	str = "";
+	str.resize(ScriptPacket.size + 1);
+
+	if (!Recv(ScriptPacket.size, &str[0]))
+		return false;
+
+	str[str.size() - 1] = '\0';
+#if defined(ENABLE_LOCALE_CLIENT)
+	CPythonLocale::Instance().FormatString(str);
+#endif
+
+	int iIndex = CPythonEventManager::Instance().RegisterEventSetFromString(str);
+
+	if (-1 != iIndex)
+	{
+		CPythonEventManager::Instance().SetVisibleLineCount(iIndex, CPythonEventManager::QUEST_VISIBLE_LINE_COUNT);
+		CPythonNetworkStream::Instance().OnScriptEventStart(ScriptPacket.skin, iIndex);
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendScriptAnswerPacket(int iAnswer)
+{
+	TPacketCGScriptAnswer ScriptAnswer;
+
+	ScriptAnswer.header = HEADER_CG_SCRIPT_ANSWER;
+	ScriptAnswer.answer = (BYTE)iAnswer;
+	if (!Send(sizeof(TPacketCGScriptAnswer), &ScriptAnswer))
+	{
+		Tracen("Send Script Answer Packet Error");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendScriptButtonPacket(unsigned int iIndex)
+{
+	TPacketCGScriptButton ScriptButton;
+
+	ScriptButton.header = HEADER_CG_SCRIPT_BUTTON;
+	ScriptButton.idx = iIndex;
+	if (!Send(sizeof(TPacketCGScriptButton), &ScriptButton))
+	{
+		Tracen("Send Script Button Packet Error");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendAnswerMakeGuildPacket(const char* c_szName)
+{
+	TPacketCGAnswerMakeGuild Packet;
+
+	Packet.header = HEADER_CG_ANSWER_MAKE_GUILD;
+	strncpy(Packet.guild_name, c_szName, GUILD_NAME_MAX_LEN);
+	Packet.guild_name[GUILD_NAME_MAX_LEN] = '\0';
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracen("SendAnswerMakeGuild Packet Error");
+		return false;
+	}
+
+	//Tracef("SendAnswerMakeGuildPacket : %s", c_szName);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendQuestInputStringPacket(const char* c_szString)
+{
+	TPacketCGQuestInputString Packet;
+	Packet.bHeader = HEADER_CG_QUEST_INPUT_STRING;
+	strncpy(Packet.szString, c_szString, QUEST_INPUT_STRING_MAX_NUM);
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracen("SendQuestInputStringPacket Error");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+#if defined(ENABLE_OX_RENEWAL)
+bool CPythonNetworkStream::SendQuestInputStringLongPacket(const char* c_szString)
+{
+	TPacketCGQuestInputLongString Packet;
+	Packet.bHeader = HEADER_CG_QUEST_INPUT_LONG_STRING;
+	strncpy(Packet.szString, c_szString, QUEST_INPUT_LONG_STRING_MAX_NUM);
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracen("SendQuestInputLongStringPacket Error");
+		return false;
+	}
+
+	return SendSequence();
+}
+#endif
+
+bool CPythonNetworkStream::SendQuestConfirmPacket(BYTE byAnswer, DWORD dwPID)
+{
+	TPacketCGQuestConfirm kPacket;
+	kPacket.header = HEADER_CG_QUEST_CONFIRM;
+	kPacket.answer = byAnswer;
+	kPacket.requestPID = dwPID;
+
+	if (!Send(sizeof(kPacket), &kPacket))
+	{
+		Tracen("SendQuestConfirmPacket Error");
+		return false;
+	}
+
+	Tracenf("SendQuestConfirmPacket : %d, %d", byAnswer, dwPID);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvSkillLevel()
+{
+	assert(!"CPythonNetworkStream::RecvSkillLevel -  Ê´ Ô¼");
+	TPacketGCSkillLevel packet;
+	if (!Recv(sizeof(TPacketGCSkillLevel), &packet))
+	{
+		Tracen("CPythonNetworkStream::RecvSkillLevel - RecvError");
+		return false;
+	}
+
+	DWORD dwSlotIndex;
+
+	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
+	for (int i = 0; i < SKILL_MAX_NUM; ++i)
+	{
+		if (rkPlayer.GetSkillSlotIndex(i, &dwSlotIndex))
+			rkPlayer.SetSkillLevel(dwSlotIndex, packet.abSkillLevels[i]);
+	}
+
+	__RefreshSkillWindow();
+	__RefreshStatus();
+	Tracef(" >> RecvSkillLevel\n");
+	return true;
+}
+
+bool CPythonNetworkStream::RecvSkillLevelNew()
+{
+	TPacketGCSkillLevelNew packet;
+
+	if (!Recv(sizeof(TPacketGCSkillLevelNew), &packet))
+	{
+		Tracen("CPythonNetworkStream::RecvSkillLevelNew - RecvError");
+		return false;
+	}
+
+	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
+
+	rkPlayer.SetSkill(7, 0);
+	rkPlayer.SetSkill(8, 0);
+#if defined(ENABLE_CONQUEROR_LEVEL)
+	if (!rkPlayer.GetStatus(POINT_CONQUEROR_LEVEL))
+		rkPlayer.SetSkill(9, 0);
+#endif
+
+	for (int i = 0; i < SKILL_MAX_NUM; ++i)
+	{
+		const TPlayerSkill& rPlayerSkill = packet.skills[i];
+
+		if (i >= 112 && i <= 115 && rPlayerSkill.bLevel)
+			rkPlayer.SetSkill(7, i);
+
+		if (i >= 116 && i <= 119 && rPlayerSkill.bLevel)
+			rkPlayer.SetSkill(8, i);
+
+#if defined(ENABLE_678TH_SKILL)
+		if (i >= 221 && i <= 229 && rPlayerSkill.bLevel)
+			rkPlayer.SetSkill(7, i);
+
+		if (i >= 236 && i <= 244 && rPlayerSkill.bLevel)
+			rkPlayer.SetSkill(8, i);
+#endif
+
+		rkPlayer.SetSkillLevel_(i, rPlayerSkill.bMasterType, rPlayerSkill.bLevel);
+	}
+
+	__RefreshSkillWindow();
+	__RefreshStatus();
+	//Tracef(" >> RecvSkillLevelNew\n");
+	return true;
+}
+
+bool CPythonNetworkStream::RecvDamageInfoPacket()
+{
+	TPacketGCDamageInfo DamageInfoPacket;
+
+	if (!Recv(sizeof(TPacketGCDamageInfo), &DamageInfoPacket))
+	{
+		Tracen("Recv Target Packet Error");
+		return false;
+	}
+
+	CInstanceBase* pInstTarget = CPythonCharacterManager::Instance().GetInstancePtr(DamageInfoPacket.dwVID);
+	bool bSelf = (pInstTarget == CPythonCharacterManager::Instance().GetMainInstancePtr());
+	bool bTarget = (pInstTarget == m_pInstTarget);
+	if (pInstTarget)
+	{
+		if (DamageInfoPacket.damage >= 0)
+			pInstTarget->AddDamageEffect(DamageInfoPacket.damage, DamageInfoPacket.flag, bSelf, bTarget);
+		else
+			TraceError("Damage is equal or below 0.");
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvTargetPacket()
+{
+	TPacketGCTarget TargetPacket;
+
+	if (!Recv(sizeof(TPacketGCTarget), &TargetPacket))
+	{
+		Tracen("Recv Target Packet Error");
+		return false;
+	}
+
+#if defined(ENABLE_DEFENSE_WAVE)
+	if (TargetPacket.bAlliance)
+	{
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetHPAllianceTargetBoard",
+			Py_BuildValue("(iii)", TargetPacket.dwVID, TargetPacket.iMinHP, TargetPacket.iMaxHP));
+		return true;
+	}
+#endif
+
+	CInstanceBase* pInstPlayer = CPythonCharacterManager::Instance().GetMainInstancePtr();
+	CInstanceBase* pInstTarget = CPythonCharacterManager::Instance().GetInstancePtr(TargetPacket.dwVID);
+	if (pInstPlayer && pInstTarget)
+	{
+		if (!pInstTarget->IsDead())
+		{
+#if defined(ENABLE_VIEW_TARGET_PLAYER_HP)
+			if (pInstTarget->IsBuilding())
+#else
+			if (pInstTarget->IsPC() || pInstTarget->IsBuilding())
+#endif
+			{
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoardIfDifferent", Py_BuildValue("(i)", TargetPacket.dwVID));
+			}
+			else if (pInstPlayer->CanViewTargetHP(*pInstTarget))
+			{
+#if defined(ENABLE_VIEW_TARGET_DECIMAL_HP)
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetHPTargetBoard", Py_BuildValue("(iiii)", TargetPacket.dwVID, TargetPacket.bHPPercent, TargetPacket.iMinHP, TargetPacket.iMaxHP));
+#else
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetHPTargetBoard", Py_BuildValue("(ii)", TargetPacket.dwVID, TargetPacket.bHPPercent));
+#endif
+
+#if defined(ENABLE_ELEMENT_ADD)
+				PyObject* poDict = PyDict_New();
+				for (BYTE bElementIndex = 0; bElementIndex < CPythonNonPlayer::MOB_ELEMENT_MAX_NUM; ++bElementIndex)
+				{
+					PyDict_SetItem(poDict,
+						Py_BuildValue("i", bElementIndex),
+						Py_BuildValue("i", TargetPacket.bElement[bElementIndex]));
+				}
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ShowTargetElementEnchant", Py_BuildValue("(O)", poDict));
+				Py_DECREF(poDict);
+#endif
+			}
+			else
+			{
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoard", Py_BuildValue("()"));
+			}
+
+			m_pInstTarget = pInstTarget;
+		}
+	}
+	else
+	{
+		CPythonPlayer::Instance().SetTarget(0);
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoard", Py_BuildValue("()"));
+	}
+
+	return true;
+}
+
+#if defined(ENABLE_SEND_TARGET_INFO)
+bool CPythonNetworkStream::RecvTargetInfoPacket()
+{
+	TPacketGCTargetInfo TargetInfoPacket;
+	if (!Recv(sizeof(TPacketGCTargetInfo), &TargetInfoPacket))
+	{
+		Tracen("Recv TargetInfo Packet Error");
+		return false;
+	}
+
+	CPythonNonPlayer::Instance().ClearItemDrop();
+
+	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(TargetInfoPacket.dwVID);
+	if (pInstance && (pInstance->IsEnemy() || pInstance->IsStone() && !pInstance->IsDead()))
+	{
+		UINT uiPacketSize = (TargetInfoPacket.wSize - sizeof(TPacketGCTargetInfo));
+		for (; uiPacketSize > 0; uiPacketSize -= sizeof(TPacketGCTargetDropInfo))
+		{
+			TPacketGCTargetDropInfo TargetDropInfoPacket;
+			if (!Recv(sizeof(TargetDropInfoPacket), &TargetDropInfoPacket))
+				return false;
+
+			CPythonNonPlayer::Instance().AddItemDrop(
+				TargetInfoPacket.dwRaceVnum,
+				TargetDropInfoPacket.dwVnum,
+				TargetDropInfoPacket.bCount
+			);
+		}
+
+		CPythonNonPlayer::Instance().SetDropMetinStone(TargetInfoPacket.bDropMetinStone);
+	}
+	else
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoard", Py_BuildValue("()"));
+
+	return true;
+}
+#endif
+
+bool CPythonNetworkStream::RecvMountPacket()
+{
+	TPacketGCMount MountPacket;
+
+	if (!Recv(sizeof(TPacketGCMount), &MountPacket))
+	{
+		Tracen("Recv Mount Packet Error");
+		return false;
+	}
+
+	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(MountPacket.vid);
+
+	if (pInstance)
+	{
+		// Mount
+		if (0 != MountPacket.mount_vid)
+		{
+			//pInstance->Ride(MountPacket.pos, MountPacket.mount_vid);
+		}
+		// Unmount
+		else
+		{
+			//pInstance->Unride(MountPacket.pos, MountPacket.x, MountPacket.y);
+		}
+	}
+
+	if (CPythonPlayer::Instance().IsMainCharacterIndex(MountPacket.vid))
+	{
+		//CPythonPlayer::Instance().SetRidingVehicleIndex(MountPacket.mount_vid);
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvChangeSpeedPacket()
+{
+	TPacketGCChangeSpeed SpeedPacket;
+
+	if (!Recv(sizeof(TPacketGCChangeSpeed), &SpeedPacket))
+	{
+		Tracen("Recv Speed Packet Error");
+		return false;
+	}
+
+	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(SpeedPacket.vid);
+
+	if (!pInstance)
+		return true;
+
+	//pInstance->SetWalkSpeed(SpeedPacket.walking_speed);
+	//pInstance->SetRunSpeed(SpeedPacket.running_speed);
+	return true;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////////////
+// Recv
+bool CPythonNetworkStream::SendAttackPacket(UINT uMotAttack, DWORD dwVIDVictim)
+{
+	if (!__CanActMainInstance())
+		return true;
+
+#ifdef ATTACK_TIME_LOG
+	static DWORD prevTime = timeGetTime();
+	DWORD curTime = timeGetTime();
+	TraceError("TIME: %.4f(%.4f) ATTACK_PACKET: %d TARGET: %d", curTime / 1000.0f, (curTime - prevTime) / 1000.0f, uMotAttack, dwVIDVictim);
+	prevTime = curTime;
+#endif
+
+	TPacketCGAttack kPacketAtk;
+	kPacketAtk.header = HEADER_CG_ATTACK;
+	kPacketAtk.bType = uMotAttack;
+	kPacketAtk.dwVictimVID = dwVIDVictim;
+
+	if (!SendSpecial(sizeof(kPacketAtk), &kPacketAtk))
+	{
+		Tracen("Send Battle Attack Packet Error");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendSpecial(int nLen, void* pvBuf)
+{
+	BYTE bHeader = *(BYTE*)pvBuf;
+
+	switch (bHeader)
+	{
+		case HEADER_CG_ATTACK:
+		{
+			TPacketCGAttack* pkPacketAtk = (TPacketCGAttack*)pvBuf;
+			pkPacketAtk->bCRCMagicCubeProcPiece = GetProcessCRCMagicCubePiece();
+			pkPacketAtk->bCRCMagicCubeFilePiece = GetProcessCRCMagicCubePiece();
+			return Send(nLen, pvBuf);
+		}
+		break;
+	}
+
+	return Send(nLen, pvBuf);
+}
+
+bool CPythonNetworkStream::RecvAddFlyTargetingPacket()
+{
+	TPacketGCFlyTargeting kPacket;
+	if (!Recv(sizeof(kPacket), &kPacket))
+		return false;
+
+	__GlobalPositionToLocalPosition(kPacket.lX, kPacket.lY);
+
+	Tracef("VID [%d] Å¸ ß° \n", kPacket.dwShooterVID);
+
+	CPythonCharacterManager& rpcm = CPythonCharacterManager::Instance();
+
+	CInstanceBase* pShooter = rpcm.GetInstancePtr(kPacket.dwShooterVID);
+
+	if (!pShooter)
+	{
+#ifndef _DEBUG
+		TraceError("CPythonNetworkStream::RecvFlyTargetingPacket() - dwShooterVID[%d] NOT EXIST", kPacket.dwShooterVID);
+#endif
+		return true;
+	}
+
+	CInstanceBase* pTarget = rpcm.GetInstancePtr(kPacket.dwTargetVID);
+
+	if (kPacket.dwTargetVID && pTarget)
+	{
+		pShooter->GetGraphicThingInstancePtr()->AddFlyTarget(pTarget->GetGraphicThingInstancePtr());
+	}
+	else
+	{
+		float h = CPythonBackground::Instance().GetHeight(kPacket.lX, kPacket.lY) + 60.0f; // TEMPORARY HEIGHT
+		pShooter->GetGraphicThingInstancePtr()->AddFlyTarget(D3DXVECTOR3(kPacket.lX, kPacket.lY, h));
+		//pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(kPacket.kPPosTarget.x,kPacket.kPPosTarget.y,);
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvFlyTargetingPacket()
+{
+	TPacketGCFlyTargeting kPacket;
+	if (!Recv(sizeof(kPacket), &kPacket))
+		return false;
+
+	__GlobalPositionToLocalPosition(kPacket.lX, kPacket.lY);
+
+	//Tracef("CPythonNetworkStream::RecvFlyTargetingPacket - VID [%d]\n",kPacket.dwShooterVID);
+
+	CPythonCharacterManager& rpcm = CPythonCharacterManager::Instance();
+
+	CInstanceBase* pShooter = rpcm.GetInstancePtr(kPacket.dwShooterVID);
+
+	if (!pShooter)
+	{
+#ifdef _DEBUG
+		TraceError("CPythonNetworkStream::RecvFlyTargetingPacket() - dwShooterVID[%d] NOT EXIST", kPacket.dwShooterVID);
+#endif
+		return true;
+	}
+
+	CInstanceBase* pTarget = rpcm.GetInstancePtr(kPacket.dwTargetVID);
+
+	if (kPacket.dwTargetVID && pTarget)
+	{
+		pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(pTarget->GetGraphicThingInstancePtr());
+	}
+	else
+	{
+		float h = CPythonBackground::Instance().GetHeight(kPacket.lX, kPacket.lY) + 60.0f; // TEMPORARY HEIGHT
+		pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(D3DXVECTOR3(kPacket.lX, kPacket.lY, h));
+		//pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(kPacket.kPPosTarget.x,kPacket.kPPosTarget.y,);
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendShootPacket(UINT uSkill)
+{
+	TPacketCGShoot kPacketShoot;
+	kPacketShoot.bHeader = HEADER_CG_SHOOT;
+	kPacketShoot.bType = uSkill;
+
+	if (!Send(sizeof(kPacketShoot), &kPacketShoot))
+	{
+		Tracen("SendShootPacket Error");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendAddFlyTargetingPacket(DWORD dwTargetVID, const TPixelPosition& kPPosTarget)
+{
+	TPacketCGFlyTargeting packet;
+
+	//CPythonCharacterManager & rpcm = CPythonCharacterManager::Instance();
+
+	packet.bHeader = HEADER_CG_ADD_FLY_TARGETING;
+	packet.dwTargetVID = dwTargetVID;
+	packet.lX = kPPosTarget.x;
+	packet.lY = kPPosTarget.y;
+
+	__LocalPositionToGlobalPosition(packet.lX, packet.lY);
+
+	if (!Send(sizeof(packet), &packet))
+	{
+		Tracen("Send FlyTargeting Packet Error");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendFlyTargetingPacket(DWORD dwTargetVID, const TPixelPosition& kPPosTarget)
+{
+	TPacketCGFlyTargeting packet;
+
+	//CPythonCharacterManager & rpcm = CPythonCharacterManager::Instance();
+
+	packet.bHeader = HEADER_CG_FLY_TARGETING;
+	packet.dwTargetVID = dwTargetVID;
+	packet.lX = kPPosTarget.x;
+	packet.lY = kPPosTarget.y;
+
+	__LocalPositionToGlobalPosition(packet.lX, packet.lY);
+
+	if (!Send(sizeof(packet), &packet))
+	{
+		Tracen("Send FlyTargeting Packet Error");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvCreateFlyPacket()
+{
+	TPacketGCCreateFly kPacket;
+	if (!Recv(sizeof(TPacketGCCreateFly), &kPacket))
+		return false;
+
+	CFlyingManager& rkFlyMgr = CFlyingManager::Instance();
+	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
+
+	CInstanceBase* pkStartInst = rkChrMgr.GetInstancePtr(kPacket.dwStartVID);
+	CInstanceBase* pkEndInst = rkChrMgr.GetInstancePtr(kPacket.dwEndVID);
+	if (!pkStartInst || !pkEndInst)
+		return true;
+
+	rkFlyMgr.CreateIndexedFly(kPacket.bType, pkStartInst->GetGraphicThingInstancePtr(), pkEndInst->GetGraphicThingInstancePtr());
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendTargetPacket(DWORD dwVID)
+{
+	TPacketCGTarget packet;
+	packet.header = HEADER_CG_TARGET;
+	packet.dwVID = dwVID;
+
+	if (!Send(sizeof(packet), &packet))
+	{
+		Tracen("Send Target Packet Error");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendSyncPositionElementPacket(DWORD dwVictimVID, DWORD dwVictimX, DWORD dwVictimY)
+{
+	TPacketCGSyncPositionElement kSyncPos;
+	kSyncPos.dwVID = dwVictimVID;
+	kSyncPos.lX = dwVictimX;
+	kSyncPos.lY = dwVictimY;
+
+	__LocalPositionToGlobalPosition(kSyncPos.lX, kSyncPos.lY);
+
+	if (!Send(sizeof(kSyncPos), &kSyncPos))
+	{
+		Tracen("CPythonNetworkStream::SendSyncPositionElementPacket - ERROR");
+		return false;
+	}
+
+	return true;
+}
+
+//////////////////////////////////////////////////////////////////////////
+// Messenger
+
+bool CPythonNetworkStream::SendMessengerAddByVIDPacket(const DWORD c_dwVID)
+{
+	TPacketCGMessenger Packet;
+	Packet.bHeader = HEADER_CG_MESSENGER;
+	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_ADD_BY_VID;
+	if (!Send(sizeof(Packet), &Packet))
+		return false;
+
+	if (!Send(sizeof(c_dwVID), &c_dwVID))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMessengerAddByNamePacket(const char* c_szName)
+{
+	TPacketCGMessenger Packet;
+	Packet.bHeader = HEADER_CG_MESSENGER;
+	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_ADD_BY_NAME;
+	if (!Send(sizeof(Packet), &Packet))
+		return false;
+
+	char szName[CHARACTER_NAME_MAX_LEN] = {};
+	strncpy(szName, c_szName, CHARACTER_NAME_MAX_LEN - 1);
+	szName[CHARACTER_NAME_MAX_LEN - 1] = '\0'; // #720: Þ½ Ì¸   Ã·Î¿  
+
+	if (!Send(sizeof(szName), &szName))
+		return false;
+
+	Tracef(" SendMessengerAddByNamePacket : %s\n", c_szName);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMessengerRemovePacket(const char* c_szKey, const char* c_szName)
+{
+	TPacketCGMessenger Packet;
+	Packet.bHeader = HEADER_CG_MESSENGER;
+	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_REMOVE;
+	if (!Send(sizeof(Packet), &Packet))
+		return false;
+
+	char szKey[CHARACTER_NAME_MAX_LEN] = {};
+	strncpy(szKey, c_szKey, CHARACTER_NAME_MAX_LEN - 1);
+	if (!Send(sizeof(szKey), &szKey))
+		return false;
+
+	__RefreshTargetBoardByName(c_szName);
+	return SendSequence();
+}
+
+#if defined(ENABLE_MESSENGER_BLOCK)
+bool CPythonNetworkStream::SendMessengerBlockAddByVIDPacket(const DWORD c_dwVID)
+{
+	TPacketCGMessenger Packet;
+	Packet.bHeader = HEADER_CG_MESSENGER;
+	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID;
+	if (!Send(sizeof(Packet), &Packet))
+		return false;
+
+	if (!Send(sizeof(c_dwVID), &c_dwVID))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMessengerBlockAddByNamePacket(const char* c_szName)
+{
+	TPacketCGMessenger Packet;
+	Packet.bHeader = HEADER_CG_MESSENGER;
+	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME;
+	if (!Send(sizeof(Packet), &Packet))
+		return false;
+
+	char szName[CHARACTER_NAME_MAX_LEN] = {};
+	strncpy(szName, c_szName, CHARACTER_NAME_MAX_LEN - 1);
+	szName[CHARACTER_NAME_MAX_LEN - 1] = '\0';
+
+	if (!Send(sizeof(szName), &szName))
+		return false;
+
+	Tracef(" SendMessengerBlockAddByNamePacket : %s\n", c_szName);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMessengerBlockRemovePacket(const char* c_szKey, const char* c_szName)
+{
+	TPacketCGMessenger Packet;
+	Packet.bHeader = HEADER_CG_MESSENGER;
+	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_BLOCK_REMOVE;
+	if (!Send(sizeof(Packet), &Packet))
+		return false;
+
+	char szKey[CHARACTER_NAME_MAX_LEN];
+	strncpy(szKey, c_szKey, CHARACTER_NAME_MAX_LEN - 1);
+	if (!Send(sizeof(szKey), &szKey))
+		return false;
+
+	CPythonMessenger::Instance().RemoveBlock(szKey);
+	__RefreshTargetBoardByName(c_szName);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMessengerBlockRemoveByVIDPacket(DWORD c_dwVID)
+{
+	TPacketCGMessenger Packet;
+	Packet.bHeader = HEADER_CG_MESSENGER;
+	Packet.bSubHeader = MESSENGER_SUBHEADER_CG_BLOCK_REMOVE;
+	if (!Send(sizeof(Packet), &Packet))
+		return false;
+
+	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(c_dwVID);
+
+	char szKey[CHARACTER_NAME_MAX_LEN];
+	strncpy(szKey, pInstance->GetNameString(), CHARACTER_NAME_MAX_LEN - 1);
+	if (!Send(sizeof(szKey), &szKey))
+		return false;
+
+	CPythonMessenger::Instance().RemoveBlock(szKey);
+	__RefreshTargetBoardByName(pInstance->GetNameString());
+	return SendSequence();
+}
+#endif
+
+bool CPythonNetworkStream::RecvMessenger()
+{
+	TPacketGCMessenger Packet;
+	if (!Recv(sizeof(Packet), &Packet))
+		return false;
+
+	if (Packet.wSize < sizeof(TPacketGCMessenger))
+		return false;
+
+	UINT uiPacketSize = (Packet.wSize - sizeof(TPacketGCMessenger));
+	if (uiPacketSize % sizeof(TPacketGCMessengerList) != 0)
+		return false;
+	for (; uiPacketSize > 0; uiPacketSize -= sizeof(TPacketGCMessengerList))
+	{
+		TPacketGCMessengerList ListPacket;
+		if (!Recv(sizeof(ListPacket), &ListPacket))
+			return false;
+
+		switch (Packet.bSubHeader)
+		{
+			case MESSENGER_SUBHEADER_GC_LIST:
+			{
+				if (ListPacket.bConnected & MESSENGER_CONNECTED_STATE_ONLINE)
+				{
+#if defined(ENABLE_MESSENGER_DETAILS)
+					CPythonMessenger::Instance().OnFriendLogin(ListPacket.szName
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+						, ListPacket.szCountry
+#endif
+					);
+#else
+					CPythonMessenger::Instance().OnFriendLogin(ListPacket.szName);
+#endif
+				}
+				else
+				{
+#if defined(ENABLE_MESSENGER_DETAILS)
+					CPythonMessenger::Instance().OnFriendLogout(ListPacket.szName, ListPacket.dwLastPlayTime
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+						, ListPacket.szCountry
+#endif
+					);
+#else
+					CPythonMessenger::Instance().OnFriendLogout(ListPacket.szName);
+#endif
+				}
+			}
+			break;
+
+			case MESSENGER_SUBHEADER_GC_LOGIN:
+			{
+#if defined(ENABLE_MESSENGER_DETAILS)
+				CPythonMessenger::Instance().OnFriendLogin(ListPacket.szName
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+					, ListPacket.szCountry
+#endif
+				);
+#else
+				CPythonMessenger::Instance().OnFriendLogin(ListPacket.szName);
+#endif
+				__RefreshTargetBoardByName(ListPacket.szName);
+			}
+			break;
+
+			case MESSENGER_SUBHEADER_GC_LOGOUT:
+#if defined(ENABLE_MESSENGER_DETAILS)
+				CPythonMessenger::Instance().OnFriendLogout(ListPacket.szName, ListPacket.dwLastPlayTime
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+					, ListPacket.szCountry
+#endif
+				);
+#else
+				CPythonMessenger::Instance().OnFriendLogout(ListPacket.szName);
+#endif
+				break;
+
+#if defined(ENABLE_MESSENGER_GM)
+			case MESSENGER_SUBHEADER_GC_GM_LIST:
+			{
+				if (ListPacket.bConnected & MESSENGER_CONNECTED_STATE_ONLINE)
+					CPythonMessenger::Instance().OnGMLogin(ListPacket.szName
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+						, ListPacket.szCountry
+#endif
+					);
+				else
+					CPythonMessenger::Instance().OnGMLogout(ListPacket.szName, ListPacket.dwLastPlayTime
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+						, ListPacket.szCountry
+#endif
+					);
+			}
+			break;
+
+			case MESSENGER_SUBHEADER_GC_GM_LOGIN:
+			{
+				CPythonMessenger::Instance().OnGMLogin(ListPacket.szName
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+					, ListPacket.szCountry
+#endif
+				);
+				__RefreshTargetBoardByName(ListPacket.szName);
+			}
+			break;
+
+			case MESSENGER_SUBHEADER_GC_GM_LOGOUT:
+				CPythonMessenger::Instance().OnGMLogout(ListPacket.szName, ListPacket.dwLastPlayTime
+#if defined(ENABLE_MULTI_LANGUAGE_SYSTEM)
+					, ListPacket.szCountry
+#endif
+				);
+				break;
+#endif
+
+#if defined(ENABLE_MESSENGER_BLOCK)
+			case MESSENGER_SUBHEADER_GC_BLOCK_LIST:
+			{
+				if (ListPacket.bConnected & MESSENGER_CONNECTED_STATE_ONLINE)
+					CPythonMessenger::Instance().OnBlockLogin(ListPacket.szName);
+				else
+					CPythonMessenger::Instance().OnBlockLogout(ListPacket.szName);
+			}
+			break;
+
+			case MESSENGER_SUBHEADER_GC_BLOCK_LOGIN:
+			{
+				CPythonMessenger::Instance().OnBlockLogin(ListPacket.szName);
+				__RefreshTargetBoardByName(ListPacket.szName);
+			}
+			break;
+
+			case MESSENGER_SUBHEADER_GC_BLOCK_LOGOUT:
+				CPythonMessenger::Instance().OnBlockLogout(ListPacket.szName);
+				break;
+#endif
+		}
+	}
+
+	return true;
+}
+
+//////////////////////////////////////////////////////////////////////////
+// Party
+
+bool CPythonNetworkStream::SendPartyInvitePacket(DWORD dwVID)
+{
+	TPacketCGPartyInvite kPartyInvitePacket;
+	kPartyInvitePacket.header = HEADER_CG_PARTY_INVITE;
+	kPartyInvitePacket.vid = dwVID;
+
+	if (!Send(sizeof(kPartyInvitePacket), &kPartyInvitePacket))
+	{
+		Tracenf("CPythonNetworkStream::SendPartyInvitePacket [%ud] - PACKET SEND ERROR", dwVID);
+		return false;
+	}
+
+	Tracef(" << SendPartyInvitePacket : %d\n", dwVID);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPartyInviteAnswerPacket(DWORD dwLeaderVID, BYTE byAnswer)
+{
+	TPacketCGPartyInviteAnswer kPartyInviteAnswerPacket;
+	kPartyInviteAnswerPacket.header = HEADER_CG_PARTY_INVITE_ANSWER;
+	kPartyInviteAnswerPacket.leader_pid = dwLeaderVID;
+	kPartyInviteAnswerPacket.accept = byAnswer;
+
+	if (!Send(sizeof(kPartyInviteAnswerPacket), &kPartyInviteAnswerPacket))
+	{
+		Tracenf("CPythonNetworkStream::SendPartyInviteAnswerPacket [%ud %ud] - PACKET SEND ERROR", dwLeaderVID, byAnswer);
+		return false;
+	}
+
+	Tracef(" << SendPartyInviteAnswerPacket : %d, %d\n", dwLeaderVID, byAnswer);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPartyRemovePacket(DWORD dwPID)
+{
+	TPacketCGPartyRemove kPartyInviteRemove;
+	kPartyInviteRemove.header = HEADER_CG_PARTY_REMOVE;
+	kPartyInviteRemove.pid = dwPID;
+
+	if (!Send(sizeof(kPartyInviteRemove), &kPartyInviteRemove))
+	{
+		Tracenf("CPythonNetworkStream::SendPartyRemovePacket [%ud] - PACKET SEND ERROR", dwPID);
+		return false;
+	}
+
+	Tracef(" << SendPartyRemovePacket : %d\n", dwPID);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPartySetStatePacket(DWORD dwVID, BYTE byState, BYTE byFlag)
+{
+	TPacketCGPartySetState kPartySetState;
+	kPartySetState.byHeader = HEADER_CG_PARTY_SET_STATE;
+	kPartySetState.dwVID = dwVID;
+	kPartySetState.byState = byState;
+	kPartySetState.byFlag = byFlag;
+
+	if (!Send(sizeof(kPartySetState), &kPartySetState))
+	{
+		Tracenf("CPythonNetworkStream::SendPartySetStatePacket(%ud, %ud) - PACKET SEND ERROR", dwVID, byState);
+		return false;
+	}
+
+	Tracef(" << SendPartySetStatePacket : %d, %d, %d\n", dwVID, byState, byFlag);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPartyUseSkillPacket(BYTE bySkillIndex, DWORD dwVID)
+{
+	TPacketCGPartyUseSkill kPartyUseSkill;
+	kPartyUseSkill.byHeader = HEADER_CG_PARTY_USE_SKILL;
+	kPartyUseSkill.bySkillIndex = bySkillIndex;
+	kPartyUseSkill.dwTargetVID = dwVID;
+
+	if (!Send(sizeof(kPartyUseSkill), &kPartyUseSkill))
+	{
+		Tracenf("CPythonNetworkStream::SendPartyUseSkillPacket(%ud, %ud) - PACKET SEND ERROR", bySkillIndex, dwVID);
+		return false;
+	}
+
+	Tracef(" << SendPartyUseSkillPacket : %d, %d\n", bySkillIndex, dwVID);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPartyParameterPacket(BYTE byDistributeMode)
+{
+	TPacketCGPartyParameter kPartyParameter;
+	kPartyParameter.bHeader = HEADER_CG_PARTY_PARAMETER;
+	kPartyParameter.bDistributeMode = byDistributeMode;
+
+	if (!Send(sizeof(kPartyParameter), &kPartyParameter))
+	{
+		Tracenf("CPythonNetworkStream::SendPartyParameterPacket(%d) - PACKET SEND ERROR", byDistributeMode);
+		return false;
+	}
+
+	Tracef(" << SendPartyParameterPacket : %d\n", byDistributeMode);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvPartyInvite()
+{
+	TPacketGCPartyInvite kPartyInvitePacket;
+	if (!Recv(sizeof(kPartyInvitePacket), &kPartyInvitePacket))
+		return false;
+
+	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(kPartyInvitePacket.leader_pid);
+	if (!pInstance)
+	{
+		TraceError(" CPythonNetworkStream::RecvPartyInvite - Failed to find leader instance [%d]\n", kPartyInvitePacket.leader_pid);
+		return true;
+	}
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RecvPartyInviteQuestion", Py_BuildValue("(is)", kPartyInvitePacket.leader_pid, pInstance->GetNameString()));
+	Tracef(" >> RecvPartyInvite : %d, %s\n", kPartyInvitePacket.leader_pid, pInstance->GetNameString());
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPartyAdd()
+{
+	TPacketGCPartyAdd kPartyAddPacket;
+	if (!Recv(sizeof(kPartyAddPacket), &kPartyAddPacket))
+		return false;
+
+	CPythonPlayer::Instance().AppendPartyMember(kPartyAddPacket.pid, kPartyAddPacket.name);
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AddPartyMember",
+		Py_BuildValue("(is"
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+			"i"
+#endif
+#if defined(ENABLE_PARTY_CHANNEL_FIX)
+			"i"
+#endif
+			")",
+			kPartyAddPacket.pid, kPartyAddPacket.name
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+			, kPartyAddPacket.mapIdx
+#endif
+#if defined(ENABLE_PARTY_CHANNEL_FIX)
+			, kPartyAddPacket.channel
+#endif
+		));
+
+	Tracef(" >> RecvPartyAdd : %d, %s"
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+		", %d"
+#endif
+#if defined(ENABLE_PARTY_CHANNEL_FIX)
+		", %d"
+#endif
+		"\n", kPartyAddPacket.pid, kPartyAddPacket.name
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+		, kPartyAddPacket.mapIdx
+#endif
+#if defined(ENABLE_PARTY_CHANNEL_FIX)
+		, kPartyAddPacket.channel
+#endif
+	);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPartyUpdate()
+{
+	TPacketGCPartyUpdate kPartyUpdatePacket;
+	if (!Recv(sizeof(kPartyUpdatePacket), &kPartyUpdatePacket))
+		return false;
+
+	CPythonPlayer::TPartyMemberInfo* pPartyMemberInfo;
+	if (!CPythonPlayer::Instance().GetPartyMemberPtr(kPartyUpdatePacket.pid, &pPartyMemberInfo))
+		return true;
+
+	BYTE byOldState = pPartyMemberInfo->byState;
+
+	CPythonPlayer::Instance().UpdatePartyMemberInfo(kPartyUpdatePacket.pid, kPartyUpdatePacket.state, kPartyUpdatePacket.percent_hp);
+	for (int i = 0; i < PARTY_AFFECT_SLOT_MAX_NUM; ++i)
+	{
+		CPythonPlayer::Instance().UpdatePartyMemberAffect(kPartyUpdatePacket.pid, i, kPartyUpdatePacket.affects[i]);
+	}
+
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+	if (kPartyUpdatePacket.x || kPartyUpdatePacket.y)
+		__GlobalPositionToLocalPosition(kPartyUpdatePacket.x, kPartyUpdatePacket.y);
+
+	CPythonPlayer::Instance().UpdatePartyMemberPosition(kPartyUpdatePacket.pid, kPartyUpdatePacket.x, kPartyUpdatePacket.y);
+#endif
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "UpdatePartyMemberInfo", Py_BuildValue("(i)", kPartyUpdatePacket.pid));
+
+	//   Ù²Ù¸, TargetBoard  Æ° Æ® Ñ´.
+	DWORD dwVID;
+	if (CPythonPlayer::Instance().PartyMemberPIDToVID(kPartyUpdatePacket.pid, &dwVID))
+		if (byOldState != kPartyUpdatePacket.state)
+		{
+			__RefreshTargetBoardByVID(dwVID);
+		}
+
+	//Tracef(" >> RecvPartyUpdate : %d, %d, %d\n", kPartyUpdatePacket.pid, kPartyUpdatePacket.state, kPartyUpdatePacket.percent_hp);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPartyRemove()
+{
+	TPacketGCPartyRemove kPartyRemovePacket;
+	if (!Recv(sizeof(kPartyRemovePacket), &kPartyRemovePacket))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RemovePartyMember", Py_BuildValue("(i)", kPartyRemovePacket.pid));
+	Tracef(" >> RecvPartyRemove : %d\n", kPartyRemovePacket.pid);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPartyLink()
+{
+	TPacketGCPartyLink kPartyLinkPacket;
+	if (!Recv(sizeof(kPartyLinkPacket), &kPartyLinkPacket))
+		return false;
+
+	CPythonPlayer::Instance().LinkPartyMember(kPartyLinkPacket.pid, kPartyLinkPacket.vid);
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "LinkPartyMember",
+		Py_BuildValue("(ii"
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+			"i"
+#endif
+#if defined(ENABLE_PARTY_CHANNEL_FIX)
+			"i"
+#endif
+			")",
+			kPartyLinkPacket.pid, kPartyLinkPacket.vid
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+			, kPartyLinkPacket.mapIdx
+#endif
+#if defined(ENABLE_PARTY_CHANNEL_FIX)
+			, kPartyLinkPacket.channel
+#endif
+		));
+
+	Tracef(" >> RecvPartyLink : %d, %d"
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+		", %d"
+#endif
+#if defined(ENABLE_PARTY_CHANNEL_FIX)
+		", %d"
+#endif
+		"\n", kPartyLinkPacket.pid, kPartyLinkPacket.vid
+#if defined(WJ_SHOW_PARTY_ON_MINIMAP)
+		, kPartyLinkPacket.mapIdx
+#endif
+#if defined(ENABLE_PARTY_CHANNEL_FIX)
+		, kPartyLinkPacket.channel
+#endif
+	);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPartyUnlink()
+{
+	TPacketGCPartyLink kPartyUnlinkPacket;
+	if (!Recv(sizeof(kPartyUnlinkPacket), &kPartyUnlinkPacket))
+		return false;
+
+	CPythonPlayer::Instance().UnlinkPartyMember(kPartyUnlinkPacket.pid);
+
+	if (CPythonPlayer::Instance().IsMainCharacterIndex(kPartyUnlinkPacket.vid))
+	{
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "UnlinkAllPartyMember", Py_BuildValue("()"));
+	}
+	else
+	{
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "UnlinkPartyMember", Py_BuildValue("(i)", kPartyUnlinkPacket.pid));
+	}
+
+	Tracef(" >> RecvPartyUnlink : %d, %d\n", kPartyUnlinkPacket.pid, kPartyUnlinkPacket.vid);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPartyParameter()
+{
+	TPacketGCPartyParameter kPartyParameterPacket;
+	if (!Recv(sizeof(kPartyParameterPacket), &kPartyParameterPacket))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ChangePartyParameter", Py_BuildValue("(i)", kPartyParameterPacket.bDistributeMode));
+	Tracef(" >> RecvPartyParameter : %d\n", kPartyParameterPacket.bDistributeMode);
+
+	return true;
+}
+// Party
+//////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////////
+// Guild
+bool CPythonNetworkStream::SendGuildAddMemberPacket(DWORD dwVID)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_ADD_MEMBER;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+	if (!Send(sizeof(dwVID), &dwVID))
+		return false;
+
+	Tracef(" SendGuildAddMemberPacket\n", dwVID);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildRemoveMemberPacket(DWORD dwPID)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_REMOVE_MEMBER;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+	if (!Send(sizeof(dwPID), &dwPID))
+		return false;
+
+	Tracef(" SendGuildRemoveMemberPacket %d\n", dwPID);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildChangeGradeNamePacket(BYTE byGradeNumber, const char* c_szName)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+	if (!Send(sizeof(byGradeNumber), &byGradeNumber))
+		return false;
+
+	char szName[GUILD_GRADE_NAME_MAX_LEN + 1];
+	strncpy(szName, c_szName, GUILD_GRADE_NAME_MAX_LEN);
+	szName[GUILD_GRADE_NAME_MAX_LEN] = '\0';
+
+	if (!Send(sizeof(szName), &szName))
+		return false;
+
+	Tracef(" SendGuildChangeGradeNamePacket %d, %s\n", byGradeNumber, c_szName);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildChangeGradeAuthorityPacket(BYTE byGradeNumber, BYTE byAuthority)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+	if (!Send(sizeof(byGradeNumber), &byGradeNumber))
+		return false;
+	if (!Send(sizeof(byAuthority), &byAuthority))
+		return false;
+
+	Tracef(" SendGuildChangeGradeAuthorityPacket %d, %d\n", byGradeNumber, byAuthority);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildOfferPacket(DWORD dwExperience)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_OFFER;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+	if (!Send(sizeof(dwExperience), &dwExperience))
+		return false;
+
+	Tracef(" SendGuildOfferPacket %d\n", dwExperience);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildPostCommentPacket(const char* c_szMessage)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_POST_COMMENT;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+
+	BYTE bySize = BYTE(strlen(c_szMessage)) + 1;
+	if (!Send(sizeof(bySize), &bySize))
+		return false;
+	if (!Send(bySize, c_szMessage))
+		return false;
+
+	Tracef(" SendGuildPostCommentPacket %d, %s\n", bySize, c_szMessage);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildDeleteCommentPacket(DWORD dwIndex)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_DELETE_COMMENT;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+
+	if (!Send(sizeof(dwIndex), &dwIndex))
+		return false;
+
+	Tracef(" SendGuildDeleteCommentPacket %d\n", dwIndex);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildRefreshCommentsPacket(DWORD dwHighestIndex)
+{
+	static DWORD s_LastTime = timeGetTime() - 1001;
+
+	if (timeGetTime() - s_LastTime < 1000)
+		return true;
+	s_LastTime = timeGetTime();
+
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_REFRESH_COMMENT;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+
+	Tracef(" SendGuildRefreshCommentPacket %d\n", dwHighestIndex);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildChangeMemberGradePacket(DWORD dwPID, BYTE byGrade)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+
+	if (!Send(sizeof(dwPID), &dwPID))
+		return false;
+	if (!Send(sizeof(byGrade), &byGrade))
+		return false;
+
+	Tracef(" SendGuildChangeMemberGradePacket %d, %d\n", dwPID, byGrade);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildUseSkillPacket(DWORD dwSkillID, DWORD dwTargetVID)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_USE_SKILL;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+
+	if (!Send(sizeof(dwSkillID), &dwSkillID))
+		return false;
+	if (!Send(sizeof(dwTargetVID), &dwTargetVID))
+		return false;
+
+	Tracef(" SendGuildUseSkillPacket %d, %d\n", dwSkillID, dwTargetVID);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildChangeMemberGeneralPacket(DWORD dwPID, BYTE byFlag)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+
+	if (!Send(sizeof(dwPID), &dwPID))
+		return false;
+	if (!Send(sizeof(byFlag), &byFlag))
+		return false;
+
+	Tracef(" SendGuildChangeMemberGeneralFlagPacket %d, %d\n", dwPID, byFlag);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildInviteAnswerPacket(DWORD dwGuildID, BYTE byAnswer)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+
+	if (!Send(sizeof(dwGuildID), &dwGuildID))
+		return false;
+	if (!Send(sizeof(byAnswer), &byAnswer))
+		return false;
+
+	Tracef(" SendGuildInviteAnswerPacket %d, %d\n", dwGuildID, byAnswer);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildChargeGSPPacket(DWORD dwMoney)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHARGE_GSP;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+
+	if (!Send(sizeof(dwMoney), &dwMoney))
+		return false;
+
+	Tracef(" SendGuildChargeGSPPacket %d\n", dwMoney);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildDepositMoneyPacket(DWORD dwMoney)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_DEPOSIT_MONEY;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+	if (!Send(sizeof(dwMoney), &dwMoney))
+		return false;
+
+	Tracef(" SendGuildDepositMoneyPacket %d\n", dwMoney);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGuildWithdrawMoneyPacket(DWORD dwMoney)
+{
+	TPacketCGGuild GuildPacket;
+	GuildPacket.byHeader = HEADER_CG_GUILD;
+	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_WITHDRAW_MONEY;
+	if (!Send(sizeof(GuildPacket), &GuildPacket))
+		return false;
+	if (!Send(sizeof(dwMoney), &dwMoney))
+		return false;
+
+	Tracef(" SendGuildWithdrawMoneyPacket %d\n", dwMoney);
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvGuild()
+{
+	TPacketGCGuild GuildPacket;
+	if (!Recv(sizeof(GuildPacket), &GuildPacket))
+		return false;
+
+	switch (GuildPacket.subheader)
+	{
+		case GUILD_SUBHEADER_GC_LOGIN:
+		{
+			DWORD dwPID;
+			if (!Recv(sizeof(DWORD), &dwPID))
+				return false;
+
+			// Messenger
+			CPythonGuild::TGuildMemberData* pGuildMemberData;
+			if (CPythonGuild::Instance().GetMemberDataPtrByPID(dwPID, &pGuildMemberData))
+				if (0 != pGuildMemberData->strName.compare(CPythonPlayer::Instance().GetName()))
+					CPythonMessenger::Instance().LoginGuildMember(pGuildMemberData->strName.c_str());
+
+			//Tracef(" <Login> %d\n", dwPID);
+			break;
+		}
+		case GUILD_SUBHEADER_GC_LOGOUT:
+		{
+			DWORD dwPID;
+			if (!Recv(sizeof(DWORD), &dwPID))
+				return false;
+
+			// Messenger
+			CPythonGuild::TGuildMemberData* pGuildMemberData;
+			if (CPythonGuild::Instance().GetMemberDataPtrByPID(dwPID, &pGuildMemberData))
+				if (0 != pGuildMemberData->strName.compare(CPythonPlayer::Instance().GetName()))
+					CPythonMessenger::Instance().LogoutGuildMember(pGuildMemberData->strName.c_str());
+
+			//Tracef(" <Logout> %d\n", dwPID);
+			break;
+		}
+		case GUILD_SUBHEADER_GC_REMOVE:
+		{
+			DWORD dwPID;
+			if (!Recv(sizeof(dwPID), &dwPID))
+				return false;
+
+			// Main Player   DeleteGuild
+			if (CPythonGuild::Instance().IsMainPlayer(dwPID))
+			{
+				CPythonGuild::Instance().Destroy();
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "DeleteGuild", Py_BuildValue("()"));
+				CPythonMessenger::Instance().RemoveAllGuildMember();
+				__SetGuildID(0);
+				__RefreshMessengerWindow();
+				__RefreshTargetBoard();
+				__RefreshCharacterWindow();
+			}
+			else
+			{
+				// Get Member Name
+				std::string strMemberName = "";
+				CPythonGuild::TGuildMemberData* pData;
+				if (CPythonGuild::Instance().GetMemberDataPtrByPID(dwPID, &pData))
+				{
+					strMemberName = pData->strName;
+					CPythonMessenger::Instance().RemoveGuildMember(pData->strName.c_str());
+				}
+
+				CPythonGuild::Instance().RemoveMember(dwPID);
+
+				// Refresh
+				__RefreshTargetBoardByName(strMemberName.c_str());
+				__RefreshGuildWindowMemberPage();
+			}
+
+			Tracef(" <Remove> %d\n", dwPID);
+			break;
+		}
+		case GUILD_SUBHEADER_GC_LIST:
+		{
+			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);
+
+			for (; iPacketSize > 0;)
+			{
+				TPacketGCGuildSubMember memberPacket;
+				if (!Recv(sizeof(memberPacket), &memberPacket))
+					return false;
+
+				char szName[CHARACTER_NAME_MAX_LEN + 1] = "";
+				if (memberPacket.byNameFlag)
+				{
+					if (!Recv(sizeof(szName), &szName))
+						return false;
+
+					iPacketSize -= CHARACTER_NAME_MAX_LEN + 1;
+				}
+				else
+				{
+					CPythonGuild::TGuildMemberData* pMemberData;
+					if (CPythonGuild::Instance().GetMemberDataPtrByPID(memberPacket.pid, &pMemberData))
+					{
+						strncpy(szName, pMemberData->strName.c_str(), CHARACTER_NAME_MAX_LEN);
+					}
+				}
+
+				//Tracef(" <List> %d : %s, %d (%d, %d, %d)\n", memberPacket.pid, szName, memberPacket.byGrade, memberPacket.byJob, memberPacket.byLevel, memberPacket.dwOffer);
+
+				CPythonGuild::SGuildMemberData GuildMemberData;
+				GuildMemberData.dwPID = memberPacket.pid;
+				GuildMemberData.byGrade = memberPacket.byGrade;
+				GuildMemberData.strName = szName;
+				GuildMemberData.byJob = memberPacket.byJob;
+				GuildMemberData.byLevel = memberPacket.byLevel;
+				GuildMemberData.dwOffer = memberPacket.dwOffer;
+				GuildMemberData.byGeneralFlag = memberPacket.byIsGeneral;
+				CPythonGuild::Instance().RegisterMember(GuildMemberData);
+
+				// Messenger
+				if (strcmp(szName, CPythonPlayer::Instance().GetName()))
+					CPythonMessenger::Instance().AppendGuildMember(szName);
+
+				__RefreshTargetBoardByName(szName);
+
+				iPacketSize -= sizeof(memberPacket);
+			}
+
+			__RefreshGuildWindowInfoPage();
+			__RefreshGuildWindowMemberPage();
+			__RefreshMessengerWindow();
+			__RefreshCharacterWindow();
+			break;
+		}
+		case GUILD_SUBHEADER_GC_GRADE:
+		{
+			BYTE byCount;
+			if (!Recv(sizeof(byCount), &byCount))
+				return false;
+
+			for (BYTE i = 0; i < byCount; ++i)
+			{
+				BYTE byIndex;
+				if (!Recv(sizeof(byCount), &byIndex))
+					return false;
+
+				TPacketGCGuildSubGrade GradePacket;
+				if (!Recv(sizeof(GradePacket), &GradePacket))
+					return false;
+
+#if defined(ENABLE_LOCALE_CLIENT)
+				CPythonLocale::Instance().FormatString(GradePacket.grade_name, sizeof(GradePacket.grade_name));
+#endif
+
+				auto aGradeData = CPythonGuild::SGuildGradeData(GradePacket.auth_flag, GradePacket.grade_name);
+				CPythonGuild::Instance().SetGradeData(byIndex, aGradeData);
+				//Tracef(" <Grade> [%d/%d] : %s, %d\n", byIndex, byCount, GradePacket.grade_name, GradePacket.auth_flag);
+			}
+			__RefreshGuildWindowGradePage();
+			__RefreshGuildWindowMemberPageGradeComboBox();
+			break;
+		}
+		case GUILD_SUBHEADER_GC_GRADE_NAME:
+		{
+			BYTE byGradeNumber;
+			if (!Recv(sizeof(byGradeNumber), &byGradeNumber))
+				return false;
+
+			char szGradeName[GUILD_GRADE_NAME_MAX_LEN + 1] = "";
+			if (!Recv(sizeof(szGradeName), &szGradeName))
+				return false;
+
+#if defined(ENABLE_LOCALE_CLIENT)
+			CPythonLocale::Instance().FormatString(szGradeName, sizeof(szGradeName));
+#endif
+
+			CPythonGuild::Instance().SetGradeName(byGradeNumber, szGradeName);
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildGrade", Py_BuildValue("()"));
+
+			Tracef(" <Change Grade Name> %d, %s\n", byGradeNumber, szGradeName);
+			__RefreshGuildWindowGradePage();
+			__RefreshGuildWindowMemberPageGradeComboBox();
+			break;
+		}
+		case GUILD_SUBHEADER_GC_GRADE_AUTH:
+		{
+			BYTE byGradeNumber;
+			if (!Recv(sizeof(byGradeNumber), &byGradeNumber))
+				return false;
+			BYTE byAuthorityFlag;
+			if (!Recv(sizeof(byAuthorityFlag), &byAuthorityFlag))
+				return false;
+
+			CPythonGuild::Instance().SetGradeAuthority(byGradeNumber, byAuthorityFlag);
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildGrade", Py_BuildValue("()"));
+
+			Tracef(" <Change Grade Authority> %d, %d\n", byGradeNumber, byAuthorityFlag);
+			__RefreshGuildWindowGradePage();
+			break;
+		}
+		case GUILD_SUBHEADER_GC_INFO:
+		{
+			TPacketGCGuildInfo GuildInfo;
+			if (!Recv(sizeof(GuildInfo), &GuildInfo))
+				return false;
+
+			CPythonGuild::Instance().EnableGuild();
+			CPythonGuild::TGuildInfo& rGuildInfo = CPythonGuild::Instance().GetGuildInfoRef();
+			strncpy(rGuildInfo.szGuildName, GuildInfo.name, GUILD_NAME_MAX_LEN);
+			rGuildInfo.szGuildName[GUILD_NAME_MAX_LEN] = '\0';
+
+			rGuildInfo.dwGuildID = GuildInfo.guild_id;
+			rGuildInfo.dwMasterPID = GuildInfo.master_pid;
+			rGuildInfo.dwGuildLevel = GuildInfo.level;
+			rGuildInfo.dwCurrentExperience = GuildInfo.exp;
+			rGuildInfo.dwCurrentMemberCount = GuildInfo.member_count;
+			rGuildInfo.dwMaxMemberCount = GuildInfo.max_member_count;
+			rGuildInfo.dwGuildMoney = GuildInfo.gold;
+			rGuildInfo.bHasLand = GuildInfo.hasLand;
+
+			//Tracef(" <Info> %s, %d, %d : %d\n", GuildInfo.name, GuildInfo.master_pid, GuildInfo.level, rGuildInfo.bHasLand);
+			__RefreshGuildWindowInfoPage();
+			break;
+		}
+		case GUILD_SUBHEADER_GC_COMMENTS:
+		{
+			BYTE byCount;
+			if (!Recv(sizeof(byCount), &byCount))
+				return false;
+
+			CPythonGuild::Instance().ClearComment();
+			//Tracef(" >>> Comments Count : %d\n", byCount);
+
+			for (BYTE i = 0; i < byCount; ++i)
+			{
+				DWORD dwCommentID;
+				if (!Recv(sizeof(dwCommentID), &dwCommentID))
+					return false;
+
+				char szName[CHARACTER_NAME_MAX_LEN + 1] = "";
+				if (!Recv(sizeof(szName), &szName))
+					return false;
+
+				char szComment[GULID_COMMENT_MAX_LEN + 1] = "";
+				if (!Recv(sizeof(szComment), &szComment))
+					return false;
+
+				//Tracef(" [Comment-%d] : %s, %s\n", dwCommentID, szName, szComment);
+				CPythonGuild::Instance().RegisterComment(dwCommentID, szName, szComment);
+			}
+
+			__RefreshGuildWindowBoardPage();
+			break;
+		}
+		case GUILD_SUBHEADER_GC_CHANGE_EXP:
+		{
+			BYTE byLevel;
+			if (!Recv(sizeof(byLevel), &byLevel))
+				return false;
+			DWORD dwEXP;
+			if (!Recv(sizeof(dwEXP), &dwEXP))
+				return false;
+			CPythonGuild::Instance().SetGuildEXP(byLevel, dwEXP);
+			Tracef(" <ChangeEXP> %d, %d\n", byLevel, dwEXP);
+			__RefreshGuildWindowInfoPage();
+			break;
+		}
+		case GUILD_SUBHEADER_GC_CHANGE_MEMBER_GRADE:
+		{
+			DWORD dwPID;
+			if (!Recv(sizeof(dwPID), &dwPID))
+				return false;
+			BYTE byGrade;
+			if (!Recv(sizeof(byGrade), &byGrade))
+				return false;
+			CPythonGuild::Instance().ChangeGuildMemberGrade(dwPID, byGrade);
+			Tracef(" <ChangeMemberGrade> %d, %d\n", dwPID, byGrade);
+			__RefreshGuildWindowMemberPage();
+			break;
+		}
+		case GUILD_SUBHEADER_GC_SKILL_INFO:
+		{
+			CPythonGuild::TGuildSkillData& rSkillData = CPythonGuild::Instance().GetGuildSkillDataRef();
+			if (!Recv(sizeof(rSkillData.bySkillPoint), &rSkillData.bySkillPoint))
+				return false;
+			if (!Recv(sizeof(rSkillData.bySkillLevel), rSkillData.bySkillLevel))
+				return false;
+			if (!Recv(sizeof(rSkillData.wGuildPoint), &rSkillData.wGuildPoint))
+				return false;
+			if (!Recv(sizeof(rSkillData.wMaxGuildPoint), &rSkillData.wMaxGuildPoint))
+				return false;
+
+			Tracef(" <SkillInfo> %d / %d, %d\n", rSkillData.bySkillPoint, rSkillData.wGuildPoint, rSkillData.wMaxGuildPoint);
+			__RefreshGuildWindowSkillPage();
+			break;
+		}
+		case GUILD_SUBHEADER_GC_CHANGE_MEMBER_GENERAL:
+		{
+			DWORD dwPID;
+			if (!Recv(sizeof(dwPID), &dwPID))
+				return false;
+			BYTE byFlag;
+			if (!Recv(sizeof(byFlag), &byFlag))
+				return false;
+
+			CPythonGuild::Instance().ChangeGuildMemberGeneralFlag(dwPID, byFlag);
+			Tracef(" <ChangeMemberGeneralFlag> %d, %d\n", dwPID, byFlag);
+			__RefreshGuildWindowMemberPage();
+			break;
+		}
+		case GUILD_SUBHEADER_GC_GUILD_INVITE:
+		{
+			DWORD dwGuildID;
+			if (!Recv(sizeof(dwGuildID), &dwGuildID))
+				return false;
+			char szGuildName[GUILD_NAME_MAX_LEN + 1];
+			if (!Recv(GUILD_NAME_MAX_LEN, &szGuildName))
+				return false;
+
+			szGuildName[GUILD_NAME_MAX_LEN] = 0;
+
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RecvGuildInviteQuestion", Py_BuildValue("(is)", dwGuildID, szGuildName));
+			Tracef(" <Guild Invite> %d, %s\n", dwGuildID, szGuildName);
+			break;
+		}
+		case GUILD_SUBHEADER_GC_WAR:
+		{
+			TPacketGCGuildWar kGuildWar;
+			if (!Recv(sizeof(kGuildWar), &kGuildWar))
+				return false;
+
+			switch (kGuildWar.bWarState)
+			{
+				case GUILD_WAR_SEND_DECLARE:
+					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_SEND_DECLARE\n");
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
+						"BINARY_GuildWar_OnSendDeclare",
+						Py_BuildValue("(i)", kGuildWar.dwGuildOpp)
+					);
+					break;
+				case GUILD_WAR_RECV_DECLARE:
+					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_RECV_DECLARE\n");
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
+						"BINARY_GuildWar_OnRecvDeclare",
+						Py_BuildValue("(ii)", kGuildWar.dwGuildOpp, kGuildWar.bType)
+					);
+					break;
+				case GUILD_WAR_ON_WAR:
+					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_ON_WAR : %d, %d\n", kGuildWar.dwGuildSelf, kGuildWar.dwGuildOpp);
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
+						"BINARY_GuildWar_OnStart",
+						Py_BuildValue("(ii)", kGuildWar.dwGuildSelf, kGuildWar.dwGuildOpp)
+					);
+					CPythonGuild::Instance().StartGuildWar(kGuildWar.dwGuildOpp);
+					break;
+				case GUILD_WAR_END:
+					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_END\n");
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
+						"BINARY_GuildWar_OnEnd",
+						Py_BuildValue("(ii)", kGuildWar.dwGuildSelf, kGuildWar.dwGuildOpp)
+					);
+					CPythonGuild::Instance().EndGuildWar(kGuildWar.dwGuildOpp);
+					break;
+			}
+			break;
+		}
+		case GUILD_SUBHEADER_GC_GUILD_NAME:
+		{
+			DWORD dwID;
+			char szGuildName[GUILD_NAME_MAX_LEN + 1];
+
+			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);
+
+			int nItemSize = sizeof(dwID) + GUILD_NAME_MAX_LEN;
+
+			assert(iPacketSize % nItemSize == 0 && "GUILD_SUBHEADER_GC_GUILD_NAME");
+
+			for (; iPacketSize > 0;)
+			{
+				if (!Recv(sizeof(dwID), &dwID))
+					return false;
+
+				if (!Recv(GUILD_NAME_MAX_LEN, &szGuildName))
+					return false;
+
+				szGuildName[GUILD_NAME_MAX_LEN] = 0;
+
+				//Tracef(" >> GulidName [%d : %s]\n", dwID, szGuildName);
+				CPythonGuild::Instance().RegisterGuildName(dwID, szGuildName);
+				iPacketSize -= nItemSize;
+			}
+			break;
+		}
+		case GUILD_SUBHEADER_GC_GUILD_WAR_LIST:
+		{
+			DWORD dwSrcGuildID;
+			DWORD dwDstGuildID;
+
+			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);
+			int nItemSize = sizeof(dwSrcGuildID) + sizeof(dwDstGuildID);
+
+			assert(iPacketSize % nItemSize == 0 && "GUILD_SUBHEADER_GC_GUILD_WAR_LIST");
+
+			for (; iPacketSize > 0;)
+			{
+				if (!Recv(sizeof(dwSrcGuildID), &dwSrcGuildID))
+					return false;
+
+				if (!Recv(sizeof(dwDstGuildID), &dwDstGuildID))
+					return false;
+
+				Tracef(" >> GulidWarList [%d vs %d]\n", dwSrcGuildID, dwDstGuildID);
+				CInstanceBase::InsertGVGKey(dwSrcGuildID, dwDstGuildID);
+				CPythonCharacterManager::Instance().ChangeGVG(dwSrcGuildID, dwDstGuildID);
+				iPacketSize -= nItemSize;
+			}
+			break;
+		}
+		case GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST:
+		{
+			DWORD dwSrcGuildID;
+			DWORD dwDstGuildID;
+
+			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);
+			int nItemSize = sizeof(dwSrcGuildID) + sizeof(dwDstGuildID);
+
+			assert(iPacketSize % nItemSize == 0 && "GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST");
+
+			for (; iPacketSize > 0;)
+			{
+				if (!Recv(sizeof(dwSrcGuildID), &dwSrcGuildID))
+					return false;
+
+				if (!Recv(sizeof(dwDstGuildID), &dwDstGuildID))
+					return false;
+
+				Tracef(" >> GulidWarEndList [%d vs %d]\n", dwSrcGuildID, dwDstGuildID);
+				CInstanceBase::RemoveGVGKey(dwSrcGuildID, dwDstGuildID);
+				CPythonCharacterManager::Instance().ChangeGVG(dwSrcGuildID, dwDstGuildID);
+				iPacketSize -= nItemSize;
+			}
+			break;
+		}
+		case GUILD_SUBHEADER_GC_WAR_POINT:
+		{
+			TPacketGuildWarPoint GuildWarPoint;
+			if (!Recv(sizeof(GuildWarPoint), &GuildWarPoint))
+				return false;
+
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
+				"BINARY_GuildWar_OnRecvPoint",
+				Py_BuildValue("(iii)", GuildWarPoint.dwGainGuildID, GuildWarPoint.dwOpponentGuildID, GuildWarPoint.lPoint)
+			);
+			break;
+		}
+		case GUILD_SUBHEADER_GC_MONEY_CHANGE:
+		{
+			DWORD dwMoney;
+			if (!Recv(sizeof(dwMoney), &dwMoney))
+				return false;
+
+			CPythonGuild::Instance().SetGuildMoney(dwMoney);
+
+			__RefreshGuildWindowInfoPage();
+			Tracef(" >> Guild Money Change : %d\n", dwMoney);
+			break;
+		}
+	}
+
+	return true;
+}
+// Guild
+//////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////
+// Fishing
+bool CPythonNetworkStream::SendFishingPacket(int iRotation)
+{
+	BYTE byHeader = HEADER_CG_FISHING;
+	if (!Send(sizeof(byHeader), &byHeader))
+		return false;
+	BYTE byPacketRotation = iRotation / 5;
+	if (!Send(sizeof(BYTE), &byPacketRotation))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendGiveItemPacket(DWORD dwTargetVID, TItemPos ItemPos, int iItemCount)
+{
+	TPacketCGGiveItem GiveItemPacket;
+	GiveItemPacket.byHeader = HEADER_CG_GIVE_ITEM;
+	GiveItemPacket.dwTargetVID = dwTargetVID;
+	GiveItemPacket.ItemPos = ItemPos;
+	GiveItemPacket.byItemCount = iItemCount;
+
+	if (!Send(sizeof(GiveItemPacket), &GiveItemPacket))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvFishing()
+{
+	TPacketGCFishing FishingPacket;
+	if (!Recv(sizeof(FishingPacket), &FishingPacket))
+		return false;
+
+	CInstanceBase* pFishingInstance = NULL;
+	if (FISHING_SUBHEADER_GC_FISH != FishingPacket.subheader)
+	{
+		pFishingInstance = CPythonCharacterManager::Instance().GetInstancePtr(FishingPacket.info);
+		if (!pFishingInstance)
+			return true;
+	}
+
+	switch (FishingPacket.subheader)
+	{
+		case FISHING_SUBHEADER_GC_START:
+			pFishingInstance->StartFishing(float(FishingPacket.dir) * 5.0f);
+			break;
+
+		case FISHING_SUBHEADER_GC_STOP:
+			if (pFishingInstance->IsFishing())
+				pFishingInstance->StopFishing();
+			break;
+
+		case FISHING_SUBHEADER_GC_REACT:
+			if (pFishingInstance->IsFishing())
+			{
+#if !defined(ENABLE_FISHING_GAME)
+				pFishingInstance->SetFishEmoticon(); // Fish Emoticon
+#endif
+				pFishingInstance->ReactFishing();
+			}
+			break;
+
+		case FISHING_SUBHEADER_GC_SUCCESS:
+			pFishingInstance->CatchSuccess();
+#if defined(ENABLE_FISHING_GAME)
+			pFishingInstance->SetFishEmoticon();
+#endif
+			break;
+
+		case FISHING_SUBHEADER_GC_FAIL:
+			pFishingInstance->CatchFail();
+			if (pFishingInstance == CPythonCharacterManager::Instance().GetMainInstancePtr())
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingFailure", Py_BuildValue("()"));
+#if defined(ENABLE_FISHING_GAME)
+			pFishingInstance->SetEmoticon(CInstanceBase::EMOTICON_NO_FISH);
+#endif
+			break;
+
+		case FISHING_SUBHEADER_GC_FISH:
+		{
+			DWORD dwFishID = FishingPacket.info;
+
+			if (0 == FishingPacket.info)
+			{
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingNotifyUnknown", Py_BuildValue("()"));
+				return true;
+			}
+
+			CItemData* pItemData;
+			if (!CItemManager::Instance().GetItemDataPointer(dwFishID, &pItemData))
+				return true;
+
+			CInstanceBase* pMainInstance = CPythonCharacterManager::Instance().GetMainInstancePtr();
+			if (!pMainInstance)
+				return true;
+
+			if (pMainInstance->IsFishing())
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingNotify", Py_BuildValue("(is)", CItemData::ITEM_TYPE_FISH == pItemData->GetType(), pItemData->GetName()));
+			else
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingSuccess", Py_BuildValue("(is)", CItemData::ITEM_TYPE_FISH == pItemData->GetType(), pItemData->GetName()));
+			break;
+		}
+	}
+
+	return true;
+}
+
+#if defined(ENABLE_FISHING_GAME)
+bool CPythonNetworkStream::RecvFishingGamePacket()
+{
+	TPacketGCFishingGame Packet;
+	if (!Recv(sizeof(Packet), &Packet))
+		return false;
+
+	CPythonPlayer& rkPlayer = CPythonPlayer::instance();
+	switch (Packet.bSubHeader)
+	{
+		case FISHING_GAME_SUBHEADER_OPEN:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingGameStart", Py_BuildValue("(i)", Packet.bLevel));
+			rkPlayer.SetFishingGameWindowOpen(true);
+			break;
+
+		case FISHING_GAME_SUBHEADER_QUIT:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingStopGame", Py_BuildValue("()"));
+			rkPlayer.SetFishingGameWindowOpen(false);
+			break;
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendFishingGamePacket(BYTE bSubHeader, BYTE bGoals)
+{
+	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
+	if (!rkPlayer.GetFishingGameWindowOpen())
+		return false;
+
+	TPacketCGFishingGame Packet;
+	Packet.bHeader = HEADER_CG_FISHING_GAME;
+	Packet.bSubHeader = bSubHeader;
+	Packet.bGoals = bGoals;
+	if (!Send(sizeof(Packet), &Packet))
+		return false;
+
+	return SendSequence();
+}
+#endif
+// Fishing
+/////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////
+// Dungeon
+bool CPythonNetworkStream::RecvDungeon()
+{
+	TPacketGCDungeon DungeonPacket;
+	if (!Recv(sizeof(DungeonPacket), &DungeonPacket))
+		return false;
+
+	switch (DungeonPacket.subheader)
+	{
+		case DUNGEON_SUBHEADER_GC_TIME_ATTACK_START:
+		{
+			break;
+		}
+		case DUNGEON_SUBHEADER_GC_DESTINATION_POSITION:
+		{
+			unsigned long ulx, uly;
+			if (!Recv(sizeof(ulx), &ulx))
+				return false;
+			if (!Recv(sizeof(uly), &uly))
+				return false;
+
+			CPythonPlayer::Instance().SetDungeonDestinationPosition(ulx, uly);
+			break;
+		}
+	}
+
+	return true;
+}
+// Dungeon
+/////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////
+// MyShop
+bool CPythonNetworkStream::SendBuildPrivateShopPacket(const char* c_szName, const std::vector<TShopItemTable>& c_rSellingItemStock)
+{
+	TPacketCGMyShop packet;
+	packet.bHeader = HEADER_CG_MYSHOP;
+	strncpy(packet.szSign, c_szName, SHOP_SIGN_MAX_LEN);
+	packet.bCount = static_cast<BYTE>(c_rSellingItemStock.size());
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	for (std::vector<TShopItemTable>::const_iterator itor = c_rSellingItemStock.begin(); itor < c_rSellingItemStock.end(); ++itor)
+	{
+		const TShopItemTable& c_rItem = *itor;
+		if (!Send(sizeof(c_rItem), &c_rItem))
+			return false;
+	}
+
+	return SendSequence();
+}
+
+#if defined(ENABLE_MYSHOP_DECO)
+bool CPythonNetworkStream::SendMyShopDecoState(BYTE bState)
+{
+	TPacketCGMyShopDeco Packet;
+	Packet.bHeader = HEADER_CG_MYSHOP_DECO;
+	Packet.bState = bState;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("TPacketCGMyShopDeco Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMyShopDecoSet(BYTE bType, DWORD dwPolyVnum)
+{
+	TPacketCGMyShopDecoAdd Packet;
+	Packet.bHeader = HEADER_CG_MYSHOP_DECO_ADD;
+	Packet.bType = bType;
+	Packet.dwPolyVnum = dwPolyVnum;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("TPacketCGMyShopDecoAdd Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+#endif
+
+bool CPythonNetworkStream::RecvShopSignPacket()
+{
+	TPacketGCShopSign p;
+	if (!Recv(sizeof(TPacketGCShopSign), &p))
+		return false;
+
+	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
+
+#if defined(ENABLE_GRAPHIC_ON_OFF)
+	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(p.dwVID);
+	if (!pInstance)
+		return true;
+#endif
+
+	if (0 == strlen(p.szSign))
+	{
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_PrivateShop_Disappear", Py_BuildValue("(i)", p.dwVID));
+
+		if (rkPlayer.IsMainCharacterIndex(p.dwVID))
+			rkPlayer.ClosePrivateShop();
+
+#if defined(ENABLE_GRAPHIC_ON_OFF)
+		pInstance->GetGraphicThingInstancePtr()->RemovePrivateShopSign();
+#endif
+	}
+	else
+	{
+#if defined(ENABLE_MYSHOP_DECO)
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_PrivateShop_Appear", Py_BuildValue("(isi)", p.dwVID, p.szSign, p.bType));
+#else
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_PrivateShop_Appear", Py_BuildValue("(is)", p.dwVID, p.szSign));
+#endif
+
+		if (rkPlayer.IsMainCharacterIndex(p.dwVID))
+			rkPlayer.OpenPrivateShop();
+
+#if defined(ENABLE_GRAPHIC_ON_OFF)
+		pInstance->GetGraphicThingInstancePtr()->AddPrivateShopSign();
+#endif
+	}
+
+	return true;
+}
+/////////////////////////////////////////////////////////////////////////
+
+bool CPythonNetworkStream::RecvTimePacket()
+{
+	TPacketGCTime TimePacket;
+	if (!Recv(sizeof(TimePacket), &TimePacket))
+		return false;
+
+	IAbstractApplication& rkApp = IAbstractApplication::GetSingleton();
+	rkApp.SetServerTime(TimePacket.time);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvWalkModePacket()
+{
+	TPacketGCWalkMode WalkModePacket;
+	if (!Recv(sizeof(WalkModePacket), &WalkModePacket))
+		return false;
+
+	CInstanceBase* pInstance = CPythonCharacterManager::Instance().GetInstancePtr(WalkModePacket.vid);
+	if (pInstance)
+	{
+		if (WALKMODE_RUN == WalkModePacket.mode)
+		{
+			pInstance->SetRunMode();
+		}
+		else
+		{
+			pInstance->SetWalkMode();
+		}
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvChangeSkillGroupPacket()
+{
+	TPacketGCChangeSkillGroup ChangeSkillGroup;
+	if (!Recv(sizeof(ChangeSkillGroup), &ChangeSkillGroup))
+		return false;
+
+	m_dwMainActorSkillGroup = ChangeSkillGroup.skill_group;
+
+	CPythonPlayer::Instance().NEW_ClearSkillData();
+	__RefreshCharacterWindow();
+	return true;
+}
+
+void CPythonNetworkStream::__TEST_SetSkillGroupFake(int iIndex)
+{
+	m_dwMainActorSkillGroup = DWORD(iIndex);
+
+	CPythonPlayer::Instance().NEW_ClearSkillData();
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshCharacter", Py_BuildValue("()"));
+}
+
+bool CPythonNetworkStream::SendRefinePacket(BYTE byPos, BYTE byType)
+{
+	TPacketCGRefine kRefinePacket;
+	kRefinePacket.header = HEADER_CG_REFINE;
+	kRefinePacket.pos = byPos;
+	kRefinePacket.type = byType;
+
+	if (!Send(sizeof(kRefinePacket), &kRefinePacket))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendSelectItemPacket(DWORD dwItemPos)
+{
+	TPacketCGScriptSelectItem kScriptSelectItem;
+	kScriptSelectItem.header = HEADER_CG_SCRIPT_SELECT_ITEM;
+	kScriptSelectItem.selection = dwItemPos;
+
+	if (!Send(sizeof(kScriptSelectItem), &kScriptSelectItem))
+		return false;
+
+	return SendSequence();
+}
+
+#if defined(ENABLE_GEM_SYSTEM)
+bool CPythonNetworkStream::SendSelectMetinStone(DWORD dwItemPos)
+{
+	TPacketCGSelectItemEx command_select_item_ex(dwItemPos);
+	if (!Send(sizeof(command_select_item_ex), &command_select_item_ex))
+		return false;
+	return SendSequence();
+}
+#endif
+
+bool CPythonNetworkStream::RecvRefineInformationPacket()
+{
+	TPacketGCRefineInformation kRefineInfoPacket;
+	if (!Recv(sizeof(kRefineInfoPacket), &kRefineInfoPacket))
+		return false;
+
+	TRefineTable& rkRefineTable = kRefineInfoPacket.refine_table;
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
+		"OpenRefineDialog",
+		Py_BuildValue("(iiii)",
+			kRefineInfoPacket.pos,
+			kRefineInfoPacket.refine_table.result_vnum,
+			rkRefineTable.cost,
+			rkRefineTable.prob));
+
+	for (int i = 0; i < rkRefineTable.material_count; ++i)
+	{
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AppendMaterialToRefineDialog", Py_BuildValue("(ii)", rkRefineTable.materials[i].vnum, rkRefineTable.materials[i].count));
+	}
+
+#ifdef _DEBUG
+	Tracef(" >> RecvRefineInformationPacket(pos=%d, result_vnum=%d, cost=%d, prob=%d)\n",
+		kRefineInfoPacket.pos,
+		kRefineInfoPacket.refine_table.result_vnum,
+		rkRefineTable.cost,
+		rkRefineTable.prob);
+#endif
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvRefineInformationPacketNew()
+{
+	TPacketGCRefineInformationNew kRefineInfoPacket;
+	if (!Recv(sizeof(kRefineInfoPacket), &kRefineInfoPacket))
+		return false;
+
+	TRefineTable& rkRefineTable = kRefineInfoPacket.refine_table;
+
+#if defined(ENABLE_APPLY_RANDOM)
+	PyObject* poList = PyList_New(0);
+	if (!poList)
+		return false;
+
+	for (BYTE bApplySlot = 0; bApplySlot < ITEM_APPLY_RANDOM_SLOT_MAX_NUM; ++bApplySlot)
+	{
+		PyObject* poItem = Py_BuildValue("(ii)", kRefineInfoPacket.aApplyRandom[bApplySlot].wType, kRefineInfoPacket.aApplyRandom[bApplySlot].lValue);
+		if (!poItem)
+		{
+			Py_DECREF(poList);
+			return false;
+		}
+
+		PyList_Append(poList, poItem);
+		Py_DECREF(poItem);
+	}
+#endif
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME],
+		"OpenRefineDialog",
+#if defined(ENABLE_APPLY_RANDOM)
+		Py_BuildValue("(iiiiiOi)",
+			kRefineInfoPacket.pos,
+			kRefineInfoPacket.refine_table.result_vnum,
+			rkRefineTable.cost,
+			rkRefineTable.prob,
+			kRefineInfoPacket.type,
+			poList,
+			rkRefineTable.src_vnum)
+#else
+		Py_BuildValue("(iiiii)",
+			kRefineInfoPacket.pos,
+			kRefineInfoPacket.refine_table.result_vnum,
+			rkRefineTable.cost,
+			rkRefineTable.prob,
+			kRefineInfoPacket.type)
+#endif
+	);
+
+#if defined(ENABLE_APPLY_RANDOM)
+	Py_DECREF(poList);
+#endif
+
+	for (int i = 0; i < rkRefineTable.material_count; ++i)
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AppendMaterialToRefineDialog", Py_BuildValue("(ii)", rkRefineTable.materials[i].vnum, rkRefineTable.materials[i].count));
+
+#ifdef _DEBUG
+	Tracef(" >> RecvRefineInformationPacketNew(pos=%d, result_vnum=%d, cost=%d, prob=%d, type=%d, src_vnum=%d)\n",
+		kRefineInfoPacket.pos,
+		kRefineInfoPacket.refine_table.result_vnum,
+		rkRefineTable.cost,
+		rkRefineTable.prob,
+		kRefineInfoPacket.type
+	);
+#endif
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvNPCList()
+{
+	TPacketGCNPCPosition kNPCPosition;
+	if (!Recv(sizeof(kNPCPosition), &kNPCPosition))
+		return false;
+
+	assert(int(kNPCPosition.size) - sizeof(kNPCPosition) == kNPCPosition.count * sizeof(TNPCPosition) && "HEADER_GC_NPC_POSITION");
+
+	CPythonMiniMap::Instance().ClearAtlasMarkInfo();
+
+	for (int i = 0; i < kNPCPosition.count; ++i)
+	{
+		TNPCPosition NPCPosition;
+		if (!Recv(sizeof(TNPCPosition), &NPCPosition))
+			return false;
+
+		CPythonMiniMap::Instance().RegisterAtlasMark(NPCPosition.bType, NPCPosition.name, NPCPosition.x, NPCPosition.y);
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::__SendCRCReportPacket()
+{
+	/*
+	DWORD dwProcessCRC = 0;
+	DWORD dwFileCRC = 0;
+	CFilename exeFileName;
+	//LPCVOID c_pvBaseAddress = NULL;
+
+	GetExeCRC(dwProcessCRC, dwFileCRC);
+
+	CFilename strRootPackFileName = CEterPackManager::Instance().GetRootPacketFileName();
+	strRootPackFileName.ChangeDosPath();
+
+	TPacketCGCRCReport kReportPacket;
+
+	kReportPacket.header = HEADER_CG_CRC_REPORT;
+	kReportPacket.byPackMode = CEterPackManager::Instance().GetSearchMode();
+	kReportPacket.dwBinaryCRC32 = dwFileCRC;
+	kReportPacket.dwProcessCRC32 = dwProcessCRC;
+	kReportPacket.dwRootPackCRC32 = GetFileCRC32(strRootPackFileName.c_str());
+
+	if (!Send(sizeof(kReportPacket), &kReportPacket))
+		Tracef("SendClientReportPacket Error");
+
+	return SendSequence();
+	*/
+	return true;
+}
+
+bool CPythonNetworkStream::SendClientVersionPacket()
+{
+	std::string filename;
+
+	GetExcutedFileName(filename);
+
+	filename = CFileNameHelper::NoPath(filename);
+	CFileNameHelper::ChangeDosPath(filename);
+
+	if (LocaleService_IsEUROPE() && false == LocaleService_IsYMIR())
+	{
+		TPacketCGClientVersion2 kVersionPacket;
+		kVersionPacket.header = HEADER_CG_CLIENT_VERSION2;
+		strncpy(kVersionPacket.filename, filename.c_str(), sizeof(kVersionPacket.filename) - 1);
+		strncpy(kVersionPacket.timestamp, "1689090990", sizeof(kVersionPacket.timestamp) - 1);
+
+		if (!Send(sizeof(kVersionPacket), &kVersionPacket))
+			Tracef("SendClientReportPacket Error");
+	}
+	else
+	{
+		TPacketCGClientVersion kVersionPacket;
+		kVersionPacket.header = HEADER_CG_CLIENT_VERSION;
+		strncpy(kVersionPacket.filename, filename.c_str(), sizeof(kVersionPacket.filename) - 1);
+		strncpy(kVersionPacket.timestamp, __TIMESTAMP__, sizeof(kVersionPacket.timestamp) - 1);
+
+		if (!Send(sizeof(kVersionPacket), &kVersionPacket))
+			Tracef("SendClientReportPacket Error");
+	}
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvAffectAddPacket()
+{
+	TPacketGCAffectAdd kAffectAdd;
+	if (!Recv(sizeof(kAffectAdd), &kAffectAdd))
+		return false;
+
+	TPacketAffectElement& rkElement = kAffectAdd.elem;
+	if (rkElement.wApplyOn == POINT_ENERGY)
+	{
+		CPythonPlayer::Instance().SetStatus(POINT_ENERGY_END_TIME, CPythonApplication::Instance().GetServerTimeStamp() + rkElement.lDuration);
+		__RefreshStatus();
+	}
+
+	CPythonPlayer::Instance().AddAffect(rkElement.dwType, kAffectAdd.elem);
+#if defined(ENABLE_AFFECT_RENEWAL)
+	if (rkElement.bUpdate)
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_NEW_UpdateAffect", Py_BuildValue("(iiii)", rkElement.dwType, rkElement.wApplyOn, rkElement.lApplyValue, rkElement.lDuration));
+	else
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_NEW_AddAffect", Py_BuildValue("(iiii)", rkElement.dwType, rkElement.wApplyOn, rkElement.lApplyValue, rkElement.lDuration));
+#else
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_NEW_AddAffect", Py_BuildValue("(iiii)", rkElement.dwType, rkElement.wApplyOn, rkElement.lApplyValue, rkElement.lDuration));
+#endif
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvAffectRemovePacket()
+{
+	TPacketGCAffectRemove kAffectRemove;
+	if (!Recv(sizeof(kAffectRemove), &kAffectRemove))
+		return false;
+
+	CPythonPlayer::Instance().RemoveAffect(kAffectRemove.dwType, kAffectRemove.wApplyOn);
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_NEW_RemoveAffect", Py_BuildValue("(ii)", kAffectRemove.dwType, kAffectRemove.wApplyOn));
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvChannelPacket()
+{
+	TPacketGCChannel kChannelPacket;
+	if (!Recv(sizeof(kChannelPacket), &kChannelPacket))
+		return false;
+
+	// Tracef(" >> CPythonNetworkStream::RecvChannelPacket(channel=%d)\n", kChannelPacket.channel);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvViewEquipPacket()
+{
+	TPacketGCViewEquip kViewEquipPacket;
+	if (!Recv(sizeof(kViewEquipPacket), &kViewEquipPacket))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenEquipmentDialog", Py_BuildValue("(i)", kViewEquipPacket.dwVID));
+
+	for (BYTE bSlotIdx = 0; bSlotIdx < WEAR_MAX_NUM; ++bSlotIdx)
+	{
+		TEquipmentItemSet& rItemSet = kViewEquipPacket.Equips[bSlotIdx];
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetEquipmentDialogItem", Py_BuildValue(
+			"("
+			"i" // window
+			"i" // vid
+			"i" // slot_index
+			"i" // vnum
+			"i" // count
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+			"i" // change_look_vnum
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+			"(iiOO)" // refine_element
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+			"(OOOO)" // apply_random_list
+#endif
+#if defined(ENABLE_SET_ITEM)
+			"i" // set_value
+#endif
+			")"
+			, EQUIPMENT
+			, kViewEquipPacket.dwVID
+			, bSlotIdx
+			, rItemSet.dwVnum
+			, rItemSet.bCount
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+			, rItemSet.dwTransmutationVnum
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+			, rItemSet.RefineElement.wApplyType
+			, rItemSet.RefineElement.bGrade
+			, Py_BuildValue("iii",
+				rItemSet.RefineElement.abValue[0],
+				rItemSet.RefineElement.abValue[1],
+				rItemSet.RefineElement.abValue[2])
+			, Py_BuildValue("iii",
+				rItemSet.RefineElement.abBonusValue[0],
+				rItemSet.RefineElement.abBonusValue[1],
+				rItemSet.RefineElement.abBonusValue[2])
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+			, Py_BuildValue("ii", rItemSet.aApplyRandom[0].wType, rItemSet.aApplyRandom[0].lValue)
+			, Py_BuildValue("ii", rItemSet.aApplyRandom[1].wType, rItemSet.aApplyRandom[1].lValue)
+			, Py_BuildValue("ii", rItemSet.aApplyRandom[2].wType, rItemSet.aApplyRandom[2].lValue)
+			, Py_BuildValue("ii", rItemSet.aApplyRandom[3].wType, rItemSet.aApplyRandom[3].lValue)
+#endif
+#if defined(ENABLE_SET_ITEM)
+			, rItemSet.bSetValue
+#endif
+		));
+
+		for (BYTE bSocketIdx = 0; bSocketIdx < ITEM_SOCKET_SLOT_MAX_NUM; ++bSocketIdx)
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetEquipmentDialogSocket", Py_BuildValue("(iiiii)",
+				EQUIPMENT, kViewEquipPacket.dwVID, bSlotIdx, bSocketIdx, rItemSet.alSockets[bSocketIdx]));
+
+		for (BYTE bAttrIdx = 0; bAttrIdx < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++bAttrIdx)
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetEquipmentDialogAttr", Py_BuildValue("(iiiiii)",
+				EQUIPMENT, kViewEquipPacket.dwVID, bSlotIdx, bAttrIdx, rItemSet.aAttr[bAttrIdx].wType, rItemSet.aAttr[bAttrIdx].lValue));
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvLandPacket()
+{
+	TPacketGCLandList kLandList;
+	if (!Recv(sizeof(kLandList), &kLandList))
+		return false;
+
+	std::vector<DWORD> kVec_dwGuildID;
+
+	CPythonMiniMap& rkMiniMap = CPythonMiniMap::Instance();
+	CPythonBackground& rkBG = CPythonBackground::Instance();
+	CInstanceBase* pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();
+
+	rkMiniMap.ClearGuildArea();
+	rkBG.ClearGuildArea();
+
+	int iPacketSize = (kLandList.size - sizeof(TPacketGCLandList));
+	for (; iPacketSize > 0; iPacketSize -= sizeof(TLandPacketElement))
+	{
+		TLandPacketElement kElement;
+		if (!Recv(sizeof(TLandPacketElement), &kElement))
+			return false;
+
+		rkMiniMap.RegisterGuildArea(kElement.dwID,
+			kElement.dwGuildID,
+			kElement.x,
+			kElement.y,
+			kElement.width,
+			kElement.height);
+
+		if (pMainInstance)
+			if (kElement.dwGuildID == pMainInstance->GetGuildID())
+			{
+				rkBG.RegisterGuildArea(kElement.x,
+					kElement.y,
+					kElement.x + kElement.width,
+					kElement.y + kElement.height);
+			}
+
+		if (0 != kElement.dwGuildID)
+			kVec_dwGuildID.push_back(kElement.dwGuildID);
+	}
+
+	if (kVec_dwGuildID.size() > 0)
+		__DownloadSymbol(kVec_dwGuildID);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvTargetCreatePacket()
+{
+	TPacketGCTargetCreate kTargetCreate;
+	if (!Recv(sizeof(kTargetCreate), &kTargetCreate))
+		return false;
+
+#if defined(ENABLE_LOCALE_CLIENT)
+	CPythonLocale::Instance().FormatString(kTargetCreate.szTargetName, sizeof(kTargetCreate.szTargetName));
+#endif
+
+	CPythonMiniMap& rkpyMiniMap = CPythonMiniMap::Instance();
+	rkpyMiniMap.CreateTarget(kTargetCreate.lID, kTargetCreate.szTargetName);
+
+	//#ifdef _DEBUG
+	//	char szBuf[256+1];
+	//	_snprintf(szBuf, sizeof(szBuf), "Å¸  Ç¾Ï´ [%d:%s]", kTargetCreate.lID, kTargetCreate.szTargetName);
+	//	CPythonChat::Instance().AppendChat(CHAT_TYPE_NOTICE, szBuf);
+	//	Tracef(" >> RecvTargetCreatePacket %d : %s\n", kTargetCreate.lID, kTargetCreate.szTargetName);
+	//#endif
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_OpenAtlasWindow", Py_BuildValue("()"));
+	return true;
+}
+
+bool CPythonNetworkStream::RecvTargetCreatePacketNew()
+{
+	TPacketGCTargetCreateNew kTargetCreate;
+	if (!Recv(sizeof(kTargetCreate), &kTargetCreate))
+		return false;
+
+#if defined(ENABLE_LOCALE_CLIENT)
+	CPythonLocale::Instance().FormatString(kTargetCreate.szTargetName, sizeof(kTargetCreate.szTargetName));
+#endif
+
+	CPythonMiniMap& rkpyMiniMap = CPythonMiniMap::Instance();
+	CPythonBackground& rkpyBG = CPythonBackground::Instance();
+	if (CREATE_TARGET_TYPE_LOCATION == kTargetCreate.byType)
+	{
+		rkpyMiniMap.CreateTarget(kTargetCreate.lID, kTargetCreate.szTargetName);
+	}
+	else
+	{
+		rkpyMiniMap.CreateTarget(kTargetCreate.lID, kTargetCreate.szTargetName, kTargetCreate.dwVID);
+		rkpyBG.CreateTargetEffect(kTargetCreate.lID, kTargetCreate.dwVID);
+	}
+
+	//#ifdef _DEBUG
+	//	char szBuf[256+1];
+	//	_snprintf(szBuf, sizeof(szBuf), "Ä³ Å¸  Ç¾Ï´ [%d:%s:%d]", kTargetCreate.lID, kTargetCreate.szTargetName, kTargetCreate.dwVID);
+	//	CPythonChat::Instance().AppendChat(CHAT_TYPE_NOTICE, szBuf);
+	//	Tracef(" >> RecvTargetCreatePacketNew %d : %d/%d\n", kTargetCreate.lID, kTargetCreate.byType, kTargetCreate.dwVID);
+	//#endif
+
+	//PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_OpenAtlasWindow", Py_BuildValue("()"));
+	return true;
+}
+
+bool CPythonNetworkStream::RecvTargetUpdatePacket()
+{
+	TPacketGCTargetUpdate kTargetUpdate;
+	if (!Recv(sizeof(kTargetUpdate), &kTargetUpdate))
+		return false;
+
+	CPythonMiniMap& rkpyMiniMap = CPythonMiniMap::Instance();
+	rkpyMiniMap.UpdateTarget(kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
+
+	CPythonBackground& rkpyBG = CPythonBackground::Instance();
+
+	rkpyBG.CreateTargetEffect(kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
+
+	//#ifdef _DEBUG
+	//	char szBuf[256+1];
+	//	_snprintf(szBuf, sizeof(szBuf), "Å¸ Ä¡  Ç¾Ï´ [%d:%d/%d]", kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
+	//	CPythonChat::Instance().AppendChat(CHAT_TYPE_NOTICE, szBuf);
+	//	Tracef(" >> RecvTargetUpdatePacket %d : %d, %d\n", kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
+	//#endif
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvTargetDeletePacket()
+{
+	TPacketGCTargetDelete kTargetDelete;
+	if (!Recv(sizeof(kTargetDelete), &kTargetDelete))
+		return false;
+
+	CPythonMiniMap& rkpyMiniMap = CPythonMiniMap::Instance();
+	rkpyMiniMap.DeleteTarget(kTargetDelete.lID);
+
+	CPythonBackground& rkpyBG = CPythonBackground::Instance();
+	rkpyBG.DeleteTargetEffect(kTargetDelete.lID);
+
+	//#ifdef _DEBUG
+	//	Tracef(" >> RecvTargetDeletePacket %d\n", kTargetDelete.lID);
+	//#endif
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvLoverInfoPacket()
+{
+	TPacketGCLoverInfo kLoverInfo;
+	if (!Recv(sizeof(kLoverInfo), &kLoverInfo))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_LoverInfo", Py_BuildValue("(si)", kLoverInfo.szName, kLoverInfo.byLovePoint));
+#ifdef _DEBUG
+	Tracef("RECV LOVER INFO : %s, %d\n", kLoverInfo.szName, kLoverInfo.byLovePoint);
+#endif
+	return true;
+}
+
+bool CPythonNetworkStream::RecvLovePointUpdatePacket()
+{
+	TPacketGCLovePointUpdate kLovePointUpdate;
+	if (!Recv(sizeof(kLovePointUpdate), &kLovePointUpdate))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_UpdateLovePoint", Py_BuildValue("(i)", kLovePointUpdate.byLovePoint));
+#ifdef _DEBUG
+	Tracef("RECV LOVE POINT UPDATE : %d\n", kLovePointUpdate.byLovePoint);
+#endif
+	return true;
+}
+
+bool CPythonNetworkStream::RecvDigMotionPacket()
+{
+	TPacketGCDigMotion kDigMotion;
+	if (!Recv(sizeof(kDigMotion), &kDigMotion))
+		return false;
+
+#ifdef _DEBUG
+	Tracef(" Dig Motion [%d/%d]\n", kDigMotion.vid, kDigMotion.count);
+#endif
+
+	IAbstractCharacterManager& rkChrMgr = IAbstractCharacterManager::GetSingleton();
+	CInstanceBase* pkInstMain = rkChrMgr.GetInstancePtr(kDigMotion.vid);
+	CInstanceBase* pkInstTarget = rkChrMgr.GetInstancePtr(kDigMotion.target_vid);
+	if (NULL == pkInstMain)
+		return true;
+
+	if (pkInstTarget)
+		pkInstMain->NEW_LookAtDestInstance(*pkInstTarget);
+
+	for (int i = 0; i < kDigMotion.count; ++i)
+		pkInstMain->PushOnceMotion(CRaceMotionData::NAME_DIG);
+
+	return true;
+}
+
+#if defined(ENABLE_DRAGON_SOUL_SYSTEM)
+// È¥ È­
+bool CPythonNetworkStream::SendDragonSoulRefinePacket(BYTE bRefineType, TItemPos* pos)
+{
+	TPacketCGDragonSoulRefine pk;
+	pk.header = HEADER_CG_DRAGON_SOUL_REFINE;
+	pk.bSubType = bRefineType;
+	memcpy(pk.ItemGrid, pos, sizeof(TItemPos) * DS_REFINE_WINDOW_MAX_NUM);
+	if (!Send(sizeof(pk), &pk))
+	{
+		return false;
+	}
+	return true;
+}
+#endif
+
+#if defined(ENABLE_SKILLBOOK_COMB_SYSTEM)
+bool CPythonNetworkStream::SendSkillBookCombinationPacket(TItemPos* pPos, BYTE bAction)
+{
+	TPacketCGSkillBookCombination SkillBookCombCGPacket;
+	SkillBookCombCGPacket.bHeader = HEADER_CG_SKILLBOOK_COMB;
+	SkillBookCombCGPacket.bAction = bAction;
+	memcpy(SkillBookCombCGPacket.CombItemGrid, pPos, sizeof(TItemPos) * SKILLBOOK_COMB_SLOT_MAX);
+
+	if (!Send(sizeof(SkillBookCombCGPacket), &SkillBookCombCGPacket))
+		return false;
+
+	return true;
+}
+#endif
+
+#if defined(ENABLE_MINI_GAME_CATCH_KING)
+bool CPythonNetworkStream::SendMiniGameCatchKing(BYTE bSubHeader, BYTE bSubArgument)
+{
+	if (!__CanActMainInstance())
+		return true;
+
+	TPacketCGMiniGameCatchKing packet;
+	packet.bHeader = HEADER_CG_MINI_GAME_CATCH_KING;
+	packet.bSubHeader = bSubHeader;
+	packet.bSubArgument = bSubArgument;
+
+	if (!Send(sizeof(TPacketCGMiniGameCatchKing), &packet))
+	{
+		Tracef("SendMiniGameCatchKing Send Packet Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvMiniGameCatchKingPacket()
+{
+	std::vector<char> vPacketBuffer;
+	vPacketBuffer.clear();
+
+	TPacketGCMiniGameCatchKing Packet;
+	if (!Recv(sizeof(Packet), &Packet))
+		return false;
+
+	unsigned int uiPacketSize = Packet.wSize - sizeof(Packet);
+	if (uiPacketSize > 0)
+	{
+		vPacketBuffer.resize(uiPacketSize);
+		if (!Recv(uiPacketSize, &vPacketBuffer[0]))
+			return false;
+	}
+
+	switch (Packet.bSubHeader)
+	{
+		case CATCHKING_GC_START:
+		{
+			DWORD dwBigScore = *(DWORD*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameCatchKingEventStart", Py_BuildValue("(i)", dwBigScore));
+		}
+		break;
+
+		case CATCHKING_GC_SET_CARD:
+		{
+			BYTE bCardNumber = *(BYTE*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameCatchKingSetHandCard", Py_BuildValue("(i)", bCardNumber));
+		}
+		break;
+
+		case CATCHKING_GC_RESULT_FIELD:
+		{
+			TPacketGCMiniGameCatchKingResult* pkData = (TPacketGCMiniGameCatchKingResult*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameCatchKingResultField", Py_BuildValue("(iiiibbbb)",
+				pkData->dwPoints, pkData->bRowType, pkData->bCardPos, pkData->bCardValue,
+				pkData->bKeepFieldCard, pkData->bDestroyHandCard, pkData->bGetReward, pkData->bIsFiveNearBy));
+		}
+		break;
+
+		case CATCHKING_GC_SET_END_CARD:
+		{
+			TPacketGCMiniGameCatchKingSetEndCard* pkData = (TPacketGCMiniGameCatchKingSetEndCard*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameCatchKingSetEndCard", Py_BuildValue("(ii)",
+				pkData->bCardPos, pkData->bCardValue));
+		}
+		break;
+
+		case CATCHKING_GC_REWARD:
+		{
+			BYTE bReturnCode = *(BYTE*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameCatchKingReward", Py_BuildValue("(i)", bReturnCode));
+		}
+		break;
+
+#if defined(ENABLE_CATCH_KING_EVENT_FLAG_RENEWAL)
+		case CATCHKING_GC_SET_CARD_PIECE_FLAG:
+		case CATCHKING_GC_SET_CARD_FLAG:
+		case CATCHKING_GC_SET_QUEST_FLAG:
+		case CATCHKING_GC_NO_MORE_GAIN:
+		{
+			TPacketGCMiniGameCatchKingQuestFlag* pkData = (TPacketGCMiniGameCatchKingQuestFlag*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CatchKingFlagProcess", Py_BuildValue("(i(ii))",
+				Packet.bSubHeader, pkData->wPieceCount, pkData->wPackCount));
+		}
+		break;
+#endif
+
+		default:
+			TraceError("CPythonNetworkStream::RecvMiniGameCatchKingPacket: Unknown SubHeader %d\n", Packet.bSubHeader);
+			break;
+	}
+
+	return true;
+}
+
+#if defined(ENABLE_CATCH_KING_EVENT_FLAG_RENEWAL)
+bool CPythonNetworkStream::SendMiniGameCatchKingRequestQuestFlag()
+{
+	TPacketCGMiniGameCatchKing Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_CATCH_KING;
+	Packet.bSubHeader = CATCHKING_CG_REQUEST_QUEST_FLAG;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameCatchKingRequestQuestFlag Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+#endif
+#endif
+
+#if defined(ENABLE_ACCE_COSTUME_SYSTEM)
+bool CPythonNetworkStream::RecvAcceRefinePacket()
+{
+	TPacketGCAcceRefine Packet;
+	if (!Recv(sizeof(TPacketGCAcceRefine), &Packet))
+	{
+		Tracef("CPythonNetworkStream::RecvAcceRefinePacket Error\n");
+		return false;
+	}
+
+	UINT uiPacketSize = (Packet.wSize - sizeof(TPacketGCAcceRefine));
+	switch (Packet.bSubHeader)
+	{
+		case ACCE_REFINE_SUBHEADER_GC_CLOSE:
+		case ACCE_REFINE_SUBHEADER_GC_OPEN:
+		{
+			if (uiPacketSize > 0)
+			{
+				TSubPacketGCAcceRefineOpenClose SubPacket;
+				assert(uiPacketSize % sizeof(TSubPacketGCAcceRefineOpenClose) == 0 && "ACCE_REFINE_SUBHEADER_GC_CLOSE | ACCE_REFINE_SUBHEADER_GC_OPEN");
+				if (!Recv(sizeof(TSubPacketGCAcceRefineOpenClose), &SubPacket))
+					return false;
+
+				if (Packet.bSubHeader == ACCE_REFINE_SUBHEADER_GC_CLOSE)
+				{
+					if (SubPacket.bServerClose)
+						PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseAcceWindow", Py_BuildValue("()"));
+
+					for (BYTE bSlotIndex = ACCE_SLOT_LEFT; bSlotIndex < ACCE_SLOT_MAX; ++bSlotIndex)
+						CPythonPlayer::Instance().DelAcceItemData(bSlotIndex);
+				}
+				else if (Packet.bSubHeader == ACCE_REFINE_SUBHEADER_GC_OPEN)
+				{
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenAcceWindow", Py_BuildValue("(i)", SubPacket.bType));
+				}
+
+				CPythonPlayer::Instance().SetAcceRefineWindowType(SubPacket.bType);
+			}
+			else
+				TraceError("CPythonNetworkStream::RecvAcceRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
+		}
+		break;
+
+		case ACCE_REFINE_SUBHEADER_GC_SET_ITEM:
+		{
+			if (uiPacketSize > 0)
+			{
+				TSubPacketGCAcceRefineSetItem SubPacket;
+				assert(uiPacketSize % sizeof(TSubPacketGCAcceRefineSetItem) == 0 && "ACCE_REFINE_SUBHEADER_GC_SET_ITEM");
+				if (!Recv(sizeof(TSubPacketGCAcceRefineSetItem), &SubPacket))
+					return false;
+
+				TItemData ItemData = {};
+				ItemData.dwVnum = SubPacket.Item.dwVnum;
+				ItemData.dwCount = SubPacket.Item.dwCount;
+				for (BYTE bSocketIndex = 0; bSocketIndex < ITEM_SOCKET_SLOT_MAX_NUM; ++bSocketIndex)
+					ItemData.alSockets[bSocketIndex] = SubPacket.Item.alSockets[bSocketIndex];
+				for (BYTE bAttrIndex = 0; bAttrIndex < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++bAttrIndex)
+					ItemData.aAttr[bAttrIndex] = SubPacket.Item.aAttr[bAttrIndex];
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+				ItemData.dwTransmutationVnum = SubPacket.Item.dwTransmutationVnum;
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+				ItemData.RefineElement = SubPacket.Item.RefineElement;
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+				for (BYTE bApplyIndex = 0; bApplyIndex < ITEM_APPLY_RANDOM_SLOT_MAX_NUM; ++bApplyIndex)
+					ItemData.aApplyRandom[bApplyIndex] = SubPacket.Item.aApplyRandom[bApplyIndex];
+#endif
+#if defined(ENABLE_SET_ITEM)
+				ItemData.bSetValue = SubPacket.Item.bSetValue;
+#endif
+
+				if (SubPacket.AttachedPos.IsValidCell() && !SubPacket.AttachedPos.IsEquipCell())
+					CPythonPlayer::Instance().SetActivatedAcceSlot(static_cast<BYTE>(SubPacket.SelectedPos.cell), SubPacket.AttachedPos);
+
+				CPythonPlayer::Instance().SetAcceItemData(static_cast<BYTE>(SubPacket.SelectedPos.cell), ItemData);
+			}
+			else
+				TraceError("CPythonNetworkStream::RecvAcceRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
+		}
+		break;
+
+		case ACCE_REFINE_SUBHEADER_GC_CLEAR_SLOT:
+		{
+			if (uiPacketSize > 0)
+			{
+				TSubPacketGCAcceRefineClearSlot SubPacket;
+				assert(uiPacketSize % sizeof(TSubPacketGCAcceRefineClearSlot) == 0 && "ACCE_REFINE_SUBHEADER_GC_CLEAR_SLOT");
+				if (!Recv(sizeof(TSubPacketGCAcceRefineClearSlot), &SubPacket))
+					return false;
+
+				CPythonPlayer::Instance().DelAcceItemData(SubPacket.bSlotIndex);
+			}
+			else
+				TraceError("CPythonNetworkStream::RecvAcceRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
+		}
+		break;
+
+		case ACCE_REFINE_SUBHEADER_GC_CLEAR_ALL:
+		{
+			for (BYTE bSlotIndex = ACCE_SLOT_LEFT; bSlotIndex < ACCE_SLOT_MAX; ++bSlotIndex)
+				CPythonPlayer::Instance().DelAcceItemData(bSlotIndex);
+		}
+		break;
+	}
+
+	__RefreshInventoryWindow();
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendAcceRefineCheckIn(TItemPos AttachedPos, TItemPos SelectedPos, BYTE bType)
+{
+	__PlayInventoryItemDropSound(AttachedPos);
+
+	TPacketCGAcceRefine Packet;
+	Packet.wSize = sizeof(TPacketCGAcceRefine) + sizeof(TSubPacketCGAcceRefineCheckIn);
+	Packet.bSubHeader = ACCE_REFINE_SUBHEADER_CG_CHECKIN;
+
+	TSubPacketCGAcceRefineCheckIn SubPacket;
+	SubPacket.AttachedPos = AttachedPos;
+	SubPacket.SelectedPos = SelectedPos;
+	SubPacket.bType = bType;
+
+	if (!Send(sizeof(TPacketCGAcceRefine), &Packet))
+		return false;
+
+	if (!Send(sizeof(TSubPacketCGAcceRefineCheckIn), &SubPacket))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendAcceRefineCheckOut(TItemPos SelectedPos, BYTE bType)
+{
+	TPacketCGAcceRefine Packet;
+	Packet.wSize = sizeof(TPacketCGAcceRefine) + sizeof(TSubPacketCGAcceRefineCheckOut);
+	Packet.bSubHeader = ACCE_REFINE_SUBHEADER_CG_CHECKOUT;
+
+	TSubPacketCGAcceRefineCheckOut SubPacket;
+	SubPacket.SelectedPos = SelectedPos;
+	SubPacket.bType = bType;
+
+	if (!Send(sizeof(TPacketCGAcceRefine), &Packet))
+		return false;
+
+	if (!Send(sizeof(TSubPacketCGAcceRefineCheckOut), &SubPacket))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendAcceRefineAccept(BYTE bType)
+{
+	TPacketCGAcceRefine Packet;
+	Packet.wSize = sizeof(TPacketCGAcceRefine) + sizeof(TSubPacketCGAcceRefineAccept);
+	Packet.bSubHeader = ACCE_REFINE_SUBHEADER_CG_ACCEPT;
+
+	TSubPacketCGAcceRefineAccept SubPacket;
+	SubPacket.bType = bType;
+
+	if (!Send(sizeof(TPacketCGAcceRefine), &Packet))
+		return false;
+
+	if (!Send(sizeof(TSubPacketCGAcceRefineAccept), &SubPacket))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendAcceRefineCancel()
+{
+	TPacketCGAcceRefine Packet;
+	Packet.wSize = sizeof(TPacketCGAcceRefine);
+	Packet.bSubHeader = ACCE_REFINE_SUBHEADER_CG_CANCEL;
+
+	if (!Send(sizeof(TPacketCGAcceRefine), &Packet))
+		return false;
+
+	return SendSequence();
+}
+#endif
+
+#if defined(ENABLE_AURA_COSTUME_SYSTEM)
+bool CPythonNetworkStream::RecvAuraRefinePacket()
+{
+	TPacketGCAuraRefine Packet;
+	if (!Recv(sizeof(TPacketGCAuraRefine), &Packet))
+	{
+		Tracef("CPythonNetworkStream::RecvAuraRefinePacket Error\n");
+		return false;
+	}
+
+	UINT uiPacketSize = (Packet.wSize - sizeof(TPacketGCAuraRefine));
+	switch (Packet.bSubHeader)
+	{
+		case AURA_REFINE_SUBHEADER_GC_CLOSE:
+		case AURA_REFINE_SUBHEADER_GC_OPEN:
+		{
+			if (uiPacketSize > 0)
+			{
+				TSubPacketGCAuraRefineOpenClose SubPacket;
+				assert(uiPacketSize % sizeof(TSubPacketGCAuraRefineOpenClose) == 0 && "AURA_REFINE_SUBHEADER_CG_CLOSE | AURA_REFINE_SUBHEADER_CG_OPEN");
+				if (!Recv(sizeof(TSubPacketGCAuraRefineOpenClose), &SubPacket))
+					return false;
+
+				if (Packet.bSubHeader == AURA_REFINE_SUBHEADER_GC_CLOSE)
+				{
+					if (SubPacket.bServerClose)
+						PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseAuraWindow", Py_BuildValue("()"));
+
+					for (BYTE bSlotIndex = AURA_SLOT_MAIN; bSlotIndex < AURA_SLOT_MAX; ++bSlotIndex)
+						CPythonPlayer::Instance().DelAuraItemData(bSlotIndex);
+				}
+				else if (Packet.bSubHeader == AURA_REFINE_SUBHEADER_GC_OPEN)
+				{
+					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenAuraWindow", Py_BuildValue("(i)", SubPacket.bType));
+				}
+
+				CPythonPlayer::Instance().SetAuraWindowType(SubPacket.bType);
+			}
+			else
+				TraceError("CPythonNetworkStream::RecvAuraRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
+		}
+		break;
+
+		case AURA_REFINE_SUBHEADER_GC_SET_ITEM:
+		{
+			if (uiPacketSize > 0)
+			{
+				TSubPacketGCAuraRefineSetItem SubPacket;
+				assert(uiPacketSize % sizeof(TSubPacketGCAuraRefineSetItem) == 0 && "AURA_REFINE_SUBHEADER_GC_SET_ITEM");
+				if (!Recv(sizeof(TSubPacketGCAuraRefineSetItem), &SubPacket))
+					return false;
+
+				TItemData ItemData = {};
+				ItemData.dwVnum = SubPacket.Item.dwVnum;
+				ItemData.dwCount = SubPacket.Item.dwCount;
+				for (BYTE bSocketIndex = 0; bSocketIndex < ITEM_SOCKET_SLOT_MAX_NUM; ++bSocketIndex)
+					ItemData.alSockets[bSocketIndex] = SubPacket.Item.alSockets[bSocketIndex];
+				for (BYTE bAttrIndex = 0; bAttrIndex < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++bAttrIndex)
+					ItemData.aAttr[bAttrIndex] = SubPacket.Item.aAttr[bAttrIndex];
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+				ItemData.dwTransmutationVnum = SubPacket.Item.dwTransmutationVnum;
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+				for (BYTE bApplyIndex = 0; bApplyIndex < ITEM_APPLY_RANDOM_SLOT_MAX_NUM; ++bApplyIndex)
+					ItemData.aApplyRandom[bApplyIndex] = SubPacket.Item.aApplyRandom[bApplyIndex];
+#endif
+#if defined(ENABLE_SET_ITEM)
+				ItemData.bSetValue = SubPacket.Item.bSetValue;
+#endif
+
+				if (SubPacket.AttachedPos.IsValidCell() && !SubPacket.AttachedPos.IsEquipCell())
+					CPythonPlayer::Instance().SetActivatedAuraSlot(static_cast<BYTE>(SubPacket.SelectedPos.cell), SubPacket.AttachedPos);
+
+				CPythonPlayer::Instance().SetAuraItemData(static_cast<BYTE>(SubPacket.SelectedPos.cell), ItemData);
+			}
+			else
+				TraceError("CPythonNetworkStream::RecvAuraRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
+		}
+		break;
+
+		case AURA_REFINE_SUBHEADER_GC_CLEAR_SLOT:
+		{
+			if (uiPacketSize > 0)
+			{
+				TSubPacketGCAuraRefineClearSlot SubPacket;
+				assert(uiPacketSize % sizeof(TSubPacketGCAuraRefineClearSlot) == 0 && "AURA_REFINE_SUBHEADER_GC_CLEAR_SLOT");
+				if (!Recv(sizeof(TSubPacketGCAuraRefineClearSlot), &SubPacket))
+					return false;
+
+				CPythonPlayer::Instance().DelAuraItemData(SubPacket.bSlotIndex);
+			}
+			else
+				TraceError("CPythonNetworkStream::RecvAuraRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
+		}
+		break;
+
+		case AURA_REFINE_SUBHEADER_GC_CLEAR_ALL:
+		{
+			for (BYTE bSlotIndex = AURA_SLOT_MAIN; bSlotIndex < AURA_SLOT_MAX; ++bSlotIndex)
+				CPythonPlayer::Instance().DelAuraItemData(bSlotIndex);
+		}
+		break;
+
+		case AURA_REFINE_SUBHEADER_GC_INFO:
+		{
+			if (uiPacketSize > 0)
+			{
+				for (UINT uiPacketOffset = 0; uiPacketSize > 0; ++uiPacketOffset)
+				{
+					assert(uiPacketSize % sizeof(TSubPacketGCAuraRefineInfo) == 0 && "AURA_REFINE_SUBHEADER_GC_INFO");
+					TSubPacketGCAuraRefineInfo SubPacket;
+					if (!Recv(sizeof(TSubPacketGCAuraRefineInfo), &SubPacket))
+						return false;
+
+					CPythonPlayer::Instance().SetAuraRefineInfo(SubPacket.bInfoType, SubPacket.bInfoLevel, SubPacket.bInfoExpPercent);
+					uiPacketSize -= sizeof(TSubPacketGCAuraRefineInfo);
+				}
+			}
+			else
+				TraceError("CPythonNetworkStream::RecvAuraRefinePacket - Empty Packet Size SubHeader %d", Packet.bSubHeader);
+		}
+		break;
+	}
+
+	__RefreshInventoryWindow();
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendAuraRefineCheckIn(TItemPos AttachedPos, TItemPos SelectedPos, BYTE bType)
+{
+	__PlayInventoryItemDropSound(AttachedPos);
+
+	TPacketCGAuraRefine Packet;
+	Packet.wSize = sizeof(TPacketCGAuraRefine) + sizeof(TSubPacketCGAuraRefineCheckIn);
+	Packet.bSubHeader = AURA_REFINE_SUBHEADER_CG_CHECKIN;
+
+	TSubPacketCGAuraRefineCheckIn SubPacket;
+	SubPacket.AttachedPos = AttachedPos;
+	SubPacket.SelectedPos = SelectedPos;
+	SubPacket.bType = bType;
+
+	if (!Send(sizeof(TPacketCGAuraRefine), &Packet))
+		return false;
+
+	if (!Send(sizeof(TSubPacketCGAuraRefineCheckIn), &SubPacket))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendAuraRefineCheckOut(TItemPos SelectedPos, BYTE bType)
+{
+	TPacketCGAuraRefine Packet;
+	Packet.wSize = sizeof(TPacketCGAuraRefine) + sizeof(TSubPacketCGAuraRefineCheckOut);
+	Packet.bSubHeader = AURA_REFINE_SUBHEADER_CG_CHECKOUT;
+
+	TSubPacketCGAuraRefineCheckOut SubPacket;
+	SubPacket.SelectedPos = SelectedPos;
+	SubPacket.bType = bType;
+
+	if (!Send(sizeof(TPacketCGAuraRefine), &Packet))
+		return false;
+
+	if (!Send(sizeof(TSubPacketCGAuraRefineCheckOut), &SubPacket))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendAuraRefineAccept(BYTE bType)
+{
+	TPacketCGAuraRefine Packet;
+	Packet.wSize = sizeof(TPacketCGAuraRefine) + sizeof(TSubPacketCGAuraRefineAccept);
+	Packet.bSubHeader = AURA_REFINE_SUBHEADER_CG_ACCEPT;
+
+	TSubPacketCGAuraRefineAccept SubPacket;
+	SubPacket.bType = bType;
+
+	if (!Send(sizeof(TPacketCGAuraRefine), &Packet))
+		return false;
+
+	if (!Send(sizeof(TSubPacketCGAuraRefineAccept), &SubPacket))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendAuraRefineCancel()
+{
+	TPacketCGAuraRefine Packet;
+	Packet.wSize = sizeof(TPacketCGAuraRefine);
+	Packet.bSubHeader = AURA_REFINE_SUBHEADER_CG_CANCEL;
+
+	if (!Send(sizeof(TPacketCGAuraRefine), &Packet))
+		return false;
+
+	return SendSequence();
+}
+#endif
+
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+#define ChangeLookPacket(x) TPacketCGChangeLook Packet(static_cast<std::underlying_type_t<EPacketCGChangeLookSubHeader>>(EPacketCGChangeLookSubHeader::x))
+
+bool CPythonNetworkStream::SendChangeLookCheckInPacket(const TItemPos& c_rItemPos, const BYTE c_bSlotIndex)
+{
+	ChangeLookPacket(ITEM_CHECK_IN);
+	Packet.bSlotIndex = c_bSlotIndex;
+	Packet.ItemPos = c_rItemPos;
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("CPythonNetworkStream::SendChangeLookCheckInPacket Error\n");
+		return false;
+	}
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendChangeLookCheckOutPacket(const BYTE c_bSlotIndex)
+{
+	ChangeLookPacket(ITEM_CHECK_OUT);
+	Packet.bSlotIndex = c_bSlotIndex;
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("CPythonNetworkStream::SendChangeLookCheckOutPacket Error\n");
+		return false;
+	}
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendChangeLookCheckInFreeYangItemPacket(const TItemPos& c_rItemPos)
+{
+	ChangeLookPacket(FREE_ITEM_CHECK_IN);
+	Packet.ItemPos = c_rItemPos;
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("CPythonNetworkStream::SendChangeLookCheckInFreeYangItemPacket Error\n");
+		return false;
+	}
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendChangeLookCheckOutFreeYangItemPacket()
+{
+	ChangeLookPacket(FREE_ITEM_CHECK_OUT);
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("CPythonNetworkStream::SendChangeLookCheckOutFreeYangItemPacket Error\n");
+		return false;
+	}
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendChangeLookAcceptPacket()
+{
+	ChangeLookPacket(ACCEPT);
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("CPythonNetworkStream::SendChangeLookAcceptPacket Error\n");
+		return false;
+	}
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendChangeLookCancelPacket()
+{
+	ChangeLookPacket(CANCEL);
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("CPythonNetworkStream::SendChangeLookCancelPacket Error\n");
+		return false;
+	}
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvChangeLookItemSetPacket()
+{
+	TPacketGCChangeLookSet kItemSet;
+	if (!Recv(sizeof(kItemSet), &kItemSet))
+		return false;
+
+	if (kItemSet.bSlotIndex >= static_cast<BYTE>(EChangeLookSlots::CHANGE_LOOK_SLOT_MAX))
+		return true;
+
+	CPythonPlayer::Instance().SetChangeLookItemData(kItemSet);
+	__RefreshInventoryWindow();
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvChangeLookItemDelPacket()
+{
+	TPacketGCChangeLookDel kItemDel;
+	if (!Recv(sizeof(kItemDel), &kItemDel))
+		return false;
+
+	CPythonPlayer::Instance().DelChangeLookItemData(kItemDel.bSlotIndex, true);
+	__RefreshInventoryWindow();
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvChangeLookFreeItemSetPacket()
+{
+	TPacketGCChangeLookSet kItemSet;
+	if (!Recv(sizeof(kItemSet), &kItemSet))
+		return false;
+
+	CPythonPlayer::Instance().SetChangeLookFreeItemData(kItemSet);
+	__RefreshInventoryWindow();
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvChangeLookFreeItemDelPacket()
+{
+	TPacketGCChangeLookDel kItemDel;
+	if (!Recv(sizeof(kItemDel), &kItemDel))
+		return false;
+
+	CPythonPlayer::Instance().DelChangeLookFreeItemData(true);
+	__RefreshInventoryWindow();
+
+	return true;
+}
+#endif
+
+#if defined(ENABLE_MAILBOX)
+bool CPythonNetworkStream::RecvMailboxProcess()
+{
+	TPacketMailboxProcess p;
+
+	if (!Recv(sizeof(p), &p))
+		return false;
+
+	switch (p.bSubHeader)
+	{
+		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_CLOSE:
+			CPythonMailBox::Instance().Destroy();
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("(ii)", p.bSubHeader, p.bArg1));
+			break;
+		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_OPEN:
+		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_WRITE_CONFIRM:
+		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_WRITE:
+		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_ALL_DELETE:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("(ii)", p.bSubHeader, p.bArg1));
+			break;
+		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_ADD_DATA:
+		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_DELETE:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("(i(ii))", p.bSubHeader, p.bArg1, p.bArg2));
+			break;
+		case CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_GET_ITEMS:
+			CPythonMailBox::Instance().ResetAddData(p.bArg1);
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("(i(ii))", p.bSubHeader, p.bArg1, p.bArg2));
+			break;
+		default:
+			TraceError("CPythonNetworkStream::RecvMailboxProcess: Unknown subheader: %d\n", p.bSubHeader);
+			break;
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvMailbox()
+{
+	TPacketGCMailBox p;
+	if (!Recv(sizeof(p), &p))
+		return false;
+
+	CPythonMailBox::Instance().Destroy();
+
+	unsigned int iPacketSize = (p.wSize - sizeof(TPacketGCMailBox));
+	for (; iPacketSize > 0; iPacketSize -= sizeof(TPacketGCMailBoxMessage))
+	{
+		TPacketGCMailBoxMessage Message;
+		if (!Recv(sizeof(Message), &Message))
+			return false;
+
+#if defined(ENABLE_LOCALE_CLIENT)
+		if (Message.bIsGMPost)
+			CPythonLocale::Instance().FormatString(Message.szTitle, sizeof(Message.szTitle));
+#endif
+
+		CPythonMailBox::Instance().AddMail(new CPythonMailBox::SMailBox(Message.SendTime, Message.DeleteTime, Message.szTitle, Message.bIsGMPost, Message.bIsItemExist, Message.bIsConfirm));
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvMailboxAddData()
+{
+	TPacketGCMailBoxAddData p;
+
+	if (!Recv(sizeof(p), &p))
+		return false;
+
+	CPythonMailBox::SMailBox* _Data = CPythonMailBox::Instance().GetMail(p.Index);
+	if (_Data == nullptr)
+	{
+		Tracef("RecvMailboxAddData Error: SMailBox is null.\n");
+		return true;
+	}
+
+	CPythonMailBox::SMailBoxAddData*& _AddData = _Data->AddData;
+	if (_AddData != nullptr)
+	{
+		Tracef("RecvMailboxAddData Error: SMailBoxAddData is not null.\n");
+		return true;
+	}
+
+	_Data->bIsConfirm = true;
+	_AddData = new CPythonMailBox::SMailBoxAddData(p.szFrom, p.szMessage, p.iYang, p.iWon, p.dwItemVnum, p.dwItemCount, p.alSockets, p.aAttr
+#if defined(ENABLE_CHANGE_LOOK_SYSTEM)
+		, p.dwChangeLookVnum
+#endif
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+		, &p.RefineElement
+#endif
+#if defined(ENABLE_APPLY_RANDOM)
+		, p.aApplyRandom
+#endif
+#if defined(ENABLE_SET_ITEM)
+		, p.bSetValue
+#endif
+	);
+	return true;
+}
+
+bool CPythonNetworkStream::RecvMailboxAll()
+{
+	TPacketGCMailBox p;
+	if (!Recv(sizeof(p), &p))
+		return false;
+
+	// Safety: prevent unsigned underflow and wraparound loops on malformed sizes
+	if (p.wSize < sizeof(TPacketGCMailBox))
+		return false;
+
+	const unsigned int payloadSize = (p.wSize - sizeof(TPacketGCMailBox));
+	if (payloadSize % sizeof(TPacketGCMailboxProcessAll) != 0)
+		return false;
+
+	PyObject* list = PyList_New(0);
+
+	unsigned int iPacketSize = payloadSize;
+	for (; iPacketSize > 0; iPacketSize -= sizeof(TPacketGCMailboxProcessAll))
+	{
+		TPacketGCMailboxProcessAll Index;
+		if (!Recv(sizeof(Index), &Index))
+			return false;
+
+		CPythonMailBox::Instance().ResetAddData(Index.Index);
+		PyList_Append(list, Py_BuildValue("i", Index.Index));
+	}
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("i(iO)",
+		CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_POST_ALL_GET_ITEMS, CPythonMailBox::EMAILBOX_POST_ALL_GET_ITEMS::POST_ALL_GET_ITEMS_OK, list));
+
+	Py_DECREF(list);
+	return true;
+}
+
+bool CPythonNetworkStream::RecvMailboxUnread()
+{
+	TMailBoxRespondUnreadData p;
+
+	if (!Recv(sizeof(p), &p))
+		return false;
+
+	const bool bFlash = p.bItemMessageCount > 0;
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MailBoxProcess", Py_BuildValue("i(iiiii)", CPythonMailBox::EMAILBOX_GC::MAILBOX_GC_UNREAD_DATA,
+		bFlash, (p.bItemMessageCount + p.bCommonMessageCount), p.bItemMessageCount, p.bCommonMessageCount, p.bGMVisible));
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendPostWriteConfirm(const char* szName)
+{
+	TPacketCGMailboxWriteConfirm p;
+	p.bHeader = HEADER_CG_MAILBOX_WRITE_CONFIRM;
+	strncpy(p.szName, szName, sizeof(p.szName) - 1);
+	p.szName[sizeof(p.szName) - 1] = '\0';
+
+	if (!Send(sizeof(p), &p))
+	{
+		Tracef("SendPostWriteConfirm Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMailBoxClose()
+{
+	TPacketMailboxProcess p;
+	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
+	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_CLOSE;
+
+	if (!Send(sizeof(p), &p))
+	{
+		Tracef("SendMailBoxClose Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPostDelete(const BYTE Index)
+{
+	TPacketMailboxProcess p;
+	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
+	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_DELETE;
+	p.bArg1 = Index;
+
+	if (!Send(sizeof(p), &p))
+	{
+		Tracef("SendPostDelete Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPostAllDelete()
+{
+	TPacketMailboxProcess p;
+	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
+	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_DELETE;
+
+	if (!Send(sizeof(p), &p))
+	{
+		Tracef("SendPostAllDelete Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPostGetItems(const BYTE Index)
+{
+	TPacketMailboxProcess p;
+	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
+	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_GET_ITEMS;
+	p.bArg1 = Index;
+
+	if (!Send(sizeof(p), &p))
+	{
+		Tracef("SendPostGetItems Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPostAllGetItems()
+{
+	TPacketMailboxProcess p;
+	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
+	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_GET_ITEMS;
+
+	if (!Send(sizeof(p), &p))
+	{
+		Tracef("SendPostAllGetItems Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RequestPostAddData(const BYTE ButtonIndex, const BYTE DataIndex)
+{
+	TPacketMailboxProcess p;
+	p.bHeader = HEADER_CG_MAILBOX_PROCESS;
+	p.bSubHeader = CPythonMailBox::EMAILBOX_CG::MAILBOX_CG_ADD_DATA;
+	p.bArg1 = ButtonIndex;
+	p.bArg2 = DataIndex;
+
+	if (!Send(sizeof(p), &p))
+	{
+		Tracef("RequestPostAddData Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPostWrite(const char* szName, const char* szTitle, const char* szMessage, const TItemPos& pos, const int iYang, const int iWon)
+{
+	TPacketCGMailboxWrite p;
+	p.bHeader = HEADER_CG_MAILBOX_WRITE;
+	strncpy(p.szName, szName, sizeof(p.szName) - 1);
+	p.szName[sizeof(p.szName) - 1] = '\0';
+
+	strncpy(p.szTitle, szTitle, sizeof(p.szTitle) - 1);
+	p.szTitle[sizeof(p.szTitle) - 1] = '\0';
+
+	strncpy(p.szMessage, szMessage, sizeof(p.szMessage) - 1);
+	p.szMessage[sizeof(p.szMessage) - 1] = '\0';
+
+	p.pos = pos;
+	p.iYang = iYang;
+	p.iWon = iWon;
+
+	if (!Send(sizeof(p), &p))
+	{
+		Tracef("SendPostWrite Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+#endif
+
+#ifdef ENABLE_GROWTH_PET_SYSTEM
+bool CPythonNetworkStream::SendPetHatchingPacket(const char* c_szName, TItemPos eggPos)
+{
+	TPacketCGPetHatch packet;
+	packet.header = HEADER_CG_PET_HATCH;
+	strncpy(packet.name, c_szName, sizeof(packet.name) - 1);
+	packet.name[sizeof(packet.name) - 1] = '\0';
+	packet.eggPos = eggPos;
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetWindowType(BYTE bType)
+{
+	TPacketCGPetWindowType packet;
+	packet.header = HEADER_CG_PET_WINDOW_TYPE;
+	packet.type = bType;
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetHatchingWindowPacket(bool bState)
+{
+	TPacketCGPetWindow packet;
+	packet.header = HEADER_CG_PET_WINDOW;
+	packet.window = PET_WINDOW_HATCH;
+	packet.state = bState;
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetNameChangeWindowPacket(bool bState)
+{
+	TPacketCGPetWindow packet;
+	packet.header = HEADER_CG_PET_WINDOW;
+	packet.window = PET_WINDOW_NAME_CHANGE;
+	packet.state = bState;
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetNameChangePacket(const char* c_szName, TItemPos changeNamePos, TItemPos upBringingPos)
+{
+	TPacketCGPetNameChange packet;
+	packet.header = HEADER_CG_PET_NAME_CHANGE;
+	strncpy(packet.name, c_szName, sizeof(packet.name));
+	packet.changeNamePos = changeNamePos;
+	packet.upBringingPos = upBringingPos;
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetFeedPacket(int iFeedIndex, const std::vector<std::pair<WORD, WORD>>& itemVec)
+{
+	TPacketCGPetFeed packet;
+	packet.header = HEADER_CG_PET_FEED;
+	packet.index = iFeedIndex;
+	memset(packet.pos, 0, sizeof(packet.pos));
+	memset(packet.count, 0, sizeof(packet.count));
+
+	for (int i = 0; i < itemVec.size(); i++)
+	{
+		packet.pos[i] = itemVec.at(i).first;
+		packet.count[i] = itemVec.at(i).second;
+	}
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetAttrDetermine(TItemPos determinePos)
+{
+	TPacketCGPetDetermine packet;
+	packet.header = HEADER_CG_PET_DETERMINE;
+	packet.determinePos = determinePos;
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetAttrChange(TItemPos upBringingPos, TItemPos attrChangePos)
+{
+	TPacketCGPetAttrChange packet;
+	packet.header = HEADER_CG_PET_ATTR_CHANGE;
+	packet.upBringingPos = upBringingPos;
+	packet.attrChangePos = attrChangePos;
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetRevive(TItemPos upBringingPos, const std::vector<std::pair<WORD, WORD>>& itemVec)
+{
+	TPacketCGPetRevive packet;
+	packet.header = HEADER_CG_PET_REVIVE;
+	packet.upBringingPos = upBringingPos;
+	memset(packet.pos, 0, sizeof(packet.pos));
+	memset(packet.count, 0, sizeof(packet.count));
+
+	for (int i = 0; i < itemVec.size(); i++)
+	{
+		packet.pos[i] = itemVec.at(i).first;
+		packet.count[i] = itemVec.at(i).second;
+	}
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetLearnSkill(BYTE bSlot, TItemPos learnSkillPos)
+{
+	TPacketCGPetLearnSkill packet;
+	packet.header = HEADER_CG_PET_LEARN_SKILL;
+	packet.slotIndex = bSlot;
+	packet.learnSkillPos = learnSkillPos;
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetSkillUpgradeRequest(BYTE bSlot)
+{
+	TPacketCGPetSkillUpgrade packet;
+	packet.header = HEADER_CG_PET_SKILL_UPGRADE;
+	packet.slotIndex = bSlot;
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetDeleteSkill(BYTE bSlot, TItemPos deleteSkillPos)
+{
+	TPacketCGPetDeleteSkill packet;
+	packet.header = HEADER_CG_PET_DELETE_SKILL;
+	packet.slotIndex = bSlot;
+	packet.deleteSkillPos = deleteSkillPos;
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendPetDeleteAllSkill(TItemPos deleteAllSkillPos)
+{
+	TPacketCGPetDeleteAllSkill packet;
+	packet.header = HEADER_CG_PET_DELETE_ALL_SKILL;
+	packet.deleteAllSkillPos = deleteAllSkillPos;
+
+	if (!Send(sizeof(packet), &packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvPet()
+{
+	TPacketGCPet packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		TraceError("TPacketGCPet Error");
+		return false;
+	}
+
+	switch (packet.subheader)
+	{
+	case SUBHEADER_PET_EGG_USE_SUCCESS:
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetHatchingWindowCommand", Py_BuildValue("(i)", CItemData::EGG_USE_SUCCESS));
+		break;
+	case SUBHEADER_PET_EGG_USE_FAILED_BECAUSE_NAME:
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetHatchingWindowCommand", Py_BuildValue("(i)", CItemData::EGG_USE_FAILED_BECAUSE_NAME));
+		break;
+	case SUBHEADER_PET_EGG_USE_FAILED_TIMEOVER:
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetHatchingWindowCommand", Py_BuildValue("(i)", CItemData::EGG_USE_FAILED_TIMEOVER));
+		break;
+	case SUBHEADER_PET_UNSUMMON:
+		CPythonPlayer::Instance().SetActivePet(NULL);
+		break;
+	case SUBHEADER_PET_FEED_FAILED:
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetFeedReuslt", Py_BuildValue("(i)", FALSE));
+		break;
+	case SUBHEADER_PET_FEED_SUCCESS:
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetFeedReuslt", Py_BuildValue("(i)", TRUE));
+		break;
+	case SUBHEADER_PET_REVIVE_FAILED:
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetReviveResult", Py_BuildValue("(i)", FALSE));
+		break;
+	case SUBHEADER_PET_REVIVE_SUCCESS:
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetReviveResult", Py_BuildValue("(i)", TRUE));
+		break;
+	case SUBHEADER_PET_WINDOW_TYPE_INFO:
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetWindowTypeResult", Py_BuildValue("(i)", PET_WINDOW_INFO));
+		break;
+	case SUBHEADER_PET_WINDOW_TYPE_ATTR_CHANGE:
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetWindowTypeResult", Py_BuildValue("(i)", PET_WINDOW_ATTR_CHANGE));
+		break;
+	case SUBHEADER_PET_WINDOW_TYPE_PREMIUM_FEED:
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetWindowTypeResult", Py_BuildValue("(i)", PET_WINDOW_PRIMIUM_FEEDSTUFF));
+		break;
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPetSet()
+{
+	TPacketGCPetSet packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		TraceError("TPacketGCPetSet Error");
+		return false;
+	}
+
+	CPythonPlayer::TPetData pet;
+	pet.dwID = packet.dwID;
+	pet.strName = packet.szName;
+	pet.dwSummonItemVnum = packet.dwSummonItemVnum;
+
+	for (DWORD i = 0; i < POINT_UPBRINGING_MAX_NUM; ++i)
+		pet.dwPoints[i] = packet.dwPoints[i];
+
+	for (int i = 0; i < PET_SKILL_COUNT_MAX; ++i)
+	{
+		pet.skillData.aSkillInfo[i].bSkill = packet.aSkill[i].bSkill;
+		pet.skillData.aSkillInfo[i].bLevel = packet.aSkill[i].bLevel;
+		pet.skillData.aSkillInfo[i].dwCooltime = packet.aSkill[i].dwCooltime;
+
+		if (!packet.aSkill[i].bLocked)
+			++pet.skillData.bSkillCount;
+	}
+
+	CPythonPlayer::Instance().SetPetData(&pet);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPetSetExchange()
+{
+	TPacketGCPetSet packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		TraceError("TPacketGCPetSet-Exchange Error");
+		return false;
+	}
+
+	CPythonPlayer::TPetData pet;
+	pet.dwID = packet.dwID;
+	pet.strName = packet.szName;
+	pet.dwSummonItemVnum = packet.dwSummonItemVnum;
+
+	for (DWORD i = 0; i < POINT_UPBRINGING_MAX_NUM; ++i)
+		pet.dwPoints[i] = packet.dwPoints[i];
+
+	for (int i = 0; i < PET_SKILL_COUNT_MAX; ++i)
+	{
+		pet.skillData.aSkillInfo[i].bSkill = packet.aSkill[i].bSkill;
+		pet.skillData.aSkillInfo[i].bLevel = packet.aSkill[i].bLevel;
+		pet.skillData.aSkillInfo[i].dwCooltime = packet.aSkill[i].dwCooltime;
+
+		if (!packet.aSkill[i].bLocked)
+			++pet.skillData.bSkillCount;
+	}
+
+	pet.bIsExchange = true;
+
+	CPythonPlayer::Instance().SetPetData(&pet);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPetDelete()
+{
+	TPacketGCPetDelete packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		TraceError("TPacketGCPetDelete Error");
+		return false;
+	}
+
+	CPythonPlayer::Instance().DeletePetData(packet.dwID);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPetSummon()
+{
+	TPacketGCPetSummon packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		TraceError("TPacketGCPetSummon Error");
+		return false;
+	}
+
+	CPythonPlayer::Instance().SetActivePet(packet.dwID);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPetPointChange()
+{
+	TPacketGCPetPointUpdate packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		TraceError("TPacketGCPetPointUpdate Error");
+		return false;
+	}
+
+	CPythonPlayer::Instance().SetPetStatus(packet.dwID, packet.bPoint, packet.dwValue);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPetNameChangeResult()
+{
+	TPacketGCPetNameChangeResult packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		TraceError("TPacketGCPetNameChangeResult Error");
+		return false;
+	}
+
+	switch (packet.subheader)
+	{
+	case SUBHEADER_PET_NAME_CHANGE_FAILED:
+	{
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetNameChangeWindowCommand", Py_BuildValue("(i)", CItemData::NAME_CHANGE_USE_FAILED_BECAUSE_NAME));
+	}	break;
+
+	case SUBHEADER_PET_NAME_CHANGE_SUCCESS:
+	{
+		CPythonPlayer::TPetData* pPet = nullptr;
+		CPythonPlayer::Instance().GetPetInfo(packet.dwID, &pPet);
+
+		if (pPet)
+			pPet->strName = packet.szName;
+
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetNameChangeWindowCommand", Py_BuildValue("(i)", CItemData::NAME_CHANGE_USE_SUCCESS));
+	}	break;
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPetSkillUpdate()
+{
+	TPacketGCPetSkillUpdate packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		TraceError("TPacketGCPetSkillUpdate Error");
+		return false;
+	}
+
+	CPythonPlayer::Instance().SetPetSkillData(packet.dwID, packet.aSkill);
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetAffectShowerRefresh", Py_BuildValue("()"));
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPetSkillCooltime()
+{
+	TPacketGCPetSkillCooltime packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		TraceError("TPacketGCPetSkillCooltime Error");
+		return false;
+	}
+
+	CPythonPlayer::Instance().SetPetSkillCooltime(packet.dwID, packet.bSlot, packet.dwCooltime);
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPetDetermineResult()
+{
+	TPacketGCPetDetermineResult packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		TraceError("TPacketGCPetDetermineResult Error");
+		return false;
+	}
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetAttrDetermineResult", Py_BuildValue("(i)", packet.type));
+	return true;
+}
+
+bool CPythonNetworkStream::RecvPetAttrChangeResult()
+{
+	TPacketGCPetAttrChangeResult packet;
+	if (!Recv(sizeof(packet), &packet))
+	{
+		TraceError("TPacketGCPetAttrChangeResult Error");
+		return false;
+	}
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "PetAttrChangeResult", Py_BuildValue("(ii)", packet.pos.cell, packet.type));
+
+	return true;
+}
+#endif
+
+#ifdef ENABLE_SHOP_SEARCH
+bool CPythonNetworkStream::RecvShopSearchResult()
+{
+	TPacketGCShopSearchResult pack;
+	if (!Recv(sizeof(pack), &pack))
+		return false;
+
+	CPythonShopSearch::Instance().SetResultMaxPage(pack.maxPageNum);
+
+	CPythonShopSearch::Instance().ClearResultItems();
+	for (int i = 0; i < pack.itemCount; ++i)
+	{
+		TShopSearchClientItem itemData;
+		if (!Recv(sizeof(itemData), &itemData))
+		{
+			TraceError("Bad size of packet");
+			return false;
+		}
+
+		CPythonShopSearch::Instance().AppendResultItem(itemData);
+	}
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ShopSearch_RecvResult", Py_BuildValue("()"));
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvShopSearchBuyResult()
+{
+	TPacketGCShopSearchBuyResult pack;
+	if (!Recv(sizeof(pack), &pack))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ShopSearch_RecvBuyDone", Py_BuildValue("(i)", pack.result));
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvShopSearchOwnerMessage()
+{
+	TPacketGCShopSearchOwnerMessage pack;
+	if (!Recv(sizeof(pack), &pack))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ShopSearch_RecvOwnerMessage", Py_BuildValue("(s)", pack.ownerName));
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvShopSearchSoldInfo()
+{
+	TPacketGCShopSearchSoldInfo pack;
+	if (!Recv(sizeof(pack), &pack))
+		return false;
+
+	CPythonShopSearch::Instance().ClearSoldItemInfo();
+
+	if (pack.results)
+	{
+		for (int i = 0; i < SHOPSEARCH_SOLD_ITEM_INFO_COUNT; ++i)
+		{
+			TShopSearchSoldItemInfo info;
+			if (!Recv(sizeof(info), &info))
+				return false;
+
+			CPythonShopSearch::Instance().SetSoldItemInfo(i, info);
+		}
+	}
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ShopSearch_RecvSoldInfo", Py_BuildValue("(b)", pack.results));
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendShopSearchByName(const std::string& itemName, WORD page, BYTE entryCountIdx, BYTE sortType)
+{
+	TPacketCGShopSearchByName pack;
+	pack.header = HEADER_CG_SHOP_SEARCH_BY_NAME;
+	strncpy(pack.itemName, itemName.c_str(), sizeof(pack.itemName));
+	pack.itemName[CItemData::ITEM_NAME_MAX_LEN] = '\0'; // strncpy is not automatically 0-terminated
+	pack.page = page;
+	pack.entryCountIdx = entryCountIdx;
+	pack.sortType = sortType;
+
+	if (!Send(sizeof(pack), &pack))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendShopSearchByOptions(const TShopSearchOptions& options, const TShopSearchItemType* itemTypeFlags, const DWORD* vnumList, WORD page, BYTE entryCountIdx, BYTE sortType)
+{
+	TPacketCGShopSearchByOptions pack;
+	pack.header = HEADER_CG_SHOP_SEARCH_BY_OPTION;
+	pack.options = options;
+	pack.page = page;
+	pack.entryCountIdx = entryCountIdx;
+	pack.sortType = sortType;
+
+	if (!Send(sizeof(pack), &pack))
+		return false;
+
+	if (options.typeFlagCount && !Send(options.typeFlagCount * sizeof(TShopSearchItemType), itemTypeFlags))
+		return false;
+
+	if (options.specificVnumCount && !Send(options.specificVnumCount * sizeof(DWORD), vnumList))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendShopSearchBuy(TShopSearchItemID itemID, DWORD itemVnum, int64_t itemPrice)
+{
+	TPacketCGShopSearchBuy pack;
+	pack.header = HEADER_CG_SHOP_SEARCH_BUY;
+	pack.itemID = itemID;
+	pack.itemVnum = itemVnum;
+	pack.itemPrice = itemPrice;
+
+	if (!Send(sizeof(pack), &pack))
+		return false;
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendShopSearchOwnerMessage(DWORD ownerID)
+{
+	TPacketCGShopSearchOwnerMessage pack;
+	pack.header = HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE;
+	pack.ownerID = ownerID;
+
+	if (!Send(sizeof(pack), &pack))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendShopSearchRequestSoldInfo(DWORD itemVnum)
+{
+	TPacketCGShopSearchRequestSoldInfo pack;
+	pack.header = HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO;
+	pack.itemVnum = itemVnum;
+
+	if (!Send(sizeof(pack), &pack))
+		return false;
+
+	return SendSequence();
+}
+#endif
+
+#if defined(ENABLE_RANKING_SYSTEM)
+#include "PythonRanking.h"
+bool CPythonNetworkStream::RecvRanking()
+{
+	TPacketGCRanking Packet;
+	if (!Recv(sizeof(Packet), &Packet))
+		return false;
+
+	CPythonRanking::Instance().Clear();
+
+	for (unsigned int iPacketSize = Packet.wSize - sizeof(Packet); iPacketSize > 0; iPacketSize -= sizeof(SRankingData))
+	{
+		SRankingData RKData;
+		if (Recv(sizeof(RKData), &RKData))
+			CPythonRanking::Instance().Add(Packet.bType, Packet.bCategory, RKData);
+	}
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenRankingBoard", Py_BuildValue("(ii)", Packet.bType, Packet.bCategory));
+
+	return true;
+}
+#endif
+
+#if defined(ENABLE_MOVE_COSTUME_ATTR)
+bool CPythonNetworkStream::SendItemCombinationPacket(const int iMediumIndex, const int iBaseIndex, const int iMaterialIndex)
+{
+	TPacketCGItemCombination p;
+	p.Header = HEADER_CG_ITEM_COMBINATION;
+	p.MediumIndex = iMediumIndex;
+	p.BaseIndex = iBaseIndex;
+	p.MaterialIndex = iMaterialIndex;
+
+	if (!Send(sizeof(p), &p))
+	{
+		Tracef("SendItemCombinationPacket Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendItemCombinationPacketCancel()
+{
+	TPacketCGItemCombinationCancel p;
+	p.Header = HEADER_CG_ITEM_COMBINATION_CANCEL;
+
+	if (!Send(sizeof(p), &p))
+	{
+		Tracef("SendItemCombinationPacketCancel Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+#endif
+
+#if defined(ENABLE_CHANGED_ATTR)
+bool CPythonNetworkStream::RecvSelectAttr()
+{
+	TPacketGCItemSelectAttr p;
+
+	if (!Recv(sizeof(p), &p))
+		return false;
+
+	CPythonPlayer::Instance().SetSelectAttr(p.aAttr);
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenSelectAttrDialog", Py_BuildValue("(ii)", p.pItemPos.window_type, p.pItemPos.cell));
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendChagedItemAttributePacket(const bool bNew, const TItemPos& pos)
+{
+	TPacketCGItemSelectAttr p;
+	p.bHeader = HEADER_CG_ITEM_SELECT_ATTR;
+	p.bNew = bNew;
+	p.pItemPos = pos;
+
+	if (!Send(sizeof(p), &p))
+	{
+		Tracef("SendChagedItemAttributePacket Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+#endif
+
+#if defined(ENABLE_LOOTING_SYSTEM)
+bool CPythonNetworkStream::SendLootFilterPacket(BYTE(&settings)[ELootFilter::LOOT_FILTER_SETTINGS_MAX])
+{
+	TPacketCGLootFilter p;
+	p.header = HEADER_CG_LOOT_FILTER;
+	memcpy(p.settings, settings, sizeof(p.settings));
+
+	if (!Send(sizeof(p), &p))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvLootFilterPacket()
+{
+	TPacketGCLootFilter p;
+	if (!Recv(sizeof(p), &p))
+		return false;
+
+	if (p.enable)
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "LootingSystemProcess", Py_BuildValue("()"));
+	else
+		CPythonItem::Instance().InsertLootFilteredItem(p.vid);
+
+	return true;
+}
+#endif
+
+// MARK_BUG_FIX
+void CPythonNetworkStream::RefreshGuildMark()
+{
+	__RefreshGuildWindowInfoPage();
+}
+// END_OF_MARK_BUG_FIX
+
+#if defined(ENABLE_MINI_GAME_RUMI)
+bool CPythonNetworkStream::RecvMiniGameRumi()
+{
+	std::vector<char> vPacketBuffer;
+	vPacketBuffer.clear();
+
+	TPacketGCMiniGameRumi Packet;
+	if (!Recv(sizeof(Packet), &Packet))
+		return false;
+
+	unsigned int uiPacketSize = Packet.wSize - sizeof(Packet);
+	if (uiPacketSize > 0)
+	{
+		vPacketBuffer.resize(uiPacketSize);
+		if (!Recv(uiPacketSize, &vPacketBuffer[0]))
+			return false;
+	}
+
+	switch (Packet.bSubHeader)
+	{
+		case RUMI_GC_SUBHEADER_END:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiEnd", Py_BuildValue("()"));
+			break;
+
+		case RUMI_GC_SUBHEADER_START:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiStart", Py_BuildValue("()"));
+			break;
+
+		case RUMI_GC_SUBHEADER_SET_DECK:
+		{
+			TPacketGCMiniGameRumiSetDeck* pkData = (TPacketGCMiniGameRumiSetDeck*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiSetDeckCount", Py_BuildValue("(i)", pkData->bDeckCount));
+		}
+		break;
+
+		case RUMI_GC_SUBHEADER_SET_SCORE:
+		{
+			TPacketGCMiniGameRumiSetScore* pkData = (TPacketGCMiniGameRumiSetScore*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiIncreaseScore", Py_BuildValue("(ii)",
+				pkData->wScore, pkData->wTotalScore));
+		}
+		break;
+
+		case RUMI_GC_SUBHEADER_MOVE_CARD:
+		{
+			TPacketGCMiniGameRumiMoveCard* pkData = (TPacketGCMiniGameRumiMoveCard*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiMoveCard", Py_BuildValue("(iiiiiiii)",
+				pkData->bSrcPos, pkData->bSrcIndex, pkData->bSrcColor, pkData->bSrcNumber,
+				pkData->bDstPos, pkData->bDstIndex, pkData->bDstColor, pkData->bDstNumber));
+		}
+		break;
+
+#if defined(ENABLE_OKEY_EVENT_FLAG_RENEWAL)
+		case RUMI_GC_SUBHEADER_SET_CARD_PIECE_FLAG:
+		case RUMI_GC_SUBHEADER_SET_CARD_FLAG:
+		case RUMI_GC_SUBHEADER_SET_QUEST_FLAG:
+		case RUMI_GC_SUBHEADER_NO_MORE_GAIN:
+		{
+			TPacketGCMiniGameRumiQuestFlag* pkData = (TPacketGCMiniGameRumiQuestFlag*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "MiniGameRumiFlagProcess", Py_BuildValue("(i(ii))",
+				Packet.bSubHeader, pkData->wCardPieceCount, pkData->wCardCount));
+		}
+		break;
+#endif
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendMiniGameRumiExit()
+{
+	TPacketCGMiniGameRumi Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
+	Packet.bSubHeader = RUMI_CG_SUBHEADER_END;
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameRumiExit Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMiniGameRumiStart()
+{
+	TPacketCGMiniGameRumi Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
+	Packet.bSubHeader = RUMI_CG_SUBHEADER_START;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameRumiStart Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMiniGameRumiDeckCardClick()
+{
+	TPacketCGMiniGameRumi Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
+	Packet.bSubHeader = RUMI_CG_SUBHEADER_DECK_CARD_CLICK;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameRumiDeckCardClick Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMiniGameRumiHandCardClick(bool bUse, BYTE bIndex)
+{
+	TPacketCGMiniGameRumi Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
+	Packet.bSubHeader = RUMI_CG_SUBHEADER_HAND_CARD_CLICK;
+	Packet.bUseCard = bUse;
+	Packet.bIndex = bIndex;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameRumiHandCardClick Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMiniGameRumiFieldCardClick(const BYTE c_bIndex)
+{
+	TPacketCGMiniGameRumi Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
+	Packet.bSubHeader = RUMI_CG_SUBHEADER_FIELD_CARD_CLICK;
+	Packet.bIndex = c_bIndex;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameRumiFieldCardClick Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+#if defined(ENABLE_OKEY_EVENT_FLAG_RENEWAL)
+bool CPythonNetworkStream::SendMiniGameRumiRequestQuestFlag()
+{
+	TPacketCGMiniGameRumi Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_RUMI;
+	Packet.bSubHeader = RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameRumiRequestQuestFlag Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+#endif
+#endif
+
+#if defined(ENABLE_GEM_SYSTEM)
+bool CPythonNetworkStream::RecvGemShop()
+{
+	TPacketGCGemShop Packet;
+	if (!Recv(sizeof(Packet), &Packet))
+		return false;
+
+	CPythonPlayer& rkPlayer = CPythonPlayer::Instance();
+	rkPlayer.ClearGemShop();
+
+	unsigned int uiPacketSize = (Packet.wSize - sizeof(TPacketGCGemShop));
+	for (; uiPacketSize > 0; uiPacketSize -= sizeof(TGemShopTable))
+	{
+		TGemShopTable GemShopTable;
+		if (!Recv(sizeof(GemShopTable), &GemShopTable))
+			return false;
+
+		rkPlayer.GemShop(GemShopTable);
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvGemShopProcess()
+{
+	TPacketGCGemShopProcess Packet;
+	if (!Recv(sizeof(Packet), &Packet))
+		return false;
+
+	switch (Packet.bSubHeader)
+	{
+		case SUBHEADER_GEM_SHOP_CLOSE:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseGemShop", Py_BuildValue("()"));
+			break;
+		case SUBHEADER_GEM_SHOP_OPEN:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenGemShop", Py_BuildValue("()"));
+			break;
+		case SUBHEADER_GEM_SHOP_BUY:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "GemShopSlotBuy", Py_BuildValue("(ib)", Packet.bSlotIndex, Packet.bEnable));
+			break;
+		case SUBHEADER_GEM_SHOP_SLOT_ADD:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "GemShopSlotAdd", Py_BuildValue("(ib)", Packet.bSlotIndex, Packet.bEnable));
+			break;
+		case SUBHEADER_GEM_SHOP_REFRESH:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGemShopWindow", Py_BuildValue("()"));
+			break;
+		default:
+			TraceError("CPythonNetworkStream::RecvGemShopProcess: Unknown SubHeader: %d\n", Packet.bSubHeader);
+			break;
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendGemShopCommand(const BYTE c_bSubHeader, const BYTE c_bSlotIndex)
+{
+	if (c_bSubHeader > SUBHEADER_GEM_SHOP_MAX)
+		return false;
+
+	if (c_bSlotIndex > GEM_SHOP_SLOT_COUNT)
+		return false;
+
+	TPacketCGGemShop Packet(c_bSubHeader, c_bSlotIndex);
+	if (!Send(sizeof(Packet), &Packet))
+		return false;
+
+	return SendSequence();
+}
+#endif
+
+#if defined(ENABLE_CONQUEROR_LEVEL)
+void CPythonNetworkStream::__SungMaAttrInfoProcess() const
+{
+	CPythonBackground& rkBg = CPythonBackground::Instance();
+	if (!rkBg.HasSungMaAttr())
+		return;
+
+	const CMapBase::SSungmaAttr& data = rkBg.GetSungMaAttrData();
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SungMaAttr", Py_BuildValue("(iiii)", data.str, data.hp, data.move, data.immune));
+}
+#endif
+
+#if defined(ENABLE_EXTEND_INVEN_SYSTEM)
+bool CPythonNetworkStream::SendExtendInven(bool bUpgrade, BYTE bIndex)
+{
+	TPacketCGExtendInven Packet;
+	Packet.bHeader = HEADER_CG_EXTEND_INVEN;
+	Packet.bUpgrade = bUpgrade;
+	Packet.bIndex = bIndex;
+	if (!Send(sizeof(TPacketCGExtendInven), &Packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvExtendInven()
+{
+	TPacketGCExtendInven Packet;
+	if (!Recv(sizeof(Packet), &Packet))
+		return false;
+
+	CPythonPlayer::Instance().SetExtendInvenStage(Packet.bStage);
+	CPythonPlayer::Instance().SetExtendInvenMax(Packet.wMaxNum);
+
+	__RefreshInventoryWindow();
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvExtendInvenItemUse()
+{
+	TPacketGCExtendInvenItemUse Packet;
+	if (!Recv(sizeof(Packet), &Packet))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ExInvenItemUseMsg",
+		Py_BuildValue("(iii)", 0 /* unused item vnum */, Packet.bMsgResult, Packet.bEnoughCount));
+
+	__RefreshStatus();
+	__RefreshInventoryWindow();
+
+	return true;
+}
+#endif
+
+#if defined(ENABLE_CLIENT_TIMER)
+bool CPythonNetworkStream::RecvClientTimer()
+{
+	TPacketGCClientTimer Packet;
+	if (!Recv(sizeof(TPacketGCClientTimer), &Packet))
+		return false;
+
+	switch (Packet.bSubHeader)
+	{
+		case CLIENT_TIMER_SUBHEADER_GC_SET:
+		{
+			PyObject* poDict = PyDict_New();
+			if (poDict == nullptr)
+				return false;
+
+			for (BYTE bDataIndex = 0; bDataIndex < ECLIENT_TIMER_MAX; ++bDataIndex)
+				PyDict_SetItem(poDict, Py_BuildValue("i", bDataIndex), Py_BuildValue("i", Packet.dwData[bDataIndex]));
+
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ClientTimerProcess",
+				Py_BuildValue("iO", CLIENT_TIMER_SUBHEADER_GC_SET, poDict));
+
+			Py_DECREF(poDict);
+		}
+		break;
+
+		case CLIENT_TIMER_SUBHEADER_GC_DELETE:
+		default:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ClientTimerProcess",
+				Py_BuildValue("ii", CLIENT_TIMER_SUBHEADER_GC_DELETE, 0));
+		}
+		break;
+	}
+
+	return true;
+}
+#endif
+
+bool CPythonNetworkStream::RecvEmote()
+{
+	TPacketGCEmote Packet;
+	if (!Recv(sizeof(TPacketGCEmote), &Packet))
+		return false;
+
+	switch (Packet.bSubHeader)
+	{
+		case SUBHEADER_EMOTE_ADD:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AddSpecialActionSlot",
+				Py_BuildValue("ii", Packet.dwEmoteVnum, Packet.dwDuration));
+		}
+		break;
+
+#if defined(ENABLE_EXPRESSING_EMOTION)
+		case SUBHEADER_EMOTE_CLEAR:
+		{
+			for (int iIndex = SPECIAL_ACTION_START_INDEX; iIndex < EMOTION_NUM; ++iIndex)
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RemoveSpecialActionSlot", Py_BuildValue("(i)", iIndex));
+		}
+		break;
+#endif
+
+		case SUBHEADER_EMOTE_MOTION:
+		{
+			IAbstractCharacterManager& rkChrMgr = IAbstractCharacterManager::GetSingleton();
+			CInstanceBase* pkInstMain = rkChrMgr.GetInstancePtr(Packet.dwMainVID);
+			CInstanceBase* pkInstTarget = rkChrMgr.GetInstancePtr(Packet.dwTargetVID);
+			if (pkInstMain == nullptr)
+				return false;
+
+			switch (Packet.dwEmoteVnum)
+			{
+				case EMOTION_CLAP:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_CLAP);
+					break;
+				case EMOTION_CONGRATULATION:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_CONGRATULATION);
+					break;
+				case EMOTION_FORGIVE:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_FORGIVE);
+					break;
+				case EMOTION_ANGRY:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_ANGRY);
+					break;
+				case EMOTION_ATTRACTIVE:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_ATTRACTIVE);
+					break;
+				case EMOTION_SAD:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_SAD);
+					break;
+				case EMOTION_SHY:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_SHY);
+					break;
+				case EMOTION_CHEERUP:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_CHEERUP);
+					break;
+				case EMOTION_BANTER:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_BANTER);
+					break;
+				case EMOTION_JOY:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_JOY);
+					break;
+				case EMOTION_CHEERS_1:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_CHEERS_1);
+					break;
+				case EMOTION_CHEERS_2:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_CHEERS_2);
+					break;
+				case EMOTION_DANCE_1:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_1);
+					break;
+				case EMOTION_DANCE_2:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_2);
+					break;
+				case EMOTION_DANCE_3:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_3);
+					break;
+				case EMOTION_DANCE_4:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_4);
+					break;
+				case EMOTION_DANCE_5:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_5);
+					break;
+				case EMOTION_DANCE_6:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_6);
+					break;
+
+				case EMOTION_KISS:
+					if (pkInstTarget)
+						pkInstMain->ActDualEmotion(*pkInstTarget, CRaceMotionData::NAME_KISS_START, CRaceMotionData::NAME_KISS_START);
+					break;
+				case EMOTION_FRENCH_KISS:
+					if (pkInstTarget)
+						pkInstMain->ActDualEmotion(*pkInstTarget, CRaceMotionData::NAME_FRENCH_KISS_START, CRaceMotionData::NAME_FRENCH_KISS_START);
+					break;
+				case EMOTION_SLAP:
+					if (pkInstTarget)
+						pkInstMain->ActDualEmotion(*pkInstTarget, CRaceMotionData::NAME_SLAP_HURT_START, CRaceMotionData::NAME_SLAP_HIT_START);
+					break;
+
+#if defined(ENABLE_EXPRESSING_EMOTION)
+				case EMOTION_PUSH_UP:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_PUSH_UP);
+					break;
+				case EMOTION_DANCE_7:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_DANCE_7);
+					break;
+				case EMOTION_EXERCISE:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_EXERCISE);
+					break;
+				case EMOTION_DOZE:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_DOZE);
+					break;
+				case EMOTION_SELFIE:
+					pkInstMain->ActEmotion(CRaceMotionData::NAME_SELFIE);
+					break;
+
+				case EMOTION_CHARGING:
+				case EMOTION_NOSAY:
+				case EMOTION_WEATHER_1:
+				case EMOTION_WEATHER_2:
+				case EMOTION_WEATHER_3:
+				case EMOTION_HUNGRY:
+				case EMOTION_SIREN:
+				case EMOTION_LETTER:
+				case EMOTION_CALL:
+				case EMOTION_CELEBRATION:
+				case EMOTION_ALCOHOL:
+				case EMOTION_BUSY:
+				case EMOTION_WHIRL:
+				{
+					DWORD dwEmoticon;
+					if (ParseEmoticon(Packet.dwEmoteVnum, &dwEmoticon))
+						pkInstMain->SetEmoticon(dwEmoticon);
+				}
+				break;
+#endif
+			}
+		}
+		break;
+
+		case SUBHEADER_EMOTE_ICON:
+		{
+			IAbstractCharacterManager& rkChrMgr = IAbstractCharacterManager::GetSingleton();
+			CInstanceBase* pkInstMain = rkChrMgr.GetInstancePtr(Packet.dwMainVID);
+			CInstanceBase* pkInstTarget = rkChrMgr.GetInstancePtr(Packet.dwTargetVID);
+			if (pkInstMain == nullptr)
+				return false;
+
+			DWORD dwEmoticon;
+			if (ParseEmoticon(Packet.dwEmoteVnum, &dwEmoticon))
+				pkInstMain->SetEmoticon(dwEmoticon);
+		}
+		break;
+	}
+
+	return true;
+}
+
+#if defined(ENABLE_CUBE_RENEWAL)
+bool CPythonNetworkStream::SendCubeClosePacket()
+{
+	TPacketCGCube Packet;
+	Packet.bHeader = HEADER_CG_CUBE;
+	Packet.bSubHeader = SUBHEADER_CG_CUBE_CLOSE;
+	Packet.dwFileCrc = CPythonCubeManager::Instance().GetFileCrc();
+	if (!Send(sizeof(TPacketCGCube), &Packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendCubeMakePacket(const UINT iCubeIndex, const UINT iQuantity, const INT iImproveItemPos)
+{
+	TPacketCGCube Packet;
+	Packet.bHeader = HEADER_CG_CUBE;
+	Packet.bSubHeader = SUBHEADER_CG_CUBE_MAKE;
+	Packet.iCubeIndex = iCubeIndex;
+	Packet.iQuantity = iQuantity;
+	Packet.iImproveItemPos = iImproveItemPos;
+	Packet.dwFileCrc = CPythonCubeManager::Instance().GetFileCrc();
+	if (!Send(sizeof(TPacketCGCube), &Packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvCubePacket()
+{
+	TPacketGCCube Packet;
+	if (!Recv(sizeof(TPacketGCCube), &Packet))
+		return false;
+
+	if (Packet.bSubHeader != SUBHEADER_GC_CUBE_CLOSE && Packet.dwFileCrc != CPythonCubeManager::Instance().GetFileCrc())
+	{
+		Tracef("CPythonNetworkStream::RecvCubePacket() - File Mismatch");
+		return false;
+	}
+
+	switch (Packet.bSubHeader)
+	{
+		case SUBHEADER_GC_CUBE_OPEN:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_Open", Py_BuildValue("(i)", Packet.dwNPCVnum));
+			break;
+		case SUBHEADER_GC_CUBE_CLOSE:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_Close", Py_BuildValue("()"));
+			break;
+		case SUBHEADER_GC_CUBE_RESULT:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_Result", Py_BuildValue("(b)", Packet.bSuccess));
+			break;
+	}
+
+	return true;
+}
+#endif
+
+#if defined(ENABLE_SNOWFLAKE_STICK_EVENT)
+bool CPythonNetworkStream::SendSnowflakeStickEventPacket(BYTE bSubHeader)
+{
+	TPacketCGSnowflakeStickEvent Packet(bSubHeader);
+	if (!Send(sizeof(TPacketCGSnowflakeStickEvent), &Packet))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvSnowflakeStickEventPacket()
+{
+	TPacketGCSnowflakeStickEvent Packet;
+	if (!Recv(sizeof(TPacketGCSnowflakeStickEvent), &Packet))
+		return false;
+
+	switch (Packet.bSubHeader)
+	{
+		case SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SnowflakeStickEventProcess",
+				Py_BuildValue("(i(iiiiii))", Packet.bSubHeader,
+					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_SNOW_BALL],
+					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_TREE_BRANCH],
+					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK],
+					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_STICK_COOLDOWN],
+					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_PET],
+					Packet.dwValue[SNOWFLAKE_STICK_EVENT_QUEST_FLAG_EXCHANGE_MOUNT]));
+		}
+		break;
+
+		case SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_ENABLE:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SnowflakeStickEventProcess",
+				Py_BuildValue("(ii)", Packet.bSubHeader, Packet.dwValue[0]));
+		}
+		break;
+
+		case SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_MESSAGE_USE_STICK_FAILED:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SnowflakeStickEventProcess",
+				Py_BuildValue("(ii)", Packet.bSubHeader, Packet.dwValue[0]));
+		}
+		break;
+
+		default:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SnowflakeStickEventProcess",
+				Py_BuildValue("(i())", Packet.bSubHeader));
+		}
+		break;
+	}
+
+	return true;
+}
+#endif
+
+#if defined(ENABLE_REFINE_ELEMENT_SYSTEM)
+bool CPythonNetworkStream::SendRefineElementPacket(BYTE bSubHeader, WORD wElementType)
+{
+	TPacketCGRefineElement kPacket(bSubHeader, wElementType);
+	if (!Send(sizeof(TPacketCGRefineElement), &kPacket))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvRefineElementPacket()
+{
+	TPacketGCRefineElement kPacket;
+	if (!Recv(sizeof(TPacketGCRefineElement), &kPacket))
+		return false;
+
+	switch (kPacket.bSubHeader)
+	{
+		case REFINE_ELEMENT_GC_OPEN:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefineElementProcess",
+				Py_BuildValue("(ii(ii))", kPacket.bSubHeader, kPacket.bRefineType,
+					kPacket.SrcPos.cell, kPacket.DestPos.cell
+				));
+		}
+		break;
+		case REFINE_ELEMENT_GC_RESULT:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefineElementProcess",
+				Py_BuildValue("(iib)", kPacket.bSubHeader, kPacket.bRefineType, kPacket.bResult));
+		}
+		break;
+	}
+
+	return true;
+}
+#endif
+
+#if defined(ENABLE_MINI_GAME_YUTNORI)
+bool CPythonNetworkStream::RecvMiniGameYutnori()
+{
+	std::vector<char> vPacketBuffer;
+	vPacketBuffer.clear();
+
+	TPacketGCMiniGameYutnori Packet;
+	if (!Recv(sizeof(Packet), &Packet))
+		return false;
+
+	unsigned int uiPacketSize = Packet.wSize - sizeof(Packet);
+	if (uiPacketSize > 0)
+	{
+		vPacketBuffer.resize(uiPacketSize);
+		if (!Recv(uiPacketSize, &vPacketBuffer[0]))
+			return false;
+	}
+
+	switch (Packet.bSubHeader)
+	{
+		case YUTNORI_GC_SUBHEADER_START:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(ii)",
+				Packet.bSubHeader, 0));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_STOP:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(ii)",
+				Packet.bSubHeader, 0));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_SET_PROB:
+		{
+			TPacketGCMiniGameYutnoriSetProb* pPacket = (TPacketGCMiniGameYutnoriSetProb*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(ii)",
+				Packet.bSubHeader, pPacket->bProbIndex));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_THROW:
+		{
+			TPacketGCMiniGameYutnoriThrowYut* pPacket = (TPacketGCMiniGameYutnoriThrowYut*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(i(ii))",
+				Packet.bSubHeader, pPacket->bPC, pPacket->bYut));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_MOVE:
+		{
+			TPacketGCMiniGameYutnoriMoveYut* pPacket = (TPacketGCMiniGameYutnoriMoveYut*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(i(iiiii))",
+				Packet.bSubHeader, pPacket->bPC, pPacket->bUnitIndex, pPacket->bIsCatch, pPacket->bStartIndex, pPacket->bDestIndex));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_AVAILABLE_AREA:
+		{
+			TPacketGCMiniGameYutnoriAvailableArea* pPacket = (TPacketGCMiniGameYutnoriAvailableArea*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(i(ii))",
+				Packet.bSubHeader, pPacket->bPlayerIndex, pPacket->bAvailableIndex));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_PUSH_CATCH_YUT:
+		{
+			TPacketGCMiniGameYutnoriPushCatchYut* pPacket = (TPacketGCMiniGameYutnoriPushCatchYut*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(i(ii))",
+				Packet.bSubHeader, pPacket->bPC, pPacket->bUnitIndex));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_SET_SCORE:
+		{
+			TPacketGCMiniGameYutnoriSetScore* pPacket = (TPacketGCMiniGameYutnoriSetScore*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(ii)",
+				Packet.bSubHeader, pPacket->wScore));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_SET_REMAIN_COUNT:
+		{
+			TPacketGCMiniGameYutnoriSetRemainCount* pPacket = (TPacketGCMiniGameYutnoriSetRemainCount*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(ii)",
+				Packet.bSubHeader, pPacket->bRemainCount));
+		}
+		break;
+
+		case YUTNORI_GC_SUBHEADER_PUSH_NEXT_TURN:
+		{
+			TPacketGCMiniGameYutnoriPushNextTurn* pPacket = (TPacketGCMiniGameYutnoriPushNextTurn*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriProcess", Py_BuildValue("(i(ii))",
+				Packet.bSubHeader, pPacket->bPC, pPacket->bState));
+		}
+		break;
+
+#if defined(ENABLE_YUTNORI_EVENT_FLAG_RENEWAL)
+		case YUTNORI_GC_SUBHEADER_SET_YUT_PIECE_FLAG:
+		case YUTNORI_GC_SUBHEADER_SET_YUT_BOARD_FLAG:
+		case YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG:
+		case YUTNORI_GC_SUBHEADER_NO_MORE_GAIN:
+		{
+			TPacketGCMiniGameYutnoriQuestFlag* pPacket = (TPacketGCMiniGameYutnoriQuestFlag*)&vPacketBuffer[0];
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "YutnoriFlagProcess", Py_BuildValue("(i(ii))",
+				Packet.bSubHeader, pPacket->wYutPieceCount, pPacket->wYutBoardCount));
+		}
+		break;
+#endif
+	}
+
+	return true;
+}
+
+bool CPythonNetworkStream::SendMiniGameYutnoriStart()
+{
+	TPacketCGMiniGameYutnori Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
+	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_START;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameYutnoriStart Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMiniGameYutnoriGiveup()
+{
+	TPacketCGMiniGameYutnori Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
+	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_GIVEUP;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameYutnoriGiveup Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMiniGameYutnoriProb(BYTE bProbIndex)
+{
+	TPacketCGMiniGameYutnori Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
+	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_SET_PROB;
+	Packet.bArgument = bProbIndex;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameYutnoriProb Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMiniGameYutnoriCharClick(BYTE bPlayerIndex)
+{
+	TPacketCGMiniGameYutnori Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
+	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_CLICK_CHAR;
+	Packet.bArgument = bPlayerIndex;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameYutnoriCharClick Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMiniGameYutnoriThrow(BYTE bPC)
+{
+	TPacketCGMiniGameYutnori Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
+	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_THROW;
+	Packet.bArgument = bPC;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameYutnoriThrow Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMiniGameYutnoriMove(BYTE bPlayerIndex)
+{
+	TPacketCGMiniGameYutnori Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
+	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_MOVE;
+	Packet.bArgument = bPlayerIndex;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameYutnoriMove Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMiniGameYutnoriReward()
+{
+	TPacketCGMiniGameYutnori Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
+	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_REWARD;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameYutnoriReward Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendMiniGameYutnoriRequestComAction()
+{
+	TPacketCGMiniGameYutnori Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
+	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_REQUEST_COM_ACTION;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameYutnoriRequestComAction Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+#if defined(ENABLE_YUTNORI_EVENT_FLAG_RENEWAL)
+bool CPythonNetworkStream::SendMiniGameYutnoriRequestQuestFlag()
+{
+	TPacketCGMiniGameYutnori Packet;
+	Packet.bHeader = HEADER_CG_MINI_GAME_YUTNORI;
+	Packet.bSubHeader = YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendMiniGameYutnoriRequestQuestFlag Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+#endif
+#endif
+
+#if defined(ENABLE_QUEST_REQUEST_EVENT)
+bool CPythonNetworkStream::SendRequestEventQuest(const char* pszEventQuest)
+{
+	TPacketCGRequestEventQuest Packet;
+	Packet.bHeader = HEADER_CG_REQUEST_EVENT_QUEST;
+	strncpy(Packet.szEventQuest, pszEventQuest, sizeof(Packet.szEventQuest) - 1);
+	Packet.szEventQuest[sizeof(Packet.szEventQuest) - 1] = '\0';
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendRequestEventQuest Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+#endif
+
+#if defined(ENABLE_LEFT_SEAT)
+bool CPythonNetworkStream::SendLeftSeatWaitTimeIndexPacket(BYTE bIndex)
+{
+	TPacketCGLeftSeat Packet;
+	Packet.bHeader = HEADER_CG_LEFT_SEAT;
+	Packet.bSubHeader = LEFT_SEAT_SET_WAIT_TIME_INDEX;
+	Packet.bIndex = bIndex;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendLeftSeatWaitTimeIndexPacket Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendLeftSeatOffPacket(BYTE bIndex)
+{
+	TPacketCGLeftSeat Packet;
+	Packet.bHeader = HEADER_CG_LEFT_SEAT;
+	Packet.bSubHeader = LEFT_SEAT_SET_LOGOUT_TIME_INDEX;
+	Packet.bIndex = bIndex;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("SendLeftSeatOffPacket Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::DisableLeftSeatLogOutState()
+{
+	TPacketCGLeftSeat Packet;
+	Packet.bHeader = HEADER_CG_LEFT_SEAT;
+	Packet.bSubHeader = LEFT_SEAT_DISABLE_LOGOUT_STATE;
+	Packet.bIndex = 0;
+
+	if (!Send(sizeof(Packet), &Packet))
+	{
+		Tracef("DisableLeftSeatLogOutState Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+#endif
+
+#if defined(ENABLE_GUILD_DRAGONLAIR_SYSTEM)
+bool CPythonNetworkStream::RecvGuildDragonLairPacket()
+{
+	TPacketGCGuildDragonLair GuildDragonLairPacket;
+	if (!Recv(sizeof(TPacketGCGuildDragonLair), &GuildDragonLairPacket))
+		return false;
+
+	switch (GuildDragonLairPacket.bSubHeader)
+	{
+		case GUILD_DRAGONLAIR_GC_SUBHEADER_RANKING:
+		{
+			CPythonGuild::Instance().ClearDragonLairRanking(GuildDragonLairPacket.bType);
+
+			unsigned int iPacketSize = (GuildDragonLairPacket.wSize - sizeof(TPacketGCGuildDragonLair));
+			for (; iPacketSize > 0; iPacketSize -= sizeof(TPacketGCGuildDragonLairRanking))
+			{
+				TPacketGCGuildDragonLairRanking GuildDragonLairRankingPacket;
+				if (!Recv(sizeof(TPacketGCGuildDragonLairRanking), &GuildDragonLairRankingPacket))
+					return false;
+
+				CPythonGuild::Instance().RegisterDragonLairRanking(
+					GuildDragonLairRankingPacket.bType,
+					GuildDragonLairRankingPacket.dwGuildID,
+					GuildDragonLairRankingPacket.szGuildName,
+					GuildDragonLairRankingPacket.bMemberCount,
+					GuildDragonLairRankingPacket.dwTime
+				);
+			}
+
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenGuildDragonLairRanking", Py_BuildValue("(i)", GuildDragonLairPacket.bType));
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildDragonLairRanking", Py_BuildValue("(i)", GuildDragonLairPacket.bType));
+		}
+		break;
+
+#if defined(ENABLE_GUILD_DRAGONLAIR_PARTY_SYSTEM)
+		case GUILD_DRAGONLAIR_GC_SUBHEADER_1ST_GUILD_TEXT:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetGuildDragonLairFistGuildText", Py_BuildValue("(i)", GuildDragonLairPacket.dwSeconds));
+			break;
+
+		case GUILD_DRAGONLAIR_GC_SUBHEADER_START:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetGuildDragonLairStart", Py_BuildValue("()"));
+			break;
+
+		case GUILD_DRAGONLAIR_GC_SUBHEADER_SUCCESS:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetGuildDragonLairSuccess", Py_BuildValue("()"));
+			break;
+#endif
+	}
+
+	return true;
+}
+#endif
+
+#if defined(ENABLE_SUMMER_EVENT_ROULETTE)
+bool CPythonNetworkStream::SendMiniGameRoulettePacket(BYTE bSubHeader)
+{
+	TPacketCGMiniGameRoulette MiniGameRoulettePacket;
+	MiniGameRoulettePacket.bHeader = HEADER_CG_MINI_GAME_ROULETTE;
+	MiniGameRoulettePacket.bSubHeader = bSubHeader;
+
+	if (!Send(sizeof(MiniGameRoulettePacket), &MiniGameRoulettePacket))
+	{
+		Tracef("SendMiniGameRoulettePacket Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvMiniGameRoulettePacket()
+{
+	TPacketGCMiniGameRoulette MiniGameRoulettePacket;
+	if (!Recv(sizeof(TPacketGCMiniGameRoulette), &MiniGameRoulettePacket))
+		return false;
+
+	switch (MiniGameRoulettePacket.bSubHeader)
+	{
+		case ROULETTE_GC_OPEN:
+		{
+			PyObject* poTuple = PyTuple_New(ROULETTE_ITEM_MAX);
+			if (poTuple == NULL)
+				return false;
+
+			for (BYTE bSlotIdx = 0; bSlotIdx < ROULETTE_ITEM_MAX; bSlotIdx++)
+			{
+				PyObject* poItemTuple = PyTuple_New(2);
+				if (poItemTuple == NULL)
+					break;
+
+				PyTuple_SetItem(poItemTuple, 0, PyInt_FromLong(MiniGameRoulettePacket.ItemData[bSlotIdx].dwVnum));
+				PyTuple_SetItem(poItemTuple, 1, PyInt_FromLong(MiniGameRoulettePacket.ItemData[bSlotIdx].bCount));
+				PyTuple_SetItem(poTuple, bSlotIdx, poItemTuple);
+			}
+
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RouletteProcess",
+				Py_BuildValue("(i(iO))", ROULETTE_GC_OPEN, MiniGameRoulettePacket.dwExpireTime, poTuple));
+		}
+		break;
+
+		case ROULETTE_GC_START:
+		case ROULETTE_GC_END:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RouletteProcess",
+				Py_BuildValue("(ii)", MiniGameRoulettePacket.bSubHeader, MiniGameRoulettePacket.bResult));
+			break;
+
+		case ROULETTE_GC_CLOSE:
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RouletteProcess",
+				Py_BuildValue("(i)", ROULETTE_GC_CLOSE));
+			break;
+	}
+
+	return true;
+}
+#endif
+
+#if defined(ENABLE_FLOWER_EVENT)
+bool CPythonNetworkStream::SendFlowerEventPacket(BYTE bSubHeader, BYTE bShootType, BYTE bExchangeKey)
+{
+	if (CPythonPlayer::Instance().GetFlowerEventEnable() == 0)
+		return false;
+
+	TPacketCGFlowerEvent FlowerEventPacket;
+	FlowerEventPacket.bHeader = HEADER_CG_FLOWER_EVENT;
+	FlowerEventPacket.bSubHeader = bSubHeader;
+	FlowerEventPacket.bShootType = bShootType;
+	FlowerEventPacket.bExchangeKey = bExchangeKey;
+
+	if (!Send(sizeof(FlowerEventPacket), &FlowerEventPacket))
+		return false;
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvFlowerEventPacket()
+{
+	TPacketGCFlowerEvent FlowerEventPacket;
+	if (!Recv(sizeof(TPacketGCFlowerEvent), &FlowerEventPacket))
+		return false;
+
+	switch (FlowerEventPacket.bSubHeader)
+	{
+		case FLOWER_EVENT_SUBHEADER_GC_INFO_ALL:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "FlowerEventProcess",
+				Py_BuildValue("(i(iiiiii))", FLOWER_EVENT_SUBHEADER_GC_INFO_ALL
+					, FlowerEventPacket.aiShootCount[SHOOT_ENVELOPE]
+					, FlowerEventPacket.aiShootCount[SHOOT_CHRYSANTHEMUM]
+					, FlowerEventPacket.aiShootCount[SHOOT_MAY_BELL]
+					, FlowerEventPacket.aiShootCount[SHOOT_DAFFODIL]
+					, FlowerEventPacket.aiShootCount[SHOOT_LILY]
+					, FlowerEventPacket.aiShootCount[SHOOT_SUNFLOWER]
+				));
+		}
+		break;
+
+		case FLOWER_EVENT_SUBHEADER_GC_GET_INFO:
+		{
+			if (FlowerEventPacket.bShootType == SHOOT_TYPE_MAX)
+			{
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "FlowerEventProcess",
+					Py_BuildValue("ii", FLOWER_EVENT_SUBHEADER_GC_GET_INFO, FlowerEventPacket.bChatType));
+			}
+			else
+			{
+				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "FlowerEventProcess",
+					Py_BuildValue("i(ii)", FLOWER_EVENT_SUBHEADER_GC_GET_INFO,
+						FlowerEventPacket.bShootType, FlowerEventPacket.aiShootCount[FlowerEventPacket.bShootType]));
+			}
+		}
+		break;
+
+		case FLOWER_EVENT_SUBHEADER_GC_UPDATE_INFO:
+		{
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "FlowerEventProcess",
+				Py_BuildValue("i(ii)", FLOWER_EVENT_SUBHEADER_GC_UPDATE_INFO,
+					FlowerEventPacket.bShootType, FlowerEventPacket.aiShootCount[FlowerEventPacket.bShootType]));
+		}
+		break;
+	}
+
+	return true;
+}
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+bool CPythonNetworkStream::SendExtBattlePassAction(BYTE bAction)
+{
+	if (!__CanActMainInstance())
+		return true;
+
+	TPacketCGExtBattlePassAction packet;
+	packet.bHeader = HEADER_CG_EXT_BATTLE_PASS_ACTION;
+	packet.bAction = bAction;
+
+	if (!Send(sizeof(TPacketCGExtBattlePassAction), &packet))
+	{
+		Tracef("SendExtBattlePassAction Send Packet Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::SendExtBattlePassPremiumItem(int slotindex)
+{
+	if (!__CanActMainInstance())
+		return true;
+
+	TPacketCGExtBattlePassSendPremiumItem packet;
+	packet.bHeader = HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM;
+	packet.iSlotIndex = slotindex;
+
+	if (!Send(sizeof(TPacketCGExtBattlePassSendPremiumItem), &packet))
+	{
+		Tracef("SendExtBattlePassPremiumItem Send Packet Error\n");
+		return false;
+	}
+
+	return SendSequence();
+}
+
+bool CPythonNetworkStream::RecvExtBattlePassOpenPacket()
+{
+	SPacketGCExtBattlePassOpen packet;
+	if (!Recv(sizeof(packet), &packet))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtOpenBattlePass", Py_BuildValue("()"));
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvExtBattlePassGeneralInfoPacket()
+{
+	TPacketGCExtBattlePassGeneralInfo packet;
+	if (!Recv(sizeof(packet), &packet))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassAddGeneralInfo", Py_BuildValue("(isiii)", packet.bBattlePassType, packet.szSeasonName, packet.dwBattlePassID, packet.dwBattlePassStartTime, packet.dwBattlePassEndTime));
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvExtBattlePassMissionInfoPacket()
+{
+	TPacketGCExtBattlePassMissionInfo packet;
+	if (!Recv(sizeof(packet), &packet))
+		return false;
+
+	packet.wSize -= sizeof(packet);
+
+	while (packet.wSize > 0)
+	{
+		TExtBattlePassMissionInfo missionInfo;
+		if (!Recv(sizeof(missionInfo), &missionInfo))
+			return false;
+
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassAddMission", Py_BuildValue("(iiiiiii)",
+			packet.bBattlePassType, packet.dwBattlePassID, missionInfo.bMissionIndex, missionInfo.bMissionType, missionInfo.dwMissionInfo[0], missionInfo.dwMissionInfo[1], missionInfo.dwMissionInfo[2]));
+
+		for (int i = 0; i < 3; ++i)
+			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassAddMissionReward", Py_BuildValue("(iiiiii)",
+				packet.bBattlePassType, packet.dwBattlePassID, missionInfo.bMissionIndex, missionInfo.bMissionType, missionInfo.aRewardList[i].dwVnum, missionInfo.aRewardList[i].bCount));
+
+		packet.wSize -= sizeof(missionInfo);
+	}
+
+	while (packet.wRewardSize > 0)
+	{
+		TExtBattlePassRewardItem rewardInfo;
+		if (!Recv(sizeof(rewardInfo), &rewardInfo))
+			return false;
+
+		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassAddReward", Py_BuildValue("(iiii)", packet.bBattlePassType, packet.dwBattlePassID, rewardInfo.dwVnum, rewardInfo.bCount));
+
+		packet.wRewardSize -= sizeof(rewardInfo);
+	}
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtOpenBattlePass", Py_BuildValue("()"));
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvExtBattlePassMissionUpdatePacket()
+{
+	TPacketGCExtBattlePassMissionUpdate packet;
+	if (!Recv(sizeof(packet), &packet))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassUpdate", Py_BuildValue("(iiii)", packet.bBattlePassType, packet.bMissionIndex, packet.bMissionType, packet.dwNewProgress));
+
+	return true;
+}
+
+bool CPythonNetworkStream::RecvExtBattlePassRankingPacket()
+{
+	TPacketGCExtBattlePassRanking packet;
+	if (!Recv(sizeof(packet), &packet))
+		return false;
+
+	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_ExtBattlePassAddRanklistEntry", Py_BuildValue("(siiii)",
+		packet.szPlayerName, packet.bBattlePassType, packet.bBattlePassID, packet.dwStartTime, packet.dwEndTime
+	));
+
+	return true;
+}
+#endif
diff --git a/src-client/Client/UserInterface/ServerStateChecker.cpp b/src-client/Client/UserInterface/ServerStateChecker.cpp
index b730bcd..c727e60 100644
--- a/src-client/Client/UserInterface/ServerStateChecker.cpp
+++ b/src-client/Client/UserInterface/ServerStateChecker.cpp
@@ -1,111 +1,124 @@
-#include "StdAfx.h"
-#include "Packet.h"
-#include "ServerStateChecker.h"
-
-#include "../EterLib/NetAddress.h"
-
-#pragma pack(push)
-#pragma pack(1)
-
-typedef unsigned char ServerStateChecker_Header;
-typedef unsigned long ServerStateChecker_Key;
-typedef unsigned long ServerStateChecker_Index;
-typedef unsigned char ServerStateChecker_State;
-
-#pragma pack(pop)
-
-CServerStateChecker::CServerStateChecker()
-{
-	Initialize();
-}
-
-CServerStateChecker::~CServerStateChecker()
-{
-	Initialize();
-	m_poWnd = NULL;
-}
-
-void CServerStateChecker::Create(PyObject* poWnd)
-{
-	m_poWnd = poWnd;
-}
-
-void CServerStateChecker::AddChannel(UINT uServerIndex, const char* c_szAddr, UINT uPort)
-{
-	TChannel c;
-	c.uServerIndex = uServerIndex;
-	c.c_szAddr = c_szAddr;
-	c.uPort = uPort;
-
-	m_lstChannel.push_back(c);
-}
-
-void CServerStateChecker::Request()
-{
-	if (m_lstChannel.empty())
-		return;
-
-	if (!m_kStream.Connect(m_lstChannel.begin()->c_szAddr, m_lstChannel.begin()->uPort))
-	{
-		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it)
-		{
-			PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, 0));
-		}
-		return;
-	}
-	m_kStream.ClearRecvBuffer();
-	m_kStream.SetSendBufferSize(1024);
-	m_kStream.SetRecvBufferSize(1024);
-	std::string strMainStream("O W S A P");
-
-	BYTE bHeader = HEADER_CG_STATE_CHECKER;
-	if (!m_kStream.Send(sizeof(bHeader), &bHeader))
-	{
-		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it)
-		{
-			PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, 0));
-		}
-		Initialize();
-		return;
-	}
-}
-
-void CServerStateChecker::Update()
-{
-	m_kStream.Process();
-
-	BYTE bHeader;
-	if (!m_kStream.Recv(sizeof(bHeader), &bHeader))
-		return;
-
-	if (HEADER_GC_RESPOND_CHANNELSTATUS != bHeader)
-		return;
-
-	int nSize;
-	if (!m_kStream.Recv(sizeof(nSize), &nSize))
-		return;
-
-	for (int i = 0; i < nSize; i++)
-	{
-		TChannelStatus channelStatus;
-		if (!m_kStream.Recv(sizeof(channelStatus), &channelStatus))
-			return;
-
-		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it)
-		{
-			if (channelStatus.nPort == it->uPort)
-			{
-				PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, channelStatus.bStatus));
-				break;
-			}
-		}
-	}
-
-	Initialize();
-}
-
-void CServerStateChecker::Initialize()
-{
-	m_lstChannel.clear();
-	m_kStream.Disconnect();
-}
+#include "StdAfx.h"
+#include "Packet.h"
+#include "ServerStateChecker.h"
+
+#include "../EterLib/NetAddress.h"
+
+#pragma pack(push)
+#pragma pack(1)
+
+typedef unsigned char ServerStateChecker_Header;
+typedef unsigned long ServerStateChecker_Key;
+typedef unsigned long ServerStateChecker_Index;
+typedef unsigned char ServerStateChecker_State;
+
+#pragma pack(pop)
+
+CServerStateChecker::CServerStateChecker()
+{
+	Initialize();
+}
+
+CServerStateChecker::~CServerStateChecker()
+{
+	Initialize();
+	m_poWnd = NULL;
+}
+
+void CServerStateChecker::Create(PyObject* poWnd)
+{
+	m_poWnd = poWnd;
+}
+
+void CServerStateChecker::AddChannel(UINT uServerIndex, const char* c_szAddr, UINT uPort)
+{
+	TChannel c;
+	c.uServerIndex = uServerIndex;
+	c.c_szAddr = c_szAddr;
+	c.uPort = uPort;
+
+	m_lstChannel.push_back(c);
+}
+
+void CServerStateChecker::Request()
+{
+	if (m_lstChannel.empty())
+		return;
+	if (!m_poWnd)
+		return;
+
+	if (!m_kStream.Connect(m_lstChannel.begin()->c_szAddr, m_lstChannel.begin()->uPort))
+	{
+		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it)
+		{
+			PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, 0));
+		}
+		return;
+	}
+	m_kStream.ClearRecvBuffer();
+	m_kStream.SetSendBufferSize(1024);
+	m_kStream.SetRecvBufferSize(1024);
+	std::string strMainStream("O W S A P");
+
+	BYTE bHeader = HEADER_CG_STATE_CHECKER;
+	if (!m_kStream.Send(sizeof(bHeader), &bHeader))
+	{
+		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it)
+		{
+			PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, 0));
+		}
+		Initialize();
+		return;
+	}
+}
+
+void CServerStateChecker::Update()
+{
+	m_kStream.Process();
+
+	BYTE bHeader;
+	if (!m_kStream.Recv(sizeof(bHeader), &bHeader))
+		return;
+
+	if (HEADER_GC_RESPOND_CHANNELSTATUS != bHeader)
+		return;
+
+	int nSize;
+	if (!m_kStream.Recv(sizeof(nSize), &nSize))
+		return;
+
+	if (nSize < 0)
+	{
+		Initialize();
+		return;
+	}
+	if (static_cast<size_t>(nSize) > m_lstChannel.size() || nSize > 64)
+	{
+		Initialize();
+		return;
+	}
+
+	for (int i = 0; i < nSize; i++)
+	{
+		TChannelStatus channelStatus;
+		if (!m_kStream.Recv(sizeof(channelStatus), &channelStatus))
+			return;
+
+		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it)
+		{
+			if (channelStatus.nPort == it->uPort)
+			{
+				PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, channelStatus.bStatus));
+				break;
+			}
+		}
+	}
+
+	Initialize();
+}
+
+void CServerStateChecker::Initialize()
+{
+	m_lstChannel.clear();
+	m_kStream.Disconnect();
+}
