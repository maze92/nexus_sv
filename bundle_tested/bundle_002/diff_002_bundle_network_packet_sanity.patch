diff --git a/server/metin2/Source/Server/game/src/exchange.cpp b/server/metin2/Source/Server/game/src/exchange.cpp
index 86524c4..38ccd5f 100644
--- a/server/metin2/Source/Server/game/src/exchange.cpp
+++ b/server/metin2/Source/Server/game/src/exchange.cpp
@@ -1,881 +1,1059 @@
-#include "stdafx.h"
-#include "../../libgame/include/grid.h"
-#include "utils.h"
-#include "desc.h"
-#include "desc_client.h"
-#include "char.h"
-#include "item.h"
-#include "item_manager.h"
-#include "packet.h"
-#include "log.h"
-#include "db.h"
-#include "locale_service.h"
-#include "../../common/length.h"
-#include "exchange.h"
-#include "questmanager.h"
-#include "DragonSoul.h"
-#if defined(__PET_SYSTEM__)
-#	include "PetSystem.h"
-#endif
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-#	include "messenger_manager.h"
-#endif
-
-void exchange_packet(LPCHARACTER ch, BYTE sub_header, bool is_me, DWORD arg1, TItemPos arg2, DWORD arg3, void* pvData = NULL);
-
-// ±≥»Ø ∆–≈∂
-void exchange_packet(LPCHARACTER ch, BYTE sub_header, bool is_me, DWORD arg1, TItemPos arg2, DWORD arg3, void* pvData)
-{
-	if (!ch->GetDesc())
-		return;
-
-	struct packet_exchange pack_exchg;
-
-	pack_exchg.header = HEADER_GC_EXCHANGE;
-	pack_exchg.sub_header = sub_header;
-	pack_exchg.is_me = is_me;
-	pack_exchg.arg1 = arg1;
-	pack_exchg.arg2 = arg2;
-	pack_exchg.arg3 = arg3;
-
-	if (sub_header == EXCHANGE_SUBHEADER_GC_ITEM_ADD && pvData)
-	{
-		pack_exchg.arg4 = TItemPos(((LPITEM)pvData)->GetWindow(), ((LPITEM)pvData)->GetCell());
-
-		thecore_memcpy(&pack_exchg.alSockets, ((LPITEM)pvData)->GetSockets(), sizeof(pack_exchg.alSockets));
-		thecore_memcpy(&pack_exchg.aAttr, ((LPITEM)pvData)->GetAttributes(), sizeof(pack_exchg.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		pack_exchg.dwTransmutationVnum = static_cast<LPITEM>(pvData)->GetTransmutationVnum();
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		thecore_memcpy(&pack_exchg.RefineElement, ((LPITEM)pvData)->GetRefineElement(), sizeof(pack_exchg.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-		thecore_memcpy(&pack_exchg.aApplyRandom, ((LPITEM)pvData)->GetRandomApplies(), sizeof(pack_exchg.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-		pack_exchg.bSetItem = static_cast<LPITEM>(pvData)->GetItemSetValue();
-#endif
-	}
-	else
-	{
-		pack_exchg.arg4 = TItemPos(RESERVED_WINDOW, 0);
-
-		memset(&pack_exchg.alSockets, 0, sizeof(pack_exchg.alSockets));
-		memset(&pack_exchg.aAttr, 0, sizeof(pack_exchg.aAttr));
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		pack_exchg.dwTransmutationVnum = 0;
-#endif
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		memset(&pack_exchg.RefineElement, 0, sizeof(pack_exchg.RefineElement));
-#endif
-#if defined(__ITEM_APPLY_RANDOM__)
-		memset(&pack_exchg.aApplyRandom, 0, sizeof(pack_exchg.aApplyRandom));
-#endif
-#if defined(__SET_ITEM__)
-		pack_exchg.bSetItem = 0;
-#endif
-	}
-
-	ch->GetDesc()->Packet(&pack_exchg, sizeof(pack_exchg));
-}
-
-// ±≥»Ø¿ª Ω√¿€
-bool CHARACTER::ExchangeStart(LPCHARACTER victim)
-{
-	if (this == victim) // ¿⁄±‚ ¿⁄Ω≈∞˙¥¬ ±≥»Ø¿ª ∏¯«—¥Ÿ.
-		return false;
-
-	if (IsObserverMode())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("∞¸¿¸ ªÛ≈¬ø°º≠¥¬ ±≥»Ø¿ª «“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return false;
-	}
-
-	if (victim->IsRunningQuest())
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("The other person is currently busy so you cannot trade right now."));
-		return false;
-	}
-
-	if (IsRunningQuest())
-		return false;
-
-	if (victim->IsNPC())
-		return false;
-
-#ifdef __GROWTH_PET_SYSTEM__
-	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc."));
-		return false;
-	}
-
-	if (victim->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || victim->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot trade while your trading partner is modifying their pet's stats."));
-		return false;
-	}
-
-	/*
-	if (GetActiveGrowthPet())
-	{
-		ChatPacket(CHAT_TYPE_INFO, "You cannot open a private shop whilst summoning your pet.");
-		return false;
-	}
-
-	if (victim->GetActiveGrowthPet())
-	{
-		ChatPacket(CHAT_TYPE_INFO, "You cannot trade whilst your partner is summoning their pet.");
-		return false;
-	}
-	*/
-#endif
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	if (CMessengerManager::instance().IsBlocked(GetName(), victim->GetName()))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", victim->GetName()));
-		return false;
-	}
-	else if (CMessengerManager::instance().IsBlocked(victim->GetName(), GetName()))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", victim->GetName()));
-		return false;
-	}
-#endif
-
-	// PREVENT_TRADE_WINDOW
-	if (PreventTradeWindow(WND_EXCHANGE, true/*except*/))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("¥Ÿ∏• ∞≈∑°√¢¿Ã ø≠∑¡¿÷¿ª∞ÊøÏ ∞≈∑°∏¶ «“ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return false;
-	}
-
-	if (victim->PreventTradeWindow(WND_EXCHANGE, true/*except*/))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ªÛ¥ÎπÊ¿Ã ¥Ÿ∏• ∞≈∑°¡ﬂ¿Ã∂Û ∞≈∑°∏¶ «“ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return false;
-	}
-	// END_PREVENT_TRADE_WINDOW
-
-	int iDist = DISTANCE_APPROX(GetX() - victim->GetX(), GetY() - victim->GetY());
-
-	// ∞≈∏Æ √º≈©
-	if (iDist >= EXCHANGE_MAX_DISTANCE)
-		return false;
-
-	if (GetExchange())
-		return false;
-
-	if (victim->GetExchange())
-	{
-		exchange_packet(this, EXCHANGE_SUBHEADER_GC_ALREADY, 0, 0, NPOS, 0);
-		return false;
-	}
-
-	if (victim->IsBlockMode(BLOCK_EXCHANGE))
-	{
-		ChatPacket(CHAT_TYPE_INFO, LC_STRING("ªÛ¥ÎπÊ¿Ã ±≥»Ø ∞≈∫Œ ªÛ≈¬¿‘¥œ¥Ÿ."));
-		return false;
-	}
-
-	SetExchange(M2_NEW CExchange(this));
-	victim->SetExchange(M2_NEW CExchange(victim));
-
-	victim->GetExchange()->SetCompany(GetExchange());
-	GetExchange()->SetCompany(victim->GetExchange());
-
-	//
-	SetExchangeTime();
-	victim->SetExchangeTime();
-
-	exchange_packet(victim, EXCHANGE_SUBHEADER_GC_START, 0, GetVID(), NPOS, 0);
-	exchange_packet(this, EXCHANGE_SUBHEADER_GC_START, 0, victim->GetVID(), NPOS, 0);
-
-	return true;
-}
-
-CExchange::CExchange(LPCHARACTER pOwner)
-{
-	m_pCompany = NULL;
-
-	m_bAccept = false;
-
-	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		m_apItems[i] = NULL;
-		m_aItemPos[i] = NPOS;
-		m_abItemDisplayPos[i] = 0;
-	}
-
-	m_lGold = 0;
-#if defined(__CHEQUE_SYSTEM__)
-	m_lCheque = 0;
-#endif
-
-	m_pOwner = pOwner;
-	pOwner->SetExchange(this);
-
-	m_pGrid = M2_NEW CGrid(4, 3);
-}
-
-CExchange::~CExchange()
-{
-	M2_DELETE(m_pGrid);
-}
-
-bool CExchange::AddItem(TItemPos item_pos, BYTE display_pos)
-{
-	assert(m_pOwner != NULL && GetCompany());
-
-	if (!item_pos.IsValidItemPosition())
-		return false;
-
-	// ¿Â∫Ò¥¬ ±≥»Ø«“ ºˆ æ¯¿Ω
-	if (item_pos.IsEquipPosition())
-		return false;
-
-	LPITEM item;
-
-	if (!(item = m_pOwner->GetItem(item_pos)))
-		return false;
-
-	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_GIVE))
-	{
-		m_pOwner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("æ∆¿Ã≈€¿ª ∞«≥◊¡Ÿ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return false;
-	}
-
-	if (true == item->isLocked())
-		return false;
-
-#if defined(__PET_SYSTEM__)
-	CPetSystem* pPetSystem = m_pOwner->GetPetSystem();
-	if (pPetSystem && pPetSystem->GetSummonItemVID() == item->GetVID())
-		return false;
-#endif
-
-#if defined(__SOUL_BIND_SYSTEM__)
-	if (item->IsSealed())
-	{
-		m_pOwner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot give away a soulbound item."));
-		return false;
-	}
-#endif
-
-	// ¿ÃπÃ ±≥»Ø√¢ø° √ﬂ∞°µ» æ∆¿Ã≈€¿Œ∞°?
-	if (item->IsExchanging())
-	{
-		sys_log(0, "EXCHANGE under exchanging");
-		return false;
-	}
-
-	if (!m_pGrid->IsEmpty(display_pos, 1, item->GetSize()))
-	{
-		sys_log(0, "EXCHANGE not empty item_pos %d %d %d", display_pos, 1, item->GetSize());
-		return false;
-	}
-
-	Accept(false);
-	GetCompany()->Accept(false);
-
-	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		if (m_apItems[i])
-			continue;
-
-		m_apItems[i] = item;
-		m_aItemPos[i] = item_pos;
-		m_abItemDisplayPos[i] = display_pos;
-		m_pGrid->Put(display_pos, 1, item->GetSize());
-
-		item->SetExchanging(true);
-
-#ifdef __GROWTH_PET_SYSTEM__
-		if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
-		{
-			LPGROWTH_PET pkPet = item->GetOwner()->GetGrowthPet(item->GetSocket(2));
-
-			// Pet might not be stored in the bag
-			if (pkPet)
-				pkPet->PetSetExchangePacket(GetCompany()->GetOwner());
-		}
-#endif
-
-		exchange_packet(m_pOwner,
-			EXCHANGE_SUBHEADER_GC_ITEM_ADD,
-			true,
-			item->GetVnum(),
-			TItemPos(RESERVED_WINDOW, display_pos),
-			item->GetCount(),
-			item);
-
-		exchange_packet(GetCompany()->GetOwner(),
-			EXCHANGE_SUBHEADER_GC_ITEM_ADD,
-			false,
-			item->GetVnum(),
-			TItemPos(RESERVED_WINDOW, display_pos),
-			item->GetCount(),
-			item);
-
-		sys_log(0, "EXCHANGE AddItem success %s pos(%d, %d) %d", item->GetName(), item_pos.window_type, item_pos.cell, display_pos);
-
-		return true;
-	}
-
-	// √ﬂ∞°«“ ∞¯∞£¿Ã æ¯¿Ω
-	return false;
-}
-
-bool CExchange::RemoveItem(BYTE pos)
-{
-	if (pos >= EXCHANGE_ITEM_MAX_NUM)
-		return false;
-
-	if (!m_apItems[pos])
-		return false;
-
-	TItemPos PosOfInventory = m_aItemPos[pos];
-	m_apItems[pos]->SetExchanging(false);
-
-	m_pGrid->Get(m_abItemDisplayPos[pos], 1, m_apItems[pos]->GetSize());
-
-	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_ITEM_DEL, true, pos, NPOS, 0);
-	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_ITEM_DEL, false, pos, PosOfInventory, 0);
-
-	Accept(false);
-	GetCompany()->Accept(false);
-
-	m_apItems[pos] = NULL;
-	m_aItemPos[pos] = NPOS;
-	m_abItemDisplayPos[pos] = 0;
-	return true;
-}
-
-bool CExchange::AddGold(long gold)
-{
-	if (gold <= 0 || gold > EXCHANGE_YANG_MAX)
-		return false;
-
-	if (GetOwner()->GetGold() < gold)
-	{
-		// ∞°¡ˆ∞Ì ¿÷¥¬ µ∑¿Ã ∫Œ¡∑.
-		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_GOLD, 0, 0, NPOS, 0);
-		return false;
-	}
-
-	if (LC_IsCanada() == true || LC_IsEurope() == true)
-	{
-		if (m_lGold > 0)
-		{
-			return false;
-		}
-	}
-
-	Accept(false);
-	GetCompany()->Accept(false);
-
-	m_lGold = gold;
-
-	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_GOLD_ADD, true, m_lGold, NPOS, 0);
-	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_GOLD_ADD, false, m_lGold, NPOS, 0);
-	return true;
-}
-
-#if defined(__CHEQUE_SYSTEM__)
-bool CExchange::AddCheque(long cheque)
-{
-	if (cheque <= 0 || cheque > EXCHANGE_CHEQUE_MAX)
-		return false;
-
-	if (GetOwner()->GetCheque() < cheque)
-	{
-		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
-		return false;
-	}
-
-	LPCHARACTER victim = GetCompany()->GetOwner();
-
-	if (m_lCheque)
-	{
-		long vic_cheque = victim->GetCheque() + m_lCheque;
-		if (vic_cheque > CHEQUE_MAX)
-		{
-			exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("This user can not accept that much cheque."));
-			return false;
-		}
-	}
-
-	if (LC_IsCanada() == true || LC_IsEurope() == true)
-	{
-		if (m_lCheque > 0)
-		{
-			return false;
-		}
-	}
-
-	Accept(false);
-	GetCompany()->Accept(false);
-
-	m_lCheque = cheque;
-
-	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, true, m_lCheque, NPOS, 0);
-	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, false, m_lCheque, NPOS, 0);
-	return true;
-}
-#endif
-
-// µ∑¿Ã √Ê∫–»˜ ¿÷¥¬¡ˆ, ±≥»Ø«œ∑¡¥¬ æ∆¿Ã≈€¿Ã Ω«¡¶∑Œ ¿÷¥¬¡ˆ »Æ¿Œ «—¥Ÿ.
-bool CExchange::Check(int* piItemCount)
-{
-	if (GetOwner()->GetGold() < m_lGold)
-		return false;
-
-#if defined(__CHEQUE_SYSTEM__)
-	if (GetOwner()->GetCheque() < m_lCheque)
-		return false;
-#endif
-
-	int item_count = 0;
-
-	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		if (!m_apItems[i])
-			continue;
-
-		if (!m_aItemPos[i].IsValidItemPosition())
-			return false;
-
-		if (m_apItems[i] != GetOwner()->GetItem(m_aItemPos[i]))
-			return false;
-
-		++item_count;
-	}
-
-	*piItemCount = item_count;
-	return true;
-}
-
-bool CExchange::CheckSpace()
-{
-	static CGrid s_grid1(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
-	static CGrid s_grid2(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	static CGrid s_grid3(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
-	static CGrid s_grid4(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
-#endif
-
-	s_grid1.Clear();
-	s_grid2.Clear();
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	s_grid3.Clear();
-	s_grid4.Clear();
-#endif
-
-	LPCHARACTER victim = GetCompany()->GetOwner();
-	LPITEM item;
-
-	int i;
-
-	for (i = 0; i < INVENTORY_PAGE_SIZE * 1; ++i)
-	{
-		if (!(item = victim->GetInventoryItem(i)))
-			continue;
-
-		s_grid1.Put(i, 1, item->GetSize());
-	}
-	for (i = INVENTORY_PAGE_SIZE * 1; i < INVENTORY_PAGE_SIZE * 2; ++i)
-	{
-		if (!(item = victim->GetInventoryItem(i)))
-			continue;
-
-		s_grid2.Put(i - INVENTORY_PAGE_SIZE * 1, 1, item->GetSize());
-	}
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	for (i = INVENTORY_PAGE_SIZE * 2; i < INVENTORY_PAGE_SIZE * 3; ++i)
-	{
-		if (!(item = victim->GetInventoryItem(i)))
-			continue;
-
-		s_grid3.Put(i - INVENTORY_PAGE_SIZE * 2, 1, item->GetSize());
-	}
-	for (i = INVENTORY_PAGE_SIZE * 3; i < INVENTORY_PAGE_SIZE * 4; ++i)
-	{
-		if (!(item = victim->GetInventoryItem(i)))
-			continue;
-
-		s_grid4.Put(i - INVENTORY_PAGE_SIZE * 3, 1, item->GetSize());
-	}
-#endif
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	// æ∆... π∫∞° ∞≥∫¥Ω≈ ∞∞¡ˆ∏∏... øÎ»•ºÆ ¿Œ∫•¿ª ≥Î∏÷ ¿Œ∫• ∫∏∞Ì µ˚∂Û ∏∏µÁ ≥ª ¿ﬂ∏¯¿Ã¥Ÿ §–§–
-	static std::vector <WORD> s_vDSGrid(DRAGON_SOUL_INVENTORY_MAX_NUM);
-
-	// ¿œ¥‹ øÎ»•ºÆ¿ª ±≥»Ø«œ¡ˆ æ ¿ª ∞°¥…º∫¿Ã ≈©π«∑Œ, øÎ»•ºÆ ¿Œ∫• ∫πªÁ¥¬ øÎ»•ºÆ¿Ã ¿÷¿ª ∂ß «œµµ∑œ «—¥Ÿ.
-	bool bDSInitialized = false;
-#endif
-
-	for (i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		if (!(item = m_apItems[i]))
-			continue;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-		{
-			if (!victim->DragonSoul_IsQualified())
-				return false;
-
-			if (!bDSInitialized)
-			{
-				bDSInitialized = true;
-				victim->CopyDragonSoulItemGrid(s_vDSGrid);
-			}
-
-			bool bExistEmptySpace = false;
-			WORD wBasePos = DSManager::instance().GetBasePosition(item);
-			if (wBasePos >= DRAGON_SOUL_INVENTORY_MAX_NUM)
-				return false;
-
-			for (int i = 0; i < DRAGON_SOUL_BOX_SIZE; i++)
-			{
-				WORD wPos = wBasePos + i;
-				if (0 == s_vDSGrid[wPos])
-				{
-					bool bEmpty = true;
-					for (int j = 1; j < item->GetSize(); j++)
-					{
-						if (s_vDSGrid[wPos + j * DRAGON_SOUL_BOX_COLUMN_NUM])
-						{
-							bEmpty = false;
-							break;
-						}
-					}
-					if (bEmpty)
-					{
-						for (int j = 0; j < item->GetSize(); j++)
-						{
-							s_vDSGrid[wPos + j * DRAGON_SOUL_BOX_COLUMN_NUM] = wPos + 1;
-						}
-						bExistEmptySpace = true;
-						break;
-					}
-				}
-				if (bExistEmptySpace)
-					break;
-			}
-			if (!bExistEmptySpace)
-				return false;
-		}
-		else
-#endif
-		{
-			int iPos;
-
-			if ((iPos = s_grid1.FindBlank(1, item->GetSize())) >= 0)
-				s_grid1.Put(iPos, 1, item->GetSize());
-			else if ((iPos = s_grid2.FindBlank(1, item->GetSize())) >= 0)
-				s_grid2.Put(iPos, 1, item->GetSize());
-#if defined(__EXTEND_INVEN_SYSTEM__)
-			else if ((iPos = s_grid3.FindBlank(1, item->GetSize())) >= 0)
-			{
-				int iExtendMaxPos = (INVENTORY_WIDTH * victim->GetExtendInvenStage()) - 1;
-				if (iPos > iExtendMaxPos)
-					return false;
-
-				if (item->GetSize() > 1)
-				{
-					iExtendMaxPos -= (INVENTORY_WIDTH * (item->GetSize() - 1));
-					if (iPos > iExtendMaxPos)
-						return false;
-				}
-				s_grid3.Put(iPos, 1, item->GetSize());
-			}
-			else if ((iPos = s_grid4.FindBlank(1, item->GetSize())) >= 0)
-			{
-				int iExtendMaxPos = (INVENTORY_WIDTH * (victim->GetExtendInvenStage() - INVENTORY_HEIGHT)) - 1;
-				if (iPos > iExtendMaxPos)
-					return false;
-
-				if (item->GetSize() > 1)
-				{
-					iExtendMaxPos -= (INVENTORY_WIDTH * (item->GetSize() - 1));
-					if (iPos > iExtendMaxPos)
-						return false;
-				}
-				s_grid4.Put(iPos, 1, item->GetSize());
-			}
-#endif
-			else
-				return false; // No space left in inventory
-		}
-	}
-
-	return true;
-}
-
-// ±≥»Ø ≥° (æ∆¿Ã≈€∞˙ µ∑ µÓ¿ª Ω«¡¶∑Œ ø≈±‰¥Ÿ)
-bool CExchange::Done()
-{
-	int empty_pos, i;
-	LPITEM item;
-
-	LPCHARACTER victim = GetCompany()->GetOwner();
-
-#if defined(__CHEQUE_SYSTEM__)
-	if (m_lCheque)
-	{
-		long vic_cheque = victim->GetCheque() + m_lCheque;
-		if (vic_cheque > CHEQUE_MAX)
-		{
-			// exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The has reached cheque limit."));
-			return false;
-		}
-	}
-#endif
-
-	for (i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		if (!(item = m_apItems[i]))
-			continue;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-			empty_pos = victim->GetEmptyDragonSoulInventory(item);
-		else
-#endif
-			empty_pos = victim->GetEmptyInventory(item->GetSize());
-
-		if (empty_pos < 0)
-		{
-			sys_err("Exchange::Done : Cannot find blank position in inventory %s <-> %s item %s",
-				m_pOwner->GetName(), victim->GetName(), item->GetName());
-			continue;
-		}
-
-		if (empty_pos < 0)
-		{
-			sys_err("Exchange::Done : Cannot find blank position in inventory %s <-> %s item %s",
-					m_pOwner->GetName(), victim->GetName(), item->GetName());
-			continue;
-		}
-
-		assert(empty_pos >= 0);
-
-		m_pOwner->SyncQuickslot(SLOT_TYPE_INVENTORY, item->GetCell(), WORD_MAX);
-
-#ifdef __GROWTH_PET_SYSTEM__
-		if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
-		{
-			LPGROWTH_PET pkPet = item->GetOwner()->GetGrowthPet(item->GetSocket(2));
-			if (pkPet)
-			{
-				// Remove from previous owner
-				item->GetOwner()->DeleteGrowthPet(item->GetSocket(2));
-
-				// Add to the new owner
-				victim->SetGrowthPet(pkPet);
-				pkPet->Save();
-			}
-		}
-#endif
-
-		item->RemoveFromCharacter();
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (item->IsDragonSoul())
-			item->AddToCharacter(victim, TItemPos(DRAGON_SOUL_INVENTORY, empty_pos));
-		else
-#endif
-			item->AddToCharacter(victim, TItemPos(INVENTORY, empty_pos));
-		ITEM_MANAGER::instance().FlushDelayedSave(item);
-
-		item->SetExchanging(false);
-		{
-			char exchange_buf[51];
-
-			snprintf(exchange_buf, sizeof(exchange_buf), "%s %u %u", item->GetName(), GetOwner()->GetPlayerID(), item->GetCount());
-			LogManager::instance().ItemLog(victim, item, "EXCHANGE_TAKE", exchange_buf);
-
-			snprintf(exchange_buf, sizeof(exchange_buf), "%s %u %u", item->GetName(), victim->GetPlayerID(), item->GetCount());
-			LogManager::instance().ItemLog(GetOwner(), item, "EXCHANGE_GIVE", exchange_buf);
-
-			if (item->GetVnum() >= 80003 && item->GetVnum() <= 80007)
-			{
-				LogManager::instance().GoldBarLog(victim->GetPlayerID(), item->GetID(), EXCHANGE_TAKE, "");
-				LogManager::instance().GoldBarLog(GetOwner()->GetPlayerID(), item->GetID(), EXCHANGE_GIVE, "");
-			}
-
-			m_pOwner->CreateFly(FLY_SP_MEDIUM, victim);
-			for (int i = 0; i < 3; i++)
-				m_pOwner->CreateFly(FLY_SP_SMALL, victim);
-		}
-
-		m_apItems[i] = NULL;
-	}
-
-	if (m_lGold)
-	{
-		GetOwner()->PointChange(POINT_GOLD, -m_lGold, true);
-		victim->PointChange(POINT_GOLD, m_lGold, true);
-
-		if (m_lGold > 1000)
-		{
-			char exchange_buf[51];
-			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", GetOwner()->GetPlayerID(), GetOwner()->GetName());
-			LogManager::instance().CharLog(victim, m_lGold, "EXCHANGE_GOLD_TAKE", exchange_buf);
-
-			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", victim->GetPlayerID(), victim->GetName());
-			LogManager::instance().CharLog(GetOwner(), m_lGold, "EXCHANGE_GOLD_GIVE", exchange_buf);
-		}
-	}
-
-#if defined(__CHEQUE_SYSTEM__)
-	if (m_lCheque)
-	{
-		GetOwner()->PointChange(POINT_CHEQUE, -m_lCheque, true);
-		victim->PointChange(POINT_CHEQUE, m_lCheque, true);
-
-		if (m_lCheque > 1000)
-		{
-			char exchange_buf[51];
-			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", GetOwner()->GetPlayerID(), GetOwner()->GetName());
-			LogManager::instance().CharLog(victim, m_lCheque, "EXCHANGE_GOLD_TAKE", exchange_buf);
-
-			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", victim->GetPlayerID(), victim->GetName());
-			LogManager::instance().CharLog(GetOwner(), m_lCheque, "EXCHANGE_GOLD_GIVE", exchange_buf);
-		}
-	}
-#endif
-
-	m_pGrid->Clear();
-	return true;
-}
-
-// ±≥»Ø¿ª µø¿«
-bool CExchange::Accept(bool bAccept)
-{
-	if (m_bAccept == bAccept)
-		return true;
-
-	m_bAccept = bAccept;
-
-	// µ— ¥Ÿ µø¿« «ﬂ¿∏π«∑Œ ±≥»Ø º∫∏≥
-	if (m_bAccept && GetCompany()->m_bAccept)
-	{
-		int iItemCount;
-
-		LPCHARACTER victim = GetCompany()->GetOwner();
-
-		// PREVENT_PORTAL_AFTER_EXCHANGE
-		GetOwner()->SetExchangeTime();
-		victim->SetExchangeTime();
-		// END_PREVENT_PORTAL_AFTER_EXCHANGE
-
-		if (GetOwner()->IsRunningQuest() || victim->IsRunningQuest())
-			goto EXCHANGE_END;
-	
-		// exchange_check ø°º≠¥¬ ±≥»Ø«“ æ∆¿Ã≈€µÈ¿Ã ¡¶¿⁄∏Æø° ¿÷≥™ »Æ¿Œ«œ∞Ì,
-		// ø§≈©µµ √Ê∫–»˜ ¿÷≥™ »Æ¿Œ«—¥Ÿ, µŒπ¯¬∞ ¿Œ¿⁄∑Œ ±≥»Ø«“ æ∆¿Ã≈€ ∞≥ºˆ
-		// ∏¶ ∏Æ≈œ«—¥Ÿ.
-		if (!Check(&iItemCount))
-		{
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("µ∑¿Ã ∫Œ¡∑«œ∞≈≥™ æ∆¿Ã≈€¿Ã ¡¶¿⁄∏Æø° æ¯Ω¿¥œ¥Ÿ."));
-			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ªÛ¥ÎπÊ¿« µ∑¿Ã ∫Œ¡∑«œ∞≈≥™ æ∆¿Ã≈€¿Ã ¡¶¿⁄∏Æø° æ¯Ω¿¥œ¥Ÿ."));
-			goto EXCHANGE_END;
-		}
-
-		// ∏Æ≈œ πﬁ¿∫ æ∆¿Ã≈€ ∞≥ºˆ∑Œ ªÛ¥ÎπÊ¿« º“¡ˆ«∞ø° ≥≤¿∫ ¿⁄∏Æ∞° ¿÷≥™ »Æ¿Œ«—¥Ÿ.
-		if (!CheckSpace())
-		{
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ªÛ¥ÎπÊ¿« º“¡ˆ«∞ø° ∫Û ∞¯∞£¿Ã æ¯Ω¿¥œ¥Ÿ."));
-			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("º“¡ˆ«∞ø° ∫Û ∞¯∞£¿Ã æ¯Ω¿¥œ¥Ÿ."));
-			goto EXCHANGE_END;
-		}
-
-		// ªÛ¥ÎπÊµµ ∏∂¬˘∞°¡ˆ∑Œ..
-		if (!GetCompany()->Check(&iItemCount))
-		{
-			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("µ∑¿Ã ∫Œ¡∑«œ∞≈≥™ æ∆¿Ã≈€¿Ã ¡¶¿⁄∏Æø° æ¯Ω¿¥œ¥Ÿ."));
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ªÛ¥ÎπÊ¿« µ∑¿Ã ∫Œ¡∑«œ∞≈≥™ æ∆¿Ã≈€¿Ã ¡¶¿⁄∏Æø° æ¯Ω¿¥œ¥Ÿ."));
-			goto EXCHANGE_END;
-		}
-
-		if (!GetCompany()->CheckSpace())
-		{
-			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ªÛ¥ÎπÊ¿« º“¡ˆ«∞ø° ∫Û ∞¯∞£¿Ã æ¯Ω¿¥œ¥Ÿ."));
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("º“¡ˆ«∞ø° ∫Û ∞¯∞£¿Ã æ¯Ω¿¥œ¥Ÿ."));
-			goto EXCHANGE_END;
-		}
-
-		if (db_clientdesc->GetSocket() == INVALID_SOCKET)
-		{
-			sys_err("Cannot use exchange feature while DB cache connection is dead.");
-			victim->ChatPacket(CHAT_TYPE_INFO, "Unknown error");
-			GetOwner()->ChatPacket(CHAT_TYPE_INFO, "Unknown error");
-			goto EXCHANGE_END;
-		}
-
-		if (Done())
-		{
-			if (m_lGold) // µ∑¿Ã ¿÷¿ª ãö∏∏ ¿˙¿Â
-				GetOwner()->Save();
-
-#if defined(__CHEQUE_SYSTEM__)
-			if (m_lCheque)
-				GetOwner()->Save();
-#endif
-
-			if (GetCompany()->Done())
-			{
-				if (GetCompany()->m_lGold) // µ∑¿Ã ¿÷¿ª ∂ß∏∏ ¿˙¿Â
-					victim->Save();
-
-#if defined(__CHEQUE_SYSTEM__)
-				if (GetCompany()->m_lCheque)
-					victim->Save();
-#endif
-
-				// INTERNATIONAL_VERSION
-				GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s ¥‘∞˙¿« ±≥»Ø¿Ã º∫ªÁ µ«æ˙Ω¿¥œ¥Ÿ.", victim->GetName()));
-				victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s ¥‘∞˙¿« ±≥»Ø¿Ã º∫ªÁ µ«æ˙Ω¿¥œ¥Ÿ.", GetOwner()->GetName()));
-				// END_OF_INTERNATIONAL_VERSION
-			}
-		}
-
-	EXCHANGE_END:
-		Cancel();
-		return false;
-	}
-	else
-	{
-		// æ∆¥œ∏È acceptø° ¥Î«— ∆–≈∂¿ª ∫∏≥ª¿⁄.
-		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_ACCEPT, true, m_bAccept, NPOS, 0);
-		exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_ACCEPT, false, m_bAccept, NPOS, 0);
-		return true;
-	}
-}
-
-// ±≥»Ø √Îº“
-void CExchange::Cancel()
-{
-	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_END, 0, 0, NPOS, 0);
-	GetOwner()->SetExchange(NULL);
-
-	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
-	{
-		if (m_apItems[i])
-			m_apItems[i]->SetExchanging(false);
-	}
-
-	if (GetCompany())
-	{
-		GetCompany()->SetCompany(NULL);
-		GetCompany()->Cancel();
-	}
-
-	M2_DELETE(this);
-}
+#include "stdafx.h"
+#include "../../libgame/include/grid.h"
+#include "utils.h"
+#include "desc.h"
+#include "desc_client.h"
+#include "char.h"
+#include "item.h"
+#include "item_manager.h"
+#include "packet.h"
+#include "log.h"
+#include "db.h"
+#include "locale_service.h"
+#include "../../common/length.h"
+#include "exchange.h"
+#include "questmanager.h"
+#include "DragonSoul.h"
+#if defined(__PET_SYSTEM__)
+#	include "PetSystem.h"
+#endif
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+#	include "messenger_manager.h"
+#endif
+
+static bool __ComputeExchangeDestinationSlots(LPCHARACTER victim, LPITEM const* apItems, TItemPos* outPos)
+{
+	if (!victim || !apItems || !outPos)
+		return false;
+
+	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+		outPos[i] = NPOS;
+
+	static CGrid s_grid1(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+	static CGrid s_grid2(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	static CGrid s_grid3(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+	static CGrid s_grid4(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+#endif
+
+	s_grid1.Clear();
+	s_grid2.Clear();
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	s_grid3.Clear();
+	s_grid4.Clear();
+#endif
+
+	for (int pos = 0; pos < INVENTORY_PAGE_SIZE * 1; ++pos)
+	{
+		LPITEM it = victim->GetInventoryItem(pos);
+		if (it)
+			s_grid1.Put(pos, 1, it->GetSize());
+	}
+	for (int pos = INVENTORY_PAGE_SIZE * 1; pos < INVENTORY_PAGE_SIZE * 2; ++pos)
+	{
+		LPITEM it = victim->GetInventoryItem(pos);
+		if (it)
+			s_grid2.Put(pos - INVENTORY_PAGE_SIZE * 1, 1, it->GetSize());
+	}
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (int pos = INVENTORY_PAGE_SIZE * 2; pos < INVENTORY_PAGE_SIZE * 3; ++pos)
+	{
+		LPITEM it = victim->GetInventoryItem(pos);
+		if (it)
+			s_grid3.Put(pos - INVENTORY_PAGE_SIZE * 2, 1, it->GetSize());
+	}
+	for (int pos = INVENTORY_PAGE_SIZE * 3; pos < INVENTORY_PAGE_SIZE * 4; ++pos)
+	{
+		LPITEM it = victim->GetInventoryItem(pos);
+		if (it)
+			s_grid4.Put(pos - INVENTORY_PAGE_SIZE * 3, 1, it->GetSize());
+	}
+#endif
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	static std::vector<WORD> s_vDSGrid(DRAGON_SOUL_INVENTORY_MAX_NUM);
+	bool bDSInitialized = false;
+#endif
+
+	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		LPITEM item = apItems[i];
+		if (!item)
+			continue;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+		{
+			if (!victim->DragonSoul_IsQualified())
+				return false;
+
+			if (!bDSInitialized)
+			{
+				bDSInitialized = true;
+				victim->CopyDragonSoulItemGrid(s_vDSGrid);
+			}
+
+			bool bFound = false;
+			WORD wBasePos = DSManager::instance().GetBasePosition(item);
+			if (wBasePos >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+				return false;
+
+			for (int b = 0; b < DRAGON_SOUL_BOX_SIZE; ++b)
+			{
+				WORD wPos = wBasePos + b;
+				if (s_vDSGrid[wPos] != 0)
+					continue;
+
+				bool bEmpty = true;
+				for (int j = 1; j < item->GetSize(); ++j)
+				{
+					if (s_vDSGrid[wPos + j * DRAGON_SOUL_BOX_COLUMN_NUM])
+					{
+						bEmpty = false;
+						break;
+					}
+				}
+				if (!bEmpty)
+					continue;
+
+				for (int j = 0; j < item->GetSize(); ++j)
+					s_vDSGrid[wPos + j * DRAGON_SOUL_BOX_COLUMN_NUM] = 1;
+
+				outPos[i] = TItemPos(DRAGON_SOUL_INVENTORY, wPos);
+				bFound = true;
+				break;
+			}
+
+			if (!bFound)
+				return false;
+
+			continue;
+		}
+#endif
+
+		const int size = item->GetSize();
+		int pos = s_grid1.FindBlank(1, size);
+		if (pos >= 0)
+		{
+			s_grid1.Put(pos, 1, size);
+			outPos[i] = TItemPos(INVENTORY, pos);
+			continue;
+		}
+
+		pos = s_grid2.FindBlank(1, size);
+		if (pos >= 0)
+		{
+			s_grid2.Put(pos, 1, size);
+			outPos[i] = TItemPos(INVENTORY, pos + INVENTORY_PAGE_SIZE * 1);
+			continue;
+		}
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		pos = s_grid3.FindBlank(1, size);
+		if (pos >= 0)
+		{
+			s_grid3.Put(pos, 1, size);
+			outPos[i] = TItemPos(INVENTORY, pos + INVENTORY_PAGE_SIZE * 2);
+			continue;
+		}
+
+		pos = s_grid4.FindBlank(1, size);
+		if (pos >= 0)
+		{
+			s_grid4.Put(pos, 1, size);
+			outPos[i] = TItemPos(INVENTORY, pos + INVENTORY_PAGE_SIZE * 3);
+			continue;
+		}
+#endif
+
+		return false;
+	}
+
+	return true;
+}
+
+void exchange_packet(LPCHARACTER ch, BYTE sub_header, bool is_me, DWORD arg1, TItemPos arg2, DWORD arg3, void* pvData = NULL);
+
+// »Ø ≈∂
+void exchange_packet(LPCHARACTER ch, BYTE sub_header, bool is_me, DWORD arg1, TItemPos arg2, DWORD arg3, void* pvData)
+{
+	if (!ch->GetDesc())
+		return;
+
+	struct packet_exchange pack_exchg;
+
+	pack_exchg.header = HEADER_GC_EXCHANGE;
+	pack_exchg.sub_header = sub_header;
+	pack_exchg.is_me = is_me;
+	pack_exchg.arg1 = arg1;
+	pack_exchg.arg2 = arg2;
+	pack_exchg.arg3 = arg3;
+
+	if (sub_header == EXCHANGE_SUBHEADER_GC_ITEM_ADD && pvData)
+	{
+		pack_exchg.arg4 = TItemPos(((LPITEM)pvData)->GetWindow(), ((LPITEM)pvData)->GetCell());
+
+		thecore_memcpy(&pack_exchg.alSockets, ((LPITEM)pvData)->GetSockets(), sizeof(pack_exchg.alSockets));
+		thecore_memcpy(&pack_exchg.aAttr, ((LPITEM)pvData)->GetAttributes(), sizeof(pack_exchg.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		pack_exchg.dwTransmutationVnum = static_cast<LPITEM>(pvData)->GetTransmutationVnum();
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		thecore_memcpy(&pack_exchg.RefineElement, ((LPITEM)pvData)->GetRefineElement(), sizeof(pack_exchg.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+		thecore_memcpy(&pack_exchg.aApplyRandom, ((LPITEM)pvData)->GetRandomApplies(), sizeof(pack_exchg.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+		pack_exchg.bSetItem = static_cast<LPITEM>(pvData)->GetItemSetValue();
+#endif
+	}
+	else
+	{
+		pack_exchg.arg4 = TItemPos(RESERVED_WINDOW, 0);
+
+		memset(&pack_exchg.alSockets, 0, sizeof(pack_exchg.alSockets));
+		memset(&pack_exchg.aAttr, 0, sizeof(pack_exchg.aAttr));
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		pack_exchg.dwTransmutationVnum = 0;
+#endif
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		memset(&pack_exchg.RefineElement, 0, sizeof(pack_exchg.RefineElement));
+#endif
+#if defined(__ITEM_APPLY_RANDOM__)
+		memset(&pack_exchg.aApplyRandom, 0, sizeof(pack_exchg.aApplyRandom));
+#endif
+#if defined(__SET_ITEM__)
+		pack_exchg.bSetItem = 0;
+#endif
+	}
+
+	ch->GetDesc()->Packet(&pack_exchg, sizeof(pack_exchg));
+}
+
+// »Ø 
+bool CHARACTER::ExchangeStart(LPCHARACTER victim)
+{
+	if (this == victim) // ⁄± ⁄Ω≈∞ »Ø —¥.
+		return false;
+
+	if (IsObserverMode())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ¬ø »Ø   œ¥."));
+		return false;
+	}
+
+	if (victim->IsRunningQuest())
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("The other person is currently busy so you cannot trade right now."));
+		return false;
+	}
+
+	if (IsRunningQuest())
+		return false;
+
+	if (victim->IsNPC())
+		return false;
+
+	// [Security Fix] Remote Exchange (inter-map) is not allowed.
+	if (victim->IsNPC())
+		return false;
+
+	// [Security] Prevent cross-map / remote exchange via packet injection
+	if (GetMapIndex() != victim->GetMapIndex())
+		return false;
+
+#ifdef __GROWTH_PET_SYSTEM__
+	if (GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("While modifying your pet's stats, you cannot trade, sell items, use the storeroom etc."));
+		return false;
+	}
+
+	if (victim->GetPetWindowType() == PET_WINDOW_ATTR_CHANGE || victim->GetPetWindowType() == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot trade while your trading partner is modifying their pet's stats."));
+		return false;
+	}
+
+	/*
+	if (GetActiveGrowthPet())
+	{
+		ChatPacket(CHAT_TYPE_INFO, "You cannot open a private shop whilst summoning your pet.");
+		return false;
+	}
+
+	if (victim->GetActiveGrowthPet())
+	{
+		ChatPacket(CHAT_TYPE_INFO, "You cannot trade whilst your partner is summoning their pet.");
+		return false;
+	}
+	*/
+#endif
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	if (CMessengerManager::instance().IsBlocked(GetName(), victim->GetName()))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", victim->GetName()));
+		return false;
+	}
+	else if (CMessengerManager::instance().IsBlocked(victim->GetName(), GetName()))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", victim->GetName()));
+		return false;
+	}
+#endif
+
+	// PREVENT_TRADE_WINDOW
+	if (PreventTradeWindow(WND_EXCHANGE, true/*except*/))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ÿ∏ ≈∑√¢  ≈∑ “º œ¥."));
+		return false;
+	}
+
+	if (victim->PreventTradeWindow(WND_EXCHANGE, true/*except*/))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" Ÿ∏ ≈∑Ã∂ ≈∑ “º œ¥."));
+		return false;
+	}
+	// END_PREVENT_TRADE_WINDOW
+
+	int iDist = DISTANCE_APPROX(GetX() - victim->GetX(), GetY() - victim->GetY());
+
+	// ≈∏ √º≈©
+	if (iDist >= EXCHANGE_MAX_DISTANCE)
+		return false;
+
+	if (GetExchange())
+		return false;
+
+	if (victim->GetExchange())
+	{
+		exchange_packet(this, EXCHANGE_SUBHEADER_GC_ALREADY, 0, 0, NPOS, 0);
+		return false;
+	}
+
+	if (victim->IsBlockMode(BLOCK_EXCHANGE))
+	{
+		ChatPacket(CHAT_TYPE_INFO, LC_STRING(" »Ø ≈∫ ‘¥œ¥."));
+		return false;
+	}
+
+	SetExchange(M2_NEW CExchange(this));
+	victim->SetExchange(M2_NEW CExchange(victim));
+
+	victim->GetExchange()->SetCompany(GetExchange());
+	GetExchange()->SetCompany(victim->GetExchange());
+
+	//
+	SetExchangeTime();
+	victim->SetExchangeTime();
+
+	exchange_packet(victim, EXCHANGE_SUBHEADER_GC_START, 0, GetVID(), NPOS, 0);
+	exchange_packet(this, EXCHANGE_SUBHEADER_GC_START, 0, victim->GetVID(), NPOS, 0);
+
+	return true;
+}
+
+CExchange::CExchange(LPCHARACTER pOwner)
+{
+	m_pCompany = NULL;
+
+	m_bAccept = false;
+
+	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		m_apItems[i] = NULL;
+		m_aItemPos[i] = NPOS;
+		m_abItemDisplayPos[i] = 0;
+	}
+
+	m_lGold = 0;
+#if defined(__CHEQUE_SYSTEM__)
+	m_lCheque = 0;
+#endif
+
+	m_pOwner = pOwner;
+	pOwner->SetExchange(this);
+
+	m_pGrid = M2_NEW CGrid(4, 3);
+}
+
+CExchange::~CExchange()
+{
+	M2_DELETE(m_pGrid);
+}
+
+bool CExchange::AddItem(TItemPos item_pos, BYTE display_pos)
+{
+	assert(m_pOwner != NULL && GetCompany());
+
+	if (!item_pos.IsValidItemPosition())
+		return false;
+
+	//  »Ø  
+	if (item_pos.IsEquipPosition())
+		return false;
+
+
+	if (m_pGrid && display_pos >= m_pGrid->GetSize())
+	{
+		sys_err(\"EXCHANGE: display_pos out of bounds (pos=%u, size=%d)\", display_pos, m_pGrid->GetSize());
+		return false;
+	}
+	LPITEM item;
+
+	if (!(item = m_pOwner->GetItem(item_pos)))
+		return false;
+
+	if (IS_SET(item->GetAntiFlag(), ITEM_ANTIFLAG_GIVE))
+	{
+		m_pOwner->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" «≥  œ¥."));
+		return false;
+	}
+
+	if (true == item->isLocked())
+		return false;
+
+#if defined(__PET_SYSTEM__)
+	CPetSystem* pPetSystem = m_pOwner->GetPetSystem();
+	if (pPetSystem && pPetSystem->GetSummonItemVID() == item->GetVID())
+		return false;
+#endif
+
+#if defined(__SOUL_BIND_SYSTEM__)
+	if (item->IsSealed())
+	{
+		m_pOwner->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot give away a soulbound item."));
+		return false;
+	}
+#endif
+
+	// Ãπ »Ø√¢ ﬂ∞ Œ∞?
+	if (item->IsExchanging())
+	{
+		sys_log(0, "EXCHANGE under exchanging");
+		return false;
+	}
+
+	if (!m_pGrid->IsEmpty(display_pos, 1, item->GetSize()))
+	{
+		sys_log(0, "EXCHANGE not empty item_pos %d %d %d", display_pos, 1, item->GetSize());
+		return false;
+	}
+
+	Accept(false);
+	GetCompany()->Accept(false);
+
+	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		if (m_apItems[i])
+			continue;
+
+		m_apItems[i] = item;
+		m_aItemPos[i] = item_pos;
+		m_abItemDisplayPos[i] = display_pos;
+		m_pGrid->Put(display_pos, 1, item->GetSize());
+
+		item->SetExchanging(true);
+
+#ifdef __GROWTH_PET_SYSTEM__
+		if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
+		{
+			LPGROWTH_PET pkPet = item->GetOwner()->GetGrowthPet(item->GetSocket(2));
+
+			// Pet might not be stored in the bag
+			if (pkPet)
+				pkPet->PetSetExchangePacket(GetCompany()->GetOwner());
+		}
+#endif
+
+		exchange_packet(m_pOwner,
+			EXCHANGE_SUBHEADER_GC_ITEM_ADD,
+			true,
+			item->GetVnum(),
+			TItemPos(RESERVED_WINDOW, display_pos),
+			item->GetCount(),
+			item);
+
+		exchange_packet(GetCompany()->GetOwner(),
+			EXCHANGE_SUBHEADER_GC_ITEM_ADD,
+			false,
+			item->GetVnum(),
+			TItemPos(RESERVED_WINDOW, display_pos),
+			item->GetCount(),
+			item);
+
+		sys_log(0, "EXCHANGE AddItem success %s pos(%d, %d) %d", item->GetName(), item_pos.window_type, item_pos.cell, display_pos);
+
+		return true;
+	}
+
+	// ﬂ∞  
+	return false;
+}
+
+bool CExchange::RemoveItem(BYTE pos)
+{
+	if (pos >= EXCHANGE_ITEM_MAX_NUM)
+		return false;
+
+	if (!m_apItems[pos])
+		return false;
+
+	TItemPos PosOfInventory = m_aItemPos[pos];
+	m_apItems[pos]->SetExchanging(false);
+
+	m_pGrid->Get(m_abItemDisplayPos[pos], 1, m_apItems[pos]->GetSize());
+
+	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_ITEM_DEL, true, pos, NPOS, 0);
+	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_ITEM_DEL, false, pos, PosOfInventory, 0);
+
+	Accept(false);
+	GetCompany()->Accept(false);
+
+	m_apItems[pos] = NULL;
+	m_aItemPos[pos] = NPOS;
+	m_abItemDisplayPos[pos] = 0;
+	return true;
+}
+
+bool CExchange::AddGold(long gold)
+{
+	if (gold <= 0 || gold > EXCHANGE_YANG_MAX)
+		return false;
+
+	if (GetOwner()->GetGold() < gold)
+	{
+		//  ÷¥  .
+		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_GOLD, 0, 0, NPOS, 0);
+		return false;
+	}
+
+	if (LC_IsCanada() == true || LC_IsEurope() == true)
+	{
+		if (m_lGold > 0)
+		{
+			return false;
+		}
+	}
+
+	Accept(false);
+	GetCompany()->Accept(false);
+
+	m_lGold = gold;
+
+	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_GOLD_ADD, true, m_lGold, NPOS, 0);
+	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_GOLD_ADD, false, m_lGold, NPOS, 0);
+	return true;
+}
+
+#if defined(__CHEQUE_SYSTEM__)
+bool CExchange::AddCheque(long cheque)
+{
+	if (cheque <= 0 || cheque > EXCHANGE_CHEQUE_MAX)
+		return false;
+
+	if (GetOwner()->GetCheque() < cheque)
+	{
+		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
+		return false;
+	}
+
+	LPCHARACTER victim = GetCompany()->GetOwner();
+
+	if (m_lCheque)
+	{
+		long vic_cheque = victim->GetCheque() + m_lCheque;
+		if (vic_cheque > CHEQUE_MAX)
+		{
+			exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("This user can not accept that much cheque."));
+			return false;
+		}
+	}
+
+	if (LC_IsCanada() == true || LC_IsEurope() == true)
+	{
+		if (m_lCheque > 0)
+		{
+			return false;
+		}
+	}
+
+	Accept(false);
+	GetCompany()->Accept(false);
+
+	m_lCheque = cheque;
+
+	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, true, m_lCheque, NPOS, 0);
+	exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_CHEQUE_ADD, false, m_lCheque, NPOS, 0);
+	return true;
+}
+#endif
+
+//   ÷¥, »Øœ∑   ÷¥ »Æ —¥.
+bool CExchange::Check(int* piItemCount)
+{
+	if (GetOwner()->GetGold() < m_lGold)
+		return false;
+
+#if defined(__CHEQUE_SYSTEM__)
+	if (GetOwner()->GetCheque() < m_lCheque)
+		return false;
+#endif
+
+	int item_count = 0;
+
+	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		if (!m_apItems[i])
+			continue;
+
+		if (!m_aItemPos[i].IsValidItemPosition())
+			return false;
+
+		if (m_apItems[i] != GetOwner()->GetItem(m_aItemPos[i]))
+			return false;
+
+		++item_count;
+	}
+
+	*piItemCount = item_count;
+	return true;
+}
+
+bool CExchange::CheckSpace()
+{
+	static CGrid s_grid1(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+	static CGrid s_grid2(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	static CGrid s_grid3(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+	static CGrid s_grid4(5, INVENTORY_MAX_NUM / 5 / INVENTORY_PAGE_COUNT);
+#endif
+
+	s_grid1.Clear();
+	s_grid2.Clear();
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	s_grid3.Clear();
+	s_grid4.Clear();
+#endif
+
+	LPCHARACTER victim = GetCompany()->GetOwner();
+	LPITEM item;
+
+	int i;
+
+	for (i = 0; i < INVENTORY_PAGE_SIZE * 1; ++i)
+	{
+		if (!(item = victim->GetInventoryItem(i)))
+			continue;
+
+		s_grid1.Put(i, 1, item->GetSize());
+	}
+	for (i = INVENTORY_PAGE_SIZE * 1; i < INVENTORY_PAGE_SIZE * 2; ++i)
+	{
+		if (!(item = victim->GetInventoryItem(i)))
+			continue;
+
+		s_grid2.Put(i - INVENTORY_PAGE_SIZE * 1, 1, item->GetSize());
+	}
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	for (i = INVENTORY_PAGE_SIZE * 2; i < INVENTORY_PAGE_SIZE * 3; ++i)
+	{
+		if (!(item = victim->GetInventoryItem(i)))
+			continue;
+
+		s_grid3.Put(i - INVENTORY_PAGE_SIZE * 2, 1, item->GetSize());
+	}
+	for (i = INVENTORY_PAGE_SIZE * 3; i < INVENTORY_PAGE_SIZE * 4; ++i)
+	{
+		if (!(item = victim->GetInventoryItem(i)))
+			continue;
+
+		s_grid4.Put(i - INVENTORY_PAGE_SIZE * 3, 1, item->GetSize());
+	}
+#endif
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	// ...   ... »• Œ∫  Œ∫     ﬂ∏Ã¥ –§
+	static std::vector <WORD> s_vDSGrid(DRAGON_SOUL_INVENTORY_MAX_NUM);
+
+	// œ¥ »• »Ø  …º ≈©«∑, »• Œ∫  »•   œµ —¥.
+	bool bDSInitialized = false;
+#endif
+
+	if (m_lGold)
+	{
+		const long long vic_gold = (long long)victim->GetGold() + (long long)m_lGold;
+		if (vic_gold >= (long long)GOLD_MAX)
+		{
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The target has reached Yang limit."));
+			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have reached Yang limit."));
+			return false;
+		}
+	}
+
+	if (!__ComputeExchangeDestinationSlots(victim, m_apItems, aDstPos))
+	{
+		GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The target does not have enough inventory space."));
+		victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You do not have enough inventory space."));
+		return false;
+	}
+
+	for (i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		if (!(item = m_apItems[i]))
+			continue;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (item->IsDragonSoul())
+		{
+			if (!victim->DragonSoul_IsQualified())
+				return false;
+
+			if (!bDSInitialized)
+			{
+				bDSInitialized = true;
+				victim->CopyDragonSoulItemGrid(s_vDSGrid);
+			}
+
+			bool bExistEmptySpace = false;
+			WORD wBasePos = DSManager::instance().GetBasePosition(item);
+			if (wBasePos >= DRAGON_SOUL_INVENTORY_MAX_NUM)
+				return false;
+
+			for (int i = 0; i < DRAGON_SOUL_BOX_SIZE; i++)
+			{
+				WORD wPos = wBasePos + i;
+				if (0 == s_vDSGrid[wPos])
+				{
+					bool bEmpty = true;
+					for (int j = 1; j < item->GetSize(); j++)
+					{
+						if (s_vDSGrid[wPos + j * DRAGON_SOUL_BOX_COLUMN_NUM])
+						{
+							bEmpty = false;
+							break;
+						}
+					}
+					if (bEmpty)
+					{
+						for (int j = 0; j < item->GetSize(); j++)
+						{
+							s_vDSGrid[wPos + j * DRAGON_SOUL_BOX_COLUMN_NUM] = wPos + 1;
+						}
+						bExistEmptySpace = true;
+						break;
+					}
+				}
+				if (bExistEmptySpace)
+					break;
+			}
+			if (!bExistEmptySpace)
+				return false;
+		}
+		else
+#endif
+		{
+			int iPos;
+
+			if ((iPos = s_grid1.FindBlank(1, item->GetSize())) >= 0)
+				s_grid1.Put(iPos, 1, item->GetSize());
+			else if ((iPos = s_grid2.FindBlank(1, item->GetSize())) >= 0)
+				s_grid2.Put(iPos, 1, item->GetSize());
+#if defined(__EXTEND_INVEN_SYSTEM__)
+			else if ((iPos = s_grid3.FindBlank(1, item->GetSize())) >= 0)
+			{
+				int iExtendMaxPos = (INVENTORY_WIDTH * victim->GetExtendInvenStage()) - 1;
+				if (iPos > iExtendMaxPos)
+					return false;
+
+				if (item->GetSize() > 1)
+				{
+					iExtendMaxPos -= (INVENTORY_WIDTH * (item->GetSize() - 1));
+					if (iPos > iExtendMaxPos)
+						return false;
+				}
+				s_grid3.Put(iPos, 1, item->GetSize());
+			}
+			else if ((iPos = s_grid4.FindBlank(1, item->GetSize())) >= 0)
+			{
+				int iExtendMaxPos = (INVENTORY_WIDTH * (victim->GetExtendInvenStage() - INVENTORY_HEIGHT)) - 1;
+				if (iPos > iExtendMaxPos)
+					return false;
+
+				if (item->GetSize() > 1)
+				{
+					iExtendMaxPos -= (INVENTORY_WIDTH * (item->GetSize() - 1));
+					if (iPos > iExtendMaxPos)
+						return false;
+				}
+				s_grid4.Put(iPos, 1, item->GetSize());
+			}
+#endif
+			else
+				return false; // No space left in inventory
+		}
+	}
+
+	return true;
+}
+
+// »Ø  (€∞    ≈±)
+bool CExchange::Done()
+{
+	int i;
+	LPITEM item;
+
+	LPCHARACTER victim = GetCompany()->GetOwner();
+	TItemPos aDstPos[EXCHANGE_ITEM_MAX_NUM];
+
+#if defined(__CHEQUE_SYSTEM__)
+	if (m_lCheque)
+	{
+		long vic_cheque = victim->GetCheque() + m_lCheque;
+		if (vic_cheque > CHEQUE_MAX)
+		{
+			// exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_LESS_CHEQUE, 0, 0, NPOS, 0);
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The has reached cheque limit."));
+			return false;
+		}
+	}
+#endif
+
+	if (m_lGold)
+	{
+		const long long vic_gold = (long long)victim->GetGold() + (long long)m_lGold;
+		if (vic_gold >= (long long)GOLD_MAX)
+		{
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The target has reached Yang limit."));
+			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You have reached Yang limit."));
+			return false;
+		}
+	}
+
+	if (!__ComputeExchangeDestinationSlots(victim, m_apItems, aDstPos))
+	{
+		GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The target does not have enough inventory space."));
+		victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You do not have enough inventory space."));
+		return false;
+	}
+
+	for (i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		if (!(item = m_apItems[i]))
+			continue;
+
+		const TItemPos& dstPos = aDstPos[i];
+		if (!dstPos.IsValidItemPosition())
+			return false;
+
+		m_pOwner->SyncQuickslot(SLOT_TYPE_INVENTORY, item->GetCell(), WORD_MAX);
+
+#ifdef __GROWTH_PET_SYSTEM__
+		if (item->GetType() == ITEM_PET && item->GetSubType() == PET_BAG)
+		{
+			LPGROWTH_PET pkPet = item->GetOwner()->GetGrowthPet(item->GetSocket(2));
+			if (pkPet)
+			{
+				// Remove from previous owner
+				item->GetOwner()->DeleteGrowthPet(item->GetSocket(2));
+
+				// Add to the new owner
+				victim->SetGrowthPet(pkPet);
+				pkPet->Save();
+			}
+		}
+#endif
+
+		item->RemoveFromCharacter();
+		item->AddToCharacter(victim, dstPos);
+		ITEM_MANAGER::instance().FlushDelayedSave(item);
+
+		item->SetExchanging(false);
+		{
+			char exchange_buf[51];
+
+			snprintf(exchange_buf, sizeof(exchange_buf), "%s %u %u", item->GetName(), GetOwner()->GetPlayerID(), item->GetCount());
+			LogManager::instance().ItemLog(victim, item, "EXCHANGE_TAKE", exchange_buf);
+
+			snprintf(exchange_buf, sizeof(exchange_buf), "%s %u %u", item->GetName(), victim->GetPlayerID(), item->GetCount());
+			LogManager::instance().ItemLog(GetOwner(), item, "EXCHANGE_GIVE", exchange_buf);
+
+			if (item->GetVnum() >= 80003 && item->GetVnum() <= 80007)
+			{
+				LogManager::instance().GoldBarLog(victim->GetPlayerID(), item->GetID(), EXCHANGE_TAKE, "");
+				LogManager::instance().GoldBarLog(GetOwner()->GetPlayerID(), item->GetID(), EXCHANGE_GIVE, "");
+			}
+
+			m_pOwner->CreateFly(FLY_SP_MEDIUM, victim);
+			for (int i = 0; i < 3; i++)
+				m_pOwner->CreateFly(FLY_SP_SMALL, victim);
+		}
+
+		m_apItems[i] = NULL;
+	}
+
+	if (m_lGold)
+	{
+		GetOwner()->PointChange(POINT_GOLD, -m_lGold, true);
+		victim->PointChange(POINT_GOLD, m_lGold, true);
+
+		if (m_lGold > 1000)
+		{
+			char exchange_buf[51];
+			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", GetOwner()->GetPlayerID(), GetOwner()->GetName());
+			LogManager::instance().CharLog(victim, m_lGold, "EXCHANGE_GOLD_TAKE", exchange_buf);
+
+			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", victim->GetPlayerID(), victim->GetName());
+			LogManager::instance().CharLog(GetOwner(), m_lGold, "EXCHANGE_GOLD_GIVE", exchange_buf);
+		}
+	}
+
+#if defined(__CHEQUE_SYSTEM__)
+	if (m_lCheque)
+	{
+		GetOwner()->PointChange(POINT_CHEQUE, -m_lCheque, true);
+		victim->PointChange(POINT_CHEQUE, m_lCheque, true);
+
+		if (m_lCheque > 1000)
+		{
+			char exchange_buf[51];
+			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", GetOwner()->GetPlayerID(), GetOwner()->GetName());
+			LogManager::instance().CharLog(victim, m_lCheque, "EXCHANGE_GOLD_TAKE", exchange_buf);
+
+			snprintf(exchange_buf, sizeof(exchange_buf), "%u %s", victim->GetPlayerID(), victim->GetName());
+			LogManager::instance().CharLog(GetOwner(), m_lCheque, "EXCHANGE_GOLD_GIVE", exchange_buf);
+		}
+	}
+#endif
+
+	m_pGrid->Clear();
+	return true;
+}
+
+// »Ø 
+bool CExchange::Accept(bool bAccept)
+{
+	if (m_bAccept == bAccept)
+		return true;
+
+	m_bAccept = bAccept;
+
+	//    «∑ »Ø 
+	if (m_bAccept && GetCompany()->m_bAccept)
+	{
+		int iItemCount;
+
+		LPCHARACTER victim = GetCompany()->GetOwner();
+
+		// PREVENT_PORTAL_AFTER_EXCHANGE
+		GetOwner()->SetExchangeTime();
+		victim->SetExchangeTime();
+		// END_PREVENT_PORTAL_AFTER_EXCHANGE
+
+		if (GetOwner()->IsRunningQuest() || victim->IsRunningQuest())
+			goto EXCHANGE_END;
+	
+		// exchange_check  »Ø €µ ⁄∏ ÷≥ »Æœ∞,
+		// ≈©  ÷≥ »Æ—¥, Œπ¬∞ ⁄∑ »Ø  
+		//  —¥.
+		if (!Check(&iItemCount))
+		{
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" œ∞≈≥  ⁄∏ œ¥."));
+			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  œ∞≈≥  ⁄∏ œ¥."));
+			goto EXCHANGE_END;
+		}
+
+		//      «∞  ⁄∏ ÷≥ »Æ—¥.
+		if (!CheckSpace())
+		{
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" «∞   œ¥."));
+			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("«∞   œ¥."));
+			goto EXCHANGE_END;
+		}
+
+		// Êµµ ..
+		if (!GetCompany()->Check(&iItemCount))
+		{
+			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" œ∞≈≥  ⁄∏ œ¥."));
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  œ∞≈≥  ⁄∏ œ¥."));
+			goto EXCHANGE_END;
+		}
+
+		if (!GetCompany()->CheckSpace())
+		{
+			victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" «∞   œ¥."));
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("«∞   œ¥."));
+			goto EXCHANGE_END;
+		}
+
+		if (db_clientdesc->GetSocket() == INVALID_SOCKET)
+		{
+			sys_err("Cannot use exchange feature while DB cache connection is dead.");
+			victim->ChatPacket(CHAT_TYPE_INFO, "Unknown error");
+			GetOwner()->ChatPacket(CHAT_TYPE_INFO, "Unknown error");
+			goto EXCHANGE_END;
+		}
+
+		if (Done())
+		{
+			if (m_lGold) //    
+				GetOwner()->Save();
+
+#if defined(__CHEQUE_SYSTEM__)
+			if (m_lCheque)
+				GetOwner()->Save();
+#endif
+
+			if (GetCompany()->Done())
+			{
+				if (GetCompany()->m_lGold) //    
+					victim->Save();
+
+#if defined(__CHEQUE_SYSTEM__)
+				if (GetCompany()->m_lCheque)
+					victim->Save();
+#endif
+
+				// INTERNATIONAL_VERSION
+				GetOwner()->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s ‘∞ »Ø  «æœ¥.", victim->GetName()));
+				victim->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s ‘∞ »Ø  «æœ¥.", GetOwner()->GetName()));
+				// END_OF_INTERNATIONAL_VERSION
+			}
+		}
+
+	EXCHANGE_END:
+		Cancel();
+		return false;
+	}
+	else
+	{
+		// ∆¥œ∏ accept  ≈∂ .
+		exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_ACCEPT, true, m_bAccept, NPOS, 0);
+		exchange_packet(GetCompany()->GetOwner(), EXCHANGE_SUBHEADER_GC_ACCEPT, false, m_bAccept, NPOS, 0);
+		return true;
+	}
+}
+
+// »Ø 
+void CExchange::Cancel()
+{
+	exchange_packet(GetOwner(), EXCHANGE_SUBHEADER_GC_END, 0, 0, NPOS, 0);
+	GetOwner()->SetExchange(NULL);
+
+	for (int i = 0; i < EXCHANGE_ITEM_MAX_NUM; ++i)
+	{
+		if (m_apItems[i])
+			m_apItems[i]->SetExchanging(false);
+	}
+
+	if (GetCompany())
+	{
+		GetCompany()->SetCompany(NULL);
+		GetCompany()->Cancel();
+	}
+
+	M2_DELETE(this);
+}
diff --git a/server/metin2/Source/Server/game/src/input.cpp b/server/metin2/Source/Server/game/src/input.cpp
index 440ae03..6219b82 100644
--- a/server/metin2/Source/Server/game/src/input.cpp
+++ b/server/metin2/Source/Server/game/src/input.cpp
@@ -1,664 +1,665 @@
-#include "stdafx.h"
-#include <sstream>
-
-#include "desc.h"
-#include "desc_manager.h"
-#include "char.h"
-#include "buffer_manager.h"
-#include "config.h"
-#include "profiler.h"
-#include "p2p.h"
-#include "log.h"
-#include "db.h"
-#include "questmanager.h"
-#include "login_sim.h"
-#include "fishing.h"
-#include "TrafficProfiler.h"
-#include "priv_manager.h"
-#include "castle.h"
-#include "dev_log.h"
-
-#ifndef __WIN32__
-#include "limit_time.h"
-#endif
-
-extern time_t get_global_time();
-
-bool IsEmptyAdminPage()
-{
-	return g_stAdminPageIP.empty();
-}
-
-bool IsAdminPage(const char* ip)
-{
-	for (size_t n = 0; n < g_stAdminPageIP.size(); ++n)
-	{
-		if (g_stAdminPageIP[n] == ip)
-			return 1;
-	}
-	return 0;
-}
-
-void ClearAdminPages()
-{
-	for (size_t n = 0; n < g_stAdminPageIP.size(); ++n)
-		g_stAdminPageIP[n].clear();
-
-	g_stAdminPageIP.clear();
-}
-
-CInputProcessor::CInputProcessor() : m_pPacketInfo(NULL), m_iBufferLeft(0)
-{
-	if (!m_pPacketInfo)
-		BindPacketInfo(&m_packetInfoCG);
-}
-
-void CInputProcessor::BindPacketInfo(CPacketInfo* pPacketInfo)
-{
-	m_pPacketInfo = pPacketInfo;
-}
-
-bool CInputProcessor::Process(LPDESC lpDesc, const void* c_pvOrig, int iBytes, int& r_iBytesProceed)
-{
-	const char* c_pData = (const char*)c_pvOrig;
-
-	BYTE bLastHeader = 0;
-	int iLastPacketLen = 0;
-	int iPacketLen;
-
-	if (!m_pPacketInfo)
-	{
-		sys_err("No packet info has been binded to");
-		return true;
-	}
-
-	for (m_iBufferLeft = iBytes; m_iBufferLeft > 0;)
-	{
-		BYTE bHeader = (BYTE) * (c_pData);
-		const char* c_pszName;
-
-		if (bHeader == 0) // æœ»£»≠ √≥∏Æ∞° ¿÷¿∏π«∑Œ 0π¯ «Ï¥ı¥¬ Ω∫≈µ«—¥Ÿ.
-			iPacketLen = 1;
-		else if (!m_pPacketInfo->Get(bHeader, &iPacketLen, &c_pszName))
-		{
-			sys_err("UNKNOWN HEADER: %d, LAST HEADER: %d(len:%d), %s, REMAIN BYTES: %d, fd: %d",
-				bHeader, bLastHeader, iLastPacketLen, c_pszName, m_iBufferLeft, lpDesc->GetSocket());
-
-			//printdata((BYTE *) c_pvOrig, m_iBufferLeft);
-
-			lpDesc->SetPhase(PHASE_CLOSE);
-			return true;
-		}
-
-		if (m_iBufferLeft < iPacketLen)
-			return true;
-
-		if (bHeader)
-		{
-			if ((test_server || packet_analyze) && bHeader != HEADER_CG_MOVE)
-				sys_log(0, "Packet Analyze [Header %d][bufferLeft %d] ", bHeader, m_iBufferLeft);
-
-			m_pPacketInfo->Start();
-
-			int iExtraPacketSize = Analyze(lpDesc, bHeader, c_pData);
-
-			if (iExtraPacketSize < 0)
-				return true;
-
-			iPacketLen += iExtraPacketSize;
-			lpDesc->Log("%s %d", c_pszName, iPacketLen);
-			m_pPacketInfo->End();
-		}
-
-		// TRAFFIC_PROFILER
-		if (g_bTrafficProfileOn)
-			TrafficProfiler::instance().Report(TrafficProfiler::IODIR_INPUT, bHeader, iPacketLen);
-		// END_OF_TRAFFIC_PROFILER
-
-#if defined(__SEND_SEQUENCE__)
-		if (bHeader == HEADER_CG_PONG)
-			sys_log(0, "PONG! %u %u", m_pPacketInfo->IsSequence(bHeader), *(BYTE*)(c_pData + iPacketLen - sizeof(BYTE)));
-
-		if (m_pPacketInfo->IsSequence(bHeader))
-		{
-			BYTE bSeq = lpDesc->GetSequence();
-			BYTE bSeqReceived = *(BYTE*)(c_pData + iPacketLen - sizeof(BYTE));
-
-			if (bSeq != bSeqReceived)
-			{
-				sys_err("SEQUENCE %x mismatch 0x%x != 0x%x header %u", get_pointer(lpDesc), bSeq, bSeqReceived, bHeader);
-
-				LPCHARACTER ch = lpDesc->GetCharacter();
-
-				char buf[1024];
-				int offset, len;
-
-				offset = snprintf(buf, sizeof(buf), "SEQUENCE_LOG [%s]-------------\n", ch ? ch->GetName() : "UNKNOWN");
-
-				if (offset < 0 || offset >= (int)sizeof(buf))
-					offset = sizeof(buf) - 1;
-
-				for (size_t i = 0; i < lpDesc->m_seq_vector.size(); ++i)
-				{
-					len = snprintf(buf + offset, sizeof(buf) - offset, "\t[%03d : 0x%x]\n",
-						lpDesc->m_seq_vector[i].hdr,
-						lpDesc->m_seq_vector[i].seq);
-
-					if (len < 0 || len >= (int)sizeof(buf) - offset)
-						offset += (sizeof(buf) - offset) - 1;
-					else
-						offset += len;
-				}
-
-				snprintf(buf + offset, sizeof(buf) - offset, "\t[%03d : 0x%x]\n", bHeader, bSeq);
-				sys_err("%s", buf);
-
-				lpDesc->SetPhase(PHASE_CLOSE);
-				return true;
-			}
-			else
-			{
-				lpDesc->push_seq(bHeader, bSeq);
-				lpDesc->SetNextSequence();
-				//sys_err("SEQUENCE %x match %u next %u header %u", lpDesc, bSeq, lpDesc->GetSequence(), bHeader);
-			}
-		}
-#endif
-
-		c_pData += iPacketLen;
-		m_iBufferLeft -= iPacketLen;
-		r_iBytesProceed += iPacketLen;
-
-		iLastPacketLen = iPacketLen;
-		bLastHeader = bHeader;
-
-		if (GetType() != lpDesc->GetInputProcessor()->GetType())
-			return false;
-	}
-
-	return true;
-}
-
-void CInputProcessor::Pong(LPDESC d)
-{
-	d->SetPong(true);
-}
-
-void CInputProcessor::Handshake(LPDESC d, const char* c_pData)
-{
-	TPacketCGHandshake* p = (TPacketCGHandshake*)c_pData;
-
-	if (d->GetHandshake() != p->dwHandshake)
-	{
-		sys_err("Invalid Handshake on %d", d->GetSocket());
-		d->SetPhase(PHASE_CLOSE);
-	}
-	else
-	{
-		if (d->IsPhase(PHASE_HANDSHAKE))
-		{
-			if (d->HandshakeProcess(p->dwTime, p->lDelta, false))
-			{
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-				d->SendKeyAgreement();
-#else
-				if (g_bAuthServer)
-					d->SetPhase(PHASE_AUTH);
-				else
-					d->SetPhase(PHASE_LOGIN);
-#endif
-			}
-		}
-		else
-			d->HandshakeProcess(p->dwTime, p->lDelta, true);
-	}
-}
-
-void CInputProcessor::Version(LPCHARACTER ch, const char* c_pData)
-{
-	if (!ch)
-		return;
-
-	TPacketCGClientVersion* p = (TPacketCGClientVersion*)c_pData;
-	sys_log(0, "VERSION: %s %s %s", ch->GetName(), p->timestamp, p->filename);
-	ch->GetDesc()->SetClientVersion(p->timestamp);
-}
-
-void LoginFailure(LPDESC d, const char* c_pszStatus)
-{
-	if (!d)
-		return;
-
-	TPacketGCLoginFailure failurePacket;
-
-	failurePacket.header = HEADER_GC_LOGIN_FAILURE;
-	strlcpy(failurePacket.szStatus, c_pszStatus, sizeof(failurePacket.szStatus));
-
-	d->Packet(&failurePacket, sizeof(failurePacket));
-}
-
-CInputHandshake::CInputHandshake()
-{
-	CPacketInfoCG* pkPacketInfo = M2_NEW CPacketInfoCG;
-#if defined(__SEND_SEQUENCE__)
-	pkPacketInfo->SetSequence(HEADER_CG_PONG, false);
-#endif
-
-	m_pMainPacketInfo = m_pPacketInfo;
-	BindPacketInfo(pkPacketInfo);
-}
-
-CInputHandshake::~CInputHandshake()
-{
-	if (NULL != m_pPacketInfo)
-	{
-		M2_DELETE(m_pPacketInfo);
-		m_pPacketInfo = NULL;
-	}
-}
-
-std::map<DWORD, CLoginSim*> g_sim;
-std::map<DWORD, CLoginSim*> g_simByPID;
-std::vector<TPlayerTable> g_vec_save;
-
-// BLOCK_CHAT
-ACMD(do_block_chat);
-// END_OF_BLOCK_CHAT
-
-int CInputHandshake::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
-{
-	if (bHeader == 10) // ø£≈Õ¥¬ π´Ω√
-		return 0;
-
-	if (bHeader == HEADER_CG_TEXT)
-	{
-#if !defined(__ALLOW_EXTERNAL_PEER__)
-		if (IsEmptyAdminPage() || !IsAdminPage(inet_ntoa(d->GetAddr().sin_addr)))
-		{
-			sys_log(0, "SOCKET_CMD: BLOCK FROM(%s)", d->GetHostName());
-			d->SetPhase(PHASE_CLOSE);
-			return 0;
-		}
-#endif
-
-		++c_pData;
-		const char* c_pSep;
-
-		if (!(c_pSep = strchr(c_pData, '\n'))) // \n¿ª √£¥¬¥Ÿ.
-			return 0;
-
-		if (*(c_pSep - 1) == '\r')
-			--c_pSep;
-
-		std::string stResult;
-		std::string stBuf;
-		stBuf.assign(c_pData, 0, c_pSep - c_pData);
-
-		sys_log(0, "SOCKET_CMD: FROM(%s) CMD(%s)", d->GetHostName(), stBuf.c_str());
-
-		if (!stBuf.compare("IS_SERVER_UP"))
-		{
-			if (g_bNoMoreClient)
-				stResult = "NO";
-			else
-				stResult = "YES";
-		}
-		//else if (!stBuf.compare("SHOWMETHEMONEY"))
-		else if (stBuf == g_stAdminPagePassword)
-		{
-			if (!IsEmptyAdminPage())
-			{
-				if (!IsAdminPage(inet_ntoa(d->GetAddr().sin_addr)))
-				{
-					char szTmp[64];
-					snprintf(szTmp, sizeof(szTmp), "WEBADMIN : Wrong Connector : %s", inet_ntoa(d->GetAddr().sin_addr));
-					stResult += szTmp;
-				}
-				else
-				{
-					d->SetAdminMode();
-					stResult = "UNKNOWN";
-				}
-			}
-			else
-			{
-				d->SetAdminMode();
-				stResult = "UNKNOWN";
-			}
-		}
-		else if (!stBuf.compare("USER_COUNT"))
-		{
-			char szTmp[64];
-
-			if (!IsEmptyAdminPage())
-			{
-				if (!IsAdminPage(inet_ntoa(d->GetAddr().sin_addr)))
-				{
-					snprintf(szTmp, sizeof(szTmp), "WEBADMIN : Wrong Connector : %s", inet_ntoa(d->GetAddr().sin_addr));
-				}
-				else
-				{
-					int iTotal;
-					int* paiEmpireUserCount;
-					int iLocal;
-					DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
-					snprintf(szTmp, sizeof(szTmp), "%d %d %d %d %d", iTotal, paiEmpireUserCount[1], paiEmpireUserCount[2], paiEmpireUserCount[3], iLocal);
-				}
-			}
-			else
-			{
-				int iTotal;
-				int* paiEmpireUserCount;
-				int iLocal;
-				DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
-				snprintf(szTmp, sizeof(szTmp), "%d %d %d %d %d", iTotal, paiEmpireUserCount[1], paiEmpireUserCount[2], paiEmpireUserCount[3], iLocal);
-			}
-			stResult += szTmp;
-		}
-		else if (!stBuf.compare("CHECK_P2P_CONNECTIONS"))
-		{
-			std::ostringstream oss(std::ostringstream::out);
-			oss << "P2P CONNECTION NUMBER : " << P2P_MANAGER::instance().GetDescCount() << "\n";
-
-			std::string hostNames;
-			P2P_MANAGER::Instance().GetP2PHostNames(hostNames);
-			oss << hostNames;
-
-			stResult = oss.str();
-
-			TPacketGGCheckAwakeness packet;
-			packet.bHeader = HEADER_GG_CHECK_AWAKENESS;
-			P2P_MANAGER::instance().Send(&packet, sizeof(packet));
-		}
-		else if (!stBuf.compare("PACKET_INFO"))
-		{
-			m_pMainPacketInfo->Log("packet_info.txt");
-			stResult = "OK";
-		}
-		else if (!stBuf.compare("PROFILE"))
-		{
-			CProfiler::instance().Log("profile.txt");
-			stResult = "OK";
-		}
-		// gift notify delete command
-		else if (!stBuf.compare(0, 15, "DELETE_AWARDID "))
-		{
-			char szTmp[64];
-			std::string msg = stBuf.substr(15, 26); // item_award ¿« idπ¸¿ß?
-
-			TPacketDeleteAwardID p;
-			p.dwID = (DWORD)(atoi(msg.c_str()));
-			snprintf(szTmp, sizeof(szTmp), "Sent to DB cache to delete ItemAward, id: %d", p.dwID);
-			//sys_log(0,"%d",p.dwID);
-			// strlcpy(p.login, msg.c_str(), sizeof(p.login));
-			db_clientdesc->DBPacket(HEADER_GD_DELETE_AWARDID, 0, &p, sizeof(p));
-			stResult += szTmp;
-		}
-		else
-		{
-			stResult = "UNKNOWN";
-
-			if (d->IsAdminMode())
-			{
-				// æÓµÂπŒ ∏Ì∑…µÈ
-				if (!stBuf.compare(0, 7, "NOTICE "))
-				{
-					std::string msg = stBuf.substr(7, 50);
-					LogManager::instance().CharLog(0, 0, 0, 1, "NOTICE", msg.c_str(), d->GetHostName());
-					BroadcastNotice(msg.c_str());
-				}
-				else if (!stBuf.compare("SHUTDOWN"))
-				{
-					LogManager::instance().CharLog(0, 0, 0, 2, "SHUTDOWN", "", d->GetHostName());
-					TPacketGGShutdown p;
-					p.bHeader = HEADER_GG_SHUTDOWN;
-					P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGShutdown));
-					sys_err("Accept shutdown command from %s.", d->GetHostName());
-					Shutdown(10);
-				}
-				else if (!stBuf.compare("SHUTDOWN_ONLY"))
-				{
-					LogManager::instance().CharLog(0, 0, 0, 2, "SHUTDOWN", "", d->GetHostName());
-					sys_err("Accept shutdown only command from %s.", d->GetHostName());
-					Shutdown(10);
-				}
-				else if (!stBuf.compare(0, 3, "DC "))
-				{
-					std::string msg = stBuf.substr(3, LOGIN_MAX_LEN);
-
-					dev_log(LOG_DEB0, "DC : '%s'", msg.c_str());
-
-					TPacketGGDisconnect pgg;
-
-					pgg.bHeader = HEADER_GG_DISCONNECT;
-					strlcpy(pgg.szLogin, msg.c_str(), sizeof(pgg.szLogin));
-
-					P2P_MANAGER::instance().Send(&pgg, sizeof(TPacketGGDisconnect));
-
-					// delete login key
-					{
-						TPacketDC p;
-						strlcpy(p.login, msg.c_str(), sizeof(p.login));
-						db_clientdesc->DBPacket(HEADER_GD_DC, 0, &p, sizeof(p));
-					}
-				}
-				else if (!stBuf.compare(0, 10, "RELOAD_CRC"))
-				{
-					LoadValidCRCList();
-
-					BYTE bHeader = HEADER_GG_RELOAD_CRC_LIST;
-					P2P_MANAGER::instance().Send(&bHeader, sizeof(BYTE));
-					stResult = "OK";
-				}
-				else if (!stBuf.compare(0, 20, "CHECK_CLIENT_VERSION"))
-				{
-					CheckClientVersion();
-
-					BYTE bHeader = HEADER_GG_CHECK_CLIENT_VERSION;
-					P2P_MANAGER::instance().Send(&bHeader, sizeof(BYTE));
-					stResult = "OK";
-				}
-				else if (!stBuf.compare(0, 6, "RELOAD"))
-				{
-					if (stBuf.size() == 6)
-					{
-						LoadStateUserCount();
-						db_clientdesc->DBPacket(HEADER_GD_RELOAD_PROTO, 0, NULL, 0);
-						DBManager::instance().LoadDBString();
-					}
-					else
-					{
-						char c = stBuf[7];
-
-						switch (LOWER(c))
-						{
-						case 'u':
-							LoadStateUserCount();
-							break;
-
-						case 'p':
-							db_clientdesc->DBPacket(HEADER_GD_RELOAD_PROTO, 0, NULL, 0);
-							break;
-
-						case 's':
-							DBManager::instance().LoadDBString();
-							break;
-
-						case 'q':
-							quest::CQuestManager::instance().Reload();
-							break;
-
-						case 'f':
-							fishing::Initialize();
-							break;
-
-						case 'a':
-							db_clientdesc->DBPacket(HEADER_GD_RELOAD_ADMIN, 0, NULL, 0);
-							sys_log(0, "Reloading admin infomation.");
-							break;
-						}
-					}
-				}
-				else if (!stBuf.compare(0, 6, "EVENT "))
-				{
-					std::istringstream is(stBuf);
-					std::string strEvent, strFlagName;
-					long lValue;
-					is >> strEvent >> strFlagName >> lValue;
-
-					if (!is.fail())
-					{
-						sys_log(0, "EXTERNAL EVENT FLAG name %s value %d", strFlagName.c_str(), lValue);
-						quest::CQuestManager::instance().RequestSetEventFlag(strFlagName, lValue);
-						stResult = "EVENT FLAG CHANGE ";
-						stResult += strFlagName;
-					}
-					else
-					{
-						stResult = "EVENT FLAG FAIL";
-					}
-				}
-				// BLOCK_CHAT
-				else if (!stBuf.compare(0, 11, "BLOCK_CHAT "))
-				{
-					std::istringstream is(stBuf);
-					std::string strBlockChat, strCharName;
-					long lDuration;
-					is >> strBlockChat >> strCharName >> lDuration;
-
-					if (!is.fail())
-					{
-						sys_log(0, "EXTERNAL BLOCK_CHAT name %s duration %d", strCharName.c_str(), lDuration);
-
-						do_block_chat(NULL, const_cast<char*>(stBuf.c_str() + 11), 0, 0);
-
-						stResult = "BLOCK_CHAT ";
-						stResult += strCharName;
-					}
-					else
-					{
-						stResult = "BLOCK_CHAT FAIL";
-					}
-				}
-				// END_OF_BLOCK_CHAT
-				else if (!stBuf.compare(0, 12, "PRIV_EMPIRE "))
-				{
-					int empire, type, value, duration;
-					std::istringstream is(stBuf);
-					std::string strPrivEmpire;
-					is >> strPrivEmpire >> empire >> type >> value >> duration;
-
-					// √÷¥Îƒ° 10πË
-					value = MINMAX(0, value, 1000);
-					stResult = "PRIV_EMPIRE FAIL";
-
-					if (!is.fail())
-					{
-						// check parameter
-						if (empire < 0 || 3 < empire);
-						else if (type < 1 || 4 < type);
-						else if (value < 0);
-						else if (duration < 0);
-						else
-						{
-							stResult = "PRIV_EMPIRE SUCCEED";
-
-							// Ω√∞£ ¥‹¿ß∑Œ ∫Ø∞Ê
-							duration = duration * (60 * 60);
-
-							sys_log(0, "_give_empire_privileage(empire=%d, type=%d, value=%d, duration=%d) by web",
-								empire, type, value, duration);
-							CPrivManager::instance().RequestGiveEmpirePriv(empire, type, value, duration);
-						}
-					}
-				}
-				else if (!stBuf.compare(0, 15, "BLOCK_EXCEPTION"))
-				{
-					// BLOCK_EXCEPTION cmd(add=1, del=2) login
-					std::istringstream is(stBuf);
-					std::string dummy_string;
-					std::string login_string;
-					int cmd;
-
-					is >> dummy_string >> cmd >> login_string;
-
-					sys_log(0, "block_exception %s:%d", login_string.c_str(), cmd);
-					DBManager::instance().RequestBlockException(login_string.c_str(), cmd);
-					stResult = "BLOCK_EXCEPTION_YES";
-				}
-			}
-		}
-
-		sys_log(1, "TEXT %s RESULT %s", stBuf.c_str(), stResult.c_str());
-		stResult += "\n";
-		d->Packet(stResult.c_str(), stResult.length());
-		return (c_pSep - c_pData) + 1;
-	}
-	else if (bHeader == HEADER_CG_MARK_LOGIN)
-	{
-		if (!guild_mark_server)
-		{
-			// ≤˜æÓπˆ∑¡! - ∏∂≈© º≠πˆ∞° æ∆¥—µ• ∏∂≈©∏¶ ø‰√ª«œ∑¡∞Ì?
-			sys_err("Guild Mark login requested but i'm not a mark server!");
-			d->SetPhase(PHASE_CLOSE);
-			return 0;
-		}
-
-		// π´¡∂∞« ¿Œ¡ı --;
-		sys_log(0, "MARK_SERVER: Login");
-		d->SetPhase(PHASE_LOGIN);
-		return 0;
-	}
-	else if (bHeader == HEADER_CG_STATE_CHECKER)
-	{
-		if (d->isChannelStatusRequested())
-			return 0;
-
-		d->SetChannelStatusRequested(true);
-		db_clientdesc->DBPacket(HEADER_GD_REQUEST_CHANNELSTATUS, d->GetHandle(), NULL, 0);
-	}
-	else if (bHeader == HEADER_CG_PONG)
-		Pong(d);
-	else if (bHeader == HEADER_CG_HANDSHAKE)
-		Handshake(d, c_pData);
-#if defined(__IMPROVED_PACKET_ENCRYPTION__)
-	else if (bHeader == HEADER_CG_KEY_AGREEMENT)
-	{
-		// Send out the key agreement completion packet first
-		// to help client to enter encryption mode
-		d->SendKeyAgreementCompleted();
-		// Flush socket output before going encrypted
-		d->ProcessOutput();
-
-		TPacketKeyAgreement* p = (TPacketKeyAgreement*)c_pData;
-		if (!d->IsCipherPrepared())
-		{
-			sys_err("Cipher isn't prepared. %s maybe a Hacker.", inet_ntoa(d->GetAddr().sin_addr));
-			d->DelayedDisconnect(5);
-			return 0;
-		}
-
-		if (d->FinishHandshake(p->wAgreedLength, p->data, p->wDataLength))
-		{
-			// Handshaking succeeded
-			if (g_bAuthServer)
-			{
-				d->SetPhase(PHASE_AUTH);
-			}
-			else {
-				d->SetPhase(PHASE_LOGIN);
-			}
-		}
-		else
-		{
-			sys_log(0, "[CInputHandshake] Key agreement failed: al=%u dl=%u",
-				p->wAgreedLength, p->wDataLength);
-			d->SetPhase(PHASE_CLOSE);
-		}
-	}
-#endif
-	else
-		sys_err("Handshake phase does not handle packet %d (fd %d)", bHeader, d->GetSocket());
-
-	return 0;
-}
+#include "stdafx.h"
+#include <sstream>
+
+#include "desc.h"
+#include "desc_manager.h"
+#include "char.h"
+#include "buffer_manager.h"
+#include "config.h"
+#include "profiler.h"
+#include "p2p.h"
+#include "log.h"
+#include "db.h"
+#include "questmanager.h"
+#include "login_sim.h"
+#include "fishing.h"
+#include "TrafficProfiler.h"
+#include "priv_manager.h"
+#include "castle.h"
+#include "dev_log.h"
+
+#ifndef __WIN32__
+#include "limit_time.h"
+#endif
+
+extern time_t get_global_time();
+
+bool IsEmptyAdminPage()
+{
+	return g_stAdminPageIP.empty();
+}
+
+bool IsAdminPage(const char* ip)
+{
+	for (size_t n = 0; n < g_stAdminPageIP.size(); ++n)
+	{
+		if (g_stAdminPageIP[n] == ip)
+			return 1;
+	}
+	return 0;
+}
+
+void ClearAdminPages()
+{
+	for (size_t n = 0; n < g_stAdminPageIP.size(); ++n)
+		g_stAdminPageIP[n].clear();
+
+	g_stAdminPageIP.clear();
+}
+
+CInputProcessor::CInputProcessor() : m_pPacketInfo(NULL), m_iBufferLeft(0)
+{
+	if (!m_pPacketInfo)
+		BindPacketInfo(&m_packetInfoCG);
+}
+
+void CInputProcessor::BindPacketInfo(CPacketInfo* pPacketInfo)
+{
+	m_pPacketInfo = pPacketInfo;
+}
+
+bool CInputProcessor::Process(LPDESC lpDesc, const void* c_pvOrig, int iBytes, int& r_iBytesProceed)
+{
+	const char* c_pData = (const char*)c_pvOrig;
+
+	BYTE bLastHeader = 0;
+	int iLastPacketLen = 0;
+	int iPacketLen;
+
+	if (!m_pPacketInfo)
+	{
+		sys_err("No packet info has been binded to");
+		return true;
+	}
+
+	for (m_iBufferLeft = iBytes; m_iBufferLeft > 0;)
+	{
+		BYTE bHeader = (BYTE) * (c_pData);
+		const char* c_pszName = "UNKNOWN";
+
+		if (bHeader == 0) // 0 header is skipped (reserved for encryption handler)
+			iPacketLen = 1;
+		else if (!m_pPacketInfo->Get(bHeader, &iPacketLen, &c_pszName))
+		{
+			c_pszName = "UNKNOWN";
+			r_iBytesProceed = m_iBufferLeft; // flush remaining bytes to avoid log-spam loops
+
+			sys_err("UNKNOWN HEADER: %d, LAST HEADER: %d(len:%d), %s, REMAIN BYTES: %d, fd: %d",
+				bHeader, bLastHeader, iLastPacketLen, c_pszName, m_iBufferLeft, lpDesc->GetSocket());
+
+			lpDesc->SetPhase(PHASE_CLOSE);
+			return true;
+		}
+
+		if (m_iBufferLeft < iPacketLen)
+			return true;
+
+		if (bHeader)
+		{
+			if ((test_server || packet_analyze) && bHeader != HEADER_CG_MOVE)
+				sys_log(0, "Packet Analyze [Header %d][bufferLeft %d] ", bHeader, m_iBufferLeft);
+
+			m_pPacketInfo->Start();
+
+			int iExtraPacketSize = Analyze(lpDesc, bHeader, c_pData);
+
+			if (iExtraPacketSize < 0)
+				return true;
+
+			iPacketLen += iExtraPacketSize;
+			lpDesc->Log("%s %d", c_pszName, iPacketLen);
+			m_pPacketInfo->End();
+		}
+
+		// TRAFFIC_PROFILER
+		if (g_bTrafficProfileOn)
+			TrafficProfiler::instance().Report(TrafficProfiler::IODIR_INPUT, bHeader, iPacketLen);
+		// END_OF_TRAFFIC_PROFILER
+
+#if defined(__SEND_SEQUENCE__)
+		if (bHeader == HEADER_CG_PONG)
+			sys_log(0, "PONG! %u %u", m_pPacketInfo->IsSequence(bHeader), *(BYTE*)(c_pData + iPacketLen - sizeof(BYTE)));
+
+		if (m_pPacketInfo->IsSequence(bHeader))
+		{
+			BYTE bSeq = lpDesc->GetSequence();
+			BYTE bSeqReceived = *(BYTE*)(c_pData + iPacketLen - sizeof(BYTE));
+
+			if (bSeq != bSeqReceived)
+			{
+				sys_err("SEQUENCE %x mismatch 0x%x != 0x%x header %u", get_pointer(lpDesc), bSeq, bSeqReceived, bHeader);
+
+				LPCHARACTER ch = lpDesc->GetCharacter();
+
+				char buf[1024];
+				int offset, len;
+
+				offset = snprintf(buf, sizeof(buf), "SEQUENCE_LOG [%s]-------------\n", ch ? ch->GetName() : "UNKNOWN");
+
+				if (offset < 0 || offset >= (int)sizeof(buf))
+					offset = sizeof(buf) - 1;
+
+				for (size_t i = 0; i < lpDesc->m_seq_vector.size(); ++i)
+				{
+					len = snprintf(buf + offset, sizeof(buf) - offset, "\t[%03d : 0x%x]\n",
+						lpDesc->m_seq_vector[i].hdr,
+						lpDesc->m_seq_vector[i].seq);
+
+					if (len < 0 || len >= (int)sizeof(buf) - offset)
+						offset += (sizeof(buf) - offset) - 1;
+					else
+						offset += len;
+				}
+
+				snprintf(buf + offset, sizeof(buf) - offset, "\t[%03d : 0x%x]\n", bHeader, bSeq);
+				sys_err("%s", buf);
+
+				lpDesc->SetPhase(PHASE_CLOSE);
+				return true;
+			}
+			else
+			{
+				lpDesc->push_seq(bHeader, bSeq);
+				lpDesc->SetNextSequence();
+				//sys_err("SEQUENCE %x match %u next %u header %u", lpDesc, bSeq, lpDesc->GetSequence(), bHeader);
+			}
+		}
+#endif
+
+		c_pData += iPacketLen;
+		m_iBufferLeft -= iPacketLen;
+		r_iBytesProceed += iPacketLen;
+
+		iLastPacketLen = iPacketLen;
+		bLastHeader = bHeader;
+
+		if (GetType() != lpDesc->GetInputProcessor()->GetType())
+			return false;
+	}
+
+	return true;
+}
+
+void CInputProcessor::Pong(LPDESC d)
+{
+	d->SetPong(true);
+}
+
+void CInputProcessor::Handshake(LPDESC d, const char* c_pData)
+{
+	TPacketCGHandshake* p = (TPacketCGHandshake*)c_pData;
+
+	if (d->GetHandshake() != p->dwHandshake)
+	{
+		sys_err("Invalid Handshake on %d", d->GetSocket());
+		d->SetPhase(PHASE_CLOSE);
+	}
+	else
+	{
+		if (d->IsPhase(PHASE_HANDSHAKE))
+		{
+			if (d->HandshakeProcess(p->dwTime, p->lDelta, false))
+			{
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+				d->SendKeyAgreement();
+#else
+				if (g_bAuthServer)
+					d->SetPhase(PHASE_AUTH);
+				else
+					d->SetPhase(PHASE_LOGIN);
+#endif
+			}
+		}
+		else
+			d->HandshakeProcess(p->dwTime, p->lDelta, true);
+	}
+}
+
+void CInputProcessor::Version(LPCHARACTER ch, const char* c_pData)
+{
+	if (!ch)
+		return;
+
+	TPacketCGClientVersion* p = (TPacketCGClientVersion*)c_pData;
+	sys_log(0, "VERSION: %s %s %s", ch->GetName(), p->timestamp, p->filename);
+	ch->GetDesc()->SetClientVersion(p->timestamp);
+}
+
+void LoginFailure(LPDESC d, const char* c_pszStatus)
+{
+	if (!d)
+		return;
+
+	TPacketGCLoginFailure failurePacket;
+
+	failurePacket.header = HEADER_GC_LOGIN_FAILURE;
+	strlcpy(failurePacket.szStatus, c_pszStatus, sizeof(failurePacket.szStatus));
+
+	d->Packet(&failurePacket, sizeof(failurePacket));
+}
+
+CInputHandshake::CInputHandshake()
+{
+	CPacketInfoCG* pkPacketInfo = M2_NEW CPacketInfoCG;
+#if defined(__SEND_SEQUENCE__)
+	pkPacketInfo->SetSequence(HEADER_CG_PONG, false);
+#endif
+
+	m_pMainPacketInfo = m_pPacketInfo;
+	BindPacketInfo(pkPacketInfo);
+}
+
+CInputHandshake::~CInputHandshake()
+{
+	if (NULL != m_pPacketInfo)
+	{
+		M2_DELETE(m_pPacketInfo);
+		m_pPacketInfo = NULL;
+	}
+}
+
+std::map<DWORD, CLoginSim*> g_sim;
+std::map<DWORD, CLoginSim*> g_simByPID;
+std::vector<TPlayerTable> g_vec_save;
+
+// BLOCK_CHAT
+ACMD(do_block_chat);
+// END_OF_BLOCK_CHAT
+
+int CInputHandshake::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
+{
+	if (bHeader == 10) // Õ¥ 
+		return 0;
+
+	if (bHeader == HEADER_CG_TEXT)
+	{
+#if !defined(__ALLOW_EXTERNAL_PEER__)
+		if (IsEmptyAdminPage() || !IsAdminPage(inet_ntoa(d->GetAddr().sin_addr)))
+		{
+			sys_log(0, "SOCKET_CMD: BLOCK FROM(%s)", d->GetHostName());
+			d->SetPhase(PHASE_CLOSE);
+			return 0;
+		}
+#endif
+
+		++c_pData;
+		const char* c_pSep;
+
+		if (!(c_pSep = strchr(c_pData, '\n'))) // \n √£¬¥.
+			return 0;
+
+		if (*(c_pSep - 1) == '\r')
+			--c_pSep;
+
+		std::string stResult;
+		std::string stBuf;
+		stBuf.assign(c_pData, 0, c_pSep - c_pData);
+
+		sys_log(0, "SOCKET_CMD: FROM(%s) CMD(%s)", d->GetHostName(), stBuf.c_str());
+
+		if (!stBuf.compare("IS_SERVER_UP"))
+		{
+			if (g_bNoMoreClient)
+				stResult = "NO";
+			else
+				stResult = "YES";
+		}
+		//else if (!stBuf.compare("SHOWMETHEMONEY"))
+		else if (stBuf == g_stAdminPagePassword)
+		{
+			if (!IsEmptyAdminPage())
+			{
+				if (!IsAdminPage(inet_ntoa(d->GetAddr().sin_addr)))
+				{
+					char szTmp[64];
+					snprintf(szTmp, sizeof(szTmp), "WEBADMIN : Wrong Connector : %s", inet_ntoa(d->GetAddr().sin_addr));
+					stResult += szTmp;
+				}
+				else
+				{
+					d->SetAdminMode();
+					stResult = "UNKNOWN";
+				}
+			}
+			else
+			{
+				d->SetAdminMode();
+				stResult = "UNKNOWN";
+			}
+		}
+		else if (!stBuf.compare("USER_COUNT"))
+		{
+			char szTmp[64];
+
+			if (!IsEmptyAdminPage())
+			{
+				if (!IsAdminPage(inet_ntoa(d->GetAddr().sin_addr)))
+				{
+					snprintf(szTmp, sizeof(szTmp), "WEBADMIN : Wrong Connector : %s", inet_ntoa(d->GetAddr().sin_addr));
+				}
+				else
+				{
+					int iTotal;
+					int* paiEmpireUserCount;
+					int iLocal;
+					DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
+					snprintf(szTmp, sizeof(szTmp), "%d %d %d %d %d", iTotal, paiEmpireUserCount[1], paiEmpireUserCount[2], paiEmpireUserCount[3], iLocal);
+				}
+			}
+			else
+			{
+				int iTotal;
+				int* paiEmpireUserCount;
+				int iLocal;
+				DESC_MANAGER::instance().GetUserCount(iTotal, &paiEmpireUserCount, iLocal);
+				snprintf(szTmp, sizeof(szTmp), "%d %d %d %d %d", iTotal, paiEmpireUserCount[1], paiEmpireUserCount[2], paiEmpireUserCount[3], iLocal);
+			}
+			stResult += szTmp;
+		}
+		else if (!stBuf.compare("CHECK_P2P_CONNECTIONS"))
+		{
+			std::ostringstream oss(std::ostringstream::out);
+			oss << "P2P CONNECTION NUMBER : " << P2P_MANAGER::instance().GetDescCount() << "\n";
+
+			std::string hostNames;
+			P2P_MANAGER::Instance().GetP2PHostNames(hostNames);
+			oss << hostNames;
+
+			stResult = oss.str();
+
+			TPacketGGCheckAwakeness packet;
+			packet.bHeader = HEADER_GG_CHECK_AWAKENESS;
+			P2P_MANAGER::instance().Send(&packet, sizeof(packet));
+		}
+		else if (!stBuf.compare("PACKET_INFO"))
+		{
+			m_pMainPacketInfo->Log("packet_info.txt");
+			stResult = "OK";
+		}
+		else if (!stBuf.compare("PROFILE"))
+		{
+			CProfiler::instance().Log("profile.txt");
+			stResult = "OK";
+		}
+		// gift notify delete command
+		else if (!stBuf.compare(0, 15, "DELETE_AWARDID "))
+		{
+			char szTmp[64];
+			std::string msg = stBuf.substr(15, 26); // item_award  id?
+
+			TPacketDeleteAwardID p;
+			p.dwID = (DWORD)(atoi(msg.c_str()));
+			snprintf(szTmp, sizeof(szTmp), "Sent to DB cache to delete ItemAward, id: %d", p.dwID);
+			//sys_log(0,"%d",p.dwID);
+			// strlcpy(p.login, msg.c_str(), sizeof(p.login));
+			db_clientdesc->DBPacket(HEADER_GD_DELETE_AWARDID, 0, &p, sizeof(p));
+			stResult += szTmp;
+		}
+		else
+		{
+			stResult = "UNKNOWN";
+
+			if (d->IsAdminMode())
+			{
+				//  …µ
+				if (!stBuf.compare(0, 7, "NOTICE "))
+				{
+					std::string msg = stBuf.substr(7, 50);
+					LogManager::instance().CharLog(0, 0, 0, 1, "NOTICE", msg.c_str(), d->GetHostName());
+					BroadcastNotice(msg.c_str());
+				}
+				else if (!stBuf.compare("SHUTDOWN"))
+				{
+					LogManager::instance().CharLog(0, 0, 0, 2, "SHUTDOWN", "", d->GetHostName());
+					TPacketGGShutdown p;
+					p.bHeader = HEADER_GG_SHUTDOWN;
+					P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGShutdown));
+					sys_err("Accept shutdown command from %s.", d->GetHostName());
+					Shutdown(10);
+				}
+				else if (!stBuf.compare("SHUTDOWN_ONLY"))
+				{
+					LogManager::instance().CharLog(0, 0, 0, 2, "SHUTDOWN", "", d->GetHostName());
+					sys_err("Accept shutdown only command from %s.", d->GetHostName());
+					Shutdown(10);
+				}
+				else if (!stBuf.compare(0, 3, "DC "))
+				{
+					std::string msg = stBuf.substr(3, LOGIN_MAX_LEN);
+
+					dev_log(LOG_DEB0, "DC : '%s'", msg.c_str());
+
+					TPacketGGDisconnect pgg;
+
+					pgg.bHeader = HEADER_GG_DISCONNECT;
+					strlcpy(pgg.szLogin, msg.c_str(), sizeof(pgg.szLogin));
+
+					P2P_MANAGER::instance().Send(&pgg, sizeof(TPacketGGDisconnect));
+
+					// delete login key
+					{
+						TPacketDC p;
+						strlcpy(p.login, msg.c_str(), sizeof(p.login));
+						db_clientdesc->DBPacket(HEADER_GD_DC, 0, &p, sizeof(p));
+					}
+				}
+				else if (!stBuf.compare(0, 10, "RELOAD_CRC"))
+				{
+					LoadValidCRCList();
+
+					BYTE bHeader = HEADER_GG_RELOAD_CRC_LIST;
+					P2P_MANAGER::instance().Send(&bHeader, sizeof(BYTE));
+					stResult = "OK";
+				}
+				else if (!stBuf.compare(0, 20, "CHECK_CLIENT_VERSION"))
+				{
+					CheckClientVersion();
+
+					BYTE bHeader = HEADER_GG_CHECK_CLIENT_VERSION;
+					P2P_MANAGER::instance().Send(&bHeader, sizeof(BYTE));
+					stResult = "OK";
+				}
+				else if (!stBuf.compare(0, 6, "RELOAD"))
+				{
+					if (stBuf.size() == 6)
+					{
+						LoadStateUserCount();
+						db_clientdesc->DBPacket(HEADER_GD_RELOAD_PROTO, 0, NULL, 0);
+						DBManager::instance().LoadDBString();
+					}
+					else
+					{
+						char c = stBuf[7];
+
+						switch (LOWER(c))
+						{
+						case 'u':
+							LoadStateUserCount();
+							break;
+
+						case 'p':
+							db_clientdesc->DBPacket(HEADER_GD_RELOAD_PROTO, 0, NULL, 0);
+							break;
+
+						case 's':
+							DBManager::instance().LoadDBString();
+							break;
+
+						case 'q':
+							quest::CQuestManager::instance().Reload();
+							break;
+
+						case 'f':
+							fishing::Initialize();
+							break;
+
+						case 'a':
+							db_clientdesc->DBPacket(HEADER_GD_RELOAD_ADMIN, 0, NULL, 0);
+							sys_log(0, "Reloading admin infomation.");
+							break;
+						}
+					}
+				}
+				else if (!stBuf.compare(0, 6, "EVENT "))
+				{
+					std::istringstream is(stBuf);
+					std::string strEvent, strFlagName;
+					long lValue;
+					is >> strEvent >> strFlagName >> lValue;
+
+					if (!is.fail())
+					{
+						sys_log(0, "EXTERNAL EVENT FLAG name %s value %d", strFlagName.c_str(), lValue);
+						quest::CQuestManager::instance().RequestSetEventFlag(strFlagName, lValue);
+						stResult = "EVENT FLAG CHANGE ";
+						stResult += strFlagName;
+					}
+					else
+					{
+						stResult = "EVENT FLAG FAIL";
+					}
+				}
+				// BLOCK_CHAT
+				else if (!stBuf.compare(0, 11, "BLOCK_CHAT "))
+				{
+					std::istringstream is(stBuf);
+					std::string strBlockChat, strCharName;
+					long lDuration;
+					is >> strBlockChat >> strCharName >> lDuration;
+
+					if (!is.fail())
+					{
+						sys_log(0, "EXTERNAL BLOCK_CHAT name %s duration %d", strCharName.c_str(), lDuration);
+
+						do_block_chat(NULL, const_cast<char*>(stBuf.c_str() + 11), 0, 0);
+
+						stResult = "BLOCK_CHAT ";
+						stResult += strCharName;
+					}
+					else
+					{
+						stResult = "BLOCK_CHAT FAIL";
+					}
+				}
+				// END_OF_BLOCK_CHAT
+				else if (!stBuf.compare(0, 12, "PRIV_EMPIRE "))
+				{
+					int empire, type, value, duration;
+					std::istringstream is(stBuf);
+					std::string strPrivEmpire;
+					is >> strPrivEmpire >> empire >> type >> value >> duration;
+
+					// ÷¥ƒ° 10
+					value = MINMAX(0, value, 1000);
+					stResult = "PRIV_EMPIRE FAIL";
+
+					if (!is.fail())
+					{
+						// check parameter
+						if (empire < 0 || 3 < empire);
+						else if (type < 1 || 4 < type);
+						else if (value < 0);
+						else if (duration < 0);
+						else
+						{
+							stResult = "PRIV_EMPIRE SUCCEED";
+
+							// √∞  
+							duration = duration * (60 * 60);
+
+							sys_log(0, "_give_empire_privileage(empire=%d, type=%d, value=%d, duration=%d) by web",
+								empire, type, value, duration);
+							CPrivManager::instance().RequestGiveEmpirePriv(empire, type, value, duration);
+						}
+					}
+				}
+				else if (!stBuf.compare(0, 15, "BLOCK_EXCEPTION"))
+				{
+					// BLOCK_EXCEPTION cmd(add=1, del=2) login
+					std::istringstream is(stBuf);
+					std::string dummy_string;
+					std::string login_string;
+					int cmd;
+
+					is >> dummy_string >> cmd >> login_string;
+
+					sys_log(0, "block_exception %s:%d", login_string.c_str(), cmd);
+					DBManager::instance().RequestBlockException(login_string.c_str(), cmd);
+					stResult = "BLOCK_EXCEPTION_YES";
+				}
+			}
+		}
+
+		sys_log(1, "TEXT %s RESULT %s", stBuf.c_str(), stResult.c_str());
+		stResult += "\n";
+		d->Packet(stResult.c_str(), stResult.length());
+		return (c_pSep - c_pData) + 1;
+	}
+	else if (bHeader == HEADER_CG_MARK_LOGIN)
+	{
+		if (!guild_mark_server)
+		{
+			// ! - ≈©  ∆¥—µ ≈© √ªœ∑?
+			sys_err("Guild Mark login requested but i'm not a mark server!");
+			d->SetPhase(PHASE_CLOSE);
+			return 0;
+		}
+
+		//   --;
+		sys_log(0, "MARK_SERVER: Login");
+		d->SetPhase(PHASE_LOGIN);
+		return 0;
+	}
+	else if (bHeader == HEADER_CG_STATE_CHECKER)
+	{
+		if (d->isChannelStatusRequested())
+			return 0;
+
+		d->SetChannelStatusRequested(true);
+		db_clientdesc->DBPacket(HEADER_GD_REQUEST_CHANNELSTATUS, d->GetHandle(), NULL, 0);
+	}
+	else if (bHeader == HEADER_CG_PONG)
+		Pong(d);
+	else if (bHeader == HEADER_CG_HANDSHAKE)
+		Handshake(d, c_pData);
+#if defined(__IMPROVED_PACKET_ENCRYPTION__)
+	else if (bHeader == HEADER_CG_KEY_AGREEMENT)
+	{
+		// Send out the key agreement completion packet first
+		// to help client to enter encryption mode
+		d->SendKeyAgreementCompleted();
+		// Flush socket output before going encrypted
+		d->ProcessOutput();
+
+		TPacketKeyAgreement* p = (TPacketKeyAgreement*)c_pData;
+		if (!d->IsCipherPrepared())
+		{
+			sys_err("Cipher isn't prepared. %s maybe a Hacker.", inet_ntoa(d->GetAddr().sin_addr));
+			d->DelayedDisconnect(5);
+			return 0;
+		}
+
+		if (d->FinishHandshake(p->wAgreedLength, p->data, p->wDataLength))
+		{
+			// Handshaking succeeded
+			if (g_bAuthServer)
+			{
+				d->SetPhase(PHASE_AUTH);
+			}
+			else {
+				d->SetPhase(PHASE_LOGIN);
+			}
+		}
+		else
+		{
+			sys_log(0, "[CInputHandshake] Key agreement failed: al=%u dl=%u",
+				p->wAgreedLength, p->wDataLength);
+			d->SetPhase(PHASE_CLOSE);
+		}
+	}
+#endif
+	else
+		sys_err("Handshake phase does not handle packet %d (fd %d)", bHeader, d->GetSocket());
+
+	return 0;
+}
diff --git a/server/metin2/Source/Server/game/src/input_main.cpp b/server/metin2/Source/Server/game/src/input_main.cpp
index 5a44dae..0443fa6 100644
--- a/server/metin2/Source/Server/game/src/input_main.cpp
+++ b/server/metin2/Source/Server/game/src/input_main.cpp
@@ -1,5511 +1,6034 @@
-#include "stdafx.h"
-#include "constants.h"
-#include "config.h"
-#include "utils.h"
-#include "desc_client.h"
-#include "desc_manager.h"
-#include "buffer_manager.h"
-#include "packet.h"
-#include "protocol.h"
-#include "char.h"
-#include "char_manager.h"
-#include "item.h"
-#include "item_manager.h"
-#ifdef ENABLE_QUEEN_NETHIS
-#include "SnakeLair.h"
-#endif
-#include "cmd.h"
-#include "shop.h"
-#include "shop_manager.h"
-#include "safebox.h"
-#include "regen.h"
-#include "battle.h"
-#include "exchange.h"
-#include "questmanager.h"
-#include "profiler.h"
-#include "messenger_manager.h"
-#include "party.h"
-#include "p2p.h"
-#include "affect.h"
-#include "guild.h"
-#include "guild_manager.h"
-#include "log.h"
-#include "banword.h"
-#include "empire_text_convert.h"
-#include "unique_item.h"
-#include "building.h"
-#include "locale_service.h"
-#include "gm.h"
-#include "spam.h"
-#include "ani.h"
-#include "motion.h"
-#include "OXEvent.h"
-#include "locale_service.h"
-#include "DragonSoul.h"
-#include "belt_inventory_helper.h"
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-#	include "LootFilter.h"
-#endif
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-#	include "xmas_event.h"
-#endif
-
-#if defined(__DEFENSE_WAVE__)
-#	include "defense_wave.h"
-#endif
-
-#if defined(__OFFLINE_SHOP__)
-#include "OfflineShop.h"
-#endif
-
-#if defined(__SHOP_SEARCH__)
-	#include "ShopSearchManager.h"
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-#include "battlepass_manager.h"
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-#include "growth_pet.h"
-#endif
-
-extern void SendShout(const char* szText, BYTE bEmpire
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	, const char* c_szName
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	, const char* c_szCountry
-#endif
-);
-
-extern int g_nPortalLimitTime;
-
-static int __deposit_limit()
-{
-	return (1000 * 10000); // 1√µ∏∏
-}
-
-void SendBlockChatInfo(LPCHARACTER ch, int sec)
-{
-	if (sec <= 0)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√§∆√ ±›¡ˆ ªÛ≈¬¿‘¥œ¥Ÿ."));
-		return;
-	}
-
-	long hour = sec / 3600;
-	sec -= hour * 3600;
-
-	long min = (sec / 60);
-	sec -= min * 60;
-
-	if (hour > 0 && min > 0)
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d Ω√∞£ %d ∫– %d √  µøæ» √§∆√±›¡ˆ ªÛ≈¬¿‘¥œ¥Ÿ", hour, min, sec));
-	else if (hour > 0 && min == 0)
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d Ω√∞£ %d √  µøæ» √§∆√±›¡ˆ ªÛ≈¬¿‘¥œ¥Ÿ", hour, sec));
-	else if (hour == 0 && min > 0)
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d ∫– %d √  µøæ» √§∆√±›¡ˆ ªÛ≈¬¿‘¥œ¥Ÿ", min, sec));
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d √  µøæ» √§∆√±›¡ˆ ªÛ≈¬¿‘¥œ¥Ÿ", sec));
-}
-
-EVENTINFO(spam_event_info)
-{
-	char host[MAX_HOST_LENGTH + 1];
-
-	spam_event_info()
-	{
-		::memset(host, 0, MAX_HOST_LENGTH + 1);
-	}
-};
-
-typedef std::unordered_map<std::string, std::pair<unsigned int, LPEVENT>> spam_score_of_ip_t;
-spam_score_of_ip_t spam_score_of_ip;
-
-EVENTFUNC(block_chat_by_ip_event)
-{
-	spam_event_info* info = dynamic_cast<spam_event_info*>(event->info);
-
-	if (info == NULL)
-	{
-		sys_err("block_chat_by_ip_event> <Factor> Null pointer");
-		return 0;
-	}
-
-	const char* host = info->host;
-
-	spam_score_of_ip_t::iterator it = spam_score_of_ip.find(host);
-
-	if (it != spam_score_of_ip.end())
-	{
-		it->second.first = 0;
-		it->second.second = NULL;
-	}
-
-	return 0;
-}
-
-bool SpamBlockCheck(LPCHARACTER ch, const char* const buf, const size_t buflen)
-{
-	extern int g_iSpamBlockMaxLevel;
-
-	if (ch->GetLevel() < g_iSpamBlockMaxLevel)
-	{
-		spam_score_of_ip_t::iterator it = spam_score_of_ip.find(ch->GetDesc()->GetHostName());
-
-		if (it == spam_score_of_ip.end())
-		{
-			spam_score_of_ip.insert(std::make_pair(ch->GetDesc()->GetHostName(), std::make_pair(0, (LPEVENT)NULL)));
-			it = spam_score_of_ip.find(ch->GetDesc()->GetHostName());
-		}
-
-		if (it->second.second)
-		{
-			SendBlockChatInfo(ch, event_time(it->second.second) / passes_per_sec);
-			return true;
-		}
-
-		unsigned int score;
-		const char* word = SpamManager::instance().GetSpamScore(buf, buflen, score);
-
-		it->second.first += score;
-
-		if (word)
-			sys_log(0, "SPAM_SCORE: %s text: %s score: %u total: %u word: %s", ch->GetName(), buf, score, it->second.first, word);
-
-		extern unsigned int g_uiSpamBlockScore;
-		extern unsigned int g_uiSpamBlockDuration;
-
-		if (it->second.first >= g_uiSpamBlockScore)
-		{
-			spam_event_info* info = AllocEventInfo<spam_event_info>();
-			strlcpy(info->host, ch->GetDesc()->GetHostName(), sizeof(info->host));
-
-			it->second.second = event_create(block_chat_by_ip_event, info, PASSES_PER_SEC(g_uiSpamBlockDuration));
-			sys_log(0, "SPAM_IP: %s for %u seconds", info->host, g_uiSpamBlockDuration);
-
-			LogManager::instance().CharLog(ch, 0, "SPAM", word);
-
-			SendBlockChatInfo(ch, event_time(it->second.second) / passes_per_sec);
-
-			return true;
-		}
-	}
-
-	return false;
-}
-
-enum
-{
-	TEXT_TAG_PLAIN,
-	TEXT_TAG_TAG, // ||
-	TEXT_TAG_COLOR, // |cffffffff
-	TEXT_TAG_HYPERLINK_START, // |H
-	TEXT_TAG_HYPERLINK_END, // |h ex) |Hitem:1234:1:1:1|h
-	TEXT_TAG_RESTORE_COLOR,
-};
-
-int GetTextTag(const char* src, int maxLen, int& tagLen, std::string& extraInfo)
-{
-	tagLen = 1;
-
-	if (maxLen < 2 || *src != '|')
-		return TEXT_TAG_PLAIN;
-
-	const char* cur = ++src;
-
-	if (*cur == '|') // ||¥¬ |∑Œ «•Ω√«—¥Ÿ.
-	{
-		tagLen = 2;
-		return TEXT_TAG_TAG;
-	}
-	else if (*cur == 'c') // color |cffffffffblahblah|r
-	{
-		tagLen = 2;
-		return TEXT_TAG_COLOR;
-	}
-	else if (*cur == 'H') // hyperlink |Hitem:10000:0:0:0:0|h[¿Ã∏ß]|h
-	{
-		tagLen = 2;
-		return TEXT_TAG_HYPERLINK_START;
-	}
-	else if (*cur == 'h') // end of hyperlink
-	{
-		tagLen = 2;
-		return TEXT_TAG_HYPERLINK_END;
-	}
-
-	return TEXT_TAG_PLAIN;
-}
-
-void GetTextTagInfo(const char* src, int src_len, int& hyperlinks, bool& colored)
-{
-	colored = false;
-	hyperlinks = 0;
-
-	int len;
-	std::string extraInfo;
-
-	for (int i = 0; i < src_len;)
-	{
-		int tag = GetTextTag(&src[i], src_len - i, len, extraInfo);
-
-		if (tag == TEXT_TAG_HYPERLINK_START)
-			++hyperlinks;
-
-		if (tag == TEXT_TAG_COLOR)
-			colored = true;
-
-		i += len;
-	}
-}
-
-int ProcessTextTag(LPCHARACTER ch, const char* c_pszText, size_t len)
-{
-	// 20120517 ±ËøÎøÌ
-	// 0 : ¡§ªÛ¿˚¿∏∑Œ ªÁøÎ
-	// 1 : ±›∞≠∞Ê ∫Œ¡∑
-	// 2 : ±›∞≠∞Ê¿Ã ¿÷¿∏≥™, ∞≥¿ŒªÛ¡°ø°º≠ ªÁøÎ¡ﬂ
-	// 3 : ±≥»Ø¡ﬂ
-	// 4 : ø°∑Ø
-
-	int hyperlinks;
-	bool colored;
-
-	GetTextTagInfo(c_pszText, len, hyperlinks, colored);
-
-	if (colored == true && hyperlinks == 0)
-		return 4;
-
-	if (ch->GetExchange())
-	{
-		if (hyperlinks == 0)
-			return 0;
-		else
-			return 3;
-	}
-
-	int nPrismCount = ch->CountSpecifyItem(ITEM_PRISM);
-
-	if (nPrismCount < hyperlinks)
-		return 1;
-
-	if (!ch->GetMyShop())
-	{
-		ch->RemoveSpecifyItem(ITEM_PRISM, hyperlinks);
-		return 0;
-	}
-	else
-	{
-		int sellingNumber = ch->GetMyShop()->GetNumberByVnum(ITEM_PRISM);
-		if (nPrismCount - sellingNumber < hyperlinks)
-		{
-			return 2;
-		}
-		else
-		{
-			ch->RemoveSpecifyItem(ITEM_PRISM, hyperlinks);
-			return 0;
-		}
-	}
-
-	return 4;
-}
-
-int CInputMain::Whisper(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	const TPacketCGWhisper* pinfo = reinterpret_cast<const TPacketCGWhisper*>(data);
-
-	if (uiBytes < pinfo->wSize)
-		return -1;
-
-	int iExtraLen = pinfo->wSize - sizeof(TPacketCGWhisper);
-
-	if (iExtraLen < 0)
-	{
-		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->wSize, uiBytes);
-		ch->GetDesc()->SetPhase(PHASE_CLOSE);
-		return -1;
-	}
-
-	ch->IncreaseWhisperCounter();
-	if (ch->GetWhisperCounter() == 10 && !ch->IsGM())
-	{
-		sys_log(0, "WHISPER_HACK: %s", ch->GetName());
-		//ch->GetDesc()->DelayedDisconnect(5);
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Please do not spam the chat."));
-		ch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, 10, 0, true);
-
-		return iExtraLen;
-	}
-
-	if (ch->FindAffect(AFFECT_BLOCK_CHAT))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√§∆√ ±›¡ˆ ªÛ≈¬¿‘¥œ¥Ÿ."));
-		return (iExtraLen);
-	}
-
-	LPCHARACTER pkChr = CHARACTER_MANAGER::instance().FindPC(pinfo->szNameTo);
-
-	if (pkChr == ch && !test_server)
-		return iExtraLen;
-
-	LPDESC pkDesc = NULL;
-	BYTE bOpponentEmpire = 0;
-	DWORD dwOpponentPID = 0;
-
-	if (test_server)
-	{
-		if (!pkChr)
-			sys_log(0, "Whisper to %s(%s) from %s", "Null", pinfo->szNameTo, ch->GetName());
-		else
-			sys_log(0, "Whisper to %s(%s) from %s", pkChr->GetName(), pinfo->szNameTo, ch->GetName());
-	}
-
-	if (ch->IsBlockMode(BLOCK_WHISPER))
-	{
-		if (ch->GetDesc())
-		{
-			TPacketGCWhisper pack;
-			pack.bHeader = HEADER_GC_WHISPER;
-			pack.bType = WHISPER_TYPE_SENDER_BLOCKED;
-			pack.wSize = sizeof(TPacketGCWhisper);
-			strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-			ch->GetDesc()->Packet(&pack, sizeof(pack));
-		}
-		return iExtraLen;
-	}
-
-	if (!pkChr)
-	{
-		CCI* pkCCI = P2P_MANAGER::instance().Find(pinfo->szNameTo);
-
-		if (pkCCI)
-		{
-			pkDesc = pkCCI->pkDesc;
-			pkDesc->SetRelay(pinfo->szNameTo);
-			bOpponentEmpire = pkCCI->bEmpire;
-			dwOpponentPID = pkCCI->dwPID;
-
-			if (test_server)
-				sys_log(0, "Whisper to %s from %s (Channel %d Mapindex %d)", "Null", ch->GetName(), pkCCI->bChannel, pkCCI->lMapIndex);
-		}
-	}
-	else
-	{
-		pkDesc = pkChr->GetDesc();
-		bOpponentEmpire = pkChr->GetEmpire();
-		dwOpponentPID = pkChr->GetPlayerID();
-	}
-
-	if (!pkDesc)
-	{
-		if (ch->GetDesc())
-		{
-			TPacketGCWhisper pack;
-
-			pack.bHeader = HEADER_GC_WHISPER;
-			pack.bType = WHISPER_TYPE_NOT_EXIST;
-			pack.wSize = sizeof(TPacketGCWhisper);
-			strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-
-			ch->GetDesc()->Packet(&pack, sizeof(TPacketGCWhisper));
-			sys_log(0, "WHISPER: no player");
-		}
-	}
-	else
-	{
-		if (ch->IsBlockMode(BLOCK_WHISPER))
-		{
-			if (ch->GetDesc())
-			{
-				TPacketGCWhisper pack;
-				pack.bHeader = HEADER_GC_WHISPER;
-				pack.bType = WHISPER_TYPE_SENDER_BLOCKED;
-				pack.wSize = sizeof(TPacketGCWhisper);
-				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-				ch->GetDesc()->Packet(&pack, sizeof(pack));
-			}
-		}
-		else if (pkChr && pkChr->IsBlockMode(BLOCK_WHISPER))
-		{
-			if (ch->GetDesc())
-			{
-				TPacketGCWhisper pack;
-				pack.bHeader = HEADER_GC_WHISPER;
-				pack.bType = WHISPER_TYPE_TARGET_BLOCKED;
-				pack.wSize = sizeof(TPacketGCWhisper);
-				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-				ch->GetDesc()->Packet(&pack, sizeof(pack));
-			}
-		}
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		else if (pkDesc && CMessengerManager::instance().IsBlocked(ch->GetName(), pinfo->szNameTo))
-		{
-			if (ch->GetDesc())
-			{
-				TPacketGCWhisper pack;
-
-				char msg[CHAT_MAX_LEN + 1];
-				snprintf(msg, sizeof(msg), LC_STRING("Unblock %s to continue.", pinfo->szNameTo));
-				int len = MIN(CHAT_MAX_LEN, strlen(msg) + 1);
-
-				pack.bHeader = HEADER_GC_WHISPER;
-				pack.wSize = sizeof(TPacketGCWhisper) + len;
-				pack.bType = WHISPER_TYPE_SYSTEM;
-				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-
-				TEMP_BUFFER buf;
-
-				buf.write(&pack, sizeof(TPacketGCWhisper));
-				buf.write(msg, len);
-				ch->GetDesc()->Packet(buf.read_peek(), buf.size());
-
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", pinfo->szNameTo));
-			}
-		}
-		else if (pkDesc && CMessengerManager::instance().IsBlocked(pinfo->szNameTo, ch->GetName()))
-		{
-			if (ch->GetDesc())
-			{
-				TPacketGCWhisper pack;
-
-				char msg[CHAT_MAX_LEN + 1];
-				snprintf(msg, sizeof(msg), LC_STRING("%s has blocked you.", pinfo->szNameTo));
-				int len = MIN(CHAT_MAX_LEN, strlen(msg) + 1);
-
-				pack.bHeader = HEADER_GC_WHISPER;
-				pack.wSize = sizeof(TPacketGCWhisper) + len;
-				pack.bType = WHISPER_TYPE_SYSTEM;
-				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-
-				TEMP_BUFFER buf;
-
-				buf.write(&pack, sizeof(TPacketGCWhisper));
-				buf.write(msg, len);
-				ch->GetDesc()->Packet(buf.read_peek(), buf.size());
-
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", pinfo->szNameTo));
-			}
-		}
-#endif
-		else
-		{
-			BYTE bType = WHISPER_TYPE_NORMAL;
-
-			char buf[CHAT_MAX_LEN + 1];
-			strlcpy(buf, data + sizeof(TPacketCGWhisper), MIN(iExtraLen + 1, sizeof(buf)));
-			const size_t buflen = strlen(buf);
-
-			//if (true == SpamBlockCheck(ch, buf, buflen))
-			//{
-			//	if (!pkChr)
-			//	{
-			//		CCI* pkCCI = P2P_MANAGER::instance().Find(pinfo->szNameTo);
-			//
-			//		if (pkCCI)
-			//		{
-			//			pkDesc->SetRelay("");
-			//		}
-			//	}
-			//	return iExtraLen;
-			//}
-
-			//if (LC_IsCanada() == false)
-			//{
-			//	CBanwordManager::instance().ConvertString(buf, buflen);
-			//}
-
-			if (!g_bEmpireWhisper)
-			{
-				if (!ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
-				{
-					if (!(pkChr && pkChr->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)))
-					{
-						if (bOpponentEmpire != ch->GetEmpire() && ch->GetEmpire() && bOpponentEmpire // º≠∑Œ ¡¶±π¿Ã ¥Ÿ∏£∏Èº≠
-							&& ch->GetGMLevel() == GM_PLAYER && gm_get_level(pinfo->szNameTo) == GM_PLAYER) // µ—¥Ÿ ¿œπ› «√∑π¿ÃæÓ¿Ã∏È
-							// ¿Ã∏ß π€ø° ∏∏£¥œ gm_get_level «‘ºˆ∏¶ ªÁøÎ
-						{
-							if (!pkChr)
-							{
-								// ¥Ÿ∏• º≠πˆø° ¿÷¿∏¥œ ¡¶±π «•Ω√∏∏ «—¥Ÿ. bType¿« ªÛ¿ß 4∫Ò∆Æ∏¶ Empireπ¯»£∑Œ ªÁøÎ«—¥Ÿ.
-								bType = ch->GetEmpire() << 4;
-							}
-							else
-							{
-								ConvertEmpireText(ch->GetEmpire(), buf, buflen, 10 + 2 * pkChr->GetSkillPower(SKILL_LANGUAGE1 + ch->GetEmpire() - 1) /* ∫Ø»Ø»Æ∑¸ */);
-							}
-						}
-					}
-				}
-			}
-
-			if (!g_bDisableGlassInsight)
-			{
-				int processReturn = ProcessTextTag(ch, buf, buflen);
-				if (processReturn != 0)
-				{
-					if (ch->GetDesc())
-					{
-						TItemTable* pTable = ITEM_MANAGER::instance().GetTable(ITEM_PRISM);
-
-						if (pTable)
-						{
-							char buf[128];
-							int len;
-							if (processReturn == 3) // ±≥»Ø¡ﬂ
-								len = snprintf(buf, sizeof(buf), LC_STRING("¥Ÿ∏• ∞≈∑°¡ﬂ(√¢∞Ì,±≥»Ø,ªÛ¡°)ø°¥¬ ∞≥¿ŒªÛ¡°¿ª ªÁøÎ«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-							else
-							{
-								len = snprintf(buf, sizeof(buf), LC_STRING("%s æ∆¿Ã≈€¿Ã « ø‰«’¥œ¥Ÿ", LC_ITEM(pTable->dwVnum)));
-							}
-
-							if (len < 0 || len >= (int)sizeof(buf))
-								len = sizeof(buf) - 1;
-
-							++len; // \0 πÆ¿⁄ ∆˜«‘
-
-							TPacketGCWhisper pack;
-
-							pack.bHeader = HEADER_GC_WHISPER;
-							pack.bType = WHISPER_TYPE_ERROR;
-							pack.wSize = sizeof(TPacketGCWhisper) + len;
-							strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
-
-							ch->GetDesc()->BufferedPacket(&pack, sizeof(pack));
-							ch->GetDesc()->Packet(buf, len);
-
-							sys_log(0, "WHISPER: not enough %s: char: %s", pTable->szLocaleName, ch->GetName());
-						}
-					}
-
-					// ∏±∑°¿Ã ªÛ≈¬¿œ ºˆ ¿÷¿∏π«∑Œ ∏±∑°¿Ã∏¶ «ÆæÓ¡ÿ¥Ÿ.
-					pkDesc->SetRelay("");
-					return (iExtraLen);
-				}
-			}
-
-			if (ch->IsGM())
-				bType = (bType & 0xF0) | WHISPER_TYPE_GM;
-
-			if (buflen > 0)
-			{
-				TPacketGCWhisper pack;
-
-				pack.bHeader = HEADER_GC_WHISPER;
-				pack.wSize = sizeof(TPacketGCWhisper) + buflen;
-				pack.bType = bType;
-				strlcpy(pack.szNameFrom, ch->GetName(), sizeof(pack.szNameFrom));
-#if defined(__LOCALE_CLIENT__)
-				pack.bCanFormat = false;
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-				strlcpy(pack.szCountry, ch->GetCountry(), sizeof(pack.szCountry));
-#endif
-
-				// desc->BufferedPacket¿ª «œ¡ˆ æ ∞Ì πˆ∆€ø° Ω·æﬂ«œ¥¬ ¿Ã¿Ø¥¬ 
-				// P2P relayµ«æÓ ∆–≈∂¿Ã ƒ∏Ω∂»≠ µ… ºˆ ¿÷±‚ ∂ßπÆ¿Ã¥Ÿ.
-				TEMP_BUFFER tmpbuf;
-
-				tmpbuf.write(&pack, sizeof(pack));
-				tmpbuf.write(buf, buflen);
-
-				pkDesc->Packet(tmpbuf.read_peek(), tmpbuf.size());
-
-				if (test_server)
-					sys_log(0, "WHISPER: %s -> %s : %s", ch->GetName(), pinfo->szNameTo, buf);
-
-				if (g_bWhisperLog)
-					LogManager::instance().WhisperLog(ch->GetPlayerID(), dwOpponentPID, buf);
-			}
-		}
-	}
-	if (pkDesc)
-		pkDesc->SetRelay("");
-
-	return (iExtraLen);
-}
-
-struct RawPacketToCharacterFunc
-{
-	const void* m_buf;
-	int m_buf_len;
-
-	RawPacketToCharacterFunc(const void* buf, int buf_len) : m_buf(buf), m_buf_len(buf_len)
-	{
-	}
-
-	void operator () (LPCHARACTER c)
-	{
-		if (!c->GetDesc())
-			return;
-
-		c->GetDesc()->Packet(m_buf, m_buf_len);
-	}
-};
-
-struct FEmpireChatPacket
-{
-	packet_chat& p;
-	const char* orig_msg;
-	int orig_len;
-	char converted_msg[CHAT_MAX_LEN + 1];
-
-	BYTE bEmpire;
-	int iMapIndex;
-	int namelen;
-
-	FEmpireChatPacket(packet_chat& p, const char* chat_msg, int len, BYTE bEmpire, int iMapIndex, int iNameLen)
-		: p(p), orig_msg(chat_msg), orig_len(len), bEmpire(bEmpire), iMapIndex(iMapIndex), namelen(iNameLen)
-	{
-		memset(converted_msg, 0, sizeof(converted_msg));
-	}
-
-	void operator () (LPDESC d)
-	{
-		if (!d->GetCharacter())
-			return;
-
-		if (d->GetCharacter()->GetMapIndex() != iMapIndex)
-			return;
-
-		d->BufferedPacket(&p, sizeof(packet_chat));
-
-		if (d->GetEmpire() == bEmpire ||
-			bEmpire == 0 ||
-			d->GetCharacter()->GetGMLevel() > GM_PLAYER ||
-			d->GetCharacter()->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
-		{
-			d->Packet(orig_msg, orig_len);
-		}
-		else
-		{
-			// ªÁ∂˜∏∂¥Ÿ Ω∫≈≥∑π∫ß¿Ã ¥Ÿ∏£¥œ ∏≈π¯ «ÿæﬂ«’¥œ¥Ÿ
-			size_t len = strlcpy(converted_msg, orig_msg, sizeof(converted_msg));
-
-			if (len >= sizeof(converted_msg))
-				len = sizeof(converted_msg) - 1;
-
-			ConvertEmpireText(bEmpire, converted_msg + namelen, len - namelen, 10 + 2 * d->GetCharacter()->GetSkillPower(SKILL_LANGUAGE1 + bEmpire - 1));
-			d->Packet(converted_msg, orig_len);
-		}
-	}
-};
-
-struct FYmirChatPacket
-{
-	packet_chat& packet;
-	const char* m_szChat;
-	size_t m_lenChat;
-	const char* m_szName;
-
-	int m_iMapIndex;
-	BYTE m_bEmpire;
-	bool m_ring;
-
-	char m_orig_msg[CHAT_MAX_LEN + 1];
-	int m_len_orig_msg;
-	char m_conv_msg[CHAT_MAX_LEN + 1];
-	int m_len_conv_msg;
-
-	FYmirChatPacket(packet_chat& p, const char* chat, size_t len_chat, const char* name, size_t len_name, int iMapIndex, BYTE empire, bool ring)
-		: packet(p),
-		m_szChat(chat), m_lenChat(len_chat),
-		m_szName(name),
-		m_iMapIndex(iMapIndex), m_bEmpire(empire),
-		m_ring(ring)
-	{
-		m_len_orig_msg = snprintf(m_orig_msg, sizeof(m_orig_msg), "%s : %s", m_szName, m_szChat) + 1; // ≥Œ πÆ¿⁄ ∆˜«‘
-
-		if (m_len_orig_msg < 0 || m_len_orig_msg >= (int)sizeof(m_orig_msg))
-			m_len_orig_msg = sizeof(m_orig_msg) - 1;
-
-		m_len_conv_msg = snprintf(m_conv_msg, sizeof(m_conv_msg), "??? : %s", m_szChat) + 1; // ≥Œ πÆ¿⁄ πÃ∆˜«‘
-
-		if (m_len_conv_msg < 0 || m_len_conv_msg >= (int)sizeof(m_conv_msg))
-			m_len_conv_msg = sizeof(m_conv_msg) - 1;
-
-		ConvertEmpireText(m_bEmpire, m_conv_msg + 6, m_len_conv_msg - 6, 10); // 6¿∫ "??? : "¿« ±Ê¿Ã
-	}
-
-	void operator() (LPDESC d)
-	{
-		if (!d->GetCharacter())
-			return;
-
-		if (d->GetCharacter()->GetMapIndex() != m_iMapIndex)
-			return;
-
-		if (m_ring ||
-			d->GetEmpire() == m_bEmpire ||
-			d->GetCharacter()->GetGMLevel() > GM_PLAYER ||
-			d->GetCharacter()->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
-		{
-			packet.size = m_len_orig_msg + sizeof(TPacketGCChat);
-
-			d->BufferedPacket(&packet, sizeof(packet_chat));
-			d->Packet(m_orig_msg, m_len_orig_msg);
-		}
-		else
-		{
-			packet.size = m_len_conv_msg + sizeof(TPacketGCChat);
-
-			d->BufferedPacket(&packet, sizeof(packet_chat));
-			d->Packet(m_conv_msg, m_len_conv_msg);
-		}
-	}
-};
-
-int CInputMain::Chat(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	const TPacketCGChat* pinfo = reinterpret_cast<const TPacketCGChat*>(data);
-
-	if (uiBytes < pinfo->size)
-		return -1;
-
-	const int iExtraLen = pinfo->size - sizeof(TPacketCGChat);
-
-	if (iExtraLen < 0)
-	{
-		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->size, uiBytes);
-		ch->GetDesc()->SetPhase(PHASE_CLOSE);
-		return -1;
-	}
-
-	char buf[CHAT_MAX_LEN - (CHARACTER_NAME_MAX_LEN + 3) + 1];
-	strlcpy(buf, data + sizeof(TPacketCGChat), MIN(iExtraLen + 1, sizeof(buf)));
-	const size_t buflen = strlen(buf);
-
-	if (buflen > 1 && *buf == '/')
-	{
-		// NOTE : Block players from accessing the command interpreter
-		// through normal chat. (CHAT_TYPE_TALKING) 20230607.Owsap
-		if (!ch->IsGM() && pinfo->type == CHAT_TYPE_TALKING)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("±◊∑± ∏Ì∑…æÓ¥¬ æ¯Ω¿¥œ¥Ÿ"));
-			return iExtraLen;
-		}
-
-		interpret_command(ch, buf + 1, buflen - 1);
-		return iExtraLen;
-	}
-
-	ch->IncreaseChatCounter();
-	if (ch->GetChatCounter() == 10 && !ch->IsGM())
-	{
-		sys_log(0, "CHAT_HACK: %s", ch->GetName());
-		//ch->GetDesc()->DelayedDisconnect(5);
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Please do not spam the chat."));
-		ch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, 10, 0, true);
-
-		return iExtraLen;
-	}
-
-	// √§∆√ ±›¡ˆ Affect √≥∏Æ
-	const CAffect* pAffect = ch->FindAffect(AFFECT_BLOCK_CHAT);
-
-	if (pAffect != NULL)
-	{
-		SendBlockChatInfo(ch, pAffect->lDuration);
-		return iExtraLen;
-	}
-
-	if (SpamBlockCheck(ch, buf, buflen))
-		return iExtraLen;
-
-	if (CHAT_TYPE_SHOUT == pinfo->type && g_bDisableShout && !ch->IsGM())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The shout is disabled."));
-		return iExtraLen;
-	}
-
-	char chatbuf[CHAT_MAX_LEN + 1];
-	int len = snprintf(chatbuf, sizeof(chatbuf), "%s : %s", ch->GetName(), buf);
-
-	if (CHAT_TYPE_SHOUT == pinfo->type)
-	{
-		LogManager::instance().ShoutLog(g_bChannel, ch->GetEmpire(), chatbuf);
-	}
-
-	CBanwordManager::instance().ConvertString(buf, buflen);
-
-	if (len < 0 || len >= (int)sizeof(chatbuf))
-		len = sizeof(chatbuf) - 1;
-
-	if (!g_bDisableGlassInsight)
-	{
-		int processReturn = ProcessTextTag(ch, chatbuf, len);
-		if (processReturn != 0)
-		{
-			const TItemTable* pTable = ITEM_MANAGER::instance().GetTable(ITEM_PRISM);
-
-			if (NULL != pTable)
-			{
-				if (3 == processReturn) //±≥»Ø¡ﬂ
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¥Ÿ∏• ∞≈∑°¡ﬂ(√¢∞Ì,±≥»Ø,ªÛ¡°)ø°¥¬ ∞≥¿ŒªÛ¡°¿ª ªÁøÎ«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-				else
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s æ∆¿Ã≈€¿Ã « ø‰«’¥œ¥Ÿ", LC_ITEM(pTable->dwVnum)));
-				}
-			}
-
-			return iExtraLen;
-		}
-	}
-
-	if (pinfo->type == CHAT_TYPE_SHOUT)
-	{
-		const int SHOUT_LIMIT_LEVEL = g_iUseLocale ? 15 : 3;
-
-		if (ch->GetLevel() < SHOUT_LIMIT_LEVEL)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ø‹ƒ°±‚¥¬ ∑π∫ß %d ¿ÃªÛ∏∏ ªÁøÎ ∞°¥… «’¥œ¥Ÿ.", SHOUT_LIMIT_LEVEL));
-			return (iExtraLen);
-		}
-
-		if (thecore_heart->pulse - (int)ch->GetLastShoutPulse() < passes_per_sec * 15 && !ch->IsGM())
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can only call every 15 seconds."));
-			return (iExtraLen);
-		}
-
-		ch->SetLastShoutPulse(thecore_heart->pulse);
-
-		TPacketGGShout p;
-		p.bHeader = HEADER_GG_SHOUT;
-		p.bEmpire = ch->GetEmpire();
-		strlcpy(p.szText, chatbuf, sizeof(p.szText));
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		strlcpy(p.szName, ch->GetName(), sizeof(p.szName));
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-		strlcpy(p.szCountry, ch->GetCountry(), sizeof(p.szCountry));
-#endif
-
-		P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGShout));
-
-		SendShout(chatbuf, ch->GetEmpire()
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-			, ch->GetName()
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-			, ch->GetCountry()
-#endif
-		);
-
-		return (iExtraLen);
-	}
-
-	TPacketGCChat pack_chat;
-	pack_chat.header = HEADER_GC_CHAT;
-	pack_chat.size = sizeof(TPacketGCChat) + len;
-	pack_chat.type = pinfo->type;
-	pack_chat.id = ch->GetVID();
-#if defined(__LOCALE_CLIENT__)
-	pack_chat.bCanFormat = false;
-#endif
-#if defined(__MULTI_LANGUAGE_SYSTEM__)
-	strlcpy(pack_chat.szCountry, ch->GetCountry(), sizeof(pack_chat.szCountry));
-#endif
-
-	switch (pinfo->type)
-	{
-		case CHAT_TYPE_TALKING:
-		{
-			const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
-
-			if (false)
-			{
-				std::for_each(c_ref_set.begin(), c_ref_set.end(),
-					FYmirChatPacket(pack_chat,
-						buf,
-						strlen(buf),
-						ch->GetName(),
-						strlen(ch->GetName()),
-						ch->GetMapIndex(),
-						ch->GetEmpire(),
-						ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)));
-			}
-			else
-			{
-				std::for_each(c_ref_set.begin(), c_ref_set.end(),
-					FEmpireChatPacket(pack_chat,
-						chatbuf,
-						len,
-						(ch->GetGMLevel() > GM_PLAYER ||
-							ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)) ? 0 : ch->GetEmpire(),
-						ch->GetMapIndex(), strlen(ch->GetName())));
-			}
-		}
-		break;
-
-		case CHAT_TYPE_PARTY:
-		{
-			if (!ch->GetParty())
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("∆ƒ∆º ¡ﬂ¿Ã æ∆¥’¥œ¥Ÿ."));
-			else
-			{
-				TEMP_BUFFER tbuf;
-
-				tbuf.write(&pack_chat, sizeof(pack_chat));
-				tbuf.write(chatbuf, len);
-
-				RawPacketToCharacterFunc f(tbuf.read_peek(), tbuf.size());
-				ch->GetParty()->ForEachOnlineMember(f);
-			}
-		}
-		break;
-
-		case CHAT_TYPE_GUILD:
-		{
-			if (!ch->GetGuild())
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("±ÊµÂø° ∞°¿‘«œ¡ˆ æ æ“Ω¿¥œ¥Ÿ."));
-			else
-				ch->GetGuild()->Chat(chatbuf);
-		}
-		break;
-
-		default:
-			sys_err("Unknown chat type %d", pinfo->type);
-			break;
-	}
-
-	return (iExtraLen);
-}
-
-void CInputMain::ItemUse(LPCHARACTER ch, const char* data)
-{
-	ch->UseItem(((struct command_item_use*)data)->Cell);
-}
-
-void CInputMain::ItemToItem(LPCHARACTER ch, const char* pcData)
-{
-	TPacketCGItemUseToItem* p = (TPacketCGItemUseToItem*)pcData;
-	if (ch)
-		ch->UseItem(p->Cell, p->TargetCell);
-}
-
-void CInputMain::ItemDrop(LPCHARACTER ch, const char* data)
-{
-	struct command_item_drop* pinfo = (struct command_item_drop*)data;
-
-	// MONARCH_LIMIT
-	//if (ch->IsMonarch())
-	//	return;
-	// END_MONARCH_LIMIT
-	if (!ch)
-		return;
-
-	// ø§≈©∞° 0∫∏¥Ÿ ≈©∏È ø§≈©∏¶ πˆ∏Æ¥¬ ∞Õ ¿Ã¥Ÿ.
-	if (pinfo->gold > 0)
-		ch->DropGold(pinfo->gold);
-#if defined(__CHEQUE_SYSTEM__)
-	else if (pinfo->cheque > 0)
-		ch->DropCheque(pinfo->cheque);
-#endif
-	else
-		ch->DropItem(pinfo->Cell);
-}
-
-void CInputMain::ItemDrop2(LPCHARACTER ch, const char* data)
-{
-	// MONARCH_LIMIT
-	//if (ch->IsMonarch())
-	//	return;
-	// END_MONARCH_LIMIT
-
-	TPacketCGItemDrop2* pinfo = (TPacketCGItemDrop2*)data;
-
-	// ø§≈©∞° 0∫∏¥Ÿ ≈©∏È ø§≈©∏¶ πˆ∏Æ¥¬ ∞Õ ¿Ã¥Ÿ.
-
-	if (!ch)
-		return;
-	if (pinfo->gold > 0)
-		ch->DropGold(pinfo->gold);
-#if defined(__CHEQUE_SYSTEM__)
-	else if (pinfo->cheque > 0)
-		ch->DropCheque(pinfo->cheque);
-#endif
-	else
-		ch->DropItem(pinfo->Cell, pinfo->count);
-}
-
-#if defined(__NEW_DROP_DIALOG__)
-void CInputMain::ItemDestroy(LPCHARACTER ch, const char* data)
-{
-	struct command_item_destroy* pinfo = (struct command_item_destroy*)data;
-	if (ch)
-		ch->DestroyItem(pinfo->Cell);
-}
-#endif
-
-void CInputMain::ItemMove(LPCHARACTER ch, const char* data)
-{
-	struct command_item_move* pinfo = (struct command_item_move*)data;
-
-	if (ch)
-		ch->MoveItem(pinfo->Cell, pinfo->CellTo, pinfo->count);
-}
-
-void CInputMain::ItemPickup(LPCHARACTER ch, const char* data)
-{
-	struct command_item_pickup* pinfo = (struct command_item_pickup*)data;
-	if (ch)
-		ch->PickupItem(pinfo->vid);
-}
-
-void CInputMain::QuickslotAdd(LPCHARACTER ch, const char* data)
-{
-	struct command_quickslot_add* pinfo = (struct command_quickslot_add*)data;
-	ch->SetQuickslot(pinfo->pos, pinfo->slot);
-}
-
-void CInputMain::QuickslotDelete(LPCHARACTER ch, const char* data)
-{
-	struct command_quickslot_del* pinfo = (struct command_quickslot_del*)data;
-	ch->DelQuickslot(pinfo->pos);
-}
-
-void CInputMain::QuickslotSwap(LPCHARACTER ch, const char* data)
-{
-	struct command_quickslot_swap* pinfo = (struct command_quickslot_swap*)data;
-	ch->SwapQuickslot(pinfo->pos, pinfo->change_pos);
-}
-
-int CInputMain::Messenger(const LPCHARACTER c_lpChar, const char* c_pData, std::size_t uiBytes)
-{
-	const TPacketCGMessenger* c_pPacket = reinterpret_cast<const TPacketCGMessenger*>(c_pData);
-	if (uiBytes < sizeof(TPacketCGMessenger))
-		return -1;
-
-	c_pData += sizeof(TPacketCGMessenger);
-	uiBytes -= sizeof(TPacketCGMessenger);
-
-	switch (c_pPacket->bSubHeader)
-	{
-		case MESSENGER_SUBHEADER_CG_ADD_BY_VID:
-		{
-			if (uiBytes < sizeof(TPacketCGMessengerAddByVID))
-				return -1;
-
-			const TPacketCGMessengerAddByVID* c_pAddByVIDPacket = reinterpret_cast<const TPacketCGMessengerAddByVID*>(c_pData);
-			const LPCHARACTER c_lpCharCompanion = CHARACTER_MANAGER::instance().Find(c_pAddByVIDPacket->dwVID);
-
-			if (c_lpCharCompanion == nullptr)
-				return sizeof(TPacketCGMessengerAddByVID);
-
-			if (c_lpCharCompanion->IsObserverMode())
-				return sizeof(TPacketCGMessengerAddByVID);
-
-			if (c_lpCharCompanion->IsBlockMode(BLOCK_MESSENGER_INVITE))
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ªÛ¥ÎπÊ¿Ã ∏ﬁΩ≈¡Æ √ﬂ∞° ∞≈∫Œ ªÛ≈¬¿‘¥œ¥Ÿ."));
-				return sizeof(TPacketCGMessengerAddByVID);
-			}
-
-			const LPDESC c_lpCompanionDesc = c_lpCharCompanion->GetDesc();
-			if (c_lpCompanionDesc == nullptr)
-				return sizeof(TPacketCGMessengerAddByVID);
-
-			if (c_lpChar->GetGMLevel() == GM_PLAYER && c_lpCharCompanion->GetGMLevel() != GM_PLAYER)
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∏ﬁΩ≈¡Æ> øÓøµ¿⁄¥¬ ∏ﬁΩ≈¡Æø° √ﬂ∞°«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-				return sizeof(TPacketCGMessengerAddByVID);
-			}
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", c_lpCharCompanion->GetName()));
-				return sizeof(TPacketCGMessengerAddByVID);
-			}
-			else if (CMessengerManager::instance().IsBlocked(c_lpCharCompanion->GetName(), c_lpChar->GetName()))
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", c_lpCharCompanion->GetName()));
-				return sizeof(TPacketCGMessengerAddByVID);
-			}
-#endif
-
-			if (c_lpChar->GetDesc() == c_lpCompanionDesc) // ¿⁄Ω≈¿∫ √ﬂ∞°«“ ºˆ æ¯¥Ÿ.
-				return sizeof(TPacketCGMessengerAddByVID);
-
-			CMessengerManager::instance().RequestToAdd(c_lpChar, c_lpCharCompanion);
-			//CMessengerManager::instance().AddToList(c_lpChar->GetName(), c_lpCharCompanion->GetName());
-		}
-		return sizeof(TPacketCGMessengerAddByVID);
-
-		case MESSENGER_SUBHEADER_CG_ADD_BY_NAME:
-		{
-			if (uiBytes < CHARACTER_NAME_MAX_LEN)
-				return -1;
-
-			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
-			strlcpy(szName, c_pData, sizeof(szName));
-
-			if (c_lpChar->GetGMLevel() == GM_PLAYER && gm_get_level(szName) != GM_PLAYER)
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∏ﬁΩ≈¡Æ> øÓøµ¿⁄¥¬ ∏ﬁΩ≈¡Æø° √ﬂ∞°«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-				return CHARACTER_NAME_MAX_LEN;
-			}
-
-			const LPCHARACTER c_lpCharTarget = CHARACTER_MANAGER::instance().FindPC(szName);
-			if (c_lpCharTarget == nullptr)
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s ¥‘¿∫ ¡¢º”µ« ¿÷¡ˆ æ Ω¿¥œ¥Ÿ.", szName));
-			else
-			{
-				if (c_lpCharTarget == c_lpChar) // ¿⁄Ω≈¿∫ √ﬂ∞°«“ ºˆ æ¯¥Ÿ.
-					return CHARACTER_NAME_MAX_LEN;
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharTarget->GetName()))
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", c_lpCharTarget->GetName()));
-					return CHARACTER_NAME_MAX_LEN;
-				}
-				else if (CMessengerManager::instance().IsBlocked(c_lpCharTarget->GetName(), c_lpChar->GetName()))
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", c_lpCharTarget->GetName()));
-					return CHARACTER_NAME_MAX_LEN;
-				}
-#endif
-
-				if (c_lpCharTarget->IsBlockMode(BLOCK_MESSENGER_INVITE) == true)
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ªÛ¥ÎπÊ¿Ã ∏ﬁΩ≈¡Æ √ﬂ∞° ∞≈∫Œ ªÛ≈¬¿‘¥œ¥Ÿ."));
-				}
-				else
-				{
-					// ∏ﬁΩ≈¿˙∞° ƒ≥∏Ø≈Õ¥‹¿ß∞° µ«∏Èº≠ ∫Ø∞Ê
-					CMessengerManager::instance().RequestToAdd(c_lpChar, c_lpCharTarget);
-					//CMessengerManager::instance().AddToList(c_lpChar->GetName(), c_lpCharTarget->GetName());
-				}
-			}
-		}
-		return CHARACTER_NAME_MAX_LEN;
-
-		case MESSENGER_SUBHEADER_CG_REMOVE:
-		{
-			if (uiBytes < CHARACTER_NAME_MAX_LEN)
-				return -1;
-
-			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
-			strlcpy(szName, c_pData, sizeof(szName));
-			CMessengerManager::instance().RemoveFromList(c_lpChar->GetName(), szName);
-		}
-		return CHARACTER_NAME_MAX_LEN;
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-		case MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID:
-		{
-			if (uiBytes < sizeof(TPacketCGMessengerAddBlockByVID))
-				return -1;
-
-			const TPacketCGMessengerAddBlockByVID* c_pAddBlockByVIDPacket = reinterpret_cast<const TPacketCGMessengerAddBlockByVID*>(c_pData);
-			const LPCHARACTER c_lpCharCompanion = CHARACTER_MANAGER::instance().Find(c_pAddBlockByVIDPacket->dwVID);
-			if (c_lpCharCompanion == nullptr)
-				return sizeof(TPacketCGMessengerAddBlockByVID);
-
-			if (c_lpChar->IsObserverMode())
-				return sizeof(TPacketCGMessengerAddBlockByVID);
-
-			const LPDESC c_lpDescCompanion = c_lpCharCompanion->GetDesc();
-			if (c_lpDescCompanion == nullptr)
-				return sizeof(TPacketCGMessengerAddByVID);
-
-			const LPCHARACTER c_pPartner = c_lpChar->GetMarryPartner();
-			if (c_pPartner)
-			{
-				if (c_lpCharCompanion->GetName() == c_pPartner->GetName())
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block your spouse."));
-					return sizeof(TPacketCGMessengerAddBlockByVID);
-				}
-			}
-
-			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Remove %s from your friends list to continue.", c_lpCharCompanion->GetName()));
-				return sizeof(TPacketCGMessengerAddBlockByVID);
-			}
-
-			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is already being blocked.", c_lpCharCompanion->GetName()));
-				return sizeof(TPacketCGMessengerAddBlockByVID);
-			}
-
-			if (c_lpChar->GetGMLevel() == GM_PLAYER && c_lpCharCompanion->GetGMLevel() != GM_PLAYER && !test_server)
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block this player."));
-				return sizeof(TPacketCGMessengerAddByVID);
-			}
-
-			if (c_lpChar->GetDesc() == c_lpDescCompanion)
-				return sizeof(TPacketCGMessengerAddBlockByVID);
-
-			CMessengerManager::instance().AddToBlockList(c_lpChar->GetName(), c_lpCharCompanion->GetName());
-		}
-		return sizeof(TPacketCGMessengerAddBlockByVID);
-
-		case MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME:
-		{
-			if (uiBytes < CHARACTER_NAME_MAX_LEN)
-				return -1;
-
-			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
-			strlcpy(szName, c_pData, sizeof(szName));
-
-			if (gm_get_level(szName) != GM_PLAYER && !test_server)
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block this player."));
-				return CHARACTER_NAME_MAX_LEN;
-			}
-
-			const LPCHARACTER c_lpCharTarget = CHARACTER_MANAGER::instance().FindPC(szName);
-			if (c_lpCharTarget == c_lpChar)
-				return CHARACTER_NAME_MAX_LEN;
-
-			LPDESC pDescTarget = nullptr;
-			if (c_lpCharTarget == nullptr)
-			{
-				const CCI* c_pCCI = P2P_MANAGER::instance().Find(szName);
-				if (c_pCCI)
-					pDescTarget = c_pCCI->pkDesc;
-			}
-			else
-				pDescTarget = c_lpCharTarget->GetDesc();
-
-			if (pDescTarget == nullptr)
-			{
-				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is not online.", szName));
-				return CHARACTER_NAME_MAX_LEN;
-			}
-			else
-			{
-				const LPCHARACTER c_pPartner = c_lpChar->GetMarryPartner();
-				if (c_pPartner)
-				{
-					if (c_pPartner->GetName() == szName)
-					{
-						c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block your spouse."));
-						return CHARACTER_NAME_MAX_LEN;
-					}
-				}
-
-				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Remove %s from your friends list to continue.", szName));
-					return CHARACTER_NAME_MAX_LEN;
-				}
-
-				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
-				{
-					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is already being blocked.", szName));
-					return CHARACTER_NAME_MAX_LEN;
-				}
-
-				CMessengerManager::instance().AddToBlockList(c_lpChar->GetName(), szName);
-			}
-		}
-		return CHARACTER_NAME_MAX_LEN;
-
-		case MESSENGER_SUBHEADER_CG_BLOCK_REMOVE:
-		{
-			if (uiBytes < CHARACTER_NAME_MAX_LEN)
-				return -1;
-
-			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
-			strlcpy(szName, c_pData, sizeof(szName));
-
-			if (!CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
-				return CHARACTER_NAME_MAX_LEN;
-
-			CMessengerManager::instance().RemoveFromBlockList(c_lpChar->GetName(), szName);
-		}
-		return CHARACTER_NAME_MAX_LEN;
-#endif
-
-		default:
-			sys_err("CInputMain::Messenger : Unknown subheader %d : %s", c_pPacket->bSubHeader, c_lpChar->GetName());
-			break;
-	}
-
-	return 0;
-}
-
-int CInputMain::Shop(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	TPacketCGShop* p = (TPacketCGShop*)data;
-
-	if (uiBytes < sizeof(TPacketCGShop))
-		return -1;
-
-	if (test_server)
-		sys_log(0, "CInputMain::Shop() ==> SubHeader %d", p->subheader);
-
-	const char* c_pData = data + sizeof(TPacketCGShop);
-	uiBytes -= sizeof(TPacketCGShop);
-
-	switch (p->subheader)
-	{
-		case SHOP_SUBHEADER_CG_END:
-			sys_log(1, "INPUT: %s SHOP: END", ch->GetName());
-			CShopManager::instance().StopShopping(ch);
-			return 0;
-
-		case SHOP_SUBHEADER_CG_BUY:
-		{
-			if (uiBytes < sizeof(BYTE) + sizeof(BYTE))
-				return -1;
-
-			BYTE bPos = *(c_pData + 1);
-			sys_log(1, "INPUT: %s SHOP: BUY %d", ch->GetName(), bPos);
-			CShopManager::instance().Buy(ch, bPos);
-			return (sizeof(BYTE) + sizeof(BYTE));
-		}
-
-		case SHOP_SUBHEADER_CG_SELL:
-		{
-			if (uiBytes < sizeof(BYTE))
-				return -1;
-
-			BYTE pos = *c_pData;
-
-			sys_log(0, "INPUT: %s SHOP: SELL", ch->GetName());
-			CShopManager::instance().Sell(ch, pos);
-			return sizeof(BYTE);
-		}
-
-		case SHOP_SUBHEADER_CG_SELL2:
-		{
-			const TPacketCGShopSell* p = reinterpret_cast<const TPacketCGShopSell*>(c_pData);
-
-			sys_log(0, "INPUT: %s SHOP: SELL2", ch->GetName());
-
-			CShopManager::instance().Sell(ch, p->wPos, p->wCount, p->bType);
-			return sizeof(TPacketCGShopSell);
-		}
-
-		default:
-			sys_err("CInputMain::Shop : Unknown subheader %d : %s", p->subheader, ch->GetName());
-			break;
-	}
-
-	return 0;
-}
-
-void CInputMain::OnClick(LPCHARACTER ch, const char* data)
-{
-	struct command_on_click* pinfo = (struct command_on_click*)data;
-	LPCHARACTER victim;
-
-	if ((victim = CHARACTER_MANAGER::instance().Find(pinfo->vid)))
-		victim->OnClick(ch);
-	else if (test_server)
-	{
-		sys_err("CInputMain::OnClick %s.Click.NOT_EXIST_VID[%d]", ch->GetName(), pinfo->vid);
-	}
-}
-
-void CInputMain::Exchange(LPCHARACTER ch, const char* data)
-{
-	struct command_exchange* pinfo = (struct command_exchange*)data;
-	LPCHARACTER to_ch = NULL;
-
-	if (!ch->CanHandleItem())
-		return;
-
-	int iPulse = thecore_pulse();
-
-	if ((to_ch = CHARACTER_MANAGER::instance().Find(pinfo->arg1)))
-	{
-		if (iPulse - to_ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-		{
-			to_ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("∞≈∑° »ƒ %d√  ¿Ã≥ªø° √¢∞Ì∏¶ ø≠ºˆ æ¯Ω¿¥œ¥Ÿ.", g_nPortalLimitTime));
-			return;
-		}
-
-		if (true == to_ch->IsDead())
-		{
-			return;
-		}
-	}
-
-	sys_log(0, "CInputMain()::Exchange() SubHeader %d ", pinfo->sub_header);
-
-	if (iPulse - ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("∞≈∑° »ƒ %d√  ¿Ã≥ªø° √¢∞Ì∏¶ ø≠ºˆ æ¯Ω¿¥œ¥Ÿ.", g_nPortalLimitTime));
-		return;
-	}
-
-	switch (pinfo->sub_header)
-	{
-		case EXCHANGE_SUBHEADER_CG_START: // arg1 == vid of target character
-			if (!ch->GetExchange())
-			{
-				if ((to_ch = CHARACTER_MANAGER::instance().Find(pinfo->arg1)))
-				{
-					//MONARCH_LIMIT
-					/*
-					if (to_ch->IsMonarch() || ch->IsMonarch())
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("±∫¡÷øÕ¥¬ ∞≈∑°∏¶ «“ºˆ∞° æ¯Ω¿¥œ¥Ÿ", g_nPortalLimitTime));
-						return;
-					}
-					//END_MONARCH_LIMIT
-					*/
-					if (iPulse - ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√¢∞Ì∏¶ ø¨»ƒ %d√  ¿Ã≥ªø°¥¬ ∞≈∑°∏¶ «“ºˆ æ¯Ω¿¥œ¥Ÿ.", g_nPortalLimitTime));
-
-						if (test_server)
-							ch->ChatPacket(CHAT_TYPE_INFO, "[TestOnly][Safebox]Pulse %d LoadTime %d PASS %d", iPulse, ch->GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
-						return;
-					}
-
-					if (iPulse - to_ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
-					{
-						to_ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√¢∞Ì∏¶ ø¨»ƒ %d√  ¿Ã≥ªø°¥¬ ∞≈∑°∏¶ «“ºˆ æ¯Ω¿¥œ¥Ÿ.", g_nPortalLimitTime));
-
-						if (test_server)
-							to_ch->ChatPacket(CHAT_TYPE_INFO, "[TestOnly][Safebox]Pulse %d LoadTime %d PASS %d", iPulse, to_ch->GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
-						return;
-					}
-
-					if (ch->GetGold() >= GOLD_MAX)
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("æ◊ºˆ∞° 20æÔ ≥…¿ª √ ∞˙«œø© ∞≈∑°∏¶ «“ºˆ∞° æ¯Ω¿¥œ¥Ÿ.."));
-
-						sys_err("[OVERFLOG_GOLD] START (%d) id %u name %s ", ch->GetGold(), ch->GetPlayerID(), ch->GetName());
-						return;
-					}
-
-#if defined(__CHEQUE_SYSTEM__)
-					if (ch->GetCheque() > CHEQUE_MAX)
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("æ◊ºˆ∞° 20æÔ ≥…¿ª √ ∞˙«œø© ∞≈∑°∏¶ «“ºˆ∞° æ¯Ω¿¥œ¥Ÿ.."));
-
-						sys_err("[OVERFLOW_CHEQUE] START (%d) id %u name %s ", ch->GetCheque(), ch->GetPlayerID(), ch->GetName());
-						return;
-					}
-#endif
-
-					if (to_ch->IsPC())
-					{
-						if (quest::CQuestManager::instance().GiveItemToPC(ch->GetPlayerID(), to_ch))
-						{
-							sys_log(0, "Exchange canceled by quest %s %s", ch->GetName(), to_ch->GetName());
-							return;
-						}
-					}
-
-					if (ch->PreventTradeWindow(WND_EXCHANGE, true/*except*/))
-					{
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¥Ÿ∏• ∞≈∑°¡ﬂ¿œ∞ÊøÏ ∞≥¿ŒªÛ¡°¿ª ø≠ºˆ∞° æ¯Ω¿¥œ¥Ÿ."));
-						return;
-					}
-
-					ch->ExchangeStart(to_ch);
-				}
-			}
-			break;
-
-		case EXCHANGE_SUBHEADER_CG_ITEM_ADD: // arg1 == position of item, arg2 == position in exchange window
-			if (ch->GetExchange())
-			{
-				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
-					ch->GetExchange()->AddItem(pinfo->Pos, pinfo->arg2);
-			}
-			break;
-
-		case EXCHANGE_SUBHEADER_CG_ITEM_DEL: // arg1 == position of item
-			if (ch->GetExchange())
-			{
-				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
-					ch->GetExchange()->RemoveItem(pinfo->arg1);
-			}
-			break;
-
-		case EXCHANGE_SUBHEADER_CG_ELK_ADD: // arg1 == amount of gold
-			if (ch->GetExchange())
-			{
-				const int64_t nTotalGold = static_cast<int64_t>(ch->GetExchange()->GetCompany()->GetOwner()->GetGold()) + static_cast<int64_t>(pinfo->arg1);
-				if (GOLD_MAX <= nTotalGold)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Yang."));
-
-					sys_err("[OVERFLOW_GOLD] ELK_ADD (%d) id %u name %s ",
-						ch->GetExchange()->GetCompany()->GetOwner()->GetGold(),
-						ch->GetExchange()->GetCompany()->GetOwner()->GetPlayerID(),
-						ch->GetExchange()->GetCompany()->GetOwner()->GetName());
-
-					return;
-				}
-
-				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
-					ch->GetExchange()->AddGold(pinfo->arg1);
-			}
-			break;
-
-#if defined(__CHEQUE_SYSTEM__)
-		case EXCHANGE_SUBHEADER_CG_CHEQUE_ADD: // arg1 == amount of cheque
-			if (ch->GetExchange())
-			{
-				const int64_t nTotalCheque = static_cast<int64_t>(ch->GetExchange()->GetCompany()->GetOwner()->GetCheque()) + static_cast<int64_t>(pinfo->arg1);
-
-				if (nTotalCheque > CHEQUE_MAX)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Won."));
-
-					sys_err("[OVERFLOW_CHEQUE] CHEQUE_ADD (%u) id %u name %s ",
-						ch->GetExchange()->GetCompany()->GetOwner()->GetCheque(),
-						ch->GetExchange()->GetCompany()->GetOwner()->GetPlayerID(),
-						ch->GetExchange()->GetCompany()->GetOwner()->GetName());
-
-					return;
-				}
-
-				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
-					ch->GetExchange()->AddCheque(pinfo->arg1);
-			}
-			break;
-#endif
-
-		case EXCHANGE_SUBHEADER_CG_ACCEPT: // arg1 == not used
-			if (ch->GetExchange())
-			{
-				sys_log(0, "CInputMain()::Exchange() ==> ACCEPT ");
-				ch->GetExchange()->Accept(true);
-			}
-			break;
-
-		case EXCHANGE_SUBHEADER_CG_CANCEL: // arg1 == not used
-			if (ch->GetExchange())
-				ch->GetExchange()->Cancel();
-			break;
-	}
-}
-
-void CInputMain::Position(LPCHARACTER ch, const char* data)
-{
-	struct command_position* pinfo = (struct command_position*)data;
-
-	switch (pinfo->position)
-	{
-		case POSITION_GENERAL:
-			ch->Standup();
-			break;
-
-		case POSITION_SITTING_CHAIR:
-			ch->Sitdown(0);
-			break;
-
-		case POSITION_SITTING_GROUND:
-			ch->Sitdown(1);
-			break;
-	}
-}
-
-static const int ComboSequenceBySkillLevel[3][8] =
-{
-	//	0	1	2	3	4	5	6	7
-	{	14,	15,	16,	17,	0,	0,	0,	0	},
-	{	14,	15,	16,	18,	20,	0,	0,	0	},
-	{	14,	15,	16,	18,	19,	17,	0,	0	},
-};
-
-#define COMBO_HACK_ALLOWABLE_MS 100
-
-bool CheckComboHack(LPCHARACTER ch, BYTE bArg, DWORD dwTime, bool CheckSpeedHack)
-{
-	if (!gHackCheckEnable)
-		return false;
-
-	// ¡◊∞≈≥™ ±‚¿˝ ªÛ≈¬ø°º≠¥¬ ∞¯∞›«“ ºˆ æ¯¿∏π«∑Œ, skip«—¥Ÿ.
-	// ¿Ã∑∏∞‘ «œ¡ˆ ∏ª∞Ì, CHRACTER::CanMove()ø° 
-	// if (IsStun() || IsDead()) return false;
-	// ∏¶ √ﬂ∞°«œ¥¬∞‘ ∏¬¥Ÿ∞Ì ª˝∞¢«œ≥™,
-	// ¿ÃπÃ ¥Ÿ∏• ∫Œ∫–ø°º≠ CanMove()¥¬ IsStun(), IsDead()∞˙
-	// µ∂∏≥¿˚¿∏∑Œ √º≈©«œ∞Ì ¿÷±‚ ∂ßπÆø° ºˆ¡§ø° ¿««— øµ«‚¿ª
-	// √÷º“»≠«œ±‚ ¿ß«ÿ ¿Ã∑∏∞‘ ∂´ªß ƒ⁄µÂ∏¶ Ω·≥ı¥¬¥Ÿ.
-	if (ch->IsStun() || ch->IsDead())
-		return false;
-	int ComboInterval = dwTime - ch->GetLastComboTime();
-	int HackScalar = 0; // ±‚∫ª Ω∫ƒÆ∂Û ¥‹¿ß 1
-#if 0
-	sys_log(0, "COMBO: %s arg:%u seq:%u delta:%d checkspeedhack:%d",
-		ch->GetName(), bArg, ch->GetComboSequence(), ComboInterval - ch->GetValidComboInterval(), CheckSpeedHack);
-#endif
-	// bArg 14 ~ 21π¯ ±Ó¡ˆ √— 8ƒﬁ∫∏ ∞°¥…
-	// 1. √π ƒﬁ∫∏(14)¥¬ ¿œ¡§ Ω√∞£ ¿Ã»ƒø° π›∫π ∞°¥…
-	// 2. 15 ~ 21π¯¿∫ π›∫π ∫“∞°¥…
-	// 3. ¬˜∑ ¥Î∑Œ ¡ı∞°«—¥Ÿ.
-	if (bArg == 14)
-	{
-		if (CheckSpeedHack && ComboInterval > 0 && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
-		{
-			// FIXME √ππ¯¬∞ ƒﬁ∫∏¥¬ ¿ÃªÛ«œ∞‘ ª°∏Æ ø√ ºˆ∞° ¿÷æÓº≠ 300¿∏∑Œ ≥™¥Æ -_-;
-			// ¥Ÿºˆ¿« ∏ÛΩ∫≈Õø° ¿««ÿ ¥ŸøÓµ«¥¬ ªÛ»≤ø°º≠ ∞¯∞›¿ª «œ∏È
-			// √ππ¯¬∞ ƒﬁ∫∏∞° ∏≈øÏ ¿˚¿∫ ¿Œ≈Õπ˙∑Œ µÈæÓø¿¥¬ ªÛ»≤ πﬂª˝.
-			// ¿Ã∑Œ ¿Œ«ÿ ƒﬁ∫∏«Ÿ¿∏∑Œ ∆®±‚¥¬ ∞ÊøÏ∞° ¿÷æÓ ¥Ÿ¿Ω ƒ⁄µÂ ∫Ò »∞º∫»≠.
-			//HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 300;
-
-			//sys_log(0, "COMBO_HACK: 2 %s arg:%u interval:%d valid:%u atkspd:%u riding:%s",
-			//	ch->GetName(),
-			//	bArg,
-			//	ComboInterval,
-			//	ch->GetValidComboInterval(),
-			//	ch->GetPoint(POINT_ATT_SPEED),
-			//	ch->IsRiding() ? "yes" : "no"
-			//);
-		}
-
-		ch->SetComboSequence(1);
-		ch->SetValidComboInterval((int)(ani_combo_speed(ch, 1) / (ch->GetPoint(POINT_ATT_SPEED) / 100.f)));
-		ch->SetLastComboTime(dwTime);
-	}
-	else if (bArg > 14 && bArg < 22)
-	{
-		int idx = MIN(2, ch->GetComboIndex());
-
-		if (ch->GetComboSequence() > 5) // «ˆ¿Á 6ƒﬁ∫∏ ¿ÃªÛ¿∫ æ¯¥Ÿ.
-		{
-			HackScalar = 1;
-			ch->SetValidComboInterval(300);
-			sys_log(0, "COMBO_HACK: 5 %s combo_seq:%d", ch->GetName(), ch->GetComboSequence());
-		}
-		// ¿⁄∞¥ Ω÷ºˆ ƒﬁ∫∏ øπø‹√≥∏Æ
-		else if (bArg == 21 &&
-			idx == 2 &&
-			ch->GetComboSequence() == 5 &&
-			ch->GetJob() == JOB_ASSASSIN &&
-			ch->GetWear(WEAR_WEAPON) &&
-			ch->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_DAGGER
-			)
-			ch->SetValidComboInterval(300);
-		else if (bArg == 21 &&
-			idx == 2 &&
-			ch->GetComboSequence() == 5 &&
-			ch->GetJob() == JOB_WOLFMAN &&
-			ch->GetWear(WEAR_WEAPON) &&
-			ch->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_CLAW
-			)
-			ch->SetValidComboInterval(300);
-		else if (ComboSequenceBySkillLevel[idx][ch->GetComboSequence()] != bArg)
-		{
-			HackScalar = 1;
-			ch->SetValidComboInterval(300);
-
-			sys_log(0, "COMBO_HACK: 3 %s arg:%u valid:%u combo_idx:%d combo_seq:%d",
-				ch->GetName(),
-				bArg,
-				ComboSequenceBySkillLevel[idx][ch->GetComboSequence()],
-				idx,
-				ch->GetComboSequence());
-		}
-		else
-		{
-			if (CheckSpeedHack && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
-			{
-				HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 100;
-
-				sys_log(0, "COMBO_HACK: 2 %s arg:%u interval:%d valid:%u atkspd:%u riding:%s",
-					ch->GetName(),
-					bArg,
-					ComboInterval,
-					ch->GetValidComboInterval(),
-					ch->GetPoint(POINT_ATT_SPEED),
-					ch->IsRiding() ? "yes" : "no");
-			}
-
-			// ∏ª¿ª ≈¿¿ª ∂ß¥¬ 15π¯ ~ 16π¯¿ª π›∫π«—¥Ÿ
-			//if (ch->IsHorseRiding())
-			if (ch->IsRiding())
-				ch->SetComboSequence(ch->GetComboSequence() == 1 ? 2 : 1);
-			else
-				ch->SetComboSequence(ch->GetComboSequence() + 1);
-
-			ch->SetValidComboInterval((int)(ani_combo_speed(ch, bArg - 13) / (ch->GetPoint(POINT_ATT_SPEED) / 100.f)));
-			ch->SetLastComboTime(dwTime);
-		}
-	}
-	else if (bArg == 13) // ±‚∫ª ∞¯∞› (µ–∞©(Polymorph)«ﬂ¿ª ∂ß ø¬¥Ÿ)
-	{
-		if (CheckSpeedHack && ComboInterval > 0 && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
-		{
-			// ¥Ÿºˆ¿« ∏ÛΩ∫≈Õø° ¿««ÿ ¥ŸøÓµ«¥¬ ªÛ»≤ø°º≠ ∞¯∞›¿ª «œ∏È
-			// √ππ¯¬∞ ƒﬁ∫∏∞° ∏≈øÏ ¿˚¿∫ ¿Œ≈Õπ˙∑Œ µÈæÓø¿¥¬ ªÛ»≤ πﬂª˝.
-			// ¿Ã∑Œ ¿Œ«ÿ ƒﬁ∫∏«Ÿ¿∏∑Œ ∆®±‚¥¬ ∞ÊøÏ∞° ¿÷æÓ ¥Ÿ¿Ω ƒ⁄µÂ ∫Ò »∞º∫»≠.
-			//HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 100;
-
-			//sys_log(0, "COMBO_HACK: 6 %s arg:%u interval:%d valid:%u atkspd:%u",
-			//	ch->GetName(),
-			//	bArg,
-			//	ComboInterval,
-			//	ch->GetValidComboInterval(),
-			//	ch->GetPoint(POINT_ATT_SPEED)
-			//);
-		}
-
-		if (ch->GetRaceNum() >= MAIN_RACE_MAX_NUM)
-		{
-			// POLYMORPH_BUG_FIX
-
-			// DELETEME
-			/*
-			const CMotion * pkMotion = CMotionManager::instance().GetMotion(ch->GetRaceNum(), MAKE_MOTION_KEY(MOTION_MODE_GENERAL, MOTION_NORMAL_ATTACK));
-
-			if (!pkMotion)
-				sys_err("cannot find motion by race %u", ch->GetRaceNum());
-			else
-			{
-				// ¡§ªÛ¿˚ ∞ËªÍ¿Ã∂Û∏È 1000.f∏¶ ∞ˆ«ÿæﬂ «œ¡ˆ∏∏ ≈¨∂Û¿Ãæ∆Æ∞° æ÷¥œ∏ﬁ¿Ãº« º”µµ¿« 90%ø°º≠
-				// ¥Ÿ¿Ω æ÷¥œ∏ﬁ¿Ãº« ∫Ì∑ªµ˘¿ª «„øÎ«œπ«∑Œ 900.f∏¶ ∞ˆ«—¥Ÿ.
-				int k = (int) (pkMotion->GetDuration() / ((float) ch->GetPoint(POINT_ATT_SPEED) / 100.f) * 900.f);
-				ch->SetValidComboInterval(k);
-				ch->SetLastComboTime(dwTime);
-			}
-			*/
-			float normalAttackDuration = CMotionManager::instance().GetNormalAttackDuration(ch->GetRaceNum());
-			int k = (int)(normalAttackDuration / ((float)ch->GetPoint(POINT_ATT_SPEED) / 100.f) * 900.f);
-			ch->SetValidComboInterval(k);
-			ch->SetLastComboTime(dwTime);
-			// END_OF_POLYMORPH_BUG_FIX
-		}
-		else
-		{
-			// ∏ª¿Ã æ»µ«¥¬ ƒﬁ∫∏∞° ø‘¥Ÿ «ÿƒø¿œ ∞°¥…º∫?
-			//if (ch->GetDesc()->DelayedDisconnect(number(2, 9)))
-			//{
-			//	LogManager::instance().HackLog("Hacker", ch);
-			//	sys_log(0, "HACKER: %s arg %u", ch->GetName(), bArg);
-			//}
-
-			// ¿ß ƒ⁄µÂ∑Œ ¿Œ«ÿ, ∆˙∏Æ∏«¡∏¶ «™¥¬ ¡ﬂø° ∞¯∞› «œ∏È,
-			// ∞°≤˚ «Ÿ¿∏∑Œ ¿ŒΩƒ«œ¥¬ ∞ÊøÏ∞° ¿÷¥Ÿ.
-
-			// ¿⁄ºº»˜ ∏ª«Ù∏È,
-			// º≠πˆø°º≠ poly 0∏¶ √≥∏Æ«ﬂ¡ˆ∏∏,
-			// ≈¨∂Ûø°º≠ ±◊ ∆–≈∂¿ª πﬁ±‚ ¿¸ø°, ∏˜¿ª ∞¯∞›. <- ¡Ô, ∏˜¿Œ ªÛ≈¬ø°º≠ ∞¯∞›.
-			//
-			// ±◊∑Ø∏È ≈¨∂Ûø°º≠¥¬ º≠πˆø° ∏˜ ªÛ≈¬∑Œ ∞¯∞›«ﬂ¥Ÿ¥¬ ƒø∏«µÂ∏¶ ∫∏≥ª∞Ì (arg == 13)
-			//
-			// º≠πˆø°º≠¥¬ race¥¬ ¿Œ∞£¿Œµ• ∞¯∞›«¸≈¬¥¬ ∏˜¿Œ ≥¿Ã¥Ÿ! ∂Û∞Ì «œø© «Ÿ√º≈©∏¶ «ﬂ¥Ÿ.
-
-			// ªÁΩ« ∞¯∞› ∆–≈œø° ¥Î«— ∞Õ¿∫ ≈¨∂Û¿Ãæ∆Æø°º≠ ∆«¥‹«ÿº≠ ∫∏≥æ ∞Õ¿Ã æ∆¥œ∂Û,
-			// º≠πˆø°º≠ ∆«¥‹«ÿæﬂ «“ ∞Õ¿Œµ•... ø÷ ¿Ã∑∏∞‘ «ÿ≥˘¿ª±Ó...
-			// by rtsummit
-		}
-	}
-	else
-	{
-		// ∏ª¿Ã æ»µ«¥¬ ƒﬁ∫∏∞° ø‘¥Ÿ «ÿƒø¿œ ∞°¥…º∫?
-		if (ch->GetDesc()->DelayedDisconnect(number(2, 9)))
-		{
-			LogManager::instance().HackLog("Hacker", ch);
-			sys_log(0, "HACKER: %s arg %u", ch->GetName(), bArg);
-		}
-
-		HackScalar = 10;
-		ch->SetValidComboInterval(300);
-	}
-
-	if (HackScalar)
-	{
-		// ∏ªø° ≈∏∞≈≥™ ≥ª∑»¿ª ∂ß 1.5√ ∞£ ∞¯∞›¿∫ «Ÿ¿∏∑Œ ∞£¡÷«œ¡ˆ æ µ« ∞¯∞›∑¬¿∫ æ¯∞‘ «œ¥¬ √≥∏Æ
-		if (get_dword_time() - ch->GetLastMountTime() > 1500)
-			ch->IncreaseComboHackCount(1 + HackScalar);
-
-		ch->SkipComboAttackByTime(ch->GetValidComboInterval());
-	}
-
-	return HackScalar;
-}
-
-void CInputMain::Move(LPCHARACTER ch, const char* data)
-{
-	if (!ch->CanMove())
-		return;
-
-	struct command_move* pinfo = (struct command_move*)data;
-
-	if (pinfo->bFunc >= FUNC_MAX_NUM && !(pinfo->bFunc & 0x80))
-	{
-		sys_err("invalid move type: %s", ch->GetName());
-		return;
-	}
-
-	/*
-	enum EMoveFuncType
-	{
-		FUNC_WAIT,
-		FUNC_MOVE,
-		FUNC_ATTACK,
-		FUNC_COMBO,
-		FUNC_MOB_SKILL,
-		_FUNC_SKILL,
-		FUNC_MAX_NUM,
-		FUNC_SKILL = 0x80,
-	};
-	*/
-
-	// ≈⁄∑π∆˜∆Æ «Ÿ √º≈©
-
-	//if (!test_server) // 20120515 ±ËøÎøÌ : ≈◊º∑ø°º≠ (π´¿˚ªÛ≈¬∑Œ) ¥Ÿºˆ ∏ÛΩ∫≈Õ ªÛ¥Î∑Œ ¥ŸøÓµ«∏Èº≠ ∞¯∞›Ω√ ƒﬁ∫∏«Ÿ¿∏∑Œ ¡◊¥¬ πÆ¡¶∞° ¿÷æ˙¥Ÿ.
-	{
-		const float fDist = DISTANCE_SQRT((ch->GetX() - pinfo->lX) / 100, (ch->GetY() - pinfo->lY) / 100);
-#ifdef MOUNT_FIX
-		if (((false == ch->IsRiding() && fDist > 750) || fDist > 999) && OXEVENT_MAP_INDEX != ch->GetMapIndex())
-#else
-		if (((false == ch->IsRiding() && fDist > 25) || fDist > 60) && OXEVENT_MAP_INDEX != ch->GetMapIndex())
-#endif
-		{
-			sys_log(0, "MOVE: %s trying to move too far (dist: %.1fm) Riding(%d)", ch->GetName(), fDist, ch->IsRiding());
-
-			ch->Show(ch->GetMapIndex(), ch->GetX(), ch->GetY(), ch->GetZ());
-			ch->Stop();
-			return;
-		}
-
-		//
-		// Ω∫««µÂ«Ÿ(SPEEDHACK) Check
-		//
-		int dwCurTime = get_dword_time();
-		// Ω√∞£¿ª Sync«œ∞Ì 7√  »ƒ ∫Œ≈Õ ∞ÀªÁ«—¥Ÿ. (20090702 ¿Ã¿¸ø£ 5√ ø¥¿Ω)
-		bool CheckSpeedHack = (false == ch->GetDesc()->IsHandshaking() && dwCurTime - ch->GetDesc()->GetClientTime() > 7000);
-
-		if (CheckSpeedHack)
-		{
-			int iDelta = (int)(dwCurTime - pinfo->dwTime);
-			int iServerDelta = (int)(dwCurTime - ch->GetDesc()->GetClientTime());
-
-			iDelta = (int)(dwCurTime - pinfo->dwTime);
-
-			// Ω√∞£¿Ã ¥ ∞‘∞£¥Ÿ. ¿œ¥‹ ∑Œ±◊∏∏ «ÿµ–¥Ÿ. ¡¯¬• ¿Ã∑± ªÁ∂˜µÈ¿Ã ∏π¿∫¡ˆ √º≈©«ÿæﬂ«‘. TODO
-			if (iDelta >= 30000)
-			{
-				sys_log(0, "SPEEDHACK: slow timer name %s delta %d", ch->GetName(), iDelta);
-				ch->GetDesc()->DelayedDisconnect(3);
-			}
-			// 1√ ø° 20msec ª°∏Æ ∞°¥¬∞≈ ±Ó¡ˆ¥¬ ¿Ã«ÿ«—¥Ÿ.
-			else if (iDelta < -(iServerDelta / 50))
-			{
-				sys_log(0, "SPEEDHACK: DETECTED! %s (delta %d %d)", ch->GetName(), iDelta, iServerDelta);
-				ch->GetDesc()->DelayedDisconnect(3);
-			}
-		}
-
-		//
-		// ƒﬁ∫∏«Ÿ π◊ Ω∫««µÂ«Ÿ √º≈©
-		//
-		if (pinfo->bFunc == FUNC_COMBO && g_bCheckMultiHack)
-		{
-			CheckComboHack(ch, pinfo->bArg, pinfo->dwTime, CheckSpeedHack); // ƒﬁ∫∏ √º≈©
-		}
-	}
-
-	if (pinfo->bFunc == FUNC_MOVE)
-	{
-		if (ch->GetLimitPoint(POINT_MOV_SPEED) == 0)
-			return;
-
-		ch->SetRotation(pinfo->bRot * 5); // ¡ﬂ∫π ƒ⁄µÂ
-		ch->ResetStopTime(); // ""
-
-		ch->Goto(pinfo->lX, pinfo->lY);
-	}
-	else
-	{
-		if (pinfo->bFunc == FUNC_ATTACK || pinfo->bFunc == FUNC_COMBO)
-			ch->OnMove(true);
-		else if (pinfo->bFunc & FUNC_SKILL)
-		{
-			const int MASK_SKILL_MOTION = 0x7F;
-			unsigned int motion = pinfo->bFunc & MASK_SKILL_MOTION;
-
-			if (!ch->IsUsableSkillMotion(motion))
-			{
-				const char* name = ch->GetName();
-				unsigned int job = ch->GetJob();
-				unsigned int group = ch->GetSkillGroup();
-
-				char szBuf[256];
-				snprintf(szBuf, sizeof(szBuf), "SKILL_HACK: name=%s, job=%d, group=%d, motion=%d", name, job, group, motion);
-				LogManager::Instance().HackLog(szBuf, ch->GetDesc()->GetAccountTable().login, ch->GetName(), ch->GetDesc()->GetHostName());
-				sys_log(0, "%s", szBuf);
-
-				if (test_server)
-				{
-					ch->GetDesc()->DelayedDisconnect(number(2, 8));
-					ch->ChatPacket(CHAT_TYPE_INFO, szBuf);
-				}
-				else
-				{
-					ch->GetDesc()->DelayedDisconnect(number(150, 500));
-				}
-			}
-
-			ch->OnMove();
-		}
-
-		ch->SetRotation(pinfo->bRot * 5); // ¡ﬂ∫π ƒ⁄µÂ
-		ch->ResetStopTime(); // ""
-
-		ch->Move(pinfo->lX, pinfo->lY);
-		ch->Stop();
-		ch->StopStaminaConsume();
-	}
-
-	TPacketGCMove pack;
-
-	pack.bHeader = HEADER_GC_MOVE;
-	pack.bFunc = pinfo->bFunc;
-	pack.bArg = pinfo->bArg;
-	pack.bRot = pinfo->bRot;
-	pack.dwVID = ch->GetVID();
-	pack.lX = pinfo->lX;
-	pack.lY = pinfo->lY;
-	pack.dwTime = pinfo->dwTime;
-	pack.dwDuration = (pinfo->bFunc == FUNC_MOVE) ? ch->GetCurrentMoveDuration() : 0;
-
-	ch->PacketAround(&pack, sizeof(TPacketGCMove), ch);
-	/*
-		if (pinfo->dwTime == 10653691) // µπˆ∞≈ πﬂ∞ﬂ
-		{
-			if (ch->GetDesc()->DelayedDisconnect(number(15, 30)))
-				LogManager::instance().HackLog("Debugger", ch);
-
-		}
-		else if (pinfo->dwTime == 10653971) // Softice πﬂ∞ﬂ
-		{
-			if (ch->GetDesc()->DelayedDisconnect(number(15, 30)))
-				LogManager::instance().HackLog("Softice", ch);
-		}
-	*/
-	/*
-	sys_log(0,
-			"MOVE: %s Func:%u Arg:%u Pos:%dx%d Time:%u Dist:%.1f",
-			ch->GetName(),
-			pinfo->bFunc,
-			pinfo->bArg,
-			pinfo->lX / 100,
-			pinfo->lY / 100,
-			pinfo->dwTime,
-			fDist);
-	*/
-}
-
-void CInputMain::Attack(LPCHARACTER ch, const BYTE header, const char* data)
-{
-	if (NULL == ch)
-		return;
-
-	struct type_identifier
-	{
-		BYTE header;
-		BYTE type;
-	};
-
-	const struct type_identifier* const type = reinterpret_cast<const struct type_identifier*>(data);
-
-	if (type->type > 0)
-	{
-		if (false == ch->CanUseSkill(type->type))
-		{
-			return;
-		}
-
-		switch (type->type)
-		{
-			case SKILL_GEOMPUNG:
-			case SKILL_SANGONG:
-			case SKILL_YEONSA:
-			case SKILL_KWANKYEOK:
-			case SKILL_HWAJO:
-			case SKILL_GIGUNG:
-			case SKILL_PABEOB:
-			case SKILL_MARYUNG:
-			case SKILL_TUSOK:
-#if defined(__9TH_SKILL__)
-			case SKILL_ILGWANGPYO:
-			case SKILL_PUNGLOEPO:
-			case SKILL_MABEOBAGGWI:
-			case SKILL_METEO:
-#endif
-			case SKILL_MAHWAN:
-			case SKILL_BIPABU:
-			case SKILL_NOEJEON:
-			case SKILL_CHAIN:
-			case SKILL_HORSE_WILDATTACK_RANGE:
-				if (HEADER_CG_SHOOT != type->header)
-				{
-					if (test_server)
-						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Attack :name[%s] Vnum[%d] can't use skill by attack(warning)", type->type));
-					return;
-				}
-				break;
-		}
-	}
-
-	switch (header)
-	{
-		case HEADER_CG_ATTACK:
-		{
-			if (NULL == ch->GetDesc())
-				return;
-
-			const TPacketCGAttack* const packMelee = reinterpret_cast<const TPacketCGAttack*>(data);
-
-			ch->GetDesc()->AssembleCRCMagicCube(packMelee->bCRCMagicCubeProcPiece, packMelee->bCRCMagicCubeFilePiece);
-
-			LPCHARACTER victim = CHARACTER_MANAGER::instance().Find(packMelee->dwVID);
-
-			if (NULL == victim || ch == victim)
-				return;
-
-			switch (victim->GetCharType())
-			{
-				case CHAR_TYPE_NPC:
-				case CHAR_TYPE_WARP:
-				case CHAR_TYPE_GOTO:
-				case CHAR_TYPE_HORSE:
-					//#if defined(__GROWTH_PET_SYSTEM__)
-				case CHAR_TYPE_PET:
-					//#endif
-				case CHAR_TYPE_PET_PAY:
-				case CHAR_TYPE_SHOP:
-					return;
-			}
-
-			if (packMelee->bType > 0)
-			{
-				if (false == ch->CheckSkillHitCount(packMelee->bType, victim->GetVID()))
-				{
-					return;
-				}
-			}
-
-			ch->Attack(victim, packMelee->bType);
-		}
-		break;
-
-		case HEADER_CG_SHOOT:
-		{
-			const TPacketCGShoot* const packShoot = reinterpret_cast<const TPacketCGShoot*>(data);
-
-			ch->Shoot(packShoot->bType);
-		}
-		break;
-	}
-}
-
-int CInputMain::SyncPosition(LPCHARACTER ch, const char* c_pcData, size_t uiBytes)
-{
-	const TPacketCGSyncPosition* pinfo = reinterpret_cast<const TPacketCGSyncPosition*>(c_pcData);
-
-	if (uiBytes < pinfo->wSize)
-		return -1;
-
-	int iExtraLen = pinfo->wSize - sizeof(TPacketCGSyncPosition);
-
-	if (iExtraLen < 0)
-	{
-		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->wSize, uiBytes);
-		ch->GetDesc()->SetPhase(PHASE_CLOSE);
-		return -1;
-	}
-
-	if (0 != (iExtraLen % sizeof(TPacketCGSyncPositionElement)))
-	{
-		sys_err("invalid packet length %d (name: %s)", pinfo->wSize, ch->GetName());
-		return iExtraLen;
-	}
-
-	int iCount = iExtraLen / sizeof(TPacketCGSyncPositionElement);
-
-	if (iCount <= 0)
-		return iExtraLen;
-
-	static const int nCountLimit = 16;
-
-	if (iCount > nCountLimit)
-	{
-		// LogManager::instance().HackLog( "SYNC_POSITION_HACK", ch );
-		sys_err("Too many SyncPosition Count(%d) from Name(%s)", iCount, ch->GetName());
-		// ch->GetDesc()->SetPhase(PHASE_CLOSE);
-		// return -1;
-		iCount = nCountLimit;
-	}
-
-	TEMP_BUFFER tbuf;
-	LPBUFFER lpBuf = tbuf.getptr();
-
-	TPacketGCSyncPosition* pHeader = (TPacketGCSyncPosition*)buffer_write_peek(lpBuf);
-	buffer_write_proceed(lpBuf, sizeof(TPacketGCSyncPosition));
-
-	const TPacketCGSyncPositionElement* e =
-		reinterpret_cast<const TPacketCGSyncPositionElement*>(c_pcData + sizeof(TPacketCGSyncPosition));
-
-	timeval tvCurTime;
-	gettimeofday(&tvCurTime, NULL);
-
-	for (int i = 0; i < iCount; ++i, ++e)
-	{
-		LPCHARACTER victim = CHARACTER_MANAGER::instance().Find(e->dwVID);
-
-		if (!victim)
-			continue;
-
-		switch (victim->GetCharType())
-		{
-			case CHAR_TYPE_NPC:
-			case CHAR_TYPE_WARP:
-			case CHAR_TYPE_GOTO:
-			case CHAR_TYPE_HORSE:
-				//#if defined(__GROWTH_PET_SYSTEM__)
-			case CHAR_TYPE_PET:
-				//#endif
-			case CHAR_TYPE_PET_PAY:
-			case CHAR_TYPE_SHOP:
-				continue;
-		}
-
-		// º“¿Ø±« ∞ÀªÁ
-		if (!victim->SetSyncOwner(ch))
-			continue;
-
-		const float fDistWithSyncOwner = DISTANCE_SQRT((victim->GetX() - ch->GetX()) / 100, (victim->GetY() - ch->GetY()) / 100);
-		static const float fLimitDistWithSyncOwner = 2500.f + 1000.f;
-		// victim∞˙¿« ∞≈∏Æ∞° 2500 + a ¿ÃªÛ¿Ã∏È «Ÿ¿∏∑Œ ∞£¡÷.
-		// ∞≈∏Æ ¬¸¡∂ : ≈¨∂Û¿Ãæ∆Æ¿« __GetSkillTargetRange, __GetBowRange «‘ºˆ
-		// 2500 : Ω∫≈≥ protoø°º≠ ∞°¿Â ªÁ∞≈∏Æ∞° ±‰ Ω∫≈≥¿« ªÁ∞≈∏Æ, ∂«¥¬ »∞¿« ªÁ∞≈∏Æ
-		// a = POINT_BOW_DISTANCE ∞™... ¿Œµ• Ω«¡¶∑Œ ªÁøÎ«œ¥¬ ∞™¿Œ¡ˆ¥¬ ¿ﬂ ∏∏£∞⁄¿Ω. æ∆¿Ã≈€¿Ã≥™ ∆˜º«, Ω∫≈≥, ƒ˘Ω∫∆Æø°¥¬ æ¯¥¬µ•...
-		// ±◊∑°µµ »§Ω√≥™ «œ¥¬ ∏∂¿Ωø° πˆ∆€∑Œ ªÁøÎ«“ ∞‚«ÿº≠ 1000.f ∑Œ µ“...
-		if (fDistWithSyncOwner > fLimitDistWithSyncOwner)
-		{
-			// g_iSyncHackLimitCountπ¯ ±Ó¡ˆ¥¬ ∫¡¡‹.
-			if (ch->GetSyncHackCount() < g_iSyncHackLimitCount)
-			{
-				ch->SetSyncHackCount(ch->GetSyncHackCount() + 1);
-				continue;
-			}
-			else
-			{
-				LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
-
-				sys_err("Too far SyncPosition DistanceWithSyncOwner(%f)(%s) from Name(%s) CH(%d,%d) VICTIM(%d,%d) SYNC(%d,%d)",
-					fDistWithSyncOwner, victim->GetName(), ch->GetName(), ch->GetX(), ch->GetY(), victim->GetX(), victim->GetY(),
-					e->lX, e->lY);
-
-				ch->GetDesc()->SetPhase(PHASE_CLOSE);
-
-				return -1;
-			}
-		}
-
-		const float fDist = DISTANCE_SQRT((victim->GetX() - e->lX) / 100, (victim->GetY() - e->lY) / 100);
-		static const long g_lValidSyncInterval = 100 * 1000; // 100ms
-		const timeval& tvLastSyncTime = victim->GetLastSyncTime();
-		timeval* tvDiff = timediff(&tvCurTime, &tvLastSyncTime);
-
-		// SyncPosition¿ª æ«øÎ«œø© ≈∏¿Ø¿˙∏¶ ¿ÃªÛ«— ∞˜¿∏∑Œ ∫∏≥ª¥¬ «Ÿ πÊæÓ«œ±‚ ¿ß«œø©,
-		// ∞∞¿∫ ¿Ø¿˙∏¶ g_lValidSyncInterval ms ¿Ã≥ªø° ¥ŸΩ√ SyncPosition«œ∑¡∞Ì «œ∏È «Ÿ¿∏∑Œ ∞£¡÷.
-		if (tvDiff->tv_sec == 0 && tvDiff->tv_usec < g_lValidSyncInterval)
-		{
-			// g_iSyncHackLimitCountπ¯ ±Ó¡ˆ¥¬ ∫¡¡‹.
-			if (ch->GetSyncHackCount() < g_iSyncHackLimitCount)
-			{
-				ch->SetSyncHackCount(ch->GetSyncHackCount() + 1);
-				continue;
-			}
-			else
-			{
-				LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
-
-				sys_err("Too often SyncPosition Interval(%ldms)(%s) from Name(%s) VICTIM(%d,%d) SYNC(%d,%d)",
-					tvDiff->tv_sec * 1000 + tvDiff->tv_usec / 1000, victim->GetName(), ch->GetName(), victim->GetX(), victim->GetY(),
-					e->lX, e->lY);
-
-				ch->GetDesc()->SetPhase(PHASE_CLOSE);
-
-				return -1;
-			}
-		}
-		else if (fDist > 25.0f)
-		{
-			LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
-
-			sys_err("Too far SyncPosition Distance(%f)(%s) from Name(%s) CH(%d,%d) VICTIM(%d,%d) SYNC(%d,%d)",
-				fDist, victim->GetName(), ch->GetName(), ch->GetX(), ch->GetY(), victim->GetX(), victim->GetY(),
-				e->lX, e->lY);
-
-			ch->GetDesc()->SetPhase(PHASE_CLOSE);
-
-			return -1;
-		}
-		else
-		{
-			victim->SetLastSyncTime(tvCurTime);
-			victim->Sync(e->lX, e->lY);
-			buffer_write(lpBuf, e, sizeof(TPacketCGSyncPositionElement));
-		}
-	}
-
-	if (buffer_size(lpBuf) != sizeof(TPacketGCSyncPosition))
-	{
-		pHeader->bHeader = HEADER_GC_SYNC_POSITION;
-		pHeader->wSize = buffer_size(lpBuf);
-
-		ch->PacketAround(buffer_read_peek(lpBuf), buffer_size(lpBuf), ch);
-	}
-
-	return iExtraLen;
-}
-
-void CInputMain::FlyTarget(LPCHARACTER ch, const char* pcData, BYTE bHeader)
-{
-	TPacketCGFlyTargeting* p = (TPacketCGFlyTargeting*)pcData;
-	ch->FlyTarget(p->dwTargetVID, p->x, p->y, bHeader);
-}
-
-void CInputMain::UseSkill(LPCHARACTER ch, const char* pcData)
-{
-	TPacketCGUseSkill* p = (TPacketCGUseSkill*)pcData;
-	ch->UseSkill(p->dwVnum, CHARACTER_MANAGER::instance().Find(p->dwVID));
-}
-
-void CInputMain::ScriptButton(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGScriptButton* p = (TPacketCGScriptButton*)c_pData;
-	sys_log(0, "QUEST ScriptButton pid %d idx %u", ch->GetPlayerID(), p->idx);
-
-	quest::PC* pc = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
-	if (pc && pc->IsConfirmWait())
-	{
-		quest::CQuestManager::instance().Confirm(ch->GetPlayerID(), quest::CONFIRM_TIMEOUT);
-	}
-	else if (p->idx & 0x80000000)
-	{
-		quest::CQuestManager::Instance().QuestInfo(ch->GetPlayerID(), p->idx & 0x7fffffff);
-	}
-	else
-	{
-		quest::CQuestManager::Instance().QuestButton(ch->GetPlayerID(), p->idx);
-	}
-}
-
-void CInputMain::ScriptAnswer(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGScriptAnswer* p = (TPacketCGScriptAnswer*)c_pData;
-	sys_log(0, "QUEST ScriptAnswer pid %d answer %d", ch->GetPlayerID(), p->answer);
-
-	if (p->answer > 250) // ¥Ÿ¿Ω πˆ∆∞ø° ¥Î«— ¿¿¥‰¿∏∑Œ ø¬ ∆–≈∂¿Œ ∞ÊøÏ
-	{
-		quest::CQuestManager::Instance().Resume(ch->GetPlayerID());
-	}
-	else // º±≈√ πˆ∆∞¿ª ∞Ò∂Ûº≠ ø¬ ∆–≈∂¿Œ ∞ÊøÏ
-	{
-		quest::CQuestManager::Instance().Select(ch->GetPlayerID(), p->answer);
-	}
-}
-
-// SCRIPT_SELECT_ITEM
-void CInputMain::ScriptSelectItem(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGScriptSelectItem* p = (TPacketCGScriptSelectItem*)c_pData;
-	sys_log(0, "QUEST ScriptSelectItem pid %d answer %d", ch->GetPlayerID(), p->selection);
-	quest::CQuestManager::Instance().SelectItem(ch->GetPlayerID(), p->selection);
-}
-// END_OF_SCRIPT_SELECT_ITEM
-
-#if defined(__GEM_SYSTEM__)
-void CInputMain::SelectItemEx(LPCHARACTER c_lpCh, const void* c_pvData)
-{
-	if (c_lpCh == nullptr)
-		return;
-
-	TPacketCGSelectItemEx* pPacket = (TPacketCGSelectItemEx*)c_pvData;
-	sys_log(0, "SelectItemEx player (pid: %d) item (pos: %d)", c_lpCh->GetPlayerID(), pPacket->dwItemPos);
-	c_lpCh->SelectItemEx(pPacket->dwItemPos, pPacket->bType);
-}
-#endif
-
-#if defined(__QUEST_REQUEST_EVENT__)
-void CInputMain::RequestEventQuest(LPCHARACTER pChar, const void* c_pvData)
-{
-	const TPacketCGRequestEventQuest* c_pData = reinterpret_cast<const TPacketCGRequestEventQuest*>(c_pvData);
-	unsigned int uiQuestIndex = quest::CQuestManager::instance().GetQuestIndexByName(c_pData->szEventQuest);
-	if (uiQuestIndex)
-	{
-		if (quest::CQuestManager::instance().GetPCForce(pChar->GetPlayerID())->IsRunning())
-			return;
-
-		sys_log(0, "QUEST RequestEventQuest pid(%d), qid(%d)", pChar->GetPlayerID(), uiQuestIndex);
-		quest::CQuestManager::instance().RequestEvent(pChar->GetPlayerID(), uiQuestIndex, 0);
-	}
-}
-#endif
-
-void CInputMain::QuestInputString(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGQuestInputString* p = (TPacketCGQuestInputString*)c_pData;
-
-	char msg[65];
-	strlcpy(msg, p->msg, sizeof(msg));
-	sys_log(0, "QUEST InputString pid %u msg %s", ch->GetPlayerID(), msg);
-
-	quest::CQuestManager::Instance().Input(ch->GetPlayerID(), msg);
-}
-
-#if defined(__OX_RENEWAL__)
-void CInputMain::QuestInputLongString(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGQuestInputLongString* p = (TPacketCGQuestInputLongString*)c_pData;
-
-	char msg[129];
-	strlcpy(msg, p->msg, sizeof(msg));
-	sys_log(0, "QUEST InputLongString pid %u msg %s", ch->GetPlayerID(), msg);
-
-	quest::CQuestManager::Instance().Input(ch->GetPlayerID(), msg);
-}
-#endif
-
-void CInputMain::QuestConfirm(LPCHARACTER ch, const void* c_pData)
-{
-	TPacketCGQuestConfirm* p = (TPacketCGQuestConfirm*)c_pData;
-	LPCHARACTER ch_wait = CHARACTER_MANAGER::instance().FindByPID(p->requestPID);
-	if (p->answer)
-		p->answer = quest::CONFIRM_YES;
-	sys_log(0, "QuestConfirm from %s pid %u name %s answer %d", ch->GetName(), p->requestPID, (ch_wait) ? ch_wait->GetName() : "", p->answer);
-	if (ch_wait)
-	{
-		quest::CQuestManager::Instance().Confirm(ch_wait->GetPlayerID(), (quest::EQuestConfirmType)p->answer, ch->GetPlayerID());
-	}
-}
-
-void CInputMain::Target(LPCHARACTER ch, const char* pcData)
-{
-	TPacketCGTarget* p = (TPacketCGTarget*)pcData;
-
-	building::LPOBJECT pkObj = building::CManager::instance().FindObjectByVID(p->dwVID);
-
-	if (pkObj)
-	{
-		TPacketGCTarget pckTarget;
-		pckTarget.header = HEADER_GC_TARGET;
-		pckTarget.dwVID = p->dwVID;
-#if defined(__DEFENSE_WAVE__)
-		pckTarget.bAlliance = false;
-#endif
-		ch->GetDesc()->Packet(&pckTarget, sizeof(TPacketGCTarget));
-	}
-	else
-		ch->SetTarget(CHARACTER_MANAGER::instance().Find(p->dwVID));
-}
-
-void CInputMain::Warp(LPCHARACTER ch, const char* pcData)
-{
-	ch->WarpEnd();
-}
-
-void CInputMain::SafeboxCheckin(LPCHARACTER ch, const char* c_pData)
-{
-	if (quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID())->IsRunning() == true)
-		return;
-
-	TPacketCGSafeboxCheckin* p = (TPacketCGSafeboxCheckin*)c_pData;
-
-	if (!ch->CanHandleItem())
-		return;
-
-	CSafebox* pkSafebox = ch->GetSafebox();
-	LPITEM pkItem = ch->GetItem(p->ItemPos);
-
-	if (!pkSafebox || !pkItem)
-		return;
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	if (pkItem->GetCell() >= ch->GetExtendInvenMax() && IS_SET(pkItem->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-#else
-	if (pkItem->GetCell() >= INVENTORY_MAX_NUM && IS_SET(pkItem->GetFlag(), ITEM_FLAG_IRREMOVABLE))
-#endif
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢∞Ì> √¢∞Ì∑Œ ø≈±Ê ºˆ æ¯¥¬ æ∆¿Ã≈€ ¿‘¥œ¥Ÿ."));
-		return;
-	}
-
-	if (!pkSafebox->IsEmpty(p->bSafePos, pkItem->GetSize()))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢∞Ì> ø≈±Ê ºˆ æ¯¥¬ ¿ßƒ°¿‘¥œ¥Ÿ."));
-		return;
-	}
-
-	if (pkItem->GetSIGVnum() == UNIQUE_GROUP_LARGE_SAFEBOX)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢∞Ì> ¿Ã æ∆¿Ã≈€¿∫ ≥÷¿ª ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return;
-	}
-
-	if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_SAFEBOX))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢∞Ì> ¿Ã æ∆¿Ã≈€¿∫ ≥÷¿ª ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return;
-	}
-
-	if (pkItem->IsEquipped())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Storeroom] An item that is currently being used cannot be stored."));
-		return;
-	}
-
-#if defined(__PET_SYSTEM__)
-	CPetSystem* pPetSystem = ch->GetPetSystem();
-	if (pPetSystem && pPetSystem->GetSummonItemVID() == pkItem->GetVID())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Storeroom] An item that is currently being used cannot be stored."));
-		return;
-	}
-#endif
-
-	if (true == pkItem->isLocked())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢∞Ì> ¿Ã æ∆¿Ã≈€¿∫ ≥÷¿ª ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return;
-	}
-
-	// Prevent items from the belt inventory checking-in the safebox.
-	if (p->ItemPos.window_type == BELT_INVENTORY)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Cannot proceed."));
-		return;
-	}
-
-	pkItem->RemoveFromCharacter();
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (!pkItem->IsDragonSoul())
-#endif
-		ch->SyncQuickslot(SLOT_TYPE_INVENTORY, p->ItemPos.cell, WORD_MAX);
-
-	pkSafebox->Add(p->bSafePos, pkItem);
-#ifdef __GROWTH_PET_SYSTEM__
-	if (pkItem->GetType() == ITEM_PET)
-	{
-		if (pkItem->GetSubType() == PET_UPBRINGING || pkItem->GetSubType() == PET_BAG)
-		{
-			LPGROWTH_PET pPet = ch->GetGrowthPet(pkItem->GetSocket(2));
-			if (pPet)
-				pkSafebox->AddPet(pPet);
-		}
-	}
-#endif
-	char szHint[128];
-	snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
-	LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX PUT", szHint);
-}
-
-void CInputMain::SafeboxCheckout(LPCHARACTER ch, const char* c_pData, bool bMall)
-{
-	TPacketCGSafeboxCheckout* p = (TPacketCGSafeboxCheckout*)c_pData;
-
-	if (!ch->CanHandleItem())
-		return;
-
-	CSafebox* pkSafebox;
-
-	if (bMall)
-		pkSafebox = ch->GetMall();
-	else
-		pkSafebox = ch->GetSafebox();
-
-	if (!pkSafebox)
-		return;
-
-	LPITEM pkItem = pkSafebox->Get(p->bSafePos);
-	if (!pkItem)
-		return;
-
-	if (p->ItemPos.IsBeltInventoryPosition())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Cannot proceed."));
-		return;
-	}
-
-#if defined(__SAFEBOX_IMPROVING__)
-	if ((p->ItemPos.window_type == INVENTORY) && (p->ItemPos.cell == 0))
-	{
-		BYTE bWindow = INVENTORY;
-		INT iCell = -1;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (pkItem->IsDragonSoul())
-		{
-			bWindow = DRAGON_SOUL_INVENTORY;
-			iCell = ch->GetEmptyDragonSoulInventory(pkItem);
-		}
-
-		else
-#endif
-		{
-			bWindow = INVENTORY;
-			iCell = ch->GetEmptyInventory(pkItem->GetSize());
-		}
-
-
-		if (iCell < 0)
-			return;
-
-		pkSafebox->Remove(p->bSafePos);
-		if (bMall)
-		{
-			if (NULL == pkItem->GetProto())
-			{
-				sys_err("pkItem->GetProto() == NULL (id : %d)", pkItem->GetID());
-				return;
-			}
-			// 100% »Æ∑¸∑Œ º”º∫¿Ã ∫ŸæÓæﬂ «œ¥¬µ• æ» ∫ŸæÓ¿÷¥Ÿ∏È ªı∑Œ ∫Ÿ»˘¥Ÿ. ...............
-			if (100 == pkItem->GetProto()->bAlterToMagicItemPct && 0 == pkItem->GetAttributeCount())
-			{
-				pkItem->AlterToMagicItem(number(40, 50), number(10, 15));
-			}
-		}
-		pkItem->AddToCharacter(ch, TItemPos(bWindow, (WORD)iCell)
-#if defined(__WJ_PICKUP_ITEM_EFFECT__)
-			, false
-#endif
-		);
-		ITEM_MANAGER::Instance().FlushDelayedSave(pkItem);
-
-		DWORD dwID = pkItem->GetID();
-		db_clientdesc->DBPacketHeader(HEADER_GD_ITEM_FLUSH, 0, sizeof(DWORD));
-		db_clientdesc->Packet(&dwID, sizeof(DWORD));
-
-		char szHint[128];
-		snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
-		if (bMall)
-			LogManager::instance().ItemLog(ch, pkItem, "MALL GET", szHint);
-		else
-			LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX GET", szHint);
-
-		return;
-	}
-#endif
-
-	if (!ch->IsEmptyItemGrid(p->ItemPos, pkItem->GetSize()))
-		return;
-
-	// æ∆¿Ã≈€ ∏Ùø°º≠ ¿Œ∫•¿∏∑Œ ø≈±‚¥¬ ∫Œ∫–ø°º≠ øÎ»•ºÆ ∆Øºˆ √≥∏Æ
-	// (∏Ùø°º≠ ∏∏µÂ¥¬ æ∆¿Ã≈€¿∫ item_protoø° ¡§¿«µ»¥Î∑Œ º”º∫¿Ã ∫Ÿ±‚ ∂ßπÆø°,
-	// øÎ»•ºÆ¿« ∞ÊøÏ, ¿Ã √≥∏Æ∏¶ «œ¡ˆ æ ¿∏∏È º”º∫¿Ã «œ≥™µµ ∫Ÿ¡ˆ æ ∞‘ µ»¥Ÿ.)
-#if defined(__DRAGON_SOUL_SYSTEM__)
-	if (pkItem->IsDragonSoul())
-	{
-		if (bMall)
-		{
-			DSManager::instance().DragonSoulItemInitialize(pkItem);
-		}
-
-		if (DRAGON_SOUL_INVENTORY != p->ItemPos.window_type)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢∞Ì> ø≈±Ê ºˆ æ¯¥¬ ¿ßƒ°¿‘¥œ¥Ÿ."));
-			return;
-		}
-
-		TItemPos DestPos = p->ItemPos;
-		if (!DSManager::instance().IsValidCellForThisItem(pkItem, DestPos))
-		{
-			int iCell = ch->GetEmptyDragonSoulInventory(pkItem);
-			if (iCell < 0)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢∞Ì> ø≈±Ê ºˆ æ¯¥¬ ¿ßƒ°¿‘¥œ¥Ÿ."));
-				return;
-			}
-			DestPos = TItemPos(DRAGON_SOUL_INVENTORY, iCell);
-		}
-
-		pkSafebox->Remove(p->bSafePos);
-		pkItem->AddToCharacter(ch, DestPos);
-		ITEM_MANAGER::instance().FlushDelayedSave(pkItem);
-	}
-	else
-#endif
-	{
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		if (DRAGON_SOUL_INVENTORY == p->ItemPos.window_type)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢∞Ì> ø≈±Ê ºˆ æ¯¥¬ ¿ßƒ°¿‘¥œ¥Ÿ."));
-			return;
-		}
-#endif
-
-		pkSafebox->Remove(p->bSafePos);
-		if (bMall)
-		{
-			if (NULL == pkItem->GetProto())
-			{
-				sys_err("pkItem->GetProto() == NULL (id : %d)", pkItem->GetID());
-				return;
-			}
-			// 100% »Æ∑¸∑Œ º”º∫¿Ã ∫ŸæÓæﬂ «œ¥¬µ• æ» ∫ŸæÓ¿÷¥Ÿ∏È ªı∑Œ ∫Ÿ»˘¥Ÿ. ...............
-			if (100 == pkItem->GetProto()->bAlterToMagicItemPct && 0 == pkItem->GetAttributeCount())
-			{
-				pkItem->AlterToMagicItem(number(40, 50), number(10, 15));
-			}
-		}
-		pkItem->AddToCharacter(ch, p->ItemPos);
-		ITEM_MANAGER::instance().FlushDelayedSave(pkItem);
-#ifdef __GROWTH_PET_SYSTEM__
-		if (pkItem->GetType() == ITEM_PET)
-		{
-			if (pkItem->GetSubType() == PET_UPBRINGING || pkItem->GetSubType() == PET_BAG)
-				pkSafebox->RemovePet(pkItem);
-		}
-#endif
-	}
-
-	DWORD dwID = pkItem->GetID();
-	db_clientdesc->DBPacketHeader(HEADER_GD_ITEM_FLUSH, 0, sizeof(DWORD));
-	db_clientdesc->Packet(&dwID, sizeof(DWORD));
-
-	char szHint[128];
-	snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
-	if (bMall)
-		LogManager::instance().ItemLog(ch, pkItem, "MALL GET", szHint);
-	else
-		LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX GET", szHint);
-}
-
-void CInputMain::SafeboxItemMove(LPCHARACTER ch, const char* data)
-{
-	struct command_item_move* pinfo = (struct command_item_move*)data;
-
-	if (!ch->CanHandleItem())
-		return;
-
-	if (!ch->GetSafebox())
-		return;
-
-	ch->GetSafebox()->MoveItem(pinfo->Cell.cell, pinfo->CellTo.cell, pinfo->count);
-}
-
-// PARTY_JOIN_BUG_FIX
-void CInputMain::PartyInvite(LPCHARACTER ch, const char* c_pData)
-{
-	if (!ch)
-		return;
-
-	if (ch->GetArena())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¥Î∑√¿Âø°º≠ ªÁøÎ«œΩ« ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return;
-	}
-
-	TPacketCGPartyInvite* p = (TPacketCGPartyInvite*)c_pData;
-
-	LPCHARACTER pInvitee = CHARACTER_MANAGER::instance().Find(p->vid);
-	if (ch == pInvitee)
-		return;
-
-	if (!pInvitee || !ch->GetDesc() || !pInvitee->GetDesc() || !pInvitee->IsPC() || !ch->IsPC())
-	{
-		sys_err("PARTY Cannot find invited character");
-		return;
-	}
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-	if (CMessengerManager::instance().IsBlocked(ch->GetName(), pInvitee->GetName()))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", pInvitee->GetName()));
-		return;
-	}
-	else if (CMessengerManager::instance().IsBlocked(pInvitee->GetName(), ch->GetName()))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", pInvitee->GetName()));
-		return;
-	}
-#endif
-
-	ch->PartyInvite(pInvitee);
-}
-
-void CInputMain::PartyInviteAnswer(LPCHARACTER ch, const char* c_pData)
-{
-	if (!ch)
-		return;
-
-	if (ch->GetArena())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¥Î∑√¿Âø°º≠ ªÁøÎ«œΩ« ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return;
-	}
-
-	TPacketCGPartyInviteAnswer* p = (TPacketCGPartyInviteAnswer*)c_pData;
-
-	LPCHARACTER pInviter = CHARACTER_MANAGER::instance().Find(p->leader_vid);
-
-	// pInviter ∞° ch ø°∞‘ ∆ƒ∆º ø‰√ª¿ª «ﬂæ˙¥Ÿ.
-
-	if (!pInviter || !pInviter->IsPC())
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ∆ƒ∆ºø‰√ª¿ª «— ƒ≥∏Ø≈Õ∏¶ √£¿ªºˆ æ¯Ω¿¥œ¥Ÿ."));
-	else if (!p->accept)
-		pInviter->PartyInviteDeny(ch->GetPlayerID());
-	else
-		pInviter->PartyInviteAccept(ch);
-}
-// END_OF_PARTY_JOIN_BUG_FIX
-
-void CInputMain::PartySetState(LPCHARACTER ch, const char* c_pData)
-{
-	if (!CPartyManager::instance().IsEnablePCParty())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> º≠πˆ πÆ¡¶∑Œ ∆ƒ∆º ∞¸∑√ √≥∏Æ∏¶ «“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return;
-	}
-
-	TPacketCGPartySetState* p = (TPacketCGPartySetState*)c_pData;
-
-	if (!ch->GetParty())
-		return;
-
-	if (ch->GetParty()->GetLeaderPID() != ch->GetPlayerID())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ∏Æ¥ı∏∏ ∫Ø∞Ê«“ ºˆ ¿÷Ω¿¥œ¥Ÿ."));
-		return;
-	}
-
-	if (!ch->GetParty()->IsMember(p->pid))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ªÛ≈¬∏¶ ∫Ø∞Ê«œ∑¡¥¬ ªÁ∂˜¿Ã ∆ƒ∆ºø¯¿Ã æ∆¥’¥œ¥Ÿ."));
-		return;
-	}
-
-	DWORD pid = p->pid;
-	sys_log(0, "PARTY SetRole pid %d to role %d state %s", pid, p->byRole, p->flag ? "on" : "off");
-
-	switch (p->byRole)
-	{
-		case PARTY_ROLE_NORMAL:
-			break;
-
-		case PARTY_ROLE_ATTACKER:
-		case PARTY_ROLE_TANKER:
-		case PARTY_ROLE_BUFFER:
-		case PARTY_ROLE_SKILL_MASTER:
-		case PARTY_ROLE_HASTE:
-		case PARTY_ROLE_DEFENDER:
-			if (ch->GetParty()->SetRole(pid, p->byRole, p->flag))
-			{
-				TPacketPartyStateChange pack;
-				pack.dwLeaderPID = ch->GetPlayerID();
-				pack.dwPID = p->pid;
-				pack.bRole = p->byRole;
-				pack.bFlag = p->flag;
-				db_clientdesc->DBPacket(HEADER_GD_PARTY_STATE_CHANGE, 0, &pack, sizeof(pack));
-			}
-			/*
-			else
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> æÓ≈¬ƒø º≥¡§ø° Ω«∆–«œø¥Ω¿¥œ¥Ÿ."));
-			*/
-			break;
-
-		default:
-			sys_err("wrong byRole in PartySetState Packet name %s state %d", ch->GetName(), p->byRole);
-			break;
-	}
-}
-
-void CInputMain::PartyRemove(LPCHARACTER ch, const char* c_pData)
-{
-	if (ch->GetArena())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¥Î∑√¿Âø°º≠ ªÁøÎ«œΩ« ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return;
-	}
-
-	if (!CPartyManager::instance().IsEnablePCParty())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> º≠πˆ πÆ¡¶∑Œ ∆ƒ∆º ∞¸∑√ √≥∏Æ∏¶ «“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return;
-	}
-
-#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
-	if (ch->GetGuildDragonLair())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot disband the group while you are still active in Meley's Lair."));
-		return;
-	}
-#endif
-
-	TPacketCGPartyRemove* p = (TPacketCGPartyRemove*)c_pData;
-	LPPARTY pParty = ch->GetParty();
-
-	if (!pParty)
-		return;
-
-	if (pParty->GetDungeon_for_Only_party())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ¥¯¿¸ æ»ø°º≠¥¬ ∆ƒ∆ºø°º≠ ≥™∞• ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		return;
-	}
-
-	if (pParty->GetLeaderPID() == ch->GetPlayerID())
-	{
-		if (ch->GetDungeon()
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-			|| ch->GetGuildDragonLair()
-#endif
-#if defined(__DEFENSE_WAVE__)
-			|| ch->GetDefenseWave()
-#endif
-			)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ¥¯¡Ø≥ªø°º≠¥¬ ∆ƒ∆ºø¯¿ª √ﬂπÊ«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		}
-		else
-		{
-#ifdef ENABLE_QUEEN_NETHIS
-			if (SnakeLair::CSnk::instance().IsSnakeMap(ch->GetMapIndex()))
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ¥¯¡Ø≥ªø°º≠¥¬ ∆ƒ∆ºø¯¿ª √ﬂπÊ«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-				return;
-			}
-#endif
-			// leader can remove any member
-			if (p->pid == ch->GetPlayerID() || pParty->GetMemberCount() == 2)
-			{
-				// party disband
-				CPartyManager::instance().DeleteParty(pParty);
-			}
-			else
-			{
-				LPCHARACTER B = CHARACTER_MANAGER::instance().FindByPID(p->pid);
-				if (B)
-				{
-					//pParty->SendPartyRemoveOneToAll(B);
-					B->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ∆ƒ∆ºø°º≠ √ﬂπÊ¥Á«œºÃΩ¿¥œ¥Ÿ."));
-					//pParty->Unlink(B);
-					//CPartyManager::instance().SetPartyMember(B->GetPlayerID(), NULL);
-				}
-				pParty->Quit(p->pid);
-			}
-		}
-	}
-	else
-	{
-		// otherwise, only remove itself
-		if (p->pid == ch->GetPlayerID())
-		{
-			if (ch->GetDungeon()
-#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
-				|| ch->GetGuildDragonLair()
-#endif
-#if defined(__DEFENSE_WAVE__)
-				|| ch->GetDefenseWave()
-#endif
-				)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ¥¯¡Ø≥ªø°º≠¥¬ ∆ƒ∆º∏¶ ≥™∞• ºˆ æ¯Ω¿¥œ¥Ÿ."));
-			}
-			else
-			{
-#ifdef ENABLE_QUEEN_NETHIS
-				if (SnakeLair::CSnk::instance().IsSnakeMap(ch->GetMapIndex()))
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ¥¯¡Ø≥ªø°º≠¥¬ ∆ƒ∆ºø¯¿ª √ﬂπÊ«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-					return;
-				}
-#endif
-				if (pParty->GetMemberCount() == 2)
-				{
-					// party disband
-					CPartyManager::instance().DeleteParty(pParty);
-				}
-				else
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ∆ƒ∆ºø°º≠ ≥™∞°ºÃΩ¿¥œ¥Ÿ."));
-					//pParty->SendPartyRemoveOneToAll(ch);
-					pParty->Quit(ch->GetPlayerID());
-					//pParty->SendPartyRemoveAllToOne(ch);
-					//CPartyManager::instance().SetPartyMember(ch->GetPlayerID(), NULL);
-				}
-			}
-		}
-		else
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ¥Ÿ∏• ∆ƒ∆ºø¯¿ª ≈ª≈Ω√≈≥ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		}
-	}
-}
-
-void CInputMain::AnswerMakeGuild(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGAnswerMakeGuild* p = (TPacketCGAnswerMakeGuild*)c_pData;
-
-	if (ch->GetGold() < 200000)
-		return;
-
-	if (ch->GetLevel() < 40)
-		return;
-
-	if (get_global_time() - ch->GetQuestFlag("guild_manage.new_disband_time") <
-		CGuildManager::instance().GetDisbandDelay())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> «ÿªÍ«— »ƒ %d¿œ ¿Ã≥ªø°¥¬ ±ÊµÂ∏¶ ∏∏µÈ ºˆ æ¯Ω¿¥œ¥Ÿ.",
-			quest::CQuestManager::instance().GetEventFlag("guild_disband_delay")));
-		return;
-	}
-
-	if (get_global_time() - ch->GetQuestFlag("guild_manage.new_withdraw_time") <
-		CGuildManager::instance().GetWithdrawDelay())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ≈ª≈«— »ƒ %d¿œ ¿Ã≥ªø°¥¬ ±ÊµÂ∏¶ ∏∏µÈ ºˆ æ¯Ω¿¥œ¥Ÿ.",
-			quest::CQuestManager::instance().GetEventFlag("guild_withdraw_delay")));
-		return;
-	}
-
-	if (ch->GetGuild())
-		return;
-
-	CGuildManager& gm = CGuildManager::instance();
-
-	TGuildCreateParameter cp;
-	memset(&cp, 0, sizeof(cp));
-
-	cp.master = ch;
-	strlcpy(cp.name, p->guild_name, sizeof(cp.name));
-
-	if (cp.name[0] == 0 || !check_name(cp.name))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¿˚«’«œ¡ˆ æ ¿∫ ±ÊµÂ ¿Ã∏ß ¿‘¥œ¥Ÿ."));
-		return;
-	}
-
-	DWORD dwGuildID = gm.CreateGuild(cp);
-
-	if (dwGuildID)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> [%s] ±ÊµÂ∞° ª˝º∫µ«æ˙Ω¿¥œ¥Ÿ.", cp.name));
-
-		int GuildCreateFee;
-
-		if (LC_IsBrazil())
-		{
-			GuildCreateFee = 500000;
-		}
-		else
-		{
-			GuildCreateFee = 200000;
-		}
-
-		ch->PointChange(POINT_GOLD, -GuildCreateFee);
-		DBManager::instance().SendMoneyLog(MONEY_LOG_GUILD, ch->GetPlayerID(), -GuildCreateFee);
-
-		char Log[128];
-		snprintf(Log, sizeof(Log), "GUILD_NAME %s MASTER %s", cp.name, ch->GetName());
-		LogManager::instance().CharLog(ch, 0, "MAKE_GUILD", Log);
-
-		if (g_iUseLocale)
-			ch->RemoveSpecifyItem(GUILD_CREATE_ITEM_VNUM, 1);
-		//ch->SendGuildName(dwGuildID);
-
-#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
-		CGuildManager::Instance().RequestSetEventFlag(dwGuildID, "create_time", get_global_time());
-#endif
-	}
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±ÊµÂ ª˝º∫ø° Ω«∆–«œø¥Ω¿¥œ¥Ÿ."));
-}
-
-void CInputMain::PartyUseSkill(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGPartyUseSkill* p = (TPacketCGPartyUseSkill*)c_pData;
-	if (!ch->GetParty())
-		return;
-
-	if (ch->GetPlayerID() != ch->GetParty()->GetLeaderPID())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> ∆ƒ∆º ±‚º˙¿∫ ∆ƒ∆º¿Â∏∏ ªÁøÎ«“ ºˆ ¿÷Ω¿¥œ¥Ÿ."));
-		return;
-	}
-
-	switch (p->bySkillIndex)
-	{
-		case PARTY_SKILL_HEAL:
-			ch->GetParty()->HealParty();
-			break;
-		case PARTY_SKILL_WARP:
-		{
-			LPCHARACTER pch = CHARACTER_MANAGER::instance().Find(p->vid);
-			if (pch && pch->IsPC())
-				ch->GetParty()->SummonToLeader(pch->GetPlayerID());
-			else
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆ƒ∆º> º“»Ø«œ∑¡¥¬ ¥ÎªÛ¿ª √£¿ª ºˆ æ¯Ω¿¥œ¥Ÿ."));
-		}
-		break;
-	}
-}
-
-void CInputMain::PartyParameter(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGPartyParameter* p = (TPacketCGPartyParameter*)c_pData;
-
-	if (ch->GetParty() && ch->GetParty()->GetLeaderPID() == ch->GetPlayerID())
-		ch->GetParty()->SetParameter(p->bDistributeMode);
-}
-
-size_t GetSubPacketSize(const GUILD_SUBHEADER_CG& header)
-{
-	switch (header)
-	{
-		case GUILD_SUBHEADER_CG_DEPOSIT_MONEY: return sizeof(int);
-		case GUILD_SUBHEADER_CG_WITHDRAW_MONEY: return sizeof(int);
-		case GUILD_SUBHEADER_CG_ADD_MEMBER: return sizeof(DWORD);
-		case GUILD_SUBHEADER_CG_REMOVE_MEMBER: return sizeof(DWORD);
-		case GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME: return 10;
-		case GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY: return sizeof(BYTE) + sizeof(BYTE);
-		case GUILD_SUBHEADER_CG_OFFER: return sizeof(DWORD);
-		case GUILD_SUBHEADER_CG_CHARGE_GSP: return sizeof(int);
-		case GUILD_SUBHEADER_CG_POST_COMMENT: return 1;
-		case GUILD_SUBHEADER_CG_DELETE_COMMENT: return sizeof(DWORD);
-		case GUILD_SUBHEADER_CG_REFRESH_COMMENT: return 0;
-		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE: return sizeof(DWORD) + sizeof(BYTE);
-		case GUILD_SUBHEADER_CG_USE_SKILL: return sizeof(TPacketCGGuildUseSkill);
-		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL: return sizeof(DWORD) + sizeof(BYTE);
-		case GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER: return sizeof(DWORD) + sizeof(BYTE);
-	}
-
-	return 0;
-}
-
-int CInputMain::Guild(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	if (uiBytes < sizeof(TPacketCGGuild))
-		return -1;
-
-	const TPacketCGGuild* p = reinterpret_cast<const TPacketCGGuild*>(data);
-	const char* c_pData = data + sizeof(TPacketCGGuild);
-
-	uiBytes -= sizeof(TPacketCGGuild);
-
-	const GUILD_SUBHEADER_CG SubHeader = static_cast<GUILD_SUBHEADER_CG>(p->subheader);
-	const size_t SubPacketLen = GetSubPacketSize(SubHeader);
-
-	if (uiBytes < SubPacketLen)
-	{
-		return -1;
-	}
-
-	CGuild* pGuild = ch->GetGuild();
-
-	if (NULL == pGuild)
-	{
-		if (SubHeader != GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER)
-		{
-			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±ÊµÂø° º”«ÿ¿÷¡ˆ æ Ω¿¥œ¥Ÿ."));
-			return SubPacketLen;
-		}
-	}
-
-	switch (SubHeader)
-	{
-		case GUILD_SUBHEADER_CG_DEPOSIT_MONEY:
-		{
-			// by mhh : ±ÊµÂ¿⁄±›¿∫ ¥Á∫–∞£ ≥÷¿ª ºˆ æ¯¥Ÿ.
-			return SubPacketLen;
-
-			const int gold = MIN(*reinterpret_cast<const int*>(c_pData), __deposit_limit());
-
-			if (gold < 0)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ¿ﬂ∏¯µ» ±›æ◊¿‘¥œ¥Ÿ."));
-				return SubPacketLen;
-			}
-
-			if (ch->GetGold() < gold)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ∞°¡ˆ∞Ì ¿÷¥¬ µ∑¿Ã ∫Œ¡∑«’¥œ¥Ÿ."));
-				return SubPacketLen;
-			}
-
-			pGuild->RequestDepositMoney(ch, gold);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_WITHDRAW_MONEY:
-		{
-			// by mhh : ±ÊµÂ¿⁄±›¿∫ ¥Á∫–∞£ ª¨ ºˆ æ¯¥Ÿ.
-			return SubPacketLen;
-
-			const int gold = MIN(*reinterpret_cast<const int*>(c_pData), 500000);
-
-			if (gold < 0)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ¿ﬂ∏¯µ» ±›æ◊¿‘¥œ¥Ÿ."));
-				return SubPacketLen;
-			}
-
-			pGuild->RequestWithdrawMoney(ch, gold);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_ADD_MEMBER:
-		{
-			const DWORD vid = *reinterpret_cast<const DWORD*>(c_pData);
-			LPCHARACTER newmember = CHARACTER_MANAGER::instance().Find(vid);
-
-			if (!newmember)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±◊∑Ø«— ªÁ∂˜¿ª √£¿ª ºˆ æ¯Ω¿¥œ¥Ÿ."));
-				return SubPacketLen;
-			}
-
-			if (!ch->IsPC() || !newmember->IsPC())
-				return SubPacketLen;
-
-#if defined(__MESSENGER_BLOCK_SYSTEM__)
-			if (CMessengerManager::instance().IsBlocked(ch->GetName(), newmember->GetName()))
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", newmember->GetName()));
-				return SubPacketLen;
-			}
-			else if (CMessengerManager::instance().IsBlocked(newmember->GetName(), ch->GetName()))
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", newmember->GetName()));
-				return SubPacketLen;
-			}
-#endif
-
-			if (newmember->GetQuestFlag("change_guild_master.be_other_member") > get_global_time())
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> æ∆¡˜ ∞°¿‘«“ ºˆ æ¯¥¬ ƒ≥∏Ø≈Õ¿‘¥œ¥Ÿ"));
-				return SubPacketLen;
-			}
-
-			pGuild->Invite(ch, newmember);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_REMOVE_MEMBER:
-		{
-			if (pGuild->UnderAnyWar() != 0)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±ÊµÂ¿¸ ¡ﬂø°¥¬ ±ÊµÂø¯¿ª ≈ª≈Ω√≈≥ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-				return SubPacketLen;
-			}
-
-			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			LPCHARACTER member = CHARACTER_MANAGER::instance().FindByPID(pid);
-
-			if (member)
-			{
-				if (member->GetGuild() != pGuild)
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ªÛ¥ÎπÊ¿Ã ∞∞¿∫ ±ÊµÂ∞° æ∆¥’¥œ¥Ÿ."));
-					return SubPacketLen;
-				}
-
-				if (!pGuild->HasGradeAuth(m->grade, GUILD_AUTH_REMOVE_MEMBER))
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±ÊµÂø¯¿ª ∞≠¡¶ ≈ª≈ Ω√≈≥ ±««—¿Ã æ¯Ω¿¥œ¥Ÿ."));
-					return SubPacketLen;
-				}
-
-				member->SetQuestFlag("guild_manage.new_withdraw_time", get_global_time());
-				pGuild->RequestRemoveMember(member->GetPlayerID());
-
-				if (LC_IsBrazil() == true)
-				{
-					DBManager::instance().Query("REPLACE INTO guild_invite_limit VALUES(%d, %d)", pGuild->GetID(), get_global_time());
-				}
-			}
-			else
-			{
-				if (!pGuild->HasGradeAuth(m->grade, GUILD_AUTH_REMOVE_MEMBER))
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±ÊµÂø¯¿ª ∞≠¡¶ ≈ª≈ Ω√≈≥ ±««—¿Ã æ¯Ω¿¥œ¥Ÿ."));
-					return SubPacketLen;
-				}
-
-				if (pGuild->RequestRemoveMember(pid))
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±ÊµÂø¯¿ª ∞≠¡¶ ≈ª≈ Ω√ƒ◊Ω¿¥œ¥Ÿ."));
-				else
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±◊∑Ø«— ªÁ∂˜¿ª √£¿ª ºˆ æ¯Ω¿¥œ¥Ÿ."));
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME:
-		{
-			char gradename[GUILD_GRADE_NAME_MAX_LEN + 1];
-			strlcpy(gradename, c_pData + 1, sizeof(gradename));
-
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			if (m->grade != GUILD_LEADER_GRADE)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ¡˜¿ß ¿Ã∏ß¿ª ∫Ø∞Ê«“ ±««—¿Ã æ¯Ω¿¥œ¥Ÿ."));
-			}
-			else if (*c_pData == GUILD_LEADER_GRADE)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±ÊµÂ¿Â¿« ¡˜¿ß ¿Ã∏ß¿∫ ∫Ø∞Ê«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-			}
-			else if (!check_name(gradename))
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ¿˚«’«œ¡ˆ æ ¿∫ ¡˜¿ß ¿Ã∏ß ¿‘¥œ¥Ÿ."));
-			}
-			else
-			{
-				pGuild->ChangeGradeName(*c_pData, gradename);
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY:
-		{
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			if (m->grade != GUILD_LEADER_GRADE)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ¡˜¿ß ±««—¿ª ∫Ø∞Ê«“ ±««—¿Ã æ¯Ω¿¥œ¥Ÿ."));
-			}
-			else if (*c_pData == GUILD_LEADER_GRADE)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±ÊµÂ¿Â¿« ±««—¿∫ ∫Ø∞Ê«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-			}
-			else
-			{
-				pGuild->ChangeGradeAuth(*c_pData, *(c_pData + 1));
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_OFFER:
-		{
-			DWORD offer = *reinterpret_cast<const DWORD*>(c_pData);
-
-			if (pGuild->GetLevel() >= GUILD_MAX_LEVEL && LC_IsHongKong() == false)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±ÊµÂ∞° ¿ÃπÃ √÷∞Ì ∑π∫ß¿‘¥œ¥Ÿ."));
-			}
-			else
-			{
-				offer /= 100;
-				offer *= 100;
-
-				if (pGuild->OfferExp(ch, offer))
-				{
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-					ch->UpdateExtBattlePassMissionProgress(GUILD_SPENT_EXP, offer, 0);
-#endif
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> %u¿« ∞Ê«Ëƒ°∏¶ ≈ı¿⁄«œø¥Ω¿¥œ¥Ÿ.", offer));
-				}
-				else
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ∞Ê«Ëƒ° ≈ı¿⁄ø° Ω«∆–«œø¥Ω¿¥œ¥Ÿ."));
-				}
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_CHARGE_GSP:
-		{
-			const int offer = *reinterpret_cast<const int*>(c_pData);
-			const int gold = offer * 100;
-
-			if (offer < 0 || gold < offer || gold < 0 || ch->GetGold() < gold)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> µ∑¿Ã ∫Œ¡∑«’¥œ¥Ÿ."));
-				return SubPacketLen;
-			}
-
-			if (!pGuild->ChargeSP(ch, offer))
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> øÎΩ≈∑¬ »∏∫πø° Ω«∆–«œø¥Ω¿¥œ¥Ÿ."));
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_POST_COMMENT:
-		{
-			const size_t length = *c_pData;
-
-			if (length > GUILD_COMMENT_MAX_LEN)
-			{
-				// ¿ﬂ∏¯µ» ±Ê¿Ã.. ≤˜æÓ¡÷¿⁄.
-				sys_err("POST_COMMENT: %s comment too long (length: %u)", ch->GetName(), length);
-				ch->GetDesc()->SetPhase(PHASE_CLOSE);
-				return -1;
-			}
-
-			if (uiBytes < 1 + length)
-				return -1;
-
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			if (length && !pGuild->HasGradeAuth(m->grade, GUILD_AUTH_NOTICE) && *(c_pData + 1) == '!')
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ∞¯¡ˆ±€¿ª ¿€º∫«“ ±««—¿Ã æ¯Ω¿¥œ¥Ÿ."));
-			}
-			else
-			{
-				std::string str(c_pData + 1, length);
-				pGuild->AddComment(ch, str);
-			}
-
-			return (1 + length);
-		}
-
-		case GUILD_SUBHEADER_CG_DELETE_COMMENT:
-		{
-			const DWORD comment_id = *reinterpret_cast<const DWORD*>(c_pData);
-
-			pGuild->DeleteComment(ch, comment_id);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_REFRESH_COMMENT:
-			pGuild->RefreshComment(ch);
-			return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE:
-		{
-			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
-			const BYTE grade = *(c_pData + sizeof(DWORD));
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			if (m->grade != GUILD_LEADER_GRADE)
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ¡˜¿ß∏¶ ∫Ø∞Ê«“ ±««—¿Ã æ¯Ω¿¥œ¥Ÿ."));
-			else if (ch->GetPlayerID() == pid)
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±ÊµÂ¿Â¿« ¡˜¿ß¥¬ ∫Ø∞Ê«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-			else if (grade == 1)
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ±ÊµÂ¿Â¿∏∑Œ ¡˜¿ß∏¶ ∫Ø∞Ê«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-			else
-				pGuild->ChangeMemberGrade(pid, grade);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_USE_SKILL:
-		{
-			const TPacketCGGuildUseSkill* p = reinterpret_cast<const TPacketCGGuildUseSkill*>(c_pData);
-
-			pGuild->UseSkill(p->dwVnum, ch, p->dwPID);
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL:
-		{
-			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
-			const BYTE is_general = *(c_pData + sizeof(DWORD));
-			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
-
-			if (NULL == m)
-				return -1;
-
-			if (m->grade != GUILD_LEADER_GRADE)
-			{
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ¿Â±∫¿ª ¡ˆ¡§«“ ±««—¿Ã æ¯Ω¿¥œ¥Ÿ."));
-			}
-			else
-			{
-				if (!pGuild->ChangeMemberGeneral(pid, is_general))
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<±ÊµÂ> ¥ı¿ÃªÛ ¿Âºˆ∏¶ ¡ˆ¡§«“ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-				}
-			}
-		}
-		return SubPacketLen;
-
-		case GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER:
-		{
-			const DWORD guild_id = *reinterpret_cast<const DWORD*>(c_pData);
-			const BYTE accept = *(c_pData + sizeof(DWORD));
-
-			CGuild* g = CGuildManager::instance().FindGuild(guild_id);
-
-			if (g)
-			{
-				if (accept)
-					g->InviteAccept(ch);
-				else
-					g->InviteDeny(ch->GetPlayerID());
-			}
-		}
-		return SubPacketLen;
-
-	}
-
-	return 0;
-}
-
-void CInputMain::Fishing(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGFishing* p = (TPacketCGFishing*)c_pData;
-	ch->SetRotation(p->dir * 5);
-	ch->fishing();
-	return;
-}
-
-#if defined(__FISHING_GAME__)
-#include "fishing.h"
-void CInputMain::FishingGame(const LPCHARACTER c_lpChar, const char* c_pszData)
-{
-	const TPacketCGFishingGame* c_pData = reinterpret_cast<const TPacketCGFishingGame*>(c_pszData);
-	if (c_pData == nullptr || c_lpChar == nullptr)
-		return;
-
-	const LPITEM c_lpFishingRod = c_lpChar->GetWear(WEAR_WEAPON);
-	if (c_lpFishingRod && c_lpFishingRod->GetType() == ITEM_ROD)
-	{
-		if (c_lpChar->m_pkFishingEvent)
-		{
-			switch (c_pData->bSubHeader)
-			{
-				case FISHING_GAME_SUBHEADER_GOAL:
-				{
-					c_lpChar->SetFishingGameGoals(c_pData->bGoals);
-					if (c_lpChar->GetFishingGameGoals() >= 3)
-						c_lpChar->fishing();
-				}
-				break;
-
-				case FISHING_GAME_SUBHEADER_QUIT:
-				{
-					event_cancel(&c_lpChar->m_pkFishingEvent);
-					c_lpFishingRod->SetSocket(2, 0);
-					fishing::FishingFail(c_lpChar);
-				}
-				break;
-			};
-		}
-	}
-}
-#endif
-
-void CInputMain::ItemGive(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGGiveItem* p = (TPacketCGGiveItem*)c_pData;
-	LPCHARACTER to_ch = CHARACTER_MANAGER::instance().Find(p->dwTargetVID);
-
-	if (to_ch)
-		ch->GiveItem(to_ch, p->ItemPos);
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("æ∆¿Ã≈€¿ª ∞«≥◊¡Ÿ ºˆ æ¯Ω¿¥œ¥Ÿ."));
-}
-
-void CInputMain::Hack(LPCHARACTER ch, const char* c_pData)
-{
-	TPacketCGHack* p = (TPacketCGHack*)c_pData;
-
-	char buf[sizeof(p->szBuf)];
-	strlcpy(buf, p->szBuf, sizeof(buf));
-
-	sys_err("HACK_DETECT: %s %s", ch->GetName(), buf);
-
-	// «ˆ¿Á ≈¨∂Û¿Ãæ∆Æø°º≠ ¿Ã ∆–≈∂¿ª ∫∏≥ª¥¬ ∞ÊøÏ∞° æ¯¿∏π«∑Œ π´¡∂∞« ≤˜µµ∑œ «—¥Ÿ
-	ch->GetDesc()->SetPhase(PHASE_CLOSE);
-}
-
-#if defined(__MYSHOP_DECO__)
-void CInputMain::MyShopDecoState(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGMyShopDecoState* p = (TPacketCGMyShopDecoState*)c_pData;
-	ch->SetMyShopDecoState(p->bState);
-}
-
-void CInputMain::MyShopDecoAdd(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGMyShopDecoAdd* p = (TPacketCGMyShopDecoAdd*)c_pData;
-	if (ch->GetMyShopDecoState())
-	{
-		if (p->dwPolyVnum < 30000 && p->dwPolyVnum > 30008)
-		{
-			sys_err("MyShopDecoAdd : Unknown PolyVnum");
-			return;
-		}
-
-		ch->SetMyShopDecoType(p->bType);
-		ch->SetMyShopDecoPolyVnum(p->dwPolyVnum);
-
-#if defined(__MYSHOP_EXPANSION__)
-		//ch->OpenPrivateShop(2, true);
-		// NOTE : Ideally, the Kashmir Bundle should have the same benefits as the Silk Bundle.
-		ch->UseSilkBotary();
-#else
-		ch->OpenPrivateShop(1, true);
-#endif
-	}
-	else
-	{
-		sys_err("MyShopDecoAdd : Unknown State");
-		return;
-	}
-}
-#endif
-
-int CInputMain::MyShop(LPCHARACTER ch, const char* c_pData, size_t uiBytes)
-{
-	const TPacketCGMyShop* p = (TPacketCGMyShop*)c_pData;
-	const int iExtraLen = p->bCount * sizeof(TShopItemTable);
-
-	if (uiBytes < sizeof(TPacketCGMyShop) + iExtraLen)
-		return -1;
-
-	if (ch->GetGold() >= GOLD_MAX)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("º“¿Ø µ∑¿Ã 20æÔ≥…¿ª ≥—æÓ ∞≈∑°∏¶ «€ºˆ∞° æ¯Ω¿¥œ¥Ÿ."));
-		sys_log(0, "MyShop ==> OverFlow Gold id %u name %s ", ch->GetPlayerID(), ch->GetName());
-		return (iExtraLen);
-	}
-
-#if defined(__CHEQUE_SYSTEM__)
-	if (ch->GetCheque() > CHEQUE_MAX)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("º“¿Ø µ∑¿Ã 20æÔ≥…¿ª ≥—æÓ ∞≈∑°∏¶ «€ºˆ∞° æ¯Ω¿¥œ¥Ÿ."));
-		sys_log(0, "MyShop ==> OverFlow Cheque id %u name %s ", ch->GetPlayerID(), ch->GetName());
-		return (iExtraLen);
-	}
-#endif
-
-	if (ch->IsStun() || ch->IsDead())
-		return (iExtraLen);
-
-	if (ch->PreventTradeWindow(WND_MYSHOP, true/*except*/))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("¥Ÿ∏• ∞≈∑°¡ﬂ¿œ∞ÊøÏ ∞≥¿ŒªÛ¡°¿ª ø≠ºˆ∞° æ¯Ω¿¥œ¥Ÿ."));
-		return (iExtraLen);
-	}
-
-	sys_log(0, "MyShop count %u", p->bCount);
-	ch->OpenMyShop(p->szSign, (TShopItemTable*)(c_pData + sizeof(TPacketCGMyShop)), p->bCount);
-	return (iExtraLen);
-}
-
-void CInputMain::Refine(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGRefine* p = reinterpret_cast<const TPacketCGRefine*>(c_pData);
-
-	if (ch->PreventTradeWindow(WND_REFINE, true/*except*/))
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√¢∞Ì,∞≈∑°√¢µÓ¿Ã ø≠∏∞ ªÛ≈¬ø°º≠¥¬ ∞≥∑Æ¿ª «“ºˆ∞° æ¯Ω¿¥œ¥Ÿ"));
-		ch->ClearRefineMode();
-		return;
-	}
-
-	if (p->type == 255)
-	{
-		// DoRefine Cancel
-		ch->ClearRefineMode();
-		return;
-	}
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-	if (p->pos >= ch->GetExtendInvenMax())
-#else
-	if (p->pos >= INVENTORY_MAX_NUM)
-#endif
-	{
-		ch->ClearRefineMode();
-		return;
-	}
-
-	LPITEM item = ch->GetInventoryItem(p->pos);
-	if (!item)
-	{
-		ch->ClearRefineMode();
-		return;
-	}
-
-	ch->SetRefineTime();
-
-	if (p->type == REFINE_TYPE_NORMAL)
-	{
-		sys_log(0, "refine_type_noraml");
-		ch->DoRefine(item);
-	}
-	else if (p->type == REFINE_TYPE_SCROLL
-		|| p->type == REFINE_TYPE_NOT_USED1
-		|| p->type == REFINE_TYPE_HYUNIRON
-		|| p->type == REFINE_TYPE_MUSIN
-		|| p->type == REFINE_TYPE_BDRAGON
-#if defined(__STONE_OF_BLESS__)
-		|| p->type == REFINE_TYPE_BLESSING_STONE
-#endif
-		)
-	{
-		sys_log(0, "refine_type_scroll, ...");
-		ch->DoRefineWithScroll(item);
-	}
-#if defined(__SOUL_SYSTEM__)
-	else if (p->type == REFINE_TYPE_SOUL_AWAKE || p->type == REFINE_TYPE_SOUL_EVOLVE)
-	{
-		ch->DoRefineSoul(item);
-	}
-#endif
-	else if (p->type == REFINE_TYPE_MONEY_ONLY)
-	{
-		const LPITEM item = ch->GetInventoryItem(p->pos);
-
-		if (NULL != item)
-		{
-			if (500 <= item->GetRefineSet())
-			{
-				LogManager::instance().HackLog("DEVIL_TOWER_REFINE_HACK", ch);
-			}
-			else
-			{
-				if (ch->GetQuestFlag("deviltower_zone.can_refine"))
-				{
-					ch->DoRefine(item, true);
-					ch->SetQuestFlag("deviltower_zone.can_refine", 0);
-				}
-				else
-				{
-					ch->ChatPacket(CHAT_TYPE_INFO, "ªÁ±Õ ≈∏øˆ øœ∑· ∫∏ªÛ¿∫ «—π¯±Ó¡ˆ ªÁøÎ∞°¥…«’¥œ¥Ÿ.");
-				}
-			}
-		}
-	}
-
-	ch->ClearRefineMode();
-}
-
-#if defined(__CUBE_RENEWAL__)
-void CInputMain::Cube(const LPCHARACTER pChar, const char* pData)
-{
-	const TPacketCGCube* pPacket = reinterpret_cast<const TPacketCGCube*>(pData);
-	if (pPacket == nullptr)
-		return;
-
-	const DWORD dwFileCrc = CCubeManager::Instance().GetFileCrc();
-	if (pPacket->dwFileCrc != dwFileCrc)
-	{
-		const char* szSubHeader[] = {
-			{ "SUBHEADER_CG_CUBE_CLOSE" },
-			{ "SUBHEADER_CG_CUBE_MAKE" },
-		};
-
-		if (test_server)
-			pChar->ChatPacket(CHAT_TYPE_INFO, "cube crc mismatch: %u != %u",
-				pPacket->dwFileCrc, dwFileCrc);
-
-		sys_log(0, "cube: recv %s ch %s file crc mismatch: %u != %u",
-			szSubHeader[pPacket->bSubHeader], pChar->GetName(),
-			pPacket->dwFileCrc, dwFileCrc);
-
-		LogManager::instance().CharLog(pChar, 0, "CUBE FILE MISMATCH", "");
-		CCubeManager::Instance().CloseCube(pChar);
-	}
-
-	if (pChar->PreventTradeWindow(WND_CUBE, true/*except*/))
-	{
-		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√¢∞Ì,∞≈∑°√¢µÓ¿Ã ø≠∏∞ ªÛ≈¬ø°º≠¥¬ ∞≥∑Æ¿ª «“ºˆ∞° æ¯Ω¿¥œ¥Ÿ"));
-		return;
-	}
-
-	switch (pPacket->bSubHeader)
-	{
-		case SUBHEADER_CG_CUBE_CLOSE:
-			CCubeManager::Instance().CloseCube(pChar);
-			break;
-
-		case SUBHEADER_CG_CUBE_MAKE:
-			CCubeManager::Instance().MakeCube(pChar, pPacket->iCubeIndex, pPacket->iQuantity, pPacket->iImproveItemPos);
-			break;
-	}
-}
-#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-void CInputMain::ItemCombination(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGItemCombination* p = reinterpret_cast<const TPacketCGItemCombination*>(c_pData);
-
-	ch->ItemCombination(p->MediumIndex, p->BaseIndex, p->MaterialIndex);
-}
-
-void CInputMain::ItemCombinationCancel(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGItemCombinationCancel* p = reinterpret_cast<const TPacketCGItemCombinationCancel*>(c_pData);
-
-	ch->SetItemCombNpc(NULL);
-}
-#endif
-
-#if defined(__CHANGED_ATTR__)
-void CInputMain::ItemSelectAttr(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGItemSelectAttr* p = reinterpret_cast<const TPacketCGItemSelectAttr*>(c_pData);
-
-	ch->SelectAttrResult(p->bNew, p->pItemPos);
-}
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-static size_t GetAcceSubPacketLength(const ESubHeaderCGAcceRefine& eSubHeader)
-{
-	switch (eSubHeader)
-	{
-		case ACCE_REFINE_SUBHEADER_CG_CHECKIN:
-			return sizeof(TSubPacketCGAcceRefineCheckIn);
-		case ACCE_REFINE_SUBHEADER_CG_CHECKOUT:
-			return sizeof(TSubPacketCGAcceRefineCheckOut);
-		case ACCE_REFINE_SUBHEADER_CG_ACCEPT:
-			return sizeof(TSubPacketCGAcceRefineAccept);
-		case ACCE_REFINE_SUBHEADER_CG_CANCEL:
-			return 0;
-	}
-	return 0;
-}
-
-int CInputMain::AcceRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes)
-{
-	if (uiBytes < sizeof(TPacketCGAcceRefine))
-		return -1;
-
-	const TPacketCGAcceRefine* pPacket = reinterpret_cast<const TPacketCGAcceRefine*>(pszData);
-	const char* pszDataPacket = pszData + sizeof(TPacketCGAcceRefine);
-
-	uiBytes -= sizeof(TPacketCGAcceRefine);
-
-	const ESubHeaderCGAcceRefine eSubHeader = static_cast<ESubHeaderCGAcceRefine>(pPacket->bSubHeader);
-	const size_t uiSubPacketLength = GetAcceSubPacketLength(eSubHeader);
-	if (uiBytes < uiSubPacketLength)
-	{
-		sys_err("Invalid AcceRefine SubPacket length (SubPacketLength %d Size %u Buffer %u)", uiSubPacketLength, sizeof(TPacketCGAcceRefine), uiBytes);
-		return -1;
-	}
-
-	switch (eSubHeader)
-	{
-		case ACCE_REFINE_SUBHEADER_CG_CHECKIN:
-		{
-			const TSubPacketCGAcceRefineCheckIn* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineCheckIn*>(pszDataPacket);
-			pChar->AcceRefineWindowCheckIn(pSubPacket->bType, pSubPacket->SelectedPos, pSubPacket->AttachedPos);
-		}
-		return uiSubPacketLength;
-
-		case ACCE_REFINE_SUBHEADER_CG_CHECKOUT:
-		{
-			const TSubPacketCGAcceRefineCheckOut* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineCheckOut*>(pszDataPacket);
-			pChar->AcceRefineWindowCheckOut(pSubPacket->bType, pSubPacket->SelectedPos);
-		}
-		return uiSubPacketLength;
-
-		case ACCE_REFINE_SUBHEADER_CG_ACCEPT:
-		{
-			const TSubPacketCGAcceRefineAccept* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineAccept*>(pszDataPacket);
-			pChar->AcceRefineWindowAccept(pSubPacket->bType);
-		}
-		return uiSubPacketLength;
-
-		case ACCE_REFINE_SUBHEADER_CG_CANCEL:
-		{
-			pChar->AcceRefineWindowClose();
-		}
-		return uiSubPacketLength;
-	}
-
-	return 0;
-}
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-static size_t GetAuraSubPacketLength(const ESubHeaderCGAuraRefine& eSubHeader)
-{
-	switch (eSubHeader)
-	{
-		case AURA_REFINE_SUBHEADER_CG_CHECKIN:
-			return sizeof(TSubPacketCGAuraRefineCheckIn);
-		case AURA_REFINE_SUBHEADER_CG_CHECKOUT:
-			return sizeof(TSubPacketCGAuraRefineCheckOut);
-		case AURA_REFINE_SUBHEADER_CG_ACCEPT:
-			return sizeof(TSubPacketCGAuraRefineAccept);
-		case AURA_REFINE_SUBHEADER_CG_CANCEL:
-			return 0;
-	}
-	return 0;
-}
-
-int CInputMain::AuraRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes)
-{
-	if (uiBytes < sizeof(TPacketCGAuraRefine))
-		return -1;
-
-	const TPacketCGAuraRefine* pPacket = reinterpret_cast<const TPacketCGAuraRefine*>(pszData);
-	const char* pszDataPacket = pszData + sizeof(TPacketCGAuraRefine);
-
-	uiBytes -= sizeof(TPacketCGAuraRefine);
-
-	const ESubHeaderCGAuraRefine eSubHeader = static_cast<ESubHeaderCGAuraRefine>(pPacket->bSubHeader);
-	const size_t uiSubPacketLength = GetAuraSubPacketLength(eSubHeader);
-	if (uiBytes < uiSubPacketLength)
-	{
-		sys_err("Invalid AuraRefine SubPacket length (SubPacketLength %d Size %u Buffer %u)", uiSubPacketLength, sizeof(TPacketCGAuraRefine), uiBytes);
-		return -1;
-	}
-
-	switch (eSubHeader)
-	{
-		case AURA_REFINE_SUBHEADER_CG_CHECKIN:
-		{
-			const TSubPacketCGAuraRefineCheckIn* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineCheckIn*>(pszDataPacket);
-			pChar->AuraRefineWindowCheckIn(c_pSubPacket->bType, c_pSubPacket->SelectedPos, c_pSubPacket->AttachedPos);
-		}
-		return uiSubPacketLength;
-
-		case AURA_REFINE_SUBHEADER_CG_CHECKOUT:
-		{
-			const TSubPacketCGAuraRefineCheckOut* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineCheckOut*>(pszDataPacket);
-			pChar->AuraRefineWindowCheckOut(c_pSubPacket->bType, c_pSubPacket->SelectedPos);
-		}
-		return uiSubPacketLength;
-
-		case AURA_REFINE_SUBHEADER_CG_ACCEPT:
-		{
-			const TSubPacketCGAuraRefineAccept* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineAccept*>(pszDataPacket);
-			pChar->AuraRefineWindowAccept(c_pSubPacket->bType);
-		}
-		return uiSubPacketLength;
-
-		case AURA_REFINE_SUBHEADER_CG_CANCEL:
-		{
-			pChar->AuraRefineWindowClose();
-		}
-		return uiSubPacketLength;
-	}
-
-	return 0;
-}
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-void CInputMain::ChangeLook(LPCHARACTER lpCh, const char* c_pszData)
-{
-	const TPacketCGChangeLook* c_pData = reinterpret_cast<const TPacketCGChangeLook*>(c_pszData);
-
-	CChangeLook* pChangeLook = lpCh->GetChangeLook();
-	if (pChangeLook == nullptr)
-		return;
-
-	switch (static_cast<EPacketCGChangeLookSubHeader>(c_pData->bSubHeader))
-	{
-		case EPacketCGChangeLookSubHeader::ITEM_CHECK_IN:
-			pChangeLook->ItemCheckIn(c_pData->ItemPos, c_pData->bSlotIndex);
-			break;
-		case EPacketCGChangeLookSubHeader::ITEM_CHECK_OUT:
-			pChangeLook->ItemCheckOut(c_pData->bSlotIndex);
-			break;
-		case EPacketCGChangeLookSubHeader::FREE_ITEM_CHECK_IN:
-			pChangeLook->FreeItemCheckIn(c_pData->ItemPos);
-			break;
-		case EPacketCGChangeLookSubHeader::FREE_ITEM_CHECK_OUT:
-			pChangeLook->FreeItemCheckOut();
-			break;
-		case EPacketCGChangeLookSubHeader::ACCEPT:
-			pChangeLook->Accept();
-			break;
-		case EPacketCGChangeLookSubHeader::CANCEL:
-			lpCh->SetChangeLook(nullptr);
-			break;
-		default:
-			sys_err("Unknown Subheader ch:%s, %d", lpCh->GetName(), c_pData->bSubHeader);
-			return;
-	}
-}
-#endif
-
-#if defined(__SEND_TARGET_INFO__)
-void CInputMain::TargetInfo(LPCHARACTER pChar, const char* c_pszData)
-{
-	const TPacketCGTargetInfo* c_pData = reinterpret_cast<const TPacketCGTargetInfo*>(c_pszData);
-	const LPCHARACTER pkTarget = CHARACTER_MANAGER::instance().Find(c_pData->dwVID);
-	if (pChar == nullptr || pkTarget == nullptr)
-		return;
-
-	const DWORD dwVID = pkTarget->GetVID();
-	const DWORD dwRaceVnum = pkTarget->GetRaceNum();
-
-	if (pkTarget->IsMonster() || pkTarget->IsStone())
-	{
-		MonsterItemDropMap ItemDropMap; bool bDropMetinStone = false;
-		ITEM_MANAGER::instance().GetMonsterItemDropMap(pkTarget, pChar, ItemDropMap, bDropMetinStone);
-
-		TEMP_BUFFER TempBuffer;
-		for (const MonsterItemDropMap::value_type& it : ItemDropMap)
-		{
-			TPacketGCTargetDropInfo DropInfoPacket;
-			DropInfoPacket.dwVnum = it.first;
-			DropInfoPacket.bCount = it.second;
-			TempBuffer.write(&DropInfoPacket, sizeof(DropInfoPacket));
-		}
-
-		TPacketGCTargetInfo TargetInfoPacket;
-		TargetInfoPacket.bHeader = HEADER_GC_TARGET_INFO;
-		TargetInfoPacket.wSize = sizeof(TargetInfoPacket) + TempBuffer.size();
-		TargetInfoPacket.dwRaceVnum = dwRaceVnum;
-		TargetInfoPacket.dwVID = dwVID;
-		TargetInfoPacket.bDropMetinStone = bDropMetinStone;
-
-		if (TempBuffer.size())
-		{
-			pChar->GetDesc()->BufferedPacket(&TargetInfoPacket, sizeof(TargetInfoPacket));
-			pChar->GetDesc()->Packet(TempBuffer.read_peek(), TempBuffer.size());
-		}
-		else
-			pChar->GetDesc()->Packet(&TargetInfoPacket, sizeof(TargetInfoPacket));
-	}
-
-	pChar->ChatPacket(CHAT_TYPE_COMMAND, "RefreshMonsterDropInfo %d", pkTarget->GetRaceNum());
-}
-#endif
-
-#if defined(__SKILLBOOK_COMB_SYSTEM__)
-bool CInputMain::SkillBookCombination(LPCHARACTER ch, TItemPos(&CombItemGrid)[SKILLBOOK_COMB_SLOT_MAX], BYTE bAction)
-{
-	if (!ch->GetDesc())
-		return false;
-
-	// if (CombItemGrid.empty())
-		// return false;
-
-	if (ch->PreventTradeWindow(WND_ALL))
-		return false;
-
-	if (bAction != 2/*COMBI_START*/)
-		return false;
-
-	std::set <LPITEM> set_items;
-	for (int i = 0; i < SKILLBOOK_COMB_SLOT_MAX; i++)
-	{
-		LPITEM pItem = ch->GetItem(CombItemGrid[i]);
-		if (pItem)
-		{
-			if (pItem->GetType() != ITEM_SKILLBOOK)
-				return false;
-
-			set_items.insert(pItem);
-		}
-	}
-
-	if (set_items.empty())
-		return false;
-
-	if (ch->GetGold() < SKILLBOOK_COMB_COST)
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Yang to trade books with me."));
-		return false;
-	}
-
-	for (std::set <LPITEM>::iterator it = set_items.begin(); it != set_items.end(); ++it)
-	{
-		LPITEM pItem = *it;
-		if (pItem)
-		{
-			pItem->SetCount(pItem->GetCount() - 1);
-			//pItem->RemoveFromCharacter();
-			//M2_DESTROY_ITEM(pItem);
-		}
-	}
-
-	DWORD dwBooks[JOB_MAX_NUM][2/*SKILL_GROUPS*/][2] = {
-		{ // 0 - Warrior
-			{50401, 50406}, // Skill Group 1
-			{50416, 50421}, // Skill Group 2
-		},
-		{ // 1 - Ninja
-			{50431, 50436}, // Skill Group 1
-			{50446, 50451}, // Skill Group 2
-		},
-		{ // 2 - Sura
-			{50461, 50466}, // Skill Group 1
-			{50476, 50481}, // Skill Group 2
-		},
-		{ // 3 - Shaman
-			{50491, 50496}, // Skill Group 1
-			{50506, 50511}, // Skill Group 2
-		},
-		{ // 4 - Wolfman
-			{50530, 50535}, // Skill Group 1
-			{0, 0}, // Skill Group 2
-		},
-	};
-
-	ch->PointChange(POINT_GOLD, -SKILLBOOK_COMB_COST);
-
-	if (ch->GetSkillGroup() != 0)
-	{
-		DWORD dwMinRandomBook = dwBooks[ch->GetJob()][ch->GetSkillGroup() - 1][0];
-		DWORD dwMaxRandomBook = dwBooks[ch->GetJob()][ch->GetSkillGroup() - 1][1];
-
-		std::random_device rd;
-		std::mt19937 gen(rd());
-		std::uniform_real_distribution<> dis(dwMinRandomBook, dwMaxRandomBook);
-		DWORD dwRandomBook = dis(gen);
-
-		ch->AutoGiveItem(dwRandomBook, 1);
-	}
-	else
-		ch->AutoGiveItem(ITEM_SKILLBOOK_VNUM, 1);
-
-	return true;
-}
-#endif
-
-#if defined(__MAILBOX__)
-void CInputMain::MailboxWrite(LPCHARACTER ch, const char* c_pData)
-{
-	const auto* p = reinterpret_cast<const TPacketCGMailboxWrite*>(c_pData);
-	if (p == nullptr)
-		return;
-
-	CMailBox* mail = ch->GetMailBox();
-	if (mail == nullptr)
-		return;
-
-	mail->Write(p->szName, p->szTitle, p->szMessage, p->pos, p->iYang, p->iWon);
-}
-
-void CInputMain::MailboxConfirm(LPCHARACTER ch, const char* c_pData)
-{
-	const auto* p = reinterpret_cast<const TPacketCGMailboxWriteConfirm*>(c_pData);
-	if (p == nullptr)
-		return;
-
-	CMailBox* mail = ch->GetMailBox();
-	if (mail == nullptr)
-		return;
-
-	mail->CheckPlayer(p->szName);
-}
-
-void CInputMain::MailboxProcess(LPCHARACTER ch, const char* c_pData)
-{
-	const auto* p = reinterpret_cast<const TPacketMailboxProcess*>(c_pData);
-	if (p == nullptr)
-		return;
-
-	CMailBox* mail = ch->GetMailBox();
-	if (mail == nullptr)
-		return;
-
-	switch (p->bSubHeader)
-	{
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_CLOSE:
-			ch->SetMailBox(nullptr);
-			break;
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_DELETE:
-			mail->DeleteMail(p->bArg1, false);
-			break;
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_DELETE:
-			mail->DeleteAllMails();
-			break;
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_GET_ITEMS:
-			mail->GetItem(p->bArg1, false);
-			break;
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_GET_ITEMS:
-			mail->GetAllItems();
-			break;
-		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ADD_DATA:
-			mail->AddData(p->bArg1, p->bArg2);
-			break;
-		default:
-			sys_err("CInputMain::MailboxProcess Unknown SubHeader (ch: %s) (%d)", ch->GetName(), p->bSubHeader);
-			break;
-	}
-}
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-void CInputMain::MiniGameRumi(LPCHARACTER pChar, const char* pszData)
-{
-	const TPacketCGMiniGameRumi* pkData = reinterpret_cast<const TPacketCGMiniGameRumi*>(pszData);
-	if (pkData == nullptr)
-		return;
-
-	switch (pkData->bSubHeader)
-	{
-		case RUMI_CG_SUBHEADER_END:
-			CMiniGameRumi::EndGame(pChar);
-			break;
-
-		case RUMI_CG_SUBHEADER_START:
-			CMiniGameRumi::StartGame(pChar);
-			break;
-
-		case RUMI_CG_SUBHEADER_DECK_CARD_CLICK:
-		case RUMI_CG_SUBHEADER_HAND_CARD_CLICK:
-		case RUMI_CG_SUBHEADER_FIELD_CARD_CLICK:
-			CMiniGameRumi::Analyze(pChar, pkData->bSubHeader, pkData->bUseCard, pkData->bIndex);
-			break;
-
-#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
-		case RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG:
-			CMiniGameRumi::RequestQuestFlag(pChar, RUMI_GC_SUBHEADER_SET_QUEST_FLAG);
-			break;
-#endif
-
-		default:
-			sys_err("CInputMain::MiniGameRumi Unknown SubHeader (ch: %s) (%d)", pChar->GetName(), pkData->bSubHeader);
-			break;
-	}
-}
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__)
-void CInputMain::MiniGameYutnori(LPCHARACTER pChar, const char* pszData)
-{
-	const TPacketCGMiniGameYutnori* pkData = reinterpret_cast<const TPacketCGMiniGameYutnori*>(pszData);
-	if (pkData == nullptr)
-	{
-		sys_err("CInputMain::MiniGameYutnori - Null Data! (ch: %s)", pChar->GetName());
-		return;
-	}
-
-	switch (pkData->bSubHeader)
-	{
-		case YUTNORI_CG_SUBHEADER_START:
-			CMiniGameYutnori::Create(pChar);
-			break;
-
-		case YUTNORI_CG_SUBHEADER_GIVEUP:
-			CMiniGameYutnori::Destroy(pChar);
-			break;
-
-#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
-		case YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG:
-			CMiniGameYutnori::RequestQuestFlag(pChar, YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG);
-			break;
-#endif
-
-		default:
-			CMiniGameYutnori::Analyze(pChar, pkData->bSubHeader, pkData->bArgument);
-			break;
-	}
-}
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-void CInputMain::LootFilter(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGLootFilter* p = reinterpret_cast<const TPacketCGLootFilter*>(c_pData);
-	if (ch->GetLootFilter())
-		ch->GetLootFilter()->SetLootFilterSettings(p->settings);
-}
-#endif
-
-#if defined(__GEM_SHOP__)
-void CInputMain::GemShop(LPCHARACTER c_lpCh, const char* c_pszData)
-{
-	const TPacketCGGemShop* c_pPacket = reinterpret_cast<const TPacketCGGemShop*>(c_pszData);
-	if (c_pPacket == nullptr)
-		return;
-
-	CGemShop* pGemShop = c_lpCh->GetGemShop();
-	if (pGemShop == nullptr)
-		return;
-
-	switch (c_pPacket->bSubHeader)
-	{
-		case SUBHEADER_GEM_SHOP_CLOSE:
-			c_lpCh->SetGemShop(nullptr);
-			break;
-		case SUBHEADER_GEM_SHOP_BUY:
-			pGemShop->Buy(c_pPacket->bSlotIndex);
-			break;
-		case SUBHEADER_GEM_SHOP_SLOT_ADD:
-			pGemShop->AddSlot();
-			break;
-		case SUBHEADER_GEM_SHOP_REFRESH:
-			pGemShop->Refresh();
-			break;
-		default:
-			sys_err("CInputMain::GemShop Unknown SubHeader (ch: %s) (%d)", c_lpCh->GetName(), c_pPacket->bSubHeader);
-			break;
-	}
-}
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-void CInputMain::Attr67Add(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGAttr67Add* pkPacket = (TPacketCGAttr67Add*)c_pData;
-	switch (pkPacket->bySubHeader)
-	{
-		case SUBHEADER_CG_ATTR67_ADD_CLOSE:
-			ch->SetOpenAttr67Add(false);
-			break;
-		case SUBHEADER_CG_ATTR67_ADD_OPEN:
-			if (!ch->IsOpenAttr67Add())
-				ch->SetOpenAttr67Add(true);
-			break;
-		case SUBHEADER_CG_ATTR67_ADD_REGIST:
-			if (ch->IsOpenAttr67Add())
-				ch->Attr67Add(pkPacket->Attr67AddData);
-			break;
-		default:
-			return;
-	}
-}
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-void CInputMain::ExtendInven(LPCHARACTER pChar, const char* c_pszData)
-{
-	const TPacketCGExtendInven* pPacket = reinterpret_cast<const TPacketCGExtendInven*>(c_pszData);
-	if (pPacket == nullptr)
-		return;
-
-	if (pPacket->bUpgrade)
-		pChar->ExtendInvenUpgrade();
-	else
-		pChar->ExtendInvenRequest();
-}
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-void CInputMain::SnowflakeStickEvent(LPCHARACTER pChar, const char* c_pszData)
-{
-	const TPacketCGSnowflakeStickEvent* pPacket = reinterpret_cast<const TPacketCGSnowflakeStickEvent*>(c_pszData);
-	if (pPacket == nullptr)
-		return;
-
-	switch (pPacket->bSubHeader)
-	{
-		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_REQUEST_INFO:
-			CSnowflakeStickEvent::Process(pChar, SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO);
-			break;
-
-		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_STICK:
-		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_PET:
-		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_MOUNT:
-			CSnowflakeStickEvent::Exchange(pChar, pPacket->bSubHeader);
-			break;
-
-		default:
-			return;
-	}
-}
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-void CInputMain::RefineElement(LPCHARACTER pChar, const char* c_pszData)
-{
-	const TPacketCGRefineElement* pPacket = reinterpret_cast<const TPacketCGRefineElement*>(c_pszData);
-	if (pPacket == nullptr)
-		return;
-
-	switch (pPacket->bSubHeader)
-	{
-		case REFINE_ELEMENT_CG_CLOSE:
-			pChar->SetUnderRefineElement(false);
-			break;
-
-		case REFINE_ELEMENT_CG_REFINE:
-			pChar->RefineElement(pPacket->wChangeElement);
-			break;
-
-		default:
-			sys_err("CInputMain::RefineElement: %s received unknown sub header.", pChar->GetName());
-			break;
-	}
-}
-#endif
-
-#if defined(__LEFT_SEAT__)
-void CInputMain::LeftSeat(LPCHARACTER pChar, const char* c_pszData)
-{
-	const TPacketCGLeftSeat* c_pPacket = reinterpret_cast<const TPacketCGLeftSeat*>(c_pszData);
-	if (c_pPacket == nullptr)
-		return;
-
-	switch (c_pPacket->bSubHeader)
-	{
-		case LEFT_SEAT_SET_WAIT_TIME_INDEX:
-			pChar->SetLeftSeatWaitTime(c_pPacket->bIndex);
-			break;
-
-		case LEFT_SEAT_SET_LOGOUT_TIME_INDEX:
-			pChar->SetLeftSeatLogoutTime(c_pPacket->bIndex);
-			break;
-
-		case LEFT_SEAT_DISABLE_LOGOUT_STATE:
-			pChar->DisableLeftSeatLogOutState(false);
-			break;
-
-		default:
-			sys_err("CInputMain::LeftSeat: %s received unknown sub header.", pChar->GetName());
-			break;
-	}
-}
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-void CInputMain::MiniGameRoulette(LPCHARACTER pChar, const char* pszData)
-{
-	const TPacketCGMiniGameRoulette* pData = reinterpret_cast<const TPacketCGMiniGameRoulette*>(pszData);
-	if (pData == nullptr)
-	{
-		sys_err("CInputMain::MiniGameRoulette : Data NULL (ch: %s)", pChar->GetName());
-		return;
-	}
-
-	CMiniGameRoulette* pMiniGameRoulette = pChar->GetMiniGameRoulette();
-	if (pMiniGameRoulette == nullptr)
-	{
-		sys_err("CInputMain::MiniGameRoulette : MiniGameRoulette NULL (ch: %s)", pChar->GetName());
-		return;
-	}
-
-	switch (pData->bSubHeader)
-	{
-		case ROULETTE_CG_START:
-			pMiniGameRoulette->Start();
-			break;
-
-		case ROULETTE_CG_REQUEST:
-			pMiniGameRoulette->Request();
-			break;
-
-		case ROULETTE_CG_END:
-			pMiniGameRoulette->End();
-			break;
-
-		case ROULETTE_CG_CLOSE:
-			pMiniGameRoulette->Close();
-			break;
-
-		default:
-			sys_err("CInputMain::MiniGameRoulette : Unknown SubHeader %u (ch: %s)",
-				pData->bSubHeader, pChar->GetName());
-			break;
-	}
-}
-#endif
-
-#if defined(__FLOWER_EVENT__)
-void CInputMain::FlowerEvent(LPCHARACTER pChar, const char* pszData)
-{
-	if (!quest::CQuestManager::instance().GetEventFlag("e_flower_drop"))
-		return;
-
-	const TPacketCGFlowerEvent* pPacketData = reinterpret_cast<const TPacketCGFlowerEvent*>(pszData);
-	if (NULL == pPacketData)
-	{
-		sys_err("NULL TPacketCGFlowerEvent (ch: %s)", pChar->GetName());
-		return;
-	}
-
-	switch (pPacketData->bSubHeader)
-	{
-		case FLOWER_EVENT_SUBHEADER_CG_INFO_ALL:
-			CFlowerEvent::RequestAllInfo(pChar);
-			break;
-
-		case FLOWER_EVENT_SUBHEADER_CG_EXCHANGE:
-			CFlowerEvent::Exchange(pChar, pPacketData->bShootType, pPacketData->bExchangeKey);
-			break;
-
-		default:
-			sys_err("Unknown SubHeader %u (ch: %s)",
-				pPacketData->bSubHeader, pChar->GetName());
-			break;
-	}
-}
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-int CInputMain::ReciveExtBattlePassActions(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	TPacketCGExtBattlePassAction* p = (TPacketCGExtBattlePassAction*)data;
-
-	if (uiBytes < sizeof(TPacketCGExtBattlePassAction))
-		return -1;
-
-	const char* c_pData = data + sizeof(TPacketCGExtBattlePassAction);
-	uiBytes -= sizeof(TPacketCGExtBattlePassAction);
-
-	switch (p->bAction)
-	{
-		case 1:
-			CBattlePassManager::instance().BattlePassRequestOpen(ch);
-			return 0;
-
-		case 2:
-			if(get_dword_time() < ch->GetLastReciveExtBattlePassOpenRanking()) {
-				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NEXT_REFRESH_RANKLIST_TIME"), ((ch->GetLastReciveExtBattlePassOpenRanking() - get_dword_time()) / 1000) + 1 );
-				return 0;
-			}
-			ch->SetLastReciveExtBattlePassOpenRanking(get_dword_time() + 10000);
-			
-			for (BYTE bBattlePassType = 1; bBattlePassType <= 3 ; ++bBattlePassType)
-			{
-				BYTE bBattlePassID;
-				if (bBattlePassType == 1)
-					bBattlePassID = CBattlePassManager::instance().GetNormalBattlePassID();
-				if (bBattlePassType == 2){
-					bBattlePassID = CBattlePassManager::instance().GetPremiumBattlePassID();
-					if (bBattlePassID != ch->GetExtBattlePassPremiumID())
-						continue;
-				}
-				if (bBattlePassType == 3)
-					bBattlePassID = CBattlePassManager::instance().GetEventBattlePassID();
-
-				std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("SELECT player_name, battlepass_type+0, battlepass_id, UNIX_TIMESTAMP(start_time), UNIX_TIMESTAMP(end_time) FROM player.battlepass_playerindex WHERE battlepass_type = %d and battlepass_id = %d and battlepass_completed = 1 and not player_name LIKE '[%%' ORDER BY (UNIX_TIMESTAMP(end_time)-UNIX_TIMESTAMP(start_time)) ASC LIMIT 40", bBattlePassType, bBattlePassID));
-				if (pMsg->uiSQLErrno)
-					return 0;
-
-				MYSQL_ROW row;
-
-				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
-				{
-					TPacketGCExtBattlePassRanking pack;
-					pack.bHeader = HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING;
-					strlcpy(pack.szPlayerName, row[0], sizeof(pack.szPlayerName));
-					pack.bBattlePassType = std::atoi(row[1]);
-					pack.bBattlePassID = std::atoll(row[2]);
-					pack.dwStartTime = std::atoll(row[3]);
-					pack.dwEndTime = std::atoll(row[4]);
-
-					ch->GetDesc()->Packet(&pack, sizeof(pack));
-				}
-			}
-			break;
-
-		case 10:
-			CBattlePassManager::instance().BattlePassRequestReward(ch, 1);
-			return 0;
-			
-		case 11:
-			CBattlePassManager::instance().BattlePassRequestReward(ch, 2);
-			return 0;
-			
-		case 12:
-			CBattlePassManager::instance().BattlePassRequestReward(ch, 3);
-			return 0;
-
-
-		default:
-			break;
-	}
-
-	return 0;
-}
-
-int CInputMain::ReciveExtBattlePassPremiumItem(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	TPacketCGExtBattlePassSendPremiumItem* p = (TPacketCGExtBattlePassSendPremiumItem*)data;
-
-	if (uiBytes < sizeof(TPacketCGExtBattlePassSendPremiumItem))
-		return -1;
-
-	const char* c_pData = data + sizeof(TPacketCGExtBattlePassSendPremiumItem);
-	uiBytes -= sizeof(TPacketCGExtBattlePassSendPremiumItem);
-
-	LPITEM item = ch->GetInventoryItem(p->iSlotIndex);
-	if (item != NULL and item->GetVnum() == 93100)
-	{
-		ch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, CBattlePassManager::instance().GetPremiumBattlePassID());
-		CBattlePassManager::instance().BattlePassRequestOpen(ch);
-		item->SetCount(item->GetCount() - 1);
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NOW_IS_ACTIVATED_PREMIUM_BATTLEPASS_OWN"));
-	}
-	return 0;
-}
-#endif
-
-int CInputMain::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
-{
-	LPCHARACTER ch;
-
-	if (!(ch = d->GetCharacter()))
-	{
-		sys_err("no character on desc");
-		d->SetPhase(PHASE_CLOSE);
-		return (0);
-	}
-
-	int iExtraLen = 0;
-
-	if (test_server && bHeader != HEADER_CG_MOVE)
-		sys_log(0, "CInputMain::Analyze() ==> Header [%d] ", bHeader);
-
-#if defined(__LEFT_SEAT__)
-	const std::unordered_set<BYTE> bExcludeLeftSeatHeader = {
-		HEADER_CG_LEFT_SEAT,
-		HEADER_CG_TIME_SYNC,
-		HEADER_CG_PONG,
-	};
-
-	if (bExcludeLeftSeatHeader.find(bHeader) == bExcludeLeftSeatHeader.end())
-	{
-		if (ch->LeftSeat())
-			ch->DisableLeftSeatLogOutState(true);
-
-		ch->SetLastRequestTime(get_dword_time());
-	}
-#endif
-
-	switch (bHeader)
-	{
-		case HEADER_CG_PONG:
-			Pong(d);
-			break;
-
-		case HEADER_CG_TIME_SYNC:
-			Handshake(d, c_pData);
-			break;
-
-		case HEADER_CG_CHAT:
-			if (test_server)
-			{
-				char* pBuf = (char*)c_pData;
-				sys_log(0, "%s", pBuf + sizeof(TPacketCGChat));
-			}
-
-			if ((iExtraLen = Chat(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-
-			break;
-
-		case HEADER_CG_WHISPER:
-			if ((iExtraLen = Whisper(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_MOVE:
-			Move(ch, c_pData);
-			break;
-
-		case HEADER_CG_CHARACTER_POSITION:
-			Position(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_USE:
-			if (!ch->IsObserverMode())
-				ItemUse(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_DROP:
-			if (!ch->IsObserverMode())
-			{
-				ItemDrop(ch, c_pData);
-			}
-			break;
-
-		case HEADER_CG_ITEM_DROP2:
-			if (!ch->IsObserverMode())
-				ItemDrop2(ch, c_pData);
-			break;
-
-#if defined(__NEW_DROP_DIALOG__)
-		case HEADER_CG_ITEM_DESTROY:
-			if (!ch->IsObserverMode())
-				ItemDestroy(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_ITEM_MOVE:
-			if (!ch->IsObserverMode())
-				ItemMove(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_PICKUP:
-			if (!ch->IsObserverMode())
-				ItemPickup(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_USE_TO_ITEM:
-			if (!ch->IsObserverMode())
-				ItemToItem(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_GIVE:
-			if (!ch->IsObserverMode())
-				ItemGive(ch, c_pData);
-			break;
-
-		case HEADER_CG_EXCHANGE:
-			if (!ch->IsObserverMode())
-				Exchange(ch, c_pData);
-			break;
-
-		case HEADER_CG_ATTACK:
-		case HEADER_CG_SHOOT:
-			if (!ch->IsObserverMode())
-			{
-				Attack(ch, bHeader, c_pData);
-			}
-			break;
-
-		case HEADER_CG_USE_SKILL:
-			if (!ch->IsObserverMode())
-				UseSkill(ch, c_pData);
-			break;
-
-#ifdef __OFFLINE_SHOP__
-		case HEADER_CG_OFFLINE_SHOP:
-		{
-			if ((iExtraLen = COfflineShop::ReceivePacket(ch, c_pData, m_iBufferLeft)) < 0) {
-				return -1;
-			}
-
-			break;
-		}
-#endif
-
-#ifdef __SHOP_SEARCH__
-		case HEADER_CG_SHOP_SEARCH_BY_NAME:
-			ShopSearchByName(ch, c_pData);
-			break;
-
-		case HEADER_CG_SHOP_SEARCH_BY_OPTION:
-			if ((iExtraLen = ShopSearchByOptions(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_SHOP_SEARCH_BUY:
-			ShopSearchBuy(ch, c_pData);
-			break;
-
-		case HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE:
-			ShopSearchOwnerMessage(ch, c_pData);
-			break;
-
-		case HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO:
-			ShopSearchRequestSoldInfo(ch, c_pData);
-			break;
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-		case HEADER_CG_PET_HATCH:
-			PetHatch(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_WINDOW:
-			PetWindow(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_WINDOW_TYPE:
-			PetWindowType(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_NAME_CHANGE:
-			PetNameChange(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_FEED:
-			PetFeed(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_DETERMINE:
-			PetDetermine(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_ATTR_CHANGE:
-			PetAttrChange(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_REVIVE:
-			PetRevive(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_LEARN_SKILL:
-			PetLearnSkill(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_SKILL_UPGRADE:
-			PetSkillUpgrade(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_DELETE_SKILL:
-			PetDeleteSkill(ch, c_pData);
-			break;
-
-		case HEADER_CG_PET_DELETE_ALL_SKILL:
-			PetDeleteAllSkill(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_QUICKSLOT_ADD:
-			QuickslotAdd(ch, c_pData);
-			break;
-
-		case HEADER_CG_QUICKSLOT_DEL:
-			QuickslotDelete(ch, c_pData);
-			break;
-
-		case HEADER_CG_QUICKSLOT_SWAP:
-			QuickslotSwap(ch, c_pData);
-			break;
-
-		case HEADER_CG_SHOP:
-			if ((iExtraLen = Shop(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_MESSENGER:
-			if ((iExtraLen = Messenger(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_ON_CLICK:
-			OnClick(ch, c_pData);
-			break;
-
-		case HEADER_CG_SYNC_POSITION:
-			if ((iExtraLen = SyncPosition(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_ADD_FLY_TARGETING:
-		case HEADER_CG_FLY_TARGETING:
-			FlyTarget(ch, c_pData, bHeader);
-			break;
-
-		case HEADER_CG_SCRIPT_BUTTON:
-			ScriptButton(ch, c_pData);
-			break;
-
-			// SCRIPT_SELECT_ITEM
-		case HEADER_CG_SCRIPT_SELECT_ITEM:
-			ScriptSelectItem(ch, c_pData);
-			break;
-			// END_OF_SCRIPT_SELECT_ITEM
-
-		case HEADER_CG_SCRIPT_ANSWER:
-			ScriptAnswer(ch, c_pData);
-			break;
-
-#if defined(__GEM_SYSTEM__)
-		case HEADER_CG_SELECT_ITEM_EX:
-			SelectItemEx(ch, c_pData);
-			break;
-#endif
-
-#if defined(__QUEST_REQUEST_EVENT__)
-		case HEADER_CG_REQUEST_EVENT_QUEST:
-			RequestEventQuest(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_QUEST_INPUT_STRING:
-			QuestInputString(ch, c_pData);
-			break;
-
-#if defined(__OX_RENEWAL__)
-		case HEADER_CG_QUEST_INPUT_LONG_STRING:
-			QuestInputLongString(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_QUEST_CONFIRM:
-			QuestConfirm(ch, c_pData);
-			break;
-
-		case HEADER_CG_TARGET:
-			Target(ch, c_pData);
-			break;
-
-		case HEADER_CG_WARP:
-			Warp(ch, c_pData);
-			break;
-
-		case HEADER_CG_SAFEBOX_CHECKIN:
-			SafeboxCheckin(ch, c_pData);
-			break;
-
-		case HEADER_CG_SAFEBOX_CHECKOUT:
-			SafeboxCheckout(ch, c_pData, false);
-			break;
-
-		case HEADER_CG_SAFEBOX_ITEM_MOVE:
-			SafeboxItemMove(ch, c_pData);
-			break;
-
-		case HEADER_CG_MALL_CHECKOUT:
-			SafeboxCheckout(ch, c_pData, true);
-			break;
-
-		case HEADER_CG_PARTY_INVITE:
-			PartyInvite(ch, c_pData);
-			break;
-
-		case HEADER_CG_PARTY_REMOVE:
-			PartyRemove(ch, c_pData);
-			break;
-
-		case HEADER_CG_PARTY_INVITE_ANSWER:
-			PartyInviteAnswer(ch, c_pData);
-			break;
-
-		case HEADER_CG_PARTY_SET_STATE:
-			PartySetState(ch, c_pData);
-			break;
-
-		case HEADER_CG_PARTY_USE_SKILL:
-			PartyUseSkill(ch, c_pData);
-			break;
-
-		case HEADER_CG_PARTY_PARAMETER:
-			PartyParameter(ch, c_pData);
-			break;
-
-		case HEADER_CG_ANSWER_MAKE_GUILD:
-			AnswerMakeGuild(ch, c_pData);
-			break;
-
-		case HEADER_CG_GUILD:
-			if ((iExtraLen = Guild(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-		case HEADER_CG_FISHING:
-			Fishing(ch, c_pData);
-			break;
-
-#if defined(__FISHING_GAME__)
-		case HEADER_CG_FISHING_GAME:
-			FishingGame(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_HACK:
-			Hack(ch, c_pData);
-			break;
-
-		case HEADER_CG_MYSHOP:
-			if ((iExtraLen = MyShop(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-
-#if defined(__MYSHOP_DECO__)
-		case HEADER_CG_MYSHOP_DECO_STATE:
-			MyShopDecoState(ch, c_pData);
-			break;
-
-		case HEADER_CG_MYSHOP_DECO_ADD:
-			MyShopDecoAdd(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_REFINE:
-			Refine(ch, c_pData);
-			break;
-
-#if defined(__CUBE_RENEWAL__)
-		case HEADER_CG_CUBE:
-			Cube(ch, c_pData);
-			break;
-#endif
-
-		case HEADER_CG_CLIENT_VERSION:
-			Version(ch, c_pData);
-			break;
-
-#if defined(__DRAGON_SOUL_SYSTEM__)
-		case HEADER_CG_DRAGON_SOUL_REFINE:
-		{
-			TPacketCGDragonSoulRefine* p = reinterpret_cast <TPacketCGDragonSoulRefine*>((void*)c_pData);
-			switch (p->bSubType)
-			{
-				case DS_SUB_HEADER_CLOSE:
-					ch->DragonSoul_RefineWindow_Close();
-					break;
-
-				case DS_SUB_HEADER_DO_REFINE_GRADE:
-				{
-					DSManager::instance().DoRefineGrade(ch, p->ItemGrid);
-				}
-				break;
-
-				case DS_SUB_HEADER_DO_REFINE_STEP:
-				{
-					DSManager::instance().DoRefineStep(ch, p->ItemGrid);
-				}
-				break;
-
-				case DS_SUB_HEADER_DO_REFINE_STRENGTH:
-				{
-					DSManager::instance().DoRefineStrength(ch, p->ItemGrid);
-				}
-				break;
-
-#if defined(__DS_CHANGE_ATTR__)
-				case DS_SUB_HEADER_DO_CHANGE_ATTR:
-				{
-					DSManager::instance().DoChangeAttribute(ch, p->ItemGrid);
-				}
-				break;
-#endif
-			}
-		}
-		break;
-#endif
-
-#if defined(__SEND_TARGET_INFO__)
-		case HEADER_CG_TARGET_INFO:
-			TargetInfo(ch, c_pData);
-			break;
-#endif
-
-#if defined(__MOVE_COSTUME_ATTR__)
-		case HEADER_CG_ITEM_COMBINATION:
-			ItemCombination(ch, c_pData);
-			break;
-
-		case HEADER_CG_ITEM_COMBINATION_CANCEL:
-			ItemCombinationCancel(ch, c_pData);
-			break;
-#endif
-
-#if defined(__CHANGED_ATTR__)
-		case HEADER_CG_ITEM_SELECT_ATTR:
-			ItemSelectAttr(ch, c_pData);
-			break;
-#endif
-
-#if defined(__ACCE_COSTUME_SYSTEM__)
-		case HEADER_CG_ACCE_REFINE:
-			if ((iExtraLen = AcceRefine(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-#endif
-
-#if defined(__AURA_COSTUME_SYSTEM__)
-		case HEADER_CG_AURA_REFINE:
-			if ((iExtraLen = AuraRefine(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-#endif
-
-#if defined(__CHANGE_LOOK_SYSTEM__)
-		case HEADER_CG_CHANGE_LOOK:
-			ChangeLook(ch, c_pData);
-			break;
-#endif
-
-#if defined(__MINI_GAME_CATCH_KING__)
-		case HEADER_CG_MINI_GAME_CATCH_KING:
-			if ((iExtraLen = CMiniGameCatchKing::Process(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-#endif
-
-#if defined(__SKILLBOOK_COMB_SYSTEM__)
-		case HEADER_CG_SKILLBOOK_COMB:
-		{
-			TPacketCGSkillBookCombination* p = reinterpret_cast <TPacketCGSkillBookCombination*>((void*)c_pData);
-			SkillBookCombination(ch, p->CombItemGrid, p->bAction);
-		}
-		break;
-#endif
-
-#if defined(__MAILBOX__)
-		case HEADER_CG_MAILBOX_WRITE:
-			MailboxWrite(ch, c_pData);
-			break;
-
-		case HEADER_CG_MAILBOX_WRITE_CONFIRM:
-			MailboxConfirm(ch, c_pData);
-			break;
-
-		case HEADER_CG_MAILBOX_PROCESS:
-			MailboxProcess(ch, c_pData);
-			break;
-#endif
-
-#if defined(__LOOT_FILTER_SYSTEM__)
-		case HEADER_CG_LOOT_FILTER:
-			LootFilter(ch, c_pData);
-			break;
-#endif
-
-#if defined(__MINI_GAME_RUMI__)
-		case HEADER_CG_MINI_GAME_RUMI:
-			MiniGameRumi(ch, c_pData);
-			break;
-#endif
-
-#if defined(__MINI_GAME_YUTNORI__)
-		case HEADER_CG_MINI_GAME_YUTNORI:
-			MiniGameYutnori(ch, c_pData);
-			break;
-#endif
-
-#if defined(__LUCKY_BOX__)
-		case HEADER_CG_LUCKY_BOX:
-			LuckyBox(ch, c_pData);
-			break;
-#endif
-
-#if defined(__GEM_SHOP__)
-		case HEADER_CG_GEM_SHOP:
-			GemShop(ch, c_pData);
-			break;
-#endif
-
-#if defined(__EXTEND_INVEN_SYSTEM__)
-		case HEADER_CG_EXTEND_INVEN:
-			ExtendInven(ch, c_pData);
-			break;
-#endif
-
-#if defined(__ATTR_6TH_7TH__)
-		case HEADER_CG_ATTR67_ADD:
-			Attr67Add(ch, c_pData);
-			break;
-#endif
-
-#if defined(__SNOWFLAKE_STICK_EVENT__)
-		case HEADER_CG_SNOWFLAKE_STICK_EVENT:
-			SnowflakeStickEvent(ch, c_pData);
-			break;
-#endif
-
-#if defined(__REFINE_ELEMENT_SYSTEM__)
-		case HEADER_CG_REFINE_ELEMENT:
-			RefineElement(ch, c_pData);
-			break;
-#endif
-
-#if defined(__LEFT_SEAT__)
-		case HEADER_CG_LEFT_SEAT:
-			LeftSeat(ch, c_pData);
-			break;
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-		case HEADER_CG_MINI_GAME_ROULETTE:
-			MiniGameRoulette(ch, c_pData);
-			break;
-#endif
-
-#if defined(__SUMMER_EVENT_ROULETTE__)
-		case HEADER_CG_FLOWER_EVENT:
-			FlowerEvent(ch, c_pData);
-			break;
-#endif
-
-#ifdef ENABLE_EXTENDED_BATTLE_PASS
-		case HEADER_CG_EXT_BATTLE_PASS_ACTION:
-			if ((iExtraLen = ReciveExtBattlePassActions(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-			
-		case HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM:
-			if ((iExtraLen = ReciveExtBattlePassPremiumItem(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-			break;
-#endif
-	}
-
-	return (iExtraLen);
-}
-
-#if defined(__LUCKY_BOX__)
-void CInputMain::LuckyBox(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGLuckyBox* c_pPacket = reinterpret_cast<const TPacketCGLuckyBox*>(c_pData);
-
-	switch (c_pPacket->bAction)
-	{
-		case ELUCKY_BOX_ACTION::LUCKY_BOX_ACTION_RETRY:
-			ch->LuckyBoxRetry();
-			break;
-		case ELUCKY_BOX_ACTION::LUCKY_BOX_ACTION_RECEIVE:
-			ch->LuckyBoxReceive();
-			break;
-		default:
-			sys_err("CInputMain::LuckyBox : Unknown action %d : %s", c_pPacket->bAction, ch->GetName());
-			return;
-	}
-}
-#endif
-
-#ifdef __SHOP_SEARCH__
-void CInputMain::ShopSearchByName(LPCHARACTER ch, const char* data)
-{
-	TPacketCGShopSearchByName* p = (TPacketCGShopSearchByName*)data;
-	CShopSearchManager::PC_RequestSearch(ch, p->itemName, p->page, p->entryCountIdx, p->sortType);
-}
-
-int CInputMain::ShopSearchByOptions(LPCHARACTER ch, const char* data, size_t uiBytes)
-{
-	TPacketCGShopSearchByOptions* p = (TPacketCGShopSearchByOptions*)data;
-	data += sizeof(TPacketCGShopSearchByOptions);
-	uiBytes -= sizeof(TPacketCGShopSearchByOptions);
-
-	if (uiBytes < sizeof(TShopSearchItemType) * p->options.typeFlagCount)
-		return -1;
-
-	TShopSearchItemType* itemTypeFlags = (TShopSearchItemType*)data;
-	data += sizeof(TShopSearchItemType) * p->options.typeFlagCount;
-	uiBytes -= sizeof(TShopSearchItemType) * p->options.typeFlagCount;
-
-	if (uiBytes < sizeof(DWORD) * p->options.specificVnumCount)
-		return -1;
-
-	CShopSearchManager::PC_RequestSearch(ch, &p->options, itemTypeFlags, (const DWORD*)data, p->page, p->entryCountIdx, p->sortType);
-
-	return sizeof(TShopSearchItemType) * p->options.typeFlagCount + sizeof(DWORD) * p->options.specificVnumCount;
-}
-
-void CInputMain::ShopSearchBuy(LPCHARACTER ch, const char* data)
-{
-	TPacketCGShopSearchBuy* p = (TPacketCGShopSearchBuy*)data;
-
-	CShopSearchManager::PC_RequestBuy(ch, p->itemID, p->itemVnum, p->itemPrice);
-}
-
-void CInputMain::ShopSearchOwnerMessage(LPCHARACTER ch, const char* data)
-{
-	TPacketCGShopSearchOwnerMessage* p = (TPacketCGShopSearchOwnerMessage*)data;
-
-	TPacketGCShopSearchOwnerMessage pack;
-	pack.header = HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE;
-	memset(pack.ownerName, 0, sizeof(pack.ownerName));
-
-	if (LPCHARACTER tch = CHARACTER_MANAGER::instance().FindByPID(p->ownerID))
-		strlcpy(pack.ownerName, tch->GetName(), sizeof(pack.ownerName));
-	else if (CCI* pkCCI = P2P_MANAGER::instance().FindByPID(p->ownerID))
-		strlcpy(pack.ownerName, pkCCI->szName, sizeof(pack.ownerName));
-	else
-	{
-		std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("SELECT name FROM player WHERE id = %u", p->ownerID));
-		if (MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult))
-		{
-			strlcpy(pack.ownerName, row[0], sizeof(pack.ownerName));
-		}
-	}
-
-	ch->GetDesc()->Packet(&pack, sizeof(pack));
-}
-
-void CInputMain::ShopSearchRequestSoldInfo(LPCHARACTER ch, const char* data)
-{
-	TPacketCGShopSearchRequestSoldInfo* p = (TPacketCGShopSearchRequestSoldInfo*)data;
-
-	CShopSearchManager::PC_RequestSoldInfo(ch, p->itemVnum);
-}
-#endif
-
-#ifdef __GROWTH_PET_SYSTEM__
-void CInputMain::PetHatch(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetHatch* p = reinterpret_cast<const TPacketCGPetHatch*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-	
-	CGrowthPetManager::Instance().EggHatch(ch, p->name, p->eggPos);
-}
-
-void CInputMain::PetWindow(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetWindow* p = reinterpret_cast<const TPacketCGPetWindow*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	switch (p->window)
-	{
-		case PET_WINDOW_HATCH:
-			ch->SetPetHatchWindow(p->state);
-			break;
-
-		case PET_WINDOW_NAME_CHANGE:
-			ch->SetPetChangeNameWindow(p->state);
-			break;
-	}
-}
-
-void CInputMain::PetWindowType(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetWindowType* p = reinterpret_cast<const TPacketCGPetWindowType*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	BYTE bWindowType = p->type;
-
-	if (bWindowType == ch->GetPetWindowType())
-		return;
-
-	if (bWindowType == PET_WINDOW_ATTR_CHANGE || bWindowType == PET_WINDOW_PRIMIUM_FEEDSTUFF)
-	{
-
-		if ((ch->GetExchange() || ch->IsOpenSafebox() || ch->GetShopOwner()) || ch->IsCubeOpen())
-			return;
-	}
-
-	ch->SetPetWindowType(bWindowType);
-
-	TPacketGCPet packet;
-	packet.header = HEADER_GC_PET;
-	packet.subheader = SUBHEADER_PET_WINDOW_TYPE_INFO + bWindowType;
-
-	ch->GetDesc()->Packet(&packet, sizeof(packet));
-}
-
-void CInputMain::PetFeed(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetFeed* p = reinterpret_cast<const TPacketCGPetFeed*>(c_pData);
-	
-	if (!ch || !ch->GetDesc())
-		return;
-
-	if (ch->GetActiveGrowthPet())
-		ch->GetActiveGrowthPet()->Feed(p);
-	else
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-}
-
-void CInputMain::PetDetermine(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetDetermine* p = reinterpret_cast<const TPacketCGPetDetermine*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pDetermineItem = ch->GetInventoryItem(p->determinePos.cell);
-	if (!pDetermineItem)
-		return;
-
-	if (pDetermineItem->GetType() != ITEM_PET || pDetermineItem->GetSubType() != PET_ATTR_DETERMINE)
-		return;
-
-	if (!ch->GetActiveGrowthPet())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-		return;
-	}
-
-	ch->GetActiveGrowthPet()->AttrDetermine(pDetermineItem);
-}
-
-void CInputMain::PetAttrChange(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetAttrChange* p = reinterpret_cast<const TPacketCGPetAttrChange*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
-	if (!pUpBringingItem)
-		return;
-
-	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
-		return;
-
-	LPITEM pChangeAttrItem = ch->GetInventoryItem(p->attrChangePos.cell);
-	if (!pChangeAttrItem)
-		return;
-
-	if (pChangeAttrItem->GetType() != ITEM_PET || pChangeAttrItem->GetSubType() != PET_ATTR_CHANGE)
-		return;
-
-	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
-	if (!pPet)
-		return;
-
-	pPet->AttrChange(pUpBringingItem, pChangeAttrItem);
-}
-
-void CInputMain::PetRevive(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetRevive* p = reinterpret_cast<const TPacketCGPetRevive*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
-	if (!pUpBringingItem)
-		return;
-
-	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
-		return;
-
-	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
-	if (!pPet)
-		return;
-
-	pPet->PremiumFeed(p, pUpBringingItem);
-}
-
-void CInputMain::PetLearnSkill(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetLearnSkill* p = reinterpret_cast<const TPacketCGPetLearnSkill*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pSkillBookItem = ch->GetInventoryItem(p->learnSkillPos.cell);
-	if (!pSkillBookItem)
-		return;
-
-	if (pSkillBookItem->GetType() != ITEM_PET || pSkillBookItem->GetSubType() != PET_SKILL)
-		return;
-
-	if (!ch->GetActiveGrowthPet())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-		return;
-	}
-
-	ch->GetActiveGrowthPet()->LearnSkill(p->slotIndex, pSkillBookItem);
-}
-
-void CInputMain::PetSkillUpgrade(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetSkillUpgrade* p = reinterpret_cast<const TPacketCGPetSkillUpgrade*>(c_pData);
-
-	if (!ch->GetActiveGrowthPet())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-		return;
-	}
-
-	ch->GetActiveGrowthPet()->SkillUpgrade(p->slotIndex);
-}
-
-void CInputMain::PetDeleteSkill(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetDeleteSkill* p = reinterpret_cast<const TPacketCGPetDeleteSkill*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pDeleteSkillItem = ch->GetInventoryItem(p->deleteSkillPos.cell);
-	if (!pDeleteSkillItem)
-		return;
-
-	if (pDeleteSkillItem->GetType() != ITEM_PET || pDeleteSkillItem->GetSubType() != PET_SKILL_DEL_BOOK)
-		return;
-
-	if (!ch->GetActiveGrowthPet())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-		return;
-	}
-
-	ch->GetActiveGrowthPet()->DeleteSkill(p->slotIndex, pDeleteSkillItem);
-}
-
-void CInputMain::PetDeleteAllSkill(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetDeleteAllSkill* p = reinterpret_cast<const TPacketCGPetDeleteAllSkill*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pDeleteAllSkillItem = ch->GetInventoryItem(p->deleteAllSkillPos.cell);
-	if (!pDeleteAllSkillItem)
-		return;
-
-	if (pDeleteAllSkillItem->GetType() != ITEM_PET || pDeleteAllSkillItem->GetSubType() != PET_SKILL_ALL_DEL_BOOK)
-		return;
-
-	if (!ch->GetActiveGrowthPet())
-	{
-		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
-		return;
-	}
-
-	ch->GetActiveGrowthPet()->DeleteAllSkill(pDeleteAllSkillItem);
-}
-
-void CInputMain::PetNameChange(LPCHARACTER ch, const char* c_pData)
-{
-	const TPacketCGPetNameChange* p = reinterpret_cast<const TPacketCGPetNameChange*>(c_pData);
-
-	if (!ch || !ch->GetDesc())
-		return;
-
-	LPITEM pNameChangeItem = ch->GetInventoryItem(p->changeNamePos.cell);
-	if (!pNameChangeItem)
-		return;
-
-	if (pNameChangeItem->GetType() != ITEM_PET || pNameChangeItem->GetSubType() != PET_NAME_CHANGE)
-		return;
-
-	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
-	if (!pUpBringingItem)
-		return;
-
-	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
-		return;
-
-	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
-	if (!pPet)
-		return;
-
-	if (pPet->GetOwner() != ch)
-		return;
-
-	pPet->NameChange(p->name, pNameChangeItem, pUpBringingItem);
-}
-#endif
-
-int CInputDead::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
-{
-	LPCHARACTER ch;
-
-	if (!(ch = d->GetCharacter()))
-	{
-		sys_err("no character on desc");
-		return 0;
-	}
-
-	int iExtraLen = 0;
-
-	switch (bHeader)
-	{
-		case HEADER_CG_PONG:
-			Pong(d);
-			break;
-
-		case HEADER_CG_TIME_SYNC:
-			Handshake(d, c_pData);
-			break;
-
-		case HEADER_CG_CHAT:
-			if ((iExtraLen = Chat(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-
-			break;
-
-		case HEADER_CG_WHISPER:
-			if ((iExtraLen = Whisper(ch, c_pData, m_iBufferLeft)) < 0)
-				return -1;
-
-			break;
-
-		case HEADER_CG_HACK:
-			Hack(ch, c_pData);
-			break;
-
-		default:
-			return (0);
-	}
-
-	return (iExtraLen);
-}
+// Hardening: reject truncated packets early to prevent OOB reads in handlers.
+#define REQUIRE_BYTES(bytes, need) do { if ((bytes) < (need)) return -1; } while(0)
+#include "stdafx.h"
+#include "constants.h"
+#include "config.h"
+#include "utils.h"
+#include "desc_client.h"
+#include "desc_manager.h"
+#include "buffer_manager.h"
+#include "packet.h"
+#include "protocol.h"
+#include "char.h"
+#include "char_manager.h"
+#include "item.h"
+#include "item_manager.h"
+#ifdef ENABLE_QUEEN_NETHIS
+#include "SnakeLair.h"
+#endif
+#include "cmd.h"
+#include "shop.h"
+#include "shop_manager.h"
+#include "safebox.h"
+#include "regen.h"
+#include "battle.h"
+#include "exchange.h"
+#include "questmanager.h"
+#include "profiler.h"
+#include "messenger_manager.h"
+#include "party.h"
+#include "p2p.h"
+#include "affect.h"
+#include "guild.h"
+#include "guild_manager.h"
+#include "log.h"
+#include "banword.h"
+#include "empire_text_convert.h"
+#include "unique_item.h"
+#include "building.h"
+#include "locale_service.h"
+#include "gm.h"
+#include "spam.h"
+#include "ani.h"
+#include "motion.h"
+#include "OXEvent.h"
+#include "locale_service.h"
+#include "DragonSoul.h"
+#include "belt_inventory_helper.h"
+
+#include <vector>
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+#	include "LootFilter.h"
+#endif
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+#	include "xmas_event.h"
+#endif
+
+#if defined(__DEFENSE_WAVE__)
+#	include "defense_wave.h"
+#endif
+
+#if defined(__OFFLINE_SHOP__)
+#include "OfflineShop.h"
+#endif
+
+#if defined(__SHOP_SEARCH__)
+	#include "ShopSearchManager.h"
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+#include "battlepass_manager.h"
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+#include "growth_pet.h"
+#endif
+
+extern void SendShout(const char* szText, BYTE bEmpire
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	, const char* c_szName
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	, const char* c_szCountry
+#endif
+);
+
+extern int g_nPortalLimitTime;
+
+static int __deposit_limit()
+{
+	return (1000 * 10000); // 1√µ
+}
+
+void SendBlockChatInfo(LPCHARACTER ch, int sec)
+{
+	if (sec <= 0)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√§  ‘¥œ¥."));
+		return;
+	}
+
+	long hour = sec / 3600;
+	sec -= hour * 3600;
+
+	long min = (sec / 60);
+	sec -= min * 60;
+
+	if (hour > 0 && min > 0)
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d √∞ %d  %d   √§√± ‘¥œ¥", hour, min, sec));
+	else if (hour > 0 && min == 0)
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d √∞ %d   √§√± ‘¥œ¥", hour, sec));
+	else if (hour == 0 && min > 0)
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d  %d   √§√± ‘¥œ¥", min, sec));
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%d   √§√± ‘¥œ¥", sec));
+}
+
+EVENTINFO(spam_event_info)
+{
+	char host[MAX_HOST_LENGTH + 1];
+
+	spam_event_info()
+	{
+		::memset(host, 0, MAX_HOST_LENGTH + 1);
+	}
+};
+
+typedef std::unordered_map<std::string, std::pair<unsigned int, LPEVENT>> spam_score_of_ip_t;
+spam_score_of_ip_t spam_score_of_ip;
+
+EVENTFUNC(block_chat_by_ip_event)
+{
+	spam_event_info* info = dynamic_cast<spam_event_info*>(event->info);
+
+	if (info == NULL)
+	{
+		sys_err("block_chat_by_ip_event> <Factor> Null pointer");
+		return 0;
+	}
+
+	const char* host = info->host;
+
+	spam_score_of_ip_t::iterator it = spam_score_of_ip.find(host);
+
+	if (it != spam_score_of_ip.end())
+	{
+		it->second.first = 0;
+		it->second.second = NULL;
+	}
+
+	return 0;
+}
+
+bool SpamBlockCheck(LPCHARACTER ch, const char* const buf, const size_t buflen)
+{
+	extern int g_iSpamBlockMaxLevel;
+
+	if (ch->GetLevel() < g_iSpamBlockMaxLevel)
+	{
+		spam_score_of_ip_t::iterator it = spam_score_of_ip.find(ch->GetDesc()->GetHostName());
+
+		if (it == spam_score_of_ip.end())
+		{
+			spam_score_of_ip.insert(std::make_pair(ch->GetDesc()->GetHostName(), std::make_pair(0, (LPEVENT)NULL)));
+			it = spam_score_of_ip.find(ch->GetDesc()->GetHostName());
+		}
+
+		if (it->second.second)
+		{
+			SendBlockChatInfo(ch, event_time(it->second.second) / passes_per_sec);
+			return true;
+		}
+
+		unsigned int score;
+		const char* word = SpamManager::instance().GetSpamScore(buf, buflen, score);
+
+		it->second.first += score;
+
+		if (word)
+			sys_log(0, "SPAM_SCORE: %s text: %s score: %u total: %u word: %s", ch->GetName(), buf, score, it->second.first, word);
+
+		extern unsigned int g_uiSpamBlockScore;
+		extern unsigned int g_uiSpamBlockDuration;
+
+		if (it->second.first >= g_uiSpamBlockScore)
+		{
+			spam_event_info* info = AllocEventInfo<spam_event_info>();
+			strlcpy(info->host, ch->GetDesc()->GetHostName(), sizeof(info->host));
+
+			it->second.second = event_create(block_chat_by_ip_event, info, PASSES_PER_SEC(g_uiSpamBlockDuration));
+			sys_log(0, "SPAM_IP: %s for %u seconds", info->host, g_uiSpamBlockDuration);
+
+			LogManager::instance().CharLog(ch, 0, "SPAM", word);
+
+			SendBlockChatInfo(ch, event_time(it->second.second) / passes_per_sec);
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
+enum
+{
+	TEXT_TAG_PLAIN,
+	TEXT_TAG_TAG, // ||
+	TEXT_TAG_COLOR, // |cffffffff
+	TEXT_TAG_HYPERLINK_START, // |H
+	TEXT_TAG_HYPERLINK_END, // |h ex) |Hitem:1234:1:1:1|h
+	TEXT_TAG_RESTORE_COLOR,
+};
+
+int GetTextTag(const char* src, int maxLen, int& tagLen, std::string& extraInfo)
+{
+	tagLen = 1;
+
+	if (maxLen < 2 || *src != '|')
+		return TEXT_TAG_PLAIN;
+
+	const char* cur = ++src;
+
+	if (*cur == '|') // || | «•—¥.
+	{
+		tagLen = 2;
+		return TEXT_TAG_TAG;
+	}
+	else if (*cur == 'c') // color |cffffffffblahblah|r
+	{
+		tagLen = 2;
+		return TEXT_TAG_COLOR;
+	}
+	else if (*cur == 'H') // hyperlink |Hitem:10000:0:0:0:0|h[Ã∏]|h
+	{
+		tagLen = 2;
+		return TEXT_TAG_HYPERLINK_START;
+	}
+	else if (*cur == 'h') // end of hyperlink
+	{
+		tagLen = 2;
+		return TEXT_TAG_HYPERLINK_END;
+	}
+
+	return TEXT_TAG_PLAIN;
+}
+
+void GetTextTagInfo(const char* src, int src_len, int& hyperlinks, bool& colored)
+{
+	colored = false;
+	hyperlinks = 0;
+
+	int len;
+	std::string extraInfo;
+
+	for (int i = 0; i < src_len;)
+	{
+		int tag = GetTextTag(&src[i], src_len - i, len, extraInfo);
+
+		if (tag == TEXT_TAG_HYPERLINK_START)
+			++hyperlinks;
+
+		if (tag == TEXT_TAG_COLOR)
+			colored = true;
+
+		i += len;
+	}
+}
+
+int ProcessTextTag(LPCHARACTER ch, const char* c_pszText, size_t len)
+{
+	// 20120517 
+	// 0 :  
+	// 1 : ›∞ 
+	// 2 : ›∞ , Œª 
+	// 3 : »Ø
+	// 4 : 
+
+	int hyperlinks;
+	bool colored;
+
+	GetTextTagInfo(c_pszText, len, hyperlinks, colored);
+
+	if (colored == true && hyperlinks == 0)
+		return 4;
+
+	if (ch->GetExchange())
+	{
+		if (hyperlinks == 0)
+			return 0;
+		else
+			return 3;
+	}
+
+	int nPrismCount = ch->CountSpecifyItem(ITEM_PRISM);
+
+	if (nPrismCount < hyperlinks)
+		return 1;
+
+	if (!ch->GetMyShop())
+	{
+		ch->RemoveSpecifyItem(ITEM_PRISM, hyperlinks);
+		return 0;
+	}
+	else
+	{
+		int sellingNumber = ch->GetMyShop()->GetNumberByVnum(ITEM_PRISM);
+		if (nPrismCount - sellingNumber < hyperlinks)
+		{
+			return 2;
+		}
+		else
+		{
+			ch->RemoveSpecifyItem(ITEM_PRISM, hyperlinks);
+			return 0;
+		}
+	}
+
+	return 4;
+}
+
+static bool __ParseItemLinkParts(const std::string& payload, std::vector<long long>& out)
+{
+	out.clear();
+
+	// Expect "item:" prefix
+	if (payload.size() < 5 || payload.compare(0, 5, "item:") != 0)
+		return false;
+
+	const char* p = payload.c_str() + 5;
+	const char* end = payload.c_str() + payload.size();
+
+	while (p < end)
+	{
+		char* next = NULL;
+		long long v = strtoll(p, &next, 10);
+		if (next == p)
+			break;
+
+		out.push_back(v);
+
+		p = next;
+		if (p < end && *p == ':')
+			++p;
+		else
+			break;
+	}
+
+	return !out.empty();
+}
+
+static bool __HasMatchingItemForLink(LPCHARACTER ch, const std::vector<long long>& parts)
+{
+	if (!ch || parts.empty())
+		return false;
+
+	const DWORD vnum = (DWORD)parts[0];
+
+	// If sockets are present, validate the first 3 sockets
+	const bool hasSockets = (parts.size() >= 4);
+	DWORD s0 = 0, s1 = 0, s2 = 0;
+	if (hasSockets)
+	{
+		s0 = (DWORD)parts[1];
+		s1 = (DWORD)parts[2];
+		s2 = (DWORD)parts[3];
+	}
+
+	// If attributes are present in classic format, validate 7 attribute pairs (type,value)
+	const bool hasAttrs = (parts.size() >= 18);
+
+	auto matches = [&](LPITEM item) -> bool
+	{
+		if (!item)
+			return false;
+
+		if (item->GetVnum() != vnum)
+			return false;
+
+		if (hasSockets)
+		{
+			if (item->GetSocket(0) != s0 || item->GetSocket(1) != s1 || item->GetSocket(2) != s2)
+				return false;
+		}
+
+		if (hasAttrs)
+		{
+			for (int i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
+			{
+				const TPlayerItemAttribute& a = item->GetAttribute(i);
+				const int type = (int)parts[4 + i * 2];
+				const int val = (int)parts[5 + i * 2];
+
+				if (a.bType != type || a.sValue != val)
+					return false;
+			}
+		}
+
+		return true;
+	};
+
+	// Inventory
+	int maxInv = INVENTORY_MAX_NUM;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	maxInv = ch->GetExtendInvenMax();
+#endif
+	for (int i = 0; i < maxInv; ++i)
+	{
+		LPITEM item = ch->GetInventoryItem(i);
+		if (matches(item))
+			return true;
+	}
+
+	// Equipment
+	for (int i = 0; i < WEAR_MAX_NUM; ++i)
+	{
+		LPITEM item = ch->GetWear(i);
+		if (matches(item))
+			return true;
+	}
+
+	// Belt inventory
+	for (int i = 0; i < BELT_INVENTORY_SLOT_COUNT; ++i)
+	{
+		LPITEM item = ch->GetItem(TItemPos(BELT_INVENTORY, i));
+		if (matches(item))
+			return true;
+	}
+
+	return false;
+}
+
+static bool __ValidateItemLinksInText(LPCHARACTER ch, const char* text, size_t len)
+{
+	if (!ch || !text || len == 0)
+		return true;
+
+	// Allow GMs to link freely
+	if (ch->IsGM())
+		return true;
+
+	std::string s(text, len);
+	size_t pos = 0;
+
+	std::vector<long long> parts;
+
+	while ((pos = s.find("|Hitem:", pos)) != std::string::npos)
+	{
+		const size_t payloadStart = pos + 2; // skip "|H"
+		const size_t hEnd = s.find("|h", payloadStart);
+		if (hEnd == std::string::npos)
+			return false; // malformed hyperlink
+
+		const std::string payload = s.substr(payloadStart, hEnd - payloadStart);
+
+		if (!__ParseItemLinkParts(payload, parts))
+			return false;
+
+		if (!__HasMatchingItemForLink(ch, parts))
+			return false;
+
+		pos = hEnd + 2;
+	}
+
+	return 4;
+}
+
+static bool __ParseItemLinkParts(const std::string& payload, std::vector<long long>& out)
+{
+	out.clear();
+
+	// Expect "item:" prefix
+	if (payload.size() < 5 || payload.compare(0, 5, "item:") != 0)
+		return false;
+
+	const char* p = payload.c_str() + 5;
+	const char* end = payload.c_str() + payload.size();
+
+	while (p < end)
+	{
+		char* next = NULL;
+		long long v = strtoll(p, &next, 10);
+		if (next == p)
+			break;
+
+		out.push_back(v);
+
+		p = next;
+		if (p < end && *p == ':')
+			++p;
+		else
+			break;
+	}
+
+	return !out.empty();
+}
+
+static bool __HasMatchingItemForLink(LPCHARACTER ch, const std::vector<long long>& parts)
+{
+	if (!ch || parts.empty())
+		return false;
+
+	const DWORD vnum = (DWORD)parts[0];
+
+	// If sockets are present, validate the first 3 sockets
+	const bool hasSockets = (parts.size() >= 4);
+	DWORD s0 = 0, s1 = 0, s2 = 0;
+	if (hasSockets)
+	{
+		s0 = (DWORD)parts[1];
+		s1 = (DWORD)parts[2];
+		s2 = (DWORD)parts[3];
+	}
+
+	// If attributes are present in classic format, validate 7 attribute pairs (type,value)
+	const bool hasAttrs = (parts.size() >= 18);
+
+	auto matches = [&](LPITEM item) -> bool
+	{
+		if (!item)
+			return false;
+
+		if (item->GetVnum() != vnum)
+			return false;
+
+		if (hasSockets)
+		{
+			if (item->GetSocket(0) != s0 || item->GetSocket(1) != s1 || item->GetSocket(2) != s2)
+				return false;
+		}
+
+		if (hasAttrs)
+		{
+			for (int i = 0; i < ITEM_ATTRIBUTE_MAX_NUM; ++i)
+			{
+				const TPlayerItemAttribute& a = item->GetAttribute(i);
+				const int type = (int)parts[4 + i * 2];
+				const int val = (int)parts[5 + i * 2];
+
+				if (a.bType != type || a.sValue != val)
+					return false;
+			}
+		}
+
+		return true;
+	};
+
+	// Inventory
+	int maxInv = INVENTORY_MAX_NUM;
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	maxInv = ch->GetExtendInvenMax();
+#endif
+	for (int i = 0; i < maxInv; ++i)
+	{
+		LPITEM item = ch->GetInventoryItem(i);
+		if (matches(item))
+			return true;
+	}
+
+	// Equipment
+	for (int i = 0; i < WEAR_MAX_NUM; ++i)
+	{
+		LPITEM item = ch->GetWear(i);
+		if (matches(item))
+			return true;
+	}
+
+	// Belt inventory
+	for (int i = 0; i < BELT_INVENTORY_SLOT_COUNT; ++i)
+	{
+		LPITEM item = ch->GetItem(TItemPos(BELT_INVENTORY, i));
+		if (matches(item))
+			return true;
+	}
+
+	return false;
+}
+
+static bool __ValidateItemLinksInText(LPCHARACTER ch, const char* text, size_t len)
+{
+	if (!ch || !text || len == 0)
+		return true;
+
+	// Allow GMs to link freely
+	if (ch->IsGM())
+		return true;
+
+	std::string s(text, len);
+	size_t pos = 0;
+
+	std::vector<long long> parts;
+
+	while ((pos = s.find("|Hitem:", pos)) != std::string::npos)
+	{
+		const size_t payloadStart = pos + 2; // skip "|H"
+		const size_t hEnd = s.find("|h", payloadStart);
+		if (hEnd == std::string::npos)
+			return false; // malformed hyperlink
+
+		const std::string payload = s.substr(payloadStart, hEnd - payloadStart);
+
+		if (!__ParseItemLinkParts(payload, parts))
+			return false;
+
+		if (!__HasMatchingItemForLink(ch, parts))
+			return false;
+
+		pos = hEnd + 2;
+	}
+
+	return true;
+}
+
+int CInputMain::Whisper(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	const TPacketCGWhisper* pinfo = reinterpret_cast<const TPacketCGWhisper*>(data);
+
+	if (uiBytes < pinfo->wSize)
+		return -1;
+
+	int iExtraLen = pinfo->wSize - sizeof(TPacketCGWhisper);
+
+	if (iExtraLen < 0)
+	{
+		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->wSize, uiBytes);
+		ch->GetDesc()->SetPhase(PHASE_CLOSE);
+		return -1;
+	}
+
+	ch->IncreaseWhisperCounter();
+	if (ch->GetWhisperCounter() == 10 && !ch->IsGM())
+	{
+		sys_log(0, "WHISPER_HACK: %s", ch->GetName());
+		//ch->GetDesc()->DelayedDisconnect(5);
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Please do not spam the chat."));
+		ch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, 10, 0, true);
+
+		return iExtraLen;
+	}
+
+	if (ch->FindAffect(AFFECT_BLOCK_CHAT))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√§  ‘¥œ¥."));
+		return (iExtraLen);
+	}
+
+	LPCHARACTER pkChr = CHARACTER_MANAGER::instance().FindPC(pinfo->szNameTo);
+
+	if (pkChr == ch && !test_server)
+		return iExtraLen;
+
+	LPDESC pkDesc = NULL;
+	BYTE bOpponentEmpire = 0;
+	DWORD dwOpponentPID = 0;
+
+	if (test_server)
+	{
+		if (!pkChr)
+			sys_log(0, "Whisper to %s(%s) from %s", "Null", pinfo->szNameTo, ch->GetName());
+		else
+			sys_log(0, "Whisper to %s(%s) from %s", pkChr->GetName(), pinfo->szNameTo, ch->GetName());
+	}
+
+	if (ch->IsBlockMode(BLOCK_WHISPER))
+	{
+		if (ch->GetDesc())
+		{
+			TPacketGCWhisper pack;
+			pack.bHeader = HEADER_GC_WHISPER;
+			pack.bType = WHISPER_TYPE_SENDER_BLOCKED;
+			pack.wSize = sizeof(TPacketGCWhisper);
+			strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+			ch->GetDesc()->Packet(&pack, sizeof(pack));
+		}
+		return iExtraLen;
+	}
+
+	if (!pkChr)
+	{
+		CCI* pkCCI = P2P_MANAGER::instance().Find(pinfo->szNameTo);
+
+		if (pkCCI)
+		{
+			pkDesc = pkCCI->pkDesc;
+			pkDesc->SetRelay(pinfo->szNameTo);
+			bOpponentEmpire = pkCCI->bEmpire;
+			dwOpponentPID = pkCCI->dwPID;
+
+			if (test_server)
+				sys_log(0, "Whisper to %s from %s (Channel %d Mapindex %d)", "Null", ch->GetName(), pkCCI->bChannel, pkCCI->lMapIndex);
+		}
+	}
+	else
+	{
+		pkDesc = pkChr->GetDesc();
+		bOpponentEmpire = pkChr->GetEmpire();
+		dwOpponentPID = pkChr->GetPlayerID();
+	}
+
+	if (!pkDesc)
+	{
+		if (ch->GetDesc())
+		{
+			TPacketGCWhisper pack;
+
+			pack.bHeader = HEADER_GC_WHISPER;
+			pack.bType = WHISPER_TYPE_NOT_EXIST;
+			pack.wSize = sizeof(TPacketGCWhisper);
+			strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+
+			ch->GetDesc()->Packet(&pack, sizeof(TPacketGCWhisper));
+			sys_log(0, "WHISPER: no player");
+		}
+	}
+	else
+	{
+		if (ch->IsBlockMode(BLOCK_WHISPER))
+		{
+			if (ch->GetDesc())
+			{
+				TPacketGCWhisper pack;
+				pack.bHeader = HEADER_GC_WHISPER;
+				pack.bType = WHISPER_TYPE_SENDER_BLOCKED;
+				pack.wSize = sizeof(TPacketGCWhisper);
+				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+				ch->GetDesc()->Packet(&pack, sizeof(pack));
+			}
+		}
+		else if (pkChr && pkChr->IsBlockMode(BLOCK_WHISPER))
+		{
+			if (ch->GetDesc())
+			{
+				TPacketGCWhisper pack;
+				pack.bHeader = HEADER_GC_WHISPER;
+				pack.bType = WHISPER_TYPE_TARGET_BLOCKED;
+				pack.wSize = sizeof(TPacketGCWhisper);
+				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+				ch->GetDesc()->Packet(&pack, sizeof(pack));
+			}
+		}
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		else if (pkDesc && CMessengerManager::instance().IsBlocked(ch->GetName(), pinfo->szNameTo))
+		{
+			if (ch->GetDesc())
+			{
+				TPacketGCWhisper pack;
+
+				char msg[CHAT_MAX_LEN + 1];
+				snprintf(msg, sizeof(msg), LC_STRING("Unblock %s to continue.", pinfo->szNameTo));
+				int len = MIN(CHAT_MAX_LEN, strlen(msg) + 1);
+
+				pack.bHeader = HEADER_GC_WHISPER;
+				pack.wSize = sizeof(TPacketGCWhisper) + len;
+				pack.bType = WHISPER_TYPE_SYSTEM;
+				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+
+				TEMP_BUFFER buf;
+
+				buf.write(&pack, sizeof(TPacketGCWhisper));
+				buf.write(msg, len);
+				ch->GetDesc()->Packet(buf.read_peek(), buf.size());
+
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", pinfo->szNameTo));
+			}
+		}
+		else if (pkDesc && CMessengerManager::instance().IsBlocked(pinfo->szNameTo, ch->GetName()))
+		{
+			if (ch->GetDesc())
+			{
+				TPacketGCWhisper pack;
+
+				char msg[CHAT_MAX_LEN + 1];
+				snprintf(msg, sizeof(msg), LC_STRING("%s has blocked you.", pinfo->szNameTo));
+				int len = MIN(CHAT_MAX_LEN, strlen(msg) + 1);
+
+				pack.bHeader = HEADER_GC_WHISPER;
+				pack.wSize = sizeof(TPacketGCWhisper) + len;
+				pack.bType = WHISPER_TYPE_SYSTEM;
+				strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+
+				TEMP_BUFFER buf;
+
+				buf.write(&pack, sizeof(TPacketGCWhisper));
+				buf.write(msg, len);
+				ch->GetDesc()->Packet(buf.read_peek(), buf.size());
+
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", pinfo->szNameTo));
+			}
+		}
+#endif
+		else
+		{
+			BYTE bType = WHISPER_TYPE_NORMAL;
+
+			char buf[CHAT_MAX_LEN + 1];
+			strlcpy(buf, data + sizeof(TPacketCGWhisper), MIN(iExtraLen + 1, sizeof(buf)));
+			const size_t buflen = strlen(buf);
+
+			//if (true == SpamBlockCheck(ch, buf, buflen))
+			//{
+			//	if (!pkChr)
+			//	{
+			//		CCI* pkCCI = P2P_MANAGER::instance().Find(pinfo->szNameTo);
+			//
+			//		if (pkCCI)
+			//		{
+			//			pkDesc->SetRelay("");
+			//		}
+			//	}
+			//	return iExtraLen;
+			//}
+
+			//if (LC_IsCanada() == false)
+			//{
+			//	CBanwordManager::instance().ConvertString(buf, buflen);
+			//}
+
+			if (!g_bEmpireWhisper)
+			{
+				if (!ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
+				{
+					if (!(pkChr && pkChr->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)))
+					{
+						if (bOpponentEmpire != ch->GetEmpire() && ch->GetEmpire() && bOpponentEmpire //   Ÿ∏Èº≠
+							&& ch->GetGMLevel() == GM_PLAYER && gm_get_level(pinfo->szNameTo) == GM_PLAYER) // —¥ œπ √∑ÃæÃ∏
+							// Ã∏ €ø ∏£¥ gm_get_level ‘º 
+						{
+							if (!pkChr)
+							{
+								// Ÿ∏    «•√∏ —¥. bType  4∆Æ Empire»£ —¥.
+								bType = ch->GetEmpire() << 4;
+							}
+							else
+							{
+								ConvertEmpireText(ch->GetEmpire(), buf, buflen, 10 + 2 * pkChr->GetSkillPower(SKILL_LANGUAGE1 + ch->GetEmpire() - 1) /* »Ø»Æ */);
+							}
+						}
+					}
+				}
+			}
+
+			if (!g_bDisableGlassInsight)
+			{
+				if (!__ValidateItemLinksInText(ch, buf, buflen))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Invalid item link."));
+					return iExtraLen;
+				}
+
+				int processReturn = ProcessTextTag(ch, buf, buflen);
+				if (processReturn != 0)
+				{
+					if (ch->GetDesc())
+					{
+						TItemTable* pTable = ITEM_MANAGER::instance().GetTable(ITEM_PRISM);
+
+						if (pTable)
+						{
+							char buf[128];
+							int len;
+							if (processReturn == 3) // »Ø
+								len = snprintf(buf, sizeof(buf), LC_STRING("Ÿ∏ ≈∑(√¢,»Ø,) Œª   œ¥."));
+							else
+							{
+								len = snprintf(buf, sizeof(buf), LC_STRING("%s   ø’¥œ¥", LC_ITEM(pTable->dwVnum)));
+							}
+
+							if (len < 0 || len >= (int)sizeof(buf))
+								len = sizeof(buf) - 1;
+
+							++len; // \0  
+
+							TPacketGCWhisper pack;
+
+							pack.bHeader = HEADER_GC_WHISPER;
+							pack.bType = WHISPER_TYPE_ERROR;
+							pack.wSize = sizeof(TPacketGCWhisper) + len;
+							strlcpy(pack.szNameFrom, pinfo->szNameTo, sizeof(pack.szNameFrom));
+
+							ch->GetDesc()->BufferedPacket(&pack, sizeof(pack));
+							ch->GetDesc()->Packet(buf, len);
+
+							sys_log(0, "WHISPER: not enough %s: char: %s", pTable->szLocaleName, ch->GetName());
+						}
+					}
+
+					//    «∑ Ã∏ «Æÿ¥.
+					pkDesc->SetRelay("");
+					return (iExtraLen);
+				}
+			}
+
+			if (ch->IsGM())
+				bType = (bType & 0xF0) | WHISPER_TYPE_GM;
+
+			if (buflen > 0)
+			{
+				TPacketGCWhisper pack;
+
+				pack.bHeader = HEADER_GC_WHISPER;
+				pack.wSize = sizeof(TPacketGCWhisper) + buflen;
+				pack.bType = bType;
+				strlcpy(pack.szNameFrom, ch->GetName(), sizeof(pack.szNameFrom));
+#if defined(__LOCALE_CLIENT__)
+				pack.bCanFormat = false;
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+				strlcpy(pack.szCountry, ch->GetCountry(), sizeof(pack.szCountry));
+#endif
+
+				// desc->BufferedPacket   ∞ €ø œ¥  
+				// P2P relay«æ ≈∂ ƒ∏»≠   ÷± Ã¥.
+				TEMP_BUFFER tmpbuf;
+
+				tmpbuf.write(&pack, sizeof(pack));
+				tmpbuf.write(buf, buflen);
+
+				pkDesc->Packet(tmpbuf.read_peek(), tmpbuf.size());
+
+				if (test_server)
+					sys_log(0, "WHISPER: %s -> %s : %s", ch->GetName(), pinfo->szNameTo, buf);
+
+				if (g_bWhisperLog)
+					LogManager::instance().WhisperLog(ch->GetPlayerID(), dwOpponentPID, buf);
+			}
+		}
+	}
+	if (pkDesc)
+		pkDesc->SetRelay("");
+
+	return (iExtraLen);
+}
+
+struct RawPacketToCharacterFunc
+{
+	const void* m_buf;
+	int m_buf_len;
+
+	RawPacketToCharacterFunc(const void* buf, int buf_len) : m_buf(buf), m_buf_len(buf_len)
+	{
+	}
+
+	void operator () (LPCHARACTER c)
+	{
+		if (!c->GetDesc())
+			return;
+
+		c->GetDesc()->Packet(m_buf, m_buf_len);
+	}
+};
+
+struct FEmpireChatPacket
+{
+	packet_chat& p;
+	const char* orig_msg;
+	int orig_len;
+	char converted_msg[CHAT_MAX_LEN + 1];
+
+	BYTE bEmpire;
+	int iMapIndex;
+	int namelen;
+
+	FEmpireChatPacket(packet_chat& p, const char* chat_msg, int len, BYTE bEmpire, int iMapIndex, int iNameLen)
+		: p(p), orig_msg(chat_msg), orig_len(len), bEmpire(bEmpire), iMapIndex(iMapIndex), namelen(iNameLen)
+	{
+		memset(converted_msg, 0, sizeof(converted_msg));
+	}
+
+	void operator () (LPDESC d)
+	{
+		if (!d->GetCharacter())
+			return;
+
+		if (d->GetCharacter()->GetMapIndex() != iMapIndex)
+			return;
+
+		d->BufferedPacket(&p, sizeof(packet_chat));
+
+		if (d->GetEmpire() == bEmpire ||
+			bEmpire == 0 ||
+			d->GetCharacter()->GetGMLevel() > GM_PLAYER ||
+			d->GetCharacter()->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
+		{
+			d->Packet(orig_msg, orig_len);
+		}
+		else
+		{
+			//  ≈≥ Ÿ∏ ≈π ÿæ’¥œ¥
+			size_t len = strlcpy(converted_msg, orig_msg, sizeof(converted_msg));
+
+			if (len >= sizeof(converted_msg))
+				len = sizeof(converted_msg) - 1;
+
+			ConvertEmpireText(bEmpire, converted_msg + namelen, len - namelen, 10 + 2 * d->GetCharacter()->GetSkillPower(SKILL_LANGUAGE1 + bEmpire - 1));
+			d->Packet(converted_msg, orig_len);
+		}
+	}
+};
+
+struct FYmirChatPacket
+{
+	packet_chat& packet;
+	const char* m_szChat;
+	size_t m_lenChat;
+	const char* m_szName;
+
+	int m_iMapIndex;
+	BYTE m_bEmpire;
+	bool m_ring;
+
+	char m_orig_msg[CHAT_MAX_LEN + 1];
+	int m_len_orig_msg;
+	char m_conv_msg[CHAT_MAX_LEN + 1];
+	int m_len_conv_msg;
+
+	FYmirChatPacket(packet_chat& p, const char* chat, size_t len_chat, const char* name, size_t len_name, int iMapIndex, BYTE empire, bool ring)
+		: packet(p),
+		m_szChat(chat), m_lenChat(len_chat),
+		m_szName(name),
+		m_iMapIndex(iMapIndex), m_bEmpire(empire),
+		m_ring(ring)
+	{
+		m_len_orig_msg = snprintf(m_orig_msg, sizeof(m_orig_msg), "%s : %s", m_szName, m_szChat) + 1; //   
+
+		if (m_len_orig_msg < 0 || m_len_orig_msg >= (int)sizeof(m_orig_msg))
+			m_len_orig_msg = sizeof(m_orig_msg) - 1;
+
+		m_len_conv_msg = snprintf(m_conv_msg, sizeof(m_conv_msg), "??? : %s", m_szChat) + 1; //   
+
+		if (m_len_conv_msg < 0 || m_len_conv_msg >= (int)sizeof(m_conv_msg))
+			m_len_conv_msg = sizeof(m_conv_msg) - 1;
+
+		ConvertEmpireText(m_bEmpire, m_conv_msg + 6, m_len_conv_msg - 6, 10); // 6 "??? : " 
+	}
+
+	void operator() (LPDESC d)
+	{
+		if (!d->GetCharacter())
+			return;
+
+		if (d->GetCharacter()->GetMapIndex() != m_iMapIndex)
+			return;
+
+		if (m_ring ||
+			d->GetEmpire() == m_bEmpire ||
+			d->GetCharacter()->GetGMLevel() > GM_PLAYER ||
+			d->GetCharacter()->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE))
+		{
+			packet.size = m_len_orig_msg + sizeof(TPacketGCChat);
+
+			d->BufferedPacket(&packet, sizeof(packet_chat));
+			d->Packet(m_orig_msg, m_len_orig_msg);
+		}
+		else
+		{
+			packet.size = m_len_conv_msg + sizeof(TPacketGCChat);
+
+			d->BufferedPacket(&packet, sizeof(packet_chat));
+			d->Packet(m_conv_msg, m_len_conv_msg);
+		}
+	}
+};
+
+int CInputMain::Chat(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	const TPacketCGChat* pinfo = reinterpret_cast<const TPacketCGChat*>(data);
+
+	if (uiBytes < pinfo->size)
+		return -1;
+
+	const int iExtraLen = pinfo->size - sizeof(TPacketCGChat);
+
+	if (iExtraLen < 0)
+	{
+		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->size, uiBytes);
+		ch->GetDesc()->SetPhase(PHASE_CLOSE);
+		return -1;
+	}
+
+	char buf[CHAT_MAX_LEN - (CHARACTER_NAME_MAX_LEN + 3) + 1];
+	strlcpy(buf, data + sizeof(TPacketCGChat), MIN(iExtraLen + 1, sizeof(buf)));
+	const size_t buflen = strlen(buf);
+
+	if (buflen > 1 && *buf == '/')
+	{
+		// NOTE : Block players from accessing the command interpreter
+		// through normal chat. (CHAT_TYPE_TALKING) 20230607.Owsap
+		if (!ch->IsGM() && pinfo->type == CHAT_TYPE_TALKING)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("◊∑ …æ œ¥"));
+			return iExtraLen;
+		}
+
+		interpret_command(ch, buf + 1, buflen - 1);
+		return iExtraLen;
+	}
+
+	ch->IncreaseChatCounter();
+	if (ch->GetChatCounter() == 10 && !ch->IsGM())
+	{
+		sys_log(0, "CHAT_HACK: %s", ch->GetName());
+		//ch->GetDesc()->DelayedDisconnect(5);
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Please do not spam the chat."));
+		ch->AddAffect(AFFECT_BLOCK_CHAT, POINT_NONE, 0, AFF_NONE, 10, 0, true);
+
+		return iExtraLen;
+	}
+
+	// √§  Affect √≥
+	const CAffect* pAffect = ch->FindAffect(AFFECT_BLOCK_CHAT);
+
+	if (pAffect != NULL)
+	{
+		SendBlockChatInfo(ch, pAffect->lDuration);
+		return iExtraLen;
+	}
+
+	if (SpamBlockCheck(ch, buf, buflen))
+		return iExtraLen;
+
+	if (CHAT_TYPE_SHOUT == pinfo->type && g_bDisableShout && !ch->IsGM())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("The shout is disabled."));
+		return iExtraLen;
+	}
+
+	char chatbuf[CHAT_MAX_LEN + 1];
+	int len = snprintf(chatbuf, sizeof(chatbuf), "%s : %s", ch->GetName(), buf);
+
+	if (CHAT_TYPE_SHOUT == pinfo->type)
+	{
+		LogManager::instance().ShoutLog(g_bChannel, ch->GetEmpire(), chatbuf);
+	}
+
+	CBanwordManager::instance().ConvertString(buf, buflen);
+
+	if (len < 0 || len >= (int)sizeof(chatbuf))
+		len = sizeof(chatbuf) - 1;
+
+	if (!g_bDisableGlassInsight)
+	{
+		if (!__ValidateItemLinksInText(ch, buf, buflen))
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Invalid item link."));
+			return iExtraLen;
+		}
+
+		int processReturn = ProcessTextTag(ch, chatbuf, len);
+		if (processReturn != 0)
+		{
+			const TItemTable* pTable = ITEM_MANAGER::instance().GetTable(ITEM_PRISM);
+
+			if (NULL != pTable)
+			{
+				if (3 == processReturn) //»Ø
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ÿ∏ ≈∑(√¢,»Ø,) Œª   œ¥."));
+				else
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s   ø’¥œ¥", LC_ITEM(pTable->dwVnum)));
+				}
+			}
+
+			return iExtraLen;
+		}
+	}
+
+	if (pinfo->type == CHAT_TYPE_SHOUT)
+	{
+		const int SHOUT_LIMIT_LEVEL = g_iUseLocale ? 15 : 3;
+
+		if (ch->GetLevel() < SHOUT_LIMIT_LEVEL)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("ƒ°  %d Ãª   ’¥œ¥.", SHOUT_LIMIT_LEVEL));
+			return (iExtraLen);
+		}
+
+		if (thecore_heart->pulse - (int)ch->GetLastShoutPulse() < passes_per_sec * 15 && !ch->IsGM())
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You can only call every 15 seconds."));
+			return (iExtraLen);
+		}
+
+		ch->SetLastShoutPulse(thecore_heart->pulse);
+
+		TPacketGGShout p;
+		p.bHeader = HEADER_GG_SHOUT;
+		p.bEmpire = ch->GetEmpire();
+		strlcpy(p.szText, chatbuf, sizeof(p.szText));
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		strlcpy(p.szName, ch->GetName(), sizeof(p.szName));
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+		strlcpy(p.szCountry, ch->GetCountry(), sizeof(p.szCountry));
+#endif
+
+		P2P_MANAGER::instance().Send(&p, sizeof(TPacketGGShout));
+
+		SendShout(chatbuf, ch->GetEmpire()
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+			, ch->GetName()
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+			, ch->GetCountry()
+#endif
+		);
+
+		return (iExtraLen);
+	}
+
+    TPacketGCChat pack_chat{};
+    pack_chat.header = HEADER_GC_CHAT;
+    pack_chat.size = sizeof(TPacketGCChat) + len;
+    pack_chat.type = pinfo->type;
+	pack_chat.id = ch->GetVID();
+#if defined(__LOCALE_CLIENT__)
+	pack_chat.bCanFormat = false;
+#endif
+#if defined(__MULTI_LANGUAGE_SYSTEM__)
+	strlcpy(pack_chat.szCountry, ch->GetCountry(), sizeof(pack_chat.szCountry));
+#endif
+
+	switch (pinfo->type)
+	{
+		case CHAT_TYPE_TALKING:
+		{
+			const DESC_MANAGER::DESC_SET& c_ref_set = DESC_MANAGER::instance().GetClientSet();
+
+			if (false)
+			{
+				std::for_each(c_ref_set.begin(), c_ref_set.end(),
+					FYmirChatPacket(pack_chat,
+						buf,
+						strlen(buf),
+						ch->GetName(),
+						strlen(ch->GetName()),
+						ch->GetMapIndex(),
+						ch->GetEmpire(),
+						ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)));
+			}
+			else
+			{
+				std::for_each(c_ref_set.begin(), c_ref_set.end(),
+					FEmpireChatPacket(pack_chat,
+						chatbuf,
+						len,
+						(ch->GetGMLevel() > GM_PLAYER ||
+							ch->IsEquipUniqueGroup(UNIQUE_GROUP_RING_OF_LANGUAGE)) ? 0 : ch->GetEmpire(),
+						ch->GetMapIndex(), strlen(ch->GetName())));
+			}
+		}
+		break;
+
+		case CHAT_TYPE_PARTY:
+		{
+			if (!ch->GetParty())
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("∆º  ∆¥’¥œ¥."));
+			else
+			{
+				
+	// [Anti-Abuse] Rate-limit SyncPosition packet spam (CPU burner / lag switch)
+	// The original SyncPosition logic checks per-victim intervals; this adds a per-sender throttle.
+	{
+		const DWORD dwNow = get_dword_time();
+		const long lCurX = ch->GetX();
+		const long lCurY = ch->GetY();
+		const long dx = lCurX - ch->GetLastSyncPosX();
+		const long dy = lCurY - ch->GetLastSyncPosY();
+		const long long distSq = (long long)dx * dx + (long long)dy * dy;
+		static const long long kStillDistSq = (long long)5000 * 5000; // ~50m (coords are /100)
+		static const int kMaxPacketsPerSecStill = 10;
+		static const int kMaxStrikes = 3;
+
+		if (ch->GetSyncPosWindowStart() == 0 || dwNow - ch->GetSyncPosWindowStart() > 1000)
+			ch->ResetSyncPosWindow(dwNow);
+
+		if (distSq <= kStillDistSq)
+		{
+			ch->IncSyncPosPacketCount();
+			if (ch->GetSyncPosPacketCount() > kMaxPacketsPerSecStill)
+			{
+				ch->IncSyncPosSpamStrikes();
+				if (ch->GetSyncPosSpamStrikes() >= kMaxStrikes)
+				{
+					LogManager::instance().HackLog("SYNC_POSITION_SPAM", ch);
+					sys_err("SyncPosition spam (count=%d strikes=%d) from %s",
+						ch->GetSyncPosPacketCount(), ch->GetSyncPosSpamStrikes(), ch->GetName());
+					ch->GetDesc()->SetPhase(PHASE_CLOSE);
+					return -1;
+				}
+				// Ignore excessive packets while stationary to protect core CPU
+				return iExtraLen;
+			}
+		}
+		else
+		{
+			ch->SetLastSyncPos(lCurX, lCurY);
+			ch->ResetSyncPosSpamStrikes();
+		}
+	}
+
+TEMP_BUFFER tbuf;
+
+				tbuf.write(&pack_chat, sizeof(pack_chat));
+				tbuf.write(chatbuf, len);
+
+				RawPacketToCharacterFunc f(tbuf.read_peek(), tbuf.size());
+				ch->GetParty()->ForEachOnlineMember(f);
+			}
+		}
+		break;
+
+		case CHAT_TYPE_GUILD:
+		{
+			if (!ch->GetGuild())
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Âø°   æ“Ωœ¥."));
+			else
+				ch->GetGuild()->Chat(chatbuf);
+		}
+		break;
+
+		default:
+			sys_err("Unknown chat type %d", pinfo->type);
+			break;
+	}
+
+	return (iExtraLen);
+}
+
+void CInputMain::ItemUse(LPCHARACTER ch, const char* data)
+{
+	ch->UseItem(((struct command_item_use*)data)->Cell);
+}
+
+void CInputMain::ItemToItem(LPCHARACTER ch, const char* pcData)
+{
+	TPacketCGItemUseToItem* p = (TPacketCGItemUseToItem*)pcData;
+	if (ch)
+		ch->UseItem(p->Cell, p->TargetCell);
+}
+
+void CInputMain::ItemDrop(LPCHARACTER ch, const char* data)
+{
+	struct command_item_drop* pinfo = (struct command_item_drop*)data;
+
+	// MONARCH_LIMIT
+	//if (ch->IsMonarch())
+	//	return;
+	// END_MONARCH_LIMIT
+	if (!ch)
+		return;
+
+	// ≈© 0 ≈© ≈©   Ã¥.
+	if (pinfo->gold > 0)
+		ch->DropGold(pinfo->gold);
+#if defined(__CHEQUE_SYSTEM__)
+	else if (pinfo->cheque > 0)
+		ch->DropCheque(pinfo->cheque);
+#endif
+	else
+		ch->DropItem(pinfo->Cell);
+}
+
+void CInputMain::ItemDrop2(LPCHARACTER ch, const char* data)
+{
+	// MONARCH_LIMIT
+	//if (ch->IsMonarch())
+	//	return;
+	// END_MONARCH_LIMIT
+
+	TPacketCGItemDrop2* pinfo = (TPacketCGItemDrop2*)data;
+
+	// ≈© 0 ≈© ≈©   Ã¥.
+
+	if (!ch)
+		return;
+	if (pinfo->gold > 0)
+		ch->DropGold(pinfo->gold);
+#if defined(__CHEQUE_SYSTEM__)
+	else if (pinfo->cheque > 0)
+		ch->DropCheque(pinfo->cheque);
+#endif
+	else
+		ch->DropItem(pinfo->Cell, pinfo->count);
+}
+
+#if defined(__NEW_DROP_DIALOG__)
+void CInputMain::ItemDestroy(LPCHARACTER ch, const char* data)
+{
+	struct command_item_destroy* pinfo = (struct command_item_destroy*)data;
+	if (ch)
+		ch->DestroyItem(pinfo->Cell);
+}
+#endif
+
+void CInputMain::ItemMove(LPCHARACTER ch, const char* data)
+{
+	struct command_item_move* pinfo = (struct command_item_move*)data;
+
+	if (ch)
+		ch->MoveItem(pinfo->Cell, pinfo->CellTo, pinfo->count);
+}
+
+void CInputMain::ItemPickup(LPCHARACTER ch, const char* data)
+{
+	struct command_item_pickup* pinfo = (struct command_item_pickup*)data;
+	if (ch)
+		ch->PickupItem(pinfo->vid);
+}
+
+void CInputMain::QuickslotAdd(LPCHARACTER ch, const char* data)
+{
+	struct command_quickslot_add* pinfo = (struct command_quickslot_add*)data;
+	ch->SetQuickslot(pinfo->pos, pinfo->slot);
+}
+
+void CInputMain::QuickslotDelete(LPCHARACTER ch, const char* data)
+{
+	struct command_quickslot_del* pinfo = (struct command_quickslot_del*)data;
+	ch->DelQuickslot(pinfo->pos);
+}
+
+void CInputMain::QuickslotSwap(LPCHARACTER ch, const char* data)
+{
+	struct command_quickslot_swap* pinfo = (struct command_quickslot_swap*)data;
+	ch->SwapQuickslot(pinfo->pos, pinfo->change_pos);
+}
+
+int CInputMain::Messenger(const LPCHARACTER c_lpChar, const char* c_pData, std::size_t uiBytes)
+{
+	const TPacketCGMessenger* c_pPacket = reinterpret_cast<const TPacketCGMessenger*>(c_pData);
+	if (uiBytes < sizeof(TPacketCGMessenger))
+		return -1;
+
+	c_pData += sizeof(TPacketCGMessenger);
+	uiBytes -= sizeof(TPacketCGMessenger);
+
+	switch (c_pPacket->bSubHeader)
+	{
+		case MESSENGER_SUBHEADER_CG_ADD_BY_VID:
+		{
+			if (uiBytes < sizeof(TPacketCGMessengerAddByVID))
+				return -1;
+
+			const TPacketCGMessengerAddByVID* c_pAddByVIDPacket = reinterpret_cast<const TPacketCGMessengerAddByVID*>(c_pData);
+			const LPCHARACTER c_lpCharCompanion = CHARACTER_MANAGER::instance().Find(c_pAddByVIDPacket->dwVID);
+
+			if (c_lpCharCompanion == nullptr)
+				return sizeof(TPacketCGMessengerAddByVID);
+
+			if (c_lpCharCompanion->IsObserverMode())
+				return sizeof(TPacketCGMessengerAddByVID);
+
+			if (c_lpCharCompanion->IsBlockMode(BLOCK_MESSENGER_INVITE))
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ﬁΩ ﬂ∞ ≈∫ ‘¥œ¥."));
+				return sizeof(TPacketCGMessengerAddByVID);
+			}
+
+			const LPDESC c_lpCompanionDesc = c_lpCharCompanion->GetDesc();
+			if (c_lpCompanionDesc == nullptr)
+				return sizeof(TPacketCGMessengerAddByVID);
+
+			if (c_lpChar->GetGMLevel() == GM_PLAYER && c_lpCharCompanion->GetGMLevel() != GM_PLAYER)
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ﬁΩ> Óøµ⁄¥ ﬁΩ ﬂ∞  œ¥."));
+				return sizeof(TPacketCGMessengerAddByVID);
+			}
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", c_lpCharCompanion->GetName()));
+				return sizeof(TPacketCGMessengerAddByVID);
+			}
+			else if (CMessengerManager::instance().IsBlocked(c_lpCharCompanion->GetName(), c_lpChar->GetName()))
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", c_lpCharCompanion->GetName()));
+				return sizeof(TPacketCGMessengerAddByVID);
+			}
+#endif
+
+			if (c_lpChar->GetDesc() == c_lpCompanionDesc) // ⁄Ω ﬂ∞  .
+				return sizeof(TPacketCGMessengerAddByVID);
+
+			CMessengerManager::instance().RequestToAdd(c_lpChar, c_lpCharCompanion);
+			//CMessengerManager::instance().AddToList(c_lpChar->GetName(), c_lpCharCompanion->GetName());
+		}
+		return sizeof(TPacketCGMessengerAddByVID);
+
+		case MESSENGER_SUBHEADER_CG_ADD_BY_NAME:
+		{
+			if (uiBytes < CHARACTER_NAME_MAX_LEN)
+				return -1;
+
+			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
+			strlcpy(szName, c_pData, sizeof(szName));
+
+			if (c_lpChar->GetGMLevel() == GM_PLAYER && gm_get_level(szName) != GM_PLAYER)
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<ﬁΩ> Óøµ⁄¥ ﬁΩ ﬂ∞  œ¥."));
+				return CHARACTER_NAME_MAX_LEN;
+			}
+
+			const LPCHARACTER c_lpCharTarget = CHARACTER_MANAGER::instance().FindPC(szName);
+			if (c_lpCharTarget == nullptr)
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s  ”µ   Ωœ¥.", szName));
+			else
+			{
+				if (c_lpCharTarget == c_lpChar) // ⁄Ω ﬂ∞  .
+					return CHARACTER_NAME_MAX_LEN;
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharTarget->GetName()))
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", c_lpCharTarget->GetName()));
+					return CHARACTER_NAME_MAX_LEN;
+				}
+				else if (CMessengerManager::instance().IsBlocked(c_lpCharTarget->GetName(), c_lpChar->GetName()))
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", c_lpCharTarget->GetName()));
+					return CHARACTER_NAME_MAX_LEN;
+				}
+#endif
+
+				if (c_lpCharTarget->IsBlockMode(BLOCK_MESSENGER_INVITE) == true)
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" ﬁΩ ﬂ∞ ≈∫ ‘¥œ¥."));
+				}
+				else
+				{
+					// ﬁΩ ƒ≥Õ¥ «∏Èº≠ 
+					CMessengerManager::instance().RequestToAdd(c_lpChar, c_lpCharTarget);
+					//CMessengerManager::instance().AddToList(c_lpChar->GetName(), c_lpCharTarget->GetName());
+				}
+			}
+		}
+		return CHARACTER_NAME_MAX_LEN;
+
+		case MESSENGER_SUBHEADER_CG_REMOVE:
+		{
+			if (uiBytes < CHARACTER_NAME_MAX_LEN)
+				return -1;
+
+			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
+			strlcpy(szName, c_pData, sizeof(szName));
+			CMessengerManager::instance().RemoveFromList(c_lpChar->GetName(), szName);
+		}
+		return CHARACTER_NAME_MAX_LEN;
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+		case MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_VID:
+		{
+			if (uiBytes < sizeof(TPacketCGMessengerAddBlockByVID))
+				return -1;
+
+			const TPacketCGMessengerAddBlockByVID* c_pAddBlockByVIDPacket = reinterpret_cast<const TPacketCGMessengerAddBlockByVID*>(c_pData);
+			const LPCHARACTER c_lpCharCompanion = CHARACTER_MANAGER::instance().Find(c_pAddBlockByVIDPacket->dwVID);
+			if (c_lpCharCompanion == nullptr)
+				return sizeof(TPacketCGMessengerAddBlockByVID);
+
+			if (c_lpChar->IsObserverMode())
+				return sizeof(TPacketCGMessengerAddBlockByVID);
+
+			const LPDESC c_lpDescCompanion = c_lpCharCompanion->GetDesc();
+			if (c_lpDescCompanion == nullptr)
+				return sizeof(TPacketCGMessengerAddByVID);
+
+			const LPCHARACTER c_pPartner = c_lpChar->GetMarryPartner();
+			if (c_pPartner)
+			{
+				if (c_lpCharCompanion->GetName() == c_pPartner->GetName())
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block your spouse."));
+					return sizeof(TPacketCGMessengerAddBlockByVID);
+				}
+			}
+
+			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Remove %s from your friends list to continue.", c_lpCharCompanion->GetName()));
+				return sizeof(TPacketCGMessengerAddBlockByVID);
+			}
+
+			if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), c_lpCharCompanion->GetName()))
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is already being blocked.", c_lpCharCompanion->GetName()));
+				return sizeof(TPacketCGMessengerAddBlockByVID);
+			}
+
+			if (c_lpChar->GetGMLevel() == GM_PLAYER && c_lpCharCompanion->GetGMLevel() != GM_PLAYER && !test_server)
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block this player."));
+				return sizeof(TPacketCGMessengerAddByVID);
+			}
+
+			if (c_lpChar->GetDesc() == c_lpDescCompanion)
+				return sizeof(TPacketCGMessengerAddBlockByVID);
+
+			CMessengerManager::instance().AddToBlockList(c_lpChar->GetName(), c_lpCharCompanion->GetName());
+		}
+		return sizeof(TPacketCGMessengerAddBlockByVID);
+
+		case MESSENGER_SUBHEADER_CG_BLOCK_ADD_BY_NAME:
+		{
+			if (uiBytes < CHARACTER_NAME_MAX_LEN)
+				return -1;
+
+			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
+			strlcpy(szName, c_pData, sizeof(szName));
+
+			if (gm_get_level(szName) != GM_PLAYER && !test_server)
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block this player."));
+				return CHARACTER_NAME_MAX_LEN;
+			}
+
+			const LPCHARACTER c_lpCharTarget = CHARACTER_MANAGER::instance().FindPC(szName);
+			if (c_lpCharTarget == c_lpChar)
+				return CHARACTER_NAME_MAX_LEN;
+
+			LPDESC pDescTarget = nullptr;
+			if (c_lpCharTarget == nullptr)
+			{
+				const CCI* c_pCCI = P2P_MANAGER::instance().Find(szName);
+				if (c_pCCI)
+					pDescTarget = c_pCCI->pkDesc;
+			}
+			else
+				pDescTarget = c_lpCharTarget->GetDesc();
+
+			if (pDescTarget == nullptr)
+			{
+				c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is not online.", szName));
+				return CHARACTER_NAME_MAX_LEN;
+			}
+			else
+			{
+				const LPCHARACTER c_pPartner = c_lpChar->GetMarryPartner();
+				if (c_pPartner)
+				{
+					if (c_pPartner->GetName() == szName)
+					{
+						c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot block your spouse."));
+						return CHARACTER_NAME_MAX_LEN;
+					}
+				}
+
+				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Remove %s from your friends list to continue.", szName));
+					return CHARACTER_NAME_MAX_LEN;
+				}
+
+				if (CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
+				{
+					c_lpChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s is already being blocked.", szName));
+					return CHARACTER_NAME_MAX_LEN;
+				}
+
+				CMessengerManager::instance().AddToBlockList(c_lpChar->GetName(), szName);
+			}
+		}
+		return CHARACTER_NAME_MAX_LEN;
+
+		case MESSENGER_SUBHEADER_CG_BLOCK_REMOVE:
+		{
+			if (uiBytes < CHARACTER_NAME_MAX_LEN)
+				return -1;
+
+			char szName[CHARACTER_NAME_MAX_LEN + 1] = {};
+			strlcpy(szName, c_pData, sizeof(szName));
+
+			if (!CMessengerManager::instance().IsBlocked(c_lpChar->GetName(), szName))
+				return CHARACTER_NAME_MAX_LEN;
+
+			CMessengerManager::instance().RemoveFromBlockList(c_lpChar->GetName(), szName);
+		}
+		return CHARACTER_NAME_MAX_LEN;
+#endif
+
+		default:
+			sys_err("CInputMain::Messenger : Unknown subheader %d : %s", c_pPacket->bSubHeader, c_lpChar->GetName());
+			break;
+	}
+
+	return 0;
+}
+
+int CInputMain::Shop(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	TPacketCGShop* p = (TPacketCGShop*)data;
+
+	if (uiBytes < sizeof(TPacketCGShop))
+		return -1;
+
+	if (test_server)
+		sys_log(0, "CInputMain::Shop() ==> SubHeader %d", p->subheader);
+
+	const char* c_pData = data + sizeof(TPacketCGShop);
+	uiBytes -= sizeof(TPacketCGShop);
+
+	switch (p->subheader)
+	{
+		case SHOP_SUBHEADER_CG_END:
+			sys_log(1, "INPUT: %s SHOP: END", ch->GetName());
+			CShopManager::instance().StopShopping(ch);
+			return 0;
+
+		case SHOP_SUBHEADER_CG_BUY:
+		{
+			if (uiBytes < sizeof(BYTE) + sizeof(BYTE))
+				return -1;
+
+			BYTE bPos = *(c_pData + 1);
+			sys_log(1, "INPUT: %s SHOP: BUY %d", ch->GetName(), bPos);
+			CShopManager::instance().Buy(ch, bPos);
+			return (sizeof(BYTE) + sizeof(BYTE));
+		}
+
+		case SHOP_SUBHEADER_CG_SELL:
+		{
+			if (uiBytes < sizeof(BYTE))
+				return -1;
+
+			BYTE pos = *c_pData;
+
+			sys_log(0, "INPUT: %s SHOP: SELL", ch->GetName());
+			CShopManager::instance().Sell(ch, pos);
+			return sizeof(BYTE);
+		}
+
+		case SHOP_SUBHEADER_CG_SELL2:
+		{
+			const TPacketCGShopSell* p = reinterpret_cast<const TPacketCGShopSell*>(c_pData);
+
+			sys_log(0, "INPUT: %s SHOP: SELL2", ch->GetName());
+
+			CShopManager::instance().Sell(ch, p->wPos, p->wCount, p->bType);
+			return sizeof(TPacketCGShopSell);
+		}
+
+		default:
+			sys_err("CInputMain::Shop : Unknown subheader %d : %s", p->subheader, ch->GetName());
+			break;
+	}
+
+	return 0;
+}
+
+void CInputMain::OnClick(LPCHARACTER ch, const char* data)
+{
+	struct command_on_click* pinfo = (struct command_on_click*)data;
+	LPCHARACTER victim = NULL;
+
+	if (!ch)
+		return;
+
+	// Prevent range-click hacks and dead-state abuse
+	if (ch->IsDead() || !ch->GetSectree())
+		return;
+
+	if ((victim = CHARACTER_MANAGER::instance().Find(pinfo->vid)))
+	{
+		if (!victim->GetSectree())
+			return;
+
+		// Cross-map interaction is always invalid
+		if (victim->GetMapIndex() != ch->GetMapIndex())
+			return;
+
+		// Range limit (same as shop interaction distance)
+		if (ch->GetDist(victim) >= SHOP_MAX_DISTANCE)
+			return;
+
+		victim->OnClick(ch);
+	}
+	else if (test_server)
+	{
+		sys_err("CInputMain::OnClick %s.Click.NOT_EXIST_VID[%d]", ch->GetName(), pinfo->vid);
+	}
+}
+
+void CInputMain::Exchange(LPCHARACTER ch, const char* data)
+{
+	struct command_exchange* pinfo = (struct command_exchange*)data;
+	LPCHARACTER to_ch = NULL;
+
+	if (!ch->CanHandleItem())
+		return;
+
+	// [Security Fix] Window overlap: block safebox operations while other trade windows are open.
+	if (ch->PreventTradeWindow(WND_SAFEBOX, true/*except*/))
+		return;
+
+	if (!ch->GetSafebox())
+		return;
+
+	int iPulse = thecore_pulse();
+
+	if ((to_ch = CHARACTER_MANAGER::instance().Find(pinfo->arg1)))
+	{
+		if (ch->GetDist(to_ch) >= EXCHANGE_MAX_DISTANCE)
+			return;
+
+		if (iPulse - to_ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+		{
+			to_ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("\xb0≈∑\xa1 \xc8\xc4 %d\xc3\xca \xc0Ã≥\xbb\xbf\xa1 √¢\xb0\xed\xb8\xa6 \xbf\xad\xbc\xf6 \xbe\xf8\xbd\xc0\xb4œ¥\xd9.", g_nPortalLimitTime));
+			return;
+		}
+
+		if (true == to_ch->IsDead())
+		{
+			return;
+		}
+	}
+
+	sys_log(0, "CInputMain()::Exchange() SubHeader %d ", pinfo->sub_header);
+
+	if (iPulse - ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("≈∑  %d Ã≥ √¢  œ¥.", g_nPortalLimitTime));
+		return;
+	}
+
+	switch (pinfo->sub_header)
+	{
+		case EXCHANGE_SUBHEADER_CG_START: // arg1 == vid of target character
+			if (!ch->GetExchange())
+			{
+				if ((to_ch = CHARACTER_MANAGER::instance().Find(pinfo->arg1)))
+				{
+					if (ch->GetDist(to_ch) >= EXCHANGE_MAX_DISTANCE || to_ch->IsDead())
+						return;
+
+					//MONARCH_LIMIT
+					/*
+					if (to_ch->IsMonarch() || ch->IsMonarch())
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("÷øÕ¥ ≈∑ “º œ¥", g_nPortalLimitTime));
+						return;
+					}
+					//END_MONARCH_LIMIT
+					*/
+					if (iPulse - ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√¢  %d Ã≥ ≈∑ “º œ¥.", g_nPortalLimitTime));
+
+						if (test_server)
+							ch->ChatPacket(CHAT_TYPE_INFO, "[TestOnly][Safebox]Pulse %d LoadTime %d PASS %d", iPulse, ch->GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
+						return;
+					}
+
+					if (iPulse - to_ch->GetSafeboxLoadTime() < PASSES_PER_SEC(g_nPortalLimitTime))
+					{
+						to_ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√¢  %d Ã≥ ≈∑ “º œ¥.", g_nPortalLimitTime));
+
+						if (test_server)
+							to_ch->ChatPacket(CHAT_TYPE_INFO, "[TestOnly][Safebox]Pulse %d LoadTime %d PASS %d", iPulse, to_ch->GetSafeboxLoadTime(), PASSES_PER_SEC(g_nPortalLimitTime));
+						return;
+					}
+
+					if (ch->GetGold() >= GOLD_MAX)
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("◊º 20   ∞œø ≈∑ “º œ¥.."));
+
+						sys_err("[OVERFLOG_GOLD] START (%d) id %u name %s ", ch->GetGold(), ch->GetPlayerID(), ch->GetName());
+						return;
+					}
+
+#if defined(__CHEQUE_SYSTEM__)
+					if (ch->GetCheque() > CHEQUE_MAX)
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("◊º 20   ∞œø ≈∑ “º œ¥.."));
+
+						sys_err("[OVERFLOW_CHEQUE] START (%d) id %u name %s ", ch->GetCheque(), ch->GetPlayerID(), ch->GetName());
+						return;
+					}
+#endif
+
+					if (to_ch->IsPC())
+					{
+						if (quest::CQuestManager::instance().GiveItemToPC(ch->GetPlayerID(), to_ch))
+						{
+							sys_log(0, "Exchange canceled by quest %s %s", ch->GetName(), to_ch->GetName());
+							return;
+						}
+					}
+
+					if (ch->PreventTradeWindow(WND_EXCHANGE, true/*except*/))
+					{
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ÿ∏ ≈∑œ∞ Œª  œ¥."));
+						return;
+					}
+
+					ch->ExchangeStart(to_ch);
+				}
+			}
+			break;
+
+		case EXCHANGE_SUBHEADER_CG_ITEM_ADD: // arg1 == position of item, arg2 == position in exchange window
+			if (ch->GetExchange())
+			{
+				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
+					ch->GetExchange()->AddItem(pinfo->Pos, pinfo->arg2);
+			}
+			break;
+
+		case EXCHANGE_SUBHEADER_CG_ITEM_DEL: // arg1 == position of item
+			if (ch->GetExchange())
+			{
+				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
+					ch->GetExchange()->RemoveItem(pinfo->arg1);
+			}
+			break;
+
+		case EXCHANGE_SUBHEADER_CG_ELK_ADD: // arg1 == amount of gold
+			if (ch->GetExchange())
+			{
+				const int64_t nTotalGold = static_cast<int64_t>(ch->GetExchange()->GetCompany()->GetOwner()->GetGold()) + static_cast<int64_t>(pinfo->arg1);
+				if (GOLD_MAX <= nTotalGold)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Yang."));
+
+					sys_err("[OVERFLOW_GOLD] ELK_ADD (%d) id %u name %s ",
+						ch->GetExchange()->GetCompany()->GetOwner()->GetGold(),
+						ch->GetExchange()->GetCompany()->GetOwner()->GetPlayerID(),
+						ch->GetExchange()->GetCompany()->GetOwner()->GetName());
+
+					return;
+				}
+
+				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
+					ch->GetExchange()->AddGold(pinfo->arg1);
+			}
+			break;
+
+#if defined(__CHEQUE_SYSTEM__)
+		case EXCHANGE_SUBHEADER_CG_CHEQUE_ADD: // arg1 == amount of cheque
+			if (ch->GetExchange())
+			{
+				const int64_t nTotalCheque = static_cast<int64_t>(ch->GetExchange()->GetCompany()->GetOwner()->GetCheque()) + static_cast<int64_t>(pinfo->arg1);
+
+				if (nTotalCheque > CHEQUE_MAX)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot exchange as this would exceed the maximum amount of Won."));
+
+					sys_err("[OVERFLOW_CHEQUE] CHEQUE_ADD (%u) id %u name %s ",
+						ch->GetExchange()->GetCompany()->GetOwner()->GetCheque(),
+						ch->GetExchange()->GetCompany()->GetOwner()->GetPlayerID(),
+						ch->GetExchange()->GetCompany()->GetOwner()->GetName());
+
+					return;
+				}
+
+				if (ch->GetExchange()->GetCompany()->GetAcceptStatus() != true)
+					ch->GetExchange()->AddCheque(pinfo->arg1);
+			}
+			break;
+#endif
+
+		case EXCHANGE_SUBHEADER_CG_ACCEPT: // arg1 == not used
+			if (ch->GetExchange())
+			{
+				sys_log(0, "CInputMain()::Exchange() ==> ACCEPT ");
+				ch->GetExchange()->Accept(true);
+			}
+			break;
+
+		case EXCHANGE_SUBHEADER_CG_CANCEL: // arg1 == not used
+			if (ch->GetExchange())
+				ch->GetExchange()->Cancel();
+			break;
+	}
+}
+
+void CInputMain::Position(LPCHARACTER ch, const char* data)
+{
+	struct command_position* pinfo = (struct command_position*)data;
+
+	switch (pinfo->position)
+	{
+		case POSITION_GENERAL:
+			ch->Standup();
+			break;
+
+		case POSITION_SITTING_CHAIR:
+			ch->Sitdown(0);
+			break;
+
+		case POSITION_SITTING_GROUND:
+			ch->Sitdown(1);
+			break;
+	}
+}
+
+static const int ComboSequenceBySkillLevel[3][8] =
+{
+	//	0	1	2	3	4	5	6	7
+	{	14,	15,	16,	17,	0,	0,	0,	0	},
+	{	14,	15,	16,	18,	20,	0,	0,	0	},
+	{	14,	15,	16,	18,	19,	17,	0,	0	},
+};
+
+#define COMBO_HACK_ALLOWABLE_MS 100
+
+bool CheckComboHack(LPCHARACTER ch, BYTE bArg, DWORD dwTime, bool CheckSpeedHack)
+{
+	if (!gHackCheckEnable)
+		return false;
+
+	// ◊∞≈≥  ¬ø   «∑, skip—¥.
+	// Ã∑  , CHRACTER::CanMove() 
+	// if (IsStun() || IsDead()) return false;
+	//  ﬂ∞œ¥¬∞ ¬¥Ÿ∞ œ≥,
+	// Ãπ Ÿ∏ Œ∫–ø CanMove() IsStun(), IsDead()
+	//  √º≈©œ∞ ÷±    
+	// ÷º»≠œ±  Ã∑  ⁄µÂ∏¶ ¬¥.
+	if (ch->IsStun() || ch->IsDead())
+		return false;
+	int ComboInterval = dwTime - ch->GetLastComboTime();
+	int HackScalar = 0; // ‚∫ª ƒÆ  1
+#if 0
+	sys_log(0, "COMBO: %s arg:%u seq:%u delta:%d checkspeedhack:%d",
+		ch->GetName(), bArg, ch->GetComboSequence(), ComboInterval - ch->GetValidComboInterval(), CheckSpeedHack);
+#endif
+	// bArg 14 ~ 21   8ﬁ∫ 
+	// 1. √π ﬁ∫(14)  √∞ ƒø ›∫ 
+	// 2. 15 ~ 21 ›∫ “∞
+	// 3.  ¥ —¥.
+	if (bArg == 14)
+	{
+		if (CheckSpeedHack && ComboInterval > 0 && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
+		{
+			// FIXME √π¬∞ ﬁ∫ Ãªœ∞    ÷æÓº≠ 300  -_-;
+			// Ÿº Õø  Ÿø«¥ »≤  œ∏
+			// √π¬∞ ﬁ∫ ≈ø  Õπ  »≤ ﬂª.
+			// Ã∑  ﬁ∫ ∆® Ï∞° ÷æ  ⁄µ  »∞»≠.
+			//HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 300;
+
+			//sys_log(0, "COMBO_HACK: 2 %s arg:%u interval:%d valid:%u atkspd:%u riding:%s",
+			//	ch->GetName(),
+			//	bArg,
+			//	ComboInterval,
+			//	ch->GetValidComboInterval(),
+			//	ch->GetPoint(POINT_ATT_SPEED),
+			//	ch->IsRiding() ? "yes" : "no"
+			//);
+		}
+
+		ch->SetComboSequence(1);
+		ch->SetValidComboInterval((int)(ani_combo_speed(ch, 1) / (ch->GetPoint(POINT_ATT_SPEED) / 100.f)));
+		ch->SetLastComboTime(dwTime);
+	}
+	else if (bArg > 14 && bArg < 22)
+	{
+		int idx = MIN(2, ch->GetComboIndex());
+
+		if (ch->GetComboSequence() > 5) //  6ﬁ∫ Ãª .
+		{
+			HackScalar = 1;
+			ch->SetValidComboInterval(300);
+			sys_log(0, "COMBO_HACK: 5 %s combo_seq:%d", ch->GetName(), ch->GetComboSequence());
+		}
+		// ⁄∞ ÷º ﬁ∫ √≥
+		else if (bArg == 21 &&
+			idx == 2 &&
+			ch->GetComboSequence() == 5 &&
+			ch->GetJob() == JOB_ASSASSIN &&
+			ch->GetWear(WEAR_WEAPON) &&
+			ch->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_DAGGER
+			)
+			ch->SetValidComboInterval(300);
+		else if (bArg == 21 &&
+			idx == 2 &&
+			ch->GetComboSequence() == 5 &&
+			ch->GetJob() == JOB_WOLFMAN &&
+			ch->GetWear(WEAR_WEAPON) &&
+			ch->GetWear(WEAR_WEAPON)->GetSubType() == WEAPON_CLAW
+			)
+			ch->SetValidComboInterval(300);
+		else if (ComboSequenceBySkillLevel[idx][ch->GetComboSequence()] != bArg)
+		{
+			HackScalar = 1;
+			ch->SetValidComboInterval(300);
+
+			sys_log(0, "COMBO_HACK: 3 %s arg:%u valid:%u combo_idx:%d combo_seq:%d",
+				ch->GetName(),
+				bArg,
+				ComboSequenceBySkillLevel[idx][ch->GetComboSequence()],
+				idx,
+				ch->GetComboSequence());
+		}
+		else
+		{
+			if (CheckSpeedHack && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
+			{
+				HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 100;
+
+				sys_log(0, "COMBO_HACK: 2 %s arg:%u interval:%d valid:%u atkspd:%u riding:%s",
+					ch->GetName(),
+					bArg,
+					ComboInterval,
+					ch->GetValidComboInterval(),
+					ch->GetPoint(POINT_ATT_SPEED),
+					ch->IsRiding() ? "yes" : "no");
+			}
+
+			//    15 ~ 16 ›∫—¥
+			//if (ch->IsHorseRiding())
+			if (ch->IsRiding())
+				ch->SetComboSequence(ch->GetComboSequence() == 1 ? 2 : 1);
+			else
+				ch->SetComboSequence(ch->GetComboSequence() + 1);
+
+			ch->SetValidComboInterval((int)(ani_combo_speed(ch, bArg - 13) / (ch->GetPoint(POINT_ATT_SPEED) / 100.f)));
+			ch->SetLastComboTime(dwTime);
+		}
+	}
+	else if (bArg == 13) // ‚∫ª  (–∞(Polymorph)  ¬¥)
+	{
+		if (CheckSpeedHack && ComboInterval > 0 && ComboInterval < ch->GetValidComboInterval() - COMBO_HACK_ALLOWABLE_MS)
+		{
+			// Ÿº Õø  Ÿø«¥ »≤  œ∏
+			// √π¬∞ ﬁ∫ ≈ø  Õπ  »≤ ﬂª.
+			// Ã∑  ﬁ∫ ∆® Ï∞° ÷æ  ⁄µ  »∞»≠.
+			//HackScalar = 1 + (ch->GetValidComboInterval() - ComboInterval) / 100;
+
+			//sys_log(0, "COMBO_HACK: 6 %s arg:%u interval:%d valid:%u atkspd:%u",
+			//	ch->GetName(),
+			//	bArg,
+			//	ComboInterval,
+			//	ch->GetValidComboInterval(),
+			//	ch->GetPoint(POINT_ATT_SPEED)
+			//);
+		}
+
+		if (ch->GetRaceNum() >= MAIN_RACE_MAX_NUM)
+		{
+			// POLYMORPH_BUG_FIX
+
+			// DELETEME
+			/*
+			const CMotion * pkMotion = CMotionManager::instance().GetMotion(ch->GetRaceNum(), MAKE_MOTION_KEY(MOTION_MODE_GENERAL, MOTION_NORMAL_ATTACK));
+
+			if (!pkMotion)
+				sys_err("cannot find motion by race %u", ch->GetRaceNum());
+			else
+			{
+				//  Ã∂ 1000.f ÿæ  ≈¨Ãæ∆Æ ÷¥œ∏Ãº ”µ 90%
+				//  ÷¥œ∏Ãº  œπ«∑ 900.f —¥.
+				int k = (int) (pkMotion->GetDuration() / ((float) ch->GetPoint(POINT_ATT_SPEED) / 100.f) * 900.f);
+				ch->SetValidComboInterval(k);
+				ch->SetLastComboTime(dwTime);
+			}
+			*/
+			float normalAttackDuration = CMotionManager::instance().GetNormalAttackDuration(ch->GetRaceNum());
+			int k = (int)(normalAttackDuration / ((float)ch->GetPoint(POINT_ATT_SPEED) / 100.f) * 900.f);
+			ch->SetValidComboInterval(k);
+			ch->SetLastComboTime(dwTime);
+			// END_OF_POLYMORPH_BUG_FIX
+		}
+		else
+		{
+			//  »µ«¥ ﬁ∫ ‘¥ ƒø …º?
+			//if (ch->GetDesc()->DelayedDisconnect(number(2, 9)))
+			//{
+			//	LogManager::instance().HackLog("Hacker", ch);
+			//	sys_log(0, "HACKER: %s arg %u", ch->GetName(), bArg);
+			//}
+
+			//  ⁄µ ,  «™ ﬂø  œ∏,
+			//   ŒΩœ¥ Ï∞° ÷¥.
+
+			// ⁄º ,
+			//  poly 0 √≥,
+			// ≈¨Ûø°º  ≈∂ ﬁ± ,  . <- ,  ¬ø .
+			//
+			// ◊∑ ≈¨Ûø°º   ¬∑ ﬂ¥Ÿ¥ ƒø«µÂ∏¶  (arg == 13)
+			//
+			//  race Œ∞Œµ ¬¥  Ã¥!  œø √º≈© ﬂ¥.
+
+			//   œø   ≈¨Ãæ∆Æ «¥ÿº   ∆¥œ∂,
+			//  «¥ÿæ  Œµ...  Ã∑ ÿ≥...
+			// by rtsummit
+		}
+	}
+	else
+	{
+		//  »µ«¥ ﬁ∫ ‘¥ ƒø …º?
+		if (ch->GetDesc()->DelayedDisconnect(number(2, 9)))
+		{
+			LogManager::instance().HackLog("Hacker", ch);
+			sys_log(0, "HACKER: %s arg %u", ch->GetName(), bArg);
+		}
+
+		HackScalar = 10;
+		ch->SetValidComboInterval(300);
+	}
+
+	if (HackScalar)
+	{
+		//  ≈∏≈≥   1.5 ∞     µ ›∑  œ¥ √≥
+		if (get_dword_time() - ch->GetLastMountTime() > 1500)
+			ch->IncreaseComboHackCount(1 + HackScalar);
+
+		ch->SkipComboAttackByTime(ch->GetValidComboInterval());
+	}
+
+	return HackScalar;
+}
+
+void CInputMain::Move(LPCHARACTER ch, const char* data)
+{
+	if (!ch->CanMove())
+		return;
+
+	struct command_move* pinfo = (struct command_move*)data;
+
+	if (pinfo->bFunc >= FUNC_MAX_NUM && !(pinfo->bFunc & 0x80))
+	{
+		sys_err("invalid move type: %s", ch->GetName());
+		return;
+	}
+
+	/*
+	enum EMoveFuncType
+	{
+		FUNC_WAIT,
+		FUNC_MOVE,
+		FUNC_ATTACK,
+		FUNC_COMBO,
+		FUNC_MOB_SKILL,
+		_FUNC_SKILL,
+		FUNC_MAX_NUM,
+		FUNC_SKILL = 0x80,
+	};
+	*/
+
+	// ⁄∑∆Æ  √º≈©
+
+	//if (!test_server) // 20120515  : ◊º (¬∑) Ÿº   Ÿø«∏Èº≠ ›Ω ﬁ∫ ◊¥  ÷æ.
+	{
+		const float fDist = DISTANCE_SQRT((ch->GetX() - pinfo->lX) / 100, (ch->GetY() - pinfo->lY) / 100);
+#ifdef MOUNT_FIX
+		if (((false == ch->IsRiding() && fDist > 750) || fDist > 999) && OXEVENT_MAP_INDEX != ch->GetMapIndex())
+#else
+		if (((false == ch->IsRiding() && fDist > 25) || fDist > 60) && OXEVENT_MAP_INDEX != ch->GetMapIndex())
+#endif
+		{
+			sys_log(0, "MOVE: %s trying to move too far (dist: %.1fm) Riding(%d)", ch->GetName(), fDist, ch->IsRiding());
+
+			ch->Show(ch->GetMapIndex(), ch->GetX(), ch->GetY(), ch->GetZ());
+			ch->Stop();
+			return;
+		}
+
+		//
+		// «µ(SPEEDHACK) Check
+		//
+		int dwCurTime = get_dword_time();
+		// √∞ Syncœ∞ 7   Àª—¥. (20090702  5 ø)
+		bool CheckSpeedHack = (false == ch->GetDesc()->IsHandshaking() && dwCurTime - ch->GetDesc()->GetClientTime() > 7000);
+
+		if (CheckSpeedHack)
+		{
+			int iDelta = (int)(dwCurTime - pinfo->dwTime);
+			int iServerDelta = (int)(dwCurTime - ch->GetDesc()->GetClientTime());
+
+			iDelta = (int)(dwCurTime - pinfo->dwTime);
+
+			// √∞  ∞‘∞. œ¥ Œ±◊∏ ÿµ–¥. ¬• Ã∑   √º≈©ÿæ. TODO
+			if (iDelta >= 30000)
+			{
+				sys_log(0, "SPEEDHACK: slow timer name %s delta %d", ch->GetName(), iDelta);
+				ch->GetDesc()->DelayedDisconnect(3);
+			}
+			// 1 ø 20msec  ¬∞  —¥.
+			else if (iDelta < -(iServerDelta / 50))
+			{
+				sys_log(0, "SPEEDHACK: DETECTED! %s (delta %d %d)", ch->GetName(), iDelta, iServerDelta);
+				ch->GetDesc()->DelayedDisconnect(3);
+			}
+		}
+
+		//
+		// ﬁ∫  «µ √º≈©
+		//
+				if (pinfo->bFunc == FUNC_COMBO && g_bCheckMultiHack)
+		{
+					// [Security] Prevent COMBO spam via forged client timestamps / packets.
+					// Require an actual victim and use server time for interval checks.
+					if (!ch->GetVictim())
+						return;
+		
+					const DWORD dwNow = get_dword_time();
+					CheckComboHack(ch, pinfo->bArg, dwNow, true); // combo check (server-time)
+		}
+	}
+
+	if (pinfo->bFunc == FUNC_MOVE)
+	{
+		if (ch->GetLimitPoint(POINT_MOV_SPEED) == 0)
+			return;
+
+		ch->SetRotation(pinfo->bRot * 5); // ﬂ∫ ⁄µ
+		ch->ResetStopTime(); // ""
+
+		ch->Goto(pinfo->lX, pinfo->lY);
+	}
+	else
+	{
+		if (pinfo->bFunc == FUNC_ATTACK || pinfo->bFunc == FUNC_COMBO)
+			ch->OnMove(true);
+		else if (pinfo->bFunc & FUNC_SKILL)
+		{
+			const int MASK_SKILL_MOTION = 0x7F;
+			unsigned int motion = pinfo->bFunc & MASK_SKILL_MOTION;
+
+			if (!ch->IsUsableSkillMotion(motion))
+			{
+				const char* name = ch->GetName();
+				unsigned int job = ch->GetJob();
+				unsigned int group = ch->GetSkillGroup();
+
+				char szBuf[256];
+				snprintf(szBuf, sizeof(szBuf), "SKILL_HACK: name=%s, job=%d, group=%d, motion=%d", name, job, group, motion);
+				LogManager::Instance().HackLog(szBuf, ch->GetDesc()->GetAccountTable().login, ch->GetName(), ch->GetDesc()->GetHostName());
+				sys_log(0, "%s", szBuf);
+
+				if (test_server)
+				{
+					ch->GetDesc()->DelayedDisconnect(number(2, 8));
+					ch->ChatPacket(CHAT_TYPE_INFO, szBuf);
+				}
+				else
+				{
+					ch->GetDesc()->DelayedDisconnect(number(150, 500));
+				}
+			}
+
+			ch->OnMove();
+		}
+
+		ch->SetRotation(pinfo->bRot * 5); // ﬂ∫ ⁄µ
+		ch->ResetStopTime(); // ""
+
+		ch->Move(pinfo->lX, pinfo->lY);
+		ch->Stop();
+		ch->StopStaminaConsume();
+	}
+
+	TPacketGCMove pack;
+
+	pack.bHeader = HEADER_GC_MOVE;
+	pack.bFunc = pinfo->bFunc;
+	pack.bArg = pinfo->bArg;
+	pack.bRot = pinfo->bRot;
+	pack.dwVID = ch->GetVID();
+	pack.lX = pinfo->lX;
+	pack.lY = pinfo->lY;
+	pack.dwTime = pinfo->dwTime;
+	pack.dwDuration = (pinfo->bFunc == FUNC_MOVE) ? ch->GetCurrentMoveDuration() : 0;
+
+	ch->PacketAround(&pack, sizeof(TPacketGCMove), ch);
+	/*
+		if (pinfo->dwTime == 10653691) //  ﬂ∞
+		{
+			if (ch->GetDesc()->DelayedDisconnect(number(15, 30)))
+				LogManager::instance().HackLog("Debugger", ch);
+
+		}
+		else if (pinfo->dwTime == 10653971) // Softice ﬂ∞
+		{
+			if (ch->GetDesc()->DelayedDisconnect(number(15, 30)))
+				LogManager::instance().HackLog("Softice", ch);
+		}
+	*/
+	/*
+	sys_log(0,
+			"MOVE: %s Func:%u Arg:%u Pos:%dx%d Time:%u Dist:%.1f",
+			ch->GetName(),
+			pinfo->bFunc,
+			pinfo->bArg,
+			pinfo->lX / 100,
+			pinfo->lY / 100,
+			pinfo->dwTime,
+			fDist);
+	*/
+}
+
+void CInputMain::Attack(LPCHARACTER ch, const BYTE header, const char* data)
+{
+	if (NULL == ch)
+		return;
+
+	// [Security] Spectator/observer characters must never be able to attack (packet injection / ghost attack)
+	if (ch->IsObserverMode() || ch->IsDead())
+		return;
+
+	struct type_identifier
+	{
+		BYTE header;
+		BYTE type;
+	};
+
+	const struct type_identifier* const type = reinterpret_cast<const struct type_identifier*>(data);
+
+	if (type->type > 0)
+	{
+		if (false == ch->CanUseSkill(type->type))
+		{
+			return;
+		}
+
+		switch (type->type)
+		{
+			case SKILL_GEOMPUNG:
+			case SKILL_SANGONG:
+			case SKILL_YEONSA:
+			case SKILL_KWANKYEOK:
+			case SKILL_HWAJO:
+			case SKILL_GIGUNG:
+			case SKILL_PABEOB:
+			case SKILL_MARYUNG:
+			case SKILL_TUSOK:
+#if defined(__9TH_SKILL__)
+			case SKILL_ILGWANGPYO:
+			case SKILL_PUNGLOEPO:
+			case SKILL_MABEOBAGGWI:
+			case SKILL_METEO:
+#endif
+			case SKILL_MAHWAN:
+			case SKILL_BIPABU:
+			case SKILL_NOEJEON:
+			case SKILL_CHAIN:
+			case SKILL_HORSE_WILDATTACK_RANGE:
+				if (HEADER_CG_SHOOT != type->header)
+				{
+					if (test_server)
+						ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Attack :name[%s] Vnum[%d] can't use skill by attack(warning)", type->type));
+					return;
+				}
+				break;
+		}
+	}
+
+	switch (header)
+	{
+		case HEADER_CG_ATTACK:
+		{
+			if (NULL == ch->GetDesc())
+				return;
+
+			const TPacketCGAttack* const packMelee = reinterpret_cast<const TPacketCGAttack*>(data);
+
+			ch->GetDesc()->AssembleCRCMagicCube(packMelee->bCRCMagicCubeProcPiece, packMelee->bCRCMagicCubeFilePiece);
+
+			LPCHARACTER victim = CHARACTER_MANAGER::instance().Find(packMelee->dwVID);
+
+			if (NULL == victim || ch == victim)
+				return;
+
+			switch (victim->GetCharType())
+			{
+				case CHAR_TYPE_NPC:
+				case CHAR_TYPE_WARP:
+				case CHAR_TYPE_GOTO:
+				case CHAR_TYPE_HORSE:
+					//#if defined(__GROWTH_PET_SYSTEM__)
+				case CHAR_TYPE_PET:
+					//#endif
+				case CHAR_TYPE_PET_PAY:
+				case CHAR_TYPE_SHOP:
+					return;
+			}
+
+			if (packMelee->bType > 0)
+			{
+				if (false == ch->CheckSkillHitCount(packMelee->bType, victim->GetVID()))
+				{
+					return;
+				}
+			}
+
+			ch->Attack(victim, packMelee->bType);
+		}
+		break;
+
+		case HEADER_CG_SHOOT:
+		{
+			const TPacketCGShoot* const packShoot = reinterpret_cast<const TPacketCGShoot*>(data);
+
+			ch->Shoot(packShoot->bType);
+		}
+		break;
+	}
+}
+
+int CInputMain::SyncPosition(LPCHARACTER ch, const char* c_pcData, size_t uiBytes)
+{
+	const TPacketCGSyncPosition* pinfo = reinterpret_cast<const TPacketCGSyncPosition*>(c_pcData);
+
+	if (uiBytes < pinfo->wSize)
+		return -1;
+
+	int iExtraLen = pinfo->wSize - sizeof(TPacketCGSyncPosition);
+
+	if (iExtraLen < 0)
+	{
+		sys_err("invalid packet length (len %d size %u buffer %u)", iExtraLen, pinfo->wSize, uiBytes);
+		ch->GetDesc()->SetPhase(PHASE_CLOSE);
+		return -1;
+	}
+
+	if (0 != (iExtraLen % sizeof(TPacketCGSyncPositionElement)))
+	{
+		sys_err("invalid packet length %d (name: %s)", pinfo->wSize, ch->GetName());
+		return iExtraLen;
+	}
+
+	int iCount = iExtraLen / sizeof(TPacketCGSyncPositionElement);
+
+	if (iCount <= 0)
+		return iExtraLen;
+
+	static const int nCountLimit = 16;
+
+	if (iCount > nCountLimit)
+	{
+		// LogManager::instance().HackLog( "SYNC_POSITION_HACK", ch );
+		sys_err("Too many SyncPosition Count(%d) from Name(%s)", iCount, ch->GetName());
+		// ch->GetDesc()->SetPhase(PHASE_CLOSE);
+		// return -1;
+		iCount = nCountLimit;
+	}
+
+	TEMP_BUFFER tbuf;
+	LPBUFFER lpBuf = tbuf.getptr();
+
+	TPacketGCSyncPosition* pHeader = (TPacketGCSyncPosition*)buffer_write_peek(lpBuf);
+	buffer_write_proceed(lpBuf, sizeof(TPacketGCSyncPosition));
+
+	const TPacketCGSyncPositionElement* e =
+		reinterpret_cast<const TPacketCGSyncPositionElement*>(c_pcData + sizeof(TPacketCGSyncPosition));
+
+	timeval tvCurTime;
+	gettimeofday(&tvCurTime, NULL);
+
+	for (int i = 0; i < iCount; ++i, ++e)
+	{
+		LPCHARACTER victim = CHARACTER_MANAGER::instance().Find(e->dwVID);
+
+		if (!victim)
+			continue;
+
+		switch (victim->GetCharType())
+		{
+			case CHAR_TYPE_NPC:
+			case CHAR_TYPE_WARP:
+			case CHAR_TYPE_GOTO:
+			case CHAR_TYPE_HORSE:
+				//#if defined(__GROWTH_PET_SYSTEM__)
+			case CHAR_TYPE_PET:
+				//#endif
+			case CHAR_TYPE_PET_PAY:
+			case CHAR_TYPE_SHOP:
+				continue;
+		}
+
+		//  Àª
+		if (!victim->SetSyncOwner(ch))
+			continue;
+
+		const float fDistWithSyncOwner = DISTANCE_SQRT((victim->GetX() - ch->GetX()) / 100, (victim->GetY() - ch->GetY()) / 100);
+		static const float fLimitDistWithSyncOwner = 2500.f + 1000.f;
+		// victim ≈∏ 2500 + a ÃªÃ∏  .
+		// ≈∏  : ≈¨Ãæ∆Æ __GetSkillTargetRange, __GetBowRange ‘º
+		// 2500 : ≈≥ proto  ≈∏  ≈≥ ≈∏, «¥ »∞ ≈∏
+		// a = POINT_BOW_DISTANCE ... Œµ  œ¥   ∏£∞. Ã≥ , ≈≥, ∆Æ ¬µ...
+		// ◊∑ »§√≥ œ¥  €∑  ÿº 1000.f  ...
+		if (fDistWithSyncOwner > fLimitDistWithSyncOwner)
+		{
+			// g_iSyncHackLimitCount  .
+			if (ch->GetSyncHackCount() < g_iSyncHackLimitCount)
+			{
+				ch->SetSyncHackCount(ch->GetSyncHackCount() + 1);
+				continue;
+			}
+			else
+			{
+				LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
+
+				sys_err("Too far SyncPosition DistanceWithSyncOwner(%f)(%s) from Name(%s) CH(%d,%d) VICTIM(%d,%d) SYNC(%d,%d)",
+					fDistWithSyncOwner, victim->GetName(), ch->GetName(), ch->GetX(), ch->GetY(), victim->GetX(), victim->GetY(),
+					e->lX, e->lY);
+
+				ch->GetDesc()->SetPhase(PHASE_CLOSE);
+
+				return -1;
+			}
+		}
+
+		const float fDist = DISTANCE_SQRT((victim->GetX() - e->lX) / 100, (victim->GetY() - e->lY) / 100);
+		static const long g_lValidSyncInterval = 100 * 1000; // 100ms
+		const timeval& tvLastSyncTime = victim->GetLastSyncTime();
+		timeval* tvDiff = timediff(&tvCurTime, &tvLastSyncTime);
+
+		// SyncPosition «øœø ≈∏ Ãª    œ± œø,
+		//   g_lValidSyncInterval ms Ã≥ ŸΩ SyncPositionœ∑ œ∏  .
+		if (tvDiff->tv_sec == 0 && tvDiff->tv_usec < g_lValidSyncInterval)
+		{
+			// g_iSyncHackLimitCount  .
+			if (ch->GetSyncHackCount() < g_iSyncHackLimitCount)
+			{
+				ch->SetSyncHackCount(ch->GetSyncHackCount() + 1);
+				continue;
+			}
+			else
+			{
+				LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
+
+				sys_err("Too often SyncPosition Interval(%ldms)(%s) from Name(%s) VICTIM(%d,%d) SYNC(%d,%d)",
+					tvDiff->tv_sec * 1000 + tvDiff->tv_usec / 1000, victim->GetName(), ch->GetName(), victim->GetX(), victim->GetY(),
+					e->lX, e->lY);
+
+				ch->GetDesc()->SetPhase(PHASE_CLOSE);
+
+				return -1;
+			}
+		}
+		else if (fDist > 25.0f)
+		{
+			LogManager::instance().HackLog("SYNC_POSITION_HACK", ch);
+
+			sys_err("Too far SyncPosition Distance(%f)(%s) from Name(%s) CH(%d,%d) VICTIM(%d,%d) SYNC(%d,%d)",
+				fDist, victim->GetName(), ch->GetName(), ch->GetX(), ch->GetY(), victim->GetX(), victim->GetY(),
+				e->lX, e->lY);
+
+			ch->GetDesc()->SetPhase(PHASE_CLOSE);
+
+			return -1;
+		}
+		else
+		{
+			victim->SetLastSyncTime(tvCurTime);
+			victim->Sync(e->lX, e->lY);
+			buffer_write(lpBuf, e, sizeof(TPacketCGSyncPositionElement));
+		}
+	}
+
+	if (buffer_size(lpBuf) != sizeof(TPacketGCSyncPosition))
+	{
+		pHeader->bHeader = HEADER_GC_SYNC_POSITION;
+		pHeader->wSize = buffer_size(lpBuf);
+
+		ch->PacketAround(buffer_read_peek(lpBuf), buffer_size(lpBuf), ch);
+	}
+
+	return iExtraLen;
+}
+
+void CInputMain::FlyTarget(LPCHARACTER ch, const char* pcData, BYTE bHeader)
+{
+	TPacketCGFlyTargeting* p = (TPacketCGFlyTargeting*)pcData;
+	ch->FlyTarget(p->dwTargetVID, p->x, p->y, bHeader);
+}
+
+void CInputMain::UseSkill(LPCHARACTER ch, const char* pcData)
+{
+	TPacketCGUseSkill* p = (TPacketCGUseSkill*)pcData;
+	ch->UseSkill(p->dwVnum, CHARACTER_MANAGER::instance().Find(p->dwVID));
+}
+
+void CInputMain::ScriptButton(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGScriptButton* p = (TPacketCGScriptButton*)c_pData;
+	sys_log(0, "QUEST ScriptButton pid %d idx %u", ch->GetPlayerID(), p->idx);
+
+	quest::PC* pc = quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID());
+	if (pc && pc->IsConfirmWait())
+	{
+		quest::CQuestManager::instance().Confirm(ch->GetPlayerID(), quest::CONFIRM_TIMEOUT);
+	}
+	else if (p->idx & 0x80000000)
+	{
+		quest::CQuestManager::Instance().QuestInfo(ch->GetPlayerID(), p->idx & 0x7fffffff);
+	}
+	else
+	{
+		quest::CQuestManager::Instance().QuestButton(ch->GetPlayerID(), p->idx);
+	}
+}
+
+void CInputMain::ScriptAnswer(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGScriptAnswer* p = (TPacketCGScriptAnswer*)c_pData;
+	sys_log(0, "QUEST ScriptAnswer pid %d answer %d", ch->GetPlayerID(), p->answer);
+
+	if (p->answer > 250) //  ∆∞    ≈∂ 
+	{
+		quest::CQuestManager::Instance().Resume(ch->GetPlayerID());
+	}
+	else //  ∆∞   ≈∂ 
+	{
+		quest::CQuestManager::Instance().Select(ch->GetPlayerID(), p->answer);
+	}
+}
+
+// SCRIPT_SELECT_ITEM
+void CInputMain::ScriptSelectItem(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGScriptSelectItem* p = (TPacketCGScriptSelectItem*)c_pData;
+	sys_log(0, "QUEST ScriptSelectItem pid %d answer %d", ch->GetPlayerID(), p->selection);
+	quest::CQuestManager::Instance().SelectItem(ch->GetPlayerID(), p->selection);
+}
+// END_OF_SCRIPT_SELECT_ITEM
+
+#if defined(__GEM_SYSTEM__)
+void CInputMain::SelectItemEx(LPCHARACTER c_lpCh, const void* c_pvData)
+{
+	if (c_lpCh == nullptr)
+		return;
+
+	TPacketCGSelectItemEx* pPacket = (TPacketCGSelectItemEx*)c_pvData;
+	sys_log(0, "SelectItemEx player (pid: %d) item (pos: %d)", c_lpCh->GetPlayerID(), pPacket->dwItemPos);
+	c_lpCh->SelectItemEx(pPacket->dwItemPos, pPacket->bType);
+}
+#endif
+
+#if defined(__QUEST_REQUEST_EVENT__)
+void CInputMain::RequestEventQuest(LPCHARACTER pChar, const void* c_pvData)
+{
+	const TPacketCGRequestEventQuest* c_pData = reinterpret_cast<const TPacketCGRequestEventQuest*>(c_pvData);
+	unsigned int uiQuestIndex = quest::CQuestManager::instance().GetQuestIndexByName(c_pData->szEventQuest);
+	if (uiQuestIndex)
+	{
+		if (quest::CQuestManager::instance().GetPCForce(pChar->GetPlayerID())->IsRunning())
+			return;
+
+		sys_log(0, "QUEST RequestEventQuest pid(%d), qid(%d)", pChar->GetPlayerID(), uiQuestIndex);
+		quest::CQuestManager::instance().RequestEvent(pChar->GetPlayerID(), uiQuestIndex, 0);
+	}
+}
+#endif
+
+void CInputMain::QuestInputString(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGQuestInputString* p = (TPacketCGQuestInputString*)c_pData;
+
+	char msg[65];
+	strlcpy(msg, p->msg, sizeof(msg));
+	sys_log(0, "QUEST InputString pid %u msg %s", ch->GetPlayerID(), msg);
+
+	quest::CQuestManager::Instance().Input(ch->GetPlayerID(), msg);
+}
+
+#if defined(__OX_RENEWAL__)
+void CInputMain::QuestInputLongString(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGQuestInputLongString* p = (TPacketCGQuestInputLongString*)c_pData;
+
+	char msg[129];
+	strlcpy(msg, p->msg, sizeof(msg));
+	sys_log(0, "QUEST InputLongString pid %u msg %s", ch->GetPlayerID(), msg);
+
+	quest::CQuestManager::Instance().Input(ch->GetPlayerID(), msg);
+}
+#endif
+
+void CInputMain::QuestConfirm(LPCHARACTER ch, const void* c_pData)
+{
+	TPacketCGQuestConfirm* p = (TPacketCGQuestConfirm*)c_pData;
+	LPCHARACTER ch_wait = CHARACTER_MANAGER::instance().FindByPID(p->requestPID);
+	if (p->answer)
+		p->answer = quest::CONFIRM_YES;
+	sys_log(0, "QuestConfirm from %s pid %u name %s answer %d", ch->GetName(), p->requestPID, (ch_wait) ? ch_wait->GetName() : "", p->answer);
+	if (ch_wait)
+	{
+		quest::CQuestManager::Instance().Confirm(ch_wait->GetPlayerID(), (quest::EQuestConfirmType)p->answer, ch->GetPlayerID());
+	}
+}
+
+void CInputMain::Target(LPCHARACTER ch, const char* pcData)
+{
+	TPacketCGTarget* p = (TPacketCGTarget*)pcData;
+
+	building::LPOBJECT pkObj = building::CManager::instance().FindObjectByVID(p->dwVID);
+
+	if (pkObj)
+	{
+		TPacketGCTarget pckTarget;
+		pckTarget.header = HEADER_GC_TARGET;
+		pckTarget.dwVID = p->dwVID;
+#if defined(__DEFENSE_WAVE__)
+		pckTarget.bAlliance = false;
+#endif
+		ch->GetDesc()->Packet(&pckTarget, sizeof(TPacketGCTarget));
+	}
+	else
+		ch->SetTarget(CHARACTER_MANAGER::instance().Find(p->dwVID));
+}
+
+void CInputMain::Warp(LPCHARACTER ch, const char* pcData)
+{
+	ch->WarpEnd();
+}
+
+void CInputMain::SafeboxCheckin(LPCHARACTER ch, const char* c_pData)
+{
+	if (quest::CQuestManager::instance().GetPCForce(ch->GetPlayerID())->IsRunning() == true)
+		return;
+
+	if (ch->IsDead())
+		return;
+
+	// Prevent packet injection when safebox is not actually open
+	if (!ch->IsOpenSafebox())
+		return;
+
+	TPacketCGSafeboxCheckin* p = (TPacketCGSafeboxCheckin*)c_pData;
+
+	if (!ch->CanHandleItem())
+		return;
+
+	// [Security] Mutual exclusion: forbid safebox actions while other trade windows are open
+	if (!ch->IsOpenSafebox())
+		return;
+	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
+		return;
+
+	CSafebox* pkSafebox = ch->GetSafebox();
+	LPITEM pkItem = ch->GetItem(p->ItemPos);
+
+	if (!pkSafebox || !pkItem)
+		return;
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	if (pkItem->GetCell() >= ch->GetExtendInvenMax() && IS_SET(pkItem->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+#else
+	if (pkItem->GetCell() >= INVENTORY_MAX_NUM && IS_SET(pkItem->GetFlag(), ITEM_FLAG_IRREMOVABLE))
+#endif
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢> √¢ ≈±    ‘¥œ¥."));
+		return;
+	}
+
+	if (!pkSafebox->IsEmpty(p->bSafePos, pkItem->GetSize()))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢> ≈±   ƒ°‘¥œ¥."));
+		return;
+	}
+
+	if (pkItem->GetSIGVnum() == UNIQUE_GROUP_LARGE_SAFEBOX)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢>     œ¥."));
+		return;
+	}
+
+	if (IS_SET(pkItem->GetAntiFlag(), ITEM_ANTIFLAG_SAFEBOX))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢>     œ¥."));
+		return;
+	}
+
+	if (pkItem->IsEquipped())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Storeroom] An item that is currently being used cannot be stored."));
+		return;
+	}
+
+#if defined(__PET_SYSTEM__)
+	CPetSystem* pPetSystem = ch->GetPetSystem();
+	if (pPetSystem && pPetSystem->GetSummonItemVID() == pkItem->GetVID())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("[Storeroom] An item that is currently being used cannot be stored."));
+		return;
+	}
+#endif
+
+	if (true == pkItem->isLocked())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢>     œ¥."));
+		return;
+	}
+
+	// Prevent items from the belt inventory checking-in the safebox.
+	if (p->ItemPos.window_type == BELT_INVENTORY)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Cannot proceed."));
+		return;
+	}
+
+	pkItem->RemoveFromCharacter();
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (!pkItem->IsDragonSoul())
+#endif
+		ch->SyncQuickslot(SLOT_TYPE_INVENTORY, p->ItemPos.cell, WORD_MAX);
+
+	pkSafebox->Add(p->bSafePos, pkItem);
+#ifdef __GROWTH_PET_SYSTEM__
+	if (pkItem->GetType() == ITEM_PET)
+	{
+		if (pkItem->GetSubType() == PET_UPBRINGING || pkItem->GetSubType() == PET_BAG)
+		{
+			LPGROWTH_PET pPet = ch->GetGrowthPet(pkItem->GetSocket(2));
+			if (pPet)
+				pkSafebox->AddPet(pPet);
+		}
+	}
+#endif
+	char szHint[128];
+	snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
+	LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX PUT", szHint);
+}
+
+void CInputMain::SafeboxCheckout(LPCHARACTER ch, const char* c_pData, bool bMall)
+{
+	TPacketCGSafeboxCheckout* p = (TPacketCGSafeboxCheckout*)c_pData;
+
+	if (ch->IsDead())
+		return;
+
+	// Prevent packet injection when safebox/mall is not actually open
+	if (!ch->IsOpenSafebox())
+		return;
+
+	if (!ch->CanHandleItem())
+		return;
+
+	// [Security] Mutual exclusion: safebox operations must not be possible alongside exchange/shop/cube (packet overlap / dup prevention)
+	if (!bMall && !ch->IsOpenSafebox())
+		return;
+	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
+		return;
+
+	CSafebox* pkSafebox;
+
+	if (bMall)
+		pkSafebox = ch->GetMall();
+	else
+		pkSafebox = ch->GetSafebox();
+
+	if (!pkSafebox)
+		return;
+
+	LPITEM pkItem = pkSafebox->Get(p->bSafePos);
+	if (!pkItem)
+		return;
+
+	if (p->ItemPos.IsBeltInventoryPosition())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Cannot proceed."));
+		return;
+	}
+
+#if defined(__SAFEBOX_IMPROVING__)
+	if ((p->ItemPos.window_type == INVENTORY) && (p->ItemPos.cell == 0))
+	{
+		BYTE bWindow = INVENTORY;
+		INT iCell = -1;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (pkItem->IsDragonSoul())
+		{
+			bWindow = DRAGON_SOUL_INVENTORY;
+			iCell = ch->GetEmptyDragonSoulInventory(pkItem);
+		}
+
+		else
+#endif
+		{
+			bWindow = INVENTORY;
+			iCell = ch->GetEmptyInventory(pkItem->GetSize());
+		}
+
+
+		if (iCell < 0)
+			return;
+
+		pkSafebox->Remove(p->bSafePos);
+		if (bMall)
+		{
+			if (NULL == pkItem->GetProto())
+			{
+				sys_err("pkItem->GetProto() == NULL (id : %d)", pkItem->GetID());
+				return;
+			}
+			// 100% »Æ ”º Ÿæ œ¥¬µ  Ÿæ÷¥Ÿ∏  . ...............
+			if (100 == pkItem->GetProto()->bAlterToMagicItemPct && 0 == pkItem->GetAttributeCount())
+			{
+				pkItem->AlterToMagicItem(number(40, 50), number(10, 15));
+			}
+		}
+		pkItem->AddToCharacter(ch, TItemPos(bWindow, (WORD)iCell)
+#if defined(__WJ_PICKUP_ITEM_EFFECT__)
+			, false
+#endif
+		);
+		ITEM_MANAGER::Instance().FlushDelayedSave(pkItem);
+
+		DWORD dwID = pkItem->GetID();
+		db_clientdesc->DBPacketHeader(HEADER_GD_ITEM_FLUSH, 0, sizeof(DWORD));
+		db_clientdesc->Packet(&dwID, sizeof(DWORD));
+
+		char szHint[128];
+		snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
+		if (bMall)
+			LogManager::instance().ItemLog(ch, pkItem, "MALL GET", szHint);
+		else
+			LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX GET", szHint);
+
+		return;
+	}
+#endif
+
+	if (!ch->IsEmptyItemGrid(p->ItemPos, pkItem->GetSize()))
+		return;
+
+	//   Œ∫ ≈± Œ∫–ø »• ∆Ø √≥
+	// (   item_proto «µ»¥ ”º Ÿ± ,
+	// »• ,  √≥   ”º œ≥   ∞ »¥.)
+#if defined(__DRAGON_SOUL_SYSTEM__)
+	if (pkItem->IsDragonSoul())
+	{
+		if (bMall)
+		{
+			DSManager::instance().DragonSoulItemInitialize(pkItem);
+		}
+
+		if (DRAGON_SOUL_INVENTORY != p->ItemPos.window_type)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢> ≈±   ƒ°‘¥œ¥."));
+			return;
+		}
+
+		TItemPos DestPos = p->ItemPos;
+		if (!DSManager::instance().IsValidCellForThisItem(pkItem, DestPos))
+		{
+			int iCell = ch->GetEmptyDragonSoulInventory(pkItem);
+			if (iCell < 0)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢> ≈±   ƒ°‘¥œ¥."));
+				return;
+			}
+			DestPos = TItemPos(DRAGON_SOUL_INVENTORY, iCell);
+		}
+
+		pkSafebox->Remove(p->bSafePos);
+		pkItem->AddToCharacter(ch, DestPos);
+		ITEM_MANAGER::instance().FlushDelayedSave(pkItem);
+	}
+	else
+#endif
+	{
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		if (DRAGON_SOUL_INVENTORY == p->ItemPos.window_type)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<√¢> ≈±   ƒ°‘¥œ¥."));
+			return;
+		}
+#endif
+
+		pkSafebox->Remove(p->bSafePos);
+		if (bMall)
+		{
+			if (NULL == pkItem->GetProto())
+			{
+				sys_err("pkItem->GetProto() == NULL (id : %d)", pkItem->GetID());
+				return;
+			}
+			// 100% »Æ ”º Ÿæ œ¥¬µ  Ÿæ÷¥Ÿ∏  . ...............
+			if (100 == pkItem->GetProto()->bAlterToMagicItemPct && 0 == pkItem->GetAttributeCount())
+			{
+				pkItem->AlterToMagicItem(number(40, 50), number(10, 15));
+			}
+		}
+		pkItem->AddToCharacter(ch, p->ItemPos);
+		ITEM_MANAGER::instance().FlushDelayedSave(pkItem);
+#ifdef __GROWTH_PET_SYSTEM__
+		if (pkItem->GetType() == ITEM_PET)
+		{
+			if (pkItem->GetSubType() == PET_UPBRINGING || pkItem->GetSubType() == PET_BAG)
+				pkSafebox->RemovePet(pkItem);
+		}
+#endif
+	}
+
+	DWORD dwID = pkItem->GetID();
+	db_clientdesc->DBPacketHeader(HEADER_GD_ITEM_FLUSH, 0, sizeof(DWORD));
+	db_clientdesc->Packet(&dwID, sizeof(DWORD));
+
+	char szHint[128];
+	snprintf(szHint, sizeof(szHint), "%s %u", pkItem->GetName(), pkItem->GetCount());
+	if (bMall)
+		LogManager::instance().ItemLog(ch, pkItem, "MALL GET", szHint);
+	else
+		LogManager::instance().ItemLog(ch, pkItem, "SAFEBOX GET", szHint);
+}
+
+void CInputMain::SafeboxItemMove(LPCHARACTER ch, const char* data)
+{
+	struct command_item_move* pinfo = (struct command_item_move*)data;
+
+	if (ch->IsDead())
+		return;
+
+	if (!ch->IsOpenSafebox())
+		return;
+
+	if (!ch->CanHandleItem())
+		return;
+
+	// [Security] Mutual exclusion: block safebox operations while other trade windows are open
+	if (!ch->IsOpenSafebox())
+		return;
+	if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->GetShopOwner() || ch->IsCubeOpen())
+		return;
+
+	if (!ch->GetSafebox())
+		return;
+
+	ch->GetSafebox()->MoveItem(pinfo->Cell.cell, pinfo->CellTo.cell, pinfo->count);
+}
+
+// PARTY_JOIN_BUG_FIX
+void CInputMain::PartyInvite(LPCHARACTER ch, const char* c_pData)
+{
+	if (!ch)
+		return;
+
+	if (ch->IsDead())
+		return;
+
+	if (ch->GetArena())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Âø° œΩ  œ¥."));
+		return;
+	}
+
+	if (m_iBufferLeft < (int)sizeof(TPacketCGPartyInvite))
+	{
+		sys_err("PARTY_INVITE: malformed packet (len=%d < %u)", m_iBufferLeft, (unsigned)sizeof(TPacketCGPartyInvite));
+		return;
+	}
+
+	TPacketCGPartyInvite* p = (TPacketCGPartyInvite*)c_pData;
+
+	LPCHARACTER pInvitee = CHARACTER_MANAGER::instance().Find(p->vid);
+	if (ch == pInvitee)
+		return;
+
+	if (!pInvitee || !ch->GetDesc() || !pInvitee->GetDesc() || !pInvitee->IsPC() || !ch->IsPC())
+	{
+		sys_err("PARTY Cannot find invited character");
+		return;
+	}
+
+	if (pInvitee->IsDead())
+		return;
+
+	// Visibility / world safety: must be in-world and same map
+	if (!ch->GetSectree() || !pInvitee->GetSectree())
+		return;
+	if (ch->GetMapIndex() != pInvitee->GetMapIndex())
+		return;
+
+	// Proximity enforcement
+	if (ch->GetDist(pInvitee) >= EXCHANGE_MAX_DISTANCE)
+		return;
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+	if (CMessengerManager::instance().IsBlocked(ch->GetName(), pInvitee->GetName()))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", pInvitee->GetName()));
+		return;
+	}
+	else if (CMessengerManager::instance().IsBlocked(pInvitee->GetName(), ch->GetName()))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", pInvitee->GetName()));
+		return;
+	}
+#endif
+
+	ch->PartyInvite(pInvitee);
+}
+
+void CInputMain::PartyInviteAnswer(LPCHARACTER ch, const char* c_pData)
+{
+	if (!ch)
+		return;
+
+	if (ch->GetArena())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Âø° œΩ  œ¥."));
+		return;
+	}
+
+	if (m_iBufferLeft < (int)sizeof(TPacketCGPartyInviteAnswer))
+	{
+		sys_err("PARTY_INVITE_ANSWER: malformed packet (len=%d < %u)", m_iBufferLeft, (unsigned)sizeof(TPacketCGPartyInviteAnswer));
+		return;
+	}
+
+	TPacketCGPartyInviteAnswer* p = (TPacketCGPartyInviteAnswer*)c_pData;
+
+	LPCHARACTER pInviter = CHARACTER_MANAGER::instance().Find(p->leader_vid);
+
+	// pInviter  ch  ∆º √ª ﬂæ.
+
+	if (!pInviter || !pInviter->IsPC())
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º> ∆º√ª  ƒ≥Õ∏ √£ œ¥."));
+	else if (!p->accept)
+		pInviter->PartyInviteDeny(ch->GetPlayerID());
+	else
+		pInviter->PartyInviteAccept(ch);
+}
+// END_OF_PARTY_JOIN_BUG_FIX
+
+void CInputMain::PartySetState(LPCHARACTER ch, const char* c_pData)
+{
+	if (!CPartyManager::instance().IsEnablePCParty())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º>   ∆º  √≥   œ¥."));
+		return;
+	}
+
+	TPacketCGPartySetState* p = (TPacketCGPartySetState*)c_pData;
+
+	if (!ch->GetParty())
+		return;
+
+	if (ch->GetParty()->GetLeaderPID() != ch->GetPlayerID())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º>    ÷Ωœ¥."));
+		return;
+	}
+
+	if (!ch->GetParty()->IsMember(p->pid))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º> ¬∏ œ∑  ∆º ∆¥’¥œ¥."));
+		return;
+	}
+
+	DWORD pid = p->pid;
+	sys_log(0, "PARTY SetRole pid %d to role %d state %s", pid, p->byRole, p->flag ? "on" : "off");
+
+	switch (p->byRole)
+	{
+		case PARTY_ROLE_NORMAL:
+			break;
+
+		case PARTY_ROLE_ATTACKER:
+		case PARTY_ROLE_TANKER:
+		case PARTY_ROLE_BUFFER:
+		case PARTY_ROLE_SKILL_MASTER:
+		case PARTY_ROLE_HASTE:
+		case PARTY_ROLE_DEFENDER:
+			if (ch->GetParty()->SetRole(pid, p->byRole, p->flag))
+			{
+				TPacketPartyStateChange pack;
+				pack.dwLeaderPID = ch->GetPlayerID();
+				pack.dwPID = p->pid;
+				pack.bRole = p->byRole;
+				pack.bFlag = p->flag;
+				db_clientdesc->DBPacket(HEADER_GD_PARTY_STATE_CHANGE, 0, &pack, sizeof(pack));
+			}
+			/*
+			else
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º> ƒø  œøœ¥."));
+			*/
+			break;
+
+		default:
+			sys_err("wrong byRole in PartySetState Packet name %s state %d", ch->GetName(), p->byRole);
+			break;
+	}
+}
+
+void CInputMain::PartyRemove(LPCHARACTER ch, const char* c_pData)
+{
+	if (ch->GetArena())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Âø° œΩ  œ¥."));
+		return;
+	}
+
+	if (!CPartyManager::instance().IsEnablePCParty())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º>   ∆º  √≥   œ¥."));
+		return;
+	}
+
+#if defined(__GUILD_DRAGONLAIR_PARTY_SYSTEM__)
+	if (ch->GetGuildDragonLair())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot disband the group while you are still active in Meley's Lair."));
+		return;
+	}
+#endif
+
+	TPacketCGPartyRemove* p = (TPacketCGPartyRemove*)c_pData;
+	LPPARTY pParty = ch->GetParty();
+
+	if (!pParty)
+		return;
+
+	if (pParty->GetDungeon_for_Only_party())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º>  »ø ∆º   œ¥."));
+		return;
+	}
+
+	if (pParty->GetLeaderPID() == ch->GetPlayerID())
+	{
+		if (ch->GetDungeon()
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+			|| ch->GetGuildDragonLair()
+#endif
+#if defined(__DEFENSE_WAVE__)
+			|| ch->GetDefenseWave()
+#endif
+			)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º>  ∆º ﬂπ  œ¥."));
+		}
+		else
+		{
+#ifdef ENABLE_QUEEN_NETHIS
+			if (SnakeLair::CSnk::instance().IsSnakeMap(ch->GetMapIndex()))
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º>  ∆º ﬂπ  œ¥."));
+				return;
+			}
+#endif
+			// leader can remove any member
+			if (p->pid == ch->GetPlayerID() || pParty->GetMemberCount() == 2)
+			{
+				// party disband
+				CPartyManager::instance().DeleteParty(pParty);
+			}
+			else
+			{
+				LPCHARACTER B = CHARACTER_MANAGER::instance().FindByPID(p->pid);
+				if (B)
+				{
+					//pParty->SendPartyRemoveOneToAll(B);
+					B->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º> ∆º ﬂπœºÃΩœ¥."));
+					//pParty->Unlink(B);
+					//CPartyManager::instance().SetPartyMember(B->GetPlayerID(), NULL);
+				}
+				pParty->Quit(p->pid);
+			}
+		}
+	}
+	else
+	{
+		// otherwise, only remove itself
+		if (p->pid == ch->GetPlayerID())
+		{
+			if (ch->GetDungeon()
+#if defined(__GUILD_DRAGONLAIR_SYSTEM__)
+				|| ch->GetGuildDragonLair()
+#endif
+#if defined(__DEFENSE_WAVE__)
+				|| ch->GetDefenseWave()
+#endif
+				)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º>  ∆º   œ¥."));
+			}
+			else
+			{
+#ifdef ENABLE_QUEEN_NETHIS
+				if (SnakeLair::CSnk::instance().IsSnakeMap(ch->GetMapIndex()))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º>  ∆º ﬂπ  œ¥."));
+					return;
+				}
+#endif
+				if (pParty->GetMemberCount() == 2)
+				{
+					// party disband
+					CPartyManager::instance().DeleteParty(pParty);
+				}
+				else
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º> ∆º ÃΩœ¥."));
+					//pParty->SendPartyRemoveOneToAll(ch);
+					pParty->Quit(ch->GetPlayerID());
+					//pParty->SendPartyRemoveAllToOne(ch);
+					//CPartyManager::instance().SetPartyMember(ch->GetPlayerID(), NULL);
+				}
+			}
+		}
+		else
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º> Ÿ∏ ∆º ≈ª≈≥  œ¥."));
+		}
+	}
+}
+
+void CInputMain::AnswerMakeGuild(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGAnswerMakeGuild* p = (TPacketCGAnswerMakeGuild*)c_pData;
+
+	if (ch->GetGold() < 200000)
+		return;
+
+	if (ch->GetLevel() < 40)
+		return;
+
+	if (get_global_time() - ch->GetQuestFlag("guild_manage.new_disband_time") <
+		CGuildManager::instance().GetDisbandDelay())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> ÿª  %d Ã≥ Â∏¶   œ¥.",
+			quest::CQuestManager::instance().GetEventFlag("guild_disband_delay")));
+		return;
+	}
+
+	if (get_global_time() - ch->GetQuestFlag("guild_manage.new_withdraw_time") <
+		CGuildManager::instance().GetWithdrawDelay())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> ≈ª  %d Ã≥ Â∏¶   œ¥.",
+			quest::CQuestManager::instance().GetEventFlag("guild_withdraw_delay")));
+		return;
+	}
+
+	if (ch->GetGuild())
+		return;
+
+	CGuildManager& gm = CGuildManager::instance();
+
+	TGuildCreateParameter cp;
+	memset(&cp, 0, sizeof(cp));
+
+	cp.master = ch;
+	strlcpy(cp.name, p->guild_name, sizeof(cp.name));
+
+	if (cp.name[0] == 0 || !check_name(cp.name))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("   Ã∏ ‘¥œ¥."));
+		return;
+	}
+
+	DWORD dwGuildID = gm.CreateGuild(cp);
+
+	if (dwGuildID)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> [%s] Â∞° «æœ¥.", cp.name));
+
+		int GuildCreateFee;
+
+		if (LC_IsBrazil())
+		{
+			GuildCreateFee = 500000;
+		}
+		else
+		{
+			GuildCreateFee = 200000;
+		}
+
+		ch->PointChange(POINT_GOLD, -GuildCreateFee);
+		DBManager::instance().SendMoneyLog(MONEY_LOG_GUILD, ch->GetPlayerID(), -GuildCreateFee);
+
+		char Log[128];
+		snprintf(Log, sizeof(Log), "GUILD_NAME %s MASTER %s", cp.name, ch->GetName());
+		LogManager::instance().CharLog(ch, 0, "MAKE_GUILD", Log);
+
+		if (g_iUseLocale)
+			ch->RemoveSpecifyItem(GUILD_CREATE_ITEM_VNUM, 1);
+		//ch->SendGuildName(dwGuildID);
+
+#if defined(__GUILD_EVENT_FLAG__) //&& defined(__GUILD_RENEWAL__)
+		CGuildManager::Instance().RequestSetEventFlag(dwGuildID, "create_time", get_global_time());
+#endif
+	}
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   œøœ¥."));
+}
+
+void CInputMain::PartyUseSkill(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGPartyUseSkill* p = (TPacketCGPartyUseSkill*)c_pData;
+	if (!ch->GetParty())
+		return;
+
+	if (ch->GetPlayerID() != ch->GetParty()->GetLeaderPID())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º> ∆º  ∆ºÂ∏∏   ÷Ωœ¥."));
+		return;
+	}
+
+	switch (p->bySkillIndex)
+	{
+		case PARTY_SKILL_HEAL:
+			ch->GetParty()->HealParty();
+			break;
+		case PARTY_SKILL_WARP:
+		{
+			LPCHARACTER pch = CHARACTER_MANAGER::instance().Find(p->vid);
+			if (pch && pch->IsPC())
+				ch->GetParty()->SummonToLeader(pch->GetPlayerID());
+			else
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<∆º> »Øœ∑  √£  œ¥."));
+		}
+		break;
+	}
+}
+
+void CInputMain::PartyParameter(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGPartyParameter* p = (TPacketCGPartyParameter*)c_pData;
+
+	if (ch->GetParty() && ch->GetParty()->GetLeaderPID() == ch->GetPlayerID())
+		ch->GetParty()->SetParameter(p->bDistributeMode);
+}
+
+size_t GetSubPacketSize(const GUILD_SUBHEADER_CG& header)
+{
+	switch (header)
+	{
+		case GUILD_SUBHEADER_CG_DEPOSIT_MONEY: return sizeof(int);
+		case GUILD_SUBHEADER_CG_WITHDRAW_MONEY: return sizeof(int);
+		case GUILD_SUBHEADER_CG_ADD_MEMBER: return sizeof(DWORD);
+		case GUILD_SUBHEADER_CG_REMOVE_MEMBER: return sizeof(DWORD);
+		case GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME: return 10;
+		case GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY: return sizeof(BYTE) + sizeof(BYTE);
+		case GUILD_SUBHEADER_CG_OFFER: return sizeof(DWORD);
+		case GUILD_SUBHEADER_CG_CHARGE_GSP: return sizeof(int);
+		case GUILD_SUBHEADER_CG_POST_COMMENT: return 1;
+		case GUILD_SUBHEADER_CG_DELETE_COMMENT: return sizeof(DWORD);
+		case GUILD_SUBHEADER_CG_REFRESH_COMMENT: return 0;
+		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE: return sizeof(DWORD) + sizeof(BYTE);
+		case GUILD_SUBHEADER_CG_USE_SKILL: return sizeof(TPacketCGGuildUseSkill);
+		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL: return sizeof(DWORD) + sizeof(BYTE);
+		case GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER: return sizeof(DWORD) + sizeof(BYTE);
+	}
+
+	return 0;
+}
+
+int CInputMain::Guild(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	if (uiBytes < sizeof(TPacketCGGuild))
+		return -1;
+
+	const TPacketCGGuild* p = reinterpret_cast<const TPacketCGGuild*>(data);
+	const char* c_pData = data + sizeof(TPacketCGGuild);
+
+	uiBytes -= sizeof(TPacketCGGuild);
+
+	const GUILD_SUBHEADER_CG SubHeader = static_cast<GUILD_SUBHEADER_CG>(p->subheader);
+	const size_t SubPacketLen = GetSubPacketSize(SubHeader);
+
+	if (uiBytes < SubPacketLen)
+	{
+		return -1;
+	}
+
+	CGuild* pGuild = ch->GetGuild();
+
+	if (NULL == pGuild)
+	{
+		if (SubHeader != GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER)
+		{
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> Âø°   Ωœ¥."));
+			return SubPacketLen;
+		}
+	}
+
+	switch (SubHeader)
+	{
+		case GUILD_SUBHEADER_CG_DEPOSIT_MONEY:
+		{
+			// by mhh : ⁄± –∞   .
+			return SubPacketLen;
+
+			const int gold = MIN(*reinterpret_cast<const int*>(c_pData), __deposit_limit());
+
+			if (gold < 0)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> ﬂ∏ ›æ‘¥œ¥."));
+				return SubPacketLen;
+			}
+
+			if (ch->GetGold() < gold)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  ÷¥  ’¥œ¥."));
+				return SubPacketLen;
+			}
+
+			pGuild->RequestDepositMoney(ch, gold);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_WITHDRAW_MONEY:
+		{
+			// by mhh : ⁄± –∞   .
+			return SubPacketLen;
+
+			const int gold = MIN(*reinterpret_cast<const int*>(c_pData), 500000);
+
+			if (gold < 0)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> ﬂ∏ ›æ‘¥œ¥."));
+				return SubPacketLen;
+			}
+
+			pGuild->RequestWithdrawMoney(ch, gold);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_ADD_MEMBER:
+		{
+			const DWORD vid = *reinterpret_cast<const DWORD*>(c_pData);
+			LPCHARACTER newmember = CHARACTER_MANAGER::instance().Find(vid);
+
+			if (!newmember)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<\xb1\xe6\xb5\xe5> \xb1◊∑\xaf\xc7\xd1 \xbb\xe7\xb6\xf7\xc0\xbb √£\xc0\xbb \xbc\xf6 \xbe\xf8\xbd\xc0\xb4œ¥\xd9."));
+				return SubPacketLen;
+			}
+
+			if (!ch->IsPC() || !newmember->IsPC())
+				return SubPacketLen;
+
+			if (ch->IsDead() || newmember->IsDead())
+				return SubPacketLen;
+
+			// Visibility / world safety: must be in-world and same map
+			if (!ch->GetSectree() || !newmember->GetSectree())
+				return SubPacketLen;
+			if (ch->GetMapIndex() != newmember->GetMapIndex())
+				return SubPacketLen;
+
+			// Proximity enforcement (same as shop interaction distance)
+			if (ch->GetDist(newmember) >= SHOP_MAX_DISTANCE)
+				return SubPacketLen;
+
+#if defined(__MESSENGER_BLOCK_SYSTEM__)
+			if (CMessengerManager::instance().IsBlocked(ch->GetName(), newmember->GetName()))
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Unblock %s to continue.", newmember->GetName()));
+				return SubPacketLen;
+			}
+			else if (CMessengerManager::instance().IsBlocked(newmember->GetName(), ch->GetName()))
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("%s has blocked you.", newmember->GetName()));
+				return SubPacketLen;
+			}
+#endif
+
+			if (newmember->GetQuestFlag("change_guild_master.be_other_member") > get_global_time())
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>     ƒ≥‘¥œ¥"));
+				return SubPacketLen;
+			}
+
+			pGuild->Invite(ch, newmember);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_REMOVE_MEMBER:
+		{
+			if (pGuild->UnderAnyWar() != 0)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  ﬂø  ≈ª≈≥  œ¥."));
+				return SubPacketLen;
+			}
+
+			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			LPCHARACTER member = CHARACTER_MANAGER::instance().FindByPID(pid);
+
+			if (member)
+			{
+				if (member->GetGuild() != pGuild)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   Â∞° ∆¥’¥œ¥."));
+					return SubPacketLen;
+				}
+
+				if (!pGuild->HasGradeAuth(m->grade, GUILD_AUTH_REMOVE_MEMBER))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   ≈ª ≈≥  œ¥."));
+					return SubPacketLen;
+				}
+
+				member->SetQuestFlag("guild_manage.new_withdraw_time", get_global_time());
+				pGuild->RequestRemoveMember(member->GetPlayerID());
+
+				if (LC_IsBrazil() == true)
+				{
+					DBManager::instance().Query("REPLACE INTO guild_invite_limit VALUES(%d, %d)", pGuild->GetID(), get_global_time());
+				}
+			}
+			else
+			{
+				if (!pGuild->HasGradeAuth(m->grade, GUILD_AUTH_REMOVE_MEMBER))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   ≈ª ≈≥  œ¥."));
+					return SubPacketLen;
+				}
+
+				if (pGuild->RequestRemoveMember(pid))
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   ≈ª ◊Ωœ¥."));
+				else
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> ◊∑  √£  œ¥."));
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME:
+		{
+			char gradename[GUILD_GRADE_NAME_MAX_LEN + 1];
+			strlcpy(gradename, c_pData + 1, sizeof(gradename));
+
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			if (m->grade != GUILD_LEADER_GRADE)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  Ã∏   œ¥."));
+			}
+			else if (*c_pData == GUILD_LEADER_GRADE)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>   Ã∏   œ¥."));
+			}
+			else if (!check_name(gradename))
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>    Ã∏ ‘¥œ¥."));
+			}
+			else
+			{
+				pGuild->ChangeGradeName(*c_pData, gradename);
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY:
+		{
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			if (m->grade != GUILD_LEADER_GRADE)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>     œ¥."));
+			}
+			else if (*c_pData == GUILD_LEADER_GRADE)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>     œ¥."));
+			}
+			else
+			{
+				pGuild->ChangeGradeAuth(*c_pData, *(c_pData + 1));
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_OFFER:
+		{
+			DWORD offer = *reinterpret_cast<const DWORD*>(c_pData);
+
+			if (pGuild->GetLevel() >= GUILD_MAX_LEVEL && LC_IsHongKong() == false)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> Â∞° Ãπ ÷∞ ‘¥œ¥."));
+			}
+			else
+			{
+				offer /= 100;
+				offer *= 100;
+
+				if (pGuild->OfferExp(ch, offer))
+				{
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+					ch->UpdateExtBattlePassMissionProgress(GUILD_SPENT_EXP, offer, 0);
+#endif
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> %u ƒ° œøœ¥.", offer));
+				}
+				else
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> ƒ° ⁄ø œøœ¥."));
+				}
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_CHARGE_GSP:
+		{
+			const int offer = *reinterpret_cast<const int*>(c_pData);
+			const int gold = offer * 100;
+
+			if (offer < 0 || gold < offer || gold < 0 || ch->GetGold() < gold)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  ’¥œ¥."));
+				return SubPacketLen;
+			}
+
+			if (!pGuild->ChargeSP(ch, offer))
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> ≈∑ »∏ œøœ¥."));
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_POST_COMMENT:
+		{
+			const size_t length = *c_pData;
+
+			if (length > GUILD_COMMENT_MAX_LEN)
+			{
+				// ﬂ∏ .. .
+				sys_err("POST_COMMENT: %s comment too long (length: %u)", ch->GetName(), length);
+				ch->GetDesc()->SetPhase(PHASE_CLOSE);
+				return -1;
+			}
+
+			if (uiBytes < 1 + length)
+				return -1;
+
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			if (length && !pGuild->HasGradeAuth(m->grade, GUILD_AUTH_NOTICE) && *(c_pData + 1) == '!')
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>  €º  œ¥."));
+			}
+			else
+			{
+				std::string str(c_pData + 1, length);
+				pGuild->AddComment(ch, str);
+			}
+
+			return (1 + length);
+		}
+
+		case GUILD_SUBHEADER_CG_DELETE_COMMENT:
+		{
+			const DWORD comment_id = *reinterpret_cast<const DWORD*>(c_pData);
+
+			pGuild->DeleteComment(ch, comment_id);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_REFRESH_COMMENT:
+			pGuild->RefreshComment(ch);
+			return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE:
+		{
+			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
+			const BYTE grade = *(c_pData + sizeof(DWORD));
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			if (m->grade != GUILD_LEADER_GRADE)
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>    œ¥."));
+			else if (ch->GetPlayerID() == pid)
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>     œ¥."));
+			else if (grade == 1)
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<>     œ¥."));
+			else
+				pGuild->ChangeMemberGrade(pid, grade);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_USE_SKILL:
+		{
+			const TPacketCGGuildUseSkill* p = reinterpret_cast<const TPacketCGGuildUseSkill*>(c_pData);
+
+			pGuild->UseSkill(p->dwVnum, ch, p->dwPID);
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL:
+		{
+			const DWORD pid = *reinterpret_cast<const DWORD*>(c_pData);
+			const BYTE is_general = *(c_pData + sizeof(DWORD));
+			const TGuildMember* m = pGuild->GetMember(ch->GetPlayerID());
+
+			if (NULL == m)
+				return -1;
+
+			if (m->grade != GUILD_LEADER_GRADE)
+			{
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> Â±∫   œ¥."));
+			}
+			else
+			{
+				if (!pGuild->ChangeMemberGeneral(pid, is_general))
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("<> Ãª    œ¥."));
+				}
+			}
+		}
+		return SubPacketLen;
+
+		case GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER:
+		{
+			const DWORD guild_id = *reinterpret_cast<const DWORD*>(c_pData);
+			const BYTE accept = *(c_pData + sizeof(DWORD));
+
+			CGuild* g = CGuildManager::instance().FindGuild(guild_id);
+
+			if (g)
+			{
+				if (accept)
+					g->InviteAccept(ch);
+				else
+					g->InviteDeny(ch->GetPlayerID());
+			}
+		}
+		return SubPacketLen;
+
+	}
+
+	return 0;
+}
+
+void CInputMain::Fishing(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGFishing* p = (TPacketCGFishing*)c_pData;
+	ch->SetRotation(p->dir * 5);
+	ch->fishing();
+	return;
+}
+
+#if defined(__FISHING_GAME__)
+#include "fishing.h"
+void CInputMain::FishingGame(const LPCHARACTER c_lpChar, const char* c_pszData)
+{
+	const TPacketCGFishingGame* c_pData = reinterpret_cast<const TPacketCGFishingGame*>(c_pszData);
+	if (c_pData == nullptr || c_lpChar == nullptr)
+		return;
+
+	const LPITEM c_lpFishingRod = c_lpChar->GetWear(WEAR_WEAPON);
+	if (c_lpFishingRod && c_lpFishingRod->GetType() == ITEM_ROD)
+	{
+		if (c_lpChar->m_pkFishingEvent)
+		{
+			switch (c_pData->bSubHeader)
+			{
+				case FISHING_GAME_SUBHEADER_GOAL:
+				{
+					c_lpChar->SetFishingGameGoals(c_pData->bGoals);
+					if (c_lpChar->GetFishingGameGoals() >= 3)
+						c_lpChar->fishing();
+				}
+				break;
+
+				case FISHING_GAME_SUBHEADER_QUIT:
+				{
+					event_cancel(&c_lpChar->m_pkFishingEvent);
+					c_lpFishingRod->SetSocket(2, 0);
+					fishing::FishingFail(c_lpChar);
+				}
+				break;
+			};
+		}
+	}
+}
+#endif
+
+void CInputMain::ItemGive(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGGiveItem* p = (TPacketCGGiveItem*)c_pData;
+	LPCHARACTER to_ch = CHARACTER_MANAGER::instance().Find(p->dwTargetVID);
+
+	if (to_ch)
+		ch->GiveItem(to_ch, p->ItemPos);
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING(" «≥  œ¥."));
+}
+
+void CInputMain::Hack(LPCHARACTER ch, const char* c_pData)
+{
+	TPacketCGHack* p = (TPacketCGHack*)c_pData;
+
+	char buf[sizeof(p->szBuf)];
+	strlcpy(buf, p->szBuf, sizeof(buf));
+
+	sys_err("HACK_DETECT: %s %s", ch->GetName(), buf);
+
+	//  ≈¨Ãæ∆Æ  ≈∂  Ï∞° «∑   —¥
+	ch->GetDesc()->SetPhase(PHASE_CLOSE);
+}
+
+#if defined(__MYSHOP_DECO__)
+void CInputMain::MyShopDecoState(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGMyShopDecoState* p = (TPacketCGMyShopDecoState*)c_pData;
+	ch->SetMyShopDecoState(p->bState);
+}
+
+void CInputMain::MyShopDecoAdd(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGMyShopDecoAdd* p = (TPacketCGMyShopDecoAdd*)c_pData;
+	if (ch->GetMyShopDecoState())
+	{
+		if (p->dwPolyVnum < 30000 && p->dwPolyVnum > 30008)
+		{
+			sys_err("MyShopDecoAdd : Unknown PolyVnum");
+			return;
+		}
+
+		ch->SetMyShopDecoType(p->bType);
+		ch->SetMyShopDecoPolyVnum(p->dwPolyVnum);
+
+#if defined(__MYSHOP_EXPANSION__)
+		//ch->OpenPrivateShop(2, true);
+		// NOTE : Ideally, the Kashmir Bundle should have the same benefits as the Silk Bundle.
+		ch->UseSilkBotary();
+#else
+		ch->OpenPrivateShop(1, true);
+#endif
+	}
+	else
+	{
+		sys_err("MyShopDecoAdd : Unknown State");
+		return;
+	}
+}
+#endif
+
+int CInputMain::MyShop(LPCHARACTER ch, const char* c_pData, size_t uiBytes)
+{
+	const TPacketCGMyShop* p = (TPacketCGMyShop*)c_pData;
+	const int iExtraLen = p->bCount * sizeof(TShopItemTable);
+
+	if (uiBytes < sizeof(TPacketCGMyShop) + iExtraLen)
+		return -1;
+
+	if (ch->GetGold() >= GOLD_MAX)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  20 —æ ≈∑ €º œ¥."));
+		sys_log(0, "MyShop ==> OverFlow Gold id %u name %s ", ch->GetPlayerID(), ch->GetName());
+		return (iExtraLen);
+	}
+
+#if defined(__CHEQUE_SYSTEM__)
+	if (ch->GetCheque() > CHEQUE_MAX)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("  20 —æ ≈∑ €º œ¥."));
+		sys_log(0, "MyShop ==> OverFlow Cheque id %u name %s ", ch->GetPlayerID(), ch->GetName());
+		return (iExtraLen);
+	}
+#endif
+
+	if (ch->IsStun() || ch->IsDead())
+		return (iExtraLen);
+
+	if (ch->PreventTradeWindow(WND_MYSHOP, true/*except*/))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Ÿ∏ ≈∑œ∞ Œª  œ¥."));
+		return (iExtraLen);
+	}
+
+	sys_log(0, "MyShop count %u", p->bCount);
+	const TShopItemTable* pTable = reinterpret_cast<const TShopItemTable*>(c_pData + sizeof(TPacketCGMyShop));
+	for (BYTE i = 0; i < p->bCount; ++i)
+	{
+		// [BUNDLE_15][Security] Prevent price overflow/zero-price abuse (tax bypass / item transfer)
+		if (pTable[i].price == 0 || pTable[i].price > GOLD_MAX)
+		{
+			sys_err("HACK_DETECT: %s invalid shop price=%u (slot %u)", ch->GetName(), pTable[i].price, i);
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Invalid shop price."));
+			return (iExtraLen);
+		}
+#if defined(__CHEQUE_SYSTEM__)
+		if (pTable[i].cheque > CHEQUE_MAX)
+		{
+			sys_err("HACK_DETECT: %s invalid shop cheque=%u (slot %u)", ch->GetName(), pTable[i].cheque, i);
+			ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Invalid shop price."));
+			return (iExtraLen);
+		}
+#endif
+	}
+
+	ch->OpenMyShop(p->szSign, (TShopItemTable*)(c_pData + sizeof(TPacketCGMyShop)), p->bCount);
+	return (iExtraLen);
+}
+
+void CInputMain::Refine(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGRefine* p = reinterpret_cast<const TPacketCGRefine*>(c_pData);
+
+	if (ch->PreventTradeWindow(WND_REFINE, true/*except*/))
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√¢,≈∑√¢  ¬ø  “º œ¥"));
+		ch->ClearRefineMode();
+		return;
+	}
+
+	if (p->type == 255)
+	{
+		// DoRefine Cancel
+		ch->ClearRefineMode();
+		return;
+	}
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+	if (p->pos >= ch->GetExtendInvenMax())
+#else
+	if (p->pos >= INVENTORY_MAX_NUM)
+#endif
+	{
+		ch->ClearRefineMode();
+		return;
+	}
+
+	LPITEM item = ch->GetInventoryItem(p->pos);
+	if (!item)
+	{
+		ch->ClearRefineMode();
+		return;
+	}
+
+	ch->SetRefineTime();
+
+	if (p->type == REFINE_TYPE_NORMAL)
+	{
+		sys_log(0, "refine_type_noraml");
+		ch->DoRefine(item);
+	}
+	else if (p->type == REFINE_TYPE_SCROLL
+		|| p->type == REFINE_TYPE_NOT_USED1
+		|| p->type == REFINE_TYPE_HYUNIRON
+		|| p->type == REFINE_TYPE_MUSIN
+		|| p->type == REFINE_TYPE_BDRAGON
+#if defined(__STONE_OF_BLESS__)
+		|| p->type == REFINE_TYPE_BLESSING_STONE
+#endif
+		)
+	{
+		sys_log(0, "refine_type_scroll, ...");
+		ch->DoRefineWithScroll(item);
+	}
+#if defined(__SOUL_SYSTEM__)
+	else if (p->type == REFINE_TYPE_SOUL_AWAKE || p->type == REFINE_TYPE_SOUL_EVOLVE)
+	{
+		ch->DoRefineSoul(item);
+	}
+#endif
+	else if (p->type == REFINE_TYPE_MONEY_ONLY)
+	{
+		const LPITEM item = ch->GetInventoryItem(p->pos);
+
+		if (NULL != item)
+		{
+			if (500 <= item->GetRefineSet())
+			{
+				LogManager::instance().HackLog("DEVIL_TOWER_REFINE_HACK", ch);
+			}
+			else
+			{
+				if (ch->GetQuestFlag("deviltower_zone.can_refine"))
+				{
+					ch->DoRefine(item, true);
+					ch->SetQuestFlag("deviltower_zone.can_refine", 0);
+				}
+				else
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, " ≈∏ œ∑  —π Î∞°’¥œ¥.");
+				}
+			}
+		}
+	}
+
+	ch->ClearRefineMode();
+}
+
+#if defined(__CUBE_RENEWAL__)
+void CInputMain::Cube(const LPCHARACTER pChar, const char* pData)
+{
+	const TPacketCGCube* pPacket = reinterpret_cast<const TPacketCGCube*>(pData);
+	if (pPacket == nullptr)
+		return;
+
+	const DWORD dwFileCrc = CCubeManager::Instance().GetFileCrc();
+	if (pPacket->dwFileCrc != dwFileCrc)
+	{
+		const char* szSubHeader[] = {
+			{ "SUBHEADER_CG_CUBE_CLOSE" },
+			{ "SUBHEADER_CG_CUBE_MAKE" },
+		};
+
+		if (test_server)
+			pChar->ChatPacket(CHAT_TYPE_INFO, "cube crc mismatch: %u != %u",
+				pPacket->dwFileCrc, dwFileCrc);
+
+		sys_log(0, "cube: recv %s ch %s file crc mismatch: %u != %u",
+			szSubHeader[pPacket->bSubHeader], pChar->GetName(),
+			pPacket->dwFileCrc, dwFileCrc);
+
+		LogManager::instance().CharLog(pChar, 0, "CUBE FILE MISMATCH", "");
+		CCubeManager::Instance().CloseCube(pChar);
+	}
+
+	if (pChar->PreventTradeWindow(WND_CUBE, true/*except*/))
+	{
+		pChar->ChatPacket(CHAT_TYPE_INFO, LC_STRING("√¢,≈∑√¢  ¬ø  “º œ¥"));
+		return;
+	}
+
+	switch (pPacket->bSubHeader)
+	{
+		case SUBHEADER_CG_CUBE_CLOSE:
+			CCubeManager::Instance().CloseCube(pChar);
+			break;
+
+		case SUBHEADER_CG_CUBE_MAKE:
+			CCubeManager::Instance().MakeCube(pChar, pPacket->iCubeIndex, pPacket->iQuantity, pPacket->iImproveItemPos);
+			break;
+	}
+}
+#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+void CInputMain::ItemCombination(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGItemCombination* p = reinterpret_cast<const TPacketCGItemCombination*>(c_pData);
+
+	ch->ItemCombination(p->MediumIndex, p->BaseIndex, p->MaterialIndex);
+}
+
+void CInputMain::ItemCombinationCancel(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGItemCombinationCancel* p = reinterpret_cast<const TPacketCGItemCombinationCancel*>(c_pData);
+
+	ch->SetItemCombNpc(NULL);
+}
+#endif
+
+#if defined(__CHANGED_ATTR__)
+void CInputMain::ItemSelectAttr(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGItemSelectAttr* p = reinterpret_cast<const TPacketCGItemSelectAttr*>(c_pData);
+
+	ch->SelectAttrResult(p->bNew, p->pItemPos);
+}
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+static size_t GetAcceSubPacketLength(const ESubHeaderCGAcceRefine& eSubHeader)
+{
+	switch (eSubHeader)
+	{
+		case ACCE_REFINE_SUBHEADER_CG_CHECKIN:
+			return sizeof(TSubPacketCGAcceRefineCheckIn);
+		case ACCE_REFINE_SUBHEADER_CG_CHECKOUT:
+			return sizeof(TSubPacketCGAcceRefineCheckOut);
+		case ACCE_REFINE_SUBHEADER_CG_ACCEPT:
+			return sizeof(TSubPacketCGAcceRefineAccept);
+		case ACCE_REFINE_SUBHEADER_CG_CANCEL:
+			return 0;
+	}
+	return 0;
+}
+
+int CInputMain::AcceRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes)
+{
+	if (uiBytes < sizeof(TPacketCGAcceRefine))
+		return -1;
+
+	const TPacketCGAcceRefine* pPacket = reinterpret_cast<const TPacketCGAcceRefine*>(pszData);
+	const char* pszDataPacket = pszData + sizeof(TPacketCGAcceRefine);
+
+	uiBytes -= sizeof(TPacketCGAcceRefine);
+
+	const ESubHeaderCGAcceRefine eSubHeader = static_cast<ESubHeaderCGAcceRefine>(pPacket->bSubHeader);
+	const size_t uiSubPacketLength = GetAcceSubPacketLength(eSubHeader);
+	if (uiBytes < uiSubPacketLength)
+	{
+		sys_err("Invalid AcceRefine SubPacket length (SubPacketLength %d Size %u Buffer %u)", uiSubPacketLength, sizeof(TPacketCGAcceRefine), uiBytes);
+		return -1;
+	}
+
+	switch (eSubHeader)
+	{
+		case ACCE_REFINE_SUBHEADER_CG_CHECKIN:
+		{
+			const TSubPacketCGAcceRefineCheckIn* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineCheckIn*>(pszDataPacket);
+			pChar->AcceRefineWindowCheckIn(pSubPacket->bType, pSubPacket->SelectedPos, pSubPacket->AttachedPos);
+		}
+		return uiSubPacketLength;
+
+		case ACCE_REFINE_SUBHEADER_CG_CHECKOUT:
+		{
+			const TSubPacketCGAcceRefineCheckOut* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineCheckOut*>(pszDataPacket);
+			pChar->AcceRefineWindowCheckOut(pSubPacket->bType, pSubPacket->SelectedPos);
+		}
+		return uiSubPacketLength;
+
+		case ACCE_REFINE_SUBHEADER_CG_ACCEPT:
+		{
+			const TSubPacketCGAcceRefineAccept* pSubPacket = reinterpret_cast<const TSubPacketCGAcceRefineAccept*>(pszDataPacket);
+			pChar->AcceRefineWindowAccept(pSubPacket->bType);
+		}
+		return uiSubPacketLength;
+
+		case ACCE_REFINE_SUBHEADER_CG_CANCEL:
+		{
+			pChar->AcceRefineWindowClose();
+		}
+		return uiSubPacketLength;
+	}
+
+	return 0;
+}
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+static size_t GetAuraSubPacketLength(const ESubHeaderCGAuraRefine& eSubHeader)
+{
+	switch (eSubHeader)
+	{
+		case AURA_REFINE_SUBHEADER_CG_CHECKIN:
+			return sizeof(TSubPacketCGAuraRefineCheckIn);
+		case AURA_REFINE_SUBHEADER_CG_CHECKOUT:
+			return sizeof(TSubPacketCGAuraRefineCheckOut);
+		case AURA_REFINE_SUBHEADER_CG_ACCEPT:
+			return sizeof(TSubPacketCGAuraRefineAccept);
+		case AURA_REFINE_SUBHEADER_CG_CANCEL:
+			return 0;
+	}
+	return 0;
+}
+
+int CInputMain::AuraRefine(const LPCHARACTER pChar, const char* pszData, size_t uiBytes)
+{
+	if (uiBytes < sizeof(TPacketCGAuraRefine))
+		return -1;
+
+	const TPacketCGAuraRefine* pPacket = reinterpret_cast<const TPacketCGAuraRefine*>(pszData);
+	const char* pszDataPacket = pszData + sizeof(TPacketCGAuraRefine);
+
+	uiBytes -= sizeof(TPacketCGAuraRefine);
+
+	const ESubHeaderCGAuraRefine eSubHeader = static_cast<ESubHeaderCGAuraRefine>(pPacket->bSubHeader);
+	const size_t uiSubPacketLength = GetAuraSubPacketLength(eSubHeader);
+	if (uiBytes < uiSubPacketLength)
+	{
+		sys_err("Invalid AuraRefine SubPacket length (SubPacketLength %d Size %u Buffer %u)", uiSubPacketLength, sizeof(TPacketCGAuraRefine), uiBytes);
+		return -1;
+	}
+
+	switch (eSubHeader)
+	{
+		case AURA_REFINE_SUBHEADER_CG_CHECKIN:
+		{
+			const TSubPacketCGAuraRefineCheckIn* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineCheckIn*>(pszDataPacket);
+			pChar->AuraRefineWindowCheckIn(c_pSubPacket->bType, c_pSubPacket->SelectedPos, c_pSubPacket->AttachedPos);
+		}
+		return uiSubPacketLength;
+
+		case AURA_REFINE_SUBHEADER_CG_CHECKOUT:
+		{
+			const TSubPacketCGAuraRefineCheckOut* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineCheckOut*>(pszDataPacket);
+			pChar->AuraRefineWindowCheckOut(c_pSubPacket->bType, c_pSubPacket->SelectedPos);
+		}
+		return uiSubPacketLength;
+
+		case AURA_REFINE_SUBHEADER_CG_ACCEPT:
+		{
+			const TSubPacketCGAuraRefineAccept* c_pSubPacket = reinterpret_cast<const TSubPacketCGAuraRefineAccept*>(pszDataPacket);
+			pChar->AuraRefineWindowAccept(c_pSubPacket->bType);
+		}
+		return uiSubPacketLength;
+
+		case AURA_REFINE_SUBHEADER_CG_CANCEL:
+		{
+			pChar->AuraRefineWindowClose();
+		}
+		return uiSubPacketLength;
+	}
+
+	return 0;
+}
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+void CInputMain::ChangeLook(LPCHARACTER lpCh, const char* c_pszData)
+{
+	const TPacketCGChangeLook* c_pData = reinterpret_cast<const TPacketCGChangeLook*>(c_pszData);
+
+	CChangeLook* pChangeLook = lpCh->GetChangeLook();
+	if (pChangeLook == nullptr)
+		return;
+
+	switch (static_cast<EPacketCGChangeLookSubHeader>(c_pData->bSubHeader))
+	{
+		case EPacketCGChangeLookSubHeader::ITEM_CHECK_IN:
+			pChangeLook->ItemCheckIn(c_pData->ItemPos, c_pData->bSlotIndex);
+			break;
+		case EPacketCGChangeLookSubHeader::ITEM_CHECK_OUT:
+			pChangeLook->ItemCheckOut(c_pData->bSlotIndex);
+			break;
+		case EPacketCGChangeLookSubHeader::FREE_ITEM_CHECK_IN:
+			pChangeLook->FreeItemCheckIn(c_pData->ItemPos);
+			break;
+		case EPacketCGChangeLookSubHeader::FREE_ITEM_CHECK_OUT:
+			pChangeLook->FreeItemCheckOut();
+			break;
+		case EPacketCGChangeLookSubHeader::ACCEPT:
+			pChangeLook->Accept();
+			break;
+		case EPacketCGChangeLookSubHeader::CANCEL:
+			lpCh->SetChangeLook(nullptr);
+			break;
+		default:
+			sys_err("Unknown Subheader ch:%s, %d", lpCh->GetName(), c_pData->bSubHeader);
+			return;
+	}
+}
+#endif
+
+#if defined(__SEND_TARGET_INFO__)
+void CInputMain::TargetInfo(LPCHARACTER pChar, const char* c_pszData)
+{
+	const TPacketCGTargetInfo* c_pData = reinterpret_cast<const TPacketCGTargetInfo*>(c_pszData);
+	const LPCHARACTER pkTarget = CHARACTER_MANAGER::instance().Find(c_pData->dwVID);
+	if (pChar == nullptr || pkTarget == nullptr)
+		return;
+
+	if (!pChar->GetDesc())
+		return;
+
+	const DWORD dwVID = pkTarget->GetVID();
+	const DWORD dwRaceVnum = pkTarget->GetRaceNum();
+
+	if (pkTarget->IsMonster() || pkTarget->IsStone())
+	{
+		MonsterItemDropMap ItemDropMap; bool bDropMetinStone = false;
+		ITEM_MANAGER::instance().GetMonsterItemDropMap(pkTarget, pChar, ItemDropMap, bDropMetinStone);
+
+		TEMP_BUFFER TempBuffer;
+		for (const MonsterItemDropMap::value_type& it : ItemDropMap)
+		{
+			TPacketGCTargetDropInfo DropInfoPacket;
+			DropInfoPacket.dwVnum = it.first;
+			DropInfoPacket.bCount = it.second;
+			TempBuffer.write(&DropInfoPacket, sizeof(DropInfoPacket));
+		}
+
+		TPacketGCTargetInfo TargetInfoPacket;
+		TargetInfoPacket.bHeader = HEADER_GC_TARGET_INFO;
+		TargetInfoPacket.wSize = sizeof(TargetInfoPacket) + TempBuffer.size();
+		TargetInfoPacket.dwRaceVnum = dwRaceVnum;
+		TargetInfoPacket.dwVID = dwVID;
+		TargetInfoPacket.bDropMetinStone = bDropMetinStone;
+
+		if (TempBuffer.size())
+		{
+			pChar->GetDesc()->BufferedPacket(&TargetInfoPacket, sizeof(TargetInfoPacket));
+			pChar->GetDesc()->Packet(TempBuffer.read_peek(), TempBuffer.size());
+		}
+		else
+			pChar->GetDesc()->Packet(&TargetInfoPacket, sizeof(TargetInfoPacket));
+	}
+
+	pChar->ChatPacket(CHAT_TYPE_COMMAND, "RefreshMonsterDropInfo %d", pkTarget->GetRaceNum());
+}
+#endif
+
+#if defined(__SKILLBOOK_COMB_SYSTEM__)
+bool CInputMain::SkillBookCombination(LPCHARACTER ch, TItemPos(&CombItemGrid)[SKILLBOOK_COMB_SLOT_MAX], BYTE bAction)
+{
+	if (!ch->GetDesc())
+		return false;
+
+	// if (CombItemGrid.empty())
+		// return false;
+
+	if (ch->PreventTradeWindow(WND_ALL))
+		return false;
+
+	if (bAction != 2/*COMBI_START*/)
+		return false;
+
+	std::set <LPITEM> set_items;
+	for (int i = 0; i < SKILLBOOK_COMB_SLOT_MAX; i++)
+	{
+		LPITEM pItem = ch->GetItem(CombItemGrid[i]);
+		if (pItem)
+		{
+			if (pItem->GetType() != ITEM_SKILLBOOK)
+				return false;
+
+			set_items.insert(pItem);
+		}
+	}
+
+	if (set_items.empty())
+		return false;
+
+	if (ch->GetGold() < SKILLBOOK_COMB_COST)
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You don't have enough Yang to trade books with me."));
+		return false;
+	}
+
+	for (std::set <LPITEM>::iterator it = set_items.begin(); it != set_items.end(); ++it)
+	{
+		LPITEM pItem = *it;
+		if (pItem)
+		{
+			pItem->SetCount(pItem->GetCount() - 1);
+			//pItem->RemoveFromCharacter();
+			//M2_DESTROY_ITEM(pItem);
+		}
+	}
+
+	DWORD dwBooks[JOB_MAX_NUM][2/*SKILL_GROUPS*/][2] = {
+		{ // 0 - Warrior
+			{50401, 50406}, // Skill Group 1
+			{50416, 50421}, // Skill Group 2
+		},
+		{ // 1 - Ninja
+			{50431, 50436}, // Skill Group 1
+			{50446, 50451}, // Skill Group 2
+		},
+		{ // 2 - Sura
+			{50461, 50466}, // Skill Group 1
+			{50476, 50481}, // Skill Group 2
+		},
+		{ // 3 - Shaman
+			{50491, 50496}, // Skill Group 1
+			{50506, 50511}, // Skill Group 2
+		},
+		{ // 4 - Wolfman
+			{50530, 50535}, // Skill Group 1
+			{0, 0}, // Skill Group 2
+		},
+	};
+
+	ch->PointChange(POINT_GOLD, -SKILLBOOK_COMB_COST);
+
+	if (ch->GetSkillGroup() != 0)
+	{
+		DWORD dwMinRandomBook = dwBooks[ch->GetJob()][ch->GetSkillGroup() - 1][0];
+		DWORD dwMaxRandomBook = dwBooks[ch->GetJob()][ch->GetSkillGroup() - 1][1];
+
+		std::random_device rd;
+		std::mt19937 gen(rd());
+		std::uniform_real_distribution<> dis(dwMinRandomBook, dwMaxRandomBook);
+		DWORD dwRandomBook = dis(gen);
+
+		ch->AutoGiveItem(dwRandomBook, 1);
+	}
+	else
+		ch->AutoGiveItem(ITEM_SKILLBOOK_VNUM, 1);
+
+	return true;
+}
+#endif
+
+#if defined(__MAILBOX__)
+void CInputMain::MailboxWrite(LPCHARACTER ch, const char* c_pData)
+{
+	const auto* p = reinterpret_cast<const TPacketCGMailboxWrite*>(c_pData);
+	if (p == nullptr)
+		return;
+
+	CMailBox* mail = ch->GetMailBox();
+	if (mail == nullptr)
+		return;
+
+	mail->Write(p->szName, p->szTitle, p->szMessage, p->pos, p->iYang, p->iWon);
+}
+
+void CInputMain::MailboxConfirm(LPCHARACTER ch, const char* c_pData)
+{
+	const auto* p = reinterpret_cast<const TPacketCGMailboxWriteConfirm*>(c_pData);
+	if (p == nullptr)
+		return;
+
+	CMailBox* mail = ch->GetMailBox();
+	if (mail == nullptr)
+		return;
+
+	mail->CheckPlayer(p->szName);
+}
+
+void CInputMain::MailboxProcess(LPCHARACTER ch, const char* c_pData)
+{
+	const auto* p = reinterpret_cast<const TPacketMailboxProcess*>(c_pData);
+	if (p == nullptr)
+		return;
+
+	CMailBox* mail = ch->GetMailBox();
+	if (mail == nullptr)
+		return;
+
+	switch (p->bSubHeader)
+	{
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_CLOSE:
+			ch->SetMailBox(nullptr);
+			break;
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_DELETE:
+			mail->DeleteMail(p->bArg1, false);
+			break;
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_DELETE:
+			mail->DeleteAllMails();
+			break;
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_GET_ITEMS:
+			mail->GetItem(p->bArg1, false);
+			break;
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ALL_GET_ITEMS:
+			mail->GetAllItems();
+			break;
+		case CMailBox::EMAILBOX_CG::MAILBOX_CG_ADD_DATA:
+			mail->AddData(p->bArg1, p->bArg2);
+			break;
+		default:
+			sys_err("CInputMain::MailboxProcess Unknown SubHeader (ch: %s) (%d)", ch->GetName(), p->bSubHeader);
+			break;
+	}
+}
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+void CInputMain::MiniGameRumi(LPCHARACTER pChar, const char* pszData)
+{
+	const TPacketCGMiniGameRumi* pkData = reinterpret_cast<const TPacketCGMiniGameRumi*>(pszData);
+	if (pkData == nullptr)
+		return;
+
+	switch (pkData->bSubHeader)
+	{
+		case RUMI_CG_SUBHEADER_END:
+			CMiniGameRumi::EndGame(pChar);
+			break;
+
+		case RUMI_CG_SUBHEADER_START:
+			CMiniGameRumi::StartGame(pChar);
+			break;
+
+		case RUMI_CG_SUBHEADER_DECK_CARD_CLICK:
+		case RUMI_CG_SUBHEADER_HAND_CARD_CLICK:
+		case RUMI_CG_SUBHEADER_FIELD_CARD_CLICK:
+			CMiniGameRumi::Analyze(pChar, pkData->bSubHeader, pkData->bUseCard, pkData->bIndex);
+			break;
+
+#if defined(__OKEY_EVENT_FLAG_RENEWAL__)
+		case RUMI_CG_SUBHEADER_REQUEST_QUEST_FLAG:
+			CMiniGameRumi::RequestQuestFlag(pChar, RUMI_GC_SUBHEADER_SET_QUEST_FLAG);
+			break;
+#endif
+
+		default:
+			sys_err("CInputMain::MiniGameRumi Unknown SubHeader (ch: %s) (%d)", pChar->GetName(), pkData->bSubHeader);
+			break;
+	}
+}
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__)
+void CInputMain::MiniGameYutnori(LPCHARACTER pChar, const char* pszData)
+{
+	const TPacketCGMiniGameYutnori* pkData = reinterpret_cast<const TPacketCGMiniGameYutnori*>(pszData);
+	if (pkData == nullptr)
+	{
+		sys_err("CInputMain::MiniGameYutnori - Null Data! (ch: %s)", pChar->GetName());
+		return;
+	}
+
+	switch (pkData->bSubHeader)
+	{
+		case YUTNORI_CG_SUBHEADER_START:
+			CMiniGameYutnori::Create(pChar);
+			break;
+
+		case YUTNORI_CG_SUBHEADER_GIVEUP:
+			CMiniGameYutnori::Destroy(pChar);
+			break;
+
+#if defined(__YUTNORI_EVENT_FLAG_RENEWAL__)
+		case YUTNORI_CG_SUBHEADER_REQUEST_QUEST_FLAG:
+			CMiniGameYutnori::RequestQuestFlag(pChar, YUTNORI_GC_SUBHEADER_SET_QUEST_FLAG);
+			break;
+#endif
+
+		default:
+			CMiniGameYutnori::Analyze(pChar, pkData->bSubHeader, pkData->bArgument);
+			break;
+	}
+}
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+void CInputMain::LootFilter(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGLootFilter* p = reinterpret_cast<const TPacketCGLootFilter*>(c_pData);
+	if (ch->GetLootFilter())
+		ch->GetLootFilter()->SetLootFilterSettings(p->settings);
+}
+#endif
+
+#if defined(__GEM_SHOP__)
+void CInputMain::GemShop(LPCHARACTER c_lpCh, const char* c_pszData)
+{
+	const TPacketCGGemShop* c_pPacket = reinterpret_cast<const TPacketCGGemShop*>(c_pszData);
+	if (c_pPacket == nullptr)
+		return;
+
+	CGemShop* pGemShop = c_lpCh->GetGemShop();
+	if (pGemShop == nullptr)
+		return;
+
+	switch (c_pPacket->bSubHeader)
+	{
+		case SUBHEADER_GEM_SHOP_CLOSE:
+			c_lpCh->SetGemShop(nullptr);
+			break;
+		case SUBHEADER_GEM_SHOP_BUY:
+			pGemShop->Buy(c_pPacket->bSlotIndex);
+			break;
+		case SUBHEADER_GEM_SHOP_SLOT_ADD:
+			pGemShop->AddSlot();
+			break;
+		case SUBHEADER_GEM_SHOP_REFRESH:
+			pGemShop->Refresh();
+			break;
+		default:
+			sys_err("CInputMain::GemShop Unknown SubHeader (ch: %s) (%d)", c_lpCh->GetName(), c_pPacket->bSubHeader);
+			break;
+	}
+}
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+void CInputMain::Attr67Add(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGAttr67Add* pkPacket = (TPacketCGAttr67Add*)c_pData;
+	switch (pkPacket->bySubHeader)
+	{
+		case SUBHEADER_CG_ATTR67_ADD_CLOSE:
+			ch->SetOpenAttr67Add(false);
+			break;
+		case SUBHEADER_CG_ATTR67_ADD_OPEN:
+			if (!ch->IsOpenAttr67Add())
+				ch->SetOpenAttr67Add(true);
+			break;
+		case SUBHEADER_CG_ATTR67_ADD_REGIST:
+			if (ch->IsOpenAttr67Add())
+				ch->Attr67Add(pkPacket->Attr67AddData);
+			break;
+		default:
+			return;
+	}
+}
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+void CInputMain::ExtendInven(LPCHARACTER pChar, const char* c_pszData)
+{
+	const TPacketCGExtendInven* pPacket = reinterpret_cast<const TPacketCGExtendInven*>(c_pszData);
+	if (pPacket == nullptr)
+		return;
+
+	if (pPacket->bUpgrade)
+		pChar->ExtendInvenUpgrade();
+	else
+		pChar->ExtendInvenRequest();
+}
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+void CInputMain::SnowflakeStickEvent(LPCHARACTER pChar, const char* c_pszData)
+{
+	const TPacketCGSnowflakeStickEvent* pPacket = reinterpret_cast<const TPacketCGSnowflakeStickEvent*>(c_pszData);
+	if (pPacket == nullptr)
+		return;
+
+	switch (pPacket->bSubHeader)
+	{
+		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_REQUEST_INFO:
+			CSnowflakeStickEvent::Process(pChar, SNOWFLAKE_STICK_EVENT_GC_SUBHEADER_EVENT_INFO);
+			break;
+
+		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_STICK:
+		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_PET:
+		case SNOWFLAKE_STICK_EVENT_CG_SUBHEADER_EXCHANGE_MOUNT:
+			CSnowflakeStickEvent::Exchange(pChar, pPacket->bSubHeader);
+			break;
+
+		default:
+			return;
+	}
+}
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+void CInputMain::RefineElement(LPCHARACTER pChar, const char* c_pszData)
+{
+	const TPacketCGRefineElement* pPacket = reinterpret_cast<const TPacketCGRefineElement*>(c_pszData);
+	if (pPacket == nullptr)
+		return;
+
+	switch (pPacket->bSubHeader)
+	{
+		case REFINE_ELEMENT_CG_CLOSE:
+			pChar->SetUnderRefineElement(false);
+			break;
+
+		case REFINE_ELEMENT_CG_REFINE:
+			pChar->RefineElement(pPacket->wChangeElement);
+			break;
+
+		default:
+			sys_err("CInputMain::RefineElement: %s received unknown sub header.", pChar->GetName());
+			break;
+	}
+}
+#endif
+
+#if defined(__LEFT_SEAT__)
+void CInputMain::LeftSeat(LPCHARACTER pChar, const char* c_pszData)
+{
+	const TPacketCGLeftSeat* c_pPacket = reinterpret_cast<const TPacketCGLeftSeat*>(c_pszData);
+	if (c_pPacket == nullptr)
+		return;
+
+	switch (c_pPacket->bSubHeader)
+	{
+		case LEFT_SEAT_SET_WAIT_TIME_INDEX:
+			pChar->SetLeftSeatWaitTime(c_pPacket->bIndex);
+			break;
+
+		case LEFT_SEAT_SET_LOGOUT_TIME_INDEX:
+			pChar->SetLeftSeatLogoutTime(c_pPacket->bIndex);
+			break;
+
+		case LEFT_SEAT_DISABLE_LOGOUT_STATE:
+			pChar->DisableLeftSeatLogOutState(false);
+			break;
+
+		default:
+			sys_err("CInputMain::LeftSeat: %s received unknown sub header.", pChar->GetName());
+			break;
+	}
+}
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+void CInputMain::MiniGameRoulette(LPCHARACTER pChar, const char* pszData)
+{
+	const TPacketCGMiniGameRoulette* pData = reinterpret_cast<const TPacketCGMiniGameRoulette*>(pszData);
+	if (pData == nullptr)
+	{
+		sys_err("CInputMain::MiniGameRoulette : Data NULL (ch: %s)", pChar->GetName());
+		return;
+	}
+
+	CMiniGameRoulette* pMiniGameRoulette = pChar->GetMiniGameRoulette();
+	if (pMiniGameRoulette == nullptr)
+	{
+		sys_err("CInputMain::MiniGameRoulette : MiniGameRoulette NULL (ch: %s)", pChar->GetName());
+		return;
+	}
+
+	switch (pData->bSubHeader)
+	{
+		case ROULETTE_CG_START:
+			pMiniGameRoulette->Start();
+			break;
+
+		case ROULETTE_CG_REQUEST:
+			pMiniGameRoulette->Request();
+			break;
+
+		case ROULETTE_CG_END:
+			pMiniGameRoulette->End();
+			break;
+
+		case ROULETTE_CG_CLOSE:
+			pMiniGameRoulette->Close();
+			break;
+
+		default:
+			sys_err("CInputMain::MiniGameRoulette : Unknown SubHeader %u (ch: %s)",
+				pData->bSubHeader, pChar->GetName());
+			break;
+	}
+}
+#endif
+
+#if defined(__FLOWER_EVENT__)
+void CInputMain::FlowerEvent(LPCHARACTER pChar, const char* pszData)
+{
+	if (!quest::CQuestManager::instance().GetEventFlag("e_flower_drop"))
+		return;
+
+	const TPacketCGFlowerEvent* pPacketData = reinterpret_cast<const TPacketCGFlowerEvent*>(pszData);
+	if (NULL == pPacketData)
+	{
+		sys_err("NULL TPacketCGFlowerEvent (ch: %s)", pChar->GetName());
+		return;
+	}
+
+	switch (pPacketData->bSubHeader)
+	{
+		case FLOWER_EVENT_SUBHEADER_CG_INFO_ALL:
+			CFlowerEvent::RequestAllInfo(pChar);
+			break;
+
+		case FLOWER_EVENT_SUBHEADER_CG_EXCHANGE:
+			CFlowerEvent::Exchange(pChar, pPacketData->bShootType, pPacketData->bExchangeKey);
+			break;
+
+		default:
+			sys_err("Unknown SubHeader %u (ch: %s)",
+				pPacketData->bSubHeader, pChar->GetName());
+			break;
+	}
+}
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+int CInputMain::ReciveExtBattlePassActions(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	TPacketCGExtBattlePassAction* p = (TPacketCGExtBattlePassAction*)data;
+
+	if (uiBytes < sizeof(TPacketCGExtBattlePassAction))
+		return -1;
+
+	const char* c_pData = data + sizeof(TPacketCGExtBattlePassAction);
+	uiBytes -= sizeof(TPacketCGExtBattlePassAction);
+
+	switch (p->bAction)
+	{
+		case 1:
+			CBattlePassManager::instance().BattlePassRequestOpen(ch);
+			return 0;
+
+		case 2:
+			const DWORD dwNow = get_dword_time();
+			if ((int)(dwNow - ch->GetLastReciveExtBattlePassOpenRanking()) < 0) {
+				ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NEXT_REFRESH_RANKLIST_TIME"), (((int)(ch->GetLastReciveExtBattlePassOpenRanking() - dwNow)) / 1000) + 1 );
+				return 0;
+			}
+			ch->SetLastReciveExtBattlePassOpenRanking(dwNow + 10000);
+			
+			for (BYTE bBattlePassType = 1; bBattlePassType <= 3 ; ++bBattlePassType)
+			{
+				BYTE bBattlePassID;
+				if (bBattlePassType == 1)
+					bBattlePassID = CBattlePassManager::instance().GetNormalBattlePassID();
+				if (bBattlePassType == 2){
+					bBattlePassID = CBattlePassManager::instance().GetPremiumBattlePassID();
+					if (bBattlePassID != ch->GetExtBattlePassPremiumID())
+						continue;
+				}
+				if (bBattlePassType == 3)
+					bBattlePassID = CBattlePassManager::instance().GetEventBattlePassID();
+
+				std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("SELECT player_name, battlepass_type+0, battlepass_id, UNIX_TIMESTAMP(start_time), UNIX_TIMESTAMP(end_time) FROM player.battlepass_playerindex WHERE battlepass_type = %d and battlepass_id = %d and battlepass_completed = 1 and not player_name LIKE '[%%' ORDER BY (UNIX_TIMESTAMP(end_time)-UNIX_TIMESTAMP(start_time)) ASC LIMIT 40", bBattlePassType, bBattlePassID));
+				if (pMsg->uiSQLErrno)
+					return 0;
+
+				MYSQL_ROW row;
+
+				while ((row = mysql_fetch_row(pMsg->Get()->pSQLResult)))
+				{
+					TPacketGCExtBattlePassRanking pack;
+					pack.bHeader = HEADER_GC_EXT_BATTLE_PASS_SEND_RANKING;
+					strlcpy(pack.szPlayerName, row[0], sizeof(pack.szPlayerName));
+					pack.bBattlePassType = std::atoi(row[1]);
+					pack.bBattlePassID = std::atoll(row[2]);
+					pack.dwStartTime = std::atoll(row[3]);
+					pack.dwEndTime = std::atoll(row[4]);
+
+					ch->GetDesc()->Packet(&pack, sizeof(pack));
+				}
+			}
+			break;
+
+		case 10:
+			CBattlePassManager::instance().BattlePassRequestReward(ch, 1);
+			return 0;
+			
+		case 11:
+			CBattlePassManager::instance().BattlePassRequestReward(ch, 2);
+			return 0;
+			
+		case 12:
+			CBattlePassManager::instance().BattlePassRequestReward(ch, 3);
+			return 0;
+
+
+		default:
+			break;
+	}
+
+	return 0;
+}
+
+int CInputMain::ReciveExtBattlePassPremiumItem(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	TPacketCGExtBattlePassSendPremiumItem* p = (TPacketCGExtBattlePassSendPremiumItem*)data;
+
+	if (uiBytes < sizeof(TPacketCGExtBattlePassSendPremiumItem))
+		return -1;
+
+	const char* c_pData = data + sizeof(TPacketCGExtBattlePassSendPremiumItem);
+	uiBytes -= sizeof(TPacketCGExtBattlePassSendPremiumItem);
+
+	LPITEM item = ch->GetInventoryItem(p->iSlotIndex);
+	if (item != NULL and item->GetVnum() == 93100)
+	{
+		ch->PointChange(POINT_BATTLE_PASS_PREMIUM_ID, CBattlePassManager::instance().GetPremiumBattlePassID());
+		CBattlePassManager::instance().BattlePassRequestOpen(ch);
+		item->SetCount(item->GetCount() - 1);
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("BATTLEPASS_NOW_IS_ACTIVATED_PREMIUM_BATTLEPASS_OWN"));
+	}
+	return 0;
+}
+#endif
+
+int CInputMain::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
+{
+	LPCHARACTER ch;
+
+	if (!(ch = d->GetCharacter()))
+	{
+		sys_err("no character on desc");
+		d->SetPhase(PHASE_CLOSE);
+		return (0);
+	}
+
+	int iExtraLen = 0;
+
+	// Phase hardening: if this processor is invoked outside GAME phase,
+	// treat it as a protocol violation (prevents cross-phase packet injection).
+	if (d->GetPhase() != PHASE_GAME)
+	{
+		sys_err("CInputMain::Analyze called in non-GAME phase (phase=%d header=%d)", d->GetPhase(), bHeader);
+		d->SetPhase(PHASE_CLOSE);
+		return 0;
+	}
+
+	if (test_server && bHeader != HEADER_CG_MOVE)
+		sys_log(0, "CInputMain::Analyze() ==> Header [%d] ", bHeader);
+
+#if defined(__LEFT_SEAT__)
+	const std::unordered_set<BYTE> bExcludeLeftSeatHeader = {
+		HEADER_CG_LEFT_SEAT,
+		HEADER_CG_TIME_SYNC,
+		HEADER_CG_PONG,
+	};
+
+	if (bExcludeLeftSeatHeader.find(bHeader) == bExcludeLeftSeatHeader.end())
+	{
+		if (ch->LeftSeat())
+			ch->DisableLeftSeatLogOutState(true);
+
+		ch->SetLastRequestTime(get_dword_time());
+	}
+#endif
+
+	switch (bHeader)
+	{
+		case HEADER_CG_PONG:
+			Pong(d);
+			break;
+
+		case HEADER_CG_TIME_SYNC:
+			Handshake(d, c_pData);
+			break;
+
+		case HEADER_CG_CHAT:
+			if (test_server)
+			{
+				char* pBuf = (char*)c_pData;
+				sys_log(0, "%s", pBuf + sizeof(TPacketCGChat));
+			}
+
+			if ((iExtraLen = Chat(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+
+			break;
+
+		case HEADER_CG_WHISPER:
+			if ((iExtraLen = Whisper(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_MOVE:
+			Move(ch, c_pData);
+			break;
+
+		case HEADER_CG_CHARACTER_POSITION:
+			Position(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_USE:
+			if (!ch->IsObserverMode())
+				ItemUse(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_DROP:
+			if (!ch->IsObserverMode())
+			{
+				ItemDrop(ch, c_pData);
+			}
+			break;
+
+		case HEADER_CG_ITEM_DROP2:
+			if (!ch->IsObserverMode())
+				ItemDrop2(ch, c_pData);
+			break;
+
+#if defined(__NEW_DROP_DIALOG__)
+		case HEADER_CG_ITEM_DESTROY:
+			if (!ch->IsObserverMode())
+				ItemDestroy(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_ITEM_MOVE:
+			if (!ch->IsObserverMode())
+				ItemMove(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_PICKUP:
+			if (!ch->IsObserverMode())
+				ItemPickup(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_USE_TO_ITEM:
+			if (!ch->IsObserverMode())
+				ItemToItem(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_GIVE:
+			if (!ch->IsObserverMode())
+				ItemGive(ch, c_pData);
+			break;
+
+		case HEADER_CG_EXCHANGE:
+			if (!ch->IsObserverMode())
+				Exchange(ch, c_pData);
+			break;
+
+		case HEADER_CG_ATTACK:
+		case HEADER_CG_SHOOT:
+			if (!ch->IsObserverMode())
+			{
+				Attack(ch, bHeader, c_pData);
+			}
+			break;
+
+		case HEADER_CG_USE_SKILL:
+			if (!ch->IsObserverMode())
+				UseSkill(ch, c_pData);
+			break;
+
+#ifdef __OFFLINE_SHOP__
+		case HEADER_CG_OFFLINE_SHOP:
+		{
+			if ((iExtraLen = COfflineShop::ReceivePacket(ch, c_pData, m_iBufferLeft)) < 0) {
+				return -1;
+			}
+
+			break;
+		}
+#endif
+
+#ifdef __SHOP_SEARCH__
+		case HEADER_CG_SHOP_SEARCH_BY_NAME:
+			ShopSearchByName(ch, c_pData);
+			break;
+
+		case HEADER_CG_SHOP_SEARCH_BY_OPTION:
+			if ((iExtraLen = ShopSearchByOptions(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_SHOP_SEARCH_BUY:
+			ShopSearchBuy(ch, c_pData);
+			break;
+
+		case HEADER_CG_SHOP_SEARCH_OWNER_MESSAGE:
+			ShopSearchOwnerMessage(ch, c_pData);
+			break;
+
+		case HEADER_CG_SHOP_SEARCH_REQUEST_SOLD_INFO:
+			ShopSearchRequestSoldInfo(ch, c_pData);
+			break;
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+		case HEADER_CG_PET_HATCH:
+			PetHatch(ch, c_pData);
+			break;
+
+		case HEADER_CG_PET_WINDOW:
+			PetWindow(ch, c_pData);
+			break;
+
+		case HEADER_CG_PET_WINDOW_TYPE:
+			PetWindowType(ch, c_pData);
+			break;
+
+		case HEADER_CG_PET_NAME_CHANGE:
+			PetNameChange(ch, c_pData);
+			break;
+
+		case HEADER_CG_PET_FEED:
+			PetFeed(ch, c_pData);
+			break;
+
+		case HEADER_CG_PET_DETERMINE:
+			PetDetermine(ch, c_pData);
+			break;
+
+		case HEADER_CG_PET_ATTR_CHANGE:
+			PetAttrChange(ch, c_pData);
+			break;
+
+		case HEADER_CG_PET_REVIVE:
+			PetRevive(ch, c_pData);
+			break;
+
+		case HEADER_CG_PET_LEARN_SKILL:
+			PetLearnSkill(ch, c_pData);
+			break;
+
+		case HEADER_CG_PET_SKILL_UPGRADE:
+			PetSkillUpgrade(ch, c_pData);
+			break;
+
+		case HEADER_CG_PET_DELETE_SKILL:
+			PetDeleteSkill(ch, c_pData);
+			break;
+
+		case HEADER_CG_PET_DELETE_ALL_SKILL:
+			PetDeleteAllSkill(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_QUICKSLOT_ADD:
+			QuickslotAdd(ch, c_pData);
+			break;
+
+		case HEADER_CG_QUICKSLOT_DEL:
+			QuickslotDelete(ch, c_pData);
+			break;
+
+		case HEADER_CG_QUICKSLOT_SWAP:
+			QuickslotSwap(ch, c_pData);
+			break;
+
+		case HEADER_CG_SHOP:
+			if ((iExtraLen = Shop(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_MESSENGER:
+			if ((iExtraLen = Messenger(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_ON_CLICK:
+			OnClick(ch, c_pData);
+			break;
+
+		case HEADER_CG_SYNC_POSITION:
+			if ((iExtraLen = SyncPosition(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_ADD_FLY_TARGETING:
+		case HEADER_CG_FLY_TARGETING:
+			FlyTarget(ch, c_pData, bHeader);
+			break;
+
+		case HEADER_CG_SCRIPT_BUTTON:
+			ScriptButton(ch, c_pData);
+			break;
+
+			// SCRIPT_SELECT_ITEM
+		case HEADER_CG_SCRIPT_SELECT_ITEM:
+			ScriptSelectItem(ch, c_pData);
+			break;
+			// END_OF_SCRIPT_SELECT_ITEM
+
+		case HEADER_CG_SCRIPT_ANSWER:
+			ScriptAnswer(ch, c_pData);
+			break;
+
+#if defined(__GEM_SYSTEM__)
+		case HEADER_CG_SELECT_ITEM_EX:
+			SelectItemEx(ch, c_pData);
+			break;
+#endif
+
+#if defined(__QUEST_REQUEST_EVENT__)
+		case HEADER_CG_REQUEST_EVENT_QUEST:
+			RequestEventQuest(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_QUEST_INPUT_STRING:
+			QuestInputString(ch, c_pData);
+			break;
+
+#if defined(__OX_RENEWAL__)
+		case HEADER_CG_QUEST_INPUT_LONG_STRING:
+			QuestInputLongString(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_QUEST_CONFIRM:
+			QuestConfirm(ch, c_pData);
+			break;
+
+		case HEADER_CG_TARGET:
+			Target(ch, c_pData);
+			break;
+
+		case HEADER_CG_WARP:
+			Warp(ch, c_pData);
+			break;
+
+		case HEADER_CG_SAFEBOX_CHECKIN:
+			SafeboxCheckin(ch, c_pData);
+			break;
+
+		case HEADER_CG_SAFEBOX_CHECKOUT:
+			SafeboxCheckout(ch, c_pData, false);
+			break;
+
+		case HEADER_CG_SAFEBOX_ITEM_MOVE:
+			SafeboxItemMove(ch, c_pData);
+			break;
+
+		case HEADER_CG_MALL_CHECKOUT:
+			SafeboxCheckout(ch, c_pData, true);
+			break;
+
+		case HEADER_CG_PARTY_INVITE:
+			PartyInvite(ch, c_pData);
+			break;
+
+		case HEADER_CG_PARTY_REMOVE:
+			PartyRemove(ch, c_pData);
+			break;
+
+		case HEADER_CG_PARTY_INVITE_ANSWER:
+			PartyInviteAnswer(ch, c_pData);
+			break;
+
+		case HEADER_CG_PARTY_SET_STATE:
+			PartySetState(ch, c_pData);
+			break;
+
+		case HEADER_CG_PARTY_USE_SKILL:
+			PartyUseSkill(ch, c_pData);
+			break;
+
+		case HEADER_CG_PARTY_PARAMETER:
+			PartyParameter(ch, c_pData);
+			break;
+
+		case HEADER_CG_ANSWER_MAKE_GUILD:
+			AnswerMakeGuild(ch, c_pData);
+			break;
+
+		case HEADER_CG_GUILD:
+			if ((iExtraLen = Guild(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+		case HEADER_CG_FISHING:
+			Fishing(ch, c_pData);
+			break;
+
+#if defined(__FISHING_GAME__)
+		case HEADER_CG_FISHING_GAME:
+			FishingGame(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_HACK:
+			Hack(ch, c_pData);
+			break;
+
+		case HEADER_CG_MYSHOP:
+			if ((iExtraLen = MyShop(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+
+#if defined(__MYSHOP_DECO__)
+		case HEADER_CG_MYSHOP_DECO_STATE:
+			MyShopDecoState(ch, c_pData);
+			break;
+
+		case HEADER_CG_MYSHOP_DECO_ADD:
+			MyShopDecoAdd(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_REFINE:
+			Refine(ch, c_pData);
+			break;
+
+#if defined(__CUBE_RENEWAL__)
+		case HEADER_CG_CUBE:
+			Cube(ch, c_pData);
+			break;
+#endif
+
+		case HEADER_CG_CLIENT_VERSION:
+			Version(ch, c_pData);
+			break;
+
+#if defined(__DRAGON_SOUL_SYSTEM__)
+		case HEADER_CG_DRAGON_SOUL_REFINE:
+		{
+			TPacketCGDragonSoulRefine* p = reinterpret_cast <TPacketCGDragonSoulRefine*>((void*)c_pData);
+			// [BUNDLE_15][Security] Block Dragon Soul refine actions while trade/shop/cube windows are open
+			if (p->bSubType == DS_SUB_HEADER_DO_REFINE_GRADE || p->bSubType == DS_SUB_HEADER_DO_REFINE_STEP || p->bSubType == DS_SUB_HEADER_DO_REFINE_STRENGTH
+#if defined(__DS_CHANGE_ATTR__)
+				|| p->bSubType == DS_SUB_HEADER_DO_CHANGE_ATTR
+#endif
+				)
+			{
+				if (ch->GetExchange() || ch->GetShop() || ch->GetMyShop() || ch->IsCubeOpen()
+#ifdef __OFFLINE_SHOP__
+					|| ch->GetOfflineShop()
+#endif
+					)
+				{
+					ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("You cannot refine Dragon Soul items while another window is open."));
+					break;
+				}
+			}
+
+			switch (p->bSubType)
+			{
+				case DS_SUB_HEADER_CLOSE:
+					ch->DragonSoul_RefineWindow_Close();
+					break;
+
+				case DS_SUB_HEADER_DO_REFINE_GRADE:
+				{
+					DSManager::instance().DoRefineGrade(ch, p->ItemGrid);
+				}
+				break;
+
+				case DS_SUB_HEADER_DO_REFINE_STEP:
+				{
+					DSManager::instance().DoRefineStep(ch, p->ItemGrid);
+				}
+				break;
+
+				case DS_SUB_HEADER_DO_REFINE_STRENGTH:
+				{
+					DSManager::instance().DoRefineStrength(ch, p->ItemGrid);
+				}
+				break;
+
+#if defined(__DS_CHANGE_ATTR__)
+				case DS_SUB_HEADER_DO_CHANGE_ATTR:
+				{
+					DSManager::instance().DoChangeAttribute(ch, p->ItemGrid);
+				}
+				break;
+#endif
+			}
+		}
+		break;
+#endif
+
+#if defined(__SEND_TARGET_INFO__)
+		case HEADER_CG_TARGET_INFO:
+			TargetInfo(ch, c_pData);
+			break;
+#endif
+
+#if defined(__MOVE_COSTUME_ATTR__)
+		case HEADER_CG_ITEM_COMBINATION:
+			ItemCombination(ch, c_pData);
+			break;
+
+		case HEADER_CG_ITEM_COMBINATION_CANCEL:
+			ItemCombinationCancel(ch, c_pData);
+			break;
+#endif
+
+#if defined(__CHANGED_ATTR__)
+		case HEADER_CG_ITEM_SELECT_ATTR:
+			ItemSelectAttr(ch, c_pData);
+			break;
+#endif
+
+#if defined(__ACCE_COSTUME_SYSTEM__)
+		case HEADER_CG_ACCE_REFINE:
+			if ((iExtraLen = AcceRefine(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+#endif
+
+#if defined(__AURA_COSTUME_SYSTEM__)
+		case HEADER_CG_AURA_REFINE:
+			if ((iExtraLen = AuraRefine(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+#endif
+
+#if defined(__CHANGE_LOOK_SYSTEM__)
+		case HEADER_CG_CHANGE_LOOK:
+			ChangeLook(ch, c_pData);
+			break;
+#endif
+
+#if defined(__MINI_GAME_CATCH_KING__)
+		case HEADER_CG_MINI_GAME_CATCH_KING:
+			if ((iExtraLen = CMiniGameCatchKing::Process(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+#endif
+
+#if defined(__SKILLBOOK_COMB_SYSTEM__)
+		case HEADER_CG_SKILLBOOK_COMB:
+		{
+			TPacketCGSkillBookCombination* p = reinterpret_cast <TPacketCGSkillBookCombination*>((void*)c_pData);
+			SkillBookCombination(ch, p->CombItemGrid, p->bAction);
+		}
+		break;
+#endif
+
+#if defined(__MAILBOX__)
+		case HEADER_CG_MAILBOX_WRITE:
+			MailboxWrite(ch, c_pData);
+			break;
+
+		case HEADER_CG_MAILBOX_WRITE_CONFIRM:
+			MailboxConfirm(ch, c_pData);
+			break;
+
+		case HEADER_CG_MAILBOX_PROCESS:
+			MailboxProcess(ch, c_pData);
+			break;
+#endif
+
+#if defined(__LOOT_FILTER_SYSTEM__)
+		case HEADER_CG_LOOT_FILTER:
+			LootFilter(ch, c_pData);
+			break;
+#endif
+
+#if defined(__MINI_GAME_RUMI__)
+		case HEADER_CG_MINI_GAME_RUMI:
+			MiniGameRumi(ch, c_pData);
+			break;
+#endif
+
+#if defined(__MINI_GAME_YUTNORI__)
+		case HEADER_CG_MINI_GAME_YUTNORI:
+			MiniGameYutnori(ch, c_pData);
+			break;
+#endif
+
+#if defined(__LUCKY_BOX__)
+		case HEADER_CG_LUCKY_BOX:
+			LuckyBox(ch, c_pData);
+			break;
+#endif
+
+#if defined(__GEM_SHOP__)
+		case HEADER_CG_GEM_SHOP:
+			GemShop(ch, c_pData);
+			break;
+#endif
+
+#if defined(__EXTEND_INVEN_SYSTEM__)
+		case HEADER_CG_EXTEND_INVEN:
+			ExtendInven(ch, c_pData);
+			break;
+#endif
+
+#if defined(__ATTR_6TH_7TH__)
+		case HEADER_CG_ATTR67_ADD:
+			Attr67Add(ch, c_pData);
+			break;
+#endif
+
+#if defined(__SNOWFLAKE_STICK_EVENT__)
+		case HEADER_CG_SNOWFLAKE_STICK_EVENT:
+			SnowflakeStickEvent(ch, c_pData);
+			break;
+#endif
+
+#if defined(__REFINE_ELEMENT_SYSTEM__)
+		case HEADER_CG_REFINE_ELEMENT:
+			RefineElement(ch, c_pData);
+			break;
+#endif
+
+#if defined(__LEFT_SEAT__)
+		case HEADER_CG_LEFT_SEAT:
+			LeftSeat(ch, c_pData);
+			break;
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+		case HEADER_CG_MINI_GAME_ROULETTE:
+			MiniGameRoulette(ch, c_pData);
+			break;
+#endif
+
+#if defined(__SUMMER_EVENT_ROULETTE__)
+		case HEADER_CG_FLOWER_EVENT:
+			FlowerEvent(ch, c_pData);
+			break;
+#endif
+
+#ifdef ENABLE_EXTENDED_BATTLE_PASS
+		case HEADER_CG_EXT_BATTLE_PASS_ACTION:
+			if ((iExtraLen = ReciveExtBattlePassActions(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+			
+		case HEADER_CG_EXT_SEND_BP_PREMIUM_ITEM:
+			if ((iExtraLen = ReciveExtBattlePassPremiumItem(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+			break;
+#endif
+	}
+
+	return (iExtraLen);
+}
+
+#if defined(__LUCKY_BOX__)
+void CInputMain::LuckyBox(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGLuckyBox* c_pPacket = reinterpret_cast<const TPacketCGLuckyBox*>(c_pData);
+
+	switch (c_pPacket->bAction)
+	{
+		case ELUCKY_BOX_ACTION::LUCKY_BOX_ACTION_RETRY:
+			ch->LuckyBoxRetry();
+			break;
+		case ELUCKY_BOX_ACTION::LUCKY_BOX_ACTION_RECEIVE:
+			ch->LuckyBoxReceive();
+			break;
+		default:
+			sys_err("CInputMain::LuckyBox : Unknown action %d : %s", c_pPacket->bAction, ch->GetName());
+			return;
+	}
+}
+#endif
+
+#ifdef __SHOP_SEARCH__
+void CInputMain::ShopSearchByName(LPCHARACTER ch, const char* data)
+{
+	TPacketCGShopSearchByName* p = (TPacketCGShopSearchByName*)data;
+	CShopSearchManager::PC_RequestSearch(ch, p->itemName, p->page, p->entryCountIdx, p->sortType);
+}
+
+int CInputMain::ShopSearchByOptions(LPCHARACTER ch, const char* data, size_t uiBytes)
+{
+	TPacketCGShopSearchByOptions* p = (TPacketCGShopSearchByOptions*)data;
+	data += sizeof(TPacketCGShopSearchByOptions);
+	uiBytes -= sizeof(TPacketCGShopSearchByOptions);
+
+	if (uiBytes < sizeof(TShopSearchItemType) * p->options.typeFlagCount)
+		return -1;
+
+	TShopSearchItemType* itemTypeFlags = (TShopSearchItemType*)data;
+	data += sizeof(TShopSearchItemType) * p->options.typeFlagCount;
+	uiBytes -= sizeof(TShopSearchItemType) * p->options.typeFlagCount;
+
+	if (uiBytes < sizeof(DWORD) * p->options.specificVnumCount)
+		return -1;
+
+	CShopSearchManager::PC_RequestSearch(ch, &p->options, itemTypeFlags, (const DWORD*)data, p->page, p->entryCountIdx, p->sortType);
+
+	return sizeof(TShopSearchItemType) * p->options.typeFlagCount + sizeof(DWORD) * p->options.specificVnumCount;
+}
+
+void CInputMain::ShopSearchBuy(LPCHARACTER ch, const char* data)
+{
+	TPacketCGShopSearchBuy* p = (TPacketCGShopSearchBuy*)data;
+
+	CShopSearchManager::PC_RequestBuy(ch, p->itemID, p->itemVnum, p->itemPrice);
+}
+
+void CInputMain::ShopSearchOwnerMessage(LPCHARACTER ch, const char* data)
+{
+	TPacketCGShopSearchOwnerMessage* p = (TPacketCGShopSearchOwnerMessage*)data;
+
+	TPacketGCShopSearchOwnerMessage pack;
+	pack.header = HEADER_GC_SHOP_SEARCH_OWNER_MESSAGE;
+	memset(pack.ownerName, 0, sizeof(pack.ownerName));
+
+	if (LPCHARACTER tch = CHARACTER_MANAGER::instance().FindByPID(p->ownerID))
+		strlcpy(pack.ownerName, tch->GetName(), sizeof(pack.ownerName));
+	else if (CCI* pkCCI = P2P_MANAGER::instance().FindByPID(p->ownerID))
+		strlcpy(pack.ownerName, pkCCI->szName, sizeof(pack.ownerName));
+	else
+	{
+		std::unique_ptr<SQLMsg> pMsg(DBManager::instance().DirectQuery("SELECT name FROM player WHERE id = %u", p->ownerID));
+		if (MYSQL_ROW row = mysql_fetch_row(pMsg->Get()->pSQLResult))
+		{
+			strlcpy(pack.ownerName, row[0], sizeof(pack.ownerName));
+		}
+	}
+
+	ch->GetDesc()->Packet(&pack, sizeof(pack));
+}
+
+void CInputMain::ShopSearchRequestSoldInfo(LPCHARACTER ch, const char* data)
+{
+	TPacketCGShopSearchRequestSoldInfo* p = (TPacketCGShopSearchRequestSoldInfo*)data;
+
+	CShopSearchManager::PC_RequestSoldInfo(ch, p->itemVnum);
+}
+#endif
+
+#ifdef __GROWTH_PET_SYSTEM__
+void CInputMain::PetHatch(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetHatch* p = reinterpret_cast<const TPacketCGPetHatch*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+	
+	CGrowthPetManager::Instance().EggHatch(ch, p->name, p->eggPos);
+}
+
+void CInputMain::PetWindow(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetWindow* p = reinterpret_cast<const TPacketCGPetWindow*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	switch (p->window)
+	{
+		case PET_WINDOW_HATCH:
+			ch->SetPetHatchWindow(p->state);
+			break;
+
+		case PET_WINDOW_NAME_CHANGE:
+			ch->SetPetChangeNameWindow(p->state);
+			break;
+	}
+}
+
+void CInputMain::PetWindowType(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetWindowType* p = reinterpret_cast<const TPacketCGPetWindowType*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	BYTE bWindowType = p->type;
+
+	if (bWindowType == ch->GetPetWindowType())
+		return;
+
+	if (bWindowType == PET_WINDOW_ATTR_CHANGE || bWindowType == PET_WINDOW_PRIMIUM_FEEDSTUFF)
+	{
+
+		if ((ch->GetExchange() || ch->IsOpenSafebox() || ch->GetShopOwner()) || ch->IsCubeOpen())
+			return;
+	}
+
+	ch->SetPetWindowType(bWindowType);
+
+	TPacketGCPet packet;
+	packet.header = HEADER_GC_PET;
+	packet.subheader = SUBHEADER_PET_WINDOW_TYPE_INFO + bWindowType;
+
+	ch->GetDesc()->Packet(&packet, sizeof(packet));
+}
+
+void CInputMain::PetFeed(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetFeed* p = reinterpret_cast<const TPacketCGPetFeed*>(c_pData);
+	
+	if (!ch || !ch->GetDesc())
+		return;
+
+	if (ch->GetActiveGrowthPet())
+		ch->GetActiveGrowthPet()->Feed(p);
+	else
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
+}
+
+void CInputMain::PetDetermine(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetDetermine* p = reinterpret_cast<const TPacketCGPetDetermine*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pDetermineItem = ch->GetInventoryItem(p->determinePos.cell);
+	if (!pDetermineItem)
+		return;
+
+	if (pDetermineItem->GetType() != ITEM_PET || pDetermineItem->GetSubType() != PET_ATTR_DETERMINE)
+		return;
+
+	if (!ch->GetActiveGrowthPet())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
+		return;
+	}
+
+	ch->GetActiveGrowthPet()->AttrDetermine(pDetermineItem);
+}
+
+void CInputMain::PetAttrChange(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetAttrChange* p = reinterpret_cast<const TPacketCGPetAttrChange*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
+	if (!pUpBringingItem)
+		return;
+
+	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
+		return;
+
+	LPITEM pChangeAttrItem = ch->GetInventoryItem(p->attrChangePos.cell);
+	if (!pChangeAttrItem)
+		return;
+
+	if (pChangeAttrItem->GetType() != ITEM_PET || pChangeAttrItem->GetSubType() != PET_ATTR_CHANGE)
+		return;
+
+	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
+	if (!pPet)
+		return;
+
+	pPet->AttrChange(pUpBringingItem, pChangeAttrItem);
+}
+
+void CInputMain::PetRevive(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetRevive* p = reinterpret_cast<const TPacketCGPetRevive*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
+	if (!pUpBringingItem)
+		return;
+
+	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
+		return;
+
+	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
+	if (!pPet)
+		return;
+
+	pPet->PremiumFeed(p, pUpBringingItem);
+}
+
+void CInputMain::PetLearnSkill(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetLearnSkill* p = reinterpret_cast<const TPacketCGPetLearnSkill*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pSkillBookItem = ch->GetInventoryItem(p->learnSkillPos.cell);
+	if (!pSkillBookItem)
+		return;
+
+	if (pSkillBookItem->GetType() != ITEM_PET || pSkillBookItem->GetSubType() != PET_SKILL)
+		return;
+
+	if (!ch->GetActiveGrowthPet())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
+		return;
+	}
+
+	ch->GetActiveGrowthPet()->LearnSkill(p->slotIndex, pSkillBookItem);
+}
+
+void CInputMain::PetSkillUpgrade(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetSkillUpgrade* p = reinterpret_cast<const TPacketCGPetSkillUpgrade*>(c_pData);
+
+	if (!ch->GetActiveGrowthPet())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
+		return;
+	}
+
+	ch->GetActiveGrowthPet()->SkillUpgrade(p->slotIndex);
+}
+
+void CInputMain::PetDeleteSkill(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetDeleteSkill* p = reinterpret_cast<const TPacketCGPetDeleteSkill*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pDeleteSkillItem = ch->GetInventoryItem(p->deleteSkillPos.cell);
+	if (!pDeleteSkillItem)
+		return;
+
+	if (pDeleteSkillItem->GetType() != ITEM_PET || pDeleteSkillItem->GetSubType() != PET_SKILL_DEL_BOOK)
+		return;
+
+	if (!ch->GetActiveGrowthPet())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
+		return;
+	}
+
+	ch->GetActiveGrowthPet()->DeleteSkill(p->slotIndex, pDeleteSkillItem);
+}
+
+void CInputMain::PetDeleteAllSkill(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetDeleteAllSkill* p = reinterpret_cast<const TPacketCGPetDeleteAllSkill*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pDeleteAllSkillItem = ch->GetInventoryItem(p->deleteAllSkillPos.cell);
+	if (!pDeleteAllSkillItem)
+		return;
+
+	if (pDeleteAllSkillItem->GetType() != ITEM_PET || pDeleteAllSkillItem->GetSubType() != PET_SKILL_ALL_DEL_BOOK)
+		return;
+
+	if (!ch->GetActiveGrowthPet())
+	{
+		ch->ChatPacket(CHAT_TYPE_INFO, LC_STRING("Activate your pet first."));
+		return;
+	}
+
+	ch->GetActiveGrowthPet()->DeleteAllSkill(pDeleteAllSkillItem);
+}
+
+void CInputMain::PetNameChange(LPCHARACTER ch, const char* c_pData)
+{
+	const TPacketCGPetNameChange* p = reinterpret_cast<const TPacketCGPetNameChange*>(c_pData);
+
+	if (!ch || !ch->GetDesc())
+		return;
+
+	LPITEM pNameChangeItem = ch->GetInventoryItem(p->changeNamePos.cell);
+	if (!pNameChangeItem)
+		return;
+
+	if (pNameChangeItem->GetType() != ITEM_PET || pNameChangeItem->GetSubType() != PET_NAME_CHANGE)
+		return;
+
+	LPITEM pUpBringingItem = ch->GetInventoryItem(p->upBringingPos.cell);
+	if (!pUpBringingItem)
+		return;
+
+	if (pUpBringingItem->GetType() != ITEM_PET || pUpBringingItem->GetSubType() != PET_UPBRINGING)
+		return;
+
+	LPGROWTH_PET pPet = ch->GetGrowthPet(pUpBringingItem->GetSocket(2));
+	if (!pPet)
+		return;
+
+	if (pPet->GetOwner() != ch)
+		return;
+
+	pPet->NameChange(p->name, pNameChangeItem, pUpBringingItem);
+}
+#endif
+
+int CInputDead::Analyze(LPDESC d, BYTE bHeader, const char* c_pData)
+{
+	LPCHARACTER ch;
+
+	if (!(ch = d->GetCharacter()))
+	{
+		sys_err("no character on desc");
+		return 0;
+	}
+
+	int iExtraLen = 0;
+
+	switch (bHeader)
+	{
+		case HEADER_CG_PONG:
+			Pong(d);
+			break;
+
+		case HEADER_CG_TIME_SYNC:
+			Handshake(d, c_pData);
+			break;
+
+		case HEADER_CG_CHAT:
+			if ((iExtraLen = Chat(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+
+			break;
+
+		case HEADER_CG_WHISPER:
+			if ((iExtraLen = Whisper(ch, c_pData, m_iBufferLeft)) < 0)
+				return -1;
+
+			break;
+
+		case HEADER_CG_HACK:
+			Hack(ch, c_pData);
+			break;
+
+		default:
+			return (0);
+	}
+
+	return (iExtraLen);
+}
